{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"struct material {\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float specularPower;\n};\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n    vec3 bgLight = normalize(vec3(\n        cos(iTime*0.2/0.954929658551372)*4.0, \n        sin(iTime/1.1936620731892151)*3.0 - 4.0, \n        sin(iTime*0.2/0.954929658551372)*8.0\n    ));\n\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 sun = vec3(1.0, 1.0, 0.5);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.2, 0.7, 1.0);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.7);\n\tbgCol += vec3(0.2, 0.8, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.8, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    bgCol += vec3(1.2,0.4,0.9) * ((1.0-pow(abs(bgDiff), 0.6)));// * 1.0 * map(-nml) * map(-nml*nml.y));\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n    \nfloat sphereDet(vec3 ray, vec3 dir, vec3 center, float radius, inout float b)\n{\n\tvec3 rc = ray-center;  // 1\n\tfloat c = dot(rc, rc); // 1\n\tc -= radius*radius;    // 2?\n\tb = dot(dir, rc);      // 1\n\treturn b*b - c;        // 2?\n}\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tfloat b;\n\tfloat d = sphereDet(ray, dir, center, radius, b); // 7\n\tif (d < 0.0) { // 1\n\t\treturn closestHit;\n\t}\n\tfloat t = -b - sqrt(d); // 3\n\tif (t > 0.0 && t < closestHit) { // 2\n        nml = center - (ray+dir*t);\n        dst = m;\n\t} else {\n\t\tt = closestHit;\n\t}\n    return t;\n}\n\n// from http://stackoverflow.com/questions/4078401/trying-to-optimize-line-vs-cylinder-intersection\nfloat cylinder(vec3 ro, vec3 rd, vec3 cp, vec3 cd, float r, float closestHit, material m, inout vec3 nml, inout material dst) {\n\n    vec3 rc = ro - cp;\n    vec3 n = cross(rd, cd);\n\n    float len = length(n);\n\n    // Parallel? (?)\n    if(len < 0.00001 && len > 0.00001) {\n        return closestHit;\n    }\n\n    n = normalize(n);\n\n    float d = abs(dot(rc, n));\n\n    if (d <= r)\n    {\n        vec3 o = cross(rc, cd);\n        float t = -dot(o, n) / len;\n        o = normalize(cross(n, cd));\n        float s = abs( sqrt(r*r-d*d) / dot(rd, o) );\n        float inD = t-s;\n        float outD = t+s;\n        float lambda = outD;\n\n        if (inD < -0.00001) {\n            if(outD < -0.00001) {\n                return closestHit;\n            }\n        } else if (outD < -0.00001 || inD < outD) {\n            lambda = inD;\n        }\n        \n        if (lambda < closestHit) {\n            vec3 hb = (ro + rd*lambda) - cp;\n\n            float scale = dot(hb, cd);\n            nml = -normalize(hb - cd*scale);\n            dst = m;\n\n            return lambda;\n        }\n    }\n\n    return closestHit;\n}\n\nfloat triangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, float closestHit, material m, inout vec3 nml, inout material dst, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\t\n\tif (u < 0.0 || u > 1.0 || v < 0.0 || u+v > 1.0) {\n\t\treturn closestHit;\n\t}\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\t\n    if (t > closestHit || t <= 0.00001 || (a > -0.00001 && a < 0.00001)) {\n        return closestHit;\n    }\n    \n    nml = normalize(cross(e1, e2));\n    if (dot(nml, d) < 0.0) {\n        nml = -nml;\n    }\n    dst = m;\n\tuv = vec2(u,v);\n\n    return t;\n}\n\n\nfloat plane(vec3 rp, vec3 rd, vec3 p, vec3 pnml, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tfloat pd = dot(pnml, rd);\n\tfloat dist = dot(pnml, p-rp) / pd;\n\tif (abs(pd) > 0.00001 && dist > 0.0 && dist < closestHit) {\n\t\tnml = pnml;\n\t\tif (pd < 0.0) nml = -nml;\n\t\tclosestHit = dist;\n        dst = m;\n\t}\n\treturn closestHit;\n}\n\nfloat disk(vec3 rp, vec3 rd, vec3 p, vec3 pnml, float r1, float r2, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tvec3 tmp;\n    material tmpMat;\n\tfloat dist = plane(rp, rd, p, pnml, closestHit, m, tmp, tmpMat);\n\tfloat len = length(rp + dist*rd - p);\n\tif (dist < closestHit && len >= r1 && len <= r2) {\n\t\tnml = tmp;\n\t\tclosestHit = dist;\n        dst = m;\n\t}\n\treturn closestHit;\n}\n\nfloat scene(vec3 ro, vec3 rd, inout vec3 nml, inout material m) {\n    float closestHit = 1e5;\n    float t = iTime * 1.12346;\n    material red, blue, white;\n    \n    red.diffuseColor = vec3(1.0, 0.3, 0.1);\n    red.specularColor = vec3(1.0, 0.6, 0.3) * 2.0;\n    red.specularPower = 8.0;\n\n    blue.diffuseColor = vec3(0.2, 0.5, 1.0) * 2.0;\n    blue.specularColor = vec3(1.0);\n\tblue.specularPower = 32.0;\n\n    white.diffuseColor = vec3(0.1, 0.15, 0.2);\n    white.specularColor = vec3(0.25);\n    white.specularPower = 1024.0;\n    \n    vec2 uv = vec2(0);\n    \n    closestHit = sphere(ro, rd, vec3(cos(t)*2.0, sin(t*0.8)*3.0, 2.0+cos(t*0.5)*2.0), 1.0, closestHit, red, nml, m);\n    closestHit = sphere(ro, rd, vec3(cos(t*1.1)*3.0, sin(t*0.68)*4.0, 2.5+cos(t*0.65)*3.0), 1.0, closestHit, blue, nml, m);\n    //closestHit = plane(ro, rd, vec3(0.0, 7.0, 7.0), normalize(vec3(0.0, 1.0, 1.0)), closestHit, white, nml, m);\n    closestHit = triangle(ro, rd, vec3(1.0,0,7.0), vec3(6.0, 0, 7.0), vec3(1.0, 5.0, 7.0), closestHit, red, nml, m, uv);\n\n    closestHit = triangle(ro, rd, vec3(-0.0,0,7.0), vec3(-5.0, 0, 7.0), vec3(-0.0, 5.0, 7.0), closestHit, red, nml, m, uv);\n    //closestHit = triangle(ro, rd, vec3(-0.0,5.0,7.0), vec3(-5.0, 5.0, 7.0), vec3(-5.0, 0.0, 7.0), closestHit, blue, nml, m, uv);\n\n    closestHit = cylinder(ro, rd, vec3(0.0, 15.0, 0.0), normalize(vec3(sin(iTime+1.0), -1.0, 1.0)), 0.5, closestHit, blue, nml, m);\n    closestHit = cylinder(ro, rd, vec3(-8.0, 0.0, 0.0), normalize(vec3(1.0, cos(iTime), 1.0)), 1.0, closestHit, red, nml, m);\n    closestHit = cylinder(ro, rd, vec3(8.0, 0.0, 0.0), normalize(vec3(-1.0, sin(iTime), 1.0)), 1.5, closestHit, white, nml, m);\n    \n    return closestHit;\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec3 nml, material m) {\n    vec3 bgLight = normalize(vec3(\n        cos(iTime*0.2/0.954929658551372)*4.0, \n        sin(iTime/1.1936620731892151)*3.0 - 4.0, \n        sin(iTime*0.2/0.954929658551372)*8.0\n    ));\n\n    vec3 lightPos = bgLight * 1e5; //vec3(4.0)*vec3(sin(iTime*0.3), cos(iTime*0.7), sin(iTime));\n    material shadowMat;\n    vec3 lightVec = (lightPos - ro);\n    float lightDist = length(lightVec);\n    vec3 lightDir = normalize(lightVec);\n    float diffuse = dot(nml, -lightDir);\n    float diffuseStep = (diffuse > 0.0 && m.specularPower > 0.0 ? 1.0 : 0.0);\n    float specular = diffuseStep * pow(clamp(dot(lightDir, rd), 0.0, 1.0), m.specularPower);\n    ro += rd * 0.005;\n    float shadow = 0.0;\n    float r = 0.2;\n    vec3 lX = normalize(cross(lightDir, vec3(1.0, 0.0, 0.0)));\n    vec3 lY = normalize(cross(lightDir, lX));\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n/*\n\tlightDir = normalize(lightPos + r * lX - ro);\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n    lightDir = normalize(lightPos + -r * lX - ro);\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n    lightDir = normalize(lightPos + r * lY - ro);\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n    lightDir = normalize(lightPos + -r * lY - ro);\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n    shadow /= 5.0;\n*/\n    return shadow * ( m.diffuseColor*max(0.0, diffuse) + m.specularColor*specular ) + max(0.0, -diffuse)*vec3(0.1, 0.15, 0.2);        \n}\n\nvec3 trace(vec2 xy) {\n    vec2 uv = 1.0 - 2.0 * xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -8.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 nml = vec3(1.0);\n    material m;\n    vec3 transmit = vec3(1.0);\n    for (int i = 0; i < 3; i++) {\n\t    float closestHit = scene(ro, rd, nml, m);\n\t    if (closestHit < 1e5) {\n            ro += rd * closestHit;\n            nml = normalize(nml);\n            rd = reflect(rd, nml);\n            col += transmit * shade(ro, rd, nml, m);\n            transmit *= m.specularColor;\n            ro += rd * 0.01;\n        } else {\n            col += transmit * 0.2 * shadeBg(rd, xy);\n            break;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col = vec3(0.0);\n    col += trace(fragCoord.xy);\n    col += trace(fragCoord.xy+vec2(0.5, 0.0));\n    col += trace(fragCoord.xy+vec2(0.0, 0.5));\n    col += trace(fragCoord.xy+vec2(0.5, 0.5));\n\tfragColor = vec4(col / 4.0, 1.0);    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llf3DS","date":"1424739718","viewed":312,"name":"cylinder - shadeaday","username":"kig","description":"adding more primitives little by little, shadeaday for 2015-02-23","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["shadeaday"],"hasliked":0,"parentid":"","parentname":""}}