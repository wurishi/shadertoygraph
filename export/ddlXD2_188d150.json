{"ver":"0.1","info":{"id":"ddlXD2","date":"1669611872","viewed":74,"name":"Fade & Anim Utility Reference","username":"trancor","description":"Sometimes ya need a reminder of what different 0-1 blends look like\n  - Some 0-1 blending math\n  - Texture based animation frames; Nyan Cat Animation\n  - Pixel animation based on the distance from points of interest (Star Bursts; BufferA)","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["utility","animation","blending","tweening","fading","atob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sometimes ya just need a reference for a fade or animation set up\n//  - 4 different 0-1 blending methods, so far\n//  - Texture-based animation frame lookup\n//      Nyan Cat\n//  - Pixel value frame animation based on distance from point of interest\n//      Star Burst Background; BufferA\n//\n//  - BufferB is a static rainbow\n//\n//  Kevin Edzenga\n//    gh: ProcStack\n\n\n// -- -- -- -- -- --\n\n// Blending math functions in Common\n\n// Toggle Debug Colorization\n//   Turn all white 1.0 values to a aqua color\n//   Turn all black 0.0 values to a purple color\n#define ToggleDebugColors 0\n\n// -- -- -- -- -- --\n\n\n// Draw Nyan Cat with given size at location\nvec4 drawNyanCat( vec2 baseUv, vec2 nyanCentroid, vec2 size ){\n\n    // nyanCentroid\n    vec2 nyanUv = baseUv;\n    \n    \n    // Min Max in U\n    vec2 minMax = vec2( nyanCentroid.x - size.x, nyanCentroid.x + size.x );\n    nyanUv.x = (nyanUv.x - minMax.x) / (minMax.y-minMax.x);\n    // Min Max in V\n    minMax = vec2( nyanCentroid.y - size.y, nyanCentroid.y + size.y );\n    nyanUv.y = (nyanUv.y - minMax.x) / (minMax.y-minMax.x);\n\n    // Draw mask to keep thing clean and purdy\n    vec2 drawMaskUV = step( abs(nyanUv-.5), vec2(.5, .5) );\n    float drawMask = drawMaskUV.x*drawMaskUV.y;\n    \n    // Nyan Frame Read -\n    float fCount = 6.0;\n    // `nyanCentroid.y` is frame randomization  vv\n    float frameOffset = mod(iTime*1.5 + nyanCentroid.y*15.324,1.0);\n    frameOffset = ( 1.0 / (fCount+0.35) ) * floor( frameOffset*(fCount-1.0) );\n    \n    float uVal = frameOffset + nyanUv.x/(fCount+1.0);\n    nyanUv = vec2( uVal, nyanUv.y );\n    vec4 nyanCat = texture(iChannel0, nyanUv);\n    \n    \n    nyanCat*=drawMask;\n    //nyanCat.b=0.0;\n    \n    return nyanCat;\n    \n}\n\n// Helper script to merge Nyan Cat draws\nvec4 compNyanCat( vec4 nyanCd, vec2 uv, vec2 nyanCentroid, vec2 nyanSize ){\n    vec4 curNyan = drawNyanCat( uv, nyanCentroid, nyanSize );\n    nyanCd = mix( nyanCd, curNyan, curNyan.a );\n    return nyanCd;\n}\n\n\n\n// -- -- -- --\n// -- -- -- --\n// -- -- -- --\n\n\n\n// Draw Rainbow Trail with given thickness at location\nvec4 drawNyanRainbowTrail( vec2 baseUv, vec2 nyanCentroid, float height, float danceDist ){\n\n    // nyanCentroid\n    float time = iTime*1.50;\n    vec2 nyanUv = baseUv;\n    float flipShift = fract( nyanCentroid.y*1334.25263 + time );\n    flipShift = (step( .5, flipShift )*2.0 - 1.0);\n    \n    // Multiplier is trail dance frquency\n    // Add/Sub is trail dance offset                 vv    vv\n    nyanUv.y += mod(floor((nyanCentroid.x-nyanUv.x)*50.0-0.25), 2.0)*danceDist * flipShift;\n    \n    float offset = 0.0;\n    \n    // Min Max in U\n    vec2 minMax = vec2( 0.0, nyanCentroid.x + offset );\n    nyanUv.x = (nyanUv.x - minMax.x) / (minMax.y-minMax.x);\n    // Min Max in V\n    minMax = vec2( nyanCentroid.y - height, nyanCentroid.y + height );\n    nyanUv.y = (nyanUv.y - minMax.x) / (minMax.y-minMax.x);\n\n    // Draw mask to keep thing clean and purdy\n    vec2 drawMaskUV = step( abs(nyanUv-.5), vec2(.5, .5) );\n    float drawMask = drawMaskUV.x*drawMaskUV.y;\n    vec4 rainbowTrail = texture(iChannel2, nyanUv);\n    \n    rainbowTrail.a *= drawMask;\n    \n    \n    return rainbowTrail;\n    \n}\n\n// Helper script to merge Rainbow Trail draws\nvec4 compNyanTrail( vec4 trailCd, vec2 uv, vec2 nyanCentroid, float trailHeight, float danceDist  ){\n    vec2 fittedUv = uv;\n    \n    // Shift trail end, so it stops behind a foot\n    //  I'm lazy, what ya want from me?\n    nyanCentroid.x-=.0085;\n    vec4 curNyan = drawNyanRainbowTrail( fittedUv, nyanCentroid, trailHeight, danceDist );\n    trailCd = mix( trailCd, curNyan, curNyan.a );\n\n    return trailCd;\n}\n\n\n\n\n// -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- --\n\n\n\n// Janky\n// The Fresnel Schlick is a little janky (WIP)\n// Work in Progress I guess\n#define ToggleFresnelSchlick 0\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1.0/iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n\n    float time = iTime*18.0;\n    float modTime = mod(iTime,1.0);\n    float ftime = max(0.00001, fract(time*.007));\n\n\n    // -- -- --\n    // Nyan Backdrop\n    vec3 nyanBg = texture(iChannel1, uv).xyz;\n\n\n    float s1 = uv.x;\n    float s2 = .5;\n    float sd = (s2-s1);\n    float sdsign = sign(sd);\n\n\n    s2 = .5; // Position\n    sd = (s2-s1);\n\n\n    // Visualization Groups\n    float spacerSize = .081 - .016*float(ToggleFresnelSchlick); // Red Lines\n    float stepBase = 1.0 / ((4.0+float(ToggleFresnelSchlick))*3.0); // ( 5 fades * 3 visualizations )\n    float stepCount = 0.0;\n    float stepVal;\n    float halfStep = stepBase*.5;\n    float debugMask = 1.0;\n\n\n    vec2 nyanCentroid;\n    vec2 nyanSize = vec2(.04,.055);\n    vec4 nyanCd = vec4(0.0,0.0,0.0,0.0);\n    float trailHeight = .028;\n    vec4 rainbowTrailCd = vec4(0.0,0.0,0.0,0.0);\n    float trailDanceDist = pixelSize.y*2.0; \n\n\n    // Groups are the clusters of 3 visualizations between the red lines\n    //   Top vis - Linear move 0-1; UV.x is driving the fade value\n    //   Mid vis - Fade from center screen to 0 using the fading method\n    //   Bottom vis - Nyan Cat animating from left to right using fading method\n\n    // -- -- -- --\n    // Top Group - PowTo()\n    \n    stepVal = step((++stepCount-.15)*stepBase,1.0-uv.y);\n    \n    vec3 smoothTo =  vec3( mix( PowTo(s1,ftime,.02), PowTo(s1,s2,ftime*.5), stepVal ) );\n    \n    \n    // Nyan\n    stepVal = step((++stepCount-.15)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( nyanBg ), stepVal );\n    debugMask = mix( debugMask, 0.0, stepVal );\n    \n    nyanCentroid = 1.0 - vec2( PowTo(ftime*2.0,1.00,.05), stepCount*stepBase + halfStep*.75 );\n    nyanCd = compNyanCat( nyanCd, uv, nyanCentroid, nyanSize );\n    rainbowTrailCd = compNyanTrail( rainbowTrailCd, uv, nyanCentroid, trailHeight, trailDanceDist );\n    \n    \n    // Spacer --\n    stepVal = step(stepCount*stepBase + spacerSize,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( 1.0,0.0,0.0 ), stepVal );\n\n\n    // -- -- -- --\n    // 2nd Group Down - LogPowTo()\n    \n    // Third from top\n    float j = ftime*1.5; // 0.0 - 1.5; \n    //float logPowTo = 1.0-abs( log(pow(abs(sd),j)) ); // 0.0 - 1.5\n\n    \n    stepVal = step((++stepCount)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( LogPowTo(s1,ftime,.08) ), stepVal );\n    debugMask = mix( debugMask, 1.0, stepVal );\n    \n    stepVal = step((++stepCount-.15)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( LogPowTo(s1,s2,j) ), stepVal );\n    \n    // Nyan\n    stepVal = step((++stepCount-.3)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, nyanBg, stepVal );\n    debugMask = mix( debugMask, 0.0, stepVal );\n    nyanCentroid = 1.0 - vec2( LogPowTo(1.0,ftime*2.0,0.150), stepCount*stepBase+halfStep*.7 );\n    nyanCd = compNyanCat( nyanCd, uv, nyanCentroid, nyanSize );\n    \n    rainbowTrailCd = compNyanTrail( rainbowTrailCd, uv, nyanCentroid, trailHeight, trailDanceDist );\n    \n    \n    \n\n    // Spacer --\n    stepVal = step(stepCount*stepBase + spacerSize,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( 1.0,0.0,0.0 ), stepVal );\n\n\n    // -- -- -- --\n    // 3rd Group Down - DeltaDivTo()\n\n    float b = ftime; // Position\n    stepVal = step((++stepCount)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( DeltaDivTo(s1,ftime,.20) ), stepVal );\n    debugMask = mix( debugMask, 1.0, stepVal );\n    \n    stepVal = step((++stepCount-.15)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( DeltaDivTo(s1,.5,b) ), stepVal );\n    \n    // Nyan\n    stepVal = step((++stepCount-.3)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, nyanBg, stepVal );\n    debugMask = mix( debugMask, 0.0, stepVal );\n    float timeFit = ftime;//(clamp((ftime*1.0),0.0,1.0)-.5)+.5;\n\n    nyanCentroid =  1.0 - vec2( 1.0-(1.0-DeltaDivTo(timeFit,.50,0.365))*.735, stepCount*stepBase+halfStep*.7 );\n    nyanCd = compNyanCat( nyanCd, uv, nyanCentroid, nyanSize );\n    rainbowTrailCd = compNyanTrail( rainbowTrailCd, uv, nyanCentroid, trailHeight, trailDanceDist );\n    \n    \n\n\n    // Spacer --\n    stepVal = step(stepCount*stepBase + spacerSize,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( 1.0,0.0,0.0 ), stepVal );\n\n\n\n\n    // -- -- -- --\n    // 4th Group Down - SinTo()\n    \n    float sintime = (1.0-ftime);\n    sintime*=sintime*sintime;\n    float d = sintime * 20.0;\n    \n    float divTo = SinTo(s1,s2,d);\n    \n    stepVal = step((++stepCount)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( SinTo(s1,ftime,1.99) ), stepVal );\n    debugMask = mix( debugMask, 1.0, stepVal );\n    \n    stepVal = step((++stepCount-.15)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( divTo ), stepVal );\n    \n    // Nyan\n    stepVal = step((++stepCount-.3)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, nyanBg, stepVal );\n    debugMask = mix( debugMask, 0.0, stepVal );\n    nyanCentroid = 1.0 - vec2( SinTo(1.0,ftime*2.0,.5), stepCount*stepBase+halfStep*.75 );\n    nyanCd = compNyanCat( nyanCd, uv, nyanCentroid, nyanSize );\n    rainbowTrailCd = compNyanTrail( rainbowTrailCd, uv, nyanCentroid, trailHeight, trailDanceDist );\n    \n    \n    \n\n\n    // -- -- -- --\n    // Bottom Group - fresnelSchlick()\n#if (ToggleFresnelSchlick > 0)\n    // Spacer --\n    stepVal = step(stepCount*stepBase + spacerSize,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3( 1.0,0.0,0.0 ), stepVal );\n\n    stepVal = step((++stepCount)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3(fresnelSchlickAbs(ftime*3.0, s1-.01) ), stepVal );\n    debugMask = mix( debugMask, 1.0, stepVal );\n\n    stepVal = step((++stepCount-.15)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, vec3(fresnelSchlick(sd, s1-.01) ), stepVal );\n\n    // Nyan\n    stepVal = step((++stepCount-.3)*stepBase,1.0-uv.y);\n    smoothTo = mix( smoothTo, nyanBg, stepVal );\n    debugMask = mix( debugMask, 0.0, stepVal );\n    nyanCentroid = 1.0 - vec2( max(1.0,fresnelSchlick(ftime, s1-.01)), stepCount*stepBase+halfStep*.75 );\n    nyanCd = compNyanCat( nyanCd, uv, nyanCentroid, nyanSize );\n    rainbowTrailCd = compNyanTrail( rainbowTrailCd, uv, nyanCentroid, trailHeight, trailDanceDist );\n#endif\n\n    // -- -- -- --\n    //  Nyan Cat, Rainbow Trails, & Nyan Background Color Blend In\n    //  The backgroud bursts are drawn on BufferA directly\n    //    I'm just pulling the bursts up to match the real Nyan Cat animation\n    //      (Bursts were over the rainbow trails)\n    //  Draw order matters, first rainbow trail, then nyan cats, below\n    //\n    //  TODO - Get bursts displaying over the rainbow trail randomly, based on uv\n    //           Right now, all bursts render over the rainbow trails\n    smoothTo = mix( smoothTo, rainbowTrailCd.xyz, max(0.0,rainbowTrailCd.a- nyanBg.r) );\n    smoothTo = mix( smoothTo, nyanCd.xyz, nyanCd.a );\n    \n    \n    // Final out color\n    vec3 outCd = smoothTo;\n\n\n    // Debug Colorization-izer\n#if (ToggleDebugColors > 0)\n    vec3 debugCd = outCd;\n    float redSeparators = step(.9999, dot( vec3(1.0,0.0,0.0), normalize(debugCd)) );\n    debugCd = mix(  debugCd, vec3(0.5,0.1,0.5), step( .9999, 1.0-smoothTo ) );\n    debugCd = mix( debugCd, vec3(0.1,0.6,0.6), step( .9999, smoothTo ) );\n    outCd = mix( outCd, debugCd, debugMask);\n#endif\n\n    // Output to screen\n    fragColor = vec4(outCd,1.0);\n}\n\n  ","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//  Star Field Generation\n//\n//  The star burst animations are in this buffer; BufferA\n//\n//  Below I have info on setting up the bursts using a random vec2 array\n//    Which should be used for performance reasons\n//  But I'm using a texture look up instead, cause its more fun to do\n//\n//  Pixels check 3 neighboring pixels of the texture\n//    For a color value above an arbirarily set vec3 in a dot product\n//    In - `checkBurstDistances()`\n//  This returns the Burst Source pixel UV and stores its pixel distance in a vec4 respectively\n//    `vec4( Is current uv a Burst Source?, 1 pixel away?, 2 pixels away?, 3 pixels away? )`\n//    Allowing usage of the `vec4 starBurstAnim[6]` variable below as animation frames\n//      Animation per pixel based on the distance from found Burst Sources\n//    The stored Burst Source UV is then used to randomize the animation frame, per burst\n\n\n// -- -- -- \n\n// Dec 4th 2022 Update\n//   Scrolling UV.x weren't fitted to exact pixels\n//     So it looked like vertical banding when altering the \"random frame\" value\n//   In its persuit, added pixel size support -\n\n// Pixel res; Divisor, lower yields larger pixels ( iChannel0 res default )\n#define TX_RES 256.0\n#define TX_RATIO (1.0/TX_RES)\n// For performance, no need to fit Y to be pixel perfect if TX_RES set to iChannel0 res\n//   For non-iChannel0 pixel res, set below to 1 for square pixels\n#define FIT_V_TO_PIXEL 0\n\n\n// -- -- -- \n\n\n// Animation Frames\n//   Pixel Distance Lookup from Burst Spawn location,\n//     Correlates to entry in vec4 -\n//       `starBurstAnim[#].xyzw` -> [0.0,1.0,2.0,3.0] pixel distance from burst origin\n//   Where each vec4 component is the alpha multiplier for each pixel\n// (Working with what I got...)\n//\nfloat starBurstFrameCount = 5.0;\nfloat starBurstDiagnalFrame = 4.0;\nvec4 starBurstAnim[6] = vec4[6](\n        vec4( 1.0, .0, .0, .0 ),\n        vec4( .0, 1.0, .0, .0 ),\n        vec4( .0, 1.0, 1.0, .0 ),\n        vec4( 1.0, .0, 1.0, 1.0 ),\n        vec4( .0, .0, .0, 1.0 ), // Diagnials need to draw on this frame\n        vec4( .0, .0, .0, 1.0 )\n    );\n\n\n// -- -- -- \n\n\n//  In real world usage, use a vec2 array of \"burst spawning\" locations\n//    So each pixel can easily know linear and diagnal distances the the bursts\n//      The distances can be used for array look up of animation frames\n//        And give better performance than the method I'm using below.\n//    Then just scroll the \"burst spawning\" location's x component over time.\n//\n//  I'm doing texel look up cause its more fun to write hah\n//    And our computers are strong enough\n//      This isn't ray marching or scattered surface lighting or anything here\n//\n\n/* --\n//  If you'd like a random vec2 array -\nvec2 randomValues[20] = vec2[20](\n                        vec2(0.02161958, 0.16291224),\n                        vec2(0.61498832, 0.99613451),\n                        vec2(0.13396591, 0.07368630),\n                        vec2(0.80880696, 0.65135087),\n                        vec2(0.32537786, 0.64989967),\n                        vec2(0.38445766, 0.63814615),\n                        vec2(0.11107493, 0.50663224),\n                        vec2(0.67832142, 0.23739949),\n                        vec2(0.36730385, 0.27462783),\n                        vec2(0.35543229, 0.52916799),\n                        vec2(0.73520796, 0.48910078),\n                        vec2(0.73299803, 0.83677814),\n                        vec2(0.91284746, 0.69910881),\n                        vec2(0.05648311, 0.19749575),\n                        vec2(0.08832685, 0.13530803),\n                        vec2(0.82986931, 0.26431773),\n                        vec2(0.44639064, 0.67307125),\n                        vec2(0.91785661, 0.24877479),\n                        vec2(0.89286102, 0.98344936),\n                        vec2(0.07082943, 0.83841112)\n                    );\n-- */\n\n/* --\n//  If you want a random array of any size\n//    int[],float[],vec2[],vec3[],vec4\n//  You can use the python script below -\n\n\n#  Python\n#  Generate Random Value OpenGL Arrays\n#    Auto Generate an OpenGL formatted float/vec# array of random numbers\n#    Kevin Edzenga\n#      gh: ProcStack\n\n#  Please set your variables below\nimport random\n\n#  Entry size; 0 - int | 1 - float | 2 - vec2 | 3 - vec3 | 4 - vec4\ngenEntrySize = 2\n\n#  Entry count, list size\ngenEntryCount = 20\n\n#  Name of your outputted array variable\nvariableName = \"randomValues\"\n\n#  Numbers after the decimal\n#    2 -> 0.##  |  6 -> 0.######\ndecimalCount = 8 \n\n#  Your os's carrage return\n#    Windows - \\r\\n  |  Linux/MacOS X+ - \\n  |  MaxOS <X - \\r\ncarrageReturn = \"\\r\\n\" \n\n### -- -- -- ###\n\ndef printRandomArray():\n    printStr = \"\"\n    entryTypeList = [\"int\",\"float\",\"vec2\",\"vec3\",\"vec4\"]\n    entryRun = max(1,genEntrySize)\n    \n    padding = \" \"*int((len(variableName)+len(entryTypeList[genEntrySize]) + 4)*.3)*4\n    randomArrayList = list(map(lambda x: (\"{0}({1})\",\"{0}{1}\")[entryRun==1].format((entryTypeList[genEntrySize],\"\")[entryRun==1], \", \".join(list(map(lambda x : (str(random.random())[0:decimalCount+2],str(int(random.random()*10)))[genEntrySize==0], [0]*entryRun))) ), [0]*genEntryCount ))\n    printStr += r\"{0}{1} {2}[{3}] = {4}[{5}](\".format( carrageReturn, entryTypeList[genEntrySize], variableName, genEntryCount, entryTypeList[genEntrySize], genEntryCount )\n    randomArrayList = list(map(lambda x: r\"{0}{1}{2}\".format( carrageReturn, padding, x), randomArrayList))\n    printStr += \",\".join(randomArrayList)\n    printStr += \"{0}{1});\".format( carrageReturn, padding[0:-4] )\n    \n    print( printStr )\n\nprintRandomArray()\n\n# -- Copy To Here --\n\n\n-- -- -- */\n\n\n\n\n// Check if UV is texture Burst Spawn location\nfloat getSpawnLocationValue( vec2 checkUv ){\n\n    vec3 outCd = texture(iChannel0, checkUv).xyz;\n    // This vec3 is used to check if the sampled color is a Burst Source\n    //   If the dot product value is above the last step value below, .9985\n    vec3 randomCdDotVec = normalize(vec3(1.0, 0.0, 0.20));\n    \n    float starDot = 1.0 - max(0.0, dot( normalize(outCd), randomCdDotVec ));\n    \n    starDot = 1.0 - (1.0-starDot)*(1.0-starDot);\n    starDot *= step(.999, starDot);\n    \n    return starDot;\n}\n\n//  Run texture lookups to find near by Burst Spawn locations\nvoid checkBurstDistances( vec2 baseUv, vec2 txRes, float checkDist,\n                          inout vec2 burstSpawnUv,\n                          inout vec4 linearAnimFrames, inout float hasDiagnalAnim ){\n    vec2 curUv;\n    float curCheck;\n    vec4 outVal = vec4(0.0,0.0,0.0,0.0); // x - Linear Check Value | y - Diagnal Check Value\n    float outDiag = 0.0;\n    vec2 outSpawnUv = vec2(0.0,0.0);\n    \n    vec2 txCheckRes =  txRes * checkDist;\n    \n    \n    // Its late, I'll optimize later\n    curUv = baseUv;\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.x = max(outVal.x, curCheck);\n    // -- \n    curUv = fract( baseUv + txCheckRes * vec2( 1.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.y = max(outVal.y, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -1.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.y = max(outVal.y, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, 1.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.y = max(outVal.y, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, -1.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.y = max(outVal.y, curCheck );\n    // -- \n    curUv = fract( baseUv + txCheckRes * vec2( 2.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.z = max(outVal.z, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -2.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.z = max(outVal.z, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, 2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.z = max(outVal.z, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, -2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.z = max(outVal.z, curCheck );\n    // -- \n    curUv = fract( baseUv + txCheckRes * vec2( 3.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.w = max(outVal.w, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -3.0, 0.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.w = max(outVal.w, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, 3.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.w = max(outVal.w, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 0.0, -3.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outVal.w = max(outVal.w, curCheck );\n    // -- \n    \n    \n    \n    // -- \n    // Diagnals\n    curUv = fract( baseUv + txCheckRes * vec2( 2.0, 2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outDiag = max(outDiag, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -2.0, 2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outDiag = max(outDiag, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( -2.0, -2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outDiag = max(outDiag, curCheck );\n    curUv = fract( baseUv + txCheckRes * vec2( 2.0, -2.0 ) );\n    curCheck = getSpawnLocationValue( curUv );\n    outSpawnUv = mix( outSpawnUv, curUv, curCheck );\n    outDiag = max(outDiag, curCheck );\n    // -- \n    \n    \n    // Output\n    //   In-Out variables\n    \n    // Burst UV location\n    burstSpawnUv = outSpawnUv;\n    \n    // Horizontal / Vertical anim frame vec4 entry\n    linearAnimFrames = outVal;\n    // Is UV a dignal pixel from Burst location\n    //   `baseUV +/- vec2(2.0,2.0)`\n    hasDiagnalAnim = outDiag;\n    \n}\n\n\n\n// -- -- -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- -- -- --\n// -- -- -- -- -- -- -- -- -- -- --\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scrollTime = iTime*.04;\n    float fpsTime = iTime*7.00;\n    \n    vec2 uvRatio = 1.0/iResolution.xy;\n    float pxlRatio = uvRatio.y/uvRatio.x;\n    vec2 baseUv = fragCoord * uvRatio;\n    vec2 curUv = baseUv*vec2(pxlRatio,1.0)*.7;\n    curUv.x = fract( curUv.x + scrollTime );\n    \n    // Fit to pixel size\n    curUv.x = floor(curUv.x * TX_RES) * TX_RATIO;\n    \n    // For Y scaling and/or scrolling\n#if ( FIT_V_TO_PIXEL > 0 )\n    curUv.y = floor(curUv.y * TX_RES) * TX_RATIO;\n#endif\n\n    vec3 outCd;\n    vec3 bgCd = vec3( 0.0470588235294118, 0.2588235294117647, 0.4705882352941176 );\n    \n    \n    // -- -- --\n    //  Check distance to Burst Spawn locations\n    vec2 noiseRes = vec2(TX_RES);\n    vec2 noiseRatio = vec2(TX_RATIO);\n    float burstRadius = 1.0;\n    \n    vec2 burstSpawnUv = vec2(0.0,0.0);\n    vec4 linearAnimFrames = vec4( 0.0, 0.0, 0.0, 0.0 );\n    float hasDiagnalAnim = 0.0;\n    \n    // `checkBurstDistances()` Outputs -\n    //   `burstSpawnUv` - Point Of Interest UV\n    //     Used to offset animation frame/element lookup in `starBurstAnim`\n    //   `linearAnimFrames` - RGB for distance from Point of Interest\n    //     For vec4 animation frame value from `starBurstAnim`\n    //   `hasDiagnalAnim` - If pixel is a burst diagnal pixel\n    //     To animate specific on frame 5 of the animation\n    checkBurstDistances( curUv, noiseRatio, burstRadius, burstSpawnUv, linearAnimFrames, hasDiagnalAnim );\n    \n    // -- -- --\n    //  Get current animation frame\n    float burstOffsetU = burstSpawnUv.x * starBurstFrameCount*10.0;\n    float burstOffsetV = burstSpawnUv.x * starBurstFrameCount*4.0;\n    float curFrameFloat = mod(floor(fpsTime + burstOffsetU + burstOffsetV ), starBurstFrameCount);\n    \n    int curFrame = int( curFrameFloat );\n    \n    vec4 animFrame = starBurstAnim[curFrame];\n    \n    float burstValue = length(linearAnimFrames * animFrame);\n    \n    float diagnalBurstFrameValue = (1.0-step(0.5, abs(starBurstDiagnalFrame - curFrameFloat)));\n    burstValue = max( burstValue, diagnalBurstFrameValue * hasDiagnalAnim );\n    \n    outCd = mix( bgCd, vec3(1.0,1.0,1.0), burstValue);\n    //outCd.rgb = burstValue;//vec3(linearAnimFrames,linearAnimFrames,linearAnimFrames);\n    \n    \n    float test = step(.5, fract(burstSpawnUv.x*100.0));\n    \n    \n    \n    \n    \n    \n    \n    fragColor = vec4(outCd,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Nyan Cat's Rainbow Trail Base Texture\n//   Animation in Parent File\nfloat rainbowColorCount = 6.0;\nvec3 rainbowColors[6] = vec3[6](\n        vec3(1.00, 0.17, 0.05),\n        vec3(1.00, 0.66, 0.02),\n        vec3(1.00, 0.96, 0.0),\n        vec3(0.19, 0.92, .02),\n        vec3(0.01, 0.64, 1.00),\n        vec3(0.47, 0.34, 1.00)\n    );\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 baseUv = fragCoord / iResolution.xy;\n    \n    \n    vec4 outCd = vec4( 1.0, 1.0, 1.0, 1.0);\n    \n    float vFitted = (1.0-baseUv.y);\n    \n    int targetColorId = int( vFitted*rainbowColorCount);\n    vec3 targetColor = rainbowColors[ targetColorId ];\n    \n    outCd.rgb = targetColor;\n    \n    \n    fragColor = outCd;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// For other transitional math and curves alike -\n//   BruOp put together tone mapping curves here -\n//     \"Tonemap operators incl. reinhard\"\n//     https://www.shadertoy.com/view/WdjSW3\n\n\n// Helpers\n\n#define PI 3.14159265358979323\n\nfloat clamp01(float val){\n    return clamp( val, 0.0, 1.0 );\n}\n\n\n// -- -- -- -- -- --\n// Different 0 to 1 blending math\n//   Poking around & exploring \n//\n// Groups are the clusters of 3 visualizations between the red lines\n//   Top vis - Linear move 0-1; UV.x is driving the fade value\n//   Mid vis - Fade from center screen to 0 using the fading method\n//   Bottom vis - Nyan Cat animating from left to right using fading method\n//\n// Top group; Sharper high end\nfloat PowTo(float s1, float s2, float k){ \n  k*=9.0; // k => 0.0-9.0 to fit 0.0-1.0\n  float sd = (s2-s1);\n  float powTo = pow( abs(sd), k );\n  return clamp01( powTo );\n}\n\n// Second from top group; Slow grow, sharp high end\nfloat LogPowTo(float s1, float s2, float j){  \n  j*=1.5;// j => 0.0-1.5 to fit 0.0-1.0\n  float sd = (s2-s1);\n  float logPowTo = 1.0-abs( log(pow( abs(sd), j )) );\n  return clamp01( logPowTo );\n}\n  \n// Third group\n//   Only looks cool if all 3 variables are animating\n//     Feels like an overly complicated linear otherwise\nfloat DeltaDivTo(float s1, float s2, float b){\n  float deltaTo = abs( ((s1-b)-(s2-b)) / b) - b;\n  //float deltaTo = abs( ((s1-b)-(s2-b)) / (b));// - b*2.5;\n  //return clamp01( deltaTo );\n  return  deltaTo ;\n}\n  \n\n// Forth group\n//   Soft ease-in to 1\nfloat SinTo(float s1, float s2, float p){\n  float sd = ( s2-s1 );\n  float d = sd*p ;\n  d = clamp(d, -1.0, 1.0) * PI ;\n  float divTo = 1.0-cos( d );\n  return clamp01( divTo );\n}\n\n// -- -- --\n\n// Optional Fresnel Schlick on the Bottom group -\n//   The Define to turn this on is kinda hidden for now\n//     Since these are kinda busted at the moment\n//   Soft ends, fast mid range\nfloat fresnelSchlick(float theta, float val)\n{\n    return clamp01( val + (1.0-val) * pow(1.0-theta, 5.0) );\n}\nfloat fresnelSchlickAbs(float theta, float val)\n{\n    return min( 1.0, abs( val + (1.0-val) * pow(1.0-theta, 5.0) ));\n}","name":"Common","description":"","type":"common"}]}