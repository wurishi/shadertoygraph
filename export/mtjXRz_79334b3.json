{"ver":"0.1","info":{"id":"mtjXRz","date":"1675734806","viewed":197,"name":"triangle hash","username":"valalalalala","description":"Demo use of a different periodic function for hashing and rotation instead of sine and cosine: abs(fract(x)-5). \nThe \"fract\" is actually: mod( x,TAU) /TAU for smoothness. In 2d it makes a triangle, or a diamond in the same sense that sin make a circle.\n\n","likes":7,"published":1,"flags":8,"usePreview":0,"tags":["starry","hash","trianglehash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"        //////////////////////////////////////////////////////////////////////\n       //                                                                 ////\n      //  \"diamond hash\"                                                 // //\n     //                                                                 //  //\n    //  Demo use of a different periodic function for hashing and      //   // \n   //  and rotation instead of sine and cosine: abs( fract(x) -.5 ).  //    //\n  // The \"fract\" is actually: \"mod( x, TAU ) / TAU\" for smoothness.  //     //\n //                                                                 //     //\n/////////////////////////////////////////////////////////////////////     //\n//                                                                 //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike           //   ///\n// 3.0 Unported License                                            //  ////\n//                                                                 // // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2023                               ////  //\n//                                                                 ///   //\n/////////////////////////////////////////////////////////////////////    //\n       //                                                                //\n       // The hashes and other functions are in the common tab. Demo     //\n       // code lives here.                                               //\n       //                                                                //\n       // Starfield part borrows heavily from patu's \"Starfield DOTs II\" //\n       //                                                                //\n       // This is my first shader with sound! Sorry, but it is awful :-P //\n       // If you listen long enough you will hear the periodic function  //\n       // change from the triangle to sin for notes                      //\n       //                                                                //\n       // Tau makes the triangle wave have the same period as cosine:    //\n       // https://www.desmos.com/calculator/qpsmszumse                   //\n       //                                                                //\n       // For extra fun the rotation is also based on the triangle wave. //\n       // I don't think it is noticable to forego the trigonometry. Ha!  //\n       //                                                                //\n       ////////////////////////////////////////////////////////////////////\n       \n/////////////////////////////////////////////////////////////////////   \n\nvec3 hashBackground( vec2 uv ) {\n    vec2 mv = uv + fract( iTime * .000033 );\n    if ( uv.x < .0 ) {\n        float h = triangleHash( mv );     \n        return vec3( h, vec2( invert( h ) ) );\n    }\n    \n    float h = trigonometryHash( mv );\n    return vec3( vec2( invert( h ) ), h );\n}\n\n/////////////////////////////////////////////////////////////////////\n// borrows heavily from patu's \"Starfield DOTs II\" [XtjcW3]\n\nvec3 hashStars( in vec2 st, in vec2 uv, in vec2 ms ) {\n    float timo = mod( iTime * .66, 333333. ) + 3.3;\n\n    vec3 eye = vec3( uv * 1.33 * .33 * rotate2d( timo ), 3.3 );   \n    vec3 dst = vec3( ms, .0 );\n    vec3 dir = normalize( dst - eye );\n\n    vec3 color = .0 * st.xxx;\n\n    // borrows heavily from patu's \"Starfield DOTs II\" [XtjcW3]\n    for ( float depth = .0 ; depth < 1. ; depth += 1. / MAX_DEPTH ) {        \n        float x, y, z = mod( -timo * depth  * 33., MAXZ );\n        \n        if ( uv.x < .0 ) {\n            x = triangleHash( depth );\n            y = triangleHash( x * depth );\n        } else {\n            vec2 d2 = vec2( depth );\n            x = trigonometryHash( d2 );\n            y = trigonometryHash( x * d2 );\n        }\n\n        vec3 pt = normalize( vec3( scalo( x, 3. ), scalo( y, 3. ), z ) );\n        vec3 e2p = normalize( eye - pt );\n        \n        float a = abs(dot(e2p,dir));\n        vec3 c = abs( fract( vec3( x, y, x + y ) ) );\n        float p = 33833. + pow( invert( depth ), 2. ) * 8338338.;\n        \n        color += c * pow( a, p );\n    }\n    \n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n// https://iquilezles.org/articles/distfunctions2d/\n// that guy is always everywhere all the time!\nfloat sdRoundedX( in vec2 p, in float w ) {\n    p = abs( p );\n    p -= .5 * min( p.x + p.y, w );\n    return dot( p, p );\n    return length(p-min(p.x+p.y,w)*0.5);\n}\n\n// some nonsense\nfloat splat( in vec2 p ) {\n    vec2 a = abs( p );\n    return min(a.x,min(a.y,max(a.x-a.y,a.y-a.x)));\n}\n\nvec3 demo( in vec2 st, in vec2 uv, in vec2 ms ) {\n    vec2 a = abs( uv );\n    \n    float t = STAR_WIPE * triangle( iTime );\n    float x = (\n        + STAR_WIPE * smoothstep( .00033, t * 2.2, splat( uv ) )\n        + smoothstep( .000133, -t, sdRoundedX( uv, .066 ) )\n    );\n    \n    vec3 color = mix( hashBackground( uv ), hashStars( st, uv, ms ), .33 * 1.33 );\n\n    return mix( color, 1. -color, x );\n}\n\nvoid mainImage( out vec4 result, in vec2 st ) {\n    vec2 uv = fromScreen( st, iResolution );\n    vec2 ms = fromScreen( iMouse.xy, iResolution ) * step( 3e-3, iMouse.z + iMouse.w );\n    \n    result = vec4( demo( st, uv, ms ), 1. );\n}\n\n/////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////////////////////////////////////////\n\nconst float TAU = 99733. / 15873.;\n\nconst float MAX_DEPTH = 333.;\nconst float MAXZ = MAX_DEPTH * .11;\n\nconst vec3 MAGIC = vec3( TAU * 3.3, 99.733, 15873. );\n\nconst float STAR_WIPE = .0; // don't set this to 1! lol\n\n/////////////////////////////////////////////////////////////////////\n\nvec2 fromScreen( vec2 st, vec3 rez ) {\n    return ( 2. * st - rez.xy ) / min( rez.x, rez.y );\n}\n\nfloat absMod( float f, float m ) {\n    return abs( mod( f, m ) - m *.5 );\n}\n\nfloat scalo( float f, float s ) {\n    return f * s - .5 * s;\n}\n\nfloat invert( float f ) {\n    return 1. - f;\n}\n\nfloat modScale( float f, float s ) {\n    return mod( f, s ) / s;\n}\n\n/////////////////////////////////////////////////////////////////////\n\nfloat triangle( float x ) {\n    return 4. * abs( modScale( x, TAU ) - .5 ) -1.;\n}\n\n// rotation w/o trig :-P\nmat2 rotate2d( in float angle ) {\n    float c = triangle( angle );\n    float s = triangle( angle + TAU *.25 );\n    return mat2( c, -s, s, c );\n}\n\n/////////////////////////////////////////////////////////////////////\n\nfloat magicFloat( vec2 uv ) {\n    return dot( uv, MAGIC.xy );\n}\n\n// really a lot like just regular fract based hash :-P\nfloat triangleHash( float f ) {\n    return fract( triangle( f * MAGIC.x ) * f * MAGIC.z * .133 );\n}\n\nfloat triangleHash( vec2 uv ) { \n    return triangleHash( magicFloat( uv ) );\n}\n\n// the og\nfloat trigonometryHash( vec2 uv ) { \n    return fract( sin( magicFloat( uv ) ) * MAGIC.z ); \n}\n\n/////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"// note: to hear the compilation changes, you need to reset to frame 0\n//       idk why... it's not my fault!\n\n#define NOTE_MIN 33.\n#define NOTE_ADD 6666.\n\n#define PATHOLOGICAL 100.\n\nvec2 mainSound( int samp, float time ) {\n    float volume = .0133; // little bit of this goes a long ways...\n    float fade = 1.;\n    \n    float f = 7.7;\n    //f = 8.8; // other good value\n    //f = 6.6; // other good value\n    float t = mod( time, f );\n    float q = floor( t * f ) / f;\n    \n    if ( mod( time, PATHOLOGICAL ) < .5 * PATHOLOGICAL ) {\n        t = triangle( time );\n        fade = abs( triangleHash( t * 1.33 ) );\n    } else {\n        t = sin( time );\n        fade = abs( sin( t * 1.33 ) );\n    }\n    \n    fade = .4 + .6 * fade;\n        \n    float noteTrigonometry = trigonometryHash( vec2(q) ) * NOTE_ADD + NOTE_MIN;\n    float noteTriangle = triangleHash( q ) * NOTE_ADD + NOTE_MIN;\n    \n    return volume * fade * vec2( \n        sin( t * TAU * noteTrigonometry) ,\n        triangle( t * TAU* noteTriangle )\n    );\n}\n","name":"Sound","description":"","type":"sound"}]}