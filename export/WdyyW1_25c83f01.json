{"ver":"0.1","info":{"id":"WdyyW1","date":"1604310077","viewed":179,"name":"ps_Vortex","username":"bigt","description":"vortex\n鼠标移动改变圆心位置","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["distort","vortex","photoshop","ps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fAngle = 90.0;// 更改旋转角度\nfloat fRadius = 0.3;\nint iSquare = 1;\nfloat fThreshold = 10.0;// aa(单位:像素)\n\n// 漩涡的特征是离圆心距离越远, 旋转角度越大\nvec4 vortexFilter(vec2 pos)\n{\t\n    // 变换坐标系,决定是否使用宽高比\n    vec2 res = mix(min(iResolution.xx, iResolution.yy), iResolution.xy, float(iSquare));\n    pos = pos/iResolution.xy*res;\n    \n    // 圆心坐标\n    float mouseDown = step(0.1, iMouse.z);\n    vec2 O = mix(vec2(0.5,0.4)*res, iMouse.xy/iResolution.xy*res, mouseDown);\n    \n    float maxRadius = min(res.x, res.y) * fRadius;// x,y选取最小值作为半径\n\n    vec2 P = pos;// 初始化坐标为屏幕坐标\n\n    vec2 OtoP = P - O;// 以圆心为坐标原点\n    float R = length(OtoP);\n    \n    // ------------------ 漩涡主要代码 -----------------------------------------------------\n\tfloat attenuationFactor = 1.0-(R/maxRadius);// 计算旋转角度的衰减因子(离圆心越近,旋转角度变化越小)\n\tfloat beta = atan(OtoP.y, OtoP.x);// 计算xOy夹角\n    beta += radians(fAngle) * attenuationFactor;// 计算漩涡的角度\n    P = O + R*vec2(cos(beta), sin(beta));// 计算旋转后的直角坐标\n    // -------------------------------------------------------------------------------------\n    \n    // aa\n    float t = smoothstep(-fThreshold, fThreshold, R-maxRadius);// aa\n    vec3 col1 = texture(iChannel0, pos/res).rgb;\n    vec3 col2 = vec3(0.3,0.2,0.4) + texture(iChannel0, P/res).rgb;\n\n    return vec4( mix(col2, col1, t), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vortexFilter(fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/3sVyWh\nfloat checkerboard(vec2 pos, vec2 size, float threshold)\n{\n    vec2 gc = floor(pos/size);\n    float flag = abs(mod(gc.x,2.0) - mod(gc.y,2.0));\n    \n    // aa\n    vec2 t1 = smoothstep(size,size-threshold,pos - floor(pos/size)*size);\n    vec2 t2 = smoothstep(0.0,threshold,pos - floor(pos/size)*size);\n    float aa = t1.x*t1.y*t2.x*t2.y;\n    \n    return flag*aa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(30.0,30.0);// 棋盘格的大小(单位:像素)\n    vec3 col1 = vec3(0.15);// 两个格子的颜色\n    vec3 col2 = vec3(0.85);\n    float threshold = 2.0;// aa(单位:像素)\n    \n    vec2 coord = fragCoord;\n    \n    float flag = checkerboard(coord, size, threshold);\n    vec3 col = mix(col1, col2, flag);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}