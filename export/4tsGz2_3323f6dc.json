{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define MAX_STEPS 60\n#define MAX_DISTANCE 30.0\n#define EPSILON 0.01\n#define NORMAL_EPSILON 0.1\n#define CANDY_COUNT 10\n#define CANDY_RADIUS 2.0\n#define CANDY_HEIGHT 0.58\n#define CANDY_SMOOTHNESS 0.5\n#define FALL_SPEED 10.0\n\nfloat smax(float a, float b, float k)\n{\n    float h = 1.0 - clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,  y,   z,   1.0 );\n}\n\nvec3 rotateY(vec3 v, float angle)\n{\n\tvec3 vo = v; \n    float cosa = cos(angle); \n    float sina = sin(angle);\n    \n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\nvec3 rotateX(vec3 v, float angle)\n{\n\tvec3 vo = v; \n    float cosa = cos(angle); \n    float sina = sin(angle);\n    \n\tv.y = cosa*vo.y - sina*vo.z;\n\tv.z = sina*vo.y + cosa*vo.z;\n\treturn v;\n}\n\nvec4 map(vec3 p) \n{\n    float dist = MAX_DISTANCE;\n    vec3 local = vec3(0.0);\n    \n    for (int i = 0; i < CANDY_COUNT; i++) \n    {\n     \tfloat ratio = float(i) / float(CANDY_COUNT);\n        vec3 q = p;\n        \n        // Make them fall\n        q.y += (float(i) * 3.0) + (iTime * FALL_SPEED);\n        \n        // Duplicate along the height\n        float c = 8.0 + (ratio * 10.0);\n    \tq = vec3(q.x, mod(q.y, c) - (0.5 * c), q.z);\n\n        // Spread them appart\n        q = (translate(cos(float(i)) * 7.0, 0.0, float(i) * -1.2) * vec4(q, 1.0)).xyz;\n        \n        // Apply the rotation\n    \tq = rotateX(q, (float(i) * 150.0) + iTime);\n\t\tq = rotateY(q, (float(i) * 150.0) + iTime);\n\n        // Candy\n        float d = length(q.xz) - CANDY_RADIUS;\n        d = smax(d, abs(q.y) - CANDY_HEIGHT, CANDY_SMOOTHNESS);\n        \n        if (d < dist)\n        {\n            dist = d;\n            local = q;\n        }\n    }\n    \n    return vec4(dist, local);\n}\n\nvec3 norm(vec3 point) \n{\n    float d0 = map(point).x;\n    float dX = map(point - vec3(NORMAL_EPSILON, 0.0, 0.0)).x;\n    float dY = map(point - vec3(0.0, NORMAL_EPSILON, 0.0)).x;\n\tfloat dZ = map(point - vec3(0.0, 0.0, NORMAL_EPSILON)).x;\n    return normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nvec4 raymarch(vec3 rayOrigin, vec3 rayDir) \n{\n\tfloat d = 0.0;\n\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n\t\tvec3 point = rayOrigin + (rayDir * d);\n\t\tvec4 s = map(point);\n        \n    \tif (s.x < EPSILON) \n            return vec4(d, s.yzw);\n        \n    \td += s.x;\n    \tif (d > MAX_DISTANCE) \n            return vec4(MAX_DISTANCE, vec3(0.0));\n  \t}\n    \n    return vec4(MAX_DISTANCE, vec3(0.0));\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float dt = 0.1;\n    float t = mint;\n    for( int i=0; i<30; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        h = max(h,0.0);\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += dt;\n\t\tif( h<0.001 ) break;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Obtain the screen uv\n    vec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Camera\n    vec3 camPos = vec3(0.0, 2.0, -2.5);\n    vec3 camLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(camLookAt - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, forward);\n    \n    // Calculate a ray for each pixel\n    vec3 rayDir = normalize((up * uv.y) + (right * uv.x) + (forward * 1.0));\n    vec4 d = raymarch(camPos, rayDir);\n    \n    // Blue background\n    vec4 col = mix(vec4(0.1, 0.3, 0.6, 1.0), vec4(0.15, 0.5, 1.0, 1.0), 1.0 - min(1.0, length(uv) / 1.4));\n    \n    if (d.x < MAX_DISTANCE) \n    {     \n        // Calculate lighting\n        vec4 ambient = vec4(0.1, 0.1, 0.3, 1.0);\t\t// Blue-ish ambient light\n        vec3 lightPos = vec3(0.0, 3.0, 1.0);\n        vec3 point = camPos + rayDir * d.x;\n        vec3 normal = norm(point);\n        vec3 lightDir = -normalize(lightPos - point);\n        float ndotl = max(0.0, dot(lightDir, normal));\n        \n        // Specular\n        vec3 h = normalize(lightDir + forward);\n        float nh = max(0.0, dot(normal, h));\n        float spec = pow(nh, 48.0);\n        \n        // Add color\n        vec4 red = vec4(0.9, 0.1, 0.1, 1.0);\n        vec4 white = vec4(1.0, 0.96, 0.96, 1.0);\n        float radius = length(d.yw);\n        float angle = atan(d.w, d.y);\n        float offset = 0.3 * sin(radius * 5.0) * 0.3;\n        float stripe = cos((angle + offset) * 10.0) * 2.0;\n        \n        col = mix(white, red, max(0.0, stripe));\n        col = mix(white, col, smoothstep(0.5, 2.0, radius));\n        \n        float shadow = softshadow(point, -lightDir, 0.06, 3.0, 3.0);\n        col += spec * 0.4;\n        \n        col = mix(ambient, col, clamp(min(ndotl, shadow), 0.35, 1.0));\n        \n        // Gamma correction\n        col = pow(clamp(col, 0.0, 1.0), vec4(0.45));\n    }\n    \n    fragColor = col; \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4tsGz2","date":"1423443905","viewed":314,"name":"Peppermint Candy Rain","username":"SeventySevian","description":"Quite happy with my first shader. Might not be optimal in many ways, but thanks to iq, I did learn a lot!","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","candy"],"hasliked":0,"parentid":"","parentname":""}}