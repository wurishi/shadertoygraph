{"ver":"0.1","info":{"id":"ttjcWh","date":"1594271783","viewed":830,"name":"Cloudy Shapes temporal upsample","username":"ming","description":"Applying a temporal upsampling filter to the original \"Cloudy Shapes Shader\"\nhttps://www.shadertoy.com/view/WdXGRj\n\nSo that less ray-marching steps is used:\nOriginal: MAX_STEPS=48\nThis: MAX_STEPS=16\n","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["volume","raymarch","cloud","jitter","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///\n/// Original shader: https://www.shadertoy.com/view/WdXGRj\n///\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = getTime(iFrame);\n    \n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro, rd;\n    screenToViewRay(p, time, ro, rd);\n    \n    // r - sun light intensity\n    // g - ambient light intensity\n    // b - unused\n    // a - transmittance\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n#ifdef USE_MIPMAPS\n    #ifdef NOISY\n    vec4 cloud = textureLod(iChannel0, uv, 0.0);\n    #else\n    // due with the jittering noise with mipmaps\n    vec4 cloud = \n        textureLod(iChannel0, uv, 0.0) +\n        textureLod(iChannel0, uv, 2.0) +\n        textureLod(iChannel0, uv, 4.0) +\n        textureLod(iChannel0, uv, 8.0);\n        \n    cloud *= 0.25;\n    \n    #endif\n#elif defined(SHOW_COMPARE)\n\n    vec4 cloud;\n    \n    if (fragCoord.x >= iResolution.x / 2.0)\n    {\n        cloud = \n        textureLod(iChannel0, uv, 0.5) +\n        textureLod(iChannel0, uv, 3.5) +\n        textureLod(iChannel0, uv, 6.5) +\n        textureLod(iChannel0, uv, 9.5);\n        \n        cloud *= 0.25;\n    }\n    else\n    {\n        cloud = textureLod(iChannel0, uv, 0.0);\n    }\n#else\n    cloud = textureLod(iChannel0, uv, 0.0);\n#endif    \n    \n    vec4 col = vec4(cloud.r * vec3(1.1, 0.9, .5) + cloud.g * vec3(0.15, 0.45, 1.1), cloud.a);\n    vec3 result = col.rgb + mix(vec3(0.3, 0.6, 1.0), vec3(0.05, 0.35, 1.0), p.y + 0.75) * (col.a);\n    \n    float sundot = clamp(dot(rd,normalize(vec3(1.0, 2.0, 1.0))),0.0,1.0);\n    result += 0.4*vec3(1.0,0.7,0.3)*pow( sundot, 4.0 );\n\n    result = pow(result, vec3(1.0/2.2));\n    \n    fragColor = vec4(result,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"///\n/// Original shader: https://www.shadertoy.com/view/WdXGRj\n///\n\n\n\n\nfloat jitter;\n\n#define MAX_STEPS 16\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2.\n\n// Reference\n// https://shaderbits.com/blog/creating-volumetric-ray-marcher\nvec4 cloudMarch(vec3 p, vec3 ray, float time)\n{\n    float density = 0.;\n\n    float stepLength = VOLUME_LENGTH / float(MAX_STEPS);\n    float shadowStepLength = SHADOW_LENGTH / float(SHADOW_STEPS);\n    vec3 light = normalize(vec3(1.0, 2.0, 1.0));\n\n    vec4 sum = vec4(0., 0., 0., 1.);\n    \n    vec3 pos = p + ray * jitter * stepLength;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        \n        float d = map(pos, time);\n    \n        if( d > 0.001)\n        {\n            vec3 lpos = pos + light * jitter * shadowStepLength;\n            float shadow = 0.;\n    \n            for (int s = 0; s < SHADOW_STEPS; s++)\n            {\n                lpos += light * shadowStepLength;\n                float lsample = map(lpos, time);\n                shadow += lsample;\n            }\n    \n            density = clamp((d / float(MAX_STEPS)) * 20.0, 0.0, 1.0);\n            float s = exp((-shadow / float(SHADOW_STEPS)) * 3.);\n            \n            // sun light\n            sum.r += (s * density) * sum.a;\n            \n            // transmittance\n            sum.a *= 1.-density;\n\n            // ambient light\n            sum.g += exp(-map(pos + vec3(0,0.25,0.0), time) * .2) * density * sum.a;\n        }\n        pos += ray * stepLength;\n    }\n\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = getTime(iFrame);\n    \n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float seed = texture(iChannel1, fragCoord.xy / iChannelResolution[1].xy).x;\n    \n    jitter = Halton2(int(seed * 1024.0) + iFrame);\n    \n    vec3 ro, rd;\n    screenToViewRay(p, time, ro, rd);\n   \n    \n    vec4 curr = cloudMarch(ro, rd, time);\n    \n    vec4 prev = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n#ifdef USE_MIPMAPS\n    fragColor = prev + (curr - prev) * 0.875;\n#elif defined(SHOW_COMPARE)\n    // this will introduce ghosting\n    if (fragCoord.x >= iResolution.x / 2.0)\n        fragColor = prev + (curr - prev) * 0.875;\n    else\n        fragColor = prev + (curr - prev) * 0.05;\n#else\n        fragColor = prev + (curr - prev) * 0.05;\n#endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"///\n/// Original shader: https://www.shadertoy.com/view/WdXGRj\n///\n\n// Comment USE_MIPMAPS to see the old method which introduce ghosting\n#define USE_MIPMAPS\n\n#define SHOW_COMPARE\n\n//#define NOISY\n\n// noise\n// Volume raycasting by XT95\n// https://www.shadertoy.com/view/lss3zr\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n              \nfloat Halton(int b, int i)\n{\n    float r = 0.0;\n    float f = 1.0;\n    while (i > 0) {\n        f = f / float(b);\n        r = r + f * float(i % b);\n        i = int(floor(float(i) / float(b)));\n    }\n    return r;\n}\n\nfloat Halton2(int i)\n{\n#if __VERSION__ >= 400\n\treturn float(bitfieldReverse(uint(i)))/4294967296.0;\n#else\n\treturn Halton(2, i);\n#endif\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p );\n    return f;\n}\n/////////////////////////////////////\n\nfloat stepUp(float t, float len, float smo)\n{\n  float tt = mod(t += smo, len);\n  float stp = floor(t / len) - 1.0;\n  return smoothstep(0.0, smo, tt) + stp;\n}\n\n// iq's smin\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid screenToViewRay(vec2 p, float time, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(cos(time) * 8.0, -5.5, sin(time) * 8.0);\n    vec3 ta = vec3(0.0, 1., 0.0);\n    mat3 viewmat = camera(ro, ta, 0.0);\n    \n    rd = viewmat * normalize(vec3(p, 1.75));\n    \n}\n\nfloat getTime(int frame)\n{\n    return float(frame) * 0.03;\n}\n\nfloat map( in vec3 p, float time )\n{\n\tvec3 q = p - vec3(0.0,0.5,1.0)*time;\n    float f = fbm(q);\n    float s1 = 1.0 - length(p * vec3(0.5, 1.0, 0.5)) + f * 2.2;\n    float s2 = 1.0 - length(p * vec3(0.1, 1.0, 0.2)) + f * 2.5;\n    float torus = 1. - sdTorus(p * 2.0, vec2(6.0, 0.005)) + f * 3.5;\n    float s3 = 1.0 - smin(smin(\n                           length(p * 1.0 - vec3(cos(time * 3.0) * 6.0, sin(time * 2.0) * 5.0, 0.0)),\n                           length(p * 2.0 - vec3(0.0, sin(time) * 4.0, cos(time * 2.0) * 3.0)), 4.0),\n                           length(p * 3.0 - vec3(cos(time * 2.0) * 3.0, 0.0, sin(time * 3.3) * 7.0)), 4.0) + f * 2.5;\n    \n    float t = mod(stepUp(time, 4.0, 1.0), 4.0);\n    \n\tfloat d = mix(s1, s2, clamp(t, 0.0, 1.0));\n    d = mix(d, torus, clamp(t - 1.0, 0.0, 1.0));\n    d = mix(d, s3, clamp(t - 2.0, 0.0, 1.0));\n    d = mix(d, s1, clamp(t - 3.0, 0.0, 1.0));\n    \n\treturn min(max(0.0, d), 1.0);\n}","name":"Common","description":"","type":"common"}]}