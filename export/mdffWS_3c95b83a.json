{"ver":"0.1","info":{"id":"mdffWS","date":"1689113538","viewed":88,"name":"Schrödinger Equation","username":"chronos","description":"See Image tab!","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["complex","physics","quantum","equation","equation","imaginary","pde","differential","schrdinger"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nDisclaimer!\n\nI'm neither a physicist nor an expert in numerical solutions to differential equations, so this is probably very wrong.\nIt was a bit tricky to get it to be stable at all. I had to resort to using a difference of gaussian approximation\nto the Laplacian in order to get it to not explode immediately xD\nIt still blows up after a while, but at least it looks like it behaves reasonably for a while.\n\nApparently it should also be normalized to have a unit integral. Maybe that would help with stabiliy as well(?)\n\nIf anyone has any input on how to make this more stable and/or correct, please let me know!\nTips for numberical solutions to differential equations in shaders are also very welcome!\n\nCurrently there seems to be some high frequency ringing, especially on the wave peaks, so perhaps that is a hint?\n(Update: Turns out that was due to the plotting function being bad, thanks to @spalmer for the info!\nI wrote a new plotting function that should be better quality, although the code quality and performance could be better...)\n\nAlso, this is a simplified version of the Schrödinger equation used in physics, without any physical units, as far as I can tell :)\n\n*/\n\n// Inspired by tweet by Gabriel Peyre\n// https://twitter.com/gabrielpeyre/status/1325317126505238528?lang=en\n\n// Basically simulating: df/dt = i * laplacian(f)\n\n// Another reference with similar goals:\n// https://liam-ilan.github.io/time-dependent-schrodinger-equation/\n\n\nconst float GAMMA = 2.2;\nconst float line_thickness = 0.005;\nconst float line_thickness_px = 4.;\n\n#define PLOT_METHOD 1\n\nfloat plot(float f, float y, float pixels_per_uv)\n{\n    float func_dx   = dFdx(f) * pixels_per_uv; \n\n    float factor = sqrt(1. + func_dx * func_dx);\n    float plot_distance = abs(f - y) / factor;\n    float eps = fwidth(plot_distance);\n    float real_plot = smoothstep(line_thickness+eps, line_thickness-eps, plot_distance);\n    return real_plot;\n}\n\nvec2 get_sample(float x)\n{\n    // manual bilinear xD\n    float X = ((x * iResolution.y) + iResolution.x) / 2.;\n    \n    vec2 a = texelFetch(iChannel0, ivec2(floor(X),0),0).xy;\n    vec2 b = texelFetch(iChannel0, ivec2(ceil(X),0),0).xy;\n    \n    return mix(a, b, fract(X));\n    return a;\n}\n\nvec2 plot_func(float x, float y)\n{\n    float num_pix = 6.;\n    float pix_width = 1./iResolution.y;\n    \n    float real_dist = 9e9;\n    float imag_dist = 9e9;\n    \n    for(float i = -num_pix; i < num_pix; ++i)\n    {\n        float a_x = x + pix_width * i;\n        float b_x = x + pix_width * (i+1.);\n        vec2 a_y = get_sample(a_x);\n        vec2 b_y = get_sample(b_x);\n        \n        float real = distance_point_line_segment(vec2(x,y), vec2(a_x, a_y.r), vec2(b_x, b_y.r));\n        float imag = distance_point_line_segment(vec2(x,y), vec2(a_x, a_y.g), vec2(b_x, b_y.g));\n        \n        real_dist = min(real_dist, real);\n        imag_dist = min(imag_dist, imag);\n    }\n    return vec2(real_dist, imag_dist);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 color = vec3(0.9);\n\n    vec2 function = get_sample(uv.x);\n    \n    float real_func = function.x;\n    float imag_func = function.y;\n    float amplitude_func = dot(function, function);\n    \n    float pixels_per_uv = iResolution.y * .5; // (iResolution.y / 2.) is the number of pixels in a uv.x distance of 1\n    \n    float real_plot = plot(real_func, uv.y, pixels_per_uv);\n\n    vec3 real_line_color = vec3(0,0,1);\n    \n    float imag_plot = plot(imag_func, uv.y, pixels_per_uv);\n\n    vec3 imag_line_color = vec3(0,1,0);\n    \n    vec3 amplitude_line_color = vec3(1,0,0);\n    \n    float amp_plot = plot(amplitude_func, uv.y, pixels_per_uv);\n\n    #if PLOT_METHOD == 1\n    float plot_real = 0.;\n    float plot_imag = 0.;\n    const float NUM_AA = 4.;\n    for (float AAx = 0.; AAx < NUM_AA; AAx++)\n    for (float AAy = 0.; AAy < NUM_AA; AAy++)\n    {\n        float pix_width = 1./iResolution.y;\n        float x = uv.x - (pix_width / 2.) + pix_width * (AAx/(NUM_AA-1.));\n        float y = uv.y - (pix_width / 2.) + pix_width * (AAy/(NUM_AA-1.));\n        vec2 plot_dist = plot_func(x, y);\n        float eps_real = pix_width*1.5;\n        float eps_imag = pix_width*1.5;\n        float width = line_thickness_px/iResolution.y;\n\n        plot_real += smoothstep(width+eps_real, width-eps_real, plot_dist.x);\n        plot_imag += smoothstep(width+eps_imag, width-eps_imag, plot_dist.y);\n    }\n    \n    plot_real /= (NUM_AA*NUM_AA);\n    plot_imag /= (NUM_AA*NUM_AA);\n    \n    color = mix(color, real_line_color, plot_real);\n    color = mix(color, imag_line_color, plot_imag);\n\n    #elif 0\n    color = mix(color, real_line_color, (max(real_func,0.) * 0.5));\n    color = mix(color, 1.-real_line_color, (max(-real_func,0.) * 0.5));\n    \n    color = mix(color, imag_line_color, (max(imag_func,0.) * 0.5));\n    color = mix(color, 1.-imag_line_color, (max(-imag_func,0.) * 0.5));\n    #else\n    color = mix(color, real_line_color, real_plot);\n    color = mix(color, imag_line_color, imag_plot);\n    color = mix(color, amplitude_line_color, amp_plot * 0.5);\n    #endif\n    \n    fragColor = vec4(pow(color, vec3(1./GAMMA)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simulation\n\nvec2 get_sample(float x)\n{\n    return texelFetch(iChannel0, ivec2((int(x)+int(iResolution.x))%int(iResolution.x),0),0).xy;\n}\n\nvec2 sample_neighbours(float x)\n{\n    vec2 sum = vec2(0);\n    float total_weight = 0.;\n    for(int i = -20; i <= 20; i++)\n    {\n        float w = get_neighbour_weight(float(i));\n        sum += w * get_sample(x + float(i));\n        total_weight += w;\n    }\n    return sum / total_weight;\n}\n\nvec2 sample_center(float x)\n{\n    vec2 sum = vec2(0);\n    float total_weight = 0.;\n    for(int i = -10; i <= 10; i++)\n    {\n        float w = get_center_weight(float(i));\n        sum += w * get_sample(x + float(i));\n        total_weight += w;\n    }\n    return sum / total_weight;\n}\n\nvec2 schrodinger_equation(float x)\n{\n    vec2 laplacian = sample_neighbours(x) - sample_center(x); // difference of gaussians approximation\n    \n    // multiply by imaginary unit\n    vec2 time_derivative = vec2(-1, 1) * laplacian.yx;\n    \n    return time_derivative;\n}\n\nvec2 get_next_timestep(float x)\n{\n    vec2 dfdt = schrodinger_equation(x);\n    vec2 previous = get_sample(x);\n    float dt = 0.1; // iTimeDelta;\n    vec2 result = previous + dfdt * dt;\n    return result;\n}\n\nvec2 GaussianWavePacket(float x, float k)\n{\n    float sigma = 0.25;\n    float mean = 0.;\n    return vec2(cos(k * x), sin(k * x)) * gaussian(mean, sigma, x);\n}\n\nvec2 init(float x)\n{    \n    float k = 35.;\n    return GaussianWavePacket(x, k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 result = get_next_timestep(fragCoord.x);\n\n    if(iFrame <= 10)\n    {   \n        vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n        result = init(uv.x);\n    }\n\n    fragColor = vec4(result, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float gaussian(float mean, float sigma, float x)\n{\n    float offset = (x - mean)/sigma;\n    return exp(-0.5 * offset * offset) / (sigma * sqrt(2. * 3.14159));\n}\n\nfloat get_neighbour_weight(float x)\n{\n    return gaussian(0., 5., x);\n}\n\nfloat get_center_weight(float x)\n{\n    return gaussian(0., 3., x);\n}\n\nvec2 project_point_on_line_segment(vec2 point, vec2 a, vec2 b)\n{\n    vec2 ab = b-a;\n    \n    float l = dot(point-a, ab) / dot(ab,ab);\n    \n    l = clamp(l, 0., 1.);\n    \n    return mix(a, b, l);\n}\n\n\nfloat distance_point_line_segment(vec2 point, vec2 a, vec2 b)\n{\n    return distance(point, project_point_on_line_segment(point, a, b));\n}","name":"Common","description":"","type":"common"}]}