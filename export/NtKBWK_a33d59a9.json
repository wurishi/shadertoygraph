{"ver":"0.1","info":{"id":"NtKBWK","date":"1665262914","viewed":96,"name":"autopilot","username":"jt","description":"A basic space-ship style autopilot implementation: Given a list of waypoints the plane orientates towards current waypoint and accelerates attempting to match speed.\nMouse controls global camera, lower left corner: demo. Info and Controls see Common tab.\n","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["simulation","dynamics","quaternion","control","quaternions","rigidbody","body","rigid","autopilot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// see common tab for infos\n\n#define EPSILON 0.001\n#define DIST_MAX 1000.0\n\n// https://iquilezles.org/articles/distfunctions/\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat halfspace(vec3 p)\n{\n    return p.z;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat udLine( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nstruct result\n{\n    float dist;\n    uint id;\n};\n\n//result union(result a, result b) // ERROR: 'union' : Illegal use of reserved word\nresult combine(result a, result b)\n{\n    //return a.dist < b.dist ? a : b; // ERROR: '? : '\n    if(a.dist < b.dist) return a;\n    return b;\n}\n\nfloat plane(vec3 p)\n{\n    //return udTriangle(p, vec3(-0.5,-1,0), vec3(+0.5,-1,0), vec3(0,+1,0)) - 0.1;\n    float d = udTriangle(p, vec3(0,-1,1.0), vec3(0,-1,0), vec3(0,+1,0));\n    d = min(d, udTriangle(p, vec3(-1,-1,-0.5), vec3(0,-1,0), vec3(0,+1,0)));\n    d = min(d, udTriangle(p, vec3(+1,-1,-0.5), vec3(0,-1,0), vec3(0,+1,0)));\n    return d - 0.025;\n}\n\nresult map(vec3 p, state s)\n{\n    //result r = result(plane(rotate(s.orientation, p - s.position)), 0u);\n    result r = result(plane(rotate(p - s.position, s.orientation)), 0u);\n    //r = combine(r, result(udLine(p, s.position, waypoints[s.waypoint]) - 0.01, 0u));\n    for(uint i = 0u; i < uint(waypoints.length()/* length should have return type uint - arrays can't have negative amount of elements */); i++)\n    {\n        r = combine(r, result(sdSphere(p - waypoints[i], 1.0), i + 1u));\n    }\n    //r = combine(r, result(sdBox(p - waypoints[s.waypoint], vec3(1.0)), 0u)); // mark current waypoint\n    r = combine(r, result(sdBoxFrame(p - waypoints[s.waypoint], vec3(1.0), 0.05),~0u)); // mark current waypoint\n    float dist = distance(s.position, waypoints[s.waypoint]);\n    vec3 project = s.position + dist * rotate(s.orientation, vec3(0,1,0)/*local forward*/); // project tangent of trajectory\n    r = combine(r, result(sdSphere(p - project, 0.2), ~0u));\n    if(texelFetch( iChannel1, ivec2(71/*'G'*/,2),0).x >= 0.5)\n        r = combine(r, result(halfspace(p + vec3(0,0,50)), 0u)); // ground\n\n    return r;\n}\n\n// modified https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p, state s) \n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map(p + k.xyy*h, s).dist + \n                      k.yyx*map(p + k.yyx*h, s).dist + \n                      k.yxy*map(p + k.yxy*h, s).dist + \n                      k.xxx*map(p + k.xxx*h, s).dist);\n}\n\nresult trace(vec3 ro, vec3 rd, float t0, float t1, state s)\n{\n    for(float t = t0; t < t1;)\n    {\n        result h = map(ro + rd * t, s);\n        if(h.dist < EPSILON)\n            return result(t, h.id);\n        t += h.dist;\n    }\n    return result(t1, 0u);\n}\n\n#define pi 3.1415926\n\nvec3 palette(float t)\n{\n    return cos(2.0 * pi * (t + vec3(0,1,2)/3.0)) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    state s = decode(iChannel0);\n    //s.position = vec3(0.5,0,0);\n\n    vec2 p = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    p.x *= float(iResolution.x) / float(iResolution.y);\n    \n    vec3 ro = vec3(0.0, 0.0,-40.0);\n    vec3 rd = normalize(vec3(0.5 * p.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n\n    bool localview = (iMouse.x > 10.0 || iMouse.y > 10.0) ? (texelFetch( iChannel1, ivec2(32/*SPACE*/,2),0 ).x >= 0.5) : (cos(2.0 * pi * iTime / 10.0) < 0.0);\n    if(localview) // lock-on to plane position\n    {\n        if(localview) // lock-on to plane rotation\n        {\n            rd.xy = -rd.xy; // workaround - messed up the rotation somewhere\n            mat2 Pitch = mat2(vec2(0.0,1.0), vec2(-1.0, 0.0));\n            rd.yz = Pitch * rd.yz;\n            rd = rotate(s.orientation, -rd);\n            ro = s.position + rotate(s.orientation, vec3(0,-5,0));\n        }\n        else\n        {\n            mat2 Pitch = mat2(vec2(0.0,1.0), vec2(-1.0, 0.0));\n            rd.yz = Pitch * rd.yz;\n            ro = s.position + vec3(0,5,0);\n        }\n    }\n    else\n    {\n        float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n        float my = pi  + pi * float(-iMouse.y) / float(iResolution.y);\n        mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * fract(iTime * 0.01);\n        my = (iMouse.y > 10.0) ? my : pi / 2.0;\n\n        mat2 Yaw = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n        //mat2 Pitch = mat2(vec2(0.0, 1.0), vec2(-1.0, 0.0));\n        mat2 Pitch = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n        ro.yz = Pitch * ro.yz;\n        ro.xy = Yaw * ro.xy;\n        rd.yz = Pitch * rd.yz;\n        rd.xy = Yaw * rd.xy;\n    }\n\n    result r = trace(ro, rd, 0.0, DIST_MAX, s);\n    \n    vec3 color = vec3(0);\n    if(r.dist < DIST_MAX)\n    {\n        if(r.id != ~0u)\n        {\n            vec3 dst = ro + rd * r.dist;\n            vec3 n = normal(dst, s);\n\n            vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n            vec3 ambient = vec3(0.05);\n            float brightness = max(dot(lightdir, n), 0.0);\n            float specular = pow(max(0.0, dot(normalize(rd + lightdir), n)), 50.0);\n            color = (r.id == 0u) ? vec3(s.approach ? 1.0 : 0.5) : palette(float(r.id) / float(waypoints.length()));\n            color = (ambient + brightness) * color;\n            color += specular;\n        }\n        else\n        {\n            color = pow(mix(vec3(0,0.25,0),vec3(0.75,1,0.75), vec3(cos(2.0 * pi * iTime) * 0.5 + 0.5)), vec3(2.0)); // mark green when distance decreasing\n            if(!s.approach)\n                //color.xy = color.yx; // mark red if distance increasing\n                color.yz = color.zy; // mark blue if distance increasing\n            bool combined = (texelFetch( iChannel1, ivec2(67/*'G'*/,2),0).x >= 0.5);\n            if(combined)\n                color.x = 1.0;\n        }\n    }\n    \n    fragColor = vec4(sqrt(color), 1.0); // approximate gamma\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://www.shadertoy.com/view/NtKBWK autopilot by jt\n\n// A basic space-ship style autopilot implementation: Given a list of waypoints\n// the plane orientates towards current waypoint and accelerates attempting to match speed.\n\n// tags: simulation, dynamics, quaternion, control, quaternions, rigidbody, body, rigid, autopilot\n\n// MIT license, from https://www.shadertoy.com/terms\n\n/*\n\nCopyright (c) 2022 Jakob Thomsen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\n// CONTROLS: SPACE toggles view, 'g' toggles ground, 'c' toggles combined control mode, '0'-'8' select waypoint manually - if possible\n//           (Sometimes it appears a waypoint can't be selected because the conditions to advance to the next are immediately fulfilled). \n\n// NOTE: using vec4 here would be more concise - but when quaternions have their own type,\n//       the type-checking done by the glsl compiler can be used to detect errors\n//       caused by accidentally confusing vec4 with quaternions\n//       (e.g. accidentally multiplying a quaternion with an axis-angle, both stored in vec4).\n//       Also in mathematical notation usually the real part is written first, followed by the imaginary part:\n//       w + xi + yj + zk while the vec4 constructor expects x, y, z, w.\n//       A minor convenience: vector-scalar notation simplifies accessing vector-part in rotation.\n//       When defining a quaternion type the mathematical order can be chosen.\n//       Last but not least using an own type for quaternions allows to overload functions, like norm\n//       (this becomes increasingly valuable when introducing more systems,\n//        like complex numbers, dual numbers, dual quaternions...)\n\n// https://en.wikipedia.org/wiki/Quaternion\nstruct quat\n{\n    float s;\n    vec3 v;\n};\n\n// NOTE: https://en.wikipedia.org/wiki/Quaternion#Quaternions_and_the_space_geometry\n// NOTE: The cross-product of the vector-parts of any quaternions p, q can be expressed by (pq - qp)/2\n//       (the scalar part of this expression always evaluates to zero)\n//       (the expression pq - qp is apparently called \"commutator\")\n// NOTE: The dot-product of all four components of quaternions p, q can be expressed by (pq* + qp*)/2\n//       (where * denotes the quaternion conjugate, i.e. negation of the vector-part)\n// NOTE: This is straight forward but cumbersome to check - use e.g. Maxima:\n//       % quaternion-multiplication (in component form)\n//       a_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*a_2 - b_1*b_2 - c_1*c_2 - d_1*d_2;\n//       b_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*b_2 + b_1*a_2 + c_1*d_2 - d_1*c_2;\n//       c_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) := a_1*c_2 - b_1*d_2 + c_1*a_2 + d_1*b_2;\n//       d_3(a_1, b_1, c_1, d_1, a_2, b_2, c_2, d_2) :=a_1 * d_2 + b_1 * c_2 - c_1 * b_2 + d_1 * a_2;\n//       % evaluate squared norm |q|^2 = qq* = a^2 + b^2 + c^2 + d^2\n//       a_3(a,b,c,d,a,-b,-c,-d);b_3(a,b,c,d,a,-b,-c,-d);c_3(a,b,c,d,a,-b,-c,-d);d_3(a,b,c,d,a,-b,-c,-d);\n//       % evaluate (pq - qp)\n//       a_3(a,b,c,d,A,B,C,D)-a_3(A,B,C,D,a,b,c,d);b_3(a,b,c,d,A,B,C,D)-b_3(A,B,C,D,a,b,c,d);c_3(a,b,c,d,A,B,C,D)-c_3(A,B,C,D,a,b,c,d);d_3(a,b,c,d,A,B,C,D)-d_3(A,B,C,D,a,b,c,d);\n//       % evaluate (pq* + qp*)\n//       a_3(a,b,c,d,A,-B,-C,-D)+a_3(A,B,C,D,a,-b,-c,-d);b_3(a,b,c,d,A,-B,-C,-D)+b_3(A,B,C,D,a,-b,-c,-d);c_3(a,b,c,d,A,-B,-C,-D)+c_3(A,B,C,D,a,-b,-c,-d);d_3(a,b,c,d,A,-B,-C,-D)+d_3(A,B,C,D,a,-b,-c,-d);\n\nquat quat_identity()\n{\n    return quat(1.0, vec3(0.0, 0.0, 0.0));\n}\n\nquat conjugate(quat q)\n{\n    return quat(q.s,-q.v);\n}\n\nfloat norm_squared(quat q)\n{\n    return q.s * q.s + dot(q.v, q.v);\n}\n\nfloat norm(quat q)\n{\n    return sqrt(norm_squared(q));\n}\n\nquat mul(float s, quat q)\n{\n    return quat(s * q.s, s * q.v);\n}\n\nquat mul(quat q, float s)\n{\n    return quat(s * q.s, s * q.v);\n}\n\nquat div(quat q, float s)\n{\n    return quat(q.s / s, q.v / s);\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat normalify(quat q) // NOTE: can't reuse function name normalize here\n{\n    return div(q, norm(q));\n}\n\n//quat normalize(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\n//quat inverse(quat q) // ERROR: \"Name of a built-in function cannot be redeclared as function\"\nquat inv(quat q) // NOTE: can't reuse function name inverse here\n{\n    return div(conjugate(q), norm_squared(q));\n}\n\nquat div(float s, quat q)\n{\n    return mul(s, inv(q));\n}\n\nquat neg(quat q)\n{\n    return quat(-q.s,-q.v);\n}\n\nquat add(quat a, quat b)\n{\n    return quat(a.s + b.s, a.v + b.v);\n}\n\nquat sub(quat a, quat b)\n{\n    return quat(a.s - b.s, a.v - b.v);\n}\n\nquat mul(quat a, quat b)\n{\n    return quat(a.s * b.s - dot(a.v, b.v), a.s * b.v + b.s * a.v + cross(a.v, b.v));\n}\n\nquat div(quat a, quat b)\n{\n    return mul(a, inv(b));\n}\n\nvec3 rotate(quat q, vec3 v)\n{\n    return mul(mul(q, quat(0.0, v)), inv(q)).v;\n}\n\n// inverse rotation\nvec3 rotate(vec3 v, quat q)\n{\n    return mul(mul(inv(q), quat(0.0, v)), q).v;\n}\n\nquat by_vec4(vec4 v)\n{\n    return quat(v.w, vec3(v));\n}\n\nvec4 to_vec4(quat q)\n{\n    return vec4(q.v, q.s);\n}\n\n#define dt (1.0/60.0)\n\nvec3 waypoints[] =\n    vec3[]\n    (\n        10.0 * vec3(0,0,0),\n        10.0 * vec3(+1,+1,+1),\n        10.0 * vec3(-1,+1,+1),\n        10.0 * vec3(+1,-1,+1),\n        10.0 * vec3(-1,-1,+1),\n        10.0 * vec3(+1,+1,-1),\n        10.0 * vec3(-1,+1,-1),\n        10.0 * vec3(+1,-1,-1),\n        10.0 * vec3(-1,-1,-1)\n    );\n\nstruct state\n{\n    vec3 position;\n    quat orientation;\n    vec3 velocity;\n    vec3 rotation;\n    uint waypoint;\n    bool approach;\n};\n\n//vec3 align(state s) // rotate towards current waypoint\n//{\n//    vec3 diff_global = waypoints[s.waypoint] - s.position;\n//    vec3 diff_local = rotate(diff_global, s.orientation);\n//    vec3 delta_rotation_local = 2.0 * cross(vec3(0, 1, 0)/*forward*/, diff_local);\n//    vec3 delta_rotation_global = rotate(s.orientation, delta_rotation_local);\n//    //delta_rotation_global += cross(vec3(0, 0,1)/*global up*/, rotate(vec3(0, 0, 1)/*local up*/, s.orientation)); // try to maintain \"up\"\n//    return delta_rotation_global;\n//}\n\nvec3 align(state s, bool combined, bool maintainup) // rotate towards current waypoint\n{\n    vec3 diff_global = waypoints[s.waypoint] - s.position;\n    if(length(diff_global) != 0.0)\n    {\n        diff_global = normalize(diff_global);\n        vec3 diff_local = rotate(diff_global, s.orientation);\n        vec3 sky_local = rotate(vec3(0, 0, 1)/*global up*/, s.orientation);\n        vec3 delta_rotation_local = vec3(0);\n        if(combined) // control all angles at once\n        {\n            delta_rotation_local += 20.0 * cross(vec3(0, 1, 0)/*local forward*/, diff_local);\n            if(maintainup)\n                delta_rotation_local += 10.0 * cross(vec3(0, 0, 1)/*local up*/, sky_local); // try to maintain \"up\"\n        }\n        else // control angles separately\n        {\n            delta_rotation_local.x += 20.0 * atan(diff_local.z, diff_local.y); // pitch\n            delta_rotation_local.y += 20.0 * atan(diff_local.x, diff_local.z); // roll\n            delta_rotation_local.z -= 20.0 * atan(diff_local.x, diff_local.y); // yaw\n            \n            if(maintainup)\n                delta_rotation_local += 50.0 * cross(vec3(0, 0, 1)/*local up*/, sky_local); // try to maintain \"up\"\n        }\n\n        vec3 delta_rotation_global = rotate(s.orientation, delta_rotation_local);\n        //delta_rotation_global += 20.0 * cross(vec3(0, 0,1)/*global up*/, rotate(vec3(0, 0, 1)/*local up*/, s.orientation)); // try to maintain \"up\"\n        return delta_rotation_global;\n    }\n    \n    return vec3(0);\n}\n\nbool can_lock(vec3 pos_diff, vec3 vel_diff)\n{\n    return dot(pos_diff, vel_diff) < 0.0;\n}\n\n// https://www.chrishecker.com/Rigid_Body_Dynamics \"Rigid Body Dynamics\" by Chris Hecker\n// https://www.cs.cmu.edu/~baraff/sigcourse/notesd1.pdf \"An Introduction to Physically Based Modeling: Rigid Body Simulation I—Unconstrained Rigid Body Dynamics\" by David Baraff, Robotics Institute, Carnegie Mellon University\nstate update(state s) // rigid body\n{\n    s.position += s.velocity * dt;\n    s.orientation = add(s.orientation, mul(mul(quat(0.0, s.rotation), s.orientation), dt * 0.5));\n    s.orientation = normalify(s.orientation); // for stability\n\n    return s;\n}\n\nstate autopilot(state s, bool combined, bool maintainup)\n{\n    bool cl = can_lock(s.position - waypoints[s.waypoint], vec3(0) - s.velocity);\n    float d0 = distance(s.position, waypoints[s.waypoint]);\n    s = update(s);\n    float d1 = distance(s.position, waypoints[s.waypoint]);\n    if (d1 < d0) // distance to waypoint decreased\n    {\n        s.approach = true;\n    }\n    else if(d1 > d0) // distance to waypoint increased\n    {\n        if (s.approach && cl)\n        {\n            s.approach = false;\n            s.waypoint++;\n            if(s.waypoint >= uint(waypoints.length())) // workaround potential modulo bugs on windows\n                s.waypoint = 0u;\n        }\n    }\n\n    s.rotation = align(s, combined, maintainup) * dt; // rotate towards current waypoint\n\n    float acceleration = 10.0;\n    float damping = 5.0;\n    s.velocity += rotate(s.orientation, vec3(0, acceleration, 0)) * dt;\n    s.velocity += damping * (vec3(0) - s.velocity) * dt; // adjust to destination velocity\n\n    return s;\n}\n\n#define POSITION ivec2(0,0)\n#define ORIENTATION ivec2(1,0)\n#define VELOCITY ivec2(2,0)\n#define ROTATION ivec2(3,0)\n#define WAYPOINT ivec2(4,0)\n#define APPROACH ivec2(5,0)\n\nstate decode(sampler2D tex)\n{\n    state s;\n    s.position = vec3(texelFetch(tex, POSITION, 0));\n    s.orientation = by_vec4(texelFetch(tex, ORIENTATION, 0));\n    s.velocity = vec3(texelFetch(tex, VELOCITY, 0));\n    s.rotation = vec3(texelFetch(tex, ROTATION, 0));\n    s.waypoint = uint(floor(texelFetch(tex, WAYPOINT, 0).x));\n    s.approach = (texelFetch(tex, APPROACH, 0).x >= 0.5);\n    return s;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// see common tab for infos\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,0.0);\n\n    if(iFrame == 0)\n    {\n        if(ivec2(floor(fragCoord.xy)) == POSITION) fragColor = vec4(20.0,0.0,0.0,0.0);\n        if(ivec2(floor(fragCoord.xy)) == ORIENTATION) fragColor = vec4(0.0,0.0,0.0,1.0);\n        if(ivec2(floor(fragCoord.xy)) == VELOCITY) fragColor = vec4(0.0,0.0,0.0,0.0);\n        if(ivec2(floor(fragCoord.xy)) == ROTATION) fragColor = vec4(0.0,0.0,0.0,0.0);\n        if(ivec2(floor(fragCoord.xy)) == WAYPOINT) fragColor = vec4(0.0,0.0,0.0,0.0);\n        if(ivec2(floor(fragCoord.xy)) == APPROACH) fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n    else\n    {\n        state s = decode(iChannel0);\n        for(uint n = 0u; n < 10u; n++)\n            if(texelFetch( iChannel1, ivec2(48u/*'0'*/+n,1),0).x >= 0.5 && n < uint(waypoints.length())) s.waypoint = n;\n        bool combined = (texelFetch( iChannel1, ivec2(67/*'G'*/,2),0).x < 0.5);\n        bool maintainup = (texelFetch( iChannel1, ivec2(71/*'G'*/,2),0).x >= 0.5);\n        s = autopilot(s, combined, maintainup);\n        if(ivec2(floor(fragCoord.xy)) == POSITION) fragColor = vec4(s.position, 0.0);\n        if(ivec2(floor(fragCoord.xy)) == ORIENTATION) fragColor = to_vec4(s.orientation);\n        if(ivec2(floor(fragCoord.xy)) == VELOCITY) fragColor = vec4(s.velocity, 0.0);\n        if(ivec2(floor(fragCoord.xy)) == ROTATION) fragColor = vec4(s.rotation, 0.0);\n        if(ivec2(floor(fragCoord.xy)) == WAYPOINT) fragColor = vec4(s.waypoint);\n        if(ivec2(floor(fragCoord.xy)) == APPROACH) fragColor = vec4(s.approach ? 1.0 : 0.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}