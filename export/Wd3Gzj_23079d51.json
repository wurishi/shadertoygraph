{"ver":"0.1","info":{"id":"Wd3Gzj","date":"1568824998","viewed":175,"name":"Barth Decic","username":"skye_adaire","description":"Implicit equation taken from:\nhttp://mathworld.wolfram.com/BarthDecic.html","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["geometry","dual","real","algebraic","barth","decic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\n//begin Hypercomplex\n\n#define Real float\n#define Nat uint\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_inverse(Real r)\n{\n \treturn 1.0 / r;   \n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_power(Real x, Real e)\n{\n    return pow(x, e);\n}\n\nReal H_power(Real x, Nat e)\n{\n    return pow(abs(x), float(e)) * ((e % 2u) == 0u ? 1.0 : sign(x));\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\nReal H_sin(Real r)\n{\n    return sin(r);\n}\n\nReal H_cos(Real r)\n{\n    return cos(r);\n}\n\n#define DualReal vec2\n\nDualReal D_add(DualReal lhs, DualReal rhs)\n{\n    return lhs + rhs;\n}\n\nDualReal D_subtract(DualReal lhs, DualReal rhs)\n{\n    return lhs - rhs;\n}\n\nDualReal D_multiply(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_multiply(lhs[0], rhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualReal D_divide(DualReal lhs, DualReal rhs)\n{\n    return DualReal(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualReal D_power(DualReal d, Real exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\nDualReal D_power(DualReal d, Nat exponent)\n{\n    return DualReal(\n        H_power(d[0], exponent),\n        H_multiply(float(exponent) * H_power(d[0], exponent - 1u), d[1]));\n}\n\nDualReal D_sq(DualReal d)\n{\n \treturn D_multiply(d, d);   \n}\n\nDualReal D_inverse(DualReal d)\n{\n    return DualReal(\n        H_inverse(d[0]),\n        H_multiply(H_negate(H_inverse(H_sq(d[0]))), d[1]));\n}\n\nDualReal D_sin(DualReal d)\n{\n \treturn DualReal(\n        H_sin(d[0]), \n        H_multiply(d[1], H_cos(d[0])));   \n}\n                          \nDualReal D_cos(DualReal d)\n{\n \treturn DualReal(\n        H_cos(d[0]),\n        H_multiply(H_negate(d[1]), H_sin(d[0])));   \n}\n\n#define DualVector2 mat2x2\n#define DualVector3 mat3x2\n\n//end Hypercomplex\n\nDualReal f(int index, DualVector3 d)\n{\n    switch(index)\n    {\n        case 10:\n        {\nDualReal x = d[0];\n            DualReal x2 = D_multiply(x, x);\n            DualReal x3 = D_multiply(x, x2);\n            DualReal x4 = D_multiply(x, x3);\n            DualReal y = d[1];\n            DualReal y2 = D_multiply(y, y);\n            DualReal y3 = D_multiply(y, y2);\n            DualReal y4 = D_multiply(y, y3);\n            DualReal z = d[2];\n            DualReal z2 = D_multiply(z, z);\n            DualReal z3 = D_multiply(z, z2);\n            DualReal z4 = D_multiply(z, z3);\n            DualReal w = DualReal(1.5,0);\n            DualReal w2 = D_multiply(w, w);\n            DualReal w3 = D_multiply(w, w2);\n            DualReal w4 = D_multiply(w, w3);\n            \n            Real ro = 0.5 * (1.0 + 2.2360679775);\n            Real ro2 = ro * ro;\n            Real ro3 = ro * ro2;\n            Real ro4 = ro * ro3;\n            \n            DualReal t0 = 8.0 * (x2 - ro4 * y2);\n            DualReal t1 = y2 - ro4 * z2;\n            DualReal t2 = z2 - ro4 * x2;\n            DualReal t3 = x4 + y4 + z4 - 2.0 * D_multiply(x2, y2) - 2.0 * D_multiply(x2, z2) - 2.0 * D_multiply(y2, z2);\n            DualReal p0 = D_multiply(t0, D_multiply(t1, D_multiply(t2, t3)));\n            DualReal t4 = (3.0 + 5.0 * ro) * D_sq(x2 + y2 + z2 - w2);\n            DualReal t5 = D_multiply(D_sq(x2 + y2 + z2 - (2.0 - ro) * w2), w2);\n            DualReal p1 = D_multiply(t4, t5);\n            return p0 + p1;\n            \n        }\n    }\n}\t\n\nfloat getDE(int index, vec3 p, out vec3 gradient)\n{\n \tDualReal dx = f(index, DualVector3(p.x, 1, p.y, 0, p.z, 0)); \n    DualReal dy = f(index, DualVector3(p.x, 0, p.y, 1, p.z, 0)); \n    DualReal dz = f(index, DualVector3(p.x, 0, p.y, 0, p.z, 1)); \n    \n    float fp = dx[0];//level, same for all partials\n    gradient = vec3(dx[1], dy[1], dz[1]);\n    float de = fp / length(gradient);\n    \n    float bound = length(p) - 3.5;\n    \n    return max(abs(de), bound) * 0.5;//intersection\n}\n\nmat3 rotationXY(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);\n}\n\nmat3 rotationXZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotationYZ(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat3(1, 0, 0, 0, c, s, 0, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n    vec2 unitSpacePosition = 0.5 * clip;\n    vec2 ratioSpacePosition = vec2(aspectRatio, 1) * unitSpacePosition;\n    \n    //model\n    float time = iTime * 0.15;\n    int index = 10;\n    \n    //view basis\n    float polar = (iMouse == vec4(0)) ? 0.0 : tau32 * iMouse.y / iResolution.y + pi32;\n    float az = (iMouse == vec4(0)) ? time * tau32 : -tau32 * iMouse.x / iResolution.x;\n    mat3 viewTransform = rotationXZ(az) * rotationYZ(polar);\n    vec3 viewPosition = viewTransform * vec3(0, 0, 7);\n    vec3 viewRight = viewTransform * vec3(1, 0, 0);\n    vec3 viewUp = viewTransform * vec3(0, 1, 0);\n    vec3 viewForward = viewTransform * vec3(0, 0, -1);\n    \n    //view ray\n    vec3 frustumPoint = viewPosition - viewForward;\n    vec3 srp =\n       viewPosition +\n       viewRight * ratioSpacePosition.x +\n       viewUp * ratioSpacePosition.y;\n    vec3 srd = normalize(srp - frustumPoint);\n\n    //sphere trace\n    int i;\n    float t = 0.0;\n    vec3 p;\n    bool hit = false;\n    vec3 gradient;\n    \n    for(i = 0; i < 300; i++)\n    {\n        p = srp + t * srd;\n        \n        float de = getDE(index, p, gradient);\n        \n        if(de < 0.0001)\n        {\n            hit = true;\n            p -= 0.001 * srd;\n            break; \n        }\n\n        t += de;\n    }\n    \n    if(hit)\n    {\n        vec3 color = vec3(1.0 - float(i) / 100.0) * 2.0;\n        color *= normalize(gradient) * 0.8 + 0.2;\n        fragColor = vec4(color, 1);\n    }\n    else\n    {\n     \tfragColor = vec4(vec3(0.2),1);   \n    }\n}","name":"Image","description":"","type":"image"}]}