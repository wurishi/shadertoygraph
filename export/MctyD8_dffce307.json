{"ver":"0.1","info":{"id":"MctyD8","date":"1730651778","viewed":198,"name":"Wave PDE spectral solution","username":"vchizhov","description":"Solves the wave PDE by discretising spatially with FDM and using a spectral method for the solution of the resulting ODE. SPACE - change visualsation mode, LMB - oscillate, WS - time speed/direction, ENTER - reverse time, AD - adjust damping. ","likes":0,"published":3,"flags":48,"usePreview":0,"tags":["wave","spectral","pde","fdm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define P(X,Y) texture(iChannel0, (fragCoord+vec2(0.5)+vec2(X,Y))/res).x\n\n/*\n\tSolves the damped wave PDE and visualizes it:\n\td_{tt} u + 2g d_t u - d_{xx} u = 0\n\n*/\n\n\nfloat apply3x3Kernel(float kernel[9], vec2 fragCoord, vec2 res)\n{\n    return kernel[0] * P(-1,1) + kernel[1] * P(0,1) + kernel[2] * P(1,1) +\n        kernel[3] * P(-1,0) + kernel[4] * P(0,0) + kernel[5] * P(1,0) +\n        kernel[6] * P(-1,-1) + kernel[7] * P(0,-1) + kernel[8] * P(1,-1);\n}\n\nfloat dx[9] = float[9]( 1.0, 0.0, -1.0,\n    \t\t\t\t\t2.0, 0.0, -2.0,\n    \t\t\t\t\t1.0, 0.0, -1.0 \n    \t\t\t\t\t);\n    \nfloat dy[9] = float[9]( -1.0, -2.0, -1.0,\n    \t\t\t\t\t0.0, 0.0, 0.0,\n    \t\t\t\t\t1.0, 2.0, 1.0 \n    \t\t\t\t\t);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 grad = normalize(vec3(apply3x3Kernel(dx, fragCoord, iResolution.xy), \n                     apply3x3Kernel(dy, fragCoord, iResolution.xy), 1.0));\n\n    int mode = int(texelFetch(iChannel0, ivec2(0,0), 0).w);\n    float scale = 300.0;\n    vec3 col;\n    if(mode==0)\n    {\n     \tcol = texture(iChannel1, uv+scale*grad.xy/iChannelResolution[1].xy).xyz;\n    }\n    else if(mode==1)\n    {\n        col = grad*0.5 + vec3(0.5);\n    }\n    else\n    {\n        col = vec3(0.5*texture(iChannel0, fragCoord/iChannelResolution[0].xy).x+0.5);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // horizontal oDCT-IIe pass on the height and velocity\n    vec2 uv = DCT_IIe_row(iChannel0, fragCoord.xy, iResolution.xy); \n    \n    // set the initial state to 0\n    if (iFrame==0)\n        uv = vec2(0);\n    \n    // write the horizontal transforms of the height and velocity in the first two components\n    fragColor = vec4(uv, 0, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float keyDown(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\n\nbool keyHit(int ascii) {\n\treturn texture(iChannel2,vec2((.5+float(ascii))/256.,1.5/3.)).x == 1.0;\n}\n\nconst int KEY_ENTER = 13;\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // extract data\n    vec4 info = texelFetch(iChannel3, ivec2(0,0), 0);\n    float inv_damping_ratio = info.z;\n    float time_step = info.w;\n    \n    //initialize\n    if(iFrame==0)\n    {\n        inv_damping_ratio = 4.0*25.0;\n        time_step = 1.0;\n    }\n    \n    // vertical oDCT-IIe pass on the height and velocity\n    // uv are now in cosine frequency space \n    vec2 uv = DCT_IIe_col(iChannel0, fragCoord.xy, iResolution.xy); \n    \n    // inverse damping ratio\n    float damp_sens;\n    if (inv_damping_ratio<4.0)\n        damp_sens = 0.1;\n    else\n        damp_sens = 1.0;\n    inv_damping_ratio = clamp(inv_damping_ratio+damp_sens*(keyDown(KEY_D) - keyDown(KEY_A)), 0.01, 400.0);\n    \n    // what matters is the ratio of squared speed to damping g\n    // so just fix the speed to c=2 and have the damping be \n    // proportional to c^2\n    float c = 2.0;\n#if UNDAMPED==0\n    float g = c*c/inv_damping_ratio;\n#else\n    float g = 0.0;\n#endif\n    \n    // time step\n    float time_sense = 0.01;\n    time_step = time_step+time_sense*(keyDown(KEY_W) - keyDown(KEY_S));\n    \n    // reverse time\n    if(keyHit(KEY_ENTER))\n        time_step = -time_step;\n        \n    if (time_step<0.0)\n        g = -g;\n    \n    // compute the eigenvalue\n    float l = L_eigenvalue(fragCoord.xy, iResolution.xy);\n    \n    // solve the damped harmonic oscillator equation\n    uv = harmonic_oscillator(g, c*c*l, uv[0], uv[1], time_step);\n    \n    // write the solution for the height and velocity in cosine frequency space \n    // in the first two components\n    fragColor = vec4(uv, inv_damping_ratio, time_step);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// README:\n\n// SPACE change visualisation mode\n// LMB   oscillate sine wave\n// WS    adjust time speed/direction\n// ENTER reverse time\n// AD    adjust inverse damping factor ratio\n\n\n#define up(X,Y) texture(old, (coord + vec2(X,Y))/res).x\n#define u(X,Y) texture(curr, (coord + vec2(X,Y))/res).x\n\n#define PI 3.14159265358979323846264338327950288420\n\n// set to 1 to remove the damping\n#define UNDAMPED 0\n\n// 0: -\\Delta, 1: \\Delta^2, 2: (-\\Delta)^{1/2}\n// may become unstable for 1 and 2\n#define LAPLACE_MODE 0\n\n#if LAPLACE_MODE == 1\n#define LAPLACE_NUMER 2\n#define LAPLACE_DENOM 1\n#elif LAPLACE_MODE==2\n#define LAPLACE_NUMER 1\n#define LAPLACE_DENOM 2\n#else\n#define LAPLACE_NUMER 1\n#define LAPLACE_DENOM 1\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //     \n//              Spectral Solution of the FDM Discretised Wave PDE           //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n// TLDR:\n// The full procedure is:\n// 0) Take some initial u0,v0 (e.g. u=0, v=0).\n// 1) Transform them with 2D oDCT-IIe (bufA does a horizontal pass, and bufB a vertical)\n// 2) Solve the harmonic oscillator equations for each pixel.\n//    The initial conditions are the current values uk,vk.\n//    Take as large a time step size as you like (the step is allowed to be \n//    negative if g<=0).\n// 3) Backtransform with 2D oDCT-IIIe (bufC vertical and bufD horizontal)\n// 4) Add any height modification you wish in bufD, visualize in Image.\n// Repeat.\n\n//////////////////////////////////////////////////////////////////////////////\n\n// The wave equation (with damping/decay) is the PDE:\n\n// d_{tt} u(t,x) + 2 g d_t u(t,x) - c^2\\Delta u(t,x) = 0\n\n// with initial conditions: u(0) = u0, v(t) = d_t u(0) = v0,\n// and reflecting boundary conditions: d_n u = 0.\n\n// Here u(t,x) describes the height (of e.g. some body of water) at time t \n// at point x. We will denote v(t,x) = d_t u(t,x) the (vertical) velocity \n// of the water at point x and time t.\n\n// In 1D discretising the negated Laplacian with reflecting boundary condition by \n// using the FDM method leads to a symmetric positive semi-definite matrix L:\n\n//                     [  1 -1        ]\n//                     [ -1  2 -1     ]\n// -d_{xx} ~ L = 1/h^2 [    .  .  .   ]\n//                     [     -1  2 -1 ]\n//                     [        -1  1 ]\n\n// The new equation (where now u is a vector in R^n) is the matrix ODE:\n\n// d_{tt} u(t) + 2g d_t u(t) + c^2 L u(t) = 0\n\n// A typical solution of the above also discretises time with explicit Euler:\n\n// d_{tt} u^k = (u^{k+1} -2u^k + u^{k-1})/\\tau^2\n\n// However this severly limits the allowed step size. Instead we \n// consider the spectral solution, where there is no limit on \n// the step size.\n\n//////////////////////////////////////////////////////////////////////////////\n\n// The matrix L has an eigendecomposition L = VSV^T, where the \n// eigenvectors are the columns in the matrix of the orthogonal \n// DCT-IIIe transform, and the eigenvalues are S=diag([DCT-Ie] * [-1,2,-1]^T).\n\n// Thus: V = oDCT-IIIe, V^T = oDCT-IIe, eigenvalues:\n// S_{ii} = ([DCT-Ie] * [-1,2,-1])_k = 4/h^2 * sin(k * pi/(2n))\n\n// The goal is to diagonalise the matrix L:\n\n// d_{tt} u + 2g d_t u + c^2 VSV^T u = 0\n\n// set u = V u (these are different us, but it's convenient to use the same var)\n\n// d_{tt} V u + 2g d_t V u + c^2 VSV^TV u = 0\n\n// multiply by V^T from the left:\n\n// V^TV d_{tt} u + V^TV 2g d_t u + c^2 V^TVS u = 0\n\n// d_{tt} u + 2g d_t u + c^2 S u = 0\n\n// Since $S$ is diagonal, we have n decoupled scalar ODEs for each pixel.\n// Each ODE of those is known as a damped harmonic oscillator equation, see:\n// https://en.wikipedia.org/wiki/Harmonic_oscillator#Transient_solution\n\n//////////////////////////////////////////////////////////////////////////////\n\n// To solve an equation of the above form one takes the ansatz that\n// u = exp(t lambda), and gets a quadratic equation.\n\n// The discriminant of the quadratic equation is \n// D = g^2 - c^2 S_{ii}\n// The two roots are:\n// z_1 = -g - sqrt(D)\n// z_2 = -g + sqrt(D)\n\n// There are three cases depending on the discriminant:\n\n// 0) D==0 \n// critically damped: the system returns to the steady state \n// as fast as possible without oscillating\n\n// u(t) = exp(-tg)(A_1 + A_2t)\n// v(t) = exp(-tg)(A_3 + A_4t)\n\n// 1) D>0\n// overdamped: the system returns to the steady state without oscillating.\n// the larger D the more slowly the system returns to the steady state\n\n// u(t) = exp(tz_1) A_1 + exp(tz_2) A_2 \n// v(t) = exp(tz_1) A_3 + exp(tz_2) A_4\n\n// 2) D<0\n// underdamped:  the system oscillates and if g>0 then the amplitude \n// gradually decreases. If g=0 the amplitude doesn't decrease.\n\n// u(t) = exp(-tg) (cos(tsqrt(-D)) A_1 + \\sin(tsqrt(-D)) A_2) \n// v(t) = exp(-tg) (cos(tsqrt(-D)) A_3 + \\sin(tsqrt(-D)) A_4) \n\n// Note that g<0 is non physical as it generally causes the amplitude \n// to grow exponentially.\n\n\n// In the above the coefficients A_i need to be determined from \n// the initial conditions:\n// u(0) = u_0, u'(0) = v_0, v(0) = v_0, v'(0) = u''(0) = -2gv_0 + c^2S_{ii}u_0\n\n// Solving all of the equations for those leads to:\n\n// 0) D==0\n\n// u(t) = exp(-t*g) * (u0 + (v0+g*u0)*t)\n// v(t) = exp(-t*g) * (v0 - (w*u0+g*v0)*t)\n\n// 1) D>0\n\n// s = sqrt(D)\n// z1 = -g - s\n// z2 = -g + s\n// f = -2.0*g*v0-c^2*S_{ii}*u0\n\n// u(t) = (exp(t*z1) * (u0*z2-v0) + exp(t*z2) * (v0-u0*z1))/(-2.0*s);\n// v(t) = (exp(t*z1) * (v0*z2-f) + exp(t*z2) * (f-v0*z1))/(-2.0*s); \n\n// 2) D<0\n\n// s = sqrt(-D);\n        \n// u(t) = exp(-t*g) * (cos(t*s) * u0 + sin(t*s) * (v0+u0*g)/s)\n// v(t) = exp(-t*g) * (cos(t*s) * v0 - sin(t*s) * (g*v0+c^2*S_{ii}*u0)/s)\n\n// This is implemented in the following function:\n\n// solution (u(t),v(t)) for the harmonic oscillator equation d_t^2 u + 2g d_tu + w u = 0\n// for details see: https://en.wikipedia.org/wiki/Harmonic_oscillator#Transient_solution\n#define EPS 0.0001\nvec2 harmonic_oscillator(float g, float w, float u0, float v0, float t)\n{\n    vec2 uv;\n    \n    float D = g*g-w;\n    \n    if (abs(D)<=EPS)\n    {\n        // u(0) = u0, u'(0) = v0\n        uv[0] = exp(-t*g) * (u0 + (v0+g*u0)*t);\n        // v(0) = v0, v'(0) = u''(0) = -2g v0 - w u0\n        uv[1] = exp(-t*g) * (v0 - (w*u0+g*v0)*t);\n        return uv;\n    }\n    else if (D>EPS)\n    {\n        float s = sqrt(D);\n        float z1 = -g + s;\n        float z2 = -g - s;\n        float f = -2.0*g*v0-w*u0;\n        \n        // u(0) = u0, u'(0) = v0\n        uv[0] = (exp(t*z1) * (u0*z2-v0) + exp(t*z2) * (v0-u0*z1))/(-2.0*s);\n        // v(0) = v0, v'(0) = u''(0) = -2g v0 - w u0 = f\n        uv[1] = (exp(t*z1) * (v0*z2-f) + exp(t*z2) * (f-v0*z1))/(-2.0*s);\n        return uv;\n    }\n    else // (D<-EPS)\n    {\n        float s = sqrt(-D);\n        \n        // u(0) = u0, u'(0) = v0\n        uv[0] = exp(-t*g) * (cos(t*s) * u0 + sin(t*s) * (v0+u0*g)/s);\n        // v(0) = v0, v'(0) = u''(0) = -2g v0 - w u0\n        uv[1] = exp(-t*g) * (cos(t*s) * v0 - sin(t*s) * (g*v0+w*u0)/s);\n        return uv;\n    }\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n// For the 2D case the matrix L is formed through a Kronecker sum, see:\n// https://en.wikipedia.org/wiki/Kronecker_product#Relations_to_other_matrix_operations\n// L = L_y(x+x)L_x = I_h x L_x + L_y x I_w\n// The eigenvectors of L are then the kronecker products of the eigenvectors \n// of L_x and L_y. And the eigenvalues are the sum of the eigenvalues of \n// L_x and L_y.\n// In other words we need 2D oDCT-IIe and oDCT-IIIe transforms for V^T \n// and V. And we just need to sum the eigenvalues for S.\n\n// computes the eigenvalue of L at pixel (i,j)\nfloat L_eigenvalue(vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int h = int(res.y);\n    int i = int(xy.x);\n    int j = int(xy.y);\n\n    // eigenvalue for L_x\n    float lx = sin(PI*float(i)/(2.0*float(w)));\n    lx = 4.0*lx*lx;\n    // eigenvalue for L_y\n    float ly = sin(PI*float(j)/(2.0*float(h)));\n    ly = 4.0*ly*ly;\n    // eigenvalue for L = I_h x L_x + L_y x I_w\n    float l = lx+ly; //pow(lx + ly,0.5);\n    \n    // you could take some power p of this, then instead of \n    // the negated Laplacian you would be approximating \n    // some power of the negated Laplacian \n    // for example biharmonic Delta^2\n    // or Poisson (-Delta)^{1/2}\n    // while those are fun to check out, I like -Delta best\n    // note: the system may become unstable\n#if (LAPLACE_NUMER != LAPLACE_DENOM)\n    l = pow(l, float(LAPLACE_NUMER)/float(LAPLACE_DENOM));\n#endif\n    \n    return l;\n}\n\n//////////////////////////////////////////////////////////////////////////////\n\n// The full procedure is then:\n// 0) Take some initial u0,v0 (e.g. u=0, v=0).\n// 1) Transform them with 2D oDCT-IIe (bufA does a horizontal pass, and bufB a vertical)\n// 2) Solve the harmonic oscillator equations for each pixel.\n//    The initial conditions are the current values uk,vk.\n//    Take as large a time step size as you like (the step is allowed to be \n//    negative if g<=0).\n// 3) Backtransform with 2D oDCT-IIIe (bufC vertical and bufD horizontal)\n// 4) Add any height modification you wish in bufD, visualize in Image.\n// Repeat.\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //     \n//               Laplacian Eigenvalues and Eigenvectors                     //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n// For more details on the relation between difference matrices and \n// the discrete trigonometric transforms you can see the paper below.\n\n// For a basic overview see:\n// \"FUNCTIONS OF DIFFERENCE MATRICES ARE TOEPLITZ PLUS HANKEL\"\n// https://math.mit.edu/~gs/highdegree/TplusH.pdf\n\n// For the general discussion see:\n// \"Diagonalizing properties of the discrete cosine transforms\"\n// http://www.ugr.es/~segura/pdfdocs/ie3sp95.pdf\n\n// For a more in-depth review see:\n// \"The Algebraic Approach to the Discrete Cosine and Sine Transforms and Their Fast Algorithms\"\n// https://users.ece.cmu.edu/~pueschel/papers/dttalgo.pdf\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //     \n//      Orthogonal Discrete Cosine Transforms of Type IIe and IIIe          //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n// For the definitions see: \n// https://en.wikipedia.org/wiki/Discrete_cosine_transform#Formal_definition\n\nvec2 DCT_IIe_row(sampler2D f, vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int i = int(xy.x);\n    int j = int(xy.y);\n\n    // DCT-IIe along the j-th row\n    float factor = PI*float(i)/float(w);\n    vec2 a = vec2(0);\n    for (int k=0; k<w; ++k)\n    {\n        vec2 s = texelFetch(f, ivec2(k,j), 0).xy;\n        float t = (float(k)+0.5)*factor;\n        a = a + cos(t) * s;\n    }\n    // orthogonal \n    if (i==0)\n        a = a / sqrt(float(w));\n    else\n        a = a * sqrt(2.0/float(w));\n    \n    return a;\n}\n\nvec2 DCT_IIIe_row(sampler2D f, vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int i = int(xy.x);\n    int j = int(xy.y);\n\n    // DCT-IIIe along the j-th row\n    float factor = PI*(float(i)+0.5)/float(w);\n    vec2 a = vec2(0);\n    for (int k=0; k<w; ++k)\n    {\n        vec2 s = texelFetch(f, ivec2(k,j), 0).xy;\n        float t = float(k)*factor;\n        a = a + cos(t) * s;\n        // orthogonal\n        if (k==0)\n            a = a / sqrt(2.0);\n    }\n    // orthogonal\n    a = a * sqrt(2.0/float(w));\n    \n    return a;\n}\n\nvec2 DCT_IIe_col(sampler2D f, vec2 xy, vec2 res)\n{\n    int h = int(res.y);\n    int i = int(xy.x);\n    int j = int(xy.y);\n    \n    // DCT-IIe along the i-th column\n    float factor = PI*float(j)/float(h);\n    vec2 a = vec2(0);\n    for (int k=0; k<h; ++k)\n    {\n        vec2 s = texelFetch(f, ivec2(i,k), 0).xy;\n        float t = (float(k)+0.5)*factor;\n        a = a + cos(t) * s;\n    }\n    // orthogonal \n    if (j==0)\n        a = a / sqrt(float(h));\n    else\n        a = a * sqrt(2.0/float(h));\n    \n    return a;\n}\n\nvec2 DCT_IIIe_col(sampler2D f, vec2 xy, vec2 res)\n{\n    int h = int(res.y);\n    int i = int(xy.x);\n    int j = int(xy.y);\n    \n    // DCT-IIIe transform along the i-th column\n    float factor = PI*(float(j)+0.5)/float(h);\n    vec2 a = vec2(0);\n    for (int k=0; k<h; ++k)\n    {\n        vec2 s = texelFetch(f, ivec2(i,k), 0).xy;\n        float t = float(k)*factor;\n        a = a + cos(t) * s;\n        // orthogonal\n        if (k==0)\n            a = a / sqrt(2.0);\n    }\n    // orthogonal \n    if (j==0)\n        a = a / sqrt(float(h));\n    else\n        a = a * sqrt(2.0/float(h));\n    \n    return a;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // vertical oDCT-IIIe pass on the frequency space height and velocity\n    vec2 uv = DCT_IIIe_col(iChannel0, fragCoord.xy, iResolution.xy); \n    \n    // write the horizontal transforms of the height and velocity in the first two components\n    fragColor = vec4(uv,0.0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"float keyDown(int ascii) {\n\treturn float(texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.0);\n}\nbool keyHit(int ascii) {\n\treturn texture(iChannel2,vec2((.5+float(ascii))/256.,1.5/3.)).x == 1.0;\n}\n\nconst int KEY_SPACE = 32;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // visualisation mode\n    vec4 info = texelFetch(iChannel3,ivec2(0,0),0);\n    int mode = int(info.w) + int(keyHit(KEY_SPACE));\n    // initialize\n    if(iFrame==0)\n    {\n        mode = 0;\n    }\n    mode = mode > 2 ? mode - 3 : mode < 0 ? mode + 3 : mode;\n\n    // horizontal oDCT-IIIe pass on the frequency space height and velocity\n    // now the height and velocity are back to the primal space\n    vec2 uv = DCT_IIIe_row(iChannel0, fragCoord.xy, iResolution.xy);\n    \n    // sine wave oscillate on mouse click\n    float radius = 10.0;\n    float oscillationSpeed = 20.0;\n    if(iMouse.z>0.0)\n    {\n        float d = length(iMouse.xy * iChannelResolution[0].xy/iResolution.xy -fragCoord);\n        uv[0] = d<radius ? smoothstep(radius,0.0, d)*sin(oscillationSpeed*iTime) : uv[0];\n    }\n    \n    fragColor = vec4(uv, 0, float(mode));\n}","name":"Buffer D","description":"","type":"buffer"}]}