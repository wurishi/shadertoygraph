{"ver":"0.1","info":{"id":"XllSWN","date":"1436888773","viewed":130,"name":"Session3","username":"dennixtreme","description":"e","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["ewqe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\nvec3 BrightnessContrast(in vec3 color)\n{\n    float Brightness = iMouse.y / iResolution.y * 2.0 - 1.0;\n\tfloat Contrast = iMouse.x / iResolution.x * 2.0;\n    \n    // --- EX2: implement brightness/contrast formula\n    color = (color - 0.5) * Contrast + 0.5 + Brightness;\n    return color;\n}\n\nvec3 Luminance(in vec3 color)\n{\n    // --- EX1: implement luminance formula\n    color = vec3(dot(color, vec3(0.222, 0.707, 0.071)));\n    return color;\n}\n\nvec3 Sepia(in vec3 color)\n{\n   \tfloat LerpFactor = iMouse.x / iResolution.x;\n    vec3 SepiaColor = vec3(1.2, 1.0, 0.8);\n    \n    // --- EX3: compute sepia color\n    vec3 luminance = Luminance(color);\n    vec3 lumsep = luminance * SepiaColor;\n    color = mix(color, lumsep, LerpFactor);\n    // --- first compute luminance * SepiaColor\n    // --- then interpolate\n    \n    return color;\n}\n\nvec3 Vignette(in vec3 color, in vec2 uv)\n{\n    float VignetteFactor = 1.0 + iMouse.x / iResolution.x;\n    \n    // --- EX4: compute vignette effect\n    // --- start with distance from center to current UV coordinates\n    color = color*(1.0 - length(uv - vec2(0.5, 0.5))*VignetteFactor);\n    return color;\n}\n\nvec3 ColorGrading(in vec3 color, in vec2 uv)\n{\n    // color grading data\n    float DesaturationFactor = 0.8;\n    vec3 Shadows = vec3(0.1, 0.22, 0.87);\n    vec3 HighlightsWoShadows = vec3(0.76, 0.32, 0.12);\n    vec3 Midtones = vec3(0.77, 0.43, 0.32);\n    \n    // --- color balance formula\n    vec3 Luma = Luminance(color);\n    vec3 DesaturatedColor = mix(color, Luma, DesaturationFactor);\n    vec3 GradedColor = Shadows + DesaturatedColor * HighlightsWoShadows + (1.0 - 2.0 * abs(DesaturatedColor - 0.5)) * Midtones;\n    return mix(color, GradedColor, 0.35);\n}\n\nvec3 Sample(in vec2 uv, in vec2 offsets, in float weight, in float mipBias)\n{\n    vec2 PixelSize = (mipBias == 0.0 ? 1.0 : mipBias) / iResolution.xy;\n    return texture(iChannel0, uv + offsets * PixelSize, mipBias).rgb * weight;\n}\n\nvec3 Mean(in vec2 uv)\n{\n    // --- nice mouse line\n    float DivideX = iMouse.x / iResolution.x;\n    float Line = smoothstep(0.0, 1.0 / iResolution.y, abs(DivideX - uv.x));\n    \n    // --- mip-map bias; play around with it for larger filter kernel\n    float Mip = 0.0;\n       \n   \t// --- EX5: Implement mean filter\n    // --- pixel offsets for a 3x3 filter kernel;\n    // --- a) Introduce the correct offsets for the second and third rows of pixels\n    vec2 Offsets[9];\n    Offsets[0] = vec2(-1.0, -1.0); \tOffsets[1] = vec2(-1.0, 0.0); \tOffsets[2] = vec2(-1.0, 1.0);\n    Offsets[3] = vec2( 0.0, -1.0); \tOffsets[4] = vec2( 0.0, 0.0); \tOffsets[5] = vec2( 0.0, 1.0);\n    Offsets[6] = vec2( 1.0, -1.0); \tOffsets[7] = vec2( 1.0, 0.0); \tOffsets[8] = vec2( 1.0, 1.0);\n    \n    // --- b) introduce the correct weights to obtain a mean filter operator\n    float Weights[9];\n    Weights[0] = 1.0/9.0; \tWeights[1] = 1.0/9.0; \tWeights[2] = 1.0/9.0;\n    Weights[3] = 1.0/9.0; \tWeights[4] = 1.0/9.0; \tWeights[5] = 1.0/9.0;\n    Weights[6] = 1.0/9.0; \tWeights[7] = 1.0/9.0; \tWeights[8] = 1.0/9.0;\n    \n   \t// --- take the samples with the appropriate weights and offsets \n   \tvec3 FilteredColor = Sample(uv, Offsets[0], Weights[0], Mip) + Sample(uv, Offsets[1], Weights[1], Mip) + Sample(uv, Offsets[2], Weights[2], Mip) +\n        \t\t\t\t Sample(uv, Offsets[3], Weights[3], Mip) + Sample(uv, Offsets[4], Weights[4], Mip) + Sample(uv, Offsets[5], Weights[5], Mip) +\n        \t\t\t\t Sample(uv, Offsets[6], Weights[6], Mip) + Sample(uv, Offsets[7], Weights[7], Mip) + Sample(uv, Offsets[8], Weights[8], Mip);\n    \n    // --- separate the two colors with a line\n   \tvec3 NormalColor = texture(iChannel0, uv).rgb;   \n    return (uv.x < DivideX ? NormalColor : FilteredColor) * Line;\n}\n\nvec3 Laplace(in vec2 uv)\n{\n    // --- nice mouse line\n    float DivideX = iMouse.x / iResolution.x;\n    float Line = smoothstep(0.0, 1.0 / iResolution.y, abs(DivideX - uv.x));\n    \n    // --- mip-map bias; play around with it for larger filter kernel\n    float Mip = 0.0;\n    \n    // --- pixel offsets for a 3x3 filter kernel;\n    vec2 Offsets[9];\n    Offsets[0] = vec2(-1.0, -1.0); \tOffsets[1] = vec2(-1.0, 0.0); \tOffsets[2] = vec2(-1.0, 1.0);\n    Offsets[3] = vec2(0.0, -1.0); \tOffsets[4] = vec2(0.0, 0.0); \tOffsets[5] = vec2(0.0, 1.0);\n    Offsets[6] = vec2(1.0, -1.0); \tOffsets[7] = vec2(1.0, 0.0); \tOffsets[8] = vec2(1.0, 1.0);\n    \n   \t// --- EX6: Implement Laplace filter\n    // --- a) introduce the correct weights to obtain a Laplace operator\n    float Weights[9];\n    Weights[0] = 0.0; \tWeights[1] = -1.0; \tWeights[2] = 0.0;\n    Weights[3] = -1.0; \tWeights[4] = 4.0; \tWeights[5] = -1.0;\n    Weights[6] = 0.0; \tWeights[7] = -1.0; \tWeights[8] = 0.0;\n    \n   \t// --- take the samples with the appropriate weights and offsets \n   \tvec3 FilteredColor = Sample(uv, Offsets[0], Weights[0], Mip) + Sample(uv, Offsets[1], Weights[1], Mip) + Sample(uv, Offsets[2], Weights[2], Mip) +\n        \t\t\t\t Sample(uv, Offsets[3], Weights[3], Mip) + Sample(uv, Offsets[4], Weights[4], Mip) + Sample(uv, Offsets[5], Weights[5], Mip) +\n        \t\t\t\t Sample(uv, Offsets[6], Weights[6], Mip) + Sample(uv, Offsets[7], Weights[7], Mip) + Sample(uv, Offsets[8], Weights[8], Mip);\n    \n   \t// --- separate the two colors with a line\n   \tvec3 NormalColor = texture(iChannel0, uv).rgb;   \n    return (uv.x < DivideX ? NormalColor : FilteredColor) * Line;\n}\n\nvec3 Sobel(in vec2 uv)\n{\n    // --- nice mouse line\n    float DivideX = iMouse.x / iResolution.x;\n    float Line = smoothstep(0.0, 1.0 / iResolution.y, abs(DivideX - uv.x));\n    \n    // --- mip-map bias; play around with it for larger filter kernel\n    float Mip = 0.0;\n    \n    // --- pixel offsets for a 3x3 filter kernel;\n    vec2 Offsets[9];\n    Offsets[0] = vec2(-1.0, -1.0); \tOffsets[1] = vec2(-1.0, 0.0); \tOffsets[2] = vec2(-1.0, 1.0);\n    Offsets[3] = vec2(0.0, -1.0); \tOffsets[4] = vec2(0.0, 0.0); \tOffsets[5] = vec2(0.0, 1.0);\n    Offsets[6] = vec2(1.0, -1.0); \tOffsets[7] = vec2(1.0, 0.0); \tOffsets[8] = vec2(1.0, 1.0);\n    \n   \t// --- EX7: Implement Sobel filter\n    // --- a) introduce the correct weights to obtain the two Sobel operator    \n    float WeightsGx[9];\n    WeightsGx[0] = -1.0; \tWeightsGx[1] = 0.0; \tWeightsGx[2] = 1.0;\n    WeightsGx[3] = -2.0; \tWeightsGx[4] = 0.0; \tWeightsGx[5] = 2.0;\n    WeightsGx[6] = -1.0; \tWeightsGx[7] = 0.0; \tWeightsGx[8] = 1.0;\n    \n    float WeightsGy[9];\n    WeightsGy[0] = -1.0; \tWeightsGy[1] = -2.0; \tWeightsGy[2] = -1.0;\n    WeightsGy[3] = 0.0; \tWeightsGy[4] = 0.0; \tWeightsGy[5] = 0.0;\n    WeightsGy[6] = 1.0; \tWeightsGy[7] = 2.0; \tWeightsGy[8] = 1.0;\n    \n   \t// --- take the samples with the appropriate weights and offsets \n   \tvec3 Gx = Sample(uv, Offsets[0], WeightsGx[0], Mip) + Sample(uv, Offsets[1], WeightsGx[1], Mip) + Sample(uv, Offsets[2], WeightsGx[2], Mip) +\n        \t  Sample(uv, Offsets[3], WeightsGx[3], Mip) + Sample(uv, Offsets[4], WeightsGx[4], Mip) + Sample(uv, Offsets[5], WeightsGx[5], Mip) +\n        \t  Sample(uv, Offsets[6], WeightsGx[6], Mip) + Sample(uv, Offsets[7], WeightsGx[7], Mip) + Sample(uv, Offsets[8], WeightsGx[8], Mip);\n    \n    vec3 Gy = Sample(uv, Offsets[0], WeightsGy[0], Mip) + Sample(uv, Offsets[1], WeightsGy[1], Mip) + Sample(uv, Offsets[2], WeightsGy[2], Mip) +\n        \t  Sample(uv, Offsets[3], WeightsGy[3], Mip) + Sample(uv, Offsets[4], WeightsGy[4], Mip) + Sample(uv, Offsets[5], WeightsGy[5], Mip) +\n        \t  Sample(uv, Offsets[6], WeightsGy[6], Mip) + Sample(uv, Offsets[7], WeightsGy[7], Mip) + Sample(uv, Offsets[8], WeightsGy[8], Mip);\n    \n    \n    // --- b) compute the appropriate filter color\n    vec3 FilteredColor = sqrt( pow(Gx, vec3(2.0)) + pow(Gy, vec3(2.0)));\n   \tvec3 NormalColor = texture(iChannel0, uv).rgb;\n    return (uv.x < DivideX ? NormalColor : FilteredColor) * Line;\n}\n\nvec3 GaussianBlur(in vec2 uv, in float Mip, bool line)\n{\n    // --- nice mouse line\n    float DivideX = iMouse.x / iResolution.x;\n    float Line = smoothstep(0.0, 1.0 / iResolution.y, abs(DivideX - uv.x));\n    \n    // --- pixel offsets for a 3x3 filter kernel;\n    vec2 Offsets[9];\n    Offsets[0] = vec2(-1.0, -1.0); \tOffsets[1] = vec2(-1.0, 0.0); \tOffsets[2] = vec2(-1.0, 1.0);\n    Offsets[3] = vec2(0.0, -1.0); \tOffsets[4] = vec2(0.0, 0.0); \tOffsets[5] = vec2(0.0, 1.0);\n    Offsets[6] = vec2(1.0, -1.0); \tOffsets[7] = vec2(1.0, 0.0); \tOffsets[8] = vec2(1.0, 1.0);\n    \n   \t// --- EX8: Implement Gaussian Blur filter\n    // --- a) introduce the correct weights to obtain a gaussian blur operator\n    float Weights[9];\n    Weights[0] = 1.0/16.0; \tWeights[1] = 2.0/16.0; \tWeights[2] = 1.0/16.0;\n    Weights[3] = 2.0/16.0; \tWeights[4] = 4.0/16.0; \tWeights[5] = 2.0/16.0;\n    Weights[6] = 1.0/16.0; \tWeights[7] = 2.0/16.0; \tWeights[8] = 1.0/16.0;\n    \n   \t// --- take the samples with the appropriate weights and offsets \n   \tvec3 FilteredColor = Sample(uv, Offsets[0], Weights[0], Mip) + Sample(uv, Offsets[1], Weights[1], Mip) + Sample(uv, Offsets[2], Weights[2], Mip) +\n        \t\t\t\t Sample(uv, Offsets[3], Weights[3], Mip) + Sample(uv, Offsets[4], Weights[4], Mip) + Sample(uv, Offsets[5], Weights[5], Mip) +\n        \t\t\t\t Sample(uv, Offsets[6], Weights[6], Mip) + Sample(uv, Offsets[7], Weights[7], Mip) + Sample(uv, Offsets[8], Weights[8], Mip);\n    \n   \t// --- separate the two colors with a line\n    if (line)\n    {\n   \t\tvec3 NormalColor = texture(iChannel0, uv).rgb;   \n    \treturn (uv.x < DivideX ? NormalColor : FilteredColor) * Line;\n    }\n    else\n    {\n        return FilteredColor;\n    }\n}\n\nvec3 Bloom(in vec3 color, in vec2 uv)\n{\n    float Threshold = iMouse.y/iResolution.y;\n\tfloat BlurSize = 6.0 - iMouse.x / iResolution.x * 6.0;\n    float Intensity = 1.5;\n    \n    // --- EX9: Implement Bloom\n    vec3 BlurredImg = GaussianBlur(uv, BlurSize, false);\n    \n    // --- a) Compute highlights image\n    vec3 HighlightImg = clamp(BlurredImg - Threshold,0.0,1.0)/ (1.0 - Threshold);\n    \n    // --- b) Screen blend original image with highlights image\n    vec3 BloomImg = 1.0 - (1.0 - color) * (1.0 - HighlightImg);\n    \n    return BloomImg;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1. - uv.y;\n    \n    vec4 color = texture(iChannel0, uv);\n    \n    vec4 finalColor = vec4(color.rgb, 1.0);\n    //finalColor.rgb = Luminance(color.rgb);\n    //finalColor.rgb = BrightnessContrast(color.rgb);\n    //finalColor.rgb = Sepia(color.rgb);\n    //finalColor.rgb = Vignette(color.rgb, uv);\n    //finalColor.rgb = ColorGrading(color.rgb, uv);\n    //finalColor.rgb = Mean(uv);\n    //finalColor.rgb = Laplace(uv);\n    //finalColor.rgb = Sobel(uv);\n    //finalColor.rgb = GaussianBlur(uv, 4.0, true);\n    //finalColor.rgb = Bloom(color.rgb, uv);\n    \n\tfragColor = finalColor;\n}","name":"","description":"","type":"image"}]}