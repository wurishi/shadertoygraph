{"ver":"0.1","info":{"id":"sdsSWB","date":"1619189045","viewed":109,"name":"Fractalis Kaleidoscopus","username":"rimina","description":"Shadertoy version of a shader I did during my live shader coding stream at 16th of April 2021.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractals","kaleidoscope","spacefolding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2021-2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :)).\n\n\nconst float FAR = 100.0;\nconst int STEPS = 64;\nconst float E = 0.01;\n\nvec3 glow = vec3(0.0);\n\n\nfloat box(vec3 p, vec3 r){\n    vec3 d = abs(p)-r;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sphere(vec3 p, float r){\n    return length(p)-r;\n}\n\nvoid rot(inout vec2 p, float a){\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat scene(vec3 p){\n    vec3 pp = p;\n    float time = iTime;\n\n    pp.z = mod(pp.z+40.0, 80.0)-40.0;\n    pp.x = mod(pp.x+40.0, 80.0)-40.0;\n\n    float scale = 2.2;\n    float offset = 16.0;\n    for(int i = 0; i < 5; ++i){\n        rot(pp.xz, 0.1*time);\n\n        pp = (abs(pp)-vec3(3.0, 2.0, 5.0))*scale-offset*(scale-1.0);\n        rot(pp.xz, 0.1*time);\n        rot(pp.yz, time*0.1);\n        rot(pp.yx, time*0.1);\n    }\n\n    float a = box(pp, vec3(20.0))*pow(scale, -5.0);\n    float b = box(pp, vec3(10.0, 10.0, FAR))*pow(scale, -5.0);\n    float c = box(pp-vec3(10.0, 20.0, 0.0), vec3(10.0, 10.0, FAR))*pow(scale, -5.0);\n\n    vec3 g = vec3(0.2, 0.4, 0.5)*0.01 / (0.01+abs(a));\n    g += vec3(0.5, 0.3, 0.2)*0.05 / (0.01+abs(c));\n\n    glow += g;\n\n    c = max(abs(c), 0.1);\n\n    return min(a, min(b, c));\n}\n\nfloat march(vec3 ro, vec3 rd){\n    float t = E;\n    vec3 p = ro;\n\n    for(int i = 0; i < STEPS; ++i){\n        float d = scene(p);\n        t +=d;\n        p = ro+rd*t;\n\n        if(d < E || t > FAR){\n            break;\n        }\n    }\n    return t;\n}\n\nvec3 normals(vec3 p){\n    vec3 eps = vec3(E, 0.0, 0.0);\n    return normalize(vec3(\n        scene(p+eps.xyy) - scene(p-eps.xyy),\n        scene(p+eps.yxy) - scene(p-eps.yxy),\n        scene(p+eps.yyx) - scene(p-eps.yyx)\n    ));\n}\n\nvec3 shade(vec3 p, vec3 rd, vec3 ld){\n    vec3 n = normals(p);\n\n    float l = max(dot(n, ld), 0.0);\n    float a = max(dot(reflect(ld, n), rd), 0.0);\n    float s = pow(a, 10.0);\n\n    return l*vec3(0.3, 0.5, 0.9)*0.5+s*vec3(0.3, 0.6, 1.8)*0.5;\n  \n}\n\n//https://iquilezles.org/articles/fog\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n    float dist = length(p-ro);\n\tfloat sunAmount = max( dot(rd, -ld), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.06);\n\tvec3  fogColor = mix(vec3(0.0, 0.05, 0.05), vec3(0.5, 0.2, 0.15), pow(sunAmount, 7.0));\n    return mix(col, fogColor, fogAmount);\n}\n\nvec3 render(vec3 ro, vec3 rd){\n    float t = march(ro, rd);\n    vec3 p = ro+rd*t;\n\n    vec3 ld = normalize(vec3(0.0, 0.0, FAR) - ro);\n    vec3 ld2 = normalize(ro-vec3(0.0, 0.0, FAR));\n\n    vec3 col = vec3(0.0);\n    if(t < FAR){\n        col = shade(p, rd, ld);\n        col += shade(p, rd, ld2);\n        col *= 0.5;\n        col += vec3(0.1, 0.5, 0.6);\n    }\n    col += glow*0.25;\n\n    vec3 f = fog(col, p, ro, rd, ld);\n    vec3 ff = fog(col, p, ro, rd, ld2);\n    f += ff;\n    f *= 0.5;\n\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n  \n    vec3 ro = vec3(1.0, 0.0, iTime);\n    vec3 rt = vec3(1.5, 0.0, -FAR);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x, y, z) * vec3(q, radians(60.0)));\n\n    vec3 col = render(ro, rd);\n\n    col = pow(col, 1.0/vec3(2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}