{"ver":"0.1","info":{"id":"dd2cWh","date":"1687718038","viewed":2857,"name":"grass field with blades","username":"MonterMan","description":"SDF-defined grass field. I want to make fields that are made up of solid individual grass blades. I think I got to a place where I'm happy with the result.\n\nchangelog:\n6/29/2023: added TAA to smooth out the aliasing.","likes":103,"published":1,"flags":32,"usePreview":1,"tags":["grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// credits:\n//\n//    ollj: suggested lower-iteration fractal terrain hull to speed up traversal\n//    iq: suggested breaking shading code out of the raymarch loop for speedup\n//        also suggested fresnel with low-iter terrain normal for improved visual\n\n// if you don't like TAA, go to Common file to uncomment DISABLE_TAA macro\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n#ifdef DISABLE_TAA\n    vec3 result = texelFetch(iChannel1, ivec2(fragCoord), 0).rgb;\n#else\n    // optinal sharpness filter to remove TAA blur\n    vec3 result = vec3(0.0);\n    //float sharpness = -iMouse.w/450.0;\n    float sharpness = 0.1;\n    for (int dy = -1; dy <= 1; ++dy)\n    {\n        for (int dx = -1; dx <= 1; ++dx)\n        {\n            float weight = (dx == 0 && dy == 0)? (1.0 + 8.0*sharpness): -sharpness;\n            result += weight * texelFetch(iChannel0, ivec2(fragCoord)+ivec2(dx,dy), 0).rgb;\n        }\n    }\n#endif\n\n    fragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// uncomment to disable TAA\n//#define DISABLE_TAA\n\nmat3 calcCameraMat(vec3 from, vec3 at)\n{\n    float filmDist = 1.3;\n    vec3 camera_z = normalize(at - from);\n    vec3 camera_x = normalize(cross(vec3(0,1,0), camera_z));\n    vec3 camera_y = cross(camera_z, camera_x);\n    return mat3(\n        camera_x,\n        camera_y,\n        camera_z\n    );\n}\n\n// inverse projection: rd -> uv\nvec2 rd2uv(vec3 rd, vec3 from, vec3 at, float filmDist, float ar)\n{\n    mat3 camMat = calcCameraMat(from, at);\n    // equivalent to inverse transform of camera matrix\n    vec3 uv = transpose(camMat) * rd;\n\n    uv /= uv.z;\n    uv *= filmDist;\n    uv.x /= ar;\n    uv = (uv + 1.0) / 2.0;\n    return uv.xy;\n}\n\nfloat radicalInverse(int x, float base)\n{\n    int baseI = int(base);\n    float result = 0.0;\n    float b = 1.0 / base;\n    while (x > 0)\n    {\n        result += float(x % baseI) * b;\n        x /= baseI;\n        b /= base;\n    }\n    return result;\n}\n\nvec2 halton23(int index)\n{\n    return vec2(radicalInverse(index, 2.0), radicalInverse(index, 3.0));\n}\n\nvec3 rgb2yCoCg(vec3 rgb)\n{\n    vec3 yCoCg;\n    yCoCg.x = 0.25 * rgb.r + 0.5 * rgb.g + 0.25 * rgb.b;\n    yCoCg.y = 0.5 * rgb.r - 0.5 * rgb.b;\n    yCoCg.z = -0.25 * rgb.r + 0.5 * rgb.g - 0.25 * rgb.b;\n    return yCoCg;\n}\n\nvec3 yCoCg2rgb(vec3 yCoCg)\n{\n    vec3 rgb;\n    rgb.x = yCoCg.r + yCoCg.g - yCoCg.b;\n    rgb.y = yCoCg.r + yCoCg.b;\n    rgb.z = yCoCg.r - yCoCg.g - yCoCg.b;\n    return rgb;\n}\n\nvec3 clipToBox(vec3 p, vec3 box_min, vec3 box_max) {\n    float epsilon = 0.000001;\n    \n    vec3 box_center = 0.5 * (box_max + box_min);\n    vec3 box_half = 0.5 * (box_max - box_min);\n    vec3 local_p = (p - box_center) / (box_half + epsilon);\n    \n    float max_d = max(max(abs(local_p.x), abs(local_p.y)), abs(local_p.z));\n    \n    if (max_d < 1.0) {\n        return p;\n    } else {\n        local_p /= max_d;\n        return local_p * (box_half + epsilon) + box_center;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fork of \"grass field with blades\" by MonterMan. https://shadertoy.com/view/dd2cWh\n// 2023-06-28 04:24:53\n\n// credits:\n//\n//    ollj: suggested lower-iteration fractal terrain hull to speed up traversal\n//    iq: suggested breaking shading code out of the raymarch loop for speedup\n//        also suggested fresnel with low-iter terrain normal for improved visual\n\n// hash function credit: https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(d1,-d2); }\n\nvec2 opRepeat(vec2 p, vec2 period, out vec2 outId)\n{\n    outId = floor((p+0.5*period)/period);\n    return mod(p+0.5*period, period) - 0.5*period;\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdGrassBlade2d(vec2 p)\n{\n    float dist = sdCircle(p - vec2(1.7, -1.3), 2.0);\n    dist = opSubtraction(dist, sdCircle(p - vec2(1.7, -1.0), 1.8));\n    dist = opSubtraction(dist, p.y + 1.0);\n    dist = opSubtraction(dist, -p.x + 1.7);\n    return dist;\n}\n\nfloat sdSphere(vec3 p)\n{\n    return length(p) - 1.0;\n}\n\nfloat sdGrassBlade(vec3 p, float thickness)\n{\n    p -= vec3(0, 1.0, 0);\n    float dist2d = max(0.0, sdGrassBlade2d(p.xy));\n    return sqrt(dist2d*dist2d + p.z*p.z) - thickness;\n}\n\nmat2 rotate2d(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(\n        c, -s,\n        s, c\n    );\n}\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float a = hash12(ip);\n    float b = hash12(ip + vec2(1, 0));\n    float c = hash12(ip + vec2(0, 1));\n    float d = hash12(ip + vec2(1, 1));\n    \n    vec2 t = smoothstep(0.0, 1.0, fp);\n    return mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n}\n\nfloat fbm(vec2 p, int octaveCount)\n{\n    float value = 0.0;\n    float amplitude = 0.5;\n    for (int i = 0; i < octaveCount; ++i)\n    {\n        value += amplitude * noise(p);\n        p *= rotate2d(0.45);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat calcTerrainHeight(vec2 p)\n{\n    return 20.0*fbm(0.02*p, 10);\n}\n\nfloat approxTerrainHeight(vec2 p)\n{\n    return 20.0*(fbm(0.02*p, 2) + 0.25);\n}\n\nvec3 calcTerrainNormal(vec2 p, float heightAtP)\n{\n    vec2 e = vec2(0, 0.001);\n    vec3 forward = vec3(0.0, calcTerrainHeight(p + e.xy) - heightAtP, e.y);\n    vec3 right = vec3(e.y, calcTerrainHeight(p + e.yx) - heightAtP, 0.0);\n    return normalize(cross(forward, right));\n}\n\nvec3 approxTerrainNormal(vec2 p)\n{\n    vec2 e = vec2(0, 0.001);\n    float approxHeightCenter = approxTerrainHeight(p);\n    vec3 forward = vec3(0.0, approxTerrainHeight(p + e.xy) - approxHeightCenter, e.y);\n    vec3 right = vec3(e.y, approxTerrainHeight(p + e.yx) - approxHeightCenter, 0.0);\n    return normalize(cross(forward, right));\n}\n\nfloat map(vec3 p, inout float terrainHeightAtP)\n{\n    float distToTerrain = 0.5 * (p.y - terrainHeightAtP);\n\n#if 1\n    float guard = 1.1;\n    if (distToTerrain > guard)\n    {\n        return distToTerrain - (guard - 1.0);\n    }\n#endif\n    \n    terrainHeightAtP = calcTerrainHeight(p.xz);\n    distToTerrain = 0.5 * (p.y - terrainHeightAtP);\n    vec3 originalP = p;\n\n    vec2 grassId;\n    float repeatPeriod = 0.25;\n    p.xz = opRepeat(p.xz, vec2(repeatPeriod), grassId);\n\n    float dist = 10e31;\n\n\n#define NEIGHBOR_CHECK_COUNT 1\n    for (int dy = -NEIGHBOR_CHECK_COUNT; dy <= NEIGHBOR_CHECK_COUNT; ++dy)\n    {\n        for (int dx = -NEIGHBOR_CHECK_COUNT; dx <= NEIGHBOR_CHECK_COUNT; ++dx)\n        {\n            vec3 neighborP = p - vec3(dx, 0, dy) * repeatPeriod;\n            vec2 neighborId = grassId + vec2(dx, dy);\n            \n            // HORRIBLE HACK:\n            //    assume all neighbors share the same terrain height\n            //    this produces minimal visual artifact and cuts rendering time more than half\n            //float terrainHeight = calcTerrainHeight(neighborId*repeatPeriod);\n            float terrainHeight = terrainHeightAtP;\n            neighborP.y -= terrainHeight;\n#if 1\n            // transform randomization\n            vec4 rand = hash42(neighborId);\n            neighborP.xz *= rotate2d(rand.z*6.28);\n            neighborP.xz += (rand.xy - 0.5) * repeatPeriod;\n#endif\n            dist = min(dist, sdGrassBlade(neighborP/sqrt(rand.w), 0.002));\n        }\n    }\n    \n    dist = min(dist, distToTerrain);\n    \n    return dist;\n}\n\nvec3 getSkyCol(vec3 rd)\n{\n    vec3 skyCol = vec3(0.6, 0.7, 0.8);\n    return mix(skyCol, 0.5*skyCol, rd.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n#ifdef DISABLE_TAA\n    vec2 jitter = vec2(0);\n#else\n    vec2 jitter = halton23(iFrame & 15);\n#endif\n    vec2 uv = (fragCoord+jitter)/iResolution.xy;\n\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 pixelSize = vec2(2.0) / iResolution.xy;\n\n#if 0\n    float cameraAngle = 3.1415926 + 2.0 * 3.1415926 * iMouse.x / 800.0;\n    vec3 ro = 10.0 * vec3(cos(cameraAngle), 0.8, sin(cameraAngle));\n    vec3 at = vec3(0, 1.5, 0);\n#else\n    float time = 45.0 + 15.0 * iTime;\n    vec3 ro = vec3(0.0, 18.2, -2.0 + time);\n    ro.y = max(approxTerrainHeight(ro.xz) + 5.0, ro.y);\n    vec3 at = ro + vec3(0, -0.4, 2.0);\n#endif\n    mat3 cameraMat = calcCameraMat(ro, at);\n    float filmDist = 1.3;\n    vec3 rd = normalize(cameraMat * vec3(uv, filmDist));\n    \n    int currIndex = iFrame & 1;\n    int prevIndex = (currIndex + 1) & 1;\n    ivec2 texelCoord = ivec2(fragCoord);\n    if (texelCoord.x == 2*currIndex + 0 && texelCoord.y == 0)\n    {\n        fragColor = vec4(ro, 10e31);\n        return;\n    }\n    if (texelCoord.x == 2*currIndex + 1 && texelCoord.y == 0)\n    {\n        fragColor = vec4(at, 10e31);\n        return;\n    }\n    if ((texelCoord.x == 2*prevIndex + 0 && texelCoord.y == 0) || \n        (texelCoord.x == 2*prevIndex + 1 && texelCoord.y == 0))\n    {\n        fragColor = texelFetch(iChannel0, texelCoord, 0);\n        return;\n    }\n        \n    vec3 skyCol = 1.1*getSkyCol(rd);\n    vec3 sunCol = vec3(1.2);\n    vec3 l = normalize(vec3(-0.5, 0.9, -0.0));\n    \n    // TODO: atmospheric scattering\n    vec3 col = skyCol;\n    \n    bool hit = false;\n    float t = 0.0;\n    for (int i = 0; i < 512 && t < 500.0; ++i)\n    {\n        if (rd.y > 0.0) break; // early-out if ray is going upward since no way it hits the ground\n        \n        vec3 p = ro + t * rd;\n        float terrainHeight = approxTerrainHeight(p.xz);\n        // NOTE: map() updates terrainHeight to exact height if ray penetrates terrain guard\n        float dist = map(p, terrainHeight);\n        \n        vec2 projectedPixelSize = pixelSize / filmDist * t;\n        // increase sampling frequency due to TAA\n        if (dist < 0.25*projectedPixelSize.x) // simple LOD: loosen check as point gets farther away\n        {\n            hit = true;\n            break;\n        }\n        t += dist;\n    }\n    \n    if (hit)\n    {\n        vec3 p = ro + t*rd;\n        vec3 youngGrassCol = vec3(0.3, 0.35, 0.15);\n        vec3 oldGrassCol = vec3(0.32, 0.35, 0.15);\n        float colBlend = smoothstep(0.4, 0.3, fbm(0.2*p.xz, 2));\n        vec3 grassCol = mix(youngGrassCol, oldGrassCol, colBlend);\n\n        float terrainHeight = calcTerrainHeight(p.xz);\n        float heightFromTerrain = p.y - terrainHeight;\n        vec3 n = calcTerrainNormal(p.xz, terrainHeight);\n        float directLight = max(0.0, dot(n, l));\n        float ao = 0.3 + 0.7*pow(heightFromTerrain, 0.5);\n        vec3 sampleCol = grassCol * (sunCol*directLight + 0.1*skyCol) * ao;\n        // fresnel idea suggested by iq\n        vec3 fresnel = vec3(0.2,0.2,0.1)*ao*pow(clamp(1.0 + dot(approxTerrainNormal(p.xz), rd),0.0,1.0), 3.0);\n        //float tweakA = -iMouse.z/800.0;\n        //float tweakB = -iMouse.w/450.0;\n        col = 0.74*sampleCol + 0.82*fresnel;\n    }\n    else\n    {\n        t = 10e31;\n    }\n    \n    vec3 fogExp = -0.25*vec3(0.01, 0.012, 0.01);\n    col = mix(skyCol, col, exp(fogExp*t));\n        \n#if 1\n    // HACK garbage formula color tuning\n    col = smoothstep(0.0, 1.0, col);\n    col *= 1.0;\n#else\n    //col = sqrt(col);\n#endif\n    fragColor = vec4(col, t);\n    \n    vec2 reprojUv = rd2uv(rd, ro, at, filmDist, iResolution.x/iResolution.y);\n    //fragColor = vec4(fragCoord/iResolution.xy, 0.0, 1.0);\n    //fragColor = vec4(reprojUv, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// credit to TheRealMJP for for CatmullRom sampling code: https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n// The following code is licensed under the MIT license: https://gist.github.com/TheRealMJP/bc503b0b87b643d3505d41eab8b332ae\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 sampleHistCatmullRom(in vec2 uv, in vec2 texSize)\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5f) + 0.5f;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * (-0.5f + f * (1.0f - 0.5f * f));\n    vec2 w1 = 1.0f + f * f * (-2.5f + 1.5f * f);\n    vec2 w2 = f * (0.5f + f * (2.0f - 1.5f * f));\n    vec2 w3 = f * f * (-0.5f + 0.5f * f);\n\n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / (w1 + w2);\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1);\n    vec2 texPos3 = texPos1 + vec2(2);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0);\n    result += texture(iChannel1, vec2(texPos0.x, texPos0.y)) * w0.x * w0.y;\n    result += texture(iChannel1, vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += texture(iChannel1, vec2(texPos3.x, texPos0.y)) * w3.x * w0.y;\n\n    result += texture(iChannel1, vec2(texPos0.x, texPos12.y)) * w0.x * w12.y;\n    result += texture(iChannel1, vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += texture(iChannel1, vec2(texPos3.x, texPos12.y)) * w3.x * w12.y;\n\n    result += texture(iChannel1, vec2(texPos0.x, texPos3.y)) * w0.x * w3.y;\n    result += texture(iChannel1, vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += texture(iChannel1, vec2(texPos3.x, texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    if (iFrame == 0)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n\n    // iChannel0 (buffer A): curr buffer\n    // iChannel1 (buffer C): hist buffer\n    \n    int currIndex = iFrame & 1;\n    int prevIndex = (currIndex + 1) & 1;\n    vec3 currCamOrigin = texelFetch(iChannel0, ivec2(currIndex*2 + 0, 0), 0).rgb;\n    vec3 currCamAt = texelFetch(iChannel0, ivec2(currIndex*2 + 1, 0), 0).rgb;\n    vec3 prevCamOrigin = texelFetch(iChannel0, ivec2(prevIndex*2 + 0, 0), 0).rgb;\n    vec3 prevCamAt = texelFetch(iChannel0, ivec2(prevIndex*2 + 1, 0), 0).rgb;\n\n    float currDepth = texelFetch(iChannel0, ivec2(fragCoord), 0).a;\n    if (currDepth > 100000.0)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    \n    float filmDist = 1.3;\n    mat3 cameraMat = calcCameraMat(currCamOrigin, currCamAt);\n    vec3 rd = normalize(cameraMat * vec3(uv, filmDist));\n    \n    // reprojection\n    vec3 currPos = currCamOrigin + currDepth * rd;\n    vec3 prevRd = normalize(currPos - prevCamOrigin);\n    vec2 prevUv = rd2uv(prevRd, prevCamOrigin, prevCamAt, filmDist, iResolution.x/iResolution.y);\n\n    vec3 curr = texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n    //vec3 hist = texture(iChannel1, prevUv.xy).rgb;\n    vec3 hist = sampleHistCatmullRom(prevUv.xy, iResolution.xy).rgb;\n    \n    float histWeight = 0.9;\n    if (any(greaterThan(prevUv.xy, vec2(1.0))) ||\n        any(lessThan(prevUv.xy, vec2(0.0))))\n    {\n        histWeight = 0.0;\n    }\n    \n    // neighborhood clamping\n    vec3 neighborMin = vec3(10e31);\n    vec3 neighborMax = vec3(0);\n    float neighborSize = 0.5;\n    for (int dy = -1; dy <= 1; ++dy)\n    {\n        for (int dx = -1; dx <= 1; ++dx)\n        {\n            vec2 neighborTexelAddr = (fragCoord + neighborSize*vec2(dx, dy))/iResolution.xy;\n            vec3 neighborSample = texture(iChannel0, neighborTexelAddr).rgb;\n            neighborSample = rgb2yCoCg(neighborSample);\n            neighborMin = min(neighborMin, neighborSample);\n            neighborMax = max(neighborMax, neighborSample);\n        }\n    }\n    hist = rgb2yCoCg(hist);\n    hist = clipToBox(hist, neighborMin, neighborMax);\n    hist = yCoCg2rgb(hist);\n    \n    fragColor = vec4(mix(curr, hist, vec3(histWeight)), 1.0);\n    //fragColor = vec4(abs(uv - prevUv), 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Buffer C","description":"","type":"buffer"}]}