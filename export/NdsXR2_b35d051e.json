{"ver":"0.1","info":{"id":"NdsXR2","date":"1628734231","viewed":76,"name":"Study Path Tracing 2","username":"YUIT","description":"A path tracer","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n\tvec4 col = texelFetch(iChannel0,ivec2(fragCoord),0);\n    vec3 fragCol=vec3(col.xyz);\n    \n    fragCol/=col.w;\n    //fragCol=fragCol/(vec3(1)+fragCol);\n    fragCol = LinearToGamma(fragCol);\n    \n    fragColor = vec4(fragCol,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Define math constants\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318\n\n#define EPS 0.0001\n#define INF 10000000.\n\n#define MAX_DEPTH 4u  // Max depth\n\n#define TMIN 0.1\n#define TMAX 100.\n\n// The light energy\n#define Le vec3(20.2)\n// Multiple importance sample\n// #define USE_MIS\n\n#define LIGHT_MAT uint(-1)\n#define BG_MAT uint(-2)\n\n#define MATERIAL_0 0u\n#define MATERIAL_1 1u\n#define MATERIAL_2 2u\n#define MATERIAL_3 3u\n#define MATERIAL_4 4u\n\n#define USE_SPHERE\n#define USE_RECTANGLE \n#define USE_LIGHT\n\nconst vec3 L_S=vec3(1.,0.,0.);\nconst vec3 L_U=vec3(0.,1.,0.);\nconst vec3 L_F=vec3(0.,0.,1.);\n\n///\n/// Base Data structure\n///\nstruct LightInfo {\n    // light color\n    vec3 emission;\n    vec3 corner;    // the rectangle corner\n    vec3 v1, v2;    // the rectangle edge vector\n    vec3 normal;    // the rectangle normal\n    \n    int type;\n    bool enabled;\n};\n\nstruct ONB {\n    vec3 N;\n    vec3 T;\n    vec3 B;\n};\n\nstruct Sphere{\n    float radius;\n    vec3 center;\n    uint matIndex;\n};\n\nstruct Rectangle{\n    vec3 origin;\n    vec3 normal;\n    vec2 size;\n    uint matIndex;\n};\n\nstruct Ray{\n    vec3 d;\n    vec3 o;\n};\n\n// Disney Brdf material params\nstruct MaterialInfo {\n    vec3  baseColor;       // Base Color\n    float subsurface;      // Subsurface scatering\n    float roughness;       // Roughness\n    float metallic;        // Metalness\n    float specular;\n    float specularTint;\n    float clearcoat;\n    float clearcoatGloss;\n    float anisotropic;\n    float sheen;\n    float sheenTint;\n};\n\nstruct HitData {\n    vec3 N;        // Hit surface normal\n    vec3 P;        // Hit surface point\n    vec3 X;        // Hit Anisotropic Params\n    vec3 Y;\n    uint matIdx;   // Hit material index\n};\n\nstruct MissData {\n    vec3 bgColor;  // Miss background color\n};\n\nconst uint sphereCnt = 4u;\nSphere spheres[sphereCnt];\n\nconst uint planeCnt = 1u;\nRectangle planes[planeCnt];\n\nconst uint lightCnt = 1u;\nLightInfo lights[lightCnt];\n\nconst uint objCnt = planeCnt + sphereCnt;\nMaterialInfo materials[objCnt] = MaterialInfo[objCnt](\n    MaterialInfo(vec3(1.), 0., 1., 0., 0., 0., 0., 1., 0., 0., 0.),\n    MaterialInfo(vec3(.8, .4, .3), 0., 0.3, 0., 1., 0., 0., 1., 0., 0., 0.),\n    MaterialInfo(vec3(.4, .8, .7), 0., 0.2, 0., 1., 0., 0., 1., 0., 0., 0.),\n    MaterialInfo(vec3(.8, .8, .3), 0., 0.1, 1., 0.3, 0., 0., 1., 0., 0., 0.),\n    MaterialInfo(vec3(.8), 0., 1., 0., 0., 0., 0., 1., 0., 0., 0.)\n);\n\n// Global hit data\nHitData g_Hit;\n// Global miss data\nMissData g_Miss;\n// Global ray\nRay g_ray;\n// Global shadow ray\n// Note : Just one shadow ray\nRay g_sray;\n// Gloabl ray max t value\nfloat g_t;\nfloat g_st;\n\n// Global random seed\nuint g_seed = 0u;\n\nvoid InitGlobalTracingState() {\n    g_Hit = HitData(vec3(0), vec3(0), vec3(0), vec3(0), BG_MAT);\n    g_Miss= MissData(vec3(0));\n    g_ray = Ray(vec3(0), vec3(0));\n    g_sray = Ray(vec3(0), vec3(0));\n    g_t = g_st = TMAX;\n}\n\nRectangle GetRecAreaFromLight(const in uint lIdx) {\n    vec3 origin = lights[lIdx].corner + lights[lIdx].v1 * .5 + lights[lIdx].v2 * .5;\n    vec2 size = vec2(length(lights[lIdx].v1), length(lights[lIdx].v2));\n    return Rectangle(origin, lights[lIdx].normal, size, LIGHT_MAT);\n}\n\nvec3 GetRay(const in float t){\n    return g_ray.o + g_ray.d * t;\n}\n\nvec3 GetRayOrigin() {\n    return g_ray.o;\n}\n\nvec3 GetRayDirection() {\n    return g_ray.d;\n}\n\nvoid SetRay(in vec3 o, in vec3 d) {\n    g_ray.o = o;\n    g_ray.d = d;\n}\n\nvoid SetShadowRay(in vec3 o, in vec3 d) {\n    g_sray.o = o;\n    g_sray.d = d;\n}\n\nvec3 GetShadowRayOrigin() {\n    return g_sray.o;\n}\n\nvec3 GetShadowRayDirection() {\n    return g_sray.d;\n}\n\nvec3 GetShadowRay(const in float t) {\n    return g_sray.o + t * g_sray.d;\n}\n\nvoid SetHitData(const in vec3 p, const in vec3 n, const in uint id) {\n    g_Hit.P = p;\n    g_Hit.N = n;\n    g_Hit.matIdx = id;\n}\n\nbool SetT(out float gt, const in float t, in float tmin, in float tmax) {\n    if (t < tmin || t > tmax) \n        return false;\n    if(gt > t) {\n        gt = t; \n        return true;\n    }\n    return false;\n}\n\nbool SetHitT(const in float t, in float tmin, in float tmax, in bool isVray) {\n    return isVray ? SetT(g_st, t, tmin, tmax) : SetT(g_st, t, tmin, tmax);\n}\n\nvoid SetMissData(const in vec3 bgCol) { g_Miss.bgColor = bgCol; }\n\nMaterialInfo GetMat() { return materials[g_Hit.matIdx]; }\n\n////////////////////////////////\n// intersection part\nbool IntersectWithRectangle(in Rectangle rec, in Ray r, in float tmin, in float tmax, in bool isVray){\n    vec3 asubo = rec.origin-r.o;\n    float d_dot_n = dot(r.d, rec.normal);\n    if(abs(d_dot_n) < EPS) return false;\n    float hit_t = dot(asubo,rec.normal) / d_dot_n;\n    bool hitted = false;\n    if (SetHitT(hit_t, tmin, tmax, isVray)) {\n        vec3 ray_hit = r.o + r.d * hit_t;\n        vec3 y = rec.normal;\n        vec3 x = normalize(cross(rec.normal, -L_F));\n        vec3 z = normalize(cross(y, -x));\n        mat3 basis = transpose(mat3(x,y,z));\n        mat4 transform = mat4(vec4(basis[0], 0.), vec4(basis[1],0.), vec4(basis[2],0.),\n            vec4(-basis*rec.origin, 1.));\n        vec3 rhit = (transform*vec4(ray_hit,1.)).xyz;\n        bvec2 re = lessThan(abs(rhit.xz), rec.size);\n        if(re.x && re.y){\n            if (!isVray)\n                SetHitData(ray_hit, rec.normal, rec.matIndex);\n            hitted = true;\n        }\n    } \n    return hitted;\n}\n\n// Sphere intersection test\nbool IntersectWithSphere(in Sphere s, in Ray r, in float tmin, in float tmax, in bool isVray)\n{\n    bool hitted=false;\n    vec3 tmp=r.o-s.center;\n    float b=2.*dot(r.d,tmp);\n    float c=dot(tmp,tmp)-s.radius*s.radius;\n    float discriminant=b*b-4.*c;\n    if(discriminant>0.){\n        discriminant=sqrt(discriminant);\n        float t=(-b-discriminant)/(2.);\n        if(t<tmin) t=(-b+discriminant)/2.;\n        if (SetHitT(t, tmin, tmax, isVray)) {\n            hitted=true;\n            vec3 pos = r.o + r.d * t;\n            if (!isVray)\n                SetHitData(pos, normalize(pos-s.center), s.matIndex);\n        }\n    }\n    return hitted;\n}\n\n/// Random Utility\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\n\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash21(uint x)\n{\n    uint n = baseHash(x);\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat hash1(uint x)\n{\n    uint n = baseHash(x);\n    return float((n >> 1) & (0x7fffffffU))/float(0x7fffffff);\n}\n\n// frameIdx: When camera change this will change \nvoid InitGlobalSeed(uvec2 p, uint w, uint subFrameIdx) {\n    g_seed = baseHash(uvec2(p.x*w+p.y, subFrameIdx));\n}\n\nvec2 rand2() { return hash21(g_seed++); }\nfloat rand() { return hash1(g_seed++); }\n\n// Init a scene\nvoid InitScene() {\n    uint count = 0u;\n#ifdef USE_SPHERE\n    spheres[count++] = Sphere(0.6, vec3(0., 1.15, 0.), MATERIAL_1);\n    spheres[count++] = Sphere(0.5, vec3(1.3, 1.1, 0.5), MATERIAL_2);\n    spheres[count++] = Sphere(0.3, vec3(-1.2, 0.87, 0.6), MATERIAL_3);\n#endif\n\n#ifdef USE_RECTANGLE\n    planes[0] = Rectangle(vec3(0., 0.5, 0.), vec3(0., 1., 0.), vec2(3.), MATERIAL_0);\n#endif\n\n#ifdef USE_LIGHT\n    vec3 offset = vec3(-0.5, 1., 0.);\n    float scale = 1.3;\n    lights[0] = LightInfo(\n        Le,                                     \n        vec3(-.5, 0.5, 1.)*scale+offset,                     \n        vec3(0., 0.5, -1.)*scale+offset, vec3(1., .5, 0.)*scale+offset,\n        normalize(vec3(0.1, -0.5, 0.2)),\n        \n        0, true\n    );\n#endif\n}\n\n\nmat3 rotateY(float degree) {\n    float rd = radians(degree);\n    float cosTheta = cos(degree);\n    float sinTheta = sin(degree);\n    return mat3(\n        cosTheta, 0., sinTheta,\n        0., 1., 0.,\n        -sinTheta, 0., cosTheta\n    ); \n}\n\n// Define an animation\nvoid AnimationInit(float time) {\n#ifdef USE_SPHERE\n    spheres[2].center = rotateY(mod(time,360.)) * spheres[2].center;\n#endif\n}\n\nbool WorldHitTest(in float tmin, in float tmax, in bool isVray) {\n    bool hitted = false;\n    Ray ray;\n    if (isVray) ray = g_sray;\n    else ray = g_ray;\n#ifdef USE_SPHERE\n    for (uint i = 0u; i < sphereCnt; i++) \n        if (IntersectWithSphere(spheres[i], ray, tmin, tmax, isVray)) hitted = true;\n#endif\n\n#ifdef USE_RECTANGLE\n    for (uint i = 0u; i < planeCnt; i++) \n        if (IntersectWithRectangle(planes[i], ray, tmin, tmax, isVray)) hitted = true;\n#endif\n\n#ifdef USE_LIGHT\n    for (uint i = 0u; i < lightCnt; i++)\n        if (IntersectWithRectangle(GetRecAreaFromLight(i), ray, tmin, tmax, isVray)) hitted = true;\n#endif\n\n    return hitted;\n}\n\n//////////////// Camera Setup ///////////////////\n// Calculate fovy from focal length\nfloat focalLengthToFovY(float f, float h){\n    return 2.*atan(.5*h/f);\n}\n\n// Calculate focal length from fovy\nfloat fovYToFocalLength(float fovy, float h){\n    return h/(2.*tan(.5*fovy));\n}\n\nvoid GetCameraRay(vec2 offset, in vec2 p, in float fovy, in vec2 vp) {\n    vec3 origin = vec3(0.0, 2.5, 10.0);\n    vec3 lookAt = vec3(0., 1.2, 0.);\n\n    vec2 uv = (p + offset) / vp.xy - vec2(.5);\n    uv.y *= vp.y / vp.x;\n\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( lookAt - origin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 direction = normalize( uv.x * ix + uv.y * iy + fovYToFocalLength(radians(fovy), 1.) * iz );\n\n    SetRay(origin, direction);\n}\n\n/////////////////////////////////////////////////\n// Gamma Correction\nvec3 LinearToGamma(const in vec3 linearColor) {\n   return pow(linearColor, vec3(0.4545));\n}\n\nvec3 GammaToLinear(const in vec3 gammaColor) {\n   return pow(gammaColor, vec3(2.2));\n}\n\nfloat ColorToLuminance(in vec3 col) {\n    return .3*col.r + .6*col.g + .1*col.b;\n}\n\n//////////////////////////////////////////\n// \nfloat DistanceSq(in vec3 v1, in vec3 v2) {\n    vec3 d = v1 - v2;\n    return dot(d, d);\n}\n\nfloat Pow2(in float x) { \n    return x*x;\n}\n\nvoid CreateONB(vec3 normal, out ONB onb){\n    vec3 tangent, binormal;\n    if (abs(normal.x) > abs(normal.y)) {\n        tangent = normalize(vec3(0., normal.z, -normal.y));\n    }\n    else {\n        tangent = normalize(vec3(-normal.z, 0., normal.x));\n    }\n    binormal = cross(normal, tangent);\n    onb = ONB(normal, tangent, binormal);\n}\n\nvoid TransformToONB(out vec3 p, in ONB onb) {\n    p = p.x * onb.T + p.y * onb.B + p.z * onb.N;\n}\n\n///////////////////////////////////////////////////\n// From https://www.shadertoy.com/view/XdyyDd\nvoid directionOfAnisotropicity(vec3 normal, out vec3 tangent, out vec3 binormal){\n    tangent = cross(normal, vec3(1.,0.,1.));\n    binormal = normalize(cross(normal, tangent));\n    tangent = normalize(cross(normal,binormal));\n}\n\nvec3 sphericalDirection(float sinTheta, float cosTheta, float sinPhi, float cosPhi) {\n    return vec3(sinTheta * cosPhi, sinTheta * sinPhi, cosTheta);\n}\n\nvec3 uniformSampleCone(vec2 u12, float cosThetaMax, vec3 xbasis, vec3 ybasis, vec3 zbasis) {\n    float cosTheta = (1. - u12.x) + u12.x * cosThetaMax;\n    float sinTheta = sqrt(1. - cosTheta * cosTheta);\n    float phi = u12.y * TWO_PI;\n    vec3 samplev = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));\n    return samplev.x * xbasis + samplev.y * ybasis + samplev.z * zbasis;\n}\n\nbool sameHemiSphere(const in vec3 wo, const in vec3 wi, const in vec3 normal) {\n    return dot(wo, normal) * dot(wi, normal) > 0.0;\n}\n\nvec2 concentricSampleDisk(const in vec2 u) {\n    vec2 uOffset = 2. * u - vec2(1., 1.);\n\n    if (uOffset.x == 0. && uOffset.y == 0.) return vec2(0., 0.);\n\n    float theta, r;\n    if (abs(uOffset.x) > abs(uOffset.y)) {\n        r = uOffset.x;\n        theta = PI/4. * (uOffset.y / uOffset.x);\n    } else {\n        r = uOffset.y;\n        theta = PI/2. - PI/4. * (uOffset.x / uOffset.y);\n    }\n    return r * vec2(cos(theta), sin(theta));\n}\n\nvec3 cosineSampleHemisphere(const in vec2 u) {\n    vec2 d = concentricSampleDisk(u);\n    float z = sqrt(max(EPS, 1. - d.x * d.x - d.y * d.y));\n    return vec3(d.x, d.y, z);\n}\n\nvec3 uniformSampleHemisphere(const in vec2 u) {\n    float z = u[0];\n    float r = sqrt(max(EPS, 1. - z * z));\n    float phi = 2. * PI * u[1];\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// Multiple importance sampling\nfloat powerHeuristic(float nf, float fPdf, float ng, float gPdf){\n    float f = nf * fPdf;\n    float g = ng * gPdf;\n    return (f*f)/(f*f + g*g);\n}\n\n\n/////////////////////////////////////////////////////\n/// Probability Density Function and Bidirectional Reflectance Distribution Function\n/////////////////////////////////////////////////////\n\n// From Disney' principled brdf\n// Basic SChlick Fresnel Approximation\nfloat SchlickFresnel(float theta)\n{\n    float m = clamp(1.-theta, 0., 1.);\n    float m2 = m*m;\n    return m2*m2*m; // pow(m,5)\n}\n\nfloat GTR1(float NdotH, float a)\n{\n    if (a >= 1.) return 1./PI;\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return (a2-1.) / (PI*log(a2)*t);\n}\n\nfloat GTR2(float NdotH, float a)\n{\n    float a2 = a*a;\n    float t = 1. + (a2-1.)*NdotH*NdotH;\n    return a2 / (PI * t*t);\n}\n\nfloat GTR2_aniso(float NdotH, float HdotX, float HdotY, float ax, float ay)\n{\n    return 1. / (PI * ax*ay * Pow2( Pow2(HdotX/ax) + Pow2(HdotY/ay) + NdotH*NdotH ));\n}\n\nfloat smithG_GGX(float NdotV, float alphaG)\n{\n    float a = alphaG*alphaG;\n    float b = NdotV*NdotV;\n    return 1. / (NdotV + sqrt(a + b - a*b));\n}\n\nfloat smithG_GGX_aniso(float NdotV, float VdotX, float VdotY, float ax, float ay)\n{\n    return 1. / (NdotV + sqrt( Pow2(VdotX*ax) + Pow2(VdotY*ay) + Pow2(NdotV) ));\n}\n\nvec3 mon2lin(vec3 x)\n{\n    return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\n///////////////////////////////////////////////////\n// pdf(theta) = cos(theta)/PI\n// wi: incident direction\n// wo: reflected direction\n#define JUDGE_INHEMISPHERE if (!sameHemiSphere(wo, wi, g_Hit.N)) return 0.;\n\nfloat pdfLambertianReflection(const in vec3 wi, const in vec3 wo) {\n    return sameHemiSphere(wo, wi, g_Hit.N) ? abs(dot(g_Hit.N, wi))/PI : 0.;\n}\n\n// pdf for microfacet\nfloat pdfMicrofacet(const in vec3 wi, const in vec3 wo) {\n    JUDGE_INHEMISPHERE\n    vec3 wh = normalize(wo + wi);\n    MaterialInfo mat = GetMat();\n    float NdotH = dot(g_Hit.N, wh);\n    float alpha2 = mat.roughness * mat.roughness;\n    alpha2 *= alpha2;\n    \n    float cos2Theta = NdotH * NdotH;\n    float denom = cos2Theta * ( alpha2 - 1.) + 1.;\n    if( denom == 0. ) return 0.;\n    float pdfDistribution = alpha2 * NdotH /(PI * denom * denom);\n    return pdfDistribution/(4. * dot(wo, wh));\n}\n\nfloat pdfMicrofacetAniso(const in vec3 wi, const in vec3 wo) {\n    JUDGE_INHEMISPHERE\n    vec3 wh = normalize(wo + wi);\n    MaterialInfo mat = GetMat();\n    float aspect = sqrt(1.-mat.anisotropic*.9);\n    float alphax = max(.001, Pow2(mat.roughness)/aspect);\n    float alphay = max(.001, Pow2(mat.roughness)*aspect);\n    \n    float alphax2 = alphax * alphax;\n    float alphay2 = alphax * alphay;\n\n    float hDotX = dot(wh, g_Hit.X);\n    float hDotY = dot(wh, g_Hit.Y);\n    float NdotH = dot(g_Hit.N, wh);\n    \n    float denom = hDotX * hDotX/alphax2 + hDotY * hDotY/alphay2 + NdotH * NdotH;\n    if( denom == 0. ) return 0.;\n    float pdfDistribution = NdotH /(PI * alphax * alphay * denom * denom);\n    return pdfDistribution/(4. * dot(wo, wh));\n}\n\nfloat pdfClearCoat(const in vec3 wi, const in vec3 wo) {\n    JUDGE_INHEMISPHERE\n\n    vec3 wh = wi + wo;\n    wh = normalize(wh);\n\tMaterialInfo mat = GetMat();\n    float NdotH = abs(dot(wh, g_Hit.N));\n    float Dr = GTR1(NdotH, mix(.1,.001, mat.clearcoatGloss));\n    return Dr * NdotH/ (4. * dot(wo, wh));\n}\n\n// Disney brdf setting\nvec3 disneyDiffuse(const in float NdotL, const in float NdotV, const in float LdotH) {\n    MaterialInfo mat = GetMat();\n    float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n    \n    float Fd90 = 0.5 + 2. * LdotH*LdotH * mat.roughness;\n    float Fd = mix(1.0, Fd90, FL) * mix(1.0, Fd90, FV);\n    \n    return (1./PI) * Fd * mat.baseColor;\n}\n\nvec3 disneySubsurface(const in float NdotL, const in float NdotV, const in float LdotH) {\n    MaterialInfo mat = GetMat();\n    float FL = SchlickFresnel(NdotL), FV = SchlickFresnel(NdotV);\n    \n    float Fss90 = LdotH*LdotH*mat.roughness;\n    float Fss = mix(1.0, Fss90, FL) * mix(1.0, Fss90, FV);\n    float ss = 1.25 * (Fss * (1. / (NdotL + NdotV) - .5) + .5);\n    \n    return (1./PI) * ss * mat.baseColor;\n}\n\nvec3 disneyMicrofacetIsotropic(float NdotL, float NdotV, float NdotH, float LdotH) {\n    MaterialInfo mat = GetMat();\n    float Cdlum = ColorToLuminance(mat.baseColor); // luminance approx.\n\n    vec3 Ctint = Cdlum > 0. ? mat.baseColor/Cdlum : vec3(1.); // normalize lum. to isolate hue+sat\n    vec3 Cspec0 = mix(mat.specular *.08 * mix(vec3(1.), Ctint, mat.specularTint), mat.baseColor, mat.metallic);\n    \n    float a = max(.001, Pow2(mat.roughness));\n    float Ds = GTR2(NdotH, a);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX(NdotL, a);\n    Gs *= smithG_GGX(NdotV, a);\n    \n    return Gs*Fs*Ds;\n}\n\nvec3 disneyMicrofacetAnisotropic(float NdotL, float NdotV, float NdotH, float LdotH,\n                                 const in vec3 L, const in vec3 V,\n                                 const in vec3 H) {\n    MaterialInfo mat = GetMat();\n    float Cdlum = ColorToLuminance(mat.baseColor);\n\n    vec3 Ctint = Cdlum > 0. ? mat.baseColor/Cdlum : vec3(1.);\n    vec3 Cspec0 = mix(mat.specular *.08 * mix(vec3(1.), Ctint, mat.specularTint), mat.baseColor, mat.metallic);\n    \n    float aspect = sqrt(1.-mat.anisotropic*.9);\n    float ax = max(.001, Pow2(mat.roughness)/aspect);\n    float ay = max(.001, Pow2(mat.roughness)*aspect);\n    float Ds = GTR2_aniso(NdotH, dot(H, g_Hit.X), dot(H, g_Hit.Y), ax, ay);\n    float FH = SchlickFresnel(LdotH);\n    vec3 Fs = mix(Cspec0, vec3(1), FH);\n    float Gs;\n    Gs  = smithG_GGX_aniso(NdotL, dot(L, g_Hit.X), dot(L, g_Hit.Y), ax, ay);\n    Gs *= smithG_GGX_aniso(NdotV, dot(V, g_Hit.X), dot(V, g_Hit.Y), ax, ay);\n    \n    return Gs*Fs*Ds;\n}\n\nfloat disneyClearCoat(float NdotL, float NdotV, float NdotH, float LdotH) {\n    MaterialInfo mat = GetMat();\n    float gloss = mix(.1,.001, mat.clearcoatGloss);\n    float Dr = GTR1(abs(NdotH), gloss);\n    float FH = SchlickFresnel(LdotH);\n    float Fr = mix(.04, 1.0, FH);\n    float Gr = smithG_GGX(NdotL, .25) * smithG_GGX(NdotV, .25);\n    return .25 * mat.clearcoat * Fr * Gr * Dr;\n}\n\nvec3 disneySheen(float LdotH) {\n    MaterialInfo mat = GetMat();\n    float FH = SchlickFresnel(LdotH);\n    float Cdlum = ColorToLuminance(mat.baseColor);\n\n    vec3 Ctint = Cdlum > 0. ? mat.baseColor/Cdlum : vec3(1.);\n    vec3 Csheen = mix(vec3(1.), Ctint, mat.sheenTint);\n    vec3 Fsheen = FH * mat.sheen * Csheen;\n    return FH * mat.sheen * Csheen;\n}\n\n\n/////////////////////// Sample Stategy /////////////////////\n////////////////////////////////////////////////////////////\n\nvoid cosineSample(in vec2 rand, in vec3 N, in vec3 wo, out vec3 wi) {\n    vec3 wi_local = cosineSampleHemisphere(rand);\n    ONB onb;\n    CreateONB(N, onb);\n    TransformToONB(wi_local, onb);\n\twi = wi_local;\n    if (dot(wo, N) < 0.) wi.z *= -1.;\n}\n\nvec3 AreaLightSample(const in uint lIdx, out vec3 wi, out float tmax, out float lightPdf) {\n    // Get Light Pos\n    vec2 rand = rand2();\n    lightPdf = 0.;\n    vec3 sampled_light_pos = lights[lIdx].corner + rand.x * lights[lIdx].v1 + rand.y * lights[lIdx].v2;\n    float Ldist = length(sampled_light_pos - g_Hit.P);\n    vec3 L = normalize(sampled_light_pos - g_Hit.P);\n    float nDl = dot(g_Hit.N, L);\n    float LnDl = dot(lights[lIdx].normal, -L);\n    \n    tmax = Ldist;\n    \n    SetShadowRay(g_Hit.P, L);\n    g_st = tmax;\n    wi = GetShadowRayDirection();\n    if (nDl * LnDl > 0.) {\n        // The total area of the area light\n        float A = length(cross(lights[lIdx].v1, lights[lIdx].v2));\n        lightPdf = LnDl * A / (PI * Pow2(Ldist));\n    }\n    // Set the incident direction\n    \n    return lights[lIdx].emission;\n}\n\n\nvoid disneyDiffuseSample(\n    out vec3 wi, \n    const in vec3 wo, \n    out float pdf, \n    const in vec2 rand\n) {    \n    cosineSample(rand, g_Hit.N, wo, wi);\n}\n\nvec3 disneySheenSample(\n    out vec3 wi, \n    const in vec3 wo, \n    out float pdf, \n    const in vec2 rand\n) {\n    cosineSample(rand, g_Hit.N, wo, wi);\n\n    vec3 H = normalize(wo+wi);\n    float LdotH = dot(wo,H);\n    \n    pdf = pdfLambertianReflection(wi, wo);\n    return disneySheen(LdotH);\n}\n\nvec3 disneyMicrofacetSample(\n    out vec3 wi, \n    const in vec3 wo, \n    out float pdf, \n    const in vec2 rand\n) {\n    MaterialInfo mat = GetMat();\n    float cosTheta = 0., phi = (2. * PI) * rand[1];\n    float alpha = mat.roughness * mat.roughness;\n    float tanTheta2 = alpha * alpha * rand[0] / (1.0 - rand[0]);\n    cosTheta = 1. / sqrt(1. + tanTheta2);\n    \n    float sinTheta = sqrt(max(EPS, 1. - cosTheta * cosTheta));\n    vec3 whLocal = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));\n    \n    ONB onb;\n    CreateONB(g_Hit.N, onb);\n    TransformToONB(whLocal, onb);\n    vec3 wh = whLocal;\n    \n    if(!sameHemiSphere(wo, wh, g_Hit.N)) {\n       wh *= -1.;\n    }\n            \n    wi = reflect(-wo, wh);\n    \n    float NdotL = dot(g_Hit.N, wo);\n    float NdotV = dot(g_Hit.N, wi);\n\n    if (NdotL < 0. || NdotV < 0.) {\n        pdf = 0.; // If not set to 0 here, create's artifacts. WHY EVEN IF SET OUTSIDE??\n        return vec3(0.);\n    }\n    \n    vec3 H = normalize(wo+wi);\n    float NdotH = dot(g_Hit.N,H);\n    float LdotH = dot(wo,H);\n    \n    pdf = pdfMicrofacet(wi, wo);\n    return disneyMicrofacetIsotropic(NdotL, NdotV, NdotH, LdotH);\n}\n\nvoid disneyMicrofacetAnisoSample(\n    out vec3 wi, \n    const in vec3 wo, \n    const in vec2 rand\n) {\n    MaterialInfo mat = GetMat();\n    float cosTheta = 0., phi = 0.;\n    \n    float aspect = sqrt(1. - mat.anisotropic*.9);\n    float alphax = max(.001, Pow2(mat.roughness)/aspect);\n    float alphay = max(.001, Pow2(mat.roughness)*aspect);\n    \n    phi = atan(alphay / alphax * tan(2. * PI * rand[1] + .5 * PI));\n    \n    if (rand[1] > .5f) phi += PI;\n    float sinPhi = sin(phi), cosPhi = cos(phi);\n    float alphax2 = alphax * alphax, alphay2 = alphay * alphay;\n    float alpha2 = 1. / (cosPhi * cosPhi / alphax2 + sinPhi * sinPhi / alphay2);\n    float tanTheta2 = alpha2 * rand[0] / (1. - rand[0]);\n    cosTheta = 1. / sqrt(1. + tanTheta2);\n    \n    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));\n    vec3 whLocal = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));\n         \n    vec3 wh = whLocal.x * g_Hit.X + whLocal.y * g_Hit.Y + whLocal.z * g_Hit.N;\n    \n    if(!sameHemiSphere(wo, wh, g_Hit.N)) {\n       wh *= -1.;\n    }\n            \n    wi = reflect(-wo, wh);\n}\n\nvoid disneyClearCoatSample(\n    out vec3 wi, \n    const in vec3 wo, \n    const in vec2 rand\n) {\n    MaterialInfo mat = GetMat();\n\tfloat gloss = mix(0.1, 0.001, mat.clearcoatGloss);\n    float alpha2 = gloss * gloss;\n    float cosTheta = sqrt(max(EPS, (1. - pow(alpha2, 1. - rand[0])) / (1. - alpha2)));\n    float sinTheta = sqrt(max(EPS, 1. - cosTheta * cosTheta));\n    float phi = TWO_PI * rand[1];\n    \n    vec3 whLocal = sphericalDirection(sinTheta, cosTheta, sin(phi), cos(phi));\n     \n    ONB onb;\n    CreateONB(g_Hit.N, onb);\n    TransformToONB(whLocal, onb);\n    vec3 wh = whLocal;\n    \n    if(!sameHemiSphere(wo, wh, g_Hit.N)) {\n       wh *= -1.;\n    }\n            \n    wi = reflect(-wo, wh);   \n}\n\n// Add All pdf\nfloat bsdfPdf(\n    const in vec3 wi, \n    const in vec3 wo\n) {\n    float pdfDiffuse = pdfLambertianReflection(wi, wo);\n    float pdfMicrofacet = pdfMicrofacetAniso(wi, wo);\n    float pdfClearCoat = pdfClearCoat(wi, wo);\n    return (pdfDiffuse + pdfMicrofacet + pdfClearCoat)/3.;\n}\n\nvec3 EvaluateDisneyBSDF(const in vec3 wi, const in vec3 wo) {\n    if (!sameHemiSphere(wo, wi, g_Hit.N)) return vec3(0.);\n    MaterialInfo mat = GetMat();\n\tfloat NdotL = dot(g_Hit.N, wo);\n    float NdotV = dot(g_Hit.N, wi);\n    \n    if (NdotL < 0. || NdotV < 0.) return vec3(0.);\n\n    vec3 H = normalize(wo+wi);\n    float NdotH = dot(g_Hit.N,H);\n    float LdotH = dot(wo,H);\n    \n    vec3 diffuse = disneyDiffuse(NdotL, NdotV, LdotH);\n    vec3 subSurface = disneySubsurface(NdotL, NdotV, LdotH);\n    vec3 glossy = disneyMicrofacetAnisotropic(NdotL, NdotV, NdotH, LdotH, wi, wo, H);\n    float clearCoat = disneyClearCoat(NdotL, NdotV, NdotH, LdotH);\n    vec3 sheen = disneySheen(LdotH);\n    \n    return ( mix(diffuse, subSurface, mat.subsurface) + sheen ) * (1. - mat.metallic) + glossy + clearCoat;\n}\n\n///////////////////////////////////////\n// Sample bsdf\n///////////////////////////////////////\nvec3 bsdfSample(\n    out vec3 wi, \n    const in vec3 wo, \n    out float pdf\n) {\n    MaterialInfo mat = GetMat();\n    vec3 f = vec3(0.);\n    pdf = 0.0;\n\twi = vec3(0.);\n    \n    vec2 u = rand2();\n    float rnd = rand();\n\tif( rnd <= 0.3333 ) {\n       disneyDiffuseSample(wi, wo, pdf, u);\n    }\n    else if( rnd >= 0.3333 && rnd < 0.6666 ) {\n       disneyMicrofacetAnisoSample(wi, wo, u);\n    }\n    else {\n       disneyClearCoatSample(wi, wo, u);\n    }\n    f = EvaluateDisneyBSDF(wi, wo);\n    pdf = bsdfPdf(wi, wo);\n    if( pdf < EPS )\n        return vec3(0.);\n\treturn f;\n}\n\n//////////////////////////////////////// \n// Sample Light\n////////////////////////////////////////\nvoid VisbilityTestForLight(out float v, in vec2 t_range) {\n    v = WorldHitTest(t_range.x, t_range.y, true) ? 0. : 1.;\n}\n\nvec3 SampleLightType( \n    const uint lIdx,\n    out vec3 wi\n) {\n    if( !lights[lIdx].enabled )\n        return vec3(0.);\n    float tmax;\n    float visibility;\n    float weight;\n    // 区域灯光采样\n    vec3 emission = AreaLightSample(lIdx, wi, tmax, weight);\n    // From current hit point to the light direction\n    VisbilityTestForLight(visibility, vec2(TMIN, tmax));\n    // Reset ray direction sample from a hemisphere\n    return emission * weight * (visibility);\n}\n\n// 基于出射辐射度的半球积分\n// 使用两点传输模型\nvec3 DirectIllumination(\n    const in uint lIdx, \n    out vec3 wi, \n    out vec3 f, \n    out float scatteringPdf\n) {\n\t\n    // 获取输出方向\n    vec3 wo = -GetRayDirection();\n    vec3 Ld = vec3(0.);\n    scatteringPdf = 0.;\n    bool isBlack = false;\n    // May be multiple shadow ray\n    // From this wi is the light direction\n    vec3 lit = SampleLightType( lIdx, wi );\n    isBlack = dot(lit, lit) == 0.;\n    if (!isBlack ) {\n        vec3 f0 = EvaluateDisneyBSDF(wi, wo) * abs(dot(wi, g_Hit.N));\n        float weight = 1.;\n        \n#ifdef USE_MIS\n        scatteringPdf = bsdfPdf(wi, wo);\n        weight = powerHeuristic(1., lightPdf, 1., scatteringPdf);\n#endif\n            \n\t\tisBlack = dot(f0, f0) == 0.;\n        if (!isBlack) {\n            // The core direct rendering equation\n            Ld += f0 * lit;\n        }\n    }\n   \n#ifdef USE_MIS\n    // TODO: Implement for area light MIS\n#endif\n    return Ld;\n}\n\n// Indirect Illumination\nvec3 IndirectIllumination(\n    out vec3 wi, \n    out vec3 f, \n    out float scatteringPdf\n) {\n    // 间接光照BSDF计算\n    // BSDF MIS\n    vec3 wo = -GetRayDirection();\n    f = bsdfSample( wi, wo, scatteringPdf );\n    // The cosine term\n    f *= abs(dot(wi, g_Hit.N));\n    \n    if( scatteringPdf > EPS && dot(f, f) > EPS)\n        return f / scatteringPdf;\n    return vec3(0.);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 RandomTrace(vec2 pixelCoord) \n{\n    vec3 L = vec3(0.);\n    vec3 beta = vec3(1.);\n    vec3 wi;\n    // Init Scene\n    InitScene();\n    // Init Global Tracing State\n    InitGlobalTracingState();\n    // Cast Ray\n    GetCameraRay(rand2(), pixelCoord, 45., iResolution.xy);\n    \n    // AnimationInit(iTime);\n    for (uint d = 0u; d < MAX_DEPTH; d++) {\n        // Intersection Test\n        if (WorldHitTest(TMIN, TMAX, false)) {\n            \n            // 初始射线到光源，加入光源的强度后，直接终止追踪\n            if (g_Hit.matIdx == LIGHT_MAT) {\n                if( d == 0u )\n                    L += vec3(Le);\n                break;\n            }\n            // Evaluate disney bsdf\n            vec3 X = vec3(0.), Y = vec3(0.);\n            // 求解切线空间坐标，用于各向异性着色\n            directionOfAnisotropicity(g_Hit.N, X, Y);\n            g_Hit.X = X;\n            g_Hit.Y = Y;\n            vec3 f = vec3(0.);\n            float scatteringPdf = 0.;\n            vec3 wi;\n            vec3 Ld = DirectIllumination(0u, wi, f, scatteringPdf);\n            vec3 Li = IndirectIllumination(wi, f, scatteringPdf);\n            SetRay(g_Hit.P, wi);\n            L += beta * Ld;\n            // L = Li;\n            beta *= Li; \n        } else {\n            // 碰撞到背景，采样一张纹理            \n            L += beta * GammaToLinear(texture(iChannel1, GetRayDirection()).rgb) ;//BG Color\n            //L += beta * g_Miss.bgColor;\n            break;\n        }\n        \n    }\n    \n    return L;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( ivec2(fragCoord) == ivec2(0)){\n        fragColor = iResolution.xyxy;\n    } else {\n        vec3 col = vec3(0.);\n        InitGlobalSeed(uvec2(fragCoord), uint(iResolution.x), uint(iFrame));\n        col = RandomTrace(fragCoord);\n        col = clamp(col, vec3(0.), vec3(10.));\n        if(texelFetch(iChannel0,ivec2(0),0).xy == iResolution.xy){\n            fragColor=vec4(col,1)+texelFetch(iChannel0,ivec2(fragCoord),0);\n        }else{\n            fragColor=vec4(col,1);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}