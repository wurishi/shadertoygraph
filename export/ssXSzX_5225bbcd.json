{"ver":"0.1","info":{"id":"ssXSzX","date":"1619486016","viewed":157,"name":"Final Project 561","username":"emma20","description":"final project\n-depth of field\n-ambient occlusion\n-subsurface scattering effect\n-csg operations\n-blinn phong reflection on ladybug\n-smooth blend on ladybug's legs","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from https://www.shadertoy.com/view/XdfGDH\n    const int m = 60;\n    const int k = (m-1)/2;\n    float kernel[m];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 30.0;\n    float Z = 0.0;\n    for (int j = 0; j <= k; ++j) {\n        kernel[k+j] = kernel[k-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < m; ++j) {\n        Z += kernel[j];\n    }\n    \n    //read out the texels\n    for (int i=-k; i <= k; ++i) {\n        for (int j=-k; j <= k; ++j) {\n            final_color += kernel[k+j]*kernel[k+i]*texture(iChannel2, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel2, uv);\n    //fragColor = unblurredColor;\n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a), 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\nconst float AO_DIST = 0.25;\nconst float AO_K = 2.0;\nconst float FOCAL_LENGTH =17.0;\nconst float FOCAL_RANGE = 10.0;\n\n#define LIGHT_POS vec3(-5.0, 10.45, -17.0)\n#define LIGHT_POS2 vec3(-1.0, -5.0, -17.0)\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = .20;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n\nconst float SCALE = 3.0;\n\nconst float AMBIENT = 0.65;\n\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \n/*vec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}*/\n\n\n\n\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thin) {\n\tvec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * SCALE;\n    float attenuation = 1.0;\n   \n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n    return totalLight;\n}\n\n#define leftStem sdRoundCone(opCheapBend(pos, .035), vec3(-1.83, 1.0, -14.5), identity(), .150, .13, 5.0)\n#define backWall plane(pos, vec4(0.0, 0.0, -1.0, 19.0))\n#define leftMush sdRoundCone(pos, vec3(-1.3, 6.2, -11.0), rotateX(-15.0 * (3.14158 / 180.0)) * rotateZ(20.0 * (3.14158 / 180.0)), 1.20, .850, .60)\n#define rightMush sdRoundCone(pos, vec3(-3.0, 5.5, -14.0), rotateX(-12.0 * (3.14158 / 180.0)) * rotateZ(-20.0 * (3.14158 / 180.0)), 1.00, .650, .50)\n\n//rocks\n#define rock sdEllipsoid(pos, vec3(3.70, 0.5, 11.0) + fbmN(pos, 4.0), rotateX(-20.0 * (3.14158 / 180.0)), vec3(6.0, 2.5, 5.0))\n#define rightStem sdRoundCone(opCheapBend(pos, -.02), vec3(-2.0, .6, -11.5), identity(), .150, .13, 6.0)\n#define leftSphere sphere(pos, identity(), 1.9, vec3(3.0, 4.0, 6.0))\n#define subtractBox sdEllipsoid(pos, vec3(1.85, -4.4, 11.9), rotateX(-15.0 * (3.14158 / 180.0)) * rotateZ(20.0 * (3.14158 / 180.0)), vec3(1.61, 2.1, 1.61))\n#define subtractBox2 sdEllipsoid(pos, vec3(2.2, -4.0, 15.0), rotateX(-12.0 * (3.14158 / 180.0)) * rotateZ(-20.0 * (3.14158 / 180.0)), vec3(1.8, 1.9, 1.71))\n\n#define subtractLeftMush opSmoothSubtraction(subtractBox, leftMush,  .25)\n#define subtractRightMush opSmoothSubtraction(subtractBox2, rightMush,  .25)\n\n\n\n//ladybug\n#define ladybugBody sphere(pos, identity(), .75, vec3(-2.5, 3.9, -14.1))\n#define ladyBox box(pos, vec3(-3.3, 3.8, -14.0), rotateZ(-20.0 * (3.14158 / 180.0)), vec3(.7, .9, 1.5))\n#define ladySubtract opIntersection(ladyBox, ladybugBody)\n#define ladybugBody2 sphere(pos, identity(), .75, vec3(-2.5, 3.9, -13.8))\n#define ladyBox2 box(pos, vec3(-3.3, 3.8, -14.0), rotateZ(-20.0 * (3.14158 / 180.0)), vec3(.7, .9, 1.5))\n#define ladySubtract2 opIntersection(ladyBox2, ladybugBody2)\n#define ladyDot sphere(pos, identity(), .1, vec3(-2.5, 3.9, -15.9))\n#define ladyDot2 sphere(pos, identity(), .1, vec3(-2.6, 4.3, -15.9))\n#define ladyHead sdEllipsoid(pos, vec3(2.6, -3.3, 14.1), rotateZ(-60.0 * (3.14158 / 180.0)), vec3(.15, .25, .5))\n#define ladyInt opIntersection(ladyHead, ladySubtract)\n//ladybug legs\n#define ladylegs1 sdRoundCone(pos, vec3(-2.4, 4.3, -16.0), rotateZ(40.0 * (3.14158 / 180.0)), .02, .02, .20)\n#define ladylegs2 sdRoundCone(pos, vec3(-2.1, 3.8, -16.0), rotateZ(-60.0 * (3.14158 / 180.0)), .02, .02, .20)\n#define ladylegs3 sdRoundCone(pos, vec3(-2.1, 4.35, -16.0), rotateZ(-60.0 * (3.14158 / 180.0)), .02, .02, .20)\n#define ladylegs4 sdRoundCone(pos, vec3(-2.1, 3.8, -16.0), rotateZ(40.0 * (3.14158 / 180.0)), .02, .02, .20)\n\n#define smoothlegs1 smin(ladylegs1, ladylegs3, .03)\n#define smoothlegs2 smin(ladylegs2, ladylegs4, .03)\n//background spheres\n#define lightBlueSphere sphere(pos, identity(), 2.1, vec3(3.0 + cos(iTime), 5.0, 6.0))\n#define whiteSphere sphere(pos, identity(), 2.5, vec3(3.0 + sin(iTime) * .5, 5.0, 8.0))\n#define greySphere sphere(pos, identity(), 2.4, vec3(5.5, 1.0 + cos(iTime) * .5, 12.0))\n#define greySphere2 sphere(pos, identity(), 2.8, vec3(5.5, .5 + sin(iTime), 13.0))\n#define greenSphere sphere(pos, identity(), 3.6, vec3(1.0, -4.5, 18.0))\n#define greenSphere2 sphere(pos, identity(), 2.8, vec3(1.5, -3.0, 16.0))\n\n//grass plane\n#define grass1\n//random amount of bend\n//offset the height\n\n\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    \n    eye = vec3(0.0, 5.5, -30.0);\n    ref = vec3(1.0, 2.5, 1.0);\n    \n    float len = tan(.3403392 * 0.75) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\n//https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8/\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n////sdf from https://iquilezles.org/articles/distfunctions -------------------------------\n\nfloat sphere(vec3 p, mat3 transform, float r, vec3 c)\n{\n    p *= transform;\n    c *= transform;\n    return distance(p, c) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 offset, mat3 transform, vec3 r )\n{\n  p = (p + offset) * transform;\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 offset, mat3 transform, vec3 b)\n{\n  p = (p - offset) *transform;\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n//round cone\nfloat sdRoundCone( vec3 p, vec3 offset, mat3 transform, float r1, float r2, float h )\n{\n  p = (p - offset) * transform;\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n//capsule\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n//cylinder\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n//bend for stem\nvec3 opCheapBend(in vec3 p, float k)\n{\n   \n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n} \n\n//smooth blend\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//csg subtractions\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n    \nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n\n\n//functions for noises --------------------------------------------\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n\n\n\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 pow1 = vec3(pow(t2.x, 5.f), pow(t2.y, 5.f), pow(t2.z, 5.f));\n    vec3 pow2 = vec3(pow(t2.x, 4.f), pow(t2.y, 4.f), pow(t2.z, 4.f)); \n    vec3 pow3 = vec3(pow(t2.x, 3.f), pow(t2.y, 3.f), pow(t2.z, 3.f));\n    vec3 t = vec3(1.f) - 6.f * pow1 + 15.f * pow2 - 10.f * pow3;\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\n\nfloat perlinNoise3D(vec3 p) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tfor(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n\t\t\t}\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\nfloat random1( vec3 p ) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\n\nfloat mySmootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\nfloat interpNoise3D1(vec3 p) {\n  vec3 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec3(1.0,0.0,0.0));\n  float ulb = random1(floor(p) + vec3(0.0,1.0,0.0));\n  float urb = random1(floor(p) + vec3(1.0,1.0,0.0));\n\n  float llf = random1(floor(p) + vec3(0.0,0.0,1.0));\n  float lrf = random1(floor(p) + vec3(1.0,0.0,1.0));\n  float ulf = random1(floor(p) + vec3(0.0,1.0,1.0));\n  float urf = random1(floor(p) + vec3(1.0,1.0,1.0));\n\n  float lerpXLB = mySmootherStep(llb, lrb, pFract.x);\n  float lerpXHB = mySmootherStep(ulb, urb, pFract.x);\n  float lerpXLF = mySmootherStep(llf, lrf, pFract.x);\n  float lerpXHF = mySmootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = mySmootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = mySmootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return mySmootherStep(lerpYB, lerpYF, pFract.z);\n}\n\nfloat fbmN(vec3 p, float octaves) {\n  float amp = 0.5;\n  float freq = 2.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += interpNoise3D1(p * freq) * amp;\n    amp *= 0.6;\n    freq *= 1.8;\n  }\n  return (sum / maxSum);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    uv *= 1.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    uv = uv;\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâ€™s Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist + cos(iTime);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n#define leftStemNum 4\n#define backWallNum 0\n#define leftMushNum 1\n#define topWallNum 2\n#define RockNum 3\n#define smallCubeNum 5\n#define largeCubeNum 6\n#define rightStemNum 7\n#define lightBlueSphereNum 8\n#define subtractNum 9\n#define ladyBody 10\n#define whiteSphereNum 11\n#define ladyBoxNum 12\n#define ladyDotNum 13\n#define grey1 14\n#define grey2 15\n#define green1 16\n#define green2 17\n\n\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = backWall;\n    t = min(t, lightBlueSphere);\n    t = min(t, leftStem);\n    t = min(t, rock);\n    t = min(t, rightStem);\n    t = min(t, subtractRightMush);\n    t = min(t, subtractLeftMush);\n    t = min(t, whiteSphere);\n    t = min(t, ladyDot);\n    t = min(t, ladyDot2);\n    t = min(t, ladySubtract2);\n    t = min(t, ladyInt);\n    t = min(t, greySphere);\n    t = min(t, greySphere2);\n    t = min(t, greenSphere);\n    t = min(t, greenSphere2);\n    t = min(t, smoothlegs1);\n    t = min(t, smoothlegs2);\n   // t = min(t, ladylegs3);\n  //  t = min(t, ladylegs4);\n    return t;\n}\n\nfloat AO(vec3 p, vec3 n, float k, vec3 lightPos) {\n    float aoTotal = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        vec3 newPos = p + n * i * AO_DIST;\n        aoTotal += coeff * (i * AO_DIST - sceneMap3D(newPos, lightPos));\n    }\n    return 1.0 - k * aoTotal;\n}\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n   // t = sphere(pos, 4.0, vec3(0.0, 0.0, 0.0));\n    t = backWall;\n    float t2;\n    obj = 0; // 0 is center sphere\n \n    if((t2 = leftStem) < t){\n        t = t2;\n        obj = leftStemNum;\n    } \n    if((t2 = rock) < t)\n    {\n        t = t2;\n        obj = RockNum;\n    }\n   \n     if((t2 = rightStem) < t){\n         t = t2;\n         obj = rightStemNum;\n         \n     }\n     if((t2 = lightBlueSphere) < t){\n         t = t2;\n         obj = lightBlueSphereNum; \n     }\n     if((t2 = subtractRightMush) < t){\n         t = t2;\n         obj = subtractNum;\n     } \n     if((t2 = subtractLeftMush) < t){\n         t = t2;\n         obj = subtractNum; \n     \n     }\n     if((t2 = ladySubtract2) < t){\n         t = t2;\n         obj = ladyBody;\n     \n     } \n    if((t2 = whiteSphere) < t){\n         t = t2;\n         obj = whiteSphereNum;\n     }\n     if((t2 = ladyDot) < t){\n         t = t2;\n         obj = ladyDotNum;\n     \n     } \n      if((t2 = ladyDot2) < t){\n         t = t2;\n         obj = ladyDotNum;\n     \n     } \n     if((t2 = ladyInt) < t){\n         t = t2;\n         obj = ladyDotNum;\n     \n     }\n      if((t2 = smoothlegs1) < t){\n         t = t2;\n         obj = ladyDotNum;\n     \n     }\n     if((t2 = smoothlegs2) < t){\n         t = t2;\n         obj = ladyDotNum;\n     \n     }\n   /*   if((t2 = ladylegs3) < t){\n         t = t2;\n         obj = ladyDotNum;\n     \n     }\n      if((t2 = ladylegs4) < t){\n         t = t2;\n         obj = ladyDotNum;\n     \n     } */\n     if((t2 = greySphere) < t){\n         t = t2;\n         obj = grey1;\n     \n     }\n      if((t2 = greySphere2) < t){\n         t = t2;\n         obj = grey2;\n     \n     }\n      if((t2 = greenSphere) < t){\n         t = t2;\n         obj = green1;\n     \n     }\n      if((t2 = greenSphere2) < t){\n         t = t2;\n         obj = green2;\n     \n     }\n     \n     \n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\n\n\n//noise colors\n//background color\n\nvec3 backgroundColor(vec3 pos){\n    vec3 a = vec3(0.2, 0.6, 0.0);\n    vec3 b = vec3(0.1, 0.5, 0.1);\n    vec3 c = vec3(0.2, 0.1, 0.0);\n    vec3 d = vec3(0.3, 0.4, 0.5);\n    \n    vec3 color = palette(perlinNoise3D(pos/7.0) + (cos(iTime) * .1), a, b, c, d);\n    return color;\n    \n\n}\n\nvec3 rightStemColor(vec3 pos){\n    vec3 a = vec3(.845, .55, .214);\n    vec3 b = vec3(.545, .251, .314);\n    vec3 c = vec3(.845, .651, .214);\n    vec3 d = vec3(.845, .351, .214);\n    \n    vec3 color = palette(perlinNoise3D(pos/10.0), a, b, c, d);\n    return color;\n\n}\n\nvec3 leftStemColor(vec3 pos){\n    vec3 a = vec3(.85, .59, .214);\n    vec3 b = vec3(.545, .251, .314);\n    vec3 c = vec3(.845, .651, .214);\n    vec3 d = vec3(.845, .351, .214);\n    \n    vec3 color = palette(perlinNoise3D(pos/13.0), a, b, c, d);\n    return color;\n\n}\n\n\nvec3 ladyBugColor(vec3 pos){\n    vec3 a = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(1.0, 0.1, 0.1);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    \n    vec3 color = palette(WorleyNoise(vec2(pos.x, pos.y)), a, b, c, d);\n    return color;\n\n\n}\n\nvec3 grassColor(vec3 pos){\n     float t = texture(iChannel3, .2 * pos.yz).x;\n    vec3 color = mix(vec3(.25, .40, 0.1), vec3(.15, .20, 0.0), t);\n\n    return color;\n}\n\nvec3 rockColor(vec3 pos){\n    float t = texture(iChannel2, .5 * pos.zx).x;\n    vec3 color = mix(vec3(.289, 0.261, 0.242), vec3(0.1, 0.1, 0.1), t);\n    return color;\n\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 subLight, vec3 light2, vec3 light, vec3 view, float thin) {\n    float t;\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 newC = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.00, 0.33, 0.67);\n    float lambert = clamp(dot(n, light), 0.0, 1.0) + 0.50;\n    float lambert2 = clamp(dot(n, light), 0.0, 1.0) + 0.2;\n    vec3 avg = light + view;\n    vec3 av = avg / 2.0;\n    float spec = max(pow(dot(normalize(av), normalize(n)), 15.0), 0.0);\n    switch(hitObj) {\n        case 0:\n        return backgroundColor(p) * lambert;\n        break;\n        case topWallNum:\n        return vec3(.80, 0.88, 0.87);\n        break;\n        case RockNum:\n        vec3 color;\n        if(p.y > (.8 + cos(iTime) * .1) && p.z > -15.2){\n        \n           //color = vec3(.25, .40, 0.1) * lambert;\n           color = grassColor(p) * lambert;\n        }\n        else{\n          color = rockColor(p) * (lambert);\n        }\n        return color;\n        break;\n        case leftStemNum:\n        vec3 leftSubLight = vec3(-6.0, -3.0, -13.0);\n        vec3 leftSub = normalize(leftSubLight - p);\n        //vec3 c =  vec3(.645, .251, .214) * lambert; \n        vec3 c =  leftStemColor(p) * lambert; \n        //subLight = \n        c = c + vec3(.500, .37, 0.37) * subsurface(leftSub, n, view, thin);\n        return c;\n        break;\n        case rightStemNum:\n        c = rightStemColor(p) * lambert;\n        c = c + vec3(.80, 0.47, 0.47) * subsurface(subLight, n, view, thin);\n        return c;\n        break;\n        case leftMushNum:\n        color = vec3(.889, 0.861, 0.942) * lambert;\n        //return color;\n        case lightBlueSphereNum:\n        color = vec3(.80, 0.88, 0.87);\n        return color;\n        case subtractNum:\n        float t = texture(iChannel0, .2 * p.yx).x;\n        float t2 = texture(iChannel1, .3 * p.zx).x;\n        color = mix(vec3(.82, 0.761, 0.742), vec3(.79, 0.70, 0.70), t)  * ((lambert));\n        \n        color *= mix(color, vec3(.83, 0.80, 0.80), t2);\n        color += vec3(.40, 0.57, 0.57) * subsurface(subLight, n, view, thin);\n        return color;\n        case ladyBody:\n        color = ladyBugColor(p) * (lambert2 + spec);\n        return color;\n        case whiteSphereNum:\n        color = vec3(1.0, 1.0, 1.0);\n        return color;\n        case ladyDotNum:\n        color = vec3(0.0, 0.0, 0.0) * lambert;\n        return color;\n        case grey1:\n        color = vec3(.7, .7, .7);\n        return color;\n        case grey2:\n        color = vec3(.4, .4, .4);\n        return color;\n        case green1:\n        color = vec3(.5, .5, .3);\n        return color;\n        case green2:\n        color = vec3(.7, .7, .2);\n        return color;\n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    vec3 subsurfaceLight = vec3(-5.0, -5.0, -12.0);\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    vec3 lightDir2 = normalize(LIGHT_POS2 - isect);\n    vec3 subsurfaceLightPos = normalize(subsurfaceLight - isect);\n    float thin = AO(isect, -nor, AO_K, lightPos);\n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, subsurfaceLightPos, lightDir2, lightDir, normalize(eye - isect), thin);\n    float aoComp = AO(isect, nor, AO_K, lightPos);\n    surfaceColor = surfaceColor * aoComp;\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\t//vec3 lightPos = rotateY(vec3(12.0, 4.0, -6.0), sin(iTime) * 0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection isect;\n    vec3 dir, eye, ref;\n    int idx = 0;\n   \n    raycast(uv2, dir, eye, ref);\n    isect = sdf3D(dir, eye, LIGHT_POS);\n     vec3 n = normalize(ref - eye);\n    vec3 view = isect.p - eye;\n    float distAlongCamZ = abs(dot(n, view));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.7);\n    //dofZ = cos(iTime) + dofZ;\n    //vec3 avgColor = vec3(0.0);\n    vec3 avgColor = vec3(0.0);\n    \n    avgColor = isect.color;\n   \n   fragColor = vec4(avgColor, dofZ);\n}","name":"Buffer A","description":"","type":"buffer"}]}