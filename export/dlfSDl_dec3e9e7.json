{"ver":"0.1","info":{"id":"dlfSDl","date":"1675470628","viewed":151,"name":"Roading Screen","username":"jsfehler","description":"Might use something like this for a loading screen.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["road","perspective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float FOV = .2;\n    float SCALE = .2;\n \n    vec2 CAMERA_OFFSET = vec2(1.0, 0.0);\n    \n    float HORIZON = 0.0;\n  \n    vec2 uv = (fragCoord * 4. - iResolution.xy) / min(iResolution.x, iResolution.y) / 4.;\n    \n    if (uv.y < HORIZON) {\n        // Projection \n        vec3 projection = vec3(uv.x, uv.y - HORIZON - FOV, uv.y - HORIZON); \n        vec2 scene = projection.xy / projection.z;   \n\n        // Camera\n        scene *= SCALE;\n        scene += CAMERA_OFFSET;\n        uv=scene;\n  \n        // Coords for road lines\n        vec2 uv2 = uv;\n        \n        // Move road\n        uv2.y += (iTime * 1.8);\n\n        // Define colours\n        vec3 gray = vec3(0.2, 0.2, 0.2);\n        vec3 black = vec3(0.0);\n        vec3 yellow = vec3(1.0, 0.9, 0.4);\n\n        // Calculate the center of the screen\n        vec2 center = vec2(0.5, 0.5);\n\n        // Compute the distance between the fragment coordinate and the center of the screen\n        float d = distance(center + 1.0, uv * 2.5);\n\n        // Vignette for the horizon\n        float pulseHorizon = clamp(sin(iTime), .0, .5);\n        float vignetteHorizon = smoothstep(.4 + pulseHorizon, 2.99, d);\n\n        // Vignette in the center\n        float pulse = clamp(sin(iTime), .0, .5);\n        float vignetteCenter = smoothstep(.4 + pulse, 2.99, d);\n\n        // Mix the gray color with black based on the vignette factor\n        vec3 color = mix(gray, black, vignetteCenter);\n\n        // Draw two solid yellow lines with a specified distance\n        float lineWidth = 0.02;\n        float lineSeparation = 0.02;\n        \n        float leftLineWhite = -0.5 - lineSeparation / 2.0 - lineWidth;\n        float rightLineWhite = 1.5 + lineSeparation / 2.0 - lineWidth;\n        \n        float leftLine = center.x - lineSeparation / 2.0 - lineWidth;\n        float rightLine = center.x + lineSeparation / 2.0 + lineWidth;\n        \n        float lineLength = lineWidth * 20.0;\n        float lineSpace = lineWidth * 20.0;\n\n        // White lines\n        if (abs(uv2.x - leftLineWhite) < lineWidth) {\n            color = mix(vec3(1.0), black, vignetteCenter * 0.8);\n        }\n\n        if (abs(uv2.x - rightLineWhite) < lineWidth) {\n            color = mix(vec3(1.0), black, vignetteCenter * 0.8);\n        }\n\n        // Check if the fragment coordinate is within the left yellow line\n        if (abs(uv2.x - leftLine) < lineWidth) {\n            color = mix(yellow, black, vignetteCenter * 0.8);\n        }\n\n        // Check if the fragment coordinate is within the right yellow line (dashed)\n        float dash = mod((uv2.y - center.y + lineWidth), lineLength + lineSpace);\n        if (abs(uv2.x - rightLine) < lineWidth && dash < lineLength) {\n            color = mix(yellow, black, vignetteCenter * 0.8);\n        }\n\n        vec4 tex0 = texture(iChannel0, uv2);\n\n        color = mix(color, tex0.rrr, 0.12);\n\n        fragColor = vec4(color, 1.0);\n        fragColor -= vignetteHorizon * 0.20;\n   } else\n     {\n     fragColor = vec4(vec3(0.0), 1.0);\n     }  \n}","name":"Image","description":"","type":"image"}]}