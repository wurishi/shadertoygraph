{"ver":"0.1","info":{"id":"ls3fRf","date":"1526125751","viewed":468,"name":"A Real Gyroid","username":"rodolphito","description":"A Gyroid, rendered with a special rendering technique I came up with. Trilinear voxel raytracing!\nMove: WASD (X=down, Space=up, tap Shift=fast)\nCamera: Mouse / Arrow keys.\nAsk any question! :)","likes":33,"published":1,"flags":48,"usePreview":0,"tags":["raytrace","surface","trilinear","gyroid","potential"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2018 rodolphito\n\n// The idea here is to voxel march a potential,\n// sampling only the corners of the voxel at each step,\n// and intersecting a ray against the cubic surface formed by\n// setting the trilinear interpolated values to zero\n\n// This potential rendering technique has a lot of potential\n// It can potentially render any potential you throw at it :)\n\n// This is kind of a runtime equivalent of marching cubes,\n// sort of... not exactly. But it looks similar. Instead of\n// Triangles, its a bunch of small patches of cubic surfaces.\n\nconst int MAX_RAY_STEPS = 100;\nconst float FAR = float(MAX_RAY_STEPS) / sqrt(3.0);\nconst float INVFAR = 1.0/FAR;\n\nfloat getVoxel(vec3 v)\n{\n    v *= atan(1.0) * 0.5;\n    // The Gyroid Potential!\n    return dot(sin(v),cos(v.yzx));\n    // Alternative, showing the cellulose-like structure\n    //return abs(dot(sin(v),cos(v.yzx))) - 1.2;\n}\n\n// Intersect a ray ro + t * rd with a trilinear-cube-potential\n// return smallest positive t.\n// Some very carefully hand-optimized code ahead. Tread lightly...\nfloat rayVsDensity(vec3 ro,vec3 rd,float t,\n\t\t\t\t   float a,float b,float c,float d,\n\t\t\t\t   float e,float f,float g,float h)\n{\n    // Helpers\n    vec3 p = vec3(b,c,e);\n    vec3 q = vec3(d,g,f);\n\tvec3 k = q - p;\n\tfloat i = h - a - k.x - k.y - k.z;\n\tk += a - p.yzx;\n    vec3 m = k*ro.yzx + p - a;\n    vec3 n = k*rd.yzx + i*ro.yzx*rd.zxy;\n\n    // Find cubic coefficients\n    // Look at how symmetric this turns out to be! This is great...\n\tfloat t0 = i*ro.x*ro.y*ro.z + a\n             + dot(m, ro);\n\tfloat t1 = dot(m, rd)\n             + dot(n, ro);\n\tfloat t2 = dot(n, rd);\n\tfloat t3 = i*rd.x*rd.y*rd.z;\n\t\n    // Solve the cubic\n\tvec3 soln = cubic(t3,t2,t1,t0);\n    \n    // Get rid of nasty negatives\n\tsoln = max(soln, miss * step(soln, vec3(t)));\n\t\n    // return the closest hit\n    return min(min(soln.x,soln.y),soln.z);\n}\n\n// Gradient of the trilinear potential\nvec3 getNormal(vec3 p,\n\t\t\t   float a,float b,float c,float d,\n\t\t\t   float e,float f,float g,float h)\n{\n\treturn vec3(\n\t\tmix(mix(b-a,d-c,p.y),mix(f-e,h-g,p.y),p.z),\n\t\tmix(mix(c-a,d-b,p.x),mix(g-e,h-f,p.x),p.z),\n\t\tmix(mix(e-a,f-b,p.x),mix(g-c,h-d,p.x),p.y)\n\t);\n}\n\nvoid mainImage(out vec4 color,vec2 co)\n{\n\tvec4 uv = (vec4(co,iMouse.xy)-0.5*iResolution.xyxy)/iResolution.x;\n    vec4 rot = texelFetch(iChannel0, ROT, 0);\n    vec4 pos = texelFetch(iChannel0, POS, 0);\n    if (length(iMouse.xy) < 10.0)\n    {\n        pos = vec4(4.01,sin(iTime)*4.0+4.0,iTime*5.0,0.0);\n        rot = vec4(-sin(iTime*0.5)*0.6,cos(iTime*0.3)*0.3,0.0,0.0);\n    }\n\tvec3 rd = r(vec3(uv.xy, 0.5), -rot.xy);\n\tvec3 ro = pos.xyz;\n\tvec2 mo = 10.0*uv.zw;\n\trd = normalize(rd);\n\t\n\tvec3 voxel = floor(ro);\n\tvec3 id = 1.0 / rd;\n\tvec3 rs = sign(rd);\n\tvec3 sh = (step(rd,vec3(0.0))-ro)*id;\n\tvec3 sd = (max(rs,0.0) - fract(ro)) * id;\n\tvec3 mk = vec3(0.0);\n\tfloat a,b,c,d,e,f,g,h;\n\tvec3 hit = vec3(0.0);\n\tint i;\n\tfloat t = miss;\n    // Good old voxel traversal\n    // offset by .5 to save some adds\n\tfor (i = 0; i < MAX_RAY_STEPS; i++)\n\t{\n        // using min here because faaast\n\t\tmk = step(sd,min(sd.yzx,sd.zxy)) * rs;\n\t\tsd += mk * id;\n\t\tvoxel += mk;\n\t\tvec2 off = vec2(0.0,1.0);\n        // Update voxel corner values\n\t\ta = getVoxel(voxel+off.xxx);\n\t\tb = getVoxel(voxel+off.yxx);\n\t\tc = getVoxel(voxel+off.xyx);\n\t\td = getVoxel(voxel+off.yyx);\n\t\te = getVoxel(voxel+off.xxy);\n\t\tf = getVoxel(voxel+off.yxy);\n\t\tg = getVoxel(voxel+off.xyy);\n\t\th = getVoxel(voxel+off.yyy);\n\t\tbvec4 q = lessThan(vec4(a,b,c,d), vec4(0.0));\n\t\tbvec4 w = lessThan(vec4(e,f,g,h), vec4(0.0));\n        // Skip if all the corners are empty\n\t\tif (any(q) || any(w))\n\t\t{\n            // Voxel entry point t value\n\t\t\tvec3 vt = voxel*id+sh;\n\t\t\tt = max(max(vt.x, vt.y), vt.z);\n\t\t\tt = rayVsDensity(ro-voxel,rd,t,a,b,c,d,e,f,g,h);\n            // Recalculate hit position\n\t\t\thit = ro+rd*t;\n            // break if the hit is within the voxel\n\t\t\tif (floor(hit) == voxel) break;\n\t\t}\n\t}\n    vec3 col;\n    vec3 fog = vec3(0.7,0.8,0.9);\n    vec3 one = vec3(0.6,0.0,1.4); // 'Outside' color\n    vec3 two = vec3(0.1,0.7,0.1); // 'Inside' color\n    vec3 surf = mix(one,two,step(0.0,getVoxel(ro)));\n    vec3 light = normalize(vec3(0.4,0.2,0.7));\n    vec3 normal = getNormal(hit - voxel,a,b,c,d,e,f,g,h);\n    \n    if (i == MAX_RAY_STEPS) col = fog;\n    else\n    {\n        // Lighting\n        // Normalization is delayed because the normal is actually\n        // the gradient, and that has some other information that\n        // could be exploited to get a face AO effect. (magnitude)\n        normal = normalize(normal);\n        float ndotv = dot(rd,normal);\n        float fresnel = 1.0 - abs(ndotv);\n        // Hacky fresnel (should be pow 5)\n        fresnel *= fresnel; fresnel *= fresnel;\n        // Hacky Lambert-wrapped lighting\n        col = surf * vec3(0.5 + 0.5*dot(normal, light));\n        // Fresnel is fog colored\n        col += fresnel * fog * 0.6;\n        float ff = min(1.0, t*INVFAR);\n        // Pow 8 fog falloff to maximize visibility\n        ff *= ff; ff *= ff; ff *= ff;\n        col = mix(col.rgb,fog,vec3(ff));\n    }\n    // Hacky gamma correction (should be pow .4545)\n    color = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define POS ivec2(0,0)\n#define ROT ivec2(1,0)\n//#define NEWTON_RAPHSON\n\n// The Pi Vector (0,π/2,π,2π)\nvec4 pi = vec4(0,2,4,8)*atan(1.0);\n\n// The Third Vector (0,1/3,2/3,1)\nvec4 it = vec4(0.0,1.0,2.0,3.0)/3.0;\n\n// Very far away\nfloat miss = 9e9;\n\n// Solve a linear equation (Oof, so difficult...)\nfloat linear(float a, float b)\n{\n\treturn -b/a;\n}\n\n// Solve a quadratic (This is a little easier!)\nvec2 quadratic(float a, float b, float c)\n{\n\tfloat d = b*b - 4.0*a*c;\n\tif (d < 0.0) return vec2(miss);\n\td = sqrt(d)*sign(b);\n\tb = -0.5*(b + d);\n\treturn vec2(b/a, c/b);\n}\n\n// Solve a cubic (Piece of cake!)\nvec3 _cubic(float a, float b, float c, float d)\n{\n\t// abs(a) > abs(d) is guaranteed\n    // I could use a little help here...\n    // These constants were chosen by looking at artifacts\n    // and adjusting numbers until most of them were gone.\n    // The gyroid happens to behave nicely, but try any\n    // other potential and you will start seeing missing\n    // 'faces' in many places. I need a robust cubic solver.\n    if (abs(d) < 1e-7) return vec3(quadratic(a, b, c), miss); \n\tif (abs(a) < 0.005) return vec3(quadratic(b, c, d), miss);\n\tfloat tmp = 1.0/a;\n    a = b*tmp*it.y;\n    b = c*tmp;\n    c = d*tmp;\n\tfloat q = a*a - b*it.y;\n\tfloat r = a*a*a - 0.5*(a*b - c);\n\tfloat r2 = r*r;\n    float q3 = q*q*q;\n\tif (r2 < q3)\n\t{\n        vec3 f,f1,f2,t = -2.0*sqrt(q)*cos(acos(r*inversesqrt(q3))*it.y + it.z*pi.xzw) - a;\n        #if defined(NEWTON_RAPHSON)\n        // Newton Raphson\n        f = t*t*t+3.0*a*t*t+b*t+c;\n        f1 = 9.0*t*t+a*t+b;\n        //f2 = 18.0*t+a;\n        t -= f/f1;\n        //t -= (2.0*f*f1)/(2.0*f1*f1-f*f2);\n        #endif\n        return t;\n\t}\n\telse\n\t{\n\t\tfloat e = pow(abs(r) + sqrt(r2-q3), it.y);\n\t\tfloat f,f1,f2,t = -a-(e + q/e)*sign(r);\n        #if defined(NEWTON_RAPHSON)\n        // Newton Raphson, but modified with multiplicity 3\n        f = t*t*t+3.0*a*t*t+b*t+c;\n        f1 = 9.0*t*t+a*t+b;\n        //f2 = 18.0*t+a;\n        t -= 3.0*f/f1;\n        //t -= (2.0*f*f1)/(2.0*f1*f1-f*f2);\n        #endif\n        return vec3(t, miss, miss);\n\t}\n}\n\nvec3 cubic(float a, float b, float c, float d)\n{\n    // Avoid calling cubic with small a\n\tif (abs(a) > abs(d)) return _cubic(a,b,c,d);\n\telse return 1.0/_cubic(d,c,b,a);\n}\n\n// Rotation function\nvec3 r(vec3 v, vec2 r)\n{\n\tvec2 c = cos(r);\n\tvec2 s = sin(r);\n\tfloat ypz = v.y*s.y + v.z*c.y;\n\treturn vec3(v.x*c.x - s.x*ypz,\n\t\t\t\tv.y*c.y - v.z*s.y,\n\t\t\t\tv.x*s.x + c.x*ypz);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Nothing interesting here, move along...\n// Just camera and movement stuff.\n#define MOUSESENS 8.0\n#define SPEED 0.1\n#define BOOST 0.1\n#define KEY_X texture(iChannel1,vec2(88.5/256.0,0.25)).x\n#define SHIFT texture(iChannel1,vec2(16.5/256.0,0.75)).x\n#define SPACE texture(iChannel1,vec2(32.5/256.0,0.25)).x\n\n#define QWERTY\n\n#if defined(QWERTY)\n#define KEY_W texture(iChannel1,vec2(87.5/256.0,0.25)).x\n#define KEY_A texture(iChannel1,vec2(65.5/256.0,0.25)).x\n#define KEY_S texture(iChannel1,vec2(83.5/256.0,0.25)).x\n#define KEY_D texture(iChannel1,vec2(68.5/256.0,0.25)).x\n#define KEYLF texture(iChannel1,vec2(37.5/256.0,0.25)).x\n#define KEYUP texture(iChannel1,vec2(38.5/256.0,0.25)).x\n#define KEYRT texture(iChannel1,vec2(39.5/256.0,0.25)).x\n#define KEYDN texture(iChannel1,vec2(40.5/256.0,0.25)).x\n#else\n#define KEYLF texture(iChannel1,vec2(65.5/256.0,0.25)).x\n#define KEYUP texture(iChannel1,vec2(87.5/256.0,0.25)).x\n#define KEYRT texture(iChannel1,vec2(68.5/256.0,0.25)).x\n#define KEYDN texture(iChannel1,vec2(83.5/256.0,0.25)).x\n#define KEY_W texture(iChannel1,vec2(38.5/256.0,0.25)).x\n#define KEY_A texture(iChannel1,vec2(37.5/256.0,0.25)).x\n#define KEY_S texture(iChannel1,vec2(40.5/256.0,0.25)).x\n#define KEY_D texture(iChannel1,vec2(39.5/256.0,0.25)).x\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    ivec2 texel = ivec2(fragCoord);\n    if (texel != POS && texel != ROT) discard;\n    vec4 rot = texelFetch(iChannel0, ROT, 0);\n    vec4 pos = texelFetch(iChannel0, POS, 0);\n    pos.w = max(step(0.0,iMouse.z) - pos.w,0.0);\n    if (texel == ROT)\n    {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        rot.zw += (mouse - rot.zw) * pos.w;\n        rot.xy += (mouse - rot.zw) * step(0.0,iMouse.w) * MOUSESENS;\n        rot.xy += vec2(KEYRT-KEYLF,KEYUP-KEYDN) * MOUSESENS * 0.003;\n        fragColor = rot;\n    }\n\telse if (texel == POS)\n    {\n        pos.xyz += r(vec3(KEY_D - KEY_A, SPACE - KEY_X, KEY_W - KEY_S),-rot.xy) * (BOOST * SHIFT + SPEED);\n        fragColor = pos;\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}