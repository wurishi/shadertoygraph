{"ver":"0.1","info":{"id":"7l3yzN","date":"1663274167","viewed":112,"name":"Extrusion Moulding Fonts","username":"Reynolds","description":"This is how fonts are made on the computer.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["sdf","extrusion","treadmil"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n//SDFs and functions from iq\n//Physically-based SDF template: https://www.shadertoy.com/view/XlKSDR\n//metal texture from: https://www.shadertoy.com/view/4sycDK\n//font sampling: https://www.shadertoy.com/view/4sVyWh\n\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\n\nvec2 scene2(in vec3 position) {\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(sdSphere(position - vec3(0.0, 0.4, 0.0), 0.4), 12.0)\n    );\n    return scene;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nconst float TEX_BIAS = 127./255.;\n\nvec3 sample_grad_dist(vec2 uv, float font_size) {\n    \n    vec3 grad_dist = (textureLod(iChannel0, uv, 0.).yzw - TEX_BIAS) * font_size;\n\n    grad_dist.y = -grad_dist.y;\n    grad_dist.xy = normalize(grad_dist.xy + 1e-5);\n    \n    return grad_dist;   \n}\n\nvec2 select()\n{\n    return vec2(1.0/16.0, 1.0/16.0) * vec2(int(iTime / 10.0) % 16, int(iTime/10.0) / 16);\n}\n\nvec2 prev() \n{\n    return vec2(1.0/16.0, 1.0/16.0) * vec2((int(iTime / 10.0) -1 + 16) % 16, (int(iTime/10.0) - 1) / 16);\n}\n\nfloat sdShapeTextXY(vec3 p, vec2 letter)\n{\n    float d = sdBox(p, vec3(0.5));\n    d = max(d, sample_grad_dist((p.xy + vec2(0.5)) * vec2(1.0/16.0) + letter, 0.2).z); \n    return d;\n}\n\nfloat sdShapeTextYZ(vec3 p, vec2 letter) \n{\n    float d = sdBox(p, vec3(0.5));\n    d = max(d, sample_grad_dist((p.zy + vec2(0.5)) * vec2(1.0/16.0) + letter, 0.2).z); \n    return d;\n}\n\nfloat sdBoxWithShape2(vec3 p) \n{\n    float d = sdBox(p, vec3(1.0));\n    float box_hole = sdBox(p - vec3(0., 0.8, 0.), vec3(0.5));\n\n    vec2 shapeOffset = select();\n\n    d = max(d, -box_hole);\n    if(abs(p.x) < 0.5 && abs(p.y) < 0.5) \n        d = max(d, -sample_grad_dist((p.xy + vec2(0.5)) * vec2(1.0/16.0) + shapeOffset, 0.2).z);\n    if(abs(p.y) < 0.5 && abs(p.z) < 0.5)\n        d = max(d, -sample_grad_dist((p.zy + vec2(0.5)) * vec2(1.0/16.0) + shapeOffset, 0.2).z);\n    \n    \n    return d;\n}\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{   \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\nvec2 lopendeBand(vec3 p, bool x, float dir) \n{\n    float l = 3.0;\n\n    vec3 longation = x ? vec3(l, 0.0, 0.5) : vec3(0.5, 0.0, l);\n    vec3 size = x ? vec3(0.8, 0.8, 1.0) : vec3(1.0, 0.8, 0.8);\n\n    vec3 q = p;\n    vec4 w = opElongate(q, longation);\n    float d = w.w + sdEllipsoid(w.xyz, size);\n\n    float bSpeed = 100.0;\n\n    d += x ? 0.025*sin(p.x*40.0 + dir*iTime*bSpeed) : 0.025*sin(p.z*40. + dir*iTime*bSpeed); \n    \n    float r = sdBox(p, x ? vec3(l, 1.0, 0.5) : vec3(0.5, 1.0, l));\n    \n    \n    return vec2(max(d, r), d > r ? 26.0 : 20.);\n}\n\nfloat quadratic(float a, float b, float c, float t)\n{\n    return mix(mix(a, b, t), mix(b, c, t), t);\n}\n\nvec2 scene(vec3 p) \n{    \n    vec2 d = vec2(sdBoxWithShape2(p) , 20.0); \n    \n    float dist2box = 1.5;\n    float st = 2.5;\n    \n    vec2 l_z1 = lopendeBand(p - vec3(-dist2box, -2.0, -st), false, 1.0);\n    vec2 l_z2 = lopendeBand(p - vec3(dist2box, -2.0, st), false, -1.0);\n    \n    vec2 l_x1 = lopendeBand(p - vec3(-st, -2.0, dist2box), true, 1.0);\n    vec2 l_x2 = lopendeBand(p - vec3(st, -2.0, -dist2box), true, -1.0);\n   \n    d = opUnion(d, l_z1);\n    d = opUnion(d, l_z2);\n    \n    d = opUnion(d, l_x1);\n    d = opUnion(d, l_x2);\n    \n    \n    float aTime = mod(iTime, 10.0);\n    \n    float endDist = 6.;\n    float endDistDelta = endDist + 1.75;\n    float drop = -0.8;\n    float D = 1.5;\n    \n    vec2 currentLetter = select();\n    vec2 prevLetter = prev();\n    \n    \n    if(aTime < 2.5) {\n        float l_aTime = aTime / 2.5;\n        \n        float blobDist = quadratic(5.0, 5.0, 0.5, l_aTime);//mix(3.0, 0.5, l_aTime);\n        \n        vec2 blob = vec2(sdSphere(p - vec3(0.0, blobDist, 0.0) , 0.4), 5.0);\n        \n        float fallDist = mix(-15.0, -50.0, l_aTime);\n        \n        float fallingPrev= sdShapeTextXY(p - vec3(-endDistDelta, fallDist, D), prevLetter);\n        fallingPrev = min(fallingPrev, sdShapeTextXY(p - vec3(endDistDelta, fallDist, -D), prevLetter));\n     \n        fallingPrev = min(fallingPrev, sdShapeTextYZ(p - vec3(D, fallDist, endDistDelta), prevLetter));\n        fallingPrev = min(fallingPrev, sdShapeTextYZ(p - vec3(-D, fallDist, -endDistDelta), prevLetter));\n        \n        \n        d = opUnion(d, vec2(fallingPrev, 5.0));\n        \n        d = opUnion(d, blob);\n    } else if(aTime < 5.0) {\n        float l_aTime = (aTime - 2.5) / 2.5;\n        float e_aTime = (aTime - 4.0);\n        float e2_aTime = (aTime - 3.0);\n    \n        vec2 stamper = vec2(sdBox(p - mix(vec3(0.0, 5.0, 0.0), vec3(0.0), l_aTime), vec3(0.5, 1.0, 0.5)), 20.0); \n        \n        float blob = sdSphere(p - vec3(0., 0.5, 0.0), 0.4);\n        \n        float extrDist = mix(0.0, D, smoothstep(0., 1., e_aTime));\n        \n        float shapes = sdShapeTextXY(p - vec3(0.0, 0.0, extrDist), currentLetter);\n        shapes = min(shapes, sdShapeTextXY(p - vec3(0.0, 0.0, -extrDist), currentLetter));\n        \n        shapes = min(shapes, sdShapeTextYZ(p - vec3(extrDist, 0.0, 0.0), currentLetter));\n        shapes = min(shapes, sdShapeTextYZ(p - vec3(-extrDist, 0.0, 0.0), currentLetter));\n        \n        \n        vec2 extrusion = vec2(mix(blob, shapes, smoothstep(0., 1.0, e2_aTime)), 5.0);\n\n        \n        d = opUnion(d, stamper);\n        d = opUnion(d, extrusion);\n        d = opUnion(d, vec2(blob, 5.0));\n        \n    } else if(aTime < 5.5) {\n        float l_aTime = (aTime - 5.) / 0.5;    \n    \n        vec2 stamper = vec2(sdBox(p, vec3(0.5, 1.0, 0.5)), 20.0); \n        \n        float fallDist = mix(0.0, drop, l_aTime);\n        \n        float d1 = sdShapeTextXY(p - vec3(0., fallDist, D), currentLetter);\n        d1 = min(d1, sdShapeTextXY(p - vec3(0., fallDist, -D), currentLetter));\n        \n        d1 = min(d1, sdShapeTextYZ(p - vec3(D, fallDist, .0), currentLetter));\n        d1 = min(d1, sdShapeTextYZ(p - vec3(-D, fallDist, .0), currentLetter));\n        vec2 shapes = vec2(d1, 5.0);\n        \n        d = opUnion(d, stamper);\n        d = opUnion(d, shapes);\n    } else \n    if(aTime < 8.0) {\n        float l_aTime = (aTime - 5.5) / 2.5;\n        vec2 stamper = vec2(sdBox(p - mix(vec3(0.0), vec3(0.0, 5.0, 0.0), l_aTime), vec3(0.5, 1.0, 0.5)), 20.0); \n        \n        float travel = mix(0.0, endDist, l_aTime);\n        \n        float d1 = sdShapeTextXY(p - vec3(-travel, drop, D), currentLetter);\n        d1 = min(d1, sdShapeTextXY(p - vec3(travel, drop, -D), currentLetter));\n        \n        d1 = min(d1, sdShapeTextYZ(p - vec3(D, drop, travel), currentLetter));\n        d1 = min(d1, sdShapeTextYZ(p - vec3(-D, drop, -travel), currentLetter));\n        \n        vec2 shapes = vec2(d1, 5.0);\n        \n        d = opUnion(d, stamper);\n        d = opUnion(d, shapes);\n    } \n    else {\n        float l_aTime = (aTime - 8.0) / 2.0;\n        \n        float woop = quadratic(endDist, endDistDelta, endDistDelta, l_aTime);\n        float fallDist = quadratic(drop, drop, -15.0, l_aTime);\n        \n        float d1 = sdShapeTextXY(p - vec3(-woop, fallDist, D), currentLetter);\n        d1 = min(d1, sdShapeTextXY(p - vec3(woop,  fallDist, -D), currentLetter));\n     \n        d1 = min(d1, sdShapeTextYZ(p - vec3(D, fallDist, woop), currentLetter));\n        d1 = min(d1, sdShapeTextYZ(p - vec3(-D,  fallDist, -woop), currentLetter));\n\n        \n        vec2 shapes = vec2(d1, 5.0);\n        \n        d = opUnion(d, shapes);\n    }\n    \n\n    return d; \n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 30.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 30.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n                    \nvec3 tex(vec3 p) {\n    vec3 ta = texture(iChannel1, p.yz/10.0).xyz;\n    vec3 tb = texture(iChannel1, p.xz/10.0).xyz;\n    vec3 tc = texture(iChannel1, p.xy/10.0).xyz;\n    return (ta * ta + tb * tb + tc * tc) / 3.0;\n}\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n// Sky gradient\nvec3 sky = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n    \n    vec3 color = sky;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        if (material < 4.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            // Metallic objects\n            baseColor = vec3(0.3, 0.0, 0.0);\n            roughness = 0.2;\n        } else if(material < 21.0) {\n            baseColor = tex(position);\n            roughness = 0.8;\n        } else if(material < 32.0) {\n            baseColor = vec3(0.1, 0.1, .05);\n            roughness = 1.0;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n        \n        float dCentre = length(position);\n        // Exponential distance fog\n        color = mix(color, 0.8 * sky, 1.0 - exp2(-0.011 * dCentre * dCentre));\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(8.0, 6.0, 8.0);\n    vec3 target = vec3(0.0, -3.5, 0.0);\n\n    origin.x = cos(iTime/10.0)*8.0;\n    origin.z = sin(iTime/10.0)*8.0;\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float d;\n    vec3 color = render(origin, direction, d);\n\n    // Tone mapping\n    color = Tonemap_ACES(color);\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}