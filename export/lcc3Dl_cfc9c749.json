{"ver":"0.1","info":{"id":"lcc3Dl","date":"1712245778","viewed":60,"name":"2-Edge Wang Tiling","username":"ishani","description":"https://tinyurl.com/cr31-wang\nhttps://tinyurl.com/stanford-wang-pdf\n\nstripped down implementation of Wang tiling for 2-edge input; example tile map generated dynamically","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["procedural","tiling","wang"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// original https://www.shadertoy.com/view/3tB3zm by postrediori\n//\n\n#define SCROLL_IT   0\n#define ANIMATE_IT  0\n\n#define LARGE_ZOOM  9.\n#define SMALL_ZOOM  33.0\n\n// ----------------------------------------------------------------------------------------------------------------------------------------\n\n// from Hash without Sine (Dave Hoskins); https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy)\n    \n#if ANIMATE_IT\n        * (0.5 + ((1.0 + sin(iTime * 0.9)) * 4.0));\n#endif \n   \n    ;\n}\n\n\n// compute deterministic edge indices for the current tile\nvec4 TileMap(vec2 xy)\n{\n    vec2 TopLeft   = hash22(xy);\n    vec2 TileRight = hash22(xy + vec2(1.0, 0.0));\n    vec2 TileBelow = hash22(xy + vec2(0.0, 1.0));\n    \n    return vec4(\n            TopLeft.y,    // Top\n            TileRight.x,  // Right\n            TileBelow.y,  // Bottom\n            TopLeft.x     // Left\n            ); \n}\n\n\n\n// precomputed to avoid bothering with going via ivec2\nconst float EdgesToPosMod4[16] = float[16](0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 3.0, 3.0, 2.0, 2.0, 3.0, 3.0, 2.0, 2.0);\nconst float EdgesToPosDiv4[16] = float[16](3.0, 2.0, 3.0, 2.0, 0.0, 1.0, 0.0, 1.0, 3.0, 2.0, 3.0, 2.0, 0.0, 1.0, 0.0, 1.0);\n\n// cells that support being flipped in X or Y\nconst float CellsCanFlipX[16]  = float[16](1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0);\nconst float CellsCanFlipY[16]  = float[16](1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0);\n\n\n// enable to run a second hash and flip x/y cells\n#define SUPPORT_FLIP_SCRAMBLE 0\n\n#if SUPPORT_FLIP_SCRAMBLE\n#define EdgeType vec4\n#else\n#define EdgeType vec2\n#endif // SUPPORT_FLIP_SCRAMBLE\n\n\n// get tile index by edge flags\nEdgeType EdgeTile(vec4 e)\n{\n    int tile = (e.x > .5 ? 1 : 0) +\n               (e.y > .5 ? 2 : 0) +\n               (e.z > .5 ? 4 : 0) +\n               (e.w > .5 ? 8 : 0);\n        \n    return EdgeType(\n        EdgesToPosMod4[tile]\n      , EdgesToPosDiv4[tile]\n#if SUPPORT_FLIP_SCRAMBLE\n      , CellsCanFlipX[tile]\n      , CellsCanFlipY[tile]\n#endif // SUPPORT_FLIP_SCRAMBLE\n        );\n}\n\n\n// ----------------------------------------------------------------------------------------------------------------------------------------\n\nvec3 wangTexture( in vec2 uv, float tileScale )\n{\n    vec2 tileuv = fract(uv * tileScale);\n    \n    // Coordinate of the tile\n    vec2 tileIdxf = uv * tileScale - tileuv;\n    \n    // Get texture coordinate of a tile\n    vec4 edges = TileMap(tileIdxf);\n    EdgeType tile = EdgeTile(edges);\n    \n    \n#if SUPPORT_FLIP_SCRAMBLE\n    // little test of flipping certain tiles based on a secondary hash pass\n    // if the tile edges are compatible with such follies\n    {\n        vec2 scrambler = round( hash22(edges.yx) );\n    \n        tileuv.x = mix( tileuv.x, 1.0 - tileuv.x, scrambler.x * tile.z );\n        tileuv.y = mix( tileuv.y, 1.0 - tileuv.y, scrambler.y * tile.w );\n    }\n#endif // SUPPORT_FLIP_SCRAMBLE\n\n    \n    vec2 inputTileUV = ( tile.xy + tileuv ) * 0.25;\n    inputTileUV.y = 1.0 - inputTileUV.y;\n    \n    // quote\n    // Notice the use of ddx and ddy in the last tex2D() call.\n    // This is necessary to avoid spuriously large texture coordinate\n    // derivatives near tile boundaries which can cause low resolu-\n    // tion mipmap levels to be accessed and produce over-blurry\n    // results.\n    vec2 tileScaledTex = uv * vec2( tileScale * 0.25, tileScale * 0.25 );\n    \n    vec3 tileTexture = textureGrad(\n        iChannel0,\n        inputTileUV,\n        dFdx(tileScaledTex),\n        dFdy(tileScaledTex)\n        ).xyz;\n            \n    return tileTexture;\n}\n\n\n// ========================================================================================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float divideLine = iResolution.x * 0.5;\n    vec4 divideColour = vec4(0.465, 0.716, 0.561,1.) * 0.15;\n    \n    vec2 uv = fragCoord/iResolution.y;\n#if SCROLL_IT    \n    uv.x += iTime * 0.2;\n    uv.y += iTime * 0.03;\n#endif\n        \n    // produce the tiling for this coordinate\n    fragColor = vec4( wangTexture( \n        uv, \n        (fragCoord.x > divideLine) ? SMALL_ZOOM : LARGE_ZOOM\n        ), 1.0 );\n        \n    // draw a quick divider line\n    fragColor = mix( fragColor, divideColour, smoothstep( 1.0, 0.0, abs( divideLine - fragCoord.x ) ) );\n    \n    // show tile outlines on one side\n    // nabbed from ollj\n    float gridLineThickness = LARGE_ZOOM * 2.2 / iResolution.y;\n\tfragColor = mix(\n        fragColor,\n        divideColour,\n        smoothstep(1.-gridLineThickness,1.,grid(uv * LARGE_ZOOM)) * clamp(divideLine - fragCoord.x, 0.0, 1.0) * 0.5\n        );\n        \n    // fragColor = texture( iChannel0, fragCoord/iResolution.y );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// dynamically build the source tile image\n// eg. https://github.com/Scrawk/AperiodicTexturing/blob/master/Media/SolidColorTile2x2_256.png\n\n// add a thin grid to the 4x4 cells\n#define ADD_SOURCE_GRID       0\n// add some notion of direction to each cell to debug flipping\n#define ADD_DIRECTION_ARROWS  0\n// make it curvy!\n#define ADD_CURVES            0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float tinyEdge = fwidth(max(uv.x, uv.y));\n    \n#if ADD_CURVES\n    tinyEdge *= 12.0;\n#else\n    tinyEdge *= 1.5;\n#endif // ADD_CURVES\n    \n    \n    uv.y = 1.0 - uv.y;\n    \n    vec2 rhombSize1 = vec2(0.125, 0.125) - vec2( tinyEdge * 0.5 );\n    vec2 rhombSize2 = rhombSize1 * 2.0;\n\n    float x =       smoothstep( 0.0, tinyEdge, sdRhombus( uv - vec2(0.125, 0.25),  rhombSize1 ) );\n    x = opUnion( x, smoothstep( 0.0, tinyEdge, sdRhombus( uv - vec2(0.125, 0.5),   rhombSize1 ) ) );\n    x = opUnion( x, smoothstep( 0.0, tinyEdge, sdRhombus( uv - vec2(0.5,   0.875), rhombSize1 ) ) );\n    x = opUnion( x, smoothstep( 0.0, tinyEdge, sdRhombus( uv - vec2(0.75,  0.875), rhombSize1 ) ) );\n\n    x = opUnion( x, smoothstep( 0.0, tinyEdge, sdRhombus( uv - vec2(0.5,   0.25),  rhombSize2 ) ) );\n    x = opUnion( x, smoothstep( 0.0, tinyEdge, sdRhombus( uv - vec2(0.75,  0.25),  rhombSize2 ) ) );\n    x = opUnion( x, smoothstep( 0.0, tinyEdge, sdRhombus( uv - vec2(0.5,   0.5),   rhombSize2 ) ) );\n    x = opUnion( x, smoothstep( 0.0, tinyEdge, sdRhombus( uv - vec2(0.75,  0.5),   rhombSize2 ) ) );\n\n\n    // super goofy and specific adjustments to add curves over the top of the pattern\n    // resulting tiling has a 70s wallpaper vibe to it\n#if ADD_CURVES\n\n    vec2 cellScaleUV = uv * 4.0;\n    vec2 cellUV = fract(cellScaleUV);\n    ivec2 cellIndex = ivec2( cellScaleUV - cellUV );\n    \n    // end points\n    float parabolaT = 3.4 - tinyEdge;\n    if ( cellIndex.x == 0 && cellIndex.y == 0 )\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdParabola( cellUV - vec2(0.5, 0.15), parabolaT ) ) );\n    if ( cellIndex.x == 1 && cellIndex.y == 3 )\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdParabola( cellUV.yx - vec2(0.5, 0.15), parabolaT ) ) );\n    if ( cellIndex.x == 0 && cellIndex.y == 2 )\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdParabola( cellUV - vec2(0.5, 0.85), -parabolaT ) ) );\n    if ( cellIndex.x == 3 && cellIndex.y == 3 )\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdParabola( cellUV.yx - vec2(0.5, 0.85), -parabolaT ) ) );\n\n    // larger corners\n    if ( cellIndex.x == 1 && cellIndex.y == 0 )\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdCircle( cellUV - vec2(1.0, 1.0), 1.0 - tinyEdge ) ) );\n    if ( cellIndex.x == 3 && cellIndex.y == 0 )\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdCircle( cellUV - vec2(0.0, 1.0), 1.0 - tinyEdge ) ) );\n    if ( cellIndex.x == 1 && cellIndex.y == 2 )\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdCircle( cellUV - vec2(1.0, 0.0), 1.0 - tinyEdge ) ) );\n    if ( cellIndex.x == 3 && cellIndex.y == 2 )\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdCircle( cellUV - vec2(0.0, 0.0), 1.0 - tinyEdge ) ) );\n\n    // larger indents\n    if ( cellIndex.x == 2 && cellIndex.y == 0 )\n        x = opSubtraction( x, 1.0 - smoothstep( 0.0, tinyEdge, sdCircle( cellUV - vec2(0.5, 0.0), 0.5 - tinyEdge ) ) );\n    if ( cellIndex.x == 1 && cellIndex.y == 1 )\n        x = opSubtraction( x, 1.0 - smoothstep( 0.0, tinyEdge, sdCircle( cellUV - vec2(0.0, 0.5), 0.5 - tinyEdge ) ) );\n    if ( cellIndex.x == 3 && cellIndex.y == 1 )\n        x = opSubtraction( x, 1.0 - smoothstep( 0.0, tinyEdge, sdCircle( cellUV - vec2(1.0, 0.5), 0.5 - tinyEdge ) ) );\n    if ( cellIndex.x == 2 && cellIndex.y == 2 )\n        x = opSubtraction( x, 1.0 - smoothstep( 0.0, tinyEdge, sdCircle( cellUV - vec2(0.5, 1.0), 0.5 - tinyEdge ) ) );\n\n    // kites\n    if ( cellIndex.x == 0 && cellIndex.y == 1 )\n    {\n        float slice1 = sdCircle( cellUV - vec2(1.0, 0.5), 0.5 - tinyEdge );\n        float slice2 = sdCircle( cellUV - vec2(0.0, 0.5), 0.5 - tinyEdge );\n        float slice  = opUnion( slice1, slice2 );\n        \n        x = opSubtraction( x, 1.0 - smoothstep( 0.0, tinyEdge, slice ) );\n    }\n    if ( cellIndex.x == 2 && cellIndex.y == 3 )\n    {\n        float slice1 = sdCircle( cellUV.yx - vec2(1.0, 0.5), 0.5 - tinyEdge );\n        float slice2 = sdCircle( cellUV.yx - vec2(0.0, 0.5), 0.5 - tinyEdge );\n        float slice  = opUnion( slice1, slice2 );\n        \n        x = opSubtraction( x, 1.0 - smoothstep( 0.0, tinyEdge, slice ) );\n    }\n#endif // ADD_CURVES    \n\n\n    fragColor = mix( vec4(0.165, 0.616, 0.561,1.), vec4(0.149, 0.275, 0.325,1.), x );\n\n\n#if ADD_DIRECTION_ARROWS\n    x = 1.;\n\n    float offset = 0.125;\n    for ( int f=0; f<4; f++ )\n    {\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdEquilateralTriangle( uv - vec2(0.125,  offset),  0.05f ) ) );\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdEquilateralTriangle( uv - vec2(0.375,  offset),  0.05f ) ) );\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdEquilateralTriangle( uv - vec2(0.625,  offset),  0.05f ) ) );\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdEquilateralTriangle( uv - vec2(0.875,  offset),  0.05f ) ) );\n\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdEquilateralTriangle( uv.yx - vec2(offset, 0.2 ),  0.02f ) ) );\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdEquilateralTriangle( uv.yx - vec2(offset, 0.45),  0.02f ) ) );\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdEquilateralTriangle( uv.yx - vec2(offset, 0.7 ),  0.02f ) ) );\n        x = opUnion( x, smoothstep( 0.0, tinyEdge, sdEquilateralTriangle( uv.yx - vec2(offset, 0.95),  0.02f ) ) );\n\n        offset += 0.25;\n    }\n    fragColor = mix( fragColor, vec4(1.) - fragColor, 1.0 - x );\n#endif // ADD_DIRECTION_ARROWS\n\n\n#if ADD_SOURCE_GRID\n    float gridLineThickness = 4. * 2.2 / iResolution.y;\n\tfragColor = mix(\n        fragColor,\n        vec4(0),\n        smoothstep(1.-gridLineThickness,1.,grid(uv * 4.))\n        );\n#endif // ADD_SOURCE_GRID\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// SDF bits from iq (https://iquilezles.org/articles/distfunctions/)\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdParabola( in vec2 pos, in float k )\n{\n    pos.x = abs(pos.x);\n    float ik = 1.0/k;\n    float p = ik*(pos.y - 0.5*ik)/3.0;\n    float q = 0.25*ik*ik*pos.x;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r,q)/3.0)*sqrt(p);\n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\nfloat opXor(float d1, float d2 )\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\n// https://www.shadertoy.com/view/llsfzr\nfloat miv(vec2 a){return min(a.y,a.x);}//return max domain of vector.\nfloat miv(vec3 a){return min(a.z,miv(a.xy));}\nfloat miv(vec4 a){return min(miv(a.zw),miv(a.xy));}\n#define mav(a) -miv(-a)\n#define grid(u) mav(abs(fract(u)*2.-1.))","name":"Common","description":"","type":"common"}]}