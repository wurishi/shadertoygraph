{"ver":"0.1","info":{"id":"tlSBDw","date":"1599194341","viewed":575,"name":"Cosine color palette generator","username":"tauame","description":"Customizable cosine color palette (see code header comment for usage)\n\na, b, c and d values shown on screen are used on this function to generate the color values:\nf(x) = a + b * cos(TAU*(c*x + d));\n\nbased on https://www.shadertoy.com/view/ll2GD3\n","likes":26,"published":1,"flags":48,"usePreview":0,"tags":["palette","picker","gui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nCustomizable cosine color palette\n\nPress the R, G, B, T, H and N keys on your keyboard while dragging with the mouse to change the shape of the cosine function;\n\n\nUsage:\n\n \nHold R or G or B keys while moving the mouse along the X axis: \n  change the corresponding color wave offset on the Y axist (a paramenter)\n\nHold R or G or B keys while moving the mouse along the Y axis: \n  scale the corresponding color wave on the Y axis (b parameter)\n\nHold T or H or N keys while moving the mouse along the Y axis: \n  change the corresponding color wave frequency from 0. up to 3. (c parameter)\n\nHold T or H or N keys while moving the mouse along the X axis: \n  change the phase of the corresponding color wave  (d parameter)\n\n\n\nYou only fully control the first row. Rows 2 through 7 are random variations \nof the first row by changing the 'd' parameter of the palette function.\nAlso, you can change which keys control each color by changing the define \nkeyvalues in the \"Common\" tab. I choose RGBTHN for my own confort.\n\nBased on https://www.shadertoy.com/view/ll2GD3\n\n*/\n\n\n\n//cosine color pallete from https://iquilezles.org/articles/palettes\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d){\n\n\treturn a + b * cos(TAU*(c*t + d));\n    \n}\n\n\n//from https://www.shadertoy.com/view/llySRh\n#define TEXTCHANNEL iChannel1\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc fragColor+= char(U,64+CAPS+c);\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( TEXTCHANNEL, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n}\n\n// --- display int3\n\nvec4 pInt(vec2 p, float n, float size) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = size-1.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// --- display float1.3\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n),1.); p.x -= .5;\n    v += char(p, 46);      p.x -= .5;\n    v += pInt(p,fract(n)*1e3,3.);\n    return v;\n}\n\n\n\n//from https://www.shadertoy.com/view/Ms2SD1\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec2 U;\n\n    \n   \n    \n    uv.y*=7.;\n    uv+=1.;\n    \n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n\n\n    //float seed = noise(vec2(iTime)*.01);\n    float seed = iTime*.03;\n\n\n    vec3 col;\n\n    \n    \n    \n    vec3 a = texelFetch(iChannel0,ivec2(1),0).rgb;\n    \n    vec3 b = texelFetch(iChannel0,ivec2(2),0).rgb;\n    vec3 c = texelFetch(iChannel0,ivec2(3),0).rgb;\n    vec3 d;\n    if(i_uv.y<=6.)\n    \t//d = vec3(noise(i_uv*seed*.8),noise(i_uv*seed*1.3),noise(i_uv.yx*seed));\n        d = texelFetch(iChannel0,ivec2(4),0).rgb+mod(vec3(i_uv.y*seed*.2,i_uv.y*seed*.3,i_uv.y*seed*.5),vec3(2.))-1.;\n    else\n    \td = texelFetch(iChannel0,ivec2(4),0).rgb;\n    \n    \n    if(f_uv.x>textBorder){\n        \n        //print color palette\n        \n\n        float t = (f_uv.x-textBorder)/(1.-textBorder);\n\n        col = palette(t,a,b,c,d);\n        \n        // shadowing\n        col *= 1. + 0.05*log(4.0*f_uv.y*(1.0-f_uv.y));\n        \n        // dithering\n        col += (5.0/255.0)*texture( iChannel2, fragCoord.xy/iChannelResolution[2].xy ).xyz;\n        \n        \n      \n    }else if(f_uv.x > waveBorder){\n    \n        //print a,b,c and d values as text\n        \n         U = ( f_uv - vec2(waveBorder-0.005,.7) ) * vec2(64.,5.);  low C(1)caps C(-6)  // \"a:\"\n         U = ( f_uv - vec2(waveBorder+0.020,.7) ) * vec2(70.,5.);        \n         col += pFloat(U, a.r).xxx;  U.x -= 2.; caps C(-20) U.x-=0.5;\n         \n         col += pFloat(U, a.g).xxx;  U.x -= 2.; caps C(-20) U.x-=0.5;\n         col += pFloat(U, a.b).xxx;  \n             \n             \n         U = ( f_uv - vec2(waveBorder-0.005,.5) ) * vec2(64.,5.);  low C(2)caps C(-6)  // \"b:\"\n         U = ( f_uv - vec2(waveBorder+0.020,.5) ) * vec2(70.,5.);        \n         col += pFloat(U, b.r).xxx;  U.x -= 2.; caps C(-20) U.x-=0.5;\n         \n         col += pFloat(U, b.g).xxx;  U.x -= 2.; caps C(-20) U.x-=0.5;\n         col += pFloat(U, b.b).xxx;      \n             \n             \n         U = ( f_uv - vec2(waveBorder-0.005,.3) ) * vec2(64.,5.);  low C(3)caps C(-6)  // \"c:\"\n         U = ( f_uv - vec2(waveBorder+0.020,.3) ) * vec2(70.,5.);        \n         col += pFloat(U, c.r).xxx;  U.x -= 2.; caps C(-20) U.x-=0.5;\n         \n         col += pFloat(U, c.g).xxx;  U.x -= 2.; caps C(-20) U.x-=0.5;\n         col += pFloat(U, c.b).xxx;      \n             \n             \n         U = ( f_uv - vec2(waveBorder-0.005,.1) ) * vec2(64.,5.);  low C(4)caps C(-6)  // \"d:\"\n         U = ( f_uv - vec2(waveBorder+0.020,.1) ) * vec2(70.,5.);        \n         col += pFloat(U, d.r).xxx;  U.x -= 2.; caps C(-20) U.x-=0.5;\n         \n         col += pFloat(U, d.g).xxx;  U.x -= 2.; caps C(-20) U.x-=0.5;\n         col += pFloat(U, d.b).xxx;  \n             \n         col += draw_char().xxx;\n    \t\n        \n    }else{\n    \n        //plot palette waves on the left\n        \n        float thickness = 1.5/iResolution.y/waveBorder;\n        \n        \n        float t = (f_uv.x)/(waveBorder);\n        \n        col = palette(t,a,b,c,d);\n        \n        col = smoothstep(col-thickness, col ,vec3(f_uv.y)) - smoothstep(col, col +thickness,vec3(f_uv.y));\n        \n        //add grey background\n        col = mix(vec3(0.1),col,col);\n        \n        \n        \n        \n    }\n    \n    if(step(0.015, f_uv.y) == 0.)\n        col = vec3(0.2);\n    \n    //print to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    m.x = (max(m.x-textBorder,0.))/(1.-textBorder);\n        \n    vec3 oldA;\n    vec3 oldB;\n    vec3 oldC;\n    vec3 oldD;\n    \n    \n    if(iFrame==0){ \n        oldA = vec3(0.5);\n        oldB = vec3(0.5);\n        oldC = vec3(1.);\n        oldD = vec3(0.5);\n    }else{\n    \toldA=texelFetch(iChannel1,ivec2(1),0).rgb;\n    \toldB=texelFetch(iChannel1,ivec2(2),0).rgb;\n        oldC=texelFetch(iChannel1,ivec2(3),0).rgb;\n    \toldD=texelFetch(iChannel1,ivec2(4),0).rgb;\n    }\n    \n    \n    vec3 inpAB=vec3(0.);\n    vec3 inpCD=vec3(0.);\n    inpAB.r = texelFetch(iChannel0, ivec2(KEY_abR, 0), 0).x;\n    inpAB.g = texelFetch(iChannel0, ivec2(KEY_abG, 0), 0).x;\n    inpAB.b = texelFetch(iChannel0, ivec2(KEY_abB, 0), 0).x;\n    \n    inpCD.r = texelFetch(iChannel0, ivec2(KEY_cdR, 0), 0).x;\n    inpCD.g = texelFetch(iChannel0, ivec2(KEY_cdG, 0), 0).x;\n    inpCD.b = texelFetch(iChannel0, ivec2(KEY_cdB, 0), 0).x;\n    \n    \n    oldA.r = inpAB.r > 0.5 ? m.x : oldA.r;\n    oldB.r = inpAB.r > 0.5 ? m.y : oldB.r;\n    \n    oldA.g = inpAB.g > 0.5 ? m.x : oldA.g;\n    oldB.g = inpAB.g > 0.5 ? m.y : oldB.g;\n    \n    oldA.b = inpAB.b > 0.5 ? m.x : oldA.b;\n    oldB.b = inpAB.b > 0.5 ? m.y : oldB.b;\n\n    \n    oldC.r = inpCD.r > 0.5 ? m.y*3. : oldC.r;\n    oldD.r = inpCD.r > 0.5 ? m.x : oldD.r;\n    \n    oldC.g = inpCD.g > 0.5 ? m.y*3. : oldC.g;\n    oldD.g = inpCD.g > 0.5 ? m.x : oldD.g;\n    \n    oldC.b = inpCD.b > 0.5 ? m.y*3. : oldC.b;\n    oldD.b = inpCD.b > 0.5 ? m.x : oldD.b;\n    \n    \n    if(fragCoord == vec2(1.5))\n\t    fragColor = vec4(oldA,1.0);\n    \n    else if(fragCoord == vec2(2.5))\n        fragColor = vec4(oldB,1.0);\n        \n    else if(fragCoord == vec2(3.5))\n        fragColor = vec4(oldC,1.0);\n        \n    else if(fragCoord == vec2(4.5))\n        fragColor = vec4(oldD,1.0);\n    \n        \n    //store currentresolution (to check if entered or exited fullscreen)\n    //not in use at the moment\n    if (fragCoord == vec2(5.5) )\n        fragColor.xy =  iResolution.xy;\n        \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265\n#define TAU 6.28318531\n\n\n#define KEY_abR 82  /*R*/\n#define KEY_abG 71  /*G*/\n#define KEY_abB 66  /*B*/\n\n#define KEY_cdR 84  /*T*/\n#define KEY_cdG 72  /*H*/\n#define KEY_cdB 78  /*N*/\n\n\nfloat waveBorder = 0.15;\nfloat textBorder = 0.3;\n\n\n","name":"Common","description":"","type":"common"}]}