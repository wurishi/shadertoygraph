{"ver":"0.1","info":{"id":"NtjBW1","date":"1652144017","viewed":116,"name":"bubbly display","username":"saidwho12","description":"Came across a video recently about 7-segment displays which really made me want to try and make virtual clocks for each of these shapes. The video in question is [url=https://youtu.be/RTB5XhjbgZA]Segmented Displays[/url] and shows a variety of designs.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","time","sdf","clock","display","segment","seven","segmented"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEBUG_ANGLE_CONSTRUCT 0\n#define DEBUG_MODE 0\n#define MAX_DISTANCE 1000.\n#define ALTERNATE_STYLE 1\n\n\nfloat circleSdf(vec2 p, vec2 d, float r)\n{\n    return length(p-d)-r;\n}\n\nstruct Segment {\n    float t;\n    float z_factor;\n    int index;\n};\n\nmat2 Rotate2D(in float angle)\n{\n    float cosT = cos(angle);\n    float sinT = sin(angle);\n    return mat2(cosT,-sinT,sinT,cosT);\n}\n\nSegment SegmentDist(in vec3 q)\n{\n    q *= 2.;\n    \n    #ifdef DEBUG_MODE\n    #endif\n    \n    // cutoff spacing constant\n    float H = .0851;\n    float R1 = 1.;\n    float R2 = .5;\n    float D = .75;\n    float A = 50.; // degrees angle\n    \n    // mirrored bottom part\n    vec3 r = vec3(q.x,abs(q.y),q.z);\n    float c1 = circleSdf(r.xy,vec2(0,D),R1);\n    float c2 = circleSdf(r.xy,vec2(0,-D),R1);\n    \n    float bubble = max(c1, // circle\n        -min(\n            circleSdf(r.xy,vec2(0,D),R2), // hole\n            c2 // other circle\n        )) + H/2.;\n        \n    float middle = max(c1,c2) + H/2.;\n    \n    \n    #if ALTERNATE_STYLE\n    float mask1 = min(r.x, max(r.x - (R2 + H/2.), -(r.y-D)));\n    float segment1 = max(bubble,-mask1);\n    \n    float mask2 = min(-r.x, max(-r.x - (R2 + H/2.), -(r.y-D)));\n    float segment2 = max(bubble,-mask2);\n    \n    float segment3 = max(bubble, -(min(segment1, segment2)-H));\n    #else\n    vec2 z = r.xy - vec2(0,D);\n    vec2 z1 = z * Rotate2D(radians(A));\n    vec2 z2 = z * Rotate2D(-radians(A));\n    \n    \n    float mask1 = min(r.x, max(r.x - (R2*.91 + H/2.), -(r.y-D)));\n    float segment1 = max(bubble,-mask1);\n    //float mask1 = min(z1.x,z.x);\n    //float segment1 = max(bubble,-mask1);\n    \n    float mask2 = min(-z2.x,-z.x);\n    float segment2 = max(bubble,-mask2);\n    \n    float segment3 = max(bubble, -(min(segment1, segment2)-H));\n    \n    #endif\n    \n    float t = MAX_DISTANCE;\n    int id = 0;\n    \n    if (segment1 < t) {\n        t = segment1;\n        id = 1;\n    }\n    \n    \n    if (segment2 < t) {\n        t = segment2;\n        id = 2;\n    }\n    \n    \n    if (segment3 < t) {\n        t = segment3;\n        id = 3;\n    }\n    \n    if (sign(q.y) < 0. && id != 0) {\n        // below part of the shape, add 3 to id\n        id += 3;\n    }\n    \n    if (middle < t) {\n        t = middle;\n        id = 7;\n    }\n    \n    //float t = min(min(min(segment1, segment2),segment3), middle);\n    \n    return Segment(t,q.z,id);\n}\n\nvec3 debugColors[8] = vec3[8](\n    vec3(1,1,1),\n    vec3(1,0,0), vec3(0,1,0), vec3(0,0,1),\n    vec3(1,1,0), vec3(1,0,1), vec3(0,1,1), vec3(0,.5,1) );\n\n\nstruct LitState { int s[7]; };\n\n#if DEBUG_ANGLE_CONSTRUCT \nLitState digitTable[10] = LitState[10](\n    LitState(int[7](1,1,1,1,1,1,0)),// 0 zero  \n    LitState(int[7](1,0,0,1,0,0,0)),// 1 one\n    LitState(int[7](1,0,1,0,1,1,1)),// 2 two\n    LitState(int[7](1,0,1,1,0,1,1)),// 3 three\n    LitState(int[7](1,1,0,1,0,0,1)),// 4 four\n    LitState(int[7](0,1,1,1,0,1,1)),// 5 five\n    LitState(int[7](0,1,1,1,1,1,1)),// 6 six\n    LitState(int[7](1,0,1,1,0,0,0)),// 7 seven\n    LitState(int[7](1,1,1,1,1,1,1)),// 8 eight\n    LitState(int[7](1,1,1,1,0,1,1)) // 9 nine\n);\n#else\nLitState digitTable[10];\nvoid InitLitState()\n{\n    digitTable[0].s = int[7](1,1,1,1,1,1,0); // 0 zero  \n    digitTable[1].s = int[7](1,0,0,1,0,0,0); // 1 one\n    digitTable[2].s = int[7](1,0,1,0,1,1,1); // 2 two\n    digitTable[3].s = int[7](1,0,1,1,0,1,1); // 3 three\n    digitTable[4].s = int[7](1,1,0,1,0,0,1); // 4 four\n    digitTable[5].s = int[7](0,1,1,1,0,1,1); // 5 five\n    digitTable[6].s = int[7](0,1,1,1,1,1,1); // 6 six\n    digitTable[7].s = int[7](1,0,1,1,0,0,0); // 7 seven\n    digitTable[8].s = int[7](1,1,1,1,1,1,1); // 8 eight\n    digitTable[9].s = int[7](1,1,1,1,0,1,1); // 9 nine\n}\n#endif\n\nfloat SegmentOn(in float digit, in int current_id)\n{\n    // return segment On/Off state\n    \n    int x = int(floor(digit));\n    \n    LitState state = digitTable[x];\n    return state.s[current_id-1] == 1 ? 1. : 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if !DEBUG_ANGLE_CONSTRUCT\n    InitLitState();\n    #endif\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // NDC coordinates (from -1 to 1)\n    vec2 p = uv * 2.0 - 1.0;\n\n    // Correct aspect ratio\n    float aspect = iResolution.x/iResolution.y;\n    p.x *= aspect;\n\n    // Digit display extent\n    vec3 q = vec3(p,1);\n    q *= 1.8; // overall zoom\n    \n    vec2 b = vec2(1.2,2);\n    \n    q.x += 1.5*b.x;\n    int digitIndex = int(floor((q.x-b.x*.5)/b.x));\n    q.x = mod(q.x+b.x*.5,b.x)-b.x*.5;\n    Segment sg = SegmentDist(q);\n\n    float t = sg.t/sg.z_factor;\n    float alpha = smoothstep(3./iResolution.y,0.,t);\n    float bloom = pow(clamp(-t,0.,.05),10.);\n    \n    vec3 col = vec3(0.0185);\n    if (digitIndex <= 1 && digitIndex >= 0) {\n#if DEBUG_MODE\n        vec3 segmentTint = debugColors[sg.index];\n#else\n        vec3 segmentTint = vec3(.52,1., 1.0);\n#endif\n        \n        float sec = mod(iTime,60.);\n        float digitVal = mod(sec / pow(10.,float(1-digitIndex)), 10.);\n        \n        float centi = mod(iDate.w*100.,100.);\n        float isOn = SegmentOn(digitVal, sg.index);\n        col = mix(col, mix(vec3(.0814),segmentTint,isOn), alpha);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}