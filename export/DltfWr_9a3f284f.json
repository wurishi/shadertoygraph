{"ver":"0.1","info":{"id":"DltfWr","date":"1701154273","viewed":48,"name":"colorful moving","username":"nayk","description":"shader copy past thf for original","likes":0,"published":1,"flags":1,"usePreview":0,"tags":["3d","colorful","moving"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*original https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/ldc3Dn  /*original https://www.shadertoy.com/view/cttXRl https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/MlfcDN*/\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define MIRROR\n\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\n#define MIRROR\n\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat qbox( vec3 p, float s )\n{\n  return length(max(abs(p)-vec3(s,s,s),0.0));\n}\n\nfloat box(vec3 p, vec3 b){ \n    p = abs(p) - b;\n    return max(p.x, max(p.y,p.z));\n}\n\nvec2 map2( in vec3 pos )\n{\n    float size = .35;\n    pos = mod(pos,size)-0.5*size;\n\t\n    float res = qbox(pos,size);\n\n    pos+=size;\n    \n    for(float i = 0.0; i<3.;i++){\n        size /= 3.0;\n        \n        float b = box(opRep(pos,vec3(size*3.,size*3.,0)),vec3(size,size,10.));\n        res = opS(res,b);\n        b = box(opRep(pos,vec3(size*6.,0.,size*6.)),vec3(size,10.,size));\n        res = opS(res,b);\n        b = box(opRep(pos,vec3(0.,size*6.,size*6.)),vec3(10.,size,size));\n        res = opS(res,b);\n    }\n\t\n    return vec2(res,1.0);\n}\n\n#define pi 3.1415926\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\n// primitives mostly adapted from https://iquilezles.org/articles/distfunctions/\nfloat halfspace(vec3 p)\n{\n    return p.z + 1.0;\n}\n\n// based on https://iquilezles.org/articles/distfunctions/\nfloat line(vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// adapted from https://iquilezles.org/articles/distfunctions/\nfloat cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 200u\n\nfloat map(vec3 p)\n{\n    uint variant = uint(floor(iTime/5.0)) % 2u;\n\n    float h = 1.0;\n    vec2 o = vec2(-1,+1);\n    vec3 v[4] = vec3[](o.xxx,o.yxx,o.xyx,o.xxy);\n    float d = DIST_MAX;\n    \n    for(uint i = 0u; i < 4u; i++)\n    {\n        //d = min(d, cylinder(p,-v[i],+v[i],h/8.0));\n        for(uint j = 0u; j < 4u; j++)\n        {\n            if(i!=j)\n            {\n                vec3 n =\n                    variant < 1u ? normalize(cross(v[i],v[j])) :\n                    normalize(cross(v[i],cross(v[i],v[j])));\n                d = min(d, cylinder(p,-v[i]+n*h,+v[i]+n*h,h/8.0));\n                d = min(d, cylinder(p,-v[i]-n*h,+v[i]-n*h,h/8.0));\n            }\n        }\n    }\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p )\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) +\n                      k.yyx*map( p + k.yyx*h ) +\n                      k.yxy*map( p + k.yxy*h ) +\n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat trace(vec3 ro, vec3 rd, float t0, float t1) // pass on running out of iterations\n{\n    // NOTE: Limited number of iterations to avoid stalling\n    //       when ray passes closely (just above EPSILON)\n    //       in parallel to a surface.\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n\n    return t; // stop on running out of iterations\n    //return t1; // pass on running out of iterations\n}\n\n// NOTE: Don't forget to add +normal*EPSILON to the starting position\n//       to avoid artifacts caused by getting stuck in the surface\n//       due to starting at distance < EPSILON from the surface.\n//       (normal could be calculated here but that would most likely be redundant)\nfloat shadow(vec3 ro, vec3 rd, float t0, float t1)\n{\n    return trace(ro, rd, t0, t1) < t1 ? 0.0 : 1.0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, in vec3 rd, float t0, float t1, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    uint i;\n    float t;\n    for(t = t0, i = 0u; t < t1 && i < ITER_MAX; i++)\n    {\n        float h = map(ro + rd*t);\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\nfloat checker(vec2 p)\n{\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi));\n}\n\nfloat checker(vec3 p)\n{\n    return step(0.0, sin(p.x*pi)*sin(p.y*pi)*sin(p.z*pi));\n}\n\nvec3 material(vec3 p)\n{\n    return vec3(1.0); // TODO\n    //return mix(vec3(0.25), vec3(0.75), checker(p*2.0+0.5));\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.;\n    float tmax = 120.0;\n    \n\tfloat precis = 0.0001;\n    float t = tmin;\n    float m = 0.0;\n    for( int i=0; i<120; i++ )\n    {\n\t    vec2 res = map2( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.;\n    return vec2( t, m );\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(1.0);\n    vec2 res = castRay(ro,rd);\n    \n    const vec3 a = vec3(.5, .0, .5);\n    const vec3 b = vec3(.5, 1., .5);\n    const vec3 c = vec3(1., 1., 1.);\n    const vec3 d = vec3(.0, .1, 0.2);\n    \n    col = palette(0.3+res.x*2., a, b, c, d);\n    col = mix( col, vec3(1.0), 1.0-exp( -.5*res.x*res.x ) );\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.2; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.02,1.);\t\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.000,1.000,0.000);\n    vec3 d = vec3(0.5,0.2,0.25);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat SDF_Triangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    \n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)/sign(p.y);\n}\n\nfloat spiral(in vec2 p)\n{\n    float x = p.x*3.;\n    \n    float m = min (fract (x), fract (3. -x)) ;\n    return smoothstep (-0.2, 0.1, m*.5+.2-p.y) ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\nvec2 p2 = -1.0+2.0*(fragCoord.xy / iResolution.xy);\n\tp2.x *= iResolution.x/iResolution.y;\n    vec4 O= fragColor;\n    vec2 C=  fragCoord;\n  \n    vec2 I=  fragCoord;\n    float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(p2.xy) + 0.07)) * 2.2;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n\n    vec2 uv2 = (C.xy-.5*iResolution.xy) / iResolution.y;\n    vec2 st = vec2 (atan(uv2.x, uv2.y), length (uv2)) ;\n    uv2 = vec2 (st.x / 6.2831+.5 - (-iTime + st.y), st.y);\n    float c = 0.0;\n    \n    float triangle = SDF_Triangle((C.xy-.5*iResolution.xy) / iResolution.y, .3);\n    \n    c = spiral(uv2) * 2. * spiral(vec2(spiral(uv2 / 1.6), triangle))*cos(iTime);\n    \n    \n    c += triangle / 1.6;\n\n    \n    vec3 col = palette(length(st.y) + .4 + iTime*.4);\n    col *= c;\n    \n    \n \n \n\n    col *= c;\n\n   \n\n  \n\n O=vec4(0);\n    vec3 p,q,r=iResolution;\n   vec3 d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n   \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n    \n        p=g*d;\n    \n      \n        p.z+=-iTime*2.5;\n        a=10.;\n        p+= vec3(cos(iTime)*10.,-sin(iTime)*10.,sin(iTime)*10.);\n        p=mod(p-a,a*2.)-a;\n        s=3.;\n        for(int i=0;i++<8;){\n            p=.3-abs(p);\n            \n            p.x<p.z?p=p.zyx:p;\n            p.z<p.y?p=p.xzy:p;\n            p.y<p.x?p=p.zyx:p;\n            \n            s*=e=1.7+sin(iTime*.1234)*.1;\n            p=abs(p)*e-\n                vec3(\n                    5.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                    120,\n                    8.+cos(iTime*.5)*5.\n                 );\n         }\n      \n         g+=e=length(p.yx)/s;\n    }\n \tbool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    I = (2.0 * I - R) / R.y; // concise scaling thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 4.0/3.0 * pi / 2.0;\n\n    vec3 ro = vec3(0, 0,-5);\n    vec3 rd = normalize(vec3(I.xy, 2.0)); // NOTE: omitting normalization results in clipped edges artifact\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0);\n    ro = M * ro;\n    rd = M * rd;\n    //ro.z += 1.0;\n;\n    vec3 color = vec3(1);\n    float dist = trace(ro, rd, 0.0, DIST_MAX);\n    if(dist < DIST_MAX)\n    {\n        vec3 dst = ro + rd * dist;\n        vec3 n = normal(dst);\n\n        //color *= (n * 0.5 + 0.5);\n        color *= material(dst);\n\n        vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 ambient = vec3(0.4);\n        float brightness2 = max(dot(lightdir, n), 0.0);\n        if(brightness > 0.0)\n            brightness2 *= shadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX);\n            //brightness *= softshadow(ro + rd * dist + n * 0.01, lightdir, 0.0, DIST_MAX, 20.0);\n        color *= (ambient * calcAO(dst, n) + brightness2);\n\n        if(brightness > 0.0)\n        {\n            float specular = pow(max(0.0, dot(n, normalize(-rd + lightdir))), 250.0);\n            color += specular;\n        }\n\n        vec3 fog_color = vec3(0.2);\n        color = mix(fog_color, vec3(color), exp(-pow(dist/20.0, 2.0))); // fog\n    }\n    else\n    {\n        color *= mix(vec3(0,0.5,0.5),vec3(0,0,1),abs(-rd.z)); // sky\n        color = vec3(0);\n    }\n\n    color = tanh(color); // roll-off overly bright colors\n    color = sqrt(color); // approximate gamma\n\tvec3 ro2 = vec3(0., .0, -iTime*0.04 );\n   \n\tvec3 ta = ro2 + vec3(0., 0., -1. );\n\t\n\n    mat3 ca = setCamera( ro, ta, 0. );\n   \n\tvec3 rd2 = ca * normalize( vec3(p.xy,.8) );\n\n  \t\n    vec3 col2 = render( ro2, rd2);\n    col2 += (vec3(1.)*p2.y)*0.35;\n\t\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.)*col;\n\tdir+=O.xyz+color+col2;\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n    fragColor*=vec4(col2,1.);\n}\n","name":"Image","description":"","type":"image"}]}