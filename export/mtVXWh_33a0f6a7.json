{"ver":"0.1","info":{"id":"mtVXWh","date":"1686357913","viewed":90,"name":"Creepy power grid","username":"Krafpy","description":"An experiment with an infinite grid traversal and some (not really good) bloom. Use the mouse to move the camera around.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","grid","sdf","bloom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.);\n    float r = 6.;\n    float rr = r*r;\n    float w0 = 0.3780/pow(r,2.);\n    for(float i = -r; i <= r; ++i){\n        for(float j = -r; j <= r; ++j){\n            vec2 uv2 = uv + vec2(i,j)/iResolution.xy;\n            vec4 tex = texture(iChannel0, uv2);\n            vec3 c = texture(iChannel0, uv2).rgb;\n            if(tex.w == 1. || tex.w == 3.){\n                c *= step(0.5, c.b);\n                c *= w0*exp((-i*i-j*j)/(2.*rr));\n                col += c;\n            }\n        }\n    }\n    \n    \n    col += texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265\n#define TWOPI 6.28318530\n#define HALFPI 1.5707963\n#define MAX_RM_STEPS 200.\n\n// hash functions from: https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash32(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash31(float p) {\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hash13(vec3 p3) {\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat sdSphere(vec3 p, vec4 sph){\n    return length(p - sph.xyz) - sph.w;\n}\n\nfloat sdBox(vec3 p, vec3 b){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdLine(vec3 p, vec3 a, vec3 u){\n    vec3 ap = p - a;\n    return length(ap - dot(ap,u)*u);\n}\n\nfloat sdCylinder(vec3 p, float h, float r){\n    float d = length(p.xz) - r;\n    d = max(d, p.y-0.5*h);\n    d = max(d, -(p.y+0.5*h));\n    return d;\n}\n\nfloat sdTorus(vec3 p, float r, float w){\n    return distance(normalize(vec3(p.x,0.,p.z))*r, p) - w;\n}\n\nconst vec2 gridSize = vec2(2.55);\n\n\nfloat sdBlock(vec3 p){\n    float d = sdBox(p-vec3(0.,-9.,0.), vec3(1.,10.,1.)) - 0.25;\n    d = max(d, (p.y-1.));\n    vec3 o = vec3(0.,-0.1,0.);\n    d = max(d, -sdBox(p-o, vec3(0.8, 0.8, 10.)));\n    d = max(d, -sdBox(p-o, vec3(10., 0.8, 0.8)));\n    for(float h = -0.4; h <= 0.4; h += 0.4)\n        d = max(d, -(abs(p.y+h)-0.12));\n    \n    p.y -= 1.05;\n    o = vec3(1.,0.,1.);\n    float d1 = sdCylinder(abs(p)-o, 0.15, 0.15);\n    float d2 = sdBox(p, vec3(1.,0.075,1.));\n    d = max(d, -min(d1, d2));\n    \n    return d;\n}\n\nfloat sdLightRods(vec3 p){\n    float d = sdLine(abs(p)-vec3(1.,0.,1.), vec3(0.), vec3(0.,1.,0.)) - 0.15;\n    return max(d, (p.y-0.75));\n}\n\nfloat getmin(float a, float b, inout float ida, float idb){\n    float f = step(0., a - b);\n    ida = (1.-f)*ida + f*idb;\n    return min(a, b);\n}\n\nfloat sdPowerPost(vec3 p, inout float id){\n    id = 0.;\n    p.y -= 6.;\n    vec3 c = vec3(0.,floor(p.y)+.5,0.);\n    float d = sdTorus(p - c, 2., 0.5);\n    d = max(d, p.y);\n    d = getmin(d, length(abs(p.xz)-vec2(0.8))-0.3, id, 1.);\n    p.y = mod(p.y+5.,10.)-5.;\n    float dc = sdCylinder(p, 1., 2.);\n    d = getmin(d, dc, id, 2.);\n    return d;\n}\n\n\nvec3 target = vec3(0.);\n\nvec3 cellCenter(vec2 c){\n    vec2 oxz = (c+0.5)*gridSize;\n    float y = 0.;\n    float d = abs(target.x - oxz.x);\n    if(c.y < 1. && c.y > -1.) {\n        y = target.y*smoothstep(10.,3.,d);\n    }\n    return vec3(oxz.x, y, oxz.y);\n}\n\nvec2 sdf(vec3 p){\n    // coordinates of ro relative to the center of the cell\n    vec2 c = floor(p.xz/gridSize);\n    p = p - cellCenter(c);\n    // distance in cell's space\n    float d = 100000.;\n    float id = 0.;\n    \n    if(abs(c.y) < 5. || hash12(c*10.) < 0.95) {\n        float d1 = sdBlock(p);\n        float d2 = sdLightRods(p);\n        d = getmin(d1, d2, id, 1.);\n    } else {\n        float idp = 0.;\n        float dp = sdPowerPost(p/0.5, idp)*0.5;\n        d = getmin(d, dp, id, idp+2.);\n    }\n    \n    return vec2(d, id);\n}\n\nvec3 randomInUnitSphere(vec3 p) {\n  float f = hash13(p);\n  float theta = TWOPI * hash12(vec2(f * 0.3482f, f * 2.18622f));\n  float phi = acos(1.0f - 2.f * hash12(vec2(f * 1.9013, f * 0.94312)));\n  float x = sin(phi) * cos(theta);\n  float y = sin(phi) * sin(theta);\n  float z = cos(phi);\n  return sqrt(hash13(p))*vec3(x,y,z);\n}\n\nfloat ambiantOcclusion(vec3 p, vec3 n) {\n    vec3 x = normalize(cross(p, n));\n    vec3 y = n;\n    vec3 z = cross(x, y);\n    mat3 l2w = mat3(x, y, z);\n    float m = 32.;\n    float k = 0.;\n    float r = 0.3;\n    for(float i = 0.; i < m; ++i){\n        vec3 u = randomInUnitSphere(i*vec3(-1.149,0.19,3.31)+p);\n        u.y = abs(u.y);\n        k += step(0., sdf(p+r*l2w*u).x);\n    }\n    \n    return pow(k/m, 4.);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd, float maxT){\n    float eps = 0.0001;\n    float t = 0.;\n    for(float i = 0.; i < MAX_RM_STEPS && t < maxT; ++i){\n        vec2 info = sdf(ro + rd*t);\n        float d = info.x;\n        if(d < eps){\n            return vec3(min(t, maxT), i/MAX_RM_STEPS, info.y);\n        }\n        t += d;\n    }\n    return vec3(-1.);\n}\n\n\nfloat nextGridCell(vec2 ro, vec2 rd){\n    const float eps = 0.002;\n    vec2 i = floor(ro/gridSize)*gridSize;\n    vec2 d = i + max(sign(rd)*gridSize,0.) - ro;\n    vec2 t = d/rd;\n    return min(t.x,t.y) + eps;\n}\n\nvec3 traceGrid(vec3 ro, vec3 rd){\n    float t = 0.;\n    float f = 0.;\n    for(float i = 0.; i < 35.; ++i){\n        float maxT = nextGridCell(ro.xz, rd.xz);\n        vec3 hit = raymarch(ro, rd, maxT);\n        if(hit.x > 0.){\n            t += hit.x;\n            f += hit.y;\n            return vec3(t, f/(i+1.), hit.z);\n        }\n        t += maxT;\n        f += 1.;\n        ro += maxT*rd;\n    }\n    return vec3(-1.);\n}\n\nvec3 sdfNormal(vec3 p){\n    vec2 h = vec2(0.0001,0.);\n    return normalize(vec3(\n        sdf(p+h.xyy).x - sdf(p-h.xyy).x,\n        sdf(p+h.yxy).x - sdf(p-h.yxy).x,\n        sdf(p+h.yyx).x - sdf(p-h.yyx).x\n    ));\n}\n\nconst vec3 sunDir = normalize(vec3(1.));\n\nstruct Material {\n    vec3 F0;\n    float alphaP;\n};\n\nvec3 FSchlick(vec3 F0, vec3 n, vec3 h) {\n    return F0 + (1.-F0)*(1. - pow(max(dot(n,h),0.), 5.));\n}\n\nfloat D_alpha(vec3 n, vec3 h, float a){\n    return ((a + 2.)/TWOPI)*pow(max(dot(n,h),0.), a);\n}\n\nMaterial getMaterial(float id, vec2 c){\n    if(id == 0.){\n        vec3 F0 = vec3(0.15, 0.1, 0.3);\n        F0 += (0.5*hash32(c)-0.5)*0.3;\n        F0 = clamp(F0, 0., 1.);\n        return Material(F0, 20.);\n    }\n    if(id == 1. || id == 3.)\n        return Material(vec3(0.9,0.1,0.1), 50.);\n    if(id == 2.)\n        return Material(vec3(0.955,0.638,0.538), 10.);\n    if(id == 4.)\n        return Material(vec3(1.,1.,0.5), 10.);\n    return Material(vec3(0.), 1.);\n}\n\nvec3 lightRodCol(vec3 baseCol, float y){\n    float c = 1.1*sin(iTime*1.5);\n    float f = smoothstep(-0.4,0.,y-c)*smoothstep(0.4,0.,y-c);\n    return mix(baseCol, vec3(0.3,0.8,1.), f);\n}\n\nvec3 lightPostCol(vec3 baseCol, float y){\n    float x = mod(y-iTime*30., 20.)-10.;\n    float s = 3.;\n    float m = 0.7;\n    float c = smoothstep(-s,-m,x)*smoothstep(s,m,x);\n    return mix(baseCol, vec3(0.5,0.9,0.7), c);\n}\n\nvec3 lightRodNormal(vec3 p, vec3 n){\n    vec2 q = abs(p.xz) - vec2(1.);\n    n.xz *= rot(sin(10.*atan(q.x,q.y)));\n    return n;\n}\n\nvec3 background(vec3 rd){\n    vec3 bgCol = vec3(1.,0.4,0.3);\n    vec3 sunCol = vec3(1., 0.9, 0.4);\n    vec3 col = vec3(0.);\n    float d = dot(rd, sunDir);\n    float f = smoothstep(0.6, 1., d);\n    col = mix(bgCol, sunCol, f);\n    return col*0.45;\n}\n\nvec4 render(vec3 ro, vec3 rd){\n    vec3 hit = traceGrid(ro, rd);\n    \n    vec3 bg = background(rd);\n    float dark = smoothstep(-0.2, -0.1, rd.y);\n    \n    if(hit.x <= 0.){\n        return vec4(bg * dark, -1.);\n    }\n    \n    vec3 col = vec3(0.);\n    \n    float id = hit.z;\n    float t = hit.x;\n    \n    vec3 p = ro + rd*t;\n    vec2 c = floor(p.xz/gridSize);\n    vec3 cc = cellCenter(c);\n    vec3 q = p - cc;\n    vec3 n = sdfNormal(p);\n    // light rod normal distortion\n    if(id == 1.)\n        n = lightRodNormal(q, n);\n    vec3 v = -rd;\n    vec3 l = sunDir;\n    vec3 h = normalize(l + v);\n    \n    // lighting\n    Material mat = getMaterial(id, c);\n    float iG = pow(max(dot(l,h),0.), 2.);\n    float D = D_alpha(n,h,mat.alphaP);\n    col = FSchlick(mat.F0, n, h) * D / iG;\n    col += mat.F0 / PI;\n    col *= max(dot(n, l), 0.) * vec3(0.4);\n    col = clamp(col, 0., 1.);\n    \n    // shadows\n    hit = traceGrid(p+n*0.03, l);\n    if(hit.x > 0.) {\n        float s = smoothstep(6., 1., hit.x);\n        vec3 shad = vec3(1.-exp(-0.03*hit.x));\n        shad = mix(shad, vec3(0.01), s);\n        // shad = pow(shad, vec3(1.0, 1.2, 1.5));\n        col *= shad;\n    }\n    \n    // ambiant occlusion\n    col *= ambiantOcclusion(p, n);\n    \n    // light rods effects\n    if(id == 1.)\n        col = lightRodCol(col, q.y);\n    else if(id == 3.)\n        col = lightPostCol(col, q.y);\n    \n    // air absorption\n    float s = smoothstep(10., 50., t);\n    col = mix(col, bg, s);\n    // make parts below a certain altitude dark\n    s = smoothstep(-1., -5., p.y);\n    col = mix(col, vec3(0.), s);\n    \n    return vec4(col, id);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 mr = iMouse.xy/iResolution.xy;\n    mr -= 0.5;\n    mr.x *= iResolution.x / iResolution.y;\n    mr *= 3.141592;\n    \n    target = vec3(0.);\n    target.xz = gridSize*0.5;\n    target.x += iTime;\n    target.y = 2.3*smoothstep(0.,0.4,0.5*sin(0.1*iTime-1.2)+0.5);\n    \n    vec3 ro = target;\n    // vec3 ro = vec3(0., 0., -10.);\n    vec3 rd = normalize(vec3(1., uv.y, -uv.x));\n    if(iMouse.z > 0.){\n        rd.yx *= rot(mr.y);\n        rd.xz *= rot(mr.x);\n        // ro.yz *= rot(mr.y);\n        // ro.xz *= rot(mr.x);\n    } else {\n        float ax = sin(iTime*0.1) * HALFPI;\n        rd.xz *= rot(ax);\n    }\n    \n    vec4 res = render(ro, rd);\n    col = res.rgb;\n    \n    col = pow(col, vec3(1./2.4));\n    \n    \n    fragColor = vec4(col,res.w);\n}","name":"Buffer A","description":"","type":"buffer"}]}