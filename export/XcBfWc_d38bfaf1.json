{"ver":"0.1","info":{"id":"XcBfWc","date":"1725556804","viewed":20,"name":"test lambert","username":"www998www","description":"test lambert","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lambert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PROJECTION_SCALE  1.\n\n// 球体的球心位置\n#define SPHERE_POS vec3(0, 0, -2)\n// 球体的半径\n#define SPHERE_R 1.0\n// 球体的漫反射系数\n#define SPHERE_KD vec3(1)\n\n// 相机视点位\n#define CAMERA_POS mat3(cos(iTime),0,sin(iTime),0,1,0,-sin(iTime),0,cos(iTime))*(vec3(1, 0, 0)-SPHERE_POS)+SPHERE_POS\n\n// 相机目标点\n#define CAMERA_TARGET vec3(0, 0, -2) + vec3(iMouse.x/iResolution.x - 0.5, iMouse.y/iResolution.y - 0.5, 0)\n// 上方向\n#define CAMERA_UP vec3(0, 1, 0)\n\n// 光线推进的起始距离\n#define RAYMARCH_NEAR 0.1\n// 光线推进的最远距离\n#define RAYMARCH_FAR 128.\n// 光线推进次数\n#define RAYMARCH_TIME 20\n// 当推进后的点位距离物体表面小于RAYMARCH_PRECISION时，默认此点为物体表面的点\n#define RAYMARCH_PRECISION 0.001\n\n// 点光源位置\n#define LIGHT_POS vec3(1, 1, 0)\n\n// 相邻点的抗锯齿的行列数\n#define AA 3\n\n// 投影坐标系\nvec2 ProjectionCoord(in vec2 coord) {\n  return PROJECTION_SCALE * 2. * (coord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\n//从相机视点到片元的射线\nvec3 RayDir(in vec2 coord) {\n  return normalize(vec3(coord, 0) - CAMERA_POS);\n}\n\n//球体的SDF模型\nfloat SDFSphere(vec3 coord) {\n  return length(coord - SPHERE_POS) - SPHERE_R;\n}\n\n// 计算球体的法线\nvec3 SDFNormal(in vec3 p) {\n  const float h = 0.0001;\n  const vec2 k = vec2(1, -1);\n  return normalize(k.xyy * SDFSphere(p + k.xyy * h) +\n    k.yyx * SDFSphere(p + k.yyx * h) +\n    k.yxy * SDFSphere(p + k.yxy * h) +\n    k.xxx * SDFSphere(p + k.xxx * h));\n}\n\n// 打光\nvec3 AddLight(vec3 positon) {\n  // 当前着色点的法线\n  vec3 n = SDFNormal(positon);\n  // 当前着色点到光源的方向\n  vec3 lightDir = normalize(LIGHT_POS - positon);\n  // 漫反射\n  vec3 diffuse = SPHERE_KD * max(dot(lightDir, n), 0.);\n  // 环境光\n  float amb = 0.15 + dot(-lightDir, n) * 0.2;\n  // 最终颜色\n  return diffuse + amb;\n}\n\n// 视图旋转矩阵\nmat3 RotateMatrix() {\n  //基向量c，视线\n  vec3 c = normalize(CAMERA_POS - CAMERA_TARGET);\n  //基向量a，视线和上方向的垂线\n  vec3 a = cross(CAMERA_UP, c);\n  //基向量b，修正上方向\n  vec3 b = cross(c, a);\n  //正交旋转矩阵\n  return mat3(a, b, c);\n}\n\n// 光线推进\nvec3 RayMarch(vec2 coord) {\n  float d = RAYMARCH_NEAR;\n  // 从相机视点到当前片元的射线\n  vec3 rd = normalize(RotateMatrix() * vec3(coord, -1));\n  // 片元颜色\n  vec3 color = vec3(0);\n  for(int i = 0; i < RAYMARCH_TIME && d < RAYMARCH_FAR; i++) {\n    // 光线推进后的点位\n    vec3 p = CAMERA_POS + d * rd;\n    // 光线推进后的点位到球体的有向距离\n    float curD = SDFSphere(p);\n    // 若有向距离小于一定的精度，默认此点在球体表面\n    if(curD < RAYMARCH_PRECISION) {\n      color = AddLight(p);\n      break;\n    }\n    // 距离累加\n    d += curD;\n  }\n  return color;\n}\n\n// 抗锯齿 Anti-Aliasing\nvec3 RayMarch_anti(vec2 fragCoord) {\n  // 初始颜色\n  vec3 color = vec3(0);\n  // 行列的一半\n  float aa2 = float(AA / 2);\n  // 逐行列遍历\n  for(int y = 0; y < AA; y++) {\n    for(int x = 0; x < AA; x++) {\n      // 基于像素的偏移距离\n      vec2 offset = vec2(float(x), float(y)) / float(AA) - aa2;\n      // 投影坐标位\n      vec2 coord = ProjectionCoord(fragCoord + offset);\n      // 累加周围片元的颜色\n      color += RayMarch(coord);\n    }\n  }\n  // 返回周围颜色的均值\n  return color / float(AA * AA);\n}\n\n/* 绘图函数，画布中的每个片元都会执行一次，执行方式是并行的。\nfragColor 输出参数，用于定义当前片元的颜色。\nfragCoord 输入参数，当前片元的位置，原点在画布左下角，右侧边界为画布的像素宽，顶部边界为画布的像素高\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // 光线推进\n  vec3 color = RayMarch_anti(fragCoord);\n  // 最终颜色\n  fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}