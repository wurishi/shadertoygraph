{"ver":"0.1","info":{"id":"fljGDK","date":"1624744391","viewed":68,"name":"Infinitely Happy 2","username":"splinterofchaos","description":"A smiley face fractal.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["smile"],"hasliked":0,"parentid":"ft2GRt","parentname":"Infinitely happy."},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 LEFT = vec2(.32, .6);\nconst vec2 RIGHT = vec2(1.0 - LEFT.x, LEFT.y);\nconst float RADIUS = .15;\n\nconst float ZOOM_INCREMENT = 0.725;\nconst float ZOOM_TIME = 8.86;  // number of seconds to increment one zoom level, about.\n\nfloat zoom_of_depth(float depth) {\n  return tanh(depth * ZOOM_TIME);\n  float z = ZOOM_INCREMENT;\n  while (depth-- > 0.0) z += ZOOM_INCREMENT * (1.0 - z);\n  return z;\n}\n\nvec2 rotate2(vec2 v, float r) {\n  v = mat2(cos(r), -sin(r), sin(r), cos(r)) * (v - .5);\n  v += .5;\n  return v;\n}\n\nvec4 rotate4_around_z(vec4 v, float r) {\n  v = mat4(-cos(r), sin(r), cos(r),  0.0,\n           sin(r),  cos(r), -sin(r), 0.0,\n           -sin(r), -sin(r), -cos(r),  0.0,\n           0.0,     0.0,    0.0,     1.0) * (v - .5);\n  v += .5;\n  return v;\n}\n\nvec2 left(vec2 v, float zoom_factor, float depth) {\n  return (v - (LEFT - RADIUS)) * (1.0 / (RADIUS * 2.0));\n  float z_level = zoom_of_depth(depth+1.0);\n  float r = atanh(z_level - zoom_factor) * (depth + 1.0);\n  return rotate2(v, r);\n}\n\nvec2 right(vec2 v, float zoom_factor, float depth) {\n  return (v - (RIGHT - RADIUS)) / (RADIUS * 2.0);\n  float z_level = zoom_of_depth(depth+1.0);\n  float r = atanh(z_level - zoom_factor) * (depth + 1.0);\n  return rotate2(v, -r);\n}\n\nvec2 deeper(vec2 uv, vec2 new_center) {\n  return (uv - (new_center - RADIUS)) / (RADIUS * 2.0);\n}\n\n\nfloat sdf_circle(vec2 uv, vec2 position, float radius){\n\tfloat d = length(uv - position);\n\tfloat c = smoothstep(radius, radius-0.005, d); \n    return c;\n}\n\nfloat sdf_smile(vec2 uv, vec2 position, float offset, float radius, float radius_off) {\n    return clamp(\n    sdf_circle(uv, position, radius) - \n    sdf_circle(uv, vec2(position.x, position.y + offset), radius + radius_off),\n    0.0, 1.0);\n}\n\nfloat sdf_rim(vec2 uv, vec2 position, float radius_offset, float radius) {\n    return clamp(\n        sdf_circle(uv, position, radius) -\n        sdf_circle(uv, position, radius - radius_offset),\n        0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    uv.x -= .45;\n    \n    float t = iTime - 10.0;\n    \n    vec2 zoom_point = vec2(.3842109, .642857);\n    float zoom_factor = tanh(min(iTime - 10.0, 60.0) / 10.0);\n    \n    //if (zoom_factor > zoom_of_depth(2.0)) {\n    //fragColor = vec4(1,0,0,1);\n    //return;\n    //}\n    \n    vec2 off = zoom_point - uv;\n    uv += off * zoom_factor;\n    \n    float depth = 0.0;\n    for (; depth < 100.0; ++depth) {\n      if (distance(LEFT, uv) < RADIUS) {\n        uv = left(uv, zoom_factor, depth);\n      } else if (distance(RIGHT, uv) < RADIUS) {\n        uv = right(uv, zoom_factor, depth);\n      } else {\n        break;\n      }\n    }\n    \n    float smile = sdf_smile(uv, vec2(.5, .4), .08, .3, .025);\n    float rim = sdf_rim(uv, vec2(.5, .5), .06, .51);\n    float outline = smile + rim;\n    \n    float inside = sdf_circle(uv, vec2(.5, .5), .45);\n    \n    depth -= zoom_factor;\n    vec4 depth_color = rotate4_around_z(\n        normalize(vec4(.75, .3, .4, 1.0)),\n        2.0 * (depth - sin(iTime / 2.f)));\n    \n    float intensity = dot(vec2(1.0 - uv.x, uv.y), vec2(0.9, 1.0));\n    vec4 in_circle_color = depth_color * intensity / (depth + 1.0);\n    \n    fragColor = outline * vec4(1, 1, 1, 0) + inside * in_circle_color;\n}","name":"Image","description":"","type":"image"}]}