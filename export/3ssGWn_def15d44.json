{"ver":"0.1","info":{"id":"3ssGWn","date":"1545744217","viewed":295,"name":"Reflect and Refract","username":"gest","description":"almost original https://www.shadertoy.com/view/MtlBDj","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["lighting","materials","reflect","refract","sphereiandntersect","sphera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Адаптер\nfloat u_time;\n\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Object {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tvec3  normal;\n\tObject object;\t\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\nstruct Sphere {\n\tvec3  center;\n\tfloat radius;\n};\n\nstruct Plane {\n\tvec3 center;\n\tvec3 normal;\n};\n\nstruct Light {\n    vec3 position;\n\tvec3 color;\n};\nLight light_0 = Light ( vec3(1.5, 1.5, 0), vec3(0.9, 0.9, 0.6) );\nLight light_1 = Light ( vec3(1.5, 1.5, 0), vec3(0.6, 0.9, 0.9) );               \n\nstruct Material {\n    vec3  colorAmbient;     \n    vec3  colorDiffuse;    \n    vec3  colorSpecular;  \n    float shininess;   \t\n\t\n    float reflectivity;  \t//1 - полное отражение\n    float refractivity;\t\t//1 - полное преломление\n    float indexRefractive;\n};\nMaterial material_0 = Material ( \n\tvec3(0), vec3(0.3, 0.6, 0.9), vec3(0.0), 32.0,\n\t0.0, 0.0, 0.0\n);\t\t\t\t\t\t\t\t\t\t              \nMaterial material_1 = Material (\n\tvec3(0), vec3(0.9, 0.3, 0.6), vec3(1.0), 32.0,\n\t0.2, 0.0, 0.0\n);            \nMaterial material_2 = Material (\n\tvec3(0), vec3(0.6, 0.9, 0.3), vec3(0.0), 32.0,\t\n\t0.8, 0.0, 0.0\n);\n//Шары            \nMaterial material_3 = Material (\n\tvec3(0), vec3(.95, .9, .85), vec3 (1.0), 32.0,\t\n\t0.5, 0.5, 0.95\n);              \n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//---------------------------------------\n//Пересечение луча со сферой\nfloat intersectSphere (in Ray ray, in Sphere sphere) {\n    float a = dot (ray.direction, ray.direction);\n    // exit early, if denominator would almost be zero \n    if (a <= 0.) return ray.far;\n    // set up coefficients a, b and c\n    float b = dot (2. * ray.direction, ray.origin - sphere.center);\n    vec3 op = ray.origin - sphere.center;\n    float c = dot (op, op) - sphere.radius * sphere.radius;\n    float d = sqrt (b * b - 4. * a * c);\n    float twoA = 1. / 2.*a;\n    // compute possible values for t\n    float t1 = (-b + d) * twoA;\n    float t2 = (-b - d) * twoA;\n    // this case should not be possible \n    if (t1 <= .0 && t2 <= .0) return ray.far;\n\tfloat dist = ray.far;\n    if (t1 > .0 && t2 > .0) {\n        if (t1 < t2) {\n\t\t\tdist = t1;\n\t\t} else {\n\t\t\tdist = t2;\n\t\t}\n    }\n    return dist;\n}\n//Пересечение луча с плоскостью\nfloat intersectPlane (in Ray ray, in Plane plane) {\n\t// are ray and plane parallel?\n\tfloat d = dot (ray.direction,plane.normal);\n    if ( d >= 0.) return ray.far;\n\tfloat dist = dot(plane.center - ray.origin, plane.normal) / d;\n\treturn dist;\n}\n//Пересечение луча с элементами сцены\nvoid rayMarch (inout Ray ray) {\n\tray.origin += ray.near * ray.direction;\n\tray.distance = ray.far;\n\tray.hit = false;\n\tray.position = ray.origin + ray.distance * ray.direction;\n\tray.normal = vec3(0);\n\tray.object.id = 0;\n\t\n\tfloat d;\n\t\n\tSphere sphere;\n\tPlane plane;\n\t\n\t//Шары\n\tsphere = Sphere(vec3 (-2.,-1.4*0.5,-0.5), 0.6);\n\tsphere.center.y += -1.4*0.5*cos(0. + u_time);\n    d = intersectSphere (ray, sphere);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= normalize (ray.position - sphere.center);\n\t\tray.object.id \t= 1;\n\t}\n    \n\tsphere = Sphere(vec3 ( 1.,-1.5*0.5, 0.5), 0.5);\n\tsphere.center.y += -1.5*0.5*cos(1. + u_time);\n\td = intersectSphere (ray, sphere);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= normalize (ray.position - sphere.center);\n\t\tray.object.id \t= 2;\n\t}\n\n\tsphere = Sphere(vec3 ( 0.,-1.6*0.5, 1.5), 0.4);\n\tsphere.center.y += -1.6*0.5*cos(2. + u_time);\n    d = intersectSphere (ray, sphere);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= normalize (ray.position - sphere.center);\n\t\tray.object.id \t= 3;\n\t}\n\t\n\t//Пол\n\tplane = Plane(vec3 (.0, -2., .0),  vec3 ( 0, 1, 0));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 4;\n\t}\n\t//Потолок\n\tplane = Plane(vec3 (.0, 2.0, 0.),  vec3 ( 0,-1, 0));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 5;\n\t}\n\t//Ближняя стена\n\tplane = Plane(vec3 (.0, .0, 4.),   vec3 ( 0, 0,-1));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 6;\n\t}\n\t//Дальняя стена\n\tplane = Plane(vec3 (.0, .0, -4.),  vec3 ( 0, 0, 1));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit\t\t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 7;\n\t}\n\t//Правая стена\n\tplane = Plane(vec3 (-6.0, .0, 0.), vec3 ( 1, 0, 0));\n    d= intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 8;\n\t}\n\t//Левая стена\n\tplane = Plane(vec3 (6.0, .0, 0.),  vec3 (-1, 0, 0));\n    d = intersectPlane (ray, plane);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.hit \t\t= true;\n\t\tray.position \t= ray.origin + ray.distance * ray.direction;\n\t\tray.normal \t\t= plane.normal;\n\t\tray.object.id \t= 9;\n\t}\n\n\n}\n//Освещение от двух источников света\nvec3 lighting (in Ray ray, in Light lights[2], in Material material) {\n\tvec3 color = vec3(0);\n\t\n\tfor (int i=0; i<2; i++) {\n\t\tvec3 lightDirection = normalize (lights[i].position - ray.position);\n    \tfloat lightDistance = length (lights[i].position - ray.position);\n\t\tvec3 rayDirection_ref = reflect (ray.direction, ray.normal);\n\t\t//Тень\n\t\tRay ray1 = ray;\n\t\t{\n\t\t\tray1.origin \t= ray.position;\n\t\t\tray1.direction \t= lightDirection;\n\t\t\tray1.near\t\t= 0.01; //Отступ\n\t\t\tray1.far \t\t= lightDistance;\n\t\t}\n\t\trayMarch (ray1);\n\t\tfloat shadow = ray1.distance<lightDistance ? 0.5 : 1.0;\n\t\t\n\t\tfloat attenuation = 1.4 / (lightDistance * lightDistance);\n\t\tfloat diffuse = max (dot (ray.normal, lightDirection), .0);\n\t\tfloat specular = pow (max (dot (rayDirection_ref, lightDirection), .0), material.shininess);\n\t\tif (shadow >= 0.5)  specular = 0.;\n\n\t\tvec3 col = vec3(0);\n\t\tcol += material.colorAmbient;\n\t\tcol += material.colorDiffuse * diffuse * shadow * attenuation;\n\t\tcol *= lights[i].color;\n\t\tcol += material.colorSpecular * specular;\n\t\t\n\t\tcolor += col;\n\t}\n\treturn color;\n}\n/*\n//Получение цвета текстуры\nvec3 getColorTexture(sampler2D texture, vec3 p, vec3 normal) {\n\tmat3 m = mat3(\n\t\ttexture(texture, p.yz).rgb,\n\t\ttexture(texture, p.zx).rgb,\n\t\ttexture(texture, p.xy).rgb\n\t);\n\treturn m * abs(normal);\n}\n*/\n//Получение материала\nMaterial getMaterial(Ray ray) {\n\tMaterial material;\n\tif (ray.object.id==1) {\n\t\t//Прозрачные шарики\n\t\tmaterial = material_3;\n\t\tmaterial.colorDiffuse = vec3 (0);\n\t} else if (ray.object.id==2) {\n\t\t//Прозрачные шарики\n\t\tmaterial = material_3;\n\t\tmaterial.colorDiffuse = vec3 (0.5);\n\t} else if (ray.object.id==3) {\n\t\t//Прозрачные шарики\n\t\tmaterial = material_3;\n\t\tmaterial.colorDiffuse = vec3 (0.5, 0.1, 0.1);\n\t} else if (ray.object.id==4) {\n\t\t//Пол (Красная отражающая)\n\t\tmaterial = material_1;\n    \tfloat pattern = clamp (pow (abs(2. * cos(ray.position.x + u_time) * sin (ray.position.z + u_time) * .5 + .5), .3), 0., 1.);\n\t\tmaterial.colorDiffuse = mix (vec3 (.9, .3, .3), vec3 (.9), 1. - pattern);\n\t} else if (ray.object.id==5) {\n\t\t//Потолок (Желтая отражающая)\n\t\tmaterial = material_1;\n    \tfloat pattern = clamp (pow (abs(2. * cos(ray.position.x + u_time) * sin (ray.position.z + u_time) * .5 + .5), .3), 0., 1.);\n\t\tmaterial.colorDiffuse = mix (vec3 (.9, .9, .3), vec3 (.5), 1. - pattern);\n\t} else if (ray.object.id==6 || ray.object.id==7) {\n\t\t//Ближняя и дальняя стены (Зеленая отражающая)\n\t\tmaterial = material_2;\n    \tfloat pattern = clamp (mod (length(ray.position*sin(.1*u_time)), .5), 0., 1.);\n\t\tmaterial.colorDiffuse = mix (vec3 (.6, .9, .3), vec3 (.5), 1. - pattern);\n//    \tfloat pattern = clamp (pow (length (4.*sin(mod((ray.position.y*ray.position.x), .3))), .125), 0., 1.);\n//\t\tmaterial.colorDiffuse = mix (vec3 (.6, .9, .3), vec3 (.5), 1. - pattern);\n\t} else if (ray.object.id==8) {\n\t\t//Правая стена (синяя не отражающая)\n\t\tmaterial = material_0;\n\t\tfloat pattern = clamp (pow (abs(15. * cos(ray.position.x+u_time) * sin (ray.position.z+u_time)), .3), 0., 1.);\n\t\tmaterial.colorDiffuse = mix (vec3 (.3, .6, .9), vec3 (.8), 1. - pattern);\n\t} else if (ray.object.id==9) {\n\t\t//Левая стена (Кирпичная не отражающая)\n\t\tmaterial = material_0;\n        vec3 p = ray.position * 0.5;\n        mat3 m = mat3(\n            texture(iChannel0, p.yz).rgb,\n            texture(iChannel0, p.zx).rgb,\n            texture(iChannel0, p.xy).rgb\n        );\n\t\tmaterial.colorDiffuse = m * abs(ray.normal);;\n\t}\n\treturn material;\n}\n\n//Цвет отражений\nvec3 rayReflect(in Ray ray, in Light lights[2]) {\n\t//Цвет отражений\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorReflect = 1.0;\n\t\n\tfor (int i=0; i<5; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tcolor += factorReflect * lighting(ray, lights, material);\n\t\t\tfactorReflect *= material.reflectivity;\n\t\t\tif (factorReflect < 0.01) break;\n\t\t\t//Следующий луч\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= reflect (ray.direction, ray.normal);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n//Цвет преломлений\nvec3 rayRefract(in Ray ray, in Light lights[2]) {\n\tvec3 color = vec3(0);\n\t//Фактор отражения\n\tfloat factorRefract = 1.0;\n\t\n\tfor (int i=0; i<4; i++) {\n\t\t\n\t\trayMarch (ray);\n\t\t\n\t\tif (ray.hit) {\n\t\t\t//Достигли фигуры\n\t\t\tMaterial material = getMaterial(ray);\n\t\t\tfactorRefract *= material.refractivity;\n\t\t\tif (factorRefract < 0.01) break;\n\t\t\t//Луч преломления сквозь фигуру\n\t\t\t{\n\t\t\t\tray.origin \t\t= ray.position;\n\t\t\t\tray.direction \t= refract (ray.direction, ray.normal, material.indexRefractive);\n\t\t\t\tray.near \t\t= 0.01; //Отступ\n\t\t\t}\n            rayMarch (ray);\n\t\t\tcolor += factorRefract * rayReflect(ray, lights);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn color;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    //Адаптер\n    u_time = iTime;\n    vec2 u_canvas = iResolution.xy;\n    vec2 u_mouse  = iMouse.xy;\n    \n    float aspect = u_canvas.x / u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv * 2. - 1.;\n\n    vec2 mouse = u_mouse.xy / u_canvas.xy;\n    mouse = mouse * 2. - 1.;\n    mouse = (u_mouse.xy==vec2(0)) ? vec2(0) : (mouse.xy);\n\n    //Источники света\n    Light lights[2];\n    lights[0] = light_0;\n    lights[1] = light_1;\n    rotate (lights[0].position, vec3(0,1,0)*u_time/5.);\n    rotate (lights[1].position, vec3(0,1,0)*-u_time/5.);\n    //Камера\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n        cam.origin \t= vec3 (.0, .0, -3.);\n\n        float rotX = 0.5*PI*sin (0.5 * PI * mouse.y);\n        float rotY = PI*sin (0.5 * PI * mouse.x);\n        rotate(cam.origin, vec3(rotX, rotY, 0));\n\n        cam.target  = vec3(0,0,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n    //Луч из камеры\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.0;\n        ray.far  \t= 15.0;\n        ray.epsilon = 0.0001;\n        ray.steps \t= 1;\n    }\n    \n    vec3 color = vec3(0);\n\n    color += rayReflect(ray, lights);\n    color += rayRefract(ray, lights);    \n  \n\n    //Гаммакоррекция\n    color = pow(color, vec3(1.0/2.2));\n\n    GL_FragColor = vec4 (color, 1.);\n\n}","name":"Image","description":"","type":"image"}]}