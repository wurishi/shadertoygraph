{"ver":"0.1","info":{"id":"ldScWc","date":"1494077084","viewed":162,"name":"xem test raymarching + DE","username":"xem","description":"-","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distance","estimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Edit the numbers below and press play:\n\n// =========================================\n\n// Shape: 0 = sphere, 1 = box, 2 = torus,\n//        3 = union, 4 = substraction, 5 = intersection\nint shape = 0;\n\n// Infinite: 0 = no, 1 = yes\nint infinite = 1;\n\n// =========================================\n\n// Distance Estimation function\nfloat DE(vec3 p){\n    \n    // Infinite\n    if(infinite == 1){\n      p = mod(p, 2.0) - 0.5 * 2.0;\n    }\n    \n    // Scaling based on a cosinus wave\n    float scale = ((cos(iTime) + 2.5) / 2.7);\n    p = p / scale;\n    \n    float r;\n    \n    // Sphere\n    if(shape == 0){\n      r = length(p) - 0.7;\n    }\n    \n    // Box\n    if(shape == 1){\n      r = length(max(abs(p) - 0.5, 0.0));\n    }\n    \n    // Torus\n    if(shape == 2){\n      vec2 q = vec2(length(p.xy) - 0.5, p.z);\n      r = length(q)-0.1;\n    }\n    \n    // Union\n    if(shape == 3){\n      r = min(length(p) - 0.7, length(max(abs(p) - 0.55, 0.0)));\n    }\n    \n    // Substraction\n    if(shape == 4){\n      r = max(-(length(p) - 0.7), length(max(abs(p) - 0.55, 0.0)));\n    }\n    \n    // Intersection\n    if(shape == 5){\n      r = max(length(p) - 0.7, length(max(abs(p) - 0.5, 0.0)));\n    }\n    \n    // End of scale\n    return r * scale;\n}\n\n// Main function (called for each pixel)\n// Simple algorithm: all rays are parallel.\nvoid mainImage(out vec4 fragColor,vec2 fragCoord){\n\t\n    // Adjust to canvas size\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Create a ray that goes forward\n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    // The origin o is the camera's position\n    vec3 o;\n    \n    // Infinite: Make the camera move\n    if(infinite == 1){\n        o = vec3(0.0, iTime, iTime);\n    }\n    \n    // Not infinite: place the camera at (0,0,-2)\n    if(infinite == 0){\n        o = vec3(0.0, 0.0, -2.0);   \n    }\n    \n    // Raymarching loop\n    //float t = 0.0;\n    //for(int i = 0; i < 99; ++i){\n    //    t += DE(o + r * t) * 0.3;\n    //}\n    \n    float t = 0.0;\n    vec3 p;\n\n    for(int i = 0; i < 99; i++)\n    {\n        p = (o + r * t);// * 0.3;\n    \tfloat d = DE(p);\n        t += d;\n        //if(d < .01){\n        //    break;\n        //}\n    }\n    \n    // Fog\n    float fog = 1.0 / (1.0 + t * t * 0.3);\n    \n    // Color the current pixel according to the fog\n    fragColor = vec4(vec3(fog), 1.0);\n}","name":"Image","description":"","type":"image"}]}