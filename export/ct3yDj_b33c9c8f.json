{"ver":"0.1","info":{"id":"ct3yDj","date":"1699628533","viewed":80,"name":"Dragable graph","username":"Envy24","description":"Drag plot with mouse.\nSee BufferA and lines 84,85 in Image Tab.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["template","implicit","plotter","drag","graphs","explicit","dragable"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y) ) functions. */\n#define ORIGIN                    ( vec2(0) )\n#define UNIT                      ( 4.0*SCENE_SCALE / iResolution.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    NDC = fract(NDC); NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, L2_norm = sqrt(1.0 + dfdx * dfdx);\n    return SMAA(abs(sdf) / L2_norm);\n    //return SMAA(abs(sdf) / L2_norm - 0.05); // thick\n                           \n}\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / sqrt(grad.x*grad.x + grad.y*grad.y)); } // L2-norm\n//float draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / (abs(grad.x) + abs(grad.y))); }       // L1-norm\n//float draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / max(abs(grad.x), abs(grad.y))); }     // Linf-norm\n//float draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / sqrt(grad.x*grad.x + grad.y*grad.y) - 0.05); } // thick\n// e.t.c.\n// variants with fwidth                                                                       fwidth\n//float draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / (abs(grad.x) + abs(grad.y))); }\n//float draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / (fwidth(fxy)*120.)); }\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale - origin;\n}\n\n// Explicit function definition.\nfloat explicit(float x) { return x*x; }  // Just redefine this.\nfloat explicit_dydx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return ( explicit(x+dx) - explicit(x-dx) ) / (2.*dx);\n    /* Analytic derivative. *\n    return -M*sin(M*x);\n    /**/\n}\n//vec2 explicit_tangent(float x) { return vec2(1., explicit_dydx(x)); }\n//vec2 explicit_gradient(float x) { return vec2(1., explicit_dydx(x)); }\n//vec2 explicit_normal(float x) { vec2 T = explicit_tangent(x); return vec2(-T.y, T.x); }\n\n// Implicit function definition.\nfloat implicit(float x, float y)  // Just redefine this.\n{ \n    vec2 offset = texelFetch(iChannel0, ivec2(0), 0).zw;\n    return sin(2.*x*offset.x*.1)*sin(2.*x)*sin(2.*x) + 4.*cos(y)*sin(y)*sin(y) - 3.*sin(2.*x)*sin(y); \n}\nfloat delf_delx(float x, float y)\n{ \n    /* Numeric derivative. */\n    const float dx=0.001;\n    return ( implicit(x+dx, y)-implicit(x-dx, y) ) / (2.*dx);\n    /* Analytic derivative. *\n    return 2.*x;\n    /**/\n}\nfloat delf_dely(float x, float y) \n{ \n    /* Numeric derivative. */\n    const float dy=0.001;\n    return ( implicit(x, y+dy)-implicit(x, y-dy) ) / (2.*dy);\n    /* Analytic derivative. *\n    return 2.*y;\n    /**/\n}\nvec2 implicit_gradient(float x, float y) { return vec2(delf_delx(x, y), delf_dely(x, y)); }\n//vec2 implicit_normal(float x, float y) { return vec2(delf_delx(x, y), delf_dely(x, y)); }\n//vec2 implicit_tangent(float x, float y) { return vec2(delf_dely(x, y), -delf_delx(x, y)); }\n//float implicit_dydx(float x, float y) { return -delf_delx(x, y) / delf_dely(x, y); }\n//float implicit_deriv(float x, float y) { return -delf_delx(x, y) / delf_dely(x, y); }\n       \nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 offset = texelFetch(iChannel0, ivec2(0), 0).zw;\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, false) + offset;\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.8), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n\n    /* Explicit function y=f(x) */\n         color = mix(color, vec3(0,0,1), draw_explicit_func(NDC, explicit(NDC.x), explicit_dydx(NDC.x)));\n         \n    /* Implicit function f(x,y) */\n         color = mix(color, vec3(1,0,0), draw_implicit_func(NDC, implicit(NDC.x, NDC.y), implicit_gradient(NDC.x, NDC.y)));\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n#define LMB_CLICK_EVENT (iMouse.w > 0.)\n#define LMB_HOLD_EVENT (iMouse.z > 0.)\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    // Fetch old data.\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    \n    // Remap mouse coordinates \n    // from xy = [vec2(0,0), vec2(vpw, vph)] \n    // to [vec2(-SCENE_SCALE*AR, -SCENE_SCALE), vec2(SCENE_SCALE*AR, SCENE_SCALE)].\n    vec2 MP = iMouse.xy == vec2(0) ? vec2(0) :\n             map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false);\n       \n    // Mouse LMB state changed from RELEASE to HOLD?\n    if (LMB_CLICK_EVENT && LMB_HOLD_EVENT == true)\n    {\n        // Save mouse coordinates, and don't touch offset.\n        data.xy = MP;\n    }\n    // Mouse LMB state is HOLD?\n    else if (LMB_HOLD_EVENT == true)\n    {\n        // Calculate delta, save mouse coordinates, update offset.\n        vec2 delta = MP - data.xy; \n        \n        data.xy = MP;\n        data.zw -= delta;\n    }\n\n    // Update data.\n    O = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SCENE_SCALE               ( 5.0 )\n\nfloat circleSDF(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }","name":"Common","description":"","type":"common"}]}