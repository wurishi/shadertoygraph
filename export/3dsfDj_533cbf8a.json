{"ver":"0.1","info":{"id":"3dsfDj","date":"1589830536","viewed":242,"name":"Hip-Flop!","username":"shau","description":"Started of as an attempt at s Hip-Hop/Graffiti style tag ","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define S(a, b, v) smoothstep(a, b, v)\n#define EPS .003\n#define FAR 20.\n#define T iTime\n#define PI 3.14159\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec3 h3(vec3 p) \n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z) * UI3;\n\treturn vec3(q) * UIF;\n}\n\nfloat h1(float p) \n{\n\tvec3 x  = fract(vec3(p) * .1031);\n    x += dot(x, x.yzx + 19.19);\n    return fract((x.x + x.y) * x.z);\n}\n\nvec3 hash31(float p) \n{\n   vec3 p3 = fract(vec3(p) * vec3(443.8975,397.2973, 491.1871));\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\nvec3 n13(float n) \n{\n    float f = fract(n);\n    n = floor(n);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(hash31(n), hash31(n + 1.0), f);\n}\n\n//Shane IQ\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0.,s.yz,s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h)*43758.5453),fract(sin(h + s.x)*43758.5453),p.x);\n    h.xy = mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\nfloat noise(vec2 uv, float s1, float s2, float t1, float t2, float c1) \n{\n\treturn clamp(h3(vec3(uv.xy * s1, t1)).x +\n\t\t         h3(vec3(uv.xy * s2, t2)).y, \n                 c1, \n                 1.);\n}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796,0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr,0.,1.);\n}\n\n//SDFs - IQ\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArc(vec2 p, vec2 sca, vec2 scb, float ra, float rb)\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat smax(float a, float b, float k) \n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat dfS3DPart(vec3 p)\n{\n    vec3 q = p;\n    q.y *= 2.0;\n\tfloat t = sdCappedCylinder(q,2.0,0.5); \n    q.xy *= rot(0.5);\n    float l = max(0.0,p.y - 0.2)*max(0.0,p.y - 0.2)*-0.2*sign(q.z);\n    t = min(t, sdBox(q - vec3(1.0,1.0,0.0), vec3(1.0,1.8,0.5 + l)));\n    q = p;\n    q.y *= 4.0;\n\tt = max(t, -sdCappedCylinder(q - vec3(0.0,-1.4,0.0),1.2,5.0)); \n    q = p;\n    q.xy *= rot(0.3); \n    t = smax(t, -sdBox(q - vec3(1.7,0.0,0.0), vec3(1.0,4.0,2.0)),0.2);    \n    return max(t, -sdBox(p - vec3(1.0,-1.0,0.0), vec3(1.0,1.0,2.0)));\n}\n\nfloat dfS3D(vec3 p)\n{\n    p.xy *= rot(-0.5);\n    float t = dfS3DPart(p - vec3(0.0,0.825,0.0));\n    p.xy *= rot(PI);\n    return min(t, dfS3DPart(p - vec3(0.0,0.825,0.0)));\n}\n\nfloat dfH3D(vec3 p)\n{\n    float l = max(0.0,p.x*0.5 + 0.6)*max(0.0,p.x*0.5 + 0.6)*0.3;\n    float t = sdCappedCylinder(p - vec3(1.0,6.0,0.0),5.0,0.5 + l);  \n    vec3 q = p;\n    q.xy *= rot(0.1);\n    t = min(t, sdBox(q - vec3(-1.0,0.0,0.0), vec3(0.6,3.0,0.5)));\n    t = smax(t, -sdBox(p - vec3(-1.0,-3.0,0.0), vec3(2.0,1.0,1.0)),0.2);    \n    t = smax(t, -sdCappedCylinder(p - vec3(1.0,6.0,0.0),4.0,4.0),0.2);\n    t = smax(t, -sdBox(q - vec3(-3.4,0.0,0.0), vec3(2.0,10.0,1.0)),0.2);\n    t = smax(t, -sdBox(p - vec3(4.1,0.0,0.0), vec3(4.0,16.0,10.0)),0.2);\n    t = max(t, -sdBox(p - vec3(0.0,9.0,0.0), vec3(10.0,4.0,4.0)));\n    t = min(t, sdBox(p - vec3(1.0,0.0,0.0), vec3(0.5,2.0,0.5)));  \n    q = p;\n    l = max(0.0,p.x*-0.5)*max(0.0,p.x*-0.5)*0.3;\n    return min(t, sdBox(q - vec3(-0.5,-0.4,0.0), vec3(1.4,0.2,0.5 + l)));\n}\n\nfloat dfA3D(vec3 p)\n{\n \tfloat t = sdBox(p - vec3(-0.2,0.0,0.0), vec3(0.5,2.0,0.5));\n    float l = max(0.0,(p.x-2.5)*-1.0)*max(0.0,(p.x-2.5)*-1.0)*0.1;\n    t = min(t, sdBox(p - vec3(1.7,-1.6,0.0), vec3(0.9,0.6,0.5 + l)));\n    vec3 q = p;\n    q.xy *= rot(0.6);\n    t = min(t, sdBox(q - vec3(1.2,0.0,0.0), vec3(0.5,4.0,0.5)));\n    l = max(0.0,p.x+0.2)*max(0.0,p.x+0.2)*0.1;\n    t = min(t, sdBox(p - vec3(1.2,-0.4,0.0),vec3(1.6,0.2,0.5 + l)));\n    t = min(t, sdCappedCylinder(p - vec3(-1.0,6.0,0.0),5.0,0.5 + l));\n    t = smax(t, -sdCappedCylinder(p - vec3(-1.0,6.0,0.0),4.0,5.0),0.2);\n    t = smax(t, -sdBox(p - vec3(-3.5,0.0,0.0), vec3(3.0,16.0,5.0)),0.2); \n    t = smax(t, -sdBox(q - vec3(7.0,0.0,0.0), vec3(4.0,10.0,5.0)),0.2);\n    return smax(t, -sdBox(p - vec3(2.0,-3.0,0.0), vec3(4.0,1.0,2.0)),0.2);\n}\n\nfloat dfU3D(vec3 p)\n{\n    vec3 q = p;\n    q.xy *= rot(-0.3);\n    q.x *= 3.0;\n    float t = sdCappedCylinder(q - vec3(0.0,2.0,0.0),4.0,0.5);\n    t = min(t, sdBox(p - vec3(1.8,0.0,0.0), vec3(0.5,2.2,0.5)));\n    float l = max(0.0,(q.x + 2.0)*-0.5)*max(0.0,(q.x + 2.0)*-0.5)*0.1;\n    l = min(l, 2.0);\n    t = min(t, sdCappedCylinder(p - vec3(-5.0,6.0,0.0),6.5,0.5 + l));\n    t = smax(t, -sdCappedCylinder(p - vec3(-5.0,6.0,0.0),5.5,20.0),0.2);\n    t = smax(t, -sdCappedCylinder(q - vec3(1.0,2.0,0.0),2.0,1.0),0.2);\n    q = p;\n    q.xy *= rot(0.6);\n    t = smax(t, -sdBox(q - vec3(-5.4,6.0,0.0), vec3(4.0,6.0,10.0)),0.2);\n    return smax(t, -sdBox(p - vec3(-5.0,8.0,0.0), vec3(8.0,6.0,20.0)),0.2);\n}\n\nfloat dfS2DPart(vec2 uv)\n{\n    float t = sdSegment(uv, vec2(0.5,1.35), vec2(1.4,1.1));\n    t = min(t, sdSegment(uv, vec2(1.4,1.1), vec2(1.1,-0.0)));\n    uv *= rot(0.9);\n    uv.x *= 2.0;\n    return min(t, sdArc(uv, vec2(1.0,0.0),vec2(1.0,0.0), 1.3, 0.0));\n}\n\nfloat dfS2D(vec2 uv) \n{\n    float t = dfS2DPart(uv - vec2(0.0,0.8));\n    uv *= rot(PI);\n    return min(t, dfS2DPart(uv - vec2(0.0,0.8)));\n}\n\nfloat dfH2D(vec2 uv)\n{\n    float t = sdSegment(uv,vec2(-1.0,1.6),vec2(-1.0,-1.8));\n    t = min(t, sdSegment(uv,vec2(-1.6,-1.8),vec2(-1.0,-1.8)));\n    t = min(t, sdSegment(uv,vec2(-3.3,-1.8),vec2(-2.7,-1.8)));\n    t = min(t, sdSegment(uv,vec2(-3.4,-1.0),vec2(-3.3,-1.8)));\n    t = min(t, sdSegment(uv,vec2(-3.6,1.4),vec2(-3.5,0.3)));\n    t = min(t, sdSegment(uv,vec2(-4.0,-0.4),vec2(-1.4,-0.4)));\n    uv -= vec2(-2.0,4.7);\n    uv *= rot(-0.4);\n    return min(t, sdArc(uv, vec2(1.0,0.0),vec2(-0.45,1.0), 2.8, 0.));\n}\n\nfloat dfA2D(vec2 uv)\n{\n    float t = sdSegment(uv,vec2(0.0,1.8),vec2(0.0,-1.4));\n    t = min(t, sdSegment(uv,vec2(0.4,-0.4),vec2(2.8,-0.4)));\n    t = min(t, sdSegment(uv,vec2(1.4,-1.8),vec2(3.2,-1.8)));\n    t = min(t, sdSegment(uv,vec2(3.2,-1.8),vec2(2.65,-1.0)));\n    t = min(t, sdSegment(uv,vec2(1.25,1.1),vec2(1.8,0.3)));\n    uv.y -= 4.8;\n    uv *= rot(0.36);\n    return min(t, sdArc(uv, vec2(1.0,0.0),vec2(-0.4,1.0), 3.0, 0.));\n}\n\nfloat dfU2D(vec2 uv)\n{\n    vec2 quv = uv - vec2(0.0,1.1);\n    quv *= rot(-0.3);\n    quv.x *= 3.0;\n \tfloat t = sdArc(quv, vec2(1.0,0.0),vec2(-1.0,0.0), 2.8, 0.0);\n    t = min(t, sdSegment(uv, vec2(1.4,1.7), vec2(1.4,-1.8)));\n    t = min(t, sdSegment(uv, vec2(1.4,-1.8), vec2(0.9,-1.8)));\n    t = min(t, sdSegment(uv, vec2(-1.7,1.8), vec2(-0.6,1.8)));\n    quv = uv - vec2(-4.0,4.3);\n    quv *= rot(0.54);\n    return min(t, sdArc(quv, vec2(1.0,0.0),vec2(-0.24,1.0), 3.4, 0.));    \n}\n\nfloat map(vec3 p) \n{\n    float t = dfS3D(p - vec3(-5.2,0.0,0.0));\n    t = min(t, dfH3D(p - vec3(-2.3,0.0,0.0)));\n    t = min(t, dfA3D(p - vec3(0.2,0.0,0.0)));\n    t = min(t, dfU3D(p - vec3(4.4,0.0,0.0)));\n    return t -0.1;\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 p, vec3 n) \n{    \n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 12.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n \tfloat t = mint;\n    float res = 1.0;\n    for( int i=ZERO; i<256; i++ )\n    {\n     \tfloat h = map(ro + t*rd);\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.30);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\nfloat sparkles(vec2 uv)\n{\n    float t = length(uv - vec2(-3.9,1.9));\n    t = min(t, length(uv - vec2(-6.4,-2.0)));\n    t = min(t, length(uv - vec2(-1.0,1.7)));\n    t = min(t, length(uv - vec2(-4.1,-0.4)));\n    t = min(t, length(uv - vec2(-2.4,1.95)));\n    t = min(t, length(uv - vec2(1.9,2.5)));\n    t = min(t, length(uv - vec2(3.0,-0.4)));\n    t = min(t, length(uv - vec2(4.3,1.8)));\n    return min(t, length(uv - vec2(6.4,1.75)));\n}\n\nvec2 pol(vec3 rd)\n{\n    float a = (atan(rd.x,rd.y)/6.28318) + 0.5;\n\treturn vec2(a,floor(a*24.0)/24.0);  \n}\n\nvec3 bg3(vec3 rd, vec3 hu, float nz)\n{\n\tvec2 pa = pol(rd);\n    float m = mod(abs(rd.y) + h1(pa.y*sign(rd.z))*4. - T*.08, .3); \n    return hu*step(.1, fract(pa.x * 24.))*h1(pa.y)*step(m, .16)*m*50.0*rd.y*rd.y +\n           hu/(1.0 + rd.y*rd.y*1000.0)*nz;\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec2 uv = (U - R*.5) / R.y;\n    float fl = 1.4,\n          AT = mod(T, 40.),\n          nz = noise(uv, 64., 16., float(iFrame), float(iFrame), .96);\n    vec3 la = vec3(0),\n         lp = vec3(4,6,-5),\n         ro = vec3(0,sin(T*0.2),-8. - cos(T*0.4)*0.5),\n         hu = rotHue(vec3(1,0.1,0.2), T*0.1),\n         hu2 = rotHue(vec3(1,0.1,0.2), (T+6.0)*0.1);\n    ro.xz *= rot(sin(T*0.1)*0.2);\n    ro += 0.1*n13(T);\n    //camera\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x)),\n         rd = normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n    //background\n    float yy = rd.y*rd.y;\n    vec2 pa = pol(rd); \n    vec3 pc1 = (hu/(1.0 + yy*32.0) +\n                mix(hu,vec3(1),0.7)/(1.0 + yy*256.0)) * nz,\n         pc2 = (hu*yy*8.0 +\n\t            mix(hu,vec3(1),0.7)*yy*2.*clamp(nz,0.96,1.0)) * clamp(nz,0.98,1.0),\n         pc3 = bg3(rd,hu,nz),\n         pc4 = mix(mix(hu*nz,vec3(1),yy*4.0),\n                   hu,\n                   S(0.02, 0.0, length(fract(yy*6.0-T*0.4) - 0.5)) +\n                  (S(0.46, 0.5, fract(pa.x*24.0)) * S(0.54, 0.5, fract(pa.x*24.0))))*yy*8.;\n    //ray march\n    float t = 0.0;   \n    for (int i=ZERO; i<200; i++)\n    {\n        float ns = map(ro + rd*t);\n        if (abs(ns)<EPS) break;\n        t += ns *0.8;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    //render\n    if (t>0.0)\n    {\n        vec3 p = ro + rd*t,\n             n = normal(p),\n             rrd = reflect(rd,n),\n             ld = normalize(lp - p),\n             bgc = mix(hu,hu2,clamp((p.y*-1.)+sin(p.x*2.)*0.3,0.,1.));        \n        float ao = AO(p,n),\n              spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 8.0),\n              spec2 = max(dot(reflect(-ld, n), -rd), 0.0),\n              frs = pow(clamp(dot(n, rd) + 1.,0.,1.),1.),\n              sh = apprSoftShadow(p, ld, 0.01, FAR, 0.1),\n              spa = sparkles(p.xy);\n\n        float hg = dfS2D(p.xy - vec2(-5.2,0.0));\n        hg = min(hg, dfH2D(p.xy));\n        hg = min(hg, dfA2D(p.xy));\n        hg = min(hg, dfU2D(p.xy - vec2(5.0,0.0)));\n        \n        //neon\n        pc1 = hu*2.0 / (1.0 + hg*hg*100.6);\n        pc1 += hu2*max(0.0,n.y)*0.3;\n        pc1 += vec3(2) * spec;\n        pc1 *= ao;\n        \n        //hip-hop\n        pc2 = vec3(0.4,0.6,0.6) + bgc / (1. + hg*hg*0.6);\n        vec3 hg2 = mix(pc2,bgc,1.0/(1.0 + hg*hg*100.));\n        pc2 = mix(pc2,hg2,S(0.0,1.0,abs(p.y+0.4)));\n        pc2 = mix(pc2,bgc*2.0,1.0/(1.0 + spa*spa*6.0));\n        vec3 hg3 = mix(pc2, vec3(2), 1.0/(1.0 + hg*hg*400.));        \n        pc2 = mix(pc2,hg3,S(0.5,2.0,abs(p.y+0.4)));\n        pc2 *= max(0.05,dot(ld,n));\n        pc2 *= ao * sh;\n        pc2 += vec3(0.3)*(spec + spec2);\n        pc2 += vec3(1)/(1.0 + spa*spa*30.0);        \n\n        //dark reflection\n        pc3 = mix(mix(hu*0.4,vec3(0.2),0.4)*max(0.05,dot(ld,n)),\n                  bg3(rrd,hu,nz)*0.5,\n                  S(0.15,0.12,hg));\n        pc3 += hu2*max(0.0,n.y)*0.3;\n        pc3 += vec3(2)*spec;\n        pc3 *= ao*sh;\n        \n        //silver\n        pc4 = mix(hu,vec3(1),0.7)*max(0.,0.6+dot(ld,n)*0.4);\n        pc4 += hu2*max(0.0,n.y)*0.4;\n        pc4 += vec3(0.7)*spec2 + vec3(1)*spec;\n        pc4 *= ao*(0.6 + sh*0.4);\n        pc4 = mix(pc4,hu,1.0/(1.0 + hg*hg*60.));\n        pc4 += vec3(2) / (1.0 + hg*hg*1000.);\n        \n    }\n    //transitions\n    vec2 axy = fract((uv-0.5)*40.0) - 0.5;\n    vec3 pc = mix(pc1,pc2,step(length(axy),clamp(uv.y - (5. - AT),-0.1,1.4))); \n    pc = mix(pc4,pc,step(length(axy),clamp(length(uv) - (AT - 15.0),-0.1,1.4)));\n    pc = mix(pc3,pc,step(length(axy),clamp(uv.y - (-25. + AT),-0.1,1.4)));\n    pc = mix(pc1,pc,step(length(axy),clamp(length(uv) - (AT - 35.0),-0.1,1.4)));\n    pc *= 1. + sin(uv.y*800. + T)*0.02;\n    pc *= 1. + sin(uv.x*800. + T)*0.02;\n    \n    C = vec4(pc,1.0);\n}","name":"Image","description":"","type":"image"}]}