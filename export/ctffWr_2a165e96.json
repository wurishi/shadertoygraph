{"ver":"0.1","info":{"id":"ctffWr","date":"1692783408","viewed":60,"name":"pseudo-barycentric coordinates","username":"KeyJ","description":"Attempt at a computation of \"pseudo-barycentric\" coordinates that's easily generalizable to higher dimensions and vertex counts. Not at all suitable for texture mapping, as is turns out, but for pure color interpolation, it isn't too bad.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["triangle","barycentric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // generate two normalized square viewports\n    vec2 P = fragCoord / min(iResolution.y, iResolution.x * .5);\n    bool right = (P.x > 1.);\n    P = (fract(P) - .5) * 2.2;\n\n    // generate triangle\n    vec2 A = vec2(sin(iTime * .3 + 0.0), cos(iTime * .3 + 0.0));\n    vec2 B = vec2(sin(iTime * .4 + 2.1), cos(iTime * .4 + 2.1));\n    vec2 C = vec2(sin(iTime * .5 + 4.2), cos(iTime * .5 + 4.2));\n    float winding = (dot(C - A, vec2(B.y-A.y, A.x-B.x)) < 0.) ? -1. : 1.;\n\n    // compute edge SDFs to get outline\n    float eAB = winding * dot(P - A, vec2(B.y-A.y, A.x-B.x));\n    float eBC = winding * dot(P - B, vec2(C.y-B.y, B.x-C.x));\n    float eCA = winding * dot(P - C, vec2(A.y-C.y, C.x-A.x));\n    float inside = min(eAB, min(eBC, eCA));\n    inside /= fwidth(inside);\n    float outline = max(0., 1. - abs(inside - 0.5));\n\n    // compute barycentric coordinates\n    vec3 bary;\n    if (right) {\n        // RIGHT SIDE: pseudobarycentrics\n        const float exponent = 0.5;\n        const float epsilon = .001;\n        float longest = max(length(A - B), max(length(B - C), length(A - B))) ;\n        longest = 1. / (pow(longest,       exponent * 2.) + epsilon);\n        bary.r  = 1. / (pow(length(A - P), exponent * 2.) + epsilon);\n        bary.g  = 1. / (pow(length(B - P), exponent * 2.) + epsilon);\n        bary.b  = 1. / (pow(length(C - P), exponent * 2.) + epsilon);\n        if (max(bary.r, max(bary.g, bary.b)) < longest) {\n            // point is far outside the triangle -> approximate by closest point\n            if      (bary.r > max(bary.g, bary.b))    { bary = vec3(1.,0.,0.); }\n            else if (bary.g > max(bary.r, bary.b))    { bary = vec3(0.,1.,0.); }\n            else /* (bary.b > max(bary.r, bary.g)) */ { bary = vec3(0.,0.,1.); }\n        } else {\n            // clamp to longest axis\n            bary = max(vec3(0.), bary - longest);\n        }\n        bary *= 1. / (bary.r + bary.g + bary.b);\n    } else {\n        // LEFT SIDE: real barycentrics\n        // https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Vertex_approach\n        bary.r = B.x*C.y-C.x*B.y + (B.y-C.y)*P.x + (C.x-B.x)*P.y;\n        bary.g = C.x*A.y-A.x*C.y + (C.y-A.y)*P.x + (A.x-C.x)*P.y;\n        bary.b = A.x*B.y-B.x*A.y + (A.y-B.y)*P.x + (B.x-A.x)*P.y;\n        bary *= 1. / (A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y));\n    }\n    \n    // texturize while mouse button is pressed\n    if (iMouse.z > .5) {\n        bary = texture(iChannel0, vec2(bary)).rgb;\n    }\n\n    // final color mix\n    bary = clamp(bary, vec3(0.), vec3(1.));\n    inside = clamp(inside, 0., 1.);\n    fragColor = vec4(mix(vec3(bary) * mix(inside, 1., .5), vec3(1.), outline), 0.);\n}\n","name":"Image","description":"","type":"image"}]}