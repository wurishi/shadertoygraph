{"ver":"0.1","info":{"id":"tsKfRG","date":"1607678755","viewed":127,"name":"Chess piece - Rook","username":"Atchafalaya","description":"After binging The Queen's Gambit, I though that it would be fun to model chess pieces with SDFs. My second piece is a rook.\nStill working on lighting and post-processing.\nFeel free to comment if you have any advice :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","chess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define PI 3.1415\n#define FOCAL 2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - R.xy) / R.y;\n\n    vec2 angle = vec2(2.*iMouse.xy/R.xy - 1.) * vec2(3., -0.7);\n    angle.x += iTime;\n    mat3 rotCam = rot(angle);\n    vec3 ro = rotCam * vec3(0., 0., 4.);\n    ro += vec3(-1., 0., -1.);\n    vec3 rd = rotCam * normalize(vec3(uv, -FOCAL));\n    \n    vec3 mainLight = normalize(vec3(1.));\n    \n    float t;\n    RMResult s = raymarch(ro, rd, t);\n    vec3 p = ro + t * rd;\n    vec3 normal = gradient(p);    \n\n    vec3 sky = texture(iChannel0, rd).xyz;\n    vec3 col;\n    if (s.id < 0.)\n    {\n        // skybox\n        col = sky;\n    }\n    else if (s.id < 1.)\n    {\n        // board\n        if (abs(p.x) > 8. || abs(p.z) > 8.)\n        {\n            vec3 n = abs(normal);\n            vec2 fetch;\n            fetch = n.x > n.y && n.x > n.z ? vec2(0.5 * p.z, p.y) :\n            \t    n.y > n.z ? \t\t\t vec2(p.x, p.z) * 0.5:\n            \t\t\t\t\t\t\t   \t vec2(0.5 * p.x, p.y);\n            col = texture(iChannel1, fetch).xyz;\n        }\n        else\n        {\n            vec2 ss = sin(0.5 * PI * p.xz);\n            col = sign(ss.x) * sign(ss.y) < 0. ? vec3(0.05) : vec3(0.9);\n            col *= max(0.2, dot(normal, mainLight));\n        }\n    }\n    else if (s.id < 2.)\n    {\n        // chess piece\n        col = vec3(0.95, 0.95, 0.85) * max(0.2, dot(normal, mainLight));\n        col += 0.1 * max(0.0, dot(normal, -mainLight));\n        col += 0.1 * vec3(0.7, 0.43, 0.3) * max(0., dot(normal, vec3(0., 1., 0.)));\n    }\n\n    col = pow(col, vec3(0.5));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define I_MAX 1024\n#define FAR 1000.\n#define EPS 0.01\n#define PI 3.1415\n\n// ~~~~~~~~ CAMERA ~~~~~~~~\nmat3 rot(vec2 angle)\n{\n    vec2 cc = cos(angle);\n    vec2 ss = sin(angle);\n    return mat3(vec3(cc.x      , 0.  , ss.x      ),\n\t\t\t\tvec3(ss.x*ss.y , cc.y, -ss.y*cc.x),\n                vec3(-cc.y*ss.x, ss.y, cc.x*cc.y ));\n}\n\n// ~~~~~~~~ SDFs and operations ~~~~~~~~\n// SDFs from iq's website https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 o, float r, vec3 p)\n{\n    return length(p - o) - r;\n}\n\nfloat sdBox(vec3 b, vec3 p)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundedBox(vec3 b, float r, vec3 p)\n{\n\treturn sdBox(b, p) - r;\n}\n\nfloat sdHPlane(float h, vec3 p)\n{\n    return p.y - h;\n}\n\nfloat sdCappedCylinder(float h, float r, vec3 p)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 r, vec3 p)\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus(vec2 t, vec3 p)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat smax(float a, float b, float k)\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// ~~~~~~~~ Ray-marching algorithm ~~~~~~~~\nstruct RMResult{\n  \tfloat dist;\n    float id;\n};\n\nRMResult map(vec3 p)\n{\n    float d = FAR;\n    float id = -1.;\n    \n    {// board\n        float d0 = sdRoundedBox(vec3(8.2, 0.35, 8.2), 0.1, p - vec3(0., -1.5, 0.));\n        if (d0 < d)\n        {\n            d = d0;\n            id = 0.5;\n        }\n    }\n    {// rook\n\t\tp += vec3(1., 0., 1.);\n        float r = 0.4 + (pow(1. - p.y, 2.) / 8.);\n        float d0 = sdCappedCylinder(1., r, p);\n        vec3 p1 = p - vec3(0., 1.15, 0.);\n        float d1 = sdCappedCylinder(0.13, 0.52, p1) - 0.01;\n        d0 = smin(d0, d1, 0.15);\n        vec3 p2 = p - vec3(0., 1.25, 0.);\n        float d2 = sdCappedCylinder(0.1, 0.32, p2) - 0.08;\n        float a = mod(atan(p2.z, p2.x) + PI / 8., PI / 4.) - PI / 8.;\n        float l = length(vec2(p2.x, p2.z));\n        p2 = vec3(l * cos(a), p2.y, l * sin(a));\n        d2 = smin(d2, sdBox(vec3(0.65, 0.1, 0.06), p2), 0.02);\n        d0 = smax(d0, -d2, 0.03);\n        vec3 p3 = p - vec3(0., 0.935, 0.);\n        float d3 = sdEllipsoid(vec3(0.45, 0.1, 0.45), p3);\n        d0 = smin(d0, d3, 0.02);\n        vec3 p4 = p - vec3(0., -1., 0.);\n        float d4 = sdTorus(vec2(0.5, 0.45), p4);\n        d4 = max(d4, -sdHPlane(0., p4));\n        d0 = smin(d0, d4, 0.05);\n        float d5 = sdEllipsoid(vec3(0.8, 0.08, 0.8), p - vec3(0., -0.55, 0.));\n        d0 = smin(d0, d5, 0.05);\n\t\tfloat d6 = sdTorus(vec2(0.66, 0.01), p - vec3(0., -0.45, 0.));\n        d0 = smax(d0, -d6, 0.05);\n\t\tfloat d7 = sdTorus(vec2(0.63, 0.01), p - vec3(0., -0.38, 0.));\n        d0 = smax(d0, -d7, 0.05);\n        if (d0 < d)\n        {\n            d = d0;\n            id = 1.5;\n        }\n    }\n    \n    return RMResult(d, id);\n}\n\nvec3 gradient( vec3 p )\n{\n    float h = EPS * EPS;\n    vec2 k = vec2(1,-1);\n    return normalize( k.xyy * map(p + k.xyy * h).dist + \n                      k.yyx * map(p + k.yyx * h).dist + \n                      k.yxy * map(p + k.yxy * h).dist + \n                      k.xxx * map(p + k.xxx * h).dist );\n}\n\nRMResult raymarch(vec3 ro, vec3 rd, out float t)\n{\n\tt = 0.;\n    vec3 p = ro + t * rd;\n    RMResult s = RMResult(-1., FAR);\n    for(int i = 0; i < I_MAX; i++)\n    {\n\t\ts = map(p);\n        if (t + s.dist < FAR && abs(s.dist) > EPS) \n        {\n\t\t\tt += s.dist;\n\t        p = ro + t * rd;\n\n        }\n        else\n        {\n            if (t + s.dist > FAR)\n            {\n               s.id = -1.;\n            }\n            break;\n        }\n    }\n    return s;\n}\n","name":"Common","description":"","type":"common"}]}