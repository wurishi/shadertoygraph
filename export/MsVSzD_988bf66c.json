{"ver":"0.1","info":{"id":"MsVSzD","date":"1463422495","viewed":193,"name":"Raymarching stuff","username":"Egomeh","description":"Attempt to make a raymarcher. I feel like there are a lot of these out there XD","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n# define PI           3.14159265358979323846  /* pi */\n\nconst float EPS = 0.003;\nconst int ITERATIONS = 256;\nconst float FAR = 10.0;\n\n\n// STOLEN\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// END STOLEN\n\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat query(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    //float cube = length(max(abs(p)-0.5, 0.0));\n    \n    \n    float radius = 0.75;\n    float time = iTime * 0.5;\n    float tex0 = texture(iChannel1, vec2(0.5,0.1)).x * 2.0 * PI;\n    float tex1 = texture(iChannel1, vec2(0.5,0.2)).x * 2.0 * PI;\n    float tex2 = texture(iChannel1, vec2(0.5,0.3)).x * 2.0 * PI;\n    radius += cnoise(p.xz + vec2(sin(time), cos(time)) - vec2(p.y * 0.4) * clamp(0.0,1.0,sin(time)) );\n    \n    float sphere = length(p) - radius;\n   \n    return sphere;\n}\n\nvec3 gradient(vec3 p)\n{\n    vec3 px = p;\n    px.x += EPS;\n    \n    vec3 py = p;\n    py.y += EPS;\n    \n    vec3 pz = p;\n    pz.z += EPS;\n    \n    return normalize(vec3(\n        \t\t\tquery(px) - query(p),\n        \t\t\tquery(py) - query(p),\n                    query(pz) - query(p) )\n    );\n}\n\nfloat intersect(vec3 o, vec3 r, out int iterations, out vec3 p, out bool hit)\n{\n    hit = false;\n\tfloat t = 0.0;\n    for (int i = 0; i < ITERATIONS; ++i)\n    {\n\t\tp = o + r * t;\n        float d = query(p);\n        t += d * (0.4 + rand(p.xy) * EPS);\n        ++iterations;\n        if (d < EPS)\n        {\n            hit = true;\n        \tbreak;   \n        }\n        \n        if (t > FAR)\n        {\n            break;\n        }\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    uv = uv * 2.0 - 1.0;\n    uv.y = -uv.y;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    float theta = iTime * 0.1;\n    \n    vec3 rs = normalize(vec3(uv, 1.5));\n    float add_angle = PI / 2.0;\n    vec3 r = vec3(cos( (theta + add_angle) ) * rs.x - sin( (theta + add_angle) ) * rs.z,\n                  rs.y,\n                  sin( (theta + add_angle) ) * rs.x + cos( (theta + add_angle) ) * rs.z);\n    //r = rs;\n    \n    float x = cos(theta);\n    float y = sin(theta);\n    vec3 o = vec3(x, 0.0, y) * 3.0;\n    \n    \n    \n    bool hit;\n    vec3 pos;\n    int iterations = 0;\n    float t = intersect(o, r, iterations, pos, hit);\n    \n    float smoke = float(iterations) / float(ITERATIONS) * (1.0 - step(float(ITERATIONS), float(iterations)) );\n    smoke = clamp(smoothstep(0.0, 1.0, smoke * 0.9) * 3.0, 0.0, 1.0);\n    \n    vec3 col = vec3(0.0);//vec3(1.0 - log(t * 0.3) );\n    \n    \n    if (hit)\n    {\n        vec3 grad = gradient(pos);\n        \n        vec3 rout = reflect(r, grad);\n        \n        vec3 refl = texture(iChannel0, rout).xyz;\n        \n        float v1 = sin( (rout.x +iTime) * 5.0);\n    \tfloat v2 = sin( (rout.y +iTime) * 5.0);\n    \tfloat v3 = sin( (rout.x+grad.y +iTime) * 5.0);\n    \tfloat v4 = sin( (sqrt(rout.x*rout.x+rout.y*rout.y) +1.7*iTime) * 5.0);\n\t\tfloat v = v1+v2+v3+v4;\n        \n        vec3 diff = vec3(sin(v));\n        vec3 diffCol = mix(vec3(0.2,0.2,0.8), vec3(0.8, 0.2, 0.2), sin(v));\n        col += mix(refl, diffCol, 0.0);//max(dot(r, -rout),0.0));\n    }\n    else \n    {\n        col = texture(iChannel0, r).xyz;\n\t}\n    \n            \n    col = clamp(col, vec3(0), vec3(1));\n    col += vec3(0.9,0.1,0.4) * smoke;\n    \n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}