{"ver":"0.1","info":{"id":"wd3GDX","date":"1569365843","viewed":266,"name":"Sphere PBR","username":"tepSHATOY","description":"Sphere physically based rendering","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphere","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sphere PBR\n//\n// Concepts:\n//\n// * Albedo vs Reflectance:\n//   https://gis.stackexchange.com/questions/36726/difference-between-albedo-and-surface-reflectance\n//   Albedo is defined as the fraction of incident radiation that is reflected by a surface.\n//   While reflectance is defined as this same fraction for a single incidence angle, albedo\n//   is the directional integration of reflectance over all sun-view geometries\n//\n// * Hemispherical directional reflectance:\n//   http://www.pbr-book.org/3ed-2018/Reflection_Models/Basic_Interface.html\n//   total reflection in a given direction due to constant illumination over the hemisphere\n//   total reflection over the hemisphere due to light from a given direction\n//\n// * The hemispherical-hemispherical reflectance \n//   a spectral value that gives the fraction of incident light reflected by a surface when\n//   the incident light is the same from all directions.\n//\n// * Anisotropy\n//   To form anisotropic distribution, the roughness is varied with Phi and\n//   this affects D and G. Note that split sum approximation for envmap is also affected.\n//\n//   References:\n//   * Physically Based Shading at Disney by Burley [SIGGRAPH 2012]\n//     https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf\n//   * Implementing Fur Using Deferred Shading by Don Revie [GPU Pro 2]\n//   * Rendering the World of Far Cry 4 by Steven McAuley [GDC 2015]\n//     http://twvideo01.ubm-us.net/o1/vault/gdc2015/presentations/McAuley_Stephen_Rendering_the_World.pdf\n//   * Physically Based Materials Where We Are by Sebastien Lagarde\n//     https://seblagarde.wordpress.com/2017/09/09/siggraph-2017-physically-based-materials-where-are-we/\n//   * https://forums.unrealengine.com/development-discussion/rendering/19649-anisotropy-material/page2   \n//\n// TODO:\n// * Height Correlated G\n\n\n///////////////////////////////////////////////////////////////////////\n// Constants\n///////////////////////////////////////////////////////////////////////\nconst float kInf        = 1e16f; // some random max distance..\nconst float kPi         = 3.14159265358979323846264338327950288;\nconst vec3  kWorldUp    = vec3(0.0, 1.0, 0.0);\nconst vec3  F0_nonmetal = vec3(0.04);\nconst vec3  F0_gold     = vec3(1.00, 0.71, 0.29);\nconst vec3  F0_silver   = vec3(0.95, 0.93, 0.88);\nconst vec3  F0_iron     = vec3(0.56, 0.57, 0.58);\n\n\n///////////////////////////////////////////////////////////////////////\n// Features\n///////////////////////////////////////////////////////////////////////\n#define MTL_ANISOTROPIC\t\t1\n\n///////////////////////////////////////////////////////////////////////\n// Types\n///////////////////////////////////////////////////////////////////////\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n\tvec3  center;\n\tfloat radius;\n};\n\nstruct Light\n{\n    vec3 dir;\n    vec3 color;\n    float atten;\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 F0;\n    float gloss;\n#if MTL_ANISOTROPIC    \n    float anisotropy; // degree of anisotropy (0 = isotropic, 1 = maximally anisotropic)\n#endif\n};    \n\nstruct HitRecord\n{\n    vec3 p;\n    vec3 t;\n    vec3 b;\n    vec3 n;\n    Material mtl;\n};\n\nstruct Polar\n{\n    float theta;\n    float phi;\n};\n\nstruct Scene\n{\n    Polar light;\n    vec3  lightColor;\n    \n    Sphere sphere;\n    Material sphereMaterial;\n};\n\n///////////////////////////////////////////////////////////////////////\n// Utils\n///////////////////////////////////////////////////////////////////////\nvec3 LinearToGammaSrgb( vec3 linColor )\n{    \n\tlinColor.r = ( linColor.r <= 0.0031308 ) ? ( 12.92 * linColor.r ) : ( 1.055 * pow( linColor.r, 1.0f/2.4 ) - 0.055 );\n    linColor.g = ( linColor.g <= 0.0031308 ) ? ( 12.92 * linColor.g ) : ( 1.055 * pow( linColor.g, 1.0f/2.4 ) - 0.055 );\n\tlinColor.b = ( linColor.b <= 0.0031308 ) ? ( 12.92 * linColor.b ) : ( 1.055 * pow( linColor.b, 1.0f/2.4 ) - 0.055 );\n    return linColor;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat chi(float x)\n{\n    return x > 0.0 ? 1.0 : 0.0;\n}\n\nfloat rsqrt(float x)\n{\n    return 1.0 / sqrt(x);\n}\n\nfloat rcp(float x)\n{\n    return 1.0 / x;\n}\n\nfloat max3(float a, float b, float c)\n{\n    return max(max(a,b),c);\n}\n\nfloat Discretize(float x, float steps)\n{\n    return floor(x * steps) / steps + 1.0 / (2.0 * steps);\n}\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return mix(a, b, t);\n}\n\n// References:\n// * GPU Pro 2, Don Revie - Implementing Fur Using Deferred Shading\n// * GDC 2015, Steven McAuley - Rendering the World of Far Cry 4 pg. 19\n//   http://twvideo01.ubm-us.net/o1/vault/gdc2015/presentations/McAuley_Stephen_Rendering_the_World.pdf\n//\n// Direction used for fetching envmap\nvec3 reflect_aniso(vec3 v, vec3 n, vec3 t, float anisotropy)\n{\n    vec3 anisotropicTangent = cross(v, t);\n    vec3 anisotropicNormal  = cross(anisotropicTangent, t);\n    vec3 reflectionNormal   = normalize(lerp(n, anisotropicNormal, anisotropy));\n    vec3 reflectionDir      = v - 2.0 * dot(reflectionNormal, v) * reflectionNormal;\n    return reflectionDir;\n}\n\n///////////////////////////////////////////////////////////////////////\n// Intersection\n///////////////////////////////////////////////////////////////////////\nfloat RaySphereIntersect(Ray r, Sphere sphere, float tmin)\n{\n    vec3 oc = r.origin - sphere.center;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(oc, r.dir);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n    float discriminant = b * b - 4.0 * a*c;\n\n    if (discriminant > 0.0)\n    {\n        float t = (-b - sqrt(discriminant)) / (2.0 * a);\n        if (tmin < t)\n            return t;\n    }    \n    return -1.0;\n}\n\n///////////////////////////////////////////////////////////////////////\n// Scene\n///////////////////////////////////////////////////////////////////////\nScene Scene_Setup()\n{\n    Scene scene;\n    scene.light.theta = 0.0;\n    scene.light.phi = sin(iTime) * 135.0;\n    scene.lightColor = vec3(1.0);\n    \n    scene.sphere.center = vec3(0, 0, 2);\n\tscene.sphere.radius = 1.3;\n    \n    scene.sphereMaterial.albedo     = vec3(0.18);\n    scene.sphereMaterial.F0         = F0_iron;//F0_nonmetal;\n    scene.sphereMaterial.gloss      = 0.5;\n#if MTL_ANISOTROPIC    \n    scene.sphereMaterial.anisotropy = 0.7;\n#endif\n    \n    return scene;\n}\n\nLight Scene_GetLight(Scene scene, uint lightIndex, vec3 p)\n{\n    float theta_l = radians(-(90.0f + scene.light.theta));\n    float phi_l   = radians(-(180.0f + scene.light.phi));\n    \n    Light light;\n    light.dir.x = sin(phi_l) * cos(theta_l);\n    light.dir.y = sin(phi_l) * sin(theta_l);\n    light.dir.z = cos(phi_l);\n    \n    light.color = scene.lightColor;\n    \n    // directional light has no attenuation\n    light.atten = 1.0;\n\n    return light;\n}\n    \nbool Scene_RayTrace(Scene scene, Ray r, inout HitRecord hitRecord)\n{\n    float xmin = kInf;\n    \n    // for each Sphere s\n\tSphere s = scene.sphere;\n    {\n        float x = RaySphereIntersect(r, s, 0.0);\n        if (x > 0.0 && x < xmin)\n        {\n            xmin = x;\n            \n            vec3 p = r.origin + x * r.dir;\n            vec3 n = normalize(p - s.center);\n            vec3 t = cross(kWorldUp, n);\n            vec3 b = normalize(cross(n, t));            \n            hitRecord.p = p;\n            hitRecord.t = t;\n            hitRecord.b = b;\n            hitRecord.n = n;\n            hitRecord.mtl = scene.sphereMaterial;\n        }\n    }\n    return (xmin < kInf);\n}\n\n///////////////////////////////////////////////////////////////////////\n// BRDF\n///////////////////////////////////////////////////////////////////////\nfloat BRDF_DiffuseLambert()\n{\n    return 1.0 / kPi;\n}\n\nfloat Alpha2FromGloss(float gloss)\n{\n    float roughness = 1.0 - gloss;\n    float alpha     = roughness * roughness;\n    float alpha2    = alpha * alpha;\n    return alpha2;\n}\n\n// cosAngle = dot(H, V) = dot(H, L)\nvec3 F_Schlick(vec3 F0, float cosAngle)\n{\n    float oneMinusCosAngle = 1.0 - cosAngle;\n    float oneMinusCosAngle2 = oneMinusCosAngle * oneMinusCosAngle;\n    float oneMinusCosAngle5 = oneMinusCosAngle2 * oneMinusCosAngle2 * oneMinusCosAngle;\n    return F0 + (vec3(1.0) - F0) * oneMinusCosAngle5;\n}\n\nfloat D_GGX(float NoH, float NoH2, float alpha2)\n{\n    float denom0 = NoH2 * alpha2 + (1.0 - NoH2);\n    float denom  = kPi * denom0 * denom0;\n    float numer  = chi(NoH) * alpha2;\n    return numer / denom;\n}\n\nfloat D_GGX_Aniso(float ToH2, float BoH2, float NoH2, float alpha_x2, float alpha_y2, float alpha_xy)\n{\n\t// D term for anisotropic GGX can be found in appendix B\n    //                                                          1.0\n    // D_GGX_Aniso = -----------------------------------------------------------------------------------------\n    //                ( Pi * alpha_x * alpha_y ) * ( (t.h)^2 / alpha_x^2 + (b.h)^2 / alpha_y^2 + (n.h)^2 )^2\n    //\n    float denom0   = (ToH2 / alpha_x2 + BoH2 / alpha_y2 + NoH2);\n    float denom    = (kPi * alpha_xy) * denom0 * denom0;\n    \n    return rcp( denom );\n}\n\n// dp can be NoV or NoL\n// NoV - masking function\n// NoL - shadowing function\nfloat G1_GGX(float dp, float alpha2)\n{\n    // generalized form of Smith masking function\n    // G1(Wo, Wm) = Chi(Wo.Wm) / ( 1 + lambda(Wo) )\n    \n    // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n    return 2.0 * dp / (dp + sqrt(alpha2 + (1.0 - alpha2)*dp*dp));\n}\n\nfloat G1_GGX_Aniso(float NoM, float ToM, float alpha_x2, float alpha_y2)\n{\n    float NoM2 = NoM * NoM;\n    float ToM2 = ToM * ToM;\n    float BoM2 = 1.0 - NoM2 - ToM2;\n    return 2.0 * NoM / (NoM + sqrt(ToM2 * alpha_x2 + BoM2 * alpha_y2 + NoM2));\n}\n\nfloat G2_SmithGGX(float NoL, float NoV, float alpha2)\n{\n    //              -1 + sqrt(1 + 1/a^2)\n    // Lambda(m) = ----------------------\n    //                       2\n    //\n    // a = 1 / alpha * tan(theta)\n    //\n    // Uncorrelated (separable)\n    //\n    //                            Chi(NoV)          Chi(NoL)\n    // G2(NoV, NoL, alpha2) = --------------- * ---------------\n    //                         1 + Lambda(V)     1 + Lambda(L)    \n    return G1_GGX(NoL, alpha2) * G1_GGX(NoV, alpha2);\n    \n    // Height Correlated\n    //\n    //                            Chi(NoV) * Chi(NoL)\n    // G2(NoV, NoL, alpha2) = ---------------------------\n    //                         1 + Lambda(V) + Lambda(L)\n}\n\nfloat G2_SmithGGX_Aniso(float NoL, float ToL, float NoV, float ToV, float alpha_x2, float alpha_y2)\n{\n    // Uncorrelated (separable)\n    return G1_GGX_Aniso(NoL, ToL, alpha_x2, alpha_y2) * G1_GGX_Aniso(NoV, ToV, alpha_x2, alpha_y2);\n}\n\nvec3 BRDF_SpecularCookTorrance_GGXSmith(float NoL, float NoV, float NoH, vec3 F, float gloss)\n{\n    //                            D F G\n    // Cook Torrance = -----------------------------\n    //                  4.0 * dot(N, V) * dot(N, L)\n    float alpha2 = Alpha2FromGloss(gloss);\n\n    // D term - GGX\n    float NoH2 = NoH * NoH;\n    float D    = D_GGX(NoH, NoH2, alpha2);\n        \n    // G term - Uncorrelated height\n    float G    = G2_SmithGGX(NoL, NoV, alpha2);\n\n    vec3 sBRDF = D * F * G / (4.0 * NoV * NoL);\n    \n    return sBRDF;\n}\n\nvec3 BRDF_SpecularCookTorrance_GGXSmith_OPT(float NoL, float NoV, float NoH, vec3 F, float gloss)\n{\n    //                            D F G\n    // Cook Torrance = -----------------------------\n    //                  4.0 * dot(N, V) * dot(N, L)\n    //\n    // Optimization:\n    // * Numerator of G term cancels out 4.0 * dot(N, V) * dot(N, L)\n    // * Save division by combining DG term\n    //\n    float alpha2 = Alpha2FromGloss(gloss);\n    \n    // D term - GGX\n    float NoH2         = NoH * NoH;\n\tfloat D_GGX_denom0 = NoH2 * alpha2 + (1.0 - NoH2);    \n    float D_GGX_denom  = kPi * D_GGX_denom0 * D_GGX_denom0;\n    float D_GGX_numer  = alpha2; // Removing chi(NoH) doesn't seem to give any difference\n\n    // G term - Smith GGX Uncorrelated height\n    float G1_GGX_L_denom = (NoL + sqrt(alpha2 + (1.0 - alpha2)*NoL*NoL));\n    float G1_GGX_V_denom = (NoV + sqrt(alpha2 + (1.0 - alpha2)*NoV*NoV));\n        \n    float DG = D_GGX_numer * rcp(D_GGX_denom * G1_GGX_L_denom * G1_GGX_V_denom);\n\n    vec3 sBRDF = DG * F;\n    \n    return sBRDF;\n}\n\nvec3 BRDF_SpecularCookTorrance_AnisoGGXSmith(float NoL, float ToL, float NoV, float ToV, float NoH, float ToH, vec3 F, float gloss, float anisotropy)\n{\n    // Anisotropic Parameterization    \n    // alpha_x  = alpha_y * anisoAspect\n    float anisoAspect = max(1.0 - anisotropy, 0.001);\n    float alpha_y2    = Alpha2FromGloss(gloss);\n    float alpha_x2    = alpha_y2 * (anisoAspect * anisoAspect);\n\tfloat alpha_xy    = alpha_y2 * anisoAspect;\n        \n    // D term - Aniso GGX\n    float NoH2 = NoH * NoH;\n    float ToH2 = ToH * ToH;\n    float BoH2 = 1.0 - NoH2 - ToH2;\n\tfloat D    = D_GGX_Aniso(ToH2, BoH2, NoH2, alpha_x2, alpha_y2, alpha_xy);\n    \n    // G term - Uncorrelated height\n    float G = G2_SmithGGX_Aniso(NoL, ToL, NoV, ToV, alpha_x2, alpha_y2);\n    \n    vec3 sBRDF = D * F * G / (4.0 * NoV * NoL);\n    \n    return sBRDF;    \n}\n\n\nfloat GetTransmittance( vec3 fresnel )\n{\n\treturn 1.0 - max3( fresnel.x, fresnel.y, fresnel.z );\n}\n\n///////////////////////////////////////////////////////////////////////\n// Closest Hit Shader\n///////////////////////////////////////////////////////////////////////\nvec3 ClosestHit(HitRecord hitRecord, Scene scene)\n{\n    // material\n    Material m = hitRecord.mtl;\n    vec3 b     = hitRecord.b;\n    vec3 n     = hitRecord.n;\n    //vec3 t     = normalize(hitRecord.t + n * (m.eccentricity * aniso_shift_param));\n    vec3 t     = hitRecord.t;\n    vec3 p     = hitRecord.p;\n    \n    // viewer\n    vec3  v   = normalize(vec3(0.0) - p);\n    float NoV = dot(n, v);\n\n    // shading\n    vec3 radiance = vec3(0.0);\n    \n    // for each light\n    //for (uint lightIndex = 0u; lightIndex < scene.lightCount; lightIndex++)\n    uint lightIndex = 0u;\n    {\n        Light light = Scene_GetLight(scene, lightIndex, p);\n        vec3  l     = light.dir;\n        float NoL   = dot(n, l);\n        \n#if MTL_ANISOTROPIC\n        vec3 h     = normalize(l + v);\n        float NoH  = dot(n, h);\n        float ToH  = dot(t, h);\n        float ToL  = dot(t, l);\n        float ToV  = dot(t, v);\n        float LoH  = dot(l, h);\n#else\n        // For isotropic material, we don't really need to calculate H directly\n        // https://twvideo01.ubm-us.net/o1/vault/gdc2017/Presentations/Hammon_Earl_PBR_Diffuse_Lighting.pdf\n        //\n        // h = (l + v) / |l + v|\n        //\n        // |l + v|^2 = (l + v).(l + v)\n        //           = l.l + l.v + v.l + v.v\n        //           = 2 + 2 * l.v\n        //\n        // rcpLen_LV = 1.0 / |l + v| = rqsrt(2 + 2 * l.v);\n        //\n        // n.h = (n.l + n.v) * rcpLen_LV\n        //\n        // l.h = l . (( l + v ) / |l + v|)\n        //     = (l.l + l.v) / |l + v|\n        //     = (1 + l.v) / |l + v|\n        //     = (1 + l.v) * rcpLen_LV\n        //\n        float LoV   = dot(l, v);\n        float rcpLen_LV = rsqrt(2.0 + 2.0 * LoV);\n        float NoH   = (NoL + NoV) * rcpLen_LV;\n        float LoH   = (1.0 + LoV) * rcpLen_LV;\n#endif        \n        // for each interface top to bottom\n        {\n            float NoL_sat = saturate(NoL);\n            vec3  Li_cos  = light.color * (light.atten * NoL_sat);\n\n\t\t    // Fresnel term - Schlick\n    \t\tvec3  F       = F_Schlick(m.F0, LoH);//NoV);\n            \n            // https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch14.html\n            // Approximation for rho_dt to tell how much energy is left for diffuse\n            float rho_dt = 1.0 - max3(F.r, F.g, F.b);            \n                        \n            // diffuse shading\n            vec3 dBRDF    = vec3(BRDF_DiffuseLambert());\n            vec3 diffuse  = Li_cos * dBRDF * rho_dt;\n\n            // specular shading\n#if MTL_ANISOTROPIC\n            vec3 sBRDF    = BRDF_SpecularCookTorrance_AnisoGGXSmith(NoL, ToL, NoV, ToV, NoH, ToH, F, m.gloss, m.anisotropy);\n#else\n            vec3 sBRDF    = BRDF_SpecularCookTorrance_GGXSmith_OPT(NoL, NoV, NoH, F, m.gloss);\n#endif\n            vec3 specular = Li_cos * sBRDF;\n\n            radiance += diffuse * m.albedo + specular;        \n        }\n    }\n    \n    return radiance;\n}\n\nRay Ray_Setup(vec2 screenCoord)\n{\n\tvec2 uv = screenCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n        \n    Ray r;\n    r.origin = vec3(0.0);\n    r.dir = normalize(vec3(uv.x, uv.y, 1.0));\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray r = Ray_Setup(fragCoord);\n\n    Scene scene = Scene_Setup();\n\n    // default is sky color\n    vec3 radiance = vec3(0.0f);\n    \n    HitRecord hitRecord;\n    if (Scene_RayTrace(scene, r, hitRecord))\n    {        \n\t\tradiance = ClosestHit(hitRecord, scene);\n\t}\n    \n    fragColor.rgb = LinearToGammaSrgb(radiance);\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}