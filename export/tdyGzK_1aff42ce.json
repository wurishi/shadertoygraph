{"ver":"0.1","info":{"id":"tdyGzK","date":"1570631309","viewed":499,"name":"Flight through a nebula","username":"Delvar","description":"Simple fly though of a 3d voronoi via ray marching added lightning, mouse to look around.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","raymarch","cloud","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// also see \n// voronoi  version, https://www.shadertoy.com/view/tdyGzK\n// simplex version, https://www.shadertoy.com/view/WsG3zd\n// box version, https://www.shadertoy.com/view/tsK3Rd\n\n#define RAY_MAX_STEPS 30\n#define RAY_MAX_DISTANCE 10.0\n#define RAY_CAMERA_FADE_START_DISTANCE 0.5\n#define RAY_CAMERA_FADE_END_DISTANCE 2.0\n#define RAY_MAX_STEPS_SHADOW 15\n\n#define K\t0.1428571428571429\t// 1/7\n#define Ko\t0.3571428571428571\t// 1/2-(K/2)\n#define K2\t0.0204081632653061\t// 1/(7*7)\n#define Kz\t0.1666666666666667\t// 1/6\n#define Kzo\t0.4166666666666667\t// 1/2-(1/(6*2))\n#define Km\t0.0034602076124567\t// 1/289\n#define PI\t3.1415926535897932384626433832795\n    \n\nstruct camera {\n   vec3 origin, forward, right, up;\n   float zoom; // Distance from screen\n};\n\nstruct ray {\n   vec3 origin, direction;\n};\n       \ncamera getCameraDirection(vec3 origin, vec3 direction, float zoom) {\n   camera camera;\n   camera.origin = origin;\n   camera.forward = normalize(direction);\n   camera.right = cross(vec3(0.0,1.0,0.0), camera.forward);\n   camera.up = cross(camera.forward, camera.right);\n   camera.zoom = zoom;\n   return camera;\n}\n\nray getRay(vec2 uv, camera camera) {\n\tray ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n\treturn ray;   \n}\n\nfloat mod289(float x) {\n\treturn x - floor(x * Km) * 289.0;\n}\n\nfloat mod7(float x) {\n\t//return x;\n\treturn x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n//Wrap around for id generation\nfloat wrap(float x) {\n\t//return mod((34.0 * x + 1.0) * x, 289.0);\n    return mod289((34.0 * x + 1.0) * x);\n}\n\nvec3 idToPoint(vec3 id) {\n    vec3 point;\n    point.x = fract(id.z * K) - Ko;\n\t//point.y = mod(floor(id.z * K),7.0) * K - Ko;\n    point.y = floor(id.z * K) * K - Ko;\n\tpoint.z = floor(id.z * K2) * Kz - Kzo;\n    return point;\n}\n\nfloat voronoiNoiseDistance(vec3 samplePoint){\n    vec3 pointI = mod(floor(samplePoint),289.0);\n    vec3 pointF = fract(samplePoint);\n\n    float minDistance= 9999.0;\n    vec3 id;\n    vec3 offset;\n    \n    for(float i=-1.0;i<=1.0;i++) {\n        offset.x = i;\n        id.x= wrap(pointI.x + i);\n\t\tfor(float j=-1.0;j<=1.0;j++) {\n            offset.y=j;\n            id.y = wrap(id.x + pointI.y + j);\n            for(float k=-1.0;k<=1.0;k++) {\n                offset.z=k;\n            \tid.z = wrap(id.y + pointI.z + k);\n                vec3 pointFract = fract(idToPoint(id));\n                vec3 pointPos = pointFract + offset;\n                vec3 dPosition = pointF - pointPos;\n                float squareDistance = dot(dPosition,dPosition);\n    \t\t\tminDistance = min(minDistance, squareDistance);\n\t\t\t}\n\t\t}\n\t}\n\treturn  clamp(minDistance,0.0,1.0);\n}\n\nvec3 RayMarch(ray ray, float maxDistance, int maxSteps)\n{\n    float maxStepsf = float(maxSteps);\n    float stepSize = maxDistance/maxStepsf;\n    vec3 total = vec3(0.0);\n    \n    // Stop the shimmering??\n    float currentDistance = stepSize-(ray.origin.z-(floor(ray.origin.z/stepSize)*stepSize));\n    \n    float strike = 1.0+smoothstep(0.5,1.0,sin(ray.direction.z+iTime*20.0)*sin(ray.direction.x +iTime*30.0)*cos(ray.direction.y +iTime*40.0)*(wrap(iTime)/289.0));\n    \n    for(float i=0.0; i<maxStepsf; i++) {\n\t\tvec3 currentPoint = ray.origin + ray.direction * currentDistance;\n        float s = voronoiNoiseDistance(currentPoint);\n        s=smoothstep(0.1,1.0,s);\n        float stepf = ((maxStepsf - i)/maxStepsf);\n        s *= stepf;\n        vec3 light = sin((currentPoint+vec3(iTime/10.0,iTime/13.0,iTime/15.0))/4.0)*0.5+1.0; //Yes we blow out the colour a little.\n        total += light*s;\n        currentDistance += stepSize;\n    }\n    return (total*(3.0/maxStepsf))*strike;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized Pixel coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    // Normalized Mouse coordinates (from -0.5 to +0.5, center at 0,0)\n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);// - vec2(0.5,0.5)*(iMouse.w*0.1);\n    //Snap to center on startup.\n    if(iMouse.x <= 1.0 && iMouse.y <= 1.0) {\n        mouse = vec2(0.0,0.0);\n    }\n\n    // -- 1st person cammera\n    vec3 forward = vec3(\n        sin(mouse.x*PI),\n    \tsin(mouse.y*PI),\n    \tcos(mouse.x*PI)\n    );\n    camera camera = getCameraDirection(vec3(0.0,0.0,iTime), forward, 0.5);\n    \n    ray ray = getRay(uv, camera);\n\tvec3 colour = RayMarch(ray, RAY_MAX_DISTANCE, RAY_MAX_STEPS);\n    float gamma = 0.8;\n    colour = pow(colour, vec3(1.0/gamma));\n    \n    fragColor = vec4(colour,1.0);\n\n   \n  /*  \n    vec3 samplePosition = vec3(uv.xy*4.0,iTime*0.1);\n    vec3 samplePositionf = fract(samplePosition);\n    float s = 0.0*voronoiNoiseDistance(samplePosition);\n    vec3 s3= smoothstep(vec3(0.95),vec3(1.0),samplePositionf) + smoothstep(vec3(0.05),vec3(0.0),samplePositionf);\n\tfragColor = vec4(max(s3,vec3(s)),1.0); \n*/\n}\n","name":"Image","description":"","type":"image"}]}