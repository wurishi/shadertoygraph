{"ver":"0.1","info":{"id":"l3syRf","date":"1726517932","viewed":25,"name":"ITWTTA","username":"Alexander_Egorov","description":"It's terrible what these textures are. (ITWTTA)","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["sdf","cubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define             PI 3.14159265359\n#define MAX_ITERS   700\n#define MAX_DIST    100.0\n#define EPS         0.001\n\n\nstruct obj {\n    float d;\n    int id;\n};\n\nfloat torus ( in vec3 p, in vec2 t )\n{\n    vec2 q  = vec2 ( length ( p.xz) - t.x, p.y );\n    return length ( q ) - t.y;\n}\n\nfloat sphere ( vec3 p, in vec3 center, in float radius )\n{\n    return length ( p - center ) - radius;\n}\n\nfloat plane ( in vec3 p, vec4 n )\n{\n    return dot ( p, n.xyz ) + n.w;\n}\n\nobj smoothSubtraction ( obj f, obj s, float k ) \n{\n    float d1 = f.d;\n    float d2 = s.d;\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return obj(mix( d2, -d1, h ) + k*h*(1.0-h), f.id); \n}\n\nobj smoothIntersection ( obj f, obj s, float k ) \n{\n    float d1 = f.d;\n    float d2 = s.d;\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return obj(mix( d2, d1, h ) + k*h*(1.0-h), f.id); \n}\n\nobj smoothUnion ( obj f, obj s, float k ) \n{\n    float d1 = f.d;\n    float d2 = s.d;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return obj(mix( d2, d1, h ) - k*h*(1.0-h), f.id); \n}\n\nobj objmin(obj f, obj s) {\n    if (f.d < s.d)\n        return f;\n    return s;\n}\n\nobj sdf(in vec3 p) {\n    obj sph1 = obj(sphere ( p, vec3 ( 0.0, 3.4, 0.0 ), 1.0 * (1.0 + sin(iTime + PI * 0.75))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph2 = obj(sphere ( p, vec3 ( 3.4, 0.0, 0.0 ), 1.0 * (1.0 + sin(iTime))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph3 = obj(sphere ( p, vec3 ( 0.0, 0.0, 3.4 ), 1.0 * (1.0 + sin(iTime))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph4 = obj(sphere ( p, vec3 ( 0.0, -3.4, 0.0 ), 1.0 * (1.0 + sin(iTime + PI * 0.75))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph5 = obj(sphere ( p, vec3 ( -3.4, 0.0, 0.0 ), 1.0 * (1.0 + sin(iTime))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    obj sph6 = obj(sphere ( p, vec3 ( 0.0, 0.0, -3.4 ), 1.0 * (1.0 + sin(iTime))) + 0.05 * (1.0 + sin(10.0 *(length(p) + 2.0*iTime))), 0);\n    \n    obj sph_0 = objmin(objmin( sph5, sph2) , objmin( sph3, sph6));\n    \n    obj sph  = obj(sphere ( p, vec3 ( 0.0, 0.0, 0.0 ), 4.0 ) +  0.025 * cos(2.0 * p.x * p.y * p.z + iTime * 3.0), 0);\n    obj pl   = obj(plane(p, vec4 (0.0, 1.0, 0.0, 5.0)) + 0.5 * sin(length(p) - iTime), 1);\n    \n    obj tor  = obj(torus(p, vec2 (4.0 * (1.0 + sin(1.0 * iTime)), 1)) + 0.01 * (1.0 + sin(15.0 * p.y + 15.0 * p.x + p.z * 15.0 + iTime*5.0)), 2);\n    \n    return objmin(smoothUnion(smoothSubtraction(objmin(sph1, sph4), smoothSubtraction(sph_0, sph, 1.0), 0.5), tor, 3.0), pl); //objmin(sph, pl);\n    //return obj(sphere ( p, vec3 ( 0.0, 0.0, 0.0 ), 5.0) ,0);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nvec3 trace ( vec3 from, vec3 dir, out bool hit, out int steps, out int id, out float d )\n{\n    vec3     p         = from;\n    float    totalDist = 0.0;\n    \n    hit = false;\n    \n    for ( steps = 0; steps < MAX_ITERS; steps++ )\n    {\n        obj    dist = sdf ( p );\n        id = dist.id;\n        \n        if ( dist.d < EPS )\n        {\n            hit = true;\n            break;\n        }\n        \n        totalDist += dist.d;\n        \n        if ( totalDist > MAX_DIST )\n            break;\n            \n        p += dist.d * dir;\n    }\n    d = totalDist;\n    return p;\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat2 rotate2d(in float angle) {\n    float angle_cos = cos(angle);\n    float angle_sin = sin(angle);\n    return mat2(\n        vec2(angle_cos, angle_sin),\n        vec2(-angle_sin, angle_cos)\n    );\n}\n\nmat3 camera(in vec3 camera_pos, in vec3 look_at_point) {\n    vec3 camera_dir = normalize(look_at_point - camera_pos);\n    vec3 camera_right = normalize(cross(vec3(0, 1, 0), camera_dir));\n    vec3 camera_up = normalize(cross(camera_dir, camera_right));\n    \n    return mat3(-camera_right, camera_up, -camera_dir);\n}\n\nvec3 generateNormal ( vec3 surfacePoint, float d )\n{ \n    float e = d;\n    float dx1 = sdf(surfacePoint + vec3(e, 0, 0)).d;\n    float dx2 = sdf(surfacePoint - vec3(e, 0, 0)).d;\n    float dy1 = sdf(surfacePoint + vec3(0, e, 0)).d;\n    float dy2 = sdf(surfacePoint - vec3(0, e, 0)).d;\n    float dz1 = sdf(surfacePoint + vec3(0, 0, e)).d;\n    float dz2 = sdf(surfacePoint - vec3(0, 0, e)).d;\n  \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 camera_origin = vec3(0.0, 7.0, 0.0);\n    float camera_radius = 7.0;\n    vec3 look_at_point = vec3(0.0, 1.0, 0.0);\n\n    vec2 uv_coord = (fragCoord - 0.5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    camera_origin.yz = camera_origin.yz * camera_radius * rotate2d(mix(PI / 2.0, 0.0, mouse.y));\n    camera_origin.xz = camera_origin.xz * rotate2d(mix(-PI, PI, mouse.x)) + vec2(look_at_point.x, look_at_point.z);\n    \n    vec3 ray_dir = camera(camera_origin, look_at_point) * normalize(vec3(uv_coord, -1));\n    \n    bool hit;\n    int id;\n    int  steps;\n    float d;\n    vec3 intersectionPoint = trace (camera_origin, ray_dir, hit, steps, id, d );\n    vec3 surfaceNormal  = generateNormal ( intersectionPoint, 0.001);\n    vec3 lightSource = vec3  ( -15.0, 25.0, -48.0 );\n    if (hit) {\n        vec3 lightVector  = normalize ( lightSource - intersectionPoint );\n        vec3 surfaceNormal  = generateNormal ( intersectionPoint, 0.001 );\n        vec3 n = abs(surfaceNormal);\n        vec3 reflected = ray_dir - 2.0 * dot(ray_dir, surfaceNormal) * surfaceNormal;\n        float specular = pow(max(dot(reflected, lightVector), 0.0), 32.0);\n        vec3 p = intersectionPoint;\n        if (id == 0) {\n            vec3 txtr = 1.5 * (n.x * texture(iChannel1, p.yz).rgb + n.y * texture(iChannel1, p.xz).rgb + n.z * texture(iChannel1, p.xy).rgb) * (n.x * texture(iChannel2, p.yz).rgb + n.y * texture(iChannel2, p.xz).rgb + n.z * texture(iChannel2, p.xy).rgb);\n            fragColor = vec4 ( 2.19 / 2.0, 1.71 / 2.0, 0.37 / 2.0, 0.0 ) * max(dot(surfaceNormal, lightVector), 0.0) + specular * vec4(1.0, 0.0, 1.0, 0.0) + 0.05;\n            fragColor *= vec4(txtr, 0.0);\n        } else {\n            vec3 txtr = 1.0 * (n.x * texture(iChannel3, p.yz).rgb + n.y * texture(iChannel3, p.xz).rgb + n.z * texture(iChannel3, p.xy).rgb);\n            fragColor = vec4 ( sin(intersectionPoint.x * 4.0), 0.5 + 0.5  * sin(length(intersectionPoint) - iTime), sin(intersectionPoint.z * 4.0), 0.0 ) * max(dot(surfaceNormal, lightVector), 0.0) * 0.85 + 0.15 + specular * vec4(0.5 + 0.5 * sin(iTime), 0.0,  0.33 + 0.33 * cos(iTime), 0.0);\n            fragColor *= vec4(txtr, 0.0);\n        }\n    } else {\n        fragColor = vec4 ( 0.1 , 0.3 , 0.45, 0.0 );\n    }\n    vec3 col = texture(iChannel0, ray_dir).rgb;\n    col = mix(col, fragColor.xyz, step((d) - MAX_DIST / 1.01, 0.0));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 col = vec3(0.); \n    col = 0.7 * (mix(texture(iChannel0, rayDir.yz).rgb, texture(iChannel0, rayDir.yx).rgb, texture(iChannel0, rayDir.xz).rgb) * 0.2 + 0.3 + 0.5*rayDir);;\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.x *= iResolution.y / iResolution.x;\n    vec3 col = vec3(0.1, 0.2, 0.0);\n    if (mod(abs(fragCoord.x - fragCoord.y + 0.5 * iTime) , 2.) <= 0.8) {\n        col.r += 1. + sin(iTime);\n        col.x += 1. - cos(iTime);\n        col.y += 1. + cos(iTime + PI / 4.0);\n    } else {\n        col.r += 1. - sin(iTime);\n        col.z += 1. + cos(iTime - PI / 4.0);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}