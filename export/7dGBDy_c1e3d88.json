{"ver":"0.1","info":{"id":"7dGBDy","date":"1658789236","viewed":155,"name":"Wave Equation 5 - Trapped waves","username":"athibaul","description":"Same as Wave Equation 3, but added an example of scattering by a periodic medium + trapped modes in a cavity.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["wave","simulation","refraction","pde","helmholtz","dalembert"],"hasliked":0,"parentid":"3t2fWG","parentname":"Wave Equation 3 - Trumpet!"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ********************************* //\n//      WAVE EQUATION SIMULATOR      //\n// ********************************* //\n\n// A simple numerical scheme to simulate wave propagation.\n// 11/09/2020 : Added basic absorbing boundary conditions!\n// 26/07/2022 : Added examples 10 (periodic medium), 11 (cavity) and 12 (membrane)\n// Copyright 2020-2022 Alexis THIBAULT\n\n\n// Change the PRESET number in \"Common\" tab!\n// ---------------\n// LIST OF PRESETS\n// ---------------\n// 0: Droplet in a square pond\n// 1: Scattering by a small obstacle\n// 2: Two-slit interference\n// 3: Two-slit interference, tilted\n// 4: Refraction through glass\n// 5: Total reflection\n// 6: Iridescence of butterfly wings\n// 7: Iridescence of thin film\n//    (Reflected waves display constructive/destructive \n//     interference depending on frequency.)\n// 8: Quadratic diffuser\n// 9: A trumpet!\n// 10: Scattering by a periodic medium\n// 11: Partial trapping in a cavity with a small opening\n// 12: Membrane\n\n#define pal(x,c,d) abs(c*x+d)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    ivec2 ij = ivec2(fragCoord);\n    float p = T0(ij).r;\n    vec2 vxvy = T1(ij).rg;\n    float nrj = p*p + dot(vxvy, vxvy);\n    \n    vec3 col;\n    #if COLORSTYLE == 0\n    float q = sign(p) * pow(abs(p),0.8) * 3.0;\n    //float q = pow(nrj, 0.25);\n    col = pal(q, vec3(-1.0,1.0,1.0), vec3(0.2,-0.1,0.15));\n    #elif COLORSTYLE == 1\n    col = 0.5 + 3.0*vec3(p, vxvy);\n    #endif\n    \n    col = mix(col, vec3(0.0,1.0,1.0), 0.6*smoothstep(1.0,3.0,indexOfRefraction(uv_of(ij))));\n    \n    #ifdef SHOW_ABSORBING_BC\n    if(absorbingBC(uv_of(ij)) != vec2(0))\n        col = mix(col, vec3(0.2,0.8,0.2), 0.4);\n    #endif\n    \n    if(isObstacle(uv_of(ij)))\n        col = (11*ij.x+13*ij.y)%101 % 19 % 5 == 0 ? vec3(0.6) : vec3(0.3);\n    /*{\n        col = 0.5+0.5*cos(0.1*fragCoord.xyy*vec3(0.1,0.162,0.062)+vec3(0.2,3.5,0.9));\n    \tcol = 0.5+0.5*sin((col + 0.5*sin(0.062*fragCoord.yxy))*TAU*vec3(1,1.62,0.62)+vec3(0));\n    \tcol = 0.5+0.5*cos((col + 0.5*sin(0.3*fragCoord.xyx))*TAU*vec3(1,1.62,0.62)+vec3(0));\n        col = 0.6 - 0.3*col.ggg;\n    }*/\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define T0(a) texelFetch(iChannel0, a, 0)\n#define T1(a) texelFetch(iChannel1, a, 0)\n#define ex ivec2(1,0)\n#define ey ivec2(0,1)\n#define dt_dx sqrt(0.5)\n#define uv_of(ij) (( 2.0*vec2(ij) - iResolution.xy ) / iResolution.y)\n#define ij_of(uv) ivec2(( iResolution.y * uv + iResolution.xy )*0.5)\n#define dt_of(ij) dFdx(uv_of(ij).x)*dt_dx\n#define TAU 2.0*3.1415926535\n\n// ---------------\n// LIST OF PRESETS\n// ---------------\n// 0: Droplet in a square pond\n// 1: Scattering by a small obstacle\n// 2: Two-slit interference\n// 3: Two-slit interference, tilted\n// 4: Refraction through glass\n// 5: Total reflection\n// 6: Iridescence of butterfly wings\n// 7: Iridescence of thin film\n//    (Reflected waves display constructive/destructive \n//     interference depending on frequency.)\n// 8: Quadratic diffuser\n// 9: A trumpet!\n// 10: Scattering by a periodic medium\n// 11: Partial trapping in a cavity with a small opening\n// 12: Membrane\n\n#define PRESET 11\n\n// ------------\n// COLOR STYLES\n// ------------\n// 0: Pressure only (blue is positive, orange is negative).\n// 1: R = pressure, G = horizontal velocity, B = vertical velocity.\n\n#define COLORSTYLE 0\n#define SHOW_ABSORBING_BC\n\n#define squared(x) (x)*(x)\n\nfloat indexOfRefraction( in vec2 uv );\n\nbool isObstacle( in vec2 uv )\n{\n    //if(uv.x < -0.99 || uv.x > 0.99 || uv.y < -0.99 || uv.y > 0.99)\n    //    return true;\n    \n    #if PRESET==1\n    if(length(uv - vec2(-0.2,0.3)) < 0.1)\n        return true;\n    #elif PRESET==2\n    if(abs(uv.x + 0.5) < 0.02 && abs(abs(uv.y)-0.2)>0.05)\n        return true;\n    #elif PRESET==3\n    if(abs(uv.x + 0.5*uv.y) < 0.02 && abs(abs(uv.y)-0.2)>0.05)\n        return true;\n    #elif PRESET==6\n    if(uv.y < -0.5 && mod(dot(uv, vec2(0.6,-0.8)), 0.1) < 0.02)\n        return true;\n    #elif PRESET==8\n    float scale = 1.0;\n    uv = scale*uv + (1.0-scale)*vec2(0.0,-1.0);\n    float y0 = -0.5;\n    if(uv.y < y0 && mod(uv.x, 0.1) < 0.02)\n\t        return true;\n    if(uv.y < y0-0.5/21.0*float(squared(int(floor(uv.x / 0.1))) % 21))\n        return true;\n    #elif PRESET == 9\n    if(uv.x < 0.0 && abs(abs(uv.y) - 0.04 - 0.1*exp(20.0*uv.x))< 0.01\n      || uv.x < -0.95 && abs(uv.y) < 0.05)\n        return true;\n    #elif PRESET == 10\n    float w = 0.05;\n    vec2 p = mod(uv, 2.0*w) - w;\n    p = abs(p);\n    p = vec2(min(p.x,p.y),max(p.x,p.y));\n    vec2 q = p - vec2(0.1,0.9)*w;\n    if(q.x < 0. && q.y < 0. && length(uv) < 0.5)\n        return true;\n    #elif PRESET == 11\n    vec2 p = uv - vec2(0,-0.4);\n    if(abs(p.y - 0.5) < 0.01 && abs(p.x) > 0.02\n       || abs(p.x) > 0.5  && p.y < 0.5\n       || length(p) > 0.5 && p.y <= 0.\n       || length(p) > 0.5 && p.y <= 0.5 && abs(p.x) > 0.02)\n        return true;\n    #endif\n    \n    \n    return false;\n}\n\nvec2 pressureCondition( in vec2 uv, in float time ) \n{\n    // First field is 1.0 if we impose pressure here, 0.0 otherwise.\n    // Second field is the value.\n    #if PRESET == 1 \n    if(length(uv) < 0.01)\n        return vec2(1, 0.6*sin(TAU*10.0*time));\n    #elif PRESET == 2 || PRESET == 3\n    if(uv.x < -0.95 && uv.x > -1.0)\n        return vec2(1, 0.03*sin(TAU*10.0*time));\n    #elif PRESET == 4\n    float angle = -0.25*0.5*TAU;\n    float omega = 20.0*TAU;\n    vec2 wavenumber = vec2(cos(angle), sin(angle)) * omega;\n    if(uv.x < -0.5 && uv.y > 0.5)\n        return vec2(1, 0.1*sin(omega*time - dot(wavenumber, uv)) \n                    * smoothstep(0.,0.2,time));\n    #elif PRESET == 5\n    // The limit angle of total reflection is asin(1/ior) \n    // For ior=2, the angle is pi/6.\n    float angle = TAU/12.0 + 0.05;\n    float omega = 15.0*TAU;\n    vec2 wavenumber = vec2(sin(angle), -cos(angle)) * omega * indexOfRefraction(uv);\n    if(uv.x < -0.5 && uv.y > 0.5)\n        return vec2(1, 0.1*sin(omega*time - dot(wavenumber, uv)) \n                    * smoothstep(0.,0.2,time));\n    #elif PRESET == 5\n    uv -= vec2(-1.0, 1.0);\n    if( length(uv) < 0.05 )\n        return vec2(1.0, sin(TAU*10.0*time));\n    #elif PRESET == 7\n    if(dot(uv, normalize(vec2(0.5,1.0))) > 1.05)\n    {\n        // Source with frequency modulation\n        float omega0 = 10.0*TAU; // Frequency of carrier\n        float deltaOmega = 9.0*TAU; // Frequency width\n        float omega1 = 0.2 * TAU; // Frequency of modulator\n        float phase = omega0*time - deltaOmega/omega1 * sin(omega1*time);\n        return vec2(1, 0.1*sin(phase));\n    }\n    #elif PRESET == 9\n    if(uv.x < -0.94 && abs(uv.y-0.01) < 0.01)\n        return vec2(1, 0.5*(-0.5+smoothstep(0.24,0.26, abs(fract(2.0*time)-0.5))));\n    #elif PRESET == 12\n    if(length(uv) > 0.98)\n        return vec2(1, 0);\n    #endif\n    return vec2(0.0, 0.0);\n}\n\nvec2 absorbingBC( in vec2 uv )\n{\n    // Return the normal direction of the boundary (toward the exterior),\n    // or vec2(0) if we're inside the domain.\n    //\n    // The \"absorbing boundary conditions\" we use are actually a simple\n    // transport equation [dt p = b.grad p], so there are strong spurious\n    // reflections if we're not careful. We can cheat by choosing an appropriate\n    // direction [b].\n    \n    #if PRESET == 1 || PRESET == 4 || PRESET == 9\n    // Absorbing boundaries on all four sides\n    if(max(abs(uv.x),abs(uv.y)) > 0.98)\n        // We expect the waves to propagate mostly radially\n        return normalize(uv);\n    #elif PRESET == 2\n    // Absorbing boundaries in the right part\n    if(uv.x > -0.5 && max(uv.x, abs(uv.y)) > 0.98)\n        return normalize(uv - vec2(-0.5, 0.0));\n    #elif PRESET == 3\n    // Lots of cheating on this one\n    if(uv.x < 0.5 && uv.y < -0.98)\n        // Absorb the direct reflection from the tilted plane\n        return normalize(vec2(-1.0, -1.333));\n    if((uv.x + 0.5*uv.y) > 0.0 && max(uv.x, abs(uv.y)) > 0.98)\n        // Absorb the diffracted waves\n        return normalize(uv);\n    #elif PRESET == 5 || PRESET == 6 || PRESET == 7 || PRESET==8 || PRESET == 10 || PRESET == 11\n    // Perfect absorbtion of orthogonal waves\n    if(uv.x > 0.98)\n        return vec2(1,0);\n    if(uv.x < -0.98)\n        return vec2(-1,0);\n    if(uv.y > 0.98)\n        return vec2(0,1);\n    if(uv.y < -0.98)\n        return vec2(0,-1);\n    #endif\n    return vec2(0);\n}\n\n\nfloat indexOfRefraction( in vec2 uv )\n{\n    #if PRESET == 4\n\treturn (uv.y > -0.0 || uv.y < -0.6) ? 1.0 : 2.0;\n    #elif PRESET == 5\n    return 1.0 + step(0.0, uv.y);\n    #elif PRESET == 7\n    //float thickness = 0.1*(0.5 + 0.5*uv.x);\n    float thickness = 0.02;\n    return 1.0 + 2.0*smoothstep(thickness*1.0, thickness*0.5, abs(uv.y+0.5));\n    #else\n    return 1.0;\n   \t#endif\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float initialPressure( in ivec2 ij )\n{\n    vec2 uv = uv_of(ij);\n    #if PRESET == 0\n    float denom = 1e-3;\n    return exp(-dot(uv,uv) / denom) * 2.0;\n    #elif PRESET == 1 || PRESET == 2 || PRESET == 3\n    //uv.x += 1.0;\n    //return 0.3*exp(-dot(uv.x,uv.x) / 3e-2) * cos(uv.x * 6.28 * 10.0);\n    #elif PRESET == 4\n    //uv -= vec2(-0.5,0.0);\n    //return exp(-dot(uv,uv) / 1e-3) * 2.0;\n    #elif PRESET == 6\n    //uv -= vec2(0.0,0.5);\n    //return exp(-dot(uv,uv) / 2e-3) * 3.0;\n    uv.y -= 0.5;\n    return exp(-uv.y*uv.y / 1e-3) * smoothstep(1.0,0.5,abs(uv.x));\n    #elif PRESET == 7\n    //uv -= vec2(-1.0,0.5);\n    //return exp(-dot(uv.y,uv.y) / 6e-2) * cos(uv.y*6.28*(10.0+5.0*uv.y)) * 0.3;\n    #elif PRESET == 8\n    uv -= vec2(0.0,0.8);\n    return (exp(-dot(uv,uv) / 1e-2) + exp(-dot(uv,uv) / 1e-3));\n    #elif PRESET == 10\n    uv -= vec2(0.2,0.6);\n    return 5.*(exp(-dot(uv,uv) / 1e-3) + exp(-dot(uv,uv) / 1e-4));\n    #elif PRESET == 11  || PRESET == 12\n    uv -= vec2(0.2,-0.3);\n    return (exp(-dot(uv,uv) / 5e-3) + exp(-dot(uv,uv) / 5e-4));\n    //return 0.4*smoothstep(-0.4,-0.5,uv.y+0.1*uv.x);\n    #endif\n    return 0.0;\n}\n\nfloat pressureStep( in ivec2 ij, in float time )\n{\n    vec2 pc = pressureCondition(uv_of(ij), time);\n    if(pc.x > 0.5)\n        return pc.y;\n    \n    float p_i_j  = T0(ij).r;\n    float p_im_j = T0(ij-ex).r;\n    float p_ip_j = T0(ij+ex).r;\n    float p_i_jm = T0(ij-ey).r;\n    float p_i_jp = T0(ij+ey).r;\n    \n    float vx_iph_j = T1(ij).r,\n        vx_imh_j = T1(ij-ex).r,\n        vy_i_jph = T1(ij).g,\n        vy_i_jmh = T1(ij-ey).g;\n    \n    \n    float p_np1;\n    vec2 direction = absorbingBC(uv_of(ij));\n    float ior = indexOfRefraction(uv_of(ij));\n    if(direction != vec2(0))\n    {\n        p_np1 = p_i_j - dt_dx/ior * (\n            max(direction.x, 0.0) * (p_i_j - p_im_j)\n            + min(direction.x, 0.0) * (p_ip_j - p_i_j)\n            + max(direction.y, 0.0) * (p_i_j - p_i_jm)\n            + min(direction.y, 0.0) * (p_i_jp - p_i_j)\n        );\n    }\n    else\n    {\n    \tp_np1 = p_i_j - dt_dx * (vx_iph_j - vx_imh_j + vy_i_jph - vy_i_jmh);\n    }\n    return p_np1;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p;\n    float time = T0(ivec2(0)).z;\n    float dt = dt_of(fragCoord);\n    if(iFrame == 0 || T0(ivec2(0)).a != iResolution.x)\n    {\n        p = initialPressure(ivec2(fragCoord));\n        fragColor = vec4(p, 0, 0.0, iResolution.x);\n    }\n    else\n    {\n        p = pressureStep(ivec2(fragCoord), time);\n        fragColor = vec4(p, 0, time+dt, iResolution.x);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 initialVelocity( in vec2 fragCoord )   \n{\n    return vec2(0.0);\n}\n\n\nvec2 velocityStep( in ivec2 ij )\n{\n    \n    float p_i_j = T0(ij).r,\n          p_ip_j = T0(ij+ex).r,\n          p_i_jp = T0(ij+ey).r;\n    float vx_iph_j = T1(ij).r;\n    float vy_i_jph = T1(ij).g;\n    float ior_x = indexOfRefraction(uv_of(vec2(ij)+vec2(0.5,0.0)));\n    float ior_y = indexOfRefraction(uv_of(vec2(ij)+vec2(0.0,0.5)));\n    \n    float vx_iph_j_np1 = vx_iph_j - dt_dx/(ior_x*ior_x) * (p_ip_j - p_i_j);\n    float vy_i_jph_np1 = vy_i_jph - dt_dx/(ior_y*ior_y) * (p_i_jp - p_i_j);\n    \n    if(isObstacle(uv_of(ij)) || isObstacle(uv_of(ij+ex)))\n        vx_iph_j_np1 = 0.0;\n    if(isObstacle(uv_of(ij)) || isObstacle(uv_of(ij+ey)))\n        vy_i_jph_np1 = 0.0;\n    \n    return vec2(vx_iph_j_np1, vy_i_jph_np1);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vxvy;\n    if(iFrame == 0 || T1(ivec2(0)).a != iResolution.x)\n        vxvy = initialVelocity(fragCoord);\n    else\n        vxvy = velocityStep(ivec2(fragCoord));\n    \n    fragColor = vec4(vxvy, 0, iResolution.x);\n}","name":"Buffer B","description":"","type":"buffer"}]}