{"ver":"0.1","info":{"id":"4XS3zm","date":"1708707615","viewed":76,"name":"Surfaces implicites tp1","username":"LiQiye","description":"Fonctions de surfaces Implicites. Le programme prend environ 1 min à compiler. 20 FPS en moyenne en petit écran.","likes":1,"published":1,"flags":0,"usePreview":1,"tags":["school"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2023.02.06\n// Eric Galin\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return \n  mat3(ca,sa,0.,\n      -sa,ca,0.,\n      0.,0.,1.);\n}\n\n// Rotation matrix around x axis\n// a : Angle\nmat3 Rx(float a)\n{\n  float sa = sin(a);float ca = cos(a);\n  return mat3(1., 0., 0., 0., ca, sa, 0., -sa, ca);\n}\n\n// Rotation matrix around y axis\n// a : Angle\nmat3 Ry(float a)\n{\n  float sa = sin(a);float ca = cos(a);\n  return mat3(ca, 0., -sa, 0., 1., 0., sa, 0., ca);\n}\n\n//https://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/M1IMAGE/html/group__math.html#gaa1e0bf3acb335f7d1441f3af21405679\nmat3 RotationAxis(vec3 axis, float angle) {\n    vec3 a = normalize(axis);\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n\n    return mat3(\n        a.x * a.x + (1. - a.x * a.x) * c,\n        a.x * a.y * (1. - c) - a.z * s,\n        a.x * a.z * (1. - c) + a.y * s,\n        \n        a.x * a.y * (1. - c) + a.z * s,\n        a.y * a.y + (1. - a.y * a.y) * c,\n        a.y * a.z * (1. - c) - a.x * s,\n        \n        a.x * a.z * (1. - c) - a.y * s,\n        a.y * a.z * (1. - c) + a.x * s,\n        a.z * a.z + (1. - a.z * a.z) * c\n    );\n}\n//https://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/M1IMAGE/html/group__math.html#gaa1e0bf3acb335f7d1441f3af21405679\nmat3 findRotation(vec3 u,vec3 v){\n    vec3 a= normalize(u);\n     vec3 b= normalize(v);\n     vec3 w= cross(a, b);      // rotation autour de w, un vecteur perpendiculaire a u et v\n     float s= length(w); // sin theta\n     float c= dot(a, b); // cos theta\n     \n     // si u et v sont colineaires, pas d'axe de rotation, renvoyer +1 ou -1\n     if(s < float(0.00001))\n        return mat3(\n            vec3(c, 0.0, 0.0),\n            vec3(0.0, c, 0.0),\n            vec3(0.0, 0.0, c)\n        );\n     \n     // normalise l'axe de rotation\n     w= w / s;\n     \n     // meme matrice de rotation qu'au dessus , cf Rotation(axis, angle), l'axe est le vecteur w, s et c sont le sinus et le cosinus de l'angle\n     return mat3(\n         w.x * w.x + (1. - w.x * w.x ) * c,\n         w.x * w.y * (1. - c ) - w.z * s,\n         w.x * w.z * (1. - c ) + w.y * s,\n         \n         \n         w.x * w.y * (1. - c ) + w.z * s,\n         w.y * w.y + (1. - w.y * w.y ) * c,\n         w.y * w.z * (1. - c ) - w.x * s,\n         \n         \n         w.x * w.z * (1. - c ) - w.y * s,\n         w.y * w.z * (1. - c ) + w.x * s,\n         w.z * w.z + (1. - w.z * w.z ) * c\n         );\n}\n\n//https://perso.univ-lyon1.fr/jean-claude.iehl/Public/educ/M1IMAGE/html/group__math.html#gaea1c277aef004d3a93418d2a086d24e5\nmat4 translation(vec3 offset) {\n    return mat4(\n        1.0, 0.0, 0.0, offset.x,\n        0.0, 1.0, 0.0, offset.y,\n        0.0, 0.0, 1.0, offset.z,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n\nmat3 homothety(float scale) {\n    return mat3(\n        scale, 0.0, 0.0,\n        0.0, scale, 0.0,\n        0.0, 0.0, scale\n    );\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m,vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n\n  // Origin\n  ro=vec3(37.,0.,15.);\n  ro*=Rz(a);\n\n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n\n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  rd=normalize(p.x*u+p.y*v+le*w);\n}\n\nvec3 changeLength(vec3 v,float len){\n  return (len/length(v))*v;\n}\n\nvec3 getNormal(vec3 CommonPoint, vec3 r, vec3 s) {\n    vec3 rb = r - CommonPoint;\n    vec3 sb = s - CommonPoint;\n    return cross(rb, sb);\n}\n\n\n\nfloat sqr(float a){\n  return a*a;\n}\n\nvec3 getNormal(vec3 d1, vec3 d2) {\n    vec3 n = cross(d1, d2); \n    n = normalize(n); \n    float length_d1 = length(d1);\n    return n * length_d1;\n}\n\nvec3 getNormalTowards(vec3 a,vec3 b,vec3 c,vec3 posDot){\n  vec3 v1=a-b;\n  vec3 v2=c-b;\n  vec3 normal=getNormal(v1,v2);\n  vec3 vpos=posDot-b;\n  if(dot(vpos,normal)<0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nvec3 getNormalTowards(vec3 a,vec3 normal,vec3 posDot){\n  vec3 vpos=posDot-a;\n  if(dot(vpos,normal)<0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nvec3 getNormalOpp(vec3 a,vec3 b,vec3 c,vec3 posDot){\n  vec3 v1=a-b;\n  vec3 v2=c-b;\n  vec3 normal=getNormal(v1,v2);\n  vec3 vpos=posDot-b;\n  if(dot(vpos,normal)>0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nvec3 getNormalOpp(vec3 a,vec3 normal,vec3 posDot){\n  vec3 vpos=posDot-a;\n  if(dot(vpos,normal)>0.0){\n    normal*=-1.;\n  }\n  return normal;\n}\n\nbool abovePlane(vec3 point,vec3 planePoint,vec3 normal){\n  vec3 v=point-planePoint;\n  return dot(v,normal)>=0.0;\n}\n\nvec3 getNormal(vec3 v) {\n    float l = length(v);  \n    vec3 n = cross(vec3(1, 0, 0),v);  \n    if (length(n) < 0.01) {  \n        n = cross(v, vec3(0, 0, 1));\n    }\n    return changeLength(n,l);  \n}\n\nfloat getAngleDegrees(vec3 v1, vec3 v2) {\n    return degrees(acos(dot(v1, v2) / (length(v1) * length(v2))));\n}\nfloat getAngleRadians(vec3 v1, vec3 v2) {\n    return radians(acos(dot(v1, v2) / (length(v1) * length(v2))));\n}\n\nvec3 getProjectionVector(vec3 v, vec3 u) {\n  u=normalize(u);\n  return dot(v,u)*u;\n}\n\nvec3 getRejectionVector(vec3 v, vec3 u) {\n  return v-getProjectionVector(v,u);\n}\n\nbool isBetweenPoints(vec3 p,vec3 a,vec3 b){\n    vec3 u1 = normalize(b - a);\n    vec3 PA=p-a;\n    float proja=dot(PA,u1);\n    vec3 PB=p-b;\n    float projb=dot(PB,u1);\n    return proja*projb<0.;\n}\n\nbool inCircleAxe(vec3 p,vec3 center,vec3 normal,float radius){\n  vec3 v=p-center;\n  vec3 rejection=getRejectionVector(v,normal);\n  return length(rejection)<=radius;\n}\n\nbool isInTriangleAxis(vec3 p,vec3 a,vec3 b,vec3 c){\n    vec3 ab=b-a;\n    vec3 ac=c-a;\n    vec3 normal=getNormal(ab,ac);\n    vec3 pa=p-a;\n    vec3 rpa=getRejectionVector(pa,normal);\n    vec3 pb=p-b;\n    vec3 rpb=getRejectionVector(pb,normal);\n    vec3 pc=p-c;\n    vec3 rpc=getRejectionVector(pc,normal);\n    float angle1=getAngleDegrees(rpa,rpb);\n    float angle2=getAngleDegrees(rpb,rpc);\n    float angle3=getAngleDegrees(rpa,rpc);\n    float result=angle1+angle2+angle3;\n    return result>=359.9&&result<360.1;\n}\n\n//Will work if the rectangle has opposites sides.\nbool isInParallelogramAxis(vec3 p,vec3 a,vec3 b,vec3 c,vec3 d){\n    vec3 ab=a-b;\n    vec3 ad=a-d;\n    vec3 normal=getNormal(ab,ad);\n    vec3 pa=p-a;\n    vec3 rpa=getRejectionVector(pa,normal);\n    vec3 pb=p-b;\n    vec3 rpb=getRejectionVector(pb,normal);\n    vec3 pc=p-c;\n    vec3 rpc=getRejectionVector(pc,normal);\n    vec3 pd=p-d;\n    vec3 rpd=getRejectionVector(pd,normal);\n    float angle1=getAngleDegrees(rpa,rpb);\n    float angle2=getAngleDegrees(rpb,rpc);\n    float angle3=getAngleDegrees(rpc,rpd);\n    float angle4=getAngleDegrees(rpd,rpa);\n    float result=angle1+angle2+angle3+angle4;\n    return result>=359.9&&result<360.1;\n}\n\nbool isInBox(vec3 p,vec3 pt1,vec3 pt2,vec3 a,vec3 b,vec3 c,vec3 d){\n  vec3 seg=pt2-pt1;\n  if(isInParallelogramAxis(p,a,b,c,d)){\n    return isBetweenPoints(p,pt1,pt2);\n  }\n  return false;\n}\n\n\nbool isInToblerone(vec3 p,vec3 pt1,vec3 pt2,vec3 a,vec3 b,vec3 c){\n  vec3 seg=pt1-pt2;\n  if(isInTriangleAxis(p,a,b,c)){\n    return isBetweenPoints(p,pt1,pt2);\n  }\n  return false;\n}\n\nbool isInTetrahedron(vec3 point, vec3 a, vec3 b, vec3 c, vec3 d) {\n  vec3 ab=b-a;\n  vec3 ac=c-a;\n  vec3 bc=c-b;\n  vec3 ad=d-a;\n  vec3 bd=d-b;\n  vec3 cd=c-d;\n  vec3 nabc=getNormalTowards(b,a,c,d);\n  vec3 nabd=getNormalTowards(d,a,b,c);\n  vec3 nacd=getNormalTowards(c,d,a,b);\n  vec3 nbcd=getNormalTowards(b,c,d,a);\n\n  bool aboveABC=abovePlane(point,a,nabc);\n  bool aboveABD=abovePlane(point,a,nabd);\n  bool aboveACD=abovePlane(point,a,nacd);\n  bool aboveBCD=abovePlane(point,b,nbcd);\n  return aboveABC&&aboveABD&&aboveACD&&aboveBCD;\n}\n\nbool isInPyramid(vec3 point, vec3 a, vec3 b, vec3 c, vec3 d,vec3 top) {\n  vec3 ab=a-b;\n  vec3 bc=c-b;\n  vec3 cd=c-d;\n  vec3 ad=d-a;\n  vec3 atop=a-top;\n  vec3 btop=b-top;\n  vec3 ctop=c-top;\n  vec3 dtop=d-top;\n\n  vec3 nabcd=getNormalTowards(b,a,d,top);\n  vec3 nabtop=getNormalTowards(b,a,top,c);\n  vec3 nadtop=getNormalTowards(a,d,top,b);\n  vec3 nbctop=getNormalTowards(b,c,top,d);\n  vec3 ncdtop=getNormalTowards(c,d,top,a);\n\n  bool aboveABCD=abovePlane(point,a,nabcd);\n  bool aboveABTOP=abovePlane(point,a,nabtop);\n  bool aboveADTOP=abovePlane(point,a,nadtop);\n  bool aboveBCTOP=abovePlane(point,b,nbctop);\n  bool aboveCDTOP=abovePlane(point,c,ncdtop);\n  return aboveABCD&&aboveABTOP&&aboveADTOP&&aboveBCTOP&&aboveCDTOP;\n}\n\n\n\n\nvec3 rotateX(vec3 v,float angle){\n  return Rx(angle)*v;\n}\n\nvec3 rotateY(vec3 v,float angle){\n  return Ry(angle)*v;\n}\n\nvec3 rotateZ(vec3 v,float angle){\n  return Rz(angle)*v;\n}\n\n\n\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\n\nvec3 Translate(vec3 p,vec3 trans){\n  return p-trans;\n}\n\nvec3 RotateAxis(vec3 v,vec3 axis,float degree){\n  return RotationAxis(axis,degree)*v;\n}\n\nfloat Intersect(float a,float b){\n  return max(a,b);\n}\n\nfloat Difference(float a,float b){\n  return max(a,-b);\n}\n\nfloat Correction(float a,float b,float r){\n  r=max(0.0001,min(r,1.0));\n  float h=max(r-abs(a-b),0.)/r;\n  return (r*h*h*h)/6.;\n}\n\nfloat SmoothUnion(float a, float b,float r){\n    return Union(a, b) - Correction(a, b, r);\n}\n\nfloat SmoothUnion(float a, float b){\n    return Union(a, b) - Correction(a, b, 1.);\n}\n\n// Primitives\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\n\n//Renvoie la distance signée à la surface d'une boule\nfloat Ball(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n//Renvoie la distance absolue à la surface d'une boule\nfloat Sphere(vec3 p,vec3 c,float r)\n{\nreturn abs(Ball(p,c,r))-0.1;\n}\n\n//Renvoie un plan avec toutes les longueurs négatives en dessous de la normale. utile pour des formes polyédriques\nfloat signedPlane(vec3 p,vec3 c, vec3 normal) {\n  vec3 cp=p-c;\n  float resDot=dot(cp,normal);\n  float len=length(getProjectionVector(cp,normal));\n  if(resDot>=0.){\n    return len;\n  }\n  else return -len;\n}\n//Renvoie un plan sans épaisseur\nfloat Plane(vec3 p, vec3 c, vec3 normal) {\n  vec3 pc=p-c;\n  return length(getProjectionVector(pc,normal));\n}\n\n//Renvoie un plan très fin\nfloat ThinPlane(vec3 p, vec3 c, vec3 normal){\n  return Plane(p,c,normal)-0.1;\n}\n\n//vérifie s'il est sur le même plan\nbool onSamePlane(vec3 v, vec3 pnormal, vec3 normal) {\n  return Plane(v,pnormal,normal)<0.001;\n}\n\n//distance à un disque. est dans l'axe si la norme du rejection vector est  inférieur au rayon\nfloat Disc(vec3 p, vec3 center, vec3 normal, float radius) {\n  vec3 hypotenuse=p-center;\n  if(inCircleAxe(p,center,normal,radius)){\n      return Plane(p,center,normal);\n  }\n  vec3 parallel=getRejectionVector(hypotenuse,normal);\n   return distance(p,center+changeLength(parallel,radius)); \n}\n\n//distance à un cercle sans surface\nfloat Circle(vec3 p,vec3 center,vec3 normal,float radius){\n    vec3 hypotenuse=p-center;\n    vec3 parallel=getRejectionVector(hypotenuse,normal);\n    return abs(distance(p,center+changeLength(parallel,radius))); \n}\n\n//distance à un disque avec épaisseur\nfloat Cheese(vec3 p,vec3 center,vec3 normal,float radius,float width){\n  return Disc(p,center,normal,radius)-width;\n}\n\n\n\n//distance à une droite infinie\nfloat Droite(vec3 p,vec3 a,vec3 b){\n    vec3 u1 = normalize(b - a);\n    vec3 PA=p-a;\n    float distA=distance(p,a);\n    float proja=dot(PA,u1);\n    return sqrt(sqr(distA)-sqr(proja));\n}\n\n//distance à un segment\nfloat Segment(vec3 p, vec3 a, vec3 b) {\n    float distA=distance(p,a);\n    vec3 u1 = normalize(b - a);\n    vec3 PA=p-a;\n    float proja=dot(PA,u1);\n    if(isBetweenPoints(p,a,b)){\n        return sqrt(sqr(distA)-sqr(proja));\n    }\n    else{\n      float distB=distance(p,b); \n      return min(distA,distB);\n    } \n}\n//distance à un triangle, pareil que pour le parallélogramme\n float Triangle(vec3 p,vec3 a,vec3 b,vec3 c){\n   vec3 ab=b-a;\n   vec3 ac=c-a;\n   vec3 normal=getNormal(ac,ab);\n   if(isInTriangleAxis(p,a,b,c)){\n      return Plane(p,b,normal);\n   }\n   float outside =min(min(Segment(p,a,b),Segment(p,b,c)),Segment(p,a,c));\n   return outside;\n }\n//distance à un rectangle\nfloat Rectangle(vec3 p,vec3 a,vec3 b,vec3 dirPoint,vec3 normal,float width) {\n  vec3 ab= a-b;\n  vec3 adirPoint=dirPoint-a;\n  vec3 bdirPoint=dirPoint-b;\n  vec3 norm2=getNormal(normal,ab);\n  vec3 anorm=getNormalTowards(a,norm2,dirPoint);\n  anorm=changeLength(anorm,width);\n  vec3 c=b+anorm;\n  vec3 d=a+anorm;\n  if(isInParallelogramAxis(p, a, b, c, d)) {\n      return Plane(p, a, normal);\n  }\n  float outside = min(min(min(Segment(p, a, b), Segment(p, b, c)), Segment(p, c, d)), Segment(p, a, d));\n  return outside;\n}\n//distance à un carré\nfloat Square(vec3 p,vec3 a,vec3 c,vec3 normal){\n  vec3 ca=c-a;\n  vec3 mid=(c+a)/2.;\n  vec3 halfdiag=ca/2.;\n  vec3 d=mid+RotateAxis(halfdiag,normal,90.);\n  vec3 b=mid-RotateAxis(halfdiag,normal,90.);\n  if(isInParallelogramAxis(p,a,b,c,d)){\n    return Plane(p,mid,normal);\n  }\n  else  {\n    float seg1=Segment(p,a,b);\n    float seg2=Segment(p,b,c);\n    float seg3=Segment(p,c,d);\n    float seg4=Segment(p,d,a);\n    return min(min(min(seg1,seg2),seg3),seg4);\n  }\n}\n//Distance à un carré avec épaisseur\nfloat RoundSquare(vec3 p,vec3 a,vec3 c,vec3 normal,float dist){\n  return Square(p,a,c,normal)-dist;\n}\n\n//Distance à un parallélogramme. renvoie la distance à un plan si la somme des angles entre la projection de p\n//sur le plan formé par a,b,c est environ égale à 360;, sinon le minimum des 4 segments.\nfloat Parallelogram(vec3 p, vec3 a,vec3 b,vec3 c){\n  vec3 ab=b-a;\n  vec3 bc=c-b;\n  vec3 d=c-ab;\n  if(isInParallelogramAxis(p,a,b,c,d)){\n    return Plane(p,a,getNormal(ab,bc));\n  }\n  else {\n    float seg1=Segment(p,a,b);\n    float seg2=Segment(p,b,c);\n    float seg3=Segment(p,c,d);\n    float seg4=Segment(p,a,d);\n    return min(min(min(seg1,seg2),seg3),seg4);\n  }\n}\n\n//Distance à un parallélogramme avec épaisseur\nfloat RoundParallelogram(vec3 p, vec3 a,vec3 b,vec3 c,float dist){\n  return Parallelogram(p,a,b,c)-dist;\n}\n\n//Intersection de 6 plans. Possibilité de faire n'importe quel parallélépipède\nfloat Box(vec3 p,vec3 a1,vec3 b1,vec3 c1,vec3 dirPoint,float len){\n    vec3 b1c1=c1-b1;\n    vec3 d1=a1+b1c1;\n    vec3 normal=changeLength(getNormalTowards(a1,b1,c1,dirPoint),len);\n    vec3 a2=a1+normal;\n    vec3 b2=b1+normal;\n    vec3 c2=c1+normal;\n    vec3 d2=d1+normal;\n    vec3 n1=-normal;\n    vec3 n2=-n1;\n    vec3 n3=getNormalOpp(a1,a2,b2,c2);\n    vec3 n4=getNormalOpp(b1,b2,c2,a2);\n    vec3 n5=-n3;\n    vec3 n6=-n4;\n    float Plane1=signedPlane(p,a1,n1);\n    float Plane2=signedPlane(p,a2,n2);\n    float Plane3=signedPlane(p,a1,n3);\n    float Plane4=signedPlane(p,b1,n4);\n    float Plane5=signedPlane(p,c1,n5);\n    float Plane6=signedPlane(p,d1,n6);\n    return Intersect(Intersect(Intersect(Intersect(Intersect(Plane1,Plane2),Plane3),Plane4),Plane5),Plane6);\n }\n\n//Distance à un segment avec épaisseur\nfloat Capsule(vec3 p, vec3 center1, vec3 center2, float radius) {\n  float distToCenter=Segment(p,center1,center2);\n  return distToCenter - radius;\n}\n\n//Test d'orthogonalité des fonctions getNormal\nfloat Orthogonal(vec3 p){\n  vec3 base =vec3(0,0,0);\n  vec3 original=changeLength(vec3(0,1,0),-5.);\n  vec3 firstNormal=getNormal(original);\n  vec3 secNormal=getNormal(original,firstNormal);\n  return Union(Union(Capsule(p,base,original,1.),Capsule(p,base,firstNormal,1.)),Capsule(p,base,secNormal,1.));\n}\n\n//Distance à un disque si en dehors des 2 points sinon au segment-radius;\nfloat Cylinder(vec3 p, vec3 center1, vec3 center2, float radius) { \n    vec3 axis = center1 - center2;\n    if(isBetweenPoints(p,center1,center2)){\n      return Segment(p,center1,center2)-radius;\n    }\n    else return min(Disc(p,center1,axis,radius),Disc(p,center2,axis,radius))-0.01;\n}\n\n\n//Cone, distance défini par le triangle formé par le plan entre p et l'axe. Possède un problème d'affichage malgré les efforts\n//Possibilité de modifier avec l'intersection de plans 2D\nfloat Cone(vec3 p, vec3 discCenter,vec3 tip,float radius){\n  vec3 seg=tip-discCenter;\n  float h=length(seg);\n  float diaglength=sqrt(sqr(h)+sqr(radius));\n  float halfConeAngle=degrees(acos(h/diaglength));\n  bool inCone=true;\n  vec3 v=tip-p;\n  vec3 rej=getRejectionVector(v,seg);\n  vec3 proj=getProjectionVector(v,seg);\n  float angle=degrees(acos(length(proj)/length(v)));;\n  rej=changeLength(rej,radius);\n  vec3 x=discCenter-rej;\n\n  bool belowDisc=false;\n  bool withinAngle=false;\n  bool AboveTip=false;\n  bool inside;\n  if(abovePlane(p,tip,seg)){\n    if(angle<=halfConeAngle){\n        AboveTip=true;\n    }\n    else{\n      withinAngle=true;\n    }\n  }\n  else if(isBetweenPoints(p,discCenter,tip)){\n    withinAngle=true;\n    if(angle<=halfConeAngle){\n      inside=true;\n    }\n  }\n  else {\n    belowDisc=true;\n  }\n  if(withinAngle){\n    float minDist=Segment(p,x,tip);\n    if(inside){\n      return -minDist;\n    }\n    else return minDist-0.1;\n  }\n  else if(AboveTip){\n    return distance(p,tip);\n  }\n  else {\n    return Disc(p,discCenter,seg,radius);\n  }\n}\n\n\n\n// Pareil que CapsuleCircle mais avec un angle total prédéfini\nfloat CapsuleRotation(vec3 p, vec3 center, vec3 dir, float radius, int nbCapsules,int Angle,float totalAngle) {\n    if (nbCapsules<= 0) nbCapsules = 1;\n    float angle = totalAngle / float(nbCapsules);\n    vec3 orthoDir = getNormal(dir); \n    vec3 orthoDir2=getNormal(dir,orthoDir);\n    orthoDir=RotateAxis(orthoDir,orthoDir2,float(Angle));\n    float prevUnion = Capsule(p, center, center+orthoDir, radius);\n    for (int i = 0; i < nbCapsules-1; ++i) {\n        orthoDir = RotateAxis(orthoDir, dir,angle);\n        prevUnion = Union(prevUnion, Capsule(p, center, center+orthoDir, radius));\n    }\n    return prevUnion;\n}\n\n// Cercle de n capsules autour d'un axe répartis uniformément\nfloat CapsuleCircle(vec3 p, vec3 center, vec3 dir, float radius, int nbCapsules,int Angle) {\n    if (nbCapsules<= 0) nbCapsules = 1;\n    float angle = 360. / float(nbCapsules);\n    vec3 orthoDir = getNormal(dir); \n    vec3 orthoDir2=getNormal(dir,orthoDir);\n    orthoDir=RotateAxis(orthoDir,orthoDir2,float(Angle));\n    float prevUnion = Capsule(p, center, center+orthoDir, radius);\n    for (int i = 0; i < nbCapsules-1; ++i) {\n        orthoDir = RotateAxis(orthoDir, dir,angle);\n        prevUnion = Union(prevUnion, Capsule(p, center, center+orthoDir, radius));\n    }\n    return prevUnion;\n}\n\n//Rotation de n CapsuleCircle pour former un hérisson, cependant il y a un problème de rotation que je ne comprend pas\nfloat HedgeHog(vec3 p, vec3 center, vec3 dir, float radius, int nbCapsules, int nbCircles,int Angle) {\n    if (nbCircles<= 0)nbCircles = 1;\n    if(nbCapsules<=0)nbCapsules=1;\n    float angle = 360. / float(nbCircles);\n    vec3 normal=getNormal(dir);\n    float prevUnion= CapsuleCircle(p, center, dir, radius, nbCapsules,Angle);\n    for (int i = 0; i < nbCircles-1; i++) {\n      dir = RotateAxis(dir,normal, angle);\n      prevUnion = Union(prevUnion, CapsuleCircle(p, center, dir, radius, nbCapsules,Angle));\n    }\n    return prevUnion;\n}\n\n\n\n\n\n\n//Distance à un Cercle avec épaisseur\nfloat Torus(vec3 p, vec3 center, vec3 normal, float Radius, float width) {\n    return Circle(p, center, normal, Radius) - width;\n}\n\n//Inverse du Torus (pas très utile)\nfloat invTor(vec3 p, vec3 center, vec3 normal, float Radius, float width){\n  return -Torus(p,center,normal,Radius,width);\n}\n\n//Union de boules formant un début de bonhomme de neige\nfloat Snowman(vec3 p, vec3 start, float radius) {\n    float bottomSphereRadius = radius * 1.4;\n    float middleSphereRadius = radius * 1.;\n    float topSphereRadius = radius*0.7;\n    vec3 posMid=start+1.2*vec3(0,0,bottomSphereRadius);\n    vec3 posTop=posMid+1.2*vec3(0,0,middleSphereRadius);\n    float bottomSphere=Sphere(p,start,bottomSphereRadius);\n    float middleSphere=Sphere(p,posMid,middleSphereRadius);\n    float topSphere=Sphere(p,posTop,topSphereRadius);\n    return SmoothUnion(SmoothUnion(bottomSphere,middleSphere,0.5),topSphere,0.5);\n}\n\n\n//Test de la fonction rejectionVector\nfloat TriangleCapsule(vec3 p, vec3 start, vec3 orientation1, vec3 orientation2, float radius){\n    vec3 r = -getRejectionVector(orientation1, orientation2);\n    vec3 end1 = start + orientation1; \n    vec3 end2 = start + orientation2; \n    return Union(Union(Capsule(p, start, end1, radius), Capsule(p, start, end2, radius)), Capsule(p, end1, end1+r, radius));\n}\n\n//Triangle avec épaisseur\nfloat RoundTriangle(vec3 p,vec3 a,vec3 b,vec3 c,float width){\n  return Triangle(p,a,b,c)-width;\n}\n\n//Rectangle avec épaisseur\nfloat RoundRectangle(vec3 p,vec3 a,vec3 b,vec3 c,vec3 normal,float width,float dist){\n  return Rectangle(p,a,b,c,normal,width)-dist;\n}\n\n\n/* Tentative d'arbre récursif, mais glsl ne supporte pas, pas de tableau dynamiques, et pas de formule pour savoir le nombre de feuilles à chaque niveau.*/ \n\n// float Tree(vec3 p,vec3 start,vec3 dir,float len,float radius,int nbJunctions,int Capsules,int SubBranches) {\n//     float angle = 360. / float(Capsules);\n//     int nbLast=0;\n//     float prevUnion=1.;\n//     float leavesSize=0.;\n//     vec3 lastPositions[1000];\n//     vec3 lastDirections[1000];\n//     for(int k=SubBranches;k>0;--k){\n//       float distJunction=len/float(nbJunctions);\n//       nbLast=nbJunctions*Capsules;\n//       for(int z=0;z<)\n//         for(int j=0;j<nbJunctions;++j){ \n//           center+=changeLength(dir,distJunction);\n//             prevUnion=Branch(p, center, (center+orthoDir)/1.5, radius/1.5,nbJunctions,CapsulesPerJunctions,SubBranches-1);\n//           for (int i = 0; i < Capsules-1; ++i) {\n//               orthoDir = RotateAxis(orthoDir, dir,angle);\n//               prevUnion = Union(prevUnion, Capsule(p, center, (center+orthoDir)/1.5, radius/1.5,nbJunctions,CapsulesPerJunctions,SubBranches-1));\n//           }\n//         }\n//     }\n  \n//   for(int l=0;l<nbLast;++l){\n//     vec3 end=lastPositions[l];\n//     vec3 leafSide=changeLength(lastDirections[l],leavesSize);\n//     vec3 a=end-leafSide/2.;\n//     vec3 b=end+leafSide/2.;\n//     vec3 c=end+changeLength(dir,length(leafSide));\n//     prevUnion= Union(prevUnion,RoundTriangle(p,a,b,c,radius/3.));\n//   }\n\n// }\n\n\n\n\n/*La Construction par intersection de plans pose un problème pour RoundToblerone qui avant adoucissait le contour.\nMaintenant les distances extérieures sont biaisées ce qui fait simplement augmenter la taille du toblerone tout en le déformant*/\n//Prisme en vrai Toblerone pour les intimes. La forme du triangle peut être quelconque\nfloat Toblerone(vec3 p,vec3 a1,vec3 b1,vec3 c1,vec3 pointDir,float dist){\n  vec3 normal=changeLength(getNormalTowards(a1,b1,c1,pointDir),dist);\n  vec3 a2=a1+normal;\n  vec3 b2=b1+normal;\n  vec3 c2=c1+normal;\n  vec3 norm1=getNormalOpp(a1,b1,c1,c2);\n  vec3 norm2=getNormalOpp(a2,b2,c2,c1);\n  vec3 norm3=getNormalOpp(a1,a2,b2,c2);\n  vec3 norm4=getNormalOpp(b1,b2,c2,a2);\n  vec3 norm5=getNormalOpp(c1,c2,a2,b2);\n  float splane1=signedPlane(p,a1,norm1);\n  float splane2=signedPlane(p,a2,norm2);\n  float splane3=signedPlane(p,a1,norm3);\n  float splane4=signedPlane(p,b1,norm4);\n  float splane5=signedPlane(p,c1,norm5);\n  float result=Intersect(Intersect(Intersect(Intersect(splane1,splane2),splane3),splane4),splane5);\n  return result;\n}\n\n//Intersection de 4 plans formés par 4 triangles\nfloat Tetraedre(vec3 p,vec3 a,vec3 b,vec3 c,vec3 d){\n   vec3 nabc=getNormalOpp(a,b,c,d);\n   vec3 nabd=getNormalOpp(a,b,d,c);\n   vec3 nacd=getNormalOpp(a,d,c,b);\n   vec3 nbcd=getNormalOpp(b,c,d,a);\n  float splane1=signedPlane(p,a,nabc);\n  float splane2=signedPlane(p,a,nabd);\n  float splane3=signedPlane(p,a,nacd);\n  float splane4=signedPlane(p,b,nbcd);\n  return Intersect(Intersect(Intersect(splane1,splane2),splane3),splane4);\n }\n\n\n//Intersection de 5 plans formés par 4 triangles et 1 carré\nfloat Pyramid(vec3 p,vec3 a,vec3 c,vec3 normal,float height){\n  float distTr1,distTr2,distTr3,distTr4,distBase;\n  vec3 ca=c-a;\n  vec3 mid=(c+a)/2.;\n  vec3 halfdiag=ca/2.;\n  vec3 d=mid+RotateAxis(halfdiag,normal,90.);\n  vec3 b=mid-RotateAxis(halfdiag,normal,90.);\n  vec3 top=mid+changeLength(normal,height);\n  \n  vec3 nabcd=getNormalOpp(d,a,b,top);\n  vec3 nabtop=getNormalOpp(a,b,top,c);\n  vec3 nadtop=getNormalOpp(a,d,top,b);\n  vec3 nbctop=getNormalOpp(b,c,top,d);\n  vec3 ncdtop=getNormalOpp(c,d,top,a);\n  float splane1=signedPlane(p,a,nabcd);\n  float splane2=signedPlane(p,a,nabtop);\n  float splane3=signedPlane(p,a,nadtop);\n  float splane4=signedPlane(p,b,nbctop);\n  float splane5=signedPlane(p,c,ncdtop);\n  return Intersect(Intersect(Intersect(Intersect(splane1,splane2),splane3),splane4),splane5);\n}\n\n//Si Corners<=2 un cylindre sinon une intersection de Corners plan Signés avec une rotation de 360/Corners à chaque plan\nfloat Column(vec3 p,vec3 p1,vec3 p2,float radius,int Corners){\n  if(Corners<=2){\n    return Cylinder(p,p1,p2,radius);\n  }\n  else{\n    vec3 seg=p2-p1;\n    vec3 splaneNormal=changeLength(getNormal(seg),radius);\n    float angle=360./float(Corners);\n    vec3 planePoint=p1+splaneNormal;\n    float prevIntersect=signedPlane(p,planePoint,splaneNormal);\n    for(int i=1;i<Corners;++i){\n      splaneNormal=RotateAxis(splaneNormal,seg,angle);\n      planePoint=p1+splaneNormal;\n      prevIntersect=Intersect(prevIntersect,signedPlane(p,planePoint,splaneNormal));\n    }\n    float disc1=signedPlane(p,p1,-seg);\n    float disc2=signedPlane(p,p2,seg);\n    return Intersect(Intersect(prevIntersect,disc1),disc2);\n  }\n}\n\n//Lignes de n colomnes répartis avec une distance n*ColumnSpace;\nfloat ColumnLine(vec3 p,vec3 start,vec3 dir,vec3 normal,int nbColumn,float ColumnSpace,float ColumnRadius,int Corners){\n  float prevUnion=Column(p,start,start+normal,ColumnRadius,Corners);\n  dir=changeLength(dir,ColumnSpace);\n  for(int i=1;i<nbColumn;++i){\n    start=start+dir;\n    prevUnion=Union(prevUnion,Column(p,start,start+normal,ColumnRadius,Corners));\n  }\n  return prevUnion;\n}\n\n//Escaliers droits, union de Box\nfloat Stairs(vec3 p,vec3 a,vec3 b,vec3 normal,vec3 dirPoint,int nbSteps,float len){\n  vec3 ab=b-a;\n  vec3 direction=getNormalTowards(a,b,b+normal,dirPoint);\n  vec3 upLen=changeLength(normal,len);\n  vec3 directionLen=changeLength(direction,len);\n  vec3 leftStep=a;\n  vec3 rightStep=b;\n  vec3 endStep=rightStep+upLen;\n  float longueur;\n  float prevStep=Box(p,leftStep,rightStep,endStep,endStep+directionLen+upLen,len*float(nbSteps));\n  for(int i=1;i<nbSteps;++i){\n    longueur=len*float((nbSteps-i));\n    leftStep+=upLen+directionLen;\n    rightStep+=upLen+directionLen;\n    endStep=rightStep+upLen;\n    prevStep=Union(prevStep,Box(p,leftStep,rightStep,endStep,endStep+directionLen+upLen,longueur));\n  }\n  return prevStep;\n}\n\n//Escaliers dans un angle pas forcément de 90°\nfloat AngleStairs(vec3 p,vec3 start,vec3 dirLeft,vec3 dirRight,vec3 dirPoint,int nbSteps,float len){\n  dirLeft=changeLength(dirLeft,float(nbSteps)*len);\n  dirRight=changeLength(dirRight,float(nbSteps)*len);\n\n  vec3 leftCorner=start+dirLeft;\n  vec3 rightCorner=start+dirRight;\n  vec3 midCorner=start;\n  vec3 normal=getNormalTowards(leftCorner,midCorner,rightCorner,dirPoint);\n\n  vec3 upLen=changeLength(normal,len);\n  vec3 dirLeftLen=changeLength(dirLeft,len);\n  vec3 dirRightLen=changeLength(dirRight,len);\n  vec3 upCorner=midCorner+upLen;\n  float longueur;\n  float prevStep=Box(p,leftCorner,midCorner,upCorner,upCorner+dirRightLen,len*float(nbSteps));\n   for(int i=1;i<nbSteps;++i){\n     longueur=len*float((nbSteps-i));\n     leftCorner+=dirRightLen+upLen;\n     midCorner+=dirLeftLen+dirRightLen+upLen;\n     upCorner=midCorner+upLen;\n     prevStep=Union(prevStep,Box(p,leftCorner,midCorner,upCorner,upCorner+dirRightLen,longueur));\n   }\n  return prevStep;\n}\n\n//Pyramide de 4 AnglesStairs. 4 fois plus de primitives, non optimisé\nfloat PyramidAngleStairs(vec3 p,vec3 center,vec3 normal,float rotation,int nbSteps,float len){\n  vec3 norm1=getNormal(normal);\n  norm1=RotateAxis(norm1,normal,rotation);\n  float longueur=float(nbSteps)*len;\n  vec3 norm2=getNormal(norm1,normal);\n  norm1=changeLength(norm1,longueur);\n  norm2=changeLength(norm2,longueur);\n  vec3 corner=center+norm1+norm2;\n  float prevUnion=AngleStairs(p,corner,norm1-corner,norm2-corner,center,nbSteps,len);\n   for(int i=1;i<4;++i){\n    vec3 oldnorm=norm1;\n    norm1=RotateAxis(norm1,normal,90.);\n    norm2=RotateAxis(norm2,normal,90.);\n    corner=center+norm1+norm2;\n    prevUnion=Union(prevUnion,AngleStairs(p,corner,norm1-corner,norm2-corner,center,nbSteps,len));\n   }\n  return prevUnion;\n}\n\n//Intersection de deux triangles équilatéraux avec épaisseur\nfloat Star(vec3 p,vec3 pos,vec3 normal,float size,float dist,float rotation){\n  vec3 norm1=changeLength(getNormal(normal),size/2.);\n  norm1=RotateAxis(norm1,normal,rotation);\n  vec3 norm2=RotateAxis(norm1,normal,60.);\n  vec3 a1=pos+norm1;\n  norm1=RotateAxis(norm1,normal,120.);\n  vec3 b1=pos+norm1;\n  norm1=RotateAxis(norm1,normal,120.);\n  vec3 c1=pos+norm1;\n  vec3 a2=pos+norm2;\n  norm2=RotateAxis(norm2,normal,120.);\n  vec3 b2=pos+norm2;\n  norm2=RotateAxis(norm2,normal,120.);\n  vec3 c2=pos+norm2;\n  float tr1=RoundTriangle(p,a1,b1,c1,dist);\n  float tr2=RoundTriangle(p,a2,b2,c2,dist);\n  return Union(tr1,tr2);\n}\n\n//Pyramide Complête de Box\nfloat PyramidBox(vec3 p,vec3 center,vec3 normal,float rotation,int nbSteps,float len){\n  vec3 norm1=getNormal(normal);\n  normal=changeLength(normal,len);\n  norm1=RotateAxis(norm1,normal,rotation);\n  float longueur=float(nbSteps)*len;\n  vec3 norm2=getNormal(norm1,normal);\n  norm1=changeLength(norm1,longueur);\n  norm2=changeLength(norm2,longueur);\n  longueur*=2.;\n  vec3 dirLeft=norm1+norm2;\n  vec3 dirRight=RotateAxis(dirLeft,normal,90.);\n  vec3 cornerLeft=center+dirLeft;\n  vec3 cornerRight=center+dirRight;\n  float diagLength=sqrt(sqr(len)+sqr(len));\n  vec3 dirLeftInv=-changeLength(dirLeft,diagLength);\n  vec3 dirRightInv=-changeLength(dirRight,diagLength);\n  vec3 upCorner=cornerRight+normal;\n  float prevUnion=Box(p,cornerLeft,cornerRight,upCorner,center,longueur);\n  for(int i=1;i<nbSteps;++i){\n    longueur=2.*float(nbSteps-i)*len;\n    cornerLeft+=dirLeftInv+normal;\n    cornerRight+=dirRightInv+normal;\n    upCorner=cornerRight+normal;\n    prevUnion=Union(prevUnion,Box(p,cornerLeft,cornerRight,upCorner,center,longueur));\n  }\n  return prevUnion;\n}\n\n//Union d'un cone au bout d'une capsule\nfloat Lance(vec3 p,vec3 start,vec3 dir,float len){\n  vec3 sep=start+changeLength(dir,0.75*len);\n  float Pointe=Cone(p,sep,sep+changeLength(dir,0.25*len),len*0.05);\n  float Stick=Capsule(p,start,start+changeLength(dir,0.75*len),len*0.02);\n  return Union(Stick,Pointe);\n}\n\n//Pyramide à socle. commence du Haut puis descend avec un nombre nbSteps d'escalier et len pour la taille de chaque marche\nfloat FlatPyramid(vec3 p,vec3 topCenter,vec3 normal,float rotation,int nbSteps,float len,float topSize){\n  vec3 norm1=getNormal(normal);\n  normal=changeLength(normal,len);\n  norm1=RotateAxis(norm1,normal,rotation);\n  vec3 norm2=getNormal(norm1,normal);\n  norm1=changeLength(norm1,topSize/2.);\n  norm2=changeLength(norm2,topSize/2.);\n  float longueur=topSize;\n  vec3 dirLeft=norm1+norm2;\n  vec3 dirRight=RotateAxis(dirLeft,normal,90.);\n  vec3 cornerLeft=topCenter+dirLeft;\n  vec3 cornerRight=topCenter+dirRight;\n  float diagLength=sqrt(sqr(len)+sqr(len));\n  vec3 dirLeftStep=changeLength(dirLeft,diagLength);\n  vec3 dirRightStep=changeLength(dirRight,diagLength);\n  vec3 upCorner=cornerRight-normal;\n  float prevUnion=Box(p,cornerLeft,cornerRight,upCorner,topCenter,longueur);\n  for(int i=1;i<nbSteps;++i){\n    longueur=topSize+2.*float(i)*len;\n    cornerLeft+=dirLeftStep-normal;\n    cornerRight+=dirRightStep-normal;\n    upCorner=cornerRight-normal;\n    prevUnion=Union(prevUnion,Box(p,cornerLeft,cornerRight,upCorner,topCenter,longueur));\n  }\n  return prevUnion;\n}\n\n//Une Box, 2 lignes de Colonnes,une autre Box puis un prisme en toit\nfloat Temple(vec3 p,vec3 pos,vec3 normal,float rotation,float width,float len){\n  vec3 norm1=changeLength(getNormal(normal),width);\n  if(mod(rotation,360.)!=0.){\n    norm1=RotateAxis(norm1,normal,rotation);\n  }\n  vec3 norm2=changeLength(getNormal(norm1,normal),len);\n  vec3 halfwidth=norm1/2.;\n  vec3 halflen=norm2/2.;\n  vec3 halfdiag1=halfwidth+halflen;\n  vec3 halfdiag2=halfwidth-halflen;\n  vec3 pt1Socle=pos+halfdiag1;\n  vec3 pt2Socle=pos+halfdiag2;\n  vec3 pt3Socle=pt2Socle+changeLength(normal,min(width,len)/25.);\n  float socle=Box(p,pt1Socle,pt2Socle,pt3Socle,pos,width);\n  vec3 sideLen=pt2Socle-pt1Socle;\n  vec3 sideWidth=-(halfdiag1+halfdiag2);\n    pt1Socle=pt3Socle-sideLen;\n  pt2Socle=pt3Socle;\n  vec3 pillLeftStart=pt1Socle-halfdiag1*0.1;\n  vec3 pillRightStart=pt2Socle-halfdiag2*0.1;\n  int nbColumn=8;\n  float space=length(sideWidth)/float(nbColumn);\n  float radiusCol=width/45.;\n  int nbCorners=6;\n  float ColumnHeight=width/3.;\n  vec3 ColumnNormal=changeLength(normal,ColumnHeight);\n  float linePillarsLeft=ColumnLine(p,pillLeftStart,sideWidth,ColumnNormal,nbColumn,space,radiusCol,nbCorners);\n  float linePillarsRight=ColumnLine(p,pillRightStart,sideWidth,ColumnNormal,nbColumn,space,radiusCol,nbCorners);\n  float linePillars=Union(linePillarsLeft,linePillarsRight);\n  \n  float boxRoofHeight=ColumnHeight/7.;\n  vec3 LeftBoxRoofCorner=pt1Socle+ColumnNormal;\n  vec3 RightBoxRoofCorner=pt2Socle+ColumnNormal;\n  vec3 thirdBoxRoofCorner=RightBoxRoofCorner+changeLength(normal,boxRoofHeight);\n  float BoxRoof=Box(p,LeftBoxRoofCorner,RightBoxRoofCorner,thirdBoxRoofCorner,pos,width);\n  float roofHeight=ColumnHeight/2.5;\n  vec3 RightRoofCorner=thirdBoxRoofCorner-halflen/10.+halfwidth/10.;\n  vec3 LeftRoofCorner=thirdBoxRoofCorner-sideLen+halflen/10.+halfwidth/10.;\n  vec3 topRoofCorner=(LeftRoofCorner+RightRoofCorner)/2.+changeLength(normal,roofHeight);\n  float RoofWidth=width+2.*length(halfwidth)/10.;\n  float Roof=Toblerone(p,LeftRoofCorner,RightRoofCorner,topRoofCorner,pos,RoofWidth);\n  float temple=Union(BoxRoof,Union(Roof,Union(socle,linePillars)));\n  return temple;\n}\n\n// Casque résultant de la différence entre 2 boules avec translation diagonale du 2ème centre.\n// La rotation ne fonctionne pas avec la les \"plumes\"\nfloat Helmet(vec3 p,vec3 pos,vec3 normal,float radius,float rotation){\n    float sphere1=Ball(p,pos,radius);\n    normal=changeLength(normal,radius/7.);\n    vec3 norm=getNormal(normal);\n    norm=RotateAxis(norm,normal,rotation);\n    vec3 norm2=getNormal(norm,normal);\n    float sphere2=Ball(p,pos-normal+norm/1.5,radius);\n    float feathers=CapsuleRotation(p,pos,changeLength(norm2,radius*1.7),radius/5.,10,0,-150.);\n    return Union(Difference(feathers,sphere2),Difference(sphere1,sphere2));\n}\n\n\n//Statue Soldat Romain avec un casque, une lance et un bouclier\nfloat Statue(vec3 p,vec3 pos,vec3 normal,float scale,float rotation){\n  float size=10.*scale;\n  vec3 endPoint=pos+changeLength(normal,size);\n  vec3 wholeStatueVec=endPoint-pos;\n  vec3 helmetpos=pos+wholeStatueVec*0.9;\n  float helmet=Helmet(p,helmetpos,normal,size*0.2,rotation+90.);\n  float visageSizeRadius=size*0.18;\n  vec3 visagePos=helmetpos-wholeStatueVec*0.05;\n  float visage=Ball(p,visagePos,visageSizeRadius);\n  float couLength=visageSizeRadius/2.;\n  vec3 couUp=visagePos-changeLength(wholeStatueVec,size*0.15);\n  vec3 couDown=couUp-changeLength(wholeStatueVec,couLength);\n  float cou=Cylinder(p,couUp,couDown,visageSizeRadius/4.);\n  vec3 leftNormal=getNormal(normal);\n  vec3 rightNormal=-leftNormal;\n  vec3 dirFacing=-getNormal(normal,leftNormal);\n  float bodyLen=size*0.35;\n  float bodyWidth=size*0.5;\n  float bodyThickness=visageSizeRadius/3.;\n\n  float distCou=bodyThickness/1.5;\n  vec3 leftRect=couDown+changeLength(leftNormal,bodyLen/2.)-changeLength(normal,distCou);\n  vec3 rightRect=couDown+changeLength(rightNormal,bodyLen/2.)-changeLength(normal,distCou);\n  vec3 bodyLenVec=leftRect-rightRect;\n  vec3 bodyWidthVec=changeLength(-normal,bodyWidth);\n  float body=RoundParallelogram(p,leftRect,rightRect,rightRect-changeLength(normal,bodyWidth),bodyThickness);\n  float armRadius=bodyThickness;\n  vec3 LeftArmBeg=leftRect;\n  vec3 LeftArmEnd=LeftArmBeg+changeLength(RotateAxis(-normal,bodyLenVec,50.)+bodyLenVec/12.,bodyWidth);\n  float handRadius=armRadius*1.5;\n  float leftHand=Ball(p,LeftArmEnd,handRadius);\n  float LeftArm=Capsule(p,LeftArmBeg,LeftArmEnd,armRadius);\n  float shieldThick=bodyThickness/3.;\n  float shield=Cheese(p,LeftArmEnd+changeLength(dirFacing,armRadius),dirFacing,handRadius*3.5,shieldThick);\n  float LeftSide=Union(Union(leftHand,LeftArm),shield);\n\n  vec3 rightArmBeg=rightRect;\n  vec3 rightArmEnd=rightArmBeg-bodyLenVec+bodyWidthVec+changeLength(dirFacing,bodyWidth*sin(iTime*2.));\n  float rightArm=Capsule(p,rightArmBeg,rightArmEnd,armRadius);\n  float rightHand=Ball(p,rightArmEnd,handRadius);\n  float lance=Lance(p,rightArmEnd-changeLength(dirFacing,bodyLen*2.),dirFacing,bodyWidth*4.);\n  float RightSide=Union(lance,Union(rightArm,rightHand));\n\n  float legLength=bodyWidth*1.5;\n  float legRadius=armRadius*1.3;\n  float deltaLegPos=bodyLen*sin(iTime);\n  vec3 leftLegBeg=leftRect+changeLength(-normal,bodyWidth);\n  vec3 leftLegEnd=leftLegBeg+changeLength(-normal,legLength)+changeLength(dirFacing,deltaLegPos);\n  float leftLeg=Capsule(p,leftLegBeg,leftLegEnd,legRadius);\n  vec3 rightLegBeg=rightRect+changeLength(-normal,bodyWidth);\n  vec3 rightLegEnd=rightLegBeg+changeLength(-normal,legLength)+changeLength(dirFacing,-deltaLegPos);\n  float rightLeg=Capsule(p,rightLegBeg,rightLegEnd,legRadius);\n  float legs=Union(leftLeg,rightLeg);\n  float statue=SmoothUnion(legs,Union(RightSide,Union(LeftSide,Union(body,Union(cou,Union(helmet,visage))))),0.3);\n  return statue;\n}\n\n\n//Pyramide avec Socle, Tor avec rotation Soleil et Lune, Temple et soldat Romain.\nfloat Beauty(vec3 p){\n  vec3 normal=vec3(0,0,1);\n  vec3 normal2=getNormal(normal);\n  \n  float z;\n  float topPyrSize=15.;\n  \n  float time=mod(iTime/2.,20000.);\n  normal2=RotateAxis(normal2,normal,3.*time);\n  float pyrStairSize=0.3;\n  int nbStairsPyr=3;\n  vec3 StairsHeight=changeLength(normal,pyrStairSize*float(nbStairsPyr));\n  vec3 startPos=vec3(0,0,-3.);\n  vec3 planePos=startPos-StairsHeight;\n\n\n  float TorRadius=25.;\n  float TorDistance=50.;\n  vec3 lowerCenter=changeLength(normal,15.);\n  vec3 rotAstre=changeLength(RotateAxis(normal,normal2,iTime*3.0),TorRadius);\n  vec3 TorOnePos=startPos+changeLength(normal2,TorDistance)-lowerCenter;\n  vec3 TorTwoPos=startPos-changeLength(normal2,TorDistance)-lowerCenter;\n  vec3 starPos=TorOnePos+rotAstre;\n  vec3 moonPos=TorTwoPos-rotAstre;\n  float ConeSize=4.;\n  float ConeRadius=1.;\n\n  vec3 coneStartAdd=changeLength(normal2,mod(10.*time,TorDistance));\n  vec3 coneDirAdd=changeLength(normal2,ConeSize);\n\n  vec3 startCone1=TorOnePos-coneStartAdd+lowerCenter*1.5;\n  vec3 endCone1=startCone1-coneDirAdd;\n  vec3 startCone2=TorTwoPos+coneStartAdd+lowerCenter*1.5;\n  vec3 endCone2=startCone2+coneDirAdd;\n  float cone1=Cone(p,startCone1,endCone1,ConeRadius);\n  float cone2=Cone(p,startCone2,endCone2,ConeRadius);\n  float AllCones=SmoothUnion(cone2,cone1);\n  float etoile=Star(p,starPos,normal2,8.,1.5,30.*time);\n  float moon=Sphere(p,moonPos,4.);\n  float Astres=Union(etoile,moon);\n  float plane=signedPlane(p,planePos,normal);\n  float rotate=0.;\n  float fpyr=FlatPyramid(p,startPos,vec3(0,0,1),rotate,nbStairsPyr,pyrStairSize,topPyrSize);\n  float temple=Temple(p,startPos,normal,rotate,topPyrSize/1.5,topPyrSize/2.);\n  float tor1=Torus(p,TorOnePos,normal2,TorRadius,0.8);\n  float tor2=Torus(p,TorTwoPos,normal2,TorRadius,0.8);\n  float allTorus=Union(tor1,tor2);\n  vec3 statDir=getNormal(getNormal(normal),normal);\n  float stat=Statue(p,startPos+changeLength(statDir,topPyrSize/2.5)+changeLength(normal,topPyrSize/7.5),normal,topPyrSize/70.,0.);\n  return Union(stat,SmoothUnion(AllCones,(SmoothUnion(Astres,SmoothUnion(allTorus,Union(fpyr,temple))))));\n}\n\n\n\n\n\n\n\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  vec3 empty=vec3(0,0,0);\n  vec3 ex1=vec3(0,1,3);\n  vec3 ex2=vec3(5,0,0);\n  vec3 ex3=vec3(0,5,0);\n  float result;\n\n  // float verifyOrth=Orthogonal(p);\n  // float splane=signedPlane(p,vec3(0,0,-1),vec3(0,1,1));\n  // float plane=Plane(p,vec3(0,0,0),vec3(1,0,1));\n  // float ball=Ball(p,vec3(0,0,0),5.);\n  // float circle=Circle(p,vec3(0,0,0),vec3(2,1,1),2.);\n  // float sphere=Sphere(p,vec3(5,0,0),2.);\n  // float cylinder=Cylinder(p,vec3(0,0,0),vec3(4,2,5),5.);\n  // float disc=Disc(p,vec3(0,0,0),vec3(0,1,1),3.);\n  // float droite=Droite(p,vec3(0,0,0),vec3(1,1,1));\n  // float tor=Torus(p,vec3(0,0,1),vec3(1,0,0.3),4.,2.);\n  // float snow=Snowman(p,vec3(0,0,0),2.);\n  // float capsule=Capsule(p,ex1,ex2,2.);\n  // float capscircle=CapsuleCircle(p,vec3(0,0,5),vec3(0,0,10),0.5,30,15);\n  // float hedgeHog=HedgeHog(p,vec3(0,0,0),vec3(1,5,6),0.2,4,10,0);\n  // float testDot=TriangleCapsule(p,vec3(0,0,0),vec3(-6,0,5),vec3(0,2,2),0.5);\n  // float cheese=Cheese(p,vec3(0,1,0),vec3(5,1,1),3.,1.);\n  // float triangle=Triangle(p,ex1,ex2,ex3);\n  // float rtri=RoundTriangle(p,ex1,ex2,ex3,2.);\n  // float rect=Rectangle(p,vec3(0,0,0),vec3(5,0,0),vec3(5,5,5),vec3(0,5,0),5.);\n  // float roundRect=RoundRectangle(p,ex1,ex2,ex3,getNormal(ex1-ex2,vec3(-2,-3,0)),4.,1.);\n  // float tobl=Toblerone(p,vec3(1,0,5),vec3(0,0,5),vec3(2,6,0),vec3(1,1,1),1.);\n  // float box=Box(p,vec3(0,0,0),vec3(-5,0,0),vec3(-5,5,3),vec3(1,2,1),3.);\n  // float tetr=Tetraedre(p,vec3(0,10,0),vec3(0,0,-5),vec3(-1,0,6),vec3(-3,4,1));\n  // float pyr=Pyramid(p,empty,vec3(-5,0,-2),getNormal(vec3(-5,0,-2),vec3(-1,-1,-1)),3.);\n  // float cone=Cone(p,vec3(0,-10,0),vec3(0,10,0),5.);\n  // float sqr=Square(p,vec3(0,0,0),vec3(5,5,0),getNormal(vec3(5,5,0),vec3(1,0,0)));\n  // float rsqr=RoundSquare(p,vec3(0,0,0),vec3(5,5,0),getNormal(vec3(5,5,0),vec3(1,0,1)),1.);\n  // float rparallelogram=RoundParallelogram(p,empty,vec3(0,5,0),vec3(5,5,0),1.);\n  // float column=Column(p,vec3(0,0,-8),vec3(1,0,8),3.,5);\n  // float columnLine=ColumnLine(p,vec3(0,0,-5),vec3(5,0,0),vec3(0,0,10),5,4.,1.,8);\n  // vec3 ab=vec3(5,0,0);\n  // vec3 cb=vec3(0,5,0);\n  // float star=Star(p,vec3(0,0,0),vec3(0,1,0),10.,0.5,0.);\n  // float stairs=Stairs(p,vec3(-5,0,0),vec3(5,0,0),-getNormal(ab,cb),vec3(0,5,0),10,0.5);\n  // float angleStairs=AngleStairs(p,vec3(0,0,0),ab,vec3(5,3,6),ab-cb,10,0.2);\n  // float pyrStairs=PyramidAngleStairs(p,vec3(0,0,0),vec3(0,0,1),0.,10,0.5);\n  // float pyrBox=PyramidBox(p,vec3(0,0,0),vec3(0,0,1),0.,20,0.4);\n  // float fpyr=FlatPyramid(p,vec3(0,0,7),vec3(0,0,1),0.,12,0.3,15.);\n  // float hel=Helmet(p,vec3(0,0,0),vec3(0,0,1),3.,0.);\n  // float stat=Statue(p,vec3(0,0,0),vec3(0,0,1),0.7,0.);\n  // float temple=Temple(p,vec3(0,0,0),vec3(0,-1,4),0.,15.,10.);\n  float beauty=Beauty(p);\n\n  result=beauty;\n  return result;\n}\n\n// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  float v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z))-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z))-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps))-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float e,out bool h,out int s)\n{\n  h=false;\n\n  // Start at the origin\n  float t=0.;\n\n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=object(p);\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),d.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  bool h;\n  int s;\n  float t=SphereTrace(p+Epsilon*n,l,100.,h,s);\n  if(!h)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p,vec3 n,vec3 e)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n\n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n\n  // Ambient color\n  vec3 ambient=.25+.25*background(n);\n\n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n\n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n\n  // Specular\n  vec3 r=reflect(e,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n\n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n\n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n\n  // Camera\n  vec3 ro,rd;\n  rd=vec3(100,0,0);\n  Ray(m,pixel,ro,rd);\n\n  // Trace ray\n\n  // Hit and number of steps\n  bool hit;\n  int s;\n\n  float t=SphereTrace(ro,rd,100.,hit,s);\n\n  // Shade background\n  vec3 rgb=background(rd);\n  if(hit)\n  {\n    // Position\n    vec3 p=ro+t*rd;\n\n    // Compute normal\n    vec3 n=ObjectNormal(p);\n\n    // Shade object with light\n    rgb=Shade(p,n,rd);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n\n  color=vec4(rgb,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}