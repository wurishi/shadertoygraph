{"ver":"0.1","info":{"id":"ctfczj","date":"1690927467","viewed":69,"name":"Mouse drag 2 (derived state)","username":"mrboggieman","description":"Demo of dragging around items with the mouse (state persisted in buffers). Replaced the imperative-based logic for mutation with derived logic (see Buffer A code)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["mouse","state","drag"],"hasliked":0,"parentid":"7tccWM","parentname":"Mouse drag (state)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//MIT Licence\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    \n    int indexOfCircleDragged = getInt(dragIndex);\n    \n    //draw circles\n    for (int i=0; i<circles.length(); i++) {\n        Circle circle = circles[i];\n\n        if (distance(uv, getVec2(circle.pos)) < getFloat(circle.radius)) {\n            vec3 col = getVec3(circle.colour);\n\n            //being dragged? highlight it\n            if (indexOfCircleDragged == i) {\n                col = vec3(0.0, 1.0, 0.0);\n            }\n            \n            fragColor = vec4(col, 1.0);\n            return;\n        }\n    }\n\n    fragColor = vec4(vec3(0.0), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"bool mouseIsDown() {\n    return iMouse.z > 0.0;\n}\n\nvec2 getMousePos() {\n    return iMouse.xy / iResolution.y;\n}\n\nvoid calcDragPosition(inout vec4 nextValue, in Item item) {\n    if (mouseIsDown()) {\n        nextValue = setVec2(getMousePos());\n    }\n}\n\nvoid calcDragIndex(inout vec4 nextValue, in Item item) {\n    if (mouseIsDown()) {\n        int prevDragIndex = getInt(dragIndex);\n        \n        //not already dragging an item\n        if (prevDragIndex == -1) {\n            vec2 mousePos = getMousePos();\n\n            for (int i=0; i<circles.length(); i++) {\n                Circle circle = circles[i];\n                \n                //go through the circles in order, could have a z-index here instead\n                if (distance(mousePos, getVec2(circle.pos)) < getFloat(circle.radius)) {\n                    nextValue = setInt(i);\n                    return;\n                }\n            }\n        }\n    } else {\n        nextValue = setInt(-1);\n    }\n}\n\nvoid calcCirclePos(inout vec4 nextValue, in Item item, in int index) {\n    if (mouseIsDown()) {\n        int draggedIndex = getInt(dragIndex);\n        \n        //this is the circle we are dragging\n        if (draggedIndex == index) {\n            vec2 prevDragPos = getVec2(dragPosition);\n            vec2 prevCirclePos = getVec2(item);\n            vec2 mousePos = getMousePos();\n\n            nextValue = setVec2(prevCirclePos + mousePos - prevDragPos);\n        }\n    }\n}\n\nvoid calcCircleRadius(inout vec4 nextValue, in Item item, in int index) {\n    //no dynamic changes\n}\n\nvoid calcCircleColour(inout vec4 nextValue, in Item item, in int index) {\n    //no dynamic changes\n}\n\n#define init_or(item, func) if (index == item.index) { if (iFrame == 0) { fragColor = item.value; } else { func; }}\n#define store(item, func) init_or(item, func(fragColor, item))\n#define store_indexed(item, func, i) init_or(item, func(fragColor, item, i))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = toIndex(fragCoord);\n    \n    //default to the previous frame\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    \n    //store each value (only calculates/stores if the index matches)\n    for (int i=0; i<circles.length(); i++) {\n        Circle circle = circles[i];\n\n        store_indexed(circle.pos, calcCirclePos, i);\n        store_indexed(circle.radius, calcCircleRadius, i);\n        store_indexed(circle.colour, calcCircleColour, i);\n    }\n\n    store(dragIndex, calcDragIndex);\n    store(dragPosition, calcDragPosition);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//must be macros to be used in constants\n#define setFloat(value) vec4(value, 0.0, 0.0, 0.0)\n#define setVec2(value) vec4(value, 0.0, 0.0)\n#define setVec3(value) vec4(value, 0.0)\n#define setVec4(value) value\n#define setBool(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setBvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setBvec3(value) vec4(vec3(value), 0.0)\n#define setBvec4(value) vec4(value)\n#define setUint(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setUvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setUvec3(value) vec4(vec3(value), 0.0)\n#define setUvec4(value) vec4(value)\n#define setInt(value) vec4(float(value), 0.0, 0.0, 0.0)\n#define setIvec2(value) vec4(vec2(value), 0.0, 0.0)\n#define setIvec3(value) vec4(vec3(value), 0.0)\n#define setIvec4(value) vec4(value)\n\n//used across persistance and rendering\n#define fromIndex(index) ivec2(index % int(iResolution.x), floor(float(index) / iResolution.x))\n#define toIndex(uv) int(floor(uv.x) + floor(uv.y) * iResolution.x)\n#define get(item) texelFetch(iChannel0, fromIndex(item.index), 0).rgba\n#define getBool(item) bool(get(item).r)\n#define getBvec2(item) bvec2(get(item).rg)\n#define getBvec3(item) bvec3(get(item).rgb)\n#define getBvec4(item) bvec4(get(item).rgba)\n#define getUint(item) uint(get(item).r)\n#define getUvec2(item) uvec2(get(item).rg)\n#define getUvec3(item) uvec3(get(item).rgb)\n#define getUvec4(item) uvec4(get(item).rgba)\n#define getInt(item) int(get(item).r)\n#define getIvec2(item) ivec2(get(item).rg)\n#define getIvec3(item) ivec3(get(item).rgb)\n#define getIvec4(item) ivec4(get(item).rgba)\n#define getFloat(item) get(item).r\n#define getVec2(item) get(item).rg\n#define getVec3(item) get(item).rgb\n#define getVec4(item) get(item).rgba\n\n//just a wrapper around a value we want to persist and the index where it should be saved\nstruct Item {\n    vec4 value;\n    int index;\n};\n\n//demo\n#define circle(pos, radius, colour, index) Circle(Item(setVec2(pos), index), Item(setFloat(radius), index + 1), Item(setVec3(colour), index + 2))\n\nstruct Circle {\n    Item pos;\n    Item radius;\n    Item colour;\n};\n\nconst Circle[] circles = Circle[](\n    circle(vec2(0.4, 0.4), 0.1, vec3(1.0, 0.0, 0.0), 0), //need to manually code the indexes :(\n    circle(vec2(0.8, 0.6), 0.2, vec3(0.0, 0.0, 1.0), 3),\n    circle(vec2(0.5, 0.1), 0.3, vec3(1.0, 0.0, 1.0), 6)\n);\n\nconst Item dragPosition = Item(setVec2(vec2(0.0)), 9);\n\nconst Item dragIndex = Item(setInt(-1), 10);\n","name":"Common","description":"","type":"common"}]}