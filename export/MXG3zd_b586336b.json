{"ver":"0.1","info":{"id":"MXG3zd","date":"1718688191","viewed":65,"name":"DaVinci Style Color Grading","username":"Mynx","description":"Color grading using DaVinci's Wide Gamut Intermediate, following similar order of operations inside a DaVinci Resolve node. Final output is mapped with an approximation of DaVinci's DRT.\n\nFeel free to toy with different working color spaces and DRTs.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["bezier","color","curves","contrast","grading","film","mixer","levels","tonemap","srgb","clip","log","gamut","resolve","rec709","davinci","drt","709","cdl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Final output, takes in DaVinci Wide Gamut Intermediate source,\n// linearizes it, and applies DaVinci DRT\n\n// Buffer A: Image output in DaVinci Wide Gamut Intermediate\n// Buffer B: Spatial filters (higlight and shadow boost, sharpen/midtone detail)\n// Buffer D: Color grading process\n// Image:    Display Rendering Transform output\n\n// DaVinci Wide Gamut Intermediate:\n// https://documents.blackmagicdesign.com/InformationNotes/DaVinci_Resolve_17_Wide_Gamut_Intermediate.pdf\n\n#define INPUT_NITS  10000.0f // the maximum input brightness, in nits\n#define OUTPUT_NITS   100.0f // the maximim output brighntess, in nits\n#define ADAPTATION      9.0f // DaVinci's \"adaptation\" value, I believe this is in nits as well?\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // input in davinci wide gamut intermediate\n    vec3 col = texture(iChannel0, uv).rgb;\n         \n    // to linear\n    col.r = davinci_to_lin(col.r);\n    col.g = davinci_to_lin(col.g);\n    col.b = davinci_to_lin(col.b);\n \n\t// apply drt\n    col = davinci_drt(col, false);\n    \n    // back to rec709\n    col = col * davinci_2_rec709;\n \n    // sRGB output\n    col = rgb2srgb(col);\n \n\tfragColor = vec4(col,1);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// DaVinci Wide Gamut Intermediate:\n// https://documents.blackmagicdesign.com/InformationNotes/DaVinci_Resolve_17_Wide_Gamut_Intermediate.pdf\n\n// DRT Settings\n#define INPUT_NITS  10000.0f // the maximum input brightness, in nits\n#define OUTPUT_NITS   100.0f // the maximim output brighntess, in nits\n#define ADAPTATION      9.0f // DaVinci's \"adaptation\" value, I believe this is in nits as well?\n\n// DaVinci DRT\nvec3 davinci_drt(vec3 col, bool invert)\n{\n    // davinci drt seems to be a simple naka-rushton operation with white point remapping\n   \tconst float adaptation = ADAPTATION / 100.0f;\n\tconst float in_white = INPUT_NITS / 100.0f;\n\tconst float in_adaptation = adaptation;\n\tconst float out_adaptation = adaptation;\n    const float out_white = OUTPUT_NITS / 100.0f;      \n    \n    const float a = out_white * out_adaptation * (in_adaptation - in_white) / (out_white * in_adaptation - in_white * out_adaptation);\n    const float b = in_adaptation * (a - out_adaptation) / out_adaptation;\n    \n    if(in_white == out_white)\n        return col;\n    \n    if(invert)\n        return b * col / (a - col);\n        \n    // clamp to input\n\tcol = min(col, in_white);\n    \t\n\t// apply drt\n    col = a * col / (col + b);\n\t\n\t// clamp to output range\n\tcol = clamp(col, vec3(0.0f), vec3(out_white));\n    \n\treturn col;\n}\n\n\n// DaVinci Wide Gamut\nconst mat3 xyz_2_davinci = mat3\n(\n    1.51667204, -0.28147805, -0.14696363,\n    -0.4649171,  1.25142378,  0.17488461,\n    0.06484905,  0.10913934,  0.76141462\n);\n\nconst mat3 davinci_2_xyz = mat3\n(\n     0.70062239,  0.14877482,  0.10105872,\n     0.27411851,  0.8736319,  -0.14775041,\n    -0.09896291, -0.13789533,  1.32591599\n);\n\n// Rec.709\nconst mat3 xyz_2_rec709 = mat3\n(\n     3.2409699419, -1.5373831776, -0.4986107603,\n    -0.9692436363,  1.8759675015,  0.0415550574,\n     0.0556300797, -0.2039769589,  1.0569715142\n);\n\nconst mat3 rec709_2_xyz = mat3\n(\n    0.4124564, 0.3575761, 0.1804375,\n    0.2126729, 0.7151522, 0.0721750,\n    0.0193339, 0.1191920, 0.9503041\n);\n\n// LMS\nconst mat3 xyz_2_lms = mat3\n(\n\t 0.4002,  0.7076, -0.0808,\n\t-0.2263,  1.1653,  0.0457,\n\t 0,       0,       0.9182\n);\n\nconst mat3 lms_2_xyz = mat3\n(\n\t 1.8601, -1.1295,  0.2199,\n\t 0.3612,  0.6388, -0.0000,\n\t 0.0000,  0.0000,  1.0891\n);\n\nconst vec3 davinci_lum = vec3(0.27411851,  0.8736319,  -0.14775041);\n\n// Rec.709 <-> DaVinci Wide Gamut\nconst mat3 rec709_2_davinci = xyz_2_davinci * rec709_2_xyz;\nconst mat3 davinci_2_rec709 = xyz_2_rec709 * davinci_2_xyz;\n\n// DaVinci Wide Gamut <-> LMS\nconst mat3 davinci_2_lms = xyz_2_lms * davinci_2_xyz;\nconst mat3 lms_2_davinci = xyz_2_davinci * lms_2_xyz;\n\n// DaVinci Intermediate\nfloat lin_to_davinci(float aL)\n{\n\tfloat v;\n    if (aL > 0.00262409f)\n        v = (log2(aL + 0.0075f) + 7.0f) * 0.07329248f;\n    else\n        v = aL * 10.44426855f;\n    return v;\n}\n\nfloat davinci_to_lin(float aV)\n{\n\tfloat l;\n\tif(aV > 0.02740668f)\n\t\tl = exp2((aV / 0.07329248f) - 7.0f) - 0.0075f;\n\telse\n\t\tl = aV / 10.44426855f;\n\treturn l;\n}\n\n//RGB to sRGB (standard Red Green Blue).\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\nconst float SRGB_ALPHA=.055;\nfloat linear2srgb(float x){\n\tif(x<=.0031308)\n\t\treturn 12.92*x;\n\telse\n\t\treturn(1.+SRGB_ALPHA)*pow(x,1./2.4)-SRGB_ALPHA;\n}\nvec3 rgb2srgb(vec3 c)\n{\n\treturn vec3(\n\t\tlinear2srgb(c.r),\n\t\tlinear2srgb(c.g),\n\t\tlinear2srgb(c.b)\n\t);\n}\n//sRGB to RGB.\nfloat srgb2linear(float x)\n{\n\tif(x<=.04045)\n\t\treturn x/12.92;\n\telse\n\t\treturn pow((x+SRGB_ALPHA)/(1.+SRGB_ALPHA),2.4);\n}\nvec3 srgb2rgb(vec3 c)\n{\n\treturn vec3(\n\t\tsrgb2linear(c.r),\n\t\tsrgb2linear(c.g),\n\t\tsrgb2linear(c.b)\n\t);\n}\n\n// YCbCr\nvec3 rgb_to_2ycbcr(vec3 c)\n{\n\tfloat y = 0.299 * c.r + 0.587 * c.g + 0.114 * c.b;\n    float cb = (c.b - y) * 0.565;\n    float cr = (c.r - y) * 0.713;\n\treturn vec3(y, cb, cr);\n}\n\nvec3 ycbcr_to_rgb(vec3 yuv)\n{\n\treturn vec3(\n\t\tyuv.x + 1.403 * yuv.z,\n\t\tyuv.x - 0.344 * yuv.y - 0.714 * yuv.z,\n\t\tyuv.x + 1.770 * yuv.y\n\t);\n}\n\n// HSV\n// https://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// adapted from\n// https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/White-Balance-Node.html\n// temperature: -4000, 4000\n// tint: -100, 100\nvec3 white_balance(vec3 rgb, float temperature, float tint)\n{\n    float t1 = temperature / 1200.0f;\n    float t2 = tint / 180.0f;\n\n    // Get the CIE xy chromaticity of the reference white point.\n    // Note: 0.31271 = x value on the D65 white point\n    float x = 0.31271f - t1 * (t1 < 0.0f ? 0.1f : 0.05f);\n    float standardIlluminantY = 2.87f * x - 3.0f * x * x - 0.27509507f;\n    float y = standardIlluminantY + t2 * 0.05;\n\n    // Calculate the coefficients in the LMS space.\n    vec3 w1 = vec3(0.949237, 1.03542, 1.08728); // D65 white point\n\n    // CIExyToLMS\n    float Y = 1.0f;\n    float X = Y * x / y;\n    float Z = Y * (1.0f - x - y) / y;\n    float L = 0.7328f * X + 0.4296f * Y - 0.1624f * Z;\n    float M = -0.7036f * X + 1.6975f * Y + 0.0061f * Z;\n    float S = 0.0030f * X + 0.0136f * Y + 0.9834f * Z;\n    vec3 w2 = vec3(L, M, S);\n\n    vec3 balance = w1 / w2;\n\n    // apply\n    vec3 lms = rgb * davinci_2_lms;\n    lms *= balance;\n    return lms * lms_2_davinci;\n}\n\n// much thanks to Cary Knoop\n// https://forum.blackmagicdesign.com/viewtopic.php?f=21&t=122108\nfloat rolloff(float x, float cutoff, float soft)\n{\n    float low  = cutoff - soft;\n\tfloat high = cutoff + soft;\n\t\n\tif(x <= low)\n\t\treturn x;\n        \n\tif(x >= high)\n\t\treturn cutoff;\n\t\n\treturn -1.0f / (4.0f * soft) * (x * x - 2.0f * high * x + low * low);\n}\n\n// https://medium.com/@ericdjohnson/shaping-functions-for-shaders-ffbad63069c7\nfloat slopeFromT (float t, float A, float B, float C)\n{\n    float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); \n    return dtdx;\n}\n\nfloat xFromT (float t, float A, float B, float C, float D)\n{\n    float x = A*(t*t*t) + B*(t*t) + C*t + D;\n    return x;\n}\n\nfloat yFromT (float t, float E, float F, float G, float H)\n{\n    float y = E*(t*t*t) + F*(t*t) + G*t + H;\n    return y;\n}\n\nfloat cubicBezier (float x, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n\n    float y0a = p0.y; // initial y\n    float x0a = p0.x; // initial x \n    float y1a = p1.y; // 1st influence y   \n    float x1a = p1.x; // 1st influence x \n    float y2a = p2.y; // 2nd influence y\n    float x2a = p2.x; // 2nd influence x\n    float y3a = p3.y; // final y \n    float x3a = p3.x; // final x \n\n    float A =   x3a - 3.0*x2a + 3.0*x1a - x0a;\n    float B = 3.0*x2a - 6.0*x1a + 3.0*x0a;\n    float C = 3.0*x1a - 3.0*x0a;   \n    float D =   x0a;\n\n    float E =   y3a - 3.0*y2a + 3.0*y1a - y0a;    \n    float F = 3.0*y2a - 6.0*y1a + 3.0*y0a;             \n    float G = 3.0*y1a - 3.0*y0a;             \n    float H =   y0a;\n\n    // Solve for t given x (using Newton-Raphson), then solve for y given t.\n    // Assume for the first guess that t = x.\n    float currentt = x;\n    int nRefinementIterations = 5;\n    for (int i=0; i < nRefinementIterations; i++)\n    {\n        float currentx = xFromT (currentt, A,B,C,D); \n        float currentslope = slopeFromT (currentt, A,B,C);\n        currentt -= (currentx - x)*(currentslope);\n        currentt = clamp(currentt, 0.0,1.0);\n    } \n\n    float y = yFromT (currentt,  E,F,G,H);\n    return y;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Outputs the image in DaVinci Wide Gamut Intermediate HDR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // linearize the input\n    vec3 col = texture(iChannel0, uv).rgb;\n    col = srgb2rgb(col);\n        \n    // to davinci wide gamut\n    col = col * rec709_2_davinci;\n    \n    // use an inverse davinci drt to map to hdr\n    // resolve actually has an option for this :)\n    col = davinci_drt(col, true);\n    \n    // to davinci intermediate\n    col.r = lin_to_davinci(col.r);\n    col.g = lin_to_davinci(col.g);\n    col.b = lin_to_davinci(col.b);\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Color grading pass, this stage can be baked to a LUT (use an appropriate mapping, maybe ST2048/PQ or a log space)\n// Input and Output are both in DaVinci Wide Gamut Intermediate\n\n// Order of operations similar to Resolve:\n// https://uploads.tapatalk-cdn.com/files-3867/1697543858_DaVinci_Resolve_image_processing_order.pdf\n\n//****************************************************************************\n// Controls\n// These are set to the \"defaults\" with no effect\n// I encourage you play around with the values\n// or fork and add some fun UI stuff on top\n//****************************************************************************\n\n// note: not all operations are exactly HDR friendly but are here for fun\n\n// how much the luminance math (Y) affects the result\n// pretty much a \"preserve luminance\" control\n#define LUM_MIX         100.0f // range: 0, 100\n\n// boost colors, more or less a vibrance effect\n#define COLOR_BOOST     0.0f // range: 0, 100\n\n// s-curve contrast (done in log space so the actual math is linear)\n#define CONTRAST        1.0f   // range: 0, 2\n#define CONTRAST_PIVOT  0.435f // range: 0, 1\n\n// hue and saturation\n#define HUE_SHIFT       50.0 // range: 0, 100\n#define SATURATION      50.0 // range: 0, 100\n\n// white balance\n#define TEMPERATURE     0.0f // range: -4000, 4000\n#define TINT            0.0f // range:  -100,  100\n\n// YRGB primaries (lift/gamma/gain/offset)\n#define LIFT            vec4(0.0,   0.0,  0.0,  0.0) // range:   -1,   1\n#define GAMMA           vec4(0.0,   0.0,  0.0,  0.0) // range:   -1,   1\n#define GAIN            vec4(1.0,   1.0,  1.0,  1.0) // range:    0,  16\n#define OFFSET          vec4(25.0, 25.0, 25.0, 25.0) // range: -175, 225\n\n// RGB log/film (shadows/midtones/highlights)\n#define SHADOW_RANGE    0.33f                  // range:  0, 1\n#define HIGHLIGHT_RANGE 0.55f                  // range:  0, 1\n#define SHADOWS         vec3(0.0f, 0.0f, 0.0f) // range: -8, 1\n#define MIDTONES        vec3(0.0f, 0.0f, 0.0f) // range: -1, 1\n#define HIGHLIGHTS      vec3(0.0f, 0.0f, 0.0f) // range: -1, 8\n\n// input levels, remaps input range and gamma akin to photoshop levels (applied at the beginning)\n#define INPUT_MIN       0.0f    // range: 0, 1023\n#define INPUT_MAX       1023.0f // range: 0, 1023\n#define INPUT_GAMMA     1.0     // range: 0,    8\n\n// output levels, remaps output range akin to photoshop levels (applied at the end)\n#define OUTPUT_MIN      0.0f    // range: 0, 1023\n#define OUTPUT_MAX      1023.0f // range, 0, 1023\n\n// channel mixer\n#define RED_MIX         vec3(1023.0, 0.0, 0.0) // range: 0, 1023\n#define GREEN_MIX       vec3(0.0, 1023.0, 0.0) // range: 0, 1023\n#define BLUE_MIX        vec3(0.0, 0.0, 1023.0) // range: 0, 1023\n\n// soft clipping, adds rolloff to shadow and highlight regions to prevent clipping\n#define HIGH            1.0f // range:  0.6, 1.3\n#define HIGH_SOFT       0.0f // range:    0,   1\n#define LOW             0.0f // range: -0.3, 0.4\n#define LOW_SOFT        0.0f // range:    0,   1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // input in davinci wide gamut intermediate\n    vec3 col = texture(iChannel0, uv).rgb;\n        \n    // input levels\n    col = pow(max((col - (INPUT_MIN / 1023.0)) / ((INPUT_MAX - INPUT_MIN) / 1023.0), vec3(0.0f)), vec3(INPUT_GAMMA));\n    \n    // color boost\n    {\n        float lum = dot(col, davinci_lum);\n        float mask = 1.0f - dot(col - vec3(lum), davinci_lum);\n        col = mix(vec3(lum), col, 1.0f + (COLOR_BOOST / 100.0) * mask);\n    }\n    \n    // white balance\n    col = white_balance(col, TEMPERATURE, TINT);\n    \n    // primares a.k.a lift/gamma/gain\n    // there's a few ways to match resolve but this version comes from\n    // thatchers wonderful dctl utils:\n    // https://github.com/thatcherfreeman/utility-dctls/tree/main\n    {\n        // davinci-style yrgb\n        float y = rgb_to_2ycbcr(col).x;\n        vec4 yrgb = vec4(y, col);\n\n        vec4 white_point = 1.0f / GAIN;\n        vec4 black_point = 1.0f - (1.0f / (1.0f - LIFT));\n        vec4 slope = 1.0f / (white_point - black_point);\n        vec4 offset = (OFFSET - 25.0) * 0.00733137392; // magic scale value to match Resolve\n        vec4 power = 1.0f + 4.0f * abs( GAMMA );\n        power = mix(power, 1.0f / power, step(0.0f, power));\n        yrgb -= black_point;\n        yrgb = yrgb * slope + offset;\n        yrgb = sign(yrgb) * pow(abs(yrgb), power); // negative-safe power\n        \n        // yrgb to rgb with lum mix\n        vec3 ycbcr = rgb_to_2ycbcr(yrgb.yzw);\n        ycbcr.x = mix(ycbcr.x, yrgb.x, LUM_MIX * 0.01f);\n        col = ycbcr_to_rgb(ycbcr);\n   }\n\n    \n    // contrast\n    col = CONTRAST_PIVOT + (col - CONTRAST_PIVOT) * CONTRAST;\n    \n    // todo: anyone want to add some kind of curves here?\n\n    // film/log grade, using bezier curves to approximate Resolve's behavior\n    // note: you're probably going to want to optimize this a bit if you use it\n    {\n        float hi = HIGHLIGHT_RANGE;\n        float lo = SHADOW_RANGE;\n        vec3 shadows    = SHADOWS;\n        vec3 midtones   = MIDTONES;\n        vec3 highlights = HIGHLIGHTS;\n        for(int i = 0; i < 3; ++i)\n        {   \n            float ss = shadows[i];\n            float ms = midtones[i];\n            float hs = highlights[i];\n\n            float y = col[i];\n\n            // shadow curve\n            vec2 s0 = vec2(0.0, min(lo * 0.8, ss)) - max(-ss + 1.0, 0.0);\n            vec2 s1 = vec2(lo * 0.8);\n            vec2 s2 = vec2(lo * 0.9);\n            vec2 s3 = vec2(lo);\n            float s = cubicBezier(y, s0, s1, s2, s3);\n\n            // highlight curve\n            vec2 h0 = vec2(hi);\n            vec2 h1 = vec2(hi * 1.1);\n            vec2 h2 = vec2(hi * 1.2);\n            vec2 h3 = vec2(1.0, max(hi * 1.2, 1.0f + hs)) + min(1.0, hs + 1.0);\n            float h = cubicBezier(y, h0, h1, h2, h3);\n\n            // midtone curve\n            vec2 m0 = vec2(lo);\n            vec2 m1 = vec2(mix(lo * 1.05, hi * 0.95, -ms * 0.5 + 0.5), mix(lo, hi * 0.95, ms * 0.5 + 0.5));\n            vec2 m2 = vec2(mix(lo * 1.05, hi * 0.95, -ms * 0.5 + 0.5), mix(lo, hi * 0.95, ms * 0.5 + 0.5));\n            vec2 m3 = vec2(hi);\n            float m = cubicBezier(y, m0, m1, m2, m3);\n\n            y = y < lo ? s : y;\n            y = y > hi ? h : y;    \n            y = y > lo && y < hi ? m : y;\n            \n            col[i] = y;\n        }\n    }\n    \n    // hue/saturation\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += HUE_SHIFT / 100.0f - 0.5f;\n    hsv.x = hsv.x < 0.0f // rotate hue if out of range\n        ? hsv.x + 1.0f\n        : (hsv.x > 1.0f)\n            ? hsv.x - 1.0f\n            : hsv.x;\n    hsv.y *= SATURATION / 100.0f * 2.0f;\n    col = hsv2rgb(hsv);\n    \n    // channel mixer\n    col = vec3(dot(col, RED_MIX / 1023.0), dot(col, GREEN_MIX / 1023.0), dot(col, BLUE_MIX / 1023.0));\n    \n    // soft clip highlights\n\tcol.r = rolloff(col.r, HIGH, HIGH_SOFT);\n\tcol.g = rolloff(col.g, HIGH, HIGH_SOFT);\n\tcol.b = rolloff(col.b, HIGH, HIGH_SOFT);\n\t\n\t// soft clip shadows\n\tcol.r = 1.0 - rolloff(1.0 - col.r, 1.0 - LOW, LOW_SOFT);\n\tcol.g = 1.0 - rolloff(1.0 - col.g, 1.0 - LOW, LOW_SOFT);\n\tcol.b = 1.0 - rolloff(1.0 - col.b, 1.0 - LOW, LOW_SOFT);\n\t \n    // output levels\n    col = col / ((OUTPUT_MAX - OUTPUT_MIN) / 1023.0f) + (OUTPUT_MIN / 1023.0f);\n   \n    // output in dwg intermediate\n    fragColor = vec4(col,1.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Spatial filters, input and output are in DaVinci Wide Gamut Intermediate\n\n// highlight and shadow boost\n#define SHADOW_BOOST    0.0f // range: -100, 100\n#define HIGHLIGHT_BOOST 0.0f // range: -100, 100\n\n// Sharpening (lazy stand-in for midtone detail)\n#define SHARPEN       1.0f\n#define SHARPEN_WIDTH 1.0f\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // input in davinci wide gamut intermediate\n    vec3 col = texture(iChannel0, uv).rgb;\n     \n    // highlight/shadow boost\n    // not quite sure how resolve does this but a fun challenge anyway\n    vec3 boost_col = texture(iChannel0, uv, 2.0f).rgb;\n    float lum = dot(boost_col, davinci_lum);\n    col += col * (HIGHLIGHT_BOOST / 100.0f) * (smoothstep(0.66f, 1.0f, lum));\n    col += col * (SHADOW_BOOST / 100.0f) * (1.0-smoothstep(0.0f, 0.33f, lum)); \n \n    // simple sharpen\n    vec3 blurred = textureLod(iChannel0, uv, SHARPEN_WIDTH).rgb;\n    blurred += blurred * (HIGHLIGHT_BOOST / 100.0f) * (smoothstep(0.66f, 1.0f, lum));\n    blurred += blurred * (SHADOW_BOOST / 100.0f) * (1.0-smoothstep(0.0f, 0.33f, lum)); \n    col += (col - blurred) * SHARPEN;\n    \n\tfragColor = vec4(col,1);    \n}","name":"Buffer B","description":"","type":"buffer"}]}