{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\nported from https://git.sr.ht/~noneofyourbusiness/vulkan_shadertoy_shaders @ 84554f0718a3033c5b4155ceab8f78bc23c379f0 for shadertoy.com\n\nCopyright (c) 2024 noneofyourbusiness <noneofyourbusiness@danwin1210.de>\n\nPermission to use, copy, modify, and distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\nconst float pi = 3.14159265358979323846;\nvec2\ncpx_exp(float exponent)\n/* exp() for complex numbers */\n{\n\tvec2 result;\n\n\t/* exp(i * x) = cos(x) + i * sin(x) */\n\tresult.x = cos(exponent);\n\tresult.y = sin(exponent);\n\n\treturn result;\n}\n\n/* adjusted to glsl */\nfloat\npm_polynomial_value (int n, int m, float x)\n/******************************************************************************/\n/*\n  Purpose:\n\n    PM_POLYNOMIAL_VALUE evaluates the Legendre polynomials Pm(n,m,x).\n\n  Differential equation:\n\n    (1-X*X) * Y'' - 2 * X * Y + ( N (N+1) - (M*M/(1-X*X)) * Y = 0\n\n  First terms:\n\n    M = 0  ( = Legendre polynomials of first kind P(N,X) )\n\n    Pm(0,0,x) =    1\n    Pm(1,0,x) =    1 X\n    Pm(2,0,x) = (  3 X^2 -   1)/2\n    Pm(3,0,x) = (  5 X^3 -   3 X)/2\n    Pm(4,0,x) = ( 35 X^4 -  30 X^2 +   3)/8\n    Pm(5,0,x) = ( 63 X^5 -  70 X^3 +  15 X)/8\n    Pm(6,0,x) = (231 X^6 - 315 X^4 + 105 X^2 -  5)/16\n    Pm(7,0,x) = (429 X^7 - 693 X^5 + 315 X^3 - 35 X)/16\n\n    M = 1\n\n    Pm(0,1,x) =   0\n    Pm(1,1,x) =   1 * SQRT(1-X^2)\n    Pm(2,1,x) =   3 * SQRT(1-X^2) * X\n    Pm(3,1,x) = 1.5 * SQRT(1-X^2) * (5*X^2-1)\n    Pm(4,1,x) = 2.5 * SQRT(1-X^2) * (7*X^3-3*X)\n\n    M = 2\n\n    Pm(0,2,x) =   0\n    Pm(1,2,x) =   0\n    Pm(2,2,x) =   3 * (1-X^2)\n    Pm(3,2,x) =  15 * (1-X^2) * X\n    Pm(4,2,x) = 7.5 * (1-X^2) * (7*X^2-1)\n\n    M = 3\n\n    Pm(0,3,x) =   0\n    Pm(1,3,x) =   0\n    Pm(2,3,x) =   0\n    Pm(3,3,x) =  15 * (1-X^2)^1.5\n    Pm(4,3,x) = 105 * (1-X^2)^1.5 * X\n\n    M = 4\n\n    Pm(0,4,x) =   0\n    Pm(1,4,x) =   0\n    Pm(2,4,x) =   0\n    Pm(3,4,x) =   0\n    Pm(4,4,x) = 105 * (1-X^2)^2\n\n  Recursion:\n\n    if N < M:\n      Pm(N,M,x) = 0\n    if N = M:\n      Pm(N,M,x) = (2*M-1)!! * (1-X*X)^(M/2) where N!! means the product of\n      all the odd integers less than or equal to N.\n    if N = M+1:\n      Pm(N,M,x) = X*(2*M+1)*Pm(M,M,x)\n    if M+1 < N:\n      Pm(N,M,x) = ( X*(2*N-1)*Pm(N-1,M,x) - (N+M-1)*Pm(N-2,M,x) )/(N-M)\n\n  Licensing:\n\n    This code is distributed under the GNU LGPL license.\n\n  Modified:\n\n    08 August 2013\n\n  Author:\n\n    John Burkardt\n\n  Reference:\n\n    Milton Abramowitz, Irene Stegun,\n    Handbook of Mathematical Functions,\n    National Bureau of Standards, 1964,\n    ISBN: 0-486-61272-4,\n    LC: QA47.A34.\n\n  Parameters:\n\n    Input, int MM, the number of evaluation points.\n\n    Input, int N, the maximum first index of the Legendre\n    function, which must be at least 0.\n\n    Input, int M, the second index of the Legendre function,\n    which must be at least 0, and no greater than N.\n\n    Input, double X[MM], the point at which the function is to be\n    evaluated.\n\n    Output, double PM_POLYNOMIAL_VALUE[MM*(N+1)], the function values.\n*/\n{\n  float fact;\n  int i;\n  int j;\n  int k;\n  float v = 0.0;\n  float v0 = 1.0;\n  float v1 = x;\n\n/*\n  J = M is the first nonzero function.\n*/\n  if ( m <= n )\n  {\n    v = 1.0;\n    fact = 1.0;\n    for ( k = 0; k < m; k++ )\n    {\n      v = - v * fact * sqrt(1.0 - x * x);\n      fact = fact + 2.0;\n    }\n  }\n/*\n  J = M + 1 is the second nonzero function.\n*/\n  if ( m + 1 <= n )\n  {\n    v = x * (2.0 * float(m) + 1.0) * v;\n  }\n/*\n  Now we use a three term recurrence.\n*/\n  for ( j = m + 2; j <= n; j++ )\n  {\n      v = ((2.0 * float(j) - 1.0 ) * x * v1\n                  + (- float(j) - float(m) + 1.0 ) * v0 )\n                  / float(  j - m     );\n      v0 = v1;\n      v1 = v;\n  }\n\n  return v;\n}\n/******************************************************************************/\nfloat associated_legendre_function(uint l, int m, float x);\nvec2 coordinate_transform(vec2 coordinates);\nuint factorial(uint n);\nfloat hydrogen(uint l, int m, uint n, vec3 polar_sph);\nfloat laguerre_polynomials(uint n, uint k, float x);\nvec2 spherical_harmonic(uint l, int m, vec2 angles);\n\nfloat\nassociated_legendre_function(uint l, int m, float x)\n/* https://people.math.sc.edu/Burkardt/c_src/legendre_polynomial/legendre_polynomial.html */\n{\n\treturn pm_polynomial_value(int(l), m, x);\n}\n\nuint\nfactorial(uint n)\n/* 0 <= n <= 12 */\n{\n/* OEIS: A000142 */\n    uint LUT[13] = uint[13](1U,\n    1U,\n    2U,\n    6U,\n    24U,\n    120U,\n    720U,\n    5040U,\n    40320U,\n    362880U,\n    3628800U,\n    39916800U,\n    479001600U\n    );\n\n\tif (n > 12U) {\n\t\treturn uint(0);\n\t} else  {\n\t\treturn LUT[n];\n\t}\n}\n\nfloat\nlaguerre_polynomials(uint n, uint k, float x)\n/* solve a given laguerre polynomial numerically */\n/* tested for correctness on n=2,k=3 using (x*x - 2*(k+2)*x + (k+1)*(k+2))/2 */\n{\n\tfloat lp0 = 1.0;\n\tfloat lp1 = 1.0 + float(k) - x;\n\n\tif (n < 2U) {\n\t\tif (n == 1U) return lp1;\n\t\tif (n == 0U) return lp0;\n\t}\n\n\tuint degree;\n\tfloat result;\n\t/* using the recursive definition */\n\tfor (degree = 2U; degree <= n; degree++) {\n\t\tresult =\n\t\t\t(\n\t\t\t\t(float(2U * (degree-1U) + 1U + k) - x) * lp1 - float(degree - 1U + k) * lp0\n\t\t\t) / float(degree);\n\t\tlp0 = lp1;\n\t\tlp1 = result;\n\t}\n\n\treturn result;\n}\n\nvec2\nspherical_harmonic(uint l, int m, vec2 angles)\n/* using eq. (6) for Y from https://mathworld.wolfram.com/SphericalHarmonic.html */\n{\n\t/* different naming convention: psi, theta switch */\n\tfloat psi = angles.x; /* azimuthal */\n\tfloat theta = angles.y; /* polar */\n\n\t/* p_lm is an associated Legendre polynomial */\n\tfloat p_lm = associated_legendre_function(l, m, cos(theta));\n\tfloat scalar = p_lm * sqrt(\n\t\t(float(2U * l + 1U))\n\t\t/ (float(4) * pi)\n\t\t* float(factorial(uint(int(l) - m)))\n\t\t/ float(factorial(uint(int(l) + m))));\n\t/* a complex number is a multivector */\n\tvec2 multivector = cpx_exp(float(m) * psi) * scalar;\n\n\treturn multivector;\n}\n\nfloat\nhydrogen(uint l, int m, uint n, vec3 polar_sph)\n/* solve the SchrÃ¶dinger equation for a hydrogen atom */\n/* $ \\psi _{n\\ell m}(r,\\theta ,\\varphi )={\\sqrt {\\left({\\frac {2}{na_{0}}}\\right)^{3}{\\frac {(n-\\ell -1)!}{2n[(n+\\ell )!]}}}}e^{-r/na_{0}}\\left({\\frac {2r}{na_{0}}}\\right)^{\\ell }L_{n-\\ell -1}^{2\\ell +1}\\left({\\frac {2r}{na_{0}}}\\right)\\cdot Y_{\\ell }^{m}(\\theta ,\\varphi ) $ */\n{\n\tfloat a_0 /* bohr radius */ = 1.0; /* =1 for the sake of reducing floating point error */\n\t/*\n\tquantum numbers\n\tl azimuthal\n\tm magnetic\n\tn principal\n\t*/\n\n\tfloat na_0 = float(n) * a_0;\n\tfloat r = polar_sph.x;\n\n\tvec2 result;\n\tfloat scalar;\n\t{/* {\\sqrt {\\left({\\frac {2}{na_{0}}}\\right)^{3}{\\frac {(n-\\ell -1)!}{2n[(n+\\ell )!]}}}} */\n\t\tfloat exp3 = pow(2.0 / na_0, 3.0);\n\t\tfloat fact_n = float(factorial(n - l - 1U));\n\t\tfloat fact_d = float(2U * n * factorial(n + l));\n\t\tfloat fract = fact_n / fact_d;\n\t\tscalar = sqrt(exp3 * fract);\n\t}\n\tscalar *= exp(-r / na_0);\n\tscalar *= pow(2.0*r / na_0, float(l));\n\tscalar *= laguerre_polynomials(n - l - 1U, 2U * l + 1U, 2.0 * r / na_0);\n\n\tresult = scalar * spherical_harmonic(l, m, polar_sph.yz);\n\n\treturn length(result);\n}\n\nvec2\ncoordinate_transform(vec2 coordinates)\n/* map to [-1, 1], (0, 0) is the center */\n{\n\t/* dividing by just y to have a square screen */\n\tvec2 transformed = (coordinates / iResolution.y);\n\t/* translate center to screen center */\n\t/* aspect/2 -> 1/2 */\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\ttransformed.x -= aspect_ratio / 2.0 - 0.5;\n\t/* [0,1] -> [-1,1] */\n\ttransformed = transformed * 2.0 - 1.0;\n\n\treturn transformed;\n}\n\nvec3\nsrgb2linear(vec3 srgb)\n/* https://www.color.org/chardata/rgb/srgb.xalter */\n{\n\tvec3 linear;\n\n\tlinear.x = pow(((srgb.x + 0.055) / 1.055), 2.4) / 12.92;\n\tlinear.y = pow(((srgb.y + 0.055) / 1.055), 2.4) / 12.92;\n\tlinear.z = pow(((srgb.z + 0.055) / 1.055), 2.4) / 12.92;\n\n\treturn linear;\n}\n\nvoid\nmainImage(out vec4 c, vec2 u)\n{\n\tvec3 xyz = vec3(0, coordinate_transform(u).yx);/* slice in yz plane */\n\n\tfloat theta = atan(xyz.x, xyz.y);/* azimuthal angle */\n\tfloat psi = atan(xyz.z, length(xyz.xy)); /* polar angle */\n\n\t/* switch between some orbitals */\n\t/* l, m, n */\n\tconst ivec3 orbitals[] = ivec3[](\n\t/* 1^2 */\n\tivec3(0, 0, 1),\n\t/* 2^2 */\n\tivec3(0, 0, 2),\n\tivec3(1, 0, 2),\n\tivec3(1, +1, 2),\n\tivec3(1, -1, 2),\n\t/* 3^2 */\n\tivec3(0, 0, 3),\n\tivec3(1, 0, 3),\n\tivec3(1, +1, 3),\n\tivec3(1, -1, 3),\n\tivec3(2, 0, 3),\n\tivec3(2, +1, 3),\n\tivec3(2, -1, 3),\n\tivec3(2, +2, 3),\n\tivec3(2, -2, 3),\n\t/* 4^2 */\n\tivec3(0, 0, 4),\n\tivec3(1, 0, 4),\n\tivec3(1, +1, 4),\n\tivec3(1, -1, 4),\n\tivec3(2, 0, 4),\n\tivec3(2, +1, 4),\n\tivec3(2, -1, 4),\n\tivec3(2, +2, 4),\n\tivec3(2, -2, 4),\n\tivec3(3, 0, 4),\n\tivec3(3, +1, 4),\n\tivec3(3, -1, 4),\n\tivec3(3, +2, 4),\n\tivec3(3, -2, 4),\n\tivec3(3, +3, 4),\n\tivec3(3, -3, 4)\n\t);\n\n\n\n\n\t/* transition every 500 ms */\n\tuint index = (uint(iTime * 2.0) % uint(orbitals.length()));\n\tint l, m, n;\n\tl = orbitals[index].x;\n\tm = orbitals[index].y;\n\tn = orbitals[index].z;\n\n\tfloat zoom = float(15U + index * 2U);\n\t/* spherical coordinates */\n\tvec3 position = vec3(length(xyz) * zoom, theta, psi);\n\n\tc.x = hydrogen(uint(l), abs(m), uint(n), position);\n\n\t// color-primary #FF5053 of https://events.ccc.de/congress/2024/infos/styleguide.html\n\tvec3 reference_primary = srgb2linear(vec3(255, 80, 83));\n\tvec3 palette = vec3(reference_primary / 1e3);\n\tc.xyz = c.xxx * palette;\n    c.w = 1.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"M3dyzS","date":"1735305018","viewed":105,"name":"hydrogen orbitals","username":"noneofyourbusiness","description":"solving the schrÃ¶dinger equation for hydrogen orbitals\n\nporting this made me notice that shadertoy.com uses some older glsl version, idk whether it is selectable.","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["2d","sphericalharmonics","physics","orbitals"],"hasliked":0,"parentid":"","parentname":""}}