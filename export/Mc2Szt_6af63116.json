{"ver":"0.1","info":{"id":"Mc2Szt","date":"1707325540","viewed":117,"name":"Edge cartoon detection","username":"Famousghost","description":"Edge cartoon detection","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["edgecartoondetection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float edgeDetection(sampler2D tex, vec2 fragCoord, vec3 normal, float size)\n{\n    for(int x = -1 ; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            if(x == 0 && y == 0)\n            {\n                continue;\n            }\n            vec3 currentNormal = texture(tex, (fragCoord + vec2(x, y) * size) / iResolution.xy).rgb;\n            if(dot(currentNormal, normal) <= 0.89f)\n            {\n                return 0.0f;\n            }\n        }\n    }\n    return 1.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 result = texture(iChannel0, uv);\n    \n    vec3 normal = result.xyz;\n\n    vec3 col = mix(vec3(0.0f), vec3(1.0f), edgeDetection(iChannel0, fragCoord, normal, 1.2f));\n    col *= result.a;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.005\n#define FAR 1000.0\n\n#define PITCH -20.0\n#define YAW -50.0\n\nfloat sdBox( vec3 p, vec3 size, vec3 offset)\n{\n  p = (p - offset);\n  vec3 q = abs(p) - size;\n  float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return d;\n}\n\nfloat sdSphere(vec3 p, vec3 position, float radius)\n{\n    return length(p - position) - radius;\n}\n\nfloat sdScene(vec3 p)\n{\n    float sphere1 = sdSphere(p, vec3(1.0f, 0.0f, 0.0f), 0.7f);\n    float sphere2 = sdSphere(p, vec3(0.0f, 1.0f, 0.0f), 0.7f);\n    float sphere3 = sdSphere(p, vec3(0.0f, 0.0f, 1.0f), 0.7f);\n    \n    float sphere4 = sdSphere(p, vec3(-1.0f, 0.0f, 0.0f), 0.7f);\n    float sphere5 = sdSphere(p, vec3(0.0f, -1.0f, 0.0f), 0.7f);\n    float sphere6 = sdSphere(p, vec3(0.0f, 0.0f, -1.0f), 0.7f);\n    \n    float result = min(sphere1, sphere2);\n    result = min(result, sphere3);\n    result = min(result, sphere4);\n    result = min(result, sphere5);\n    result = min(result, sphere6);\n    return min(result, sdBox(p, vec3(1.0f), vec3(0.0f)));\n}\n\nfloat rayMarching(vec3 ro, vec3 rd)\n{\n    float depth = 0.0f;\n    for(int i = 0; i < 120; ++i)\n    {\n        vec3 p = ro + rd * depth;\n        float tmp = sdScene(p);\n        depth += tmp;\n        if(tmp <= NEAR || tmp >= FAR)\n            break;\n    }\n    return depth;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    float e  = 0.005f;\n    return normalize(vec3(sdScene(vec3(p.x - e, p.y, p.z)) - sdScene(vec3(p.x + e, p.y, p.z)),\n                sdScene(vec3(p.x, p.y - e, p.z)) - sdScene(vec3(p.x, p.y + e, p.z)),\n                sdScene(vec3(p.x, p.y, p.z - e)) - sdScene(vec3(p.x, p.y, p.z + e))));\n}\n\nfloat diffuseLight(vec3 lightDir, vec3 normal, vec3 p)\n{\n    float diff = max(0.0f, dot(lightDir, normal));\n    \n    if(rayMarching(p - normal * 0.05f, -lightDir) <= FAR)\n    {\n        diff *= 0.5f;\n    }\n\n    return diff;\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n    float ang = radians(angle);\n    \n    return vec3(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y, p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5f * iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(1.0f, 1.0f, 4.0f);\n    vec3 rd = normalize(vec3(uv, -1.0f));\n    \n    ro = rotateZ(ro, iTime * 55.0f);\n    \n    \n    float depth = rayMarching(ro, rd);\n    \n    vec4 col = vec4(0.0f);\n    \n    float pitch = radians(PITCH);\n    float yaw = radians(YAW);\n    \n    vec3 lightDir = normalize(vec3(cos(pitch) * cos(yaw), sin(pitch), cos(pitch) * sin(yaw)));\n    \n    if(depth <= FAR)\n    {\n        vec3 p = ro + rd * depth;\n        vec3 normal = calcNormal(p);\n        float val1 = texture(iChannel0, p.xy * 4.0f).r * -normal.z;\n        float val2 = texture(iChannel0, p.yz * 4.0f).r * -normal.x;\n        float val3 = texture(iChannel0, p.xz * 4.0f).r * -normal.y;\n        col = vec4(normal, clamp(diffuseLight(lightDir, normal, p) + (val1 + val2 + val3), 0.0f, 1.0f));\n    }\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}