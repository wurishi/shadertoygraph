{"ver":"0.1","info":{"id":"4syGR1","date":"1453185507","viewed":288,"name":"Combining two Triangles","username":"Lerc","description":"Multiple ways to render six points as a pair of triangles.  The same six points are used for all 8 images with each image using different options.   The top row has an outline triangle,  Left to Right are Additive,  smooth combine. subtract, and Intersect","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","triangles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float dot2(in vec2 a) {\n    return dot(a,a);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat tri_d(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b-a;\n    vec2 cb = c-b;\n    vec2 ac = a-c;\n    \n    vec2 pa = p-a;\n    vec2 pb = p-b;\n    vec2 pc = p-c;\n    \n    float edge_ab = dot (vec2(-ba.y,ba.x),pa);\n    float edge_bc = dot (vec2(-cb.y,cb.x),pb);\n    float edge_ca = dot (vec2(-ac.y,ac.x),pc);\n                             \n    float v= sign(edge_ab) + sign(edge_bc) + sign(edge_ca);\n    \n    return (v <2.0)         \n        ? sqrt(min (min(\n          dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     \t  dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n          dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) ) )         \n    \t: 0.0;\n\n}\n\n\n\nfloat halfs(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 d = b-a;\n    return dot (vec2(-d.y,d.x),(p-a));\n    \n}\n\nfloat shape_alpha(in vec2 p,\n                  in vec2 a, in vec2 b, in vec2 c,\n                  in vec2 d, in vec2 e, in vec2 f,\n                  in int combineMethod, in float blur) {\n    \n    float tri_1 = tri_d(p, a,b,c);\n    float tri_2 = tri_d(p, d,e,f);\n    \n    float result = 0.0;\n    \n    if ( combineMethod == 0 ) {\n        result = min(tri_1,tri_2);\n    }\n    \n    if ( combineMethod == 1 ) {\n        result = smin(tri_1,tri_2,0.05);\n    }\n\n    if ( combineMethod == 2 ) {\n        result = max(blur-tri_1,tri_2);\n    }\n    \n    if ( combineMethod == 3 ) {\n        result = max(tri_1,tri_2);\n    }\n    \n    return 1.0-smoothstep(0.00,blur,result);    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec2 a = vec2(0.2,0.2);\n    vec2 b = vec2(0.4,0.4);\n    vec2 c = vec2(0.15,0.5);\n\n    vec2 c2 = vec2(0.3,0.2);\n    vec2 b2 = vec2(0.1,0.4);\n    vec2 a2 = vec2(0.4,0.5);\n        \n    float q = 0.0;\n    \n    vec2 xspacing=vec2(0.4,0.0);\n    vec2 yspacing=vec2(0.0,0.4);\n    \n    float blur = 0.2+0.2*sin(iTime);\n    blur=blur*blur;\n    \n    for (int i=0; i<4;i++) {        \n    \tq= max(q,shape_alpha(uv, a,b,c, a2,b2,c2, i, blur));\n    \tq= max(q,shape_alpha(uv, a+yspacing,b+yspacing,c+yspacing, c2+yspacing,b2+yspacing,a2+yspacing, i, blur));\n        a=a+xspacing;\n        b=b+xspacing;\n        c=c+xspacing;\n\n        a2=a2+xspacing;\n        b2=b2+xspacing;\n        c2=c2+xspacing;\n    }    \n    \n    \n\tfragColor = vec4(q,q,q,1.0);\n    \n\n}","name":"","description":"","type":"image"}]}