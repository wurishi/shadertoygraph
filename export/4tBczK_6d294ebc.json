{"ver":"0.1","info":{"id":"4tBczK","date":"1552178438","viewed":356,"name":"point light on heightmap","username":"ghost","description":"light","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tex iChannel0\n\n// ray marching\n#define MAX_STEPS 255\n#define MAX_DIST 100.\n#define EPSILON .001 // to move along gradient\n\nbool animateHeight = false;\nbool animateDepth = false;\nbool rotateMouse = false;\n\n// lighting\nbool light = true;\nvec3 cam = vec3(0.0, 0.0, -5.0);\nstruct Light { vec3 pos; float ld, ls; };\nstruct Material { vec3 ka,kd,ks; float a; };\n#define LIGHTS 1\n\nvec3 rotate(inout vec3 p, float a) \n{\t\n    float s = sin(a);\n    float c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\tp.yz = m*p.yz;\n    return p;\n}\n\nvec2 worldToTex(vec3 p)\n{\n\tvec2 uv = p.xz*.5+.5;\n\tuv.y = 1. - uv.y;\n\treturn uv;\n}\n\nfloat grayScale(vec4 c) { return c.x*.29 + c.y*.58 + c.z*.13; }\n\n\nfloat heightField(vec3 p)\n{\n    vec2 uv = worldToTex(p);\n    vec2 s = 1./iResolution.xy;\n    float c = grayScale(texture(tex, uv));\n    if (animateHeight) {\n    \tc = mix(c,1.-c,sin(iTime*2.)*.8);\n    \tc*=.3;    \n    }\n    //c+=abs(sin(iTime*.5))*.5;\n    return c;\n}\n\n//https://iquilezles.org/articles/terrainmarching\nbool traceHeightField(vec3 ro, vec3 rd, out vec3 hitPos)\n{\n    const float max_steps = 60.;\n    \n    float s = .01;\n    float lh = 0.;\n    vec3  ly = vec3(0.);\n    for(float t = 0.; t < max_steps; t += s)\n    {\n        vec3 p = ro + rd*t;\n\t\tfloat h = heightField(p);\n\t\tif (p.y < h) {\n            t = t - s + s*(lh-ly.y)/(p.y-ly.y-h+lh);\n            //t = (t-.5*s);\n            hitPos = ro + rd  * t;\n            return true;\n\t\t}\n        lh = h;\n        ly = p;\n\t}\n\treturn false;\n}\n\n// Use gradient of the SDF to estimate the normal on the surface at point p\n// http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-ii-lighting-and-coloring/\nvec3 estimateNormal(vec3 p) \n{\n    vec3 xDir = vec3(EPSILON,0,0);\n    vec3 yDir = vec3(0,EPSILON,0);\n    vec3 zDir = vec3(0,0,EPSILON);\n    \n    return normalize(vec3(heightField(p+xDir) - heightField(p-xDir),\n                          heightField(p+yDir) - heightField(p-yDir),\n                          heightField(p+zDir) - heightField(p-zDir)));\n}\n\nLight[LIGHTS] getLights() \n{\n    vec3 l1 = vec3(0.5, 0.5, -5.0);\n    l1 = vec3((iMouse.xy/iResolution.xy)*2.-1., -5.0);\n    l1 = rotate(l1, 1.25 * 2.-1.);\n    //l1.z = -5.0;\n    \n    return Light[LIGHTS] \n    ( \n        Light(l1, 0.5, 1.0)\n    );\n}\n\nvec3 contribution(Material m, vec3 p, Light l) \n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(l.pos - p);\n    vec3 V = normalize(cam - p);\n    vec3 H = normalize(V + L); \n    vec3 R = normalize(reflect(-L,N));\n   \n    float ndotL = dot(N,L);\n    float ndotH = dot(N,H);\n    float rdotV = dot(V,R);\n    \n    if (ndotL < 0.0) return vec3(0);\n    \n    // diffuse component\n    vec3 diffuse = max(ndotL, 0.0) * m.kd*l.ld;\n\n    // specular\n    vec3 specular = pow(max(ndotH, 0.0), m.a) * m.ks*l.ls;\n\n    return (diffuse+specular);\n}\n\nvec3 phong(vec3 p) \n{\n    //Material\n    vec3 ka = vec3(0.0, 0.0, 0.3);\n    vec3 kd = vec3(0.0, 0.0, 0.6);\n    vec3 ks = vec3(1);\n    float alpha = 1.0;\n    Material m = Material(ka,kd,ks,alpha);\n    \n    //Lights\n    vec3 la = vec3(0.5);\n    vec3 color = la*m.ka;  \n\n    Light l[LIGHTS] = getLights();\n    \n    for (int i=0; i<l.length(); i++) {\n        color+=contribution(m, p, l[i]);    \n    }\n\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n\n    // compute ray origin and direction\n    vec3 rd = normalize(vec3(uv, -2.));\n    vec3 ro = vec3(0.,0.,2.);\n    \n    // rotate view\n    ro = rotate(ro, 1.25 * 2.-1.);\n    rd = rotate(rd, 1.25 * 2.-1.); \n\tcam = rotate(cam, 1.25 * 2.-1.);\n    \n\t// rotate view w/mouse\n    if (rotateMouse) {\n        vec2 mouse = iMouse.xy / iResolution.xy * 2.-1.;\n        if (iMouse.x > 0.0) {\n            float ax = (1. - mouse.y);\n            ro = rotate(ro, ax);\n            rd = rotate(rd, ax); \n        }\n    }\n\n\tvec3 c = vec3(0.);   \n    vec3 hitPos;\n    if (traceHeightField(ro, rd, hitPos)) {\n        vec2 uv = worldToTex(hitPos);\n        if (animateHeight) \n            c = texture(iChannel0, uv).xyz;\n        float depth = (animateHeight) ?\n            1.0 - clamp(sin(mod(iTime,5.)*.2),0.,1.) : 0.0;\n        if (hitPos.y > depth)\n            c = texture(iChannel0, uv).xyz;\n        if (light) c += phong(hitPos);\n    }\n    \n\tfragColor = vec4(c, 1.0);\n    //fragColor = vec4(grayScale(fragColor));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TILE\n//#define ROUNDED\n\n// pixellate\nconst float borderSize = 1.;\nconst float tileSize = 10.;\nconst float count = 5.;\n\n// pointillize\nconst float size = .2;\nconst float dist = .4;\nconst float alpha = .4;\t\n\n\n// https://gamedev.stackexchange.com/questions/111017/pixelation-shader-explanation\nvec4 pixellate(vec2 uv)\n{\n    vec2 tile = tileSize / iResolution.xy;\n    vec2 coord = floor(uv/tile)*tile;    \n    return texture(iChannel0, coord);   \n}\n\n// based off: https://www.shadertoy.com/view/MtfXRN\nvec4 pixellate2(vec2 uv)\n{\n    vec4 c = vec4(0.);    \n    vec2 tile = tileSize / iResolution.xy;\n    vec2 p = floor(uv/tile);\n    \n    for (float y = 0.; y < count; ++y) {\n        for (float x = 0.; x < count; ++x) {\n            vec2 coord = (p + vec2(x/count, y/count)) * tile;\n            c += texture(iChannel0, coord);\n        }\n    }\n\n    return c / vec4(count * count);\n}\n\n\n// based off: https://www.shadertoy.com/view/ls23DG\nvec4 pointillize(vec2 uv)\n{\n    vec3 tex = texture(iChannel0, uv).xyz;\n    \n    vec3 c = vec3(1.);\n    vec2 point = vec2(size)*.1;\n    point.x *= iResolution.y/iResolution.x;\n\n    vec2 m = mod(uv,point);\n    vec2 p = m/point - .3;\n    \n    float a = (length(p)-.3)*length(point)*iResolution.x;\n    \n    a = 1.-a;\n    a = min(alpha,max(0.,a));\n    c = vec3(a);\n    c = mix(c,tex,a);\n    return vec4(c,1.);\n}\n\nvec4 getBorders(vec4 fragColor, vec2 fragCoord) \n{\n    vec2 p = floor(fragCoord - tileSize);\n    p = mod(p + borderSize, tileSize);\n  \n    #ifdef TILE\n    float border = step(min(p.x,p.y), borderSize);\n    #else\n    float border = step(p.x, borderSize) * step(p.y, borderSize);\n    #endif\n    \n    return pow(fragColor, vec4(border));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;    \n\n    //fragColor = pixellate(uv);\n    fragColor = pixellate2(uv);\n\n    #if defined(TILE) || defined(ROUNDED)\n    fragColor *= getBorders(fragColor, fragCoord);\n    #endif\n    \n    //fragColor = pointillize(uv);\n}","name":"Buffer A","description":"","type":"buffer"}]}