{"ver":"0.1","info":{"id":"slVBzt","date":"1704476133","viewed":419,"name":"PORTRAIT OF TRISTAN","username":"alro","description":"Known for his decipherment of the the carvings at Eremer, by the close of the century Tristan van Wei had become the pre-eminent authority on eldritch devices.","likes":58,"published":1,"flags":32,"usePreview":1,"tags":["sss","shadow","eye","translucent","skin","head","pbr","human","ear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Exploring modelling and shading a head. Use mouse to move camera.\n    Change FOV in Common for a closer look at the details.\n\n    Inspired by:\n        https://www.shadertoy.com/view/wlf3WX - Head by tdhooper\n        https://www.shadertoy.com/view/Md3GR4 - Meditation for dummies by iapafoto\n        https://www.shadertoy.com/view/WsSBzh - Selfie Girl by iq\n        https://www.shadertoy.com/view/ldd3DX - Surfer Boy by iq\n    \n    The geometry is ray marched only when the camera moves or the resolution changes.\n    The normal and depth are written to a texture in Buffer C and the Image tab shades\n    in screen space using the reconstructed position and normal with detail and albedo \n    maps from Buffer A and a pre-integrated subsurface scattering texture from Buffer B.\n    Screen space shadows are also rendered using the depth information. Buffer D \n    generates height maps for eyebrows and lip detail.\n    \n    The geometry is hand-modelled using signed distance function primitives and\n    constructive solid geometry operations. Shading uses PBR for specular and \n    pre-integrated subsurface scattering for diffuse.\n\n    Do I think it's a real person? Of course not.\n    Did I stare at it long enough to form some sort of attachment? Maybe.\n    Did I start talking to it? That's not a problem until it talks back.\n\n    TODO:\n        Lenses\n        Eyelashes\n        \n    References (not necessarily used):\n    \n    https://renderman.pixar.com/photorealistic-head\n    https://www.3dscanstore.com/hd-head-scans/hd-head-models/hd-male-3d-head-model-21\n    http://simonstechblog.blogspot.com/2015/02/pre-integrated-skin-shading.html\n    https://dennisruan171085578.wordpress.com/2020/09/06/pre-integrated-skin-shading-under-spherical-harmonic-indirect-lighting/\n\n    \n    https://help.autodesk.com/view/ARNOL/ENU/?guid=arnold_user_guide_ac_legacy_shaders_ac_legacy_skin_html\n    https://docs.unrealengine.com/4.26/en-US/Resources/Showcases/DigitalHumans/\n    https://marmoset.co/posts/how-to-create-realistic-hair-peach-fuzz-and-eyes/\n    https://www.youtube.com/watch?v=B3TnEMoNIr4\n    \n    https://www.youtube.com/watch?v=s0DhvFML7oM\n    https://www.youtube.com/watch?v=HlHoIGE2Ocs\n    https://www.youtube.com/watch?v=PYnmn3hp14s\n    https://www.artstation.com/artwork/zDv3gd\n    https://www.artstation.com/artwork/8w8Raw\n    \n    EDIT: Fix texture mapping artefacts\n\n*/\n\n// Rotate light around up-axis\nconst bool animateLight = true;\nconst float lightSpeed = -0.5;\n// If not animated\nconst float lightPosition = 0.0;\nconst float lightHeight = 0.65;\n\n// Render screenspace shadows\n#define SHADOWS\nconst int SAMPLES = 32;\nconst float SHADOW_SOFTNESS = 0.05;\n// How far to march shadow\nconst float SHADOW_DISTANCE = 0.5;\n\nconst vec3 eyeColour = 0.12 * vec3(0.2, 0.5, 1.0);\n\nconst float AMBIENT_STRENGTH = 0.125;\nconst float DETAIL_EPSILON = 2e-3;\nconst float DETAIL_HEIGHT = 0.003;\nconst vec3 DETAIL_SCALE = vec3(4.0);\nconst vec3 BLENDING_SHARPNESS = vec3(1.0);\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\n//----------------------------- Normal mapping -----------------------------\n\n// https://tinyurl.com/y5ebd7w7\nfloat getTriplanar(vec3 position, vec3 normal){\n    float xaxis = texture(iChannel0, DETAIL_SCALE.x*(position.zy)).a;\n    float yaxis = texture(iChannel0, DETAIL_SCALE.y*(position.zx)).a;\n    float zaxis = texture(iChannel0, DETAIL_SCALE.z*(position.xy)).a;\n\n    vec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n    blending = pow(blending, BLENDING_SHARPNESS);\n\tfloat b = (blending.x + blending.y + blending.z);\n\tblending /= b;\n\n    return\txaxis * blending.x + \n       \t\tyaxis * blending.y + \n        \tzaxis * blending.z;\n}\n\n// Return the position of p extruded in the normal direction by normal map\nvec3 getDetailExtrusion(vec3 p, vec3 normal){\n    float detail = DETAIL_HEIGHT * getTriplanar(p, normal);\n    \n    vec3 ap = normalize(p);\n    vec2 uvv = vec2((atan(ap.z, -ap.x) / (0.5*PI)) + 0.5, ap.y + 0.7);\n    float wx = min(smoothstep(0.0, 0.05, uvv.x), smoothstep(1.0, 0.95, uvv.x));\n    float wy = min(smoothstep(0.0, 0.05, uvv.y), smoothstep(1.0, 0.95, uvv.y));\n    float w = min(wx, wy);\n\n    // Lip\n    if(uvv.x > 0.0 && uvv.x < 1.0 && uvv.y > 0.0 && uvv.y < 1.0){\n        detail += w * 0.75*texture(iChannel3, uvv).r;\n    }\n    \n    // Eyebrows\n    if(uvv.x > 0.0 && uvv.x < 1.0 && uvv.y > 0.0 && uvv.y < 1.0){\n        detail += w * 0.75*texture(iChannel3, 2.3*uvv-vec2(1.15, 1.375)).b;\n        detail += w * 0.75*texture(iChannel3, vec2(-1, 1) * (2.3*uvv-vec2(1.15, 1.35))).b;\n    }\n    \n    return p + detail * normal;\n}\n\n\n// Get orthonormal basis from surface normal\n// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\nvoid pixarONB(vec3 n, out vec3 b1, out vec3 b2){\n\tfloat sign_ = n.z >= 0.0 ? 1.0 : -1.0;\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\n// Return the normal after applying a normal map\nvec3 getDetailNormal(vec3 p, vec3 normal){\n\n    vec3 tangent;\n    vec3 bitangent;\n    \n    // Construct orthogonal directions tangent and bitangent to sample detail gradient in\n    pixarONB(normal, tangent, bitangent);\n    \n    tangent = normalize(tangent);\n    bitangent = normalize(bitangent);\n\n    vec3 delTangent = vec3(0);\n    vec3 delBitangent = vec3(0);\n    \n    for(int i = ZERO; i < 2; i++){\n        \n        //i to  s\n        //0 ->  1\n        //1 -> -1\n        float s = 1.0 - 2.0 * float(i&1);\n    \n        delTangent += s * getDetailExtrusion(p + s * tangent * DETAIL_EPSILON, normal);\n        delBitangent += s * getDetailExtrusion(p + s * bitangent * DETAIL_EPSILON, normal);\n\n    }\n    \n    return normalize(cross(delTangent, delBitangent));\n}\n\n//------------------------------- Shading -------------------------------\n\nfloat depth(vec2 uv){\n    return texture(iChannel2, uv).a;\n}\n\nvec3 normal(vec2 uv){\n    return texture(iChannel2, uv).rgb;\n}\n\n\nvec3 getAmbient(vec3 normal){\n\n    // Flip environment map data\n    vec4 n = vec4(normal * vec3(-1,1,1), 1.0);\n    \n    // Venice Sunrise spherical harmonics matrices\n    mat4 red = mat4(0.16553553938865662, 0.12402049452066422, \n                    0.2091294825077057, 0.39199331402778625, \n                    0.12402049452066422, -0.16553553938865662, \n                    0.10027865320444107, 0.3196796178817749, \n                    0.2091294825077057, 0.10027865320444107, \n                    0.03354411944746971, 0.31643790006637573, \n                    0.39199331402778625, 0.3196796178817749, \n                    0.31643790006637573, 1.4789215326309204);\n                    \n    mat4 grn = mat4(0.08535411208868027, 0.07948554307222366, \n                    0.13153763115406036, 0.22119151055812836, \n                    0.07948554307222366, -0.08535411208868027, \n                    0.09292984008789062, 0.3931199014186859, \n                    0.13153763115406036, 0.09292984008789062, \n                    0.000118217445560731, 0.24447447061538696, \n                    0.22119151055812836, 0.3931199014186859, \n                    0.24447447061538696, 1.4334945678710938);\n                    \n    mat4 blu = mat4(0.01650789938867092, 0.04344102740287781, \n                    0.09565411508083344, 0.10879706591367722, \n                    0.04344102740287781, -0.01650789938867092, \n                    0.0988568365573883, 0.5883923768997192, \n                    0.09565411508083344, 0.0988568365573883, \n                    -0.05795031040906906, 0.2256385236978531, \n                    0.10879706591367722, 0.5883923768997192, \n                    0.2256385236978531, 1.7560255527496338);\n\n    float r = dot(n, red * n);\n    float g = dot(n, grn * n);\n    float b = dot(n, blu * n);\n    \n    return vec3(r, g, b);\n}\n\nfloat getOcclusion(vec3 p){\n    p.y -= 0.25;\n    p.x -= 0.21;\n    \n    vec3 q = p;\n    q.z = abs(q.z);\n    q.z -= 0.06;\n    q.x += 1.03;\n    q.y += 0.58;\n    float nostrils = smoothstep(0.0, 0.04, sphereSDF(q, 0.01));\n    \n    q = p;\n    q.z = abs(q.z);\n    q.z -= 0.07;\n    q.x += 1.032;\n    q.y += 0.59;\n    nostrils = min(nostrils, smoothstep(0.005, 0.02, sphereSDF(q, 0.01)));\n    \n    q = p;\n    q.z = abs(q.z);\n    q.x += 0.22;\n    q.y += 0.45;\n    q.z -= 0.55;\n    float ear = smoothstep(0.0, 0.1, sphereSDF(q, 0.01));\n    return min(ear, nostrils);\n}\n\n//---------------------------- PBR ----------------------------\n\n// Trowbridge-Reitz\nfloat distribution(vec3 n, vec3 h, float roughness){\n    float a_2 = roughness * roughness;\n\treturn a_2/(PI * pow(pow(dot_c(n, h), 2.0) * (a_2 - 1.0) + 1.0, 2.0));\n}\n\n// GGX and Schlick-Beckmann\nfloat geometry(float cosTheta, float k){\n\treturn (cosTheta) / (cosTheta * (1.0 - k) + k);\n}\n\nfloat smiths(float NdotV, float NdotL, float roughness){\n    float k = pow(roughness + 1.0, 2.0) / 8.0; \n\treturn geometry(NdotV, k) * geometry(NdotL, k);\n}\n\n// Fresnel-Schlick\nvec3 fresnel(float cosTheta, vec3 F0){\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n} \n\n// Specular part of Cook-Torrance BRDF\nvec3 BRDF(vec3 p, vec3 n, vec3 viewDir, vec3 lightDir, vec3 F0, float roughness){\n    vec3 h = normalize(viewDir + lightDir);\n    float NdotL = dot_c(lightDir, n);\n    float NdotV = dot_c(viewDir, n);\n\n    float cosTheta = dot_c(h, viewDir);\n    float D = distribution(n, h, roughness);\n    vec3 F = fresnel(cosTheta, F0);\n\n    float G = smiths(NdotV, NdotL, roughness);\n    \n    vec3 specular =  D * F * G / max(0.0001, (4.0 * NdotV * NdotL));\n    \n    return specular;\n}\n\n\n#define SIZE 2048.0\n\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash(vec3 p3){\n    p3 = mod(p3, SIZE);\n    p3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return 2.0 * fract((p3.xxy + p3.yxx) * p3.zyx) - 1.0;\n}\n\nfloat worley(vec3 pos, float numCells){\n\tvec3 p = pos * numCells;\n\tfloat d = 1.0e10;\n\tfor (int x = -1; x <= 1; x++){\n\t\tfor (int y = -1; y <= 1; y++){\n\t\t\tfor (int z = -1; z <= 1; z++){\n                vec3 tp = floor(p) + vec3(x, y, z);\n                tp = p - tp - (0.5 + 0.5 * hash(mod(tp, numCells)));\n                d = min(d, dot(tp, tp));\n            }\n        }\n    }\n\treturn saturate(d);\n}\n\nvec3 getFreckles(vec3 p){\n\n    float dist = smoothstep(0.2, -0.5, worley(p, 24.0));\n    dist = max(dist, smoothstep(0.2, -0.5, worley(p, 48.0)));\n    \n    float area = smoothstep(1.2, -0.0, length(p + vec3(1, 0.2, 0)));\n    area = max(area, smoothstep(0.5, 0.35, length(vec3(p.x, p.y, abs(p.z)) + vec3(1, 0.2, -0.35))));\n    \n    area *= 1.0 - 0.75 * smoothstep(0.65, 0.3, length(vec3(p.x, p.y, abs(p.z)) + vec3(1, 0.85, -0.25)));\n    \n    vec3 col = mix(vec3(1), vec3(0.4, 0.15, 0.0), dist * area);\n    \n    return col;\n}\n\nfloat getHairArea(vec3 p){\n\n    // Top\n    vec3 q = p;\n    q.x -= 0.2;\n    q.y -= 0.6;\n    float d = smoothstep(0.875, 0.975, length(q));\n    \n    // Back\n    q = p;\n    q.x -= 0.5;\n    q.y -= 0.15;\n    q.z = abs(q.z);\n    q.z -= 0.1;\n    d = min(d, smoothstep(0.5, 0.8, length(q)));\n\n    \n    // Top sides\n    q = p;\n    q.x += 0.15;\n    q.y -= 0.3;\n    q.z = abs(q.z);\n    q.z -= 0.4;\n    d = min(d, smoothstep(0.325, 0.5, length(q)));\n    \n    \n    // Sideburns\n    q = p;\n    q.x += 0.2;\n    q.z = abs(q.z);\n    q.z -= 0.4;\n    float sideBurnD = smoothstep(-0.0, 0.25, sdBox(q, vec3(0.05, 0.1, 0.5)));\n    \n    q = p;\n    q.x += 0.2;\n    q.y += 0.4;\n    q.z = abs(q.z);\n    q.z -= 0.4;\n    sideBurnD = max(sideBurnD, smoothstep(0.25, 0.0, sdBox(q, vec3(0.5, 0.1, 0.5))));\n    \n    d = min(d, sideBurnD);\n    \n    // Back sides\n    q = p;\n    q.x -= 0.5;\n    q.y -= 0.15;\n    q.z = abs(q.z);\n    q.z -= 0.3;\n    d = min(d, smoothstep(0.5, 0.8, length(q)));\n    \n    // Ear hollow\n    q = p;\n    q.x -= 0.045;\n    q.y += 0.15;\n    q.z = abs(q.z);\n    q.z -= 0.75;\n    d = max(d, smoothstep(0.275, 0.2, length(q)));\n    \n        \n    // Back hollow\n    q = p;\n    q.x -= 0.075;\n    q.y += 0.4;\n    q.z = abs(q.z);\n    q.z -= 0.5;\n    d = max(d, smoothstep(0.4, 0.2, length(q)));\n    \n    return 1.0 - d;\n}\n\nvec3 shadeEyes(vec3 p, vec3 normal){\n    \n    vec3 col = 0.8 * vec3(1.0, 0.7, 0.7);\n    \n    float pupil = getPupilSDF(p);\n    \n    float bloodVessels = worley(p, 64.0);\n    col = mix(mix(col, 0.8 * vec3(0.8, 0.3, 0.3), bloodVessels), col, smoothstep(0.09, 0.0, pupil));\n    \n    col = mix(col, vec3(0.05), smoothstep(0.013, 0.01, pupil));\n    \n    vec3 irisCol = mix(0.5*eyeColour, eyeColour, saturate(2.0*worley(p, 128.0)));\n    irisCol = irisCol + 0.1*vec3(1,1,0) * saturate(worley(p, 100.0));\n    irisCol = mix(eyeColour, irisCol, 0.5);\n    col = mix(col, irisCol, smoothstep(0.01, 0.008, pupil));\n    col = mix(col, vec3(0), smoothstep(0.0015, 0.0005, pupil));\n   \n    float eyeDist = getEyesSDF(p, 1e2);\n    col = mix(col, 0.75*col, smoothstep(0.1, 0.0, eyeDist));\n    col = mix(col, 0.75*col, smoothstep(0.025, -0.015, eyeDist));\n    return col;\n}\n\nmat4 perspective(float fieldOfView, float aspect, float near, float far) {\n    float f = tan(PI * 0.5 - 0.5 * radians(fieldOfView));\n    float rangeInv = 1.0 / (near - far);\n\n    return mat4(\n      f / aspect, 0.0, 0.0, 0.0,\n      0.0, f, 0.0, 0.0,\n      0.0, 0.0, (near + far) * rangeInv, -1.0,\n      0.0, 0.0, near * far * rangeInv * 2.0, 0.0\n    );\n}\n\nfloat getShadow(vec2 uv, vec3 p, vec3 cameraPos, vec3 lightDir, vec2 res, mat4 viewMatrix){\n\n    float shadow = 0.0;\n    \n    mat4 perspectiveMatrix = perspective(FOV, res.x/res.y, 0.0, 1.0);\n \n    float d = depth(uv);\n    \n    const float del = SHADOW_DISTANCE/float(SAMPLES);\n    for(int i = 0; i < SAMPLES; i++) {\n        vec3 pos = p + lightDir * del * float(i);\n        vec4 clip = perspectiveMatrix * (inverse(viewMatrix) * vec4(pos, 1.0));\n        clip.xyz /= clip.w;  \n        clip.xy = clip.xy * 0.5 + 0.5;\n\n        float traversedDepth = depth(clip.xy);\n        bool onScreen = clip.x >= 0.0 && clip.x <= 1.0 && clip.y >= 0.0 && clip.y <= 1.0;\n        \n        if(onScreen && (length(pos - cameraPos) - traversedDepth) > 1e-4) {\n            shadow += del / SHADOW_SOFTNESS;\n        }\n    }\n    return 1.0-saturate(shadow);\n}\n\nvec3 shading(vec3 p, vec3 n, vec3 rayDir, vec3 geoNormal, float shadow, vec3 lightDir){\n    vec3 specular = vec3(0);\n\n    vec3 ap = normalize(p);\n    vec4 data = texture(iChannel0, vec2((atan(ap.z, -ap.x) / TWO_PI) + 0.5, acos(-ap.y) / PI));\n    vec3 albedo = data.rgb;\n    \n    albedo *= getFreckles(p);\n    \n    vec2 uvv = vec2((atan(ap.z, -ap.x) / (0.5*PI)) + 0.5, ap.y + 0.7);\n    float lips = 0.0;\n    \n    float wx = min(smoothstep(0.0, 0.05, uvv.x), smoothstep(1.0, 0.95, uvv.x));\n    float wy = min(smoothstep(0.0, 0.05, uvv.y), smoothstep(1.0, 0.95, uvv.y));\n    float w = min(wx, wy);\n    \n    if(uvv.x > 0.0 && uvv.x < 1.0 && uvv.y > 0.0 && uvv.y < 1.0){\n        lips = 1.0-texture(iChannel3, uvv).g;\n        albedo = mix(albedo, albedo * vec3(1.0, 0.8, 0.9), w * smoothstep(0.0, 1.0, lips));\n        \n        float eyebrows = max(texture(iChannel3, 2.3*uvv-vec2(1.15, 1.375)).b, \n                             texture(iChannel3, vec2(-1, 1) * (2.3*uvv-vec2(1.15, 1.35))).b);\n    \n        albedo = mix(albedo, 0.125*vec3(0.4, 0.2, 0.1), w * smoothstep(0.0, 1.0, 200.0*eyebrows));\n    \n        albedo = saturate(albedo);\n    }\n    \n    float hair = getHairArea(p) * (1.0-worley(p, 128.0));\n    albedo = mix(albedo, vec3(0.04, 0.02, 0.01), smoothstep(0.25, 1.25, hair));\n    \n    vec3 q = p;\n    q.y -= 0.25;\n    q.x -= 0.2;\n    float collar = collarSDF(q);\n    albedo = mix(0.1 * vec3(0.1, 0.2, 0.1), albedo, smoothstep(0.0, 0.01, collar));\n    albedo = mix(albedo, 0.1 * vec3(0.1, 0.2, 0.1), smoothstep(-1.0, -1.2, rotateZ(q, -0.2).y));\n    \n    float h = getTriplanar(p, geoNormal);\n    float roughness = 0.15;\n    roughness = mix(roughness, 0.1, h); \n    roughness = mix(roughness, 0.9, hair);\n    roughness = mix(roughness, 0.01, smoothstep(0.0, 1.0, lips));\n    \n    float eyeballDist = getEyeballSDF(q);\n    if(eyeballDist < 0.001){\n        albedo = shadeEyes(q, geoNormal);\n        roughness = 0.01;\n        n = geoNormal;\n    }\n    \n    float IOR = mix(1.3, 1.5, smoothstep(0.0, 0.25, roughness));\n    \n    // Reflectance of the surface when looking straight at it along the negative normal\n    vec3 F0 = vec3(pow(IOR - 1.0, 2.0) / pow(IOR + 1.0, 2.0));\n    \n    roughness = mix(0.35, roughness, smoothstep(0.0, 0.01, collar));\n    specular += 0.35*BRDF(p, n, -rayDir, lightDir, F0, roughness) * dot_c(n, lightDir);\n\n    roughness = 0.25;\n    specular += BRDF(p, n, -rayDir, lightDir, F0, roughness) * dot_c(n, lightDir);\n    \n    float d = 0.5 + 0.5 * dot(geoNormal, lightDir);\n\n    float curvature = length(fwidth(geoNormal));\n    curvature = mix(0.1, 0.5, curvature);\n    curvature = mix(curvature, 0.0, hair);\n\n    vec3 transmittance = texture(iChannel1, vec2(d, curvature)).rgb;\n    \n    vec3 diffuse = transmittance;\n    \n    // Mix detail normal with geometry normal to soften ambient light contribution\n    // Add reddish hue to simulate ambient subsurface scattering\n    vec3 ambientCol = mix(vec3(1,0,0), getAmbient(mix(geoNormal, n, 0.15)), 0.9);\n    vec3 ambient = AMBIENT_STRENGTH * ambientCol;\n    \n\n    // Reflection of the environment.\n    vec3 reflectedDir = normalize(reflect(rayDir, n));\n    vec3 reflectedCol = getAmbient(reflectedDir);\n    \n    float cosTheta = dot_c(mix(geoNormal, n, 0.25), -rayDir);\n    float F = fresnel(cosTheta, F0).x;\n    \n    ambient = mix(ambient, reflectedCol, saturate(F * 0.35));\n\n    vec3 radiance = vec3(1.0);\n    return getOcclusion(p) * radiance * (shadow * specular + albedo * (ambient + shadow * diffuse));\n}\n\n\n//----------------------------- Tonemapping and output ------------------------------\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //----------------- Define a camera -----------------\n    \n    vec3 rayDir = rayDirection(FOV, fragCoord, iResolution.xy);\n\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n    vec3 targetDir = -cameraPos;\n    \n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel2, uv);\n    \n    vec3 col;\n    \n    if(data.a < 10.0){\n        vec3 p = cameraPos + rayDir * data.a;\n        vec3 geoNormal = data.xyz;\n        vec3 detailNormal = normalize(getDetailNormal(p, geoNormal));\n        \n        float t = animateLight ? lightSpeed * iTime : lightPosition;\n        vec3 lightDir = normalize(vec3(sin(t), lightHeight, cos(t)));\n        mat4 viewMatrix4 = lookAt4(cameraPos, targetDir, up);\n        float shadow = 1.0;\n        \n    #ifdef SHADOWS\n        shadow = getShadow(uv, p, cameraPos, lightDir, iResolution.xy, viewMatrix4);\n    #endif\n    \n        col = shading(p, detailNormal, rayDir, geoNormal, shadow, lightDir);\n\n    }else{\n        col = 0.01 * getAmbient(rayDir);\n    }\n    \n    // Tonemapping\n    col = ACESFilm(col);\n\n    // Gamma\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n    Albedo (RGB) and detail height map for skin (A)\n    Rendered only on start or resolution change.\n\n    &\n    \n    Track mouse movement and resolution change between frames and set camera position. \n    (Overwrites first couple of pixels)\n*/\n\n#define EPS 1e-4\n\n#define SIZE 1024\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash(vec2 p){\n    p = mod(p, float(SIZE));\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return 2.0 * fract((p3.xx+p3.yz)*p3.zy) - 1.0;\n}\n\n// 5th order polynomial interpolation\nvec2 fade(vec2 t){\n    return (t * t * t) * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat gradientNoise(vec2 p ){\n\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = fade(f);\n    return  0.5+0.5*mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                              dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                         mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                              dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat worley(vec2 pos, float numCells){\n\tvec2 p = pos * numCells;\n\tfloat d = 1e10;\n\tfor (int x = -1; x <= 1; x++){\n\t\tfor (int y = -1; y <= 1; y++){\n            vec2 tp = floor(p) + vec2(x, y);\n            tp = p - tp - (0.5 + 0.5 * hash(mod(tp, numCells)));\n            d = min(d, dot(tp, tp));\n        }\n    }\n\treturn d;\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    return min(1e2, max(1e-5, pow(radius/max(1e-5, dist), intensity)));\n}\n\nvec2 rotate(vec2 p, float a){\n    return mat2(cos(a), sin(a), -sin(a), cos(a)) * p;\n}\n\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h ){\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\nfloat mouthLine(vec2 pos){\n\n    const int N = 6;\n    vec2 points[N];\n    pos.y += 0.002;\n    points[0] = vec2(-0.0525, -0.22);\n    points[1] = vec2(-0.015, -0.195);\n    points[2] = vec2(-0.00001, -0.20);\n    points[3] = vec2(0.015, -0.195);\n    points[4] = vec2(0.07, -0.23);\n    points[5] = vec2(0.07, -0.23);\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n    float dist = 1e10;\n    for(int i = ZERO; i < N-2; i++){\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, c_prev, points[i], c));\n    }\n    return dist;\n}\n\nfloat getEyeLine(vec2 pos){\n\n    float dist = 1e10;\n    const int N = 6;\n    vec2 points[N];\n    pos.y -= 0.2055;\n    pos.x = abs(pos.x);\n    pos.x -= 0.015;\n    points[0] = vec2(0.02, -0.22);\n    points[1] = vec2(0.03, -0.2);\n    points[2] = vec2(0.045, -0.195);\n    points[3] = vec2(0.06, -0.2);\n    points[4] = vec2(0.07, -0.22);\n    points[5] = vec2(0.07, -0.22);\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n    for(int i = ZERO; i < N-2; i++){\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, c_prev, points[i], c));\n    }\n    \n    pos.y += 0.028;\n    pos.y += 0.0055;\n    pos.x -= 0.002;\n    \n    points[0] = vec2(0.02, -0.195);\n    points[1] = vec2(0.03, -0.2);\n    points[2] = vec2(0.045, -0.21);\n    points[3] = vec2(0.06, -0.2);\n    points[4] = vec2(0.07, -0.19);\n    points[5] = vec2(0.07, -0.19);\n    \n    c = (points[0] + points[1]) / 2.0;\n    c_prev;\n    for(int i = ZERO; i < N-2; i++){\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, c_prev, points[i], c));\n    }\n\n    return dist;\n}\n\nfloat getEyeLashes(vec2 pos){\n\n    float dist = 1e10;\n    const int N = 6;\n    vec2 points[N];\n    pos.y -= 0.2055;\n    pos.x = abs(pos.x);\n    pos.x -= 0.015;\n    points[0] = vec2(0.02, -0.22);\n    points[1] = vec2(0.03, -0.2);\n    points[2] = vec2(0.045, -0.198);\n    points[3] = vec2(0.06, -0.205);\n    points[4] = vec2(0.07, -0.22);\n    points[5] = vec2(0.07, -0.22);\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n    for(int i = ZERO; i < N-2; i++){\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, c_prev, points[i], c));\n    }\n    \n    pos.y += 0.028;\n    pos.y += 0.0055;\n    pos.x -= 0.002;\n    \n    points[0] = vec2(0.02, -0.195);\n    points[1] = vec2(0.03, -0.205);\n    points[2] = vec2(0.045, -0.205);\n    points[3] = vec2(0.06, -0.2);\n    points[4] = vec2(0.07, -0.18);\n    points[5] = vec2(0.07, -0.18);\n    \n    c = (points[0] + points[1]) / 2.0;\n    c_prev;\n    for(int i = ZERO; i < N-2; i++){\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, c_prev, points[i], c));\n    }\n\n    return dist;\n}\n\nfloat fbm(vec2 p){\n    float weight = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    float res = 0.0;\n    for(int i = ZERO; i < 3; i++){\n        res += amplitude * gradientNoise(frequency * p);\n        weight += amplitude;\n        amplitude *= 0.9;\n        frequency *= 2.0;\n    }\n    \n    return res / weight;\n}\n\nvec4 getSkin(vec2 fragCoord){\n    bool resolutionChanged = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).r > 0.0;\n    \n    if(iFrame == 0 || resolutionChanged){\n    \n        vec2 uv = fragCoord/iResolution.xy;\n        vec2 p = uv;\n        uv.x *= iResolution.x/iResolution.y;\n\n        vec3 skinCol = 0.7*vec3(0.945, 0.44, 0.3);\n\n        float noise0 = gradientNoise(128.0*uv);\n        float noise1 = gradientNoise(64.0*(uv+0.5));\n        float noise2 = gradientNoise(200.0*uv);\n\n        skinCol = mix(vec3(1,0.9,0.9)*skinCol, skinCol, noise0);\n        skinCol = mix(vec3(0.9,0.85,1)*skinCol, skinCol, saturate(0.4+noise1));\n\n        vec3 lipCol = mix(skinCol, 0.35*vec3(1.0, 0.1, 0.2), 0.4);\n        vec3 vessels = vec3(1, 0.02, 0.15);\n        vec3 darkCol = mix(skinCol, 0.5*vessels, 0.25*noise2);\n        darkCol = mix(darkCol, 0.3*vessels, 0.225);\n\n        vec3 col = skinCol;\n\n        float lip = 1e10;\n\n        vec2 q = p;\n        q -= 0.5;\n        q.x = abs(q.x);\n        q.y += 0.191;\n        q = rotate(q, PI * 0.66);\n        lip = min(lip, sdUnevenCapsule(q, 0.015, 0.0045, 0.04));\n\n        q = p;\n        q -= 0.5;\n        q.x = abs(q.x);\n        q.y += 0.208;\n        q = rotate(q, PI * 0.53);\n        lip = min(lip, sdUnevenCapsule(q, 0.013, 0.005, 0.03));\n\n        q = p;\n        q -= 0.5;\n        q.y += 0.16;\n        q = rotate(q, PI * 0.55);\n        lip = opSmoothSub(sdCircle(q, 0.02), lip, 0.01);\n\n        col = mix(col, lipCol, smoothstep(0.01, -0.001, lip));\n        \n        float eyes = 1e10;\n        q = p;\n        q -= 0.5;\n        q.x = abs(q.x);\n        q.x -= 0.03;\n        q.y += 0.015;\n        q = rotate(q, PI * 0.775);\n        eyes = min(eyes, sdUnevenCapsule(q, 0.05, 0.03, 0.05));\n\n        q = p;\n        q -= 0.5;\n        q.x = abs(q.x);\n        q.x -= 0.05;\n        q.y += 0.015;\n        q = rotate(q, PI * 0.5);\n        eyes = min(eyes, sdUnevenCapsule(q, 0.03, 0.03, 0.025));\n\n        q = p;\n        q -= 0.5;\n        q.y += 0.08;\n        eyes = opSmoothSub(sdUnevenCapsule(q, 0.005, 0.01, 0.095), eyes, 0.035);\n\n        col = mix(col, 0.9*darkCol, smoothstep(0.015, -0.025, eyes));\n\n        float nose = 1e10;\n        q = p;\n        q -= 0.5;\n        q.y += 0.125;\n        nose = sdCircle(q, 0.03);\n\n        q = p;\n        q -= 0.5;\n        q.y += 0.125;\n        nose = min(nose , sdUnevenCapsule(q, 0.015, 0.001, 0.075));\n\n        col = mix(col, mix(skinCol, darkCol, 0.75), smoothstep(0.02, -0.01, nose));\n\n        float cheeks = 1e10;\n        q = p;\n        q -= 0.5;\n        q.x = abs(q.x);\n        q.x -= 0.075;\n        q.y += 0.11;\n        q = rotate(q, PI * 0.9);\n        cheeks = sdUnevenCapsule(q, 0.035, 0.02, 0.09);\n\n        col = mix(col, mix(skinCol, darkCol, 0.5), smoothstep(0.03, -0.02, cheeks));\n\n        float ears = 1e10;\n        q = p;\n        q -= 0.5;\n        q.x = abs(q.x);\n        q.x -= 0.265;\n        q.y -= 0.02;\n        q = rotate(q, PI);\n        ears = sdUnevenCapsule(q, 0.02, 0.03, 0.2);\n\n        col = mix(col, mix(skinCol, darkCol, 0.75), smoothstep(0.025, -0.02, ears));\n\n        float brow = 1e10;\n        q = p;\n        q -= 0.5;\n        q.x = abs(q.x);\n        float noise = fbm(rotate(q, 0.05*PI) * vec2(256.0, 32.0));\n        q.y += mix(0.0, -0.0075, smoothstep(0.0, 0.1, q.x));\n        q.y += mix(0.0, -0.0025, smoothstep(0.0, 0.05, q.x));\n        q.x -= 0.0325;\n        q.y -= 0.042;\n        q = rotate(q, 0.5*PI);\n        brow = sdUnevenCapsule(q, 0.0175, 0.0075, 0.0575);\n\n        q = p;\n        q -= 0.5;\n        float mouthLine = mouthLine(q);\n        \n        float lipNoise = fbm(q * vec2(64.0, 10.0));\n        col = mix(col, mix(lipCol, mix(lipCol, lipCol*vec3(0.6,0.5,0.5), 0.5), lipNoise), smoothstep(0.03, -0.01, mouthLine) * smoothstep(0.01, -0.005, lip));       \n        col = mix(col, mix(lipCol, mix(lipCol, 0.75*lipCol*vec3(0.4,0.15,0.15), 0.5), smoothstep(0.05, 0.01, abs(q.x))), smoothstep(0.0075, -0.005, mouthLine));\n        col = mix(col, mix(lipCol, mix(lipCol, 0.75*lipCol*vec3(0.4,0.15,0.15), 0.5), smoothstep(0.05, 0.01, abs(q.x))), smoothstep(0.015, -0.03, mouthLine));\n\n        q = p;\n        q -= 0.5;\n        float eyeLine = getEyeLine(q);\n        col = mix(col, mix(skinCol, skinCol*vec3(0.4,0.15,0.2), 0.6), smoothstep(0.015, -0.0, eyeLine));\n        \n        q = p;\n        q -= 0.5;\n        q.y += 0.001;\n        float eyeLashes = getEyeLashes(q);\n        col = mix(col, mix(col, 0.125*vec3(0.4, 0.2, 0.1), 0.45), smoothstep(0.005, -0.0, eyeLashes));\n        \n        uv = fragCoord/iResolution.xy;\n        float skinHeight = smoothstep(2.0, 0.0, worley(uv, 32.0));\n        float pores = 1.0-saturate(getGlow(worley(uv, 32.0), 0.001, 0.2));\n\n        return vec4(col, skinHeight * pores);\n    }else{\n        return texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    fragColor = getSkin(fragCoord);\n    \n    // Store camera and resolution data in the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 5.0)){\n        \n        vec4 oldData = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n\n        vec2 oldPolarAngles = oldData.xy;\n        vec2 oldMouse = oldData.zw;\n\n        vec2 polarAngles = vec2(0);\n        vec2 mouse = iMouse.xy / iResolution.xy; \n        \n        // Stop camera going directly above and below\n        float angleEps = 0.01;\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame.\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse - oldMouse;\n            polarAngles = oldPolarAngles + vec2(5.0, 3.0) * mouseMove;\n            \n        }else{\n            polarAngles = oldPolarAngles;\n        }\n        \n        polarAngles.x = mod(polarAngles.x, 2.0 * PI - angleEps);\n        polarAngles.y = min(PI - angleEps, max(angleEps, polarAngles.y));\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames.\n            if(iFrame == 0){\n                polarAngles = vec2(0.2, 1.7);\n                mouse = vec2(0);\n            }\n            fragColor = vec4(polarAngles, mouse);\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)){\n            // Cartesian direction from polar coordinates.\n            vec3 cameraPos = normalize(vec3(-cos(polarAngles.x) * sin(polarAngles.y), \n                                             cos(polarAngles.y), \n                                            -sin(polarAngles.x) * sin(polarAngles.y)));\n\n            fragColor = vec4(CAMERA_DIST * cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n\n        // Store FOV in the fifth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 4.5)){\n            float fovChangeFlag = 0.0;\n            // The FOV last frame.\n            float oldFOV = texelFetch(iChannel0, ivec2(0.5, 4.5), 0).y;\n            \n            if(FOV != oldFOV){\n            \tfovChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(fovChangeFlag, FOV, 0.0, 1.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n    Copyright (c) 2024 al-ro\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE. THE SOFTWARE.\n*/\n\n#define FOV 40.0\n#define CAMERA_DIST 3.5\n\n#define PI 3.14159\n#define TWO_PI 6.283185\n#define FOUR_PI 12.56637\n#define HALF_PI 1.570795\n\n// Minimum dot product value\nconst float minDot = 1e-3;\n\n// Clamped dot product\nfloat dot_c(vec3 a, vec3 b){\n\treturn max(dot(a, b), minDot);\n}\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\n\nvec3 saturate(vec3 x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n\n\n// https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n// Compute the near and far intersections using the slab method.\n// No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p, vec3 boxMin, vec3 boxMax){\n    float eps = 1e-4;\n\treturn  (p.x > boxMin.x-eps) && (p.y > boxMin.y-eps) && (p.z > boxMin.z-eps) && \n\t\t\t(p.x < boxMax.x+eps) && (p.y < boxMax.y+eps) && (p.z < boxMax.z+eps);\n}\n\nbool testAABB(vec3 org, vec3 dir, vec3 boxMin, vec3 boxMax, out float distToStart){\n\tvec2 intersections = intersectAABB(org, dir, boxMin, boxMax);\n\t\n    if(insideAABB(org, boxMin, boxMax)){\n        intersections.x = 1e-4;\n    }\n    \n    bool hitsAABB = intersections.x > 0.0 && (intersections.x < intersections.y);\n    \n    distToStart = hitsAABB ? intersections.x : 1e10;\n    return hitsAABB;\n}\n\n//-------------------------------- Camera --------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord, vec2 resolution) {\n    vec2 xy = fragCoord - resolution.xy / 2.0;\n    float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\nmat4 lookAt4(vec3 camera, vec3 at, vec3 up){\n  vec3 zaxis = normalize(at-camera);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n  \n  return mat4(vec4(xaxis, 0.0), vec4(yaxis, 0.0), vec4(-zaxis, 0.0), vec4(camera, 1.0));\n}\n\n//-------------------------------- Rotations --------------------------------\n\nvec3 rotate(vec3 p, vec4 q){\n  return 2.0 * cross(q.xyz, p * q.w + cross(q.xyz, p)) + p;\n}\nvec3 rotateX(vec3 p, float angle){\n    return rotate(p, vec4(sin(angle/2.0), 0.0, 0.0, cos(angle/2.0)));\n}\nvec3 rotateY(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, sin(angle/2.0), 0.0, cos(angle/2.0)));\n}\nvec3 rotateZ(vec3 p, float angle){\n\treturn rotate(p, vec4(0.0, 0.0, sin(angle), cos(angle)));\n}\n\n//---------------------------- Operations ----------------------------\n\nvec4 opElongate( in vec3 p, in vec3 h ){ \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat opSmoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n    \nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSmoothMin(float a, float b, float k){\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//---------------------------- Distance functions ----------------------------\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundCone( vec3 p, float r1, float r2, float h ){\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCapsule( vec3 p, float r, float h ){\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r ){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb){\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat getPupilSDF(vec3 p){\n    vec3 q = p;\n    q.x += 0.92;\n    q.z = abs(q.z);\n    q.z -= 0.255;\n    q.y += 0.279;\n    return sphereSDF(q, 0.057);\n}\n\nfloat getEyeballSDF(vec3 p){\n    \n    vec3 q = p;\n    \n    q.x += 0.74;\n    q.z = abs(q.z);\n    q.z -= 0.255;\n    q.y += 0.258;\n    \n    float d = sphereSDF(q, 0.14);\n    \n    d = opSmoothSub(getPupilSDF(p), d, 0.015);\n    \n    return d;\n    \n}\n\nfloat getEyesSDF(vec3 p, float dist){\n    // Top lid\n    float dist_t = 100.0;\n    vec3 q = p;\n    q.z = abs(q.z);\n    q += vec3(0.7, 0.245, -0.25);\n\n    q = rotateY(q, -0.15);\n    dist_t = sphereSDF(q, 0.19);\n    \n    q += vec3(0.22, 0.25, 0.01);\n    dist_t = opSmoothSub(sphereSDF(q, 0.25), dist_t, 0.01);\n    q += vec3(0.0, -0.13, 0.015);\n    dist_t = opSmoothSub(sphereSDF(q, 0.13), dist_t, 0.015);\n    \n    // Bottom lid\n    float dist_b = dist_t;\n    q = p;\n    q.z = abs(q.z);\n    q += vec3(0.695, 0.25, -0.245);\n    q = rotateY(q, -0.1);\n    q = rotateX(q, 0.09);\n    dist_b = sphereSDF(q, 0.195);\n    \n    q.x += 0.1;\n    q.y -= 0.115;\n    \n    dist_b = opSmoothSub(sphereSDF(q, 0.2), dist_b, 0.012);\n    \n    // Combine\n    dist_t = opSmoothMin(dist_t, dist_b, 0.005);\n\n    // Add to scene\n    dist = opSmoothMin(dist_t, dist, 0.01);\n    \n    // Tear duct\n    q = p;\n    q.z = abs(q.z);\n    q += vec3(0.835, 0.3, -0.12);\n    q = rotateX(q, -0.4 * PI);\n    q = rotateZ(q, -0.0 * PI);\n    dist = opSmoothSub(sdCapsule(q, 0.001, 0.05), dist, 0.035);\n    \n    q = p;\n    q.z = abs(q.z);\n    q += vec3(0.795, 0.3, -0.12);\n    q = rotateX(q, -0.4 * PI);\n    q = rotateZ(q, -0.1 * PI);\n    dist = opSmoothMin(sdCapsule(q, 0.015, 0.05), dist, 0.01);\n    \n    return dist;\n}\n\n\n\n//------------------------- Collar -------------------------\n\nvec2 radialRepetition(vec2 p, float cells){\n    float an = TWO_PI/cells;\n    float fa = (atan(p.y,p.x)+an*0.5)/an;\n    float sym = an*floor(fa);\n    p.xy = mat2(cos(sym),-sin(sym), sin(sym), cos(sym))*p.xy;\n    return p;\n}\n\nfloat collarSDF(vec3 p){\n\n    float dist = 1e5;\n    vec3 q = p;\n    \n    q.y += 1.5;\n    q.x -= 0.2;\n    q = rotateZ(q, -0.2);\n\n    q.xz = radialRepetition(q.xz, 64.0);\n    \n    q = rotateZ(q, 0.5);\n    \n    q.y -= 0.7;\n    q = rotateZ(q, 0.9);\n    dist = opSmoothMin(dist, sdRoundCone(q, 0.07, 0.1, 0.5), 0.0);\n    \n    return dist;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    RGB:\n    \n    Pre-integrated screen-space subsurface scattering based on:\n\n    https://therealmjp.github.io/posts/sss-intro/\n    https://dokumen.tips/documents/advances-in-real-time-rendering-in-games-pre-integrated-skin-shading-eric-penner.html\n    https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-14-advanced-techniques-realistic-real-time-skin\n    https://www.shadertoy.com/view/4tXBWr\n    https://www.shadertoy.com/view/dt2SWh\n    \n    Rendered only on start or resolution change.\n*/\n\n\n// Gaussian definition from Nvidia article although different from standard form\n// v: variance\n// x: evaluation position\nfloat gaussian(float v, float x){\n\treturn 1.0/sqrt(TWO_PI*v)*exp(-(x*x)/(2.0*v));\n}\n\n// Scattering profile for human skin from Nvidia article\nvec3 getProfile(float x){\n    return gaussian(0.0064, x) * vec3(0.233, 0.455, 0.649) +\n    \t   gaussian(0.0484, x) * vec3(0.100, 0.336, 0.344) +\n    \t   gaussian(0.1870, x) * vec3(0.118, 0.198, 0.000) +\n    \t   gaussian(0.5670, x) * vec3(0.113, 0.007, 0.007) +\n    \t   gaussian(1.9900, x) * vec3(0.358, 0.004, 0.000) +\n    \t   gaussian(7.4100, x) * vec3(0.078, 0.000, 0.000);\n}\n\n/*\n  We want to find the amount of light that travels to the evaluated point through a \n  sphere of a given radius. For this we sample points around a circle, integrating \n  the light contribution from each sample point. We find the amount of light arriving \n  at the sample point using the diffuse Lambertian term, calculate the path length \n  through the sphere and find the amount of light that remains after scattering along \n  this path using the scattering profile. Due to symmetry, this can be done in 2D.\n*/\nvec3 integrateProfile(float angle, float r){\n\n    vec3 totalLight = vec3(0);\n    vec3 weight = vec3(0);\n\n    // Higher count gives more accurate results\n    const float STEPS = 512.0;\n    float delta = TWO_PI / STEPS;\n\n    // Sample points in a circle\n    for(float theta = float(min(0, iFrame)); theta < TWO_PI; theta += delta){\n\n        /*\n          The distance that light travels from the sample point to the evaluated point\n          is the length of the chord between these two points. This assumes light travels \n          straight and does not scatter multiple times. This is the formula for a chord\n          length of a circle given an angle and a radius.\n          https://en.wikipedia.org/wiki/Chord_(geometry)\n        */\n        float dist = 2.0 * r * sin(0.5 * theta);\n        \n        // The amount of light that remains while travelling from the sample point\n        // to the evaluated point is determined by the scattering profile.\n        vec3 scattering = getProfile(dist);\n\n        // The amount of light at the sample point is determined by its normal in relation\n        // to the incoming light direction - the diffuse Lambertian term.\n        totalLight += max(0.0, cos(angle + theta)) * scattering;\n        \n        // Accumulate the light contribution to normalize the integral\n        weight += scattering;\n    }\n    \n    // Return normalized integral of all incoming light at the evaluation point.\n    return totalLight / weight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    bool resolutionChanged = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).r > 0.0;\n    \n    if(iFrame == 0 || resolutionChanged){\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n        vec3 col = integrateProfile(PI - uv.x * PI, 1.0 / uv.y);\n        fragColor = vec4(col, 1.0);\n    }else{\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    Ray march geometry and write normal to RGB and depth to A for recontruction and shading\n    in Image tab.\n    \n    Only renders when camera position has moved or the resolution has changed.\n*/\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(iFrame,0))\n\nconst int MAX_STEPS = 64;\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 1e-4;\n\nconst float AABBLimit = 0.001;\n\n//---------------------------- Part functions ----------------------------\n\n// https://www.youtube.com/watch?v=AGNBb8u38gc&t=18s\nfloat getMouthSDF(vec3 p, float dist){\n    // Mouth mound\n    vec3 q = p;\n    q.x += 0.8;\n    q.y += 0.775;\n    q = rotateZ(q, -0.15);\n    dist = opSmoothMin(sphereSDF(q, 0.1), dist, 0.25);\n        \n    // Gap between lips\n    q = p;\n    q.x += 0.72;\n    q.y += 0.85;\n    q = rotateY(q, PI * 0.5);\n    q = rotateX(q, PI * -0.475);\n    float an = 0.95;\n    dist = opSmoothSub(sdCappedTorus(q, vec2(sin(an), cos(an)), 0.25, 0.001), dist, 0.05);\n  \n    // Top lip\n    q = p;\n    q.x += 0.7;\n    q.y += 0.81;\n    q = rotateZ(q, -0.6);\n    dist = opSmoothMin(sdEllipsoid(q, vec3(0.1, 0.25, 0.2)), dist, 0.1);\n    \n    q = p;\n    q.x += 0.74;\n    q.y += 0.82;\n    q = rotateZ(q, -0.65);\n    dist = opSmoothMin(sdEllipsoid(q, vec3(0.075, 0.25, 0.225)), dist, 0.035);\n  \n    // Depression below bottom lip\n    q = p;\n    q.x += 1.085;\n    q.y += 1.05;\n    q = rotateZ(q, PI * 0.15);\n    q = rotateY(q, PI * 0.5);\n    float am = 1.5;\n    dist = opSmoothSub(sdCappedTorus(q, vec2(sin(am), cos(am)), 0.15, 0.015), dist, 0.1);\n    \n  \n    // Bottom lip\n    q = p;\n    q.x += 0.74;\n    q.y += 0.79;\n    q = rotateZ(q, 0.55);\n    dist = opSmoothMin(sdEllipsoid(q, vec3(0.1, 0.25, 0.2)), dist, 0.025);\n    \n    // Philtrum\n    q = p;\n    q.x += 0.925;\n    q.y += 0.7;\n    q = rotateZ(q, 0.0);\n    dist = opSmoothMin(sdCapsule(q, 0.025, 0.0125), dist, 0.1);\n    \n    q = p;\n    q.x += 1.0125;\n    q.y += 0.7;\n    q = rotateZ(q, 0.0);\n    dist = opSmoothSub(sdRoundCone(q, 0.025, 0.0125, 0.025), dist, 0.05);\n    \n    return dist;\n}\n\nfloat getNoseSDF(vec3 p, float dist){\n\n    p.x -= 0.01;\n\n    // Nose\n    vec3 q = p;\n    q.x += 1.1;\n    q.y += 0.52;\n    q = rotateZ(q, 0.24);\n    dist = opSmoothMin(sdRoundCone(q, 0.05, 0.005, 0.5), dist, 0.1);\n    \n    q = p;\n    q.x += 0.9;\n    q.y += 0.32;\n    q = rotateZ(q, 0.175);\n    q.y += 0.2;\n    dist = opSmoothMin(sdRoundCone(q, 0.075, 0.01, 0.25), dist, 0.125);\n    \n    // Nostrils\n    q = p;\n    q.z = abs(q.z);\n    q.x += 0.98;\n    q.y += 0.58;\n    q.z -= 0.085;\n    q = rotateZ(q, -0.65);\n    q = rotateX(q, 0.7);\n    dist = opSmoothMin(sdRoundCone(q, 0.065, 0.075, 0.1), dist, 0.02);\n    \n    // Septum\n    q = p;\n    q.x += 1.0;\n    q.y += 0.63;\n    q = rotateZ(q, -0.45);\n    dist = opSmoothMin(sdRoundCone(q, 0.05, 0.07, 0.12), dist, 0.03);\n\n    // Holes\n    q = p;\n    q.z = abs(q.z);\n    q.x += 1.05;\n    q.y += 0.64;\n    q.z -= 0.08;\n    q = rotateZ(q, -0.65);\n    q = rotateX(q, 0.7);\n    dist = opSmoothSub(sdRoundCone(q, 0.01, 0.015, 0.05), dist, 0.025);\n    \n    \n    q = p;\n    q.z = abs(q.z);\n    q.x += 1.03;\n    q.y += 0.61;\n    q.z -= 0.07;\n    q = rotateZ(q, -0.78);\n    q = rotateX(q, 0.7);\n    dist = opSmoothSub(sdCapsule(q, 0.015, 0.07), dist, 0.02);\n\n\n    // Lower septum\n    q = p;\n    q.x += 1.07;\n    q.y += 0.62;\n    q = rotateZ(q, -0.5);\n    dist = opSmoothMin(sdCapsule(q, 0.03, 0.03), dist, 0.04);\n    \n    return dist;\n}\n\nfloat getNeckSDF(vec3 p) {\n\n    vec3 q = p;\n    float d = 1e12;\n    q.x -= 0.05;\n    q.y += 1.3;\n    q = rotateZ(q, -0.02);\n    d = sdRoundCone(q, 0.525, 0.5, 1.5);\n    \n    q = p;\n    q.x += 0.45;\n    q.y += 1.5;\n    q = rotateZ(q, 0.1);\n    d = opSmoothSub(sdRoundCone(q, 0.3, 0.42, 0.55), d, 0.15);\n    \n    \n    q = p;\n    q.x += 0.05;\n    q.y += 1.5;\n    q = rotateZ(q, -0.2);\n    d = opSmoothMin(sdCapsule(q, 0.3, 0.5), d, 0.25);\n    \n    return d;\n}\n\nfloat getEarSDF(vec3 p) {\n\n    float d = 1e12;\n    /*\n        The ear was modelled in a separate shader with different coordinates and we need to \n        orient and scale it to fit the scene. Incidentally, modelling ears with distance\n        functions made me almost lose my actual mind. Way too much time was spent staring at\n        people in the street, trying to figure out what an ear looks like. \n        They are not perfect but, whatever, I tried.\n    */\n    p.xyz = p.zyx;\n    p.z *= -1.0;\n    \n    // Positioning\n    p.x = abs(p.x);\n    p.x -= 0.66;\n    p.y += 0.345;\n    p.z -= 0.13;\n    \n    // Stretch the ear to fit the head better\n    p *= vec3(0.6, 0.6, 0.65);\n    \n    // Warp centre of ear inward to give it a 3D rather than a planar look\n    p.x += mix(0.0, 0.055, smoothstep(0.065, 0.0, length(p.yz-vec2(-0.065, 0.055))));\n    \n    // Orient\n    p = rotateX(p, 0.25);\n    p = rotateZ(p, 0.125);\n    p = rotateY(p, 0.525);\n\n    // Orient some more\n    p = rotateZ(p, PI * 0.025);\n    \n    vec3 q = p;\n\n    // Helix and main plane makes up the main shape\n    q.y -= 0.015;\n    d = sphereSDF(q, 0.11);\n\n    q = p;\n    q.y += 0.13;\n    q.z -= 0.02;\n    d = opSmoothMin(sphereSDF(q, 0.055), d, 0.15);\n    \n    q = p;\n    q.x -= 0.11;\n    q.y -= 0.015;\n    float hollow = sphereSDF(q, 0.105);\n    \n    q = p;\n    q.x -= 0.14;\n    q.y += 0.13;\n    q.z -= 0.04;\n    hollow = opSmoothMin(sphereSDF(q, 0.07), hollow, 0.15);\n    \n    q = p;\n    q.x -= 0.11;\n    hollow = opSmoothIntersection(hollow, sdBox(q, vec3(0.075, 0.25, 0.15)), 0.005);\n    \n    d = opSmoothSub(hollow, d, 0.02);\n    \n    // Flatten to a plane\n    q = p;\n    q.x -= 0.055;\n    d = opSmoothIntersection(d, sdBox(q, vec3(0.04, 0.25, 0.15)), 0.035);\n    \n    // Rotation for central geometry\n    p = rotateX(p, 0.1);\n    p = rotateZ(p, PI * -0.025);\n    p = rotateY(p, PI * -0.025);\n    \n    // Antihelix\n    float rot = 0.035;\n    p.y -= 0.025;\n    p = rotateY(p, PI * -rot);\n    float middle = 1e10;\n    \n    // Two large spheres make up the central shape\n    q = p;\n    q.y += 0.02;\n    q.z += 0.01;\n    q.x += 0.075;\n    middle = sphereSDF(q, 0.145);\n    \n    q = p;\n    q.x += 0.015;\n    q.y += 0.08;\n    q.z -= 0.01;\n    middle = opSmoothMin(sphereSDF(q, 0.1), middle, 0.015);\n    \n    // Triangular fossa (top depression)\n    q = p;\n    q.x -= 0.04;\n    q.y += 0.125;\n    q.z -= 0.09;\n    q = rotateY(q, PI * 0.67);\n    float an = 0.5*PI;\n    middle = opSmoothSub(sdCappedTorus(q, vec2(sin(an), cos(an)), 0.15, 0.02), middle, 0.01);\n\n    // Concha (central hollow)\n    q = p;\n    q.x -= 0.04;\n    q.z -= 0.045;\n    q.y += 0.08;\n    middle = opSmoothSub(sphereSDF(q, 0.05), middle, 0.06);\n    \n    q = p;\n    q.x -= 0.04;\n    q.z -= 0.0;\n    q.y += 0.085;\n    middle = opSmoothSub(sphereSDF(q, 0.0025), middle, 0.065);\n    \n    // Lobe\n    q = p;\n    q.x -= 0.0;\n    q.z -= 0.01;\n    q.y += 0.18;\n    middle = opSmoothMin(sphereSDF(q, 0.03), middle, 0.04);\n  \n    q = p;\n    q = rotateY(q, 0.2);\n    q = rotateZ(q, 0.1);\n    q.x -= 0.105;\n    q.y -= 0.045;\n    q.z += 0.005;\n    middle = opSmoothIntersection(middle, sdBox(q, vec3(0.075, 0.3, 0.19)), 0.01);\n\n    p.y += 0.025;\n    d = opSmoothMin(middle, d, 0.005);\n    \n    // Ear back\n    q = p;\n    q.x -= 0.01;\n    q.y += 0.09;\n    q.z -= 0.02;\n    float back = sphereSDF(q, 0.06);\n\n    q.y -= 0.07;\n    back = opSmoothMin(sphereSDF(q, 0.06), back, 0.03);\n    \n    q = p;\n    q = rotateY(q, 0.2);\n    q = rotateZ(q, 0.1);\n    q.x -= 0.09;\n    back = opSmoothSub(sdBox(q, vec3(0.075, 0.25, 0.19)),back, 0.01);\n    \n    d = opSmoothMin(back, d, 0.025);\n    \n    return d;\n}\n\nfloat getSDF(vec3 p, vec3 dir){\n\n    float minStart = 1e10;\n    float start = 10e10;\n\n    vec3 originalPos = p;\n    \n    p.y -= 0.25;\n    p.x -= 0.2;\n    vec3 q = p;\n    q.xy += 0.015;\n    float dist = sphereSDF(q, 0.8);\n\n    // Far jaw limit\n    q = p;\n    q.x += 0.15;\n    q.y += 0.4;\n    q = opElongate(q, vec3(0., 0., -0.)).xyz;\n    float distCut = sdCapsule(q, 0.8, 0.25);\n    q = p;\n    q.x -= 0.85;\n    q.y += 0.9;\n    distCut = opSmoothSub(sdBox(q, vec3(1.0, 0.35, 1.0)), distCut, 0.5);\n    \n    dist = opSmoothMin(distCut, dist, 0.05);\n   \n    q = p;\n    q.x -= 0.45;\n    q.y += 1.3;\n    \n    \n    // Sides\n    q = p;\n    q.z = abs(q.z);\n    q.z -= 0.9;\n    q = rotateY(q, 0.2);\n    q = rotateX(q, -0.12);\n    dist = opSmoothSub(sdBox(q, vec3(3.0, 3.0, 0.1)), dist, 0.25);\n    \n    // Jowls\n    q = p;\n    q.z = abs(q.z);\n    q.x += 0.75;\n    q.y += 0.8;\n    q.z -= 0.5;\n    q = rotateX(q, -0.5);\n    q = rotateY(q, 0.6);\n    dist = opSmoothSub(sdBox(q, vec3(1.5, 1.55, 0.1)), dist, 0.1);\n    \n    // Forehead\n    q = p;\n    q.x += 0.55;\n    q.y -= 0.25;\n    q = rotateZ(q, 0.3);\n    q.z *= 0.85;\n    dist = opSmoothMin(sphereSDF(q, 0.2), dist, 0.52);\n    \n    if(testAABB(p, dir, vec3(-1.1, -0.6, -0.6), vec3(-0.7, 0.075, 0.6), start)){\n        if(start < AABBLimit){\n            // Eye sockets \n            q = p;\n            q.x += 0.85;\n            q.y += 0.255;\n            q.z -= 0.225;\n            dist = opSmoothSub(sphereSDF(q, 0.1), dist, 0.25);\n            q = p;\n            q.x += 0.85;\n            q.y += 0.255;\n            q.z += 0.225;\n            dist = opSmoothSub(sphereSDF(q, 0.1), dist, 0.25);\n            \n        }else{\n            minStart = min(minStart, start);\n        }\n    }\n    \n    // Cheekbones\n    q = p;\n    q.z = abs(q.z);\n    q.x += 0.725;\n    q.y += 0.43;\n    q.z -= 0.25;\n    q = rotateY(q, -0.3);\n    dist = opSmoothMin(sdEllipsoid(q, vec3(0.1, 0.1, 0.2)), dist, 0.15);\n  \n    // Inner corner\n    q = p;\n    q.z = abs(q.z);\n    q.x += 0.9;\n    q.y += 0.3;\n    q.z -= 0.125;\n    q = rotateZ(q, -0.2 * PI);;\n    q = rotateX(q, 0.2 * PI);\n    dist = opSmoothSub(sdRoundCone(q, 0.02, 0.05, 0.15), dist, 0.1);\n  \n    // Eye hood\n    q = p;\n    q.z = abs(q.z);\n    q.x += 0.72;\n    q.y += 0.25;\n    q.z -= 0.255;\n    q = rotateZ(q, PI * 0.3);\n    q = rotateY(q, PI * 0.45);\n    float an = PI;\n    dist = opSmoothMin(sdCappedTorus(q, vec2(sin(an), cos(an)), 0.12, 0.03), dist, 0.07);\n  \n    // Brow\n    q = p;\n    q.x += 0.75;\n    q.y += 0.215;\n    q.z += 0.235;\n    q = rotateZ(q, PI * 0.355);\n    q = rotateY(q, PI * -0.55);\n    an = PI;\n    dist = opSmoothMin(sdCappedTorus(q, vec2(sin(an), cos(an)), 0.165, 0.02), dist, 0.2);\n    \n    q = p;\n    q.x += 0.75;\n    q.y += 0.215;\n    q.z -= 0.235;\n    q = rotateZ(q, PI * 0.355);\n    q = rotateY(q, PI * 0.55);\n    an = PI;\n    dist = opSmoothMin(sdCappedTorus(q, vec2(sin(an), cos(an)), 0.165, 0.02), dist, 0.2);\n    \n   \n    \n    if(testAABB(p, dir, vec3(-1.1, -0.4, -0.5),vec3(-0.65, -0.15, 0.5), start)){\n        if(start < AABBLimit){\n            dist = getEyesSDF(p, dist);\n        }else{\n            minStart = min(minStart, start);\n        }\n    }\n    \n    // Lower cheeks\n    q = p;\n    q.z = abs(q.z);\n    q.x += 0.7;\n    q.y += 0.8;\n    q.z -= 0.2;\n    dist = opSmoothMin(sphereSDF(q, 0.025), dist, 0.22);\n    \n    // Upper cheeks\n    q = p;\n    q.z = abs(q.z);\n    q.x += 0.8;\n    q.y += 0.475;\n    q.z -= 0.0;\n    \n    q = rotateZ(q, 0.2);\n    q = rotateY(q, -0.5);\n    q = rotateX(q, -0.25);\n    dist = opSmoothMin(sdEllipsoid(q, vec3(0.1, 0.1, 0.15)), dist, 0.2);\n    \n    // Chin\n    q = p;\n    q.z *= 0.5;\n    q.x += 0.85;\n    q.y += 1.08;\n    q = rotateZ(q, 0.5);   \n    dist = opSmoothMin(sdCapsule(q, 0.025, 0.75), dist, 0.225);\n    \n    // Mouth\n    if(testAABB(p, dir, vec3(-1.1, -1.2, -0.5),vec3(-0.7, -0.45, 0.5), start)){\n        if(start < AABBLimit){\n            vec3 offset = vec3(0.02, 0.0, 0.0);\n            dist = getMouthSDF(p + offset, dist);\n        }else{\n            minStart = min(minStart, start);\n        }\n    }\n\n    // Nose\n    if(testAABB(p, dir, vec3(-1.2, -0.7, -0.2),vec3(-0.5, 0.0, 0.2), start)){ \n        if(start < AABBLimit){\n            vec3 offset = vec3(0.0, -0.015, 0.0);\n            dist = getNoseSDF(p + offset, dist);\n        }else{\n            minStart = min(minStart, start);\n        }\n    }\n    \n    // Ears\n    if(testAABB(vec3(p.x, p.y, abs(p.z)), dir, vec3(-0.4, -0.8, 0.5), vec3(0.1, 0.0, 1.1), start)){ \n        if(start < AABBLimit){\n            // Ear hole\n            q = p;\n            q.z = abs(q.z);\n            q.x += 0.2;\n            q.y += 0.45;\n            q.z -= 0.57;\n            dist = opSmoothSub(sphereSDF(q, 0.03), dist, 0.075);\n\n            float earDist = getEarSDF(p);\n            dist = opSmoothMin(earDist, dist, 0.01);\n\n            q = p;\n            q.z = abs(q.z);\n            q.x += 0.22;\n            q.y += 0.45;\n            q.z -= 0.55;\n            dist = opSmoothSub(sphereSDF(q, 0.01), dist, 0.05);\n\n            // Tragus\n            q = p;\n            q.z = abs(p.z);\n            q.x += 0.24;\n            q.y += 0.435;\n            q.z -= 0.625;\n            q = rotateY(q, PI * 0.2);\n            q = rotateZ(q, PI * -0.1);\n\n            float distTragus = sdRoundCone(q, 0.015, 0.03, 0.1);\n            q = p;\n            q.z = abs(p.z);\n            q.x += 0.24;\n            q.y += 0.455;\n            q.z -= 0.615;\n            q = rotateY(q, PI * 0.25);\n            q = rotateZ(q, PI * -0.35);\n            distTragus = opSmoothMin(sdRoundCone(q, 0.015, 0.03, 0.1), distTragus, 0.06);\n\n            dist = opSmoothMin(dist, distTragus, 0.035);\n\n            // Crus helix\n            q = p;\n            q.z = abs(p.z);\n            q.x += 0.19;\n            q.y += 0.3125;\n            q.z -= 0.655;\n            q = rotateY(q, PI * 0.03);\n            q = rotateX(q, PI * -0.05);\n            float an = PI;\n            dist = opSmoothMin(sdCappedTorus(q, vec2(sin(an), cos(an)), 0.075, 0.01), dist, 0.025);\n        }else{\n            minStart = min(minStart, start);\n        }\n    }\n    \n    // Lower jaw limit\n    q = p;\n    q.y += 1.15;\n    q = rotateZ(q, -0.225);\n    q.x += 0.45;\n    dist = opSmoothSub(sdBox(q, vec3(0.5, 0.3, 1.5)), dist, 0.1);\n    \n    // Neck\n    float neckDist = getNeckSDF(p);\n    dist = opSmoothMin(neckDist, dist, 0.075);\n    \n    q = p;\n    dist = opSmoothMin(collarSDF(q), dist, 0.0);\n    \n    q = p;\n    q.y += 1.725;\n    q = rotateZ(q, -0.2);\n    q.x += 0.45;\n    dist = opSmoothSub(sdBox(q, vec3(3.5, 0.4, 3.5)), dist, 0.0);\n\n    q = p;\n    dist = opSmoothMin(getEyeballSDF(q), dist, 0.0025);\n    \n    \n    return min(minStart, dist);\n}\n\nfloat distanceToScene(const vec3 cameraPos, const vec3 rayDir, const float start, const float end){\n\t\n    float s;\n    if(!testAABB(cameraPos, rayDir, vec3(-1.0, -1.4, -1.0),vec3(1.0, 1.2, 1.0), s)){\n        return MAX_DIST;\n    }\n    \n    // Start at a predefined distance from the camera in the ray direction\n    float depth = start;\n    \n    // Variable that tracks the distance to the scene at the current ray endpoint\n    float dist;\n   \n    // For a set number of steps\n    for (int i = ZERO; i < MAX_STEPS; i++) {\n        \n        // Get the sdf value at the ray endpoint, giving the maximum \n        // safe distance we can travel in any direction without hitting a surface\n        dist = getSDF(cameraPos + depth * rayDir, rayDir);\n    \n        // If it is small enough, we have hit a surface\n        // Return the depth that the ray travelled through the scene\n        if (dist < EPSILON){\n            return depth;\n        }\n        \n        // Else, march the ray by the sdf value\n        depth += 0.98*dist;\n        \n        // Test if we have left the scene\n        if (depth >= end){\n            return end;\n        }\n    }\n\n    return depth;\n}\n\n\n// Tetrahedral normal technique with a loop to avoid inlining getSDF()\n// This should improve compilation times\n// https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p, vec3 rayDir){\n    vec3 n = vec3(0.0);\n    for(int i = ZERO; i < 4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*getSDF(p+e*EPSILON, rayDir);\n    }\n    return normalize(n);\n}\n\n//----------------------------- Output ------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    bool resolutionChanged = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).r > 0.0;\n    bool fovChanged = texelFetch(iChannel0, ivec2(0.5, 4.5), 0).x > 0.0;\n\n    if(iFrame < 2 || iMouse.z > 0.0 || resolutionChanged || fovChanged){\n    \n        //----------------- Define a camera -----------------\n\n        vec3 rayDir = rayDirection(FOV, fragCoord, iResolution.xy);\n\n        vec3 cameraPos = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n\n        vec3 targetDir = -cameraPos;\n        vec3 up = vec3(0.0, 1.0, 0.0);\n\n        // Get the view matrix from the camera orientation.\n        mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n        // Transform the ray to point in the correct direction.\n        rayDir = normalize(viewMatrix * rayDir);\n\n        //---------------------------------------------------\n\n        // Find the distance to where the ray stops.\n        float dist = distanceToScene(cameraPos, rayDir, MIN_DIST, MAX_DIST);\n        vec3 col = vec3(0);\n        if(dist < MAX_DIST){\n            vec3 position = cameraPos + rayDir * dist;\n            col = getNormal(position, rayDir);\n        }\n\n        fragColor = vec4(col, dist);\n    }else{\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"/*\n    R: Lip detail\n    G: Lip map\n    B: Eyebrow height map\n    \n    Rendered only on start or resolution change.\n*/\n\n// Variable iterator initializer to stop loop unrolling\n#define ZERO (min(float(iFrame),0.0))\n\n#define EYEBROW_COUNT 1024.0\n\nvec2 rotate(vec2 p, float a){\n    return mat2(cos(a), sin(a), -sin(a), cos(a)) * p;\n}\n\nfloat sdCircle( vec2 p, float r ){\n    return length(p) - r;\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h ){\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n//https://www.shadertoy.com/view/MlKcDD\n//Signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0){ \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }else{\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\nfloat mouthLine(vec2 pos){\n\n    const int N = 6;\n    vec2 points[N];\n    pos.y += 0.002;\n    points[0] = vec2(-0.225, -0.27);\n    points[1] = vec2(-0.07, -0.2075);\n    points[2] = vec2(-0.0, -0.21);\n    points[3] = vec2(0.07, -0.2075);\n    points[4] = vec2(0.29, -0.3);\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n    float dist = 1e10;\n    for(int i = 0; i < N-2; i++){\n        c_prev = c;\n        c = (points[i] + points[min(i+1, N-1)]) / 2.0;\n        dist = min(dist, sdBezier(pos, c_prev, points[i], c));\n    }\n    return dist;\n}\n\n#define SIZE 1024\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash(vec2 p){\n    p = mod(p, float(SIZE));\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return 2.0 * fract((p3.xx+p3.yz)*p3.zy) - 1.0;\n}\n\nfloat hash(float p){\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nfloat getEyebrowHeight(vec2 pos, float id){\n\n    vec2 o = pos;\n\n    float r = mix(0.0035, 0.0055, smoothstep(0.0, 0.35, float(id)/512.0) * smoothstep(1.0, 0.85, id/EYEBROW_COUNT));\n    \n    float rand = hash(float(id));\n    \n    pos.y -= mix(0.1, 0.2, saturate(id/(0.25*EYEBROW_COUNT))) * rand;\n    float angle = PI * mix(0.3, 0.65, hash(id));\n    \n    angle *= mix(0.25, 1.0, saturate(id/(0.25*EYEBROW_COUNT)));\n    pos = rotate(pos, angle);\n\n    const int N = 4;\n    vec2 points[N];\n    points[0] = vec2(0.0, 0.0);\n    points[1] = vec2(mix(-0.025, 0.025, hash(float(id + 23.0))), 0.2);\n    points[2] = vec2(0.1, 0.35);\n    points[3] = vec2(0.1, 0.35);\n    \n    vec2 c = (points[0] + points[1]) / 2.0;\n    vec2 c_prev;\n    float dist = 1e10;\n    for(int i = 0; i < N-2; i++){\n        c_prev = c;\n        c = (points[i] + points[i+1]) / 2.0;\n        dist = min(dist, sdBezier(pos, c_prev, points[i], c));\n    }\n    \n    \n    float t = dist / r;\n    float z = sqrt(1.0-t*t) * r;\n    z *= smoothstep(r, 0.999*r, dist);\n    z *= mix(0.5, 1.0, hash(float(id+2.0)));\n    z *= 3.0*smoothstep(0.0, 0.2, pos.y)*smoothstep(0.2, 0.0, pos.y);\n\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    bool resolutionChanged = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).r > 0.0;\n    \n    if(iFrame == 0 || resolutionChanged){\n        vec2 uv = fragCoord / iResolution.xy;\n\n        vec2 p = uv;\n        p -= 0.5;\n\n        vec2 q = p;\n        q.y += 0.18;\n\n        float mouthDist = mouthLine(q);\n        float h = 0.0;\n\n        q = p;\n        q.x = abs(q.x);\n        q.x += smoothstep(mix(0.075, 0.025, smoothstep(0.2, 0.0, abs(p.x))), -0.7, mouthDist);\n\n        float lipNoise = 0.25 * pow(abs(sin(175.0*q.x)), 0.25);\n\n        float lips = lipNoise * smoothstep(mix(0.005, 0.05, smoothstep(0.2, 0.05, abs(p.x))), -0.75, mouthDist);\n        lips -= 100.0*smoothstep(0.0025, -1.5, mouthDist);\n        h = saturate(lips);\n        float d = ((1.0-lipNoise)*smoothstep(mix(0.005, 0.075, smoothstep(0.2, 0.05, abs(p.x))), mix(-0.1, -0.02, smoothstep(0.2, 0.0, abs(p.x))), mouthDist));\n\n        q = uv;\n        q -= 0.5;\n        q += vec2(0.5, 0.175);\n        float eyebrowHeight = 0.0;\n        q.x -= 0.125;\n        q.y -= 0.015;\n        for(float i = ZERO; i < EYEBROW_COUNT; i++){\n            eyebrowHeight = max(eyebrowHeight, getEyebrowHeight(q, i));\n            q.x -= mix(0.5*0.0005, 0.5*0.002, i/EYEBROW_COUNT);\n            q.y += mix(0.65*-0.0006, 0.65*0.00045, i/EYEBROW_COUNT);\n        }\n        \n       \n        fragColor = vec4(saturate(h), saturate(1.0-d), eyebrowHeight, 0.0);\n    \n    }else{\n        fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    }\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}