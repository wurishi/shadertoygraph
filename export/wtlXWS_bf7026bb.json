{"ver":"0.1","info":{"id":"wtlXWS","date":"1566466662","viewed":282,"name":"psychedelic voxel tornade","username":"takumifukasawa","description":"psychedelic tornade box","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel","wireframe","color","voxel","palette","psychedelic","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------------------------------------\n// # refs\n// ## repeat, mod, pmod\n// - https://qiita.com/kaneta1992/items/21149c78159bd27e0860#ifs%E3%81%AB%E3%82%88%E3%82%8B%E8%A4%87%E9%9B%91%E3%81%AA%E5%BD%A2%E7%8A%B6\n// - https://qiita.com/edo_m18/items/8c20c9c80d44e8b1dfe4#_reference-7c25132332209c2cd12e\n// - https://gam0022.net/blog/2017/03/02/raymarching-fold/\n// ## collor pallete\n// - https://www.shadertoy.com/view/ll2GD3\n// ## material mechanism\n// - https://www.shadertoy.com/view/ldlcRf\n// ## distance functions, fog ... \n// - https://iquilezles.org/www/index.htm\n//------------------------------------------------------------------------\n\nprecision highp float;\n\n#define EPS .0001\n#define PI 3.1415\n#define PI2 PI * 2.\n#define repeat(p, o) mod(p, o) - o * .5\n#define saturate(a) clamp(a, 0., 1.)\n\n// ref: https://www.shadertoy.com/view/ldlcRf\n#define TEST_MAT_LESS (a, b) a < (b + .1)\n#define TEST_MAT_GREATER (a, b) a > (b - .1)\n\nconst float stopThreshold = .0001;\n\nstruct Light {\n\tvec3 position;\n  \tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n};\n    \nstruct Surface {\n  \tfloat depth;\n  \tfloat dist;\n  \tvec3 position;\n  \tvec3 baseColor;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n  \tfloat material;\n};  \n\n// init lights\nLight directionalLight;    \nLight pointLight;\n\n// ref: https://www.shadertoy.com/view/ldlcRf\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n// ref: https://www.shadertoy.com/view/WllSDM\nfloat n3(vec3 p) {\n\tvec3 r = vec3(1, 99, 999);\n\tvec4 s = dot(floor(p), r) + vec4(0., r.yz, r.y + r.z);\n\tp = smoothstep(0., 1., fract(p));\n\tvec4 a = mix(fract(sin(s) * 5555.), fract(sin(s + 1.) * 5555.), p.x);\n\tvec2 b = mix(a.xz, a.yw, p.y);\n\treturn mix(b.x, b.y, p.z);\n}\n    \n// ref: https://www.shadertoy.com/view/ll2GD3\n// t: 0-1, a: contrast, b: brightness, c: times, d: offset\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\n// d1 subtract to d2\nfloat opSub(float d1, float d2) {\n\treturn max(-d1, d2);\n}\n\nfloat smin(float a, float b, float k) {\n  float res = exp(-k * a) + exp(-k * b);\n  return -log(res) / k;\n}\n\nfloat sdWireBox(vec3 p, float s, float b) {\n    float d = 0.;\n    float o = s + .5;\n    float i = s - b;\n    d = opSub(\n        sdBox(p, vec3(o, i, i)),\n        sdBox(p, vec3(s))\n    );\n    d = opSub(\n        sdBox(p, vec3(i, o, i)),\n\t\td\n    );\n    d = opSub(\n        sdBox(p, vec3(i, i, o)),\n\t\td\n    );\n        \n    return d;\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = atan(p.x, p.y) + PI / r;\n    float n = PI * 2. / r;\n    a = floor(a / n) * n;\n    return p * rot(-a);\n}\n\nvec2 tunnel(vec3 p) {    \n    float d = 0.;\n    vec3 _p = p;\n    vec3 q = p;\n    float m = 0.;\n    \n    float scale = 2.6;\n    float scalePower = .6;\n    vec3 size = vec3(1.1);\n    \n    float repeatNum = 9.;\n\n    vec3 id = floor(_p / repeatNum);\n    \n    float openSpeed = mod(iTime * 1.8 + PI2 * .8, PI2);\n    \n    float border = .15 + sin(openSpeed) * .11;\n    \n    d = 100000.;\n    \n    vec2 obj = vec2(d, 1.);\n\n    _p.z = repeat(_p.z, .8);\n    \n\t_p.xy = pmod(_p.xy, 5.);\n\n    for(int i = 0; i < 2; i++) {\n        _p.y -= size.y;\n\n        p.xz *= rot(.08);\n        p.xy *= rot(mod(iTime * .8, PI2));\n        \n        float currentDist = 0.;\n        currentDist = sdWireBox(p, .22 * size.y, border * size.y);\n        \n\t\tvec2 currentObj = vec2(currentDist, float(i) + 1.);\n        m = minMat(obj, currentObj).y;\n        obj.x = min(obj.x, currentObj.x);\n        obj.y = m;\n\t\t\n        scale *= scalePower;\n        \n        p = _p;\n        size *= scale;\n    }\n    \n    return vec2(obj.x, m);\n}\n\n\nvec3 opTwist(vec3 p) {\n    float k = .75;\n    vec3 q = p;\n    q.xy *= rot(mod(k * p.z + iTime * .35, PI2));\n    return q;\n}\n\n\nvec2 scene(vec3 p) {\n    vec3 move = vec3(0., 0., -iTime) * 1.8;\n    vec2 d = vec2(0.);\n    vec3 _p = p + move;\n    _p = opTwist(_p);\n    d = tunnel(_p);\n    \n    return d;\n}\n\nmat3 camera(vec3 o, vec3 t, vec3 u) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, u);\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nvec3 getNormal(vec3 p, float eps) {\n    vec2 e = vec2(eps, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nfloat getSpecular(vec3 position, vec3 normal, Light light, float diffuse, vec3 cameraPos) {\n  \tvec3 lightDir = light.position - position;\n  \tvec3 ref = reflect(-normalize(lightDir), normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - normal)));\n    \tfloat specularPower = 64.;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nfloat calcRim(float NoL, float NoE, float EoL, float eyeCoef, float lightCoef) {\n    float rimEyeCoef = pow(saturate(1. - saturate(NoE)), eyeCoef);\n    float rimLightCoef = pow(EoL, lightCoef);\n    float rim = saturate(rimEyeCoef * rimLightCoef);\n    return rim;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \t// diffuse\n    float NoL = dot(surface.normal, normalize(light.position));\n    float EoL = dot(\n        normalize(cameraPos - surface.position),\n        normalize(light.position - surface.position)\n    );\n    float NoE = dot(\n    \tnormalize(cameraPos - surface.position),\n        surface.normal\n    );\n    \n  \tfloat diffuseCoef = saturate(NoL);\n  \tvec3 diffuse = diffuseCoef * light.color * light.intensity;    \n    diffuse += calcRim(NoL, NoE, EoL, 4., 32.) * light.intensity * light.color;\n    \n    // specular\n  \tfloat specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n  \tvec3 specular = vec3(specularCoef * light.color * light.intensity);  \n    \n  \tlight.diffuse = diffuse;\n  \tlight.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n\tvec3 lightDir = normalize(light.position - surface.position);\n    float attenuation = saturate(1. / pow(distance(light.position, surface.position), 2.));\n    \n    float NoL = saturate(dot(surface.normal, lightDir));\n    float EoL = dot(\n        normalize(cameraPos - surface.position),\n        lightDir\n    );\n    float NoE = dot(\n    \tnormalize(cameraPos - surface.position),\n        surface.normal\n    );\n\n    float diffuseCoef = NoL;\n    vec3 diffuse = diffuseCoef * attenuation * light.color * light.intensity;\n    diffuse += calcRim(NoL, NoE, EoL, 4., 32.) * light.intensity * attenuation * light.color;    \n    \n    float specularCoef = getSpecular(surface.position, surface.normal, light, diffuseCoef, cameraPos);\n    vec3 specular = vec3(specularCoef * attenuation * light.color * light.intensity);\n        \n    light.diffuse = diffuse;\n    light.specular = specular;\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos, vec3 rd) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n    calcDirectionalLight(directionalLight, surface, cameraPos);\n\tcalcPointLight(pointLight, surface, cameraPos);\n\n  \tvec3 diffuse = directionalLight.diffuse + pointLight.diffuse;\n  \tvec3 specular = directionalLight.specular + pointLight.specular;;\n    \n  \tvec3 ambient = vec3(1.) * .1;\n\n  \tcolor = surface.baseColor * (diffuse + specular + ambient);  \n  \n  \treturn color;\n}\n\nvec3 fog(vec3 color, float distance, vec3 fogColor, float b) {\n  \tfloat fogAmount = 1. - exp(-distance * b);\n  \treturn mix(color, fogColor, fogAmount);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 move = vec3(0., 0., -iTime) * 0.;\n    vec3 ro = vec3(cos(iTime * 1.9) * .03, sin(iTime * 1.6 + .4) * .05, -4.) + move;\n    vec3 target = vec3(cos(iTime * .9 + .2) * .3, sin(iTime * .5) * .3, -8.) + move/* + vec3(mouse * 1., 0.)*/;\n    \n    \n    float fov = 1.2;\n    \n    vec3 up = vec3(0., 1., 0.);\n    vec3 rd = camera(ro, target, up) * normalize(vec3(uv, fov));\n    \n    // raymarching\n    float depth = 0.;\n    float dist = 0.;\n    vec2 result = vec2(0.);\n    for(int i = 0; i < 99; i++) {\n    \tresult = scene(ro + rd * depth);\n        dist = result.x;\n        if(dist < stopThreshold) {\n            break;\n        }\n        depth += result.x;\n    }   \n    \n    vec3 color = vec3(0.);\n   \n    vec3 position = ro + rd * depth;\n    vec3 normal = getNormal(position, .001);\n    \n    Surface surface;\n    surface.depth = depth;\n    surface.dist = dist;\n    surface.position = position;\n    surface.normal = normal;\n    surface.material = result.y;\n    \n\tvec3 sceneColor = vec3(0.);\n    \n    vec3 bgColor = vec3(.08,  .05, .09);\n \n\tdirectionalLight.position = vec3(0., 0., 1.);\n\tdirectionalLight.intensity = .5;\n\tdirectionalLight.color = vec3(.8, .8, 1.);\n\n\tpointLight.position = vec3(0., 0., -4.2) + move;\n\tpointLight.intensity = .4;\n\tpointLight.color = vec3(.8, .8, 1.);\n    \n    if(dist >= stopThreshold) {\n\t    // no hit\n        sceneColor = bgColor;\n    } else {\n\t    // hit\n\t    surface.baseColor = palette(\n            /*surface.position.x / 10.\n                + surface.position.y / 10.\n\t            + */(surface.position.z - iTime * 1.4) / 1.2,\n        \tvec3(.9),\n        \tvec3(.6),\n        \tvec3(.2),\n        \tvec3(.4, .9, 1.)    \n    \t);\n        sceneColor = lighting(surface, ro, rd);           \n    }\n\n    // fog\n    sceneColor = fog(sceneColor, depth, bgColor, .2);\n\t// vignet\n    sceneColor *= smoothstep(1.6, .35, length(uv.xy));\n    \n    fragColor = vec4(sceneColor, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}