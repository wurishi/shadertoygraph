{"ver":"0.1","info":{"id":"3ssBzM","date":"1587943529","viewed":128,"name":"Pinwheel Tiling KIFS","username":"notfancy","description":"A variation on https://www.shadertoy.com/view/tdlBz4 with a different implementation using iterated inverse transforms. Each tile is colored with the barycentric coordinates of the point inside the containing tile, interpreted as an RGB value.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["kifs","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/tdlBz4 is the combinatorial version of this shader\n\n#define NITERS 5\n\n/*\n * PQR is the 1:2:√5 triangle with right angle at the origin,\n * subdivided in 5 tiles as follows:\n *\n * P=(0,1)                                      (2,1)\n * +------------------------------------------------+\n * |\\__                                             |\n * |   \\____U=(2/5,4/5)                             |\n * |       /\\_____                                  |\n * |  1   /  \\_   \\____                             |\n * |     /     \\_      \\____                        |\n * |  V /   3    \\_         \\____T=(6/5,2/5)        |\n * |   /\\__        \\_    4      /\\____              |\n * |  /    \\____     \\_        /      \\_____        |\n * | /   2      \\___   \\_     /    5        \\____   |\n * |/               \\____\\_  /                   \\__|\n * +-----------------------\\/-----------------------+\n * Q=(0,0)               S=(1,0)              R=(2,0)\n *\n * V=(1/5,2/5)\n *\n * The lines are defined by the following homogeneous equations:\n *\n * PR:   x + 2*y - 2 == 0\n * QU: 2*x -   y     == 0\n * SV:   x + 2*y - 1 == 0\n * SU: 4*x + 3*y - 4 == 0\n * ST: 2*x -   y - 2 == 0\n *\n * Semispace tests determine to which tile does the input point belong.\n * Each semispace is then scaled, rotated, reflected and translated so\n * that the tile transforms back to the base 1:2:√5 triangle PQR.\n */\nfloat PR(in vec2 p) { return dot(p, vec2(1.,  2.)) - 2.; }\nfloat QU(in vec2 p) { return dot(p, vec2(2., -1.));      }\nfloat ST(in vec2 p) { return dot(p, vec2(2., -1.)) - 2.; }\nfloat SU(in vec2 p) { return dot(p, vec2(4.,  3.)) - 4.; }\nfloat SV(in vec2 p) { return dot(p, vec2(1.,  2.)) - 1.; }\n\n/*\n * Let\n *   R(𝜗) = mat2(cos(𝜗), sin(𝜗), -sin(𝜗), cos(𝜗))\n * be the rotation matrix for angle 𝜗, and\n *   Y = mat2(+1, 0, 0, -1)\n * be the reflection matrix across the Y axis. Then:\n *\n * - T0 = T1 * √5*Y*R(atan(+2, -1))  + ( 2,  0)\n * - T0 = T2 * √5*Y*R(atan(+1, +2))  + ( 0,  1)\n * - T0 = T3 * √5*  R(atan(+1, +2))  + ( 0, -1)\n * - T0 = T4 * √5*  R(atan(-1, -2))  + ( 2,  2)\n * - T0 = T5 * √5*Y*R(atan(+1, +2))  + (-2,  2)\n */\nvec2 T0(in vec2 p) { return vec2(2., 1.) - p; }\nvec2 T1(in vec2 p) { return p*mat2(-1., -2., -2., +1.) + vec2( 2.,  0.); }\nvec2 T2(in vec2 p) { return p*mat2(+2., -1., -1., -2.) + vec2( 0.,  1.); }\nvec2 T3(in vec2 p) { return p*mat2(+2., -1., +1., +2.) + vec2( 0., -1.); }\nvec2 T4(in vec2 p) { return p*mat2(-2., +1., -1., -2.) + vec2( 2.,  2.); }\nvec2 T5(in vec2 p) { return p*mat2(+2., -1., -1., -2.) + vec2(-2.,  2.); }\n\n/*\n * Inverting the matrices, we see how each tile results from transforming\n * the base triangle:\n * - T1 == (T0 - ( 2,  0))*R(atan(-2, -1))*Y/√5\n * - T2 == (T0 - ( 0,  1))*R(atan(-1, +2))*Y/√5\n * - T3 == (T0 - ( 0, -1))*R(atan(-1, +2))  /√5\n * - T4 == (T0 - ( 2,  2))*R(atan(+1, -2))  /√5\n * - T5 == (T0 - (-2,  2))*R(atan(-1, +2))*Y/√5\n *\n * Modulo π/2 and discounting reflections, each tile gets rotated with\n * respect to the parent triangle by one of two possible angles:\n * - T1, T2, T5, by atan(0.5)\n * - T3, T4,     by atan(2)\n * and clearly both angles are complementary.\n */\nconst float A = 0.2951672353; // atan(0.5) / (0.5*PI)\n\n// See http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(in vec3 hsv)\n{\n    vec3 hue = clamp(abs(6.*fract(hsv.xxx + vec3(0.,2./3.,1./3.)) - 3.) - 1., 0., 1.);\n    return hsv.z * mix(vec3(1.), hue, hsv.y);\n}\n\n// PRE 0 <= p.x < 2 && 0 <= p.y < 1\nvec3 pinwheel(in vec2 p, in int n)\n{\n    float a = 0.; // Accumulated rotation angle as a fraction of π/2\n    float h = 0.; // Hash, or sequence of triangles in the subdivision\n\n    // Reflect upper right triangle into the lower left one\n    if (PR(p) > 0.) {\n\t\tp = T0(p);\n        h = 0.5;\n    }\n\n    // Find tile and inverse transform the point\n    for (int i = 0; i < n; i++) {\n        // INV 0 <= p.x < 2 && 0 <= p.y < 1 && 0 <= p.x + 2*p.y <= 2\n        if (QU(p) < 0.) {\n            // Triangle 1\n            p  = T1(p);\n            a += A;\n            h += 0.;\n        } else if (SV(p) < 0.) {\n            // Triangle 2\n            p  = T2(p);\n            a += A;\n            h += 1.;\n        } else if (SU(p) < 0.) {\n            // Triangle 3\n            p  = T3(p);\n            a -= A;\n            h += 2.;\n        } else if (ST(p) < 0.) {\n            // Triangle 4\n            p  = T4(p);\n            a -= A;\n            h += 3.;\n        } else {\n            // Triangle 5\n            p  = T5(p);\n            a += A;\n            h += 4.;\n        }\n\t    a  = fract(a);\n        h *= 0.2;\n    }\n\t// Barycentric coordinates of the point\n    vec3 b = vec3(p.y, 0.5*p.x, 1. - 0.5*p.x - p.y);\n    return b;//hsv2rgb(vec3(a, 1., 1.));\n}\n\nfloat triangle(in float x)\n{\n    return 1. - 2.*abs(fract(x) - 0.5);\n}\n\n#define T (iTime / 6.0)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.x;\n    // Point in the [0,2]*[0,1] domain\n    vec2 p = vec2(2.0*fract(uv.x), fract(2.0*uv.y));\n    int n = int(round(float(NITERS) * triangle(T)));\n    vec3 col = pinwheel(p, n);\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}