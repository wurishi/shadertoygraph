{"ver":"0.1","info":{"id":"NslXz4","date":"1618413897","viewed":130,"name":"sphere_glow23","username":"edwardbraed","description":"realization screen space glowing-effect","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define gray(rgb) (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114)\n#define norm(a) (a + 1.0) * 0.5\n\nfloat glow(sampler2D tex, vec2 uv, float k, float off, float t)\n{\n    vec2 s = 1.0 / vec2(textureSize(tex, 0));\n    float avg = 0.0;\n    float hk = k * 0.5;\n    for(float x = -hk; x < hk; x += 1.0)\n    {\n        for(float y = -hk; y < hk; y += 1.0)\n            avg += float(gray(texture(tex, uv + s * vec2(x,y) * off).rgb) > t);\n    }\n    return avg / (k * k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const float gs = 10.0; // glow samples\n    const float go = 2.0;  // glow samples offsets (for optimize blur)\n    const float gp = 1.0;  // glow power\n    const float gt = 0.45; // glow trashhold (because glow map from color brightness)\n    \n    vec4 gb = texture(iChannel0, uv);\n    \n    vec3 col = gb.rgb * gb.a + vec3(1.5, 1.5, 4.0) * glow(iChannel0, uv, gs, go, gt) * gp;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS_MARCH 64\n#define SPHERE_RADIUS 1.0\n#define BACKGROUND_COLOR vec3(0.1, 0.1, 0.2)\n\nvec4 raymarch(vec3 ro, vec3 rd, vec3 lv, float g)\n{\n    float t = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos = ro + rd * t;\n        float d = length(pos) - SPHERE_RADIUS;\n        if(d < 0.001)\n        {\n            vec2 rt = vec2(pos.x + (iTime - floor(iTime)), pos.y);\n            vec3 col = texture(iChannel0, rt).rgb;\n            float l = max(0.1, dot(normalize(lv), normalize(pos))) * 2.0;\n            return vec4(col, l);\n        }\n        \n        t += d;\n    }\n    \n    return vec4(BACKGROUND_COLOR * g, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // aspect ratio for correction rays..\n    float a = iResolution.x / iResolution.y;\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec3 rd = vec3(mix(mix(dBl, dBr, uv.x),\n                       mix(dTl, dTr, uv.x), uv.y),\n                   1.0);\n    rd.x *= a;\n    \n    // origin direction (or pseudo camera position)\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    // light vector\n    vec3 lv = vec3(3.0, 1.5, -2.0);\n    // background gradient\n    float g = (1.0 - distance(uv, vec2(0.5, 0.5 * a))) * 1.8;\n    g = max(g, (1.0 - distance(uv, vec2(0.5, 0.0))) * 2.0);\n    g = g*g;\n    \n    // Output to screen\n    fragColor = raymarch(ro, rd, lv, g);\n}","name":"Buffer A","description":"","type":"buffer"}]}