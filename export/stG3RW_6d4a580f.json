{"ver":"0.1","info":{"id":"stG3RW","date":"1641113867","viewed":336,"name":"Light Orbits","username":"ethanbuttimer","description":"Learning to light 3D shapes, blend color layers, and warp space!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","orbit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n#define BLUR 0.02\n\n//UTILITIES//\n\nfloat remap01(float a, float b, float t){\n    return min(max(0.,(t-a)/(b-a)), 1.);\n}\n\nfloat vecsAngle(vec3 u, vec3 v) {\n    return acos(dot(u, v) / (length(u) * length(v)));\n}\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(p-ro, rd))/length(rd);\n}\n\n//Helper function to correctly blend layers based on depth in scene\nvec4 combineZedAlpha(vec4 col1, vec4 col2, float zed1, float zed2){\n    if (zed2 < zed1) {\n        return vec4(col1.rgb * (1.-col2.a) + col2.rgb, min(1., col1.a + col2.a));\n    } else {\n        return vec4(col2.rgb * (1.-col1.a) + col1.rgb, min(1., col1.a + col2.a));\n    }\n}\n\n//DRAWING//\n\n//Circular sprites used to represent point lights\nvec3 Point(vec3 ro, vec3 rd, vec3 pos, float rad) {\n\tfloat d = DistLine(ro, rd, pos);\n    \n    float br = smoothstep(rad, rad-BLUR, d);\n    float zed = length(pos - ro);\n    float alpha = smoothstep(rad, rad-BLUR, d);\n    \n    return vec3(br, zed, alpha);\n}\n\n//Get the surface color of the (warped) sphere resulting from a single light source \nvec3 Sphere(vec3 ro, vec3 rd, vec3 center, float rad, vec3 light) {\n    float br = 0.;\n    //initialize large depth\n    float zed = 1000.;\n    float alpha = 0.;\n    \n    float t = dot(center-ro, rd);\n    vec3 p = ro + rd*t;\n    \n    //Warping\n    float blendx = 0.2*(1.+ sin(5.243*iTime));\n    p.x = mix(p.x, sin(2.5*p.x), blendx);\n    \n    float blendy = 0.15*(1.+ sin(7.254*iTime));\n    p.y = mix(p.y, sin(2.2*p.y), blendy);\n    \n    float y = length(center-p);\n    \n    if (y < rad) {\n        float x = sqrt(rad*rad - y*y);\n        float t1 = t-x;\n        float t2 = t+x;\n        \n        vec3 camToSurface = rd*t1;\n        vec3 p1 = ro + camToSurface;\n        \n        vec3 norm = normalize(p1 - center);\n        vec3 lightRay = normalize(light - p1);\n        vec3 viewRay = -normalize(rd);\n        vec3 reflRay = normalize(2.* dot(norm, lightRay) * norm - lightRay);//+ for retroreflective\n        \n        float diff = 1. * max(0.05, dot(lightRay, norm));\n        float spec = 0.;\n        if (vecsAngle(viewRay, reflRay) < PI/2.) {\n            spec = pow(dot(reflRay, viewRay), 4.);\n        }\n        zed = length(camToSurface);\n        alpha = smoothstep(rad, rad-BLUR, y);\n        br = 0.5 * (spec+diff) * alpha;\n    }\n\n    return vec3(br, zed, alpha);\n}\n\n//MAIN//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n\tvec2 uv =  (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    \n    //Background gradients\n    vec4 backCol = vec4(0.15,0.13,0.2,1.);\n    backCol.r += uv.y+0.1-(0.3*cos(1.5*uv.x));\n    backCol.g += 0.8*(uv.y-0.1);\n    backCol.b += 0.2*uv.y;\n    \n    //CAMERA MODEL//\n    \n    //Camera rotates around the sphere\n    vec3 ro = vec3(5.*cos(t/2.), 2., 5.*sin(t/2.));\n    vec3 lookat = vec3(0.);\n    \n    float zoom = 1.;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = normalize(cross(f, r));\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    //OBJECT PLACEMENT//\n    \n    vec3 spherePos = vec3(0.);//vec3(0., 1.*sin(t), 0.);\n    float sphereRad = 1.3 + (0.1 * sin(t*3.13));\n    \n    float light1OrbitRad = 2.5;// * (1.+ 0.1 * sin(iTime * 5.));\n    vec3 light1Pos = vec3(light1OrbitRad*cos(t), 0., light1OrbitRad*sin(t));\n    //Brightness changes over time\n    vec3 light1Col = vec3(0.9, 0.3, 0.)*(1.+0.8*sin(t));\n    \n    vec3 light2Pos = vec3(-3., 1.5, 0.);\n    vec3 light2Col = vec3(0., 0.9, 0.)*(0.8+0.2*cos(2.3*t));;\n    \n    float light3OrbitRad = 2.;// * (1.+ 0.1 * sin(iTime * 5.));\n    vec3 light3Pos = vec3(0., light3OrbitRad*cos(t*0.5), light3OrbitRad*sin(t*0.5));\n    vec3 light3Col = vec3(0., 0., 1.);\n\n    float lightRad = 0.3;\n    \n    //RENDER LAYERS//\n    \n    vec3 light1Info = Point(ro, rd, light1Pos, lightRad);\n    float light1Zed = light1Info[1];\n    vec4 light1Drawn = vec4(light1Col * light1Info[0], light1Info[2]);\n\n    vec3 light2Info = Point(ro, rd, light2Pos, lightRad);\n    float light2Zed = light2Info[1];\n    vec4 light2Drawn = vec4(light2Col * light2Info[0], light2Info[2]);\n    \n    vec3 light3Info = Point(ro, rd, light3Pos, lightRad);\n    float light3Zed = light3Info[1];\n    vec4 light3Drawn = vec4(light3Col * light3Info[0], light3Info[2]);\n\n    vec3 sphereL1Info = Sphere(ro, rd, spherePos, sphereRad, light1Pos);\n    vec3 sphereL1Drawn = light1Col * sphereL1Info[0];\n    vec3 sphereL2Info = Sphere(ro, rd, spherePos, sphereRad, light2Pos);\n    vec3 sphereL2Drawn = light2Col * sphereL2Info[0];\n    vec3 sphereL3Info = Sphere(ro, rd, spherePos, sphereRad, light3Pos);\n    vec3 sphereL3Drawn = light3Col * sphereL3Info[0];\n    float sphereZed = sphereL1Info[1];\n    \n    //COMBINE LAYERS//\n    \n    vec4 sphereDrawn = vec4(sphereL1Drawn+sphereL2Drawn+sphereL3Drawn, sphereL1Info[2]);\n    \n    vec4 retCol = combineZedAlpha(backCol, sphereDrawn, 1000., sphereZed);\n    retCol = combineZedAlpha(retCol, light1Drawn, sphereZed, light1Zed);\n    retCol = combineZedAlpha(retCol, light2Drawn, sphereZed, light2Zed);\n    retCol = combineZedAlpha(retCol, light3Drawn, sphereZed, light3Zed);\n\n\tfragColor = retCol;\n}","name":"Image","description":"","type":"image"}]}