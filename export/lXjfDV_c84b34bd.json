{"ver":"0.1","info":{"id":"lXjfDV","date":"1729966904","viewed":49,"name":"Julia 3d kuko","username":"kukovisuals","description":"julia set","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","3dfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    @kukovisuals\n*/\n\n// Constants\nconst int maxIterations = 7;\nconst float bailout = 2.0;\n\nvec3 rotateY(vec3 p, float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return vec3(\n        cosAngle * p.x + sinAngle * p.z,\n        p.y,\n        -sinAngle * p.x + cosAngle * p.z\n    );\n}\n\nvec3 rotateX(vec3 p, float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return vec3(\n        p.x,\n        cosAngle * p.y - sinAngle * p.z,\n        sinAngle * p.y + cosAngle * p.z\n    );\n}\n\nvec3 rotateZ(vec3 p, float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return vec3(\n        cosAngle * p.x - sinAngle * p.y,\n        sinAngle * p.x + cosAngle * p.y,\n        p.z\n    );\n}\n\nfloat DE_Julia(vec3 pos, vec3 c) {\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n    const float power = 3.0;\n    const float powerMinusOne = 1.0; // Constant for power - 1 to avoid recalculating\n\n    // Rotation angle, animating with time (lowered frequency for efficiency)\n    float angle = iTime * 0.02;\n\n    for (int i = 0; i < maxIterations; i++) {\n        r = length(z);\n        if (r > bailout) break;\n\n        // Apply rotation only once for performance\n        float cosAngle = cos(angle);\n        float sinAngle = sin(angle);\n        z = rotateY(rotateX(z, cosAngle), sinAngle * 0.5);\n\n        // Spherical coordinates with minimized trigonometric usage\n        float zr = r * r * r; // Equivalent to pow(r, 3.0) with power 3\n        float theta = acos(z.z / r) * power;\n        float phi = atan(z.y, z.x) * power;\n\n        // Update dr (distance estimation derivative) without recalculating power - 1\n        dr = zr * powerMinusOne * dr + 1.0;\n\n        // Cartesian coordinates with minimized trigonometric calls\n        float sinTheta = sin(theta);\n        z = zr * vec3(\n            sinTheta * cos(phi),\n            sinTheta * sin(phi),\n            cos(theta)\n        ) + c;\n    }\n\n    return 0.5 * log(r) * r / dr;\n}\n\n\nvec3 getNormal(vec3 p, vec3 c) {\n    float epsilon = 0.0005;\n    vec3 n = vec3(\n        DE_Julia(p + vec3(epsilon, 0.0, 0.0), c) - DE_Julia(p - vec3(epsilon, 0.0, 0.0), c),\n        DE_Julia(p + vec3(0.0, epsilon, 0.0), c) - DE_Julia(p - vec3(0.0, epsilon, 0.0), c),\n        DE_Julia(p + vec3(0.0, 0.0, epsilon), c) - DE_Julia(p - vec3(0.0, 0.0, epsilon), c)\n    );\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize pixel coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup (precomputed constants)\n    vec3 camPos = vec3(0.0, 0.0, -5.0);\n    vec3 target = vec3(0.0);\n    float zoom = 10.0;\n\n    vec3 forward = normalize(target - camPos);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rayDir = normalize(uv.x * right + uv.y * up + zoom * forward);\n\n    // Julia set constant\n    const vec3 c = vec3(-0.5, 0.156, 0.0);\n\n    // Ray marching setup with optimized parameters\n    float totalDistance = 0.0;\n    const float maxDistance = 50.0;   // Lower max distance for early exit\n    const float minDistance = 0.00001;  // Increased minimum distance for less precision\n    const int maxSteps = 70;          // Reduced maximum steps for optimization\n    vec3 pos;\n    int steps;\n\n    for (steps = 0; steps < maxSteps; steps++) {\n        pos = camPos + totalDistance * rayDir;\n        float distance = DE_Julia(pos, c);\n\n        // Break if we're close enough to the surface or too far away\n        if (distance < minDistance || totalDistance > maxDistance) break;\n\n        // Adaptive step size to skip over larger empty spaces quickly\n        totalDistance += distance * 0.2;\n    }\n\n    vec3 color = vec3(0.0);\n    if (steps < maxSteps) {\n        vec3 normal = getNormal(pos, c);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));\n        float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n\n        // Simplified color gradient based on distance and steps\n        float stepFactor = float(steps) / float(maxSteps);\n        vec3 depthColor = mix(vec3(0.9, 0.3, 0.7), vec3(0.2, 0.7, 1.0), stepFactor);\n\n        // Basic coloring without heavy sine calculations\n        vec3 baseColor = vec3(0.4 + stepFactor * 0.6, 0.8 + stepFactor * 1.7, 1.3 - stepFactor * 0.5);\n\n        // Combine with diffuse lighting for final color\n        color = diff * (baseColor * 0.5 + depthColor * 0.5);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}