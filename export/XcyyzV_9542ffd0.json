{"ver":"0.1","info":{"id":"XcyyzV","date":"1732089605","viewed":102,"name":"TheBoiledHotWater","username":"TheBoiledHotWater","description":"nyowa","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["logo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    col = col + fwidth(dot(col.rgb, vec3(0.2126, 0.7152, 0.0722)));\n            \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float TAU = 2. * 3.14159265;\n\nvec4 cosine_gradient(float x,  vec4 phase, vec4 amp, vec4 freq, vec4 offset){\n  phase *= TAU;\n  x *= TAU;\n\n  return vec4(\n    offset.r + amp.r * 0.5 * cos(x * freq.r + phase.r) + 0.5,\n    offset.g + amp.g * 0.5 * cos(x * freq.g + phase.g) + 0.5,\n    offset.b + amp.b * 0.5 * cos(x * freq.b + phase.b) + 0.5,\n    offset.a + amp.a * 0.5 * cos(x * freq.a + phase.a) + 0.5\n  );\n}\n\nvec3 toRGB(vec4 grad){\n  return grad.rgb;\n}\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nvec3 pcg3df(vec3 s) {\n  uvec3 r = pcg3d(floatBitsToUint(s));\n  return vec3(r) / float(0xffffffffu);\n}\n\nivec2 font_data[37] = ivec2[](\n    ivec2(0x00000000,0x00000000), //space\n    ivec2(0x7e91897e,0x00000000), //0\n    ivec2(0x01ff4121,0x00000000), //1\n    ivec2(0x71898543,0x00000000), //2\n    ivec2(0x6e919142,0x00000000), //3\n    ivec2(0x08ff4838,0x00000000), //4\n    ivec2(0x8e9191f2,0x00000000), //5\n    ivec2(0x0e91916e,0x00000000), //6\n    ivec2(0xc0b08f80,0x00000000), //7\n    ivec2(0x6e91916e,0x00000000), //8\n    ivec2(0x6e919162,0x00000000), //9\n    ivec2(0x7f88887f,0x00000000), //A\n    ivec2(0x6e9191ff,0x00000000), //B\n    ivec2(0x4281817e,0x00000000), //C\n    ivec2(0x7e8181ff,0x00000000), //D\n    ivec2(0x919191ff,0x00000000), //E\n    ivec2(0x909090ff,0x00000000), //F\n    ivec2(0x4685817e,0x00000000), //G\n    ivec2(0xff1010ff,0x00000000), //H\n    ivec2(0x0081ff81,0x00000000), //I\n    ivec2(0x80fe8182,0x00000000), //J\n    ivec2(0x413608ff,0x00000000), //K\n    ivec2(0x010101ff,0x00000000), //L\n    ivec2(0x601060ff,0x000000ff), //M\n    ivec2(0x0c1060ff,0x000000ff), //N\n    ivec2(0x7e81817e,0x00000000), //O\n    ivec2(0x609090ff,0x00000000), //P\n    ivec2(0x7f83817e,0x00000001), //Q\n    ivec2(0x619698ff,0x00000000), //R\n    ivec2(0x4e919162,0x00000000), //S\n    ivec2(0x80ff8080,0x00000080), //T\n    ivec2(0xfe0101fe,0x00000000), //U\n    ivec2(0x0e010ef0,0x000000f0), //V\n    ivec2(0x031c03fc,0x000000fc), //W\n    ivec2(0x340834c3,0x000000c3), //X\n    ivec2(0x300f30c0,0x000000c0), //Y\n    ivec2(0xe1918d83,0x00000081) //Z\n);\n\nvec3 font(vec2 uv,int id){\n    vec2 uv1 = uv;\n    uv = uv * 8.0;\n    ivec2 texel = ivec2(uv);\n    int bit_offset = texel.x * 8 + texel.y;\n\n    int s,t;\n    s = font_data[id].x;\n    t = font_data[id].y;\n\n    int tex = 0;\n    \n    if(bit_offset <= 31){\n        s = s >> bit_offset;\n        s = s & 0x00000001;\n        tex = s;\n    }\n    else{\n        t = t >> (bit_offset - 32);\n        t = t & 0x00000001;\n        tex = t;\n    }\n\n    tex = (abs(uv1.x - 0.5) < 0.5 && abs(uv1.y - 0.5) < 0.5) ? tex : 0;\n    return vec3(tex); \n}\n\nmat2 rot(float r)\n{\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec4 phases = vec4(1.00, 1.12, 1.00, 0.);\nconst vec4 amplitudes = vec4(1.57, 1.10, 0.57, 0.);\nconst vec4 frequencies = vec4(0.58, 0.50, 0.53, 0.);\nconst vec4 offsets = vec4(0.31, -.13, -.23, 0.);\n\nconst vec4 fPhases = vec4(0.06, 0.19, 0.22, 0.);\nconst vec4 fAmplitudes = vec4(1.07, 0.80, 0.95, 0.);\nconst vec4 fFrequencies = vec4(4.95, 5.98, 6.72, 0.);\nconst vec4 fOffsets = vec4(-0.4, -0.4, -0.4, 0.);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec3 fontHash = pcg3df(vec3(floor(iTime), 423.24, 63542.213));\n    vec2 fontUV = (uv - 0.5);\n    fontUV *= rot(acos(-1.0) / 4.0 * (fontHash.y - 0.5) * 2.0);\n    fontUV *= 7.0 * (fontHash.x * 0.5 + 0.95);\n    fontUV.x += sin(iTime + fontUV.y) * 0.3;\n    vec3 text;\n    // The\n    fontUV -= vec2(-1.3, 1.75);\n    text += font(fontUV, 30);\n    fontUV -= vec2(1.0, 0.0);\n    text += font(fontUV, 18);\n    fontUV -= vec2(0.925, 0.0);\n    text += font(fontUV, 15);\n    \n    // Boiled\n    fontUV -= vec2(-3.15, -1.5);\n    text += font(fontUV, 12);\n    fontUV -= vec2(1.0, 0.0);\n    text += font(fontUV, 25);\n    fontUV -= vec2(1.0, 0.0);\n    text += font(fontUV, 19);\n    fontUV -= vec2(0.8, 0.0);\n    text += font(fontUV, 22);\n    fontUV -= vec2(0.9, 0.0);\n    text += font(fontUV, 15);\n    fontUV -= vec2(0.9, 0.0);\n    text += font(fontUV, 14);\n    \n    // HotWater\n    fontUV -= vec2(-5.65, -1.5);\n    text += font(fontUV, 18);\n    fontUV -= vec2(1.0, 0.0);\n    text += font(fontUV, 25);\n    fontUV -= vec2(0.925, 0.0);\n    text += font(fontUV, 30);    \n    fontUV -= vec2(1.0, 0);\n    text += font(fontUV, 33);\n    fontUV -= vec2(1.0, 0.0);\n    text += font(fontUV, 11);\n    fontUV -= vec2(0.9, 0.0);\n    text += font(fontUV, 30);\n    fontUV -= vec2(1.0, 0.0);\n    text += font(fontUV, 15);\n    fontUV -= vec2(1.0, 0.0);\n    text += font(fontUV, 28);\n    \n    vec3 col;\n    \n    for (float i = 1.0; i < 10.0; i += 1.0)\n    {\n        vec3 fHash = pcg3df(vec3(7352.42, 243.0 * i, 9452.31));\n        \n        \n        vec2 uvf = uv;\n        uvf.x += sin(iTime + uvf.y + acos(-1.0) * fHash.x) * (fHash.y * 0.2 + 0.1);\n        \n        vec3 xHash = pcg3df(vec3(floor(uvf.x * 100.0 + fHash.z * 100.0), 413.432, 542.52));\n        vec3 xHash2 = pcg3df(vec3(8564.345, 213.34, floor(uvf.x * 100.0 + fHash.z * 100.0)));\n\n        vec4 cos_grad = cosine_gradient(uvf.y + xHash.x * 0.1, phases, amplitudes, frequencies, offsets);\n        cos_grad = clamp(cos_grad, 0., 1.);\n        \n        float m = 1.0 - length(uvf.y) - (0.7 * xHash.y + 0.3);\n        float l = step(length(fract(uvf.y - iTime * (0.3 + xHash.z * 0.7) + xHash2.x)), 0.02) * m;\n        col += vec3(l) * cos_grad.rgb;\n    }\n    \n    col *= 0.5;\n            \n    vec4 fcos_grad = cosine_gradient(fontUV.y / 5.0 + iTime * 0.2, fPhases, fAmplitudes, fFrequencies, fOffsets);\n    fcos_grad = clamp(fcos_grad, 0., 1.);\n    col += text * fcos_grad.rgb;\n        \n    float bg = step(pcg3df(vec3(uv * 2.0, floor(iTime * 16.0))).x, 0.00025);\n    col += bg;   \n    \n    float s = 0.999;\n    vec3 backCol = texture(iChannel0, uv * s + (1.0 - s) * 0.5).rgb;\n    backCol.b *= abs(sin(iTime * 20.0));\n\n    fragColor = vec4(mix(col, col + backCol, 0.95), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}