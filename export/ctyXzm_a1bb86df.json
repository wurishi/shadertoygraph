{"ver":"0.1","info":{"id":"ctyXzm","date":"1686062462","viewed":64,"name":"Mandelbrot and others","username":"Rogolop","description":"Mandelbrot set, and other things commented\nDrag with mouse, zoom with +/- (Spanish keyboard at least)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["2d","sdf"],"hasliked":0,"parentid":"clySzm","parentname":"Keyboard and mouse test 2"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mandelbrot set, and other things commented\n// Drag with mouse, zoom with +/- (Spanish keyboard at least)\n\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to an oriented box.\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = p-(a+b)*0.5;\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l*0.5,th);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat orderOfMagnitude(float x) {\n    //return round(x);\n    return exp2(log2(10.)*round(log2(x)/log2(10.)));\n}\n\nfloat fracabs(float x) {\n    return abs(x - round(x));\n}\n\nfloat mandelbrot(float x, float y) {\n    float z1 = 0., z2 = 0.;\n    float oldz1 = z1, oldz2 = z2;\n    int i=0;\n    const int maxiter = 600;\n    \n    for (i; i<maxiter; i++) {\n        z1 = oldz1*oldz1 - oldz2*oldz2 + x;\n        z2 = 2.*oldz1*oldz2 + y;\n        \n        if (z1*z1+z2*z2 > 4.) break; \n        oldz1 = z1;\n        oldz2 = z2;\n    }\n    if (i == maxiter) return -1.;\n    \n    float val = float(i);\n    val += -log2(log2(z1*z1+z2*z2)) + 4.0; // Smooth iteration count https://www.shadertoy.com/view/4df3Rn\n    \n    val = val/float(maxiter);\n    //val = mod(val, 50.)/50.;\n    \n    return val;\n}\n\nvec3 colorize(float x) {\n    if (x == -1.) return vec3(0.,0.,0.);\n    if (0./6. <= x && x < 1./6.) return mix(vec3(1.,0.,0.), vec3(1.,1.,0.), (x-0./6.)/(1./6.-0./6.));\n    if (1./6. <= x && x < 2./6.) return mix(vec3(1.,1.,0.), vec3(0.,1.,0.), (x-1./6.)/(2./6.-1./6.));\n    if (2./6. <= x && x < 3./6.) return mix(vec3(0.,1.,0.), vec3(0.,1.,1.), (x-2./6.)/(3./6.-2./6.));\n    if (3./6. <= x && x < 4./6.) return mix(vec3(0.,1.,1.), vec3(0.,0.,1.), (x-3./6.)/(4./6.-3./6.));\n    if (4./6. <= x && x < 5./6.) return mix(vec3(0.,0.,1.), vec3(1.,0.,1.), (x-4./6.)/(5./6.-4./6.));\n    if (5./6. <= x && x < 6./6.) return mix(vec3(1.,0.,1.), vec3(1.,0.,0.), (x-5./6.)/(6./6.-5./6.));\n}\n\n\n//---------\n\n// Printing floats (https://www.shadertoy.com/view/4tl3D2)\n// Created by Eduardo Castineyra - casty/2015\n// Creative Commons Attribution 4.0 International License\n\nvec2 pV[4];\n//   -\n// 0| |1\n//   -\n// 2| |3\n//   -\n\nvec2 pH[3];\n//\t- 2\n//\t- 1\n//\t- 0\n\n//vec2 uv;\nvec2 pixel; // size of a \"pixel\"\nint SIZE; // \"pixels\" per segment\nint WIDTH;\nvec2 SEGMENT; // dimensions of a segment\nfloat DIGIT_SPACING = 0.2; // digit spacing (proportion wrt. SIZE)\nfloat digitSpace; // (as length)\nfloat digitWidth;\nconst ivec2 DIGITS = ivec2(3, 7); // #digits before and after decimal separator\n\nvoid globalInit(){\n    pixel = vec2(1./iResolution.y); //vec2(0.005, 0.001);\n    SIZE = max(3, int(iResolution.y/70.)); // at least 3 pixels\n    WIDTH = int(float(SIZE)/3.);\n    WIDTH = clamp(WIDTH, 1, int(SIZE/2)); // at least 1 pixel, at most half the length\n    SEGMENT = pixel * vec2(SIZE, WIDTH);\n    digitWidth = pixel.x * float(SIZE+WIDTH);\n    digitSpace = pixel.x * max(1., DIGIT_SPACING * float(SIZE+WIDTH)); // at least 1 pixel spacing\n    \n    // starting positon of segments\n    pV[0] = vec2(0, SIZE);  pV[1] = vec2(SIZE - 1, SIZE);\n    pV[2] = vec2(0, 0); \tpV[3] = vec2(SIZE - 1, 0);\n    \n    for (int i = 0; i < 3; i++) {\n    \tpH[i] = vec2(0, SIZE * i);\n    }\n}\n\n// segments encoded in the digits of v.x, v.y (ending in 5 to prevent numerical errors)\nconst vec2[] digitSegments = vec2[] (\n    vec2(.11115, .1015),\n    vec2(.01015, .0005),\n    vec2(.01105, .1115),\n    vec2(.01015, .1115),\n    vec2(.11015, .0105),\n    vec2(.10015, .1115),\n    vec2(.10115, .1115),\n    vec2(.01015, .0015),\n    vec2(.11115, .1115),\n    vec2(.11015, .1115),\n    vec2(.00005, .0105)\n);\n\nvec2 step2(vec2 edge, vec2 v){\n    return vec2(step(edge.x, v.x), step(edge.y, v.y));\n}\n\n// horizontal segment\nfloat segmentH(vec2 pos, vec2 uv){\n    vec2 sv = step2(pos, uv) - step2(pos + SEGMENT.xy, uv); // 0, 1 or 2\n    return step(1.5, sv.x+sv.y); // if == 2\n}\n\n// vertical segment\nfloat segmentV(vec2 pos, vec2 uv){\n    vec2 sv = step2(pos, uv) - step2(pos + SEGMENT.yx, uv); // 0, 1 or 2\n    return step(1.5, sv.x+sv.y); // if == 2\n}\n\n// dot segment\nfloat segmentDot(vec2 pos, vec2 uv){\n    vec2 sv = step2(pos, uv) - step2(pos + SEGMENT.yy, uv); // 0, 1 or 2\n    return step(1.5, sv.x+sv.y); // if == 2\n}\n\n// return units digit and shift f one digit to the left\nfloat nextDigit(inout float f){\n    f = fract(f) * 10.0;\n    return floor(f);\n}\n\nfloat drawDigit(int d, vec2 pos, vec2 uv){\n    //vec4 sv = vec4(1.0, 0.0, 1.0, 0.0);\n    //vec3 sh = vec3(1.0);\n    float c = 0.0;\n    \n    vec2 v = digitSegments[d];\n    \n    for (int i = 0; i < 4; i++)\n        c += segmentV(pos + pixel.x * pV[i], uv) * nextDigit(v.x);\n\n    for (int i = 0; i < 3; i++)\n        c += segmentH(pos + pixel.x * pH[i], uv) * nextDigit(v.y);\n    \n\treturn c;\n}\n\nfloat printNumber(float f, vec2 pos, vec2 uv){\n    float c = 0.0;\n    \n    // Overflow\n    if (f >= pow(10.0, float(DIGITS.x)) || f <= -pow(10.0, float(DIGITS.x-1))) {\n        for (int i = 0; i < DIGITS.x + DIGITS.y; i++) {\n            c += drawDigit(10, pos, uv); // draw digit\n            pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        }\n        return c;\n    }\n    \n    // set first representable digit of f to units digit\n    f /= pow(10.0, float(DIGITS.x));\n    \n    // draw digits before decimal separator\n    for (int i = 0; i < DIGITS.x; i++) {\n        if (i==0 && f < 0.) {\n            // Negative sign\n            c += drawDigit(10, pos, uv); // draw digit\n            pos += vec2(digitWidth + digitSpace, 0.0); // move right\n            f = -f;\n            nextDigit(f);\n        } else {\n            // Digit\n            c += drawDigit(int(nextDigit(f)), pos, uv); // draw digit\n            pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        }\n    }\n    \n    // decimal separator\n    c += segmentDot(pos, uv);\n    pos += vec2(digitWidth + digitSpace, 0.0); // move right\n    // float(WIDTH)*pixel.x + digitSpace\n    \n    // draw digits after decimal separator\n    for (int i = 0; i < DIGITS.y; i++) {\n        c += drawDigit(int(nextDigit(f)), pos, uv); // draw digit\n        pos += vec2(digitWidth + digitSpace, 0.0); // move right\n    }\n   \treturn c;\n}\n\nfloat printFloat(float f, vec2 pos, vec2 uv){\n    float c = 0.0;\n    int ifSign = 1-int(step(0., f));\n    /*\n    // Overflow\n    if (f >= pow(10.0, float(DIGITS.x)) || f <= -pow(10.0, float(DIGITS.x-1))) {\n        for (int i = 0; i < DIGITS.x + DIGITS.y; i++) {\n            c += drawDigit(10, pos, uv); // draw digit\n            pos += vec2(digitSpace, 0.0); // move right\n        }\n        return c;\n    }\n    */\n    \n    // Negative sign\n    if (f < 0.) {\n        c += drawDigit(10, pos, uv); // draw digit\n        pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        f = -f;\n    }\n    \n    int power10 = max(0, 1 + int(floor(log2(f)/log2(10.))));\n    \n    // set first representable digit of f to units digit\n    f /= pow(10.0, float(power10));\n    \n    \n    \n    // draw digits\n    for (int i = 0; i < DIGITS.x+DIGITS.y-ifSign; i++) {\n        // decimal separator\n        if (power10 == 0) {\n            c += segmentDot(pos, uv);\n            pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        }\n        c += drawDigit(int(nextDigit(f)), pos, uv); // draw digit\n        pos += vec2(digitWidth + digitSpace, 0.0); // move right\n        \n        power10--;\n    }\n   \treturn c;\n}\n\n\n\n\n//#########################################################\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Position and scale\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec2 centerPos = get0(POSITION_ADDR).xy;\n    float scale = get0(POSITION_ADDR).z;\n    p /= scale;\n    m /= scale;\n    p += centerPos;\n    float x = p.x;\n    float y = p.y;\n    \n    //-----------------------------------------------------\n\n    // Box animation\n    /*\n    float t = iTime;\n    vec2 v1 = cos( t*0.5 + vec2(0.0,1.00) + 0.0 );\n\tvec2 v2 = cos( t*0.5 + vec2(0.0,3.00) + 1.5 );\n    float th = 0.3*(0.5+0.5*cos(t*1.1+1.0));\n    */\n    \n    // SDF\n\tfloat d = 0.;\n    //d = sdOrientedBox( p, v1, v2, th );\n    //d = x*x*x-y*y;\n    //d = x*x*(x+1.)-y*y;\n    //d = y*y*(x+y-1.)-2.*x*x*x;\n    //d = (x*x+y*y)*(x*x+y*y)-(x*x-y*y);\n    //d = y*y-x*x+x*x*x*x;\n    //d = y*y*(y*y-9.)-x*x*(x*x-10.);\n    //d = (x*x-2.*y+y*y)*(x*x-2.*y+y*y)-x*x-y*y;\n    d = mandelbrot(x, y);\n    \n    //-----------------------------------------------------\n    \n    // Colors as function of d\n    vec3 col = vec3(1.0);\n    //col -= sign(d)*vec3(0.1,0.4,0.7); // cyan-orange\n\t//col *= 1.0 - exp(-6.0*abs(d)); // black close to 0\n\t//col *= 0.8 + 0.2*cos(120.0*d); // lighter-darker bands\n\t//col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) ); // white line\n    //col = mix( col, vec3(1.0), exp(-120.0*abs(d))); // white line v2\n    col = colorize(d); //vec3(d);\n    \n    col = clamp(col, 0., 1.);\n    \n    // Unit grid\n    /*\n    if (fracabs(x*orderOfMagnitude(1.8*scale))<0.01 || fracabs(y*orderOfMagnitude(1.8*scale))<0.01) col = 0.9*col + 0.1*(1.-col);\n    else if (fracabs(x*orderOfMagnitude(4.*scale))<0.01 || fracabs(y*orderOfMagnitude(4.*scale))<0.01) col = 0.9*col + 0.1*(1.-col);\n    */\n    \n    // Output color\n    fragColor = vec4(col, 1.0);\n    \n    \n    // Print coordinates\n    globalInit();\n    vec2 uv = fragCoord.xy / iResolution.y;\n    if (uv.x < 0.25 && uv.y < 0.15) fragColor *= 0.5; // Dark box\n    //vec2 mouse = iMouse.xy / iResolution.xy;\n    //fillNumbers();\n    \n    fragColor += vec4(//printNumber(mouse.x * 100.0, mouse) + \n                     //printNumber(mouse.y * 100.0, mouse - pixel * vec2(0.0, SIZE * 5)) + \n                     //printNumber(0.0123405, vec2(0.01,0.01+0.05*5.), uv) +\n                     //printFloat(1.+floor(log2(scale)/log2(10.)), vec2(0.01,0.01+0.05*5.), uv) +\n                     printFloat(centerPos.x, vec2(0.01,0.01+0.05*1.), uv) +\n                     printFloat(centerPos.y, vec2(0.01,0.01), uv) +\n                     printFloat(scale, vec2(0.01,0.01+0.1*1.), uv)\n                    );\n    \n    \n    fragColor.a = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Save and manipulate position, scale, last mouse position\n\n\nconst vec4 startPos1 = vec4(-0.777120613150274923773, 0.126857111509958518545, 0.4, 0.);\nconst vec4 startPos2 = vec4(-1.7864403, 0., 0.4, 0.);\nconst vec4 startPos = startPos1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize\n    if (iFrame == 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        if (inAddr(POSITION_ADDR)) {\n            fragColor = startPos;\n        }\n        return;\n    }\n    \n    // Mouse\n    vec2 m = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    //m = vec2(0., 0.);\n    //m *= 1.4;\n    float scale = get0(POSITION_ADDR).z;\n    m /= scale;\n    \n    \n    if (inAddr(POSITION_ADDR)) {\n    \n        // Update position\n        fragColor = get0(POSITION_ADDR); // last position\n        if ( mouseClicked && get0(LAST_MOUSE_ADDR).w == 1.) {\n            fragColor -= (vec4(m.x, m.y, 0., 0.) - vec4(get0(LAST_MOUSE_ADDR).xy, 0., 0.));\n        }\n        \n        // Update zoom\n        if ( checkKey(KEY_MINUS) ) fragColor.z *= 0.97;\n        if ( checkKey(KEY_PLUS) ) fragColor.z *= 1.03;\n        if ( checkKey(KEY_0) ) {\n            fragColor = startPos;\n        }\n        float T = 30.;\n        float tt = 2.*3.14159*(iTime/T+0.25);\n        fragColor.z = startPos.z*pow(600., (1.-2./3.*sin(tt)*(1.+0.5*sin(tt)*sin(tt))));\n        fragColor.x = mix(startPos1.x, startPos2.x, clamp(0.5+5.*sin(tt/2.-2.*3.14159/8.),0.,1.));\n        fragColor.y = mix(startPos1.y, startPos2.y, clamp(0.5+5.*sin(tt/2.-2.*3.14159/8.),0.,1.));\n        \n        \n    } else if (inAddr(LAST_MOUSE_ADDR)) {\n        // Update last mouse position\n        fragColor = vec4(m.x, m.y, 0., 1.);\n        \n        // Indicate mouse may have moved when not pressed\n        if ( !(mouseClicked) ) {\n            fragColor.w = 0.;\n        }\n        \n        \n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const ivec2 POSITION_ADDR = ivec2(0, 0); // x, y, scale, 0\nconst ivec2 LAST_MOUSE_ADDR = ivec2(1, 0); // x, y, 0, isUpdated\n\n\n// https://www.shadertoy.com/view/WsdfRS\n// --- most  utils from https://www.shadertoy.com/view/llySRh\n                                                        \n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame). cf https://www.shadertoy.com/view/3dcBRS\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.z > 0. )                  // mouse clicked:   mouse button currently clicked\n\n//#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) ) \n//#define keyClick(a)  ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n//#define hash(p)        fract( sin( (p) * vec2(12.9898, 78.233) ) * 43758.5453 )\n\n//#define in(x,a,b)    ( x > min(a,b) && x < max(a,b) )\n\n\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define inAddr(addr) ( ivec2(fragCoord) == addr )\n\n#define get0(addr) ( texelFetch(iChannel0, addr, 0) )\n#define get1(addr) ( texelFetch(iChannel1, addr, 0) )\n\n\n// https://www.shadertoy.com/view/XdG3Dh\n// Modified for Spanish keyboard\n\n// Keyboard constants definition\nconst float KEY_BACKSPACE = 8.5/256.0;\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0; // ,\nconst float KEY_PERIOD = 190.5/256.0; // .\n//const float KEY_ADD   = 107.5/256.0; // NO FUNCIONA\n//const float KEY_SUBS  = 109.5/256.0; // NO FUNCIONA\n//const float KEY_EQUAL = 187.5/256.0; // NO FUNCIONA\n//const float KEY_MINUS = 189.5/256.0; // NO FUNCIONA\n\n\nconst float KEY_TAB = 9.5/256.0; // TAB\nconst float KEY_CTRL = 17.5/256.0; // CTRL, ALTGR\nconst float KEY_ALT = 18.5/256.0; // ALT, ALTGR\nconst float KEY_0 = 48.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\nconst float KEY_6 = 54.5/256.0;\nconst float KEY_7 = 55.5/256.0;\nconst float KEY_8 = 56.5/256.0;\nconst float KEY_9 = 57.5/256.0;\nconst float KEY_SHIFT = 16.5/256.0;\nconst float KEY_LT = 16.5/256.0; // <\nconst float KEY_oth = 220.5/256.0; // º\nconst float KEY_MINUS = 173.5/256.0; // -\nconst float KEY_RIGHTACCENT = 222.5/256.0; // ´ and  '\nconst float KEY_LEFTACCENT = 192.5/256.0; // ` and ñ\nconst float KEY_CTRENCADA = 191.5/256.0; // ç\nconst float KEY_PLUS = 171.5/256.0; // +\nconst float KEY_INVERTEDEXCLAMATION = 221.5/256.0; // ¡\n\n#define checkKey(key) ( texture(iChannel1, vec2(key, 0.25)).x > 0.5 )\n\n\n\n","name":"Common","description":"","type":"common"}]}