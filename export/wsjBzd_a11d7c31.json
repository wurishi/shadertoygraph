{"ver":"0.1","info":{"id":"wsjBzd","date":"1590648368","viewed":154,"name":"Clickable SDF's","username":"sdfgeoff","description":"A project that's been brewing at the back of my mind is a CAD system that uses SDF's. One challenge is figuring out what object the user clicks on. This shader solves that by rendering a buffer of object ID's. This coul be read back to host on mouseclick.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["sdf","cad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 surface_id_colors[4] = vec3[4](\n    vec3(0.0),// World Color\n    vec3(0.0, 0.0, 1.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(1.0, 0.0, 0.0)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Get data about the surface we're looking at\n    vec4 data = texture(iChannel0, uv);\n    vec3 normal = vec3(data[0], data[1], sqrt(1.0 - data[0]*data[0] - data[1] * data[1]));\n    float surface_id = data[2];\n    float dist = data[3];\n    \n    vec3 surface_color = surface_id_colors[int(surface_id)];\n    \n    // Edge outlines\n    float edge_width = 0.003;\n    vec4 data_offset_left = texture(iChannel0, uv + vec2(0, edge_width));\n    vec4 data_offset_down = texture(iChannel0, uv + vec2(edge_width * iResolution.x / iResolution.y, 0.0));\n    float edge = abs(data_offset_left[2]- data[2]) + abs(data_offset_down[2] - data[2]);\n    \n    \n    // Get the surface under the mouse\n    vec2 mouse_pos = iMouse.xy / iResolution.xy;\n    vec4 data_under_mouse = texture(iChannel0, mouse_pos);\n    bool clicked = data_under_mouse[2] == data[2];\n\n    \n    // Render the surface that we're looking at\n    vec3 lighting = vec3(dot(normal, vec3(0.0,0.0,1.0)));\n    if (clicked) {\n    \tlighting += 2.0 * pow(1.0 - lighting.x, 3.0);\n    }\n    vec4 environment = texture(iChannel1, normal);\n    lighting += environment.rgb * 0.3;\n\n    vec3 surface_output = mix(surface_color, lighting.rgb, 0.7);\n    surface_output *= 1.0 - edge;\n\n    \n    \n    fragColor = vec4(vec3(surface_output), 0.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This is a test of signed distance fields where instead of each SDF function\n// only returning the distance, it returns a struct containing\n// the surface normals and a surface ID as well\n// The aim of this is to allow simple CAD style rendering, edge\n// drawing, etc.\n//\n// The output of this shader is an image containing the normals, distance from camera\n// and the surface ID.\n\nstruct surface_t {\n    int surface_id;\n    float sdf;\n    vec3 normal;\n};\n\n\nsurface_t sphere_sdf(vec3 query_point, int id, float sphere_radius) {\n    return surface_t(\n        id,\n        length(query_point)  - sphere_radius,\n        normalize(query_point)\n    );\n}\n\nsurface_t surface_union(surface_t surface_1, surface_t surface_2) {\n    // Join surface_1 to surface_2\n    if (surface_1.sdf < surface_2.sdf){\n        return surface_1;\n    } else {\n     \treturn surface_2;   \n    }\n}\nsurface_t surface_intersect(surface_t surface_1, surface_t surface_2) {\n    // Find the volume both surface occupy\n    if (surface_1.sdf > surface_2.sdf){\n        return surface_1;\n    } else {\n     \treturn surface_2;   \n    }\n}\n\nsurface_t surface_difference(surface_t surface_1, surface_t surface_2) {\n    // subtract surface_2 from surface_1\n    // invert surface 2:\n    surface_2.sdf = -surface_2.sdf;\n    surface_2.normal = -surface_2.normal;\n    return surface_intersect(surface_1, surface_2);\n}\n\n\n\nvec3 transform(vec3 inp, mat4 offset) {\n    return (offset * vec4(inp, 1.0)).xyz;\n}\n\nmat4 translation(vec3 trans) {\n    // Construct a translation matrix\n    return mat4 (\n        vec4(1.0, 0.0, 0.0, 0.0), \n        vec4(0.0, 1.0, 0.0, 0.0), \n        vec4(0.0, 0.0, 1.0, 0.0), \n        vec4(trans.x, trans.y, trans.z, 1.0)\n    );\n    \n}\n\n\nsurface_t world(vec3 world_position) {\n    surface_t sphere1 = sphere_sdf(transform(world_position, translation(-vec3(0.0, 0.0, 5.0))), 1, 1.0);\n    surface_t sphere2 = sphere_sdf(transform(world_position, translation(-vec3(0.0, 1.0, 4.0))), 2, 1.0);\n    surface_t sphere3 = sphere_sdf(transform(world_position, translation(-vec3(1.0, 0.0, 5.0))), 3, 1.0);\n    \n    surface_t body = sphere1;\n    body = surface_union(body, sphere3);\n    body = surface_difference(body, sphere2);\n    \n    //for (int i; i<100; i++) {\n    // \tsurface_t new_sphere = sphere_sdf(transform(world_position, translation(-vec3(sin(float(i) + iTime), float(i) / 100.0, 5.0))), i+4, 1.0);\n    //\tbody = surface_union(body, new_sphere);\n    //}\n    \n    return body;\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int steps = 10; // Steps to converge to surface\n    float tolerance = 0.01; // It's a surface if the end result is within this distance of a surface.\n    \n    mat4 projection_matrix = mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 0.0\n    );\n    \n    // camera coords (from -1 to 1)\n    vec2 cam_coords = (fragCoord/iResolution.xy - vec2(0.5)) * 2.0;\n    cam_coords.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray_start_position = (projection_matrix * vec4(cam_coords.x, cam_coords.y, 0.0, 0.0)).xyz;\n    vec3 ray_end_position = (projection_matrix * vec4(cam_coords.x, cam_coords.y, 1.0, 0.0)).xyz;\n    vec3 ray_direction = ray_end_position - ray_start_position;\n    \n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    \n    vec3 sample_point = ray_start_position;\n    surface_t results = world(sample_point);\n    float dist = 0.0;\n    \n    for (int i=0; i<steps; i += 1) {\n        dist += results.sdf;\n        sample_point += ray_direction * results.sdf;\n        results = world(sample_point);\n    }\n    \n    if (results.sdf < tolerance) {\n        // We hit a surface\n        color = vec4(\n            results.normal.x,\n            results.normal.y,\n            results.surface_id,\n            dist\n        );\n    }\n\n    // Output to screen\n    fragColor = color;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}