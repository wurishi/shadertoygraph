{"ver":"0.1","info":{"id":"wtK3Ww","date":"1579201234","viewed":156,"name":"Cursor Effect of FGO","username":"heqin6314","description":"I played the Fate mobile game recently. The comlicated system confused me but the touching screen cursor effect is really interesting. So I try to reproduce it here.\n\nCopyright may belong to Type-Moon or some other companies.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["cursoreffectinterestingtinystuff"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.1416;\nconst mat2 rot45 = mat2(0.7071,0.7071,-0.7071,0.7071);\n\nconst int max_count = 10;\nconst float cursorSize = 0.05;\n\nfloat rand(int x){\n    return fract(sin(float(x))*6735.0);\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus(vec2 c, float size, vec2 fragCoord){\n    //vec2 q = abs(fragCoord/iResolution.yy - c);\n\t//vec2 b = vec2(size);\n    //float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    //float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    //d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\t//return d;\n    \n    vec2 relaUV = fragCoord/iResolution.yy - c;\n\tvec2 rotatedUV = relaUV.xy * rot45;\n    vec2 diff = abs(rotatedUV)- vec2(size);\n    return length(max(diff,vec2(0))) + min(max(diff.x,diff.y),0.0);\n}\n\nvec4 gradientColor(float t, float dist){\n    vec3 col1 = 1.1*t*vec3(0.0,1.0,0.0) + (1.0-1.1*t)*vec3(0.0,0.0,1.0);\n    vec3 col2 = smoothstep(0.1,0.0,t)*vec3(0.6) + smoothstep(0.0,0.1,t)*col1;\n    \n    float alpha = exp(-4.0*abs(dist)) * t * t; //not finished.\n\treturn vec4(col2,alpha);\n}\n\nvec2 surround(vec2 pos, float dist, int i){\n    float angle = float(i)/10.0*pi*2.0 + pi/10.0* 2.0 *(2.0*rand(i*99)-1.0);\n    vec2 tran = vec2(dist*cos(angle), dist*sin(angle));\n    return pos + tran;\n}\n\nfloat subTime(float t, float delay, float scalar){\n    float sub1 = step(t,(1.0-delay))*t/(1.0-delay);// delay\n    float sub2 = max(0.0,(sub1-1.0+scalar)/scalar); //scale\n    return sub2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(0.0);//texture(iChannel1, uv);//vec4(col,1.0);//\n\n    //Cursor Effect\n    for(int i=0; i<max_count; i++){\n        vec2 pos = texelFetch(iChannel0, ivec2(i), 0).xy;\n        float t = texelFetch(iChannel0, ivec2(i), 0).z;\n        \n        if(t>0.0)\n        {\n            //center rhombus\n            float tPt = subTime(t,0.0,0.6); //delay 0.0, scale to 0.2 lifetime\n            vec2 center = pos/iResolution.yy;\n            float size = cursorSize*(3.0-2.0*t);\n            float distRbs = sdRhombus(center, size, fragCoord);\n            float dist = 0.0; //distance to the center of click\n            float index = 1.0 - step(0.0,distRbs);\n\n            vec4 colRbs = gradientColor(tPt, distRbs);//vec3(1.0);//(1.0-tLife)*vec3(0.0,1.0,0.0) + vec3(0.0,0.0,1.0);\n            colRbs = index*0.7* tPt * colRbs;\n            fragColor = fragColor + colRbs;\n\n            //surrounding rhombus\n            for(int c=0;c<35;c++){\n                float order = -0.01*float(c+1) + 1.0;\n                float scalar = 0.5*order;//*rand(c)\n                tPt = subTime(t, 0.05 + 0.4 *(1.0-order),0.4*rand(c));//\n\n                dist = cursorSize * (3.0-2.5*order);\n                center = surround(pos/iResolution.yy, dist, c);\n                size = cursorSize* tPt * 0.8*(0.8+0.2*rand(c*15));//*scalar\n                distRbs =  sdRhombus(center, size, fragCoord);\n                index = 1.0 - step(0.0,distRbs);\n\n                colRbs = gradientColor(1.0-tPt, distRbs);\n                colRbs = index*0.7*tPt * colRbs;\n\n                fragColor = fragColor + colRbs;\n            }\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//record the pos of clicking point. There should be a much better way to do this with a client program.\n//fragColor.xy = cursor position.xy\n//fragColor.z = life cycle: 1.0 when click, 0.0 when die out.\n\nconst int max_count = 10; //10 fingers at most for touch screen\nconst float decay = 0.015;\nconst float cursorSize = 0.05;\n\nvoid updateBuffer(vec4 mouse, inout vec4 fragColor, in ivec2 p){\n    vec4 buffer = vec4(mouse.xy, 1.0, 0.0);\n    if(mouse.z>0.0 && texelFetch(iChannel0, ivec2(max_count), 0).z==0.0){\n        for(int i=0; i<max_count; i++){\n            if(texelFetch(iChannel0, ivec2(i), 0).z==0.0){\n\n                {\n                    fragColor = (p==ivec2(i)) ? buffer : fragColor;\n                    fragColor.z = (p==ivec2(max_count)) ? 0.1*iFrameRate*decay : fragColor.z; //lock:time too short between 2 click\n                    break;\n                }\n                \n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ipx = ivec2(fragCoord-0.5);\n    fragColor = max(vec4(0.0), texelFetch(iChannel0, ipx, 0) - vec4(0.0,0.0,decay,0.0));\n\n    updateBuffer(iMouse, fragColor, ipx);\n}","name":"Buffer A","description":"","type":"buffer"}]}