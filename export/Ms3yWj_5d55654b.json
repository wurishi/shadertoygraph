{"ver":"0.1","info":{"id":"Ms3yWj","date":"1520179113","viewed":221,"name":"The hole","username":"Draedrus","description":"Black hole simple","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float S = 0.2;\nfloat C = 8.0;\nfloat T = 40.0;\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    // original code inspired from https://gamedev.stackexchange.com/questions/134520/creating-a-space-game-need-help-with-a-solution-for-creating-dynamic-spiral-gra#answer-135129\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 ouv = fragCoord/iResolution.xy;\n    //ouv.x *= iResolution.x/iResolution.y;\n    vec2 R = iResolution.xy, U = (u+u - R)/R.y;\n    \n    //vec2 uv = ouv * 2.0 - 1.0 - vec2(iResolution.x/iResolution.y*0.5, 0.0);\n\n    // Convert to polar coordinates.\n    float a = atan(U.y, U.x),\n        r = length(U),\n        l = max(0., 1. - r * (1. + S*(1.+sin(a*C+r*T-iTime*2.0))));\n    //float radius = length(U);\n\n\n    // Create a value that varies from 1 (normal falloff in the arms)\n    // to 2 * _ArmSharpness (accelerated falloff in the gaps between).\n    //float armBias = (sin(angle * C + radius * T - iTime*2.0) + 1.0) * S;\n\n    // Use this to bias our lookup value, which falls off with radius.\n    //float lookup = saturate(1.0 - radius * (armBias + 1.0));\n\n    // You could use this lookup to sample a gradient texture...\n    // fixed4 col = tex2D(_MainTex, lookup);\n    \n    //vec4 color = vec4(lookup * lookup, 3.0 * lookup - 2.0, lookup, 1.0);\n    \n    //vec4 bg = texture(iChannel0, u/iResolution.xy + color.rg);\n    \n    //color = \n    //    mix(saturate(color) * 8.0, bg, saturate(radius))\n    //            * (radius-0.3);\n    //color = mix(color * 4.0, bg, length(uv));\n    //color = vec4(length(uv));\n\n    // But here I'll just use it to calculate a purple-ish gradient:\n    //O = color;\n    O = vec4(l*l, 3.*l-2.,l,1);\n    O = mix(max(O, 0.)*8., texture(iChannel0, u/R + O.rg), min(1.,r))*(r-.3);\n}","name":"Image","description":"","type":"image"}]}