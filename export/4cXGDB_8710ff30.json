{"ver":"0.1","info":{"id":"4cXGDB","date":"1703424776","viewed":18,"name":"Cybertruck Wiper! :-D","username":"KaleyGoode","description":"Animated line, just for fun","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["hue","wiper","cybertruck"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define    pi 3.14159265359\n#define   tau (2.*pi)\n#define  gold vec3(.9,.8,.4)\n#define black vec3(0)\n#define white vec3(1)\n\nfloat   Signed(float x)          {return 2.* x-1. ;} // Unsigned Unit Interval [ 0,1] to   Signed UI [-1,1]\nfloat Unsigned(float x)          {return .5*(x+1.);} //   Signed Unit Interval [-1,1] to Unsigned UI [ 0,1]\nfloat Lower   (float n, float t) {return clamp(n* t       ,0.,1.);} // if n=5, returns the lower fifth spread out to [0,1]\nfloat Upper   (float n, float t) {return clamp(n*(t-1.)+1.,0.,1.);} // t-(n-1)/n; if n=5, returns the upper fifth spread out to [0,1]\n\nfloat GetGreen(float t) {\n  t -= floor(t); // Use the fractional part of parameters that may infinitely cycle (like sine).\n       if(t<1./6.) return    6.*t; //        1 __\n  else if(t<3./6.) return 1.;      // Green: |/  \\__\n  else if(t<4./6.) return 4.-6.*t; //        0--t---1\n                   return 0.;\n}\nvec3 FromHue(float hue) { // hue [0,1] where 0=red\n  return vec3(GetGreen(hue+1./3.),\n              GetGreen(hue      ),\n              GetGreen(hue-1./3.));\n}\n\n// Values are unit intervals (relative to uv)\n// px is the current pixel coord (fragCoord)\n// p0,p1 are the start and end points of the line\nvoid line(inout vec3 color, in vec3 lineColor, in float alpha, in float blur,\n          in    vec2 p0   , in vec2 p1       , in vec2  px   , in float width, in bool goo) {\n  vec2  h = px-p0, // Vector from current pixel to line start point (hypotenuse)\n        a = p1-p0; // Direction vector along line (adjacent)\n  float t = clamp(dot(h,a)/dot(a,a), 0.,1.), // Parametric t along line segment [0,1]\n        d = length(h - t*a),         // Distance from current pixel to line (length of opposite)\n       dw = fwidth(d)*(1.+10.*blur); // Antialiasing width\n  if(goo && (length(a)>3.*width)) width *= 1.-2.*t*(1.-t);\n  color = mix(color, lineColor, alpha*(1.-smoothstep(width-dw, width+dw, d)));\n}\n\n//###################################################################################################################\nvoid mainImage(out vec4 o, in vec2 fragCoord) {\n  float rPx = .5*min(iResolution.x, iResolution.y); // Radius in pixels\n  vec2   uv = (fragCoord.xy-.5*iResolution.xy)/rPx,\n   position = vec2(.2);\n  float r = length(uv),\n        d = distance(uv,position);\n  vec3  color = black;\n/*__Cybertruck Wiper__________________________________________________________________________________________________\nThin line colour-changing line:\nWipe using p0,p1 for .5*pi\nAltering the x and y component signs for each corner could be done with a 2-bit count/state,\nhowever, the sin and cos signs coincide usefully with the x and y signs\n # binary corner:\n 0   00 = -x -y Bottom Left\n 1   01 = +x -y Bottom Right\n 2   10 = +x +y    Top Right\n 3   11 = -y +y    Top Left */\n  float a = iTime,\n        s = sin(a),\n        c = cos(a);\n  vec2 p0 = (vec2(10,10)-.5*iResolution.xy)/rPx, // mapping the pixel coord (10,10) to uv for the Line function\n       p1 = p0 + .98*iResolution.xy * vec2(abs(sin(a)),abs(cos(a)))/rPx; // Quarter circle wipe\n  bool dx = (c<0.), // Flags to select which corner to wipe from:\n       dy = (s<0.);\n  line(color,FromHue(s), 1.,.1, vec2((dx ? p0.x : -p0.x),(dy ? p0.y : -p0.y)),\n                                vec2((dx ? p1.x : -p1.x),(dy ? p1.y : -p1.y)), uv, .01, false);\n  o = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}