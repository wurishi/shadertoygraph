{"ver":"0.1","info":{"id":"X3SBWV","date":"1729937007","viewed":39,"name":"Example: SDF Distance Lines","username":"ElliotPadfield","description":"This shader renders a 2D circle using Signed Distance Functions (SDFs), with translation and aspect ratio correction for consistent scaling.\nUV Normalization: Adjusts UVs for aspect ratio to avoid stretching. Shows Distance lines for SDF Visualisation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["example"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference: https://www.ronja-tutorials.com/post/034-2d-sdf-basics/\n\n// Properties for line controls\nfloat _SubLines = 1.0;                // Lines between major lines\nfloat _SubLineThickness = 0.01;       // Thickness of in-between lines\nfloat _LineDistance = 0.2;            // Distance between major lines\nfloat _LineThickness = 0.015;          // Thickness of major lines\nvec3 _InsideColor = vec3(0.2, 0.4, 1.0); // Color inside the circle\nvec3 _OutsideColor = vec3(1.0, 1.0, 1.0); // Color outside the circle\n\n// SDF for a circle\nfloat sdCircle(vec2 p, float radius) {\n    return length(p) - radius; // Distance to circle edge\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Step 1: Normalize UV coordinates with aspect ratio correction\n    // https://www.shadertoy.com/view/lf2fWw\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.0 * fragCoord - R) / min(R.x, R.y); // Normalize to [-1, 1] along the shortest side\n\n    // Step 2: Define circle parameters\n    float radius = 0.3;\n    float dist = sdCircle(uv, radius); // Distance from current point to circle\n\n    // Step 3: Base color based on inside or outside the circle\n    vec3 col = mix(_InsideColor, _OutsideColor, step(0.0, dist));\n\n    // Step 4: Calculate the distance change for anti-aliasing\n    float distanceChange = fwidth(dist) * 0.5;\n\n    // Step 5: Major lines based on the main line distance\n    float majorLineDistance = abs(fract(dist / _LineDistance + 0.5) - 0.5) * _LineDistance;\n    float majorLines = smoothstep(_LineThickness - distanceChange, _LineThickness + distanceChange, majorLineDistance);\n\n    // Step 6: Sub-lines between major lines\n    float distanceBetweenSubLines = _LineDistance / _SubLines;\n    float subLineDistance = abs(fract(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines;\n    float subLines = smoothstep(_SubLineThickness - distanceChange, _SubLineThickness + distanceChange, subLineDistance);\n       \n    // Step 5: Anti-aliasing for smooth edges\n    // https://www.shadertoy.com/view/MfjBDw\n    float pix = 1.5 / min(R.x, R.y); // Pixel width (Adjusted to use min(R.x, R.y) for consistent pixel scaling)\n    float aa = smoothstep(-pix / 2., pix / 2., dist); // Adjusted smoothstep for smoother anti-aliasing transition\n\n    // Step 7: Final color with applied major and sub-line effects\n    fragColor = vec4(col * majorLines * subLines, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}