{"ver":"0.1","info":{"id":"3l2SD3","date":"1567324517","viewed":91,"name":"Boxed cat","username":"Tesselator","description":"A minecraft-style cat","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdfcat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define surface vec2\n\n#define matHead 1.0\n#define matBody 1.0\n#define matFloor 2.0\n#define matEye 3.0\n#define matOko 4.0\n#define matNose 5.0\n#define matFish 6.0\n#define matFishTail 8.0\n#define matFishHead 7.0\n#define matSun 9.0\n\n#define bgColor 1.0\n#define floorColor 1.0\n#define headColor 1.0, 0.5, 0.1\n#define eyeColor 1.0\n#define okoColor 0.0, 1.0, 0.0\n#define noseColor 1.0, 0.0, 1.0\n#define fishColor 1.0, 0.0, 0.0\n#define fishHeadColor 1.0, 0.0, 1.0\n#define fishTailColor 1.0, 0.5, 0.3\n#define sunColor 5.0, 5.0, 0.0\n\n#define floorPos 0.0\n#define floorSize 20.0, 1.0, 20.0\n#define headPos 0.0, 5.0, 5.0\n#define tailPos 0.0, 5.0, -6.0\n#define bodyPos 0.0, 5.0, 0.0\n\n#define farAway 50.0\n\nstruct hitInfo {\n    vec3 pos;\n    vec3 norm;\n    float matId;\n};\n    \nvec3 light = vec3(0.0, 30.0, 0.0);\n\nmat3 rotateX( float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c);\n}\n    \nmat3 rotateY( float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n}\n\nmat3 rotateZ( float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(c, -s, 0.0, s, c, 0.0, 0.0, 0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b * 0.5;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nsurface combine( surface d1, surface d2 )\n{\n    return (d1.x <= d2.x) ? d1 : d2; \n}\n\nsurface subtract( surface d2, surface d1 )\n{\n    return (-d1.x >= d2.x) ? d1 : d2; \n}\n\nsurface opAdd( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5 * (d2.x - d1.x) / k, 0.0, 1.0 );\n    float m = (d1.x <= d2.x) ? d1.y : d2.y;\n    return surface(mix( d2.x, d1.x, h ) - k*h*(1.0-h), m); }\n\nsurface opSub( surface d2, surface d1, float k ) {\n    float h = clamp( 0.5 - 0.5 * (d2.x + d1.x) / k, 0.0, 1.0 );\n    float m = (-d1.x >= d2.x) ? d1.y : d2.y;\n    return surface(mix( d2.x, -d1.x, h ) + k*h*(1.0-h), m); }\n\nsurface Head( vec3 p )\n{\n    surface h = surface(sdBox( p - vec3(0.0, 1.0, 2.0), vec3(5.0) ), matHead);\n    h = combine(h, surface(sdBox( p - vec3(1.5, 4.0, 0.5), vec3(2.0, 1.0, 2.0)), matHead));\n    h = combine(h, surface(sdBox( p - vec3(-1.5, 4.0, 0.5), vec3(2.0, 1.0, 2.0)), matHead));\n    h = combine(h, surface(sdBox( p - vec3(0.0, 0.0, 5.0), vec3(1.0)), matNose));\n    \n    h = combine(h, surface(sdBox( p - vec3(-1.5, 1.5, 5.0), vec3(2.0, 2.0, 1.0)), matEye));\n    h = combine(h, surface(sdBox( p - vec3( 1.5, 1.5, 5.0), vec3(2.0, 2.0, 1.0)), matEye));\n    h = opSub(h, surface(sdBox( p - vec3(-1.5, 1.5, 5.5), vec3(0.1, 1.5, 0.2)), matOko), 0.1);\n    h = opSub(h, surface(sdBox( p - vec3( 1.5, 1.5, 5.5), vec3(0.1, 1.5, 0.2)), matOko), 0.1);\n    return h;\n}\n\nsurface Tail( vec3 p )\n{\n    surface m = surface(sdBox( p - vec3( 0.0, 1.0, 0.0), vec3(1.0, 2.0, 1.0)), matBody);\n    m = combine(m, surface(sdBox( p - vec3( 0.0, 2.0, -1.0), vec3(1.0, 2.0, 1.0)), matBody));\n    m = combine(m, surface(sdBox( p - vec3( 0.0, 0.0, -2.0), vec3(1.0, 4.0, 1.0)), matBody));\n\treturn m;\n}\n\nsurface FishTail( vec3 p )\n{\n    surface m = surface(sdBox( p - vec3( 0.0, 0.0, 0.0), vec3(1.0, 2.0, 1.0)), matFishTail);\n    m = combine(m, surface(sdBox( p - vec3( 0.0, 0.0, -1.0), vec3(1.0, 4.0, 1.0)), matFishTail));\n\treturn m;\n}\n\nsurface Fish( vec3 p )\n{\n    surface m = surface(sdBox(p, vec3(1.0, 2.0, 4.0)), matFish);\n    m = combine(m, surface(sdBox(p - vec3(0.0, 0.0, 2.0), vec3(1.0, 2.0, 2.0)), matFishHead));\n    m = combine(m, surface(sdBox(p - vec3(-0.5, 0.0, 2.0), vec3(0.5)), matEye));\n    m = combine(m, surface(sdBox(p - vec3(+0.5, 0.0, 2.0), vec3(0.5)), matEye));\n    mat3 r = rotateY(0.5 * sin(8.0 * iTime + 1.0));\n\tm = opAdd(m, FishTail(r * (p - vec3(0.0, 0.0, -2.75))), 0.75);\n    return m;\n}\n\nsurface CatLeg( vec3 p )\n{\n    return surface(sdBox(p - vec3(0.0, -2.0, 0.0), vec3(1.0, 4.0, 1.0)), matBody);\n}\n\nsurface Cat( vec3 p )\n{\n    mat3 r = rotateX(0.5 * sin(iTime)) * rotateY(0.5 * sin(iTime));\n    surface m = Head( r * (p - vec3(headPos)));\n    m = combine(m, surface(sdBox( p - vec3(0.0, 5.0, -0.5), vec3(3.0, 2.0, 10.0)), matBody));\n\n    m = combine(m, CatLeg( rotateX(0.5 * sin(5.0 * iTime + 0.0)) * (p - vec3(-1.0, 4.0, 3.0))));\n    m = combine(m, CatLeg( rotateX(0.5 * sin(5.0 * iTime + 1.0)) * (p - vec3( 1.0, 4.0, 1.0))));\n    m = combine(m, CatLeg( rotateX(0.5 * sin(5.0 * iTime + 2.0)) * (p - vec3(-1.0, 4.0, -2.0))));\n    m = combine(m, CatLeg( rotateX(0.5 * sin(5.0 * iTime + 3.0)) * (p - vec3( 1.0, 4.0, -4.0))));\n\n    r = rotateY(0.5 * sin(4.0 * iTime));\n    m = opAdd(m, Tail(r * (p - vec3(tailPos))), 0.5);\n    return m;\n}\n\nsurface SmallCat( vec3 p )\n{\n    surface c = Cat( p / 0.5 );\n    c.x *= 0.5;\n    return c;\n}\n\nsurface SmallFish( vec3 p )\n{\n    surface c = Fish( p / 0.5 );\n    c.x *= 0.5;\n    return c;\n}\n\nfloat grey( vec3 c )\n{\n    return dot(c, vec3(0.3, 0.59, 0.11));\n}\n\nvec3 srgb( vec3 c )\n{\n    return -log(1.0 - c);\n}\n\nfloat hf(sampler2D field, vec3 p, vec3 size)\n{\n    float d = length(p.xz);\n    if( d < 20.0 )\n    \treturn 0.001 * grey(texture(field, p.xz / size.xz).rgb) - p.y;\n    else\n        return d;\n}\n\nsurface map( vec3 p, bool sunEnabled )\n{\n//    surface m = surface( hf(iChannel0, p - vec3(floorPos), vec3(floorSize)), matFloor);\n    surface m  = surface( sdBox( p - vec3(floorPos), vec3(floorSize) ), matFloor);\n\tm = combine(m, Cat(rotateX(0.1 * cos(4.0 * iTime)) * rotateY(-0.75 * iTime) * p - vec3(-7.0, abs(sin(4.0 * iTime)), 0.0)));\n\tm = combine(m, SmallCat( rotateY(-1.5 * iTime) * p - vec3(-5.0, abs(sin(8.0 * iTime)), 0.0)));\n    m = combine(m, Fish(rotateY(iTime) * p - vec3(14.0, -3.0, 0.0)));\n    m = combine(m, SmallFish(rotateY(iTime - 0.7) * p - vec3(14.0, -3.0, 0.0)));\n\tif(sunEnabled)\n    \tm = combine(m, surface(sdSphere( p - light, 1.0 ), matSun));\n    return m;\n}\n    \nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.0001; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h, false ).x + \n                      k.yyx*map( p + k.yyx*h, false ).x + \n                      k.yxy*map( p + k.yxy*h, false ).x + \n                      k.xxx*map( p + k.xxx*h, false ).x );\n}\n\nvec3 matColor( const float m, const vec3 p )\n{\n    if(m == matHead) return vec3(headColor);\n    if(m == matFloor) return srgb(texture(iChannel0, p.xz * 0.1).xyz);\n    if(m == matEye) return vec3(eyeColor);\n    if(m == matOko) return vec3(okoColor);\n    if(m == matNose) return vec3(noseColor);\n    if(m == matFish) return vec3(fishColor);\n    if(m == matFishHead) return vec3(fishHeadColor);\n    if(m == matFishTail) return vec3(fishTailColor);\n    if(m == matSun) return vec3(sunColor);\n    return vec3(bgColor);\n}\n\nbool castRay( const vec3 ro, const vec3 rd, out hitInfo hit )\n{\n    float t = 0.001;\n    float m = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 h = map(p, true);\n        m = h.y;\n        if( abs(h.x) < 0.001 || t > farAway ) break;\n        t += h.x;\n    }\n\n    if( t < farAway )\n    {\n        hit.pos = ro + t * rd;\n        hit.norm = calcNormal(hit.pos);\n        hit.matId = m;\n        return true;\n    }\n    else\n        return false;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 0.9;\n    for( float t = 0.0; t < farAway; )\n    {\n        vec2 h = map(ro + rd*t, false);\n        if( h.x < 0.001 )\n            return 0.0;\n        res = min( res, k*h.x/t );\n        t += h.x;\n    }\n    return res;\n}\n\nvec3 render(const hitInfo hit, vec3 lightPos)\n{\n    if(hit.matId == matSun) return vec3(sunColor);\n    vec3 lightDir = normalize(lightPos - hit.pos);\n    float shadow = softshadow(hit.pos + hit.norm * 0.001, lightDir, 10.0);\n    if(shadow > 0.0)\n    {     \n    \tfloat dif = clamp(dot(hit.norm, lightDir),0.0,1.0);\n    \treturn dif * matColor(hit.matId, hit.pos) * shadow;\n    }\n    return vec3(0.0);\n}\n#define camRotSpeed 0.01\n#define camPos 0.0, 5.0, 20.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    mat3 c = rotateY(-(iMouse.x - iResolution.x * 0.2) * camRotSpeed);\n    \tc *= rotateX(-(iMouse.y - iResolution.y * 0.4) * camRotSpeed);\n    vec3 targetPos = vec3(bodyPos);\n    vec3 eye = c * (vec3(camPos) - targetPos) + targetPos;    \n    c[2] = normalize(targetPos - eye);\n    c[0] = normalize(cross(c[2], vec3(0.0, 1.0, 0.0)));\n    c[1] = normalize(cross(c[0], c[2]));\n    \n    vec3 ro = eye;\n    vec3 rd = c * normalize(vec3(uv.x, uv.y, 1.0));\n\thitInfo hit;\n//    light = vec3(30.0 * cos(0.1 * iTime), 30.0 * sin(0.1 * iTime), 0.0);\n    vec3 col = vec3(0.0);\n    if(castRay(ro, rd, hit)) {\n        col = render(hit, light);\n    }\n    else\n        col = srgb(texture(iChannel1, rd).xyz);\n\n   // Exposure tone mapping\n    vec3 mapped = vec3(1.0) - exp(-col * 1.0);\n   // Reinhard tone mapping\n//    vec3 mapped = col / (col + vec3(1.0));\n   // gamma correction \n\t//mapped = pow(mapped, vec3(1.0 / 1.6));\n    fragColor = vec4(mapped,1.0);\n}","name":"Image","description":"","type":"image"}]}