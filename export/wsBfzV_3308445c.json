{"ver":"0.1","info":{"id":"wsBfzV","date":"1590416491","viewed":283,"name":"Inside frame","username":"gaz","description":"inspired https://www.shadertoy.com/view/ltGSW1","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["volumetric","fold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 ro=eye(iTime);\n    vec3 ta =target(iTime);\n    vec3 rd=normalize(light(iTime)-ro)*lookat(ro,ta,vec3(0,1,0));\n    rd*=1.0/rd.z;\n\tvec2 co=rd.xy;\n    co.y*=iResolution.x/iResolution.y;\n    co=co*0.5+0.5;    \n    // https://www.shadertoy.com/view/ls2Xzd\n    // a radial blur\n    float itr = 100.0;\n    vec2 uv0=uv;\n    vec2 delta = (uv0-co)/itr;\n    delta *= 1.2;\n    vec3 col = vec3(0);\n    float decay=1.0;\n    for (float i = 0.0; i < itr; i++)\n\t{\n        col += 0.05*decay*textureLod(iChannel1, uv0,0.0).xyz;\n        uv0 -= delta;\n        decay *= 0.985;\n    }  \n    col=min(vec3(1),col);\n    // If you comment out the following line, you can see the picture of radial blur.\n    col+=textureLod(iChannel0, uv,0.0).xyz;\n    fragColor = vec4(col,1.0);\n    \n    // mask\n    //fragColor =textureLod(iChannel1, uv,0.0);\n    // base picture \n    //fragColor =textureLod(iChannel0, uv,0.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat lpNorm(vec3 p, float n)\n{\n\tp = pow(abs(p), vec3(n));\n\treturn pow(p.x+p.y+p.z, 1.0/n);\n}\n\nvec2 pSFold(vec2 p,float n)\n{\n    float h=floor(log2(n)),a =6.2831*exp2(h)/n;\n    for(float i=0.0; i<h+2.0; i++)\n    {\n\t \tvec2 v = vec2(-cos(a),sin(a));\n\t\tfloat g= dot(p,v);\n \t\tp-= (g - sqrt(g * g + 5e-3))*v;\n \t\ta*=0.5;\n    }\n    return p;\n}\n\nvec2 sFold45(vec2 p, float k)\n{\n    vec2 v = vec2(-1,1)*0.7071;\n    float g= dot(p,v);\n \treturn p-(g-sqrt(g*g+k))*v;\n}\n\nfloat frameBox(vec3 p, vec3 s, float r)\n{   \n    p = abs(p)-s;\n    p.yz=sFold45(p.yz, 1e-3);\n    p.xy=sFold45(p.xy, 1e-3);\n    p.x = max(0.0,p.x);\n\treturn lpNorm(p,5.0)-r;\n}\n\nfloat deObj(vec3 p)\n{   \n    p.z=mod(p.z,4.)-2.;\n    p.xy=mod(p.xy,10.)-5.;\n    p.xy=pSFold(p.xy,8.0);\n    p.y-=0.8;\n    for(int i=0;i<2;i++)\n    {\n        p.xy*=rot(1.6);\n        p.xy=abs(p.xy)-1.0;\n        p.xz*=rot(0.3);\n        p.xz=abs(p.xz)-1.8;\n    }\n\t return min(0.5,frameBox(p,vec3(0.8),0.1));\n}\n\n//+++++++++++++++++++++++++++++++\n#define PI acos(-1.0)\n#define TAU PI*2.0\n\n#define hash(n) fract(sin(n)*5555.0)\nvec3 randVec(float n)\n{\n    float a=(hash(n)*2.-1.)*TAU,b=asin(hash(n+215.3)*2.-1.);\n    return vec3(cos(a),sin(a)*cos(b),sin(a)*sin(b));\n}\n\nvec3 randCurve(float t,float n)\n{\n    t*=0.15;\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++)\n    {\n        p += randVec(n+=365.)*sin((t*=1.3)+sin(t*0.6)*0.5);\n    }\n    return p;\n}\n\nconst float maxd=50.0;\n\nvec3 eye(float time){\n    float seed=12713.0;\n    return randCurve(time,seed)*5.0;\n}\n\nvec3 target(float time){\n    float seed=12713.0;\n    return randCurve(time+2.5,seed)*5.0;\n    return vec3(0);\n}\n\nvec3 light(float time){\n    return target(time)+randCurve(time,5523.0)*1.5;\n    return vec3(0,0.5,3);\n}\n\nmat3 lookat(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 w = normalize(target-eye), u = normalize(cross(w,up));\n    return mat3(u,cross(u,w),w);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float deLight(vec3 p)\n{\n    return length(p-light(iTime))-.2;\n}\n\nfloat map(vec3 p)\n{\n    return min(deLight(p),deObj(p));\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nfloat calcShadow( vec3 light, vec3 ld, float len ) {\n\tfloat depth = march( light, ld, 0.0, len );\t\n\treturn step( len - depth, 0.01 );\n}\n\nvec3 doColor(vec3 p)\n{\n    if(deLight(p)<0.001) return vec3(1);\n    return vec3(0.3,0.5,0.8)+cos(p*0.2)*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=eye(iTime);\n    vec3 ta =target(iTime);\n    vec3 rd=lookat(ro,ta,vec3(0,1,0))*normalize(vec3(uv,2.0));\n    vec3 col= vec3(0);\n    float t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        col=doColor(p); \n        vec3 n = calcNormal(p);      \n\t\tvec3 lightPos=light(iTime);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        float sha = calcShadow( lightPos, -li, len );\n        col *= max(sha*dif, 0.2);\n        float rimd = pow(clamp(1.0 - dot(reflect(-li, n), -rd), 0.0, 1.0), 2.5);\n\t\tfloat frn = rimd+2.2*(1.0-rimd);\n    \tcol *= frn*0.8;\n        col *= max(0.5+0.5*n.y, 0.0);\n        col *= exp2(-2.*pow(max(0.0, 1.0-map(p+n*0.3)/0.3),2.0));\n        col += vec3(0.8,0.6,0.2)*pow(clamp(dot(reflect(rd, n), li), 0.0, 1.0), 20.0);\n        col = mix(vec3(0.0),col,  exp(-0.001*t*t));\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float deLight(vec3 p)\n{\n    return length(p-light(iTime))-0.4;\n}\n\nfloat map(vec3 p)\n{\n    return min(deLight(p),deObj(p));\n}\n\nfloat march(vec3 ro, vec3 rd, float near, float far)\n{\n    float t=near,d;\n    for(int i=0;i<100;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) return t;\n        if (t>=far) return far;\n    }\n    return far;\n}\n\nvec3 doColor()\n{\n    return vec3(.9,.6,.2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro=eye(iTime);\n    vec3 ta =target(iTime);\n    vec3 rd=lookat(ro,ta,vec3(0,1,0))*normalize(vec3(uv,2.0));\n    vec3 col= vec3(0);\n    float t=march(ro,rd,0.0,maxd);\n    if(t<maxd)\n    {\n        vec3 p=ro+rd*t;\n        if(deLight(p)<0.001)col=doColor();\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}