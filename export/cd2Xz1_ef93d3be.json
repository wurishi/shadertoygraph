{"ver":"0.1","info":{"id":"cd2Xz1","date":"1670134887","viewed":570,"name":"𝑫𝒆𝒂𝒅 𝑳𝒆𝒂𝒗𝒆𝒔","username":"Poisson","description":"Some 2d dead leaves mapped on 3d raytraced spheres with a Skyrim music.","likes":48,"published":1,"flags":96,"usePreview":1,"tags":["2d","3d","raytracing","raytracer","ray","volume","bokeh","volumetric","bloom","glow","leave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ltjSWw","filepath":"https://soundcloud.com/matija-hulina/skyrim-music-ambience-night","previewfilepath":"https://soundcloud.com/matija-hulina/skyrim-music-ambience-night","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Buffer A - main rendering\n// Buffer B - bokeh dof \n\n// tonemap\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// bloom function\nvec4 bloom(sampler2D sam, vec2 p) {\n    vec4 col = vec4(0);\n    const int N = 8;\n    \n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++) {\n        vec2 off = vec2(i,j) / float(N);\n        col += textureLod(sam, p+off*.04, 3.);\n    }\n    return col/col.a;\n}\n\n// radial blur function\n// v is the direction vector\nvec4 radialBlur(sampler2D sam, vec2 p, vec2 v) {\n    vec4 col = vec4(0);\n    const float N = 64.; // samples\n    \n    for (float i=0.; i<1.; i+= 1./N) {\n        col += pow(1.-sqrt(i),3.)*texture(iChannel0, p+.3*i*v);\n    }\n    \n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n\n    // base color\n    vec3 col = texture(iChannel0, p).rgb;\n    // bloom\n    vec3 bloom = pow(bloom(iChannel0, p).rgb, vec3(2));\n    // radial blur\n    vec2 v = normalize(vec2(1)-p); // direction\n    vec3 blur = .2*radialBlur(iChannel0, p, v).rgb;\n    \n    col += blur;\n    col = pow(col, vec3(.4545)); // gamma correction\n    col += bloom;\n    \n    col = ACES(col);\n    col = mix(col, dot(col, vec3(1))/vec3(3), -.6); // boost the saturation\n    col = pow(col, vec3(.84,1,.9)); // color grade\n        \n    // vignette\n    col *= pow(64.*p.x*p.y*(1.-p.x)*(1.-p.y),.1);\n        \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// time\n#define time iTime\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// hash vec2 to float\nfloat hash21(vec2 p) {\n    p = fract(p*vec2(452.127,932.618));\n    p += dot(p, p+123.23);\n    return fract(p.x*p.y);\n}\n\n// noise function by me\nfloat noise(vec2 p) {\n    vec2 q = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.-2.*f);\n    return mix(mix(hash21(q+vec2(0,0)),hash21(q+vec2(1,0)),f.x),\n               mix(hash21(q+vec2(0,1)),hash21(q+vec2(1,1)),f.x),f.y);\n}\n\n// fractal noise\nfloat fbm(vec2 p) {\n    float f = 0.;\n    f += .5*noise(p);\n    f += .25*noise(p*2.);\n    f += .125*noise(p*4.);\n    f += .0625*noise(p*8.);\n    return f;\n}\n\n// leave sdf\nfloat sdLeave(vec2 p) {    \n    float d = length(p*vec2(1,.9)-vec2(0,.02))-.2+.9*abs(p.x);\n      \n    p.x = abs(p.x);\n    \n    vec2 q = p;\n    q -= vec2(0,-.2+32.*pow(p.x,5.));\n    q *= rot(3.141592*.3+.1*fbm(16.*p));\n    q -= vec2(0,.17);\n    d = min(d, length(q)-.17+2.*abs(q.x));\n    \n    q = p;\n    q -= vec2(-.07,-.1+6.*pow(p.x,3.));\n    q *= rot(3.141592*.7+.1*fbm(24.*p));\n    q -= vec2(0,.13);\n    d = min(d, length(q)-.13+2.5*abs(q.x));\n    \n    // stem\n    q = p;\n    float h = clamp(q.y,-.377,0.);\n    q -= vec2(0,h);\n    d = min(d+.2*pow(fbm(24.*p),3.), length(q)+.02*h);\n\n    return d;\n}\n\n// sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    if(h<0.) return vec2(-1);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// 3d cartesian to 2d polar coordinates\nvec2 polar(vec3 p) {\n    return vec2(atan(p.x,p.z),p.y);\n}\n\n// leave in 3d\nfloat leaveSphere(vec3 col, vec3 ro, vec3 rd, vec3 ce, vec2 an, float ra) {\n    vec2 t = sphIntersect(ro, rd, ce, ra);\n    \n    if (t.y<0.) return 0.; // no intersection\n    \n    vec3 oc = ro - ce;\n    vec3 p = oc + rd*t.x; // front point\n    vec3 q = oc + rd*t.y; // back point\n\n    // rotation, very ugly code\n    p.xz *= rot(an.x);\n    q.xz *= rot(an.x);\n    p.yz *= rot(an.y);\n    q.yz *= rot(an.y);\n       \n    \n    float di = ra*2.; // diameter\n    vec2 r = vec2(ra,1)/di; // ratio\n    vec2 pf = polar(p)*r; // polar front point\n    vec2 pb = polar(q)*r; // polar back point\n        \n    // leave back and front\n    float lf = step(sdLeave(pf), 0.);\n    float lb = step(sdLeave(pb), 0.);\n        \n    // return alpha values\n    return lf*(1.-lb)+lb;\n}\n\n// hash functions by me\nfloat hash1(inout float n) {return fract(sin(n+=1.)*2348.3241);}\n\nvec2 hash2(inout float n) {return fract(sin(n+=1.)*vec2(2348.3241,4591.5392));}\n\nvec3 hash3(inout float n) {return fract(sin(n+=1.)*vec3(2348.3241,4591.5392,3412.4231));}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n        \n    vec2 an = time*vec2(.2,.3); // angle\n    \n    for (float i=0.; i<1.; i+=1./80.) { // generate 80 leaves\n        float n = i+1.; // randoms seed\n        // xy point\n        vec2 p = (.5-fract(hash2(n)+vec2(-.06,.05)*time))*vec2(15,13);\n        \n        // change the angle\n        an += hash1(n)-.5;\n        \n        // color\n        vec3 mat = hash3(n);\n        mat = vec3(.3+.7*mat.r,.3+.7*mat.g*mat.g,mat.b);\n        \n        vec3 ce = vec3(p,8.*(1.-i)); // center\n        float ra = .7+.6*hash1(n); // radius\n        \n        // alpha value\n        float alpha = leaveSphere(col, ro, rd, ce, 3.141592*an, ra);\n        \n        col = mix(col, mat, alpha);\n    }\n    \n    // light direction\n    vec3 lig = vec3(.57735026919);\n    \n    // light glare + noise to simulate volumetric scattering in fog\n    float glare = pow(clamp(dot(rd, lig),0.,1.),16.);\n    col += .8*fbm(12.*rd.xy+.1*time*vec2(1,3))*(.004+glare);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates centered at the origin\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0,0,-3); // ray origin\n    vec3 rd = normalize(vec3(p,1.5)); // ray direction\n\n    vec3 col = render(ro, rd);\n    \n    // output\n    fragColor = vec4(col*1.2,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// bokeh dof buffer\n\n// bokeh function\nvec4 bokeh(sampler2D sam, vec2 p, float b) {    \n    vec4 col = vec4(0);\n    const int N = 6; // samples\n        \n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++) {\n        vec2 off = vec2(i,j) / float(N); // offset\n\n        if (dot(off, off)<1.) { // inside disk\n            // blurred image\n            col += texture(iChannel0, p + b*off*vec2(9./16.,1));\n        }\n    }\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n\n    float b = dot(p-.6,p-.5)*.05; // blur value\n    vec3 col = bokeh(iChannel0, p, b).rgb;\n        \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}