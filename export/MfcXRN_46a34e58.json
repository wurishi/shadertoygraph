{"ver":"0.1","info":{"id":"MfcXRN","date":"1713636788","viewed":36,"name":"toon bubble inflation","username":"Kolaa","description":"a combination of spheres with 3d noises\nmade for a vocaloid music project\nsee the final result on https://ior.works","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","modeling","bubble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define BUB_EX_N 2\nvec3[BUB_EX_N] bub_p0 = vec3[](\n    vec3(0.4,-0.35,0.0),\n    vec3(0.45,-0.25,0.)\n);\nvec3[BUB_EX_N] bub_p1 = vec3[](\n    vec3(0.0,0.7,0),\n    vec3(0.1, 0.18, 0.)\n);\n\nfloat [BUB_EX_N] bub_exp = float[](\n        1.0,\n        0.5\n);\n\n// R0, R1, K\nvec3[BUB_EX_N] bub_r = vec3[](\n        vec3(0, 0.8, 0.75),\n        vec3(0, 0.25, .25)\n);\n// AMP, SCALE, SPD\nvec3[BUB_EX_N] bub_noise = vec3[](\n    vec3(0.02, 1.6, 1.),\n    vec3(0.01, 0.5, 1.)\n);\nfloat phaseTrans = 0.;\nfloat phaseScale =0.5;\n#define NOISE_FLOW 2.5\nfloat map(vec3 p){\n    float result = sdSphere(\n                                translate(p, vec3(0.47,-0.29,0))\n                            ,0.125);\n\n    for (int i = 0; i < BUB_EX_N; i++){\n        // mixing\n        float fac = clamp01(pow ( phaseTrans, exp2(bub_exp[i])));\n        vec3 pos = mix (bub_p0[i], bub_p1[i]  , fac);\n        float r = mix (bub_r[i].x, bub_r[i].y  , fac);\n        float ks = fac * bub_r[i].z;\n        //noise?\n        vec3 noise = vec3(0.);\n\n        vec3 posNz = pos + normalize(p-pos) * r;\n        float nAmp = bub_noise[i].x;\n        float nScale = bub_noise[i].y;\n        float nSpd = bub_noise[i].z;\n\n        vec3 cnIn = posNz * nScale;\n        cnIn.z -=  iTime * nSpd * NOISE_FLOW / nScale;\n        float r1 = r + (cnoise( cnIn) *2.0 - 1.0 ) * nAmp;\n\n        result = opSmoothUnion(result,\n                               sdSphere(translate(\n                                       p, pos + noise\n                                             ), r1),\n                               ks\n        );\n    }\n\n    return result;\n}\n#define HIT_EPSL 0.0001\n#define NORM_EPSL 0.005\nvec3 norm(vec3 p){\n    vec2 e = vec2(NORM_EPSL,0.);\n    return normalize( map(p)-vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    phaseTrans = sin(iTime*TAU /4.) *0.6 + .5;\n    phaseTrans = clamp01(phaseTrans);\n    vec2 uv = vec2(2.*fragCoord.x,2.*fragCoord.y)/iResolution.x;\n    uv+=vec2(-1.0,-iResolution.y/iResolution.x);\n    uv+=vec2(0.,0.24); // for display\n    uv /= phaseScale;\n    float d =1.0e10;\n    bool hit = false;\n    vec3 trace =vec3(uv.x,uv.y, -10.0);\n    vec3 dir = vec3(0,0,1);\n    for (int i =0; i<24; i++){\n        d= map(trace);\n        if (d < HIT_EPSL) {hit=true;break;}\n        trace+=d*dir;\n        if (trace.z > 10.) break;\n    }\n\n    float u =uv.x, v=uv.y;\n    fragColor = vec4(0.);\n    if (hit){\n\n\n        vec3 nm = norm(trace);\n        float v = dot(nm, vec3(0.,0.,-1.));\n        v = clamp01(1.-v);\n        float vOrig = v;\n        v = scaleFloat( v, 0.3,.5, 0.,1. );\n        v = clamp01(v);\n        float av = pow (v, 1.);\n\n\n        //vec3 colInner = vec3(abs(uv),0.5);\n        vec3 colInner = cPsuedoColor(nm + vec3(0.,0.,iTime*3.));\n        colInner += 1.0;\n        colInner /= 2.0;\n        fragColor = vec4(colInner,av);\n\n        //riming\n        float fRim = 0.;\n        float vRim = vOrig;\n        if (vRim>0.59) fRim = 1.;\n\n        vec3 lDir = vec3(0.,  -1.,  0.);\n        lDir = erot(lDir, vec3(1.,0.,0.), radians(-35.));\n        lDir = erot(lDir, vec3(0.,1.,0.), radians(-40.));\n\n        // first rim\n\n        vec3 colRim = vec3(0.8,0.8,1.);\n\n        fragColor = mix (fragColor, vec4(colRim, 1.), fRim );\n        // second Rim\n        vec3 dirSum = normalize(lDir + dir);\n        fRim = 1.;//\n        float vBackRim = dot (dirSum, nm);\n        float br0 = -.1; float br1 = br0 + 0.005;\n        vBackRim = scaleFloat( vBackRim, br0,br1, 0.,1.);\n        vBackRim = clamp01(vBackRim);\n        fRim *= vBackRim;\n\n        vec3 colBackRim = vec3(0.5,.98,1.);\n\n        fragColor = mix (fragColor, vec4(colBackRim, 1.), vBackRim );\n\n        // spec\n\n        float vSpec = dot (dirSum, -nm);\n        br0 = .96; br1 = br0 + 0.005;\n        vSpec = scaleFloat( vSpec, br0,br1, 0.,1.);\n        vSpec = clamp01(vSpec);\n        vec3 colSpec = vec3(1.);\n        fragColor = mix (fragColor, vec4(colSpec, 1.), vSpec );\n\n    }\n    fragColor = mix (vec4(0.2,0.1,0.3,1.),fragColor,fragColor.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TAU 6.28318530718\n// noise block\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\nvec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 permute(vec4 x) {return mod289(((x*34.0)+10.0)*x);}\nvec4 taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nvec3 cPsuedoColor(vec3 p){\n    vec3 pg = p.yzx;\n    pg.x = -pg.x;\n    vec3 pb = p.zxy;\n    pb.x = -pg.x;\n    return vec3(cnoise(p), cnoise(pg), cnoise(pb));\n}\n//noise end\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec3 translate(vec3 p, vec3 ofs){\n    return p - ofs;\n}\n\nfloat clamp01(float x){\n    return clamp(x,0.,1.);\n}\nfloat scaleFloat (float number,\n                     float inMin,\n                     float inMax,\n                     float outMin,\n                     float outMax) {\n    return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;\n}\nfloat sdSphere(vec3 p, float r){\n    return length(p)-r;\n}\n","name":"Common","description":"","type":"common"}]}