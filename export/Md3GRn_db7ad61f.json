{"ver":"0.1","info":{"id":"Md3GRn","date":"1447633199","viewed":430,"name":"Simple Terrain","username":"felipevsfbr","description":"Result of some effects put together ...","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*The moment aliasing actually make things better ahahahaha*/\nconst float dMax = 100.0;\nconst float dSea = 30.3;\nconst int ITER_FRAGMENT = 4;\nconst float SEA_HEIGHT = 1.1;\nconst float SEA_CHOPPY = 0.9;\nconst float SEA_SPEED = 1.0;\nconst float SEA_FREQ = 0.3;\nconst vec3 SEA_BASE = vec3(0.1,0.29,0.19);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,1.0,0.8);\nfloat SEA_iTime = 0.;\nvec3 camEye;\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nconst mat2 rotate2D = mat2(1.732, 1.323, -1.523, 1.652);\nvec3 sunColour = vec3(1.0, .75, .4);\nvec3 sunP;\nvec3 sunLight;\nfloat Hash( float n );\nvec3 noise( in vec2 x );\nfloat snoise(vec2 p);\nfloat Terrain(vec2 p);\nvec3 GetSky(in vec3 rd);\nvec3 doLight(vec3 ro, vec3 rd, vec2 res);\nvec3 getNormal(vec3 p);\n\nfloat sea_octave(vec2 uv, float choppy) \n{\n    \tuv += snoise(uv);        \n    \tvec2 wv = 1.0-abs(cos(uv));\n    \treturn pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat Sea(vec3 p)\n{\n\tfloat freq = SEA_FREQ;\n    \tfloat amp = SEA_HEIGHT;\n    \tfloat choppy = SEA_CHOPPY;\n    \tvec2 uv = p.xz; uv.x *= 0.75;\n    \n    \tfloat d, h = 0.0;    \n    \tfor(int i = 0; i < ITER_FRAGMENT; i++) \n\t{        \n    \t\td = sea_octave((uv + SEA_iTime)*freq,choppy);\n    \t\td += sea_octave((uv - SEA_iTime)*freq,choppy);\n       \t\t\n\t\th += d * amp;        \n    \t\tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        \tchoppy = mix(choppy,1.0,.2);\n\t}\n\treturn p.y - h;\t\n}\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) \n{    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) \n{  \n    \tfloat fresnel = 1.0 - max(dot(n,-eye),0.0);\n    \tfresnel = pow(fresnel,3.0) * 0.85;\n        \n    \tvec3 reflected = GetSky(reflect(eye,n));    \n    \tvec3 refracted = SEA_BASE; \n    \n    \tvec3 color = mix(refracted,reflected,fresnel);\n    \n    \tfloat atten = max(1.0 - dot(dist,dist) * 0.001, 0.2);\n    \tcolor += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n   \n    \tcolor += vec3(specular(n,l,eye,10.0));\n    \treturn color;\n}\n\nvec2 map(vec3 p)\n{\n\tfloat d = Terrain(p.xz);\n\tfloat dd = Sea(p);\n\tfloat m = -1.0;\n\tfloat dist = length(p - camEye);\n\td = p.y - d;\n\tif(d < dSea && dist < dSea + 2.555)\n\t\tm = 1.0;\n\t\n\telse if(d < dMax)\n\t{\n\t\td = dd;\n\t\t m = 2.0;\n\t}\n\treturn vec2(d, m); \n}\n\nvec2 raymarch(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tfloat eps = 0.01;\n\tfloat h = 2.0*eps;\n\tfloat m = -1.0;\n\tfor(int i = 0; i < 20;  i++)\n\t{\n\t\tif(abs(h) > eps || t < dMax)\n\t\t{\n\t\t\tt += h;\n\t\t\tvec2 res = map(ro + t*rd);\n\t\t\th = res.x;\n\t\t\tm = res.y;\n\t\t}\n\t\telse break;\n\t}\n\tif(t > dMax) m = -1.0;\n\treturn vec2(t,m);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 color = vec3(0.0);\n\tvec2 res = raymarch(ro, rd);\n\tvec3 sky = GetSky(rd);\n\tcolor = sky;\n\tvec3 pos = ro + res.x*rd;\n\tvec3 nor = getNormal(pos);\n\tif(res.y > 0.5 && res.y < 1.5)\n\t{\n\t\tcolor = doLight(ro, rd, res);\n\t\tvec3 darker = vec3(0.1);\t\n\t\tcolor -= darker;\n\t\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\t\tcolor = mix(color, sky, 0.92*uv.y);\n\t}\n\telse if(res.y > 1.5)\n\t{\n\t\tcolor = mix(\n        \tsky,\n       \t\tgetSeaColor(pos,nor,sunLight,rd,pos - camEye),\n    \t\tpow(smoothstep(0.0,-.3,rd.y),0.2)) * vec3(0.45);\n\t\tfloat fogAmount = clamp(res.x*res.x* 0.00009, 0.0, 1.0);\n\t\tcolor = mix(color, sky, fogAmount);\n\t}\n\treturn color;\n}\n\nvec3 lensFlare(vec3 rgb, vec3 ww, vec3 uu, vec3 vv,\n\t\t\t\t\t\t\t\t   vec2 uv, vec3 dir)\n{\n\tvec3 color = rgb;\n\tfloat bri = dot(ww,sunLight)*.75;\n\tmat3 camMat = mat3(uu, vv, ww);\n\tfloat PI = 3.1415;\n\tif(bri > 0.0)\n\t{\n\t\tvec2 sunPos = (-camMat * sunLight).xy;\n\t\t\n\t\tbri = pow(bri, 7.0)*.8;\n\t\tfloat glare = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\t\tfloat glare2 = max(sin(smoothstep(.4, .7, length(sunPos - uv*.5))*PI), 0.0);\n\n\t\tfloat glare3 = max(1.0-length(sunPos - uv*2.1), 0.0);\n\t\tfloat glare4 = max(sin(smoothstep(-0.05, .4, length(sunPos + uv*2.5))*PI), 0.0);\n\n\t\tcolor += bri * vec3(1.0, .0, .0)  * pow(glare, 12.5)*.07;\n\t\tcolor += bri * vec3(.0, 1.0, 1.0) * pow(glare2, 3.0);\n\t\tcolor += bri * vec3(1.0, 1.0, 0.0)* pow(glare3, 3.0)*4.0;\n\t\tcolor += bri * vec3(.5, 1.0, 1.0) * pow(glare4, 33.9)*.7;\n\t} \t\n\treturn color;\n}\n\nvec3 PostProcess(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(0.45));\n\tfloat contrast = 1.3;\n\tfloat saturation = 1.0;\n\tfloat brightness = 1.3;\n\trgb = mix(vec3(0.5), mix(vec3(dot(vec3(.2125, .7154, .0721), \n\t\t\t\t\trgb*brightness)), rgb*brightness, saturation), contrast); \n\trgb *= 0.4 + 0.4*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2);\n\treturn rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunP = vec3(1000.0, 750.0 + 650.0*sin(0.5*iTime), 3500.0);\n   \tsunLight = normalize(sunP);\n\tSEA_iTime = iTime * SEA_SPEED;\n\tvec2 xy = fragCoord.xy/iResolution.xy;\n\tvec2 uv = 2.0*xy - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\tfloat x = 0.0 ;\n\tfloat y = 10.0;\n\tfloat z = -11.0;\n\tvec3 eye = vec3(x,y,z);\n\tvec3 at = vec3(eye.x +4.0, eye.y - 0.9, 0.0);\n\tcamEye = eye;\n\t//at.x *= 5.0*sin(iTime);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 ww = normalize(at-eye);\n\tvec3 uu = normalize(cross(ww, up));\n\tvec3 vv = normalize(cross(uu, ww));\n\tvec3 rd = normalize(uv.x*uu + uv.y*vv + 2.0*ww);\n\tvec3 ro = eye;\n\tvec3 color = render(ro, rd);\n\tcolor = lensFlare(color, ww, uu, vv, uv, rd);\n\tcolor = PostProcess(color, xy);\n    fragColor = vec4(color, 1.0);\n}\n\nvec3 getNormal(vec3 p)\n{\n\tvec3 n;\n\tfloat eps = 0.001;\n\tn.x = map(vec3(p.x + eps, p.y, p.z)).x - map(vec3(p.x - eps, p.y, p.z)).x; \n\tn.y = map(vec3(p.x, p.y + eps, p.z)).x - map(vec3(p.x, p.y - eps, p.z)).x;\n\tn.z = map(vec3(p.x, p.y, p.z + eps)).x - map(vec3(p.x, p.y, p.z - eps)).x;\n\treturn normalize(n);\n}\n\nvec3 doLight(vec3 ro, vec3 rd, vec2 res)\n{\n\tvec3 pos = ro + res.x*rd;\n\tvec3 nor = getNormal(pos);\n\tvec3 lightv = sunP - pos;\t\n\tfloat dist = length(lightv);\n\tlightv = normalize(lightv);\n\tfloat at = 1500.0/(.0 + 0.1*dist);\n\tvec3 difc = vec3(0.7, 0.5, 0.2);\n\tvec3 dif = at*sunColour*max(0., dot(lightv, nor))*difc;\n\tvec3 refl = reflect(lightv, nor);\n\tfloat s = dot(lightv, refl);\n\tvec3 spec = vec3(0.0);\n\tif(s > 0.7)\n\t\tdif -= vec3(0.1)*pow(s, 64.0);\n\treturn max(dif + spec, 0.1);\n}\n\nfloat Terrain(vec2 p)\n{\n\tvec2 pos = p*0.0035;\n\tfloat w = 24.0;\n\tfloat f = 0.0;\n\tvec2 d = vec2(0.0);\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tvec3 n = noise(pos);\n\t\td += n.yz;\n\t\tf += w*n.x/(1.0 + dot(d,d));\n\t\tw = w*0.57;\n\t\tpos = rotate2D * pos;\n\t}\n\treturn f;\n}\n\nfloat snoise(vec2 p) \n{\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,.0),3.);\n\tvec3  sky = mix(vec3(.015,0.0,.01), vec3(.42, .2, .1), v);\n\tsky = sky + sunColour * sunAmount * sunAmount * .5;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .4);\n\treturn clamp(sky, 0.3, 1.0);\n}\n\nvec3 noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n\n    float a = Hash(n+  0.0);\n    float b = Hash(n+  1.0);\n    float c = Hash(n+ 57.0);\n    float d = Hash(n+ 58.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat Hash( float n )\n{\n    return fract(sin(n)*33753.545383);\n}","name":"","description":"","type":"image"}]}