{"ver":"0.1","info":{"id":"M3VGWw","date":"1717748518","viewed":80,"name":"galaxy and dawn","username":"nnew","description":"copypast","likes":3,"published":1,"flags":1,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*from shadertoy and internet*/\n#define iterations 13\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat noise( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// https://www.shadertoy.com/view/XsGfWV\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n#define R iResolution.xy\nvec2 r(vec2 p, float a) { return p*mat2(cos(a), sin(a), -sin(a), cos(a)); }\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n    \n    vec4 O = fragColor;\n    vec2 I =fragCoord;\n     vec2 uv2 = I/R;\n    vec2 p = (2.*I - R) / R.y * 1.5;\n    \n    float fp = pow(.5/length(pow(abs(r(p,.43))\n        *vec2(2,1),vec2(.5))),4.5);\n       \n    p *= mat2(.7,-.5,-.4,1.2);    \n    vec3 pos = normalize(vec3(r(p,-.4/length(p)),.25));\n    pos.z -= iTime*0.1;\n    \n    vec3 q = 6.*pos;\n    float f  = 0.5000*noise( q ); q = q*2.;\n          f += 0.2500*noise( q ); q = q*2.;\n          f += 0.1250*noise( q ); q = q*2.;\n          f += 0.0625*noise( q );\n    \n    vec2 n = uv2*(1.-uv)*3.; float v = pow(n.x*n.y,.8);\n    \n    float fr = .6/length(p);\n    f = smoothstep(-.4,2.,f*f) * fr*fr + fp;\n    \n    O = vec4(aces_tonemap(\n        pow(f*f * vec3(0., .00, 2.5)*v,vec3(.45))*3.5),0);\n    \n\n\n\nvec3 from=vec3(1.,.5,0.5);\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v2=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05), cos(iTime*0.05));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.1-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv2+=fade;\n\t\tv2+=vec3(s,s,s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv2=mix(vec3(length(v2)),v2,saturation); //color adjust\n\tfragColor = vec4(v2*.03+O.xyz,1.);\t\n\t\n\t\n\n\n\t\n\t\n    fragColor*=O;\n}\n","name":"Image","description":"","type":"image"}]}