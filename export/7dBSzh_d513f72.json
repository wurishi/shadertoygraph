{"ver":"0.1","info":{"id":"7dBSzh","date":"1619627086","viewed":65,"name":"Inception - Final Project","username":"eurekazheng","description":"Final Project for CIS-561. The spin scene from the movie Inception. Are you watching the movie, or is the movie watching you? In the permanent, periodic spinning of everything, we failed to perceive the ultimate essence of existence...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cis561"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_STEPS = 256;\nconst float FOVY = 0.25 * 3.14159;\n\n\nconst vec3 lightPos = vec3(1.0, 1.0, 1.0);\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\nconst float lightPower = 40.0;\nconst vec3 ambient = vec3(0.6);\nconst vec3 diffuse = vec3(0.7, 0.1, 0.2);\nconst vec3 spec = vec3(1.0);\nconst float shine = 17.2;\nconst float gamma = 3.1; \n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat CSG_Union(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat lerp(float a, float b, float t) {\n    return a + t * (b - a);\n}\n\nfloat smooth_CSG_Union( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return lerp( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat cylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    t = min(t, plane(pos, vec4(1.0, 0.0, 0.0, 9.0)));\n    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 7.5)));\n    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 9.0)));\n    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 2.5)));\n    float spin = CSG_Union(\n        smooth_CSG_Union(\n            cylinder(pos, vec2(2.0, 0.2)),\n            cylinder(pos, vec2(0.2, 3.0)),\n            2.5\n        ), \n        cylinder(pos, vec2(2.3, 0.1))\n    );\n    t = min(t, spin);\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n\n    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    obj = 0;\n    \n    float t2;\n    if((t2 = plane(pos, vec4(1.0, 0.0, 0.0, 9.0))) < t)\n    {\n        t = t2;\n        obj = 1;\n    }\n    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 9.0))) < t)\n    {\n        t = t2;\n        obj = 2;\n    }\n    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 7.5))) < t)\n    {\n        t = t2;\n        obj = 3;\n    }\n    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)\n    {\n        t = t2;\n        obj = 4;\n    }\n    \n   \n    float spin = CSG_Union(\n        smooth_CSG_Union(\n            cylinder(pos, vec2(2.0, 0.2)),\n            cylinder(pos, vec2(0.2, 3.0)),\n            2.5\n        ), \n        cylinder(pos, vec2(2.3, 0.1))\n    );\n    if((t2 = spin) < t)\n    {\n        t = t2;\n        obj = 5;\n    }\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n#define FBM_OCTAVES 4\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 25.0) + 12.0);\n    return mix(a, b, t);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat bilerpNoise(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    float ll = random1(floor(uv));\n    float lr = random1(floor(uv) + vec2(1,0));\n    float ul = random1(floor(uv) + vec2(0,1));\n    float ur = random1(floor(uv) + vec2(1,1));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.4;\n    float freq = 7.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.4;\n        freq *= 2.5;\n    }\n    return sum;\n}\n\n#define PI 3.14159\n\nconst vec3 a = vec3(0.3);\nconst vec3 b = vec3(0.7);\nconst vec3 c = vec3(1.);\nconst vec3 d = vec3(0.00, 0.6, 0.4);\n\nvec3 colorPalette(float t)\n{\n    return a + b * cos(2. * PI * (t * c + d));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec)\n{\n    vec3 lightDir = vec3(0., 7.4, -3.5) - p;\n    float d = length(lightDir);\n    lightDir = normalize(lightDir);\n    float lambertian = max(dot(lightDir, n), 0.0);\n    float angle = max(dot(normalize(lightDir + normalize(-p)), n), 0.0);\n    vec3 col = ambient + diffuse * lambertian * lightColor * lightPower / (d * d) \n                       + spec * pow(angle, shine) * lightColor * lightPower / (d * d);\n\n    //float lambertian = dot(-lightVec, n);\n    switch(hitObj){\n        case 0:\n        return texture(iChannel0, p.xy * 0.065 + 0.5).rgb * col;\n        break;\n        case 1:\n        return texture(iChannel0, p.zy * 0.065 + 0.5).rgb * col;\n        break;\n        case 2:\n        return texture(iChannel0, p.zy * 0.065 + 0.5).rgb * col;\n        break;\n        case 3:\n        return texture(iChannel2, p.xz * 0.065 + 0.5).rgb * col;\n        break;\n        case 4:\n        return texture(iChannel1, p.xz * 0.065 + 0.5).rgb * col;\n        break;\n        case 5:\n        vec2 uvSpin;\n        uvSpin.x = cos(iTime * 3.) + p.x / 10.;\n        uvSpin.y = p.y;        \n        return colorPalette(fbm(uvSpin)) * col;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(1.);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 nor, float k) {\n\tfloat t = 0.0;\n\tfor (float i = 0.0; i < 5.0; i++) {\n\t\tt += (.2 * i - sceneMap3D(p + .2 * i * nor)) / pow(4.0, i);\n\t}\n\treturn 1.0 - t * k;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 lightPos = vec3(0., 7.4, -3.5);\n    vec3 lightVec = normalize(isect - lightPos);\n    float ao = ambientOcclusion(isect, nor, 1.5);\n    vec3 surfaceCol = ao * computeMaterial(hitObj, isect, nor, lightVec);    \n    return Intersection(t, surfaceCol, isect, hitObj);\n}\n\nvoid rayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = vec3(0, 7, -15);\n    ref = vec3(0, 3, 0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;    \n    dir = normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye;    \n    vec3 ref;\n    vec3 dir;\n    rayCast(uv, dir, eye, ref);\n    \n    Intersection isect = sdf3D(dir, eye);\n    fragColor = vec4(isect.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}