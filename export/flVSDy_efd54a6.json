{"ver":"0.1","info":{"id":"flVSDy","date":"1667824207","viewed":102,"name":"Correction tp3.5","username":"schreck","description":"Le template Ã  completer pour l'exercice de la sceance de graphique du 04/01.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["lancerderayon"],"hasliked":0,"parentid":"7lKSRd","parentname":"Correction tp3"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    C.Obs = Obs;\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(vec3(0, 0, 1), C.View));\n    C.Up = normalize(cross(C.View, C.Horiz));\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H/2.0/tan(aperture * 3.1415 / 180.0 /2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = C.z*C.View + (XY.x - C.W/2.0)*C.Horiz + (XY.y - C.H/2.0)*C.Up;\n   return r;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n   bool light;\n   vec3 color;\n};\n\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    float a = dot(R.Dir,R.Dir);\n    float b = 2.0*dot(R.Dir,(R.Origin - S.Center));\n    float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R*S.R;\n    float delta = b*b - 4.0*a*c;   \n    if (delta > 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n    }\n    return delta > 0.0;\n}\n\nfloat lighting(vec3 p, vec3 n, vec3 light) {\n    vec3 light_dir = normalize(light - p);\n    float coef = dot(n, light_dir);\n    return coef;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   \n   vec3 col = vec3(0, 0.3, 0.8);\n   Ray r = launch(C, fragCoord);\n   \n   vec3 center0 = vec3(0.0, 0.0, 0.0);\n   float R0 = 0.6;\n   vec3 col0 = vec3(1, 1, 1);\n   \n   float a = iTime;\n   mat3 rot = mat3(cos(a), sin(a), 0,\n                   -sin(a), cos(a), 0,\n                   0, 0, 1);\n   vec3 center1 = center0 + rot*vec3(1.5, 0.0, 0.0);\n   float R1 = 0.3;\n   vec3 col1 = vec3(1, 0, 0);\n   \n   \n   float a2 = 4.0*iTime;\n   mat3 rot2 = mat3(cos(a2), sin(a2), 0,\n                   -sin(a2), cos(a2), 0,\n                   0, 0, 1);                 \n   vec3 center2 = center1 + rot2*vec3(0.5, 0, 0);\n   float R2 = 0.1;\n   vec3 col2 = vec3(0.5, 0.2, 0.9);\n   \n   float a3 = 3.0*iTime;\n   mat3 rot3 = mat3(cos(a3), 0, sin(a3),\n                    0, 1, 0,\n                   -sin(a3), 0, cos(a3));\n   vec3 center3 = center0 + rot3*vec3(2, 0.0, 0.0);\n   float R3 = 0.1;\n   vec3 col3 = vec3(1, 1, 0);\n   \n   float a4 = 1.0*iTime;\n   mat3 rot4 = mat3(1, 0, 0,\n                    cos(a4), sin(a4), 0,\n                   -sin(a4), cos(a4), 0);\n   vec3 center4 = center0 + rot4*vec3(1.0, 0.0, 1.0);\n   float R4 = 0.1;\n   vec3 col4 = vec3(0, 1, 1);\n   \n   Sphere s0 = Sphere(center0, R0, \n                      false, col0);\n   Sphere s1 = Sphere(center1, R1,\n                      false, col1);\n   Sphere s2 = Sphere(center2, R2,\n                      true, col2);\n   Sphere s3 = Sphere(center3, R3,\n                      true, col3);\n   Sphere s4 = Sphere(center4, R4,\n                      true, col4);\n   \n   float t = 1e30;\n   float t0;\n   if (intersect_sphere(r, s0, t0) && t0 < t) {\n       t = t0;\n       vec3 p = r.Origin + t0*r.Dir;\n       vec3 n = normalize(p - s0.Center);\n       float coef = lighting(p, n, s2.Center);\n       col = coef*s0.color*s2.color;\n       float coef2 = lighting(p, n, s3.Center);\n       col += coef2*s0.color*s3.color;\n       float coef3 = lighting(p, n, s4.Center);\n       col += coef3*s0.color*s4.color;\n    }\n    float t1;\n    if (intersect_sphere(r, s1, t1) && t1 < t) {\n       t = t1;\n       vec3 p = r.Origin + t1*r.Dir;\n       vec3 n = normalize(p - s1.Center);\n       float coef = lighting(p, n, s2.Center);\n       col = coef*s1.color*s2.color;\n        float coef2 = lighting(p, n, s3.Center);\n       col += coef2*s1.color*s3.color;\n       float coef3 = lighting(p, n, s4.Center);\n       col += coef3*s1.color*s4.color;\n    }\n    \n    float t2;\n    if (intersect_sphere(r, s2, t2) && t2 < t) {\n      // vec3 p = r.Origin + t2*r.Dir;\n      // vec3 n = normalize(p - s2.Center);\n      // float coef = lighting(p, n, light);\n       col = s2.color;\n       t = t2;\n    }\n     float t3;\n    if (intersect_sphere(r, s3, t3) && t3 < t) {\n      // vec3 p = r.Origin + t2*r.Dir;\n      // vec3 n = normalize(p - s2.Center);\n      // float coef = lighting(p, n, light);\n       col = s3.color;\n       t = t3;\n    }\n    float t4;\n    if (intersect_sphere(r, s4, t4) && t4 < t) {\n      // vec3 p = r.Origin + t2*r.Dir;\n      // vec3 n = normalize(p - s2.Center);\n      // float coef = lighting(p, n, light);\n       col = s4.color;\n       t = t4;\n    }\n\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}