{"ver":"0.1","info":{"id":"wlsSzs","date":"1563988170","viewed":364,"name":"Entreprise","username":"maplellll","description":"Just a trivial example","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["spaceship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// created by Maple\n\n// code reference:\n// ShaderToy入门教程 by 穿越文明 source: https://blog.csdn.net/weixin_28710515/article/details/89532597\n// code by Inigo Quilez, source: https://iquilezles.org/articles/distfunctions\n// code by Low Kok Lim in NUS Summer workshop of CS 2019\n// glm source code on https://github.com/g-truc/glm\n\nconst float EPSILON = 0.001;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst int MAX_MARCHING_STEPS = 255;\nconst int NUM_ITERATIONS = 5;\nconst bool useTextrue = true;\nconst int NUM_MATERIALS = 3;\nconst vec3 BACKGROUND_COLOR = vec3(0.5, 0.5, 0.5);\n\nconst int MAX_LIGHT_NUM = 10;\nconst int MAX_OBJ_NUM = 50;\n\nconst vec3 X_AXIS = vec3(1.0,0.0,0.0);\nconst vec3 Y_AXIS = vec3(0.0,1.0,0.0);\nconst vec3 Z_AXIS = vec3(0.0,0.0,1.0);\n\nint objectNum = 0;\nint lightNum = 0;\n\nbool test = false;\nstruct Ray {\n    vec3 origin;  // Ray Origin.\n    vec3 direction;  // Ray Direction. A unit vector.\n};\n\nstruct Object\n{\n    vec4 dimensions;\n    mat4 transformation;\n    int which_kind;\n    int materialID;\n};\n\nstruct Material {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\nstruct Light \n{\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nObject objects[MAX_OBJ_NUM];\nLight lights[MAX_LIGHT_NUM];\nMaterial materials[NUM_MATERIALS];\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.yz) - w, p.x );\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d); // can delay this sqrt\n    return ((p.y-b)*d > p.x*b) \n            ? length(p-vec2(0.0,b))\n            : length(p-vec2(-d,0.0))-r;\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\n\n\n#define CUBE 0\n#define SPHERE 1\n#define DROP 2\n#define PLANE 3\n#define ROUND_CYLINDER 4\n#define VESICA_BAR 5\n#define CAPSULE 6\n#define UNUSED 0.0\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n float sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\nvoid addVesicaBar(float r, float d, float h, int materialID,mat4 transformation)\n{\n    objects[objectNum].which_kind = VESICA_BAR;\n    objects[objectNum].dimensions = vec4(r,d,h,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\nvoid addRoundedCylinder(float ra, float rb, float h, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = ROUND_CYLINDER;\n    objects[objectNum].dimensions = vec4(ra,rb,h,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\nvoid addCube( vec3 dimensions, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = CUBE;\n    objects[objectNum].dimensions = vec4(dimensions,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\nvoid addPlane(vec4 coefficients, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = CUBE;\n    objects[objectNum].dimensions = coefficients;\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\nvoid addSphere( float radius, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = SPHERE;\n    objects[objectNum].dimensions = vec4(radius,UNUSED,UNUSED,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\nvoid addCapsule(float r,float h, int materialID, mat4 transformation )\n{\n    objects[objectNum].which_kind = CAPSULE;\n    objects[objectNum].dimensions = vec4(r,h,UNUSED,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\n\n//revolved vesica on https://www.shadertoy.com/view/4lyfzw\nvoid addDrop( float innerRadius, float size, float proportion, int materialID, mat4 transformation)\n{\n    objects[objectNum].which_kind = DROP;\n    objects[objectNum].dimensions = vec4(innerRadius,size, proportion,UNUSED);\n    objects[objectNum].materialID = materialID;\n    objects[objectNum].transformation = transformation;\n    objectNum += 1;\n}\n\nvoid addLight(vec3 position, vec3 ambient, vec3 source)\n{\n    lights[lightNum].position = position;\n    lights[lightNum].I_a = ambient;\n    lights[lightNum].I_source = source;\n    lightNum += 1;\n}\n\nmat4 translateObj(mat4 matrix, vec3 translation)\n{\n    mat4 result = matrix;\n    translation = - translation;\n    result[3] = matrix[0] * translation[0] + matrix[1] * translation[1] + matrix[2] * translation[2] + matrix[3];\n    return result;\n}\n\n\nmat4 rotateObj(mat4 matrix, float angle, vec3 v)\n{\n    float a = -angle;//bacause actually ref point moving\n    float c = cos(a);\n    float s = sin(a);\n    vec3 axis = normalize(v);\n    vec3 temp = (1.0-c) * axis;\n    mat4 Rotate = mat4(1.0);\n    Rotate[0][0] = c + temp[0] * axis[0];\n\tRotate[0][1] = temp[0] * axis[1] + s * axis[2];\n\tRotate[0][2] = temp[0] * axis[2] - s * axis[1];\n\n\tRotate[1][0] = temp[1] * axis[0] - s * axis[2];\n\tRotate[1][1] = c + temp[1] * axis[1];\n\tRotate[1][2] = temp[1] * axis[2] + s * axis[0];\n\n\tRotate[2][0] = temp[2] * axis[0] + s * axis[1];\n\tRotate[2][1] = temp[2] * axis[1] - s * axis[0];\n\tRotate[2][2] = c + temp[2] * axis[2];\n\t\n    mat4 Result = mat4(1.0);\n    Result[0] = matrix[0] * Rotate[0][0] + matrix[1] * Rotate[0][1] + matrix[2] * Rotate[0][2];\n\tResult[1] = matrix[0] * Rotate[1][0] + matrix[1] * Rotate[1][1] + matrix[2] * Rotate[1][2];\n    Result[2] = matrix[0] * Rotate[2][0] + matrix[1] * Rotate[2][1] + matrix[2] * Rotate[2][2];\n\tResult[3] = matrix[3];\n    return Result;\n}\nconst float PI = 3.14159265358;\nvoid initScene()\n{\n    mat4 transformation = mat4(1.0);\n    mat4 identity = mat4(1.0);\n    vec3 init_pos = vec3(0.0,-5.0,0.0);\n    //MIND THE ORDER WHICH IS REVERSED!\n     //MIND THE ORDER WHICH IS REVERSED!\n      //MIND THE ORDER WHICH IS REVERSED!\n    {\n        transformation = translateObj(identity,vec3(-0.5,2.8,0.0));\n        addRoundedCylinder(1.7,0.19,0.05,0,transformation);\n        transformation = translateObj(transformation,vec3(0.0,-0.2,0.0));\n        addSphere(0.3,0,transformation);\n        transformation = translateObj(transformation,vec3(0.0,-0.05,0.0));\n        addRoundedCylinder(0.4,0.07,0.01,0,transformation);\n    }\n    test = false;\n    transformation = rotateObj(identity,PI/180.0*75.0, X_AXIS);\n    transformation = rotateObj(transformation,PI/2.0, Y_AXIS);\n    transformation = translateObj(transformation,vec3(1.6,1.65,0.0));\n    addVesicaBar(0.7,0.3,1.0,0,transformation);\n\n    transformation = identity;\n    transformation = rotateObj(transformation,PI/2.0, Y_AXIS);\n    transformation = translateObj(transformation,vec3(3.0,0.4,0.0));\n    addVesicaBar(0.7,0.3,1.8,0,transformation);\n\n    transformation = rotateObj(identity,PI/180.0 * 40.0,Y_AXIS);\n    transformation = rotateObj(transformation,PI/180.0 * 60.0,Z_AXIS);\n    transformation = translateObj(transformation,vec3(4.7,1.3,0.9));\n    addVesicaBar(0.7,0.3,1.5,0,transformation);\n\n    transformation = rotateObj(identity,PI/180.0 * 140.0,Y_AXIS);\n    transformation = rotateObj(transformation,PI/180.0 * 60.0,Z_AXIS);\n    transformation = translateObj(transformation,vec3(4.7,1.3   ,-0.9));\n    addVesicaBar(0.7,0.3,1.5,0,transformation);\n    \n    transformation = rotateObj(identity,PI/2.0,Z_AXIS);\n    transformation = translateObj(transformation,vec3(7.15,2.15,2.0));\n    addCapsule(.5,3.0,0,transformation);\n    transformation = rotateObj(identity,PI/2.0,Z_AXIS);\n    transformation = translateObj(transformation,vec3(7.15,2.15,-2.0));\n    addCapsule(.5,3.0,0,transformation);\n    transformation = rotateObj(identity,PI/2.0,Z_AXIS);\n    transformation = translateObj(transformation,vec3(1.8,0.25,0.0));\n    addCapsule(0.7,1.0,0,transformation);\n    // Silver material.\n    materials[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    materials[0].k_a = 0.2 * materials[0].k_d;\n    materials[0].k_r = 2.0 * materials[0].k_d;\n    materials[0].k_rg = 0.5 * materials[0].k_r;\n    materials[0].n = 64.0;\n\n    // Gold material.\n    materials[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    materials[1].k_a = 0.2 * materials[1].k_d;\n    materials[1].k_r = 2.0 * materials[1].k_d;\n    materials[1].k_rg = 0.5 * materials[1].k_r;\n    materials[1].n = 64.0;\n\n    \n    addLight(vec3( 0.4,-3,0.1 ), vec3( 0.1, 0.1, 0.1 ), vec3( 1.0, 1.0, 1.0 ));\n    addLight(vec3( -4.0, 8.0, 0.0 ), vec3( 0.1, 0.1, 0.1 ), vec3( 1.0, 1.0, 1.0 ));\n    \n}\n\n// model algebra\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\nfloat unionSDF(float distances[MAX_OBJ_NUM])\n{\n    float min_dist = distances[0];\n    for(int i=0;i<objectNum;i++)\n    {\n        min_dist = min(min_dist, distances[i]);\n    }\n    return min_dist;\n}\nfloat unionSDF(float distances[MAX_OBJ_NUM], out int objIdx)\n{\n    float min_dist = distances[0];\n    objIdx = 0;\n    for(int i=0;i<objectNum;i++)\n    {\n        if(distances[i]<min_dist)\n        {\n            min_dist = distances[i];\n            objIdx = i;\n        }\n    }\n    return min_dist;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothUnion(float distances[MAX_OBJ_NUM], out int objIdx)\n{\n    float min_dist = distances[0];\n    float dist = min_dist;\n    objIdx = 0;\n    for(int i=0;i<objectNum;i++)\n    {\n        if(distances[i]<min_dist)\n        {\n            min_dist = distances[i];\n            objIdx = i;\n        }\n        dist = opSmoothUnion(dist, distances[i],0.25);\n    }\n    return dist;\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\n//models\nfloat sdPlane( vec3 ref_pos, vec4 dimensions )\n{\n  // dimensions must be normalized\n  dimensions = normalize(dimensions);\n  return dot(ref_pos,dimensions.xyz) + dimensions.w;\n}\n\nfloat sdBox( vec3 ref_pos, vec3 dimensions )\n{\n  vec3 d = abs(ref_pos) - dimensions;\n  float dist_to_ref_pos = length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n  return dist_to_ref_pos;\n}\nfloat sdSphere( vec3 ref_pos, float s )\n{\n  return length(ref_pos)-s;\n}\n\n\nfloat calcDist(vec3 ref_point, Object obj)\n{\n    vec4 refP = vec4(ref_point,1.0);\n    refP = obj.transformation* refP;\n    ref_point = refP.xyz / refP.w;\n    switch (obj.which_kind)\n    {\n        case CUBE:\n            return sdBox(ref_point,  obj.dimensions.xyz);\n        case SPHERE:\n            return sdSphere(ref_point,  obj.dimensions.x);\n        case DROP:\n            return sdVesica(opRevolution(ref_point, obj.dimensions.x), obj.dimensions.y, obj.dimensions.z);\n        case PLANE:\n            return sdPlane(ref_point, obj.dimensions);\n        case ROUND_CYLINDER:\n            return sdRoundedCylinder(ref_point,obj.dimensions.x,obj.dimensions.y, obj.dimensions.z);\n        case VESICA_BAR:\n            return opExtrussion(ref_point, sdVesica(ref_point.xy,obj.dimensions.x,obj.dimensions.y), obj.dimensions.z);\n        case CAPSULE:\n            return sdVerticalCapsule(ref_point,obj.dimensions.y,obj.dimensions.x);\n        default:\n            return MAX_DIST;\n    }\n}\n\n// float sceneSDF(in vec3 ref_point)\n// {\n//     float distances[MAX_OBJ_NUM];\n//     for(int i=0;i<objectNum;i++)\n//     {\n//         distances[i] = calcDist(ref_point, objects[i]);\n//     }\n//     distances[0] = opSmoothUnion(distances[0],distances[1],0.25);\n//     distances[1] = distances[0];\n//     return unionSDF(distances);\n// }\n\n\nvoid sceneSDF(in vec3 ref_point, out float distances[MAX_OBJ_NUM])\n{\n    for(int i=0;i<objectNum;i++)\n    {\n        distances[i] = calcDist(ref_point, objects[i]);\n    }\n}\nfloat sceneSDF(in vec3 ref_point)\n{\n    float distances[MAX_OBJ_NUM];\n    for(int i=0;i<objectNum;i++)\n    {\n        distances[i] = calcDist(ref_point, objects[i]);\n    }\n    int i;\n    return smoothUnion(distances,i);\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start_dist, float limit_dist ,int preObj,out int objectIndex) \n{\n    float depth = start_dist;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n    {\n        float distances[MAX_OBJ_NUM];\n        sceneSDF(eye + depth * marchingDirection, distances);\n        if(preObj != -1)\n            distances[preObj] = 2.0 * MAX_DIST;\n        int hitObjIdx;\n        ////\n        // float dist = unionSDF(distances,hitObjIdx);\n        ///\n        float dist = smoothUnion(distances,hitObjIdx);\n        if (dist < EPSILON) {\n            objectIndex = hitObjIdx;\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= limit_dist) \n        {\n            objectIndex = objectNum;\n            return limit_dist;\n        }\n    }\n    return limit_dist;\n}\n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvec3 estimateNormal(vec3 ref_pos, Object obj) \n{\n    return normalize(vec3(\n        calcDist(vec3(ref_pos.x + EPSILON, ref_pos.y, ref_pos.z), obj) - calcDist(vec3(ref_pos.x - EPSILON, ref_pos.y, ref_pos.z), obj),\n        calcDist(vec3(ref_pos.x, ref_pos.y + EPSILON, ref_pos.z), obj) - calcDist(vec3(ref_pos.x, ref_pos.y - EPSILON, ref_pos.z), obj),\n        calcDist(vec3(ref_pos.x, ref_pos.y, ref_pos.z  + EPSILON), obj) - calcDist(vec3(ref_pos.x, ref_pos.y, ref_pos.z - EPSILON), obj)\n    ));\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material mat, in Light light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\nvec3 castRay (in Ray ray, in int preObj,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg, out int hitObj )\n{\n    int objIndex;\n    float dist = shortestDistanceToSurface(ray.origin,ray.direction, MIN_DIST,MAX_DIST,preObj, objIndex);\n    if(dist>MAX_DIST - EPSILON)\n    {\n        hasHit = false;\n        if(useTextrue)\n            return texture(iChannel0,ray.direction).xyz;\n        else\n            return BACKGROUND_COLOR;\n    }\n    else\n    {\n        hitObj = objIndex;\n        Object obj = objects[objIndex];\n        hasHit = true;\n        vec3 ref_pos = ray.origin + dist * ray.direction;\n        hitPos = ref_pos;\n        hitNormal =  estimateNormal(ref_pos);\n        k_rg = materials[obj.materialID].k_rg;\n        vec3 I_local = vec3(0.0);\n        // shadow ray\n        for (int i = 0;i<lightNum;i++)\n        {\n            Light light = lights[i];\n            vec3 shadowRay = light.position - hitPos;\n            Ray sRay;\n            sRay.origin = hitPos;\n            sRay.direction = normalize(shadowRay);\n            float max_dist = MAX_DIST;\n            int hitObjIndex;\n            float distTemp = shortestDistanceToSurface(sRay.origin, sRay.direction,MIN_DIST,max_dist,objIndex,hitObjIndex);\n            bool hitSth = (distTemp<max_dist-EPSILON);\n            I_local += PhongLighting(sRay.direction, hitNormal,-ray.direction, hitSth, materials[obj.materialID],light);\n        }\n        return I_local;\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    initScene();\n    float FOVY = 45.0;\n    vec3 viewInitDirection = rayDirection(FOVY, iResolution.xy, fragCoord);\n    vec3 eyePos = vec3(-20.0,5, 15);\n    vec2 rott = iMouse.xy / iResolution.xy;\n    mat4 identity = mat4(1.0);\n    mat4 transformation = rotateObj(identity, rott.x*1.5*PI, Y_AXIS);\n    transformation = rotateObj(transformation, rott.y*1.5*PI, Z_AXIS);\n    eyePos =(transformation* vec4(eyePos,1.0)).xyz;\n    if(test)\n        eyePos = vec3(0.0,0.0, 30.0);//for test\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat4 lookAtMatrix = lookAt(eyePos, center, up);\n    vec3 wcRayDir = (lookAtMatrix * vec4(viewInitDirection,0.0)).xyz;//wc : world coordinate\n    Ray primaryRay;\n    primaryRay.origin = eyePos;\n    primaryRay.direction = normalize(wcRayDir);\n    Ray nextRay = primaryRay;\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    int preObj = -1;\n    for(int level =0;level<NUM_ITERATIONS;level++)\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        vec3 I_local = castRay(nextRay,preObj, hasHit, hitPos, hitNormal,k_rg, preObj);\n        I_result += compounded_k_rg * I_local;\n        if(!hasHit)\n            break;\n        compounded_k_rg *= k_rg;\n        nextRay = Ray(hitPos,normalize( reflect(nextRay.direction, hitNormal)));\n    }\n    fragColor = vec4(I_result,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}