{"ver":"0.1","info":{"id":"3dVfzG","date":"1607418763","viewed":59,"name":"Sh1","username":"SayrakDark","description":"...","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Hash2(uint n) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec2 k = n * uvec2(n,n*16807U);\n    return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\n\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec3 rand3(vec3 st) {\n    \n \treturn vec3(Hash2(uint(st.x)), rand(st.yz));    \n    \n}\nfloat sph(in vec3 pos, in vec3 cen, in float r){\n\treturn length(pos - cen) - r; \n}\n\nfloat plane(in vec3 pos, in float r){\n\n\treturn pos.y - (-r);\n}\nvec2 mmax(in vec2 a, in vec2 b){\n\t\n\treturn a.x > b.x ? a: b;\n}\n\nvec2 mmin(in vec2 a, in vec2 b){\n\t\n\treturn a.x < b.x ? a: b;\n}\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled) {\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\nvec2 map(in vec3 pos){\n    \n    //float disp = \n\tvec2 d = vec2(sph(pos, vec3(0.0), 1.5), 1.0);\n    vec2 d1 = vec2(sph(pos, vec3(-3.0*sin(iTime), 0.3-0.31-sin(iTime*5.0), 3.0*cos(iTime)), 0.31*abs(cos(2.5*iTime) + sin(2.5*iTime))), 2.0);\n    vec2 d2 = vec2 (plane(pos, 1.5), 3.0);\n    vec2 d3 = vec2(sph(pos, vec3(3.0*cos(iTime), -1.0, 3.0*sin(iTime)), 0.50),4.0);\n    vec2 d4 = vec2(sph(pos, vec3(10.0, 10.0,0.0),1.0) , 5.0);\n    \n    \n    vec2 d5 = vec2(sph(pos, vec3(-0.5, 0.0, 5.0), 1.5), 6.0);\n    vec2 res = mmin(mmin(d, mmin(d1,d2)), d3);\n    \n    \n    \n    res = mmin(res, d4);\n    res = mmin(res, d5); \n    return res;\n}\n\n\nvec3 ray_cast(in vec3 ro, in vec3 rd){\n\n\tfloat t = 0.0; \n    float d = 0.0; \n    float absSum = 1.0;\n    for(int i = 0; i < 1000; i++){\n    \tvec2 pos = map(ro + t* rd); \n        \n        if(pos.x < 0.001){\n        \t\n            if (pos.y == 6.0) {\n             \tfloat absorp = 1.3;\n                float opacity = 1.0;\n                float d = 0.0;   \n\t\t\t\tabsSum = 0.0;\n                 \n\n                \n                //t += 0.01;\n                \n                while(pos.y == 6.0){\n                    \n                    float prev_opacity = opacity;\n                    \n                    \n                 \tpos = map(ro + t*rd);\n                    \n                    t += 0.01;\n                    \n                    if(pos.x < 0.0)\n                    \td += 0.01;\n                    \n                    opacity *= BeerLambert(absorp, 0.01);\n                    \n                    float absorb = prev_opacity -opacity;\n                    \n                    absSum += absorb;\n                    \n                }              \n                \n            }\n        \tpos.x = t; \n           \t\n            return vec3(pos, absSum);\n        } \n        \n        if(pos.x > 20.0){\n        \tbreak;\n        }\n        \n        t += pos.x;\n    }\n    \n    return vec3(vec2(-1.0), absSum);\n}\nvec3 normal(in vec3 pos){\n\n\tconst vec3 eps = vec3(0.001, 0.0, 0.0);\n    \n    \n    \n    float grad_x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    float grad_y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    float grad_z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    \n    \n    \n    return normalize(vec3(grad_x, grad_y, grad_z));\n\n\n\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nfloat checkers( in vec3 p ) {\n    vec3 s = sign(fract(p*.5)-.5);\n    return .5 - .5*s.x*s.y*s.z;\n}\n\nfloat diffuse_light(in vec3 pos, in vec3 cen){\n    \n\tvec3 nor = normal(pos);\n    vec3 dir_to_light = normalize(cen-pos);\n    float diff_intens = dot(nor, dir_to_light);\n    \n    return diff_intens;\n\n}\nfloat phong_light(in vec3 pos, in vec3 cen, in vec3 ro, in float k){\n\t\n    float specPower = k;\n    vec3 n = normal(pos);\n    vec3 l = normalize(cen-pos);\n    vec3 v = normalize(ro-pos);\n    vec3 r = reflect(v, n);\n    float phong_light = pow ( max ( dot ( l, r ), 0.0 ), specPower );\n    return phong_light;\n\n}\nfloat fog(in vec3 pos) {\n\t\n    float ans = 1.0;\n    if(abs(pos.x) > 10.0) ans *= 1.0 / (pos.x*pos.x*0.01);\n    //if(abs(pos.y) > 10.0) ans *= 1.0 / (pos.y*pos.y*0.01);\n    if(abs(pos.z) > 10.0 ) ans *= 1.0 / (pos.z*pos.z*0.01);\n    \n    return ans;\n\n}\n\n\nfloat shadow(vec3 pos, vec3 lightpos){\n\tvec3 rd = normalize(lightpos-pos);\n    float res = 1.0;\n    float t = 0.0;\n    \n    for (float i = 0.0; i < 1000.0; i++)\n    {\n\t\tvec2 h = map(pos + rd * t);\n        res = min(res, 15.0 * h.x / t);\n        t += h.x;\n        \n        if ((res < 0.000001 || t > 3200.0)) break;\n        \n    }\n    \n    return clamp(res, 0.0, 1.0);\n    \n}\n\nvec3 fogMarch(vec3 pos){\n    float absorp = 1.0;\n    float opacity = 1.0;\n    float absSum = 0.0; \n    float h = 0.0;\n\n    float prev_opacity = opacity;\n\n\n    opacity *= BeerLambert(absorp, h);\n\n    float absorb = prev_opacity -opacity; \n\n    absSum += absorb; \n    h+= 0.01;\n\n    \n    return vec3(absSum);\n    \n}\n\nvec3 mirror(in vec3 opos, in vec3 ord) {\n    \n    \n    vec3 n = normal(opos);\n    vec3 ro = opos;\n    vec3 rd = n;\n    int max_step =1;\n    vec3 lp = vec3(5.0, 5.0,0.0);\n    vec3 col =vec3(1.0,1.0,1.0);\n    for(int i=0; i < max_step; i++){\n        vec3 h = ray_cast(ro+0.1*n, reflect(-ro, n));\n\n\n        if(h.x > -1.0) {\n            vec3 pos = ro + h.x *rd;\n         \n            if(h.y == 2.0){\n                col = vec3(0.0, 0.0, 1.0) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col *= 2.0;\n                \n            }\n\n\n            if(h.y == 3.0) {\n\n                col = vec3(0.7, 0.7, 0.7) * calcAO(pos, normal(pos));\n                \n\n                col += checkers(pos);\n                col *= mix(col, vec3(0.9), 20.0);\n                col *= shadow(pos, lp);\n\n            }\n            if(h.y == 4.0) {\n\n                col = vec3(1.0,0.0,0.0) * calcAO(pos, normal(pos));\n                col *= shadow(pos, lp);\n                col *= 1.5;\n\n\n\n            }\n            if(h.y == 5.0){\n            \tcol = vec3(0.9,0.9,0.9) * diffuse_light(pos, lp) ; \n                col += checkers(pos * iTime);\n            }\n            col *= 2.0;\n            col*=fog(pos);\n\n            \n            //col = vec3(h.y,0,0);\n        }else {\n        if(rand(vec2(ord.x, ord.y )) > 0.0  )\n\t\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.2);    \n    }\n    }\n    return col;\n    \n    \n    \n}\nvec3 render(in vec3 ro, in vec3 rd){\n    \n    vec3 h = ray_cast(ro, rd);\n    vec3 lp = vec3(5.0, 5.0,0.0);\n    vec3 mp = vec3(0.0);\n    vec3 col = vec3(1.0,1.0,1.0);\n    if(h.x > -1.0){\n        vec3 pos = ro + h.x * rd;\n        \n        if(h.y == 1.0){\n        \tcol *= calcAO(pos, normal(pos));;\n            \n           \n            \n            \n           \n            col *= mirror(pos, rd); \n            //col *= shadow(pos, lp) + 0.4;\n            \n        }\n    \t\t\n    \t\n        if(h.y == 2.0){\n        \tcol = vec3(0.0, 0.0, 1.0) * calcAO(pos, normal(pos));\n            col *= shadow(pos, lp);\n            //float d = h.z; \n            //float s = d / 1.0;\n            //s = s / (1.0 + s); \n            \n           // col = (1.0 - s) * col + s * vec3(0.7);\n        }\n        \n        \n        if(h.y == 3.0) {\n        \t\n            col = vec3(0.7, 0.7, 0.7) * calcAO(pos, normal(pos));\n            \n            col += checkers(pos);\n            col *= mix(col, vec3(0.9), 20.0);\n            col *= shadow(pos, lp);\n        \t\n        }\n        if(h.y == 4.0) {\n        \t\n            col = vec3(1.0,0.0,0.0) * calcAO(pos, normal(pos)); \n        \tcol *= shadow(pos, lp);\n            \n            \n        \t\n        }\n        if(h.y == 5.0){\n        \tif(rand(vec2(rd.x, rd.y)) > 0.0 )\n\t\t\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.2);  \n        \t\n        \n        }\n        \n        \n        \n        col *= fog(pos);\n        col *= vec3(h.z);\n        \n    } else {\n        if(rand(vec2(rd.x, rd.y)) > 0.0 )\n\t\t\tcol = mix(col, vec3(0.0, 0.0, 0.0), 1.2);    \n    }\n    \n    return col;\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    int totalAASamples = 1;\n    for (int i = 0; i < totalAASamples; ++i)\n    {\n        \n        float x = mod(float(i), 2.0);\n        float y = mod(float(i / 2), 2.0);\n        \n        vec2 jitter = (Hash2(uint(i)) + vec2(x, y)) / 2.0;\n\n        vec2 uv = 2.0 * (fragCoord.xy + jitter) / iResolution.xy - 1.0;\n        uv.x *= iResolution.x / iResolution.y;\n    }\n    \n    float an = 10.0 * iMouse.x/iResolution.x;\n    \n    vec3 ro = vec3(4.0*cos(an)*1.5, 1.0, 4.0*sin(an) * 1.5);\n    vec3 ta = vec3(0.0, 0.0, 0.0); // target for camera\n\n\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize( cross(uu, ww));\n\n\n\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + ww);\n    col = render(ro, rd);\n    col /= float(totalAASamples);\n    col *= 1.0;\n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}