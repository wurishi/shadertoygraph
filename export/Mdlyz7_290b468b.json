{"ver":"0.1","info":{"id":"Mdlyz7","date":"1487614844","viewed":152,"name":"Clouds (Plane)","username":"ARPP3","description":"Cast a ray to a plane, then ray march to the top of a cloud volume. Integrate, and light the cloud.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.0001\n#define SKY_HEIGHT 300.0\n#define SKY_POINT vec3(0.0, SKY_HEIGHT, 0.0)\n#define STEP_SIZE 0.02\n#define NUM_STEPS 128\n#define CLOUD_SCALE 0.002\n#define CLOUD_HEIGHT 100.0\n\nconst float CLOUD_HEIGHT_SQUARED = CLOUD_HEIGHT * CLOUD_HEIGHT;\n\nvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\n\n// A hash function, to get a random-ish number\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// Sample 3D noise\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+0.0  ), hash(n+1.0  ),f.x),\n                   mix( hash(n+57.0 ), hash(n+58.0 ),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n// Fractional Brownian Motion (FBM Noise)\nfloat cloudMap( in vec3 p )\n{\n\tvec3 q = p * CLOUD_SCALE;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn f - cos (iTime * 0.1);\n}\n\n// To be used in a condition, hence the bool return type\nbool rayPlaneIntersect(vec3 a_rayOrigin, vec3 a_rayDirection,\n                       out vec4 point)\n{\n    // The vector pointing down is the surface normal, of the 'sky'\n\tfloat denom = dot(vec3(0.0, -1.0, 0.0), a_rayDirection);\n    \n    if (abs(denom) > EPSILON)\n    {\n        // Using a known point (SKY_POINT), and the point-normal plane\n        float t = dot(SKY_POINT - a_rayOrigin, vec3(0.0, -1.0, 0.0)) / denom;\n        if (t > 0.0)\n        {\n            // Work backwards, return the intersection point\n\t\t\tpoint = vec4(a_rayOrigin + a_rayDirection * t, t);\n            return true;\n        }\n    }\n    \n    // There isn't a collision point\n    point = vec4(0.0, 0.0, 0.0, 0.0);\n    return false;\n}\n\nvec4 integrate( in vec4 sum, in float diffuse, in float den, in vec3 bgcol, in float t )\n{\n    // lighting\n    vec3 lin = vec3(0.65,0.7,0.75)*1.4 + vec3(1.0, 0.6, 0.3) * diffuse;        \n    vec4 col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n    col.xyz *= lin;\n    col.xyz = mix( col.xyz, bgcol, 1.0-exp(-0.003*t*t) );\n    // front to back blending    \n    col.a *= 0.4;\n    col.rgb *= col.a;\n    return sum + col*(1.0-sum.a);\n}\n\nvec4 trace(vec3 a_rayOrigin, vec3 a_rayDirection, vec3 a_bgCol)\n{\n    vec4 colorSum = vec4(0.0, 0.0, 0.0, 0.0), outPoint;\n    \n    // Get the intersection of the lower cloud plane and the ray\n\tif (rayPlaneIntersect(a_rayOrigin, a_rayDirection, outPoint))\n    {\n        float stepInc = sqrt(pow(length(a_rayDirection.xz), 2.0) + \n                             CLOUD_HEIGHT_SQUARED) / float(NUM_STEPS);\n        \n        float t = 0.0;\n        // Start to integrate along the ray, now that we have a good start spot\n        for (int i = 0; i < NUM_STEPS; i++)\n        {\n            // Break, if we're at max density already\n            if (colorSum.a > 0.99) break;\n            \n            // Get a sample position along the ray (with new start pos)\n\t\t\tvec3 samplePos = outPoint.xyz + a_rayDirection * t;\n            \n            // Sample the density of the cloud\n            float cloudDensity = cloudMap(samplePos);\n            \n            // If it's larger than minimum density of 0.01\n           \tif (cloudDensity > 0.01)\n            {\n                // Sample TOWARD the sun, and check if it should be a lit cloud or not\n\t            float diffuse = clamp((cloudDensity -\n                \tcloudMap(samplePos + 0.3 * sundir)) / 0.6, 0.0, 1.0 );\n                \n                // Integrate through the clouds\n\t\t\t\tcolorSum = integrate(colorSum, diffuse, cloudDensity, a_bgCol, t);\n            }             \n        \tt += stepInc;\n        }   \n    }\n    \n    // Alpha will be 0 if there is no clouds,\n    return clamp(colorSum, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 background = vec4(0.0);\n    \n    // Create NDC UV, and also, aspect ratio fix (not really NDC then)\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Make a simple ray, with 90deg FOV\n\tvec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    vec3 rayDirection = normalize(vec3(uv, 1.3));\n    \n    // Calculate the clouds\n    vec4 clouds = trace(rayOrigin, rayDirection, background.xyz);\n    \n    fragColor = (1.0 - clouds.a) * background + clouds * clouds.a;\n}","name":"Image","description":"","type":"image"}]}