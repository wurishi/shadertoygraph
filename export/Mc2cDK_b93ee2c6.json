{"ver":"0.1","info":{"id":"Mc2cDK","date":"1723032728","viewed":25,"name":"blood pixels","username":"ShadeWhizz","description":"feedback shader","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","feedback"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// entire section taken from https://www.shadertoy.com/view/3l3yDr\n// NOISES\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash2D(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\nuint hash( uint x )\n{\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n\nfloat uintToFloat( uint m )\n{\n    return uintBitsToFloat(0x3F800000u|(m&0x007FFFFFu) ) - 1.0;\n}\n// end https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl#answer-17479300\n\nfloat random( vec2  v ) { return uintToFloat(hash(packSnorm2x16(v))); }\nfloat random( vec3  v ) { return uintToFloat(hash(\n    uvec3(floatBitsToUint(v.x), floatBitsToUint(v.y),floatBitsToUint(v.z))\n)); }\n\n\nfloat smooth_hash2D(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash2D(lower+vec2(0.0, 0.0)), hash2D(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash2D(lower+vec2(0.0, 1.0)), hash2D(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash2D(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*smooth_hash2D(uv); uv*=2.001;\n    total += 0.2500*smooth_hash2D(uv); uv*=2.003;\n    total += 0.1250*smooth_hash2D(uv); uv*=2.002;\n    total += 0.0625*smooth_hash2D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat hash3D(vec3 uv)\n{\n \tvec3 suv = fract(sin(uv));\n    mat3 rdz = mat3(0.324354, 0.303147, 0.21024,\n                    0.405434, 0.723953, 0.69343,\n                    0.904379, 0.594319, 0.10439);\n    suv = rdz*suv;\n    return fract(dot(suv, uv)*1204.9324234934);\n}\n\nfloat smooth_hash3D(vec3 uv)\n{\n \tvec3 lower\t= floor(uv);\n    vec3 frac \t= fract(uv);\n    vec3 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix( // Z\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 0.0)), hash3D(lower+vec3(1.0, 0.0, 0.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 0.0)), hash3D(lower+vec3(1.0, 1.0, 0.0)), f.x),\n                f.y),\n        \tmix( // Y\n                mix( // X\n                    hash3D(lower+vec3(0.0, 0.0, 1.0)), hash3D(lower+vec3(1.0, 0.0, 1.0)), f.x),\n                mix( // X\n                    hash3D(lower+vec3(0.0, 1.0, 1.0)), hash3D(lower+vec3(1.0, 1.0, 1.0)), f.x),\n                f.y),\n        \tf.z);\n}\n\nfloat fbm_hash3D(vec3 uv)\n{\n    float total = 0.0;\n    total += 0.5000*smooth_hash3D(uv); uv*=2.001;\n    total += 0.2500*smooth_hash3D(uv); uv*=2.003;\n    total += 0.1250*smooth_hash3D(uv); uv*=2.002;\n    total += 0.0625*smooth_hash3D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat voronoi2D(vec2 uv)\n{\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for(int j=-1; j<=1; j++ )\n    {\n        vec2 p = vec2(j, k);\n        float h = random(fl+p);\n        vec2 vp = p-fr+h;\n        float d = dot(vp, vp);\n\n        res +=1.0/pow(d, 16.0);\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat voronoi3D(vec3 uv)\n{\n    vec3 fl = floor(uv);\n    vec3 fr = fract(uv);\n    float res = 1.0;\n    for(int k=-1;k<=1;k++)\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec3 p = vec3(i, j, k);\n            float h = random(fl+p);\n            vec3 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 16.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 res = vec2(320.0, 180.0)/1.0;\n    uv = floor(uv*res)/res;\n    float d = fbm_hash3D(vec3(uv*10.0, iTime*0.1));\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n    float bayer = texture(iChannel1, uv*res/8.0).x;\n    \n    fragColor *= d > 0.5 + 0.1*bayer ? 1.0 : 0.0;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvn = uv * 2.0 - 1.0;\n    vec2 delta = normalize(uvn)*0.001;\n    fragColor = 0.5*texture(iChannel0, uv) + vec4(0.99, 0.95, 0.93, 1.0)*texture(iChannel1, uv + delta);\n}","name":"Buffer B","description":"","type":"buffer"}]}