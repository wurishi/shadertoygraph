{"ver":"0.1","info":{"id":"wscfW8","date":"1606052306","viewed":399,"name":"New Ray Tracer by Darko","username":"omegasbk","description":"Ray tracer made for Darko's Gamedev Cookbook: youtube.com/c/DarkoSupe","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Darko (omegasbk) \n//\n// Darko's Gamedev Cookbok Youtube serial\n// https://www.youtube.com/channel/DarkoSupe\n//\n// Lesson 6 & 7 \n\nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n    float reflection;\n} materials[2];\n\nstruct Sphere \n{\n    vec3 position;\n    vec3 color;\n    float radius;\n    Material material;\n} spheres[2];    \n    \n# define PLANES_COUNT 6\nstruct Plane \n{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n    Material material;\n} planes[PLANES_COUNT];\n\nstruct Camera\n{\n    vec3 position;\n    float focalDistance;\n};\n    \nstruct PointLight\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n} lights[1];\n\nconst Material material1 = Material(0.514, 0.49, 76.8, 0.7, 1.);\nconst Material material2 = Material(0.4, 0.25, 124.3, 0.2, 1.);\n\n\nSphere sphere1 = Sphere(\n    vec3(0.12, 0., 0.),  \t\t\t\t\t// position\n    vec3(0.1, 0.1, 0.3), \t\t\t\t\t// color\n    0.08,\t\t\t\t\t\t\t\t\t// radius\n    material1);  // material\n\nSphere sphere2 = Sphere(\n    vec3(-0.12, -0.05, 0.),  \t\t\t\t// position\n    vec3(0.3, 0.1, 0.1), \t\t\t\t\t// color\n    0.08,\t\t\t\t\t\t\t\t\t// radius\n    material1);  // material\n\nPlane plane1 = Plane(\n    vec3(0., -0.2, 0.), \n    vec3(0., 1., 0.), \n    vec3(0.5, 0.5, 0.5), \n    material2);\n\nPlane plane2 = Plane(\n    vec3(-0.3, 0., 0.), \n    vec3(1., 0., 0.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPlane plane3 = Plane(\n    vec3(0.3, 0., 0.), \n    vec3(-1., 0., 0.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPlane plane4 = Plane(\n    vec3(0., 0.3, 0.), \n    vec3(0., -1., 0.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPlane plane5 = Plane(\n    vec3(0., 0., .12), \n    vec3(0., 0., -1.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPlane plane6 = Plane(\n    vec3(0., 0., -1.), \n    vec3(0., 0., 1.), \n    vec3(0.2, 0.5, 0.6), \n    material2);\n\nPointLight light1 = PointLight(\n    vec3(0., 0.19, -0.2), // position\n    vec3(1., 1., 1.),     // color\n    15.);                 // intensity\n\nCamera camera = Camera(\n    vec3(0., 0., -0.3),\n    0.6);\n\n#define SPHERE 0\n#define PLANE 1\n\nvoid setupScene()\n{\n\tspheres[0] = sphere1;\n    spheres[1] = sphere2;\n    planes[0] = plane1;\n    planes[1] = plane2;\n\tplanes[2] = plane3;\n    planes[3] = plane4;\n\tplanes[4] = plane5;\n    planes[5] = plane6;\n    lights[0] = light1;\n}\n\n//////////////////////////////////////////////////////////////\n// \t                        UTILS                           // \n//////////////////////////////////////////////////////////////\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\n//////////////////////////////////////////////////////////////\n// \t                   INTERSECTION CODE                    // \n//////////////////////////////////////////////////////////////\nbool intersectSphere(\n    vec3 origin, \n    vec3 direction, \n    Sphere sphere, \n    out float dist, \n    out vec3 surfaceNormal, \n    out vec3 Phit)\n{\n    vec3 L = origin - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {        \n        if (t0 > t1) \n        {\n        \tfloat temp = t0;\n            t0 = t1;\n            t1 = temp;\n        } \n \n        if (t0 < 0.)\n        { \n            t0 = t1; // if t0 is negative, let's use t1 instead \n            if (t0 < 0.) return false; // both t0 and t1 are negative \n        }  \n             \n        dist = t0;\n       \n        Phit = origin + dist * direction;\n        surfaceNormal = normalize(Phit - sphere.position);               \n        \n        return true;\n    }  \n     \n    return false;\n}\n\nbool intersectPlane(in Plane plane, in vec3 origin, in vec3 rayDirection, out float hitDistance) \n{ \n    // Assuming vectors are all normalized\n    float denom = dot(plane.normal, rayDirection); \n    if (denom < 1e-6) \n    { \n        vec3 p0l0 = plane.position - origin; \n        hitDistance = dot(p0l0, plane.normal) / denom; \n        return (hitDistance >= 0.); \n    } \n \n    return false; \n} \n\n//////////////////////////////////////////////////////////////\n// \t                     LIGTHING CODE                      // \n//////////////////////////////////////////////////////////////\nvoid fresnel(vec3 I, vec3 N, float ior, out float kr) \n{ \n    float cosi = clamp(-1., 1., dot(I, N)); \n    \n    float etai = 1., etat = ior; \n    \n    if (cosi > 0.) \n    {\n        float temp = etai;\n        etai = etat;\n        etat = temp;        \n    } \n    \n    // Compute sini using Snell's law\n    float sint = etai / etat * sqrt(max(0., 1. - cosi * cosi)); \n    \n    // Total internal reflection\n    if (sint >= 1.)\n    { \n        kr = 1.; \n    } \n    else \n    { \n        float cost = sqrt(max(0., 1. - sint * sint)); \n        cosi = abs(cosi); \n        float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost)); \n        float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost)); \n        kr = (Rs * Rs + Rp * Rp) / 2.; \n    } \n    // As a consequence of the conservation of energy, transmittance is given by:\n    // kt = 1 - kr;\n} \n\nvoid calculateShadow(vec3 pHit, inout vec3 finalColor, in float ambient, int type, int index)\n{\n    // Intersect spheres\n    vec3 shadowSurfaceNormal;\n    vec3 shadowRay = lights[0].position - pHit;\n    vec3 shadowRayDirection = normalize(shadowRay);\n    float distanceToLight = sqrt(dot(shadowRay, shadowRay));\n    vec3 shadowPhit;\n    \n    float dist; \n    \n    for(int i = 0; i < 2; ++i)\n\t{\n        if (type == SPHERE && index == i)\n        {\n            continue;  \n        }\n    \n        if (intersectSphere(pHit, shadowRay, spheres[i], dist, shadowSurfaceNormal, shadowPhit))\n        {\n            if (dist > 0. && distanceToLight > dist)\n            {\n            \tfinalColor *= 2. * ambient; // Educated guess\n            }\n        }\n    }\n    \n    // Intersect planes\n    for(int i = 0; i < PLANES_COUNT; ++i)\n\t{\n \t\tif (type == PLANE && index == i)\n        {\n            continue;\n        }\n        \n        if (intersectPlane(planes[i], pHit, shadowRay, dist))\n        {    \n            if (dist < distanceToLight)\n            {                \n \t\t\t\tfinalColor *= 2. * ambient;        \n            }\n        }\n    }     \n}\n\nvec3 getLitColor(in vec3 viewDir, in vec3 surfacePointPosition, in vec3 objectColor, in PointLight pointLight, in vec3 surfaceNormal, in Material material)\n{\n    vec3 lightVector = surfacePointPosition - pointLight.position;\n    vec3 lightDir = normalize(lightVector);   \n    \n   \tfloat lightIntensity = (pow(0.1, 2.) / pow(sqrt(dot(lightVector, lightVector)), 2.)) * pointLight.intensity;\n    \n    float coeff = -dot(lightDir, surfaceNormal);     \n    \n    vec3 ambient = material.ambience * objectColor;\n        \n    vec3 diffuse = material.diffuse * max(coeff, 0.) * objectColor * lightIntensity;\n       \n    vec3 halfwayDir = normalize(lightDir + viewDir);  \n    vec3 specular = pow(max(-dot(surfaceNormal, halfwayDir), 0.0), material.shininess) * material.specular * objectColor * lightIntensity;\n    \n    vec3 color = ambient + diffuse + specular;\n    \n    return color;\n}\n\nMaterial getMaterial(int type, int index)\n{\n    if (type == SPHERE)\n    {\n        return spheres[index].material;\n    }\n    \n    if (type == PLANE)\n    {\n        return planes[index].material;\n    }\n}\n\n//////////////////////////////////////////////////////////////\n// \t                       MAIN CODE                        // \n//////////////////////////////////////////////////////////////\nvec3 rayMarch(in vec3 rayDirection, in vec3 rayOrigin)\n{\n    // Final color output - will be blended with all results below\n    vec3 finalColor = vec3(0.);\n    \n    int BOUNCES = 2;\n    \n    int type = -1;\n    int index = -1;\n    \n    int prevType = -1;\n    int prevIndex = -1;\n    \n    for (int bounce = 0; bounce < BOUNCES; bounce++)\n    {\n        float dist =  1.0 / 0.0; // Infinity\n        float planeHitDistance = dist;\n        float sphereHitDistance = dist;\n\n        vec3 passColor = vec3(0.);\n    \tvec3 surfaceNormal;\n    \tvec3 pHit;\n        \n        // Get color base\n        // Intersect spheres\n        for(int i = 0; i < 2; ++i)\n        {\n            if (prevType == SPHERE && prevIndex == i)\n            {\n                continue;\n            }\n            \n            if (intersectSphere(rayOrigin, rayDirection, spheres[i], sphereHitDistance, surfaceNormal, pHit))\n            {\n                if (sphereHitDistance <= dist)\n                {  \n                    passColor = getLitColor(rayDirection, pHit, spheres[i].color, lights[0] /* TODO: support more lights */, surfaceNormal, spheres[i].material);        \n                    calculateShadow(pHit, passColor, spheres[i].material.ambience, SPHERE, i);\n                  \n                    type = SPHERE;\n                    index = i;\n                    \n                    dist = sphereHitDistance;\n                }\n            }\n        }\n\n        // Intersect planes\n        for(int i = 0; i < PLANES_COUNT; ++i)\n        {\n            if (prevType == PLANE && prevIndex == i)\n            {\n                continue;\n            }\n            \n            if (intersectPlane(planes[i], rayOrigin, rayDirection, planeHitDistance))\n            {\n                if (planeHitDistance <= dist)\n                {    \n                    passColor = getLitColor(rayDirection, rayOrigin + planeHitDistance * rayDirection, planes[i].color, lights[0] /* TODO: support more lights */, planes[i].normal, planes[i].material);        \n                    dist = planeHitDistance;\n\n                    pHit = rayOrigin + rayDirection * dist;\n                    surfaceNormal = planes[i].normal;\n\n                    calculateShadow(pHit, passColor, planes[i].material.ambience, PLANE, i);\n                \n                \ttype = PLANE;\n                    index = i;\n                }\n            }\n        } \n        \n        if (bounce == 0)\n        {\n       \t\tfinalColor += passColor;\n        }\n        else\n        {\n            finalColor += getMaterial(prevType, prevIndex).specular * passColor;\n        }\n        \n        rayOrigin = pHit;\n        rayDirection = normalize(reflect(rayDirection, surfaceNormal));\n        prevType = type;\n        prevIndex = index;\n    }\n        \n\treturn finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupScene();\n    \n    //camera.position.z += iMouse.y / iResolution.y / 4.;\n    lights[0].position.x = (iMouse.x/ iResolution.x - 0.5) / 4.;\n    lights[0].position.z = (iMouse.y/ iResolution.y - 0.5) / 3. - 0.3;\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 clipPlanePosition = vec3(uv.x, uv.y, camera.position.z + camera.focalDistance);\n    vec3 rayDirection = normalize(clipPlanePosition - camera.position);\n    \n    vec3 finalColor = rayMarch(rayDirection, camera.position);\n    \n    // Fake antialiasing\n    /*int sampleSize = 2;\n    for (int i = -sampleSize; i < sampleSize; i++)\n    {\n        for (int j = -sampleSize; j < sampleSize; j++)\n        {\n            clipPlanePosition = vec3(uv.x + float(i) / iResolution.x, uv.y + float(j) / iResolution.y, camera.position.z + camera.focalDistance);\n    \t\trayDirection = normalize(clipPlanePosition - camera.position);\n            finalColor += rayMarch(rayDirection, camera.position);\n        }\n    }   \n    finalColor /= pow(float(sampleSize) * 2., 2.);*/\n    \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}