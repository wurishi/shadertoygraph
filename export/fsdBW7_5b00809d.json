{"ver":"0.1","info":{"id":"fsdBW7","date":"1656752878","viewed":391,"name":"The Backroom","username":"playbyan1453","description":"Only sphere lights also I don't implement the wall textures.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer","montecarlo","tile","bidirectional"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Credits\n// Monterman : https://www.shadertoy.com/view/4dyBRK\n// markjarzynski : https://www.shadertoy.com/view/XlGcRh\n// michael0884 : https://www.shadertoy.com/view/wltcRS\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    col = max(col, 0.0);\n    col = tanh(pow(col, vec3(0.4545))); // Little Trick from michael0884\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Amazing work from reinder. With some changes.\n// https://www.shadertoy.com/view/4lfGWr\n#define tmax 1e19\n#define epsilon 1e-4\n#define ligbounces 2\n#define eyebounces 4\n#define bluenoise\n// #define shadow\n\n// #define ortho\n#define depthoffield\n#define bloom\n\nfloat time;\n\nstruct material {\n    vec3 albedo;\n    float ior;\n    bool specular;\n    bool emission;\n};\n\n// Hash functions by markjarzynski:\n// https://www.shadertoy.com/view/XlGcRh\nuvec2 baseHash(uvec2 p) {\n    p = p * 1664525u + 1013904223u;\n    p += p.yx * 1664525u;\n    p = p ^ (p >> 16u);\n    p += p.yx * 1664525u;\n    return p ^ (p >> 16u);\n}\n\n#ifdef bluenoise\n// Blue Hash Function by michael0884:\n// https://www.shadertoy.com/view/wltcRS\nivec2 px;\nvec4 baseBlueHash(inout float seed) {\n    uvec2 n = baseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)));\n    ivec2 p = (px + ivec2(n & 0x7fffffffu)) % 1024;\n    return abs(2.0 * fract(texelFetch(iChannel1, p, 0) + 1.3247181 * seed) - 1.0);\n}\n\nfloat hash1(inout float seed) {\n    return baseBlueHash(seed).x;\n}\n\nvec2 hash2(inout float seed) {\n    return baseBlueHash(seed).xy;\n}\n#else\nfloat hash1(inout float seed) {\n    return float(baseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1))).x) / float(0xffffffffu);\n}\n\nvec2 hash2(inout float seed) {\n    return vec2(baseHash(floatBitsToUint(vec2(seed += 0.1, seed += 0.1)))) / float(0xffffffffu);\n}\n#endif\n\n// Checkboard pattern\nfloat checkboard(vec2 p) {\n    p = floor(p);\n    return mod(p.x + p.y, 2.0);\n}\n\n// Intersectors by iq\nfloat sphere(vec3 ro, vec3 rd, vec3 p, float r) {\n    vec3 o = p - ro;\n    float t,\n    b = dot(o, rd),\n    d = b * b - dot(o, o) + r * r;\n    if(d < 0.0) return tmax;\n    d = sqrt(d);\n    (t = b - d) > 0.0 ? t : (t = b + d) > 0.0 ? t : tmax;\n    return t;\n}\n/*\nfloat ellipsoid(vec3 ro, vec3 rd, vec3 p, vec3 r) {\n    vec3 ocn = ro / r,\n         rdn = rd / r;\n    float t,\n    a = dot(rdn, rdn),\n    b = dot(ocn, rdn),\n    c = dot(ocn, ocn),\n    d = b * b - a * (c - 1.0);\n    if(d < 0.0) return tmax;\n    d = sqrt(d);\n    (t = (-b - d) / a) > 0.0 ? t : (t =(-b + d) / a) > 0.0 ? t : tmax;\n    return t;\n}\n*/\nfloat plane(vec3 ro, vec3 rd, float h, vec3 n) {\n    float d = dot(rd, n);\n    float t = -(dot(ro, n) - h) / d;\n    return t;\n}\n\nfloat boxSDF(vec2 p, vec2 b) {\n    return length(max(abs(p) - b, 0.0));\n}\n\n// Exact solution in comment there : https://www.shadertoy.com/view/XtGfzw\nfloat crossSDF(vec2 p, vec2 b) {\n    p = abs(p); p = (p.y > p.x) ? p.yx : p.xy;\n    vec2 u = p - b.yy;\n    vec2 v = p - b;\n    if((u.x > 0.0 || v.y < v.x)\n    && (v.x < 0.0 || v.y < 0.0)) return max(v.x, v.y);\n    float d = length(u.x < 0.0 ? u : v);\n    return u.x < 0.0 ? max(0.0 - d, v.x) : d;\n}\n\n#define lightCol vec3(15)\nconst vec4 lightSphere = vec4(0, 2, 0, 0.5);\n\nfloat walls(vec3 p) {\n    float c = 16.0;\n    vec2 a = p.xz;\n    a -= vec2(0.5 * c);\n    a  = mod(a + 0.5 * c, c) - 0.5 * c;\n    float b = length(a) - 6.2;\n    if(b > 0.1) return b;\n    return min(crossSDF(a, vec2(6, 1)), max(crossSDF(a, vec2(6.1, 1.1)), p.y+1.4));\n}\n\nvec2 map(vec3 p) {\n    float c = 16.0;\n    vec3 b = p;\n    b.xz = mod(b.xz + 0.5 * c, c) - 0.5 * c;\n    float l = length(b - lightSphere.xyz) - lightSphere.w;\n    float t = min(walls(p), l);\n    return vec2(t, t == l);\n}\n\nvec3 normal(vec3 p) {\n    const vec2 h = vec2(1,-1)*epsilon;\n    return normalize(h.xyy*map(p + h.xyy).x+\n                     h.yyx*map(p + h.yyx).x+\n                     h.yxy*map(p + h.yxy).x+\n                     h.xxx*map(p + h.xxx).x);\n}\n\nfloat raymarch(vec3 ro, vec3 rd, inout bool light) {\n    float t = epsilon;\n    for(int i = 0; i < 256; i++) {\n        vec2 d = map(ro + rd * t);\n        t += d.x;\n        light = bool(d.y);\n        if(d.x < epsilon * t || t > 100.0) break;\n    }\n    return t < 100.0 ? t : tmax;\n}\n\nfloat scene(vec3 ro, vec3 rd, inout material mat, inout vec3 nor) {\n    float tmin = tmax;\n    bool light = false;\n    float t = raymarch(ro, rd, light);\n    if(t > epsilon && tmin > t) {\n        tmin = t;\n        vec3 p = ro + rd * t;\n        nor = normal(p);\n        vec3 texWall = mix(vec3(0.718, 0.769, 0.353), vec3(0.635, 0.682, 0.278), smoothstep(0.09, 0.1, sin((p.x + p.z) * 16.0)*0.5+0.5));\n        mat = material(mix(mix(texWall, vec3(0.898, 0.698, 0.424), step((ro+rd*t).y, -1.39)), lightCol, float(light)), 1.5, false, light);\n    }\n    vec3 p0N = normalize(vec3(0, 1, 0));\n    t = plane(ro, rd,-2.0, p0N);\n    if(t > epsilon && tmin > t) {\n        tmin = t;\n        nor = p0N;\n        mat = material(vec3(0.898, 0.698, 0.424), 1.5, false, false);\n    }\n    vec3 p1N = normalize(vec3(0,-1, 0));\n    t = plane(ro, rd,-2.0, p1N);\n    if(t > epsilon && tmin > t) {\n        tmin = t;\n        nor = p1N;\n        mat = material(vec3(0.95), 1.5, false, false);\n    }\n    return tmin;\n}\n\nbool sceneShadow(vec3 ro, vec3 rd, float d) {\n    float t;\n    #ifdef shadow\n    bool light = false;\n    t = raymarch(ro, rd, light); if(t > epsilon && t < d) return !light;\n    #endif\n    return false;\n}\n\nvec3 randomSphere(inout float seed) {\n    vec2 uv = hash2(seed) * vec2(2.0, 6.2831853) - vec2(1, 0);\n    return vec3(sqrt(1.0 - uv.x * uv.x) * vec2(cos(uv.y), sin(uv.y)), uv.x);\n}\n\nvec3 cosineHemisphere(vec3 nor, inout float seed) {\n    return normalize(nor + randomSphere(seed));\n}\n\nvec2 sampleDisk(inout float seed) {\n    vec2 uv = hash2(seed) * vec2(1.0, 6.2831853);\n    return sqrt(uv.x) * vec2(sin(uv.y), cos(uv.y));\n}\n\n// https://github.com/gkjohnson/three-gpu-pathtracer/blob/main/src/shader/shaderUtils.js\nvec2 triangleSample(vec2 a, vec2 b, vec2 c, inout float seed) {\n    // get the edges of the triangle and the diagonal across the\n    // center of the parallelogram\n    vec2 e1 = a - b;\n    vec2 e2 = c - b;\n    vec2 diag = normalize(e1 + e2);\n    // pick a random point in the parallelogram\n    vec2 r = hash2(seed);\n    if(r.x + r.y > 1.0) r = 1.0 - r;\n    return e1 * r.x + e2 * r.y;\n}\n\n// samples an aperture shape with the given number of sides. 0 means circle\nvec2 sampleAperture(int blades, inout float seed) {\n    if(blades == 0) {\n        return sampleDisk(seed);\n    } else {\n        blades = max(blades, 3);\n        float anglePerSegment = 6.2831853 / float(blades);\n        float segment = floor(float(blades) * hash1(seed));\n        float angle1 = anglePerSegment * segment;\n        float angle2 = angle1 + anglePerSegment;\n        vec2 a = vec2(sin(angle1), cos(angle1));\n        vec2 b = vec2(0);\n        vec2 c = vec2(sin(angle2), cos(angle2));\n        return triangleSample(a, b, c, seed);\n    }\n}\n\nvec3 sampleLight(vec3 ro, inout float seed) {\n    vec3 n = randomSphere(seed) * lightSphere.w;\n    return lightSphere.xyz + n - ro;\n}\n\nvec3 getBRDFRay(inout vec3 ro, vec3 rd, vec3 n, material mat, inout bool specularBounce, inout float seed) {\n    specularBounce = false;\n    if(!mat.specular) {\n        ro += n * epsilon;\n        return cosineHemisphere(n, seed);\n    } else {\n        specularBounce = true;\n        float n1, n2, ndotr = dot(rd, n);\n        if(ndotr > 0.0) {\n            n1 = 1.0 / mat.ior; n2 = 1.0;\n            n = -n;\n        } else {\n            n2 = 1.0 / mat.ior; n1 = 1.0;\n        }\n        \n        float r0 = (n1 - n2) / (n1 + n2); r0 *= r0;\n        float fresnel = r0 + (1.0 - r0) * pow(1.0 - abs(ndotr), 5.0);\n        \n        vec3 ref = refract(rd, n, n2 / n1);\n        ro -= n * epsilon;\n        if(ref == vec3(0) || hash1(seed) < fresnel) {\n            ref = reflect(rd, n);\n            ro += n * epsilon;\n        }\n        return ref;\n    }\n}\n\nstruct LightPathNode {\n    vec3 col;\n    vec3 pos;\n    vec3 nor;\n};\n\nLightPathNode lpNodes[ligbounces];\n\nvoid constructLightPath(inout float seed) {\n    vec3 ro, rd;\n    ro = rd = randomSphere(seed);\n    ro = lightSphere.xyz - ro * lightSphere.w;\n    \n    vec3 col = lightCol;\n    \n    bool specularBounce;\n    for(int i = 0; i < ligbounces; i++) {\n        vec3 nor;\n        material mat;\n        float tmin = scene(ro, rd, mat, nor);\n        if(!mat.emission && dot(rd, nor) < 0.0) {\n            ro = ro + rd * tmin;\n            float c = 16.0;\n            ro.xz = mod(ro.xz + 0.5 * c, c) - 0.5 * c; // Hacky way to get multiple lights\n            col *= mat.albedo;\n            \n            lpNodes[i].pos = ro;\n            if(!mat.specular) lpNodes[i].col = col; // * clamp(dot(nor, -rd), 0.0, 1.0);\n            lpNodes[i].nor = nor;\n            \n            rd = getBRDFRay(ro, rd, nor, mat, specularBounce, seed);\n        } else break;\n    }\n}\n\nfloat getWeightForPath(int e, int l) {\n    return float(e + l + 2);\n}\n\nvec3 pathtrace(vec3 ro, vec3 rd, inout float seed) {\n    vec3 tcol = vec3(0);\n    vec3 fcol = vec3(1);\n    \n    bool specularBounce = true;\n    int jdiff = 0;\n    float fogDepth;\n    for(int j = 0; j < eyebounces; j++) {\n        vec3 nor;\n        material mat;\n        float tmin = scene(ro, rd, mat, nor);\n        if(tmin > epsilon && tmin < tmax) {\n            if(j == 0) fogDepth = tmin;\n            if(mat.emission) {\n                if(specularBounce) tcol += fcol * lightCol;\n                break; // the light has no diffuse component, therefore we can return col\n            }\n            \n            fcol *= mat.albedo;\n            ro = ro + rd * tmin;\n            rd = getBRDFRay(ro, rd, nor, mat, specularBounce, seed);\n            \n            if(!mat.specular || !specularBounce) {\n                float c = 16.0;\n                ro.xz = mod(ro.xz + 0.5 * c, c) - 0.5 * c; // Hacky Way to get multiple lights\n                // path of (j+1) eyepath-nodes, and 1 lightpath-node (= direct light sampling)\n                // Better direct light by ockiller: https://www.shadertoy.com/view/7ll3zN\n                vec3 ld = sampleLight(ro, seed);\n                vec3 nld = normalize(ld);\n                if(!sceneShadow(ro, nld, length(ld))) {\n                    float d2 = dot(ld, ld);\n                    float weight = 2.0 * (1.0 - sqrt(d2 - lightSphere.w * lightSphere.w) * inversesqrt(d2));\n                          weight = clamp(weight * dot(nld, nor), 0.0, 1.0);\n                    \n                    tcol += (fcol * lightCol) * weight / getWeightForPath(jdiff,-1);\n                }\n                for(int i = 0; i < ligbounces; i++) {\n                    // path of (j+1) eyepath-nodes, and i+2 lightpath-nodes.\n                    vec3 lp = lpNodes[i].pos - ro;\n                    vec3 lpn = normalize(lp);\n                    vec3 lc = lpNodes[i].col;\n                    \n                    if(!sceneShadow(ro, lpn, length(lp))) {\n                        // weight for going from (j+1)th eyepath-node to (i+1)th lightpath-node\n                        // Note : I guessed this one, Most likely biased.\n                        float weight = clamp(\n                                 dot( lpn, nor) \n                               * dot(-lpn, lpNodes[i].nor)\n                               * (1.0 / dot(lp, lp)), 0.0, 1.0)\n                               * ((lightSphere.w * lightSphere.w) * 3.9269908); // pi * 1.25\n                        \n                        tcol += lc * fcol * weight / getWeightForPath(jdiff, i - 1);\n                    }\n                }\n                jdiff++;\n            } else jdiff = 0;\n        } else break;\n    }\n    float fog = exp(-0.01 * fogDepth);\n    tcol *= fog; \n    tcol += (1.0 - fog) * (1.0 - fog) * 0.1 * vec3(1.0, 0.9, 0.8);\n    return tcol;\n}\n\nmat3 cam(vec3 at, vec3 ro) {\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nint frame;\nvoid init(vec2 fragCoord, inout float seed) {\n    #ifdef bluenoise\n    px = ivec2(fragCoord);\n    seed = float(baseHash(uvec2(frame)).x)/float(0xffffffffu);\n    #else\n    seed = float(baseHash(floatBitsToUint(fragCoord) + uint(frame)).x)/float(0xffffffffu);\n    #endif\n    time = 0.0 + hash1(seed) / 16.0;\n}\n\nvoid mainImages(out vec4 fragColor, vec2 fragCoord) {\n    float seed;\n    init(fragCoord, seed);\n    \n    vec2 rnd = sampleDisk(seed);\n    vec2 uv = fragCoord + rnd;\n         uv = (2.0 * uv - iResolution.xy) / max(iResolution.x, iResolution.y);\n    \n    rnd = sampleAperture(7, seed); // To keep the seed consistent I put things here.\n    float r = hash1(seed);\n    #ifdef bloom\n    r = log2(1.0 - r * r);\n    uv += rnd * (r * r) * 2.0 / max(iResolution.x, iResolution.y);\n    #endif\n    \n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = vec3(0, 0,-8);\n    mat3 ca = cam(at, ro);\n    #ifndef ortho\n    vec3 rd = ca * normalize(vec3(uv, 1));\n    #else\n    uv *= 7.5;\n    ro = ro + uv.x * ca[0] + uv.y * ca[1];\n    vec3 rd = ca[2];\n    #endif\n    \n    \n    #ifdef depthoffield\n    // Lens Camera Focal Plane relative to the camera\n    vec3 p = ca[2];\n    float t = plane(ro, rd, dot(p, ro - p) + 16.0, p);\n    vec3 fp = ro + rd * t;\n    ro += ca * vec3(rnd, 0) * 0.1;\n    rd = normalize(fp - ro);\n    #endif\n    \n    constructLightPath(seed);\n    vec3 col = pathtrace(ro, rd, seed);\n    if(all(isnan(col)) || all(isinf(col))) col = vec3(0);\n    vec3 prev_col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    fragColor.xyz = mix(prev_col, col, 1.0 / float(frame + 1));\n}\n\n// Tiled Rendering by morimea : https://www.shadertoy.com/view/tltBzM\n// Rendering option\n// #define progressive\n#ifndef progressive\n#define tilecount 2\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    #ifndef progressive\n    int tiles = tilecount;\n    frame = iFrame / (tiles*tiles);\n    \n    ivec2 tile_size = (ivec2(iResolution.xy) / tiles);\n    //fix for dFd and texture, making tile size %2\n    tile_size = ivec2(ceil(vec2(tile_size) / 2.0)) * 2;\n    \n    int tile_id = int(fragCoord.x) / tile_size.x + (int(fragCoord.y) / tile_size.y) * tiles;\n    if(tile_id != (iFrame % (tiles * tiles))) {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n    mainImages(fragColor, fragCoord);\n    frame += 1;\n    #else\n    frame = iFrame;\n    mainImages(fragColor, fragCoord);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// HDR export in OpenEXR format file by clicking image icon on bottom right\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    // Color Grading (in linear space)\n    col = max(col * vec3(1.000, 0.953, 0.659), 0.0);\n    \n    // Vignette by Ippokratis : https://www.shadertoy.com/view/lsKSWR\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= 1.0 - uv;\n    col *= pow(uv.x * uv.y * 15.0, 0.25);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}