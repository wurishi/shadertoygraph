{"ver":"0.1","info":{"id":"3dSGRh","date":"1548053920","viewed":299,"name":"Obsidian","username":"bitnenfer","description":"inspired by yx's shader (https://www.shadertoy.com/view/wsB3Rz)","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 uLightDir = vec3(0.0, 1.0, 0.0);\nconst vec3 uLightColor = vec3(5.0,6.0,12.0);\nconst float uScale = 4.;\n\nstruct Material {\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nstruct Scene {\n    int type;\n    float dist;\n    Material material;\n};\n\nstruct DirLight {\n    vec3 dir;\n    vec3 color;\n};\n\nconst Material kNoMaterial = Material(vec3(0.0), 0.0, 0.0);\n\nmat2 Rotate(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); }\nvec3 Repeate(vec3 p, vec3 r) {\n//    r*=uScale;\n    return mod(p, r) - 0.5 * r;\n}\n\nMaterial MixMaterial(Material a, Material b, float m) {\n    return Material(\n        mix(a.albedo, b.albedo, m),\n        mix(a.roughness, b.roughness, m),\n        mix(a.metallic, b.metallic, m)\n    );\n}\n\nfloat NormalDistributionFunctionGGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = 3.14 * (denom * denom);\n    return a2 / denom;\n}\n\nfloat GeometryGGX(float NdotV, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float a)\n{\n    float g1 = GeometryGGX(NdotL, a);\n    float g2 = GeometryGGX(NdotV, a);\n    return g1 * g2;\n}\n\nvec3 FresnelSchlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 Shade(vec3 n, vec3 v, DirLight l, in Material material)\n{\n    vec3 F0 = mix(vec3(0.04), material.albedo, material.metallic);\n    vec3 h = normalize(v + l.dir);\n    float roughness = material.roughness * material.roughness;\n    float NdotL = max(0.0, dot(n, l.dir));\n    float NdotV = max(0.0, dot(n, v));\n    float D = NormalDistributionFunctionGGXTR(n, h, roughness);\n    vec3 F = FresnelSchlick(v, h, F0);\n    float G = GeometrySmith(NdotV, NdotL, roughness);\n    vec3 Kd = (1.0 - F) * (1.0 - material.metallic);\n    vec3 radiance = l.color;\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, .01);\n    \n    return (material.albedo * 0.3) + ((Kd * material.albedo / 3.14 + specularBRDF) * radiance * NdotL);\n}\n\nScene SceneUnion(Scene a, Scene b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}\n\nfloat Box(vec3 p, vec3 s) {\n    vec3 d = abs(p) - (s * uScale);\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n// iq's\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - (h * uScale);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat Ring(vec3 p, float radius) {\n    float outer = sdCappedCylinder(p, vec2(radius, 0.025));\n    float inner = sdCappedCylinder(p, vec2(radius-0.05, 1.0));\n    return max(outer, -inner);\n}\n\nScene GetOuterBox(vec3 p) {\n    p.xz *= Rotate(-iTime * .4);\n    p.xy *= Rotate(0.615472907);\n    p.yz *= Rotate(0.785398);\n    float border = 0.95;\n    float scene = Box(p, vec3(1.0));\n    float boxOut = scene;\n    float remove = Box(p, vec3(2.0, border, border));\n    remove = min(remove, Box(p, vec3(border, 2.0, border)));\n    remove = min(remove, Box(p, vec3(border, border, 2.0)));\n    scene = max(scene, -remove);\n    vec3 p2 = p;\n    vec3 p3 = p;\n    p2.xy *= Rotate(3.14 / 2.0);\n    p3.yz *= Rotate(3.14 / 2.0);\n    float rings = 100.;\n    float ringRadius = 1.1;\n    rings = min(rings, Ring(Repeate(p, uScale*vec3(0.0, 1.95, 0.0)), ringRadius));\n    rings = min(rings, Ring(Repeate(p2, uScale*vec3(0.0, 1.95, 0.0)), ringRadius));\n    rings = min(rings, Ring(Repeate(p3, uScale*vec3(0.0, 1.95, 0.0)), ringRadius));\n    rings = max(rings, boxOut);\n    return Scene(2, min(scene, rings), Material(vec3(3.0), 0.8, 0.0));\n}\n\nScene GetInnerContent(vec3 p) {\n    vec3 pmin = p;\n    vec3 pmax = p;\n    pmin.xz *= Rotate(-iTime * .4);\n    pmin.xy *= Rotate(0.615472907);\n    pmin.yz *= Rotate(0.785398);\n    pmax.xz *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    pmax.yz *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    pmax.xy *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    float clip = Box(pmin, vec3(0.85));\n    vec3 pmod = Repeate(pmax + vec3(0, iTime * 0.5, 0), vec3(0.4) * 2.0);\n    float dispSize = ((sin(p.y) + sin(p.z) + sin(p.x) + iTime * 5.0) * 0.15);\n    float scene = Box(pmod, vec3(0.1 + 0.2 * sin(dispSize + p.y * 0.19)));\n\n    scene = max(scene, clip);\n\n    return Scene(1, scene, Material(vec3(0.0, 0.0, 0.01), 0.1, 1.0));\n}\n\nScene GetInnerContent2(vec3 p) {\n    vec3 pmin = p;\n    vec3 pmax = p;\n    pmin.xz *= Rotate(-iTime * .4);\n    pmin.xy *= Rotate(0.615472907);\n    pmin.yz *= Rotate(0.785398);\n    pmax.xz *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    pmax.yz *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    pmax.xy *= Rotate(iTime * 0.8 + sin(0.2 * iTime + p.y * 0.1));\n    float clip = length(pmin)-1.1*uScale;\n    vec3 pmod = Repeate(pmax + vec3(0, iTime * 0.5, 0), vec3(0.4) * 2.0);\n    float dispSize = ((sin(p.y) + sin(p.z) + sin(p.x) - iTime * 5.0) * 0.15);\n    float scene = Box(pmod, vec3(0.2 + 0.8 * sin(dispSize - p.y * 0.19)));\n\n    scene = max(scene, clip);\n\n    return Scene(1, scene, Material(vec3(0.0, 0.01, 0.0), 0.1, 1.0));\n}\n\nScene GetFloor(vec3 p) {\n    return Scene(1, Box(p + vec3(0.0, 2.75, 0.0) * uScale, vec3(1, 1.0,1)) - 0.1, Material(vec3(.2,0,0.0), 0.3, 0.));\n}\n\nScene MixScene(Scene a, Scene b, float m) {\n    return Scene(\n        int(mix(float(a.type), float(b.type), m)),\n        mix(a.dist, b.dist, m),\n        MixMaterial(a.material, b.material, pow(m, 5.0))\n    );    \n}\n\nuniform float uFactor;\n\nScene GetScene(vec3 p) {\n    Scene scene = Scene(0, 100., kNoMaterial);\n\n    scene = SceneUnion(scene, Scene(3, 9.0 - p.y, Material(vec3(1), 1.0, 0.0)));\n    scene = SceneUnion(scene, GetOuterBox(p));\n    scene = SceneUnion(scene, MixScene(GetInnerContent2(p), GetInnerContent(p), abs(sin(0.2*iTime + p.y * 0.01))));\n    scene = SceneUnion(scene, GetFloor(p));\n\n    return scene;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(0,.01);\n    return normalize(GetScene(p).dist - vec3(\n            GetScene(p - e.yxx).dist,\n            GetScene(p - e.xyx).dist,\n            GetScene(p - e.xxy).dist\n        ));\n}\n\nScene RayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < 80; ++i) {\n        vec3 p = (ro + rd * t);\n        Scene scene = GetScene(p);\n        if (scene.dist < .01) {\n            return Scene(scene.type, t, scene.material);\n        }\n        t += scene.dist * 0.9;\n        if (t > 200.) break;\n    }\n\n    return Scene(0, 100., kNoMaterial);\n}\n\nvec3 Trace(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.0);\n    vec3 skyColor = vec3(0.0);\n    float atten = 1.0;\n    vec3 point = ro + rd;\n    for (int i = 0; i < 2; ++i) {\n        Scene scene = RayMarch(ro, rd);\n        if (scene.type == 1) {\n            vec3 p = ro + rd * scene.dist;\n            vec3 n = GetNormal(p);\n            vec3 v = normalize(-rd);\n            DirLight l = DirLight(uLightDir, uLightColor);\n            color += vec3(1.0, 0.2, 0.2) * atten * Shade(n, v, l, scene.material);\n            rd = normalize(reflect(rd, n));\n            ro = p + rd * 0.1;\n            atten *= 0.2;\n        } else if (scene.type == 2) {\n            vec3 p = ro + rd * scene.dist;\n            vec3 n = GetNormal(p);\n            vec3 v = normalize(-rd);\n            DirLight l = DirLight(uLightDir, uLightColor);\n            color += atten * Shade(n, v, l, scene.material);\n            if (i == 0) {\n               scene = RayMarch(p + n * 0.03, n);\n                if (scene.type != 0) {\n                    color = mix(color, color * clamp(scene.dist * 10.0 / (uScale * uScale), 0.0, 1.0), 0.7);\n                }\n            }\n            break;\n        } else {\n            break;\n        }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ar = vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy/iResolution.xy-.5) * ar;\n    vec3 ro = vec3(0,-0.2,-5) * uScale;\n    vec3 rd = normalize(vec3(uv, 1.2) * uScale);\n    vec3 color = vec3(0.0);\n    float mx = (iMouse.x/iResolution.x * 2.0 - 1.0) * 3.14;\n    \n    ro.xz *= Rotate(mx);\n    rd.xz *= Rotate(mx);\n\n    float offset = 0.005;\n\n    color = Trace(ro, rd);\n\n    color = mix(color, color * 0.35, max(0.0, length(2. * uv/ar)));\n\n    // tone mapping\n    color = color / (color + 1.0);\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}