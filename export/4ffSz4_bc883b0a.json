{"ver":"0.1","info":{"id":"4ffSz4","date":"1705003710","viewed":99,"name":"Egg Carton Halftone in CMYK","username":"jcarrano","description":"Halftone using the \"egg carton\" formula in subtractive color space with black. Egg Carton on the right. Circles on the left.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["screen","cmyk","dithering"],"hasliked":0,"parentid":"lcfXRH","parentname":"Simple Halftone Experiment"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// If 1, do not use a downsampled (and thus unique) radius per circle\n#define CHEAT_RADIUS 1\n\n#define NON_UNIFORM_COLOR 0\n\n#define M_PI 3.1415926535897932384626433832795f\n\nconst int diameter = 8;\nconst int downsample = diameter;\nconst float aa_width = 0.5/float(diameter);\n\n\n// This is not the only possibility. \n// See https://en.m.wikipedia.org/wiki/File:CMYK_screen_angles.svg\n//const float yellowAngle = 0.0;\nconst float cyanAngle = 15.0;\nconst float magentaAngle = 75.0;\nconst float blackAngle = 45.0;\n\nmat2x2 rot(float angleDeg)\n{\n    float a = radians(angleDeg);\n    return mat2x2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nmat2x2 cyanR, magentaR, blackR;\n\nvoid initRotations()\n{\n    cyanR = rot(cyanAngle);\n    magentaR = rot(magentaAngle);\n    blackR = rot(blackAngle);\n}\n\nfloat improveImage(float grayLevel)\n{\n    float contrastFixed = (grayLevel - 0.1f)*1.2f;\n    return clamp(contrastFixed, 0.0, 1.0);\n}\n\nfloat eggCartonBalls(float grayLevel, vec2 coord)\n{\n    const float b = (sqrt(2.0)*M_PI)/float(diameter);\n    float eggCarton0 = (sin(coord.x*b) + sin(coord.y*b))*0.45f;\n    float eggCarton = sqrt(abs(eggCarton0)) + aa_width*2.0;\n    \n    return smoothstep(1.0-grayLevel, 1.1-grayLevel, eggCarton);\n}\n\nfloat balls(float grayLevel, vec2 coord)\n{\n    // Adjust so that it matches the egg carton screen\n    coord = blackR*(coord) + vec2(diameter/2, 0);\n    \n    vec2 coordblock = fract(coord/float(diameter)) - 0.5;\n    float radius = length(coordblock) + 0.7/float(diameter);\n    \n    float grayRadius = sqrt(grayLevel)*0.75;\n    float edge_low = max(0.0, grayRadius - aa_width);\n    float edge_hi = grayRadius + aa_width;\n    return 1.0 - smoothstep(edge_low, edge_hi, radius);\n}\n\nvec4 rgb2cmyk(vec4 rgb)\n{\n    vec3 cmy = 1.0 - rgb.rgb;\n    float k = min(min(cmy.r, cmy.g), cmy.b);\n    \n    return vec4(cmy-k, k);\n}\n\nvec4 cmyk2rgb(vec4 cmyk)\n{\n    return vec4(1.0 - vec3(cmyk.a) - cmyk.rgb, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRotations();\n    \n    vec4 color = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    vec4 colorCMYK = rgb2cmyk(color);\n    \n    vec4 screenCMYK;\n    if (fragCoord.x < iResolution.x*0.5) \n        screenCMYK = vec4(balls(colorCMYK.r, cyanR*fragCoord.xy),\n                       balls(colorCMYK.g, magentaR*fragCoord.xy),\n                       balls(colorCMYK.b, fragCoord.xy),\n                       balls(colorCMYK.a, blackR*fragCoord.xy));\n    else\n        screenCMYK = vec4(eggCartonBalls(colorCMYK.r, cyanR*fragCoord.xy),\n                       eggCartonBalls(colorCMYK.g, magentaR*fragCoord.xy),\n                       eggCartonBalls(colorCMYK.b, fragCoord.xy),\n                       eggCartonBalls(colorCMYK.a, blackR*fragCoord.xy));\n\n\n    fragColor = cmyk2rgb(screenCMYK)*color.a;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Remove the green screen and transform it to an alpha channel (premultiplied).\n\nvec4 removeGreenScreen(vec4 col)\n{\n    float greenness = col.g - max(col.r, col.b);\n    float mask = (1.0 - smoothstep(0.0, 0.1, greenness));\n    \n    return vec4(col.rgb * mask, mask*col.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = removeGreenScreen(color);\n}","name":"Buffer A","description":"","type":"buffer"}]}