{"ver":"0.1","info":{"id":"wlGGRV","date":"1579405014","viewed":264,"name":"Blocked with chains","username":"gaz","description":"3d","likes":13,"published":1,"flags":8,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BUMP 0\n\n#define PI acos(-1.0)\n#define TAU PI*2.0\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define opRepLim(p,s,l) p-s*clamp(round(p/s),-l,l);\n#define hash(n)fract(sin(n+1234.5)*55555.0)\n\nvec3 randVec(float n)\n{\n\tvec3 v=vec3(1,0,0);\n    v.xy*=rot(asin(hash(n)*2.-1.));\n    n+=123.0;\n    v.xz*=rot((hash(n)*2.-1.)*PI);\n\treturn v;\n}\n\nfloat noise(vec3 p)\n{\n    vec3 r=vec3(1,99,999);\n    vec4 s=dot(floor(p),r)+vec4(0,r.y,r.z,r.y+r.z);\n    p=smoothstep(0.,1.,fract(p));\n    s=mix(hash(s),hash(s+1.),p.x);\n    s.xy=mix(s.xz,s.yw,p.y);\n    return mix(s.x,s.y,p.z);\n}\n\nfloat fbm(vec3 p)\n{\n   \tfloat n = 0.0;\n    float amp = 0.8;\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tn += noise(p)*amp;\n\t\tamp *= 0.5;\n\t}\n\treturn min(n, 1.0);\n}\n\nfloat deRing(vec3 p)\n{\n    p.x-=clamp(p.x,-1.0,1.0);\n    return length(vec2(length(p.xy)-1.0,p.z))-0.5;\n}\n\nfloat deChain(vec3 p)\n{\n    float de = 1e9;\n    vec3 q;\n    q=p;\n    q.x=opRepLim(q.x,6.0,8.0);\n    de=min(de, deRing(q));\n    q=p;\n    q.x-=3.0;\n    q.x=opRepLim(q.x,6.0,8.0);\n    de=min(de, deRing(q.xzy));\n#if BUMP\n    de+=fbm(p*5.0)*0.01;\n#endif\n    return de;\n}\n\nfloat map(vec3 p)\n{\n    float de = 1e9;\n    for(float i=0.0; i<10.0; i++)\n    {\n        vec3 q = p;\n        q+=randVec(i*3.22)*10.0-5.0;\n        vec3 v = randVec(i+7753.2223);\n        vec3 w=normalize(v);\n        vec3 u=normalize(cross(w,v.yzx));\n        q *= mat3(u,cross(u,w),w);\n        de=min(de, deChain(q));\n    }    \n    return de;\n}\n\nvec3 calcNormal(vec3 pos){\n  vec2 e = vec2(1,-1) * 0.002;\n  return normalize(\n    e.xyy*map(pos+e.xyy)+e.yyx*map(pos+e.yyx)+ \n    e.yxy*map(pos+e.yxy)+e.xxx*map(pos+e.xxx)\n  );\n}\n\n#define quantize(t, a)floor(t*a)/a\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    float s=uv.y;\n    float g=quantize(fract(uv.y+iTime*0.5),30.0);\n    uv.x += 0.1*sin(iTime*8.0+g*10.0)*\n        step(hash(floor(iTime*2.0))*0.4+0.6,hash(g))*\n        step(0.95,sin(iTime*0.5+1.5*sin(iTime*2.0)));\n    vec3 ro=vec3(0,5,-10);\n    ro= vec3(cos(iTime*0.5+0.5*cos(iTime*.3))*8.0-6.,sin(iTime*0.8+0.5*sin(iTime*0.3))+4.0,sin(iTime*0.3+1.2*sin(iTime*0.3))*10.);\n    ro*=3.5;\n    vec3 ta=vec3(3);\n    ta.xz*=rot(iTime);\n    ta.xy*=rot(iTime*0.3);\n    vec3 w = normalize(ta-ro),u=normalize(cross(w,vec3(0,1,0))),v=cross(w,u);\n    vec3 rd=mat3(u,v,w)*normalize(vec3(uv,2.0));\n    vec3 col=vec3(0.12,0.1,0.03)+fbm(vec3(uv,iTime*0.5)*0.8)*0.3;\n    float t=1.0,d;\n    for(int i=0;i<96;i++)\n    {\n        t+=d=map(ro+rd*t);\n        if (d<0.001) break;\n    }\n    if(d<0.001)\n    {\n        vec3 p=ro+rd*t;\n        vec3 nor = calcNormal(p);\n        vec3 li = normalize(vec3(1));\n        vec3 bg=col;\n        col= vec3(1,0.95,0.85);\n        col*=exp2(-2.*pow(max(0.0, 1.0-map(p+nor*0.3)/0.3),2.0));\n        col*=max(0.,dot(nor,li));\n        col*=max(0.0,0.5+nor.y*0.5);\n        col+=pow(max(0.0,dot(reflect(normalize(p-ro),nor),li)),20.0);\n        col = mix(bg, col, exp(-t*t*0.0003));\n    }\n    col *= sin(s * 250.0 - iTime * 5.0) * 0.2 + 0.9;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI acos(-1.0)\n#define PIH (atan(1.0)*2.0)\n#define TAU (atan(1.0)*8.0)\n \n\n// OSC\nfloat osc_sin(float x){return sin(x*TAU);}\nfloat osc_saw(float x){return 1.0-fract(x)*2.0;}\nfloat osc_sqr(float x){return sign(0.5-fract(x));}\nfloat osc_tri(float x){return asin(sin(x*TAU))/PIH;}\nfloat osc_noise(float x){return fract(sin(x*45678.0)*1234.5)*2.0-1.0;}\n// ENVELOPE\nfloat adsr(float t, float a, float d, float s, float r, float gt)\n{  \n    return max(0.0,\n        min(1.0, t/max(1e-4, a)) \n        - min((1.0 - s) ,max(0.0, t - a)*(1.0 - s)/max(1e-4, d))\n        - max(0.0, t - gt)*s/max(1e-4, r));\n}\n\nfloat note2freq(int n)\n{\n    return 440.0*exp2((float(n)-69.0)/12.0);\n}\n\nfloat distortion(float gain, float d)\n{\n    return clamp(gain * d, -1.0, 1.0);\n}\n\n// scale  \nint major_scale(int n)\n{\n    n--;\n\treturn n/7*12+int[](0,2,4,5,7,9,11)[n%7];\n}\n\nint minor_scale(int n)\n{\n    n--;\n\treturn n/7*12+int[](0,2,3,5,7,8,10)[n%7];\n}\n\nint natural_minor_scale(int n)\n{\n    n--;\n\treturn n/7*12+int[](0,2,3,5,7,8,10)[n%7];\n}\n\nint harmonic_minor_scale(int n)\n{\n    n--;\n\treturn n/7*12+int[](0,2,3,5,7,8,11)[n%7];\n}\n\nint melodic_minor_scale(int n)\n{\n    n--;\n\treturn n/7*12+int[](0,2,3,5,7,9,11)[n%7];\n}\n\n#define SCALE(n) minor_scale(n)\n\n#define _ -100\n\n// CHORD\n/* code_type\n0: none\n1: dim\n2: sus2\n3: M <-> m //change\n4: sus4\n5: aug\n6: 6\n7: 7\n8: M7\n9: add9 \n*/\n\nint CHORD(int degree, int code_type, int inv)\n{\n    int root = SCALE(degree);\n    int[4] chord;\n    chord[0] = root;\n    chord[1] = SCALE(degree+2);\n    chord[2] = SCALE(degree+4);\n    chord[3] = 63;\n  \n    switch(code_type)\n    {\n        case 1:\n    \t\tchord[0] = root+1;\n   \t\t\tchord[1] = root+4;\n   \t\t\tchord[2] = root+7;\n   \t\t\tchord[3] = root+10;\n    \t\tbreak;\n    \tcase 2:\n   \t\t\tchord[1] = root+2;\n    \t\tbreak;\n    \tcase 3:\n   \t\t\tchord[1] = 7-chord[1]+root*2;\n    \t\tbreak;\n    \tcase 4:\n   \t\t\tchord[1] = root+5;\n    \t\tbreak;\n \t\tcase 5:\n    \t\tchord[1] = root+4;\n    \t\tchord[2] = root+8;\n    \t\tbreak;\n\t\tcase 6:\n    \t\tchord[3] = root+9;\n    \t\tbreak;\n\t\tcase 7:\n    \t\tchord[3] = root+10;\n    \t\tbreak;\n\t\tcase 8:\n    \t\tchord[3] = root+11;\n    \t\tbreak;\n    \tcase 9:\n   \t\t\tchord[3] = chord[2];\n   \t\t\tchord[2] = chord[1];\n            chord[1] = root+2;\n    \t\tbreak;\n    }\n    \n    int ret=0;\n    if(chord[3]==63)\n    {\n        for(int i=0;i<3;i++)\n        {\n           ret += (12+int[](chord[1]-12, chord[2]-12, chord[0], chord[1], chord[2])[i+2-inv])<<(6*i);\n        }\n        ret+=63<<18;\n    } else {\n        for(int i=0;i<4;i++)\n        {\n            ret += (12+int[](chord[1]-12, chord[2]-12,chord[3]-12, chord[0], chord[1], chord[2], chord[3])[i+3-inv])<<(6*i);\n        }\n    }\n    return ret;\n}\n\nfloat kick(float t){\n    return sin(pow(1.0-min(1.0,t*3.5),15.)*48.0+1.3)*exp(-t*3.0);\n}\n\nfloat snare(float t)\n{\n    return 0.5*osc_sqr(3063.0*t*sin(t*8000.0))*adsr(t,0.01,0.08,0.0,0.0,0.0);\n}\n\nfloat hihat(float t)\n{\n    return osc_noise(t)*exp(-t*50.0);\n}\n\nfloat sound01(float f, float t)\n{\n\treturn 0.4*distortion(osc_saw(f*t), 3.5)*exp(-t*2.5)+\n           0.3*distortion(osc_saw(f*t*1.03), 1.5)*exp(-t*5.0);\n}\n\nfloat sound02(float f, float t)\n{\n\treturn 0.7*distortion(osc_tri(f*t), 1.5);//*adsr(t,0.01,0.1,0.5,0.1,0.2);\n}\n\nfloat base(float f, float t)\n{\n\tf *= t;\n  \treturn clamp((\n        5.0*osc_sin(f)\n        + 2.0*osc_sin(f*2.0)\n        + osc_sin(f*3.0)\n    \t)/4.0,-1.0,1.0)*exp(-5.0*t);\n}\n\n// SEQENCE MACRO\n#define TRACK {float T,T1,T2, tmp=time, V=0.0; int N,N1,N2; \n#define REST(a) tmp -= a;\n#define LOOP(a) if(tmp>0.0){tmp = mod(tmp, a);\n#define FOR(c) if(tmp>0.0)for(int i=0;i<c;i++){\n#define END }\n#define SEQ(a,c,s) \\\n\tif(tmp>0.0){\\\n    \tT = mod(tmp,s);\\\n    \tfor(int i= int(tmp/(s))%c;i>=0;i--)\\\n    \t{\\\n        \tif(a[i]>_){N=a[i];break;}\\\n        \tT+=s;\\\n    \t}\\\n    \ttmp-=float(c)*s;\\\n\t}\n#define SUB(a,c,s) \\\n\tif(tmp>0.0){\\\n    \tT1 = mod(tmp,s);\\\n    \tfor(int i= int(tmp/(s))%c;i>=0;i--)\\\n    \t{\\\n        \tif(a[i]>_){N1=a[i];break;}\\\n        \tT1+=s;\\\n    \t}\\\n\t}\n#define VEL(a,c,s) \\\n\tif(tmp>0.0)if(a[int(tmp/(s))%c]==1)V=1.0;\n \nvec2 mainSound( in int samp, float time )\n{ \n\tint key = 55; // G2\n    \n    float bpm = 106.0;\n    float tick = 15.0/bpm;\n    float bar = 16.0*tick;\n    \n    vec2 gain=vec2(0);\n    \n    TRACK\n    \tLOOP(bar)\n       \t\tSEQ(int[]( 1,_,_,_, 1,_,1,_, 1,_,_,_, 1,_,1,_ ),16,tick)\n       \tEND\n        gain+= 0.4*kick(T);\n    END\n    \n\tTRACK\n        LOOP(bar*4.0)\n            FOR(3)\n       \t\t    SEQ(int[]( _,_,_,_, 1,_,_,_, _,_,_,_, 1,_,_,_ ),16,tick)\n       \t\tEND\n       \t\tSEQ(int[]( _,_,_,_, 1,_,_,_, _,_,1,_, 1,_,1,_ ),16,tick)\n        END\n        gain+=0.5*snare(T);\n    END\n    \n    TRACK\n        LOOP(bar)\n        \tVEL(int[]( _,_,_,_, 1,1,_,_, _,_,_,_, 1,1,_,_ ),16,tick)\n        \tSEQ(int[]( 1,_,1,_, 1,_,1,_, 1,_,1,_, 1,_,1,_ ),16,tick)\n        END\n        gain+= 0.3*(0.7+0.3*V) * hihat(T);\n    END        \n        \n\tTRACK\n\t    REST(bar)\n        LOOP(bar*2.0)\n        \tSEQ(int[]( 5,_,4,_,5,_,_,_,5,_,6,_,5,_,_,_ ),16,tick)\n    \t\tSEQ(int[]( 5,_,4,_,5,_,_,_,9,_,8,_,5,_,_,_ ),16,tick)\n        END\n        //gain+= 0.5*sound01(note2freq(key+SCALE(N)),T);\n    END\n    \n    #define PITCH(a) (N>>(a*6)&31)-12\n    #define N_CNT 4-(N>>18&63)/63\n    TRACK\n\t    REST(bar)\n        LOOP(bar*4.0)\n         \tSUB(int[]( 1,_,_,1,_,_,1,_),8,tick*2.0)\n            SEQ(int[](CHORD(4,0,0),CHORD(5,7,1),CHORD(3,0,0),CHORD(6,0,1)),4,bar)\n        END\n      \tfor(int i=0;i<N_CNT;i++)\n    \t{\n        \tgain += 0.9*sound02(note2freq(key-12+PITCH(i)), T1)/float(N_CNT);\n    \t}\n    END\n    \n\tTRACK\n\t    REST(bar)\n        LOOP(bar*4.0)\n         \tSUB(int[](0,1),2,bar/2.0)\n        \tSEQ(int[](4,5,3,6),4,bar)\n        END\n      \tgain += 0.5*base(note2freq(key-24+SCALE(N+N1*2)), T1);\n    END\n        \n    return clamp(0.7*gain,vec2(-1),vec2(1));\n}\n","name":"Sound","description":"","type":"sound"}]}