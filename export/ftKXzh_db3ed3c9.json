{"ver":"0.1","info":{"id":"ftKXzh","date":"1640384331","viewed":149,"name":"Book of Life","username":"pticawr","description":"Game of Life simulation with various spaceships and collisions in book form","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["simulation","automata","life","gameoflife","page","book","turning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat time()\n{\n    float mt = mod(iTime, 12.0);\n    return mt < 8.0 ? 0.0 : (mt - 8.0) / 4.0;\n}\n\nint pagesFlipped()\n{\n    return mod(iTime, 24.0) >= 12.0 ? 1 : 0;\n}\n\nfloat radius()\n{\n    return 0.982 - 2.0 * pow(time() - 0.3, 2.0);\n}\n\nvec2 circleBase()\n{\n    return vec2(4.0 - 4.0 * time(), 0.23);\n}\n\nvec2 circleCenter()\n{\n    return circleBase() + vec2(0.0, radius() - 0.002);\n}\n\nfloat arcAngle()\n{\n    return 2.0 * (PI - atan((8.0 - 4.0 * time()) / radius()));\n}\n\nfloat partArcAngle()\n{\n    float a = arcAngle();\n    float pa = 4.0 * time() / radius();\n    return pa < a ? pa : a;\n}\n\nvec2 lineEnd()\n{\n    return vec2(-4.0, 0.232);\n}\n\nvec2 lineStart()\n{\n    vec2 cc = circleCenter();\n    return cc + reflect(cc - circleBase() + vec2(0.0, 0.002), normalize(lineEnd() - cc));\n}\n\nfloat line2D(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat lineSDF(vec3 p)\n{\n    float pa = partArcAngle();\n    if (pa < arcAngle()) {\n        return MAX_DIST;\n    }\n    float len = 4.0 * time() - pa * radius();\n    vec2 l1 = lineStart();\n    vec2 ld = normalize(lineEnd() - l1);\n    float d2d = line2D(p.xy, l1, l1 + len * ld) - 0.002;\n    \n    return max(d2d, abs(p.z)-2.0);\n}\n\nfloat arc2D( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    if (scb.y*p.x>scb.x*p.y)\n    {\n        return sqrt((p.x - ra*scb.x)*(p.x - ra*scb.x) + (p.y - ra*scb.y)*(p.y - ra*scb.y)) - rb;\n    }\n    else\n    {\n        return sqrt(dot(p,p) + ra*ra - 2.0*ra*length(p)) - rb;\n    }\n    //float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) - rb/280.0 : length(p);\n    //return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat arcSDF(vec3 p)\n{\n    float t = time();\n    float r = radius();\n    float hpa = partArcAngle() / 2.0;\n    if (hpa == 0.0) {\n        return MAX_DIST;\n    }\n    vec2 cp = circleBase() + vec2(0.0, r - 0.002);\n    float ma = 1.5 * PI - hpa;\n    float d2d = arc2D(p.xy - cp,\n        vec2(sin(ma), cos(ma)),\n        vec2(sin(hpa), cos(hpa)),\n        r, 0.002);\n    \n    return max(d2d, abs(p.z)-2.01);\n}\n\nfloat roundedCross2D( in vec2 p, in float h )\n{\n    float k = 0.5*(h+1.0/h);\n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot(p-vec2(1,k),p-vec2(1,k)))  :\n           sqrt(min(dot(p-vec2(0,h),p-vec2(0,h)),\n                    dot(p-vec2(1,0),p-vec2(1,0))));\n}\n\nfloat roundedCrossSDF(vec3 p)\n{\n    float d2d = roundedCross2D(p.xy - vec2(0.0, 0.23), 0.05);\n    \n    return max(d2d, abs(p.z)-2.1);\n}\n\nfloat trapezoid2D(vec2 p, float r1, float r2, float he)\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n}\n\nfloat trapezoidSDF(vec3 p)\n{\n    float d2d = trapezoid2D(p.xy - vec2(0.0, 0.13), 4.2, 4.0, 0.1);\n    \n    return max(d2d, abs(p.z)-2.0);\n}\n\nfloat coverSDF(vec3 p)\n{\n    vec3 d = abs(p) - vec3(4.23, 0.03, 2.03);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat sceneSDF(vec3 p) {\n    return min(min(min(\n        coverSDF(p),\n        max(trapezoidSDF(p),-roundedCrossSDF(p))),\n        arcSDF(p)),\n        lineSDF(p));\n}\n\n// ##################################################\n\nvec3 pageCoord(vec3 p)\n{\n    float t = time();\n    \n    if (p.y > 0.231)\n    {\n        if (arcSDF(p) < EPSILON)\n        {\n            vec2 rl = p.xy - circleCenter();\n            float ad = (PI / 2.0 + atan(rl.y, rl.x)) * radius();\n            if (length(rl) < radius())\n            {\n                return vec3(circleBase().x + ad, p.z, 0.0);\n            }\n            else\n            {\n                return vec3(-(circleBase().x + ad), p.z, 1.0);\n            }\n        }\n        else //if (lineSDF(p) < EPSILON)\n        {\n            float ld = distance(lineStart(), p.xy);\n            float ad = partArcAngle() * radius();\n            return vec3(-(circleBase().x + ad + ld), p.z, 1.0);\n        }\n    }\n    else\n    {\n        return vec3(p.x, p.z, p.x > 4.05 - 4.0 * t ? 1.0 : 0.0);\n    }\n}\n\nvec3 colFromPoint(vec3 p)\n{\n    if (p.y < 0.031)\n    {\n        return vec3(1.0, 0.4, 0.4);\n    }\n    else if (p.y < 0.18)\n    {\n        return vec3(0.7, 0.7, 0.7);\n    }\n    else\n    {\n        vec3 pc = pageCoord(p);\n        \n        if (abs(pc.x) >= 3.9 || abs(pc.y) >= 1.9)\n        {\n            vec2 rd = abs(pc.xy) - vec2(3.95, 1.95);\n            float rdl = pow(20.0 * min(abs(length(max(rd,0.0)) + min(max(rd.x,rd.y),0.0)), 0.05), 0.5);\n            return vec3(rdl, rdl, 1.0);\n        }\n        else\n        {\n            int sbuf = (int(pc.z) ^ pagesFlipped());\n            vec4 tc = texelFetch(iChannel0, ivec2(78.0 * float(sbuf) + (pc.x + 3.9) * 10.0, (pc.y + 1.9) * 10.0), 0);\n            return vec3(0.4) - vec3(0.4, -0.6, 0.4) * (max(tc.xxx, 0.4 * tc.yyy));\n        }\n    }\n}\n\nvec3 backColor(vec2 fc)\n{\n    int ci = (int(pow(fc.x, 2.0)) ^ int(pow(fc.y, 2.0))) % 1003;\n    float c = (ci == 97 ? 1.0 : (ci == 73 ? 0.6 : 0.0)) * (sin(iTime + float(int(fc.x) ^ int(fc.y))) / 2.0 + 0.5);\n    return vec3(c);\n}\n\n// ##################################################\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.7 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime/8.0),\n                          3.0,\n                          -1.5 + 3.0 * cos(iTime/8.0));\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n// ##################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(7.5 * sin(0.5 * sin(iTime/8.0)), 12.0 - 2.0 * abs(sin(iTime/8.0)), 7.5 * cos(0.5 * sin(iTime/8.0)));\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.23, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(backColor(fragCoord), 1.0);\n    }\n    else\n    {\n        vec3 p = eye + dist * worldDir;\n\n        vec3 K_a = vec3(0.2, 0.2, 0.3);\n        vec3 K_d = colFromPoint(p);\n        vec3 K_s = vec3(1.0, 1.0, 1.0);\n        float shininess = 10.0;\n\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n\n        fragColor = vec4(color, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int shipc = 17;\n\nconst ivec3[] shipsz = ivec3[](\nivec3(3,3,0),      //Glider\nivec3(5,4,9),      //Lightweight spaceship\nivec3(6,5,29),     //Middleweight spaceship\nivec3(7,5,59),     //Heavyweight spaceship\nivec3(9,9,94),     //Loafer\nivec3(12,8,175),   //Copperhead\nivec3(13,12,271),  //Canada goose\nivec3(12,10,427),  //Turtle\nivec3(10,15,547),  //Dart\nivec3(7,16,697),   //Edge-repair spaceship 1\nivec3(8,16,809),   //B29\nivec3(11,17,937),  //Brain\nivec3(10,9,1124),  //Coe ship\nivec3(11,16,1214), //Weekender\nivec3(9,22,1390),  //Wasp\nivec3(12,24,1588), //Swan\nivec3(21,11,1876)  //Non-monotonic spaceship 1\n);\n\nconst vec2[] shipsp = vec2[](\nvec2(0.25,0.25),\nvec2(0.5,0.0),\nvec2(0.5,0.0),\nvec2(0.5,0.0),\nvec2(1.0/7.0,0.0),\nvec2(0.1,0.0),\nvec2(0.25,0.25),\nvec2(1.0/3.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(0.25,0.25),\nvec2(1.0/3.0,0.0),\nvec2(0.5,0.0),\nvec2(2.0/7.0,0.0),\nvec2(1.0/3.0,0.0),\nvec2(0.25,0.25),\nvec2(0.25,0.0)\n);\n\nconst uint[] ships = uint[](\n0x47c83179u,0x11030be6u,0x210182ffu,0x4cc90501u,\n0x201c0101u,0x3000b01u,0x2313a0du,0xa0c31210u,\n0x20b000c0u,0x60611a5u,0x1a81180u,0x40002019u,\n0x8b813004u,0xf01db4u,0xc8708a48u,0x428428a4u,\n0x871b4d01u,0xc8050060u,0x40110049u,0xe5013e50u,\n0x49104006u,0x5008010u,0x50314188u,0x9010304u,\n0x38210183u,0x8206050u,0x5048404au,0x218b4800u,\n0x10600806u,0xc006c12u,0x71cf488eu,0xe4c217cu,\n0x5f0c2u,0x3908e3du,0x271f0480u,0x60fcc1d0u,\n0x4220200cu,0x781b018u,0x201b148u,0x20140480u,\n0x8c018030u,0x460900a0u,0x400a403u,0x6010c118u,\n0xac400e00u,0x80e14800u,0xae389080u,0x41801808u,\n0x1c040803u,0x1810008u,0x400c00u,0x80580900u,\n0x110220u,0x6008505u,0xb85a0400u,0x803800a0u,\n0x2800u,0x600e00a0u,0x3006016u,0x1d703u,\n0x10029e20u,0xc31709a0u,0x84005c2u,0x69e20c3cu,\n0x400a01d7u,0x58000u\n);\n\n\n\n\nuint shipBit(int n, int x, int y)\n{\n    int b = shipsz[n].z + x + y * shipsz[n].x;\n    return (ships[b / 32] >> (31 - (b % 32))) % 2u;\n}\n\nint Cell(int n, in ivec2 p)\n{\n    ivec2 r = ivec2(78, 38);\n    p = (p+r) % r;\n    vec4 c = texelFetch(iChannel0, p + (n%2 == 1 ? ivec2(78,0) : ivec2(0)), 0);\n    return ((n/2 == 0 ? c.x : c.y) > 0.5) ? 1 : 0;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n + iDate.w)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    float f = 0.0;\n    int e = 0;\n    \n    if (px.x < 2*78 && px.y < 38)\n    {\n        int b = px.x / 78;\n        if (iFrame % 3 == 0)\n        {\n            int k = Cell(b, px+ivec2(-1,-1)) + Cell(b, px+ivec2(0,-1)) + Cell(b, px+ivec2(1,-1))\n                  + Cell(b, px+ivec2(-1, 0))                           + Cell(b, px+ivec2(1, 0))\n                  + Cell(b, px+ivec2(-1, 1)) + Cell(b, px+ivec2(0, 1)) + Cell(b, px+ivec2(1, 1));\n\n            e = Cell(b, px);\n\n            f = ( ((k==2)&&(e==1)) || (k==3) ) ? 1.0 : 0.0;\n\n            if( iFrame == 0\n                || (b == 1 && mod(iTime, 24.0) < 2.0)\n                || (b == 0 && mod(iTime, 24.0) >= 12.0 && mod(iTime, 24.0) < 14.0))\n            {\n                if (iFrame != 0 && mod(iTime, 60.0) < 48.0)\n                {\n                    ivec2 gpx = px - ivec2(b==1?78:0,0);\n\n                    int si1 = int(floor((iDate.w + hash1(1.1)) * float(shipc))) % shipc;\n                    int si2 = int(floor((iDate.w + hash1(2.3)) * float(shipc))) % shipc;\n                    bool sr1 = int(floor((iDate.w + hash1(5.8)) * 2.0)) % 2 == 1;\n                    bool sr2 = int(floor((iDate.w + hash1(13.21)) * 2.0)) % 2 == 1;\n                    int ssm = (shipsz[si1].y / 2 + shipsz[si2].y / 2) / 2;\n                    int sy1 = int(floor((iDate.w + hash1(34.55)) * float(ssm * 2 + 1))) % (ssm * 2 + 1) - ssm;\n                    int sy2 = int(floor((iDate.w + hash1(89.144)) * float(ssm * 2 + 1))) % (ssm * 2 + 1) - ssm;\n\n                    float stps = floor(min(min(float(36 - shipsz[si1].x) / shipsp[si1].x,\n                        float(36 - shipsz[si2].x) / shipsp[si2].x), 140.0));\n\n                    ivec2 sp1 = ivec2(39 - shipsz[si1].x - int(shipsp[si1].x * stps),\n                        (38 + 19 + sy1 - shipsz[si1].y / 2 + (sr1?1:-1) * int(shipsp[si1].y * stps)) % 38);\n                    ivec2 sp2 = ivec2(38 + shipsz[si2].x + int(shipsp[si2].x * stps),\n                        (38 + 19 + sy2 - shipsz[si2].y / 2 + (sr2?1:-1) * int(shipsp[si2].y * stps)) % 38);\n\n                    if (gpx.x >= sp1.x && gpx.x < sp1.x + shipsz[si1].x\n                        && (sp1.y <= (sp1.y + shipsz[si1].y - 1) % 38 && (gpx.y >= sp1.y % 38 && gpx.y <= (sp1.y + shipsz[si1].y - 1) % 38)\n                        || (sp1.y > (sp1.y + shipsz[si1].y - 1) % 38 && (gpx.y >= sp1.y % 38 || gpx.y <= (sp1.y + shipsz[si1].y - 1) % 38))))\n                    {\n                        f = float(shipBit(si1, gpx.x - sp1.x, ((sr1 ? shipsz[si1].y + 37 - (gpx.y - sp1.y) : gpx.y - sp1.y + 38) % 38)));\n                    }\n                    else if (gpx.x <= sp2.x && gpx.x > sp2.x - shipsz[si2].x\n                        && (sp2.y <= (sp2.y + shipsz[si2].y - 1) % 38 && (gpx.y >= sp2.y % 38 && gpx.y <= (sp2.y + shipsz[si2].y - 1) % 38)\n                        || (sp2.y > (sp2.y + shipsz[si2].y - 1) % 38 && (gpx.y >= sp2.y % 38 || gpx.y <= (sp2.y + shipsz[si2].y - 1) % 38))))\n                    {\n                        f = float(shipBit(si2, sp2.x - gpx.x, ((sr2 ? shipsz[si2].y + 37 - (gpx.y - sp2.y) : gpx.y - sp2.y + 38) % 38)));\n                    }\n                    else\n                    {\n                        f = 0.0;\n                    }\n                }\n                else\n                {\n                    e = 0;\n                    f = step(0.7, hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)));\n                }\n            }\n            else if( (b == 1 && mod(iTime, 24.0) < 11.0)\n                || (b == 0 && mod(iTime, 24.0) >= 12.0 && mod(iTime, 24.0) < 23.0))\n            {\n                e = 0;\n                f = float(Cell(b, px));\n            }\n        }\n        else\n        {\n            e = Cell(b + 2, px);\n            f = float(Cell(b, px));\n        }\n    }\n    \n\tfragColor = vec4(f, float(e), 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}