{"ver":"0.1","info":{"id":"lftBDH","date":"1733064929","viewed":5827,"name":"うろうろシェーダー 241201","username":"TheBoiledHotWater","description":"うろうろ、ちょっと調整","likes":54,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// original → https://vrchat.com/home/launch?worldId=wrld_6325c346-2ea9-4bc5-8d65-59cd7e700d06\n// it is not my idea.\n\nconst float BPM = 151.0;\n\nvec3 pcg3df(vec3 v)\n{\n  uvec3 r = floatBitsToUint(v);\n  r = r * 1664525u + 1013904223u;\n  \n  r.x += r.y*r.z;\n  r.y += r.z*r.x;\n  r.z += r.x*r.y;\n  \n  r ^= r >> 16u;\n  \n  r.x += r.y*r.z;\n  r.y += r.z*r.x;\n  r.z += r.x*r.y;\n  \n  return vec3(r) / float(0xffffffffu);\n}\n\nmat2 rot(float r)\n{\n   return mat2(cos(r), -sin(r), sin(r), cos(r));\n}\n\nvec2 pmod(vec2 p, float r)\n{\n  float a = atan(p.x, p.y) + acos(-1.0) / r;\n  float n = acos(-1.0) * 2.0 / r;\n  a = floor(a/n)*n;\n  return p * rot(-a);\n}\n\nfloat sdBox(vec3 p, vec3 d)\n{\n  vec3 q = abs(p) - d;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRoom(vec3 p)\n{\n  float d = sdBox(p, vec3(1.7, 2.0, 0.5));\n  float d2 = sdBox(p, vec3(1.6, 1.9, 0.51));\n  \n  return max(d, -d2);\n}\n\nfloat sdTable(vec3 p)\n{\n  float d = sdBox(p + vec3(0.0, 1.2, 0.0), vec3(0.25, 0.02, 0.5));\n  float d2 = sdBox(p + vec3(0.0, 1.6, 0.0), vec3(0.025, 0.4, 0.025));\n  \n  return min(d, d2);\n}\n\nfloat sdPlate(vec3 p)\n{\n  p.y += 1.1;\n  p.x += 0.15;\n  float d = max(length(p) - 0.1, -(length(p + vec3(0.0, -0.125, 0.0)) - 0.2));\n\n  p.x -= 0.3;\n  \n  float d2 = max(length(p) - 0.1, -(length(p + vec3(0.0, -0.125, 0.0)) - 0.2));\n\n  \n  return min(d, d2);\n}\n\nfloat sdChair(vec3 p)\n{\n  float d = sdBox(p, vec3(0.2, 0.025, 0.2));\n  float d2 = sdBox(p + vec3(0.15, 0.0, 0.15), vec3(0.02, 0.5, 0.02));\n  float d3 = sdBox(p + vec3(-0.15, 0.0, 0.15), vec3(0.02, 0.5, 0.02));\n  float d4 = sdBox(p + vec3(-0.15, 0.2, -0.15), vec3(0.02, 0.2, 0.02));\n  float d5 = sdBox(p + vec3(0.15, 0.2, -0.15), vec3(0.02, 0.2, 0.02));\n  float d6 = sdBox(p + vec3(0.0, -0.5, 0.15), vec3(0.2, 0.05, 0.05));\n  \n  return min(min(min(min(min(d, d2), d3), d4), d5), d6);\n}\n\nfloat sdChairs(vec3 p)\n{\n  p.xz *= rot(acos(-1.0)/2.0);\n  float d = sdChair(p + vec3(0.0, 1.5, 0.5));\n  \n  p.xz *= rot(acos(-1.0));\n  float d2 = sdChair(p + vec3(0.0, 1.5, 0.5));\n  \n  return min(d, d2);\n}\n\nstruct Result\n{\n  float d;\n  vec3 ld;\n  float la;\n  int id;\n};\n\nResult map(vec3 p)\n{\n  float i = floor(p.z) - 0.5;\n  vec3 rnd = pcg3df(vec3(i, floor(iTime*BPM/60.0), 0.0));\n  rnd.x -= 0.5;\n  rnd.y -= 0.5;\n  rnd.y *= 0.5;\n  \n  p.z = mod(p.z, 1.0) - 0.5;\n  \n  float room = sdRoom(p);\n  float table = sdTable(p);\n  float plate = sdPlate(p);\n  float chairs = sdChairs(p);\n  \n  Result result;\n  result.d = min(min(min(room, table), plate), chairs) * 0.5;\n  result.ld = normalize(vec3(rnd.xy - vec2(sin(2.0 * iTime + rnd.z * acos(-1.0)) * 0.5, 0.0), 0.0) - p);\n  result.la = 1.0 / pow(length(vec3(rnd.xy - vec2(sin(2.0 * iTime + rnd.z * acos(-1.0)) * 0.5, 0.0), 0.0) - p), 15.0);\n  result.id = 0;\n  \n  float light = length(p + vec3(-rnd.xy + vec2(sin(2.0 * iTime + rnd.z * acos(-1.0)) * 0.5, 0.0), 0.0)) - 0.1;\n  \n  if (light < result.d)\n  {\n    result.d = light * 0.45;\n    result.id = 1;\n  }\n  \n  return result;\n}\n\nvec3 getNormal(vec3 p)\n{\n  return normalize(vec3(\n    map(p + vec3(0.0001, 0.0, 0.0)).d - map(p + vec3(-0.0001, 0.0, 0.0)).d,\n    map(p + vec3(0.0, 0.0001, 0.0)).d - map(p + vec3(0.0, -0.0001, 0.0)).d,\n    map(p + vec3(0.0, 0.0, 0.0001)).d - map(p + vec3(0.0, 0.0, -0.0001)).d\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n  float time = iTime*BPM/60.0;\n  \n  p.x = mod(floor(time), 8.0) < 1.0 ? abs(p.x) : p.x;\n  p = 3.0 < mod(floor(time), 8.0) && mod(floor(time), 8.0) < 5.0 ? pmod(p, 4.0) : p;\n  \n  vec3 ro = vec3(sin(time / 8.0) * 1.5, sin(time / 5.0) * 3.0 - 0.25, 1.0-time);\n  vec3 ta = vec3(sin(time / 8.0) * 1.5, sin(time / 5.0) * 3.0 - 0.25, -time);\n  vec3 cDir = normalize(ta - ro);\n  vec3 cUp = normalize(cross(vec3(1.0, 0.0, 0.0), cDir));\n  vec3 cSide = normalize(cross(cDir, cUp));\n\n  float fov = mod(floor(time), 4.0) < 1.0 ? 1.0 : 0.6;\n  vec3 rd = normalize(p.x * cSide + p.y * cUp + cDir * fov);\n\n  float t, d;\n  float e;\n  vec3 col = vec3(0.0);\n  \n  for (int i = 0; i < 256; i++)\n  {\n    vec3 rp = ro + rd * t;\n    \n    rp.x += sin(rp.z / 8.0) * 1.5;\n    rp.y += sin(rp.z / 5.0) * 3.0;\n    rp.xy *= rot(t * 0.15 * sin(time/3.0));\n    \n    Result result = map(rp);\n    d = result.d;\n    \n    if (abs(d) < 0.0001)\n    {\n      vec3 n = getNormal(rp);\n      col = vec3(clamp(pow(dot(n, result.ld), 20.0), 0.0, 1.0)) * result.la;\n      break;\n    }\n    \n    if (result.id == 1) e += 0.03/abs(d);\n    t += d;\n  }\n  \n  col *= exp(-t * 0.4);\n  \n  col = pow(col, vec3(0.4545));\n\n  col += e * 0.01;\n  \n  col = pow(col, mod(floor(time), 16.0) < 8.0 ? vec3(0.7, 0.8, 0.95) : vec3(0.9, 1.0, 0.75));\n  \n  float noise = pcg3df(vec3(p, iTime)).x;\n  col += vec3(noise) * 0.105;\n  \n  float v = 1.0 - clamp(pow(0.525 * length(p), 10.0), 0.0, 1.0);\n  \n  col *= v;\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}