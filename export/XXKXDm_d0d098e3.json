{"ver":"0.1","info":{"id":"XXKXDm","date":"1720043241","viewed":50,"name":"Perlin Noise Grad Sine","username":"L1x3N","description":"Another Eathbound inspired shader, combining the effect of the previous ones with the sine.\nFeel free to change the colors (with the length of COLORS_VALUES having to be the same than COLORS_POS's) and the other consts.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["perlin","gradient","endless","animated","sine","seamless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3[] COLORS_VALUES = vec3[](vec3(0.), vec3(1., 0., 0.), vec3(0.), vec3(0.));\nconst float[] COLORS_POS = float[](0., 20. / 100., 75. / 100., 1.);\n\nconst bool GRADIENT_BLEND_MODE = true;\nconst bool ASPECT_RATIO = true;\n\nconst float SCROLL_SPEED_X = 0.4;\nconst float SCROLL_SPEED_Y = 0.15;\nconst float PERLIN_SCALE = 3.5;\nconst float GRADIENT_SPEED = 0.25;\nconst float MULTIPLY_PERLIN = 1.25;\n\nconst float SINE_SPEED = 1.5;\nconst float SINE_STRENGTH = 8.;\nconst float SINE_MINIMUM = 2.;\n\nvec2 randomGradient(vec2 p) {\n\tp = p + 0.1f;\n\tfloat x = dot(p, vec2(123.4, 234.5));\n\tfloat Y = dot(p, vec2(432.1, 987.6));\n\tvec2 gradient = sin(vec2(x, Y)) * 26438.799f;\n\n\treturn sin(gradient + iTime * GRADIENT_SPEED);\n}\n\nfloat getPerlinNoise(vec2 uv) {\n\tvec2 gridUv = fract(uv * PERLIN_SCALE), gridId = floor(uv * PERLIN_SCALE);\n\n\tfloat scBg = dot(randomGradient(gridId), gridUv);\n\tfloat scBd = dot(randomGradient(gridId + vec2(1, 0)), gridUv - vec2(1, 0));\n\tfloat scHg = dot(randomGradient(gridId + vec2(0, 1)), gridUv - vec2(0, 1));\n\tfloat scHd = dot(randomGradient(gridId + vec2(1, 1)), gridUv - vec2(1, 1));\n\n\tgridUv = smoothstep(0., 1., gridUv);\n\treturn mix(mix(scBg, scBd, gridUv.x), mix(scHg, scHd, gridUv.x), gridUv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Setup UVs\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tuv = vec2(uv.x + iTime / 4. * SCROLL_SPEED_X, uv.y + iTime / 4. * SCROLL_SPEED_Y);\n\tif(ASPECT_RATIO)\n\t\tuv.x *= iResolution.x / iResolution.y;\n\n\tfloat perlin = getPerlinNoise(uv);\n\tperlin = fract(perlin * MULTIPLY_PERLIN);\n\n\tfloat sineNoise = fract(perlin * (((sin(iTime / 2. * SINE_SPEED) + 1.) / 2. * SINE_STRENGTH) + SINE_MINIMUM));\n\tsineNoise = smoothstep(0.45, 0.35, sineNoise);\n\n\tvec3 myColor;\n\n\tint colorPosIndex;\n\tfor(colorPosIndex = 0; colorPosIndex < (COLORS_POS.length()); colorPosIndex ++) {\n\t\tif(fract(perlin) < COLORS_POS[colorPosIndex])\n\t\t\tbreak;\n\t}\n\n\tif(GRADIENT_BLEND_MODE) {\n\t\tfloat colorUv = (fract(perlin) - COLORS_POS[colorPosIndex - 1]) / (COLORS_POS[colorPosIndex] - COLORS_POS[colorPosIndex - 1]);\n\t\tmyColor = mix(COLORS_VALUES[colorPosIndex - 1], COLORS_VALUES[colorPosIndex], colorUv);\n\t} else {\n\t\tmyColor = COLORS_VALUES[colorPosIndex];\n\t}\n\n\tmyColor *= sineNoise;\n\n\tfragColor = vec4(myColor, 1.);\n}","name":"Image","description":"","type":"image"}]}