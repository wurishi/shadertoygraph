{"ver":"0.1","info":{"id":"ssscRB","date":"1642340300","viewed":125,"name":"Mandelbrot smooth psychedelic","username":"Daniel3141","description":"A zoom into the Mandelbrot set.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","mandelbrot"],"hasliked":0,"parentid":"4df3Rn","parentname":"Mandelbrot - smooth"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is an enhanced and modified version of the smooth Mandelbrot version by \n// Inigo Quilez, @iquilezles and iquilezles.org https://www.shadertoy.com/view/4df3Rn\n\n\n#define AA 2              // 1..8  Anti Aliasing: increase this if you have a very fast GPU\n#define SMOOTH 1          // 0 or 1\n#define PSYCHODELIC 1     // 0 .. 3 (only works with SMOOTH == 1)\n#define ZOOM_TO_REGION 1  // 1 .. 3\n#define MIN_ZOOM 1.6\n#define MAX_ZOOM 0.00007  // deeper zoom is not possible because of 'float' limitations\n#define SPEED 1.0\n#define START_FADE_IN 1   // 0 or 1\n\n\nfloat mandelbrot( in vec2 c )\n{\n    #if 1\n    {\n        float c2 = dot(c, c);\n        // skip computation inside M1 - https://iquilezles.org/articles/mset1bulb\n        if( 256.0*c2*c2 - 96.0*c2 + 32.0*c.x - 3.0 < 0.0 ) return 0.0;\n        // skip computation inside M2 - https://iquilezles.org/articles/mset2bulb\n        if( 16.0*(c2+2.0*c.x+1.0) - 1.0 < 0.0 ) return 0.0;\n    }\n    #endif\n\n\n    const float B = 256.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<512; i++ ) {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z) > (B*B) ) break;\n        l += 1.0;\n    }\n\n    float maxIterations = 511.0;\n#if START_FADE_IN==1\n    if (iTime < 7.0 && iTime > 0.01) {\n       maxIterations = pow(iTime + 1.0, 2.0);\n    }\n#endif\n    if (l > maxIterations) return 0.0;\n    \n#if SMOOTH==1\n    float diff = log2(log2(dot(z,z))) - 4.0;\n    \n #if PSYCHODELIC>0\n    if (diff < 0.04) return 0.0;\n  #if PSYCHODELIC==1 \n    diff = diff * 13.0;\n  #elif PSYCHODELIC==2 \n    diff = 3.5 / diff;\n  #endif\n #endif\n\n#else\n    const float diff = 0.0;\n#endif\n\n    return l - diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    vec2 offset = vec2(-0.745, 0.0);\n    \n#if ZOOM_TO_REGION==1\n    vec2 zoomTo = vec2(-0.742513, -0.143715) - offset; // zoom to 'self'\n#elif ZOOM_TO_REGION==2\n    vec2 zoomTo = vec2(-0.15828, 1.0386) - offset; // zoom to 'self'\n#elif ZOOM_TO_REGION==3\n    vec2 zoomTo = vec2(-1.401155, 0.0) - offset;\n#else\n    vec2 zoomTo = vec2(0.0, 0.186);\n#endif\n\n\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float time = iTime*0.5*SPEED; \n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n        float time = iTime*0.5*SPEED;\n#endif\n    \n        float z = 0.5 + 0.5*cos(.25*time); // 0.0 .. 1.0\n        float zz = pow( z, 4.0);\n        float zoom = MAX_ZOOM*(1.0-zz) + MIN_ZOOM*zz; // values 0.0x .. 1.0\n        float coa = cos( 0.25*(1.0-z)*time );\n        float sia = sin( 0.25*(1.0-z)*time );\n        \n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n        vec2 c =  xy*zoom + offset + (1.0-zoom)*zoomTo;\n\n        float l = mandelbrot(c);\n\n        if (l > 0.001) { // do color mapping only for \"non-black\" values\n           color += 0.5 + 0.5*cos( l*0.10 + 3.0 + vec3(0.0, 0.6, 1.0));\n        }\n        \n#if AA>1\n    }\n    color /= float(AA*AA);\n#endif\n\n    fragColor = vec4( color, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}