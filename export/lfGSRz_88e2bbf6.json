{"ver":"0.1","info":{"id":"lfGSRz","date":"1714702316","viewed":94,"name":"Catch2 (824 char 3D game)","username":"ukeshet","description":"3D game, now less predictable and in only 824 characters. \nLeft-click to navigate. Game pauses briefly (discard) when the red glowing ball is caught (not easy!). \nShorter, less predictable version of Catch (https://www.shadertoy.com/view/4fcSzX).","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","fractal","game","raymarch"],"hasliked":0,"parentid":"4fcSzX","parentname":"Catch (986 char 3D game)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Minimalistic playable 3D ray-marched fractal game.\n// Demo for ICP course, by ukeshet.\n\nM { // Main image\n    float w,f,l,F=w=.1,S=50.,T=F*iTime,i=sin(T);\n\tV a,v,p,d,q=140.*V(i*cos(F*iDate.w),.5+i,P+F*T); // q=(-target location)\n    L; d=D*normalize(V(C+C-R.xy,-R.y));              // load position+direction\n    while (++l<S && w>Q) {                           // ray march\n\t\tv=p; w=Q; f=length(p+q); \n        for (i=S+S;i>P;i*=.4) {                      // fractalize\n\t\t\tv=.85*i-abs(mod(v+.5*V(v.z,0,-v),i+i)-i);\n            w=min(f,max(w,min(v.x,min(v.y,v.z))));   // ray distance\n        }\n        p+=w*d;                                      // ray step\n        if (f<5.) {F=S; if(l<P) discard;}            // mark/catch ball\n    }\n    O.xyz=mix(V(.5,.7,0),a*Q,l/S); O.x+=F+.6-.003*f; // ray color\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A: position+direction update with mouse input.\n\nM { // Main image\n    V p=V(-6,-6,1)/.1,a=p*Q,m=iMouse.xyz/R-.5; // -0.5<m.xy<+0.5\n    if (iFrame>1) {\n        L; m.z>Q?a+=.04*m:a;                    // load previous \n        a.x=mod(a.x,4.*P); a.y=clamp(-P,a.y,P); // update direction\n        p-=iTimeDelta*D*V(0,0,11);              // update position\n    }\n    O=vec4(p,round(a.x/Q)+.1*(a.y+P));          // save\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define P 1.57  // pi/2\n#define Q .001  // data packing precision\n#define V vec3\n#define R iResolution\n#define M void mainImage(out vec4 O,vec2 C)  // Main image\n#define L vec4 I=texture(iChannel0,C); p=I.xyz; a.x=Q*round(I.w); a.y=fract(I.w)/.1-P; // Load\n#define A vec4(sin(a.xy),cos(a))\n#define D mat3(A.z,0,A.x,-A.x*A.y,A.w,A.z*A.y,-A.w*A.x,-A.y,A.z*A.w) // 3D rotate","name":"Common","description":"","type":"common"}]}