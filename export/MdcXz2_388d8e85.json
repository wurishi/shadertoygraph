{"ver":"0.1","info":{"id":"MdcXz2","date":"1497043688","viewed":183,"name":"fnord balls","username":"hubbe","description":"Experimenting with simulated annealing to approximate an image using round shapes.\nProbably has bugs, because it doesn't work very well.\nIt kind of converges if you let it run long enough, but doesn't produce anything interesting.\n","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["balls","annealing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 a = texture(iChannel0, uv);\n    #if 0\n    vec4 b = texture(iChannel2, uv);\n    fragColor = abs(a - b);\n    #else\n    fragColor = a;\n    #endif\n    #if 1\n    if (texture(iChannel1, vec2(0.5)/iResolution.xy).w < 0.5) {\n        // fragColor.r += 0.2;\n    } else {\n        fragColor.g += 0.1;\n    }\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BALLS 500\n#define P 1024.0\n\nstruct Ball {\n    vec2 pos;\n    float alpha;\n    float radius;\n    vec3 color;\n};\n    \n// This function returns where in iChannel0, the position of ball \"v\" is.\nvec2 VarPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[0].x),\n                 floor(vf / iChannelResolution[0].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[0].xy;\n  return xy;\n}\n\n    \nBall getBall(int ball) {\n    Ball ret;\n    vec4 tmp1 = texture(iChannel0, VarPos(ball * 2));\n    vec4 tmp2 = texture(iChannel0, VarPos(ball * 2 + 1));\n    ret.pos = tmp1.xy;\n    ret.radius = tmp1.z;\n    ret.color = tmp2.xyz;\n    ret.alpha = tmp2.w;\n    return ret;\n}\n\n\n// Return a \"random\" number.\nhighp float rand(vec2 co)\n{\n    co.x += iTime;\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nint var_num(vec2 fragCoord) {\n    return int(fragCoord.x) + int(iResolution.x) * int(fragCoord.y);\n}\n\nvec2 srand;\nfloat scale;\nvoid randomize(inout float x) {\n    \n    srand += vec2(rand(srand), 0.1);\n\n    if (iFrame < 5) {\n        x = rand(srand);\n    } else {\n        x += (rand(srand) - 0.5) * scale;\n        x = clamp(x, 0.0, 1.0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   srand = fragCoord;\n   scale = 1.0/10.0;\n   int var = var_num(fragCoord);\n   int ball_num = var / 2;\n   if (ball_num < 0 || ball_num > BALLS * 2) discard;\n   int ball_to_get = ball_num;\n   bool modify = true;\n   if (ball_num >= BALLS) {\n       ball_to_get -= BALLS;\n       modify = false;\n   }\n   if (texture(iChannel1, vec2(0.5)/iResolution.xy).w < 0.5) {\n      ball_to_get += BALLS;\n   }\n   Ball b = getBall(ball_to_get);\n\n    if (modify) {\n        vec4 tmp = texture(iChannel1, vec2(1.5, 0.5)/iResolution.xy);\n        scale = dot(vec4(1.0, 1.0/P, 1.0/P/P, 1.0/P/P/P), tmp);\n        scale /= b.radius * 10.0;\n        scale /= b.alpha * 10.0;\n\n        randomize(b.pos.x);\n        randomize(b.pos.y);\n        b.pos.y = clamp(b.pos.y, 0.0, iResolution.y / iResolution.x);\n        randomize(b.radius);\n        b.radius = clamp(b.radius, 0.01, 1.0);\n        randomize(b.color.x);\n        randomize(b.color.y);\n        randomize(b.color.z);\n        randomize(b.alpha);\n        b.alpha = clamp(b.alpha, 0.05, 1.0);\n        if (iFrame < 5) b.radius /= 10.0;\n    }\n    if (ball_num * 2 == var) {\n        fragColor = vec4(b.pos, b.radius, 0);\n    } else {\n        fragColor = vec4(b.color, b.alpha);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define BALLS 500\n\nstruct Ball {\n    vec2 pos;\n    float alpha;\n    float radius;\n    vec3 color;\n};\n    \n// This function returns where in iChannel0, the position of ball \"v\" is.\nvec2 VarPos(int v) {\n  float vf = float(v);\n  vec2 xy = vec2(mod(vf, iChannelResolution[0].x),\n                 floor(vf / iChannelResolution[0].x));\n  xy += vec2(0.5);\n  xy /= iChannelResolution[0].xy;\n  return xy;\n}\n\n    \nBall getBall(int ball) {\n    Ball ret;\n    vec4 tmp1 = texture(iChannel0, VarPos(ball * 2));\n    vec4 tmp2 = texture(iChannel0, VarPos(ball * 2 + 1));\n    ret.pos = tmp1.xy;\n    ret.radius = tmp1.z;\n    ret.color = tmp2.xyz;\n    ret.alpha = tmp2.w;\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,1);\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    for (int i = 0; i < BALLS; i++) {\n        Ball b = getBall(i);\n        vec2 x = b.pos - uv;\n        if (length(x) < b.radius) {\n            float tmp = (b.radius - length(x)) / b.radius;\n            fragColor = mix(fragColor, vec4(b.color, 1.0), b.alpha * tmp);\n        }        \n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x >= 32.0 || fragCoord.y >= 32.0) discard;\n    vec2 p = fragCoord * 16.0;\n    vec4 ret = vec4(0.0);\n    for (int x = 0; x < 16; x++) {\n        for (int y = 0; y < 16; y++) {\n            vec2 p2 = (p + vec2(float(x), float(y))) / 512.0;\n            vec4 a = texture(iChannel0, p2);\n            vec4 b = texture(iChannel1, p2);\n            ret += abs(a - b);\n        } \n    }\n    ret /= 256.0;\n    fragColor = ret;\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define P 1024.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 0.6) discard;\n    if (fragCoord.x > 1.6) discard;\n\n    if (fragCoord.x > 0.6) {\n        vec4 tmp = texture(iChannel1, vec2(1.5, 0.5)/iResolution.xy);\n        float scale = dot(vec4(1.0, 1.0/P, 1.0/P/P, 1.0/P/P/P), tmp);\n        if (iFrame < 10) scale = 1.0/10.0;\n        if (texture(iChannel1, vec2(0.5)/iResolution.xy).w < 0.5)\n        {\n            scale *= 0.999;\n        } else {\n            scale *= 1.005;\n        }\n        scale = min(scale, 1.0/10.0);\n        fragColor.x = floor(scale);\n        scale -= fragColor.x;\n        scale *= P;\n        fragColor.y = floor(scale);\n        scale -= fragColor.y;\n        scale *= P;\n        fragColor.z = floor(scale);\n        scale -= fragColor.z;\n        scale *= P;\n        fragColor.w = scale;\n        return;\n    }\n    \n    vec4 ret = vec4(0.0);\n    for (int x = 1; x <= 32; x+=2) {\n        for (int y = 1; y <= 32; y+=2) {\n            ret += texture(iChannel0, vec2(float(x), float(y)) / iResolution.xy);\n        }\n    }\n    \n    highp float err = dot(vec4(vec3(1.0/3.0),0.0), ret);\n    \n    fragColor = texture(iChannel1, vec2(0.5)/iResolution.xy);\n\n    highp float previous_err = fragColor.x + fragColor.y/P + fragColor.z/P/P;\n\n    if (err <= previous_err || iFrame < 6) {\n        fragColor.w = 1.0;\n        fragColor.x = floor(err);\n        err -= fragColor.x;\n        err *= 1024.0;\n        fragColor.y = floor(err);\n        err -= fragColor.y;\n        err *= 1024.0;\n        fragColor.z = err;\n    } else {\n        fragColor.w = 0.0;\n    }\n}","name":"Buf D","description":"","type":"buffer"}]}