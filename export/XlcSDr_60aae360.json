{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by sebastien durand - 11/2016\n//-------------------------------------------------------------------------------------\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n// Some part of code are extracted, adaptated or inspired by\n//\n// Planet Shadertoy by Reinder Nijhoff [https://www.shadertoy.com/view/4tjGRh]\n// Type 2 Supernova by Duke (https://www.shadertoy.com/view/lsyXDK) \n// Supernova remnant by Duke [https://www.shadertoy.com/view/MdKXzc]\n// Awesome star by Foxes [https://www.shadertoy.com/view/4lfSzS]\n// Black Body Spectrum plank by FabriceNeyret2 [https://www.shadertoy.com/view/4tdGWM]\n// Alien Beacon by otaviogood's [https://www.shadertoy.com/view/ld2SzK]\n// Hash without Sine by Dave_Hoskins [https://www.shadertoy.com/view/4djSRW]\n// Noise - value - 3D by iq [https://www.shadertoy.com/view/4sfGzS]\n// Smooth HSV by iq [https://www.shadertoy.com/view/MsS3Wc]\n// And many others  :)\n//-------------------------------------------------------------------------------------\n\n\n// Some stranges behaviours detected under \n//     Ubunto - Firefox and \n//     Manjaro linux - chromium - ati 280\n//  => strange navigation, star disaper when clicked\n \n\n#define WITH_INTERGALACTIC_CLOUDS\n\n// in progress\n//#define WITH_PLANETS  \n\n// If fast enougth\n#define WITH_SUPERNOVA_REMNANT\n//#define WITH_DOUBLE_GALAXY;\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\n\n#define SPIRAL_NOISE_ITER 6\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI / 180.0);\n\n// Unit = 10 UA\nconst int   GALAXY_FIELD_VOXEL_STEPS = 16;\nconst int   GALAXY_FIELD_VOXEL_STEPS_HD = 7;\nconst float GALAXY_FIELD_VOXEL_STEP_SIZE = 250000.; // 2,500,000 AL\nconst float GALAXY_RADIUS = .015;  // (% of 250000)  50,000 AL\n\nconst int   STAR_FIELD_VOXEL_STEPS = 22;\nconst float STAR_FIELD_VOXEL_STEP_SIZE = .5;  // 5AL \nconst float STAR_RADIUS = .01; // 2e-8 in true life !   // (% of 5)   1e-8\n\nconst float PLANET_FIELD_SCALE = 75.;\nconst int   PLANET_FIELD_VOXEL_STEPS = 10;\nconst float PLANET_FIELD_VOXEL_STEP_SIZE = .5;  // 5AL \nconst float PLANET_RADIUS = .04;\n\n\nconst float kU2G = GALAXY_FIELD_VOXEL_STEP_SIZE/STAR_FIELD_VOXEL_STEP_SIZE;\nconst float kG2U = STAR_FIELD_VOXEL_STEP_SIZE/GALAXY_FIELD_VOXEL_STEP_SIZE;\n\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\n\nfloat time;\n\n\n//-----------------------------------------------------\n\n\n#define IN_UNIVERSE 1.\n#define IN_GALAXY 2.\n#define IN_SOLAR_SYSTEM 3.\n\n#define MOVING     1.\n#define STATIONARY 2.\n\n#define NONE     0.\n#define GALAXY   1.\n#define STAR     2.\n#define PLANET   3.\n\n\nstruct Config {\n \tfloat movingMode;\n    float targetType;\n    float coordSystem;\n    float time;\n    vec3 ro_cam;\n    vec3 rd_cam;\n    vec3 target_pos;\n    vec3 galaxy_pos;\n};\n    \n//--------------------------------------------------------------------\n// from iq shader Brick [https://www.shadertoy.com/view/MddGzf]\n//--------------------------------------------------------------------\n\n#define CONF(id)  texture(iChannel0, vec2(id+.5,.5)/ iChannelResolution[0].xy, -100.0).xyz;\n#define CONF4(id) texture(iChannel0, vec2(id+.5,.5)/ iChannelResolution[0].xy, -100.0);\n\nConfig getConfig() { \n    vec4 v1 = CONF4(0.);\n    Config cfg;\n    \n    cfg.movingMode = v1.x > 1.5 ? STATIONARY : \n                     MOVING;\n    cfg.targetType = v1.y > 2.5 ? PLANET : \n    \t\t\t\t v1.y > 1.5 ? STAR:\n    \t\t\t\t v1.y > 0.5 ? GALAXY:\n    \t\t\t\t NONE;\n    cfg.coordSystem = v1.z > 2.5 ? IN_SOLAR_SYSTEM :\n    \t\t\t\t  v1.z > 1.5 ? IN_GALAXY :\t\t\t\t\n                      IN_UNIVERSE;\n    cfg.time = v1.w;\n    cfg.ro_cam = CONF(1.);\n    cfg.rd_cam = CONF(2.);\n    cfg.target_pos = CONF(3.);\n    cfg.galaxy_pos = CONF(4.);\n    return cfg;\n}\n\n//-----------------------------------------------------\n// Paletes functions\n//-----------------------------------------------------\n\n// from FabriceNeyret2 shader Black Body Spectrum plank [https://www.shadertoy.com/view/4tdGWM]\nvec3 blackBodyColor(float k) {\n    float T = (k*2.)*16000.;\n    vec3 c = vec3(1.,3.375,8.)/(exp((19e3*vec3(1.,1.5,2.)/T)) - 1.); // Planck law\n    return c / max(c.r,max(c.g,c.b));  // chrominance\n}\n\n//-----------------------------------------------------\n// Noise functions\n//-----------------------------------------------------\n// Hash without Sine by Dave_Hoskins [https://www.shadertoy.com/view/4djSRW]\n//----------------------------------------------------------------------------------------\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n#define HASHSCALE1 .1031\n\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec4 hash4(const in vec4 n) { return fract(sin(n)*1399763.5453123); }\n\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n//----------------------------------------------------------------------------------------\n\n\n\n// [iq] https://www.shadertoy.com/view/4sfGzS\nfloat noise(const in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf *= f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = textureLod( iChannel1, (uv+.5)/256., -100.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat pn(const in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf *= f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = textureLod( iChannel1, (uv+.5)/256., -100.).yx;\n\treturn 2.4*mix(rg.x, rg.y, f.z)-1.;\n}\n\nfloat bm(const in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf *= f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = textureLod( iChannel1, (uv+ .5)/256., -100.).yx;\n\treturn 1.-.82*mix(rg.x, rg.y, f.z);\n}\n\nfloat fpn(const in vec3 p) { \n    return pn(p*.06125)*.5 + \n           pn(p*.125)*.25 + \n           pn(p*.25)*.125;// + pn(p*.5)*.625;\n}\n\nfloat fbm(const in vec3 p) {\n   return bm(p*.06125)*.5 + \n          bm(p*.125)*.25 + \n          bm(p*.25)*.125 + \n          bm(p*.4)*.2;\n}\n\nconst mat3 msun = mat3(0., .8, .6, -.8, .36, -.48, -.6, -.48, .64);\n\nfloat smoothNoise(in vec3 q){\n\tfloat f  = .5000*noise(q); q=msun*q*2.01;\n          f += .2500*noise(q); q=msun*q*2.02;\n          f += .1250*noise(q); q=msun*q*2.03;\n          f += .0625*noise(q);\n\treturn f;\n}\n\n//-------------------------------------------------------------------------------------\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 20.;\t// size of perpendicular vector\nfloat normalizer = 1.0 / sqrt(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p, vec4 id) {\n    float iter = 2., n = 2.-id.x; // noise amount\n    for (int i = 0; i < SPIRAL_NOISE_ITER; i++) {\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter; // add sin and cos scaled inverse with the frequency (abs for a ridged look)\n        p.xy += vec2(p.y, -p.x) * nudge; // rotate by adding perpendicular and scaling down\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge; // rotate on other axis\n        p.xz *= normalizer;  \n        iter *= id.y + .733733;          // increase the frequency\n    }\n    return n;\n}\n\nfloat mapIntergalacticCloud(vec3 p, vec4 id) {\n\tfloat k = 2.*id.w +.1;  // p/=k;\n    return k*(.5 + SpiralNoiseC(p.zxy*.4132+333., id)*3. + pn(p*8.5)*.12);\n}\n\n#ifdef WITH_SUPERNOVA_REMNANT\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n} \n\nconst float nudge2 = .9;\t// size of perpendicular vector\nfloat normalizer2 = 1. / sqrt(1. + nudge2*nudge2);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC2(vec3 p) {\n    float n = 0., iter = 2.;\n    for (int i = 0; i < 8; i++) {\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        p.xy += vec2(p.y, -p.x) * nudge2;\n        p.xy *= normalizer2;\n        p.xz += vec2(p.z, -p.x) * nudge2;\n        p.xz *= normalizer2;\n        iter *= 1.733733;\n    }\n    return n;\n}\n\nfloat length2( vec2 p) {\n\treturn sqrt(p.x*p.x + p.y*p.y);\n}\n\nfloat length8(vec2 p) {\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow(p.x + p.y, .125);\n}\n\nfloat Disk(vec3 p, vec3 t) {\n    vec2 q = vec2(length2(p.xy)-t.x,p.z*0.5);\n    return max(length8(q)-t.y, abs(p.z) - t.z);\n}\n\nfloat mapSupernovaRemnant(vec3 p) {\n\tp*=2.;\n    float noi = Disk(p.xzy,vec3(2.0,1.8,1.25))+\n    \t+ fbm(p*90.)\n    \t+ SpiralNoiseC2(p.zxy*0.5123+100.0)*3.0;\n\treturn abs(noi*.5)+0.07;\n}\n\n#endif // WITH_SUPERNOVA_REMNANT\n\n\n\n\n//-----------------------------------------------------\n// Intersection functions (mainly adapted from iq ones)\n//-----------------------------------------------------\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in float r, out float dist, out float edge) {\n\tfloat b = dot(rd,-ro), d = b*b - dot(ro,ro) + r*r;\n\tif (d < 0.) return false;\n    edge = sqrt(d);\n\tdist = b - edge;\n\treturn dist > 0.;\n}\n\nbool cylinder(vec3 ro, vec3 rd, float r, float h, out float tn, out float tf) {\n\tfloat a = dot(rd.xy, rd.xy), b = dot(ro.xy, rd.xy),\n\t\t  d = b*b - a*(dot(ro.xy, ro.xy) - r*r);    \n\tif(d < 0.) return false;\n\td = sqrt(d);\n\ttn = (-b - d)/a; tf = (-b + d)/a;\n\ta = min(tf, tn); tf = max(tf, tn); tn = a; // order roots\n\ta = ro.z + tn * rd.z;\n    b = ro.z + tf * rd.z;\n\t// top, bottom\n\tvec2 zcap = h*vec2(.5, -.5), cap = (zcap - ro.z) / rd.z;\n    tn = a < zcap.y ? cap.y : a > zcap.x ? cap.x : tn;\n\ttf = b < zcap.y ? cap.y : b > zcap.x ? cap.x : tf;\n    return tf > 0. && tf > tn;\n}\n\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n\t//return length(cross(p-ro,rd));\n}\n\n// +------------------------------------------------------+\n// |                 Star ray effect                      |\n// +------------------------------------------------------+\n\n//---------------------------------------------------------\n// Awesome star by Foxes [https://www.shadertoy.com/view/4lfSzS]\n//---------------------------------------------------------\n \nfloat noise4q(vec4 x) {\n\tvec4 n3 = vec4(0,.25,.5,.75);\n\tvec4 p2 = floor(x.wwww+n3);\n\tvec4 b = floor(x.xxxx+n3) + floor(x.yyyy+n3)*157. + floor(x.zzzz +n3)*113.;\n\tvec4 p1 = b + fract(p2*.00390625)*vec4(164352., -164352., 163840., -163840.);\n\tp2 = b + fract((p2+1.0)*.00390625)*vec4(164352., -164352., 163840., -163840.);\n\tvec4 f1 = fract(x.xxxx+n3),f2 = fract(x.yyyy+n3);\n\tf1 *= f1*(3.0-f1-f1);\n\tf2 *= f2*(3.0-f2-f2);\n\tvec4 n1 = vec4(0,1.,157.,158.), \n         n2 = vec4(113.,114.,270.0,271.);\t\n\tvec4 vs1 = mix(hash4(p1), hash4(n1.yyyy+p1), f1),\n         vs2 = mix(hash4(n1.zzzz+p1), hash4(n1.wwww+p1), f1),\n         vs3 = mix(hash4(p2), hash4(n1.yyyy+p2), f1),\n         vs4 = mix(hash4(n1.zzzz+p2), hash4(n1.wwww+p2), f1);\t\n\tvs1 = mix(vs1, vs2, f2);\n\tvs3 = mix(vs3, vs4, f2);\n\tvs2 = mix(hash4(n2.xxxx+p1), hash4(n2.yyyy+p1), f1);\n\tvs4 = mix(hash4(n2.zzzz+p1), hash4(n2.wwww+p1), f1);\n\tvs2 = mix(vs2, vs4, f2);\n\tvs4 = mix(hash4(n2.xxxx+p2), hash4(n2.yyyy+p2), f1);\n\tvec4 vs5 = mix(hash4(n2.zzzz+p2), hash4(n2.wwww+p2), f1);\n\tvs4 = mix(vs4, vs5, f2);\n\tf1 = fract(x.zzzz+n3);\n\tf2 = fract(x.wwww+n3);\n\tf1 *= f1*(3.-f1-f1);\n\tf2 *= f2*(3.-f2-f2);\n\tvs1 = mix(vs1, vs2, f1);\n\tvs3 = mix(vs3, vs4, f1);\n\tvs1 = mix(vs1, vs3, f2);\n\tfloat r = dot(vs1,vec4(.25));\n\treturn r*r*(3.-r-r);\n}\n\n// rays of a star\nfloat ringRayNoise(vec3 ray, vec3 pos, float r, float size, float anim) {\n  \tfloat b = dot(ray,pos);\n    vec3 pr = ray*b-pos;\n    float c = length(pr),\n     \t  s = max(0.,(1.-size*abs(r-c)));\n    pr = pr/c;\n    float n=.4, ns=1., nd = noise4q(vec4(pr*1.0,-anim+c))*2.0;\n    if (c > r) {\n        n  = noise4q(vec4(pr*10.0,-anim+c));\n        ns = noise4q(vec4(pr*50.0,-anim*2.5+ c+c))*2.;\n    }\n    n *= n*nd*nd*ns;\n    return s*s*(s*s+n);\n}\n\n\n// +------------------------------------------------------+\n// |                  Sun Lava effect                     |\n// +------------------------------------------------------+\n\nvec3 getSunColor(in vec3 p, in vec4 id, in float time) {\n    float lava = smoothNoise((p+vec3(time*.03))*50.*(.5+id.z) );\n    return blackBodyColor(.02+3.*clamp(id.x*id.x,.05,1.)*(1. - sqrt(lava)));\n}\n\nvec4 renderSun(in vec3 ro, in vec3 rd, in vec4 id, in float time) {\n\t// Rotate view to integrate sun rotation \n    // R(ro.zx, 1.6-time*.5*id.w);\n    // R(rd.zx, 1.6-time*.5*id.w);\n    vec4 color = vec4(0.);\n    float dist, edge;   \n    if (intersectSphere(ro, rd, 1., dist, edge)) {\n        vec3  pos = ro+rd*dist,\n        \t  nor = normalize(pos);\n    \tcolor = vec4(getSunColor(pos, id, time), smoothstep(0., .2, edge));\n    }\n    // Rays\n    float s3 = ringRayNoise(rd,ro,1.0,5.-4.*id.y,time);\n\tcolor.a = max(color.a, clamp(s3,0.,.98));\n    color.rgb += blackBodyColor(id.x)*s3;\n    color.rgb *=  1.-.03*cos(5.*time+2.*hash(time));  // twinkling;\n\treturn clamp(color, vec4(0.),vec4(1.));\n}\n\n// ---------------------------------------------------\n// Render Supernova Remnant\n// ---------------------------------------------------\n// Supernova remnant by Duke [https://www.shadertoy.com/view/MdKXzc]\n// ---------------------------------------------------\n\n#ifdef WITH_SUPERNOVA_REMNANT\n\nvec3 computeColorSR(float density, float radius) {\n\treturn mix( vec3(1.,.9,.8), vec3(.4,.15,.1), density)\n\t\t * mix( 7.*vec3(.8,1.,1.), 1.5*vec3(.48,0.53,.5), min( (radius+.5)/.9, 1.15 ) );\n}\n\nvec4 renderSupernova(vec3 ro, vec3 rd) {\n\tfloat td=0., lDist, d, t;\n    const float h = .1;\n    vec4 sum = vec4(0.);\n    float min_dist=0., max_dist=0.;\n    vec3 pos;\n    \n    if (RaySphereIntersect(ro, rd, min_dist, max_dist)) {       \n        t = max(min_dist,0.) + .01*hash(rd);\n        for (int i=0; i<64; i++) {\n            if (td>.9 || sum.a > .99 || t>max_dist) break;\n            pos = ro + t*rd;\n            d = mapSupernovaRemnant(pos);\n            //d = max(d, 0.);\n            // point light calculations\n            lDist = max(length(pos), .001);\n            sum+= vec4(.67,.75,1.,1.)/(lDist*lDist*10.)*.0125; // star itself\n            sum+= vec4(1.,.5,.25,.6)/exp(lDist*lDist*lDist*.08)*.033; // bloom\n            if (d<h) {\n                td += (1. - td) * (h - d) + .005;\n                vec4 col = vec4(computeColorSR(td,lDist), td*.2 );\n                sum.rgb += sum.a * sum.rgb * .2;\t\n                col.rgb *= col.a;\n                sum += col*(1. - sum.a);  \n            }\n            td += .014;\n            // trying to optimize step size near the camera and near the light source\n            t += max(d * .1 * max(min(lDist,length(ro)),1.0), 0.01);\n        }\n        // simple scattering\n      //  sum *= 1. / exp( ld * 0.2 ) * 0.6;\n        sum = clamp(sum, 0., 1.);\n        sum.xyz *= sum.xyz*(3.-sum.xyz-sum.xyz);\n\t}    \n\treturn sum;\n}\n\n#endif\n\n// +----------------------------------------+\n// |               Galaxy                   |\n// +----------------------------------------+\n\nfloat spiralArm(in vec3 p, in float thickness, in float blurAmout, in float blurStyle) {\n    float dephase = 2., loop = 4.;\n    float a = atan(p.x,p.z),  // angle     \n\t\t  r = length(p.xz), lr = log(r), // distance to center\n    \t  th = .1-.25*r, // thickness according to distance\n    \t  d = fract(.5*(a-lr*loop)/PI); //apply rotation and scaling.\n    d = (.5/dephase - abs(d-.5))*2.*PI*r;\n  \td *= (1.-lr)/thickness;  // space fct of distance\n    // Perturb distance fiel1\n    float radialBlur = blurAmout*mix(fpn(8.*vec3(r*43.,40.*d,24.*p.y)),fpn(p*400.0), blurStyle);\n    return sqrt(d*d+10.*p.y*p.y/thickness)-th*r*.2-radialBlur;\n}\n\nvoid galaxyTransForm(inout vec3 ro, const in vec4 id ) {\n    R(ro.yz, (id.y-.5));\n // R(ro.xy, .25*id.x*iTime);\n}\n\nfloat mapGalaxy(vec3 p, vec4 id) {  \n\tfloat d1 = spiralArm(p.xzy*.2, 10.*(.5+.5*id.x), .2+.3*id.y, id.z);\n#ifdef WITH_DOUBLE_GALAXY\n    if (id.z<.25) {\n   \t\tfloat d2 = spiralArm(vec3(-p.y,p.z,p.x)*.205, 10.*(.5+.5*id.x), .2+.3*id.y, id.z);        \n   \t\treturn min(d2, d1);\n     } \n#endif    \n     return d1;\n}\n\n// assign color to the media\nvec3 computeColor( float density, float radius ) {\n\t// color based on density alone, gives impression of occlusion within the media\n\treturn  mix(vec3(.25,.22,.2), vec3(.1,.0375,.025), density )*\n\t        mix(vec3(4.8,6.,6.),  vec3(.96,1.06,1.), min((radius+.5)*.5, 1.15)); // color added for disk\n}\n\nvec4 renderGalaxy(in vec3 ro, in vec3 rd, in vec4 id, in bool fast) { \n\tvec4 col, sum = vec4(0);\n    float min_dist=0., max_dist=100.;\n \n    galaxyTransForm(ro,id);\n    galaxyTransForm(rd,id);\n    \n    if (cylinder(ro, rd, 3.,3.5, min_dist, max_dist)) {\n        float ld, td=0., d, t;\n\t\tfloat lDist, lDist2;\n        vec3 pos, ldst, ldst2, lightColor;\n        const float h = .1;\n\n        t = max(min_dist,t) + .2*hash(rd+iTime);;\n\n        // raymarch loop\n        for (int i=0; i<48; i++)  {\n            // Loop break conditions.\n            if ((fast&&i>20) || td>.9 ||  sum.a > 0.99 || t>max_dist) break;\n\t\t\n            pos = ro + t*rd;\n            \n            d = mapGalaxy(3.5*pos, id); // evaluate distance function\n            d = abs(d)+.05;  // kind of countour drawing\n            d = max(d,.005); // change this string to control density \n            \n            if (d<h) {\n                // compute local density \n                ld = h - d;         \n                ld +=  clamp((ld - mapGalaxy(pos*3.5-.2*normalize(pos), id))*2.5, 0., 1. );\n                td += (1. - td) * ld + .005;\n                col = vec4(computeColor(td,length(pos)), td*.25 );\n                col.rgb *= col.a;\n                sum += col*(1. - sum.a);  \n            }\n\n            td += .014;\n            // point light calculations\n            ldst = pos*.25;\n            ldst2 = pos*.05;\n            ldst2.z *= 2.5;\n            lDist  = max(length(ldst),.0001); //max(length(ldst), 0.001);\n            lDist2 = max(length(ldst2),.0001);\n            // star in center\n            lightColor = (1.-smoothstep(3.,4.5,lDist*lDist))*\n                mix(.07*vec3(1.,.5,.25)/(lDist),\n                    .008*vec3(1.,1.7,2.)/(lDist2), \n                    smoothstep(.2,.7,lDist));\n\n            // star in center\n            sum.rgb += lightColor/(lDist*20.); //add a bloom around the light\n            d = max(d, .04); \n            t +=  max(d * .3, .02);\n        }\n   \t\tsum = clamp(sum, 0., 1.);\n      \tsum.xyz *= sum.xyz*(3.-sum.xyz-sum.xyz);\n    }\n    \n    return sum;\n}\n\n\n//--------------------------------------------------------------\n// Adapted from Planet Shadertoy - Reinder Nijhoff [https://www.shadertoy.com/view/4tjGRh]\n//--------------------------------------------------------------\n// Toujours en coordonnes Univers\nvec4 renderGalaxyField(in vec3 roU, in vec3 rd, out vec3 out_posU, out vec3 out_id, in bool fast) { \n    out_id = vec3(9);\n      \n    float dint, d=0.;\n    vec3 offset, id, galaxyro,\n         ros = roU + rd*d,\n         pos = floor(ros),\n         ri = 1./rd,\n         rs = sign(rd),\n         dis = (pos-ros + .5 + rs*.5) * ri;\n\tvec4 col, sum = vec4(0);\n    \n\tfor( int i=0; i<GALAXY_FIELD_VOXEL_STEPS_HD; i++ ) {\n        \n        if (!fast || i!=0 ) {//galaxyId != id) {\n            id = hash33(pos);\n        \toffset = clamp(id, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n       \t\td = distanceRayPoint(ros, rd, pos+offset, dint);\n        \tif (dint > 0. && d<GALAXY_RADIUS) {\n                galaxyro = ros-(pos+offset);\n                col = renderGalaxy(galaxyro/GALAXY_RADIUS*3., rd, vec4(id,.5), fast);\n            \tcol.rgb *= smoothstep(float(GALAXY_FIELD_VOXEL_STEPS),0.,length(roU -pos));\n                out_id = id;\n                sum += (1.-sum.a)*col;\n                if (sum.a>.99)\n                    break;\n            }\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n    \n    if (!fast && sum.a<.99) {\n        for( int i=GALAXY_FIELD_VOXEL_STEPS_HD; i<GALAXY_FIELD_VOXEL_STEPS; i++ ) {\n            id = hash33(pos);\n            offset = clamp(id, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n            d = distanceRayPoint(ros, rd, pos+offset, dint);\n            if (dint > 0.) { \n                col = vec4(.9,.9,.8, 1.)*(1.-smoothstep(GALAXY_RADIUS*.25,GALAXY_RADIUS*.5,d));\n                col.rgb *= smoothstep(float(GALAXY_FIELD_VOXEL_STEPS),0.,length(roU -pos));\n                out_id = id;\n                sum += (1.-sum.a)*col;\n                if (sum.a>.99)\n                    break;\n            }\n\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n            dis += mm * rs * ri;\n            pos += mm * rs;\n        }\n    }\n\n\treturn sum; \n}\n\n//--------------------------------------------------------------\n// Adapted from Planet Shadertoy - Reinder Nijhoff [https://www.shadertoy.com/view/4tjGRh]\n//--------------------------------------------------------------\n// Toujours en coordonnes Galaxy\nvec4 renderStarField(in vec3 roG, in vec3 rd, inout float out_dStar, out vec3 out_id) { \n    out_id = vec3(9);\n    \n    float dint, d = 0.;\n    vec3 offset, id,\n         ros = roG + rd*d,  \n         pos = floor(ros),\n         ri = 1./rd,\n         rs = sign(rd),\n         dis = (pos-ros + .5 + rs*.5) * ri;\n    vec4 col, sum = vec4(0);\n    \n    float pitch = 10. / iResolution.x;\n    \n\tfor( int i=0; i<STAR_FIELD_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id,STAR_RADIUS, 1.-STAR_RADIUS);\n        \n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint > 0.) { \n            if (dint < 2. && d<STAR_RADIUS) {\n                col =\n#ifdef WITH_SUPERNOVA_REMNANT\n                \tid.x>.8 ? renderSupernova((ros-(pos+offset))*3./STAR_RADIUS, rd) :\n#endif\n                renderSun((ros-(pos+offset))*2./STAR_RADIUS, rd, vec4(id,.5), iTime);\n                out_id = id;\n            \tif (col.a>.99) out_dStar = dint;\n            } else {\n                col = (vec4(blackBodyColor(max(id.x-.1, .01)), 1.)*(1.-smoothstep(STAR_RADIUS*.5,STAR_RADIUS,d)));\n            }\n            col.rgb *= smoothstep(float(STAR_FIELD_VOXEL_STEPS), .5, dint);\n            col.rgb *= col.a;\t\t\t\t                                \n            sum += (1.-sum.a)*col;\n            if (sum.a>.99)\n                break;\n        }\n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\treturn sum;\n}\n\n#ifdef WITH_PLANETS\n\nvec3 getPlanetColor(in vec3 p, vec4 id) {\n    float lava = smoothNoise(p*1.5*(5.*id.z) );\n    return blackBodyColor((.5+id.x)*(1. - pow(lava,2.*id.y))); // todo: le faire sur une constante\n}\n\nvec4 renderPlanet(in vec3 ro, in vec3 rd, in vec4 id, in vec3 lightDir, float dSun) {\n    vec4 color = vec4(0.);\n  \tfloat r = 1.;\n    float dist, edge;   \n    \n    if (intersectSphere(ro, rd, r, dist, edge)) {\n        if (dist<dSun) {\n\n            vec3  pos = ro+rd*dist,\n                  nor = normalize(pos);\n            float a = smoothstep(0., .8*r, edge); \n            vec3 oCol = getPlanetColor(pos, id);\n\n            vec3 norm = -normalize(pos);\n            float dif = clamp(dot(lightDir, norm), 0.0, 1.0);\n\n            vec3 h = normalize(-rd + lightDir);\n            float spe = pow(clamp(dot(h, norm), 0.0, 1.0), 4.0);\n\n            oCol = dif * oCol ;\n            oCol += dif * spe;\n            color = vec4(oCol, 1.);\n       }\n    }\n\treturn clamp(color, vec4(0.),vec4(1.));\n}\n\n\n// TODO ue 2D field ex: iq : https://www.shadertoy.com/view/4dSGW1\nvec4 renderPlanetField(in vec3 sunPos, in vec3 roG, in vec3 rd, inout float out_dStar, out vec3 out_id) { \n    out_id = vec3(9);\n\n    roG -= sunPos;\n    roG *= PLANET_FIELD_SCALE;\n    roG.z+=.5;\n    \n    float distSunDrawing = out_dStar*PLANET_FIELD_SCALE;\n    float rayon = 3.;\n    float min_dist=0., max_dist=100.;\n    \n    vec4 col, sum = vec4(0);\n\n  //  if (cylinder(roG, rd, rayon, 1., min_dist, max_dist)) {\n        float dint, d = max(0., (length(roG)-rayon)); //min_dist;\n        vec3 offset, id,\n             ros = roG + rd*d,  \n             pos = floor(ros),\n             ri = 1./rd,\n             rs = sign(rd),\n             dis = (pos-ros + .5 + rs*.5) * ri;\n\n        for( int i=0; i<PLANET_FIELD_VOXEL_STEPS; i++ ) {\n            if (length(pos) < rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75) {\n                id = hash33(pos+sunPos);\n                offset = clamp(id,PLANET_RADIUS, 1.-PLANET_RADIUS);\n                offset.z = .5;\n\t\t\t\t\n                col = renderPlanet((ros-(pos+offset))/PLANET_RADIUS, rd, vec4(id,.5), normalize((pos+offset)-ros), distSunDrawing);\n                out_id = id;\n                if (col.a>.95) out_dStar = dint;\n                col.rgb *= col.a;\t\t\t\t                                \n                sum += (1.-sum.a)*col;\n                if (sum.a>.99)\n                    break;\n            }\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n            dis += mm * rs * ri;\n            pos += mm * rs;\n            \n        }\n  //  }\n    return sum;\n}\n\n#endif\n// ---------------------------------------------------\n// Render intergalactic clouds\n// ---------------------------------------------------\n\n\n#ifdef WITH_INTERGALACTIC_CLOUDS\n\n//-------------------------------------------------------------------------------------\n// Adapted from [iq: https://www.shadertoy.com/view/MsS3Wc]\n//-------------------------------------------------------------------------------------\nvec3 hsv2rgb(float x, float y, float z) {\t\n\treturn z+z*y*(clamp(abs(mod(x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.)-1.);\n}\n\n//-------------------------------------------------------------------------------------\n// Based on \"Type 2 Supernova\" by Duke (https://www.shadertoy.com/view/lsyXDK) \n//-------------------------------------------------------------------------------------\nvec4 renderIntergalacticClouds(vec3 ro, vec3 rd, float tmax, const vec4 id) {\n    \n    float max_dist= min(tmax, float(STAR_FIELD_VOXEL_STEPS)),\n\t\t  td=0., d, t, noi, lDist, a, sp = 9.,         \n    \t  rRef = 2.*id.x,\n          h = .05+.25*id.z;\n    vec3 pos, lightColor;   \n    vec4 sum = vec4(0);\n   \t\n    t = .1*hash(hash(rd)); \n\n    for (int i=0; i<100; i++)  {\n\t    if(td>.9 ||  sum.a > .99 || t>max_dist) break;\n        a = smoothstep(max_dist,0.,t);\n        pos = ro + t*rd;\n        d = abs(mapIntergalacticCloud(pos, id))+.07;\n\n        // Light calculations\n        lDist = max(length(mod(pos+sp*.5,sp)-sp*.5), .001); // TODO add random offset\n        noi = pn(.05*pos);\n        lightColor = mix(hsv2rgb(noi,.5,.6), \n                         hsv2rgb(noi+.3,.5,.6), \n                         smoothstep(rRef*.5,rRef*2.,lDist));\n        sum.rgb += a*lightColor/exp(lDist*lDist*lDist*.08)/30.;\n\t\t// Edges coloring\n        if (d<h) {\n\t\t\ttd += (1.-td)*(h-d)+.005;  // accumulate density\n            sum.rgb += sum.a * sum.rgb * .25 / lDist;  // emission\t\n\t\t\tsum += (1.-sum.a)*.02*td*a;  // uniform scale density + alpha blend in contribution \n        } \n        td += .015;\n        t += max(d * .08 * max(min(lDist,d),2.), .01);  // trying to optimize step size\n    }\n    \n   \tsum = clamp(sum, 0., 1.);   \n    sum.xyz *= sum.xyz*(3.-sum.xyz-sum.xyz);\n\treturn sum;\n}\n\n#endif \n\n//-----------------------------------------------------\n//        Coordinate system conversions\n//-----------------------------------------------------\n\nbool isInGalaxy(in vec3 roU, out vec3 out_GalaxyId, out vec3 out_GalaxyPosU) {\n    vec3 pos = floor(roU);\n    out_GalaxyId = hash33(pos);\n    vec3 offset = clamp(out_GalaxyId, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n    out_GalaxyPosU = (pos+offset);\n    return length(roU - out_GalaxyPosU) < GALAXY_RADIUS;\n}\n\n// Echelle 1 pour la grille des galaxies \nvec3 galaxyToUniverse(vec3 galaxyPosU, vec3 coord) {\n    return coord*kG2U + galaxyPosU;\n}\n\n// Centré sur le centre de la galaxie\n// Echelle 1 pour la grille des etoiles\nvec3 universeToGalaxy(vec3 galaxyPosU, vec3 coord) {\n    return (coord-galaxyPosU)*kU2G;\n}\n\n\n\n/*\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n// Original interface\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    \n    return PrintValue( vStringCharCoords, fValue, fMaxDigits, fDecimalPlaces );\n}\n*/\n\n//-----------------------------------------------------\n// mainImage\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2. * uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    \n// Lecture de la configuration -------------------------\n        Config cfg = getConfig();\n\n\t\tbool isU = cfg.coordSystem == IN_UNIVERSE,\n\t\t\t isG = cfg.coordSystem == IN_GALAXY;\n\n// camera ----------------------------------------------\n\n    vec3 ro, rdcam, ta, up;\n    ro = cfg.ro_cam; \n    rdcam = cfg.rd_cam;\n\n    // Leger tangage\n    up = normalize(vec3(.1*cos(.1*iTime), .3*cos(.1*iTime), 1.));\n    vec3 ww = normalize( rdcam ),\n         uu = normalize( cross(ww,up) ),\n         vv = normalize( cross(uu,ww)),\n         rd = normalize( -p.x*uu + p.y*vv + 2.*ww );\n\n// - Est t on dans une galaxie ? --------------------------------     \n    vec3 galaxyId, galaxyPosU;\n    bool inGalaxy = isInGalaxy(isU ? ro : galaxyToUniverse(cfg.galaxy_pos, ro), galaxyId, galaxyPosU);\n       \n// - rendu des etoiles -----------------------------------\n\n    bool isHitStar = false;\n\tvec3 starPosG, starId = vec3(90);  \n\tvec4 star = vec4(0);\n    if (inGalaxy) {\n        // Le calcul se fait toujours en coordonnees Galaxie       \n        vec3 roG = isU ? universeToGalaxy(cfg.galaxy_pos, ro) : ro;    \n        float dStar = 9999.;\n        star = renderStarField(roG, rd, dStar, starId ); \n    \n#ifdef WITH_PLANETS    \n        vec3 id0, posSun;\n        if (cfg.targetType == STAR) {\n            posSun = cfg.target_pos;\n        } else if (cfg.targetType == PLANET) {\n\t        id0 = hash33(floor(cfg.target_pos));\n            posSun = floor(cfg.target_pos) + clamp(id0, STAR_RADIUS, 1.-STAR_RADIUS);\n        } else {\n        \tid0 = hash33(floor(roG));\n        \tposSun = floor(roG) + clamp(id0, STAR_RADIUS, 1.-STAR_RADIUS);\n        }\n            \n        float dPlanet = dStar;\n        vec3 planetPosG, planetId = vec3(90);  \n        vec4 planet = renderPlanetField(posSun, roG, rd, dPlanet, planetId);  \n        star = planet + (1.-planet.a) *sqrt(star)*star.a;\n#endif \n        \n#ifdef WITH_INTERGALACTIC_CLOUDS\n        vec4 clouds = renderIntergalacticClouds(roG, rd, dStar, vec4(0.5,0.4,0.16,0.7));\n        star = clouds + (1.-clouds.a) *sqrt(star)*star.a;\n#endif        \n        \n    }\n\n// - rendu des galaxies ----------------------------------\n\n    vec3 targetPosU, targetId = vec3(90);\n    // Le calcul se fait toujours en coordonnees univers\n\tvec3 roU = isG ? galaxyToUniverse(cfg.galaxy_pos, ro) : ro;\n\tvec4 colGalaxy = renderGalaxyField(roU, rd, targetPosU, targetId, isG);\n\n    star.rgb += colGalaxy.rgb* (1. - star.a);\n\n    col = star.rgb;\n    \n    \n //   float digit = PrintValue(fragCoord, iResolution.xy*vec2(.0,.7), vec2(20.), cfg.galaxy_pos.x, 8., 10.);\n //   digit += PrintValue(fragCoord, iResolution.xy*vec2(.0,.6), vec2(20.), cfg.galaxy_pos.y, 8., 10.);\n //   digit += PrintValue(fragCoord, iResolution.xy*vec2(.0,.5), vec2(20.), cfg.galaxy_pos.z, 8., 10.);\n //\tcol = mix(col, vec3(1,0,0), digit);\n    \n    fragColor = vec4((isU ? vec3(0.03,0.,.1)+col : col), 1.);\n \n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// in progress\n//#define WITH_PLANETS  \n\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI / 180.0);\nconst float MAX = 10000.0;\n\n// Unit = 10 UA\nconst int   GALAXY_FIELD_VOXEL_STEPS = 10;\nconst float GALAXY_FIELD_VOXEL_STEP_SIZE = 250000.; // 2,500,000 AL\nconst float GALAXY_RADIUS = .015;  // (% of 250000)  50,000 AL\n\nconst int   STAR_FIELD_VOXEL_STEPS = 13;\nconst float STAR_FIELD_VOXEL_STEP_SIZE = .5;  // 5AL \nconst float STAR_RADIUS = .01; // 2e-8 in true life !   // (% of 5)   1e-8\n\nconst float PLANET_FIELD_SCALE = 75.;\nconst int   PLANET_FIELD_VOXEL_STEPS = 10;\nconst float PLANET_FIELD_VOXEL_STEP_SIZE = .5;  // 5AL \nconst float PLANET_RADIUS = .04; \n\n\nconst float kU2G = GALAXY_FIELD_VOXEL_STEP_SIZE/STAR_FIELD_VOXEL_STEP_SIZE;\nconst float kG2U = STAR_FIELD_VOXEL_STEP_SIZE/GALAXY_FIELD_VOXEL_STEP_SIZE;\n\n\n\n\nfloat time;\n\nfloat keyPress(int ascii) {\n\treturn texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x ;\n}\n\n\n\n\n\n// Time spend traveling to clicked point\n#define TRAVEL_DELAY 4.\n\n#define IN_UNIVERSE 1.\n#define IN_GALAXY 2.\n#define IN_SOLAR_SYSTEM 3.\n\n#define MOVING     1.\n#define STATIONARY 2.\n\n#define NONE     0.\n#define GALAXY   1.\n#define STAR     2.\n#define PLANET   3.\n\nstruct Config {\n \tfloat movingMode;\n    float targetType;\n    float coordSystem;\n    float time;\n    vec3 ro_cam;\n    vec3 rd_cam;\n    vec3 target_pos;\n    vec3 galaxy_pos;\n    vec3 ro_from;\n    vec3 ro_to;\n    vec3 rd_from;\n    vec3 rd_to;\n};\n    \n    \n#define HASHSCALE1 .1031\nfloat hash(vec3 p3) {\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/*\nvec3 hash33( const in vec3 p) {\n    return fract(vec3(\n        sin(dot(p,    vec3(127.1,311.7,758.5453123))),\n        sin(dot(p.zyx,vec3(127.1,311.7,758.5453123))),\n        sin(dot(p.yxz,vec3(127.1,311.7,758.5453123))))*43758.5453123);\n}\n*/\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat distanceRayPoint(vec3 ro, vec3 rd, vec3 p, out float h) {\n    h = dot(p-ro,rd);\n    return length(p-ro-rd*h);\n}\n\n// Toujours en coordonnes Univers\nbool renderGalaxyField( in vec3 roU, in vec3 rd, out vec3 out_posU, out vec3 out_id) { \n    float d, dint;\n    vec3 ros = roU + rd*d,   \n\t\tpos = floor(ros),\n\t\tri = 1./rd,\n\t\trs = sign(rd),\n\t\tdis = (pos-ros + 0.5 + rs*0.5) * ri,\n\t\toffset, id, galaxyro;\n    \n    float pitch = 10./iResolution.x;\n    \n\tfor( int i=0; i<GALAXY_FIELD_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n        \n        // Si on intersectionne avec la boundingbox (sphere)\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if( dint > 0. && d < GALAXY_RADIUS*.5+dint*pitch ) {\n            galaxyro = pos+offset;\n            out_posU = galaxyro;\n        \tout_id = id;\n        \treturn true;\t    \n        }\n        \n\t\tvec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n    \n\treturn false;\n}\n\n\n\n// Toujours en coordonnes Galaxy\nbool renderStarField(vec3 galaxyId, in vec3 roG, in vec3 rd, out vec3 out_posG, out vec3 out_id) { \n    out_id = vec3(9);\n\n    float d, dint;\n    vec3 ros = roG + rd*d,\n\t \tpos = floor(ros),\n\t\tri = 1./rd,\n\t\trs = sign(rd),\n\t\tdis = (pos-ros + 0.5 + rs*0.5) * ri,\t\n\t\tmm, offset = vec3(0.), id, galaxyro;\n\n    float pitch = 10./iResolution.x;\n    \n\tfor( int i=0; i<STAR_FIELD_VOXEL_STEPS; i++ ) {\n        id = hash33(pos);\n        offset = clamp(id, STAR_RADIUS, 1.-STAR_RADIUS);\n        d = distanceRayPoint(ros, rd, pos+offset, dint);\n        if (dint > 0. && d < STAR_RADIUS*.5+dint*pitch) {\n\t        out_posG = pos+offset;\n   \t     \tout_id = id;\n        \treturn true;\n        }\n\t\tmm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\treturn false;\n}\n\n\n#ifdef WITH_PLANETS\n\nbool renderPlanetField(in vec3 sunPos, in vec3 roG, in vec3 rd, out vec3 out_posG, out vec3 out_id) { \n    out_id = vec3(9);\n    float scale = 50.;\n    roG -= sunPos;\n    roG *= PLANET_FIELD_SCALE;\n    roG.z+=.5;\n\n    float rayon = 3.;\n    float min_dist=0., max_dist=100.;\n    \n    vec4 col, sum = vec4(0);\n    float pitch = 10./iResolution.x;\n    float dint, d = max(0., (length(roG)-rayon)); //min_dist;\n    vec3 offset, id,\n        ros = roG + rd*d,  \n        pos = floor(ros),\n        ri = 1./rd,\n        rs = sign(rd),\n        dis = (pos-ros + .5 + rs*.5) * ri;\n\n    for( int i=0; i<PLANET_FIELD_VOXEL_STEPS; i++ ) {\n        if (length(pos) < rayon && abs(pos.z)<1. && hash(pos+sunPos)>.75) {\n            id = hash33(pos+sunPos);\n            offset = clamp(id,PLANET_RADIUS, 1.-PLANET_RADIUS);\n            offset.z = .5;\n            d = distanceRayPoint(ros, rd, pos+offset, dint);\n            if(dint > 0. && d<PLANET_RADIUS+dint*pitch ) {\n                vec3 pp = pos+offset;\n                pp.z-=.5;\n                out_posG = (pp/scale)+sunPos;\n                out_id = id;\n                return true;\n            }\n        }\n        vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n        dis += mm * rs * ri;\n        pos += mm * rs;\n\n    }\n    return false;\n}\n\n#endif\n    \n//--------------------------------------------------------------------\n// from iq shader Brick [https://www.shadertoy.com/view/MddGzf]\n//--------------------------------------------------------------------   \nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-.5-c) - .5; return -max(d.x,d.y); }\nvoid store( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ( isInside(fragCoord,re) > 0. ) ? va : fragColor;\n}\nvoid store( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = ( isInside(fragCoord,re) > 0. ) ? vec4(va,0.) : fragColor;\n}\n//--------------------------------------------------------------------\n\n\nvoid saveConfig(Config cfg, inout vec4 c, in vec2 f) {\n\tstore(vec2(0.,0.), vec4(cfg.movingMode, cfg.targetType, cfg.coordSystem, cfg.time), c, f);\n\tstore(vec2(1.,0.), cfg.ro_cam,    c, f);\n\tstore(vec2(2.,0.), cfg.rd_cam,    c, f);\n\tstore(vec2(3.,0.), cfg.target_pos,c, f);\n    store(vec2(4.,0.), cfg.galaxy_pos,c, f);\n\tstore(vec2(5.,0.), cfg.ro_from,   c, f);\n    store(vec2(6.,0.), cfg.ro_to,     c, f);\n    store(vec2(7.,0.), cfg.rd_from,   c, f);\n    store(vec2(8.,0.), cfg.rd_to,     c, f);\n}\n\n#define CONF(id)  texture(iChannel0, vec2(id+.5,.5)/ iChannelResolution[0].xy, -100.0).xyz;\n#define CONF4(id) texture(iChannel0, vec2(id+.5,.5)/ iChannelResolution[0].xy, -100.0);\nConfig getConfig() { \n    vec4 v1        = CONF4(0.);\n    Config cfg;\n    cfg.movingMode = v1.x > 1.5 ? STATIONARY : \n                     MOVING;\n    cfg.targetType = v1.y > 2.5 ? PLANET : \n    \t\t\t\t v1.y > 1.5 ? STAR:\n    \t\t\t\t v1.y > 0.5 ? GALAXY:\n    \t\t\t\t NONE;\n    cfg.coordSystem =v1.z > 2.5 ? IN_SOLAR_SYSTEM :\n    \t\t\t\t v1.z > 1.5 ? IN_GALAXY :\t\t\t\t\n                     IN_UNIVERSE;\n    cfg.time = v1.w;\n    cfg.ro_cam     = CONF(1.);\n    cfg.rd_cam     = CONF(2.);\n    cfg.target_pos = CONF(3.);\n    cfg.galaxy_pos = CONF(4.);\n    cfg.ro_from    = CONF(5.);\n    cfg.ro_to      = CONF(6.);\n    cfg.rd_from    = CONF(7.);\n    cfg.rd_to      = CONF(8.);\n    return cfg;\n}\n\n\nbool isInGalaxy(in vec3 roU, out vec3 out_GalaxyId, out vec3 out_GalaxyPosU) {\n    vec3 pos = floor(roU);\n    out_GalaxyId = hash33(pos);\n    \n    vec3 offset = clamp(out_GalaxyId, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n    out_GalaxyPosU = (pos+offset);\n    \n    return length(roU - out_GalaxyPosU) < GALAXY_RADIUS;\n}\n\n// Echelle 1 pour la grille des galaxies \nvec3 galaxyToUniverse(vec3 galaxyPosU, vec3 coord) {\n    return coord*kG2U + galaxyPosU;\n}\n\n// Centré sur le centre de la galaxie\n// Echelle 1 pour la grille des etoiles\nvec3 universeToGalaxy(vec3 galaxyPosU, vec3 coord) {\n    return (coord-galaxyPosU)*kU2G;\n}\n\nConfig galaxyToUniverse(vec3 galaxyPosU, Config cfg) {\n\tcfg.coordSystem = IN_UNIVERSE;\n    cfg.galaxy_pos = galaxyPosU;\n    cfg.ro_cam =  galaxyToUniverse(galaxyPosU, cfg.ro_cam);\n    cfg.ro_from = galaxyToUniverse(galaxyPosU, cfg.ro_from);\n    cfg.ro_to =   galaxyToUniverse(galaxyPosU, cfg.ro_to);\n    cfg.target_pos = galaxyToUniverse(galaxyPosU, cfg.target_pos);\n    return cfg;\n}\n\nConfig universeToGalaxy(vec3 galaxyPosU, Config cfg) {\n\tcfg.coordSystem = IN_GALAXY;\n    cfg.galaxy_pos = galaxyPosU;\n    cfg.ro_cam =  universeToGalaxy(galaxyPosU, cfg.ro_cam);\n    cfg.ro_from = universeToGalaxy(galaxyPosU, cfg.ro_from);\n    cfg.ro_to =   universeToGalaxy(galaxyPosU, cfg.ro_to);\n    cfg.target_pos = universeToGalaxy(galaxyPosU, cfg.target_pos);\n\treturn cfg;\n}\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\t\n    if (fragCoord.y > 0.5 || fragCoord.x > 10.) discard;\n            vec2 uv = iMouse.xy / iResolution.xy;\n        vec2 p = -1.0 + 2.0 * uv;\n        p.x *= iResolution.x/iResolution.y;\n\n// - Initialisation si besoin -------------------------\n    Config cfg;    \n    if(iFrame < 10) { \n        \n        cfg.rd_cam = normalize(vec3(1.,0.,0.));\n \n        vec3 pos = floor(vec3(10.));\n        vec3 id = hash33(pos),\n        offset = clamp(id, GALAXY_RADIUS, 1.-GALAXY_RADIUS);\n        cfg.ro_cam = pos + offset-.03*cfg.rd_cam;\n        vec3 mov = .03*cfg.rd_cam;\n        vec3 center = cfg.ro_cam + mov; \n        R(mov.yz, 1.);\n        R(mov.xy, 1.);\n        cfg.ro_cam = center - mov;\n        cfg.rd_cam = normalize(mov);\n        \n        cfg.movingMode = STATIONARY;\n        cfg.targetType = GALAXY;\n        cfg.coordSystem = IN_UNIVERSE;\n        cfg.time = iTime;\n        cfg.ro_from = cfg.ro_cam;\n        cfg.rd_from = cfg.rd_cam;\n        cfg.ro_to = cfg.ro_cam;\n        cfg.rd_to = cfg.rd_cam;\n        cfg.galaxy_pos = vec3(0);\n        cfg.target_pos = vec3(1);//center;\n\n    } else {\n\n// - Lecture de la configuration -----------------------\n        cfg = getConfig();\n\n\t\tbool isU = (cfg.coordSystem == IN_UNIVERSE),\n\t\t\t isG = (cfg.coordSystem == IN_GALAXY);\n\n        float time = iTime - cfg.time;\n        \n// - Camera --------------------------------------------        \n        vec3 ro, ta, rd_cam, up;\n        float smoth = smoothstep(0., TRAVEL_DELAY, time);\n        \n        if (cfg.movingMode == MOVING) { \n            ro =     mix(cfg.ro_from, cfg.ro_to, smoth);\n            rd_cam = mix(cfg.rd_from, cfg.rd_to, smoth);\n        } else {\n            // rotation autour de la cible\n            if (cfg.targetType != NONE) {                \n                vec3 mov = cfg.rd_to*(cfg.targetType==PLANET?(.03/PLANET_FIELD_SCALE):.03);\n                vec3 center = cfg.ro_to + mov; \n                R(mov.yz, .05*smoth*time);\n                R(mov.xy, .05*smoth*time);\n                ro = center - mov;\n                rd_cam = normalize(mov);\n            } else {\n                // ballade\n\t        \tro = cfg.ro_cam+.005*cfg.rd_cam;\n    \t        rd_cam = cfg.rd_cam;\n                R(rd_cam.yz, .002);\n            }\n        }\n        \n        // leger tangage\n        up = normalize(vec3(.1*cos(.1*iTime), .3*cos(.1*iTime), 1.));\n\n        vec3 ww = normalize(rd_cam),\n        \t uu = normalize(cross(ww,up)),\n        \t vv = normalize(cross(uu,ww)),\n        \t rd = normalize(-p.x*uu + p.y*vv + 2.*ww );\n\n// - Est t on dans une galaxie ? --------------------------------     \n        vec3 galaxyId, galaxyPosU;\n        bool inGalaxy = isInGalaxy(isU ? ro : galaxyToUniverse(cfg.galaxy_pos, ro), galaxyId, galaxyPosU);\n\n// - Recherche des clicks sur les objets\n        vec3 targetPosU, targetPosG, targetId;\n     \n        // - Click Galaxy Field ------------------------------------------\n\n        bool isHitGalaxy = false, isHitStar = false, isHitPlanet = false;\n\n        // Le calcul se fait toujours en coordonnees univers\n        vec3 roU = isG ? galaxyToUniverse(cfg.galaxy_pos, ro) : ro;\n        isHitGalaxy = renderGalaxyField( roU, rd, targetPosU, targetId);\n        if (isG && length(roU - targetPosU) > 3.) isHitGalaxy = false;\n        if (isHitGalaxy) {\n            targetPosG = universeToGalaxy(cfg.galaxy_pos,targetPosU);    \n        }\n// - Click Star Field ------------------------------------------\n\n        if (isG && !isHitGalaxy) {\n            // Le calcul se fait toujours en coordonnees Galaxie       \n            vec3 roG = ro;    \n            isHitStar = renderStarField(galaxyId, roG, rd, targetPosG, targetId );\n\t\t\tif (isHitStar) targetPosU = galaxyToUniverse(cfg.galaxy_pos,targetPosG);                 \n            \n#ifdef WITH_PLANETS\n            vec3 id0 = hash33(floor(roG));\n        \tvec3 posSun = floor(roG) + clamp(id0, STAR_RADIUS, 1.-STAR_RADIUS);            \n            isHitPlanet = renderPlanetField(posSun, roG, rd, targetPosG, targetId);\n            if (isHitPlanet) targetPosU = galaxyToUniverse(cfg.galaxy_pos,targetPosG);                 \n#endif\n        }\n        \n\n\n// - Generate new Configuration ----------------------------\n\n        cfg.ro_cam = ro;\n        cfg.rd_cam = rd_cam;\n\n        // On est en mode attente\n        if (cfg.movingMode == STATIONARY) { // stationary\n            \n            // click en cours\n            bool isClick = (iMouse.z != 0. && abs(iMouse.z - iMouse.x) < 3. && abs(iMouse.w - iMouse.y) <3.)\n                           || (keyPress(32) >.5);\n\n            if (isClick) {\n                // On va declancher un mouvement vers le point cliqué\n\t\t\t\tcfg.targetType = \n                    \tisHitGalaxy ? GALAXY :\n                \t\tisHitStar ? STAR :\n                \t\tisHitPlanet ? PLANET : NONE;\n                cfg.ro_from = ro;\n                cfg.ro_to = \n                    isHitGalaxy ? (isU ? targetPosU-(cfg.target_pos==vec3(1)||targetPosU==cfg.target_pos?0.:.03)*rd : targetPosG-.03*rd*kU2G) : // vers la cible\n                    isHitStar ? targetPosG-.03*rd :\n                \tisHitPlanet ? targetPosG-.06*rd/PLANET_FIELD_SCALE :\n                    ro + 3.*rd; // 3 unitees dans la direction du click\n\n                cfg.rd_from = rd_cam;\n                cfg.rd_to = rd;\n                cfg.movingMode = MOVING;            \n                cfg.time = iTime;\n                cfg.target_pos = isU ? targetPosU : targetPosG;\n                //((isHitGalaxy && targetId!=cfg.target_id)) ? targetId : isHitStar ? vec3(.5) : isHitPlanet ? vec3(9.) : vec3(0.);\n            }\n            \n        } else { \n          // En mouvement vers une cible\n            if (isU && inGalaxy) {\n                // On vient de rentrer dans une galaxie, on change de coordonnes pour garder la precision\n                cfg = universeToGalaxy(galaxyPosU, cfg);\n                \n            } else if (isG && !inGalaxy) {\n                if (length(ro)*kG2U > GALAXY_RADIUS*3.) {\n                // On vient de sortir de la galaxy, on change de systeme de coordonnes pour garder la precision   \n       \t\t\t\tcfg = galaxyToUniverse(galaxyPosU, cfg);\n                }\n            } \n          \n            if (iTime - cfg.time > TRAVEL_DELAY+1.) {\n                cfg.movingMode = STATIONARY;            \n                cfg.time = iTime;  \n            }\n        }\n\n    }\n    \n    \n// - Save new Configuration -----------------------------------\n    fragColor = vec4(0.);\n    saveConfig(cfg, fragColor, fragCoord);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XlcSDr","date":"1478909549","viewed":12608,"name":"Clickable Starfield","username":"iapafoto","description":"Click on Galaxies to go close. When close, click on it to enter inside. \nWhen inside, click on stars or clouds to go close or click another galaxy to go close to it.\nIf your computer is good enought you could try WITH_SUPERNOVA_REMNANT (by Duke)","likes":217,"published":1,"flags":48,"usePreview":1,"tags":["interactive","star","space","galaxy","cosmos","field","supernova","universe"],"hasliked":0,"parentid":"","parentname":""}}