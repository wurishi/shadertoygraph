{"ver":"0.1","info":{"id":"WtSyDW","date":"1594302729","viewed":462,"name":"Simple hexagonal truchet pattern","username":"mrange","description":"License CC0: Simple hexagonal truchet pattern\nNothing fancy, wanted a simple shader that illustrated simple hexagonal truchet patterns\n","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License CC0: Simple hexagonal truchet pattern\n//  Nothing fancy, wanted a simple shader that illustrated simple hexagonal truchet patterns\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat pcos(float a) {\n  return 0.5 + 0.5*cos(a);\n}\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rot120   = MROT(TAU/3.0);\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst vec2 n1       = normalize(sz.yx);\nconst vec2 n2       = n1*vec2(-1.0, 1.0);\nconst float radius  = 0.5/sqrt(3.0);\nconst vec2 off1     = 2.0*radius*n1;\nconst vec2 off2     = rot120*off1;\nconst vec2 off3     = rot120*off2;\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz*1.0, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(length(p1) < length(p2)));\n  vec2 n = p3 - p;\n  p = p3;\n\n  return round(n*2.0)*0.5;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat cell0(vec2 p) {\n  float d0 = abs(p.y);\n  float d1 = abs(dot(n1, p));\n  float d2 = abs(dot(n2, p));\n  float d3 = circle(p, radius);\n \n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  d = min(d, d3);\n   \n  return d;\n}\n\nfloat cell1(vec2 p) {\n  p = abs(p);\n  float d0 = circle(p-off1, radius); \n  return d0;\n}\n\nfloat cell2(vec2 p) {\n  float d0 = circle(p-off1, radius);\n  float d1 = circle(p-off2, radius);\n  float d2 = circle(p-off3, radius);\n   \n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n \n  return d;\n}\n\nfloat df(vec2 p, float scale, float width, inout vec2 nn) {\n   p /= scale;   \n   nn = hextile(p);\n   nn = round(nn);\n   float r1 = hash(nn);\n   float r2 = fract(23.0*r1);\n   rot(p, floor(r2*6.0)* TAU/6.0);\n   float d = 1E6;\n   if (r1 < 0.5) {\n     d = cell2(p);\n   } else if (r1 < 0.8) {\n     d = cell1(p);\n   } else {\n     d = cell0(p);\n   }\n   d *= scale;\n    \n   float d1 = abs(d) - width;\n   float d2 = abs(d) - width*2.0;\n   d2 = abs(d2) - width*0.5;\n   \n   return min(d1, d2);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord / iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n    \n  float aa = 4.0 / iResolution.y;\n  float tm = iTime*0.1;\n    \n  p += vec2(cos(tm), sin(tm*sqrt(0.5)));\n\n  vec2 nn = vec2(0.0);\n  float d = df(p, 0.25, 0.01, nn);\n\n  vec3 col = vec3(0.0);\n  \n  col += vec3(0.5 + 0.5*sin(nn*10.0), 1.0)*smoothstep(0.0, aa, -d);\n//  col += vec3(0.5, 0.3, 0.9)*pcos(500*d);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}