{"ver":"0.1","info":{"id":"MfKGRD","date":"1722091515","viewed":31,"name":"Penrose Multiverse","username":"MisterSirCode","description":"Kruskal-Szekeres Map of the Multiverse (If it's real), explorable by passing through layers of black holes / wormholes / whiteholes. FTL travel would allow backwards exploration too.\n\nThis version is called the \"Penrose Diagram\", based on Kerr black holes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["map","blackhole","coordinates","hole","penrose","black","schwarzschild","kruskal","szekeres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define line 0.01\n#define pl 14\n\nfloat pa[pl] = float[](0.0, 0.6, 1.6, 3.5, 7.0, 14.0, 30.0, 70.0, 170.0, 550.0, 2000.0, 10000.0, 100000.0, 1000000.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y * 2.0;\n    // sq2 is measured off the square root of the scaler... Ie: 2.0 ^.\n    \n    float uy = uv.y;\n    uv.y = uv.x; // Flip X and Y\n    uv.x = uy;\n    \n    vec2 ruv = uv * mat2(t45, -t45, t45, t45); // Rotate 45\n    float total; // Select Only Map\n    if (ruv.y <= mod(ruv.x, sq2) + sq2 - ruv.x && ruv.y >= mod(ruv.x, sq2) - 2.0 * sq2 - ruv.x) total = 1.0;\n    float middle; // Select Middles\n    if (ruv.y <= mod(ruv.x, sq2) - ruv.x && ruv.y + sq2 >= mod(ruv.x, sq2) - ruv.x) middle = 1.0;\n    float edges = total - middle;\n    if (uv.x < 0.0) {\n        ruv *= -1.0; // Mirror\n        float ty = ruv.y;\n        ruv.y = ruv.x; // Flip X and Y\n        ruv.x = ty;\n    }\n    float periodic; // Select Periodic / Every Other\n    periodic = (mod(ruv.x, sq2 * 2.0) - ruv.x) - (mod(ruv.x, sq2) - ruv.x);\n    float periodicAlt = total - periodic;\n    ruv.y += ruv.x - mod(ruv.x, sq2); // Modulate Height\n    ruv.x = mod(ruv.x, sq2); // Repeat X\n   \n    vec2 iuv = uv * -mat2(t45, -t45, t45, t45); // Rotate -45\n    iuv.y += sq2;\n    iuv.y += iuv.x - mod(iuv.x, sq2); // Modulate Height\n    iuv.x = mod(iuv.x, sq2); // Repeat X\n    \n    vec2 bound = horizons(uv);\n    float timelines = 1.0;\n    float spacelines = 1.0;\n    \n    \n    vec2 nuv = mix(ruv, iuv, middle); // Merged UVs\n    \n    for (int i = 0; i < pl; i++) { // Grab the Curves\n        if (middle > 0.5) {\n            timelines = min(timelines, pr(nuv, sq2, pa[i]));\n            timelines = min(timelines, pr(nuv, sq2, -pa[i]));\n            spacelines = min(spacelines, pt(nuv, sq2, pa[i]));\n            spacelines = min(spacelines, pt(nuv, sq2, -pa[i]));\n        } else {\n            timelines = min(timelines, pt(nuv, sq2, pa[i]));\n            timelines = min(timelines, pt(nuv, sq2, -pa[i]));\n            spacelines = min(spacelines, pr(nuv, sq2, pa[i]));\n            spacelines = min(spacelines, pr(nuv, sq2, -pa[i]));\n        }\n    }\n    \n    // All just stylization past this point.\n    float border = smoothstep(0.0, line, bound.y);\n    float timecurves = smoothstep(0.0, line, timelines);\n    float spacecurves = smoothstep(0.0, line, spacelines);\n    \n    float lightdye = -min(timecurves, spacecurves) + 1.0;\n    vec3 col = vec3(0);\n    if (middle * periodic > 0.5) {\n        col = vec3(0);\n        col += lightdye;\n        col.yz *= timecurves;\n        col.xy *= spacecurves;\n    } else if (edges * periodicAlt > 0.5) {\n        col = vec3(0.5);\n        col += lightdye;\n        col.yz *= timecurves;\n        col.xy *= spacecurves;\n    } else if (edges * periodic > 0.5) {\n        col = vec3(0.2);\n        col += lightdye;\n        col.yz *= timecurves;\n        col.xz *= spacecurves;\n        col.z += (-spacecurves + 1.0) * 0.5;\n        if (abs(uv.x) >= 1.0) {\n            col = vec3(0.05);\n            col *= vec3(min(timecurves, spacecurves) + 0.5);\n        }\n    } else if (total > 0.5) {\n        col = vec3(1);\n        col.yz *= timecurves;\n        col.xy *= spacecurves;\n    }\n    \n    fragColor = vec4(col * border, 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float t45 = 0.707106781187;\nfloat sq2 = 1.41421356237;\n\nvec2 horizons(vec2 uv) {\n    float horizontal = abs(abs(uv.x) - 1.0) - 1.0 + abs(uv.y);\n    float infinite = abs(abs(abs(uv.x) - 1.0) - 1.0 + abs(mod(uv.y + 1.0, 2.0) - 1.0));\n    return vec2(horizontal, infinite);\n}\n\nfloat penrose(float v, float s, float p) {\n    if (0.0 <= v && v <= s) {\n        return (s * (s - v)) / (p * v + s);\n    } else return v - s;\n}\n\nfloat pt(vec2 uv, float s, float p) {\n    if (0.0 <= uv.x && uv.x <= s && 0.0 <= uv.y && uv.y <= s) {\n        if (p < 0.0)\n            return min(abs(-penrose(-uv.x + s, s, -p) + s - uv.y), abs(-penrose(-uv.y + s, s, -p) + s - uv.x));\n        else\n            return min(abs(penrose(uv.x, s, p) - uv.y), abs(penrose(uv.y, s, p) - uv.x));\n    } else return 1.0;\n}\n\nfloat pr(vec2 uv, float s, float p) {\n    if (0.0 <= uv.x && uv.x <= s && 0.0 <= uv.y && uv.y <= s) {\n        if (p < 0.0)\n            return min(abs(penrose(-uv.x + s, s, -p) - uv.y), abs(penrose(-uv.y + s, s, -p) - uv.x));\n        else\n            return min(abs(-penrose(uv.x, s, p) + s - uv.y), abs(-penrose(uv.y, s, p) + s - uv.x));\n    } else return 1.0;\n}","name":"Common","description":"","type":"common"}]}