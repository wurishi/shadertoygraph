{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":2,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//// input\n// keys\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\nint kRed = 49;\nint kGreen = 50;\nint kBlue = 51;\n\n//bool hit = false;\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKeyBool( int key, bool toggle )\n{\n    //return false;\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat ReadKeyFloat( int key, bool toggle )\n{\n    //return 0.0;\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn step(.5,keyVal);\n}\n\n\n//// convert screen coords to -asp to +asp for x, -1 to +1 for y, asp = aspect ratio\n// normalized device coords\nvec2 ndc(vec2 p)\n{\n    p *= 2.0/iResolution.y;\n    p += vec2(-iResolution.x/iResolution.y,-1.0);\n\treturn p;\n}\n\n// generate a 2d rotation matrix\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\n//// raytrace plane\n// return color of plane at xyz, this plane is at y = 0\nvec3 planeColor(vec3 loc,bool pc)\n{\n    vec2 loct = loc.xz * vec2(.1,-.1);\n    float lodBias = -.2;\n    vec3 ret3 = texture(iChannel2,loct,lodBias).xyz;\n    //pc = true;\n    if (pc) {\n        if (loc.x >= 0.0)\n        \tret3.r += .25;\n    \tif (loc.z >= 0.0)\n        \tret3.g += .25;\n        if (fract(loc.x*.05) >= .5)\n            ret3.r -= .15;\n        if (fract(loc.z*.05) >= .5)\n            ret3.g -= .15;\n    }\n\treturn ret3;\n}\n\n\n//// sky and plane\nvec3 skyPlane(vec3 rs,vec3 rd,bool planeaxis) // unnormalized direction\n{\n    \n// sky color\n    vec3 skycolor = vec3(0.0,0.0,1.0) - vec3(0.0,0.0,rd.y);\n    \n    // plane color\n    float t = -rs.y/rd.y;\n    vec3 isect = rs + rd*t;\n    //planeaxis = false;\n    vec3 planecolor = planeColor(isect,planeaxis);\n    \n    vec3 skyplanecolor;\n    if (rd.y >= 0.0)\n        skyplanecolor = skycolor;\n    else\n        skyplanecolor = planecolor;\n    return clamp(skyplanecolor,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0)); \n\n   // return vec3(.5,.5,.75);\n}\n\n\n//// raymarch\nvec3 sceneCol;\n\nfloat sdSphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p,vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// h.x = radius h.y = height\nfloat sdCappedCylinder(vec3 p,vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// c.xy is the position if xz, c.z is the radius\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// n.w is the distance from origin to the plane P*N = D\nfloat sdPlane(vec3 p,vec4 n)\n{\n  // n.xyz must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// CSG Union d1 U d2\nfloat opU(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// CSG Intersection d1 ^ d2\nfloat opI(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// CSG Subtract d1 - d2\nfloat opS(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\nfloat scene1(vec3 pr)\n{\n    //vec3 pr = p;\n    //pr.x += 4.0;\n    //pr.xy *= rot(iTime*.5);\n    pr.xz *= rot(1.57);\n    sceneCol = fract(pr*8.0);\n    float d1 = sdBox(pr,vec3(.5,1.0,1.5));\n    //float d1 = sdBox(pr,vec3(.25,.5,.75));\n    //float d2 = sdSphere(p,1.0); // p or pr, it's a sphere\n    pr.xy *= rot(1.57);\n\tfloat d2 = sdCappedCylinder(pr,vec2(.50,12));\n    //float d3 = sdTorus(pr,vec2(1.0,.25));\n    //float d4 = sdCappedCylinder(pr,vec2(.25,1.0));\n    //return opU(d1,d2);\n    //return opI(d1,d2);\n    return opS(d1,d2);\n    //return opS(d2,d1);\n    //return d1;\n    //return d2;\n    //return d3;\n    //return d4;\n}\n\nfloat opRep_scene1(vec3 p,vec3 c)\n{\n    vec3 q;\n\tq = mod(p+.5*c,c)-.5*c;\n    return scene1(q);\n}\n\nfloat opRepLimit_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat sceneT(vec3 p)\n{\n    float d4 = sdTorus(p,vec2(.125,.03125));\n    return d4;\n}\n\nfloat opRep_sceneT(vec3 p,vec3 c)\n{\n    vec3 q;\n\tq = mod(p+.5*c,c)-.5*c;\n    return sceneT(q);\n}\n\nfloat opRepLimit_sceneT(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return sceneT(q);\n}\n\nfloat opRepLimitCenter_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 lm1 = lim-vec3(1.0);\n    p += c*.5*lm1;\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat scene2(vec3 p)\n{\n\treturn opRep_scene1(p,vec3(10.0));\n}\n\nfloat scene4(vec3 p)\n{\n\tfloat rs1 = opRepLimitCenter_scene1(p,vec3(10.0),vec3(9.0));\n    //float pn = sdPlane(p,vec4(0.0,0.0,-1.0,10.0));\n    //float pn = sdPlane(p,vec4(.7071,0.,-.7071,7.071));\n    //return opU(rs1,pn);\n    return rs1;\n}\n\nfloat scene5(vec3 p)\n{\n    vec3 torusmove = .7*sin(vec3(iTime,iTime*1.1,iTime*1.3));\n    float d3 = sdSphere(p + vec3(-1,-.75,1.0),.25); // p or pr, it's a sphere\n    vec3 pr;\n    pr.xz = p.xz * rot(1.57);\n    pr.y = p.y;\n    sceneCol = fract(pr*8.0);\n    float d1 = sdBox(pr,vec3(.5,1.0,1.5));\n    pr.xy *= rot(1.57);\n    // +Y+Z+X\n\tfloat d2 = sdCappedCylinder(pr,vec2(.50,12));\n    pr -= vec3(.75,1.0,1.0)+torusmove;\n    pr.xy *= rot(iTime*.2);\n   \t//pr.xz *= rot(iTime*.5);\n    //float d4 = sdTorus(pr,vec2(.5,.125));\n    float d4 = opRep_sceneT(pr,vec3(1.));\n//    float d4 = sdTorus(pr + vec3(-.75,-1.5,-1.0)+vec3(0.0,torusmove,0.0),vec2(.5,.125));\n    return opU(d3,opU(d4,opS(d1,d2)));\n    //return sdCylinder(pr,vec3(1.0));\n}\n\nfloat scene(vec3 p)\n{\n\t//float d = scene1(p);\n    //float d = scene2(p);\n    //float d = scene4(p);\n    float d = scene5(p);\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    const float eps = .001;\n    float d0x = scene(vec3(p.x - eps,p.yz));\n    float d1x = scene(vec3(p.x + eps,p.yz));\n    float d0y = scene(vec3(p.x,p.y - eps,p.z));\n    float d1y = scene(vec3(p.x,p.y + eps,p.z));\n    float d0z = scene(vec3(p.xy,p.z - eps));\n    float d1z = scene(vec3(p.xy,p.z + eps));\n    //return vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(.5/eps);\n    //return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z)*(2.5/eps));\n    return normalize(vec3(d1x-d0x,d1y-d0y,d1z-d0z));\n    //return vec3(1.0,0.0,0.0);\n}\n    \nvec3 getTex(vec3 p)\n{\n\tp = fract(p);\n    //p.xy *= rot(iTime*.5);\n    //p.xz *= rot(iTime*.25);\n    return p;\n    //return vec3(1.0);\n}\n    \n/*float getNormalZ(vec3 p)\n{\n    const float eps = .0001;\n    float d0z = scene(vec3(p.xy,p.z + eps));\n    float d1z = scene(vec3(p.xy,p.z - eps));\n    //return (d1 - d0)/eps;\n    return (d1z-d0z)/eps;\n}\n*/  \n\n// very simple ambient occlusion\nfloat getAO(vec3 rs,vec3 rd)\n{\n    // move away along the normal\n    float d = .3;\n    float k = 1.0;\n    float ret = 1.0;\n    for (int i = 1;i<5;++i) {\n        float fi = float(i);\n        k *= .5;\n        float distBack = scene(rs + rd*(d*fi));\n        ret -= k*(fi*d - distBack);\n    }\n    return ret;\n    //return 1.0;\n    //return distBack/k;\n    //return k/distBack;\n}\n\nvec4 march(vec3 rs,vec3 rd) // ret.w > 0 means hit\n{\n    const float conserve = .87; // compensate for errors in distance function esp. rotate box repeat\n    const int steps = 180;\n    float eps = .001;\n    float toobig = 1000.0;\n\tvec4 col = vec4(0.0,0.0,0.0,0.0);\n    //hit = false;\n    //hit = true;\n    for (int i=0;i<steps;++i) {\n        float d = scene(rs);\n        if (d > toobig) { // bail early if clearly can't hit anything\n            //hit = false;\n            return col;\n        }\n        if (d < eps) {\n            if (rs.y >= 0.0) { // hit above ground\n                vec3 norm = getNormal(rs);\n \t\t\t\t// normal color, very simple lighting .5 ambient, .5 directional\n \t\t\t\t// normal in opposite direction of light gets the light\n                //col += max(-norm.x,0.0)*.5+.5; // dir +1x\n                //col += max(norm.y,0.0)*.5+.5; // dir -1y\n                col += max(-norm.z,0.0)*.5+.5; // dir +1z\n                //col += -norm.z; // dir +1z, no ambient all directional\n                \n                //col += sceneCol;\n                //col += getTex(rs); // texture color\n                //col += norm*.5 + vec3(.5); // normal color 0 to 1\n                //col += norm; // raw normal color -1 to 1\n    \t\t\t//col += float(i)*(10.0/256.0); // brighter if more iterations\n                float ao = getAO(rs,norm);\n                col.xyz *= ao;\n                col.w = 1.0;\n            }\n           // break;\n            //hit = true;\n            return col;\n        }\n        rs += rd*d*conserve; // compensate for the slight error from rotating boxes distance modulo function\n    }\n\t//hit = true;\n    return col;\n}\n\n//// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool roll = ReadKeyBool(k1,true);\n    bool planeaxis = !ReadKeyBool(k2,true);\n    bool movexy = ReadKeyBool(k3,true);\n\n    // ndc\n    vec2 pos = ndc(fragCoord.xy);\n    vec2 mouse;// = vec2(0.0,0.0);\n    \n    if (iMouse.x == 0.0) // hack for mouse not yet clicked\n        mouse = vec2(0.0,0.0);\n    else\n    \tmouse = ndc(iMouse.xy);\n    \n    // keyboard color, for circle (press 1,2,3)\n    vec3 keycolor = vec3(ReadKeyFloat(kRed,true),\n             ReadKeyFloat(kGreen,true),\n             ReadKeyFloat(kBlue,true));\n    \n    //// camera\n    const float zoom = 2.0;\n    // make a ray, left handed coords\n    vec3 rs; // ray start\n    vec3 rd = vec3(pos,1.0); // ray direction to the pixel\n    vec3 nrd;\n    vec3 rc = vec3(0.0,0.0,1.0); // ray direction from center of camera\n    // zoom factor\n    rd.xy /= zoom;\n    vec3 cd = vec3(0.0,0.0,1.0); // camera direction (center, look at)\n    if (movexy) { // mouse move camera in xy, always facing forward\n\t    rs = vec3(0.0,6.0,-5.0) + vec3(mouse*5.99,0.0); // ray start\n        nrd = normalize(rd);\n    } else { // mouse rotates camera 2 different ways\n\t    rs = vec3(0.0,.4,0.0); // ray start\n        rd.yz *= rot(mouse.y*3.14 ); // pitch\n        rc.yz *= rot(mouse.y*3.14 ); // pitch\n        if (roll) {\n            rd.xy *= rot(mouse.x*3.14 ); // roll\n            rc.xy *= rot(mouse.x*3.14 ); // roll\n        } else {\n            rd.xz *= rot(mouse.x*3.14 ); // yaw\n            rc.xz *= rot(mouse.x*3.14 ); // yaw\n        }\n        nrd = normalize(rd); // normalized for the marching, unnormalized for the sky gradient\n        rs += rc * -4.0;\n    }\n    \n\n    \n    // cursor color\n    vec3 circlecolor = keycolor;\n    // is inside circle\n    vec2 del =  pos - mouse;\n    float d2 = dot(del,del);\n    float rad = 1.0/30.0;\n    bool iscursor = d2<rad*rad;\n    \n    // sky plane color\n    //rs -= nrd * 2.3;\n    //rs.z += nrd.z;\n    //planeaxis = false;\n    vec3 skyplanecolor = skyPlane(rs,rd,planeaxis); // do this with an unnormalized ray\n   \n    // march color\n    //bool hit; // did hit something\n    vec4 marchcol = march(rs,nrd);\n    \n    //hit = true;\n    // put it all together\n    vec3 comp;\n    if (iscursor)\n        comp = circlecolor;\n    else\n\t\t//comp = marchcol.xyz;\n        //comp = marchcol.www;\n    \t//comp = skyplanecolor;\n    \t//comp = mix(marchcol.xyz,skyplanecolor,marchcol.w);\n    \tcomp = mix(skyplanecolor,marchcol.xyz,marchcol.w);\n    \t//comp = skyplanecolor + marchcol.www;\n\tfragColor = vec4(comp,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2XWh","date":"1411620668","viewed":155,"name":"ambient occlusion","username":"rickiters","description":"ambient occulusion","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["ambientocculusion"],"hasliked":0,"parentid":"","parentname":""}}