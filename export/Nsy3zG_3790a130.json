{"ver":"0.1","info":{"id":"Nsy3zG","date":"1633421627","viewed":149,"name":"Hammer","username":"SciKot","description":"SDF and PBR practice","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 3 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat dSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0; // + 0.03 * sin(20.0*p.x + iTime);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat dBox ( vec3 p, vec3 b )\n{\n\treturn length ( max ( abs ( p ) - b, 0.0 ) );\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//sds капсулы, где a и b координаты концов\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdPulseCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - (r + 0.007 * sin(15.0*p.y + (iTime) * 5.) * (p.y + 2.));\n\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );\n}\n\nfloat length8 ( in vec3 p )\n{\n    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );\n}\n\n\nfloat dTorus ( vec3 p, vec2 t )\n{\n\tvec2\tq = vec2 ( length ( p.xz ) - t.x, p.y );\n\t\n\treturn length ( q ) - t.y;\n}\n\n//?\nfloat smin ( float a, float b, float k )\n{\n\tfloat res = exp ( -k*a ) + exp ( -k*b );\n\treturn -log ( res ) / k;\n}\n\n\n\n\n//задаем геометрию\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   //перемножаем матрицу вращения и ветор к пикселю\n   vec3 q = m * p;\n   \n    \n    //return dSphere ( q, vec3 ( 0, 0, 0 ) );\n    //return dTorus ( q - vec3 ( 0, -1.5, 0 ), vec2 ( 0.1, 0.05) );\n    //return max(  dBox ( q, vec3 ( 2, 0.5, 0.5)), - dBox ( q + vec3( 0, 0.4, 0 ), vec3 ( 0.4, 0.4, 2.0 )));\n    //return max( dBox ( q, vec3 ( 2.0, 0.5, 0.5)), - dSphere ( q, vec3 ( 1, 0, 0 )));\n\t//return smin ( dTorus ( q, vec2 ( 0.74, 0.4 ) ),  dSphere ( q, vec3 ( 1, 0, 0 ) ), 7.0 );\n    //return sdRoundBox( q, vec3 ( 1, 0.25, 0.25), 0.05 );\n    //return sdCapsule( q, vec3 ( 0, -2, 0 ), vec3 ( 0, -0.15, 0 ), 0.05 );\n    //return max(abs(sdRoundBox( q, vec3 ( 1.5, 3, 1), 0.05 )) - 0.05, q.z);\n    return min(\n             max(\n                smin(sdRoundBox( q - vec3 ( 0, 1, 0.3 ), vec3 ( 0.5, 0.2, 0.2), 0.05 ),\n                     sdPulseCapsule( q, vec3 ( 0, -2, 0.3 ), vec3 ( 0, 0.85, 0.3 ), 0.07 ), 15.0 ),\n             - dTorus ( q - vec3 ( 0, -1.9, 0.3 ), vec2 ( 0.1, 0.05) )),\n           max(abs(abs(abs(sdRoundBox( q - vec3 ( 0, 0, 0.8 ), vec3 ( 1.5, 3.0, 1), 0.05 ))\n               - 0.08) - 0.04) - 0.02, q.z - 0.6));\n\n}\n\n//функция, которая отслеживает пересек ли луч (который проведен от точки from по направлению dir)\n//геометрию, заданную в sdf\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\t//зададим точку с который начнем иттерироваться sdf_ами\n    vec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t//если появляются некраевые эффекты протыкания поверхности это может значить, что при рассчете sdf\n        //мы выскакиваем за поверхность более чем на эпсилон. в этом случае в следующем выражении следует\n        //добавить понижающий коэффициент\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\n//находим нормаль к заданной sdf_ом геометрии\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nconst float roughness = 0.6;\nconst vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );\nconst vec3  clr  = vec3 ( 0.9, 0.7, 0.7 );\nconst float gamma = 2.2;\nconst float pi    = 3.1415926;\nconst float FDiel = 0.04;\t\t// Fresnel for dielectrics\n\nvec3 fresnel ( in vec3 f0, in float product )\n{\n\tproduct = clamp ( product, 0.0, 1.0 );\t\t// saturate\n\t\n\treturn mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );\n}\n\nfloat D_blinn(in float roughness, in float NdH)\n{\n    float m = roughness * roughness;\n    float m2 = m * m;\n    float n = 2.0 / m2 - 2.0;\n    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);\n}\n\nfloat D_beckmann ( in float roughness, in float NdH )\n{\n\tfloat m    = roughness * roughness;\n\tfloat m2   = m * m;\n\tfloat NdH2 = NdH * NdH;\n\t\n\treturn exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);\n}\n\nfloat D_GGX ( in float roughness, in float NdH )\n{\n\tfloat m  = roughness * roughness;\n\tfloat m2 = m * m;\n\tfloat NdH2 = NdH * NdH;\n\tfloat d  = (m2 - 1.0) * NdH2 + 1.0;\n\t\n\treturn m2 / (pi * d * d);\n}\n\nfloat G_schlick ( in float roughness, in float nv, in float nl )\n{\n    float k = roughness * roughness * 0.5;\n    float V = nv * (1.0 - k) + k;\n    float L = nl * (1.0 - k) + k;\n\t\n    return 0.25 / (V * L);\n}\n\nfloat G_neumann ( in float nl, in float nv )\n{\n\treturn nl * nv / max ( nl, nv );\n}\n\nfloat G_klemen ( in float nl, in float nv, in float vh )\n{\n\treturn nl * nv / (vh * vh );\n}\n\nfloat G_default ( in float nl, in float nh, in float nv, in float vh )\n{\n\treturn min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );\n}\n\nvec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )\n{\n    vec3  h    = normalize ( l + v );\n\tfloat nh   = dot (n, h);\n\tfloat nv   = dot (n, v);\n\tfloat nl   = dot (n, l);\n\tfloat vh   = dot (v, h);\n\t\n\t\t\t// compute Beckman\n   \tfloat d = D_beckmann ( roughness, nh );\n\n            // compute Fresnel\n    vec3 f = fresnel ( r0, nv );\n\t\n            // default G\n    float g = G_default ( nl, nh, nv, vh );\n\t\n\t\t\t// resulting color\n\tvec3  ct   = f*(0.25 * d * g / nv);\n\tfloat diff = max(nl, 0.0);\n\tfloat ks   = 0.5;\n\n\treturn vec4 ( diff * clr + ks * ct, 1.0 );\n}\n\nconst vec3 lum = vec3(0.2126, 0.7152, 0.0722);\n\n//возвращает яркость путем умножения цвета текстуры на коэфф восприимчивости глаза к цветам rgb(lum)\nfloat height(in vec2 tx)\n{\n    return dot(texture(iChannel0, tx).rgb, lum);\n}\n\n//получаем карту высот?\nvec3 bump (in vec2 tx) \n{\n    float v = height (tx);\n    float vx = height(vec2(tx.x + 0.01, tx.y));\n    float vy = height(vec2(tx.x, tx.y + 0.01));\n    \n    return normalize(vec3(vx - v, vy - v, 0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        // Normalized pixel coordinates (from 0 to 1)\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);\n    //вводим коэффициент чтобы избежать растяжения и управления углом обзора(отдаление камеры)\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    //переводим коорд пикселей фрагмента к виду с центром 0 0 \n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n    //получаем единичный вектор из глаза в пиксель\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0, 0, 0, 1 );\n    vec4 color1 = vec4 ( 0, 0, 0, 1 );\n    vec4 color2 = vec4 ( 0, 0, 0, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\t//направление на источник света\n        vec3  l  = normalize        ( light - p );\n        //направление на камеру\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n        \n        //n = bump( p.xy );\n        \n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n        \n        vec3 r = reflect (-v, n);\n        \n        color = texture( iChannel1, r);\n        \n        color *= cookTorrance ( p, n, l, v );\n        //n = bump( p.xy );\n        //color *= cookTorrance ( p, n, l, v );\n\n\t} \n\n        // Output to screen\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}