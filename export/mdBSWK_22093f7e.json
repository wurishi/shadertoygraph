{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define T iTime*TIMESPEED\n\nfloat rays(vec2 uv, vec2 offset, float seed, float r, float vdotl){\n    vec2 pos = uv - offset;\n    float ang = atan(pos.x,pos.y);\n    float len = length(pos);\n    float rays = S(.15,.5,noise(vec2(ang*16.,len*5.+seed*1.1))\n    *pow(1.-len,2.)*S(4.*tanFOV,.0,len)*S(0.08*r,.2,len));\n    rays += S(.15,.5,noise(vec2(ang*16.+10.,len*9.+seed*0.9))\n    *pow(1.-len,2.)*S(4.*tanFOV,.0,len)*S(0.08*r,.2,len));\n    \n    float rad =max(vdotl*2.-1.,0.);\n    return rays*smoothstep(r,.0,len);\n}\nfloat lineray(vec2 uv, vec2 offset, float seed, float radius){\n    vec2 p = uv -offset;\n    p *= rot(2.*PI*seed);\n    float l = min(length(p),1.);\n    float r = pow(1.-l,4.);\n    float ray = smoothstep(.01*r,.005*r,abs(p.x));\n    ray *= smoothstep(0.1,.2,l)*smoothstep(2.*radius,.0,l);\n    return ray;\n}\n\n//Lens flare effect based on it shader https://www.shadertoy.com/view/slVXDW\nfloat sdCircle( in vec2 p, in float r ){\n    return length(p) - r;\n}\n\nfloat sdHexagon( in vec2 p, in float r ){\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat star_burst( in vec2 p, in vec2 center ){\n    float c0 = 0.1, c1 = 3.0, c2 = 8.0, c3 = 12.0, \n          c4 = 2.0, c5 = 6.2, c6 = 4.0, c7 = 0.1, c8 = 6.2;\n    \n    float t  = dot( center, vec2( 0.25 ) );\n    float l  = length( p );\n    float l2 = pow( l, c0 );\n    float n0 = noise( vec2( atan(  p.y,  p.x ) * c1, l2 ) * c2);\n    float n1 = noise( vec2( atan( -p.y, -p.x ) * c1, l2 ) * c2);\n    float n  = pow( max( n0, n1 ), c3 ) * pow( saturate( 1.0 - l * c4 ), c5 );\n    n += pow( saturate( 1.0 - ( l * c6 - c7 ) ), c8 );// glare\n    return n;\n}\nvec3 star_burst3( in vec2 p, in vec2 center ){\n    p -= center;\n    vec3 col;\n    col.r = star_burst( p * 0.9, center );\n    col.g = star_burst( p * 1.0, center );\n    col.b = star_burst( p * 1.1, center );\n    return col;// * vec3( 2.0, 1.5, 1.0 );\n}\nfloat halo( in vec2 p, in vec2 center, in float r, in float offset ){\n    float c0 = 0.5, c1 = 32.0, c2 = 12.0, c3 = 2.0, c4 = 0.7,\n          c5 = 4.0, c6 = 5.2, c7 = 0.5, c8 = 1.5, c9 = 0.25;\n\n    float t  = dot( center, vec2( c9 ) );\n    float l  = length( p );\n    float l1 = abs( l - r );\n    float l2 = pow( l, c0 );\n    float n0 = noise( vec2( atan(  p.y,  p.x ) * c1, l2 ) * c2);\n    float n1 = noise( vec2( atan( -p.y, -p.x ) * c1, l2 ) * c2);\n    float n  = mix( pow( max( n0, n1 ), c3 ), 1.0, c4 ) * pow( saturate( 1.0 - l1 * c5 ), c6 );\n    return n * 0.2 * saturate( pow(\n        1.0 - saturate( pow( length( center ), c7 ) ),\n        ( length( p - center ) / r ) * c8\n    ) );\n}\nvec3 ghost3( in vec2 p, in vec2 center, float focus, in float r, in float offset ){\n    float shape_factor = 0.4;   // 0.0 == Circular aperture(like digital camera)\n                                // 1.0 == Six blades aperture(like old camera)\n    p -= center * offset;\n    vec2 p2 = p*rot(0.25);\n    float d0 = mix( sdCircle( p2 * 0.85, r ), sdHexagon( p2 * 0.85, r ), shape_factor );\n    float d1 = mix( sdCircle( p2,        r ), sdHexagon( p2,        r ), shape_factor );\n    float d2 = mix( sdCircle( p2 * 1.15, r ), sdHexagon( p2 * 1.15, r ), shape_factor );\n    return mix(\n        vec3(\n            halo( p * 1.05, center, r, offset ),\n            halo( p * 1.0,  center, r, offset ),\n            halo( p * 0.95, center, r, offset )\n        ) * vec3( 2.0, 1.5, 1.0 ),\n        pow( saturate( 1.0 - vec3( d0, d1, d2 ) ), vec3( 200. ) ),\n        focus\n    );\n}\n//\nfloat light2dPoint(mat3 vm, vec2 uv){\n    vec3 iv = invViewMatrix(vm)*LIGHTDIR;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 q = (iv.xy/iv.z*vec2(1.,aspect)*1.13)*.5+.5;\n    float p = texture(iChannel0, q).a*.1;\n    vec2 texel = 1./vec2(textureSize(iChannel0, 0)).xy*5.;\n    texel = vec2(1.)/ iResolution.xy*10.;\n    \n    p += texture(iChannel0, q+texel).a*.1;\n    p += texture(iChannel0, q-texel).a*.1;\n    p += texture(iChannel0, q+vec2(texel.x, -texel.y)).a*.1;\n    p += texture(iChannel0, q+vec2(-texel.x, texel.y)).a*.1;\n    return p/10.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = mouse(m,iTime);\n    \n    vec3 ro = rayOrigin(m);\n    mat3 vm = viewModelMatrix(ro);\n    vec3 rd = vec3(uv*tanFOV,1.);    \n    rd = normalize(vm*rd);\n    vec3 lightDir = LIGHTDIR;\n    \n    float vdotl = dot(rd, LIGHTDIR); // angle btw view dir and light dir\n    float cdotl = dot(-ro, LIGHTDIR); // angle btw camera and light dir\n    vec4 tex = texture(iChannel0, q);\n    vec3 col = tex.rgb;\n    \n    // abberation\n    float am =pow(abs(uv.x),3.);\n    col.r = texture(iChannel0, q+.01*am).r;\n    col.b = texture(iChannel0, q-.01*am).b;\n    \n    //lens flare\n    float volL = pow(vdotl,4.);\n    vec3 iv = invViewMatrix(vm)*LIGHTDIR;\n    iv.xy /= iv.z;\n    float zTest = light2dPoint(vm, uv);\n    if(zTest <= 0.99)\n    {\n        float zfade = clamp(1.-zTest, 0.,1.);\n        float clmpback = max(rd.z,0.);\n        col += SKYCOLORHORRIZON.rgb*pow(max(vdotl,0.),16.)*.14*zfade;\n        float radius = zfade;\n        float seed = iv.x*2.;\n        col.r += rays(uv,iv.xy, seed, radius,vdotl)*clmpback*.333;\n        uv += vec2(.01,0.);\n        col.g += rays(uv,iv.xy, seed, radius,vdotl)*clmpback*.333;\n        uv -= vec2(.02,0.);\n        col.b += rays(uv,iv.xy, seed, radius,vdotl)*clmpback*.333;\n        col.r += lineray(uv,iv.xy, -iv.x*.05+.25, radius)*clmpback*.2;\n        uv += vec2(.002,0.);\n        col.g += lineray(uv,iv.xy, -iv.x*.05+.25, radius)*clmpback*.2;\n        uv -= vec2(.004,0.);\n        col.b += lineray(uv,iv.xy, -iv.x*.05+.25, radius)*clmpback*.2;\n        \n        col += ghost3(uv,iv.xy,.0,.15,1.)*zfade*clmpback;// halo\n        col += ghost3(uv,iv.xy,.0,.5,.85/1.5)*.15*zfade*clmpback;// halo\n        col += ghost3(uv,iv.xy,.3,.005,.5/1.5)*zfade*clmpback*vec3(.5,.1,-.05);\n        col += ghost3(uv,iv.xy,.3,.01,.4/1.5)*zfade*clmpback*vec3(.0,.5,-.05);\n        col += ghost3(uv,iv.xy,.3,.01,.3/1.5)*zfade*clmpback*vec3(.05,-.05,.45);\n        col += ghost3(uv,iv.xy,.2,.03,-.8/3.5)*zfade*clmpback*vec3(.5,.1,-.05);\n        col += ghost3(uv,iv.xy,.05,.01,-1.2/3.5)*zfade*clmpback*vec3(.0,.5,-.05);\n        col += ghost3(uv,iv.xy,.2,.07,-2./3.5)*zfade*clmpback*vec3(.05,-.05,.45);\n        col += ghost3(uv,iv.xy,.25,.04,-3.15/3.5)*zfade*clmpback*vec3(.0,.4,.2);\n        col += ghost3(uv,iv.xy,.15,.085,-3.75/3.5)*zfade*clmpback*vec3(.0,.2,.05);\n        col += ghost3(uv,iv.xy,.05,.06,-4.5/3.5)*zfade*clmpback*vec3(.05,-.05,.45);\n        col += ghost3(uv,iv.xy,.20,.03,-5.75/3.5)*zfade*clmpback*vec3(.0,.3,.5);\n        col += ghost3(uv,iv.xy,.08,.02,-5.95/3.5)*zfade*clmpback*vec3(.05,.2,.05);\n        col += ghost3(uv,iv.xy,.04,.01,-6.15/3.5)*zfade*clmpback*vec3(.1,-0.05,.65);\n    }\n    \n    col = clamp(col,.0,1.);\n\n    //color grading\n    col = expToneMap(col,2.6);\n    col = S(0.,1.,col);\n    col = pow(col, vec3(.4545)); // gamma correction\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 ); // vignete\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"volume","id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define FT iTime*FLAGWSPEED\n\n\nfloat noise(in vec3 x ){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    x = p + f;\n    return textureLod(iChannel0,(x+0.5)/32.0,0.0).x*2.0-1.0;\n}\nvec2 sdfClouds(vec3 p){\n\tvec3 q = p*.5 - vec3(.1,.05,0.0)*iTime;\n    float g = 0.5+0.5*noise( q*0.3 );\n    \n\tfloat f;\n    f  = 0.70000*noise( q ); q = q*2.02-1.;\n    f += 0.45000*noise( q ); q = q*2.23-1.;\n    f += 0.12500*noise( q ); q = q*2.41-1.;\n    f += 0.05250*noise( q ); q = q*2.62-1.;\n    f += 0.03125*noise( q ); \n    \n    f = mix( f*0.1-0.75, f, g*g*1.1 ) + 0.01;\n    return vec2(1.5*f - 0.5 - p.y,4.);\n}\n\nfloat GetDist(vec3 p) {\n    p -= FLAGPOS;\n    float rope = sdfRope(p, FT).x;\n    float b = sdfFlag(p, FT).x;\n    float cyl = sdfFlagstick(p).x;\n    p += FLAGPOS;\n    p += vec3(0.,1.7,0.);\n    float pl = p.y;\n    return min(min(min(cyl, b), rope),pl);\n}\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO;\n    vec3 tp = vec3(0.);\n    for(int i=ZERO; i<32; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        tp = p;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (.2-ro.z)/rd.z; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i= ZERO; i<55; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.05, 0.5 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://www.shadertoy.com/view/lss3zr\nvec4 RayMarchClouds(vec3 ro, vec3 rd, vec3 sundir, vec3 bg, vec2 px)\n{\n    // bounding planes\t\n    const float yb = -5.0;\n    const float yt =  0.;\n\n    float tb = (yb-ro.y)/rd.y;\n    float tt = (yt-ro.y)/rd.y;\n\n    // find tigthest possible raymarching segment\n\n    float tmin, tmax;\n    if( ro.y>yt )\n    {\n        // above top plane\n        if( tt<0.0 ) return vec4(0.0); // early exit\n        tmin = tt;\n        tmax = tb;\n    }\n    else\n    {\n        // inside clouds slabs\n        tmin = 0.0;\n        tmax = 60.0;\n        if( tt>0.0 ) tmax = min( tmax, tt );\n        if( tb>0.0 ) tmax = min( tmax, tb );\n    }\n    // dithered near distance\n    float t = tmin + 0.1*texture( iChannel1, px/iResolution.xy*4. ).x;\n    \n    // raymarch loop\n\tvec4 sum = vec4(0.0);\n    \n    vec4 skyColorHorrizon = SkyColorHorrizon;\n    vec4 skyFillColor = SkyFillColor;\n    vec4 sunColor = SunColor;\n    \n    float rm = RayMarch(ro, rd);\n    vec3 fp = ro+rd*rm;\n    float shadow = 1.;\n    if(fp.y<1.)shadow = calcSoftshadow(fp, normalize(vec3(-0.5,0.5,1.)), .1, 100.);\n        \n        \n    for( int i=0; i<190; i++ )\n    {\n       // step size\n       float dt = max(0.03,0.005*t);\n       vec3 pos = ro + t*rd;\n       pos += (texture(iChannel1, px/iResolution.xy*50.).xyz*2.-1.)*.1;\n       float den = sdfClouds(pos).x;\n\n       if( den>0.01) // if inside\n       {\n           // do lighting\n           float dif = clamp((den - sdfClouds(pos+0.2*sundir).x)/.2, 0.0, 1.0 );\n           vec3 lightColor = rgbe2rgb(skyColorHorrizon)+rgbe2rgb(sunColor)*.2;\n           vec3 baseColor = vec3(1.,.95,0.8);\n           vec3 densColor = vec3(.25,.0,.65);\n           vec3 shadColor = rgbe2rgb(SkyColorDown);\n           vec4 col = vec4(mix(baseColor,densColor,den),den);\n           \n           col.rgb *= mix(shadColor, lightColor, dif*shadow);\n           col.rgb += lightColor*dif*S(0.,150.,pos.z)*5.;\n           col.rgb += pow((1.-clamp(den,0.,1.)),4.)*.36;\n           col += clamp(den*pos.y*.15, -.05, .0);\n           \n           // fog\n           col.xyz = mix(col.xyz,bg, 1.0-exp2(-0.03*t));\n           \n           // composite front to back\n           col.w    = min(col.w*5.0*dt,1.0);\n           col.rgb *= col.a;\n           sum += col*(1.0-sum.a);\n       }\n       \n\n       // advance ray\n       t += dt;\n\n       // until far clip or full opacity\n       if( t>tmax || sum.a>0.99 ) break;\n\n    }\n\treturn clamp( sum, 0.0, 1.0 );\n}\nvec3 GetNormal(vec3 p) {\n\tfloat d = sdfClouds(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        sdfClouds(p-e.xyy).x,\n        sdfClouds(p-e.yxy).x,\n        sdfClouds(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 q = fragCoord/iResolution.xy;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    m = mouse(m,iTime);\n    \n    vec3 ro = rayOrigin(m);\n    mat3 vm = viewModelMatrix(ro);\n    vec3 rd = vec3(uv*tanFOV,1.);    \n    rd = normalize(vm*rd);\n    \n    vec3 skyColor = rgbe2rgb(skySphere(rd));\n    vec3 col = skyColor;\n    \n    vec3 cloudsPos = ro;\n    vec4 clouds = RayMarchClouds(cloudsPos,rd, LIGHTDIR, col, vec2(fragCoord-0.5));\n    \n    col = clouds.rgb+col*(1.-clouds.a);\n    \n    col = pow(col,vec3(1.5))*1.5;\n    col = expToneMap(col, 1.4);\n    fragColor = vec4(col,1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"// Sky box settings\nconst vec4 SunColor         = vec4( 1.00, 0.50, 0.30, 2.42);\nconst vec4 SkyFillColor     = vec4( 0.45, 0.40, 1.00, 0.55);\nconst vec4 SkyColorDown     = vec4( 0.50, 0.40, 0.80, 0.30);\nconst vec4 SkyColorHorrizon = vec4( 0.90, 0.25, 0.10, 1.00);\nconst vec3 LightDir         = vec3(-0.50, 0.05, 1.00);\n\n//Camera settings\n#define CAMERAVIEW0\n\n#ifdef CAMERAVIEW0\nconst vec3 CameraPos = vec3(0,2.,30.);\nconst vec3 SceneCentre = vec3(0,10,-1);\nconst float FOV = 80.;\n#endif \n#ifdef CAMERAVIEW1\n#define LOCKCAMERA\nconst vec3 CameraPos = vec3(16,3.,30.);\nconst vec3 SceneCentre = vec3(-0,7,-1);\nconst float FOV = 60.;\n#endif\n#ifdef CAMERAVIEW2\n#define LOCKCAMERA\nconst vec3 CameraPos = vec3(20.,1.5,-30.);\nconst vec3 SceneCentre = vec3(0,8,-1);\nconst float FOV = 60.;\n#endif\n#ifdef CAMERAVIEW3\n#define LOCKCAMERA\nconst vec3 CameraPos = vec3(10.,9.,-15.);\nconst vec3 SceneCentre = vec3(0,10,-1);\nconst float FOV = 60.;\n#endif\n#ifdef CAMERAVIEW4\n#define LOCKCAMERA\nconst vec3 CameraPos = vec3(10.,9.,14.);\nconst vec3 SceneCentre = vec3(0,10,-1);\nconst float FOV = 60.;\n#endif\n\n//SDF settings of the flag shape\nconst vec3 FlagSize = vec3(6.5,4.0,0.02);\nconst vec3 FLAGPOS =  vec3(0.0,9.0,0.0 );\n\n#define WINDSET0\n\n//Wind settings of flag\nconst vec3 WindForce = vec3(12.0,0.0,5.); // Wind force vector\nconst vec3 WindDelta = vec3(5.0 ,0.0,10.0); // Kind of randomization of wind force\n\nconst vec3 GForce = vec3(0.0,-2.0,0.0); // Gravitation force vector\nconst float WFrequency = 8.0; // frequency of sin waves of the flag shape\nconst float WAmplitude = 0.16; // amplitude or heigth sin waves of the flag shape\nconst float FlagSolidity = 15.; // this value affects on wind speed of flag\n\n\n//Common functions\nvec3 rgbe2rgb(vec4 color){\n    // this is like rgb color and last vector components is exsposure of color\n    vec3 rgb = color.xyz*color.w;\n    return rgb;\n}\nvec3 expToneMap(vec3 col, float e){\n    return 1.0 - exp2(-col * e);\n}\n\nfloat saturate(float a){return clamp(a,0.,1.);}\nvec2  saturate(vec2 a) {return clamp(a,0.,1.);}\nvec3  saturate(vec3 a) {return clamp(a,0.,1.);}\nvec4  saturate(vec4 a) {return clamp(a,0.,1.);}\n\nfloat remap01(float a,float b,float t){return saturate((t-a)/(b-a));}\nvec2 remap01(vec2 a,vec2 b,vec2 t){return saturate((t-a)/(b-a));}\nvec3 remap01(vec3 a,vec3 b,vec3 t){return saturate((t-a)/(b-a));}\nvec4 remap01(vec4 a,vec4 b,vec4 t){return saturate((t-a)/(b-a));}\n\n//\n#define HIGHQUALITY\n\n#define PI 3.14159\n#define AA 2.\n#define ZERO (min(iFrame,0))\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n#define SUNCOLOR         rgbe2rgb(SunColor)\n#define SKYFILLCOLOR     rgbe2rgb(SkyFillColor)\n#define SKYCOLORDOWN     rgbe2rgb(SkyColorDown)\n#define SKYCOLORHORRIZON rgbe2rgb(SkyColorHorrizon)\n#define LIGHTDIR normalize(LightDir)\n\n#define FLAGWSPEED 1.\n\n#define CAMERASPEED .005\n#define tanFOV tan(radians(FOV/2.))\n#define S(a,b,t) smoothstep(a,b,t)\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Gradient noise https://www.shadertoy.com/view/XdXGW8\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nvec2 grad( ivec2 z )  // replace this anything that returns a random vector\n{\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n    return vec2(cos(float(n)),sin(float(n)));                           \n}\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n    vec2 f =       fract( p );\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat3 invViewMatrix(mat3 m){\n    // would be nice to move these divides of FOV value to a better place\n    m[0].xyz *= 1./tanFOV;\n    m[1].xyz *= 1./tanFOV;\n    vec3 c0 = vec3(m[0].x, m[1].x, m[2].x);\n    vec3 c1 = vec3(m[0].y, m[1].y, m[2].y);\n    vec3 c2 = vec3(m[0].z, m[1].z, m[2].z);\n    return mat3(c0,c1,c2);\n}\n\nvec2 mouse(vec2 m, float t){\n    #if !defined(LOCKCAMERA)\n    m.x += t*CAMERASPEED;\n    m.y = cos(m.y+t*CAMERASPEED*4.);\n    #endif\n    return m;\n}\nmat3 viewModelMatrix(vec3 ro){\n   vec3 f = normalize(SceneCentre - ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r);\n    return mat3(r,u,f);\n}\nvec3 rayOrigin(vec2 m){\n    vec3 ro = CameraPos;\n    #if !defined(LOCKCAMERA)\n    ro.z = mix(12.,ro.z, clamp(m.y*.5+.5,0.,1.));\n    ro.y = mix(11.,ro.y, clamp(m.y*.5+.5,0.,1.));\n    mat2 rotZ = rot(-m.x*6.2831);\n    ro.xz *= rotZ;\n    #endif\n    return ro;\n}\n\nfloat skyNoise2d(vec2 p, vec2 s, vec2 o, vec2 piv, float r)\n{\n    // r means roughness\n    r = (1.-r)*6.;\n    float clouds = noise((p+piv)*s-piv+o);          s*=2.;\n    if(r>=1.)clouds += noise((p+piv)*s-piv+o)*.500; s*=2.;\n    if(r>=2.)clouds += noise((p+piv)*s-piv+o)*.250; s*=2.;\n    if(r>=3.)clouds += noise((p+piv)*s-piv+o)*.125; s*=2.;\n    if(r>=4.)clouds += noise((p+piv)*s-piv+o)*.100; s*=2.;\n    if(r>=5.)clouds += noise((p+piv)*s-piv+o)*.080; s*=2.;\n    if(r>=6.)clouds += noise((p+piv)*s-piv+o)*.060; s*=2.;\n    clouds = S(.2,1.,clouds*.5+.5);\n    return clamp(clouds,0.,1.);\n}\nvec4 skySphere(vec3 rd, float r){\n    float dist = distance(rd, LIGHTDIR);\n    vec3 lv = (rd*LIGHTDIR); //light view\n    \n    float n = skyNoise2d(vec2(atan(rd.x,rd.z),rd.y),vec2(6.,10.), vec2(0.), vec2(.0), r)*.5+.5;\n    float glare = clamp(1.-sqrt(dist),0.,1.);\n    float mie = glare*glare*(3.-2.*glare)*2.*S(-0.05,0.00,rd.y*n);\n    \n    vec4 sfc = mix(SkyFillColor, (SkyFillColor+SkyColorDown+SkyColorHorrizon)*.333, r);\n    vec4 scd = mix(SkyColorDown,(SkyColorDown)*1., r);\n    vec4 sch = mix(SkyColorHorrizon, (SkyFillColor*SkyColorHorrizon)*2.,r);\n    vec4 sc = mix(SunColor, (SunColor+SkyColorHorrizon)*.5, r);\n    \n    vec4 color = sfc;\n    vec2 w = mix(vec2(-.1,.1),vec2(-.15,.15),r);\n    color = mix((scd+sch)*.5, sch*sfc*2., S(w.x,w.y,rd.y));\n    w = mix(vec2(-.15,.2),vec2(-.19,.29),r);\n    color = mix(color, (sfc+sch)*.5, S(w.x,w.y,rd.y));\n    w = mix(vec2(.0,.5),vec2(.0,.5),r);\n    color = mix(color, sfc*.75, S(w.x,w.y,rd.y));\n    w.x = mix(1.,.8,r);\n    color = mix(color, sch+glare*0.2, mie);\n    w = mix(vec2(.0,-.2),vec2(.0,-.28),r);\n    color = mix(color, scd, S(w.x,w.y,rd.y));\n    \n    //2d clouds\n    vec2 scl = vec2(.8,1.);\n    vec3 ldir = LIGHTDIR;\n    vec2 ofs = vec2(0.,0.)*normalize(ldir.xz/ldir.y);\n    \n    float cm = smoothstep(-0.1,.4,rd.y); // clouds mask\n    \n    vec2 cuv = rd.xz/rd.y;\n    vec2 piv = normalize(ldir.xz/ldir.y)*-4.;\n    float skyClouds = skyNoise2d(cuv, scl, vec2(0.), piv, r)*cm;\n    \n    float shad = skyNoise2d(cuv, scl*vec2(1.,.98), ofs, piv, r)*cm;\n    shad = clamp(skyClouds - shad,0.,1.);\n    \n    vec3 clc = mix(SKYCOLORDOWN*SKYCOLORHORRIZON*2.,SKYCOLORHORRIZON,-lv.z*.5+.5);\n    vec3 cls = (SKYCOLORDOWN+SKYFILLCOLOR)*.5;\n    vec4 skyCloudsColor = vec4(mix(cls,clc, min(shad*1.5+glare,1.)),1.);\n    skyCloudsColor.a = mix(.5, 2., shad);\n    \n    \n    //sun\n    w.x = mix(0.01, 0.08, r);\n    float sundisk =S(w.x,.000,dist*0.2);\n    color = mix(color,sc,sundisk);\n    color = mix(color, skyCloudsColor, S(.25,1.,min(shad+skyClouds,1.)));\n    \n    return vec4(color);\n}\nvec4 skySphere(vec3 rd){\n    return skySphere(rd, 0.);\n}\nvec3 skySphereExpToned(vec3 rd, float r, float e){\n    vec4 col = skySphere(rd, r);\n    return expToneMap(col.rgb*col.a, e);\n}\n\n//flag textures\nfloat clothPattern(vec2 uv, float s){\n    uv = vec2(sin(uv.x*s),sin(uv.y*s))*.5+.5;\n    float n1 = noise(uv*vec2(0.01,1.)*s)*.5+.5;\n    float n2 = noise(uv*vec2(1.,.01)*s)*.5+.5;\n    return min(n1,n2);\n}\nfloat flagTextureSeems(vec3 p, float h){\n    float b = smoothstep(0.2,.15,abs(sin(p.y*6.)))*h*1.1;\n    float yp = FlagSize.y*.5-.1;\n    float height = smoothstep(yp,yp+.05,abs(p.y))*h*1.5;\n    float rp = -(FlagSize.x*.5-.1);\n    float root = smoothstep(rp+.05,rp,p.x)*h*2.;\n    float ep = FlagSize.x*.5-.1;\n    float end = smoothstep(ep,ep+.05,p.x)*h*1.5;\n    return max(max(height,root+end),b);\n}\n//source https://www.shadertoy.com/view/NdVXDw\nfloat silk(vec2 p, float a, float t){\n    p = (p-.5)*rot(a)+.5;\n\tp.y += 0.03*sin(8.0*p.x);\n    float s1 = 7.0*(p.x+p.y+cos(5.0*p.x+3.0*p.y));\n    float s2 = sin(30.0*(p.x+p.y-0.1*t));\n    return sin(s1+s2);\n}\nfloat flagClothStripes(vec3 p, float s, float h, float t){\n    p.xy += p.z;\n    float stripes1 = silk(p.xy*(s-0.1), 2.25, t)*(h-0.001);\n    float stripes2 = silk(p.xy*s+ vec2(-.04*t,0.),0.,t)*h;\n    return stripes1+stripes2;\n}\n\n//Flag wind computations\nvec3 gravityVecField(vec3 pos, float diametr, vec3 uroot, vec3 droot, vec3 force){\n    \n    float upm = length(pos.xy+uroot.xy)/diametr;\n    float dpm = length(pos.xy+droot.xy)/diametr;\n    float uc = S(0.,.2,upm); // down constraint\n    float dc = S(0.,.3,dpm); // down constraint\n    float xc = S(0.0,.1,(pos.x+uroot.x+.1)/FlagSize.x); // x constraint\n    \n    float x = upm*dc*uc*xc;\n    x *= force.x*force.y;\n    float y = remap01(0.,PI,atan(pos.x+uroot.x,-(pos.y+uroot.y)))*dc*uc*xc;\n    y *= force.y;\n    diametr -= force.x*force.y;\n    \n    //maybe will write Z direction later\n    //float z = 1.-(length(pos.xy+vec2(x,y)+vec2(-FlagSize.xy/2.-.1))/diametr);\n    //z = z*z*force.z;\n    return vec3(x,y,0.);\n}\nvec3 windVecField(vec3 pos, vec3 uroot, vec3 droot, vec3 force){\n    float wx = max(1.-length(pos.xy+vec2(uroot.x,0.))/(abs(uroot.y)*.5+abs(droot.y)*.5),0.);\n    wx /= force.y;\n    return vec3(-wx,0.,0.);\n}\n\nvec3 windPos(vec3 p, float t){\n    vec3 wpos = p;\n    vec3 uroot = vec3(3.25, -2.5, 0.); // upper flag's shape point\n    vec3 droot = vec3(3.25, 3., 0.);   // lower flag's shape point\n    float freq = WFrequency;\n    float amp = WAmplitude;\n    \n    float area = FlagSize.x*FlagSize.y;        // area of flag surface\n    float mass = FlagSolidity*area*FlagSize.z; // mass of flag shape\n    \n    // F = m*a, a is an acceleration, it represents time speed\n    t *= length(WindForce)/mass; \n    float t2 = t*3.;\n    \n    // the distribution of wind force\n    float wn = noise(p.xy*.2+vec2(-t,0.))*.5+.5;\n    //Randomized wind force vector. It changes by the time.\n    vec3 wvec = vec3(mix(WindForce.x,WindForce.x-WindDelta.x,wn),0.,    \n                mix(WindForce.z,WindForce.z-WindDelta.z,wn)); \n    \n    vec3 nfvec = normalize(wvec+GForce);       // normalized force vector\n    float wpower = length(wvec);               // wind force\n    float gpower = length(GForce)*(1./wpower); // gravity force\n\n    float diagonal = length(FlagSize.xy);      // length of diagonal of parallelogram\n    \n    // compute angle between a perpendicular to the flag stick and force vector\n    vec3 forward = vec3(nfvec.x,0.,nfvec.z);\n    float fcos = dot(nfvec, forward);\n    float fsin = sqrt(1.-fcos*fcos);\n    float ftan = fsin/fcos; // gravity tangens\n    \n    // compute flag rotation by Y axis\n    float fdotr = dot(nfvec.xz,vec2(0.,1.));\n    mat2 r2d = rot(acos(fdotr)-PI*.5);\n    mat3 rm = mat3(vec3(r2d[0].x,0.,r2d[0].y),vec3(0.,1.,0.),vec3(r2d[1].x,0.,r2d[1].y));\n    wpos = (wpos+uroot)*rm-uroot;\n    \n    // compute gravity offsets\n    float gY = FlagSize.x*ftan;\n    float gX = length(vec2(FlagSize.x, gY))-FlagSize.x;\n    float gZ = area/((FlagSize.x-gX)*(FlagSize.y-gY));\n    \n    // generate vector fields for wind force and gravity force\n    vec3 wf = vec3(gX,gY,gZ);\n    vec3 gvf = gravityVecField(p,diagonal,uroot,droot,wf);\n    vec3 wvf = windVecField(wpos,uroot,droot, wf);\n    wpos += gvf+wvf;\n\n    // generate sin waves on a flag surface\n    amp *= gZ;\n    vec3 f3 = freq*wf; // frequency for each axis\n    wpos.z += (sin(gvf.x*f3.x-t2)+sin(gvf.y*f3.y-t2)+sin(gvf.z*f3.z-t2))*amp*fsin\n    *S(0.,.1,((p.x+uroot.x)/FlagSize.x));;\n    \n    //wpos.z += sin(p.x*freq-t5*2.)*.1*amp*fsin;\n    \n    return wpos;\n}\n\n//SDF \n\n//base sdf functions\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n    \nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.)-.001;\n}\nfloat sdPlane(vec3 p, vec3 n){\n    return dot(normalize(p),n);\n}\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//Flag sdf shapes\n\nfloat sdTrident(vec3 p,float s, float th){\n    vec2 uv = p.xy;\n    p.z = abs(p.z);\n    uv.x = abs(uv.x);\n    vec3 point = vec3(0.5, -0.5, 0.)*s;\n    float sdf =0.;\n    float r = .3*s;\n    float r1 = .17*s;\n    float r2 = 1.4*s;\n    float inc = p.z;\n    \n    //base shape\n    float hor = max(abs(uv.x+point.y),abs(uv.y)+point.y);\n    float ver = max(abs(uv.y+point.x),abs(uv.x)+point.y);\n    sdf = min(hor,ver);\n\n    vec2 ofs0 = vec2(-.05*s, r-.02*s);\n    vec2 ofs1 = vec2(-0.2,0.13)*s;\n    vec2 ofs2 = vec2(-.17,-.1);\n\n    float c = length(uv+point.yy+ofs0);\n\n    float ct = (1.-c)-r+inc;\n    ct = max(ct,abs(p.z)-.3);\n    ct = max(ct,-uv.y-point.y-r+.1*s);\n    \n    c = abs(c-r);\n    c = max(c,uv.x-point.x);\n    c = max(c,-uv.y-point.y-ofs0.y-(uv.x+point.y+r)*-.5);\n    sdf = min(sdf,c);\n    \n    //mid line\n    float l = abs(uv.x-r-ofs0.x-.0001-(-uv.y-point.y-ofs0.y)*-.04);\n    l = max(l, uv.y+point.y+ofs0.y+(uv.x-r-ofs0.x)*-.6-.019*s);\n    l = max(l, -uv.y-ofs1.y+r1);\n    sdf = min(sdf, l);\n\n    //mid cyrcle\n    r = .17*s;\n    c = length(uv + ofs1);\n    c = abs(c-r);\n\n    c = max(c,-uv.x+r-ofs0.x+(uv.y+ofs1.y)*.04+.016*s);\n    l = abs(uv.y+ofs1.y);\n    l = max(l,-uv.x-ofs1.x+r); l = max(l,uv.x-point.x);\n    sdf = min(sdf,l);\n    sdf = min(sdf,c);\n\n    //pre downd cyrcle\n    r = .17*s;\n    c = length(uv-point.zy+vec2(-r,-0.033*s));\n    c = abs(c-r);\n    c = max(max(c,-uv.y-point.x),uv.x-.17*s);\n    l = abs(uv.y+point.x-r-0.0325*s);l=max(l,-uv.x+r); \n    l = max(l,uv.x-r+ofs0.x-(uv.y+ofs1.y)*.04-.01*s);\n    sdf = min(sdf,min(c,l));\n\n    //down cyrcle\n    r = .4*s;\n    c = length(uv-point.zy+vec2(.17,-0.1)*s);\n    c = abs(c-r);\n    c = max(max(c,uv.y+.3*s),-uv.x);\n    l = abs(uv.x);\n    l = max(l,uv.y+point.x); l = max(l, -uv.y+point.y-r+.16*s);\n    c = min(c,l);\n    c = max(c,-p.z-.1);\n    sdf = min(sdf,c);\n\n    //down small cyrcle\n    r = .1*s;\n    c = length(uv-point.zy-vec2(0.1*s,r-.418*s));\n    c = abs(c-r);\n    c = max(max(c, uv.x-.01),-uv.y-point.x-0.3*s);\n\n    //center cyrcle shape\n    r2 = 1.4*s;\n    c = length(uv-point.xz+vec2(-.89,-0.46)*s);\n    c = abs(c-r2);\n    c = max(c,uv.x-r-ofs0.x-.16*s-(uv.y+ofs1.y)*.04-.01*s);\n    c = max(c,uv.y-.5*s);\n    sdf = min(sdf,c);\n\n    //top center cyrcle shape\n    r = .3*s;\n    c = length(uv-point.zx-vec2(-.3,.03)*s);\n    c = c-r;\n    c = max(c,-uv.x);\n\n    sdf = min(sdf,c);\n    sdf = max(sdf*0.866025+p.z*0.5,-p.z)-th*.5;\n    sdf = max(abs(p.z)-.045*s,sdf);\n    return sdf;\n}\nvec2 sdfFlag(vec3 p, float t){\n\n    vec3 s = FlagSize/2.;\n    p = windPos(p, t)-vec3(-.03,0.,0.);\n    \n    //Generate textures\n    float flagSeems = flagTextureSeems(p, .004);\n    float cloth = (1.-clothPattern(p.xy+p.z,20.))*.002;\n    float stripes = flagClothStripes(p, .3, 0.01, t)*(1.-min(flagTextureSeems(p, 1.),1.));\n    \n    p.z += stripes;\n    float b = sdBox(p, s)*.45;\n    b -= flagSeems;\n    b -= cloth;\n\n    return vec2(b, 1.);\n}\nvec2 sdfRope(vec3 p, float t){\n    p = windPos(p,t)-vec3(-3.25, 0., 0.);\n    float sdf = max(length(p.xz)-.02, abs(p.y+.22)-2.5);\n    \n    return vec2(sdf,2.);\n}\nvec2 sdfFlagstick(vec3 p){\n    float cylH = 7.;                         // stick's height\n    vec3 pCyl = p+vec3(3.5,4.5,0.);          // stick's position\n    float m = 1.-smoothstep(-10.,7.,p.y)*.7; // distribution of diameter of the stick\n    float sdf1 = sdCappedCylinder(pCyl, .25*m, cylH);\n    vec3 pCyl2 = pCyl+vec3(0.0,-7.02,0.);\n    float sdf2 = sdCappedCylinder(pCyl2, .055, .25);\n    \n    vec3 sBox = vec3(.19,.05,.05);\n    vec3 bPos = vec3(pCyl.x,abs(pCyl.y-4.25),pCyl.z);//+vec3(-0.17,-7.,0.);\n    bPos += vec3(-.2,-2.52,0.);\n    float box = sdBox(bPos,sBox);\n    \n    sdf1 -= smoothstep(.04,.032,abs(sin(p.y*.7+2.55)))*.02;\n    \n    float k = 0.05; // privitives union\n    vec3 emPos = pCyl-vec3(0.,cylH+1.3,0.);\n    float st = sdCappedCylinder(pCyl2-vec3(0.,.3,0.), .03, .2);\n    float trident = sdTrident(emPos,1.,.08);\n    trident = opSmoothUnion(st,trident,k);\n    \n    float stick = opSmoothUnion(opSmoothUnion(sdf1,sdf2,k),box,k);\n    stick = opSmoothUnion(stick,trident,k);\n    return vec2(stick, stick<trident ?3.:4.);\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define FT iTime*FLAGWSPEED\n\n//raymarching functions\nvec2 GetDist(vec3 p) {\n    float pl = p.y;\n    p -= FLAGPOS;\n    vec2 rope = sdfRope(p, FT);\n    vec2 b = sdfFlag(p, FT);\n    vec2 cyl = sdfFlagstick(p);\n    float u1 = min(min(cyl.x, b.x), rope.x);\n    float m1 = cyl.x < b.x ? cyl.y : b.y;\n    float m2 = min(cyl.x, b.x) < rope.x ? m1 : rope.y;\n    return vec2(u1, m2);\n}\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 dO=vec2(0.);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x;\n        dO.y = dS.y;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    if(dO.x>MAX_DIST) dO.x=-1.;\n    return dO;\n}\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n//Lighting\n//Sperical harmonics https://www.shadertoy.com/view/MdfSDH\nvoid SH_AddLightDirectional( inout vec3 sh[9], in vec3 col, in vec3 v )\n{\n    //#define NO  1.0        // for perfect overal brigthness match\n    #define NO (16.0/17.0) // for normalizing to maximum = 1.0;\n    sh[0] += col * (NO*PI*1.000) * (0.50*sqrt( 1.0/PI));\n    sh[1] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.x;\n    sh[2] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.y;\n    sh[3] += col * (NO*PI*0.667) * (0.50*sqrt( 3.0/PI)) * v.z;\n    sh[4] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.x*v.z;\n    sh[5] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.z*v.y;\n    sh[6] += col * (NO*PI*0.250) * (0.50*sqrt(15.0/PI)) * v.y*v.x;\n    sh[7] += col * (NO*PI*0.250) * (0.25*sqrt( 5.0/PI)) * (3.0*v.z*v.z-1.0);\n    sh[8] += col * (NO*PI*0.250) * (0.25*sqrt(15.0/PI)) * (v.x*v.x-v.y*v.y);\n}\n\nvec3 SH_Evalulate( in vec3 v, in vec3 sh[9] )\n{\n    return sh[0] * (0.50*sqrt( 1.0/PI)) +\n           sh[1] * (0.50*sqrt( 3.0/PI)) * v.x +\n           sh[2] * (0.50*sqrt( 3.0/PI)) * v.y +\n           sh[3] * (0.50*sqrt( 3.0/PI)) * v.z +\n           sh[4] * (0.50*sqrt(15.0/PI)) * v.x*v.z +\n           sh[5] * (0.50*sqrt(15.0/PI)) * v.z*v.y +\n           sh[6] * (0.50*sqrt(15.0/PI)) * v.y*v.x +\n           sh[7] * (0.25*sqrt( 5.0/PI)) * (3.0*v.z*v.z-1.0) +\n           sh[8] * (0.25*sqrt(15.0/PI)) * (v.x*v.x-v.y*v.y);\n}\n\nvec3 DiffuseLighting(vec3 normal){\n    vec3 sh[9];sh[0]=vec3(0.);sh[1]=vec3(0.);sh[2]=vec3(0.);sh[3]=vec3(0.);sh[4]=vec3(0.);sh[5]=vec3(0.);sh[6]=vec3(0.);sh[7]=vec3(0.);sh[8]=vec3(0.);\n    vec3 lightDir = LIGHTDIR;\n\n    vec3 rld = normalize(vec3(1.,0.,0.)),\n         lld = rld*vec3(-1.,1.,1.),\n         lbd = normalize(vec3(0.,0.,-1.)),\n         ldd = normalize(vec3(0.,-1.,0.)),\n         ltd = normalize(vec3(0.,1.,0.));\n    float r = 1.;\n    float e = 1.;\n    SH_AddLightDirectional(sh, ((SUNCOLOR)), lightDir);\n    SH_AddLightDirectional(sh, (skySphereExpToned(lld, r,e)), lld);\n    SH_AddLightDirectional(sh, (skySphereExpToned(rld, r,e)), rld);\n    SH_AddLightDirectional(sh, (skySphereExpToned(lbd, r,e)), lbd);\n    SH_AddLightDirectional(sh, (skySphereExpToned(ldd, r,e)), ldd);\n    SH_AddLightDirectional(sh, (skySphereExpToned(ltd, r,e)), ltd);\n    return SH_Evalulate( normal, sh);\n}\n\n// PBR implementation https://learnopengl.com/PBR/Theory\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness){\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat RadicalInverse_VdC(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\nvec2 Hammersley(uint i, uint N){\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness){\n    float a = roughness*roughness;\n\t\n    float phi = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\t\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = sin(phi) * sinTheta;\n    H.z = cosTheta;\n\t\n    vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 tangent   = normalize(cross(up, N));\n    vec3 bitangent = cross(N, tangent);\n\t\n    vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n    return normalize(sampleVec);\n}\n\n// Cloth PBR \n// https://google.github.io/filament/Filament.md.html#materialsystem/clothmodel\nfloat AshikhminD(float roughness, float ndoth){\n\tfloat r2    = roughness * roughness;\n\tfloat cos2h = ndoth * ndoth;\n\tfloat sin2h = 1. - cos2h;\n\tfloat sin4h = sin2h * sin2h;\n\n\treturn (sin4h + 4. * exp(-cos2h / (sin2h * r2))) / max((PI * (1. + 4. * r2) * sin4h),0.1);\n}\n\nfloat AshikhminV(float ndotv, float ndotl){\n\treturn 1. / (4. * (ndotl + ndotv - ndotl * ndotv));\n}\n\n//LUT https://github.com/google/filament/blob/main/libs/ibl/src/CubemapIBL.cpp\nfloat DFV_Charlie(float NoV, float roughness) {\n    float r = 0.0;\n    vec3 V = vec3(sqrt(1. - NoV * NoV), 0., NoV);\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    float VdotH = dot(V,N);\n    const uint numSamples = 10u;\n    for (uint i = 0u; i < numSamples; i++) {\n        vec2 Xi = Hammersley(i, numSamples);\n        vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n        vec3 L = 2. * dot(V, H) * H - V;\n        float VdotH = saturate(dot(V, H));\n        float NdotL = saturate(L.z);\n        float NdotH = saturate(H.z);\n        if (NdotL > 0.) {\n            float d = AshikhminD(roughness, NdotH);\n            float v = AshikhminV(VdotH, NdotL);\n            r += v * d * NdotL * VdotH; // VoH comes from the Jacobian, 1/(4*VoH)\n        }\n    }\n    // uniform sampling, the PDF is 1/2pi, 4 comes from the Jacobian\n    return r * (4.0f * 2.0f * PI / float(numSamples));\n}\n\n//Cloth Lighting\n\nvec3 ClothLighting(vec3 baseColor, vec3 irradiance, vec3 sssColor, float occ, float roughness,\nvec3 rd, vec3 normal){\n\n    vec3 lightDir = LIGHTDIR;\n    vec3 reflectVector = reflect(rd,normal);\n    \n    float proughness = roughness*roughness*2.;\n    float vdotn = max(dot(-rd,normal),0.);\n    vec3 sss = min(sssColor + vdotn, 1.);\n\n    baseColor *= occ;\n    baseColor *= clamp((vdotn + 0.5)/1.25,.0,1.);\n    \n    vec3 diffuse = baseColor*irradiance * sss;\n    //specular\n    vec3 specularColor = vec3(.5);\n    vec3 f = fresnelSchlickRoughness(vdotn,specularColor,roughness);\n    float ch = DFV_Charlie(vdotn, roughness);\n    vec3 reflectionColor = rgbe2rgb(skySphere(reflectVector,roughness));\n    vec3 specular = reflectionColor * f * ch;\n    return diffuse+specular;\n\n}\nvec3 ClothSSS(vec3 color, vec2 uv, vec3 p, float vdotn, float opacity){\n    vec2 nof = texture(iChannel1, (p.xy+p.z)*vec2(2.,.5)).rg * .5;\n    nof += texture(iChannel1, (p.xy+p.z)*vec2(.5,2.)).rg * .5;\n    nof = (nof *2.-1.)*.2;\n    \n    vec2 texel = 1./vec2(textureSize(iChannel0, 0).xy);\n    vec3 bg = texture(iChannel0, uv+nof).rgb;\n    vec2 offset = texel.xx*5.;\n    bg += texture(iChannel0, uv+nof+vec2(0., offset.y)).rgb;\n    bg += texture(iChannel0, uv+nof+vec2(0., -offset.y)).rgb;\n    bg += texture(iChannel0, uv+nof+vec2(offset.x, 0.)).rgb;\n    bg += texture(iChannel0, uv+nof+vec2(-offset.x, 0.)).rgb;\n    bg /= 5.;\n    bg = clamp(bg,0.,1.);\n    float lum = sqrt(dot(bg, vec3(0.299, 0.587, 0.114)));\n    vdotn = pow(vdotn,2.);\n    \n    return mix(color, bg, lum*vdotn*opacity);\n}\n\n//Common Lighting\n//Based on this shader https://www.shadertoy.com/view/XlfGD2\nvec3 pbrColor(vec3 f0, vec3 diffuse, vec3 vd, vec3 n, float r, float m){\n\n    float specPower = mix(0.,16.,r)+2.;\n    specPower*=specPower;\n    r = 1.-r;\n    vec3 amb = diffuse*.3;\n    vec3 spec = vec3(0.);\n    vec3 ref = reflect(vd,n);\n    vec3 skyColor = rgbe2rgb(skySphere(ref, r));\n    float vdotn = max(dot(-vd,n),0.);\n\n    vec3 h = normalize(-vd+LIGHTDIR);\n    float hdotn = max(dot(h, n), 0.);\n    vdotn = pow(vdotn,4.);\n    vec3 frenselRefl = f0+(max(vec3(1.-r),f0)-f0)*(1.-vdotn);\n    spec = skyColor * vdotn;\n\n    float blinnPhongNormFactor = (specPower + 2.0) / (2.0 );\n    vec3 specColor = 1.-diffuse;\n    float blinnPhongSpec = pow(hdotn,specPower);\n    \n    float ldoth = max(dot(LIGHTDIR, h),0.);\n    float ndotl = max(dot(n,LIGHTDIR),0.);\n    \n    vec3 F = f0 + (1.0 - f0) * pow( (1.0 - ldoth), 5.0);\n    float D = blinnPhongNormFactor * blinnPhongSpec;\n    float G = ndotl * vdotn;\n    vec3 specBRDF = (F * G * D) / ((4.0 * ndotl * vdotn) + 0.001);\n    \n    vec3 specular = (1.-m)*amb + frenselRefl*skyColor + f0*specBRDF;\n    return specular;\n}\n\nvec3 ShadeMaterial(int mId, vec4 bg, vec3 normal, vec3 rd, vec3 p, vec2 uv, float d){\n\n    vec3 col = vec3(0.0);\n    vec3 diffuse = DiffuseLighting(normal);\n    \n    float aoRange = d;\n    float occlusion = max( 0.0, 1.0 - GetDist( p + normal*aoRange ).x/aoRange );\n    \n    vec3 yellow = vec3(0.9,.4, .1);\n    vec3 blue = vec3(0.05,0.2,0.9);\n    vec3 pw = windPos(p-FLAGPOS, FT);\n    float fmask = 1.-flagTextureSeems(pw,.4);\n    vec3 flagtex = mix(yellow,blue,S(-.03,.03,pw.y));\n    \n    //Flag material\n    if(mId == 1)\n    {\n        vec3 albedo = flagtex;\n        vec3 sssColor = SKYCOLORHORRIZON*.6+SUNCOLOR*.4;\n        float roughness = clothPattern(pw.xy+pw.z,20.)*.5;        \n        float vdotn = max(dot(-rd, normal),0.);\n        \n        col = ClothLighting(albedo, diffuse, sssColor, occlusion, roughness, rd, normal);\n        col = ClothSSS(col, uv, pw, vdotn, fmask*roughness);\n    }\n    //Rope material\n    if(mId == 2){\n        float roughness = 0.5, met = 0.0;\n        vec3 albedo = vec3(0.7), f0 = vec3(0.2);\n        diffuse *= albedo*occlusion;\n        col = pbrColor(f0,diffuse,rd,normal,roughness,met);\n    }\n    //Flag stick material\n    if(mId == 3)\n    {\n        vec3 f0 = vec3(.15);\n        float roughness = .2;\n        float tex = noise(p.xy*vec2(5.,10.))*abs(normal.x)+noise(p.zy*vec2(5.,10.))*abs(normal.z);\n        roughness *= tex;\n        float met = .1;\n        vec3 albedo = vec3(.5,.6,.6);\n        \n        #ifdef HIGHQUALITY\n        diffuse *= albedo*occlusion;\n        flagtex *= pow(max(dot(normal, vec3(1,0,0)),0.),2.)*S(2.1,2.,abs(p.y-9.));\n        diffuse += flagtex*.2;\n        diffuse += max(-p.y+1.5,0.)*SKYCOLORDOWN*.5;\n        col = pbrColor(f0, diffuse, rd, normal, roughness, met);\n        #else\n        col = diffuse*albedo*.25;\n        #endif\n    }\n    //Emplem material\n    if(mId == 4)\n    {\n        vec3 baseColor = vec3(1.,.9,.6);\n        \n        vec3 f0 = vec3(1.,.9,.6), albedo = vec3(1.);\n        float roughness = 0.2, met = 1.;\n        roughness *= pow(random(pw.xy),.4);\n        diffuse *= albedo*occlusion;\n        col = pbrColor(f0, diffuse, rd, normal, roughness, met);\n    }\n\n    float cm = smoothstep(-1.,-2., p.y); // clouds mask\n\n    col = mix(col,bg.rgb, cm);\n    return col;\n\n}\n//\nvec4 trace(vec2 fragCoord, vec4 bg, vec2 q){\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = mouse(m,iTime);\n    \n    vec3 ro = rayOrigin(m);\n    mat3 vm = viewModelMatrix(ro);\n    vec3 rd = vec3(uv*tanFOV,1.);    \n    rd = normalize(vm*rd);\n    \n    vec2 rm = RayMarch(ro,rd);\n    \n    float d = rm.x;\n    int mId = int(rm.y);\n    \n    vec3 p = ro+rd*d;\n    vec3 normal = GetNormal(p);\n    vec3 col = bg.rgb;\n    \n    if(d>0.1)\n    {\n\n        col = ShadeMaterial(mId, bg, normal, rd, p, q, d);\n    }\n\n        \n    return vec4(col,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;    \n    vec4 bg = texture(iChannel0, q);\n    \n    vec4 col = vec4(0.);\n    \n    float increment = 1. / AA;\n    for (float i = 0.; i < 1.; i += increment) {\n        for (float j = 0.; j < 1.; j += increment) {\n            col += trace(fragCoord + vec2(i,j), bg, q);\n        }\n    }\n    \n    col = col/AA/AA;\n    fragColor = vec4(col);\n}","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"mdBSWK","date":"1676463684","viewed":189,"name":"Ukranian Flag","username":"uTaras","description":"Inspired of the tallest flag in Ukraine which is based in Kyiv city. Its height is around of 90 meters.\nCamera controls by mouse. You can also play some settings in common tab. \nVideo of this https://www.artstation.com/artwork/vDAEkD","likes":20,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","sdf","clouds","sky","flag","lensflare","pbr","wind","cloth"],"hasliked":0,"parentid":"","parentname":""}}