{"ver":"0.1","info":{"id":"XdByRw","date":"1491444348","viewed":299,"name":"Wave table","username":"52GW","description":"Just playing around learning volumetric rendering. This is a work in progress, but I figured it is at least slightly interesting.\n\nThe mouse controls the light location.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["reflection","waves","volumetric","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A first exercise for myself. Mybe I'll make it juggle a couple balls next next!\n\n// for higher frame rate, turn fisheye off and reduce reflections to 1\nconst bool fisheye = true;\nconst int reflections = 2;\n\nconst float PI = 3.1415926536;\nconst float max_depth = 15.0;\n\nconst float time_f = 0.4;\nconst float FOV = radians(65.0);\nconst float tilt = -20.0 * PI/180.0;\nconst float rotate = -30.0 * PI/180.0;\nconst vec3 eye_pos = vec3(-0.5, 0.0, -6.7)\n    * mat3(1.0,0.0,0.0,0.0,cos(tilt),sin(tilt),0.0,-sin(tilt),cos(tilt))\n    * mat3(cos(rotate),0.0,sin(rotate),0.0,1.0,0.0,-sin(rotate),0.0,cos(rotate));\n\n// Shiny, bouncy ball\nconst float r_ball = 0.8;\nconst float ball_y = 0.3;\nconst float disp_y = 0.1;\n\nvec3 o_ball;\n\nfloat BallDistance(vec3 pos, float r) {\n    return distance(pos, o_ball) - r;\n}\n\n// The box holding the waves\nconst float box_size = 3.0;\t\t\t\t// half the box width and height (inside)\nconst float box_thickness = 0.1;\t\t// thickness of box walls\nconst float box_top = 0.3;\nconst float box_bottom = -0.8;\n\nfloat BoxDistance(vec3 pos) {\n    float outside = max(abs(pos.x) - (box_size + box_thickness),\n                        \t  abs(pos.z) - (box_size + box_thickness));\n    float inside = min(box_size - abs(pos.x),\n                       \t\t box_size - abs(pos.z));\n    return max(max(outside, inside), max(box_bottom - pos.y, pos.y - box_top));\n}\n\n// Wavy pool\nconst float reflect_f = 0.8;\t\t\t// waves reflect off the sides (only once), this is how much gets reflected\nconst vec2 o_wave1 = vec2(-1.7,-0.9);\t// wave origins\nconst vec2 o_wave2 = vec2(1.7,0.3);\nconst float m_wave1 = 0.1;\t\t\t\t// wave magnitudes\nconst float m_wave2 = 0.14;\nconst float f_wave1 = 10.0;\t\t\t\t// wave frequencies\nconst float f_wave2 = 9.0;\nconst int num_points = 2;\t\t\t\t// change to 1 to remove second wave\n\nconst vec2 o[10] = vec2[10](o_wave1, vec2(-6.0-o_wave1.x, o_wave1.y), vec2(6.0-o_wave1.x, o_wave1.y),\n                                     vec2(o_wave1.x, -6.0-o_wave1.y), vec2(o_wave1.x, 6.0-o_wave1.y),\n                            o_wave2, vec2(-6.0-o_wave2.x, o_wave2.y), vec2(6.0-o_wave2.x, o_wave2.y),\n                                     vec2(o_wave2.x, -6.0-o_wave2.y), vec2(o_wave2.x, 6.0-o_wave2.y));\nconst float m[10] = float[10](m_wave1, m_wave1*reflect_f, m_wave1*reflect_f, m_wave1*reflect_f, m_wave1*reflect_f,\n                              m_wave2, m_wave2*reflect_f, m_wave2*reflect_f, m_wave2*reflect_f, m_wave2*reflect_f);\nconst float f[10] = float[10](f_wave1, f_wave1, f_wave1, f_wave1, f_wave1,\n                              f_wave2, f_wave2, f_wave2, f_wave2, f_wave2);\n\nvec3 o_disp;\n\nfloat PoolDistance(vec3 pos) {\n    float dist = pos.y;\n    for(int i=0; i<num_points*5; ++i) {\n        float d = distance(pos.xz,o[i]);\n        d = mix(0.3,d,smoothstep(0.0,0.09,d*d));\n      \tdist -= pow(sin((d-iTime*time_f)*f[i])*0.5+0.5,2.0)/(d+0.3)*m[i];\n    }\n    float disp_dist = 4.0*pow(distance(vec3(pos.x,-1.0,pos.z), o_disp) + 1.0, -3.0);\n    return max(max(abs(pos.x) - box_size, abs(pos.z) - box_size),\n               max(box_bottom - pos.y, dist + disp_dist));\n}\n\n// Ray marching to the objects\nfloat pool_dist;\nfloat ball_dist;\nfloat box_dist;\n\nfloat RayMarch(vec3 start_pos, vec3 dir) {\n\tfloat depth = 0.0;\n    for (int i = 0; i < 255 && depth < max_depth; i++) {\n        vec3 pos = start_pos + dir * depth;\n        pool_dist = PoolDistance(pos);\n        ball_dist = BallDistance(pos, r_ball);\n        box_dist = BoxDistance(pos);\n        float dist = min(min(pool_dist, ball_dist), box_dist);\n        if (abs(dist) < 0.001) {\n        \treturn depth;\n        }\n        depth += 0.9 * dist;\n    }\n    return max_depth;\n}\n\n// Normals to our objects\nconst float DX = 0.01;\nconst vec3 dx = vec3(DX, 0.0, 0.0);\nconst vec3 dy = vec3(0.0, DX, 0.0);\nconst vec3 dz = vec3(0.0, 0.0, DX);\n\nvec3 PoolNormal(vec3 pos) {\n    return normalize(vec3(\n        PoolDistance(pos + dx) - PoolDistance(pos - dx),\n        PoolDistance(pos + dy) - PoolDistance(pos - dy),\n        PoolDistance(pos + dz) - PoolDistance(pos - dz)\n    ));\n}\nvec3 BallNormal(vec3 pos) {\n    return normalize(pos - o_ball);\n}\nvec3 BoxNormal(vec3 pos) {\n    return normalize(vec3(\n        BoxDistance(pos + dx) - BoxDistance(pos - dx),\n        BoxDistance(pos + dy) - BoxDistance(pos - dy),\n        BoxDistance(pos + dz) - BoxDistance(pos - dz)\n    ));\n}\n\n// Needs rework, but sample the point we hit\nvec3 sample_normal;\nfloat sample_reflect;\n\nvec3 sampler(vec3 pos, vec3 light_dir) {\n    vec3 color;\n    \n    if (pool_dist < 0.001) {\n        sample_normal = PoolNormal(pos);\n        color = vec3(0.0,1.0,0.4);\n        sample_reflect = 0.2;\n    }\n    else if (ball_dist < 0.001) {\n        sample_normal = BallNormal(pos);\n        color = vec3(0.1,0.2,0.3);\n        sample_reflect = 0.8;\n    }\n    else if (box_dist < 0.001) {\n        sample_normal = BoxNormal(pos);\n        color = vec3(0.3,0.0,0.1);\n        sample_reflect = 0.5;\n    }\n    float shadow_dist = RayMarch(pos + 0.02*light_dir, light_dir);\n    float diffuse = clamp(dot(light_dir, sample_normal), 0.0, step(max_depth-0.1, shadow_dist)) +\n        0.2*clamp(dot(vec3(0.0,1.0,0.0), sample_normal), 0.0, 1.0);\n    return color * diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // vectors from eye and light\n    vec2 xy = fragCoord - vec2(0.5,0.5)*iResolution.xy;\n    vec3 ray_dir;\n    if (fisheye) {\n\t    ray_dir = normalize(vec3(xy, cos(2.0*FOV/iResolution.x*length(xy)) * iResolution.x));\n    } else {\n\t    ray_dir = normalize(vec3(xy, 1.0 / tan(0.5 * FOV) * 0.5 * iResolution.y));\n    }\n    ray_dir.yz *= mat2(cos(tilt),sin(tilt),-sin(tilt),cos(tilt));\n    ray_dir.xz *= mat2(cos(rotate),sin(rotate),-sin(rotate),cos(rotate));\n    vec2 mouse_pos = (iMouse.xy == vec2(0.0) ? vec2(0.7,0.25) : iMouse.xy / iResolution.xy) * vec2(6.2832,2.0);\n    vec3 light_dir = normalize(vec3(-sin(mouse_pos.x), mouse_pos.y, cos(mouse_pos.x)));\n\n    // animate the wave displacement and ball\n    float anim_d = fract((-iTime * time_f + 0.19) * f[0] * (0.25/PI));\n    o_ball.xz = mix(o_wave1, o_wave2, 0.5 - 0.45*cos(anim_d * 2.0*PI));\n    anim_d = fract((-iTime * time_f + 0.14) * f[0] * (0.5/PI)) - 0.5;\n    anim_d *= anim_d;\n    o_ball.y = ball_y + (1.0 - 8.0*anim_d) / (1.0 + 256.0*pow(anim_d, 4.0));\n    \n    anim_d = fract((-iTime * time_f + 0.05) * f[0] * (0.25/PI));\n    o_disp.xz = mix(o_wave1, o_wave2, 0.5 - 0.45*cos(anim_d * 2.0*PI));\n    anim_d = fract(2.0*anim_d) - 0.5;\n    anim_d *= anim_d;\n    o_disp.y = disp_y + (1.0 - 12.0*anim_d) / (1.0 + 48.0*anim_d*anim_d);\n\n    float depth = RayMarch(eye_pos, ray_dir);\n    if (depth >= max_depth) {\n        // the background is the background, does not get reflected or anything\n        fragColor = vec4(0.1,0.2,0.4,1.0);\n    } else {\n        // sample the fragment\n        vec3 pos = eye_pos + ray_dir * depth;\n\t\tfragColor = vec4(sampler(pos, light_dir),1.0);\n\n        // and then add any reflections\n        float r_factor = sample_reflect;\n\t    for (int i = 0; i < reflections; ++i ) {\n            ray_dir = reflect(ray_dir, sample_normal);\n            pos += 0.02*ray_dir;\n\n            depth = RayMarch(pos, ray_dir);\n            if (depth >= max_depth) break;\n\n            pos += ray_dir * depth;\n            fragColor.rgb += r_factor * sampler(pos, light_dir);\n            r_factor *= sample_reflect;\n        }\n    }\n}\n","name":"Image","description":"","type":"image"}]}