{"ver":"0.1","info":{"id":"3l3yzl","date":"1609676273","viewed":74,"name":"RayMarch study","username":"FunMaster","description":"First steps into raymarch","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sphere","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_DIST 0.01\n#define MAX_DIST 1000.\n#define EPSILON 0.00000001\n\n\nvec2 rotatePlane(in vec2 plane, in float angle){\n\treturn cos(angle) * plane + sin(angle) * vec2(plane.y, -plane.x);\n}\n\nvec3 rotate(in vec3 pos, in vec3 rot){\n    pos.yz = rotatePlane(pos.yz, rot.x);\n    \n    pos.xz = rotatePlane(pos.xz, rot.y);\n    \n    pos.xy = rotatePlane(pos.xy, rot.z);\n    \n    return pos;\n}\n\nfloat DistanceToPlane(in vec3 pos, in float planeOffset){\n    return pos.y + planeOffset;\n}\n\nfloat DistanceToBox(in vec3 pos, in vec3 scale){\n    vec3 q = abs(pos) - scale;\n  \n\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat DistanceToSphere(in vec3 pos, in vec3 spherePos, in float r){\n    return length(pos - spherePos) - r;\n}\n\nfloat smin(float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat DistanceTo(in vec3 pos){\n    return DistanceToBox(rotate(pos + vec3(7., -5., -20.), vec3(-0.1, sin(iTime), 0.)), vec3(3., 2., 3.));\n    //return smin(o, DistanceToSphere(pos, vec3(-5. + sin(iTime * 2.) * 5., 1., 20.), 3.), 1.);\n}\n\nfloat GetDist(vec3 pos){\n    float d = length(pos)-1.5;\n    return d*.7;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        DistanceTo(p-e.xyy),\n        DistanceTo(p-e.yxy),\n        DistanceTo(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetDirectLight(in vec3 normal, in vec3 lightDir){\n    return clamp(dot(lightDir, normal), 0., 1.);\n}\n\n\nfloat GetPointLightSpecular(in vec3 normal, in vec3 pos, in vec3 lightPos){\n    vec3 attenGrad = vec3(0.006, 0.003, 0.001);\n\n    vec3 lightDir = lightPos - pos;\n    float dist = length(lightDir);\n    lightDir /= dist;\n    vec3 halfVec = normalize(lightDir - vec3(0., 0., 0.));\n    \n    float distAtten = clamp(1. / (attenGrad.x + attenGrad.y * dist + attenGrad.z * dist * dist), 0., 1.);\n    \n    return pow(clamp(dot(normal, halfVec), 0., 1.), 32.) * distAtten;\n}\n\nfloat GetPointLight(in vec3 normal, in vec3 pos, in vec3 lightPos){\n    vec3 attenGrad = vec3(0.006, 0.003, 0.001);\n\n    vec3 lightDir = lightPos - pos;\n    float dist = length(lightDir);\n    lightDir /= dist;\n    \n    float distAtten = clamp(1. / (attenGrad.x + attenGrad.y * dist + attenGrad.z * dist * dist), 0., 1.);\n    return clamp(dot(normal, lightDir), 0., 1.) * distAtten;\n}\n\n\n\n\nvoid RayMarch(in vec3 rayPos, in vec3 rayDir, out bool back, out float dist){\n    \n    dist = 0.;\n    back = false;\n    \n    for (int i = 0; i < MAX_STEPS; i++){\n        if (dist > MAX_DIST){\n            back = true;\n            break;\n        }\n        else if (DistanceTo(rayPos + rayDir * dist) < MIN_DIST)\n            break;\n        dist += DistanceTo(rayPos + rayDir * dist);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    vec3 rayPos = vec3((iMouse.x) / -50., 2., 0.);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.));\n    float p;\n    bool back;\n    RayMarch(rayPos, rayDir, back, p);\n    vec3 pos = rayPos + rayDir * p;\n    \n   // pos = rotate(pos + vec3(7., -5., -20.), vec3(-0.1, sin(iTime), 0.));\n    \n    //pos *= 1. - float(back);\n    \n    vec3 normals = GetNormal(pos);\n    \n    vec3 an = abs(normals);\n    an = pow(an, vec3(3.));\n    \n    an /= an.x + an.y + an.z;\n    \n   // vec3 outColor = abs(normals);\n    //vec3 outColor = texture(iChannel0, pos.xy / 4. + 0.5).rgb * an.y;\n    //+ texture(iChannel0, pos.xz / 4. + 0.5).rgb * an.y \n    //+ texture(iChannel0, pos.xy / 4. + 0.5).rgb * an.z;\n    \n    //p = 0.1;\n   // p = GetDirectLight(normals, vec3(0.7, 0.4, 0.));\n    vec3 outColor = vec3(p + GetPointLightSpecular(normals, pos, vec3(-13., 11., 2.)) + 0.3 * GetPointLight(normals, pos, vec3(-13., 11., 2.)));\n    //outColor = pow(outColor, vec3(0.454));\n    \n    \n    fragColor = vec4(normals, 1.0);\n}","name":"Image","description":"","type":"image"}]}