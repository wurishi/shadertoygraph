{"ver":"0.1","info":{"id":"fd3fR4","date":"1656104804","viewed":140,"name":"Numeric Cubic Bezier SDF With L2","username":"Envy24","description":"https://www.desmos.com/calculator/5yqnm37ffx // contains errors\n\nOther implementations:\nhttps://www.shadertoy.com/view/4sXyDr\nhttps://www.shadertoy.com/view/4sKyzW\nhttps://www.shadertoy.com/view/7lsBW2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","bezier","distance","cubic","newton","segment","parametric","metric","raphson","l2","numeric"],"hasliked":0,"parentid":"7s3fzr","parentname":"Cubic Bezier SDF With Linf"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define NZMX                      ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define INITIALLY_FAR               9e30\n\nfloat L2(vec2 B, vec2 E)\n{\n    return length(E-B);\n}\n\n//#define P(t) (P0*(1.-t)*(1.-t)*(1.-t)+3.*P1*t*(1.-t)*(1.-t)+3.*P2*t*t*(1.-t)+P3*t*t*t)\n#define P(t) (P0 + t*(C + t*(B + t*A)))\nfloat cubicBezierSegmentSDF_L2(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3)\n{\n    vec2 A =   -P0+3.*P1-3.*P2+P3,\n         B = 3.*P0-6.*P1+3.*P2,\n         C =      -3.*P0+3.*P1,\n         D =          P0-NDC;\n    \n    float coef[6] = float[6](\n          6.*dot(A, A),\n          10.*dot(A, B),\n          4.*(2.*dot(A,C)+dot(B,B)),\n          6.*(dot(A,D)+dot(B,C)),\n          2.*(2.*dot(B,D)+dot(C,C)),\n          2.*dot(C,D)\n    );\n      \n    float minSqDist = INITIALLY_FAR;\n      \n    /* This divisions lets rewrite \n        ax^5+bx^4+cx^3+dx^2+ex+f = f+x(e+x(d+x(c+x(b+x*a))))\n    as   x^5+Ax^4+Bx^3+Cx^2+Dx+E = E+x(D+x(C+x(B+x(A+x))))      -1 mult op */\n    float invA=1.0/  coef[0];\n    coef[0] = 1.0;\n    coef[1] *= invA;\n    coef[2] *= invA;\n    coef[3] *= invA;\n    coef[4] *= invA;\n    coef[5] *= invA;\n\n    const float N = 20.0;\n    float dt = 1.0 / N;\n    vec2 diff = vec2(0);\n\n    for (float i = 1.; i < N; i += 1.0)\n    {\n        float t = findQuinticRootNewtonRaphson(\n            dt * i,\n            coef);\n\n        diff = vec2(P(clamp(t, 0.0, 1.0))) - NDC;\n\n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n    \n    diff = P0 - NDC; // vec2(P(0)) - NDC\n    minSqDist = min(minSqDist, dot(diff, diff));\n    diff = P3 - NDC; // vec2(P(1)) - NDC\n    minSqDist = min(minSqDist, dot(diff, diff));\n    \n    float R = sinOSC(0.0, 0.3, iTime);\n    return sqrt(minSqDist) - R;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = F*0.01, //0.3\n          waves_sdf = C + amp*smoothstep(8./iResolution.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./iResolution.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) * 2.0 :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.0;\n            //vec2(0);\n    \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L2(NDC, M) - abs(cubicBezierSegmentSDF_L2(M, P0, P1, P2, P3));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n/* IQ coloring scheme */\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float offs = sinOSC(-0.5, 0.5, iTime * 0.5);\n    vec2 NDC = TO_CENTERED_NDC(SC) * 3.0;\n    \n    vec2 P0 = vec2(2.0, 0.0) * 0.65; \n    vec2 P1 = vec2(8.0, -3.0);\n    vec2 P2 = vec2(-3.0, 6.0);\n    vec2 P3 = vec2(-2.0, 0.0) * 0.65;\n    \n    P0 = rotateAroundZ(P0, iTime * 0.1) + vec2(2.*offs, -offs);\n    P1 = rotateAroundZ(P1, iTime * 0.9) + vec2(-12.*offs, 0.0);\n    P2 = rotateAroundZ(P2, iTime * 0.9) + vec2(-8.*offs, 3.*offs);\n    P3 = rotateAroundZ(P3, iTime * 0.1) + vec2(-offs*offs, offs);\n        \n    float minDist = cubicBezierSegmentSDF_L2(NDC, P0, P1, P2, P3);\n    \n    // Blending.\n    vec3 color = colorize_field(minDist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_circle(NDC, P0, P1, P2, P3, color);\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.x * s + p.y * c);\n}\n\nfloat findQuinticRootNewtonRaphson(\n    float x,\n    float c[6])\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    float deriv = c[4] + x * (2.*c[3] + x * (3.*c[2] + x * (4.*c[1] + x * 5.)));\n    bool quit = abs(deriv) <= EPSILON;\n    \n    for (int i = 0; (i < 15) && (quit == false); ++i)\n    {\n        float f = (c[5] + x * (c[4] + x * (c[3] + x * (c[2] + x * (c[1] + x)))));\n        x -= f / deriv;          \n        deriv = c[4] + x * (2.*c[3] + x * (3.*c[2] + x * (4.*c[1] + x * 5.)));\n        quit = (abs(f) <= tolerance) || (abs(deriv) <= EPSILON);\n    }\n\n    return x;\n}","name":"Common","description":"","type":"common"}]}