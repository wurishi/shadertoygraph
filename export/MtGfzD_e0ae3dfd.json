{"ver":"0.1","info":{"id":"MtGfzD","date":"1541985358","viewed":111,"name":"Raymarch Distance","username":"gest","description":"exp0","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch3dcubemap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 u_canvas;\nvec3 u_mouse;\nfloat u_time;\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n//Дополнительные параметры, возвращаемые картой расстояний\nstruct Mapdata {\n\tfloat   distance;\t//Последнее приближение луча к элементу сцены (стремится к 0 в случае нахождения точки пересечения)\n\tint \tid;\t\t\t//id элемента сцены\n};\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tfloat distance; \t//Расстояние до точки элемента сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Текущая точка элемента сцены ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//Успех нахождения точки пересечения\n\tMapdata mapdata;\t//Дополнительные параметры, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формируем луч\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n//-------------Вспомогательные функции-----------------------------\n//Масштаб вектора\nvoid scale (inout vec3 v, vec3 s) {\n\tv = v * s;\n}\n//Перемещение вектора\nvoid translate (inout vec3 v, vec3 delta) {\n\tv = v - delta;\n}\n//Вращение вектора\nvoid rotate(inout vec3 v, vec3 rad) {\n\tvec3 c = cos(rad), s = sin(rad);\n\tif (rad.x!=0.) v = vec3(v.x, \t\t\t\t   c.x * v.y + s.x * v.z, -s.x * v.y + c.x * v.z);\n\tif (rad.y!=0.) v = vec3(c.y * v.x - s.y * v.z, v.y, \t\t\t\t   s.y * v.x + c.y * v.z);\n\tif (rad.z!=0.) v = vec3(c.z * v.x + s.z * v.y, -s.z * v.x + c.z * v.y, v.z\t\t\t\t\t);\n}\n//-------------------------------------------\n//Расстояние до бокса\nfloat dBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n//Расстояние до сферы\nfloat dSphere(vec3 p, float radius) { \n\treturn length(p) - radius; \n}\n//-------------------------------------------\n//Карта расстояний до элементов сцены\nfloat map (in vec3 p, out Mapdata mapdata) {\n\tmapdata.distance = Infinity;\n\tmapdata.id = 0;\n\tfloat d;\n\t//Куб\n\tvec3 p1 = p;\n\ttranslate(p1, vec3(-0.3, 0, 0));\n\trotate(p1, vec3(0,1,0)*u_time/4.);\n\td = min( mapdata.distance, dBox( p1 , vec3(0.2) ));\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance = d;\n\t\tmapdata.id = 1;\n\t}\n\t//Сфера\n\tvec3 p2 = p;\n\ttranslate(p2, vec3(0.3, 0, 0));\n\td = min( mapdata.distance, dSphere( p2, 0.2 ));\n\tif (mapdata.distance > d) {\n\t\tmapdata.distance = d;\n\t\tmapdata.id = 2;\n\t}\n\treturn mapdata.distance;\n}\n//Карта расстояний до элементов сцены (без дополнительных параметров)\nfloat map ( in vec3 p ) {\n\tMapdata mapdata;\n\treturn map (p, mapdata);\n}\n//Нормали в точке поверхности\nvec3 mapNormal( in vec3 p, float epsilon ) {\n\tmat3 eps = mat3(epsilon);\n\treturn normalize( vec3(\n\t\tmap( p + eps[0]) - map(p - eps[0]),\n\t\tmap( p + eps[1]) - map(p - eps[1]),\n\t\tmap( p + eps[2]) - map(p - eps[2])\n\t));\n}\n//Пересечение луча с элементами сцены\nint rayMarch( inout Ray ray ) {\n\t//Минимальное расстояник\n    ray.distance = ray.near;\n\t//Флаг пересечения\t\t\t\t\n    float d;\n    for (int i = 0; i < 1024; ++i) {\n\t\t//Проверка ограничения итераций\n\t\tif (i==ray.steps) break;\t\t\n\t\t//Текущая точка луча\n\t\tray.position = ray.origin + ray.distance * ray.direction;\t\n\t\t//Минимальное расстояние до элемента сцены\n        d = map(ray.position, ray.mapdata);\t\t\n        ray.hit = abs(d) < ray.epsilon;\n        //Проверка достижения требуемой точности\n\t\tif (ray.hit) return i;    \n\t\t//Перемещаем точку луча\n        ray.distance += d;\t\t\t\t\n\t\t//Проверка достижения предельной дистанции\n        if (ray.distance > ray.far) return i;\t\n    }\n\treturn ray.steps;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    //Адаптер\n    u_time = iTime;\n    u_canvas = iResolution.xy;\n    u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = gl_FragCoord.xy / u_canvas.xy;\n    uv = -1. + 2.*uv;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n    mouse.xy = mouse.xy - 0.5;\n    mouse.xy = (u_mouse.xy==vec2(0)) ? (vec2(0)) : (mouse.xy);\n\n    //Формируем камеру\n    Camera cam;\n    {\n        cam.fov \t= 45.;\n        cam.aspect\t= aspect;\n\n        cam.origin \t= vec3(0, 1, 1);\n        translate (cam.origin, vec3(0, 1.+ mouse.y*3.5, 0));\n        rotate (cam.origin, vec3(0,1,0)*(mouse.x*3.5 + PI));\n\n        cam.target \t= vec3(0,0,0); \n        cam.up \t\t= vec3(0,1,0);\n    }\n    //Формируем луч\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.;\n        ray.far  \t= 10.;\n        ray.epsilon = 0.001;\n        ray.steps \t= int( floor(mod(u_time*10.,64.)));   //Число итераций\n    }\n    rayMarch(ray);\n\n\n    vec3 color = texture(iChannel0, ray.direction).rgb;\n\n\n    #if 0\n        if (ray.distance < ray.far ) { //Условие не достижения предельной дистанции\n\t\t\t\n            vec3 n = mapNormal( ray.position, ray.epsilon );\n            \n            Ray ray1 = ray;\n            {\n                ray1.origin \t= ray.position;\n                ray1.direction \t= reflect(ray.direction, n);\n                ray1.near \t\t= 0.01; //Отступаем от поверхности\n            }\n            rayMarch(ray1);\n\n            if (ray1.distance < ray1.far) { //Условие не достижения предельной дистанции\n                n = mapNormal( ray1.position, ray1.epsilon );\n                color = texture(iChannel0, reflect(ray1.direction, n)).rgb * 2.0;\n            } else {\n                color = texture(iChannel0, reflect(ray.direction, n)).rgb * 2.0;\n            }\n        }\n    #endif\n    \n    #if 1\n        if (ray.hit) { //Условие пересечения с элементом сцены\n            \n            vec3 n = mapNormal( ray.position, ray.epsilon );\n            \n            //Отражение\n            Ray ray1 = ray;\n            {\n                ray1.origin \t= ray.position;\n                ray1.direction \t= reflect(ray.direction, n);\n                ray1.near \t\t= 0.01;\t//Отступаем от поверхности\n            }\n            rayMarch(ray1);\n\n            if (ray1.hit) { //Условие пересечения с элементом сцены\n                n = mapNormal( ray1.position, ray1.epsilon );\n                color = texture(iChannel0, reflect(ray1.direction, n)).rgb * 2.0;\n            } else {\n                //Условие не достижения предельной дистанции\n                color = texture(iChannel0, reflect(ray.direction, n)).rgb * 2.0;\n            }\n        }\n    #endif\n\n    // Output to screen\n    GL_FragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}