{"ver":"0.1","info":{"id":"7d2SWD","date":"1620300456","viewed":190,"name":"Hexagon Triangle Pixel Filter","username":"NakedBowman","description":"Triangulates in an hexagon shape any some image you throw at it","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["triangle","pixel","filter","hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Setup\n    vec2 uv = fragCoord/iResolution.xy;\n    float d, f =0.;\n    \n    float size = 30.;\n    float outline = abs(sin(iTime)*.2);\n    bool mirror = false;\n      \n    size = (iResolution.y-iResolution.x)/size;\n    float pixelSize = iResolution.y /size;\n    float imagePixelX = pixelSize / iResolution.x;\n    float imagePixelY = pixelSize / iResolution.y;\n\n    //uv+=iTime*0.05;//DEMO\n    float x = imagePixelX * floor(uv.x / imagePixelX);\n    float y = imagePixelY * floor(uv.y / imagePixelY);\n    \n    float j = size * iResolution.x/iResolution.y;\n    j = size/j*0.5;\n    float x2 = imagePixelX * floor((uv.x-j/size)/ imagePixelX);\n    float y2 = imagePixelY * floor(uv.y / imagePixelY);\n    \n     \n    uv.x *= iResolution.x/iResolution.y;\n    uv*=size;\n    //get the Tiles Lines\n    float tx = floor(uv.x);\n    float ty = floor(uv.y);\n \n    uv=fract(uv);\n    float border;\n    float backBorder;\n    \n    float back = 0.;\n    float front =1.;\n      \n    ///Check if mirror\n    if(floor(ty / 2.)*2. == ty){\n       mirror = true;\n    }\n    \n    ///Draw triangles\n    if(mirror){\n     \n       d = step((0.),uv.x - uv.y*0.5);\n       f = step((1.),uv.x + uv.y*0.5);\n       back+=d-f;\n       front-=d-f;\n       //front border        \n       border = step(-outline,uv.x - uv.y*0.5);\n       border -= step(1.+outline,uv.x + uv.y*0.5);\n       border += step(1.-outline, uv.y);\n       border =(border -1.) * -1.;\n       front*=border;\n       \n       //back border\n       backBorder=step(outline,uv.x - uv.y*0.5);\n       backBorder-=step((1.-outline),uv.x + uv.y*0.5);\n       back*=backBorder;\n       back*=step(outline,uv.y);\n       \n    }       \n    else{\n    \n      d = step((0.5),uv.x - uv.y*0.5);\n      f = step((0.5),uv.x + uv.y*0.5);\n      back+=f-d;\n      front-=f-d;\n       \n      border = step(0.5 - outline,uv.x + uv.y*0.5);\n      border -= step(0.5 + outline,uv.x - uv.y*0.5);\n      border += step(-outline, -uv.y);\n        \n      border = (border -1.) * -1.;\n      front*=border;\n         \n      //back border\n      backBorder=step(0.5 + outline,uv.x + uv.y*0.5);\n      backBorder-=step(0.5 - outline,uv.x - uv.y*0.5);\n      back*=backBorder;\n      back = back*((step(1.-outline,uv.y) -1.)*-1.);\n        \n    }      \n          \n    \n   \n    vec4 pixel_f = texture(iChannel0, vec2(x2,y2))*front;\n    vec4 pixel_b = texture(iChannel0, vec2(x+0.01,y+0.01))*back;  \n\n    pixel_f+=pixel_b;\n        \n    // Output to screen\n    fragColor = vec4(vec3(pixel_f),1);\n}","name":"Image","description":"","type":"image"}]}