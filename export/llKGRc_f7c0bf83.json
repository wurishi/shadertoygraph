{"ver":"0.1","info":{"id":"llKGRc","date":"1475995072","viewed":133,"name":"Spot the Artifact","username":"sillsm","description":"Why is there an artifact in the right mirrored branch? ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bugs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Max Sills 2016, licensed under the MIT license.\n// Plasma tree\n#define PI 3.14159265\n#define MIRROR\n\n#define MAT_PLANE .9     \n#define MAT_TREE  .1\n\n//--------------------------------------------------------------------------\nmat4 Ry (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, 0, -s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Rz (float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \nreturn  mat4(\n        vec4(c, s, 0, 0),\n        vec4(-s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n); \n}\n\nmat4 Disp (vec3 displacement)\n{\nreturn  mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(displacement, 1)\n); \n}\n//--------------------------------------------------------------------------\n\nvec2 opU( float d1, float d2, float m1, float m2 )\n{\n    return (d1<d2) ? vec2(d1, m1) : vec2(d2, m2);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  p -= vec3(0.,h.y, 0);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p )\n{ \n\treturn p.y;\n}\n//--------------------------------------------------------------------------\nfloat tree (vec3 p)\n{\n    float l = 1.4;\n    float trunk = sdCappedCylinder(p, vec2(.25,l));\n    \n    mat4 m1 = Rz(iTime) * Disp(vec3(0,-l,-.5));\n\n    p.x *= sign(p.z);\n    p.z = abs(p.z);\n    p = (m1 * vec4(p, 1.)).xyz;\n    float t2 = sdCappedCylinder(p, vec2(.25,l));\n    \n    return min(trunk, t2);\n}\n//--------------------------------------------------------------------------\n// Returns distance_to_shape, material index\nvec2 scene(vec3 ray)  \n{\n    vec2 objs = opU(tree(ray), sdPlane(ray), MAT_TREE, MAT_PLANE);\n    return objs ;\n}\n\nvec2 trace(vec3 ray, vec3 viewportxy)\t\t\t\t\n{\n    const float hitThreshold = 0.001;\n    vec3 p = vec3(0);\n    float t = 0.0;\n    float m = 0.0;\n    for (int i = 0; i < 100; ++i)\t\t\t\t\n    {\t\n        p = viewportxy + (t* ray);\n        vec2 data = scene(p);\n        float dist = data.x;\n        m  = data.y;\n        t += dist;// * .9;\n        \n        if ( dist < hitThreshold ){\n            break;\n        }\n    }\n    return vec2(t, m);\t\t\t\t\t\t\n}\n\n// iq normal\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n\t    scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n\t    scene(pos+eps.yyx).x - scene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// Compute the camera to world transform.\n// Rotates then translates.\nmat4 LookAtRH( vec3 eye, vec3 target, vec3 up )\n{\n    vec3 zaxis = normalize(target-eye);      // The \"forward\" vector.\n    vec3 xaxis = normalize(cross(up, zaxis));// The \"right\" vector.\n    vec3 yaxis = cross(zaxis, xaxis);        // The \"up\" vector.\n\n    return  mat4(\n        vec4(      xaxis,       0 ),\n        vec4(      yaxis,       0 ),\n        vec4(      zaxis,       0 ),\n        vec4(      eye,         1 )\n    );\n}\n\n// Stolen from ming's tutorial.\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.1;\n\t//float vis = shadow( pos, toLight, 0.01, toLightLen );\n\tfloat vis = 1.;//shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n\t\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n\t\tcomb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\n// Given distance to shape, material index, world coord, and pixel, color.\nvec4 color (float t, float m, vec3 p)\n{\n\n    vec4 col = vec4(0.0);\n    if (abs(p.x) > 10. || abs(p.z) > 10.) {\n        return vec4(0.);\n    }\n    else if (abs(m -MAT_TREE) < .001) {\n         vec4 brown = vec4(.8, .6, .45, 1.);\n         col = brown;\n         return 10.*(1./t)*col;\n    }else if( abs(m -MAT_PLANE) < .001 ){\n         float f = mod( floor(p.z) + floor(p.x), 2.0);\n         return vec4( 0.8 + 0.1*f*vec3(1.0), 1.);\n    } \n    return col;\n}\n\n// returns pixel color\nvec4 render(vec3 ray, vec3 pt)\n{\n    vec2 tm    = trace(ray, pt);\n    float t    = tm.x;\n    float mat  = tm.y;\n    vec3 point = pt + (t* ray);\n    return color(t, mat, point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\t\t\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float f = 3.; // f-stop.\n    vec4 pixel = vec4(uv, 0, 1);\n    \n    //position += vec3(0., 0., sin(iTime)*10.);\n    vec3 position = vec3(cos(iMouse.x/100. - .8)*10., 3., sin(iMouse.y/100.-.3)*10.);\n    //position -= vec3(0,iMouse.y/200.,-iMouse.x/20.);\n    \n    #ifdef DEBUG\n    position = vec3(0,40,1);\n    #endif\n    \n    mat4 mat = LookAtRH(position, vec3(0,0,0), vec3(0,1,0));\n    vec3 pt = (mat*pixel).xyz;\n    vec3 ray = normalize(mat*(pixel - vec4(0,0,-f,1))).xyz;\n    \n    fragColor   = render(ray, pt);\n}","name":"Image","description":"","type":"image"}]}