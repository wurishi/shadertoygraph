{"ver":"0.1","info":{"id":"XsBfzW","date":"1499651861","viewed":185,"name":"Ã‰querre Recursive Filling Curve","username":"ttoinou","description":"A few recursives rules about which sides the curve goes from and to generate a nice curve that goes through each sub equerre. I'm not sure the curve is 2D filling the main Equerre (maybe only by taking the incenter point... click on the upper right)\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["triangle","tiling","kisrhombille","reptile","equerre"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHOW_POINTS 1\n#define SHOW_SEGMENTS 1\n#define SHOW_DUAL_POINTS 1\n#define SHOW_DUAL 1\n\n// segment.x is distance to closest point\n// segment.y is barycentric coefficient for closest point\n// segment.z is length of closest point on curve, on the curve, starting from A\n// segment.a is approximate length of curve\nvec4 segment( vec2 p, vec2 a, vec2 b )\n{\n  a -= p;\n  b -= p;\n  vec3 k = vec3( dot(a,a) , dot(b,b) , dot(a,b) );\n  float t = (k.x - k.z)/( k.x + k.y - 2.*k.z );\n  float len = length(b-a);\n    \n  if( t < 0. ){\n      return vec4( sqrt(k.x) , 0. , 0. , len );\n  } else if( t > 1. ){\n      return vec4( sqrt(k.y) , 1. , len , len );\n  } else {\n  \treturn vec4( length(a*(1.-t) + b*t) , t , t*len , len );\n  }\n}\n\n// https://www.shadertoy.com/view/4djSRW\n#define ITERATIONS 4\n\n\n// *** Change these to suit your range of random numbers..\n\n// *** Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3point(vec2 p)\n{\n    //vec3 col = hash32(p);\n    vec3 col = \n            hash32(p*1.25672+vec2(.2,.8))\n          * hash32(vec2(p.y,p.x)/3.42464-vec2(.5,.0))\n          - hash32(vec2(3.0+p.y,1.2))\n    ;\n    \n    return pow(\n        (abs(col)+max(col,0.0))/2.0\n        , vec3(.6,.5,.4)\n    );\n}\n\nfloat smoothFunction(float k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\nvec3 smoothFunction(vec3 k)\n{\n    return 1.0 / ( 1.0 + k*k );\n}\n\n\nfloat coeffDistPoint(vec2 uv,vec2 colPoint,float scale)\n{    \n    //float dist = length(uv - colPoint) * scale;\n    //dist = pow(dist,0.25);\n    //dist = 1.0 - smoothstep(0.0,1.0,dist);\n    \n    vec2 uv_ = (uv - colPoint)*scale*24.0;\n    float dist = dot(uv_,uv_);\n    return  1.0 / ( 1.0 + dist );\n}\n\nvoid mixColorPoint(vec2 uv,inout vec3 col,vec2 colPoint,float scale)\n{\n    col = mix(\n        col , \n        hash3point(colPoint) ,\n        coeffDistPoint(uv,colPoint,scale)\n    );\n}\n\n\nvec3 mixColorLine(vec2 uv,vec3 currentCol,vec3 colLine,vec2 lineA,vec2 lineB,float scale)\n{\n    return mix(\n        currentCol , \n        colLine ,\n        1.0 - smoothstep(0.0,1.0,sqrt(sqrt( segment(uv,lineA,lineB).x * scale )))\n    );\n}\n\nbool pointsOnSameSideOfLine(vec2 pointA,vec2 pointB,vec2 lineA, vec2 lineB)\n{\n    vec2 n = lineB - lineA;\n    n = vec2(n.y,-n.x);\n    return  dot(pointA-lineA,n)\n          * dot(pointB-lineA,n)\n    > 0.0;\n}\n\n\nfloat viewportMagnify = 1.0;\nvec2 screenToViewport(vec2 uv)\n{\n    return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\nvec2 viewportToScreen(vec2 uv,vec2 base)\n{\n    return (uv - base/4.0) / viewportMagnify * min(iResolution.x,iResolution.y) +  iResolution.xy/2.0;\n    //return (uv - iResolution.xy/2.0 ) / min(iResolution.x,iResolution.y) * viewportMagnify;\n}\n\n// there is three kind of points\n// in kisrhombille\n// named here A,B,C\nstruct Equerre\n{\n    vec2 A; // Right angle  => 4 connections\n    vec2 B; // Acute angle  => 12 connections\n    vec2 C; // Obtuse angle => 6 connections\n    \n    vec2 D; // on AB\n    vec2 E; // on BC\n};\n    \n// when decomposing an A,B,C triangle into thre subtriangles\n// A & B stays respectively A & B points\n// C becomes a B point\n// D created is a C point\n// E created is an A point\n    \nfloat det22(vec2 a,vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 barycentricCoordinate(vec2 P,Equerre T)\n{\n    vec2 PA = P - T.A;\n    vec2 PB = P - T.B;\n    vec2 PC = P - T.C;\n    \n    vec3 r = vec3(\n        det22(PB,PC),\n        det22(PC,PA),\n        det22(PA,PB)\n    );\n    \n    return r / (r.x + r.y + r.z);\n}\n    \n#define EQUERRE_COPY(T,Q) \\\n    T.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n    \n#define EQUERRE_COMPUTE_DE(T) \\\n\tT.D = (2.0 * T.A + T.B)/3.0; \\\n\tT.E = (T.B + T.C)/2.0;\n    \n#define EQUERRE_GET1(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET2(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.B; \\\n    T.C = Q.D;\n\n#define EQUERRE_GET3(T,Q) \\\n\tT.A = Q.E; \\\n    T.B = Q.C; \\\n    T.C = Q.D;\n\n\n#define EQUERRE_GET_NEIGHBOUR_AB(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = Q.B; \\\n    T.C = 2.0 * Q.A - Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_AC(T,Q) \\\n\tT.A = Q.A; \\\n    T.B = 2.0 * Q.A - Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_GET_NEIGHBOUR_BC(T,Q) \\\n\tT.A = (3.0 * Q.C + Q.B)/2.0 - Q.A; \\\n    T.B = Q.B; \\\n    T.C = Q.C;\n\n#define EQUERRE_COND1(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.A,T.D,T.C)\n \n#define EQUERRE_COND2(X,T) \\\n\tpointsOnSameSideOfLine(uv,T.B,T.D,T.E)\n\n#define EQUERRE_CENTER(T) ((T.A+T.B+T.C)/3.0)\n        \n#define _AB_ (1)\n#define _BC_ (2)\n#define _CA_ (3)\n        \n#define _ALPHA_ _AB_\n#define _BETA_  _BC_\n#define _GAMMA_ _CA_\n        \n#define _REPLACE_(X,Y,Z,T) \\\n        if( Begin == X && End == Y && !operation ) { \\\n            Begin = Z; End = T; operation = true; \\\n        } else if( End == X && Begin == Y && !operation) { \\\n            End = Z; Begin = T; operation = true; \\\n        }\n\n#define _SWAP_(X,Y) _REPLACE_(X,Y,Y,X)\n\n#define _SWAP_KEEP_BETA_ \\\n\t_REPLACE_(_BETA_,_ALPHA_,_BETA_,_GAMMA_) \\\n\t_REPLACE_(_BETA_,_GAMMA_,_BETA_,_ALPHA_) \\\n\n#define _SWAP_KEEP_GAMMA_ \\\n\t_REPLACE_(_GAMMA_,_ALPHA_,_GAMMA_,_BETA_) \\\n\t_REPLACE_(_GAMMA_,_BETA_,_GAMMA_,_ALPHA_) \\\n\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0);\n    \n    int nbIterations = 1 + int(floor(pow((1.0 - cos(iTime*3.14/13.0))/2.0,0.5)*7.1));\n    \n\tint EquerreVersion = 1;\n    vec2 base = vec2(sqrt(3.0),1.0);\n    base *= 1.0;\n    \n    \n\tvec2 uv = screenToViewport(fragCoord.xy );\n    \n    viewportMagnify = 1.25;\n    uv *= viewportMagnify;\n    uv += base/2.25;\n    \n    // Base Triangle\n    Equerre Tri;\n    Equerre Tri_TMP;\n    Tri.A = Tri.B = Tri.C = vec2(0.0);\n    Tri.B.x += base.x;\n    Tri.C.y += base.y;\n    \n    int Begin = _GAMMA_;\n    int End   = _ALPHA_;\n    bool operation;\n    \n    for(int i = 0 ; i < nbIterations ; i++)\n    {\n        EQUERRE_COMPUTE_DE(Tri);\n        operation = false;\n        \n        if( EQUERRE_COND1(uv,Tri) )\n        {\n            EQUERRE_GET1(Tri_TMP,Tri);\n            \n            _REPLACE_(_ALPHA_,_GAMMA_,_BETA_,_ALPHA_)\n            _SWAP_KEEP_BETA_\n        }\n        else if( EQUERRE_COND2(uv,Tri) )\n        {\n            EQUERRE_GET2(Tri_TMP,Tri);\n            \n            _SWAP_KEEP_GAMMA_\n            _REPLACE_(_ALPHA_,_BETA_,_GAMMA_,_ALPHA_)\n        }\n        else \n        {\n            EQUERRE_GET3(Tri_TMP,Tri);\n            \n            _SWAP_(_GAMMA_,_BETA_)\n                \n            _REPLACE_(_ALPHA_,_BETA_,_BETA_,_GAMMA_)\n            _REPLACE_(_ALPHA_,_GAMMA_,_GAMMA_,_BETA_)\n        }\n        \n        fragColor.rgb = 1.15 - fragColor.gbr;\n        EQUERRE_COPY(Tri,Tri_TMP);\n    }\n    \n    fragColor.rgb = vec3(1.0);\n    \n    float scale = float(nbIterations);\n    scale = pow(2.0,scale)/viewportMagnify/scale;\n    \n    vec3 EquerreCoeffs = barycentricCoordinate(uv,Tri);\n    vec3 EquerreColor =\n          EquerreCoeffs.x * hash3point(Tri.A)\n        + EquerreCoeffs.y * hash3point(Tri.B)\n        + EquerreCoeffs.z * hash3point(Tri.C)\n    ;//vec3(1.0,0.0,0.0);\n    \n    vec3 EquerreDualColor = vec3(0.0,0.0,0.0);\n    \n    #if SHOW_SEGMENTS==1\n        #define OPERATION1(x,y) fragColor.rgb = mixColorLine(uv,fragColor.rgb,EquerreColor,x,y,scale);\n    \tOPERATION1(Tri.A,Tri.B);\n    \tOPERATION1(Tri.B,Tri.C);\n    \tOPERATION1(Tri.C,Tri.A);\n    #endif\n    \n    scale /= sqrt(float(nbIterations));\n   \n    #if SHOW_POINTS==1\n    \t#define OPERATION2(x) fragColor.rgb = mix( EquerreColor , fragColor.rgb , 1.0 - coeffDistPoint(uv,x,scale))\n    \n        OPERATION2(Tri.A);\n        OPERATION2(Tri.B);\n        OPERATION2(Tri.C);\n    \n    #endif\n    \n    float k = iTime/1.0*3.14;\n    vec2 mouse = iMouse.z > .5 ?\n          iMouse.xy / iResolution.xy\n        : vec2(1.0/3.0) + 0.15 * vec2(cos(k),sin(k));\n    vec3 coeffs;\n    coeffs.xy = mouse.xy;\n    coeffs.z = 1.0 - mouse.x - mouse.y;\n    if( coeffs.z < 0.0 )\n    {\n        coeffs.x = 2.0;\n        coeffs.y = 1.0;\n        coeffs.z = sqrt(3.0);\n        coeffs /= coeffs.x + coeffs.y + coeffs.z;\n    }\n    \n    #define EQUERRE_CENTER_MIX(T) (T.A * coeffs.x + T.B * coeffs.y + T.C * coeffs.z)\n    vec2 TriCenterMix = EQUERRE_CENTER_MIX(Tri);\n    \n    #if SHOW_DUAL_POINTS==1\n        fragColor.rgb = mix( EquerreDualColor , fragColor.rgb , 1.0 - coeffDistPoint(uv,TriCenterMix,scale));\n    #endif\n           \n    scale = 1.0 / iResolution.y * viewportMagnify;\n    float lineCoeff = 1000.0;\n           \n    \n    \n    #if SHOW_DUAL==1\n    \tEquerre Neighbour;\n    \n        #define OPERATION3(X,Y) \\\n    \t\tlineCoeff = min(lineCoeff,segment(uv,X,Y).x);\n    \n    \tif( Begin == _AB_ || End == _AB_) {\n    \t  EQUERRE_GET_NEIGHBOUR_AB(Neighbour,Tri);\n    \t  OPERATION3(EQUERRE_CENTER_MIX(Neighbour),TriCenterMix);\n    \t}\n    \n    \tif( Begin == _BC_ || End == _BC_) {\n    \t  EQUERRE_GET_NEIGHBOUR_BC(Neighbour,Tri);\n    \t  OPERATION3(EQUERRE_CENTER_MIX(Neighbour),TriCenterMix);\n    \t}\n    \n    \tif( Begin == _CA_ || End == _CA_) {\n    \t  EQUERRE_GET_NEIGHBOUR_AC(Neighbour,Tri);\n    \t  OPERATION3(EQUERRE_CENTER_MIX(Neighbour),TriCenterMix);\n    \t}\n    \n    \tlineCoeff = smoothFunction(lineCoeff/scale);\n    \n    \tfragColor.rgb = mix(\n              fragColor.rgb\n            , EquerreDualColor\n            , clamp(lineCoeff,0.0,1.0)\n        );\n    \n    #endif\n    \n    fragColor.rgb = tanh(fragColor.rgb*2.5);\n}","name":"Image","description":"","type":"image"}]}