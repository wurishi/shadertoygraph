{"ver":"0.1","info":{"id":"lclSRN","date":"1705013761","viewed":67,"name":"Simple 4D Raymarcher - Jcode","username":"Jcodefox","description":"Move up and down with space and shift\nMove left and right with a and d\nMove forward and back with w and s\nMove ana and kata with f and r\nClick and drag to look around","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat5x5 transformb = IDENTITY_MAT5x5;\n\nvec3 screen_to_world(vec2 screen_coords){\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec2 uv = screen_coords/iResolution.xy;\n    return vec3(vec2(aspect_ratio, 1.0) * ((uv * 2.0) - vec2(1.0)), 0.0);\n}\n\nfloat cube_vec4(vec4 ray){\n    vec4 d = abs(ray) - 0.5;\n    float inner_dist = min(max(d.x, max(d.y, max(d.z, d.w))), 0.0);\n    float outer_dist = length(max(d, 0.0));\n\n    return inner_dist + outer_dist;\n}\n\nfloat sphere_vec4(vec4 ray){\n    return length(ray);\n}\n\nvec2 obj_union(vec2 l, vec2 r){\n    return (l.y < r.y) ? l : r;\n}\n\nvec2 world_dist(vec4 ray){\n    vec2 resulta = vec2(1.0, 10000.0);\n    float last_dist = resulta.y;\n    int i = 0;\n    for (int z = 0; z < 3; z++){\n        for (int x = 0; x < 3; x++){\n            for (int y = 0; y < 3; y++){\n                vec2 resultb = vec2(float(x + 1) * 1.0, 10000.0);\n                vec4 pos = vec4(float(x * 2), float(y * 2), float(z * 2), 0.0);\n                mat5x5 transformc = multiply_mat5x5(translate(IDENTITY_MAT5x5, ray + pos), transformb);\n\n                if (i % 2 == 0){\n                    resultb.y = min(resultb.y, sphere_vec4(vec4_from_mat5x5(transformc)) - 0.5);\n                }else{\n                    resultb.y = min(resultb.y, cube_vec4(vec4_from_mat5x5(transformc)));\n                }\n                if (resultb.y < resulta.y){\n                    resulta = resultb;\n                }\n                i++;\n            }\n        }\n    }\n\n    return resulta;\n}\n\nvec2 march_ray(vec4 ray, vec4 dir){\n    const float EPSILON = 0.01;\n\n    float depth = 0.0;\n    vec2 result = vec2(0.0);\n\n    for (int i = 0; i < 50; i++){\n        result = world_dist(ray + dir * depth);\n        depth += result.y;\n        if (result.y < EPSILON){\n            return result;\n        }\n        if (depth > 40.0){\n            return vec2(0.0);\n        }\n    }\n    return vec2(0.0);//result;\n}\n\n#define PI  3.141592653589793238462643383279\n#define TAU 6.283185307179586476925286766559\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    transformb = multiply_mat5x5(transformb, generate_xy_rotation(iTime * 0.2));\n    transformb = multiply_mat5x5(transformb, generate_xz_rotation(iTime * 0.3));\n    transformb = multiply_mat5x5(transformb, generate_yz_rotation(iTime * 0.5));\n    transformb = multiply_mat5x5(transformb, generate_xw_rotation(iTime * 0.7));\n    transformb = multiply_mat5x5(transformb, generate_yw_rotation(iTime * 0.11));\n    transformb = multiply_mat5x5(transformb, generate_zw_rotation(iTime * 0.13));\n\n    float zoom = 500.0;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec2 norm_fragCoord = fragCoord;\n    norm_fragCoord.x *= aspect_ratio;\n    norm_fragCoord = (norm_fragCoord / iResolution.xy - vec2(aspect_ratio * 0.5, 0.5)) * zoom;\n    vec2 mouse_pos = (screen_to_world(iMouse.xy).xy - vec2(1.0, 0.0)) * vec2(PI * 0.5);\n    vec4 cam_pos = texelFetch(iChannel0, ivec2(0, 0), 0) + vec4(-2, -2, 10, 0);\n\n    vec4 rot = texelFetch(iChannel0, ivec2(1, 0), 0);\n\n    mat5x5 transform = IDENTITY_MAT5x5;\n    transform = translate(transform, vec4(norm_fragCoord * 0.001, -1.0, 0.0));\n    transform = multiply_mat5x5(transform, generate_yw_rotation(rot.y));\n    transform = multiply_mat5x5(transform, generate_xw_rotation(rot.x));\n    transform = multiply_mat5x5(transform, generate_xy_rotation(rot.w));\n\n    vec4 ray_dir = normalize(vec4_from_mat5x5(transform));\n\n    vec2 result = march_ray(cam_pos, ray_dir);\n\n    vec3 col = vec3(result.x);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct vec5{\n    float x;\n    float y;\n    float z;\n    float w;\n    float v;\n};\n\nstruct mat5x5{\n    vec5 a;\n    vec5 b;\n    vec5 c;\n    vec5 d;\n    vec5 e;\n};\n\nconst mat5x5 IDENTITY_MAT5x5 = mat5x5(\n    vec5(1.0, 0.0, 0.0, 0.0, 0.0),\n    vec5(0.0, 1.0, 0.0, 0.0, 0.0),\n    vec5(0.0, 0.0, 1.0, 0.0, 0.0),\n    vec5(0.0, 0.0, 0.0, 1.0, 0.0),\n    vec5(0.0, 0.0, 0.0, 0.0, 1.0)\n);\n\nvec4 vec4_from_mat5x5(mat5x5 matrix){\n    return vec4(matrix.a.v, matrix.b.v, matrix.c.v, matrix.d.v);\n}\n\nvec5 multiply_mat5x5_vec5(mat5x5 l, vec5 r){\n    vec5 rs;\n\n    rs.x = l.a.x * r.x + l.b.x * r.y + l.c.x * r.z + l.d.x * r.w + l.e.x * r.v;\n    rs.y = l.a.y * r.x + l.b.y * r.y + l.c.y * r.z + l.d.y * r.w + l.e.y * r.v;\n    rs.z = l.a.z * r.x + l.b.z * r.y + l.c.z * r.z + l.d.z * r.w + l.e.z * r.v;\n    rs.w = l.a.w * r.x + l.b.w * r.y + l.c.w * r.z + l.d.w * r.w + l.e.w * r.v;\n    rs.v = l.a.v * r.x + l.b.v * r.y + l.c.v * r.z + l.d.v * r.w + l.e.v * r.v;\n\n    return rs;\n}\n\nmat5x5 multiply_mat5x5(mat5x5 l,mat5x5 r){\n    mat5x5 rs;\n\n    rs.a.x = l.a.x * r.a.x + l.b.x * r.a.y + l.c.x * r.a.z + l.d.x * r.a.w + l.e.x * r.a.v;\n    rs.a.y = l.a.y * r.a.x + l.b.y * r.a.y + l.c.y * r.a.z + l.d.y * r.a.w + l.e.y * r.a.v;\n    rs.a.z = l.a.z * r.a.x + l.b.z * r.a.y + l.c.z * r.a.z + l.d.z * r.a.w + l.e.z * r.a.v;\n    rs.a.w = l.a.w * r.a.x + l.b.w * r.a.y + l.c.w * r.a.z + l.d.w * r.a.w + l.e.w * r.a.v;\n    rs.a.v = l.a.v * r.a.x + l.b.v * r.a.y + l.c.v * r.a.z + l.d.v * r.a.w + l.e.v * r.a.v;\n\n    rs.b.x = l.a.x * r.b.x + l.b.x * r.b.y + l.c.x * r.b.z + l.d.x * r.b.w + l.e.x * r.b.v;\n    rs.b.y = l.a.y * r.b.x + l.b.y * r.b.y + l.c.y * r.b.z + l.d.y * r.b.w + l.e.y * r.b.v;\n    rs.b.z = l.a.z * r.b.x + l.b.z * r.b.y + l.c.z * r.b.z + l.d.z * r.b.w + l.e.z * r.b.v;\n    rs.b.w = l.a.w * r.b.x + l.b.w * r.b.y + l.c.w * r.b.z + l.d.w * r.b.w + l.e.w * r.b.v;\n    rs.b.v = l.a.v * r.b.x + l.b.v * r.b.y + l.c.v * r.b.z + l.d.v * r.b.w + l.e.v * r.b.v;\n\n    rs.c.x = l.a.x * r.c.x + l.b.x * r.c.y + l.c.x * r.c.z + l.d.x * r.c.w + l.e.x * r.c.v;\n    rs.c.y = l.a.y * r.c.x + l.b.y * r.c.y + l.c.y * r.c.z + l.d.y * r.c.w + l.e.y * r.c.v;\n    rs.c.z = l.a.z * r.c.x + l.b.z * r.c.y + l.c.z * r.c.z + l.d.z * r.c.w + l.e.z * r.c.v;\n    rs.c.w = l.a.w * r.c.x + l.b.w * r.c.y + l.c.w * r.c.z + l.d.w * r.c.w + l.e.w * r.c.v;\n    rs.c.v = l.a.v * r.c.x + l.b.v * r.c.y + l.c.v * r.c.z + l.d.v * r.c.w + l.e.v * r.c.v;\n\n    rs.d.x = l.a.x * r.d.x + l.b.x * r.d.y + l.c.x * r.d.z + l.d.x * r.d.w + l.e.x * r.d.v;\n    rs.d.y = l.a.y * r.d.x + l.b.y * r.d.y + l.c.y * r.d.z + l.d.y * r.d.w + l.e.y * r.d.v;\n    rs.d.z = l.a.z * r.d.x + l.b.z * r.d.y + l.c.z * r.d.z + l.d.z * r.d.w + l.e.z * r.d.v;\n    rs.d.w = l.a.w * r.d.x + l.b.w * r.d.y + l.c.w * r.d.z + l.d.w * r.d.w + l.e.w * r.d.v;\n    rs.d.v = l.a.v * r.d.x + l.b.v * r.d.y + l.c.v * r.d.z + l.d.v * r.d.w + l.e.v * r.d.v;\n\n    rs.e.x = l.a.x * r.e.x + l.b.x * r.e.y + l.c.x * r.e.z + l.d.x * r.e.w + l.e.x * r.e.v;\n    rs.e.y = l.a.y * r.e.x + l.b.y * r.e.y + l.c.y * r.e.z + l.d.y * r.e.w + l.e.y * r.e.v;\n    rs.e.z = l.a.z * r.e.x + l.b.z * r.e.y + l.c.z * r.e.z + l.d.z * r.e.w + l.e.z * r.e.v;\n    rs.e.w = l.a.w * r.e.x + l.b.w * r.e.y + l.c.w * r.e.z + l.d.w * r.e.w + l.e.w * r.e.v;\n    rs.e.v = l.a.v * r.e.x + l.b.v * r.e.y + l.c.v * r.e.z + l.d.v * r.e.w + l.e.v * r.e.v;\n\n    return rs;\n}\n\nmat5x5 translate(mat5x5 matrix, vec4 amount){\n    matrix.a.v += amount.x;\n    matrix.b.v += amount.y;\n    matrix.c.v += amount.z;\n    matrix.d.v += amount.w;\n    return matrix;\n}\n\nmat5x5 scale(mat5x5 l, vec4 amount){\n    mat5x5 rs = IDENTITY_MAT5x5;\n    rs.a.x = l.a.x * amount.x;\n    rs.a.y = l.a.y * amount.x;\n    rs.a.z = l.a.z * amount.x;\n    rs.a.w = l.a.w * amount.x;\n    rs.a.v = l.a.v * amount.x;\n\n    rs.b.x = l.b.x * amount.y;\n    rs.b.y = l.b.y * amount.y;\n    rs.b.z = l.b.z * amount.y;\n    rs.b.w = l.b.w * amount.y;\n    rs.b.v = l.b.v * amount.y;\n\n    rs.c.x = l.c.x * amount.z;\n    rs.c.y = l.c.y * amount.z;\n    rs.c.z = l.c.z * amount.z;\n    rs.c.w = l.c.w * amount.z;\n    rs.c.v = l.c.v * amount.z;\n\n    rs.d.x = l.d.x * amount.w;\n    rs.d.y = l.d.y * amount.w;\n    rs.d.z = l.d.z * amount.w;\n    rs.d.w = l.d.w * amount.w;\n    rs.d.v = l.d.v * amount.w;\n\n    rs.e = l.e;\n    return rs;\n}\n\n// https://math.stackexchange.com/questions/1402362/can-rotations-in-4d-be-given-an-explicit-matrix-form\n\nmat5x5 generate_zw_rotation(float theta){\n    return mat5x5(\n        vec5(cos(theta), -sin(theta), 0.0, 0.0, 0.0),\n        vec5(sin(theta), cos(theta), 0.0, 0.0, 0.0),\n        vec5(0.0, 0.0, 1.0, 0.0, 0.0),\n        vec5(0.0, 0.0, 0.0, 1.0, 0.0),\n        vec5(0.0, 0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat5x5 generate_yw_rotation(float theta){\n    return mat5x5(\n        vec5(cos(theta), 0.0, -sin(theta), 0.0, 0.0),\n        vec5(0.0, 1.0, 0.0, 0.0, 0.0),\n        vec5(sin(theta), 0.0, cos(theta), 0.0, 0.0),\n        vec5(0.0, 0.0, 0.0, 1.0, 0.0),\n        vec5(0.0, 0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat5x5 generate_yz_rotation(float theta){\n    return mat5x5(\n        vec5(cos(theta), 0.0, 0.0, -sin(theta), 0.0),\n        vec5(0.0, 1.0, 0.0, 0.0, 0.0),\n        vec5(0.0, 0.0, 1.0, 0.0, 0.0),\n        vec5(sin(theta), 0.0, 0.0, cos(theta), 0.0),\n        vec5(0.0, 0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat5x5 generate_xw_rotation(float theta){\n    return mat5x5(\n        vec5(1.0, 0.0, 0.0, 0.0, 0.0),\n        vec5(0.0, cos(theta), -sin(theta), 0.0, 0.0),\n        vec5(0.0, sin(theta), cos(theta), 0.0, 0.0),\n        vec5(0.0, 0.0, 0.0, 1.0, 0.0),\n        vec5(0.0, 0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat5x5 generate_xz_rotation(float theta){\n    return mat5x5(\n        vec5(1.0, 0.0, 0.0, 0.0, 0.0),\n        vec5(0.0, cos(theta), 0.0, -sin(theta), 0.0),\n        vec5(0.0, 0.0, 1.0, 0.0, 0.0),\n        vec5(0.0, sin(theta), 0.0, cos(theta), 0.0),\n        vec5(0.0, 0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat5x5 generate_xy_rotation(float theta){\n    return mat5x5(\n        vec5(1.0, 0.0, 0.0, 0.0, 0.0),\n        vec5(0.0, 1.0, 0.0, 0.0, 0.0),\n        vec5(0.0, 0.0, cos(theta), -sin(theta), 0.0),\n        vec5(0.0, 0.0, sin(theta), cos(theta), 0.0),\n        vec5(0.0, 0.0, 0.0, 0.0, 1.0)\n    );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_A = 65;\nconst int KEY_W = 87;\nconst int KEY_D = 68;\nconst int KEY_S = 83;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\n\nconst int KEY_SPACE = 32;\nconst int KEY_SHIFT = 16;\n\nconst float SPEED = 2.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(fragCoord.y) != 0){\n        fragColor = vec4(0.0);\n        return;\n    }\n    vec4 data = texelFetch(iChannel0, ivec2(int(fragCoord.x), int(fragCoord.y)), 0).xyzw;\n    switch(int(fragCoord.x)){\n        case 0:{\n            float key_a_down = texelFetch( iChannel1, ivec2(KEY_A,0), 0 ).x;\n            float key_w_down = texelFetch( iChannel1, ivec2(KEY_W,0), 0 ).x;\n            float key_d_down = texelFetch( iChannel1, ivec2(KEY_D,0), 0 ).x;\n            float key_s_down = texelFetch( iChannel1, ivec2(KEY_S,0), 0 ).x;\n            float key_e_down = texelFetch( iChannel1, ivec2(KEY_E,0), 0 ).x;\n            float key_q_down = texelFetch( iChannel1, ivec2(KEY_Q,0), 0 ).x;\n            float key_f_down = texelFetch( iChannel1, ivec2(KEY_F,0), 0 ).x;\n            float key_r_down = texelFetch( iChannel1, ivec2(KEY_R,0), 0 ).x;\n            float key_space_down = texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x;\n            float key_shift_down = texelFetch( iChannel1, ivec2(KEY_SHIFT,0), 0 ).x;\n\n            vec4 velocity = vec4(0.0);\n\n            if (key_d_down != 0.0){\n                velocity.x += iTimeDelta * SPEED;\n            }\n            if (key_a_down != 0.0){\n                velocity.x -= iTimeDelta * SPEED;\n            }\n            if (key_space_down != 0.0){\n                velocity.y += iTimeDelta * SPEED;\n            }\n            if (key_shift_down != 0.0){\n                velocity.y -= iTimeDelta * SPEED;\n            }\n            if (key_w_down != 0.0){\n                velocity.z -= iTimeDelta * SPEED;\n            }\n            if (key_s_down != 0.0){\n                velocity.z += iTimeDelta * SPEED;\n            }\n            if (key_f_down != 0.0){\n                velocity.w -= iTimeDelta * SPEED;\n            }\n            if (key_r_down != 0.0){\n                velocity.w += iTimeDelta * SPEED;\n            }\n\n            vec4 rot = texelFetch(iChannel0, ivec2(1, 0), 0);\n            mat5x5 mat = IDENTITY_MAT5x5;\n            mat = translate(mat, velocity * iTimeDelta * 25.0);\n            mat = multiply_mat5x5(mat, generate_xw_rotation(rot.x));\n            mat = multiply_mat5x5(mat, generate_yw_rotation(rot.y));\n            mat = multiply_mat5x5(mat, generate_xy_rotation(rot.w));\n\n            data += vec4_from_mat5x5(mat);\n            break;\n        }\n        case 1:{\n            float key_e_down = texelFetch( iChannel1, ivec2(KEY_E,0), 0 ).x;\n            float key_q_down = texelFetch( iChannel1, ivec2(KEY_Q,0), 0 ).x;\n\n            if (key_q_down != 0.0){\n                data.y -= iTimeDelta;\n            }\n            if (key_e_down != 0.0){\n                data.y += iTimeDelta;\n            }\n\n            vec4 prev_mouse = texelFetch(iChannel0, ivec2(2, 0), 0);\n            if (iMouse.z == prev_mouse.z){\n                data.y += (iMouse.x - prev_mouse.x) * 0.005;\n                data.x += (iMouse.y - prev_mouse.y) * 0.005;\n            }\n\n            break;\n        }\n        case 2:{\n            data = iMouse;\n            return;\n        }\n    }\n\n    fragColor = vec4(data);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}