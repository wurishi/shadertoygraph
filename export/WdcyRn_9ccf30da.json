{"ver":"0.1","info":{"id":"WdcyRn","date":"1600233501","viewed":465,"name":"high bloom","username":"Carandiru","description":"developing a bloom post effect\n\nSHADERTOY should be archived in the Artic Vault (github recently did this!)\n\nBLOOD MACHINES is Out, sequel to TERROR KILLER! go watch it you'll thank me later, lol","likes":9,"published":1,"flags":40,"usePreview":0,"tags":["bloom","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WdcyRn\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\n#define POISSON_RADIUS 4.5f\nconst int TAPS = 12;\nconst vec2 kTaps[TAPS] = vec2[TAPS](\tvec2(-0.326212,-0.40581),vec2(-0.840144,-0.07358),\n\t\t\t\t\t\t\tvec2(-0.695914,0.457137),vec2(-0.203345,0.620716),\n\t\t\t\t\t\t\tvec2(0.96234,-0.194983),vec2(0.473434,-0.480026),\n\t\t\t\t\t\t\tvec2(0.519456,0.767022),vec2(0.185461,-0.893124),\n\t\t\t\t\t\t\tvec2(0.507431,0.064425),vec2(0.89642,0.412458),\n\t\t\t\t\t\t\tvec2(-0.32194,-0.932615),vec2(-0.791559,-0.59771) \n\t\t\t\t\t     );\n\nvec3 poissonBlurBilateral( in vec3 color, in float bilateral_alpha, in vec2 center_uv, in float radius ) // pass in center sample \n{ \n\tfloat distance_reflection = bilateral_alpha + radius * (1.0f - bilateral_alpha);\n\tfloat attenuation = 1.0f - (1.0f / (1.0f + distance_reflection*distance_reflection));\n\n    vec2 InvResDimensions = 1.0f / iChannelResolution[1].xy;\n\tfor ( int tap = 0 ; tap < TAPS ; ++tap ) \n\t{\n\t\tvec3 sampling = textureLod(iChannel1, center_uv + InvResDimensions * kTaps[tap] * distance_reflection, 0.0).rgb;\n\t\tcolor += sampling.rgb * attenuation * (1.0f - bilateral_alpha);\n\t}\n\n\tcolor *= (1.0f/float(TAPS+1));\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 blur = texture(iChannel1, uv).rgb;\n\tfloat bilateral = length(abs(color - blur));\n    \n    blur = poissonBlurBilateral(blur, bilateral, uv, POISSON_RADIUS);\n   \n    color = mix( color + color * bilateral * blur + blur,\n                 color + blur * blur * 2.0f + blur * blur * blur * 4.0f + pow(blur, vec3(0.5f)),\n                 1.0f - bilateral );\n   \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WdcyRn\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n#define FLUENCY 0.166666f\n#define SCALE 5.0f\n\nconst vec3 c = vec3(1.0, 0.0, -1.0);\n\nfloat iScale;\n\n\n// https://www.shadertoy.com/view/WlsGz4\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n} \n\nfloat flownoise(in vec2 a, in float size)\n{\n    vec2 id = ceil(a/size);    \n    vec2 rid = vec2(rand(id), rand(id+iResolution.y));            \n        \n    float ridFactor = rid.x + rid.y;\n    float f = ridFactor + iTime * FLUENCY *  (ridFactor);\n    float fid = floor(f);\n    f = abs(fract(f) - mod(fid, 2.));\n    \n    return(0.1f/(0.05f + f));\n}\n\n// Box sdf\nvoid dbox(in vec2 x, in vec2 b, out float d)\n{\n    vec2 da = abs(x)-b;\n    d = length(max(da,c.yy)) + min(max(da.x,da.y),0.0);\n}\n\n// Stroke\nvoid stroke(in float d0, in float s, out float d)\n{\n    d = abs(d0)-s;\n}\n\n// Extrusion\nvoid zextrude(in float z, in float d2d, in float h, out float d)\n{\n    vec2 w = vec2(-d2d, abs(z)-0.5*h);\n    d = length(max(w,0.0));\n}\n\n// Add sdfs\nvoid add(in vec2 sda, in vec2 sdb, out vec2 sdf)\n{\n    sdf = min(sda,sdb);\n}\n\nvec2 ind;\nvoid scene(in float tT, in vec3 x, out vec2 sdf)\n{\n    x.y += .3*iTime;\n    x.xy = vec2(x.x-x.y,x.x+x.y)/sqrt(2.);\n    \n    float d,\n        size = .1;\n    vec2 x2 = mod(x.xy,size)-.5*size;\n\t\n    ind = (x.xy - x2)/size;\n    dbox(x2, .5*size*c.xx, d);\n    zextrude(x.z, -d-.005, .05, d);\n    d = max(x.z,d);\n    d = abs(d);\n    sdf = vec2(d,2.);\n    \n    float r, r2;\n    r = flownoise(ind-floor(iTime), 1.0);\n    r2 = flownoise(ind-floor(iTime)-1., SCALE);\n    \n    r = mix(r, r2, fract(iTime));\n    \n    {\n        dbox(x2, .5*size*c.xx, d);\n        zextrude(x.z, -d-.02, r, d);\n        stroke(d, .001, d);\n        add(sdf, vec2(d,1.), sdf);\n    }\n}\n\nfloat sm(float d)\n{\n    //fixed to be static - keeps color constant independent of resolution\n    return smoothstep(1.5/288.0f, -1.5/288.0f, d);\n}\n\nvoid colorize(in float tT, in vec2 x, out vec3 col)\n{\n    x.y += .3*iTime;\n    x = vec2(x.x-x.y,x.x+x.y)/sqrt(2.);\n    \n    float d,\n        size = .1;\n    vec2 x2 = mod(x.xy,size)-.5*size;\n    \n    float r, r2;\n    r = flownoise(ind-floor(iTime), 1.0);\n    r2 = flownoise(ind-floor(iTime)-1., SCALE);\n    \n    r = mix(r, r2, fract(iTime));\n    \n    dbox(x2, .35*size*c.xx, d);\n    \n   {\n    col = mix(col, mix(c.zzx, c.xzz, .8), sm(d));\n        stroke(d, .0025, d);\n        col = mix(col, mix(c.xyy,c.xxx,.8)* 0.5f, sm(d)) * r;\n       \n       float d0, d1;\n       dbox(x2, .35*size*abs(v2_rotate(c.yx, pi/4.)), d0);\n       dbox(x2, .35*size*abs(-v2_rotate(c.xy, pi/4.)), d1);\n       \n       stroke(d0, .0025, d0);\n       stroke(d1, .0025, d1);\n       \n       float ss;\n       ss = mix(sm(d0),sm(d1),0.5);\n       col = mix(col,vec3(sm(d0)), 0.5f);\n       col = mix(col, mix(c.xyy,c.xxx,.8)* vec3(0.5f,0,0.9f), sm(d)) * sm(d0) * pow(r, 5.0f);\n       col += vec3(ss*r);\n       col += vec3(ss) * tT * r;\n       col *= vec3(0.5f,0,0.9f);\n       col = mix(col, col*vec3(ss*r)* vec3(0.5f,0,0.9f), tT+0.5f);\n   }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    iScale = 1.;\n    \n    vec2 uv = ( fragCoord -.5* iResolution.xy) / iResolution.y, \n        s;\n    vec3 col = c.yyy, \n        o = c.yzx,\n        r = c.xyy, \n        u = normalize(c.yxx), \n        t = c.yyy, \n        dir,\n        n,\n        x;\n    int N = 100,\n        i;\n    t = uv.x * r + uv.y * u;\n    dir = normalize(t-o);\n\n    float tT = 0.;\n    float tF = iTime*bpm/60.;\n    \n    tT += base(tF,iTime);\n    tT += kick(tF,iTime);\n    tT = smoothstep(0.01, 0.99, tT);\n    \n    float d = -(o.z-.15)/dir.z;\n    \n    for(i = 0; i<N; ++i)\n    {\n     \tx = o + d * dir;\n        scene(tT, x,s);\n        if(s.x < 1.e-4)break;\n        if(x.z<-.05)\n        {\n            col = .2*c.xxx;\n            i = N;\n            break;\n        }\n        d += min(s.x,5.e-3);\n        //d += s.x;\n    }\n    \n    if(i < N)\n    {\n        colorize(tT, x.xy, col);\n    }\n\n    \n    fragColor = vec4(clamp(col,0.,1.),1.0);\n}\t","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define bpm 138.\n#define pi acos(-1.)\n#define pi2 pi*2.\n\nfloat calf(float i){\n    return pow(2.0,i/12.0);\n}\n\nfloat dist(float s, float d)\n{\n    return clamp(s * d, -1.0, 1.0);\n}\n\nfloat fm(float t,float f,float i,float r){\n    return sin(pi2*f*t+i*sin(pi2*f*t*r));\n}\n\nfloat base(float t,float time)\n{\n    float o = 0.;\n    float note = 4.5;\n\to += fm(time,40.*calf(note),2.,1.);\n    o += sin(time*40.*calf(note+12.)*pi2)*.5;\n    o *= .9;\n    o = dist(o,2.)*.5;\n    o = o * exp(-.75*fract(t*2.));\n\treturn o;\n}\n\n//kick\n//https://www.shadertoy.com/view/ldfSW2\nfloat kick(float t, float time)\n{\n    \n    t = fract(t*0.5)*.5;\n    float aa = 5.;\n    t = sqrt(t * aa) / aa; \t\n\n    float amp = exp(max(t - 0.15, 0.0) * -2.0);\n    \n       \n    float o = sin(t * 100.0 * pi2) * amp;\n    o = dist(o,1.);\n    return o;\n}\n\n#define fma(a,b,c) (a*b+c)\nvec2 v2_rotate(in vec2 p, in float angle)\n{\n\treturn( vec2(fma(p.x, cos(angle), -p.y * sin(angle)),\n\t\t\t\t fma(p.x, sin(angle), p.y * cos(angle))\n\t));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":" // http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WdcyRn\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 ch = .5/iResolution.xy;\n\n    vec3 color = vec3(1.0);\n    for(float i=-1.; i<=1.; i++){\n        for(float j=-1.; j<=1.; j++){\n            \n            color *= texture(iChannel0, uv+vec2(i, j)*ch).rgb;\n        }\n    }\n    \n    color = smoothstep(vec3(0.0f), vec3(0.1f), color);\n\n    fragColor = vec4(color,1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp, float time )\n{\n    time = time + 33.;\n    \n    float tT = 0.;\n    float tF = time*bpm/60.;\n    \n    tT += base(tF,time);\n    tT += kick(tF,time);\n    tT = smoothstep(0.01, 0.99, tT);\n    \n    return(vec2(tT));\n}","name":"Sound","description":"","type":"sound"}]}