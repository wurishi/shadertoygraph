{"ver":"0.1","info":{"id":"mtSSD3","date":"1676667039","viewed":149,"name":"ribbon squeeze glow","username":"HaleyHalcyon","description":"aa","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spiralperspective"],"hasliked":0,"parentid":"mt2SDG","parentname":"ribbon helix"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Set to 1 to enable dithering (GIF export)\n#define DITHER 0\n\n#if DITHER == 1\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 1;\n    return float((xy.x ^ xy.y) * 2 + xy.y)/ 4.;\n}\n#endif\n\nconst float TURN = 2.*acos(-1.);\nconst vec3 EQUALPOWER = vec3(0.5, 0.3, 1);\n\nfloat radiusAtZ(float z, float t) {\n    //return 0.5;\n    return 0.5 + 0.3 * sin((0.25 * z + t) * TURN);\n    \n}\n\nvec3 deepfry(vec3 rgb) {\n    return rgb + vec3(\n      max(0., rgb.g - 1.) + max(0., rgb.b - 1.),\n      max(0., rgb.b - 1.) + max(0., rgb.r - 1.),\n      max(0., rgb.r - 1.) + max(0., rgb.g - 1.)\n    );\n}\n\nfloat brightness(vec3 c) {\n    return sqrt(\n        .299 * c.r * c.r +\n        .587 * c.g * c.g +\n        .114 * c.b * c.b\n    );\n}\n\nvec3 color(float t) {\n    vec3 rgb = 0.7 + 0.7 * cos(\n        TURN * (fract(t) + vec3(0, 1, 2) / 3.)\n    );\n    rgb += vec3(0.5 - brightness(rgb));\n//    vec3 rgb = pow(\n//        max(vec3(0.), 0.5 + cos(\n//            TURN * (fract(t) + vec3(0, 1, 2) / 3.)\n//        )), vec3(0.5)\n//    );\n    return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Time loops\n    float t = fract(-iTime / 2.56);\n    \n    const float Z_OFFSET = -1.5;\n    const float Z_SCALE = .5;\n    const float LAYERS_PER_LOOP = 4.;\n    const float LAYERS = 24.;\n    const float EDGE = 0.10;\n    const float WIDTH = 0.25;\n    \n    // Horiz position of eye/camera for stereoscopic 3D\n    // Change the sign to use other eye\n    float EYE_X = 0.125;\n    // DEMO: Camera moves left and right\n    EYE_X = cos(t * TURN) * EYE_X;\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.yy;\n    \n    float offset = t * LAYERS_PER_LOOP;\n    float firstLayer = floor(offset);\n    float fractOffset = fract(offset);\n\n    vec3 col = vec3(0);\n    \n    // approximated by starting from center always\n    // i donâ€™t know how to use an accurate value w/o circular reference\n    float theta = atan(uv.y, uv.x) / TURN;\n    \n    for (float layer = LAYERS; layer > 0.; layer--) {\n        \n        float z = (\n        - theta\n        + t * LAYERS_PER_LOOP\n        + layer - firstLayer\n        + Z_OFFSET\n        );\n        vec2 uvLayer = z * Z_SCALE * uv + vec2(EYE_X, 0.);\n        float r = length(uvLayer);\n        if (z > 0.) {\n            float w = WIDTH * smoothstep(\n                LAYERS - 1.,\n                LAYERS - 2.,\n                z\n            );\n            \n            r -= radiusAtZ(Z_SCALE * z, t);\n            col = mix(\n                col, color(\n                    0.3 * z +\n                    1. * t\n                ) / (0.5 + 0.1 * z),\n                smoothstep(0., EDGE, w - r) * \n                smoothstep(0., EDGE, r)\n            );\n        }\n    }\n    \n    col = deepfry(col);\n\n#if DITHER == 1\n// dithering\n    float thres = 1.0 - (\n    crosshatch(fragCoord)\n    + crosshatch(fragCoord / 2.) / 4.\n    + crosshatch(fragCoord / 4.) / 16.\n    //+ crosshatch(fragCoord / 8.) / 64.\n    );\n    const float DITHERSTEPS = 2.;\n    col = (\n        floor(col * DITHERSTEPS) +\n        step(vec3(thres), fract(col * DITHERSTEPS))\n    ) / DITHERSTEPS;\n    \n#endif\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}