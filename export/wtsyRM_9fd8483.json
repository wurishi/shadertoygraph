{"ver":"0.1","info":{"id":"wtsyRM","date":"1591912726","viewed":134,"name":"kmrd_cornellBox","username":"komradepasha","description":"Path Traced Cornell Box. WIP","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Path Traced Cornell Box. \t\t\t\t\t\t\t\t\t by Pavel Pranevsky //\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t//\n//\t\t\t\t\t\t\t\t\t!!Work in Progress!!\t\t\t\t\t\t  \t//\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t//\n// This is an exercise in learning GLSL and understanding Monte Carlo path tracing. //\n// All code is property of it's creator and cannot be used without permission.\t\t//\n\n\n\n////////////////////     defines    ////////////////////\n\n#define MAX_MARCHING_STEPS 200\n#define MAX_MARCHING_DIST 20.0\n#define MIN_SURFACE_DIST 0.001\n\n// current resolution 1200x675 = 810,000 pixels\n\n#define SAMPLES_PER_PIXEL 1\n// number of diffuse samples fired for every pixel sample\n#define DIFFUSE_SAMPLES 8\n// number of indirect samples fired for EVERY diffuse sample that didn't hit a light source\n#define INDIRECT_DIFFUSE_SAMPLES 2\n\n#define REFRACTION_DEPTH 1\n\n#define Pi 3.14159265359\n\n////////////////////////////////////////////////////////\n\n\n\n\n//////////////////// custom structs ////////////////////\n\nstruct ray {\n    vec3 origin, direction;\n};\n\nstruct rayHit {\n    float dist;\t\t\t\t\t//distance to ray hit\n    float emissive;\n    float IOR;\n    bool metallic, refractive;\n    vec3  normal, albedo;\n};\n\nstruct camera {\n    vec3 position, target,\n        forward, right, up;\t\t// coordinate system\n    float FOV;\n};\n\nstruct light {\n    vec3 position, target, color,\n        forward, right, up;\t\t// coordinate system\n    float intensity, radius;\n};\n\n//////////////////////////////////////////////////////// \n\n\n\n\n////////////////////    functions   ////////////////////\n\n    \n// generate random float from 0-1, based on a vec2 seed input    \nfloat randFloat (vec2 seed)\t{\n\tvec2 constant = vec2( 23.14069263277926, 2.665144142690225 );\t\t\t\n    return fract( cos(dot(seed,constant)) * 123456.0 ); \t}\n\n\n//  create a light\nlight makeLight(vec3 lightPosition, vec3 lightColor, float intensity, float radius) {\n\n    light l;\n    l.position \t\t= lightPosition;\n    l.color \t\t= lightColor;\n    l.intensity \t= intensity;\n    l.radius \t\t= radius;\n\n    l.forward \t\t= normalize(l.target - l.position);  \t\t// forward vector\n    l.right \t\t= cross(vec3(0, 1, 0), l.forward);\t    \t// right vector\n    l.up \t\t\t= cross(l.forward, l.right);\t\t\t\t// up vector\n\n    return l;     \n}\n\n\n// create a camera object\ncamera makeCamera(vec3 cameraPosition, vec3 cameraTarget, float FOV) {\n\n    camera cam;\n    cam.position \t= cameraPosition;\n    cam.target \t\t= cameraTarget;\n    cam.FOV \t\t= FOV;\n\n    cam.forward \t= normalize(cameraTarget - cameraPosition); \n    cam.right \t\t= cross(vec3(0, 1, 0), cam.forward);\t    \n    cam.up \t\t\t= cross(cam.forward, cam.right);\t\t\t\n\n    return cam;     \t\t\t\t\t\t\t\t\t\t\n}\n\n\n// get an eye/camera ray. These rays are shot for every pixel (current resolution 1200x675 = 810,000 rays)\nray getCameraRay(vec2 uv, camera cam, float zoom) {\n\n    ray r;\n    \tr.origin \t= cam.position;                          \t// shoot rays from the camera origin\n\n    vec3 c \t\t\t= r.origin + cam.forward * zoom;\t\t\t// center of the virtual screen \n    vec3 i \t\t\t= c + uv.x * cam.right + uv.y * cam.up;\t\t// point at which the current ray intersects the screen \n    \tr.direction = normalize(i - r.origin);                  \n\n    return r;\t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n\n\n// trace a plane\nbool planeTrace(ray r, vec3 i0, vec3 i1, vec3 i2, inout rayHit rayHitDetails) {\n\n    // find the plane normal\n    vec3  n = normalize(cross((i1 - i0), (i2 - i0)));\n    vec3  p = vec3(0.0);  \t\t\t\t\t\t\t\t\t// intersection point\n    float d = MIN_SURFACE_DIST;  \t\t\t\t\t\t\t// distance to intersection point\n\n    // ray march to the plane, to find the intersection point\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        p = r.origin + r.direction * d;\n        vec3 v = abs(dot((p - i0), n)) * n;\n\n        if (length(v) > MIN_SURFACE_DIST || d < MAX_MARCHING_DIST)\n            d += length(v);\n        else\n            break;\n    }\n\n    if (\td \t> rayHitDetails.dist  \t\t\t// chop walls off, to let more env light in\n        || \tp.x >  4.0\n        ||\tp.x < -4.0\n        || \tp.y >  6.01\n        ||\tp.y <  0.0        \n        || \tp.z >  5.0\n        || \tp.z < -5.5)\t\n        \n        return false;\n\n    rayHitDetails.dist = d;\n    rayHitDetails.normal = n;\n\n    return true;\n}\n\n\n\n// get distance to sphere\nfloat getDistToSphere(vec3 p, inout vec4 sphere) {\n    return (length(sphere.xyz - p) - sphere.w);\n}\n\n\n// trace a sphere\nbool sphereTrace(ray r, vec4 sphere, inout rayHit rayHitDetails) {\n\n    float distToCenter \t= length(sphere.xyz - r.origin);\n    float alpha \t\t= asin(sphere.w / distToCenter);\n    float theta \t\t= acos(dot((sphere.xyz - r.origin), r.direction) / distToCenter);\n\n    if (theta > alpha)\n        return false;\t\n\t\n    vec2  delta \t\t= vec2(.001, 0);\t\t\t\t\t\t\t\t// small delta vector2, to compute surface normal\n    vec3  p \t\t\t= vec3(0.0);  \t\t\t\t\t\t\t\t\t// intersection point\n    float d \t\t\t= MIN_SURFACE_DIST;  \t\t\t\t\t\t\t// distance to intersection point\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) { \n\n        p = r.origin + r.direction * d;\n        float distToSphere = abs(distance(sphere.xyz,p) - sphere.w);  \t// distance to sphere from P\n            \n        if (distToSphere > MIN_SURFACE_DIST && d < MAX_MARCHING_DIST)\n            d += distToSphere;\n        else            \n            break;\n    }\n\n    if (d > rayHitDetails.dist)\n        return false;\n\n    rayHitDetails.dist \t\t= d;\n    rayHitDetails.normal \t= -normalize(sphere.xyz - p);\n\n    /*// the below works too and is a more traditional method, just super long and uses an additional getDistToSphere function\n\n     rayHitDetails.normal = normalize (vec3(\tgetDistToSphere(p + delta.xyy, sphere) - getDistToSphere(p - delta.xyy, sphere),\n                                                getDistToSphere(p + delta.yxy, sphere) - getDistToSphere(p - delta.yxy, sphere),\n                                                getDistToSphere(p + delta.yyx, sphere) - getDistToSphere(p - delta.yyx, sphere)\t));\t*/\n    return true;\n}\n\n\n// trace scene\nvoid traceScene(ray r, inout rayHit rayHitDetails) {\n\n/*    // metallic sphere\n    if (sphereTrace(r, vec4(0, 1, -2.5, 1), rayHitDetails))\t{\n\t\trayHitDetails.metallic\t\t= true;\t\n\t\trayHitDetails.refractive\t= false;\n        rayHitDetails.IOR\t\t\t= 6.0;\n        rayHitDetails.albedo \t\t= vec3(1.0);\t}\t\t*/\n\n    // diffuse sphere\n    if (sphereTrace(r, vec4(1.5, 1, 0, 1), rayHitDetails))  {\n        rayHitDetails.metallic\t\t= false;\n\t\trayHitDetails.refractive\t= false;\t\n        rayHitDetails.albedo \t\t= vec3(1.0);\t}\t\t\t\n\n    // diffuse sphere\n    if (sphereTrace(r, vec4(-1.5, 1, 0, 1), rayHitDetails))\t {\n        rayHitDetails.metallic\t\t= false;\n\t\trayHitDetails.refractive\t= false;\t\n        rayHitDetails.albedo \t\t= vec3(1.0);\t}\t\t\n\n/*    // glass sphere\n    if (sphereTrace(r, vec4(vec3(sin(iTime)*2.0, cos(iTime*3.0)*0.8 + 4.0, cos(iTime)*2.0 - 2.0), 1.0), rayHitDetails)) {\n        rayHitDetails.metallic\t\t= false;\n        rayHitDetails.refractive\t= true;\n        rayHitDetails.IOR\t\t\t= 1.5;\n        rayHitDetails.albedo\t\t= vec3(1,0,0);\t}    */\n\n    // glass sphere\n    if (sphereTrace(r, vec4(0, 3, -4, 1.5), rayHitDetails)) {\n        rayHitDetails.metallic\t\t= false;\n        rayHitDetails.refractive\t= true;\n        rayHitDetails.IOR\t\t\t= 1.333;\n        rayHitDetails.albedo\t\t= vec3(1,0.5,0);\t}       \n    \n    \n    // floor \n    if (planeTrace(r, \tvec3(-1, 0.01,  1),\n        \t\t\t\tvec3( 1, 0.01,  1),\n        \t\t\t\tvec3( 1, 0.01, -1), rayHitDetails))\n        rayHitDetails.albedo \t= vec3(1.0);\n\n/*    // ceiling\t\t\n    if (planeTrace(r, \tvec3( 1, 6,  1),\n        \t\t\t\tvec3(-1, 6,  1),\n        \t\t\t\tvec3( 1, 6, -1), rayHitDetails))\n        rayHitDetails.albedo = vec3(0.8, 0.8, 0.8);\t\t*/\t\n\n    // left wall - red\n    if (planeTrace(r, \tvec3(-3.99, 1, -1),\n        \t\t\t\tvec3(-3.99, 1,  1),\n        \t\t\t\tvec3(-3.99, 0,  1), rayHitDetails))\n    \trayHitDetails.albedo \t= vec3(0.8, 0.1, 0.1);\n\n    // right wall - green\n    if (planeTrace(r, \tvec3(3.99, 1, -1),\n        \t\t\t\tvec3(3.99, 0,  1),\n        \t\t\t\tvec3(3.99, 1,  1), rayHitDetails))\n    \trayHitDetails.albedo \t= vec3(0.1, 0.8, 0.1);\n\n    // back wall\n    if (planeTrace(r, \tvec3(-1,  1, 4.99),\n        \t\t\t\tvec3( 1,  1, 4.99),\n                   vec3( 1, -1, 4.99), rayHitDetails))\t\n    \trayHitDetails.albedo \t= vec3(1.0);\t\n\n \n    light sphereLight1 = makeLight(\tvec3(2.5,  1, -3),\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* position\t*/\n                                    vec3(  1, .5, .1), \t\t\t\t\t\t\t\t\t\t\t\t\t\t/* color\t*/\n                                   \t2.0,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* intensity */\n                                    0.5\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* light radius\t*/);\n        if (sphereTrace(r, vec4(sphereLight1.position, sphereLight1.radius), rayHitDetails)) {\n            rayHitDetails.albedo \t= sphereLight1.color;\n            rayHitDetails.metallic \t= false;\n            rayHitDetails.emissive \t= sphereLight1.intensity;\n            if (rayHitDetails.emissive > 0.0)\n                rayHitDetails.albedo = sphereLight1.color * sphereLight1.intensity;\t}\n\n\n\n    light sphereLight2 = makeLight(\tvec3(-2.5,  1, -4),\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* position\t*/\n                                    vec3(  .1, .5,  1),\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* color\t*/\n                                   \t2.0,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* intensity */\n                                    0.6\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* light radius\t*/);\n        if (sphereTrace(r, vec4(sphereLight2.position, sphereLight2.radius), rayHitDetails)) {\n            rayHitDetails.albedo \t= sphereLight2.color;\n            rayHitDetails.metallic \t= false;\n            rayHitDetails.emissive \t= sphereLight2.intensity;\n            if (rayHitDetails.emissive > 0.0)\n                rayHitDetails.albedo = sphereLight2.color * sphereLight2.intensity;\t}\t\n}\n\n\n// get a random direction vector, sampled in a hemispherical pattern from sampleOrigin\nvec3 getRandomDirection (vec2 uv) {\n \n    vec3  direction;\n    float theta \t= randFloat(uv.xy) * Pi ;\n    float phi \t\t= randFloat(uv.yx) * Pi * 2.0;\n    \n//        direction.x = sin(theta) * cos(phi);\n//        direction.y = sin(theta) * sin(phi);\n//        direction.z = cos(theta);\n\n    \tdirection.z = randFloat(uv.xy) * 2.0 - 1.0; // cosTheta\n    \t\tfloat sinTheta = sqrt(1.0 - direction.z * direction.z);\n        direction.x = sinTheta * cos(phi);\n        direction.y = sinTheta * sin(phi);\n\n    return direction;\n}\n\n\n//\nvoid resetRayHitDetails (inout rayHit rayHitDetails)\t{\n    rayHitDetails.albedo\t\t=\tvec3(0.0);\n    rayHitDetails.normal\t\t=\tvec3(0.0);\n\trayHitDetails.emissive\t\t=\t0.0;\n    rayHitDetails.metallic\t\t=\tfalse;\n    rayHitDetails.refractive\t=\tfalse;\n    rayHitDetails.IOR\t\t\t=\t1.0;\n    rayHitDetails.dist\t\t\t=\tMAX_MARCHING_DIST;\n}\n\n\n// get radiance at shading point\nvec3 getRadiance (ray r, vec2 uv, inout rayHit rayHitDetails)\t{\n\n   \tvec3  albedo \t\t\t= rayHitDetails.albedo;\n\tvec3  normal \t\t\t= rayHitDetails.normal;\n    float emissive \t\t\t= rayHitDetails.emissive;\n\tfloat d \t\t\t\t= rayHitDetails.dist;\n    vec3  p \t\t\t\t= r.origin + vec3(r.direction * d);\n\n    vec3  totalRadiance \t= vec3(0.0);\n    vec3  indirectRadiance \t= vec3(0.0);\n\n    for (int i = 0; i < DIFFUSE_SAMPLES; i++) {\n        vec3  direction  \t\t= getRandomDirection ( uv + vec2(i) );\n        if (dot (direction, normal) < 0.0) \n\t\t\tdirection = -direction;\n\n        vec3 directionP = direction;\n\n        ray directSampleRay \t= ray (p, directionP);\n\t\t\tresetRayHitDetails(rayHitDetails);\n        traceScene (directSampleRay, rayHitDetails);\n        \tvec3 sampleAlbedo \t= rayHitDetails.albedo;\n\n        // if the direct sample ray hit the environment, radiance is calculated from the cube map\n        if (rayHitDetails.dist == MAX_MARCHING_DIST) {\n            totalRadiance += texture(iChannel0, directSampleRay.direction).rgb \n                \t\t\t* vec3(clamp(dot(normal, directSampleRay.direction), 0.0, 1.0)); \n        }\n\n        else\n        // if we hit a light source\n        if (rayHitDetails.emissive > 0.0) \n            totalRadiance += (sampleAlbedo * vec3(clamp(-dot(rayHitDetails.normal, normal), 0.0, 1.0))\n            \t\t\t\t* (rayHitDetails.emissive * (1.0 / (rayHitDetails.dist * rayHitDetails.dist))));          \n\n        else\t\n        // if we hit something other than environment or a light, do another bounce\n        {\n            vec3  sampleRadiance \t= vec3(0.0);\n            vec3  sampleNormal\t\t= rayHitDetails.normal;\n            float distToSample\t\t= rayHitDetails.dist;\n\n            if (INDIRECT_DIFFUSE_SAMPLES > 0)\t{\n                for (int j = 0; j < INDIRECT_DIFFUSE_SAMPLES; j++) {\n\t\t\t\t\t\n                    \n                    vec3 directionI\t\t= getRandomDirection ( uv + vec2(j+i+1) );\n                    if (dot (directionI, rayHitDetails.normal) < 0.0) \n                        directionI = -directionI;\n\n                    directionI = normalize(rayHitDetails.normal + directionI); // bias samples toward the normal\n                    \n                    ray indirectSampleRay \t= ray ((p + (directSampleRay.direction*rayHitDetails.dist)), directionI);\n                    \t\n\t\t\t\t\t\tresetRayHitDetails(rayHitDetails);\n                    traceScene (indirectSampleRay, rayHitDetails);\n\n                    // if the indirect sample hits the environment, light contribution is calculated from the cube map\n                    if (rayHitDetails.dist == MAX_MARCHING_DIST )\t{\n                        sampleRadiance   \t+= sampleAlbedo * texture(iChannel0, indirectSampleRay.direction).rgb \n                            \t\t\t\t\t\t  \t\t* vec3(clamp(dot(sampleNormal, indirectSampleRay.direction), 0.0, 1.0)); \n                    }\n\n                    else\n                    /*/ if the indirect sample hits a light source*/\n                    if (rayHitDetails.emissive > 0.0) \n                        sampleRadiance   \t+= sampleAlbedo \n                            \t\t\t\t\t* (rayHitDetails.albedo * vec3(clamp(-dot(rayHitDetails.normal, sampleNormal), 0.0, 1.0))\n                            \t\t\t\t\t* (rayHitDetails.emissive * (1.0 / (rayHitDetails.dist * rayHitDetails.dist))));          \n                    else\t\t\n                    // if indirect hits anything else\n                    \tsampleRadiance += vec3(0.0);\n                }\t\n \n                indirectRadiance += (sampleRadiance / vec3(float(INDIRECT_DIFFUSE_SAMPLES)))\n                    \t\t\t\t* vec3(clamp(-dot(normal, sampleNormal), 0.0, 1.0));\n            }\t\n    \t}\n    }\n\n    return vec3( (totalRadiance + indirectRadiance / Pi )  / vec3(float(DIFFUSE_SAMPLES)) ) * albedo;\n}\n\n\n// get reflection at shading point\nvec3 getReflection (ray cameraRay, vec2 uv, inout rayHit rayHitDetails)\n{\n\tvec3 albedo = vec3(1.0);\n    \n   \tif (rayHitDetails.metallic)\n\t \talbedo = rayHitDetails.albedo;\t// if the object is metallic, color the reflection by it's albedo\n    \n    vec3 reflVector\t= \t(cameraRay.direction * rayHitDetails.dist) - \n    \t\t\t\t\t\t2.0 * (dot ((cameraRay.direction * rayHitDetails.dist), rayHitDetails.normal)) * rayHitDetails.normal;\n\n    ray reflectionRay \t= ray ((cameraRay.origin + cameraRay.direction*rayHitDetails.dist), normalize(reflVector));\n\t\tresetRayHitDetails(rayHitDetails);\n\t\ttraceScene (reflectionRay, rayHitDetails);\n\n\t// if we miss all objects, return the background env cube map, and move onto the next pixel\n    if (rayHitDetails.dist == MAX_MARCHING_DIST)\n    \treturn albedo * texture(iChannel0, reflectionRay.direction).rgb;\n \n\t// if we hit an emissive object (light) - return it's color, and move onto the next pixel    \n    if (rayHitDetails.emissive > 0.0)\n    \treturn albedo * rayHitDetails.albedo;\n        \n\treturn albedo \t* getRadiance (reflectionRay, uv, rayHitDetails) \n            \t\t* (1.0 - clamp(-dot(cameraRay.direction, rayHitDetails.normal), 0.0, 1.0) );\n}\n\n\n// calculate fresnel value based on IOR\nfloat getFresnel (ray cameraRay, inout rayHit rayHitDetails)\t{\n\n\tfloat cosTheta1 = dot(normalize(-cameraRay.direction*rayHitDetails.dist), rayHitDetails.normal);\n    float cosTheta2 = sqrt ( 1.0 - (( 1.0 - (cosTheta1 * cosTheta1) ) / (rayHitDetails.IOR * rayHitDetails.IOR) ));\t\t\t\t\t\t\t\t\t\t\t\t\t\n        \n    float ratio1\t= \t( (cosTheta1 - rayHitDetails.IOR * cosTheta2) / (cosTheta1 + rayHitDetails.IOR * cosTheta2) );\n    float ratio2\t= \t( (rayHitDetails.IOR * cosTheta1 - cosTheta2) / (rayHitDetails.IOR * cosTheta1 + cosTheta2) );        \n\n    return ((ratio1 * ratio1) + (ratio2 * ratio2)) / 2.0;\n}\n\n\n// get refraction\nvec3 getRefraction (ray incomingRay, vec2 uv, rayHit rayHitDetails)\t{\n\n\tvec3 \trefraction \t\t\t= vec3(0.0);\n    float \tinIOR \t\t\t\t= 1.0;\n    float\toutIOR\t\t\t\t= rayHitDetails.IOR;\n    float \tcosTheta1\t\t\t= 0.0;\n    float \tsinSqTheta2\t\t\t= 0.0;\n    vec3 \trefractionVector\t= vec3(0.0);\n\n    for (int i = 0; i < REFRACTION_DEPTH; i++)\t{\n        \n/*        cosTheta1 \t\t\t= dot(-incomingRay.direction, rayHitDetails.normal);\n            \n        sinSqTheta2 \t\t= (inIOR/outIOR) * (inIOR/outIOR) * (1.0 - cosTheta1*cosTheta1);\n        refractionVector \t= (inIOR/outIOR) * incomingRay.direction \n            \t\t\t\t\t+ ( inIOR*abs(cosTheta1)/outIOR - sqrt(1.0 - sinSqTheta2) ) * rayHitDetails.normal;\t\t*/\n\n\t\tif (dot(incomingRay.direction, rayHitDetails.normal) > 0.0)\n            rayHitDetails.normal = -rayHitDetails.normal;\n        refractionVector\t= refract(incomingRay.direction, rayHitDetails.normal, inIOR/outIOR);\n        \n        ray refractionRay = ray ((incomingRay.origin + incomingRay.direction*rayHitDetails.dist), refractionVector);\n            resetRayHitDetails(rayHitDetails);\n            traceScene (refractionRay, rayHitDetails);    \n\n        return vec3(rayHitDetails.dist);\n        \n        if (rayHitDetails.refractive)\t{ \t\n            outIOR = inIOR;\n            inIOR = rayHitDetails.IOR;\n            incomingRay = refractionRay;\n\n        }\n\n        else\t{\t            \n\n\t\t\t\t\treturn vec3(rayHitDetails.albedo);\n/*\n            if (rayHitDetails.dist == MAX_MARCHING_DIST)\t{\n            \trefraction = texture(iChannel0, refractionRay.direction).rgb;\n                break;\t}\n\n            if (rayHitDetails.emissive > 0.0)\t{\n                refraction = rayHitDetails.albedo;\n                break;\t}\n\n            if (rayHitDetails.metallic)\t{\n                refraction = getFresnel(refractionRay, rayHitDetails) * getReflection(refractionRay, uv, rayHitDetails);\n                break;\t}\n\n            else\t{\n            \trefraction = getRadiance(refractionRay, uv, rayHitDetails);    \n                break;\t}\n*/\n        }\n    }\n\n//    resetRayHitDetails (rayHitDetails);\n    return refraction;\n}\n\n\n// get Pixel color by tracing the scene \nvec3 getPixelColor (ray cameraRay, vec2 uv) {\n\n    rayHit rayHitDetails;\n\t\tresetRayHitDetails(rayHitDetails);\n    \ttraceScene(cameraRay, rayHitDetails);\n\n    // if we miss all objects, return the background env cube map, and move onto the next pixel\n    if (rayHitDetails.dist == MAX_MARCHING_DIST)\n        return texture(iChannel0, cameraRay.direction).rgb;\n    \n    // on initial scene trace, if we hit an emissive object (light) - return it's color, and move onto the next pixel    \n    if (rayHitDetails.emissive > 0.0)\n        return rayHitDetails.albedo;\n\n\t// if the surface is metal, trace reflection\n    if (rayHitDetails.metallic)\n\t\treturn getFresnel(cameraRay, rayHitDetails) * getReflection(cameraRay, uv, rayHitDetails);\n    \n    // if the surface is refractive, do.. refractive stuff\n    if (rayHitDetails.refractive) {\n        \n\t\tfloat fresnel \t= getFresnel(cameraRay, rayHitDetails);\n\n        rayHit refractionHitDetails = rayHitDetails;\n        \n        vec3 reflection = getReflection(cameraRay, uv, rayHitDetails);\n\t\tvec3 refraction = getRefraction(cameraRay, uv, refractionHitDetails);\n\n        return refraction;\n        \n        return fresnel*reflection + (1.0 - fresnel)*refraction;\n    }\n\n\t// if it's diffuse, just get diffuse radiance\n    return getRadiance (cameraRay, uv, rayHitDetails);   \n}\n\n\n\n////////////////////////////////////////////////////////\nfloat sRGB(float channel) {\n\n    if (channel <= 0.00031308)\n        channel *= 12.92;\n    else\n        channel = 1.055 * pow(channel, (1.0 / 2.4)) - 0.055;\n\n    return channel;\n}\n\n\n////////////////////     output     ////////////////////    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 drawBuffer = vec3(0);\n    vec2 uv = fragCoord / iResolution.xy;          \t\t\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 mouseCoords = iMouse.xy / iResolution.xy;\t\t\t// Normalized mouse coordinates    \n    float resRatio = iResolution.x / iResolution.y;       \t// screeen aspect ratio\n\n    mouseCoords = mouseCoords - 0.5;\n    mouseCoords.x *= resRatio;\n    uv = uv - 0.5;                                        \t// reset screen origin to the center of the screen\n    uv.x *= resRatio;                                 \t\t//square up the pixels\n\n    // make a camera\n    camera cam = makeCamera(vec3(0, 1, -10), \t\t\t\t/* camera position */\n        vec3(0, 0, 0),\t   \t\t\t\t\t\t\t\t\t/* camera target   */\n        90.0);\t\t\t\t\t\t\t\t\t\t\t\t/* field of view */\n\n\t// camera controls via mouse input\n    cam.position.x = -sin(mouseCoords.x) * 4.0;\n    cam.position.y = -sin(mouseCoords.y) * 4.0 + 3.0;\n\tcam.position.z = -cos(mouseCoords.x)* 10.0 - 1.0;\n\n    ray cameraRay = getCameraRay(uv, cam, 1.0);\n\n    for (int i = 0; i < SAMPLES_PER_PIXEL; i++)\n        drawBuffer += getPixelColor(cameraRay, uv + vec2(float(i)));\n\n    drawBuffer /= vec3(float(SAMPLES_PER_PIXEL));\n    \n    // convert to sRGB color space and output the fragment to screen\n    fragColor = vec4(vec3(sRGB(drawBuffer.r), sRGB(drawBuffer.g), sRGB(drawBuffer.b)),1);\n}","name":"Image","description":"","type":"image"}]}