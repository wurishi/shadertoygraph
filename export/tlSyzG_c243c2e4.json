{"ver":"0.1","info":{"id":"tlSyzG","date":"1594656367","viewed":285,"name":"Intrinsic Gravity Remake","username":"LiamHz","description":"A Shadertoy remake of the intro of \"Intrinsic Gravity\" by Still [0]\n\nNOTE: To enable and sync audio, press \"pause\", then \"rewind\", then \"play\"\n\n[0]: https://youtu.be/-ZxPhDC-r3w","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["2d","demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4lSGzt","filepath":"https://soundcloud.com/donotthink/hoffman-intrinsic","previewfilepath":"https://soundcloud.com/donotthink/hoffman-intrinsic","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is my first 2D shader :)\n// NOTE: To enable and sync audio, press \"pause\", \n//\t\t then \"rewind\", then \"play\"\n\n#define EPS 0.0000001\n#define PI 3.1415926535\n\n#define BPM 85.0\n#define beat (60.0/BPM)\n#define halfbeat (60.0/BPM/2.0)\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\t// Adding EPS fixes a bug in older versions of GLSL\n    return c.z * mix(vec3(1.0), rgb, c.y) + EPS;\n}\n\nvec2 rotate2D(vec2 pos, float angle){\n    pos -= 0.5;\n    pos =  mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * pos;\n    pos += 0.5;\n    return pos;\n}\n\nvec2 tile(vec2 pos, float zoom){\n    pos   *= zoom;\t   // Changes range from [0, 1] to [0, `zoom`]\n    pos.x += 0.5;      // Shift tiling to the right by half a unit\n    \n    return fract(pos); // Creates `zoom` tilings\n}\n\nfloat sdfCircle(vec2 p, float r) {\n    float dist = 1.0 - (length(p) - r);\n    dist = smoothstep(0.0, 0.1, dist);\n    return dist;\n}\n\n// Side length of grid squares\n// For a square that is rotated 45 degrees, and is contained\n// by the unit square, its side length is sqrt(1/2)\n#define z pow(0.5, 0.5)\n\nfloat box(vec2 uv, vec2 size, float blur) {\n    vec2 edge = vec2(0.5)-size*0.5;\n    vec2 pos = smoothstep(edge, edge+blur,     uv)\n     \t       * smoothstep(edge, edge+blur, 1.0-uv);\n    \n    // Apply a NAND on the colors\n    return 1.0 - pos.x * pos.y;\n}\n\n/*\nti1: Start of wipe to white\nti2: Start of wipe to black\nti3: Start of half wipe\n*/\n\n#define SCENE_INTRO_START 0.0\n#define ti1 (SCENE_INTRO_START + beat)\n#define ti2 (ti1 + 4.0*beat)\n#define ti3 (ti2 + 4.0*beat)\n#define SCENE_INTRO_END (ti3 + 3.0*beat)\n// 12 beats total\n\n// step(pos.y + 0.5, time) wipes screen from bottom to top edge\n// -pos.y flips the edge / wipe direction\n// -step(...) flips the color\nvec3 sceneIntro(vec2 pos, float time) {\n    float d = 0.5*halfbeat;\n    float col = step(-pos.y + 0.5,     smoothstep(ti1  , ti1+halfbeat, time))\n              - step( pos.x + 0.5,     smoothstep(ti2  , ti2+halfbeat, time))\n              + step( pos.y + 0.5, 0.5*smoothstep(ti3-d, ti3+d       , time));\n    \n    return vec3(col);\n}\n\n/*\ntq1: Length of initial stillness\ntq2: Length of horizontal slide\ntq3: Start of zoom out\ntq4: Start of global rotation 1\ntq5: Start of sub squares growing\ntq6: Start of flattening to stripes\ntq7: Start of stripes sliding\ntq8: Start of grid reformation stage 1\ntq9: Start of grid reformation stage 2\ntq10: Start of screen flash + grid shift + tile spin\ntq11: Start of wipe from outside in\ntq12: Start of global rotation 2\ntq13: Start of global rotation 3\ntq14: Start of tiles shrinking to nothing\n*/\n\n\n#define SCENE_QUADS_START SCENE_INTRO_END\n#define tq1 (SCENE_QUADS_START + beat)\n#define tq2 (tq1 + halfbeat)\n#define tq3 (tq2 + 1.5*beat)\n#define tq4 (tq3 + 1.5*beat)\n#define tq5 (tq4 + 4.0*beat)\n#define tq6 (tq5 + 4.5*beat)\n#define tq7 (tq6 + 0.5*halfbeat)\n#define tq8 (tq7 + 0.5*halfbeat+3.5*beat)\n#define tq9 (tq8 + halfbeat)\n#define tq10 (tq9 + 2.0*beat)\n#define tq11 (tq10 + beat)\n#define tq12 (tq11 + halfbeat)\n#define tq13 (tq12 + halfbeat)\n#define tq14 (tq13 + halfbeat)\n#define SCENE_QUADS_END (tq14 + 2.0*beat)\n// 24 beats total\n\nvec3 sceneQuads(vec2 pos, float time) {\n    vec3 color;\n    float bColor;\n    \n    if (time < tq2) {\n        float shift = smoothstep(tq1, tq2, time);\n        bColor = pos.y > 0.0 ?     step(-pos.x+0.5, 0.5*shift) : \n                 pos.y < 0.0 ? 1.0-step(-pos.x+0.5, 0.5*shift) : 0.0;\n    \n    \treturn vec3(bColor);\n    }       \n    // Decrease size\n    float size = z + z*4.0*smoothstep(tq3, tq4, time)\n                   + z*2.0*smoothstep(tq5, tq5+halfbeat, time)\n                   + z*0.25*smoothstep(tq5+halfbeat, tq6, time);\n\n    // Global rotation\n    float rot = -PI/4.0 + PI/4.0*smoothstep(tq4,  tq4 +    halfbeat, time)\n        \t\t\t    + PI/4.0*smoothstep(tq12, tq12+0.5*halfbeat, time)\n        \t\t\t    + PI/4.0*smoothstep(tq13, tq13+0.5*halfbeat, time);\n    pos *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n\n    // s > 1.0 will make grid 2 and 3 visible\n    float s = 1.0+0.5*smoothstep(tq5, tq5+halfbeat, time);\n\n    // Grid skewing\n    float diffSkew   = 0.03;\n    float centerSkew = 0.25;\n    float skew = (centerSkew + diffSkew)\n               * smoothstep(tq6, tq7, time);\n    float miniSkew = max(0.0, skew - centerSkew);\n    float subSkew  = miniSkew-min(skew, centerSkew - diffSkew);\n\n    float reskew = (centerSkew + diffSkew) \n        \t     * smoothstep(tq8, tq8+0.5*halfbeat, time);\n\n    float unskew = pow(2.0, 0.5) * diffSkew\n                 * smoothstep(tq9, tq9+0.5*halfbeat, time);\n\n    vec2 mainGridSize = vec2( reskew, skew)-unskew  +vec2(z)/s;\n    vec2 subGridSize  = vec2(-reskew, subSkew)    +z-vec2(z)/s;\n\n    mainGridSize += z*smoothstep(tq14, tq14+0.5*halfbeat, time);\n\n    // Wipe transition\n    float wipeSize = (z+0.5)*(1.0 - smoothstep(tq11, tq11+halfbeat, time));\n\n    // Only apply blur after tq4 (rotation)\n    // and before tq6 (flattening to stripes)\n    float blur = 0.005*step(tq4, time) * (1.0 - step(tq6, time));\n    \n    // Slide grids\n    float slide = (1.0/size) * 0.1*smoothstep(tq7, tq8, time);\n    pos += slide;\n\n    // Screen flash and recenter grid\n    pos = time >= tq10 ? pos - slide : pos;   \n    if (time >= tq10 && time <= tq10+0.1*beat) return vec3(0.0);\n    \n    // Tile spin\n    float spin = PI/2.0*smoothstep(tq10, tq10 + halfbeat, time);\n    \n    // Wipe square\n    vec2 pos4 = pos;\n    pos4 = rotate2D(pos4, PI/4.0);\n    pos4.x += z;\n    float wipeSquare = box(pos4, vec2(wipeSize), EPS);\n\n    // Create 3 separate grids \n    vec2 pos1 = pos;\n    pos1 = tile(pos, size);\n    pos1 = rotate2D(pos1, PI/4.0+spin);\n    float grid1 = box(pos1, mainGridSize, blur);\n\n    // Center squares on edges of grid1\n    vec2 shift = vec2(0.5/size, 0.0);\n\n    vec2 pos2 = tile(pos - shift, size);\n    pos2 = rotate2D(pos2, PI/4.0);\n    float grid2 = box(pos2, subGridSize, 0.5*blur);\n\n    vec2 pos3 = tile(pos - shift.yx, size);\n    pos3 = rotate2D(pos3, PI/4.0);\n    float grid3 = box(pos3, subGridSize, 0.5*blur);\n\n    float grids = min(grid1, min(grid2, grid3));\n    \n    // Apply an XOR between the grids and wipeSquare\n    bColor = mod(grids + wipeSquare, 2.0);\n\n    return vec3(bColor);\n}\n\n/*\ntc0: Circles start moving out\ntc1: Circles start rotating\ntc2: Radius increase 1\ntc3: Radius increase 2\ntc4: Radius increase 3\ntc5: Radius increase 4\n*/\n\n#define SCENE_CIRCLES_START SCENE_QUADS_END\n#define tc0 (SCENE_CIRCLES_START + 3.0*beat)\n#define tc1 (tc0 + 3.0*beat)\n#define tc2 (tc1 + beat)\n#define tc3 (tc2 + beat)\n#define tc4 (tc3 + beat)\n#define tc5 (tc4 + halfbeat)\n#define SCENE_CIRCLES_END (tc5 + 2.5*beat)\n// 12 beats total\n\n// I used digital's shader as a starter for this scene\n// https://www.shadertoy.com/view/XtcBzr\nvec3 sceneCircles(vec2 uv, float time) {\n    vec3 color;\n    float nCircles = 12.0;\n    float camZoom  = 0.05;\n    \n    // Continously rotate the scene\n    float rotS = 0.1;\n    float rot = time > tc1 ? (time - tc1)*rotS : 0.0;\n    uv *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n\n    float dist = smoothstep(tc0, tc1, time) * 2.97;\n    \n    // Change circle radius at specific times\n    float radius = -1.0 +  1.5*smoothstep(SCENE_CIRCLES_START, tc0, time)\n                        + 0.61*smoothstep(tc2, tc2+halfbeat, time)\n                        + 0.48*smoothstep(tc3, tc3+halfbeat, time)\n                        +  0.5*smoothstep(tc4, tc4+halfbeat, time)\n                        + 16.0*smoothstep(tc5, tc5+beat, time);\n    \n    // Color intensity / transparency\n    float alpha = 0.20;\n\n    for (float i=0.0; i<nCircles; i++) {\n        vec2 pos = uv/camZoom;\n\n        // Space circles along radius of the origin\n        float x = dist*cos(2.0*PI*i/nCircles);\n        float y = dist*sin(2.0*PI*i/nCircles);\n        pos.x += x;\n        pos.y += y;\n\n        // SDF controls color brightness\n        // SDF of <= 0 indicates point is outside of shape\n        float sdf = clamp(sdfCircle(pos, radius), 0.0, alpha);\n\n        // Evenly space hue\n        float hue = float(i)/nCircles;\n        color += hsv2rgb(vec3(hue, 0.8, sdf));\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Correct for the delay between Soundcloud \n    // and YouTube audio of Infinite Gravity\n    float time = iTime + 0.4;\n    \n    float end = SCENE_CIRCLES_END; // End of last scene\n    time += SCENE_INTRO_START;     // Start at specified scene\n    time = mod(time, end);         // Loop at end of last scene\n    \n    // NDC from -1/2 to 1/2\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n    \n    vec3 scene;\n    if (time < SCENE_INTRO_END) {\n        scene = sceneIntro(uv, time); \n    } else if (time < SCENE_QUADS_END) {\n        scene = sceneQuads(uv, time);\n    } else if (time < SCENE_CIRCLES_END) {\n        scene = mix(1.0-sceneCircles(uv, time), vec3(0), \n                    smoothstep(end-halfbeat, end, time));\n    } else {\n        scene = vec3(1.0);   \n    }\n\n    fragColor = vec4(scene, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}