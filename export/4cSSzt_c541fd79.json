{"ver":"0.1","info":{"id":"4cSSzt","date":"1706661956","viewed":118,"name":"CoolRayTracingThing","username":"DataLioness","description":"Cool raytracing thing I'm using for self-study to learn how raytracing works.\n\nCredits from my GF for help: Spheya","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct HitInfo {\n    bool hit;\n    float dist;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct LightSource {\n    vec3 origin;\n    float power;\n};\n\nHitInfo sphereIntersection(Ray ray, vec3 position, float radius) {\n    HitInfo hit;\n    hit.hit = false;\n    hit.dist = 1000000.0;\n    hit.normal = vec3(0.0);\n    hit.color = vec3(0.0);\n\n    float distToNearestPos = dot(ray.direction, position - ray.origin);\n    vec3 nearestPos = ray.origin + ray.direction * distToNearestPos;\n    vec3 toSphereCenter = position - nearestPos;\n    float offsetToEdgeSq = radius * radius - dot(toSphereCenter, toSphereCenter);\n    \n    if(offsetToEdgeSq < 0.0 || distToNearestPos < 0.0) return hit; // miss\n    \n    // hit\n    hit.hit = true;\n    hit.dist = distToNearestPos - sqrt(offsetToEdgeSq);\n    hit.normal = normalize((ray.origin + ray.direction * hit.dist) - position);\n    hit.color = vec3(1.0, 0.0, 1.0);\n    return hit;\n}\n\nHitInfo planeIntersection(Ray ray, float height) {\n    HitInfo hit;\n    hit.hit = false;\n    hit.dist = 1000000.0;\n    hit.normal = vec3(0.0);\n    hit.color = vec3(0.0);\n    \n    float dist = (ray.origin.y - height) / -ray.direction.y;\n    if(dist < 0.0) return hit; // miss\n    \n    // hit\n    hit.hit = true;\n    hit.dist = dist;\n    hit.normal = vec3(0.0, 1.0, 0.0);\n    hit.color = vec3(0.0, 1.0, 0.0);\n    return hit;\n}\n\nHitInfo sceneIntersection(Ray ray) {\n    HitInfo sphere = sphereIntersection(ray, vec3(0.0, 0.0, 10.0), 3.0);\n    HitInfo sphereTwo = sphereIntersection(ray, vec3(sin(iTime/4.0)*4.0,0.0,7.0), 1.0);\n    HitInfo plane = planeIntersection(ray, -3.0);\n    \n    if(sphereTwo.dist < sphere.dist && sphereTwo.dist < plane.dist) return sphereTwo;\n    if(sphere.dist < plane.dist && sphere.dist < sphereTwo.dist) return sphere;\n    else return plane;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec2 screenPos = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Ray init\n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.direction = normalize(vec3(screenPos, 1.0));\n    \n    \n    vec3 spherePos = vec3(0.0, 0.0, 5.0);\n    LightSource lightSource;\n    lightSource.origin = vec3(sin(iTime), cos(iTime/5.0)+1.5, cos(iTime))*20.0 + spherePos;\n    lightSource.power = 5000.0f;\n    \n    \n    \n    HitInfo hitInfo = sceneIntersection(ray);\n    if(hitInfo.hit){\n        \n        // ShadowRay\n        Ray shadowRay;\n        shadowRay.origin = ray.origin + (ray.direction * (hitInfo.dist - 0.001));\n        shadowRay.direction = normalize(lightSource.origin - shadowRay.origin);\n        \n        HitInfo shadowHitInfo = sceneIntersection(shadowRay);\n        if(shadowHitInfo.hit){\n            fragColor.rgb = vec3(0.0);\n        }else{\n            fragColor.rgb = vec3(hitInfo.color * dot(hitInfo.normal, shadowRay.direction)) * (lightSource.power / pow(length(shadowRay.origin - lightSource.origin), 3.0));\n        }\n        \n        // ReflectionRay\n        //Ray reflectionRay;\n        //reflectionRay.origin = shadowRay.origin;\n        //reflectionRay.direction = reflect(ray.direction, hitInfo.normal);\n        //HitInfo reflectHitInfo = sceneIntersection(reflectionRay);\n        //fragColor.rgb = mix(reflectHitInfo.color, fragColor.rgb, 0.99);\n     \n    }\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2)); // gamma correction\n}\n","name":"Image","description":"","type":"image"}]}