{"ver":"0.1","info":{"id":"sddSzM","date":"1632883456","viewed":124,"name":"From  a single Bezier Line","username":"shyuriken","description":"from  a single bezier line sdf\nusing a single bezier line.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["bezierfold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Processed by 'GLSL Shader Shrinker' (Shrunk by 7,134 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n\n\n\nfloat det2(vec3 a, vec3 b, vec3 v) { return dot(v, cross(a, b)); }\n\nvec2 rot(vec2 p, float an) {\n\tfloat cc = cos(an),\n\t      ss = sin(an);\n\treturn vec2(cc * p.x - ss * p.y, ss * p.x + cc * p.y);\n}\n\nvec4 sdBezier(vec3 p, vec3 b0, vec3 b1, vec3 b2) {\n\tb0 -= p;\n\tb1 -= p;\n\tb2 -= p;\n\tvec3 g, q,\n\t     d21 = b2 - b1,\n\t     d10 = b1 - b0,\n\t     d20 = (b2 - b0) * .5,\n\t     n = normalize(cross(d10, d21));\n\tfloat f, t, k,\n\t      a = det2(b0, b2, n),\n\t      b = det2(b1, b0, n),\n\t      d = det2(b2, b1, n);\n\tg = b * d21 + d * d10 + a * d20;\n\tf = a * a * .25 - b * d;\n\tt = clamp(dot(cross(b0, n) + f * g / dot(g, g), d10 - d20) / (a + b + d), 0., 1.);\n\tq = mix(mix(b0, b1, t), mix(b1, b2, t), t);\n\tk = dot(q, n);\n\treturn vec4(length(q), t, -k, -sign(f) * length(q - n * k));\n}\n\nfloat pBezier(float n, vec3 pa, vec3 pb, vec3 pc, vec3 p) {\n\tvec4 res,\n\t     b = sdBezier(p, pa, pb, pc);\n\tvec2 tmp,\n\t     q = rot(b.zw, 0.);\n\tres = vec4(99, q, b.y);\n\ttmp = q;\n\tres.x = length(tmp) - n;\n\tres.yz = tmp;\n\treturn res.x;\n}\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nvec3 mRepInf(vec3 cell_size, vec3 p) { return p - cell_size * round(p * vec3(greaterThan(cell_size, vec3(0))) / cell_size); }\n\nfloat sabs(float p) { return sqrt(p * p + 1e-2); }\n\nvec3 mFold(vec3 sw, vec3 t, vec3 p) {\n\tfloat h, a,\n\t      n = sw.x,\n\t      r = sw.y;\n\tbool s = sw.z > 0.;\n\th = floor(log2(n));\n\ta = 6.2832 * exp2(h) / n;\n\tfor (int i = 0; i < int(h) + 2; i++) {\n\t\tvec2 v = normalize(vec2(-cos(a), sin(a)));\n\t\tfloat g = dot(p.xz, v);\n\t\tp.xz -= (g - ((r > 0.) ? sabs(g) : abs(g))) * v;\n\t\ta *= .5;\n\t}\n\n\tp.xz -= clamp(p.xz, s ? -t.xz : t.xz, t.xz);\n\treturn p;\n}\n\nfloat sdf(vec3 p0) {\n\tfloat d1;\n\t{\n\t\tvec3 p1 = mRepInf(vec3(5.4, -1, 5.5), p0);\n\t\t{\n\t\t\tvec3 p2 = mFold(vec3(24, 1, 1), vec3(0, 0, 1), p1);\n\t\t\t{ d1 = pBezier(.1,  vec3(-1.5,1.1*sin(iTime), 0.), vec3(.5, cos(iTime)*0.1, 0), vec3(0, -1.5, 0), mRotation(mat3(-.017452, 0, .999848, 0, 1, 0, -.999848, 0, -.017452), p2)); }\n\t\t}\n\t}\n\treturn d1;\n}\n\nvec3 calcNormal(vec3 pos) {\n\tconst vec2 e = vec2(1, -1) * 58e-5;\n\treturn normalize(e.xyy * sdf(pos + e.xyy) + e.yyx * sdf(pos + e.yyx) + e.yxy * sdf(pos + e.yxy) + e.xxx * sdf(pos + e.xxx));\n}\n\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 4; i++) {\n\t\taopos = pos + nor * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = ro + t * rd;\n\t\tfloat h = sdf(pos);\n\t\tif (h < .001) break;\n\t\tt += h;\n\t\tif (t > 80.) break;\n\t}\n\n\tif (t > 80.) t = -1.;\n\treturn t;\n}\n\nvec3 env_color(vec3 dir) {\n\tif (dir.y > 0.) return mix(vec3(0, .5, 1), vec3(0, .1, .8), dir.y);\n\treturn mix(vec3(0, .5, 1), vec3(.8, .7, .6), pow(-dir.y, .5));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat t,\n\t      fi = 10. * iMouse.x / iResolution.x,\n\t      th = 10. * iMouse.y / iResolution.y;\n\tvec3 ro = vec3(5. * cos(fi) * sin(th), 2., 3. * cos(th)),\n\t     ww = normalize(vec3(0) - ro),\n\t     uu = normalize(cross(ww, vec3(0, 1, 0))),\n\t     rd = normalize(p.x * uu + p.y * normalize(cross(uu, ww)) + 1.5 * ww),\n\t     col = vec3(.25, .72, .75) - .005 * rd.y;\n\tt = castRay(ro, rd);\n\tif (t > 0.) {\n\t\tcol = vec3(1);\n\t\tvec3 pos = ro + t * rd,\n\t\t     nor = calcNormal(pos);\n\t\tfloat occ = calcOcclusion(pos, nor);\n\t\tvec3 sun_dir = normalize(vec3(.8, .4, .2));\n\t\tfloat sun_sha = step(castRay(pos + nor * .001, sun_dir), 0.),\n\t\t      sun_dif = clamp(dot(nor, sun_dir), 0., 1.),\n\t\t      sky_dif = clamp(.5 + .5 * dot(nor, vec3(0, 1, 0)), 0., 1.),\n\t\t      bou_dif = clamp(.5 + .5 * dot(nor, vec3(0, -1, 0)), 0., 1.);\n\t\tcol = vec3(.18) * vec3(7, .3, 5) * sun_dif * sun_sha;\n\t\tcol += vec3(.18) * vec3(.8, .3, .2) * sky_dif * occ;\n\t\tcol += vec3(.18) * vec3(.7, .3, .2) * bou_dif * occ;\n\t}\n\telse col = env_color(rd);\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}\n","name":"Image","description":"","type":"image"}]}