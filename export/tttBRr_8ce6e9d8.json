{"ver":"0.1","info":{"id":"tttBRr","date":"1612139469","viewed":618,"name":"Curler 1.0 Test","username":"sjdacruz","description":"Author: https://www.shadertoy.com/view/XsVBzd","likes":7,"published":3,"flags":34,"usePreview":0,"tags":["webcam"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{\n    vec4 selfState = texture(iChannel0, (fragCoord / iResolution.xy));\n    \n    outFragColor = selfState;\n    //outFragColor = (selfState * pow(selfState.a, 20.0));\n    outFragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int k_blurRadius = 10;\n\nfloat RandomFloat(\n  vec2 testCoord)\n{\n\t// From: https://www.shadertoy.com/view/Xd23Dh\n\t// (just removed some dimensions)\n\tfloat testCoordInGeneratorSpace = \n\t\tdot(testCoord, vec2(127.1, 311.7));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvec2 RandomVec2(\n  vec2 testCoord)\n{\n\t// From: https://www.shadertoy.com/view/Xd23Dh\n\t// (just removed some dimensions)\n\tvec2 testCoordInGeneratorSpace = vec2(\n\t\tdot(testCoord, vec2(127.1, 311.7)),\n\t\tdot(testCoord, vec2(269.5, 183.3)));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvec3 RandomVec3(\n  vec2 testCoord)\n{\n    // From: https://www.shadertoy.com/view/Xd23Dh\n    // (just removed some dimensions)\n    vec3 testCoordInGeneratorSpace = vec3(\n        dot(testCoord, vec2(127.1, 311.7)),\n        dot(testCoord, vec2(269.5, 183.3)),\n        dot(testCoord, vec2(419.2, 371.9)));\n\n\treturn fract(sin(testCoordInGeneratorSpace) * 43758.5453);\n}\n\nvec2 TransformFromCanvasTextureToFramedTexture(\n\tvec2 canvasTextureCoord,\n\tvec2 canvasTextureSize,\n\tvec2 framedTextureSize)\n{\t\n\tvec2 result = (canvasTextureCoord / canvasTextureSize);\n\n\tfloat canvasAspectRatio = (canvasTextureSize.x / canvasTextureSize.y);\n\tfloat framedAspectRatio = (framedTextureSize.x / framedTextureSize.y);\n\n\tif (framedAspectRatio < canvasAspectRatio)\n\t{\n\t\tfloat relativeAspectRatio = (canvasAspectRatio / framedAspectRatio);\n\n\t\tresult.x *= relativeAspectRatio;\n\t\tresult.x -= (0.5 * (relativeAspectRatio - 1.0));\n\t}\n\telse\n\t{\n\t\tfloat relativeAspectRatio = (framedAspectRatio / canvasAspectRatio);\n\n\t\tresult.y *= relativeAspectRatio;\n\t\tresult.y -= (0.5 * (relativeAspectRatio - 1.0));\n\t}\n\n\treturn result;\n}\n\nbool TextureCoordIsInBounds(\n\tvec2 texCoord)\n{\n\tvec2 inBounds = (\n        step(vec2(0.0), texCoord) * \n        step(texCoord, vec2(1.0)));\n    \n    return ((inBounds.x > 0.5) && (inBounds.y > 0.5));\n}\n\nvec4 SampleWebcam(\n\tsampler2D webcamTexture,\n\tvec2 webcamSize,\n    bool horizontallyMirrorWebcam,\n    vec2 canvasCoord,\n\tvec2 canvasSize)\n{\n\tvec2 webcamCoord = \n        TransformFromCanvasTextureToFramedTexture(\n            canvasCoord, \n            canvasSize, \n            webcamSize);\n\n    if (horizontallyMirrorWebcam)\n    {\n    \twebcamCoord.x = mix(1.0, 0.0, webcamCoord.x);\n    }\n    \n    vec4 result = TextureCoordIsInBounds(webcamCoord) ? \n        pow(texture(webcamTexture, webcamCoord), vec4(2.0)) : \n    \tvec4(0.0, 0.0, 0.0, 1.0);\n    \n    return result;\n}\n\nfloat GetBrightness(\n    vec4 color)\n{    \n    return (0.333 * (color.r + color.g + color.b));\n}\n\nvec4 ComputePseudoGaussianBlur(\n\tsampler2D source,\n    vec2 texelSize,\n    vec2 fragCoord,\n    vec2 blurDirection) // Unit-length. Typically (1, 0) or (0, 1).\n{\n    vec4 accumulator = vec4(0.0);\n    float totalWeight = 0.0;\n    \n    float oneOverBlurRadius = (1.0 / 10.0);\n\n    vec2 sampleUvIncrement = (blurDirection * texelSize);\n    vec2 sampleUv = (\n        (fragCoord * texelSize) - \n        (float(k_blurRadius) * sampleUvIncrement));\n    \n    float uncurvedSampleWeight = -1.0;\n    float uncurvedSampleWeightIncrement = (1.0 / float(k_blurRadius));\n    \n    for (int index = (-1 * k_blurRadius); index <= k_blurRadius; index++)\n    {\n        vec4 sampleColor = texture(source, sampleUv);\n\n        // NOTE: Small fudge to make the outermost texels non-zero.\n        float sampleWeight = smoothstep(\n            (1.0 + oneOverBlurRadius), \n            0.0, \n            abs(uncurvedSampleWeight));\n        sampleWeight = (sampleWeight * sampleWeight * sampleWeight); \n\n        accumulator += (sampleColor * sampleWeight);\n        totalWeight += sampleWeight;\n        \n        sampleUv += sampleUvIncrement;\n        uncurvedSampleWeight += uncurvedSampleWeightIncrement;\n    }\n\n    return (accumulator / totalWeight);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Pass: Webcam perspective correction.\n\nvoid mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{    \n    outFragColor = SampleWebcam(\n\t\tiChannel0,\n\t\tiChannelResolution[0].xy,\n    \ttrue, // horizontallyMirrorWebcam\n    \tfragCoord,\n\t\tiResolution.xy);\n    \n    outFragColor.a = GetBrightness(outFragColor);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Pass: Vertical blur.\n\nvoid mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{\n    outFragColor = ComputePseudoGaussianBlur(\n        iChannel0,\n        (1.0 / iResolution.xy),\n        fragCoord,\n        vec2(0.0, 1.0));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Pass: Horizontal blur.\n\nvoid mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{\n    outFragColor = ComputePseudoGaussianBlur(\n        iChannel0,\n        (1.0 / iResolution.xy),\n        fragCoord,\n        vec2(1.0, 0.0));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Pass: Curl and simulation.\n\nvec2 s_texelSize;\n\nvec2 ComputeGradient(\n    vec2 fragUv)\n{\n    // HAAAAACK!\n    \n    vec4 center = texture(iChannel0, fragUv);\n    vec4 right = texture(iChannel0, (fragUv + vec2(s_texelSize.x, 0.0)));\n    vec4 up = texture(iChannel0, (fragUv + vec2(0.0, s_texelSize.y)));\n\n    return vec2((center.a - right.a), (center.a - up.a));\n} \n\nvoid mainImage(\n    out vec4 outFragColor,\n    vec2 fragCoord)\n{\n    s_texelSize = (1.0 / iResolution.xy);\n    \n    vec2 fragUv = (fragCoord * s_texelSize);\n    \n    vec2 gradient = ComputeGradient(fragUv);\n    vec2 curl = vec2((-1.0 * gradient.y), gradient.x);\n    \n    vec4 selfState = texture(iChannel1, fragUv);\n    \n    vec2 frameOffset = vec2(mod(float(iFrame), 97.0), mod(float(iFrame), 101.0));\n    vec2 frameRandom = RandomVec2(fragUv + frameOffset);\n    \n    if (frameRandom.x > selfState.a)\n    {\n        vec4 camera = texture(iChannel2, fragUv);\n        \n        outFragColor.rgb = mix(selfState.rgb, camera.rgb, 0.8);\n        //outFragColor.rgb = camera.rgb;\n        \n        //outFragColor.a = mix(outFragColor.a, 1.0, frameRandom.y);\n        outFragColor.a = 1.0;\n    }\n    else\n    {\n        vec2 normalizedCurl = (curl / (length(curl) + 0.00001));\n            \n        vec4 curlSourceState = texture(iChannel1, (fragUv + (normalizedCurl * s_texelSize)));\n        \n        outFragColor = curlSourceState;\n        //outFragColor.rg = smoothstep(vec2(-1.0), vec2(1.0), (25.0 * curl));\n        \n        outFragColor.a -= (0.005 * iTimeDelta);\n    }\n}","name":"Buffer D","description":"","type":"buffer"}]}