{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\nvec2 rotate(vec2 point, vec2 origin, float angleRad) {\n\tfloat rotatex = cos(angleRad) * (point.x - origin.x) - sin(angleRad) * (point.y - origin.y) + origin.x;\n\tfloat rotatey = sin(angleRad) * (point.x - origin.x) + cos(angleRad) * (point.y - origin.y) + origin.y;\n\treturn vec2(rotatex, rotatey);\n}\n\nfloat dist(vec2 source, vec2 dest) {\n\tvec2 diff = dest - source;\n\treturn sqrt(diff.x * diff.x + diff.y * diff.y);\n}\n\nfloat distToLine(vec2 a, vec2 n, vec2 p) {\n\tvec2 temp = (a-p) - dot((a-p), n) * n;\n\treturn length(temp);\n}\n\t\nfloat button(vec2 position, vec2 pixelPos, vec2 lightDir) {\n\t\n\tfloat width = 60.0;\n\tfloat height = 60.0;\n\t\n\t// super-ellipse button center\n\t// (xr / a) ^ m + (yr / b) ^ n = 1\n\tfloat m = 1.4;\n\tfloat n = 1.4;\n\tfloat a = width + 4.0;\n\tfloat b = height + 4.0;\n\tfloat omega = 3.14159/4.0;\n\tvec2 rotated = rotate(pixelPos, position, omega);\n\tfloat superellipse = pow(((rotated.x - position.x) / a), m) + pow(((rotated.y - position.y) / b), n);\n\tsuperellipse = clamp(step(superellipse, 1.0) * (position.x - pixelPos.x + width) * 0.003, 0.0, 1.0);\n\t\n\t// specular highlights and shadow. second step parameter is for some anti-aliasing\n\tfloat superellipseBorder = pow(((rotated.x - position.x) / (a+2.5)), (m-0.06)) + pow(((rotated.y - position.y) / (b+2.5)), (n-0.06));\n\tsuperellipseBorder = clamp(step(superellipseBorder, 1.0) * (pixelPos.x - position.x + width-6.0) * 0.006, 0.0, 1.0);\n\n\t// square button outer shaded on two sides\n\t// (x / p) ^ 2 + (y / q) ^ 2\n\tfloat buttonRight, buttonLeft;\n\tfloat button = max(((pixelPos.x - position.x) / width) * ((pixelPos.x - position.x) / width),\n\t\t\t\t   ((pixelPos.y - position.y) / height) * ((pixelPos.y - position.y) / height));\n\t// basic 4 point radial gradients\n\tbuttonRight = step(button, 1.0) * 0.006 * (60.0 - min(distToLine(position, normalize(vec2(1,1)), pixelPos),\n\t\t\t\t\t\t\t\t\t\t\t distToLine(position, normalize(vec2(-1,1)), pixelPos)));\n\tbuttonRight += step(button, 1.0) * 0.001 * (position.x - pixelPos.x + width);\n\tbuttonRight -= step(button, 1.0) * 0.0015 * (position.x - pixelPos.x - width);\n\t\n\tbuttonLeft = step(button, 1.0) * 0.0028 * (position.x - pixelPos.x);\n\tbutton = mix(buttonLeft, buttonRight, abs(position.x-pixelPos.x-width+3.0)/160.0);\n\tbutton *= 4.0; // brightness\n\t\n\tif (superellipse > 0.0) {\n\t\treturn superellipse + 0.75;\n\t} else if (superellipseBorder > 0.0) {\n\t\treturn superellipseBorder * 0.4 + button - 0.1;\n\t} else {\n\t\treturn button;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pixelPos = fragCoord.xy;\n\tvec2 offset = vec2(iResolution.x * 0.5, iResolution.y * 0.5);\n\tvec2 lightDir = vec2(0,1);\n\t\t\n\tfloat shading = button(offset, pixelPos, lightDir); // monochrome / ramp shaded\n\tshading += button(offset+vec2(122,0), pixelPos, lightDir); // monochrome / ramp shaded\n\tshading += button(offset+vec2(-122,0), pixelPos, lightDir); // monochrome / ramp shaded\n\t\n\tfragColor = vec4(shading, shading*shading*shading*0.25, 0.07, 1);\n\t\n\t\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsSGDm","date":"1389015758","viewed":231,"name":"Abatron 803","username":"rocifier","description":"Replicating the look of the buttons on an Abatron 803 calculator. Can anyone help me add a variable light source that rotates around the button? Got confused converting the x axis and shifts by the button width..","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["button","calculator","abatron"],"hasliked":0,"parentid":"","parentname":""}}