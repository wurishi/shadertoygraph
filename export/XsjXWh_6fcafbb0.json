{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float rand(vec3 n) {\n  n = floor(n);\n  n.z = 100.0*fract(n.z/100.0);\n  return fract(sin((n.x*1e2+n.y*1e4+n.z*1e6)*1e-4)*1e5);\n}\n\nvec3 light( vec3 ray,vec3 lightPos,float cr) {\n    vec3 f = fract( ray ) -0.5;\n    vec3 normf = normalize(f);\n    vec3 light = lightPos-ray;\n    float lighting = normf.x*light.x+normf.y*light.y+normf.z*light.z;\n    lighting=lighting<0.0?0.0:lighting;\n    float l2 = length(light);\n\treturn 3.0*lighting/pow((l2+0.40),2.5)*vec3(0.8*cr,0.5,0.8-cr);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n    float t = iTime+0.2;\n    float tt = iTime+2.0;\n    \n    //camera\n    vec3 camPos = vec3(cos(iTime*0.5), sin(iTime*0.5), -iTime*0.5);\n    vec3 camTarget = vec3(cos(t*0.5), sin(t*0.5), -t*0.5);\n    vec3 camDir = normalize(camTarget-camPos);\n    vec3 camUp  = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 camSide = cross(camDir, camUp);\n    camUp  = cross(camDir, camSide);\n    vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*1.5);\n    \n    //light position\n    vec3 lightPos = vec3(cos(tt*0.5), sin(tt*0.5), -tt*0.5);\n    lightPos += vec3(0.1*sin(iTime*5.0),0.1*cos(iTime*3.0),0.1*cos(iTime*4.0));\n    lightPos -=pow(1.0-2.0*abs(fract(iTime/7.0)-0.5),6.)*(-camDir)*5.0;\n    \n    //raymarching\n    vec3 ray = camPos;\n    float l_min = length(cross(lightPos-ray,rayDir));\n\tfloat halo = 0.0005/l_min/l_min;\n    float cr;\n    bool end = true;\n    for(int i=0; i<30; ++i) {\n\t\tcr = 0.3*rand( ray );\n        vec3 bc = floor(ray)+0.5;\n        float d_min = length(cross(rayDir,bc-camPos));\n        if ((d_min<cr)&&(dot(bc-camPos,camDir)>0.0)){\n            \n            //determine closest intersection of ray and sphere\n         \tvec3 d_min_vec = normalize(cross(cross(bc-camPos,rayDir),rayDir));\n            float l1 = sqrt(cr*cr-d_min*d_min);\n            ray = bc + d_min_vec*d_min-rayDir*l1;\n            \n            if (length(ray - camPos)<length(lightPos-camPos)) {halo = 0.0;}\n            end = false;\n            break;\n        }\n        ray+=0.8*rayDir;\n    }\n    vec3 color = end?vec3(0.0,0.0,0.0):light(ray,lightPos,cr/0.3);\n    fragColor = vec4( color+halo*(1.0,1.0,1.0), 1.0 );;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsjXWh","date":"1411479526","viewed":1824,"name":"Exploring the crystal lattice","username":"Devin","description":"My attempt to create a simple 3D shader, after studying the code of other ones.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","balls"],"hasliked":0,"parentid":"","parentname":""}}