{"ver":"0.1","info":{"id":"4s3XzH","date":"1457560974","viewed":240,"name":"Ball Torch","username":"rainman110","description":"Simulated a ball with phong shader. The light source comes from a torch at the current mouse position.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ATTENUATION\n\n// Phong shading with a light source from the current\n// mouse position, including attenuation\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst vec3 diffuseColor = vec3(1.0, 0.0, 1.0);\n    const vec3 ambient = vec3(0.0, 0.0, 0.0);\n\tconst vec3 specColor = vec3(1.0, 1.0, 1.0);\n    \n    // the center of the texture\n    vec2 center = iResolution.xy /2.; \n\t\n    // current pixel location\n    vec2 loc = fragCoord.xy;\n\t\n    // how far we are from the center\n    float radius = 100.;\n\n    // vertex position relative to the unit circle\n    vec3 vertPos = vec3((loc-center)/radius, 0.);\n    float distToCenter = length(vertPos);\n    if (distToCenter < 1.)\n        vertPos.z = sqrt(1.- dot(vertPos.xy, vertPos.xy));\n    \n    // normal is identical to vertex position on a sphere\n    vec3 normal = vertPos;\n    \n    // compute position of the light. It should follow\n    // the mouse at a height of 2.0\n    float lightDis = 2.0;\n    vec3 mouse3d = vec3((iMouse.xy - center.xy) / radius, 2.0);\n    lightDis *= (1.+ dot(mouse3d.xy, mouse3d.xy));\n\n\n    vec3 lightpos = lightDis * mouse3d;\n    vec3 lightDir = normalize(lightpos - vertPos);\n\n    // fragment phong shader\n    int mode = 2;\n\n    float lambertian = max(dot(lightDir,normal), 0.0);\n    float specular = 0.0;\n\n    if(lambertian > 0.0) {\n\n        vec3 reflectDir = reflect(-lightDir, normal);\n        vec3 viewDir = normalize(vertPos);\n\n        float specAngle = max(dot(reflectDir, viewDir), 0.0);\n        specular = pow(specAngle, 4.0);\n\n        // the exponent controls the shininess (try mode 2)\n        if(mode == 2)  specular = pow(specAngle, 20.0);\n\n        // according to the rendering equation we would need to multiply\n        // with the the \"lambertian\", but this has little visual effect\n        if(mode == 3) specular *= lambertian;\n\n        // switch to mode 4 to turn off the specular component\n        if(mode == 4) specular *= 0.0;\n        \n        #ifdef ATTENUATION\n        specular *= (2./sqrt(lightDis));\n        #endif\n\n    }\n\t\n    \n    // only draw, if we are inside the unit circle\n    if (distToCenter < 1.0)\n        fragColor = vec4( ambient*diffuseColor + lambertian*diffuseColor +\n                          specular*specColor, 1.0);\n    else\n        fragColor = vec4(0,0,0,1); // black background\n}","name":"Image","description":"","type":"image"}]}