{"ver":"0.1","info":{"id":"Ndy3Rm","date":"1631217039","viewed":224,"name":"Infinite 3D Grid Planes","username":"peepsalot","description":"3D Grid planes with major/minor divisions.  Click and drag mouse to change rotate orbit and zoom.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","grid","infinite","scale","axes","tickmarks"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// plane defined by p (p.xyz must be normalized)\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p )\n{\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N) {\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    //vec2 a = p + scl*w;\n    //vec2 b = p - scl*w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0) \n       -floor(b) - min(fract(b) * N, 1.0) \n      ) / (N*w)\n      , vec2(0), vec2(1))\n    ;\n    return (1.0 - i.x) * (1.0 - i.y);\n    return 1.0 / (w.x + w.y);\n}\n\n\nfloat grid_lookup(in vec3 ro, in vec3 rd, in vec4 pln, float scale, float lineRatio) {\n    float t = plane(ro, rd, pln);\n    if (t > 0.0)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z); \n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera position based on (click drag current position) - (click drag start)\n    vec2 mouse = (iMouse.xy - abs(iMouse.zw)) / iResolution.xy;\n    // camera movement  \n    float an = /*0.25 * iTime*/ + 6.29 * mouse.x;\n    float d = 1.0 + 4.0 * mouse.y;\n    vec3 ro = vec3( d * cos(an), d, d * sin(an) );\n    vec3 ta = vec3(0.0, 0.5*d, 0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww, vec3(0.0, 1.0, 0.0) ) );\n    vec3 vv = normalize( cross(uu, ww));\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    // create view ray\n    vec3 rd = normalize( p.x * uu + p.y * vv + 1.5 * ww );\n    float val =\n      max(grid_lookup(ro, rd, vec4(1, 0, 0, 0), 1.0, 24.0), grid_lookup(ro, rd, vec4(1, 0, 0, 0), 5.0, 32.0)) +\n      max(grid_lookup(ro, rd, vec4(0, 0, 1, 0), 1.0, 24.0), grid_lookup(ro, rd, vec4(0, 0, 1, 0), 5.0, 32.0)) +\n      max(grid_lookup(ro, rd, vec4(0, 1, 0, 0), 1.0, 24.0), grid_lookup(ro, rd, vec4(0, 1, 0, 0), 5.0, 32.0));\n    \n    //if (val <= 0.0) discard;\n    fragColor = vec4(1, 1, 1, 0.75) * val / 3.0;\n}","name":"Image","description":"","type":"image"}]}