{"ver":"0.1","info":{"id":"ml3cRH","date":"1698884290","viewed":56,"name":"Space Defender (Playable)","username":"iznax","description":"Work-In-Progress... defenderish game simulation... currently only lets player fly Left/Right/Up/Down over terrain... no shooting enemies, yet.\n\nControls: Arrow keys or WASD to fly and SPACE to fire\n\n","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["game","space","playable","arcade","defender"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_W     = 87;\n\nvec3 Arrow(vec2 w, float angle, vec2 pos, vec3 col)\n{\n    vec2 v = w-pos;\n    if (length(v) < 16.)\n    {\n        float da = abs(atan(v.y,v.x)-angle);\n        if (da > 3.1415) da = 6.283 - da;\n        return (da < .6) ? vec3(1) : col;\n    }\n    return col;\n}\n\nconst int PARM_X = 0; // ship x\nconst int PARM_Y = 1; // ship y\nconst int PARM_B = 2; // buttons\nconst int PARM_D = 3; // ship direction\nconst int PARM_V = 4; // ship velocity\nconst int PARM_W = 5; // World position\n\n// Enemy properties\n\nconst int PARM_ET  = 70; // Time (-1 dead)\nconst int PARM_EX  = 71; // World X\nconst int PARM_EY  = 72; // World Y\nconst int PARM_EV  = 73; // Velocity\nconst int PARM_ER  = 74; // Explosion Radius\n\nint ReadButtons()\n{\n    return int(texelFetch(iChannel0, ivec2(PARM_B,0), 0).r);\n}\n\nvec3 Ship(vec2 w, vec2 pos, float dir, vec3 col)\n{\n    const float Scale = 1.5;\n    vec2 d = (w-pos)*Scale;\n    if (abs(d.x) < .05 && abs(d.y) < .035)\n    {\n        vec3 Wht = vec3(1);\n        float bx = d.x + dir*0.035;\n        float dx = abs(bx);\n        for (int i=0; i<9; ++i) { bx+=.001*dir;dx=min(dx,abs(bx)); }\n        bool back = -d.x*dir<.045;\n        if (dx+abs(d.y)<.025&&back) return Wht*.95; // tail fin\n        if (length(vec2(d.x*.3,d.y*1.5)) < .015) return Wht; // body\n        if (length(vec2(d.x*.5+dir*.01,d.y+.005)) < .015) return Wht*.8; // wing\n    }\n    return col;\n}\n\nfloat Get(int PARM)\n{\n    return texelFetch(iChannel0, ivec2(PARM,0), 0).r; \n}\n\nvec3 Stars(vec2 w, vec3 col)\n{\n    if (w.y > .3)\n    {\n        float y = w.y * 50.;\n        if (sin(y) > .9 && sin(iTime*.5 + w.x*2. + w.y*43100.) > .9999995) return vec3(1);\n    }\n    return col;\n}\n\n// Work-In-Progress\nvec3 Bullets(vec2 w, float T, vec3 col)\n{\n    const int B1 = 10;\n    const int BX = 50;\n    const int BSTEP = 10;\n    const float BSCALE = 40.;\n    const float BeamLength = .25*BSCALE;\n    vec3 beam = mix(0.5 + 0.5*cos(iTime+w.xyx+vec3(0,2,4)),vec3(1),.2);\n    // PARM_B1,B2,B3,etc.\n    for (int P=B1; P<=BX; P+=BSTEP)\n    {\n        // Age,X,Y,Vel\n        float A = Get(P+0);\n        float X = Get(P+1);\n        float Y = Get(P+2);\n        float V = Get(P+3);\n        if (A > 0. && abs(w.y-Y) < .003)\n        {\n            float wx = w.x + (V>0. ? .375 : -.375);\n            float t = (V>0. ? -1.:1.) * (X-T-wx*BSCALE)/BeamLength;\n            if (t > 0. && t < 1.)\n            {\n                float g = floor(w.x*64.+w.y*16.)/64.;\n                float hash = fract(sin(g+iTime)*4357.123);\n                return mix(beam,vec3(1),t*t)*hash;\n            }\n        }\n    }\n    return col;\n}\n\n// T = terrain world position\nvec3 Terrain(vec2 uv, float T, vec3 col)\n{\n    float scale = 64.;\n    float a = T*.25 + uv.x*7.;\n    float elev = sin(a+cos(a)*1.205-sin(a*4.)*cos(a))*.1+.2+sin(a*17.)*.01;\n    float uy = floor(uv.y*scale)/scale;\n    if (abs(uy-elev) < .007)\n    {\n        col = vec3(1.,.4,0);\n    }\n    return col;\n}\n\n// w   = normalized screen position being rendered\n// pos = world pos of sprite projected to screen coordinates\n// col = input color\nvec3 Human(vec2 w, vec2 pos, vec3 col)\n{\n    vec2 dw = w - pos;\n    if (abs(dw.x) < .01)\n    {\n        if (dw.y < -0.009)\n        {\n            if (abs(dw.x) < .002)\n            {\n                return vec3(.8,.25,0); // Leg\n            }\n            if (dw.y > -0.0225)\n            {\n                return vec3(1.,.1,.9); // Body\n            }\n            return col;\n        }\n        else if (abs(dw.x) < .006)\n        {\n            return vec3(0,.8,0); // Head\n        }\n    }\n    return col;\n}\n\n// returns Terrain view offset plus Screen offset in pixels\nfloat W2T(float T, float wx)\n{\n    return T*35.75 + (wx+.5)*iResolution.x;\n}\n\nvec2 PixelsToView(float T, float tx, float ty)\n{\n    return vec2((tx/35.75-T)-.5,.25);\n}\n\nbool Box(vec2 v, vec2 c, float w, float h)\n{\n    return abs(v.x-c.x) < w && abs(v.y-c.y) < h;\n}\n\n// T = terrain world position\nvec3 Humans(vec2 w, float T, vec3 col)\n{\n    float hy = -.25;\n    float dy = abs(w.y - hy);\n    if (dy < .0175)\n    {\n        for (int i=0; i<8; ++i)\n        {\n            // World position in pixels\n            float hx = 32.+float(i)*768.;\n            float hy = -0.235;\n            float p = W2T(T,w.x);\n\n            vec2 cam = vec2(T*.03575+.5,0);\n\n            vec2 wpos = vec2(hx*.001 -.5 - T*.03575, hy);\n            \n            if (Box(w,wpos,.01,1.))\n            {\n                col = Human(w,wpos,col);\n            }\n        }\n    }\n    return col;\n}\n\nvec3 Enemy(vec2 w, float T, vec3 col)\n{\n    if (Get(PARM_ET) < 0.) // IsDead?\n    {\n        return col;\n    }\n    vec3 GRN = vec3(0,1,.5);\n    float ex = Get(PARM_EX);\n    float ey = Get(PARM_EY);\n    vec2 v = vec2(ex,ey)-vec2(T*.03575,0)-w;\n    // Eyeball\n    //if (length(v+vec2(mod(iTime*.02,.025)-.01,0))<.006) return vec3(0);\n    for (int i=0; i<3; ++i)\n    {\n        float a = mod(iTime*3.+float(i)*1.047,3.141);\n        if (length(v+vec2(sin(a+1.57)*.02,0))<.005) return vec3(0);\n    }\n    // Body\n    if (length(vec2(v.x*1.,v.y*1.85)) < .024) return GRN*cos(v.y*96.);\n    // Legs\n    float r = .004, h = .01;\n    if (Box(v,vec2(.015,.012),r,h) || Box(v,vec2(-.015,.012),r,h) || Box(v,vec2(.0,.016),r,h)) return GRN;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 w = (fragCoord - .5*iResolution.xy) / iResolution.x;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col = col * pow(uv.y,4.);\n\n    if (fragCoord.x < 64. && fragCoord.y < 64.)\n    {\n        const int L = 1;\n        const int R = 2;\n        const int U = 4;\n        const int D = 8;\n        int btn = ReadButtons();\n        if ((btn&L)>0) col = Arrow(fragCoord, 0.00, vec2(11.,32.), col);\n        if ((btn&R)>0) col = Arrow(fragCoord, 3.14, vec2(53.,32.), col);\n        if ((btn&U)>0) col = Arrow(fragCoord,-1.57, vec2(32.,53.), col);\n        if ((btn&D)>0) col = Arrow(fragCoord, 1.57, vec2(32.,11.), col);\n    }\n\n    float T = Get(PARM_W);\n    col = Terrain(uv,T,col);\n    col = Stars(uv,col);\n    col = Humans(w,T,col);\n    col = Enemy(w,T,col);\n    col = Bullets(w,T,col);\n\n    float dir = Get(PARM_D); \n    float sx = Get(PARM_X);\n    float sy = Get(PARM_Y);\n    sx = max(sx,-.45);\n    sx = min(sx, .45);\n    col = Ship(w,vec2(sx,sy),dir,col);\n\n    // Tick mark for to world position\n    if (abs(fragCoord.x-mod(T,iResolution.x))<4. && fragCoord.y<8.) col = vec3(1,0,0);\n\n    //float ww = (768.+32.)/iResolution.x-.5;\n    //if (abs(ww-w.x) < 0.002) col = vec3(0,1,0);\n    //if (fragCoord.y < 100. && abs(fragCoord.x-768.-32.) <= 2.) col = vec3(1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_W     = 87;\nconst int KEY_SPACE = 32;\n\nconst float speed = .5;\nconst float accel = 4.;\nconst float decay = 8.;\n\n// Indent the player from the screen edge\nconst float Indent = .15;\nconst float Edge = .5-Indent;\n\n// How far ship nudges forward to show speed\nconst float Nudge = .02;\nconst float MaxVel = 3.;\n\nconst int PARM_X   = 0; // Player Screen X\nconst int PARM_Y   = 1; // Player Screen Y\nconst int PARM_B   = 2; // Buttons = 1+2+4+8;\nconst int PARM_DIR = 3;\nconst int PARM_VEL = 4;\nconst int PARM_W   = 5; // World position\n\nconst int PARM_OP  = 9; // Operation command\n\nconst int PARM_B1 = 10; // Bullet #1 Age,X,Y,Vel\nconst int PARM_B2 = 20; // Bullet #2 Age,X,Y,Vel\nconst int PARM_B3 = 30; // Bullet #3 Age,X,Y,Vel\nconst int PARM_B4 = 40; // Bullet #4 Age,X,Y,Vel\nconst int PARM_B5 = 50; // Bullet #5 Age,X,Y,Vel\nconst int PARM_BX = 60; // END\n\nconst int PARM_ET  = 70; // Time (-1 dead)\nconst int PARM_EX  = 71; // World position\nconst int PARM_EY  = 72; // World position\nconst int PARM_EV  = 73; // Velocity\nconst int PARM_ER  = 74; // Explosion Radius\n\nconst int PARM_MAX = 80;\n\nconst int BSTEP = 10;\nconst int BCOUNT = 5;\n\nconst float BulletLifetime = 2.0;\n\nfloat Key(int k)\n{\n    return texelFetch(iChannel1, ivec2(k, 0), 0).r;\n}\n\nfloat ReadKeys(int k1, int k2)\n{\n    return max(Key(k1),Key(k2));\n}\n\nfloat Get(int PARM)\n{\n    return texelFetch(iChannel0, ivec2(PARM, 0), 0).r;\n}\n\nvoid Push(int PARM)\n{\n    float A = Get(PARM+0);\n    float X = Get(PARM+1);\n    float Y = Get(PARM+2);\n    float V = Get(PARM+3);\n}\nvoid FireStack()\n{\n    if (Get(PARM_B1) > 0.)\n    {\n        Push(PARM_B2);\n    }\n}\n\nconst int OP_RESET = 0;\nconst int OP_FIRE = 100;\n\nconst float FireDelay = .2; // seconds\n\n// Return index of bullet slot (1..N) or BCOUNT+1\nint GetFireSlot()\n{\n    int Best = BCOUNT;\n    float Time = BulletLifetime;\n    for (int i=0; i<BCOUNT; ++i)\n    {\n        float age = Get(PARM_B1+i*BSTEP);\n        if (age > BulletLifetime-FireDelay)\n        {\n            return BCOUNT+1; // Cooldown = limit firing rate\n        }\n        if (age < Time)\n        {\n            Best = i;\n            Time = age;\n        }\n    }\n    return Best+1;\n}\n\nbool HitBullet(float tx, float ty)\n{\n    return false;//Get(PARM_B1+0) > 0.;\n    \n    for (int i=0; i<BCOUNT; ++i)\n    {\n        int B = PARM_B1+i*BSTEP;\n        float age = Get(B+0);\n        if (age > 0.)\n        {\n            float y = Get(B+2);\n            if (abs(y-ty) < 1.)\n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float outData = 0.0;\n    \n    int PARM = int(fragCoord.x);\n\n    if (PARM >= PARM_MAX)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    float X,Y,W,t,Left,Right,Up,Down;\n    float dx = iTimeDelta * speed;\n    float dy = dx/2.;\n    float Dir = Get(PARM_DIR) < 0. ? -1. : 1.;\n    float Vel = Get(PARM_VEL);\n    float Age = 0.;\n    \n    int Op = int(Get(PARM_OP));\n    \n    switch (PARM)\n    {\n        case PARM_OP:\n            if (Op <= 0 && Key(KEY_SPACE) > 0.)\n            {\n                Op = OP_FIRE + GetFireSlot(); // Begin firing\n            }\n            else\n            {\n                Op = OP_RESET; // cleanup\n            }\n            outData = float(Op);\n            break;\n    \n        case PARM_X:\n            Left = ReadKeys(KEY_A,KEY_LEFT);\n            Right = ReadKeys(KEY_D,KEY_RIGHT);\n            X = Get(PARM);\n            // Indent camera from screen edge\n            float tx = (Dir < 0.) ? Edge : -Edge;\n            X = mix(X,tx-Nudge*Vel,.025);\n            outData = clamp(X,-.5,.5);\n        \tbreak;\n        \n        case PARM_Y:\n            Up = ReadKeys(KEY_W,KEY_UP);\n            Down = ReadKeys(KEY_S,KEY_DOWN);\n        \tY = Get(PARM) + (Up - Down) * dy;\n            outData = clamp(Y,-.25,.25);\n        \tbreak;\n\n        case PARM_VEL:\n            Left = ReadKeys(KEY_A,KEY_LEFT);\n            Right = ReadKeys(KEY_D,KEY_RIGHT);\n            if (Left > Right) Vel += dx*accel;\n            else if (Right > Left) Vel -= dx*accel;\n            else Vel = mix(Vel,0.,iTimeDelta*decay);\n            outData = clamp(Vel,-MaxVel,MaxVel);\n            break;\n\n        case PARM_W:\n            W = Get(PARM) -10.*iTimeDelta*Vel;\n            outData = W;\n            break;\n\n        case PARM_DIR:\n            outData = Dir;\n            Left = ReadKeys(KEY_A,KEY_LEFT);\n            Right = ReadKeys(KEY_D,KEY_RIGHT);\n            if (Left > Right) outData = -1.;\n            if (Right> Left) outData = 1.;\n            break;\n            \n        case PARM_B:\n            outData = ReadKeys(KEY_A,KEY_LEFT )*1.\n                    + ReadKeys(KEY_D,KEY_RIGHT)*2.\n                    + ReadKeys(KEY_W,KEY_UP   )*4.\n                    + ReadKeys(KEY_S,KEY_DOWN )*8.;\n            break;\n            \n        case PARM_ET:\n            t = Get(PARM);\n            W = Get(PARM_ER);\n            if (W == 0.) // not exploding?\n            {\n                t += + iTimeDelta;\n            }\n            else if (W > 0.)\n            {\n                t = -1.;\n            }\n            else\n            {\n                t -= iTimeDelta;\n                if (t < -3.) // wait to respawn?\n                {\n                    t = 0.;\n                }\n            }\n            outData = t;\n            break;\n        case PARM_EX:\n            X = Get(PARM);\n            t = Get(PARM_ET);\n            if (t > 0.)\n            {\n                X = sin(t)*.1+.25;\n            }\n            outData = X;\n            break;\n        case PARM_EY:\n            outData = .1;\n            break;\n        case PARM_ER:\n            X = Get(PARM_EX);\n            Y = Get(PARM_EY);\n            W = Get(PARM);\n            if (W > 0.)\n            {\n                W += iTimeDelta;\n                if (W >= 2.)\n                {\n                    W = -1.;\n                }\n            }\n            else if (HitBullet(X,Y))\n            {\n                W = .01; // begin explosion\n            }\n            outData = W;\n            break;\n    }\n\n    // Process array of bullets\n    if (PARM >= PARM_B1 && PARM < PARM_BX)\n    {\n        // Bullet index (0..3)\n        int B = (PARM - PARM_B1) / BSTEP;\n        // Bullet Parameter Base\n        int PB = PARM_B1 + B*BSTEP;\n        // Property index\n        int P = (PARM - PB) % BSTEP;\n        \n        bool Fire = (Op == OP_FIRE+B+1);\n\n        switch (P)\n        {\n            case 0: // Age\n                Age = Get(PARM);\n                if (Fire)\n                {\n                    Age = BulletLifetime;\n                }\n                else if (Age > iTimeDelta)\n                {\n                    Age -= iTimeDelta;\n                }\n                else\n                {\n                    Age = 0.;\n                }\n                outData = Age;\n                break;\n            case 1: // X\n                if (Fire)\n                {\n                    X = Get(PARM_W) + Get(PARM_X);\n                }\n                else\n                {\n                    X = Get(PARM);\n                    Age = Get(PB+0);\n                    if (Age > 0.)\n                    {\n                        float BSCALE = 40.;\n                        float Speed = Get(PB+3)*BSCALE;\n                        X += iTimeDelta * Speed;\n                    }\n                }\n                outData = X;\n                break;                \n            case 2: // Y\n                outData = Fire ? Get(PARM_Y) : Get(PARM);\n                break;\n            case 3: // Vel\n                outData = Fire ? Get(PARM_DIR) : Get(PARM);\n                break;\n        }\n    }\n    \n    fragColor = vec4(outData, 0.0, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}