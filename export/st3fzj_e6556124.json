{"ver":"0.1","info":{"id":"st3fzj","date":"1663346263","viewed":53,"name":"Cubic Bezier Arclength","username":"Envy24","description":"Cubic Bezier Arclength Approximation with L1, L2, Linf-norms.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","cubic","arclength","l2"],"hasliked":0,"parentid":"ft3fRB","parentname":"Quadratic Bezier Arclength L2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  10.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float signed_dist = NDC.y - fx;\n    return SMAA(abs(signed_dist) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvec2 DFDT(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    vec2 C = -P0+3.*P1-3.*P2+P3,\n         D = 3.*(P0-2.*P1+P2),\n         E = 3.*(P1-P0);\n    return t*(3.*t*C + 2.*D) + E;\n}\n\nfloat cubicBezierApproxSDF_L2(vec2 NDC, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    int count = 5;\n    vec2 B = P0, E;\n    float dt_ = 1. / float(count), t_ = 0., min_dist = 99.;\n    \n    for (int i = 0; i < count; ++i)\n    {\n        t_ = float(i+1) * dt_;\n        \n        E = cubicBezier(t_, P0, P1, P2, P3);\n        min_dist = min(min_dist, segmentSDF_L2(NDC, B, E));\n        \n        B = E;\n    }\n    \n    return min_dist;\n}\n\n/* Simple approxiamtion by rectangles rule (worst result) */\nfloat arclength0(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    int count = 32;\n    float dx = t / float(count), sum = 0., x = 0.;\n      \n    for (int i = 0; i < count; ++i)\n    {\n        x = float(i) * dx;\n        sum += length(DFDT(x, P0, P1, P2, P3));      \n    }\n    \n    return sum*dx;\n}\n/* Another simple appriximation by line segments. *\nfloat arclength1(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    int count = 30;\n    vec2 B = P0, E;\n    float dt_ = t / float(count), t_ = 0., sum = 0.;\n    \n    for (int i = 0; i < count; ++i)\n    {\n        t_ = float(i+1) * dt_;\n        \n        E = cubicBezier(t_, P0, P1, P2, P3);\n        sum += length(E - B);                     // L2-norm      \n        //vec2 D = E-B; sum += abs(D.x) + abs(D.y);   // L1-norm\n        //vec2 D = E-B; sum += max(D.x, D.y);         // Linf-norm\n        \n        B = E;\n    }\n    \n    return sum;\n}\n/* Approximation by Gauss-Legendre quadrature (best result).\n   https://www.shadertoy.com/view/st3yzs */\nfloat arclength1(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    const float xs[5] = float[5](\n        -0.9061798459386639927976,\n        -0.5384693101056830910363,\n        0.,\n        0.5384693101056830910363,\n        0.9061798459386639927976  );\n    const float ws[5] = float[5](\n        0.2369268850561890875143,\n        0.4786286704993664680413,\n        0.5688888888888888888889,\n        0.4786286704993664680413,\n        0.2369268850561890875143 );\n    \n    float a = 0., b = 1.;\n    float hwidth = t*(b-a)*0.5,\n          mean = t*(b+a)*0.5;\n\n    float I = 0.;\n    for (int i = 0; i < 5; ++i)\n    {\n        float x = mean + hwidth * xs[i];\n              I += length(DFDT(x, P0, P1, P2, P3)*ws[i]);                    // L2-norm\n              //vec2 P = DFDT(x, P0, P1, P2, P3)*ws[i]; I += abs(P.x)+abs(P.y);// L1-norm\n              //vec2 P = DFDT(x, P0, P1, P2, P3)*ws[i]; I += max(P.x, P.y);    // Linf-norm\n    }\n\n    return I * mean;\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * 2.5;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    vec2 P0 = vec2(-2., -1.), P1 = vec2(-2.0, 1.0), P2 = vec2(2., 1.), P3 = vec2(2., -1.);\n    float offs = sinOSC(-0.5, 0.5, iTime * 0.5);\n    \n    P0 = rotateAroundZ(P0, iTime * 0.1) + vec2(2.*offs, -offs);\n    P1 = rotateAroundZ(P1, iTime * 0.9) + vec2(-12.*offs, 0.0);\n    P2 = rotateAroundZ(P2, iTime * 0.9) + vec2(-8.*offs, 3.*offs);\n    P3 = rotateAroundZ(P3, iTime * 0.1) + vec2(-offs*offs, offs);\n                  \n         color = mix(color, vec3(0, 1, 0), SMAA( cubicBezierSegmentSDF_L2(NDC, P0, P1, P2, P3) ));\n         color = mix(color, vec3(.4, .4, .4), SMAA( cubicBezierApproxSDF_L2(NDC, P0, P1, P2, P3) ));\n         color = mix(color, vec3(0, 0, 1), SMAA( segmentSDF_L2(NDC, P0, P1) ));\n         color = mix(color, vec3(0, 0, 1), SMAA( segmentSDF_L2(NDC, P1, P2) ));\n         color = mix(color, vec3(0, 0, 1), SMAA( segmentSDF_L2(NDC, P2, P3) ));\n         color = mix(color, vec3(1, 0, 1), SMAA( diskSDF_L2(NDC, P0, UNIT) ));\n         color = mix(color, vec3(1, 0, 1), SMAA( diskSDF_L2(NDC, P1, UNIT) ));\n         color = mix(color, vec3(1, 0, 1), SMAA( diskSDF_L2(NDC, P2, UNIT) ));\n         color = mix(color, vec3(1, 0, 1), SMAA( diskSDF_L2(NDC, P3, UNIT) ));\n\n/**/\n#define SCALE 0.125\n         float t = fract(iTime * 0.25);\n         vec2 P = cubicBezier(t, P0, P1, P2, P3);\n         color = mix(color, vec3(1, 0, 0), SMAA( diskSDF_L2(NDC, P, UNIT) ));\n              P = vec2(t, SCALE*arclength0(t, P0, P1, P2, P3));\n         color = mix(color, vec3(1, 0, 0), SMAA( diskSDF_L2(NDC, P, UNIT) ));\n\n         t = clamp(NDC.x, 0., 1.);\n#define func(x) ( arclength0(x, P0, P1, P2, P3) )\n#define dfdx(x, dx) ( ( func((x)+(dx)) - func(x) ) / (dx) )\n         color.rb -= \n             draw_explicit_func(\n                 NDC, \n                 SCALE * func(t),\n                 NDC.x < 0. || NDC.x > 1. ? 0. : SCALE * dfdx(t, 0.01));\n#define func2(x) ( arclength1(x, P0, P1, P2, P3) )\n#define dfdx2(x, dx) ( ( func2((x)+(dx)) - func2(x) ) / (dx) )\n         color.gb -= \n             draw_explicit_func(\n                 NDC, \n                 SCALE * func2(t),\n                 NDC.x < 0. || NDC.x > 1. ? 0. : SCALE * dfdx2(t, 0.01));\n                 /**/\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nvec2 cubicBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float f = 1.- t, tt = t*t, ff = f*f;\n    return (P0*f*ff+3.*P1*t*ff+3.*P2*tt*f+P3*tt*t);\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat findQuinticRootNewtonRaphson(\n    float x, float a, float b, float c, float d, float e, float f)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = (((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e;\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 12) && (quit == false); ++i)\n    {\n        float y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n        x -= y / dfdx;          \n        dfdx = (((5. * a * x + 4. * b) * x + 3. * c) * x + 2. * d) * x + e;\n        quit = (abs(y) <= tolerance) || (abs(dfdx) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findQuinticRootBisection(\n    float xl, float xr, float a, float b, float c, float d, float e, float f)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        ((((a * xl + b) * xl + c) * xl + d) * xl + e) * xl + f,  // f(xl)\n        ((((a * xr + b) * xr + c) * xr + d) * xr + e) * xr + f); // f(xr)\n        \n    float y = 0.5;\n        \n    for (int i = 0; (i < 8) && (abs(y) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = (X[0] + X[1]) * 0.5;\n              y = ((((a * x + b) * x + c) * x + d) * x + e) * x + f;\n\n        int w_idx = int(sign(F[0]) != sign(y));\n        \n        F[w_idx] = y; X[w_idx] = x;\n    }\n\n    return (X[0] + X[1]) * 0.5;\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n/*\n    Return value:\n        0 - no roots when A==0, B==0, C==0;\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicForReal(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / coef[0];\n    float a = coef[1] * inv;\n    float b = coef[2] * inv;\n    float c = coef[3] * inv;\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n\n        roots[0].x = -2.0 * sign(R) * sqrt(Q) * cosh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n\n        roots[0].x = -2.0 * sign(R) * sqrt(abs(Q)) * sinh(phi) - a * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        roots[0].x = -pow(c - a * a * a / 27.0, oneThird) - a * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    float Re = sign(R) * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\n/*\n     Returns number of real roots.       \n*/\nint solveQuartic(\n    inout vec2 roots[4],\n    in float coef[5])\n{\n    float invA = 1.0 / coef[0];\n    float B = coef[1] * invA;\n    float C = coef[2] * invA;\n    float D = coef[3] * invA;\n    float E = coef[4] * invA;\n\n    float coef_[4] = float[4](\n        1.,\n        -C,\n        D * B - 4. * E,\n        -(D * D + E * B * B - 4. * E * C)\n    );\n    vec2 roots_[3];\n\n    int num = solveCubicForReal(roots_, coef_);\n\n    float u = 0.0;\n    float D0 = -1.0;\n    float D1 = -1.0;\n\n    if (num == 3)\n    {\n        u = roots_[1].x;\n\n        D0 = B * B * 0.25 + u - C;\n        D1 = u * u * 0.25 - E;\n    }\n    else\n    {\n        u = roots_[0].x;\n        D0 = B * B * 0.25 + u - C;\n        D1 = u * u * 0.25 - E;\n    }\n\n    D0 = sqrt(D0); D1 = sqrt(D1);\n\n    float p0 = B * 0.5 + D0, p1 = B * 0.5 - D0,\n          q0 = u * 0.5 + D1, q1 = u * 0.5 - D1;\n    \n    // This line may cause problems (try other tresholds).\n    if (abs(p0 * q1 + p1 * q0 - D) > 1e-14)\n    {\n        float t = q0; q0 = q1; q1 = t;\n    } \n\n    vec2 r_[2];\n    float c_[3] = float[3]( 1.0, p0, q0 );\n\n    num = solveQuadraticForReal(r_, c_);\n\n    int wIdx = \n        num == 0 ? \n            2 : 0;\n\n    roots[wIdx] = r_[0]; roots[wIdx + 1] = r_[1];\n\n    wIdx = \n        num == 0 ? \n        0 : 2;\n\n    c_[1] = p1; c_[2] = q1;\n\n    int n = solveQuadraticForReal(r_, c_);\n\n    roots[wIdx] = r_[0]; roots[wIdx + 1] = r_[1];\n\n    num = num == 1 ? 2 : num;\n\n    return\n        n == 1 ? \n            num + 2 :\n            num + n;\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve5(\n    inout vec2[5] roots,\n    in float[6] coef)\n{\n    // Quintic equation?\n    if (coef[0] != 0.0)\n    {\n\n        float x = findQuinticRootBisection(-1.01, 2.1, coef[0], coef[1], coef[2], coef[3], coef[4], coef[5]);\n              x = findQuinticRootNewtonRaphson(x, coef[0], coef[1], coef[2], coef[3], coef[4], coef[5]);\n    \n        roots[0].x = x;\n\n        // Convert equation to form: (x-r0)(axxxx+bxxx+cxx+dx+e)=0\n        vec2 roots_[4];\n        float coef_[5] = float[5](\n            coef[0],\n            coef[1] + x * coef[0],\n            coef[2] + x * (coef[1] + x * coef[0]),\n            coef[3] + x * (coef[2] + x * (coef[1] + x * coef[0])),\n            coef[4] + x * (coef[3] + x * (coef[2] + x * (coef[1] + x * coef[0])))\n        );\n\n        int num = solveQuartic(roots_, coef_);\n\n        roots[1] = roots_[0]; roots[2] = roots_[1]; roots[3] = roots_[2]; roots[4] = roots_[3];\n\n        return num + 1;\n    }\n\n    // Quartic equation?\n    if (coef[1] != 0.0)\n    {\n        vec2 roots_[4];\n        float coef_[5] = float[5](\n            coef[1], coef[2], coef[3], coef[4], coef[5]\n        );\n\n        int num = solveQuartic(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2]; roots[3] = roots_[3];\n        \n        return num;\n    }\n\n    // Cubic equation?\n    if (coef[2] != 0.0)\n    {\n        vec2 roots_[3];\n        float coef_[4] = float[4](\n            coef[2], coef[3], coef[4], coef[5]\n        );\n\n        int num = solveCubicForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1]; roots[2] = roots_[2];\n        \n        return num;\n    }\n    \n    // Quadratic equation?\n    if (coef[3] != 0.0)\n    {\n        vec2 roots_[2];\n        float coef_[3] = float[3](\n            coef[3], coef[4], coef[5]\n        );\n\n        int num = solveQuadraticForReal(roots_, coef_);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (coef[4] != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -coef[5]/coef[4]; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (coef[5] == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    /**/\n    \n    return 0;\n}\n\n/*\n    First root will be find numerically, other four analytically.\n*/\nfloat cubicBezierSegmentSDF_L2(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2,\n    vec2 P3)\n{\n    vec2 A =   -P0+3.*P1-3.*P2+P3,\n         B = 3.*P0-6.*P1+3.*P2,\n         C =      -3.*P0+3.*P1,\n         D =          P0-NDC;\n    \n    float coef[6] = float[6](\n          3. * dot(A, A),\n          5. * dot(A, B),\n          2. * (2.*dot(A,C) + dot(B,B)),\n          3. * (dot(A,D)    + dot(B,C)),\n               (2.*dot(B,D) + dot(C,C)),\n               dot(C,D)\n    );\n      \n    float minSqDist = 99.;\n      \n    /* This divisions lets rewrite \n        ax^5+bx^4+cx^3+dx^2+ex+f = f+x(e+x(d+x(c+x(b+x*a))))\n    as   x^5+Ax^4+Bx^3+Cx^2+Dx+E = E+x(D+x(C+x(B+x(A+x))))      -1 mult op */\n    float invA = 1.0 / coef[0];\n    coef[0] = 1.0;   coef[1] *= invA; coef[2] *= invA;\n    coef[3] *= invA; coef[4] *= invA; coef[5] *= invA;\n\n    vec2 roots[5];\n\n    // Find other four roots (one numerically).\n    int num = solve5(roots, coef);\n\n    for (int r = 0; r < num; ++r)\n    {\n        vec2 diff = vec2(cubicBezier(clamp(roots[r].x, 0., 1.), P0, P1, P2, P3)) - NDC;\n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n\n    return sqrt(minSqDist);\n}","name":"Common","description":"","type":"common"}]}