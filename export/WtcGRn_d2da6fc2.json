{"ver":"0.1","info":{"id":"WtcGRn","date":"1575384869","viewed":226,"name":"Web distortion","username":"Fogrex","description":"distorted","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float r = 0.07;\nconst float wr = 0.5;\n\n#define saturate(a) clamp(a,0.0,1.0)\n#define smooth(a) (1.0-saturate(smoothstep(0.0,r,length(a))/r))\n#define smoothWidth(a) (1.0-saturate(smoothstep(0.0,wr,length(a))/wr))\n\nconst float GRID = 5.0;\n\n\nfloat rand(in vec2 p)\n{\n    return fract(sin(dot(p.xy,\n                         vec2(12.9898,78.233)))*\n        758.5453123);\n}\n\nfloat drawLine (in vec2 uv, in vec2 p1, in vec2 p2, in float a)\n{\n    float r = 0.0;\n    float one_px = 1.0 / iResolution.x;\n    \n    float d = distance(p1, p2);\n    \n\n    float duv = distance(p1, uv);\n\n    r = 1.0-floor(1.0-(a*one_px)+distance (mix(p1, p2, clamp(duv/d, 0.0, 1.0)),  uv));\n        \n    return r;\n}\n\n\nvec4 map(in vec2 pos)\n{\n    float t = iTime;\n    \n    vec2 grid = floor(pos * GRID);\n    \n    vec2 np = (grid + vec2(0.0,1.0));\n    vec2 ep = (grid + vec2(1.0,0.0));\n    vec2 wp = (grid + vec2(-1.0,0.0));\n    vec2 sp = (grid + vec2(0.0,-1.0));\n    vec2 nep = (grid + vec2(1.0,1.0));\n    vec2 sep = (grid + vec2(1.0,-1.0));\n    vec2 nwp = (grid + vec2(-1.0,1.0));\n    vec2 swp = (grid + vec2(-1.0,-1.0));\n    vec2 cp = (grid + vec2(0.0,0.0));\n    \n    vec2 nc = (vec2(sin(t * rand(np))*0.5+0.5, cos(t * rand(np+1.0))*0.5+0.5)*0.9+0.05) / GRID + np/GRID;\n    vec2 ec = (vec2(sin(t * rand(ep))*0.5+0.5, cos(t * rand(ep+1.0))*0.5+0.5)*0.9+0.05) / GRID + ep/GRID;\n    vec2 wc = (vec2(sin(t * rand(wp))*0.5+0.5, cos(t * rand(wp+1.0))*0.5+0.5)*0.9+0.05) / GRID + wp/GRID;\n    vec2 sc = (vec2(sin(t * rand(sp))*0.5+0.5, cos(t * rand(sp+1.0))*0.5+0.5)*0.9+0.05) / GRID + sp/GRID;\n    vec2 nec = (vec2(sin(t * rand(nep))*0.5+0.5, cos(t * rand(nep+1.0))*0.5+0.5)*0.9+0.05) / GRID + nep/GRID;\n    vec2 sec = (vec2(sin(t * rand(sep))*0.5+0.5, cos(t * rand(sep+1.0))*0.5+0.5)*0.9+0.05) / GRID + sep/GRID;\n    vec2 nwc = (vec2(sin(t * rand(nwp))*0.5+0.5, cos(t * rand(nwp+1.0))*0.5+0.5)*0.9+0.05) / GRID + nwp/GRID;\n    vec2 swc = (vec2(sin(t * rand(swp))*0.5+0.5, cos(t * rand(swp+1.0))*0.5+0.5)*0.9+0.05) / GRID + swp/GRID;\n    vec2 cc = (vec2(sin(t * rand(cp))*0.5+0.5, cos(t * rand(cp+1.0))*0.5+0.5)*0.9+0.05) / GRID + cp/GRID;\n    \n    float w = 3.0;\n    float ncl = drawLine(pos, nc, cc, w*smoothWidth(nc - cc));\n    float ecl = drawLine(pos, ec, cc, w*smoothWidth(ec - cc));\n    float wcl = drawLine(pos, wc, cc, w*smoothWidth(wc - cc));\n    float scl = drawLine(pos, sc, cc, w*smoothWidth(sc - cc));\n    float secl = drawLine(pos, sec, cc, w*smoothWidth(sec - cc));\n    float nel = drawLine(pos, nc, ec, w*smoothWidth(nc - ec));\n    float nwcl = drawLine(pos, nwc, cc, w*smoothWidth(nwc - cc));\n    float swl = drawLine(pos, sc, wc, w*smoothWidth(sc - wc));\n    \n    \n    float res = 0.0;\n    res += (smooth(nc - pos)+smooth(ec - pos)+smooth(wc - pos)+smooth(sc - pos)+smooth(cc - pos));\n    res += (smooth(nec - pos)+smooth(sec - pos)+smooth(nwc - pos)+smooth(swc - pos));\n    res += ncl + ecl + wcl + scl + secl + nel + nwcl + swl;\n\n    return vec4(res);\n}\n\nfloat noise (in vec2 st) {\n    st *= 6.0;\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 e = vec2(0.0,0.001);\n    uv += vec2(noise(uv+e.yx)-noise(uv-e.yx),noise(uv+e.xy)-noise(uv-e.xy))*5.0;\n    \n\n    // Output to screen\n    fragColor = map(uv);\n}","name":"Image","description":"","type":"image"}]}