{"ver":"0.1","info":{"id":"MsdXW7","date":"1459819698","viewed":459,"name":"Voxel Life","username":"akohdr","description":"Multi-slide Conway life to see what it could look like.\nLooking through dense voxel space increases frame rate due to increased early hit on ray cast.\n(NOT cycle accurate or 3D CA simply tiles of 2D automata from BufA)\n(R - Resets,  use mouse to draw)","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["voxel","automata","life","cellular","automaton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define SPD_R sin(.2*iTime)\n#define SPD_R .8*sin(cos(2.*iTime))\n//#define SPD_R iTime/2.\n\n// Cut/Paste begin ------------------------------------------------------------\n#define BOB_H 40.*SPD_R\n#define EYE_D 20.\n#define WORLD_OFFSET vec3(iResolution.x/2., iResolution.y/2., -20)\n#define B0 vec4(.0,.0,.0,1.)\n#define B1 vec4(.6,.6,.6,1.)\n#define B2 vec4(.3,.3,.3,1.)\n\n// goal is fast voxel based abstraction returning existence and colour(c) in spacetime(P)\nbool cVoxel(out vec4 c, in vec4 P );\n\nbool VxViewer(out vec4 fc,             // fragColor\n         const in vec2 P,              // fragCoord\n         const in vec3 R,              // iResolution\n        const in float T ) {           // timebase\n    \n    vec2 t = vec2(sin(T), cos(T)),\n         l = P.xx / R.xx - .5;         // vec ops faster than single scalar\n    vec3 r = vec3(l.y*t.y - .8*t.x, \n                  (P.y/R.y - .5)*R.y/R.x, \n                  .8*t.y + l.x*t.x),\n         o = t.xxy * vec3(EYE_D, BOB_H, -EYE_D),\n         h = length(r)/r,\n         q = sign(r),\n         f = floor(o),\n         d = abs(h),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n    \n    for(int i=0;i<200;i++) {\n\n        if(cVoxel(fc,vec4(f + WORLD_OFFSET, T))){\n            fc += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n            return true; // early exit\n        }\n        \n        bvec3 a = lessThan(s,s.yzx),\n              b = lessThanEqual(s,s.zxy);\n              m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n                \n        f += m*q;\n        s += m*d;\n    }\n    return false;\n}\n// Cut/Paste end ------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if(iMouse.z>0.)\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n    else        \n    if(!VxViewer(fragColor, \n                 fragCoord,\n                 iResolution,\n                 SPD_R))          // timebase\n    // we didn't hit voxel\n    fragColor = texture(iChannel1,fragCoord/iResolution.xy);\n}\n\nvec2 prj3Dto2D(const in vec4 p) {    \n    vec2 ar = vec2(6.,4.),\n         ir2 = iResolution.xy/ar;\n    \n    float fpl = ar.x;\n    vec2 fOrigin;\n         fOrigin.x = mod(p.z, fpl);\n         fOrigin.y = ((p.z)/3.) - ((fOrigin.x)*(fpl));\n    \n    return p.xy + floor(fOrigin) * iResolution.x/5.;\n}\n\nbool cVoxel(out vec4 c,\n             in vec4 P ) {\n    // pull voxel state from 2D map of world slices generated in BufA\n    c = texture(iChannel0, prj3Dto2D(P)/iResolution.xy);\n \treturn c.x>.0;\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// from https://www.shadertoy.com/view/ld3Sz7  (with few tweaks)\n\n#define pixel (1.0 / iResolution.xy)\n#define brushSize 20.0\n\nconst vec3 v3_0 = vec3(0),\n           v3_2 = vec3(2),\n           v3_3 = vec3(3);\nconst vec4 NULL = vec4(-1);\n\n\n//noise see https://www.shadertoy.com/view/ltB3zD\nfloat snoise(in vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// set value for r key to reset with\nconst int Key_R = 82;\n\n// process keyboard input\nbool ReadKey( int key ) {\n\tbool toggle = false;\n\tfloat keyVal = texture( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn keyVal>.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // <FIX>: black stripe boundary on map to prevent 'beam forming'\n    //      There is a sampler setting I think that could help here.\n    if(fragCoord.x<1.||fragCoord.y<1.) {fragColor = NULL; return;}\n\tvec3 rl = iResolution-1.;\n    if(fragCoord.x>rl.x||fragCoord.y>rl.y)  {fragColor = NULL; return;}\n    // </FIX>\n\n    // retrieve the texture coordinate\n    vec2 c = fragCoord.xy / iResolution.xy;\n    // and the current pixel\n    vec3 current = texture(iChannel0, c).rgb;\n    // set the neighbours value to 0\n    vec3 neighbours = v3_0;\n    \n    // check to seee if we are at the start of the timeline or if the R key is pressed.\n    if(iTime > 0.1 && !ReadKey(Key_R)) {\n        // draw a circle if the mouse is clicked\n        if(distance(iMouse.xy, fragCoord) < brushSize && iMouse.z > .0) {\n        \tfragColor = vec4(1.);\n        }\n        else {\n            // count the neightbouring pixels with a value greater than zero\n            neighbours += vec3(greaterThan(texture(iChannel0, c + pixel*vec2(-1,-1)).rgb, v3_0));\n            neighbours += vec3(greaterThan(texture(iChannel0, c + pixel*vec2(-1, 0)).rgb, v3_0));\n            neighbours += vec3(greaterThan(texture(iChannel0, c + pixel*vec2(-1, 1)).rgb, v3_0));\n            neighbours += vec3(greaterThan(texture(iChannel0, c + pixel*vec2( 0,-1)).rgb, v3_0));\n            neighbours += vec3(greaterThan(texture(iChannel0, c + pixel*vec2( 0, 1)).rgb, v3_0));\n            neighbours += vec3(greaterThan(texture(iChannel0, c + pixel*vec2( 1,-1)).rgb, v3_0));\n            neighbours += vec3(greaterThan(texture(iChannel0, c + pixel*vec2( 1, 0)).rgb, v3_0));\n            neighbours += vec3(greaterThan(texture(iChannel0, c + pixel*vec2( 1, 1)).rgb, v3_0));\n\n            // check if the current pixel is alive\n            vec3 live = vec3(greaterThan(current, v3_0));\n\n            // resurect if we are not live, and have 3 live neighrbours\n            current += (1.0-live) * vec3(equal(neighbours, v3_3));\n\n            // kill if we do not have either 3 or 2 neighbours\n            current *= vec3(equal(neighbours, v3_2)) + vec3(equal(neighbours, v3_3));\n\n            // fade the current pixel as it ages\n            current -= vec3(greaterThan(current, vec3(0.4)))*0.05;\n\n            // write out the pixel\n            fragColor = vec4(current, 1.0);\n        }\n    }\n    //Generate some noise to get things going\n    else {\n        fragColor = vec4(snoise(fragCoord) > 0.8 ? 1.0 : 0.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}