{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define THRESHOLD 0.01\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 120\n#define MAX_SAMPLES 4.0\n\nfloat aa_size = 2.0;\n\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// iq's LUT-based 3D noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// cloud fBm with three noise samples, flow direction & exponential y-scale\nfloat map( in vec3 p )\n{\n\tp.y = pow(abs(p.y), 1.3);\n\t\n\tfloat time = iTime * 0.3;\n\tfloat d = -0.1 - p.y;\n\n\tvec3 dir = 8.0*normalize(p);\n\tdir.y = 0.0;\n\tvec3 q = p - dir+vec3(-0.0,3.0,-0.0)*(0.2*time);\n\tfloat f;\n    f  = 0.6*noise( q ); q = q*3.01;\n    f += 0.3*noise( q ); q = q*3.02;\n    f += 0.1*noise( q );\n\n\td += 3.5 * f;\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\treturn d;\n}\n\n\nfloat scene(vec3 p)\n{\nmat3 mp = rotationXY(vec2(0.0, 0.25*3.14159)) * rotationXY(vec2(3.14159*0.25, 0.0));\n\tfloat cube = length(max(abs(mp*p - vec3(0.0, 0.0, 0.0)) - vec3(1.95), 0.0)) - 0.05;\n\treturn cube;\n}\n\nmat material(vec3 p)\n{\n\tfloat cube = length(max(abs(p - vec3(0.0, 2.0, 0.0)) - vec3(1.95), 0.0)) - 0.05;\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\nfloat time = iTime * 0.3;\n    float n = map(p.yzz*1.5*cos(0.5*3.14159*time)-cos(p.z+0.5*3.14159*time));\n\tm.transmit = vec3(1.1)*n; // 0.95, 0.7, 0.5);\n\tm.diffuse = 0.1+(1.0-sqrt(abs(n)));\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\n\nvec3 shadeBg(vec3 nml, vec2 uv)\n{\n\tvec3 lightPos_ = vec3(0.5, -1.5, 8.0);\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(2.0)*4.0; //, 3.5, 2.0)*4.0;\n\n    vec3 bgColz = vec3(0.9);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = vec3(0.0);\n\tbgCol += max(0.0, bgDiff)*vec3(0.8);\n\tbgCol += max(0.0, -bgDiff)*vec3(1.25);\n\tbgCol += vec3(0.15)*( pow(1.0-abs(bgDiff), 6.0) );\n\tbgCol += sun*(0.02*pow( sp, 3.0) + pow( sp, 256.0));\n\tbgCol += bgColz*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\nfloat time = iTime * 0.3;\n    float t = mod(time*1.5, 3.0)-1.5;\n\treturn (bgCol + 0.25) * map(nml.yyz+2.5*t) + 0.1*hash((time)+nml.x*1211.201+nml.z*2531.029+nml.y*2443.029+3289.02);\n}\n\nfloat shade(inout ray r, vec3 nml, float d)\n{\n\tmat m = material(r.p);\n\tr.light += m.emit * r.transmit;\n\tr.transmit *= m.transmit;\n\treturn m.diffuse;\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n\nray setupRay(vec2 uv, float k) {\n\tmat3 rot = rotationXY( vec2( -0.11, 0.0 )); //iTime*0.0602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(0.0, 0.0, -9.5) + vec3(0.0, 0.0, 0.0);\n\tr.d = rot * normalize(vec3(uv, 1.5));\n\n\treturn r;\n}\n\nvec3 trace(vec2 uv, vec2 uvD, inout float sceneDist)\n{\t\n\tfloat minDist = 9999999.0;\n\tfloat count = 0.0;\n\tfloat diffuseSum = 0.0, maxDiffuseSum = 0.0;\n\t\n\tvec3 accum = vec3(0.0);\n\tsceneDist = 9999999.0;\n\n\tray r = setupRay(uv, 1.0);\n\tvec3 op = r.p + 1.0*r.d;\n\tr.p = op;\n\tfloat k = 1.0;\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (k > MAX_SAMPLES) break;\n\t\tfloat dist = scene(r.p);\n\t\tminDist = min(minDist, dist);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tif (sceneDist == 9999999.0) {\n\t\t\t\tsceneDist = length(r.p - op);\n\t\t\t}\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n\t\t\tfloat diffuse = shade(r, nml, dist);\n\t\t\tdiffuseSum += diffuse;\n\t\t\toffset(r.d, k, k+10.0*dot(nml, r.d), diffuse*0.5);\n\t\t\tr.d = reflect(r.d, nml);\n\t\t\tr.p += 4.0*THRESHOLD * r.d;\n\t\t\tcount++;\n\t\t\t\n\t\t\tif (dot(r.transmit, vec3(2.0)) < 0.2) {\n\t\t\t\t// if even the brightest light in the scene can't\n\t\t\t\t// make the ray brighter, let's bail.\n\t\t\t\taccum += r.light;\n\t\t\t\tk++;\n\t\t\t\tr = setupRay(uv+(uvD*mod(xy(k, aa_size), aa_size)/aa_size), k);\n\t\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\t\tdiffuseSum = 0.0;\n\t\t\t}\n\t\t} else if (dist > MAX_DISTANCE) {\n\t\t\tvec3 bg = shadeBg(-r.d, uv);\n\t\t\tif (minDist > THRESHOLD*10.5) {\n\t\t\t\taccum = bg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taccum += r.light + r.transmit * bg;\n\t\t\tk++;\n\t\t\tr = setupRay(uv+(uvD*mod(xy(k, aa_size), aa_size)/aa_size), k);\n\t\t\tif (sceneDist < 9999999.0) {\n\t\t\t\tr.p += sceneDist*0.95*r.d;\n\t\t\t}\n\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\tdiffuseSum = 0.0;\n\t\t}\n\t}\n\tfloat glow = 0.0;\n    if (minDist > THRESHOLD) {\n        minDist += -4.0*pow(abs(r.d.y), 2.8);\n\t\tglow = 0.04*pow(pow(max(0.0, (1.0-minDist)), 2.0), 5.0);\n    }\n\treturn accum / max(1.0, k-1.0) + glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (2.0 * uv - 1.0) * aspect;\n\n\tvec2 uvD = 2.0*aspect / iResolution.xy;\n\t\n\tray r;\n\tr = setupRay(uv, 0.0);\n\t\n\tfloat dist = 999999.0;\n\tvec3 light = trace(uv, uvD, dist);\n/*\n\tif (dist > 10000.0) {\n\t\tr.p += 5.0*r.d;\n\t\tfor (int i=0; i<5; i++) {\n\t\t\tfloat c = map( r.p );\n\t\t\tr.p += 1.8*r.d;\n\t\t\tr.transmit *= 1.0+c*0.15;\n\t\t}\n\t}\n*/\n\tr.light = r.transmit * light;\n\t\n\tfragColor = mix( vec4(0.0), vec4( 1.0 - exp(-1.5 * r.light), 1.0 ), 0.5-0.5*cos(3.14159*min(1.0, iTime/1.0)) );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltX3W2","date":"1425157014","viewed":254,"name":"corrupting cube","username":"kig","description":"Playing with a corrupting cube concept, #shadeADay for 2015-02-28","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","glow","shadeaday"],"hasliked":0,"parentid":"","parentname":""}}