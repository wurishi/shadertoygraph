{"ver":"0.1","info":{"id":"Xff3RS","date":"1703168597","viewed":29,"name":" Kaleidoscope Triangles","username":"brunorealities","description":"This shader is part of my experiments with shapes and patterns. intricately weaves vibrant neon hues into symmetrical patterns, dynamically evolving with time's passage. Using shapes functions to change into different geometric patterns.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["patterns","kaleidoscope","geometry","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n//Palette\n\nvec3 pal(in float t) {\n    vec3 a =  vec3(0.329,0.310,0.271);// Updated color 1\n    vec3 b = vec3(0.239,0.255,0.263); // Updated color 2\n    vec3 c = vec3(0.910,0.549,0.188); // Updated color 3\n    vec3 d = vec3(0.098,0.102,0.102);  // Updated color 4\n  \n \n    // Return the color by applying a cosine function to create smooth transitions between colors\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n\nfloat shapes(vec2 uv ,int N)\n{\n   float a = atan(uv.y, uv.x);\n   float r = TWO_PI/float(N);\n   float d = 0.0;\n\n   return d = cos(floor(.556 + a/r) * r-a)*length(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2. - iResolution.xy)/ iResolution.y;\n    \n    float t = iTime;\n    \n    vec3 finalCol = vec3(0.);\n    \n    for(float i = 0.; i < 3.; i++)\n    {\n    \n    vec2 uv0 = uv;\n    \n    // Transforma as coordenadas UV para criar efeitos de repetição\n\n     uv = fract(uv * 1.5) - .5;\n    \n    float d = length(uv);\n    \n    // Evita divisão por zero, ajustando o valor mínimo de 'd'\n     d = max(abs(d),0.01);\n    \n    // Calcula um valor baseado na forma geométrica usando a função 'shapes'\n    float s = shapes(uv * length(uv0) ,6);\n   \n    // Calcula a intensidade baseada em funções trigonométricas e na forma\n    float it = pow(sin(1. * step(.5,d)) +  cos(2. * s),4.);\n    s = fract(abs(sin(s * .2 + t * 0.01)*it));\n    \n    s = step(0.2,s);\n    \n   \n   // Calcula a cor com base no tempo e na intensidade, usando a função 'pal'\n    vec3 col = pal(sin(s * it + t*.15));\n   \n   \n    finalCol += col * smoothstep(0.4,.45,s);\n   \n   \n    }\n\n \n\n    // Output to screen\n    fragColor = vec4(finalCol,1.0);\n}","name":"Image","description":"","type":"image"}]}