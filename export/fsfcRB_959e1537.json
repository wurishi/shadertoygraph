{"ver":"0.1","info":{"id":"fsfcRB","date":"1642246502","viewed":180,"name":"8-Colour Dither","username":"Janowicz","description":"Recently inspired by a one lone coder video, I decided to go back to an old shader I made and put it on shader toy. Floyd-Steinberg can't be parallelised, but this 8-colour method can be. Useful if you want to create a retro-look.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["dither","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    This shader works by making 5 patterns,\n    one completely black,\n    a 2x2 where one square is white (like a waffle),\n    a checkerboard,\n    a 2x2 where one square is black,\n    and one that is fully white.\n    \n    The middle three patterns are generated based on\n    the oddness of the x and y co-ordinates.\n    \n    Which pattern to use is chosen by the brightness\n    of the channel of each pixel.\n    \n    Unfortunately, with how the patterns overlap, some\n    pixels will always be black (unless they get placed\n    in the last pattern bucket). If you prefer a lighter\n    image, you can invert the checkered pattern (1-) to\n    mitigate this.\n    \n    You can also experiment with how big you want the\n    fractional component of the multiplier, I like it\n    quite big.\n*/\n\n/*\n    Some older hardware and applications do not support\n    bitwise operators. You can either use a LUT to solve this:    \n    http://orenk2k.blogspot.com/2011/05/bitwise-operators-on-low-end-gpus.html\n    \n    Or these functions:\n    \n    int myAND(int A, int B)\n    {\n        return A % 2 != 0 && B % 2 != 0;\n    }\n\n    int myOR(int A, int B)\n    {\n        return A > 0 || B > 0;\n    }\n\n    int myXOR(int A, int B)\n    {\n        return !(A == 1) != !(B == 1);\n    }\n    \n    There may be better ways of doing that.\n*/\n\nvec3 dithering(vec2 uv)\n{\n\tint positionX = int(uv.x * iResolution.x);\n\tint positionY = int(uv.y * iResolution.y);\n\t\n\tvec3 inC = texture(iChannel0, uv).rgb;\n\t\n\tvec3 index = inC * 4.999999f; \n\t\n\tint oddX = positionX & 1;\n\tint oddY = positionY & 1;\n\t\n\tint val[5];\n\tval[0] = 0;           // 0.0f <= x < 0.2f\n\tval[1] = oddX & oddY; // 0.2f <= x < 0.4f\n\tval[2] = oddX ^ oddY; // 0.4f <= x < 0.6f\n\tval[3] = oddX | oddY; // 0.6f <= x < 0.8f\n\tval[4] = 1;           // 0.8f <= x\n\t\n    //return vec3(val[1], val[2], val[3]); // For testing\n    \n\treturn vec3(val[int(index.r)], val[int(index.g)], val[int(index.b)]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = dithering(uv);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}