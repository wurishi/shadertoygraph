{"ver":"0.1","info":{"id":"sstXDs","date":"1634215358","viewed":167,"name":"Alhambra Captive Tower Rosette","username":"curena","description":"A \"Rosácea\" (rosette, wheel) based in the model designed by Manuel Martínez Vela, the original is found in the Captive Tower (Torre de la Cautiva) at the Alhambra in Granada. It is the central part of a larger motif","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["star","tilings","alhambra","rosacea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -----------------------------------------------------------------------------------\n// ISLAMIC STAR PATTERNS\n// Alhambra, Captive Tower (Torre de la Cautiva). Rosácea.\n//\n// Based in one of Manuel Martínez Vela models found in its book:\n// https://www.agapea.com/Manuel-Martinez-Vela/24-Patterns-for-Drawing-The-Alhambra-9788494664328-i.htm\n//\n// Carlos Ureña, Nov, 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\nconst int   n_aa   = 9 ;   // root of number of sampes per pixel for anti-aliasing\nconst float y_freq = 0.6 ; // number of motif repetitions in Y in the output image\n\nconst bool schematic_view = false ;  // show schematic view\nconst bool animation      = false ;\n\nconst float w1 = 0.0100 ,  // ribbons width\n            w2 = 0.0012 ,  // ribbons black border width\n            w  = w1+w2 ;   // total ribbons width\n\nconst float mirror_edges_width = 0.001 ; // red edges width (schematic view)\n\n\n// ------------------------------------------------------------------------------------\n// returns 'p' reflected along the line through 'o' perpendicular to 'n'\n// only when 'p' and 'n' are on different sides of the line\n//  * 'n' must be normalized\n//  * it does not any reflection when 'p' is on the side of 'n' (w.r.t. the line)\n\nint mirror_counter = 0;\n\n\nvec2 CondMirror( vec2 p, vec2 o, vec2 n )\n{\n    float d = dot( p-o, n ),\n          s = step( d, 0.0 );  // s == 0.0 when p on side of n, and s == 1.0 when p and n on different sides\n\n    mirror_counter += int(s);\n    return p - 2.0*s*d*n ;\n}\n\n// ------------------------------------------------------------------------------------\n// rotate 90o to the right, keeps length\n\nvec2 Rotate90Right( vec2 v )\n{\n    return vec2( v.y, -v.x );\n}\n\n// ------------------------------------------------------------------------------------\n// conditional mirror so the resulting point is on the right side of the line from q1 to q2\n// q1-q2 needs not to be normalized\n\nvec2 ToRightSideNUD( vec2 p, vec2 q1, vec2 q2 )\n{\n    return CondMirror(p, q1, normalize( Rotate90Right(q2-q1) ));\n}\n\n// ------------------------------------------------------------------------------------\n// conditional mirror so the resulting point is on the right side of the line from q1 to q2\n// q2-q1 needs to be normalized\n\nvec2 ToRightSideUD( vec2 p, vec2 q1, vec2 q2 )\n{\n    return CondMirror(p, q1, Rotate90Right(q2-q1) );\n}\n\n// ------------------\n// returns 1.0 when 'p' is \"above\" the line through 'o' perpendicular to 'n'\n// (\"above\" means on the same side as 'n', 'n' does not need to be normalized)\n// return 0.0 if it is \"below\"\n\nfloat Above( vec2 p, vec2 o, vec2 n )\n{\n   return step( dot(p-o,n), 0.0 );\n}\n\n// ----------------------------------------------------\n// returns shortest distance to a segment from v1 to v2\n// (the real distance, not scaled)\n// Based on Capsule/Line: https://iquilezles.org/articles/distfunctions\n\nfloat DistanceToSegment2P( vec2 p, vec2 v0, vec2 v1 )\n{\n\tvec2  pa = p - v0,\n          d  = v1 - v0;\n\tfloat h  = clamp( dot(pa,d)/dot(d,d), 0.0, 1.0 );\n    vec2  q  = pa - d*h ;\n\n  \treturn length( q );\n}\n// ------------------------------------------------------------\n// same as before, but using the minimun distance to 2 consecutive\n// segments through 3 points\n\nfloat DistanceToSegment3P( vec2 p, vec2 v0, vec2 v1, vec2 v2 )\n{\n   return min( DistanceToSegment2P( p, v0, v1 ),\n               DistanceToSegment2P( p, v1, v2 ) );\n}\n\n// ----------------------------------------------------\n// returns distance to infinite line\n// (line given by two points, p0 and p1)\n\nfloat DistanceToLine2P( vec2 p, vec2 p0, vec2 p1 )\n{\n\tvec2  q = p - p0,\n          n = Rotate90Right( p1 - p0 );\n\treturn abs( dot(q,n)/sqrt(dot(n,n)) );\n}\n\n// ----------------------------------------------------\n// returns distance to infinite line\n// (line given by point 'p0' and normalized direction vector 'v_norm'\n\nfloat DistanceToLinePVN( vec2 p, vec2 p0, vec2 v_norm )\n{\n\treturn abs( dot( p-p0, Rotate90Right( v_norm ) ) );\n}\n\n// ----------------------------------------------------\n// Returns distance to two halflines joining at v1\n// (with sharp corner in v1)\n\nfloat DistanceToLine3P( vec2 p, vec2 v0, vec2 v1, vec2 v2 )\n{\n    vec2  d01 = normalize( v1-v0 ),\n          d12 = normalize( v2-v1 );\n    float dn  = dot( p-v1, d01+d12 ) ;\n\n    if ( 0.0 <= dn ) return DistanceToLinePVN( p, v1, d12 );  // p on v1-v2 side\n    else             return DistanceToLinePVN( p, v0, d01 );  // p on v0-v1 side\n\n    // note: yes, I know this thing above can be done with 'step',\n    // but ¿ would it be faster ? (that would need two calls to 'DistanceToLine2P')\n}\n\n// ------------------------------------------------------------------------------------\n// if both 'a' and 'b' are <= 't', returns m*a + (m-1)*b ; otherwise return min(a,b) (WIP)\n\nfloat MinPrio( float a, float b, float t, float m )\n{\n    return min(a,b);\n    //float maxim = max(a,b) ;\n    //if ( t < maxim )\n    //    return a+b-maxim ;\n   \t//else\n    //    return m*a + (m-1.0)*b ;\n}\n\n// ------------------------------------------------------------------------------------\n// \n// (compile time constants, I hope) \n\n\nconst float sqrt_2   = sqrt(2.0),\n\t\t\ttan_pi8  = sqrt_2 - 1.0 ,   // tan( pi/8 )\n            tan_pi16 = sqrt( 4.0 +2.0*sqrt_2 ) - sqrt_2 - 1.0 ;  // tan( pi/16 )\n\nconst vec2  n8  = normalize( vec2( -tan_pi8, 1.0 ) ),\n            n16 = normalize( vec2( -tan_pi16, 1.0 ) );\n\n\nconst float x0 = 0.8/10.0 ;\nconst vec2  v0 = vec2( x0, x0*tan_pi16 );\n\nconst float x1 = x0 *( 1.0 + tan_pi16/tan_pi8) ;\nconst vec2  v1 = vec2( x1, 0.0 );\n\nconst float x2 = x1 *( 1.0 + tan_pi16/(tan_pi8-tan_pi16) );\nconst vec2  v2 = vec2( x2, x2*tan_pi16 );\n\nconst float x3 = x2 + 0.15 ;\nconst vec2  v3 = vec2( x3, v2.y ) ;\n\nconst float x4 = v3.x + v3.y*tan_pi8 ;\nconst vec2  v4 = vec2( x4, 0.0 );\n\nconst float x5 = v4.x + v3.y*tan_pi8 ;\nconst vec2  v5 = vec2( x5, v3.y ) ;\n\nconst float x5bis = x5+0.07 ;\nconst vec2  v5bis = vec2( x5bis, v5.y );\n\nconst float x6 = 0.97 ; // right most X coordinate, just a guess...\nconst vec2  v6 = vec2( x6, v5.y ) ;\n\nconst float x7 = ( tan_pi16*v2.x +v5bis.x )/(1.0+tan_pi16) ; // magic formula\nconst vec2  v7 = vec2( x7, x7*tan_pi16 ) ;\n\nconst float x8 = v5bis.x + v5bis.y ;\nconst vec2  v8 = vec2( x8, 0.0 );\n\nconst float l9 = v2.y/(1.0+sqrt_2) ;\nconst float x9 = x8 + l9 ;\nconst vec2  v9 = vec2( x9, l9 );\n\nconst float x10 = x9 ;\nconst vec2  v10 = vec2( x9, x9*tan_pi16 );\n\n\nconst vec4 black  = vec4( 0.0, 0.0, 0.0, 1.0 ),\n           white  = vec4( 1.0, 1.0, 1.0, 1.0 ),\n           line_c = vec4( 1.0, 0.2, 0.0, 1.0 );\n\n// ------------------------------------------------------------------------------------\n// main pattern function\n\nvec4 PatternWCC( in vec2 sample_pos_ndc )\n{\n    float ang = animation ? iTime/6.0 : 0.0 ;\n    float c = cos(ang);\n    float s = sin(ang);\n\n    vec2 p1 = 2.0*sample_pos_ndc ;\n    vec2 p2 = vec2( c*p1.x - s*p1.y, s*p1.x + c*p1.y ); // rotate\n\n    mirror_counter = 0 ;\n\n    vec2  p3  = ToRightSideUD( p2, vec2(0,0), vec2(0,1) );\n    vec2  p4  = ToRightSideUD( p3, vec2(0,0), vec2(-1,0) );\n    vec2  p5  = ToRightSideUD( p4, vec2(0,0), vec2(1,1)/sqrt_2  );\n    vec2  p6  = CondMirror( p5, vec2(0,0), -n8 );\n    vec2  p7  = CondMirror( p6, vec2(0,0), -n16 );\n    vec2  p   = p7 ;\n    float m   = float( mirror_counter & 1 );\n    float p2l = length( p ) ;\n\n    vec4 alternating_bgcol = schematic_view ? vec4( 0.85, 0.85, 0.85, 1.0 )\n                                            : m*vec4( 0.45, 0.45, 0.45, 1.0 )\n                                              + (1.0-m)*vec4( 0.55, 0.55, 0.55, 1.0 ) ;\n\n    const vec4 dark_flat_1 = schematic_view ? vec4( 0.75, 0.75, 0.75, 1.0 )\n                                            : vec4( 0.3,  0.33, 0.39, 1.0 );\n\n    float t      = min( p2l, 1.0 );\n    vec4  bg_col =  0.8*(alternating_bgcol*(1.0-t) + t*dark_flat_1) ;\n\n    // check if point is near edges, for schematic view\n\n    const float wheel_rad = x10 + 0.5*w + 0.009 ; \n    \n\n    bool in_wheel       = p.x <= wheel_rad + 0.5*mirror_edges_width ;\n    bool on_mirror_axes = false ;\n\n    if ( schematic_view )\n    {\n        float de1 = DistanceToLine2P( p, vec2( 0.0, 0.0 ), vec2( 1.0, tan_pi16 ) );\n        float de2 = p.y ;\n        float de3 = abs( p.x - wheel_rad );\n        float dm  = min( de1, min( de2, de3 )) ;\n\n        on_mirror_axes = ( dm <= mirror_edges_width );\n\n        if ( on_mirror_axes && in_wheel  )\n            return vec4( 0.8, 0.3, 0.3, 1.0 );\n    }\n\n    // use background color for points beyond the disk\n\n    if ( ! in_wheel  )\n       return bg_col ;\n\n    // for points inside the disk, compute the pattern\n    \n    float d01   = DistanceToLine2P( p, v0, v1 ),\n          d12   = DistanceToLine2P( p, v1, v2 ),\n          d234  = DistanceToLine3P( p, v2, v3, v4 ),\n          d456  = DistanceToLine3P( p, v4, v5, v6 ),\n          d78   = DistanceToLine2P( p, v7, v8 ),\n          d8910 = DistanceToLine3P( p, v8, v9, v10 );\n\n    float dmin = min( d01, min( d12, min( d234, min( d456, min( d78, d8910 ))))) ;\n    float d ;\n\n    vec4 out_color ;\n\n    if ( dmin < w )\n    {\n        if ( schematic_view )\n        {\n            d = dmin ;\n        }\n        else\n        {\n            if      ( d01  < w && d12  < w ) d = d01*m   + d12* (1.0-m);\n            else if ( d12  < w && d234 < w ) d = d12*m   + d234*(1.0-m);\n            else if ( d234 < w && d456 < w ) d = d234*m  + d456*(1.0-m);\n            else if ( d456 < w && d78  < w ) d = d456*m  + d78* (1.0-m);\n            else if ( d456 < w && d8910< w ) d = d8910*m + d456*(1.0-m);\n            else if ( d78  < w && d8910< w ) d = d78*m   + d8910*(1.0-m);\n            else                             d = dmin ;\n        }\n\n        if ( d < w )\n        {\n           if ( d < w1-w2 ) out_color = white ;\n           else             out_color = schematic_view ? vec4( 0.5, 0.5, 0.5, 1.0 ) : black ;\n        }\n    }\n    else\n        out_color = ( p2l < 0.1 ) ? dark_flat_1*0.8 : bg_col ;\n\n    if ( schematic_view && mirror_counter == 0 )\n        out_color = vec4( 1.0, 0.6*out_color.g, 0.6*out_color.b, 1.0 );\n\n    return out_color ;\n}\n\n\n// ------------------------------------------------------------------------------------\n// computes a pixel color, by using the device coordinates of pixel center\n\nvec4 AA_pixel_color( in vec2 pixel_center_dc )\n{\n    vec4        sum     = vec4( 0.0, 0.0, 0.0, 1.0 );\n    const float n_aa_f  = float(n_aa);\n\n    for( int i = 0 ; i < n_aa ; i++ )\n    for( int j = 0 ; j < n_aa ; j++ )\n    {\n       vec2 sample_pos_dc  = pixel_center_dc + 1.2*(vec2(float(i)+0.5,float(j)+0.5)/n_aa_f) ,\n            sample_pos_ndc = (y_freq/iResolution.y)*(sample_pos_dc-0.5*iResolution.xy) ;\n       sum = sum + PatternWCC( sample_pos_ndc ); ;\n    }\n    return sum/(n_aa_f*n_aa_f);\n}\n\n//-------------------------------------------------------------------------------------\n// computes pixel color, from the integer device coordinates\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AA_pixel_color( fragCoord ) ;\n\n}","name":"Image","description":"","type":"image"}]}