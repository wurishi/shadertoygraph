{"ver":"0.1","info":{"id":"4ljXRc","date":"1508845296","viewed":277,"name":"dithering: i32uni to i16tri hash","username":"hornet","description":"test of idea by Sebastian Sylvan: https://twitter.com/ssylvan/status/922710051269120000\ncalc single 32bit hash, use lower/upper 16bits separately (see n2rand_split())\nint-hash stolen from the awesome Marc B Reynolds, https://www.shadertoy.com/view/4dlcR4","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const int NUM_BUCKETS = 32;\nconst int ITER_PER_BUCKET = 1024;\nconst float HIST_SCALE = 8.0;\n\nconst float NUM_BUCKETS_F = float(NUM_BUCKETS);\nconst float ITER_PER_BUCKET_F = float(ITER_PER_BUCKET);\n\n\n//note: uniformly distributed, normalized rand, [0;1[\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncate( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\n// each dim is defective when zero\nuint hash(uint x, uint y)\n{\n    #define W0 0x3504f333u   // 3*2309*128413 \n\t#define W1 0xf1bbcdcbu   // 7*349*1660097 \n\t#define M  741103597u    // 13*83*686843\n\n  \tx *= W0;   // x' = Fx(x)\n  \ty *= W1;   // y' = Fy(y)\n  \tx ^= y;    // combine\n    x *= M;    // MLCG constant\n  \treturn x;\n}\nfloat hash_st( vec2 uv )\n{\n    uvec2 p = uvec2( uv * iResolution.xy );\n  \tuint h = hash( p.x, p.y );\n  \n  \tuint h_lo = (h & 0x0000ffffu);\n  \tuint h_hi = (h & 0xffff0000u)>>16;\n    \n    float f0 = float(h_lo) / 65536.0;\n    float f1 = float(h_hi) / 65536.0;\n    \n    return f0+f1-1.0;\n}\nfloat n2rand_split( vec2 n )\n{\n\tfloat t = fract( iTime );\n    return hash_st( n + 83.0*t)*0.5+0.5;\n}\n\n\n// ====\n\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nfloat n2rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\treturn (nrnd0+nrnd1) / 2.0;\n}\nfloat n3rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\treturn (nrnd0+nrnd1+nrnd2) / 3.0;\n}\nfloat n4rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n\treturn (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;\n}\n\nfloat n8rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\tfloat nrnd1 = nrand( n + 0.11*t );\t\n\tfloat nrnd2 = nrand( n + 0.13*t );\n\tfloat nrnd3 = nrand( n + 0.17*t );\n    \n    float nrnd4 = nrand( n + 0.19*t );\n    float nrnd5 = nrand( n + 0.23*t );\n    float nrnd6 = nrand( n + 0.29*t );\n    float nrnd7 = nrand( n + 0.31*t );\n    \n\treturn (nrnd0+nrnd1+nrnd2+nrnd3 +nrnd4+nrnd5+nrnd6+nrnd7) / 8.0;\n}\n\n// ====\n\nfloat histogram( int iter, vec2 uv, vec2 interval, float height, float scale )\n{\n\tfloat t = remap( interval.x, interval.y, uv.x );\n\tvec2 bucket = vec2( truncate(t,NUM_BUCKETS_F), truncate(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);\n\tfloat bucketval = 0.0;\n\tfor ( int i=0;i<ITER_PER_BUCKET;++i)\n\t{\n\t\tfloat seed = float(i)/ITER_PER_BUCKET_F;\n\t\t\n\t\tfloat r;\n\t\tif ( iter < 2 )\n\t\t\tr = 0.0; //n1rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<3 )\n\t\t\tr = n2rand( vec2(uv.x,0.5) + seed );\n\t\telse if ( iter<4 )\n\t\t\tr = n2rand_split( vec2(uv.x,0.5) + seed );\n\t\telse\n\t\t\tr = 0.0; //n8rand( vec2(uv.x,0.5) + seed );\n\t\t\n\t\tbucketval += step(bucket.x,r) * step(r,bucket.y);\n\t}\n\tbucketval /= ITER_PER_BUCKET_F;\n\tbucketval *= scale;\n    \n    float v0 = step( uv.y / height, bucketval );\n    float v1 = step( (uv.y-1.0/iResolution.y) / height, bucketval );\n    float v2 = step( (uv.y+1.0/iResolution.y) / height, bucketval );\n\treturn 0.5 * v0 + v1-v2;\n}\n\n// ====\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat o;\n    int idx;\n    vec2 uvrange;\n\tif ( uv.x < 1.0/4.0 )\n\t{\n\t\t//o = n1rand( uv );\n        //idx = 1;\n        //uvrange = vec2( 0.0/4.0, 1.0/4.0 );\n\t}\n\telse if ( uv.x < 2.0 / 4.0 )\n\t{\n\t\to = n2rand( uv );\n        idx = 2;\n        uvrange = vec2( 1.0/4.0, 2.0/4.0 );\n\t}\n\telse if ( uv.x < 3.0 / 4.0 )\n\t{\n\t\to = n2rand_split( uv );\n        idx = 3;\n        uvrange = vec2( 2.0/4.0, 3.0/4.0 );\n\t}\n\telse\n\t{\n\t\t//o = n8rand( uv );\n        //idx = 4;\n        //uvrange = vec2( 3.0/4.0, 4.0/4.0 );\n\t}\n\n    //display histogram\n    if ( uv.y < 1.0 / 4.0 )\n\t\to = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );\n    \n\t//display lines\n\tif ( abs(uv.x - 1.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 2.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.x - 3.0/4.0) < 0.002 ) o = 0.0;\n\tif ( abs(uv.y - 1.0/4.0) < 0.002 ) o = 0.0;\n\n\t\n\tfragColor = vec4( vec3(o), 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}