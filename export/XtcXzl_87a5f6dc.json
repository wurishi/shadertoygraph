{"ver":"0.1","info":{"id":"XtcXzl","date":"1538012384","viewed":753,"name":"bounce about","username":"bergi","description":"This has been a private shader for some years now... Simulates a rubber-ball on a slightly askew plane of wondrous reliefs. ","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","pattern","ballphysics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat sphere_trace(in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    for (int i=0; i<70; ++i)\n    {\n        float d = DE(ro + rd * t);\n        if (d < 0.001)\n            return t;\n        t += d;\n        if (t > 100.)\n            break;\n    }\n    return -1.;\n}\n\nvec3 sky_c(in vec3 rd)\n{\n    return mix(vec3(0.0,.1,.0)*.3,\n               vec3(0.0,.5,.8)*.2, rd.y*.5+.5);\n}\n\nvec3 light(in vec3 p, in vec3 n, in vec3 refl, in vec3 lp, in vec3 co)\n{\n    vec3 ln = normalize(lp - p);\n    float ph = max(0., dot(n, ln));\n    float sh = max(0., dot(refl, ln));\n    return co * pow(ph, 5.)\n         + co * pow(sh, 9.) * .5;\n}\n\nmat4 camera = mat4(1);\nvec4 texel(in ivec2 pixel) { return texture(iChannel0, (vec2(pixel)+.5) / iResolution.xy); }\nvec3 ball_pos;\n\nvoid get_ray(in vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(0,0,0);\n    rd = normalize(vec3(uv, -1.2+.3*length(uv)));\n\n    ro = (camera * vec4(ro, 1.)).xyz;\n    rd = (camera * vec4(rd, 0.)).xyz;\n}\n\nvec3 ball_mix(in vec3 col, in vec3 ro, in vec3 rd, in float t)\n{\n    vec3 n = ball_pos - ro;\n    float l = length(n);\n    n /= l;\n    float mx = max(0., dot(rd, n));\n    return mix(col, vec3(1,.8,.5), pow(mx,60.+l*l));\n}\n\nvec3 render(in vec2 uv)\n{\n    vec3 ro, rd, col=vec3(0);\n    get_ray(uv, ro, rd);\n    float t = sphere_trace(ro, rd);\n    if (t < 0.)\n        return ball_mix(sky_c(rd), ro, rd, 0.);\n\n    vec3 po = ro+t*rd;\n    vec3 n = DE_norm(po);\n    vec3 refl = reflect(rd, n);\n\n    float amp = 4.*max(0., sin(iTime*3.+po.x/3.+po.z));\n    col += sky_c(refl)*.3;\n    col += (sky_c(rd)*amp) * pow(max(0., dot(rd, refl)), 1.);\n    col += light(po, n, refl, camera[3].xyz+vec3(10,10,-3), vec3(.3,.7,1.));\n    col += light(po, n, refl, ball_pos, vec3(1,.8,.5));\n\t\n    col += ball_mix(vec3(0), po, reflect(rd,n), 0.);\n    \n    col = mix(col, sky_c(rd), min(1., t/60.));\n    col = ball_mix(col, ro, rd, t);\n    return col;\n}\n\n// some nifty helper to uniformly set the rotation of a mat2, mat3 or mat4 \nvoid set_rot(in float deg, inout vec2 a, inout vec2 b, in vec4 sig)\n{\n    deg = deg / 180. * 3.14159265; vec2 sc = vec2(sin(deg), cos(deg));\n    a = sc.yx * sig.xy;\n    b = sc.xy * sig.zw;\n}\nmat4 rotate_x(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[1].yz, r[2].yz, vec4(1,1,-1,1)); return m*r; }\nmat4 rotate_y(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[0].xz, r[2].xz, vec4(1,-1,1,1)); return m*r; }\nmat4 rotate_z(in mat4 m, in float deg) { mat4 r = mat4(1); set_rot(deg, r[0].xy, r[1].xy, vec4(1,1,-1,1)); return m*r; }\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(-0.1,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage(out vec4 fragc, in vec2 fc)\n{\n    float t = iTime;\n\t//camera = rotate_x(camera, 90.+20.*sin(t/3.)); \n\t//camera = rotate_y(camera, -90.+20.*sin(t/4.)); \n    //camera = rotate_z(camera, sin(t/7.)*90.); \n\t//camera = rotate_x(camera, 20.*sin(t/1.1)); \n    //camera[3].xyz = vec3(t*3., sin(t*3.141593/12.-.1)*3., sin(t/3.-1.))+0.001;\n    ball_pos = texel(ivec2(0,0)).xyz;\n    vec3 fast_pos = texel(ivec2(2,0)).xyz;\n    vec3 slow_pos = texel(ivec2(1,0)).xyz + vec3(0,1,2);\n    camera = mat4(lookat((slow_pos - fast_pos)*vec3(1,0.4,1)));\n\tcamera[3].xyz = slow_pos;\n    \n    // un-comment to see structure from outside\n    //camera[3].z += 15.; camera = rotate_x(camera, -50.); \n    \n    vec2 uv = (fc - iResolution.xy*.5) / iResolution.y * 2.;\n    \n    vec3 col = vec3(0.);\n\n    col = render(uv);\n\n    fragc = vec4(sqrt(col),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n\nvoid integrate_ball(inout vec3 pos, inout vec3 vel, float dt)\n{\n    vel += dt * vec3(0.06,-.1,0);\n    \n\tvec3 p = pos + dt * vel;\n   \n    float d = DE(p);\n    vec3 n = DE_norm(p);\n    float d_ = dot(n,vel); \n    if (d <= 0. && d_ < 0.)\n    {\n        p -= d * n * 1.1;\n        //vel *= clamp(1.+d_, 0.,1.);\n        vel = reflect(vel, -n);\n    }\n    \n    pos += dt * vel;\n    \n    vel -= dt * vel * 0.03;\n}\n\nvec4 texel(in ivec2 pixel) { return texture(iChannel0, (vec2(pixel)+.5) / iResolution.xy); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fc)\n{\n    fragColor = texel(ivec2(fc));\n    if (iFrame == 0)\n        fragColor = vec4(1.);\n    // do ball\n    else if (fc.x < 1. && fc.y < 2.)\n    {\n        vec3 pos = texel(ivec2(0,0)).xyz;\n        vec3 vel = texel(ivec2(0,1)).xyz;\n        for (int i=0; i<25; ++i)\n            integrate_ball(pos, vel, 0.1/25.);\n        fragColor = vec4(fc.y < 1. ? pos : vel, 0.);\n    }\n    // camera\n    else if (fc.x >= 1. && fc.x < 3. && fc.y < 1.)\n    {\n        vec3 ball = texel(ivec2(0,0)).xyz;\n        vec3 pos = texel(ivec2(1,0)).xyz;\n        float speed = fc.x < 2. ? 0.01 : 0.1;\n        pos += speed * (ball - pos);\n        fragColor = vec4(pos, 0.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 repeat_transform(in vec3 pos, in vec3 repeat) {\n    if (repeat.x > 0.) pos.x = mod(pos.x + repeat.x/2., repeat.x) - repeat.x/2.;\n    if (repeat.y > 0.) pos.y = mod(pos.y + repeat.y/2., repeat.y) - repeat.y/2.;\n    if (repeat.z > 0.) pos.z = mod(pos.z + repeat.z/2., repeat.z) - repeat.z/2.;\n    return pos;\n}\n\nvec3 fan_transform_xz(in vec3 pos, in float center, in float range) {\n    center *= 0.017453292519943295;\n    range *= 0.017453292519943295;\n    float start = (center - range/2.),\n          ang = atan(pos.x, pos.z),\n          len = length(pos.xz);\n    ang = mod(ang-start, range) - range/2. + center;\n    pos.xz = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\nfloat DE(in vec3 pos) {\n    //return dot(pos+vec3(0,4,0), vec3(0,1,0));\n    float d = dot((pos + vec3(0.0, 4.0, 0.0)), vec3(0.0, 1.0, 0.0));\n    d = max(d, -(length(fan_transform_xz(repeat_transform(fan_transform_xz((pos + vec3(0.0, 4.0, 0.0)), 0.0, 45.0), vec3(10.0, 0.0, 10.0)), 90.0, 30.0).yz) - 0.5));\n    d = max(d, -(length(fan_transform_xz(repeat_transform(fan_transform_xz((pos + vec3(0.0, 4.0, 0.0)), 0.0, 60.0), vec3(12.0, 0.0, 12.0)), 90.0, 10.0).yz) - 0.2));\n    return d;\n}\n\nvec3 DE_norm(in vec3 p)\n{\n    vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(\n        DE(p + e.xyy) - DE(p - e.xyy),\n        DE(p + e.yxy) - DE(p - e.yxy),\n        DE(p + e.yyx) - DE(p - e.yyx) ));\n}\n","name":"Common","description":"","type":"common"}]}