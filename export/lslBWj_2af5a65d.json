{"ver":"0.1","info":{"id":"lslBWj","date":"1498233009","viewed":141,"name":"triplanar  texturing test","username":"AngryBaguette","description":"WIP","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["triplanar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Triplanar texture fetch\n//\n// References:\n// https://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821\n// http://www.martinpalko.com/triplanar-mapping/\n//\n// Distance function\n// https://iquilezles.org/articles/distfunctions\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float GRAD_STEP = 0.1;\nconst float PI_4 = 0.78539816339744;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \n\n// Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Twist operator\nvec3 opTwist( vec3 p, float sa )\n{\n    float c = cos(sa*p.y);\n    float s = sin(sa*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// Box\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Sphere\nfloat sdSphere( vec3 p, float r )\n{\n     return length(p)-r;\n}\n\nfloat sdCircle(vec2 uv, vec2 center, float r)\n{\n    vec2 c = (uv - center);\n    return 1.0-clamp(dot(c,c)/r,0.0,1.0);\n}\n    \n// Rotation matrix from euler angle (radian)\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// The scene\nfloat sdScene(vec3 p)\n{     \n    // twist\n\tp = fromEuler( vec3(0.0,0.0,p.y) ) * p;\n    p = opTwist(p, 0.0);\n    \n    //return sdSphere(p,1.0);\n    //return sdBox(p,vec3(0.75,0.75,0.5));\n    //return opS( sdSphere(p,1.0), sdBox(p,vec3(0.75,0.75,0.5)) );\n    //return opS( sdBox(p,vec3(0.8,0.8,0.5)), sdSphere(p,1.0) );\n    return opU( sdBox(p,vec3(2.0,2.0,2.0)), sdSphere(p,2.7) );\n    //return sdSphere(p,2.7);\n}\n\n// Compute through gradient\nvec3 sdSceneNormal(vec3 p) \n{\n    return normalize(vec3(\n        sdScene(vec3(p.x + GRAD_STEP, p.y, p.z)) - sdScene(vec3(p.x - GRAD_STEP, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + GRAD_STEP, p.z)) - sdScene(vec3(p.x, p.y - GRAD_STEP, p.z)),\n        sdScene(vec3(p.x, p.y, p.z  + GRAD_STEP)) - sdScene(vec3(p.x, p.y, p.z - GRAD_STEP))\n    ));\n}\n\n// Ray marching algorithm\nfloat sdRayMarching(Ray ray, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sdScene(ray.origin + depth * ray.direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n// Compute ray\nRay sdRay(vec3 origin, vec2 frag, vec2 res, float fov)\n{\n    Ray ray;\n    ray.origin = origin;\n    vec2 xy = frag - res / 2.0;\n    float z = res.y / tan(fov / 2.0);\n    ray.direction = normalize(vec3(xy, -z));\n    \n    return ray;\n}\n\n// https://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821\n// http://www.martinpalko.com/triplanar-mapping/\nvec4 textureTriPlanar(vec3 P, vec3 N)\n{\n    float texScale = 2.0;\n    // Absolute world normal\n    vec3 sharpness = vec3(1.0);\n    vec3 Nb = pow(abs(N), sharpness);     \n    // Force weights to sum to 1.0\n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\t\n    \n    vec4 c0 = texture(iChannel0, P.xy * texScale) * Nb.z;\n    vec4 c1 = texture(iChannel0, P.yz * texScale) * Nb.x;\n    vec4 c2 = texture(iChannel0, P.xz * texScale) * Nb.y;\n    \n    //vec4 c0 = vec4(1.0,0.0,0.0,1.0) * Nb.z;\n    //vec4 c1 = vec4(0.0,1.0,0.0,1.0) * Nb.x;\n    //vec4 c2 = vec4(0.0,0.0,1.0,1.0) * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\n//Phong shading\nvec3 BlinnPhong(vec3 E, vec3 P, vec3 N)\n{   \n    // Light position\n    vec3 LP = vec3(0.0, 0.0, 6.0);    \n    mat3 rot = fromEuler( vec3(0.0, iTime*0.5, iTime*0.5) );\n    LP = rot * LP;\n \n    // Material\n    //vec3 D = vec3(1.0,0.0,0.0);\n    vec3 D = textureTriPlanar(P,N).rgb;\n    \n    vec3 S = vec3(0.8,0.8,0.8);\n    vec3 A = D * 0.8;\n    float Shininess = 128.0;\n    \n    // Phong\n    vec3 L = normalize(LP-P);\n    vec3 V = normalize(E-P);\n    vec3 H = normalize(L+V);\n    float NDotL = clamp(dot(N,L),0.0,1.0);      \n    float NDotH = clamp(dot(N,H),0.0,1.0);   \n    return D * NDotL + pow( NDotH, Shininess ) + A;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec3 E = vec3(0.0, 0.0, 15.0);\n    Ray ray = sdRay(E, fragCoord.xy, iResolution.xy, PI_4);\n    \n    //mat3 rot = fromEuler( vec3(0.0, iTime, iTime) );\n    //ray.origin = rot * ray.origin;\n    //ray.direction = rot * ray.direction;\n    \n        \n    vec3 color = vec3(0.0);\n    float d = sdRayMarching( ray, MIN_DIST, MAX_DIST);\n    if(d < MAX_DIST)\n    {\n        vec3 P = ray.origin + ray.direction * d;\n        vec3 N = sdSceneNormal(P);\n        \n        // Apply Light\n        color += BlinnPhong(E,P,N);\n        \n        //color += textureTriPlanar(P,N).rgb;\n    }\n    else\n    {\n        // No intersection\n        color = vec3(0.3,0.3,0.3);\n    }\n    \n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}