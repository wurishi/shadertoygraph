{"ver":"0.1","info":{"id":"slXXRX","date":"1626173863","viewed":119,"name":"Ray tracing 1st","username":"TheoWU","description":"My first try","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float c_minimumRayHitTime = 0.1f;\nconst float c_superFar = 10000.0f;\nconst int max_bounce = 8;\nconst float c_pi = 3.1415926;\nconst float c_rayPosNormalNudge = 0.01f;\nconst float c_FOVDegrees = 90.0;\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomDirVector(inout uint state)\n{\n    float z = RandomFloat(state) * 2.0f - 1.0f;\n    float a = RandomFloat(state) * 2.0* c_pi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nstruct hitInfo{\n  float dist;\n  vec3 normal;\n  vec3 albedo;\n  vec3 emission;\n};\n\n\nfloat ScalarTriple(vec3 u, vec3 v, vec3 w)\n{\n    return dot(cross(u, v), w);\n}\n\nbool TestQuadTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo info, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    // calculate normal and flip vertices order if needed\n    vec3 normal = normalize(cross(c-a, c-b));\n    if (dot(normal, rayDir) > 0.0) //if the direction is the same as ray, turn it around\n    {\n        normal *= -1.0;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = rayPos;\n    vec3 q = rayPos + rayDir;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    // determine which triangle to test against by testing against diagonal first\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0f)\n    {\n        // test against triangle a,b,c\n        float u = -dot(pb, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pb, pa);\n        if (w < 0.0f) return false;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else\n    {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0f) return false;\n        float w = ScalarTriple(pq, pa, pd);\n        if (w < 0.0f) return false;\n        v = -v;\n        float denom = 1.0f / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rayDir.x) > 0.1f)\n    {\n        dist = (intersectPos.x - rayPos.x) / rayDir.x;\n    }\n    else if (abs(rayDir.y) > 0.1f)\n    {\n        dist = (intersectPos.y - rayPos.y) / rayDir.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - rayPos.z) / rayDir.z;\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool TestSphereTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo info, in vec4 sphere)\n{\n\t//get the vector from the center of this sphere to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray cannot reach sphere\n\tif(discr < 0.0)\n\t\treturn false;\n    \n\t//ray now found to intersect sphere, compute smallest t value of intersection\n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0f)\n    {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > c_minimumRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normalize((rayPos+rayDir*dist) - sphere.xyz) * (fromInside ? -1.0f : 1.0f);\n        return true;\n    }\n    \n    return false;\n}\n\nvoid TestSceneTrace(in vec3 rayPos, in vec3 rayDir, inout hitInfo hit)\n{    \n    {\n        vec3 A = vec3(-15.0f, -15.0f, 22.0f);\n        vec3 B = vec3( 15.0f, -15.0f, 22.0f);\n        vec3 C = vec3( 15.0f,  15.0f, 22.0f);\n        vec3 D = vec3(-15.0f,  15.0f, 22.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hit.emission = vec3(0.0f, 0.0f, 0.0f);\n        }\n    }\n    \n    {\n        vec3 A = vec3(-15.0f, -15.0f, 22.0f);\n        vec3 B = vec3(-15.0f,  15.0f, 22.0f);\n        vec3 C = vec3(-15.0f,  15.0f, 15.0f);\n        vec3 D = vec3(-15.0f, -15.0f, 15.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.albedo = vec3(0.7f, 0.1f, 0.1f);\n            hit.emission = vec3(0.0f, 0.0f, 0.0f);\n        }\n    } \n    \n    {\n        vec3 A = vec3(15.0f, -15.0f, 22.0f);\n        vec3 B = vec3(15.0f,  15.0f, 22.0f);\n        vec3 C = vec3(15.0f,  15.0f, 15.0f);\n        vec3 D = vec3(15.0f, -15.0f, 15.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.albedo = vec3(0.1f, 0.7f, 0.1f);\n            hit.emission = vec3(0.0f, 0.0f, 0.0f);\n        }\n    }\n    //buttom\n    {\n        vec3 A = vec3(15.1f, -15.0f, 22.0f);\n        vec3 B = vec3(-15.1f, -15.0f, 22.0f);\n        vec3 C = vec3(-15.1f, -15.0f, 15.0f);\n        vec3 D = vec3(15.1f, -15.0f, 15.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.albedo = vec3(0.7f, 0.7f, 0.7f);\n            hit.emission = vec3(0.0f, 0.0f, 0.0f);\n        }\n    }\n    //top\n    {\n        vec3 A = vec3(15.0f, 15.0f, 22.0f);\n        vec3 B = vec3(-15.0f, 15.0f, 22.0f);\n        vec3 C = vec3(-15.0f, 15.0f, 15.0f);\n        vec3 D = vec3(15.0f, 15.0f, 15.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.albedo = vec3(0.5f, 0.5f, 0.5f);\n            hit.emission = vec3(0.0f, 0.0f, 0.0f);\n        }\n    }\n    //light\n    {\n        vec3 A = vec3(5.0f, 13.0f, 17.0f);\n        vec3 B = vec3(-5.0f, 13.0f, 17.0f);\n        vec3 C = vec3(-5.0f, 13.0f, 15.0f);\n        vec3 D = vec3(5.0f, 13.0f, 15.0f);\n        if (TestQuadTrace(rayPos, rayDir, hit, A, B, C, D))\n        {\n            hit.albedo = vec3(0.0f, 0.0f, 0.0f);\n            hit.emission = vec3(1.0f, 0.9f, 0.7f)*30.;\n        }\n    }\n     \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(-10.0f, -10.0f, 20.0f, 3.0f)))\n    {\n        hit.albedo = vec3(0.8f, 0.9f, 0.8f);\n        hit.emission = vec3(0.0f, 0.0f, 0.0f);        \n    } \n     \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(0.0f, -10.0f, 20.0f, 3.0f)))\n    {\n        hit.albedo = vec3(0.9f, 0.8f, 0.8f);\n        hit.emission = vec3(0.0f, 0.0f, 0.0f);        \n    }    \n     \n    if (TestSphereTrace(rayPos, rayDir, hit, vec4(10.0f, -10.0f, 20.0f, 3.0f)))\n    {\n        hit.albedo = vec3(0.8f, 0.8f, 0.9f);\n        hit.emission = vec3(0.0f, 0.0f, 0.0f);\n    }           \n     \n     \n    //if (TestSphereTrace(rayPos, rayDir, hit, vec4(10.0f, 10.0f, 20.0f, 5.0f)))\n    //{\n    //    hit.albedo = vec3(0.0f, 0.0f, 0.0f);\n    //    hit.emission = vec3(1.0f, 0.9f, 0.7f) * 100.0f;\n    //}         \n}\n\nvec3 getColor(vec3 rayori, vec3 raydir, inout uint seed){\n    vec3 color = vec3(0.0,0.0,0.0);\n    vec3 throughput = vec3(1.0,1.0,1.0);\n    for(int i = 0; i <= max_bounce; i++){\n        hitInfo hit;\n        hit.dist = c_superFar;\n        TestSceneTrace(rayori,raydir,hit);\n        if(hit.dist == c_superFar){\n            color += texture(iChannel1, raydir).rgb*throughput;\n            break;\n        }\n        rayori = (rayori + raydir * hit.dist) + hit.normal * c_rayPosNormalNudge;\n        raydir = normalize(hit.normal + RandomDirVector(seed));\n        color += hit.emission * throughput;\n        throughput *= hit.albedo;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint seed = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    vec2 jitter = vec2(RandomFloat(seed),RandomFloat(seed))-0.5;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord+jitter)/iResolution.xy*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float cameraDistance = 1.0f / tan(c_FOVDegrees * 0.5f * c_pi / 180.0f);   \n    \n    vec3 rayori = vec3(0.0,0.0,0.0);\n    \n    vec3 raytarget = vec3(uv,cameraDistance);\n    vec3 raydir = normalize(raytarget - rayori);\n    vec3 col = getColor(rayori,raydir,seed);\n    \n    vec3 lastFrame = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    col = mix(lastFrame,col,1.0/float(iFrame+1));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}