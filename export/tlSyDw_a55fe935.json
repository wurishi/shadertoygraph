{"ver":"0.1","info":{"id":"tlSyDw","date":"1700252869","viewed":47,"name":"water drops shader tutorial","username":"Xneuma","description":"following a tutorial","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["waterdrop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a, b, t)\n\nfloat N21 (vec2 st) {\n    st = fract(st*vec2(123.34, 345.45));\n    st += dot(st, st+34.345);\n    return fract(st.x*st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, 6000.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 aspect = vec2(2., 1.);\n    vec2 size = vec2(5., 3);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 origUVCopy = uv;\n    uv.y += t * 0.25; //To make uv move downwards in y direction.\n    \n    vec2 id = floor(uv*size*aspect);\n    \n\tvec2 pos = fract(uv*size*aspect);\n    pos -= vec2(.5);\n    // Time varying pixel color\n    vec3 col = vec3(0.0);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t//col.rg = pos;\n    \n    float n = N21(id); //-1 to 1, our uv is from -0.5 to 0.5\n    t += n*6.2831;\n    \n    float w = uv.y * 8.;\n    float x = (n-.5)*0.8; //-0.4 to 0.4\n    x += (0.4 - abs(x))*sin(w*3.)*pow(sin(w), 6.)*0.45;\n    float y = -sin(t+sin(t+sin(t)*.5))*0.45;\n    y += (pos.x-x)*(pos.x-x);\n    /*\n\t\tImportant here: setting y += pos.x, will scew the drop.\n\t\tWhy? Because we are setting the y to x which is negative to the\n\t\tleft of the drop, \n\t*/\n    \n    \n    vec2 dropPos = (pos-vec2(x, y))/aspect;\n    float drop = S(.05, .03, length(dropPos));\n    \n    //Adding t*0.25 to the y velocity will cancel out its movement.\n    vec2 trailPos = (pos-vec2(x, t*0.25))/aspect;\n    trailPos.y = (fract(trailPos.y * 8.)-.5)/8.; //To duplicate the trails in y-dir\n    float trail = S(.03, .01, length(trailPos));\n    \n    \n    //trail *= step(-dropPos.y, trailPos.y);\n    //Nedan är en bättre lösning eftersom den smoothar runt mitten cirkeln\n    float fogTrail = S(-.05, .05, dropPos.y);\n    fogTrail *= S(.5, y, pos.y);\n    trail *= fogTrail;\n    fogTrail *= S(-0.05, -0.04, dropPos.x)*S(0.05, 0.04, dropPos.x);\n    \n    col += fogTrail*0.5;\n    col += trail;\n    col += drop;\n    \n    //col = vec3(fogTrail);// Cool effect\n    \n    //Draw a red outline on each cell\n    if(pos.x > 0.48||pos.y > 0.48) { \n      col = vec3(1., 0., 0.); \n    }\n    vec2 offset = drop*dropPos;// + trail*trailPos;// + trail, 0.0);\n    float Distortion = -2.0;\n    vec4 tex = texture(iChannel0, origUVCopy+offset*Distortion);\n    //col = vec3(id*0.1, .4);\n    // Output to screen\n    fragColor = vec4(col*0.0,1.0)+tex;\n}","name":"Image","description":"","type":"image"}]}