{"ver":"0.1","info":{"id":"4lXXDB","date":"1439527702","viewed":2287,"name":"Bokeh World","username":"BigWIngs","description":"My first attempt at creating an environment inside of a shader. Could definitely be optimized but I already spent way too much time on this. :)\nI welcome suggestions on how to make it better.\n\n","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","bokeh","ocean","underwater","fish","sparkles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by Martijn Steinrucken - msteinrucken@gmail.com - 2015\n// License Attribution-ShareAlike 4.0 International (CC BY-SA 4.0)\n// \nconst vec3 worldUp = vec3(0.,1.,0.);\n\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nconst float NUM_SURFACE_BOKEH = 150.;\t// number of twinkly lights on the surface\nconst float NUM_LIGHTS = 100.;\t\t\t// number of twinkly lights falling down\nconst float _FocalDistance = 3.;\t// focal distance of the camera\nconst float _DOF = 2.;\t\t\t\t// depth of field. How quickly lights go out of focus\nconst float _ZOOM = 0.4;\t\t// camera zoom, smaller values means wider FOV\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n// Helper functions =================================\n\n//  Borrowed from other peoples shaders =============\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nvec2 hash2(float n) {\n\tvec2 n2 = vec2(n, -n+2.1323);\n    return fract(sin(n2)*1751.5453);\n}\n\n// https://iquilezles.org/articles/functions\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.;\n    x /= w;\n    return 1. - x*x*(3.-2.*x);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n// ================ End Borrowed Functions =================================\n\nfloat PeriodicPulse(float x, float p) {\n    // pulses from 0 to 1 with a period of 2 pi\n    // increasing p makes the pulse sharper\n\treturn pow((cos(x+sin(x))+1.)/2., p);\n}\n\nfloat SlantedCosine(float x) {\n    // its a cosine.. but skewed so that it rises slowly and drops quickly\n    // if anyone has a better function for this i'd love to hear about it\n\tx -= 3.55;\t// shift the phase so its in line with a cosine\n    return cos(x-cos(x)*0.5);\n}\n\nvec3 IntersectPlane(ray r, vec4 plane) {\n    // returns the intersection point between a ray and a plane\n\tvec3 n = plane.xyz;\n    vec3 p0 = plane.xyz*plane.w;\n    float t = dot(p0-r.o, n)/dot(r.d, n);\n    return r.o+max(0.,t)*r.d;\t\t\t\t// not quite sure what to return if there is no intersection\n    \t\t\t\t\t\t\t\t\t\t// right now it just returns the ray origin\n}\n\nfloat BandStep(float ss, float se, float es, float ee, float t) {\n    return smoothstep(ss, se, t)*smoothstep(ee, es, t);\n}\n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\n// ================================================================\n\n\n\nvec3 Light(ray r, vec3 p) {\n\t// renders a pointlight at position p\n    float dist = length( ClosestPoint(r, p)-p );\n    \n    float lightIntensity = smoothstep(0.1, 0.08, dist);\n    \n    return lightIntensity*vec3(1.);\n}\n\nfloat Bokeh(ray r, vec3 p) {\n\tfloat dist = length( p-ClosestPoint(r, p) );\n    \n    float distFromCam = length(p-e.o);\n    float focus = cubicPulse(_FocalDistance, _DOF, distFromCam);\n    \n    vec3 inFocus = vec3(0.05, -0.1, 1.);\t// outer radius = 0.05, inner radius=0 brightness =1\n    vec3 outFocus = vec3(0.25, 0.2, .05);\t// out of focus is larger, has sharper edge, is less bright\n    \n    vec3 thisFocus = mix(outFocus, inFocus, focus);\n    \n    return smoothstep(thisFocus.x, thisFocus.y, dist)*thisFocus.z;\n}\n\n\n\n\n\nfloat SineWave(vec2 pos, float phase, float frequency, float amplitude, float offset, float thickness, float glow) {\n\t\t// returns a sine wave band\n    \t// takes a position from -pi,-pi to pi, pi\n\t\t\t\t\n    float dist = abs(pos.y-(sin(pos.x*frequency+phase)*amplitude-offset));  // distance to a sine wave\n    return smoothstep(thickness+glow, thickness, dist);\n}\n\nvec3 Floor(ray r) {\n\tvec3 i = IntersectPlane(r, vec4(0.,1.,0.,0.));//Light(e, lightPos);\n    vec3 col=vec3(0.);\n    \n    return col;\n}\n\nvec3 SurfaceBokeh(ray r, float t) {\n    vec3 col = vec3(0.);\n    \n    float bokehArea = 30.;\n    float halfBokehArea = bokehArea/2.;\n    float bokehSize = 0.3*0.3;\t\t\t// use square so we can use squared distance to avoid using length()\n    float bokehBrightness = 0.1;\n    vec3 bokehColor = vec3(1., 1., 0.5);\n    \n    t *= 1.;\n    float T = iTime*3.;\n    float fT = floor(T);\n    \n    for(float i=0.; i<NUM_SURFACE_BOKEH; i++) {\n        float c = i/NUM_SURFACE_BOKEH;\n        float thisT = T+c;\n        \n        vec2 n = hash2(floor(thisT)+c)*bokehArea-halfBokehArea;\n        vec3 p = vec3(n.x, 10., n.y);\n        \n        //vec3 bokeh = vec3( smoothstep(bokehSize, bokehSize*0.8, length(p-ClosestPoint(e, p))) );\n        vec3 d = p-ClosestPoint(e, p);\n        vec3 bokeh = vec3( smoothstep(bokehSize, bokehSize*0.8, dot(d, d)) );\n        \n        \n        float alpha = cubicPulse(0.5, 0.5, fract(thisT));\n        col += vec3( bokeh*alpha);\n    }\n    col *= bokehBrightness;\n    \n    col *= bokehColor;\n    \n    return col;\n}\n\nvec3 Surface(ray r, vec2 coords, float t) {\n    float st = sin(t);\n    float ct = cos(t);\n    mat2 rot = mat2(ct, st, st, -ct);\n    \n    vec3 col = vec3(0.);\n    \n    t *= -20.;\n\tvec2 I = IntersectPlane(r, vec4(0., 1., 0., 10.)).xz*0.2;\n   \n    \n    vec2 W1 = vec2(12., -45)*rot;\n    vec2 W2 = vec2(-210., 360.)*rot;\n    vec2 W3 = vec2(870., -360.);\n    vec2 W4 = vec2(130., 60.);\n    vec2 W5 = vec2(1., -870.);\n    vec2 W6 = vec2(0., 0.);\n    \n    float LW1 = length(I-W1);\n    float LW2 = length(I-W2);\n    float LW3 = length(I-W3);\n    float LW4 = length(I-W4);\n    float LW5 = length(I-W5);\n    float LW6 = length(I-W6);\n    \n    float wave1 = sin(LW1*8.7+t);\n    float wave2 = sin(LW2*12.2+t);\n    float wave3 = sin(LW3*16.+t);\n    float wave4 = sin(LW4*8.+t);\n    float wave5 = sin(LW5*16.+t);\n    float wave6 = sin(LW6*32.+t);\n    \n    float waves = wave1*wave2*wave3*wave4*wave5*wave6;\n    waves /= 4.;\n    waves += 0.25;\n\n    col += vec3(waves);\n    col *= vec3( smoothstep(5., 0., LW6) );\t\t// LW6 was centered at 0, 0 so we can use it to fade the waves\n    \n    \n    col += SurfaceBokeh(r, t);\t\t\t\t\t// add surface wave sparkles\n   \t\n    float camToLight = clamp(dot(worldUp, cam.forward), 0., 1.);\n    camToLight = pow(camToLight, 12.);\n    float rayToLight = clamp(dot(worldUp, e.d), 0., 1.);\n  \t\n    float starShape =  1.+clamp(sin(coords.x*coords.x*100.)-cos(coords.y), 0.,1.);\n    col += vec3(camToLight*rayToLight)*starShape;\n    \n    return col;\n}\n\nvec3 Backdrop(ray r, vec2 coords, float t) {\n    vec3 col= vec3(0.1, 0.5, 1.);\n    \n\tfloat band1 = SineWave(coords, t, 1., 1., 0., 0., 1.);\n\tfloat band2 = SineWave(coords, t*0.7686+1.1342132, 3., .5, 0., 0., 1.);\n    \n    col += (band1*band2)*vec3(0.1, 0.1, 1.);\n    float wave = SineWave(coords, 0., 4., .1, 0., 0.01, 0.01);\n    \n   \n    if(r.d.y>0.) col += Surface(r, coords, t);\n    \n    return col;\n}\n\n\n\n\nvec3 Lights(ray r, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    float height = 4.;\n   \tfloat halfHeight = height/2.;\n   \n    for(float i=0.; i<NUM_LIGHTS; i++) {\n    \tfloat c = i/NUM_LIGHTS;\n        c *= twopi;\n        \n        vec2 xy = hash2(i)*10.-5.;\n        \n        float y = fract(c-t)*height-halfHeight;\n        \n        vec3 pos = vec3(xy.x, y, xy.y);\n        \n        float glitter = 1. +clamp((sin(c+t*30.)-0.9)*50., 0., 100.);\n       \n        float verticalFade = BandStep(halfHeight, halfHeight*0.8, -halfHeight*0.8, -halfHeight, y);\n        col += Bokeh(r, pos)*verticalFade*glitter;\n    }\n    return col;\n}\n\n\n\nvec4 FishLayer(ray r, vec2 coords, float depth, float pathThickness, float t, float shouldLight) {\n\t\n    vec4 col = vec4(1.);\n    \n    vec2 I = IntersectPlane(r, vec4(0.,1.,0.,depth)).xz;\n    \n    float pathCenter = 4.5;\n    \n    float squareDist = dot(I, I);\n    float dist = length(I);\n    float x = coords.x*10.;\n    \n    dist += sin(coords.x*20.)*0.1;\n   \t\n    float circle = BandStep(pathCenter-pathThickness, pathCenter, pathCenter, pathCenter+pathThickness, dist);\n    \n    col.rgb *= 1.- ((dist-pathCenter)/pathThickness)*shouldLight;\t\t// add the light gradient to fake light from above\n    \n    x -= t+depth;\n    \n    float creature = SlantedCosine(x)*0.5+0.5;\n    creature *= clamp(sin(x/2.)*100., 0., 1.);\t// knock out every other creature\n    pathCenter -= 0.2;\n    float eyes = PeriodicPulse(x+1.5, 16.)*BandStep(pathCenter-0.4, pathCenter, pathCenter, pathCenter+0.4, dist);\n    \n    col.rgb -= vec3( eyes*eyes )*0.5;\n    \n    col.a = smoothstep(0., .5, circle*creature);\n    col.rgb *= clamp(col.a*10.,0.,1.);\t\t\t// premultiply alpha\n    \n    return col;\n}\n\nvec4 Fish(ray r, vec2 coords, float t) {\n    vec4 topLayer = FishLayer(r, coords, 2., 0.7, t*2., 1.)*vec4(0.4,0.4,0.4,0.3);\n    vec4 bottomLayer = FishLayer(r, coords, -3., 1., t, 0.)*vec4(0.,0.,0.,.3);\n    \n    vec4 layers = mix(topLayer, bottomLayer, bottomLayer.a);\n    \n    return layers;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec3 mouse = -vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\tfloat t = iTime;\n    \n    float speed = 0.3;\n    \n    float st = sin(t*speed);\n    float ct = cos(t*speed);\n    \n    cam.p = vec3(st, st, ct)*vec3(4., 3.5, 4.);\n    cam.p = normalize(cam.p);// NOTE this won't work if the lookat isn't at the origin\n    \n   // cam.p = vec3(1., 2., 1.);\n    cam.p = rotate_x(cam.p,mouse.y*2.); cam.p = rotate_y(cam.p,mouse.x*3.);\n    \n    \n    cam.lookAt = vec3(0., 0., 0.);\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(worldUp, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = _ZOOM;\n    \n    vec3 screenCenter = cam.p+cam.forward*cam.zoom;\n    vec3 screenPoint = screenCenter+cam.left*uv.x+cam.up*uv.y;\n    \n    e.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    e.d = normalize(screenPoint-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n    \n    float x = atan(e.d.x, e.d.z);\t\t// from -pi to pi\t\n\tfloat y = pi*0.5-acos(e.d.y);  \t\t// from -1/2pi to 1/2pi\n\tvec2 sphereCoords = vec2(x, y);\t\t\t\t\t\n    \n   \n    vec3 col = vec3(0.);\n    \t\n    col += Backdrop(e, sphereCoords, t*0.1);\t\t\t// blueish water + surface \n    \n    vec4 fish = Fish(e, sphereCoords, t);\t\t\t\t// fishies! or... some poor excuse for them ;)\n    col = mix(col, fish.rgb, fish.a);\n    \n\tcol += Lights(e, t*0.1);\t\t\t\t\t\t\t// lights falling down\n   \n    float depthGradient = (dot(e.d, worldUp)+1.)+0.3;\t// STuff gets darker the deeper you go\n    col *= vec3(depthGradient);\n    \n    \n\tfragColor = vec4(col.r, col.g, col.b, 1.);\n}","name":"","description":"","type":"image"}]}