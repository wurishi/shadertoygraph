{"ver":"0.1","info":{"id":"wslGWr","date":"1545882430","viewed":2439,"name":"tracy raymond","username":"bitnenfer","description":"testing out something, inspired by \"Deciphering The Postcard Sized Raytracer\" written by Fabien Sanglard. (http://fabiensanglard.net/postcard_pathtracer/)","likes":24,"published":1,"flags":32,"usePreview":0,"tags":["raytracer","rays","raymarcher","lights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DIST 100.0\n#define MIN_DIST 0.001\n#define TYPE_NONE -1.0\n#define TYPE_SPHERE 1.0\n#define TYPE_BOX 2.0\n#define TYPE_BOX2 4.0\n#define TYPE_BOX3 5.0\n#define TYPE_SUN 3.0\n#define IS_DEBUG 0\n\nvec3 kSunDir = vec3(0.8, 1.0, 0.6);\n\nstruct Hit\n{\n    vec3 point;\n    vec3 normal;\n    float type;\n};\n\nvec3 hash3( vec2 p ){\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n                   dot(p,vec2(269.5,183.3)), \n                   dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n\nfloat seed = 0.0;\nfloat hash( float n )\n{\n    seed = fract(sin(n + seed)*43758.5453);\n    return seed;\n}\n\n// HG_SDF (http://mercury.sexy/hg_sdf/)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p+halfsize, size) - halfsize;\n    if (c > stop) { //yes, this might not be the best thing numerically.\n        p += size*(c - stop);\n        c = stop;\n    }\n    if (c <start) {\n        p += size*(c - start);\n        c = start;\n    }\n    return c;\n}\n\n\nvoid Rotate(inout vec2 point, float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    float px = point.x * c - point.y * s;\n    float py = point.x * s + point.y * c;\n    point.x = px;\n    point.y = py;\n}\n\nfloat SDFSphere(vec3 point, float radius)\n{\n    return length(point) - radius;\n}\n\nfloat SDFBox(vec3 point, vec3 size)\n{\n    vec3 d = abs(point) - size;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec2 Union(in vec2 a, in vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nvec2 MapSpheres(vec3 rayPoint)\n{\n    float a = SDFSphere(rayPoint + vec3(+0.3, 1.6, -1.7), 0.5);\n    float b = SDFSphere(rayPoint + vec3(-1.0, 1.3, -4.0), 0.8);\n    \n    return vec2(min(a, b), TYPE_SPHERE);\n}\n\nvec2 MapBoxes(vec3 rayPoint)\n{\n    rayPoint += vec3(0.0, 0.0, -3.0);\n    float a = SDFBox(rayPoint + vec3(0.0, 0.0, 0.0), vec3(4.2, 2.4, 7.2));\n    float b = SDFBox(rayPoint + vec3(0.0, 0.0, 0.0), vec3(3.8, 2.0, 6.5));\n    float c = SDFBox(rayPoint + vec3(-0.0, 0.4, -9.0), vec3(2.45, 0.45, 10.0)) - 0.4;\n    \n    vec3 rep = vec3(0.0, 0.0, 1.3);\n    vec3 p = mod(rayPoint, rep) - rep * 0.5;\n    float vent = SDFBox(p + vec3(0.0, -2.5, 0.0), vec3(3.1, 0.8, 0.4));\n    float scene = max(max(max(a, -b), -c), -vent);\n    float d = SDFBox(rayPoint + vec3(-5.2, 0.4, -0.0), vec3(2.45, 0.45, 3.0)) - 0.4;\n    \n    scene = max(scene, -d);\n    \n    \n    \n    return vec2(scene, TYPE_BOX);\n}\n\nvec2 MapScene(vec3 rayPoint)\n{\n    vec2 spheres = MapSpheres(rayPoint);\n    vec2 boxes = MapBoxes(rayPoint);\n    vec3 p = rayPoint + vec3(0.0, -1.0, -9.5);\n    pModInterval1(p.x, 2.0, -1.0, 1.0);\n    vec2 box2 = vec2(SDFBox(p, vec3(0.3, 0.1, 0.2)), TYPE_BOX2);\n    \n    vec3 hp = rayPoint + vec3(0.05, 1.1, -4.1);\n    Rotate(hp.xz, 3.15/2.5);\n    Rotate(hp.yz, -3.15/4.3);\n    float hex = SDFBox(hp, vec3(0.8, 1.2, 0.1)) - 0.05;\n    \n    box2 = Union(box2, vec2(hex, TYPE_BOX3));\n    \n    return Union(Union(spheres, boxes), box2);\n}\n\nvec3 GetNormal(vec3 point)\n{\n    vec2 e = vec2(0.0, 0.001);\n    return normalize(MapScene(point).x - vec3(\n        MapScene(point - e.yxx).x,\n        MapScene(point - e.xyx).x,\n        MapScene(point - e.xxy).x\n    ));\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection, out Hit result)\n{\n    const int MAX_STEPS = 200;\n    float totalDistance = 0.0;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 rayPoint = rayOrigin + rayDirection * totalDistance;\n        vec2 mapResult = MapScene(rayPoint);\n        if (mapResult.x < MIN_DIST) \n        {\n            result.point = rayPoint;\n            result.normal = GetNormal(rayPoint);\n            result.type = mapResult.y;\n            return totalDistance;\n        }\n        totalDistance += mapResult.x;\n        if (totalDistance > MAX_DIST) break;\n    }\n    result.type = TYPE_NONE;\n    return MAX_DIST;\n}\n\nvec3 seed1 = vec3(0, 0, 0);\nfloat random()\n{\n    return fract(sin(fract(sin(dot(seed1.xy, vec2(12.98, 78.23)) * (seed1.z += 1.)) * 437.54))*73.54);\n}\n\nvec3 getSampleBiased(vec3 dir, float power) {\n    dir = normalize(dir);\n    vec3 o1 = normalize(abs(dir.x) > abs(dir.z) ? vec3(-dir.y, dir.x, 0) : vec3(0, -dir.z, dir.y));\n    vec3 o2 = normalize(cross(dir, o1));\n    vec2 r = vec2(random(), random());\n    r.x = r.x * 2. * 3.14;\n    r.y = pow(r.y, 1. / (power + 1.));\n    float oneminus = sqrt(1. - r.y * r.y);\n    return cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\nvec3 GetRandomHemisphere(float r1, float r2)\n{\n    #if 0\n    float st = sqrt(1.0 - r1 * r1);\n    float phi = 2.0 * 3.15 * r2;\n    float x = st * cos(phi);\n    float z = st * sin(phi);\n    return vec3(x, r1, z);\n    #else\n    float r = sqrt(r1);\n    float theta = 2.0 * 3.15 * r2;\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    return vec3(x, sqrt(max(0.0, 1.0 - r1)), y);\n    #endif\n}\n\nvec3 Trace(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    #if IS_DEBUG\n    Hit result;\n    float dist = RayMarch(rayOrigin, rayDirection, result);\n    if (result.type != TYPE_NONE)\n    {\n        return result.normal;\n        return result.point;\n        return vec3(dist / 20.0);\n    }\n    #else\n    const int BOUNCE_COUNT = 5;\n    vec3 color = vec3(0.1);\n    float offset = 0.1;\n    vec3 l = normalize(kSunDir);\n    float a = 1.0;\n    float frame = float(iFrame);\n    float cf = cos(frame);\n    float sf = sin(frame);\n    \n    for (int bounce = 0; bounce < BOUNCE_COUNT; ++bounce)\n    {\n        Hit result = Hit(vec3(0.0), vec3(0.0), 0.0);\n        float rayDistance = RayMarch(rayOrigin, rayDirection, result);\n        float diff = dot(result.normal, l);\n        \n        if (result.type == TYPE_BOX)\n        {\n            float rx = hash(rayDirection.x + sf);\n            float ry = hash(rayDirection.x + cf);\n            vec3 rn = GetRandomHemisphere(rx, ry);\n            vec3 n = normalize(result.normal + rn * 0.8);\n            rayDirection = getSampleBiased(result.normal, 1.);//normalize(reflect(rayDirection, n));\n            rayOrigin = result.point + rayDirection * offset;\n            a *= 0.8;\n            if (diff > 0.0)\n            {\n                float dist = RayMarch(result.point + result.normal * offset, l + rn * 0.01, result);\n                if (result.type == TYPE_NONE)\n                {       \n                    color += a * vec3(1.2,1.2,1) * max(0.0, diff);\n                }\n            }\n        }\n        else if (result.type == TYPE_SPHERE)\n        {\n            rayDirection = normalize(reflect(rayDirection, result.normal));\n            rayOrigin = result.point + rayDirection * offset;\n            color += a * vec3(0.25,0,0) * max(0.2, diff);\n            a *= 0.1;\n            if (diff > 0.0)\n            {\n                float rx = hash(rayDirection.x + sf);\n                float ry = hash(rayDirection.x + cf);\n                vec3 rn = GetRandomHemisphere(rx, rx);\n                float dist = RayMarch(result.point + result.normal * offset, l + rn * 0.1, result);\n                if (result.type == TYPE_NONE)\n                {       \n                    color += a * vec3(1.8, 0.0, 0.0) * max(0.0, diff);\n                }\n            }\n        }\n        else if (result.type == TYPE_BOX3)\n        {\n            float rx = hash(rayDirection.x + sf);\n            float ry = hash(rayDirection.x + cf);\n            vec3 rn = GetRandomHemisphere(rx, rx);\n            vec3 n = normalize(result.normal + rn * 0.02);\n            rayDirection = getSampleBiased(result.normal, 1.);;\n            rayOrigin = result.point + rayDirection * offset;\n            color += a * vec3(0.3, 0.2, 0.05) * max(0.2, diff * 2.0);\n            a *= 0.5;\n            if (diff > 0.0)\n            {\n                float dist = RayMarch(result.point + result.normal * offset, l + rn * 0.1, result);\n                if (result.type == TYPE_NONE)\n                {\n                    color += a * vec3(0.8, 0.8, 0.0) * max(0.00, diff);\n                }\n            }\n        }\n        else if (result.type == TYPE_BOX2)\n        {\n            rayDirection = normalize(reflect(rayDirection, result.normal));\n            rayOrigin = result.point + rayDirection * offset;\n            color += a * (vec3(1.29, 0.71, 0.28)) * 4.0;\n            a *= 0.1;\n        }\n        else if (result.type == TYPE_NONE) \n        {\n            color = color + a * vec3(0.35, 0.69, 0.95);\n            break;\n        }\n    }\n    \n    return color;\n    #endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    seed1 = vec3(fragCoord.xy/iResolution.xy, mod(iTime, 10.));\n    vec3 color = vec3(0.0);\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * aspectRatio;\n    vec3 rayOrigin = vec3(0.0, 0.0, -3.2);\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n    float frame = float(iFrame);\n    float cf = cos(frame);\n    float sf = sin(frame);\n    float mx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 6.28;\n    \n    Rotate(rayOrigin.xz, mx);\n    Rotate(rayDirection.xz, mx);\n    \n    #if IS_DEBUG\n    color = Trace(rayOrigin, rayDirection);\n    #else\n    vec3 rd = rayDirection;\n    float rx = hash(rayDirection.x + sf);\n    float ry = hash(rayDirection.x + cf);\n    vec3 rn = GetRandomHemisphere(rx, ry);\n    color = Trace(rayOrigin, rd);\n    color = pow(color, vec3(1.0/1.4));\n    color = mix(color, 1.0 - (color * 5.2), max(0.0, pow(length(1.0 * uv / vec2(aspectRatio)), 5.9)));   \n    vec4 prevColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    float frames = 1.0 / float(iFrame + 1);\n    if (iFrame > 1)\n        color.rgb = mix(prevColor.rgb, color.rgb, frames);\n    #endif\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"}]}