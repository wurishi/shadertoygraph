{"ver":"0.1","info":{"id":"ms3GDs","date":"1678038630","viewed":1165,"name":"Smoke Flythrough","username":"Poisson","description":"A simple cloud shader to test my volumetric renderer, the noise is very bad and cheap.","likes":79,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","ray","volume","clouds","fbm","cloud","fire","volumetric","raymarcher","scattering","smoke","scatter","volumetrics","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A simple cloud shader to test my volumetric renderer, the noise is very bad and cheap.\n\n#define LOOK 0\n#define NUM_STEPS 256 // marching steps, higher -> better quality\n\n// aces tonemapping\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// camera path\nvec2 camPath(float t) {\n    return vec2(.4*sin(t),.4*cos(t*.5));\n}\n\n// generate a number between 0 and 1\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// 3d noise function\nfloat noise(vec3 x) {\n    vec3 p = floor(x+.5);\n    vec3 f = fract(x+.5);\n    f = f*f*(3.-2.*f);\n    \n    x = p + f - .5;\n    return textureLod(iChannel0, x/iChannelResolution[0], 0.).r;\n}\n\n// smooth minimum\n// thanks to iq: https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5+.5*(b-a)/k, 0., 1.);\n\treturn mix(b, a, h) - k*h*(1.-h);\n}\n\n// volume density\nfloat map(vec3 p) {\n    float f = 0.;\n    \n    // smoke fbm\n    vec3 q = p;\n    p *= 3.;\n    f += .5*noise(p);\n    f += .25*noise(2.*p);\n    f += .0625*noise(7.*p);\n    f += .03125*noise(16.*p);\n    f -= .35;\n    \n    // tunnel\n    q.xy -= camPath(q.z);\n    f = smin(f, .1-length(q.xy), -.4);\n    \n    return -256.*f;\n}\n\n#if LOOK==0\n// light intensity function\nfloat getLight(float h, float k, vec3 ce, vec3 p) {\n    vec3 lig = ce-p;\n    float llig = length(lig);\n    lig = normalize(lig);\n    float sha = clamp((h - map(p + lig*k))/128.,0.,1.);\n    float att = 1./(llig*llig);\n    return sha*att;\n}\n#endif\n\n// volumetric rendering\nvec3 render(vec3 ro, vec3 rd) {                   \n    float tmax = 6.; // maximum distance\n    float s = tmax / float(NUM_STEPS); // step size\n    float t = 0.; // distance travelled\n    // dithering\n    t += s*hash(gl_FragCoord.x*8315.9213/iResolution.x+gl_FragCoord.y*2942.5192/iResolution.y);\n    vec4 sum = vec4(0,0,0,1); // final result\n    \n    for (int i=0; i<NUM_STEPS; i++) { // marching loop\n        vec3 p = ro + rd*t; // current point\n        float h = map(p); // density\n        \n        if (h>0.) { // inside the volume    \n            // lighting\n            float occ = exp(-h*.1); // occlusion\n            \n            #if LOOK==0\n            float k = .08;\n            vec3 col = 3.*vec3(.3,.6,1)*getLight(h, k, ro+vec3(1,0,2), p)*occ\n                     + 3.*vec3(1,.2,.1)*getLight(h, k, ro+vec3(-1,0,2.5), p)*occ;\n            #else\n            vec3 col = .1*vec3(.6,.8,1)*occ;\n            #endif\n             \n            sum.rgb += h*s*sum.a*col; // add the color to the final result\n            sum.a *= exp(-h*s); // beer's law\n        }\n        \n        if (sum.a<.01) break; // optimization\n        t += s; // march\n    }\n                   \n    // output\n    return sum.rgb;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro); // forward vector\n    vec3 u = normalize(cross(w, vec3(0,1,0))); // side vector\n    vec3 v = cross(u, w); // cross vector\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates centered at the origin\n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\n        \n    vec3 ro = vec3(0,0,iTime); // ray origin\n    vec3 ta = ro + vec3(0,0,1); // target\n    \n    ro.xy += camPath(ro.z);\n    ta.xy += camPath(ta.z);\n    \n    mat3 ca = setCamera(ro, ta); // camera matrix\n    vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n    vec3 col = render(ro, rd); // render\n    \n    col = ACES(col); // tonemapping\n    col = pow(col, vec3(.4545)); // gamma correction\n\n    // vignette and black bars\n    vec2 q = fragCoord/iResolution.xy;\n    col *= pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);\n    col *= step(abs(q.y-.5),.4);\n                \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}