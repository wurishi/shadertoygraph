{"ver":"0.1","info":{"id":"Dls3D7","date":"1672008628","viewed":98,"name":"DI Trace Nehon","username":"nehon","description":"A simple path tracer written for educational purposes.\nderived from https://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html\nThis only does direct illumination (no GI)\nFocused on various types of importance sampling.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["educational","pathtracing","exercises"],"hasliked":0,"parentid":"mlf3WM","parentname":"Path Traced Scene Ref Nehon"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    out_color = texture(iChannel0, pixel_coord / iResolution.xy);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SAMPLE_COUNT 1\n#define ACCUM 1\n\n// Sampling mode\n#define RIS 1\n#define UNIFORM_HEMI 2\n#define COSINE_HEMI 3\n\n#define SAMPLING_MODE RIS\n\n\n// Computes the sum of emitted radiance and reflected radiance due to direct\n// illumination\n// \\param point The point being shaded (x)\n// \\param tri The triangle on which the point is located\n// \\param seed Needed for get_random_numbers()\n// \\return A Monte Carlo estimate with N=1 of the direct illumination (L_o(x))\nvec3 compute_direct_illumination(vec3 point, triangle_t tri, inout uvec2 seed) {\n    vec3 radiance = tri.emission;    \n    float invpdf;\n#if SAMPLING_MODE == RIS\n    // pdf: Probability density function (likelihood that a rand om ray will be in a certain range, say shooting toward a light)\n    // cdf: Cumulative distribution function (step by step sum of the pdf, allows to draw samples from the pdf easily) \n\n    // Ressampled Importance Sampling \n    // see https://diglib.eg.org/bitstream/handle/10.2312/EGWR.EGSR05.139-146/139-146.pdf\n    // The main idea is to have a simple initial pdf for wich computing the cdf is trivial.\n    // this allow to draw \"bad\" samples without shoot ing rays.\n    // here we use the lighting equation for pdf, without the visibility part. (except when the light in on th e backside of the shaded face)\n    // once we created the cdf we pick a sample and actually shoot the ray to compute the real light equation\n    //\n    // Caveats: since we only shoot at lights we need to correct the error by weighting the sample.\n    \n    // compute cdf\n    float cdf[LIGHT_COUNT];\n    float weights[LIGHT_COUNT];    \n    float sum;     \n    for(int i = 0; i < LIGHT_COUNT; i++){\n        Light l = lights[i];\n        vec3 lightV = l.pos - point;\n        float dist = length(lightV);\n        lightV = lightV / dist;\n        // unshadowed light contribution\n        // we want the light to be have higher weight when:\n        //  - emission is higher        \n        //  - the dot with the light dir and the shaded surface is higher (0 if normal and dir go opposite side)\n        //  - the light is closer to the shaded point.\n        vec3 ev = vec3(l.emission) * max(0.0,dot(tri.normal, lightV))  / ((dist * dist));\n        weights[i] = (ev.x + ev.y + ev.z) * 0.333333; // brightness as weight\n        sum += weights[i];\n        cdf[i] = sum;\n    }\n    \n    //draw from cdf\n    float rv = get_random_numbers(seed).x * sum;\n    int index = 0;\n    // we could do a binary search but since we have only 4 lights we do a brute force lookup.\n    for(int i = 0; i < LIGHT_COUNT; i++){\n        if(rv <= cdf[i]) {\n            index = i;\n            break;\n        }\n    }\n    \n    // compute sample error correction induced by RIS\n    // see https://youtu.be/gsZiJeaMO48?t=1345\n    // correction is the average of the weights divided byt the drawn sample's weight\n    invpdf = (sum / float(LIGHT_COUNT)) / weights[index];\n    \n    // get random dir to towards light.\n    // we pick a random point on the light surface\n    Light l = lights[index];\n    vec2 rd = get_random_numbers(seed);\n    vec3 p = vec3(mix(l.min.xy, l.max.xy, rd), l.min.z);    \n    vec3 dir = normalize(p - point);     \n    // here we also have to correct the sample, since we pick only on the lights\n    // we use the total area covered by the lights sources, mutiplied by the dot between \n    // light surface area normal and the drawn direction\n    // note that we'd probably have a better result with proper solid angle calculation, but his works ok.\n    invpdf *= areaSum * abs(dot(dir, vec3(0.0,0.0,-1.0)));\n    \n    float t;\n    triangle_t hit;\n    if(ray_mesh_intersection(t, hit, point, dir)){        \n        invpdf /= t*t; // accoutn for the light distance to the shaded point.\n        radiance = tri.emission + (tri.color / M_PI) * invpdf * hit.emission * dot(tri.normal, dir);\n        //              |                 |               |          |                  |\n        //    shaded surface emission    BRDF     pdf correction     |                 NoL\n        //                                                           |\n        //                                                 hit surface emission\n        //                                       (0 if not a light, acts as the visibility)\n    }\n#else\n    #if SAMPLING_MODE == UNIFORM_HEMI\n     vec3 dir = sample_hemisphere(get_random_numbers(seed), tri.normal, invpdf);\n    #else\n     vec3 dir = sample_cos_weighted_hemisphere(get_random_numbers(seed), tri.normal, invpdf);\n    #endif \n    float t;\n    triangle_t hit;\n    if(ray_mesh_intersection(t, hit, point, dir)){        \n        radiance = tri.emission + (tri.color / M_PI) * invpdf * hit.emission * dot(tri.normal, dir);\n    }\n#endif\n    \n    return radiance;\n}\n\n\n// Finds the triangle intersected by the given ray and performs shading without\n// global illumination.\n// \\param origin The position at which the ray starts\n// \\param direction The direction vector of the ray\n// \\param seed Needed for get_random_numbers()\n// \\return A Monte Carlo estimate of the reflected (direct only) and emitted\n//         radiance at the point intersected by the ray (i.e. the color)\nvec3 get_direct_ray_radiance(vec3 origin, vec3 direction, inout uvec2 seed) {\n    float t;\n    triangle_t tri;\n    if (ray_mesh_intersection(t, tri, origin, direction)){\n        if(tri.emission.x >0.0){\n            return tri.emission;\n        }\n        return compute_direct_illumination(origin + t * direction, tri, seed);\n    }\n    else\n        return vec3(0.0);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    createScene();\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Use a different seed for each pixel and each frame\n    uvec2 seed = uvec2(pixel_coord) ^ uvec2(iFrame << 16);\n    // Perform path tracing with SAMPLE_COUNT paths\n   \n    out_color.rgb = vec3(0.0);\n    for (int i = 0; i != SAMPLE_COUNT; ++i)\n        out_color.rgb += get_direct_ray_radiance(camera_position, ray_direction, seed);\n    out_color.rgb /= float(SAMPLE_COUNT);\n   \n   #if ACCUM == 1\n    vec3 prevColor = texture(iChannel0, tex_coord).rgb;\n    float weight = 1.0 / float(iFrame + 1);\n    out_color.rgb = mix(prevColor, out_color.rgb, weight); \n   #endif \n    out_color.a = 1.0;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.141592653589793238462643\n#define TRIANGLE_COUNT 38\n#define LIGHT_COUNT 4\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\nstruct Light{    \n    vec3 min;\n    vec3 max;  \n    vec3 pos;\n    float area;\n    float emission;\n};\n\nfloat areaSum = 0.0;\nLight lights[LIGHT_COUNT];\nint lightIndex = 0;\ntriangle_t tris[TRIANGLE_COUNT];\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n    float z = 2.0 * random_numbers[1] - 1.0;     \n    float phi = 2.0 * M_PI * random_numbers[0]; \n    float s = sqrt(1.0 - z * z);\n    float x = cos(phi) * s;     \n    float y = sin(phi) * s;     \n    return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal,inout float invpdf) {\n    vec3 direction = sample_sphere(random_numbers);\n    if (dot(normal, direction) < 0.0)\n    direction -= 2.0 * dot(normal, direction) * normal;\n    invpdf = 2.0 * M_PI;\n    return direction;\n}\n\nvec3 sample_cos_weighted_hemisphere(vec2 u, vec3 normal, inout float invpdf) {\n    float a = sqrt(1.0-u.y);    \n    float phi = 2.0 * M_PI * u.x;   \n    float cphi = cos(phi);\n    float x = cphi * a;\n    float y = sin(phi) * a;\n    float z = sqrt(u.y);\n    \n    vec3 up = vec3(0.0,0.0,1.0);\n    float d = abs(dot(normal, up));\n    up = d > 0.999?vec3(0.0,1.0,0.0):up;\n    up = d > 0.999?vec3(1.0,0.0,0.0):up;\n    vec3 bt = cross(normal, up);\n    vec3 t = cross(normal, bt);\n    vec3 b = cross(normal, t);\n    mat3 tbn = mat3(t, b , normal);\n    invpdf =  M_PI / z;\n    return normalize(tbn * vec3(x,y,z));\n}\n\n\n\nvoid makeLight(out triangle_t tri1, out triangle_t tri2, in vec3 pos, in vec3 extent, in float str){\n    tri1.positions[0] = pos + extent * vec3(-1.0,1.0,0.0); \n    tri1.positions[1] = pos + extent * vec3(1.0,-1.0,0.0); \n    tri1.positions[2] = pos + extent * vec3(-1.0,-1.0,0.0);     \n    tri1.normal = vec3(0.0, 0.0, -1.0);\n    tri1.color = vec3(0.0, 0.0, 0.0);\n    tri1.emission = vec3(str, str, str);\n    \n    tri2.positions[0] = tri1.positions[0];\n    tri2.positions[1] = pos + extent * vec3(1.0,1.0,0.0); \n    tri2.positions[2] = tri1.positions[1];\n    tri2.normal = vec3(0.0, 0.0, -1.0);\n    tri2.color = vec3(0.0, 0.0, 0.0);\n    tri2.emission = vec3(str, str, str);\n    \n    Light l;\n    l.min = pos - extent;\n    l.max = pos + extent;\n    l.pos = pos;\n    l.area = extent.x * extent.y * 4.0;\n    areaSum += l.area;\n    l.emission = str;\n    lights[lightIndex++] = l;\n}\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n    vec3 v0 = tri.positions[0];     \n    mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);     \n    vec3 solution = inverse(matrix) * (origin - v0);     \n    out_t = solution.x;     \n    vec2 barys = solution.yz;\n    return out_t >= 0.001 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38; \n    for (int i = 0; i != TRIANGLE_COUNT; ++i) {         \n        float t;         \n        if (ray_triangle_intersection(t, origin, direction, tris[i]) && t < out_t) {             \n            out_t = t;             \n            out_tri = tris[i];         \n        }     \n    }     \n    return out_t < 1.0e38;\n}\n\nvoid createScene(){\n    // Definition of the mesh geometry (exported from Blender)\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.8, 0.8, 0.8); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.8, 0.8, 0.8);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(0.0, 0.0, 0.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(0.0, 0.0, 0.0);\n    \n    \n    makeLight(tris[30], tris[31], vec3(0.485,-0.485,0.548), vec3(0.035, 0.035, 0.0), 10.0);\n    makeLight(tris[32], tris[33], vec3(0.1,-0.485,0.548), vec3(0.045, 0.045, 0.0), 10.0);\n    makeLight(tris[34], tris[35], vec3(0.485,-0.1,0.548), vec3(0.025, 0.025, 0.0), 20.0);\n    makeLight(tris[36], tris[37], vec3(0.1,-0.1,0.548), vec3(0.055, 0.055, 0.0), 20.0);\n \n}\n\n\n","name":"Common","description":"","type":"common"}]}