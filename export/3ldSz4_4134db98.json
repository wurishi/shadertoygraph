{"ver":"0.1","info":{"id":"3ldSz4","date":"1581457137","viewed":118,"name":"Strange_v1","username":"oscarmar","description":"DeJung Strange Attractor real-time rendering.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["attractor","recursive","dataencoded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by OscarMar\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(texture(iChannel0,uv).rgba);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by OscarMar\n\n//\n// parameters\n//\nconst int N = 4;            // number of base points\nconst int M = 50;           // computed points\nconst float rd = 1.5;       // point radius\nconst bool blur_en = false; // \"gaussian\" blur effect\nconst float wt = .021;      // blur intensity\n\n\n//\n// attractor function\n//\nvec2 att_fn(vec2 xm){\n\n    //float a = -2., b = -2., c = -1.29, d = 2.;\n    //float a = -2.24, b = 0.663, c = -0.65, d = -2.43;\n    //float a = 1.28, b = -1.98, c = -1.19, d = 1.91;\n    //float a = -2.24, b = 1.43, c = -0.65, d = -2.43;\n\n    float a = 1.1 , b = 1.43, c = -0.86+ 3.0*sin(floor(float(iFrame)/100.)/10.), d = -2.43;\n\n    vec2 nx = vec2(sin(a*xm.y)-cos(b*xm.x),\n                   sin(c*xm.x)-cos(d*xm.y));\n\n    return nx;\n}\n\n\n//\n// pseudo random\n//\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy + .1 ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//\n// color space conversion\n//\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//\n// Data encoding (needed for 8bit depth buffers)\n//\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\n\nvec4 dencode (float v) {\n    vec4 enc = bitEnc * v;\n    enc = fract(enc);\n    enc -= enc.yzww * vec2(1./255., 0.).xxxy;\n    return enc;\n    \n//    return vec4(v,0,0,0);\n}\n\nfloat ddecode (vec4 v) {\n    return dot(v, bitDec);\n    \n//    return v.x;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 rs = iResolution.xy;\n\n    vec4 Xp[N]; // store x-value data\n    vec4 Xq[N]; // store y-value data\n    vec2 Xt[N]; // store decoded data\n    \n    // data blocks width\n    float w = rs.x/(float(4*N)+1.);\n\n    // retreive all points\n    for(int i=0;i<N;i++){\n  \t\tXp[i] = (vec4(texture(iChannel0,vec2(w/2.+float(2*i)*w,1.)/rs).rgba));\n        Xq[i] = (vec4(texture(iChannel0,vec2(w/2.+float(2*i+1)*w,1.)/rs).rgba));\n        Xt[i] = vec2(ddecode(Xp[i]),\n                     ddecode(Xq[i]));\n\n        // add noise to each point\n        if (Xt[i].x == Xt[i].y)\n        {\n            Xt[i].x = rand(vec2(iTime-float(i/N)));\n            Xt[i].y = rand(vec2(iTime+float(i/N)));\n        }\n        if (i>0&&Xt[i]==Xt[i-1]){\n            Xt[i] += .1*rand(vec2(iTime-float(i/N)));\n\n    \t}\n        if (i>1&&Xt[i]==Xt[i-2]){\n            Xt[i] -= .1*rand(vec2(iTime-float(i/N)));\n\n    \t}\n        if (i>2&&Xt[i]==Xt[i-3]){\n            Xt[i] -= .2*rand(vec2(iTime-float(i/N)));\n\n    \t}\n        if (i>3&&Xt[i]==Xt[i-4]){\n            Xt[i] -= .3*rand(vec2(iTime-float(i/N)));\n\n    \t}\n\n    }\n\n\t// normalized coord\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // update data blocks\n    if (fragCoord.y<4. && fragCoord.x < 2.*w*float(N))\n    {\n        for (int i=0;i<N;i++)\n        {\n\n            // x values\n            if (fragCoord.x>w*float(2*i)&&fragCoord.x<w*float(2*i+1))\n            {\n                vec2 xm = (Xt[i])*4.-2.;\n                vec2 Xn = att_fn(att_fn(xm + .1*rand(vec2(iTime))));\n                Xn = (Xn+2.)/4.;\n                Xp[i] = dencode(Xn.x);\n                fragColor = (Xp[i]);\n            }\n            // y values\n            else if (fragCoord.x> w*float(2*i+1) && fragCoord.x< w*float(2*i+2))\n            {\n                vec2 xm = (Xt[i])*4.3-2.;\n                vec2 Xn = att_fn(att_fn(xm + .1*rand(vec2(iTime))));\n                Xn = (Xn+2.)/4.3;\n                Xq[i] = dencode(Xn.y);\n                fragColor = (Xq[i]);\n            }\n\t    }\n    }\n    else\n    {\n\n        bool flg = false;\n        vec3 px = vec3(texture(iChannel0,uv)).rgb; // current pixel value\n\n        for (int i=0;i<N;i++)\n        {\n            float at = 0.; // motion angle\n            \n            for(int j=0;j<M;j++){ // compute several points\n\n                // adjust data coordinates\n                vec2 xm = (Xt[i])*4.-2.;\n                \n                // apply function\n                vec2 Xn = att_fn(xm +vec2(.1*rand(vec2(iTime)),.1*rand(vec2(iTime+float(j/M)))));\n                \n                // move data back to 0-1 range\n                Xt[i] = (Xn+2.)/4.;\n\n\t\t\t\t// compute distance of current pixel to computed point\n                float l = length((uv - Xt[i]*vec2(1.0125,.91))*rs);\n\n                // if inside radius color up\n                if(l<rd) {\n                    \n                    vec2 dx = (xm - Xn); // displacement\n\n                    at = at*.5+.5*atan(dx.y/dx.x); // motion angle\n                    float dd = length(dx); // motion distance\n                    \n                    //float h = 1.14 - .8*(at);\n                    \n                    float h = 1.74   - .8*cos(at); // Hue function\n                    \n                    h =  h>1. ? h-1.: h;\n                    \n                    // convert to rgb\n                    vec3 np = (hsv2rgb(vec3(h,.76 - at*dd/5.,.95-dd/6.)));\n                    \n                    // intensity check\n                    if (length(px)< length(np))\n                    {\n                    \tpx = px*.5+np*.5;\n                    }\n                    else\n                    {\n                    \tpx = px*.9+np*.1;                    \n                    }\n                    \n                    flg = true;\n                }\n            }\n        }\n\n        px *=.9876; // fadding\n\n        if (blur_en&&!flg) // blur\n        {\n            px = wt*vec3(texture(iChannel0,uv + vec2( 1./rs.x, 0))).rgb +\n                 wt*vec3(texture(iChannel0,uv + vec2(-1./rs.x, 0))).rgb +\n                 wt*vec3(texture(iChannel0,uv + vec2(0, 1./rs.y))).rgb +\n                 wt*vec3(texture(iChannel0,uv + vec2(0,-1./rs.y))).rgb +\n                (1.-4.*wt-.001)*px;\n\n        }\n\n        fragColor = vec4(px,1.);\n    }\n}\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by OscarMar\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 5)\n    {\n    \tfragColor = vec4(0,0,0,1);\n    }\n\telse\n    {\n    \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \tfragColor = vec4(texture(iChannel0,uv).rgba);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}