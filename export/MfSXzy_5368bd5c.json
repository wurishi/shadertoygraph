{"ver":"0.1","info":{"id":"MfSXzy","date":"1707234930","viewed":56,"name":"RRRLandscape","username":"Mimka","description":"landScape","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 getGridCellIndices(vec3 position, float cellSize) {//there is this stupid space repetition thing because of that we can get the index of a cell dynamically\n    vec2 indices;\n    indices.x = floor(position.x / cellSize);// decides when we go to the fract part\n    indices.y = floor(position.z / cellSize); // Assuming XZ plane is your ground\n    return indices;\n}\n\nfloat getHeightValue(vec2 position, float cellSize)\n{\n    vec2 intIndices = floor(vec2(position.x, position.y)/cellSize);// floor removes the decimal part\n    \n    \n    vec2 medium = fract(intIndices/3.14159265359)*50.0;\n    return 2.0 * fract((medium.x * medium.y) * (medium.x + medium.y)) - 1.0;\n}\n\nvec4 getCornerValues(vec2 indices, float cellSize) {\n    vec2 basePosition = indices * cellSize;\n    \n    float a_ij = getHeightValue(basePosition, cellSize);\n    float b_ij = getHeightValue(basePosition + vec2(cellSize, 0), cellSize);\n    float c_ij = getHeightValue(basePosition + vec2(0, cellSize),cellSize);\n    float d_ij = getHeightValue(basePosition + vec2(cellSize, cellSize),cellSize);\n    \n    return vec4(a_ij, b_ij, c_ij, d_ij);\n}\n\nfloat smoothStep(float a, float b, float x)\n{\n    return min(1.0, max(0.0,(x-a)/(b-a)));\n}\n\nfloat polyFunc(float l)\n{\n    //float l = smoothStep(0.0,1.0, k);\n    return 3.0*(l*l) - 2.0*(l*l*l);\n}\n\nfloat calculateInterpolation(vec4 vertices, vec3 position, float cellSize)\n{\n   \n    vec2 GridIndices = floor(vec2(position.x, position.z) / cellSize);\n    \n\n    float dx = polyFunc((position.x / cellSize) - GridIndices.x);\n    float dz = polyFunc((position.z / cellSize) - GridIndices.y);\n\n    float aij = vertices.x; // Height at the cell's origin corner\n    float bij = vertices.y; // Height at the cell's x-direction corner\n    float cij = vertices.z; // Height at the cell's z-direction corner\n    float dij = vertices.w; // Height at the cell's diagonal corner\n\n    // Correct interpolation logic\n    float hight = aij + (bij - aij) * dx + (cij - aij) * dz + (aij - bij - cij + dij) * dx * dz;\n\n    return hight;\n}\n\n\n\n\nfloat  approximateSDF(vec3 point, float gridSize) {\n    \n    float blendedSurfaceHeight = 0.0;\n    float detailFactor = 2.0;\n    for(int i = 1; i < 7; i++) \n    {\n        vec3 pointTrans = point ;\n        //pointTrans.xz*=detailFactor;\n        pointTrans.xz*=rotate2d(3.14159265359/10.0*float(i));\n        float cellSize = gridSize/detailFactor;\n        vec2 gridIndices = floor(vec2(pointTrans.x, pointTrans.z)/ cellSize);\n        vec4 vertices = getCornerValues(gridIndices, cellSize);\n        float surfaceHeight = calculateInterpolation(vertices, pointTrans, cellSize)/detailFactor;\n        blendedSurfaceHeight += surfaceHeight;\n        detailFactor *= 2.0;\n        \n    }\n\n    float verticalDistance = point.y - blendedSurfaceHeight;\n    \n    return verticalDistance;\n}\n\n\nvec3 calculateNormal(vec3 position, float epsilon, float cellSize) {\n    vec3 dx = vec3(epsilon, 0.0, 0.0);\n    vec3 dy = vec3(0.0, epsilon, 0.0);\n    vec3 dz = vec3(0.0, 0.0, epsilon);\n\n    // Recalculate the SDF for slightly offset positions in each dimension\n    float sdfXPlus = approximateSDF(position + dx, cellSize);\n    float sdfXMinus = approximateSDF(position - dx, cellSize);\n    float sdfYPlus = approximateSDF(position + dy, cellSize);\n    float sdfYMinus = approximateSDF(position - dy, cellSize);\n    float sdfZPlus = approximateSDF(position + dz, cellSize);\n    float sdfZMinus = approximateSDF(position - dz, cellSize);\n    \n    // Derivative in x direction\n    float df_dx = (approximateSDF(position + vec3(epsilon, 0.0, 0.0), cellSize) - approximateSDF(position - vec3(epsilon, 0.0, 0.0), cellSize)) / (2.0 * epsilon);\n\n    // Derivative in z direction\n    float df_dz = (approximateSDF(position + vec3(0.0, 0.0, epsilon), cellSize) - approximateSDF(position - vec3(0.0, 0.0, epsilon), cellSize)) / (2.0 * epsilon);\n\n    // Compute the gradient (normal) using central difference\n    //vec3 normal = normalize(vec3(sdfXPlus - sdfXMinus, sdfYPlus - sdfYMinus, sdfZPlus - sdfZMinus) / (2.0 * epsilon));\n\n    return normalize(vec3(-df_dx, 1.0 ,-df_dx))+approximateSDF(position, 5.0);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);// mix is an interpolation but for vectors\n}\n\nfloat dist(vec3 p)\n{\n    \n    return  approximateSDF(p, 5.0);\n    //return sdPlane(p, vec3(1.0,0.0,0.0), 0.1);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1) and put the center in the middle\n    vec2 uv = fragCoord/iResolution.xy*2.0f - 1.0f;\n    uv.x*=(iResolution.x/iResolution.y);\n    \n    // mouse\n     vec2 mouse = iMouse.xy/iResolution.xy*2.0f - 1.0f;// can be scaled for sensitivity\n    \n    // initialization \n    vec3 rayOrigin = vec3(0.0,0.0,-3.0);\n    // also uv * 1.5 makes the field of view bigger\n    vec3 rayDirection = normalize(vec3(uv, 1.0));// this will spread the vectors from the origin to each point on the screen\n    \n    // rotate the coordinates vertically\n    rayOrigin.yz *= rotate2d(-mouse.y);\n    rayDirection.yz *= rotate2d(-mouse.y);\n    \n    // rotate the coordinates horizontally\n    rayOrigin.xz *= rotate2d(-mouse.x);\n    rayDirection.xz *= rotate2d(-mouse.x);\n    \n    vec3 finalColor = vec3(0);// final pixel color\n    \n    float totalDistance = 0.0;// total distance travelled\n    vec3 normal;\n    for(int i = 0; i < 80; i++)\n    {\n        vec3 positionAlongRay = rayOrigin + rayDirection*totalDistance; // distance traveled along the ray\n        float distToObject = dist( positionAlongRay);\n        if(distToObject<10.0)\n        \n        normal = calculateNormal(positionAlongRay, 0.00001, 5.0);\n        \n        totalDistance += distToObject;// steps along the ray by the safe distance to travel\n        if(distToObject<0.001 || distToObject>100.0)// early stop if close enough \n        {\n            break;\n        }\n        \n        \n        \n    }// it is calculted for the current closest object\n    \n    //normal.yz *= rotate2d(-mouse.y);\n    //normal.xz *= rotate2d(-mouse.x);\n    \n    vec3 light = normalize(vec3(0.0,0.0,1.0));\n    float lightFactor = dot(light, normal);\n    \n    finalColor = vec3(totalDistance * 0.1) * lightFactor;\n    \n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct SDFCalcs {\n    float dist;\n    vec3 normal;\n};","name":"Common","description":"","type":"common"}]}