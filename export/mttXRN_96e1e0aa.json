{"ver":"0.1","info":{"id":"mttXRN","date":"1685115398","viewed":161,"name":"Avatar ray marching","username":"Irec","description":"ray marching example","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","avatar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define detail  0.075\n#define pi      3.14159265359\n#define MODEL_ROTATION  vec2(.3, .25)\n#define CAMERA_ROTATION vec2(.5, .5)\n\n// 0: Defaults\n// 1: Model\n// 2: Camera\n#define MOUSE_CONTROL 1\n\nvec3 vec3_1 = vec3(-2.0, -1.5,  -0.5);\nvec3 vec3_2 = vec3( 0.5, -0.05, -0.5);\nvec3 vec3_3 = vec3( 0.5,  1.0,   0.5);\nvec3 vec3_4 = vec3( 1.0,  1.0,   1.0);\nvec4 vec4_5 = vec4( 0.0,  0.0,   0.0,   0.0);\nvec3 vec3_6 = vec3( 0.0, -0.7,  -20.0);\n\nvec3 yxx    = vec3(detail,    0.0,    0.0);\nvec3 xyx    = vec3(   0.0, detail,    0.0);\nvec3 xxy    = vec3(   0.0,    0.0, detail);\n\nint   Iterations;\nfloat Scale;\nvec3  Julia;\nvec3  RotVector;\nfloat RotAngle;\nfloat Speed;\nfloat Amplitude;\nvec3  lightdir;\nmat2  rot;\nvec3  from;\nfloat time;\nmat3  rot2;\nfloat t6;\n\nvec3  ani;\nfloat sinA,cosA;\nfloat st;\nmat3  m;\nfloat a;\n\n//======================================================================\nmat3 rotationMatrix3( vec3 v, float angle )\n{\n  float c = cos(radians(angle));\n  float s = sin(radians(angle));\n  float g = 1.0 - c;\n\n  return mat3(c + g*v.x*v.x,      g*v.x*v.y - s*v.z,    g*v.x*v.z + s*v.y,\n              g*v.x*v.y + s*v.z,  c + g*v.y*v.y,        g*v.y*v.z - s*v.x,\n              g*v.x*v.z - s*v.y,  g * v.y*v.z + s*v.x,  c + g*v.z*v.z);\n}\n\n//======================================================================\nfloat de(vec3 p)\n{\n  p    = p.zxy;\n\n  //p.xy = p.xy * m;\n  p *= m;\n  p.x  = p.x * 0.75;\n\n  // p   = p + (sin(p * 3.0 + time * .06) * 0.04);\n  p.x   = p.x + (sin(p.x * 3.0 + t6) * 0.04);\n  p.y   = p.y + (sin(p.y * 3.0 + t6) * 0.04);\n  p.z   = p.z + (sin(p.z * 3.0 + t6) * 0.04);\n\n  vec3 pp = p;\n\n  for (int i = 0; i < Iterations; i++)\n  {\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p   = p * Scale + Julia;\n    p   = p * rot2;\n  }\n\n  return length(p) * pow(Scale, -float(Iterations)) * 0.9;\n}\n\n//======================================================================\nvec3 normal(vec3 p)\n{\n  vec3 rs;\n  rs.x = de(p + yxx) - de(p - yxx);\n  rs.y = de(p + xyx) - de(p - xyx);\n  rs.z = de(p + xxy) - de(p - xxy);\n  \n  return normalize(rs);\n}\n\n//======================================================================\nfloat softshadow( vec3 ro, vec3 rd, float mint, float k )\n{\n  float h;\n  float res = 1.0;\n  float t   = mint;\n  for (int i = 0; i < 48; i++)\n  {\n    h   = de(ro + rd * t);\n    h   = max(h, 0.0);\n    res = min(res, k * h / t);\n    t   += clamp(h, 0.01, 0.5);\n  }\n\n  return clamp(res, 0.0, 1.0);\n}\n\n//======================================================================\nvec4 light( vec3 p, vec3 dir, float d )\n{\n  vec3  ldir    = normalize(lightdir);\n  vec3  n       = normal(p);\n  float sh      = softshadow(p, -ldir, 1.0, 20.0);\n  float diff    = max(0.0, dot(ldir, -n));\n  vec3  r       = reflect(ldir, n);\n  float spec    = max(0.0, dot(dir, -r));\n  vec3  ray     = 0.8 * d * ((0.4*p - 3.0*r) + d * vec3_4);\n  vec4 lightCol = texture(iChannel0, ray.xz + ray.xy);\n  \n  return 3.0*lightCol*diff*sh + pow(spec, 30.0)*0.5*sh + 0.15*max(0.0, dot(normalize(dir), -n));\n}\n\n//======================================================================\nvec4 raymarch( vec3 from, vec3 dir )\n{\n  vec3 p;\n  vec4 col;\n\n  float d       = 1.0;\n  float totdist = 0.0;\n\n  for (int i = 0; i < 30; i ++)\n  {\n    if (d > detail) \n      if (totdist < 150.0)\n      {\n        p = from + totdist * dir;\n        d = de(p);\n        totdist += d;\n      }\n  }\n\n  vec4 backg = vec4_5;\n  if (d < detail)\n  {\n    col = light(p, dir, d);\n  }\n  else\n  {\n    col = backg;\n  }\n\n  //col = mix(col, backg, 1.0-exp(-0.000025*pow(totdist,3.5)));\n  return col;\n}\n\n//https://www.shadertoy.com/view/llVXRd\nmat3 sphericalMatrix(float theta, float phi) \n{\n   float cx = cos(theta);\n   float cy = cos(phi);\n   float sx = sin(theta);\n   float sy = sin(phi);\n   return mat3(cy, -sy*-sx, -sy*cx,\n                0,      cx,  sx,\n               sy,  cy*-sx, cy*cx);\n}\n\n\nmat3 mouseRotation(bool enable, vec2 xy) \n{\n  if (enable) \n  {\n     vec2 mouse = iMouse.xy / iResolution.xy;\n\n     if (mouse.x != 0. && mouse.y != 0.) \n     {\n        xy.x = mouse.x;\n        xy.y = mouse.y;\n     }\n  }\n  float rx, ry;\n    \n  rx = (xy.y + .5)*pi;\n  ry = (-xy.x)*2. *pi;\n    \n  return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() \n{\n  return mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n}\n\n//======================================================================\nvoid PrepareFrame()\n{\n  Iterations = 16;\n  Scale      = 1.27;\n  Julia      = vec3_1;\n  RotVector  = vec3_2;\n  RotAngle   = 145.0;\n  Speed      = 1.3;\n  Amplitude  = 0.25;\n  lightdir   = -vec3_3;\n  \n  rot     = mat2(cos(-0.5), sin(-0.5), -sin(-0.5), cos(-0.5));\n  from    = vec3_6;\n  from.yz = from.yz * rot;\n\n  t6 = time * 6.0;\n\n  a    = 1.5 + sin(iTime * 0.5) * 0.5;\n  sinA = sin(a);\n  cosA = cos(a);\n  m    = mat3(cosA, sinA, 0., -sinA, cosA, 0., 0., 0., 1.)*modelRotation();\n  time = iTime * Speed;\n\n  st   = sin(time);\n  \n  \n  ani  = vec3(st, st, cos(time)) * Amplitude;\n  rot2 = rotationMatrix3(normalize(RotVector + ani), RotAngle + st * 10.0);\n}\n\n//======================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    PrepareFrame();\n    \n    vec2 uv  = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y     = uv.y * (iResolution.y /iResolution.x);\n    vec3 dir = normalize(vec3(uv * 0.7, 1.0));\n    dir.yz   = dir.yz * rot;\n\n    fragColor = raymarch(from, dir);\n}","name":"Image","description":"","type":"image"}]}