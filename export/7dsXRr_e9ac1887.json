{"ver":"0.1","info":{"id":"7dsXRr","date":"1618238484","viewed":453,"name":"Neon Raymarch","username":"boris159","description":"Neon raymarching","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 32.0\n#define MAX_STEPS 128\n#define REPEAT 2.0\n#define BLOOM_DEPTH 16.0;\n#define BLOOM_IT 128\n#define ANG 7.5\n\nfloat seed;\n\nfloat rand()\n{\n    seed += 0.15342;\n    return fract(sin(seed) * 35423.7652344);\n}\n\nmat2 rot(float ang)\n{\n    float s = sin(ang);\n    float c = cos(ang);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotVec(vec3 p, vec3 r)\n{\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nvec3 makeRay(vec2 origin)\n{\n    vec2 res;\n    res.x = origin.x - iResolution.x * 0.5;\n    res.y = origin.y - iResolution.y * 0.5;\n    return normalize(vec3(res / iResolution.yy, 0.5));\n}\n\nfloat capsule(vec3 a, vec3 b, float r, vec3 p)\n{\n    vec3 pa = p - a, ba = b - a;\n  \tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  \treturn length(pa - ba * h) - r;\n}\n\nvec3 dirByAng(float deg, float mag)\n{\n    float rad = deg * PI / 180.0;\n    return vec3(sin(rad), cos(rad), 0) * mag;\n}\n\nfloat getDist(vec3 origin)\n{\n    float ang = origin.z / REPEAT * ANG - ANG;\n    origin.z = mod(origin.z + REPEAT * 0.5, REPEAT) - REPEAT * 0.5;\n    \n    vec3 a = dirByAng(0.0 + ang, 1.0);\n    vec3 b = dirByAng(120.0 + ang, 1.0);\n    vec3 c = dirByAng(240.0 + ang, 1.0);\n    \n    float cap1 = capsule(a, b, 0.01, origin);\n    float cap2 = capsule(b, c, 0.01, origin);\n    float cap3 = capsule(c, a, 0.01, origin);\n    return min(cap1, min(cap2, cap3));\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat rayMarch(vec3 origin, vec3 direct)\n{\n    float res = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 tmp = origin + direct * res;\n        float d = getDist(tmp);\n        res += d;\n        \n        if (res >= MAX_DIST || d < EPSILON)\n        \tbreak;\n    }\n\n    return res;\n}\n\nvec3 getCol(float z)\n{\n    float fac = (cos(z / REPEAT * PI) + 1.0) * 0.5;\n    return mix(vec3(1, 0.1, 0.25), vec3(0.25, 0.1, 1), fac);\n}\n\nvec3 getBloom(vec3 pos, vec3 dir)\n{\n    vec3 res = vec3(0);\n    vec3 end = pos + dir * BLOOM_DEPTH;\n    \n    for (int i = 0; i < BLOOM_IT; i++)\n    {\n        float fac = (float(i) + rand()) / float(BLOOM_IT);\n        vec3 p = mix(pos, end, fac);\n        float d = getDist(p);\n        res += getCol(p.z) / d / float(BLOOM_IT);\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 pos = vec3(0, 0, iTime * 2.0);\n    vec3 dir = makeRay(fragCoord);\n    dir = rotVec(dir, vec3(0, 0, -(pos.z / REPEAT * ANG * PI / 180.0)));\n    \n    float res = rayMarch(pos, dir);\n    vec3 col = getBloom(pos, dir);\n    \n    if (res < MAX_DIST)\n        col = vec3(1);\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}