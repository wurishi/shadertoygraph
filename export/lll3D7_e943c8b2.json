{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const bool mustScaleToFit = true;\n\nconst float TAU = 6.28318530717958647692528676655900576839433879875021;\n\nconst int BILINEAR_RESAMPLING = 1;\nconst int MITCHELL_NETRAVALLI_RESAMPLING = 2;\nconst int LANCZOS3_RESAMPLING = 3;\n\n// compatibility to GLSL 1.50\nvec4 m_texture(sampler2D sampler, vec2 uv)\n{\n    return texture(sampler, uv);\n}\n\nvec2 m_round(vec2 v)\n{\n    return floor(v + 0.5);\n}\n\nfloat mitchellNetravali(float x)\n{\n        float ax = abs(x);\n        if (ax < 1.0) {\n                return 7.0*ax*ax*ax\n                       - 12.0*ax*ax\n                       + 16.0/3.0;\n        } else if (ax >= 1.0 && ax < 2.0) {\n                return -7.0/3.0 * ax*ax*ax\n                       + 12.0 * ax*ax\n                       + -20.0 * ax\n                       + 32.0/3.0;\n        }\n\n        return 0.0;\n}\n\nfloat lanczos3(float x)\n{\n        const float radius = 3.0;\n\n        float ax = abs(x);\n        if (x == 0.0) {\n                return 1.0;\n        }\n\n        if (ax > radius) {\n                return 0.0;\n        }\n\n        float pix = TAU * ax / 2.0;\n\n\n        return sin(pix) * sin(pix / radius) / (pix * pix);\n}\n\n// kernel summer for a 3x3 matrix\nvec4 kernel3(sampler2D sampler, vec3 x3, vec3 linetaps, vec3 y3,\n             vec3 columntaps)\n{\n        return columntaps.r * (m_texture(sampler, vec2(x3.r, y3.r)) * linetaps.r +\n                               m_texture(sampler, vec2(x3.g, y3.r)) * linetaps.g +\n                               m_texture(sampler, vec2(x3.b, y3.r)) * linetaps.b) +\n               columntaps.g * (m_texture(sampler, vec2(x3.r, y3.g)) * linetaps.r +\n                               m_texture(sampler, vec2(x3.g, y3.g)) * linetaps.g +\n                               m_texture(sampler, vec2(x3.b, y3.g)) * linetaps.b) +\n               columntaps.b * (m_texture(sampler, vec2(x3.r, y3.b)) * linetaps.r +\n                               m_texture(sampler, vec2(x3.g, y3.b)) * linetaps.g +\n                               m_texture(sampler, vec2(x3.b, y3.b)) * linetaps.b)\n               ;\n}\n\n// kernel summer for a 4x4 matrix\nvec4 kernel4(sampler2D sampler, vec4 x4, vec4 linetaps, vec4 y4,\n             vec4 columntaps)\n{\n        return columntaps.r * (m_texture(sampler, vec2(x4.r, y4.r)) * linetaps.r +\n                               m_texture(sampler, vec2(x4.g, y4.r)) * linetaps.g +\n                               m_texture(sampler, vec2(x4.b, y4.r)) * linetaps.b +\n                               m_texture(sampler, vec2(x4.a, y4.r)) * linetaps.a) +\n               columntaps.g * (m_texture(sampler, vec2(x4.r, y4.g)) * linetaps.r +\n                               m_texture(sampler, vec2(x4.g, y4.g)) * linetaps.g +\n                               m_texture(sampler, vec2(x4.b, y4.g)) * linetaps.b +\n                               m_texture(sampler, vec2(x4.a, y4.g)) * linetaps.a) +\n               columntaps.b * (m_texture(sampler, vec2(x4.r, y4.b)) * linetaps.r +\n                               m_texture(sampler, vec2(x4.g, y4.b)) * linetaps.g +\n                               m_texture(sampler, vec2(x4.b, y4.b)) * linetaps.b +\n                               m_texture(sampler, vec2(x4.a, y4.b)) * linetaps.a) +\n               columntaps.a * (m_texture(sampler, vec2(x4.r, y4.a)) * linetaps.r +\n                               m_texture(sampler, vec2(x4.g, y4.a)) * linetaps.g +\n                               m_texture(sampler, vec2(x4.b, y4.a)) * linetaps.b +\n                               m_texture(sampler, vec2(x4.a, y4.a)) * linetaps.a)\n               ;\n}\n\n// MITCHELL - NETRAVALI\n// -------------------\n//\n// General form:\n//\n// k(x) = 1/6 times\n//    { (12 - 9B -6C)*abs(x)^3 + (-18 +12B + 6C)*abs(x)^2 + (6 - 2B) } if abs(x) < 1\n//    { (-B-6C)abs(x)^3 + (6B+30C)abs(x)^2 + (-12B-48C)abs(x) + (8B+24C) } if abs(x) in [1..2(\n//    { 0 } otherwise\n//\n// and with B = C = 1/3\n//\n// k(x) = 1/6 times\n//    { 7*|x|^3 + -20*|x|^2 + 16/3} if |x| < 1\n//    { -7/3*|x|^3 + 12*|x|^2 + -20*|x| + 32/3 | if |x| in [1..2[\n//    { 0 } otherwise\n//\nvec4 sampleWithMitchellNetravali(sampler2D sampler, vec2 samplerSize,\n                                 vec2 stepxy, vec2 uv)\n{\n        vec2 texel = 1.0 / samplerSize;\n\n        vec2 texelPos = samplerSize * uv;\n        vec2 bottomLeftTexelPos = floor(texelPos - vec2(0.5)) + vec2(0.5);\n\n        vec4 xpos = vec4(\n                            (bottomLeftTexelPos.x - 1.0) * texel.x,\n                            (bottomLeftTexelPos.x + 0.0) * texel.x,\n                            (bottomLeftTexelPos.x + 1.0) * texel.x,\n                            (bottomLeftTexelPos.x + 2.0) * texel.x\n                    );\n\n        vec4 ypos = vec4(\n                            (bottomLeftTexelPos.y - 1.0) * texel.y,\n                            (bottomLeftTexelPos.y + 0.0) * texel.y,\n                            (bottomLeftTexelPos.y + 1.0) * texel.y,\n                            (bottomLeftTexelPos.y + 2.0) * texel.y\n                    );\n\n        vec2 f = texelPos - bottomLeftTexelPos;\n        if (f.x >= 1.0 || f.y >= 1.0 || f.x < 0.0 || f.y < 0.0) {\n                return vec4(1.0, 0.0, 0.0, 0.0);\n        }\n\n        vec2 speed = min(vec2(1.0), texel / stepxy);\n        vec4 linetaps = vec4(mitchellNetravali(speed.x*(-1.0 - f.x)),\n                             mitchellNetravali(speed.x*(0.0-f.x)),\n                             mitchellNetravali(speed.x*(1.0-f.x)),\n                             mitchellNetravali(speed.x*(2.0-f.x))\n                            );\n        linetaps /= dot(linetaps, vec4(1.0));\n        vec4 columntaps = vec4(mitchellNetravali(speed.y*(-1.0 - f.y)),\n                               mitchellNetravali(speed.y*(0.0-f.y)),\n                               mitchellNetravali(speed.y*(1.0-f.y)),\n                               mitchellNetravali(speed.y*(2.0-f.y))\n                              );\n        columntaps /= dot(columntaps, vec4(1.0));\n\n        return kernel4(sampler, xpos, linetaps, ypos, columntaps);\n}\n\n// LANCZOS 3 INTERPOLATION\n// ---------------------\n//\nvec4 sampleWithLanczos3Interpolation(sampler2D sampler, vec2 samplerSize,\n                                     vec2 stepxy, vec2 uv)\n{\n        vec2 texel = 1.0 / samplerSize;\n        vec2 texelPos = uv / texel;\n        vec2 bottomLeftTexelPos = floor(texelPos - vec2(0.5)) + vec2(0.5);\n\n        vec3 x0_2 = vec3(\n                            (bottomLeftTexelPos.x - 2.0) * texel.x,\n                            (bottomLeftTexelPos.x - 1.0) * texel.x,\n                            (bottomLeftTexelPos.x + 0.0) * texel.x\n                    );\n        vec3 x3_5 = vec3(\n                            (bottomLeftTexelPos.x + 1.0) * texel.x,\n                            (bottomLeftTexelPos.x + 2.0) * texel.x,\n                            (bottomLeftTexelPos.x + 3.0) * texel.x\n                    );\n\n        vec3 y0_2 = vec3(\n                            (bottomLeftTexelPos.y - 2.0) * texel.y,\n                            (bottomLeftTexelPos.y - 1.0) * texel.y,\n                            (bottomLeftTexelPos.y + 0.0) * texel.y\n                    );\n        vec3 y3_5 = vec3(\n                            (bottomLeftTexelPos.y + 1.0) * texel.y,\n                            (bottomLeftTexelPos.y + 2.0) * texel.y,\n                            (bottomLeftTexelPos.y + 3.0) * texel.y\n                    );\n\n        vec2 f = texelPos - bottomLeftTexelPos;\n        vec2 speed = min(vec2(1.0), texel / stepxy);\n        vec3 ltaps0_2 = vec3(\n                                lanczos3(speed.x*(-2.0 - f.x)),\n                                lanczos3(speed.x*(-1.0 - f.x)),\n                                lanczos3(speed.x*(0.0 - f.x))\n                        );\n        vec3 ltaps3_5 = vec3(\n                                lanczos3(speed.x*(1.0 - f.x)),\n                                lanczos3(speed.x*(2.0 - f.x)),\n                                lanczos3(speed.x*(3.0 - f.x))\n                        );\n        float lsum = dot(ltaps0_2, vec3(1)) + dot(ltaps3_5, vec3(1));\n\n        ltaps0_2 /= lsum;\n        ltaps3_5 /= lsum;\n\n        vec3 coltaps0_2 = vec3(\n                                  lanczos3(speed.y*(-2.0 - f.y)),\n                                  lanczos3(speed.y*(-1.0 - f.y)),\n                                  lanczos3(speed.y*( 0.0 - f.y))\n                          );\n        vec3 coltaps3_5 = vec3(\n                                  lanczos3(speed.y*(1.0 - f.y)),\n                                  lanczos3(speed.y*(2.0 - f.y)),\n                                  lanczos3(speed.y*(3.0 - f.y))\n                          );\n        float csum = dot(coltaps0_2, vec3(1.0)) + dot(coltaps3_5, vec3(1.0));\n\n        coltaps0_2 /= csum;\n        coltaps3_5 /= csum;\n\n        return kernel3(sampler, x0_2, ltaps0_2, y0_2, coltaps0_2) +\n               kernel3(sampler, x3_5, ltaps3_5, y0_2, coltaps0_2) +\n               kernel3(sampler, x0_2, ltaps0_2, y3_5, coltaps3_5) +\n               kernel3(sampler, x3_5, ltaps3_5, y3_5, coltaps3_5);\n}\n\n// LINEAR INTERPOLATION\n// -------------------\n//\n//\n// This is done by hand here to demonstrate the algorithm and\n// highlight the coordinate system used by OpenGL by default.\n//\n// You would normally just configure the texture to GL_LINEAR\n// interpolation\n//\nvec4 sampleWithBilinearInterpolation(sampler2D sampler, vec2 samplerSize,\n                                     vec2 uv)\n{\n        vec2 texel = 1.0 / samplerSize;\n        vec2 texelPos = samplerSize * uv;\n\n        // we get the position of the texel. Watch out that\n        // texels start at the center of a position (hence the 0.5)\n        vec2 bottomLeftTexelPos = floor(texelPos - vec2(0.5)) + vec2(0.5);\n\n        vec4 bl = texture(sampler, (bottomLeftTexelPos + vec2(0.0, 0.0)) * texel);\n        vec4 br = texture(sampler, (bottomLeftTexelPos + vec2(1.0, 0.0)) * texel);\n        vec4 tl = texture(sampler, (bottomLeftTexelPos + vec2(0.0, 1.0)) * texel);\n        vec4 tr = texture(sampler, (bottomLeftTexelPos + vec2(1.0, 1.0)) * texel);\n\n        vec2 fractFromBottomLeftTexelPos = texelPos - bottomLeftTexelPos;\n        if (fractFromBottomLeftTexelPos.x > 1.0) {\n                return vec4(1.0, 0.0, 0.0, 0.0);\n        }\n        if (fractFromBottomLeftTexelPos.y > 1.0) {\n                return vec4(1.0, 0.0, 0.0, 0.0);\n        }\n\n        vec4 tA = mix(bl, br, fractFromBottomLeftTexelPos.x);\n        vec4 tB = mix(tl, tr, fractFromBottomLeftTexelPos.x);\n        return mix(tA, tB, fractFromBottomLeftTexelPos.y);\n}\n\n// NEAREST NEIGHBOR LOOKUP\n// ----------------------\n//\n// Normally you would just look up the nearest sample in the texture\n//\n// return texture(sampler, uv);\n//\n// We here show what OpenGL does internally\n//\nvec4 sampleWithNearestNeighbor(sampler2D sampler, vec2 samplerSize, vec2 uv)\n{\n        vec2 nearestTexelPos = m_round(samplerSize * uv - vec2(0.5)) + vec2(0.5);\n        return m_texture(sampler, nearestTexelPos / samplerSize);\n}\n\n// draw a square between r0 and r1 in the given fillColor over the\n// fragment at pixelPos and whose current color is fragmentColor\nvec4 drawSquare(float r0, float r1, vec4 fillColor, vec2 pixelPos,\n                vec4 fragmentColor)\n{\n        if (step(pixelPos, r0*vec2(1.0)) == vec2(0.0)\n            && step(pixelPos, r1*vec2(1.0)) == vec2(1.0)) {\n                return fillColor;\n        }\n        return fragmentColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        // NOTE(nicolas) we are assuming below that the input\n        // photo/picture has a pixel aspect ratio equals to that of\n        // our display.\n        vec2 screenCenterFragCoord = vec2(iResolution.x/2.0,\n                                          iResolution.y/2.0);\n        vec2 fragCoordFromCenter = fragCoord.xy - screenCenterFragCoord;\n\n        vec2 iChannel0Size = iChannelResolution[0].xy;\n        vec2 uvPerFragCoord = 1.0 / iChannel0Size;\n\n        int interpolationMethod = LANCZOS3_RESAMPLING;\n        if (mustScaleToFit) {\n                // scale photo so that at least one of its dimensions occupies the screen\n                float xs = iChannel0Size.x / iResolution.x;\n                float ys = iChannel0Size.y / iResolution.y;\n\n                float speed = max(xs, ys);\n                if (speed == 1.0) {\n                        interpolationMethod = LANCZOS3_RESAMPLING;\n                } else if (speed > 1.0) {\n                        // use mitchell netravalli when downsampling, as it softens a bit more\n                        interpolationMethod = MITCHELL_NETRAVALLI_RESAMPLING;\n                } else if (speed < 1.0) {\n                        interpolationMethod = LANCZOS3_RESAMPLING;\n                }\n\n                uvPerFragCoord = speed / iChannel0Size;\n        }\n\n        // compute uv so the photo is centered\n        vec2 uvAtCenter = vec2(0.5, 0.5);\n        vec2 uv = uvAtCenter + vec2(1.0, -1.0) * uvPerFragCoord * fragCoordFromCenter;\n    \n    \tif (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n        \treturn;\n    \t}\n    \n        vec4 color;\n        if (interpolationMethod == MITCHELL_NETRAVALLI_RESAMPLING) {\n                color = sampleWithMitchellNetravali(iChannel0, iChannel0Size, uvPerFragCoord,\n                                                    uv);\n                color = drawSquare(8.0, 32.0, vec4(1.0, 0.4, 0.2, 0.0), fragCoord.xy, color);\n        } else if (interpolationMethod == LANCZOS3_RESAMPLING) {\n                color = sampleWithLanczos3Interpolation(iChannel0, iChannel0Size,\n                                                        uvPerFragCoord, uv);\n                color = drawSquare(8.0, 32.0, vec4(0.2, 0.7, 0.2, 0.0), fragCoord.xy, color);\n        } else if (interpolationMethod == BILINEAR_RESAMPLING) {\n                color = sampleWithBilinearInterpolation(iChannel0, iChannel0Size, uv);\n                color = drawSquare(8.0, 32.0, vec4(0.0, 0.8, 0.72, 0.0), fragCoord.xy,\n                                   color);\n        } else {\n                color = sampleWithNearestNeighbor(iChannel0, iChannel0Size, uv);\n        }\n\n        fragColor = color;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lll3D7","date":"1422702755","viewed":520,"name":"draw_image","username":"neqkk","description":"a downsampling/upsampling shader to scale textures/pictures","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lanczos3","mitchell","netravali"],"hasliked":0,"parentid":"","parentname":""}}