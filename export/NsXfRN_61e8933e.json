{"ver":"0.1","info":{"id":"NsXfRN","date":"1644533650","viewed":111,"name":"Triangle_Circles_2d","username":"gPlatl","description":"The three bisectors of a triangle meet at a single point which is the center of the inscribed triangle circle.\nThis version calculate additional circle radii & draw inscribed and circumscribed circle!\n\nQ: Can TriangleOutCircle() calculation be optimized?","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","triangle","circle","center","circumcircle","incircle","bisectors","outcircle","circlecenter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Triangle Incircle\" by iq. https://shadertoy.com/view/wtVyDz\n// The MIT License, Copyright Â© 2021 Inigo Quilez\n//---------------------------------------------------------------------\n// Shader: https://www.shadertoy.com/view/NsXfRN \n//---------------------------------------------------------------------\n// Triangle_Circles_2d.glsl  by Gerd Platl\n//   v1.0  2022-02-10  initial release\n//   v1.1  2022-02-11  calculation optimized by pyBlob\n//   v1.2  2022-02-12  added circumCircle() by oneshade\n//   v1.3  2022-02-14  added circumcenter Wikipedia\n//   v1.4  2023-02-01  current state\n// The three bisectors of a triangle meet at a single point which is \n// the center of the inscribed triangle circle.\n// This version calculate additional circle radii, an inscribed circle\n// and 4 variants of a circumscribed circle!\n// Ref.: https://www.cuemath.com/geometry/incenter/\n//---------------------------------------------------------------------\n\n// 2d & 3d squared vector: sqr(v) = v^2 = v.v = dot(v,v)\n#define sqr(v) dot(v,v)\n\n// 2d determinant\nfloat det (in vec2 u, in vec2 v) { return u.x * v.y - u.y * v.x; }\n\n//------------------------------\n// get triangle inCircle\n// in:     triangle A,B,C\n// out:    r = inCircleRadius\n// return: M = inCircleCenter \n//------------------------------\nvec2 TriangleInCircle (in vec2 A, in vec2 B, in vec2 C, out float r)\n{\n  vec2 u = B - A;            // u = A->B\n  vec2 v = C - B;            // v = B->C\n  vec2 w = A - C;            // w = C->A\n  float i = length(v);       // i = |v|\n  float j = length(w);       // j = |w|\n  float k = length(u);       // k = |u|\n  float d = i + j + k;       // triangle perimeter \n  r = abs(det(v,w))/d;       // inCircleRadius\n  return (i*A +j*B +k*C)/d;  // inCircleCenter\n}\n//------------------------------\n// get triangle inCircle radius\n//------------------------------\nvec2 TriangleIncenter (in vec2 A, in vec2 B, in vec2 C)\n{\n  float i = length(C-B);     // k = B->C\n  float j = length(A-C);     // j = C->A\n  float k = length(B-A);     // i = A->B\n  return (A*i +B*j +C*k) / (i+j+k);\n}\n\n//------------------------------\n// get triangle outCircle\n// in:     triangle A,B,C\n// out:    r = outCircleRadius\n// return: M = outCircleCenter \n//------------------------------\nbool TriangleOutCircle1 (in vec2 A, in vec2 B, in vec2 C,\n                        out vec2 M, out float r)\n{\n  vec2 u = B - A;                // u = A->B\n  vec2 v = C - A;                // v = A->C\n  float u2 = dot(u,u);           // u2 = u^2\n  float v2 = dot(v,v);           // v2 = v^2\n  float uv = dot(u,v);           // uv = u.v\n  float d = u2 * v2 - uv * uv;   // determinant\n  d = 0.5 / d;                   // calculate M and r\n  float k = v2 * (u2 - uv)*d;    // k = v^2 * (u^2 - u.v) * d\n  float l = u2 * (v2 - uv)*d;    // l = u^2 * (v^2 - u.v) * d\n  vec2 w = k*u + l*v;            // calculate w  \n  M = A + w;                     // get circle center\n  r = length(w);                 // r = |w|\n  return (abs(d) > 1E-6);        // result = (d<>0)\n}\n\n//------------------------------\n// optimized variant 2\n//------------------------------\nbool TriangleOutCircle2 (in vec2 A, in vec2 B, in vec2 C,\n                         out vec2 M, out float r)\n{\n  vec2 u = B - A;                // u = A->B\n  vec2 v = C - A;                // v = A->C\n  float d = 2.*(u.x*v.y-u.y*v.x);// determinant\n  float u2 = dot(u,u);           // u2 = u^2\n  float v2 = dot(v,v);           // v2 = v^2\n  vec2 w = (u*v2 - v*u2) / d;    // calculate w\n  M = A + vec2(-w.y, +w.x);      // get circle center\n  r = length(w);                 // r = |w|\n  return abs(d) > 2e-6;          // result = (d<>0)  \n}\n//------------------------------\n// variant based on @oneshade\n//------------------------------\nbool TriangleOutCircle3 (in vec2 A, in vec2 B, in vec2 C,\n                        out vec2 M, out float r)\n{ vec2\n  u = B - A,             \n  v = C - A,\n  w = C - B,\n  n = vec2(-u.y, u.x),   // perpendicular vector \n  m = 0.5 * (u + n * dot(v, w) / dot(n, w));\n  M = A + m;\n  r = length(m);\n  return abs(dot(n, w)) > 1E-6;\n}\n//------------------------------\n// https://en.wikipedia.org/wiki/Circumscribed_circle#Cartesian_coordinates_2\n//------------------------------\nbool TriangleOutCircle (in vec2 A, in vec2 B, in vec2 C,\n                        out vec2 M, out float r)\n{ vec2 u = B - A;             \n  vec2 v = C - A;\n  float u2 = dot(u,u);\n  float v2 = dot(v,v);\n  float d = 2.*(u.x*v.y - u.y*v.x);\n  vec2 m = vec2 (v.y*u2 - u.y*v2\n                ,u.x*v2 - v.x*u2) / d;\n  M = A + m;\n  r = length(m);\n  return abs(d) > 1E-6;\n}\n\n//=====================================================\n\n// signed distance to a disk\nfloat sdDisk( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c)-r;\n}\n\n// distance to a 2d line segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n// signed distance to a 2D triangle\nfloat sdTriangle (in vec2 A, in vec2 B, in vec2 C, in vec2 P)\n{\n  vec2 u = B-A;   vec2 a = P-A;\n  vec2 v = C-B;   vec2 b = P-B;\n  vec2 w = A-C;   vec2 c = P-C;\n\n  vec2 q0 = a - u*clamp( dot(a,u)/sqr(u), 0.0, 1.0);\n  vec2 q1 = b - v*clamp( dot(b,v)/sqr(v), 0.0, 1.0);\n  vec2 q2 = c - w*clamp( dot(c,w)/sqr(w), 0.0, 1.0);\n    \n  vec2 d = min(min(vec2(sqr(q0), det(a,u)),\n                   vec2(sqr(q1), det(b,v))),\n                   vec2(sqr(q2), det(c,w)));\n\n  return -sqrt(d.x)*sign(d.y);\n}\n\n//=====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n\tvec2 v0 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(0.0,2.0) );\n\tvec2 v1 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(1.5,3.0) );\n\tvec2 v2 = vec2(1.2,0.8)*cos( 0.5*iTime + vec2(4.0,1.0) );\n\n// uncomment next line for test 3 point on a line!\n//    v1 = 0.5*(v2+v0);   \n    \n    // compute traingle SDF\n\tfloat dis = sdTriangle( v0, v1, v2, p );\n    \n    // compute triangle equicenter (yellow dot)\n    float inRadius = 0.0;\n    vec2 Mi = TriangleInCircle (v0, v1, v2, inRadius);\n\n    // compute triangle circumscribe center (blue dot)\n    float outRadius = 0.0;\n    vec2 Mo = vec2(0.0);\n    bool bo = TriangleOutCircle (v0, v1, v2, Mo, outRadius);\n\n    // draw triangle SDF\n    vec3 col = vec3(1.0) - sign(dis)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(dis));\n\tcol *= 0.8 + 0.2*cos(150.0*dis);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dis)) );\n\n    // draw helped bisectors in white\n    col = mix(col,vec3(1.0),smoothstep(0.005,0.001,sdSegment( p, v0, Mi )));\n    col = mix(col,vec3(1.0),smoothstep(0.005,0.001,sdSegment( p, v1, Mi )));\n    col = mix(col,vec3(1.0),smoothstep(0.005,0.001,sdSegment( p, v2, Mi )));\n    \n    // draw equicenter and inscribed circle in yellow\n    col = mix(col,vec3(1.,1.,0.),smoothstep(0.005,0.001,sdDisk(p,Mi,0.02)));\n    col = mix(col,vec3(1.,1.,0.),smoothstep(0.005,0.001,0.5*abs(sdDisk(p,Mi,inRadius))));\n    \n    // draw center and circumscribed circle in blue\n    if (bo)\n    { col = mix(col,vec3(0.1,0.4,0.9),smoothstep(0.005,0.001,sdDisk(p,Mo,0.02)));\n      col = mix(col,vec3(0.1,0.4,0.9),smoothstep(0.005,0.001,0.4*abs(sdDisk(p,Mo,outRadius))));\n    }\n    col = mix(col,vec3(0.1,0.4,0.9),smoothstep(0.005,0.001,sdDisk(p,v0,0.02)));\n    col = mix(col,vec3(0.1,0.4,0.9),smoothstep(0.005,0.001,sdDisk(p,v1,0.02)));\n    col = mix(col,vec3(0.1,0.4,0.9),smoothstep(0.005,0.001,sdDisk(p,v2,0.02)));\n    \n    // output\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}