{"ver":"0.1","info":{"id":"csjXRw","date":"1670771758","viewed":161,"name":"Walk-on-spheres 2D","username":"ishiyama","description":"Comparison of analytic solution (left) and Walk-on-Spheres method (right) of Laplace equation Δu(x,y)=0 with boundary conditions u(x,0) = u(0,y) = u(PI,y) = 0, u(x,PI)=sin(x).\n\nClick on the screen to display the WoS path.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["laplace","wos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Comparison of analytical solution (left) and Walk-on-Spheres method (right)\n// of Laplace equation Δu(x,y) = 0 with boundary conditions\n// u(x,0) = u(0,y) = u(PI,y) = 0, u(x,PI) = sin(x).\n//\n// The analytic solution is sin(x) * sinh(y) / sinh(PI).\n// The numerical solution is calculated using Walk-on-Spheres method.\n//\n// For details, see https://www.cs.cmu.edu/~kmcrane/Projects/MonteCarloGeometryProcessing/index.html\n//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = texelFetch(iChannel0,ivec2(fragCoord), 0).xyz;\n    \n    // linear RGB to sRGB (approx.)\n    col = pow(col.xyz, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Walk-on-spheres method\n// \n// Laplace equation: Δu(x,y)=0\n// Boundary conditions: u(x,0) = u(0,y) = u(PI,y) = 0, u(x,PI)=sin(x)\n//\n\n// Walk-on-spheres.\n// Returns the value of the boundary hit by a random walker starting at position p.\nfloat WalkOnSphere(in vec2 p)\n{\n    vec2 result = vec2(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++)\n    {\n        result = SDF(p);\n        float closestDist = result.x;\n        \n        if(closestDist < 0.001)\n        {\n            break;\n        }\n        p += closestDist * RandomInCircle();\n    }\n    \n    int id = int(result.y);\n    return BoundaryValue(p, id);\n}\n\n// Analytic solution of the Laplace equation\nfloat Analytic(vec2 p)\n{\n    return sin(p.x) * sinh(p.y) / sinh(PI);\n}\n\n//-------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// init randoms\n    InitRandom(uvec2(fragCoord), uint(iFrame));\n\n    // normalized pixel coordinates [0,1]\n    vec2 uv = (fragCoord + vec2(0.5)) / iResolution.xy;\n\n    vec4 history = vec4(0.0);\n    if (!ShowPath(iMouse))\n    {\n        history = texelFetch(iChannel0,ivec2(fragCoord), 0);\n    }\n    float numSamples = history.w + 1.0;\n\n    // solve the Laplace eq.\n    vec3 outColor;\n    vec2 pos = PI * uv; // [0,1] -> [0,PI]\n    if (uv.x < 0.5 && !ShowPath(iMouse))\n    {\n        // analytic solution\n        float v = Analytic(pos);\n        outColor = vec3(v);\n    }\n    else\n    {\n        // get a sample of Walk-on-Spheres.\n        float v = WalkOnSphere(pos);\n        \n        // arithmetic mean of all samples\n        outColor = mix(history.xyz, vec3(v), 1.0 / numSamples);\n    }\n\n    fragColor = vec4(outColor, numSamples);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nconst float PI = 3.14159265358979;\n\n// Maximum number of steps for Walk on Spheres algorithm\nconst int MAX_STEPS = 16;\n\n// Conditions for drawing a WoS path\nbool ShowPath(in vec4 mouse)\n{\n    return mouse.z > 0.0;\n}\n\n//-------------------------------------------------------\n// Boundary conditions\n//-------------------------------------------------------\nconst int ID_NONE = 0;\nconst int ID_TOP  = 1;\nfloat BoundaryValue(in vec2 p, in int id)\n{\n    float value = 0.0;\n    if (id == ID_TOP)\n    {\n        value = sin(p.x);\n    }\n    return value;\n}\n\n//-------------------------------------------------------\n// 2D signed distance functions\n//-------------------------------------------------------\n// https://www.shadertoy.com/view/3tdSDj\nfloat udSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nvec2 opUnion(in vec2 a, in vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nstruct Line\n{\n    vec2 p0;\n    vec2 p1;\n    int id;\n};\n\nvec2 SDF(in vec2 p)\n{\n    Line Lb = Line( vec2(0.0, 0.0), vec2(PI , 0.0), ID_NONE );\n    Line Lr = Line( vec2(PI,  0.0), vec2(PI ,  PI), ID_NONE );\n    Line Lt = Line( vec2(PI,  PI ), vec2(0.0,  PI), ID_TOP );\n    Line Ll = Line( vec2(0.0, PI ), vec2(0.0, 0.0), ID_NONE );\n    \n    vec2 info = vec2(1e9, ID_NONE);\n    info = opUnion(info, vec2(udSegment(p, Lt.p0, Lt.p1), Lt.id));\n    info = opUnion(info, vec2(udSegment(p, Lr.p0, Lr.p1), Lr.id));\n    info = opUnion(info, vec2(udSegment(p, Lb.p0, Lb.p1), Lb.id));\n    info = opUnion(info, vec2(udSegment(p, Ll.p0, Ll.p1), Ll.id));\n\n    return info;\n}\n\n//--------------------------------------\n// Random number generators\n//--------------------------------------\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 PCG3d(in uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nuvec3 gSeed = uvec3(0u);\nvoid InitRandom(in uvec2 p, in uint frame)\n{\n    gSeed = uvec3(p, frame);\n}\n\n// uniform random number [0,1]\nfloat Rand()\n{\n    gSeed = PCG3d(gSeed);\n    return float(gSeed.x) / float(0xffffffffu);\n}\n\n// uniform random number on a circle\n// https://www.shadertoy.com/view/WsXBzl\nvec2 RandomInCircle()\n{\n    float a = 2.0 * PI * Rand();\n    return vec2(cos(a), sin(a));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// Debug display of walk-on-spheres path, etc.\n//\n\n// WoS and record the WoS path\nfloat WalkOnSphere(in vec2 p, out vec2 outVertices[MAX_STEPS])\n{\n    // clear\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        outVertices[i] = vec2(-1.0);\n    }\n\n    // WoS\n    vec2 h = vec2(0.0);\n\tfor(int i = 0; i < MAX_STEPS; i++)\n    {\n        h = SDF(p);\n        if(h.x < 0.001)\n        {\n            break;\n        }\n        outVertices[i] = p;\n        p += h.x * RandomInCircle();\n    }\n    \n    return BoundaryValue(p, int(h.y));\n}\n\n// Draws a line segment at endpoints a and b with thickness w and color col\nvec3 DrawLine(in vec3 io, in vec2 p, in vec2 a, in vec2 b, in float w, in vec4 col)\n{\n    float f = udSegment(p, a, b);\n    float d = fwidth(f);\n    return mix(io, col.xyz, col.w * (1.0 - smoothstep(w - d, w + d, f)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// init randoms\n    InitRandom(uvec2(iMouse.xy), uint(iFrame));\n\n    // normalized pixel coordinates [0,1]\n    vec2 uv = (fragCoord + vec2(0.5)) / iResolution.xy;\n\n    // get calculation results\n    vec3 outColor = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    \n    if (ShowPath(iMouse))\n    {\n        // draw a random walk path from mouse position to the boundary\n        vec2 muv = iMouse.xy/iResolution.xy;\n        vec2 mpos = PI * muv;\n        \n        vec2 verts[MAX_STEPS];\n        float v = WalkOnSphere(mpos, verts);\n        \n        vec4 line_col = vec4(1.0, 0.0, 0.0, 1.0);\n        for (int i = 0; i < MAX_STEPS - 1; ++i)\n        {\n            if (verts[i+1].x < 0.0)\n            {\n                break;\n            }\n            float h = float(i) / float(MAX_STEPS);\n            vec2 v0 = verts[i] / PI;\n            vec2 v1 = verts[i+1] / PI;\n            outColor = DrawLine(outColor, uv, v0, v1, 0.01, vec4(v, v, v, 0.97));\n        }\n    }\n    else\n    {\n        // draw a line in the middle of the screen\n        vec2 a = vec2(0.5, 0.0);\n        vec2 b = vec2(0.5, 1.0);\n        outColor = DrawLine(outColor, uv, a, b, 0.002, vec4(0.5));\n    }\n    \n    fragColor = vec4(outColor, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}