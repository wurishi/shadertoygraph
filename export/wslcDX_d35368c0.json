{"ver":"0.1","info":{"id":"wslcDX","date":"1585767151","viewed":141,"name":"Simple logo","username":"CDucree","description":"Simple logo which is a registered trademark and happens to resemble my initials quite well... ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["logo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on the \"RayMarching starting point\" by BigWings/CountFrolic\n// and re-animated by watching IQ's Shader Deconstruction session on U-Tube.\n\n// Antialiasing: number of samples in x and y dimensions\n#define AA 2   // make this 1 if your machine is too slow\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define ST(a, b, t) smoothstep(a, b, t)\n\nvec3 mx(vec3 p, float x){\n\tp.x += x;\n    return p;\n}\nvec3 my(vec3 p, float y){\n\tp.y += y;\n    return p;\n}\nvec3 mz(vec3 p, float z){\n\tp.z += z;\n    return p;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n// -------------------------------------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2){\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2){\n    \n    if(d1.x < -d2.x) return vec2(-d2.x, d2.y);\n    \n    return d1;\n}\n\nfloat opE(vec3 p, float d, float h){\n    vec2 w = vec2( d, abs(p.y) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0)); \n}\n\n// -------------------------------------------------------------------------------------------------\n// From IQ's SDF library\n// -------------------------------------------------------------------------------------------------\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n// -------------------------------------------------------------------------------------------------\nvec2 sdCD2(vec3 p) {\n\tvec2 res = vec2(0.);\n    float r = .1;\n    float c1 = 1.;\n    float c2 = 2.;\n    float h = .1;\n    float ngs = -.0027;\n    float ngr = .03;\n    p *= .9;\n    \n    float t = 3.14/2.;\n\n    p.z += .5;\n    float li = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),.081 + ngs,vec2(0.48,0.4));\n    li = opE(p, li, h);\n    vec2 lif = vec2(li - ngr, c1);\n    \n\n    p.z = -p.z;\n    p.z += 1.;\n    float ri = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),.081 + ngs,vec2(0.48,0.4));    \n    ri = opE(p, ri, h);\n    vec2 rif = vec2(ri - ngr, c2);\n    \n    \n    p.z = -p.z;\n    p.z += 1.;    \n    float mi = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),.755 + ngs,vec2(0.48,0.23));\n    mi = opE(p, mi, h);\n    vec2 mif = vec2(mi - ngr, c2);   \n    \n    p.z = -p.z;\n    p.z += 1.;\n    float o1 = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),.78 + ngs,vec2(0.48,0.26));\n    o1 = opE(p, o1, h);\n    vec2 o1f = vec2(o1- ngr, c1);\n    \n    p.z = -p.z;\n    p.z += 1.;\n    float o2 = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),1.035 + ngs,vec2(0.52,0.005));\n    o2 = opE(p, o2, h);\n    vec2 o2f = vec2(o2- ngr, c1);\n        \n    res = opU(lif, rif);\n    res = opU(res, mif);\n    res = opU(res, o1f);\n    res = opU(res, o2f);        \n    \n    return res;\n}\n\n\n// -------------------------------------------------------------------------------------------------\nvec2 GetDist(vec3 p) {\n\tvec2 res = vec2(0.);\n    \n    p *= .7;\n\tres = sdCD2(p);\n    p /= .7;\n    \n\n    return res;\n}\n\n// -------------------------------------------------------------------------------------------------\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 dO= vec2(0);\n    vec2 dS=vec2(0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        dS = GetDist(p);\n        dO.x += dS.x;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n\n    dO.y = dS.y;\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d.x - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n// -------------------------------------------------------------------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n// -------------------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(1);\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int ma=0; ma<AA; ma++ )\n    for( int na=0; na<AA; na++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(ma),float(na)) / float(AA) - 0.5;\n        uv = (fragCoord+o-.5*iResolution.xy)/iResolution.y;\n#endif\n    vec3 ro = vec3(0,6, -1);\n    //ro.yz *= Rot(-m.y*3.14+1.);        \n    //ro.xz *= Rot(-m.x*6.2831);\n    ro.xz *= 5.*Rot(iTime/4.);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    vec2 d = RayMarch(ro, rd);\n    \n    if(d.x<MAX_DIST) {\n\n        if(d.y==1.) {\n            ambientColor = vec3(0.);\n            diffuseColor = vec3(0.);\n        }\n        if(d.y==2.){\n            ambientColor = vec3(.7);\n            diffuseColor = vec3(1.);\n        }\n        if(d.y==3.){\n            ambientColor = vec3(.3, .0, .0);\n            diffuseColor = vec3(1., .0, .0);\n        }   \n        if(d.y==4.){\n            ambientColor = vec3(.0, .3, .0);\n            diffuseColor = vec3(.0, 1.0, .0);\n        }         \n        vec3 p = ro + rd * d.x;\n    \tvec3 n = GetNormal(p);\n                \n        float occ = 0.5 + 0.5 * n.y;\n\n        float amb = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n        float dif = clamp(dot(lightDir, n), 0.0, 1.0);\n\n        vec3 h = normalize(-rd + lightDir);\n        float spe = pow(clamp(dot(h, n), 0.0, 1.0), 64.0);\n\n        col = amb * ambientColor * occ;        \n        col += dif * diffuseColor * occ;\n        col += dif * spe * specularColor * occ;\n               \n        \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor=vec4(tot,1.0);\n\n}","name":"Image","description":"","type":"image"}]}