{"ver":"0.1","info":{"id":"MXBBDR","date":"1729323715","viewed":35,"name":"BoxSphereRayMarching","username":"Ryota_Kyoya","description":"a","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    float outsideDistance = length(max(d, 0.0));\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    return outsideDistance + insideDistance;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sceneSDF(vec3 p) {\n    float k = 0.5; \n    float minDist = 10000.0; \n    int numPairsX = 4; \n    int numPairsY = 4;\n    \n    for (int i = 0; i < numPairsX; i++) {\n        for (int j = 0; j < numPairsY; j++) {\n            float offsetX = float(i) * 3.0;\n            float offsetY = float(j) * 3.0;\n            vec3 spherePos = vec3(offsetX + tan(iTime), offsetY + tan(iTime * 0.5), 0.0);\n            vec3 boxPos = vec3(offsetX + 1.5, offsetY + 1.5 + tan(iTime * 0.5), 0.0);\n\n            float dSphere = sphereSDF(p - spherePos, 1.0);\n            float dBox = boxSDF(p - boxPos, vec3(1.0));\n            float dPair = smin(dSphere, dBox, k);\n\n            minDist = min(minDist, dPair);\n        }\n    }\n\n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float angle = iTime * 3.;\n    \n    vec3 target = vec3(0., 5., 0.); \n    vec3 cp = vec3(cos(angle) * 10.0, 5., sin(angle) * 10.0);       \n    vec3 cd = normalize(target - cp);       \n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); \n    vec3 cu = normalize(cross(cd, cs));     \n    \n    vec3 col = vec3(0.0);\n    \n    float fov = 0.1; \n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); \n\n    float t = 0.0;\n    int maxSteps = 100;\n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = cp + t * rd;\n        float d = sceneSDF(p);\n        if (d < 0.001) break;\n        t += d;\n        if (t > 20.0) break;\n    }\n\n    float lightIntensity = smoothstep(19.0, 20.0, t);  \n    lightIntensity = pow(lightIntensity, 8.0); \n\n    vec3 color = vec3(lightIntensity);  \n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}