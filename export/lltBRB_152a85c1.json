{"ver":"0.1","info":{"id":"lltBRB","date":"1540140732","viewed":1235,"name":"BallRoller","username":"Del","description":"A Rolling Ball...","likes":42,"published":1,"flags":0,"usePreview":1,"tags":["tunnel","raymarch","ball","rolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ball roller - attempting to learn some raymarching techniques from the masters...\n//\n// raymarching base code from Shane's awesome 'Mountain Path' https://www.shadertoy.com/view/ldjyzc\n// Del - 21/10/2018\n//\n// some slight mods: improved ball rolling, single box for rails, single texture etc.\n\n#define FAR 120.\n#define BALLSIZE 1.25\n#define PI 3.14159\n#define\tTAU 6.28318\n\nfloat objID;\nfloat svObjID;\nvec3 m_ballpos;\t\t// ball position\nmat3 m_ballmat;\t\t// rotation matrix\n\n// Fabrice's concise, 2D rotation formula.\n//mat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\n//vec3 tex3D( sampler2D t, in vec3 p, in vec3 n )\n//{\n//    p*=0.4;\n//    n = max(abs(n), 0.001);\n//    n /= dot(n, vec3(1));\n//\tvec3 tx = texture(t, p.yz).xyz;\n//    vec3 ty = texture(t, p.zx).xyz;\n//    vec3 tz = texture(t, p.xy).xyz;\n//    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n//}\n\n// Smooth maximum, based on IQ's smooth minimum.\n//float smax(float a, float b, float s){\n//    \n//    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n//    return mix(b, a, h) + h*(1. - h)*s;\n//}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca * p.y - sa * p.z, sa * p.y + ca * p.z);\n}\n//vec3 rotateY(vec3 p, float a)\n//{\n//  float sa = sin(a);\n//  float ca = cos(a);\n//  return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n//}\n//vec3 rotateZ(vec3 p, float a)\n//{\n//  float sa = sin(a);\n//  float ca = cos(a);\n//  return vec3(ca * p.x - sa * p.y, sa * p.x + ca * p.y, p.z);\n//}\n\n// out: 0->val->0\nfloat SmoothTri2(float t, float val)\n{\n    return val * (1.0-(0.5+cos(t*TAU)*0.5));\n}\n\n// Blended path(s)\nvec2 path(in float z)\n{ \n\tfloat t = mod(z,68.0)/68.0;\n\tfloat m = SmoothTri2(t,1.0);\n    vec2 path1 = vec2(sin(z*0.1)*0.5,(cos(z*0.2)*0.75)-1.0);\n    vec2 path2 = vec2((sin(z*.15)*2.5), (cos(z*0.13)*1.25)+1.0); // Path 3.\n    return mix(path1,path2,m);\n}\n\n// internal cylinder\nfloat DirtyTunnel(vec3 p, float d)\n{\n\tfloat d2 = d - length(p.xy);\n\n    // tunnel noise...\n    float k = dot(sin(p*1. - cos(p.yzx*1.57)), vec3(.333))*.57;\n    k += dot(sin(p*2. - cos(p.yzx*3.14)), vec3(.333))*.13;\n    d2-=k;\n    return d2;\n}\n\n\n#if 0\n// http://mercury.sexy/hg_sdf/\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat filth(in vec3 p, vec2 pth,float z)\n{\n    vec3 p2 = p;\n    p2.xy += pth;\n    \n\tfloat c = pMod1(p2.z,16.0);\n    \n    float r = hash(vec2(c+(c*0.31),c+(c*0.61)));\n\n    if (r>0.6)\n    {\n        float h = 4.0;\t// *r;\n\t    float dist3 = sdBox(p2-vec3(0.0,h-0.5,0.0),vec3(2.7,0.5,0.5));\n\t    p2.x -= 2.7;\n\t    float dist = sdBox(p2,vec3(0.5,h,0.5));\n\t    p2.x += 5.4;\n\t    float dist2 = sdBox(p2,vec3(0.5,h,0.5));\n\t\tdist=min(dist,dist2);\n        \n\t\t//return smin(dist,dist3,0.9);\n\t\treturn min(dist,dist3);\n        \n    }\n    return 1.0;\n}\n#endif\n\n\nfloat map(vec3 p)\n{\n    vec2 pth = path(p.z);\n\n    // ROAD (1 box)\n    vec3 pp2 = p;\n    pp2.xy += pth;\n    pp2.y += 3.0;\t\t// road Yoffset\n    float dist = sdBox(pp2,vec3(3.5,0.2,200000.0));\n    \n    // RAILS (1 box, abs mirror)\n    pp2.x = abs(pp2.x);\n    pp2.x -= 1.3;\n    float rails = sdBox(pp2,vec3(0.125,0.5,200000.0));\n    \n    dist = smin(rails,dist,0.2);\n    // debug\n\t//dist = smin(filth(p, pth, p.z),dist,0.2);    \n\n    // + tunnel (-yoff)\n    vec3 p2 = p;\n    p2.xy += pth;\n\tfloat d2 = DirtyTunnel(p2-vec3(0.0,1.0,0.0),5.0);\n\n    objID = step(d2, dist); // Tunnel, Ground...\n    \n    // Ball (hack)\n    dist = smin(dist,d2,0.2);\n    vec3 bp = p-m_ballpos;\n\tfloat balldist = sdSphere(bp,BALLSIZE);\n    \n\tdist = min(balldist,dist);\n    if (dist>=balldist)\n        objID = 2.5;\t\t// or Ball!\n    if (dist>=rails)\n        objID = 3.5;\t\t// or Rail!\n    \n    return dist;\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0., d;\n    for (int i=0; i<160; i++)\n    {\n        d = map(ro + rd*t);\n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR)\n            break;\n        t += d;\n    }\n    return min(t, FAR);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k, float t)\n{\n    const int maxIterationsShad = 48; \n    vec3 rd = lp-ro;\n    float shade = 1.;\n    float dist = .0025*(t*.125 + 1.);\n    float end = max(length(rd), 0.0001);\n    rd /= end;\n    for (int i=0; i<maxIterationsShad; i++)\n    {\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n        dist += clamp(h, .07, .5); \n        if (h<0.0 || dist > end)\n            break; \n    }\n    return min(max(shade, 0.) + 0.1, 1.); \n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p )\n{\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//vec3 BallTexture2(vec2 pos)\n//{\n//    float y = mod(pos.y+0.5,2.0)-0.5;\n//\tfloat s = smoothstep( y-0.5, y, 0.0) - smoothstep( y, y+0.5, 0.0); \n//    vec3 col = mix(vec3(0.7,0.5,0.8)*1.2,vec3(0.7,0.5,0.8)*0.5,s);\n//    return col;\n//}\n\nvec3 BallTexture(vec2 pos)\n{\n    // lines\n    float f = mod( floor(pos.y),2.0) + 0.75;\n    vec3 col = f*vec3(0.7,0.5,0.8);\n    return col;\n}\n\n\n// Coloring / texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n)\n{\n    vec3 tx = vec3(1.0*1.0,0.98*0.98,0.95*0.95);\n    \n    if(svObjID<.5)\n    {\n        //vec2 pth = path(p.z);\n        //tx = tex3D(iChannel0, (p - vec3(pth.xy - .5, .0)), n );\t// Shane tex3d\n        \n        vec2 _uv = p.xz;\n        _uv += path(p.z);\n        tx = texture(iChannel0,_uv*0.1).xyz*vec3(0.8,1.1,0.8);\n        tx*=tx;\n        \n    }\n    else if(svObjID<1.5)\n    {\n        float scale = 0.25;\n        p.xy += path(p.z);\n        p*= scale;\n        tx = texture(iChannel0, (vec2(p.z , atan(p.x, p.y)) / 6.28)).xyz;\t// Cylinder\n        tx*=tx;\n    }\n    else if(svObjID<2.6)\n    {\n        vec3 p2 = n;\n        p2 = m_ballmat*p2;\n        p2 = rotateX(p2,-m_ballpos.z);\n        //p2 = normalize(p2);\n        //p2 = rotateZ(p2,3.14/2.0);\n        vec2 _uv;\n        _uv.x = 0.5 + atan(p2.z, p2.x) / TAU;\n        _uv.y = 0.5 - asin(p2.y) / PI;\n\t\ttx = BallTexture(_uv*7.0);\t\t\t\t\t// sphere\n\t\t//tx = BallTexture2(_uv*5.0);\t\t\t\t// sphere\n    \t//tx = texture(iChannel0, _uv*2.).rgb;\n        tx*=tx;\n    }\n    return tx;\n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t)\n{\n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR)\n    { // If we've hit a scene object, light it up.\n        \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        vec3 sn = getNormal(sp);\n        \n        // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n        // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n        // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n        // right without them.\n        float sh = softShadow(sp + sn*.002, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.3)*ao;\n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        // Attenuating the light, based on distance.\n        float atten = 3./(1. + lDist*0.01 + lDist*lDist*0.00008);\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        vec3 objCol = getObjectColor(sp, sn);\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.5 + vec3(1, .7, .5)*spec*1.);\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    }\n    // Return the color. Done once for each pass.\n    return sceneCol;\n}\n\n\nmat3 rotate3d(vec3 axis, float angle)\n{\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nmat3 lookat(vec3 o, vec3 t)\n{\n\tvec3 dir = normalize(t-o);\n    float yAxis = atan(dir.x,dir.z);\n    float xAxis = -asin(dir.y);\n    return rotate3d(vec3(1,0,0),xAxis)*rotate3d(vec3(0,1,0),yAxis);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*7.5); // Camera position, doubling as the ray origin.\n    \n    \n\tvec3 lk = ro + vec3(0.0, 0.0, 0.25);  // \"Look At\" position.\n   \n    // Light position.\n    //vec3 lp = ro + vec3(10., FAR*.24, FAR*.52)*3.;\n    vec3 lp = ro + vec3(10., FAR*.24, FAR*.22)*3.;\n    \n    m_ballpos = ro;\n    vec3 BallLookAt = ro;\n\n    // camera look ahead\n    ro.xy-=path(ro.z);\n    lk.xy-=path(lk.z);\n\n    // position the ball infront of the camera (on the path)\n    m_ballpos.z += 8.0;\n    m_ballpos.y -= 1.5;\n    m_ballpos.xy -= path(m_ballpos.z);\n    \n    BallLookAt.z += 8.05;\n    //BallLookAt.y -= 1.5;\n    BallLookAt.xy -= path(BallLookAt.z);\n    BallLookAt.y = m_ballpos.y;\n    \n    m_ballmat = lookat(m_ballpos,BallLookAt);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.15, 0.)) ));\n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    svObjID = objID; // Save the object ID, for use in the coloring equation.\n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(0., .95, t/FAR); // t/FAR; \n    \n    vec3 fogCol = vec3(0.5,0.5,0.5);\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}