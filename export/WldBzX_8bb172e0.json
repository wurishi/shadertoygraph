{"ver":"0.1","info":{"id":"WldBzX","date":"1613171458","viewed":273,"name":"Dancing Triangles","username":"Patate1er","description":"I like music and motion design :3\nI did another template shader with the same method to split audio spectrum :\nhttps://www.shadertoy.com/view/ttcBzX","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["2d","grid","sound","fft","triangles","visualization","reactive","music","audio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//I took some code here for triangular coords :\n//https://www.shadertoy.com/view/MdfBzl\n//And for barycentric coordinates computing :\n//https://www.shadertoy.com/view/lslXDf\n\n////////////////////////////////////////////////////////////////////////////////\n//constants\n//for triangle conversion\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n\n////////////////////////////////////////////////////////////////////////////////\n//noises\n//usefull for simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//simplex noise\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,  // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\n// 2D Random\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute barycentric coordinates from point differences\nvec3 bary(vec2 v0, vec2 v1, vec2 v2) {\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return vec3(u,v,w);\n}\n\n//////////////////////////////////////////////////////////////////////\n//waves\nfloat wave(vec2 uv){\n    //variables\n    float f_noise = 0.10;\n    float f_speed = 1.5;\n    float f_noiseSpeed = 1.0;\n    int nb_waves = 2;\n    \n    //sound influence\n    float spectrum = texelFetch( iChannel0, ivec2(0,0), 0 ).x;\n    float f_waveMiddle = 0.15 * spectrum;\n    float f_waveGrey = 0.8*spectrum;\n    \n    //uv deformation and scale\n    uv = uv+vec2(snoise(uv+iTime * f_noiseSpeed)*f_noise,snoise(uv+1.0-iTime * f_noiseSpeed)*f_noise);\n    uv = float(nb_waves)*uv;\n    \n    //drawing waves (2 mores for tiling)\n    float timeScaled = f_speed * iTime;\n    float ret = 0.0;\n    for(int i = 0; i<nb_waves+2;++i){\n        ret = max(ret,smoothstep(f_waveMiddle+f_waveGrey,f_waveMiddle,abs(uv.x-fract(timeScaled)+1.0-float(i))));\n    }\n    return ret;\n}\n\n//////////////////////////////////////////////////////////////////////\n// main shading function. inputs:\n//   p - current pixel location in scene\n//   t0, t1, t2 - coords\n//   cw - pixel accumulator. xyz are rgb color pre-multiplied by\n//        weights, and w is total weight.\nvoid tri_color(in vec2 p, \n               in vec2 t0, in vec2 t1, in vec2 t2, \n               inout vec4 cw) {\n    //wave\n    vec2 m = (t0+t1+t2)/3.0;\n    float f_wave = wave(m);\n    \n    //sound influence depending on random index\n    int soundIndex = int(random(m)*3.0);\n    switch (soundIndex){\n        case 1:\n        case 2:\n            float loc_spec = texelFetch( iChannel0, ivec2(0,0), 0 )[soundIndex];\n            f_wave=min(f_wave*loc_spec,1.0);\n            break;\n        case 0:\n            f_wave *= 0.45;\n            break;\n    }\n    \n    //constants\n    float s = 0.04;\n    float lineSeparation = mix(0.20,0.03,f_wave);\n    float lineWidth = 0.05;\n    float blackCorner = mix(0.6,0.9,f_wave);\n    float blackHoles = 0.55;\n    \n    // get differences relative to vertex 0\n    vec2 p0 = p - t0.xy;\n    vec2 p10 = t1.xy - t0.xy;\n    vec2 p20 = t2.xy - t0.xy;\n    \n    // get barycentric coords\n    vec3 b = bary(p10, p20, p0);\n    \n    // unsigned distance to triangle boundary\n    float d = min(b.x, min(b.y, b.z));\n    \n    if(d>=0.0){\n        // weight for anti-aliasing is 0.5 at border, 0 just outside,\n        // 1 just inside\n        float w = smoothstep(lineWidth/2.0, 0.0, abs(d-lineSeparation));\n        //corners\n        float c = max(b.x, max(b.y, b.z));\n        c = min(smoothstep(blackCorner,blackCorner-s,c),smoothstep(blackHoles-s,blackHoles,c));\n        w = min(c,w);\n        \n        w *= f_wave;\n        // add to accumulator\n        cw += vec4(w,w,w,1.0);\n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n//get normalized coord from triangular base coords\nvec2 uvFromTri(vec2 pt, float scl){\n    //scalé normalisé sur y\n    vec2 ret = tri2cart*pt/scl;\n    //normalisé sur x et y\n    ret = ret * vec2(iResolution.y)/iResolution.xy;\n    return ret;\n}\n\n//////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float scl = 5.1 ;\n    \n    // get 2D scene coords\n    vec2 p = fragCoord * scl/iResolution.y;\n    \n    // get triangular base coords\n    p = cart2tri * p;\n    vec2 p_loc = fract(p);\n    \n    // color accumulator\n    vec4 cw = vec4(0.0);\n\n    // creating 2 trangles:\n    vec2 t00 = p-p_loc;\n    vec2 t10 = uvFromTri(t00+vec2(1,0), scl);\n    vec2 t01 = uvFromTri(t00+vec2(0,1), scl);\n    vec2 t11 = uvFromTri(t00+vec2(1,1), scl);\n    t00 = uvFromTri(t00, scl);\n    \n    // upper triangle\n    tri_color(fragCoord/iResolution.xy, t00, t11, t01, cw);\n    // lower triangle\n    tri_color(fragCoord/iResolution.xy, t00, t10, t11, cw);\n\n    // final pixel color\n    fragColor = vec4(cw);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//ranges to split\nconst vec2[3] spec_split = vec2[3](vec2(0.2,0.8),\n                                vec2(0.0,0.01),\n                                vec2(0.4,0.6));\nconst vec3 f_range = vec3(1.8,0.475,1.2);\nconst vec3 a_range = vec3(.3,.01,.1);\nconst int steps = 1;//possibility to skip values for performance if steps > 1\n\n// return 1 value at the time\nfloat spectrum(int value){\n    float ret = 0.0;\n    int splitStart = int(floor(spec_split[value].x*512.0));\n    int splitEnd = int(floor(spec_split[value].y*512.0));\n    for(int i = splitStart; i<=splitEnd;i+=steps){\n        // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n        float fft  = texelFetch( iChannel0, ivec2(i,0), 0 ).x;\n        ret+=fft;\n    }\n    if(splitStart!=splitEnd){\n        ret/=floor(float((splitEnd-splitStart)/steps));\n    }\n    return smoothstep(0.5-a_range[value],0.5+a_range[value],f_range[value]*ret);\n}\n\n//return 3 values\nvec3 spectrum(){\n    vec3 ret = vec3(0);\n    for(int i = 0; i<3; ++i){\n        ret[i] = spectrum(i);\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     if(floor(fragCoord.x) == 0. && floor(fragCoord.y) == 0.){//only first texel\n        fragColor.xyz = spectrum();//music splited spectrum\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}