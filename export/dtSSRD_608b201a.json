{"ver":"0.1","info":{"id":"dtSSRD","date":"1675792242","viewed":114,"name":"Simplex Noise Vector Directions","username":"myth0genesis","description":"I just thought it would be a fun way to test my new DDA implementation by driving the orientation, color, and scale of a bunch of raytraced capsules with the gradient 4D simplex noise.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","ray","gradient","raytraced","4d","vector","dda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2023 myth0genesis\n\n#define F4 0.309016994374947451\n\nconst float i289 = 1.0 / 289.0;\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\nconst vec3 ip = vec3(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0);\n\nconst mat3 negIDMat = mat3(-1.0,  0.0,  0.0,\n                            0.0, -1.0,  0.0,\n                            0.0,  0.0, -1.0);\n\n// Effectively the Manhattan distance in number of cells\nconst int maxcells = 45;\nconst float linflloff = 0.03;\n// Various tweakable parameters for scale and such\nconst float capsLen = 0.45;\nconst float capsRad = 0.05;\nconst float noiseScale = 0.05;\n\nfloat mapscale;\nmat3 nRot;\n\nmat2 rot2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\n// iq's lookat rotation solution: https://iquilezles.org/articles/noacos/\n// with a catch for when z and d are pointing in opposite directions\nmat3 rotFromTo(vec3 d, vec3 z) {\n    vec3  v = cross(z, d);\n    float c = dot(z, d);\n    float k = 1.0 / (1.0 + c);\n\n    mat3 v3 = mat3(v, v, v);\n    mat3 vf = matrixCompMult(v3, transpose(v3)) * k;\n    \n    mat3 vRes = vf + mat3(   c, -v.z,  v.y,\n                           v.z,    c, -v.x,\n                          -v.y,  v.x,    c);\n\n    return (c == -1.0) ? negIDMat : vRes;\n}\n\n// Various helper functions for the simplex noise\nfloat mod289(float x) {\n    return x - floor(x * i289) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * i289) * 289.0;\n}\n\nfloat permute(float x) {\n    float pf = ((x * 34.0) + 10.0) * x;\n    return mod289(pf);\n}\n\nvec4 permute(vec4 x) {\n    vec4 pf = ((x * 34.0) + 10.0) * x;\n    return mod289(pf);\n}\n\nfloat taylorInvSqrt(float r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j) {\n    vec4 p;\n\n    p.xyz = floor(fract(j * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - abs(p.x + p.y + p.z);\n    vec4 s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.w; \n\n    return p;\n}\n\n// Stevan Gustavson's 4D simplex noise: https://github.com/stegu/webgl-noise/blob/master/src/noise4D.glsl\n// with my solution for the gradient: https://www.shadertoy.com/view/dlfXDN\n// and a few possible optimizations\nfloat snoise(vec4 v, float scale, out vec4 grad) {\n    v *= scale;\n    const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                          0.276393202250021,  //  2 * G4\n                          0.414589803375032,  //  3 * G4\n                         -0.447213595499958); // -1 + 4 * G4\n\n    vec4 i = floor(v + dot(v, vec4(F4)));\n    vec4 x0 = v - i + C.x * (i.x + i.y + i.z + i.w);\n\n    vec4 i0;\n    vec3 isX = step(x0.yzw, x0.xxx);\n    vec3 isYZ = step(x0.zww, x0.yyz);\n\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n    \n    vec4 i3 = clamp(i0,  0.0, 1.0 );\n    vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0 );\n    vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0 );\n\n    vec4 x1 = x0 - i1 + C.x;\n    vec4 x2 = x0 - i2 + C.y;\n    vec4 x3 = x0 - i3 + C.z;\n    vec4 x4 = x0 + C.w;\n\n    i = mod289(i);\n\n    float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = permute(permute(permute(permute(\n                        i.w + vec4(i1.w, i2.w, i3.w, 1.0))\n                      + i.z + vec4(i1.z, i2.z, i3.z, 1.0))\n                      + i.y + vec4(i1.y, i2.y, i3.y, 1.0))\n                      + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n\n    vec4 p0 = grad4(j0);\n    vec4 p1 = grad4(j1.x);\n    vec4 p2 = grad4(j1.y);\n    vec4 p3 = grad4(j1.z);\n    vec4 p4 = grad4(j1.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= taylorInvSqrt(dot(p4, p4));\n    \n    vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)             ), 0.0);\n    vec3 m02 = m0 * m0;\n    vec2 m12 = m1 * m1;\n    vec3 m04 = m02 * m02;\n    vec2 m14 = m12 * m12;\n    vec3 pdotx0 = vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2));\n    vec2 pdotx1 = vec2(dot(p3, x3), dot(p4, x4));\n    \n    vec3 temp0 = m02 * m0 * pdotx0;\n    vec2 temp1 = m12 * m1 * pdotx1;\n    \n    grad = -8.0 * (temp0.x * x0 + temp0.y * x1 + temp0.z * x2 + temp1.x * x3 + temp1.y * x4);\n    grad += m04.x * p0 + m04.y * p1 + m04.z * p2 + m14.x * p3 + m14.y * p4;\n    \n    grad = normalize(grad);\n    \n    return 49.0 * (dot(m04, pdotx0) + dot(m14, pdotx1));\n}\n\n// iq's capsule intersection: https://www.shadertoy.com/view/Xt3SzX\n// with some optimizations for the vertical case\nfloat capIntersect(vec3 ro, vec3 rd, float l, float ra, vec3 offs) {\n    ro -= offs + vec3(0.5);\n    ro *= nRot;\n    rd *= nRot;\n    float rdy2 = rd.y * rd.y;\n    float baba = l * l;\n    float baoa = l * ro.y;\n    float a = baba * (1.0 - rdy2);\n    float rdro = dot(rd.xz, ro.xz);\n    float br = baba * rdro;\n    float h = baba * (br * rdro - a * dot(vec3(ro.xz, -ra), vec3(ro.xz, ra)));\n\n    if(h >= 0.0) {\n        float t = (-br - sqrt(h)) / a;\n        float y = l * (ro.y + t * rd.y);\n        if(y > 0.0 && y < baba) return t;\n        vec3 oc = (y <= 0.0) ? ro : ro - vec3(0.0, l, 0.0);\n        float b = dot(rd, oc);\n        float c = dot(oc, oc) - ra * ra;\n        h = b * b - c;\n        if(h > 0.0) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\n// iq's simplest plane intersection used in various places\n// and adapted for use with my DDA implementation\nvec4 iPlane(vec3 ro, vec3 rd, vec3 offst) {\n    vec3 pRes = (-ro + offst) / rd;\n    float md = min(min(pRes.x, pRes.y), pRes.z);\n    return vec4(vec3(equal(pRes, vec3(md))), md);\n}\n\n// My own DDA implementation: https://www.shadertoy.com/view/DtsSWS\n// adapted for use with raytraced intersection functions\nvec2 rayTraceDDA(inout vec3 ro, vec3 rd, vec3 id, vec3 rdsgn, out bool ih, out vec3 pf) {\n    bool plnht = false;\n    vec3 mf = max(rdsgn, 0.0);\n    vec3 qo = id + mf;\n    vec4 hRes = iPlane(ro, rd, qo);\n    pf = hRes.xyz;\n    float ns = 0.0;\n    float dO = capIntersect(ro, rd, mapscale * capsLen, capsRad, id);\n    plnht = hRes.w > 0.0;\n    ih = dO > 0.0;\n    ro = (plnht && !ih) ? (ro + rd * hRes.w) : ro;\n    \n    return vec2(dO, hRes.w);\n}\n\n// iq's analytic solution to capsule normals: https://www.shadertoy.com/view/Xt3SzX\n// with some optimizations for the vertical case\nvec3 getNormal(vec3 p, vec3 offs) {\n    p -= offs + vec3(0.5);\n    p *= nRot;\n    float l = mapscale * capsLen;\n    float r = capsRad;\n    float h = clamp(p.y / l, 0.0, 1.0);\n    return (p - vec3(0.0, h * l, 0.0)) / r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float tm = iTime * 8.0;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 m = (all(equal(iMouse.xy, vec2(0.0)))) ? (vec2(0.5)) : (-iMouse.xy / iResolution.xy);\n    \n    vec3 ro = vec3(0.0, 0.0, iTime);\n    mat2 rmxz = rot2D(m.x * tau + pi);\n    mat2 rmyz = rot2D(m.y * tau + pi);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    rd.yz *= rmyz;\n    rd.xz *= rmxz;\n    vec3 col = vec3(0.0);\n\n    vec3 sgn = sign(rd);\n    bool inthit = false;\n    vec3 id = floor(ro);\n    vec3 plnmask;\n    vec2 mRes = vec2(0.0);\n    vec4 g;\n    vec3 ng3;\n    float td = 0.0;\n    \n    for (int i = 0; i < maxcells; i++) {\n        float smplxns = snoise(vec4(id, tm), noiseScale, g);\n        ng3 = normalize(g.xyz);\n        nRot = rotFromTo(vec3(0.0, 1.0, 0.0), ng3);\n        mapscale = length(g.xyz);\n        \n        mRes = rayTraceDDA(ro, rd, id, sgn, inthit, plnmask);\n        td += mRes.y;\n        if (inthit) break;\n        \n        id += sgn * plnmask;\n    }\n    \n    vec3 p = ro + rd * mRes.x;\n    vec3 n = getNormal(p, id);\n    float dif = dot(n, normalize(vec3(1.0, 2.0, 0.0)) * nRot) * 0.45 + 0.55;\n    \n    dif = pow(dif, 0.4545); // Only gamma-correct for self-shadowing and ambient light to keep colors saturated\n    col = inthit ? (vec3(ng3 * 0.5 + 0.5) * dif * max(1.0 - td * linflloff, 0.0)) : col;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}