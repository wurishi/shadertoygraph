{"ver":"0.1","info":{"id":"4sfyRl","date":"1489276259","viewed":149,"name":"Snake Game Shader","username":"nint22","description":"Simple Snake Clone, done via two shader passes (one that does logical game, another that goes graphics)","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["snakegame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/MddGzf\n// https://www.shadertoy.com/view/lsXGzf\n// Best keyboard example:\n// https://www.shadertoy.com/view/XsBXDw\n\nconst float kTileSize = 16.0;\nconst vec2 DataPos_BoardData = vec2( 0.0, 1.0 );\nconst vec2 gBoardSize = vec2( 20.0, 15.0 );\n\n// Read board position..\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Retrieve X and Y position\n\tvec4 snakeHead = texture( iChannel0, ( vec2( 0.5 ) + vec2( 1.0, 0 ) ) / iChannelResolution[ 0 ].xy );\n    vec4 foodHead = texture( iChannel0, ( vec2( 0.5 ) + vec2( 3.0, 0 ) ) / iChannelResolution[ 0 ].xy );\n    bool dead = ( texture( iChannel0, ( vec2( 0.5 ) + vec2( 6.0, 0 ) ) / iChannelResolution[ 0 ].xy ).x > 0.0 );\n\n    // Center and scale\n    fragCoord -= iResolution.xy * 0.5 - gBoardSize * kTileSize * 0.5;\n    fragCoord = floor( fragCoord / kTileSize );\n    \n    // If in the board..\n    if( all( greaterThanEqual( fragCoord.xy, vec2( 0.0, 0.0 ) ) ) && all( lessThan( fragCoord.xy, gBoardSize ) )  )\n    {\n        float boardAge = texture( iChannel0, ( vec2( 0.5 ) + vec2( fragCoord.y * gBoardSize.x + fragCoord.x, 1.0 ) ) / iChannelResolution[ 0 ].xy ).x;\n        if( fragCoord.xy == floor( snakeHead.xy )  )\n            fragColor = vec4( 1.0, 1.0, 1.0, 1.0 );\n        else if( fragCoord.xy == floor( foodHead.xy ) )\n            fragColor = vec4( 0.0, 1.0, 0.0, 1.0 );\n        else if( boardAge > 0.0 )\n            fragColor = vec4( 0.8, 0.8, 0.8, 1.0 );\n        else\n            fragColor = vec4( 0.5, 0.5, 0.5, 1.0 );\n    }\n    else\n        fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    \n    if( dead )\n        fragColor += vec4( 0.5, 0.0, 0.0, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/MddGzf\n// https://www.shadertoy.com/view/lsXGzf\n// Best keyboard example:\n// https://www.shadertoy.com/view/XsBXDw\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\n// Data positions & constants:\n\n// Current time in seconds; when a new second is found, we check input. This is the\n// clock mechanism that drives the game\nconst vec2 DataPost_Time = vec2( 0.0, 0.0 );\n\n// Current position and direction of the head; storted in (x, y)\nconst vec2 DataPos_SnakeHead = vec2( 1.0, 0.0 );\nconst vec2 DataPos_SnakeDir = vec2( 2.0, 0.0 );\n\n// Current seed for the next random number; this generates the food pellet\nconst vec2 DataPos_FoodPos = vec2( 3.0, 0.0 );\nconst vec2 DataPos_EatenCount = vec2( 4.0, 0.0 );\nconst vec2 DataPos_RNGSeed = vec2( 5.0, 0.0 );\n\n// Game state\nconst vec2 DataPost_Dead = vec2( 6.0, 0.0 );\n\n// Game board, row-by-row, where each value is either 0 or countdown to death\nconst vec2 DataPos_BoardData = vec2( 0.0, 1.0 );\n\n// Snake board is 20 x 15 units\nconst vec2 gBoardSize = vec2( 20.0, 15.0 );\n\n// Random number generation\nint rand( int seed )\n{\n    // Can underflow..\n    int t = int(mod(1103515245.0 * float(seed) + 12345.0, 999999.0));\n    if( t < 0 )\n        t *= -1;\n    return t;\n}\n\n// Retrieve data from keyboard:\nbool ReadKeyboard( float keyIndex )\n{\n    return ( texture( iChannel1, vec2( keyIndex, 0.25 ) ).x > 0.5 );\n}\n\n// Read / write a normalized byte (input should be ([0.0, 1.0])\n// Coordinates are in integral space\nvec4 ReadValue( vec2 pos )\n{\n    return texture( iChannel0, ( vec2( 0.5 ) + pos ) / iChannelResolution[ 0 ].xy );\n}\n\nvec4 ReadPixel( vec2 pos )\n{\n    return texture( iChannel0, pos / iChannelResolution[ 0 ].xy );\n}\n\nfloat IsPointInFragCoord( vec2 fragCoord, vec2 point )\n{\n    // Todo: Can this be simplfiied? Fast point in box check...\n\tvec2 test = point - fragCoord + vec2( 0.5 );\n    if( test.x >= (0.0) && test.x < (1.0) && test.y >= (0.0) && test.y < (1.0) )\n       return 1.0;\n    else\n       return 0.0;\n}\n\n// Write value; this is done by filling fragColor's x channel\n// if the fragCoord matches the coord we're wanting to write to\n// Value should be normalized [0.0, 1.0] and coordinate can be integral\nvoid WriteValue( inout vec4 fragColor, vec2 fragCoord, vec2 pos, float value )\n{\n    if( IsPointInFragCoord( fragCoord, pos ) > 0.0 )\n        fragColor = vec4( value, 0.0, 0.0, 1.0 );\n}\n\nvoid WriteValue( inout vec4 fragColor, vec2 fragCoord, vec2 pos, vec4 value )\n{\n    if( IsPointInFragCoord( fragCoord, pos ) > 0.0 )\n        fragColor = value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Always read the source pixel - we assume it will pass-through\n    fragColor = ReadPixel( fragCoord );\n    \n    // Read clock, increment\n    float clockTime = ReadValue( DataPost_Time ).x;\n    clockTime += 1.0 / 10.0;\n    \n    // Check for death\n    bool dead = ( ReadValue( DataPost_Dead ).x > 0.0 );\n    \n    // Regardless of clocked update, always listen for keyboard events:\n    vec2 snakeDir = ReadValue( DataPos_SnakeDir ).xy;\n\t\n    // Increment if appropriate\n    if( ReadKeyboard( KEY_RIGHT ) )\n        snakeDir = vec2( 1.0, 0.0 );\n    if( ReadKeyboard( KEY_LEFT ) )\n        snakeDir = vec2( -1.0, 0.0 );\n\n    if( ReadKeyboard( KEY_UP ) )\n        snakeDir = vec2( 0.0, 1.0 );\n    if( ReadKeyboard( KEY_DOWN ) )\n        snakeDir = vec2( 0.0, -1.0 );\n\n    // Are we now in a new second?\n    if( clockTime > 1.0 && dead == false )\n    {\n        // Get initialvalue\n        vec2 snakeHead = ReadValue( DataPos_SnakeHead ).xy;\n        \n        // Wrap snake head position increment in the last direction\n        snakeHead = mod( snakeHead + snakeDir, gBoardSize );\n\t\t\n        // Figure out where food is\n        vec2 foodPos = ReadValue( DataPos_FoodPos ).xy;\n        int rng = int(ReadValue( DataPos_RNGSeed ).x);\n        float eatenCount = ReadValue( DataPos_EatenCount ).x;\n        \n        // Check if we ate ourselves..\n        float headValue = ReadValue( DataPos_BoardData + vec2( snakeHead.y * gBoardSize.x + snakeHead.x, 0. ) ).x;\n\t\tif( headValue > 0.0 && eatenCount > 1.0 )\n        {\n            // Raise death flag\n            WriteValue( fragColor, fragCoord, DataPost_Dead, 1.0 );\n        }\n        \n        // If snake ate food, regenerate\n        if( snakeHead == foodPos )\n        {\n            rng = rand( rng );\n            foodPos.x = mod( float(rng), gBoardSize.x );\n\n            rng = rand( rng );\n            foodPos.y = mod( float(rng), gBoardSize.y );\n            \n            eatenCount++;\n        }\n        // Else, we are moving normally, so de-generate any previous tiles..\n        else\n        {\n            // Todo: clean this up for speed\n            for( float i = 0.0; i < ( gBoardSize.x * gBoardSize.y ); i++ )\n            {\n                vec2 boardDataOffset = DataPos_BoardData + vec2( i, 0. );\n                float healthValue = ReadValue( boardDataOffset ).x;\n                healthValue = max( 0.0, healthValue - 1.0 );\n        \t\tWriteValue( fragColor, fragCoord, boardDataOffset, vec4( healthValue, 0., 0., 0. ) );\n            }\n        }\n        \n        // Write out head position to map\n        snakeHead = floor( snakeHead );\n        WriteValue( fragColor, fragCoord, DataPos_BoardData + vec2( snakeHead.y * gBoardSize.x + snakeHead.x, 0.0 ), vec4( eatenCount, 0., 0., 0. ) );\n        \n        // Write out current state\n        WriteValue( fragColor, fragCoord, DataPost_Time, 0.0 );\n        WriteValue( fragColor, fragCoord, DataPos_SnakeHead, vec4( snakeHead, 0., 0.) );\n        WriteValue( fragColor, fragCoord, DataPos_RNGSeed, vec4( float( rng ), 0., 0., 0. ) );\n        WriteValue( fragColor, fragCoord, DataPos_FoodPos, vec4( foodPos, 0., 0. ) );\n        WriteValue( fragColor, fragCoord, DataPos_EatenCount, vec4( eatenCount, 0., 0., 0. ) );\n    }\n    else\n    {\n        // Pass through all pixels\n        WriteValue( fragColor, fragCoord, DataPost_Time, clockTime );\n    }\n    \n    // Common update\n    WriteValue( fragColor, fragCoord, DataPos_SnakeDir, vec4( snakeDir, 0., 0.) );\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}