{"ver":"0.1","info":{"id":"4X2BRz","date":"1729129597","viewed":222,"name":"AI 2D SDF Shapes","username":"darrinm","description":"Ported from https://darrin.hatch.one/ai-radiating-shapes (remixable).\nWritten by Claude Sonnet 3.5 with prompting by me.\nTry the other shapes: 'rectangle': 0, 'circle': 1, 'triangle': 2, 'hexagon': 3, 'heart': 4, 'diamond': 6, 'pentagon': 7, 'star': 8, 'm","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["2d","sdf","shapes","hatch","ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// title: radiating shapes\n\n/* description:\nBy Darrin Massena (https://darrin.hatch.one/ai-radiating-shapes)\nLicense: MIT\n*/\n\n/* Hatch Uniforms\n\nuniform int shapeType; // default: 0, title: \"Shape Type\", type: Option, options: { 'rectangle': 0, 'circle': 1, 'triangle': 2, 'hexagon': 3, 'heart': 4, 'diamond': 6, 'pentagon': 7, 'star': 8, 'moon': 10, 'plus': 11, 'octagon': 13, 'widow': 14 }\nuniform float glowIntensity; // default: 0.5, min: 0.0, max: 1.0, step: 0.01, title: \"Glow Strength\"\nuniform vec4 buttonColor; // default: #ffff00, type: Color, title: \"Button Color\"\nuniform vec4 ringColor; // default: #666666, type: Color, title: \"Ring Color\"\nuniform vec4 backgroundColor; // default: #333333, type: Color, title: \"Background Color\"\nuniform float ringSpacing; // default: 0.05, min: 0.01, max: 0.1, step: 0.0001, title: \"Ring Spacing\", scalingFactor: 3, decimalPlaces: 0\nuniform int numberOfRings; // default: 7, min: 1, max: 30, step: 1, title: \"Number of Rings\"\nuniform float flowSpeed; // default: 0.5, min: -0.4, max: 0.4, step: 0.01, title: \"Ring Flow Speed\"\nuniform float ringFadeRate; // default: 0.5, min: 0.0, max: 5.0, step: 0.01, title: \"Ring Fade Rate\"\nuniform float shapeWidth; // default: 0.2, min: 0.01, max: 0.5, step: 0.01, title: \"Shape Width\"\nuniform float shapeHeight; // default: 0.08, min: 0.01, max: 0.5, step: 0.01, title: \"Shape Height\"\nuniform float cornerRadius; // default: 0.05, min: 0.0, max: 0.1, step: 0.001, title: \"Corner Roundness\"\n\n*/\n\nint shapeType = 4; // 'rectangle': 0, 'circle': 1, 'triangle': 2, 'hexagon': 3, 'heart': 4, 'diamond': 6, 'pentagon': 7, 'star': 8, 'moon': 10, 'plus': 11, 'octagon': 13, 'widow': 14\nfloat glowIntensity = .78;\nvec4 buttonColor = vec4(0.8941, 0.1020, 0.1137, 1.);\nvec4 ringColor = vec4(0.9922, 0.7373, 0.7373, 1.0);\nvec4 backgroundColor = vec4(0., 0., 0., 1.);\nfloat ringSpacing = .031;\nint numberOfRings = 29;\nfloat flowSpeed = .07;\nfloat ringFadeRate = 1.08;\nfloat shapeWidth = .26;\nfloat shapeHeight = .26;\nfloat cornerRadius = .042;\n\n\nfloat sdRoundedBox(vec2 p, vec2 b, float r) {\n    vec2 q = abs(p) - b + r;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r;\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdEquilateralTriangle(vec2 p, float r) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y > 0.0) p = vec2(p.x - k*p.y, -k*p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0*r, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nfloat sdHexagon(vec2 p, float r) {\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHeart(vec2 p, float r) {\n  p.y += r / 2.;\n    p = p / (r * 2.);  // Scale the input coordinates by r\n    p.x = abs(p.x);\n    if (p.y + p.x > 1.0) {\n        return (sqrt(dot(p - vec2(0.25, 0.75), p - vec2(0.25, 0.75))) - sqrt(2.0) / 4.0) * r;\n    }\n    return (sqrt(min(dot(p - vec2(0.00, 1.00), p - vec2(0.00, 1.00)),\n                     dot(p - 0.5 * max(p.x + p.y, 0.0), p - 0.5 * max(p.x + p.y, 0.0))))\n            * sign(p.x - p.y)) * r;\n}\n\nfloat sdDiamond(vec2 p, float r) {\n    p = abs(p);\n    return (p.x + p.y - r) * 0.7071;\n}\n\nfloat sdPentagon(vec2 p, float r) {\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2(k.x,k.y),p),0.0)*vec2(k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdStar5(in vec2 p, float r) {\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    const float rf = 0.5;  // Constant inner radius factor\n\n    p = p / r;  // Scale the input coordinates by r\n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= 1.0;\n    vec2 ba = rf * vec2(-k1.y, k1.x) - vec2(0, 1);\n    float h = clamp(dot(p, ba) / dot(ba, ba), 0.0, 1.0);\n    return (length(p - ba * h) * sign(p.y * ba.x - p.x * ba.y)) * r;\n}\n\nfloat sdCrescent(vec2 p, float r) {\n    float cr = 0.9 * r; // Inner circle radius\n    float a = sdCircle(p, r);\n    float b = sdCircle(p - vec2(cr * 0.35, 0.0), cr);\n    return max(a, -b);\n}\n\nfloat sdPlus(vec2 p, float w) {\n    p = abs(p);\n    return min(max(p.x - w/3.0, p.y - w), max(p.x - w, p.y - w/3.0));\n}\n\nfloat sdTriangle(vec2 p, float r) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y > 0.0) p = vec2(p.x - k*p.y, -k*p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0*r, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nfloat sdOctagon(vec2 p, float r) {\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623);\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\nfloat sdHouse(vec2 p, float r) {\n    vec2 q = abs(p);\n    float house = min(max(q.x*1.2 + q.y, q.x), q.y) - r*0.8;\n    float roof = (q.x*0.707 - q.y*0.707) - r*0.5;\n    return max(house, roof);\n}\n\nfloat map(vec2 p) {\n    float d;\n    float size = min(shapeWidth, shapeHeight) / 2.0;\n    switch(shapeType) {\n        case 0: return sdRoundedBox(p, vec2(shapeWidth, shapeHeight) / 2.0, cornerRadius);\n        case 1: return sdCircle(p, size);\n        case 2: return sdEquilateralTriangle(p, size);\n        case 3: return sdHexagon(p, size);\n        case 4: return sdHeart(p * 1.5, size);\n        case 6: return sdDiamond(p, size);\n        case 7: return sdPentagon(p, size);\n        case 8: return sdStar5(p, size);\n        case 10: return sdCrescent(p, size);\n        case 11: return sdPlus(p, size);\n        case 13: return sdOctagon(p, size);\n        case 14: return sdHouse(p, size);\n        default: return sdRoundedBox(p, vec2(shapeWidth, shapeHeight) / 2.0, cornerRadius);\n    }\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    float d = map(uv);\n\n    // Base color\n    vec4 col = backgroundColor;\n\n    // Animate rings\n    float flowOffset = mod(iTime * flowSpeed, ringSpacing);\n\n    // Rings\n    for (int i = 0; i < numberOfRings; i++) {\n        float ringD = abs(d) - (float(i) * ringSpacing + flowOffset);\n        float ringMask = smoothstep(0.002, 0.0, abs(ringD));\n        float fadeMultiplier = 1.0 - (float(i) / float(numberOfRings)) * ringFadeRate;\n        col = mix(col, ringColor, ringMask * 0.5 * fadeMultiplier);\n    }\n\n    // Button color\n    col = mix(col, buttonColor, 1.0 - smoothstep(0.0, 0.002, d));\n\n    // Glow effect\n    float glow = exp(-d * 10.0) * glowIntensity;\n    col += buttonColor * glow;\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}