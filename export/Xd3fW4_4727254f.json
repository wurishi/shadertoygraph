{"ver":"0.1","info":{"id":"Xd3fW4","date":"1525577060","viewed":647,"name":"Buddhabrot rendering","username":"rory618","description":"Blazing fast! R to reset.","likes":21,"published":1,"flags":48,"usePreview":0,"tags":["stochastic","buddhabrot","routing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 uv = i/R.xy;\n    \n    o = texture(iChannel0,uv)/textureLod(iChannel0,vec2(.5),100.)/10.;\n    o += texture(iChannel0,uv*vec2(1,-1)+vec2(0,1))/textureLod(iChannel0,vec2(.5),100.)/10.;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F iFrame\n#define branches 6\n#define mIters 64.\nfloat particles = 1e6;\n\n    \nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//Convert uniform random to normal\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n\n\n//This function defines the location of each particle. In other shaders I have used\n//A buffer instead, which is good for storing particles that are acting more complex.\n//But this is fastest.\nvec2 getParticle(float id, vec3 R, int iFrame){\n    vec4 r = hash44(vec4(41,floor(id),iFrame,floor(id)));\n    return (randn(r.zw)/5.)*float(4);\n}\n\n\nfloat orbitDist(vec2 c, vec2 p){\n    float d = 1e9;\n    vec2 z = vec2(c);\n    float j = 0.0;\n    for(j = 0.0;  j < mIters; j++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        d = min(d,length(z-p));\n        if(dot(z,z)>1e3)\n            return d;\n    }\n    return(1e9);\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nThe idea behind stochastic routing is to route information to all relevant \ndestinations by passing everything through a series of layers, taking a stochastic\npath, such that the information gets closer and closer to the destination over \neach layer. For graphics, the destination is one of the pixels rendered in image,\nand the information is the parameters of an obect to be drawn. In this example, a \npoint is stored as a vec2 and rendered as a gaussian.\n\nEach layer of computation, stored in channels x,y,z,w of this buffer, randomly\nsamples 10 orbits stored in the previous layer. Only the one coming closest to the fragCoord\nis saved, this satisfies that information gets closer to the destination over \neach layer. This is why normal distributions with shrinking sigma over the layers \nis used.\n\nAn id tag is passed through the channel output, which enables using one buffer to\nget a lot of passes in by pipelining through xyzw. Even more than 4 passes would be \npossible by using only 16 bits or so to store the tag to get twice the passes.\n\nNear the latter layers, the id tags become closer in fragCoord space to the pixels \nthat the associeted orbits will be affected, so the final rendering pass only needs\nto scan a few nearby locations in order to find every relevant orbit.\n\n\n*/\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(-1);\n    \n    \n    //Set the current best distance to infinity ish\n    float d=1e9;\n    for(int j = 0; j < branches; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = 1.5+mod(floor(r.x * 1e5+r.y*1e3+r.z ),particles);\n        vec2 t = getParticle(id,R,iFrame);//Uniformly sample one of the particles\n\n        vec2 c = (t-.5)/R.xy*R.y*2.;\n        vec2 p = (i-R.xy/2.)/R.y*2.;\n        \n        float dp = orbitDist(c,p);\n        //compute the length to see if it is closer than the current champion\n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.x = id;//Output the nearest points ID\n        }\n    }\n    //Repeat for each getParticle->x->y->z->w\n    d=1e9;\n    for(int j = 0; j < branches; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        //Sample using a shrinking normal distribution\n        float id = texture(iChannel1,(i+randn(r.zw)*127.)/R.xy).x;\n        vec2 t = getParticle(id,R,iFrame-1);\n\n        vec2 c = (t-.5)/R.xy*R.y*2.;\n        vec2 p = (i-R.xy/2.)/R.y*2.;\n        \n        float dp = orbitDist(c,p);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.y = id;\n        }\n    }\n    \n    d=1e9;\n    for(int j = 0; j < branches; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*19.)/R.xy).y;\n        vec2 t = getParticle(id,R,iFrame-2);\n\n        vec2 c = (t-.5)/R.xy*R.y*2.;\n        vec2 p = (i-R.xy/2.)/R.y*2.;\n        \n        float dp = orbitDist(c,p);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.z = id;\n        }\n    }\n    d=1e9;\n    \n    for(int j = 0; j < branches; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*13.)/R.xy).z;\n        vec2 t = getParticle(id,R,iFrame-3);\n\n        vec2 c = (t-.5)/R.xy*R.y*2.;\n        vec2 p = (i-R.xy/2.)/R.y*2.;\n        \n        float dp = orbitDist(c,p);//length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.w = id;\n        }\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 uv = i/R.xy;\n    o = texture(iChannel0,uv)*(texture( iChannel3, vec2(82.5/256.0,0.25) ).x > .5?0.:1.);\n    \n    for(int j = 0; j < branches; j++){//Rendering pass is just the last layer pass\n        \n        vec4 r = hash44(vec4(F,i,j));\n        r.zw = randn(r.zw)*10.;\n        float id = texture(iChannel1,(i+r.zw)/R.xy).w;\n\n\n            \n        if(id >= 1.){\n            vec2 t = getParticle(id,R,iFrame-3);\n            \n            //Optional - redraw orbit 16 times with small jitter. Some points will be convergent\n            //for(int k = 0; k < 16; k++){\n           //     r = hash44(vec4(F,i,j*8+k));\n                vec2 c = (t-.5)/R.xy*R.y*2.;\n           //     c += randn(r.xy)/3e2;\n                vec2 p = (i-R.xy/2.)/R.y*2.;\n\n                vec2 z = vec2(0);\n                float q = 0.0;\n                for(q = 0.0;  q < mIters; q++) {\n                    z = mat2(z, -z.y, z.x) * z + c;\n                    \n                    vec4 rr = hash44(vec4(41,floor(id),iFrame-3,floor(id)));\n    \t\t\t\tfloat ll = length((randn(rr.zw)/5.));\n                    o.xyz += clamp(3.-length((z-p)*R.xy),0.,1.)*(.5+.5*cos(2.*ll*vec3(2,3,4)));\n                    //o[iFrame-3*(iFrame/3)] += clamp(3.-length((z-p)*R.xy),0.,1.);\n\n                    if(dot(z,z)>1e3)\n                        break;\n                }\n         //   }\n            \n            \n        }\n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}