{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Created by Bart Verheijen 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat circleFill(vec2 pos, float radius)\n{\n    return clamp(((1.0-(length(pos)-radius))-(1.0-3.0/iResolution.y))*(iResolution.y/3.0), 0.0, 1.0);   \n}\n\nvec4 smiley(vec2 pos, float scale)\n{\n    vec4 result = vec4(0.0, 0.0, 0.0, circleFill(pos, 0.5*scale));\n    float c = circleFill(pos, 0.45*scale);\n    if (c>0.0) {\n        result += vec4(c, c, 0.0, 0.0);\n    }\n    c = circleFill(vec2(pos.x*1.5+(0.24*scale),pos.y-(0.12*scale)), 0.14*scale);\n    if (c>0.0) {\n        result -= vec4(c, c, 0.0, 0.0);\n    }\n    c = circleFill(vec2(pos.x*1.5-(0.24*scale),pos.y-(0.12*scale)), 0.14*scale);\n    if (c>0.0) {\n        result -= vec4(c, c, 0.0, 0.0);\n    }\n\n    if (pos.y<-0.08*scale)\n    {\n    \tfloat c1 = circleFill(vec2(pos.x,pos.y-(0.04*scale)), 0.36*scale);\n    \tfloat c2 = circleFill(vec2(pos.x*0.9,pos.y-(0.04*scale)), 0.30*scale);\n    \tif (c1>0.0) {\n        \tresult -= vec4(c1, c1, 0.0, 0.0);\n    \t    if (c2>0.0) {\n        \t    result += vec4(c2, c2, 0.0, 0.0);\n    \t    }\n    \t}\n    }\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    //vec4 background = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n    vec2 center = vec2(p.x + 1.2*cos(iTime/10.0), p.y + 1.2*sin(iTime/10.0));\n    float cotan = atan(center.y, center.x);\n    float spot  = clamp(1.3 - 20.0 * length(center), 0.0, 1.0);\n    vec4 background = vec4(clamp(10.0*sin(cotan*13.0 + iTime*3.0)-8.0, 0.0, 1.0) + spot,\n                           clamp(10.0*sin(cotan*17.0 + iTime*2.5)-8.0, 0.0, 1.0) + spot,\n                           clamp(10.0*sin(cotan*19.0 + iTime*2.0)-8.0, 0.0, 1.0) + spot, 1.0);\n    \n    \n    \n    for (float i=0.0; i<8.0; i++)\n    {\n        float seed  = ((i+3.0)*(i+3.0) + floor(iTime*1.1+i/8.0));\n        float rest  = fract(iTime*1.1+i/8.0);\n        seed        = mod(seed*seed*seed, 114.0);\n        vec2 pos    = vec2(floor(seed/6.0)/19.0*3.3 - 1.5, fract(seed/6.0)*1.7-0.7);\n        //vec2 pos    = vec2(fract(y*y*y/10.0)*3.5 - 1.5, fract(y*y*(y+.5)/14.)*1.6-0.8);\n        float scale = 0.7 * sin(rest*2.0 + 1.1415);\n    \tvec4 sprite = smiley(p - pos, scale);\n    \tbackground  = background * (1.0 - sprite.a) + sprite * sprite.a;\n    }\n        \n    fragColor = background;\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"XsfGRr"}],"inputs":[],"code":"// Created by Bart Verheijen 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nconst float PI = 3.14159265358979323846;\nconst float TWOPI = 6.28318530717958647692;\n\n//8 = 120BPM\n#define SPEED 8.0\n\n/**\n * Standard white noise, found somewhere on the interweb\n */\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) - 0.5;\n}\n\n/**\n * returns the notes (left,right) for the bass line (I couldn't use an array :( )\n */\nvec2 notes(float i, float p)\n{\n    vec2 result = vec2(0.0, 0.0);\n    if (mod(i,2.0) < 0.5) result = vec2(55.0, 55.0);\n    \n    float divider = 3.0;\n    if (mod(p,4.0)>2.5) divider = 1.0;\n\n    float sequence = 1.0;\n    if (mod(p/4.0, 2.0) > 0.8) sequence = 2.0;\n\n    float f = 27.5 * (sequence + floor(mod(i,8.0)));\n    \n    if (mod(i,divider) < 0.5)\n    {\n        if (mod(i,6.0) < 0.5) {\n            result.x = f;\n        }\n        else {\n            result.y = f;\n        }\n    }\n    return result;\n}\n\nfloat synthesize(float freq, float time, float filter_) {\n    float sum = 0.0;\n    \n    float envelope = 2.0 - filter_ - (freq - 50.0) / 500.0;\n\n    for (float k=1.0; k<128.0; k++) {\n        float f =  k * freq * time;\n        if (f<1250.0*(0.2-time)) {\n          sum += sin(TWOPI * k * freq * time) / (pow(k,envelope));\n        }\n        else if (f<2500.0*(0.2-time)) {\n          sum += sin(TWOPI * k * freq * time) / (0.2 * pow(k,envelope));\n        }\n    }\n    return (sum/PI) * 0.8 * (envelope-0.5);\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float counter = floor(time*SPEED);\n    float barer   = floor(counter*0.25);\n    float count   = mod(counter, 16.0);\n    float bar     = mod(barer, 16.0);\n    float swell   = pow(mod(time*0.275, 8.0), 2.0) / 1.5;\n    float piece   = floor(barer/16.0);\n    float snaretime = fract((time*SPEED-4.0) / 8.0);\n    float beattime  = fract((time*SPEED) / 4.0);\n    if (bar>14.0) beattime = min(beattime, fract((time*SPEED) / 4.0 - 0.5)); //one extra beat at the end of the bar\n\n    vec2 note = notes(count, piece);\n\n    //the bass is a sawtooth with a small difference in pich between left and right to create a stereo effect\n    vec2 bass = vec2(synthesize(1.01*note.x, fract(time*SPEED)/8.0, fract(time*0.034375)), synthesize(0.99*note.y, fract(time*SPEED)/8.0, fract(time*0.034375)));\n    bass      = clamp(2.0*bass*exp(-1.6*(0.9-bar/16.0)*fract(time*SPEED)), -0.6, 0.6);\n    \n    //initially I wanted to do an organ like sound, but using an extra sin() function\n    //to distort the waveform and then overdoing that was more fun ;)\n    //vec2 organ = vec2(0.1, 0.1) * sin((5.0+swell)* sin(1.0 + 1.0*time) * sin(6.2831*110.0*time));\n    //organ     += vec2(0.0, 0.1) * sin((3.0+swell)* sin(0.4 + 1.3*time) * sin(6.2831*165.0*time));\n    //organ     += vec2(0.1, 0.0) * sin((2.0+swell)* sin(-0.1+ 1.6*time) * sin(6.2831*220.0*time));\n    //organ     += vec2(0.0,0.07) * sin((1.0+swell)* sin(-0.9+ 1.7*time) * sin(6.2831*275.0*time));\n    //organ     += vec2(0.07,0.0) * sin((0.8+swell)* sin(-1.2+ 1.8*time) * sin(6.2831*330.0*time));\n\n    //hihat and snare are simply whitenoise with a volume envelope\n    float noise = rand(vec2(floor(time),fract(time)));\n    vec2 hh = vec2(0.3, 0.6) * noise * exp(-10.0*fract(time*SPEED));\n    vec2 snare = vec2(0.9,0.3) * noise * exp(-10.0*snaretime);\n\n    //the beat is a sin who's frequency drops really quick with a volume envelope\n    //to remove the first tick and the lower then low frequencies at the end.\n    vec2 beat = vec2(1.0,1.0) * sin(25.0*log(beattime)) * min(beattime*10.0, exp(-5.0*beattime));\n\n    vec2 mixed = 0.9*(beat + snare + hh) + bass;// + 0.2*organ;\n\n    return clamp(mixed, vec2(-1.0, -1.0), vec2(1.0, 1.0));\n}\n","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sBSDz","date":"1410693089","viewed":919,"name":"Retro electro music","username":"Bart_Verheijen","description":"I just wanted to try out 100% generated sound (no samples used).","likes":25,"published":1,"flags":8,"usePreview":0,"tags":["music","electro","soundgeneration"],"hasliked":0,"parentid":"","parentname":""}}