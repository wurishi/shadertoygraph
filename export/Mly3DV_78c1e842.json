{"ver":"0.1","info":{"id":"Mly3DV","date":"1476815928","viewed":317,"name":"Kaleidoscope Britney","username":"roboshoes","description":"A Kaleidoscope implementation ... that pretty much sums it up.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589793\n#define TAU 6.283185307\n\nconst float radius = 200.0;\nconst float slices = 16.0;\nconst float maxSize = 2.0 * radius * cos( ( PI / 2.0 ) - ( ( TAU / slices ) / 2.0 ) );\n\nvec2 polarToCartesian( float angle, float r ) {\n    return vec2(\n        r * cos( angle ),\n        r * sin( angle )\n    );\n}\n\nvec3 drawCircle( vec2 center, vec2 vUV ) {\n\n    vec2 positionFromCenter = gl_FragCoord.xy - center;\n    float distancePercent = length( positionFromCenter ) / radius;\n\n    if ( distancePercent > 1.0 ) distancePercent = 1.0;\n\n    float piece = 1.0 / slices;\n\n    vec2 relativePosition = vUV - center;\n\n    vec2 positionDirection = normalize( positionFromCenter );\n\n    float angle = atan( positionDirection.y, positionDirection.x );\n    float anglePercent = ( 1.0 + ( angle / PI ) ) / 2.0;\n\n    float leftover = mod( anglePercent, piece );\n    float sectionPercent = leftover / piece;\n\n    float index = floor( anglePercent / piece );\n\n    if ( mod( index, 2.0 ) == 0.0 ) {\n        sectionPercent = 1.0 - sectionPercent;\n        leftover = piece - leftover;\n    }\n\n    vec2 uv = polarToCartesian( leftover * TAU, distancePercent * radius );\n\n    uv /= vec2( radius, maxSize );\n\n    vec2 triangleBox = vec2( radius, maxSize );\n    vec2 imageBox = iChannelResolution[ 0 ].xy;\n\n    vec2 scaleVector = triangleBox / imageBox;\n    float scale = max( scaleVector.x, scaleVector.y );\n\n    vec2 scaleBox = iChannelResolution[ 0 ].xy * scale;\n    vec2 startingPoints = scaleBox / 2.0 - triangleBox / 2.0;\n\n    vec2 coord = startingPoints + uv * triangleBox;\n\n    uv = coord / scaleBox;\n\n    return texture( iChannel0, uv ).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 center = iResolution.xy / 2.0;\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    vec2 upperLeft = center - vec2( radius );\n    vec2 upperRight = center + vec2( radius, - radius );\n    vec2 lowerRight = center + vec2( radius );\n    vec2 lowerLeft = center + vec2( -radius, radius );\n\n    vec2 xy = gl_FragCoord.xy;\n\n    float centerDistance = distance( xy, center );\n    float upperLeftDistance = distance( xy, upperLeft );\n    float upperRightDistance = distance( xy, upperRight );\n    float lowerRightDistance = distance( xy, lowerRight );\n    float lowerLeftDistance = distance( xy, lowerLeft );\n\n    vec2 points[ 5 ];\n    points[ 0 ] = center;\n    points[ 1 ] = upperLeft;\n    points[ 2 ] = upperRight;\n    points[ 3 ] = lowerRight;\n    points[ 4 ] = lowerLeft;\n\n    float distances[ 5 ];\n    distances[ 0 ] = centerDistance;\n    distances[ 1 ] = upperLeftDistance;\n    distances[ 2 ] = upperRightDistance;\n    distances[ 3 ] = lowerRightDistance;\n    distances[ 4 ] = lowerLeftDistance;\n\n    float smallest = max( iResolution.x, iResolution.y );\n    vec3 pixel;\n    \n    for ( int i = 0; i < 5; i++ ) {\n        if ( distances[ i ] < smallest ) {\n            smallest = distances[ i ];\n            fragColor = vec4( drawCircle( points[ i ], uv ), 1.0 );\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}