{"ver":"0.1","info":{"id":"ct2cWR","date":"1691658988","viewed":57,"name":"testsqr","username":"sqraaa","description":"testsqr","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["testsqr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void warp(vec2 fragCoord, out vec4 fragColor){\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // 从iChannel1中采样梯度信息\n    float gradient = texture(iChannel1, uv).r;\n\n    // 计算变换方向，这里使用梯度的法线作为方向\n    vec2 normal = vec2(dFdx(gradient), dFdy(gradient));\n    normal = normalize(normal);\n\n    // 计算偏移量，根据梯度决定偏移程度\n    float offsetAmount = gradient * 0.06;\n    vec2 offset = normal * offsetAmount;\n\n    // 对原始UV进行偏移\n    vec2 newUV = uv + offset;\n\n    // 在新的UV位置采样iChannel0纹理\n    vec3 color = texture(iChannel0, newUV).xyz;\n\n    fragColor = vec4(color, 1.0);\n}\n\n//我们计算出一个从原点指向不同方向的向量。然后，\n//我们将这个向量与一个偏移系数相乘，得到最终的偏移量\nvoid Directionalwarp(vec2 fragCoord, out vec4 fragColor){\n     vec2 uv = fragCoord / iResolution.xy;\n\n    // 从iChannel1中采样噪声值\n    float noise = texture(iChannel1, uv).r;\n\n    // 计算偏移方向\n    vec2 direction = vec2(cos(noise * 2.0 * 3.14159), sin(noise * 2.0 * 3.14159));\n\n    // 计算偏移量\n    float offsetAmount = noise * 0.06;\n    vec2 offset = direction * offsetAmount;\n\n    // 对原始UV进行偏移\n    vec2 newUV = uv + offset;\n\n    // 在新的UV位置采样iChannel0纹理\n    vec3 color = texture(iChannel0, newUV).xyz;\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n/*\n使用了iChannel1中的噪声图来生成模糊半径。根据噪声值，\n我们计算出一个模糊的半径大小。然后，我们在周围的几个不同方向上进行采样，\n根据半径生成偏移量，并从iChannel0中采样颜色。最后，\n我们将所有采样的颜色值取平均，作为最终的模糊颜色。\n*/\n\nvoid sBlur(vec2 fragCoord, out vec4 fragColor){\n      vec2 uv = fragCoord / iResolution.xy;\n\n    // 从iChannel1中采样噪声值\n    float noise = texture(iChannel0, uv).r;\n\n    // 计算模糊半径，根据噪声值\n    float blurRadius = noise * 0.1;\n\n    // 计算模糊采样\n    vec3 blurredColor = vec3(0.0);\n    int samples = 8; // 采样次数\n    for (int i = 0; i < samples; i++) {\n        // 计算采样偏移\n        float angle = float(i) * 3.14159 * 2.0 / float(samples);\n        vec2 offset = vec2(cos(angle), sin(angle)) * blurRadius;\n\n        // 在偏移后的位置采样iChannel0纹理\n        blurredColor += texture(iChannel0, uv + offset).xyz;\n    }\n\n    // 取平均值作为最终颜色\n    vec3 color = blurredColor / float(samples);\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 c )\n{\n vec2 uv = c / iResolution.xy;\n\twarp(c, fragColor);\n   // Directionalwarp(c, fragColor);\n   // sBlur(c,fragColor);\n   // fragColor =  texture(iChannel0, uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.y, iResolution.x);\n\n    // 计算圆心位置和半径\n    vec2 center = vec2(0, -0); // 居中位置\n    float radius = 0.6;\n\n    // 计算当前像素点到圆心的距离\n    float distanceToCenter = length(uv - center);\n\n    // 判断是否在圆内\n    float insideCircle = step(distanceToCenter, radius);\n\n    // 设置颜色\n    vec3 color = vec3(1.0, 0.0, 0.0); // 红色\n\n    // 将颜色应用到圆内的像素\n    fragColor = vec4(color * insideCircle, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}