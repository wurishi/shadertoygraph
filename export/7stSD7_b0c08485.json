{"ver":"0.1","info":{"id":"7stSD7","date":"1633384863","viewed":71,"name":"RGB and HSV gamuts","username":"rafastv","description":"Different channels of RGB and HSV color gamut (F = All channels or properties):\nG R.   |.   S H\n------------------\nB F.    |.   V. F","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["saturation","rgb","hsv","hue","value","colorchannels","gamuts","colordivision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define convert2hsv true\n\n// Copyright (C) 1999-2021 The Octave Project Developers\nvec3 rgb2hsv (vec3 rgb)\n{\n  float s = min (rgb.r, min(rgb.g, rgb.b));\n  float v = max (rgb.r, max(rgb.g, rgb.b));\n  float h = 0.;\n  bool notgray = !(s == v);\n\n  if ((v == rgb.b) && (notgray))\n    h = (2./3.) + ((1./6.) * (rgb.r - rgb.g) / (v - s));\n  if ((v == rgb.g) && (notgray))\n    h = (1./3.) + ((1./6.) * (rgb.b - rgb.r) / (v - s));\n  if ((v == rgb.r) && (notgray))\n    h =           ((1./6.) * (rgb.g - rgb.b) / (v - s));\n  \n  if (h < 0.)\n      h += 1.;   // correct for negative red\n  \n  if (notgray)\n      s = (1. - s/v);\n  else\n      s = 0.;\n      \n  return vec3(h, s, v);\n}\n\n// Copyright (C) 1999-2021 The Octave Project Developers\nvec3 hsv2rgb (vec3 hsv)\n{\n  float h = hsv.x;\n  float s = hsv.y;\n  float v = hsv.z;\n\n  vec3 rgb = vec3 (v * (1. - s));\n  vec3 hue = vec3(h-(2./3.), h, h-(1./3.));\n  vec3 f = vec3 (s * v);\n\n  for (int i=0; i<3; i++)\n  {\n      if (hue[i] < 0.) \n          hue[i] += 1.;\n      rgb[i] += f[i] * ((6. * float(hue[i] < (1./6.)) * hue[i])\n                   + (float((hue[i] >= (1./6.)) && (hue[i] < (1./2.))))\n                   + (float((hue[i] >= (1./2.)) && (hue[i] < (2./3.))) * (4. - 6. * hue[i])));\n  }\n  return rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.y - vec2(iResolution.x/iResolution.y,0.);\n    \n    vec3 col = texture(iChannel0, fract(uv)).rgb;\n\n    if (convert2hsv)\n        col = rgb2hsv(col);\n    \n    if (abs(uv.x) > 1.)\n        col = vec3(0.);\n    else if ((uv.x >  .0) && (uv.y >  1.))\n        col = col*vec3(1.,0.,0.) + float(convert2hsv)*vec3(0.,1.,1.);\n    else if ((uv.x <= .0) && (uv.y >  1.))\n        col = col*vec3(0.,1.,0.) + float(convert2hsv)*vec3(2./3.,0.,1.);\n    else if ((uv.x <= .0) && (uv.y <= 1.))\n        col *= vec3(0.,0.,1.);\n    else\n        col *= vec3(1.,1.,1.);\n    \n    if (convert2hsv)\n        col = hsv2rgb(col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*  Copyright (C) 2021 Rafael S. T. Vieira\n    \n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>.\n    \n    You may download the full license at https://www.gnu.org/licenses/gpl-3.0.en.html\n*/","name":"Image","description":"","type":"image"}]}