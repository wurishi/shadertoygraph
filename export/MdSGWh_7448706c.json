{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\t//constants for ray marching\n\tconst int max_iterations = 64;\n\tconst float stop_threshold = 0.01;\n\tconst float grad_step = 0.5;\n\tconst float clip_far = 1000.0;\n\n\t//constants for ambient oclusion\n\tconst int   ao_iterations = 1;\n\tconst float ao_step = 1.0;\n\tconst float ao_scale = 0.46;\n\n\t//math constants\n\tconst float PI = 3.14159265359;\n\tconst float DEG_TO_RAD = PI / 180.0;\n\n\tconst vec3 upColor = vec3(237.0, 246.0, 255.0) / 255.0;\n\tconst vec3 downColor = vec3(1.0);\n\n\t//rotation around X axis\n\tmat3 rotX(float angle) {\n\t\tangle *= DEG_TO_RAD;\n\t\treturn mat3(1.0, 0.0, 0.0,\n\t\t\t\t\t0.0, cos(angle), -sin(angle),\n\t\t\t\t\t0.0, sin(angle), cos(angle));\n\t}\n\t\n\t//rotation around Y axis\n\tmat3 rotY(float angle) {\n\t\tangle *= DEG_TO_RAD;\n\t\treturn mat3(cos(angle), 0.0, sin(angle),\n\t\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\t\t-sin(angle), 0.0, cos(angle));\n\t}\n\n\t//rotation around Z axis\n\tmat3 rotZ(float angle) {\n\t\tangle *= DEG_TO_RAD;\n\t\treturn mat3(cos(angle), -sin(angle), 0.0,\n\t\t\t\t\tsin(angle), cos(angle), 0.0,\n\t\t\t\t\t0.0, 0.0, 1.0);\n\t}\n\n\t//Distance to box\n\tfloat dBox(vec3 p, vec3 b) {\n\t\tb *= 0.5;\n\t\tvec3 d = abs(p) - b;\n\t\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t}\n\n\t//infinite Cilinder\n\tfloat dInfCil(vec3 p, float r) {\n\t\treturn length(p.xz) - r;\n\t}\n\n\t//Cilinder (finite)\n\tfloat dCil(vec3 p, float r, float h) {\n\t\treturn max( length(p.xz) - r, abs(p.y) - h * 0.5);\n\t}\n\n\t/*round sided box (can change the radius of the lower part).\n\t* ri... upper radius, rs... lower radius, h... height, w... width\n\t*/ \n\tfloat rsBox(vec3 p, float rs, float ri, float h, float w, float side) {\n\t\t\n\t\tvec3 p1 = p.xyz;\n\t\tp1 *= rotX(90.0);\n\t\tp1 -= vec3(0.0, 0.0, h * 0.5);\n\t\tfloat upperCil = dCil(p1, rs, w);\n\n\t\tp1 -= vec3(side * (rs - ri), 0.0, -h);\n\t\tfloat lowerCil = dCil(p1, ri, w);\n\n\t\tfloat box = dBox(p, vec3(2.0 * rs, h, w));\n\n\t\treturn min(min(upperCil, lowerCil), box);\n\t}\n\n\t//piston rod\n\tfloat biela(vec3 p) {\n\n\t\tp.y -= 171.2 * 0.5;\n\t\t\n\t\tfloat salida = dBox(p, vec3(50.0, 171.2, 18));\n\n\t\tfloat h = 110.0;\n\t\tfloat dy = 20.0;\n\t\tfloat rs = 22.5;\n\t\tfloat ri = 43.0;\n\t\tfloat dx = 17.7;\n\n\t\tfloat difSideRight = rsBox(p - vec3(rs + dx, dy, 0.0), rs, ri, h, 30.0, -1.);\n\t\tfloat difSideLeft = rsBox(p - vec3(- rs - dx, dy, 0.0), rs, ri, h, 30.0, 1.);\n\t\n\t\tsalida = max(salida, -min(difSideLeft, difSideRight));\n\n\t\tfloat dz = 13.0;\n\t\tfloat difFront = rsBox(p -vec3(0.0, 6.0, -dz), 8.0, 8.0, 85.0, 20.0, 1.);\n\t\tfloat difBack = rsBox(p - vec3(0.0, 6.0, dz), 8.0, 8.0, 85.0, 20.0, 1.);\n\n\t\tsalida =  max(salida, -min(difFront, difBack));\n\n\t\tvec3 p1 = p.xyz;\n\t\tp1 *= rotX(90.0);\n\t\tp1 -= vec3(0.0, 0.0, 85.6);\n\t\tfloat extCil = dCil(p1, 22.0, 38.0);\n\t\tfloat intCil = dInfCil(p1, 18.0);\n\n\t\tsalida = max(min(salida, extCil), -intCil);\n\n\t\tp1 = p.xyz;\n\t\tp1 *= rotX(90.0);\n\t\tp1 *= rotZ(90.0);\n\n\t\tfloat infSection = rsBox(p1 - vec3(0.0, 0.0, -85.6), 9.0, 9.0, 72.0, 60.0, 1.);\n\t\tsalida = min(salida, infSection);\n\n\t\tp1 = p.xyz;\n\t\tp1 *= rotX(90.0);\n\t\tp1 -= vec3(0.0, 0.0, -85.6);\n\t\tintCil = dInfCil(p1, 30.0);\n\n\t\tsalida = max(min(salida, extCil), -intCil);\n\n\t\tfloat difBox = dBox(p - vec3(0.0, -85.6, 0.0), vec3(150.0, 1.0, 100.0));\n\t\tsalida = max(salida, -difBox);\n\n\t\treturn salida;\n\t}\n\n\t//piston\n\tfloat piston(vec3 p) {\n\t\tfloat salida;\n\t\t\n\t\tfloat cil = dCil(p, 43.0, 58.1);\n\t\tsalida = cil;\n\n\t\tcil = dCil(p - vec3(0.0, 41.2, 0.0), 38.3, 24.3);\n\t\tsalida = min(salida, cil);\n\n\t\tcil = dCil(p- vec3(0.0, 57.0, 0.0), 43.0, 7.3);\n\t\tsalida = min(salida, cil);\n\t\t \n\t\tfor(int i = 0; i < 2; i++) {\n\t\t\tfloat dy = 36.25 + 10.0 * float(i);\n\t\t\tcil = dCil(p - vec3(0.0, dy, 0.0), 43.0, 5.7);\n\t\t\tsalida = min(salida, cil);\n\t\t}\n\n\t\tcil = dInfCil(p * rotX(90.0) - vec3(0.0, 0.0, 4.0), 16.9);\n\t\tsalida = max(salida, -cil);\n\n\t\tcil = dCil(p- vec3(0.0, -20.0, 0.0), 35.0, 100.0);\n\t\tsalida = max(salida, -cil);\n\n\t\tcil = dCil(p * rotX(90.0) - vec3(0.0, 0.0, 4.0), 16.5, 86.0);\n\t\tsalida = min(salida, cil);\n\n\t\tcil = dInfCil(p * rotX(90.0) - vec3(0.0, 0.0, 4.0), 13.0);\n\t\tsalida = max(salida, -cil);\n\n\t\tcil = dInfCil(p * rotX(90.0) * rotZ(90.0) - vec3(0.0, 0.0, -70.0), 60.0);\n\t\tsalida = max(salida, -cil);\t\t\n\n\t\treturn salida;\n\t}\n\n\t//crankshaft\n\tfloat ciguenal(vec3 p) {\n\n\t\tfloat salida = dCil(p - vec3(44.0, 0.0, 0.0), 32.0, 45.0);\n\t\tfloat shape = rsBox(p * rotZ(90.0) * rotY(90.0) -vec3(0.0, 20.0, 30.5), 40.0, 40.0, 40.0, 16.0, 1.);\n\t\tsalida = min(salida, shape);\n\n\t\tshape = rsBox(p * rotZ(90.0) * rotY(90.0) -vec3(0.0, 20.0, -30.5), 40.0, 40.0, 40.0, 16.0, 1.);\n\t\tsalida = min(salida, shape);\n\n\t\tshape = dCil(p - vec3(0.0, 57.5, 0.0), 32.0, 38.0);\n\t\tsalida = min(salida, shape);\n\n\t\tshape = dCil(p - vec3(0.0, 73.5, 0.0), 16.0, 70.0);\n\t\tsalida = min(salida, shape);\n\n\t\tshape = dCil(p - vec3(0.0, -57.5, 0.0), 32.0, 38.0);\n\t\tsalida = min(salida, shape);\n\n\t\tfloat wheel = dCil(p - vec3(0.0, -84.0, 0.0), 72.0, 15.0);\n\t\t\n\t\t\n\t\tfloat hole;\n\t\tvec3 d;\n\t\tfor(int i = 0; i < 8; i++) {\n\t\t\td.x = 54.0 * cos(PI * float(i) * 0.25);\n\t\t\td.z = 54.0 * sin(PI * float(i) * 0.25);\n\t\t\thole = dInfCil(p - d, 7.0);\n\t\t\twheel = max(wheel, -hole);\n\t\t}\n\t\t\n\n\t\tsalida = min(salida, wheel);\n\n\t\treturn salida;\t\n\t}\n\n\tvec2 dist_field(vec3 p) {\n\n\t\t\n\t\tp.y -= 10.0;\n\t\tvec3 pp = p.xyz;\n\t\tpp.y += 200.0;\n\n\t\tp*= rotY(45.0);\n\n\t\tvec3 pC = p.xyz;\n\t\tp.y += 100.0;\n\t\t\n\t\tvec3 pB = p.xyz;\n\t\tfloat alfa = 300.0 * iTime * DEG_TO_RAD;\n\t\tfloat u = 44.0 * sin(alfa);\n\t\tfloat v = 44.0 * cos(alfa);\n\t\tpB.y += v;\n\t\tpB.x -= u;\n\n\t\tfloat beta = asin(u / (171.2)) * 180.0 / PI;\n\t\tpB *= rotZ(-beta);\n\t\t\t \t\t\n\t\tvec2 biela1 = vec2(biela(pB), 0.0);\n\t\t\n\t\tfloat h = 42.9 * (1.0 - cos(alfa) - 30.0 * sin(alfa) * sin(alfa) / 171.2);\n\t\tp.y -= h + 114.8;\n\t\tvec2 piston1 = vec2(piston(p), 1.0);\n\t\t\n\t\tpC.y += 100.0;\n\t\tpC *= rotX(90.0);\n\t\tpC *= rotY(300.0 * iTime - 90.0);\n\t\t\n\t\tvec2 ciguenal1 = vec2(ciguenal(pC), 2.0);\n\t\t\n\t\tvec2 salida = biela1;\n\t\tif(piston1.x < salida.x) salida = piston1;\n\t\tif(ciguenal1.x < salida.x) salida = ciguenal1;\n\t\t\n\t\treturn salida;\n\t\t\n\n\t}\n\n\t// ao\n\tfloat ao( vec3 v, vec3 n ) {\n\t\tfloat sum = 0.0;\n\t\tfloat att = 1.0;\n\t\tfloat len = ao_step;\n\t\tfor ( int i = 0; i < ao_iterations; i++ ) {\n\t\t\tsum += ( len - dist_field( v + n * len ).x ) * att;\n\t\t\tlen += ao_step;\n\t\t\tatt *= 0.5;\n\t\t}\n\t\treturn max( 1.0 - sum * ao_scale, 0.0 );\n\t}\n\n\n\t// get gradient in the world\n\tvec3 gradient( vec3 v ) {\n\t\tconst vec3 delta = vec3( grad_step, 0.0, 0.0 );\n\t\treturn normalize (\n\t\t\tvec3(\n\t\t\t\tdist_field( v + delta.xyy).x - dist_field( v - delta.xyy).x,\n\t\t\t\tdist_field( v + delta.yxy).x - dist_field( v - delta.yxy).x,\n\t\t\t\tdist_field( v + delta.yyx).x - dist_field( v - delta.yyx).x\t\t\t\n\t\t\t)\n\t\t);\n\t}\n\n\t// ray marching\n\tvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\tfloat depth = start;\n\t\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\t\tvec2 dist = dist_field( origin + dir * depth );\n\t\t\tif ( dist.x < stop_threshold ) return vec2(depth, dist.y);\n\t\t\tdepth += dist.x;\n\t\t\tif ( depth >= end) break;\n\t\t}\n\t\treturn vec2(end);\n\t}\n\n\t// shadow\n\tfloat shadow( vec3 v, vec3 light ) {\n\t\tvec3 lv = v - light;\n\t\tfloat end = length( lv );\n\t\tlv /= end;\n\t\n\t\tfloat depth = ray_marching( light, lv, 0.0, end ).x;\n\t\n\t\treturn step( end - depth, 0.02 );\n\t}\n\n\t// phong shading\n\tvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t\n\t\tvec3 final = vec3( 0.0 );\n\t\n\t\tvec3 ev = normalize( v - eye );\n\t\tvec3 ref_ev = reflect( ev, n );\n\t\n\t\t// light 0\n\t\t{\n\t\t\tvec3 light_pos   = vec3(0.0, 500.0, -1000.0);\n\t\t\tvec3 vl = normalize( light_pos - v );\n\t\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\t\tspecular = pow( specular, 128.0 );\n\t\t\tfinal += vec3( 0.9 ) * ( diffuse * 0.4 + specular * 0.9 ) * shadow( v, light_pos ); \n\t\t}\n\t\t\n\t\tfinal += ao( v, n ) * vec3( 0.15 );\n\t\n\t\treturn final;\n\t}\n\n\t// get ray direction\n\tvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\t\tvec2 xy = pos - size * 0.5;\n\n\t\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\t\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\t\treturn normalize( vec3( xy, z ) );\n\t}\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\n\t\t// default ray dir\n\t\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\t\n\t\t// default ray origin\n\t\tvec3 eye = vec3( 0.0, 0.0, -550.0 );\n\t\n\t\t// ray marching\n\t\tvec2 data = ray_marching( eye, dir, 0.0, clip_far );\n\n\n\t\t// shading\n\t\tvec3 pos = eye + dir * data.x;\n\t\tvec3 n = gradient( pos );\n\t\tvec3 lightColor =  shading( pos, n, eye ) * 2.0;\n\t\tvec3 color = vec3(0.);\n\t\tif(data.y == 0.0) color = vec3(0.5) * lightColor;\n\t\tif(data.y == 1.0) color = vec3(1.0) * lightColor;\n\t\tif(data.y == 2.0) color = vec3(1.0) * lightColor;\n\t\t\n\t\t// desat\n\t\tcolor = mix( color, vec3(dot(color,vec3(0.33))), 0.3);\n\t\t\n    \t// gamma\n\t\tcolor = pow( color, vec3(0.45) );\n\n\t\tfragColor = vec4(color, 1.0 );\n\t} \n\t\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdSGWh","date":"1386768673","viewed":217,"name":"crankshaft animation","username":"hat","description":"    Based on the code from gltracy.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""}}