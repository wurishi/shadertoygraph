{"ver":"0.1","info":{"id":"MstGDH","date":"1449884695","viewed":210,"name":"shiny glowing dancing shapes","username":"public_int_i","description":"shiny","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shapes","shiny","dancing","glowing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4slGzH","filepath":"https://soundcloud.com/gravitas-recordings/error-cryptex","previewfilepath":"https://soundcloud.com/gravitas-recordings/error-cryptex","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//Ethan Shulman/public_int_i 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//thanks to iq for the great tutorials, code and information\n//thanks to XT95 for the ambient occlusion function\n\n\n//if its running too slowly comment '#define global_illumination 1' on line 35\n\n\n\n#define FOV_SCALE 2.\n#define ITERATIONS 86\n#define EPSILON .01\n#define NORMAL_EPSILON .012\n\n#define VIEW_DISTANCE 64.\n\n#define pi 3.141592\n\nvec3 cameraLocation;\nvec2 cameraRotation;\n\n\nstruct material {\n    vec3 diffuse,specular,emissive;\n    float metallic,roughness;\n};\nstruct light {\n    vec3 position, color;\n    float size;\n};\n    \n\n#define global_illumination 1\n#define gi_background 1\n#define gi_trace_iter 16\nconst float global_illumination_strength = .3,\n    \t\tglobal_illumination_reach = 16.;\n\nconst vec3 ambient = vec3(0.0);\n\n\n#define nLights 0\n\n#if nLights != 0\nlight lights[nLights];\n#endif    \n\nvoid initLights() {\n    #if nLights != 0\n\t#endif\n}\n\n//distance functions from iq's site\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n    \n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\n//polynomial smooth min from iq's site\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//exp smooth min\nfloat exp_smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat ground(in vec3 rp) {\n    return abs(rp.y-5.);\n}\nvec3 groundTexture(in vec3 rp) {\n    return texture(iChannel0,rp.xz*.1).xyz;\n}\n\n\nfloat mainObject(in vec3 rp) {\n    vec2 lp = abs(mod(abs(rp.xz), 10.)-5.);\n    vec2 freqp = floor(abs(rp.xz)/10.);\n    freqp.x = mod(freqp.x*.05+freqp.y*.4,1.);\n    freqp.x *= .25;\n    \n    float prismStr = texture(iChannel2,vec2(freqp.x,.25)).x;\n    vec3 prismPos = vec3(lp,-rp.y+6.-prismStr*16.).xzy;\n    prismPos.yz = rot(prismPos.yz, iTime-prismStr*10.);\n    \n\treturn smin(udBox(vec3(lp,rp.y-12.+texture(iChannel2,vec2(freqp.x,.1)).x*24.).xzy,vec3(.5,3.,.5)),\n             smin(sdTriPrism(prismPos,vec2(3.,1.)),\n                  length(vec3(lp,rp.y-10.+texture(iChannel2,vec2(freqp.x+.5,.25)).x*22.).xzy)-2., 2.), 2.);\n}\nvec3 mainObjectTexture(in vec3 rp) {\n    return texture(iChannel1,(abs(rp.xy)+abs(rp.zz))*.04).xyz;\n}\n\nfloat df(in vec3 rp) {\n\n    return min(ground(rp),mainObject(rp));\n}\nfloat df_hq(in vec3 rp) {\n\n   // return df(rp);\n    return min(ground(rp)-length(groundTexture(rp))*.004,\n               mainObject(rp)-length(mainObjectTexture(rp))*.1);\n}\n\n\n\nconst vec3 ne = vec3(NORMAL_EPSILON,0.,0.);\nvec3 normal2(in vec3 rp) {\n    return normalize(vec3(df(rp+ne)-df(rp-ne),\n                          df(rp+ne.yxz)-df(rp-ne.yxz),\n                          df(rp+ne.yzx)-df(rp-ne.yzx)));\n}\n\n\nvec3 normal(in vec3 rp) {\n    return normalize(vec3(df_hq(rp+ne)-df_hq(rp-ne),\n                          df_hq(rp+ne.yxz)-df_hq(rp-ne.yxz),\n                          df_hq(rp+ne.yzx)-df_hq(rp-ne.yzx)));\n}\n\n\nmaterial mat(vec3 rp) {\n    material m;\n    \n    if (mainObject(rp) < EPSILON) {\n            vec2 freqp = floor(abs(rp.xz)/10.);\n            freqp.x = mod(freqp.x*.05+freqp.y*.4,1.);\n        \tfreqp.x *= .5;\n       \t\tfreqp.y = .1;\n        \n        \tfloat str = texture(iChannel2, freqp).x;\n        \tfreqp.x += str*.3;\n        \n                m = material(vec3(.74,.54,.65), //diffuse\n                     vec3(.74,.54,.65), //specular\n                  \t (vec3(cos(freqp.x*64.24),cos(freqp.x*59.324+.441),cos(freqp.x*49.345+1.83))*.5+.5)*max(0.,str*2.-1.), //emissive\n                    .8,//metallic\n                     0.01);//roughness\n    }\n    \n    if (ground(rp) < EPSILON) {\n        m = material(vec3(.85,.84,.95), //diffuse\n                     vec3(.85,.84,.95), //specular\n                     vec3(0.), //emissive\n                     0.,//metallic\n                     0.9);//roughness\n    }\n    \n    return m;\n}\n\n\n\n//rp = ray pos\n//rd = ray dir\n//maxDist = max trace distance\n//returns -1 if nothing is hit\nfloat trace(in vec3 rp, inout vec3 rd, float maxDist) {\n    \n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON || s > maxDist) break;\n        s += d;\n        \n        //rd = normalize(rd+vec3(.01,-.001,0.)*d);\n    }\n    \n    if (d < EPSILON) return s;\n    \n    return -1.0;\n}\n\nvec3 randomHemiRay(in vec3 d, in vec3 p, in float amount) {\n    return normalize(d+cos(p*245.245-d*cos(p*9954.345)*3532.423)*amount);\n}\n//ambient occlusion function is XT95's from https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion(in vec3 rp, in vec3 norm) {\n    float sum = 0., s = 0.;\n    \n    for (int i = 0; i < 16; i++) {\n        sum += max(0., s-df(rp+randomHemiRay(norm,rp,.3)*s));//randomHemiRay(norm,rp,.5)*s);\n        s += .05;\n    }\n    \n    return clamp(1.-sum*.1, 0., 1.);\n}\n\nfloat softShadowTrace(in vec3 rp, in vec3 rd, in float maxDist, in float penumbraSize, in float penumbraIntensity) {\n    vec3 p = rp;\n    float sh = 0.;\n    float d,s = 0.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        d = df(rp+rd*s);\n        sh += max(0., penumbraSize-d)*float(s>penumbraSize*4.);\n        s += d;\n        if (d < EPSILON || s > maxDist) break;\n    }\n    \n    if (d < EPSILON) return 0.;\n    \n    return max(0.,1.-sh/penumbraIntensity);\n}\n\nvec3 background(in vec3 rd) {\n    if (rd.y > 0.) return vec3(0.);\n    \n    vec3 bgc = vec3(0.);\n    vec2 uv = vec2(atan(rd.x, rd.y), rd.z*pi);\n    float tex = max(0., texture(iChannel2, uv/(pi*4.)).x*2.-1.);\n    \n    return vec3(\nlength(max( mod(abs(uv*10.+texture(iChannel0,iTime*.2+uv+cos(uv.yx*4.2345)).yz*4.*tex),4.)-2.-.5,0.))*tex);\n}\nvec3 background_gi(in vec3 rd) {\n    return background(rd);\n}\n\nvec3 locateSurface(in vec3 rp) {    \n    vec3 sp = rp;\n    for (int i = 0; i < 3; i++) {\n        float sd = abs(df(rp));\n        if (sd < EPSILON) return sp;\n        sp += normal2(sp)*sd*.5;\n    }\n    return sp;\n}\nvoid lighting(in vec3 td, in vec3 sd, in vec3 norm, in vec3 reflDir, in material m, inout vec3 dif, inout vec3 spec) {\n    float ao = ambientOcclusion(td,norm);\n    dif = ambient*ao;\n    spec = vec3(0.);\n        \n    #if nLights != 0\n    for (int i = 0; i < nLights; i++) {\n        vec3 lightVec = lights[i].position-td;\n        float lightAtten = length(lightVec);\n        lightVec = normalize(lightVec);\n        float shadow = softShadowTrace(sd, lightVec, lightAtten, 0.3, 1.5);\n        lightAtten = max(0., 1.-lightAtten/lights[i].size)*shadow;\n        \n    \tdif += max(0., dot(lightVec,norm))*lights[i].color*lightAtten;\n        spec += pow(max(0., dot(reflDir, lightVec)), 4.+(1.-m.roughness)*78.)*shadow*lights[i].color;\n    }\n\t#endif\n    \n    dif *= .5+ao*.5;\n}\n\n//copy of shade without reflection trace\nvec3 shadeNoReflection(in vec3 rp, in vec3 rd, in vec3 norm, in material m) {\n    vec3 sd = rp+norm*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 reflDir = reflect(rd,norm);\n\n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n\n    return (1.-m.metallic)*lightDif*m.diffuse +\n        \t(.5+m.metallic*.5)*lightSpec*m.specular +\n        \tm.emissive ;\n}\nvec3 giTrace(in vec3 rp, in vec3 rd) {\n    float s = 0., d;\n    for (int k = 0; k < gi_trace_iter; k++) {\n        d = df(rp+rd*s);\n        if (d < EPSILON) break;\n        s += d;\n    }\n    if (d < EPSILON) {\n        vec3 hp = rp+rd*s;\n        return shadeNoReflection(hp, rd, normal(hp), mat(hp))*max(0.,1.-s/global_illumination_reach);\n    }\n    #ifdef gi_background\n    return background_gi(rd);\n    #endif\n    return vec3(0.);\n}\nvec3 shade(in vec3 rp, in vec3 rd, in vec3 norm, material m) {\n    vec3 sd = rp+norm*EPSILON*10.;//locateSurface(rp)-rd*EPSILON*2.;\n    \n    //lighting\n    vec3 dlc = vec3(0.);\n    \n    #ifdef global_illumination\n    vec3 ray = norm;\n    vec3 majorAxis = abs(ray);\n    if (majorAxis.x > majorAxis.y) {\n        if (majorAxis.x > majorAxis.z) {\n            majorAxis = vec3(1.,0.,0.);\n            if (ray.x == 1.) ray = vec3(0.999,0.001,0.0);\n        } else {\n            majorAxis = vec3(0.,0.,1.);\n            if (ray.z == 1.) ray = vec3(0.,0.001,0.999);\n        }\n    } else {\n        if (majorAxis.y > majorAxis.z) {\n            majorAxis = vec3(0.,1.,0.);\n            if (ray.y == 1.) ray = vec3(0.,0.999,0.001);\n        } else {\n            majorAxis = vec3(0.,0.,1.);\n            if (ray.z == 1.) ray = vec3(0.,0.001,0.999);\n        }\n    }\n    \n    vec3 rayRight = normalize(cross(majorAxis,ray))*.5;\n    vec3 rayUp = normalize(cross(ray,rayRight))*.5;\n\n    vec3 gi = giTrace(sd, norm);\n    gi += giTrace(sd, normalize(norm+rayRight));\n    gi += giTrace(sd, normalize(norm-rayRight));\n    gi += giTrace(sd, normalize(norm+rayUp));\n    gi += giTrace(sd, normalize(norm-rayUp));\n    dlc += gi*global_illumination_strength;\n    #endif\n    \n    vec3 slc;\n    vec3 reflDir = reflect(rd,norm);\n    vec3 tReflDir = normalize(reflDir+cos(rp*245.245-rd*cos(rp*9954.345)*3532.423)*m.roughness*0.25);\n    tReflDir *= sign(dot(tReflDir,reflDir));\n    \n    float rtd = trace(sd,tReflDir,VIEW_DISTANCE);\n    if (rtd < 0.) {\n        slc = background(tReflDir);\n    } else {\n        vec3 rhp = sd+tReflDir*rtd;\n        slc = shadeNoReflection(rhp,reflDir,normal(rhp),mat(rhp));\n    }\n    \n    vec3 lightDif,lightSpec;\n    lighting(rp,sd,norm,reflDir,m,lightDif,lightSpec);\n    dlc += lightDif;\n    slc += lightSpec;\n    \n    float fres = max(0., dot(-rd,norm));\n    \n    return (1.-m.metallic)*dlc*m.diffuse +\n        \tslc*m.specular*((.5-m.metallic*.5)*fres+m.metallic*(.5+m.metallic*.5)) +\n        \tm.emissive ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n\tvec2 uv = (fragCoord.xy - R*.5)/R.x;\n\n    initLights();\n    \n  \n    vec2 mxy = (iMouse.xy/iResolution.xy);\n    mxy.y -= 1.;\n    mxy *= 6.28;\n    if (iMouse.w < 1.) {\n        mxy = vec2(-iTime*.1+1.71,-3.9);\n    }\n    cameraRotation = vec2(-mxy.x,mxy.y/4.+2.4);//x = yaw ,   y = pitch\n    cameraLocation = vec3(sin(iTime*.02)*100.,\n                          -12.+cos(iTime)*5.,\n                          cos(iTime*.03174)*100.);\n\n    \n    vec3 rp = cameraLocation;\n    vec3 rd = normalize(vec3(uv*vec2(1.,-1.)*FOV_SCALE,1.));\n\n    rd.yz = rot(rd.yz,cameraRotation.y);\n    rd.xz = rot(rd.xz,cameraRotation.x);\n    \n    rp += rd*5.;\n    \n\tfloat itd = trace(rp,rd,VIEW_DISTANCE);\n    if (itd < 0.) {\n        fragColor = vec4(background(rd),1.);\n        return;\n    }\n    \n\n    vec3 hp = rp+itd*rd;\n    #ifndef PATH_TRACE\n    fragColor = vec4(mix(shade(hp,\n                      rd,\n                      normal(hp),\n                      mat(hp)), background(rd), max(0.,itd/VIEW_DISTANCE)),1.);\n\t#else\n    \n    #endif\n}","name":"","description":"","type":"image"}]}