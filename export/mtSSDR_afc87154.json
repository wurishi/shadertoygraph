{"ver":"0.1","info":{"id":"mtSSDR","date":"1676018437","viewed":452,"name":"Bubble Heaven","username":"ChunderFPV","description":"Turn off AA if its too slow: line 17.\n\nThis one uses mipmap anti-aliasing instead: https://www.shadertoy.com/view/cljSD1","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","spheres","aa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define H(a) (cos(radians(vec3(0, -60, -120))-((a)*6.2832))*.5+.5) // hue pallete\n#define RT(a) mat2(cos(m.a*1.571+vec4(0,-1.571,1.571,0))) // rotate\n#define G(v) H(v)*g(v) // quick grid\n#define L(v) length(v) // quick radius\n\nfloat g(float x) // fancy grid\n{\n    float l = max(0., 1.-(abs(fract(x+.5)-.5)/fwidth(x)/1.5)), // lines\n          g = 1.-abs(sin(x*3.1416)), // glow\n          d = min(1., 1./abs(x));    // darken\n    return (l+g*.4)*d;\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    int   loop = 35; // raymarch loop\n    float aa = 2.,   // 1 = off\n          t = iTime/20.,\n          d, s;\n    vec2  R = iResolution.xy,\n          m = iMouse.xy/R*4.-2.,  // mouse coords\n          ao;\n    vec3  c = vec3(0),            // background\n          o = vec3(.5, .5, t/2.), // camera\n          u, p, l, v;\n    \n    if (iMouse.z < 1.) m = vec2(0, .15); // adjust camera position\n    \n    for (int k = 0; k < int(aa*aa); k++) // aa loop\n    {\n        ao = vec2(k%2, k/2)/aa; // aa offset\n        u = normalize(vec3((U-.5*R+ao)/R.y, .75)); // ray direction\n        u.yz *= RT(y); // pitch\n        u.xz *= RT(x); // yaw\n        d = 0.;\n        p *= 0.;\n        for (int i = 0; i < loop; i++) // raymarch\n        {\n            p = o+u*d; // position along ray\n            p.z += round(abs(p.y-.5)+.5)*t; // movement\n            s = smoothstep(.1, .15, L(p-round(p)) ); // sphere grid\n            if (s < .01) break;\n            d += s;\n        }\n        v = vec3(d/float(loop)); // gradient of objects\n        v = H(v+sin(t)*.2)*(1.-v); // color\n        l = 1.-vec3( L(u.yz), L(u.xz), L(u.xy) ); // spots at xyz\n        v *= max(max(l.x, l.y), l.z)*4.+.5; // contrast & highlight\n        if (u.y < 0.) v += G(u.x/u.y) + G(u.z/u.y-mod(t*2., 1.)) + .1; // floor grid\n        v = max(v, .4-H(-d)); // fringe color\n        v += min(1., 1.-L(u.xy)*1.2)*v; // adjust brightness\n        c += v;\n    }\n    c /= aa*aa; // fix brightness after aa\n    \n    C = vec4(c*c, 1);\n}","name":"Image","description":"","type":"image"}]}