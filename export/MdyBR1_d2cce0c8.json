{"ver":"0.1","info":{"id":"MdyBR1","date":"1527606701","viewed":331,"name":"Better Reflections","username":"noxbuds","description":"Playing around with an idea I had. Update 25/09/2018: Added better movement. Makes it more interesting","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////\n//                                             //\n//  Attempting to create reflections inside    //\n//  reflections, instead of just having one    //\n//  reflection like my original shader.        //\n//                                  - Noxbuds  //\n//                                             //\n/////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\t// Setup pixel colour\n    vec3 col = vec3(0.0);\n    \n    // Sample Buf A (normal image)\n    vec3 bufA = texture(iChannel0, uv).rgb;\n    \n    // Sample Buf B (bloom)\n    vec3 bufB = texture(iChannel1, uv * 0.25 + 0.5).rgb;\n    \n    // Add them\n    col = bufA * 0.7 + bufB * 0.5;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////\n//                                             //\n//  Buffer A renders the scene to a texture,   //\n//  so that it can have post-processing stuff  //\n//  done to it to make it look better.         //\n//                                             //\n/////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.142\n#define GLASS_IOR 1.15\n\nvec3 lightDir = normalize(vec3(-0.4, -0.6, 0.4));\n\n/////////////////////////////////////////////////\n//                                             //\n//              NOISE GENERATION               //\n//                                             //\n/////////////////////////////////////////////////\n\n// 2D value noise\nfloat noisev(vec2 p)\n{\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0) * 5647.0);\n}\n\n// Smoother noise\nfloat noise(vec2 uv)\n{\n    // Noise vector\n    vec2 nv = vec2(0.0);\n    \n    // Local positions\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    // Interpolate lv\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    // Calculate each corner\n    float bl = noisev(id);\n    float br = noisev(id + vec2(1, 0));\n    float tl = noisev(id + vec2(0, 1));\n    float tr = noisev(id + vec2(1, 1));\n    \n    // Interpolate values\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float n = mix(b, t, lv.y);\n    \n    // Return n\n    return n;\n}\n\n// FBM function\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p+vec2(0.0, 1.0)); p *= 2.02;\n    f += 0.1250 * noise(p+vec2(1.0, 0.0)); p *= 2.03;\n    f += 0.0625 * noise(p+vec2(1.0, 1.0)); p *= 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//             DISTANCE FUNCTIONS              //\n//                                             //\n/////////////////////////////////////////////////\n\n// Returns the maximum value in a vector\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\n// Sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Cube\nfloat sdBox(vec3 p, vec3 D)\n{\n    vec3 d = abs(p) - D;\n    return length(max(d, 0.0)) - max3(min(d, 0.0));\n}\n\n// Combine two objects\nvec2 combine(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              SCENE CREATION                 //\n//                                             //\n/////////////////////////////////////////////////\n\n// Draws a chair\nfloat chair(vec3 p)\n{\n    // Setup v\n    float v = 0.0;\n    \n    // Draw the chair\n    v = sdBox(p, vec3(0.5, 0.05, 0.5));\n    \n    // Draw the legs\n    v = min(v, sdBox(p + vec3(-0.45, 0.5, 0.45), vec3(0.05, 0.5, 0.05)));\n    v = min(v, sdBox(p + vec3(0.45, 0.5, -0.45), vec3(0.05, 0.5, 0.05)));\n    v = min(v, sdBox(p + vec3(-0.45, 0.5, -0.45), vec3(0.05, 0.5, 0.05)));\n    v = min(v, sdBox(p + vec3(0.45, 0.5, 0.45), vec3(0.05, 0.5, 0.05)));\n    \n    // Return it\n    return v;\n}\n\n// Draws a table\nfloat table(vec3 p)\n{\n    // Setup v\n    float v = 0.0;\n    \n    // Draw the table\n    v = sdBox(p, vec3(0.8, 0.05, 0.8));\n    \n    // Draw the legs\n    v = min(v, sdBox(p + vec3(-0.65, 0.65, 0.65), vec3(0.05, 0.6, 0.05)));\n    v = min(v, sdBox(p + vec3(0.65, 0.65, -0.65), vec3(0.05, 0.6, 0.05)));\n    v = min(v, sdBox(p + vec3(-0.65, 0.65, -0.65), vec3(0.05, 0.6, 0.05)));\n    v = min(v, sdBox(p + vec3(0.65, 0.65, 0.65), vec3(0.05, 0.6, 0.05)));\n    \n    // Return it\n    return v;\n}\n\n// Map function\nvec2 map(vec3 p)\n{\n    // v is the raymarch data\n    vec2 v = vec2(0.0);\n    \n    // Draw a reflective sphere\n    v = vec2(sdSphere(p + vec3(-0.8, 0.15, 1.2), 0.4), 4.0);\n    \n    // Draw another sphere\n    v = combine(v, vec2(sdSphere(p + vec3(-1.6, 0.15, 1.2), 0.4), 0.0));\n    \n    // Draw a glass box\n    v = combine(v, vec2(sdBox(p + vec3(0.1, 0.35, 1.5), vec3(0.4, 0.4, 0.1)), 3.0));\n    \n    // Draw the table\n    v = combine(v, vec2(table(p + vec3(-1.2, 0.5, 1.5)), 1.0));\n    \n    // Draw a chair\n    v = combine(v, vec2(chair(p + vec3(0.2, 0.8, 1.5)), 1.0));\n    \n    // Draw a mirror\n    v = combine(v, vec2(sdBox(p + vec3(-1.0, 0.0, -2.0), vec3(3.0, 2.0, 0.5)), 0.0));\n    \n    // Draw the floor\n    v = combine(v, vec2(sdBox(p + vec3(0.0, 2.2, 0.0), vec3(10.0, 0.48, 10.0)), 2.0));\n    \n    // Return v\n    return v;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              LIGHTING/SHADING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Calculate the normal of a point\nvec3 calcNormal(vec3 p)\n{\n    vec2 eps = vec2(0.002, 0.0);\n    return normalize(vec3(\n        map(p + eps.xyy).x - map(p - eps.xyy).x,\n        map(p + eps.yxy).x - map(p - eps.yxy).x,\n        map(p + eps.yyx).x - map(p - eps.yyx).x\n    ));\n}\n\n// Softer shadows\nfloat sshadow(vec3 o, vec3 r, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for (float t = mint; t < maxt;)\n    {\n        float h = map(o + r * t).x;\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// Diffuse shading\nvec3 diffuse(vec3 c, vec3 n)\n{\n    return c * max(dot(-lightDir, n), 0.0);\n}\n\n// Specular\nvec3 specular(vec3 c, vec3 n, vec3 r)\n{\n    // Calculate diffuse\n    c = diffuse(c, n);\n    \n    // Calculate specular highlight\n    vec3 rr = reflect(-lightDir, n);\n    float spec = max(0.0, dot(rr, r));\n    \n    // Add in the specular hightlights\n    float ks = 0.5;\n    return c * (1.0 - ks) + ks * spec;\n}\n\n// Cuboid UV mapping\nvec2 cuboidUV(vec3 p, vec3 n)\n{\n    // Setup UV co-ordinates\n    vec2 uv = vec2(0.0);\n    \n    // Since this is just used for cuboids, we can just take\n    // two components of p based on the normal's direction,\n    // seeing as the normal will only be like (0,1,0) or (1,0,0)\n    if (abs(n.x) > 0.9)\n        uv = p.yz;\n    if (abs(n.y) > 0.9)\n        uv = p.xz;\n    if (abs(n.z) > 0.9)\n        uv = p.xy;\n    \n    // Return UV\n    return uv;\n}\n\n// Material function\nvec4 material(float id, vec3 p, vec3 n, vec3 r, out bool hitDiffuse)\n{\n    // By default, set 'hitDiffuse' to false\n    hitDiffuse = false;\n    \n    // Shade different materials differently\n    if (id == 1.0)\n    {\n        // ID 1 is the table + chair\n        // Here I'm aiming for a sort of polished granite look;\n        // noisy and rocky colouring, but smooth and reflective.\n        \n        // Setup colour\n        vec3 col = vec3(0.8);\n        \n        // Get UV co-ordinates\n        vec2 uv = cuboidUV(p, n);\n        \n        // Add a noise texture\n        col *= 0.4 + 0.6 * fbm(abs(uv) * 25.0);\n        \n        // Diffuse shading\n        return vec4(diffuse(col, n), 0.2);\n    }\n    else if (id == 2.0)\n    {\n        // Blue reflective\n        // For this I want a checkered floor (like a chess board)\n        // using blue and dark blue colours.\n        \n        // Setup colour\n        vec3 col = vec3(0.2, 0.6, 0.9);\n        \n        // Get UV co-ordinates\n        vec2 uv = cuboidUV(p, n);\n        \n        // Calculate cell co-ordinates\n        vec2 c = (uv - mod(uv, 2.0)) / 2.0;\n        \n        // Create the chess-board-style texture\n        if (mod(c.x, 2.0) < 0.05 && mod(c.y, 2.0) > 0.05)\n            col *= 0.5;\n        if (mod(c.x, 2.0) > 0.05 && mod(c.y, 2.0) < 0.05)\n            col *= 0.5;\n        \n        // Do specular shading\n        return vec4(specular(col, n, r), 0.3);\n    }\n    else if (id == 3.0)\n        // Glass\n    \treturn vec4(specular(vec3(0.9, 1.0, 0.9), n, r), 1.0);\n    else if (id == 4.0)\n        // Red reflective\n        return vec4(specular(vec3(0.9, 0.2, 0.2), n, r), 0.4);\n    else\n        // Default material, e.g mirror, floor, sphere\n        return vec4(specular(vec3(0.9), n, r), 1.0);\n}\n\n// Burgess tonemapping - looks fairly bright/cheerful, has quite\n// a bit of contrast aswell\nvec3 burgess(vec3 col)\n{\n    vec3 maxCol = max(vec3(0.0), col - 0.004);\n    vec3 retCol = (maxCol * (6.2 * maxCol + 0.05)) / (maxCol * (6.2 * maxCol + 2.3) + 0.06);\n    return pow(retCol, vec3(1.0 / 2.2));\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Add movement\nvec3 getPosition()\n{\n    // Check the position in the data buffer\n    return texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n}\n\n// Get y rotation\nvec2 getRotation()\n{\n    // Fetch y-rotation at (0, 1).y\n    return texelFetch(iChannel0, ivec2(0, 1), 0).yz;\n}\n\n// Main image processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n\t// Setup pixel colour\n    vec3 col = vec3(0.0);\n    \n    // Fetch position and rotation\n    vec3 pos = getPosition();\n    vec2 rot = getRotation();\n    \n    // Setup ray\n    vec3 o = vec3(1.0 + pos.x, 0.4 + pos.y, pos.z - 4.0);\n    vec3 r = normalize(vec3(uv, 0.5 * PI));\n    int maxRays = 4;\n    \n    // Mouse position\n    vec2 mp = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    //mp.x *= iResolution.x / iResolution.y;\n    \n    // Rotate camera\n    r.yz *= mat2(cos(rot.x), -sin(rot.x), sin(rot.x), cos(rot.x));\n    r.xz *= mat2(cos(rot.y), -sin(rot.y), sin(rot.y), cos(rot.y));\n    \n    // Max ray travel distance\n    float maxt = 50.0;\n    \n    // Whether or not the ray has hit a\n    // non-reflective material\n    bool rayCanTerminate = false;\n    \n    // Previous material data\n    vec4 prevData = vec4(0.0);\n    \n    // Iterate through each ray\n    for (int rn = 0; rn < maxRays; rn++)\n    {\n        // Terminate if appropriate\n        if (rayCanTerminate)\n            break;\n        \n        // Ray distance travelled\n        float t = 0.0;\n        \n        // 'Falloff multiplier'; a multiplier used to make\n        // various things weaker the more times the ray has\n        // bounced (e.g reflections, shadows)\n        float falloff = 1.0 / float(rn + 1);\n        \n        // Raymarch    \n        for (int i = 0; i < 512; i++)\n        {\n            // Break if t is too high\n            if (t > maxt)\n            {\n                rayCanTerminate = true;\n                break;\n            }\n            \n            // Setup point to test. Margin added is the\n            // camera minimum clip distance\n            vec3 p = o + r * (t + 0.01);\n            \n            // Evaluate map function\n            vec2 m = map(p);\n            \n            // Fog values\n            float fog1 = 1.0 / (1.0 + t * t * 0.2);\n            float fog2 = 1.0 / (0.3 + t * t * 0.02);\n            \n            // Check if we hit an object\n            if (m.x < 0.0001)\n            {\n                // Calculate normal\n                vec3 n = calcNormal(p);\n                \n                // Calculate colour\n                vec4 matData = material(m.y, p, n, r, rayCanTerminate);\n                vec3 ncol = matData.rgb;\n                \n                // Whether or not the material is refractive\n                bool refractive = m.y == 3.0;\n                \n                // Calculate shadows\n                if (n.y >= 0.0)\n                {\n                \tfloat ss = sshadow(p, -lightDir, 0.01, 10.0, 2.0);\n                \tncol *= ss * 0.5 + 0.5;\n                }\n                \n                // Fog calculation. Use a different gradient for reflections\n                //if (rn < 1)\n                //\tncol *= fog2;\n                //else\n                //    ncol *= fog1;\n                \n                // Add the colour on\n                vec3 fcol = falloff * ncol;\n                \n                if (refractive)\n                    fcol *= 0.5;\n                \n                // Interpolate between the colours based on the reflectiveness\n               \t// 0 = only previous colour but darker\n                // 1 = colour of reflected object\n                if (rn > 0)\n                {\n                    // Reflected colour\n                    vec3 rcol = col + fcol;\n                    \n                    // Mix between reflected colour and colour\n                    // based on the previous reflectiveness\n                    rcol = mix(col * 0.5, rcol, prevData.a);\n                    \n                    // Blend between the reflection and the object,\n                    // based on the distance from the object\n                    col = mix(col, rcol, fog1);\n                }\n                else\n                    col = fcol;\n                    \n                // If we hit a refractive object, do more raytracing\n                if (refractive)\n                {\n                    // Setup the ray\n                    vec3 r2 = refract(r, n, 1.0 / GLASS_IOR);\n                    float t2 = 0.0;\n                    float maxt2 = 50.0;\n                    \n                    // Raytrace\n                    for (int j = 0; j < 256; j++)\n                    {\n                        // Break if beyond limits\n                        if (t2 > maxt2)\n                            break;\n                        \n                        // Setup point\n                        vec3 q = p + r2 * t2;\n                        \n                        // Evaluate map function\n                        vec2 m2 = map(q);\n                        \n                        // Test the point\n                        if (m2.x < 0.0001 && m2.y != m.y)\n                        {\n                            // Calculate normal\n                            vec3 n2 = calcNormal(q);\n                            \n                            // Shade the object\n                            bool isSpec = false;\n                            \n                            // Calculate the refracted colour\n                            vec3 nncol = material(m2.y, q, n2, r2, isSpec).rgb;\n                            nncol *= sshadow(q, -lightDir, 0.01, 10.0, 2.0);\n                            \n                            // Make the colour darker further away\n                            nncol *= 1.0 / (0.2 + t2 * t2 * 0.1);\n                            \n                            // Add the refracted colour on\n                            col += matData.rgb * 2.0 * falloff * nncol;\n                            \n                            // Break out of the refraction loop\n                            break;\n                        }\n                        \n                        // Increment t2\n                        if (m2.y != m.y)\n                        \tt2 += m2.x * 0.4;\n                        else\n                            t2 += 0.01;\n                    }\n                }\n                \n                // Set the previous data\n                prevData = matData;\n                \n                // Move the origin to the current point\n                o = p;\n                \n                // Reflect the ray\n                r = reflect(r, n);\n                \n                // Break out of the loop\n                break;\n            }\n            \n            // Increment t\n            t += m.x * 0.5;\n        }\n    }\n    \n    // Reduce colour a bit\n    //col *= 0.5;\n    \n    // Tonemapping to make the scene look better\n    col = pow(col, vec3(2.2));\n    col = burgess(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/////////////////////////////////////////////////\n//                                             //\n//  Buffer B generates a texture which is      //\n//  basically a copy of the rendered scene,    //\n//  but only with the brightest parts          //\n//  coloured in. This will be used for bloom.  //\n//                                             //\n/////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\nfloat weights[11] = float[](\n    0.0093,\n    0.028002,\n    0.065984,\n    0.121703,\n    0.175713,\n    0.198596,\n    0.175713,\n    0.121703,\n    0.065984,\n    0.028002,\n    0.0093\n);\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Gets a sample from a point\nvec3 getSample(vec2 p)\n{\n   \t// Get UV co-ordinates\n    vec2 uv = p / iResolution.xy;\n    uv = uv * 4.0 - 2.0;\n    \n    // Sample texture\n    return texture(iChannel0, uv).rgb;\n}\n\n// Main image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // UV co-ordinates\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Sample colour from Buf A\n    vec3 col = texture(iChannel0, uv * 4.0 - 2.0).rgb;\n    \n    // Calculate the brightness of the colour, bearing in mind\n    // that different wavelengths of light are perceived differently\n    float bright = col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722;\n    \n    // Remove darker colours\n    col *= bright;\n    \n    // Horizontal blur\n    for (int i = 0; i < 11; i++)\n    {\n        col += getSample(fragCoord + vec2(float(i) * 0.25, 0.0)) * weights[i / 2];\n        col += getSample(fragCoord - vec2(float(i) * 0.25, 0.0)) * weights[i / 2];\n    }\n    \n    // Vertical blur\n    for (int i = 0; i < 11; i++)\n    {\n        col += getSample(fragCoord + vec2(0.0, float(i) * 0.25)) * weights[i / 2];\n        col += getSample(fragCoord - vec2(0.0, float(i) * 0.25)) * weights[i / 2];\n    }\n    \n    col *= 0.3;\n    \n    // Output to texture\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Another experiment in path tracing. This    //\n//  time I'm trying to improve on my previous   //\n//  one. Various things have been added too.    //\n//  Buffer B here is the 'data' buffer, which   //\n//  stores data on player position, rotation    //\n//  and possibly other things.                  //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n// Values\n#define PI 3.14159\n#define EPS 1e-5\n\n// Macros\n#define tex(x, y) texelFetch(iChannel0, ivec2(x, y), 0)\n#define getKey(n) texelFetch(iChannel1, ivec2(n, 0), 0).x\n#define getKeyDown(n) texelFetch(iChannel1, ivec2(n, 1), 0).x\n\n// Keys\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_SPACE 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 data = tex(0, 0);\n    \n    // Old mouse position\n    vec2 oldMouse = iMouse.zw / iResolution.xy;\n    vec2 newMouse = iMouse.xy / iResolution.xy;\n    vec2 dragDiff = newMouse - oldMouse;\n    \n    ////////////////////////////////////////////////////////\n    // Player rotation                                    //\n    ////////////////////////////////////////////////////////\n    vec2 rot = tex(0, 1).yz;\n    \n    // Get y-rotation speed\n    float yrVel = newMouse.x - oldMouse.x;//getKey(KEY_RIGHT) - getKey(KEY_LEFT);\n    yrVel *= step(0.5, iMouse.z);\n    \n    // Get x-rotation speed\n    float xrVel = newMouse.y - oldMouse.y;\n    xrVel *= step(0.5, iMouse.z);\n    \n    // Rotate\n    rot -= vec2(xrVel, yrVel);// * 0.025;\n    \n    ////////////////////////////////////////////////////////\n    // Player position                                    //\n    ////////////////////////////////////////////////////////\n    vec3 pos = tex(0, 0).xyz;\n    \n    // Get the velocity\n    float vHorizontal = getKey(KEY_RIGHT) - getKey(KEY_LEFT) + getKey(KEY_D) - getKey(KEY_A);\n    float vVertical = getKey(KEY_UP) - getKey(KEY_DOWN) + getKey(KEY_W) - getKey(KEY_S);\n    \n    // Clamp velocity\n    vec2 vel = vec2(clamp(vHorizontal, -1.0, 1.0), clamp(vVertical, -1.0, 1.0));\n    \n    // Rotate velocity\n    float yrot = rot.y + 0.5 * PI;\n    vec2 velocity = vel;\n    velocity.x = vel.y * cos(yrot) + vel.x * cos(yrot - 0.5 * PI);\n    velocity.y = vel.y * sin(yrot) + vel.x * sin(yrot - 0.5 * PI);\n    \n    // Move the object\n    pos.xz += velocity * 0.025;\n    \n    ////////////////////////////////////////////////////////\n    // Player jumping                                     //\n    ////////////////////////////////////////////////////////\n    \n    // Upwards velocity (jumping) is stored in data(0, 0).w\n    float upVel = tex(0, 0).w;\n    \n    // If upwards velocity is zero, and we press the jump key,\n    // set an upward velocity\n    if (upVel <= EPS && getKeyDown(KEY_SPACE) > 0.0) upVel = 0.16;\n    \n    // Downwards acceleration is 10 m/s^2\n    upVel -= 0.4 * iTimeDelta;\n    \n    // Update player position based on upwards velocity\n    pos.y += upVel;\n    if (pos.y <= EPS)\n    {\n        pos.y = 0.0;\n        upVel = 0.0;\n    }\n    \n    ////////////////////////////////////////////////////////\n    // Store data                                         //\n    ////////////////////////////////////////////////////////\n    \n    // Only store the following data at (0, 0)\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n    \t// Store player position\n        data.xyz = pos;\n        \n        // Store upwards velocity\n        data.w = upVel;\n    }\n    // Only store the following data at (0, 1)\n    else if (ivec2(fragCoord) == ivec2(0, 1))\n    {\n        // Store a flag (0 | 1) if the player has moved this frame\n        data.x = step(EPS, abs(velocity.x)) + step(EPS, abs(velocity.y));\n        //if (abs(upVel) > 0.0) data.x = 1.0;\n        data.x += step(EPS, abs(upVel));\n        \n        // Store y rotation\n        data.yz = rot;\n    }\n    \n    // Output data\n    fragColor = data;\n}","name":"Buf C","description":"","type":"buffer"}]}