{"ver":"0.1","info":{"id":"slSGzy","date":"1624221935","viewed":298,"name":"Rhombic Dodecahedron - Enclosing","username":"sylvain69780","description":"The rhombic dodecahedron can be totally enclosed by a symmetrical cluster of 12 sticks having equilateral-triangular cross-section.\nThis is the way the \"scorpius slider spider\" wood puzzle is designed.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["dodecahedron","puzzle","enclosing","rhombic"],"hasliked":0,"parentid":"sllGDN","parentname":"[TUT] Bending Light - Part 2"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Rhombic Dodecahedron - Enclosing\n    ------------------------------\n    \n    When I was a child, I had the chance to own a \"scorpius slider spider puzzle\", \n    a piece of wood art. \n    \n    The shape is very cool and I tried to reproduce it on Shadertoy. \n    For this I needed to understand the geometry of the puzzle, with only hight school math.\n    And in fact I discovered more than I expected.\n    \n    The first approach is start from the description of each piece of the puzzle, that are 24\n    identical sticks with a section that is an half equilateral triangle. Coding the related \n    position of one piece to another is a real challenge, and I resigned at some point. 4 pieces \n    are forming an helix, and you need to assemble 3 helix to get a \"spider\" that is an\n    half shell having 3 sticks pointing in the same direction. 2 \"spiders\" are finally assembled \n    to finish the puzzle.\n    \n    The other approach that I followed here is to start from the Rhombic Dodecahedron that is \n    the geometry behind this figure. It uses the noticable fact that the rhombic \n    dodecahedron can be totally enclosed by a symmetrical cluster of 12 sticks having \n    equilateral-triangular cross-section. (Stewart T. Coffin) \n        \n    I made a hard use of basic trigonometry formulas and spent time to find the 3 times \n    polar repetition that allows to compute 3 pieces for the price of 1. At the end I get \n    quite satisfied about the result and decided to publish it on Shadertoy.\n    \n    At the same time, BigWings published his awesome tutorial \"Bending Light\" and I didn't \n    resist to the temptation to replicate this effect here.\n    \n   \tRelated references:\n    \n    This video of Philippe Cichon shows how to mount and unmout the puzzle (in French)\n    Le Scorpius on Youtube\n    https://youtu.be/2orJ6rTSx2s\n    Philippe Cichon's blog (French) if you want to shape it from a piece of wood.\n    (https://puzzles-et-casse-tete.blog4ever.com/le-scorpius-1\n\n    Rhombic dodecahedron - Wikipedia\n    https://en.wikipedia.org/wiki/Rhombic_dodecahedron\n    \n    The Puzzling World of Polyhedral Dissections By Stewart T. Coffin\n    https://johnrausch.com/PuzzlingWorld/chap08.htm\n    \n    Rhombic Dodecahedron SDF - yx\n    https://www.shadertoy.com/view/Wd2Gzt\n    \n    Bending Light - Part 2\n    by Martijn Steinrucken aka The Art of Code/BigWings\n    This is the end result of a tutorial on YouTube:\n    Part 1 - https://youtu.be/NCpaaLkmXI8\n    Part 2 - https://youtu.be/0RWaR7zApEo\n    \n    Adam Savage's One Day Builds: Rhombic Dodecahedron with Matt Parker!\n    https://www.youtube.com/watch?v=65r_1TzJXaQ\n    \n    My blog page\n    https://sylvain69780.github.io/2021/06/05/dihedral-angle-and-the-spider-slider-puzzle.html\n\n*/\n\n// Bigwings \n#define MAX_STEPS 256\n#define MAX_DIST 20.\n#define SURF_DIST .001\n#define S smoothstep\n#define T iTime\n// To avoid questions from the PI guy\n#define PI 3.14159265\n#define TAU 6.283185\n\nconst float r = acos(1.0/3.0); // Rotation angle between 2 assembled pieces\nconst float k = sqrt(3.0);     // height of the trianglular section\n// used to calculate the length of the sticks\nconst float d0 = 2.0/sin(r);  \n\n// some rotations shortcuts\nconst mat2 rot60 = mat2(0.5,-k/2.0,k/2.0,0.5);\nconst mat2 rot30 = mat2(k/2.0,.5,-.5,k/2.0);\nconst mat2 rot45 = mat2(sqrt(0.5),sqrt(0.5),-sqrt(0.5),sqrt(0.5));\nconst mat2 rot90  = mat2(0,1,-1,0);\nconst mat2 rot180 = mat2(-1,0,0,-1);\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// XY polar repetion starting Y axis\nvec3 opModPolar(vec3 p,float radius,float sectors,out float id) {\n    float angle = TAU/sectors;\n    p.y += radius;\n    float sector = round(atan(p.x,p.y)/angle); // thanks to IQ video https://youtu.be/sl9x19EnKng?t=1745\n    p.xy *= rot(angle*sector);\n    p.y -= radius;\n    id = sector;\n    return p;\n}\n\n// yx https://www.shadertoy.com/view/Wd2Gzt\nfloat sdRhombicDodecahedron(vec3 p)\n{\n    p = abs(p);\n    p += p.yzx;\n    return (max(max(p.x,p.y),p.z)-1.) * sqrt(.5);\n}\n\n// the rhombic dodecahedron can be totally enclosed by a symmetrical cluster \n// of 12 sticks having equilateral-triangular cross-section. (Stewart T. Coffin) \nfloat sdPiece( vec3 p ) {\n    float d = -p.y;\n    vec2 side = vec2(k/2.0,.5); // cut of the 60 degree plan\n    d = smax(d,dot(vec2(sqrt(p.x*p.x+.005),p.y)-vec2(1.0,0.0),side),.1); // a smooth abs I saw it somewhere from IQ ?\n    d = opExtrussion(p,d,1.5*d0+cos(r));\n    // plan truncating the prism\n    if ( p.z < 0.0 ) p.xz *= rot180;\n    vec3 n = vec3(0.0,0.0,1.0);  \n    n.yz *= rot30;\n    n.xz *= rot(3.14159*.5-r);\n    d = smax(d,dot(p-vec3(0.0,0.0,1.5*d0),n),.1);    \n    return d;\n}\n\nfloat GetDist(vec3 p) {\n    p.xz *= rot(iTime*.2);\n    float d = 2.0*sdRhombicDodecahedron(p/2.0);\n    // Computing the scale of the triangle from the width of the rhombic faces\n    float edge = 1.0/sin(r/2.0)*.5;  // length of the edge of the rhombus \n    float scale = edge*cos(PI/2.0-r); // base of the equilateral triangle\n    for (int i=0 ; i <= 3 ; i++) {\n        vec3 q = p;\n        q.z -= 1.0;\n        q.y -= 1.0;\n        q.zy *= rot(3.1415/4.0);\n        q.zx *= rot(acos(1./3.)/2.0); \n        float id;\n        q = opModPolar(q,sqrt(2.0),3.0,id);\n        q.z -= 20.0*smoothstep(-0.2,0.2,cos(iTime*PI*.05-id*.02+float(i)*0.3));\n        d = min(d,sdPiece(q/scale)*scale);\n        p.xy *= rot90;\n    }\n    // The Bigwings's effect is supposed to work only with convex shapes\n    // The result may be look strange for that.\n    d+= .1 * S(.6,1.0,sin(iTime*.2));\n    return d;\n}\n\n/*\n    Code below from Bigwings\n    Bending Light - Part 2\n    by Martijn Steinrucken aka The Art of Code/BigWings\n    This is the end result of a tutorial on YouTube:\n    Part 1 - https://youtu.be/NCpaaLkmXI8\n    Part 2 - https://youtu.be/0RWaR7zApEo\n*/\n\nfloat RayMarch(vec3 ro, vec3 rd, float side) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p)*side;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.1, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0, 0, 3)*(3.0-cos(iTime*PI*.05));\n    if ( iMouse.x > 0.0 ) {\n        ro.yz *= rot(m.y*PI);\n        ro.zx *= rot(m.x*PI);\n    } \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 col = texture(iChannel0, rd).rgb;\n    col *= col;\n    col *= S(1.0,0.5,length(uv));\n    vec3 bg = col;\n    float d = RayMarch(ro, rd, 1.); // outside of object\n    \n    float IOR = 1.45; // index of refraction\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d; // 3d hit position\n        vec3 n = GetNormal(p); // normal of surface... orientation\n        vec3 r = reflect(rd, n);\n        vec3 refOutside = texture(iChannel0, r).rgb;\n        refOutside *= refOutside;\n        \n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n*SURF_DIST*3.;\n        float dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n        vec3 nExit = -GetNormal(pExit); \n        \n        vec3 reflTex = vec3(0);\n        \n        vec3 rdOut = vec3(0);\n        \n        float abb = .01;\n        \n        // red\n        rdOut = refract(rdIn, nExit, IOR-abb);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.r = texture(iChannel0, rdOut).r;\n        \n        // green\n        rdOut = refract(rdIn, nExit, IOR);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.g = texture(iChannel0, rdOut).g;\n        \n        // blue\n        rdOut = refract(rdIn, nExit, IOR+abb);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.b = texture(iChannel0, rdOut).b;\n        \n        float dens = .09;\n        float optDist = exp(-dIn*dens);\n        reflTex *= reflTex;\n        // SylvainLC - played here with the optical distance\n        // tried a green glass effect.\n         reflTex = mix(vec3(0.15, .95,.15),reflTex,optDist); //*optDist*mix(vec3(0.05, .75,.05),vec3(1.0),optDist);\n      //  reflTex = reflTex*optDist;\n        \n        float fresnel = pow(1.+dot(rd, n), 5.);\n        \n        col = mix(reflTex, refOutside, fresnel);\n        col = mix(col,bg,S(12.0,15.0,d)); // vanish in the distance\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}