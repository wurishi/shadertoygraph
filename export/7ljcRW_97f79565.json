{"ver":"0.1","info":{"id":"7ljcRW","date":"1683903455","viewed":1092,"name":"Terrain Erosion Noise","username":"Fewes","description":"A modified version of clayjohn's awesome \"Eroded Terrain Noise\": https://www.shadertoy.com/view/MtGcWh\nThe original shader seemed to have some directional biasing when calculating the branches.\nThis is my attempt to fix that and improve the visualization.","likes":91,"published":1,"flags":32,"usePreview":0,"tags":["terrain","landscape","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 GetChannel0(vec2 uv)\n{\n    uv = clamp(uv, vec2(0.001), vec2(0.999));\n    uv *= BUFFER_SIZE / iResolution.xy;\n    return texture(iChannel0, uv);\n}\n\nvec4 GetChannel1(vec2 uv)\n{\n    uv = fract(uv);\n    uv *= BUFFER_SIZE / iResolution.xy;\n    return texture(iChannel1, uv);\n}\n\nvec4 map(vec3 p, out float erosion)\n{\n    vec2 uv = p.xz + vec2(0.5) - vec2(0.5) / BUFFER_SIZE;\n    \n    vec4 tex = GetChannel0(uv);\n    float height = tex.x;\n    vec3 normal = tex.yzz;\n    normal.y = sqrt(1.0 - dot(normal.xz, normal.xz)); // Recover Y\n    \n    erosion = tex.w;\n    \n    return vec4(height, normal);\n}\n\n// Ray marching\nfloat march(vec3 ro, vec3 rd, out vec3 normal, out int material, out float s_t)\n{\n    s_t = 9999.0;\n    \n    vec3 boxNormal;\n    vec2 box = boxIntersection(ro, rd, vec3(0.5, 1.0, 0.5), boxNormal);\n    \n    if (box.y < 0.0)\n    {\n        return -1.0;\n    }\n    \n    float tStart = max(0.0, box.x) + 1e-2;\n    float tEnd = box.y - 1e-2;\n    \n    material = M_GROUND;\n\n    float stepSize = 0.0;\n    float stepScale = 1.0;\n    float t = tStart;\n    float altitude = 0.0;\n    for (int i = 0; i < 32; i++)\n    {\n        vec3 pos = ro + rd * t;\n        \n        float foo;\n        vec4 tex = map(pos, foo);\n        float h = tex.x;\n        normal = tex.yzw;\n        \n        altitude = pos.y - h;\n        \n        s_t = max(0.0, min(s_t, altitude / t));\n        \n        if (altitude < 0.0)\n        {\n            if (i < 1) // Sides\n            {\n                /*\n                if (diff < -0.1) // Bottom\n                {\n                    return -1.0;\n                }\n                */\n                if (pos.y < 0.35) // Flat bottom\n                {\n                    s_t = 9999.0;\n                    return -1.0;\n                }\n                normal = boxNormal;\n                material = M_STRATA;\n                break;\n            }\n        }\n        \n        if (altitude < 0.0)\n        {\n            // Step back (contact/edge refinement)\n            stepScale *= 0.5;\n            t -= stepSize * stepScale;\n        }\n        else\n        {\n            // Step forward\n            // Accelerate the ray by distance to terrain. This would result in horrible aliasing if we didn't do refinement above\n            stepSize = abs(altitude) + 1e-2;\n            //stepSize = (tEnd - tStart) / float(stepCount);\n            t += stepSize * stepScale;\n        }\n    }\n    \n    if (t > tEnd)\n    {\n        s_t = 9999.0;\n        return -1.0;\n    }\n    \n#ifdef WATER\n    vec3 waterNormal;\n    vec2 water = boxIntersection(ro, rd, vec3(0.5, WATER_HEIGHT, 0.5), waterNormal);\n    if ((water.y > 0.0 && (water.x < t || t < 0.0)) && material != M_STRATA)\n    {\n        t = max(0.0, water.x);\n        normal = waterNormal;\n        material = M_WATER;\n    }\n    else\n#endif\n\n    if (box.y < 0.0)\n    {\n        return -1.0;\n    }\n\n    return t;\n}\n\nvec3 GetReflection(vec3 p, vec3 r, vec3 sun, float smoothness)\n{\n    vec3 refl = SkyColor(r, sun) * 4.0;\n    \n    vec3 foo;\n    float r_t;\n    int r_material;\n    march(p, r, foo, r_material, r_t);\n    return refl * (1.0 - exp(-r_t * 10.0 * sq(smoothness)));\n}\n\n// Main image output\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#ifdef SHOW_BUFFER\n    float debugWidth = iResolution.y / 2.0;\n#else\n    float debugWidth = 0.0;\n#endif\n\n    // ==========================================================================================\n    // Set up camera\n    // ==========================================================================================\n    vec2 cameraAngle = vec2(iTime * 0.1 + PI * 1.5, -0.17 * PI);\n    float cameraDistance = 5.0;\n    \n    // Intro animation\n    cameraAngle.x -= exp(-iTime * 5.0) * 4.0;\n    cameraDistance += exp(-iTime * 5.0) * 5.0;\n        \n    if (iMouse.z > 0.5)\n    {\n        cameraAngle.x = PI / 2.0;\n        cameraAngle.y = -0.2 * PI;\n    }\n    \n    vec3 ro = vec3(0.0, 0.325, 0.0);\n    vec3 rd = CameraRay(11.0, iResolution.xy, fragCoord.xy - vec2(debugWidth / 2.0, 0.0));\n    \n    mat3 rot = CameraRotation(cameraAngle.yx);\n    rd = rot * rd;\n    ro = rot * ro + rot * vec3(0, 0, cameraDistance);\n    \n    // ==========================================================================================\n    // Ray march\n    // ==========================================================================================\n    vec4 foo;\n    vec3 normal;\n    int material;\n    float t = march(ro, rd, normal, material, foo.w);\n    \n    // ==========================================================================================\n    // Shade\n    // ==========================================================================================\n#ifdef FIXED_SUN\n    vec3 sun = normalize(vec3(-1.0, 0.4, 0.05));\n#else\n    vec3 sun = rot * normalize(vec3(-1.0, 0.1, 0.25));\n#endif\n    \n    vec3 fogColor = 1.0 - exp(-SkyColor(rd, sun) * 2.0);\n    \n    vec3 color;\n    \n    if (t < 0.0)\n    {\n        // Sky\n        color = fogColor * (1.0 + pow(fragCoord.y / iResolution.y, 3.0) * 3.0) * 0.5;\n#ifdef SHOW_NORMALS\n        color = vec3(0.5, 0.5, 1.0);\n#endif\n    }\n    else\n    {\n        vec3 pos = ro + rd * t;\n        \n        float erosion;\n        //float h = map(pos, erosion).x;\n        float diff = pos.y - map(pos, erosion).x;\n        \n        vec4 breakupTex = vec4(0.0);\n        \n#ifdef DETAIL_TEXTURE\n        breakupTex = GetChannel1(pos.xz + 0.5);\n        vec3 breakupNormal = breakupTex.zyw;\n        if (material != M_STRATA)\n        {\n            normal = normalize(normal + breakupNormal.xzy * 0.1);\n        }            \n#endif\n        float breakup = breakupTex.x;\n\n        vec3 f0 = vec3(0.04);\n        float smoothness = 0.0;\n        float reflAmount = 0.0;\n        float occlusion = 1.0;\n        \n        vec3 r = reflect(rd, normal);\n        \n        vec3 diffuseColor = vec3(0.5);\n        if (material == M_GROUND)\n        {\n#ifndef GREYSCALE\n            occlusion = sq(saturate(erosion + 0.5));\n            \n            // Cliffs / Dirt\n            diffuseColor = CLIFF_COLOR * smoothstep(0.4, 0.52, pos.y);\n            //diffuseColor = mix(diffuseColor, DIRT_COLOR, smoothstep(0.8, 0.9, normal.y - erosion * 0.1 + breakup * 0.05));\n            diffuseColor = mix(diffuseColor, DIRT_COLOR, smoothstep(0.3, 0.0, occlusion + breakup * 1.0));\n            \n            // Grass\n            vec3 grassMix = mix(GRASS_COLOR1, GRASS_COLOR2, smoothstep(0.4, 0.6, pos.y - erosion * 0.05 + breakup * 0.3));\n            //diffuseColor = mix(diffuseColor, grassMix, smoothstep(0.8, 0.95, normal.y - erosion * 0.2 + breakup * 0.1));\n            diffuseColor = mix(diffuseColor, grassMix, smoothstep(WATER_HEIGHT + 0.05, WATER_HEIGHT + 0.02, pos.y - breakup * 0.02) * smoothstep(0.8, 1.0, normal.y + breakup * 0.1));\n            \n            // Snow\n            diffuseColor = mix(diffuseColor, vec3(1.0), smoothstep(0.53, 0.6, pos.y + breakup * 0.1));\n    #ifdef WATER\n            // Sand (beach)\n            diffuseColor = mix(diffuseColor, SAND_COLOR, smoothstep(WATER_HEIGHT + 0.005, WATER_HEIGHT, pos.y + breakup * 0.01));\n    #endif\n            diffuseColor *= 1.0 + breakup * 0.5;\n#endif\n        }\n        else if (material == M_STRATA)\n        {\n#ifndef GREYSCALE\n            vec3 strata = smoothstep(0.0, 1.0, cos(diff * vec3(130.0, 190.0, 250.0)));\n            diffuseColor = vec3(0.3);\n            diffuseColor = mix(diffuseColor, vec3(0.50), strata.x);\n            diffuseColor = mix(diffuseColor, vec3(0.55), strata.y);\n            diffuseColor = mix(diffuseColor, vec3(0.60), strata.z);\n            \n            diffuseColor *= exp(diff * 10.0) * vec3(1.0, 0.9, 0.7);\n#endif\n        }\n        else if (material == M_WATER)\n        {\n            float shore = normal.y > 1e-2 ? exp(-diff * 60.0) : 0.0;\n            float foam = normal.y > 1e-2 ? smoothstep(0.005, 0.0, diff + breakup * 0.005) : 0.0;\n        \n            diffuseColor = mix(WATER_COLOR, WATER_SHORE_COLOR, shore);\n            \n            diffuseColor = mix(diffuseColor, vec3(1.0), foam);\n            \n            //f0 = vec3(0.2);\n            smoothness = 0.95;\n        }\n        \n        float shadow = 1.0;\n        \n#ifdef SHADOWS\n        if (material != M_STRATA)\n        {\n            // Shadow ray\n            float s_t;\n            int s_material;\n            march(pos + vec3(0.0, 1.0, 0.0) * 1e-4, sun, foo.xyz, s_material, s_t);\n            shadow = 1.0 - exp(-s_t * 20.0);\n            //fragColor = vec4(shadow, shadow, shadow, 1.0);\n            //return;\n        }\n#endif\n\n        // Ambient\n        color = diffuseColor * SkyColor(normal, sun) * occlusion * Fd_Lambert();\n        // Direct\n        color += Shade(diffuseColor, f0, smoothness, normal, -rd, sun, SUN_COLOR * shadow);\n        // Bounce\n        color += diffuseColor * SUN_COLOR * (dot(normal, sun * vec3(1.0,-1.0, 1.0)) * 0.5 + 0.5) * Fd_Lambert() / PI;\n        // Reflection\n        color += GetReflection(pos, r, sun, smoothness) * F_Schlick(f0, dot(-rd, normal));\n        // Fog\n        float fog = exp(-t * t * smoothstep(WATER_HEIGHT, WATER_HEIGHT - 0.5, pos.y) * 0.5);\n        //color = mix(fogColor, color, fog);\n        \n        //color = vec3(exp(-max(0.0, -erosion * 2.0)));\n        //color = vec3(occlusion);\n\n#ifdef SHOW_DIFFUSE\n        color = pow(diffuseColor, vec3(1.0 / 2.2));\n#elif defined(SHOW_NORMALS)\n        color = normal.xzy * 0.5 + 0.5;\n#endif\n    }\n    \n    vec3 boxNormal;\n    vec2 box = boxIntersection(ro, rd, vec3(0.5, 1.0, 0.5), boxNormal);\n    \n    float costh = dot(rd, sun);\n    float phaseR = PhaseRayleigh(costh);\n    float phaseM = PhaseMie(costh, 0.6);\n    \n    vec2 od = vec2(0.0);\n    vec3 tsm;\n    vec3 sct = vec3(0.0);\n    float rayLength = (t > 0.0 ? t : box.y) - box.x;\n    float stepSize = rayLength / 16.0;\n    for (float i = 0.0; i < 16.0; i++)\n    {\n        vec3 p = ro + rd * (box.x + (i + 0.5) * stepSize);\n        \n        float h = max(0.0, p.y - 0.35);\n        //float d = exp(-h * 5.0);\n        float d = 1.0 - saturate(h / 0.2);\n        \n        if (p.y < 0.35)\n        {\n            d = 0.0;\n        }\n        \n        float densityR = d * 1e5;\n        float densityM = d * 1e5;\n        \n        od += stepSize * vec2(densityR, densityM);\n        \n        tsm = exp(-(od.x * C_RAYLEIGH + od.y * C_MIE));\n        \n        sct += tsm * C_RAYLEIGH * phaseR * densityR * stepSize;\n        sct += tsm * C_MIE * phaseM * densityM * stepSize;\n    }\n    \n    color = color * tsm + sct * 10.0;\n\n#if !defined(SHOW_NORMALS) && !defined(SHOW_DIFFUSE)\n    color = Tonemap_ACES(color);\n    color = pow(color, vec3(1.0 / 2.2));\n#endif\n\n    // Dither\n    color += texture(iChannel2, mod(fragCoord.xy, iChannelResolution[2].xy) / iChannelResolution[2].xy).xxx / 255.0;\n\n#ifdef SHOW_BUFFER\n    vec2 debugUV = fragCoord / debugWidth;\n    if (debugUV.x > 0.0 && debugUV.x < 1.0 && debugUV.y > 0.0 && debugUV.y < 2.0)\n    {\n        vec4 tex = GetChannel0(fract(debugUV));\n        vec3 normal = tex.yzz;\n        normal.y = sqrt(1.0 - dot(normal.xz,normal.xz));\n        color = debugUV.y > 1.0 ? normal.xzy * 0.5 + 0.5 : tex.xxx * 2.5 - 0.75;\n    }\n#endif\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copyright 2020 Clay John\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software \n// and associated documentation files (the \"Software\"), to deal in the Software without restriction, \n// including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, \n// and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do \n// so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or \n// substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT \n// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\n==========================================================================================\n\nBuffer A generates the heightmap (X), normals (YZ) and erosion mask used for coloring (W)\n\n==========================================================================================\n*/\n\n// code adapted from https://www.shadertoy.com/view/llsGWl\n// name: Gavoronoise\n// author: guil\n// license: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Code has been modified to return analytic derivatives and to favour \n// direction quite a bit.\nvec3 Erosion(in vec2 p, vec2 dir)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 2.0 * PI;\n    vec3 va = vec3(0.0);\n    float wt = 0.0;\n    for (int i=-2; i<=1; i++)\n    {\n        for (int j=-2; j<=1; j++)\n        {\n            vec2 o = vec2(i, j);\n            vec2 h = hash(ip - o) * 0.5;\n            vec2 pp = fp + o - h;\n            float d = dot(pp, pp);\n            float w = exp(-d * 2.0);\n            wt +=w;\n            float mag = dot(pp, dir);\n            va += vec3(cos(mag * f), -sin(mag * f) * (pp * 0.0 + dir)) * w;\n        }\n    }\n    return va / wt;\n}\n\nvec2 Heightmap(vec2 uv)\n{\n    vec2 p = uv * HEIGHT_TILES;\n    \n    // FBM terrain\n    vec3 n = vec3(0.0);\n    float nf = 1.0;\n    float na = HEIGHT_AMP;\n    for (int i = 0; i < HEIGHT_OCTAVES; i++)\n    {\n        n += noised(p * nf) * na * vec3(1.0, nf, nf);\n        na *= HEIGHT_GAIN;\n        nf *= HEIGHT_LACUNARITY;\n    }\n    \n    // [-1, 1] -> [0, 1]\n    n.x = n.x * 0.5 + 0.5;\n    \n    // Take the curl of the normal to get the gradient facing down the slope\n    vec2 dir = n.zy * vec2(1.0, -1.0) * EROSION_SLOPE_STRENGTH;\n    \n    // Now we compute another fbm type noise\n    // erosion is a type of noise with a strong directionality\n    // we pass in the direction based on the slope of the terrain\n    // erosion also returns the slope. we add that to a running total\n    // so that the direction of successive layers are based on the\n    // past layers\n    vec3 h = vec3(0.0);\n    \n    float a = 0.5;\n    float f = 1.0;\n    \n    // Smooth valleys\n    //a *= (smoothstep(0.0, 1.0, n.x));\n    \n    a *= smoothstep(WATER_HEIGHT - 0.1, WATER_HEIGHT + 0.2, n.x);\n\n    int octaves = EROSION_OCTAVES;\n    \n#ifdef COMPARISON_SLIDER\n    if (iMouse.z > 0.5 && (iMouse.x / iResolution.x - 0.5) * 1.5 < (0.5 - uv.y) || iMouse.z < 0.5 && 1.0 - uv.y > (-cos(iTime) * 1.0 + 0.5))\n    {\n        octaves = 0;\n        h.x = 0.5;\n    }\n#endif\n\n    for (int i = 0; i < octaves; i++)\n    {\n        h += Erosion(p * EROSION_TILES * f, dir + h.zy * vec2(1.0, -1.0) * EROSION_BRANCH_STRENGTH) * a * vec3(1.0, f, f);\n        a *= EROSION_GAIN;;\n        f *= EROSION_LACUNARITY;\n    }\n    \n    return vec2(n.x + (h.x - 0.5) * EROSION_STRENGTH, h.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (fragCoord.x >= BUFFER_SIZE.x || fragCoord.y >= BUFFER_SIZE.y)\n    {\n        return;\n    }\n\n    vec2 uv = fragCoord / BUFFER_SIZE;\n    uv.x += TIME_SCROLL_OFFSET;\n    \n    float s = 0.1;//scaling factor for heightmap\n    \n    vec2 h = Heightmap(uv);\n    \n    // Calculate an accurate normal from neighbouring points\n    vec2 uv1 = uv + vec2(1.0, 0.0) / 512.0;\n    vec2 uv2 = uv + vec2(0.0, 1.0) / 512.0;\n    vec2 h1 = Heightmap(uv1);\n    vec2 h2 = Heightmap(uv2);\n    vec3 v1 = vec3(uv1 - uv, (h1.x - h.x));\n    vec3 v2 = vec3(uv2 - uv, (h2.x - h.x));\n    vec3 normal = normalize(cross(v1, v2)).xzy;\n    \n    fragColor = vec4(h.x, normal.xz, h.y);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n==========================================================================================\n\n// Supplemental noise texture used to add diffuse/normal detail\n\n==========================================================================================\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x >= BUFFER_SIZE.x || fragCoord.y >= BUFFER_SIZE.y)\n    {\n        return;\n    }\n\n    vec2 uv = fragCoord / BUFFER_SIZE;\n    uv.x += TIME_SCROLL_OFFSET;\n    \n    vec3 color = vec3(0.0);\n    \n    float a = 0.5;\n    float f = 2.0;\n    for (int i = 0; i < 8; i++)\n    {\n        color += noised(uv * f) * a;\n        a *= 0.95;\n        f *= 2.0;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\n==========================================================================================\n\nThis shader is a fork of clayjohn's awesome \"Eroded Terrain Noise\":\nhttps://www.shadertoy.com/view/MtGcWh\n\nThe original function seemed to have some biasing problems which I've attempted to fix.\nI also wanted to improve the visualization to really show how great the result is.\nI take no credit for the actual noise/math. I simply wanted to help showcase it.\n\n==========================================================================================\n*/\n\n/*\n==========================================================================================\n\nErosion parameters\n\n==========================================================================================\n*/\n\n#define EROSION_TILES 4.0\n#define EROSION_OCTAVES 5\n#define EROSION_GAIN 0.5\n#define EROSION_LACUNARITY 2.0\n\n// Scale the input slope, leading to more erosion.\n#define EROSION_SLOPE_STRENGTH 3.0\n// Continuously modify the noise direction based on the previous fractal sample.\n// This is what gives the slopes an interesting \"branching\" structure.\n// A higher value will give you more branches.\n#define EROSION_BRANCH_STRENGTH 3.0\n// Maximum amount the erosion will modify the base height map\n#define EROSION_STRENGTH 0.04\n\n// Debug slider comparing the heightmap with and without erosion\n#define COMPARISON_SLIDER\n\n/*\n==========================================================================================\n\nThe stuff below is not strictly related to the erosion effect\n\n==========================================================================================\n*/\n\n#define PI 3.14159265358979\n#define DEG_TO_RAD (PI / 180.0)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define sq(x) (x*x)\n\n// Limit the work area of Buffer A/B to speed things up\n#define BUFFER_SIZE vec2(min(min(iResolution.x, iResolution.y), 768.0))\n\n// Base height noise parameters\n#define HEIGHT_TILES 3.0\n#define HEIGHT_OCTAVES 3\n#define HEIGHT_AMP 0.25\n#define HEIGHT_GAIN 0.1\n#define HEIGHT_LACUNARITY 2.0\n\n// Renderer settings\n\n#define SHADOWS\n#define WATER\n#define WATER_HEIGHT 0.45\n#define DETAIL_TEXTURE\n//#define GREYSCALE\n//#define SHOW_DIFFUSE\n//#define SHOW_NORMALS\n//#define SHOW_BUFFER\n\n#define M_GROUND 0\n#define M_STRATA 1\n#define M_WATER  2\n\n#define CLIFF_COLOR    vec3(0.22, 0.2, 0.2)\n#define DIRT_COLOR     vec3(0.6, 0.5, 0.4)\n#define GRASS_COLOR1   vec3(0.15, 0.3, 0.1)\n#define GRASS_COLOR2   vec3(0.4, 0.5, 0.2)\n#define SAND_COLOR     vec3(0.8, 0.7, 0.6)\n\n#define WATER_COLOR vec3(0.0, 0.05, 0.1)\n#define WATER_SHORE_COLOR vec3(0.0, 0.25, 0.25)\n\n//#define FIXED_SUN\n#define SUN_COLOR (vec3(1.0, 0.98, 0.95) * 2.0)\n#define AMBIENT_COLOR (vec3(0.3, 0.5, 0.7) * 0.1)\n\n#define TIME_SCROLL_OFFSET (cos(iTime * 0.2371) * 2.0)\n\nvec2 hash( in vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x * k + k.yx;\n    return -1.0 + 2.0 * fract(16.0 * k * fract( x.x * x.y * (x.x + x.y)));\n}\n\n// from https://www.shadertoy.com/view/XdXBRH\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0); \n    \n    vec2 ga = hash( i + vec2(0.0, 0.0) );\n    vec2 gb = hash( i + vec2(1.0, 0.0) );\n    vec2 gc = hash( i + vec2(0.0, 1.0) );\n    vec2 gd = hash( i + vec2(1.0, 1.0) );\n    \n    float va = dot( ga, f - vec2(0.0, 0.0) );\n    float vb = dot( gb, f - vec2(1.0, 0.0) );\n    float vc = dot( gc, f - vec2(0.0, 1.0) );\n    float vd = dot( gd, f - vec2(1.0, 1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),\n        ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +\n        du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nvec3 RNM(vec3 n1, vec3 n2)\n{\n    n1 += vec3( 0.0,  0.0, 1.0);\n    n2 *= vec3(-1.0, -1.0, 1.0);\n    return n1 * dot(n1, n2) / n1.z - n2;\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize, out vec3 outNormal ) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0); // no intersection\n    outNormal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\n// https://www.shadertoy.com/view/XsB3Rm\nvec3 CameraRay(float fov, vec2 size, vec2 pos)\n{\n    vec2 xy = pos - size * 0.5;\n    float cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD);    \n    float z = size.y * 0.5 * cot_half_fov;\n    return normalize( vec3( xy, -z ) );\n}\nmat3 CameraRotation(vec2 angle)\n{\n    vec2 c = cos(angle);\n    vec2 s = sin(angle);\n    return mat3(\n        c.y      ,  0.0, -s.y,\n        s.y * s.x,  c.x,  c.y * s.x,\n        s.y * c.x, -s.x,  c.y * c.x\n    );\n}\n\nvec3 SkyColor(vec3 rd, vec3 sun)\n{\n    float costh = dot(rd, sun);\n    return AMBIENT_COLOR * PI * (1.0 - abs(costh) * 0.8);\n}\n\nvec3 Tonemap_ACES(vec3 x)\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n// https://www.shadertoy.com/view/XlKSDR\n//------------------------------------------------------------------------------\n\nfloat pow5(float x)\n{\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h)\n{\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL)\n{\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH)\n{\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH)\n{\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH)\n{\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert()\n{\n    return 1.0 / PI;\n}\n\nvec3 Shade(vec3 diffuse, vec3 f0, float smoothness, vec3 n, vec3 v, vec3 l, vec3 lc)\n{\n    vec3 h = normalize(v + l);\n\n    float NoV = abs(dot(n, v)) + 1e-5;\n    float NoL = saturate(dot(n, l));\n    float NoH = saturate(dot(n, h));\n    float LoH = saturate(dot(l, h));\n\n    float roughness = 1.0 - smoothness;\n    float linearRoughness = roughness * roughness;\n    float D = D_GGX(linearRoughness, NoH, h);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3 F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    vec3 Fd = diffuse * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n    return (Fd + Fr) * lc * NoL;\n}\n\n//------------------------------------------------------------------------------\n// Atmosphere\n//------------------------------------------------------------------------------\n\n#define C_RAYLEIGH (vec3(5.802, 13.558, 33.100) * 1e-6)\n#define C_MIE (vec3(3.996,  3.996,  3.996) * 1e-6)\n\nfloat PhaseRayleigh (float costh)\n{\n\treturn 3.0 * (1.0 + costh * costh) / (16.0 * PI);\n}\n\nfloat PhaseMie(float costh, float g)\n{\n\tg = min(g, 0.9381);\n\tfloat k = 1.55*g - 0.55*g*g*g;\n\tfloat kcosth = k*costh;\n\treturn (1.0 - k*k) / ((4.0 * PI) * (1.0-kcosth) * (1.0-kcosth));\n}","name":"Common","description":"","type":"common"}]}