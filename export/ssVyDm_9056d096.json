{"ver":"0.1","info":{"id":"ssVyDm","date":"1655181691","viewed":306,"name":"Haru86_GLSLSound_220614","username":"Haru86_","description":"Haru86_GLSLSound_220614","likes":8,"published":1,"flags":40,"usePreview":0,"tags":["raymarching","sound"],"hasliked":0,"parentid":"ftfyDn","parentname":"Haru86_GLSLSound_SoundSample"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I borrowed the source code from here\n// https://neort.io/product/bvcrf5s3p9f7gigeevf0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col=vec3(0.0);\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    \n    col=texture(iChannel0,uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nvec2 mainSound( int samp, float time )\n{\n    vec2 s=DrawWave(time).s;\n    return s;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"// I borrowed the source code from here\n// https://neort.io/product/bvcrf5s3p9f7gigeevf0\n\nstruct SoundOutput{\n    vec2 s;\n    vec2 outs;\n    float samplerOffset;\n    float samplerWidth;\n};\n\n#define PI 3.14159265\n #define PI2 3.14159265*2.0\n\n// サンプラーサウンドのデバッグ(ただの試し弾き)\n #define dso(sound,useMet) debugSound(sound,ds,isd,t,beat,beatf,useMet)\n // サンプラー波形のデバッグ\n #define DebugSampler(sampler,o,w) dsw=sampler; samplerOffset=o;samplerWidth=w\n\n #define BPM 150.0\n \n #define saturate(i) clamp(i,-1.0,1.0)\n #define lofi(i,j) floor((i)/j)*j\n #define b2t(i) ((i)/BPM*60.0)\n \n #define calscale(r) 440.0*pow(2.0,(r)/12.0)\n #define scale(octave,note) calscale(octave*12.0+note)\n\n #define A 0.0\n #define B 2.0\n #define C 3.0\n #define D 5.0\n #define E 7.0\n #define F 8.0\n #define G 10.0\n #define rest -10000.0\n \n float rand(float time)\n{\n    return fract(sin(time*1e3)*1e6)-0.5;\n}\n\n// ---------------------------\n// 基礎的な音\n\nfloat saw(float phase){\n    return 2.0*fract(phase)-1.0;\n}\n\nfloat square(float phase){\n    return fract(phase) <0.5 ? -1.0 : 1.0;\n}\n\nfloat triangle(float phase){\n    return 1.0-4.0*abs(fract(phase)-0.5);\n}\n\nfloat sine(float phase){\n    return sin(PI2*phase);\n}\n\nfloat synth0(float phase){\n    float vib=0.2*sine(phase);\n   // vib=0.0;\n    return triangle(phase+vib);\n}\n\nfloat synth1(float phase){\n    float fm=0.1*sine(phase*3.0);\n    return saw(phase+fm)*sine(phase+fm);\n}\n\n// シンセ和音の生成(サンプラーだけを返す)\nfloat csaw(float phase,float s0,float s1,float s2,float s3){ // chords saw\n    float o=0.0;\n    o+=saw(phase*s0);\n    o+=saw(phase*s1);\n    o+=saw(phase*s2);\n    o+=saw(phase*s3);\n    \n    return o*0.25;\n}\n\nfloat csquare(float phase,float s0,float s1,float s2,float s3){ // chords square\n    float o=0.0;\n    o+=square(phase*s0);\n    o+=square(phase*s1);\n    o+=square(phase*s2);\n    o+=square(phase*s3);\n    \n    return o*0.25;\n}\n\nfloat ctriangle(float phase,float s0,float s1,float s2,float s3){ // chords triangle\n    float o=0.0;\n    o+=synth1(phase*s0);\n    o+=synth1(phase*s1);\n    o+=synth1(phase*s2);\n    o+=synth1(phase*s3);\n    \n    return o;\n}\n\nfloat csine(float phase,float s0,float s1,float s2,float s3){ // chords sine\n    float o=0.0;\n    o+=sine(phase*s0);\n    o+=sine(phase*s1);\n    o+=sine(phase*s2);\n    o+=sine(phase*s3);\n    \n    return o*0.25;\n}\n// ------------------------------\n\n// Instruments(楽器)\n// _phase => 時間???\n\n// 楽器の定義ではループは設定しないようにしている\n// DAWでのサンプラーの波形をそのまま表現するようにしている。\n// DAWで波形をみて楽器を作るようにする!!!!!!!!!!!!!\n\n//\nfloat sharpSaw(float _phase){\n    return mod(_phase,1.0) * 2.0 -1.0;\n}\n\nfloat kick(float phase,float s){\n    if(phase<0.0)return 0.0;\n    \n    //return sin(phase * 300.0 - exp(-phase * 70.0)*80.0 +saw(phase*10.0)*80.0) * exp(-phase * 5.0);\n    return sin(phase * s\n    - pow(5.0,-phase * 70.0)*80.0\n    - square(phase*40.0) *80.0\n    ) * exp(-phase * 5.0);\n}\n\n// Kick => サイン波のだんだんと位相が広がっていく感じ\nfloat kick2(float phase){\n    if(phase < 0.0){return 0.0;}\n    return sin(phase *300.0 - exp(-phase *70.0)*80.0)*exp(-phase *4.0);\n}\n\nfloat snare(float phase){\n    if(phase<0.0)return 0.0;\n    \n    return saturate(\n        (\n            rand(phase/0.034) +\n            sin(phase*2500.0 -exp(-phase * 400.0) * 30.0)\n        ) *  2.0 *exp(-phase *23.0)\n    );\n}\n\n// snare => ホワイトノイズっぽい音をサイン波で制御する感じ\nfloat snare2(float phase){\n    if(phase<0.0)return 0.0;\n    return (\n        rand(lofi(phase,6E-5)/2.06)*0.5+\n        sin(phase * 2000.0  - exp(-phase*800.0) * 20.0)\n    )*exp(-phase*31.0);\n}\n\n// hihat =>普通に短く区切ったホワイトノイズ\nfloat hihat(float _seed,float _dec){\n    return rand(_seed)*exp(-_dec);\n}\n\nfloat clap(float t,float s){\n    if(t<0.0){return 0.0;}\n    float o=(0.0);\n    o+=sin(s*t*(1.0+rand(t)*10.0)-exp(-t*50.)*100.);\n    \n    return o*0.5; \n}\n\nfloat bassDrum(float time)\n{\n    return sin(time * scale(0.0,9.0)) * max(0.0, 1.0 - fract(time) * 8.0);\n}\n\n// ダイアトニックコードを定義 -------------------------------------\n// ひとまずCメジャースケールで作ってみる\n\n#define sampler csine\n\n#define CM7(phase,o) sampler(phase,scale(o,C),scale(o,E),scale(o,G),scale(o+1.0,B))\n#define Dm7(phase,o) sampler(phase,scale(o,D),scale(o,F),scale(o+1.0,A),scale(o+1.0,C))\n#define Em7(phase,o) sampler(phase,scale(o,E),scale(o,G),scale(o+1.0,B),scale(o+1.0,D))\n#define FM7(phase,o) sampler(phase,scale(o,F),scale(o+1.0,A),scale(o+1.0,C),scale(o+1.0,E))\n#define G7(phase,o)  sampler(phase,scale(o,G),scale(o+1.0,B),scale(o+1.0,D),scale(o+1.0,F))\n#define Am7(phase,o) sampler(phase,scale(o+1.0,A),scale(o+1.0,C),scale(o+1.0,E),scale(o+1.0,G))\n#define Bm7(phase,o) sampler(phase,scale(o+1.0,B),scale(o+1.0,D),scale(o+1.0,F),scale(o+2.0,A))\n\n// bar(小節) -------------------------------------------------\n// 1小節(合計4泊)ごとに関数でまとめる\nfloat bar0(float beat,float masterOffset,float loopBeatNum,float octave){\n    float ret=0.0;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 0.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.25 - masterOffset,loopBeatNum))*0.2;\n    ret*=( (pow(4.0,-16.0*mod(beat - 1.5 - masterOffset,loopBeatNum))<0.5)? 1.0 : 0.0 ) ;\n    ret+=FM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 1.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=FM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 2.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Em7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.25 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-8.0*mod(beat - 3.5 - masterOffset,loopBeatNum))*0.2;\n    \n    return ret;\n}\n\n\nfloat bar1(float beat,float masterOffset,float loopBeatNum,float octave){\n    float ret=0.0;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 0.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.25 - masterOffset,loopBeatNum))*0.2;\n    ret*=( (pow(4.0,-16.0*mod(beat - 1.5 - masterOffset,loopBeatNum))<0.5)? 1.0 : 0.0 ) ;\n    ret+=G7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 1.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=FM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 2.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Em7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.25 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-8.0*mod(beat - 3.5 - masterOffset,loopBeatNum))*0.2;\n    \n    return ret;\n}\n\nfloat bar2(float beat,float masterOffset,float loopBeatNum,float octave){\n    float ret=0.0;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 0.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.25 - masterOffset,loopBeatNum))*0.2;\n    ret*=( (pow(4.0,-16.0*mod(beat - 1.5 - masterOffset,loopBeatNum))<0.5)? 1.0 : 0.0 ) ;\n    ret+=Em7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 1.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 2.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.25 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-8.0*mod(beat - 3.5 - masterOffset,loopBeatNum))*0.2;\n    \n    return ret;\n}\n\nfloat bar3(float beat,float masterOffset,float loopBeatNum,float octave){\n    float ret=0.0;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 0.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=CM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 1.25 - masterOffset,loopBeatNum))*0.2;\n    ret*=( (pow(4.0,-16.0*mod(beat - 1.5 - masterOffset,loopBeatNum))<0.5)? 1.0 : 0.0 ) ;\n    ret+=G7(b2t(beat),octave)*pow(4.0,-4.0*mod(beat - 1.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=FM7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 2.75 - masterOffset,loopBeatNum))*0.2;\n    ret+=Em7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.0 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-16.0*mod(beat - 3.25 - masterOffset,loopBeatNum))*0.2;\n    ret+=Dm7(b2t(beat),octave)*pow(4.0,-8.0*mod(beat - 3.5 - masterOffset,loopBeatNum))*0.2;\n \n    return ret;\n}\n\n\n// -------------------------------\n\n// サンプラーサウンドのデバッグ(ただの試し弾き)\nvoid debugSound(float sound,inout float o,out bool isDebug,float t,float beat,float beatf,bool useMet){\n    o=sound;\n    if(useMet)o+=0.5*sine(t * (mod(beat,4.0) < 1.0 ? 2000.0 : 1000.0) ) * (beatf < 0.1 ? 1.0 : 0.0)*0.5;\n    isDebug=true;\n}\n\n// _________________________\n\n// pow(4.0,-1.0*x) => これだと4泊(全音符・1小節)で減衰 \n   // pow(4.0,-2.0*x) => これだと2泊(二分音符)で減衰\n   // pow(4.0,-4.0*x) => これだと1泊(四分音符)で減衰\n   // エンベロープを一般化すると...\n   // pow(4.0,-音符の種類*mod(beat-offset , 繰り返しのbeat間隔))\n   // offset = その音が鳴るまでの小節内の合計拍\n   // 合計拍、数えるの大変なので1小節(全部で4泊)で関数まとめるといいかも？\n\n// 極力コメントを振る\nSoundOutput DrawWave(float time){\n    // 試し弾き用\n    bool isd=false; // isDebugMode\n    float ds=0.0;   // サンプラーサウンド\n    float dsw=0.0;  // サンプラーの波形\n    float samplerOffset=-.225;\n    float samplerWidth=0.1;\n\n    // 基本パラメーターの用意 -------------------------\n    \n    float t=time;\n    float beat=t*(BPM/60.0);\n    beat=mod(beat,64.0);\n    \n    float ret=0.0;\n    \n    // kick --------------------------------------------------------------------------------\n    //\n    ret+=kick(b2t(mod(beat - 0.0,8.0)),scale(-1.0,A))*pow(4.0,-8.0*mod(beat - 0.0,8.0));\n    ret+=kick(b2t(mod(beat - 0.5,8.0)),scale(-1.0,C))*pow(4.0,-8.0*mod(beat - 0.5,8.0));\n    ret+=kick(b2t(mod(beat - 1.0,8.0)),scale(-1.0,C))*pow(4.0,-8.0*mod(beat - 1.0,8.0));\n    ret+=kick(b2t(mod(beat - 1.5,8.0)),scale(-1.0,C))*pow(4.0,-8.0*mod(beat - 1.5,8.0));\n    \n    ret+=kick(b2t(mod(beat - 2.0,8.0)),scale(-1.0,A))*pow(4.0,-4.0*mod(beat - 2.0,8.0));\n    ret+=kick(b2t(mod(beat - 3.0,8.0)),scale(-1.0,A))*pow(4.0,-4.0*mod(beat - 3.0,8.0));\n    \n    //\n    ret+=kick(b2t(mod(beat - 4.0,8.0)),scale(-1.0,A))*pow(16.0,-8.0*mod(beat - 4.0,8.0));\n    ret+=kick(b2t(mod(beat - 4.25,8.0)),scale(-1.0,C))*pow(16.0,-8.0*mod(beat - 4.25,8.0));\n    ret+=kick(b2t(mod(beat - 4.5,8.0)),scale(-1.0,C))*pow(16.0,-8.0*mod(beat - 4.5,8.0));\n    ret+=kick(b2t(mod(beat - 4.75,8.0)),scale(-1.0,C))*pow(16.0,-8.0*mod(beat - 4.75,8.0));\n    \n    ret+=kick(b2t(mod(beat - 5.0,8.0)),scale(-1.0,A))*pow(16.0,-8.0*mod(beat - 5.0,8.0));\n    ret+=kick(b2t(mod(beat - 5.25,8.0)),scale(-1.0,C))*pow(16.0,-8.0*mod(beat - 5.25,8.0));\n    ret+=kick(b2t(mod(beat - 5.5,8.0)),scale(-1.0,C))*pow(16.0,-8.0*mod(beat - 5.5,8.0));\n    ret+=kick(b2t(mod(beat - 5.75,8.0)),scale(-1.0,C))*pow(16.0,-8.0*mod(beat - 5.75,8.0));\n    \n    ret+=kick(b2t(mod(beat - 6.0,8.0)),scale(-1.0,A))*pow(4.0,-4.0*mod(beat - 6.0,8.0));\n    ret+=kick(b2t(mod(beat - 7.0,8.0)),scale(-1.0,A))*pow(4.0,-4.0*mod(beat - 7.0,8.0));\n    \n    /*for(int i=0;i<6;i++){\n        ret+=kick(b2t(mod(beat-float(i),8.0)),scale(-1.0,A))*pow(4.0,-4.0*mod(beat-float(i),8.0));\n    }\n    \n    ret+=kick(b2t(mod(beat - 6.0,8.0)),scale(-1.0,A))*pow(4.0,-8.0*mod(beat - 6.0,8.0));\n    ret+=kick(b2t(mod(beat - 6.5,8.0)),scale(-1.0,A))*pow(4.0,-8.0*mod(beat - 6.5,8.0));\n    ret+=kick(b2t(mod(beat - 7.0,8.0)),scale(-1.0,A))*pow(4.0,-8.0*mod(beat - 7.0,8.0));\n    ret+=kick(b2t(mod(beat - 7.5,8.0)),scale(-1.0,A))*pow(4.0,-8.0*mod(beat - 7.5,8.0));*/\n    \n    if(beat>32.0){\n        ret+=clap(b2t(beat),scale(0.0,A))*pow(4.0,-4.0*mod(beat,2.0));\n    }\n    \n    // -------\n    \n    \n    // 音の最終アウトプット\n    if(isd){\n        SoundOutput o;\n        o.s=vec2(ds);\n        o.outs=vec2(dsw);\n        o.samplerOffset=samplerOffset;\n        o.samplerWidth=samplerWidth;\n        \n        return o;\n    }else{\n        SoundOutput o;\n        o.s=vec2(ret);\n        o.outs=vec2(dsw);\n        o.samplerOffset=samplerOffset;\n        o.samplerWidth=samplerWidth;\n    \n        return o;\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// I borrowed the source code from here\n// https://neort.io/product/bvcrf5s3p9f7gigeevf0\n\n// Raymarching Buffer\n\n#define time iTime\n#define resolution iResolution\n#define PI 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nfloat Scale;\nfloat map(vec3 p){\n     p.z+=time;\n     p.z=mod(p.z,4.0)-2.;\n\n     p=abs(p)-2.;\n     if(p.x<p.y)p.xy=p.yx;\n     if(p.x<p.z)p.xz=p.zx;\n     if(p.y<p.z)p.yz=p.zy;\n     \n     float s=3.5;\n     vec3 off=p*1.5;\n     for(int i=0;i<8;i++){\n         p=sign(p)*(1.-abs(abs(p)-1.));\n         float r=-10.5*clamp(0.51*max(.5*dot(p,p),0.5),0.,1.18);\n         s*=r;\n         p*=r;\n         p+=off+vec3(.5,0.13,.1);\n         \n         p.xy*=rot(1.75);\n         p.yz*=rot(0.75);\n     }\n     \n     s=abs(s);\n     Scale=s;\n     \n     float a=20.0;\n     p-=clamp(p,-a,a);\n     \n     return length(cross(p,normalize(vec3(5.0,2.0,-9.0)) ))/s -.0125;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st=(gl_FragCoord.xy*2.0-resolution.xy)/min(resolution.x,resolution.y); st*=rot(time*0.1);\n  vec3 p=vec3(cos(time)*0.1,sin(time)*0.1,-1.0),rd=normalize(vec3(st,1.));\n  float d=1.,i=0.;\n  for(;++i<128.&&d>0.001;)p+=rd*(d=map(p));\n  if(d<0.001){fragColor.xyz=20.*(cos(vec3(1.,5.,11.)+log(Scale)*3.)*.5+.5)/i;}\n  else{fragColor.xyz=vec3(0.0);}\n}","name":"Buffer A","description":"","type":"buffer"}]}