{"ver":"0.1","info":{"id":"MtsBDr","date":"1511678316","viewed":274,"name":"sludge star","username":"laserdog","description":"teaching myself ray marching","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi  3.14159\n#define tau 6.28318\n\nconst float MAX_DISTANCE = 100.;\nconst float EPSILON = .0001;\nconst int NUM_MARCHES = 255;\n\nvec3 translate(vec3 pos, vec3 offset)\n{\n    return pos - offset;\n}\n\nvec3 scale(vec3 pos, vec3 scale)\n{\n    return pos / scale;\n}\n\n// iq's smooth min\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat mergeSDF(float d1, float d2, float k)\n{\n    // higher k = more merging\n\treturn smin(d1, d2, k);\n}\n\nfloat sphereSDF(vec3 p) \n{\n    return length(p) - 1.;\n}\n\nfloat blobEffectSDF(vec3 p)\n{\n\tfloat res = sphereSDF(scale(p, vec3(.75))) * .75;\n    for (int i = 1; i <= 8; i++) {\n        for (int j = 1; j <= 3; j++) \n        {\n        \tfloat angle = float(i) * 3. * pi / 4. + float(j) * 3. * pi / 4.;\n        \tvec3 dir = normalize(vec3(cos(angle), sin(angle), 0.));\n        \tvec3 offset = dir * abs(sin(1.5 * iTime + float(i + j) * .07)\n                                    *  float(j) * 2.35);\n            float size = .5 * pow(1. / float(j), .75);\n    \t\tres = mergeSDF(res, sphereSDF(scale(translate(p, offset),\n                                                vec3(size))) * size, .7);\n        }\n    }\n    return res;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return blobEffectSDF(p);\n}\n\nvec3 phong(vec3 normal, vec3 light, vec3 view)\n{\n    const vec3 ambientColor = vec3(1., 0., 1.);\n    const vec3 diffuseColor = vec3(0.9, 0., 0.7);\n    const vec3 specularColor = vec3(1., 1., 1.);\n    const float shininess = 16.;\n    const float ambientStrength = .25;\n    \n    vec3 diffuse = max(dot(normal, light), 0.) * diffuseColor;\n    // light is negated because the first argument to reflect is the incident vector\n    vec3 specular = pow(max(dot(reflect(-light, normal), view), 0.), shininess) * specularColor;\n    vec3 ambient = ambientStrength * ambientColor;\n    \n    return diffuse + specular + ambient;\n}\n\nvec3 gradient(vec3 pos)\n{\n    const vec3 dx = vec3(EPSILON, 0., 0.);\n    const vec3 dy = vec3(0., EPSILON, 0.);\n    const vec3 dz = vec3(0., 0., EPSILON);\n    \n    return normalize(vec3(\n    \tsceneSDF(pos + dx) - sceneSDF(pos - dx),\n        sceneSDF(pos + dy) - sceneSDF(pos - dy),\n        sceneSDF(pos + dz) - sceneSDF(pos - dz)\n    ));\n}\n\nfloat distanceToShape(vec3 pos, vec3 dir)\n{\n    float tot = 0.;\n    for(int i = 0; i < NUM_MARCHES; i++) {\n        float dist = sceneSDF(pos);\n        if (dist < EPSILON || tot > MAX_DISTANCE) {\n        \treturn tot;\n        }\n        \n        tot += dist;\n        pos += dir * dist;\n    }\n    return MAX_DISTANCE;\n}\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up)\n{\n    vec3 f = normalize(target - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    \n    return mat4(\n        vec4(r, 0.),\n        vec4(u, 0.),\n        vec4(-f, 0.),\n        vec4(0., 0., 0., 1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 eye = vec3(0., 0., 7.5);\n    vec3 light = vec3(0., 3., 3.);\n    vec3 ray = normalize(vec3(uv, -1.));\n    \n    mat4 viewMat = lookAt(eye, vec3(0.), vec3(0., 1., 0.));\n    ray = (viewMat * vec4(ray, 1.)).xyz;\n    \n    float dist = distanceToShape(eye, ray);\n    vec3 pos = eye + ray * dist;\n    \n    fragColor = vec4(0.);\n    \n    if (dist < MAX_DISTANCE) {\n    \tfragColor.rgb = phong(normalize(gradient(pos)), normalize(light - pos), normalize(eye - pos));\n    }\n}","name":"Image","description":"","type":"image"}]}