{"ver":"0.1","info":{"id":"dslXR2","date":"1696666972","viewed":34,"name":"metaballs test","username":"toothmang","description":"metaballs","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define NUM_CIRCLES 2\n\nvec3 circle_starts[NUM_CIRCLES] = vec3[NUM_CIRCLES](\n    vec3(-0.1, 0.0, 2.0),\n    vec3(0.1, 0.0, 2.0)\n);\n\nvec2 circle_dirs[NUM_CIRCLES] = vec2[NUM_CIRCLES](\n    vec2(0.5, 0.0),\n    vec2(-0.5, 0.0)\n);\n\nvec3 circle_colors[NUM_CIRCLES] = vec3[NUM_CIRCLES](\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0)\n);\n\n\nvec3 get_circle(int index) {\n    vec2 start_pos = circle_starts[index].xy;\n    vec2 offset = circle_dirs[index] * sin(iTime);\n    return vec3(start_pos + offset, circle_starts[index].z);\n}\n\n// Returns the signed distance between a point p and a circle\nfloat distance_from_circle(vec2 p, vec3 c) {\n    float d = length(p - c.xy);\n    return d;\n}\n\n\nvec4 get_color(vec2 uv) {\n    vec4 result = vec4(0.);\n    \n    float sum = 0.0;\n    float radii = 0.;\n    \n    float distances[NUM_CIRCLES];\n    \n    for(int i = 0; i < NUM_CIRCLES; i++) {\n        vec3 c = get_circle(i);\n        radii += c.z;\n        float d = distance_from_circle(uv, c);\n        distances[i] = d;\n        \n        sum += 1.0 / d;\n    }\n    \n    float maxDist = 5.0;\n    \n    if (sum > maxDist) {\n    \n        float t = (sum - maxDist) / sum;\n        t *= 10.0;\n        \n        vec3 col = vec3(0.);\n        \n        for(int i = 0; i < NUM_CIRCLES; i++) {\n            float di = distances[i] / maxDist;\n            col += di * circle_colors[i];\n        }\n        result = vec4(col * t, 1.0);\n        \n                \n        //break;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize the fragCoord so that it's between [-1, -1] and [1, 1]\n    vec2 uv = fragCoord.xy - (iResolution.xy * 0.5);\n    uv = uv / (iResolution.xy * 0.5);\n    \n    // Aspect ratio correction\n    uv.x = uv.x * (iResolution.x / iResolution.y);\n    \n    fragColor = get_color(uv);\n\n\n    \n}","name":"Image","description":"","type":"image"}]}