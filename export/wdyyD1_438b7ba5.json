{"ver":"0.1","info":{"id":"wdyyD1","date":"1602712989","viewed":107,"name":"Apple raytracer","username":"iuryBorgesRodrigues","description":"Apple raytracer","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","sdf","iq","apple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\nconst vec3 W = vec3(11.2);\n\n vec3 lp = normalize(vec3(0.0,0.5,1.0));\n  vec3 lpp=normalize(vec3(0.0,-2.0,-0.0));\nconst vec3 lc = vec3(1.0,0.9,0.8)*80.0;\n\n\nstruct mat{\nvec3 col;\nvec3 rcol;\nfloat frc;\nfloat frm; \n};\n    \nstruct ray{\nvec3 o;\nvec3 d;\nfloat m;\n};\n     vec3 hash3(vec2 p)\n{\n    vec3 q = vec3(\n\t\tdot(p,vec2(127.1,311.7)), \n\t\tdot(p,vec2(269.5,183.3)), \n\t\tdot(p,vec2(419.2,371.9))\n\t);\n\treturn fract(sin(q) * 43758.5453);\n}\n\nvec3 CubemapToHDR( vec3 bg ){\n   bg = bg * bg;\n   bg = -log( 1.01f - bg );            \n   return bg;\n}\n\nfloat noise(vec2 x)\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\treturn mix(\n\t\tmix(\n\t\t\thash3(p + vec2(0.0, 0.0)).x,\n\t\t\thash3(p + vec2(1.0, 0.0)).x,\n\t\t\tsmoothstep(0.0, 1.0, f.x)\n\t\t),\n\t\tmix(\n\t\t\thash3(p + vec2(0.0, 1.0)).x,\n\t\t\thash3(p + vec2(1.0, 1.0)).x,\n\t\t\tsmoothstep(0.0, 1.0, f.x)\n\t\t),\n\t\tsmoothstep(0.0, 1.0, f.y)\n\t);\n}\n\nfloat fractal(vec2 x)\n{\n    float f = 0.0;\n    float amplitude = 0.5;\n    for (int i = 0; i < 5; i++)\n\t{\n\t\tf += noise(x) * amplitude;\n\t\tx *= 2.0;\n        amplitude /= 2.0;\n\t}\n    \n\treturn f;\n}\nvec3 tex(vec2 x){\n   \n    vec2 stretched = x * vec2(30.0, 10.0);\n    \n\tfloat speckFractal = fractal(x * 80.0);\n\tfloat yellowFractal = fractal(stretched);\n    \n    vec3 red    = vec3(0.5, 0.0, 0.0);\n    vec3 speck  = vec3(0.75, 0.5, 0.5);\n    vec3 yellow = vec3(1.0, 1.0, 0.0);\n    \n    float speckWeight = max(0.0, speckFractal * 3.0 - 2.0);\n    vec3 speckedRed = mix(red, speck, speckWeight);\n    \n    float yellowWeight = max(0.0, yellowFractal * 2.5 - 1.5);\n    vec3 color = mix(speckedRed, yellow, yellowWeight);\n\t\n\tcolor = sqrt(color); // rough gamma correction\n    \n    \n   return color;\n    \n    \n    \n}\n        \nmat getMat(float n,vec2 uv){\n  \tmat m;   \n    \n    m.col = vec3(0.4);\n    m.rcol= vec3(0.6);\n    m.frm = 0.5;\n    m.frc = 0.05;\n   \n    \n    if(n < 1.0){\n       // n = floor(texture(iChannel0,vec2(n,0.0)).r*10.0)/10.0-0.1;\n        \n        if(n == 0.1){\n\t\t\n        //texture apple\n        m.col = tex(uv.yx);\n\n        }else if(n == 0.2){\n\n        m.col = vec3(1.0,1.0,0.0);\n\n        }else if(n == 0.0){\n\n        m.col = vec3(0.1);\n\n        }else if(n == 0.3){\n\n        m.col = vec3(0.0,1.0,0.0);\n\n        }else if(n == 0.4){\n\n        m.col = vec3(0.0,1.0,1.0);\n\n        }else if(n == 0.5){\n\n        m.col = vec3(0.0,0.0,1.0);\n\n        }else if(n == 0.6){\n\n        m.col = vec3(1.0,0.0,1.0);\n\n        }\n    }else if(n < -0.1){  \n    m.frm = 0.9;\n    m.frc = 0.05;\n    }else{\n        m.frm = 1.0;\n         m.frc = 0.45*m.frm;\n         m.col = vec3(0.0);\n\n        if(n == 1.0){\n            \n        m.rcol= vec3(1.0,0.766,0.336);\n       \n        }else if(n == 1.2){\n       \n        m.rcol= vec3(0.955,0.637,0.538);\n      \n        }else if(n >= 1.1){\n\n        m.rcol= vec3(0.972, 0.960, 0.915);  \n\n        }\n        \n    }\n \n    return m;\n}\n\n\nvec3 uncharted2ToneMapping(vec3 x){\n\t\n\t\t\n\treturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec2 plane( vec3 p)\n{\n    \n    float x = float(int(mod(p.x*5.0,2.0)+1.00));\n    float z = float(int(mod(p.z*5.0,2.0)+1.00));\n    float check = abs(x-z)*-0.1;\n\treturn vec2(p.y,check);\n}\n\nfloat length8( vec3 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y+p.z, 1.0/8.0 );\n}\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n\n\n\nvec2 comp(vec2 a,vec2 b){\n    \n    return (a.x < b.x) ? a : b;\n}\n\n/*vec2 comp(vec2 a,vec2 b){\n    \n    return vec2(smin(a.x , b.x,32.0),(a.x < b.x) ? a.y : b.y);\n}*/\n\n\n\nfloat sdApple(vec3 p, float r) {\n\tp.y *= 0.95;\n\n\tp.xz *= 1.2;\n\n\tfloat k = 0.84 + 0.16 * smoothstep(-r, r, p.y);\n\tp.xz /= k;\n\treturn sdTorus(p, vec2((0.9 / 1.25) * r, r))*0.6;\n}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n\nfloat plane2( vec3 p ,vec3 d)\n{\n    \n\treturn dot(d,p);\n} \n\n\nvec2 map(vec3 rp){\n    vec2 dis = vec2(50.0);\n\n  \n   dis = comp(dis,vec2(plane(rp-vec3(0,-1,0)).xy ));\n  \n  // dis = comp(dis,vec2(sphere(rp - vec3(lp),0.1),2.0));\n      //dis = comp(dis,vec2(sphere(rp - vec3(lp2),0.1),2.0));\n    \n    \n    \n  \n   \n   \n \n    \n  \n    dis = comp(dis,vec2(sdApple(rp+vec3(0.0,0.5,0.0),0.5),0.1));\n    \n  \n    \n  \n    return dis;\n}\n\n\n\n\n\n\nvec4 castRay(vec3 ro , vec3 rd,float imax){\n    \n    float i = 0.002;\n    vec2 dat;\n    \n    for(int n = 0; n < 256; n++){\n        \n        dat.xy = map(ro+rd*i);\n        \n        if(dat.x < 0.002)return vec4(ro+rd*i,dat.y);\n        \n        if(i > imax)return vec4(ro+rd*i,-1.1);\n        \n        i+=max(abs(dat.x),0.002);\n    }\n    \n    return vec4(ro+rd*i,-1.1);\n}\n\n\nvec3 calcNormal(vec3 pos){\n    vec2 off = vec2(0.002,0.0);\n    \n   \tvec3 normal = normalize(vec3(\n    map(pos+off.xyy).x - map(pos-off.xyy).x,\n    map(pos+off.yxy).x - map(pos-off.yxy).x,\n    map(pos+off.yyx).x - map(pos-off.yyx).x )); \n    \n    return normal;\n}\n\nvec2 getUV(vec3 pos)\n{\n    vec3 nor = calcNormal(pos);\n    float lon = atan(nor.x,nor.z)/3.14;\n    float lat = acos(nor.y)/3.14;\n    vec2 r = vec2(lat, lon);\n    \n    return r;\n}\n\nray castRayR(vec3 ro , vec3 rd,float imax){\n    \n    float i = 0.002;\n    vec2 dat;\n    bool pass = false;\n    float pre = 1.0;\n    \n    for(int n = 0; n < 512; n++){\n        \n        dat.xy = map(ro+rd*i);\n        \n        \n        if(dat.x < 0.002 && dat.y > -0.5)return ray(vec3(ro+rd*i),vec3(rd),dat.y);\n        \n        if(i > imax)return ray(vec3(ro+rd*i),vec3(rd),-1.1);\n        \n        if(pre < 0.0 && dat.x > 0.0){\n            pass=true;\n            ro=ro+rd*i;\n            rd=normalize(rd+calcNormal(ro)*1.0/1.5);\n            i=0.000;\n        }\n        \n        if(pre > 0.0 && dat.x < 0.0){\n            pass=false;\n            ro=ro+rd*i;\n            rd=normalize(rd-calcNormal(ro)*1.5);\n            i=0.000;\n        }\n        \n        i+=max(abs(dat.x),0.002);\n        pre=dat.x;\n    }\n    \n    return ray(vec3(ro+rd*i),vec3(rd),-1.1);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n//from iq's raytracer \nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.1, 1.0 );    \n}\n//apenas para mapear a textura de maÃ§a corretamnete\nvec3 traceRay(in vec3 origin, in vec3 direction) {\n    \n\n   vec3 t=vec3(1.0);\n    \n    for (int i = 0; i < 20; i++) {\n        vec3 hit = vec3(map(origin + direction * t.x),1.0);\n        \n        t += hit;\n       \n    }\nreturn t;\n    \n\n    \n}\n\n//ligth\nfloat diffuse_directional(vec3 n,vec3 l, float strength)\n{\n      return (dot(n,normalize(l))*.5+.5)*strength;\n}\nfloat ambient_omni(vec3 p, vec3 l)\n{\n      float d=1.-abs(length(p-l))/400.;\n      return pow(d,32.)*1.5;\n}\nfloat specular_directional(vec3 n, vec3 l, vec3 v, float strength)\n{\n      vec3 r=reflect(normalize(l),n);\n      return pow(max(dot(v,r),.0),128.)*strength;\n}\nfloat SKY_COLOR              = 1.0; //[0.0=Red, 1.0=Blue)\n\nvec3 PBR_HDRremap(vec3 c)\n{\n    float fHDR = smoothstep(2.900,3.0,c.x+c.y+c.z);\n    vec3 cRedSky   = mix(c,1.3*vec3(4.5,2.5,2.0),fHDR);\n    vec3 cBlueSky  = mix(c,1.8*vec3(2.0,2.5,3.0),fHDR);\n    return mix(cRedSky,cBlueSky,SKY_COLOR);\n}\n\n\nvec3 renderR(vec3 ro,vec3 rd, vec2 uv){\n    vec3 pos = vec3(0,0,0),normal = vec3(0.0,0.0,0.0),color = vec3(0.0,0.0,0.0),ref = vec3(1.0);\n    mat mate; \n   \tfloat prec = 0.002;\n    vec3 bg = vec3(0.3,0.7,1.0)*1.0;\n    float dist = 0.0;\n    float cons = 1.0;\n    float lin = 0.14;\n    float quad = 0.07;\n    \n\tfor(int j = 1; j<4; j++){\n        vec4 dat = vec4(0.0);\n        if(j < 2){\n     \tray temp = castRayR(ro,rd,15.0/float(j));\n        rd = temp.d;\n        dat = vec4(temp.o,temp.m);\n        }else{\n        dat = castRay(ro,rd,15.0/float(j));\n \n        }\n     \tpos = dat.xyz;\n \t\n     \t\n            \n            dist+=length(ro-pos);\n            float fog = exp(-dist/10.0);\n            float dist1 = dist+length(lp-pos);\n           \tfloat atten = 1.0/(cons + lin*dist1 + quad * (dist1 * dist1)); \n            \n            if(dat.w >= 2.0){\n     \t       color+=lc*ref;    \n     \t       return color;\n               \n     \t    }else if(dat.w <= -1.0){\n            \n            dist+=length(ro-pos);\n  \t\t\tfog = exp(-dist/10.0);\n   \t\t\tcolor+=ref*bg;\n   \t\t\treturn color;\n                \n            }else{\n     \t         \n     \t        mate = getMat(dat.w,uv);\n                vec3 c = pow(mate.col,vec3(2.2));   \n     \t        vec3 rc = pow(mate.rcol,vec3(2.2));\n                \n     \t        normal = calcNormal(pos);\n     \t        vec3 ld = normalize(lp-pos);\n                \n     \t        float fren =pow(1.0 - max(dot(-rd,normal),0.0),5.0);\n     \t        fren = mix(mate.frc,mate.frm,fren);\n                \n     \t        vec3 lit = (max(dot(ld,normal),0.0))*lc/12.0;\n                lit*=calcSoftshadow( ro,rd, 0.01, 3.0, 20.);\n                \n     \t        vec3 dif = c*lit*(1.0-fren)*ref;\n                vec3 amb = c*bg/24.0*ref*(1.0-fren)*calcAO(pos,normal);\n                \n                dif*=atten;\n                \n     \t    \tcolor+= dif + amb;\n                \n     \t        ref*=fren*rc; \n                \n     \t    }\n            \n     \t    ro=pos;\n     \t\trd=reflect(rd,normal);\n     \t  \t  \t\n    }\n   dist+=length(ro-pos);\n   float fog = exp(-dist/10.0);\n   color+=ref*bg;\n   return color;\n    \n}\n\n\nvec3 render(vec3 ro,vec3 rd,vec2 uv){\n    vec3 pos = vec3(0,0,0),normal = vec3(0.0,0.0,0.0),color = vec3(0.0,0.0,0.0),ref = vec3(1.0);\n    mat mate; \n   \tfloat prec = 0.002;\n    vec3 bg= vec3(0.3,0.7,1.0)*1.0;\n    float dist = 0.0;\n    float cons = 1.0;\n    float lin = 2.0;\n    float quad = 0.07;\n    vec3 offset = vec3(0.01, 0.0, 0.0);\n\tfor(int j = 1; j<7; j++){\n   \n     \tvec4 dat = castRay(ro,rd,15.0/float(j));\n     \t pos = dat.xyz;\n        \t\n \t\n     \t\t\n            bg=textureLod(iChannel0, rd,0.0).rgb;\n        \tbg=PBR_HDRremap(bg);\n        \n            dist+=length(ro-pos);\n            float fog = exp(-dist/10.0);\n            float dist1 = dist+length(lp-pos);\n           \tfloat atten = 1.0/(cons + lin*dist1 + quad * (dist1 * dist1)); \n            \n            if(dat.w >= 2.0){\n     \t       color+=lc*ref;    \n     \t       return color;\n               \n     \t    }else if(dat.w < -1.0){\n            \n            dist+=length(ro-pos);\n  \t\t\tfog = exp(-dist/10.0);\n   \t\t\tcolor+=ref*bg;\n   \t\t\treturn color;\n                \n            }else if(dat.w < -0.5 && j < 3){\n                \n             \n     \t        mate = getMat(dat.w,uv);\n                vec3 c = pow(mate.col,vec3(2.2));   \n     \t        vec3 rc = pow(mate.rcol,vec3(2.2));\n                \n     \t        normal = calcNormal(pos);\n     \t        vec3 ld = normalize(lp-pos);\n                \n     \t        float fren =pow(1.0 - max(dot(-rd,normal),0.0),5.0);\n     \t        fren = mix(mate.frc,mate.frm,fren);\n               \n                \n     \t        vec3 dif = renderR(ro,rd,uv)*(1.0-fren)*ref;\n                vec3 amb = c*bg/24.0*ref*(1.0-fren)*calcAO(pos,normal);\n                \n                dif*=atten;\n                \n     \t    \tcolor+= dif;\n                \n     \t        ref*=fren*rc; \n                \n            }else{\n     \t         \n     \t        mate = getMat(dat.w,uv);\n                vec3 c = pow(mate.col,vec3(1.5));   \n     \t        vec3 rc = pow(mate.rcol,vec3(1.5));\n                \n     \t        normal = calcNormal(pos);\n     \t        vec3 ld = normalize(lp-pos);\n                \n     \t        float fren =pow(1.0 - max(dot(-rd,normal),0.0),5.0);\n     \t        fren = mix(mate.frc,mate.frm,fren);\n                \n     \t        vec3 lit = (max(dot(ld,normal),0.0))*lc/12.0;\n                lit*=calcSoftshadow( ro,rd, 0.01, 2.0, 20. );\n                ;\n\n     \t        vec3 dif = c*lit*(5.0-fren)*ref;\n               //com sombra normal vec3 amb = c*bg/24.0*ref*(1.0-fren)*calcAO(pos,normal);\n                 \n                //aqui esta com luz global \n                 vec3 amb = c*ref*(1.0-fren)*calcAO(pos,normal);\n                \n                \n                dif*=atten;\n                \n     \t    \tcolor+= dif + amb;\n               \n                \n     \t        ref*=fren*rc; \n                \n              \n        \n     \t    } \n            \n     \t    ro=pos;\n        \t\n        \t\n     \t\trd=reflect(rd,normal);\n        \n        \t\n     \t  \t\n    }\n    \n    \n   \n \n   dist+=length(ro-pos);\n   float fog = exp(-dist/10.0);\n   color+=ref*bg;\n    \n   return color;\n    \n}\n\n\n#define ZERO (min(iFrame,0))\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5; \n\t\n\t\n\tvec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n\t\n           vec2 mouse = iMouse.xy/ iResolution.xy*2.0-1.0;\n\tmouse.x *= iResolution.x/iResolution.y*4.0;\n\t\n\tmat3 rotmat = rotate_x(mouse.y*4.0+sin(1.0*.1)*.3+4.2)*rotate_y(mouse.x+1.0*.125-1.0/1.0+sin(1.0*.35));\n    \n   \n    \n\n    \n    vec3 ro = vec3(0.0,0.0,3.9)+vec3(0.0,0.0,0.0);\n    vec3 rd = normalize(vec3(uv,-2.0));\n   \n    ro*=rotmat;\n    rd*=rotmat;\n    lp*=rotmat;\n    \n    \n    \n    \n    vec3 color = render(ro,rd,getUV(ro+rd*traceRay(ro,rd).x));\n\n    vec3 curr = uncharted2ToneMapping(color.xyz*5.0);\n\tvec3 whiteScale = 1.0/uncharted2ToneMapping(W); \n\tvec3 mapped = curr*whiteScale;\n\t\n\tmapped = pow(mapped, vec3(1.0 / 2.2));\n     \n    tot += mapped;\n    }\n     tot /= float(AA*AA);\n\t\n\tfragColor =  vec4(tot,1.0) ;\n}","name":"Image","description":"","type":"image"}]}