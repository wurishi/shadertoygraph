{"ver":"0.1","info":{"id":"Dscfz8","date":"1696906361","viewed":76,"name":"Perlin Noise Lava Lamp","username":"bagelboy","description":"Lava lamp effect using 3d Perlin noise, 2-pass box blur, posterize, and color swap\n\nreferences:\nhttps://www.shadertoy.com/view/slB3z3 (3D Perlin Noise)\nhttps://www.shadertoy.com/view/sslyDB (rgb Color Swap)\nhttps://www.shadertoy.com/view/NscGDf (Blur)","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["noise","animated","posterized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLES 200.0\n#define BLUR 50\n#define LEVELS 8.0\n\nvec4 blur_linear(sampler2D tex, vec2 texel, vec2 uv, vec2 line)\n{\n    vec4 total = vec4(0);\n    \n    float dist = 1.0/SAMPLES;\n    for(float i = -0.5; i<=0.5; i+=dist)\n    {\n        vec2 coord = uv+i*line*texel;\n        total += texture(tex,coord);\n    }\n    \n    return total * dist;\n}\n\nvec4 posterize(vec4 src, float steps) { return vec4(floor(src.rgb * steps) / steps, src.a); }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = 1./iResolution.xy;\n    \n    // Blur 2nd Pass\n    vec2 line = vec2(BLUR, 0);\n    vec4 blur = blur_linear(iChannel0, texel, uv, line.yx);\n    \n    vec4 posterized = posterize(blur, LEVELS);\n    \n    // Color Replacement\n    const vec3 targets[8] = vec3[8](\n        vec3(0.0),\n        vec3(0.1),\n        vec3(0.2),\n        vec3(0.4),\n        vec3(0.5),\n        vec3(0.6),\n        vec3(0.7),\n        vec3(0.9)\n    );\n    // Pallete generated from https://acerola.gg/colors.html\n    /*\n    // BLUE\n    const vec3 replaces[8] = vec3[8](\n        vec3(0.0039, 0.0863, 0.0824),\n        vec3(0.0196, 0.1294, 0.149),\n        vec3(0.0471, 0.1843, 0.2353),\n        vec3(0.0941, 0.251, 0.349),\n        vec3(0.1647, 0.3255, 0.4824),\n        vec3(0.2667, 0.4157, 0.6431),\n        vec3(0.4039, 0.5216, 0.8157),\n        vec3(0.5804, 0.6431, 1.0)\n    );\n    */\n    \n    // ORANGE + PURPLE\n    const vec3 replaces[8] = vec3[8](\n        vec3(0.0392, 0.1137, 0.2745),\n        vec3(0.1098, 0.1373, 0.3529),\n        vec3(0.2235, 0.1647, 0.4118),\n        vec3(0.3765, 0.2, 0.4353),\n        vec3(0.5529, 0.2431, 0.4314),\n        vec3(0.7451, 0.3098, 0.4039),\n        vec3(0.9176, 0.4, 0.3804),\n        vec3(1.0, 0.5255, 0.3608)\n    );\n    \n    const float threshold = 0.1; // Controls target color range\n    const float softness = 0.0; // Controls linear falloff\n\n    for(int i = 0; i < 8; i++)\n    {\n        float diff = distance(posterized.rgb, targets[i]) - threshold;\n        if(diff <= 0.0){\n            float factor = clamp(diff / softness, 0.0, 1.0);\n            fragColor = vec4(mix(replaces[i], posterized.rgb, factor), posterized.a);\n        }\n\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 3-dimensional unsigned integer input vector.\n\nuint hash(uvec3 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process third vector element\n    k = x.z; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec3 gradientDirection(uint hash) {\n    switch (int(hash) & 15) { // look at the last four bits to pick a gradient direction\n    case 0:\n        return vec3(1, 1, 0);\n    case 1:\n        return vec3(-1, 1, 0);\n    case 2:\n        return vec3(1, -1, 0);\n    case 3:\n        return vec3(-1, -1, 0);\n    case 4:\n        return vec3(1, 0, 1);\n    case 5:\n        return vec3(-1, 0, 1);\n    case 6:\n        return vec3(1, 0, -1);\n    case 7:\n        return vec3(-1, 0, -1);\n    case 8:\n        return vec3(0, 1, 1);\n    case 9:\n        return vec3(0, -1, 1);\n    case 10:\n        return vec3(0, 1, -1);\n    case 11:\n        return vec3(0, -1, -1);\n    case 12:\n        return vec3(1, 1, 0);\n    case 13:\n        return vec3(-1, 1, 0);\n    case 14:\n        return vec3(0, -1, 1);\n    case 15:\n        return vec3(0, -1, -1);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, float value5, float value6, float value7, float value8, vec3 t) {\n    return mix(\n        mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y),\n        mix(mix(value5, value6, t.x), mix(value7, value8, t.x), t.y),\n        t.z\n    );\n}\n\nvec3 fade(vec3 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec3 position, uint seed) {\n    vec3 floorPosition = floor(position);\n    vec3 fractPosition = position - floorPosition;\n    uvec3 cellCoordinates = uvec3(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 0)), seed)), fractPosition - vec3(1, 0, 0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 0)), seed)), fractPosition - vec3(0, 1, 0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 0)), seed)), fractPosition - vec3(1, 1, 0));\n    float value5 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 0, 1)), seed)), fractPosition - vec3(0, 0, 1));\n    float value6 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 0, 1)), seed)), fractPosition - vec3(1, 0, 1));\n    float value7 = dot(gradientDirection(hash((cellCoordinates + uvec3(0, 1, 1)), seed)), fractPosition - vec3(0, 1, 1));\n    float value8 = dot(gradientDirection(hash((cellCoordinates + uvec3(1, 1, 1)), seed)), fractPosition - vec3(1, 1, 1));\n    return interpolate(value1, value2, value3, value4, value5, value6, value7, value8, fade(fractPosition));\n}\n\nfloat perlinNoise(vec3 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n// -------------------- additions --------------------\n\nvec4 multiply(vec4 a, vec4 b) {\n    return a*b;\n}\n\nfloat dist(vec2 p0, vec2 pf){return sqrt((pf.x-p0.x)*(pf.x-p0.x)+(pf.y-p0.y)*(pf.y-p0.y));}\n\n// -------------------- additions --------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 position = fragCoord / iResolution.xy;\n    position.x *= iResolution.x / iResolution.y;\n    uint seed = 0x578437adU;\n    \n    // Generate Perlin Noise\n    float value = perlinNoise(vec3(position, iTime * 0.01), 2, 4, 0.5, 2.0, seed); // multiple octaves\n    value = (value + 1.0) * 0.5; // convert from range [-1, 1] to range [0, 1]\n    vec4 perlinNoise = vec4(vec3(value + 0.2), 1.0);\n    \n    // Create Gradients\n    vec4 quadraticY = vec4(vec3(1. - (uv.y-1.)*(uv.y-1.)), 1.0);\n    vec4 quadraticX = vec4(vec3(1. - (uv.x-1.)*(uv.x-1.)), 1.0);\n    float d = dist(iResolution.xy*0.5,fragCoord.xy)*0.001;\n\tvec4 circle = mix(vec4(0.0, 0.0, 0.0, 1.0), vec4(1.0, 1.0, 1.0, 1.0), d);\n    \n    // Multiply chosen gradient with Perlin Noise and clamp\n    vec4 noiseGrad = multiply(perlinNoise, quadraticX);\n    float r = clamp(noiseGrad.r,0.0, 0.99);\n    float g = clamp(noiseGrad.g,0.0, 0.99);\n    float b = clamp(noiseGrad.b,0.0, 0.99);\n    float a = clamp(noiseGrad.a,0.0, 1.0);\n    noiseGrad = vec4(r,g,b,a);\n    \n    fragColor = noiseGrad;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define SAMPLES 200.0\n#define BLUR 50\n\nvec4 blur_linear(sampler2D tex, vec2 texel, vec2 uv, vec2 line)\n{\n    vec4 total = vec4(0);\n    \n    float dist = 1.0/SAMPLES;\n    for(float i = -0.5; i<=0.5; i+=dist)\n    {\n        vec2 coord = uv+i*line*texel;\n        total += texture(tex,coord);\n    }\n    \n    return total * dist;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texel = 1./iResolution.xy;\n\n    // Blur 1st Pass\n    vec2 line = vec2(BLUR, 0);\n    vec4 blur = blur_linear(iChannel0, texel, uv, line);\n    \n    fragColor = blur;\n}","name":"Buffer B","description":"","type":"buffer"}]}