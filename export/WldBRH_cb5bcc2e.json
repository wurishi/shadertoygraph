{"ver":"0.1","info":{"id":"WldBRH","date":"1614065087","viewed":682,"name":"High-Collar Cubes","username":"coposuke","description":"// Mouse Left  : Roll\n// Mouse Click : Cell Reset (for fullscreen)\n\nUrushi Wafu Cubes\nIt's my first that BRDF.","likes":52,"published":1,"flags":32,"usePreview":1,"tags":["brdf","pattern","fxaa","japanese","randomwalk","pbg"],"hasliked":0,"parentid":"wlyyRV","parentname":"Random-Walk Cubes"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// postprocess\n\n\nvec3 acesFilm(const vec3 x)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nfloat vignette(vec2 uv)\n{\n    const float ADJUST = 0.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    uv = mix(vec2(uv.x, uv.y / aspect), vec2(uv.x * aspect, uv.y), ADJUST);\n    \n    const float INTENSITY = -0.8;\n    const float SMOOTHNESS = 0.8;\n    float dist = distance(vec2(0.0), uv);\n    return 1.0 - smoothstep((1.0 - INTENSITY) * (1.0 - SMOOTHNESS), 1.0 - INTENSITY, dist);\n}\n\nvec3 chromaticAberration(vec2 uv, vec2 onePixel, sampler2D channel)\n{\n    vec2 uv01 = uv * 2.0 - 1.0;\n    \n    vec2 direction = uv01;\n    float power = distance(vec2(0.0), (uv01));\n    power = power * power * 2.0;\n    \n    float r = texture(channel, uv + onePixel * direction * power).r;\n    float g = texture(channel, uv).g;\n    float b = texture(channel, uv - onePixel * direction * power).b;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 onePixel = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * onePixel;\n    \n    // chromatic aberration\n    //fragColor = texture(iChannel0, uv);\n    fragColor.rgb = chromaticAberration(uv, onePixel, iChannel0);\n\n    // bloom\n    float blm = bloom(iChannel0, uv, vec2(1,-1), onePixel);\n    fragColor.rgb += vec3(saturate(blm));\n    \n    // vignette\n    fragColor.rgb *= vec3(vignette(uv));\n    \n    // tonemap\n    fragColor.rgb = acesFilm(fragColor.rgb);\n    \n    // degamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / 2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define saturate(value) (clamp(value, 0.0, 1.0))\n\nconst float PI = 3.14159265358979;//3.1415926535798;\nconst float TAU = PI * 2.0;\n\nconst float CELL_SIZE = 10.0;\nconst float CUBE_HALFSIZE = 30.0;\nconst float CUBE_SIZE = (CUBE_HALFSIZE * 2.0) / CELL_SIZE;\nconst float MOVE_FRAME = 30.0;\n\nconst int JAPANESE_PATTERN = 8;\nconst int MATERIAL_PATTERN = 3;\n\n//---------------------------\n\nfloat hash(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 hash2(vec2 uv)\n{\n    return vec2(hash(uv), hash(uv + vec2(63.357, 234.346)));\n}\n\n\n//---------------------------\n\nvec3 getDirection(float number)\n{\n    vec3 dir = vec3(0);\n    dir.x = step(1.0, number) * step(number, 2.0 - 1e-3) - step(2.0, number) * step(number, 3.0 - 1e-3);\n    dir.y = step(3.0, number) * step(number, 4.0 - 1e-3) - step(4.0, number) * step(number, 5.0 - 1e-3);\n    dir.z = step(5.0, number) * step(number, 6.0 - 1e-3) - step(6.0, number) * step(number, 7.0);\n    return dir;\n}\n\nint getBufferCellID(vec2 uv, vec2 resolution)\n{\n    return int(round(uv.y * resolution.x + uv.x));\n}\n\nint getBufferCellID(vec3 cellID)\n{\n    cellID = mod(cellID, CUBE_SIZE); // loop\n    float id = round(cellID.x + (cellID.y * CUBE_SIZE) + (cellID.z * CUBE_SIZE * CUBE_SIZE));\n    return int(mod(id, CUBE_SIZE * CUBE_SIZE * CUBE_SIZE));\n}\n\nvec3 getBufferCellID3D(int cellID)\n{\n    return vec3(\n        mod(floor(float(cellID)),  CUBE_SIZE),\n        mod(floor(float(cellID) /  CUBE_SIZE), CUBE_SIZE),\n        mod(floor(float(cellID) / (CUBE_SIZE * CUBE_SIZE)), CUBE_SIZE)\n    );\n}\n\nvec2 getBufferCellUV(int cellID, vec2 resolution)\n{\n    float num = float(cellID);\n    return vec2(mod(num, resolution.x), floor(num / resolution.x)) / resolution.xy + (0.5 / resolution.xy);\n}\n\nvec2 getBufferCellUV(vec3 cellID, vec2 resolution)\n{\n    return getBufferCellUV(getBufferCellID(cellID), resolution);\n}\n\n//---------------------------\n\nfloat luminance(vec3 color)\n{\n    const vec3 PERCEPTION = vec3(0.2126, 0.7152, 0.0722);\n    return max(0.0, dot(PERCEPTION, color));\n}\n\nfloat bloom(sampler2D channel, vec2 uv, vec2 dir, vec2 onePixel)\n{\n    vec4 color = vec4(0.0);\n    dir = normalize(dir) * 5.0;\n    \n    const float INTENSITY = 0.005;\n    const int LOOPS = 64;\n    for(int i = -LOOPS / 2; i < LOOPS / 2; ++i)\n    {\n        float dist = 1.0 - abs(float(i) / float(LOOPS / 2));\n        vec4 sampleColor = texture(channel, uv + (dir * onePixel * float(i)));\n        \n        float lumi = sampleColor.a;\n        lumi = clamp(lumi, 0.0, 5.0) * dist * dist * INTENSITY;\n        \n        color.a += sampleColor.a * lumi;\n    }\n    \n    return color.a;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// random-walk\n//     fragColor.x = exist cell (and ID)\n//     fragColor.y = cell moving direction (0 ~ 6)\n//     fragColor.z = exist neighbor cell (and ID)\n//     fragColor.w = neighbor cell moving direction (0 ~ 6)\n\n\nfloat getEmptyDirectionID(int cellID, int loops)\n{\n    vec3 cellID3D = getBufferCellID3D(cellID);\n    \n    float choises[6] = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    int choisesCount = 0;\n    \n    for(float i = -1.0; i <= 1.0; i += 2.0)\n    {\n        vec3 xNeighborCellID3D = cellID3D + vec3(i, 0.0, 0.0);\n        vec3 yNeighborCellID3D = cellID3D + vec3(0.0, i, 0.0);\n        vec3 zNeighborCellID3D = cellID3D + vec3(0.0, 0.0, i);\n\n        float xNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(xNeighborCellID3D, iResolution.xy)).x);\n        float yNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(yNeighborCellID3D, iResolution.xy)).x);\n        float zNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(zNeighborCellID3D, iResolution.xy)).x);\n\n        bool xIsExist = 1.0f <= xNeighborCellExist;\n        bool yIsExist = 1.0f <= yNeighborCellExist;\n        bool zIsExist = 1.0f <= zNeighborCellExist;\n        \n        // dont enter from outer Cube\n        xIsExist = xIsExist && 0.0 <= xNeighborCellID3D.x && xNeighborCellID3D.x < CUBE_SIZE;\n        yIsExist = yIsExist && 0.0 <= yNeighborCellID3D.y && yNeighborCellID3D.y < CUBE_SIZE;\n        zIsExist = zIsExist && 0.0 <= zNeighborCellID3D.z && zNeighborCellID3D.z < CUBE_SIZE;\n        \n        choises[choisesCount] = round(1.5 + (i * 0.5)) * float(xIsExist); choisesCount+= 1 * int(xIsExist);\n        choises[choisesCount] = round(3.5 + (i * 0.5)) * float(yIsExist); choisesCount+= 1 * int(yIsExist);\n        choises[choisesCount] = round(5.5 + (i * 0.5)) * float(zIsExist); choisesCount+= 1 * int(zIsExist);\n    }\n\n    int index = int(floor(hash(vec2(float(cellID), loops)) * 6.0)); // Dare increased choices mistake.\n    //int index = int(floor(hash(vec2(float(cellID), loops)) * float(choisesCount)));\n    return choises[index];\n}\n\nfloat getCellDirectionID(int cellID, int loops)\n{\n    vec3 cellID3D = getBufferCellID3D(cellID);\n    \n    float choises[6] = float[](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n    int choisesCount = 0;\n    \n    for(float i = -1.0; i <= 1.0; i += 2.0)\n    {\n        vec3 xNeighborCellID3D = cellID3D + vec3(i, 0.0, 0.0);\n        vec3 yNeighborCellID3D = cellID3D + vec3(0.0, i, 0.0);\n        vec3 zNeighborCellID3D = cellID3D + vec3(0.0, 0.0, i);\n\n        int  xNeighborCellID = getBufferCellID(xNeighborCellID3D);\n        int  yNeighborCellID = getBufferCellID(yNeighborCellID3D);\n        int  zNeighborCellID = getBufferCellID(zNeighborCellID3D);\n\n        float xNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(xNeighborCellID, iResolution.xy)).x);\n        float yNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(yNeighborCellID, iResolution.xy)).x);\n        float zNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(zNeighborCellID, iResolution.xy)).x);\n\n        bool xIsEmpty = xNeighborCellExist <= 0.0;\n        bool yIsEmpty = yNeighborCellExist <= 0.0;\n        bool zIsEmpty = zNeighborCellExist <= 0.0;\n        \n        // dont enter from outer Cube\n        xIsEmpty = xIsEmpty && 0.0 <= xNeighborCellID3D.x && xNeighborCellID3D.x < CUBE_SIZE;\n        yIsEmpty = yIsEmpty && 0.0 <= yNeighborCellID3D.y && yNeighborCellID3D.y < CUBE_SIZE;\n        zIsEmpty = zIsEmpty && 0.0 <= zNeighborCellID3D.z && zNeighborCellID3D.z < CUBE_SIZE;\n        \n        // cell's direction matching\n        xIsEmpty = xIsEmpty && getEmptyDirectionID(xNeighborCellID, loops) == round(1.5 + (-i * 0.5));\n        yIsEmpty = yIsEmpty && getEmptyDirectionID(yNeighborCellID, loops) == round(3.5 + (-i * 0.5));\n        zIsEmpty = zIsEmpty && getEmptyDirectionID(zNeighborCellID, loops) == round(5.5 + (-i * 0.5));\n        \n        choises[choisesCount] = round(1.5 + (-i * 0.5)) * float(xIsEmpty); choisesCount+= 1 * int(xIsEmpty);\n        choises[choisesCount] = round(3.5 + (-i * 0.5)) * float(yIsEmpty); choisesCount+= 1 * int(yIsEmpty);\n        choises[choisesCount] = round(5.5 + (-i * 0.5)) * float(zIsEmpty); choisesCount+= 1 * int(zIsEmpty);\n    }\n\n    //int index = int(floor(hash(vec2(float(cellID), loops)) * 6.0)); // Dare increased choices mistake.\n    int index = int(floor(hash(vec2(float(cellID), loops)) * float(choisesCount)));\n    return choises[index];\n}\n\nvoid getOverlap(vec3 cellID3D, int loops, out float isOverlap, out float overlapDirID)\n{\n    isOverlap = 0.0;\n    overlapDirID = 0.0;\n\n    for(float i = -1.0; i <= 1.0; i += 2.0)\n    {\n        vec3 xNeighborCellID3D = cellID3D + vec3(i, 0.0, 0.0);\n        vec3 yNeighborCellID3D = cellID3D + vec3(0.0, i, 0.0);\n        vec3 zNeighborCellID3D = cellID3D + vec3(0.0, 0.0, i);\n\n        int  xNeighborCellID = getBufferCellID(xNeighborCellID3D);\n        int  yNeighborCellID = getBufferCellID(yNeighborCellID3D);\n        int  zNeighborCellID = getBufferCellID(zNeighborCellID3D);\n\n        float xNeighborCellDirID = getCellDirectionID(xNeighborCellID, loops);\n        float yNeighborCellDirID = getCellDirectionID(yNeighborCellID, loops);\n        float zNeighborCellDirID = getCellDirectionID(zNeighborCellID, loops);\n\n        float xNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(xNeighborCellID, iResolution.xy)).x);\n        float yNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(yNeighborCellID, iResolution.xy)).x);\n        float zNeighborCellExist = step(1.0, texture(iChannel0, getBufferCellUV(zNeighborCellID, iResolution.xy)).x);\n\n        bool xIsOverlap = 1.0 <= xNeighborCellExist * step(getDirection(xNeighborCellDirID).x * i, 0.0 - 1e-3);\n        bool yIsOverlap = 1.0 <= yNeighborCellExist * step(getDirection(yNeighborCellDirID).y * i, 0.0 - 1e-3);\n        bool zIsOverlap = 1.0 <= zNeighborCellExist * step(getDirection(zNeighborCellDirID).z * i, 0.0 - 1e-3);\n        \n        // dont enter from outer Cube\n        xIsOverlap = xIsOverlap && 0.0 <= xNeighborCellID3D.x && xNeighborCellID3D.x < CUBE_SIZE;\n        yIsOverlap = yIsOverlap && 0.0 <= yNeighborCellID3D.y && yNeighborCellID3D.y < CUBE_SIZE;\n        zIsOverlap = zIsOverlap && 0.0 <= zNeighborCellID3D.z && zNeighborCellID3D.z < CUBE_SIZE;\n\n        isOverlap    = max(isOverlap,    float(xIsOverlap));\n        overlapDirID = max(overlapDirID, float(xIsOverlap) * xNeighborCellDirID);\n        isOverlap    = max(isOverlap,    float(yIsOverlap));\n        overlapDirID = max(overlapDirID, float(yIsOverlap) * yNeighborCellDirID);\n        isOverlap    = max(isOverlap,    float(zIsOverlap));\n        overlapDirID = max(overlapDirID, float(zIsOverlap) * zNeighborCellDirID);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n    \n    vec2 isInitPixel = vec2(iResolution.xy - 1.0);\n    bool isInit = texelFetch(iChannel0, ivec2(isInitPixel), 0).r < 1.0;\n    if(floor(fragCoord) == isInitPixel)\n    {\n        fragColor.r = 1.0;\n        return;\n    }\n\n    vec2 uvLocal = mod(fragCoord, CELL_SIZE) / CELL_SIZE;\n    vec2 uvID = floor(fragCoord);\n    float time = fract(iTime);\n    \n    int cellID = getBufferCellID(uvID, iResolution.xy);\n    vec3 cellID3D = getBufferCellID3D(cellID);\n    \n    if(int(CUBE_SIZE * CUBE_SIZE * CUBE_SIZE) < cellID)\n        return;\n    \n    // sequence\n    int sequence = int(mod(float(iFrame), MOVE_FRAME));\n    int loops = int(float(iFrame) / MOVE_FRAME);\n\n    if(isInit || 1.0 <= iMouse.w)\n    {\n        // initialize\n        float noise = hash(vec2(cellID, length(iDate))) * 3.0 - 1.3;\n        float id = step(-0.0, noise) * floor(noise * 0.5 * (1.0 + float(MATERIAL_PATTERN * JAPANESE_PATTERN)));\n        fragColor = vec4(id, 0.0, 0.0, 0.0);\n        return;\n    }\n\n    // overlap info (at sequence == 1)\n    float isOverlap = 0.0, overlapDirID = 0.0;\n    getOverlap(cellID3D, loops, isOverlap, overlapDirID);\n    float neighborID = texture(iChannel0, getBufferCellUV(cellID3D - getDirection(overlapDirID), iResolution.xy)).x;\n        \n    if(sequence == 0 && 1 <= loops)\n    {\n        // move cell (check that self cell overwrite from neighbor cell)\n        float exist = fragColor.x;\n        fragColor.x = exist * step(fragColor.y, 0.0); // stay\n        \n        if(fragColor.x <= 0.0)\n            fragColor.x = fragColor.z;\n\n        fragColor.y = 0.0;\n        fragColor.z = 0.0;\n        fragColor.w = 0.0;\n    }\n    else if(sequence == 1)\n    {\n        // direction decision\n        int exist = int(fragColor.x);\n        if(1 <= exist)\n            fragColor.y = getCellDirectionID(cellID, loops);\n            \n        // neighbor cell direction\n        fragColor.z = step(0.9, isOverlap) * neighborID;\n        fragColor.w = overlapDirID;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\n//                     BRDF\n//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\nstruct BRDFDesc\n{\n    vec3 lightDir; // L\n    vec3 viewDir;  // V\n    vec3 normal;   // N\n    vec3 anisoX;   // X\n    vec3 anisoY;   // Y\n    float shadowAttenuation;\n    float aoAttenuation;\n};\n\nstruct Material\n{\n    vec3 diffuseColor;\n    vec3 specularColor;\n    vec3 reflectionColor;\n    vec3 emissiveColor;\n    float roughness;\n    float metallic;\n};\n\n\nvec3 fresnel(vec3 f0, float u)\n{\n    // Schlick Approximation\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);\n}\n\nvec3 fresnelRoughness(vec3 F0, float u, float roughness)\n{\n\t// Schlick Approximation (with roughness)\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - u, 5.0);\n}\n\nfloat distribution(float dotNH, float roughness)\n{\n    // GGX(Trowbridge-Reitz)\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float dotNH2 = dotNH * dotNH;\n    float f = 1.0 - (1.0 - a2) * dotNH2;\n    return a2 / (PI * f * f);\n}\n\nfloat maskingAndShadowing(float dotNL, float dotNV, float roughness)\n{\n    //Smith Joint GGX(Height-Correlated Masking and Shadowing)\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float lambdaNL = (-1.0 + sqrt(1.0 + a2 * (1.0 / (dotNL * dotNL) - 1.0))) / 2.0;\n    float lambdaNV = (-1.0 + sqrt(1.0 + a2 * (1.0 / (dotNV * dotNV) - 1.0))) / 2.0;\n    return 1.0 / (1.0 + lambdaNL + lambdaNV);\n}\n\nvec3 directLightingBRDF(Material param, BRDFDesc desc)\n{\n    vec3 halfDir = normalize(desc.lightDir + desc.viewDir);\n    float dotNV = dot(desc.normal, desc.viewDir);\n    float dotNH = abs(dot(desc.normal, halfDir));\n    float dotNL = abs(dot(desc.normal, desc.lightDir));\n    float dotLH = abs(dot(desc.lightDir, halfDir));\n\n    // Normal Distribution Function\n    float dTerm = distribution(dotNH, param.roughness);\n    \n    // Fresnel\n  \tvec3 f0 = mix(vec3(0.04), param.diffuseColor.rgb, param.metallic);\n    vec3 fTerm = fresnel(f0, dotLH);\n    \n    // Masking And Shadowing(Geometry Term)\n    float gTerm = maskingAndShadowing(dotNL, dotNV, param.roughness);\n    \n    // Diffuse BRDF\n\tvec3 kd = mix(vec3(1.0) - fTerm, vec3(0.0), param.metallic);\n    vec3 diffuse = param.diffuseColor;\n    diffuse = (diffuse / PI) * kd * mix(dotNL, 1.0, param.metallic);\n    \n    // Specular BRDF\n    vec3 specular = param.specularColor;\n    specular *= dTerm * fTerm * gTerm;\n    \n    // Fr = Fd + Fs\n    return (diffuse + specular) * desc.shadowAttenuation;\n}\n\nvec3 ambientLightingBRDF(Material param, BRDFDesc desc)\n{\n    // Fresnel with Roughness\n    float dotNV = dot(desc.normal, desc.viewDir);\n    vec3 f0 = 0.04 * (1.0 - param.metallic) + param.diffuseColor.rgb * param.metallic;\n    vec3 fTerm = fresnelRoughness(f0, dotNV, param.roughness);\n\n    vec3 kS = fTerm;\n    vec3 kD = (1.0 - kS) * (1.0 - param.metallic);\n    \n    // IBL\n    vec3 diffuseIrradiance = textureLod(iChannel2, desc.normal, 5.0).rgb * param.diffuseColor * 0.1 * kD;\n    vec3 diffuseIBL = diffuseIrradiance * param.diffuseColor * (1.0 - param.metallic) * desc.aoAttenuation;\n    \n    float soAttenuation = saturate(pow(dotNV + desc.aoAttenuation, exp2(-16.0 * param.roughness - 1.0)) - 1.0 + desc.aoAttenuation);\n    vec3 specularIrradiance = param.reflectionColor;\n    vec3 specularIBL = specularIrradiance * fTerm * soAttenuation;\n    \n    return diffuseIBL + specularIBL;\n}\n\nvec3 computeBRDF(Material param, BRDFDesc desc)\n{\n    return directLightingBRDF(param, desc) + ambientLightingBRDF(param, desc) + param.emissiveColor;\n}\n\n\n//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\n//              Japanese Pattern\n//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\nmat2 rotate(float angle)\n{\n    float s = sin(angle), c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec2 pmod(vec2 uv, float num)\n{\n    float angle = atan(uv.x, uv.y) + PI / num;\n    float split = TAU / num;\n    float id = floor(angle / split);\n    angle = id * split;\n    return uv * rotate(angle);\n}\n\nfloat distanceLine(vec2 l0, vec2 l1, vec2 p)\n{\n    vec2 v01 = (l1 - l0);\n    vec2 v0p = ( p - l0);\n    vec2 vh = v0p - v01 * clamp(dot(v01, v0p) / dot(v01, v01), 0.0, 1.0);\n    return length(vh);\n}\n\nvec3 honeycomb(vec2 uv)\n{\n    vec2 a = vec2(1.0, 1.7320508) * 2.0;\n    vec2 ah = a * 0.5;\n    vec2 tile1 = mod(uv,      a) - ah;\n    vec2 tile2 = mod(uv + ah, a) - ah;\n    \n    uv = length(tile1) < length(tile2) ? tile1 : tile2;\n    float d = max(abs(uv.x), dot(abs(uv), a * 0.25));\n    return vec3(uv, d);\n}\n\nfloat ashanoha(vec2 uv)\n{\n    uv *= 10.0;\n    \n    vec2 p0 = vec2(0.0);\n    vec2 p1 = vec2(1.0,  1.0 / 1.7320508);\n    vec2 p2 = vec2(-p1.x, p1.y);\n    vec2 p3 = vec2(0.0, -2.0 / 1.7320508);\n    vec2 p4 = p1 * 0.5;\n    vec2 p5 = p2 * 0.5;\n    vec2 p6 = p3 * 0.5;\n\n    vec3 uvw1 = honeycomb(uv);\n    vec3 uvw2 = honeycomb(uv - p1);\n\n    float d = 1e+3;\n    d = min(d, abs(dot(p1 * 0.5 - uvw1.xy, p1)));\n    d = min(d, abs(dot(p2 * 0.5 - uvw1.xy, p2)));\n    d = min(d, abs(dot(p3 * 0.5 - uvw1.xy, p3)));\n    d = min(d, abs(uvw1.z - 1.0));\n    d = min(d, abs(uvw2.z - 1.0));\n\n    return d;\n}\n\nfloat shippou(vec2 uv)\n{\n    uv *= 4.0;\n    uv = fract(uv);\n    \n    float neighborDist = 1e+4;\n    for(float x=-1.0; x<=1.0; x+=2.0)\n        for(float y=-1.0; y<=1.0; y+=2.0)\n            neighborDist = min(neighborDist, distance(uv, vec2(x,y) * 0.5 + vec2(0.5)));\n    \n    float dist = 1e+4;\n    dist = distance(uv, vec2(0.5));\n    dist = max(dist, neighborDist);\n    return dist;\n}\n\nfloat ichimatsu(vec2 uv)\n{\n    uv *= 2.0;\n    float x = sin(uv.x * TAU);\n    float y = sin(uv.y * TAU);\n    return sign(x * y) * min(abs(x), abs(y));\n}\n\nfloat seigaiha(vec2 uv)\n{\n    uv *= 4.0;\n    \n    vec2 grid = floor(uv / vec2(1.0, 0.5));\n    uv.x += grid.y * 0.5;\n    \n    grid = floor(uv / vec2(1.0, 0.5));\n    uv = mod(uv, vec2(1.0, 0.5)) * 2.0 - vec2(1.0, 0.0);\n\n    float dist = length(uv);\n    \n    for(float x=-1.0 ; x<=1.0 ; x+=2.0)\n    {\n        float d = length(uv + vec2(x, 1.0));\n        dist = d < 1.4 ? d : dist;\n    }\n    \n    return sin(dist * TAU * 2.0);\n}\n\nfloat yagasuri(vec2 uv)\n{\n    uv *= 3.0;\n    \n    vec2 grid = floor(uv / vec2(0.5, 2.0));\n    float x = mod(uv.x, 0.5) * 2.0;\n    grid = floor(vec2(x, uv.y) / vec2(0.5, 2.0));\n    \n    float zigzag = sign(mod(grid.x, 2.0) * 2.0 - 1.0);\n    uv.y += step(zigzag, 0.0) + x * zigzag;\n    \n    return ichimatsu(uv * 0.5) * (smoothstep(0.0, 0.1, abs(x - 0.5)) - 0.3);\n}\n\nfloat kagome(vec2 uv)\n{\n    uv *= 3.05;\n    uv = fract(uv * vec2(1.7320508, 1.0)) * 2.0 - 1.0;\n    uv.x += 0.2;\n    \n    float v = 0.0;\n    v = max(v, smoothstep(-0.6, -0.5, uv.y) * smoothstep(-0.4, -0.5, uv.y));\n    v = max(v, smoothstep( 0.4,  0.5, uv.y) * smoothstep( 0.6,  0.5, uv.y));\n    v = max(v, smoothstep( 0.0,  0.2, uv.x + uv.y) * smoothstep(0.4, 0.2, uv.x + uv.y));\n    v = max(v, smoothstep( 0.0,  0.2, uv.x - uv.y) * smoothstep(0.4, 0.2, uv.x - uv.y));\n    v = max(v, smoothstep( 0.0,  0.2, uv.x + uv.y + 2.0) * smoothstep(0.4, 0.2, uv.x + uv.y + 2.0));\n    v = max(v, smoothstep( 0.0,  0.2, uv.x - uv.y + 2.0) * smoothstep(0.4, 0.2, uv.x - uv.y + 2.0));\n    \n    return v;\n}\n\nfloat sayagata(vec2 uv)\n{\n    uv.y *= 1.5;\n    uv *= rotate(PI * 0.25);\n\n    vec2 grid = floor(uv * 4.0);\n    uv = fract(uv * 4.0) * 2.0 - 1.0;\n    uv *= 2.5;\n    \n    grid = mod(grid, 2.0) * 2.0 - 1.0;\n    uv.x *= grid.x * grid.y;\n\n    float dist = 1e+3;\n    \n    for(float i=0.0; i<4.0; ++i)\n    {\n        vec2 p0 = vec2( 0.0);\n        vec2 p1 = vec2( 0.0, 1.0) * rotate(i * PI * 0.5);\n        vec2 p2 = vec2(-1.0, 1.0) * rotate(i * PI * 0.5);\n        vec2 p3 = vec2(-1.0, 2.0) * rotate(i * PI * 0.5);\n        vec2 p4 = vec2( 3.0, 2.0) * rotate(i * PI * 0.5);\n        dist = min(dist, distanceLine(p0, p1, uv));\n        dist = min(dist, distanceLine(p2, p1, uv));\n        dist = min(dist, distanceLine(p2, p3, uv));\n        dist = min(dist, distanceLine(p4, p3, uv));\n    }\n    \n    return dist;\n}\n\nfloat hishi(vec2 uv)\n{\n    float d = 1e+3;\n    \n    vec2 luv = pmod(uv * vec2(1.0, 1.3), 4.0);\n    \n    vec2 p0 = vec2(0.0, 0.65);\n    vec2 p1 = vec2(0.0, 1.2) + p0;\n    vec2 p2 = vec2(0.7) + p0;\n    vec2 p3 = vec2(-p2.x, p2.y);\n    vec2 p4 = p1 * 0.45;\n\n    d = min(d, distanceLine(p0, p1, luv));\n    d = min(d, distanceLine(p0, p2, luv));\n    d = min(d, distanceLine(p0, p3, luv));\n\n    d = max(d, 0.45 - distanceLine(-p4, p4, uv));\n    d = max(d, 0.45 - distanceLine(-p4.yx, p4.yx, uv));\n    d = max(d, 0.8 - length(uv));\n    d = min(d, length(uv) + 0.1);\n\n    return d;\n}\n\nfloat kikko(vec2 uv)\n{\n    uv *= 6.4;\n    vec3 uvw = honeycomb(uv);\n    uvw.z = 1.0 - uvw.z;\n    \n    float d = 1e+3;\n    d = min(d, uvw.z);\n    d = min(d, smoothstep(0.3, 0.0, uvw.z) + smoothstep(0.3, 0.4, uvw.z));\n    d = min(d, hishi(uvw.xy * 4.0) * 0.3);\n    \n    return d;\n}\n\nbool animJapanesePattern(float time, int timeOffset, vec2 uv)\n{\n    time /= TAU;\n    int pattern = int(floor(mod(time + float(timeOffset), float(JAPANESE_PATTERN))));\n    float patternTime = fract(time);\n    float fadeTime1 = smoothstep(0.9, 1.0, cos(patternTime * TAU) * 0.5 + 0.5);\n    float fadeTime2 = smoothstep(0.0, 0.1, patternTime) * 0.5 + smoothstep(0.9, 1.0, patternTime) * 0.5;\n    \n    switch (pattern)\n    {\n    case 0: return ashanoha(uv)  < mix( 0.05, 0.26, fadeTime1);\n    case 1: return shippou(uv)   < mix( 0.5, 0.75, fadeTime1);\n    case 2: return ichimatsu(uv) > mix(-2.0, 2.0, fadeTime2);\n    case 3: return seigaiha(uv)  < mix(-0.3,-1.1, fadeTime1);\n    case 4: return kagome(uv)    > mix( 0.5, 1.5, fadeTime1);\n    case 5: return sayagata(uv)  < mix( 0.25,-0.25, fadeTime1);\n    case 6: return kikko(uv)     < mix( 0.1,-0.1, fadeTime1);\n    case 7: return yagasuri(uv)  < mix(-2.0, 2.0, fadeTime2);\n    }\n    \n    return true;\n}\n\n//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\n//                     Main\n//_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/\nstruct Result\n{\n    float dist;\n    float type;\n    vec3 position;\n    vec3 local;\n    vec3 normal;\n    vec3 dir;\n    vec3 gridID;\n    bool isOvershoot;\n};\n\nMaterial Materials[6] = Material[](\n    Material(vec3(0.0),                 vec3(1.0),           vec3(0.0), vec3(0.0), 0.0, 0.0),   // 0: sky sphere\n    Material(vec3(1.022, 0.782, 0.344), vec3(1.0),           vec3(0.0), vec3(0.0), 0.4, 1.0),   // 1: gold rough\n    Material(vec3(1.022, 0.782, 0.344), vec3(1.0),           vec3(0.0), vec3(0.0), 0.1, 1.0),   // 2: gold clean (unuse)\n    Material(vec3(0.0, 0.0, 0.0),       vec3(0.9, 0.9, 1.0), vec3(0.0), vec3(0.0), 0.25, 0.15), // 3: urushi black\n    Material(vec3(1.0, 0.08, 0.05),     vec3(1.0, 0.9, 0.9), vec3(0.0), vec3(0.0), 0.3, 0.15),  // 4: urushi vermilion\n    Material(vec3(0.7, 0.9, 1.0),       vec3(1.0),           vec3(0.0), vec3(0.0), 0.1, 0.05)   // 5: uruchi wood\n);\n\nfloat planeDistance(vec3 planePos, vec3 planeNormal, vec3 rayPos, vec3 rayDir)\n{\n    return abs(dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal));\n}\n\nfloat sdCellCube(vec3 pos)\n{\n    // IQ's distance \"sdRoundBox\"\n    vec3 posAbs = abs(pos) - CELL_SIZE * 0.4;\n    return length(max(posAbs, 0.0)) + min(max(posAbs.x, max(posAbs.y, posAbs.z)),0.0) - CELL_SIZE * 0.1;\n    //return length(max(posAbs, 0.0));\n}\n\nResult map(vec3 rayPos, vec3 rayDir)\n{\n    vec2 mapInfo = vec2(1e+3, 0.0);\n    \n    // cell grid\n    const vec3 GridStartID = vec3(CUBE_HALFSIZE / CELL_SIZE);\n    vec3 grid = floor(rayPos / CELL_SIZE) + GridStartID;\n    vec3 gridID = mod(grid, CUBE_SIZE);\n    \n    // cell info\n    vec4  cellInfo = texture(iChannel0, getBufferCellUV(gridID, iResolution.xy));\n    float cellExist         = cellInfo.x;\n    float cellID            = cellInfo.x;\n    vec3  cellDir           = getDirection(cellInfo.y);\n    float cellNeighborExist = cellInfo.z;\n    vec3  cellNeighborDir   = getDirection(cellInfo.w);\n    \n    float time = fract(float(iFrame) / MOVE_FRAME);\n    vec3 pos = mod(rayPos, CELL_SIZE) - CELL_SIZE * 0.5;\n    \n    // cell cube\n    float cellDist = (1.0 <= cellExist ? sdCellCube(pos - CELL_SIZE * cellDir * time) : CELL_SIZE);\n    mapInfo = vec2(cellDist, 1.0);\n    \n    // neighbor cell cube\n    float neighborCellDist = (1.0 <= cellNeighborExist ? sdCellCube(pos + CELL_SIZE * (cellNeighborDir) * (1.0 - time)) : CELL_SIZE);\n    mapInfo = mapInfo.x < neighborCellDist ? mapInfo : vec2(neighborCellDist, 2.0);\n\n    // wall(3 plane)\n    mapInfo.x = max(mapInfo.x, CUBE_HALFSIZE < abs(rayPos.x) ? planeDistance(vec3(CUBE_HALFSIZE * sign(-rayDir.x), 0.0, 0.0), vec3(1.0, 0.0, 0.0), rayPos, rayDir) + 2e-3 : 0.0);\n    mapInfo.x = max(mapInfo.x, CUBE_HALFSIZE < abs(rayPos.y) ? planeDistance(vec3(0.0, CUBE_HALFSIZE * sign(-rayDir.y), 0.0), vec3(0.0, 1.0, 0.0), rayPos, rayDir) + 2e-3 : 0.0);\n    mapInfo.x = max(mapInfo.x, CUBE_HALFSIZE < abs(rayPos.z) ? planeDistance(vec3(0.0, 0.0, CUBE_HALFSIZE * sign(-rayDir.z)), vec3(0.0, 0.0, 1.0), rayPos, rayDir) + 2e-3 : 0.0);\n    \n    // anti overshoot cellgrid\n    float disableOvershoot = saturate(length(step(CUBE_HALFSIZE, abs(rayPos))));\n    vec3 gridDist = abs((step(0.0, rayDir) * CELL_SIZE - mod(rayPos, CELL_SIZE)) / rayDir);\n    float overshootDist = min(mapInfo.x, min(gridDist.x, min(gridDist.y, gridDist.z)) + 1e-3 + disableOvershoot * 1e+3);\n    bool isOvershoot = mapInfo.x > overshootDist && (abs(overshootDist) - abs(mapInfo.x) <= 5e-3);\n    mapInfo.x = min(mapInfo.x, overshootDist);\n    \n    vec3 localPosOffset = vec3(0.0);\n    localPosOffset += -CELL_SIZE * cellDir * time * float(mapInfo.y == 1.0);\n    localPosOffset +=  CELL_SIZE * cellNeighborDir * (1.0 - time) * float(mapInfo.y == 2.0);\n    \n    Result result;\n    result.dist = mapInfo.x;\n    result.type = mapInfo.y;\n    result.gridID = gridID;\n    result.local = pos + localPosOffset;\n    result.isOvershoot = isOvershoot;\n    return result;\n}\n\nvec3 computeNormal(vec3 rayPos, vec3 rayDir)\n{\n    const vec2 EPSILON = vec2(3e-3, 0.0);\n    return normalize(vec3(\n        map(rayPos + EPSILON.xyy, rayDir).dist - map(rayPos - EPSILON.xyy, rayDir).dist,\n        map(rayPos + EPSILON.yxy, rayDir).dist - map(rayPos - EPSILON.yxy, rayDir).dist,\n        map(rayPos + EPSILON.yyx, rayDir).dist - map(rayPos - EPSILON.yyx, rayDir).dist\n    ));\n}\n\nResult march(vec3 cameraPos, vec3 cameraDir, int iteration)\n{\n    Result result;\n    result.dir = cameraDir;\n    result.type = result.dist = 0.0;\n    result.position = result.position = result.gridID = vec3(0.0);\n    \n    vec3 rayPos = cameraPos;\n    float rayDist = 0.0;\n\n    for(int i = 0; i < iteration; ++i)\n    {\n        rayPos = cameraPos + cameraDir * rayDist;\n        \n        Result mapResult = map(rayPos, cameraDir);\n        rayDist += mapResult.dist;\n\n        if(1e+2 < mapResult.dist)\n            break;\n            \n        if(mapResult.dist < 1e-3)// && !mapResult.isOvershoot)\n        {\n            result.type = mapResult.type;\n            result.type = 100.0 <= result.type ? result.type - 100.0 : result.type;\n            result.gridID = mapResult.gridID;\n            result.dist = rayDist;\n            result.local = mapResult.local;\n            result.position = cameraPos + cameraDir * rayDist;\n            result.normal = computeNormal(result.position, cameraDir);\n            break;\n        }        \n    }\n\n    return result;\n}\n\nfloat shadow(vec3 rayPos, vec3 rayDir, float rayMin, float rayMax, float k)\n{\n    float attenuation = 1.0;\n    \n    for(float dist = rayMin; dist < rayMax; )\n    {\n        vec3 pos = rayPos + rayDir * dist;\n        Result mapResult = map(pos, rayDir);\n        dist += mapResult.dist;\n        \n        if(!mapResult.isOvershoot)\n            attenuation = min(attenuation, k * mapResult.dist / dist);\n        \n        if(mapResult.dist < 1e-3)\n            break;\n    }\n    \n    return attenuation;\n}\n\nvec2 computeUV(vec3 position, vec3 normal) // for round cube\n{\n    vec2 uv = vec2(0.0);\n    vec3 enableNormal = step(vec3(0.70710678), abs(normal)); // abandon corner...\n\n    uv = mix(uv, enableNormal.x * position.zy, enableNormal.x);\n    uv = mix(uv, enableNormal.y * position.xz, enableNormal.y);\n    uv = mix(uv, enableNormal.z * position.xy, enableNormal.z);\n\n    return uv;\n}\n\nint getMaterialID(Result result, vec2 uvc)\n{\n    int type = int(round(result.type));\n    if(1 <= type && type <= 2)\n    {\n        vec4 cellInfo = texture(iChannel0, getBufferCellUV(result.gridID, iResolution.xy));\n        int cellTypeID = int(round(type == 1 ? cellInfo.x : cellInfo.z)) - 1;\n        int baseID = 3 + cellTypeID / JAPANESE_PATTERN;\n        int noiseID = int(floor(hash(vec2(cellTypeID, 0.0)) * float(JAPANESE_PATTERN)));\n\n        float animTime = iTime - result.position.y * 0.1;\n        bool isGoldNormalY = step(0.70710678, abs(result.normal.y)) == 1.0;\n        vec2 uv = computeUV(result.local / CELL_SIZE, result.normal);\n        return isGoldNormalY || animJapanesePattern(animTime, noiseID, uv) ? 1 : baseID;\n    }\n    \n    return 0;\n}\n\nvec3 materialize(in Result result, in vec2 uv, in vec3 reflectionColor, in vec3 cameraDir, in vec3 lightDir, in float shadow, in float aoShadow)\n{\n    int materialID = getMaterialID(result, uv);\n    Material material = Materials[materialID];\n    material.emissiveColor += float(result.type == 0.0) * texture(iChannel1, result.dir).rgb * 0.5;\n    material.reflectionColor += float(result.type == 1.0) * (reflectionColor * 1.0);\n    material.reflectionColor += float(result.type == 2.0) * (reflectionColor * 1.0);\n    \n    if(5 <= materialID)\n    {\n        vec2 uv = computeUV(result.local, result.normal);\n        uv += CELL_SIZE * 0.5;\n        material.diffuseColor *= saturate(pow(texture(iChannel3, uv / CELL_SIZE).rgb * 1.25, vec3(2.0)));\n    }\n    \n    material.roughness = clamp(material.roughness, 0.01, 1.0);\n    \n    BRDFDesc desc;\n    desc.lightDir = lightDir;\n    desc.viewDir = -cameraDir;\n    desc.normal = result.normal;\n    desc.anisoX = vec3(0.0, 0.0, 0.0);\n    desc.anisoY = vec3(0.0, 0.0, 0.0);\n    desc.shadowAttenuation = shadow;\n    desc.aoAttenuation = aoShadow;\n    \n    if(result.type == 0.0)\n        return material.emissiveColor;\n    \n    return computeBRDF(material, desc);\n}\n\nResult reflection(Result result, int generation, vec3 refDirOffset)\n{\n    vec4 ret = vec4(0.0);\n    \n    vec3 reflectionPosition = result.position - result.dir * 1e-2;\n    vec3 reflectionDirection = reflect(result.dir, result.normal);\n    \n    vec2 dir = vec2(1.0, 0.0);\n    vec3 tangent = normalize(cross(result.normal, abs(dot(dir.xyy, result.normal)) < 0.9 ? dir.xyy : dir.yxy)); // (´；ω；｀)\n    vec3 binormal = cross(result.normal, tangent);\n    tangent = cross(result.normal, binormal);\n\n    // angle noise in tangent space\n    reflectionDirection *= mat3(tangent, result.normal, binormal);\n    reflectionDirection = normalize(reflectionDirection + refDirOffset);\n    reflectionDirection = mat3(tangent, result.normal, binormal) * reflectionDirection;\n    \n    return march(reflectionPosition, reflectionDirection, 25 - 5 * generation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Render\n    vec3 cameraPos = vec3(0.0, sin(iTime * 0.2) * 40.0, -80.0);\n    vec3 cameraDir = normalize(vec3(uv, 2.0));\n    vec3 lightDir = normalize(vec3(0.2, 0.3, -0.5));\n    \n    float cameraAngle = iMouse.x / iResolution.x * -TAU + iTime * 0.3;\n    float cameraAngle2 = sin(iTime * 0.2) * 0.625;\n    cameraPos.xz *= rotate(cameraAngle);\n    cameraDir.yz *= rotate(cameraAngle2);\n    cameraDir.xz *= rotate(cameraAngle);\n    \n    Result result = march(cameraPos, cameraDir, 120);\n    \n    // Reflection\n    Material material = Materials[getMaterialID(result, uv)];\n    float roughness = material.roughness;\n\n    vec3 reflectionColor = vec3(0.0);\n    float reflectionCount = 0.0;\n    for(int t=0 ; t<3 ; t++)\n    {\n        Result refResult = result;\n    \n        for(int i=0 ; i<3; i++)\n        {\n            vec3 seed = floor(refResult.position * 30.0);\n            vec2 offset = hash2(seed.xz * (seed.y + 1e+3) + float(t+1)) * 2.0 - 1.0;\n            refResult = reflection(refResult, i, pow(roughness, 4.0) * normalize(vec3(offset, 0.0)));\n\n            vec3 color = materialize(refResult, uv, vec3(0.0), cameraDir, lightDir, 1.0, 1.0);\n            reflectionColor += abs(color); // minus number for reflection direction (some reason)\n            reflectionCount ++;\n\n            if(refResult.type <= 0.0)\n                break;\n        }\n    }\n    \n    // Shadow\n    float shadowAttenuation = shadow(result.position, lightDir, 0.1, 10.0, 20.0);\n    shadowAttenuation = clamp(shadowAttenuation, 0.5, 1.0);\n    \n    // AmbientOcclusion\n    Result aoResult = map(result.position + result.normal * 5.0, cameraDir);\n    float aoAttenuation = mix(clamp(aoResult.dist / 5.0, 0.5, 1.0), 1.0, float(aoResult.isOvershoot));\n    \n    // Result\n    fragColor.rgb = materialize(result, uv, reflectionColor / reflectionCount, cameraDir, lightDir, shadowAttenuation, aoAttenuation);\n    fragColor.a = luminance(fragColor.rgb);\n}\n\n\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// postprocess (bloom 2pass)\n\n//\n// from reinder : https://www.shadertoy.com/view/ls3GWS\n// FXAA code from: http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/\n// license : BSD-3-Clause\n//\nvec3 fxaaPixelShader(vec4 uv, sampler2D tex, vec2 rcpFrame)\n{\n    #define FXAA_SPAN_MAX 8.0\n    #define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n    #define FXAA_REDUCE_MIN   (1.0/128.0)\n\n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 onePixel = 1.0 / iResolution.xy;\n    vec2 uv = fragCoord * onePixel;\n\n    // FXAA\n    vec4 uv2 = vec4(uv, uv - (onePixel * (0.5 + 1.0/4.0)));\n    fragColor.rgb = fxaaPixelShader(uv2, iChannel0, onePixel);\n    \n    // bloom\n    fragColor.a = bloom(iChannel0, uv, vec2(1), onePixel);\n}","name":"Buffer C","description":"","type":"buffer"}]}