{"ver":"0.1","info":{"id":"XlKyDR","date":"1535773045","viewed":167,"name":"Fake3DTexture_1.0","username":"Ecter","description":"Example of how to implement fake 3D texture by saving to BufferB.   Using this method you could pre-calculate a volume of noise and save on performance.   Note you may see seams, however I'm not sure how to fix. Note move with WASD, rotate arrow keys. ","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","noise","ray","volume","texture","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int NULL_ID = -1;\nconst int SPHERE_ID = 0;\nconst int VSPHERE_ID = 1;\nconst int BOX_ID = 2;\n\nSphere test_sphere = Sphere(vec3(0.0, 7.0, 0.0),1.0);\nSphere volume_sphere = Sphere(vec3(0.0, 5.0, 0.0),2.0);\nBox test_box = Box(vec3(0.0,0.0,0.0), vec3(2.0,2.0,2.0));\nfloat signedDistance(vec3 ray_endpoint, out int obj_id){\n    float d0 = signedDistance(ray_endpoint, test_sphere);\n    float d1 = signedDistance(ray_endpoint, volume_sphere);\n    float d2 = signedDistance(ray_endpoint, test_box);\n    float minval = min(d0, d1);\n    obj_id = minval == d0 ? SPHERE_ID : VSPHERE_ID;\n    minval = min(minval, d2);\n\tobj_id = minval == d2 ? BOX_ID : obj_id;\n    return minval;\n}\n\nbool rayMarch(ScreenRay ray, in RayMarchSettings settings, out float out_depth, out int out_obj_id){\n    float depth = 0.0;\n    //float cosA = length(ray.direction);\n    for( int i = 0; i < settings.max_steps; ++i){\n        vec3 ray_endpoint = ray.origin + ray.direction * depth;\n        int obj_id;\n        float ray_distance = signedDistance(ray_endpoint, obj_id);\n        depth += ray_distance * settings.depth_weight;\n        if(ray_distance <= settings.min_distance){\n            //out_depth = depth;\n            ray_endpoint = ray.origin + ray.direction * depth;\n            ray_distance = signedDistance(ray_endpoint, obj_id);\n            out_depth = depth + ray_distance * 2.0;\n            out_obj_id = obj_id;\n            return true;\n        }\n\n        if(depth > settings.max_distance){\n            break;\n        }\n    }\n    out_depth = inf;\n    out_obj_id = NULL_ID;\n    return false;\n}\n\nfloat checkerBoardTexture(in vec2 uv){\n    vec2 q = floor(uv);\n    return clamp(mod( q.x+q.y, 2.0 ), 0.25, 1.0);\n}\nfloat fogify(in float dist){\n    return  1.0/ (1.0 + dist*dist * 0.1);\n}\n\nRayMarchSettings rm_settings = RayMarchSettings(128, 100000.0, 0.01, 0.5);\n\n\nconst float u_fov = 45.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Sampler3DSizeInfo sampler_info = Sampler3DSizeInfo(TEX3D_SIZE_DIM, TEX3D_Z_TILING_DIM, iResolution.xy);\n    vec3 rotation = getRotation(iChannel1);\n    vec3 origin = getOrigin(iChannel1);\n    ScreenRay ray = getRay(fragCoord/iResolution.xy, iResolution, rotation, origin, u_fov);\n\n    float depth = inf;\n    int obj_id = NULL_ID;\n\n    vec3 color = vec3(0.0);\n    if(rayMarch(ray, rm_settings, depth, obj_id)){\n        vec3 endpoint = ray.origin + ray.direction * depth;\n        float pattern_value = checkerBoardTexture(endpoint.xz * 4.0);\n\n        if(obj_id == SPHERE_ID){\n            color = vec3(1.0)*pattern_value;\n        }\n        if(obj_id == VSPHERE_ID){\n            color = vec3(0.0,  1.0, 0.0)*pattern_value;\n        }\n\n        switch(obj_id){\n            case SPHERE_ID:\n            color = vec3(1.0)*pattern_value;\n            break;\n            case VSPHERE_ID:\n            color = textureAs3D(iChannel2, sampler_info, (endpoint + vec3(sin(iTime)*6.0,0.0,0.0))*8.0).xyz;\n            color = norm01(color);\n            break;\n            case BOX_ID:\n            \t//distorting noise\n            \tvec3 temp_pos = textureAs3D(iChannel2, sampler_info, (endpoint + vec3(sin(iTime)*6.0,0.0,0.0))*8.0).xyz;\n            \t//multiplying by 8.0 because coordinates are actually not that big, so need to increase frequency sampling at from\n            \t//texture\n            \tcolor = textureAs3D(iChannel2, sampler_info, (endpoint+temp_pos*1.0)*8.0).xyz;\n            \t\n            \tcolor = norm01(color);\n\n            break;\n            default:\n            color = vec3(1.0, 0.0, 1.0)*pattern_value;\n        }\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//MATH CONSTANTS\nconst float pi \t= 3.1415926535897932384626433832795;\nconst float tau = 6.2831853071795864769252867665590;\nconst float eta = 1.5707963267948966192313216916397;\nconst float SQRT3 = 1.7320508075688772935274463415059;\nconst float SQRT2 = 1.4142135623730950488016887242096;\nconst float LTE1 =  0.9999999999999999999999999999999;\nconst float inf = uintBitsToFloat(0x7F800000u);\n\n#define saturate(x) clamp(x,0.0,1.0)\n#define norm01(x) ((x + 1.0) / 2.0)\n\n//KEYS\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\n\n\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_U = 85;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_X = 88;\nconst int KEY_Y = 89;\nconst int KEY_Z = 90;\n\n\n//IO \nconst ivec2 position_index = ivec2(0, 1);\nconst ivec2 rotation_index = ivec2(0, 2);\nconst ivec2 resolution_index = ivec2(0, 3);\n\nvec4 loadValue(in sampler2D iChannel, in ivec2 value_index ){\n    return texelFetch( iChannel, value_index, 0 );\n}\n\nvoid storeValue( in ivec2 value_index, in vec4 value, \n                inout vec4 fragColor, in ivec2 ifragCoord ){\n    fragColor = ( value_index == ifragCoord.xy ) ? value : fragColor;\n}\n\nfloat getKeyState(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,0),0 ).x;\n}\n\nfloat getKeyPress(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,1),0 ).x;\n}\n\nfloat getKeyToggle(in sampler2D iChannel, int key_id){\n    return texelFetch( iChannel, ivec2(key_id,2),0 ).x;\n}\n\nvec3 getOrigin(in sampler2D iChannel){\n    return vec3(0.0, 0.0, 0.0) + loadValue(iChannel, position_index).xyz;\n}\n\nvec3 getRotation(in sampler2D iChannel){\n    return vec3(0.0, 0.0, 0.0) + loadValue(iChannel, rotation_index).xyz;\n}\n\n\n///// NONIO\n\nvec2 modv(vec2 value, float modvalue){\n    return vec2(mod(value.x, modvalue), \n                mod(value.y, modvalue));\n}\nvec3 modv(vec3 value, float modvalue){\n    return vec3(mod(value.x, modvalue), \n                mod(value.y, modvalue),\n                mod(value.z, modvalue));\n}\nvec4 modv(vec4 value, float modvalue){\n    return vec4(mod(value.x, modvalue), \n                mod(value.y, modvalue),\n                mod(value.z, modvalue),\n                mod(value.w, modvalue));\n}\n\nvec3 rotVecX(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(1, 0, 0,\n                       0, cos(theta), -sin(theta),\n                       0, sin(theta), cos(theta));\n    return vector * rotmat;\n}\n\nvec3 rotVecY(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(cos(theta), 0, sin(theta),\n                       0, 1, 0,\n                       -sin(theta), 0, cos(theta));\n    return vector * rotmat;\n}\nvec3 rotVecZ(in vec3 vector, in float theta){\n    mat3 rotmat = mat3(cos(theta), -sin(theta), 0, \n                       sin(theta), cos(theta), 0,\n                       0, 1, 0);\n    return vector * rotmat;\n}\n\n\nvec2 calcSignNormalizedUV(in vec2 fragCoord, in vec3 resolution){\n    vec2 uv = fragCoord;\n    uv.x = (uv.x * 2.0) - 1.0;\n    uv.y = (2.0 * uv.y) - 1.0;\n    return uv;\n}\n\nvec3 calculateFragementRay(in vec2 fragCoord, in vec3 resolution, in float fov){\n    vec2 uv = fragCoord;\n    uv.x = (uv.x * 2.0) - 1.0;\n    uv.y = (2.0 * uv.y) - 1.0;\n    if(resolution.x >= resolution.y){\n        uv.x *= resolution.x/resolution.y;\n    }else{\n        uv.y *= resolution.y/resolution.x;\n    }\n    float tan_fov = tan(fov/2.0);\n    vec2 pxy = uv * tan_fov;\n    vec3 ray_dir = normalize(vec3(pxy, 1));\n    return ray_dir;\n}\n\nvec3 getRotatedRayDirection(vec3 ray_dir, in vec3 rotation){\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec3 ray_dir = calculateFragementRay(fragCoord, resolution);\n    ray_dir = rotVecX(ray_dir, rotation.x);\n    ray_dir = rotVecY(ray_dir, rotation.y);\n    return ray_dir;\n}\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct ScreenRay{\n    vec3 origin;\n    vec3 direction;\n    float cosA;\n};\n    \nScreenRay getRay(const in vec2 fragCoord, \n                 const in vec3 resolution, \n                 const in vec3 rotation, \n                 const in vec3 origin, \n                 const in float fov){\n\n    vec3 ray_dir = calculateFragementRay(fragCoord, resolution, fov);\n    vec3 rot_ray_dir = getRotatedRayDirection(ray_dir, rotation);\n    vec3 ray_origin = origin;\n    float cosA = ray_dir.z;\n    return ScreenRay(ray_origin, rot_ray_dir, cosA);\n}\n\n\nstruct RayMarchSettings{\n    int max_steps;\n    float max_distance;\n    float min_distance;\n    float depth_weight;\n};\n\nstruct Sphere{\n    vec3 origin;\n    float radius;\n};\n    \nfloat signedDistance(vec3 p, in Sphere sphere){\n    return (length(p - sphere.origin) - sphere.radius);\n}\n\n    \nstruct Box{\n    vec3 origin;\n    //dimensions, width, height, length\n    vec3 dim;\n\n};\n    \nfloat signedDistance( vec3 p, in Box box){\n  vec3 d = abs(p - box.origin) - box.dim;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n    \n    \n//can't stick samplers in structs (since you don't know memory layout)\n//otherwise would have done that, oh well. \nstruct Sampler3DSizeInfo{\n    //size of a single dimension of 3D cube\n    int size_dim;\n    //dimension for z tiling (must move tiles around to fit z dimension on 2D texture\n    ivec2 z_tiling_dim;\n    //dimension of base texture (usually iResolution.xy)\n    vec2 base_tex_size;    \n};\n\n\nvec2 pos3DTo2DBordered(const in Sampler3DSizeInfo sampler_info, in vec3 pos){\n    pos = modv(pos, float(sampler_info.size_dim));\n    int z_dim_x = int(pos.z) % sampler_info.z_tiling_dim.x;\n    int z_dim_y = int(pos.z) / sampler_info.z_tiling_dim.x;\n    // we put an extra pixel around the sides, hence the +2, we also put \n    // an extra line of pixels at the begining, hence +1.0. \n    float x = pos.x+1.0 + float(z_dim_x * (sampler_info.size_dim + 2));\n    float y = pos.y+1.0 + float(z_dim_y * (sampler_info.size_dim + 2));\n    return vec2(x,y)/sampler_info.base_tex_size;\n}\n\nvec4 textureAs3D(in sampler2D src_sampler,\n                 const in Sampler3DSizeInfo sampler_info,\n                 in vec3 pos){\n    //only need whole, will do another texture read to make sure interpolated?\n\n\tvec2 tex_pos = pos3DTo2DBordered(sampler_info, pos);\n    vec4 base_vec4 = texture(src_sampler, tex_pos);\n    \n    vec2 tex_pos_z1 = pos3DTo2DBordered(sampler_info, pos+vec3(0.0,0.0,1.0));\n    vec4 base_vec4_z1 = texture(src_sampler, tex_pos_z1);\n    //return base_vec4;\n    return mix(base_vec4, base_vec4_z1, fract(pos.z));\n}\n\n    \nconst int TEX3D_SIZE_DIM = 32;\nconst ivec2 TEX3D_Z_TILING_DIM = ivec2(8,4);\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float m_velocity = 0.01;\nconst float rotvel = 0.05;\n\nvec3 getAxisMovementVector(){\n\tfloat velocity = m_velocity;\n    float modifier = 1.0;\n    if(getKeyState(iChannel0, KEY_SHIFT) == 1.0){\n        modifier *= 10.0;\n    }else if(getKeyState(iChannel0, KEY_C) == 1.0){\n        modifier *= 0.1;\n    }else if(getKeyState(iChannel0, KEY_E) == 1.0){\n        modifier *= 10.0;\n    }\n    velocity *= modifier;\n    float left_move = getKeyState(iChannel0, KEY_A)*-velocity;\n    float up_move = getKeyState(iChannel0, KEY_W)*velocity;\n    float right_move = getKeyState(iChannel0, KEY_D)*velocity;\n    float down_move = getKeyState(iChannel0, KEY_S)*-velocity;\n\n    float x_move = left_move + right_move;\n    float y_move = 0.0;\n    float z_move = up_move + down_move;\n\n    return vec3(x_move, y_move, z_move);\n}\n\nvec3 getRotatedMovementVector(){\n    vec3 axis_move_vec = getAxisMovementVector();\n    vec3 last_rot = loadValue(iChannel1, rotation_index).xyz;\n        axis_move_vec = rotVecX(axis_move_vec, last_rot.x);\n        axis_move_vec = rotVecY(axis_move_vec, last_rot.y);\n    return axis_move_vec;\n}\n\nvec3 getRotationVector(){\n    float left_rot = getKeyState(iChannel0, KEY_LEFT)*-rotvel;\n    float up_rot = getKeyState(iChannel0, KEY_UP)*rotvel;\n    float right_rot = getKeyState(iChannel0, KEY_RIGHT)*rotvel;\n    float down_rot = getKeyState(iChannel0, KEY_DOWN)*-rotvel;\n    float x_rot = up_rot + down_rot;\n    float y_rot = left_rot + right_rot;\n    float z_rot = 0.0;\n    return vec3(x_rot, y_rot, z_rot); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    if(iFrame < 1)\n    {\n        fragColor = vec4(0.0,0.0,0.0,0.0); \n        storeValue(position_index, vec4(0.0, 0.0,-16.0, 0.0), fragColor, ifragCoord );\n        storeValue(resolution_index, vec4(0.0, 0.0, 0.0, 1.0), fragColor, ifragCoord );\n    } else if(position_index == ifragCoord) {        \n        vec3 move_vec = getRotatedMovementVector();\n        vec3 last_pos = loadValue(iChannel1, position_index).xyz;\n        vec3 new_pos =last_pos + move_vec;\n        storeValue(position_index, vec4(new_pos,0.0), fragColor, ifragCoord);\n\n    } else if(rotation_index == ifragCoord){\n        vec3 rot_vec = getRotationVector();\n        vec3 last_rot = loadValue(iChannel1, rotation_index).xyz;\n        vec3 new_rot = last_rot + rot_vec;\n        storeValue(rotation_index, vec4(new_rot,0.0), fragColor, ifragCoord);\n        \n    } else if(resolution_index == ifragCoord){\n        bool resolution_changed = loadValue(iChannel1, resolution_index).x != iResolution.x;\n        storeValue(resolution_index, vec4(iResolution, float(resolution_changed)), fragColor, ifragCoord);\n    }else{\n        discard;\n    }\n}  ","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n\n//noise\n\n//NOISE CONSTANTS\n// captured from https://en.wikipedia.org/wiki/SHA-2#Pseudocode\nconst uint CONST_A = 0xcc9e2d51u;\nconst uint CONST_B = 0x1b873593u;\nconst uint CONST_C = 0x85ebca6bu;\nconst uint CONST_D = 0xc2b2ae35u;\nconst uint CONST_E = 0xe6546b64u;\nconst uint CONST_F = 0x510e527fu;\nconst uint CONST_G = 0x923f82a4u;\nconst uint CONST_H = 0x14292967u;\n\nconst uint CONST_0 = 4294967291u;\nconst uint CONST_1 = 604807628u;\nconst uint CONST_2 = 2146583651u;\nconst uint CONST_3 = 1072842857u;\nconst uint CONST_4 = 1396182291u;\nconst uint CONST_5 = 2227730452u;\nconst uint CONST_6 = 3329325298u;\nconst uint CONST_7 = 3624381080u;\n\n\nuvec3 singleHash(uvec3 uval){\n    uval ^= uval >> 16;\n    uval.x *= CONST_A;\n    uval.y *= CONST_B;\n    uval.z *= CONST_C;\n    return uval;\n}\n\nuint combineHash(uint seed, uvec3 uval){\n    // can move this out to compile time if need be. \n    // with out multiplying by one of the randomizing constants\n    // will result in not very different results from seed to seed. \n    uint un = seed * CONST_5;\n    un ^= (uval.x^uval.y)* CONST_0;\n    un ^= (un >> 16);\n    un = (un^uval.z)*CONST_1;\n    un ^= (un >> 16);\n    return un;\n}\n\nconst vec3 gradArray3d[8] = vec3[8](\n    vec3(1, 1, 1), vec3(1,-1, 1), vec3(-1, 1, 1), vec3(-1,-1, 1),\n    vec3(1, 1,-1), vec3(1,-1,-1), vec3(-1, 1,-1), vec3(-1,-1,-1)\n);\n\n\n\nfloat fmad_mix(float a, float b, float c, float d, \n               float e, float f, float g, float h, \n               vec3 uvw){\n    float q = -uvw.x+1.0;//one op\n    float r = -uvw.y+1.0;//one op\n    float s = -uvw.z+1.0;//one op\n    float result = \n        s*(uvw.y*(uvw.x*d + q*c) + r*(uvw.x*b + q*a)) \n        + uvw.z*(uvw.y*(uvw.x*h + q*g) + r*(uvw.x*f + q*e));//14 ops  \n    return \tresult;\n}\n\n//easing function perlin used\nfloat perlinEase(float value){\n     return value * value * value * (value * (value * 6.0 - 15.0) + 10.0);\n}\n\nvec3 perlinEase(vec3 value){\n    return vec3(perlinEase(value.x), perlinEase(value.y), perlinEase(value.z));\n}\n\nconst uint idxBits3d = 7u;\n\n//from IQ\n// returns 3D value noise (in .x)  and its derivatives (in .yzw)\nfloat perlinNoise(uint seed, in vec3 xyz, uint wrap)\n{\n    // grid\n    vec3 corner = floor(xyz);\n    corner = modv(corner, float(wrap));\n    vec3 corner1 = corner + 1.0;\n    corner1 = modv(corner+1.0, float(wrap));\n    vec3 dist = fract(xyz);\n    \n    // quintic interpolant\n    vec3 uvw = perlinEase(dist);\n    uvec3 corner0hash = singleHash(uvec3(corner));\n    uvec3 corner1hash = singleHash(uvec3(corner1));\n    uint zz = (corner0hash.x^corner0hash.y) * CONST_0;\n    zz ^= zz >> 16;\n    uint zp = (corner1hash.x^corner0hash.y) * CONST_0;\n    zp ^= zp >> 16;\n    uint pz = (corner0hash.x^corner1hash.y) * CONST_0;\n    pz ^= pz >> 16;\n    uint pp = (corner1hash.x^corner1hash.y) * CONST_0;\n    pp ^= pp >> 16;\n    \n    uint uga = (zz^corner0hash.z)*CONST_1;\n    uint ugb = (zp^corner0hash.z)*CONST_1;\n    uint ugc = (pz^corner0hash.z)*CONST_1;\n    uint ugd = (pp^corner0hash.z)*CONST_1;\n    uint uge = (zz^corner1hash.z)*CONST_1;\n    uint ugf = (zp^corner1hash.z)*CONST_1;\n    uint ugg = (pz^corner1hash.z)*CONST_1;\n    uint ugh = (pp^corner1hash.z)*CONST_1;\n    uga ^= uga >> 16;\n    ugb ^= ugb >> 16;\n    ugc ^= ugc >> 16;\n    ugd ^= ugd >> 16;\n    uge ^= uge >> 16;\n    ugf ^= ugf >> 16;\n    ugg ^= ugg >> 16;\n    ugh ^= ugh >> 16;\n    \n    \n    // gradients\n    vec3 ga = gradArray3d[uga & idxBits3d];\n    vec3 gb = gradArray3d[ugb & idxBits3d];\n    vec3 gc = gradArray3d[ugc & idxBits3d];\n    vec3 gd = gradArray3d[ugd & idxBits3d];\n    vec3 ge = gradArray3d[uge & idxBits3d];\n    vec3 gf = gradArray3d[ugf & idxBits3d];\n    vec3 gg = gradArray3d[ugg & idxBits3d];\n    vec3 gh = gradArray3d[ugh & idxBits3d]; \n    \n    // projections\n    float va = dot( ga, dist-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, dist-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, dist-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, dist-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, dist-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, dist-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, dist-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, dist-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    float v = fmad_mix(va, vb, vc, vd, ve, vf, vg, vh, uvw);        \n    return v;  \n}\n\n//settings for fractal brownian motion noise\nstruct BrownianFractalSettings{\n    uint seed;\n    int octave_count;\n    float frequency;\n    float lacunarity;\n    float persistence;\n    float amplitude;\n};\n\nfloat accumulateNoise(in BrownianFractalSettings settings, vec3 pos, float wrap){\n    float accumulated_noise = 0.0;\n    wrap *= settings.frequency;\n    vec3 octave_pos = pos * settings.frequency;\n    for (int octave = 0; octave < settings.octave_count; octave++) {\n        //octave_pos = modv(octave_pos, wrap);\n        float noise = perlinNoise(settings.seed, octave_pos, uint(wrap));\n        noise *= pow(settings.persistence, float(octave));\n        accumulated_noise += noise;\n        octave_pos *= settings.lacunarity;\n        wrap *= settings.lacunarity;\n    }\n    float scale = 2.0 - pow(settings.persistence, float(settings.octave_count - 1));\n    return (accumulated_noise/scale) * settings.amplitude;\n}\n\n\nbool resolutionChanged(in sampler2D iChannel){\n    return bool(loadValue(iChannel1, resolution_index).w);\n}\t\n\n\nconst float frequency = 1.0/32.0;\n\n//necessary to update the storage of 3D texture when not using \n#define DEBUG_TEX3D_STORAGE false\n#define SETTINGS_CHANNEL iChannel1\n#define OUT_CHANNEL iChannel2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setting out put to previous value so that if the resolution hasn't changed, we won't bother to re-calc.\n    //resolution change may be usefull for resizing the fake 3D texture if screen size is too small, or becomes larger \n    //(and can get better texture resolution). \n    vec3 color = texture(OUT_CHANNEL, fragCoord/iResolution.xy).xyz;\n    if(resolutionChanged(SETTINGS_CHANNEL) || DEBUG_TEX3D_STORAGE){\n        \n        vec3 origin = vec3(norm01(sin(iTime))*0.0,0.0,0.0);\n\n        BrownianFractalSettings brn_settings = \n            BrownianFractalSettings(203u, 10, frequency, 2.0, 0.5, 1.0);\n        \n        const int buffer_size_dim = TEX3D_SIZE_DIM + 2;\n        ivec2 z_size = TEX3D_Z_TILING_DIM;\n        ivec2 iFragCoord = ivec2(fragCoord.x, fragCoord.y);\n        //int singl_dim = iFragCoord\n        int z_dim_x = iFragCoord.x / buffer_size_dim;\n        int z_dim_y = iFragCoord.y / buffer_size_dim;\n\n        if(z_dim_x < z_size.x && z_dim_y < z_size.y){\n            int ix = iFragCoord.x % buffer_size_dim;\n            //creating single pixel buffer around x axis for native linear interpolation filtering\n            if(ix == 0){\n                ix = TEX3D_SIZE_DIM - 1;\n            }else if(ix == (buffer_size_dim -1)){\n                ix = 0;\n            }else{//ix is within real gen bounds\n                ix -= 1;\n            }\n            //creating single pixel buffer around y axis for native linear interpolation filtering\n            int iy = iFragCoord.y % buffer_size_dim;\n            if(iy == 0){\n                iy = TEX3D_SIZE_DIM - 1;\n            }else if(iy == (buffer_size_dim -1)){\n                iy = 0;\n            }else{//iy is within real gen bounds\n                iy -= 1;\n            }\n            \n            int iz = (z_dim_x) + ((z_dim_y)*z_size.x);\n            vec3 pos = vec3(ix,iy,iz) + origin; \n            float value = accumulateNoise(brn_settings, pos, float(TEX3D_SIZE_DIM));\n            color = vec3(norm01(value));\n            color = vec3(value);\n        }else{\n            color = vec3(0.0,0.0,0.0);\n        }\n    }\n    fragColor = vec4(color,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}