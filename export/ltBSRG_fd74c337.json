{"ver":"0.1","info":{"id":"ltBSRG","date":"1444492405","viewed":2692,"name":"dithering: waveform","username":"hornet","description":"color dithering, LMB to fullscreen<br/>inspired by https://www.youtube.com/watch?v=JVoUgR6bhBc<br/>top to bottom:<br/>dithered, quantized signal<br/>dithered, quantized signal graphed<br/>error<br/>error graphed<br/>error histogram<br/>variance","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","dithering","variance","triangular","tpdf","rpdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ANIMATE\n//#define SINGLE_INDEX 3\n//#define INPUT_NOISERANGE\n//#define BRUTEFORCE_GAUSSIAN\n\n// ====\n\n// This set suits the coords of of 0-1.0 ranges..\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n//#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(p3.x * p3.z * p3.y);\n}\n\nfloat remap( float t, float a, float b ) {\n\treturn clamp( (t - a) / (b - a), 0.0, 1.0 );\n}\n\nconst float NUM_LEVELS_F = 64.0;\n\n//note: from https://www.shadertoy.com/view/MlVSzw\nfloat inv_error_function(float x)\n{\n\tconst float ALPHA = 0.14;\n\tconst float INV_ALPHA = 1.0 / ALPHA;\n    const float PI = 3.1415926535;\n\tconst float K = 2.0 / (PI * ALPHA);\n\n    float y = log(1.0 - x*x);\n\tfloat z = K + 0.5 * y;\n\treturn sqrt(sqrt(z*z - y * INV_ALPHA) - z) * sign(x);\n}\nfloat gaussian_rand( vec2 n )\n{\n    const float FLT_EPSILON = 0.0000001;\n\tfloat x = hash12( n );\n    x = max( x, FLT_EPSILON );\n\treturn inv_error_function(x*2.0-1.0)*0.15 + 0.5;\n}\n\n\nfloat dither1( float x, float seed, int dithering_type )\n{\n    if ( dithering_type == 1 )\n    {\n        //float t = ( iMouse.z < 0.5 ) ? 0.3 : iMouse.x / iResolution.x;\n        //x += (-0.5*t+(1.0+t)*hash11(seed)) / 255.0; //uniform noise\n        //x += (-0.15+1.3*hash11(seed)) / 255.0; //uniform noise\n        x += hash11(seed) / 255.0; //uniform noise\n    }\n    else if ( dithering_type == 2 )\n        x += (hash11(seed) + hash11(seed+3.1337) - 0.5 ) / 255.0; //triangular noise\n    else if ( dithering_type == 3 )\n    {\n        #ifdef BRUTEFORCE_GAUSSIAN\n        float rnd = 0.0;\n\t \trnd += hash11( seed + 0.07 );\n\t \trnd += hash11( seed + 0.11 );\t\n\t \trnd += hash11( seed + 0.13 );\n\t \trnd += hash11( seed + 0.17 );\n    \n    \trnd += hash11( seed + 0.19 );\n     \trnd += hash11( seed + 0.23 );\n     \trnd += hash11( seed + 0.29 );\n     \trnd += hash11( seed + 0.31 );\n        rnd /= 8.0;\n        #else\n        float rnd = gaussian_rand( vec2(seed) );\n        //TODO: mad 5.25/8.0\n        #endif\n\n        #ifdef INPUT_NOISERANGE\n        float t = ( iMouse.z < 0.5 ) ? 3.0/4.0 : iMouse.x / iResolution.x;\n        //t = 5.25/8.0;\n        rnd = (1.0 + 4.0 * t) * rnd - 2.0*t; //default to [-1.5;2.5[\n        #else\n        //rnd = rnd*5.0 - 2.0; // [-2;3[\n        rnd = rnd * 4.0 - 1.5; // [-1.5;2.5[\n        #endif\n        \n        x += rnd / 255.0;\n    }\n    else\n        x += 0.5 / 255.0; //straight rounding\n        \n    return x;\n}\nfloat dither2( float x, vec2 seed, int dithering_type )\n{\n    if ( dithering_type == 1 )\n    {\n        //float t = ( iMouse.z < 0.5 ) ? 0.3 : iMouse.x / iResolution.x;\n        //x += (-0.5*t+(1.0+t)*hash12(seed)) / 255.0; //uniform noise\n        //x += (-0.15+1.3*hash12(seed)) / 255.0; //uniform noise\n        x += hash12(seed) / 255.0; //uniform noise\n    }\n    else if ( dithering_type == 2 )\n        x += (hash12(seed) + hash12(seed+3.1337) - 0.5 ) / 255.0; //triangular noise    \n    else if ( dithering_type == 3 )\n    {\n        #ifdef BRUTEFORCE_GAUSSIAN\n        float rnd = 0.0;\n\t \trnd += hash12( seed + 0.07 );\n\t \trnd += hash12( seed + 0.11 );\t\n\t \trnd += hash12( seed + 0.13 );\n\t \trnd += hash12( seed + 0.17 );\n    \n    \trnd += hash12( seed + 0.19 );\n     \trnd += hash12( seed + 0.23 );\n     \trnd += hash12( seed + 0.29 );\n     \trnd += hash12( seed + 0.31 );\n        rnd /= 8.0;\n        #else\n        float rnd = gaussian_rand( seed );\n        //TODO: mad 5.25/8.0\n        #endif\n        \n        #ifdef INPUT_NOISERANGE\n        float t = ( iMouse.z < 0.5 ) ? 3.0/4.0 : iMouse.x / iResolution.x;\n        //t = 5.25/8.0;\n        rnd = (1.0 + 4.0 * t) * rnd - 2.0*t; //note: default to [-1.5;2.5[\n        #else\n        //rnd = rnd*5.0 - 2.0; // [-2;3[\n        rnd = rnd * 4.0 - 1.5; // [-1.5;2.5[\n        #endif\n        \n        x += rnd / 255.0;\n    }\n    else\n        x += 0.5 / 255.0; //straight rounding\n\n    return x;\n}\n\n\nfloat eval( float x, float seed, int dithering_type )\n{\n    float t = x / NUM_LEVELS_F;\n    t = dither1( t, seed, dithering_type );\n    t = floor( t * 255.0 ) / 255.0;\n    \n    return t;\n}\n\nvec3 render( vec2 uv, int type )\n{\n    bool use_uniform = type == 1;\n    bool use_triangular = type == 2;\n    bool use_gaussian = type == 3;\n\n    //signal\n    float s = uv.x;\n    #ifdef ANIMATE\n    s += 0.5 * (0.5 * sin( iTime ));\n    float time = fract( 0.1 * iTime );\n    #else\n    float time = 0.0;\n    #endif\n\n    float v = s / NUM_LEVELS_F;\n    \n    vec2 vseed = uv + time;\n    v = dither2( v, vseed, type );\n    v = floor( v * 255.0 ) / 255.0; //quantisation to 8bit\n\n    vec3 outcol = vec3(v) * NUM_LEVELS_F;\n    //return outcol; //DBG dithered signal\n    \n    //graph\n\tif ( uv.y < 1.0/6.0 )\n\t{\n        const int NUM_AVG = 512;\n        const float NUM_AVG_F_RCP = 1.0 / float(NUM_AVG);\n\n        vec2 luv = vec2( uv.x, remap(uv.y, 0.0/6.0, 1.0/6.0) );\n        \n        // note: running variance calculation\n        //https://www.johndcook.com/blog/standard_deviation/\n        float m_oldM, m_newM, m_oldS, m_newS;\n\n        float var = 0.0;\n        float diffvar = 0.0;\n        for ( int i=0; i<NUM_AVG; ++i )\n        {\n            float seed = s + float(i)*NUM_AVG_F_RCP + time;\n            float t = eval( s, seed, type );\n        \n            if (i == 0)\n            {\n                m_oldM = m_newM = t;\n                m_oldS = 0.0;\n            }\n            else\n            {\n                m_newM = m_oldM + (t - m_oldM) / float(i+1);\n                m_newS = m_oldS + (t - m_oldM)*(t - m_newM);\n\n                // set up for next iteration\n                m_oldM = m_newM; \n                m_oldS = m_newS;\n            }\n        }\n        \n        var = ( (NUM_AVG > 1) ? m_newS / float(NUM_AVG - 1) : 0.0 );\n        \n        var *= 255.0 * NUM_LEVELS_F * 9.0; //...really just a random scale-factor, std deviation\n        //var *= 255.0 * NUM_LEVELS_F * 0.02; //...really just a random scale-factor, deviation\n\n        diffvar /= float(NUM_AVG-1);\n        diffvar = clamp( diffvar, 0.0, 1.0f );\n        \n        float stddev = sqrt(var);\n\n        // https://en.wikipedia.org/wiki/Statistical_dispersion\n        float oc = step( var, luv.y ); // variance\n        //float oc = step( diffvar*250000.0, luv.y ); // error variance\n        //float oc = step( stddev, luv.y ); // standard deviation\n        //float oc = step( var*var, luv.y ); //...hmm... something, and closer to what I expected...\n        //float oc = step( 100.0*abs(mindiff), luv.y ); // min diff to mean\n        //float oc = step( 100.0*maxdiff, luv.y ); // max diff to mean?\n        //float oc = step( (maxdiff-mindiff)*50.0, luv.y );\n        \n        outcol = vec3(0.5 * oc);\n        outcol.rgb += 0.125 * step( abs(0.5-luv.y), 6.0/iResolution.y );\n        \n        //outcol.g += step( abs(300.0*meanerr-luv.y), 6.0/iResolution.y ); //meanerr\n        outcol.r += step( abs(diffvar*250000.0-luv.y), 6.0/iResolution.y ); //diff-var\n        \n        //outcol.g += step( abs(mean * NUM_LEVELS_F-luv.y), 6.0/iResolution.y ); //mean\n        //outcol.b += 0.5 * step( abs(s-luv.y), 3.0/iResolution.y ); //signal\n    }\n\telse if ( uv.y < 2.0/6.0 )\n    {\n\t\t//error histogram\n        vec2 luv = vec2( uv.x, remap(uv.y, 1.0/6.0, 2.0/6.0) );\n        const float minerr = -2.0/255.0;\n        const float maxerr = 4.0/255.0;\n        const float uvh = 1.0/5.0;\n        float uvhpx = uvh * iResolution.y;\n        vec2 bucketbounds = ( minerr*uvhpx + maxerr * vec2( luv.y*uvhpx - 1.0, luv.y * uvhpx + 1.0 )) / uvhpx;\n\n        float bucket = 0.0;\n        for ( int i=0; i<64; ++i )\n        {\n            float seed = s + float(i)/64.0 + time;\n        \tfloat t = eval( s, seed, type );\n            float signal = s/NUM_LEVELS_F;\n        \tfloat err = (signal - t); //error\n            bucket += float ( err > bucketbounds.x ) * float ( err < bucketbounds.y );\n        }\n        \n        //outcol = vec3( bucket / 100.0 ) * ((luv.y>0.5) ? vec3(0.5,0.75,1.0) : vec3(1.0,0.5,0.5));\n        outcol = vec3( bucket / 100.0 ) * ((luv.y>0.5) ? vec3(0.65,1.0,0.65) : vec3(1.0,0.65,0.65));\n        outcol.rgb += step( abs(0.5-luv.y), 3.0 / iResolution.y );\n        outcol.rgb += 0.5 * step( abs(0.25-luv.y), 3.0 / iResolution.y );\n        outcol.rgb += 0.5 * step( abs(0.75-luv.y), 3.0 / iResolution.y );\n    }\n    else if ( uv.y < 3.0 / 6.0 )\n    {\n        //note: error HAS to be two triangles,\n        //      because it is either a bit below or above, error of both is triangular\n        vec2 luv = vec2( uv.x, remap(uv.y, 2.0/6.0, 3.0/6.0) );\n        float seed = s + time;\n        float t = eval( s, seed, type );\n        //float err = abs(s/NUM_LEVELS_F - t); //abs error\n        float signal = s / NUM_LEVELS_F;\n        float err = signal - t; //error\n        float euv = luv.y * 2.0 - 1.0;\n        euv = euv / 255.0;\n        if ( euv > 0.0 )\n        \toutcol = vec3(0.25,0.5,0.25) * vec3( step(euv, err) );\n        else\n            outcol = vec3(0.5,0.125,0.125) * vec3( step(err, euv) );\n\n        outcol.rgb += 0.5 * step( abs(0.5-luv.y),  6.0/iResolution.y );   \n        \n        //outcol = vec3( abs(luv), 0.0);\n    }\n    else if ( uv.y < 4.0 / 6.0 )\n    {\n        float signal = s / NUM_LEVELS_F; //only show lower part of gradient\n        //float err = abs(signal - v ); //error\n        float err = signal - v + 1.0 / 255.0;\n        outcol = vec3( err * 100.0 );\n    }\n    else if ( uv.y < 5.0 / 6.0 )\n    {\n        /*\n\t\t//b0rked histogram\n        vec2 luv = vec2( uv.x, remap(uv.y, 1.0/6.0, 2.0/6.0) );\n        const float uvh = 1.0/5.0;\n        float uvhpx = uvh * iResolution.y;\n\n        //float maxval = float(1.0)/255.0;\n        float maxval = (1.0+floor(luv.x*8.0)/8.0) / 255.0;\n        \n        //return vec3( maxval * 128.0 );\n        \n        vec2 bucketbounds = maxval * vec2( luv.y * uvhpx - 1.0, luv.y * uvhpx + 1.0 ) / uvhpx;\n       \n        float bucket = 0.0;\n        for ( int i=0; i<64; ++i )\n        {\n        \tfloat t = eval( luv.x, luv.x + float(i)/64.0, type );\n        \t//oat err = abs(luv.x/NUM_LEVELS_F - t); //error\n            bucket += float ( t > bucketbounds.x ) * float ( t < bucketbounds.y );\n        }\n        \n        outcol = vec3( bucket / 128.0 );\n        \n        outcol.g += 0.5 * step( abs(0.5-luv.y), 0.015 );\n\t\t*/\n\n        const int NUM_AVG = 1;\n        const float NUM_AVG_F = float(NUM_AVG);\n\n        vec2 luv = vec2( uv.x, remap(uv.y, 4.0/6.0, 5.0/6.0) );\n        \n        float sum = 0.0;\n        for ( int i=0; i<NUM_AVG; ++i )\n        {\n            float seed = s + float(i)/NUM_AVG_F + time;\n            float t = eval( s, seed, type );\n        \tt *= NUM_LEVELS_F;\n            sum += t;\n        }\n        sum /= NUM_AVG_F;\n        \n        float oc = step( sum, luv.y );\n        outcol = vec3(0.5 * oc);\n        outcol.g += 0.5 * step( abs(s-luv.y), 3.0/iResolution.y ); //signal\n    }\n    \n    outcol.rgb += vec3( step( abs(mod(uv.y,1.0/6.0)), 2.0 / iResolution.y) );\n    \n    return outcol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n        \n    int idx = int( floor( 2.0*uv.x ) + 2.0 * floor(2.0*uv.y) );\n\n    \n    if ( iMouse.z > 0.5 )\n    {\n        vec2 muv = iMouse.xy / iResolution.xy;\n        idx = int( floor( 2.0*muv.x ) + 2.0 * floor(2.0*muv.y) );\n    }\n    #ifndef SINGLE_INDEX\n    else\n      \tuv = fract( 2.0 * uv );\n    #endif\n    \n    #ifdef SINGLE_INDEX\n    idx = SINGLE_INDEX;\n    #endif\n    \n    fragColor = vec4( render( uv, idx ), 1.0 );\n    \n    float t = max(step(0.4975, abs(uv.x-0.5)), step(0.495, abs(uv.y-0.5)));\n    \n    fragColor.rgb = mix( fragColor.rgb, vec3(1.0, 0.0, 0.0), t );\n    //fragColor.rgb = min( fragColor.rgb, vec3(1.0-t) );\n}\n","name":"Image","description":"","type":"image"}]}