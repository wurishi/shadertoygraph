{"ver":"0.1","info":{"id":"4dyBD3","date":"1530838836","viewed":208,"name":"Space Boy","username":"magician0809","description":"Rotate: WASDQE or Arrows or Mouse\nSpeed: FR or Mouse\nWhen you get too close to a star, time will be slowed...","likes":6,"published":1,"flags":48,"usePreview":0,"tags":["3d","rotate","star","space","gyroscope","gravity","ship","boy","gravitation","fly"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Written by Cairne.D 杜愷恩\n */\n\n\n//set other constants in label \"Common\"\n\n#define COLOR_MODE 2\n\n\n//mix color 混合颜色\nvoid MixColor(float lit, out vec4 color)\n{\n    float rlit = GetRenderIntensity(lit);\n    if (COLOR_MODE == 0)\n    {\n        color = GetRenderColorBlue(rlit);\n    }\n    else if (COLOR_MODE == 1)\n    {\n        color = GetRenderColorRed(rlit);\n    }\n    else\n    {\n        float t = clamp(sin(iTime/15.0*PI2-PIH)*2.0 + 0.5, 0.0, 1.0);\n        vec4 blue = GetRenderColorBlue(rlit);\n        vec4 red = GetRenderColorRed(rlit);\n        color = mix(blue, red, t);\n    }\n}\n\n\nvec4 GetStarPositionMass(int i)\n{\n    return texture(iChannel0, I2UV(i, iResolution.xy));\n}\nfloat GetCameraAcceleration()\n{\n    return texture(iChannel1, I2UV(0, iResolution.xy)).w;\n}\nvec4 GetCameraPositionSpeed()\n{\n    return texture(iChannel1, I2UV(1, iResolution.xy));\n}\nvec4 GetCameraRotation()\n{\n    return texture(iChannel1, I2UV(2, iResolution.xy));\n}\n\nfloat SemiCircle(float x)\n{\n    x -= 1.0;\n    return sqrt(1.0 - x * x);\n}\nCamera GetCurrentCamera()\n{\n    Camera cam;\n    cam.near = 0.001;\n    cam.far = 100000.0;\n    cam.aspect = iResolution.x / iResolution.y;\n    \n    vec4 ps = GetCameraPositionSpeed();\n    vec4 r = GetCameraRotation();\n    cam.pos = ps.xyz;\n    cam.rot = r;\n    cam.fov = mix(30.0, 90.0, SemiCircle(ps.w / MAX_FLY_SPEED));\n    \n    return cam;\n}\n\n//calculate field strength on pixel ray 计算每个像素射线的场强\nfloat CalculateIntensity(vec3 ro, vec3 rd)\n{\n    rd = normalize(rd);\n    vec3 accel = vec3(0);\n    for (int i = 0; i < STAR_COUNT; i++)\n    {\n        vec4 pm = GetStarPositionMass(i);\n        vec3 da = IntegrateAcceleration(pm.xyz - ro, rd, pm.w);\n        accel += da;\n    }\n    return length(accel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //apply camera operation 应用相机操作\n    Camera cam = GetCurrentCamera();\n    vec3 ro, rd;\n    ScreenRay(uv, cam, ro, rd);\n    \n    //calculate field strength per pixel 逐像素计算累计场强\n    float lit = CalculateIntensity(ro, rd);\n    \n    MixColor(lit, fragColor);\n    \n    ShipIBData data;\n    data.accel = GetCameraAcceleration();\n    data.speed = GetCameraPositionSpeed().w;\n    data.rotation = QuatInv(GetCameraRotation());\n    ShipInstrumentBoard(uv, cam, data, fragColor);\n    \n    \n    //vec3 p = ScreenToCamera(uv, 0.0, cam);\n    //fragColor.r += fract(p.x / (cam.near / 10.0));\n    //fragColor.g += fract(p.y / (cam.near / 10.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//---------------------------------------------------Constant 常数\n#define F_MAX     3.40282347e38\n#define F_EPSILON 1.401298e-45\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n#define FWD vec3(0,0,1)\n\n#define STAR_COUNT 128\n#define CONST_G 500.0\n#define DEFAULT_MASS 1000.0\n#define STAR_DENSITY 1000.0\n#define UNIVERSE_RADIUS 10000.0\n#define DELTA_TIME 0.02\n#define TIME_SCALE 1.0\n#define TIME_SLOW_FACTOR CONST_G / 20.0\n\n#define MAX_FLY_SPEED 1000.0\n#define INIT_FLY_SPEED 1.0\n#define FLY_ACCELERATION 0.2\n#define ROTATE_SPEED 0.65\n\n//trunc light for render [0,x] 截断渲染能量\n#define RENDER_INTENSITY_MAX 50000.0\n\n//pow 曝光度\n#define RENDER_INTENSITY_POW 1.0\n\n//fish eye factor 鱼眼因子\n#define FISH_EYE_FACTOR 0.2\n\n//---------------------------------------------------Hash 散列值\nfloat Hash21(vec2 p)\n{\n\treturn fract(sin(dot(p,vec2(12.99,78.23)))*43758.5453);\n}\nvec2 Hash22(vec2 p)\n{\n\treturn fract(sin(vec2(\n        dot(p,vec2(127.1,311.7)),\n        dot(p,vec2(269.5,183.3))\n    ))*43758.5453);\n}\nvec3 Hash23(vec2 p)\n{\n    return fract(sin(vec3(\n        dot(p,vec2(127.1,311.7)),\n        dot(p,vec2(269.5,183.3)),\n        dot(p,vec2(12.99,78.23))\n    ))*43758.5453);\n}\nvec3 HashS3(vec2 h2)\n{\n    float theta = h2.x*PI2;\n    float phi = acos(h2.y*2.0-1.0);\n    return vec3(\n        sin(theta)*sin(phi),\n        cos(theta)*sin(phi),\n        cos(phi));\n}\nvec3 HashS3(vec3 h3, float disp)\n{\n    return HashS3(h3.xy)*pow(h3.z,disp);\n}\n\n\n//-----------------------------------------------------------Digit Font\n//from \"Smaller Numbers\" by P_Malin\n//https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\nfloat PrintValue( const vec2 vStringCoords, const float fValue, const float fMaxDigits, const float fDecimalPlaces )\n{\n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\nvec4 PrintFloat(vec2 uv, float f, vec2 pos, vec2 size, vec3 color)\n{;\n\tfloat fDecimalPlaces = 3.0;\n\tfloat fMaxDigits = 0.0;\n\tfloat fIsDigit = PrintValue( (uv - pos) / size, f, fMaxDigits, fDecimalPlaces);\n\treturn step(1.0, fIsDigit) * vec4(color, 1.0);\n}\n\n\n//----------------------------------------------fragCoord=>index=>uv 索引变换\n//thanks to dr2! his \"index convert function\" helped me\n//\"Faberge Balls\" by dr2\n//https://www.shadertoy.com/view/MsdXWn\nint XY2I(vec2 xy, float sizeX)\n{\n    xy = floor(xy);\n    int i = int(xy.x + xy.y * sizeX);\n    return i;\n}\nvec2 I2UV(int i, vec2 size)\n{\n    float fi = float(i);\n    vec2 uv;\n    uv.x = mod(fi, size.x);\n    uv.y = floor(fi / size.x);\n    uv = (uv + 0.5) / size;\n    return uv;\n}\n\n\n//----------------------------------------------Quaternion 四元数算法\n\n//identity 元\n#define QUAT_IDENTITY vec4(0,0,0,1)\n\n//inverse rotation 逆旋转\nvec4 QuatInv(vec4 q){return vec4(q.xyz, -q.w);}\n\n//quaternion multiply 四元数乘法\nvec4 QuatMul(vec4 q, vec4 r)\n{\n    vec4 nq;\n    nq.x = q.w * r.x + q.x * r.w + q.y * r.z - q.z * r.y;\n    nq.y = q.w * r.y - q.x * r.z + q.y * r.w + q.z * r.x;\n    nq.z = q.w * r.z + q.z * r.w - q.y * r.x + q.x * r.y;\n    nq.w = q.w * r.w - q.x * r.x - q.y * r.y - q.z * r.z;\n    return nq;\n}\nvec3 QuatMul(vec4 lhs, vec3 rhs)\n{\n    float x1 = lhs.x, y1 = lhs.y, z1 = lhs.z, w1 = lhs.w;\n    float x2 = rhs.x, y2 = rhs.y, z2 = rhs.z;\n    float nx = w1 * x2 + y1 * z2 - z1 * y2;\n    float ny = w1 * y2 - x1 * z2 + z1 * x2;\n    float nz = w1 * z2 + x1 * y2 - y1 * x2;\n    float nw = x1 * x2 + y1 * y2 + z1 * z2;\n    vec3 nv;\n    nv.x = nw * x1 + nx * w1 - ny * z1 + nz * y1;\n    nv.y = nw * y1 + nx * z1 + ny * w1 - nz * x1;\n    nv.z = nw * z1 - nx * y1 + ny * x1 + nz * w1;\n    return nv;\n}\nvec3 RotateRight(vec4 q)\n{\n    vec3 nv;\n    nv.x = 1.0 - 2.0 * (q.y * q.y + q.z * q.z);\n    nv.y = 2.0 * (q.x * q.y + q.z * q.w);\n    nv.z = 2.0 * (q.x * q.z - q.y * q.w);\n    return nv;\n}\nvec3 RotateUp(vec4 q)\n{\n    vec3 nv;\n    nv.x = 2.0 * (q.x * q.y - q.z * q.w);\n    nv.y = 1.0 - 2.0 * (q.x * q.x + q.z * q.z);\n    nv.z = 2.0 * (q.y * q.z + q.x * q.w);\n    return nv;\n}\nvec3 RotateFWD(vec4 q)\n{\n    vec3 nv;\n    nv.x = 2.0 * (q.x * q.z + q.y * q.w);\n    nv.y = 2.0 * (q.y * q.z - q.x * q.w);\n    nv.z = 1.0 - 2.0 * (q.x * q.x + q.y * q.y);\n    return nv;\n}\n\n//from angle and axis 轴角四元数\nvec4 QuatAA(float angle, vec3 axisNorm)\n{\n    float s = sin(angle * 0.5);\n    vec4 nq;\n    nq.x = s * axisNorm.x;\n    nq.y = s * axisNorm.y;\n    nq.z = s * axisNorm.z;\n    nq.w = cos(angle * 0.5);\n    return nq;\n}\n\n//from euler angles 欧拉角四元数\nvec4 QuatEA(vec3 eulers)\n{\n    vec3 eh = eulers * 0.5;\n    float c1 = cos(eh.x), c2 = cos(eh.y), c3 = cos(eh.z);\n    float s1 = sin(eh.x), s2 = sin(eh.y), s3 = sin(eh.z);\n    vec4 nq;\n    nq.x = s1 * c2 * c3 + c1 * s2 * s3;\n    nq.y = c1 * s2 * c3 + s1 * c2 * s3;\n    nq.z = c1 * c2 * s3 - s1 * s2 * c3;\n    nq.w = c1 * c2 * c3 - s1 * s2 * s3;\n    return nq;\n}\n\nvec4 QuatFT(vec3 from, vec3 to)\n{\n    float angle = acos(clamp(dot(from, to), -1.0, 1.0));\n    vec3 axis = normalize(cross(from, to));\n    return QuatAA(angle, axis);\n}\n\n\n\n//---------------------------------------------------Camera 摄像机\nstruct Camera\n{\n    vec3 pos; //position 相机位置\n    vec4 rot; //rotation 相机朝向\n    float near; //near clip plane 相机近裁面\n    float far; //far clip plane 相机远裁面\n    float fov; //field of view 视野角度\n    float aspect; //screen w/h 屏幕宽高比\n};\n\n//fish eye factor 鱼眼\nfloat FishEye(vec2 xy, float t, float f)\n{\n    return 1.0 - dot(xy, xy) * t * t * f;\n}\n\n//coord transform: camera to world 相机到世界\nvec3 ScreenToCamera(vec2 uv, float ld, Camera cam)\n{\n    vec3 pos;\n    pos.z = mix(cam.near, cam.far, ld);\n    pos.xy = (uv - 0.5) * 2.0;\n    pos.x *= cam.aspect;\n    float t = tan(radians(cam.fov * 0.5));\n    //pos.xy /= FishEye(pos.xy, t, FISH_EYE_FACTOR);\n    pos.xy *= pos.z * t;\n    return pos;\n}\nvoid ScreenRay(vec2 uv, Camera cam, out vec3 ro, out vec3 rd)\n{\n    vec3 far = ScreenToCamera(uv, 1.0, cam);\n    vec3 near = cam.near / cam.far * far;\n    ro = QuatMul(cam.rot, near) + cam.pos;\n    rd = QuatMul(cam.rot, far);\n}\n/*\nvec3 ScreenToWorld(vec2 uv, float ld, Camera cam)\n{\n    return QuatMul(cam.rot, ScreenToCamera(uv, ld, cam)) + cam.pos;\n}\n//coord transform: world to camera 世界到相机\nvec3 CameraToScreen(vec3 pos, Camera cam)\n{\n    float t = tan(radians(cam.fov * 0.5));\n    pos.xy /= pos.z * t;\n    pos.xy *= FishEye(pos.xy, t, FISH_EYE_FACTOR);\n    pos.x /= cam.aspect;\n    pos.xy = pos.xy / 2.0 + 0.5;\n    pos.z = smoothstep(cam.near, cam.far, pos.z);\n    return pos;\n}\nvec3 WorldToScreen(vec3 pos, Camera cam)\n{\n    return CameraToScreen(QuatMul(QuatInv(cam.rot), pos - cam.pos), cam);\n}*/\n\n\n//---------------------------------------------------Geometry 几何\n\nvoid UniverseWards(vec3 pos, inout vec4 rot)\n{\n    float r = UNIVERSE_RADIUS;\n    float val = smoothstep(r, r * 1.5, length(pos));\n    vec3 face = RotateFWD(rot);\n    float d = dot(face, normalize(pos));\n    float a = (d + 1.0) * val * PIH;\n    vec3 axis = normalize(cross(pos, face));\n    if (length(axis) > 0.0)\n    {\n        rot = QuatMul(QuatAA(a, axis), rot);\n    }\n}\n\nfloat Segment2(vec2 uv, vec2 sp, vec2 sq, float thinkness)\n{\n    vec2 pp = uv - sp;\n    vec2 pq = sq - sp;\n    float pql = length(pq);\n    float proj = dot(pp, pq / pql);\n    float dist = sqrt(max(0.0, dot(pp, pp) - proj * proj));\n    return smoothstep(thinkness, 0.0, dist)\n         * smoothstep(-thinkness, 0.0, proj)\n         * smoothstep(-thinkness, 0.0, pql - proj);\n}\nfloat Segment(vec2 uv, vec2 sp, vec2 sq, float thinkness)\n{\n    vec2 pp = uv - sp;\n    vec2 pq = sq - sp;\n    float lp = dot(pp, pq) / dot(pq, pq);\n    vec2 dn = pp - lp * pq;\n    return step(dot(dn, dn), thinkness * thinkness)\n         * step(0.0, lp)\n         * step(lp, 1.0);\n}\n\nfloat Ellipse(vec2 uv, float rot, vec2 wh, float thinkness, bool fill)\n{\n    float c = cos(rot), s = sin(rot);\n    uv = mat2(c,s,-s,c) * uv;\n    float lhs = uv.x / wh.x, rhs = uv.y / wh.y;\n    float val = lhs * lhs + rhs * rhs - 1.0;\n    return smoothstep(thinkness*10.0, 0.0, fill ? val : abs(val));\n}\n\n\n//---------------------------------------------------Gravitation 万有引力计算\n\n//get volume 获取体积\nfloat GetStarVolume(float mass)\n{\n    return mass / STAR_DENSITY;\n}\n//get radius 获取半径\nfloat GetStarRadius(float mass)\n{\n    return pow(GetStarVolume(mass), 1.0/3.0);\n}\n\n//calculate gravitational acceleration 计算万有引力加速度\nvec3 CalculateAcceleration(vec3 dp, float mass)\n{\n    float d = length(dp);\n    if (d == 0.0) return vec3(0);\n\tfloat g = CONST_G * mass;\n    float d3 = d * d * d;\n    float r3 = GetStarVolume(mass);\n\tg /= d3>=r3 ? d3 : r3;\n\treturn g * dp;\n}\n\nfloat TimeSlow(float accel)\n{\n    return TIME_SLOW_FACTOR / (accel + TIME_SLOW_FACTOR);\n}\n\n//calculate velocity 计算速度\nvec3 CalculateVelocity(vec3 v, vec3 g, float dt)\n{\n\tvec3 dv = g * dt;\n\tvec3 nv = v + dv;\n\treturn nv;\n}\n\n//calculate position 计算位置\nvec3 CalculatePosition(vec3 p, vec3 v, float dt)\n{\n\tvec3 dp = v * dt;\n\tvec3 np = p + dp;\n\treturn np;\n}\n\n\n//---------------------------------------------------Gravitation Display 万有引力（像素射线积分）\n\n//integration function of gravitational acceleration on ray 射线加速度总和积分函数\nfloat Integrate(float x1, float x2, float dd)\n{\n    return x2 / sqrt(dd + x2*x2) - x1 / sqrt(dd + x1*x1);\n}\nfloat Integrate(float x, float dd)\n{\n    return x / sqrt(dd + x*x) + 1.0;\n}\n\n//calculate sum acceleration on ray 计算射线上的加速度总和\nvec3 IntegrateAcceleration(vec3 ro, vec3 rd, float mass)\n{\n    float proj = dot(ro, rd);\n    vec3 dp = ro - proj * rd;\n    \n    //d = length(dp)  distance between star and ray 恒星到射线的距离\n    //intergrate = G*M/d * x/sqrt(d*d+x*x)  star outer acceleration integration 外部射线垂直方向积分\n    //limit(x/sqrt(d*d+x*x)) = +-1 function limit 积分函数极限\n\n    float d = length(dp);\n    if (d == 0.0) return vec3(0);\n    float g = CONST_G * mass / d * Integrate(proj, d*d);\n    return g / d * dp;\n}\n\n\n//---------------------------------------------------Render 渲染\nvec4 AlphaBlend(vec4 src, vec4 dst)\n{\n    return vec4(mix(dst.rgb, src.rgb, src.a), 1.0);\n}\nvec4 AlphaBlendAdd(vec4 src, vec4 dst)\n{\n    return vec4(clamp(src.rgb * src.a + dst.rgb, 0.0, 1.0), 1.0);\n}\nvec4 AlphaBlendMul(vec4 src, vec4 dst)\n{\n    return vec4(src.rgb * src.a * dst.rgb, 1.0);\n}\n\nfloat GetRenderIntensity(float intensity)\n{\n    intensity = smoothstep(0., RENDER_INTENSITY_MAX, intensity);\n    intensity = pow(intensity, RENDER_INTENSITY_POW);\n    return intensity;\n}\nvec4 GetRenderColorRed(float value)\n{\n    vec4 col;\n    col.r = smoothstep(0.0, 0.667, value);\n    col.g = smoothstep(0.333, 1.0, value);\n    col.b = smoothstep(0.667, 1.0, value);\n    col.a = 1.0;\n    return col;\n}\nvec4 GetRenderColorBlue(float value)\n{\n    vec4 col;\n    col.r = smoothstep(0.667, 1.0, value);\n    col.g = smoothstep(0.333, 1.0, value);\n    col.b = smoothstep(0.0, 0.667, value);\n    col.a = 1.0;\n    return col;\n}\n\nvec4 DrawGyroscope(vec2 ouv, vec2 uv, Camera cam, vec2 pos, float radius, float thinkness)\n{\n    vec4 res;\n    \n    vec4 rot = QuatInv(cam.rot);\n    vec3 pr = RotateRight(rot);\n    vec3 pg = RotateUp(rot);\n    vec3 pb = RotateFWD(rot);\n    \n    float t = tan(radians(cam.fov * 0.5));\n    float d = 4.0;\n    vec4 rr, gg, bb;\n    rr.xy = pr.xy * radius * d / (d + t * pr.z);\n    gg.xy = pg.xy * radius * d / (d + t * pg.z);\n    bb.xy = pb.xy * radius * d / (d + t * pb.z);\n    rr.zw = -pr.xy * radius * d / (d - t * pr.z);\n    gg.zw = -pg.xy * radius * d / (d - t * pg.z);\n    bb.zw = -pb.xy * radius * d / (d - t * pb.z);\n    \n    res.r += Segment2(uv, pos, pos + rr.xy, thinkness);\n    res.g += Segment2(uv, pos, pos + gg.xy, thinkness);\n    res.b += Segment2(uv, pos, pos + bb.xy, thinkness);\n    res.r += Segment2(uv, pos, pos + rr.zw, thinkness) * 0.5;\n    res.g += Segment2(uv, pos, pos + gg.zw, thinkness) * 0.5;\n    res.b += Segment2(uv, pos, pos + bb.zw, thinkness) * 0.5;\n    \n    res = clamp(res, 0.0, 1.0);\n    res.a = max(res.r, max(res.g, res.b));\n    return res;\n}\n\nvec4 DrawShipBack(vec2 uv, vec2 wh, float thinkness)\n{\n    vec4 col;\n    col.b = Ellipse(uv, 0.0, wh, thinkness, false);\n    col.g = col.b;\n    col.a = clamp(col.b + Ellipse(uv, 0.0, wh, thinkness, true) * 0.8, 0.0, 1.0);\n    return col;\n}\n\nvec4 DrawSpeedButton(vec2 uv, float thinkness)\n{\n    vec4 col;\n    col.a = Segment(uv, vec2(-0.01,0), vec2(-0.05,0), thinkness);\n    col.a += Segment(uv, vec2(0.01,0), vec2(0.05,0), thinkness);\n    col.a += Segment(uv, vec2(0.03,0.02), vec2(0.03,-0.02), thinkness);\n    col.a = clamp(col.a, 0.0, 1.0);\n    col.rgb = vec3(col.a);\n    return col;\n}\nvec4 DrawRotateButton(vec2 uv, float thinkness)\n{\n    vec4 col;\n    col.a =  Segment(uv, vec2(0.01,-0.02), vec2(0.01,0),     thinkness);\n    col.a += Segment(uv, vec2(0.05,0),     vec2(0.01,0),     thinkness);\n    col.a += Segment(uv, vec2(0.05,0),     vec2(0.04,0.01),  thinkness);\n    col.a += Segment(uv, vec2(-0.01,-0.02),vec2(-0.01,0),    thinkness);\n    col.a += Segment(uv, vec2(-0.05,0),    vec2(-0.01,0),    thinkness);\n    col.a += Segment(uv, vec2(-0.05,0),    vec2(-0.04,0.01), thinkness);\n    col.a = clamp(col.a, 0.0, 1.0);\n    col.rgb = vec3(col.a);\n    return col;\n}\n\nstruct ShipIBData\n{\n    float accel;\n    float speed;\n    vec4 rotation;\n};\n\n//euler angles, acceleration, speed 仪表盘：欧拉角，加速率，速率\nvoid ShipInstrumentBoard(vec2 uv, Camera cam, ShipIBData data, inout vec4 dstColor)\n{\n    if (uv.x < 0.2 || uv.x > 0.8 || uv.y > 0.2) return;\n    \n    vec2 ouv = uv;\n    uv = (uv - vec2(0.5, 0)) * vec2(cam.aspect, 1.0);\n    \n    vec4 back = DrawShipBack(uv, vec2(0.4, 0.1), 0.01);\n    \n    vec4 text = vec4(0);\n    text += PrintFloat(uv, data.accel, vec2(-0.3, 0.01), vec2(0.015, 0.025), vec3(1,0,1));\n    text += PrintFloat(uv, data.speed, vec2(0.27, 0.01), vec2(0.015, 0.025), vec3(1,1,0));\n    \n    vec4 speedBtn = DrawSpeedButton(uv - vec2(0.14, 0.04), 0.002);\n    vec4 rotBtn = DrawRotateButton(uv - vec2(-0.14, 0.04), 0.002);\n    \n    vec4 gyro = DrawGyroscope(ouv, uv, cam, vec2(0.0, 0.1), 0.08, 0.01);\n    \n    dstColor = AlphaBlend(gyro, AlphaBlend(text + speedBtn + rotBtn + back, dstColor));\n}\n\nint HoldButton(vec4 mouse, vec2 screen, vec2 pos)\n{\n    float aspect = screen.x / screen.y;\n    vec2 uv = mouse.xy / screen;\n    uv -= vec2(0.5, 0);\n    uv.x *= aspect;\n    uv -= pos;\n    if (mouse.z > 0.0 && uv.y >= -0.02 && uv.y <= 0.02)\n    {\n        if (uv.x >= 0.01 && uv.x <= 0.05) return 0;\n        if (uv.x >= -0.05 && uv.x <= -0.01) return 1;\n    }\n    return -1;\n}\nint HoldSpeedButton(vec4 mouse, vec2 screen)\n{\n    return HoldButton(mouse, screen, vec2(0.14, 0.04));\n}\nint HoldRotateButton(vec4 mouse, vec2 screen)\n{\n    return HoldButton(mouse, screen, vec2(-0.14, 0.04));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//stars' position and mass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    int index = XY2I(fragCoord, iResolution.x);\n    \n    fragColor = texture(iChannel0, uv);\n    \n    if (length(fragColor) == 0.0)\n    {\n        vec3 sphere = HashS3(Hash23(uv),1.0) * UNIVERSE_RADIUS;\n        fragColor = vec4(sphere, DEFAULT_MASS);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//-------------------------------------------------------------Keyboard\n//from \"Key Quest\" by TekF\nbool readKey(in int keyCode)\n{\n\tbool toggle = false;\n    vec2 uv = vec2((float(keyCode)+.5)/256., toggle?.75:.25);\n\tfloat keyVal = textureLod(iChannel3,uv,0.).x;\n    return keyVal>.5;\n}\n#define keyQ 81\n#define keyW 87\n#define keyE 69\n#define keyA 65\n#define keyS 83\n#define keyD 68\n#define keyR 82\n#define keyF 70\n#define keyLeft  37\n#define keyUp    38\n#define keyRight 39\n#define keyDown  40\n\n//-------------------------------------------------------------Camera\n\nvec4 GetStarPositionMass(int i)\n{\n    return texture(iChannel0, I2UV(i, iResolution.xy));\n}\nvec3 GetLastMouse()\n{\n    return texture(iChannel1, I2UV(0, iResolution.xy)).xyz;\n}\nvec4 GetCameraPositionSpeed()\n{\n    return texture(iChannel1, I2UV(1, iResolution.xy));\n}\nvec4 GetCameraRotation()\n{\n    return texture(iChannel1, I2UV(2, iResolution.xy));\n}\n\nvec3 CalculateSumAcceleration(vec3 pos)\n{\n    vec3 g = vec3(0);\n    for (int i = 0; i < STAR_COUNT; i++)\n    {\n        vec4 pm = GetStarPositionMass(i);\n        g += CalculateAcceleration(pm.xyz - pos, pm.w);\n    }\n    return g;\n}\n\nvoid UpdatePosition(inout vec4 pos)\n{\n    if (iFrame == 0)\n    {\n        pos = vec4(-0.25 * UNIVERSE_RADIUS * FWD, INIT_FLY_SPEED);\n    }\n    else\n    {\n        vec4 rot = GetCameraRotation();\n        if (rot.w == 0.0)\n        {\n            rot = QUAT_IDENTITY;\n        }\n        \n        //--fly\n        float dt = DELTA_TIME * TIME_SCALE;\n        float ds = dt * FLY_ACCELERATION;\n        int btn = HoldSpeedButton(iMouse, iResolution.xy);\n        if (readKey(keyF) || btn == 0) pos.w *= 1.0 + ds;\n        if (readKey(keyR) || btn == 1) pos.w *= 1.0 - ds;\n        pos.w = min(pos.w, MAX_FLY_SPEED);\n        \n        vec3 g = CalculateSumAcceleration(pos.xyz);\n        vec3 v = CalculateVelocity(RotateFWD(rot) * pos.w, g, dt * TimeSlow(length(g)));\n        pos.xyz = CalculatePosition(pos.xyz, v, dt * TimeSlow(length(g)));\n        pos.w = length(v);\n    }\n}\n\n\nvoid UpdateRotation(inout vec4 rot)\n{\n    if (rot.w == 0.0)\n    {\n        rot = QUAT_IDENTITY;\n    }\n    else\n    {\n        //--rotate\n        float dt = DELTA_TIME * TIME_SCALE;\n        float dr = dt * ROTATE_SPEED;\n        vec3 eu = vec3(0);\n        //key\n        int btn = HoldRotateButton(iMouse, iResolution.xy);\n        if (readKey(keyW) || readKey(keyUp))    eu.x -= 1.0;\n        if (readKey(keyS) || readKey(keyDown))  eu.x += 1.0;\n        if (readKey(keyA) || readKey(keyLeft))  eu.y -= 1.0;\n        if (readKey(keyD) || readKey(keyRight)) eu.y += 1.0;\n        if (readKey(keyE) || btn == 0) eu.z -= 1.0;\n        if (readKey(keyQ) || btn == 1) eu.z += 1.0;\n        eu *= dr;\n        //mouse\n        vec3 lm = GetLastMouse();\n        vec2 dn = iMouse.xy - iMouse.zw;\n        vec2 dp = iMouse.xy - lm.xy;\n        vec2 dm = iMouse.z > lm.z ? dn : dp;\n        dm = vec2(dm.x, -dm.y) / iResolution.y;\n        eu.xy += dm.yx * (dr * 100.0);\n        \n        rot = QuatMul(rot, QuatEA(eu));\n        \n        vec4 pos = GetCameraPositionSpeed();\n        vec3 g = QuatMul(QuatInv(rot), CalculateSumAcceleration(pos.xyz));\n        if (length(g) > 0.0)\n        {\n            vec3 nv = normalize(CalculateVelocity(FWD * pos.w, g, dt * TimeSlow(length(g))));\n            rot = QuatMul(rot, QuatFT(FWD, nv));\n        }\n        \n        UniverseWards(pos.xyz, rot);\n        \n        rot = normalize(rot);\n    }\n}\n\n//camera target position, distance, rotation buffer 相机目标位置，距离，旋转缓存\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    int index = XY2I(fragCoord, iResolution.x);\n    \n    if (index >= 4)\n    {\n        discard;\n    }\n    else if (index == 0)\n    {\n        fragColor = iMouse;\n        \n        vec4 pos = GetCameraPositionSpeed();\n        vec3 g = CalculateSumAcceleration(pos.xyz);\n        fragColor.w = length(g);\n    }\n    else\n    {\n        fragColor = texture(iChannel1, uv);\n        \n        if (index == 1)\n        {\n            UpdatePosition(fragColor);\n        }\n        else\n        {\n            UpdateRotation(fragColor);\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}