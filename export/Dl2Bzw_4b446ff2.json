{"ver":"0.1","info":{"id":"Dl2Bzw","date":"1693888463","viewed":33,"name":"Plume expansion test - lb","username":"LuxStice","description":"thanks to TheInnkeeper in StackExchange i was able to make this rocket engine plume intersection shader! theres still a lot to optimize.\nThis shader is based on the LogBisect shader at https://www.shadertoy.com/view/4sSXzD","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Log-Bisection Tracing by nimitz (twitter: @stormoid)\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//contact: nmz at stormoid.com\n\n/*\n\tI was trying to come up with a technique to plot 2d functions in 3d and tried different\n\troot finding methods, the bisection method was interesting, but it had quite a few problems.\n\tIt would detect any root, not the closest one, and is very dependent on the initial interval.\n\n\tThen I found that using log+1 of the current value allowed for good convergence without running\n\tinto the risk of crossing twice on thin slices. But this method alone can still take a bit too\n\tlong to converge (or miss roots if set coarser).\n\n\tBy combining the two techniques, that is, nearing the function by dynamic stepping with log(d+1)\n\tand checking for sign change at every step to perform bisection, the performance improves a lot.\n\t\n\tI start by marching dynamically with log(d+1). Then, either the log method finds a root or the \n\tsign changes without finding a root. If that is the case a bisection search is performed in the \n\talready\trefined interval, this converges quickly thanks\tto the small interval and is also guaranteed\n\tto converge if the function is continuous, allowing for\taccurate root finding on functions with \n\tinfinite or null derivatives (where newton's method fails horribly), singularities, degeneracy etc.\n\n\tAnd most of all, the rendering speeds are more than comparable with raymarching,\n\tI haven't done extensive testing but it seemed even faster for some standard SDFs.\n\n\tPlease let me know if you have questions or find potential issues with the technique.\n*/\n\n\n//1 = spiky thing || 2 = heavy deformation || 3 = texture plotting\n#define RENDER 1\n\n//Max iterations and max distance\n#define ITR 100\n#define FAR 150.\n#define PRECISION 0.000008\n#define INFINITY 1000000.\n\n#define ANIMATE true\n//Plume values, set ANIMATE to false for these to take effect\nfloat LINEAR = -1.;\nfloat QUADRATIC = -0.05;\nfloat RADIUS = 2.;\nfloat LENGTH = 20.;\n#define ABSOLUTE true\n\n//distance from center\n#define HEIGHT 20.\n\n//determines how fast the root finder moves in, needs to be lowered when dealing with thin \"slices\"\n//the potential problem is the intersector crossing the function twice in one step.\n#define BASE_STRIDE .75\n\n//Used by the Hybrid marcher (if the distance from the root is high enough we use d instead of log(d)\n#define FAR_STRIDE 0.3\n\n//To cross faster, a minimum step size\n#define MIN_STEP .1\n\n//Optimizations From CeeJayDK \n//(let me know if it actually improves performance for you, I'm not getting any difference here)\n#define OPTIMIZE\n\nconst float logvl = 1.+MIN_STEP;\n#define time iTime\n#define pi 3.1415926535\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\n\nfloat Plume(in float y){\n    return RADIUS + (y * LINEAR) + (y*y*QUADRATIC);\n}\n\n//returns signed distance between current position and the function's root at said position\nfloat map(in vec3 p)\n{\n    float radius = Plume(p.y);\n    if(ABSOLUTE)\n        radius = abs(radius);\n    vec2 xz = normalize(p.xz) * radius;\n\n    vec3 PlumePosition = vec3(xz.x, p.y, xz.y);\n    float sgn = 1.;\n    float d = 0.;\n\n    if(p.y > 0. || p.y < -(LENGTH)){\n        sgn = 1.;\n    }\n    else{\n        sgn = (length(p.xz) < radius)? -1. : 1.;\n    }\n    d = length(PlumePosition - p) * sgn;\n\n    return d;\n}        \n\nfloat bisect( in vec3 ro, in vec3 rd, in float near, in float far)\n{\n    float mid = 0.;\n    float sgn = sign(map(rd*near+ro));\n    for (int i = 0; i < 6; i++)\n    { \n        mid = (near + far)*.5;\n        float d = map(rd*mid+ro);\n        if (abs(d) < PRECISION)break;\n        d*sgn < 0. ? far = mid : near = mid;\n    }\n    return (near+far) * .5;\n}\n\n//returns near and far t values, x for 1st intersection and y for 2nd intersection\nbool LogBisect(in vec3 rayOrigin,in vec3 rayDirection, out vec2 near, out vec2 far){\n    float t = 0.;\n    float oldt = t;\n    vec3 rayPos = rayDirection*t+rayOrigin;\n    float d = map(rayPos);\n    bool sgn = d > 0.;\n    bool oldsgn = sgn;\n\n    int itr = ITR;\n    float maxDist = FAR;\n    bool found = false;\n\n    int intersectionCount = 0;\n    if(!sgn)//is inside the shape\n    {\n        near.x = t;\n        intersectionCount +=1;\n    }\n\n    for (int i=0;i<=itr;i++)\n    {\n        rayPos = rayDirection*t+rayOrigin;\n        d = map(rayPos);\n        sgn = d > 0.;\n        bool crossed = sgn != oldsgn;\n\n        if(t > maxDist){\n            break;\n        }\n        else if(i == itr){\n            t = INFINITY;\n        }\n\n        float edgeT = t;\n        if(crossed){\n            edgeT = bisect(rayOrigin, rayDirection, oldt, t);\n        }\n        if(abs(d) < PRECISION || crossed){\n            if(intersectionCount == 0)\n                near.x = edgeT;\n            else if(intersectionCount == 1)\n                far.x = edgeT;\n            else if(intersectionCount == 2)\n                near.y = edgeT;\n            else if(intersectionCount == 3){\n                far.y = edgeT;\n                break;\n            }\n            intersectionCount += 1;\n            found = true;\n        }\n\n    oldsgn = sgn;\n    oldt = t;\n        #if 1\n        if (d > 1.)t += d*FAR_STRIDE;\n        else t += log(abs(d)+logvl)*BASE_STRIDE;\n        #else\n        t += log(abs(d)+logvl)*BASE_STRIDE;\n        #endif\n    }\n\n    return found;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.01;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 bp = p+0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n    um = (um ==vec2(-.5))?um=vec2(-0.005,-0.005):um;\n\tum *= 3.14159265*2.;\n    \n    vec3 ligt = normalize(vec3(sin(time*0.5),3.,cos(time*0.5)));\n    \n    //camera\n    vec3 ro = vec3(0.,-5.,HEIGHT);\n    vec3 rd = normalize(vec3(p*3.,-2.4));\n   \t\n    //rotation\n    mat2 ry = mm2(um.y+sin(time)*0.3);\n    mat2 rx = mm2(um.x+time*0.29);\n    ro.yz *= ry;\n    ro.xz *= rx;\n    rd.yz *= ry;\n    rd.xz *= rx;\n\n #ifdef ANIMATE\n    LINEAR = sin(time) * .75;\n    QUADRATIC = clamp((sin(time + 58.) +sin(time)) * .02, -.4, .4);\n    RADIUS = max(.5,sin(time) + .25);\n #endif\n\n    vec2 dstToBoxNear;\n    vec2 dstToBoxFar;\n    bool intersect = LogBisect(ro,rd, dstToBoxNear, dstToBoxFar);\n    vec3 col = texture(iChannel0,rd).rgb*0.9;\n    vec3 pos = ro+rd*dstToBoxNear.x;\n    \n    if(intersect){\n    vec4 col2;\n    col2.ra += (dstToBoxFar.x - max(0.0, dstToBoxNear.x))*.5;\n    col2.ga += (dstToBoxFar.y - max(0.0, dstToBoxNear.y))*.5;\n    col2.rgb = mix(col,col2.rgb,col2.a);\n    col = mix(col,col2.rgb,.3);\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}