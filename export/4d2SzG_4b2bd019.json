{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define LIGHTING_DIRECT /* uncomment to enable direct lighting calculation with shadows */\n#define LIGHTING_BOUNCE_ONCE /* uncomment to enable the first reflection */\n//#define LIGHTING_BOUNCE_TWICE /* uncomment to enable a second reflection */\n\nstruct Slide {\n\tvec2 pos;\n    vec2 normal;\n};\n\n#define SLIDE_COUNT 6\n\nmat2 rotation(float theta) {\n\treturn mat2(cos(theta), -sin(theta), sin(theta), cos(theta));  \n}\n\nfloat boxDistance(vec2 pos, vec2 center, vec2 normal, vec2 scale) {\n    mat2 rot = mat2(normal.x, -normal.y, normal.y, normal.x);\n\tvec2 delta = rot * (pos - center);\n    delta = clamp(delta, -scale, scale);\n    vec2 clampPos = center + delta * rot;\n    return length(clampPos - pos);\n}\n\nvec2 map(vec2 pos, Slide slides[SLIDE_COUNT]) {\n    float dist = 100.0;\n    float hit = -1.0;\n    for (int i = 0; i < SLIDE_COUNT; ++i) {\n     \tfloat thisDist = boxDistance(pos, slides[i].pos, slides[i].normal, vec2(0.2, 0.01));\n        if (thisDist < dist) {\n         \thit = float(i);\n            dist = thisDist;\n        }\n    }\n    return vec2(dist, hit);\n}\n\nvec3 trace(vec2 origin, vec2 dir, float far, Slide slides[SLIDE_COUNT]) {\n \tfloat t = 0.0;\n    float hit = -1.0;\n    for (int i = 0; i < 16; ++i) {\n     \tvec2 pos = origin + dir * t;\n        vec2 d = map(pos, slides);\n        t += d.x * 1.0;\n        hit = d.y;\n        if (t >= far) {\n         \treturn vec3(t, 1.0, -1.0);   \n        }\n        if (d.x < 0.0) {\n         \treturn vec3(t, 0.0, hit);   \n        }\n    }\n\treturn vec3(t, 0.0, hit);\n}\n\nfloat reflection(vec2 a, vec2 b, float power, float fresnel, Slide slides[SLIDE_COUNT]) {\n    float r = 0.0;\n\n#ifdef LIGHTING_DIRECT\n\tvec2 delta = b - a;\n    float len = length(delta);\n\tvec3 visa = trace(a, delta/len, len, slides);\n\tr += visa.y / (1.0 + len * len * power);\n#endif\n\n#ifdef LIGHTING_BOUNCE_ONCE\n    for (int i = 0; i < SLIDE_COUNT; ++i) {\n        vec2 deltai = a - slides[i].pos;\n        vec2 refi = slides[i].pos - reflect(deltai, slides[i].normal);\n\n        vec2 rayi = refi - b;\n        float leni = length(rayi);\n        rayi /= leni;\n        vec3 pathi = trace(b, rayi, leni, slides);\n        if (pathi.z != float(i)) {\n            continue;\n        }\n\t\tvec2 hiti = b + rayi * pathi.x;\n        \n        vec2 delta = hiti - a;\n        float len = length(delta);\n        delta /= len;\n        vec3 path = trace(a, delta, len*0.99, slides);\n        if (path.y == 0.0) {\n            continue;   \n        }\n\n        float pathLength = leni;\n        float prod = abs(dot(-normalize(delta), slides[i].normal));\n        r += (1.0 - prod * fresnel) / (1.0 + pathLength * pathLength * power);\n    }\n#endif // LIGHTING_BOUNCE_ONCE\n    \n#ifdef LIGHTING_BOUNCE_TWICE\n\tfor (int i = 0; i < SLIDE_COUNT; ++i) {\n        vec2 deltai = a - slides[i].pos;\n        vec2 refi = slides[i].pos - reflect(deltai, slides[i].normal);\n        for (int j = 0; j < SLIDE_COUNT; ++j) {\n            if (j==i) {\n                continue;\n            }\n            \n        \tvec2 deltaj = refi - slides[j].pos;\n        \tvec2 refj = slides[j].pos - reflect(deltaj, slides[j].normal);\n            \n            vec2 rayj = refj - b;\n            float lenj = length(rayj);\n            rayj /= lenj;\n            vec3 pathj = trace(b, rayj, lenj, slides);\n            if (pathj.z != float(j)) {\n                continue;\n            }\n            vec2 hitj = b + rayj * pathj.x;\n            \n            vec2 rayi = refi - hitj;\n            float leni = length(rayi);\n            rayi /= leni;\n            hitj += rayi * 0.01;\n            vec3 pathi = trace(hitj, rayi, leni, slides);\n            if (pathi.z != float(i)) {\n                continue;\n            }\n            vec2 hiti = rayi + hitj * pathi.x;\n            \n            vec2 delta = hiti - a;\n            float len = length(delta);\n            delta /= len;\n            vec3 path = trace(a, delta, len*0.99, slides);\n            if (path.y == 0.0) {\n                continue;\n            }\n\n        \tfloat pathLength = lenj;\n        \tfloat prod = abs(dot(-normalize(delta), slides[i].normal));\n            prod *= abs(dot(-normalize(rayi), slides[j].normal));\n        \tr += (1.0 - prod * fresnel) / (1.0 + pathLength * pathLength * power);\n        }\n    }\n#endif // LIGHTING_BOUNCE_TWICE\n \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    Slide slides[SLIDE_COUNT];\n    \n    slides[0].pos = vec2(0.0, 0.0);\n    slides[0].normal = vec2(0.0, 1.0) * rotation(-iTime*0.5);\n\n    slides[1].pos = vec2(-0.2, -0.8);\n    slides[1].normal = vec2(0.0, 1.0) * rotation(-3.14/2.5);\n    \n    slides[2].pos = vec2(0.3, -0.8);\n    slides[2].normal = vec2(0.0, 1.0) * rotation(3.14/2.5);\n    \n    slides[3].pos = vec2(1.2, 0.5);\n    slides[3].normal = vec2(0.0, 1.0) * rotation(3.14/8.0);\n    \n    slides[4].pos = vec2(-1.0, -0.2);\n    slides[4].normal = vec2(1.0, 0.0);\n\n    slides[5].pos = vec2(-1.0, 0.2);\n    slides[5].normal = vec2(1.0, 0.0);\n    \n    vec2 lightPos = vec2(cos(iTime), sin(iTime)) * 0.6;\n    \n    if (iMouse.z >= 1.0) {\n    \tlightPos = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    \tlightPos.x *= iResolution.x / iResolution.y;\n    }\n    \n    float lighting = reflection(lightPos, uv, 1.0, 0.0, slides);\n    lighting = 0.3 + lighting * 0.7;\n    \n    vec2 delta = lightPos - uv;\n    float dist = 1.0 / (1.0 + dot(delta, delta) * 100.0);\n    float orb = clamp(pow(0.1 + dist,8.0),0.0,1.0);\n\n    vec3 colour = vec3(1.0);\n    colour.y *= 0.5 + 0.5 * cos(1.57 - iTime / 10.0);\n    colour.z *= 0.5 + 0.5 * cos(1.57 + iTime / 20.0);\n    \n\tvec3 tex = texture(iChannel0, uv * 2.0).xyz;\n        \n    vec3 ground = (tex * lighting + orb) * colour;\n    \n    float solid = abs(map(uv,slides).x) < 0.01 ? 1.0 : 0.0;\n    \n    vec3 final = mix(ground, vec3(lighting,lighting,lighting), solid);\n    \n    fragColor = vec4(final, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2SzG","date":"1413285987","viewed":1223,"name":"2D Reflections","username":"dila","description":"Simulates up to two light bounces from mirrors. Inspired by \"2D Shadow Casting\" by Tharich. Click and drag to move the light.","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarch","light","shadows","reflections","mirrors"],"hasliked":0,"parentid":"","parentname":""}}