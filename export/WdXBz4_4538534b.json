{"ver":"0.1","info":{"id":"WdXBz4","date":"1598109234","viewed":234,"name":"Underworld","username":"SimonL","description":"Testing SDF and raymarching","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["procedural","3d","raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    color = pow(color,vec4(2.2));\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct ray\n{\n\tvec3 o;\n\tvec3 d;\n};\n    \nstruct inter\n{\n\tfloat t;\n\tvec2 uv;\n\tvec3 p;\n\tvec3 n;\n\tint mID;\n    vec3 c;\n};\n    \nstruct mat\n{\n\tvec3 albedo;\n    float specular;\n    float ss_multiplier;\n};\n    \n\n    ","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define T0(u) texture(iChannel0,u)\n#define T1(u) texture(iChannel1,u)\n#define T2(u) texture(iChannel2,u)\n#define T3(u) texture(iChannel3,u)\n\n#define I(a,b) max(a,b)\n#define U(a,b) min(a,b)\n#define D(a,b) max(a,-b)\n\n#define MAX_DISTANCE 500.\n#define NORMAL_EPSILON 0.01\n#define TRACE_EPSILON 0.01\n\n#define PI_1_2 1.57079632679\n#define PI\t   3.14159265359\n#define PI_2   6.28318530718\n#define PIPI   9.86960440109\n\n#define RAIN 0\n\nfloat rand(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat rand(float v) { return fract(sin(v) * 1231534.9);}\n\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel0, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel0, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel0, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel0, (p+ivec2(1,1))&255, 0 ).x;\n\n    \n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat Us( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat Ds( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat Is( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\ninter C ( inter a, inter b) {\n\tif(a.t < b.t)\n        return a;\n    return b;\n}\n\nvec3 rotateX(vec3 p, float angle)\n{\n\tmat3 r = mat3(1, 0, 0,\n\t\t\t\t\t0, cos(angle), -sin(angle),\n\t\t\t\t\t0, sin(angle), cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), 0, sin(angle),\n\t\t\t\t0, 1, 0,\n\t\t\t\t-sin(angle),0 , cos(angle));\n\treturn r * p;\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n\tmat3 r = mat3(cos(angle), -sin(angle), 0,\n\t\t\t\tsin(angle), cos(angle), 0,\n\t\t\t\t0, 0, 1);\n\treturn r * p;\n}\n    \nfloat sdfSphere(vec3 p, vec3 c, float r)\n{\n\treturn length(c-p) - r;\n}\n\nfloat sdfSphereDisp(vec3 p, vec3 c, float r)\n{\n    float d1 = sdfSphere(p,c,r);\n    float d2 =  sin(1.4 * p.z - iTime * 3.) * 0.03 ;\n    return d1+d2;\n}\n\ninter sdfRain(vec3 p){\n    inter i;\n    \n\tvec3 rep = vec3(2.0, 0.0, 2.0);\n\tvec2 id = floor(p /rep).xz;\n\tp = mod(p,rep)-rep*0.5;\n\tp.y += -8. + mod((iTime * 1.4 + rand(id) *  8.) * 10. ,80.);\n\tp.x += rand(id.y)-0.5;\n\tp.z += rand(id.x)-0.5;\n\ti.t = sdfSphere(-p,vec3(0.), mix(0.1, 0.02, rand(id)));\n\ti.mID = 4;\n\t\n\treturn i;\n}\n\ninter sdfWorld(vec3 p)\n{\n\t//floor deformations\n    vec3 ptmp = p;\n    p.y -= p.z *p.z * 0.01;\n    \n\tp.y -= noised(p.xz * 8.).x * 0.1;\n    \n    p = rotateZ(p, PI * p.x * 0.02);\n\n    \n\tp.y += sin(p.x/2.0)*sin(p.z/2.0)*0.4;\n\tp.y += 2.*sin(p.x)*sin(p.z)*0.2;\n\tp.y += sin(p.x*2.0)*sin(p.z*2.0)*0.1;\n\n    \n\tinter i;\n    i.t = p.y + 3.0;\n\ti.mID = 1;\n    \n    \n    i.uv = p.xz;\n    \n    //lumps\n    vec3 ptmp2 = p;\n\tvec3 rep = vec3(5.0, 0.0, 10.0);\n\tvec2 id = floor(p /rep).xz;\n    p.x += sin(p.z + iTime * 3. * rand(id)) /2.;\n    p.z += cos(p.x + iTime * 5. * rand(id)) /2.;\n\tp = mod(p,rep)-rep*0.5;\n\tp.y += mix(2.4, 2.8,rand(id));\n\tp.x += rand(id.y)-0.5;\n\tp.z += rand(id.x)-0.5;\n\ti.t = Us(i.t, sdfSphere(-p,vec3(0.), mix(0.3, 0.2, rand(id))), 1.6);\n\t\n    //lumps 2\n    p = ptmp2;\n\tvec3 rep2 = vec3(3.0, 0.0, 3.0);\n\tvec2 id2 = floor(p /rep2).xz;\n\tp = mod(p,rep2)-rep2*0.5;\n\tp.y += mix(2.6, 2.8,rand(id2));\n\tp.x += (rand(id2.y)-0.5) / 2.;\n\tp.z += (rand(id2.x)-0.5) / 2.;\n\ti.t = Us(i.t, sdfSphere(-p,vec3(0.), mix(0.08, 0.06, rand(id2))), 1.);\n\t\n    // lake\n    float tmp = Ds(i.t,sdfSphereDisp(ptmp,vec3(0.,-502.,0.),500.),0.2);\n    i.t = U(i.t,tmp);\n    if(tmp == i.t)\n        i.mID = 2;\n    i.c = p;\n\t\n\treturn i;\n}\n\n// https://iquilezles.org/articles/fog\nfloat fog(ray r, inter i)\n{\n    float c = 0.00003;\n    float b = 4.2;\n    float fogAmount = pow(c * exp(-r.o.y*b) * (1.0-exp( -i.t*r.d.y*b ))/r.d.y,0.2);\n    return fogAmount;\n}\n\n\n\ninter scene(vec3 p){\n    inter world = sdfWorld(p);\n    #if RAIN\n    inter rain = sdfRain(p);\n    #endif\n    \n    inter i;\n    i.mID = 0;\n    i.t = 90000.;\n    \n   \ti = C(world,i);\n    #if RAIN\n    i = C(rain,i);\n    #endif\n    return i;\n}\n\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + NORMAL_EPSILON, p.y, p.z)).t - scene(vec3(p.x - NORMAL_EPSILON, p.y, p.z)).t,\n        scene(vec3(p.x, p.y + NORMAL_EPSILON, p.z)).t - scene(vec3(p.x, p.y - NORMAL_EPSILON, p.z)).t,\n        scene(vec3(p.x, p.y, p.z + NORMAL_EPSILON)).t - scene(vec3(p.x, p.y, p.z - NORMAL_EPSILON)).t\n    ));\n}\n\ninter trace(ray r)\n{\t\t\n\tinter i;\n\tfloat t = 0.0;\n\tvec3 p;\n\twhile(t <= MAX_DISTANCE)\n\t{\n\t\tp = r.o + r.d * t;\n\t\ti = scene(p);\t\t\n\t\tif(i.t <= TRACE_EPSILON) break;\t\n\t\tt += max(i.t*0.6, t * 0.0001);\n\t}\t\n\ti.t = t;\n\ti.p = p;\n\ti.n = normal(p);\n\treturn i;\n}\n\n// From XT95's shader : https://www.shadertoy.com/view/MsdGz2\nfloat subsurface(vec3 p, vec3 v, vec3 n){\n    vec3 d = refract(v, n, 1.0/1.5);\n    vec3 o = p;\n    float a = 0.0;\n    \n    const float max_scatter = 2.5;\n    for(float i = 0.1; i < max_scatter; i += 0.2)\n    {\n        o += i*d;\n        float t = scene(o).t;\n        a += t;\n    }\n    float thickness = max(0.0, -a);\n    const float scatter_strength = 16.0;\n\treturn scatter_strength*pow(max_scatter*0.5, 3.0)/thickness;\n}\n\n\nmat material(inter i){\n\tmat m;\n    switch(i.mID){\n    \tcase(0) :\n            m.albedo = vec3(0.,0.,1.);\n        \tm.specular = 10.;\n        \tm.ss_multiplier = 0.8;\n        break;\n        case(1) :\n            float t = clamp((i.c.y + 0.1) * 1.,0.,1.);\n        \tm.albedo = vec3(0.5, 0.2, 0.2) + t * T1(i.uv).x;\n            m.specular = 100.;\n        \tm.ss_multiplier = 1.;\n        break;\n        case(2) :\n            m.albedo = vec3(0.6,0.45,0.45) - T1(i.uv * 0.04 + 0.2 + vec2(cos(iTime + sin(i.uv + iTime)) / 110.) ).x * 0.4;\n        \tm.specular = 400.;\n        \tm.ss_multiplier = 1.2;\n        break;\n        case(4) :\n            m.albedo = vec3(0.2,0.1125,0.1125);\n        \tm.specular = 10.;\n        \tm.ss_multiplier = 1.;\n        break;\n    }\n    return m;\n}\n\n\nvec3 shade(inter i, ray r){\n    vec3 final = vec3(0.);\n    \n    if(i.t < MAX_DISTANCE){\n        \n        vec3 lp = vec3(0.,5.,0.);\n        vec3 ld = normalize(i.p - vec3(lp.x,lp.y,lp.z));\n        \n        mat m = material(i);\n        final = vec3(0.);\n\n        float diff = max(0.0, dot(-ld, i.n));\n        float spec = pow( max(dot(reflect(-ld,i.n),r.d),0.) ,m.specular);\n        \n        float ss = max(0.0, subsurface(i.p, r.d, i.n));\n        ss *= m.ss_multiplier;\n\t\tfloat lamb = mix(diff, 3.5*smoothstep(0.0, 2.0, pow(ss, 1.0)), 0.7);\n        lamb = pow(lamb,1.4);\n        \n        final = m.albedo * lamb + spec * 1.;\n       \treturn mix(final,vec3(0.32,0.2,0.2) * 1.5 ,fog(r,i) * 1.0);\n    }\n    return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 mouse = vec2(0.0);\n    if (iMouse.z > 0.0) {\n        mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.yy;\n    }\n\n    float camRotY = PI * 0.1 * sin(iTime * 0.25) - mouse.x;\n\tfloat camRotX = -PI * (0.1 + 0.03 *(sin(iTime * 0.25))) + mouse.y;\n\t\n\tray r;\n\tr.o = vec3(cos(iTime * 0.5),cos(iTime) * 0.5 - 0.3,-11.0 + sin(iTime * 0.35) * 3.);\n    r.o = rotateX(r.o, camRotX);\n\tr.o = rotateY(r.o, camRotY);\n    r.o.y -= mix(0.,scene(r.o).t - 1.5, 0.01);\n\t\n    \n\tfloat fx = tan(radians(60.0 + sin(iTime) * 6.) / 2.0) / iResolution.x;\n\tvec2 d = fx * (fragCoord.xy * 2.0 - iResolution.xy);\n\tr.d = normalize(vec3(d, 1.0));\n\tr.d = rotateX(r.d, camRotX);\n\tr.d = rotateY(r.d, camRotY);\n    \n    inter i = trace(r);\n    vec3 color = shade(i,r);\n    fragColor = vec4(color,i.p.z * 0.1);\n\n}","name":"Buffer A","description":"","type":"buffer"}]}