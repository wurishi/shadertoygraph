{"ver":"0.1","info":{"id":"wsycWD","date":"1603440425","viewed":320,"name":"Shader Submit","username":"eltounyomar","description":"axaxxa","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SKEW_GRID\n#define FAR 20.\n#define QUANTIZE_HEIGHTS\n#define FLAT_GRID\n#define PTH_INDPNT_GRD\n#define GRAYSCALE\n#define REVERSE_PALETTE\nfloat objID;\n\nmat2 rot2(in float a){float c=cos(a), s=sin(a); return mat2(c,-s,s,c);}\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.989, 78.233, 57.263)))*43758.5453);\n}\n\nvec2 path(in float z){ \n    \n    //return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), 0);\n}\n\nvec3 getTex(in vec2 p){\n    \n    // Stretching things out so that the image fills up the window.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, p/8.).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\nvec2 unskewXY(vec2 p, vec2 s){\n\n\treturn inverse(mat2(1, -s.y, -s.x, 1))*p;\n\n}\n\nvec2 gp;\n\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\tvec2 w=vec2(sdf,abs(pz)-h-sf/2.);\n    return min(max(w.x,w.y),0.) + length(max(w + sf, 0.)) - sf;\n}\n\nvec2 gP;\n\n\nvec4 blocks(vec3 q){\n\n    \n    // Scale... Kind of redundant here, but sometimes there's a distinction\n    // between scale and dimension.\n\tconst vec2 scale = vec2(1./5.);\n\n    // Block dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = scale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    \n    #ifdef SKEW_GRID\n    // Skewing half way along X, and Y.\n    const vec2 sk = vec2(-.5, .5);\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    // Height scale.\n    #ifdef FLAT_GRID\n    const float hs = 0.; // Zero height pylons for the flat grid.\n    #else\n    const float hs = .4;\n    #endif\n    \n    float height = 0.; // Pylon height.\n\n\n    // Local cell coordinate copy.\n    gP = vec2(0);\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0]/2.;\n        \n        // Skewed local coordinates.\n        p = skewXY(q.xz, sk);\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        \n        // Unskewing the rectangular cell ID.\n\t    idi = unskewXY(idi*s, sk); \n        \n \n        // The larger grid cell face.\n        //\n        vec2 idi1 = idi; // Block's central position, and ID.\n        float h1 = hm(idi1);\n        #ifdef QUANTIZE_HEIGHTS\n        h1 = floor(h1*20.999)/20.; // Discreet height units.\n        #endif\n        h1 *= hs; // Scale the height.\n        \n        // Larger face and height extrusion.\n        float face1 = sBoxS(p, 2./5.*dim - .02*scale.x, .015);\n        //float face1 = length(p) - 2./5.*dim.x;\n        float face1Ext = opExtrusion(face1, q.y + h1, h1, .006); \n    \n        \n        // The second, smaller face.\n        //\n        //vec2 offs = vec2(3./5., -1./5.)*dim;\n        vec2 offs = unskewXY(dim*.5, sk);\n        vec2 idi2 = idi + offs;  // Block's central position, and ID.\n        float h2 = hm(idi2);\n        #ifdef QUANTIZE_HEIGHTS\n        h2 = floor(h2*20.999)/20.; // Discreet height units.\n        #endif\n        h2 *= hs; // Scale the height.\n     \n        // Smaller face and height extrusion.\n        float face2 = sBoxS(p - offs, 1./5.*dim - .02*scale.x, .015);\n        //float face2 = length(p - offs) - 1./5.*dim.x;\n        float face2Ext = opExtrusion(face2, q.y + h2, h2, .006);\n         \n        // Pointed face tips, for an obelisque look, but I wasn't feeling it. :)\n        //face1Ext += face1*.25;\n        //face2Ext += face2*.25;\n        \n        vec4 di = face1Ext<face2Ext? vec4(face1Ext, idi1, h1) : vec4(face2Ext, idi2, h2);\n   \n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w;\n            \n            // Setting the local coordinates: This is hacky, but I needed a \n            // copy for the rendering portion, so put this in at the last minute.\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and pylong height.\n    return vec4(d, id, height);\n}\n\nfloat getTwist(float z){ return z*.08; }\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// Speaking of lazy, here's some global glow variables. :D\n// Glow: XYZ is for color (unused), and W is for individual \n// blocks.\nvec4 gGlow = vec4(0);\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Wrap the scene around the path. This mutates the geometry,\n    // but it's easier to implement. By the way, it's possible to\n    // snap the geometry around the path, and I've done that in\n    // other examples.\n    p.xy -= path(p.z);\n    \n    // Twist the geometry along Z. It's cheap and visually effective.\n    // Demosceners having been doing this for as long as I can remember.\n    p.xy *= rot2(getTwist(p.z));\n\n    \n    // Turning one plane into two. It's an old trick.\n    p.y = abs(p.y) - 1.25;\n  \n    // There are gaps between the pylons, so a floor needs to go in\n    // to stop light from getting though.\n    float fl = -p.y + .01;\n    \n    #ifdef PTH_INDPNT_GRD\n    // Keep the blocks independent of the camera movement, but still \n    // twisting with warped space.\n    p.xy += path(p.z);\n    #endif\n    \n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    // Only alowing certain blocks to glow. We're including some \n    // animation in there as well.\n    float rnd = hash21(gID.xy);\n    //\n    // Standard blinking lights animation.\n    gGlow.w = smoothstep(.992, .997, sin(rnd*6.2831 + iTime/4.)*.5 + .5);\n    //gGlow.w = rnd>.05? 0. : 1.; // Static version.\n \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded blocks.\n    return min(fl, d4.x);\n \n}\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n     \n    // Zero out the glow.\n    gGlow = vec4(0);\n    t = hash31(ro.zxy + rd.yzx)*.25;\n    \n    for(int i = 0; i<128; i++){\n    \n        d = map(ro + rd*t); // Distance function.\n        \n        // Adding in the glow. There'd be better and worse ways to do it.\n        float ad = abs(d + (hash31(ro + rd) - .5)*.05);\n        const float dst = .25;\n        if(ad<dst){\n            gGlow.xyz += gGlow.w*(dst - ad)*(dst - ad)/(1. + t);\n        }\n        if(abs(d)<.001*(1. + t*.05) || t>FAR) break; \n        \n        t += i<32? d*.4 : d*.7; \n    }\n\n    return min(t, FAR);\n}\n\nvec3 getNormal(in vec3 p){\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.25)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*2.0); // Camera position, doubling as the ray origin.\n    ro.xy += path(ro.z); \n    vec2 roTwist = vec2(0, 0);\n    roTwist *= rot2(-getTwist(ro.z));\n    ro.xy += roTwist;\n    \n\tvec3 lk = vec3(0, 0, ro.z + .45); // \"Look At\" position.\n    lk.xy += path(lk.z); \n    vec2 lkTwist = vec2(0, -.1); // Only twist horizontal and vertcal.\n    lkTwist *= rot2(-getTwist(lk.z));\n    lk.xy += lkTwist;\n    \n\tvec3 lp = vec3(0, 0, ro.z + 5.); // Light.\n    lp.xy += path(lp.z);\n    vec2 lpTwist = vec2(0, -.3); // Only twist horizontal and vertcal.\n    lpTwist *= rot2(-getTwist(lp.z));\n    lp.xy += lpTwist;\n    \n\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    float a = getTwist(ro.z);\n    // Swiveling the camera about the XY-plane.\n    a += (path(ro.z).x - path(lk.z).x)/(ro.z - lk.z)/4.;\n\tvec3 fw = normalize(lk - ro);\n\t//vec3 up = normalize(vec3(-fw.x, 0, -fw.z));\n\tvec3 up = vec3(sin(a), cos(a), 0);\n\t//vec3 up = vec3(0, 1, 0);\n    vec3 cu = normalize(cross(up, fw));\n\tvec3 cv = cross(fw, cu);   \n    \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*cu + uv.y*cv + fw/FOV);\t\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID, object ID and local coordinates.\n    vec3 svGID = gID;\n    float svObjID = objID;\n    vec2 svP = gP; \n    \n    vec3 svGlow = gGlow.xyz;\n   \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n          \n        // Texel color. \n\t    vec3 texCol;   \n        \n        // Transforming the texture coordinates according to the camera path\n        // and Z warping.\n        vec3 txP = sp;\n        txP.xy -= path(txP.z);\n        txP.xy *= rot2(getTwist(txP.z));\n        #ifdef PTH_INDPNT_GRD\n        txP.xy += path(txP.z);\n        #endif\n\n        // The extruded grid.\n        if(svObjID<.8){\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(svGID.xy);\n            \n            // Ramping the shade up a bit.\n            texCol = smoothstep(-.3, 1., tx)*vec3(1, .4, 2.6);\n            \n            \n            // Very fake, but very cheap, bump mapping. Render some equispaced horizontal\n            // dark lines, and some light adjacent ones. As you can see, it gives the\n            // impression of horizontally segmented grooves on the pylons.\n            const float lvls = 9.;\n            \n            // Vertical lines... A bit too much for this example, but useful for a fake\n            // voxel setup.\n            //float vLn = min(abs(txP.x - svGID.x), abs(txP.z - svGID.y));\n            \n            // Horizontal lines (planes, technically) around the pylons.\n            float yDist = (1.25 + abs(txP.y) + svGID.z*2.);\n            float hLn = abs(mod(yDist  + .8/lvls, 1./lvls) - .5/lvls);\n            float hLn2 = abs(mod(yDist + .75/lvls - .018, 1./lvls) - .7/lvls);\n            \n            // Omitting the top and bottom planes... I was in a hurry, and it seems to\n            // work, but there'd be better ways to do this. \n            if(yDist - 2.5<.45/lvls) hLn = 1e5;\n            if(yDist - 2.5<.45/lvls) hLn2 = 1e5;\n            \n            // Rendering the dark and light lines using 2D layering techniques.\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .006, hLn2 - .0055));\n       \t\ttexCol = mix(texCol, texCol/2.5, 1. - smoothstep(0., .006, hLn - .0055));\n       \t\t \n            \n            // Render a dot on the face center of each extruded block for whatever reason...\n            // They were there as markers to begin with, so I got used to them. :)\n            float fDot = length(txP.xz - svGID.xy) - .0096;\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .002, fDot - .0065));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .002, fDot));\n  \n\n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // there are very slight gaps, so it's still necessary.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .003);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.45, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 3./(1. + lDist*lDist*.5);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff *= diff*1.55; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 4.);\n        col = texCol*(diff + ao*.25 + vec3(1, .4, .2)*fre*.25 + vec3(1, .4, .2)*spec*4.);\n        \n        col *= ao*sh*atten;\n\t\n\t}\n\n    svGlow.xyz *= mix(vec3(4, 1, 2), vec3(4, 2, 1), min(svGlow.xyz*3.5, 1.25));\n    col *= .25 + svGlow.xyz*8.;\n   \n    vec3 fog =  mix(vec3(4, 1, 2), vec3(4, 2, 1), rd.y*.5 + .5);\n    fog = mix(fog, fog.zyx, smoothstep(0., .55, uv.y - .35));\n    col = mix(col, fog/1.5, smoothstep(0., .99, t*t/FAR/FAR));\n    \n    \n    #ifdef GRAYSCALE\n    // Grayscale... or almost grayscale. :)\n    col = mix(col, vec3(1)*dot(col, vec3(.320, .650, .174)), .75);\n    #endif \n \n    \n    #ifdef REVERSE_PALETTE\n    col = col.zyx; // A more calming blue, for those who don't like fiery things.\n    #endif\n\n    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}","name":"Image","description":"","type":"image"}]}