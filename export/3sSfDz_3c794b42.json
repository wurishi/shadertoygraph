{"ver":"0.1","info":{"id":"3sSfDz","date":"1598447959","viewed":287,"name":"Make Fun With Sky Simulation","username":"shicz86","description":"ps:default mode is fish-eye view,mouse click on screen and hold can change to perspective view.\n//https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n//https://www.shadertoy.com/view/3dBSDW","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["skysimulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky\n// https://www.shadertoy.com/view/3dBSDW\n\n#define PI 3.14159265359\n#define USE_HENYEY 1\n#define SWITCH_COLOR 1\n\n#define u_res iResolution\n#define u_time iTime\n\nvec3 sunDir = vec3(0.,1.,0.);\nfloat sunPower = 20.;\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst int numSamples = 16;\n#if SWITCH_COLOR\nconst int numSamplesLIght = 8;\nconst float hR = 7994.; // rayleigh\nconst float hM = 1200.; // mie\nconst vec3 betaR = vec3(5.5e-6,13.0e-6,22.4e-6); // rayleigh\nconst vec3 betaM = vec3(21e-6); // mie\n#else\nconst int numSamplesLIght = 8;\nconst float hR = 7994.; // rayleigh\nconst float hM = 1200.; // mie\nconst vec3 betaR = vec3(1.5e-6,40.0e-6,7.4e-6); // rayleigh\nconst vec3 betaM = vec3(21e-6); // mie\n#endif\n\nstruct ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\nstruct sphere\n{\n\tvec3 center;\n    float radius;\n}; \n\nconst sphere atmosphere = sphere(vec3(0.,0.,0.),atmosphereRadius);\nbool raySphereIntersect(const in ray r,const in sphere s,inout float t0,inout float t1)\n{\n\tvec3 oc = r.origin-s.center;\n    float a = dot(r.direction,r.direction);\n    float b = dot(oc,r.direction);\n    float c = dot(oc,oc)-s.radius*s.radius;\n    float discriminant = b*b-(a*c);\n    if(discriminant>0.0)\n    {\n        float tmp = sqrt(discriminant);\n        t0 = (-b-tmp)/a;\n        t1 = (-b+tmp)/a;\n        return true;\n    }\n    return false;\n}\n\nmat3 rotate_around_x(const in float degrees)\n{\n    float angle = radians(degrees);\n    float _sin = sin(angle);\n    float _cos = cos(angle);\n    return mat3(1.,0.,0.,\n                0.,_cos,-_sin,\n                0.,_sin,_cos);\n}\n\nray getPrimaryRay(in vec2 camLocalPoint,inout vec3 camOrigin,inout vec3 camLookAt)\n{\n\tvec3 fwd = normalize(camLookAt-camOrigin);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = cross(up,fwd);\n    up = cross(fwd,right);\n    ray r = ray(camOrigin,normalize(fwd+camLocalPoint.x*right+camLocalPoint.y*up));\n    return r;\n}\n\n//----------------phase function----------------\nfloat rayleighPhaseFunc(float mu)\n{\n\treturn 3.*(1.+mu*mu)/(16.*PI);\n}\n\nconst float g = 0.76;\nfloat henyeyGreensteinPhaseFunc(float mu)\n{\n\treturn (1.-g*g)/((4.*PI)*pow(1.+g*g-2.*g*mu,1.5));\n}\n\nconst float k = 1.55*g-0.55*(g*g*g);\nfloat schlickPhaseFunc(float mu)\n{\n\treturn (1.-k*k)/(4.*PI*(1.+k*mu)*(1.+k*mu));\n}\n//----------------phase function----------------\n\n// calculate optical depth\nbool getSunLight(const in ray r,inout float opticalDepthR,inout float opticalDepthM)\n{\n\tfloat t0,t1;\n    raySphereIntersect(r,atmosphere,t0,t1);\n    float marchPos = 0.;\n    float marchStep = t1/float(numSamplesLIght);\n    for(int i = 0;i<numSamplesLIght;i++)\n    {\n        // middle point between two neighbour sample points\n    \tvec3 s =r.origin+r.direction*(marchPos+0.5*marchStep);\n        float height = length(s)-earthRadius;\n        if(height<0.)\n            return false;\n        opticalDepthR += exp(-height/hR)*marchStep;\n        opticalDepthM += exp(-height/hM)*marchStep;\n        marchPos += marchStep;\n    }\n    return true;\n}\n\nvec3 getIncidentLight(const in ray r)\n{\n\tfloat t0,t1;\n    if(!raySphereIntersect(r,atmosphere,t0,t1))\n    {\n    \treturn vec3(0.);\n    }\n\tfloat marchStep = t1/float(numSamples);\n    float mu = dot(r.direction,sunDir);\n    float phaseR = rayleighPhaseFunc(mu);\n    float phaseM = \n#if USE_HENYEY\n    henyeyGreensteinPhaseFunc(mu);\n#else\n    schlickPhaseFunc(mu);\n#endif\n    float opticalDepthR = 0.;\n    float opticalDepthM = 0.;\n    \n    vec3 sumR = vec3(0.);\n    vec3 sumM = vec3(0.);\n    float marchPos = 0.;\n    for(int i=0;i<numSamples;i++)\n    {\n    \tvec3 s = r.origin+r.direction*(marchPos+0.5*marchStep);\n        float height = length(s)-earthRadius;\n        // cumulative optical depth\n        float hr = exp(-height/hR)*marchStep;\n        float hm = exp(-height/hM)*marchStep;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        \n        ray lightRay = ray(s,sunDir);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        bool bOverGround = getSunLight(lightRay,opticalDepthLightR,opticalDepthLightM);\n    \tif(bOverGround)\n        {\n        \tvec3 t = betaR*(opticalDepthR+opticalDepthLightR)+\n                betaM*1.1*(opticalDepthM+opticalDepthLightM);\n            vec3 attenuation = exp(-t);\n            sumR += hr*attenuation;\n            sumM += hm*attenuation;\n        }\n        marchPos += marchStep;\n    }\n    return sunPower*(sumR*phaseR*betaR+sumM*phaseM*betaM);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord/iResolution.xy-1.)*vec2(iResolution.x/iResolution.y,1.);\n    float viewScale = 1.;\n    vec2 p = uv*viewScale;\n\n    vec3 color = vec3(0.);\n    \n     // sun position\n    float rotSpeedFactor = 3.;\n    mat3 sunRot = rotate_around_x(-abs(sin(u_time/rotSpeedFactor))*90.);\n    sunDir *= sunRot;\n    \n    if(iMouse.z<0.1)\n    {\n        // points on unit circile map to hemisphere\n        float z2 = p.x*p.x+p.y*p.y;\n        float phi = atan(p.y,p.x);\n        float theta = acos(1.-z2);\n        vec3 dir = vec3(sin(theta)*cos(phi),\n                        cos(theta),\n                        sin(theta)*sin(phi));\n        ray r = ray(vec3(0.,earthRadius+1.,0.),dir);\n        color = getIncidentLight(r);\n    }else\n    {\n    \tvec3 from = vec3(0.,earthRadius+1.,0.);\n        vec3 lookat = vec3(0.,earthRadius+1.5,-1.);\n        ray r = getPrimaryRay(p,from,lookat);\n        if(dot(r.direction,vec3(0.,1.,0.))>0.)\n           color = getIncidentLight(r);\n        else\n           color = vec3(0.33,0.33,0.33);\n        \n    }\n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}