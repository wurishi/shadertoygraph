{"ver":"0.1","info":{"id":"NlKSWz","date":"1640513604","viewed":281,"name":"waterfalls","username":"kastorp","description":"this compressible water is perfect for a relaxing bath!\n\nuncomment DETAIL for more particles\n","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","water","particles"],"hasliked":0,"parentid":"NlXGRB","parentname":"Flocking Bubbles"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Waterfalls by Kastorp\n//--------------------------------\n//at full resolution:  define DETAIL in common tab\n//-----------------------------------------------------\n\nGETTERS\n\nvec3 Voronoi(in vec2 pos){\n    ivec4 nb = getClosest(ivec2(pos/ZOOM));\n  \n    bool ghost;\n    vec4 pi0 = getParticle(nb[0],ghost);\n    vec4 pi1 = getParticle(nb[1],ghost);\n    vec4 pi2 = getParticle(nb[2],ghost);\n\n    float d0 = distance(pos/ZOOM,pi0.xy)*ZOOM;\n    float d1 = distance(pos/ZOOM,pi1.xy)*ZOOM;  \n    float d2 = distance(pos/ZOOM,pi2.xy)*ZOOM; \n    return vec3(d0,d1,d2);\n}\n\nvoid mainImage( out vec4 O, in vec2 p ){\n\n    //float cid = fract(float(i2xy(idn).x)  /10.);\n    float vol=RADIUS*ZOOM*2.;\n    \n    vec3 d = Voronoi(p);\n    float  df=smin(smin(d.x,d.y,vol),d.z,vol);\n    \n    float foam= clamp(0.,1.,1.-.2*smoothstep(vol,vol*.8 ,d.y)-.3*smoothstep(vol,vol*.8 ,d.z));\n    vec3  col = vec3(.9*foam,.3+.7*foam,1.-.1*foam);\n\n    \n    col *= smoothstep(vol,vol*.8,df);   \n    col=mix(col,vec3(.4,.1,.1), smoothstep(vol*.4,vol*.3,(map(p/ZOOM,size,iTime).x)));\n\tO = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//configurable settings:\n#define DETAIL\n\n#ifndef DETAIL \n    //working at low resolution\n    #define NP 1600. //number of particles,  must be <=  (iResolution.x)^2\n    #define NGH 500 // number of ghosts scanned each frame\n    #define dt 2.5 // time interval;  \n    #define RADIUS 5. //average dist\n    #define WP vec3(1.,2.,0.) //water parameters depending on position: viscosity, repulsion, near force\n    #define WV vec3(.2,.05,1.5) //water parameters depending on velocity: coupling power, far coupling, near coupling\n#else \n    // more particles\n    #define NP 10000. \n    #define NGH 1000 \n    #define dt 1.5 \n    #define RADIUS 2.5 \n    #define WP vec3(1.,1.9,.1)\n    #define WV vec3(.2,.05,1.5)\n#endif\n\n//-----------------------\n//#define N8  //interact with 8 particles (default is with 4 particle)\n//#define REBOUNDS //water as inelastic balls\n#define MAXSIZE 400.\n#define ZERO  min(iFrame,0)\n#define N ivec2(int(sqrt(NP)),int(sqrt(NP)))\n#define size min(vec2(MAXSIZE*iResolution.x/iResolution.y,MAXSIZE),vec2(iResolution.xy))\n#define RRADIUS RADIUS *min(iResolution.y/MAXSIZE,1.)\n#define ZOOM (iResolution.y/size.y)\n#define mouse (iMouse/ZOOM)\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define GETTERS ivec4 getClosest(ivec2 p){ return floatBitsToInt(texel(iChannel2, p));} \\\nivec4 getNeighbor(int id){ return floatBitsToInt(texel(iChannel1, i2xy(id)));} \\\nivec4[2] getNeighbor2(int id){ uvec4 v= floatBitsToUint(texel(iChannel1, i2xy(id))); return ivec4[2](ivec4(v&65535u), ivec4(v>>16)); }\\\nvec4 getParticle(int id,out bool ghost){ vec4 p= texel(iChannel0, i2xy(id));ghost=min(p.x,p.y)<0.;return vec4(abs(p.xy),p.zw); }\n\nconst int tot_n = N.x*N.y;\n\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n//https://iquilezles.org/articles/distgradfunctions2d\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\n\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d-r,q/d);\n}\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n#define mmin(a,b) (a.x<b.x?a:b)\nvec3 map(vec2 p,vec2 sz,float t){\n     vec3 df = sdgCircle(p.xy -vec2(sz.x*.3,0),sz.y*.15);\n     df=mmin(df,-sdgBox(p-sz*.5*vec2(1,1.2),sz*.49*vec2(1,1.2)));\n     df=mmin(df,sdgBox(p-vec2(sz.x*.8,0),vec2(sz.x*.2,sz.y*.1)));\n     df=mmin(df,sdgBox(p-vec2(sz.x*.1,sz.y*.45),vec2(sz.x*.02,sz.y*.35)));\n     df=mmin(df,sdgSegment(p,vec2(.1,.8)*sz,vec2(.6,.6+sin(t)*.1)*sz,sz.y*.01));\n     df=mmin(df,sdgSegment(p,vec2(.6,.5)*sz,vec2(.9,.8)*sz,sz.y*.01));\n     float c=sz.y/6., q = mod(p.y - t*.15*sz.y +0.5*c,c)-0.5*c;\n     df=mmin(df,sdgBox(vec2(p.x,q),vec2(sz.x*.07,sz.y*.01)));\n    return df;\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle physics\n\nGETTERS\n\nint cid;\n\n\nvec4 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec4(0);\n    bool ghost;\n   \tvec4 p1 = getParticle(pid,ghost);\n    float d = distance(p1.xy,p0.xy),\n          x=d/RADIUS;\n\n#ifdef REBOUNDS\n    vec2 n= normalize(p1.xy-p0.xy),\n         rp=  n* min(0.,d-RADIUS*2.)*.5,\n         v=  min(dot(p1.zw-p0.zw,n),.0) *n/dt*smoothstep(.5,0.4, x)*1.2;      \n    return vec4(v,rp);\n#else               \n    float fd=dot(WP, vec3((1./(1.+x)), - exp(-x), - smoothstep(1.1,.9,x)));    \n    vec2 flocking_force =(p1.zw - p0.zw)/(1.+WV.y*x+WV.z*x*x*x),   \n         interaction = normalize(p1.xy-p0.xy)* min(.01,fd);\n    return vec4(flocking_force*WV.x+ interaction,vec2(0));\n#endif\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos); \n        //this pixel value\n        U = texel(iChannel0, pos);\n        U.xy=abs(U.xy);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10 || U==vec4(0))\n        {\n            U.xy = size*vec2(p)/vec2(N);\n\t\t\tU.zw = vec2(0);\n      \t\treturn;\n        }\n        \n#ifdef N8       \n   \t\tivec4[2] cp = getNeighbor2(id);\n   \t  \n        vec4 F = Fv(U, cp[0].x) +\n            \t Fv(U, cp[0].y) +\n            \t Fv(U, cp[0].z) +\n                 Fv(U, cp[0].w) +\n                 Fv(U, cp[1].x) +\n            \t Fv(U, cp[1].y) +\n            \t Fv(U, cp[1].z) +\n                 Fv(U, cp[1].w);\n#else\n   \t\tivec4 cp = getNeighbor(id);\n   \t  \n        vec4 F = (Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w));\n#endif\n       // F=vec4(0);\n        \n        bool gh;\n        vec4 p0 = getParticle(id,gh);\n\n        F.y-=.02*dt; //gravity \n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(mouse.xy, U.xy);\n            if(d<size.y*.3) F.xy += 2.*normalize(mouse.xy - U.xy)/(sqrt(d)+2.);\n        } \n \n        //border conditions\n        vec3 df= map(U.xy,size,iTime);\n        if(df.x<RRADIUS*2.) { \n            F.zw= .8*(-df.x +RRADIUS*2.0)*df.yz;\n            F.xy+= (dot(U.zw,df.yz)<=0.) ? \n                   -df.yz*1.1*dot(U.zw,df.yz)/dt: \n                   vec2(0.); \n         }\n\n        //apply forces\n        U.zw += F.xy *dt;\n        U.zw*=.99;\n        \n        //apply velocity and impulse\n        U.xy += U.zw*dt +F.zw;\n\n        \n        U.xy = mod(U.xy, size);\n        \n        bool ghost=true;\n        ivec4 nb = getClosest(ivec2(U.xy));\n        for(int i = 0; i<4; i++)\n        {\n            if(nb[i]==id) {ghost=false; break;}\n        }\n        if(ghost) U.xy=-U.xy;\n        \n    }\n    else discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particcle connection\n\nGETTERS\n\n#ifndef N8\n//sorting closest 4 particles\n\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp,ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getNeighbor(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < NGH; i++)\n    {\n        //sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort  \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(id); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(nc[i]); \n    }\n    \n    ivec4 nb = getNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n         ivec4 nbb = getNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[j]); \n        }\n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = intBitsToFloat(u);\n}\n#else\n\n//sorting closest 8 particles \n\nuvec4[2] u; //ids\nvec4[2] d; //distances\nvec2 pos; //this particle position\nuint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(uint utemp)\n{\n    if(utemp == tid || utemp >=65536u) return; \n     if(  any(equal(u[0], uvec4(utemp))) ||  any(equal(u[1], uvec4(utemp)))) return;\n     \n       \n   \tvec4 part = getParticle(int(utemp),ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n     \n    vec4 d0= d[0], d1=d[1];\n    uvec4 u0= u[0],u1= u[1];\n    //sorting\n    if(d0.x > dtemp )\n    {\n     \n        d1= vec4(d0.w, d1.xyz);\n        u1= uvec4(u0.w, u1.xyz);         \n        d0 = vec4(dtemp, d0.xyz);\n        u0 = uvec4(utemp, u0.xyz);\n    }\n    else if(d0.y > dtemp && dtemp > d0.x)\n    {\n     \n        d1= vec4(d0.w, d1.xyz);\n        u1= uvec4(u0.w, u1.xyz);\n         \n        d0.yzw = vec3(dtemp, d0.yz);\n        u0.yzw = uvec3(utemp, u0.yz);\n    }\n    else if(d0.z > dtemp && dtemp > d0.y)\n    {\n     \n        d1= vec4(d0.w, d1.xyz);\n        u1= uvec4(u0.w, u1.xyz);\n        \n        d0.zw = vec2(dtemp, d0.z);\n        u0.zw = uvec2(utemp, u0.z);\n    }\n    else if(d0.w > dtemp && dtemp > d0.z)\n    {\n  \n        d1= vec4(d0.w, d1.xyz);\n        u1= uvec4(u0.w, u1.xyz);\n          \n        d0.w = dtemp;\n        u0.w = utemp;\n    }\n     \n    else if(d1.x > dtemp && dtemp > d0.w)\n    {\n        d1 = vec4(dtemp, d1.xyz);\n        u1= uvec4(utemp, u1.xyz);\n\n    }   \n    else if(d1.y > dtemp && dtemp > d1.x)\n    {\n        d1.yzw = vec3(dtemp, d1.yz);\n        u1.yzw = uvec3(utemp, u1.yz);\n    }\n    else if(d1.z > dtemp && dtemp > d1.y)\n    {\n        d1.zw = vec2(dtemp, d1.z);\n        u1.zw = uvec2(utemp, u1.z);\n    }\n    else if(d1.w > dtemp && dtemp > d1.z)\n    {\n        d1.w = dtemp;\n        u1.w = utemp;\n    }\n    d[0]=d0;u[0]=u0;\n    d[1]=d1;u[1]=u1;\n}\n\n\nvoid sortneighbor(int id)\n{\n    ivec4[2] nb = getNeighbor2(id);\n    for(int n=min(iFrame,0);n<2;n++)\n    for(int j = min(iFrame,0); j < 4; j++)\n    {\n        sort(uint(nb[n][j]));\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = uvec4[2](uvec4(65536u),uvec4(65536u));\n    \n    d = vec4[2](vec4(1e10),vec4(1e10)); \n   \n    tid = uint(id);\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = ZERO; i < NGH + ZERO; i++)\n    {\n \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(uint(id)); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(uint(nc[i])); \n    }\n    \n    ivec4[2] nb = getNeighbor2(id);\n    for(int n1= ZERO;n1<2;n1++)\n    for(int i =ZERO; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(int(nb[n1][i])); \n         ivec4[2] nbb = getNeighbor2(nb[n1][i]);\n         for(int n2=ZERO;n2<2;n2++)\n        for(int j = ZERO; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[n2][j]); \n        }\n    }\n    \n\n\n    \n   \n    U = uintBitsToFloat(u[0]+(u[1]*65536u));\n}\n\n\n#endif","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position\n\nGETTERS\n\n\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\nbool ghost;\n\n\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = distance(getParticle(utemp,ghost).xy, pos);\n    //sorting\n     if(d.w > dtemp){\n    if(d.x > dtemp)                     { d = vec4(dtemp, d.xyz);    u = ivec4(utemp, u.xyz);}\n    else if(d.y > dtemp && dtemp >= d.x) { d.yzw = vec3(dtemp, d.yz); u.yzw = ivec3(utemp, u.yz);}\n    else if(d.z > dtemp && dtemp >= d.y) { d.zw = vec2(dtemp, d.z);   u.zw = ivec2(utemp, u.z);}\n    else if(d.w > dtemp && dtemp >= d.z) { d.w = dtemp;               u.w = utemp;}\n    }\n}     \n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = getClosest(p);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid sortPart(int id)\n{\n\n#ifdef N8  \n    ivec4[2] nb = getNeighbor2(id);\n    for(int n = ZERO; n < 2; n++)\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[n][j]);\n    }\n#else\n    ivec4 nb = getNeighbor(id);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n#endif\n\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen\n    \n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    sortpos(p); //resort this position, cause particles are moving\n    \n    //jump flood sorting; minimized gere, raising to 12 or 16 has small effect and  high impact on framerate  \n    for(int i = ZERO; i < 16; i++)\n    { \n        ivec2 p2 =p+   (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n        \n        //if (! any(greaterThan(p2,ivec2(ceil(size)) )) && ! (! any(lessThan(p2,ivec2(0u) )))) \n        sortpos(p2); \n    }\n    \n    \n    // sort neighbors of closest particles\n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n    \n    // if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )  u = ivec4(0); \n    \n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}