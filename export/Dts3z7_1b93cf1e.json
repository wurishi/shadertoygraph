{"ver":"0.1","info":{"id":"Dts3z7","date":"1688139337","viewed":77,"name":"Icosahedron DOP","username":"spalmer","description":"Must.  Draw.  Icosahedron!\n\nsee also [http://shadertoy.com/view/md2cWy]Platonic DOP[/url]","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","icosahedron","polyhedra","discreteorientedpolytope"],"hasliked":0,"parentid":"dsjXDw","parentname":"Nano Survey"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// idea from http://shadertoy.com/view/Mtc3RX\n\nconst float\n    P = sqrt(1.25) + .5, //(sqrt(5.)+1.)/2., //1.6180339887498948482045868343656 phi\n    U = P + 1., //P * P, // amazingly these  //2.6180339887498948482045868343656 // are the same number!!\n    Q = inversesqrt(U*U+1.), //inversesqrt((P+1.)*(P+1.)+1.), //0.35682208977308993194196984304609\n    R = U * Q, //0.93417235896271569645111862354806\n    S = sqrt(1./3.); //0.57735026918962576450914878050196\n// phi is a cool number, P - 1. = 1. / P and other such divine co-incidences.  It's the most irrational!\n\n// these (plus their negatives) are the plane normals for the slabs of the DOP\nconst vec3 N[] = vec3[] (\n    // half of cube's vertices gives tetrahedron; as slabs, makes octahedron\n    vec3( S, S, S),\n    vec3(-S, S, S),\n    vec3( S,-S, S),\n    vec3( S, S,-S),\n    // icosahedron combines the octahedron with vec3(0, Q, R) = normalize(vec3(0,1,P+1.))\n    vec3( 0, Q, R),\n    vec3( 0,-Q, R),\n    vec3( R, 0, Q),\n    vec3(-R, 0, Q),\n    vec3( Q, R, 0),\n    vec3(-Q, R, 0)\n);\n\nconst float size = 1.4;\n\n#define IZERO min(0, iFrame)\n\n// trace slabs clipping\n// analytic ray/DOP\nvoid trace(vec3 f, vec3 d, out vec3 n, inout vec2 r)\n{\n    vec3 n1 = -d;\n    // ray intersection with intersection of all halfspaces\n    for (int i = IZERO + N.length(); i-- > 0; ) {\n        vec3 n2 = N[i];\n        float df = dot(n2, f),\n          dp = dot(n2, d), // ray/slab intersection setup\n          a = abs(dp);\n        if (a < 1e-7) continue;\n        vec2 r2 = (size * vec2(-1,1) - sign(dp) * df) / a; // entry/exit of slab\n        if (r2.x > r.x)\n            n1 = n2 * sign(df);\n        r = vec2(max(r.x, r2.x), min(r.y, r2.y)); // clip ray\n        //if (!(r.x < r.y)) break; // may as well stop when totally clipped, but will diverge execution threads\n    }\n    n = n1;\n}\n\nconst float e = 5.; // how far eye is back from origin\n\nfloat shootray(vec3 q, vec3 r, out vec3 n)\n{\n    vec2 d = vec2(0,e+size); //9e9); //\n    trace(q, r, n, d);\n    bool hit = d.x > 0. && d.x < d.y;\n    if (!hit) {\n        d.x = 2.*e;\n        q += d.x*r;\n        n = -r + .02*sin(28.*q);\n    }\n    n = normalize(n);\n    return d.x;\n}\n// needs AA\n// I hacked Fabrice's easy AA into Common for now, helps a lot!\n\n// Fabrice-style golf rotate\nmat2 rot(float c)\n{\n    return mat2(cos((c) + vec4(0,33,11,0)));\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec3 r = iResolution, n, f = vec3(0,0,1);\n    float t0 = .3 * sin(.1*iTime), t1 = .05*iTime;\n    r = vec3(p - .5 * r.xy, min(r.x,r.y));\n    r.zy *= rot(t0);  r.zx *= rot(t1);\n    f.zy *= rot(t0);  f.zx *= rot(t1);\n    r = normalize(r);\n    f = normalize(f);\n    float t = shootray(-e*f, r, n);\n    bool bg = t > e+size;\n    o = textureLod(iChannel0, reflect(r, n), bg ? 5. : 0.); // mirror reflection\n}\n\n// see also http://shadertoy.com/view/4ltBDH or http://shadertoy.com/view/7ldfzS","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// easy antialiasing based on Fabrice http://shadertoy.com/view/NdyfRz\n#if 1\nint _AA = 3;\n#define mainImage _mainImage_(out vec4 O, vec2 U); \\\nvoid mainImage(out vec4 O, vec2 U) {               \\\n    vec4 o; O = vec4(0);                           \\\n    for (int j=0; j < _AA; ++j)                    \\\n    for (int i=0; i < _AA; ++i)                    \\\n    { vec2 V = U + (vec2(i,j))/float(_AA) - .5;    \\\n       _mainImage_(o, V);                          \\\n        O += pow(o, vec4(2.2)); }                  \\\n    O = pow(O / float(_AA*_AA), vec4(1./2.2));     \\\n} \\\nvoid _mainImage_\n#endif","name":"Common","description":"","type":"common"}]}