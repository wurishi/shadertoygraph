{"ver":"0.1","info":{"id":"Nlc3RN","date":"1635768642","viewed":93,"name":"a½♪『","username":"HaleyHalcyon","description":"a","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (6.283185307)\n// i want to use hex codes like in image editing programs,\n// so here's an improved macro by FabriceNeyret2\n#define HEX(x) vec3( ( ivec3(x) >> ivec3(16,8,0) ) & 255 ) / 255.\n\nvec3 color(float x){\n    const int colorCount = 8;\n    vec3[] c = vec3[](\n        vec3(0),\n        HEX(0xe020c0),\n        HEX(0xf0e040),\n        HEX(0xc0ff80),\n        vec3(1),\n        HEX(0xa0ffe0),\n        HEX(0x7080F0),\n        HEX(0x8000a0)\n    );\n    x *= float(colorCount);\n    int lo = 1048576 + int(floor(x));\n    \n    return mix(\n        c[lo % colorCount],\n        c[(lo + 1) % colorCount],\n        fract(x)\n    );\n}\n\nfloat square(vec2 uv, float angle) {\n    // rotation.\n    // thank you FabriceNeyret for teaching me to git gud at rotating a 2D vector in glsl\n    uv *= mat2(\n        cos(angle), -sin(angle),\n        sin(angle),  cos(angle)\n    );\n    return max(abs(uv.x), abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = fract(iTime / 3.0);\n  // make the center of the canvas (0.0, 0.0) and\n  // make the long edge of the canvas range from -1.0 to +1.0\n  // we'll use the scale variable later for antialiasing bc it's the size of one pixel\n  float scale = max(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale;\n\n  // i blend each square's color in order to antialias this shader\n  // are you proud of me yet Fabrice\n  vec3 col = vec3(0., 0., 0.);\n  float opacity = 0.;\n  float colOffset = 0.125;\n  const float iters = 32.;\n  float size = 0.002;\n  float sizeMult = 1.2;\n  float angleOffset = 0.12 * (2.5 + sin(time * TAU));\n  // i know, loops in glsl code, ew right\n  for (float i = 0.; i < iters; i++) {\n      // subtract from size and multiply by scale to get\n      // a nice \"pixels from boundary\" value\n      float dist = (square(\n          uv, -time * TAU + angleOffset * i\n      ) - size) * scale;\n      if ( // fully inside square\n          dist < 0.\n      ) {\n          col += (1. - opacity) * color(time + colOffset * i);\n          opacity = 1.;\n      } else if ( // partially inside square\n          dist < 1.\n      ) {\n          float newOpacity = max(0., (1. - dist) * (1. - opacity));\n          col += newOpacity * color(time + colOffset * i);\n          opacity += newOpacity;\n      } else { // fully outside square\n          // do nothing\n      }\n      // i'm not sure if this saves time for gpu calculation\n      // but i'm doing it anyway because it pleases me:\n      if (opacity >= 1.) {break;}\n      \n      size *= sizeMult; // better than calling pow()\n  }\n  \n  // Output to screen\n  fragColor = vec4(\n    col, 1.0\n  );\n}","name":"Image","description":"","type":"image"}]}