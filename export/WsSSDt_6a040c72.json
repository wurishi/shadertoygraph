{"ver":"0.1","info":{"id":"WsSSDt","date":"1555236560","viewed":614,"name":"Scalable and dynamic terrain","username":"AlexK","description":"Based on https://www.shadertoy.com/view/3sBXWt\nmax zoom: 200000x\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain","life","dynamic","scalable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float TIMESCALE = .03;\nconst float DETALIZATION = 2.6;\nconst float BALANCE = 0.9;\n\n\n//colors\nconst vec3 white = vec3(1.,1.,1.);\nconst vec3 dark_brown = vec3(86./255., 69./255., 61./255.);\nconst vec3 brown = vec3(101./255., 79./255., 68./255.);\nconst vec3 light_green = vec3(96./255., 163./255., 24./255.);\nconst vec3 dark_green = vec3(71./255., 117./255., 18./255.);\nconst vec3 beige = vec3(215./255., 213./255., 136./255.);\nconst vec3 blue = vec3(63./255., 114./255., 206./255.);\nconst vec3 dark_blue = vec3(59./255., 100./255., 202./255.);\n\n//division lines\nconst float snow_line = 0.8;\nconst float mount_line_1 = 0.67;\nconst float mount_line_2 = 0.6;\nconst float ground_line_1 = 0.58;\nconst float ground_line_2 = 0.45;  \nconst float sand_line = 0.42;\nconst float water_line_1 = 0.4;\nconst float water_line_2 = 0.32;\n\n\nfloat[] seed = float[](.25, .5, .75, 1.) ;\n\n\nfloat rnd(float seed){\n\treturn fract((1. - cos((seed + 21.2313662551) * 37.6447205633))/2.);\n}\n\nvec2 color(vec2 uv, float col, int i, float r){\n    int x = int(uv.x * 2.)%2;\n    int y = int(uv.y * 2.)%2;\n\n    float c;\n    \n    float r1 = rnd(float(i));\n    float r2 = rnd(seed[y * 2 + x]);\n    \n    float r3 = rnd((r1 + r2) * r);\n    \n    \n    c = (col + r3 + col * (r3 - 0.5) * 0.6) * 1.2 ;\n    \n\treturn vec2(c, r3);\n}\n\nfloat l_norm(vec2 v, float p){\n\treturn pow(pow(abs(v.x), p) + pow(abs(v.y), p), 1./p);\n}\n\n\nfloat gen_map(float init, vec2 n_uv, int iters, float seed, float time, float bol){\n    float val = init;\n    float r = seed;\n    float inn = time;\n    \n    n_uv = n_uv * 0.5;\n    \n\tfor (int i=0;i<iters;i++){\n        n_uv = mod(n_uv, 1.);\n        \n        vec2 res = color(n_uv, inn, i+1, r);\n     \tfloat bal = bol / pow(float(i+1), 1.);\n        \n        inn = res[0];\n        r = res[1];\n        \n        float val_tot = (bal + cos(inn)) / pow(float(i + 1), 0.4) /2.;\n        val_tot = val_tot * max(0., 1. - pow(l_norm(vec2(.25,.25) - mod(n_uv, 0.5), 3.)*4., 0.85));\n        val += val_tot / pow(float(i+1), 1. / DETALIZATION);\n        \n        n_uv = n_uv * 2.;\n    }\n    \n    return val;\n}\n\nfloat gen_sky(vec2 uv, int iters){\n    float val = 0.;\n    \n    float time = 30. + (0.0 + iTime) * TIMESCALE * 10.;\n\tfloat val_1 = gen_map(0.5, uv+0.2 * vec2(rnd(5.1), rnd(5.2)) - 0.1, iters, 1., time, 0.);\n    float val_2 = gen_map(0.5, uv+0.2 * vec2(rnd(6.1), rnd(6.2)) - 0.1, iters, 1., time * 1.01, 0.);\n    float val_3 = gen_map(0.5, uv+0.2 * vec2(rnd(7.1), rnd(7.2)) - 0.1, iters, 1., time * 1.02, 0.);\n\n    \n    val = val + val_1 * (1.-val);\n    val = val + val_2 * (1.-val);\n\tval = val + val_3 * (1.-val);\n    val = pow(val, 15.);\n    \n\treturn val;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv -= vec2(1.1, 0.6);\n    \n    // Starting at 200000x zoom and move it to 1x over period of 30s\n    float zoom = 1. / min(1., mix(0.000005, 1., pow((1. + iTime) / 30., 5.)));\n    uv = uv / zoom;\n    \n    uv += vec2(1.1, 0.6);\n    uv.y = 1. - uv.y;\n    uv.x += -0.4;\n       \n     \n    vec2 n_uv = uv;\n    // Reduce number of iterations as zoom value became smaller (not necessary, just a demonstration of persistence)\n    int iters = min(24, int(log2(zoom)) +9);\n    \n    //compute hight of the terrain\n    float time = 40. + (0.0 + iTime) * TIMESCALE;\n    float val_1 = gen_map(0.2, uv, iters, 1.,  time, BALANCE);\n    vec2 du = 0.2 * vec2(rnd(8.1), rnd(1.2)) + 0.1;\n    float val_2 = gen_map(0.2, uv - du, iters, 2.2, time, BALANCE);\n    float val = (val_1 + val_2) / 2.;\n    \n    //snow\n    vec3 col = white;\n    if (val <= snow_line && val > mount_line_1) {\n        float a = (val - mount_line_1) / (snow_line - mount_line_1);\n        col = mix(dark_brown, white,  pow(abs(a),0.2));\n    }\n    \n    //mountains\n    if (val < mount_line_1) {\n        float a = (val - mount_line_2) / (mount_line_1 - mount_line_2);\n        col = mix(brown, dark_brown,  pow(abs(a),0.5));\n    }\n    if (val < mount_line_2) col = brown;\n    \n    //ground\n    if (val < ground_line_1) {\n        float a = (val - ground_line_2) / (ground_line_1 - ground_line_2);\n        col = mix(light_green, dark_green,  a);\n    }\n    if (val < ground_line_2) col = light_green;\n    if (val < sand_line) col = beige;\n    \n    //water\n    if (val < water_line_1) col = blue;\n    if (val < water_line_2) col = dark_blue;\n    \n    \n    if (zoom<100.) {\n        float sky = gen_sky(uv, iters);\n        float a = (val - 0.4) / (1. - 0.4);\n        if (val > 0.4) \n            sky = clamp(0., 1., mix(sky, 0., pow(abs(a),0.2)));\n\t\telse \n            sky = clamp(0., 1.,sky);\n            \n        vec3 sky_col = white;\t\n        col = col * (1. - sky) + sky_col * sky;\n    }\n    \n    //out of reach\n    if (uv.x<0. || uv.x>1.) col = vec3(0., 0., 0.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}