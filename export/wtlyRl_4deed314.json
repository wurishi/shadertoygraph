{"ver":"0.1","info":{"id":"wtlyRl","date":"1592834003","viewed":929,"name":"TimeOfDay_Weather_Manager","username":"Polytopes","description":"I didn't invent a lot of things, I took pieces of code from several shaders, addapated, optimized and modified them in order to deepen my kowledge in shader language. Sorry if I didn't put all credits for code.\nTime of day manager (Day and night) and weat","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["sky","skybox","dust","weather","desert","tod"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////\n//-----------------------------------------------------------//\n// ------------------------ STRUCTS -------------------------//\n//-----------------------------------------------------------//\n// Materials\n// Energine conservation == microsurface + reflectivity\n// 1. Diffuse: \t\tThe color of diffused light\n// 2. Reflectivity: How reflective a surface is when viewing head\nstruct material \n{\n\tvec3\t\talbedo;\n\tfloat\t\treflectivity;\n};\n\n// Ray intersection\nstruct rayIntersect \n{\n\tvec3\t\tmPos;\t\t\t\t// Pos\n    vec2\t\tmUV;\t\t\t\t// Screen space pos\n\tvec3\t\tnor; \t\t\t\t// Normal\n\tfloat\t\tdist;\t\t\t\t// Distance\n    vec3\t\trd;\t\t\t\t\t// Ray direction\n\tmaterial\tmat; \t\t\t\t// Object material\n};\n\n\n//-----------------------------------------------------------//\n// -------------------- MATH FUNCTIONS --------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_SANDSTRIPS\n    // Standard 2D rotation formula\n    mat2 Rot2(const in float angle)\n    { \n        float c = cos(angle), s = sin(angle); \n        return mat2(c, s, -s, c);\n    }  \n#endif\n    \n// Quadratic easing in - accelerating from zero velocity--------\n#define EaseInQuad(value) (value) * (value)\n\n// Quartic easing in - accelerating from zero velocity\n#define EaseInQuart(value) pow((value), 4.0)\n\n// Exponential easing in - accelerating from zero velocity\n#define EaseInExpo(value) pow(2.0, 10.0 * abs((value) - 1.0))\n\n// Exponential easing in/out - accelerating until halfway, then decelerating\nfloat  EaseInOutExpo(const in float value) \n{\n    if(value * 2.0 < 1.0) \n        return 0.5 * pow(2.0, 10.0 * abs((value) * 2.0 - 1.0));\n\n    return 0.5 * (-pow(2.0, abs(-10.0 * ((value) * 2.0 - 1.0)) + 2.0));\n}\n\n// Cubic easing out - decelerating to zero velocity\n#define EaseOutCubic(value) (pow((value) * 2.0 - 1.0, 3.0) + 1.0)\n\n// Circular easing in - accelerating from zero velocity\n#define EaseInCirc(value) (-(sqrt(abs(1.0 - EaseInQuad(value))) - 1.0))\nfloat EaseInCircFct(const in float value)\n{\n    return EaseInCirc(value);\n}\n\n// Quintic easing out - decelerating to zero velocity\n#define EaseOutQuint(value) (pow((value) - 1.0, 5.0) + 1.0)\n\n// Sinusoidal easing out - decelerating to zero velocity\n#define EaseOutSine(value) (sin((value) * (PI/2.0)))\n\n// used for terrain and rain screen space\nfloat Hash1D(const in float n) \n{\n\treturn fract(sin(n)*4378.5453);\n}\n\n// used for water, stars \nfloat Hash2D(const in vec2 mPos) \n{\n    float h = dot(mPos, vec2(127.1, 311.7));\n    return fract(sin(h) * 43758.5453);\n}\n\n#ifndef DEBUG_NO_SANDSTRIPS\n    // used for sand stripes\n    vec2 Hash22(const in vec2 mPos) \n    {\n        float n = sin(dot(mPos, vec2(113.0, 1.0)));\n\n        return fract(vec2(2097152.0, 262144.0) * n) * 2.0 - 1.0;\n    }\n#endif\n\n#ifdef ToD_ACTIVATED\n\t// Heat color gradient\n\tvec3 HeatmapGradient(const in float value) \n\t{\n\t\treturn clamp((pow(value, 1.5) * 0.8 + 0.2) * vec3(smoothstep(0.0, 0.35, value) + value * 0.5, \n\t\t\t\t\t\t\t\t\t\t\t\t\t  smoothstep(0.5, 1.0, value), \n\t\t\t\t\t\t\t\t\t\t\t\t\t  max(1.0 - value * 1.7, value * 7.0 - 6.0)), \n\t\t\t\t\t 0.0, 1.0);\n\t}\n#endif\n\n#ifndef DEBUG_NO_RAIN\n\t// Calculate rainbow color\n\tvec3 RainbowGradient(const in float value) \n\t{\n\t\tvec3 c = 1.0 - pow(abs(vec3(value) - vec3(0.65, 0.5, 0.2)) \n\t\t\t\t\t\t   * vec3(3.0, 3.0, 5.0), vec3(1.5, 1.3, 1.7));\n\t\tc.r = max((0.15 - EaseInQuad(abs(value - 0.04) * 5.0)), c.r);\n\t\tc.g = (value < 0.5) ? smoothstep(0.04, 0.45, value) : c.g;\n\t\treturn clamp(c, 0.0, 1.0);\n\t}\n#endif\n\n#ifndef DEBUG_NO_CLOUDS\n\t// 3D noise for clouds\n\tfloat Noise3D(const in vec3 mPos)\n\t{\n\t\tvec3 p = floor(mPos);\n\t\tvec3 f = fract(mPos);\n\t\tf = f * f * (2.0 - 1.0 * f); //EaseInExpo\n\t\t\n\t\tvec2 noiseUV = (p.xy + vec2(37.0,17.0) * p.z) + f.xy;\n\t\tvec2 rg = texture(iChannel0, (noiseUV + 0.5)/256.0, -100.0).yx;\n\t\treturn mix(rg.x, rg.y, f.z);\n\t}\n\n\tfloat FBM(in vec3 p)\n\t{\n\t\tp *= 0.35;\n\t\tfloat f;\n\t\t\n\t\tf = 0.5000 * Noise3D(p); \n\t\tp = p * 3.02; \n\t\tp.x += iTime * CLOUD_MOVE;\n\t\t\n\t\tf += 0.2500 * Noise3D(p); \n\t\tp = p * 3.03; \n\t\tp.y -= iTime * CLOUD_EVAP;\n\t\t\n\t\tf += 0.1250 * Noise3D(p); \n\t\tp = p * 3.01;\n\t\t\n\t\tf += 0.0625   * Noise3D(p); \n\t\tp =  p * 3.03;\n\t\t\n\t\tf += 0.03125  * Noise3D(p); \n\t\tp =  p * 3.02;\n\n\t\treturn f;\n\t}\n\n\tfloat MapClouds(in vec3 p)\n\t{\n\t\tp *= 0.001;\n\t\treturn FBM(p);\n\t}\n#endif\n\n#ifndef DEBUG_NO_DUST\n// More concise, self contained version of IQ's original 3D noise function.\nfloat Noise3D_Dust(in vec3 mPos)\n{\n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(mPos); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    \n\tmPos -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    mPos = mPos * mPos * (3.0 - 2.0 * mPos);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), mPos.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, mPos.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, mPos.z); // Range: [0, 1].\n}\n#endif\n//-----------------------------------------------------------//\n// ------------------- END MATH FUNCTIONS ------------------ //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// -------------------- SAND STRIPS ------------------------ //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_SANDSTRIPS\n\t// Gradient noise based on IQ's implementation\n    float GradN2D(in vec2 f)\n    {\n        const vec2 e = vec2(0.0, 1.0);\n        vec2 p = floor(f);\n        f -= p; // Fractional position within the cube.\n\n        vec2 w = f * f * (3.0 - 2.0 * f); // Cubic smoothing. \n        float c = mix(mix(dot(Hash22(p + e.xx), f - e.xx), dot(Hash22(p + e.yx), f - e.yx), w.x),\n                      mix(dot(Hash22(p + e.xy), f - e.xy), dot(Hash22(p + e.yy), f - e.yy), w.x), w.y);\n\n        return c*.5 + .5; // Range: [0, 1].\n    }\n\n    float Grad(in float x, const in float offs)\n    {\n        x = abs(fract(x / TAU + offs - 0.25) - 0.5) * 2.0;\n\n        float x2 = clamp(x * x * (-1.0 + 2.0 * x), 0.0, 1.0); // Customed smoothed, peaky triangle wave.\n        x = smoothstep(0.0, 1.0, x);\n        return mix(x, x2, 0.15);\n    }\n\n\t// One sand function layer\n\tfloat SandL(const in vec2 mPos)\n    {\n        // Layer one. \n        vec2 q = Rot2(PI / 18.0) * mPos; // Rotate the layer, but not too much.\n        q.y += (GradN2D(q * 18.0) - 0.5) * 0.05; // Perturb the lines to make them look wavy.\n        float grad1 = Grad(q.y * 80.0, 0.0); // Repeat gradient lines.\n\n        q = Rot2(-PI / 20.0) * mPos; // Rotate the layer back the other way, but not too much.\n        q.y += (GradN2D(q * 12.0) - 0.5) * 0.05; // Perturb the lines to make them look wavy.\n        float grad2 = Grad(q.y * 80.0, 0.5); // Repeat gradient lines.\n\n\n        // Mix the two layers above with an underlying 2D function. The function you choose is up to you,\n        // but it's customary to use noise functions. However, in this case, I used a transcendental \n        // combination, because I like the way it looked better.\n        q = Rot2(PI / 4.0) * mPos;\n\n        // The mixes above will work, but I wanted to use a subtle screen blend of grad1 and grad2.\n        float a2 = dot(sin(q * 12.0 - cos(q.yx * 12.0)), vec2(0.25)) + 0.5;\n        float a1 = 1.0 - a2;\n\n        // Screen blend.\n        float c = 1.0 - (1.0 - grad1 * a1) * (1.0 - grad2 * a2);\n\n        return c;\n    }\n\n    float Sand(in vec2 mPos, const in float dist)\n    {\n        // Rotating by 45 degrees + zoomed in by a factor of 4.\n        mPos = vec2(mPos.y - mPos.x, mPos.x + mPos.y) * 0.7071 / 4.0;\n\n        // Sand layer 1.\n        float c1 = SandL(mPos);\n\n        // Second layer.\n        // Rotate, then increase the frequency -- The latter is optional.\n        vec2 q = Rot2(PI / 12.0) * mPos;\n        float c2 = SandL(q * 1.25);\n\n        // Mix the two layers with some underlying gradient noise.\n        c1 = mix(c1, c2, smoothstep(0.1, 0.9, GradN2D(mPos * vec2(4.0))));\n\n        // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern \n        // formed in the distance. Simply lessen the value when it's further away. Most people would\n        // figure this out pretty quickly, but it took me far too long before it hit me. :)\n        return c1/(1.0 + dist * dist * 0.015);\n    }\n\n    // Surface bump function..\n    float BumpSurf3D(const in vec3 mPos, const in float dist)\n    {\n        return Sand(mPos.xz, dist);\n    }\n\n    vec3 DoBumpMap(const in vec3 p, const in vec3 nor, const in float bumpfactor, const in float dist)\n    {\n        const vec2 e = vec2(0.001, 0); \n\n        float ref = BumpSurf3D(p, dist);\n        vec3 grad = (vec3(BumpSurf3D(p - e.xyy, dist),\n                          BumpSurf3D(p - e.yxy, dist),\n                          BumpSurf3D(p - e.yyx, dist)) - ref)/e.x; \n\n        grad -= nor*dot(nor, grad);          \n        return normalize(nor + grad*bumpfactor);\n    }\n#endif\n//-----------------------------------------------------------//\n// ------------------ END SAND STRIPS ---------------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// ---------------- DISTANCE FUNCTIONS --------------------- //\n//-----------------------------------------------------------//\n// By Iq: https://iquilezles.org/articles/distfunctions\n// Union with Material ID\nvec2 OperationUnion(const in vec2 distance1, const in vec2 distance2)\n{\n    return (distance1.x < distance2.x) ? distance1 : distance2;\n}\n\n#ifndef DEBUG_NO_TERRAIN\n    float TerrainDisplacement(const in vec2 mPos)\n    {\n        vec2 currPos = mPos * TERRAIN_SCALE;\n        float g = (sin(currPos.x + sin(currPos.y * 1.7)) \n                   + sin(currPos.y + sin(currPos.x * 1.3))) * 0.2;\n\t\t\n\t\treturn g * 2.5 * TERRAIN_MAXHEIGHT + TERRAIN_HEIGHT;\n    }\n\n\tfloat TerrainHighRez(const in vec2 mPos, const in vec2 eps, const in float waveFactor)\n    {\n        float dg1 = TerrainDisplacement(mPos - eps);\n        float dg2 = TerrainDisplacement(mPos + eps);\n        \n        float wave = (sin(mPos.x * 30.0) + 1.0) * 0.25 * max(waveFactor, 0.0);\n        \n\t\treturn (dg1 - dg2) + wave;\n    }\n#endif\n//-----------------------------------------------------------//\n// -------------- END DISTANCE FUNCTIONS ------------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// -------------------- SCENE DISTANCE --------------------- //\n//-----------------------------------------------------------//\nvec2 SceneDistance(const in vec3 mPos)\n{\n    #ifndef DEBUG_NO_TERRAIN\n    \treturn vec2(mPos.y - TerrainDisplacement(mPos.xz), 1.0);\n    #else\n    // Unsigned distance plane\n    \treturn vec2(mPos.y - WATER_HEIGHT, 0.0);\n\t#endif\n}\n//-----------------------------------------------------------//\n// ------------------ END SCENE DISTANCE ------------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// ----------------------- NIGHT SKY ----------------------- //\n//-----------------------------------------------------------//\n// [NV15] Space curvature from Iq : https://www.shadertoy.com/view/llj3Rz#\n#ifdef ToD_ACTIVATED\n    #ifndef DEBUG_NO_NIGHT\n        vec3 FancyCube(const in vec3 rayDirection, const in float s, const in float b)\n        {\n            vec3 colx = texture(iChannel1, 0.5 + s * rayDirection.yz / rayDirection.x, b).xyz;\n            vec3 coly = texture(iChannel1, 0.5 + s * rayDirection.zx / rayDirection.y, b).xyz;\n            vec3 colz = texture(iChannel1, 0.5 + s * rayDirection.xy / rayDirection.z, b).xyz;\n\n            vec3 n = rayDirection * rayDirection;\n\n            return (colx * n.x + coly * n.y + colz * n.z) / (n.x + n.y + n.z);\n        }\n\n        vec2 Voronoi(const in vec2 mPos)\n        {\n            vec2 n = floor(mPos);\n            vec2 f = fract(mPos);\n\n            vec3 m = vec3(8.0);\n            for(int j = -1; j <= 1; ++j)\n            for(int i = -1; i <= 1; ++i)\n            {\n                vec2  g = vec2( float(i), float(j));\n                vec2  o = vec2(Hash2D(n + g));\n                vec2  r = g - f + o;\n                float d = dot(r, r);\n                if(d < m.x)\n                    m = vec3(d, o);\n            }\n\n            return vec2(sqrt(abs(m.x)), m.y + m.z);\n        }\n\n        vec3 StarSky(const in vec3 rayDirection)\n        {\n            vec3 col = vec3(0.0);\n\n            // Big blueish gaz\n            col += 0.8 * pow(FancyCube(rayDirection, 0.05, 5.0).zyx, vec3(2.0));\n\n            // More detailed purpleish gaz\n            col += 0.8 * vec3(0.8, 0.5, 0.6) * pow(FancyCube(rayDirection, 0.1, 0.0).xxx, vec3(6.0));\n\n            //Stars\n            vec3 n = pow(abs(rayDirection), vec3(3.0));\n            vec2 vxy = Voronoi(NIGHT_STARSIZE * rayDirection.xy);\n            vec2 vyz = Voronoi(NIGHT_STARSIZE * rayDirection.yz);\n            vec2 vzx = Voronoi(NIGHT_STARSIZE * rayDirection.zx);\n\n            float stars = smoothstep(0.3, 0.7, FancyCube(rayDirection, 0.91, 0.0).x);\n            vec2 r = (vyz * n.x + vzx * n.y + vxy * n.z) / (n.x + n.y + n.z);\n            col += 0.9 * stars * clamp(1.0 - (3.0 + r.y * 5.0) * r.x, 0.0, 1.0);\n\n            // Gaz density\n            col = 1.5 * col - NIGHT_GAZDENSITY;\n\n            // Gaz color correction\n            col *= NIGHT_GAZCOLOR;\n\n            // TBD: MOON instead of sun\n            /*float s = clamp(dot(rayDirection, sunDirection), 0.0, 1.0);\n            col += 0.4 * pow(s, 5.0)  * vec3(1.0, 0.7, 0.6) * 2.0;\n            col += 0.4 * pow(s, 64.0) * vec3(1.0, 0.9, 0.8) * 2.0;*/\n\n            return col * rayDirection.y;\n        }\n\t#endif\n#endif\n//-----------------------------------------------------------//\n// --------------------- END NIGHT SKY --------------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// -------------- ATMOSPHERIC SCATTERING PBR --------------- //\n//-----------------------------------------------------------//\n// http://www.scratchapixel.com/lessons/3d-advanced-lessons/simulating-the-colors-of-the-sky/atmospheric-scattering/\n#ifdef PBR_SKY\n\tvoid Densities(const in vec3 mPos, out float rayleigh, out float mie) \n\t{\n\t\tfloat height = length(mPos - SKY_V3_EARTH_RADIUS) - SKY_EARTH_RADIUS;\n\t\trayleigh =  exp(-height / SKY_HR);\n\t\tmie = exp(-height / SKY_HM);\n\t}\n\n\tfloat Escape(const in vec3 rayDirection) \n\t{\n\t\tfloat b = dot(SKY_ESCAPE_V, rayDirection);\n\t\tfloat det2 = b * b - SKY_ESCAPE_C;\n\t\t\n\t\tif (det2 < 0.0) \n\t\t\treturn -1.0;\n\t\t\t\n\t\tfloat det = sqrt(abs(det2));\n\t\tfloat t1 = -b - det;\n\t\tfloat t2 = -b + det;\n\t\t\n\t\treturn (t1 >= 0.0) ? t1 : t2;\n\t}\n\n\t//vec3 SkyScatterring(const in vec2 mUV, const in vec3 rayDirection)\n\tvec3 SkyScatterring(const in vec2 mUV, in vec3 rayDirection)                                      \n\t{\n\t\t//Clamp min height rd\n\t\trayDirection.y = max(rayDirection.y, -0.07);\n\t\t\n\t\tfloat segment = Escape(rayDirection);\n\t\tfloat segmentLength = segment / float(SKY_SAMPLES);\n\n\t\tvec3 sumR , sumM = vec3(0.0);\n\t\tfloat opticalDepthR, opticalDepthM = 0.0;\n\t\tfloat mu = dot(rayDirection, sunDirection);\n\t\tfloat opmu2 = 1.0 + mu * mu;\n\t\tfloat phaseR = 3.0 / (16.0 * PI) * opmu2;\n\t\tfloat phaseM = \t3.0 / (8.0 * PI) * ((1.0 - SKY_G2) * opmu2  / ((2.0 + SKY_G2) * pow(1.0 + SKY_G2 - 2.0 * 0.76 * mu, 1.5)));\n\t\t\n\t\tfor(int i = 0; i < SKY_SAMPLES; ++i) \n\t\t{\n\t\t\tfloat samplePosition = float(i) * segmentLength;\n\t\t\tvec3 height = vec3(0.0, 25e2, 0.0) + rayDirection * samplePosition;\n\t\t\tfloat rayleigh, mieScaleHeight = 0.0;\n\t\t\t\n\t\t\t// Compute optical depth for light\n\t\t\tDensities(height, rayleigh, mieScaleHeight);\n\t\t\trayleigh *= segmentLength; \n\t\t\tmieScaleHeight *= segmentLength;\n\t\t\topticalDepthR += rayleigh;\n\t\t\topticalDepthM += mieScaleHeight;\n\t\t\t\n\t\t\t// Light optical depth\n\t\t\tfloat lightRay = Escape(sunDirection);\n\n\t\t\tfloat segmentLengthLight = lightRay / float(SKYLIGHT_SAMPLE);\n\t\t\tfloat opticalDepthLightR, opticalDepthLightM = 0.0;\n\t\t\tfor(int j = 0; j < SKYLIGHT_SAMPLE; ++j) \n\t\t\t{\n\t\t\t\tfloat lightRayleigh, LightMieScaleHeight = 0.0;\n\t\t\t\tfloat samplePositionLight = float(j) * segmentLengthLight;\n\t\t\t\tvec3 heightLight = height + sunDirection * samplePositionLight;\n\t\t\t\tDensities(heightLight, lightRayleigh, LightMieScaleHeight);\n\t\t\t\topticalDepthLightR += lightRayleigh * segmentLengthLight;\n\t\t\t\topticalDepthLightM += LightMieScaleHeight * segmentLengthLight;\n\t\t\t}\n\n\t\t\tvec3 attenuation = exp(-(SKY_BETA_R * (opticalDepthLightR + opticalDepthR) + SKY_BETA_M * 1.1 * (opticalDepthM + opticalDepthLightM)));\n\t\t\tsumR += attenuation * rayleigh;\n\t\t\tsumM += attenuation * mieScaleHeight;\n\t\t}\n\t\treturn 20.0 * sun_Color.w * (sumR * phaseR * SKY_BETA_R + sumM * phaseM * SKY_BETA_M);\n\t}\n#else\n\tvec3 SkyScatterring(const in vec2 mUV, in vec3 rayDirection)                                      \n\t{\n\t\tfloat sun = clamp(dot(sunDirection, rayDirection), 0.0, 1.0);\n\t\tvec3 hor = mix(1.2 * vec3(0.70, 1.0, 1.0), vec3(1.5, 0.5, 0.05), 0.25 + 0.75 * sun);\n\t\t\n        vec3 skyColor = mix(vec3(0.2, 0.6, 0.9), \n                            hor, \n                            exp(-(4.0 + 2.0 * (1.0 - sun)) * max(0.0, rayDirection.y - 0.1)));\n        \n\t\tskyColor *= 0.5;\n\t\tskyColor += 0.8 * vec3(1.0, 0.8, 0.7) * pow(sun, 512.0);\n\t\tskyColor += 0.2 * vec3(1.0, 0.4, 0.2) * pow(sun, 32.0);\n\t\tskyColor += 0.1 * vec3(1.0, 0.4, 0.2) * pow(sun, 4.0);\n        \n        return skyColor;\n\t}\n#endif\n//-----------------------------------------------------------//\n// ------------ END ATMOSPHERIC SCATTERING PBR ------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// ------------------------ SKYBOX ------------------------- //\n//-----------------------------------------------------------//\n    ////////!\\\\\\\\\\\\\\\\\n    //    Notes    \\\\\n    ////////!\\\\\\\\\\\\\\\\^\n    /*sun color, and shadowed clouds, like a gradient but separated from the intensity\n        I should manage color and intensity separatly: \n            Try HSV or HSL?!\n            Hue by using kind of heat map (scale factor: SunAmount, cloudsDensity, TimeOfDay);\n            Saturation by using easing function (cloudy, cloudsDensity, cloudHeight);\n            Value by using easing function (cloudy, SunAmount);\n\n\n        Shadowed cloud during day is kind of blue ish(sky?!):\n            vec3(0.47058823529412, 0.58823529411765, 0.72156862745098)\n            same as above but 100% saturated: vec3(0.0, 0.33725490196078, 0.72156862745098)\n            HSV: 212, 35, 72\n        Lighted cloud during day is kind of light orange (sunColor?!)\n            vec3(0.98039215686275, 0.92156862745098, 0.84313725490196)\n            100% saturated: vec3(0.98039215686275, 0.55686274509804, 0.0)\n            HSV: 34, 14, 98\n\n        Global clouds luminosity variation for a half clear sky is from 72% to 98% (day)\n\n        Shadowed cloud during sunset\n        I believed it was a dark purple but it seems it's more a dark red\n            vec3(0.32549019607843, 0.2, 0.25098039215686);\n            100% saturated: vec3(0.32941176470588, 0.0, 0.1333333333333333);\n            HSV: 336, 39, 33\n        Lighted cloud during the sunset depends on the sun position/sunamount\n        Goes from saturated orange to red, seems to have relation with suncolor\n            close from sun pos: (orange)\n                vec3(0.99607843137255, 0.70980392156863, 0.24705882352941);\n                100% saturated: vec3(0.98823529411765, 0.61176470588235, 0.0);\n                HSV: 37, 75, 99\n            far from the sun: (red)\n                vec3(0.97647058823529, 0.30980392156863, 0.16862745098039);\n                100% saturated: vec3(0.98039215686275, 0.16470588235294, 0.0);\n                HSV: 10, 83, 98\n\n        Global clouds luminosity variation for a half clear sky is from 33% to 99% (sunset)\n\n        Shadowed cloud during the night very dark blue\n            vec3(0.09019607843137, 0.10196078431373, 0.13725490196078);\n            100% saturated: vec3(0.0, 0.03529411764706, 0.14117647058824);\n            HSV: 225, 34, 14\n        Lighted cloud during the night grey blue\n            vec3(0.21568627450980, 0.21176470588235, 0.23137254901961);\n            100% saturated: vec3(0.04705882352941, 0.0, 0.23137254901961);\n            HSV: 252, 8, 23\n\n        Global clouds luminosity variation for a half clear sky is from 14% to 23% (night)*/\n\n    ////////!\\\\\\\\\\\\\\\\\n    // TO DO sunRay\\\\\n    ////////!\\\\\\\\\\\\\\\\\n//#ifndef DEBUG_NO_CLOUDS\t\n    float GetCloudShadow(const in vec3 pos)\n    {\n        float cloudyChange = abs(1.0 - (0.1 + (cloudy - 0.15) * (0.8/0.6)));\n        vec2 cuv = pos.xz + sunDirection.xz * (100.0 - pos.y) / sunDirection.y;\n        float cc = 0.1 + 0.9 * smoothstep(0.0, cloudyChange, \n                                          texture( iChannel1, 0.0008 * cuv \n                                                    + 0.005 * iTime).x);\n\t\n        return cc;\n    }\n//#endif\n\nvec3 CheapSkyBox(const in vec3 rayOrigin, const in rayIntersect rIntersec)\n{\n    vec3 sky = SkyScatterring(rIntersec.mUV, rIntersec.rd);\n\n    //Start and End of the cloud layer\n    float cloudStart = (CLOUD_LOWER - rayOrigin.y) / abs(rIntersec.rd.y);\n    float cloudEnd = (CLOUD_UPPER - rayOrigin.y) / abs(rIntersec.rd.y);\n\n    // Clouds start rayOrigin\n    vec3 cloudPos = vec3(rayOrigin.x + rIntersec.rd.x * cloudStart,\n                         0.0,\n                         rayOrigin.z + rIntersec.rd.z * cloudStart);\n\n    // Raymarch steps to raytrace clouds\n    vec3 add = rIntersec.rd * ((cloudEnd - cloudStart) / CLOUD_SAMPLES);\n    vec2 shade = vec2(0.0, 0.0);\n\n    // x == heigh value, y == mask (density on sky)\n    vec2 cloudsValue = vec2(0.0, 0.0);\n\n    // Loop for cloud density\n    for(float i = 0.0; i < CLOUD_SAMPLES; ++i)\n    {\n        if (cloudsValue.y >= 1.0) \n            break;\n\n        // Intensity of the current layer\n        shade.y = max(MapClouds(cloudPos) - cloudy, 0.0);\n\n        // Heigh value of the current layer\n        shade.x = i/CLOUD_SAMPLES;\n\n        // Merging new infos with backuped one\n        cloudsValue += shade * (1.0 - cloudsValue.y);\n        cloudPos += add;\n    }\n    cloudsValue.x /= 10.0;\n    cloudsValue = min(cloudsValue, 1.0);\n\n    float cloudsIntensity = cloudsValue.x * rIntersec.rd.y;\n    float sunHeight = clamp(sunDirection.y, 0.5, 1.0);\n    \n    // Applying contrast with cloudContrast and brightness with sunHeight\n    vec3 clouds = mix(((AMBIENT_COLOR * cloudsIntensity) - 0.5) + sunHeight,\n                      vec3(1.0),\n                      cloudsValue.x);\n\n    //clouds intensity by ToD\n    clouds *= max(sunDirection.y, 0.05);\n\n    //Composite sky and clouds\n    return mix(sky, clouds, cloudsValue.y);\n}\n                                     \nvec3 GetSkybox(const in vec3 rayOrigin, const in rayIntersect rIntersec)\n{\n    vec3 sky = SkyScatterring(rIntersec.mUV, rIntersec.rd);\n\n    #ifdef ToD_ACTIVATED\n        #ifndef DEBUG_NO_NIGHT\n            float nightMult = abs(min(0.16667, sun_Color.w * 6.0 - 1.0));\n            if(nightMult > 0.16667)\n                sky += StarSky(rIntersec.rd) * nightMult;\n        #endif\n\t#endif\n    \n    #ifdef DEBUG_NO_CLOUDS\n        //Apply sun on sky and return\n    \tsky += sun_Color.xyz * pow(sunAmount, abs(SUN_RADIUS)) * 40.0;\n        return sky;\n    \n    #else\n\t\t//Start and End of the cloud layer\n\t\tfloat cloudStart = (CLOUD_LOWER - rayOrigin.y) / abs(rIntersec.rd.y);\n\t\tfloat cloudEnd = (CLOUD_UPPER - rayOrigin.y) / abs(rIntersec.rd.y);\n\n\t\t// Clouds start rayOrigin\n\t\tvec3 cloudPos = vec3(rayOrigin.x + rIntersec.rd.x * cloudStart,\n\t\t\t\t\t\t\t 0.0,\n\t\t\t\t\t\t\t rayOrigin.z + rIntersec.rd.z * cloudStart);\n\n\t\t// Raymarch steps to raytrace clouds\n\t\tvec3 add = rIntersec.rd * ((cloudEnd - cloudStart) / CLOUD_SAMPLES);\n\t\tvec2 shade = vec2(0.0, 0.0);\n\n\t\t// x == heigh value, y == mask (density on sky)\n\t\tvec2 cloudsValue = vec2(0.0, 0.0);\n\n\t\t// Loop for cloud density\n\t\tfor(float i = 0.0; i < CLOUD_SAMPLES; ++i)\n\t\t{\n\t\t\tif (cloudsValue.y >= 1.0) \n\t\t\t\tbreak;\n\n\t\t\t// Intensity of the current layer\n\t\t\tshade.y = max(MapClouds(cloudPos) - cloudy, 0.0);\n\n\t\t\t// Heigh value of the current layer\n\t\t\tshade.x = i/CLOUD_SAMPLES;\n\n\t\t\t// Merging new infos with backuped one\n\t\t\tcloudsValue += shade * (1.0 - cloudsValue.y);\n\t\t\tcloudPos += add;\n\t\t}\n\t\tcloudsValue.x /= 10.0;\n\t\tcloudsValue = min(cloudsValue, 1.0);\n\t\t\n\t\t// cloudsValue.x [0.17647058823529; 1.0] need to transpose to [0.61, 0.91];\n\t\tfloat cloudsIntensity = EaseInCircFct(cloudsValue.x / 2.75 + 0.54636);\n\t\tfloat sunHeight = clamp(sunDirection.y, 0.5, 1.0);\n\t\tfloat cloudContrast = 1.6875 - 1.25 * cloudy;\n\n\t\t// Applying contrast with cloudContrast and brightness with sunHeight\n\t\tvec3 clouds = mix(((AMBIENT_COLOR * cloudsIntensity) - 0.5) * cloudContrast + sunHeight,\n\t\t\t\t\t\t  vec3(1.0),\n\t\t\t\t\t\t  cloudsValue.x);\n\n\t\t//clouds intensity by ToD\n\t\tclouds *= max(sunDirection.y, 0.05);\n\n\t\t//Composite Sun on clouds\n\t\tclouds += sun_Color.xyz * min(pow(sunAmount, abs(SUN_RADIUS) * 0.025) * (cloudy + 0.2) / 3.2,\n\t\t\t\t\t\t\t\t\t  exp(sun_Color.w+0.4) * 0.3);\n\n\t\t//Composite sun on sky\n\t\tsky += sun_Color.xyz * pow(sunAmount, abs(SUN_RADIUS)) * 40.0;\n\n\t\t//Composite sky and clouds\n\t\treturn mix(sky, min(clouds, 1.0), cloudsValue.y);\n    #endif\n}\n//-----------------------------------------------------------//\n// ---------------------- END SKYBOX ----------------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// ------------------------- RAIN -------------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_RAIN\n\tvec4 RainFX(const in vec4 colorResult, const in vec2 mUV, const in vec2 mPos)\n    {\n        vec2 texScroll =  mUV * vec2((mPos.y+2.5)*0.3, 0.05)\n                        + vec2(iTime * 0.165 + mPos.y *0.4, iTime * 0.1);\n        vec2 texScroll2 = mUV * vec2((mPos.y+2.5)*-0.5, 0.05) \n                        + vec2(iTime * 0.25 + mPos.y * -0.2, iTime * 0.1);\n\n        // Rain\n        float rainingFactor = texture(iChannel0, texScroll).y \n                              * texture(iChannel0, texScroll * 0.773).x * 1.55;\n        rainingFactor += texture(iChannel0, texScroll2).y \n                         * texture(iChannel0, texScroll2 * 0.770).x * 1.55;\n\n        rainingFactor = pow(rainingFactor, abs(colorResult.w));\n\n        //TBD: better zDepth 'cause it shit right now\n       return vec4(colorResult.xyz\n                   + (colorResult.xyz + vec3(1.2) * 0.001)\n                   * (vec3(0.4, 0.4, 0.45)* rainingFactor),\n                   colorResult.w);\n    }\n\n\t#ifndef DEBUG_NO_RAINBOW\n    vec4 ApplyRainbow(const in vec3 rayDirection, const in vec4 colorResult)\n    {\n        float rainbowAmount = dot(vec2(-FIXED_LIGHT.xy), rayDirection.xy);\n\n        float colorValue = smoothstep(RAINBOW_PARAMS.x, RAINBOW_PARAMS.x + RAINBOW_PARAMS.y, \n                                      rainbowAmount);\n        \n        if(colorValue < 1.0)\n        {\n            rainbowAmount = max((1.0 - (RAINBOW_PARAMS.w * EaseInQuad(rayDirection.z)\n                                       ))//* (cloudy - 0.75)))\n                                //* sin(PI * (-rainingValue + 1.0) * (-rainingValue + 1.0))\n                                * sin(PI * (-rainingValue + 2.0) * (-rainingValue + 2.0))\n                                * RAINBOW_PARAMS.z \t// Intensity max\n                                * colorResult.w \t// ZDepth\n                                ,0.0);\n            \n            //return vec4(rainbowAmount * min(cloudy + 0.5, 1.0) * sunDirection.y);\n            \n            return vec4(colorResult.xyz + RainbowGradient(1.0 - colorValue)* RAINBOW_PARAMS.z\n                        * rainbowAmount * min(cloudy + 0.5, 1.0) * sunDirection.y\n                        , colorResult.w);\n        }\n        \n        return colorResult;\n    }\n\t#endif\n#endif\n//-----------------------------------------------------------//\n// ----------------------- END RAIN ------------------------ //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// ------------------- SHADOW / NORMAL --------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_SHADOW\n    float SoftShadow(const in vec3 rayOrigin)\n    {\n        float res = 1.0;\n        float t = 0.1;\n        float sceneSample_F = float(SHADOW_SAMPLE);\n\n        for(int i=0; i < SHADOW_SAMPLE; ++i)\n        {\n            vec3  p = rayOrigin + sunDirection * t;\n            float h = SceneDistance(p).x;\n            res = min(res, sceneSample_F * h / t);\n\n            if(res < 0.1)\n                return 0.1;\n            \n            t += h;\n        }\n\n        return res;\n    }\n#endif\n\n#ifndef DEBUG_NO_TERRAIN\n// Calculate normals\nvec3 CalcTerrainNormal(const in vec3 mPos, const in float dist)\n{\n    vec2 eps = vec2(1.0 / iResolution.y * dist * dist, 0.0);\n    vec3 nor;\n    nor.x = TerrainDisplacement(mPos.xz - eps.xy) - \n        \tTerrainDisplacement(mPos.xz + eps.xy);\n    nor.y = 0.5 * eps.x;    \n    \n    nor.z = TerrainDisplacement(mPos.xz - eps.yx) - \n        \tTerrainDisplacement(mPos.xz + eps.yx);\n    \n    nor = normalize(nor);\n    \n    vec3 msand = DoBumpMap(mPos, nor, 0.07, dist);\n    \n    return normalize(msand);\n}\n#endif\n\n//-----------------------------------------------------------//\n// ------------------ END SHADOW / NORMAL ------------------ //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// ------------------- SHADING FUNCTIONS ------------------- //\n//-----------------------------------------------------------//\nvec3 Shading(vec3 rayOrigin, rayIntersect rIntersec)\n{\n    float NdotL = clamp(dot(rIntersec.nor, sunDirection), 0.0, 1.0);\n    float NdotV = clamp(dot(rIntersec.nor, -rIntersec.rd), 0.0, 1.0);\n    \n    // Fake GI\n    float NdotF = clamp(dot(rIntersec.nor, FIXED_LIGHT), 0.2, 0.6);\n\tfloat shadow = 1.0;\n    vec3 amb, diff = vec3(0.0);\n\n    \n    // Ambient\n    #ifndef DEBUG_NO_AMBIANT\n\t    amb = (abs(sun_Color.w - 1.0) * 0.03 + AMBIENT_POW) * AMBIENT_COLOR * rIntersec.mat.albedo;\n    #endif\n    \n    // Diffuse\n    #ifndef DEBUG_NO_DIFF\n    \tdiff = sun_Color.xyz * rIntersec.mat.albedo - rIntersec.mat.reflectivity / (2.0 * PI);\n    #endif\n    \n    #ifndef DEBUG_NO_SHADOW\n    \tshadow = SoftShadow(rIntersec.mPos + sunDirection);\n    \t#ifndef DEBUG_NO_CLOUDS\n    \t\tshadow *= GetCloudShadow(rIntersec.mPos.xyz);\n    \t#endif\n    #endif\n    \n    return amb + mix(NdotV * amb * rIntersec.mat.albedo, \n                     diff * NdotL * shadow,\n                     sun_Color.w);\n}\n//-----------------------------------------------------------//\n// ----------------- END SHADING FUNCTIONS ----------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// -------------------- COLOR FUNCTIONS -------------------- //\n//-----------------------------------------------------------//\nvoid ColorScene(inout rayIntersect rIntersec)\n{\n\t#ifndef DEBUG_NO_TERRAIN\n    \t//if(rIntersec.mat.microsurface - 0.5 < 1.0)\n    {\n        rIntersec.mat.albedo = vec3(244.0, 164.0, 96.0)/255.0;//vec3(0.929412, 0.788235, 0.686275);\n        rIntersec.mat.reflectivity = 0.9;\n        rIntersec.nor = CalcTerrainNormal(rIntersec.mPos, rIntersec.dist);\n        return;\n    }\n\n    rIntersec.nor = vec3(0.0, 1.0, 0.0);\n    \n    #endif\n}\n//-----------------------------------------------------------//\n// ------------------ END COLOR FUNCTIONS ------------------ //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// ---------------------- RAYMARCHING ------------------------ //\n//-----------------------------------------------------------//\nvec3 RayMarchScene(vec3 rayOrigin, inout rayIntersect rIntersec)\n{\n    float t = NEARCLIP;\n    vec2 res = vec2(NEARCLIP, -1.0);\n    \n\tfor(int i=0; i < SCENE_SAMPLE; ++i)\n\t{\n        vec3 pos = rayOrigin + t * rIntersec.rd;\n        res = SceneDistance(pos);\n        if(res.x < (EPSILON * t) || t > FARCLIP)\n            break;\n        t += res.x * 0.5;\n\t}\n    \n    vec3 pos = rayOrigin + t * rIntersec.rd;\n    rIntersec.mPos = pos;\n    rIntersec.dist = t;\n\t\n    material mat;\n    mat.albedo = vec3(244.0, 164.0, 96.0)/255.0;\n    mat.reflectivity = 0.8;\n    rIntersec.mat = mat;\n    \n    #if DEBUG_PASS == 0\n        if (t > FARCLIP)\n        {\n            rIntersec.dist = FARCLIP;\n            return GetSkybox(rayOrigin, rIntersec);\n        }\n        else\n        {\n            #ifndef DEBUG_NO_FOG\n                float sundot = clamp(dot(rIntersec.rd, sunDirection), 0.0, 1.0);\n            \tvec3 sky = CheapSkyBox(rayOrigin, rIntersec);\n            \tColorScene(rIntersec);\n            \n            \tfloat fogFactor = EaseOutSine(rIntersec.dist / FARCLIP);\n            \treturn mix(Shading(rayOrigin, rIntersec), sky, fogFactor);\n            #else\n            \tColorScene(rIntersec);\n            \treturn Shading(rayOrigin, rIntersec);\n            #endif\n        }\n    \n    #elif DEBUG_PASS == 1\n    \tif(t < FARCLIP)\n            ColorScene(rIntersec);\n    \treturn rIntersec.nor;\n    \n    #elif DEBUG_PASS == 2\n        if (t > FARCLIP)\n            rIntersec.dist = FARCLIP;\n        return vec3(rIntersec.dist) / FARCLIP;\n    \n    #elif DEBUG_PASS == 3\n    \treturn rIntersec.mPos;\n    \n    #elif DEBUG_PASS == 4\n    \tif(t < FARCLIP)\n            ColorScene(rIntersec);\n        vec3 sunLightPos = normalize(sunDirection);\n        float NdotL = clamp(dot(rIntersec.nor, sunLightPos), 0.0, 1.0);\n        return vec3(NdotL);\n    \n    #elif DEBUG_PASS == 5\n    \tif(t < FARCLIP)\n            ColorScene(rIntersec);\n        float NdotV = clamp(dot(rIntersec.nor, -rIntersec.rd), 0.0, 1.0);\n        return vec3(NdotV);\n    \n    #elif DEBUG_PASS == 6\n    \tif(t < FARCLIP)\n            ColorScene(rIntersec);\n        vec3 sunLightPos = normalize(sunDirection);\n        vec3 HalfAngleV = normalize(-rIntersec.rd + sunLightPos);\n        float NdotH = clamp(dot(rIntersec.nor, HalfAngleV), 0.0, 1.0);\n        return vec3(NdotH);\n    \n    #elif DEBUG_PASS == 7\n    \tif(t < FARCLIP)\n            ColorScene(rIntersec);\n        vec3 sunLightPos = normalize(sunDirection);\n        vec3 HalfAngleV = normalize(-rIntersec.rd + sunLightPos);\n        float VdotH = clamp(dot(-rIntersec.rd, HalfAngleV), 0.0, 1.0);\n        return vec3(VdotH);\n    \n    #elif DEBUG_PASS == 8\n    \tif (t > FARCLIP)\n        {\n            rIntersec.dist = FARCLIP;\n            return GetSkybox(rayOrigin, rIntersec);\n        }\n        else\n\t    \treturn CheapSkyBox(rayOrigin, rIntersec);\n    \n    #elif DEBUG_PASS == 9\n    \tif(t < FARCLIP)\n            ColorScene(rIntersec);\n    \n    \tvec3 amb = (abs(sun_Color.w - 1.0) * 0.03 + AMBIENT_POW) * AMBIENT_COLOR;\n    \treturn amb;\n\n    #elif DEBUG_PASS == 10\n   \t\tfloat shadow = SoftShadow(rIntersec.mPos + sunDirection);\n    \treturn vec3(shadow);\n    \n    #endif\n}\n//-----------------------------------------------------------//\n// -------------------- END RAYMARCHING -------------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// --------------------- SCENE RENDER ---------------------- //\n//-----------------------------------------------------------//\nvec4 RenderScene(vec2 mUV, vec3 rayOrigin, vec3 rayDirection, inout rayIntersect rIntersec)\n{\n\trIntersec.mPos = vec3(0.0);\n    rIntersec.mUV = mUV;\n\trIntersec.nor = vec3(0.0);\n\trIntersec.dist = 0.0;\n\trIntersec.rd = rayDirection;\n    \n\t// Opaque\n    vec3 accum = RayMarchScene(rayOrigin, rIntersec);\n    \n    float fogFactor = EaseOutSine(rIntersec.dist / FARCLIP);\n    \n    vec4 colorResult = vec4(clamp(accum, 0.0, 1.0), fogFactor);\n    \n    return colorResult;\n}\n//-----------------------------------------------------------//\n// ------------------- END SCENE RENDER -------------------- //\n//-----------------------------------------------------------//\n\n//-----------------------------------------------------------//\n// ------------------------ DUST --------------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_DUST\nfloat GetDust(in vec3 rayOrigin, in vec3 rayDirection, in vec3 light, in float dist)\n{\n    float mist = 0.0;\n    \n    rayOrigin -= vec3(0.0, 0.0, iTime*0.5);\n    \n    float t0 = 0.0;\n    \n    for (int i = 0; i < 4; i++)\n    {\n        // If we reach the surface, don't accumulate any more values.\n        if (t0 > dist) \n            break; \n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(light - rayOrigin) / FARCLIP; \n\t    float sAtt = 1.0 / (1.0 + sDi * 0.25);\n\t    \n        // Noise layer.\n        vec3 ro2 = (rayOrigin + rayDirection * t0) * 2.5;\n        float c = Noise3D_Dust(ro2) * 0.65 + Noise3D_Dust(ro2 * 3.0) * 0.25 + Noise3D_Dust(ro2 * 9.0) * 0.1;\n\n        mist += c*sAtt;\n        \n        // Advance the starting point towards the hit point. You can \n        // do this with constant jumps (FAR/8., etc), but I'm using\n        // a variable jump here, because it gave me the aesthetic \n        // results I was after.\n        t0 += clamp(c * 0.33, 0.25, 0.85);\n        \n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return max(mist/12., 0.);\n    \n    // A different variation (float n = (c. + 0.);)\n    //return smoothstep(.05, 1., mist/32.);\n}\n\nvoid ApplyDust(inout vec4 mColor, const in vec3 rayOrigin, const in vec3 rayDirection, const in vec3 light, const in rayIntersect rIntersec)\n{\n    float dust = GetDust(rayOrigin, rayDirection, sunDirection, rIntersec.dist) * sun_Color.w;\n    vec3 mistCol = vec3(1.0, 0.95, 0.9); \n    mColor.xyz += (mix(mColor.xyz, mistCol, 1.66) * 0.66 + mColor.xyz * mistCol * 1.0) * dust;\n}\n#endif\n//-----------------------------------------------------------//\n// --------------------- END DUST -------------------------- //\n//-----------------------------------------------------------//\n\n\n\n//-----------------------------------------------------------//\n// --------------------- POST PROCESS ---------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_POSTPROCESS\n\t// Grain by jcant0n == https://www.shadertoy.com/view/4sXSWs\n\tvoid Grain(inout vec3 colorResult, const in vec2 mUV)\n\t{\n        float x = (mUV.x + 4.0 ) * (mUV.y + 4.0 ) * (iTime * 10.0);\n        vec3 grain = 1.0 - vec3(mod((mod(x, 13.0) + 1.0) * \n                                    (mod(x, 123.0) + 1.0), \n                                    0.01)-0.005) * GRAIN_STRENGTH;\n    \n        colorResult *= grain;\n    }\n\n    void LensFX(inout vec3 colorResult, const in vec2 mUV)\n    {\n        vec2 uvT = mUV * (length(mUV));\n\n        float lensR1 = max(1.0 / (1.0 + 32.0 * pow(length(uvT + 0.80 * sunPos), 2.0)), 0.0) * 0.25;\n        float lensG1 = max(1.0 / (1.0 + 32.0 * pow(length(uvT + 0.85 * sunPos), 2.0)), 0.0) * 0.23;\n        float lensB1 = max(1.0 / (1.0 + 32.0 * pow(length(uvT + 0.90 * sunPos), 2.0)), 0.0) * 0.21;\n\n        vec2 uvx = mix(mUV, uvT, -0.5);\n        lensR1 += max(0.01 - pow(length(uvx + 0.400 * sunPos), 2.4), 0.0) * 6.0;\n        lensG1 += max(0.01 - pow(length(uvx + 0.450 * sunPos), 2.4), 0.0) * 5.0;\n        lensB1 += max(0.01 - pow(length(uvx + 0.500 * sunPos), 2.4), 0.0) * 3.0;\n\n        uvx = mix(mUV, uvT, -0.4);\n        lensR1 += max(0.01 - pow(length(uvx + 0.200 * sunPos), 5.5), 0.0) * 2.0;\n        lensG1 += max(0.01 - pow(length(uvx + 0.400 * sunPos), 5.5), 0.0) * 2.0;\n        lensB1 += max(0.01 - pow(length(uvx + 0.600 * sunPos), 5.5), 0.0) * 2.0;\n\n        uvx = mix(mUV, uvT, -0.5);\n        lensR1 += max(0.01 - pow(length(uvx - 0.300 * sunPos), 1.6), 0.0) * 6.0;\n        lensG1 += max(0.01 - pow(length(uvx - 0.325 * sunPos), 1.6), 0.0) * 3.0;\n        lensB1 += max(0.01 - pow(length(uvx - 0.350 * sunPos), 1.6), 0.0) * 5.0;\n\n        // Dirty screen\n        float dirt = 1.0-texture( iChannel1, mUV).r;\n        dirt *= (pow(sunAmount,30.0) + 0.05) * 0.8;\n\n        colorResult += (vec3(lensR1, lensG1, lensB1) * sunAmount * 5.0 + dirt) * sun_Color.w * cloudy;\n    }\n\n    void FlareFX(inout vec4 colorResult, const in vec2 mUV)\n    {\n        //flare\n        vec2 sunScreen = mUV - sunPos.xy;\n        float ang = atan(sunScreen.y, sunScreen.x);\n        float dist = length(sunPos); \n        dist = pow(dist, 0.1);\n\n        float flare = 1.0 / (length(sunScreen) * 8.0);\n\n        flare = flare + flare * (sin((ang + abs(ang) * 2.0) * 12.0) * 0.1 + dist * 0.1 + 0.8);\n\n        colorResult.xyz += (sun_Color.xyz * flare * sun_Color.w);\n    }\n\n    void GammaCorrection(inout vec3 colorResult)\n    {\n        colorResult = pow(colorResult, abs(vec3(GAMMA)));\n    }\n\n    void ContrastBrightness(inout vec3 colorResult)\n    {\n        colorResult = (colorResult - 0.5) * CONTRAST + BRIGHTNESS;\n    }\n\n    void Desaturate(inout vec3 colorResult)\n    {\n        #ifndef DEBUG_NO_CLOUDS\n            //colorResult = mix(vec3(dot(colorResult, vec3(0.33))), colorResult, min(cloudy * 2.5, 1.0));\n        \tcolorResult = mix(colorResult, vec3(dot(colorResult, vec3(0.33))), min(rainingValue, 0.4));\n        #else\n            colorResult = mix(vec3(dot(colorResult, vec3(0.33))), colorResult, DESATURATION);\n        #endif\n    }\n\n    void Tint(inout vec3 colorResult)\n    {\n        colorResult *= TINT_COLOR;\n    }\n\n    void Vigneting(inout vec3 colorResult, const in vec2 fragCoord)\n    {\n        vec2 mUV = fragCoord.xy / iResolution.xy;\n        colorResult *= 0.5 + 0.5 * pow(16.0 * mUV.x * mUV.y\n                                       * (1.0 - mUV.x) * (1.0 - mUV.y), abs(VIGNETING_POWER));\n    }\n\n    void ApplyPostProcess(inout vec4 colorResult, const in vec2 mUV, const in vec2 fragCoord)\n    {\n        #ifndef DEBUG_NO_RAIN\n    \t\t//colorResult = RainFX(colorResult, mUV, fragCoord / iResolution.xy);\n    \t#endif\n        \n        //LensFlareFX\n        if (sun_Color.w > 0.0)\n        {\n            LensFX(colorResult.xyz, mUV);\n            //FlareFX(colorResult, mUV);\n        }\n\n        Grain(colorResult.xyz, mUV);\n        GammaCorrection(colorResult.xyz);\n        ContrastBrightness(colorResult.xyz);\n        Desaturate(colorResult.xyz);\n        Tint(colorResult.xyz);\n        Vigneting(colorResult.xyz, fragCoord);\n    }\n#endif\n//-----------------------------------------------------------//\n// ------------------- END POST PROCESS -------------------- //\n//-----------------------------------------------------------//\n\n// Camera orientation + Raining post process\nvec3 GetCameraRayDir(const in vec2 mUV, const in vec3 camPosition, const in vec3 camTarget)\n{\n\tvec3 forwardVector = normalize(camTarget - camPosition);\n\tvec3 rightVector = normalize(cross(vec3(0.0, 1.0, 0.0), forwardVector));\n\tvec3 upVector = normalize(cross(forwardVector, rightVector));\t\n    \n\tvec3 camDirection = normalize(mUV.x * rightVector * FOV\n                                  + mUV.y * upVector * FOV\n                                  + forwardVector);\n\n    \n\tsunPos = vec2(dot(sunDirection, rightVector), \n                  dot(sunDirection, upVector));\n    \n    #ifndef DEBUG_NO_RAIN\n    \t//Raining\n    \t#ifndef DEBUG_NO_WATERDROPLET\n\t\t\tfloat t = floor(mUV.x * MAX_DROPLET_NMBR);\n            float r = Hash1D(t);\n    \n            //used for radius of droplet, smaller float == bigger drop\n            float fRadiusSeed = fract(r * 40.0);\n            float radius = fRadiusSeed * fRadiusSeed * 0.02 + 0.001;\n    \n            float fYpos = r * r - clamp(mod(iTime * radius * 2.0, 10.2) - 0.2, 0.0, 1.0);\n            radius *= rainingValue;\n            vec2 vPos = vec2((t + 0.5) * (1.0 / MAX_DROPLET_NMBR), fYpos * 3.0 - 1.0);\n            vec2 vDelta = mUV - vPos;\n\n            const float fInvMaxRadius = 1.0 / (0.02 + 0.001);\n            vDelta.x /= (vDelta.y * fInvMaxRadius) * -0.15 + 1.85; // big droplets tear shaped\n\n            vec2 vDeltaNorm = normalize(vDelta);\n            float l = length(vDelta);\n            if(l < radius)\n            {\t\t\n                l = l / radius;\n\n                float lz = sqrt(abs(1.0 - l * l));\n                vec3 vNormal = l * vDeltaNorm.x * rightVector \n                               + l* vDeltaNorm.y * upVector \n                               - lz * forwardVector;\n                vNormal = normalize(vNormal);\n                camDirection = refract(camDirection, vNormal, 0.7);\n            }\n        #endif\n    #endif\n\treturn camDirection;\n}\n\n// Screen Coordinates\nvec2 GetScreenSpaceCoord(const in vec2 fragCoord)\n{\n\tvec2 mUV = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tmUV.x *= iResolution.x / iResolution.y;\n\n\treturn mUV;\t\n}\n\nvec3 CamPath(float time)\n{\n    vec2 p = 1100.0 * vec2(cos(0.23 * time), cos(1.5 + 0.205 * time));\n    \n\treturn vec3(p.x, 0.0, p.y);\n}\n                                     \nvec2 CameraPath(float time)\n{\n    return 100.0 * vec2(cos(0.23 * time), cos(1.5 + 0.205 * time));\n\t//return vec3(p.x + 55.0, 0.0, -94.0 + p.y);\n}\n                                     \n// Main loop\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t//Get screen position between 0..1\n\tvec2 mUV = GetScreenSpaceCoord(fragCoord);\n    \n\t#if DEBUG_CAM == 0\n\t\tfloat time = 10.5;\n    \n\t#elif DEBUG_CAM == 1\n\t\tfloat time = 40.0 * iMouse.x/iResolution.x;\n    \n    #elif DEBUG_CAM == 2\n    \tfloat time = (iTime * 0.2);\n    \n    #elif DEBUG_CAM == 3\n\t\tvec2 vMouse = vec2(0.0);\n\t\tif (iMouse.x > 0.0) \n\t\t{\n\t\t\tvMouse = iMouse.xy / iResolution.xy;\n\t\t\tvMouse *= 5.0;\n\t\t\tvMouse.y -= 1.5;\n\t\t}\n\n\t\tvec3 rayOrigin = vec3(-0.5 + 20.0 * cos(6.0 * vMouse.x),\n\t\t\t\t\t\t\t   1.0 + 5.0 * vMouse.y + TERRAIN_HEIGHT,\n\t\t\t\t\t\t\t   0.5 + 20.0 * sin(6.0 * vMouse.x));\n\t\tvec3 camTarget = vec3(0.0, 0.5 + TERRAIN_HEIGHT, 0.0);\n\n\t\tif (rayOrigin.y < (TERRAIN_HEIGHT + TERRAIN_MAXHEIGHT))\n\t\t{\n\t\t\tcamTarget = vec3(0.0, TERRAIN_HEIGHT + TERRAIN_MAXHEIGHT, 0.0);\n\t\t\trayOrigin.y = TERRAIN_HEIGHT + TERRAIN_MAXHEIGHT;\n\t\t}\n\t#endif\n\t\n    #if DEBUG_CAM != 3\n    \tvec3 rayOrigin, camTarget;\n    \trayOrigin.xz = CameraPath(time);\n\t\tcamTarget.xz = CameraPath(time + 8.0);\n\t\trayOrigin.y = TerrainDisplacement(rayOrigin.xz) + 1.0;\n    \t\n\t\tcamTarget.y = rayOrigin.y - 5.0;\n    #endif\n    \n    #ifdef CLOUDYCHANGE\n\t\tcloudy = sin((iTime + 0.0) * CLOUD_SPEED) * 0.3 + 0.45;\n\t#endif\n\n    #ifndef DEBUG_NO_RAIN\n\t\trainingValue = max(0.0, (1.48 - cloudy * 2.0)) * (sin((iTime + 43.0) * RAIN_SPEED) * 0.5 + 0.5);\n    #endif\n\t\n    #ifdef ToD_ACTIVATED\n    \tsunDirection = normalize(mix(SUN_STARTPOS, SUN_ENDPOS, EaseInCirc(sin(iTime * SUN_SPEED))));\n    \tsun_Color.w = max(EaseOutSine(sunDirection.y), 0.0);\n    \tsun_Color.xyz = HeatmapGradient(EaseOutQuint(sunDirection.y + 0.180));\n    #endif\n\n    vec3 rayDirection = GetCameraRayDir(mUV, rayOrigin, camTarget);\n\n\tsunAmount = max(dot(sunDirection, rayDirection), 0.0);\n\n    rayIntersect mIntersection;\n\tvec4 colorResult = RenderScene(mUV, rayOrigin, rayDirection, mIntersection);\n    \n    //Add rain\n    #ifndef DEBUG_NO_RAIN\n    \t#ifndef DEBUG_NO_RAINBOW\n    \t\tcolorResult = ApplyRainbow(rayDirection, colorResult);\n    \t#endif\n    #endif\n    \n    #ifndef DEBUG_NO_DUST\n    \tApplyDust(colorResult, rayOrigin, rayDirection, sunDirection, mIntersection);\n\t#endif\n    \n    #ifndef DEBUG_NO_POSTPROCESS\n\t\tApplyPostProcess(colorResult, mUV / 2.0, fragCoord);\n    #endif\n    \n    /// DEBUG ///\n    /*float debugText = PrintValue((mUV - vec2(-0.65,0.85)) * FONT_SCALE, rainingValue);\n    float tt = max(sin(PI * (rainingValue + 1.0) * (rainingValue + 1.0)), 0.0);\n    float debugText2= PrintValue((mUV - vec2(0.65,0.85)) * FONT_SCALE, tt);\n    colorResult.xyz = mix(colorResult.xyz, abs(debugText + debugText2) - colorResult.xyz, debugText + debugText2);*/\n    \n    /// TEST ///\n    /*float fogFactor = (-pow(2.0, -10.0 * colorResult.w) + 1.0) * rainingValue;\n    float topCloudOverlay = abs(max(mUV.y, 0.0)-1.0) * fogFactor;\n    colorResult.xyz = mix(colorResult.xyz, vec3(0.6588), topCloudOverlay);*/\n    \n    fragColor = colorResult;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////////////////////////////////////////////////\n//\t\t\t\t\t\t\tTo do:\t\t\t\t\t\t\t //\n///////////////////////////////////////////////////////////////\n//\t- Thanks + references\n//\t- Main focus:\n//\t\t60 FPS\n//\t\tPhysically based rendered\n//\t\tTime of day and weather manager\n//\n//\t- Clean code and debug:\n//\t\tSeparated functions\t\t\t\t100% (WIP)\n//\t\tNaming convention\t\t\t\t100% (WIP)\n//\t\tConsistency\t\t\t\t\t\t100% (WIP)\n//\t\n//\t- Shaders:\n//\t\tPBR / BRDF Opaque Shader\t\t100%\n//\t\tWater\t\t\t\t\t\t\t50%  (WIP)\n//\t\tWet surfaces\t\t\t\t\t0%\n//\t\n//\t- Time of day: \n//\t\tLightingÂ \t\t\t\t\t\t100% \n//\t\tColors\t\t\t\t\t\t\t100%\n//\t\tSoft shadows\t\t\t\t\t100%\n//\t\tSkylight / ambient\t\t\t\t80%\n//\t\tNight / Stars\t\t\t\t\t100%\n//\t\n//\t- Clouds:\n//\t\tWeather system\t\t\t\t\t100%\n//\t\tCloud lighting color\t\t\t100%\n//\t\tShadows\t\t\t\t\t\t\t100%\n//\t\tBirds silhouettes\t\t\t\t0%\n//\t\tGod rays\t\t\t\t\t\t0% \t (Nice to have)\n//\t\n//\t- Raining:\n//\t\t- Two directions + depth pass\t0% \t (Just a draft for now)\n//\t\t- ScreenSpace droplet\t\t\t50%\t (To polish screen space oriented)\n//\t\t- Rainbow \t\t\t\t\t\t90%\t (To polish the fade on ground)\n//\t\n//\t- Terrain:\n//\t\tTerrain function\t\t\t\t100%  (WIP)\n//\t\tTerrain textures\t\t\t\t75%\n//\t\n//\t- Camera: \n//\t\tCamera path function\t\t\t75%\t (Nice to have)\n//\t\n//\t- Post process:\n//\t\tFog\t\t\t\t\t\t\t\t100%\n//\t\tBloom\t\t\t\t\t\t\t50%  (Sun glow only for now)\n//\t\tGamma correction\t\t\t\t100%\n//\t\tColor tint\t\t\t\t\t\t100% (Implemented, to tweak at the end with cloudy)\n//\t\tColor desaturation\t\t\t\t100% (Implemented, to tweak at the end with cloudy\n//\t\tContrast\t\t\t\t\t\t100% (Implemented, to tweak at the end)\n//\t\tVignetteÂ \t\t\t\t\t\t100% (Implemented, to tweak at the end)\n//\t\tGrain\t\t\t\t\t\t\t100% (Implemented, to tweak at the end)\n//\t\tLens flare effect\t\t\t\t50%  (Implemented, to tweak at the end)\n//\t\tDOF for horizon\t\t\t\t\t0%\t (Nice to have)\n//\t\tAuto-exposure\t\t\t\t\t0%\t (Nice to have)\n//\t\tMotion blur\t\t\t\t\t\t0%\t (Nice to have)\n//\t\tChromatic aberration\t\t\t0%\t (Nice to have)\n//\t\tMusique (if so, I need a visual related to support it)\n//\n///////////////////////////////////////////////////////////////\n\n//-----------------------------------------------------------//\n// --------------------- DEBUG VALUES ---------------------- //\n//-----------------------------------------------------------//\n// 0  == RENDER_ALL_PASS\n// 1  == NORMAL_PASS\n// 2  == DEPTH_PASS\n// 3  == POS_PASS\n// 4  == NdotL_PASS\n// 5  == NdotV_PASS\n// 6  == NdotH_PASS\n// 7  == VdotH_PASS\n// 8  == CLOUDS_PASS\n// 9 == AMBIANT_PASS\n// 10 == SHADOW_PASS\n#define DEBUG_PASS 0\n\n// 0 == fixed cam\n// 1 == control path cam\n// 2 == cam path\n// 3 == rotated cam\n#define DEBUG_CAM 2\n\n//#define DEBUG_NO_AMBIANT\n//#define DEBUG_NO_SHADOW\n//#define DEBUG_NO_DIFF\n//#define DEBUG_NO_CLOUDS\n//#define DEBUG_NO_NIGHT\n//#define DEBUG_NO_FOG\n//#define DEBUG_NO_WATERDROPLET\n//#define DEBUG_NO_RAIN\n//#define DEBUG_NO_RAINBOW\n//TBD DEBUG_RAINBOW ?! \n//#define DEBUG_NO_TERRAIN\n//#define DEBUG_NO_SANDSTRIPS\n//#define DEBUG_NO_POSTPROCESS\n//#define DEBUG_SPEED_FAST\n\n// Time of day activated\n#define ToD_ACTIVATED\n#define PBR_SKY\n\n// Clouds\n#define CLOUDYCHANGE\n\n// DEBUG TEXT\n#define kCharBlank 12.0\n#define kCharMinus 11.0\n#define kCharDecimalPoint 10.0\n#define FONT_RATIO vec2(4.0, 5.0)\n#define FONT_SCALE 10.0\n#define DIGITS 1.0\n#define DECIMAL 3.0\n\n//-----------------------------------------------------------//\n// --------------------- GLOBAL VALUES --------------------- //\n//-----------------------------------------------------------//\n#define PI 3.14159\n#define TAU 6.28319\n\n#define EPSILON\t\t0.0001\n#define NEARCLIP \t0.1\n\n#ifndef DEBUG_NO_TERRAIN\n\t#define FARCLIP \t300.0\n#else\n\t#define FARCLIP \t400.0\n#endif\n\n#define FOV \t\t\tPI / 2.5 //FOV in rad == 39.598 == 50.0mm lens\n\n#define AMBIENT_COLOR vec3(0.54117647058824, 0.78431372549020, 1.0)\n#define AMBIENT_POW 0.08\n\n#define SCENE_SAMPLE 128\n#define SHADOW_SAMPLE 16\n\n//-----------------------------------------------------------//\n// -------------------- RAINING VALUES --------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_RAIN\n\t//x = radius, y= size, z = intensity, w = depth %age;\n\t#define RAINBOW_PARAMS vec4(0.25, 0.15, 0.8, 0.4)\n\t#define MAX_DROPLET_NMBR 50.0 //number of drop on screen\n\tfloat rainingValue;\n\n\t#ifdef DEBUG_SPEED_FAST\n\t\t#define RAIN_SPEED 0.4\n\t#else\n\t\t#define RAIN_SPEED 0.075\n\t#endif\n\n#endif\n\n//-----------------------------------------------------------//\n// ---------------------- SKY VALUES ----------------------- //\n//-----------------------------------------------------------//\n#ifdef PBR_SKY\n\t#define SKY_SAMPLES 16\n\t#define SKYLIGHT_SAMPLE 8\n\t#define SKY_HR 7.994e3 \t\t// Rayleigh == scattering of light by air mollecules\n\t#define SKY_HM 1.2e3\t\t// Mie == scattering of light by aerosols\n\t#define SKY_EARTH_RADIUS 6360e3\n\t#define SKY_V3_EARTH_RADIUS vec3(0.0, -SKY_EARTH_RADIUS, 0.0) //For scattering only\n\t#define SKY_ESCAPE_V vec3(0.0, 63625e2, 0.0)\n\t#define SKY_ESCAPE_C -73499375e4;\n\t//#define SKY_G 0.76 //--> G^2 below\n\t#define SKY_G2 0.5776\n\n\t//Sky at sea level for wavelengths 440, 550 and 680\n\t#define SKY_BETA_R vec3(5.8e-6, 13.5e-6, 33.1e-6)\n\t#define SKY_BETA_M vec3(21e-6)\n#endif\n\n//-----------------------------------------------------------//\n// --------------------- NIGHT VALUES ---------------------- //\n//-----------------------------------------------------------//\n#ifdef ToD_ACTIVATED\n    // Gaz density during the night. 0.0 == more, 0.5 == less\n    #define NIGHT_GAZDENSITY 0.2\n    // Color multiplier for intensity and color correction\n    #define NIGHT_GAZCOLOR vec3(0.5, 0.45, 0.5)\n    // Star size, biggest is smaller\n    #define NIGHT_STARSIZE 80.0\n#endif\n\n//-----------------------------------------------------------//\n// ---------------------- SUN VALUES ----------------------- //\n//-----------------------------------------------------------//\nfloat sunAmount;\nvec2 sunPos;\n//Sun radius\n#define SUN_RADIUS 1500.0\n#define FIXED_LIGHT vec3(-0.773, 0.635, -0.01)\n\n#ifdef ToD_ACTIVATED\n\t//Start time:\t17hrs 30min 6/21/2014 latt: 37.795 long: -122.394 \n\t#define SUN_STARTPOS vec3(0.001, 0.927, -0.376)\n\t//End time:\t\t20hrs 0min 6/21/2014 latt: 37.795 long: -122.394\n\t//#define SUN_ENDPOS vec3(-0.824, 0.0, 0.567)\n    //#define SUN_ENDPOS vec3(-0.636, -0.181, 0.751)\n\t#ifndef DEBUG_NO_NIGHT\n\t\t#define SUN_ENDPOS vec3(-0.142, -0.847, 0.512)\n\t#else\n\t\t#define SUN_ENDPOS vec3(-0.636, -0.181, 0.751)\n\t#endif\n\t/*17hrs 30min spectrum == 0%\n\tconst vec3 sunStartColor = vec3(1.0, 1.0, 0.8784313725490196);\n\t19hrs 20min spectrum == 73%\n\tconst vec3 sunMidColor1 = vec3(0.99607843137255, 0.65490196078431, 0.03529411764705);\n\t19hrs 30min spectrum == 80%\n\tconst vec3 sunMidColor2 = vec3(0.80392156862745, 0.21568627450980, 0.85098039215686);\n\t19hrs 37min spectrum == 85%\n\tconst vec3 sunMidColor3 = vec3(0.35686274509804, 0.14901960784314, 0.63137254901961);\n\t20hrs 00min spectrum == 100%\n\tconst vec3 sunMidColor4 = vec3(0.10980392156862, 0.11764705882352, 0.23921568627450);*/\n\tvec3 sunDirection;\n\tvec4 sun_Color; //xyz == color, w == intensity\n\n\t#ifdef DEBUG_SPEED_FAST\n\t\t#ifdef DEBUG_NO_NIGHT\n\t\t\t#define SUN_SPEED 0.125\n\t\t#else\n\t\t\t#define SUN_SPEED 0.0625\n\t\t#endif\n\t#else\n\t\t#ifdef DEBUG_NO_NIGHT\n\t\t\t#define SUN_SPEED 0.043\n\t\t#else\n\t\t\t#define SUN_SPEED 0.043\n\t\t#endif\n\t#endif\n#else\n\t//fixed time: \t18hrs 40min 6/21/2014 latt: 37.795 long: -122.394\n\t#define sunDirection vec3(-0.773, 0.635, -0.01)\n\t#define sun_Color vec4(0.84954, 0.99958, 0.99797, 1.0)\n#endif\n\n//-----------------------------------------------------------//\n// --------------------- CLOUDS VALUES --------------------- //\n//-----------------------------------------------------------//\n#define CLOUD_SAMPLES 20.0\n#define CLOUD_LOWER 1000.0\n#define CLOUD_UPPER 1500.0\n//#define CLOUD_LOWER 2500.0\n//#define CLOUD_UPPER 4000.0\n#ifdef DEBUG_SPEED_FAST\n\t#define CLOUD_MOVE 0.5\n\t#define CLOUD_EVAP 0.6\n#else\n\t#define CLOUD_MOVE 0.5\n\t#define CLOUD_EVAP 0.6\n#endif\n\n#ifdef CLOUDYCHANGE\n\t//Cloudy value from 0.15(DarkClouds) to 0.74 (clear sky)\n\tfloat cloudy;\n\t#ifdef DEBUG_SPEED_FAST\n\t\t#define CLOUD_SPEED 0.25\n\t#else\n\t\t#define CLOUD_SPEED 0.1\n\t#endif\n\n#else\n\t#ifndef DEBUG_NO_RAIN\n\t\t#define cloudy 0.375\n\t#else\n\t\t#define cloudy 0.5\n\t#endif\n#endif\n\n//-----------------------------------------------------------//\n// -------------------- TERRAIN VALUES --------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_TERRAIN\n\t#define TERRAIN_SCALE 0.3\n\t#define TERRAIN_HEIGHT 8.0\n\t#define TERRAIN_MAXHEIGHT 1.5\n#endif\n\n//-----------------------------------------------------------//\n// --------------------- WATER VALUES ---------------------- //\n//-----------------------------------------------------------//\n//used for the plane if no terrain and no water\n#define WATER_HEIGHT 7.35\t\t\t// Global Water height\n\n//-----------------------------------------------------------//\n// ---------------------- SAND STRIP ----------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_SANDSTRIPS\n    #define STRIP_SAMPLE 100\n    #define STRIP_BUMP_CONTRAST 1.0\n    #define STRIP_SIZE 8.0 //higher value is smaller strip\n    #define STRIP_FREQ 12.0 \n#endif\n\n//-----------------------------------------------------------//\n// ------------------ POSTPROCESS VALUES ------------------- //\n//-----------------------------------------------------------//\n#ifndef DEBUG_NO_POSTPROCESS\n    #define GAMMA (1.0/2.2)\n    #define CONTRAST 1.2\n    #define BRIGHTNESS 0.45\n    #define DESATURATION 1.125\n    #define TINT_COLOR vec3(1.012, 0.988, 1.0)\n    #define VIGNETING_POWER 0.33\n\t#define GRAIN_STRENGTH 16.0\n#endif","name":"Common","description":"","type":"common"}]}