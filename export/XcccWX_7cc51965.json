{"ver":"0.1","info":{"id":"XcccWX","date":"1731262330","viewed":92,"name":"Journal de rÃªves","username":"Docteur_Raton","description":"Based on https://www.shadertoy.com/view/WtjyzR","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["fractal","rainbow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(th) mat2(cos(th), -sin(th), sin(th), cos(th))\n#define dot2(p) dot(p, p)\n\nvec3 s = vec3(0., 1., -1.);\n\n// Reference : https://www.shadertoy.com/view/MsjfDK\nvec3 generateFractal(vec3 p)\n{\n    for (int i = 0; i < 100; ++i)\n    {\n        p.xzy = abs(p / dot2(p) - vec3(.99, 1., 0.));\n    }\n    \n    return p;\n}\n\nvec3 generateBackground(vec2 uv)\n{\n    const float numLayers = 15.;\n    vec3 c = s.xxx;\n    for (float i = 0.; i < numLayers; ++i)\n    {\n        float repeat = 50.;\n        float offset = mod(iTime + i * repeat / numLayers, repeat);\n        float parallax = .1 * (.1 + .1 * i) * offset;\n        vec2 q = uv + parallax * s.yx;\n        vec3 p = vec3(.5 * q + i * vec2(.5, .1), .005 * (3. * sin(1. * iTime + .1 * i)) - .1 * i);\n        p = generateFractal(p);\n        p *= smoothstep(0., 100., offset * (repeat - offset));\n        c += clamp(p, 0., 1.);\n    }\n    c /= numLayers;\n    c = pow(c * 1.2, vec3(1. / 1.4));\n\n    return c;\n}\n\nvec2 generateCircleCenter(vec2 id)\n{\n    return vec2(id.x + .05,\n        .04 * sin(12. * id.x + 1.891273 * id.y)\n        + .02 * sin(10. * id.x + 8.1298712 * id.y))\n        + .01 * sin(7. * id.x + 2.12388273 * id.y);\n}\n\nfloat circle(vec2 uv, vec2 id)\n{\n    float d = length(uv - generateCircleCenter(id));\n\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 background = generateBackground(uv);\n    float b = 0.;\n    float numClouds = 7.;\n    for (float i = 0.; i < numClouds; ++i)\n    {\n        vec2 offset = vec2(0., .15 * i + .1 + .03 * sin(2.2141 * i));\n        vec2 p = uv + offset + (.04 * i + .2) * iTime * s.yx;\n        vec2 id = vec2(p.x - mod(p.x, .1), 0.);\n        float d = min(circle(p, id - .1 * s.yx + offset),\n                    min(circle(p, id + offset),\n                        circle(p, id + .1 * s.yx + offset)));\n        b += smoothstep(.005, 0., abs(d - 0.065)) * step(generateCircleCenter(id + offset).y, p.y);\n    }\n    background += b * s.yyy;\n    fragColor = vec4(background, 1.);\n}\n\n\n// Initial version golfed in 712 chars by FabriceNeyret2:\n/*\n#define S(x,y)  sin( dot( I, vec2(x,y)) )\n\nvec2 C(vec2 I)  // generateCircleCenter\n{\n    return vec2( I.x + .05 ,\n                  .04 * S(12,1.891273)\n                + .02 * S(10,8.1298712) )\n                + .01 * S(7,2.12388273);\n}\n\n#define circle(k) length( P - C(I+k*s) )\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2  R = iResolution.xy, s = vec2(1,0), P,I,\n          U = ( u+u - R ) / R.y;  \n    float n = 15. , T = 50., d,i;  // c = generateBackground   \n    for ( O *= i ; i < n; ++i)\n    {\n        d = mod(iTime + i/n * T, T);\n        vec3 p = vec3( ( U + .01*(1.+i)*d*s )/2. + i*vec2(.5,.1), \n                      .015 * sin(iTime + .1*i) - .1*i\n                     );     \n        for (int i; i++ < 100; ) // p = generateFractal\n            p.xzy = abs( p / dot(p,p) - vec3(.99,1,0) );    \n\n        O.rgb += min( p * smoothstep(0., 1e2, d* (T-d)) , 1.);\n    }\n    O = pow(O/n * 1.2, vec4(.7));\n\n    for (float b,i; i < 7.; ++i )\n        d = .15 * i + .1 + .03 * sin(2.2141 * i),\n        P = U + vec2( (.04 * i + .2) * iTime , d ),\n        I = vec2( (P - mod(P,.1)).x , d ),\n        d = min(circle(-.1), min(circle(0.), circle(.1) )),\n        O += step(d, .07) * step(.06, d) * step(C(I).y, P.y);\n}\n*/\n","name":"Image","description":"","type":"image"}]}