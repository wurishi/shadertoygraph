{"ver":"0.1","info":{"id":"lsG3zK","date":"1455303206","viewed":1788,"name":"LBM 3","username":"ndel","description":"Alternative lattice Boltzmann implementation for shallow water.","likes":41,"published":1,"flags":32,"usePreview":0,"tags":["lbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//fancy function to compute a color from the velocity\nvec4 computeColor(float normal_value)\n{\n    vec3 color;\n    if(normal_value<0.0) normal_value = 0.0;\n    if(normal_value>1.0) normal_value = 1.0;\n    float v1 = 1.0/7.0;\n    float v2 = 2.0/7.0;\n    float v3 = 3.0/7.0;\n    float v4 = 4.0/7.0;\n    float v5 = 5.0/7.0;\n    float v6 = 6.0/7.0;\n    //compute color\n    if(normal_value<v1)\n    {\n      float c = normal_value/v1;\n      color.x = 70.*(1.-c);\n      color.y = 70.*(1.-c);\n      color.z = 219.*(1.-c) + 91.*c;\n    }\n    else if(normal_value<v2)\n    {\n      float c = (normal_value-v1)/(v2-v1);\n      color.x = 0.;\n      color.y = 255.*c;\n      color.z = 91.*(1.-c) + 255.*c;\n    }\n    else if(normal_value<v3)\n    {\n      float c = (normal_value-v2)/(v3-v2);\n      color.x =  0.*c;\n      color.y = 255.*(1.-c) + 128.*c;\n      color.z = 255.*(1.-c) + 0.*c;\n    }\n    else if(normal_value<v4)\n    {\n      float c = (normal_value-v3)/(v4-v3);\n      color.x = 255.*c;\n      color.y = 128.*(1.-c) + 255.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v5)\n    {\n      float c = (normal_value-v4)/(v5-v4);\n      color.x = 255.*(1.-c) + 255.*c;\n      color.y = 255.*(1.-c) + 96.*c;\n      color.z = 0.;\n    }\n    else if(normal_value<v6)\n    {\n      float c = (normal_value-v5)/(v6-v5);\n      color.x = 255.*(1.-c) + 107.*c;\n      color.y = 96.*(1.-c);\n      color.z = 0.;\n    }\n    else\n    {\n      float c = (normal_value-v6)/(1.-v6);\n      color.x = 107.*(1.-c) + 223.*c;\n      color.y = 77.*c;\n      color.z = 77.*c;\n    }\n    return vec4(color.r/255.0,color.g/255.0,color.b/255.0,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //only one pixel out of 4 stores the moments\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    vec3 m = texture(iChannel0, (vec2(2*ix+1,2*iy+1)+0.5)/iResolution.xy).xyz;\n    float rho = m.x;\n    float vx  = m.y;\n    float vy  = m.z;\n    //float U = sqrt(vx*vx+vy*vy);\n    fragColor = computeColor((rho-1.0)/0.1);\n    //fragColor = vec4((rho-1.0)/0.1);\n    //fragColor = texture(iChannel0, 0.5*fragCoord.xy/iResolution.xy).xyzw;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//map distribution functions to texture coordinates\n//4 texels are used to store the 9 distribution functions in one cell\n#define f0(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).r;\n#define f1(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).g;\n#define f2(x,y) texture(iChannel0, (vec2(2*x,2*y)+0.5)/iResolution.xy).b;\n#define f3(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).r;\n#define f4(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).g;\n#define f5(x,y) texture(iChannel0, (vec2(2*x+1,2*y)+0.5)/iResolution.xy).b;\n#define f6(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).r;\n#define f7(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).g;\n#define f8(x,y) texture(iChannel0, (vec2(2*x,2*y+1)+0.5)/iResolution.xy).b;\n\n#define G 0.01\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //relaxation time\n    float w = 1.95;\n    //fragColor=texture(iChannel0, fragCoord/iResolution.xy);\n    int LatSizeX = int(iResolution.x/2.0);\n    int LatSizeY = int(iResolution.y/2.0);\n    //int LatSizeX = 200;\n    //int LatSizeY = 200;\n    //4 texels per voxel\n    //all 4 pixels do the same computations\n    int ix = int(floor(fragCoord.x/2.0));\n    int iy = int(floor(fragCoord.y/2.0));\n    if( ix >= LatSizeX || iy >= LatSizeY )\n    {\n        return;\n    }\n    int itx = int(fragCoord.x) - 2*ix;\n    int ity = int(fragCoord.y) - 2*iy;\n    float f0,f1,f2,f3,f4,f5,f6,f7,f8; //distribution functions\n    float rho, vx, vy; //moments\n    f0 = f0(ix,iy); //if 0, reinitialise\n    if( (iFrame==0) || (f0==0.0) ) //initialisation\n    {\n        rho = 1.0;\n        vx = vy = 0.0;\n        //add a small disk near the entrance\n      //  if( distance(vec2(LatSizeX/2,LatSizeY/2),vec2(ix,iy)) < 10.0 )\n      //      rho = 1.1;\n        float sq_term = (vx*vx+vy*vy);\n        f0 = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        f1 = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        f2 = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        f3 = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        f4 = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        f5 = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        f6 = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        f7 = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        f8 = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n    }\n    else //normal time-step\n    {\n        //=== STREAMING STEP (PERIODIC) =======================\n        int xplus  = ((ix==LatSizeX-1) ? (0) : (ix+1));\n        int xminus = ((ix==0) ? (LatSizeX-1) : (ix-1));\n        int yplus  = ((iy==LatSizeY-1) ? (0) : (iy+1));\n        int yminus = ((iy==0) ? (LatSizeY-1) : (iy-1));\n        //f0 = f0( ix    ,iy    );\n        f1 = f1( xminus,iy    );\n        f2 = f2( xplus ,iy    );\n        f3 = f3( ix    ,yminus);\n        f4 = f4( ix    ,yplus );\n        f5 = f5( xminus,yminus);\n        f6 = f6( xplus ,yplus );\n        f7 = f7( xplus ,yminus);\n        f8 = f8( xminus,yplus );\n\n        //=== COMPUTE MOMENTS =================================\n        //density\n        rho = f0+f1+f2+f3+f4+f5+f6+f7+f8;\n        //velocity\n        vx = 1./rho*(f1-f2+f5-f6-f7+f8);\n        vy = 1./rho*(f3-f4+f5-f6+f7-f8);\n        //velocity cap for stability\n        float norm = sqrt(vx*vx+vy*vy);\n        if(norm>0.2)\n        {\n            vx *= 0.2/norm;\n            vy *= 0.2/norm;\n        }\n       \n        //enforced motion\n        if( distance(vec2(5.0+10.0*iTime,float(LatSizeY/2)+10.0*sin(iTime/3.0)),vec2(ix,iy)) < 4.0)\n        {\n            rho = 1.1;\n            w = 1.0;\n        }\n        //mouse motion\n        if( iMouse.w>0.01 && distance(iMouse.xy/2.0,vec2(ix,iy)) < 4.0)\n        {\n            rho = 1.1;\n            w = 1.0;\n        }\n\n        float sq_term = (vx*vx+vy*vy);\n        float f0eq = rho*(1.-10./12.*G*rho-2./3.*sq_term);\n        float f1eq = rho*(1./6. *G*rho+1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f2eq = rho*(1./6. *G*rho-1./3. *vx     +vx*vx/2.             -sq_term/6.);\n        float f3eq = rho*(1./6. *G*rho+1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f4eq = rho*(1./6. *G*rho-1./3. *vy     +vy*vy/2.             -sq_term/6.);\n        float f5eq = rho*(1./24.*G*rho+1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f6eq = rho*(1./24.*G*rho-1./12.*(vx+vy)+1./8.*(vx+vy)*(vx+vy)-sq_term/24.);\n        float f7eq = rho*(1./24.*G*rho-1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        float f8eq = rho*(1./24.*G*rho+1./12.*(vx-vy)+1./8.*(vx-vy)*(vx-vy)-sq_term/24.);\n        //=== RELAX TOWARD EQUILIBRIUM ========================\n        f0 = (1.-w) * f0 + w * f0eq;\n        f1 = (1.-w) * f1 + w * f1eq;\n        f2 = (1.-w) * f2 + w * f2eq;\n        f3 = (1.-w) * f3 + w * f3eq;\n        f4 = (1.-w) * f4 + w * f4eq;\n        f5 = (1.-w) * f5 + w * f5eq;\n        f6 = (1.-w) * f6 + w * f6eq;\n        f7 = (1.-w) * f7 + w * f7eq;\n        f8 = (1.-w) * f8 + w * f8eq;\n    }\n    if(itx==0&&ity==0)//stores f0,f1,f2\n        fragColor.rgb = vec3(f0,f1,f2);\n        //fragColor.rgb = vec3(1.0,0.0,0.0);\n    else if(itx==1&&ity==0)//stores f3,f4,f5\n        fragColor.rgb = vec3(f3,f4,f5);\n        //fragColor.rgb = vec3(0.0,1.0,0.0);\n    else if(itx==0&&ity==1)//stores f6,f7,f8\n        fragColor.rgb = vec3(f6,f7,f8);\n        //fragColor.rgb = vec3(0.0,0.0,1.0);\n    else //stores rho,vx,vy\n        fragColor.rgb = vec3(rho,vx,vy);\n\n}","name":"Buf A","description":"","type":"buffer"}]}