{"ver":"0.1","info":{"id":"clSBWw","date":"1694847959","viewed":330,"name":"RayMarching test 123","username":"sedenion","description":"ray marching tutorial","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEP 255\n#define MIN_DIST 0.01\n#define MAX_DIST 100.\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPyramid( vec3 p, float h )\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdPlane( vec3 p, float h )\n{\n  return p.y-h;\n}  \n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdf(vec3 p)\n{\n    float d = min(sdSphere(p,1.),sdPlane(p,-1.));\n    d = min(d,sdRoundBox(p-vec3(4,0,0),vec3(1,1,1),0.1));\n    d = min(d,sdPyramid(p-vec3(-4,-1,0),3.));\n    return d;\n}\n\nfloat AmbientOcclusion(vec3 p, vec3 normal, float step_dist, float step_nbr)\n{\n    float occlusion = 1.f;\n    while(step_nbr > 0.0)\n    {\n\tocclusion -= pow(step_nbr * step_dist - (sdf( p + normal * step_nbr * step_dist)),2.) / step_nbr;\n\tstep_nbr--;\n    }\n\n    return occlusion;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * sdf(p + e.xyy) +\n      e.yyx * sdf(p + e.yyx) +\n      e.yxy * sdf(p + e.yxy) +\n      e.xxx * sdf(p + e.xxx));\n}\n\nfloat rayMarch(vec3 origin, vec3 direction) {\n\tfloat totalDistance = 0.0;\n\tfor (int i = 0; i < MAX_STEP; i++)\n    {\n\t\tvec3 p = origin + totalDistance * direction;\n\t\tfloat distance = sdf(p);\n\t\ttotalDistance += distance;\n\t\tif (abs(distance) < MIN_DIST || totalDistance > MAX_DIST) break;\n\t}\n\treturn totalDistance;\n}\n\nfloat softShadow(vec3 ro,vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = sdf(ro + t*rd);\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    // https://iquilezles.org/articles/rmshadows/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord/iResolution.xy)-1.;\n    uv.x*=iResolution.x/iResolution.y; // pixel -1 à 1\n    vec2 mouse = iMouse.xy / iResolution.xy - 0.5;\n    \n    vec3 lightPosition = vec3(5., 5., 1.0);\n    vec3 color = vec3(0);\n    \n    vec3 ro = vec3(0, 0, -3); // Rayon origin\n    vec3 rd = normalize(vec3(uv, 1)); // Rayon direction\n    rd *=  rotateX(mouse.y*5.)*rotateY(-mouse.x*5.);\n    \n    float dist = rayMarch(ro,rd); // Ray march\n    \n    if(dist > MAX_DIST){\n        color = vec3(0); // Couleur arrière plan\n    }\n    else{\n        vec3 p = ro + dist * rd; // position objet touché\n        vec3 normal = calcNormal(p);\n        vec3 lightDirection = normalize(lightPosition - p);\n        \n        float ambiant = 0.1;\n        float diffuse = max(dot(normal, lightDirection),0.)*0.5;\n        float specular = pow(max(dot(reflect(-lightDirection,normal),normalize(ro-p)),0.), 50.);\n    \n        float light = ambiant+diffuse+specular;\n        \n        float ambOccl = clamp(pow(AmbientOcclusion(p,normal,0.015,20.),32.),0.1,1.);\n        float sh = clamp(softShadow(p, lightDirection, 0.02, 20.5, 0.5), 0.1, 1.);\n        \n        color = vec3(1)*light*ambOccl*sh;\n    }\n    color = pow(color, vec3(1.0/2.2)); // Gamma correction\n    \n    fragColor = vec4(color,1.0); // couleur finale\n}","name":"Image","description":"","type":"image"}]}