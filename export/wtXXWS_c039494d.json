{"ver":"0.1","info":{"id":"wtXXWS","date":"1564081902","viewed":247,"name":"raySoftShadow","username":"Taron","description":"testing soft shadows, anti aliasing and id based shading...\n...so much I still have to learn again. Awesome! ^^\nadded a bit of noise to the tiles...getting slow.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raycast","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 40.\n#define SURF_DIST .01\n\n#define AA 2\n\nfloat jumpY;\nfloat time; \n\nfloat noise(vec2 nv)\n{\n    vec2 qv = nv.xy*85.;\n    vec2 fv = fract(qv);\n    qv = (qv-fv);\n    float dta = fract(sin(dot(qv.xy \t\t\t  ,vec2(1369.34,3369.19))*2.36) * 43758.5453);\n    float dtb = fract(sin(dot(qv.xy+vec2(1.0,0.0) ,vec2(1369.34,3369.19))*2.36) * 43758.5453);\n    float dtc = fract(sin(dot(qv.xy+vec2(0.0,1.0) ,vec2(1369.34,3369.19))*2.36) * 43758.5453);\n    float dtd = fract(sin(dot(qv.xy+vec2(1.0,1.0) ,vec2(1369.34,3369.19))*2.36) * 43758.5453);\n    float value = mix(mix(dta,dtb,fv.x),mix(dtc,dtd,fv.x),fv.y);\n    return value;\n}\n\nvec2 getDist(vec3 p)\n{\n    vec4 s = vec4(0., jumpY, 6., 1.);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float id = 0.;\n    \n    vec3 rotx = vec3(sin(time), 0., cos(time));\n    vec3 rotz = vec3(-rotx.z, 0., rotx.x);\n    vec3 roty = cross(rotz, rotx);\n    vec3 qr = p-(vec3(0.,s.y,6.));\n    qr = vec3(qr.x*rotx.x + qr.y*roty.x + qr.z*rotz.x,\n              qr.x*rotx.y + qr.y*roty.y + qr.z*rotz.y,\n              qr.x*rotx.z + qr.y*roty.z + qr.z*rotz.z);\n    vec3 bs = vec3(0.6);\n    vec3 q = abs(qr)-bs;\n    float boxDist = min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n    \n    //there has to be a nicer way of making a grid with bevel...(shame!)\n    float planeDist = p.y;\n    float panel = 0.;\n    float fade = 2.-min(length(p),8.)/16.;\n    if(fade>0.)\n    {\t\n        panel = max(0.9,max(abs(-1.+2.*mod(p.x,.5)),abs(-1.+2.*mod(p.z,.5))))-.9;\n    \tpanel = panel*panel+.0025*noise(p.xz);\n     \tplaneDist = mix(p.y,p.y+.95,panel*fade);\n    }\n    \n    float item = mix(sphereDist,boxDist,0.5+.5*sin(time*0.33));\n    float d = min(item, planeDist);\n    if(d<planeDist)\n        id = 1.;\n    return vec2(d, id);\n}\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float dO =0.;\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n\t\tvec3 p = ro + rd*dO;\n        float dS = getDist(p).x;\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n            break;\n        \n    }\n    return dO;\n}\nfloat shadowMarch(vec3 ro, vec3 rd)\n{\n    float dO =0.;\n    float res = 1.;\n    float dS =0.;\n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        if(dO>MAX_DIST)\n            break;\n\t\tvec3 p = ro + rd*dO;\n        dS = getDist(p).x;\n        dO += dS;\n        if(dS<SURF_DIST) \n            return 0.;\n        res = min(res, 8.*dS/dO);\n    }\n         \n    return res;\n}\nvec4 getNormal(vec3 p)\n{\n    vec2 item= getDist(p);\n    float d = item.x;\n    \n    vec2 e = vec2(.01, 0.);\n    vec3 n = d - vec3(\tgetDist(p-e.xyy).x,\n                 \t\tgetDist(p-e.yxy).x,\n                 \t\tgetDist(p-e.yyx).x);\n    return vec4(normalize(n), item.y);\n}\nvec3 getLight(vec3 lightPos, vec3 p, vec3 rd)\n{\n    lightPos.xz += vec2(sin(time)*2., 1.+cos(time))*4.;\n    vec3 l = normalize(lightPos-p);\n    vec4 item = getNormal(p);\n    vec3 n = item.xyz;\n    \n    float dif = dot(n,l);\n    float sub = max(0.,.5+.5*dif);\n    dif = max(0.,dif);\n    \n    float d = shadowMarch(p+n*SURF_DIST*2., l);\n    d = sqrt(d);\n    dif *=d;\n    vec3 col = vec3(dif)+(vec3(.6,.1,.0)-vec3(dif))*(d*.1);//little attenuation is pretty!\n    if(item.w==1.)\n    {\n        \n        col*=vec3(0.71, 0.9, 0.92);\n        col += pow(sub,2.)*vec3(0.95,0.61,0.38);\n    }\n    else\n    {    \n        vec2 l = mod(p.xz,.5);\n        col*=mix(vec3(0.84, 0.88, 0.89),vec3(0.24, 0.28, 0.19),l.x>.46 || l.y>.46?1.0:0.);\n    }\n    if(dif>0.)\n    {\n        float spec = pow( max(0.,dot(l, reflect(rd, n))), 100.);\n        col +=vec3(.45*spec);\n    }\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float mTime = iTime+ mouse.x*8.;\n    \n    vec3 all = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        \n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = 0.5*(-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n    \t\n    \tuv *=1.+.2*pow(dot(uv,uv),2.);      \n        float ad = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        time = mTime - 0.5*(1.0/30.0)*(float(m*AA+n)+ad)/float(AA*AA-1);\n#else    \n        vec2 uv = 0.5*(-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n      \tuv *=1.+.2*pow(dot(uv,uv),2.);\n      \ttime = mTime;\n#endif   \n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.,1.+mouse.y*2.7,0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y-.2,1.));\n    jumpY = abs(-1.+fract(time*1.1)*2.);\n    jumpY = 2.5-2.*jumpY*jumpY; \n        \n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd*d;\n    vec3 dif = getLight(vec3(0., 5., 1.), p, rd);\n    col = mix(dif,vec3(.2,.25,.29),pow(min(1.,d*.025),.5));\n\tall +=col;        \n        \n#if AA>1\n    }\n    all /= float(AA*AA);\n#endif        \n    fragColor = vec4(all,1.0);\n}","name":"Image","description":"","type":"image"}]}