{"ver":"0.1","info":{"id":"WdBcRG","date":"1586800030","viewed":113,"name":"Pulse - generate 1d pulse","username":"mikelsv","description":"Generate 1d pulse from formula.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pulse","oscilloscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pulse - Generate 1d pulse from formula.\n// Research for Maticals http://maticals.senin.world/\n\n// You can see how work any functions on 1d dimensional.\n// Green - sin & sin box\n// Blue - cos & cos box\n// Orange - angle\n// Red - any user function\n\n// Next project: Pulse 2D - generate pulse in 2d: https://www.shadertoy.com/view/3dSczy\n// Next project: Pulse 3D - generate pulse in 3d.\n\n// Created: 2020-04-13\n//\n// Update: 2020-04-14.\n// [!] Refactoring code.\n// [+] box_sin & box_cos - sin and cos for box.\n// [+] Angle function.\n\nconst float PULSE_TIME = 2.000; // Pulse one time = PI / 2\nconst float PULSE_TIMES = 10. * PULSE_TIME; // Pulse all times\nconst float PULSE_STEP = PULSE_TIMES / PULSE_TIME; // Pulse step\n\n#define RGBC_GREEN vec4(19. / 255., 229. / 225., 19. / 225., 1.)\n#define RGBC_BLUE vec4(47. / 255., 206. / 225., 208. / 225., 1.)\n#define RGBC_RED vec4(222. / 255., 52. / 225., 81. / 225., 1.)\n#define RGBC_PURPLE vec4(224. / 255., 15. / 225., 222. / 225., 1.)\n#define RGBC_YELLOW vec4(148. / 255., 134. / 225., 78. / 225., 1.)\n#define RGBC_ORANGE vec4(255. / 255., 165. / 225., 0. / 225., 1.)\n#define PI 3.141592653589793\n\nfloat box_sin(float angle);\nfloat box_cos(float angle);\nfloat ms_angle(float angle);\n\n// Extensions.  <-------------- Comment / uncomment this defines for hide function -----\n#define PULSE_FUNC_SIN\t\t0\t\t// Sin\n//#define PULSE_FUNC_COS\t\t1\t\t// Cos\n//#define PULSE_FUNC_BSIN\t\t2\t\t// Box Sin\n#define PULSE_FUNC_BCOS\t\t3\t\t// Box Cos\n#define PULSE_FUNC_ANGLE\t4\t\t// Angle\n#define PULSE_FUNC_ANY\t\t99\t\t// Any for test\n\nfloat pulseFuncSin(float val){\n    return sin(val);\n}\n\nfloat pulseFuncCos(float val){\n    return cos(val);\n}\n\nfloat pulseFuncBoxSin(float val){\n    return box_sin(val);\n}\n\nfloat pulseFuncBoxCos(float val){\n    return box_cos(val);\n}\n\nfloat pulseFuncAngle(float val){\n    return ms_angle(val);\n}\n\nfloat pulseFuncAny(float val){ // <------- Use for test\n    //return cos(val) * sin(val);\n    //return cos(val) * cos(val) - .5;    \n    //return cos(val) * ms_angle(val);\n    return sin(val) * ms_angle(val) - .5;\n    return sin(val) * sin(val) - .5; \n}\n\n\n// Maticals core functions\nfloat box_sin(float angle){\n\tif(angle < 0.)\n    \tangle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n    \n\tif(angle <= PI * 0.75)\n\t\treturn min(angle / (PI * 0.25), 1.);\n \n\tif(angle <= PI * 1.75)\n\t\treturn max(-1., 1. - (angle - PI * 0.75) / (PI * 0.25));\n    \n    if(angle <= PI * 2.)\n\t\treturn -1. + (angle - PI * 1.75) / (PI * 0.25);\n\n\treturn 0.;\n}\n\nfloat box_cos(float angle){\n    if(angle < 0.)\n        angle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n\n    if(angle <= PI * 0.25)\n        return 1.;\n    if(angle <= PI * 0.75)\n        return 1. - (angle - PI * 0.25) / (PI * 0.25);\n    if(angle <= PI * 1.25)\n        return -1.;\n    if(angle <= PI * 1.75)\n        return -1. + (angle - (PI * 1.25)) / (PI * 0.25);\n    if(angle <= PI * 2.)\n        return 1.;\n\n    return 0.;\n}\n\nfloat ms_angle(float angle){\n    if(angle < 0.)\n        angle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n\n    if(angle <= PI * 0.5)\n\t\treturn angle / (PI * 0.5);\n    \n\tif(angle <= PI * 1.5)\n\t\treturn 1. - (angle - PI * 0.5) / (PI * 0.5);\n    \n    if(angle <= PI * 2.)\n\t\treturn -1. + (angle - PI * 1.5) / (PI * 0.5);\n\n    return 0.;\n}\n\n// Call extension\n#define PULSE_FUNC_CALL(call)\t\\\ny = call(x * PI * PULSE_STEP);\t\\\npy = call(coord.x * PI * PULSE_STEP);\n\n// Not work :'(\n#define PULSE_FUNC_CALL_D(def, call) \\\n#ifdef def\t\\\n\tcase def: PULSE_FUNC_CALL(call); break; \\\n#endif\n\n\n\n// Draw: pulse extension\nvec4 pulseDrawExt(vec2 coord, vec2 pixel, float time, int type, vec4 color){\n    float x = time / PULSE_TIMES, y;// = PULSE_FUNC(x * PI * PULSE_STEP);\n    float px = coord.x, py; // = PULSE_FUNC(coord.x * PI * PULSE_STEP);\n    \n    switch(type){\n#ifdef PULSE_FUNC_SIN\n        case PULSE_FUNC_SIN: PULSE_FUNC_CALL(pulseFuncSin); break;\n#endif\n        \n#ifdef PULSE_FUNC_COS       \n        case PULSE_FUNC_COS: PULSE_FUNC_CALL(pulseFuncCos); break;\n#endif\n        \n#ifdef PULSE_FUNC_BSIN\n        case PULSE_FUNC_BSIN: PULSE_FUNC_CALL(pulseFuncBoxSin); break;\n#endif\n        \n#ifdef PULSE_FUNC_BCOS       \n        case PULSE_FUNC_BCOS: PULSE_FUNC_CALL(pulseFuncBoxCos); break;\n#endif\n        \n#ifdef PULSE_FUNC_ANGLE\n        case PULSE_FUNC_ANGLE: PULSE_FUNC_CALL(pulseFuncAngle); break;\n#endif\n        \n#ifdef PULSE_FUNC_ANY\n        case PULSE_FUNC_ANY: PULSE_FUNC_CALL(pulseFuncAny); break;      \n#endif        \n\t\t// <-------------------- Add you function\n    }\n    \n    // Point shadow\n    //float px = coord.x, py = PULSE_FUNC(coord.x * PI * PULSE_STEP);\n    if(abs(py - coord.y * 2. + 1.) < pixel.y * 5.)\n        return color;\n    \n    // Point as circle\n    if(sqrt(pow(abs(y - coord.y * 2. + 1.) / pixel.y * 1., 2.)\n       + pow(abs(x - coord.x) / pixel.x * 2., 2.)) < 20.\n      )\n        return color;    \n    \n    return vec4(0, 0, 0, 1.0);    \n    \n    // Point as cube // deleted\n    //float x = time / PULSE_TIMES, y = PULSE_FUNC(x * PI * PULSE_STEP);\n    if(abs(y - coord.y * 2. + 1.) < pixel.y * 20.\n       &&\n       abs(x - coord.x) < pixel.x * 10.\n      )\n        return color;\n}\n\n// Draw interface: coord, pixel size, time\nvec4 pulseDraw(vec2 coord, vec2 pixel, float time){\n    time = mod(time, PULSE_TIMES);\n    \n    // Interface monitor: all yellow lines\n    if((mod(coord.x, 1. / PULSE_STEP / 5.) <= pixel.x\n       || mod(coord.x, 1. / PULSE_STEP) <= pixel.x * 2.\n       || mod(coord.x, .5) <= pixel.x * 8.)\n      &&\n       (mod(coord.y, 1. / PULSE_STEP / 5.) <= pixel.y\n       || mod(coord.y, 1. / PULSE_STEP) <= pixel.y * 2.\n       || mod(coord.y, .5) <= pixel.y * 8.\n      )      \n\t) return vec4(1, 1, 0, 1.0);\n    \n    // Draw pulse\n    vec4 r = vec4(0, 0, 0, 1.0);\n \n#ifdef PULSE_FUNC_SIN\n    if(r == vec4(0, 0, 0, 1.0)) r = pulseDrawExt(coord, pixel, time, PULSE_FUNC_SIN, RGBC_GREEN);\n#endif\n\n#ifdef PULSE_FUNC_COS\n    if(r == vec4(0, 0, 0, 1.0)) r = pulseDrawExt(coord, pixel, time, PULSE_FUNC_COS, RGBC_BLUE);\n#endif\n  \n#ifdef PULSE_FUNC_BSIN\n    if(r == vec4(0, 0, 0, 1.0)) r = pulseDrawExt(coord, pixel, time, PULSE_FUNC_BSIN, RGBC_GREEN);\n#endif\n\n#ifdef PULSE_FUNC_BCOS\n    if(r == vec4(0, 0, 0, 1.0)) r = pulseDrawExt(coord, pixel, time, PULSE_FUNC_BCOS, RGBC_BLUE);\n#endif\n    \n#ifdef PULSE_FUNC_ANGLE\n    if(r == vec4(0, 0, 0, 1.0)) r = pulseDrawExt(coord, pixel, time, PULSE_FUNC_ANGLE, RGBC_ORANGE);\n#endif\n    \n#ifdef PULSE_FUNC_ANY\n    if(r == vec4(0, 0, 0, 1.0)) r = pulseDrawExt(coord, pixel, time, PULSE_FUNC_ANY, RGBC_RED);\n#endif\n\n   return r;\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    vec2 coord = fragCoord/iResolution.xy;\n    \n    if(coord.y < .5){\n        fragColor = vec4(0, 0, 0, 1.0);\n        fragColor = pulseDraw(vec2(coord.x, coord.y * 2.),\n        \tvec2(1. / iResolution.x, 1. / iResolution.y * 2.), iTime);\n        return ;\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}