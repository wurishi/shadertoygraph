{"ver":"0.1","info":{"id":"4XXfRS","date":"1728502806","viewed":12,"name":"Flying blobs","username":"cesio","description":"Raymarching - a scene with 5 spheres with changing radius and position.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define a 0.021\n#define PI 3.1415\n\n\n\n\n\n    float catenoid(vec3 p) {\n        float x = a * cosh(p.y/PI / a) * cos(p.x/PI);\n        float y = a * cosh(p.y/PI / a) * sin(p.x/PI);\n        float z = p.y;\n        \n        vec3 catenoid = vec3(x,y,z);\n        return length(p - catenoid);\n    }\n    \n// return a distance from point p and a sphere with center c and radius r\nfloat sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n    float raymarch(vec3 ro, vec3 rd) {\n        float t = 0.0;\n        for (int i = 0; i < 80; i++) {\n            vec3 p = ro + t * rd;\n            //vec3 c = catenoid(p.x, p.y);\n            //float d = length(p - c);\n/*\n            float d1 = sphere(p, vec3(-0. + cos(iTime) * 0.4, 0. + cos(iTime) * 0.5, 0.3 * cos(iTime) * 1.), 0.15 + cos(iTime) * 0.2);\n            float d2 = sphere(p, vec3(-0.4 + sin(iTime), 0.2 * sin(iTime), sin(iTime) * 1.1), 0.22 - cos(iTime) * 0.2); \n            float d3 = sphere(p, vec3(0.4 + sin(iTime), 0.2 * sin(iTime), cos(iTime) * 1.1), 0.12 + cos(iTime) * 0.2); \n            float d4 = sphere(p, vec3(+0.2 - cos(iTime) * 0.4, 0. + cos(iTime) *0.5, 0.3 * cos(iTime) * 1.), 0.15  + cos(iTime) * 0.2);\n*/\n            float d1 = sphere(p, vec3(-0. + cos(iTime) * 0.4, 0. + cos(iTime) * 0.5, 0.), 0.15 + cos(iTime) * 0.2);\n            float d2 = sphere(p, vec3(-0.4 + sin(iTime), 0.2 * sin(iTime), 0.), 0.22 - cos(iTime) * 0.2); \n            float d3 = sphere(p, vec3(0.4 + sin(iTime), 0.2 * sin(iTime), 0.), 0.12 + cos(iTime) * 0.2); \n            float d4 = sphere(p, vec3(+0.2 - cos(iTime) * 0.4, 0.,0.), 0.15  + cos(iTime) * 0.2);\n            float d5 = sphere(p, vec3(+0.2 - cos(iTime * 2.) * 0.2, -0.2 + sin(iTime) * 0.3, 0.), 0.15  + cos(iTime) * 0.2);\n\n            float d = min(min(min(min(d1, d2), d3), d4),d5);\n            \n            \n            //float d = catenoid(p);\n            \n            if (d < 0.01 || d > 10.) break;\n            t += d * 0.1;\n        }\n        return t;\n    }\n    \nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 1.0 - 0.5;  \n    uv.x *= iResolution.x / iResolution.y;  \n\n \n    vec3 ro = vec3(0., 0., 1.8);  \n    //vec3 rd = normalize(vec3(uv, -5.0));  \n\n\n    vec3 lookAt = vec3(0.0,0.0, -1.);\n    vec3 rd = camera(ro, lookAt) * normalize(vec3(uv, -1.));\n\n\n    float t = raymarch(ro, rd);\n    \n\n    vec3 color = vec3(0.0);\n    if (t < 10.0) {\n        color = vec3(0.3, 0.6, 0.9) * (1.0 - t / 12.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}