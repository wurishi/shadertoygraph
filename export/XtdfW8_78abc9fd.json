{"ver":"0.1","info":{"id":"XtdfW8","date":"1539416108","viewed":1178,"name":"clamp to border emulation","username":"kusma","description":"This is a prototype for emulation-code of clamp to border behavior on vulkan.\n\nMip-map support is a bit of a hack, because the border color should really be blended twice, once per miplevel  intead of lerping the size. But it's close enough, I guess.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["texture","clamping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Emulate GL_CLAMP and GL_CLAMP_TO_BORDER on top of GL_CLAMP_TO_EDGE\n *\n * sampler needs to have GL_TEXTURE_WRAP_S and/or GL_TEXTURE_WRAP_T set to\n * GL_CLAMP_TO_EDGE for the emulated dimensions for this to work as expected.\n */\n\nvec2 textureQueryLod(sampler2D sampler, vec2 P)\n{\n    vec2 pos = P * vec2(textureSize(sampler, 0)); // OpImageQuerySizeLod\n    vec2 ddx = dFdx(pos);\n    vec2 ddy = dFdy(pos);\n    float tmp = max(dot(ddx, ddx), dot(ddy, ddy));\n    float lambda = log2(tmp) * 0.5; // log2(x)/2 == log2(sqrt(x))\n    // HACK: there's really much more that should be going on here, but we need to know about the sampler-state to figure that bit out.\n    float lod = max(lambda, 0.0);\n    return vec2(lod);\n}\n\nvec4 textureBorderClamp(sampler2D sampler, vec2 uv, vec2 size, vec4 borderColor, bvec2 wrap)\n{\n#if 1\n    // mipmap\n    float lod = textureQueryLod(sampler, uv).y + 1.5 + cos(iTime); // OpImageQueryLod\n    ivec2 size0 = textureSize(sampler, int(floor(lod))); // OpImageQuerySizeLod\n    ivec2 size1 = textureSize(sampler, int(ceil(lod))); // OpImageQuerySizeLod\n    // this is a hack: we should interpolate the result of another interpolation instead\n    // see https://www.desmos.com/calculator/3aae3afks6\n    size = mix(vec2(size0), vec2(size1), fract(lod));\n    vec4 ret = textureLod(sampler, uv, lod); // OpImageSampleExplicitLod\n#else\n    // no mipmap\n    vec4 ret = texture(sampler, uv); // OpImageSampleImplicitLod\n#endif\n\n    vec2 limit = vec2(1.0, 0.5); // 0.5 for GL_CLAMP, 1.0 for GL_CLAMP_TO_BORDER\n    vec2 factors = clamp(0.5 + (abs(uv - 0.5) - 0.5) * vec2(size), vec2(0.0), limit);    \n    if (wrap.x)\n    \tret = mix(ret, borderColor, factors.x);\n    if (wrap.y)\n        ret = mix(ret, borderColor, factors.y);\n    return ret;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y) + 0.5;\n    uv *= 0.5;\n\n    vec4 borderColor = vec4(0.5 + 0.5 * cos(iTime), 0.5, 0.5 + 0.5 * sin(iTime), 1.0);\n    fragColor = textureBorderClamp(iChannel0, uv, iChannelResolution[0].xy, borderColor, bvec2(true, true));\n}","name":"Image","description":"","type":"image"}]}