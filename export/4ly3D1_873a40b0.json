{"ver":"0.1","info":{"id":"4ly3D1","date":"1474509951","viewed":504,"name":"Test Bounding Volume","username":"wachel","description":"test speed up by bounding volume","likes":27,"published":1,"flags":0,"usePreview":1,"tags":["boundingvolume","boundingbox","boundingsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n\n#define BOUNDING_VOLUME\t\t\t//turn on/off bounding_volume\n#define MAX_DETAIL_LEVEL 2\t\t//value in [0,1,2],2 will show all detail\n\nfloat smax(float a,float b,float k)\n{\t\n\tfloat h = clamp(0.5 + 0.5*(b - a) / (k + 1e-10), 0.0, 1.0);\n\th = h * h;\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat smin(float a, float b, float k)\n{\n\t\n\tfloat h = clamp(0.5 + 0.5*(b - a) / (k + 1e-10), 0.0, 1.0);\n\th = h * h;\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b * 0.5, 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b * 0.5;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(vec3 p, vec2 c)\n{\n\tvec2 p2d = vec2(length(p.xy),p.z);\n\treturn dot(p2d, c) > 0.0 ? dot(p2d, vec2(c.y, -c.x)) : length(p2d);\n}\n\nfloat sdCircle(vec3 p, float r)\n{\n\tvec2 q = vec2(length(p.xz) - r, p.y);\n\treturn length(q);\n}\n\nfloat sdHalf(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\t\n}\n\nfloat sdPlane(vec3 p, float h)\n{\n    return p.y - h;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x)? d1 : d2;\n}\n\nfloat opU(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\nfloat opS(float d1, float d2)\n{\n\treturn max(d1, -d2);\n}\n\nfloat opI(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\nfloat opBlend(float d1, float d2, float k)\n{\n\treturn smin(d1, d2, k);\n}\n\nfloat opSS(float d1, float d2, float k) //Smooth Substraction\n{\n\treturn smax(d1, -d2, k);\n}\n\nfloat opMix(float d1, float d2, float s)\n{\n\treturn mix(d1, d2, s);\n}\n\nvec3 opRot( vec4 q, vec3 v ){ \n\treturn v + 2.0*cross(cross(v, q.xyz ) + q.w*v, q.xyz);\n}\n\nvec3 opInvRot(in vec4 q,in vec3 v){\n\treturn opRot(vec4(q.x,q.y,q.z,q.w),v);\n}\n\n\n\n//scene start=========================\nvec2 model_floor(vec3 p){\n    p = (p - vec3(0.0,4.16,0.0));\n    float d = sdBox((p - vec3(0.38,-2.54,1.01)), vec3(6.07,0.1,8.0));\n    return vec2(d,2);\n}\n\nvec2 model_closet(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(2.32,4.3,2.3);\n    float dist = udBox(p - vec3(2.15,3.74,3.71), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(2.09,3.71,3.81)), vec3(2.0,4.0,2.0));\n    d = opI(d, sdHalf(p, vec4(-0.7071,0.0002,-0.7071,3.513452)));\n    d = opU(d, (sdBox(opInvRot(vec4(0.0,0.3827,0.0,0.92388),(p - vec3(1.61,3.844,3.33))), vec3(1.4,3.7,0.05)) - 0.02));\n    return vec2(d,8);\n}\n\nvec2 model_left_wall(vec3 p){\n    p = (p - vec3(-0.02,0.15,0.08));\n    float d = sdBox(p, vec3(0.33,5.0,8.0));\n    d = opSS(d, sdBox((p - vec3(0.1,-0.989,0.8)), vec3(0.5,3.2,1.5)), 0.05);\n    return vec2(d,3);\n}\n\nvec2 model_maindoor_main(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.3,3.8,1.73);\n    float dist = udBox(p - vec3(-0.31,-0.15,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.37,-0.24,0.0)), vec3(0.16,3.47,1.7)) - 0.02);\n    d = opSS(d, sdBox((p - vec3(-0.178,-0.389,0.0)), vec3(0.5,3.2,1.48)), 0.05);\n    d = opS(d, sdBox((p - vec3(-0.413,0.44,0.0)), vec3(0.2,1.2,1.1)));\n    return vec2(d,9);\n}\n\nvec2 model_maindoor_up(vec3 p){\n    p = (p - vec3(-0.33,0.48,0.0));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.26,1.36,1.34);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(-0.066,-0.026,0.0)), vec3(0.05,1.3,1.2));\n    d = opS(d, sdBox((p - vec3(-0.078,-0.037,0.0)), vec3(0.2,1.2,1.1)));\n    return vec2(d,9);\n}\n\nvec2 model_maindoor_glass(vec3 p){\n    p = (p - vec3(-0.49,0.44,0.0));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.2,1.27,1.16);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(0.007,0.0,0.0)), vec3(0.11,1.2,1.1));\n    return vec2(d,5);\n}\n\nvec2 model_maindoor_top(vec3 p){\n    p = (p - vec3(-0.272,1.485,0.0));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.26,0.22,2.09);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.086,-0.035,0.0)), vec3(0.25,0.1,1.8)) - 0.02);\n    d = opU(d, (sdBox((p - vec3(-0.056,0.039,0.0)), vec3(0.3,0.05,1.9)) - 0.02));\n    return vec2(d,9);\n}\n\nvec2 model_maindoor(vec3 p){\n    p = (p - vec3(0.2,0.25,0.05));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.42,3.52,2.0);\n    float dist = udBox(p - vec3(-0.27,-0.15,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_maindoor_main(p);\n    d = opU(d, model_maindoor_up(p));\n    d = opU(d, model_maindoor_glass(p));\n#if MAX_DETAIL_LEVEL >= 1\n    d = opU(d, model_maindoor_top(p));\n#endif\n    return d;\n}\n\nvec2 model_vase3(vec3 p){\n    p = (p - vec3(0.314,-0.53,1.28));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.36,1.57,0.36);\n    float dist = udBox(p - vec3(-0.2,-0.49,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdEllipsoid((p - vec3(-0.19,-0.52,0.0)), vec3(0.1,0.8,0.1));\n    d = opBlend(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.155,0.0))), vec2(0.314,0.9494)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,0.061,0.0))), vec2(0.4863,0.8738)), 0.05);\n    return vec2(d,6);\n}\n\nvec2 model_vase4(vec3 p){\n    p = (p - vec3(0.254,-0.53,-1.229));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.36,1.57,0.36);\n    float dist = udBox(p - vec3(-0.2,-0.49,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdEllipsoid((p - vec3(-0.19,-0.52,0.0)), vec3(0.1,0.8,0.1));\n    d = opBlend(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.155,0.0))), vec2(0.314,0.9494)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,0.061,0.0))), vec2(0.4863,0.8738)), 0.05);\n    return vec2(d,6);\n}\n\nvec2 model_left_door_vase(vec3 p){\n    p = (p - vec3(0.3,-0.7,0.83));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.6,4.03,3.17);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_maindoor(p);\n#if MAX_DETAIL_LEVEL >= 1\n    d = opU(d, model_vase3(p));\n#endif\n#if MAX_DETAIL_LEVEL >= 1\n    d = opU(d, model_vase4(p));\n#endif\n    return d;\n}\n\nvec2 model_lamp1(vec3 p){\n    p = (p - vec3(0.163,0.643,-0.929));\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.27;\n    float dist = length(p - vec3(0.0,0.0,0.0));\n    if(dist > boundingSphereRadius + 0.1){\n         return vec2(dist - boundingSphereRadius,0);\n    }\n#endif\n    float d = sdCappedCylinder(opInvRot(vec4(0.0,0.0,-0.7071,0.707107),p), vec2(0.23,0.015));\n    d = opU(d, sdSphere((p - vec3(0.026,0.0,0.0)), 0.2));\n    d = opSS(d, sdHalf(p, vec4(0.0,-1.0,0.0,0.05)), 0.01);\n    return vec2(d,12);\n}\n\nvec2 model_lamp2(vec3 p){\n    p = (p - vec3(0.163,0.643,2.69));\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.29;\n    float dist = length(p - vec3(0.0,0.0,0.0));\n    if(dist > boundingSphereRadius + 0.1){\n         return vec2(dist - boundingSphereRadius,0);\n    }\n#endif\n    float d = sdCappedCylinder(opInvRot(vec4(0.0,0.0,-0.7071,0.707107),p), vec2(0.23,0.015));\n    d = opU(d, sdSphere((p - vec3(0.026,0.0,0.0)), 0.2));\n    d = opSS(d, sdHalf(p, vec4(0.0,-1.0,0.0,0.05)), 0.01);\n    return vec2(d,12);\n}\n\nvec2 model_left(vec3 p){\n    p = (p - vec3(-2.5,4.01,0.83));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.0,5.81,8.0);\n    float dist = udBox(p - vec3(0.15,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_left_wall(p);\n    d = opU(d, model_left_door_vase(p));\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_lamp1(p));\n#endif\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_lamp2(p));\n#endif\n    return d;\n}\n\nvec2 model_front_wall(vec3 p){\n    p = (p - vec3(-0.14,-0.03,0.2));\n    float d = sdBox(p, vec3(5.5,5.0,0.2));\n    return vec2(d,3);\n}\n\nvec2 model_rack(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.0,0.13,0.2);\n    float dist = udBox(p - vec3(0.0,0.03,0.04), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox(p, vec3(1.0,0.0,0.0)) - 0.02);\n    d = opU(d, (sdBox((p - vec3(-0.414,0.0,0.098)), vec3(0.0,0.0,0.2)) - 0.01));\n    d = opU(d, (sdBox((p - vec3(0.432,0.0,0.107)), vec3(0.0,0.0,0.2)) - 0.01));\n    return vec2(d,4);\n}\n\nvec2 model_towel(vec3 p){\n    p = (p - vec3(0.012,0.0,0.107));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.66,1.0,0.24);\n    float dist = udBox(p - vec3(0.0,-0.45,-0.13), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox((p - vec3(0.0,-0.45,-0.105)), vec3(0.6,0.96,0.03)) - 0.03);\n    d = opSS(d, sdCone(opInvRot(vec4(0.7132,0.0115,0.0113,0.700798),(p - vec3(0.151,0.079,-0.18))), vec2(0.0872,0.9962)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(0.7209,0.0,0.0,0.693059),(p - vec3(-0.026,0.079,-0.18))), vec2(0.1219,0.9925)), 0.1);\n    return vec2(d,7);\n}\n\nvec2 model_towelrack(vec3 p){\n    p = (p - vec3(-1.27,-0.64,0.004));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.0,1.0,0.28);\n    float dist = udBox(p - vec3(0.0,-0.44,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_rack(p);\n    d = opU(d, model_towel(p));\n    return d;\n}\n\nvec2 model_vase1(vec3 p){\n    p = (p - vec3(1.46,0.33,2.309));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.36,1.57,0.36);\n    float dist = udBox(p - vec3(-0.2,-0.49,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdEllipsoid((p - vec3(-0.19,-0.52,0.0)), vec3(0.1,0.8,0.1));\n    d = opBlend(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.155,0.0))), vec2(0.314,0.9494)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,0.061,0.0))), vec2(0.4863,0.8738)), 0.05);\n    return vec2(d,6);\n}\n\nvec2 model_vase2(vec3 p){\n    p = (p - vec3(1.09,-0.022,2.309));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.3,1.4,0.3);\n    float dist = udBox(p - vec3(-0.2,-0.4,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdEllipsoid((p - vec3(-0.19,-0.52,0.0)), vec3(0.07,0.6,0.07));\n    d = opBlend(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.155,0.0))), vec2(0.314,0.9494)), 0.1);\n    d = opSS(d, sdCone(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.19,-0.003,0.0))), vec2(0.4863,0.8738)), 0.05);\n    return vec2(d,6);\n}\n\nvec2 model_vase_group(vec3 p){\n    p = (p - vec3(-0.97,-1.74,-2.42));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.94,1.55,0.61);\n    float dist = udBox(p - vec3(1.09,-0.13,2.27), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_vase1(p);\n    d = opU(d, model_vase2(p));\n    return d;\n}\n\nvec2 model_front(vec3 p){\n    p = (p - vec3(0.49,4.19,4.68));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(5.64,5.01,1.0);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_front_wall(p);\n#if MAX_DETAIL_LEVEL >= 1\n    d = opU(d, model_towelrack(p));\n#endif\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_vase_group(p));\n#endif\n    return d;\n}\n\nvec2 model_right_wall(vec3 p){\n    p = (p - vec3(0.52,0.0,0.07));\n    float d = sdBox(p, vec3(0.33,5.0,8.0));\n    return vec2(d,3);\n}\n\nfloat node_taptop(vec3 p){\n    p = p;\n    float d = (sdCircle(opInvRot(vec4(-0.7071,0.0,0.0,0.707107),(p - vec3(-0.092,0.352,0.0))), 0.12) - 0.03);\n    d = opS(d, (sdHalf(p, vec4(0.0,1.0,0.0,-0.319)) - 0.03));\n    return d;\n}\n\nfloat node_tap(vec3 p){\n    p = (p - vec3(0.133,0.851,-0.08));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.46,0.63,0.13);\n    float dist = udBox(p - vec3(-0.06,0.18,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return dist;\n    }\n#endif\n    float d = sdCappedCylinder((p - vec3(0.028,0.0,0.0)), vec2(0.05,0.05));\n    d = opU(d, sdCappedCylinder((p - vec3(0.028,0.202,0.0)), vec2(0.03,0.15)));\n    d = opU(d, node_taptop(p));\n    d = opU(d, sdCappedCylinder(opInvRot(vec4(0.0,0.0,-0.0448,0.998994),(p - vec3(-0.213,0.332,0.0))), vec2(0.04,0.025)));\n    return d;\n}\n\nfloat node_valve_left(vec3 p){\n    p = (p - vec3(0.133,0.851,0.152));\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.14;\n    float dist = length(p - vec3(0.0,0.05,0.0));\n    if(dist > boundingSphereRadius + 0.1){\n         return dist - boundingSphereRadius;\n    }\n#endif\n    float d = sdCappedCylinder((p - vec3(0.028,0.025,0.0)), vec2(0.03,0.07));\n    d = opU(d, sdCappedCylinder((p - vec3(0.028,0.105,0.0)), vec2(0.05,0.05)));\n    return d;\n}\n\nfloat node_valve_right(vec3 p){\n    p = (p - vec3(0.133,0.851,-0.293));\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.14;\n    float dist = length(p - vec3(0.0,0.05,0.0));\n    if(dist > boundingSphereRadius + 0.1){\n         return dist - boundingSphereRadius;\n    }\n#endif\n    float d = sdCappedCylinder((p - vec3(0.028,0.025,0.0)), vec2(0.03,0.07));\n    d = opU(d, sdCappedCylinder((p - vec3(0.028,0.105,0.0)), vec2(0.05,0.05)));\n    return d;\n}\n\nvec2 model_tap_and_basin(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    float boundingSphereRadius = 0.37;\n    float dist = length(p - vec3(0.0,1.04,-0.05));\n    if(dist > boundingSphereRadius + 0.1){\n         return vec2(dist - boundingSphereRadius,0);\n    }\n#endif\n    float d = node_tap(p);\n    d = opU(d, node_valve_left(p));\n    d = opU(d, node_valve_right(p));\n    return vec2(d,4);\n}\n\nvec2 model_box_basin(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.0,1.8,3.23);\n    float dist = udBox(p - vec3(-0.12,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.18,0.07,-0.03)), vec3(0.8,1.5,3.0)) - 0.01);\n    d = opSS(d, sdEllipsoid((p - vec3(-0.198,0.851,-0.08)), vec3(0.3,0.3,0.6)), 0.02);\n    return vec2(d,11);\n}\n\nfloat node_handle_left(vec3 p){\n    p = (p - vec3(-0.031,0.128,-0.419));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.1,0.1,0.1);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return dist;\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.024,0.0,0.0)), vec3(0.0,0.1,0.0)) - 0.01);\n    d = opU(d, (sdBox((p - vec3(0.004,-0.0321,0.0)), vec3(0.05,0.0,0.0)) - 0.005));\n    d = opU(d, (sdBox((p - vec3(0.004,0.0323,0.0)), vec3(0.05,0.0,0.0)) - 0.005));\n    return d;\n}\n\nvec2 model_leftdoor(vec3 p){\n    p = (p - vec3(-0.57,0.01,0.6));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.2,1.3,1.3);\n    float dist = udBox(p - vec3(-0.03,0.06,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(-0.03,0.06,-0.02)), vec3(0.025,1.2,1.2));\n    d = opU(d, sdBox((p - vec3(-0.053,0.06,-0.02)), vec3(0.025,1.1,1.1)));\n    d = opS(d, sdBox((p - vec3(-0.05,0.06,-0.02)), vec3(0.05,1.0,1.0)));\n    d = opU(d, node_handle_left(p));\n    return vec2(d,10);\n}\n\nfloat node_handle_right(vec3 p){\n    p = (p - vec3(-0.031,0.128,0.376));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.1,0.1,0.1);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return dist;\n    }\n#endif\n    float d = (sdBox((p - vec3(-0.024,0.0,0.0)), vec3(0.0,0.1,0.0)) - 0.01);\n    d = opU(d, (sdBox((p - vec3(0.004,-0.0321,0.0)), vec3(0.05,0.0,0.0)) - 0.005));\n    d = opU(d, (sdBox((p - vec3(0.004,0.0323,0.0)), vec3(0.05,0.0,0.0)) - 0.005));\n    return d;\n}\n\nvec2 model_rightdoor(vec3 p){\n    p = (p - vec3(-0.57,0.01,-0.69));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(0.2,1.3,1.3);\n    float dist = udBox(p - vec3(-0.03,0.06,0.0), boundingBoxSize);\n    if(dist > 0.1){\n         return vec2(dist,0);\n    }\n#endif\n    float d = sdBox((p - vec3(-0.03,0.06,-0.02)), vec3(0.025,1.2,1.2));\n    d = opU(d, sdBox((p - vec3(-0.053,0.06,-0.02)), vec3(0.025,1.1,1.1)));\n    d = opS(d, sdBox((p - vec3(-0.05,0.06,-0.02)), vec3(0.05,1.0,1.0)));\n    d = opU(d, node_handle_right(p));\n    return vec2(d,10);\n}\n\nvec2 model_bottom(vec3 p){\n    p = p;\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.3,1.8,3.14);\n    float dist = udBox(p - vec3(-0.12,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_box_basin(p);\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_leftdoor(p));\n#endif\n#if MAX_DETAIL_LEVEL >= 2\n    d = opU(d, model_rightdoor(p));\n#endif\n    return d;\n}\n\nvec2 model_sink(vec3 p){\n    p = (p - vec3(0.1,-1.79,-0.24));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.4,2.42,3.17);\n    float dist = udBox(p - vec3(-0.26,0.15,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_tap_and_basin(p);\n    d = opU(d, model_bottom(p));\n    return d;\n}\n\nvec2 model_mirror(vec3 p){\n    p = (p - vec3(0.389,0.48,0.0));\n    float d = sdBox((p - vec3(-0.012,-0.285,-0.29)), vec3(0.07,1.74,1.27));\n    return vec2(d,1);\n}\n\nvec2 model_right(vec3 p){\n    p = (p - vec3(2.77,4.16,0.93));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(1.32,5.22,8.13);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_right_wall(p);\n    d = opU(d, model_sink(p));\n    d = opU(d, model_mirror(p));\n    return d;\n}\n\nvec2 model_top(vec3 p){\n    p = (p - vec3(0.4,6.62,0.87));\n    float d = sdBox((p - vec3(0.0,0.11,0.08)), vec3(5.9,0.26,7.89));\n    d = opS(d, sdBox((p - vec3(0.0,-0.082,0.08)), vec3(5.12,0.3,7.22)));\n    return vec2(d,0);\n}\n\nvec2 model_wall(vec3 p){\n    p = p;\n    float d = sdBox(p, vec3(6.21,5.09,0.16));\n    return vec2(d,3);\n}\n\nvec2 model_back(vec3 p){\n    p = (p - vec3(0.49,4.08,-2.97));\n#ifdef BOUNDING_VOLUME\n    vec3 boundingBoxSize = vec3(6.21,5.78,0.42);\n    float dist = udBox(p - vec3(0.0,0.0,0.0), boundingBoxSize);\n    if(dist >  + 0.1){\n         return vec2(dist, 0);\n    }\n#endif\n    vec2 d = model_wall(p);\n    return d;\n}\n\nvec2 scene(vec3 p){\n    p = (p - vec3(0.0,0.0,0.235));\n    vec2 d = model_floor(p);\n    d = opU(d, model_closet(p));\n    d = opU(d, model_left(p));\n    d = opU(d, model_front(p));\n    d = opU(d, model_right(p));\n    d = opU(d, model_top(p));\n    d = opU(d, model_back(p));\n    return d;\n}\n\nvec2 map(in vec3 p){\n    vec2 d = scene(p);\n    return d;\n}\n\n#define MAT_NUM 13\nvec3 getAlbedoColor(int index){\n    if(index == 0)return vec3(1.0,1.0,1.0);//default\n    if(index == 1)return vec3(0.7058,0.7801,0.7868);//mirror\n    if(index == 2)return vec3(1.0,1.0,1.0);//floor\n    if(index == 3)return vec3(0.9851,1.0,1.0);//wall\n    if(index == 4)return vec3(1.0,1.0,1.0);//metal\n    if(index == 5)return vec3(0.0822,0.088,0.1471);//glass\n    if(index == 6)return vec3(0.4326,0.5812,0.9338);//vase\n    if(index == 7)return vec3(0.5493,0.5609,0.5882);//towel\n    if(index == 8)return vec3(0.9044,0.8732,0.7714);//wood\n    if(index == 9)return vec3(0.6912,0.6014,0.4879);//wood2\n    if(index == 10)return vec3(1.0,1.0,1.0);//basin\n    if(index == 11)return vec3(0.977,1.0,1.0);//basin2\n    if(index == 12)return vec3(0.977,1.0,1.0);//lamp\n    return vec3(1.0, 1.0, 1.0);\n}\n\nvec3 getSceneMaterial(int index){\n    if(index == 0)return vec3(1.0,0.0,0.0);//default\n    if(index == 1)return vec3(1.0,1.0,1.0);//mirror\n    if(index == 2)return vec3(1.0,0.0,0.0);//floor\n    if(index == 3)return vec3(1.0,0.0,0.0);//wall\n    if(index == 4)return vec3(1.0,1.0,0.3);//metal\n    if(index == 5)return vec3(1.0,0.0,0.0);//glass\n    if(index == 6)return vec3(1.0,0.0,0.35);//vase\n    if(index == 7)return vec3(1.0,0.0,0.35);//towel\n    if(index == 8)return vec3(1.0,0.0,0.35);//wood\n    if(index == 9)return vec3(1.0,0.0,0.35);//wood2\n    if(index == 10)return vec3(1.0,0.0,0.35);//basin\n    if(index == 11)return vec3(1.0,0.0,0.0);//basin2\n    if(index == 12)return vec3(1.0,0.0,0.5);//lamp\n    return vec3(1.0, 0.0, 0.0);\n}\n\n\n\n//scene end=========================\n\n\n \nvec3 intersect(in vec3 ro, in vec3 rd)\n{\n\tfloat tmin = 0.1;\n\tfloat tmax = 30.0;\n\tconst int imax = 64;\n\n\tfloat precis = 0.001;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0; \n\tfor (int i = 0; i<imax; i++)\n\t{\n\t\tvec2 res = map(ro + rd*t);\n\t\td = res.x;\n\t\tif (res.x<precis || t>tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * 0.95;\n\t\tm = res.y;\n\t\tc += 1.0;\n\t}\n\n\tif (t>tmax) m = -1.0;\n\treturn vec3(t, m, c/float(imax));\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd,in float len )\n{\n    // real shadows\t\n    float res = 1.0;\n    float t = 0.02;\n\tfor( int i=0; i<40; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = map(p).x;\n\t\tres = min( res, 60.0*h/t );\n\t\tt += h;\n\t\tif( res<0.01 ||p.y>(len) ) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3  eps = vec3(.005, 0.0, 0.0);\n    vec3 nor;\n    nor.x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    nor.y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    nor.z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n    return normalize(nor);\n}\n\nvec3 getAlbedo(int index,vec3 p,vec3 nor)\n{\n\tvec3 color = vec3(1.0,1.0,1.0);\n\tif(index >=0 && index < MAT_NUM){\n\t\tcolor = pow(getAlbedoColor(index),vec3(2.2));\n\t}\n\tif (index == 2) {//floor\n\t\tcolor *= (sin(p.x * 7.0) < 0.0 == sin(p.z * 7.0) < 0.0) ? vec3(0.8, 0.9, 0.8) : vec3(0.7, 0.8, 0.7);\n\t}\n\telse if (index == 3) {//wall\n\t\tcolor *= p.y < 2.0 ? vec3(0.15, 0.15, 0.15) : vec3(1.0, 1.0, 1.0);\n\t}\n\telse if (index == 4) {//metal\n\t\tcolor *= 1.6;\n\t}\n\telse if (index == 7) {//towel\n\t\t//color *= 0.5 + (sin(p.x * 30.0) + sin(p.y * 30.0 + sin(p.z * 24.0) * 5.0)) * 0.3;\n\t}\n    else if(index == 9){ //wood for door\n        //color = texture(iChannel0,vec2(p.y,p.x + p.z) * 2.0).xyz * 0.9 + vec3(0.2,0.2,0.2);\n    }\n\telse if (index == 11) {\n\t\tif (nor.y < 0.001) {\n\t\t\tcolor *= p.y < 3.1 ? vec3(0.2, 0.3, 0.4) : vec3(1.0, 1.0, 1.0);\n\t\t}\n\t}\n\treturn color;\n}\n\nvec3 getMaterial(int index)\n{\n\tvec3 material = vec3(1.0,0.0,0.0);\n\tif(index >=0 && index < MAT_NUM){\n\t\tmaterial = getSceneMaterial(index);\n\t}\n\treturn material;\n}\n\nfloat fresnelSchlick(float InCosine, float normalReflectance)\n{\n    float oneMinusCos = 1.0 - InCosine;\n    float oneMinusCosSqr = oneMinusCos * oneMinusCos;\n    float fresnel = normalReflectance +\n        (1.0 - normalReflectance) * oneMinusCosSqr * oneMinusCosSqr * oneMinusCos;\n\n    return fresnel;\n}\n\nvec3 getLightColor(float length) \n{\n\treturn vec3(1.0, 0.95, 0.85) * 2.0 * (1.0 / (length + 1.0));\n}\n\nvec4 getLightDirLength(vec3 pos)\n{\n\tvec3 lightPos = vec3(0.4, 5.0, 0.87);\n\treturn vec4(normalize(lightPos - pos), length(lightPos - pos));\n}\n\nvec3 getColor(vec3 pos, vec3 albedo, vec3 material, vec3 n,vec3 h)\n{\n\tvec4 light = getLightDirLength(pos);\n\tvec3 lightColor = getLightColor(light.w);\n\tfloat alpha = material.x;\n\tfloat metalness = material.y;\n\tfloat glossiness = material.z;\n\tvec3 diffuse = albedo * (1.0 - metalness);\n\tvec3 specular = mix(vec3(0.1,0.1,0.1), albedo, metalness);\n\tfloat shininess = pow(8192.0, glossiness);\n\tvec3 colDiff = (diffuse + (shininess + 2.0) * 0.125 * pow(max(dot(n,h),0.0),shininess) * specular) * lightColor * max(dot(n, light.xyz),0.0);\n\n\treturn colDiff;\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(1,1,1);\n    \n    vec3 tmat = intersect(ro, rd);\n    //return vec3(tmat.zzz);\n\n    int index = int(tmat.y);\n\n    if(index == -1){\n        col = mix(vec3(0.3, 0.2, 0.1)*0.5, vec3(0.7, 0.9, 1.0), 0.5 + 0.5*rd.y);\n    }\n    else if (index == -2){\n        vec3 pos = ro + tmat.x*rd;\n        float d = scene(pos).x;\n        float s = cos(d * 100.0) * 0.5 + 0.5;\n        col = vec3(s,s,s) * 0.2;\n    }\n    else\n    {\n        vec3  pos = ro + tmat.x*rd;\n        vec3  nor = calcNormal(pos);\n        vec4 lightDirLength = getLightDirLength(pos);\n\n        vec3 h = normalize(-rd + lightDirLength.xyz);\n        float sha = softShadow(pos, lightDirLength.xyz, lightDirLength.w);\n\n        vec3 albedo = getAlbedo(index,pos,nor);\n        vec3 material = getMaterial(index);\n\n        col = getColor(pos,albedo,material,nor,h) * sha * 0.9 + (dot(h,nor) * 0.05 + 0.05) * albedo;\n\n    }\n\n    return col;\n}\n\nvec3 rayDir(in vec3 dir, in vec3 up ,in vec3 uvw)\n{\n\tvec3 uu = normalize( cross(up,dir) );\n\tvec3 vv = normalize( cross(dir,uu) );\n    return normalize(uu * uvw.x + vv * uvw.y + dir * uvw.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //vec2 p = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\t//p.x *= -1.0;\n\tfloat pixelSize = tan(PI / 6.0) * 2.0 / iResolution.y;\n\tvec2 p = (fragCoord.xy - iResolution.xy * 0.5) * pixelSize;\n\t\n\n    \n    float yaw = (iMouse.x == 0.0 && iMouse.y == 0.0)?iTime * 0.1 + 1.2:-iMouse.x * 0.01;\n    float pitch = (iMouse.x == 0.0 && iMouse.y == 0.0)?-0.1:clamp(iMouse.y/iResolution.y - 0.4,-PI * 0.5,PI * 0.5);\n\n    vec3 camDir = vec3(cos(yaw) * cos(pitch),sin(pitch),sin(yaw) * cos(pitch));\n    \n    vec3 lookAt = vec3(0.3,3.8,-0.0);\n    vec3 camPos = lookAt - camDir * 2.5;//vec3(0.0,4.0,-3.0);\n    //vec3 camDir = normalize(vec3(0,-0.1,1.0));\n    \n    vec3 ro = camPos;\n\tvec3 rd = rayDir(camDir,vec3(0.0,1.0,0.0),vec3(p,1.0));\n\n    vec3 col = render(ro, rd);\n\n    fragColor = vec4(pow(clamp(col, 0.0, 1.0), vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}