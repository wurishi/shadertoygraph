{"ver":"0.1","info":{"id":"ldyyWR","date":"1521579387","viewed":379,"name":"waterline (MM3 ver.)","username":"Telperion","description":"\"waterline.frag\"\nModster Mash 3 version, 2018-03-18\n\nCreate a realistic reflection pattern in the lower part of the image, as if the upper part were reflecting in water.\n\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["reflection","wave","sunset","water","realistic","shore","waterline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI (3.14152965359)\n\nfloat softSign(in float vi)\n{\n    return atan(pow(vi,3.0));\n}\nvec3 gradSunset(float dist, float conf)\n{\n    // [0, 1]\n    float dd = 1.0-dist;\n    \n    float redConf =  1.0 + 0.5 * conf;\n    float yelConf =  2.5 + 3.0 * conf;\n    float purConf =  5.0 + 1.0 * conf;\n    \n    return vec3(\n        0.5 + 0.5*pow(dd, redConf),     // Gotta be a little bit red everywhere\n        (1.0 - conf) * 0.9*pow(dd, yelConf),\n        12.0*pow(dd, redConf)*pow(dist, purConf)\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Parameters\n\tfloat colorConf = 0.0;\t\t\t\t\t// 0 = a nice sunset effect, 1 = a scary red effect\n\tfloat waterDensity = 1.0;\t\t\t\t// 0 = no reflection effect, 1 = full opacity reflection\n\tfloat colorDensity = 0.0;\t\t\t\t// 0 = no additional color, 1 = full additional colorizing\n      \n    float cutoff = 0.22;\t\t\t\t\t// Y-coordinate where the backdrop ends and water begins \n    float decay = 3.0;                      // Strength of horizontal wave out from center (multiplied by 4 in equation)\n    float decayCenter = 0.5;                // Center of horizontal wave\n    float grandCurrentV = -1.0;             // Period of large water cycle toward user\n    float grandCurrentH = 12.0;             // Period of large water cycle horizontally back and forth\n    vec2 waveCurrent = vec2(grandCurrentH, grandCurrentV);\n    vec2 waveCount = vec2(7.0, 7.0);        // Number of \"waves\" (texture transfer oscillations) - horiz, toward\n    vec2 waveStrength = vec2(0.1, 0.5);     // Strength of waves - horiz, toward\n    float slightXCutoff = 0.02;\t\t\t\t// Soften the cutoff by blending up waves\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n\t// Position of \"sun\" in sunset coloration\n    vec2 sun = vec2(0.5, cutoff);\n    \n    // Start with a mapping of the backdrop image into the area used for reflection\n    float yWater = 1.0 - uv.y/cutoff;\n    float yScale = (cutoff-1.0);\n    \n    \n    // \n    vec2 pq = uv;\n    pq.y = yWater*(2.0-yWater);\n\n    // cross section horizontally = e^(-decay*x^2)*cos(2*pi*x/WH)\n    // cross section toward = sin(2*pi*y/WV)\n    vec2 uvWaterBase;\n    float xDecay = exp(-decay*(pq.x-decayCenter)*(pq.x-decayCenter));\n    float xWaver = sin(2.0*M_PI*(waveCount.x*pq.x + iTime/grandCurrentH));\n    float yDecay = 1.0 - exp(-decay*pq.y);\n    float yWaver = sin(2.0*M_PI*(waveCount.y*pq.y + iTime/grandCurrentV));\n    float xPushy = 0.5*xDecay*(xWaver+yWaver);\n    uvWaterBase.x = waveStrength.x*xPushy*pq.y + pq.x;\n    uvWaterBase.y = (waveStrength.y*(0.5*yDecay*yWaver + 0.5) + pq.y)/(1.0 + waveStrength.y);\n\n\n    // Keep pq from overflowing around the image when it shouldn't.\n    pq = clamp(uvWaterBase, 0.01, 0.99);\n\n    // Shift y back to just water zone\n    pq.y = cutoff - pq.y*yScale;\n    \n    vec2 uvFinal = uv;\n   \n    // Water here or not?\n    float waterWeight = 0.0;\n    if (uv.y - cutoff + slightXCutoff*xPushy < 0.0)\n    {\n        waterWeight = 1.0;\n    }\n    uvFinal = pq*waterWeight + uv*(1.0-waterWeight);\n\n    // Blend the original texture and the water reflection remap into the same texture and blend.\n    vec4 texAir = texture(iChannel0, uv);\n    vec4 texWater = texture(iChannel0, pq);\n    float waterHere = waterWeight;\n    vec4 tex = texAir*(1.0 - waterHere*waterDensity) + texWater*waterHere*waterDensity;\n\n\n    // Map color overlay to image using a radial gradient\n    float xx, yy, c1, c2;\n    xx = uv.x - sun.x;\n    yy = uv.y - sun.y;\n    c1 = sqrt(xx*xx + yy*yy);\n    vec3 gradColorAir   = gradSunset(c1, colorConf);\n    xx = pq.x - sun.x;\n    yy = pq.y - sun.y;\n    c2 = sqrt(clamp(xx*xx + yy*yy, 0.0, 1.0));\n    vec3 gradColorWater = gradSunset(c2, colorConf);\n    vec3 gradColor = gradColorAir*(1.0 - waterHere*waterDensity) + gradColorWater*waterHere*waterDensity;\n\n\n    gradColor = vec3(1.0, 1.0, 1.0)*(1.0 - colorDensity) + gradColor*colorDensity;\n    \n\n    // Output to screen\n    fragColor = vec4(tex.rgb * gradColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}