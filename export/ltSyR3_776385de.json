{"ver":"0.1","info":{"id":"ltSyR3","date":"1509460984","viewed":146,"name":"mychessraytracer","username":"grimmzzf","description":"a simple raytracer","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray_\n{\n\tvec3 origin;\n\tvec3 dir;\n};\nstruct camera_\n{\n\tvec3 eye;\n\tvec3 front;\n\tvec3 up;\n\tfloat fov;\n};\nstruct sphere_\n{\n\tvec3 center;\n\tfloat radius;\n};\nstruct plane_\n{\n\tvec3 normal;\n\tvec3 p;\n};\nstruct light_\n{\n\tvec3 pos;\n\tvec3 dir;\n\tvec3 color;\n} light = light_(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0));\nsphere_ sp1= sphere_(vec3(0.0, 10.0, -10.0), 10.0);\nsphere_ sp2= sphere_(vec3(10.0, 10.0, -10.0), 10.0);\n\nray_ getRay(vec2 pixel, camera_ camera)\n{\n\tvec3 right = cross(camera.front, camera.up);\n\tvec3 up = cross(right, camera.front);\n\tfloat fovScale = tan(camera.fov * 0.5 * 3.1415926535 / 180.0) * 2.0;\n\tvec2 point = pixel;\n\tvec3 r = right * point.x * fovScale;\n\tvec3 u = up * point.y * fovScale;\n\treturn ray_(camera.eye, normalize(camera.front + r + u));\n}\nfloat intersect_sphere(ray_ ray, sphere_ sphere, inout vec4 color)\n{\n\tvec3 v = ray.origin - sphere.center;\n\tfloat a0 = dot(v, v) - sphere.radius * sphere.radius;\n\tfloat DdotV = dot(ray.dir, v);\n\n\tif (DdotV <= 0.0){\n\t\tfloat discr = DdotV * DdotV - a0;\n\t\tif (discr >= 0.0){\n\t\t\tfloat distance = -DdotV - sqrt(discr);\n\t\t\tvec3 pos = ray.origin + ray.dir * distance;\n\t\t\tvec3 normal = normalize(pos - sphere.center);\n\n\t\t\t// float depth = 255.0 - min((distance / 20.0) * 255.0, 255.0);\n\t\t\t// color = vec4((normal + 1.0) * 0.5, 1.0);\n\t\t\t// color = vec4(vec3(depth / 255.0), 1.0);\n\n\t\t\tfloat NdotL = dot(normal, light.dir);\n\t\t\tvec3 H = normalize(light.dir - ray.dir);\n\t\t\tfloat NdotH = dot(normal, H);\n\t\t\tvec3 diffuse = vec3(1.0, 0.0, 0.0) * max(NdotL, 0.0);\n\t\t\tvec3 specular = vec3(1.0, 1.0, 1.0) * pow(max(NdotH, 0.0), 32.0);\n        \tcolor = vec4(vec3(light.color * (diffuse + specular)), 1.0);\n\t\t\treturn 1.0;\n\t\t}\n\t}\n\treturn 0.0;\n}\nfloat intersect_plane(ray_ ray, plane_ plane, inout vec4 color)\n{\n\tfloat t = dot((plane.p - ray.origin), plane.normal) / dot(plane.normal, ray.dir);\n\tif(t > 0.0){\n\t\tvec3 intersect = ray.dir * t + ray.origin;\n\t\tif (abs(mod(floor(intersect.x * 0.1) + floor(intersect.z * 0.1), 2.0)) < 1.0){\n\t\t\tcolor = vec4(vec3(0.0), 1.0);\n\t\t}else{\n\t\t\tcolor = vec4(vec3(1.0), 1.0);\n\t\t}\n\t\tfloat reflectiveness = 0.25;\n\t\tcolor *= (1.0 - reflectiveness);\n\t\tray_ r = ray_(intersect, normalize(ray.dir - 2.0 * dot(ray.dir, plane.normal) * plane.normal));\n\n\t\tvec4 c = vec4(0.0);\n\t\tfloat hit = 0.0;\n\t\thit = intersect_sphere(r, sp1, c);\n\t\tcolor += reflectiveness * c * hit;\n\n\t\t// hit = intersect_sphere(r, sp2, c);\n\t\t// color += reflectiveness * c * hit;\n\t\treturn 1.0;\n\t}\n\treturn 0.0;\n} \nvec4 aliasing(in vec2 plane_point)\n{\n\tvec2 point = plane_point;\n\tfloat r = radians(mod(iTime * 10.0, 360.0));\n\tvec3 lookat = vec3(0.0, 10.0, -10.0);\n\tfloat looklen = 30.0;\n\tvec3 position = vec3(lookat.z + cos(r) * looklen, sin(r) * 10.0 + 10.0, lookat.x + sin(r) * looklen - 10.0);\n\t// vec3 position = vec3(0.0,0.0,10.0);\n\tcamera_ camera = camera_(position, normalize(lookat - position), vec3(0.0, 1.0, 0.0), 90.0);\n\tray_ ray = getRay(point, camera);\n\tvec4 result = vec4(0.0);\n\tvec4 color = vec4(0.0);\n\tfloat hit = 0.0;\n\thit = intersect_plane(ray, plane_(vec3(0.0, 1.0, 0.0), vec3(0.0, -10.0, 0.0)), color);\n\tif (hit > 0.0){ result = vec4(0.0);}\n\tresult = color * hit;\n\n\thit = intersect_sphere(ray, sp1, color);\n\tif (hit > 0.0){ result = vec4(0.0);}\n\tresult += color * hit;\n\n\t// hit = intersect_sphere(ray, sp2, color);\n\t// if (hit > 0.0){ result = vec4(0.0);}\n\t// result += color * hit;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    vec2 point = (2.0*fragCoord.xy - iResolution.xy)/iResolution.x;\n\tvec4 result = aliasing(point);\n\n\tpoint = (2.0*vec2(fragCoord.x + 0.5, fragCoord.y) - iResolution.xy)/iResolution.x;\n\tresult += aliasing(point);\n\n\tpoint = (2.0*vec2(fragCoord.x, fragCoord.y + 0.5) - iResolution.xy)/iResolution.x;\n\tresult += aliasing(point);\n\n\tpoint = (2.0*vec2(fragCoord.x - 0.5, fragCoord.y) - iResolution.xy)/iResolution.x;\n\tresult += aliasing(point);\n\n\tpoint = (2.0*vec2(fragCoord.x, fragCoord.y - 0.5) - iResolution.xy)/iResolution.x;\n\tresult += aliasing(point);\n\n\tfragColor = result / 5.0;\n}","name":"Image","description":"","type":"image"}]}