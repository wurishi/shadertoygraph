{"ver":"0.1","info":{"id":"wtdyzH","date":"1608508543","viewed":122,"name":"Simple guitar raymarching","username":"Panicq","description":"A simple raymarched guitar (wip)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingguitar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxDist  50.0\n#define steps 200\n#define delta  0.001\n#define pi 3.1415926535\n#define degToRad 0.01745329251\n\n//https://iquilezles.org/articles/distfunctions\nvec4 sdSphere(in vec3 p, float r, vec3 color){\n    return vec4(color.rgb, length(p) - r);\n}\n\nvec4 sdPlane(vec3 p, float h, vec3 color){\n    return vec4(color.rgb, p.y - h);\n}\n\nvec4 sdCylinder(in vec3 p, float r1, float r2, float h, vec3 color){\n    vec2 d = vec2(length(p.xz)-2.0 * r1+r2, abs(p.y) - h);\n    float e= min(max(d.x, d.y),0.0) + length(max(d,0.0)) - r2;\n    return vec4(color.rgb, e);\n}\n\nvec4 sdBox( vec3 p, vec3 b, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  float d= length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  return vec4(color.rgb, d);\n}\n\nvec4 sdRoundBox( vec3 p, vec3 b, float r, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  float d= length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  return vec4(color.rgb, d);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nvec4 sdCappedCone( vec3 p, float h, float r1, float r2 , vec3 color)\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  float d = s*sqrt( min(dot2(ca),dot2(cb)) );\n  return vec4(color.rgb, d);\n}\n\n\nvec3 rotateX(vec3 v, float a){\n    float c = cos(a);\n    float s = sin(a);\n    mat3x3 r = mat3x3(vec3(1,0,0),vec3(0,c,-s),vec3(0,s,c));\n    return v *= r;\n}\n\nvec3 rotateY(vec3 v, float a){\n    float c = cos(a);\n    float s = sin(a);\n    mat3x3 r = mat3x3(vec3(c,0,s),vec3(0,1,0),vec3(-s,0,c));\n    return v *= r;\n}\n\nvec3 rotateZ(vec3 v, float a){\n    float c = cos(a);\n    float s = sin(a);\n    mat3x3 r = mat3x3(vec3(c,-s,0),vec3(s,c,0),vec3(0,0,1));\n    return v *= r;\n}\n\n\nvec4 minVec4(vec4 a, vec4 b){\n    return a.w < b.w ? a : b;\n}\n\nvec4 maxVec4(vec4 a, vec4 b){\n    return a.w > b.w ? a : b;\n}\n\nvec4 smin( vec4 a, vec4 b, float k )\n{\n    float h = clamp( 0.5+0.5*(b.w-a.w)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 body(in vec3 p, float h, vec3 color){    \n\n    //Main\n    vec4 c0 = sdCylinder(p * vec3(1.1,1,1), 0.2,0.05, h, color);\n    vec4 c1 = sdCylinder((p * vec3(1.3,1,1) - vec3(0.5,0,0)) , 0.15,0.03, h + 0.1, color);\n    vec4 d = smin(c0,c1,0.05);\n   \n    //Hole\n    vec4 c2 = sdCylinder(p - vec3(0.3,h,0), 0.055,0.05, h * 0.8, color);\n \n\n    //Concavity\n    float thickness = 0.05;\n    vec4 c0p = sdCylinder(p * vec3(1.1,1,1), 0.2 - thickness,0.05, h - thickness, color);\n    vec4 c1p = sdCylinder(p * vec3(1.3,1,1)  - vec3(0.5,0,0), 0.15 - thickness,0.05, h - thickness, color);\n    \n    vec4 hT = sdBox(p - vec3(0.15,0,0), vec3(0.55,h ,0.4), color);\n\n    vec4 hole = smin(c0p,c1p,0.04);    \n    hole = maxVec4(hT, hole);\n    \n    d = maxVec4(-hole, d);\n    \n    d = maxVec4(-c2, d);\n    \n    //Trim\n    vec4 b = sdBox(p - vec3(0.15,0,0), vec3(0.55,h + 0.04,0.4), vec3(0.721, 0.541, 0.196));\n    d = maxVec4(b, d);\n    \n    vec4 ch = sdRoundBox(p - vec3(0.05,h,0), vec3(0.03,0.08,0.13), 0.001, \n                        vec3(0.125, 0.058, 0.015));\n    \n    d = minVec4(ch,d);\n    \n    vec4 c3 = sdCylinder(p - vec3(0.3,h,0), 0.075,0.05, h * 0.8, vec3(1,1,1));\n    \n    c3.rgb *= step(fract(c3.w * 50.0),0.5);\n\n    vec4 decal = minVec4(c3,d);\n    d.rgb = decal.rgb;\n    \n    return d;\n}\n\nvec4 head(in vec3 p, vec3 color){\n    vec4 d = sdBox(p - vec3(1.62,0.1,0), \n                vec3(0.15 ,0.03,(0.002 + abs(p.x) * 0.2) * 0.3), color);\n\n    return d;\n}\n\nvec4 neck(vec3 p, vec3 color){\n    vec3 pR = rotateZ(p - vec3(0.94,0.1,0), degToRad * 90.0);\n    vec4 c0 = sdCappedCone(pR, 0.5,0.09, 0.07, color);\n    \n    vec4 t = sdPlane(p, 0.13, color);\n\n    vec4 d = maxVec4(c0, t);\n    \n    vec4 hd = head(p, color);\n    \n    d = smin(d, hd, 0.1);\n    vec4 t2 = sdPlane(p, 0.13, color);\n\n    //Tunners\n    vec3 kP = rotateX(pR, degToRad * 90.0);\n    float space = 0.08;\n    float kPZ = mod(kP.z,space)-(space*0.5);\n    vec4 k = sdCylinder(vec3(kP.xy, kPZ), 0.008,0.008, 0.16, color);\n    vec4 cB = sdBox(kP - vec3(0,0,0.7), vec3(0.1,0.2,0.12), vec3(1.0,1.0,1.0));\n    \n    //Frets\n    \n    kP = rotateX(pR - vec3(-0.03,0.0,0.0), degToRad * 90.0);\n    space = 0.08;\n    kPZ = mod(kP.z,space)-(space*0.5);\n    vec4 f  = sdCylinder(vec3(kP.xy, kPZ), 0.003,0.003, 0.08, vec3(0.5,0.5,0.5));\n    vec4 cBf = sdBox(kP - vec3(0,0,0), vec3(0.3,0.4,0.5), vec3(1.0,1.0,1.0));\n    \n    f = maxVec4(cBf,f);\n\n    k = maxVec4(cB, k);\n    d = minVec4(d, k);\n    d = maxVec4(d, t2);\n    d = minVec4(d, f);\n\n    return d;\n}\n\nvec4 strings(in vec3 p, vec3 color){\n    vec4 d = vec4(0,0,0,maxDist);\n    vec3 sH = vec3(-0.135,0.75,-0.08);\n    \n    vec3 pR = rotateZ(p, degToRad * 90.0) - sH;\n    float space = 0.028;\n    float pS = mod(pR.z,space)-(space*0.5);\n\n    /*for(int i = 0; i <= 6; i++){\n       s = sdCylinder(pR  - vec3(0,0,float(i) * 0.024), 0.002,0.005, 0.68, color);\n       d = minVec4(d,s);\n    }*/\n    \n    vec4 s = sdCylinder(vec3(pR.xy, pS), 0.002,0.05, 0.68, color);\n    \n    vec4 bT = sdBox(pR - vec3(0,0,0.08), vec3(0.1,0.7,0.08), vec3(1.0,1.0,1.0));\n    \n    vec4 r = maxVec4(bT, s);\n    \n    d = minVec4(d, r);\n    \n    return d;\n}\n\nvec4 scene(vec3 p){\n\n    //return sdSphere(p, 0.5, vec3(1,0,0));\n\n    float h = 0.06;\n    \n    //Body\n    vec3 pG = rotateY(p- vec3(-0.5,0.5,0.0), degToRad * -20.0);    \n    pG = rotateX(pG, degToRad * sin(iTime) * 20.0 + degToRad * 60.0);\n    \n    \n    vec4 d = body(pG, h, vec3(0.572, 0.313, 0.149));\n    d = minVec4(d, neck(pG, vec3(0.133, 0.050, 0.007)));\n    d = minVec4(d, strings(pG, vec3(0.827, 0.866, 0.894)));\n    \n    //float bands = step(mod(d.w * 2.0,1.2),0.5);\n    \n    float bands = step(fract(p.x * 2.0),0.5);\n    \n    vec4 pl = sdPlane(p, 0.0, vec3(0.5) * bands);\n    \n    d = minVec4(d, pl);\n    \n    return d;\n}\n\nvec4 march(in vec3 p, in vec3 dir){\n    float d = 0.0;\n    vec4 result = vec4(0.0);\n    vec3 cp = p;\n    \n    for(int i = 0; i < steps; i++){\n        cp = p + dir * d;\n        result = scene(cp);\n        d += result.w;\n       \n        \n        if(result.w < delta)\n        {\n            break;\n        }\n        \n        if(d > maxDist){\n            result.rgb = vec3(1,0,0);\n            break;\n        }\n    }\n    \n    return vec4(result.rgb, d);\n}\n\nvec3 getNormal(in vec3 p){\n    vec2 eps = vec2(0.01,0);\n    float d = scene(p).w;\n    \n    return normalize(vec3(\n        scene(p + eps.xyy).w - d,\n        scene(p + eps.yxy).w - d,\n        scene(p + eps.yyx).w - d\n    ));\n}\n\nfloat lighting(in vec3 p,in vec3 n){\n    vec3 l = vec3(3,4,-5);\n    vec3 ld = l - p;\n    vec3 ldn = normalize(ld);\n    \n    //Shadows\n    \n    if(march(p + n * 0.02, ldn).w < length(ld))\n        return 0.1;\n    \n    float d = max(dot(n, ldn),0.0);\n    return d;\n}\n\nvec3 post(in vec3 col, in vec2 uv){\n\n    float v = 1.0 - smoothstep(0.1,0.6, length(uv * vec2(0.5,1.0)));\n\n    col = vec3(col * v);\n        \n    col += vec3(0.1,0.05,0.2) * 0.1;\n\n    col = 2.0 * col;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec2 mouse = ((iMouse.xy / iResolution.xy) - 0.5) * 0.5;\n\n    //cam\n    vec3 gOffset = vec3(mouse.x * 0.5,0.5,-3.0 - mouse.y * 4.0);\n    vec3 eye = vec3(0.0,0.0,-1.0) + gOffset;\n    vec3 target = vec3(0,0,0) + gOffset;\n    \n    vec3 f = normalize(target - eye);\n    vec3 s = cross(vec3(0,1,0), f);\n    vec3 u = cross(f, s);\n    \n    float persp = 1.8 ;\n    \n    vec3 rd = normalize(persp * f + uv.x * s + uv.y * u);\n    vec4 result = march(eye, rd);\n    \n    vec3 cp = eye + rd * result.w;\n    \n    vec3 n = getNormal(cp);\n    float l = lighting(cp, n);\n    vec3 col = result.rgb * l * vec3(1.0,0.9,0.2);\n    \n    float sky = clamp(dot(n, vec3(0,1.0,0)), 0.0,1.0);\n    col += sky * vec3(0.1,0.2,0.4) * 0.6;\n    \n    \n    col = mix(col, vec3(0.0), min(result.w * 0.1,1.0));\n    col = post(col, uv);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col.rgb,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}