{"ver":"0.1","info":{"id":"Dd3XW4","date":"1679770455","viewed":644,"name":"A 2d pathtracer ? Cool !","username":"Poisson","description":"A 2d pathtraced scene with global illumination, caustics, metal, emission, diffuse and ambient occlusion. It's look 3d!","likes":44,"published":1,"flags":32,"usePreview":1,"tags":["2d","raytracing","reflection","raytracer","ray","gi","global","light","sphere","pathtracing","pathtracer","box","ao","metal","diffuse","disk","path","emission"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// my first try at 2d pathtracing\n\n// aces tonemapper\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// bloom function\nvec4 bloom(sampler2D tex, vec2 p) {    \n    vec4 col = vec4(0); // accumulated color\n    const int N = 3; // quality\n    \n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++)  {\n        vec2 off = vec2(i,j) / float(N); // blur offset\n        \n        // blurred texture\n        col += textureLod(tex, p + .03*off*vec2(9./16.,1), 4.);\n    }\n    // output\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    vec4 data = texture(iChannel0, p);\n    vec3 col = data.rgb/data.a; // base color\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    \n    // bloom\n    vec4 bloom = bloom(iChannel0, p);\n    col += .4*bloom.rgb;\n    \n    col = ACES(col); // tonemapping\n    col = col*.6+.4*col*col*(3.-2.*col); // contrast\n    col *= 1.3; // exposure\n    col = col*vec3(1,1,.7)+vec3(0,0,.15); // color grading\n    \n    // vignette\n    col *= pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y), .1);\n                \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SPP 32 // sample per pixel\n#define FRAME_BLEND .75 // prev frame to new frame blend\n#define GI_BOUNCES 5 // global illumination bounces\n\n//#define PROGRESSIVE\n\nfloat seed; // randoms seed\n\n// random number between 0 and 1\nfloat hash() {return fract(sin(seed+=.1)*4561.7564);}\n\n// vec2 to float hash\nfloat hash(vec2 x) {\n\tfloat n = dot(x,vec2(127.1,311.7));\n\treturn fract(sin(n)*4561.7564);\n}\n\n// normalized 2d vector\nvec2 uniformVector() {\n    float an = hash()*6.283185; // angle\n    return vec2(sin(an), cos(an));\n}\n\n// random 2d vector\nvec2 randomVector() {\n    float an = hash()*6.283185; // angle\n    float ra = sqrt(hash()); // radius\n    return ra * vec2(sin(an), cos(an));\n}\n\n// disk sdf\nfloat sdDisk(vec2 p, vec3 dsk) {\n    return length(p-dsk.xy) - dsk.z;\n}\n\n// box sdf\nfloat sdBox(vec2 p, vec4 box) {\n    vec2 q = abs(p-box.xy) - box.zw;\n    return length(max(q,0.));\n}\n\n// disk gradient/normal\nvec2 gDisk(vec2 p, vec3 dsk) {\n    return normalize(p - dsk.xy);\n}\n\n// box gradient/normal\n// thanks to iq: https://iquilezles.org/articles/distgradfunctions2d/\nvec2 gBox(vec2 p, vec4 box) {\n    vec2 w = p - box.xy;\n    vec2 q = abs(w) - box.zw;\n    \n    float g = max(q.x,q.y);\n    vec2 s = sign(w);\n    \n    return s*(g>0. ? normalize(max(q,0.)) : \n                     step(q.yx,q.xy));\n}\n\n// ray disk intersection\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat diskIntersect(vec2 ro, vec2 rd, vec3 dsk) {\n    vec2 oc = ro - dsk.xy;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - dsk.z*dsk.z;\n    float h = b*b - c;\n    \n    if (h<0.) return -1.;\n    h = sqrt(h);\n    return c<0. ? -b+h : -b-h;\n}\n\n// ray box intersection\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nfloat boxIntersect(vec2 ro, vec2 rd, vec4 box) {\n    vec2 oc = ro - box.xy;\n    vec2 m = 1./rd;\n    vec2 n = -m*oc;\n    vec2 k = abs(m)*box.zw;\n\t\n    vec2 t1 = n - k;\n    vec2 t2 = n + k;\n\n\tfloat tN = max(t1.x, t1.y);\n\tfloat tF = min(t2.x, t2.y);\n\t\n\tif(tN>tF || tF<0.) return -1.;\n    \n    vec2 q = abs(oc) - box.zw;\n    float g = max(q.x, q.y);\n    \n    return g>0.?tN:tF;\n}\n\n// objects\n#define NUM_DISCS 6\nvec3 discs[NUM_DISCS];\n\n#define NUM_BOXES 3\nvec4 boxes[NUM_BOXES];\n\nvoid createScene(void) {\n    // lights angle\n    #ifdef PROGRESSIVE\n    float an = 1.9;\n    #else\n    float an = 1.+.2*iTime;\n    #endif\n    //lights position\n    vec2 m = vec2(1.25,.7)*vec2(sin(an),cos(an));\n    \n    // setup scene\n    discs[0] = vec3(0,.1,.2);\n    discs[1] = vec3(.6,0,.125);\n    discs[2] = vec3(-.6,-.3,.18);\n    discs[3] = vec3(-m,.05);\n    discs[4] = vec3(m,.05);\n    discs[5] = vec3(-.15,-.3,.1);\n    \n    boxes[0] = vec4(0,.55,.2,.02);\n    boxes[1] = vec4(.25,-.5,.1,.15);\n    boxes[2] = vec4(-.6,.25,.15,.15);\n}\n\n// intersection function\nfloat intersect(vec2 ro, vec2 rd, float tmax, out vec2 on, out float oid) {\n    float t = tmax; // final distance\n    \n    // discs\n    for (int i=0; i<NUM_DISCS; i++) {\n        vec3 dsk = discs[i]; // current disk\n        float h = diskIntersect(ro, rd, dsk); // disk distance\n        \n        if (h>0. && h<t) {\n            on = gDisk(ro, dsk); // normal\n            oid = float(i); // disk index\n            t = h;\n        }\n    }\n    \n    // boxes\n    for (int i=0; i<NUM_BOXES; i++) {\n        vec4 box = boxes[i]; // current box\n        float h = boxIntersect(ro, rd, box); // box distance\n        \n        if (h>0. && h<t) {\n            on = gBox(ro, box); // normal\n            oid = float(NUM_DISCS + i); // box index\n            t = h;\n        }\n    }\n    \n    return t<tmax ? t : -1.;\n}\n\n// scene sdf\nfloat map(vec2 p) {\n    float d = 1e10; // final distance\n    \n    for (int i=0; i<NUM_DISCS; i++) {\n        vec3 dsk = discs[i]; // current disk\n        float h = sdDisk(p, dsk); // disk distance\n        d = min(d, h);\n    }\n    \n    for (int i=0; i<NUM_BOXES; i++) {\n        vec4 box = boxes[i]; // current box\n        float h = sdBox(p, box); // box distance\n        d = min(d, h);\n    }\n    \n    return d;\n}\n\n// material function\nvoid getMaterial(float id, out vec3 matCol, out float emit, out float metal) {\n    emit = 0.;\n    metal = 0.;\n    if (id<.5) {\n        matCol = .7*vec3(.7,1,.2);\n    } else if (id<1.5) {\n        matCol = .8*vec3(.6,.3,1);\n    } else if (id<2.5) {\n        matCol = vec3(1,.6,.3);\n        metal = 1.;\n    } else if (id<3.5) {\n        matCol = 3.*vec3(1,.15,.04);\n        emit = 1.;\n    } else if (id<4.5) {\n        matCol = 3.*vec3(.2,.5,1);\n        emit = 1.;\n    } else if (id<5.5) {\n        matCol = vec3(1);\n    } else if (id<6.5) {\n        matCol = vec3(.7);\n        emit = 1.;\n    } else if (id<7.5) {\n        matCol = vec3(1);\n        metal = 1.;\n    } else if (id<8.5) {\n        matCol = vec3(1);\n    }\n}\n\n// rendering function\nvec3 render(vec2 p) {    \n    vec3 col = vec3(1);\n    \n    vec2 ro = p; // ray origin\n    vec2 rd = uniformVector(); // ray direction\n    \n    int i = 0; // bounces count\n    for (;i<GI_BOUNCES; i++) { // pathtracing loop\n        vec2 n; float id; // normal and object id\n        float t = intersect(ro, rd, 1e10, n, id); // distance\n        \n        if (t<0.) return vec3(0); // background\n        vec2 p = ro + rd*t; // hit point\n\n        // material\n        vec3 matCol; float emit, metal;\n        getMaterial(id, matCol, emit, metal);\n        \n        col *= matCol;\n        if (emit>.5) break; // emission\n        \n        ro = p+n*.001; // new ray origin\n        // new ray direction\n        rd = mix(normalize(n + randomVector()), // diffuse brdf\n                 reflect(rd, n), // glossy brdf\n                 metal);\n    }\n    \n    // wood texture\n    float h = map(p); // scene sdf\n    if (h>0.) col *= texture(iChannel1, p*2.).rgb;\n    \n    // output\n    return i == GI_BOUNCES ? vec3(0) : col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    createScene();\n    \n    vec3 tot = vec3(0); // accumulated color\n    \n    for (int i=0; i<SPP; i++) {\n        // init randoms seeds\n        seed = float(i)+iTime + hash(fragCoord/iResolution.xy);\n        \n        vec2 off = vec2(hash(), hash()) - .5; // AA offset\n        // pixel coordinates centered at the origin\n        vec2 p = 1.5*(fragCoord+off - .5*iResolution.xy) / iResolution.y;\n\n        vec3 col = render(p); // render\n        tot += col;\n    }\n    tot /= float(SPP);\n\n    // accumulation\n    \n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    #ifdef PROGRESSIVE\n    fragColor = vec4(tot,1) + data;\n    #else\n    fragColor = mix(vec4(tot,1), data, \n                iFrame==0 ? 0. : FRAME_BLEND);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"}]}