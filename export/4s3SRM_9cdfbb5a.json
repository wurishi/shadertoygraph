{"ver":"0.1","info":{"id":"4s3SRM","date":"1458309630","viewed":238,"name":"Lifted Domain Coloring","username":"MBR","description":"Debugging aid for visualizing the 2D domain","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["domain","complex","debug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// LICENSE: http://unlicense.org/\n\n// Utility for visualizing the domain of a 2D map, with\n// a reasonable number of configurables.\n\n// WIP: need to tweak pole coloring scheme, currently\n// disabled.\n\n// Defaults to showing identity for the square bounding\n// the unit circle.\n\n// [1] \"Lifted Domain Coloring\", Konstantin Poelke & Konrad Polthier, \n// Eurographics/IEEE-VGTC Symposium on Visualization 2009,\n// Volume 28 (2009), Number 3\n// PDF: http://www.mi.fu-berlin.de/en/math/groups/ag-geom/publications/db/lifteddomaincoloring.pdf\n\n// Overview:\n// * angle in the plane = hue (fixed)\n// * K radial lines\n// * concentric lines @ power-of-two distance boundaries\n//   every other annulus darkens the map in the direction\n//   of zero and brighten toward infinity.\n// * radial & concentric lines are orthogonal at crossing.\n//   this can be interesting for visualizing area distortions\n//   introduced by the map.\n// * mapping point p=(x,y) in the plane to the Riemann sphere P\n//     d = dot(p,p)\n//     P = (2x,2y,d-1)/(d+1)\n// \n\n#define SHADERTOY\n\n#if !defined(SHADERTOY)\n#extension GL_OES_standard_derivatives : enable\n#define iResolution resolution\nuniform vec2 resolution;\n\nvoid mainImage(out vec4 f, in vec2 uv);\n\nvoid main(void) { mainImage(gl_FragColor, gl_FragCoord.xy); }\n#endif\n\n// coloring tweekable constants\n\n// growth indication constant (>=0). larger is less pronounced.\n// \n#define GROW_K  .9  \n\n// grid line scale (radial & concentric)\n#define GRID_K  0.04\n\n// radial grid lines: shown if defined\n#define RADIAL_GRID\n\n// radial: post blended in RGB if defined, otherwise\n// via saturation.\n//#define RADIAL_GRID_POST\nconst vec3 rg_color = vec3(1.0,1.0,1.0);\n\n// number of radial lines\n#define RADIAL_LINES 16.0\n\n// blen value for radial lines (0,1) 0=strong, 1=none\n#define RADIAL_LINE_STR 0.3\n\n// concentric grid lines: shown if defined\n#define CONCENTRIC_GRID\n\n// concentric post blended in RGB if defined, otherwise\n// via brightness\n//#define CONCENTRIC_GRID_POST\nconst vec3 cg_color = vec3(0.0,0.0,0.0);\n\n// if defined: darken as point approach zero (south pole)\n// and brighten as approachs infinity (north pole)\n#define POLE_SHADING\n\n// if defined: show a rectangle grid. Number of per unit distance.\n//#define R_GRID 2.0\n\n//--- example tweekables\n\n// if defined limits this example to \n#define BOUNDING_SQUARE\n\n\n// the map to visualize\nvec2 map(vec2 z)\n{\n  return z;  // identity\n}\n\n\n//----------------------\n\n// derived constants\n#define GROW_M  (1.0/(GROW_K+1.0))\n#define GRID_IK (1.0/GRID_K)\n#define PI (52707180.0/16777216.0)\n#define RL (RADIAL_LINES/(2.0*PI))\n\nvec3 hsv2rgb(vec3 c)\n{\n  const vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat grid_step(float t)\n{\n  t = min(t, 1.0-t);\n  return smoothstep(0.0, GRID_K, t);\n}\n\n// lifted domain plot color for point 'c'\nvec3 domainPlot(vec2 c)\n{\n  float d     = dot(c,c);\n  float theta = atan(c.y,c.x);\n  \n  // growth indication\n  float b1 = fract(0.5*log2(d));\n  float b0 = b1+b1;\n  \n  if (b0 >= 1.0) b0 -= 1.0;    // b0 = fract(2*b1) \n    \n  float b = GROW_M*(b0+GROW_K);\n    \n  // concentric grid covers branch-point\n  if (b1 < 0.5) b = 1.0;    \n    \n  // saturation and value\n  float sat = 1.0;\n  float val = 1.0;\n    \n#if defined(POLE_SHADINGx)\n  if (d < 1.0)\n    val *= 0.8;//1.0+d; // inside\n  else \n    sat *= 1.0;\n#endif\n  \n  // rectangular grid\n#if defined(R_GRID)\n  {\n    float x = floor(R_GRID*c.x);\n    float y = floor(R_GRID*c.y);\n    if (mod(x+y,2.0)==1.0) sat*= 0.55;\n  }\n#endif\n    \n  // radial grid (integrated)\n#if defined(RADIAL_GRID) && !defined(RADIAL_GRID_POST)    \n  sat = mix(RADIAL_LINE_STR, sat, grid_step(fract(theta*RL)));   \n#endif\n  \n  // concentric grid (integrated)\n#if defined(CONCENTRIC_GRID) && !defined(CONCENTRIC_GRID_POST)\n  b = mix(0.0, b, grid_step(b0));\n#endif \n  \n  // convert to RGB\n  float hue = theta*(1.0/(2.0*PI));\n  vec3  v   = hsv2rgb(vec3(hue,sat,val))*b;\n    \n  // radial grid (as post effect)\n#if defined(RADIAL_GRID) && defined(RADIAL_GRID_POST) \n  v = mix(rg_color, v, grid_step(fract(theta*RL)));\n#endif\n   \n  // concentric grid (as post effect)\n#if defined(CONCENTRIC_GRID) && defined(CONCENTRIC_GRID_POST)\n  v = mix(cg_color, v, grid_step(b0));\n#endif \n    \n  return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float s  = 0.5*min(iResolution.x,iResolution.y);\n  vec2  uv = (fragCoord.xy - 0.5*iResolution.xy)/s;\n  vec3  c  = domainPlot(map(1.0*uv));\n#if defined(BOUNDING_SQUARE)\n  if (abs(uv.x)>1.0) c=vec3(0.0);\n#endif\n  fragColor = vec4(c,1.0);\n}\n","name":"Image","description":"","type":"image"}]}