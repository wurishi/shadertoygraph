{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n#define PI_OVER_TWO 1.570796\n#define ONE_OVER_PI 0.318310\n#define GR   1.61803398\n\n#define SMALL_FLOAT 0.0001\n#define BIG_FLOAT 1000000.\n\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\n\nfloat g_time         = 0.;\n\n// **************************************************************************\n// UTILITIES\n\n// Rotate the input point around the y-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundYAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x * cosangle  + point.z * sinangle,\n        point.y,\n        point.x * -sinangle + point.z * cosangle);\n}\n\n// Rotate the input point around the x-axis by the angle given as a\n// cos(angle) and sin(angle) argument.  There are many times where  I want to\n// reuse the same angle on different points, so why do the  heavy trig twice.\n// Range of outputs := ([-1.,-1.,-1.] -> [1.,1.,1.])\n\nvec3 rotateAroundXAxis( vec3 point, float cosangle, float sinangle )\n{\n    return vec3(point.x,\n        point.y * cosangle - point.z * sinangle,\n        point.y * sinangle + point.z * cosangle);\n}\n\nfloat pow5(float v)\n{\n    float tmp = v*v;\n    return tmp*tmp*v;\n}\n\n// convert a 3d point to two polar coordinates.\n// First coordinate is elevation angle (angle from the plane going through x+z)\n// Second coordinate is azimuth (rotation around the y axis)\n// Range of outputs - ([PI/2, -PI/2], [-PI, PI])\nvec2 cartesianToPolar( vec3 p ) \n{    \n    return vec2(PI/2. - acos(p.y / length(p)), atan(p.z, p.x));\n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\nfloat spheredf( vec3 pos, float r ) \n{\n    return length( pos ) - r;\n}\n\nfloat innerspheredf( vec3 pos, float r ) \n{\n    return r - length( pos );\n}\n\n\n// **************************************************************************\n// SCENE MARCHING\n\nfloat buckeyballdf(vec3 p, float mr)\n{    \n\n    float balldf = BIG_FLOAT;\n    vec3 ap = abs(p);\n    ap += .05 * normalize(ap) * sin(3. * g_time + ap.x + ap.y);\n    \n    // vertices\n    // fully positive hexagon\n    vec3 p1 = vec3(         .66, .33+.66 * GR,   .33 * GR);\n    vec3 p2 = vec3(         .33, .66+.33 * GR,   .66 * GR);\n    vec3 p3 = vec3(    .33 * GR,          .66, .33+.66*GR);\n    vec3 p4 = vec3(    .66 * GR,          .33, .66+.33*GR);\n    vec3 p5 = vec3(.33+.66 * GR,     .33 * GR,        .66);\n    vec3 p6 = vec3(.66+.33 * GR,     .66 * GR,        .33);\n\n    // fully positive connectors\n    vec3 p7 = vec3(         .33,           GR,         0.);\n    vec3 p8 = vec3(          GR,           0.,        .33);\n    vec3 p9 = vec3(          0.,          .33,         GR);\n\n    balldf = min( balldf, spheredf(ap - p1, mr));\n    balldf = min( balldf, spheredf(ap - p2, mr));\n    balldf = min( balldf, spheredf(ap - p3, mr));\n    balldf = min( balldf, spheredf(ap - p4, mr));\n    balldf = min( balldf, spheredf(ap - p5, mr));\n    balldf = min( balldf, spheredf(ap - p6, mr));\n    balldf = min( balldf, spheredf(ap - p7, mr));\n    balldf = min( balldf, spheredf(ap - p8, mr));\n    balldf = min( balldf, spheredf(ap - p9, mr));\n\n    return balldf;\n}\n\nfloat chamberdf(vec3 p)\n{\n    return 20. - length(p);\n}\n\n#define DISTMARCH_STEPS 60\n#define DISTMARCH_MAXDIST 40.\n\nvec4 shadeChamber(vec3 p)\n{\n    vec2 pp = 100. * cartesianToPolar(p);\n\n    vec2 i = floor(pp);\n    vec2 f = fract(pp);\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int k=-1; k<=1; k++ )\n    {\n        vec2 g = vec2(float(j),float(k));\n        float row = i.x + float(j);\n        float col = i.y + float(k);\n        float oddrow = mod(row, 2.);\n        float rn = texture(iChannel2, vec2(0., row/256.), -100.).r;            \n        vec2 n = vec2(0., \n                      mod(mix(-1., 1., oddrow) * 2. * g_time * rn, 1.));\n\n        vec2 r = g + n - f;\n        float d = dot(r,r) * (2. + sin(g_time + 6.28 * texture(iChannel2, i * vec2(.01, .08), -100.).r));\n\n        if( d<md ) { md = d; }\n    }\n    \n    return vec4(.3 * mix(vec3(.05, .02, 0.5),\n\t\t\t   \t\t\t vec3(.02, .6, 1.),\n\t               \t\t md), 1.);\n}\n\nvec4 shadeBall(float dist)\n{\n    float opacity = smoothstep(.5, .0, dist);\n    opacity *= opacity;\n    return vec4(mix(vec3(1., 1.5,2.), vec3(.0,.1,1.), opacity), opacity);\n}\n    \nvec3 distmarch( vec3 ro, vec3 rd, float maxd )\n{\n\n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    float material = 0.;\n    \n    vec3 scenecol = vec3(0.);\n    float opacity = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        \n        if ( opacity > .95 ) break;\n        if ( abs(dist) < epsilon || t > maxd ) break;\n        // advance the distance of the last lookup\n        t += dist;\n        \n        vec3 pp = ro + t * rd;\n        float buckeyDist = buckeyballdf(pp, .15);\n        float chamberDist = chamberdf(pp);\n        \n        vec4 currCol = vec4(0.);\n        if (buckeyDist < chamberDist)\n        {\n            currCol = shadeBall(buckeyDist);\n            dist = (1. + (3. + 3. * sin(g_time + 6.28 * pp.y)) * currCol.a) * buckeyDist;\n        }\n        else\n        {\n            currCol = shadeChamber(ro + (t + chamberDist) * rd);\n            dist = chamberDist;\n        }\n        \n        scenecol = scenecol + (1. - opacity) * currCol.rgb * currCol.a;\n        opacity = opacity + (1. - opacity) * currCol.a;\n        \n    }\n\n    return scenecol;\n}\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nvoid animateGlobals()\n{\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    vec2 click = iMouse.xy / iResolution.xx;    \n    click = 2.0 * click - 1.0;  \n    \n    g_time = iTime;\n\n    // camera position\n    g_camOrigin = vec3(6.0, 0.0, 6.0);\n    \n    float rotx    = -1. * PI * (.5 * click.y + .45) + .05 * g_time;\n    float cosrotx = cos(rotx);\n    float sinrotx = sin(rotx);\n    \n    float roty    = TWO_PI * click.x + .1 * g_time;\n    float cosroty = cos(roty);\n    float sinroty = sin(roty);\n\n    // Rotate the camera around the origin\n    g_camOrigin = rotateAroundXAxis(g_camOrigin, cosrotx, sinrotx);\n    g_camOrigin = rotateAroundYAxis(g_camOrigin, cosroty, sinroty);\n\n    g_camPointAt   = vec3(0., 0., 0.);\n\n}\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setupCamera( vec2 fragCoord)\n{\n\n    // aspect ratio\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = fragCoord.xy / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + 1.0 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    // ----------------------------------------------------------------------\n    // Animate globals\n\n    animateGlobals();\n\n    // ----------------------------------------------------------------------\n    // Setup Camera\n\n    CameraData cam = setupCamera( fragCoord );\n\n    // ----------------------------------------------------------------------\n    // SCENE MARCHING\n\n    vec3 scenecol = distmarch( cam.origin, \n       cam.dir, \n       DISTMARCH_MAXDIST );\n    \n\n    // ----------------------------------------------------------------------\n    // POST PROCESSING\n    \n    // Gamma correct\n    scenecol = pow(scenecol, vec3(0.45));\n\n    // Contrast adjust - cute trick learned from iq\n    scenecol = mix( scenecol, vec3(dot(scenecol,vec3(0.333))), -0.6 );\n\n    // color tint\n    scenecol = .5 * scenecol + .5 * scenecol * vec3(1., 1., .9);\n    \n    fragColor.rgb = scenecol;\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtlGzX","date":"1423985568","viewed":733,"name":"Buckey Ball","username":"mplanck","description":"Having fun with buckey balls!  Trying to get away with marching artifacts as an effect.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","buckey","plausibleshading"],"hasliked":0,"parentid":"","parentname":""}}