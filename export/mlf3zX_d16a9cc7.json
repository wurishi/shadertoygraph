{"ver":"0.1","info":{"id":"mlf3zX","date":"1672235490","viewed":375,"name":"this is not 3d.","username":"Poisson","description":"A raycaster with a beautiful sunset!","likes":35,"published":1,"flags":32,"usePreview":0,"tags":["2d","3d","raymarching","reflection","ray","sun","raycasting","texture","dof","bokeh","raymarcher","bloom","25d","atmosphere","scatter","raycaster","glare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this is not 3d, you can check.\n\n// I discovered this technique a year ago with this video:\n// https://www.youtube.com/watch?v=mzznRhUA1Tk\n\n/* explanation :\n - for each horizontal line, a ray is casted in a 2d top down scene\n - then we draw a vertical line based on the distance of the hit point and the camera\n - finally we calculate the lighting for the hit point\n*/\n\n// bokeh blur function\n// b is the blur value\nvec4 bokeh(sampler2D sam, vec2 p, float b) {    \n    const int N = 5; // quality\n    \n    vec4 col = vec4(0);\n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++) {\n        vec2 off = vec2(i,j) / float(N); // blur offset\n\n        if (dot(off, off)<1.) { // disk check\n            // blurred texture\n            col.rgb += texture(iChannel0, p + b*off*vec2(9./16.,1)).rgb;\n            col.a += 1.;\n        }\n    }\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    \n    float d = texture(iChannel0, p).w; // depth\n    // base texture with fake dof\n    vec3 col = bokeh(iChannel0, p, .015*smoothstep(3.3,4.,d)).rgb;\n    \n    // postprocessing\n    col = col/(.8+col); // tonemap\n    col = 1.2*pow(col, vec3(.4545)); // gamma correction\n    \n    // bloom\n    vec3 bloom = bokeh(iChannel0, p, .05).rgb;\n    col += .3*bloom;\n        \n    col *= .5+.5*pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y), .1); // vignette\n    col = col*vec3(1.15,1.1,1)-.5*vec3(.1,.2,0); // sunset color\n    \n    // film grain\n    float n = p.x*345.2+p.y*135.43+iTime;\n    col *= .95+.1*fract(sin(n)*2342.243);\n    \n    // old CRT effect\n    //col *= 1.+.2*sin(1000.*p.y+3.*iTime);\n    \n    col = clamp(col,0.,1.);\n              \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define SHOW_MAP\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// box sdf\nfloat sdBox(vec2 p, vec2 s) {\n    vec2 q = abs(p) - s;\n    return length(max(q,0.)) + min(0.,max(q.x,q.y));\n}\n\n// cylinder sdf (disk sdf)\nfloat sdCylinder(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// scene\nfloat map(vec2 p) {\n    float d = 1e10;\n    \n    vec2 q = p;\n    //q *= rot(iTime);\n    d = min(d, sdBox(q,vec2(.5)));\n    d = min(d, sdCylinder(p-vec2(-1,0),.5));\n    d = min(d, sdBox(p-vec2(1,1),vec2(.2,.4))-.1);\n    d = min(d, sdBox(p-vec2(-2,-2),vec2(.5)));\n    d = min(d, sdCylinder(p-vec2(4,-3),.5));\n    d = min(d, sdBox(p-vec2(-4.5,2),vec2(.5)));\n    d = min(d, sdCylinder(p-vec2(4.5,1.5),.5));\n    \n    return d;\n}\n\n// raymarching loop\nfloat intersect(vec2 ro, vec2 rd) {\n    float t = 0.;\n    \n    for (int i=0; i<512 && t<64.; i++) {\n        vec2 p = ro + rd*t; // current point\n        \n        float h = map(p); // distance to the scene\n        if (h<.001) break; // we hit the surface!\n        t += h; // march\n    }\n    return t; // return the distance\n}\n\n// normal estimation\nvec2 calcNormal(vec2 p) {\n    float h = map(p);\n    const vec2 e = vec2(.0001,0);\n    \n    return normalize(h - vec2(map(p-e.xy),\n                              map(p-e.yx)));\n}\n\n// soft shadow function\n// thanks to iq: https://iquilezles.org/articles/rmshadows/\n// k is the softness of the shadow\nfloat shadow(vec2 ro, vec2 rd, float tmax, float k) {\n    float res = 1.;\n    for (float t=0.; t<tmax;) {\n        vec2 p = ro + rd*t;\n        float h = map(p);\n        if (h<.001) return 0.;\n        res = min(res, k*h/t); // find the closest penumbra\n        t += h;\n    }\n    return res*res*(3.-2.*res); // S curve\n}\n\n// background function\nvec3 background(vec2 p) {\n    vec3 col = mix(vec3(.6,.8,1),vec3(.2,.4,1),1.5*p.y); // blue gradient\n    col = mix(col, vec3(.5,.3,.2),pow(1.-p.y,2.)); // brown in the middle\n    return col;\n}\n\n// camera function\nmat2 setCamera(vec2 ro, vec2 ta) {\n    vec2 v = normalize(ta - ro); // forward vector\n    vec2 u = vec2(v.y,-v.x); // side vector, perpendicular to v\n    return mat2(u, v);\n}\n\n// rendering function\nvec4 render(vec2 uv) {\n    // mouse coordinates centered at the origin\n    vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.xy;\n    \n    // sun direction and color\n    vec2 sunDir = normalize(vec2(2.*sin(.5*iTime+.5),2.*cos(.5*iTime+.5)));\n    vec3 sunCol = vec3(1,.8,.6);\n    \n    float fov = radians(60.); // field of view (zoom)\n    float wh = tan(.5*fov); // wall height ratio\n    \n    vec2 ro = vec2(0,-4); // ray origin\n    ro *= rot(2.*m.x*3.141592+.1*iTime); // rotate the origin\n    vec2 ta = vec2(0); // target\n    mat2 ca = setCamera(ro, ta); // camera matrix\n    \n    vec2 rd = ca * normalize(vec2(uv.x,1./wh)); // ray direction\n                \n    vec3 col = background(uv);\n    // sun\n    float glare = clamp(dot(normalize(vec3(rd,uv.y)), normalize(vec3(sunDir,.15))),0.,1.);    \n    col += 2.*vec3(1,.8,.6)*pow(glare,256.);\n    \n    float t = intersect(ro, rd); // distance to the scene\n    float d = t * cos(atan(uv.x*wh))*wh; // lens corrected distance\n    float h = .5/d; // height of the wall line based on the distance\n        \n    // ground\n    if (uv.y<0.) {\n        col = .5*background(-uv); // sky reflection\n        if (t<64.) {\n            float ref = sqrt(abs(uv.y*d+.5));\n            col *= clamp(ref,0.,1.); // objects reflection\n        }\n    }\n     \n    // draw a vertical line from -h to h\n    if (t<64. && abs(uv.y)<h) { // we hit the surface!\n        vec2 p = ro + rd*t; // hit point\n        vec2 n = calcNormal(p); // normal of the surface\n        vec2 r = reflect(rd, n); // reflected vector\n        \n        float dif = clamp(dot(n,sunDir), 0., 1.); // diffuse\n        float bac = clamp(dot(n,-sunDir), 0., 1.); // back diffuse\n        float sha = shadow(p+n*.002, sunDir, 8., 8.); // soft shadow\n        float spe = clamp(dot(r,sunDir), 0., 1.); // specular\n        // ambient occlusion\n        float occ = .5+.5*map(p+n*.1)/.1;\n        occ *= .5+.5*map(p+n*.05)/.05;\n               \n        // calculate the color of the surface\n        vec2 q = vec2(p.y+p.x,uv.y*-d); // texture coordinates\n        vec3 mat = texture(iChannel0, q).rgb; // mapped texture\n        vec4 nyan = texture(iChannel1, q*vec2(.125,1.)-.5);\n        mat = mix(mat,pow(nyan.rgb,vec3(2.2)),nyan.a);\n        \n        // light surface interaction\n        vec3 lin = vec3(0);\n        lin += sunCol*dif*vec3(sha,sha*sha*.3+.7*sha,sha*sha*.2+.8*sha); // sun light\n        lin += vec3(.6,.8,1)*.1*occ; // sky light\n        lin += sunCol*.1*bac*occ; // bounce/back light\n        lin += sunCol*sha*pow(spe,16.); // specular highlight\n        \n        col = mat*lin;\n    }\n    \n    col += smoothstep(1.,2.,t)*.5*sunCol*sunCol*pow(glare,16.); // sun glare\n    \n    // return the color and the distance to the scene (for the dof)\n    return vec4(col, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates centered at the origin\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    #ifdef SHOW_MAP\n    vec4 col = vec4(vec3(smoothstep(.1,-.1,map(p*6.))),1); // show the 2d top down map\n    #else\n    vec4 col = render(p); // (fake) 3d rendering\n    #endif\n    \n    // output\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}