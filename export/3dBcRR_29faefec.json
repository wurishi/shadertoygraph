{"ver":"0.1","info":{"id":"3dBcRR","date":"1585912913","viewed":289,"name":"floating-point precision error","username":"boysx","description":"floating-point precision error in ray marching","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["glitch","error"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.001\n\n// this will move cube and sphere far away from (0, 0)\n#define ORIG_POS 5000000.\n\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float rad)\n{\n\treturn length(p) - rad;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat getDistance(vec3 p)\n{\n    //vec3 pd = vec3(0.,1.,0.);\n    \n    float box = sdBox(p-vec3(ORIG_POS-1.,1.,ORIG_POS), vec3(1., 1., 1.));\n    float sph = sdSphere(p-vec3(ORIG_POS+1.,1.,ORIG_POS), 1.0);\n    \n    return min(p.y, min(box, sph));\n}\n\nfloat raymarch(vec3 ro, vec3 rv)\n{\n    float d = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + d * rv;\n        float dist = getDistance(p);\n        d += dist;\n        if(dist < EPSILON || dist > MAX_DIST) break;\n    }\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDistance(p);\n    vec2 e = vec2(EPSILON, 0.);\n    \n    return normalize(d - vec3(\n        getDistance(p - e.xyy),\n        getDistance(p - e.yxy),\n        getDistance(p - e.yyx)));\n}\n\nvec3 getLight(vec3 p)\n{\n    vec3 lightPos = vec3(ORIG_POS, 5., ORIG_POS-2.);\n    lightPos.xz += vec2(1., 1.) * rotate(iTime);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    float ndotl = clamp(0.0, 1.0, dot(n,l));\n    float shadow = raymarch(p + n * 0.1, l);\n    \n    if(shadow < length(lightPos - p)) ndotl *= 0.1;\n    \n    return vec3(ndotl);\n}\n\nvec3 eval(vec3 ro, vec3 rv)\n{\n    float d = raymarch(ro, rv);\n    vec3 p = ro + d * rv;\n    return getLight(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mp = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(ORIG_POS,1.,ORIG_POS-5.);\n    ro.xz += vec2(1., 1.) * rotate(iTime);\n    vec3 rd = vec3(uv.x, uv.y, 1.);\n    \n    vec3 rv = normalize(rd);\n\n    vec3 col = vec3(eval(ro,rv));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}