{"ver":"0.1","info":{"id":"DsjGRG","date":"1667814853","viewed":240,"name":"Filtering with convolution","username":"Envy24","description":"Filters:\n  Blurs: Box (moving average), Gaussian, Tent (L1_norm), Square (Linf_norm), Circle (L2_norm), motion blur.\n  Other: Sharpen, Emboss, Outline.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["blur","filter","convolution","emboss","gaussian","sharpen","outline","kernel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//https://www.shadertoy.com/view/XdXSzX\n#define AVERAGE(C)         ( vec4(vec3((C.x+C.y+C.z)*0.333), C.w) )\n#define GRAYSCALE_sRGB(C)  ( vec4(vec3(C.x*0.2126+C.y*0.7152+C.z*0.0722), C.w) )\n#define GRAYSCALE_Telev(C) ( vec4(vec3(C.x*0.3+C.y*0.59+C.z*0.11), C.w) )\n\n//                 ( max(/*Your input*/, /*Constrain*/) )\n/*Box blur*\n#define ORDER      ( max(1., 0.) )\n#define FILTER(P)  ( box(P, ORDER) )\n/*Gaussian blur*\n#define SIGMA      ( max(3., 0.) )\n#define ROW_LENGTH ( 4.*SIGMA + 3. )\n#define ORDER      ( max(round(ROW_LENGTH*0.5), 0.) )\n#define FILTER(P)  ( gauss(P, SIGMA) )\n/*Sharpen*\n#define ORDER      ( max(1., 0.) )\n#define FILTER(P)  ( sharpen_a(P, ORDER) )\n//#define FILTER(P)  ( sharpen_b(P, ORDER) )\n/*Emboss*/\n#define ORDER      ( max(1., 0.) )\n#define FILTER(P)  ( emboss_a(P, ORDER) )\n//#define FILTER(P)  ( emboss_b(P, ORDER) )\n/*Outline*\n#define ORDER      ( max(1., 0.) )\n#define FILTER(P)  ( outline(P, ORDER) )\n/*Tent blur (L1 norm)*\n#define ORDER      ( max(7., 0.) )\n#define FILTER(P)  ( tent(P, ORDER) )\n/*Square blur (Linf norm)*\n#define ORDER      ( max(3., 0.) )\n#define FILTER(P)  ( square(P, ORDER) )\n/*Circle blur (L2 norm)*\n#define ORDER      ( max(5., 0.) )\n#define FILTER(P)  ( circle(P, ORDER) )\n/*Motion blur*\n#define ORDER      ( max(8., 0.) )\n#define FILTER(P)  ( motion_blur_a(P, ORDER) )\n//#define FILTER(P)  ( motion_blur_b(P, ORDER) )\n/**/\n\n#define SAMPLER(SC) ( TX0(SC) )\n//#define SAMPLER(SC) ( AVERAGE(TX0(SC)) )\n//#define SAMPLER(SC) ( GRAYSCALE_sRGB(TX0(SC)) )\n//#define SAMPLER(SC) ( GRAYSCALE_Telev(TX0(SC)) )\nvec4 convoluion(vec2 SC)\n{\n    vec4 weighted_sum = vec4(0);\n\n    for (float y = -ORDER; y <= ORDER; y += 1.)\n    {\n        for (float x = ORDER; x >= -ORDER; x -= 1.)\n        {      \n            vec2 offset = vec2(x, y);\n            weighted_sum += SAMPLER(SC + offset) * FILTER(offset);\n        }\n    }\n    \n    return \n        ORDER <= 0. ?\n            SAMPLER(SC) :\n            weighted_sum;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float x = iMouse.x == 0. ? iResolution.x*0.5 : iMouse.x;\n    O =\n        x > SC.x ?\n           SAMPLER(SC) : // bypass \n           convoluion(SC);\n    float d = segmentSDF_L2(SC, vec2(x, 0), vec2(x, iResolution.x), 0.); \n    O = mix(O, vec4(1,0,0,1), smoothstep(1., 0., d));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TX0(SC)                   ( texture(iChannel0, ((SC)/iResolution.xy)) )\n\nfloat bypass(vec2 P, float order) { return P == vec2(0) ? 1. : 0.; }\nfloat box(vec2 P, float order)\n{\n    float row_length = 2.*order + 1.;\n    return \n        order <= 0. ?\n            0. :\n            1. / (row_length*row_length);\n}\nfloat gauss(vec2 P, float sigma)\n{\n    float s = 1. / (2.*3.141592*sigma*sigma);\n\treturn s*exp(-(P.x * P.x + P.y * P.y) / (2.0 * sigma * sigma));\n}\nfloat sharpen_a(vec2 P, float order)\n{\n    float row_length = 2.*order + 1.;\n    float v = P.x == 0. || P.y == 0. ? -1. : 0.;\n    return \n        P == vec2(0) ?\n            2.*row_length-1. :\n            v;      \n}\nfloat sharpen_b(vec2 P, float order)\n{\n    float row_length = 2.*order + 1.;\n    return \n        P == vec2(0) ?\n            row_length*row_length :\n            -1.;      \n}\nfloat emboss_a(vec2 P, float order)\n{\n    float v = P.x < 0. && P.x == -P.y ? 1. : 0.;\n          v = P.x > 0. && -P.x == P.y ? -1. : v;\n    return\n        P.x == 0. && P.y == 0. ?\n            1. :\n            v;\n}\nfloat emboss_b(vec2 P, float order)\n{\n    float h_row_length = (2.*order + 1.) * 0.5001,\n          row_number = -P.y + floor(h_row_length),\n          col_number = P.x + round(h_row_length),\n          v = (2.*h_row_length) - (row_number + col_number);\n    return \n        P == vec2(0) ?\n            1.:\n            v;\n}\nfloat outline(vec2 P, float order)\n{\n    float row_length = 2.*order + 1.;\n    return \n        P == vec2(0) ?\n            row_length*row_length-1. :\n            -1.;  \n}\nfloat tent(vec2 P, float order) // based on L1_norm\n{\n    float row_length = 2. * order + 1.,\n          r = ceil(row_length * 0.5),\n          v = r - (abs(P.x) + abs(P.y)),\n          w = r,\n          m = 4.;\n\n    /* can be precalculated */\n    for (float i = 1.; i <= r; i += 1.) {\n        w += (r-i)*m; m += 4.;\n    }\n\n    return\n        v < 0. ?\n            0. :\n            v / w;\n}\nfloat square(vec2 P, float order) // based on Linf_norm\n{\n    float row_length = 2. * order + 1.,\n          r = ceil(row_length * 0.5),\n          v = r - max(abs(P.x), abs(P.y)),\n          w = r,\n          m = 8.;\n\n\n    for (float i = 1.; i <= r; i += 1.)\n    {\n        w += (r-i)*m;\n        m += 8.;\n    }\n\n    return v / w;\n}\nfloat circle(vec2 P, float order) // based on L2_norm\n{\n    float row_length = 2. * order + 1.,\n        r = round(row_length * 0.5001),\n        rr = r*r,\n        v = rr - dot(P, P);\n\n    float w = 0.;\n    for (float y = -order; y <= order; y += 1.)\n    {\n        for (float x = order; x >= -order; x -= 1.)\n        {      \n            w += rr - dot(vec2(x, y), vec2(x, y));\n        }\n    }\n\n    return v / w;\n}\nfloat motion_blur_a(vec2 P, float order)\n{\n    float h_row_length = ceil((2. * order + 1.) * 0.5001);\n    return \n        P.x >= 0. && P.y == 0. ?\n            1. / h_row_length :\n            0.;\n}\nfloat motion_blur_b(vec2 P, float order)\n{\n    float row_length = 2. * order + 1.;\n    float h_row_length = ceil(row_length * 0.5001);\n    return \n        P.x >= 0. ?\n            1. / (row_length * h_row_length) :\n            0.;\n}\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}","name":"Common","description":"","type":"common"}]}