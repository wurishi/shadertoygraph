{"ver":"0.1","info":{"id":"ssdfz2","date":"1656851761","viewed":186,"name":"My Logo.","username":"VL","description":"Click to reset.","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec3 col = tex.xyz/max(tex.w,1.);\n\n    col = pow(col ,vec3(0.4545));\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define CurrentTime (iTime)\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n\nconst float InvPI = 0.318309886f;\nconst float PId2 = 1.57079632f;\nconst float PI = 3.141592653f;\nconst float PI2 = 6.2831853f;\nconst float MaxDist = 100.f;\nconst float SurfaceDist = 0.0001f;\nconst float FloatMax = 3.402823466e+38F;\n\n\n///////////////////////\n///////  Common  //////       \n///////////////////////\n\nfloat max3(float a, float b, float c)\n{\n    return max(a, max(b, c));\n}\n\nfloat max4(float a, float b, float c, float d)\n{\n    return max(max3(a, b, c), d);\n}\n\nfloat min3(float a, float b, float c)\n{\n    return min(a, min(b, c));\n}\n\nfloat min4(float a, float b, float c, float d)\n{\n    return min(min3(a, b, c), d);\n}\n\nfloat2 minX(float2 a, float2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\nbool closedInterval(float v, float a, float b)\n{\n    return a <= v && v <= b;\n}\n\nbool openInterval(float v, float a, float b)\n{\n    return a < v && v < b;\n}\n\nfloat3x3 viewMatrix(float3 look)\n{\n    float3 right = normalize(cross(float3(0.f, 1.f, 0.f), look));\n    float3 up = cross(look, right);\n    return transpose(float3x3(right, up, look));\n}\n\nfloat3x3 normalMatrix(float3 normal)\n{\n    float3 tz = normalize(cross(float3(1., 0., 0.), normal));\n    float3 tx = cross(normal, tz);\n    return transpose(float3x3(tx, normal, tz));\n}\n\nfloat3x3 identityMatrix3()\n{\n    return float3x3(float3(1., 0., 0.), \n                    float3(0., 1., 0.), \n                    float3(0., 0., 1.));\n}\n\nfloat4x4 identityMatrix4()\n{\n    return float4x4(float4(1., 0., 0., 0.), \n                    float4(0., 1., 0., 0.),\n                    float4(0., 0., 1., 0.), \n                    float4(0., 0., 0., 1.));\n}\n\n#define RayMarching(origin, dir, distFunc, iter, res, more) {\\\n    float _hitDist = 0.f;\\\n    float _mat = 0.f;\\\n    for (int i = 0;i < iter; ++i){\\\n        float3 _ray = (origin) + (_hitDist) * (dir);\\\n        float2 _curr = distFunc(_ray);\\\n        if (_hitDist > MaxDist || _curr.x < SurfaceDist)\\\n            break;\\\n        {more;}\\\n        _mat = _curr.y;\\\n        _hitDist += _curr.x;}\\\n    res = float2(_hitDist, _mat);}\n\n#define GetNormal(ray, distFunc, res) {\\\n    float2 _k = float2(1.f, -1.f);\\\n    res = normalize(_k.xyy * distFunc((ray) + _k.xyy * SurfaceDist).x +\\\n                    _k.yyx * distFunc((ray) + _k.yyx * SurfaceDist).x +\\\n                    _k.yxy * distFunc((ray) + _k.yxy * SurfaceDist).x +\\\n                    _k.xxx * distFunc((ray) + _k.xxx * SurfaceDist).x);}\n\n///////////////////////\n///////  SDF 3D  //////       \n///////////////////////\n\nfloat sdf3dSphere(float3 _point, float4 sphere)\n{\n    return length(_point - sphere.xyz) - sphere.w;\n}\n\nfloat sdf3dInfPlane(float3 _point, float3 plane, float3 planeNormal)\n{\n    return dot((_point - plane), planeNormal);\n}\n\nfloat sdf3dInfCylinder(float3 _point, float4 cylinder, float3 cylinderDirection)\n{\n    _point -= cylinder.xyz;\n    return length(_point - dot(_point, cylinderDirection) * cylinderDirection) - cylinder.w;\n}\n\nfloat sdf3dCapsule(float3 _point, float3 A, float3 B, float radius)\n{\n    float3 ab = B.xyz - A.xyz;\n    float3 ap = _point - A.xyz;\n    float t = saturate(dot(ap, ab) / dot(ab, ab));\n    \n    return length(ap - t * ab) - radius;\n}\n\nfloat sdf3dTorus(float3 _point, float4 torus, float thickness, float3 torusPlaneNormal)\n{\n    _point -= torus.xyz;\n    float projPlaneFactor = dot(_point, torusPlaneNormal);\n    float3 projPlane = _point - projPlaneFactor * torusPlaneNormal;\n    float projPlaneToTorus = length(projPlane) - torus.w;\n    \n    return sqrt(projPlaneToTorus * projPlaneToTorus + projPlaneFactor * projPlaneFactor) - thickness;\n}\n\nfloat sdf3dBox(float3 _point, float3 box, float3 boxSize)\n{\n    _point = abs(_point - box) - boxSize;\n    return length(max(_point, 0.f)) + min(max3(_point.x, _point.y, _point.z), 0.f);\n}\n\nfloat sdf3dBoxFrame(float3 _point, float3 box, float3 boxSize, float3 thickness)\n{\n    float3 exterior = abs(_point - box) - boxSize;\n    float3 frame = abs(exterior + thickness) - thickness;\n   \n    return min3(\n      length(max(float3(exterior.x, frame.y, frame.z), 0.f)) + min(max3(exterior.x, frame.y, frame.z), 0.f),\n      length(max(float3(frame.x, exterior.y, frame.z), 0.f)) + min(max3(frame.x, exterior.y, frame.z), 0.f),\n      length(max(float3(frame.x, frame.y, exterior.z), 0.f)) + min(max3(frame.x, frame.y, exterior.z), 0.f));\n}\n\nfloat sdf3dCylinder(float3 _point, float3 A, float3 B, float radius)\n{\n    float3 ab = B.xyz - A.xyz;\n    float3 pa = _point - A.xyz;\n    \n    float Len_ab = length(ab);\n    float invLen_ab = 1.f / Len_ab;\n    float t = dot(ab, pa) * invLen_ab;\n    float3 proj_ap = A.xyz + t * invLen_ab * ab;\n    \n    float d = length(_point - proj_ap) - radius;\n    float y = (abs(t * invLen_ab - 0.5f) - 0.5f) * Len_ab;\n    \n    float e = length(max(float2(d, y), 0.f));\n    float i = min(max(d, y), 0.f);\n    \n    return e + i;\n}\n\nfloat sdf3dOctahedron(float3 _point, float3 octahedron, float3 size)\n{\n    _point = abs(_point - octahedron.xyz);\n\n    float3 n = normalize(1.f / size);\n    \n    float3 pv0 = float3(_point.x - size.x, _point.yz);\n    float3 v2v0 = float3(-size.x, 0.f, size.z);\n    float3 v1v0 = float3(-size.x, size.y, 0.f);\n    float invDot = 1.f / dot(n, cross(v1v0, v2v0));\n\n    float u = dot(n, cross(pv0, v2v0)) * invDot;\n    float v = dot(n, cross(v1v0, pv0)) * invDot;\n\n    if (0.f <= v && closedInterval(u, 0.f, 1.f) && closedInterval(u + v, 0.f, 1.f))\n    {\n        return sdf3dInfPlane(_point, size * 0.33333333f, n);\n    }\n    else\n    {\n        float3 pv1 = float3(_point.x, _point.y - size.y, _point.z);\n        float3 v2v1 = float3(0.f, -size.y, size.z);\n        \n        return min3(length(pv0 - saturate(dot(pv0, v1v0) / dot(v1v0, v1v0)) * v1v0),\n                    length(pv0 - saturate(dot(pv0, v2v0) / dot(v2v0, v2v0)) * v2v0),\n                    length(pv1 - saturate(dot(pv1, v2v1) / dot(v2v1, v2v1)) * v2v1));\n    }\n}\n\nfloat sdf3dEllipsoid(float3 _point, float3 ellisoid, float3 semiprincipal)\n{\n    //_point -= ellisoid;\n    //float k0 = length(_point / semiprincipal);\n    //float k1 = length(_point / (semiprincipal * semiprincipal));\n    //return k0 * (k0 - 1.f) / k1;\n    \n    return length((_point - ellisoid) / semiprincipal) - 1.f;\n}\n\nfloat sdf3dCone(float3 _point, float4 cone, float3 direction, float height)\n{\n    _point -= cone.xyz + direction * height;\n    \n    float dh = dot(_point, direction);\n    float dr = length(_point - dh * direction);\n    float fp = saturate((cone.w * dr - height * dh) / (height * height + cone.w * cone.w));\n    \n    float dCircle = length(float2(max(dr - cone.w, 0.f), dh + height));\n    \n    float u = dr - fp * cone.w;\n    float v = dh + fp * height;\n    float dCone = length(float2(u, v));\n\n    return (-height < dh && u < 0.f && v < 0.f) ? -min(dCone, dCircle) : min(dCone, dCircle);\n}\n\n\n////\n\nfloat2 hash(float2 p)\n{\n    float3 p3 = frac(float3(p.xyx) * float3(142.1031, 166.1030, 178.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return frac((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat3 hash(float3 p3)\n{\n    p3 = frac(p3 * float3(132.1031, 154.1030, 177.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return frac((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n///////////////////////\n////   intersect   ////       \n///////////////////////\n\n\nfloat planeIntersect(float3 ro, float3 rd, float3 n, float3 p)\n{\n    float nrd = dot(n, rd);\n\n    return dot(n, p - ro) / nrd;\n}\n\nfloat diskIntersect(float3 ro, float3 rd, float3 n, float4 disk)\n{\n    float t = planeIntersect(ro, rd, n, disk.xyz);\n    if (length(disk.xyz - (ro + t * rd)) <= disk.w)\n        return t;\n    else \n        return -1.;\n}\n\nfloat sphereIntersect(float3 ro, float3 rd, float4 p)\n{\n    float3 rop = ro - p.xyz;\n    \n    float b = dot(rop, rd);\n    float ac = dot(rop, rop) - p.w * p.w;\n    \n    float h = b * b - ac;\n    \n    if (h < 0.)\n        return -1.;\n        \n    h = sqrt(h);\n    return -b - h;\n}\n\n///////////////////////\n////      PBR      ////       \n///////////////////////\n\nfloat nCosTheta(float3 w)\n{\n    return w.y;\n}\n\nfloat nCosTheta2(float3 w)\n{\n    return w.y * w.y;\n}\n\nfloat nSinTheta2(float3 w)\n{\n    return max(0., 1. - nCosTheta2(w));\n}\n\nfloat nSinTheta(float3 w)\n{\n    return sqrt(nSinTheta2(w));\n}\n\nfloat nCosPhi(float3 w)\n{\n    float st = nSinTheta(w);\n    return (st == 0.) ? 1. : clamp(w.x / st, -1., 1.);\n}\n\nfloat nSinPhi(float3 w)\n{\n    float st = nSinTheta(w);\n    return (st == 0.) ? 0. : clamp(w.z / st, -1., 1.);\n}\n\nfloat beckmannDistribution(float3 wh, float x, float y)\n{\n    float cosTheta2 = nCosTheta2(wh);\n    if (cosTheta2 == 0.)\n        return 0.;\n        \n    float sinTheta2 = nSinTheta2(wh);\n    float tanTheta2 = sinTheta2 / cosTheta2;\n    float cosPhi = nCosPhi(wh);\n    float sinPhi = nSinPhi(wh);\n   \n    return exp(-tanTheta2 * (cosPhi * cosPhi / (x * x) + sinPhi * sinPhi / (y * y)))\n           / (PI * x * y * cosTheta2 * cosTheta2);\n}\n\nfloat3 beckmannWh(float3 wo, float3 p, float x, float y, float3x3 trans)\n{\n    float3 rand = hash(p);\n    float phiH = atan(tan(PI2 * rand.y) * y / x);\n    float cosPhiH = cos(phiH);\n    float sinPhiH = sin(phiH);\n    \n    float logX = log(rand.x);\n    float tanThetaH2 = -logX / (cosPhiH * cosPhiH / (x * x) + sinPhiH * sinPhiH / (y * y));\n    \n    float cosThetaH = 1. / sqrt(1. + tanThetaH2);\n    float sinThetaH = sqrt(max(1. - cosThetaH * cosThetaH, 0.));\n    \n    return mul(transpose(trans), float3(cosPhiH * sinThetaH, cosThetaH, sinPhiH * sinThetaH));\n}\n\nfloat beckmannLamda(float3 w, float x, float y)\n{\n    float cosTheta2 = nCosTheta2(w);\n    if (cosTheta2 == 0.)\n        return 0.;\n        \n    float sinTheta2 = nSinTheta2(w);\n    float tanTheta2 = sinTheta2 / cosTheta2;\n    float cosPhi = nCosPhi(w);\n    float sinPhi = nSinPhi(w);\n    \n    float alpha = sqrt(cosPhi * cosPhi * x * x + sinPhi * sinPhi * y * y);\n    float a = 1. / (alpha * sqrt(tanTheta2));\n    if (a >= 1.6)\n        return 0.;\n    return (1. - 1.259 * a + 0.396 * a * a) / (3.535 * a + 2.181 * a * a);\n}\n\nfloat fresnelDielectric(float cosThetaI, float etaI, float etaT)\n{\n    if (cosThetaI < 0.)\n    {\n        cosThetaI = -cosThetaI;\n        float tmp = etaI;\n        etaI = etaT;\n        etaT = tmp;\n    }\n    float sinThetaI = sqrt(1. - cosThetaI * cosThetaI);\n    \n    float sinThetaT = (etaI / etaT) * sinThetaI;\n    \n    if (sinThetaT >= 1.) \n        return 1.;\n    float cosThetaT = sqrt(1. - sinThetaT * sinThetaT);\n    \n    float rParl = (etaT * cosThetaI - etaI * cosThetaT) / (etaT * cosThetaI + etaI * cosThetaT);\n    float rPerp = (etaI * cosThetaI - etaT * cosThetaT) / (etaI * cosThetaI + etaT * cosThetaT);\n    \n    return 0.5 * (rParl * rParl + rPerp * rPerp);\n}\n\nfloat3 fresnelConductor(float cosThetaI, float3 n, float3 etaI, float3 etaT, float3 k)\n{\n    float3 eta = etaT / etaI;\n    float3 etak = k / etaI;\n    \n    float cosThetaI2 = cosThetaI * cosThetaI;\n    float sinThetaI2 = 1. - cosThetaI2;\n    float3 eta2 = eta * eta;\n    float3 etak2 = etak * etak;\n\n    float3 t0 = eta2 - etak2 - sinThetaI2;\n    float3 a2plusb2 = sqrt(t0 * t0 + 4. * eta2 * etak2);\n    float3 t1 = a2plusb2 + cosThetaI2;\n    float3 a = sqrt(0.5 * (a2plusb2 + t0));\n    float3 t2 = 2. * cosThetaI * a;\n    float3 Rs = (t1 - t2) / (t1 + t2);\n\n    float3 t3 = cosThetaI2 * a2plusb2 + sinThetaI2 * sinThetaI2;\n    float3 t4 = t2 * sinThetaI2;\n    float3 Rp = Rs * (t3 - t4) / (t3 + t4);\n\n    return 0.5 * (Rp + Rs);\n}\n\nfloat3 beckmannBSDF(float3 wo, float3 wi, float3 n, float3x3 trans, float3 etaI, float3 etaT, float3 k, float x, float y)\n{\n    float cosThetaO = max(dot(n, wo), 0.);\n    float cosThetaI = max(dot(n, wi), 0.);\n    \n    if (cosThetaO == 0. || cosThetaI == 0.)\n        return vec3(0.);\n        \n    float3 wh = wo + wi;\n    float lenH = length(wh);\n    if (lenH == 0.)\n        return vec3(0.);\n    wh /= lenH;\n    \n    float3 fr = fresnelConductor(cosThetaI, wh, etaI, etaT, k);\n    float d = beckmannDistribution(mul(trans, wh), x, y);\n    float g = 1. / (1. + beckmannLamda(mul(trans, wo), x, y) + beckmannLamda(mul(trans, wi), x, y));\n    \n    return fr * d * g / (4. * cosThetaI * cosThetaO);\n}\n\nfloat beckmannPDF(float3 wo, float3 wi, float3 n, float3x3 trans, float x, float y)\n{\n    float3 wh = wo + wi;\n    float lenH = length(wh);\n    if (lenH == 0.)\n        return 0.;\n    wh /= lenH;\n    \n    float d = beckmannDistribution(mul(trans, wh), x, y) * max(dot(n, wh), 0.);\n    float odh = 4. * max(dot(wo, wh), 0.);\n    if (odh == 0.)\n        return 0.;\n    return d / odh;\n}\n\nfloat3 fresnelBlendBSDF(float3 p, float3 wo, float3 wi, float3 n, float3x3 trans, float3 Rd, float3 Rs, float x, float y)\n{\n    float3 wh = wo + wi;\n    float lenH = length(wh);\n    if (lenH == 0.)\n        return vec3(0.);\n    wh /= lenH;\n    \n    float cosThetaI = max(dot(n, wi), 0.);\n    float cosThetaO = max(dot(n, wo), 0.);\n    float idh = max(dot(wi, wh), 0.);\n    if (idh == 0.)\n        return vec3(0.);\n    \n    float3 diffuse = (28. / (23. * PI)) * Rd * (1. - Rs) * (1. - pow(1. - 0.5 * cosThetaI, 5.)) * (1. - pow(1. - 0.5 * cosThetaO, 5.));\n    float3 specular = (Rs + pow(1. - idh, 5.) * (1. - Rs)) * beckmannDistribution(mul(trans, wh), x, y) / (4. * idh * max(cosThetaI, cosThetaO));\n    \n    return diffuse + specular;\n}\n\nfloat fresnelBlendPDF(float3 wo, float3 wi, float3 n, float3x3 trans, float x, float y)\n{\n    return 0.5 * (max(dot(n, wi), 0.) / PI + beckmannPDF(wo, wi, n, trans, x, y));\n}\n\nfloat trowbridgeReitzDistribution(float3 wh, float x, float y)\n{\n    float cosTheta2 = nCosTheta2(wh);\n    if (cosTheta2 == 0.)\n        return 0.;\n        \n    float sinTheta2 = nSinTheta2(wh);\n    float tanTheta2 = sinTheta2 / cosTheta2;\n    float cosPhi = nCosPhi(wh);\n    float sinPhi = nSinPhi(wh);\n    \n    float t = 1. + tanTheta2 * (cosTheta2 / (x * x) + sinTheta2 / (y * y));\n    \n    return 1. / (PI * x * y * cosTheta2 * cosTheta2 * t * t);\n}\n\nfloat trowbridgeReitzLamda(float3 w, float x, float y)\n{\n    float cosTheta2 = nCosTheta2(w);\n    if (cosTheta2 == 0.)\n        return 0.;\n        \n    float sinTheta2 = nSinTheta2(w);\n    float tanTheta2 = sinTheta2 / cosTheta2;\n    float cosPhi = nCosPhi(w);\n    float sinPhi = nSinPhi(w);\n    float alpha = sqrt(cosPhi * cosPhi * x * x + sinPhi * sinPhi * y * y);\n    \n    return 0.5 * (-1. + sqrt(1. + alpha * alpha * tanTheta2));\n}\n\nfloat3 trowbridgeReitzWh(float3 wo, float3 p, float x, float y, float3x3 trans)\n{\n    float3 rand = hash(p);\n    float phiH = atan(tan(PI2 * rand.y) * y / x);\n    float cosPhiH = cos(phiH);\n    float sinPhiH = sin(phiH);\n    \n    float tanThetaH2 = rand.x / (1. - rand.x) * 1. / (cosPhiH * cosPhiH / (x * x) + sinPhiH * sinPhiH / (y * y));\n    \n    float cosThetaH = 1. / sqrt(1. + tanThetaH2);\n    float sinThetaH = sqrt(max(1. - cosThetaH * cosThetaH, 0.));\n    \n    return mul(transpose(trans), float3(cosPhiH * sinThetaH, cosThetaH, sinPhiH * sinThetaH));\n}\n\nfloat3 trowbridgeReitzBSDF(float3 wo, float3 wi, float3 n, float3x3 trans, float3 etaI, float3 etaT, float3 k, float x, float y)\n{\n    float cosThetaO = max(dot(n, wo),0.);\n    float cosThetaI = max(dot(n, wi),0.);\n    \n    if (cosThetaO == 0. || cosThetaI == 0.)\n        return vec3(0.);\n        \n    float3 wh = wo + wi;\n    float lenH = length(wh);\n    if (lenH == 0.)\n        return vec3(0.);\n    wh /= lenH;\n    \n    float3 fr = fresnelConductor(cosThetaI, wh, etaI, etaT, k);\n    float d = trowbridgeReitzDistribution(mul(trans, wh), x, y);\n    float g = 1. / (1. + trowbridgeReitzLamda(mul(trans, wo), x, y) + trowbridgeReitzLamda(mul(trans, wi), x, y));\n    \n    return fr * d * g / (4. * cosThetaI * cosThetaO);\n}\n\nfloat trowbridgeReitzPDF(float3 wo, float3 wi, float3 n, float3x3 trans, float x, float y)\n{\n    float3 wh = wo + wi;\n    float lenH = length(wh);\n    if (lenH == 0.)\n        return 0.;\n    wh /= lenH;\n    \n    float d = trowbridgeReitzDistribution(mul(trans, wh), x, y) * max(dot(n, wh), 0.);\n    float odh = 4. * max(dot(wo, wh), 0.);\n    if (odh == 0.)\n        return 0.;\n    return d / odh;\n}\n\nfloat diffusePDF(float3 wi, float3  n)\n{\n    return max(dot(wi, n), 0.) / PI;\n}\n\nfloat lambertianBSDF()\n{\n    return InvPI;\n}\n\nfloat orenNayarBSDF(float sigma, float3 wo, float3 wi, float3x3 trans)\n{\n    wo = mul(trans, wo);\n    wi = mul(trans, wi);\n    \n    float cosThetaI = abs(nCosTheta(wi));\n    float sinThetaI = nSinTheta(wi);\n    \n    float cosThetaO = abs(nCosTheta(wo));\n    float sinThetaO = nSinTheta(wo);\n    \n    float cosPhiI = nCosPhi(wi);\n    float sinPhiI = nSinPhi(wi);\n        \n    float cosPhiO = nCosPhi(wo);\n    float sinPhiO = nSinPhi(wo);\n        \n    float cosPhiIO = max(cosPhiI * cosPhiO + sinPhiI * sinPhiO, 0.);\n    \n    float sinMax = cosThetaI > cosThetaO ? sinThetaO : sinThetaI;\n    float tanMax = cosThetaI > cosThetaO ? sinThetaI / cosThetaI : sinThetaO / cosThetaO;\n    \n    float sigma2 = sigma * sigma;\n    float A = 1. - sigma2 / (2. * (sigma2 + 0.33));\n    float B = 0.45 * sigma2 / (sigma2 + 0.09);\n    \n    return (A + B * cosPhiIO * sinMax * tanMax) / 3.141592;\n}\n\nfloat henyeyGreensteinPhase(float cosTheta, float g)\n{\n    float denom = 1. + g * g + 2. * g * cosTheta;\n    return (1. - g * g) / (denom * sqrt(denom) * 4. * PI);\n}\n\nfloat3 henyeyGreensteinWi(float3 p, float g)\n{\n    float3 rand = hash(p);\n    float sqrTerm = (1. - g * g) / (1. + g - 2. * g * rand.x);\n    float cosTheta = -(1. + g * g - sqrTerm * sqrTerm) / (2. * g);\n    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));\n    float phi = PI2 * rand.y;\n    float cosPhi = cos(phi);\n    float sinPhi = sin(phi);\n    \n    return float3(sinTheta * cosPhi, cosTheta, sinTheta * sinPhi);\n}\n\n///////////////////////\n////      area     ////       \n///////////////////////\n\nfloat diskArea(float r)\n{\n    return r * r * PI;\n}\n\nfloat sphereArea(float r)\n{\n    return 4. * PI * r * r;\n}\n\nfloat triangleArea(float w, float h)\n{\n    return 0.5 * w * h;\n}\n\n///////////////////////\n////    sampling   ////       \n///////////////////////\n\nfloat2 triangleSampling(float3 p)\n{\n    float3 rand = hash(p);\n    float sqrtXi = sqrt(rand.x);\n    float u = 1. - sqrtXi;\n    float v = sqrtXi * rand.y;\n    return float2(u, v);\n}\n\nfloat2 diskSampling(float3 p)\n{\n    float3 rand = hash(p);    \n    float x = sqrt(rand.x) * cos(PI2 * rand.y);\n    float y = sqrt(rand.x) * sin(PI2 * rand.y);\n    return float2(x, y);\n}\n\nfloat3 cosHemisphereSampling(float3 p)\n{\n    float2 disk = diskSampling(p);\n    float x = disk.x;\n    float y = disk.y;\n    float z = sqrt(1. - x * x - y * y);    \n    return float3(x, y, z);\n}\n\nfloat scatteringRaySampling(float3 p, float3 sigmaT)\n{\n    float3 rand = hash(p);\n    return -log(rand.x) / sigmaT[uint(ceil(rand.y * 2.9999))];\n}\n\n\n////\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * h * k * (1.0 / 6.0);\n}\n\nfloat segment(float3 _point, float4 A, float4 B)\n{\n    float3 ab = B.xyz - A.xyz;\n    float3 ap = _point - A.xyz;\n    float t = saturate(dot(ap, ab) / dot(ab, ab));\n    return length(ap - t * ab) - lerp(A.w, B.w, t);\n}\n\nfloat logo(float3 ray)\n{\n    ray *= 2.5f;\n    ray.y += 1.5f;\n    \n    float dist = sdf3dCapsule(float3(ray.x, ray.y*0.9f, ray.z * 1.4f), float3(-0.25f, 2.f, 0.f), float3(0.25f, 2.f, 0.f), 0.55f);\n    dist = smin(dist, sdf3dCapsule(ray, float3(0.45f, 2.f, 0.f), float3(0.45f, -1.5f, 0.f), 0.25f), 0.2f);\n    \n    dist = min(dist, sdf3dCapsule(float3(ray.x, ray.y, ray.z * 1.8f), float3(-2.5f, 1.2f, 0.f), float3(-2.1f, 1.4f, 0.f), 0.55f));\n    dist = smin(dist, sdf3dCapsule(ray, float3(-1.9f, 1.5f, 0.f), float3(-0.2f, -1.7f, 0.f), 0.25f), 0.2f);\n    \n    dist = smin(dist,\n    segment(float3(ray.x, ray.y * 0.8f, ray.z * abs(ray.y) * 0.9f), float4(0.6f, -1.5f, 0.f, 0.71f), float4(1.5f, -1.3f, 0.f, 0.4f)), 0.6f);\n    dist = smin(dist, segment(float3(ray.x, ray.y, ray.z * 2.f), float4(0.3f, -1.8f, 0.f, 0.6f), float4(0.4f, -3.5f, 0.f, 0.f)), 1.f);\n    \n    float x = abs(ray.x);\n    ray.y -= exp(x * 1.3f) * 0.006f + 0.2f;\n    ray.z *= abs(ray.y) * 0.9f;\n    dist = smin(dist, segment(ray, float4(1.3f, -1.9f, 0.f, 0.55f), float4(4.5f, -1.5f, 0.f, 0.02f)), 0.1f);\n    \n    return dist * 0.1;\n}\n\nfloat2 GetDist(float3 ray)\n{\n    float2 d = float2(logo(ray), 0.);\n    d = minX(d, float2(sdf3dBoxFrame(ray, float3(0., 3., 0.), vec3(5.05), vec3(0.05)) - 0.05, 8.));\n    return d;\n}\n\nconst float4 lightPos = float4(0., 8., 0., 3.);\nconst uint logoIdx = 0u;\nconst uint planeIdx = 1u;\nconst uint lightIdx = 6u;\nconst uint scatteringIdx = 7u;\nconst uint frameIdx = 8u;\n\nfloat2 GetIntersection(float3 ro, float3 rd)\n{\n    float2 tmin = float2(MaxDist, 7.);\n    \n    float pl = planeIntersect(ro, rd, float3(0., 1., 0.), float3(0., -2., 0.));\n    if(pl > 0.)\n        tmin = float2(pl, 1.);\n    \n    pl = planeIntersect(ro, rd, float3(1., 0., 0.), float3(-5., 0., 0.));\n    if(pl > 0. && pl < tmin.x)\n        tmin = float2(pl, 2.);\n    \n    pl = planeIntersect(ro, rd, float3(-1., 0., 0.), float3(5., 0., 0.));\n    if (pl > 0. && pl < tmin.x)\n        tmin = float2(pl, 3.);\n    \n    pl = planeIntersect(ro, rd, float3(0., 0., -1.), float3(0., 0., 5.));\n    if (pl > 0. && pl < tmin.x)\n        tmin = float2(pl, 4.);\n    \n    pl = planeIntersect(ro, rd, float3(0., 0., 1.), float3(0., 0., -5.));\n    if (pl > 0. && pl < tmin.x)\n        tmin = float2(pl, 5.);\n\n    float disk = diskIntersect(ro, rd, float3(0., -1., 0.), lightPos);\n    if (disk > 0. && disk < tmin.x)\n        tmin = float2(disk, 6.);\n    \n    return tmin;\n}\n\nfloat3 GetIntersectNormal(uint idx)\n{\n    vec3 sw[7] = \n    vec3[7](float3(0.),\n            float3(0., 1., 0.),\n            float3(1., 0., 0.),\n            float3(-1., 0., 0.),\n            float3(0., 0., -1.),\n            float3(0., 0., 1.),\n            float3(0., -1., 0.));\n    \n    return sw[idx];\n}\n\nfloat2 rayIntersetion(float3 rayOrigin, float3 rayDir)\n{\n    float2 march;\n    RayMarching(rayOrigin, rayDir,GetDist, 100, march, 0);\n    march = minX(march, GetIntersection(rayOrigin, rayDir));\n    return march;\n}\n\nfloat4 VL(float2 uv, float3 seed)\n{    \n    float3 rayTarget = float3(0., -0.7, 0.);\n    float3 rayOrigin = float3(0., -0.7, -4.9);\n    float3 rayDir = normalize(float3(uv, 1.));\n    float3x3 view = viewMatrix(normalize(rayTarget - rayOrigin));\n    rayDir = mul(rayDir, view);    \n    \n    float3 sigmaS = float3(0.16, 0.16, 0.155)*0.5;\n    float3 sigmaA = float3(0.025, 0.025, 0.025);\n    float3 sigmaT = sigmaS + sigmaA;\n    float3 lightColor = float3(4.3, 4.5, 5.3) * 2.;\n    float3 color = float3(0.f);\n    float3 beta = float3(1.f);\n    bool specBounce = true;\n    for (uint bounce = 0u; bounce < 10u; ++bounce)\n    {\n        float2 march = rayIntersetion(rayOrigin, rayDir);    \n        uint idx = uint(round(march.y));\n        \n        seed.z += 0.01;\n        float scatteringRayT = min(scatteringRaySampling(rayOrigin + seed, sigmaT), FloatMax);\n        float3 Tr;\n        float scatteringPdf = 0.;        \n        if (scatteringRayT < march.x || idx == scatteringIdx)\n        {\n            Tr = exp(-sigmaT * scatteringRayT);\n            scatteringPdf += dot(Tr, sigmaT) / 3.;\n            Tr *= sigmaS;\n            idx = scatteringIdx;\n            march.x = scatteringRayT;\n        }\n        else\n        {\n            Tr = exp(-sigmaT * march.x);\n            scatteringPdf += dot(Tr, vec3(1.)) / 3.;\n        }\n        beta *= scatteringPdf > 0. ? Tr / scatteringPdf : Tr;\n        \n        rayOrigin = rayOrigin + rayDir * march.x;\n        float3 normal;\n        if (idx == logoIdx || idx == frameIdx)\n        {\n            GetNormal(rayOrigin, GetDist, normal);\n        }\n        else if (idx == scatteringIdx)\n        {\n            normal = -rayDir;\n        }\n        else\n        {\n            normal = GetIntersectNormal(idx);\n        }\n        rayOrigin += normal * 0.001;\n\n        if (specBounce && idx == lightIdx && dot(float3(0., -1., 0.), -rayDir) > 0.)\n        {\n            color += beta * lightColor;\n        }\n        \n        seed.x += 0.01;\n        float2 disk = diskSampling(rayOrigin + seed) * lightPos.w;\n        float3 lightSample = float3(disk.x, lightPos.y, disk.y);\n        float3 lightWi = normalize(lightSample - rayOrigin);\n        float shadow = float(uint(round(rayIntersetion(rayOrigin, lightWi).y)) == lightIdx);\n        float areaCos = dot(float3(0., -1., 0.), -lightWi) * diskArea(lightPos.w);\n        float lightPdf = areaCos > 0. ? dot(lightSample - rayOrigin, lightSample - rayOrigin) / areaCos : 0.;\n        \n        \n        float3x3 normTrans = normalMatrix(normal);\n        float3 f = vec3(0.);\n        float3 lightF = vec3(0.);\n        float pdf = 0.;\n        float3 wi = vec3(0.);\n        seed.y += 0.01;\n        if (idx == logoIdx)\n        {\n            float x = 0.2;\n            float y = 0.1;\n            float3 etaT = float3(0.1428, 0.3741, 1.4394);\n            float3 k = float3(1.6, 2.3807, 3.9747);\n            float3 R = float3(0.2, 0.3, 0.5)*1.5;\n            lightF = R * beckmannBSDF(-rayDir, lightWi, normal, normTrans, vec3(1.), etaT, k, x, y);\n            \n            float3 wh = beckmannWh(-rayDir, rayOrigin + seed, x, y, normTrans);\n            wi = reflect(rayDir, wh);\n            \n            f = R * beckmannBSDF(-rayDir, wi, normal, normTrans, vec3(1.), etaT, k, x, y);\n            pdf = beckmannPDF(-rayDir, wi, normal, normTrans, x, y);\n        }\n        else if (idx == planeIdx)\n        {\n            float x = 0.1;\n            float y = 0.2;\n            float3 Rd = float3(0.2, 0.3, 0.5);\n            float3 Rs = float3(0.5, 0.3, 0.5);\n            lightF = fresnelBlendBSDF(rayOrigin + seed, -rayDir, lightWi, normal, normTrans,Rd,Rs,x,y);\n            \n            float3 wh = beckmannWh(-rayDir, rayOrigin + seed, x, y, normTrans);\n            wi = reflect(rayDir, wh);\n            \n            seed.x += 0.01;\n            f = fresnelBlendBSDF(rayOrigin + seed, -rayDir, wi, normal, normTrans, Rd, Rs, x, y);\n            pdf = fresnelBlendPDF(-rayDir, wi, normal, normTrans, x, y);\n        }\n        else if(idx == lightIdx)\n        {\n            f = vec3(0.5) / PI;\n            lightF = f;\n            wi = mul(transpose(normTrans), cosHemisphereSampling(rayOrigin + seed));\n            if (dot(normal, wi) < 0.)\n                wi = -wi;\n            pdf = max(dot(normal, wi), 0.) / PI;\n        }\n        else if(idx == frameIdx)\n        {\n            f = vec3(0.1) / PI;\n            lightF = f;\n            wi = mul(transpose(normTrans), cosHemisphereSampling(rayOrigin + seed));\n            if (dot(normal, wi) < 0.)\n                wi = -wi;\n            pdf = max(dot(normal, wi), 0.) / PI;\n        }\n        else if (idx == scatteringIdx)\n        {\n            lightF = vec3(henyeyGreensteinPhase(dot(-rayDir, lightWi), 0.67));\n            wi = mul(transpose(normTrans), henyeyGreensteinWi(rayOrigin + seed, 0.67));\n            f = vec3(henyeyGreensteinPhase(dot(-rayDir, wi), 0.67));\n            pdf = f.x;\n        }\n        else\n        {\n            wi = reflect(rayDir, normal);\n        }\n       \n        float pdfSquareSum = lightPdf * lightPdf + pdf * pdf;\n        if(pdfSquareSum > 0.)\n        {\n            if(idx != scatteringIdx)\n            {\n                color += lightPdf > 0. ? beta * lightF * lightColor * max(dot(normal, lightWi), 0.) * lightPdf * shadow / pdfSquareSum : vec3(0.);\n            \n                shadow = float(uint(round(rayIntersetion(rayOrigin, wi).y)) == lightIdx);\n                color += pdf > 0. ? beta * f * lightColor * max(dot(normal, wi), 0.) * pdf * shadow / pdfSquareSum : vec3(0.);\n            }\n            else\n            {\n                color += lightPdf > 0. ? beta * lightF * lightColor * lightPdf * shadow * exp(-sigmaT * length(lightSample - rayOrigin)) / pdfSquareSum : vec3(0.);\n            \n                float2 is = rayIntersetion(rayOrigin, wi);\n                shadow = float(uint(round(is.y)) == lightIdx);\n                color += pdf > 0. ? beta * f * lightColor * pdf * shadow * exp(-sigmaT * (is.x >= MaxDist ? FloatMax : is.x)) / pdfSquareSum : vec3(0.);\n            }\n        }\n        \n        \n        seed.z += 0.01;\n        if (idx == logoIdx)\n        {\n            float x = 0.2;\n            float y = 0.1;\n            float3 etaT = float3(0.1428, 0.3741, 1.4394);\n            float3 k = float3(1.6, 2.3807, 3.9747);\n            float3 R = float3(0.2, 0.3, 0.5)*1.5;\n\n            float3 wh = beckmannWh(-rayDir, rayOrigin + seed, x, y, normTrans);\n            wi = reflect(rayDir, wh);\n            f = R * beckmannBSDF(-rayDir, wi, normal, normTrans, vec3(1.), etaT, k, x, y);\n            pdf = beckmannPDF(-rayDir, wi, normal, normTrans, x, y);\n            specBounce = false;\n        }\n        else if (idx == planeIdx)\n        {\n            float x = 0.1;\n            float y = 0.2;\n            float3 Rd = float3(0.2, 0.3, 0.5);\n            float3 Rs = float3(0.5, 0.3, 0.5);\n            float3 wh = beckmannWh(-rayDir, rayOrigin + seed, x, y, normTrans);\n            wi = reflect(rayDir, wh);\n            f = fresnelBlendBSDF(rayOrigin + seed, -rayDir, wi, normal, normTrans, Rd, Rs, x, y);\n            pdf = fresnelBlendPDF(-rayDir, wi, normal, normTrans, x, y);\n            specBounce = false;\n        }\n        else if (idx == lightIdx)\n        {\n            wi = mul(transpose(normTrans), cosHemisphereSampling(rayOrigin + seed));\n            if (dot(normal, wi) < 0.)\n                wi = -wi;\n            f = vec3(0.5) / PI;\n            pdf = max(dot(normal, wi), 0.) / PI;\n            specBounce = false;\n        }\n        else if(idx == frameIdx)\n        {\n            wi = mul(transpose(normTrans), cosHemisphereSampling(rayOrigin + seed));\n            if (dot(normal, wi) < 0.)\n                wi = -wi;\n            f = vec3(0.1) / PI;\n            pdf = max(dot(normal, wi), 0.) / PI;\n            specBounce = false;\n        }\n        else if(idx == scatteringIdx)\n        {\n            f = vec3(1.);\n            wi = mul(transpose(normTrans), henyeyGreensteinWi(rayOrigin + seed, 0.67));\n            pdf = max(dot(normal, wi), 0.);\n            specBounce = false;\n        }\n        else\n        {\n            wi = reflect(rayDir, normal);\n            f = vec3(0.98);\n            pdf = max(dot(normal, wi), 0.);\n            specBounce = true;\n        }\n         \n        beta *= pdf > 0. ? f * max(dot(normal, wi), 0.) / pdf : vec3(0.);\n        \n        if (beta.r <= 0. && beta.g <= 0. && beta.b <= 0.)\n            break;\n        rayDir = wi;\n    }\n    \n    return float4(color, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offs = -0.5 + hash(fragCoord);\n    vec2 uv = (2.0*(fragCoord+offs)-iResolution.xy)/iResolution.y;\n    \n    float4 col = VL(uv, vec3(iTime));\n        if(iFrame == 0 || iMouse.z > 0.)\n        fragColor = col;\n    else\n        fragColor = texture( iChannel0, fragCoord/iResolution.xy) + col;\n}","name":"Buffer A","description":"","type":"buffer"}]}