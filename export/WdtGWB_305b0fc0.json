{"ver":"0.1","info":{"id":"WdtGWB","date":"1569246693","viewed":88,"name":"Ray Marching with reflection","username":"Varandunil","description":"Ray Marching","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 120\n#define MAX_DIST 120.\n#define SURF_DIST .01\n\nstruct Sphere {\n    vec4 point;\n    vec3 color;\n    float transp;\n    float shiny;\n};\n\nstruct Hit {\n\tfloat distance;\n    vec3 point;\n    vec3 normal;\n    vec3 color;\n    vec3 light;\n    float transp;\n    float shiny;\n    vec3 center;\n};\n    \nHit TestScene(vec3 p) {\n    Sphere spheres[5] = Sphere[](\n    \tSphere(vec4(0, 1, 6, 1), vec3(1, 0, 0), 0.8, 0.2),\n        Sphere(vec4(1.7, 0.7, 6, 0.7), vec3(0.1, 0.5, 1), 0.5, 0.2),\n        Sphere(vec4(-1.5, 1, 10, 1), vec3(1, 0.7, 0.1), 0.5, 0.2),\n        Sphere(vec4(1.5, 2, 10, 2), vec3(0.5, 0.6, 0.9), 0.5, 0.8),\n        Sphere(vec4(-3, 1.3, 6, 1.3), vec3(0.2, 1, 0.5), 0.8, 0.2)\n    );\n    \n    Hit hit = Hit(\n    \tp.y - 0.48 + (sin((p.x + iTime) * 1.33) * 0.2) + (cos((p.z + iTime) * 1.5) * 0.2),\n        p,\n        vec3(0),\n        vec3(0.1, 0.3 + cos(p.x) * 0.2, 0.7),\n        vec3(0),\n        0.6,\n        0.6,\n        vec3(0)\n    );\n    \n    for(int i = 0 ; i < spheres.length() ; i++){\n        Sphere s = spheres[i];\n        vec3 pos = vec3(s.point.x + sin(float(i) + iTime), s.point.y, s.point.z + cos(float(i) + iTime));\n        float sd = length(p - pos) - s.point.w;\n        \n        //float k = 0.05;\n        //float h = clamp( 0.5+0.5*(sd-hit.distance)/k, 0.0, 1.0 );\n        //sd = mix( sd, hit.distance, h ) - k*h*(1.0-h);\n        \n        if(sd < hit.distance) {\n            hit.distance = sd;\n            hit.color = s.color;\n            hit.transp = s.transp;\n            hit.shiny = s.shiny;\n            hit.center = s.point.xyz;\n        }\n    }\n\n    return hit;\n}\n\nHit SendRay(vec3 origin, vec3 direction) {\n\tHit hit = TestScene(origin);\n    float t = hit.distance;\n    \n    for(int i = 0 ; i < MAX_STEPS - 1 ; i++) {\n    \tvec3 p = origin + direction * t;\n        hit = TestScene(p);\n        t += hit.distance;\n        if(t > MAX_DIST || hit.distance < SURF_DIST) break;\n    }\n    \n    return hit;\n}\n\nHit findOutside(vec3 origin, vec3 direction) {\n\tHit hit = TestScene(origin);\n    float t = abs(hit.distance);\n    \n    for(int i = 0 ; i < MAX_STEPS - 1 ; i++) {\n    \tvec3 p = origin + direction * t;\n        hit = TestScene(p);\n        t += abs(hit.distance) + 0.01;\n        if(t > MAX_DIST || hit.distance >= 0.01) break;\n    }\n    \n    return hit;\n}\n\nHit AddNorm(Hit hit) {\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = hit.distance - vec3(\n        TestScene(hit.point - e.xyy).distance,\n        TestScene(hit.point - e.yxy).distance,\n        TestScene(hit.point - e.yyx).distance);\n\n    hit.normal = normalize(n);\n\n    return hit;\n}\n\nHit AddLight(Hit hit, vec3 lightPos) {\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - hit.point);\n   \n    float dif = clamp(dot(hit.normal, l), 0., 1.);\n    float d = SendRay(hit.point + hit.normal * SURF_DIST * 5., l).distance;\n    \n    if(d < length(lightPos - hit.point)) {\n        dif *= .7;\n    }\n    \n    dif *= dif * dif  * dif * dif * dif;\n    \n    hit.light += hit.color * dif * 2.6;\n    \n    return hit;\n}\n\nHit SendRayWithLight(vec3 origin, vec3 direction) {\n\tHit hit = SendRay(origin, direction);\n    \n    if(hit.distance <= SURF_DIST) {\n        hit = AddNorm(hit);\n        hit = AddLight(hit, vec3(0, 5, 6));\n        hit = AddLight(hit, vec3(1, 4, 5));\n        hit = AddLight(hit, vec3(6, 10, -10));\n    } else {\n    \thit.color = vec3(1, 1, 1);\n    }\n    \n    return hit;\n}\n\nHit SendRayWithReflection(vec3 origin, vec3 direction) {\n    Hit hit = SendRayWithLight(origin, direction);\n    \n    if(hit.distance <= SURF_DIST) {\n        \n        if(hit.shiny > 0.) {\n            vec3 refDir = direction - 2. * hit.normal * dot(direction, hit.normal);\n            Hit hitR = SendRayWithLight(hit.point + hit.normal * SURF_DIST * 2., refDir);\n            hit.light += hitR.light * hit.shiny * 0.6;\n            \n            if(hitR.distance <= SURF_DIST) {\n            \trefDir = refDir - 2. * hitR.normal * dot(refDir, hitR.normal);\n                Hit hitR = SendRayWithLight(hitR.point + hitR.normal * SURF_DIST * 2., refDir);\n                hit.light += hitR.light * hit.shiny * 0.3;\n                \n                if(hitR.distance <= SURF_DIST) {\n                    refDir = refDir - 2. * hitR.normal * dot(refDir, hitR.normal);\n                    Hit hitR = SendRayWithLight(hitR.point + hitR.normal * SURF_DIST * 2., refDir);\n                    hit.light += hitR.light * hit.shiny * 0.15;\n                    \n                    if(hitR.distance <= SURF_DIST) {\n                        refDir = refDir - 2. * hitR.normal * dot(refDir, hitR.normal);\n                        Hit hitR = SendRayWithLight(hitR.point + hitR.normal * SURF_DIST * 2., refDir);\n                        hit.light += hitR.light * hit.shiny * 0.075;\n                    }\n                }\n            }\n        }\n        \n        if(hit.transp > 0.) {\n            vec3 refDir = normalize(direction + hit.normal * 0.3 + (hit.point.x * hit.point.y * 0.5));\n            Hit outside = findOutside(hit.point + (direction * 0.1), refDir);\n            Hit hitR = SendRayWithLight(outside.point, refDir);\n            hit.light += hitR.light * hit.transp;\n            \n            if(hitR.distance <= SURF_DIST) {\n            \tvec3 refDir = refDir - 2. * hitR.normal * dot(refDir, hitR.normal);\n                Hit hitR = SendRayWithLight(hitR.point + hitR.normal * SURF_DIST * 2., refDir);\n                hit.light += hitR.light * hit.shiny;\n            }\n        }\n        \n    }\n    \n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 origin = vec3(0, 1, 0);\n    vec3 direction = normalize(vec3(uv.x + (sin(iTime) * 0.1), uv.y + (sin(iTime * 0.3) * 0.2), 1));\n    \n    fragColor = vec4(SendRayWithReflection(origin, direction).light,1.0);\n}","name":"Image","description":"","type":"image"}]}