{"ver":"0.1","info":{"id":"l3sSWX","date":"1710096819","viewed":66,"name":"Bad Hilbert Draw","username":"infernalwave","description":"a really inefficient method of drawing a hilbert curve to the screen with points on the corners","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["hilbert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define int2 ivec2\n#define float2 vec2\n\n// Converts Hilbert index to grid coordinates\nint2 hilbertToGrid(int d, int n) {\n    int2 pos = int2(0, 0);\n    int t = d;\n    for (int s = 1; s < n; s *= 2) {\n        int rx = 1 & (t / 2);\n        int ry = 1 & (t ^ rx);\n        if (ry == 0) {\n            if (rx == 1) {\n                pos.x = s - 1 - pos.x;\n                pos.y = s - 1 - pos.y;\n            }\n            // Swap x and y\n            int temp = pos.x;\n            pos.x = pos.y;\n            pos.y = temp;\n        }\n        pos.x += s * rx;\n        pos.y += s * ry;\n        t /= 4;\n    }\n    return pos;\n}\n\n// Check if point is near a line segment\nbool nearLine(float2 point, float2 a, float2 b, float width) {\n    float2 ap = point - a;\n    float2 ab = b - a;\n    float ab2 = dot(ab, ab);\n    float ap_ab = dot(ap, ab);\n    float t = ap_ab / ab2;\n    float2 p = a + t * ab;\n    return (t >= 0.0 && t <= 1.0) && length(point - p) < width;\n}\n\n// Hilbert curve and nearLine functions as before\n\n// Function to draw a rounded line segment\nbool drawRoundedLine(float2 uv, float2 start, float2 end, float lineWidth, float roundness) {\n    float lineLength = length(end - start);\n    float2 dir = (end - start) / lineLength;\n    float2 normalDir = vec2(-dir.y, dir.x);\n    \n    float2 toP = uv - start;\n    float2 toPProj = dir * dot(toP, dir);\n    float2 nearest = start + toPProj;\n    float distToLine = length(uv - nearest);\n    \n    bool inLineBounds = dot(toPProj, toPProj) <= lineLength * lineLength && dot(toP, dir) >= 0.0;\n    bool inRoundBounds = distance(nearest, start) <= roundness || distance(nearest, end) <= roundness;\n    \n    return (distToLine < lineWidth && inLineBounds) || (distToLine < lineWidth + roundness && inRoundBounds);\n}\n\n// Main shader function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int level = 5; // Level of detail\n    int n = 1 << level;\n\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(1.0); // White background\n    float lineWidth = 0.00001 * iResolution.y; // Line width\n    float roundness = 0.02; // Adjust for more/less rounded corners\n\n    float totalSegments = float(n * n - 1);\n    float currentSegment = mod(iTime * 20.0, totalSegments); // Speed of drawing\n\n    for (int i = 0; i < n * n - 1; ++i) {\n        int2 a = hilbertToGrid(i, n);\n        int2 b = hilbertToGrid(i + 1, n);\n\n        vec2 pa = (vec2(a) / float(n - 1)) * 2.0 - 1.0;\n        vec2 pb = (vec2(b) / float(n - 1)) * 2.0 - 1.0;\n\n        pa.x *= iResolution.x / iResolution.y;\n        pb.x *= iResolution.x / iResolution.y;\n\n        if (float(i) <= currentSegment) {\n            vec2 segmentEnd = mix(pa, pb, smoothstep(float(i), float(i) + 1.0, currentSegment));\n\n            if (drawRoundedLine(uv, pa, segmentEnd, lineWidth, roundness)) {\n                col = vec3(0.0); // Black line\n                break;\n            }\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}