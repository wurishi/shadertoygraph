{"ver":"0.1","info":{"id":"NtdyWj","date":"1660588068","viewed":498,"name":"Animated MSDF","username":"Tilmann","description":"Turning a small number of low-resolution textures into smooth high-resolution animations by interpolating multi-channel signed distance fields (MSDF)","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["2d","interpolation","msdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCALE (2.0 * RESOLUTION / iResolution.x)\n\nfloat median_of_three(vec3 v){\n    return max(min(v.x, v.y), min(max(v.x, v.y), v.z));\n}\n\nfloat sdf_to_alpha(float x){\n    return clamp(x / fwidth(x), 0.0, 1.0);\n}\n\nvec4 interpolate(vec2 uv, float t){\n    vec4 motion = texture(iChannel1, uv) / iResolution.xyxy;\n    vec2 uv_0 = uv + motion.xy * t;\n    vec2 uv_1 = uv + motion.zw * (1.0 - t);\n    \n    // In a real application these would be samples from two different animation frames.\n    vec4 frame_0 = texture(iChannel0, uv_0);\n    vec4 frame_1 = texture(iChannel0, uv_1);\n    return mix(frame_0, frame_1, t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime);\n    if(fragCoord.x < iResolution.x * 0.5){\n        vec2 uv = fragCoord * SCALE;\n        vec2 pixelated = (floor(uv) + 0.5) / iResolution.xy;\n        fragColor = interpolate(pixelated, t) * 0.5 + 0.5;\n    }else{\n        fragCoord.x -= iResolution.x * 0.5;\n        vec2 uv = fragCoord * SCALE / iResolution.xy;\n        \n        float m = median_of_three(interpolate(uv, t).xyz);\n        float fill = sdf_to_alpha(m - LINE_WIDTH * 0.5 * SCALE);\n        float line = sdf_to_alpha(m + LINE_WIDTH * 0.5 * SCALE);\n        vec3 rgb = mix(mix(BACKGROUND, LINE, line), FILL, fill);\n        fragColor = vec4(rgb, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// MSDF for a pair of cartoonish gears.\n// In a real application this would be a texture instead of a shader.\n\nfloat fold(float x){\n    return abs(fract(x) - 0.5);\n}\n\nvec3 gear(vec2 coord, float radius, float tooth_count){\n    float d = length(coord);\n    float outer_radius = radius + TOOTH_HEIGHT * 0.5;\n    float inner_radius = radius - TOOTH_HEIGHT * 0.5;\n    float outer_circle = RESOLUTION * outer_radius - d;\n    float inner_circle = RESOLUTION * inner_radius - d;\n    float hole = d - RESOLUTION * HOLE_SIZE;\n    float radial = atan(coord.y, coord.x) / TAU * tooth_count;\n    float teeth = (RESOLUTION * TOOTH_WIDTH * radius - fold(radial) * d) / tooth_count * TAU;\n    \n    float r = min(inner_circle, hole);\n    float g = min(outer_circle, hole);\n    float b = teeth;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 gear_a = gear(fragCoord - CENTER_A, RADIUS_A, TOOTH_COUNT_A);\n    vec3 gear_b = gear(fragCoord - CENTER_B, RADIUS_B, TOOTH_COUNT_B);\n    fragColor = vec4(mix(gear_a, gear_b, select(fragCoord)), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Displacement map for a pair of rotations.\n// In a real application this would be a texture instead of a shader.\n\nvec4 rotation(vec2 center, float speed){\n    float c = (cos(TAU * speed * 2.0) - 1.0) * 0.135;\n    float s =  sin(TAU * speed);\n    mat2 m0 = mat2(c,-s, s,c);\n    mat2 m1 = mat2(c, s,-s,c);\n    return vec4(m0 * center, m1 * center);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center_a = fragCoord - CENTER_A;\n    vec2 center_b = fragCoord - CENTER_B;\n    vec4 rot_a = rotation(center_a, 1.0 / TOOTH_COUNT_A);\n    vec4 rot_b = rotation(center_b,-1.0 / TOOTH_COUNT_B);\n    fragColor = mix(rot_a, rot_b, select(fragCoord));\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define RESOLUTION 32.0\n\n#define RADIUS_A 0.25\n#define RADIUS_B 0.2\n#define TOOTH_COUNT_A 13.0\n#define TOOTH_COUNT_B 5.0\n#define TOOTH_WIDTH  0.25\n#define TOOTH_HEIGHT 0.05\n#define HOLE_SIZE  0.1\n\n#define BACKGROUND vec3(0.6,0.8,1.0)\n#define FILL       vec3(0.5,0.4,0.3)\n#define LINE       vec3(0.0,0.0,0.0)\n#define LINE_WIDTH 2.0\n\n#define CENTER_A (RESOLUTION * vec2(0.32,0.68))\n#define CENTER_B (RESOLUTION * vec2(0.75,0.25))\n#define TAU 6.283\n\nfloat select(vec2 coord){\n    return clamp((coord.x - coord.y) / RESOLUTION * 24.0 - 2.0, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"}]}