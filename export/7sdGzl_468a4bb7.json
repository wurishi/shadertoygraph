{"ver":"0.1","info":{"id":"7sdGzl","date":"1631045900","viewed":173,"name":"Alhambra Boat Hall tiling.","username":"curena","description":"Islamic Start Patterns: Sala de la Barca, Alhambra, Granada, Spain (ilustration of wallpaper groups and symmetry in general). ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["symmetry","islamicstarpattern","alhambra"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ISLAMIC STAR PATTERNS\n// Alhambra, Boat Hall (Sala de la Barca).\n//\n// Carlos Ureña, Sep. 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// -----------------------------------------------------------------------------------\n\n\n// ------------------------------------------------------------------------------------\n// configurable constants (visualization)\n\nconst int   nspp_root       = 7 ;   // root of the number of samples per pixel \nconst float vis_wcc_sx      = 5.2 ; // visible region in world coordinates, size in X\n\nbool schematic_view = false ;\n\n// ------------------------------------------------------------------------------------\n// configurable constants (tiling shape)\n\nconst float stars_outer_rad    = 0.220 ; // measured aproximatelly from the tiling photo ...\nconst float ribbons_width      = 0.070 ;  // just guessing ...\nconst float ribbons_edge_width = 0.007 ; \n\n// ------------------------------------------------------------------------------------\n// computed or fixed constants \n\nconst int   nspp        = nspp_root*nspp_root; // number of samples per pixel\nconst float nspp_root_f = float(nspp_root);    // root of number of samples per pixel (as a float)\n\nconst float pi            = 3.14159265359 ;\nconst float root_of_2     = 1.41421356237 ;\nconst float root_of_2_inv = 1.0/root_of_2 ;\nconst vec2  norm_diag_1   = vec2( root_of_2_inv,  root_of_2_inv ); // normalized diagonal (upwards, main diag)\nconst vec2  norm_diag_2   = vec2( root_of_2_inv,  -root_of_2_inv ); // normalized diagonal (downwards, perp. to main diag)\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through two points 'q1' and 'q2'\n// (only for points in the halfplane to the right of the line from p1 to p2)\n// 'mirror_count' is increased only when 'p' is in the right halfplane\n\nvec2 MirrorPP( vec2 p, vec2 q1, vec2 q2, inout int mirror_count )\n{\n \tvec2   s = q2-q1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-q1,n) ;\n\n    if ( 0.0 <= d )\n    {\n       mirror_count = mirror_count+1; \n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n\n// -------------------------------------------------------------------------------\n// mirror reflection of 'p' around and axis through point 'q' and parallel to normalized vector 'v'\n// (only for points in the halfplane to the right of the axis)\n// 'mirror_count' is increased only when 'p' is in the right halfplane\n\nvec2 MirrorPN( vec2 p, vec2 q, vec2 v, inout int mirror_count )\n{\n \tvec2   n = vec2( v.y, -v.x ) ;\n    float  d = dot(p-q,n) ;\n\n    if ( 0.0 <= d )\n    {\n       mirror_count = mirror_count+1;\n       return p-2.0*d*n ;\n    }\n    else\n       return p ;\n}\n\n// -------------------------------------------------------------------\n// computes (closest) distance from point 'p' to segment from 'a' to 'b' \n// see Iñigo Quilez derivation at: https://www.youtube.com/watch?v=PMltMdi1Wzg\n// (particularized here for R=0)\n\nfloat PointToSegmentDist( vec2 p, vec2 a, vec2 b )\n{\n   float h = min( 1.0, max( 0.0, dot(p-a,b-a)/dot(b-a,b-a) )) ;\n   return length( p-a-(b-a)*h ); \n\n}\n//-------------------------------------------------------------------------------------\n// distance from 'p' to (extended) segment through three points\n\nfloat Point1SegmentDistance( vec2 p, vec2 a, vec2 b )\n{\n   return PointToSegmentDist( p, a + 3.0*(a-b), b + 3.0*(b-a) );\n\n}\n\n// distance from 'p' to (extended) polyline through three points\nfloat Point2SegmentDistance( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n   float d1 = PointToSegmentDist( p, a +3.0*(a-b), b );\n   float d2 = PointToSegmentDist( p, b, c +3.0*(c-b) );\n\n    return min( d1, d2 );\n}\n\n// distance from 'p' to (extended) polyline through four points\nfloat Point3SegmentDistance( vec2 p, vec2 a, vec2 b, vec2 c, vec2 d )\n{\n   float d1 = PointToSegmentDist( p, a +3.0*(a-b), b );\n   float d2 = PointToSegmentDist( p, b, c );\n   float d3 = PointToSegmentDist( p, c, d+3.0*(d-c) );\n\n    return min( d1, min( d2, d3 ) );\n}\n\n//-------------------------------------------------------------------------------------\n// returns true iif 'p' is on the left side of the line through 'a' towards 'b' \n// returns false for the right side\n\nbool IsOnLeftSide( vec2 p, vec2 a, vec2 b )\n{\n   // use dot product of b-a and vector to the left direction\n   return 0.0 <= dot( p-a, vec2( a.y-b.y, b.x-a.x ) )  ;\n}\n\n//-------------------------------------------------------------------------------------\n// Compute pattern color at a point given in WCC\n\nvec4 PatternWCC( in vec2 point_wcc )\n{\n    //float split_x  = sin( iTime*0.5 )*0.5*vis_wcc_sx ;\n    //schematic_view = ( split_x <= point_wcc.x  ) ;\n     \n    vec2  intp_f   = floor( point_wcc ) ;  // integral part of point coordinates (as floats)\n    ivec2 intp_i   = ivec2( intp_f );      // integral part of point coordinates (as integers)\n    vec2  fracp    = point_wcc - intp_f ;  // fractional part of point coordinates \n    int   ham_cnt  = 0 ;                   // horizontal axis mirror count\n    int   vam_cnt  = 0 ;                   // vertical   axis mirror count \n    int   da1m_cnt = 0 ;                   // diagonal  axis 1 mirror count (axis from (0,0) to (1,1))\n    int   da2m_cnt = 0 ;                   // diagonal  axis 2 mirror count (axis from (0,1) to (1,0))\n    \n    // take 'fracp' to the 'basic' region, track numbers of mirror reflections needed\n    \n    vec2 p1 = MirrorPN( fracp, vec2(0.5,0.0),  vec2(0.0,1.0), vam_cnt ) ;  // p1.x <= 0.5 \n    vec2 p2 = MirrorPN( p1,    vec2(1.0,0.5),  vec2(-1.0,0.0),ham_cnt ) ;  // p2.y <= 0.5\n    vec2 p3 = MirrorPN( p2,    vec2(0.0,0.0),  -norm_diag_1,   da1m_cnt ) ; // p3.y <= p3.x \n    vec2 p4 = MirrorPN( p3,    vec2(0.5,0.0),  -norm_diag_2,   da2m_cnt ) ; // p4.x+p4.y <= 0.5\n   \n    // on schematic view, if on mirror edge axes, return an edge color\n    if ( schematic_view )\n    {\n       // compute minimun distance to mirror edge axes \n       float d1 = p4.y ;\n       float d2 = dot( p4, vec2( root_of_2_inv, -root_of_2_inv ) );\n       float d3 = dot( p4 -vec2(0.5,0.0), vec2( -root_of_2_inv, -root_of_2_inv ) );\n       float d = min(d1,min(d2,d3));\n       \n       // if on edge, return edge color \n       if ( d < 0.0015 )\n          return vec4( 0.5, 0.0, 0.0, 1.0 );\n    }\n    \n    int cnt = vam_cnt + ham_cnt + da1m_cnt + da2m_cnt ;\n    \n    // true if point is in fundamental region\n    bool in_fundm = (cnt == 0) && (intp_i.x == 0) && (intp_i.y == 0) ;\n    \n    // define vertexes of the polyline through the center of the ribbon\n    \n    const float R    = stars_outer_rad ; \n    const float s    = root_of_2_inv ;  \n    const float t    = tan( pi/8.0);\n    const float u    = 1.0-2.0*t ;\n    const float w    = 0.5*ribbons_width ;\n    const float e    = 0.5*ribbons_edge_width ;\n    \n    vec2 a1 = R*vec2( 1.0, 0.0 );\n    vec2 a2 = R*vec2( 1.0-s*t, s*t );\n    vec2 a3 = R*vec2( 1.0-s*t, s );\n    vec2 a4 = R*vec2( 1.0 + s*u, s );\n    \n    float h = 0.5*length(a4-a2);  \n    \n    vec2 a5 = vec2( a4.x + (a4.y-h), h );    \n    vec2 a6 = vec2( 0.5-a5.y, a5.y );       \n    vec2 a7 = vec2( a6.x, 0.0 );\n    \n    // compute distances from 'p4' to ribbons (extended on their edges)\n    \n    float d1 = Point2SegmentDistance( p4, a1, a2, a3 );     // ribbon 1 \n    float d2 = Point3SegmentDistance( p4, a3, a4, a5, a6 ); // ribbon 2\n    float d3 = Point1SegmentDistance( p4, a6, a7 );         // ribbon 3\n   \n    // compute ribbons inclusion flags\n    \n    bool in1 = (d1 <= w+e );\n    bool in2 = (d2 <= w+e );\n    bool in3 = (d3 <= w+e );\n    \n    // if in any ribbon, compute and return color\n         \n    if ( in1 || in2 || in3 )\n    {\n       float d ;\n       \n       if ( schematic_view )\n       {\n         if ( in1 && in2 )\n            d = min( d1, d2 );\n         else if ( in2 && in3 )\n            d = min( d2, d3 );\n         else if ( in1 )\n            d = d1 ;\n         else if ( in2 )\n            d = d2 ;\n         else if ( in3 ) \n            d = d3 ;\n            \n         vec4 col ;\n         if ( w-e <= d && d <= w+e )\n            col = vec4( 0.4, 0.4, 0.4, 1.0 ); // ribbon edges (gray)\n         else if ( d <= w )\n            col = vec4( 1.0, 1.0, 1.0, 1.0 );   // ribbon interior (white) \n            \n         if ( in_fundm )\n            col = vec4( col.r, 0.0, 0.0, 1.0 );\n         return col ;\n       }\n       else \n       { \n           if ( in1 && in2 )\n           {\n                if ( (cnt & 1) == 1 )\n                  d = d1 ;\n                else \n                  d = d2 ;\n           }\n           else if ( in2 && in3 )\n           {\n                if ( (cnt & 1) == 1 )\n                  d = d2 ;\n                else \n                  d = d3 ;\n           }\n           else \n              d  = min( d1, min( d2, d3) );\n       }\n       \n       if ( w-e <= d && d <= w+e )\n          return vec4( 0.5, 0.5, 0.5, 1.0 ); // ribbon edges (gray)\n       else if ( d <= w )\n          return vec4( 1.0, 1.0, 1.0, 1.0 );   // ribbon interior (white) \n    }\n    \n    // compute point inclusion into the three regions beetween ribbons\n    // then compute color based on region\n    \n    bool in_star  = IsOnLeftSide( p4, a1, a2 ) || IsOnLeftSide( p4, a2, a3 ) ;\n    bool in_green = IsOnLeftSide( p4, a3, a4 ) || \n                         ( IsOnLeftSide( p4, a4, a5 ) && IsOnLeftSide( p4, a5, a6 ) ) ;\n    \n    if ( schematic_view )\n    {\n      vec4 c ;\n      \n      if ( in_star )\n         c = vec4( 0.8, 0.8, 0.8, 1.0 );\n      else if ( in_green )\n         c = vec4( 0.7, 0.7, 0.7, 1.0 );\n      else    \n         c = vec4( 0.6, 0.6, 0.6, 1.0 );\n         \n      if ( in_fundm )\n         c = vec4( c.r, 0.4, 0.4, 1.0 ); \n         \n      return c ;   \n    }\n    \n    if ( in_star )\n    {  \n         if ( 0 < da2m_cnt )\n           return vec4( 0.6, 0.4, 0.0, 1.0 ); // brown stars\n         else\n           return vec4( 0.3, 0.4, 0.9, 1.0 ); // blue stars\n    }\n    \n    \n    \n    if ( in_green )\n          return vec4( 0.0, 0.4, 0.0, 1.0 );\n      \n    // otherwise point is in black region:\n    \n    return vec4( 0.0, 0.0, 0.0, 1.0 );\n}\n\n\n//-------------------------------------------------------------------------------------\n// Compute anti-aliased pixel colors for a point given in device coordinates\n// point_dcc = integer pixel coordinates, starting at zero (device coordinates)\n\nvec4 AAPixelColor( in vec2 point_dcc )\n{\n    vec4 sum  = vec4( 0.0, 0.0, 0.0, 1.0 ); // sum of samples colours \n     \n    for( int i = 0 ; i < nspp_root ; i++ )\n    for( int j = 0 ; j < nspp_root ; j++ )\n    {\n       // compute sample position in device coordinates, then in world coordinates\n       vec2 sample_dcc = point_dcc + (vec2(float(i)+0.5,float(j)+0.5)/nspp_root_f) ;\n       vec2 sample_wcc = vis_wcc_sx*(sample_dcc-0.5*iResolution.xy)/iResolution.xx ;\n       \n       // add this sample color to 'sum'\n       sum = sum + PatternWCC( sample_wcc+vec2(0.0,0.0) ); // subtract 0.5,0.5 in WCC to center unit square\n    }\n    return sum/float(nspp_root*nspp_root) ;\n}\n//-------------------------------------------------------------------------------------\n// main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = AAPixelColor( fragCoord ) ;\n    \n}","name":"Image","description":"","type":"image"}]}