{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define INTERVAL 5.0\n#define PIXEL_SIZE 0.5\n#define DITHER_STRENGTH 0.05\n#define NUM_COLORS 8\n\n//Credits\n//https://iquilezles.org/articles/distfunctions/\n//https://iquilezles.org/articles/fbm/\n//https://iquilezles.org/articles/palettes/\n\nfloat hash(float n, float seed) {\n    return fract(sin(n + seed) * 53738.14534123);\n}\n\nfloat noise(vec2 p, float seed) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n\n    return mix(mix(hash(ip.x + ip.y * 57.0, seed), hash(ip.x + 1.0 + ip.y * 57.0, seed), u.x),\n               mix(hash(ip.x + (ip.y + 1.0) * 57.0, seed), hash(ip.x + 1.0 + (ip.y + 1.0) * 57.0, seed), u.x), u.y);\n}\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves, float seed) {\n    float n = 0.0;\n    for(int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency, seed) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 90.0);\n    }\n    return n;\n}\n\nfloat sphere(vec3 ro, vec3 rd, float radius) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n    float h = b * b - c;\n    if(h < 0.0)\n        return -1.0;\n    return -b - sqrt(h);\n}\n\nstruct ColorScheme {\n    vec3 colors[NUM_COLORS];\n    float seed;\n    vec3 atmosphereColor;\n};\n\nColorScheme getProceduralColorScheme(float seed) {\n    vec3 a = vec3(noise(vec2(seed, 1.0), seed), noise(vec2(seed, 2.0), seed), noise(vec2(seed, 3.0), seed)) * 1.5;\n    vec3 b = vec3(noise(vec2(seed, 8.0), seed), noise(vec2(seed, 5.0), seed), noise(vec2(seed, 6.0), seed)) * 1.5;\n    vec3 c = vec3(noise(vec2(seed, 32.0), seed), noise(vec2(seed, 8.0), seed), noise(vec2(seed, 9.0), seed)) * 1.5;\n    vec3 d = vec3(noise(vec2(seed, 128.0), seed), noise(vec2(seed, 11.0), seed), noise(vec2(seed, 12.0), seed)) * 0.75;\n    ColorScheme scheme;\n    for(int i = 0; i < NUM_COLORS; i++) {\n        scheme.colors[i] = palette(float(i+1) / float(NUM_COLORS), a, b, c, d);\n    }\n    scheme.seed = fract(seed * 0.1) * 1000.0;\n    scheme.atmosphereColor = palette(4.5, a, b, c, d);\n    return scheme;\n}\n\nvec3 colorBanding(float n, ColorScheme scheme) {\n    int index = int(clamp(n * float(NUM_COLORS), 0.0, float(NUM_COLORS - 1)));\n    return scheme.colors[index];\n}\n\nconst mat4 bayerMatrix = mat4(\n    0.0 / 16.0, 8.0 / 16.0, 2.0 / 16.0, 10.0 / 16.0,\n    12.0 / 16.0, 4.0 / 16.0, 14.0 / 16.0, 6.0 / 16.0,\n    3.0 / 16.0, 11.0 / 16.0, 1.0 / 16.0, 9.0 / 16.0,\n    15.0 / 16.0, 7.0 / 16.0, 13.0 / 16.0, 5.0 / 16.0);\n\nvec3 applyDithering(float noiseValue, vec2 uv, ColorScheme scheme) {\n    int x = int(mod(uv.x, 4.0));\n    int y = int(mod(uv.y, 4.0));\n    float threshold = bayerMatrix[x][y];\n    noiseValue += threshold * DITHER_STRENGTH;\n    return colorBanding(noiseValue, scheme);\n}\n\nvec3 applyLighting(vec3 color, vec3 normal, vec3 lightDir) {\n    float diffuse = max(dot(normal, lightDir), 0.51);\n    return color * pow(diffuse, 5.25);\n}\n\nfloat sunGlint(vec3 normal, vec3 lightDir, float intensity) {\n    float spec = max(dot(reflect(-lightDir, normal), normalize(vec3(0.0, 0.0, 1.0))), 0.0);\n    return pow(spec, 25.0) * intensity;\n}\n\nvec3 calculateAtmosphere(vec3 pos, vec3 lightDir, vec3 viewDir, vec3 atmosphereColor, float planetRadius, float atmosphereRadius) {\n    float viewAngle = dot(normalize(pos), viewDir);\n    float lightAngle = dot(normalize(pos), lightDir);\n    float atmosphereThickness = atmosphereRadius - planetRadius;\n    float fade = smoothstep(0.0, atmosphereThickness, atmosphereRadius - length(pos));\n    float scattering = pow(clamp(lightAngle, 0.0, 1.0), 2.0) * 0.5 + 0.5;\n    float atmosphereIntensity = pow(clamp(1.0 - viewAngle, 0.0, 1.0), 3.0) * fade;\n    return atmosphereColor * scattering * atmosphereIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (floor(fragCoord / PIXEL_SIZE) * PIXEL_SIZE - iResolution.xy * 0.5) / iResolution.y;\n    float intervalNumber = floor((5.0 + iTime) / INTERVAL);\n    ColorScheme scheme = getProceduralColorScheme(intervalNumber);\n    vec3 ro_planet = vec3(0.0, 0.0, 2.3);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 lightDir = normalize(vec3(0.86, 2.15, 4.0));\n    vec3 color = vec3(0.0);\n    float planetRadius = 1.0;\n    float cloudRadius = 1.02;\n    float atmosphereRadius = 1.15;\n    float t_clouds = sphere(ro_planet, rd, cloudRadius);\n    float t_planet = sphere(ro_planet, rd, planetRadius);\n    float t_atmosphere = sphere(ro_planet, rd, atmosphereRadius);\n    if (t_planet > 0.0) {\n        vec3 pos = ro_planet + t_planet * rd;\n        vec3 norm = normalize(pos);\n        vec3 rotatedPos = rotate(pos, iTime * 0.05);\n        vec3 rotatedNorm = normalize(rotate(norm, iTime * 0.05));\n\n        float landNoise = layeredNoise(rotatedNorm * 3.0, 0.9, 2.0, 0.5,  4, scheme.seed);\n        float waterNoise = layeredNoise(rotatedNorm * 6.0, 0.4, 1.0, 0.4, 4, scheme.seed);\n\n        float terrainValue = mix(landNoise, waterNoise, 0.5);\n        float terrainThreshold = smoothstep(0.4, 0.6, terrainValue);\n        vec3 surfaceColor = mix(vec3(0.0, 0.1, 0.5), vec3(0.7, 0.8, 0.2), terrainThreshold);\n\n        surfaceColor = mix(surfaceColor, applyDithering(terrainValue, fragCoord.xy / PIXEL_SIZE, scheme), 0.55);\n        vec3 glint = vec3(sunGlint(norm, lightDir, pow(length(surfaceColor), 2.25)));\n        surfaceColor = mix(surfaceColor * 3.5, glint, 0.5);\n        surfaceColor = applyLighting(surfaceColor, norm, lightDir);\n        color = surfaceColor;\n    }\n    \n    if (t_clouds > 0.0) {\n        vec3 pos = ro_planet + t_clouds * rd;\n        vec3 norm = normalize(pos);\n        vec3 rotatedPos = rotate(pos, iTime * 0.1);\n        float cloudNoise = layeredNoise(rotatedPos * 4.0 + vec3(0.,0.,iTime*0.1), 0.61, 0.5, 0.6, 6, scheme.seed);\n        float steppedClouds = floor(pow(cloudNoise, 6.35) * 5.0) / 5.0;\n        vec3 cloudColor = vec3(steppedClouds * 1.25);\n        cloudColor = mix(cloudColor, scheme.atmosphereColor, 0.5);\n        float cloudLighting = max(dot(norm, lightDir), 0.7);\n        cloudColor *= cloudLighting;\n        color = mix(color, cloudColor, steppedClouds);\n    }\n\n    if (t_planet > 0.0) {\n        vec3 pos = ro_planet + t_planet * rd;\n        vec3 norm = normalize(pos);\n        vec3 viewDir = -rd;\n        vec3 atmosphereColor = scheme.atmosphereColor;\n        vec3 atmosphere = calculateAtmosphere(pos, lightDir, viewDir, atmosphereColor, planetRadius, atmosphereRadius);\n        color += atmosphere;\n    }\n\n    if (t_atmosphere > 0.0 && t_planet < 0.0) {\n        vec3 pos = ro_planet + t_atmosphere * rd;\n        vec3 norm = normalize(pos);\n        float angleFactor = dot(-rd, norm);\n        angleFactor = smoothstep(0.0, 1.0, angleFactor);\n        float dist = length(pos) - planetRadius;\n        float glowIntensity = exp(-dist * 15.0) * angleFactor;\n        color += scheme.atmosphereColor * glowIntensity * 1.5;\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4cKfRR","date":"1733694266","viewed":96,"name":"Stylized Planets","username":"ArchaicVirus","description":"Stylized procedural planets, based on my other planet shader: https://www.shadertoy.com/view/lXdSDM.\nWith added atmosphere effect, improved lighting and glow.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","space","planet","procgen"],"hasliked":0,"parentid":"","parentname":""}}