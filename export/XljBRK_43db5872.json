{"ver":"0.1","info":{"id":"XljBRK","date":"1516496081","viewed":1868,"name":"GeneralizedTonemapper","username":"TimothyLottes","description":"Generalized Tonemapper","likes":18,"published":1,"flags":0,"usePreview":1,"tags":["tonemapper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tonemapper settings\n#define CONTRAST 1.4\n#define SHOULDER 1.0\n#define HDR_MAX 64.0\n#define MID_IN 0.18\n#define MID_OUT 0.18\n#define SATURATION vec3(0.0,0.0,0.0)\n#define CROSSTALK vec3(64.0,32.0,128.0)\n#define CROSSTALK_SATURATION vec3(4.0,1.0,16.0)\n//--------------------------------------------------------------\n#define GT_GPU 1\n#define GT_GLSL 1\n#define GT_SHOULDER 1\n\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//\n//           [GT] GENERALIZED TONEMAPPER - 20180122\n//\n//                      by Timothy Lottes\n//\n//\n//--------------------------------------------------------------\n// Showing full flexibility of over-exposure color shaping\n// Via 3 channel 'crosstalk' and 'crosstalk saturation' terms\n//--------------------------------------------------------------\n// Based on AMD GDC Presentation:\n//  Advanced Techniques and Optimization of HDR Color Pipelines\n//  https://gpuopen.com/gdc16-wrapup-presentations/\n//--------------------------------------------------------------\n// Using math fixup from Bart Wronski (see comments),\n//  https://bartwronski.com/2016/09/01/dynamic-range-and-evs/\n//--------------------------------------------------------------\n// DEFINES\n// =======\n// GT_CPU - Define to get CPU code (not implemented)\n// GT_GPU - Define to get GPU code\n// GT_SHOULDER - Define if shoulder is not set to 1.0\n// GT_GLSL - Define for OpenGL/Vulkan\n// GT_HLSL - Define for DX (not tested)\n//==============================================================\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                          CPU CODE\n//\n//==============================================================\n#ifdef GT_CPU\n // TODO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n#endif\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                          GPU CODE\n//\n//==============================================================\n#ifdef GT_GPU\n//_____________________________/\\_______________________________\n//==============================================================\n//                         PORTABILITY\n//==============================================================\n #ifdef GT_GLSL\n  #define GtF1 float\n  #define GtF2 vec2\n  #define GtF3 vec3\n  #define GtF4 vec4\n  #define GtFractF1 fract\n  #define GtLerpF3(x,y,a) mix(x,y,a)\n  #define GtRcpF1(x) (1.0/(x))\n  #define GtSatF1(x) clamp((x),0.0,1.0)\n//--------------------------------------------------------------\n  GtF1 GtMax3F1(GtF1 a,GtF1 b,GtF1 c){return max(a,max(b,c));}\n #endif\n//==============================================================\n #ifdef GT_HLSL\n  #define GtF1 float\n  #define GtF2 float2\n  #define GtF3 float3\n  #define GtF4 float4\n  #define GtFractF1 frac\n  #define GtLerpF3(x,y,a) lerp(x,y,a)\n  #define GtRcpF1(x) (1.0/(x))\n  #define GtSatF1(x) saturate(x)\n//--------------------------------------------------------------\n  GtF1 GtMax3F1(GtF1 a,GtF1 b,GtF1 c){return max(a,max(b,c));}\n #endif\n//_____________________________/\\_______________________________\n//==============================================================\n//                     CONSTANT GENERATION\n//--------------------------------------------------------------\n// GPU version of math to generate constants for tonemapper\n// Better to generate constants into a constant buffer first\n//==============================================================\n void GtConstants(\n  out GtF4 tone0,\n  out GtF4 tone1,\n  out GtF4 tone2,\n  out GtF4 tone3,\n  GtF1 contrast,\n  GtF1 shoulder,\n  GtF1 hdrMax,\n  GtF1 midIn,\n  GtF1 midOut,\n  GtF3 saturation,\n  GtF3 crosstalk,\n  GtF3 crosstalkSaturation\n ){\n  tone0.x=contrast;\n  tone0.y=shoulder;\n  GtF1 cs=contrast*shoulder;\n//--------------------------------------------------------------\n  // TODO: Better factor and clean this up!!!!!!!!!!!!!!!!!!!!!!\n  GtF1 z0=-pow(midIn,contrast);\n  GtF1 z1=pow(hdrMax,cs)*pow(midIn,contrast);\n  GtF1 z2=pow(hdrMax,contrast)*pow(midIn,cs)*midOut;\n  GtF1 z3=pow(hdrMax,cs)*midOut;\n  GtF1 z4=pow(midIn,cs)*midOut;\n  tone0.z=-((z0+(midOut*(z1-z2))/(z3-z4))/z4);\n//--------------------------------------------------------------\n  GtF1 w0=pow(hdrMax,cs)*pow(midIn,contrast);\n  GtF1 w1=pow(hdrMax,contrast)*pow(midIn,cs)*midOut;\n  GtF1 w2=pow(hdrMax,cs)*midOut;\n  GtF1 w3=pow(midIn,cs)*midOut;\n  tone0.w=(w0-w1)/(w2-w3);\n//--------------------------------------------------------------\n  // Saturation base is contrast\n  saturation+=contrast;\n  tone1.xyz=saturation/crosstalkSaturation;\n  tone2.xyz=crosstalk;\n  tone3.xyz=crosstalkSaturation;}\n//_____________________________/\\_______________________________\n//==============================================================\n//                      APPLY TONEMAPPER\n//--------------------------------------------------------------\n// Note 'pow(x,y)' is implimented as 'exp2(log2(x)*y)'\n//==============================================================\n GtF3 GtFilter(\n  // Linear input color\n  GtF3 color,\n  // Tonemapper constants\n  GtF4 tone0,\n  GtF4 tone1,\n  GtF4 tone2,\n  GtF4 tone3\n ){\n//--------------------------------------------------------------\n  // Peak of all channels\n  GtF1 peak=GtMax3F1(color.r,color.g,color.b);\n  // Protect against /0\n  peak=max(peak,1.0/(256.0*65536.0));\n  // Color ratio\n  GtF3 ratio=color*GtRcpF1(peak);\n//--------------------------------------------------------------\n  // Apply tonemapper to peak\n  // Contrast adjustment\n  peak=pow(peak,tone0.x);\n//--------------------------------------------------------------\n  // Highlight compression\n  #ifdef GT_SHOULDER\n   peak=peak/(pow(peak,tone0.y)*tone0.z+tone0.w);\n  #else\n   // No shoulder adjustment avoids extra pow\n   peak=peak/(peak*tone0.z+tone0.w);\n  #endif\n//--------------------------------------------------------------\n  // Convert to non-linear space and saturate\n  // Saturation is folded into first transform\n  ratio=pow(ratio,tone1.xyz);\n  // Move towards white on overexposure\n  vec3 white=vec3(1.0,1.0,1.0);     \n  ratio=GtLerpF3(ratio,white,pow(GtF3(peak),tone2.xyz));\n  // Convert back to linear\n  ratio=pow(ratio,tone3.xyz);\n//--------------------------------------------------------------\n   return ratio*peak;}\n//==============================================================\n#endif\n\n\n\n\n\n//_____________________________/\\_______________________________\n//==============================================================\n//\n//                 SIMPLE MESSY-CODE TEST SCENE\n//\n//==============================================================\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n//--------------------------------------------------------------\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\nF1 Noise(F2 n,F1 x){n+=fract(iTime)*x;return fract(sin(dot(n.xy,F2(12.9898, 78.233)))*43758.5453);}\nF1 Dither(F2 n){return (Noise(n,0.07)+Noise(n,0.11)+Noise(n,0.13))/3.0;}\n//--------------------------------------------------------------\nF3 Hue(F1 n){return clamp(F3(\n abs(fract(n)-0.5)*(-6.0)+2.0,\n abs(fract(n+(1.0/3.0))-0.5)*(-6.0)+2.0,\n abs(fract(n-(1.0/3.0))-0.5)*(-6.0)+2.0),F3(0.0),F3(1.0));}\n//==============================================================\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n F2 uv=fragCoord.xy/iResolution.xy;\n uv.y=1.0-uv.y;\n F3 color=Linear3(texture(iChannel0,uv*3.0).rgb);\n color*=(1.0/8.0);\n//--------------------------------------------------------------\n #if 1\n  // Add colored gradients\n  F3 bars=Hue(uv.y/(5.0/8.0))*2.0;   \n  color+=bars*bars*(uv.x*uv.x*uv.x*uv.x*uv.x);\n #endif\n//--------------------------------------------------------------\n #if 1      \n  // Draw swatches\n  if(uv.y>7.0/8.0){\n   color.b=fract(uv.x*8.0);\n   color.r=1.0-fract(uv.y*8.0);\n   color.g=floor(uv.x*8.0)/8.0;\n   color.rgb=Linear3(color);}\n  else if(uv.y>6.0/8.0){\n   color.r=fract(uv.x*8.0);\n   color.g=1.0-fract(uv.y*8.0);\n   color.b=floor(uv.x*8.0)/8.0;\n   color.rgb=Linear3(color);}\n  else if(uv.y>5.0/8.0){\n   color.g=fract(uv.x*8.0);\n   color.b=1.0-fract(uv.y*8.0);\n   color.r=floor(uv.x*8.0)/8.0;\n   color.rgb=Linear3(color);}\n #endif   \n//--------------------------------------------------------------\n color*=16.0;\n//--------------------------------------------------------------\n #if 1\n  // Fade in/out\n  color.rgb*=pow(abs(sin(fract(iTime/16.0)*3.14159*2.0)),2.2);    \n #endif\n//--------------------------------------------------------------\n // Apply generalized tonemapper\n // In practice GtConstants() would be run on CPU,\n //  or if run on GPU, \n //  run on one wave and store into constant buffer in prepass\n GtF4 tone0;\n GtF4 tone1;\n GtF4 tone2;\n GtF4 tone3;\n GtConstants(\n  // Outputs\n  tone0,tone1,tone2,tone3,\n  // Inputs\n  CONTRAST,SHOULDER,HDR_MAX,MID_IN,MID_OUT,\n  SATURATION,CROSSTALK,CROSSTALK_SATURATION);\n color=GtFilter(color,tone0,tone1,tone2,tone3);\n//--------------------------------------------------------------\n // Convert back into sRGB.\n color=Srgb3(color);\n color+=(Dither(uv)-0.5)*(16.0/256.0);    \n fragColor=F4(color,1.0);}\n    \n    \n","name":"Image","description":"","type":"image"}]}