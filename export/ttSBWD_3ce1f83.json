{"ver":"0.1","info":{"id":"ttSBWD","date":"1598929266","viewed":55,"name":"TFG 6-2 Materiales Textura","username":"lukasharing","description":"Materiales, una esfera y un toro.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tfg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PASOS 128\n#define EPSILON 0.001\n#define MAXIMO 20.0\n#define PI 3.1415\n\nmat2 rot(float a){\n    return mat2(\n        +cos(a), -sin(a), \n        +sin(a), +cos(a)\n    );\n}\n\n// Rotación del plano YZ\nvec3 rotYZ(vec3 p, float a){\n    vec2 pr = p.yz * rot(a);\n    return vec3(p.x, pr.x, pr.y);\n}\n\n// Rotación del plano XZ\nvec3 rotXZ(vec3 p, float a){\n    vec2 pr = p.xz * rot(a);\n    return vec3(pr.x, p.y, pr.y);\n}\n\n// FDS Plano con signo\nfloat SDFPlano(vec3 p, vec3 n){\n    return dot(p, n);\n}\n\n// FDS circunsferencia\nfloat SDFCircunferencia(vec2 p, float r){\n    return length(p) - r;\n}\n\n// FDS Esfera\nfloat SDFEsfera(vec3 p, float r){\n    return length(p) - r;\n}\n\n// FDS Toro\nfloat SDFToro(vec3 p, float r1, float r2){\n    // FDS Circunsferencia desplazada izq r1 del centro.\n    float d = length(p.xz) - r1;\n    // Calculamos altura\n    float dh = p.y - 0.;\n    // Calculamos la distancia (la diagonal)\n    return SDFCircunferencia(vec2(dh, d), r2);\n}\n\nvec2 escena_sdf(vec3 p){\n    // Identificador inicial y la distancia máxima.\n    float id = -1.0;\n    float min_dist = MAXIMO;\n\n    // Toro de radio interno 0.3 y radio externo 0.05.\n    // Rotamos el toro \n    vec3 pr = rotYZ(p, PI / 4.);\n    float sdf_0 = SDFToro(pr, 0.3, 0.05);\n    // Comprobamos que sea la mas cercana.\n    if(sdf_0 < min_dist){\n        id = 0.; // Identificador del toro\n        min_dist = sdf_0;\n    }\n\n    // Esfera Rotada de radio 0.2\n    // Seccionada por un plano.\n    vec3 pr1 = rotXZ(p, PI / 4.0);\n    float sdf_1 = max(\n        SDFEsfera(pr1, 0.2),\n        SDFPlano(pr1, normalize(vec3(-1., 0., -1.)))\n    );\n    // Comprobamos que sea la mas cercana.\n    if(sdf_1 < min_dist){\n        id = 1.; // identificador de la esfera.\n        min_dist = sdf_1;\n    }\n\n    // Finalmente, devolvemos la distancia mínima y el objeto que la devuelve.\n    return vec2(min_dist, id);\n}\n\n// Homeomorfismo\nfloat h3(float h){\n    return pow(h, pow(2., 3.));\n}\nfloat h(float x){ return pow(x, 4.); }\n\n// Producto Escalar normalizado positivo.\nfloat dot01(vec3 a, vec3 b){ \n    return max(dot(a,b)/(length(a)*length(b)), 0.0);\n}\n\nfloat f_difusa(float distancia){\n    return 1.0;\n}\n\n// Cálculo de la normal de la isosuperficie intersectada por un rayo que ha sido estimado.\nvec3 Normal(vec3 rayo){\n    // f(x1,...,xn)\n    float fxyz = escena_sdf(rayo).x;\n    // f(x1,..,xi+h,xn)\n    float fxhyz = escena_sdf(rayo + vec3(EPSILON, 0.0, 0.0)).x;\n    float fxyhz = escena_sdf(rayo + vec3(0.0, EPSILON, 0.0)).x;\n    float fxyzh = escena_sdf(rayo + vec3(0.0, 0.0, EPSILON)).x;\n\n    // Utilizamos la definicion de derivadas parciales para devolver el gradiente, que se trata de la normal de la isosuperficie.\n    return vec3(\n        (fxhyz - fxyz) / EPSILON,\n        (fxyhz - fxyz) / EPSILON,\n        (fxyzh - fxyz) / EPSILON\n    );\n}\n\n// Devolvemos dos elementos, distancia e id.\nvec2 SphereMarching(in vec3 ojo, in vec3 direccion, float distancia_plano){\n    float distancia = 0.0;\n    // Realizamos PASOS iteraciones de marching.\n    for(int i = 0; i < PASOS; ++i){\n        // Calculamos el rayo modular\n        vec3 p = ojo + direccion * distancia;\n        // La escena devuelve el radio de la bola y el id del elemento\n        vec2 info = escena_sdf(p);\n        // Factor para la sobreestimación.\n        info.x *= 1.0;\n        // info.x contiene la distancia\n        if(abs(info.x) < EPSILON){\n            // info.y contiene el id de un elemento de la escena.\n            return vec2(distancia, info.y);\n        }\n        // incrementamos la distancia\n        distancia += info.x;\n        if(distancia > distancia_plano) break;\n    }\n    return vec2(distancia_plano, -1.);\n}\n\n\n// Modelo de iluminación Phong con sombras duras\nfloat ModeloIluminacion(vec3 direccion, vec3 p){\n    // Calculamos la normal en el punto p.\n    vec3 normal = Normal(p);\n    float intensidad = 0.0;\n    // Intensidad Ambiente Global\n    intensidad += 0.2;\n    // Punto p de la isosuperficie, separado del suelo para ayuda a acelerar el cálculo de \n    p = p + normal * 0.1;\n    // Intensidad de cada Luz\n    // Luz 1.\n    vec3 posicion_luz_1 = vec3(3.0, 3.0, 1.);\n    vec3 d_luz_1 = posicion_luz_1 - p;\n    vec3 dir_luz_1 = normalize(d_luz_1);\n    float dst_luz_1 = length(d_luz_1);\n    // En el caso de que se trate de una luz direccional, utilizaremos el plano MAXIMO, utilizado antes.\n    if(SphereMarching(p, dir_luz_1, dst_luz_1).x >= dst_luz_1){\n        // Intensidad Difusa\n        intensidad += dot01(d_luz_1, normal);\n        // Intensidad Especular (Si no es direccional)\n        vec3 r_luz_1 = reflect(d_luz_1, normal);\n        intensidad += f_difusa(dst_luz_1) * h3(dot01(r_luz_1, direccion));\n    }\n    \n    // Luz 2. Direccional\n    vec3 dir_luz_2 = -normalize(vec3(1., 0., 0.));\n    // En el caso de que se trate de una luz direccional, utilizaremos el plano MAXIMO, utilizado antes.\n    if(SphereMarching(p, dir_luz_2, MAXIMO).x >= MAXIMO){\n        // Intensidad Difusa\n        intensidad += dot01(dir_luz_2, normal);\n    }\n    \n    return clamp(intensidad, 0.0, 1.0);\n}\n\n// Devuelve el color del material en el punto p\nvec4 obtenerMaterial(vec3 p, float id){\n    // Identificador del toro seccionado\n    if(id == 0.){\n        return vec4(1., 0., 0., 1.);\n    }else if(id == 1.0){\n        \n    \tvec3 n = normalize(p);\n        vec2 uv = vec2(\n            atan(n.x, n.z) / (2.*PI) + 0.5,\n        \tn.y * 0.5 + 0.5\n        );\n\n        // Ejemplo : TFG 0-1 Homotopía - https://www.shadertoy.com/view/wt2fR1\n        // Canales RGB\n        vec3 textura0 = texture(iChannel0, uv).rgb;\n        vec3 textura1 = texture(iChannel1, uv).rgb;\n        // Máscara t.\n        float mascara = min(texture(iChannel2, uv * 0.25).r * 2.0, 1.0);\n\n        // Homotopías\n        vec3 homotopia2 = mix(textura0, textura1, h(mascara));\n\n        \n        return vec4(homotopia2, 1.);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Calculate uv for a texel\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.y, iResolution.x);\n    // Definimos el ojo y la pantalla, que se encuentra en nuestra escena. Este debe estar detrás de la pantalla ya que de este se “lanzarán” los rayos que pasarán por la pantalla.\n    vec3 ojo = vec3(0.0, 0.0, -1.0);\n    vec3 pantalla = vec3(uv, 0.0);\n    // Es fácil observar que la dirección del rayo es el vector normalizado que apunta desde el ojo hasta la pantalla\n    vec3 direccion = normalize(pantalla - ojo);\n    // Con esto, ya podemos utilizar nuestro Sphere marcher.\n    vec2 informacion = SphereMarching(ojo, direccion, MAXIMO);\n    // Tomamos la primera componente, que es la distancia a la superficie.\n    if(informacion.x < MAXIMO){\n        // Estamos aproximadamente sobre la isosuperficie. El vector, será el formado por el ojo, con su dirección modulada con la distancia recorrida, equivalente a la distancia a la isosuperficie desde el ojo.\n        // Veremos además cómo podemos añadir un material a cada objeto.\n        // Tomamos la primera componente que es la distancia\n        vec3 p = ojo + direccion * informacion.x;\n        // Con la información actual, podemos aplicar un modelo de iluminación.\n        float intensidad = ModeloIluminacion(direccion, p);\n        // Utilizamos el color blanco para dibujar la isosuperficie.\n        fragColor = obtenerMaterial(p, informacion.y) * intensidad;\n    }else{\n        // Estamos en el fondo de la escena.\n\n        // Utilizamos el color negro para dibujar el fondo.\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}