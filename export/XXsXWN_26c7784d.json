{"ver":"0.1","info":{"id":"XXsXWN","date":"1709544713","viewed":105,"name":"[zznewclear13] Sample Disk","username":"zznewclear13","description":"Wait and see!\n\nLeft: concentric map method by Peter Shirley.\nRight: conventional sqrt method.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","circle","sample","disk","uniform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Sample Disk\n// https://www.shadertoy.com/view/XXsXWN\n\n// Wait and see!\n// Left: concentric map method by Peter Shirley.\n// https://psgraphics.blogspot.com/2011/01/improved-code-for-concentric-map.html\n// Right: conventional sqrt method.\n// No idea who was the first to propose this...\n\n// Right is more efficient\n// As @chronos pointed out, the artifacts come from my hash function...\n// You can see a bright dot in the center.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec3 bufferA = texelFetch(iChannel0, iFragCoord, 0).rgb;\n    vec3 color = bufferA;\n    color = pow(color, vec3(0.4545f));\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Uncomment one of these lines to see result using a better hash function.\n// #define EVEN_BETTER_HASH\n// #define BETTER_HASH\n// Float seed hash does not seem to be so good, it does not even converge...\n// #define FLOAT_SEED_HASH\n\n// Uncomment this line to see how two [0, 1) floats are mapped to one point within disk.\n// #define VISUALIZE\n\n#define SAMPLE_COUNT 512\n\n#define PI 3.1415926f\n\n//Random functions\n#if defined(EVEN_BETTER_HASH)\nuint seed;\n// https://github.com/skeeto/hash-prospector/issues/19#issuecomment-1120105785\nuint lowbias32(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x21f0aaadU;\n    x ^= x >> 15;\n    x *= 0x735a2d97U;\n    x ^= x >> 15;\n    return x;\n}\nfloat GetRandom(){return float(lowbias32(seed++))*uintBitsToFloat(0x2F7FFFFFu);}\n\n#elif defined(BETTER_HASH)\n// Hash Functions for GPU Rendering\n// https://www.shadertoy.com/view/XlGcRh\nuint seed;\n// https://www.pcg-random.org/\nuint pcg(uint v)\n{\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn (word >> 22u) ^ word;\n}\nfloat GetRandom(){return float(pcg(seed++))*uintBitsToFloat(0x2F7FFFFFu);}\n\n#elif defined(FLOAT_SEED_HASH)\nfloat seed;\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat GetRandom(){float hash=hash11(seed);seed+=hash+1.0f;return hash;}\n\n#else\nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n#endif\n\nvec2 sampleDisk(vec2 rv, uint type)\n{\n    float r, phi;\n    if (type == 0u)\n    {\n        // https://psgraphics.blogspot.com/2011/01/improved-code-for-concentric-map.html\n        vec2 ab = rv * 2.0f - 1.0f;  \n        if (ab.x * ab.x > ab.y * ab.y) // Why don't we use abs here?\n        {\n            r = ab.x;\n            phi = PI / 4.0f * (ab.y / ab.x);\n        }\n        else\n        {\n            r = ab.y;\n            phi = PI / 4.0f * (ab.x / ab.y) + PI / 2.0f;\n        }\n    }\n    else\n    {\n        // This is almost everywhere.\n        r = sqrt(rv.x);\n        phi = 2.0f * PI * rv.y;\n    }\n    return vec2(cos(phi), sin(phi)) * r;\n}\n\nfloat drawCircle(vec2 fragCoord, vec2 p, float radius)\n{\n    float sdCircle = length(fragCoord - p) - radius;\n    float alpha = smoothstep(1.5f, 0.0f, sdCircle);\n    return alpha;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0f);\n    if (iFrame == 0)\n    {\n        fragColor = vec4(color, 0.0f);\n        return;\n    }\n \n    uint type = fragCoord.x<=iResolution.x*0.5f ? 0u : 1u;\n\n#if defined(EVEN_BETTER_HASH)\n    seed = lowbias32(uint(iFrame));\n#elif defined(BETTER_HASH)\n    seed = pcg(uint(iFrame));\n#elif defined(FLOAT_SEED_HASH)\n    seed = hash11(iTime);\n#else\n    seed = iTime;\n#endif\n    for (int i=0;i<SAMPLE_COUNT;++i)\n    {\n        vec2 rv = vec2(GetRandom(), GetRandom());\n        vec2 pointOnDisk = sampleDisk(rv, type);\n        vec2 p = iResolution.xy * 0.5f + vec2(type==0u?-iResolution.x:iResolution.x, 0.0f)*0.25f\n                    + pointOnDisk * iResolution.x * 0.2f;\n\n        float circleAlpha = drawCircle(fragCoord, p, 2.0f);\n#if defined(VISUALIZE)\n        vec3 circleColor = vec3(rv, 0.0f);\n#else\n        vec3 circleColor = vec3(1.0f, 1.0f, 1.0f) \n                            * ((iResolution.x/640.0f) * (iResolution.x/640.0f) * 1000.0f / float(SAMPLE_COUNT));\n#endif\n        color += circleColor * circleAlpha;\n    }\n\n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 bufferA = texelFetch(iChannel0, iFragCoord, 0);\n#if defined(VISUALIZE)\n    color += bufferA.rgb * 0.95f;\n    fragColor = vec4(color, 1.0f);\n#else\n    bufferA.a += 1.0f;\n    color = mix(bufferA.rgb, color, 1.0f / bufferA.a);\n    fragColor = vec4(color, bufferA.a); \n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}