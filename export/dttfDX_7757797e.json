{"ver":"0.1","info":{"id":"dttfDX","date":"1701691809","viewed":114,"name":"Analytical Triangle Soft Shadows","username":"Oberdiah","description":"Analytically evaluating occlusion from triangular light sources.\nTakes ~20s to compile on Windows. Would really appreciate help lowering that if anyone has any suggestions!\nYou can comment DO_CAMERA_ORBIT to WASD + Mouse.","likes":8,"published":1,"flags":48,"usePreview":1,"tags":["triangle","shadow","softshadows","occlusion","analytical","analysis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This demo only uses four opaque triangles and two emissive triangles, but\n// more can be added without issue, see the \"Triangle setup\" section in\n// the middle of Buffer A.\n// If you're seeing artifacting when adding additional tris, put the MAX_SPLITS in the\n// Common file up.\n// It makes it take far longer to compile (at least on Windows) but should get rid\n// of the artifacts.\n//\n// Triangles clipping through each other may also cause issues.\n//\n// The buffer is used only to store camera positional information so you can move around the scene\n// with WASD, it is not used as part of the rendering. Enable free-flight by commenting out\n// DO_CAMERA_ORBIT in Buffer A.\n//\n// This demo works by subtracting occluder triangles from each emissive, resulting\n// in a list of new emissive triangles that don't overlap the given occluder.\n// This is repeated until all occluders have been subtracted, at which point the list of emissive\n// triangles remaining can be summed analytically directly, using IQ's triangle\n// occlusion function (https://www.shadertoy.com/view/XdjSDy)\n// \n// The triangle-triangle subtraction method is taken from https://stackoverflow.com/a/5690074\n// and adapted to work in 3D.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ### Constants ###\n\nconst uint MAX_SPLITS = 10u;\nconst uint NUM_ABSORBS = 4u;\nconst uint NUM_EMISSIVES = 2u;\n\n// ### Structs ###\n\nstruct TriList {\n    mat3[MAX_SPLITS] tris;\n    uint len;\n};\n\nTriList newTriList() {\n    TriList list;\n    list.len = 0u;\n    return list;\n}\n\nvoid addTriToList(inout TriList list, mat3 tri) {\n    // WebGL is super fun sometimes\n    for (uint i = 0u; i < MAX_SPLITS; i++) {\n        if (list.len == i) {\n            list.tris[i] = tri;\n            break;\n        }\n    }\n    list.len += 1U;\n}\n\nstruct Polygon {\n    // Nothing we do has more than 6 verts.\n    vec3[6] verts;\n    uint len;\n};\n\nPolygon newPolygon() {\n    Polygon poly;\n    poly.len = 0u;\n    return poly;\n}\n\nPolygon newPolygonFromTri(mat3 tri) {\n    Polygon poly;\n    poly.verts[0] = tri[0];\n    poly.verts[1] = tri[1];\n    poly.verts[2] = tri[2];\n    poly.len = 3u;\n    return poly;\n}\n\nvoid addVertToPolygon(inout Polygon polygon, vec3 value) {\n    switch (polygon.len) {\n        case 0u: polygon.verts[0] = value;\n        case 1u: polygon.verts[1] = value;\n        case 2u: polygon.verts[2] = value;\n        case 3u: polygon.verts[3] = value;\n        case 4u: polygon.verts[4] = value;\n        case 5u: polygon.verts[5] = value;\n    }\n    polygon.len += 1U;\n}\n\nstruct LineSegment {\n    vec3 p1;\n    vec3 p2;\n};\n\nLineSegment newLineSegment(vec3 p1, vec3 p2) {\n    LineSegment line;\n    line.p1 = p1;\n    line.p2 = p2;\n    return line;\n}\n\n// ### Utility Functions ###\n\n// Taken from https://www.shadertoy.com/view/MlGcDz\nvec3 triIntersect(vec3 ro, vec3 rd, mat3 tri, out vec3 n) {\n    rd = normalize(rd);\n    vec3 v1v0 = tri[1] - tri[0];\n    vec3 v2v0 = tri[2] - tri[0];\n    vec3 rov0 = ro - tri[0];\n\n    n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );  \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3(t, u, v);\n}\n\n// Taken from https://www.shadertoy.com/view/XdjSDy\nfloat triOcclusion(vec3 pos, vec3 nor, mat3 tri) {\n    vec3 v0 = tri[0];\n    vec3 v1 = tri[1];\n    vec3 v2 = tri[2];\n    vec3 a = normalize( v0 - pos );\n    vec3 b = normalize( v1 - pos );\n    vec3 c = normalize( v2 - pos );\n    \n    float s = sign(dot(v0-pos,cross(v1-v0,v2-v1))); // side of the triangle\n\n    return max(\n       s*(dot( nor, normalize( cross(a,b)) ) * acos( dot(a,b) ) +\n          dot( nor, normalize( cross(b,c)) ) * acos( dot(b,c) ) +\n          dot( nor, normalize( cross(c,a)) ) * acos( dot(c,a) ) ) / 6.2831,\n       0.\n    );\n}\n\nbool doesLineFromAToBIntersectTri(vec3 a, vec3 b, mat3 tri) {\n    vec3 n;\n    float hitDist = triIntersect(a, b - a, tri, n).x;\n    if (hitDist < 0. || hitDist > length(b - a)) {\n        return false;\n    }\n    return true;\n}\n\nvec4 planeFromPoints(vec3 p1, vec3 p2, vec3 p3) {\n    vec3 v1 = p2 - p1;\n    vec3 v2 = p3 - p1;\n    vec3 normal = normalize(cross(v1, v2));\n    float D = -dot(normal, p1);\n    return vec4(normal, D);\n}\n\nvec4 planeFromLinePoint(LineSegment line, vec3 p) {\n    return planeFromPoints(line.p1, line.p2, p);\n}\n\nvoid clear(inout TriList tris) {\n    tris.len = 0u;\n}\n\nuint add1(uint i) {\n    return (i + 1u) % 3u;\n}\n\nvoid forceCCW(inout mat3 tri, vec3 p) {\n    vec3 n = cross(tri[1] - tri[0], tri[2] - tri[0]);\n    vec3 viewVec = p - tri[0];\n    if (dot(n, viewVec) > 0.) {\n        vec3 temp = tri[0];\n        tri[0] = tri[1];\n        tri[1] = temp;\n    }\n}\n\nvec3 linePlaneIntersection(LineSegment line, vec4 plane) {\n    vec3 lineDir = line.p2 - line.p1;\n    float denom = dot(plane.xyz, lineDir);\n    if (abs(denom) < 1e-6) {\n        return vec3(1e20);\n    }\n    float t = -(dot(plane.xyz, line.p1) + plane.w) / denom;\n    if (t >= 0. && t <= 1.) {\n        return line.p1 + t * lineDir;\n    }\n    return vec3(1e20);\n}\n\n// ### Core Tri-splitting Algorithm\n\nbool specialIntersectsTri(uint zero, mat3 triA, LineSegment line1, vec3 p) {\n    for (uint aId = zero; aId < 3u; aId++) {\n        LineSegment line2 = newLineSegment(triA[aId], triA[add1(aId)]);\n        vec4 plane1 = planeFromLinePoint(line1, p);\n        vec3 intersection1 = linePlaneIntersection(line2, plane1);\n        if (length(intersection1) < 1e19) {\n             vec4 plane2 = planeFromLinePoint(line2, p);\n             vec3 intersection2 = linePlaneIntersection(line1, plane2);\n             if (length(intersection2) < 1e19) {\n                 vec3 i1 = p - intersection1;\n                 vec3 i2 = p - intersection2;\n                 float distToI1 = length(i1);\n                 float distToI2 = length(i2);\n                 if (distToI1 > distToI2 && dot(i1, i2) > 0.) {\n                     return true;\n                 }\n             }\n        }\n    }\n\n    // We also want to count situations where the entire line is 'inside' triA.\n    // We can do that by checking if one of its points is.\n    vec3 n;\n    vec3 pa = line1.p1 - p;\n    float hitDist = triIntersect(p, pa, triA, n).x;\n    if (hitDist > length(pa)) {\n        return true;\n    }\n    \n    return false;\n}\n\nPolygon getOuterPoly(uint zero, inout Polygon innerPoly, vec4 plane) {\n    Polygon oldPoly = innerPoly;\n    innerPoly.len = 0u;\n    \n    Polygon outerPoly = newPolygon();\n    \n    bool inside = true;\n    \n    for (uint i = zero; i < oldPoly.len; i++) {\n        vec3 P = oldPoly.verts[i];\n        vec3 Q = oldPoly.verts[(i + 1u) % oldPoly.len];\n        \n        if (inside) { \n            addVertToPolygon(innerPoly, P);\n        } else {\n            addVertToPolygon(outerPoly, P);\n        }\n        LineSegment E = newLineSegment(P, Q);\n        vec3 R = linePlaneIntersection(E, plane);\n        if (length(R) < 1e19) {\n            if (inside) { \n                addVertToPolygon(innerPoly, R);\n            } else {\n                addVertToPolygon(outerPoly, R);\n            }\n            inside = !inside;\n            if (inside) { \n                addVertToPolygon(innerPoly, R);\n            } else {\n                addVertToPolygon(outerPoly, R);\n            }\n        }\n    }\n    \n    return outerPoly;\n}\n\nvoid triangulateIntoTriList(uint zero, inout TriList tris, Polygon poly) {\n    if (poly.len <= 3u) {\n        if (poly.len == 3u) {\n            addTriToList(tris, mat3(poly.verts[0], poly.verts[1], poly.verts[2]));\n        }\n        // In theory 1 and 2 should never happen\n        return;\n    }\n    \n    vec3 origin = poly.verts[0];\n    for (uint i = 1u + zero; i < poly.len - 1u; i++) {\n        addTriToList(tris, mat3(origin, poly.verts[i], poly.verts[i + 1u]));\n    }\n}\n\n// Adapted to 3D from https://stackoverflow.com/a/5690074\nvoid insertTriDifference(uint zero, inout TriList tris, mat3 triA, mat3 triB, vec3 p) {\n    forceCCW(triB, p);\n    \n    vec3 n;\n    bool insideB = true;\n    for (uint aId = zero; aId < 3u; aId++) {\n        if (!doesLineFromAToBIntersectTri(p, triA[aId], triB)) {\n            insideB = false;\n            break;\n        }\n    }\n    \n    if (insideB) {\n        // This point cannot see triA at all.\n        return;\n    }\n    \n    uint triLenBefore = tris.len;\n    \n    Polygon currentPoly = newPolygonFromTri(triA);\n    for (uint bId = zero; bId < 3u; bId++) {\n        LineSegment bLine = newLineSegment(triB[bId], triB[add1(bId)]);\n        if (specialIntersectsTri(zero, triA, bLine, p)) {\n            vec4 plane = planeFromLinePoint(bLine, p);\n            Polygon outerPoly = getOuterPoly(zero, currentPoly, plane);\n            \n            if (dot(plane, vec4(outerPoly.verts[1], 1)) > 0.) {\n                Polygon temp = currentPoly;\n                currentPoly = outerPoly;\n                outerPoly = temp;\n            }\n            \n            triangulateIntoTriList(zero, tris, outerPoly);\n        }\n    }\n    \n    if (tris.len == triLenBefore) {\n        addTriToList(tris, triA);\n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define movespeed 1.0\n\n#define MOVE_FORW  87\n#define MOVE_LEFT  65\n#define MOVE_RIGHT 68\n#define MOVE_BACK  83\n#define MOVE_UP    32\n#define MOVE_DOWN  17\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n// Uncomment to see how the emissive triangles are clipped from the camera's perspective\n//#define DEBUG_CLIPPING\n// Comment to use WASD + Mouse to move around.\n#define DO_CAMERA_ORBIT\n\nconst int NUM_SAMPLES = 256;\n\nfloat getkey(int x, int y){\n    return texelFetch(iChannel1, ivec2(x,y), 0).x;\n}\n\n// Taken from https://www.shadertoy.com/view/4dKfRd\nbool evaluateInput(inout vec3 rayDir, inout vec3 rayPos, inout vec4 fragColor, in vec2 fragCoord) {\n    rayDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    rayDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n\t\n    vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                     getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                     getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n    \n    if ( ivec2(fragCoord) == ivec2(0)) {\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        vec3 rd2 = vec3(0,0,1);\n        rd2.yz *= rot(mouse.y*3.14-3.14*0.5);\n        rd2.xz *= rot(mouse.x*3.14*2.0-3.14);\n        \n        mat3 rotate = mat3(normalize(cross(vec3(0,1,0),rd2)),vec3(0),rd2);\n        rotate[1] = cross(rotate[2],rotate[0]);\n        \n        fragColor.xyz = rayPos+move*movespeed*iTimeDelta*transpose(rotate);\n\t\treturn true;\n    }\n    return false;\n}\n\n// So the compiler doesn't inline the loops.\n#define zero (uint(min(iFrame, 0)))\n\nvec3 getLighting(\n    vec3 p,\n    vec3 n,\n    mat3[NUM_ABSORBS] absorbTris,\n    mat3[NUM_EMISSIVES] emitTris,\n    vec3[NUM_EMISSIVES] emitColors\n) {\n    vec3 lightHere = vec3(0.);\n    TriList splitTris = newTriList();\n    TriList newSplitTris = newTriList();\n    \n    for (uint emitI = zero; emitI < NUM_EMISSIVES; emitI++) {\n        clear(splitTris);\n        clear(newSplitTris);\n        addTriToList(splitTris, emitTris[emitI]);\n        \n        for (uint absorbI = zero; absorbI < NUM_ABSORBS; absorbI++) {\n            clear(newSplitTris);\n            mat3 absorbTri = absorbTris[absorbI];\n        \n            // todo optimisation - check if this absorb tri was even overlapping the original?\n            \n            for (uint splitI = zero; splitI < splitTris.len; splitI++) {\n                insertTriDifference(zero, newSplitTris, splitTris.tris[splitI], absorbTri, p);\n            }\n            splitTris = newSplitTris; // optimization: walking between the two rather than setting one to other.\n        }\n        \n        for (uint splitI = zero; splitI < splitTris.len; splitI++) {\n            lightHere += triOcclusion(p, n, splitTris.tris[splitI]) * emitColors[emitI];\n        }\n    }\n\n    return lightHere;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.5;\n    //float time = 0.0;\n    \n    vec2 p = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    float aspect = iResolution.y / iResolution.x;\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    #ifdef DO_CAMERA_ORBIT\n    float s = (2.0*iMouse.x-iResolution.x) / iResolution.y;\n    if( iMouse.z<0.001 ) s=0.0;\n    #else\n    float s = 0.;\n    #endif\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    \n    vec3 rd = normalize(vec3(0.0, 0.0, 0.65) + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV);\n    #ifdef DO_CAMERA_ORBIT\n    float orbitTime = time * 0.2;\n    vec3 ro = vec3(sin(orbitTime), .33, cos(orbitTime)) * 3. + vec3(1., 0., 1.);\n    rd.xz *= rot(orbitTime + 3.14);\n    #else\n\tvec3 ro = texelFetch(iChannel0, ivec2(0), 0).xyz;\n    if (evaluateInput(rd, ro, fragColor, fragCoord)) return;\n    ro += vec3(2);\n    #endif\n    \n    // Triangle setup\n    vec3 offset1 = vec3(1., 0., sin(time) * 0.5);\n    mat3[NUM_ABSORBS] absorbTris = mat3[NUM_ABSORBS](\n        mat3(vec3(10., 0., 10.), vec3(-20., 0., 10.), vec3(10., -0., -10.)),\n        mat3(vec3(0.2, 0.4, 0.2), vec3(1.1, 0.1, 2.6), vec3(1.0, 0.9, 2.9)),\n        mat3(vec3(0.6, 1.1, 0.1) + offset1, vec3(0.5, 0.05, 1.2) + offset1, vec3(1.3, 0.5, 1.) + offset1),\n        mat3(vec3(0.8, 0.4, 0.4), vec3(1.3, 0.1, 1.6), vec3(0.2, 0.1, 2.0))\n    );\n    vec3[NUM_ABSORBS] absorbTriColors = vec3[NUM_ABSORBS](\n        vec3(0.85, 0.81, 0.81),\n        vec3(1., 0.7, 1.),\n        vec3(0.7, 0.8, 1.),\n        vec3(0.6, 1.0, 0.8)\n    );\n    vec3 offset2 = vec3(sin(time), 0., cos(time)) * 0.9;\n    vec3 offset3 = vec3(sin(time * 0.7), 0., cos(time * 0.3)) * 1.8;\n    mat3[NUM_EMISSIVES] emitTris = mat3[NUM_EMISSIVES](\n        mat3(\n            vec3(1.2, 1.1, 1.2) + offset2,\n            vec3(1.8, 1.1, 1.1) + offset2,\n            vec3(1.2, 1.1, 2.4) + offset2\n        ),\n        mat3(\n            vec3(2.2, 2.2 + sin(time + 1.) * 0.1, 1.2) + offset3,\n            vec3(2.8, 2.4 + sin(time + 2.) * 0.1, 1.1) + offset3,\n            vec3(2.2, 2.3 + sin(time + 3.) * 0.1, 2.4) + offset3\n        )\n    );\n    vec3[NUM_EMISSIVES] emitTriColors = vec3[NUM_EMISSIVES](\n        vec3(1.0, 0.85, 0.95),\n        vec3(0.8, 0.9, 1.0)\n    );\n\n    \n    // Lighting\n    vec3 col = vec3(0.);\n    float bestDist = 1e9;\n    vec3 hitNormal = vec3(0.);\n    for (uint i = zero; i < NUM_ABSORBS; i++) {\n        mat3 tri = absorbTris[i];\n        \n        vec3 normal = vec3(0.);\n        float dist = triIntersect(ro, rd, tri, normal).x;\n        if (dist > 0. && dist < bestDist) {\n            col = absorbTriColors[i];\n            bestDist = dist;\n            hitNormal = normal;\n        }\n    }\n    \n    TriList splitTris = newTriList();\n    TriList newSplitTris = newTriList();\n    bool hitEmissive = false;\n    for (uint i = 0u; i < NUM_EMISSIVES; i++) {\n        clear(splitTris);\n        clear(newSplitTris);\n        addTriToList(splitTris, emitTris[i]);\n        vec3 normal = vec3(0.);\n        \n        #ifdef DEBUG_CLIPPING\n        for (uint absorbI = zero; absorbI < NUM_ABSORBS; absorbI++) {\n            clear(newSplitTris);\n            mat3 absorbTri = absorbTris[absorbI];\n            for (uint splitI = zero; splitI < splitTris.len; splitI++) {\n                insertTriDifference(zero, newSplitTris, splitTris.tris[splitI], absorbTri, ro);\n            }\n            splitTris = newSplitTris;\n        }\n        #endif\n        \n        for (uint splitI = zero; splitI < splitTris.len; splitI++) {\n            float dist = triIntersect(ro, rd, splitTris.tris[splitI], normal).x;\n            #ifndef DEBUG_CLIPPING\n            if (dist > 0. && dist < bestDist) {\n                col = emitTriColors[i];\n                bestDist = dist;\n                hitNormal = normal;\n                hitEmissive = true;\n            }\n            #else\n            if (dist > 0.) {\n                float frac = float(splitI + 1u) / float(splitTris.len + 1u);\n                fragColor = vec4(frac);\n                return;\n            }\n            #endif\n        }\n    }\n    \n    if (!hitEmissive) {\n        if (length(hitNormal) == 0.) {\n            col *= 0.0;\n        } else if (col == vec3(1.)) {\n        } else {\n            hitNormal = normalize(hitNormal);\n            if (dot(hitNormal, -rd) < 0.) {\n                hitNormal = -hitNormal;\n            }\n\n            vec3 hitPos = rd * bestDist * 0.9999 + ro;\n            #ifndef DEBUG_CLIPPING\n            vec3 lighting = vec3(1.);\n            if (p.x > s) {\n                lighting = getLighting(hitPos, hitNormal, absorbTris, emitTris, emitTriColors);\n            } else {\n                lighting = vec3(0.);\n                vec4 rrr = texture( iChannel3, (fragCoord.xy)/iChannelResolution[0].xy, -99.0  ).xzyw;\n                vec3  ru  = normalize( cross( hitNormal, vec3(0.0,1.0,1.0) ) );\n                vec3  rv  = normalize( cross( ru, hitNormal ) );\n\n                for( int i = 0; i<NUM_SAMPLES; i++ ) {\n                    // Hemispherical sampling taken from https://www.shadertoy.com/view/4djSDy\n                    vec2  aa = hash2( rrr.x + float(i)*(23.1125/float(NUM_SAMPLES)) );\n                    float ra = sqrt(aa.y);\n                    float rx = ra*cos(6.2831*aa.x); \n                    float ry = ra*sin(6.2831*aa.x);\n                    float rz = sqrt( 1.0-aa.y );\n                    vec3 dir = normalize(vec3( rx*ru + ry*rv + rz*hitNormal ));\n                    vec3 rPos = hitPos+hitNormal*0.001;\n                    \n                    bestDist = 1e9;\n                    for (uint i = 0u; i < NUM_ABSORBS; i++) {\n                        mat3 tri = absorbTris[i];\n                        vec3 normal = vec3(0.);\n                        float dist = triIntersect(rPos, dir, tri, normal).x;\n                        if (dist > 0. && dist < bestDist) {\n                            bestDist = dist;\n                        }\n                    }\n                    \n                    vec3 emissiveColor = vec3(0.);\n                    for (uint i = zero; i < NUM_EMISSIVES; i++) {\n                        mat3 tri = emitTris[i];\n                        vec3 normal = vec3(0.);\n                        float dist = triIntersect(rPos, dir, tri, normal).x;\n                        if (dist > 0. && dist < bestDist) {\n                            bestDist = dist;\n                            emissiveColor = emitTriColors[i];\n                        }\n                    }\n                    \n                    lighting += emissiveColor;\n                }\n                lighting /= float(NUM_SAMPLES);\n            }\n            \n            col *= 0.001 + lighting;\n            #endif\n        }\n\n        #ifndef DEBUG_CLIPPING\n        col *= 10.0;\n        col = col / (1. + col);\n        col = pow(col, vec3(0.5));\n        #endif\n    }\n    \n    col += texture(iChannel2, fragCoord / 8.).r / 255.;\n    \n    float e = 2.0/iResolution.y;\n    col *= smoothstep( 0.0, 2.0*e, abs(p.x-s) );\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}