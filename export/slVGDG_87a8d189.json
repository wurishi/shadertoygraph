{"ver":"0.1","info":{"id":"slVGDG","date":"1638281245","viewed":124,"name":"Slicing Practice","username":"panna_pudi","description":"I still have no idea how to combine several cuts with rotation.\ncmarangu already implemented this, but I can't read their code @.@\nhttps://www.shadertoy.com/view/tddGzf","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","cut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float MAX_DIST = 30.;\nconst float PI = acos(-1.);\nconst float TAU = PI * 2.;\n\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_box(vec3 p, vec3 r) {\n    p = abs(p) - r;\n    return length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n// https://jbaker.graphics/writings/DEC.html\nfloat sd_dodecahedron(vec3 p, float radius) {\n    const float phi = 1.61803398875;\n    const vec3 n = normalize(vec3(phi, 1, 0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a, b), c) - n.x) * radius;\n}\n\nfloat shape(vec3 p) {\n    return sd_dodecahedron(p, 0.2);\n}\n\nstruct Cut {\n    vec3 off;\n    float d;\n    float sign;\n};\n\nCut op_cut(inout vec3 p, vec3 n, float w, float width) {\n    float dt = dot(p, n) - w;\n    float dcut = abs(dt) - width;\n    float s = sign(dt);\n    return Cut(width * n * s, dcut, s);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + cross(ax, p) * sin(ro);\n}\n\nfloat map(vec3 p) {\n    float d = 10e10;\n\n    d = min(d, shape(p));\n    float width = 0.1 * abs(sin(iTime));\n\n    {\n        Cut cut = op_cut(p, vec3(0., 1., 0.), 0.0, width);\n        d = min(d, max(-cut.d, shape(p - cut.off + vec3(0.5, 0.0, 0.0))));\n    }\n\n    {\n        Cut cut = op_cut(p, vec3(0., 1., 0.), 0., width);\n        d = min(d, max(-cut.d, shape(p + vec3(0.0, 0.0, 0.5))));\n    }\n\n    {\n        vec3 q = p;\n        vec3 dir = normalize(vec3(0., 1., 0.));\n        Cut cut = op_cut(q, dir, 0., width);\n        float should_rot = max(0., cut.sign);\n        q -= cut.off + vec3(0.0, 0.0, 0.5);\n        q = erot(q, dir, should_rot * width * 2. * TAU);\n        d = min(d, max(-cut.d, shape(q)));\n    }\n\n    {\n        vec3 q = p - vec3(0.5, 0., 0.);\n        vec3 dir_a = normalize(vec3(0., 1., 0.));\n        Cut cut_a = op_cut(q, dir_a, 0., width);\n        vec3 dir_b = normalize(vec3(0., 0., 1.));\n        Cut cut_b = op_cut(q, dir_b, 0., width);\n        vec3 dir_c = normalize(vec3(1., 0., 0.));\n        Cut cut_c = op_cut(q, dir_c, 0., width);\n        q -= cut_a.off + cut_b.off + cut_c.off;\n        d = min(d, max(-(min(min(cut_a.d, cut_b.d), cut_c.d)), shape(q)));\n    }\n\n    return d;\n}\n\nvec3 get_normal(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.0001);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\nmat3 camera(vec3 eye, vec3 to) {\n    vec3 zaxis = normalize(to - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nvec3 sky(vec2 uv, vec3 rd) {\n    vec3 col = vec3(0.);\n    col += (uv.y + 0.8) * 0.001; \n    col += smoothstep(-0.4, 0.4, dot(rd, normalize(vec3(0.9, 0.2, 0.6)))) *\n           vec3(0.1, 0.4, 0.3) * 0.1;\n    col += smoothstep(-0.4, 0.4,\n               dot(rd + vec3(0.0, 0.7, 0.0), normalize(vec3(0.0, -0.2, 0.0)))) *\n           vec3(0.1, 0.0, 0.3) * 0.1;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\n    float time = iTime;\n\n    float an = TAU * time / 40.;\n    vec3 ta = vec3(0., 0., 0.);\n    vec3 ro = ta + 1.0 * vec3(cos(an), 0.6, sin(an));\n\n    mat3 cam = camera(ro, ta);\n    vec3 rd = cam * normalize(vec3(uv, 1.5));\n\n    float t = 0.;\n    for (int i = 0; i < 100; ++i){\n        vec3 pos = ro + rd * t;\n        float d = map(pos);\n        if (abs(d) < 0.001) break;\n        t += d;\n        if (t > MAX_DIST) break;\n    }\n\n    vec3 col = vec3(0.01);\n    col += sky(uv, rd);\n    if (t < MAX_DIST) {\n        vec3 lig =  normalize(vec3(0., 1., 0.));\n        vec3 pos = ro + rd * t;\n        vec3 nor = get_normal(pos);\n\n        vec3 reflection = sky(uv, reflect(rd, nor));\n\n        float fresnel = pow(1.0 - abs(dot(nor, rd)), 5.0);\n        fresnel = mix(.03, 1.0, fresnel);\n\n        vec3 rd = reflect(pos, nor);\n        float dif = dot(nor, lig) * 0.5 + 0.5;\n        col = mix(vec3(1.) * 0.5 * dif, reflection, vec3(fresnel));\n    }\n    \n    col += sin(fragCoord.x * 114.0) * sin(fragCoord.y * 251.9) / 2048.0;\n    \n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}