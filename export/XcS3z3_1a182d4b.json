{"ver":"0.1","info":{"id":"XcS3z3","date":"1704446380","viewed":46,"name":"star in beautiful place","username":"nayk","description":"star,colorful,place,neon\nmoving \nKey LEFT,RIGHT,UP, DOWN","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["colorful","star","neon","place"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*originals https://www.shadertoy.com/view/DtGyWh https://www.shadertoy.com/view/XfS3zV*/\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat gyroid(vec3 p, float scale)\n{    p.yx *= Rot(T);\n\n    p *=scale;\n    return abs(dot(0.6 * sin(p), cos(p.yzx)*0.05)/10.);\n}\n\nfloat GetDist(vec3 p) {\n    \n    float ball = length(p)-0.3;\n    ball = abs(ball)-0.05;\n    float s2 = length(p)-1.2;\n    float s = length(p)-0.8;\n    s = abs(s)-0.02;\n    //float bs = min(s, ball);\n    \n    s2 = abs(s2)-0.03;\n     \n    float s_gy = gyroid(p,5.);\n    float s_gy2 = gyroid(p,10.);\n\n    \n    //float ss = min(s,s2);\n    \n    float sg1 = smin(s, s_gy, -0.025);\n    float sg2 = smin(s2, s_gy2, -0.025);\n    \n    float d = sdBox(p, vec3(1));\n    \n    \n    float g = p.y + 1.5;\n    p.z -= T * 0.1;\n    p*= 5.;\n    p.y += 1. - abs(sin(p.z*.2) + cos(p.z * .1));\n    float y = abs(dot(sin(p), cos(p.yzx)*0.05));\n    g += y;\n    \n\n    \n    \n    return min(sg1,min(sg2, g));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\nfloat beautiful_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\nbool ReadKey( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel0, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(42,53,21))*.5+.5)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec4 O =fragColor;\n    vec2 C =fragCoord;\n    \nO=vec4(0);\n    \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.y = max(-.9, ro.y);\n    \n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d2 = RayMarch(ro, rd);\n\n    if(d2<MAX_DIST) {\n        vec3 p = ro + rd * d2;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 lightDir = -normalize(p);\n        float dif = dot(n, lightDir)*.5+.5;\n        \n        float cd = length(p);\n        \n        col = vec3(dif);\n\n        if(cd > 1.03)\n        {\n            //col *= vec3(1.,0.,0.);\n            float s = gyroid(-lightDir, 10.);\n            float w = cd*.002;\n            float shadow = smoothstep(-w,w, s);\n            \n            col *= shadow;\n            \n            col/= cd * cd;\n        }\n        \n        \n    }\n    \n    //Glow\n    float cd = dot(uv, uv);\n    float light = 0.003/cd;\n    \n    vec3 lightCol = vec3(1.522,0.471,0.569);\n    col += light * S(0.,0.5, d2-3.) * lightCol;\n    float s = gyroid(normalize(ro), 5.);\n    col += light * S(0. , 0.03, s)*lightCol;\n    \n \n    float a = atan(uv.x, uv.y);\n    float lr = sin(a * 11. - T) * sin(a * 7. + T) * sin(a * 5. - T);\n    \n    vec3 nat,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        nat=g*d;\n      \n          nat.xz *= Rot(-m.x*TAU);\n          \n nat.yz *= Rot(m.y*TAU);\n        a=20.;\n         if(ReadKey(KEY_UP, false))\n    {\n        nat.x+=-iTime*10.1;\n    \t\n    }\n    \n\t// Check for key right pressed\n    if(ReadKey(KEY_DOWN , false))\n    {\n        // if key up is pressed, then white\n    \tnat.x+=iTime*10.1;\n    }\n    \n    \n     if(ReadKey(KEY_RIGHT, false))\n    {\n        nat.y+=iTime*10.1;\n    \t\n    }\n    \n\t// Check for key right pressed\n    if(ReadKey(KEY_LEFT , false))\n    {\n        // if key up is pressed, then white\n    \tnat.y+=-iTime*10.1;\n    }\n        nat=mod(nat-a,a*2.)-a;\n        s=3.;\n        for(int i=0;i++<8;){\n            nat=.3-abs(nat);\n            \n            nat.x<nat.z?nat=nat.zyx:nat;\n            nat.z<nat.y?nat=nat.xzy:nat;\n            nat.y<nat.x?nat=nat.zyx:nat;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            nat=abs(nat)*e-\n                vec3(\n                    12.+cos(iTime*.3+.5*cos(iTime*.3))*3.,\n                    80,\n                    3.+cos(iTime*.5)*5.\n                 )+col;\n         }\n       //  g+=e=length(p.yz)/s;\n         g+=e=length(nat.yx)/s;\n    }\n      \n    lr *= S(0., 0.4, cd);\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5);\n    \n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n   \n    col += max(lr,0.);\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(O.xyz,1.0);\n    fragColor+= vec4(beautiful_star(uv,anim) * vec3(0.55,0.5,0.55)*0.3, 1.0);\n}","name":"Image","description":"","type":"image"}]}