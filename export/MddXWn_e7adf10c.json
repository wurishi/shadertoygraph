{"ver":"0.1","info":{"id":"MddXWn","date":"1459000584","viewed":173,"name":"Retro Snaker test","username":"DeMaCia","description":"Retro Snaker v0.6 demo.\nmove:up,down,left,right arrow.\nreplay:Enter.\npause:space.\n","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["2d","test","game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 tx_sta = vec2(0.,0.);\t//state.x init-0 pause-1 gameover-2 normal-10\nconst vec2 tx_lvSta = vec2(2.,0.);\t//lv speed score time\n\n\nconst float balNum = 100.;\t\t//ballnum \nconst vec2 tx_balDat = vec2(0.,1.);\t\t//pos-x pos-y dir-x dir-y\n\n//static value\nconst float ball_radius = .04;\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 tx )\n{\n    return texture( iChannel0, (0.5+tx) / iChannelResolution[0].xy, -100.0 );\n}\n\nvec4 col = vec4(0.);\nvec2 crd = vec2(0.);\n\nvoid drawCir(vec2 pos);\n\n//=================================================================================================\n// number\n//=================================================================================================\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    // digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\n//=================================================================================================\n\n\n//=================================================================================================\n// heart\n//=================================================================================================\nvoid drawHeart( inout vec4 col, in vec2 uv )\n{\n\tvec2 p = uv;\n\t\n\t//p.y -= 0.25;\n\n    // background color\n    //vec3 bcol = vec3(1.0,0.8,0.7-0.07*p.y)*(1.0-0.25*length(p));\n\n    // animate\n    float tt = mod(iTime,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    ss = 1.0 + ss*0.5*sin(tt*6.2831*3.0 + p.y*0.5)*exp(-tt*4.0);\n    p *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n   \n\n    // shape\n    float a = atan(p.x,p.y)/3.141593;\n    float r = length(p);\n    float h = abs(a);\n    float d = (13.0*h - 22.0*h*h + 10.0*h*h*h)/(6.0-5.0*h)*.05;\n\n\t// color\n\tfloat s = 1.0-0.5*clamp(r/d,0.0,1.0);\n\ts = 0.75 + 0.75*p.x;\n\ts *= 1.0-0.25*r;\n\ts = 0.5 + 0.6*s;\n\ts *= 0.5+0.5*pow( 1.0-clamp(r/d, 0.0, 1.0 ), 0.1 );\n\tvec3 hcol = vec3(1.0,0.5*r,0.3)*s;\n\t\n    vec3 c = mix( col.rgb, hcol, smoothstep( -0.006, 0.006, d-r) );\n\n    col = vec4(c,1.0);\n}\n\n//=================================================================================================\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float uvxp = iResolution.x/iResolution.y;\n    uv.x *= uvxp;\n    crd = uv;\n    \n    //load data\n    vec4 state = loadValue(tx_sta);\n    \n    vec4 lvSta = loadValue(tx_lvSta);\n    \n    //col = vec4(state.w,0.,0.,0.);used for test\n    \n    if(state.x < .5)\n    {//init\n    }\n    else if(state.x < 1.5)\n    {//pause\n    }\n    else if(state.x < 2.5)\n    {//gameover\n        col.rgb = mix( col.rgb, vec3(1.0,0.5,0.2), vec3(1.0,0.5,0.2) * (0.5+0.5*sin(30.0*iTime)));\n    }\n   \telse if(state.x > 9.5)\n   {//logic\n   }\n    \n    for(float idx = 0.; idx < balNum;idx++)\n    {\n        vec2 tx_bd = tx_balDat+vec2(idx,0.);\n        vec4 baldat = loadValue(tx_bd);\n\t\tif(baldat.x>.00001)\n        {\n           drawCir(baldat.xy);\n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    //heart\n    drawHeart(col,uv-state.yz);\n    \n    //score\n    float f = PrintInt( (uv-vec2(0.005,0.9))*20.0, lvSta.z );\n    col.rgb = mix( col.rgb, vec3(1.0,1.0,1.0), f );\n    \n\tfragColor = col;\n}\n\nvoid drawCir(in vec2 pos)\n{\n\tfloat radius = ball_radius;\n    vec4 cirClr = vec4(1.,0.,1.,1.);\n    float ra = 1.-smoothstep(radius-.01,radius+.01,distance(pos,crd));\n    col = mix(col,cirClr,ra);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 tx_sta = vec2(0.,0.);\t//state.x init-0 pause-1 gameover-2 normal-10 yz-heart.xy\nconst vec2 tx_lvSta = vec2(2.,0.);\t//lv speed score time\nconst vec2 tx_nextOpt = vec2(3.,0.);\t//lastPos.xy nextDir.zw\n\n\nconst float balNum = 50.;\t\t//ballnum \nconst vec2 tx_balDat = vec2(0.,1.);\t\t//pos-x pos-y dir-x dir-y data.idx-(dir-y + 0.01*idx)\n\n\n\n//static value\nconst float ball_radius = .04;\nconst float heart_radius = .03;\n\n//key\nconst float KEY_RETURN = 13.5/256.0;\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nvec2 curCoord = vec2(0.);\nvec4 colData = vec4(0.);\nfloat uvxp = 1.;\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nbool checkKeyDown(float key)\n{\n    float is = texture( iChannel1, vec2(key,0.25) ).x;\n    return is > .5;\n}\n\nvec4 loadValue( in vec2 tx )\n{\n    return texture( iChannel0, (0.5+tx) / iChannelResolution[0].xy, -100.0 );\n}\n\n\nvoid storeValue( in vec2 tx, in vec4 va)\n{\n    colData = ( isInside(curCoord,tx) > 0.0 ) ? va : colData;\n}\n\n\nfloat radomHash(float n)\n{\n    return fract(sin(n)*138.5453123+cos(n*135.426514)*124.2365147);\n}\n\nvec2 radomHeartPos()\n{\n    vec2 ret;\n    float apx = iTime*132.24645+iDate.w;\n    float apy = apx*12.12445;\n    float offset = .04;\n    ret.x = min(max(radomHash(apx),heart_radius+offset),uvxp-heart_radius-offset);\n    ret.y = min(max(radomHash(apy),heart_radius+offset),1.-heart_radius-offset);\n    \n    return ret;\n}\n\nvoid move(inout vec4 dat,in vec4 lvsta)\n{\n    //move\n    dat.x += iTimeDelta * dat.z * lvsta.y;\n    dat.y += iTimeDelta * dat.w * lvsta.y;\n}\n\nvoid fixPos(inout vec4 dat,in vec4 inf)\n{\n    if(abs(dat.z) > .5 )\n    {\n    \tdat.x = -dat.z * ball_radius * 2. + inf.x;\n        dat.y = inf.y;\n    }\n    else\n    {\n    \tdat.y = -dat.w * ball_radius * 2. + inf.y;\n        dat.x = inf.x;\n    }\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    curCoord = fragCoord;\n    colData = fragColor;\n    uvxp = iResolution.x/iResolution.y;\n    \n    //load data\n    vec4 state = loadValue(tx_sta);\n    vec4 pos = loadValue(tx_balDat);\n    vec4 nextOpt = loadValue(tx_nextOpt);\n    vec4 lvSta = loadValue(tx_lvSta);\n    \n\tif( iFrame==0 || checkKeyDown(KEY_RETURN)) state = vec4(.0);\n    \n    if(state.x < .5)\n    {//init\n    \tpos = vec4(.5,.5,1.,0.);\n        \n        state.yz = radomHeartPos();\n        lvSta = vec4(0.,.3,0.,0.);\n        nextOpt = pos;\n        \n       \tstoreValue(tx_balDat,pos);\n        \n        for(float idx = 1.; idx < balNum;idx++)\n        {\n            vec2 tx_bd = tx_balDat+vec2(idx,0.);\n            storeValue(tx_bd,vec4(-1.));\n        }\n    \n    \tstate.x = 10.;\n    }\n    else if(state.x < 1.5)\n    {//pause\n        \n    \tif(checkKeyDown(KEY_SPACE)) state.x = 10.;\n        \n    }\n    else if(state.x < 2.5)\n    {//gameover\n        \n        for(float idx = 0.; idx < balNum;idx++)\n        {\n            vec2 tx_bd = tx_balDat+vec2(idx,0.);\n            vec4 baldat = loadValue(tx_bd);\n            \n            if(baldat.x>.00001)\n            {\n                storeValue(tx_bd,baldat);\n            }\n            else\n            {\n                storeValue(tx_bd,vec4(-1.));\n            \t//break;\n            }\n        }\n    }\n   else if(state.x > 9.5)\n    {//logic\n    \n        if(checkKeyDown(KEY_SPACE)) state.x = 1.;\n        \n        vec2 lastDir = pos.zw;\n        bool isUpdateDir = false;\n        \n        //z- w|\n        if(checkKeyDown(KEY_UP)&&pos.w > -.5)\n        {\n            nextOpt.w = 1.;\n            nextOpt.z = 0.;\n        }\n        else if(checkKeyDown(KEY_DOWN)&&pos.w < .5)\n        {\n            nextOpt.w = -1.;\n            nextOpt.z = 0.;\n        }\n        else if(checkKeyDown(KEY_LEFT)&&pos.z < .5)\n        {\n            nextOpt.z = -1.;\n            nextOpt.w = 0.;\n        }\n        else if(checkKeyDown(KEY_RIGHT)&&pos.z > -.5)\n        {\n            nextOpt.z = 1.;\n            nextOpt.w = 0.;\n        }\n\n        if(distance(pos.xy,nextOpt.xy)>ball_radius*2.)\n        {\n        \tnextOpt.xy = pos.xy;\n            pos.zw = nextOpt.zw;\n            isUpdateDir = true;\n        }\n        \n\t\tlvSta.w = iTime;\n        \n        //lvSta.y = max(log(sqrt(lvSta.w*0.3))*1.2,0.3);\n\t\tlvSta.y = min(.15,lvSta.y);\n\n        \n        move(pos,lvSta);\n        storeValue(tx_balDat,pos);\n        vec4 lastDat = vec4(nextOpt.xy,lastDir.xy);\n        \n        //state.w=0.; used for test\n        for(float idx = 1.; idx < balNum;idx++)\n        {\n            vec2 tx_bd = tx_balDat+vec2(idx,0.);\n            vec4 baldat = loadValue(tx_bd);\n            \n            if(baldat.x>.00001)\n            {\n                vec4 lastSubDat=baldat;\n            \t\n                if(isUpdateDir)\n                {\n                    baldat.zw = lastDat.zw;\n                    fixPos(baldat,lastDat);\n                }\n                \n                move(baldat,lvSta);\n                \n                \n                storeValue(tx_bd,baldat);\n                \n                lastDat = lastSubDat;\n            }\n            else\n            {\n                storeValue(tx_bd,vec4(-1.));\n            \t//break;\n            }\n            \n        }\n        \n        //coll\n        if(pos.x < ball_radius || pos.x > uvxp-ball_radius ||\n          \tpos.y < ball_radius || pos.y > 1.-ball_radius )\n        {//out of screen\n        \tstate.x = 2.;\n        }\n        \n        //coll for tail\n        for(float idx = 1.; idx < balNum;idx++)\n        {\n            vec2 tx_bd = tx_balDat+vec2(idx,0.);\n            vec4 baldat = loadValue(tx_bd);\n            \n            if(baldat.x>.00001)\n            {\n                if(distance(baldat.xy,pos.xy) < ball_radius*1.)\n                {\n                \tstate.x = 2.;\n                }\n            }\n            else\n            {\n            \tbreak;\n            }\n            \n        }\n        \n        \n        \n        if(distance(pos.xy,state.yz)<ball_radius+heart_radius)\n        {//eat heart\n            \n            //add tail\n            vec4 endTail = loadValue(tx_balDat+vec2(lvSta.z,0.));\n            fixPos(endTail,endTail);\n            storeValue(tx_balDat+vec2(lvSta.z+1.,0.),endTail);\n            \n        \tstate.yz = radomHeartPos();\n            lvSta.z += 1.;\n        }\n        \n    }\n    \n    storeValue(tx_sta,state);\n    storeValue(tx_lvSta,lvSta);\n    storeValue(tx_nextOpt,nextOpt);\n    \n    fragColor = colData;\n}","name":"Buf A","description":"","type":"buffer"}]}