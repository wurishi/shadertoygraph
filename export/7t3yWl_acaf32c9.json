{"ver":"0.1","info":{"id":"7t3yWl","date":"1660776637","viewed":166,"name":"RayTracing CSG 2","username":"kastorp","description":"Another experiment: a sphere with 21 subtractions.\nHere [url=https://www.shadertoy.com/view/7lKcz1]path tracing[/url] version\nNOTE: poor performances with openGL","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","csg"],"hasliked":0,"parentid":"NdtSWj","parentname":"Raytracing CSG"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raytracing CSG 2  by Kastorp\n//------------------------------\n//another experiment: a sphere with 21 subtractions\n//Artifacts are  due to limiting the number of intervals MAXN to 4\n//NOTE: poor performances with openGL\nShape gear(vec3 rd,vec3 ro ,float n,float v) {\n    float tk=.2,sz=tk*n*1.65;\n    Shape s= getShape(iSphere(ro,rd,sz));\n    s= Inter(s,getShape(iBox(ro,rd,vec3(sz,sz,.12))));\n    s= Sub(s,getShape(iSphere(ro,rd,sz-tk*2.)));\n    Shape s2; \n    for(int i=ZERO;i<int(n);i++){\n        float  an=3.14/n*float(i)+iTime/n*v;\n        vec3  ax=vec3(0,0,1),\n              rro= erot(ro,  ax, an),\n              rrd= erot(rd,  ax, an);\n        s2= getShape(iBox(rro,rrd,vec3(sz+tk,tk,sz+tk)));\n        erot(s2,ax,-an);        \n        s= Sub(s,s2);  \n        \n    }\n    s2= getShape(iSphere(ro,rd,sz-tk));\n    s2= Sub(s2,getShape(iSphere(ro,rd,sz-3.*tk)));\n    s2= Inter(s2,getShape(iBox(ro,rd,vec3(sz,sz,.1))));\n    s= Sub(s2,s);\n    return s;\n}\nHit trace(vec3 rd,vec3 ro ) { \n    \n    Shape s= getShape(iPlane(ro,rd,vec3(0,1.,0),0.));\n    Hit r =  Ray(s,4.);\n\n#if 1\n    s= getShape(iSphere(ro-vec3(0.,2.,0.),rd,2.));\n    Shape s2;  \n    \n    for(int i=ZERO;i<21;i++){\n        float tk=.1*(1.1-sin(iTime)), h=-1.65 + .55 *float(i%7);\n        vec3 sz= i>=14?vec3(3.,3.,tk) : i>=7? vec3(tk,3.,3.):vec3(3.,tk,3.);\n        vec3 pos = i>=14? vec3(0,2.,h): i>=7? vec3(h,2.,0.):vec3(0.,2.+h,0.);\n        s2= getShape(iBox(ro-pos,rd,sz));\n        s= Sub(s,s2);    \n    }\n   Add(r,Ray(s,3.)); \n#else\n    for(int i=ZERO;i<2;i++){\n        vec3 pos= (i==0) ? vec3(0,2.,0):vec3(2.06,3.2,0);\n        float n = (i==0)?5.:4.;\n        float dir = (i==0)?1.:-1.;        \n        Add(r,Ray(gear(rd,ro-pos,n,dir),3.));       \n    }\n#endif\n    return r;\n}\n\n\n//------------------------------------\n\nvec3 lights(vec3 p, vec3 rd, float d, vec3 n) {\n    vec3 lightDir = normalize( vec3(8.,19.,18.) );\n\tvec3 ld = normalize(lightDir*16.5 - p);\n\n\tfloat ao = 1.,\n\tl1 = max(0., .2 + .9 * dot(ld, n)),\n\t\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n   \n    vec3 pp=p+.002*n; \n    Hit h= trace( ld, pp);\n\tl1 *=  .4+.6*  step(10.,h.d  );\n         \n\tvec3 lig = ((l1 *.9+.1)* ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0, 1, 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n    vec2 m= iMouse.x>0.? +iMouse.xy/iResolution.xy:.5* vec2(iResolution.xy/iResolution.y) +vec2(iTime*.2,-.2);\n    float t= -.6+m.x*3.14;\n\tvec3 ro =1.6*vec3(3.*cos(t), 1.+6.*m.y, 3.*sin(t));\n\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n    vec3 rd =  getRayDir(ro, vec3(0,2,0), uv);\n        \n    Hit h= trace(rd, ro);\n      \n    vec3 p=ro+rd*h.d;\n    vec3[4] mat = vec3[4](vec3(0.2,0.4,0.1), //terrain\n                     vec3(0.9,0.4,0.4), // pink\n                      vec3(0.2,0.3,0.6), //blue\n                      vec3(1,.8,.8)); // white\n\n    vec3 alb=mat[int(h.id)-1];\n            \n    vec3 col=lights(p, rd, h.d,h.n) * exp(-h.d * .085)*alb;\n    \n\tfragColor = vec4(pow(col, vec3(.5)), h.d);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define MAXN 4 //maximum number of intervals 1-6\n\n//----------------------\n#define NOHIT 1e5\n#define ZERO min(iFrame, 0)\n#define time iTime*2.\n\n//structs:\n// Its= ray intersection distance + normal \n// Span = interval between entry point and exit point on convex shape\n// Shape= ordered array of spans on a CSG shape\nstruct Its\n{\n\tfloat t;\n\tuint n;    //normal \n\t\n};\n\nconst Its  NO_its=Its(NOHIT,0u);\nstruct Span\n{\n\tIts n;\n\tIts f;\n\tbool merged;\n};\n\nstruct Shape\n{\n\tint l; \n\tSpan[MAXN] s;\n};\n\n\nvoid init(inout Shape y){\n\ty.l=0;\n}\n\nIts getIx(inout Shape y){\n\n    float tMin=1e5;\n    int idm=-1;\n    for(int i=0;i<y.l;i++) if(y.s[i].n.t<tMin && y.s[i].f.t>0.001 ) {idm=i;tMin=y.s[i].n.t;}\n    if(idm>=0) {  return y.s[idm].n;}\n    return NO_its;\n}\n\nvoid add(inout Shape y,  Span x){\n\n\n    if(y.l>=MAXN) return;\n    int id=y.l++; \n\n\tif(id==0) y.s[0]=x;\n#if (MAXN>1)      \n    else if(id==1) y.s[1]=x;\n#endif\n#if (MAXN>2)   \n    else if(id==2) y.s[2]=x;\n#endif\n#if (MAXN>3)    \n    else if(id==3) y.s[3]=x;\n#endif \n#if (MAXN>4)  \n    else if(id==4) y.s[4]=x;\n#endif\n#if (MAXN>5)  \n    else if(id==5) y.s[5]=x;\n#endif\n#if (MAXN>6)  \n    else if(id==6) y.s[6]=x;\n#endif\n\n\n}\n\nbool seq(inout Its a1, inout Its a2, inout Its a3,inout Its a4)\n{\n    return a1.t<a2.t && a2.t<a3.t && a3.t<a4.t;\n}\nbool seq(inout Its a1,inout Its a2)\n{\n    return a1.t<a2.t ;\n}\nShape getShape( Span x){\n    Shape s;s.l=0;  add(s,x);\n    return s;\n}\n\n\nbool no_hit(Span x) {return x.n.t==NOHIT || x.f.t<0.;;}\n//-------------------------------\n//UNION A+B:\nvoid addMerge(inout Shape cs,  Span y,bool reduce){\n    if(reduce){\n        if(y.merged) return;\n        for(int j=0;j<cs.l;j++)\n        {           \n            Span x=cs.s[j];\n            if(x.merged) continue;\n            else if(seq(x.f,y.n)|| seq(y.f,x.n )) continue;\n            else if(seq(x.n,y.n,x.f,y.f)) {cs.s[j].merged=true; y=Span(x.n,y.f,false);}\n            else if(seq(y.n,x.n,y.f,x.f)) {cs.s[j].merged=true; y=Span(y.n,x.f,false);}\n            else if(seq(x.n,y.n,y.f,x.f)) {cs.s[j].merged=true; y=Span(x.n,x.f,false);}\n            else if(seq(y.n,x.n,x.f,y.f)) {cs.s[j].merged=true; y=Span(y.n,y.f,false); }\n        }\n    }\n    add(cs,y);    \n}\n\nShape Union(Shape as, Shape bs,bool reduce){   \n    Shape cs;\n    init(cs);\n    for(int i=0;i<as.l;i++) addMerge(cs,as.s[i],reduce);\n    for(int i=0;i<bs.l;i++) addMerge(cs,bs.s[i],reduce);\n\n    if(!reduce) return cs;    \n    //ds=REDUCE(cs)\n    Shape ds;\n    init(ds);\n    for(int i=0;i<cs.l;i++) if(!cs.s[i].merged) add(ds,cs.s[i]);\n    return ds;\n}\n\n \n\n//-------------------------------\n//INTERSECTION A*B:\nShape Inter(Shape as, Shape bs){ \n    Shape cs;\n    init(cs);\n    for(int i=0;i<as.l;i++) {\n        Span a=as.s[i];\n        if(no_hit(a)) continue;\n        for(int j=0;j<bs.l;j++) {\n            Span b=bs.s[j];\n            if(no_hit(b)) continue;\n            else if(seq( a.f,b.n)|| seq(b.f,a.n )) continue;\n            else if(seq(a.n,b.n,a.f,b.f)) add(cs,Span(b.n,a.f,false));\n            else if(seq(b.n,a.n,b.f,a.f)) add(cs,Span(a.n,b.f,false));\n            else if(seq(a.n,b.n,b.f,a.f)) add(cs,b);\n            else if(seq(b.n,a.n,a.f,b.f)) add(cs,a);\t\t\n        }\n    }\n    return cs;\n}\n//-----------------------------\n//SUBTRACTION A-B:\nShape Sub(Shape as, Span b){\n    Shape cs;\n    init(cs);\n     for(int j=0;j<as.l;j++) {\n        Span a=as.s[j];\n        if(no_hit(a)) continue;\n        if(seq( a.f,b.n)) add(cs,a);\n        else if(seq(b.f,a.n )) add(cs,a);\n        else if(seq(a.n,b.n,a.f,b.f)) add(cs,Span(a.n,b.n,false)); \n        else if(seq(b.n,a.n,b.f,a.f)) add(cs,Span(b.f,a.f,false)); \n        else if(seq(a.n,b.n,b.f,a.f)) {add(cs,Span(a.n,b.n,false)); add(cs,Span(b.f,a.f,false)); }\n        else if(seq(b.n,a.n,a.f,b.f)) continue;\t\n    }\n    return cs;\n}\n\nShape Sub(Shape as, Shape bs){ \n    for(int i=0;i<bs.l;i++) {\n        Span b=bs.s[i];        \n        if(!no_hit(b)) as=Sub( as,  b);        \n    }\n    return as;\n}\n\n//----------------------------\n\n\n//IQ normal compression https://www.shadertoy.com/view/llfcRl\nuint direct_32( in vec3 nor )\n{\n    nor /= max(max(abs(nor.x),abs(nor.y)),abs(nor.z));\n\n    vec3 v = 0.5 + 0.5*nor;\n    uvec3 d = uvec3(round(v*vec3(2047.0,1023.0,2047.0)));\n    return d.x|(d.y<<11u)|(d.z<<21u);\n}\n\nvec3 i_direct_32( uint data )\n{\n    uvec3 d = uvec3( data, data>>11, data>>21 ) & uvec3(2047u,1023u,2047u);\n    vec3 v = vec3(d)*2.0/vec3(2047.0,1023.0,2047.0) - 1.0;\n    return normalize(v);\n}\n//-----------Intersection primitives--------------------\nSpan iSphere( in vec3 ro, in vec3 rd, float ra )\n{\n\n    vec3 oc = ro ;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0. ) return Span(NO_its,NO_its,true); // no intersection\n    h = sqrt( h );\n    vec3 oNor =normalize(ro-(b+h)*rd); \n    vec3 fNor= normalize(ro-(b-h)*rd); \n    if( h-b < 0. ) return  Span(NO_its,NO_its,true);\n    return Span(Its(-b-h,direct_32(oNor)) , Its(-b+h,direct_32(-fNor)),false);\n}\n\nSpan iBox( in vec3 ro, in vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1./rd; \n    vec3 n = m*ro;   \n    vec3 k = abs(m)*boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.) return Span(NO_its,NO_its,true); // no intersection\n    vec3 oNor = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz); \n     vec3  fNor=- sign(rd)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy); \n    return  Span(Its(tN,direct_32(oNor)) , Its(tF,direct_32(fNor)),false);\n}\n\nSpan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d= -(dot(ro,n)+h)/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oFuv=vec3(1.,dot(ro+d*rd,u), dot(ro+d*rd,v));\n    vec3 oNor=n;\n    if(d<0.)  return Span(NO_its,NO_its,true);\n    return Span(Its(d,direct_32(oNor)),NO_its,false);\n}\n/*\nSpan iCylinder( in vec3 ro, in vec3 rd,  in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, \n{\n    Span no_hit =  Span(NO_its,NO_its,true);;\n\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 )  return no_hit;\n    h = sqrt(h);\n    \n    float t = (-k1-h)/k2;\n    float y = baoc + t*bard; \n    float t2 = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;   \n    \n    if( (y<0.0 || y>baba )  && abs(k1+k2*t2)>h)  return no_hit;\n    Its iN,iF;\n    vec3 w = normalize(ba), u = normalize(cross(ba,vec3(0,0,1))), v = normalize(cross(u,w) );\n    \n    //entry point\n    vec3 q = (oc+t*rd-ba)*mat3(u,v,w);   \n    if( y>0.0 && y<baba ) iN= Its( t, direct_32((oc+t*rd - ba*y/baba)/ra) ); \n    else iN= Its(t2, direct_32(ba*sign(y)/baba )); \n        \n  \n    //exit point\n    t = (-k1+ h)/k2;\n    y = baoc + t*bard; \n    t2 = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    q = (oc+t*rd-ba)*mat3(u,v,w); \n    if( y>0.0 && y<baba ) iF= Its( t, direct_32((oc+t*rd - ba*y/baba)/ra) ); \n    else iF= Its(t2, direct_32(ba*sign(y)/baba) ); \n    \n    return Span(iN , iF ,false);\n  \n}*/\n\n//---------mixed functions--------------------------\nstruct RayIn{\n    vec3 rd; \n};\n\nstruct Hit{   \n    float d;\n    vec3 n;\n    float id;\n};\n\n\nHit FastUnion( Hit a, Hit b)\n{\n   if(a.d<b.d) return a;\n   else return b;\n}\n#define Add(_ro,_func) _ro = FastUnion(_ro,_func);\n\n//unused here\n#define  RotGroup( _p, _ri,_ro, _ax,  _c ,  _a,  _body) \\\n     vec3 _rd= _ri.rd; \\\n    _p=erot( _p , _ax, _a); \\\n    _ri.rd=  normalize(erot( _ri.rd , _ax, _a)); \\\n    _body \\\n    _ro.n=  normalize(erot( _ro.n , _ax, -_a)); \\\n\n\n//------------------------------------\nHit Ray(Shape s,float mat){\n    \n    Its ix = getIx(s);\n    return Hit( ix.t,i_direct_32(ix.n),mat);\n}\nuint erot(uint n, vec3 ax, float ro) {\n    vec3 p= i_direct_32(n) ;\n    return direct_32(mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p));\n}\nvec3 erot(vec3 p, vec3 ax, float ro) {\n\n    return (mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p));\n}\n\nvoid erot(inout Shape s,vec3 ax, float an){\n    for(int i=0;i <s.l;i++){\n        s.s[i].n.n=erot(s.s[i].n.n, ax, an);\n        s.s[i].f.n=erot(s.s[i].f.n, ax, an);\n    }   \n}","name":"Common","description":"","type":"common"}]}