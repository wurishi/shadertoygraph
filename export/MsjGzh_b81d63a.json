{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Adapted from http://strlen.com/gfxengine/fisheyequake/\nvec2 fisheye_lookup(float fov, vec2 position)\n{\n\tvec2 d = position - 0.5;\n\t\n\tfloat yaw = sqrt(d.x*d.x+d.y*d.y) * fov;\n\n\tfloat roll = -atan(d.y, d.x);\n\tfloat sx = sin(yaw) * cos(roll);\n\tfloat sy = sin(yaw) * sin(roll);\n\tfloat sz = cos(yaw);\t\n\n\treturn vec2(sx, sy);\n}\t\t\t\n\n\n// lens\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    float lensSize = 2.0;\n\tfloat scale = 1.0;\n\n    vec2 d = p - m;\n    float r = scale * sqrt(dot(d, d)); // distance of pixel from mouse\n\tfloat rThresh = 0.3;\n\n\tvec2 pos = d;\n\tfloat apertureHalf = 0.5 * 90.0 * (3.14159 / 180.0);\n\tfloat maxFactor = sin(apertureHalf);\n\t\n    vec2 uv;\n\n\tfloat avgD = (iResolution.x + iResolution.y)/2.0;\n\tvec2 fMinMouse = fragCoord.xy/avgD - iMouse.xy/iResolution.xy;\n\tfloat r2 = scale * sqrt(dot(fMinMouse,fMinMouse)); // distance of pixel from mouse\n\t\n    if (r2 >= lensSize) {\n        fragColor = vec4(0,0,0, 1.0);\t\n    } \n\telse {\n        // Thanks to Paul Bourke for these formulas; see\n        // http://paulbourke.net/miscellaneous/lenscorrection/\n        // and .../lenscorrection/lens.c\n        // Choose one formula to uncomment:\n        // SQUAREXY:\n        // uv = m + vec2(d.x * abs(d.x), d.y * abs(d.y));\n        // SQUARER:\n        // uv = m + d * r; // a.k.a. m + normalize(d) * r * r\n        // SINER:\n        // uv = m + normalize(d) * sin(r * 3.14159 * 0.5);\n\t\t// TANR\n        // uv = m + normalize(d) * tan(r * 3.14159 * 0.5);\n        // ASINR:\n        // uv = m + normalize(d) * asin(r) / (3.14159 * 0.5);\n        // ATANR:\n        // uv = m + normalize(d) * atan(r) / (3.14159 * 0.5);\n\n\t\t/*\n\t\tfloat x = d.x;\n\t\tfloat y = d.y;\n\t\tfloat n = length(d);\n\t\tfloat z = sqrt(1.0 - n*n);\n\t\tfloat rNew = atan(n,z) / (3.14159*0.5);\n\t\tfloat phi = atan(y,x);\n\t\tuv.x = m.x + rNew * cos(phi);\n\t\tuv.y = m.y + rNew * sin(phi);\n\t\t*/\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t// transition from inverse to full fisheye\n\t\tvec2 p2 = fragCoord.xy / iResolution.x;//normalized coords with some cheat\n                                                        //(assume 1:1 prop)\n\t\tfloat prop = iResolution.x / iResolution.y;\n\t\tvec2 m2 = vec2(0.5, 0.5 / prop);//center coords\n\t\t// vec2 m2 = vec2(m.x, 0.5 / prop);//center coords\n\t\tvec2 d2 = p2 - m2;//vector from center to current fragment\n\t\tfloat r2 = sqrt(dot(d2, d2)); // distance of pixel from center\n\n\t\tfloat power = ( 2.0 * 3.141592 / (2.0 * sqrt(dot(m2, m2))) ) *\n\t\t\t\t(m.x - 0.5);//amount of effect\n\n\t\tfloat bind;//radius of 1:1 effect\n\t\tif (power > 0.0) bind = sqrt(dot(m2, m2));//stick to corners\n\t\telse {if (prop < 1.0) bind = m2.x; else bind = m2.y;}//stick to borders\n\n\t\t// eqn https://www.shadertoy.com/view/4s2GRR\n\t\tif (power > 0.0)//fisheye\n\t\t\tuv = m2 + normalize(d2) * tan(r2 * power) * bind / tan( bind * power);\n\t\telse if (power < 0.0)//antifisheye\n\t\t\tuv = m2 + normalize(d2) * atan(r2 * -power * 10.0) * bind / atan(-power * bind * 10.0);\n\t\telse uv = p;//no effect for power = 1.0\n\t\t\n\t\tvec3 col = texture(iChannel0, vec2(uv.x, -uv.y * prop)).xyz;//Second part of cheat\n\t    //for round effect, not elliptical\n\t\tfragColor = vec4(col, 1.0);\n\t\t\n\t\t\n\t\t// exp\n        // uv = m + normalize(d) * exp(r * 3.14159 * 0.5);\n\n\t\t\t\n        // uv = m + normalize(d);\n\t\t\n/*    \tfloat x = maxFactor * pos.x;\n    \tfloat y = maxFactor * pos.y;\n    \tfloat n = length(vec2(x, y));\n        float z = sqrt(1.0 - n * n);\n  \t    float r = atan(n, z) / 3.14159; \n\t   \tfloat phi = atan(y, x);\n    \tfloat u = m.x + r * cos(phi) + 0.5;\n    \tfloat v = m.y + r * sin(phi) + 0.5;\n\n    \tfragColor = vec4( texture(iChannel0, vec2(u, -v)).xyz, 1.0);\n*/\n\t\t\n/*\n\t\t// standard\t\n\t\tfloat theta = atan(d.y,d.x);\n\t\tuv.x = m.x + scale * r * cos(theta);\n\t\tuv.y = m.y + scale * r * sin(theta);\n\t\tif (r > rThresh) {\n\t\t\tfloat delta = r - rThresh;\n\t\t\tvec2 uv2 = m + normalize(d) * tan(r * 3.14159 * 0.5);\n\t\t\tuv.x = uv.x * (1.0 - delta) + delta * uv2.x;\n\t\t\tuv.y = uv.y * (1.0 - delta) + delta * uv2.y;\n\t\t}\n*/\n\t\t\n\t\t// vec3 col = texture(iChannel0, vec2(uv.x,-uv.y) ).xyz;\t\n\t\t\n\t\t// vec2 p2 = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\t\t\n\t\t// float a = atan(d.y,d.x);\n\t\t// uv.x = 0.07/r;\n\t\t// uv.y = a/(3.14159);\t\t\n\t\t// vec3 col = texture(iChannel0, vec2(uv.x,-uv.y) ).xyz;\n\t\t\n    \t// fragColor = vec4(col, 1.0);\n\t\n\t}\n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsjGzh","date":"1383919381","viewed":2590,"name":"fisheye","username":"victusfate","description":"thanks to http://stackoverflow.com/users/423105/larsh and http://paulbourke.net/miscellaneous/lenscorrection/\noh and now\nhttps://www.shadertoy.com/view/4s2GRR","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["2d","fisheye"],"hasliked":0,"parentid":"","parentname":""}}