{"ver":"0.1","info":{"id":"XddGDN","date":"1449732924","viewed":222,"name":"783 /~/ Squlorp","username":"MrHenryBemis","description":"783 , o , j , l ,. r .","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["warping","field","flesh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// See here for a tutorial on how to make this: https://iquilezles.org/articles/warp\n#define iTime iTime*7.783\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 x )\n{\n\treturn cos(1.5*x.x)*sin(1.5*x.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5783*noise( p ); p = m*p*2.02;\n    f += 0.2783*noise( p ); p = m*p*2.03;\n    f += 0.1783*noise( p ); p = m*p*2.01;\n    f += 0.0783*noise( p );\n    return f/0.93783;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500783*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250783*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125783*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062783*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031783*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015783*(0.5+0.5*noise( p ));\n    return f/0.96783877835;\n}\n\n\nfloat func( vec2 q, out vec4 ron )\n{\n    float ql = length( q );\n    q.x += 0.0783*sin(0.27*iTime+ql*4.1);\n    q.y += 0.0783*sin(0.23*iTime+ql*4.3);\n    q *= 0.783;\n\n\tvec2 o = vec2(0.0);\n    o.x = 0.783 + 0.783*fbm4( vec2(2.0*q          )  );\n    o.y = 0.783 + 0.783*fbm4( vec2(2.0*q+vec2(5.2))  );\n\n\tfloat ol = length( o );\n    o.x += 0.02783*sin(0.12783*iTime+ol)/ol;\n    o.y += 0.02783*sin(0.14783*iTime+ol)/ol;\n\n    vec2 n;\n    n.x = fbm6( vec2(4.783*o+vec2(9.783))  );\n    n.y = fbm6( vec2(4.783*o+vec2(5.783))  );\n\n    vec2 p = 4.0*q + 4.0*n;\n\n    float f = 0.5 + 0.5*fbm4( p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    float g = 0.5 + 0.5*sin(4.0*p.x)*cos(4.0*p.y);\n    f *= 1.0-0.5*pow( g, 9.0 );\n\n\tron = vec4( o, n );\n\t\n    return f;\n}\n\n\n\nvec3 doMagic(vec2 p)\n{\n\tvec2 q = p*1.6;\n\n    vec4 on = vec4(0.5);\n    float f = func(q, on);\n\n\tvec3 col = vec3(0.0);\n    col = mix( vec3(0.2,0.1,0.4), vec3(0.3,0.05,0.05), f );\n    col = mix( col, vec3(0.4,0.9,0.7), dot(on.zw,on.zw) );\n    col = mix( col, vec3(0.2,0.5,0.3), 0.5*on.y*on.y );\n    col = mix( col, vec3(0.8,0.8,0.6), 0.5*smoothstep(1.2,1.3,abs(on.z)+abs(on.w)) );\n    col = clamp( col*f*2.0, 0.0, 1.0 );\n    \n\tvec3 nor = normalize( vec3( dFdx(f)*iResolution.x, 6.0, dFdy(f)*iResolution.y ) );\n\n    vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n    vec3 bdrf;\n    bdrf  = vec3(0.70,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.05)*dif;\n    col *= 1.2*bdrf;\n\tcol = 1.0-col;\n\treturn 1.1*col*col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n\n    fragColor = vec4( doMagic( p ), 1.0 );\n}\n","name":"","description":"","type":"image"}]}