{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 lightPos = vec2(\n\t\t(1.2 + sin(iTime)) * 0.4 * iResolution.x,\n\t\t(1.2 + cos(iTime)) * 0.4 * iResolution.y\n\t);\n\t\n\t// Uncomment this line to control with the mouse.\n\t//lightPos = iMouse.xy;\n\t\n\tfloat bumpStrength = 16.0;\n\tfloat bumpRadius1 = 0.1; // anything closer than this to the light has no bump effect\n\tfloat bumpRadius2 = 0.25; // anything beyond this has full bump effect\n\tfloat lightStrength = 1.6;\n\tfloat lightRadius = 0.7;\n\tfloat refDist = 1.2 * iResolution.x / 500.0;\n\t\t\n\t\n\tvec2 vecToLight = fragCoord.xy - lightPos;\n\tfloat distToLight = length(vecToLight.xy / iResolution.xy);\n\tvec2 dirToLight = normalize(vecToLight);\n\tvec2 curPos = fragCoord.xy / iResolution.xy;\n\tvec2 refPos = curPos.xy - (refDist * dirToLight.xy / iResolution.xy);\n\t\n\tvec4 curSample = texture(iChannel0, curPos);\n\tvec4 refSample = texture(iChannel0, refPos);\n\t\n\tfloat curLumin = (curSample.x + curSample.y + curSample.z) * 0.33;\n\tfloat refLumin = (refSample.x + refSample.y + refSample.z) * 0.33;\n\t\n\t// Attenaute brightness based on how much this fragment seems to face the light\n\tfloat directionBrightness =\n\t\tlightStrength - // start at maximum brightness\n\t\t(\n\t\t\tstep(bumpRadius1, distToLight) * // leave a bump-free area round the light\n\t\t\tclamp((distToLight - bumpRadius1) / (bumpRadius2 - bumpRadius1), 0.0, 1.0) *\n\t\t\tstep(curLumin, refLumin) * // only attenuate if facing away from light source\n\t\t\tclamp((refLumin - curLumin) * bumpStrength, 0.0, 1.0)\n\t\t);\n\t\n\t// Attenuate brightness based on distance from the light\n\tfloat distanceBrightness = 1.0 - (distToLight / lightRadius);\n\t\n\tfragColor.xyz = directionBrightness * distanceBrightness * curSample.xyz;\n\tfragColor.w = curSample.w;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdl3WH","date":"1372437751","viewed":1901,"name":"Really basic bump mapping","username":"ElusivePete","description":"This is a very simple approach to texture-based bump mapping. For any given fragment, it uses the relative brightness of a fragment closer to the light source to determine surface angle at that point.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["lighting","bump"],"hasliked":0,"parentid":"","parentname":""}}