{"ver":"0.1","info":{"id":"43SfDD","date":"1729449128","viewed":55,"name":"AO teste","username":"Elsio","description":"estou percebendo que o algoritmo de oclusão é muito importante na coloração (iluminação e sombreamento) de multiplos objetos ou objetos formados por multiplas partes. Mas... como todo iniciante nessa área, eu não entendo muito da matemática envolvida :D","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["wobble","deformation","rubber","icosahedron","spherical","polyhedron","jiggle","rubbery"],"hasliked":0,"parentid":"lXjcDt","parentname":"Pet Ball"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// shaders lindos ♥ https://www.shadertoy.com/playlist/cXBGzV\n#define rot(a) mat2(cos(a + pi * vec4(0, .5, 1.5, 0)))\n#define pi acos(-1.)\n#define TAU (pi * 2.)\n#define FAR 20.\n#define latblock 1.1071488\n#define t iTime\n\n#define esf2cart(x, y) vec3(cos(x) * sin(y), cos(y), sin(x) * sin(y)) / 2.\n#define h33(a) fract(29. * sin(a + a) * sin(a).zxy)\n\nvec4 cor;\n\n#define op(a, b) (a.y < b.y ? a : b)\n#define cmp(i, a, b) id = op(id, vec2(i, length(p - esf2cart(a, b))))\n\nint closestFace(vec3 p, vec4 dd){\n    vec2 id = vec2(1e5);\n    vec2 lat = vec2(.65235823, 1.3820858);\n    \n    cmp(3, dd[2], pi - lat[1]);\n    \n    if(p.y < 0.){\n        cmp(1, dd[1], lat[1]);\n        cmp(2, dd[2], pi - lat[0]);\n    }\n    \n    else{\n        cmp(0, dd[0], lat[0]);\n        cmp(1, dd[1], lat[1]);\n    }\n    \n    return int(id.x);\n}\n\n\nbool defcor;\n\nfloat Tubes(vec3 p, int id, vec4 dd){\n    float flip = id == 0 || id == 3 ? 1. : -1.;\n    \n    vec4 A = vec4(0, pi-latblock, pi, latblock);\n    vec4 B = A.wwyy;\n    \n    vec3 ax = dd[id] + vec3(0, -pi, pi) * flip / 5.;\n    vec3 V = esf2cart(ax.x, A[id]) \n             + esf2cart(ax.y, B[id])\n             + esf2cart(ax.z, B[id]);\n                 \n    if(!defcor)\n        cor = vec4(h33(V), 0);\n        \n    vec3 b = normalize(V) * .5;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return length(p - b * h) - .05;\n}\n\n\nfloat icosa(vec3 p) {\n    vec4 dd;\n    \n    dd = vec4(0, 0, 1, 1) / 2.;\n    dd += atan(p.z, p.x) * 5. / TAU;\n    dd = floor(dd) + vec4(1, 1, 0, 0) / 2.;\n    dd *= TAU / 5.;\n               \n    int id = closestFace(p, dd);\n    float face = length(p) - .2;\n    float tubes = Tubes(p, id, dd);\n    \n    return min(face, tubes);\n}\n\n\nvoid rotObj(inout vec3 p) {\n    p.yz *= rot(t / 3.);\n    p.xz *= rot(t / 2.);\n    \n    // wobble deformation\n    p.xy *= rot(cos(t * .5) * .15\n              * dot(vec2(cos(t * 13.), sin(t * 12.)), p.yx));    \n}\n\n\nfloat map(vec3 p) { \n    rotObj(p);\n    return icosa(p);\n}\n\n\nfloat march(vec3 ro, vec3 rd) {\n    float s, i, d;\n    while(i++ < 48.) {\n        s = map(ro + d * rd);\n        if(s < .01 || d > FAR) break;\n        d += s * .9;\n    }\n    \n    return min(d, FAR);\n}\n\nvec3 normal(vec3 p) {\n    vec3 e = vec3(.001, 0, 0),\n         v = vec3(\n                 map(p + e.xyy), \n                 map(p + e.yxy),  \n                 map(p + e.yyx)\n             ) - map(p);\n    return normalize(v);\n}\n\nfloat AO(vec3 p, vec3 n) {\n    float i, sca = 2., occ;\n    \n    while(i++ < 6.) {\n        occ += (i * .04 - map(p + n * (i * .03 + .03))) * sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n         u = (u - r / 2.) / r.y;\n    \n    vec3 p = vec3(0, 0, -5),\n         D = normalize(vec3(u, 5));\n    \n    float d = march(p, D);\n\n    o = vec4(-D.y * 6.);\n    \n    if(d < FAR){\n        defcor = true;\n        vec3 p = p + d * D,\n             n = normal(p);\n             \n        float ao = AO(p, n);\n        \n        o = ao * length(sin(n * .25) * .35 + .35) * cor;\n    }\n}","name":"Image","description":"","type":"image"}]}