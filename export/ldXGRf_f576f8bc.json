{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// This is a port of the NTSC encode/decode shader pair in MAME and MESS, modified to use only\n// one pass rather than an encode pass and a decode pass. It accurately emulates the sort of\n// signal decimation one would see when viewing a composite signal, though it could benefit from a\n// pre-pass to re-size the input content to more accurately reflect the actual size that would\n// be incoming from a composite signal source.\n//\n// To encode the composite signal, I convert the RGB value to YIQ, then subsequently evaluate\n// the standard NTSC composite equation. Four composite samples per RGB pixel are generated from\n// the incoming linearly-interpolated texels.\n//\n// The decode pass implements a Fixed Impulse Response (FIR) filter designed by MAME/MESS contributor\n// \"austere\" in matlab (if memory serves correctly) to mimic the behavior of a standard television set\n// as closely as possible. The filter window is 83 composite samples wide, and there is an additional\n// notch filter pass on the luminance (Y) values in order to strip the color signal from the luminance\n// signal prior to processing.\n//\n// - UltraMoogleMan [8/2/2013]\n\n// Useful Constants\nconst vec4 Zero = vec4(0.0);\nconst vec4 Half = vec4(0.5);\nconst vec4 One = vec4(1.0);\nconst vec4 Two = vec4(2.0);\nconst float Pi = 3.1415926535;\nconst float Pi2 = 6.283185307;\n\n// NTSC Constants\nconst vec4 A = vec4(0.5);\nconst vec4 B = vec4(0.5);\nconst float P = 1.0;\nconst float CCFrequency = 3.59754545;\nconst float YFrequency = 6.0;\nconst float IFrequency = 1.2;\nconst float QFrequency = 0.6;\nconst float NotchHalfWidth = 2.0;\nconst float ScanTime = 52.6;\nconst float MaxC = 2.1183;\nconst vec4 MinC = vec4(-1.1183);\nconst vec4 CRange = vec4(3.2366);\n\nvec4 CompositeSample(vec2 UV) {\n\tvec2 InverseRes = 1.0 / iResolution.xy;\n\tvec2 InverseP = vec2(P, 0.0) * InverseRes;\n\t\n\t// UVs for four linearly-interpolated samples spaced 0.25 texels apart\n\tvec2 C0 = UV;\n\tvec2 C1 = UV + InverseP * 0.25;\n\tvec2 C2 = UV + InverseP * 0.50;\n\tvec2 C3 = UV + InverseP * 0.75;\n\tvec4 Cx = vec4(C0.x, C1.x, C2.x, C3.x);\n\tvec4 Cy = vec4(C0.y, C1.y, C2.y, C3.y);\n\n\tvec3 Texel0 = texture(iChannel0, C0).rgb;\n\tvec3 Texel1 = texture(iChannel0, C1).rgb;\n\tvec3 Texel2 = texture(iChannel0, C2).rgb;\n\tvec3 Texel3 = texture(iChannel0, C3).rgb;\n\t\n\t// Calculated the expected time of the sample.\n\tvec4 T = A * Cy * vec4(iResolution.x) * Two + B + Cx;\n\n\tconst vec3 YTransform = vec3(0.299, 0.587, 0.114);\n\tconst vec3 ITransform = vec3(0.595716, -0.274453, -0.321263);\n\tconst vec3 QTransform = vec3(0.211456, -0.522591, 0.311135);\n\n\tfloat Y0 = dot(Texel0, YTransform);\n\tfloat Y1 = dot(Texel1, YTransform);\n\tfloat Y2 = dot(Texel2, YTransform);\n\tfloat Y3 = dot(Texel3, YTransform);\n\tvec4 Y = vec4(Y0, Y1, Y2, Y3);\n\n\tfloat I0 = dot(Texel0, ITransform);\n\tfloat I1 = dot(Texel1, ITransform);\n\tfloat I2 = dot(Texel2, ITransform);\n\tfloat I3 = dot(Texel3, ITransform);\n\tvec4 I = vec4(I0, I1, I2, I3);\n\n\tfloat Q0 = dot(Texel0, QTransform);\n\tfloat Q1 = dot(Texel1, QTransform);\n\tfloat Q2 = dot(Texel2, QTransform);\n\tfloat Q3 = dot(Texel3, QTransform);\n\tvec4 Q = vec4(Q0, Q1, Q2, Q3);\n\n\tvec4 W = vec4(Pi2 * CCFrequency * ScanTime);\n\tvec4 Encoded = Y + I * cos(T * W) + Q * sin(T * W);\n\treturn (Encoded - MinC) / CRange;\n}\n\nvec4 NTSCCodec(vec2 UV)\n{\n\tvec2 InverseRes = 1.0 / iResolution.xy;\n\tvec4 YAccum = Zero;\n\tvec4 IAccum = Zero;\n\tvec4 QAccum = Zero;\n\tfloat QuadXSize = iResolution.x * 4.0;\n\tfloat TimePerSample = ScanTime / QuadXSize;\n\t\n\t// Frequency cutoffs for the individual portions of the signal that we extract.\n\t// Y1 and Y2 are the positive and negative frequency limits of the notch filter on Y.\n\t// \n\tfloat Fc_y1 = (CCFrequency - NotchHalfWidth) * TimePerSample;\n\tfloat Fc_y2 = (CCFrequency + NotchHalfWidth) * TimePerSample;\n\tfloat Fc_y3 = YFrequency * TimePerSample;\n\tfloat Fc_i = IFrequency * TimePerSample;\n\tfloat Fc_q = QFrequency * TimePerSample;\n\tfloat Pi2Length = Pi2 / 82.0;\n\tvec4 NotchOffset = vec4(0.0, 1.0, 2.0, 3.0);\n\tvec4 W = vec4(Pi2 * CCFrequency * ScanTime);\n\tfor(float n = -41.0; n < 42.0; n += 4.0)\n\t{\n\t\tvec4 n4 = n + NotchOffset;\n\t\tvec4 CoordX = UV.x + InverseRes.x * n4 * 0.25;\n\t\tvec4 CoordY = vec4(UV.y);\n\t\tvec2 TexCoord = vec2(CoordX.r, CoordY.r);\n\t\tvec4 C = CompositeSample(TexCoord) * CRange + MinC;\n\t\tvec4 WT = W * (CoordX  + A * CoordY * Two * iResolution.x + B);\n\n\t\tvec4 SincYIn1 = Pi2 * Fc_y1 * n4;\n\t\tvec4 SincYIn2 = Pi2 * Fc_y2 * n4;\n\t\tvec4 SincYIn3 = Pi2 * Fc_y3 * n4;\n\t\tbvec4 notEqual = notEqual(SincYIn1, Zero);\n\t\tvec4 SincY1 = sin(SincYIn1) / SincYIn1;\n\t\tvec4 SincY2 = sin(SincYIn2) / SincYIn2;\n\t\tvec4 SincY3 = sin(SincYIn3) / SincYIn3;\n\t\tif(SincYIn1.x == 0.0) SincY1.x = 1.0;\n\t\tif(SincYIn1.y == 0.0) SincY1.y = 1.0;\n\t\tif(SincYIn1.z == 0.0) SincY1.z = 1.0;\n\t\tif(SincYIn1.w == 0.0) SincY1.w = 1.0;\n\t\tif(SincYIn2.x == 0.0) SincY2.x = 1.0;\n\t\tif(SincYIn2.y == 0.0) SincY2.y = 1.0;\n\t\tif(SincYIn2.z == 0.0) SincY2.z = 1.0;\n\t\tif(SincYIn2.w == 0.0) SincY2.w = 1.0;\n\t\tif(SincYIn3.x == 0.0) SincY3.x = 1.0;\n\t\tif(SincYIn3.y == 0.0) SincY3.y = 1.0;\n\t\tif(SincYIn3.z == 0.0) SincY3.z = 1.0;\n\t\tif(SincYIn3.w == 0.0) SincY3.w = 1.0;\n\t\t//vec4 IdealY = (2.0 * Fc_y1 * SincY1 - 2.0 * Fc_y2 * SincY2) + 2.0 * Fc_y3 * SincY3;\n\t\tvec4 IdealY = (2.0 * Fc_y1 * SincY1 - 2.0 * Fc_y2 * SincY2) + 2.0 * Fc_y3 * SincY3;\n\t\tvec4 FilterY = (0.54 + 0.46 * cos(Pi2Length * n4)) * IdealY;\t\t\n\t\t\n\t\tvec4 SincIIn = Pi2 * Fc_i * n4;\n\t\tvec4 SincI = sin(SincIIn) / SincIIn;\n\t\tif (SincIIn.x == 0.0) SincI.x = 1.0;\n\t\tif (SincIIn.y == 0.0) SincI.y = 1.0;\n\t\tif (SincIIn.z == 0.0) SincI.z = 1.0;\n\t\tif (SincIIn.w == 0.0) SincI.w = 1.0;\n\t\tvec4 IdealI = 2.0 * Fc_i * SincI;\n\t\tvec4 FilterI = (0.54 + 0.46 * cos(Pi2Length * n4)) * IdealI;\n\t\t\n\t\tvec4 SincQIn = Pi2 * Fc_q * n4;\n\t\tvec4 SincQ = sin(SincQIn) / SincQIn;\n\t\tif (SincQIn.x == 0.0) SincQ.x = 1.0;\n\t\tif (SincQIn.y == 0.0) SincQ.y = 1.0;\n\t\tif (SincQIn.z == 0.0) SincQ.z = 1.0;\n\t\tif (SincQIn.w == 0.0) SincQ.w = 1.0;\n\t\tvec4 IdealQ = 2.0 * Fc_q * SincQ;\n\t\tvec4 FilterQ = (0.54 + 0.46 * cos(Pi2Length * n4)) * IdealQ;\n\t\t\n\t\tYAccum = YAccum + C * FilterY;\n\t\tIAccum = IAccum + C * cos(WT) * FilterI;\n\t\tQAccum = QAccum + C * sin(WT) * FilterQ;\n\t}\n\t\n\tfloat Y = YAccum.r + YAccum.g + YAccum.b + YAccum.a;\n\tfloat I = (IAccum.r + IAccum.g + IAccum.b + IAccum.a) * 2.0;\n\tfloat Q = (QAccum.r + QAccum.g + QAccum.b + QAccum.a) * 2.0;\n\t\n\tvec3 YIQ = vec3(Y, I, Q);\n\n\tvec3 OutRGB = vec3(dot(YIQ, vec3(1.0, 0.956, 0.621)), dot(YIQ, vec3(1.0, -0.272, -0.647)), dot(YIQ, vec3(1.0, -1.106, 1.703)));\t\t\n\t\n\treturn vec4(OutRGB, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 InverseRes = 1.0 / iResolution.xy;\n\tvec2 UV = fragCoord.xy * InverseRes;\n\n\tvec4 OutPixel = NTSCCodec(UV);\n\tfragColor = OutPixel;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldXGRf","date":"1375493384","viewed":2860,"name":"NTSC Codec","username":"UltraMoogleMan","description":"This is a port of my NTSC encode/decode shader set from MAME and MESS, modified to use only one pass. The encode pass is performed by the CompositeSample() function, and the decode pass is in main().","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","postprocessing","signalprocessing"],"hasliked":0,"parentid":"","parentname":""}}