{"ver":"0.1","info":{"id":"XcdXWj","date":"1717528989","viewed":149,"name":"Parallax Occulusion Mapping(POM)","username":"playbyan1453","description":"Parallax mapping, using noise functiion to break between steps. [url]https://learnopengl.com/Advanced-Lighting/Parallax-Mapping[/url]","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["parallax","normal","mapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 0: Low, 1: High\n#define QUALITY 1\n\nstruct Ray {\n    vec3 ori;\n    vec3 dir;\n};\n\nfloat box(Ray ray, vec3 boxSize, out vec3 outNormal) {\n    vec3 m = 1.0 / ray.dir;\n    vec3 n = m * ray.ori;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if(tN > tF || tF < 0.0) return -1.0; // no intersection\n    outNormal = tN > 0.0 ? step(vec3(tN), t1) : // ro ouside the box\n                           step(t2, vec3(tF));  // ro inside the box\n    outNormal *= -sign(ray.dir);\n    return tN;\n}\n\n// sphere of size r centered at point p\n// Projection and Pythagoras' theorem combined\n// some gpu's has some precision issues on projection method\nfloat sphere(Ray ray, vec3 p, float r) {\n    vec3 o = p - ray.ori;\n    float b = dot(o, ray.dir);\n    float c = dot(o, o) - r * r;\n    vec3 qc = o - ray.dir * b;\n    float d = min(b * b - c, r * r - dot(qc, qc));\n    if(d < 0.0) return -1.0; // no intersection\n    d = sqrt(d);\n    return b - d;\n}\n\nfloat plane(Ray ray, vec3 n) {\n    return dot(ray.ori, n) / dot(-ray.dir, n);\n}\n\nfloat getHeight(vec3 pos, vec3 nor) {\n    vec3 w  = pow(abs(nor), vec3(8));\n         w /= (w.x + w.y + w.z);\n    vec2 v1 = sign(pos.z) * pos.xy,\n         v2 = sign(pos.y) * pos.xz,\n         v3 = sign(pos.x) * pos.zy,\n         m = mix(v1, mix(v2, v3, step(w.y, hash1())), step(w.z, hash1())) * 0.5 + 0.5;\n    return texture(iChannel0, m).x;\n}\n\nmat3 tbn(vec3 no) {\n    vec3 up = abs(no.y) < 1.0 - 1e-4 ? vec3(0, 1, 0) : vec3(1, 0, 0);\n    vec3 ta = normalize(cross(up, no));\n    vec3 bi = cross(no, ta);\n    return mat3(ta, bi, no);\n}\n\nvec3 color(float a) {\n    vec3[] colors = vec3[] (\n        vec3(0.0, 0.1, 1.0),\n        vec3(0.2, 1.0, 0.0),\n        vec3(1.0, 0.8, 0.0),\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.7, 0.0, 1.0),\n        vec3(1.0, 1.0, 1.0)\n    );\n    int colLength = colors.length() - 1;\n    \n    a *= float(colLength);\n\n    int ca = int(a);\n    float fa = fract(a);\n    \n    return mix(colors[ca], colors[min(ca + 1, colLength)], fa);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    uvec2 p = uvec2(fragCoord);\n    seed = uvec2(HilbertIndex(p) + WeylHash(p >> 1u), iFrame);\n    \n    float maxAxis = step(iResolution.y, iResolution.x);\n    vec2 uv  = fragCoord / iResolution.xy - 0.5;\n         uv *= vec2(mix(1.0, iResolution.x / iResolution.y, maxAxis),\n                    mix(iResolution.y / iResolution.x, 1.0, maxAxis));\n    \n    mat3 lo = rot(vec3(0, 0, 0) * deg2rad);\n    mat3 go = rot(vec3(0, iTime * 0.5, 0));\n    mat3 ca = lo * go;\n    float fov = 75.0;\n    Ray ray = Ray(vec3(0, 0, 6) * ca, perspective(uv, fov));\n    ray.dir *= ca;\n    \n    vec3 nor = vec3(-ray.dir);\n    float tmin = 1e20;\n    \n    vec3 bN = vec3(0);\n    float tBox = box(ray, vec3(1), bN);\n    if(tBox > 0.0 && tmin > tBox) {\n        nor = bN;\n        tmin = tBox;\n    }\n    \n    /*float tSphere = sphere(ray, vec3(0), 1.0);\n    if(tSphere > 0.0 && tmin > tSphere) {\n        nor = normalize(ray.ori + ray.dir * tSphere);\n        tmin = tSphere;\n    }*/\n    \n    vec3 col = vec3(0);\n    if(tmin > 0.0 && tmin < 1e20) {\n        float heightScale = 0.25;\n        vec3 lightDir = normalize(vec3(0.1, 0.8, 0.5));\n        float minLayers = 1.0;\n        float maxLayers = 8.0;\n        #if QUALITY\n        minLayers = 8.0;\n        maxLayers = 32.0;\n        #else\n        minLayers = 4.0;\n        maxLayers = 16.0;\n        #endif\n        float numLayers = floor(mix(minLayers, maxLayers, hash1() * max(dot(-ray.dir, nor), 0.0)));\n        float layerDepth = 1.0 / numLayers;\n        float currentDepth = 1.0;\n        \n        vec3 pos = ray.ori + ray.dir * tmin;\n        float currentHeight = getHeight(pos, nor);\n        float dtStep = plane(Ray(pos, ray.dir), nor) * layerDepth * heightScale;\n        vec3 dtPos = ray.dir * dtStep;\n        \n        float complexity;\n        while(currentDepth > currentHeight) {\n            pos += dtPos;\n            complexity += dtStep * numLayers;\n            currentHeight = getHeight(pos, nor);\n            currentDepth -= layerDepth;\n        }\n        \n        vec3 prevPos = pos - dtPos;\n        float afterDepth  = currentDepth - currentHeight;\n        float beforeDepth = currentDepth - getHeight(prevPos, nor) + layerDepth;\n        float weight = afterDepth / (afterDepth - beforeDepth);\n        pos = mix(pos, prevPos, weight);\n        \n        float cd = dFdx(uv.x); // Distance to each pixel\n        #if QUALITY\n        float sa0 = 1.0 - getHeight(pos + vec3( cd,  0, 0) * ca, nor);\n        float sa1 = 1.0 - getHeight(pos + vec3(-cd,  0, 0) * ca, nor);\n        float sa2 = 1.0 - getHeight(pos + vec3(  0, cd, 0) * ca, nor);\n        float sa3 = 1.0 - getHeight(pos + vec3(  0,-cd, 0) * ca, nor);\n        vec3 tanNor = normalize(vec3(sa0 - sa1, sa2 - sa3, cd) * vec2(heightScale, 1).xxy);\n        #else\n        float h = 1.0 - getHeight(pos, nor);\n        vec3 tanNor = normalize(vec3(dFdx(h), dFdy(h), cd) * vec2(heightScale, 1).xxy);\n        #endif\n        \n        nor = tbn(nor) * tanNor;\n        \n        // Shaded\n        col = vec3(0.95) * max(dot(nor, lightDir), 0.0);\n        \n        // Normal\n        // col = tanNor * 0.5 + 0.5;\n        \n        // World Normal\n        // col = nor;\n        \n        // col = color(complexity / maxLayers);\n    }\n    \n    col = max(col, 0.0);\n    col = pow(col, vec3(0.454545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define pi       3.141592653589793\n#define twopi    6.283185307179586\n#define fourpi  12.566370614359172\n#define deg2rad  0.017453292519943\n#define rad2deg  57.29577951308232\n\nmat3 rot(vec3 ang) {\n    vec3 s = sin(ang);\n    vec3 c = cos(ang);\n    mat3 x = mat3(\n        vec3(   1,   0,   0),\n        vec3(   0, c.x,-s.x),\n        vec3(   0, s.x, c.x)\n    );\n    mat3 y = mat3(\n        vec3( c.y,   0, s.y),\n        vec3(   0,   1,   0),\n        vec3(-s.y,   0, c.y)\n    );\n    mat3 z = mat3(\n        vec3( c.z, s.z,   0),\n        vec3(-s.z, c.z,   0),\n        vec3(   0,   0,   1)\n    );\n    return x * y * z;\n}\n\nvec3 perspective(vec2 p, float a) {\n    return normalize(vec3(p, -1.0 / tan(a * 0.5 * deg2rad)));\n}\n\nvec3 equirectangular(vec2 p) {\n    p *= vec2(twopi, pi);\n    return normalize(vec3(sin(p.x), tan(p.y), -cos(p.x)) * cos(p.y));\n}\n\nvec3 cubemapface(vec2 p) {\n    return normalize(vec3(tan(p * 0.25 * twopi - fourpi), -1));\n}\n\nvec3 mirrorball(vec2 p) {\n    p *= 2.0;\n    if(dot(p, p) > 1.0) return vec3(0);\n    vec3 n = normalize(vec3(p,-sqrt(max(1.0 - dot(p, p), 0.0))));\n    return reflect(vec3(0, 0, 1), n);\n}\n\n// Hashes\n\n// https://www.shadertoy.com/view/ssBBW1\nuint HilbertIndex(uvec2 p) {\n    uint i = 0u;\n    for(uint l = 0x4000u; l > 0u; l >>= 1u) {\n        uvec2 r = min(p & l, 1u);\n        i = (i << 2u) | ((r.x * 3u) ^ r.y);       \n        p = r.y == 0u ? (0x7FFFu * r.x) ^ p.yx : p;\n    }\n    return i;\n}\n\nuint ReverseBits(uint x) {\n    x = ((x & 0xaaaaaaaau) >> 1) | ((x & 0x55555555u) << 1);\n    x = ((x & 0xccccccccu) >> 2) | ((x & 0x33333333u) << 2);\n    x = ((x & 0xf0f0f0f0u) >> 4) | ((x & 0x0f0f0f0fu) << 4);\n    x = ((x & 0xff00ff00u) >> 8) | ((x & 0x00ff00ffu) << 8);\n    return (x >> 16) | (x << 16);\n}\n\n// from: https://psychopath.io/post/2021_01_30_building_a_better_lk_hash\nuint OwenHash(uint x, uint seed) { // seed is any random number\n    x ^= x * 0x3d20adeau;\n    x += seed;\n    x *= (seed >> 16) | 1u;\n    x ^= x * 0x05526c56u;\n    x ^= x * 0x53a22864u;\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c) {\n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u; \n}\n\nuvec2 seed;\n\nfloat hash1() {\n    uint x = OwenHash(ReverseBits(seed.x), seed.y += 0x7feb352du);\n    seed.y ^= seed.y >> 16u;\n         x = OwenHash(ReverseBits(x),      seed.y += 0x846ca68bu);\n    seed.y ^= seed.y >> 16u;\n    return float(ReverseBits(x)) / float(0xffffffffu);\n}\n\nvec2 hash2() {\n    return vec2(hash1(), hash1());\n}","name":"Common","description":"","type":"common"}]}