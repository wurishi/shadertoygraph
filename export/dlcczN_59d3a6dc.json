{"ver":"0.1","info":{"id":"dlcczN","date":"1698944241","viewed":128,"name":"Optimized mountain rendering","username":"tomcat7479","description":"优化复杂地形渲染 https://www.shadertoy.com/view/dsGfzG","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ground"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n  优化复杂地形渲染 https://www.shadertoy.com/view/dsGfzG\n*/\n\n#define rotateM mat2(0.6, -0.8, 0.8, 0.6)\n#define rotateCount 10\n#define min_distance 0.1\n#define max_distance 200.0\n#define iter_precision 1e-4\n#define iter_count 512\n\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 up = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\n/**\n  vec3 p3 = fract(vec3(pos.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n*/\nfloat random(vec2 p) {\n    vec3 q = fract(p.xyx * 0.1031);\n    q += dot(q, q.yzx + 33.33);\n    return fract((q.x + q.y) * q.z);\n}\n\n// noise value and noise gradient\n// 插值公式: a + (b-a)*x(1-y) + (c-d)*(1-x)*y + (d-a)*x*y\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    vec2 du = 6.0 * f * (1.0 - f);\n\n    vec2 h = vec2(1.0, 0.0);\n    float a = random(i);\n    float b = random(i + h.xy);\n    float c = random(i + h.yx);\n    float d = random(i + h.xx);\n\n    float val = a + (b - a) * u.x * (1.0 - u.y) + (c - a) * (1.0 - u.x) * u.y + (d - a) * u.x * u.y;\n    vec2 grad = du * (vec2(b - a, c - a) + (a - b - c + d) * u.yx);\n    return vec3(val, grad);\n}\n\n// note: 这里之所以，不将迭代次数通过参数的形式进行传递是因为传参是要消耗性能的\n// 低精度迭代，确定相机的位置，这里是不需要非常高的精度，所以可以适当减少迭代次数\nfloat ground4(vec2 p) {\n    p = 0.003 * p; // 缩放之后，地面会变的非常平缓，近似于平面\n    float sdf = 0.0;\n    float scale = 1.0;\n    vec2 grad = vec2(0.0);\n    for (int i = 0; i < 4; i++) {\n        vec3 noiseInfo = noise(p);\n        grad += noiseInfo.yz;\n        sdf += scale * noiseInfo.x / (1.0 + dot(grad, grad));\n        p = rotateM * p * 2.0;\n        scale *= 0.5;\n    }\n    return 120. * sdf; // 然后在乘一个倍数，给山体的局部起伏放大\n}\n\n// 下面的山体的缩放参数是借鉴的iq的一个作品中的参数(0.003, 120.0)\nfloat ground10(vec2 p) {\n    p = 0.003 * p; // 缩放之后，地面会变的非常平缓，近似于平面\n    float sdf = 0.0;\n    float scale = 1.0;\n    vec2 grad = vec2(0.0);\n    for (int i = 0; i < 10; i++) {\n        vec3 noiseInfo = noise(p);\n        grad += noiseInfo.yz;\n        sdf += scale * noiseInfo.x / (1.0 + dot(grad, grad));\n        p = rotateM * p * 2.0;\n        scale *= 0.5;\n    }\n    return 120. * sdf; // 然后在乘一个倍数，给山体的局部起伏放大\n}\n\n// 用于计算法向量，这里将迭代次数增加到16，是为了增加山体的细节\nfloat ground16(vec2 p) {\n    p = 0.003 * p; // 缩放之后，地面会变的非常平缓，近似于平面\n    float sdf = 0.0;\n    float scale = 1.0;\n    vec2 grad = vec2(0.0);\n    for (int i = 0; i < 16; i++) {\n        vec3 noiseInfo = noise(p);\n        grad += noiseInfo.yz;\n        sdf += scale * noiseInfo.x / (1.0 + dot(grad, grad));\n        p = rotateM * p * 2.0;\n        scale *= 0.5;\n    }\n    return 120. * sdf; // 然后在乘一个倍数，给山体的局部起伏放大\n}\n\n/**\n  这里的法向量的计算无论远近其精度是一致的，但是对于远处的点，没有必要太高的精度，反而会造成远处的噪点\n  所以这里我们将距离传进来，让当前的精度 = 固定精度 * 距离\n*/\nvec3 calcNorm(vec3 p, float t) {\n    vec2 epsilon = vec2(1e-4 * t, 0);\n    return normalize(vec3(ground16(p.xz + epsilon.xy) - ground16(p.xz - epsilon.xy), 2.0 * epsilon.x, ground16(p.xz + epsilon.yx) - ground16(p.xz - epsilon.yx)));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = min_distance;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ro + t * rd;\n        float d = ground10(p.xz);\n        float dy = p.y - d;\n        if (abs(dy) < t * iter_precision || t > max_distance) {\n            break;\n        }\n        t += 0.4 * dy;\n    }\n    return t;\n}\n\n// 优化上述的rayMarch过程\nfloat rayMarch(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ro + t * rd;\n        float d = ground10(p.xz);\n        float dy = p.y - d;\n        if (abs(dy) < t * iter_precision || t > tmax) {\n            break;\n        }\n        t += 0.4 * dy;\n    }\n    return t; \n}\n\nvec3 render(vec2 uv) {\n    float an = 0.01 * iTime;\n    float r = 100.0;\n    vec2 px2 = vec2(r * sin(an), r * cos(an));\n    float h = ground4(px2) + 15.0;\n    vec3 ro = vec3(px2.x, h, px2.y);\n    float foucs = 1.0;\n    vec3 lookAt = vec3(r * sin(an + 0.01), h, r * cos(an + 0.01));\n    mat3 camera = setCamera(lookAt, ro, 0.0);\n    vec3 rd = normalize(camera * vec3(uv, foucs));\n\n    float tmin = 0.1;\n    float tmax = 500.0;\n    float maxh = 300.;\n    float tp = (maxh - ro.y) / rd.y; // 仅考虑ro.y < maxh的点 （提高渲染效率）\n    if (tp > 0.) {\n        if (maxh > ro.y)\n            tmax = min(tmax, tp);\n        else\n            // 此时maxh = ro.y, tp = 0.0\n            tmin = max(tmin, tp);\n    }\n\n    float t = rayMarch(ro, rd, tmin, tmax);\n    vec3 color = vec3(0.0);\n\n    if (t < max_distance) {\n        vec3 p = ro + t * rd;\n        vec3 n = calcNorm(p, t);\n        vec3 difColor = vec3(0.67, 0.57, 0.44);\n        color = difColor * dot(n, vec3(0, 1, 0));\n    } else {\n        color = vec3(0.1882, 0.5882, 0.8941) * exp(-1.0 * uv.y);\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fix(fragCoord);\n    vec3 col = render(uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}