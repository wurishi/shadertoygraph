{"ver":"0.1","info":{"id":"WlsyRr","date":"1591286743","viewed":420,"name":"Day 168 - Quadtree","username":"jeyko","description":"potato","likes":20,"published":3,"flags":0,"usePreview":0,"tags":["mdtmjvm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is a classifier of quadtree points, but it doesn't build the actual structure. \n// That would require a bit different of an approach \n\n\nvec2 r12(float i){\n\treturn texture(iChannel0,vec2(mod(i,256.)/256.,floor(i/256.)*256.)).xy*2. - 1.;\n}\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U- 0.5*iResolution.xy)/iResolution.y;\n\n    //uv /= dot(uv,uv)*19.;\n    \n    vec3 col = vec3(0);\n\n    \n    float id = 0.;\n    \n    float d = 10e6;\n    float dside = 10e6;\n    \n    #define ITERS 25.\n    #define DOTS 10.\n    \n    for(float i = 0.; i < 19.; i++){\n    \tvec2 p = r12(i+24.)/1.;\n        \n        p.xy += vec2(sin(i+iTime),cos(i+iTime))/20.;\n        \n        d = min(d, length(p-uv));\n        \n        \n        for(float k = 1.; k < pow(2.,ITERS); k*=2.){\n\t\t\n        \tdside = min(dside, abs(max(abs(fract((uv.y)*k) - 0.5), abs(fract((uv.x)*k)) - 0.5)-0.5)/k);\n            \n            vec2 uid = floor(uv*k)/(k);\n            \n            float stsz = 1./k;\n            if(p.x < uid.x + stsz && p.x > uid.x && p.y < uid.y+stsz && p.y > uid.y ){\n            \t//id+= uid.y + uid.x*1. + 4.;\n                id += 3.6;\n            } else {\n            \tbreak;\n            }\n            \n        }\t\n    \n    }\n    \n    col += 0.5 + sin(id + vec3(1.,0.5,0.5))/3.;\n    \n    float dw = 0.005;\n    float dott = smoothstep(dw*1.4,dw,d);\n    dside = smoothstep(dw*1.04,dw,dside);\n    \n    col -= vec3(0.,0.4,0.8)*dside;\n    \n    col = mix(col,vec3(1,0.1,0.4),dott);\n    \n    \n    C = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}