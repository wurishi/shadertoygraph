{"ver":"0.1","info":{"id":"4dlcDr","date":"1487808769","viewed":120,"name":"Midterm","username":"Dreeryan","description":"procedural","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Pattern 10\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n//.785 = 45 degrees\n\n//-----Colors-----\n\nvec3 blue = vec3(0.52, 0.81, 0.98);\nvec3 iGreen = vec3(0, 0.5, 0);\nvec3 iRed = vec3(0.86, 0.07, 0.23);\nvec3 iWhite = vec3(1.0, 1.0, 1.0);\nvec3 iYellow = vec3(1.0, 1.0, 0.0);\nvec3 brown = vec3(.87, .72, .52);\n\n\n//----Functions----\n\n//Extra function - Maps values\nfloat map(float x, float in_min, float in_max, float out_min, float out_max)\n{\n\treturn (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n\n//Function 1 - Creates Poligons\nfloat createPolygon(vec2 uv, float ratio, float sides, float size, vec2 pos)\n{\n    uv -= vec2(pos.x*ratio, pos.y);\n\tfloat a = atan(uv.x, uv.y)+PI;\n    float r = TWO_PI/sides;\n\tfloat dist = cos(floor(.5+a/r)*r-a)*length(uv);\n    dist = 1.-step(size, dist);\n    return dist;\n}\n\n//Function 2 - Rotates by Angle\nmat2 rotate2d(float angle)\n{\n\treturn mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n//Function 3 - Scales by given value\nmat2 scale2d(vec2 value)\n{\n    return mat2(value.x, 0, 0, value.y);\n}\n\n//Function 4 - Creates circles\nfloat createCircle(vec2 uv, float ratio, float size, vec2 pos)\n{\n    vec2 center = vec2(pos.x*ratio, pos.y);\n\tfloat unr = abs(sin(size));\n\tfloat r = map(unr, 0.0, 1.0, 0.1, 0.3);\n    \n    float dist = distance(center, uv);\n    \n    float value = step(dist, r);\n    return value;\n}\n\n//Function 5 - Creates Rectangles (modifiable lenght and width)\nfloat createRect(vec2 uv, float ratio, vec2 size, vec2 pos)\n{\n    float value = step(pos.x - size.x, uv.x) - step(pos.x + size.x, uv.x);\n    float value2 = step(pos.y - size.y, uv.y) - step(pos.y + size.y, uv.y);\n    value *= value2;\n    return value;\n}\n//Function 6\n\n\n//-----Patterns------\n\n//-------------------------------------------------------------------------------------\n#if Pattern == 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 3.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    uv -= pos;\n    uv *= scale2d(vec2(abs(sin(iTime))));\n    uv += pos;\n        \n    vec3 dist;\n    \n    if(tileIdx.x == 0. && tileIdx.y == 0. ||\n       tileIdx.x == 0. && tileIdx.y == 1. ||\n       tileIdx.x == 0. && tileIdx.y == 2.)\n    {\n        dist = vec3(createCircle(uv, ratio, .5, vec2(0.5, 0.5))) * iGreen;\n    }\n    else if(tileIdx.x == 1. && tileIdx.y == 0. ||\n       tileIdx.x == 1. && tileIdx.y == 1. ||\n       tileIdx.x == 1. && tileIdx.y == 2.)\n    {\n        dist = vec3(createCircle(uv, ratio, .5, vec2(0.5, 0.5))) * iWhite;\n    }\n    else if(tileIdx.x == 2. && tileIdx.y == 0. ||\n       tileIdx.x == 2. && tileIdx.y == 1. ||\n       tileIdx.x == 2. && tileIdx.y == 2.)\n    {\n        dist = vec3(createCircle(uv, ratio, .5, vec2(0.5, 0.5))) * iRed;\n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 10.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    \n    \n    vec2 upPos = vec2(0.5, mod(iTime, 1.0)+0.1);\n    vec2 downPos = vec2(0.5, mod(iTime, 1.0)+0.1);\n    \n    vec3 dist = vec3(createPolygon(uv, ratio, 3., .1, upPos)) * blue;\n    dist += vec3(createPolygon(uv, ratio, 3., .1, vec2(0., -1.0) + upPos)) * blue;\n    \n    if(mod(tileIdx.x, 2.0) == 0.0)\n    {\n        uv -= pos;\n        uv *= rotate2d(3.15);\n    \tuv += pos;\n        \n        dist = vec3(createPolygon(uv, ratio, 3., .1, downPos)) * iRed;\n    \tdist += vec3(createPolygon(uv, ratio, 3., .1, vec2(0., -1.0) + downPos)) * iRed;\n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 25.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n        \n    uv -= pos;\n    uv *= rotate2d(iTime);\n    uv += pos;\n  \n    uv -= pos;\n   \t\tuv *= rotate2d(PI * (1./4.));\n    \tuv += pos;\n    \n    float color = createPolygon(uv, ratio, 3., .1, vec2(.5, .4));\n\n\tuv -= pos;\n    uv *= rotate2d(-1.);\n    uv += pos;\n\n\tcolor += createPolygon(uv, ratio, 3., .1, vec2(.6, .6));\n\t\n    //making the rotation 0\n   // uv *= rotate2d(.5);\n    \n    if(mod(tileIdx.x, 2.) == 1. && mod(tileIdx.y, 2.) == 0.)\n    {\n        uv -= pos;\n   \t\tuv *= rotate2d(PI * (2./4.));\n    \tuv += pos;\n        \n    \tcolor = createPolygon(uv, ratio, 3., .1, vec2(.5, .4));\n\n        uv -= pos;\n   \t\tuv *= rotate2d(-1.);\n    \tuv += pos;\n        \n\t\tcolor += createPolygon(uv, ratio, 3., .1, vec2(.6, .6));\n    }\n    else if(mod(tileIdx.x, 2.) == 1. && mod(tileIdx.y, 2.) == 1.)\n    {\n        uv -= pos;\n   \t\tuv *= rotate2d(PI * (3./4.));\n    \tuv += pos;\n        \n        uv -= pos;\n   \t\tuv *= rotate2d(1.);\n    \tuv += pos;\n        \n    \tcolor = createPolygon(uv, ratio, 3., .1, vec2(.5, .4));\n\n        uv -= pos;\n   \t\tuv *= rotate2d(-1.);\n    \tuv += pos;\n        \n\t\tcolor += createPolygon(uv, ratio, 3., .1, vec2(.6, .6));\n    }\n    else if(mod(tileIdx.x, 2.) == 0. && mod(tileIdx.y, 2.) == 1.)\n    {\n        uv -= pos;\n   \t\tuv *= rotate2d(PI);\n    \tuv += pos;\n        \n        uv -= pos;\n   \t\tuv *= rotate2d(-6.2);\n    \tuv += pos;\n        \n    \tcolor = createPolygon(uv, ratio, 3., .1, vec2(.5, .4));\n\n        uv -= pos;\n   \t\tuv *= rotate2d(-1.);\n    \tuv += pos;\n        \n\t\tcolor += createPolygon(uv, ratio, 3., .1, vec2(.6, .6));\n    }\n    \n   \n  \tvec3 dist = vec3(color) * (iRed * vec3(abs(sin(iTime)))); \n        \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 7.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    vec2 leftPos = vec2(mod(iTime, 1.0)+0.1, 0.5);\n        \n    vec3 dist;\n    dist = vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .9)))*iRed;\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .7)))*iRed;\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .5)))*iRed;\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .3)))*iRed;\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .1)))*iRed;\n    \n    float size = 2.;\n    \n    if(mod(tileIdx.x, 2.) == 0.)\n    {\n        dist -= vec3(createCircle(uv, ratio, size, leftPos));\n        dist -= vec3(createCircle(uv, ratio, size, vec2(leftPos.x - 1., .5)));\n    }\n    else if(mod(tileIdx.x, 2.) == 1.)\n    {\n        dist += vec3(createCircle(uv, ratio, size, leftPos));\n        dist += vec3(createCircle(uv, ratio, size, vec2(leftPos.x - 1., .5)));\n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 10.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    vec2 rightPos = vec2(mod(iTime, 1.)+.13, .5);\n        \n    vec3 dist;\n    \n    if(mod(tileIdx.x, 2.) == 0.)\n    {\n        if(mod(tileIdx.y, 2.) == 0.)\n        {\n        \tdist = vec3(createPolygon(uv, ratio, 4., .26, vec2(rightPos.x, .26))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 4., .26, vec2(rightPos.x - 1., .26))) * blue;\n            \n        \tdist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x, .668))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x - 1., .668))) * blue;\n            \n            uv -= pos;\n            uv *= rotate2d(3.14);\n            uv += pos;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x, .15))) *iGreen;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x - .999, .15))) * iGreen;\n        }\n        else if(mod(tileIdx.y, 2.) == 1.)\n        {\n        \tdist = vec3(createPolygon(uv, ratio, 4., .26, vec2(-rightPos.x + 1., .256))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 4., .26, vec2(-rightPos.x + 2., .256))) * iGreen;\n            \n        \tdist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 1., .667))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 2., .667))) * iGreen;\n            \n            uv -= pos;\n            uv *= rotate2d(3.14);\n            uv += pos;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 1., .15))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 2., .15))) * blue;\n        }\n    }\n    else if(mod(tileIdx.x, 2.) == 1.)\n    {\n        if(mod(tileIdx.y, 2.) == 0.)\n        {\n        \tdist = vec3(createPolygon(uv, ratio, 4., .26, vec2(rightPos.x, .26))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 4., .26, vec2(rightPos.x - 1., .26))) * iGreen;\n            \n        \tdist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x, .668))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x - 1., .668))) * iGreen;\n            \n            uv -= pos;\n            uv *= rotate2d(3.14);\n            uv += pos;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x, .15))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(rightPos.x - 1., .15))) * blue;\n        }\n        else if(mod(tileIdx.y, 2.) == 1.)\n        {\n        \tdist = vec3(createPolygon(uv, ratio, 4., .26, vec2(-rightPos.x + 1., .256))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 4., .26, vec2(-rightPos.x + 2., .256))) * blue;\n            \n        \tdist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 1., .665))) * blue;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 2., .665))) * blue;\n            \n            uv -= pos;\n            uv *= rotate2d(3.14);\n            uv += pos;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + .999, .15))) * iGreen;\n            dist += vec3(createPolygon(uv, ratio, 3., .15, vec2(-rightPos.x + 1.999, .15))) * iGreen;\n        }\n    \n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 5.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    \n        \n    vec3 dist;\n    \n    uv -= pos;\n    uv *= rotate2d(iTime);\n    uv += pos;\n    \n    \n    dist = vec3(createPolygon(uv, ratio, 4., .3, vec2(0.5, 0.5))) * iGreen;\n    \n    uv -= pos;\n    uv *= scale2d(vec2(abs(sin(iTime))));\n    uv += pos;\n    \n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.33, .22)));\n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.33, .78)));\n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.67, .22)));\n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.67, .78)));\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 10.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    \n        \n    vec3 dist;\n    \n    uv -= pos;\n   // uv *= scale2d(vec2(abs(sin(iTime))));\n    uv *= rotate2d(PI/2.*sin(iTime));\n    uv += pos;\n    \n   \tdist = vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.3)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.1)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .9)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .7)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .5)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .3)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .1)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.1)));\n    dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.3)));\n    \n     uv -= pos;\n   // uv *= scale2d(vec2(abs(sin(iTime))));\n    uv *= rotate2d(-PI/2.);\n    uv += pos;\n    \n    if(mod(tileIdx.x, 2.) == 0. && mod(tileIdx.y, 2.) == 0.)\n    {\n        dist = vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.3)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.1)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .9)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .7)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .5)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .3)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .1)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.1)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.3)));\n    }\n    else if(mod(tileIdx.x, 2.) == 1. && mod(tileIdx.y, 2.) == 1.)\n    {\n        dist = vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.3)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, 1.1)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .9)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .7)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .5)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .3)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, .1)));\n        dist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.1)));\n    \tdist += vec3(createRect(uv, ratio, vec2(1, .05), vec2(1.0, -.3)));\n    }\n    \n\tfragColor = vec4(dist*brown,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 center = vec2(.5*ratio,.5);\n    \n     //-Fract--------------\n    uv *= 10.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    uv -= pos;\n    uv *= rotate2d(.785);\n   \tuv *= scale2d(vec2(sin(abs(iTime))));\n    uv += pos;\n    \n    vec3 dist;\n    \n    dist = vec3(createPolygon(uv, ratio, 4., .01, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .05, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .1, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .15, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .20, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .25, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .30, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .35, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .40, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .45, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .50, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .55, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .60, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .65, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .70, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .75, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .80, vec2(.5, .5)));\n    dist -= vec3(createPolygon(uv, ratio, 4., .85, vec2(.5, .5)));\n    dist += vec3(createPolygon(uv, ratio, 4., .90, vec2(.5, .5)));\n    \n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 5.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n    \n    uv -= pos;\n    //uv *= rotate2d(iTime);\n    //uv *= scale2d(vec2(abs(sin(iTime))));\n    uv += pos;\n        \n    vec3 dist;\n    \n    float posY = abs(sin(iTime));\n    \n    dist = vec3(createPolygon(uv, ratio, 4., .53, vec2(.5, .5))) * blue;\n    \n    dist += vec3(createPolygon(uv, ratio, 3., .175, vec2(.5, posY - .85)));\n    dist += vec3(createPolygon(uv, ratio, 4., .3, vec2(.5, posY - .85 - .47)));\n    \n    uv -= pos;\n    uv *= rotate2d(1.57);\n    uv += pos;\n    \n    dist += vec3(createPolygon(uv, ratio, 3., .175, vec2(.5, posY - .85)));\n    dist += vec3(createPolygon(uv, ratio, 4., .3, vec2(.5, posY - .85 - .47)));\n    \n    uv -= pos;\n    uv *= rotate2d(1.57);\n    uv += pos;\n    \n    dist += vec3(createPolygon(uv, ratio, 3., .175, vec2(.5, posY - .85)));\n    dist += vec3(createPolygon(uv, ratio, 4., .3, vec2(.5, posY - .85 - .47)));\n    \n    uv -= pos;\n    uv *= rotate2d(1.57);\n    uv += pos;\n    \n    dist += vec3(createPolygon(uv, ratio, 3., .175, vec2(.5, posY - .85)));\n    dist += vec3(createPolygon(uv, ratio, 4., .3, vec2(.5, posY - .85 - .47)));\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n//-------------------------------------------------------------------------------------\n#elif Pattern == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n     //-Fract--------------\n    uv *= 25.;\n    \n    //get indextile\n    vec2 tileIdx = floor(uv);\n    \n    uv = fract(uv);\n    //------------------\n    \n    uv.x *= ratio;\n    \n    vec2 pos = vec2(.5*ratio, .5) ;\n     \n    vec3 dist;\n    \n    dist = vec3(createCircle(uv, ratio, .3, vec2(.0, .0)));\n    dist += vec3(createCircle(uv, ratio, .3, vec2(1., 1.)));\n    dist += vec3(createCircle(uv, ratio, .3, vec2(.0, 1.)));\n    dist += vec3(createCircle(uv, ratio, .3, vec2(1., .0)));\n    \n    \n    \n    if(mod(tileIdx.x, 2.) == 0. && mod(tileIdx.y, 2.) == 0.)\n    {\n        uv -= pos;\n   \t\t uv *= rotate2d(-iTime);\n  \t\t //uv *= scale2d(vec2(abs(sin(iTime))));\n   \t\t uv += pos;\n    \n  \t\t  dist += vec3(createCircle(uv, ratio, .25, vec2(.5, .5)));\n  \t\t  dist += vec3(createCircle(uv, ratio, .001, vec2(.3, .5)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.7, .5)));\n  \t\t  dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .85)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .15)));\n    \n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.15, .5)));\n  \t\tdist += vec3(createCircle(uv, ratio, .001, vec2(.85, .5)));\n        dist += vec3(createCircle(uv, ratio, .001, vec2(.5, 1.1)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.5, -.1)));\n    \n    \tdist += vec3(createCircle(uv, ratio, .001, vec2(.36, .74)));\n\t\tdist += vec3(createCircle(uv, ratio, .001, vec2(.36, .26)));\n    \tdist += vec3(createCircle(uv, ratio, .001, vec2(.64, .74)));\n        dist += vec3(createCircle(uv, ratio, .001, vec2(.64, .26)));\n    }\n    else if(mod(tileIdx.x, 2.) == 1. && mod(tileIdx.y, 2.) == 1.)\n    {\n        uv -= pos;\n   \t\t uv *= rotate2d(-iTime);\n  \t\t //uv *= scale2d(vec2(abs(sin(iTime))));\n   \t\t uv += pos;\n    \n  \t\t  dist += vec3(createCircle(uv, ratio, .25, vec2(.5, .5)));\n  \t\t  dist += vec3(createCircle(uv, ratio, .001, vec2(.3, .5)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.7, .5)));\n  \t\t  dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .85)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .15)));\n    \n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.15, .5)));\n  \t\tdist += vec3(createCircle(uv, ratio, .001, vec2(.85, .5)));\n        dist += vec3(createCircle(uv, ratio, .001, vec2(.5, 1.1)));\n   \t\t dist += vec3(createCircle(uv, ratio, .001, vec2(.5, -.1)));\n    \n    \tdist += vec3(createCircle(uv, ratio, .001, vec2(.36, .74)));\n\t\tdist += vec3(createCircle(uv, ratio, .001, vec2(.36, .26)));\n    \tdist += vec3(createCircle(uv, ratio, .001, vec2(.64, .74)));\n        dist += vec3(createCircle(uv, ratio, .001, vec2(.64, .26)));\n    }\n    else\n    {\n    \tuv -= pos;\n    uv *= rotate2d(iTime);\n   //uv *= scale2d(vec2(abs(sin(iTime))));\n    uv += pos;\n    \n    dist += vec3(createCircle(uv, ratio, .25, vec2(.5, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.3, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.7, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .85)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.5, .15)));\n    \n    dist += vec3(createCircle(uv, ratio, .001, vec2(.15, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.85, .5)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.5, 1.1)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.5, -.1)));\n    \n    dist += vec3(createCircle(uv, ratio, .001, vec2(.36, .74)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.36, .26)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.64, .74)));\n    dist += vec3(createCircle(uv, ratio, .001, vec2(.64, .26)));\n        dist *= blue;\n    }\n    \n\tfragColor = vec4(dist,1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}