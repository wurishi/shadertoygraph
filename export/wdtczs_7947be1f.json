{"ver":"0.1","info":{"id":"wdtczs","date":"1602127926","viewed":361,"name":"Wormhole Effect","username":"mbowen","description":"The wormhole is enabled by default. You can change it an look at the texture and cube map implementation by making the global bool RUN_WORMHOLE false. Want more explanation look at my youtube https://youtu.be/XI9d4b_QUpk","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["wormhole","gravitationalattraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GLSL STARTER CODE BY DANIEL S. BUCKSTEIN\nfloat globalIntensity = .1;\nvec4 globalColor = vec4(1.0);\nconst int MAX_LIGHTS = 5;\nconst bool RUN_WORMHOLE = true; //set to true to run wormhole\n#define PI 3.1415926538\n\n\n//------------------------------------------------------------\n// TYPE ALIASES & UTILITY FUNCTIONS\n\n// sScalar: alias for a 1D scalar (non-vector)\n#define sScalar float\n\n// sCoord: alias for a 2D coordinate\n#define sCoord vec2\n\n// sDCoord: alias for a 2D displacement or measurement\n#define sDCoord vec2\n\n// sBasis: alias for a 3D basis vector\n#define sBasis vec3\n\n// sPoint: alias for a point/coordinate/location in space\n#define sPoint vec4\n\n// sVector: alias for a vector/displacement/change in space\n#define sVector vec4\n\n\n// color3: alias for a 3D vector representing RGB color\n// \t(this is non-spatial so neither a point nor vector)\n#define color3 vec3\n\n// color4: alias for RGBA color, which is non-spatial\n// \t(this is non-spatial so neither a point nor vector)\n#define color4 vec4\n\nfloat squareValue(in float x){\n\treturn x*x;\n}\n\nfloat powerOfTwo (in float base, in int power){\n    for(int i = power - 1; i >= 0; --i){\n    \tbase *= base;\n    }\n\treturn base;\n}\n\n// asPoint: promote a 3D vector into a 4D vector \n//\trepresenting a point in space (w=1)\n//    v: input 3D vector to be converted\nsPoint asPoint(in sBasis v)\n{\n    return sPoint(v, 1.0);\n}\n\n// asVector: promote a 3D vector into a 4D vector \n//\trepresenting a vector through space (w=0)\n//    v: input 3D vector to be converted\nsVector asVector(in sBasis v)\n{\n    return sVector(v, 0.0);\n}\n\n\n// lengthSq: calculate the squared length of a vector type\nsScalar lengthSq(sDCoord x)\n{\n    return dot(x, x);\n}\nsScalar lengthSq(sBasis x)\n{\n    return dot(x, x);\n}\nsScalar lengthSq(sVector x)\n{\n    return dot(x, x);\n}\n\n//Rotation Functions\n//mat3(1.0,0.0,0.0,0.0,c,s,0.0,-s,c); //Rotates around the X axis\n//mat3(c,0.0,-s,0.0\t\t  ,1.0,0.0,s,0.0,c); //rotates around the y axis\n//mat3(c  ,s  ,0.0,-s ,c  ,0.0,0.0,0.0,1.0); //rotates around the z axis\nmat3 rotXAxis3D(in float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(1.0,0.0,0.0,0.0,c,s,0.0,-s,c); //Rotates around the X axis\n}\n\nmat3 rotYAxis3D(in float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(c,0.0,-s,0.0,1.0,0.0,s,0.0,c); //rotates around the y axis\n}\n\n\nvec4 texture2Dinit(in vec2 px, in vec2 invRes, in sampler2D channel){\n    vec2 loc = px * invRes;\n    loc *= 1.0;\n    return texture(channel, loc);\n}\n\nvec4 texture2Dinit(in vec2 uv, in sampler2D channel, in vec2 animator){\n    //vec2 loc = px * invRes;\n    //loc *= 1.0;\n    return texture(channel, uv + animator);\n}\n\n\n//------------------------------------------------------------\n// VIEWPORT INFO\n\n// sViewport: info about viewport\n//    viewportPoint: location on the viewing plane \n//\t\t\t\t\t\t\tx = horizontal position\n//\t\t\t\t\t\t\ty = vertical position\n//\t\t\t\t\t\t\tz = plane depth (negative focal length)\n//\t  pixelCoord:    position of pixel in image\n//\t\t\t\t\t\t\tx = [0, width)\t-> [left, right)\n//\t\t\t\t\t\t\ty = [0, height)\t-> [bottom, top)\n//\t  resolution:    resolution of viewport\n//\t\t\t\t\t\t\tx = image width in pixels\n//\t\t\t\t\t\t\ty = image height in pixels\n//    resolutionInv: resolution reciprocal\n//\t\t\t\t\t\t\tx = reciprocal of image width\n//\t\t\t\t\t\t\ty = reciprocal of image height\n//\t  size:       \t in-scene dimensions of viewport\n//\t\t\t\t\t\t\tx = viewport width in scene units\n//\t\t\t\t\t\t\ty = viewport height in scene units\n//\t  ndc: \t\t\t normalized device coordinate\n//\t\t\t\t\t\t\tx = [-1, +1) -> [left, right)\n//\t\t\t\t\t\t\ty = [-1, +1) -> [bottom, top)\n// \t  uv: \t\t\t screen-space (UV) coordinate\n//\t\t\t\t\t\t\tx = [0, 1) -> [left, right)\n//\t\t\t\t\t\t\ty = [0, 1) -> [bottom, top)\n//\t  aspectRatio:   aspect ratio of viewport\n//\t  focalLength:   distance to viewing plane\nstruct sViewport\n{\n    sPoint viewportPoint;\n\tsCoord pixelCoord;\n\tsDCoord resolution;\n\tsDCoord resolutionInv;\n\tsDCoord size;\n\tsCoord ndc;\n\tsCoord uv;\n\tsScalar aspectRatio;\n\tsScalar focalLength;\n};\n\n// initViewport: calculate the viewing plane (viewport) coordinate\n//    vp: \t\t      output viewport info structure\n//    viewportHeight: input height of viewing plane\n//    focalLength:    input distance between viewer and viewing plane\n//    fragCoord:      input coordinate of current fragment (in pixels)\n//    resolution:     input resolution of screen (in pixels)\nvoid initViewport(out sViewport vp,\n                  in sScalar viewportHeight, in sScalar focalLength,\n                  in sCoord fragCoord, in sDCoord resolution)\n{\n    vp.pixelCoord = fragCoord;\n    vp.resolution = resolution;\n    vp.resolutionInv = 1.0 / vp.resolution;\n    vp.aspectRatio = vp.resolution.x * vp.resolutionInv.y;\n    vp.focalLength = focalLength;\n    vp.uv = vp.pixelCoord  * vp.resolutionInv;\n    vp.ndc = vp.uv * 2.0 - 1.0;\n    vp.size = sDCoord(vp.aspectRatio, 1.0) * viewportHeight;\n    vp.viewportPoint = asPoint(sBasis(vp.ndc * vp.size * .5, -vp.focalLength));\n}\n\nstruct pLight\n{\n\tvec4 center;\n    vec4 color;\n    float intensity;\n};\n\nvoid initPointLight(out pLight light, in vec3 center, in vec4 color, in float intensity)\n{\n  \tlight.center = asPoint(center);\n    light.color = color;\n    light.intensity = intensity;\n    \n}\n\nstruct sSphere\n{\n\tfloat radius;\n    vec4 center;\n};\n\nvoid initSphere (out sSphere sphere, in vec3 center, in float radius) \n{\n\tsphere.center = asPoint(center);\n    sphere.radius = radius;\n\n}\n\n//------------------------------------------------------------\n// RAY INFO\n\n// sRay: ray data structure\n//\t  origin: origin point in scene\n//    direction: direction vector in scene\nstruct sRay\n{\n    sPoint origin;\n    sVector direction;\n};\n\n// initRayPersp: initialize perspective ray\n//    ray: \t\t   output ray\n//    eyePosition: position of viewer in scene\n//    viewport:    input viewing plane offset\nvoid initRayPersp(out sRay ray,\n             \t  in sBasis eyePosition, in sBasis viewport)\n{\n    // ray origin relative to viewer is the origin\n    // w = 1 because it represents a point; can ignore when using\n    ray.origin = asPoint(eyePosition);\n\n    // ray direction relative to origin is based on viewing plane coordinate\n    // w = 0 because it represents a direction; can ignore when using\n    ray.direction = asVector(viewport - eyePosition);\n}\n\n// initRayOrtho: initialize orthographic ray\n//    ray: \t\t   output ray\n//    eyePosition: position of viewer in scene\n//    viewport:    input viewing plane offset\nvoid initRayOrtho(out sRay ray,\n             \t  in sBasis eyePosition, in sBasis viewport)\n{\n    // offset eye position to point on plane at the same depth\n    initRayPersp(ray, eyePosition + sBasis(viewport.xy, 0.0), viewport);\n}\n\nvec2 distort(in vec2 px){\n    float modifier = 50.0;\n\treturn vec2(px.x, px.y + cos((px.x + iTime/(modifier/2.0)) * modifier)/modifier);\n}\n\nvec3 distort(in vec3 px){\n    float modifier = 50.0;\n\treturn vec3(px.x, px.y + cos((px.x + iTime/(modifier/2.0)) * modifier)/modifier, px.z);\n}\n\nvec4 texture2DinitDistort(in vec2 px, in vec2 invRes, in sampler2D channel){\n    vec2 loc = px * invRes;\n    loc *= 1.0;\n    loc = distort(loc);\n    return texture(channel, loc);\n}\n\n\n\nbool circleExists(sRay ray, sSphere sphere, inout vec3 dp) {\n    dp.xy = ray.direction.xy - sphere.center.xy; //ray from pixel toward the center of the circle\n    float lSq = lengthSq(dp.xy), //the length function calulates the square length so it is more efficent just square it\n          rSq = squareValue(sphere.radius);\n    if(lSq <= rSq){\n        return true;\n    }\n    return false;\n}\n\n\n\nfloat calcDiffuseIntensity(in vec3 surfacePos, in vec3 surfaceNorm, in pLight light, inout vec3 normalizedLightVector){\n        //Diffuse Intensity\n        vec3 lightVector = light.center.xyz - surfacePos;\n        float lightVectorLengthSq = lengthSq(lightVector); //saves a square root function\n        normalizedLightVector = lightVector * inversesqrt(lightVectorLengthSq); //declaration of var\n        float diffusionCoefficent = max(0.0, (dot(surfaceNorm, normalizedLightVector)));\n        float attenuation = (1.0 - lightVectorLengthSq/squareValue(light.intensity));\n        return diffusionCoefficent * attenuation; \n}\n\nfloat calcSpecularIntensity(in vec3 surfacePos, in vec3 surfaceNorm, in sRay ray, in vec3 normalizedLightVector ){\n\t\t//Blinn-Phong Reflectance\n        vec3 viewVector = ray.origin.xyz - surfacePos; //Created because viewVector is used twice\n        vec3 normalViewVector = viewVector * inversesqrt(lengthSq(viewVector)); //Multiplied by the inverse and uses the dquared length function\n        vec3 halfWayVector = normalizedLightVector + normalViewVector; //Used twice \n        vec3 normalHalfWayVector = halfWayVector * inversesqrt(lengthSq(halfWayVector));\n        float specCoefficent = max(0.0, dot(surfaceNorm, normalHalfWayVector)); //Multiplied by the inverse and uses the dquared length function\n        return powerOfTwo(specCoefficent,50); //improved eff by removing pow function and adding a power of two function\n}\n\n//------------------------------------------------------------\n// RENDERING FUNCTIONS\n\n// calcColor: calculate the color of current pixel\n//\t  vp:  input viewport info\n//\t  ray: input ray info\ncolor4 calcColor(in sViewport vp, in sRay ray)\n{\n    //texture init\n    vec4 t1 = texture2DinitDistort(vp.pixelCoord, vp.resolutionInv, iChannel0);\n\n      \n    //CubeMap (Code could be contensed for a easier viewing experiance)\n    vec3 rayVec = ray.direction.xyz;\n   \n    vec2 mousePointInspace = (iMouse.xy * vp.resolutionInv)  * 2.0 - 1.0; \n    //rotation based on mouse position\n\tvec2 theta = mousePointInspace*2.0*PI; //Makes the mouse position more proportinal to the output screen \n    rayVec *= rotXAxis3D(-theta.y) * rotYAxis3D(theta.x); //rotates the scene to an angle based on the mouse position\n    //distort(rayVec);//Distort for fun\n    \n\tvec4 cube = texture(iChannel2, rayVec);  //Render Cube color\n    \n    //sphere init\n    sSphere sphere;\n    //initSphere(sphere, vec3(sin(iTime), 0.0, -4.0), .5);\n    initSphere(sphere, vec3(0.0, 0.0, -4.0), .25);\n    \n    //Lights init\n    pLight lights[MAX_LIGHTS];\n   //turns mouse XY into a NDC scale\n    \n    //other light implementation that don't quite work together very well. I recomend leaving them commented\n    //initPointLight(lights[0], vec3(vp.resolution.x*.5, vp.resolution.y*.5, 0.0), vec4(1.0), 10.0);\n    //initPointLight(lights[2], vec3(cos(iTime), sin(iTime), 0.0), vec4(1.0), 100.0);\n    //initPointLight(lights[3], vec3(2.0,  2.0, 0.0), vec4(1.0), 10.0);\n    \n    //surface init\n    vec3 position = vec3(vp.pixelCoord, -1.0); //surface position\n    vec3 normal = vec3(0.0, 0.0, 1.0); //surface \n    //vec3 surfaceNorm = normalize(vec3(vp.viewportPoint.xy, 1.0)); //other way to normalize\n    vec4 t2;\n    if(RUN_WORMHOLE){ // run Wormhole\n        initPointLight(lights[1], vec3(mousePointInspace.x,  mousePointInspace.y, 0.0), vec4(1.0), 1.0); //lighting with mouse when circle exists\n        if(circleExists(ray, sphere, position)){\n            //Unneccacary code\n            //position.z = squareValue(sphere.radius) - ((position.x*position.x)+(position.y*position.y));\n            //position.xy = sphere.center.xy + vec2(position.x, position.y);\n            //normal.xy = (position.xy - sphere.center.xy) / sphere.radius;\n            //light color init\n            //vec4 diffuseColor = vec4(normal * 0.5 + 0.5, 1.0);;\n            //vec4 specularColor = vec4(1.0);\n            //vec4 t2 = texture2Dinit(vp.pixelCoord, vp.resolutionInv, iChannel1, vec2(iTime*.5));\n\n            return vec4(0.0);\n        }\n        else{ //in else for efficency\n            //assisted by Zylann: https://godotengine.org/qa/13023/shaders-how-does-one-create-blackhole-effect-using-shaders\n            \n            //Render black hole effect\n            float p = sphere.radius * .1; // size of the black hole\n            vec2 diff = sphere.center.xy - vp.viewportPoint.xy; //Where the black hole is in realation to space\n            float distSq = lengthSq(diff); //distance squared rather than using length\n            vec2 normDiff = diff * inversesqrt(distSq); //inverse sqrt to get the normal\n            vec2 uv = vp.uv + normDiff * (p / (distSq + 0.01)); // Modifiter on the UV to create the effect. similar to the Gravitational attraction formula (G*m1*m2)/r^2 = Force. M1 is the black hole. M2 is the pixel. r^2 is distSq \n            t2 = texture2Dinit(uv, iChannel1, vec2(iTime*.5)); //defines the texture   \n            return t2;// + sumOfColors; \n        }\n    }\n    else{\n        //inits a light when not running wormhole so that the renders for parts 2-4 work as intended\n    \tinitPointLight(lights[1], vec3(iMouse.x,  iMouse.y, 0.0), vec4(1.0), 15.0); //lighting with mouse when circle exists\n    }\n\n    //Lighting\n    \n    //light color init\n    vec4 diffuseColor = vec4(normal * 0.5 + 0.5, 1.0);;\n    vec4 specularColor = vec4(1.0);\n    \n    vec4 backroundColor;\n    for(int i = MAX_LIGHTS-1; i >= 0; --i)\n    {\n\t\tvec3 normalizedLightVector;\n        backroundColor += (calcDiffuseIntensity(position, normal, lights[i], normalizedLightVector) * diffuseColor \n                       + calcSpecularIntensity(position, normal, ray, normalizedLightVector) * specularColor) * lights[i].color;\n    }\n    //Final Color calculation\n    vec4 sumOfColors = globalIntensity * globalColor + backroundColor;\n    \n    //Blackhole with lighting\n    //return t2 + sumOfColors; \n    \n    //rendering for part 2\n    return t1;\n    \n    //rendering for part 3\n    return t1 + sumOfColors;\n    \n    //Rendering for part 4\n    return cube + sumOfColors;\n    \n\n    \n    // test inputs\n    //vec4 t2 = texture(iChannel1, vp.uv );\n    //return vec4(mix(t1.rgb,t2.rgb, .5), 1.0);\n    //return vec4(.5);\n    //return color4(ray.direction.xyz == vp.viewportPoint.xyz); // pass\n    return color4(lengthSq(vp.viewportPoint.xy) >= 0.25); // pass\n    //return color4(vp.uv, 0.0, 0.0);\n    //return color4(vp.ndc, 0.0, 0.0);\n    //return vp.viewportPoint;\n}\n\n\n//------------------------------------------------------------\n// SHADERTOY MAIN\n\n// mainImage: process the current pixel (exactly one call per pixel)\n//    fragColor: output final color for current pixel\n//    fragCoord: input location of current pixel in image (in pixels)\nvoid mainImage(out color4 fragColor, in sCoord fragCoord)\n{\n    // viewing plane (viewport) inputs\n    const sBasis eyePosition = sBasis(0.0);\n    const sScalar viewportHeight = 2.0, focalLength = 1.5;\n    \n    // viewport info\n    sViewport vp;\n\n    // ray\n    sRay ray;\n    \n    // render\n    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);\n    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);\n    fragColor += calcColor(vp, ray);\n}\n","name":"Image","description":"","type":"image"}]}