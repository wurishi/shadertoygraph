{"ver":"0.1","info":{"id":"WlsBWH","date":"1597768943","viewed":150,"name":"Sphere ray march 1.1","username":"Andrew3086","description":"Simple example of ray marching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MIN_DIST 0.01\n#define MAX_DIST 200.0\n\nfloat smin(float a, float b, float k) {\n \tfloat h = max(min(0.5 + 0.5 * (b - a) / k, 1.0), 0.0);\n    return a * h + b * (1.0 - h) - k * h * (1.0 - h);\n}\nfloat box(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.0));\n}\n\nfloat getDist(vec3 p) {\n    //p.xyz = asin(sin(p.xyz));\n    vec4 sphere = vec4(sin(iTime), cos(iTime), -1.0 * sin(iTime), 0.5);\n\tfloat sphereDist = length(p - sphere.xyz) - sphere.w;\n    float planeDist = p.z + 1.0;\n    //return sphereDist;\n    float tmp = smin(sphereDist, planeDist, 0.5);\n    tmp = smin(box(p - vec3(0.0, 0.0, -1.0), vec3(2.0, 2.0, 0.1)), tmp, 0.5);\n    return tmp;\n    //return min(sphereDist, planeDist);\n    //return sphereDist;\n}\n\n\nfloat rayMarch(vec3 r0, vec3 rd) {\n\tfloat d0 = .0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = r0 + d0 * rd;\n        float ds = getDist(p);\n        d0 += ds;\n        if (d0 > MAX_DIST || ds < MIN_DIST) break;\n    }\n\treturn d0;\n}\n\nvec3 getNormal(vec3 p) {\n \tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    return normalize(n);  \n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(5, 5, 20);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float dif = dot(n, l);\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;    //текущий пиксель в координатах [x,y], где y=(-0,5;0.5), а \"x\" - от минус половины отношения разрешения по ширине к разрешению по высоте до плюс половины того же отношения\n\n    float zoom = 1.0;                                              //множитель увеличения изображения\n    \n    vec3 r0 = vec3(5.0 * cos(0.5 * iTime), 5.0 * sin(0.5 * iTime), 2);    //координаты камеры\n    vec3 lookat = vec3(0, 0, 0);                                   //точка, на которую \"смотрит\" камера\n    vec3 f = normalize(lookat - r0);                               //нормализованный вектор, направленный от заданной точки на камеру\n    vec3 r = cross(f, vec3(0.0, 0.0, 1.0));                        //векторное произведение нормали к камере - определяет перпендикулярный к нормали камеры вектор\n \tvec3 u = cross(r, f);                                          //определяет третий перпендикуляр. Тем самым, получаем тройку взаимно перпендикулярных векторов\n    vec3 c = r0 + f * zoom;                                        //вектор, нормальный к камере, пущенный из точки, в  которой камера находилась (и масштабируемый на величину \"зума\")\n\tvec3 i = c + uv.x * r + uv.y * u;                              //вектор (радиус-вектор), который указываает на очередную точку экрана перед камерой для трассеровки луча в этом направлении.\n    \n    vec3 rd = i - r0;                                              //а это уже сам вектор, направленный из камеры на очередной пиксел экрана (причем, каким-то волшебным образом, уже нормализованный)\n    float dist = rayMarch(r0, rd);                                 //вычисление дистанции до ближайшего объекта \n    \n        vec3 p = r0 + rd * dist;                                       //а это точка, в которую уперается очередной луч\n    float dif = getLight(p);                                       //модель освещения, куда же без нее\n    vec3 col = vec3(dif);\n    //vec3 matOne = texture(iChannel0, p.xy).xyz;\n    //matOne *= 1.6 * matOne;\n    //col *= matOne;\n   \n\t\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}