{"ver":"0.1","info":{"id":"Dt2XzW","date":"1675763509","viewed":116,"name":"Image Denoising","username":"etlaM","description":"Fake Image denoising like an image generation AI lol\n\nImplementation idea / help from https://computergraphics.stackexchange.com/a/5112/6628","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","image","fakedenoising"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.283185307179586476925286766559\n\n// this could be using a shadertoy \"channel\" = iChannel0;\n// uniform sampler2D myTexture;\n\n\n// PERLIN NOISE IMPLEMENTATION\n// BY TheTurk\n// https://www.shadertoy.com/view/NlSGDz\n\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float currentTime = iTime;\n    float finishTime = 2.5;\n    uint seed = 0x57dU;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float R = rand(uv.xy);\n    \n    float timeLeft = clamp((finishTime - currentTime) * R, 0.0, finishTime);\n    \n    timeLeft = pow(timeLeft, 2.0);\n\n    // float direction = perlinNoise( R + currentTime + uv.xy, 32 ) * TWO_PI;\n    float direction = perlinNoise( uv.xy, seed ) * TWO_PI * 8.0;\n    float directionNew = perlinNoise( uv.xy, seed ) * 2.0;\n    float offsetX = uv.x + sin(direction) * timeLeft / 500.0;\n    float offsetY = uv.y + cos(direction) * timeLeft / 500.0;\n    //float offsetX = uv.x + directionNew * timeLeft / 5.0;\n    //float offsetY = uv.y + directionNew * timeLeft / 5.0;\n    // offsetY = offsetY + directionNew * abs(distance(iMouse.y, fragCoord.y));\n    \n    vec2 texCoord = vec2( offsetX, offsetY );\n\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    if(abs(distance(texCoord.xy, vec2(0.5, 0.5)) - 1.0) > timeLeft*1.5) color = texture(iChannel0, texCoord);\n    // if(texCoord.x > timeLeft && texCoord.x < abs(timeLeft-1.0) && texCoord.y > timeLeft && texCoord.y < abs(timeLeft-1.0)) color = texture(iChannel0, texCoord);\n    \n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}