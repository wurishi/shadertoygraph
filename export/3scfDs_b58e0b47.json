{"ver":"0.1","info":{"id":"3scfDs","date":"1606392523","viewed":66,"name":"TP1_Mod√©lisation_JV","username":"Guiilaume_duret","description":"TP1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tp1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Texturing\n// Eric Galin\n\nconst float view = 7000.0;  // View distance\nconst float Epsilon = 0.5; // Marching epsilon\n\n// Iterations\nconst int Steps = 256;      // Maximum number of steps when sphere-tracing\nconst float K = 7.0;\t    // Lipschitz constant\n\n// Rendering\nconst float fog = 7000.0;   // Fog attenuation distance\n\n\n\nfloat Terrain(in vec2 x)\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=515.0;   // Initial amplitude\n    \n    float a = -500.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    for( int i=0; i<5; i++ )\n    {\n        float n = -(2.0*(abs(Noise(p))-float(1)));\n        //float n = Noise(p);\n        //float n = abs(Noise(p));\n        //float n = 2.0*Noise(p)-1.0;\n        \n        a += b*n;\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn a;\n}\nfloat Terrain_2(in vec2 x)\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=415.0;   // Initial amplitude\n    \n    float a = -200.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    float noise_high =0.0;\n    for( int i=0; i<10; i++ )\n    {\n        float n = -(2.0*(abs(Noise(p))-float(1)));\n        //float n = Noise(p);\n        //float n = abs(Noise(p));\n        //float n = 2.0*Noise(p)-1.0;\n        \n        a += b*n;\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n        if (i>2){\n            noise_high += b*n;\n        }\n    }\n\treturn noise_high;\n}\n\nbool in_cercle(in vec2 p,in float r, in vec2 c, out float dist){\n    dist = sqrt((p.x-c.x)*(p.x-c.x)+(p.y-c.y)*(p.y-c.y));\n    return dist<r;\n}\n\nbool in_annulus(in vec2 p, in float r_in, in float r_out, in vec2 c, out float dist){\n    dist = sqrt((p.x-c.x)*(p.x-c.x)+(p.y-c.y)*(p.y-c.y));\n    return (dist<=r_out && dist>=r_in);\n}\n\nbool in_rectangle(in vec2 p, in vec2 P1, in vec2 P3) {\n    bool x_ok = (p.x<=P3.x) && (p.x>=P1.x);\n    bool y_ok = (p.y<=P3.y) && (p.y>=P1.x);\n    return x_ok && y_ok;\n}\n\nbool next_to_segment(in vec2 p, in float r, out float dist) {\n    bool x_ok = (p.x<=r) && (p.x>=(-r));\n    dist = sqrt((p.x-0.0)*(p.x-0.0));\n    return x_ok;\n}\n\nbool next_to_segment_y(in vec2 p, in float r, out float dist) {\n    bool y_ok = (p.y<=r) && (p.y>=(-r));\n    dist = sqrt((p.y-0.0)*(p.y-0.0));\n    return y_ok;\n}\n\nfloat Rectangle(in vec2 x)\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=415.0;   // Initial amplitude\n    \n    float a = -200.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0; \n\tvec2 P1 = vec2(-0.5,-0.5);\n    vec2 P2 = vec2(0.5,0.5);\n    \n    \n    if (in_rectangle(p, P1, P2)){\n\n        //g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));  \n        float n = -(2.0*(abs(Noise(p))-float(1)));\n        \n        //float n = 1.5;//Noise(p);\n        //float g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n        //float n = -(2.0*(abs(Noise(p))-float(1)))*g;\n        //float n = 2.0*Noise(p)-1.0;\n\n        a += b*n;\n        b *= 0.5;\n        p = m2*p*2.0;\n\n    } else {\n        float n = 0.0;//Noise(p);\n        //float n = abs(Noise(p));\n        //float n = 2.0*Noise(p)-1.0;\n\n        a += b*n;\n        b *= 0.5;\n        p = m2*p*2.0;\n    }\n\treturn a;\n}\n\n\n\nfloat Montain(in vec2 x, in vec2 c, in float r)\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=2015.0;   // Initial amplitude\n    \n    float a = -200.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    float dist;\n    if (in_cercle( p, r, c, dist)){\n\n            //float n = -(2.0*(abs(Noise(p))-float(1)));\n            //float n = 1.5;//Noise(p);\n        \tfloat g =  (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n            float n = 0.2060-(2.0*(abs(Noise(p))-float(1)))*g;//*g;\n            //float n = 2.0*Noise(p)-1.0;\n\n            a += b*n;\n            b *= 0.5;\n            p = m2*p*2.0;\n\n    } else {\n            float n = 0.2060;//Noise(p);\n            //float n = abs(Noise(p));\n            //float n = 2.0*Noise(p)-1.0;\n\n            a += b*n;\n            b *= 0.5;\n            p = m2*p*2.0;\n    }\n\treturn a;\n}\n\n\n\nfloat Hole(in vec2 x, in vec2 c, in float r)\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=815.0;   // Initial amplitude\n    \n    float a = -200.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    float dist;\n    if (in_cercle( p, r, c, dist)){\n\n            //float n = -(2.0*(abs(Noise(p))-float(1)));\n            //float n = 1.5;//Noise(p);\n        \tfloat g =  -(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n            float n = 0.0-(2.0*(abs(Noise(p))-float(1)))*g;//*g;\n            //float n = 2.0*Noise(p)-1.0;\n\n            a += b*n;\n            b *= 0.5;\n            p = m2*p*2.0;\n\n    } else {\n            float n = 0.0;//Noise(p);\n            //float n = abs(Noise(p));\n            //float n = 2.0*Noise(p)-1.0;\n\n            a += b*n;\n            b *= 0.5;\n            p = m2*p*2.0;\n    }\n\treturn a;\n}\n\nfloat River(in vec2 x, in float r )\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=415.0;   // Initial amplitude\n    \n    float a = -200.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    float dist;\n    if (next_to_segment( p, r, dist)){\n\n            //float n = -(2.0*(abs(Noise(p))-float(1)));\n            //float n = 1.5;//Noise(p);\n        \tfloat g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n            //float n = -(2.0*(abs(Noise(p))-float(1)));//*g;\n        \tfloat n = 1.0 - g;\n            //float n = 2.0*Noise(p)-1.0;\n\n            a += b*n;\n\n    } else {\n            float n = 1.0;//Noise(p);\n            //float n = abs(Noise(p));\n            //float n = 2.0*Noise(p)-1.0;\n\n            a += b*n;\n    }\n\treturn a;\n}\n\n\nfloat Road(in vec2 x, in float r )\n{\n\t// Rotation matrix\n\tconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n    const float l0=1350.0;  // Initial wavelength\n    const float a0=415.0;   // Initial amplitude\n    \n    float a = -200.0;       // Initial height\n    float b = a0;           \n\tvec2  p = x/l0;\n    float dist;\n    if (next_to_segment_y( p, r, dist)){\n\n            //float n = -(2.0*(abs(Noise(p))-float(1)));\n            //float n = 1.5;//Noise(p);\n        \t//float g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n            //float n = -(2.0*(abs(Noise(p))-float(1)));//*g;\n        \tfloat n = 1.0 ;//- g;\n            //float n = 2.0*Noise(p)-1.0;\n\n            a += b*n;\n\n    } else {\n            float n = 1.0;//Noise(p);\n            //float n = abs(Noise(p));\n            //float n = 2.0*Noise(p)-1.0;\n\n            a += b*n;\n    }\n\treturn a;\n}\n\n\n\n\nfloat replacement_disc(in float h1,in float h2, in vec2 p, in vec2 c, in float r)\n{\n    float add_r = 0.5;\n    float dist;\n    p=p/1350.0;\n    if (in_cercle( p, r, c, dist))\n    {\n\n        //float n = -(2.0*(abs(Noise(p))-float(1)));\n        //float n = 1.5;//Noise(p);\n        //float g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n        return h1;\n    }\n    else if (in_annulus( p, r, (r + add_r), c, dist))\n    {\n\n        float g = (1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)));//*(1.0-(dist-0.5)*(dist-0.5)/((r*r)))*(1.0-(dist-0.5)*(dist-0.5)/((r*r)));//* (1.0-(dist-0.5)*(dist-0.5)/((0.5)* (1.0-(dist-0.5)*(dist-0.5)/((0.5);\n        return h1*g+(1.0-g)*h2;\n\n    }\n    return h2;\n}\n\n\n\n\nfloat replacement_droite(in float h1,in float h2, in vec2 p)\n{\n    float r = 0.25;\n    float add_r = 0.75;\n    vec2 c = vec2(0.0,0.0);\n    float dist;\n    p=p/1350.0;\n    if (next_to_segment( p, r, dist))\n    {\n\n        //float n = -(2.0*(abs(Noise(p))-float(1)));\n        //float n = 1.5;//Noise(p);\n        //float g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n        return h1;\n    }\n    else if (next_to_segment( p, r+add_r, dist))\n    {\n\n        float g = (1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)));//*(1.0-(dist-0.5)*(dist-0.5)/((r*r)))*(1.0-(dist-0.5)*(dist-0.5)/((r*r)));//* (1.0-(dist-0.5)*(dist-0.5)/((0.5)* (1.0-(dist-0.5)*(dist-0.5)/((0.5);\n        return h1*g+(1.0-g)*h2;\n\n    }\n    return h2;\n}\n\n\n\n\nfloat replacement(in float h1,in float h2, in int zone, in float g)\n{\n    //float dist;\n    //p=p/1350.0;\n    if (zone==0)\n    {\n\n        //float n = -(2.0*(abs(Noise(p))-float(1)));\n        //float n = 1.5;//Noise(p);\n        //float g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n        return h2;\n    }\n    else if (zone==1)\n    {\n        //float g = (1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)));//*(1.0-(dist-0.5)*(dist-0.5)/((r*r)))*(1.0-(dist-0.5)*(dist-0.5)/((r*r)));//* (1.0-(dist-0.5)*(dist-0.5)/((0.5)* (1.0-(dist-0.5)*(dist-0.5)/((0.5);\n        return h2*g+(1.0-g)*h1;\n    }\n    else if (zone==2)\n    {\n    \treturn h1;\n    }\n}\n\nfloat make_montain(in vec2 c, float r, float add_r,in vec3 p, out int zone, out float g){\n    zone = 2;\n    g=1.0;\n    float dist;\n    if (in_cercle(p.xy/1350.0, r, c, dist))\n    {\n        zone=0;\n        g=0.0;\n    }\n    else if (in_annulus( p.xy/1350.0, r, (r + add_r), c, dist))\n    {\n        zone=1;\n        g=(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)));\n    }\n    \n    return (p.z - Montain( p.xy, c, r));\n}\n\nfloat make_hole(in vec2 c, float r, float add_r,in vec3 p, out int zone, out float g){\n    zone = 2;\n    g=1.0;\n    float dist;\n    if (in_cercle(p.xy/1350.0, r, c, dist))\n    {\n        zone=0;\n        g=0.0;\n    }\n    else if (in_annulus( p.xy/1350.0, r, (r + add_r), c, dist))\n    {\n        zone=1;\n        g=(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)));\n    }\n    \n    return (p.z - Hole( p.xy, c, r));\n}\n\n\n\nfloat make_river(float r, float add_r,in vec3 p, out int zone, out float g){\n    \n    float dist;\n    zone=2;\n    g=1.0;\n    if (next_to_segment( p.xy/1350.0, r, dist))\n    {\n\n        //float n = -(2.0*(abs(Noise(p))-float(1)));\n        //float n = 1.5;//Noise(p);\n        //float g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n        zone=0;\n    }\n    else if (next_to_segment( p.xy/1350.0, r+add_r, dist))\n    {\n\n        g = (1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)));//*(1.0-(dist-0.5)*(dist-0.5)/((r*r)))*(1.0-(dist-0.5)*(dist-0.5)/((r*r)));//* (1.0-(dist-0.5)*(dist-0.5)/((0.5)* (1.0-(dist-0.5)*(dist-0.5)/((0.5);\n        zone = 1;\n\n    }\n\n    \n    return (p.z - River( p.xy, r ));\n    \n    //float h3 = p.z - Rectangle( p.xy );\n    //float h = p.z - (Terrain( p.xy ) + Disc( p.xy ) + Rectangle( p.xy ) );\n    //float h4 = p.z - replacement(Disc( p.xy ,g), Terrain( p.xy ), p.xy);//(Terrain( p.xy ) + Disc( p.xy ) + Rectangle( p.xy ) );\n    //float h_big_montain = addition (h2,1.0,h1,1.0); // add big montain\n    //float h_river_add = addition (h2,1.0,h3,1.0); // add big montain\n    //float new_big_montain = replacement_disc(h1, h2, p.xy);\n    //float new_big_river = replacement(/* de */h2, /*par*/ h3, /*sur*/ zone, g);\n    //float new_big_river = replacement_droite(h3, h2, p.xy);\n    //float test_full = addition (new_big_river,1.0,h1,1.0);\n    \n    \n}\n    \n\nfloat make_road(float r, float add_r,in vec3 p, out int zone, out float g){\n    \n    float dist;\n    zone=2;\n    g=1.0;\n    if (next_to_segment_y( p.xy/1350.0, r, dist))\n    {\n\n        //float n = -(2.0*(abs(Noise(p))-float(1)));\n        //float n = 1.5;//Noise(p);\n        //float g = (1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r))*(1.0-dist*dist/(r*r));\n        zone=0;\n    }\n    else if (next_to_segment_y( p.xy/1350.0, r+add_r, dist))\n    {\n\n        g = (1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)))*(1.0-(dist-r)*(dist-r)/((add_r*add_r)));//*(1.0-(dist-0.5)*(dist-0.5)/((r*r)))*(1.0-(dist-0.5)*(dist-0.5)/((r*r)));//* (1.0-(dist-0.5)*(dist-0.5)/((0.5)* (1.0-(dist-0.5)*(dist-0.5)/((0.5);\n        zone = 1;\n\n    }\n\n    \n    return (p.z - Road( p.xy, r ));\n    \n    //float h3 = p.z - Rectangle( p.xy );\n    //float h = p.z - (Terrain( p.xy ) + Disc( p.xy ) + Rectangle( p.xy ) );\n    //float h4 = p.z - replacement(Disc( p.xy ,g), Terrain( p.xy ), p.xy);//(Terrain( p.xy ) + Disc( p.xy ) + Rectangle( p.xy ) );\n    //float h_big_montain = addition (h2,1.0,h1,1.0); // add big montain\n    //float h_river_add = addition (h2,1.0,h3,1.0); // add big montain\n    //float new_big_montain = replacement_disc(h1, h2, p.xy);\n    //float new_big_river = replacement(/* de */h2, /*par*/ h3, /*sur*/ zone, g);\n    //float new_big_river = replacement_droite(h3, h2, p.xy);\n    //float test_full = addition (new_big_river,1.0,h1,1.0);\n    \n    \n}\n  \n\n\nfloat addition( float h1, float a1, float h2, float a2){\n    return (a1*h1+a2*h2)/(a1+a2);\n}\n\n\nint union_zone (in int zone1,in int zone2){\n    \n    if ((zone1==0) || (zone2==0)){\n        return 0;\n    }\n    else if ((zone1==1) || (zone2==1)){\n        return 1;\n    }\n    else {\n        return 2;\n    }\n}\n/*\nint union_g (in float zone1,in float zone2){\n    \n    if ((zone1==0) || (zone2==0)){\n        return 0;\n    }\n    else if ((zone1==1) || (zone2==1)){\n        return 1;\n    }\n    else {\n        return 2;\n    }\n}\n\n*/\n\n// Implicit surface defining the terrain\n// p : Point\nfloat Implicit(in vec3 p)\n{\t\n\n    \n    float g_montain;\n    int zone_montain;\n    float h1 = make_montain(/*c*/ vec2(0.0,0.0),/*r*/ 1.25, /*add_r*/ 0.75, p, zone_montain, g_montain);\n    \n    float g_hole;\n    int zone_hole;\n    float h11 = make_hole(/*c*/ vec2(0.0,0.0),/*r*/ 0.3, /*add_r*/ 0.5, p, zone_hole, g_hole);\n    float montain_hole = h1+h11;// addition (2.0*h1,1.0,2.0*h11,1.0);\n\n    float h2 = p.z - Terrain( p.xy );\n   \n    int zone_river;\n    float g_river=1.0;\n    float h3 = make_river(/* r */ 0.25, /* r_add */ 0.35, p, zone_river, g_river); \n   \t\n    int zone_road;\n    float g_road=1.0;\n    float h4 = make_road(/* r */ 0.125, /* r_add */ 0.35, p, zone_road, g_road); \n   \t\n    \n    float road_in_noise = replacement(/* de */h2, /*par*/ h4, /*sur*/ zone_road, g_road);\n\n    float river_road_in_noise = replacement(/* de */road_in_noise, /*par*/ h3, /*sur*/ zone_river, g_river);\n\n    float montagne_river_road = replacement(/* de */river_road_in_noise, /*par*/ montain_hole, /*sur*/ zone_montain,g_montain );//min (g_river,g_montain)\n   \n    \n\tfloat h5 = p.z - Terrain_2( p.xy );\n    float test_full2 = h5 + montagne_river_road;// addition (h5,1.0,montagne_river_road,1.0);\n    return road_in_noise;//test_full2\n    \n}\n\n// Sphere tracing\n// ro, rd : Ray origin and direction\n// t : Intersection depth\n// i : Iteration count\nbool Intersect(in vec3 ro, in vec3 rd, out float t,out int i)\n{\n    t = 0.0;\n\tfor( i=0; i<Steps; i++ )\n\t{\n        vec3 p = ro + t*rd;\n\t\tfloat h = Implicit(p);\n        // 1 cm precision at 1 meter range, reduce precision as we get farther from eye\n        if( abs(h)< Epsilon*sqrt(1.0+t) ) { return true; }\n        if( t>view ) { return false; }\n\t\t// Empirical Lipschitz constant with level of detail (the further, the larger steps)\n        t += max(Epsilon,h*sqrt(1.0+8.0*t/view)/K);\n\t}\n\n\treturn false;\n}\n\n// Analysis of the scalar field --------------------------------------------------------------------------\n\n// Calculate object normal\n// p : point\nvec3 Normal(in vec3 p )\n{\n  float eps = 0.01;\n  vec3 n;\n  float v = Implicit(p);\n  n.x = Implicit( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = Implicit( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = Implicit( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return 0.5+mix(vec3(0.05,0.05,0.5),vec3(0.65,0.39,0.65),t);\n}\n\n// Rendering \n// ro, rd : Ray origin and direction\n// pip : Picture in picture boolean\nvec4 Render( in vec3 ro, in vec3 rd, bool pip )\n{\n    // Light direction\n    const vec3 light1 = normalize( vec3(-0.8,-0.3,0.4) );\n   \n\tvec3 col;\n    float t;\n    int it;\n    bool b=Intersect( ro, rd, t , it);\n    if( b==false)\n    {\n        // sky\t\t\n        col = vec3(0.35,0.65,0.95) - rd.z*rd.z*2.5;\n    }\n\telse\n\t{\n        // mountains\t\t\n\t\tvec3 p = ro + t*rd;\n        vec3 n = Normal( p );\n\n        vec3 ref = reflect( rd, n );\n        float fre = clamp( 1.0+dot(rd,n), 0.0, 1.0 );\n        vec3 hal = normalize(light1-rd);\n        \n\n        col=0.5*vec3(0.471,0.361,0.110);\n        \n         // Pseudo diffuse lighting\n\t\tfloat dif = 0.5*(1.0+dot( light1, n ));\n        dif*=dif;\n        \n        col += dif*vec3(0.5);\n\n\t\t// Fog\n        float fo = 1.0-exp(-pow(t/fog,1.5) );\n        vec3 fco = 0.65*vec3(0.4,0.65,1.0);\n        col = mix( col, 0.5*col+0.51*vec3(0.35,0.65,0.95), fo );\n\n\t}\n    \n    // Shading for iterations\n    if (pip==true)\n    {\n    \treturn vec4(ShadeSteps(it),1.0);\n    }\n    else\n    {\n    // Gamma with square root\n       return vec4( sqrt(col), t );\n    }\n\n}\n\nmat3 moveCamera(float time, out vec3 ro)\n{\n\t// Origin\n    ro =  vec3(3000.0*cos(iMouse.x*0.01),3000.0*sin(iMouse.x*0.01),1500.0) ;\n\t\n    // Target\n    vec3 ta = vec3(0.0,0.0,500.0);\n    \n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 0.0,1.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec2 RayDirection(in vec2 pixel, out bool pip)\n{\n    // Pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*pixel)/iResolution.y;\n   if (pip==true)\n   {    \n    const float fraction=1.0/4.0;\n    // Picture in picture\n    if ((pixel.x<iResolution.x*fraction) && (pixel.y<iResolution.y*fraction))\n    {\n        p=(-iResolution.xy*fraction + 2.0*pixel)/(iResolution.y*fraction);\n        pip=true;\n    }\n       else\n       {\n           pip=false;\n       }\n   }\n   return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Time as function of the position of the mouse\n    float time = iTime*0.25 + 4.0*iMouse.x/iResolution.x;\n\n    // Camera transform\n    vec3 ro; \n    mat3 cam = moveCamera( time, ro);   \n\n    // Picture in picture\n    bool pip=true;\n    \n    // Pixel coordinates\n    vec2 p = RayDirection(fragCoord, pip);\n   \n    // Camera ray    \n    vec3 rd = cam * normalize(vec3(p,3.0));\n    \n    // Render\n    vec4 res = Render( ro, rd, pip );\n     \n    fragColor = vec4( res.xyz, 0.0 );\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Texturing\n// Eric Galin\n\n// Texturing and noise ---------------------------------------------------------\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in the plane\nfloat Hash(in vec2 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\n// Procedural value noise with cubic interpolation\n// x : Point \nfloat Noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix( Hash(i+vec2(0,0)), \n                        Hash(i+vec2(1,0)),f.x),\n                   mix( Hash(i+vec2(0,1)), \n                        Hash(i+vec2(1,1)),f.x),f.y);\n}\n","name":"Common","description":"","type":"common"}]}