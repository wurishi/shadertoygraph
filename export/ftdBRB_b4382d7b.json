{"ver":"0.1","info":{"id":"ftdBRB","date":"1663325704","viewed":278,"name":"Purple Rain (sound)","username":"grom12345","description":"This is an entry for #WCCChallenge and was broadly inspired by the works of Matthew Barney from the late 90s.\nIt contains a generative sound!\nUse your mouse on the liquid!","likes":8,"published":1,"flags":40,"usePreview":0,"tags":["3d","raymarching","waves","ripples","sdf","water","liquid","splash","cellularautomata"],"hasliked":0,"parentid":"7lcBzS","parentname":"Color rain"},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 lighting( vec3 p, vec3 rd, vec3 n, Material m) {\n\n  vec3 lightPos = vec3(5., 3, -2.);\n  \n  //mat2 rot = Rot(iTime*rt*.5-pi*0.5);\n  //lightPos.xz *= rot;\n  vec3 ld = (lightPos - p);\n  float lDist = length(ld);\n  vec3 l = normalize(ld);\n  //vec3 n = normal(p);\n\n  float diff = dot(l, n);\n  vec3 col = vec3(.5);//m.color.rgb;//colorMap(diff*0.2);\n  \n   Dist dist = raymarch(p+SURF_DIST*10.*n, l, 1.,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, 1., iTime);\n   if(lDist>dist.d&&m.bump!=4) col*=.5;\n  \n  diff = mix(diff*0.5+0.5, max(diff, 0.), 0.9);\n  float spec = pow(clamp(diff, 0., 1.), m.specPow);\n  float frensel = pow(1. + dot(rd, n), 4.)*m.fren;\n  \n  return m.color.rgb*col*diff+spec*m.spec+frensel;\n}\nvec3 getPixel(vec3 ro, vec3 rd, vec2 uv){\n    float aspect = iResolution.y/iResolution.x;\n    bool infinity = true;\n    float dd = 1.;//\n    float inD = 1.;//inside body coeff\n    float dir = 1.;\n    vec3 p=ro;\n    int i;\n    vec3 col = vec3(0);\n    vec3 oldRd = rd;\n    for (i = 0; i < transpIter; i++) {\n        Dist dist = raymarch(p, rd, dir,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime);\n        Material m = dist.m;\n        float d = dist.d;\n        p += d * rd;\n        dd += d;\n        if(dd-1.<MAX_DIST){\n           vec3 n = normal(p, \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, false)*dir;\n           /*if(m.color.a==0.){\n\n               rd = dir==1. ? refract(rd, n, m.refr) : refract(rd, n, 1.-m.refr);\n               col += lighting(p, rd, n, m)/inD;\n               if (dir<0.){\n                 inD+=d;\n                 col -= m.absorb*pow((inD-1.), 0.1)*.3;\n               }\n               dir *= -1.;\n               p-=SURF_DIST*4.*n;\n           }else{*/\n                col += lighting(p, rd, n, m)/inD+(dist.d*.03);\n                infinity = false;\n                break;\n          // }\n          \n        }else break;\n    }\n    \n    if(i>0){\n      if(infinity){\n          float a = atan(oldRd.x, oldRd.z);\n          rd.xz *= Rot(a);\n          rd*=-.5;\n          col += texture(iChannel1, uv*.5+.5+rd.xy).rgb/inD;\n      }\n    }else if (col == vec3(0)) col += texture(iChannel1, uv*.5+.5).rgb;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    Camera cam = getCamera(fragCoord, iResolution, iTime);\n    vec3 ro = cam.ro;\n    vec3 rd = cam.rd;\n\n    vec3 col = getPixel(ro, rd, uv);\n\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}\n/*void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=texPart;\n \n    vec3 col;\n    vec4 c = texture(iChannel3, uv);\n    col+=c.rgb;\n    float a = clamp(1.-(iTime+20.-c.a)*fadeSpeed, 0., 1.);\n    col=mix(vec3(1), col, a);\n    col = pow(abs(col), vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}*/","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvec4 fetch(ivec2 c){\n    //ivec2 size = ivec2(iResolution.xy*texPart);\n    ivec2 coord = c;//ivec2((c+size)%size);\n    return texelFetch(iChannel1, coord, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n     vec4 color1 = vec4(0);\n    float count = 0.;\n    int u = 1;\n    int sx = 1;\n    int sy = 1;\n    vec4 c0 = fetch(ivec2(fragCoord));\n    for (int x = -u*sx; x <= u*sx ; x+=u){\n        for (int y = -u*sy; y <= u*sy ; y+=u){\n            if(x==0&&y==0) continue;\n            vec4 c = fetch(ivec2(fragCoord)+ivec2(x, y));\n\n            if(c0.a<c.a+(abs(float(y))+abs(float(x)))&&hash1(vec2(iTime*.1, length(fragCoord))).x>.7){\n                //float a = 1.+hash1(vec2(iTime*.1, length(fragCoord))).x*.001;\n                //c.xyz*=a;\n                color1 += c;\n                count += 1.;//*a;\n            }\n        }\n    }\n\nif(count>0.){\n    color1 /=count;\n    //color1.y+=0.01;\n   // color1.r += (hash1(fragCoord*10.+iTime).x-.5)*2.+.05;\n    //color1.g += (hash1(fragCoord*10.+iTime).y-.5)*2.+.05;\n    //color1.b += (hash1(fragCoord*38.+iTime).x-.5)*2.+.05;\n    //color1.rgb = mix(c0, color1+hash(fragCoord*.1).x*.1, .5).rgb;\n}else{\n    color1 = c0;\n}\nfloat aspect = iResolution.y/iResolution.x;\n    vec3 col = color1.rgb;\n    bool spot = false;\n    for (int id=0; id<particlesCount;id++){\n         vec4 collis = texelFetch(iChannel0, ivec2(id,2), 0);\n    \n        if(int(collis.x)==1){\n            Particle p = readParticle(iChannel0, id);\n            vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n            vec2 mUV = collis.yz*texPart*.25*vec2(aspect,1);\n\n            float dst = length(uv - mUV);  \n            if(dst <= p.size*.1) {\n                float hue =(sin(iTime*5.)*.5+.5)*.5+.5;\n                col = p.col;\n                spot = true;\n            }\n        }\n    }\n   \n\nif(iMouse.z > 0.0) {\n   vec2 m = iMouse.xy;//*vec2(1,aspect);\n    \n    Camera camera = getCamera(m, iResolution, iTime);\n    Dist dist = raymarch(camera.ro, camera.rd, 1.,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime);\n         if(dist.object==1){\n            vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n            vec2 mUV = dist.spotUV*texPart*.25*vec2(aspect,1);\n\n            float dst = length(uv - mUV);  \n            if(dst <= spotSize*.1) {\n                float hue =(sin(iTime*5.)*.5+.5)*.5+.5;\n\n                col = HSVtoRGB(vec3(hue, 1., 1.));\n                spot = true;\n            }\n          }\n}\n    if(spot)color1=vec4(col, iTime+1./fadeSpeed);\n    fragColor = color1;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//raymarch\n#define transpIter 5\n#define MAX_STEPS 1000\n#define MAX_DIST 20.0\n#define SURF_DIST 0.01\n//#define K_Dist 0.5\n\n//color spots\n#define texPart 1.\n#define fadeSpeed .005\n#define spotSize .01\n\n//particles\n#define particlesCount 3\n\n#define pi 3.1415926535\n\n//#define GLSL_BUG\n\n#define pn 100000.\nvec2 pack(vec3 p){\n    p.x*=.01;\n    //p.xy+=1.;\n    float y= p.z;\n    float tp = p.y*pn;\n    float x= p.x+floor(tp);\n    return vec2(x,y);\n}\nvec3 unpack(vec2 p){\n    float x = fract(p.x);\n    float y = floor(p.x)/pn;\n    //vec2 xy = vec2(x,y);\n    //xy-=1.;\n    x/=.01;\n    return vec3(vec2(x,y), p.y);\n}\n\nstruct Particle{\n   vec3 coord;\n   vec3 col;\n   float size;\n   //int obj;//contact object\n   //vec2 uv;//contact uv\n};\n\nParticle readParticle(sampler2D s, int id){\n    vec3 coord = unpack(texelFetch(s, ivec2(id,0), 0).xy);\n    vec4 colS = texelFetch(s, ivec2(id,1), 0);\n    vec3 col = colS.rgb;\n    float size = colS.w;\n    return Particle(coord, col, size);\n}\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nvec2 hash1( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\nfloat curve(vec2 p){\n    return sdHexagram(p, .5);\n}\n\nvec2 N(float angle) {\n\n   return vec2(sin(angle), cos(angle));\n}\n\nmat2 Rot(float a){\n    vec2 sc = N(a);\n    return mat2(sc.y, -sc.x, sc.x, sc.y);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nstruct Material{\n   float refr;\n   vec4 color;\n   vec3 absorb;\n   float specPow;\n   float spec;\n   float fren;\n   int bump;\n   float bDist;\n   float bFactor;\n};\n\nstruct Dist{\n   Material m;\n   float d;\n   vec2 uv;\n   vec2 spotUV;\n   int object;\n};\n\nconst Material materials[]=Material[5](\n   Material(//0: glass\n    .7,\n    vec4(1., 1., 1., 0),\n    vec3(.7, .2, .0),\n    200.,\n    1.,\n    100.,\n    3,\n    .5,\n    .5),\n    Material(//1: milk\n    0.,\n    vec4(1, 1, 1, 1),\n    vec3(1, 1, 1),\n    .1,\n    .3,\n    .01,\n    0,\n    .2,\n    .2),\n    Material(//2: gravel\n    0.,\n    vec4(.5, .5, .5, 1)*2.,\n    vec3(1, 1, 1),\n    2.,\n    .001,\n    .01,\n    2,\n    .05,\n    .05),\n    Material(//3: flat white\n    0.,\n    vec4(1, 1, 1, 1),\n    vec3(1, 1, 1),\n    2.,\n    .0,\n    .0,\n    4,\n    .0,\n    .0),\n    Material(//4: particle\n    0.,\n    vec4(1, 1, 1, 1),\n    vec3(1, 1, 1),\n    .1,\n    .3,\n    .01,\n    4,\n    .2,\n    .2)\n);\n\nDist scenePure(vec3 p, \n               sampler2D iChannel0,\n               sampler2D iChannel1,\n               sampler2D iChannel2,\n               sampler2D iChannel3,\n               float aspect,\n               float iTime,\n               bool pCollision){\n               \n   float plane = p.y+1.1;\n   float sphere = abs(sdSphere(p, 10.))-0.1;\n \n   float d = 100000.;\n   float particles[particlesCount];\n   vec3 particlesCol[particlesCount];\n   if(!pCollision){\n       for (int id=0; id<particlesCount;id++){\n            Particle pp = readParticle(iChannel1, id);\n            particles[id] = sdSphere(p-pp.coord, pp.size);\n            particlesCol[id] = pp.col;\n            d = min(d, particles[id]);\n       }\n   }\n   \n   //float d = box;\n   d = min(d, sphere);\n   d = min(d, plane);\n   \n   //returning Dist\n   //particles\n   if(!pCollision){\n       for (int id=0; id<particlesCount;id++){\n            if(d==particles[id]){\n                Material m = materials[4];\n                m.color.rgb = particlesCol[id];\n                return Dist(m, particles[id], vec2(0), vec2(0), 0);\n            }\n       }\n   }\n   //plane\n   if(d==plane){\n       vec2 uv = p.xz;\n       vec2 spotUV=uv*.2;\n       Material m;// = materials[2];\n       vec4 c = texture(iChannel3, (uv*vec2(aspect, 1))*.05+.5);\n       float a = clamp(1.-(iTime+1./fadeSpeed-c.a)*fadeSpeed, 0., 1.);\n       vec3 col = c.rgb;\n       m = materials[1];\n       m.color.rgb = mix(m.color.rgb, col, a);\n       return Dist(m, plane, (uv*vec2(aspect, 1))*.05+.5, spotUV, 1);\n   }\n   //sphere\n   if(d==sphere){\n       Material m = materials[3];\n       vec2 uv = p.xz*.005;\n       vec4 c = texture(iChannel3, (uv*vec2(aspect, 1))*.05+.5);\n       float a = clamp(1.-(iTime+1./fadeSpeed-c.a)*fadeSpeed, 0., 1.);\n       vec3 col = c.rgb;\n        m.color.rgb = mix(m.color.rgb, col, a/5.);\n       //m.color = vec4(vec3(clamp(p.y*.2+.5, 0., 1.)),1);\n       return Dist(m, sphere, vec2(0), vec2(0), 2);\n   }\n}\n\nfloat getBump(vec3 p, vec3 n, int bmp, vec2 uv,\n              sampler2D iChannel0,\n              sampler2D iChannel1,\n              sampler2D iChannel2,\n              sampler2D iChannel3,\n              float iTime){\n    \n     vec4 tx1Var = vec4(0.9, 1.3, 0.65, -0.66);\n     vec4 tx2Var = vec4(0.8, 1.2, 0.85, -0.45);\n     float b;\n     switch(bmp){\n     case 0: {\n         b = 1.*texture(iChannel2,uv).r;\n         break;\n       }\n     case 2: {\n         b = 1.*texture(iChannel2,uv).r-.5;\n         break;\n       }\n       case 3: {\n         /* p = p*.1+.5;\n \n         mat3 uvm = mat3(vec3(p.xy, 0), vec3(p.yz,0), vec3(p.xz,0));\n         vec3 bb = -.5*vec3(texture(iChannel0,uvm[0].xy).r,\n                texture(iChannel0,uvm[1].xy*tx2Var.x+tx2Var.z).r,\n                texture(iChannel0,uvm[2].xy*tx1Var.y+tx1Var.w).r)-.2;\n         n=abs(n);\n         b=dot(bb, n.zxy)*.5;*/\n         b=.2-length(texture(iChannel3,uv*texPart).rgb)*.1;\n         break;\n       }\n       case 4:{\n         b=0.;\n       }\n     }\n     \n     return  b;\n}\n\nvec3 pureNormal(vec3 p, \n                sampler2D iChannel0,\n                sampler2D iChannel1,\n                sampler2D iChannel2,\n                sampler2D iChannel3,\n                float aspect,\n                float iTime,\n                bool pCollision){\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n#ifdef GLSL_BUG\n  return normalize(scenePure(p, \n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,aspect,iTime, pCollision).d-vec3(scenePure(k[0], \n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,aspect,iTime, pCollision).d,scenePure(k[1], \n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,aspect,iTime, pCollision).d,scenePure(k[2], \n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,aspect,iTime, pCollision).d));\n  \n}\n\n#else\nfloat d1 = scenePure(k[0], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d;\nfloat d2 = scenePure(k[1], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d;\nfloat d3 = scenePure(k[2], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d;\n\nreturn normalize(scenePure(p,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d-vec3(d1,d2,d3));\n}\n  \n#endif\n\nDist scene(vec3 p,\n           sampler2D iChannel0,\n           sampler2D iChannel1,\n           sampler2D iChannel2,\n           sampler2D iChannel3,\n           float aspect,\n           float iTime,\n           bool pCollision){\n   Dist dist = scenePure(p, \n                         iChannel0,\n                         iChannel1,\n                         iChannel2,\n                         iChannel3,\n                         aspect,\n                         iTime, pCollision);\n   float d = dist.d;\n   Material m = dist.m;\n   int bmp = m.bump;\n   vec2 uv = dist.uv;\n   vec2 spotUV= dist.spotUV;\n   int object = dist.object;\n\n   if (d<m.bDist){\n      vec3 n = pureNormal(p, \n      iChannel0,\n                         iChannel1,\n                         iChannel2,\n                         iChannel3, aspect, iTime, pCollision);//good and accurate\n      //vec3 n = normalize (p);//cheap and dirty\n      float bump = getBump(p,n, bmp, dist.uv,\n                           iChannel0,\n                           iChannel1,\n                           iChannel2,\n                           iChannel3,\n                           iTime);\n      d-=bump*m.bFactor;\n   }\n   return Dist(m, d, uv, spotUV, object);\n}\n\nDist raymarch(vec3 ro, vec3 rd, float dir,\n              sampler2D iChannel0,\n              sampler2D iChannel1,\n              sampler2D iChannel2,\n              sampler2D iChannel3,\n              float aspect,\n              float iTime){\n    float d0 = 0.0;\n    vec3 p = ro;\n    Dist dist;\n    //Material m;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        dist = scene(p, \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, false);\n        float dS = dist.d*dir;\n        d0 += dS;  \n        p = ro + d0 * rd;\n        if ( abs(dS) <= SURF_DIST || d0 >= MAX_DIST ) {\n            //m = dist.m;\n            break;\n        }\n    }\n    return Dist(dist.m, d0, dist.uv, dist.spotUV, dist.object);\n}\n\nvec3 normal(vec3 p, sampler2D iChannel0,\n                    sampler2D iChannel1,\n                    sampler2D iChannel2,\n                    sampler2D iChannel3,\n                    float aspect,\n                    float iTime,\n                    bool pCollision){\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n#ifdef GLSL_BUG\nreturn normalize(scene(p,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect\n  , iTime, pCollision).d-vec3(scene(k[0], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d,\n                  scene(k[1], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d,\n  scene(k[2],\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect,\n  iTime, pCollision).d));\n}\n#else\nfloat d1 = scene(k[0], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d;\nfloat d2 = scene(k[1], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d;\nfloat d3 = scene(k[2], \n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d;\n\nreturn normalize(scene(p,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3, aspect, iTime, pCollision).d-vec3(d1,d2,d3));\n}\n#endif\n\nstruct Camera{\n    vec3 ro;\n    vec3 rd;\n};\n\nCamera getCamera(vec2 fragCoord, vec3 iResolution, float iTime){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float time = iTime*0.1+1.6;\n    float n = (cos(time*2.))*.5;\n    mat2 nn = Rot(time);\n    mat2 nn1 = Rot(pi*.1+n);\n    vec3 ro = vec3(0., .0, -4.5+0.*cos(time));\n    ro.yz *= nn1;\n    ro.xz *= nn;\n    \n    \n    vec3 rd = vec3(uv, 1.);\n    rd.yz *= nn1;\n    rd.xz *= nn;\n    \n    rd = normalize(rd);\n    return Camera(ro, rd);\n}\n\nvec3 Hue(float H)\n{\n    float R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\nvec3 HSVtoRGB(in vec3 HSV)\n{\n    return vec3(((Hue(HSV.x) - 1.) * HSV.y + 1.) * HSV.z);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{     \n    float aspect = iResolution.y/iResolution.x;\n    fragColor = vec4(0);\n    if(fc.x<float(particlesCount)+.5){\n        if(fc.y==.5){//coord\n            vec4 pp = texelFetch(iChannel1, ivec2(fc), 0);\n            vec3 p=unpack(pp.xy);\n            vec3 prevP=unpack(pp.zw);\n            \n            p.y-=.05;\n            p.x+=.01;\n            if(p.y<-1.5){\n                vec2 h = hash(fc+iTime*.1)*3.;\n                p = vec3(h.x,2.5,h.y);\n            }\n            \n            if(iFrame==0){\n                vec2 h = hash(fc+iTime*.1)*5.;\n                p = vec3(h.x,2.5+1.5*fc.x,h.y);\n                prevP=p;\n            }\n            fragColor = vec4(pack(p),pack(prevP));\n        }\n        if(fc.y==1.5){//color, size\n            vec4 c = texelFetch(iChannel1, ivec2(fc), 0);\n            fragColor = c;\n            vec3 p = unpack(texelFetch(iChannel1, ivec2(fc.x,0), 0).xy);\n            \n            if(iFrame==0||p.y==2.5){\n                vec2 h = hash(fc+iTime*.1);\n                float size = (2.+h.x*1.5)*.01;\n                float hue = fract(abs(h.y));\n                vec3 col = HSVtoRGB(vec3(hue, 1., 1.)); \n                fragColor = vec4(col, size);\n            }\n        }\n        if(fc.y==2.5){//collision\n            fragColor = vec4(-1, 0, 0, 0);\n            vec3 p = unpack(texelFetch(iChannel1, ivec2(fc.x,0), 0).xy);\n            Dist dist = scene(p,\n                               iChannel0,\n                               iChannel1,\n                               iChannel2,\n                               iChannel3,\n                               aspect,\n                               iTime, true);\n            if(dist.d<.05){\n                fragColor=vec4(float(dist.object), dist.spotUV, 0.);\n                //fragColor=vec4(1, vec2(0), 0.);\n            }\n            /*if(iFrame==0){\n                fragColor = vec4(-1, 0, 0, 0);\n            }*/\n        }\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec4 fetch(ivec2 c){\n    //ivec2 size = ivec2(iResolution.xy*texPart);\n    if(c.x<0||c.x>int(iResolution.x*texPart)) return vec4(0);\n    if(c.y<0||c.y>int(iResolution.y*texPart)) return vec4(0);\n    ivec2 coord = c;//ivec2((c+size)%size);\n    return texelFetch(iChannel0, coord, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    float value=0.;\n    float count = 0.;\n    int u = 1;\n    int sx = 1;\n    int sy = 1;\n    vec4 c0 = fetch(ivec2(fragCoord));\n    for (int x = -u*sx; x <= u*sx ; x+=u){\n        for (int y = -u*sy; y <= u*sy ; y+=u){\n            if(x==0&&y==0) continue;\n            vec4 c = fetch(ivec2(fragCoord)+ivec2(x, y));\n            float l = 1./length(vec2(x, y));\n            value += c.x*l;\n            count += l;\n        }\n    }\n\n//if(count>0.){\n    value /=count;\n    //value*=2.;\n\n    float speed = c0.x-c0.y;\n    float force = (value-c0.x)*2.;\n    //force=sign(force)*pow(abs(force), 1.);\n    speed+=force;\n    speed*= 1./(1.+abs(speed));\n    value=c0.x+speed;\n    //value*=.95;\n    //color1.y+=0.01;\n   // color1.r += (hash1(fragCoord*10.+iTime).x-.5)*2.+.05;\n    //color1.g += (hash1(fragCoord*10.+iTime).y-.5)*2.+.05;\n    //color1.b += (hash1(fragCoord*38.+iTime).x-.5)*2.+.05;\n    //color1.rgb = mix(c0, color1+hash(fragCoord*.1).x*.1, .5).rgb;\n//}   \nfragColor = vec4(value, c0.x, 1, 1.);\nfloat aspect = iResolution.y/iResolution.x;\n//bool spot = false;\n    for (int id=0; id<particlesCount;id++){\n         vec4 collis = texelFetch(iChannel1, ivec2(id,2), 0);\n    \n        if(int(collis.x)==1){\n            Particle p = readParticle(iChannel1, id);\n            vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n            vec2 mUV = collis.yz*texPart*.25*vec2(aspect,1);\n\n            float dst = length(uv - mUV);  \n            if(dst <= p.size*.1) {\n                fragColor=vec4(-1);\n            }\n        }\n    }\n   //if(spot)color1=vec4(col, iTime+1./fadeSpeed);\nif(iMouse.z>0.){\n    Camera camera = getCamera(iMouse.xy, iResolution, iTime);\n    Dist dist = raymarch(camera.ro, camera.rd, 1.,\n                     iChannel0,\n                     iChannel1,\n                     iChannel2,\n                     iChannel3,  aspect,\n    iTime);\n        if(dist.object==1){\n            vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xy;\n            vec2 mUV = dist.spotUV*texPart*.25*vec2(aspect,1);\n\n            float dst = length(uv - mUV);  \n            if(dst <= spotSize*.1) {\n                fragColor=vec4(-.5);\n        }\n    }\n}\n    \n    fragColor=clamp(fragColor, -.9, .9);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float tone(float time, float freq, float speed){\n    float vol = 1.+sin(time*speed);\n    float vol1 = 1.+sin(time*speed*.287+59.);\n    float noise = hash(vec2(time)).x*(sin(time));\n    return sin(2.*pi*time*freq)*vol+noise*vol1*.5;\n}\n\nfloat sound(float time )\n{\n    float tone1 = tone(time, 200., 1.23);\n    float tone2 = tone(time, 20., .61233);\n    float tone3 = tone(time, 30., .4123);\n    float tone4 = mix(tone1, tone2, tone3*.5+.5);\n    float noise = hash(vec2(time)).x*(sin(time));\n    float tone5 = sign(tone4)*pow(abs(tone4), 2.)*.1;\n    float toneS = tone(time, 50., 10.1);\n    toneS = sign(toneS)*pow(abs(toneS), 3.);\n    float toneS1 = tone(time, 25., 23.38);\n    toneS1 = sign(toneS1)*pow(abs(toneS1), 2.);\n    return toneS*.001+toneS1*.001+noise*.003+tone5*.3;\n}\n\nvec2 mainSound( int samp, float time ){\n    vec2 s1= sound(time+.1)*vec2(1,.5);\n    vec2 s2= sound(time+.5)*vec2(.5,1);\n    vec2 s3= sound(time+.3)*vec2(1,.3);\n    vec2 s4= sound(time+.6)*vec2(.3,1);\n    vec2 s5= sound(time)*vec2(1,1);\n    return (s1+s2+s3+s4+s5);\n}","name":"Sound","description":"","type":"sound"}]}