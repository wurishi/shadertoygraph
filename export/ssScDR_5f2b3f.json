{"ver":"0.1","info":{"id":"ssScDR","date":"1643320203","viewed":112,"name":"Implicit Béziér \"S\" (tech demo)","username":"stegu","description":"One character from my rather elaborate Béziér text rendering demo, show in isolation to make it easier to understand the code. *Somewhat* easier. Pardon the mess, but this code has roots in an old 2006 demo for RenderMan SL.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["bezier","text","implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float aastep(float threshold, float value) {\n\tfloat afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n\treturn smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// Anti-aliased implicit line around v == t, in the spirit of\n// aastep(), with line width w specified in fragment space (pixels)\nfloat aaline(float t, float v, float w) {\n  float fw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n  return smoothstep(t-0.5*w*fw-fw, t-0.5*w*fw+fw, v)\n\t- smoothstep(t+0.5*w*fw-fw, t+0.5*w*fw+fw, v);\n}\n\n\nfloat cubic(float Pc[10], vec2 xy) {\n\tfloat x = xy.x;\n\tfloat y = xy.y;\n\treturn ((Pc[0]*x + Pc[1]*y + Pc[4])*x + Pc[7])*x + Pc[9]\n\t\t+ ((Pc[2]*x + Pc[3]*y + Pc[6])*y + Pc[5]*x + Pc[8])*y;\n//\tThe expression above is an optimized version of this:\n//  return Pc[0]*x*x*x + Pc[1]*x*x*y + Pc[2]*x*y*y + Pc[3]*y*y*y\n//\t+ Pc[4]*x*x + Pc[5]*x*y + Pc[6]*y*y + Pc[7]*x + Pc[8]*y + Pc[9];\n}\n\nfloat gradmag(float Pc[10], vec2 xy) {\n\tfloat x = xy.x;\n\tfloat y = xy.y;\n\tfloat gx = (3.0*Pc[0]*x + 2.0*Pc[1]*y + 2.0*Pc[4])*x\n\t\t+ (Pc[2]*y + Pc[5])*y + Pc[7];\n\tfloat gy = (Pc[1]*x + Pc[5])*x + Pc[8]\n\t\t+ (2.0*Pc[2]*x + 3.0*Pc[3]*y + 2.0*Pc[6])*y;\n//  The expressions above are optimized versions of these:\n//\tfloat gx = 3.0*Pc[0]*x*x + 2.0*Pc[1]*x*y + Pc[2]*y*y + 2.0*Pc[4]*x + Pc[5]*y + Pc[7];\n//\tfloat gy = Pc[1]*x*x + 2.0*Pc[2]*x*y + 3.0*Pc[3]*y*y + Pc[5]*x + 2.0*Pc[6]*y + Pc[8];\n\treturn sqrt(gx*gx + gy*gy);\n}\n\nfloat implicitS(vec2 xy, float aaw) {\n\nfloat Sc1a[10] = float[]( // Outer contour for upper left part of S\n-1.560896e+000, -1.07661456e+002, -2.475285372e+003,\n-1.8970074963e+004, -4.203757925723708e+005, -1.008869191772405e+005,\n-7.395343386686108e+005, 1.021959972815947e+007, 4.231012854331020e+007,\n1.619176102444687e+009\n);\nfloat Sc1b[10] = float[]( // Inner contour for upper left part of S\n1.2812904e+001, 2.37531528e+002, 1.467823032e+003,\n3.023464536e+003, 1.205445041712036e+004, -6.328299537503940e+004,\n-7.180880134607939e+004, 3.392372672377217e+005, -1.514004847128142e+006,\n2.064460489533454e+006\n);\nfloat Sc2a[10] = float[]( // Outer contour for upper right part of S\n-3.73248e-001, -5.7822336e+001, -2.985881184e+003,\n-5.1395862232e+004, -2.631670560009098e+000, 3.699543764663996e+005,\n7.819825232895721e+006, -1.079471991752684e+007, -3.985480538763968e+008,\n6.793959228746701e+009\n);\nfloat Sc2b[10] = float[]( // Inner contour for upper right part of S\n2.352637e+000, -5.7206226e+001, 4.63671516e+002,\n-1.252726552e+003, -1.846763602109960e+003, -6.592559436540401e+003,\n1.285963272360889e+005, -3.864184150032301e+005, -7.438671069995483e+006,\n1.621462796641338e+008\n);\nfloat Sc3a[10] = float[]( // Outer contour for middle left part of S\n5.053029696e+003, -4.1183958816e+004, 1.11887888112e+005,\n-1.01325045528e+005, -3.5722167794334e+005, -9.000108087994801e+005,\n5.756484950751777e+006, 1.383060896290501e+007, 2.711575485516367e+008,\n1.126225316211760e+009\n);\nfloat Sc3b[10] = float[]( // Inner contour for middle left part of S\n3.84240583e+002, -2.440218393e+003, 5.165744301e+003,\n-3.645153819e+003, 1.73990343969e+004, -3.924885612033014e+004,\n4.897977973740215e+003, 1.641019444597991e+006, 1.507638564822112e+007,\n-1.138439458260446e+008\n);\nfloat Sc4a[10] = float[]( // Outer contour for middle right part of S\n-6.612913133e+003, 4.3989788694e+004, -9.7541555964e+004,\n7.2095179528e+004, -3.900824717933405e+005, 1.178804479406984e+005,\n1.696167582980258e+006, -4.879382691530628e+007, -5.122662213495559e+008,\n3.782558913476014e+009\n);\nfloat Sc4b[10] = float[]( // Inner contour for middle right part of S\n-2.509911279e+003, 1.1452509081e+004, -1.7418937653e+004,\n8.831234763e+003, 1.364069703129298e+005, -9.938912235713974e+004,\n-1.704812004398699e+005, -8.481654673763756e+006, -6.854711509977910e+007,\n-3.141699222699289e+008\n);\nfloat Sc5a[10] = float[]( // Outer contour for lower left part of S\n-1.1089567e+001, 1.40534154e+002, -5.93646516e+002,\n8.35896888e+002, 2.227940722530032e+003, -3.338964917802015e+004,\n9.913940441721011e+004, -2.470532821691856e+005, 6.859080825118593e+006,\n1.916457264647791e+008\n);\nfloat Sc5b[10] = float[]( // Inner contour for lower left part of S\n-1.0e+000, 8.271e+001, -2.2803147e+003,\n2.0956092093e+004, -1.640258734248e+004, 4.888192197095951e+004,\n2.539159491029130e+006, 5.028775045349196e+006, 1.189107392873075e+008,\n1.992721536814904e+009\n);\nfloat Sc6a[10] = float[]( // Outer contour for lower right part of S\n1.194389981e+003, 5.50477569e+003, 8.4569127e+003,\n4.330747e+003, 5.079518640874504e+005, 2.042561801719503e+006,\n1.952816523506253e+006, 7.791598981763187e+007, -6.508484938309293e+007,\n-7.029013111518749e+009\n);\nfloat Sc6b[10] = float[]( // Inner contour for lower right part of S\n8.615125e+000, 1.89490725e+002, 1.389290535e+003,\n3.395290527e+003, -2.161032396471031e+004, 2.697558897572927e+004,\n8.647800264089205e+003, -9.382476414227656e+005, -3.404335509997699e+006,\n3.871235795097654e+007\n);\n\n// Thresholds for partitioning lines and linear outlines.\n// There are six rectangular regions, each with their own set of\n// implicit functions, bounded by the lines x=0, y=Sy1 and y=Sy2\n// \n#define Sy1 -20.72\n#define Sy2 21.78\n#define Sx0 -60.34\n#define Sx1 57.13\n\n// A less convenient aastep, using a separately computed step width to\n// cope with if-else-inflicted discontinuities in local coordinates\n#define AASTEP(a,x,w) smoothstep((a-0.5*w),(a+0.5*w),(x))\n\n// AA'd threshold of an implicit cubic polynomial, with the\n// polynomial normalized to have a unit length gradient near 0.0\n#define AACUBIC(Pc,xy,w) AASTEP(0.0, cubic(Pc,xy)/gradmag(Pc,xy), w)\n\n    float pattern;\n    float mask1, mask2;\n\n    // Draw a single character, an \"S\" originally taken from an EPS file\n\tif(xy.x < 0.0) { // left half\n\t\tif(xy.y < Sy1) { // bottom left part\n\t\t\tmask1 = min(AACUBIC(Sc5a, xy, aaw), 1.0 - AACUBIC(Sc5b, xy, aaw));\n\t\t\tpattern = min(mask1, AASTEP(Sx0, xy.x, aaw));\n\t\t}\n\t\telse if(xy.y < Sy2) { // middle left part\n\t\t\tpattern = min(AACUBIC(Sc3a, xy, aaw), 1.0 - AACUBIC(Sc3b, xy, aaw));\n\t\t}\n\t\telse { // upper left part\n\t\t\tpattern = min(AACUBIC(Sc1a, xy, aaw), AACUBIC(Sc1b, xy, aaw));\n\t\t}\n\t}\n\telse { // right half\n\t\tif(xy.y < Sy1) { // bottom right part\n\t\t\tpattern = min(1.0 - AACUBIC(Sc6a, xy, aaw),\n\t\t\t\t1.0 - AACUBIC(Sc6b, xy, aaw));\n\t\t}\n        else if(xy.y < Sy2) { // middle right part\n\t\t\tpattern = min(AACUBIC(Sc4a, xy, aaw), 1.0 - AACUBIC(Sc4b, xy, aaw));\n\t\t}\n\t\telse { // upper right part\n\t\t\tmask1 = min(AACUBIC(Sc2a, xy, aaw), 1.0 - AACUBIC(Sc2b, xy, aaw));\n\t\t\tpattern = min(mask1, 1.0 - AASTEP(Sx1, xy.x, aaw));\n\t\t}\n\t}\n    return pattern;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float zoom = pow(0.5, 8.0*max(0.0, iMouse.y-20.0)/iResolution.y);\n    vec2 pan = vec2(-sqrt(zoom)*iMouse.x/iResolution.x, 0.5);\n\n    vec2 uv = (gl_FragCoord.xy\n        - 0.5*max(vec2(0.0), (iResolution.xy-iResolution.yx))) // Center\n        / min(iResolution.x, iResolution.y);  // Fit unit square in view\n\n    vec2 poi = vec2(0.92, 0.27); // Pick a good point to zoom in on\n    vec2 xy = ((zoom * (uv - poi)) + poi) * 150.0 - vec2(75.0, 75.0);\n    float w = fwidth(length(xy));\n\n    float Smask = implicitS(xy, w);\n\n    vec3 mixcolor = vec3(1.0-Smask);\n    vec3 linecolor =vec3(1.0,0.0,0.0);\n    float boundaries;\n    if(iMouse.z > 0.0) {\n        boundaries = max(max(aaline(0.0, xy.x, 2.0),\n                             aaline(Sy1, xy.y, 2.0)),\n                             aaline(Sy2, xy.y, 2.0));\n        mixcolor = mix(mixcolor, linecolor, boundaries);\n    }\n    fragColor = vec4(mixcolor,1.0);\n}\n","name":"Image","description":"","type":"image"}]}