{"ver":"0.1","info":{"id":"ctl3WN","date":"1671784239","viewed":115,"name":"Super Particle Simulator V2","username":"danielemoro","description":"Properties observed in the simulation:\n- Rigid body physics\n- Soft body physics\n- Heat simulation\n- Crystal formation\n- Gravitational Tidal Forces\n- Lagrange points\n- Natural satellite formation\n- Planetary rotation and geography (mountains/valleys)\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["particle","gravity"],"hasliked":0,"parentid":"mlf3Dr","parentname":"Super Gravity Particle Sim"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float movingDisk(in vec2 p, in vec2 o, in float r, in vec2 v, in float Dt) {\n    vec2 p0 = p - o, p1 = v * Dt;\n\n    float a = dot(p1, p1);\n    float b = dot(p0, p1);\n    float c = dot(p0, p0) - r * r;\n\n    float h = b * b - a * c;\n    if (h > 0.0) {\n        vec2 t = clamp((vec2(-1.0, 1.0) * sqrt(h) - b) / a, 0.0, 1.0);\n        return t.y - t.x;\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    // Draw particles\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 f = vec2(0., 0.);\n    \n    for (int id=0; id < PARTICLES; id++) {\n        Particle p = loadParticle(id);\n        vec3 color = vec3(1.0, 1.0, 1.0);\n        fragColor.rgb += color * movingDisk(uv, p.pos, p.radius, p.vel, 1.0);\n        \n          \n        if( iMouse.z > 0.001 ){\n            vec2 dir = uv - p.pos;\n            float dist = length(dir);\n            if (dist < A){\n               f += (dir / dist) * (R * (dist - A));\n            } else if (dist < C) {\n               f += (dir / dist) * (M - pow(Z*dist - SQRTMmAZ, 2.));\n            } else {\n               f += (dir / dist) * (G / pow(dist - B, 2.));\n            }\n            vec2 mouse_pos = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n            vec2 mouse_dir = mouse_pos - uv;\n            if (length(mouse_dir) < MOUSE_AREA) {\n                f += mouse_dir * MOUSE_STRENGTH;\n            }\n            fragColor.r += length(f) * 300.;\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Settings\n#define PARTICLES 800\n\n#define MOUSE_AREA .02\n#define MOUSE_STRENGTH .003\n\n#define G 0.0000000003\n#define A 0.0053\n#define R 0.6\n#define M 0.00008\n#define Z 6.0\n#define B 0.005652\n#define C 0.0025 + A\n#define SQRTMmAZ 0.00894427191 - A * Z\n#define F 200.\n#define Fm1 199.\n\n\n#define DECAY 0.5\n#define dt 1.0\n\n#define EPSILON 0.00000000001\n\n// Utilities\nstruct Particle {\n    int id;\n    vec2 pos;\n    vec2 vel;\n    float radius;\n};\n\n// Hashes from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// Initialize\nvec4 initParticle(in ivec2 addr) {\n    if (addr.x < PARTICLES) {\n        float x = float(addr.x) + iDate.w;\n        if (addr.y == 0) return vec4(Hash12(x + 274.937) - 0.5, 0.0, 0.0);                     // Position vec2\n        if (addr.y == 1) return vec4((Hash12(x + 385.583) - 0.5) * 0.003, 0.0, 0.0);           // Velocity vec2\n        if (addr.y == 2) return vec4(0.002, 0.0, 0.0, 0.0);   // Radius vec1\n        return vec4(0.0);\n    }\n\n    return vec4(0.0);\n}\n\n// Load/store\n#define loadParticle(pid)                                \\\n    Particle(pid,                                        \\\n             texelFetch(iChannel0, ivec2(pid, 0), 0).xy, \\\n             texelFetch(iChannel0, ivec2(pid, 1), 0).xy, \\\n             texelFetch(iChannel0, ivec2(pid, 2), 0).x)  \\\n\nvec4 storeParticle(in Particle p, in ivec2 addr) {\n    if (addr.y == 0) return vec4(p.pos, 0.0, 0.0);            // Position vec2\n    if (addr.y == 1) return vec4(p.vel, 0.0, 0.0);            // Velocity vec2\n    if (addr.y == 2) return vec4(p.radius, 0.0, 0.0, 0.0);    // Radius vec1\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Force particles to stay within boundaries\nvec2 constrain(in vec2 pos, in vec2 constraints, in float radius) {\n    return clamp(pos, -constraints, constraints);\n}\n\nParticle updateParticle(in Particle p, in vec2 constraints) {\n    vec2 f = vec2(0.0); // Force vector (all forces get added into it)\n\n    float t = iTime * 10.;\n    \n    // Boundary collisions\n    if (abs((p.pos + p.vel * dt).x) > constraints.x - p.radius) {\n        p.vel.x *= -1.0;\n        p.vel *= DECAY;\n    }\n    if (abs((p.pos + p.vel * dt).y) > constraints.y - p.radius) {\n        p.vel.y *= -1.0;\n        p.vel *= DECAY;\n    }\n    \n\n    // Particle-particle forces\n    for (int id=0; id < PARTICLES; id++) {\n        if (id != p.id) {\n            Particle p2 = loadParticle(id);\n            vec2 dir = p2.pos - p.pos;\n            float dist = length(dir);\n\n            \n            if (dist < A){\n               p.vel = ((p.vel * Fm1) + p2.vel) / F;\n               f += (dir / dist) * (R * (dist - A));\n            } else if (dist < C) {\n               f += (dir / dist) * (M - pow(Z*dist - SQRTMmAZ, 2.));\n            } else {\n               f += (dir / dist) * (G / pow(dist - B, 2.));\n            }\n            \n        }\n    }\n    \n    // Mouse forces\n    if( iMouse.z > 0.001 ){\n        vec2 mouse_pos = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n        vec2 mouse_dir = mouse_pos - p.pos;\n        if (length(mouse_dir) < MOUSE_AREA) {\n            f += mouse_dir * MOUSE_STRENGTH;\n        }\n    }\n\n    // Update\n    p.vel += f * dt;\n    p.pos = constrain(p.pos + p.vel * dt, constraints, p.radius);\n\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 constraints = vec2(iResolution.x / iResolution.y * 0.5, 0.5);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) fragColor = initParticle(iFragCoord);\n    if (iFrame > 0) {\n        if (iFragCoord.x < PARTICLES && iFragCoord.y < 4) {\n            Particle p = loadParticle(iFragCoord.x);\n            p = updateParticle(p, constraints);\n            fragColor = storeParticle(p, iFragCoord);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}