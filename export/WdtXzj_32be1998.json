{"ver":"0.1","info":{"id":"WdtXzj","date":"1572376165","viewed":188,"name":"Exploding Blobs","username":"mrst33l","description":"A red blob explodes into smaller blobs.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blobs","loop","exploding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//creates a rotation matrix for a given angle\nmat2 rot(float a){\n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\n//smooth minimum functions for both floats and vec3s\nfloat smin(float a, float b, float h){\n    float k=clamp((a-b)/h*.5+.5,0.,1.);\n    return mix(a,b,k)-k*(1.-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h){\n    vec3 k=clamp((a-b)/h*.5+.5,0.,1.);\n    return mix(a,b,k)-k*(1.-k)*h;\n}\n\n//creates the space folding so that two spheres can appear like this.\nvec3 kifs(vec3 p, float t){\n    //spreads them out exponentially - exploding\n    float s=-2.+4.6*exp(fract(iTime*.25));\n    //rotate and fold space a few times by a decreasing amount\n    for(int i=0;i<4;i++){\n        p.xz*=rot(t+float(i));\n        p.xy*=rot(.7*(t+float(i)));\n        p=smin(p,-p,-3.);\n        p-=s;\n        s*=.7;\n    }\n    return p;\n}\n\n//distance field\nfloat at=0.;//for the colour\nfloat dist(vec3 p){\n    vec3 p1=kifs(p,iTime*.1);\n    vec3 p2=kifs(p+vec3(2.,2.,-3.),iTime*.13);\n    //two sphere sdfs\n    float d1=length(p1)-1.5;\n    float d2=length(p2)-1.4;\n    float m1=smin(d1,d2,-1.);\n    at+=.075/(.15+abs(m1));//colouring effect\n    return m1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uvs such that y is between -.5 and .5 and x is aspect ratio corrected\n    vec2 uv = -.5 + fragCoord/iResolution.xy;\n    uv/=vec2(iResolution.y/iResolution.x,1.);\n    \n    //camera stuff\n    float zoom = 1.;\n    vec3 ro = vec3(0.,0.,-50.);\n    ro.xz*=rot(iTime*.8);\n    ro.xy*=rot(iTime*.4);\n    vec3 t = vec3(0.,0.,0.);\n    vec3 f = normalize(t-ro);\n    vec3 r = normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(r,f));\n    vec3 rd = normalize(f*zoom + r*uv.x + u*uv.y);\n    \n    //colour\n    vec3 c = vec3(0.);\n    \n    //raymarching loop\n    vec3 p = ro;\n    float d;\n    for(int i=0;i<100;i++){\n        d = dist(p);\n        if(d<.001) {d=.1;}//break when hit an object\n        if(d>50.) break;//break when miss an object\n        p += d*rd;\n        c += pow(at*.01,3.)*vec3(1.,.102,0.);\n    }\n    \n    //get normal\n    vec2 e = vec2(0.,.01);\n    vec3 n = normalize(dist(p)-vec3(dist(p-e.yxx),dist(p-e.xyx),dist(p-e.xxy)));\n    \n    fragColor = vec4(c,1.);\n}\n\n\n","name":"Image","description":"","type":"image"}]}