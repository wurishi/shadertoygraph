{"ver":"0.1","info":{"id":"M3tSWj","date":"1726165882","viewed":12,"name":"Fork #inversion metamatema 840","username":"metamatematico","description":"El shader crea una escena 3D con las siguientes características:\n\nEsferas deformadas que se mueven y cambian con el tiempo.\nUna rejilla hexagonal que deforma el espacio.\nEfectos de inversión circular que crean distorsiones interesantes.\nIluminación básica","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["inversion","tilling","invertion"],"hasliked":0,"parentid":"l3tSWj","parentname":"#inversion"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shadertoy sphere inversion shader\n\n#define MAX_STEPS 10\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\n// Time-based animation\nfloat getTime() {\n    return iTime * 0.5;\n}\n\n// Hexagonal grid\nvec2 hexGrid(vec2 p) {\n    const float hexSize = 0.1;\n    vec2 r = vec2(1, 1.7320508); // sqrt(3) pre-calculated\n    vec2 h = r * 0.5;\n    vec2 a = mod(p, r) - h;\n    vec2 b = mod(p - h, r) - h;\n    return dot(a, a) < dot(b, b) ? a : b;\n}\n\n// Inversion in a circle\nvec3 invertPoint(vec3 p, float radius) {\n    float r2 = radius * radius;\n    return p * r2 / dot(p, p);\n}\n\n// Distance function\nfloat getDist(vec3 p) {\n    float time = getTime();\n    \n    // Apply hexagonal grid deformation\n    vec2 hexOffset = hexGrid(p.xy * 8.0) * 0.05;\n    p.xy += hexOffset;\n    \n    // Inversion\n    float invRadius = 1.0 + sin(time) * 0.5;\n    p = invertPoint(p, invRadius);\n    \n    // Create spheres\n    float sphereDist = length(p) - 0.5;\n    \n    // Add some variation\n    sphereDist += sin(p.x * 10.0 + time) * 0.1;\n    sphereDist += cos(p.y * 8.0 + time * 1.3) * 0.1;\n    sphereDist += sin(p.z * 12.0 + time * 0.7) * 0.1;\n    \n    return sphereDist;\n}\n\n// Ray marching\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    return dO;\n}\n\n// Calculate normal\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    return normalize(n);\n}\n\n// Main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 1, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 n = getNormal(p);\n    vec3 r = reflect(rd, n);\n    \n    // Lighting\n    vec3 light = normalize(vec3(1, 2, -3));\n    float diff = dot(n, light) * 0.5 + 0.5;\n    float spec = pow(max(dot(r, light), 0.0), 32.0);\n    float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 5.0);\n    \n    // Color\n    vec3 col = vec3(0.2, 0.3, 0.4);\n    col = mix(col, vec3(0.8, 0.7, 0.5), diff);\n    col += vec3(1.0, 0.8, 0.7) * spec * 0.5;\n    col += vec3(0.1, 0.2, 0.3) * fresnel;\n    \n    // Output\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}