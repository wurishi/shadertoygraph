{"ver":"0.1","info":{"id":"DstfDB","date":"1697659295","viewed":38,"name":"18. Saddle","username":"Ladus","description":"Inktober 2023 Day 18. First time raymarching using reinder's simple example. Didn't know what to do for saddle, and found the \"saddle point\" so I decided to draw the saddle like shape which contains a saddle point in 3d. I dont know why there are holes","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["saddle","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I used this raymarching example created by reinder as a reference: https://www.shadertoy.com/view/4dSBz3 \n#define PI 3.14159265359\nmat2 rotate(float a) {\n    a *= PI * 2.;\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// sdf for box by: https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfWorld(vec3 p) {\n    // Add ground plane\n    float d = p.y + 2.;\n    \n    // Create box space\n    vec3 boxSpace = p+vec3(0.,0.,2.);\n    \n    // Rotate the box\n    mat2 mat2Rot = rotate(fract(iTime/8.));\n    boxSpace.zx *= mat2Rot;\n    \n    // Shape the box\n    boxSpace.y += (sin((boxSpace.x*2.)+1.5) / 2.);\n    boxSpace.y += (sin((boxSpace.z*2.)-1.5) / 2.);\n    \n    // Add the box to the 3d sdf\n    d = min(d, sdBox(boxSpace, vec3(1.,0.05,1.)));\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(1.0,-1.0) * 0.0005;\n    return normalize(\n        e.xyy * sdfWorld(p + e.xyy) +\n        e.yyx * sdfWorld(p + e.yyx) +\n        e.yxy * sdfWorld(p + e.yxy) +\n        e.xxx * sdfWorld(p + e.xxx));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float loopingTime = fract(iTime/2.);\n    float aa = 0.;\n\n    vec3 rayOrigin = vec3(0,0.,.5); // behind the screen\n    vec2 p = (fragCoord.xy - .5 * iResolution.xy ) / iResolution.y;\n    vec3 rayDirection = normalize(vec3(p, 0.) - rayOrigin);\n    \n    vec3 cameraPosition = vec3(0.,0.5,0.3);\n    \n    rayOrigin += cameraPosition;\n\n    float h,distanceFromCamera = 1.;\n    for(int i = 0; i < 256; i++) {\n        h = sdfWorld(rayOrigin + rayDirection * distanceFromCamera);\n        distanceFromCamera += h *0.7;\n        if(h<0.01) break;\n    }\n    \n    if(h < 0.01) {\n        vec3 surfacePosition = rayOrigin + rayDirection * distanceFromCamera;\n        \n        vec3 normal = getNormal(surfacePosition);\n        \n        vec3 light = vec3(0,2,0);\n        float lightIntensity = 5.;\n        \n        float diffuse = clamp(dot(normal, normalize(light - surfacePosition)), 0., 1.);\n        diffuse *= lightIntensity / dot(light - surfacePosition, light - surfacePosition);\n        \n        fragColor = vec4(vec3(pow(diffuse, 0.4545)), 1);\n    }\n    else { \n        fragColor = vec4(0, 0, 0, 1);\n    }   \n}","name":"Image","description":"","type":"image"}]}