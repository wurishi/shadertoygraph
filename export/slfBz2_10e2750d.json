{"ver":"0.1","info":{"id":"slfBz2","date":"1651180829","viewed":162,"name":"Game of TorusLife ","username":"Amirk","description":"Game of life living on transparent glowing torus :). Rotate with mouse.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["torus","texture","conway","gameoflife","raymach"],"hasliked":0,"parentid":"NtjyDR","parentname":"Game of Life shader"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_ITER 100.\n#define MAX_DIST 100.\n#define SURF 0.001\n#define PI 3.1416\n\nvec3 col; \nfloat time=0.;\n\nmat2 Rot(float a){\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat atan2(vec2 p){\n//undefined at origin\n  float a=atan(p.y/p.x)*(float(p.x!=0.));\n  a+=(1.-2.*(float(p.y<0.)))*(PI*(float(p.x<0.))+.5*PI*(float(p.x==0.)));\n  \n  return a;\n}\n\nfloat asin2(vec3 p, float r1, float r2){\n\n        float toroidal = asin(p.y/r2);\n        if(length(p.xz)<r1+0.001&&p.y>-0.001) return PI-toroidal;\n        else if(length(p.xz)<r1+0.001&&p.y<0.001) return -toroidal-PI;\n\n        return toroidal;\n}\n\nvec2 toroidalCoordinates(vec3 p, float r1, float r2){\n        float toroidal = asin2(p,r1,r2);\n        \n        float poloidal= atan2(p.xz);\n        \n        //to range 0,1:\n        return (vec2(poloidal, toroidal)+PI)/(2.*PI);       \n}\n\n\nfloat sdBox(vec3 p , vec3 s){\n p= abs(p)-s;\n\nreturn length(max(p,0.))+ min(max(p.x,max(p.y,p.z)),0.); //signed distance is needed here\n}\n\nfloat sdTorus(vec3 p, float r1,float r2){\nfloat dxz= length(p.xz)-r1;\n\nreturn length(vec2(dxz,p.y))-r2;\n}\n\n\n\nvec3 getRayDir(vec2 uv, vec3 ro,vec3 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt-ro);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    vec3 i= ro+f*zoom+uv.x*r+uv.y*u;\n    \n    return normalize( i-ro);\n}\n\n\nfloat getDist(vec3 p){\n    float d= sdBox(p, vec3(1));\n    float sd= length(p)-1.5;\n    float td= sdTorus(p, 2.,1.); \n     \n  return td;\n}\n\n\n\n\nfloat RayMarch(vec3 ro, vec3 rd, float inside){\nfloat dO=0.;\nfloat i=0.;\nwhile(i<MAX_ITER){\n  vec3 p= ro+dO*rd;\n\n  float dS=inside*getDist(p);\n\n  dO+=dS;\n  \n  if(dO>MAX_DIST||dS<SURF) break;\n  \n  i++;\n}\n\nfloat halo= pow(5.*i/MAX_ITER,2.);\ncol+=vec3(halo)*vec3(0.4,0.2,1);\n\nreturn dO;\n\n}\n\n\nvec3 getNormal(vec3 p){\n  vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyy),getDist(p- e.yxy),getDist(p- e.yyx));\n   \n   return normalize(n);\n}\n\n\nvec3 getLight(vec3 p, vec3 lightPos){\n\nlightPos.xz+=2.*vec2(cos(iTime),sin(iTime));\nvec3 l= normalize(vec3(1,2,3));\nvec3 n= getNormal(p);\n\nfloat dif=0.;\n\ndif =dot(l, n)*.5+.5;\n\nreturn dif*n*.5+.5;\n}\n\n\nvoid normalColoring(vec3 p){\n          vec3 n= getNormal(p);\n\n          n=abs(n);\n          n*=pow(n,vec3(5));\n          n=normalize(n);\n          col*=.5+n*.5;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 m = (iMouse.xy)/iResolution.xy;\n    col =vec3(0);\n\n    \n    //camera: \n    float zoom= smoothstep(-1.,3.,iTime);\n\n\n    vec3 ro= vec3(2,2,-5);\n    ro.xz*=Rot(PI*2.*smoothstep(0.2,3.,iTime));\n\n\n    ro.yz*=Rot(m.y*PI);\n    ro.xz*=Rot(-m.x*PI);\n    \n    vec3 lookAt=vec3(0,0,0);\n    \n    vec3 rd= getRayDir(uv, ro, lookAt,zoom);\n\n    float d= RayMarch(ro,rd,1.);\n\n      if(d<MAX_DIST){//if we hit the object:\n       \n          vec3 p= ro+ d*rd;\n          vec3 n= getNormal(p);\n      \n          float dif= dot(n, normalize(vec3(1,2,3)))*.5+.75;\n         \n         vec2 Tuv=toroidalCoordinates(p,2.,1.); \n         \n         vec4 GOL =texture(iChannel1,Tuv);\n\n         if(GOL.g<1.){\n         d= RayMarch(p-4.*SURF*n, rd,-1.);\n         \n         p=p+d*rd;\n         \n         Tuv=toroidalCoordinates(p,2.,1.); \n         GOL =mix(GOL,texture(iChannel1,Tuv),.4);\n         \n         }\n         GOL.g*=.1;\n\n         col=mix(col,GOL.rgb,GOL.a);\n         //col.r+=-min(Tuv.x,0.);\n         //col.rg+=vec2(uv.x*20.,uv.y)*.2;\n         \n         col*=dif;\n\n       }\n    \n\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int getNeighbors(ivec2 p){\n  int num=0;\n  ivec2 r = ivec2(textureSize(iChannel1, 0))/int(SIZE);\n\n for(int y=-1;y<=1;y++ ){\n  for(int x=-1;x<=1;x++ ){\n   if(x==0&&y==0)continue;\n   ivec2 pp=p+ivec2(x,y);\n   pp = (pp+r) % r;\n\n   num+=texelFetch(iChannel1, pp,0).r >.5 ? 1 : 0;\n  }\n\n}\n\nreturn num;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = vec4(0);\n    \n    if(iFrame<10) col.rgb=vec3(texture(iChannel0,uv).r); //initial population from noise\n    \n    else if(iFrame %PERIOD !=0)\n        col= texture(iChannel1,uv); //if we're not updating, we just draw the same\n    \n    else{\n    \n      bool alive=texelFetch(iChannel1, ivec2(fragCoord),0).r>.5;\n    \n      int num=getNeighbors(ivec2(fragCoord));\n    \n      int next = alive && num==2 || num==3 ? 1:0;  //the survival rules in one line\n       \n     \n      col=vec4(next);\n    }\n    \n   // if(iMouse.z>.5&&distance(iMouse.xy/ZOOM,fragCoord.xy)<BRUSH_SIZE)  col=vec4(1);\n\n\n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SIZE 18.7 \n#define BRUSH_SIZE 5.\n#define PERIOD 40\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n\nvec4 old= texture(iChannel1, uv)*vec4(1,0,0,1)*.98; //red ones are dead\nvec4 new= texture(iChannel0, uv);\n\n\n\n    fragColor = max(old, new);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res=floor(iResolution.xy/SIZE)*SIZE;\n    //snap to frame:\n    vec2 S = iResolution.xy/floor(iResolution.xy/SIZE);\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec3 col = texture(iChannel1,uv/S).rgb;\n    \n    vec2 gv=fract(fragCoord/S)-.5;\n    \n    float d= length(gv);\n    \n    col*=smoothstep(.1,.0,d-.4);\n    \n  //  col.rg=gv;\n\n    fragColor = vec4(col,length(col));\n}\n","name":"Buffer C","description":"","type":"buffer"}]}