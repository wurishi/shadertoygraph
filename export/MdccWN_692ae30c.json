{"ver":"0.1","info":{"id":"MdccWN","date":"1518862995","viewed":270,"name":"Simple CFD - Mass + Momentum","username":"araesmojo","description":"Simple CFD (computational fluid dynamics) with only mass and momentum exchange.\nCenter blob acts as a velocity source\nNo diffusion, so extreme values can produce \"interesting\" results.\nClick + drag to move center velocity source","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["fluid","dynamics","mass","cfd","momentum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4( texture( iChannel0, fragCoord / iResolution.xy ) );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simple CFD with only mass and momentum exchange.\n// Center blob acts as a velocity source\n\n// Change this to change how the center velocity behaves\n// ( vx, vy, mass, <unused> )\n// 0.5, 0.5 is stationary velocity\n// 0.0, 0.0 is max down left\n// 1.0, 1.0 is max up right\n// Mass is logarithmic\nvec4 cenVel = vec4( 0.7, 0.7, 0.25, 1.0);\n\n// with no diffusion, extreme values can produce \"interesting\" results.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// percentage position\n\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\tvec2 mousePos = iMouse.xy / iResolution.xy;\n\tvec2 pixel = vec2(1.0,1.0)/iResolution.xy;\n    vec4 colorOut = vec4( 0.5, 0.5, 0.25, 1.0 );\n\t \n\tif( iTime < 0.25 ){\n\t\t// if its the first iteration, initialize\n\t\tcolorOut = vec4( 0.5, 0.5, 0.25, 1.0 );\n\t} else {\n\t\tif( position.x < 0.01 ){\n\t\t\t// xmin border cell\n\t\t\tcolorOut = vec4( 0.8, 0.5, 0.25, 1.0 );\n\t\t} else {\n\t\t\tif( position.x > 0.99 ){\n\t\t\t\t// xmax border cell\n\t\t\t\tcolorOut = vec4( 0.2, 0.5, 0.25, 1.0 );\n\t\t\t} else {\n\t\t\t\tif( position.y < 0.01 ){\n\t\t\t\t\t// ymin border cell\n\t\t\t\t\tcolorOut = vec4( 0.5, 0.8, 0.25, 1.0 );\n\t\t\t\t} else {\n\t\t\t\t\tif( position.y > 0.99 ){\n\t\t\t\t\t\t// ymax border cell\n\t\t\t\t\t\tcolorOut = vec4( 0.5, 0.2, 0.25, 1.0 );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// normal center cell\n\t\t\t\t\t\tvec2  cVec  = position - mousePos;\n\t\t\t\t\t\tfloat cDist = sqrt( dot( cVec, cVec ) );\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if we are less than 10% from the center make it a moving zone\n\t\t\t\t\t\tif( cDist < 0.05 ){\n\t\t\t\t\t\t\tcolorOut = cenVel;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfloat dx      = 1.0; // <m>\n\t\t\t\t\t\t\tfloat dy      = dx; // <m>\n\t\t\t\t\t\t\tfloat g       = 9.81; // <m/s^2>\n\t\t\t\t\t\t\tfloat density = 1000.0; // <kg/m^3>\n\t\t\t\t\t\t\tfloat area    = dx * dy; // <m^2>\n\t\t\t\t\t\t\tfloat h_dens  = density * area;\n\t\t\t\t \n\t\t\t\t\t\t\t// MASS change\n\t\t\t\t\t\t\t// Cells arranged in 3x3 square A-C on each side\n\t\t\t\t\t\t\t// + AC BC CC\n\t\t\t\t\t\t\t// y AB BB CB\n\t\t\t\t\t\t\t// - AA BA CA\n\t\t\t\t\t\t\t//   -  x  +\n\t\t\t\t\t\t\t// BB is current cell\n\t\t\t\t \n\t\t\t\t\t\t\t// Find out the velocity and mass at each vertex\n\t\t\t\t\t\t\tvec4 umAA = texture( iChannel0, position.xy + vec2( -1.0, -1.0 ) * pixel );  // -x, -y\n\t\t\t\t\t\t\tvec4 umAB = texture( iChannel0, position.xy + vec2( -1.0,  0.0 ) * pixel );  // -x, 0\n\t\t\t\t\t\t\tvec4 umAC = texture( iChannel0, position.xy + vec2( -1.0,  1.0 ) * pixel );  // -x, +y\n\t\t\t\t\t\t\tvec4 umBA = texture( iChannel0, position.xy + vec2(  0.0, -1.0 ) * pixel );  // 0, -y\n\t\t\t\t\t\t\tvec4 umBB = texture( iChannel0, position.xy + vec2(  0.0,  0.0 ) * pixel );  // 0, 0 (the center pixel)\n\t\t\t\t\t\t\tvec4 umBC = texture( iChannel0, position.xy + vec2(  0.0,  1.0 ) * pixel );  // 0, +y\n\t\t\t\t\t\t\tvec4 umCA = texture( iChannel0, position.xy + vec2(  1.0, -1.0 ) * pixel );  // +x, -y\n\t\t\t\t\t\t\tvec4 umCB = texture( iChannel0, position.xy + vec2(  1.0,  0.0 ) * pixel );  // +x, 0\n\t\t\t\t\t\t\tvec4 umCC = texture( iChannel0, position.xy + vec2(  1.0,  1.0 ) * pixel );  // +x, +y\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvec2 velAA = ( umAA.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\tvec2 velAB = ( umAB.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\tvec2 velAC = ( umAC.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\tvec2 velBA = ( umBA.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\tvec2 velBB = ( umBB.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\tvec2 velBC = ( umBC.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\tvec2 velCA = ( umCA.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\tvec2 velCB = ( umCB.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\tvec2 velCC = ( umCC.xy - vec2( 0.5, 0.5 ) ) * 2.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Get rid of directions that can't interact\n\t\t\t\t\t\t\tif( velAA.x < 0.0 ){ velAA.x = 0.0; }\n\t\t\t\t\t\t\tif( velAA.y < 0.0 ){ velAA.y = 0.0; }\n\t\t\t\t\t\t\tif( velAB.x < 0.0 ){ velAB.x = 0.0; }\n\t\t\t\t\t\t\tif( velAC.x < 0.0 ){ velAC.x = 0.0; }\n\t\t\t\t\t\t\tif( velAC.y > 0.0 ){ velAC.y = 0.0; }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( velBA.y < 0.0 ){ velBA.y = 0.0; }\n\t\t\t\t\t\t\tif( velBC.y > 0.0 ){ velBC.y = 0.0; }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif( velCA.x > 0.0 ){ velCA.x = 0.0; }\n\t\t\t\t\t\t\tif( velCA.y < 0.0 ){ velCA.y = 0.0; }\n\t\t\t\t\t\t\tif( velCB.x > 0.0 ){ velCB.x = 0.0; }\n\t\t\t\t\t\t\tif( velCC.x > 0.0 ){ velCC.x = 0.0; }\n\t\t\t\t\t\t\tif( velCC.y > 0.0 ){ velCC.y = 0.0; }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Mass remaining center\n\t\t\t\t\t\t\tfloat mDeltaBB = pow( 16.0, umBB.z ) * ( 1.0 - abs( velBB.x ) ) / dx * ( 1.0 - abs( velBB.y ) ) / dy;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Mass from edges\n\t\t\t\t\t\t\tfloat mDeltaAA = pow( 16.0, umAA.z ) * velAA.x / dx              * velAA.y / dy;\n\t\t\t\t\t\t\tfloat mDeltaAB = pow( 16.0, umAB.z ) * velAB.x / dx              * ( 1.0 - abs( velAB.y ) ) / dy;\n\t\t\t\t\t\t\tfloat mDeltaAC = pow( 16.0, umAC.z ) * velAC.x / dx              * velAC.y / dy * -1.0;\n\t\t\t\t\t\t\tfloat mDeltaBA = pow( 16.0, umBA.z ) * ( 1.0 - abs( velBA.x ) ) / dx * velBA.y / dy;\n\t\t\t\t\t\t\tfloat mDeltaBC = pow( 16.0, umBC.z ) * ( 1.0 - abs( velBC.x ) ) / dx * velBC.y / dy * -1.0;\n\t\t\t\t\t\t\tfloat mDeltaCA = pow( 16.0, umCA.z ) * velCA.x / dx * -1.0       * velCA.y / dy;\n\t\t\t\t\t\t\tfloat mDeltaCB = pow( 16.0, umCB.z ) * velCB.x / dx * -1.0       * ( 1.0 - abs( velCB.y ) ) / dy;\n\t\t\t\t\t\t\tfloat mDeltaCC = pow( 16.0, umCC.z ) * velCC.x / dx * -1.0       * velCC.y / dy * -1.0;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// sum up the mass change from all border cells\n\t\t\t\t\t\t\tfloat mNew = mDeltaBB;\n\t\t\t\t\t\t\t// + mass in\n\t\t\t\t\t\t\tmNew = mNew + mDeltaAA + mDeltaAB + mDeltaAC + mDeltaBA + mDeltaBC + mDeltaCA + mDeltaCB + mDeltaCC;\n\t\t\t\t\t\t\tif( mNew < 0.05 ){ mNew = 0.05; }\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// sum up the momentum change from all border cells\n\t\t\t\t\t\t\tvec2 momNew = mDeltaBB * velBB.xy;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// + mom in\n\t\t\t\t\t\t\tmomNew = momNew + mDeltaAA * velAA.xy + mDeltaAB * velAB.xy + mDeltaAC * velAC.xy;\n\t\t\t\t\t\t\tmomNew = momNew + mDeltaBA * velBA.xy + mDeltaBC * velBC.xy;\n\t\t\t\t\t\t\tmomNew = momNew + mDeltaCA * velCA.xy + mDeltaCB * velCB.xy + mDeltaCC * velCC.xy;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// calculate the new cell velocity\n\t\t\t\t\t\t\tvec2 vNew = momNew / mNew;\n\t\t\t\t\t\t\tvec2 vOut = vNew / 2.0 + vec2( 0.5, 0.5 );\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcolorOut =  vec4( vOut.x, vOut.y, log2( mNew )/4.0, 1.0 );\n                            //colorOut = vec4( 0.5, 0.5, 0.25, 1.0 );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfragColor = colorOut;\n}","name":"Buf A","description":"","type":"buffer"}]}