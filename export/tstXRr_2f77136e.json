{"ver":"0.1","info":{"id":"tstXRr","date":"1571352859","viewed":520,"name":"ShaderTober - Wild","username":"Flopine","description":"A small doodle with inktober's theme \"Wild\"","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","water","inktober","uvdistorsion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 100.\n#define PI 3.141592\n#define t (iTime*2.*PI)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.45,46.5)))*124.5);}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a, per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nfloat prim (vec3 p)\n{\n    p.xz *= rot(sin(p.y*2.)+iTime);\n  \tmoda(p.xz, 5.);\n    p.x -= .18;\n   \treturn cyl(p.xzy, 0.1, 1e10);\n}\n\nfloat g1 = 0.;\nfloat eel (vec3 p)\n{\n    p.x = abs(p.x)-2.;\n    p.z -= t;\n    p.x -= sin(p.z+t);\n    p.y += cos(p.z+t);\n    float d = cyl(p, 0.2+sin(p.z*5.)*0.1, 1.);\n    g1 += 0.1/(0.1+d*d);\n    return d; \n}\n\nfloat grid (vec3 p)\n{\n    float per = 4.;\n    p = mod(p,per)-per*0.5;\n    \n    float p1 = prim(p);\n    p.xy*=rot(PI/2.);  \n    float p2 = prim(p);\n    p.yz *= rot(PI/2.);\n    return min(min(p1,p2),prim (p));\n}\n\nfloat SDF (vec3 p)\n{return min(grid(p),eel(p));}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    uv += texNoise(texNoise(uv*0.5+iTime*0.2).rg*0.2).rg*0.7;\n    \n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(4.,1.4,-4.+t),\n        p = ro,\n        tar = vec3(0.,-.5,t ),\n        rd = getcam(ro, tar,uv),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i =0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.5+dither*0.2;\n        p += d*rd;\n    }\n\n    float ad = length(ro-p);\n    \n    col = vec3(shad)*0.8;\n\tcol += g1 * vec3(0.2,0.7,0.8+p.x*0.5)*0.4;\n    \n    col = mix(col, vec3(0.,0.15,0.35), 1.-exp(-0.008*ad*ad));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}