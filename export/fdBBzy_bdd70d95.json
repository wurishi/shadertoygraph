{"ver":"0.1","info":{"id":"fdBBzy","date":"1646510795","viewed":118,"name":"Twisted Menger","username":"lwswl","description":"A Menger Sponge distorted quadratically.\nY axis of Mouse to zoom, X axis to pan.\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","menger","twist"],"hasliked":0,"parentid":"NdjBWm","parentname":"Fork Distorted  lwswl 512"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==1\n//#define AA\n#endif\n//the max steps\n#define MAX_STEPS 65536\n//only used for computing normals\n#define near 0.000001\n#define far 1000.\n#define COLOR_SPEED 0.1\n//this number defines the number of subdivisions in the menger cube when computed for light. When not computing lights, the number of subdivions is infinite, and is only not sampled when epsilon has been reached, which is set dynamically based on the distance of the ray to the cube after the first epsilon(for the non-menger) has been reached, and the screen resolution.\n#define MENGER_LIGHT_DENSITY 3.0\n#define lerp(a, b, k,) a*(1.0-k)+b*k\n\n\nvec3 hue(float t){\n    vec3 h=vec3(1,0,0);\n    if (t<=0.333){\n        h.r=0.333-t;\n        h.g=t;\n        h.b=0.;\n    }\n    else if(t<=0.667){\n        h.g=0.667-t;\n        h.b=t-0.333;\n        h.r=0.;\n    }\n    else{\n        h.b=1.-t;\n        h.r=t-0.667;\n        h.g=0.;\n    }\n    h*=3.;\n    return h;\n}\nfloat cubeSDF(vec3 p,float f){\n    vec3 v = abs(p) - vec3(f);\n    return length(max(v,0.0)) + min(max(v.x,max(v.y,v.z)),0.0);\n}\n\nfloat mengerSDF(vec3 p, float limit){\n    float r=1.;\n    float II=0.;\n    vec3 o=vec3(0);\n    float d=0.0;\n    \n    float f;\n    \n    if(II==0.)d=cubeSDF(p+o,r);\n    if (d>r*sqrt(2.0))return d;\n    vec3 no=vec3(0);\n    \n    r/=3.;\n    while (d<r*sqrt(2.0)&&(II<limit||limit==0.)){\n        \n        d=far;\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,0);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,0),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,0);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,0,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,0,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(0,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(0,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(0,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*r,2.*-r,2.*-r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*r);}\n        f=cubeSDF(p+o+vec3(2.*-r,2.*-r,2.*-r),r);if(f<d){d=f;no=o+vec3(2.*-r,2.*-r,2.*-r);}\n        if(limit!=0.)II++;\n        o=no;\n        r/=3.;\n        \n        \n    }\n    //if(II>limit){\n    //    return cubeSDF(p+o,r);\n    //}\n    return d;\n    \n    \n    \n     \n}\n\nbool PLANE=false;\nfloat planeSDF( vec3 p, vec3 n,float d){\n  return dot(p,n)+d;\n}\nvec3 PLANE_NORMAL=vec3(0,1,0);\nfloat n(float t){\n    \n    float x=fract(t);\n    return 2.*x*x-2.*x;\n}\nfloat dn(float t){\n    float x=fract(t);\n    return 4.*x-2.;\n}\nfloat sinl(float t){\n    if(fract(t*0.5)>0.5)return n(t);\n    return -n(t);\n}\nfloat dsinl(float t){\n    if(fract(t*0.5)>0.5)return dn(t);\n    return -dn(t);\n\n}\nfloat rand(float t){t=fract(t*.1031);t*=t+33.33333333;return  fract(t);}\nfloat stars(vec3 p){\n    p.y-=iTime;\n    float d=400.-length(p);\n    if(d<3.0)\n    if(d>-3.0){\n        vec3 o=p;\n        p=mod(p-2.,4.)-1.-sinl(10.*p.y+10.*p.x+10.*p.z);\n        return length(p)-0.1;\n    }\n    return abs(d);\n\n}\n#define PI 3.141592674\n#define transform() \\\n    float a=sinl(p.y*0.2);\\\n    p*=mat3(cos(a),0,sin(a),\\\n            0,1,0,\\\n            -sin(a),0,cos(a));\\\n    p.xz+=1.;\\\n    a=p.y*0.5;\\\n    p*=mat3(cos(a),0,sin(a),\\\n            0,1,0,\\\n            -sin(a),0,cos(a));\\\n    p.y=mod(p.y,2.0)-1.0\nvec2 sceneSDF(vec3 p, float limit){\n    float strs=stars(p);\n    transform();\n    if(limit<1.){\n        float mng=mengerSDF(p,limit);\n        if(mng<strs)return vec2(mng,0.);\n        return vec2(strs,1.);\n    }else return vec2(mengerSDF(p,limit),0.);\n\n\n}\nfloat getEplison(float dist,float R){\n    return clamp(5.*pow(dist*0.1,1.1)*R,0.00000001,0.1);\n}\nvec3 rayMarch(vec3 o, vec3 d, float start, float end, int max_steps, bool for_lights){\n    float R=1.0/length(iResolution.xy);\n    float depth = start;\n    float fd= 0.0005;\n    float limit=0.0;\n    bool a_bool=false;\n    if(for_lights)limit=MENGER_LIGHT_DENSITY;\n    for (int i = 0; i < max_steps; i++) {\n        \n        vec2 dist = sceneSDF(o + depth * d, limit);\n        if(dist.y==0.&&!a_bool&&dist.x<0.0005){\n            fd=getEplison(depth+dist.x,R);\n            a_bool=true;\n            //fd=0.0001;\n            //if(!for_lights)limit=round(2./dist.x);\n        }\n        else if (dist.x < fd){\n            //if(dist.y>0.9)\n            return vec3(depth,dist.y,fd);\n        }\n        depth += dist.x*0.5;\n        if (depth >= end)return vec3(end,0,fd);\n    }\n    return vec3(end,0,fd);\n}\n\n\nvec3 normal(vec3 p, float n){\n    return normalize(vec3(sceneSDF(vec3(p.x+n,p.yz),0.).x-sceneSDF(vec3(p.x-n,p.yz),0.).x,\n                sceneSDF(vec3(p.x,p.y+n,p.z),0.).x-sceneSDF(vec3(p.x,p.y-n,p.z),0.).x,\n                sceneSDF(vec3(p.xy,p.z+n),0.).x-sceneSDF(vec3(p.xy,p.z-n),0.).x\n           ));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSDF(ro + rd*t, MENGER_LIGHT_DENSITY).x;\n        if( h<mint*0.1 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n        \n    }\n    return res;\n}\nfloat light_func(vec3 p, vec3 light, bool shadows){\n    float len=dot(light-p,light-p);\n    float f=1.0/len;\n    if(shadows){\n        float y=rayMarch(p,normalize(light-p),0.01,100.,128,true).x;\n        if(y<len)return 0.;\n    }\n    if(f<0.)return 0.;\n    return f;\n}\nfloat dist_light_func(vec3 p, vec3 normal, vec3 light,bool shadows){\n    light=normalize(light);\n    float len=dot(normal,light);\n    float f=len;\n    if(PLANE)f+=10.*pow(len,15.);\n    if(shadows){\n        float k=4.;\n        if(PLANE)k=64.;\n        f*=softShadow(p,light.xyz, 4.,128.,k);\n    }\n    if(f<0.)return 0.;\n    return f;\n}\n#define world vec3(0.0001,0.001,0.001*(uv.y+0.7))\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.rgb=vec3(0);\n    //this gives it time\n    if(iTime>0.1){\n        vec2 mouse=iMouse.xy/iResolution.xy;\n        if(iMouse.x==0.)mouse+=1.;\n        else mouse+=0.4;\n        vec3 col=hue(mod(iTime*COLOR_SPEED,1.0));\n        \n        float dist=(sin(0.25*iTime)*0.3+2.)*8.3*(pow(mouse.y,4.)+0.1);\n        vec3 o=vec3(sin(iTime-mouse.x*6.)*dist,iTime,cos(iTime-mouse.x*6.)*dist);\n\n\n        vec2 uv = (fragCoord/iResolution.xy-0.5)*normalize(iResolution.xy);\n        vec3 d=normalize(vec3(uv,1.1));\n        vec3 a = vec3(normalize(-o.xz),0);\n        a=vec3(a.x,0,a.y);\n        vec3 b = cross(a, vec3(0,1,0));\n        vec3 c = cross(b, a);\n        mat3 cm=mat3(b,c,a);\n        d*=cm;\n        vec3 f=world;\n        d=normalize(d);\n        vec3 t=rayMarch(o,d,0.0018,far,MAX_STEPS, false);\n        vec3 p=o+d*t.x;\n        if (t.x<far){\n            \n            vec3 albedo=vec3(0);\n            int NG,SG;\n            if(t.y>0.9){\n                NG=1;\n                SG=1;\n            }\n            else{\n                NG=9;\n                SG=3;\n            \n            }\n            \n            if(t.y<0.1){\n#ifdef AA\n                for(int i=0;i<NG;i++){\n                    d=normalize(vec3(uv,1.1));\n                    uv = ((fragCoord+0.1*vec2(i/SG,i%SG))/iResolution.xy-0.5)*normalize(iResolution.xy);\n                    d*=cm;\n                    d=normalize(d);\n                \n#endif\n                    p=o+d*t.x;\n                    f=world;\n                    \n                    vec3 N;\n                    f*=albedo;\n                    albedo=vec3(0.04,0.1,0.2);\n                    N=normal(p,t.z);\n\n                    float l=dist_light_func(p,N,vec3(0,1,0.5),true);\n                    f.rgb+=albedo*2.*vec3(0.2,0.15,0.15)*l;\n                    f.rgb+=0.1*pow(l,10.);\n\n                    l=dist_light_func(p,N,vec3(0,1,-0.5),true);\n                    f.rgb+=albedo*2.*vec3(0.2,0.15,0.15)*l;\n                    f.rgb+=0.1*pow(l,10.);\n                    \n                    vec3 o=p;\n                    transform();\n                    float Q=1.0/dot(p.xz,p.xz);\n                    //f.rgb+=vec3(1.,0.01,0.001)*albedo*Q;\n                    f.rgb+=col*albedo*Q;\n                    p=o;\n\n                    //f.rgb=N*0.5+0.5;\n#ifdef AA\n                    fragColor.rgb+=(1./float(NG))*f;\n                }\n                \n#endif\n                \n            }else{\n                 \n                 /*f+=rand(d.x*100.)*vec3(0,1,0.2);\n                 f+=rand(d.y*99.+d.x*98.)*0.5;\n                 f+=rand(d.y*99.+d.x*98.)*0.5;\n                 f+=(rand(d.x*99.+d.y*98.)*2.-1.)*vec3(2,0.02,0);*/\n                 fragColor.rgb=f;\n            \n            }\n\n\n        }\n#ifdef AA\n        else{\n            fragColor.rgb=world;     \n        }\n#endif \n#ifndef AA\n        fragColor.rgb=f;\n#endif\n\n\n        fragColor.rgb=sqrt(fragColor.rgb);\n        fragColor.rgb-=length(mod(fragCoord,3.))*0.01;\n        \n    }\n}","name":"Image","description":"","type":"image"}]}