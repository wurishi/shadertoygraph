{"ver":"0.1","info":{"id":"lXlGWH","date":"1707419742","viewed":84,"name":"Vornoi by chatgpt","username":"apopovic","description":"its based on the work of\nhttps://www.shadertoy.com/view/Nddfz7","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["vornoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Perlin noise function for displacement and frequency variation\nfloat perlinNoise(vec2 P) {\n    return fract(sin(dot(P, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 RGBToVec3Color(vec3 rgb) {\n    return rgb / 255.0;\n}\n\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Function to convert from HSV to RGB\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Updated function to get the nth harmonious color given an original HSV color and the total number of colors\n// Assumes hue in hsv_org.x is in the range [0, 1]\nvec3 GetHarmoniousColor(vec3 hsv_org, int totalColors, int colorIndex) {\n    float angleStep = 1.0 / float(totalColors); // Fraction of the full hue circle\n    float newHue = mod(hsv_org.x + angleStep * float(colorIndex), 1.0); // Wrap hue within [0, 1]\n    vec3 hsv_new = vec3(newHue, hsv_org.y, hsv_org.z);\n    return hsv2rgb(hsv_new); // Convert the new HSV color back to RGB\n}\n\n\n\n// Function to determine cell color based on its grid position\nvec3 getColor(int i, int j) {\n    // Example starting with an RGB color and converting to HSV\n    vec3 start_color_rgb = vec3(250, 170, 133); // Example RGB color\n    vec3 start_color = rgb2hsv(RGBToVec3Color(start_color_rgb)); // Convert to HSV\n    \n    int n = 4; // Total number of colors\n    int idx = (i * 2 + j * 3) % 4; // Use a more complex pattern to determine color\n    if (idx == 0) return GetHarmoniousColor(start_color,n,0); // Red\n    if (idx == 1) return GetHarmoniousColor(start_color,n,1);\n    if (idx == 2) return GetHarmoniousColor(start_color,n,2);\n    return GetHarmoniousColor(start_color,n,3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    const int n = 10; // Grid width\n    const int m = 10; // Grid height\n    vec2 gridSize = vec2(1.0 / float(n), 1.0 / float(m));\n\n    float closestDist = 10000.0;\n    vec3 col = vec3(0);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            // Initial grid position\n            vec2 gridPos = (vec2(float(i), float(j)) + 0.5) * gridSize;\n\n\n\n            float dmin = 1000.0; \n            \n            float movement_speed = 0.1;\n            float sin_movement_ampl = 1.0;\n            const float noiseStrength = 0.99; // If you want a fixed value inside the shader\n            \n            \n            vec2 noiseOffset = perlinNoise(gridPos * 25.0) * noiseStrength * gridSize; // Adjusted displacement\n            \n\n\n            // Unique sine frequencies for each cell based on its index and perlin noise\n            float sinFreqX = perlinNoise(vec2(float(i), float(j)) * 0.1) * movement_speed;\n            float sinFreqY = perlinNoise(vec2(float(j), float(i)) * 0.1) * movement_speed;\n            vec2 sinOffset = vec2(sin(iTime * sinFreqX + float(i)) * sin_movement_ampl, sin(iTime * sinFreqY + float(j)) * sin_movement_ampl); // Varied movement\n\n            // Dynamic position considering both noise displacement and sine movement\n            vec2 dynamicPos = gridPos + noiseOffset + sinOffset;\n\n            // Calculate distance to this cell's dynamically adjusted center\n            float dist = distance(uv, dynamicPos);\n            \n\n\n            if(length(dynamicPos - uv) < dmin){\n               dmin = length(dynamicPos - uv); \n            }\n            \n\n            if (dist < closestDist) {\n                closestDist = dist;\n                col = getColor(i, j)-dmin; // Determine color based on adjusted grid position\n            }\n        }\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}