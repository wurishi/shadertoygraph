{"ver":"0.1","info":{"id":"NtGcDK","date":"1666331757","viewed":134,"name":"CRT Test 12.5","username":"Makeavoy","description":"fullscreen!\n\nPixels are divided by rgb to separate \"lights\" in the screen, in this iteration a higher luminance merges the pixel lights more easily.\n\nnow features glitchy scan line shifting, screen curvature, and a turning-on animation\n\nVery WIP","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pixel","crt","weird"],"hasliked":0,"parentid":"NtVyR3","parentname":"CRT Test 12"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RESOLUTION 128.\n#define LOW_RANGE 0.05\n#define HIGH_RANGE 0.6\n#define DARK_FACTOR 0.8\n#define LUMEN_THRESHOLD .0\n#define GLITCHY 3.\n\n\nvec4 findSplit(vec2 uv, vec2 res2,vec2 offset){\n    vec2 i=(offset+floor(uv*res2))/res2;\n    if(i.x<0. || i.x>1.){\n    return vec4(0.,0.,0.,1.);\n    }\n    vec4 tex = texture(iChannel0, i);\n    float lum=(0.2126*tex.r + 0.7152*tex.g + 0.0722*tex.b);\n    float value=smoothstep(LOW_RANGE,HIGH_RANGE,1.-lum);\n    float v=min(value,1.);\n    \n    //first factor to determine how much rgb pixels split up\n    //1. is complete seperation, 0. is merged\n    float split=max(.33,v);\n    return vec4(tex.xyz,split);\n}\n\nvec2 path(vec2 uv, vec2 res,vec3 mask,vec2 shift){\n\n    vec4 v=findSplit(uv,res,vec2(0.,0.));\n    vec4 vl=findSplit(uv,res,vec2(-1.,0.));\n    vec4 vr=findSplit(uv,res,vec2(1.,0.));\n    float split=v.w;\n    float split_l=vl.w;\n    float split_r=vr.w;\n    \n    \n    \n    vec2 c=mod(uv+shift,1./res)*res;\n    \n    \n    float full=mask.x*v.x+mask.y*v.y+mask.z*v.z;\n    \n    float total_split=split;\n    if(c.x>0.75){\n        float f=(1.-(c.x-0.75)/.5);\n        total_split=split*f+split_r*(1.-f);\n        float side=mask.x*vr.x+mask.y*vr.y+mask.z*vr.z;\n        full=full*f+side*(1.-f);\n    }else if(c.x<0.25){\n        float f=(c.x/.5)+0.5;\n        //total_split=smoothstep(split_l,split,);\n        float side=mask.x*vl.x+mask.y*vl.y+mask.z*vl.z;\n        total_split=split*(f)+split_l*(1.-f);\n        full=full*f+side*(1.-f);\n    }\n    \n    \n    float pixel_size=(DARK_FACTOR+1.-total_split)*1. ;\n    \n    float a=1.;\n    if(total_split>LUMEN_THRESHOLD){\n     a=(0.5-abs(c.y-0.5))*pixel_size*.2; //.2\n    }\n    a*=16.;\n    return vec2(a,full);\n            \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float AR = iResolution.x / iResolution.y;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n            \n    \n    //======START tv to glass curvature===\n    const float corner_harshness=1.2;\n    const float corner_ease=4.;\n    \n    float vv=2.-min(mod(iTime,10.),2.);\n    //float vv=cos(iTime*1.)*2.;\n    float fade=max(pow(vv,16.),1.);\n    fade=1.;\n    \n    float xx=(abs(uv.x -0.5)*corner_harshness);\n    float yy=(abs(uv.y -0.5)*corner_harshness);\n    float rr=(1.+pow((xx*xx+yy*yy),corner_ease));\n    vec2 tuv=(uv-0.5)*rr+0.5;\n    tuv=clamp(tuv,0.,1.);\n    uv=tuv;\n    //========END=========================\n    \n    if(  uv.x>0. && uv.x<1. && uv.y>0. && uv.y<1.){\n    \n        \n    \n        //===== START additional curvature for glass to allow fade in out but keep glass background\n        yy=(abs(uv.y -0.5)*corner_harshness)*fade;\n        rr=(1.+pow((xx*xx+yy*yy),corner_ease));\n        tuv=(uv-0.5)*rr+0.5;\n        tuv=clamp(tuv,0.,1.);\n        uv=tuv;\n        //===END==========================\n        \n        if(  uv.x>0. && uv.x<1. && uv.y>0. && uv.y<1.){\n\n            \n            //flicker\n            uv+=sin(min(mod(iTime,1.),2.)*2000.)/10000.;\n\n            //resolution factor\n            float res=min(RESOLUTION,iResolution.x);\n            vec2 res2=vec2(res*.5,res/AR);\n            vec2 res3=res2;\n            vec2 res4=res2;\n            \n            \n            \n             float shift=1./res;\n\n\n            //vec2 pre_i=floor(uv*res2);\n            //vec2 i=pre_i/res2;\n\n            vec2 i=floor(uv*res2)/res2;\n            vec4 tex = texture(iChannel0, i);\n            float lum=(0.2126*tex.r + 0.7152*tex.g + 0.0722*tex.b);\n            float value=smoothstep(LOW_RANGE,HIGH_RANGE,1.-lum);\n            float v=min(value,1.);\n\n\n            //first factor to determine how much rgb pixels split up\n            //1. is complete seperation, 0. is merged\n            float split=max(.33,v);\n            \n            ////===== START scan lines\n            float L=0.01*cos(uv.x*1.2+iTime*20.);\n            float wave=cos(6.28*smoothstep(i.y,L,L+0.05))/5.;\n            \n           \n            float scanny=cos(1.57+3.14*(.2-wave));\n            float vvv=2.*scanny*cos(uv.x*16.+iTime*16.)/res;\n            //========== END\n\n           vec2 r=path(uv,res2,vec3(1.,0.,0.),vec2(0.,vvv)); //(uv.y*(uv.x+iTime/2.)*2.)*4.\n           float red=r.y;\n           float ar=r.x;\n\n            vec2 uv2=uv;//+vec2(-split*0.8/res,0.);\n            vec2 uv3=uv;//+vec2(-split*1.6/res,0.);\n            \n            //vec2 pushy=vec2(0.,cos((uv.x+iTime)*10.)*cos(uv.x*64. +iTime*32.)/2.);\n            \n            vec2 g=path(uv2,res3,vec3(0.,1.,0.),vec2(0.,0.));\n            vec2 b=path(uv3,res4,vec3(0.,0.,1.),vec2(0.,-vvv));\n            \n            float ag=g.x;\n            float green=g.y;\n            float ab=b.x;\n            float blue=b.y;\n             \n            // Time varying pixel color\n            vec3 col = vec3(red*ar,green*ag,blue*ab); //vec3(r);//\n\n            fragColor = vec4(col,1.);//vec4(cos(i2.x*100.),1.0,1.,1.0);\n          \n        }else{\n            fragColor=vec4(0.,0.,0.,1.);\n        }\n    }else{\n        float vx=abs(uv.x-0.5);\n        float vy=abs(uv.y-0.5);\n        float r=min(abs(vx-vy),0.25);//log(1./sqrt(vx*vx+vy*vy));\n        fragColor=vec4(r,r,r,1.);\n    }\n}","name":"Image","description":"","type":"image"}]}