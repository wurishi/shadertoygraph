{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// ***************************************//\n// Basketball, by Kleber A Garcia, 2014 (c)\n// ***************************************//\n\n\nconst vec4 BALL = vec4(0.0,0.0,1.0,1.4);\nconst vec3 LIGHT = vec3(2.0, 0.4, -0.5);\nconst vec3 LIGHT2 = vec3(-2.0, 0.4, 0.9);\nconst vec3 LIGHT3 = vec3(-20.0, 4.4, 10.3);\nconst vec3 FLOOR_AMB = vec3(0.65,1.4,0.5);\nconst vec3 CEIL_AMB = vec3(0.95,0.4,0.40);\n#define PI 3.141596\n#define TWO_PI (2.0*PI)\nfloat mat(vec4 ball, vec3 pos, out int material)\n{\n    //try sphere first\n   \tfloat dist = length(ball.xyz - pos) - ball.w;\n  \n    material = 0;\n    \n    return dist;\n}\nvec2 getUv(vec3 normal)\n{\n    vec2 xzNorm = normalize(normal.xz);\n    return vec2((acos(xzNorm.x) / TWO_PI), atan( normal.y/( length(normal.xz) ) ) / TWO_PI);\n}\nvec3 tweakNormal(vec3 normal, float freq, float blending)\n{\n    vec2 uv = getUv(normal);\n    float s = sin(uv.x * freq);\n    float c = cos(uv.y * freq);\n    normal.x += blending*s;\n    normal.z += blending*c;\n    return normalize(normal);\n}\nvoid pointLight(vec3 normal, vec3 pos, vec3 view, vec3 lightPos, out vec3 diffuse, out vec3 spec, float specPow)\n{\n    vec3 lightDir = normalize(lightPos - pos);\n    diffuse = vec3(clamp(dot(lightDir, normal), 0.0, 1.0));\n    \n    vec3 h = reflect(-view, normal);\n    float nDoth = clamp(dot(-lightDir, h), 0.0, 1.0);    \n    spec = vec3(pow(nDoth, specPow));\n    spec = mix(spec, vec3(pow(nDoth, 32.0)), 0.4);\n    \n}\nvoid scene(vec4 ball, vec3 ray, vec3 pos, out vec3 p, out vec3 col)\n{\n    p = pos;\n    int material = -1;\n    for (int it = 0; it < 30; ++it)\n    {\n    \tint m = 0;\n       \tfloat dist = mat(ball, p, m);\n        if (dist < 0.001) { material = m; }\n        else { p = p + dist * ray;}\n    }    \n    \n    if (material == -1) { col = vec3(0,0,0);  }\n    else if (material == 0)\n    {\n        vec3 normal = normalize(p - ball.xyz);\n        \n        vec3 alb = vec3(0.4, 0.08, 0.0);\n        vec3 stripsAlb =vec3(0.01,0.01,0.01); \n\t\tfloat isStrips = 1.0;\n\t\tisStrips *= smoothstep( 0.02, 0.03, abs(normal.x) );\n\t\tisStrips *= smoothstep( 0.02, 0.03, abs(normal.y) );\n\t\tisStrips *= smoothstep( 0.05, 0.06, abs(abs(normal.x) - 2.0*normal.y*normal.y - 0.15) );\n\t\tisStrips = 1.0 - isStrips;\n        vec3 occ = vec3(1.0 - pow(clamp(-p.y, 0.0, 1.0), 4.0));\n        float nDotv = dot(normal, -ray);\n        float fresnel = clamp(0.4 + pow((1.0 - clamp(nDotv, 0.0, 1.0)), 9.0), 0.0, 1.0);\n\t\tfloat roughness = 2.0;\n        float specForce = 1.0;\n        normal = mix(tweakNormal(tweakNormal(normal,3000.0,0.2), 100.0, 0.05), normal, pow(clamp(isStrips+(1.0 - clamp(nDotv, 0.0, 1.0)),0.0,1.0),0.5));\n        float camSpec = 0.2*clamp(pow(clamp(nDotv, 0.0, 1.0), 1.0), 0.0, 0.3);\n        nDotv = dot(normal, -ray);\n        alb = mix(alb, stripsAlb, isStrips);\n        \n        roughness = mix(roughness, 46.0, isStrips);\n        specForce = mix(specForce, 1.5, isStrips);\n\n        vec3 diffuse = vec3(0);\n        vec3 spec = vec3(0);\n        pointLight(normal, p, ray, LIGHT, diffuse, spec, roughness);\n        vec3 diffuse2 = vec3(0);\n        vec3 spec2 = vec3(0);\n        pointLight(normal, p, ray, LIGHT2, diffuse2, spec2, roughness);\n        diffuse += diffuse2;\n        spec += spec2;\n        pointLight(normal, p, ray, LIGHT3, diffuse2, spec2, roughness);\n        diffuse += diffuse2;\n        spec += spec2;\n        vec3 amb = mix(FLOOR_AMB, CEIL_AMB, clamp(2.0*p.y,0.0,1.0));\n        col = alb*(occ*diffuse + amb) + occ*specForce*(spec+camSpec)*fresnel;//spec + alb * (clamp(dot(normal, lightDir),0.0,1.0) + occ*AMB) + occ*0.4*pow((1.0 - clamp(dot(normal, -ray), 0.0, 1.0)), 9.0);\n\n    }\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 screen = uv * 2.0 - 1.0;\n    screen.x *= iResolution.x / iResolution.y;\n    vec3 target = vec3(screen.x, screen.y, 0.0);\n    float bounce = pow(0.5*sin(iTime * 10.0) + 0.5 ,0.4);\n    vec4 ball = vec4(BALL.xyz + vec3(0,bounce*1.0,1.0), BALL.w);\n \tvec3 cam = vec3(0,0,-5.0);\n    vec3 ray = normalize(target - cam);\n    vec3 dist = cam - ball.xyz;\n\tfloat s = sin(iTime);\n    float c = cos(iTime); \n    ray = vec3(ray.x*c + ray.z*s, ray.y, ray.x *(-s) + ray.z*c);\n    dist = vec3(dist.x*c + dist.z*s, dist.y, dist.x * (-s) + dist.z*c);\n    \n    cam = dist + ball.xyz;\n\n    vec3 col = vec3(0,0,0);\n    vec3 p = vec3(0,0,0);\n    scene(ball,ray, cam, p, col);\n   \n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dS3zy","date":"1415765156","viewed":1718,"name":"Basketball","username":"Kecho","description":"Procedural basketball with procedural normals and some fun lighting.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["sports","basketball"],"hasliked":0,"parentid":"","parentname":""}}