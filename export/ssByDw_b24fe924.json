{"ver":"0.1","info":{"id":"ssByDw","date":"1643602898","viewed":190,"name":"Menger sponge with six faces","username":"ukeyshima","description":"Menger sponge with six faces","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926;\nconst vec3 CAMERA_POS = vec3(0.0, 0.0, -2.0);\nconst vec3 DIRECTIONAL_LIGHT_DIR = normalize(vec3(-1.0, -1.0, 1.0));\nconst vec3 AMBIENT_LIGHT_COLOR = vec3(0.05);\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 foldRotate(vec2 p, float s) {\n    float t = PI * 2.0 / s;\n    float a = -atan(p.x, p.y) + PI / 2.0 + t / 2.0;\n    a = mod(a, t) - t / 2.0;\n    a = abs(a);\n    return length(p) * vec2(cos(a), sin(a));\n}\n\nfloat mengerSponge(vec3 p0) {\n    vec4 p = vec4(p0, 1.0);\n    for (int n = 0; n < 3; n++) {\n        p.xy = foldRotate(p.xy, 6.0);    \n        p.yz = foldRotate(p.yz, 6.0);    \n        p = abs(p);\n        p *= 3.0; \n        p.xyz -= 2.0;\n        p.z += 1.0;\n        p.z = abs(p.z);\n        p.z -= 1.0;\n    }\n    return sdBox(p.xyz, vec3(1.0))/p.w;\n}\n\nfloat distFunc(vec3 p){\n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n\tif (iMouse.z>0.) {\n        p.xy = rotate2d(mouse.x * 3.0)*p.xy;\n        p.yz = rotate2d(mouse.y * 3.0)*p.yz;\n\t}else{\n        p.xy = rotate2d(iTime)*p.xy;\n        p.yz = rotate2d(iTime)*p.yz;\n    }\n    return mengerSponge(p);\n}\n\nvec3 estimateNormal(vec3 p){\n    float d = 0.001;\n    vec3 dX = vec3(d, 0.0, 0.0);\n    vec3 dY = vec3(0.0, d, 0.0);\n    vec3 dZ = vec3(0.0, 0.0, d);\n    return normalize(vec3(\n        distFunc(p + dX) - distFunc(p),\n        distFunc(p + dY) - distFunc(p),\n        distFunc(p + dZ) - distFunc(p)\n    ));\n}\n\nvec3 rayMarching(vec3 rayPos, vec3 rayDir){\n    for(int i = 0; i < 64; i++){\n        float d = distFunc(rayPos);\n        if(abs(d) < 0.001){\n            vec3 normal = estimateNormal(rayPos);\n            float diffuseReflection = max(dot(normal, -DIRECTIONAL_LIGHT_DIR), 0.0);\n            return vec3(diffuseReflection) + AMBIENT_LIGHT_COLOR;\n        }\n        rayPos += rayDir * d;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n    vec3 color = vec3(rayMarching(CAMERA_POS, rayDir));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}