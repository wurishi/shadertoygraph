{"ver":"0.1","info":{"id":"ssGSDD","date":"1663494074","viewed":260,"name":"Transparent soundcloud","username":"munrocket","description":"Multiple transparencycy experiment","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["transparency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License. Â© 2021 munrocket\n\n#define MAX_STEPS 220.\n#define MAX_DIST 10.\n#define DIFF_EPS 0.005\n\nfloat map(vec3 pos) {\n    float k = 0.1;\n    float d = length(vec3(abs(pos.x), pos.yz) - vec3(0.55, -0.15, 0.)) - 0.48;\n    float d2 = opUnion(d, length(pos - vec3(0., -0.18, 0.)) - 0.45, k);\n    float d3 = opUnion(d2, length(pos - vec3(-0.28, 0.18, 0.)) - 0.4, k);\n    float d4 = opUnion(d3, length(pos - vec3(0.25, 0.35, 0.)) - 0.4, k);\n    return  opSubstr(d4, max(0.05+pos.x, -abs(.04*pos.y*pos.y+0.0175) + abs(.04 - 0.1*fract(0.16+pos.x/0.16))), 0.01);\n}\n\nvec3 normal(vec3 pos) {\n    const vec2 e = vec2(DIFF_EPS, 0.);\n    return normalize(vec3(  \tmap(pos + e.xyy) - map(pos - e.xyy),\n              \t\t\t\t  \tmap(pos + e.yxy) - map(pos - e.yxy),\n              \t\t\t\t\tmap(pos + e.yyx) - map(pos - e.yyx)));\n}\n\nvec3 getBackground(vec2 uv) {\n    return vec3(119., 159., 191.)/250. + 0.3 * exp(0.5 - length(uv)/2.) ;\n}\n\nvec3 getDiffuse(vec3 p) {\n  p.x -=  .2;\n  float a = atan(p.y, p.x) + 5.;\n  float r = length(p.xy);\n  float s = r / (r * r + .3);\n  return sqrt(sin(vec3(a,a+1.,a+3.))*.5 * s +.5);\n}\n\nvec3 march(vec3 ro, vec3 rd, vec2 uv) {\n    float I, t, dt, t0, mapSign = 1.;\n    vec3 col0, col = getBackground(uv);\n    t = MAX_DIST;\n    vec3 p = ro + t * rd;\n    for(float i = 0.; i < MAX_STEPS; i++) {\n        dt = map(p);\n        t -= max(DIFF_EPS, abs(dt));\n        p = ro + t * rd;\n        if (sign(dt) != mapSign) {\n            if (mapSign < 0.) {\n                float si = t - t0;\n                float off = (mapSign < 0.) ? 1.8 * (1. - exp(si*1.9)) : 0.;\n                col0 = mix(col0, getDiffuse(p), .8);\n                col -= (1.-col0) * off;\n            }\n            I++;\n            mapSign = sign(dt);\n            t0 = t;\n            col0 = getDiffuse(p);\n        }\n        if (t < 0.) break;\n    }\n    if (I > 0.) {\n        p = ro + t0 * rd;\n        vec3 N = normal(p);\n        float r0 = 0.15;\n        float schlick = r0 + (1.0 - r0) * pow(1. + dot(rd, N), 4.);\n        col = mix(col, getBackground(uv), schlick);\n    }\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 uv = 2.0*(fragCoord-iResolution.xy*0.5)/min(iResolution.x,iResolution.y);\n    vec3 dir = normalize(vec3(uv, -2.));\n    vec3 camera = vec3(0., 0.00, 2.);\n    \n    vec4 mouse = qmouse(iMouse, iResolution, iTime, 0.1);\n    dir = rotate(dir, mouse);\n    camera = rotate(camera, mouse);\n    \n    vec3 col = march(camera, dir, uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI   3.1415926\n#define M_2_PI 6.2831853\n#define M_PI_2 1.5707963\n#define M_PI_4 0.7853982\n\n/* quaternions */\n\nvec4 qmult(vec4 p, vec4 q) {\n    vec3 pv = p.xyz, qv = q.xyz;\n    return vec4(p.w * qv + q.w * pv + cross(pv, qv), p.w * q.w - dot(pv, qv));\n}\n\nvec4 qrotor(vec3 axis, float phi) {\n    return vec4(sin(phi*0.5) * axis, cos(phi*0.5));\n}\n\nvec4 qmouse(vec4 iMouse, vec3 iResolution, float iTime, float initRotation) {\n    vec2 init = vec2(0.5 + 0.25*initRotation * sin(iTime), 0.5 + initRotation * cos(iTime));\n    vec2 mouse = mix(init, iMouse.xy / iResolution.xy, step(0.0027, clamp(iMouse.y, 0., 1.)));\n    vec4 rotY = qrotor(vec3(0., 1., 0.), M_PI - M_2_PI * mouse.x);\n    vec4 rotX = qrotor(vec3(1., 0., 0.), M_PI * mouse.y - M_PI_2);\n    return qmult(rotY, rotX);\n}\n\nvec3 rotate(vec3 point, vec4 qrotor) {\n    vec3 rv = qrotor.xyz;\n    return qmult(qrotor, vec4(point * qrotor.w - cross(point, rv), dot(point, rv))).xyz;\n}\n\n/* SDF functions */\n\nfloat opUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSubstr(float d2, float d1, float k) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h ) + k*h*(1.0-h);\n}\n\n","name":"Common","description":"","type":"common"}]}