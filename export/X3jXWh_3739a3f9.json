{"ver":"0.1","info":{"id":"X3jXWh","date":"1710684509","viewed":97,"name":"CandyTunnel VFX","username":"Eboman","description":"Mouse x = FX amount\nMouse y = FX parameter control\nPress key 1 to 8 on keyboard = FX parameter on/off\nPress key Q to T on keyboard = Texture mode\nPress key A to G on keyboard = Pixel rotation mode","likes":7,"published":1,"flags":16,"usePreview":0,"tags":["tunnel","vfx","yummy","candy","wax","licorice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\nCONTROLS_________________:\n\nMouse x = FX amount\nMouse y = FX parameter control\nPress key 1 to 8 on keyboard = FX parameter on/off\nPress key Q to T on keyboard = Texture mode\nPress key A to G on keyboard = Pixel rotation mode\n\nFX parameters:\n1 = Candiness\n2 = Texture tile / zoom\n3 = Licoriceness\n4 = Licoricraziness level\n5 = End of tunnel darkness\n6 = Reflection on/off\n7 = Amplify\n8 = Stir it up\n\n\nCREDITS__________________:\n\nBased on the Wax Tunnel shader by aiekick  \nhttps://www.shadertoy.com/view/MsySWz\n\nRemixed into a video effect by:\nwww.eboman.com\n\n*/\n\n#define uMzero  (0.98-(iMouse.x/iResolution.x))\n#define uMone   (iMouse.y/iResolution.y) * kp(49) + (0. *(1.-kp(49))) \n#define uMtwo   (iMouse.y/iResolution.y) * kp(50) + (1. *(1.-kp(50)))\n#define uMthree ((iMouse.y/iResolution.y) * kp(51) + (0. *(1.-kp(51))))\n#define uMfour  (iMouse.y/iResolution.y) * kp(52) + (1. *(1.-kp(52)))\n#define uMfive  ((iMouse.y/iResolution.y) * kp(53) + (0.6 *(1.-kp(53))))\n#define uMsix   (iMouse.y/iResolution.y) * kp(54) + (0. *(1.-kp(54)))\n#define uMseven ((iMouse.y/iResolution.y) * kp(55) + (0. *(1.-kp(55))))\n#define uMeight ((iMouse.y/iResolution.y) * kp(56) + (0. *(1.-kp(56))))\n\n#define PI 3.1415926536\n#define POINT_FLARE\n//#define POSITIVE_DISPLACE\n\nfloat hash(float n){ return fract(cos(n)*76543.);}\nvec3 hash3(vec3 p){return normalize(vec3(hash(p.x), hash(p.y), hash(p.z)));}\n\nfloat kp(int k){\n    float kp = texelFetch( iChannel1, ivec2(k,2), 0 ).x;\n    return kp;\n}\n\nfloat expStep( float x, float k, float n ){\n    return exp( -k*pow(x,n) );\n}\n\nvec3 ifcrcl(vec3 fcolif, vec2 uvif, vec2 m, vec3 ifcolor, vec2 ifpos, int k, float korm){   \n    fcolif = mix( fcolif, ifcolor, \n        (1.-smoothstep(.3,.31,length(uvif-ifpos)*15.))*kp(k)*max(m.y,korm));\n    fcolif = mix( fcolif, ifcolor*kp(k)+.5-kp(k)/2., \n        (1.0-smoothstep(0.0,0.06,abs(length(uvif-ifpos)*15.-0.3))));\n    return fcolif;\n}\n        \nmat3 RotZ(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.2)*(5.*uMeight+1.), sin(t*0.2)*(5.*uMeight+1.)) * 2.;\n}\n\nvec2 df(vec3 p)\n{\n\tp.xy -= path(p.z);\n\tp *= RotZ(p.z*0.45);  \n\tp.xy *= sin(p.z + cos(p.z));\n\tfloat y = 1.72*uMzero - max(max(p.x, -p.x) *(75.*uMtwo) + p.y, -p.y);\n\tvec3 tex = textureLod(iChannel2, vec2(max(p.x, -p.x), p.z)*0.06, 0.0).rgb;\n\tfloat d = dot(tex, vec3(.71));\n#ifdef POSITIVE_DISPLACE\n    d *= -1.;\n#endif\n\tvec2 res = vec2(y+d, 1)*(25.*uMseven+1.);\n    return res;\n}\n\nvec3 nor( in vec3 pos, float prec )\n{\n\tvec3 eps = vec3( prec, 0., 0. );\n\tvec3 nor = vec3(\n\t    df(pos+eps.xyy).x - df(pos-eps.xyy).x,\n\t    df(pos+eps.yxy).x - df(pos-eps.yxy).x,\n\t    df(pos+eps.yyx).x - df(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat SubSurfaceScattering(vec3 surfPoint, vec3 lightPoint)\n{\n\tvec3 lightdir = normalize(lightPoint - surfPoint);\n\tfloat lightlen = length(lightPoint - surfPoint);\n\t\n\tvec3 rd = lightdir;\n\t\n\tconst float sssiter = 100.; \n\tfloat ms = lightlen / sssiter;\n\t\n\tvec3 p = surfPoint;\n\t\n\tfloat d = 0., s = 0.;\n\t\n\tfloat accum = 0.; \n\t\n\tfor (float i=0.;i<sssiter;i++)\n\t{\n\t\trd = refract(rd, hash3(normalize(lightPoint-p)), 0.4); \n\t\tp = surfPoint + rd * d;\n\n\t\tif (s < 0.) accum += ms ; \n\n\t\ts = df(p).x;\n\t\td += ms; \n\t}\n\t\n\treturn accum;\n}\n\nvec4 light(vec3 ro, vec3 rd, float d, vec3 lightpos, vec3 lc)\n{\n\tvec3 p = ro + rd * d;\n\tvec3 n = nor(p, 0.1);\n\tvec3 refl = reflect(rd,n);\n\t\t\n\tvec3 lightdir = normalize(lightpos - p);\n\tfloat lightlen = length(lightpos - p);\n\t\n\tfloat amb = 0.6;\n\tfloat diff = clamp( dot( n, lightdir ), 0.0, 1.0 );\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\tfloat spe = pow(clamp( dot( refl, lightdir ), 0.0, 1.0 ),16.);\n        \n\tvec3 brdf = vec3(0);\n\tbrdf += amb * vec3(0,0,0);\n\tbrdf += diff * 0.6;\n\tbrdf += spe * lc * 0.8;\n\t\n\treturn vec4(brdf, lightlen);\n}\n\nvec3 cam(vec2 uv, vec3 ro, vec3 cv, float t)\n{\n\tvec3 cu = normalize(vec3(0,1,0));\n  \tvec3 z = normalize(cv-ro);\n    vec3 x = normalize(cross(cu,z));\n  \tvec3 y= cross(z,x);\n  \treturn normalize(z + uv.x*x + uv.y*y);\n}\n\nvec3 DrawPointLight(vec3 ro, vec3 rd, float d, vec3 lp, float len, vec3 lc)\n{\n\tvec3 res = vec3(0);\n\tif (d>=len)\n\t{\n\t\tvec3 k = rd - normalize(lp-ro);\n\t\tres += lc * (len / 1000.) /dot(k, k);\n\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 3.;\n     \n    vec2 si = iResolution.xy;\n    vec2 uv = (2.*fragCoord-si)/si.y;\n\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    \n    float mx = iMouse.x/iResolution.x;\n    float my = pow(iMouse.y/iResolution.y, 0.5);\n    vec2 m = vec2(iMouse.x/iResolution.x, pow(iMouse.y/iResolution.y, 0.5));\n    \n    vec3 col = vec3(0.);\n    vec3 video = vec3(0.);\n    vec3 fcolif = vec3(0.);\n    vec3 finalwithcleanbeginning = vec3(0.);\n    \n    vec3 lpNear = vec3(path(t+0.55),t+0.55);\n    \n\tfloat k = (sin(t*0.3)*.5+.5);\n    vec3 lpFar = vec3(path(t+0.55 + 22.56*k),t+0.55 + 22.56*k);\n\t\n\tvec3 ro = vec3(path(t),t);\n  \tvec3 cv = vec3(path(t+0.1),t+0.1);\n\tvec3 rd = cam(uv, ro, cv, t);\n       \n\tfloat md = 100.;\n    float s = 1., so = s;\n    float d = 1.;\n\t\n\tconst float iter = 250.;\n    for(float i=0.;i<iter;i++)\n    {      \n        if (s<0.002*log(d*d)||d>md) break;\n        s = df(ro+rd*d).x;\n\t\td += s * (s>0.1?0.15:0.1);\n    }\n    \n\tif (d<md)\n\t{\n    \n\t\tvec3 p = ro+rd*d;\n        vec3 norm = nor(p, 0.001);\n        vec3 n = abs(norm);\n    \n    //--------------------------------------------------- Fun with p \n    \n    vec3 p2 = p;  \n    p2 = mix(p2, p2*RotZ(d), (uMone)*pow(uMzero, 3.));\n    \n        if (kp(65)==1.)     {p2 = mix(p2, p2*zrot(d/3.), 1.);} \n        else if (kp(83)==1.){p2 = mix(p2, p2*RotZ(d), 1.);}\n        else if (kp(68)==1.){p2 = mix(p2, p2*RotZ(p.z), d/5.);}\n        else if (kp(70)==1.){p2 = mix(p2, p2*RotZ(p.z), 1.);}\n        else if (kp(71)==1.){p2 = mix(p2, p2*RotZ(iTime), d/5.);}\n        else                {p2 = mix(p2, p2*RotZ(d), (uMone)*pow(uMzero, 3.));}\n   \n    //--------------------------------------------------- Fun with tex      \n    \n        vec4 videoXZ=texture(iChannel0, mix(uv2, fract(p2.xz*0.2), uMzero));\n        vec4 videoYZ=texture(iChannel0, mix(uv2, fract(p2.yz*0.2), uMzero));\n        vec4 videoXY=texture(iChannel0, mix(uv2, fract(p2.xy*0.2), uMzero));\n        \n    if (kp(81)==1.){video=videoYZ.rgb*n.x + videoXZ.rgb*n.y + videoXY.rgb*n.z;} \n    else if (kp(87)==1.){video=texture(iChannel0, mix(uv2, p2.xy*0.3+0.5, uMzero)).rgb;}\n    else if (kp(69)==1.){video=texture(iChannel0, mix(uv2, fract((p2*RotZ(PI)).xy*mix(0.2, d/40., d)), uMzero)).rgb;}\n    else if (kp(82)==1.){video=texture(iChannel0, mix(uv2, mix(uv2, fract(p2.xy*0.2), d/8.), uMzero)).rgb;}    //--cool\n    else if (kp(84)==1.){video=texture(iChannel0, mix(uv2, fract(p2.xy*d/40.), uMzero)).rgb;}    // kan wel weg\n    else                {video=texture(iChannel0, mix(uv2, mix(uv2, fract(p2.xy*0.2), n.z*0.8), uMzero)).rgb;}\n          \n    vec4 videoclean=texture(iChannel0, uv2);\n\n    //--------------------------------------------------- Fun with colors and light \n    \n    vec3 licorice2 = video.rgb * vec3(p.x/4.+fract(d*1.*(4.*uMfour))) * vec3(p.y/2.+fract(d*.4+.2));\n    //vec3 licorice1 = video.rgb * vec3(p.x/7.+0.9) * vec3(p.y/11.+0.9);\n    vec3 licoricevideo = mix(video.rgb, licorice2, uMthree * uMzero * (1.-uMeight));\n    \n    vec4 lightNear = light(ro, rd, d, lpNear, vec3(1));\n    float attenNear = 0.5 / lightNear.w; \n    vec3 videolight = (licoricevideo + pow(lightNear.rgb, vec3(1.5)) * attenNear * uMzero * kp(54)) * (1.25-(d*(uMfive/10.))-(0.25*(1.-uMfive)));\n    \n    vec3 videofinal = mix(video.rgb, videolight, 1.);\n    finalwithcleanbeginning = mix(videoclean.rgb, videofinal, max((1.-expStep((uMzero),30.,1.)), 0.));\n\n    fcolif = finalwithcleanbeginning.rgb;\n\n\t}\n    \n    vec2 uvif = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uvif -= 0.5; \n    uvif /= vec2(iResolution.y / iResolution.x, 1);\n    \n    // Interface Mouse.x\n    fcolif = mix( fcolif, vec3(0.,1.,1.), \n        (1.-smoothstep(.3,.31,length(uvif-vec2(-.84,.45))*15.))*(1.-mx) );\n    fcolif = mix( fcolif, vec3(0.,1.,1.), \n        (1.-smoothstep(0.,.06,abs(length(uvif-vec2(-.84,.45))*15.-.3))));\n    // Interface Mouse.y        \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,0.,0.), vec2(-.84,.38), 49, 0.);   \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,0.,0.), vec2(-.84,.31), 50, 0.);\n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,0.,0.), vec2(-.84,.24), 51, 0.);   \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,0.,0.), vec2(-.84,.17), 52, 0.);\n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,0.,0.), vec2(-.84,.10), 53, 0.);   \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,0.,0.), vec2(-.84,.03), 54, 1.);\n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,0.,0.), vec2(-.84,-.04), 55, 0.);   \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,0.,0.), vec2(-.84,-.11), 56, 0.);  \n    // Interface Tex mode select keys      \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,1.,0.), vec2(-.77,.38), 81, 1.);   \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,1.,0.), vec2(-.77,.31), 87, 1.);\n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,1.,0.), vec2(-.77,.24), 69, 1.);   \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,1.,0.), vec2(-.77,.17), 82, 1.);\n    fcolif = ifcrcl(fcolif, uvif, m, vec3(1.,1.,0.), vec2(-.77,.10), 84, 1.);   \n    // Interface Pix Rotate mode select keys  \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(0.,0.,1.), vec2(-.70,.38), 65, 1.);   \n    fcolif = ifcrcl(fcolif, uvif, m, vec3(0.,0.,1.), vec2(-.70,.31), 83, 1.);\n    fcolif = ifcrcl(fcolif, uvif, m, vec3(0.,0.,1.), vec2(-.70,.24), 68, 1.);\n    fcolif = ifcrcl(fcolif, uvif, m, vec3(0.,0.,1.), vec2(-.70,.17), 70, 1.);\n    fcolif = ifcrcl(fcolif, uvif, m, vec3(0.,0.,1.), vec2(-.70,.10), 71, 1.);\n\n    fragColor = vec4(fcolif.rgb,1);       \n       \t\n    // CandyTunnel VFX Basic+org ook nog toevoegen?\n}","name":"Image","description":"","type":"image"}]}