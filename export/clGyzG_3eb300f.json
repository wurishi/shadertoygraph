{"ver":"0.1","info":{"id":"clGyzG","date":"1700322611","viewed":79,"name":"gravitation field","username":"nayk","description":"gravitation, space,stars,galaxy","likes":5,"published":1,"flags":1,"usePreview":0,"tags":["space","galaxy","stars","gravitation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/* original https://www.shadertoy.com/view/3d2SWK https://www.shadertoy.com/view/lslyRn */\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n#define SURFDIST .001\n#define MAXSTEPS 200\n#define MAXDIST 20.\n#define TAU 6.2832\n\n#define USEDISC\n#define USESTREAM\n\nmat2 Rot(float a) {\n\tfloat s = sin(a), c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat N21(vec2 p) {\n    p = fract(p*vec2(123.34,345.35));\n    p += dot(p, p+34.53);\n    return fract(p.x*p.y);\n}\n\nfloat Noise(vec2 p) {\n\tvec2 gv = fract(p);\n    vec2 id = floor(p);\n    \n    gv = smoothstep(0.,1.,gv);\n    \n    float b = mix(N21(id+vec2(0,0)), N21(id+vec2(1, 0)), gv.x);\n    float t = mix(N21(id+vec2(0,1)), N21(id+vec2(1, 1)), gv.x);\n    \n    return mix(b, t, gv.y);\n}\n\nfloat Noise3(vec2 p) {\n    return \n        (Noise(p) + \n        .50*Noise(p*2.12*Rot(1.)) +\n        .25*Noise(p*4.54*Rot(2.)))/1.75;\n}\n\nvec3 GetRd(vec2 uv, vec3 ro, vec3 lookat, vec3 up, float zoom2, inout vec3 bBend) {\n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(up, f)),\n        u = cross(f, r),\n        c = ro + zoom2 * f,\n        i = c + uv.x*r + uv.y*u,\n        rd = normalize(i-ro);\n \t\n    vec3 offs = normalize(uv.x*r + uv.y*u);\n    bBend = rd-.1*offs/(1.+dot(uv,uv));\n    return rd;   \n}\n\nvec3 GetBg(vec3 rd) {\n\tfloat x = atan(rd.x, rd.z);\n    float y = dot(rd, vec3(0,1,0));\n    \n    float size = 10.;\n    vec2 uv = vec2(x, y)*size;\n    float m = abs(y);\n    \n    float side = Noise3(uv);\n    float stars = pow(Noise(uv*20.)*Noise(uv*23.), 10.);\n    \n    vec2 puv = rd.xz*size;\n    float poles = Noise3(rd.xz*size);\n    float stars2 = pow(Noise(puv*21.)*Noise(puv*13.), 10.);\n    \n    stars = mix(stars, stars2, m*m);\n    float n = mix(side, poles, m*m);\n    n = pow(n, 5.);\n    \n    vec3 nebulae = n * vec3(1., .7, .5);\n    \n    return nebulae + stars*4.;\n}\n\nfloat GetDist(vec3 p) {\n    float d = length(p)-.15;\n    \n    //d = min(d, max(length(p.xz)-2., abs(p.y)));\n    return d;\n}\n\nfloat GetDisc(vec3 p, vec3 pp) {\n\t\n    float t = iTime;\n    \n    // calculate plane intersection point\n    vec3 rd = p-pp;\t\t\t// local ray direction\n    vec3 c = pp + rd*pp.y;\t// intersection point\n    rd = normalize(rd)*.5;\n    p = c-rd;\n    rd *= 2.;\n    \n    // myeah this seemed like a good idea at some point... doesn't add as much as it should\n    float m = 0.;\n    const float numSamples = 3.;\n    for(float i=0.; i<1.; i+=1./numSamples) {\n    \tc = p + i*rd;\n        \n        float d = length(c.xz);\n    \tfloat l = smoothstep(3.5, .6, d);\n    \tl *= smoothstep(.1, .6, d);\n    \t\n        float x = atan(c.x, c.z);\n    \tl *= sin(x*floor(5.)+d*20.-t)*.3+.7;\n        m += l;\n    }\n    \n    return 1.5*m/numSamples;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; \n            p.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\t\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.; // dark matter, don't render near\n\t\t\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.02,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.005);\n\tfloat time=iTime*speed+.25;\n\n\tvec2 m = iTime/iResolution.xy;\n    \n    vec3 col = vec3(0);\n\t\n    vec3 ro = vec3(0, 0, -4.+sin(iTime*.2));\n    ro.yz *= Rot(m.y*TAU+iTime*.05);\n    ro.xz *= Rot(-m.x*TAU+iTime*.1);\n    \n    vec3 lookat = vec3(0);\n    float zoom2 = .8;\n    vec3 up = normalize(vec3(.5, 1,0));\n    vec3 bBend;\n    vec3 rd = GetRd(uv, ro, lookat, up, zoom, bBend);\n    vec3 eye = rd;\n    \n    float dS, dO;\n    float disc = 0.;\n    vec3 p=ro;\n    p += N21(uv)*rd*.05;\n    vec3 pp;\n    \n    float stream = 0.;\n    \n    for(int i=0; i<MAXSTEPS; i++) {\n        rd -= .01*p/dot(p,p);\t\t// bend ray towards black hole\n        \n        pp = p;\n        p += dS*rd;\n        \n        if(p.y*pp.y<0.)\n            disc += GetDisc(p, pp);\n        \n        float y = abs(p.y)*.2;\n        stream += smoothstep(.1+y, 0., length(p.xz))*\n            smoothstep(0., .2, y)*\n            smoothstep(1., .5, y)*.05;\n        \n        dS = GetDist(p);\n        dS = min(.05, dS);\n        dO += dS;\n        if(dS<SURFDIST || dO>MAXDIST) break;\n    }\n    \n   \n    \n    \n    \n   \n \n   \n\tvec3 from=vec3(1.,.5,0.5)+p ;\n    from.xz=rotate(uv,iTime/10.-length(uv)*10.01);\n\tfrom+=vec3(iTime*0.1,iTime*0.1,iTime*0.1);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n}\n","name":"Image","description":"","type":"image"}]}