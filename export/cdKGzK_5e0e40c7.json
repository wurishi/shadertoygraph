{"ver":"0.1","info":{"id":"cdKGzK","date":"1692288980","viewed":81,"name":"CRT Monitor Guy","username":"andrew741","description":"A CRT monitor guy who's animated.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["crt","shader","monitor","pixels","character","computer","guy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// from another shadertoy shader (same one as the gradient noise as this is a part of it)\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n// from https://www.shadertoy.com/view/tt23WW\nfloat dstLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 v = a, w = b;\n    \n    float l2 = pow(distance(w, v), 2.);\n    if(l2 == 0.0) return distance(p, v);\n    \n    float t = clamp(dot(p - v, w - v) / l2, 0., 1.);\n    vec2 j = v + t * (w - v);\n    \n    return distance(p, j);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the current time (so it can be scaled and stuff)\n    float time = iTime;\n\n    // getting the pixel coords, uv, and stuff\n    float scale = min(time * 32., 750.);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y * scale + vec2(0., 45. * smoothstep(0., 1., time * 0.25 - 2.));\n    \n    vec2 pixelSize = vec2(4., 6.);\n    vec2 pixelCoord = floor(uv / pixelSize) * pixelSize;\n    vec2 dif = floor(mod(uv, pixelSize));\n\n    // getting the screen color\n    vec3 col = 0.5 + 0.5*cos(time+(pixelCoord.xyx / 200. * 2.)+vec3(0,2,4));\n    float blinkMod = 1. - clamp(noised(vec3(time * 4.) + vec3(-1000.)).x * 1.5 - 0.5, 0., 1.);\n    blinkMod = min(clamp(time - 2., 0., 1.), blinkMod);\n    float eyeDst1 = pow(pixelCoord.x - 65., 4.) + pow(pixelCoord.y * 0.2 / pow(blinkMod * 0.98 + 0.02, 10.), 4.);\n    float eyeDst2 = pow(pixelCoord.x + 65., 4.) + pow(pixelCoord.y * 0.2 / pow(blinkMod * 0.98 + 0.02, 10.), 4.);\n    float mouthMovement = 1. - clamp(noised(vec3(-iTime, iTime, -iTime * 1.5)).x * 1., 0., 1.);\n    float mouthDst = pow(pixelCoord.x * 0.2, 4.) + pow((pixelCoord.y - pow(abs(pixelCoord.x) * 0.01, 1.25) * 10. + 140.) / (mouthMovement * 1.5 - 0.5) * 1.5, 4.);\n    col *= smoothstep(0.75, 1., min(min(eyeDst1, eyeDst2), mouthDst) / 100000.);\n    col *= smoothstep(0.6, 1., blinkMod) * 0.7 + 0.3;\n    \n    // the pixel pattern\n    vec3 pixelColor = vec3(0.);\n    if (dif.y < pixelSize.y - 1.)\n    {\n        if      (dif.x == 0.) pixelColor.x = col.x;\n        else if (dif.x == 1.) pixelColor.y = col.y;\n        else if (dif.x == 2.) pixelColor.z = col.z;\n    }\n    \n    // a squricle defining the bounds of the moniter, also the glow around the background\n    bool drawAnt = true;\n    \n    // stuff for the background glow effect\n    float wobble = noised(vec3(time, -time, time) * 0.1).x * 60.;\n    vec2 end1 = uv + vec2(-170, -260. + wobble);\n    vec2 end2 = uv + vec2(10, -290. - wobble);\n    float endDst1 = length(end1);\n    float endDst2 = length(end2);\n\n    vec2 newUv = uv * vec2(0.75, 1.) / 55.;\n    float glow = length(newUv) / 2.5;\n    \n    // choosing what to draw (background/glow, monitor, or screen, or screen edge)\n    float dst = pow(newUv.x, 4.) + pow(newUv.y, 4.);\n    float dst2 = pow(newUv.x - 0.2, 4.) + pow(newUv.y - 0.02, 4.);\n    if      (dst  > 100. && dst < 110.) pixelColor = vec3(0.5);\n    else if (dst2 > 120. && dst > 100.)\n    {        \n        // the lighting for the background\n        float light = smoothstep(4., 1., glow) * (smoothstep(4., 1., min(endDst1, endDst2) / 15.) * 0.5 + 1.) * (noised(vec3(-iTime * 1.2, iTime * 0.5, -iTime * 0.1)).x * 0.5 + 1.);\n    \n        // drawing the power coord\n        float powerSurge = sin(uv.x * 0.2 + iTime * 5.) * 0.5 + 0.5;\n        \n        float x;\n        if (uv.x > 220.) x = uv.x * 0.015 - 3.5;\n        else x = 220. * 0.015 - 3.5;\n        \n        float functionOutput = exp(-0.1*pow(x, 3.) + pow(x, 2.) - 2.75 * x) * 100. - 300.;\n        float coordDst1 = length(uv - vec2(max(uv.x, 220.), functionOutput));\n        x += 0.0125;\n        functionOutput = exp(-0.1*pow(x, 3.) + pow(x, 2.) - 2.75 * x) * 100. - 300.;\n        float coordDst2 = length(uv - vec2(max(uv.x, 220.) + 0.0125, functionOutput));\n        x += 0.0125;\n        functionOutput = exp(-0.1*pow(x, 3.) + pow(x, 2.) - 2.75 * x) * 100. - 300.;\n        float coordDst3 = length(uv - vec2(max(uv.x, 220.) + 0.025, functionOutput));\n        x -= 0.0125 * 3.;\n        functionOutput = exp(-0.1*pow(x, 3.) + pow(x, 2.) - 2.75 * x) * 100. - 300.;\n        float coordDst4 = length(uv - vec2(max(uv.x, 220.) - 0.0125, functionOutput));\n        x -= 0.0125;\n        functionOutput = exp(-0.1*pow(x, 3.) + pow(x, 2.) - 2.75 * x) * 100. - 300.;\n        float coordDst5 = length(uv - vec2(max(uv.x, 220.) - 0.025, functionOutput));\n        float minDst = min(coordDst1, min(coordDst2, min(coordDst3, min(coordDst4, coordDst5))));\n        if (minDst < 3.) pixelColor = mix(vec3(0.45), vec3(1., 1., 0.75), powerSurge);\n        light += smoothstep(1., 0., clamp(minDst*0.01, 0., 1.)) * 0.75;\n        \n        // drawing the background\n        if (minDst >= 3.) pixelColor = vec3(0.2) * light;\n    }\n    else if (dst > 110.) pixelColor = vec3(0.05);\n    else drawAnt = false;\n    \n    // drawing the antennas\n    if (drawAnt)\n    {\n        float dstLine1 = dstLine(uv - vec2(0., 175.), vec2(-50, 0), -end1 * 20.);\n        float dstLine2 = dstLine(uv - vec2(0., 175.), vec2(-50, 0), -end2 * 20.);\n        if      (min(endDst1 , endDst2 ) / 15. < 1.) pixelColor = vec3(0.75);\n        else if (min(dstLine1, dstLine2) / 10. < 1.) pixelColor = vec3(0.5);\n    }\n\n    // Output to screen\n    fragColor = vec4(pixelColor,1.0);\n}","name":"Image","description":"","type":"image"}]}