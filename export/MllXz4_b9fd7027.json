{"ver":"0.1","info":{"id":"MllXz4","date":"1435040035","viewed":241,"name":"Warmified","username":"ophilbinbriscoe","description":"2nd pass","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["psychedelic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//noise function taken from https://www.shadertoy.com/view/XslGRr\n\nfloat hash( float n ){\n\treturn fract(sin(n)*43758.5453);\n}\n\n//this noise function was originally 3D noise, \n//but I am just setting z to 0 for the sake of simplicity here\n//also cause most effects only care about 2D noise\nfloat noise( vec2 uv ){\n\tvec3 x = vec3(uv, 0);\n\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf       = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\t\n\treturn mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n\t\t\t\t   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nfloat ring( float angle, float dist, float ANG, float THICKNESS, float POS, float SIZE ) {\n    //angles between 4 and 15 are good\n    //negative thickness makes it black, values around 0.02 are good\n    \n    float ZIGZAG = abs( mod( angle, ANG ) - ANG * 0.5 ) * SIZE;\n    return ceil( dist - POS + ZIGZAG) - ceil( dist - (POS+THICKNESS) + ZIGZAG);   \n}\nfloat burst( float angle, float dist, float ANG ) {\n    float B = abs( mod( angle, ANG ) - ANG * 0.5 );\n    return B;\n}\nfloat lim( float IN, float amount ) {\n\treturn IN * amount + (1.0 - amount);   \n}\nfloat inv( float IN ) {\n \treturn 1.0 - IN;   \n}\nfloat ppp( float IN ) {\n \treturn IN * IN * IN;   \n}\nfloat dots( float angle, float dist, float ANG, float POS ) {\n    return ppp(7.5*burst( angle, dist, ANG )/ANG) * ppp(inv(ANG*1.5*distance( dist, POS )));\n}\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 myoutput( vec2 fragCoord )\n{\n    \n    float shortside = min( iResolution.x, iResolution.y );\n    float longside = max( iResolution.x, iResolution.y );\n    \n\tvec2 uv = fragCoord.xy / vec2( shortside, shortside );\n    \n    uv.x = uv.x - (longside/shortside - 1.0) * 0.5;\n    \n   \tfloat dist = distance( vec2( 0.5, 0.5 ), uv );\n    \n    uv = vec2( uv.x - 0.5, uv.y - 0.5 );\n    \n    float angle = degrees( atan( uv.y / uv.x ) );\n    \n    float TIMESCALE = 0.3;\n    float T = iTime * TIMESCALE * 2.0;\n    \n    \n    float n = noise( vec2( dist, T ) );\n    float slow_n = noise( vec2( dist, T * 0.2) );\n    float fast_n = noise( vec2( dist, T * 2.0) );\n    float vslow_n = noise( vec2( dist, T * 0.01) );\n    float vfast_n = noise( vec2( dist, T * 50.0) );\n    float t = noise( vec2( iTime, T ) );\n    \n    float rand_r = noise( vec2( -T, T ) );\n    float slow_r = noise( vec2( -T * 0.5, 1.0 ) );\n    float vslow_r = noise( vec2( -T * 0.2, 1.0 ) );\n    float vvslow_r = noise( vec2( -T* 0.05, 1.0 ) );\n    \n    float div = 7.0;\n    float m = sin ( mod( angle, div )/(div*0.5) * 3.14 * 0.5 );\n    float a = mod( angle, 10.0 ) * noise( vec2( T, angle ) );\n        \n    float TIME_MOD_SCALE = 1.0;\n    float TIME_MOD = floor(0.5+sin( noise( vec2(-iTime + 1000.0, 1.0 )) ))*0.5*TIMESCALE*TIME_MOD_SCALE;\n\n    TIMESCALE = TIMESCALE * TIME_MOD;\n    \n    float GRANULARITY = 1.75;\n    float GRAN_DIST_FALLOFF = 0.5;\n    float GRAN_DIST_FALLOFF_MOD = tan(noise (vec2( 500.0, -T ) ));\n    GRAN_DIST_FALLOFF = GRAN_DIST_FALLOFF + GRAN_DIST_FALLOFF_MOD * 0.5;\n    \n    float Gr = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 50.0;\n    float Gg = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 80.0;\n    float Gb = (GRANULARITY-(dist * GRANULARITY * GRAN_DIST_FALLOFF)) * 100.0;\n    \n    float Gsign = clamp( sign( noise (vec2( T * 0.22, -T * 1.5 )) -0.5 ), -1.0, 0.0 );\n    \n    float rn = 360.0 / (ceil( noise(vec2( sin(T*0.1), 0.5 ) ) * 50.0) * 2.0 );\t//randomly some divisor of 360\n    float rd1 = ceil( noise(vec2( tan(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd2 = ceil( noise(vec2( sin(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd3 = ceil( noise(vec2( cos(T/10.0), 1.0 ) ) * 2.0 );\t//randomly either 1 or 2\n    float rd4 = ceil( noise(vec2( tan(T*0.0075+99.0), 1.0 ) ) * 1.2 );\t//randomly either 1 or 2\n    float rd5 = ceil( noise(vec2( tan(T*0.008+124.0), 1.0 ) ) * 1.5 );\t//randomly either 1 or 2\n    float rd6 = ceil( noise(vec2( tan(T*0.007+24.0), 1.0 ) ) * 1.7 );\t//randomly either 1 or 2\n    float rd7 = ceil( noise(vec2( tan(T*0.005), 1.0 ) ) * 1.4 );\t//randomly either 1 or 2\n    float exp4 = ceil( noise(vec2( tan(T*0.5), 1.0 ) ) * 2.0 ) * rd1;\n    float coarse3 = ceil( noise(vec2( cos(T), 1.0 ) ) * 3.0 );\n    float coarse10 = ceil( noise(vec2( cos(T), 1.0 ) ) * 10.0 );\n    \n    vec3 RING1 = rd2 * 0.5 * ring( angle, dist,6.0, 0.02, n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * floor( n + 0.5 );\n    vec3 RING2 = ring( angle, dist,10.0, 0.01, n/2.0, 0.01) * vec3( 1.0, 1.0, 1.0 ) * ceil( n - 0.3 );\n    vec3 RING3 = ring( angle+(vslow_n*200.0*coarse3)*(2.0+n), dist,90.0*rd1/rd4, (0.02 + rand_r*0.01 + ppp(slow_r)*0.011)*ppp(rd4), n, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.5;\n    vec3 RING4 = ring( angle-iTime*(5.0*n), dist,10.0, 0.05, n, 0.01) * vec3( sin(T), cos(T), 0.1 ) * 0.5;\n    vec3 RING5 = ring( angle, dist,30.0, n*20.0, n+0.3, 0.01) * vec3( 1.0, 1.0, 1.0 ) * 0.05 + (dist)*0.05;\n    vec3 BURST1 = burst( angle, dist, rn * rd1 ) * vec3( 1.0, 1.0, 1.0 ) * 0.03 * (1.0 - dist);\n    vec3 RING6 = max(ring( angle-(vslow_n*200.0*coarse3)*(2.0+vslow_n), dist,45.0*rd1, 0.3, n, 0.01),0.0) * vec3( sin(T), tan(T) * 0.5, rand_r ) * (rd7 - 1.0) * inv(dist) * 0.5;\n    vec3 DOTS1 = max(ceil(dots( angle + T*30.0, dist, 10.0, 0.25 + rand_r*0.1 )-24.5 * (1.0+rand_r)),0.0) * vec3( rand_r, inv(rand_r), n ) * 0.15;\n    vec3 DOTS2 = max(ceil(dots( angle - T*35.0, dist, 10.0, 0.3 + rand_r*0.2 )-16.4 * (2.0-rand_r)),0.0) * vec3( n, rand_r, inv(rand_r) ) * 0.15;\n    vec3 DOTS3 = clamp( 1.0 * dots( angle + T * 45.0, dist, 15.0, 0.9 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.05;\n    vec3 DOTS4 = clamp( 1.0 * dots( angle - T * 45.0, dist, 15.0, 0.82 ), 0.0, 1.0) * vec3( 1.0, 1.0, 1.0 ) * 0.025;\n    vec3 RING = RING1 + RING2 + RING3 + RING4 + RING5 + BURST1 + DOTS1 + DOTS2 + RING6 + DOTS3 + DOTS4;\n    \n    float r = RING.r + max((1.0 - dist * 2.0),-0.5) + noise( vec2( dist * Gr * sin( noise(vec2( iTime * 8.0 * TIMESCALE, -iTime )) ), dist ) );;//floor(n*2.0) * a;\n    float g = RING.g + max((1.0 - dist * 3.5),-1.5) + noise( vec2( dist * Gg * TIMESCALE * cos( noise(vec2( iTime * 12.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.1) - a;\n    float b = RING.b + max((1.0 - dist * 2.5),-1.0) + noise( vec2( dist * Gb * tan( noise(vec2( iTime * 1.0 * TIMESCALE, -iTime )) ), dist ) );;//ceil(n/3.0 - 0.2) - a;\n    \n    vec3 boost = vec3( 1.3, 1.3 - slow_r * 0.3, 0.4 + slow_n * 0.3);    \n       \n\treturn vec4(r*boost.r,g*boost.g,b*boost.b,1.0) * mix(dist,1.0,0.7);\n    \n    float over = DOTS3.x + DOTS4.x;\n    //fragColor = vec4( DOTS3 + DOTS4, 1.0);//vec4(over,over,over,1.0);\n    //fragColor = blur( \n}\nvec4 myoverlay( vec2 fragCoord )\n{ \n\tfloat shortside = min( iResolution.x, iResolution.y );\n    float longside = max( iResolution.x, iResolution.y );\n    \n\tvec2 uv = fragCoord.xy / vec2( shortside, shortside );\n    \n    uv.x = uv.x - (longside/shortside - 1.0) * 0.5;\n    \n   \tfloat dist = distance( vec2( 0.5, 0.5 ), uv );\n    \n    uv = vec2( uv.x - 0.5, uv.y - 0.5 );\n    \n    float angle = degrees( atan( uv.y / uv.x ) );\n    \n    float TIMESCALE = 0.3;\n    float T = iTime * TIMESCALE * 2.0;\n    \n    float ar = noise( vec2( angle / 5.0, 1.0 ) );\n    float ar2 = noise ( vec2( mod ( angle, 30.0 ) / 5.0, 1.0 ) );\n    \n    vec3 DOTS1 = max(ceil(dots( angle, dist + ar * ar2 * sin( T ) * 0.35, 10.0, 0.5) - 40.0 ), 0.0) * vec3(1.0,1.0,1.0);\n    vec3 DOTS2 = max(ceil(dots( angle + 5.0, dist + ar * ar2 * sin( (T+uv.x) * 0.5 ) * 1.5 + 0.2, 10.0, 0.5) - 40.0 ), 0.0) * vec3(1.0,1.0,1.0);\n    vec3 DOTS3 = max(ceil(dots( angle + 5.0, dist + ar * ar2 * cos( (T+uv.y) * 0.5 ) * 1.0 + 0.1, 5.0, 0.5) - 45.0 ), 0.0) * vec3(1.0,1.0,1.0);\n   \n    return vec4( DOTS1 + DOTS2 + DOTS3, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float shortside = min( iResolution.x, iResolution.y );\n    float longside = max( iResolution.x, iResolution.y );\n    \n\tvec2 uv = fragCoord.xy / vec2( shortside, shortside );\n    \n    uv.x = uv.x - (longside/shortside - 1.0) * 0.5;\n    \n   \tfloat dist = distance( vec2( 0.5, 0.5 ), uv );\n\tvec3 c = myoutput(fragCoord.xy).rgb;\n\tif (fragCoord.x < iMouse.x)\n\t{\n\t\tfragColor = vec4(c, 1.0);\t\n\t} else {\n\t\t\n\t\t//declare stuff\n\t\tconst int mSize = 11;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 0.75 + dist * 5.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*myoutput((fragCoord.xy+vec2(float(i),float(j)))).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfragColor = vec4(final_colour/(Z*Z), 1.0);\n        fragColor.rgb += myoverlay( fragCoord.xy ).rgb;\n\t}\n}","name":"","description":"","type":"image"}]}