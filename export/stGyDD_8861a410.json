{"ver":"0.1","info":{"id":"stGyDD","date":"1661498410","viewed":68,"name":"testpav1","username":"northmc","description":"Testing smoothstep techniques.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["baseperfectsmoothstepline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//globals\n\nfloat thickness = 0.02;\nfloat fade = 0.01; \nvec2 uv, nMouse;\nfloat aspectRatio;\nfloat minX, minY, maxX, maxY;\n\nvec2 scenario0_1(in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n    aspectRatio = iResolution.x/iResolution.y;\n    uv.x *=aspectRatio;\n    \n    nMouse = iMouse.xy /iResolution.xy;\n    nMouse.x *=aspectRatio;\n\n    float posx =nMouse.x;\n    \n    //step working approach (position on the left)\n    //float m = (1.0-step(position+thickness,uv.x)) *\n    //          step(position,uv.x);\n    \n    //position in the middle\n    float m= (1.0-step(posx+thickness/2.0,uv.x))*\n             step(posx-thickness/2.0,uv.x);\n              \n    //smoothstep (position in the middle)\n    float m2 = (1.0-smoothstep(posx+thickness/2.0-fade,posx+thickness/2.0,uv.x))*\n              smoothstep(posx-thickness/2.0,posx-thickness/2.0+fade,uv.x);\n    \n    //smoothstep 2d (perfect!)\n    vec2 m3 = (1.0-smoothstep(nMouse+thickness/2.0-fade,nMouse+thickness/2.0,uv))*\n              smoothstep(nMouse-thickness/2.0,nMouse-thickness/2.0+fade,uv);\n    \n    //smoothstep 2d (perfect!) (inverse first m3)\n    vec2 m3_2 = smoothstep(nMouse+thickness/2.0,nMouse+thickness/2.0-fade,uv)*\n              smoothstep(nMouse-thickness/2.0,nMouse-thickness/2.0+fade,uv);\n    \n    return m3_2;\n}\n\n\n//assume the center is at (0.0)\nbool drawVerticalLine(float x, float thickness, float fade, out vec4 fragColor)\n{\n    float v = smoothstep(thickness/2.0,thickness/2.0-fade,abs(uv.x-x));  \n    if(v>0.0) fragColor += vec4(v,v,v,1.0);\n    return v>0.0;\n}\n\nbool drawHorizontalLine(float y, float thickness, float fade, out vec4 fragColor)\n{\n    float v = smoothstep(thickness/2.0,thickness/2.0-fade,abs(uv.y-y));  \n    if(v>0.0) fragColor += vec4(v,v,v,1.0);\n    return v>0.0;\n}\n\nvec2 scenario0_middle(in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -1.0 to +1.0)\n    uv = fragCoord/iResolution.xy*2.0-1.0;\n    aspectRatio = iResolution.x/iResolution.y; \n    uv.x *=aspectRatio;\n    minY = -1.0; maxY=1.0; minX = -1.0/aspectRatio; maxX=1.0/aspectRatio;\n    \n    nMouse = iMouse.xy /iResolution.xy*2.0-1.0;\n    nMouse.x *=aspectRatio;\n\n   \n    float posx =nMouse.x;\n    \n    //smoothstep 2d (perfect!)\n    //simpler by keeping  the inverse one and putting abs and offset at the end!!\n    return smoothstep(thickness/2.0,thickness/2.0-fade,abs(uv-nMouse));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = scenario0_middle(fragCoord);\n    if(m!=vec2(0.0))\n    {\n        fragColor = vec4(m,0.0,1.0); return;\n    }\n    \n \n    float gridThickness = 0.01, gridFade = 0.005;\n \n    for(int i=-10; i<10;i++)\n    {\n        float pos =float(i)/10.0;\n        if(drawHorizontalLine(pos,gridThickness,gridFade, fragColor)) return;\n//if(drawVerticalLine(minX+pos*(maxX-minX),gridThickness, gridFade, fragColor)) return;\n    }\n\n\n    // Output to screen\n    //fragColor = vec4(v,v,v,1.0);\n}","name":"Image","description":"","type":"image"}]}