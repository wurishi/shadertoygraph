{"ver":"0.1","info":{"id":"cl2fRd","date":"1694392179","viewed":91,"name":"DDA test site 2d","username":"jt","description":"3d visualization of a 2d DDA for analysis and as template for further developments.\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","raytracing","raycasting","voxel","slice","dda"],"hasliked":0,"parentid":"7dK3D3","parentname":" Branchless Voxel Raycasting Tex"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/cl2fRd DDA test site 2d, 2023 by jt\n// based on https://www.shadertoy.com/view/7dK3D3 Branchless Voxel Raycasting Tex\n// fork of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy), DDA based on http://lodev.org/cgtutor/raycasting.html\n// 3d-texture on voxels addon, normals reconstruction and grid transform by jt\n\n// 3d visualization of a 2d DDA for analysis and as template for further developments.\n\n// tags: 2d, 3d, raytracing, raycasting, voxel, slice, dda\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define pi 3.1415926\n\n#define DIST_MAX 100.0\n\nmat3 yaw_pitch_roll(float yaw, float pitch, float roll)\n{\n    mat3 R = mat3(vec3(cos(yaw), sin(yaw), 0.0), vec3(-sin(yaw), cos(yaw), 0.0), vec3(0.0, 0.0, 1.0));\n    mat3 S = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(pitch), sin(pitch)), vec3(0.0, -sin(pitch), cos(pitch)));\n    mat3 T = mat3(vec3(cos(roll), 0.0, sin(roll)), vec3(0.0, 1.0, 0.0), vec3(-sin(roll), 0.0, cos(roll)));\n\n    return R * S * T;\n}\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi *p.z + pi/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nbool get_voxel(ivec2 c)\n{\n    c = c >> 2;\n    return (c.x & 1) != (c.y & 1); // checker\n\n    c = abs(c) - 3;\n\n    return c.x*c.x + c.y*c.y < 4;\n}\n\n#define MAX_RAY_STEPS 64\n\nvec4 traverse(vec3 ray_pos, vec3 ray_dir)\n{\n    float h = 1.0;//0.25;\n\n    float plate_dist = abs(ray_pos.z) <= h ? 0.0 : min((-h-ray_pos.z)/ray_dir.z, (+h-ray_pos.z)/ray_dir.z); // distance from camera to plate\n\n    if(plate_dist < 0.0) return vec4(-ray_dir, DIST_MAX); // if entire plate missed return sky\n\n    ray_pos += plate_dist * ray_dir; // snap camera to nearest border of plate\n\n    mat2 M = fract(iTime / 5.0) > 0.5 ? mat2(1,1,-1,1) : mat2(1,0,0,1);\n\n    ray_pos.xy = M*ray_pos.xy;\n    ray_dir.xy = M*ray_dir.xy;\n\n    ivec2 tile_pos = ivec2(floor(ray_pos.xy)); // round down position to get tile position\n    bool flip = get_voxel(tile_pos); // starting in free space or inside solid\n    if(flip) return vec4(vec3(0,0,sign(ray_pos.z)), plate_dist); // if starting point at filled volume return surface normal (comment this out to remove floors & ceilings)\n\n    vec4 result = vec4(-ray_dir, DIST_MAX); // sky\n\n    // decompose ray direction into reciprocal absolute ray direction and sign (-1,+1)\n    vec2 delta_dist = 1.0 / abs(ray_dir.xy); // reciprocal absolute ray direction\n    ivec2 ray_step = ivec2(sign(ray_dir)); // sign of ray direction\n    // initial distances to nearest walls by dimension:\n    //     calculate ray position in relation to tile origin\n    //     (requires adding one half because tile origin is floor of ray position)\n    //     adjust sign according to ray direction\n    //     because tile has size 1 and we start in the middle wall is located at 0.5 (sign depends on ray direction)\n    //     divide by ray direction (to get distance with respect to ray)\n    vec2 side_dist = (vec2(ray_step) * (vec2(tile_pos) - ray_pos.xy + 0.5) + 0.5) * delta_dist; // initial distances to nearest walls by dimension\n    bvec2 nearest = lessThanEqual(side_dist.xy, side_dist.yx); // component is true if nearest wall in that dimension\n\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        if(get_voxel(tile_pos) != flip)\n        {\n            // recover distance as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n            //float dist = abs(nearest.x ? side_dist.x - delta_dist.x : nearest.y ? side_dist.y - delta_dist.y : 0.0); // calculate distance to intersection point assuming ray_dir normalized\n            float dist = length(vec2(nearest) * (side_dist - delta_dist)); // calculate distance to intersection point assuming ray_dir normalized\n            if(abs(ray_pos.z + dist * ray_dir.z) > h) return vec4(-ray_dir, DIST_MAX); // leaving plate? sky\n            // NOTE: nearest contains only one component set to true indicating nearest direction and since normal points along this direction just cast nearest to normal (sign opposite to ray direction)\n            result = vec4(inverse(M)*(vec2(nearest)*vec2(-ray_step)), 0, dist + plate_dist);\n\n            break;\n        }\n\n        // core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n        nearest = lessThanEqual(side_dist.xy, side_dist.yx); // component is true if nearest wall in that dimension\n        side_dist += vec2(nearest) * delta_dist; // update distances to nearest walls by dimension\n        tile_pos += ivec2(nearest) * ray_step; // step to next tile in direction of nearest wall\n    }\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 I )\n{\n    bool demo = all(lessThan(iMouse.xy, vec2(10.0)));\n    vec2 R = iResolution.xy;\n    //I = 2.0 * I.xy / R - 1.0;\n    //I.x *= R.x / R.y;\n    I = (2.0 * I - R) / R.y; // concise pixel-position mapping thanks to Fabrice\n    float yaw = 2.0 * pi * float(iMouse.x) / float(R.x);\n    float pitch = -pi/4.0 + pi - pi / 2.0 * float(iMouse.y) / float(R.y);\n    yaw = !demo ? yaw : 2.0 * pi * fract(iTime * 0.01);\n    pitch = !demo ? pitch : 1.5 * pi/2.0;\n\n    vec3 ray_pos = vec3(0.0, 0.0, -16.0);\n    vec3 ray_dir = vec3(I.x, I.y, 2.0); // NOTE: un-normalized direction appears to work fine here!\n    //ray_dir = normalize(ray_dir); // looks like ray-direction does not need to be normalized\n\n    mat3 M = yaw_pitch_roll(yaw, pitch, 0.0); // rotate camera\n    ray_pos = M * ray_pos;\n    ray_dir = M * ray_dir;\n\n    //ray_pos.z -= 0.0;\n\n    //ray_dir = normalize(ray_dir);\n\n    vec4 result = traverse(ray_pos, ray_dir);\n    \n    vec3 color = vec3(0);\n    if(result.w < DIST_MAX)\n    {\n        vec3 n = result.xyz;\n        float d = result.w;\n        vec3 dst = ray_pos + ray_dir * d;\n        d *= length(ray_dir); // fix distance in case ray was not normalized\n\n        vec3 light_dir = normalize(vec3(1,2,3));\n        float specular = pow(max(0.0, dot(result.xyz, normalize(-normalize(ray_dir) + light_dir))), 50.0);\n        //float diffuse = max(0.0, dot(light_dir, n));\n        float diffuse = abs(dot(light_dir, n));\n        float shadow = diffuse <= 0.0 ? 0.0 : traverse(dst+result.xyz*0.001, light_dir).w < DIST_MAX ? 0.0 : 1.0;\n        float ambient = 0.2;\n        color = (ambient + (diffuse + 0.5 * specular) * shadow) * mix(vec3(0.1), vec3(1.0), checker(dst));\n        //color *= 0.5 + 0.5 * result.xyz; // debug normals\n\n        vec3 fogcolor = vec3(0); // fog\n        color *= mix(fogcolor, color, exp(-d * d / 1000.0)); // fog for depth impression & to suppress flickering\n    }\n\n    //color = mix(vec3(1,1,0),vec3(0,0,1),result.w/20.0); // debug distance\n\n    fragColor = vec4(sqrt(color), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}