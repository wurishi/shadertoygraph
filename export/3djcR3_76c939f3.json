{"ver":"0.1","info":{"id":"3djcR3","date":"1588872894","viewed":155,"name":"Subsurface Scattering - cis461","username":"sharond106","description":"Subsurface scattering approximation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["subsurface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOVY = 0.25 * 3.141569;\nconst int RAY_STEPS = 256;\n\n#define SPHERE_SDF sdfSphere(pos, vec3(0.5, .8, 5), .2)\n#define SPHERE_ID 1\n#define SPHERE2_SDF sdfSphere(pos, vec3(-0.5, .8, 5), .2)\n#define SPHERE2_ID 2\n#define SPHERE3_SDF sdfSphere(pos, vec3(0, .5, 5), .3)\n#define SPHERE3_ID 3\n#define SPHERE4_SDF sdfSphere(pos, vec3(0, -.3, 5), .1)\n#define SPHERE4_ID 4\n#define SPHERE5_SDF sdfSphere(pos, vec3(0, .5, 7), 2.)\n#define SPHERE5_ID 5\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 inverseTransform(vec3 translate, vec3 rotate, vec3 scale) {\n    mat4 s;\n    // matrices indexed to columns!\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n\ts[3] = vec4(0., 0., 0., 1.);                                     \n                                    \n    rotate.x = radians(rotate.x);\n    rotate.y = radians(rotate.y);\n    rotate.z = radians(rotate.z);\n      \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(translate.x, translate.y, translate.z, 1.); \n    \n    return inverse(t * r * s);      \n}\n    \nfloat sdfPlane(vec3 p, mat4 inverseT) {\n    p = vec3(inverseT * vec4(p, 1.));\n    float dot = dot(p, vec3(0., 0., 1.));\n    if (abs(dot) < 0.0001) {\n        // n must be normalized\n        if (p.x >= -.5 && p.x <= 0.5 && p.y >= -0.5 && p.y <= 0.5) {\n            return 0.;  \n        }\n        return 324234.;\n    }\n    float dist = 0.f;\n    if (abs(p.x) > 0.5) {\n        dist += ((p.x - 0.5) * (p.x - 0.5));\n    }\n    if (abs(p.y) > 0.5) {\n        dist += ((p.y - 0.5) * (p.y - 0.5));\n    }\n    dist += abs(p.z) * abs(p.z);\n    return sqrt(dist);\n} \n\n// Box with side lengths b\nfloat sdfBox(vec3 p, vec3 scale, mat4 inverseT)\n{\n    p = vec3(inverseT * vec4(p, 1.));\n    vec3 q = vec3(abs(p.x), abs(p.y), abs(p.z)) - vec3(.5);\n    float d = q.x;\n    d = max(d,q.y);\n    d = max(d,q.z);\n    return d * min(min(scale.x, scale.y), scale.z);\n}\n\n\nfloat sdfSphere(vec3 p, vec3 c, float r) {\n    return distance(p, c) - r;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int objectHit) {\n\tt = SPHERE_SDF;\n    objectHit = SPHERE_ID;\n    float t2;\n\n    if ((t2 = SPHERE2_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE2_ID;\n    }\n    if ((t2 = SPHERE3_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE3_ID;\n    }\n    if ((t2 = SPHERE4_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE4_ID;\n    }\n    if ((t2 = SPHERE5_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE5_ID;\n   }\n}\n\n// called by computeNormal\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objectHit) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float min;\n        sceneMap3D(pos, min, objectHit);\n        if (min < 0.01) {\n            return;\n        }\n        t += min;\n    }\n    t = -1.;\n    objectHit = -1;\n}\n\nvec3 computeNormal(vec3 p, vec3 lightPos) {\n    vec3 epsilon = vec3(0., .001, 0.);\n    return normalize(vec3(sceneMap3D(p + epsilon.yxx) - sceneMap3D(p - epsilon.yxx),\n                          sceneMap3D(p + epsilon.xyx) - sceneMap3D(p - epsilon.xyx),\n                     \t  sceneMap3D(p + epsilon.xxy) - sceneMap3D(p - epsilon.xxy)));\n}\n\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 3.;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.;\n\n\nfloat subsurfaceColor(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * SCALE;\n    float attenuation = 1.0;\n    //attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\n#define DIST 0.085\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float sum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        sum += coeff * (i * DIST - sceneMap3D(p + n * i * DIST));\n    }\n    return 1.0 - k * sum;\n}\n\nvec3 computeMaterial(int objectHit, vec3 p, vec3 n, vec3 lightPos, vec3 view) {\n    vec3 lightDir = normalize(lightPos - p);\n    float lambert = max(0., dot(n, lightDir));\n    vec3 color;\n    float subsurface = subsurfaceColor(lightDir, n, view, fiveTapAO(p, -n, 2.0));\n    \n    switch (objectHit) {\n        case SPHERE_ID:\n        color = vec3(153., 204., 255.) / vec3(255.);\n        break;\n        case SPHERE2_ID:\n        color = vec3(153., 204., 255.) / vec3(255.);\n        break;\n        case SPHERE3_ID:\n        color =  vec3(255, 255, 0) / vec3(255.);\n        break;\n        case SPHERE4_ID:\n        color =  vec3(255, 102, 153) / vec3(255.);\n        break;\n        case SPHERE5_ID:\n        color = vec3(255, 204, 204) / vec3(255.);\n        break;\n    }\n    return color * lambert + color * subsurface;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nIntersection sdf3D(vec3 eye, vec3 dir) {\n    float t;\n    int objectHit;\n    march(eye, dir, t, objectHit);\n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect, vec3(0, 0, 0));\n    \n    vec3 lightPos =  rotateY(vec3(0, 2., 20), sin(iTime * 0.5));\n    \n    vec3 color = computeMaterial(objectHit, isect, nor, lightPos, normalize(eye - isect));\n    \n    if (objectHit == -1) {\n        color = vec3(0, 0, 0);\n    }\n    \n    return Intersection(t, color, isect, objectHit);\n}\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / float(iResolution.y);\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1, 1);\n    \n    vec3 eye = vec3(0, 0, 0);\n    vec3 ref = vec3(0, 1, 11);\n    vec3 rayDir = rayCast(eye, ref, uv); \n    \n    Intersection isect = sdf3D(eye, rayDir);\n\n    fragColor = vec4(isect.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}