{"ver":"0.1","info":{"id":"wdSXzh","date":"1552863465","viewed":485,"name":"ShaderDojo 024","username":"antonOTI","description":"Part 2 of my shaders inspired by the ES2 Riftborn prologue\nit's a comment from @ollj that motivated me trying.\nStill some weird artifact and performance I have to look into :)","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["raymarch","training","dojo","cookie","riftborn","endlessspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shattered dimention\n// Inspired by the Riftborn intro from ES2\n// https://www.youtube.com/watch?v=h8H8DedCW_I\n//\n// \n\n#define PI 3.14159\n#define TAU (PI * 2.)\n\n#define time (iTime)\n\n#define RID(p, r) (floor((p + r/2.) / r))\n#define REP(p, r) (mod(p + r/2., r) - r/2.)\n\n// from https://www.shadertoy.com/view/4tdSWr\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 2; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n    n += time * .5;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// from https://www.shadertoy.com/view/ltl3D8\n// I've modified it to tape into a 2d fbm instead of a texture\n// It's far from perfect but it's close to the feeling I searched for\n float cubemap( in vec3 d )\n{\n    vec3 n = abs(d);\n    vec3 v = (n.x>n.y && n.x>n.z) ? d.xyz: \n             (n.y>n.x && n.y>n.z) ? d.yzx:\n                                    d.zxy;\n    vec2 uv = 0.5+0.5*v.yz;///v.x;\n\n    return fbm(uv * 8.);\n}\n\nmat2 rot(float a)\n{\n  float ca = cos(a); float sa = sin(a);\n  return mat2(ca,-sa,sa,ca);\n}\n\n// from https://iquilezles.org/articles/distfunctions\nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n  return dot(p,n.xyz) - n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat distortion = 0.;\n\nfloat map(vec3 p)\n{\n\n  vec3 cp = p;\n\n  float t = time  * 1.;\n\n  vec3 orbit = normalize(vec3(1.,0.,1.));\n  orbit.xy *= rot(t * .12);\n  orbit.yz *= rot(sin(t * .23) * .2);\n\n  vec3 distOrb = p + orbit * 2.9;\n    \n  distortion = clamp(1.5 - length(distOrb), 0., 1.);\n  distortion*= distortion;\n\n  p = cp;\n\n  p *= 1.;\n  float dist = 1000.;\n\n  p.xy *= rot(-t *.05);\n  p.yz *= rot(-t * .025);\n  p.zx *= rot(-t * .00125);\n\n    if(distortion > 0.)\n    {\n        float diff = cubemap(normalize(p));\n        diff *= 10.;\n        diff = 1. - exp(-.3 - diff * 1.2);\n        diff *= 1.;\n\n        p = p + normalize(distOrb - p) * diff * distortion;\n    }\n  dist = max(sdOctahedron(p,3.5), sdBox(p,vec3(2.15))) ;\n\n  p = cp;\n\n  p += orbit * 4.3;\n\n  p.xy *= rot(-t *.27);\n  p.yz *= rot(-t * .135);\n  p.zx *= rot(-t * .0125);\n  \n    if(distortion > 0.)\n    {\n        float diff = cubemap(normalize(p)*.5);\n        diff *= 10.;\n        diff = 1. - exp(-.3 - diff * 1.2);\n        diff *= .3;\n\n        p+= normalize(p) * diff * distortion;\n    }\n  float octahedre = sdOctahedron(p, .7) ;\n  dist = min(dist, octahedre);\n\n  return dist * (1. - distortion * .85);\n}\n\nvoid ray(inout vec3 cp,vec3 rd, out float st, out float cd)\n{\n  for(st = 0.; st < 1.; st += 1./64.)\n  {\n    cd = map(cp);\n    if(cd < .01)\n      break;\n    cp += rd * cd * .75;\n  }\n}  \n\nvec3 normal(vec3 p)\n{\n  vec2 e = vec2(.01,.0);\n  float d = map(p);\n  return normalize(vec3(\n    d - map(p + e.xyy),\n    d - map(p + e.yxy),\n    d - map(p + e.yyx)\n  ));\n}\n\nvec3 lookAt(vec3 eye, vec3 tar, vec2 uv)\n{\n  vec3 fd = normalize(tar - eye);\n  vec3 ri = cross(fd, vec3(0.,1.,0.));\n  vec3 up = cross(ri,fd);\n  return normalize(fd + ri * uv.x + up * uv.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  uv*= sin(time * .1) *.1 + 1.1;\n    \n  vec3 eye = vec3(0.,0.,-10.);\n  vec3 tar = vec3(0.);\n  vec3 rd = lookAt(eye, tar, uv);\n  vec3 cp = eye;\n  float st,cd;\n  ray(cp,rd,st,cd);\n\n  float dist = length(eye - cp);\n\n  fragColor = mix(vec4(1.), vec4(.6,.6,.68,1.), pow((fragCoord.x / iResolution.x * .75 + .1), 1.2));\n  if(cd < .01)\n  {\n    vec3 norm = normal(cp);\n    vec3 ld = normalize(vec3(1.,-1.,1.));\n    float li = dot(norm,ld);\n    fragColor = mix(\n        fragColor,\n        mix(\n          mix(vec4(.84,.84,.855,1.),\n              vec4(.85,.85,.87,1.),\n                1. - pow(1. - distortion, 2.)),\n          vec4(.4,.4,.52,1.),\n        li),\n        exp(-distance(cp,eye) * .007));\n  }\n  \n  fragColor = pow(fragColor, vec4(2.2));\n}","name":"Image","description":"","type":"image"}]}