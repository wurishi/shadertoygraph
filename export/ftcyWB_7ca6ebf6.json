{"ver":"0.1","info":{"id":"ftcyWB","date":"1660407749","viewed":302,"name":"Text - Postscript (scanline)","username":"mrboggieman","description":"Simple rendering of text by tracing a scanline for all lines and curves within range. Drag the mouse in the x axis to zoom in. See truetype shader here: https://www.shadertoy.com/view/NtcyWM","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["text","scanline","otf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//MIT Licence\nstruct Cubic {\n    vec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 d;\n    vec2 aabbMin;\n    vec2 aabbMax;\n};\n\nstruct Quadratic {\n    vec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 aabbMin;\n    vec2 aabbMax;\n};\n\nstruct Line {\n    vec2 a;\n    vec2 b;\n    vec2 aabbMin;\n    vec2 aabbMax;\n};\n\nstruct Closest {\n    float x;\n    bool inside;\n};\n\n//constants\nconst float almost_zero = 0.0001;\nconst float almost_one = 0.9999;\nconst float bit_over_one = 1.0001;\nconst float bit_under_zero = -0.0001;\n\n//utilities\nint linear(in float a, in float b, out float[3] roots) {\n    if (abs(a) < almost_zero) {\n        return 0;\n    }\n    \n    roots[0] = -b/a;\n    return 1;\n}\n\nint quadratic(in float a, in float b, in float c, out float[3] roots) {\n    if (abs(a) < almost_zero) {\n        return linear(b, c, roots);\n    }\n    \n    float nom = sqrt(b*b - 4.0*a*c);\n    float denom = 2.0 * a;\n\n    roots[0] = (-b + nom) / denom;\n    roots[1] = (-b - nom) / denom;\n    return 2;\n}\n\n//modified from https://www.shadertoy.com/view/3tyczd\nconst vec2 eta = vec2(-0.5, sqrt(0.75));\nint cubic(in float a, in float b, in float c, in float d, out float[3] roots) {\n    if (abs(a) < almost_zero) {\n        return quadratic(b, c, d, roots);\n    }\n    \n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    float w = -d0 / r - r;\n    roots[0] = (C.x * w - b) / 3.0;\n    roots[1] = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots[2] = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots[0] = roots[1];\n\n    return h < 0.0 ? 1 : 3;\n}\n\nvoid testLine(in Line test, in vec2 p, inout Closest closest) {\n    float a = test.b.y - test.a.y;\n    float b = test.a.y - p.y;\n    \n    float[3] ts;\n    int numRoots = linear(a, b, ts);\n    \n    float derivative = sign(a);\n\n    for (int i=0; i<numRoots; i++) {\n        if (ts[i] > bit_under_zero && ts[i] < bit_over_one) {\n            float t = ts[i];\n            float x = mix(test.a.x, test.b.x, t);\n\n            if (p.x > x && x > closest.x) {\n                closest.x = x;\n                closest.inside = derivative > 0.0;\n            }\n        }\n    }\n}\n\nvoid testQuadraticBezier(in Quadratic test, in vec2 p, inout Closest closest) {\n    float a = test.a.y - 2.0 * test.b.y + test.c.y;\n    float b = 2.0 * (test.b.y - test.a.y);\n    float c = test.a.y - p.y;\n\n    float[3] ts;\n    int numRoots = quadratic(a, b, c, ts);\n\n    float derivativeA = 2.0 * a;\n    float derivativeB = b;\n\n    for (int i=0; i<numRoots; i++) {\n        if (ts[i] > bit_under_zero && ts[i] < bit_over_one) {\n            float t = ts[i];\n            float x = mix(mix(test.a.x, test.b.x, t), mix(test.b.x, test.c.x, t), t);\n            \n            if (p.x > x && x > closest.x) {\n                closest.x = x;\n                closest.inside = sign(derivativeA * t + derivativeB) > 0.0;\n            }\n        }\n    }\n}\n\nvoid testCubicBezier(in Cubic test, in vec2 p, inout Closest closest) {\n    float a = -test.a.y + 3.0 * (test.b.y - test.c.y) + test.d.y;\n    float b = 3.0 * (test.a.y -2.0 * test.b.y + test.c.y);\n    float c = 3.0 * (-test.a.y + test.b.y);\n    float d = test.a.y - p.y;\n    \n    float[3] ts;\n    int numRoots = cubic(a, b, c, d, ts);\n\n    float derivativeA = 3.0 * a;\n    float derivativeB = 2.0 * b;\n    float derivativeC = c;\n\n    for (int i=0; i<numRoots; i++) {\n        if (ts[i] > bit_under_zero && ts[i] < bit_over_one) {\n            float t = ts[i];\n            float mid = mix(test.b.x, test.c.x, t);\n            float x = mix(mix(mix(test.a.x, test.b.x, t), mid, t), mix(mid, mix(test.c.x, test.d.x, t), t), t);\n\n            if (p.x > x && x > closest.x) {\n                closest.x = x;\n                closest.inside = sign(derivativeA * t * t + derivativeB * t + derivativeC) > 0.0;\n            }\n        }\n    }\n}\n\n//demo\nconst Line[] lines = Line[](\n    Line(vec2(0.34375,0.14160),vec2(0.34375,0.14014),vec2(0.34375,0.14014),vec2(0.34375,0.14160)),\n    Line(vec2(0.47412,0.00977),vec2(0.47949,-0.01855),vec2(0.47412,-0.01855),vec2(0.47949,0.00977)),\n    Line(vec2(0.12793,0.08984),vec2(0.12354,0.12598),vec2(0.12354,0.08984),vec2(0.12793,0.12598)),\n    Line(vec2(1.68066,-0.25049),vec2(1.67676,-0.22412),vec2(1.67676,-0.25049),vec2(1.68066,-0.22412)),\n    Line(vec2(1.66406,-0.12744),vec2(1.66113,0.00000),vec2(1.66113,-0.12744),vec2(1.66406,0.00000)),\n    Line(vec2(1.66113,0.00000),vec2(1.78320,0.00000),vec2(1.66113,0.00000),vec2(1.78320,0.00000)),\n    Line(vec2(1.78320,0.00000),vec2(1.81055,-0.11230),vec2(1.78320,-0.11230),vec2(1.81055,0.00000)),\n    Line(vec2(1.87012,-0.38574),vec2(1.75342,-0.37988),vec2(1.75342,-0.38574),vec2(1.87012,-0.37988)),\n    Line(vec2(1.43506,-0.38135),vec2(1.42822,-0.34912),vec2(1.42822,-0.38135),vec2(1.43506,-0.34912))\n);\n\n//not using any quadratics with this demo so just include an empty entry for now\nconst Quadratic[] quadratics = Quadratic[](\n    Quadratic(vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0), vec2(0.0, 0.0))\n);\n\nconst Cubic[] cubics = Cubic[](\n    Cubic(vec2(0.34375,0.14014),vec2(0.41553,0.13525),vec2(0.48877,0.11963),vec2(0.55615,0.09277),vec2(0.34375,0.09277),vec2(0.55615,0.14014)),\n    Cubic(vec2(0.55615,0.09277),vec2(0.79443,-0.00342),vec2(0.98389,-0.22949),vec2(0.98389,-0.51660),vec2(0.55615,-0.51660),vec2(0.98389,0.09277)),\n    Cubic(vec2(0.98389,-0.51660),vec2(0.98389,-0.70801),vec2(0.86377,-0.80957),vec2(0.63330,-0.80957),vec2(0.63330,-0.80957),vec2(0.98389,-0.51660)),\n    Cubic(vec2(0.63330,-0.80957),vec2(0.34473,-0.80957),vec2(0.12744,-0.63135),vec2(0.12744,-0.30908),vec2(0.12744,-0.80957),vec2(0.63330,-0.30908)),\n    Cubic(vec2(0.12744,-0.30908),vec2(0.12744,-0.11475),vec2(0.25732,0.00977),vec2(0.47412,0.00977),vec2(0.12744,-0.30908),vec2(0.47412,0.00977)),\n    Cubic(vec2(0.47949,-0.01855),vec2(0.33984,-0.01855),vec2(0.27734,-0.07666),vec2(0.27734,-0.22314),vec2(0.27734,-0.22314),vec2(0.47949,-0.01855)),\n    Cubic(vec2(0.27734,-0.22314),vec2(0.27734,-0.52588),vec2(0.41895,-0.78516),vec2(0.62891,-0.78516),vec2(0.27734,-0.78516),vec2(0.62891,-0.22314)),\n    Cubic(vec2(0.62891,-0.78516),vec2(0.75928,-0.78516),vec2(0.82666,-0.70313),vec2(0.82666,-0.54932),vec2(0.62891,-0.78516),vec2(0.82666,-0.54932)),\n    Cubic(vec2(0.82666,-0.54932),vec2(0.82666,-0.15869),vec2(0.56982,0.11768),vec2(0.28564,0.11768),vec2(0.28564,-0.54932),vec2(0.82666,0.11768)),\n    Cubic(vec2(0.28564,0.11768),vec2(0.26416,0.11768),vec2(0.24268,0.11621),vec2(0.22070,0.11328),vec2(0.22070,0.11328),vec2(0.28564,0.11768)),\n    Cubic(vec2(0.22070,0.11328),vec2(0.18262,0.10400),vec2(0.14014,0.09326),vec2(0.12793,0.08984),vec2(0.12793,0.08984),vec2(0.22070,0.11328)),\n    Cubic(vec2(0.12354,0.12598),vec2(0.16553,0.13232),vec2(0.24365,0.14893),vec2(0.28027,0.15381),vec2(0.12354,0.12598),vec2(0.28027,0.15381)),\n    Cubic(vec2(0.28027,0.15381),vec2(0.35400,0.16406),vec2(0.69971,0.23877),vec2(0.97754,0.23877),vec2(0.28027,0.15381),vec2(0.97754,0.23877)),\n    Cubic(vec2(0.97754,0.23877),vec2(1.18750,0.23877),vec2(1.30078,0.19385),vec2(1.30078,0.11035),vec2(0.97754,0.11035),vec2(1.30078,0.23877)),\n    Cubic(vec2(1.30078,0.11035),vec2(1.30078,0.07471),vec2(1.27002,0.05566),vec2(1.21240,0.05566),vec2(1.21240,0.05566),vec2(1.30078,0.11035)),\n    Cubic(vec2(1.21240,0.05566),vec2(1.21240,0.13721),vec2(1.08740,0.18115),vec2(0.81934,0.18115),vec2(0.81934,0.05566),vec2(1.21240,0.18115)),\n    Cubic(vec2(0.81934,0.18115),vec2(0.64111,0.18115),vec2(0.43457,0.15967),vec2(0.34375,0.14160),vec2(0.34375,0.14160),vec2(0.81934,0.18115)),\n    Cubic(vec2(1.67676,-0.22412),vec2(1.65283,-0.10107),vec2(1.54590,-0.01855),vec2(1.40918,-0.01855),vec2(1.40918,-0.22412),vec2(1.67676,-0.01855)),\n    Cubic(vec2(1.40918,-0.01855),vec2(1.29346,-0.01855),vec2(1.23047,-0.09912),vec2(1.23047,-0.24854),vec2(1.23047,-0.24854),vec2(1.40918,-0.01855)),\n    Cubic(vec2(1.23047,-0.24854),vec2(1.23047,-0.57031),vec2(1.36182,-0.78516),vec2(1.55811,-0.78516),vec2(1.23047,-0.78516),vec2(1.55811,-0.24854)),\n    Cubic(vec2(1.55811,-0.78516),vec2(1.74658,-0.78516),vec2(1.77832,-0.69971),vec2(1.79150,-0.55908),vec2(1.55811,-0.78516),vec2(1.79150,-0.55908)),\n    Cubic(vec2(1.79150,-0.55908),vec2(1.81885,-0.55908),vec2(1.89160,-0.59131),vec2(1.89160,-0.64014),vec2(1.79150,-0.64014),vec2(1.89160,-0.55908)),\n    Cubic(vec2(1.89160,-0.64014),vec2(1.89160,-0.76660),vec2(1.67822,-0.80957),vec2(1.56299,-0.80957),vec2(1.56299,-0.80957),vec2(1.89160,-0.64014)),\n    Cubic(vec2(1.56299,-0.80957),vec2(1.27100,-0.80957),vec2(1.07666,-0.60791),vec2(1.07666,-0.30469),vec2(1.07666,-0.80957),vec2(1.56299,-0.30469)),\n    Cubic(vec2(1.07666,-0.30469),vec2(1.07666,-0.11621),vec2(1.20752,0.00977),vec2(1.40381,0.00977),vec2(1.07666,-0.30469),vec2(1.40381,0.00977)),\n    Cubic(vec2(1.40381,0.00977),vec2(1.51709,0.00977),vec2(1.61182,-0.04248),vec2(1.66406,-0.12744),vec2(1.40381,-0.12744),vec2(1.66406,0.00977)),\n    Cubic(vec2(1.81055,-0.11230),vec2(1.82080,-0.15430),vec2(1.86523,-0.33252),vec2(1.87012,-0.38574),vec2(1.81055,-0.38574),vec2(1.87012,-0.11230)),\n    Cubic(vec2(1.75342,-0.37988),vec2(1.75342,-0.37988),vec2(1.49121,-0.38086),vec2(1.43506,-0.38135),vec2(1.43506,-0.38135),vec2(1.75342,-0.37988)),\n    Cubic(vec2(1.60596,-0.35693),vec2(1.66992,-0.35693),vec2(1.68799,-0.35205),vec2(1.68799,-0.31689),vec2(1.60596,-0.35693),vec2(1.68799,-0.31689)),\n    Cubic(vec2(1.68799,-0.31689),vec2(1.68799,-0.30322),vec2(1.68457,-0.27490),vec2(1.68066,-0.25049),vec2(1.68066,-0.31689),vec2(1.68799,-0.25049))\n);\n\nfloat circ(in float t) {\n    return sqrt(1.0 - (t - 1.0)*(t - 1.0));\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 20.0 * (iMouse.x > 10.0 ? 1.0 - circ(iMouse.x / iResolution.x) : 0.06);\n    \n    vec2 p = ((fragCoord.xy / iResolution.y)) * scale;\n    p.y = -p.y + 0.3;\n    \n    //for a simple point in shape test we will go through all of the lines and curves and determine which side of the shape we are on\n    Closest closest = Closest(0.0, false);\n\n    for (int i=0; i<cubics.length(); i++) {\n        Cubic test = cubics[i];\n\n        if (p.y <= test.aabbMax.y && p.y >= test.aabbMin.y && p.x >= test.aabbMin.x) {\n            testCubicBezier(test, p, closest);\n        }\n    }\n    \n    for (int i=0; i<quadratics.length(); i++) {\n        Quadratic test = quadratics[i];\n\n        if (p.y <= test.aabbMax.y && p.y >= test.aabbMin.y && p.x >= test.aabbMin.x) {\n            testQuadraticBezier(test, p, closest);\n        }\n    }\n    \n    for (int i=0; i<lines.length(); i++) {\n        Line test = lines[i];\n\n        if (p.y <= test.aabbMax.y && p.y >= test.aabbMin.y && p.x > test.aabbMin.x) {\n            testLine(test, p, closest);\n        }\n    }\n    \n    //check if we are inside or outside\n    if (closest.inside) {\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n}\n\n// some aa from https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    vec4 o;\n    for (int k=0; k < 9; k+= k==3?2:1 )\n      { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n    O /= 9.;\n}","name":"Image","description":"","type":"image"}]}