{"ver":"0.1","info":{"id":"DssXDr","date":"1668733115","viewed":126,"name":"Riemann Zeta Convergence Î¶(x)","username":"syncryptic","description":"The Riemann zeta function is one of the most legendary objects in mathematics. For reasons I don't understand, proving facts about it is very hard, as it encodes crucial arithmetic information from the ring of integers of the field of complex numbers","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","mathematics","hsv","function","complex","zeta","riemann","analysis"],"hasliked":0,"parentid":"Ms2fWR","parentname":"Riemann zeta function 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/4scSWB with tweaks by FabriceNeyret2 and etale_cohomology\n// I don't know if the zeta computation is correct (yet!), but it doensn't look completely off!\n// Compare with https://en.wikipedia.org/wiki/Riemann_zeta_function\n// We look at the zeta function's domain around the so-called critical strip!\n\n//TODO: Need to reset the iFrame when resized.\n\n#define hsv2rgb(v) abs(fract(v + vec3(3, 2, 1) / 3.) - .5) * 6. - 1.\n\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 sum = vec2(\n      unpack(iChannel0,fragCoord),\n      unpack(iChannel1,fragCoord)\n  );\n  fragColor.rgb = hsv2rgb(atan(sum.y, sum.x)) * abs(length(sum));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define SCALE 65535.\n#define UV_SCALE 10.0\n#define UV_OFFSET (-iResolution.xy/2.)\n#define TIME_SCALE 1\n\n#define unmarshal(tex,uv) uintBitsToFloat(packUnorm4x8(texture(tex,uv)))/SCALE\n\n#define unpack(tex,uv) \\\n    (uintBitsToFloat(packUnorm4x8(texelFetch(tex,ivec2(uv),0)))/SCALE)\n\n#define pack(sum) \\\n    unpackUnorm4x8(floatBitsToUint(sum*SCALE))\n\nfloat zeta_fun_x(vec2 z, float i) {\n    return sin(-z.y * log(i) - 1.57) / pow(i, z.x);\n}\n\nfloat zeta_fun_y(vec2 z, float i) {\n    return sin(-z.y * log(i) - 0.) / pow(i, z.x);\n}\n\nfloat uintToMinifloat(uint i){\n    if((i&0xFFu)==0u) return 0.;\n    float mantissa = float(i&7u);\n    float exponent = float((i>>3)&15u);\n    float sgn = float((i>>7)&1u);\n    return (mantissa/8.+1.)*exp2(exponent)*(sgn*2.-1.);\n}\n\nuint MinifloatTouint(float x){\n    float sgn = float(x>0.);\n    x = abs(x);\n    if(x<.5) return 0u;\n    float exponent = floor(log2(x));\n    float mantissa = floor(8.*(x / exp2(exponent) - 1.));\n    if(exponent>=16.){\n        exponent=15.;\n        mantissa=7.;\n    }\n    return uint(sgn)<<7 | uint(exponent) << 3 | uint(mantissa);\n    \n}\n\nvec4 unpackUnorm4x8(uint p){\n    return vec4(uintToMinifloat(p),\n                uintToMinifloat(p>>8),\n                uintToMinifloat(p>>16),\n                uintToMinifloat(p>>24));\n}\n\nuint packUnorm4x8(vec4 v){\n    return MinifloatTouint(v.x) |\n            MinifloatTouint(v.y)<<8 |\n            MinifloatTouint(v.z)<<16 |\n            MinifloatTouint(v.w)<<24;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 uv = (fragCoord + UV_OFFSET) / UV_SCALE;\n\n  float sum = 0.;\n  //uint start = packUnorm4x8(texelFetch(iChannel0,ivec2(0,1),0));\n  int frame = iFrame;//-int(start);\n  if(frame != 0) {\n    sum = unpack(iChannel0,fragCoord);\n    \n    if(unmarshal(iChannel0,vec2(1.0,0.0)) == 0.0) {\n        sum = 0.0;\n//        start = uint(iFrame);\n    }\n    sum += zeta_fun_x(-uv.yx,float(frame));\n  }\n\n  fragColor = pack(sum);\n  //if(ivec2(fragCoord) == ivec2(0,1))\n  //  fragColor = unpackUnorm4x8(start);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 uv = (fragCoord + UV_OFFSET) / UV_SCALE;\n  \n  float sum = 0.;\n  //uint start = packUnorm4x8(texelFetch(iChannel0,ivec2(0,0),0));\n  int frame = iFrame;//-int(start);\n  if(frame != 0) {\n    sum = unpack(iChannel0,fragCoord);\n\n    if(unmarshal(iChannel0,vec2(1.0,0.0)) == 0.0) {\n        sum = 0.0;\n        //start = uint(iFrame);\n    }\n    sum += zeta_fun_y(-uv.yx,float(frame));\n  }\n\n  fragColor = pack(sum);\n  //if(ivec2(fragCoord) == ivec2(0,0))\n  //  fragColor = unpackUnorm4x8(start);\n}","name":"Buffer B","description":"","type":"buffer"}]}