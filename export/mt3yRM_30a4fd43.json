{"ver":"0.1","info":{"id":"mt3yRM","date":"1698987884","viewed":72,"name":"RGB Chunks with Van Damme","username":"DigitalShadow","description":"Rejected Ben and Jerry's flavor. This is your brain on buffer feedback.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["template","feedback","buffer"],"hasliked":0,"parentid":"Dl3cR7","parentname":"RGB Chunks with Thermal Paste"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RANDOMIZE_EDGES\n\nconst float oldMix      = 0.9999,    //feedback from last frame alpha\n            noiseMix    = 0.01,   //rgb noise alpha\n            noiseOffset = 0.5,    //value offset\n            timeScale   = 0.5;\n            \nmat2 rotate(float r)\n{\n    return mat2( cos(r), -sin(r), sin(r), cos(r) );\n}\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 origin = vec2(0.5);\n    float aspect = iResolution.x / iResolution.y;\n    \n    float T = iTime * timeScale;\n    \n    vec2 uvN = fragCoord / iResolution.xy;\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    float init = smoothstep(3., 0., iTime);\n    \n    vec2 uvW = uvN;                  //start of warp coordinates\n    uvW -= 0.5;                      //apply origin offset\n    uvW.x *= aspect;                 //apply aspect ratio stretch\n    uvW /= 1.0 - 0.001 * init;\n    uvW.x /= aspect;                 //undo aspect ratio stretch\n    uvW += 0.5;                      //undo origin offset\n    //uvW += 0.001 * vec2( cos(T), sin(T) );\n\n    vec3 rgbNoise = hash33(vec3(fragCoord.x, fragCoord.y, iTime));    \n    vec3 oldColor = texture(iChannel0, uvW).rgb;\n    \n    #ifdef RANDOMIZE_EDGES\n    if(\n        fragCoord.x <= 1. || \n        fragCoord.y <= 1. ||\n        fragCoord.x >= iResolution.x - 1. || \n        fragCoord.y >= iResolution.y - 1.)\n            oldColor = rgbNoise;\n    #endif\n    \n    \n    //crazy color cycling\n    float F = 0.125 + 0.025*cos(iTime/ 5.);\n\n    oldColor = vec3(oldColor.r - oldColor.g*F + oldColor.b*F, oldColor.g - oldColor.b*F + oldColor.r*F, oldColor.b - oldColor.r*F + oldColor.g*F);\n    vec3 vidColor = texture(iChannel1, uvN).rgb;\n     \n    vec3 newColor = oldColor * oldMix + (rgbNoise - noiseOffset) * noiseMix;\n    \n    float monoNew = (newColor.r + newColor.g + newColor.b) / 3.;\n    float monoOld = (oldColor.r + oldColor.g + oldColor.b) / 3.;\n    float monoVid = (vidColor.r + vidColor.g + vidColor.b) / 3.;\n    \n    float chroma = smoothstep(0.1, 0.0, vidColor.g  - (vidColor.r + vidColor.b) );\n    newColor = mix(newColor, vidColor, chroma);\n    \n    newColor = clamp(newColor, -1., 1.);\n    \n    \n    \n    fragColor = vec4(newColor, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}