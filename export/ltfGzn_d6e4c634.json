{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Thanks! https://iquilezles.org/articles/distfunctions\n//Thanks! jimanjr \n\n#define AntiAliasing 0\n#define AntiAliasing3x 1\n#define AntiAliasing4x 0\n#define SoftShadows 1\n\nint obj = 0;\nint finalObj = 0;\nvec4 soundLow;\nvec4 soundHi;\nfloat low;\nfloat hi;\n\nfloat pi = 3.14159265359;\n\nconst float timePassageFactor = 1.0;\nfloat gTime = 0.0;\n\nvec3 pos;\nvec2 uv;\nvec2 p;\nfloat aspectRatio;\nfloat depth;\n\nstruct Camera\n{\n    vec3 eye, target;\t\t\t// eye - camera position, target - the point at which the camera is pointed at\n    vec3 forward, right, up;\t// the camera CoordinateSystem\n    float zoom;\t\t\t\t\t// the amount of \"scaling\" in the camera {right,up} plane\n};\n    \nCamera camera;\n    \nstruct Ray\n{\n    vec3 origin;\t\t\t\t// the origin of the ray\n    vec3 direction;\t\t\t\t// the ray direction vector. Normally an unit vector.\n};\n\nRay ray;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// CAMERA\n\n// sets the camera to look at 'target' from 'eye' with the given 'zoom'\nCamera cameraLookAt(vec3 eye, vec3 target, float zoom)\n{\n    Camera c;\n    // target object to be seen\n    c.target = target;\n    // eye\n    c.eye = eye;\n    // zoom factor\n    c.zoom = zoom;\n    \n    // camera coordinate system\n    c.forward = normalize(c.target - c.eye);\t// optical axis\n    c.up = vec3(0.0, 1.0, 0.0);\n    c.right = cross(c.forward, c.up);\t\t\t// right direction\n    c.up = cross(c.right, c.forward);\t\t\t// up direction\n    \n    return c;\n}\n\n// computes the ray that starts from the camera eye and is directed towards the given fragment position\n// the fragment position 'p' is in [-1,1]x[-1,1];\nRay shootRay(Camera c, vec2 p)\n{\n    Ray r;\n    r.origin = c.eye;\n    r.direction = normalize(p.x * c.right + p.y * c.up + c.zoom * c.forward);\n    return r;\n}\n\n// computes a point on a nice path around the tree, given the time and mouse input\nvec3 cameraPathPoint()\n{\n    float cameraRadius = 13.0;\n    float teta = 0.0;\n    float height = 9.0;\n    bool freeCamera = (iMouse.z < 0.001);\n    if (freeCamera)\n    {\n        // time based\n        teta = gTime * 0.1;\n        height += 1.0 + 3.0 * sin(0.25 * gTime + pi / 2.0);\n        cameraRadius -= 5.0 * cos(0.25 * gTime + pi / 2.0);\n    }\n    else\n    {\n        // mouse position based\n        teta = 15.0 * (0.5 - iMouse.x / iResolution.x);\n        height += 5.0 * (0.5 - iMouse.y / iResolution.y);\n    }\n\n    // path point\n    return vec3(cameraRadius * cos(teta), height, cameraRadius * sin(teta));\n}\n\n\n// sets the camera on the desired path, looking at the desired object\nvoid setCameraOnPath()\n{\n    vec3 pathPoint = cameraPathPoint();\n    // target object to be seen. Somewhere in the middle of the tree\n    vec3 target = vec3(0.0, 4.0, 0.0);\n    // set the camera position at the point on the path and it's target at the tree\n    camera = cameraLookAt(pathPoint, target, 1.5);\n}\n\n\t\t\t\t\t\t\t\t\t\t// Primitives\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, float height, float radius)\n{\n    // c must be normalized\n    vec2 c = normalize(vec2(height, radius));\n    p.y -= height;\n    float q = length(p.xz);\n    float cone = dot(c,vec2(q,p.y));\n    float plane = sdPlane(p, vec4(0.0, 1.0, 0.0, height));\n\n    return max(-plane,cone);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\t\t\t\t\t\t\t\t// Linear Transformations\n\n//translation\nvec3 move(in vec3 p, in vec3 t)\n{\n    return p - t;\n}\n\n// rotation\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    mat4 R = rotationMatrix(axis, angle);\n    return (R*vec4(p,1.0)).xyz;\n}\n\n\n\t\t\t\t\t\t\t\t\t\t//Topology\n\n//Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\t\t\n//Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\t\t\n//Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// polynomial smooth minimum, used for blending 2 shapes\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\t\t\t\t\t\t\t\t\t\t// Utility\n// Sin function with codomain [0,1]\nfloat unitSin(float t)\n{\n    return 0.5 + 0.5 * sin(t);\n}\n\n// computes an UV coordinate based on given object and point in space\nvec2 computeUV(in vec3 p, in int obj)\n{\n    // ground\n    if (obj == 0)\n    {\n        return 0.1 * p.xz;\n    }\n    else\n    // tree\n    if (obj == 1) // branches\n    {\n        float r = atan(p.z, p.x);\n    \treturn vec2(abs(0.5 * (1.0 * r + float(int(3.0 * p.y)))), abs(0.5 * (p.y + 1.0)));\n    }\n    else\n    if (obj == 2) // trunk\n    {\n    \treturn vec2(abs(0.5 * (p.x + 1.0)), abs(0.5 * (p.y + 1.0)));\n    }\n    return vec2(0.0, 0.0);\n}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// SCENE OBJECTS\n\nfloat sdTreeCover(in vec3 p, float height)\n{\n    return sdCone(move(p, vec3(0.0, height * 0.2, 0.0)), 1.51 * 0.8*height / 2.0, height * 0.36);\n}\n\n// the tree\nfloat sdTree(in vec3 p, float height)\n{\n    p.y = p.y - 0.5;\n    float trunkHeight = height * 0.2;\n    float dh = 0.8*height / 2.0;\n    // branches: the main shapes is givent by 2 cones on top of each other\n    float cone1 = sdCone(move(p, vec3(0.0, trunkHeight + 0.5 * dh, 0.0)), dh, height * 0.21);\n    float cone2 = sdCone(move(p, vec3(0.0, trunkHeight, 0.0)), dh, height * 0.33);\n    float branches = opU(cone1, cone2);\n    // the fir tree leafs are made by combining 2 displacement maps:\n    // a Low freqency one and Hi frequency one\n    vec2 uv = 0.5 * computeUV(p, 1);\n    vec3 lowFreq = texture(iChannel2, 0.25 * uv, 1.0).xyz;\n    vec3 hiFreq = texture(iChannel2, uv, 1.0).xyz;\n    // blend the 2 displacements\n    vec3 disp = +1.0 * lowFreq - 0.4 * hiFreq;\n    // apply the displacement\n    branches += 0.3 * disp.x;\n    \n    // trunk: a cylinder\n    float trunk = sdCappedCylinder(p, vec2(0.33, trunkHeight));\n\n    obj = (trunk < branches) ? 2 : 1;\n\n    return opU(trunk, branches);\n}\n\nfloat sdTreeShadow(in vec3 p, float height)\n{\n    return sdCone(move(p, vec3(0.0, height * 0.2, 0.0)), 1.3 * 0.8*height / 2.0, height * 0.25);\n}\n\nfloat ground(in vec3 p)\n{\n    obj = 0;\n    float basePlane = udBox(p, vec3(10.0, 0.1, 10.0));\n    float hill1 = smin(basePlane, sdSphere(move(p, vec3(-10.0, -2.0, 2.0)), 4.0), 7.0);\n    float hill2 = smin(basePlane, sdSphere(move(p, vec3(-10.0, -2.0, -10.0)), 7.0), 7.00);\n    float hill3 = smin(basePlane, sdSphere(move(p, vec3(-10.0, -3.0, 10.0)), 7.0), 8.01);\n    float hill4 = smin(basePlane, sdSphere(move(p, vec3(4.0, -3.0, 10.0)), 5.0), 6.01);\n    float hill5 = smin(basePlane, sdSphere(move(p, vec3(6.0, -5.0, -10.0)), 6.0), 6.01);\n    float hill6 = smin(basePlane, sdSphere(move(p, vec3(9.0, -3.0, 0.0)), 4.0), 6.01);\n    float snow = smin(hill1, smin(hill2, smin(hill3, smin(hill4, smin(hill5, hill6, 0.50), 0.50), 0.50), 0.50), 0.50);\n\n    vec2 uv = 1.0 * computeUV(p, 0);\n    float factor = clamp(1.0 - length(p - ray.origin) / 10.0, 0.0, 1.0);\n    float disp =  0.05 * factor * texture(iChannel2, uv, 0.0).x;\n    \n  \treturn snow + disp;\n}\n\nfloat christmasScene(in vec3 p)\n{\n    float minDist = 1000.0;\n    finalObj = 0;\n\n    float tree = sdTree(p * 0.6, 6.0);\n    minDist = opU(minDist, tree);\n    finalObj = obj;\n    if (minDist < 0.001)\n        return minDist;\n \n    float snow = ground(p);\n    if (snow < minDist)\n        finalObj = obj;\n    minDist = opU(minDist, snow);\n    \n   \treturn minDist;\n}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// CHRISTMAS SCENE\nfloat christmasSceneShadow(in vec3 p)\n{\n    int finalObj = 0;\n    float tree = sdTreeShadow(p * 0.6, 6.0);\n   \treturn tree;\n}\n\nfloat map(in vec3 p)\n{\n    return christmasScene(p);\n}\n\nvec3 computeNormal(in vec3 p)\n{    \n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                   \t\t\tmap(p + e.yxy) - map(p - e.yxy),\n                   \t\t\tmap(p + e.yyx) - map(p - e.yyx)));   \n    return n;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n        float h = 1.0;\n    for( int i=0; i<16; i++ )\n    {\n        h = christmasSceneShadow(ro + rd*t);\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 1.0 );\n        if( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n \nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nfloat flakeVolume()\n{\n    float sum = 0.0;\n    float fallSpeed = 0.2;\n    float fall;\n    vec3 p1, p2;\n    float teta;\n    float t1, t2;\n    float a = pow(ray.direction.x, 2.0) + pow(ray.direction.z, 2.0);\n    float b = 2.0 * (ray.direction.x * ray.origin.x + ray.direction.z * ray.origin.z);\n    float c = pow(ray.origin.x, 2.0) + pow(ray.origin.z, 2.0);\n    float ac4 = 4.0 * a*c;\n    float a4 = 4.0 * a;\n    float a2 = 2.0 * a;\n    float bb = b*b;\n    float bbSubAC4 = bb - ac4;\n    for (float r = 1.0; r <= 16.0; r+=0.5)\n    {\n        float R = r + sin(pi * r * gTime * 0.05) / (r * 0.25);\n        float delta = bbSubAC4 + a4 * R*R;\n        if (delta >= 0.0)\n        {\n            t1 = (-b - sqrt(delta))/a2;\n            t2 = (-b + sqrt(delta))/a2;\n            p1 = ray.origin + t1 * ray.direction;\n            p2 = ray.origin + t2 * ray.direction;\n            if (t1 < depth && t1 > 2.0)\n            {\n                teta = atan(p1.z, p1.x) / (2.0 * pi);\n                fall = (0.5 + 0.5 * unitSin(r)) * fallSpeed * gTime  +  cos(r);\n                float s = 6.0;\n                s *= smoothstep(0.65, 1.0, texture(iChannel2, vec2(0.4 * teta * r, 0.1 * p1.y + fall)).r);\n                s *= smoothstep(0.65, 1.0, texture(iChannel2, vec2(0.11 * p1.y + fall, -0.4 * teta * r)).r);\n                s *= smoothstep(0.65, 1.0, texture(iChannel2, vec2(-(0.11 * p1.y + fall), 0.4 * teta * r)).r);\n                sum += s;\n            }\n            if (t2 < depth && t2 > 0.0)\n            {\n                teta = atan(p2.z, p2.x) / (2.0 * pi);\n                fall = (0.5 + 0.5 * unitSin(r)) * fallSpeed * gTime  +  cos(r);\n                float s = 6.0;\n                s *= smoothstep(0.65, 1.0, texture(iChannel2, vec2(0.4 * teta * r, 0.1 * p2.y + fall)).r);\n                s *= smoothstep(0.65, 1.0, texture(iChannel2, vec2(-(0.11 * p2.y + fall), 0.4 * teta * r)).r);\n                s *= smoothstep(0.65, 1.0, texture(iChannel2, vec2(0.11 * p2.y + fall, -0.4 * teta * r)).r);\n                sum += s;\n            }\n        }\n    }\n    return sum / 2.0;\n}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// BLIZZARD\nvec4 screenSpaceBlizzard(in vec3 p)\n{\n    float flake = flakeVolume();\n    return vec4(1.0, 1.0, 1.0, clamp(flake, 0.0, 1.0));\n}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// FOG\nvec4 screenSpaceFog(in vec3 p)\n{\n    return vec4(0.9, 0.95, 1.0, 0.4 * clamp(1.0 - exp(-pow(depth * 0.03, 2.0)), 0.0, 1.0));\n}\n\nvec4 screenSpaceIce()\n{\n    vec2 P = vec2(p.x, 2.0 * p.y);\n    float r = length(P);\n    float u = texture(iChannel2,vec2(gTime * 3.0, 0)).r;\n    vec2 texCoords = vec2(p.x, p.y);\n    texCoords = vec2(cos(u) * texCoords.x - sin(u) * texCoords.y, cos(u) * texCoords.y + sin(u) * texCoords.x);\n    float grain = 0.5 * (texture(iChannel2, texCoords).r + texture(iChannel2, 2.0 * texCoords).r);\n    float grainFactor = 0.4;\n    return vec4(0.8, 0.9, 1.0, ((1.0 - grainFactor) + grainFactor * grain) * 0.3 * (pow((abs(p.x) + abs(p.y)) * 0.5, 1.0) + pow(r / 1.6, 2.0)));\n}\n\nvec3 renderChristmasScene()\n{\n    vec3 matCol = vec3(1.0, 0.8, 0.91);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 specMap = vec3(1.0);\n    float kAmbient = 0.2;\n    float kDiffuse = 0.8;\n    float kSpecular = 0.3;\n    float kSoftShadow = 0.4;\n    float normalBlend = 0.0;\n\n    // ground snow\n    if (finalObj == 0)\n    {\n        vec3 texCol = texture(iChannel1, computeUV(pos.xyz, finalObj)).rrr;\n        matCol = vec3(0.9, 0.95, 1.0);\n        matCol *= 0.1 * texCol + 0.9;\n        specMap = texture(iChannel2, 2.0 * computeUV(pos.xyz, finalObj), -2.0).rrr;\n        specMap *= texCol *0.5 + 0.5;\n        kAmbient = 0.3;\n        kDiffuse = 0.8;\n    \tkSpecular = 0.3;\n    }\n    // tree\n    if (finalObj == 1)\t// branches\n    {\n        kAmbient = 0.2;\n        kDiffuse = 0.8;\n        kSpecular = 0.1;\n        kSoftShadow = 0.4;\n        \n        matCol = vec3(0.0, 1.0, 0.0);\n        vec2 uv = computeUV(pos.xyz, finalObj);\n        vec3 texCol = texture(iChannel0, uv).rgb;\n        matCol *= texCol;\n        float flake = smoothstep(0.4, 0.6, texture(iChannel2, 0.01 * pos.xz).r);\n        if (flake > 0.0)\n        {\n        \tnormalBlend = 1.0;\n            matCol = flake * vec3(1.0) + (1.0 - flake) * matCol;\n            kAmbient = 0.5;\n        }\n    }\n    if (finalObj == 2)\t// trunk\n    {\n        matCol = vec3(0.7, 0.6, 0.0);\n        vec3 texCol = texture(iChannel0, computeUV(pos.xyz, finalObj)).rgb;\n        matCol *= texCol;\n        kAmbient = 0.2;\n        kDiffuse = 0.8;\n        kSpecular = 0.1;\n    }\n    \n    vec3 n = (1.0 - normalBlend) * computeNormal(pos) + normalBlend * vec3(0.0, 1.0, 0.0) ;\n    float alfa = 1.0;\n    vec3 lightPos = vec3(-10.0, 10.0, 5.0);\n    vec3 lightCol = vec3(0.8, 0.9, 1.0);\n    vec3 lightRay = normalize(lightPos - pos);\n    vec3 eyeRay = -ray.direction;\n    vec3 reflectedRay = -normalize(reflect(lightRay, n));\n    \n    vec3 ambient = lightCol;\n    \n    vec3 diffuse = matCol * (dot(lightRay, n)*0.5 + 0.5);\n    \n    vec3 specular = vec3(0.0);\n    float H = clamp(dot(eyeRay, reflectedRay), 0.0, 1.0);\n    if (dot(lightRay, n) > 0.0)\n        specular = lightCol * pow(H, 10.0);\n    float occlusion = calcOcclusion(pos, n);\n#if SoftShadows\n    float softShadow = calcSoftshadow(pos + n * 0.001, lightRay, 2.0);\n#else\n   \tfloat softShadow = 1.0;\n#endif\n    col = (kAmbient * ambient + kDiffuse * diffuse + kSpecular * specular * specMap);\n    col *= kSoftShadow * softShadow + (1.0 - kSoftShadow);\n    col *= 0.7 *occlusion + 0.3;\n    \n    if (finalObj == 1)\n    {\n        vec2 uv = 2.0 * computeUV(pos.xyz, finalObj);\n        float intensity = pow(texture(iChannel2, 0.02 * uv).r, 5.0);\n        vec3 lights = vec3(intensity) * vec3(unitSin(11.0 * gTime), unitSin(17.0 * gTime), unitSin(7.0 * gTime));\n        col += lights;\n    }\n\n    return col;\n}\n\nvec3 renderScene()\n{\n    return renderChristmasScene();\n}\n\nvec3 sky()\n{\n    float hAngle = atan(ray.direction.z, ray.direction.x);\n    \n\tvec2 uv = vec2(hAngle, ray.direction.y);\n    vec3 texCol = texture(iChannel1, uv).rgb;\n\n    texCol *= vec3(0.0, 0.5, 0.9);\n    float gamma = 1.2;\n    texCol = vec3(pow(texCol.r, gamma), pow(texCol.g, gamma), pow(texCol.b, gamma));\n    return vec3(texCol);\n}\n\nvec3 warmup(vec3 col, float factor)\n{\n    float t = 0.2 * col.r + 0.7 * col.g + 0.1 * col.b;\n    vec3 warm = vec3(0,0,0) * (1.0-t)*(1.0-t) + vec3(1,1,0) * (1.0-t) * t + vec3(1,1,1) * t * t;\n    col = mix(col, warm, factor);\n    return col;\n}\n\nvec3 renderEverything(vec2 offset)\n{\n    vec2 originalP = p;\n    p += (offset / iResolution.xy) * 2.0;\n    setCameraOnPath();\t// position camera\n    ray = shootRay(camera, p); // compute ray coresponding to the current fragment position\n    vec3 col = vec3(0.0);\n    float tmax = 100.0;\n    float h = 1.0;\n    float t = 0.0;\n    obj = 0;\n    for (int i = 0; i < 80; i++)\n    {\n        h = map(ray.origin + t * ray.direction);\n        if (h < 0.001 || t >= tmax) break;\n        t += h;\n    }\n    \n    if (t < tmax)\n    {\n        pos = ray.origin + t * ray.direction;\n        depth = length(pos - ray.origin);\n        col = renderScene();\n    }\n    else\n    {\n        depth = tmax;\n    \tcol = sky();\n    }\n    \n    vec4 flake = screenSpaceBlizzard(pos);\n    col = flake.a * flake.rgb + (1.0 - flake.a) * col.rgb;\n\n    vec4 fog = screenSpaceFog(pos);\n    col = fog.a * fog.rgb + (1.0 - fog.a) * col.rgb;\n    \n    float r = 0.5 + pow(1.0 - 1.0 / exp(1.0 * length(vec2(p.x / aspectRatio, p.y))), 2.0);\n    vec3 warmCol = warmup(col, 1.0);\n    col = mix(col, warmCol, r);\n    \n    vec4 ice = screenSpaceIce();\n    col = ice.a * ice.rgb + (1.0 - ice.a) * col.rgb;\n\n    p = originalP;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = iTime;\n    soundLow = texture(iChannel3, vec2(0.01, 0.25));\n\tsoundHi = texture(iChannel3, vec2(0.4, 0.25));\n    low = soundLow.x / 0.5;\n\thi = soundHi.x / 0.3;\n\tuv = fragCoord.xy / iResolution.xy;\n    aspectRatio = iResolution.x / iResolution.y;\n    p = -1.0 + 2.0 * uv;\n    p.x = p.x * aspectRatio;\n    vec3 col = vec3(0.0);\n#if AntiAliasing\n\t#if AntiAliasing3x\n    vec3 colT0 = renderEverything(vec2(0.0));\n    gTime += 0.01;\n    vec3 colT1 = renderEverything(vec2(0.0));\n    gTime += 0.01;\n    vec3 colT2 = renderEverything(vec2(0.0));\n    col = 0.25 * colT0 + 0.5 * colT1 + 0.25 * colT2;\n\t#else\n    \t#if AntiAliasing4x\n    float dp = 0.5;\n    col = 0.25 *(\n            renderEverything(vec2( dp,  dp)) +\n            renderEverything(vec2(-dp,  dp)) +\n            renderEverything(vec2( dp, -dp)) +\n            renderEverything(vec2(-dp, -dp)));\n    \t#else\n    col = renderEverything(vec2(0.0, 0.0));\n    \t#endif\n    #endif\n#else\n    // no AntiAliasing\n    col = renderEverything(vec2(0.0, 0.0));\n#endif\n\tfragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltfGzn","date":"1417768890","viewed":2318,"name":"X-Mas_v81188","username":"virgil81188","description":"Christmas tree with snow on a remote ice island in deep space. Added some subtle postFX","likes":34,"published":1,"flags":0,"usePreview":1,"tags":["christmas","raymarch","tree","snow","xmas","firtree"],"hasliked":0,"parentid":"","parentname":""}}