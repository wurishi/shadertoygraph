{"ver":"0.1","info":{"id":"DdtczB","date":"1695205752","viewed":67,"name":"Asymmetric Linear Inclusion","username":"betelgeuse6","description":"Comparison of the asymmetric linear inclusion described in : Forward inclusion functions for ray-tracing implicit surfaces\n(https://doi.org/10.1016/j.cag.2023.05.026) based on the shader for Segment Tracing (https://shadertoy.com/view/WdVyDW)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blobs","tracing","implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Asymmetric Linear Inclusion\n//Forward inclusion functions for ray-tracing implicit surfaces\n//(https://doi.org/10.1016/j.cag.2023.05.026) \n\n// Fork of \"Segment Tracing - Blobs\" by Moon519. https://shadertoy.com/view/WdVyDW\n// 2022-11-23 12:04:17\n\n// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric GuÃ©rin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 100;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n/////////////\n//calculate signed bound either geometrically as in segment tracing or in closed form\n#define GEOMETRIC 1\n/////////////\n\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R /  sqrt(5.0))\n    {\n        float t = (1.0 - (b*b) / (R*R));\n    \treturn abs(e) * 6.0 * ((b) / R) * (t * t);\n    }\n\t//else if (a > (R * R) / 5.0)\n    else if (a >  R /  sqrt(5.0))\n    {\n        float t = (1.0 - (a*a) / (R*R));\n    \treturn abs(e) * 6.0 * ((a) / R) * (t * t);\n    }\n    else{\n        return FalloffK(e, R);\n    }\n}\n\nvoid FalloffK_Asymmetric(float a, float b, float R, float e, out float k_min, out float k_max)\n{\n    //Calculate maximum and minimum values of the kernel \n    //Either at distance interval end points or the maxima of the kernel\n    \n    float t_a = (1.0 - ((a*a) / (R*R)));\n    float k_a =  -abs(e) * 6.0 * (a / R) * (t_a * t_a);\n   \n    float t_b = (1.0 - ((b*b) / (R*R)));\n    float k_b = -abs(e) * 6.0 * (b / R) * (t_b * t_b);\n\n    if (a > R ){\n      k_min = 0.0;\n       k_max = 0.0;\n      return;\n    }        \n    if( b > R)\n        k_b = 0.0;\n        \n    if (b < R / sqrt(5.0))\n    {\n        k_min = k_b;\n        k_max = k_a;\n        return;\n    }\n\telse if (a > R / sqrt(5.0))\n    {\n       k_min = k_a;\n       k_max = k_b;\n       return;\n    }\n    else{\n        k_min = -FalloffK(e, R); \n        k_max = max(k_a,k_b); \n       \n        return;\n    }\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n\n\nfloat eval_q(vec3 q, float t){\n    return (q.z + t *(q.y + t *q.x));\n}\nfloat d_dist(vec3 q, float t){\n    float val = 2.*q.x*t +q.y;\n    return val/(2.*sqrt(eval_q(q,t)));\n}\n\nfloat d_compact_6(float d){\n    if(d<1.){\n        float arg = (1.- d*d);\n        return -6. *d *arg*arg;\n    }\n    else{\n        return 0.;\n    }\n}\n//calculate the minimum and maximum values of the derivative along the ray on given segment\nfloat VertexKSegmentAsymmetric(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n   vec3 axis = normalize(b - a);  \n   float l = dot((c - a), axis);\n   float k_min,k_max;\n    \n    if (l < 0.0)\n    {\n         FalloffK_Asymmetric(length(c-a), length(c-b), R, e,k_min,k_max);\n    }\n    else if (length(b - a) < l)\n    {\n         FalloffK_Asymmetric(length(c-b), length(c-a), R, e,k_min,k_max);\n    }\n    else\n    {\n         float dd = dot(length(c-a),length(c-a)) - (l * l);\n         FalloffK_Asymmetric(sqrt(dd), max(length(c-b), length(c-a)), R, e,k_min,k_max);\n    } \n    \n    float g_d_min = min((dot(axis, normalize(a - c))), (dot(axis, normalize(b - c))));\n    float g_d_max = max((dot(axis, normalize(a - c))), (dot(axis, normalize(b - c))));\n    \n    if (g_d_min > 0.0) {\n\t    return g_d_min * k_max; \n\t}\n\telse {\n        return g_d_min * k_min;//min is extrema\n\t}\n    \n\n\n}\n//Helper functions\nfloat sqLength(vec3 v) { return dot(v,v); }\nfloat maxroot(float a, float b, float c) {\n    //argmaximum of the compact kernel in the form (ax^2+bx+c)^3\n\treturn (-sqrt(5.0f) * sqrt( -a * a * (4.0f * a * c - b * b)) - 5.0f * a * b) / (10.0f * a * a); \n}\nfloat maxroot_2(float a, float b, float c) {\n\treturn (sqrt(5.0f) * sqrt(-a * a * (4.0f * a * c - b * b)) - 5.0f * a * b) / (10.0f * a * a); \n}\nfloat d_f(float x, float a, float b, float c){\n    //derivative of the compact kernel in the form (ax^2+bx+c)^3\n\treturn (3.0f * (2.0f * a * x + b) * (x * (a * x + b) + c) * (x * (a * x + b) + c));\n}\n\nvec2 solvequadratic(float a, float b, float c) \n{\n   if (a == 0.){\n\t\tfloat root = -c/b;\n\t\treturn vec2(root);\n\t}\n  float delta = b * b - 4.0 * a * c;\n  if (delta > 0.0) {\n\n    float sign_b = b < 0.0 ? -1.0 : 1.0;\n    float q = -0.5 * (b + sign_b * sqrt(delta));\n    vec2 root = vec2(q / a, c / q);\n\n        //return ordered\n    if (root.y < root.x){\n      return root.yx;\n    } else {\n      return root.xy;\n    }\n  }\n  else {\n    return vec2(-1.0,-1.0); //todo\n  }\n}\nfloat VertexKSegmentAsymmetric_closedform(vec3 c, float R, float e, vec3 o, vec3 u, float t0, float t1)\n{\n    //Closed form max value of derivative of field along ray\n\n    vec3 m0 = o - c;\n    float invR2 = 1.0/(R*R);\n    //distance between point center and the ray is a quadratic polynomial on ray parameter t\n    vec3 q_d = vec3(-invR2, - 2.0*dot(m0,u) *invR2, 1.0 - sqLength(m0)*invR2);\n    \n    vec2 root = solvequadratic(q_d.x, q_d.y, q_d.z);\n    // get intersection of input and support ranges\n    float range_t0 = max(root.x,t0);\n    float range_t1 = min(root.y,t1);\n    if (range_t0 > range_t1) {\n      return 0.0;\n    }\n\t//argmaximum of the derivative of field function \t\n    float maxroot = maxroot(q_d.x, q_d.y, q_d.z);\n    //maximum value of derivative along the ray\n\tfloat d_f_max_global = d_f(maxroot, q_d.x, q_d.y, q_d.z);\n \n#if 0   \n    float maxroot2 = maxroot_2(q_d.x, q_d.y, q_d.z);\n    float d_f_max_global2 = d_f(maxroot2, q_d.x, q_d.y, q_d.z);\n    if(d_f_max_global2 > d_f_max_global){\n        d_f_max_global = d_f_max_global;\n        d_f_max_global = d_f_max_global2;\n    }\n#endif\n\n\t//calculate value of the derivative at interval end points    \n\tfloat d_f_t0 = d_f(range_t0, q_d.x, q_d.y, q_d.z);\n\tfloat d_f_t1 = d_f(range_t1, q_d.x, q_d.y, q_d.z);\n    \n\tfloat d_f_max = max(d_f_t0, d_f_t1);\n    \n\t//if the argmax is between t0 and t1, take the global max\n\tif (t0 < maxroot && t1 > maxroot) {\n\t\td_f_max = d_f_max_global;\n    }\n    \n    return d_f_max;\n}\n\n\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = dot((c - a),(c-a)) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(sqrt(dd), max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\n\n// K root\nfloat KSegmentAsymmetric(vec3 a, vec3 b)\n{\n    float K = VertexKSegmentAsymmetric(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegmentAsymmetric(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegmentAsymmetric(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\n\n\nfloat KSegmentAsymmetric_closedform(vec3 o, vec3 u, float t0, float t1)\n{\n    float K = VertexKSegmentAsymmetric_closedform(vec3(-radius / 2.0, 0, 0), radius, 1.0, o,u,t0,t1);\n    K += VertexKSegmentAsymmetric_closedform(vec3(radius / 2.0, 0, 0), radius, 1.0,o,u,t0,t1);\n    K += VertexKSegmentAsymmetric_closedform(vec3(radius / 3.0, radius, 0), radius, 1.0, o,u,t0,t1);\n    return K;\n}\n\n\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\nfloat LinearTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n#if GEOMETRIC\n        float signed_upper_bound = KSegmentAsymmetric(p, o + (t + candidate) * u);\n#else\n        float signed_upper_bound = KSegmentAsymmetric_closedform(o,u,t,t+candidate);\n#endif\n\n        float step = 0.; \n        //if bound is negative, skip the interval\n        if(signed_upper_bound <= 0.)\n            step = candidate;\n        else{\n            step = abs(v)/ signed_upper_bound;\n        }\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep){\n    \t//t = SphereTracing(ro, rd, hit, s); \n        t = LinearTracing(ro, rd, hit, s);\n    }\n    // Segment tracing on the right\n    else{\n        t = SegmentTracing(ro, rd, hit, s);\n        //t = SphereTracing(ro, rd, hit, s); \n    // Shade this with object\n    }\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}