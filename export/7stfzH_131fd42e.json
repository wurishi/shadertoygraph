{"ver":"0.1","info":{"id":"7stfzH","date":"1656087439","viewed":315,"name":"Textured Black Hole","username":"joteakus","description":"Now with janky textures from some prefab organic textures.  Bloom and a slight blur are added , and can be adjusted in Buffer B and Image respectively (samples and samplesize).","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["ray","light","space","raymarcher","blackhole","physics","gravity","raycaster","bending"],"hasliked":0,"parentid":"7dcBzr","parentname":"Black Hole Raycaster"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//All code 100% by joteakus\n//Textures included in shadertoy\nvec2 uv;\nvec3 col;\nvec3 thiscol;\nvec2 uvcenter;\nvec2 pixelstep;\nfloat samplestaken;\nfloat samples = 1.;\nfloat samplesize = 2.;\n\nvoid getpixel(vec2 change){\n\n    thiscol = texture(iChannel0, uv + samplesize*pixelstep*change).xyz;\n    col += thiscol;\n    samplestaken ++;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    uv = fragCoord/iResolution.xy;//-0.5;\n    //uv.x *= iResolution.x/iResolution.y;\n    pixelstep = vec2(1./iResolution);\n    col = texture(iChannel0, uv).xyz;\n    uvcenter = uv;\n    samplestaken = 0.;\n    for(float i = 0.; i < 5.; i++){\n    \n        getpixel(vec2(0.,i));\n        getpixel(vec2(i,0.));\n        getpixel(vec2(0.,-i));\n        getpixel(vec2(-i,0.));\n    \n    }\n    col /= samplestaken;\n    \n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//begin variable definitions\nvec2 uv; //2D uv space\nvec3 col; //RGB\nvec3 ray; //ray angle\nvec3 p; //ray end position\nvec3 camera = vec3(0.,0.8,-10.); //camera position\nvec3 bhp = vec3(0.,0.,0.); //black hole position\nvec3 temp;\nvec3 ringcol = vec3(1., 0.91764705882, 0.78823529411);\nfloat oradius; //distance to center of black hole\nfloat bhradius = 1.; //radius of event horizon\nfloat bhm = 0.025; //mass of black hole\nfloat G = 1.;  //big G\nfloat F; //force on ray\nfloat raylen; //length of ray\nfloat brightness; //brightness of band of disk\nfloat smallstepnum = 5.; //detail of ring checks (higher is slower but more precise)\nfloat d; //distance modifier for disk coloring\nconst float dtr = 3.14159265359/180.; //conversion of degrees to radians (dg*dtr=radians)\nbool hit;\nint hittype; //ring or event horizon (1/2)\n//end variable definitions\n//begin rotation functions\nvec3 xr(vec3 inp, float dir){\n\n    ray.x = inp.x;\n    ray.y = (inp.y*cos(dir))-(inp.z*sin(dir));\n    ray.z = (inp.y*sin(dir))+(inp.z*cos(dir));\n    return ray;\n\n}\n\nvec3 yr(vec3 inp, float dir){\n\n    ray.x = (inp.x*cos(dir))-(inp.z*sin(dir));\n    ray.y = inp.y;\n    ray.z = (inp.x*sin(dir))+(inp.z*cos(dir));\n    return ray;\n\n}\n\nvec3 zr(vec3 inp, float dir){\n\n    ray.x = (inp.x*cos(dir))-(inp.y*sin(dir));\n    ray.y = (inp.x*sin(dir))+(inp.y*cos(dir));\n    ray.z = inp.z;\n    return ray;\n\n}\n//end rotation functions\n//apply rotation fcuntions:\nvec3 transformUV(vec2 screenp, float fl, vec3 dir){\n\n    temp = zr(normalize(vec3(screenp, fl)), dir.z*dtr);\n    temp = xr(temp, dir.x*dtr);\n    temp = yr(temp, dir.y*dtr);\n    return temp;\n    \n\n}\n//steps ray forwards\nvoid moveray(float steps){\n    \n    //moves along the ray direction vector n units\n    p += ray*steps;\n    raylen += steps;\n\n}\n//begin ray\nvoid shootray(vec3 rv, vec3 or){\n\n    //initalize\n    ray = rv;\n    p = or;\n    raylen = 0.;\n    hit = false;\n    \n    //step ray untill collision or overshot\n    while(raylen < 20. && hit == false){\n    \n    hittype = 1; //intializes to event horizon, but collision with ring changes it\n    \n        oradius = distance(p, bhp);\n        if(bhradius < oradius){ //outside event horizon\n            \n            for(float i = 0.; i < smallstepnum; i++){ //move forward to check for ring\n            \n                if(distance(p.xz, bhp.xz)-bhradius < 3. && abs(bhp.y - p.y) < 0.01){ //ring collision, 0.02 is thickness, 3. is radius \n                \n                hit = true;\n                hittype = 2;\n                break;\n                \n                }\n            moveray(0.1/smallstepnum);\n            \n            }\n            \n            moveray(-0.1);\n            \n            if(hit == false){\n            \n                if(oradius > 0.1+bhradius){\n                    F = G*(bhm/(oradius*oradius)); //force = big G times mass divided by radius squared\n                    ray += F*(bhp-p);\n                    ray = normalize(ray); //makes ray usable again\n                    moveray(0.1);\n                }else{\n                    F = 0.1*G*(bhm/(oradius*oradius)); //force = big G times mass divided by radius squared\n                    ray += F*(bhp-p);\n                    ray = normalize(ray); //makes ray usable again\n                    moveray(0.01);\n                \n                \n                }\n            \n            }\n            \n        }else{\n        \n            hit = true; //for if past event hoizon\n            \n        }\n    \n    }\n    \n    if(hit == true && hittype == 2){\n    \n        //coloring mumbo jumbo\n        \n        //col = ringcol;\n        d = distance(bhp, p)-bhradius;\n        \n        p = yr(p, iTime/1.5-((d+0.)/2.));\n        p += 10.;\n        \n        col = texture(iChannel0, p.xz*10.*(1.+0.5*cos(iTime*0.1))).xyz;\n        col += texture(iChannel1, p.xz*10.*(1.+0.5*sin(iTime*0.1))).xyz;\n        col += 2.*texture(iChannel3, p.xz*0.1).xyz;\n        col /= 2.;\n        \n        \n        \n        \n        p -= 10.;\n        \n        d *= dtr;\n        //d = dtr*1.*(distance(bhp, p)-bhradius);\n        \n        brightness = 0.1+(0.2*sin(d*500.))+(0.4*sin(d*250.))+(0.6*sin(d*125.))+(0.8*sin(d*62.5));\n        \n        brightness /= 1.6955;\n        \n        brightness = 0.75+max(0.,brightness);\n        \n        col *= brightness;\n        \n        col = col*(0.00+0.5*((3.-(distance(bhp, p)-bhradius))/3.));\n        \n        \n        //p += 10.;\n        //col = texture(iChannel0, p.xz*0.1).xyz;\n        \n        \n        \n    }else{\n    \n        col = vec3(0.);\n             \n    }\n\n}\n//end ray\n//main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //setup uv for a raycaster\n    uv = fragCoord/iResolution.xy-0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    camera = vec3(0., 2.*sin(iTime*0.5), -10.+2.*cos(iTime*0.25));\n    \n    //shoot a ray from rotated uv space with focal length of 1.2, from camera\n    shootray(transformUV(uv, 1.2, vec3(7., 0., 20.)), camera);\n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 uv;\nvec3 col;\nvec3 thiscol;\nvec2 uvcenter;\nvec2 pixelstep;\nfloat samplestaken;\nfloat samples = 5.;\nfloat samplesize = 10.;\n\nvoid getpixel(vec2 change){\n\n    thiscol = texture(iChannel0, uv + samplesize*pixelstep*change).xyz;\n    col += thiscol;\n    samplestaken ++;\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    uv = fragCoord/iResolution.xy;//-0.5;\n    //uv.x *= iResolution.x/iResolution.y;\n    pixelstep = vec2(1./iResolution);\n    col = texture(iChannel0, uv).xyz;\n    uvcenter = uv;\n    samplestaken = -samples;\n    for(float i = 0.; i < 5.; i++){\n    \n        getpixel(vec2(0.,i));\n        getpixel(vec2(i,0.));\n        getpixel(vec2(0.,-i));\n        getpixel(vec2(-i,0.));\n    \n    }\n    col /= samplestaken;\n    col += texture(iChannel0, uv).xyz;\n    \n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}