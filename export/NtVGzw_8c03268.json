{"ver":"0.1","info":{"id":"NtVGzw","date":"1637386428","viewed":79,"name":"Vector Blend Test","username":"D_Bbomb","description":"A test of blending random vectors at each corner together for noise testing.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float ZOOM = 1.5;\nconst float BORDER_WIDTH = 0.025;\n\n// Note: This is just a quick test I threw together it may be a bit jank\n//\n// This is a test program for blending a gradient asociated to the 4 corners\n// of a square together for noise generation such as perlin noise.\n//\n// Mouse x controls fade of 4 input value inspectors to fade from \n// original to final component in central blended gradient.\n// [Mouse to left] = original gradients to be used\n// [Mouse to right] = componenet of original gradients used in blended gradient\n\n\n// Generate predictable random vec2 from float value\nvec2 randVec2(float x) \n{\n    return vec2(\n        fract(sin(x+0.211231f)*43758.5453123),\n        fract(sin(x+0.252311f)*45458.5423612)\n    );\n}\n\n// Generate corner vec2 value from float\nvec2 cornerVec2(float x)\n{\n    return (normalize(randVec2(x))-0.5f)*2.0f;\n}\n\n// Generate box mask for drawing\nfloat GetBoxMask(vec2 uv, float border)\n{\n    return ((max(abs(uv.x),abs(uv.y)) > border) ? 0.0 : 1.0);\n}\n\n// Generate gradient inspector zone\nvec3 GetGradientBoxTone(vec2 uv, vec2 pos, vec2 vec, float b)\n{\n    vec2 uvShift = (uv*2.)-pos;\n    float grad = dot(vec, uvShift);\n    float mask = GetBoxMask(uvShift, 1.+b);\n    float border = mask - GetBoxMask(uvShift, 1.);\n    return vec3(grad*mask, mask, border);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Seed for tile to generate\n    const float cornerSeed = 1.2;\n\n    // normalized mouse position\n    vec2 nm = iMouse.xy / iResolution.xy;\n\n    // Random vectors (4 corners)\n    vec2 v1 = cornerVec2(1.0+cornerSeed); // Upper Left\n    vec2 v2 = cornerVec2(2.0+cornerSeed); // Upper Right\n    vec2 v3 = cornerVec2(3.0+cornerSeed); // Lower Left\n    vec2 v4 = cornerVec2(4.0+cornerSeed); // Lower Right\n    \n    // Corner positions\n    vec2 c1 = vec2(-1, 1);\n    vec2 c2 = vec2( 1, 1);\n    vec2 c3 = vec2(-1,-1);\n    vec2 c4 = vec2( 1,-1);\n    \n    // Center and Normalize position\n    float resolutionMin = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - (0.5 * iResolution.xy))/resolutionMin;\n    uv *= ZOOM * 2.0;\n\n    // Calculate corner gradients\n    float cv1 = dot(v1, uv);\n    float cv2 = dot(v2, uv);\n    float cv3 = dot(v3, uv);\n    float cv4 = dot(v4, uv);\n\n    // Calculate base tone\n    float dx = (uv.x+1.)/2.;\n    float dy = (uv.y+1.)/2.;\n    float sdx = smoothstep(0.,1.,dx);\n    float sdy = smoothstep(0.,1.,dy);\n    float upper = cv1 + sdx*(cv2-cv1);\n    float lower = cv3 + sdx*(cv4-cv3);\n    float base = lower + sdy*(upper-lower);\n    \n    // Generate inspector box values \"vec3(value, mask, border)\"\n    vec3 v1Img = GetGradientBoxTone(uv, vec2(-3.-BORDER_WIDTH,1.), v1, BORDER_WIDTH);\n    vec3 v3Img = GetGradientBoxTone(uv, vec2(-3.-BORDER_WIDTH,-1.), v3, BORDER_WIDTH);\n    vec3 v2Img = GetGradientBoxTone(uv, vec2(3.+BORDER_WIDTH,1.), v2, BORDER_WIDTH);\n    vec3 v4Img = GetGradientBoxTone(uv, vec2(3.+BORDER_WIDTH,-1.), v4, BORDER_WIDTH);\n    \n    // Generate centeral box mask and border\n    float mask = GetBoxMask(uv, 1.+BORDER_WIDTH*0.5);\n    float border = mask - GetBoxMask(uv, 1.);\n    base = base*mask;\n    \n    // Create Acumulative border\n    border += v1Img.z;\n    border += v2Img.z;\n    border += v3Img.z;\n    border += v4Img.z;\n    \n    // Calculate Inspector boxes blend fields\n    float sdyt = smoothstep(0.,1.,dy*2.-1.);\n    float sdyb = 1.-smoothstep(0.,1.,dy*2.);\n    float sdxl = 1.-smoothstep(0.,1.,dx*2.+1.+BORDER_WIDTH);\n    float sdxr = smoothstep(0.,1.,dx*2.-2.-BORDER_WIDTH);\n    \n    // Add mouse controled fade blend field inspecors\n    float fade1 = v1Img.x * mix(1.0, sdyt*sdxl , nm.x);\n    float fade2 = v2Img.x * mix(1.0, sdyt*sdxr , nm.x);\n    float fade3 = v3Img.x * mix(1.0, sdyb*sdxl , nm.x);\n    float fade4 = v4Img.x * mix(1.0, sdyb*sdxr , nm.x);\n    \n    base = mix(base, fade1, v1Img.y);\n    base = mix(base, fade2, v2Img.y);\n    base = mix(base, fade3, v3Img.y);\n    base = mix(base, fade4, v4Img.y);\n    \n    // Generate Fragment Color\n    fragColor = vec4(vec3(base),1);\n    fragColor = mix(fragColor, vec4(0.,0.,1.,1.), clamp(border, 0., 1.));\n}\n\n","name":"Image","description":"","type":"image"}]}