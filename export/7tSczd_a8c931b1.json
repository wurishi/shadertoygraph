{"ver":"0.1","info":{"id":"7tSczd","date":"1650233469","viewed":198,"name":"Cornell box path tracing","username":"Langwedocjusz","description":"Based entirely on this great series of articles:\nhttps://blog.demofox.org/2020/05/25/casual-shadertoy-path-tracing-1-basic-camera-diffuse-emissive/","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EXPOSURE 0.66\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    const float a = 2.51f, b = 0.03f, c = 2.43f, d = 0.59f, e = 0.14f;\n    \n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    //Exposure adjustment:\n    color *= EXPOSURE;\n    // ACES tone mapping curve: HDR->LDR\n    color = ACESFilm(color);\n    // Linear -> sRGB for display:\n    color = LinearToSRGB(color);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MIN_DIST 0.0001\n#define MAX_DIST 10.0\n#define MAX_BOUNCES 8\n#define NORMAL_OFFSET 0.0003\n#define CAM_FOV_DEG 45.0\n\nconst float CAM_DIST = 1.0/tan(CAM_FOV_DEG * 0.5 * PI / 180.0);\n\nstruct Ray{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Material{\n    vec3 albedo;\n    vec3 emissive;\n    \n    float specularity;\n    float roughness;\n    vec3 spec_col;\n    \n    float ior;\n    float refractivity;\n    float refr_roughness;\n    vec3 refr_col;\n};\n\nstruct HitInfo{\n    float dist;\n    vec3 norm;\n    Material mat;\n    bool inside;\n};\n\nconst vec3 COL_BLACK = vec3(0.0);\nconst vec3 COL_WHITE = vec3(1.0);\nconst vec3 COL_RED = vec3(0.9, 0.1, 0.1);\nconst vec3 COL_GREEN = vec3(0.1, 0.9, 0.1);\nconst vec3 COL_BLUE = vec3(0.1, 0.1, 0.9);\nconst vec3 COL_BRIGHT = vec3(0.99);\nconst vec3 COL_LAMP = vec3(5.0);\n\nconst Material MAT_ZERO = Material(COL_BLACK, COL_BLACK,\n                                   0.0, 0.0, COL_BLACK,\n                                   1.0, 0.0, 0.0, COL_BLACK);\n\nconst Material MAT_WALL = Material(COL_BRIGHT, COL_BLACK, \n                                   0.0, 0.0, COL_BLACK, \n                                   1.0, 0.0, 0.0, COL_BLACK);\nconst Material MAT_WALL_GREEN = Material(COL_GREEN, COL_BLACK, \n                                         0.0, 0.0, COL_BLACK,\n                                         1.0, 0.0, 0.0, COL_BLACK);\nconst Material MAT_WALL_RED = Material(COL_RED, COL_BLACK, \n                                       0.0, 0.0, COL_BLACK,\n                                       1.0, 0.0, 0.0, COL_BLACK);\nconst Material MAT_LAMP = Material(COL_BLACK, COL_LAMP,\n                                   0.0, 0.0, COL_BLACK,\n                                   1.0, 0.0, 0.0, COL_BLACK);\nconst Material MAT_SPHERE = Material(COL_BRIGHT, COL_BLACK, \n                                     0.05, 0.5, COL_WHITE,\n                                     1.0, 0.0, 0.0, COL_BLACK);\nconst Material MAT_SPHERE2 = Material(COL_BRIGHT, COL_BLACK,\n                                      1.0, 0.4, COL_WHITE,\n                                      1.0, 0.0, 0.0, COL_BLACK);\nconst Material MAT_SPHERE3 = Material(COL_BRIGHT, COL_BLACK, \n                                      0.2, 0.0, COL_WHITE,\n                                      1.0, 0.0, 0.0, COL_BLACK);\nconst Material MAT_SPHERE4 = Material(COL_BRIGHT, COL_BLACK, \n                                      0.05, 0.0, COL_WHITE,\n                                      1.0, 1.0, 0.0, COL_BLACK);\nconst Material MAT_SPHERE5 = Material(COL_BRIGHT, COL_BLACK, \n                                      0.05, 0.0, COL_WHITE,\n                                      1.45, 1.0, 0.1, COL_WHITE-COL_BLUE);\n\n\n//======================================================================================\n\nvoid IntersectSphere(in Ray ray, inout HitInfo info, Material mat, vec3 pos, float r);\nvoid IntersectQuad(in Ray ray, inout HitInfo info, Material mat,\n                   in vec3 a, in vec3 b, in vec3 c, in vec3 d);\n\nvoid IntersectScene(in Ray ray, inout HitInfo info) {\n    const float up=0.6, down=-0.6, left=-0.5, right=0.5, front=-0.5, back=0.5;\n    \n    const vec3 luf = vec3(left, up, front);\n    const vec3 ruf = vec3(right, up, front);\n    const vec3 lub = vec3(left, up, back);\n    const vec3 rub = vec3(right, up, back);\n    const vec3 ldf = vec3(left, down, front);\n    const vec3 rdf = vec3(right, down, front);\n    const vec3 ldb = vec3(left, down, back);\n    const vec3 rdb = vec3(right, down, back);\n    \n    //displacement of the entire box\n    const vec3 d = vec3(0.0, 0.0, 2.0);\n    \n    //back wall\n    IntersectQuad(ray, info, MAT_WALL, d+lub, d+rub, d+rdb, d+ldb);\n\n    //top wall\n    IntersectQuad(ray, info, MAT_WALL, d+lub, d+rub, d+ruf, d+luf);\n\n    //bottom wall\n    IntersectQuad(ray, info, MAT_WALL, d+ldb, d+rdb, d+rdf, d+ldf);\n\n    //left wall\n    IntersectQuad(ray, info, MAT_WALL_RED, d+luf, d+lub, d+ldb, d+ldf);\n\n    //right wall\n    IntersectQuad(ray, info, MAT_WALL_GREEN, d+ruf, d+rub, d+rdb, d+rdf);\n    \n    //sphere\n    const vec3 d_sph = vec3(-0.25, -0.35, 0.25);\n    IntersectSphere(ray, info, MAT_SPHERE, d+d_sph, 0.25);\n\n    //sphere2\n    const vec3 d_sph2 = vec3(0.25, -0.35, 0.0);\n    IntersectSphere(ray, info, MAT_SPHERE2, d+d_sph2, 0.25);\n    \n    //sphere3\n    const vec3 d_sph3 = vec3(-0.1, 0.0, 0.1);\n    IntersectSphere(ray, info, MAT_SPHERE3, d+d_sph3, 0.1);\n\n    //sphere4\n    const vec3 d_sph4 = vec3(-0.10, -0.40, -0.40);\n    IntersectSphere(ray, info, MAT_SPHERE4, d+d_sph4, 0.2);\n    \n    //sphere5\n    const vec3 d_sph5 = vec3(0.30, 0.35, 0.25);\n    IntersectSphere(ray, info, MAT_SPHERE5, d+d_sph5, 0.2);\n    \n    //lamp\n    const vec3 scale = vec3(0.33, 1.0, 0.33);\n    IntersectQuad(ray, info, MAT_LAMP, d+scale*lub, d+scale*rub, d+scale*ruf, d+scale*luf);\n}\n\nfloat FresnelAmount(float n1, float n2, vec3 norm, vec3 incident, float f0, float f90);\n\nvec3 PathTrace(in Ray start_ray, inout uint rng_state) {\n    vec3 res = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n    Ray ray = start_ray;\n    \n    for (int i=0; i<=MAX_BOUNCES; i++) {\n        HitInfo info;\n        info.dist = MAX_DIST;\n        info.mat = MAT_ZERO;\n        info.inside = false;\n        \n        //Attempt to find intersection\n        IntersectScene(ray, info);\n        \n        //If a ray gets too far away, read environment lighting from cubemap and exit\n        if (i>0 && info.dist == MAX_DIST) {\n            res += SRGBToLinear(texture(iChannel1, ray.dir).rgb) * throughput;\n            break;\n        }\n        \n        //Calculate absorption if hitting surface from inside the object\n        if (info.inside) throughput *= exp(-info.mat.refr_col * info.dist);\n        \n        //Obtain the chances of ray being specular/refractive\n        float spec_chance = info.mat.specularity;\n        float refr_chance = info.mat.refractivity;\n        \n        //Adjust them, taking fresnel effect into account\n        float ray_probability = 1.0;\n        \n        if (spec_chance > 0.0) {\n            spec_chance = FresnelAmount(info.inside ? info.mat.ior : 1.0,\n                                       !info.inside ? info.mat.ior : 1.0,\n                                        ray.dir, info.norm, \n                                        info.mat.specularity, 1.0);\n                                        \n            refr_chance *= (1.0-spec_chance)/(1.0-info.mat.specularity);\n        }\n        \n        //Decide what to do (specular, refraction or diffuse)\n        float do_spec = 0.0, do_refr = 0.0;\n        float rand = RandomFloat01(rng_state);\n        \n        if (spec_chance >= 0.0 && rand < spec_chance) {\n            do_spec = 1.0;\n            ray_probability = spec_chance;\n        }\n        else if (refr_chance >= 0.0 && rand < spec_chance + refr_chance) {\n            do_refr = 1.0;\n            ray_probability = refr_chance;\n        }\n        else {\n            ray_probability = 1.0 - (spec_chance + refr_chance);\n        }\n        \n        //Avoid division by 0\n        ray_probability = max(ray_probability, 0.001);\n        \n        //Move ray origin to the intersection point + normal based offset\n        if (do_refr == 1.0)\n            ray.org += info.dist*ray.dir - NORMAL_OFFSET*info.norm;\n        else\n            ray.org += info.dist*ray.dir + NORMAL_OFFSET*info.norm;\n            \n        //Calculate new ray direction\n        //Diffuse\n        vec3 diffuse_dir = normalize(info.norm + RandomUnitVector(rng_state));\n        //Specular\n        vec3 spec_dir = reflect(ray.dir, info.norm);\n        spec_dir = normalize(mix(spec_dir, diffuse_dir, \n                                     info.mat.roughness * info.mat.roughness));\n        //Refraction                     \n        vec3 refr_dir = refract(ray.dir, info.norm,\n                                info.inside ? info.mat.ior/1.0 : 1.0/info.mat.ior);\n        refr_dir = normalize(mix(refr_dir, normalize(-info.norm + RandomUnitVector(rng_state)),\n                                 info.mat.refr_roughness * info.mat.refr_roughness));\n        //Combination\n        ray.dir = mix(diffuse_dir, spec_dir, do_spec);\n        ray.dir = mix(ray.dir, refr_dir, do_refr);\n        \n        //Add the emissive lighting in\n        res += info.mat.emissive * throughput;\n        \n        //Gather albedo/specular of hit surface\n        if (do_refr==0.0)\n            throughput *= mix(info.mat.albedo, info.mat.spec_col, do_spec);\n        throughput /= ray_probability;\n        \n        //Russian Roulette to end tracing earlier\n        float p = max(throughput.r, max(throughput.g, throughput.b));\n        if (RandomFloat01(rng_state) > p) break;\n        \n        throughput *= 1.0/p;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint rng_state = SeedRNG(fragCoord, iFrame);\n    //Sub-pixel noise to the ray origin - acts like multisample antialiasing\n    vec2 jitter = vec2(RandomFloat01(rng_state), RandomFloat01(rng_state)) - 0.5f;\n    \n    vec2 uv = (2.0*(fragCoord+jitter) - iResolution.xy)/iResolution.y;\n    \n    vec3 ray_org = vec3(0.0);\n    vec3 ray_end = vec3(uv, CAM_DIST);\n    vec3 ray_dir = normalize(ray_end - ray_org);\n    \n    vec3 col = PathTrace(Ray(ray_org, ray_dir), rng_state);\n    \n    vec3 prev_col = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    col = mix(prev_col, col, 1.0/float(iFrame+1));\n    \n    fragColor = vec4(col, 1.0);\n}\n\n//======================================================================================\n\n//Based on intersectors by Inigo Quilez: https://iquilezles.org/articles/intersectors/\n\nvoid IntersectSphere(in Ray ray, inout HitInfo info, Material mat, vec3 pos, float r) {\n    vec3 d = ray.org - pos;\n    \n    float b = dot(d, ray.dir);\n    float c = dot(d, d) - r*r;\n    float h = b*b - c;\n    \n    if (h >= 0.0) {\n        float dist = -b - sqrt(h);\n        bool inside = false;\n        \n        if (dist<0.0) {\n            dist = -b + sqrt(h);\n            inside = true;\n        } \n        \n        if (dist > MIN_DIST && dist < info.dist) {\n            info.dist = dist;\n            info.norm = normalize(ray.org + dist * ray.dir - pos);\n            if (inside) info.norm *= -1.0;\n            info.inside = inside;\n            info.mat = mat;\n        }\n    }\n    \n}\n\nvoid IntersectTriangle(in Ray ray, inout HitInfo info, Material mat,\n                       in vec3 a, in vec3 b, in vec3 c) {\n    vec3 ba = b - a;\n    vec3 ca = c - a;\n    vec3 oa = ray.org - a;\n    \n    vec3 n = cross(ba, ca);\n    vec3 q = cross(oa, ray.dir);\n    \n    float d = 1.0/dot(ray.dir, n);\n    \n    float u = d*dot(-q, ca);\n    float v = d*dot(q, ba);\n    float t = d*dot(-n, oa);\n    \n    if (u>0.0 && v>0.0 && (u+v)<1.0) {\n        if (t<=info.dist && t>MIN_DIST){\n            n = normalize(n);\n            info.dist = t;\n            info.norm = (dot(n, ray.dir) <= 0.0) ? n : -n;\n            info.inside = false;\n            info.mat = mat;\n        }\n    }\n    \n}\n\nvoid IntersectQuad(in Ray ray, inout HitInfo info, Material mat,\n                   in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    IntersectTriangle(ray, info, mat, a, b, c);\n    IntersectTriangle(ray, info, mat, d, a, c);\n}\n\n//======================================================================================\n\nfloat FresnelAmount(float n1, float n2, vec3 norm, vec3 incident, float f0, float f90) {\n    // Schlick aproximation\n    float r0 = (n1-n2)/(n1+n2);\n    float r02 = r0*r0;\n    float cosX = -dot(norm, incident);\n    \n    if (n1>n2) {\n        float n = n1/n2;\n        float sinT2 = n*n*(1.0-cosX*cosX);\n        // Total internal reflection\n        if (sinT2>1.0)\n            return f90;\n        cosX = sqrt(1.0 - sinT2);\n    }\n    \n    float x = 1.0-cosX;\n    float ret = r0 + (1.0-r0)*x*x*x*x*x;\n \n    // adjust reflect multiplier for object reflectivity\n    return mix(f0, f90, ret);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n\n//Pseudo random numbers:\n\nuint SeedRNG(vec2 uv, int frame) {\n    return uint(uint(uv.x) * uint(1973) + uint(uv.y) \n                   * uint(9277) + uint(frame) * uint(26699)) | uint(1);\n}\n\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0 - 1.0;\n    float a = RandomFloat01(state) * 2.0 * PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n//Color conversions:\n\nvec3 LessThan(vec3 f, float value)\n{\n    return vec3(\n        (f.x < value) ? 1.0f : 0.0f,\n        (f.y < value) ? 1.0f : 0.0f,\n        (f.z < value) ? 1.0f : 0.0f);\n}\n \nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(rgb, vec3(1.0f / 2.4f)) * 1.055f - 0.055f,\n        rgb * 12.92f,\n        LessThan(rgb, 0.0031308f)\n    );\n}\n \nvec3 SRGBToLinear(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0f, 1.0f);\n     \n    return mix(\n        pow(((rgb + 0.055f) / 1.055f), vec3(2.4f)),\n        rgb / 12.92f,\n        LessThan(rgb, 0.04045f)\n    );\n}","name":"Common","description":"","type":"common"}]}