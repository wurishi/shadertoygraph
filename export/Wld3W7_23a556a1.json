{"ver":"0.1","info":{"id":"Wld3W7","date":"1576610661","viewed":198,"name":"Radioactive","username":"onlinerocker","description":"Warning: Highly radioactive. Do not touch the blob.\nStill making tweaks, but I'll make this public for now ;)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong","lighting","deformation","green","slime","goo","xbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\nstruct Object\n{\n \tfloat dist;\n    float specVal;\n    float specKs;\n    float normEps; //artifacting was occuring for some objects when this value was too high\n    \t\t\t   //thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \n//https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 pos, float rad)\n{\n \treturn length(pos) - rad;   \n}\n\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdCappedCylinder( vec3 p, float h, float r, float rd)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rd;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nmat4 getTransXYZ(float alpha, float beta, float gamma, float x, float y, float z)\n{\n \tvec4 col =  vec4(cos(beta)*cos(gamma),\n                     cos(alpha)*sin(gamma) + sin(alpha)*sin(beta)*cos(gamma),\n                     sin(alpha)*sin(gamma) - cos(alpha)*sin(beta)*cos(gamma),\n                     0);\n    \n    vec4 col1 = vec4(-cos(beta)*sin(gamma),\n                      cos(alpha)*cos(gamma) - sin(alpha)*sin(beta)*sin(gamma),\n                      sin(alpha)*cos(gamma) + cos(alpha)*sin(beta)*sin(gamma),\n                      0);\n                     \n    vec4 col2 = vec4(sin(beta),\n                    -sin(alpha)*cos(beta),\n                     cos(alpha)*cos(beta),\n                     0);\n                     \n    vec4 col3 = vec4(x, y, z, 1);\n                    \n    return mat4(col,\n                col1,\n                col2,\n                col3);\n    \n}\n\nfloat fmod(float x, float y)\n{\n \treturn x - y * floor(x/y); \n}\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nObject map(vec3 pos)\n{\n    Object o;\n    o.dist = 1000.0;\n    o.normEps = 0.0001;\n    \n    vec3 ballPos = pos;\n    ballPos.z = abs(ballPos.z);\n                                \n    float dBaseBall = sdSphere(ballPos - vec3(0, -2.1, 0.85), 0.16);    \n    if(dBaseBall < o.dist)\n    {\n        o.dist = smin(o.dist, dBaseBall, 0.1);\n        o.color = vec3(60.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 0.5;\n        o.normEps = 0.000001;\n    }\n    \n    vec3 ball1Pos = pos;\n    ball1Pos.x = abs(ball1Pos.x);\n    float dBaseBall1 = sdSphere(ball1Pos - vec3(0.8, -2.1, 0.2), 0.16); \n    if(dBaseBall1 < o.dist)\n    {\n        o.dist = smin(o.dist, dBaseBall1, 0.1);\n        o.color = vec3(60.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 0.5;\n        o.normEps = 0.000001;\n    }\n    \n    vec3 ball2Pos = pos;\n    ball2Pos.x = abs(ball2Pos.x);\n    ball2Pos.z = abs(ball2Pos.z);\n    float dBaseBall2 = sdSphere(ball2Pos - vec3(0.5, -2.1, 0.66), 0.16);\n    \n    if(dBaseBall2 < o.dist)\n    {\n        o.dist = smin(o.dist, dBaseBall2, 0.1);\n        o.color = vec3(60.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 55.0;\n        o.specKs = 0.5;\n        o.normEps = 0.000001;\n    }\n    \n    /*float dBaseBallBig = sdSphere(pos - vec3(0, -2.25, 0.0), 0.52);\n    o.dist = smin(o.dist, dBaseBallBig, 0.1);\n    if(dBaseBallBig < o.dist)\n    {\n        o.color = vec3(23.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 55.0;\n        o.normEps = 0.000001;\n    }*/\n    \n\n    float dTubeBase = sdCappedCylinder(pos - vec3(0, -2.26, 0), 1.1, 0.15, 0.02);\n    float dTubeBaseBtm = sdCappedCylinder(pos - vec3(0, -2.55, 0), 2.0, 0.15, 0.03);\n    float dTubeBaseRing = sdTorus(pos - vec3(0, -2.445, 0), vec2(1.65, 0.1));\n    dTubeBase = smin(dTubeBaseBtm, dTubeBase, 0.02);\n    dTubeBase = smin(dTubeBase, dTubeBaseRing, 0.01);\n    if(dTubeBase < o.dist)\n    {\n        o.dist = dTubeBase;\n        o.color = vec3(23.0 / 255.0, 23.0/255.0, 30.0/255.0);\n        o.specVal = 10.0;\n        o.specVal = 2.5;\n        o.specKs = 0.5;\n        o.normEps = 0.000001;\n    }\n\n    vec3 pipePos = pos;\n    pipePos.x = abs(pipePos.x);\n    float dPipeBound = sdSphere(pipePos - vec3(1.8, -3., 1.8), 1.0);    \n    if(dPipeBound < o.dist)\n    {\n\n        float ang = PI/2.0;\n        vec2 col1 = vec2(cos(ang), sin(ang));\n        vec2 col2 = vec2(-sin(ang), cos(ang));\n        mat2 rotMat = mat2(col1, col2);\n\n        vec2 col3 = vec2(cos(-ang/2.0), sin(-ang/2.0));\n        vec2 col4 = vec2(-sin(-ang/2.0), cos(-ang/2.0));\n        mat2 rotMat1 = mat2(col3, col4);\n\n        pipePos = vec3(pipePos.x, rotMat * pipePos.yz);\n        pipePos = vec3(rotMat1 * pipePos.xy, pipePos.z);\n\n\n        float dPipe = sdCappedCylinder(pipePos - vec3(-0.2,-2.9,-2.8), 0.3, 0.91, 0.02);\n        if(dPipe < o.dist)\n        {\n            o.dist = smin(o.dist , dPipe, 0.02);\n            o.color = vec3(23.0 / 255.0, 23.0/255.0, 30.0/255.0);\n            o.specVal = 10.0;\n            o.specVal = 5.5;\n            o.specKs = 0.5;\n            o.normEps = 0.0001;\n        }\n    }\n\n    \n    float dSphereBound = sdSphere(pos-vec3(0,-1.,0), 1.3); //blob's bounding sphere\n    if(dSphereBound < o.dist)\n    {\n        //o.dist = sphereBound; //uncomment to show bounding sphere...\n        vec3 spherePos = vec3(getTransXYZ(0., iTime/2.0, .0, .0, .0, .0) * vec4(pos, 1));\n\n        //modified version of deformation pattern at \n        //https://iquilezles.org/articles/distfunctions\n        float xMod = 0.12*cos(iTime/2.0)*sin(12.0*spherePos.y)*sin(12.0*spherePos.x)*sin(12.0*spherePos.z);\n        float yMod = 0.12*cos(iTime/2.0)*cos(spherePos.y)*sin(10.0*spherePos.x)*sin(10.0*spherePos.z);\n        float zMod = 0.12*(cos(iTime/2.0))*sin(10.0*spherePos.y)*sin(10.0*spherePos.x)*sin(9.0*spherePos.z);\n\n        spherePos = vec3(getTransXYZ(0., 1.5*iTime, .0, .0, .0, .0) * vec4(spherePos, 1));\n        spherePos = (spherePos - vec3(.0, -1.1, .0) - vec3(xMod, yMod, zMod));\n\n        float dSphere = sdSphere(spherePos, 1.0);\n\n        if(dSphere < o.dist)\n        {\n            o.dist = dSphere;\n            o.color = vec3(.1, 0.5, .1);\n            o.specVal = 50.0;\n            o.specKs = 1.0;\n            o.normEps = 0.0001;\n        }      \n    }\n    \n\n    \n    return o;\n}\n\nvec3 calcNorm(vec3 pos, float eps)\n{\n    float ep = min(0.0001, eps);\n    //float ep = 0.0001;\n \tfloat x = map(pos + vec3(ep, .0, .0)).dist - map(pos - vec3(ep, .0, .0)).dist;\n    float y = map(pos + vec3(.0, ep, .0)).dist - map(pos - vec3(.0, ep, .0)).dist;\n   \tfloat z = map(pos + vec3(.0, .0, ep)).dist - map(pos - vec3(.0, .0, ep)).dist;\n    return normalize(vec3(x,y,z));\n}\n\nfloat calcLight(vec3 pos, vec3 lightDir)\n{\n    return dot(pos, lightDir);\n}\n\nMarchRes marchRays(vec3 pos, vec3 dir)\n{\n    MarchRes res;\n    Object o;\n    float totalDist = 0.001;\n    vec3 curRay = pos;\n    for(int x=0; x<100; x++)\n    {\n        curRay = pos + (dir*totalDist);\n     \to = map(curRay);\n        \n        if(abs(o.dist) < 0.0002)\n            break;\n        if(totalDist > 20.0)\n            break;\n        \n        totalDist += o.dist*0.85; //slow down to handle insane morphing of sphere\n    }\n    \n    res.totalDist = totalDist;\n    res.curRay = curRay;\n    res.obj = o;\n\n    if(totalDist <= 20.0)\n        res.obj.normal = calcNorm(curRay, res.obj.normEps);\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.x)/iResolution.y;\n\tvec3 camEye = vec3(0, 0.0, 3.2 + -0.5*sin(iTime/3.0));\n    vec3 dir = vec3(uv, -1);\n    dir = normalize(dir);\n    \n    vec3 light = vec3(0, 10, 10);\n    vec3 lightBlob = vec3(1., -0.5, 0.);\n    float lightTime = fmod(iTime, 7.0);\n    float lightInt = 2.7 + fract(lightTime*lightTime / 3.0);\n    float lightBlobInt = 2.0;\n    vec3 lightCol = vec3(0.4,0.55,0.4);;\n    vec3 lightBlobCol = vec3(0., 0.2, 0);\n    \n    MarchRes res = marchRays(camEye, dir);\n    vec3 col = vec3(0);\n    if(res.totalDist < 20.0)\n    {\n        vec3 pos = res.curRay;\n        \n        float lightShadow = step(20.0, marchRays(pos, normalize(light)).totalDist);\n        vec3 lightDif = lightCol * clamp(calcLight(res.obj.normal, normalize(light - pos)), 0.0, 1.0) * lightInt;\n        vec3 lightSpecR = 2.0 * \n            clamp(dot(res.obj.normal, normalize(light-pos)), 0.0, 1.0) \n            * res.obj.normal - normalize(light-pos);\n        \n        float lightSpec = clamp(dot(normalize(camEye-pos), lightSpecR), 0.0, 1.0);\n        \n        vec3 lightBlobFinal = lightBlobCol * clamp(calcLight(res.obj.normal, normalize(lightBlob - pos)), .0, 1.) * lightBlobInt;\n        col = res.obj.color * (lightCol*lightDif) * lightShadow;\n        col += lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n        \n    }\n        \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}