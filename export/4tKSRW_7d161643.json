{"ver":"0.1","info":{"id":"4tKSRW","date":"1483276893","viewed":147,"name":"Blue Spoke Wheel","username":"ptrgags","description":"Another happy accident. I was in the process of making something along the lines of polar graph paper, but I'm taking this snapshot since I thought it looked cool.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","grid","distance","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CENTER (iResolution.xy / 2.0)\n#define PI 3.1415\n#define TAU (2.0 * PI)\n\nvec2 rect_to_polar(vec2 rect) {\n    float r = length(rect);\n    float theta = atan(rect.y, rect.x);\n    \n    //Fix the coordinates so they go from 0 to 2PI\n    //instead of -PI to PI\n    if (theta < 0.0)\n        theta += TAU;\n    return vec2(r, theta);\n}\n\n//max component of 2-vector.\nfloat vecmax(vec2 p) {\n    return max(p.x, p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Centered UV coords accounting for aspect ratio\n\tvec2 uv = (fragCoord.xy - CENTER) / iResolution.y;\n    \n    //Convert to polar and normalize angle\n    vec2 polar = rect_to_polar(uv);\n    \n    //Rotate over time\n    polar.y += iTime;\n    \n    //Normalize the angle\n    polar.y /= TAU;\n    \n    //Divide into boxes\n    polar *= vec2(10.0, 24.0);\n    vec2 polar_uv = fract(polar);\n    \n    //Get distance from center of each box\n    vec2 dist = abs(polar_uv - 0.5);\n    \n    //The distance vector uses two channels for x and y.\n    //Take the max value to convert to a single color channel.\n    float brightness = vecmax(dist);\n    //Color the grid.\n    fragColor = brightness * vec4(0.0, 0.5, 1.0, 1.0);\n\t\n}","name":"Image","description":"","type":"image"}]}