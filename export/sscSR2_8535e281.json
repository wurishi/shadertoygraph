{"ver":"0.1","info":{"id":"sscSR2","date":"1633520390","viewed":97,"name":"28/49","username":"tono","description":"28/49","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["49"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat menger(vec3 p,vec3 offset)\n{\n    float scale = 1.8;\n    vec4 z = vec4(p,1.);\n    for(int i = 0;i < 3;i++)\n    {\n        //z.yz *= rot(float(i) * 2.);\n        z = abs(z);  \n        //if(z.x < z.y)z.xy = z.yx;\n        if(z.x < z.z)z.xz = z.zx;\n        if(z.y < z.z)z.yz = z.zy;\n        z *= scale;  \n        z.xyz -= offset * (scale - 1.);\n        if(z.z < -.5 * offset.z * (scale - 1.) )\n            z.z += offset.z * (scale - 1.);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0))) / z.w;\n}\nfloat pi = acos(-1.);\nvec3 pp;\nvec2 map(vec3 p)\n{\n    float o = 10.;\n    float id = 0.;\n    \n    //p.xy = sin(p.xy);\n    vec3 shift = vec3(2.5,6.5,3.2);\n    // float t = floor(iTIme)+pow(fract(iTIme),4.);\n    // shift.xy *= rot(t * pi/5. );\n    // shift.xy = sin(shift.xy)+1.3;\n    o = menger(p,shift);\n    pp = p;\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0 ; i< 99 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth,d.y);\n        }\n        depth += d.x;\n    }\n    return vec2(-depth , 0.);\n\n}\n\nvec2 random22(vec2 st)\n{\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n                dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nvec3 celler2D(vec2 i,vec2 sepc)\n{\n    vec2 sep = i * sepc;\n    vec2 fp = floor(sep);\n    vec2 sp = fract(sep);\n    float dist = 5.;\n    vec2 ouv = vec2(0.);\n    vec2 mp = vec2(0.);\n\tfloat t = floor(iTime/3.) + pow(fract(iTime/3.),3.);\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int x = -1; x <= 1; x++)\n            {\n                vec2 neighbor = vec2(x, y );\n                vec2 rpos = vec2(random22(fp+neighbor));\n                vec2 pos = sin( (rpos*6. +t * pi * 1.3) )* 0.5 + 0.5;\n                float divs = length(neighbor + pos - sp);\n                if(dist > divs)\n                {\n                    ouv = rpos + neighbor + fp;\n                    mp = pos;\n                \tdist = divs;\n                }\n            }\n    }\n    return vec3(ouv,dist);\n}\n\nfloat getEdge(vec2 p,vec2 s)\n{\n    vec3 e = vec3(1.0, -1.0,0.) * 0.01;\n    vec2 edge = celler2D(p + e.xy,s).xy +\n                 celler2D(p + e.yx,s).xy -\n                 celler2D(p + e.xx,s).xy -\n                 celler2D(p + e.yy,s).xy +\n                celler2D(p + e.zx,s).xy -\n                celler2D(p + e.zy,s).xy +\n                celler2D(p + e.xz,s).xy -\n                celler2D(p + e.yz,s).xy;\n    edge = abs(edge);\n    return step(max(edge.x,edge.y),0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float fn = .2;\n    vec3 cell = celler2D(p,vec2(fn));\n    //cell = celler2D(cell.xy * p,vec2(3.))/3.;\n\tvec3 cp = vec3(0.,0.,-6.);\n    cp -= cell;\n    cp.xz *= rot(iTime/12.);\n    vec3 target = vec3(0.);\n    float t = clamp(sin(iTime+ cell.x/2.),-0.5,.5) + .5;\n    t = .3;\n    cell.z = mix(cell.z,-1.,1.);\n    target = mix(target,cell * 10.,t);\n    \n    vec3 col = vec3(1.);\n    \n    vec3 cd = normalize(vec3(target - cp));\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    \n    float fov = 2.5;\n    \n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    \n    vec2 d = march(cp,rd);\n    if( d.x > 0.)\n    {\n        vec2 e = vec2(1.0, -1.0) * 0.005;\n        vec3 pos = cp + rd * d.x;\n        vec3 N = normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        //sun.xz *= rot(iTIme);\n        float diff = max(0.,dot(-sun,N));\n        diff = mix(diff , 1.,.1);\n        float sp = max(0.,dot(rd,reflect(N,sun)));\n        sp = pow(sp,56.6) * 1.;\n        float rim = pow(clamp(1. - dot(N, -rd), 0., 1.), 12.)/.1;\n        vec3 mat = vec3(0.);\n        mat.r = 0.;\n        col = sp * mat + diff * mat + rim;\n    }\n   // col.rg += cell.rg;\n    col *= 1. - cell.z;\n    col *= getEdge(p,vec2(fn));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}