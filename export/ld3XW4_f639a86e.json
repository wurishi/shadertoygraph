{"ver":"0.1","info":{"id":"ld3XW4","date":"1459284673","viewed":1425,"name":"Emboss filter","username":"sepehr","description":"Emboss effect achieved with convolution into an Emboss kernel.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["filter","emboss","photoshop","kernel","mean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Source:\n// http://coding-experiments.blogspot.com/2010/07/convolution.html\n\n#define EMBOSS_WIDTH\t0.0015\n#define EMBOSS_HEIGHT\t0.0015\n\n// samples a pixel centerd at \"uv\" and with offset of dx|dy\nvec4 sample_pixel(in vec2 uv, in float dx, in float dy)\n{\n    return texture(iChannel0, uv + vec2(dx, dy));\n}\n\n// convolves a SINGLE channel of input color_matrix\nfloat convolve(in float[9] kernel, in vec4[9] color_matrix)\n{\n   float res = 0.0;\n   for (int i=0; i<9; i++)\n   {\n      res += kernel[i] * color_matrix[i].a;\n   }\n   return clamp(res + 0.5, 0.0 ,1.0);\n}\n\n// builds a 3x3 color matrix centerd at \"uv\"\nvoid build_color_matrix(in vec2 uv, out vec4[9] color_matrix)\n{\n    float dxtex = EMBOSS_WIDTH;\n    float dytex = EMBOSS_HEIGHT;\n\n\tcolor_matrix[0].rgb = sample_pixel(uv, -dxtex, -dytex)\t.rgb;\n\tcolor_matrix[1].rgb = sample_pixel(uv, -dxtex, \t0.0)\t.rgb;\n    color_matrix[2].rgb = sample_pixel(uv, -dxtex, \tdytex)\t.rgb;\n\tcolor_matrix[3].rgb = sample_pixel(uv, 0.0, \t-dytex)\t.rgb;\n\tcolor_matrix[4].rgb = sample_pixel(uv, 0.0, \t0.0)\t.rgb;\n    color_matrix[5].rgb = sample_pixel(uv, 0.0, \tdytex)\t.rgb;\n\tcolor_matrix[6].rgb = sample_pixel(uv, dxtex, \t-dytex)\t.rgb;\n\tcolor_matrix[7].rgb = sample_pixel(uv, dxtex, \t0.0)\t.rgb;\n    color_matrix[8].rgb = sample_pixel(uv, dxtex, \tdytex)\t.rgb;\n}\n\n// builds a mean color matrix (off of .rgb of input).\n// NOTE: stores the output in alpha channel\nvoid build_mean_matrix(inout vec4[9] color_matrix)\n{\n   for (int i=0; i<9; i++)\n   {\n      color_matrix[i].a = (color_matrix[i].r + color_matrix[i].g + color_matrix[i].b) / 3.;\n   }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\t2.\t0.\t0.\n\t\t0.\t-1\t0.\n\t\t0.\t0.\t-1\t*/\n    \n    float kerEmboss[9];\n    kerEmboss[0] = 2.0;\n    kerEmboss[1] = 0.0;\n    kerEmboss[2] = 0.0;\n    kerEmboss[3] = 0.0;\n    kerEmboss[4] = -1.;\n    kerEmboss[5] = 0.0;\n    kerEmboss[6] = 0.0;\n    kerEmboss[7] = 0.0;\n    kerEmboss[8] = -1.;\n    \n    vec4 pixel_matrix[9];\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    build_color_matrix(uv, pixel_matrix);\n    build_mean_matrix(pixel_matrix);\n    \n    float convolved = convolve(kerEmboss, pixel_matrix);\n\tfragColor = vec4(vec3(convolved) ,1.0);\n}\n","name":"Image","description":"","type":"image"}]}