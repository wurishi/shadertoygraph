{"ver":"0.1","info":{"id":"MlSBDm","date":"1516195773","viewed":326,"name":"brick arches raymarch","username":"benhardy","description":"Generating stone brick arches","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","architecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 ORIGIN = vec3(0,0,0);\n\n#define MAX_STEP 1000\n#define MAX_DIST 200.0\n#define STEP_RATIO 0.25\n#define EPSILON 0.001\n\n// really it's a bowl\n\n#define PI 3.141592654\n\n//shadows *really* slow things down\n#define SHADOWS\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float power;\n};\n\nLight light_1 = Light(vec3(1000,3000,2000), vec3(1,1,1), 10000000.0);\nLight light_2 = Light(vec3(-3000,1000,-2000), vec3(1,1,0.5), 10000000.0);\n\nfloat measure_to_building(vec3 global_where) {\n    vec3 local_where = mod(global_where - vec3(25,0,25), 80.0);\n    vec3 bl = abs(local_where) - vec3(40,20,40);\n    return length(max(bl, ORIGIN));\n}\n\nfloat measure_to_ground(vec3 where) {\n    return where.y;\n}\n\nfloat round_edge(float dist_1, float dist_2, float radius) {\n    float edge = length(vec2(dist_1, dist_2));\n    return min(edge -radius, max(dist_1 -radius, dist_2 - radius));\n}\n\nfloat torus(vec3 where, float major, float minor) {\n  vec2 q = vec2(length(where.xy) - major, where.z);\n  return length(q) - minor;\n}\n\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n/**\n * return polar vector of (angle, radius)\n */\nvec2 to_polar(vec2 where) {\n    return vec2(atan(where.x, where.y), length(where));\n}\n\n/** centred modulo */\nfloat cmod(float x, float m) {\n    return mod(x + m/2.0, m) - m/2.0;\n}\n\nfloat round_box(vec2 where, vec2 dims, float rounding) {\n    return length(max(abs(where) - dims, 0.0)) - rounding;\n}\nfloat round_box_3(vec3 where, vec3 dims, float rounding) {\n    return length(max(abs(where) - dims, 0.0)) - rounding;\n}\n#define united min\n#define intersect max\n#define difference(a,b) max((a), -(b))\n\nfloat interesting_shape(vec3 where_in) {\n    float repetition = 6.2;\n    float room_size = 62.0;\n    where_in.z = abs(abs(cmod(where_in.z, room_size))-3.1);\n    where_in.x = abs(cmod(where_in.x, room_size));\n   //where_in = abs(where_in);\n    \n    //where_in.xz = mod(where_in.xz, repetition*10.0);\n    vec3 where = where_in;\n    if (where_in.z > where_in.x) {\n        where.x = where_in.z;\n        where.z = where_in.x;\n    }\n    //= where_in;// vec3(min(where_in.x,where_in.z),where_in.y,max(where_in.x,where_in.z));\n    /*\n    vec3 where = vec3(\n        where_in.z > where_in.x ? where_in.z : where_in.x,\n        where_in.y - 3.0,\n        where_in.z > where_in.x ? where_in.x : where_in.z\n\t);*/\n    where.x -= repetition /2.0;\n    where.y -= 8.0;\n    float wall_thickness = 0.6;\n    float front = where.z - wall_thickness * 0.5;\n    float top = where.y - 8.0;\n    float wall = intersect(front, top);\n\n    float hole_radius = 4.3;\n\twhere.x = abs(cmod(where.x, repetition));\n    float hx = where.x+hole_radius/2.0;\n    float hole_round = length(vec2(hx, max(0.0,where.y))) - hole_radius;\n    float hole_lower = intersect(hx, where.y);\n    float hole_total = united(hole_round, hole_lower);\n    \n    float main = difference(wall, hole_total);\n    vec2 edge_bulk = vec2(0.0, 0.0);\n    float rounding = 0.1;\n    float hole_edge = round_box(vec2(wall, -hole_total), edge_bulk, rounding);\n    //return max(where.z-1.0,edge);\n    \n    //float more = round_box(vec2(hole_edge, main), vec2(0.1,0.4), 0.05);\n    float borf = united(main, hole_edge);\n    \n    float segments = 24.0;\n    float angular_mod = 1.0 * PI / segments;\n    where.x += hole_radius /2.0;\n    vec2 polar_pos = to_polar(vec2(where.x, where.y));\n    float radius = (where.y>0.0) ? polar_pos.y : where.x;\n    radius -= (hole_radius -0.25);\n    float angle = (where.y>0.0) ? 2.0*cmod(polar_pos.x, angular_mod) \n        : cmod(where.y/PI*2.0, PI*2.0/segments);\n    vec3 block_dim = vec3(0.2, 0.1, 0.8);\n    vec3 on_block = vec3(radius, angle, where.z+0.4);\n    float brick_rounding = 0.037;\n    float brick = round_box_3(on_block, block_dim, brick_rounding);\n    float ebrick = brick;\n    float column = intersect(where.y-30.0,length(where_in.zx)-1.0);\n    return united(column,united(borf, ebrick));\t\n}\n\n\nvec2 closest(vec2 best, vec2 next) {\n    return (best.x < next.x) ? best : next;\n}\n\nvec3 measure(vec3 where) {\n    vec2 res = vec2(measure_to_ground(where), 1.5);\n//    res = closest(res, vec2(measure_to_building(where), 6.5));\n    float interesting = interesting_shape(where);\n    res = closest(res, vec2(interesting, 7.5));\n    return vec3(res, interesting);\n}\n\n/**\n * iq's soft shadow algo\n */\nfloat soft_shadow( in vec3 start, in vec3 ray, float min_dist, float max_dist, float k )\n{\n    float res = 1.0;\n    for( float t=min_dist; t < max_dist; )\n    {\n        vec2 h = measure(start + ray * t).xy;\n        if( h.x < EPSILON )\n            return 0.0; // hit something.\n        res = min( res, k * h.x / t);\n        t += h.x;\n    }\n    return res;\n}\n\n/**\n * currently just used for shadows\n * returns how far we went, and how close we came to hitting anything\n */\nvec2 trace_for_shadow(vec3 start, vec3 ray, float max_dist) {\n    vec3 where = start;\n    float total_dist = 0.0;\n    int steps = 0;\n    vec2 current;\n    float closest = max_dist + 1.0;\n    for (int steps = 0; steps < MAX_STEP; steps++) {\n        vec2 current = measure(where).xy;\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            return vec2(total_dist, current_dist);\n        }\n        \n        if (current_dist < closest) {\n            closest = current_dist;\n        }\n\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > max_dist) {\n            break;\n        }\n        where = start + total_dist * ray;\n    }\n    return vec2(max_dist, closest);\n}\n\nvec2 calculate_lighting(in Light light, vec3 ray, vec3 hit, vec3 surface_normal, float specular) {\n        // how much illumination is the hit surface getting from light 1?\n        vec3 hit_to_light = light.position - hit;\n        vec3 nhit_to_light = normalize(hit_to_light);\n        vec3 reflected = reflect(nhit_to_light, surface_normal);\n\t\tspecular *= pow(max(0.0, dot(ray, reflected)), 16.0);\n        float length_to_light = length(hit_to_light);\n        float light_angle = max(0.0, dot(surface_normal, nhit_to_light));\n        float illum = light.power * light_angle \n            / (1.0 + pow(length_to_light, 2.0));\n        \n        // but wait, is it shadowed?\n        #ifdef SHADOWS\n        if (light_angle > 0.0) {\n            float shadow = soft_shadow(hit, nhit_to_light, EPSILON*2.0, length_to_light, 8.0);\n            illum *= shadow;\n        }\n        #endif\n    return vec2(illum, specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(0.0), 1.0);\n\tvec2 screen_pos = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.y / iResolution.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_at= vec3(0,6,0);\n    vec3 up = vec3(0,1,0);\n    vec3 eye = vec3(sin(iTime*0.1)*20.0+5.0,\n                    sin(iTime*0.13)*2.0+3.0,\n                    cos(iTime*0.1)*10.0+5.0);\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 ray = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    \n    vec3 p_normal = vec3(0,1,0);\n    float p_dist = 0.0;\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec3 current;\n    for(int steps =0;steps < MAX_STEP; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\tvec3 hit = where;\n\n    vec3 base_color = vec3(0,0,0);\n    vec3 paint = vec3(0,0,0);\n    int who = (total_dist < MAX_DIST) ? int(current.y) : 0;\n\n    // add glow for white light\n    vec3 eye_to_light_1 = light_1.position - eye;\n    float dp_1 = dot(ray, normalize(eye_to_light_1));\n    if (dp_1 > 0.0 && length(eye_to_light_1) < total_dist) {\n    \tvec3 short_1 = eye_to_light_1 * dp_1;\n        float diff = length(eye_to_light_1 - short_1);\n\t    //float light_1_dist =  diff / dp_1;\n\t    base_color += light_1.color * (0.0001 * (dp_1*dp_1) / (diff *diff));\n    }\n\t// did we hit anyone?\n    if (who > 0) {\n        float specular = 0.0;\n        vec3 col = vec3(0.7,0.5,0.2);\n        // delta for normal calculation\n        float dnc = 0.001;\n        vec3 surface_normal = normalize(vec3(\n            measure(hit+vec3(dnc, 0.0, 0.0)).x - measure(hit-vec3(dnc, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, dnc, 0.0)).x - measure(hit-vec3(0.0, dnc, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, dnc)).x - measure(hit-vec3(0.0, 0.0, dnc)).x\n        ));\n        if (who == 1) { //floor\n            float atten = min(1.0, fract(current.z) * 8.0);\n            int xi = int(fract(hit.x)*2.0);\n            int zi = int(fract(hit.z)*2.0);\n            if ((xi ^ zi) == 0) {\n\t        \tcol = vec3(0.7,0.5,0.2);\n            } else {\n\t        \tcol = vec3(0.8,0.6,0.3);\n            }\n            col *= atten;\n        } \n        else if (who == 6) {\n\t        col = vec3(0.7, 0.7, 0.7);\n        } \n        else if (who == 7) { // arches etc\n            /*\n            int yi = int(fract(hit.y*5.0)*2.0);\n            if (yi == 0) {\n\t        \tcol = vec3(1.0, 1.0, 1.0);\n            } else {\n\t            col = vec3(1.0, 0.7, 0.7);\n            }\t */\n            col = vec3(1.0, 1.0, 1.0);\n            specular = 0.2;\n        }\n\t\t// lighting\n        vec2 light_1_lighting = calculate_lighting(light_1, ray, hit, surface_normal, specular);\n        vec2 light_2_lighting = calculate_lighting(light_2, ray, hit, surface_normal, specular);\n\n        float ambient = 0.2;\n        float diffuse = 0.8;\n        \n        paint = col * ambient;\n\n        float light_1_diffuse = diffuse * min(1.0, light_1_lighting.x);\n        vec3 light_1_specular = light_1.color * light_1_lighting.y;\n        paint += col * light_1.color * light_1_diffuse;\n        paint += light_1_specular;\n        \n        paint += vec3(col * (light_2.color * min(1.0, light_2_lighting.x)));\n        paint += light_2.color * light_2_lighting.y;\n        \n        \n    }\n    paint *= 1.0 - (total_dist/MAX_DIST);\n    fragColor += vec4(base_color + paint, 1.0);\n}","name":"Image","description":"","type":"image"}]}