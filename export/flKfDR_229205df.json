{"ver":"0.1","info":{"id":"flKfDR","date":"1664358316","viewed":22,"name":"Renderer 2223","username":"meteotrix","description":"basic renderer for class :3","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lesson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Vertex\n{\n    vec3 pos;\n    vec3 color;\n};\n\n\n#define max_tris 10 //hack\nstruct Mesh\n{\n    int tri_count;\n    ivec3[max_tris] tris;\n};\n\nfloat tri_area(vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 a = v1 - v0;\n    vec3 b = v2 - v0;\n    return length(cross(a,b)) * 0.5;\n}\n\n//ici on teste si un cross product part bien vers le haut\n//si c’est pas le cas, ça indique qu’on a un triangle d’une aire “négative”\nbool cross_up(vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 a = v1 - v0;\n    vec3 b = v2 - v0;\n    return cross(a,b).z >= 0.0;\n}\n\n//ici on teste si les aires de nos sous-triangles sont bien positives toutes les trois\nbool pixel_in_tri(vec3 p, vec3 v0, vec3 v1, vec3 v2)\n{\n    return cross_up(v1,v2,p) && cross_up(p,v2,v0) && cross_up(v0,v1,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = mix(vec3(0), vec3(0,0,1), uv.y);\n    \n    //vvv MESH DATA here vvv\n    Vertex[9] verts;\n    const int mesh_count = 2;\n    Mesh[mesh_count] meshs;    \n    {\n        verts[0] = Vertex(vec3(0.1, 0.1, 0.1), vec3(1,0,0));\n        verts[1] = Vertex(vec3(0.9, 0.1, 0.1), vec3(0,1,0.5));\n        verts[2] = Vertex(vec3(0.5, 0.9, 0.1), vec3(0,0.5,1));\n\n        verts[3] = Vertex(vec3(0.1, 0.9, -0.5), vec3(1,1,1));\n        verts[4] = Vertex(vec3(0.1, 0.1, 0.5), vec3(1,1,1));\n        verts[5] = Vertex(vec3(0.5, 0.9, -0.5), vec3(1,1,1));\n\n        verts[6] = Vertex(vec3(0.1, 0.1, 0.5), vec3(1,1,1));\n        verts[7] = Vertex(vec3(0.5, 0.1, -0.5), vec3(1,1,1));\n        verts[8] = Vertex(vec3(0.5 , 0.9, -0.5), vec3(1,1,1));\n\n        meshs[0].tri_count = 1;\n        meshs[0].tris[0] = ivec3(0,1,2);\n\n        meshs[1].tri_count = 2;\n        meshs[1].tris[0] = ivec3(4,5,3);\n        meshs[1].tris[1] = ivec3(6,7,8);\n    }\n    \n    float z_min = 9999.0;\n    \n    for (int j = 0; j < mesh_count; ++j)\n    {\n        for (int i = 0; i < meshs[j].tri_count; ++i)\n        {\n            Vertex v0 = verts[meshs[j].tris[i].x];\n            Vertex v1 = verts[meshs[j].tris[i].y];\n            Vertex v2 = verts[meshs[j].tris[i].z];\n            vec3 p = vec3(uv.x, uv.y, 0.0); //notre frag\n\n            Vertex v0p = v0; v0p.pos.z = 0.0;\n            Vertex v1p = v1; v1p.pos.z = 0.0;\n            Vertex v2p = v2; v2p.pos.z = 0.0;\n\n            if(pixel_in_tri(p, v0.pos, v1.pos, v2.pos))\n            {\n                //interpolation barycentrique\n                //faire le calcul en 2D déjà projetée (sans depth, càd avec z=0)\n                float S = tri_area(v0p.pos, v1p.pos, v2p.pos); //surface totale triangle\n                float u = tri_area(p, v1p.pos, v2p.pos); //aire du sous triangle 1\n                float v = tri_area(p, v2p.pos, v0p.pos); //aire 2\n                float w = tri_area(p, v0p.pos, v1p.pos); //aire 3\n\n                p.z =   (u / S) * verts[meshs[j].tris[i].x].pos.z\n                      + (v / S) * verts[meshs[j].tris[i].y].pos.z\n                      + (w / S) * verts[meshs[j].tris[i].z].pos.z;\n\n                if(p.z < z_min)\n                {\n                    z_min = p.z;\n\n                    col.rgb =     (u / S) * verts[meshs[j].tris[i].x].color \n                                + (v / S) * verts[meshs[j].tris[i].y].color \n                                + (w / S) * verts[meshs[j].tris[i].z].color;\n                }                     \n            }\n        }\n    }\n    \n    \n    /*mat3 axes = mat3(1,0,0,\n                     0,2,0,\n                     0,0,3);                     \n    vec3 myvec = vec3(1,2,3);    \n    col = (axes * myvec) / 10.0;*/\n    \n    /*vec3 mypos = vec3(1,2,3);\n    mat3 scaling = mat3(2,0,0,\n                        0,2,0,\n                        0,0,2); */\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}