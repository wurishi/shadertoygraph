{"ver":"0.1","info":{"id":"tt3XWH","date":"1580853336","viewed":156,"name":"Mindf*ck","username":"julianlumia","description":":octopusballoon:","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float EPSILON = 0.001;\nconst float MAX_DIST = 100.0;\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nconst float PI = 3.14159265359;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n vec3 d = abs(p) - b;\n return length(max(d,0.0)); \n}\n\n\nfloat dBar(vec2 p, float width) {\n vec2 d = abs(p) - width;\n return min(max(d.x, d.y), 0.0) + length(max(d, 0.)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n float bar_x = dBar(p.yz, x);\n float bar_y = dBar(p.zx, x);\n float bar_z = dBar(p.xy, x);\n return min(bar_z, min(bar_x, bar_y));\n}\n\n\n\nfloat dMengerSponge(vec3 p) \n{\n float d = sdBox(p, vec3(0.79));\n float itt = 1.3;\n float one_third = 1. / itt;\n for (float i = 0.0; i < itt; i++) {\n  float k = pow(one_third, i);\n  float kh = k * 1.;\n  d = max(d, -dCrossBar(mod(p + kh, k * 2.) - kh, k * one_third));\n }\n return d;\n}\n\n\n\nfloat GetDist(vec3 p){\n float gap = 1.;\n p.xyz = mod(p.xyz + gap,2.0 * gap) - gap;\n float dm1;\n float d;  \n d=1.0;           \n dm1=dMengerSponge(p-vec3(-0.,-0.,0.0));\n d=min(d, dm1);\n return d;\n}\n\nvec3 GetNormal(vec3 p) {\n float d = GetDist(p);\n vec2 e = vec2(.001, 0);  \n vec3 n = d - vec3(\n GetDist(p-e.xyy),\n GetDist(p-e.yxy),\n GetDist(p-e.yyx));   \n return normalize(n);\n}\n\nvec3 cameraPath(float t) {\n t *= PI *.5 ;\n float t2 =  cos(t)+0.;\n float c = cos(t*2.);\n float x = 0.;\n float y = 0.;\n float z= 0.;   \n if (t2<0.){\n x = 1. /1. + 2. +c;\n };       \n if (t2>0.){\n y = 1. /1. + 2. +c;\n };\n vec3 xyz =vec3(x,y,z);\n return xyz;\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n vec2 xy = fragCoord - size / 2.0;\n float z = size.y / tan(radians(fieldOfView) / 2.);\n return normalize(vec3(xy, -z));\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n float dO=0.1;\n for(int i=0; i<64; i++) {\n vec3 p = ro + rd*dO;\n float dS = GetDist(p);\n dO += dS*1.;\n if(dO>100. || dS<0.001) break;\n } \n return dO;\n}\n\nmat4 viewMatrixRIGHT() \n{\n return mat4(\n vec4(1, 0, 0, 0),\n vec4(0, 1, 0, 0),\n vec4(0,0, 1, 0),\n vec4(0, 0, 0, 1)\n );\n}\n\nmat4 viewMatrixDOWN() \n{\n return mat4(\n vec4(0, 0, 1, 0),\n vec4(1,0, 0, 0),\n vec4(0, 1, 0, 0),\n vec4(0, 0, 1, 0)\n );\n}\n\nmat4 viewMatrixLEFT() \n{\n return mat4(\n vec4(1, 0, 0, 0),\n vec4(0, 1, 0, 0),\n vec4(0,0, -1, 0),\n vec4(0, 0, 0, -1)\n );\n}\n\nmat4 viewMatrixUP() \n{\n return mat4(\n vec4(0,1, 0, 0),\n vec4(0, 0, 1,0),\n vec4(-1,0, 0,0),\n vec4(0, 0,0,1)\n );\n}\n\n\nfloat GetLightPos(vec3 p, vec3 lpos) {\n float s = mod(iTime * 0.25, 1.0);\n float t = 2. * (2.0 * s - s * s);\n vec3 cameraPos = cameraPath(t);\n vec3 lightPos1 = vec3(cameraPos-vec3(0,1.,0.3));\n vec3 l1 = normalize(lightPos1-p);\n vec3 n1 = GetNormal(p);\n float dif1 = clamp(dot(n1, l1), 0., 1.);\n float d1 = RayMarch(p+n1*SURF_DIST*1., l1);\n if(d1<length(lightPos1-p)) dif1 *= 1.;  \n return (dif1)/1.0;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n float t = iTime * 0.3;\n vec2 res = iResolution.xy;\n vec2 frag = fragCoord.xy;\n vec2 uv = frag / res;\n vec3 rayDir;\n vec3 worldDir;    \n vec3 eye;\n vec4 fout;\n vec3  ro;  \n if( uv.x < 0.25)\n {\n  vec3 col;\n  frag = fragCoord.xy;\n  res = vec2(res.x *  .25, res.y);       \n  float s = mod(iTime * 0.25, 1.0);\n  float t = 2. * (2.0 * s - s * s);  \n  vec3 cameraPos = cameraPath(t);\n  vec3 rd = RayDirection(100.0, frag, res );\n  float the = iTime *0.3;\n  rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  vec3  ro = ( viewMatrixRIGHT() * vec4(rayDir,0.) ).xyz;\n  ro = vec3(cameraPos);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d;\n  float dif = GetLightPos(p, ro);\n  col = vec3(dif);\n  float fog = 1. / (2. + d * d * 2.);\n  col *= vec3(fog);  \n  vec3 sky = vec3(1., 1, 1.);\n  col = mix(sky, col, 1./(d*d/1./1.*.1+.8)); \n  fout = vec4(col,1.0);\n }\n else if(  uv.x > 0.25 && uv.x < 0.5 )\n {\n  vec3 col;\n  float s = mod(iTime * 0.25, 1.0);\n  float t = 2. * (2.0 * s - s * s);  \n  vec3 cameraPos = cameraPath(t);\n  frag = fragCoord.xy;\n  res = vec2(res.x *  0.25, res.y);\n  vec3 rd = RayDirection(100.0, frag, res );\n  float the = iTime *0.3;\n  rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd = ( viewMatrixDOWN() * vec4(rd,0.) ).xyz;\n  ro = vec3(cameraPos);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d;\n  float dif = GetLightPos(p, ro);  \n  col = vec3(dif);\n  float fog = 1. / (2. + d * d * 1.);\n  col *= vec3(fog);  \n  vec3 sky = vec3(1., 1, 1.);\n  col = mix(sky, col, 1./(d*d/1./1.*.1+1.)); \n  fout = vec4(col,1.0);         \n } \n else if(  uv.x > 0.5 && uv.x < .75 )\n {\n  vec3 col;\n  float s = mod(iTime * 0.25, 1.0);\n  float t = 2. * (2.0 * s - s * s);  \n  vec3 cameraPos = cameraPath(t);\n  frag = fragCoord.xy;\n  res = vec2(res.x *  0.25, res.y);\n   vec3 rd = RayDirection(100.0, frag, res );\n  float the = iTime *0.3;\n  rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));    \n  rd = ( viewMatrixLEFT() * vec4(rd,0.) ).xyz;     \n  ro = vec3(cameraPos);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d;  \n  float dif = GetLightPos(p, ro);  \n  col = vec3(dif);\n  float fog = 1. / (2. + d * d * 1.);\n  col *= vec3(fog);  \n  vec3 sky = vec3(1., 1, 1.);\n  col = mix(sky, col, 1./(d*d/1./1.*.1+1.)); \n  fout = vec4(col,1.0);\n }\n else if(  uv.x > 0.75 && uv.x < 1. )\n {\n  vec3 col;\n  float s = mod(iTime *0.25, 1.0);\n  float t = 2. * (2.0 * s - s * s);  \n  vec3 cameraPos = cameraPath(t);\n  frag = fragCoord.xy;\n  res = vec2(res.x *  .25, res.y);\n  vec3 rd = RayDirection(100.0, frag, res );\n  float the = iTime *0.3;\n  rd.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n  rd.yz *= mat2(cos(the), -sin(the), sin(the), cos(the));       \n  rd = ( viewMatrixUP() * vec4(rd,0.) ).xyz;\n  ro = vec3(cameraPos);\n  float d = RayMarch(ro, rd);\n  vec3 p = ro + rd * d;\n  float dif = GetLightPos(p, ro);\n  col = vec3(dif);\n  float fog = 1. / (2. + d * d * 1.);\n  col *= vec3(fog);  \n  vec3 sky = vec3(1., 1, 1.);\n  col = mix(sky, col, 1./(d*d/1./1.*.1+1.)); \n  fout = vec4(col,1.0);\n }\n fragColor = vec4(fout);\n}","name":"Image","description":"","type":"image"}]}