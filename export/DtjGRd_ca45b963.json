{"ver":"0.1","info":{"id":"DtjGRd","date":"1673825038","viewed":146,"name":"How do i add a vertex set?","username":"Yety","description":"i had this random idea that i could make hexagons and octagons be axes of transforming a square and i went and made it! woohoo. i'll animate it next","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["squares","hexes","octagonsitdoesntmatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sqrt2 = sqrt(2.)/2.;\n\nfloat linedist(vec2 a, vec2 b, vec2 pt){\n    float td = distance(a,b);\n\n    float d1 = distance(a,pt);\n    float d2 = distance(b,pt);\n\n    float dp = (d1+d2)/td-1.;\n    return dp;\n\n}\nfloat edgeness(vec2 a, vec2 b, vec2 pt){    \n    float f02 = linedist(a,b,pt);\n    f02 = clamp(1.-f02/fwidth(f02)*1.5, 0., 1.);\n\n    return f02;\n}\n\nfloat touchingEdge(vec2 p, vec2 a, vec2 b, vec2 c){\n\n    float eab = edgeness(a,b,p);\n    float ebc = edgeness(b,c,p);\n    float eca = edgeness(c,a,p);\n    \n    float test = eab  + ebc + eca;\n    return test;\n\n}\nfloat modulo(float a, float b){\n   return (a)-(floor((a)/(b))*(b));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n \n    //test the grid size as 50px;\n    float res = 50.;\n    \n    //go out as far as the hevagonal transformations. higher values will start featuring rectangles and concave shapes further\n    float uvscale = .45;\n\n    //adjusting radius down can be nice for identifying the shapes without tesselating\n    float rad = .5;\n\n\n    vec2 gridpos = floor(fragCoord/res)+.5; \n\n    vec2 p = vec2(fragCoord/res);\n\n    gridpos += modulo(iTime, 30.);\n    p += modulo(iTime, 30.);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = gridpos/(iResolution.x/res);\n    vec2 uv = p/(iResolution.x/res)*uvscale;\n    \n    //keep an unclamped uv around to make adjacent tiles meet up\n    vec2 uuv = p/(iResolution.x/res)*uvscale;\n\n\n\n\n\n    //uv will control how altered it is.\n\n    vec2 pxy = vec2(uv.x*rad, uv.x*rad)/2.;\n\n    vec2 nxy = vec2(uv.y*rad, -uv.y*rad)/2.;\n\n    vec2 upxy = vec2(uuv.x*rad, uuv.x*rad)/2.;\n\n    vec2 unxy = vec2(uuv.y*rad, -uuv.y*rad)/2.;\n    \n\n    //define all the vertices of this shape\n    vec2 p0 = vec2(gridpos),\n         p1 = vec2(p0.x+rad, p0.y+rad)-pxy-nxy,\n         p2 = vec2(p0.x+rad, p0.y+rad)-pxy+nxy,\n         p3 = vec2(p0.x+rad, p0.y-rad)+pxy-nxy,\n         p4 = vec2(p0.x+rad, p0.y-rad)-pxy-nxy,\n         p5 = vec2(p0.x-rad, p0.y-rad)+pxy+nxy,\n         p6 = vec2(p0.x-rad, p0.y-rad)+pxy-nxy,\n         p7 = vec2(p0.x-rad, p0.y+rad)-pxy+nxy,\n         p8 = vec2(p0.x-rad, p0.y+rad)+pxy+nxy;\n\n    //define all of the points at the edge between shapes\n\n    vec2 p9 = vec2(p0.x+rad, p0.y+rad)-unxy,\n         p10 = vec2(p0.x+rad, p0.y+rad)+unxy,\n         p11 = vec2(p0.x+rad, p0.y-rad)+upxy,\n         p12 = vec2(p0.x+rad, p0.y-rad)-upxy,\n         p13 = vec2(p0.x-rad, p0.y-rad)+unxy,\n         p14 = vec2(p0.x-rad, p0.y-rad)-unxy,\n         p15 = vec2(p0.x-rad, p0.y+rad)-upxy,\n         p16 = vec2(p0.x-rad, p0.y+rad)+upxy;\n\n\n    //the eight moving points of my polygon and its center are defined. \n\n    //Now to figure out if the current pixel is on a line between any of my planned triangles. \n\n    //Yuck\n\n\n    //touching triangle edge\n    float val = touchingEdge(p, p0, p1, p2)\n              + touchingEdge(p, p0, p2, p3)\n              + touchingEdge(p, p0, p3, p4)\n              + touchingEdge(p, p0, p4, p5)\n              + touchingEdge(p, p0, p5, p6)\n              + touchingEdge(p, p0, p6, p7)\n              + touchingEdge(p, p0, p7, p8)\n              + touchingEdge(p, p0, p8, p1);\n\n    //touching side connected edges\n    float v2 = edgeness(p1, p9, p)\n              + edgeness(p2, p10, p)\n              + edgeness(p3, p11, p)\n              + edgeness(p4, p12, p)\n              + edgeness(p5, p13, p)\n              + edgeness(p6, p14, p)\n              + edgeness(p7, p15, p)\n              + edgeness(p8, p16, p);\n\n    val += v2;\n    \n    float valsub = val;\n    //if(uv.x == uv.y)\n    //    valsub = 0.;\n        \n    //if(mod(gridpos.x + gridpos.y,2.)==1.)\n    //    fragColor = vec4(.5+val,.5+val, .5+val, 1.);\n\n    fragColor = vec4(valsub,valsub,val, 1.);\n\n}","name":"Image","description":"","type":"image"}]}