{"ver":"0.1","info":{"id":"3lfcDn","date":"1591769013","viewed":527,"name":"Multibrot Sets","username":"matthen","description":"the Multibrot sets are a generalization of the Mandelbrot sets, using z^n + c for varying n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","multibrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FRACTAL_ITERS 256\n#define AA 4\n\nvec2 complexPow(in vec2 z, in float a) {\n\tfloat r = length(z);\n    float th = atan(z.y, z.x);   \n    return pow(r, a) * vec2(cos(th * a), sin(th * a));\n}\n\nvec2 complexMul(in vec2 z1, in vec2 z2) {\n\treturn vec2(\n        z1.x * z2.x - z1.y * z2.y,\n        z1.x * z2.y + z1.y * z2.x);\n    \n}\n\nvec2 mandelDist(in vec2 z, in float a) {\n    bool escaped =  false;\n    float m2 = 0.0;\n    vec2 dz = vec2(0.0, 0.0);\n    vec2 c = z;\n    float minDist = 100.;\n    \n    for(int i=0; i < FRACTAL_ITERS; i++) {\n        if(m2 > 128.0) {\n            escaped = true;\n            break;\n        }\n\n\t\t// Z' -> a·(Z ^ (a-1))·Z'\n        dz = a * complexMul(complexPow(z, a - 1.), dz) + 1.;\n\t\t//dz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x) + 1.;\n\n        z = complexPow(z, a) + c;\n\t\t//z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\t\n        m2 = dot(z, z);\n        minDist = min(minDist, abs(.2 * (z.x) - .5));\n    }\n    \n    if (!escaped) {\n    \treturn vec2(0., minDist); \n    }\n\n\treturn  vec2(\n        0.5 * sqrt(dot(z, z) / dot(dz, dz))*log(dot(z, z)),\n    \tminDist\n    );\n     \n}\n\nvec3 gradient(in float r) {\t\n    //r = 1. - r;\n    return 0.5 + 0.5 * cos(\n        (2. * r * vec3(1., 1.2, 0.6) + vec3(0.5, 0.4, 0.6)*6.));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float t = iTime;\n    t = mod(t, 22.);\n    \n    float a = 1. + (\n        smoothstep(.5, 5., t)\n        +smoothstep(6., 8., t)\n        +smoothstep(9., 11., t)\n        +smoothstep(12., 14., t)\n        +smoothstep(15., 17., t)\n        - 5. * smoothstep(18., 22., t)\n    );\n    \n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n        vec2 coord = fragCoord + vec2(i, j) / float(AA);\n\t    vec2 z = (coord - .5 * iResolution.xy) / iResolution.y;\n        z.x -= .25 * (1. - smoothstep(2., 3., a));\n        \n        z *= 2.75;\n        \n        \n    \tvec2 m = mandelDist(z, a);\n        vec3 thisCol = gradient(1. / (1. + m.x + 2. * m.y));\n        thisCol = mix(\n            vec3(1., 1., 1.),\n        \tthisCol,\n            smoothstep(0., 0.00001, m.x)\n            \n        );\n        col += thisCol;\n    }\n    }\n    col /= float(AA * AA);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}