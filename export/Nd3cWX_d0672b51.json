{"ver":"0.1","info":{"id":"Nd3cWX","date":"1654162528","viewed":94,"name":"Exponential series","username":"ChunderFPV","description":"Updated July 14, 2023\nExponential func series.  Click for function graph.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["math","graph","function","plot","exponential"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define H(a) (cos(vec3(2,0,1)-((a)*6.3))*.5+.5)  // hue\n#define L(x,w) smoothstep(w*min(fwidth(x), 1.), 0., abs(x))  // line\n\n// round to fractions like 5/1, 1/5, 4/5, 5/4, but not stuff like 3/5\nfloat rnd(float n) // need to shorten\n{\n\tfloat x = 1.,\n          y = 1.;\n\tif (n > 2.)\n        x = n;\n\telse if (n < .5)\n        y = 1./n;\n\telse if (n < 1. && n > .5)\n        y = 1./(1.-n),\n        x = y-1.;\n\telse //if (n > 1. && n < 2.)\n        x = n/(n-1.),\n        y = x-1.;\n\treturn round(x)/round(y);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    float t = iTime/2.,\n          aa = 2., // anti-aliasing (1 = off)\n          s = 6.,  // scale\n          ss = .2, // snap strength\n          b, v, bc, bg, bd, mb, pc, p, pg, fp;\n    vec2 R = iResolution.xy,\n         m = (iMouse.xy-.5*R)/R.y*s,\n         rm = round(m/ss)*ss, // rounded mouse\n         ao, u, g;\n    vec3 c = vec3(0);\n    \n    if (rm.x == round(m.x)) m.x = rm.x; // snap to x\n    if (rm.y == round(m.y)) m.y = rm.y; // snap to y\n    mb = (iMouse.z > 0.) ? // base from mouse or time\n        pow(abs(m.y), 1./m.x)*sign(m.y):\n        tan(t);\n    \n    for (int k = 0; k < int(aa*aa); k++) // aa loop\n    {\n        ao = vec2(k%2, k/2)/aa; // aa offset\n        u = (U-.5*R+ao)/R.y*s;  // coords\n        b = pow(abs(u.y), 1./u.x); // base from xy\n        v = max(b, 1./min(b, abs(1.-b))); // new coords\n        bc = max(0., 1.-abs(fract(v+.5)-.5)/fwidth(v)/1.5); // base curves\n        bg = 1.-abs(sin(v*3.14)); // glow\n        bd = min(1., 1./abs(v));  // darken\n        c += (bc*.8+bg*.5)*bd*H(bd)*1.5; // blend & add color\n    }\n    c /= aa*aa; // post-aa brightness fix\n    \n    g = max(vec2(0), 1.-abs(fract(u+.5)-.5)/fwidth(u)/2.); // xy grid\n    c *= max(0., 1.-max(g.x, g.y)*.1); // dark grid lines\n    c += min(g.x, g.y); // grid points\n    \n    pc = length(u-vec2(log(abs(mb))/log(rnd(b)), mb)); // point coords\n    p = max(0., 1.-pc/length(fwidth(u))/2.); // points\n    pg = max(0., 1.-pc/.25); // point glow\n    c += H(p+.5)*p*2.; // color & add points\n    c += H(pg)*pg*.3;\n    \n    if (iMouse.z > 0.) // click\n        fp = u.y-pow(abs(mb), u.x)*sign(m.y), // func plot\n        c *= 1.-L(fp, 5.), // dark line\n        c.g += L(fp, 2.5), // green line\n        c += 1.-step(length(fwidth(u))*3.5, max(abs(u.x-m.x), abs(u.y-m.y))); // xy point\n    \n    C = vec4(c+c*c, 1);\n}","name":"Image","description":"","type":"image"}]}