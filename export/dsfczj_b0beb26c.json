{"ver":"0.1","info":{"id":"dsfczj","date":"1686974048","viewed":35,"name":"Parallel Science","username":"romeosoft","description":"Parallel Science","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["parallelscience"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n                          .-''--.\n                         _`>   `\\.-'<\n                      _.'     _     '._\n                    .'   _.='   '=._   '.\n                    >_   / /_\\ /_\\ \\   _<\n                      / (  \\o/\\\\o/  ) \\\n                      >._\\ .-,_)-. /_.<\n                          /__/ \\__\\\n                            '---'  \n            \n          “If I can’t picture it, I can’t understand it.”\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = BLACK;\n\n    // Testing\n    float T1 = 1000.0; // Temperature in Kelvin\n    float T2 = 5000.0; // Temperature in Kelvin\n    float T3 = 10000.0; // Temperature in Kelvin\n\n    vec3 color1 = vec3(planck_T_NM(T1, 10.0), planck_T_NM(T1, 50.0), planck_T_NM(T1, 90.0));\n    vec3 color2 = vec3(planck_T_NM(T2, 100.0), planck_T_NM(T2, 500.0), planck_T_NM(T2, 900.0));\n    vec3 color3 = vec3(planck_T_NM(T3, 1000.0), planck_T_NM(T3, 5000.0), planck_T_NM(T3, 9000.0));\n\n    if (uv.y < 0.33) {\n        col = 0.25 + color1;\n    } else if (uv.y < 0.66) {\n        col = 0.5 + color2;\n    } else {\n        col = 0.75 + color3;\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/** \n*                         $ Parallel Science $\n*\n* Parallel science is a scientific principle that develops independently and\n* explains phenomena using different methods from mainstream scientific principles.\n* It includes independently developed mathematical tools and independent\n* interpretations of physical phenomena. \n*\n*/\n#define PI 3.14156\n#define real float\n#define imag float\n\n#define CSCREEN vec2(0.5,0.5)\n\n#define BLACK vec3(0,0,0)\n#define WHITE vec3(1,1,1)\n#define RED vec3(1,0,0)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n#define YELLOW vec3(1,1,0)\n#define GREY vec3(0.5,0.5,0.5)\n\n#define XYZ0 vec3(0,0,0)\n#define UX vec3(1,0,0)\n#define UY vec3(0,1,0)\n#define UZ vec3(0,0,1)\n#define UC crd3(UX, UY, UZ, XYZ0)\n\n// Constants for astronomical calculations\n#define AU 149597870700.0 // Astronomical Unit in meters\n#define LY 9.4607e12 // Light Year in meters\n#define ARC_SECOND (3.141592653589793 / 180.0 / 3600.0) // Conversion factor for arc seconds\n#define MIN_ARC_SECOND 0.01 // Minimum arc second value\n#define PROXIMA_CENTAURI_DIS (4.2 * LY) // Distance to Proxima Centauri\n#define PC (AU / ARC_SECOND) // Parsec in meters\n#define RAD_DEG (3.141592653589793 / 180.0) // Conversion factor for radians to degrees\n#define ARC_SECOND_DEGREE (ARC_SECOND * 180.0 / 3.141592653589793) // Conversion factor for arc seconds to degrees\n\n// Constants for celestial objects\n#define EARTH_SUN AU // Distance from Earth to Sun\n#define SUN_D (1.392 * 1e6 * 1e3) // Sun's diameter in meters\n#define SUN_S (4.0 / 3.0 * 3.141592653589793 * pow(SUN_D / 2.0, 3.0)) // Sun's volume in cubic meters\n#define SUN_DEGREE (SUN_D / EARTH_SUN * (180.0 / 3.141592653589793)) // Sun's angular size in degrees\n#define EARTH_MOON (384403.9 * 1e3) // Distance from Earth to Moon\n#define MOON_D (3476.28 * 1e3) // Moon's diameter in meters\n#define MOON_DEGREE (MOON_D / EARTH_MOON * (180.0 / 3.141592653589793)) // Moon's angular size in degrees\n\n// Constants for astronomical measurements\n#define APPARENT_MAGNITUDE pow(10.0, -0.4) // Apparent magnitude reference value\n#define VEGA_FLUX 1.0 // Flux of Vega star\n\n#define NM (1.0 / 1e9)\n\n// Functions for astronomical calculations\nfloat flux_mag(float flux) {\n    return -2.5 * log2(flux / VEGA_FLUX);\n}\n\nfloat mag_flux(float mag) {\n    return pow(APPARENT_MAGNITUDE, mag) * VEGA_FLUX;\n}\n\nfloat color_index(float b, float v) {\n    return flux_mag(v) - flux_mag(b);\n}\n\nfloat M_m(float d) {\n    return 5.0 - 5.0 * log2(d);\n}\n\nfloat distance_modulus(float m, float M) {\n    return pow(10.0, (m - M + 5.0) / 5.0);\n}\n\n// Constants for physical calculations\nconst float C = 299792458.0; // Speed of light in vacuum in meters per second\nconst float H = 6.62607015 * 1e-34; // Planck constant in joule seconds\nconst float KE = 1.380649 * 1e-23; // Boltzmann constant in joules per kelvin\nconst float SIGMA = 5.67 * 1e-8; // Stefan-Boltzmann constant in watts per square meter per kelvin to the fourth power\nconst float WATER_SHC = 4.2 * 1e3; // Specific heat capacity of water in joules per kilogram per kelvin\nconst float CALORIE = 4.1859; // Calorie in joules\nconst float BIG_CAL = CALORIE * 1e3; // Kilocalorie in joules\nconst float COCACOLA_J_100ML = 171.0; // Energy content of Coca Cola in joules per 100 milliliters\n\n// Functions for physical calculations\nfloat hv(float gama) {\n    return H * gama;\n}\n\nfloat wavelength_frequency(float meter) {\n    return 1.0 / meter;\n}\n\nfloat frequency_wavelength(float hertz) {\n    return 1.0 / hertz;\n}\n\nfloat NM_HZ(float nm) {\n    return 1.0 / (nm * nm);\n}\n\nfloat celsius_kelvins(float celsius) {\n    return celsius + 273.15;\n}\n\nfloat kelvins_celsius(float kelvins) {\n    return kelvins - 273.15;\n}\n\nfloat planck(float T, float gama) {\n    float A = 2.0 * H * pow(gama, 3.0) / pow(C, 2.0);\n    float B0 = H * gama / (KE * T);\n    float B = exp(B0);\n    float ret = A / (B - 1.0);\n    return ret;\n}\n\nfloat planck_T_NM(float T, float nm) {\n    return planck(T, 1.0 / (nm * NM * nm * NM));\n}\n\nfloat B_T(float T) {\n    return SIGMA * pow(T, 4.0);\n}\n\nfloat peakCM_T(float cm) {\n    return 0.29 / cm;\n}\n\nfloat T_peakCM(float T) {\n    return 0.29 / T;\n}\n\nfloat lightP(float I, float R) {\n    return I * (1.0 + R) / C;\n}\n\nfloat water_DT_J(float dCelsius) {\n    return dCelsius * WATER_SHC;\n}\n\n// Constants for thermodynamics calculations\nconst float WATER_SHC_THERMODYNAMICS = 4.2 * 1e3; // Specific heat capacity of water in joules per kilogram per kelvin\nconst float CALORIE_THERMODYNAMICS = 4.1859; // Calorie in joules\nconst float BIG_CAL_THERMODYNAMICS = CALORIE_THERMODYNAMICS * 1e3; // Kilocalorie in joules\nconst float COCACOLA_J_100ML_THERMODYNAMICS = 171.0; // Energy content of Coca Cola in joules per 100 milliliters\n\n// Functions for thermodynamics calculations\nfloat water_DT_J_thermodynamics(float dCelsius) {\n    return dCelsius * WATER_SHC_THERMODYNAMICS;\n}\n","name":"Common","description":"","type":"common"}]}