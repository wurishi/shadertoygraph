{"ver":"0.1","info":{"id":"Dt3BD2","date":"1702242801","viewed":15,"name":"Fork Fork Fork  EasonChen 523","username":"EasonChen","description":"This is a homework template for a homework for UCSD CSE 167.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["boids"],"hasliked":0,"parentid":"clcBWj","parentname":"Fork Fork UCSD  EasonChen 520"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Smooth HSV2RGB from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 color = vec4(0.5, 0.5, 0.5, 1.0);\n    // Loop over all boids\n    vec4 bcolor = vec4(0.0, 0.0, 0.0, 1.0);\n    bool hit = false;\n    for (int i = 0; i < NUM_BOIDS; i++) {\n        ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x),\n                                                i / int(iChannelResolution[0].x));\n        vec4 pos_vel = texelFetch(iChannel0, tex_pos, 0);\n        if (distance(fragCoord, pos_vel.xy) < BOIDS_SIZE) {\n            vec3 rgb = hsv2rgb(vec3((float(i)+0.5) / float(NUM_BOIDS), 1.0, 0.9));\n            bcolor += vec4(rgb, 1.0);\n            hit = true;\n        }\n    }\n    \n    if (hit) {\n        color = bcolor;\n    }\n\n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if (iFrame == 0) {\n        // initialize the buffer\n        vec4 pos_vel = texture(iChannel1, fragCoord/iChannelResolution[1].xy);\n        pos_vel.xy = iResolution.xy / 2.0 + (pos_vel.xy - 0.5) * iResolution.xy * 0.2;\n        pos_vel.zw = (pos_vel.zw - 0.5) * iResolution.xy * 1.0;\n        fragColor = pos_vel;\n        return;\n    }\n    \n    ivec2 iFragCoord = ivec2(fragCoord);\n    // initialize the position and current boid\n    vec4 pos_vel = texelFetch(iChannel0, iFragCoord, 0);\n    vec2 pos = pos_vel.xy;\n    vec2 vel = pos_vel.zw;\n    \n    // ID of the current Boid\n    int id = int(iFragCoord.y) * int(iResolution.x) + int(iFragCoord.x);\n\n\n\n    // Implement Boids here\n    \n    float d_right = iChannelResolution[0].x - 200.0;\n    float d_bottom = iChannelResolution[0].y - 160.0;\n    \n   \n\n\n    // Initialize velocity update vectors\n    vec2 F_s = vec2(0.0, 0.0);\n    vec2 F_avgc = vec2(0.0, 0.0);\n    vec2 F_c = vec2(0.0, 0.0);\n    vec2 F_a = vec2(0.0, 0.0);\n    vec2 V_avg = vec2(0.0, 0.0);\n    vec2 F_b = vec2(0.0, 0.0);\n    vec2 F = vec2(0.0, 0.0);\n    \n    \n    float closeBoidsCount = 0.0;\n    float visibleCount = 0.0;\n    \n    \n    \n    \n    for (int i = 0; i < NUM_BOIDS; i++) {\n        \n        ivec2 tex_pos = ivec2(i % int(iChannelResolution[0].x),\n                                                i / int(iChannelResolution[0].x));\n        vec4 pos_vel = texelFetch(iChannel0, tex_pos, 0);\n        \n        vec2 p_neighbor = pos_vel.xy;\n        vec2 v_neighbor = pos_vel.zw;\n        \n        if( i != id){\n        \n            if (distance(pos, p_neighbor) < d_s) {\n                 F_s += pos - p_neighbor;\n                 closeBoidsCount += 1.0f;\n                }\n\n\n\n            if (distance(pos, p_neighbor) < d_v) {\n                F_avgc +=  p_neighbor;//for cohesion\n                V_avg += v_neighbor;//for alignment\n                visibleCount += 1.0f;\n\n               }\n         }\n        \n    }\n    \n    \n    \n\n\n    \n    \n    // Average out the velocities\n    if (closeBoidsCount != 0.0) {\n        F_s = F_s / float(closeBoidsCount);\n       }\n    if (visibleCount != 0.0) {\n    \n        F_avgc = F_avgc / float(visibleCount);\n        V_avg = V_avg / float(visibleCount);\n       }\n    F_c = F_avgc - pos;\n    F_a = V_avg - vel;\n    \n    float leftbool = 0.0f;\n    float rightbool = 0.0f;\n    float topbool = 0.0f;\n    float bottombool = 0.0f;\n    \n    \n    \n    if (pos.x < d_left) {\n       leftbool = 1.0;\n    }\n\n    // Push away from right boundary\n    if (pos.x > d_right) {\n         rightbool = 1.0;\n    }\n\n    // Push away from top boundary\n    if (pos.y < d_top) {\n        topbool = 1.0;\n    }\n\n    // Push away from bottom boundary\n    if (pos.y > d_bottom) {\n        bottombool = 1.0;\n    }\n    \n    \n    F_b.x = leftbool - rightbool;\n    F_b.y = topbool - bottombool;\n    \n\n    F = alpha_s * F_s + alpha_c * F_c + alpha_a * F_a + alpha_b * F_b;\n    vel =  vel + F;\n    \n    float velLength = length(vel);\n\n    if (velLength > 0.0) {\n        if (velLength > s_max) {\n            vel *= s_max / velLength;\n        } else if (velLength < s_min) {\n            vel *= s_min / velLength;\n        }\n    }\n    \n    pos += vel;\n\n\n\n    fragColor = vec4(pos, vel);\n\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define NUM_BOIDS 200\n#define BOIDS_SIZE 10.0\n#define s_max 10.0        // Maximum speed\n#define s_min 5.0         // Minimum speed\n#define d_s 30.0          // Separation distance\n#define alpha_s 0.02      // Separation factor\n#define d_v 150.0         // View distance\n#define alpha_a 0.03      // Alignment factor\n#define alpha_c 0.001     // Cohesion factor\n#define d_left 200.0      // Left boundary distance\n\n#define d_top 160.0       // Top boundary distance\n\n#define alpha_b 0.5       // Boundary avoidance factor","name":"Common","description":"","type":"common"}]}