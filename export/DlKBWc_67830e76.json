{"ver":"0.1","info":{"id":"DlKBWc","date":"1702569050","viewed":37,"name":"cosmos cube in sphere","username":"nayk","description":"cosmos,cube,sphere,rotate,copypast","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["cube","sphere","rotate","cosmos","copypast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* https://www.shadertoy.com/view/4tyfWy  https://www.shadertoy.com/view/lslyRn https://www.shadertoy.com/view/DtGfzV https://www.shadertoy.com/view/dlGfDD*/\n#define iterations 20\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000\n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n#define MAX_STEPS 100\n#define MAX_DIST 130.\n#define SURF_DIST 0.01\n#define inf 1e10\n#define R iResolution.xy\n#define T iTime\n#define PI 3.141592\n\n//Tweak parameters here! More lines, but I prefer my settings in one place\n//Noise\n#define FREQUENCY 122.0\n#define OCTAVES 2.0\n#define AMPLITUDE 0.25\n#define GAIN 1.55\n#define LACUNARITY 3.\n\n//Scroll\n#define MOVESPEED 0.017\n#define WARPMIN 0.005\n#define WARPMAX 0.025\n\n#define ROTATIONSPEED 0.1\n#define ROTDELTAMIN 1.0\n#define ROTDELTAMAX 0.1\n\n//FabriceNeyret2 + IQ hash\n//https://www.shadertoy.com/view/fsKBzw\nfloat hash( vec2 f ) {  \n    uvec2 x = uvec2( floatBitsToUint(f.x), floatBitsToUint(f.y) ),\n          q = 1103515245U * ( x>>1U ^ x.yx    );\n    return float( 1103515245U * (q.x ^ q.y>>3U) ) / float(0xffffffffU);\n}\n\nfloat cosErp(float min, float max, float p) {\n    float delta = max - min;\n    return (cos(p)*delta + delta) * 0.5 + min;\n}\n\nfloat worley(vec2 uv) {\n    vec2 index = floor(uv);\n    uv = fract(uv);\n\n    float minDist = 2.0;\n    for (float y = -1.0; y<=1.0; y++)\n    {\n        for (float x=-1.0; x<=1.0; x++)\n        {\n            float cellHash = hash(mod(index + vec2(x,y), FREQUENCY));\n            float cellTime = T * (cellHash * 2.0 + 0.1);\n            vec2 offset = vec2(cos(cellTime + cellHash * 100.0), sin(cellTime + cellHash)) * 0.5;\n            float dist = distance(vec2(0.5) + vec2(x,y) + offset, uv);\n\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 repeat(vec3 p, float c) {\n    return mod(p,c) - 0.5 * c;\n}\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    0.0,                                0.0,                                0.0,                                1.0\n  );\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n  mat4 m = rotation3d(axis, angle);\n  return (m * vec4(v, 1.0)).xyz;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nvec3 getColor(float amount) {\n  vec3 color = vec3(0.3, 0.1, 0.2) +vec3(1, 0.7, 0.9) * cos(6.2831 * (vec3(0.30, 0.20, 0.20) + amount * vec3(1.0)));\n  return color * amount;\n}\n\n\nfloat sdCross( in vec3 p ) {\n  float da = sdBox(p.xyz,vec3(inf,1.0,1.0));\n  float db = sdBox(p.yzx,vec3(1.0,inf,1.0));\n  float dc = sdBox(p.zxy,vec3(1.0,1.0,inf));\n  return min(da,min(db,dc));\n}\n\n\nfloat GetDist(vec3 p) {\n    vec3 p1 = rotate(p - vec3(0, 0, 30), vec3(0., 1. ,1.), -iTime * 1.);\n    float d = sdBox(p1, vec3(15.));\n   \n    float scale = 1.0;\n   \n    float d2 = length(repeat(p, 1.)) - 0.2;\n    float d3 = sdCross(repeat(p1+5.*cos(iTime), 5.));\n \n   \n    return max(d3, d);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n   \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n       \n        float dS = GetDist(p);\n        dO += dS;\n       \n        if(dS < SURF_DIST || dO > MAX_DIST) {\n            break;\n        }\n    }\n   \n    return dO;\n\n}\n\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n   \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n   \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p) {\n     vec3 lightPos = vec3(0, 40.0, -50);\n   \n   \n    vec3 l = normalize(lightPos-p);\n   \n    vec3 n = GetNormal(p);\n   \n    float diffuse = clamp(dot(l, n), 0., 1.);\n     \n    float sD = RayMarch(p + n * SURF_DIST*2., l);\n   \n    if(sD < length(lightPos - p)) diffuse *= .1;\n     \n    return diffuse;\n}\n\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n//get coords and direction\nvec3 dir=rd;\nvec3 from=ro;\n\n//volumetric rendering\nfloat s=0.1,fade=1.;\nvec3 v=vec3(0.);\nfor (int r=0; r<volsteps; r++) {\nvec3 p=from+s*dir*.5;\np = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\nfloat pa,a=pa=0.;\nfor (int i=0; i<iterations; i++) {\np=abs(p)/dot(p,p)-formuparam; // the magic formula\na+=abs(length(p)-pa); // absolute sum of average change\npa=length(p);\n}\nfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\na*=a*a; // add contrast\nif (r>6) fade*=1.2-dm; // dark matter, don't render near\n//v+=vec3(dm,dm*.5,0.);\nv+=fade;\nv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\nfade*=distfading; // distance fading\ns+=stepsize;\n}\nv=mix(vec3(length(v)),v,saturation); //color adjust\nfragColor = vec4(v*.03,1.);\n}\n\nmat2 rotation(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nconst mat2 m = mat2(-1.1, -.4, .3, 1.0);\n\nfloat noise( in vec2 p) {\n    return sin(p.x) * sin(p.y);\n}\n\nfloat fbm4(vec2 p) {\n    float f = 0.0;\n    for (float i = 0.; i < 5.; i++) {\n        f += 1.5 * .1 * noise(p * i);\n        p = m * p * abs(i - 2.) * 2.3;\n    }\n\n    return f / 0.99999990;\n}\n\nvec2 fbm4_2(vec2 p) {\n    return vec2(fbm4(p), fbm4(p + vec2(7.8)));\n}\n\n\nfloat myNoise( in vec2 f ){\n  f *= m;\n  return ( cos( f.x + .18975 ) * sin( f.y + .494516 ) + .1615246 );\n}\n\nmat2 rot( float d ){\nfloat s = sin(d), c = cos(d);\nreturn mat2(c, s, -s, c);\n}\n\nfloat fbm( in vec2 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<7; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        x *= rot( float( i ) );\n        float a = pow( f, -H );\n        a = smoothstep( 0., .05, a );\n       \n        t += a*myNoise(f*x * rot( float(i) ));\n\n    }\n    return t;\n}\n\nfloat coreCalc(vec3 pos, int i) {\n\n    vec3 p = pos;\n\n    p.xz *= rotation(3.1415926 * iTime * .1 * float(i) + float(i));\n\n    float d = length(p) - .5 + (fbm4_2(p.yz - iTime * .2).y * 1.5 * fbm4_2(p.xz- iTime * .2).x * 1. * cos(p).y * 1.) * .6;\n\n    return d;\n}\n\nfloat map(vec3 pos) {\n\n    vec3 p = pos;\n\n    float d = coreCalc(p, 1);\n\n    float bg = length(pos) - .1;\n\n    d = mix(d, .05, bg);\n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    const float eps = 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy * eps) +\n        e.yyx * map(pos + e.yyx * eps) +\n        e.yxy * map(pos + e.yxy * eps) +\n        e.xxx * map(pos + e.xxx * eps));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//get coords and direction\nvec2 uv=fragCoord.xy/iResolution.xy-.5;\nuv.y*=iResolution.y/iResolution.x;\nvec3 dir=vec3(uv*zoom,iTime*0.001);\nfloat time=iTime*speed+.25;\n\n\n    // Time varying pixel color\n    float tt = iTime * .4;\n\n\nuv*=5.;\n    uv.x *= iResolution.x / iResolution.y;\n\n\n    vec3 origin = vec3(cos(tt) * -1.2, 0.0, sin(tt) * -1.2);\n    vec3 ta = vec3(0.0, 0., 0.0);\n\n    origin = vec3(0., 0., -1.);\n\n    // camera matrix\n    vec3 ww = normalize(ta - origin);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec3 ray = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);\n\n    float t = 0.0;\n\n    const float tmax = 5.0;\n\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = origin + ray * t;\n        float distance = map(p);\n        t += distance * 0.9999;\n    }\n\n    vec3 col = vec3(0.0);\n    vec3 lig = normalize(vec3(.57703));\n    vec3 hal = normalize(lig - ray);\n    // vec3 spcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n       vec2 pUV;\n    float d = dot(uv, uv);\n    pUV.x = pow(d, cosErp(WARPMIN, WARPMAX, T)) - T * MOVESPEED;\n    pUV.y = atan(uv.y, uv.x)/(2.*PI) + cosErp(ROTDELTAMIN, ROTDELTAMAX, T * 0.5) + T * ROTATIONSPEED;\n   \n    float frequency = FREQUENCY;\n    float amplitude = AMPLITUDE;\n    float value;\n    for (float i = 0.0; i < OCTAVES; i++)\n    {\n        value += worley(pUV * frequency) * amplitude;\n        amplitude *= GAIN;\n        frequency *= LACUNARITY;\n    }\n\n    vec3 col2;\n    vec3 col1 = vec3(cosErp(2.5, 0.0, value),\n                     cosErp(3.0, 0.0, value),\n                     cosErp(5.0, 0.1, value));\n                     \n    vec3 col22 = vec3(cosErp(0.5, 0.0, value),\n                     cosErp(3.0, 0.1, value),\n                     cosErp(2.0, 0.1, value));\n                     \n    col2 = mix(col1, col22, worley(uv));\n               \n \n    vec3 glow = vec3(0.017 / pow(d, 0.5));\n    glow *= vec3(2.0, 2.7, 5.5);\n    glow = 1.1 - exp(-glow);\n    col2 += glow;\n   \n    col2*= clamp(vec3(1.0 - pow(d, 0.7) * 1.1) + vec3(0.0, 0.35, 0.5), 0.0, 1.0); //vignette\n\n\n    if (t < tmax) {\n        vec3 pos = origin + t * ray;\n        vec3 nor = calcNormal(pos);\n           \n       \n        float dif = clamp(dot(nor, vec3(.4, 1., -.5)), 0.0, 1.0);\n        float p = fbm( vec2( fbm( nor.xy * .5 - iTime * .01, 1. ) ), .9 );\n       \n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 50.0) * .6;\n        spe *= dif;\n\n        float amb = dot(nor, vec3(0.0, 1.0, 0.0));\n\n        col= spe + vec3( p * .08 + .1 ) * amb + vec3(.6) * dif + vec3(.3);\n    }\n // Camera\n    vec3 ro = vec3(0,0,-25.);\n    vec3 rd = normalize(vec3(uv, 1));\n   \n\n    float d2 = RayMarch(ro, rd);\n   \n    vec3 p = ro + rd * d2;\n   \n    vec3 col23 = vec3(.0);\n       \n   \n   \n    if(d < MAX_DIST) {\n        float light = GetLight(p);    \n         \n     \n        col23 = getColor(light);\n    }\n   \n\n    // gamma        \n    col = sqrt(col);\n    tot += col;\n\n\nvec3 from=vec3(1.,.5,0.5)*tot+col23;\nfrom+=vec3(time*2.,time,-2.);\n\n\nmainVR(fragColor, fragCoord, from, dir);\n    fragColor+=vec4(col2,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}