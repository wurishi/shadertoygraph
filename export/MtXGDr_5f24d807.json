{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Distance functions playground, by Ruslan Shestopalyuk, 2014/15\n\n#define PI                      3.14159265\n\n#define MTL_BACKGROUND          -1.0\n#define MTL_GROUND              1.0\n#define MTL_AX                  2.0\n#define MTL_AY                  3.0\n#define MTL_AZ                  4.0\n#define MTL_OBJ1                5.0\n#define MTL_OBJ2                6.0\n\n#define NORMAL_EPS              0.001\n\n#define NEAR_CLIP_PLANE         0.001\n#define FAR_CLIP_PLANE          1000.0\n#define MAX_RAYCAST_STEPS       100\n#define STEP_DAMPING            0.9\n#define DIST_EPSILON            0.001\n\n\n#define GLOBAL_LIGHT_COLOR      vec3(0.8,1.0,0.9)\n#define SPEC_COLOR              vec3(0.8, 0.90, 0.60)\n#define BACKGROUND_COLOR        vec3(0.3, 0.342, 0.5)\n\n\n#define CAM_DIST                5.0\n#define CAM_H                   1.5\n#define CAM_FOV_FACTOR          2.5\n#define LOOK_AT_H               0.2\n\n#define LOOK_AT                 vec3(0.0, LOOK_AT_H, 0.0)\n\n\n// Primitives\nfloat plane(vec3 p, vec3 n, float offs) { return dot(p, n) - offs; }\nfloat sphere(vec3 p, float r) { return length(p) - r; }\nfloat cone(in vec3 p, vec2 n) { return dot(vec2(length(p.xz), p.y), n);}\nfloat cone(vec3 p, float r, float h) {\n    float ang = atan(r, h);\n    vec2 n = vec2(cos(ang), sin(ang));\n    float d = cone(vec3(p.x, p.y - h, p.z), n);\n    return max(d, -p.y);\n}\n\n\nfloat cylinder(in vec3 p, float r) { return length(p.xz) - r; }\nfloat cylinder(in vec3 p, float r, float h) { return max(cylinder(p, r), abs(p.y) - h*0.5); }\nfloat torus(vec3 p, float ri, float ro) { return length(vec2(length(p.xz) - ri, p.y)) - ro; }\n\n\n// Boolean operations\nfloat diff(float d1, float d2) { return max(-d2, d1); }\nfloat add(float d1, float d2) { return min(d2, d1); }\nfloat intersect(float d1, float d2) { return max(d2, d1); }\n\n// Boolean operations (with material ID in second component)\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\nvoid add(inout vec2 d1, in vec2 d2) { if (d2.x < d1.x) d1 = d2; }\nvoid intersect(inout vec2 d1, in vec2 d2) { if (d1.x < d2.x) d1 = d2; }\n\n\n\n// Affine transformations\nvec3 translate(vec3 p, vec3 d) {\n    return p - d;\n}\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s, p.x*s+p.y*c);\n}\n\n\n//  Repetition\nfloat repeat(float coord, float spacing) {\n    return mod(coord, spacing) - spacing*0.5;\n}\n\nvec2 repeatAng(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return p;\n}\n\nvec3 repeatAngS(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    float sector = floor(atan(p.x, p.y)/ang + 0.5);\n    p = rotate(p, sector*ang);\n    return vec3(p.x, p.y, mod(sector, n));\n}\n\n\n// Helper objects\nfloat star(vec3 p) {\n    p.xy = (repeatAng(p.xy, 5.0)).xy;\n    p.xz = abs(p.xz);\n    return plane(p, vec3(0.5, 0.25, 0.8), -0.09);\n}\n\nvec2 grid(in vec3 p) {\n    p.xz += vec2(0.5, 0.5);\n    p.x = repeat(p.x, 1.0);\n    p.z = repeat(p.z, 1.0);\n    float c = cylinder(p.xzy, 0.003, 1.0);\n    c = add(c,  cylinder(p.yxz, .003, 1.0));\n    return vec2(c, MTL_GROUND);\n}\n\n\nfloat arrow(vec3 p) {\n    float c = cylinder(p - vec3(0.0, 0.5, 0.0), 0.01, 1.0);\n    return add(c, cone(p - vec3(0.0, 1.0, 0.0), 0.03, 0.2));\n}\n\n\nvec2 coordSys(vec3 p) {\n    vec2 ax = vec2(arrow(p.yxz), MTL_AX);\n    vec2 ay = vec2(arrow(p.xyz), MTL_AY);\n    vec2 az = vec2(arrow(p.xzy), MTL_AZ);\n    vec2 res = ax;\n    add(res, ay);\n    add(res, az);\n    return res;\n}\n\n\n// Your distance function here\nfloat distf(vec3 p) {\n    float scale = 0.5;\n    p *= 1.0/scale;\n    vec3 p0 = p;\n    float d = cylinder(translate(p, vec3(0.0, 1.7, 0.0)), 1.2, 0.1);\n    p.xz = repeatAng(p.xz, 5.0).xy;\n    d = add(d, sphere(translate(p, vec3(0.0, 0.0, 1.0)), 0.5));\n    d = add(d, torus(translate(p.xzy, vec3(0.0, 1.0, 1.0)), 0.5, 0.2));\n    d = intersect(d, plane(p0, normalize(vec3(1.0,1.4, 1.0)), 0.8));\n\n    d = add(d, sphere(translate(p, vec3(0.0, -8.0, 0.0)), 8.0));\n    return d*scale;\n}\n\n\nvec2 map(vec3 p) {\n    vec2 res = grid(p);\n    vec2 cs = coordSys(p);\n    add(res, cs);\n    \n    vec2 obj = vec2(distf(p), MTL_OBJ1);\n    \n    add(res, obj);\n    return res;\n}\n\n\nvec3 calcNormal(in vec3 p)\n{\n    vec2 d = vec2(NORMAL_EPS, 0.0);\n    return normalize(vec3(\n        map(p + d.xyy).x - map(p - d.xyy).x,\n        map(p + d.yxy).x - map(p - d.yxy).x,\n        map(p + d.yyx).x - map(p - d.yyx).x));\n}\n\n\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n    float t = NEAR_CLIP_PLANE;\n    float m = MTL_BACKGROUND;\n    for (int i=0; i < MAX_RAYCAST_STEPS; i++) {\n        vec2 res = map(ro + rd*t);\n        if (res.x < DIST_EPSILON || t>FAR_CLIP_PLANE) break;\n        t += res.x*STEP_DAMPING;\n        m = res.y;\n    }\n\n    if (t > FAR_CLIP_PLANE) m = MTL_BACKGROUND;\n    return vec2(t, m);\n}\n\n\nvec3 getMaterialColor(float matID) {\n    vec3 col = BACKGROUND_COLOR;\n    if (matID <= MTL_GROUND) col = vec3(0.3, 0.3, 0.5);\n    else if (matID <= MTL_AX) col = vec3(1.0, 0.0, 0.0);\n    else if (matID <= MTL_AY) col = vec3(0.0, 1.0, 0.0);\n    else if (matID <= MTL_AZ) col = vec3(0.0, 0.0, 1.0);\n    else if (matID <= MTL_OBJ1) col = vec3(0.8, 0.8, 1.8);\n    else if (matID <= MTL_OBJ2) col = vec3(1.4, 1.3, 0.3);\n    else col = vec3(0.7, 0.7, 1.8);\n    return col;\n}\n\n\nvec3 applyFog(vec3 col, float dist) {\n    return mix(col, BACKGROUND_COLOR, 1.0 - exp(-0.0015*dist*dist));\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec2 res = rayMarch(ro, rd);\n    float t = res.x;\n    float mtlID = res.y;\n    vec3  lig = -rd;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos);\n    vec3 mtlColor = getMaterialColor(mtlID);\n    \n    float ambient = 0.05;\n    float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n\n    vec3 col = mtlColor*(ambient + GLOBAL_LIGHT_COLOR*diffuse);\n    col = applyFog(col, t);\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\n\nvec3 getRayDir(vec3 camPos, vec3 viewDir, vec2 pixelPos) {\n    vec3 camRight = normalize(cross(viewDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, viewDir));\n    return normalize(pixelPos.x*camRight + pixelPos.y*camUp + CAM_FOV_FACTOR*viewDir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    float ang = 0.1*(40.0 + iTime);\n    vec3 camPos = vec3(CAM_DIST*cos(ang), CAM_H, CAM_DIST*sin(ang));\n    vec3 rayDir = getRayDir(camPos,normalize(LOOK_AT - camPos), p);\n    vec3 color = render(camPos, rayDir);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtXGDr","date":"1420721571","viewed":358,"name":"Distance function playground","username":"digital_cucumber","description":"Just a basic setup to test distance function operations.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}