{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//Settings\n#define waveSpeed 0.1\n#define waveWidth 0.01\nconst int waves = 2;\n\nvec2 waveOrigins[waves];\n\nvec3 fetchTextureRep(ivec2 pos)\n{\n    ivec2 size = textureSize(iChannel0, 0);\n    return texelFetch(iChannel0, ivec2(mod(float(pos.x), float(size.x)),mod(float(pos.y), float(size.y))),0).xyz;\n}\nfloat wave(vec2 point)\n{\n    float height = 0.0;\n    for(int i = 0; i < waves; i++)\n    {\n        height += ring(waveOrigins[i], point, waveSpeed, waveWidth, -iTime);\n    }\n    return height;\n}\nvec2 differentialWave(vec2 point)\n{\n    vec2 distortion = vec2(0.0);\n    for(int i = 0; i < waves; i++)\n    {\n        distortion += ringDifferential(waveOrigins[i], point, waveSpeed, waveWidth, -iTime);\n    }\n    return distortion;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for(int i = 0; i < waves; i++)\n    {\n        waveOrigins[i] = vec2(0.5, (float(+i)+0.5)/float(waves));\n    }\n    vec2 uv = fragCoord/vec2(iResolution);\n    float distanceToCenter = distance(uv, vec2(0.5));\n    vec3 col = vec3(0.0);\n    \n    //col = vec3(wave(uv));\n    col = fetchTextureRep(ivec2(fragCoord + differentialWave(uv)));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"float loop(float angle)\n{\n    return(sin(angle)+1.0)/2.0;\n}\nbool isRing(vec2 origin, vec2 point, float interval, float width)\n{\n    float _distance = distance(origin, point);\n    return mod(_distance, interval) <= width;\n}\nbool isRingOffset(vec2 origin, vec2 point, float interval, float width, float offset)\n{\n    float _distance = distance(origin, point) + offset;\n    return loop(_distance) <= width;\n}\nfloat ring(vec2 origin, vec2 point, float speed, float width, float offset)\n{\n    vec2 way = point - origin;\n    return sin(((sqrt(pow(way.x,2.0)+pow(way.y,2.0))+offset*speed)/width));\n    /*float _distance = distance(origin, point) + offset*speed;\n    return sin(_distance/width);*/\n}\nvec2 ringDifferential(vec2 origin, vec2 point, float speed, float width, float offset)\n{\n    vec2 way = point - origin;\n    float wayLength = length(way);\n    float x = (way.x*cos((wayLength + offset*speed)/width))/width*wayLength;\n    float y = (way.y*cos((wayLength + offset*speed)/width))/width*wayLength;\n    return vec2(x,y);\n}\n","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mc3fDB","date":"1734202444","viewed":95,"name":"Water wave interference","username":"piet_inator","description":"Visualisation of interference with distortion. Feel free to change texture","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["water","physics"],"hasliked":0,"parentid":"","parentname":""}}