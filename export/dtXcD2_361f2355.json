{"ver":"0.1","info":{"id":"dtXcD2","date":"1691200406","viewed":102,"name":"Christmas Night","username":"andrew741","description":"A snowy Christmas night, with a full moon and some fresh footsteps in the snow.\n\nLook around using the mouse.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["christmas","sky","moon","night","storm","snow","white","layers","winter","ambiance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// layer parameters (for the snowflakes)\n#define CellSize vec2(0.05)\n#define OffsetStrength 1.\n#define Itterations 20.\n\n// layer parameters (for the steps)\n#define StepNoiseSeed -10.\n\n// moon parameters\n#define MoonPosition vec2(0.8, 0.4)\n\n// ground parameters\n#define GroundNoiseSeed 0.\n\n// colors\n#define AmbientColor vec3(0.1, 0.1, 0.15)\n#define GroundColor vec3(0.6, 0.6, 0.7)\n#define MoonColor vec3(0.8)\n\n// the matrix for the hash function (weights from the origonal Hash function)\n#define HashMat  mat3( vec3(127.1,311.7, 74.7), vec3(269.5,183.3,246.1),vec3(113.5,271.9,124.6))\n#define HashMat2 mat2( vec2(127.1, 311.7), vec2(269.5, 183.3))\n\n// this hash is from someone elses shader (with some modifactions)\nvec3 Hash(vec3 p) {  return fract(sin(p * HashMat ) * 43758.5453123) * 2. - 1.;  }\nvec2 Hash(vec2 p) {  return fract(sin(p * HashMat2) * 43758.5453123) * 2. - 1.;  }\n\n// from another persons shader\nfloat Perlin(vec3 x)\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = Hash( i+vec3(0.0,0.0,0.0) );\n    vec3 gb = Hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = Hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = Hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = Hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = Hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = Hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = Hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n// multiple layers of perlin noise (to provide more detial to it)\nfloat Fractal(vec3 p)\n{\n    float perlin  = Perlin(p      ) * 0.4 ;\n    perlin       += Perlin(p * 2. ) * 0.27;\n    perlin       += Perlin(p * 4. ) * 0.17;\n    perlin       += Perlin(p * 8. ) * 0.1 ;\n    perlin       += Perlin(p * 16.) * 0.06;\n    return pow(max(perlin * 2. - 0.05, 0.), 0.5);\n}\n\n// rotates a 2d point based on an angle\nvec2 rot2D(vec2 v, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return v * mat2(ca, -sa, sa, ca);\n}\n\n// squares a value\nfloat sqr(float v) {  return v*v;  }\n\n// generates a mask for footprints\nfloat FootStep(vec2 uv, float distortion, float rot)\n{\n    vec2 np = rot2D(uv * vec2(1.5, distortion), rot);\n\n    // a squircle mixed with a circle, kinda weird\n    float outterDst = smoothstep(1., 0.7, mix(sqr(sqr(np.x*2. * (1.-clamp(sqr(np.y-0.1)*8., 0., 1.)+1.))) + sqr(sqr(np.y))*0.2, length(np), 0.7));\n    outterDst *= smoothstep(0., 1., sqr(sqr(abs(np.x)-1.15)) + sqr(sqr(mod(np.y, 0.5)*8.)));\n    return clamp(outterDst, 0., 1.);\n}\n\n// the main shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // getting the uv coord\n    float zoom = 8.;\n    vec2 tUv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    float fall = smoothstep(0., 2., iTime-4.)*5.;\n    vec2 mouseOffset = smoothstep(0., 1., iMouse.xy/iResolution.xy) * vec2(10., 4.) - vec2(fall - 5.);\n    vec2 uv = tUv * zoom + 5. - fall;\n    vec2 transUv = uv + mouseOffset;\n    vec2 offset = vec2(0.5 * iTime, iTime);\n    \n    // rendering the sky\n    float moonMask = smoothstep(1.5, 0., length(tUv - vec2(0.8, 0.4))) * 0.25;\n    vec3 skyColor = AmbientColor + moonMask;\n    vec3 col = skyColor;\n    \n    // rendering the ground\n    float dst = 99999999999.;\n    if (uv.y < 0.)\n    {\n        dst = 1. / -uv.y;\n        float fog = exp(-dst);\n        float groundTexture = Fractal(vec3(transUv.x*0.5, dst*12. + mouseOffset.y, GroundNoiseSeed)) * 0.3 + 1. + moonMask;\n        col = mix(skyColor, GroundColor * groundTexture, fog);\n        \n        // rendering footsteps\n        for (float y = 1.; y < 10.; y++)\n        {\n            vec2 nUv = uv + mouseOffset / (y*0.25 + 0.75);\n            float offsetNoise = Perlin(vec3(y*0.15, 0., StepNoiseSeed)) * 30. - 1.;\n            vec2 hash = Hash(vec2(y, -y*2.));\n            float footStep = FootStep(nUv*(y*0.5+0.3)+vec2(offsetNoise, 2.5), y*0.5+3., hash.x*0.5);\n            footStep = max(footStep, FootStep(nUv*(y*0.5+0.55)+vec2(-1.5+offsetNoise, 2.5), y*0.5+3., hash.y*0.5));\n            if (footStep > 0.) col = mix(col, vec3(0.4, 0.4, 0.5)*footStep, fog);\n        }\n    }\n    else\n    {\n        // rendering the moon\n        float moon = smoothstep(0.2, 0.175, length(tUv - MoonPosition));\n        col = mix(col, MoonColor, moon);\n    }\n    \n    // itterating over all the layers of snow\n    for (float i = 0.; i < 1.; i+=1./Itterations)\n    {\n        // clipping snowflakes under the ground\n        if (dst > (1.-i)*0.75)\n        {\n            // getting the noise offset for snowflakes\n            float noise = Perlin(vec3(iTime*0.2, i*Itterations, -i*Itterations)) * 0.5 + 0.5;\n            \n            // getting the position\n            vec2 np = uv + mouseOffset*i*2. + offset*i;\n            vec2 cellSize = CellSize + i*1.5;\n            vec2 cellPos = mod(np, cellSize) - cellSize*0.5;\n            vec2 cell = floor(np / cellSize);\n            \n            // itterating over surounding cells to prevent clipping of the snowflakes\n            for (float x = -1.; x < 2.; x++)\n            {\n                for (float y = -1.; y < 2.; y++)\n                {\n                    // getting the offset\n                    vec3 hash = Hash(vec3(cell + vec2(x, y), i*Itterations));\n                    float r = (hash.z * 0.5 + 0.5) * (i*0.5+0.25) * 0.1;\n\n                    // generating the snowflake\n                    float blur = (i*i*i*i*i*i) * 0.2;\n                    col += (moonMask*0.75 + 0.75) * 1.5 * i * vec3(smoothstep(r + blur, r - blur*0.5, length(cellPos - hash.xy*OffsetStrength*noise - vec2(x, y)*cellSize)));\n                }\n            }\n        }\n    }\n    \n    // the final color\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}