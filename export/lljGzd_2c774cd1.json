{"ver":"0.1","info":{"id":"lljGzd","date":"1452069515","viewed":235,"name":"Approx ED via chaotic map","username":"MBR","description":"Experiment to cheaply approximate 2D equidistribution in a unit square using 2 1D chaotic maps.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["random","sequence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-*- mode: c; -*-\n\n// Not intended to be pretty.  Visualization sucks.\n\n\n//#define USE_LUT\n\n// draw the cells boundaries\n//#define GRID\n\n// number of points to generate per grid\n// (initial 'hash' point is also shown)\n#define SEQUENCE_LEN 10\n\n// logistics map constants\n//#define LM_K1 (4.0-1.0/511.0)\n#define LM_K1 3.99\n#define LM_K2 3.9999\n\n// tent map constants\n#define TM_K1 1.999\n#define TM_K2 1.900\n\n// reduce tent map as if K=2\n#define TM_CHEAT\n\n// flip coordinate after each mapping\n#define FLIP\n\n// choose mapping: lm=logistic both, tm=tent both, lt = logistic for one, tent for other\n#define MAP lt\n\n// number of time to apply the map to\n// move one step in the sequence\n#define STEPS 1\n\n#if 0\n#define OFFSET(P) (P-truc(P-vec2(0.95,0.27)))\n#else\n#define OFFSET(P) P\n#endif\n\n// take input components on [0,1] and\n// map away from fixed points.\nvec2 precondition(vec2 p)\n{\n#if 0\n  //if (true) return p+(1.0/256.0);\n    \n#if 1\n   p.x = .99*(p.x - 0.5) + 0.5;\n   p.y = .82*(p.y - 0.5) + 0.5;\n#else\n   p.x = .49*p.x + 0.05;\n   p.y = .47*p.y + 0.05;\n#endif\n#endif\n  return p;\n}\n\n// logistics map\n// f(x) = Kx(1-x)\nfloat lm(float k, float x) { return k*x*(1.0-x); }\n\nvec2 lm(vec2 p)\n{\n  p.x = LM_K1*p.x*(1.0-p.x);\n  p.y = LM_K2*p.y*(1.0-p.y);\n\n  p = OFFSET(p);\n    \n  return p;\n}\n\n// tent map\n// f(x) = K Min[x, 1-x] = K(1/2-|x-1/2|)\n\nfloat tm(float k, float x)\n{\t\n#ifdef TM_CHEAT\n  return 1.0 - k*abs(x-.5);\n#else\n  return k*(.5-abs(x-.5));\n#endif\n}\n\nvec2 tm(vec2 p)\n{\n#ifdef TM_CHEAT\n  p.x = 1.0 - TM_K1*abs(p.x-.5);\n  p.y = 1.0 - TM_K2*abs(p.y-.5);\n#else\n  p.x = TM_K1*(.5-abs(p.x-.5));\n  p.y = TM_K2*(.5-abs(p.y-.5));\n#endif\n  p   = OFFSET(p);\n  return p;\n}\n\n// lm in x, tent in y\nvec2 lt(vec2 p)\n{\t\n  p.x = LM_K1*p.x*(1.0-p.x);\n#ifdef TM_CHEAT\n  p.y = 1.0 - TM_K1*abs(p.y-.5);\n#else\n  p.y = TM_K1*(.5-abs(p.y-.5));\n#endif\n    \n  return p;\n}\n\n\nvec2 map(vec2 p)\n{\n  for(int i=0; i<STEPS; i++) {\n    p = MAP(p);\n#ifdef FLIP\n    p= vec2(p.y, p.x);\n#endif\n  }\n  return p;\n}\n\n//---- VISUALIAZATION JUNK BELOW HERE\n\n\n//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n\n\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n  p  = fract(p * vec2(5.3983, 5.4427));\n  p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n  return fract(vec2(p.x * p.y * 95.4337, p.x * p.y * 97.597));\n}\n\n\nfloat cp(vec2 p) {\n  float d = dot(p,p);\n  d = 1.0-smoothstep(0.0,0.00125, d);\n  return d;\n}\n\nfloat f1(float x) { return x*(1.0-x); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  fragCoord = pz_initializeState(fragCoord);\n    \n  vec2 p =  fragCoord.xy;\n\t\n  p = (1.0/32.0)*p;\n    \n  vec2 c = floor(p);\n  vec2 o = fract(p);\n\n#if defined(GRID)\n  // draw the grid..this is junk\n  float gx = 1.0-f1(o.x); gx *= gx;\n  float gy = 1.0-f1(o.y); gy *= gy;\n  gx = smoothstep(0.94,0.999999,gx);\n  gy = smoothstep(0.94,0.99,gy);\n  float r = 0.2*(gx+gy);\n#else\n  float r = 0.0;\n#endif\n\n  // create an initial 2d point in unit square\n  vec2 rp;\n\n#if defined(USE_LUT)\n  rp = texture(iChannel1, (c-0.5)/256.0, -100.0).xy;\n#else\n  rp = hash22(c);\n#endif\n  \n  float d = cp(rp-o);\n  float col = r;\n       \n  col += d;\n\n  // create a sequence of points from initial using a chaotic map\n  rp = precondition(rp);\n\n  for(int i=0; i<SEQUENCE_LEN; i++) {\n    rp   = map(rp);     // new point \n    col += cp(rp-o);    // crap visualization of point\n  }\n    \n  fragColor.rgb = vec3(col);\n  fragColor.a   = 1.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// copy of:  https://www.shadertoy.com/view/XdG3Dh\n\n//======Start shared code for state\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution     = iChannelResolution[pz_stateBuf].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n//======End shared code for state\n\n//======Defines for state behaviour\n#define pz_resetOnMove 1\n#define pz_kinetic 0.95\n\nbool pz_checkCell(float nr, vec2 coord) {\n    return distance(pz_nr2vec(nr),coord)<=0.5;\n}\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\nconst float KEY_ADD   = 107.5/256.0;\nconst float KEY_SUBS  = 109.5/256.0;\nconst float KEY_EQUAL = 187.5/256.0;\nconst float KEY_MINUS = 189.5/256.0;\n\nbool checkKey(float key)\n{\n\treturn texture(iChannel1, vec2(key, 0.25)).x > 0.5;\n}\n\nbool checkKey(float key1, float key2)\n{\n    return checkKey(key1) || checkKey(key2);\n}\n\nbool checkKey(float key1, float key2, float key3)\n{\n    return checkKey(key1) || checkKey(key2) || checkKey(key3);\n}\n\nvoid pz_mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pz_initializeState();\n    fragColor = pz_stateSample(fragCoord/pz_realBufferResolution);\n    if (fragCoord.x < 1. \n     && fragCoord.y < 1.) {\n        //Lets store the initial buffersize at pos0 and use that for addressing\n        if (pz_originalBufferResolution.x == 0.0)\n            fragColor = vec4(pz_realBufferResolution,1.0,1.0);\n        \n    } else if (pz_checkCell(1.,fragCoord)) {\n        \n        // Use postion 1 to trigger screen size changes so we can clear other buffers on going fullscreen\n        if (distance(fragColor.xy,pz_realBufferResolution)>1.0 \n#if pz_resetOnMove            \n            || pz_readState(3.).w > 0.0\n#endif            \n           ) {\n            fragColor.xy = pz_realBufferResolution;\n            fragColor.z = 60.0;\n        } else {\n            if (fragColor.z > 0.0)\n                fragColor.z -= 1.0;\n        }\n        \n    } else if (pz_checkCell(2.,fragCoord)) {\n        // Store mouse delta if keydown\n        if (iMouse.w>0.5) {\n            if (fragColor.x>0.0) {\n                fragColor.zw = fragColor.xy - iMouse.xy;\n            } else {\n                fragColor.zw = vec2(0.0);\n            }\n            fragColor.xy = iMouse.xy;\n        } else {\n            \n            fragColor.xy = vec2(-1.,-1.);\n#ifdef pz_kinetic\n            fragColor.zw = length(fragColor.zw)>0.1?fragColor.zw*pz_kinetic:vec2(0.0,0.0);\n#else                             \n            fragColor.zw = vec2(0.0,0.0);\n#endif                             \n        }\n        \n    } else if (pz_checkCell(3.,fragCoord)) { \n        // Handle keyboard moves\n        vec2 delta = vec2( checkKey(KEY_LEFT ,KEY_A,KEY_Q)?-0.02:\n                           checkKey(KEY_RIGHT,KEY_D      )? 0.02:0.0\n                         , checkKey(KEY_DOWN ,KEY_S      )?-0.02:\n                           checkKey(KEY_UP   ,KEY_W,KEY_Z)? 0.02:0.0);\n        float factor = checkKey(KEY_SUBS, KEY_MINUS)?1.01:\n                       checkKey(KEY_ADD , KEY_EQUAL)?0.99:1.0;\n        if (fragColor.z<0.0000001)\n            fragColor.z = 1.0;\n        \n        //Update transform state\n        vec2 mouseDelta = pz_readState(2.).zw;\n        fragColor.z *= factor;\n        fragColor.xy += delta *  fragColor.z; //Add keyboard move\n        fragColor.xy += mouseDelta / iResolution.xy *  fragColor.z; //Add mouse delta\n        \n        //Store movement in w\n        fragColor.w = abs(factor-1.0)*3. + length(delta) + length(mouseDelta);\n                \n    } else\n        fragColor = vec4(0.,0.,0.,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    pz_mainImage( fragColor, fragCoord );\n    \n    // Add multiple state handlers here\n}\n","name":"Buf A","description":"","type":"buffer"}]}