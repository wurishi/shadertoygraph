{"ver":"0.1","info":{"id":"dt3BDj","date":"1701592526","viewed":39,"name":"Bound state","username":"Masterchef365","description":"Particle in a box","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["quantum","fdm","leapfrog"],"hasliked":0,"parentid":"DtVyz1","parentname":"Quantum leapfrog FDM"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 flame_color(float a, float b) {\n    // Map a and b to the range [0, 1]\n    float x = 0.5 * (a + 1.0);\n    float y = 0.5 * (b + 1.0);\n\n    // Adjust these parameters to control the color gradient\n    float blackThreshold = 0.2;\n    float orangeThreshold = 0.6;\n    float blueThreshold = 0.9;\n\n    // Define the base colors\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 orange = vec3(1.0, 0.5, 0.0);\n    vec3 blue = vec3(0.0, 0.5, 1.0);\n\n    // Use a and b to control hue and saturation\n    vec3 color = mix(black, vec3(0.1, 0.0, 0.0), smoothstep(0.0, blackThreshold, x));\n    color = mix(color, orange, smoothstep(blackThreshold, orangeThreshold, x));\n    color = mix(color, blue, smoothstep(orangeThreshold, blueThreshold, x));\n\n    // Use the length of the vector formed by a and b to control saturation\n    float saturation = length(vec2(a, b));\n    color = mix(vec3(0.0), color, saturation);\n\n    // Introduce variation based on y\n    color += vec3(0.2 * y, 0.1 * y, 0.0);\n\n    // Clamp the color values to the range [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /*\n    uv = uv * 2. - 1.;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    uv /= dot(uv, uv) * 10.;\n    \n    uv.y /= iResolution.y/iResolution.x;\n    uv = uv / 2. + 0.5;\n    */\n\n    // Probability\n    // This isn't strictly correct, but we will need some\n    // shenanigans in the texture \"history\" to get THAT to work.\n    vec2 a = texture(iChannel0, uv).xy;\n    vec2 b = texture(iChannel1, uv).xy;\n    float p = a.x*a.y + b.x*b.x;\n    \n    // Pixel color\n    vec3 col = vec3(p);\n    //col = flame_color(a.x, b.x);\n    //col += p * abs(vec3(a.x, b.x*0.5, b.x));\n    col.x = potential(fragCoord, iResolution.xy, iMouse);\n    \n    col = mix(col, col.zxy, 0.3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = next(1., iChannel0, iChannel1, fragCoord, iResolution.xy, iFrame, iMouse);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = next(-1., iChannel1, iChannel0, fragCoord, iResolution.xy, iFrame, iMouse);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Follows:\n// A fast explicit algorithm for the time‐dependent Schrödinger equation \n// https://doi.org/10.1063/1.168415\n\nconst float dt = 0.25;\n\nfloat potential(vec2 coord, vec2 res, vec4 mouse) {\n    res.y *= res.x/res.y;\n    \n    float V = 0.;\n    \n    vec2 pt = coord/res;\n    vec2 ms = mouse.xy/res;\n    \n    const float brush_sz = 0.03;\n    bool mouse_down = mouse.z > 0.;\n    float dist = distance(pt, ms);\n    if (dist < brush_sz && mouse_down) {\n        V = 0.;// / (1. + dist*dist);\n    }\n    \n    vec2 diff = vec2(0.35) - pt;\n    diff.x *= 2.;\n    V += 1./(pow(81.*dot(diff, diff), 2.) + 1.);\n    \n    \n    diff = vec2(0.7, 0.35) - pt;\n    diff.x *= 2.;\n    V += 1./(pow(81.*dot(diff, diff), 2.) + 1.);\n    \n    \n    return V;\n}\n\nvec2 wave_packet(vec2 r, float t) {\n    float k = 1.; // Scale factor of the wave packet\n    float r2 = dot(r, r);\n    float phi = -r2 * k;\n    return exp(phi) * vec2(cos(phi), sin(phi));\n}\n\nvec4 next(float inv, sampler2D a, sampler2D b, vec2 coord, vec2 res, int frame, vec4 mouse)\n{\n    vec2 center_uv = coord/res;\n    float last_a = texture(a, center_uv).x;\n    \n    const float n = 1.;\n    \n    float curr_b = texture(b, center_uv).x;\n    float lapl_b = \n        -4. * curr_b\n        + texture(b, (coord+vec2(1,0)*n)/res).x\n        + texture(b, (coord-vec2(1,0)*n)/res).x\n        + texture(b, (coord+vec2(0,1)*n)/res).x\n        + texture(b, (coord-vec2(0,1)*n)/res).x;\n    \n    float V = potential(coord, res, mouse);\n    float H = lapl_b + V * curr_b;\n    \n    float next_a = last_a + inv * dt * H;\n    \n    // Setup at beginning of run\n    if (frame < 50) {\n        vec2 uv = center_uv * 2. - 1.;\n        uv.y *= res.y/res.x;\n        if (length(uv) < 0.2) {\n            vec2 psi = wave_packet(uv, float(inv < 0.)/2.);\n            next_a = inv < 0. ? psi.x : psi.y;\n        }\n    }\n    \n    // Boundary conditions\n    const vec2 margin = vec2(5);\n    if (any(greaterThan(coord, res-margin)) || any(lessThan(coord, margin))) {\n        next_a = 0.;\n    }\n    \n    return vec4(next_a, last_a, 0, 0);\n}","name":"Common","description":"","type":"common"}]}