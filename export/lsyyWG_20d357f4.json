{"ver":"0.1","info":{"id":"lsyyWG","date":"1523202047","viewed":1740,"name":"Tight cornell box ","username":"Pr0fed","description":"Well, step by step i go.. Thank's to Peter Shirley for his books :)\nI'll appreciate any advises, improvements, optimizations and hacks. Especially on emissive materials and ambient occlusion.","likes":47,"published":1,"flags":32,"usePreview":1,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = pow(texture(iChannel0, uv), vec4(0.4545));\n    \n\tfragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// My second ray tracer following Peter Shirley's \"Raytracing : the next week.\n// Still didn't get it on volumetric's though.\n// Also hard to implement class-based objects like boxes.\n// We can of course hardcode them like Cornell Box i've done here\n// But thats really a struggle.\n\n// Made better emissive materials.\n// Got more idea on diel and metal ones.\n\n// Set it bigger to less noise and accurate render.\n#define MAX_WEIGHT 150.0\n\n#define MAX_DISTANCE 25.0\n\n#define SAMPLES 15\n#define MAX_BOUNCES 7\n#define NUM_SPHERES 11\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\n// Materials\n#define LAMB 0\n#define METAL 1\n#define DIEL 2\n#define EMISSIVE 3\n#define ISOTROPIC 4\n#define CHECKER 5\n#define PERLIN 6\n\nconst float GAMMA = 2.2;\n\n///-- Scene Objects -------------------------------------------------------\n\nstruct Material\n{\n\tint type;\n    vec3 albedo;\n    \n    // value corresponds to a material. \n    //\n    // Roughness for metal.\n    // Refract index for dielectrics.\n    // Color multiplier for current fake emission mat.\n    float v; \n};\n    \nstruct Sphere\n{\n\tvec3 c;\n    float r;\n    Material mat;\n};\n\n// XY-aligned rect on z distance.\nstruct xyRect\n{\n    float x0;\n    float x1; \n    float y0;\n    float y1;\n    float z;\n    Material mat;\n};\n    \n// XZ-aligned rect on z distance.\nstruct xzRect\n{\n    float x0;\n    float x1; \n    float z0;\n    float z1;\n    float y;\n    Material mat;\n};\n    \n// YZ-aligned rect on z distance.\nstruct yzRect\n{\n    float y0;\n    float y1; \n    float z0;\n    float z1;\n    float x;\n    Material mat;\n};\n\n// Just for the sake of simplicity.\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct bBox3\n{\n    vec3 pMin;\n    vec3 pMax;\n};\n    \n// Spheres on scene declaration.\nSphere scene[NUM_SPHERES];\n\n\n///-- Helper Functions -----------------------------------------------------\n    \nfloat seed = 0.0;\nvec2 UV = vec2(0.0);\n\nfloat random() \n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n}\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\n// Shlick's formula for transparent materials like glass.\nfloat schlick(float cosine, float IOR) \n{\n \tfloat r0 = (1.0 - IOR) / (1.0 + IOR);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    return -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y)));\n}\n\n// Simple 2D gradient noise taken from you know where: https://www.shadertoy.com/view/XdXGW8\n// Thx IQ :)\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n#define NUM_OCTAVES 2\n\nfloat fbm ( in vec2 _st) \n{\n    float v = 0.5;\n    float a = 0.5;\n    \n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.25), sin(0.25),\n                    -sin(0.25), cos(0.25));\n    \n    for (int i = 0; i < NUM_OCTAVES; ++i) \n    {\n        v += a * noise2D(_st);\n        _st = rot * _st * 2.0;\n        \n        // Need to clamp, or it is very soft when camera is away and very sharp when near.\n        a *= 0.5;\n    }\n    \n    if(v <= 0.5)\n    {\n        return 0.1;\n    }\n    \n    else if(v >= 0.5)\n    {\n        return 1.;\n    }\n}\n\n// I guess i've seen a correct formula for sphere cheker pattern.\n// This one gives artifacts.\nvec3 CheckerTex(vec3 p)\n{\n    float sines = sin(p.x * 10.) * sin(p.y * 10.) * sin(p.z * 10.);\n    if(sines < 0.) return vec3(0.1);\n    else return vec3(1.0);\n}\n\n// Function uses 3d coordinate to covert them to polar.\n// Usefull to map 2d textures on a sphere.\nvec2 GetSphereUV(vec3 p)\n{\n    float phi = atan(p.z, p.x);\n    float theta = asin(p.y);\n    float u = 1. - (phi + PI) / PI2;\n    float v = (theta + PI / 2.) / PI;\n    \n    return vec2(u, v);\n}\n\n///-- INTERSECT FUNCTIONS -----------------------------------------------------\n\n\n// The point where we intersected something.\nvec3 getHitPoint(Ray ray, float t) \n{\n \treturn ray.origin + t * ray.direction;   \n}\n\n// XY plane intersection.\nbool xyIntersect(Ray ray, xyRect rect, float tMin, float tMax, out float t)\n{\n    t = (rect.z - ray.origin.z) / ray.direction.z;\n    \n    // Checking for min max clamp.\n    if(t < tMin || t > tMax) return false;\n    \n    float x = ray.origin.x + t * ray.direction.x;\n    float y = ray.origin.y + t * ray.direction.y;\n    \n    // Checking if we are inside rect 2d bounds.\n    if(x < rect.x0 || x > rect.x1 || y < rect.y0 || y > rect.y1) return false;\n    \n    return true;\n}\n\n// XZ plane intersection.\nbool xzIntersect(Ray ray, xzRect rect, float tMin, float tMax, out float t)\n{\n    t = (rect.y - ray.origin.y) / ray.direction.y;\n    \n    // Checking for min max clamp.\n    if(t < tMin || t > tMax) return false;\n    \n    float x = ray.origin.x + t * ray.direction.x;\n    float z = ray.origin.z + t * ray.direction.z;\n    \n    // Checking if we are inside rect 2d bounds.\n    if(x < rect.x0 || x > rect.x1 || z < rect.z0 || z > rect.z1) return false;\n    \n    return true;\n}\n\n// YZ plane intersection.\nbool yzIntersect(Ray ray, yzRect rect, float tMin, float tMax, out float t)\n{\n    t = (rect.x - ray.origin.x) / ray.direction.x;\n    \n    // Checking for min max clamp.\n    if(t < tMin || t > tMax) return false;\n    \n    float y = ray.origin.y + t * ray.direction.y;\n    float z = ray.origin.z + t * ray.direction.z;\n    \n    // Checking if we are inside rect 2d bounds.\n    if(y < rect.y0 || y > rect.y1 || z < rect.z0 || z > rect.z1) return false;\n    \n    return true;\n}\n\n///-- MAIN FUNCTIONS --------------------------------------------------------\n\n// Ray tracing function.\nbool hitScene(Ray ray, float tMin, float tMax,\n              out vec3 position, out vec3 normal, out Material material, out Sphere sphere)\n{\n    // By default we assume that we are at max distance\n    // and didn't hit anything.\n    float closestSoFar = tMax;\n    bool isHit = false;\n    float t;\n    \n    // Green wall.\n    xyRect xyrect = xyRect(-3., 3., -0.2, 4., 4., Material(LAMB, vec3(0.12, 0.45, 0.15), 0.0));\n    if(xyIntersect(ray, xyrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n            isHit = true;\n            vec3 p = getHitPoint(ray, t);\n            position = p;\n            normal = vec3(0, 0, -1) + randomUnitVector();\n            material = xyrect.mat;\n        }\n    }\n    \n    // Red wall.\n    xyrect = xyRect(-3., 3., -0.2, 4., -4., Material(LAMB, vec3(0.65, 0.05, 0.05), 0.0));\n    if(xyIntersect(ray, xyrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n            isHit = true;\n            vec3 p = getHitPoint(ray, t);\n            position = p;\n            normal = vec3(0, 0, 1) + randomUnitVector();\n            material = xyrect.mat;\n    \t}\n    }\n    \n    // Back wall.\n    yzRect yzrect = yzRect(-0.2, 4.0, -4., 4., -3.0, Material(LAMB, vec3(0.73), 0.0));\n    if(yzIntersect(ray, yzrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n            isHit = true;\n            vec3 p = getHitPoint(ray, t);\n            position = p;\n            normal = vec3(1, 0, 0) + randomUnitVector();\n            material = yzrect.mat;\n    \t}\n    }\n    \n    // Bottom wall.\n    xzRect xzrect = xzRect(-3., 3., -4., 4., -0.2, Material(LAMB, vec3(0.73), 0.0));\n    if(xzIntersect(ray, xzrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n            isHit = true;\n            vec3 p = getHitPoint(ray, t);\n            position = p;\n            normal = vec3(0, 1, 0) + randomUnitVector();\n            material = xzrect.mat;\n    \t}\n    }\n    \n    // Upper wall.\n    xzrect = xzRect(-3., 3., -4., 4., 4.0, Material(LAMB, vec3(0.73), 0.0));\n    if(xzIntersect(ray, xzrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n            isHit = true;\n            vec3 p = getHitPoint(ray, t);\n            position = p;\n            normal = vec3(0, -1, 0) + randomUnitVector();\n            material = xzrect.mat;\n        }\n    }\n    \n    // Bottom metal panel.\n    xzrect = xzRect(1.5, 2.5, 2.25, 3.25, -0.19, Material(METAL, vec3(0.83), 0.1));\n    if(xzIntersect(ray, xzrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n        \tisHit = true;\n        \tvec3 p = getHitPoint(ray, t);\n            position = p;\n        \tnormal = vec3(0, 1, 0);\n        \tmaterial = xzrect.mat;\n        }\n    }\n    \n    // Right metal panel.\n    xyrect = xyRect(1.0, 2.5, 0.5, 2.5, -3.995, Material(METAL, vec3(0.83), 0.0));\n    if(xyIntersect(ray, xyrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n            isHit = true;\n            vec3 p = getHitPoint(ray, t);\n            position = p;\n            normal = vec3(0, 0, 1);\n            material = xyrect.mat;\n    \t}\n    }\n    \n    // Upper light panel.\n    xzrect = xzRect(-1.5, 1.5, -1.5, 1.5, 3.99, Material(EMISSIVE, vec3(1.0), 1.25));\n    if(xzIntersect(ray, xzrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n        \tisHit = true;\n        \tvec3 p = getHitPoint(ray, t);\n            position = p;\n        \tnormal = vec3(0, -1, 0) + randomUnitVector();\n        \tmaterial = xzrect.mat;\n        }\n    }\n    \n    // Intersection with spheres.\n    // Looping through all, caching the closest 't' point.\n    // which is a distance from ray origin and later used to get hit point.\n    for (int i = 0; i < NUM_SPHERES; i++) \n    {\n        Sphere sphere = scene[i];\n        \n        // Sphere intersection formula.\n        vec3 oc = ray.origin - sphere.c;\n        float a = dot(ray.direction, ray.direction);\n        float b = dot(oc, ray.direction);\n        float c = dot(oc, oc) - sphere.r * sphere.r;\n        float discriminant = b * b - a * c;\n        \n        if (discriminant > 0.0001) \n        {\n            // We only need the closer side of a sphere.\n\t\t\tfloat t = (-b - sqrt(discriminant)) / a;\n            \n            if (t < tMin) \n            {\n                t = (-b + sqrt(discriminant)) / a;\n            }\n            \n            // If we hit sphere, which is closest so far,\n            // we set it to closest, and re-set output\n            // materials and other stuff.\n            if (t > tMin && t < closestSoFar) \n            {\n                closestSoFar = t;\n                isHit = true;\n                \n                vec3 p = getHitPoint(ray, t);\n                position = p;\n                normal = (p - sphere.c) / sphere.r;\n                material = sphere.mat;\n            }\n        }\n    }\n        \n    return isHit;\n}\n\n// Main tracing function.\nvec3 trace(Ray ray) \n{\n    vec3 normal, position;\n    Material material;\n    Sphere sphere;\n    \n    vec3 color = vec3(1.0);\n    vec3 attenuation = vec3(1.0);\n         \n    // So for each bounce, we try to hit anything\n    // on the scene (spheres only yet), and then we \n    // apply the material of that object to properly\n    // color it. After all (when the bounce hit nothing)\n    // we multiply the rest of attenuation by \"sky\" color.\n    for (int b = 0; b < MAX_BOUNCES; b++) \n    {       \n        if (hitScene(ray, 0.001, MAX_DISTANCE, position, normal, material, sphere)) \n        {\n            // Lambertian material.\n            if (material.type == LAMB) \n            {\n                vec3 direction = normal + randomUnitVector();\n                ray = Ray(position, direction);\n                color *= material.albedo * attenuation;\n                attenuation *= material.albedo;\n            }\n            \n            // Metallic material.\n            else if (material.type == METAL)\n            {\n                vec3 reflected = reflect(ray.direction, normal);\n                vec3 direction = randomUnitVector() * material.v + reflected;\n                \n                if (dot(direction, normal) > 0.0) \n                {\n               \t\tray = Ray(position, direction);\n                \tcolor *= material.albedo * attenuation;\n               \t \tattenuation *= material.albedo;\n                }\n            }\n            \n            // Dielectric material.\n            else if (material.type == DIEL)\n            {\n                 vec3 outward_normal;\n                 vec3 reflected = reflect(ray.direction, normal);\n                 float ni_over_nt;\n\n                 vec3 refracted;\n                 \n                 attenuation = vec3(1.0, 1.0, 1.0); \n                \n                 float reflect_prob;\n                 float cosine;\n\n                 if (dot(ray.direction, normal) > 0.) \n                 {\n                      outward_normal = -normal;\n                      ni_over_nt = material.v;\n                      cosine = dot(ray.direction, normal) / length(ray.direction);\n                      cosine = sqrt(1. - material.v * material.v * (1. - cosine * cosine));\n                 }\n                \n                 else \n                 {\n                      outward_normal = normal;\n                      ni_over_nt = 1.0 / material.v;\n                      cosine = -dot(ray.direction, normal) / length(ray.direction);\n                 }\n\n                 refracted = refract(normalize(ray.direction), normalize(outward_normal), ni_over_nt);\n                 if (length(refracted) > 0.0) \n                 {\n                     reflect_prob = schlick(cosine, material.v);\n                 }\n\n\n                 else reflect_prob = 1.0;\n\n                 if (random() < reflect_prob)\n                    ray = Ray(position, reflected);\n\n                 else ray = Ray(position, refracted);\n\n                 color *= material.albedo * attenuation;\n                 attenuation *= color;\n            }\n            \n            // Emissive material. (WIP)\n            // First version here: https://www.shadertoy.com/view/4sVcDh\n            // This one is not fully correct, too.\n            // But at least it works better for this scene.\n            // While resetting ray to its origin, we don't\n            // mix other colors onto emissive object surface.\n            // But that doesn't seem to work in an open scene (link above)\n            // without the walls, becuse we end up hitting nothing and go black.\n            else if (material.type == EMISSIVE )\n            {\n                vec3 direction = normal + randomUnitVector();\n                ray = Ray(ray.origin, ray.direction);\n                color *= material.albedo * material.v;\n               \tattenuation *= color;\n            }\n            \n            // We apply a simple checker pattern to a material.\n            else if (material.type == CHECKER)\n            {\n               vec3 direction = normal + randomUnitVector();\n               ray = Ray(position, direction);\n               color *= CheckerTex(normal * material.v) * material.albedo * attenuation;\n               attenuation *= CheckerTex(normal * material.v) * material.albedo; \n            }\n            \n            // We add a perlin noise texure to a material.\n            else if (material.type == PERLIN)\n            {\n               vec3 direction = normal + randomUnitVector();\n               ray = Ray(position, direction);\n               color *= fbm(GetSphereUV(normal) * 25.) * material.v * material.albedo * attenuation;\n               attenuation *= color; \n            }\n        }\n        \n        // At the end we mix with \"sky\" color which is an iChannel1.\n        else \n        {\n            vec3 skyColor = texture(iChannel1, -ray.direction).rgb;\n            skyColor = pow(skyColor, vec3(GAMMA));\n            color = attenuation * skyColor;\n        }\n    }\n    \n    return color;\n}\n\n///-------------------------------------------------------------------------\n\n// Putting it all somewhere on the scene.\nvoid SceneFill() \n{\n    // Spheres.\n    scene[0] = Sphere(vec3(-1.0, 1.0, 0.0), 1.0, Material(METAL, vec3(0.75, 0.75, 0.75), 0.05));\n    scene[1] = Sphere(vec3(-0.75, 1.0, 3.0), 0.75, Material(EMISSIVE, vec3(0.0, 0.5, 1.4), 1.0));\n    \n    scene[2] = Sphere(vec3(-0.75, 1.0, -3.0), 0.75, Material(DIEL, vec3(0.9, 0.9, 0.3), 1.517));\n    // Negative radius hack sphere inside main (DIEL) one for correct reflection.\n    scene[3] = Sphere(vec3(-0.75, 1.0, -3.0), -0.74, Material(DIEL, vec3(0.9, 0.9, 0.3), 1.517));\n    \n    scene[4] = Sphere(vec3(0.35, 0.6, -1.8), 0.6, Material(CHECKER, vec3(1.6, 0.8, 0.0), 1.0));\n    scene[5] = Sphere(vec3(0.35, 0.6, 1.8), 0.6, Material(PERLIN, vec3(1.0, 0.0, 0.8), 1.)); \n    scene[6] = Sphere(vec3(2.0, 0.4, 2.75), 0.4, Material(CHECKER, vec3(0.0, 1.9, 0.9), 1.5));\n    \n    // Nice combo of Lambert + diel surface gives enamel feel.\n    scene[7] = Sphere(vec3(2.0, 0.4, -2.75), 0.4, Material(LAMB, vec3(0.2, 0.0, 0.8), 0.15));\n    scene[8] = Sphere(vec3(2.0, 0.4, -2.75), 0.401, Material(DIEL, vec3(1.0), 1.31));\n    \n    scene[9] = Sphere(vec3(2.0, 0.4, -0.916), 0.4, Material(LAMB, vec3(0.13, 0.9, 0.1), 0.));\n    scene[10] = Sphere(vec3(2.0, 0.4, 0.916), 0.4, Material(METAL, vec3(0.83), 0.345)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialization and seed.\n    SceneFill();\n    seed = iTime;\n\n    // Basic normalization.\n    UV = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Camera stuff taken from https://www.shadertoy.com/view/ldtSR2.\n    const float fov = 80.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / aspect;\n    \n    const float dist = 7.5;\n    vec2 mousePos = iMouse.xy / iResolution.xy;  \n    \n    if (all(equal(mousePos, vec2(0.0)))) \n    {\n        mousePos = vec2(0.63, 0.27); // Default position.\n    }\n    \n    float x = cos(mousePos.x * 10.0) * dist;\n    float z = sin(mousePos.x * 10.0) * dist;\n    float y = mousePos.y * 10.0;\n        \n    vec3 origin = vec3(x, y, z);\n    vec3 lookAt = vec3(0.0, 1.4, 0.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    \n    vec3 w = normalize(origin - lookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n    \n    vec3 lowerLeft = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n    \n    vec3 color = vec3(0.0);\n    \n    // We add random amount for a better AA. More samples - smoother.\n    for (int s = 0; s < SAMPLES; s++) \n    {        \n     \tvec3 direction = lowerLeft - origin;\n        direction += horizontal * (pixelSize.x * random() + UV.x);\n        direction += vertical * (pixelSize.y * random() + UV.y);\n        color += trace(Ray(origin, direction));\n    }\n    \n    color /= float(SAMPLES);\n       \n    vec3 previousColor = texture(iChannel0, UV).rgb;\n    \n    float weight = min(float(iFrame + 1), float(MAX_WEIGHT));\n    \n    // Resetting weight on mouse change.\n    if (!all(lessThanEqual(iMouse.zw, vec2(0.0)))) \n    {\n        weight = 1.0;\n    }\n    \n    vec3 newColor = mix(previousColor, color, 1.0 / weight);\n    \n    fragColor = vec4(newColor, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}