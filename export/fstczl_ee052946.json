{"ver":"0.1","info":{"id":"fstczl","date":"1653944431","viewed":150,"name":"Statefulness - FlyCam by Omni","username":"Omniscience","description":"Demonstrates keeping program state in a buffer. In this example, we keep some flags, and a Transform (pos and rot quaternion), mutate it using WASDRF/QE/mouselook, and allow the main program to access it as a view matrix. This allows flycam controls.","likes":10,"published":1,"flags":48,"usePreview":0,"tags":["camera","raytrace","pathtrace","state","flycam","statful","mouselook"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Material {\n    vec3 diffuse;\n    vec3 specular;\n};\nconst Material BLACK = Material(ZERO3, ZERO3);\nconst Material WHITE = Material(vec3(1.0).xxx, ZERO3);\nconst Material RED   = Material(vec3(1.0, 0.0, 0.0), ZERO3);\nconst Material GREEN = Material(vec3(0.0, 1.0, 0.0), ZERO3);\nconst Material BLUE  = Material(vec3(0.0, 0.0, 1.0), ZERO3);\nconst Material BACKGROUND = Material(vec3(0.5, 0.75, 1.0), ZERO3);\n\nMaterial mat(vec3 c) { return Material(c, ZERO3); }\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nstruct Contact {\n    bool hit;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\nconst Contact NO_CONTACT = Contact(false, ZERO3, ZERO3, BACKGROUND);\n\nstruct Sample {\n    vec3 light;\n    Contact contact;\n};\n\nContact raySphereContact(Ray ray, Sphere sphere) {\n    vec3 O = ray.pos;\n    vec3 D = ray.dir;\n    vec3 C = sphere.position;\n    float r = sphere.radius;\n    float r2 = r*r;\n    vec3 L = C - O;\n    \n    float tca = dot(L, ray.dir);\n    //if (tca < 0.0) return NO_CONTACT;\n    \n    float d2 = dot(L, L) - tca*tca;\n    if (d2 > r2) return NO_CONTACT;\n    \n    float thc = sqrt(r2 - d2);\n    float t0 = min(tca - thc, tca + thc);\n    if (t0 < 0.0) return NO_CONTACT;\n    \n    vec3 P = O + t0 * D;\n    \n    return Contact(true, P, normalize(P - C), sphere.material);\n}\n\nconst float _m = 0.125;\nconst float _M = 0.5;\n\nconst int NUM_OBJECTS = 9;\nconst Sphere objects[] = Sphere[](\n    Sphere(vec3(-2.5, 1.0, -2.5), 1.0, Material(vec3(0.0, 0.0, 0.0), ZERO3)),\n    Sphere(vec3(0.0,  1.0, -2.5), 1.0, Material(vec3(_m, _m, _m), ZERO3)),\n    Sphere(vec3(2.5,  1.0, -2.5), 1.0, Material(vec3(_M, _M, _M), ZERO3)),\n    Sphere(vec3(-2.5, 1.0, 0.0), 1.0, Material(vec3(_M, _m, _m), ZERO3)),\n    Sphere(vec3(0.0,  1.0, 0.0), 1.0, Material(vec3(_m, _M, _m), ZERO3)),\n    Sphere(vec3(2.5,  1.0, 0.0), 1.0, Material(vec3(_m, _m, _M), ZERO3)),\n    Sphere(vec3(-2.5, 1.0, 2.5), 1.0, Material(vec3(_M, _M, _m), ZERO3)),\n    Sphere(vec3(0.0,  1.0, 2.5), 1.0, Material(vec3(_m, _M, _M), ZERO3)),\n    Sphere(vec3(2.5,  1.0, 2.5), 1.0, Material(vec3(_M, _m, _M), ZERO3))\n);\n\nRay reflectRay(Ray ray, Contact contact) {\n    return Ray(contact.position, reflect(ray.dir, contact.normal));\n}\n\nconst int MAX_DEPTH = 4;\n\nfloat lerp(float a, float b, float x) { return a + (b-a) * x; }\n\nContact sampleRayOnce(Ray ray) {\n    Contact best = NO_CONTACT;\n    float bestDist = 0.0;\n    \n    for (int i=0; i<NUM_OBJECTS; ++i) {\n        Contact contact = raySphereContact(ray, objects[i]);\n        if (contact.hit) {\n            float d = distance(ray.pos, contact.position);\n            if (!best.hit || d < bestDist) {\n                best = contact;\n                bestDist = d;\n            }\n        }\n    }\n\n    if (ray.dir.y < 0.0 && ray.pos.y > 0.0) {\n        float y = ray.pos.y;\n        float aspect = y / ray.dir.y;\n        float h = -1.0 * aspect;\n        vec3 pos = ray.pos + ray.dir * h;\n\n        Material mat = BLACK;\n        bool bx = fract(pos.x * 0.5) < 0.5;\n        bool bz = fract(pos.z * 0.5) < 0.5;\n        if (bx ^^ bz) mat = WHITE;\n        \n        Contact contact = Contact(true, pos, UP, mat);\n        \n        float d = distance(ray.pos, contact.position);\n        if (!best.hit || d < bestDist) {\n            best = contact;\n            bestDist = d;\n        }\n    }\n    \n    if (!best.hit) {\n        best.material.diffuse = texture(iChannel1, ray.dir).xyz;\n        //best.material.diffuse = BACKGROUND.diffuse * lerp(0.5, 1.5, pow(1.0 - ray.dir.y, 1.5));\n    }\n    \n    return best;\n}\n\nSample sampleRay(Ray ray) {\n    Contact firstContact = NO_CONTACT;\n    vec3 light = ZERO3;\n    float absorbtion = 1.0;\n    \n    for (int depth=0; depth<MAX_DEPTH; ++depth) {\n        Contact contact = sampleRayOnce(ray);\n        \n        if (depth == 0) firstContact = contact;\n        \n        if (contact.hit) {\n            float dp = clamp(-dot(ray.dir, contact.normal), 0.0, 1.0);\n            float kd = pow(dp, 0.99);\n            float ks = lerp(0.0, 1.0, 1.0 - pow(kd, 0.75));\n\n            light += contact.material.diffuse * kd * absorbtion;\n            absorbtion *= ks;\n\n            ray = reflectRay(ray, contact);\n        }\n        else {\n            light += contact.material.diffuse * absorbtion;\n            break;\n        }\n    }\n    \n    return Sample(light, firstContact);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 kres = 1.0 / iResolution.xy;\n\n    vec4 state[] = vec4[] (\n        texture(iChannel0, vec2(0.5, 0.5) * kres),\n        texture(iChannel0, vec2(1.5, 0.5) * kres),\n        texture(iChannel0, vec2(2.5, 0.5) * kres),\n        texture(iChannel0, vec2(3.5, 0.5) * kres)\n    );\n    Transform xform = Transform(state[1].xyz, state[2]);\n    mat4 view = matrixFromTransform(xform);\n    \n    float aspectRatio = iResolution.x / iResolution.y;\n    vec4 screenPos = vec4(-1.0 + 2.0 * fragCoord * kres, 0.0, 1.0);\n    screenPos.x *= aspectRatio;\n    \n    //view = rotateY(mod(iTime * 10.0, 360.0) * DEG_TO_RAD) * view;\n    \n    vec4 rayPos = view * vec4(ZERO3, 1.0);\n    vec3 rayDir = mat3(view) * normalize(vec3(screenPos.xy, 2.0));\n    Ray ray = Ray(rayPos.xyz, rayDir);\n    Sample raySample = sampleRay(ray);\n    Contact contact = raySample.contact;\n    \n    fragColor = vec4(rayDir, 1.0);\n    fragColor = vec4(rayPos.yyy, 1.0);\n    fragColor = vec4(contact.normal, 1.0);\n    fragColor = vec4(raySample.light, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.141592653589793238462643327950;\nconst float PI_BY_90 = PI / 90.0;\nconst float DEG_TO_RAD = PI / 180.0;\nconst vec3 FWD = vec3(0.0, 0.0, 1.0);\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\nconst vec3 RIGHT = vec3(1.0, 0.0, 0.0);\nconst vec3 ZERO3 = vec3(0.0, 0.0, 0.0);\nconst vec3 ONE3 = vec3(1.0, 1.0, 1.0);\n\nmat4 identity() {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x, 0.0, 0.0, 0.0,\n        0.0, s.y, 0.0, 0.0,\n        0.0, 0.0, s.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 translate(vec3 pos) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        pos.x, pos.y, pos.z, 1.0\n    );\n}\nmat4 rotateX(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0,   c,   s, 0.0,\n        0.0,  -s,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateY(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n          c, 0.0,  -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n          s, 0.0,   c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nmat4 rotateZ(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat4(\n        c,   s,  0.0, 0.0,\n        -s,   c,   0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matrixFromQuat(vec4 q) {\n    float x = q.x, y = q.y, z = q.z, w = q.w;\n    float x2 = x*x, y2 = y*y, z2 = z*z;\n    \n    float xy = x*y, xz = x*z, yz = y*z,\n          xw = x*w, yw = y*w, zw = z*w;\n    \n    return identity() + 2.0 * mat4(\n        -(y2 + z2),  (xy + zw),  (xz - yw), 0.0,\n         (xy - zw), -(x2 + z2),  (yz + xw), 0.0,\n         (xz + yw),  (yz - xw), -(x2 + y2), 0.0,\n               0.0,        0.0,        0.0, 0.0\n    );\n}\n\nvec4 quatConjugate(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qmul(vec4 a, vec4 b) {\n    float ax = a.x, ay = a.y, az = a.z, aw = a.w;\n    float bx = b.x, by = b.y, bz = b.z, bw = b.w;\n    return vec4(\n        aw*bx + ax*bw + ay*bz - az*by,\n        aw*by + ay*bw + az*bx - ax*bz,\n        aw*bz + az*bw + ax*by - ay*bx,\n        aw*bw - ax*bx - ay*by - az*bz\n    );\n}\n\nvec3 qmulv(vec4 q, vec3 v) {\n    vec4 vq = vec4(v, 0.0);\n    vec4 c = quatConjugate(q);\n    q = qmul(q, vq);\n    q = qmul(q, c);\n    return q.xyz;\n}\nvec4 qmulv(vec4 q, vec4 v) {\n    return vec4(qmulv(q, v.xyz), v.w);\n}\n\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    angle *= 0.5;\n    float sa = sin(angle);\n    float ca = cos(angle);\n    return vec4(\n        axis.x * sa,\n        axis.y * sa,\n        axis.z * sa,\n        ca\n    );\n}\n\nvec4 quatFromEulerDeg(vec3 euler) {\n    float ex = euler.x, ey = euler.y, ez = euler.z;\n    float ep = ex * PI_BY_90,\n          eq = ey * PI_BY_90,\n          er = ez * PI_BY_90,\n        sinp = sin(ep),\n        siny = sin(eq),\n        sinr = sin(er),\n        cosp = cos(ep),\n        cosy = cos(eq),\n        cosr = cos(er);\n    vec4 q = vec4(\n        sinr * cosp * cosy - cosr * sinp * siny,\n        cosr * sinp * cosy + sinr * cosp * siny,\n        cosr * cosp * siny - sinr * sinp * cosy,\n        cosr * cosp * cosy + sinr * sinp * siny\n    );\n    return normalize(q);\n}\n\nstruct Transform {\n    vec3 pos;\n    vec4 rot;\n};\n\nTransform t_identity() {\n    return Transform(ZERO3, vec4(0.0, 0.0, 0.0, 1.0));\n}\n\nmat4 matrixFromTransform(Transform xform) {\n    mat4 m = identity();\n    m *= translate(xform.pos);\n    m *= matrixFromQuat(xform.rot);\n    return m;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define STATE_LENGTH   5.0\n#define STATE_LENGTH_I 5\n\n#define STATE_FLAGS 0.5\n#define STATE_POS   1.5\n#define STATE_ROT   2.5\n#define STATE_VEL   3.5\n#define STATE_MOUSE 4.5\n\n#define STATE_FLAGS_I 0\n#define STATE_POS_I   1\n#define STATE_ROT_I   2\n#define STATE_VEL_I   3\n#define STATE_MOUSE_I 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 kres = 1.0 / iResolution.xy;\n    vec2 uvi = fragCoord;\n    vec2 uv = uvi * kres;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if (uvi.y < 1.0 && uvi.x < STATE_LENGTH) {\n        vec4 state[] = vec4[] (\n            texture(iChannel0, vec2(0.5, 0.5) * kres),\n            texture(iChannel0, vec2(1.5, 0.5) * kres),\n            texture(iChannel0, vec2(2.5, 0.5) * kres),\n            texture(iChannel0, vec2(3.5, 0.5) * kres),\n            texture(iChannel0, vec2(4.5, 0.5) * kres)\n        );\n        \n        vec4 flags = state[STATE_FLAGS_I];\n        \n        // Catch initial load and set default values\n        if (flags.x != 1.0) {\n            flags.x = 1.0;\n            state[STATE_FLAGS_I] = flags;\n            \n            state[STATE_POS_I] = vec4(0.0, 1.0, -5.0, 0.0);\n            state[STATE_ROT_I] = quatFromAxisAngle(RIGHT, 5.0 * DEG_TO_RAD);\n        }\n        \n        // Controls\n        vec4 kbW = texture(iChannel1, vec2(87.0/256.0, 0.0));\n        vec4 kbA = texture(iChannel1, vec2(65.0/256.0, 0.0));\n        vec4 kbS = texture(iChannel1, vec2(83.0/256.0, 0.0));\n        vec4 kbD = texture(iChannel1, vec2(68.0/256.0, 0.0));\n        vec4 kbR = texture(iChannel1, vec2(82.0/256.0, 0.0));\n        vec4 kbF = texture(iChannel1, vec2(70.0/256.0, 0.0));\n        vec4 kbQ = texture(iChannel1, vec2(81.0/256.0, 0.0));\n        vec4 kbE = texture(iChannel1, vec2(69.0/256.0, 0.0));\n        \n        vec4 prevMouse = state[STATE_MOUSE_I];\n        state[STATE_MOUSE_I] = iMouse;\n        if (prevMouse.z != iMouse.z)\n            prevMouse = iMouse;\n        vec4 dMouse = iMouse - prevMouse;\n        \n        vec2 sensitivity = vec2(1.5, 2.0);\n        \n        // Rotation\n        float roll = (kbQ.x - kbE.x) * 0.02;\n        vec2 mouse_norm = dMouse.xy * kres * sensitivity;\n        vec3 angles = vec3(-mouse_norm.y, mouse_norm.x, roll);\n        \n        vec4 rot = state[STATE_ROT_I];\n        rot = qmul(rot, quatFromAxisAngle(FWD, angles.z));\n        rot = qmul(rot, quatFromAxisAngle(UP, angles.y));\n        rot = qmul(rot, quatFromAxisAngle(RIGHT, angles.x));\n        \n        state[STATE_ROT_I] = rot;\n        \n        // Translation\n        vec4 velocity = state[STATE_VEL_I];\n        \n        vec4 accel = vec4(kbD.x - kbA.x, kbR.x - kbF.x, kbW.x - kbS.x, 0.0);\n        accel *= 0.0125;\n        accel = qmulv(rot, accel);\n        \n        velocity += accel;\n        velocity *= 0.875;\n        \n        state[STATE_VEL_I] = velocity;\n        state[STATE_POS_I] += velocity;\n        \n        // Write\n        color = state[int(uvi.x - 0.5)];\n    }\n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}