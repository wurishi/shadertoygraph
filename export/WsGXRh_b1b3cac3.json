{"ver":"0.1","info":{"id":"WsGXRh","date":"1573317960","viewed":99,"name":"bin subdiv interpolation","username":"Carandiru","description":"modified : https://www.shadertoy.com/view/wsGXRz\nthis however is a\ninterpolated version // antialiasing of binary subdivision","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","binary","subdivision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// modified : https://www.shadertoy.com/view/wsGXRz\n// this however is a\n// interpolated version // antialiasing of binary subdivision\n\n#define SUBDIVISION_STEPS 17\n#define STEP_SPEED 0.5f\n#define NON_LINEAR_WEIGHTING 3.0f\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n#define NOISE_SCALAR (17.0f/255.0f)\n\n\nfloat getValue(vec2 pos){\n    return texture(iChannel0,vec3(pos/20.,iTime*0.009)).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //from -1 to 1\n    vec2 pos=( 2.*fragCoord - iResolution.xy )/iResolution.y;\n    \n    float weight = 1.0f;\n    vec3 col=vec3(0.);\n    \n    int LOOPE = int(floor(float(SUBDIVISION_STEPS) * abs(sin(iTime * STEP_SPEED))));\n    \n    vec3 paintColor=vec3(1./float(LOOPE+1));\n    for(int i=0;i<=LOOPE;i++){\n        float s=(2./iResolution.y)*float(1<<(LOOPE-i));\n        vec2 tilePos=floor(pos/s)*s;\n        float value0=getValue(tilePos+vec2(0.,0.));\n        float value1=getValue(tilePos+vec2(s,0.));\n        float value2=getValue(tilePos+vec2(0.,s));\n        float value3=getValue(tilePos+vec2(s,s));\n\n        float minValue=min(min(value0,value1),min(value2,value3));\n        float maxValue=max(max(value0,value1),max(value2,value3));\n        \n        // interpolation of if statement from original shader (see commented out below)\n        float pixel_width = 1.0f / (fragCoord.x*fragCoord.y);\n        float aa_min = smoothstep(0.0f, weight * 2.0f, 0.5f - (minValue - pixel_width));\n        float aa_max = smoothstep(0.0f, 1.0f + weight * 2.0f, 1.0f - (maxValue - pixel_width));\n        \n        float aa = aa_min * weight + aa_max * weight;\n        \n        //if(minValue<.5 &&.5<maxValue){\n        \tfloat lastweight = weight;\n        \tweight = NON_LINEAR_WEIGHTING / float(1 + i);\n        \tfloat combinedweight = lastweight+weight;\n        \taa = aa * (1.0f - smoothstep(weight, lastweight, aa * (combinedweight)));\n            col+=paintColor * aa * float(i>>1);\n            \n        //}\n    }\n    \n    //if (!(pos.y < 0.969f) || !(pos.y > -0.969f)) {\n        // colorize\n        vec3 cb = col;\n        col *= vec3(0.005, 0.0, 6.0);// * 8e-3;\n        \n        // Compress dynamic range.\n        col.rgb *= 6.0;\n        col.rgb = 1.5 * col.rgb / (1.0 + col.rgb);\n        col = mix(cb, col, cb) + cb * cb;\n   // }\n    \n    \n    // blue noise, 2 channels\n    vec2 no = texelFetch( iChannel1, (ivec2(fragCoord) & 1023), 0 ).xy;\n        \n    // temporal swap of blue noise\n    float noise = mix(no.x, no.y, bool(iFrame&1)) * NOISE_SCALAR;\n\n    // luminance\n    float luma = dot(col, LUMA);\n\n    // apply luma shaded dither\n    col = mix(col - noise, col + noise, luma);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}