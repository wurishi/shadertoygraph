{"ver":"0.1","info":{"id":"ft23W3","date":"1624860525","viewed":104,"name":"Straight-forward hexagon tiling","username":"ipg","description":"Take an equilateral triangle and stick a circle on each point. Use mod to make it repeat and do a trick to reflect it. Boom, hexagons. Released into the public domain with the unlicense (https://unlicense.org/) ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","pattern","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Straight-forward hexagonal tiling using circle SDFs\n// Released into the public domain with the unlicense (https://unlicense.org/) \n\nfloat rad = 0.25; // Approximately 1/8 of ||<1.0,1.732>||\n\n// Circle SDF\nfloat cSDF(vec2 inV, vec2 c, float r){\n    return (length(inV - c) - r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n\tuv *= 4.; // Determines size\n\tuv = abs((mod(uv,1.)*2.) - 1.); // reflects every row\n    //uv = mod(uv,1.); // Comment above and uncomment this to see without reflection\n    \n    //Each cell has 3 adjancent circles\n\tfloat d = cSDF(uv,vec2(0.,0.),rad);\n\tfloat d2 = cSDF(uv,vec2(0.5,1.),rad);\n\tfloat d3 = cSDF(uv, vec2(1.,0.),rad);\n\td = min(d,d2);\n\td = min(d,d3);\n    \n    // Output to screen\n    fragColor = vec4(vec3(d),1.0);\n}","name":"Image","description":"","type":"image"}]}