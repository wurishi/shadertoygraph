{"ver":"0.1","info":{"id":"l3XGWj","date":"1707984362","viewed":116,"name":"SpaceShader","username":"pam_m_pam","description":"// Based on Star Nest by Pablo Román Andrioli\n// Copied from https://www.shadertoy.com/view/XlfGRj\n// Original content is under the MIT License.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["space","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iterations 19 // Кількість ітерацій для формули\n#define formuparam 0.65 // Параметр формули\n\n#define volsteps 25 // Кількість кроків для волюметричного рендерингу\n#define stepsize 0.15 // Величина кроку\n\n#define zoom   0.999 // Зум\n#define tile   0.999 // Розмір плитки\n#define speed  0.003 // Швидкість\n\n#define brightness 0.0002 // Яскравість\n#define darkmatter 0.300 // Контраст переднього фону\n#define distfading 0.750 // Згасання відстані\n#define saturation 0.999 // Насиченість\n\n// Нові параметри для кольору\n#define color1 vec3(0.0, 0.1, 0.2)  // Початковий колір\n#define color2 vec3(0.2, 0.0, 0.1)  // Кінцевий колір\n#define colorTransitionDistance 30.0 // Відстань, на якій відбувається перехід між кольорами\n\n// Функція для створення S-кривої\nfloat SCurve(float value) {\n    if (value < 0.5) {\n        return value * value * value * value * value * 15.0; \n    }\n    value -= 1.0;\n    return value * value * value * value * value * 15.0 + 1.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Отримання координат та напрямку\n    vec2 uv = fragCoord.yx / iResolution.xy - 0.5;\n    uv.y *= iResolution.y / iResolution.x;\n    vec3 directionCameraMove = vec3(-uv * zoom, 1.0); \n    float time = iTime * speed + 0.25;\n    \n    vec3 startPoint = vec3(1.0, 0.5, 0.5) + vec3(time * -1.0, time, 1.0);\n    \n    // Волюметричний рендеринг\n    float stepSize = 0.15, fade = 0.75;\n    vec3 colorAccumulator = vec3(-1.0);\n    for (int step = 0; step < volsteps; step++) {\n        vec3 position = startPoint + stepSize * directionCameraMove * 0.999;\n        position = abs(vec3(tile) - mod(position, vec3(tile * 2.5))); // згортання\n        float prevLength, currentLength = prevLength = 0.0;\n        for (int i = 0; i < iterations; i++) { \n            position = abs(position) / dot(position, position) - formuparam; \n            currentLength += abs(length(position) - prevLength); \n            prevLength = length(position);\n        }\n        float darkMatter = max(0.0, darkmatter - currentLength * currentLength * 0.001); // розмір темних матерій\n        currentLength *= currentLength * currentLength; // додавання контрасту\n        if (step > 3) fade *= 1.0 - darkMatter; // віддалення темної матерії подалі від камери\n        \n        colorAccumulator += vec3(darkMatter, darkMatter * 0.6, 0.0);\n        colorAccumulator += fade;\n        colorAccumulator += vec3(\n        stepSize, stepSize * stepSize, stepSize * stepSize * stepSize * stepSize) \n        * currentLength * brightness * fade; // колірування залежно від відстані\n        \n        fade *= distfading; // згасання залежно від відстані\n        stepSize += stepsize;\n    }\n    \n    colorAccumulator = mix(vec3(length(colorAccumulator)), colorAccumulator, saturation); // колірна корекція\n    \n    vec4 pixelColor = vec4(colorAccumulator * 0.01, 1.0);\n    \n    // Гамма-корекція\n    pixelColor.r = pow(pixelColor.r, 0.35); \n    pixelColor.g = pow(pixelColor.g, 0.36); \n    pixelColor.b = pow(pixelColor.b, 0.4); \n    \n    vec4 finalColor = pixelColor;   \t\n    \n    // Застосування S-кривої для кожного кольору\n    finalColor.r = mix(finalColor.r, SCurve(finalColor.r), 1.0); \n    finalColor.g = mix(finalColor.g, SCurve(finalColor.g), 0.9); \n    finalColor.b = mix(finalColor.b, SCurve(finalColor.b), 0.6);     \t\n    \n    fragColor = finalColor;\t\n}\n","name":"Image","description":"","type":"image"}]}