{"ver":"0.1","info":{"id":"mtlXWM","date":"1674898879","viewed":115,"name":"小熊","username":"amuda","description":"用RayMarching做了一个小熊","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","model"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ray marching 23.01.28\n// ref https://www.shadertoy.com/view/XlccWH\n\nfloat pupdist = 1e4;\n\nfloat sphere_sdf(vec3 p, vec3 origin, float radius)\n{\n    return length(p - origin) - radius;\n}\n\nvec2 add_union(vec2 r1, vec2 r2)\n{\n    if(r2.x < r1.x)\n    {\n        return r2;\n    }\n    else\n    {\n        return r1;\n    }\n}\n\nvec2 circle_zero(vec3 p)\n{\n    return vec2(sphere_sdf(p, vec3(0.0, 3.5, 0.0), 1.1), 0.0);\n}\n\nvec2 plane_one(vec3 p)\n{\n    return vec2(p.y + 0.4, 1.0);\n}\n\nvec2 circle_two(vec3 p)\n{\n    return vec2(sphere_sdf(p, vec3(0.8, 4.3, 0.0), 0.38), 2.0);\n}\n\nvec2 circle_three(vec3 p)\n{\n    return vec2(sphere_sdf(p, vec3(-0.8, 4.3, 0.0), 0.38), 3.0);\n}\n\nvec2 roundcore_four(vec3 p, float r1, float r2, float h)\n{\n    p -= vec3(0.0, 1.5, 0.0);\n\n    // sampling independent computations (only depend on shape)\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n\n    // sampling dependant computations\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if(k < 0.0)\n        return vec2(length(q) - r1, 4.0);\n    if(k > a * h)\n        return vec2(length(q - vec2(0.0, h)) - r2, 4.0);\n    return vec2(dot(q, vec2(a, b)) - r1, 4.0);\n}\n\nvec2 leg_five(vec3 p, float ra, float rb, float h)\n{\n    p -= vec3(0.4, 0.5, 0.0);\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return vec2(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb, 5.0);\n}\n\nvec2 leg_six(vec3 p, float ra, float rb, float h)\n{\n    p -= vec3(-0.4, 0.5, 0.0);\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return vec2(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb, 6.0);\n}\n\nvec2 arm_left(vec3 p, float r1, float r2, float h)\n{\n    p -= vec3(0.62, 2.35, 0.0);\n    float PI = 3.1416;\n    // float angle = -PI/12. - PI/12.*sin(iTime);\n    float angle = PI - PI/12. - PI/10.*sin(iTime);\n    p.xy *= mat2( cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    // sampling independent computations (only depend on shape)\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n\n    // sampling dependant computations\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if(k < 0.0)\n        return vec2(length(q) - r1, 0.0);\n    if(k > a * h)\n        return vec2(length(q - vec2(0.0, h)) - r2, 0.0);\n    return vec2(dot(q, vec2(a, b)) - r1, 0.0);\n}\n\nvec2 arm_right(vec3 p, float r1, float r2, float h)\n{\n    p -= vec3(-0.62, 2.35, 0.0);\n    float PI = 3.1416;\n    float angle = PI + PI / 12. + PI/10.*sin(iTime);\n    p.xy *= mat2( cos(angle), -sin(angle), sin(angle), cos(angle));\n\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = dot(q, vec2(-b, a));\n    if(k < 0.0)\n        return vec2(length(q) - r1, 0.0);\n    if(k > a * h)\n        return vec2(length(q - vec2(0.0, h)) - r2, 0.0);\n    return vec2(dot(q, vec2(a, b)) - r1, 0.0);\n}\n\n// sdf scene\nvec2 map(vec3 p)\n{\n    vec2 result = circle_zero(p);\n    // result = add_union(result, plane_one(p));\n    result = add_union(result, circle_two(p));\n    result = add_union(result, circle_three(p));\n    result = add_union(result, roundcore_four(p, 0.92, 0.46, 1.6));\n    result = add_union(result, leg_five(p, 0.2, 0.2, 0.6));\n    result = add_union(result, leg_six(p, 0.2, 0.2, 0.6));\n    result = add_union(result, arm_left(p, 0.18, 0.4, 0.9));\n    result = add_union(result, arm_right(p, 0.18, 0.4, 0.9));\n\n    // blink eyes\n    p.x = abs(p.x);\n    if(mod(iTime - 1.,4.)>.04)\n    {\n        pupdist=(length(p-vec3(0.45, 3.7, -0.98)) - .1);\n        result.x=min(result.x, pupdist);\n    }\n\n    return result;\n}\n\nfloat f(vec3 p)\n{\n    return map(p).x;\n}\n\nvec3 sceneNorm(vec3 p)\n{\n    vec3 e = vec3(1e-2, 0, 0);\n    float d = f(p);\n    return normalize(vec3(f(p + e.xyy) - d, f(p + e.yxy) - d, f(p + e.yyx) - d));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 18;\n    const float delta = 1.5;\n\n    float a = 0.0;\n    float weight = .5;\n    for(int i = 1; i <= steps; i++)\n    {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight * (d - f(p + n * d));\n        weight *= 0.6;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0., 3., -8.);\n    vec3 rd = normalize(vec3(uv, 1.8));\n\n    // Raymarching\n    float t = 4., d = 0.;\n    for(int i = 0; i < 100; ++i)\n    {\n        d = f(ro + rd * t);\n        if(d < 1e-4 || t > 20.)\n            break;\n        t += d;\n    }\n\n    // Directional light\n    float d2 = f(ro + rd * t + normalize(vec3(1, 2, -2)) * 5e-2);\n    float l = .5 + .5 * (d2 - d) / 5e-2;\n    vec3 rp = (ro + rd * t);\n    vec3 n = sceneNorm(rp);\n    // vec3 bcol = vec3(1, .44, .58);\n    vec3 bcol = vec3(1, .1936, .3364); // pink background color\n    vec3 col = bcol;\n\n    if(t < 20.)\n    {\n        vec3 black = vec3(0.);\n        vec3 brown = vec3(252./255., 253./255., 164./255.);\n        col = vec3(mix(black, brown, smoothstep(0.0, .01, pupdist)));\n        col *= l;\n\n        col += pow(clamp(-n.y, 0., 1.), 2.) * bcol / 1.5;\n        if(n.y < .9999)\n            col += pow(clamp(-rp.y - 1.8, 0., 1.), 4.) * vec3(1, .4, .18) / 3.;\n        if(n.y > .99999)\n        {\n            col *= pow(ambientOcclusion(rp, n), 1.);\n            col *= mix(.7, 1., smoothstep(0., 2., length(rp.xz)));\n        }\n        else\n        {\n            vec3 r = reflect(rd, n);\n            col += step(0.5, r.y) * .2 * pow(clamp(0., 1., 1. - dot(-rd, n)), 2.);\n            col *= pow(ambientOcclusion(rp, n), 2.);\n        }\n    }\n    else\n        col = .84 * max(mix(bcol + (.1 - length(uv.xy) / 3.), vec3(1), .1), 0.);\n\n    fragColor.rgb = max(col, 0.);\n    fragColor.rgb = sqrt(fragColor.rgb + .01);\n}\n","name":"Image","description":"","type":"image"}]}