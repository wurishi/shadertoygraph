{"ver":"0.1","info":{"id":"4sdGRn","date":"1447717080","viewed":172,"name":"Dance Party","username":"dirkadirkadan","description":"Hmm","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_ITER 50\n#define MAX_BOUNCES 4\n#define EPS .001\n#define STEP .4\n#define Scale 2.\n#define Offset .3\n#define DIST iMouse.y*.1\n#define FRACT_ITER 9\n#define X_EPS .001\n#define Y_EPS X_EPS\nvec3 mat;\n\nfloat seed = 0.0;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nfloat ground(vec3 p, float height)\n{\n    return p.y - height;//+.2*sin(p.z*3.);\n}\n\nfloat sphere(vec3 p, vec3 center, float radius)\n{\n    return length(p-center) - radius;\n}\n\nfloat column(vec3 p, vec3 center, float height, float radius)\n{\n    return length((p-center).xz)-radius;\n}\n\nfloat fbm(vec2 p)\n{\n    float c = cos(.45);\n    float s = sin(.45);\n    \n    p.x *= .2;\n    \n    mat2 m = mat2(c, -s, s, c);\n    p+=vec2(1.5);\n    \n    float a = 1.5;\n    float f = .132;\n    float l = 7.5;\n    float g = .635;\n    float x = .0;\n    for (int i = 0; i < 7; i++)\n    {\n   \t\tx += a*texture(iChannel0, p*f).r;\n        p *= m * 2.;\n        a *= g;\n        f *= l;\n    }\n    \n    return x;\n}\n\nfloat de(in vec3 p)\n{\n    float s1 = sphere(p, vec3(0., sin(iTime), .0), .5);\n    float orbit_radius = 1.3;\n    float s2_angle = iTime*3.;\n    float s2 = sphere(p, vec3(orbit_radius*cos(s2_angle), \n                              1., orbit_radius*sin(s2_angle)), .5);\n    float f = ground(p, -.7);\n    float c = column(mod(p, 8.)-4., vec3(2.), 5., .5);\n    \n    vec3 scol = vec3(1., .6, .3);\n    \n    vec2 st = sin(3.14159*p.xz/1.);\n    float tile=step(st.x*st.y,0.);\n    vec3 fcol = .5*vec3((tile+1.)* fbm(p.xz));\n    \n    vec3 ccol = vec3(1., 0., 0.);\n\n    float d = min(s1, f);\n    d = min(d, s2);\n    d = min(d, c);\n    float factor = step(f, s1);\n    mat = scol*(1.-factor) + fcol*factor;\n    factor = step(s2, d);\n    mat = mat*(1.-factor) + ccol*factor;\n    factor = step(c, d);\n    mat = mat*(1.-factor) + ccol*factor;\n    return d;\n    \n}\n\nvec3 normal(vec3 p)\n{\n    float d = de(p);\n    \n    float x = de(vec3(p.x+EPS, p.y, p.z)) - d;\n    float y = de(vec3(p.x, p.y+EPS, p.z)) - d;\n    float z = de(vec3(p.x, p.y, p.z+EPS)) - d;\n    \n    return normalize(vec3(x, y, z));\n}\n\nvec3 light(vec3 norm)\n{\n    vec3 light_dir = normalize(vec3(-1.));\n    \n    return vec3(.15)+vec3(1.)*mat*clamp(dot(light_dir, -norm), .0, 1.);\n}\n\nfloat ao(vec3 p, vec3 norm)\n{\n    return .3+clamp(de(p+norm*.2), 0., 1.);   \n}\n\n\nvoid trace(vec3 ro, vec3 rd, inout vec3 col)\n{\n    float tot_d = 0.;\n    float d = 0.;\n    \n    for (int j = 0; j < MAX_BOUNCES; j++)\n    {\n        for (int i = 0; i < MAX_ITER; i++)\n        {\n            vec3 pt = ro+rd*d;\n\n            float s = de(pt);\n            d += STEP*s;\n\n            if (s < EPS)\n            {\n                tot_d += d;\n                vec3 norm = normal(pt);\n                col += light(norm) * ao(pt, norm) * exp(-tot_d*tot_d*.01);\n                rd = reflect(rd, -norm);\n                ro = pt + rd *EPS;\n                d = 0.;\n                break;\n            }\n        }\n       \n        \n    }\n    \n}\n\nvec3 color(vec2 uv)\n{\n    vec3 ro = vec3(0., 0., 1.5+DIST);\n    vec3 rd = normalize(vec3(uv, -1.));\n    \n    vec3 col = vec3(0.);\n\n    trace(ro, rd, col);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy -iResolution.xy)/ iResolution.y;\n\t\n    vec3 c;\n   /* \n    c = color(uv)+\n             color(uv+X_EPS)+\n             color(uv+Y_EPS)+\n             color(uv-X_EPS)+\n             color(uv-Y_EPS);\n    c /= 4.;\n    \n    \n    fragColor = vec4(c,1.);\n    */\n    \n    float gamma = 2.75;\n    c = color(uv);\n    c = pow(c, vec3(gamma));\n    \n    fragColor = vec4(c, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}