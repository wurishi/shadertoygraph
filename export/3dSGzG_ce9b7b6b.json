{"ver":"0.1","info":{"id":"3dSGzG","date":"1549107823","viewed":465,"name":"Shooting Gallery","username":"Flopine","description":"just a use case of my rupees :D Not the best shader I did so far but it's the more complex I think. ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","texture","specular","zelda","fresnel","3pointlighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Cookie Collective rulz\n\n#define ITER 100.\n#define PI 3.141592\n\n#define MAT_FCRYSTAL 0.\n#define MAT_MCRYSTAL 1.\n#define MAT_BCRYSTAL 2.\n#define MAT_BACK 3.\n#define MAT_PEDESTRAL 4.\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\nvec2 mo (vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n    return p;\n}\n\n\nvec2 mat_min (vec2 a, vec2 b)\n{\n\tif (a.x < b.x) return a;\n    else return b;\n}\n\n// iq function for signed hexagone\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat box(vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y, q.z))) + length(max(q,0.));\n}\n\n\nfloat plane (vec3 p, vec3 n, float dist)\n{return dot(p,normalize(n))-dist;}\n\n\nfloat crystal (vec3 p)\n{\n  p.xz *= rot(iTime*2.);\n  float b = box(p, vec3(.5, 0.7, 0.15));\n  p = abs(p);\n  float p1 = plane (p, vec3(0.7,1.,0.7), 0.5);\n  float p2 = plane (p, vec3(1.,0.,0.8), 0.3);\n  float d = max(p2,max(b,p1));\n  return d;\n}\n\n\nvec2 middle_crystal (vec3 p)\n{return vec2(crystal(vec3(p.x, p.y-sin(iTime)*2.-1., p.z-2.)),MAT_MCRYSTAL);}\n\n\nvec2 back_crystals (vec3 p)\n{\n    p.x += sin(iTime*0.2)*8.;\n    p.yz -= vec2(4., 3.);\n    p.x = abs(p.x);\n    p.x -= 1.; \n    return vec2(crystal(p),MAT_BCRYSTAL);\n}\n\n\nvec2 front_crystals (vec3 p)\n{\n    p *= 1.4;\n    p.x = abs(p.x);\n    p.x -= 1.5;\n\tp.yz += vec2(0.5, 3.3);\n    p.xz = abs(p.xz);\n    p.xz -= vec2(0.8,0.6);\n    return vec2(crystal(p)/1.4, MAT_FCRYSTAL);\n}\n\n\nvec2 scenery (vec3 p)\n{\n    vec3 pp = p;\n    p.xy *= rot(PI/6.);\n    float hex = -sdHexPrism(p, vec2(10.));\n    \n    p = pp;\n    p.y += 2.;\n    float g = abs(p.y)-0.5;\n    \n    return vec2(min(hex,g),MAT_BACK);\n}\n\n\nvec2 pedestrals (vec3 p)\n{\n    p.y += 2.;\n    float b1 = box(vec3(p.x,p.y, p.z+4.), vec3(10.,1., 1.));\n    \n    p.z -= 2.;   \n    float b2 = box(vec3(p.x,p.y,p.z), vec3(4.,1.4,2.));    \n    float b3 = max(-box(p, vec3(1.,10.,1.)),box(vec3(p.x, p.y-2., p.z),vec3(1.5,.5,1.5)));\n    return vec2(min(b3,min(b2,b1)), MAT_PEDESTRAL);\n}\n\n\nvec2 SDF (vec3 p)\n{return mat_min(pedestrals(p),mat_min(back_crystals(p),mat_min(front_crystals(p),mat_min(scenery(p), middle_crystal(p)))));}\n\n\nvec3 get_normals (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3( SDF(p+eps.xyy).x-SDF(p-eps.xyy).x,\n                         SDF(p+eps.yxy).x-SDF(p-eps.yxy).x,\n                         SDF(p+eps.yyx).x-SDF(p-eps.yyx).x\n                         )\n                    );\n}\n\n\nvec3 tex (sampler2D chan, vec2 uv)\n{\n    vec3 t = texture (chan, uv).rgb;\n    // apply a gamma correction as I do an inverse gamma at the end\n    t = pow(t,vec3(2.2));\n    return t;\n}\n\n// triplanar mapping without the weights on normals\n// See here for more info : https://catlikecoding.com/unity/tutorials/advanced-rendering/triplanar-mapping/\nvec3 triplanar(vec3 pos, vec3 normal, sampler2D channel, float uvscale) \n{\n    // adding a pixellate effect on the textures\n    float detail = 9.;\n    pos = floor(pos*detail)/detail;\n    \n    vec2 uvx = pos.yz*uvscale;\n    vec2 uvy = pos.xz*uvscale;\n    vec2 uvz = pos.xy*uvscale;\n    vec3 texx = tex(channel,uvx);\n    vec3 texy = tex(channel,uvy)*vec3(0.5,0.8,0.2);\n    vec3 texz = tex(channel,uvz);\n    vec3 blends = abs(normal);\n    return texx*blends.x+texy*blends.y+texz*blends.z;\n}\n\n// iq harmonic palette\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\n\nvec3 front_crystal_color (float id)\n{return palette (id, vec3(0.5), vec3(0.8), vec3(.7), vec3(0.5,0.7,0.1));}\n\n\nvoid crystal_shading (inout vec3 color, vec3 n, vec3 l, vec3 rd)\n{\n    // fresnel\n    float fre = pow(clamp(1.-dot(-rd,n),0.,1.), 4.);\n    color += fre* color*3.;\n    \n    // specular\n    vec3 h = normalize(l-rd);\n    float spe = pow(max(0.,dot(h,n)),7.);\n    color += spe*0.8;\n}\n\n\nvec3 point_light (vec3 p, vec3 n, vec3 lpos, float att)\n{\n  vec3 ldir = normalize(lpos-p);\n  float ldist = length(lpos-p);\n  float dotNL = dot(n , ldir)* 0.5 +0.5;\n  return (vec3(1.,1.,0.7)*dotNL) / (att * ldist * ldist);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.001,1.,-6.); vec3 p = ro;\n    vec3 rd = normalize(vec3(uv,1.));\n    vec3 col = vec3(0.);\n    // tha albedo will change with the material id\n    vec3 alb = vec3(0.);\n    float shad = 0.;\n    \n    for (float i =0.; i<ITER; i++)\n    {\n        vec2 d = SDF(p);\n        if (d.x<0.001)\n        {\n            vec3 normal = get_normals(p);\n            vec3 light = vec3(3., 6., -6.);\n            \n            if (d.y == MAT_FCRYSTAL) \n            {\n                // reaaaaally dirty hack to retrieve a fake id\n                float id = floor(fract((p.x+.19)*0.17)*5.) *0.25;\n                alb = front_crystal_color(id);\n            }\n                \n            if (d.y == MAT_MCRYSTAL) \n            {\n                alb = vec3(0.1,0.4,0.1);\n            }\n            if (d.y == MAT_BCRYSTAL) \n            {\n              alb = vec3(0.5,0.1,0.1);\n            }\n            if (d.y == MAT_BACK) \n            {\n            \talb = triplanar(p,normal, iChannel0, 0.3);    \n            }\n            if (d.y == MAT_PEDESTRAL) \n            {\n            \talb = triplanar(p,normal, iChannel1, 0.5);  \n            }\n            // three-point lighting... kind of\n            col += point_light(p,normal, vec3(-5.,4.,5.), 0.02)*alb;\n            col += point_light(p,normal, vec3(5.,4.,5.), 0.02)*alb;\n            col += point_light(p,normal, vec3(-1.,4.,-1.), 0.04)*alb;\n            \n            // adding specular and fresnel only on crystals\n            if(d.y != MAT_PEDESTRAL && d.y != MAT_BACK)\n            \tcrystal_shading(col, normal, light, rd);\n            \n            // will be use to add fake AO\n            shad = i/ITER;\n            break;\n        } \n        p += d.x*rd;\n    }\n    \n    // Fake AO\n    col *= 1.-shad;\n    \n    // fog\n    float t = length(ro-p);\n    col = mix(col, vec3(0.3,0.2,0.2), 1.-exp(-0.006*t*t));\n\n    fragColor = vec4(pow(col, vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"}]}