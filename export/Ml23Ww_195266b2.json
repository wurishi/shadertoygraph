{"ver":"0.1","info":{"id":"Ml23Ww","date":"1429650000","viewed":186,"name":"clothoid S","username":"joeedh","description":"fresnel root finder thingy","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["clothoids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define STEPS 14\n\nvec2 f(float s1) {\n    float s = 0.0, ds = s1/float(STEPS);\n    float ds2=ds*ds, ds3=ds2*ds;\n    vec2 ret = vec2(0, 0);\n    float t = fract(iTime), t2;\n    t = abs(t-0.5)*0.2+0.75;\n    t2 = t*2.0;\n    \n    for (int i=0; i<STEPS; i++) {\n        float th = s*s*t, sinth=sin(th), costh = cos(th);\n        float th2=th*th;\n        \n        //4rd-order taylor approximation\n        \n        ret[0] += sinth + costh*s*t*ds + \n             0.1666666*(t2*(costh - 2.0*sinth*th))*ds2 -\n             0.0416666*4.0*(2.0*costh*th + 3.0*sinth)*s*t*t*ds3;\n        ret[1] += costh - sinth*s*t*ds -\n            2.0*t*(0.1666666)*(2.0*costh*th + sinth)*ds2 - \n            0.0416666*4.0*(3.0*costh-2.0*sinth*th)*s*t*t*ds3;\n        s += ds;\n    }\n    \n    return ret*ds;\n}\n/* reduce script, see http://reduce-algebra.sourceforge.net/\n\noperator isin, icos;\n\nforall s let df(isin(s), s) = sin(s**2);\nforall s let df(icos(s), s) = cos(s**2);\n\ndf((isin(s)-x)**2 + (icos(s)-y)**2, s);\ndf(sqrt((isin(s)-x)**2 + (icos(s)-y)**2), s);\n\n*/\n#define DF 0.05\n\nvec2 rot2d(vec2 v, float a) {\n    return vec2(\n      v[1]*sin(a) + v[0]*cos(a),\n      -v[0]*sin(a) + v[1]*cos(a)\n    );\n}\n\nfloat sample1(vec2 uv) {\n\tfloat size = max(iResolution.x, iResolution.y);\n    float x=0.0, y=0.0;\n    \n    float s = 0.4, d=0.0, g=0.0, div=0.0, d2;\n    vec2 r, r2;\n    float t = sin(iTime*6.0)*0.5 + 0.5;\n    \n    t = t*0.5 + 0.5;\n    t *= 1.0;\n    for (int i=0; i<50; i++) {\n        r = f(s);\n        d = length(r - uv);\n        \n        g = cos(s*s)*r[1] - cos(s*s)*uv[1] + r[0]*sin(s*s) - sin(s*s)*uv[0];\n        div = sqrt(r[1]*r[1] - 2.0*r[1]*uv[1] + r[0]*r[0] - 2.0*r[0]*uv[0] \n                         + uv[0]*uv[0] + uv[1]*uv[1]);\n        g = g / div;\n        //r2 = f(s+DF);\n        \n        //d2 = length(r2-uv);\n        //g = (d2-d)/DF;\n        \n        float fac = 1.0;//abs(3.0 - s)/6.0 + 0.5;\n        s += -d*(g)*0.5*fac;\n        //s = min(max(s, 0.0), 3.0);\n    }    \n    \n    d = 1.0-d;\n    float th = 0.8+(1.0-abs(s)*0.5)*0.05;\n    d = smoothstep(th, th+0.18, d);\n\treturn d;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float size = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy / size;\n    float x=0.0, y=0.0;\n    \n    uv[0] -= 0.5;\n    uv[1] -= 0.3;\n    uv *= 5.0;\n    uv[1] *= 1.4;\n    \n    float s1 = sin(iTime*10.0+(uv[0]*uv[1])*5.0);\n    uv[0] += s1*0.015;\n    uv[1] += s1*0.015;\n    \n    uv = rot2d(uv, 0.6);\n    float d = sample1(uv);\n    //vec2 uv2 = vec2(-uv[0], uv[1])*1.5;\n    //float d2 = sample(uv2);\n    \n    //d = max(d, d2);\n\tfragColor = vec4(d, d, d, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}