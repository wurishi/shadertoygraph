{"ver":"0.1","info":{"id":"3sX3zB","date":"1546636048","viewed":137,"name":"Fake light source","username":"cacheflowe","description":"Just tinkering with fake shadows","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["light","directional"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float luma(vec4 rgba) {\n\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgba.xyz, W);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // get original color\n    vec4 texColor = texture(iChannel0, uv);\n    float texLuma = luma(texColor);\n    \n    // move light direction\n    float lightDirRads = iTime * 1.;\n    float sampleDist = 1.;\n    vec2 mouseCenteredNorm = iMouse.xy/iResolution.xy - 0.5;\n    if(iMouse.z > 0.) {\n    \tlightDirRads = atan(mouseCenteredNorm.y, mouseCenteredNorm.x);\n        sampleDist = length(mouseCenteredNorm);\n    }\n    \n    // get gradient of luma influence\n    // emission style \n    /*\n    float sampleStepDist = 0.004;\n    int samples = 10;\n    float lumaAdjust = 0.;\n    for(int i=0; i < samples; i++) {\n        float stepDist = sampleStepDist * float(i);\n        vec2 stepOffset = vec2(cos(lightDirRads) * stepDist, sin(lightDirRads) * stepDist);\n    \tvec4 stepColor = texture(iChannel0, uv + stepOffset);\n    \tfloat stepLuma = luma(stepColor);\n        float sampleAmp = 1. - float(i) / float(samples);\t// less influence further away\n\t\tif(stepLuma > texLuma) lumaAdjust += stepLuma * sampleAmp;\t// only adjust luma upwards\n        else lumaAdjust += texLuma * sampleAmp;\n    }\n    lumaAdjust = lumaAdjust / float(samples) * 3.;\n    fragColor = texColor * lumaAdjust;\n\t*/\n       \n    // fake bump map style\n    float thresh = 5.;\n    float sampleStepDist = 0.001 * sampleDist; //0.002;\n    int samples = 20;\n    float lumaAdjust = 0.;\n    float distToThresh = 0.;\n    for(int i=0; i < samples; i++) {\n        if(lumaAdjust < thresh) {\n            float stepDist = sampleStepDist * float(i);\n            vec2 stepOffset = vec2(cos(lightDirRads) * stepDist, sin(lightDirRads) * stepDist);\n            vec4 stepColor = texture(iChannel0, uv + stepOffset);\n            float stepLuma = luma(stepColor);\n            float lumaDiff = (texLuma - stepLuma);\n            lumaAdjust += lumaDiff * 5.;\n            distToThresh += 1.;\n        }\n    }\n    float distMultiplier = 1. / distToThresh;\n    lumaAdjust = lumaAdjust / float(samples) * distMultiplier * 5.;//0.25;\n    if(lumaAdjust > texLuma) lumaAdjust *= -1.;\n    fragColor = mix(texColor, texColor + lumaAdjust, 0.55);// (lumaAdjust - texLuma);\n\t\n\n    // Compare with original\n    // if(uv.x > 0.5 + 0.0002 * sin(iTime)) fragColor = texColor;\n}","name":"Image","description":"","type":"image"}]}