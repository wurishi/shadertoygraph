{"ver":"0.1","info":{"id":"4dV3zh","date":"1453307261","viewed":205,"name":"Day 000 - Simple Raytracer","username":"mwalczyk","description":"Day 000 - Simple Raytracer","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"vec4 mainSphere = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec3 sphereColor = vec3(0.85, 0.1, 0.2);\nconst vec3 backgroundColor1 = vec3(0.4, 0.15, 0.85);\nconst vec3 backgroundColor2 = vec3(0.1, 0.15, 0.65);\nvec3 lightPos = vec3(2.0, 2.0, -3.0);\n\nfloat iSphere(in vec3 ray,\n              in vec3 dir,\n              in vec4 sphere)\n{\n    // A point is on a sphere if: \t\n    //\t\t\t(point - center) = r^2.\n    // A point is on a ray if: \t\t\n    //\t\t\tpoint = ro + rd * t, for some t > 0.\n    // So, we want to solve for t where in the equation:\n   \t//\t\t\t((ro + rd * t) - center)^2 = r^2\n    \n\tvec3 rc = ray - sphere.xyz;\n    float c = dot(rc, rc) - (sphere.w * sphere.w);\n    float b = dot(dir, rc);\n    float d = b * b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step(0.0, min(t, d));\n    return mix(-1.0, t, st);\n}\n\nvec3 nSphere(in vec3 pos,\n             in vec4 sphere)\n{\n\treturn normalize((pos - sphere.xyz) / sphere.w);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    // First, generate a UV coordinate for this fragment.\n    // Then, remap it to [-1, 1] and scale by the aspect \n    // ratio of the window.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (2.0 * uv - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\t\n    // Move some stuff around.\n    mainSphere.x += cos(iTime);\n    mainSphere.z += sin(iTime);\n    lightPos.x *= (sin(iTime * 2.0) + 1.0) / 2.0;\n    \n    vec3 ro = vec3(0.0, 0.0, -3.0);\t\t// Ray origin\n    vec3 rd = normalize(vec3(uv, 1.0));\t// Ray direction\n    \n    // Calculate the point of intersection.\n\tfloat t = iSphere(ro, rd, mainSphere);\n    vec3 pos = ro + rd * t;\n    \n    // Calculate the normal at the point of intersection.\n    vec3 normal = nSphere(pos, mainSphere);\n    \n    // Calculate the per-fragment diffuse color.\n    vec3 eye = lightPos - pos;\n    float diffIntensity = max(dot(eye, normal), 0.3);\t// Soften the shadow.\n    vec3 diffColor = diffIntensity * sphereColor;\n    \n    float distToCenter = distance(uv, vec2(0.5));\n    vec3 backgroundGrad = mix(backgroundColor1, backgroundColor2, distToCenter);\n    \n    vec3 finalColor = mix(backgroundGrad, diffColor, step(0.0, t));\n    \n    fragColor = vec4(finalColor, 1.0 );\n}","name":"","description":"","type":"image"}]}