{"ver":"0.1","info":{"id":"7l3SRB","date":"1639315106","viewed":538,"name":"[TDF2021] Reflecting Crystals","username":"Kamoshika","description":"25 minutes live coding @Tokyo Demo Fest 2021 Shader Showdown Semifinals\n\nTokyo Demo Fest 2021\nhttps://tokyodemofest.jp/","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","livecoding","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Watch the recording of the live coding on YouTube.\n// https://youtu.be/bp37xTVNRrM?t=6125\n\n// Added spaces, comments, etc. to the code.\n\n#define time iTime\n#define saturate(x) clamp(x, 0., 1.)\n\n// Rotate by 45 degrees.\n#define rotpi4(v) v = vec2(v.x + v.y, -v.x + v.y) / sqrt(2.)\n\nconst float pi = acos(-1.);\n\n// Rotation matrix in two dimensions.\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n#define odd(x) step(1., mod(x, 2.))\n// Square wave.\nfloat sqWave(float x) {\n    float i = floor(x);\n    float s = 0.1;\n    return mix(odd(i), odd(i + 1.), smoothstep(0.5 - s, 0.5 + s, fract(x)));\n}\n\n// Smooth minimum.\n// reference:\n// https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n    return min(a, b) - h * h * 0.25 / k;\n}\n\nvec3 pos; // Position of gyroid sphere.\n// Distance function used for raymarching.\nfloat map(vec3 p) {\n    float d;\n    //d = length(p) - 0.3;\n    vec3 q = p;\n    q.y = 0.7 - abs(q.y);\n    \n    d = q.y;\n    q.zx = fract(q.zx) - 0.5; // Repetition in zx-plane.\n    \n    vec2 dq = mix(vec2(-0.2), vec2(0.27, 0.1), sqWave(time * 0.15)); // Movement of the branches.\n    float a = 1.;\n    for(int i = 0; i < 5; i++) { // IFS.\n        vec3 v = q;\n        v.zx = abs(v.zx);\n        if(v.z > v.x) v.zx = v.xz;\n        d = min(d, max(v.x - 0.1, (v.x * 2. + v.y) / sqrt(5.) - 0.3) / a);\n        q.zx = abs(q.zx);\n        rotpi4(q.xz);\n        q.xy -= dq;\n        rotpi4(q.yx);\n        \n        q *= 2.;\n        a *= 2.;\n    }\n    \n    // Add a gyroid sphere.\n    q = p - pos;\n    float t = length(q) - 0.3;\n    q *= 15.;\n    q.xy *= rot(time * 1.3);\n    q.yz *= rot(time * 1.7);\n    t = max(t, (abs(dot(sin(q), cos(q.yzx))) - 0.2) / 15.);\n    d = smin(d, t, 0.3);\n    \n    return d;\n}\n\n// Calculate normal vector.\nvec3 calcN(vec3 p) {\n    vec2 e = vec2(0.001, 0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Trasform HSV color to RGB.\nvec3 hsv(float h, float s, float v) {\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.) * 6. - 3.;\n    res = saturate(abs(res) - 1.);\n    res = (res - 1.) * s + 1.;\n    res *= v;\n    return res;\n}\n\n// Raymarching.\nvec3 march(inout vec3 rp, inout vec3 rd, inout vec3 ra, inout bool hit) {\n    vec3 col = vec3(0);\n    float d;\n    float t=0.;\n    hit = false;\n    for(int i = 0; i < 100; i++) {\n        d = map(rp + rd * t);\n        if(abs(d) < 0.0001) {\n            hit = true;\n            break;\n        }\n        t += d;\n    }\n    rp += t * rd;\n    \n    vec3 ld = normalize(-rp); // Light direction.\n    \n    vec3 n = calcN(rp); // Normal vector.\n    vec3 ref = reflect(rd, n); // Reflection vector.\n    \n    float diff = max(dot(ld, n), 0.); // Diffuse.\n    float spec = pow(max(dot(reflect(ld, n), rd), 0.), 20.); // Specular.\n    float fog = exp(-t * t * 0.2);\n    \n    d = length(rp - pos) - 0.3;\n    float mat = smoothstep(0.01, 0.1, d); // Material parameter. 0.0: gyroid sphere  1.0:crystal\n    float phase = length(rp) * 4. - time * 2.; // Phase of color changing.\n    vec3 al = hsv(floor(phase / pi) * pi * 0.4, 0.8, 1.); // Albedo.\n    al = mix(vec3(0.9), al, mat);\n    float f0 = mix(0.01, 0.8, mat); // Fresnel factor when the reflection vector is parallel to the normal vector.\n    float m = mix(0.01, 0.9, mat); // Metalness.\n    float fs = f0 + (1. - f0) * pow(1. - dot(ref, n), 5.); // Schlick's approximation of Fresnel factor.\n    float lp = 3. / abs(sin(phase)); // Light Power.\n    \n    col += al * diff * (1. - m) * lp; // Diffuse reflection of direct light.\n    col += al * spec * m * lp; // Specular reflection of direct light.\n    col = mix(vec3(0), col, fog); // Black Fog.\n    \n    col *= ra; // Reflection attenuation.\n    \n    // Update variables for next reflection.\n    ra *= al * fs * fog;\n    rp += 0.01 * n;\n    rd = ref;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalization of coordinates.\n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1) * 0.5;\n    \n    pos = sin(vec3(13, 0, 7) * time * 0.1); // Move the gyroid sphere.\n    \n    vec3 col = vec3(0); // Color.\n    \n    vec3 ro = vec3(0, -0.3, 1.9); // Ray origin.\n    ro.zx *= rot(time * 0.1);\n    \n    vec3 rd = normalize(vec3(uv, -2)); // Ray direction.\n    rd.zx *= rot(time * 0.1);\n    \n    vec3 ra = vec3(1); // Reflection attenuation.\n    bool hit = false; // Whether the ray hit any object or not.\n    \n    col += march(ro, rd, ra, hit);\n    if(hit) col += march(ro, rd, ra, hit); // 1st reflection.\n    if(hit) col += march(ro, rd, ra, hit); // 2nd reflection.\n    \n    // Gamma correction.\n    col = pow(col, vec3(1. / 2.2));\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}