{"ver":"0.1","info":{"id":"X3fBD7","date":"1728449444","viewed":34,"name":"Lorenz System","username":"blayman","description":"Lorenz System using RK4.:\n\nhttps://en.wikipedia.org/wiki/Lorenz_system\nhttps://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods\n\nThis is displaying the xz coordinates, along with some bloom/blur in the background.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["lorenz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 lorenz(vec3 xyz)\n{\n    // Define constants\n    float sigma = 10.0;\n    float rho = 28.0;\n    float beta = 8.0 / 3.0;\n    \n    // --------The Lorenz System ODEs--------\n    // dx/dt = sigma*(y-x)\n    // dy/dt = x*(rho-z)-y\n    // dz/dt = x*y-beta*z\n    \n    float dx = sigma*(xyz.y - xyz.x);\n    float dy = xyz.x*(rho - xyz.z) - xyz.y;\n    float dz = xyz.x*xyz.y - beta*xyz.z;\n    \n    return vec3(dx, dy, dz);\n}\n\nvec3 rungeKutta4(vec3 xyz)\n{\n    // Define time step\n    float h = TIMESTEP;\n    \n    vec3 k1 = lorenz(xyz);\n    vec3 k2 = lorenz(xyz+(h/2.0)*k1);\n    vec3 k3 = lorenz(xyz+(h/2.0)*k2);\n    vec3 k4 = lorenz(xyz+h*k3);\n    \n    // Use calculated k values to determine z_n+1\n    vec3 next = xyz + (h/6.0)*(k1+2.0*k2+2.0*k3+k4);\n    \n    return next;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = int(fragCoord.x) % NUM_POINTS;\n\n    // Initial xyz value\n    vec4 initVal = vec4(1.0,1.0,1.0,1.0);\n    \n    // Sample the buffer for the previous xyz value\n    vec4 texValue = texture(iChannel0, vec2( float(NUM_POINTS-1) / iResolution.x, 0));\n    \n    // Use the initial value on frame 0, otherwise prev value from buffer\n    vec4 inputVal = mix(initVal, texValue, float(iFrame > 0));\n    \n    // Calculate the xyz value using RK4\n    vec3 rk4 = inputVal.xyz;\n    for(int i = 0; i < index % NUM_POINTS; ++i)\n    {\n        rk4 = rungeKutta4(rk4);\n    }\n    \n    fragColor = vec4(rk4, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Helper function to map values from one range to another\nvec2 mapToScreen(vec2 p) {\n    // Map x from DOMAIN_MIN..DOMAIN_MAX to 0..1\n    p.x = (p.x - DOMAIN_MIN) / (DOMAIN_MAX - DOMAIN_MIN);\n    \n    // Map y from RANGE_MIN..RANGE_MAX to 0..1\n    p.y = (p.y - RANGE_MIN) / (RANGE_MAX - RANGE_MIN);\n    \n    return p;\n}\n\nfloat lineDist(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 prevFrame = texture(iChannel0, uv);\n    vec4 color = prevFrame;\n    \n    vec3 lineColor = vec3(0.0, (1.0+sin(5.0*iTime))/2.0, 0.8);\n    \n    for(int i = 0; i < NUM_POINTS - 1; i++) {\n        vec2 p1 = texture(iChannel1, vec2( float(i) / iResolution.x, 0)).xz;\n        vec2 p2 = texture(iChannel1, vec2( float(i + 1) / iResolution.x, 0)).xz;\n        \n        // Map the points to screen space (0 to 1)\n        p1 = mapToScreen(p1);\n        p2 = mapToScreen(p2);\n        \n        float d = lineDist(uv, p1, p2);\n        \n        float lineThickness = LINE_THICKNESS;\n        color.rgb = mix(lineColor, color.rgb, clamp(pow(d, 0.025)/lineThickness, 0.0, 1.0));\n    }\n    \n    color.rgb *= 0.999;  // Fade effect\n    \n    fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// NUM_POINTS must be 2 or greater\n#define NUM_POINTS 100\n#define TIMESTEP 0.001\n\n#define DOMAIN_MIN -25.0\n#define DOMAIN_MAX 25.0\n\n#define RANGE_MIN 0.0\n#define RANGE_MAX 50.0\n\n#define LINE_THICKNESS 0.9\n","name":"Common","description":"","type":"common"}]}