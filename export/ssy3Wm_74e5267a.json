{"ver":"0.1","info":{"id":"ssy3Wm","date":"1675076685","viewed":83,"name":"Creek","username":"Peetu","description":"Gig backdrop I did for my band Mantella","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.0001;\nconst float end = 100.0;\nconst float start = 0.01;\nconst float PI = 3.14159265359;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat c = .68;\n\nfloat layeredNoise(vec2 st) {\n \tfloat value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    for (int i = 0; i < 7; i++) {\n        value += amplitude * abs(texture(iChannel0, st*.15).r);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat waterH = -.2;\nvec4 sceneSDF(vec3 p) {\n    float height = layeredNoise(p.xz * .05) * 1.3;\n    height *= sin(p.x + cos(p.z));\n\n    if(height < waterH && p.x > 0.6 && p.x < 10.)\n    {\n        float d = p.y - waterH;\n        vec3 col = vec3(0.05, 0.2, 0.2);\n        col /= abs(sin(2. * iTime + p.z * 10. + sin(p.x * 10.))) * 2.;\n        col = min(vec3(1.), col);\n        col *= 0.03;\n        col += vec3(0.05, 0.2, 0.2);\n        return vec4(col, d);\n    } else {\n        float d = p.y - height;\n        return vec4(vec3(0.1, 0.1, 0.1), d);\n    }\n}\n\nmat3 rotationMatrixY(float rad) {\n    return mat3(\n        vec3(cos(rad), 0.0, sin(rad)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(rad), 0.0, cos(rad))\n    );\n}\n\nmat3 rotationMatrixX(float rad) {\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(rad), -sin(rad)),\n        vec3(0.0, sin(rad), cos(rad))\n    ); \n}\n\nmat3 rotationMatrixZ(float rad) {\n    return mat3(\n        vec3(cos(rad), -sin(rad), 0.0),\n        vec3(sin(rad), cos(rad), 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nvec4 rayMarch(vec3 eye, vec3 rayDir) {\n    float depth = start;\n    for(int i = 0; i < 255; i++) {\n   \t\tvec4 data = sceneSDF(eye + rayDir * depth);\n        float dist = data.w;\n        \n        if(dist < EPSILON){\n \t      \treturn vec4(data.xyz, depth);   \n        }else if(depth >= end) {\n        \treturn vec4(vec3(0.0), end);   \n        }\n        \n        depth += dist * 0.5;\n    }\n    return vec4(vec3(0.0), end);\n}\n\nvec3 estimateNormal(vec3 p) {\n    float E = 0.1;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + E, p.y, p.z)).w - sceneSDF(vec3(p.x - E, p.y, p.z)).w,\n        sceneSDF(vec3(p.x, p.y + E, p.z)).w - sceneSDF(vec3(p.x, p.y - E, p.z)).w,\n        sceneSDF(vec3(p.x, p.y, p.z + E)).w - sceneSDF(vec3(p.x, p.y, p.z - E)).w\n    ));\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float t = iTime * 0.1;\n    float rSine = sin(-iTime * .2) * .5;\n    \n\tmat3 rot = rotationMatrixY(rSine) * rotationMatrixX(0.3);\n    \n    vec3 eye = vec3(5. + sin(iTime * .2) * 3., 1.5, 5. - iTime);\n    vec3 rayDir = rot * rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec4 data = rayMarch(eye, rayDir);\n    float depth = data.w;\n    \n    vec3 col;\n   \n   \tif(depth >= end - EPSILON) {\n    \tcol = vec3(0.);\n    }else{\n        vec3 normal = estimateNormal(eye + depth * rayDir);\n        vec3 light = vec3(-1.0, -.4, .9) * rotationMatrixY(0.5);\n        float diffuse = clamp(dot(normal, -light), 0.0, 1.0) * .8;\n        \n        vec3 viewDir = normalize(-rayDir);\n\t\tvec3 reflectDir = reflect(light, normal);  \n        float specular = pow(max(dot(viewDir, reflectDir) * .75, 0.0), 8.) * .5;\n        float i = 0.1 + diffuse + specular;\n        col = data.xyz * i;\n    }\n       \n    fragColor = vec4(col * 1.3,1.0);\n\n}","name":"Image","description":"","type":"image"}]}