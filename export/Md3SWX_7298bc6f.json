{"ver":"0.1","info":{"id":"Md3SWX","date":"1461743641","viewed":226,"name":"Pi Train Integer Test","username":"mzadami","description":"Test code for integer arithmetic extracted from Pi Train: https://www.shadertoy.com/view/MdtXWj\n\nIf your WebGL implementation supports ints, then you'll see green digits of pi all the way down.\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["pi","integer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ============================================================================================\n//\n// ShaderToy test of integer maths working in your WebGL implementation for Fabrice\n//\n// Works out a single base 10 digit of pi using a lovely formula I discovered which\n// has a nice base-10 feel to it!\n//\n// pi/4 = 7/10 + 22/200 - 52/3000 - 312/40000 + 2/5000000 + 2852/6000000 + ...\n//\n// The nth term is given by ImaginaryPart[3(3i+1)^n - (2i-1)^n] / n10^n\n//\n\nconst int POW10_PER_COMPONENT\t= 7;\nconst int BASE_FOR_NUMBER\t\t= 10000000;\nconst int MAX_DIGIT\t\t\t\t= 60;\nconst int MAX_1OVER3_TERMS\t\t= 122;\nconst int MAX_2OVER11_TERMS\t\t= 93;\n\nbool IsZero(ivec4 lo)\n{\n\treturn lo.x == 0 && lo.y == 0 && lo.z == 0 && lo.w == 0;\n}\n\n// Returns +1(a>b), 0, -1(a<b)\nint CompareAbsValues(ivec4 a, ivec4 b)\n{\n\tif (a.w > b.w) {return +1;}\n\tif (a.w < b.w) {return -1;}\n\t\t\n\tif (a.z > b.z) {return +1;}\n\tif (a.z < b.z) {return -1;}\n\n\tif (a.y > b.y) {return +1;}\n\tif (a.y < b.y) {return -1;}\n\n\tif (a.x > b.x) {return +1;}\n\tif (a.x < b.x) {return -1;}\n\n\treturn 0;\n}\n\nvoid DivMod(int a, int b, out int out_div, out int out_mod)\n{\n\tif (a == 0)\n\t{\n\t\tout_div = 0;\n\t\tout_mod = 0;\n\n\t\treturn;\n\t}\n\n\tout_div = a / b;\n\tout_mod = a - out_div * b;\n}\n\nint Mod(int a, int b)\n{\n\tint div = a / b;\n\tint mod = a - b * div;\n\n\treturn mod;\n}\n\nivec4 Div(ivec4 a, int divisor, out int out_mod)\n{\n\tivec4 ans = a;\n\n\tif (ans.w != 0)\n\t{\n\t\tint div_w;\n\t\tint mod_w;\n\n\t\tDivMod(ans.w, divisor, div_w, mod_w);\n\n\t\tans.w  = div_w;\n\t\tans.z += mod_w * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.z != 0)\n\t{\n\t\tint div_z;\n\t\tint mod_z;\n\n\t\tDivMod(ans.z, divisor, div_z, mod_z);\n\n\t\tans.z  = div_z;\n\t\tans.y += mod_z * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.y != 0)\n\t{\n\t\tint div_y;\n\t\tint mod_y;\n\n\t\tDivMod(ans.y, divisor, div_y, mod_y);\n\n\t\tans.y  = div_y;\n\t\tans.x += mod_y * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.x != 0)\n\t{\n\t\tint div_x;\n\t\tint mod_x;\n\n\t\tDivMod(ans.x, divisor, div_x, mod_x);\n\n\t\tans.x = div_x;\n\n\t\tout_mod =  mod_x;\n\t}\n\telse\n\t{\n\t\tout_mod = 0;\n\t}\n\n\treturn ans;\n}\n\nivec4 Double(ivec4 a)\n{\n\tivec4 ans = a + a;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\t}\n\n\treturn ans;\n}\n\nivec4 Treble(ivec4 a)\n{\n\tivec4 ans = a + a + a;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\n\t\tif (ans.x >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.x -= BASE_FOR_NUMBER;\n\t\t\tans.y += 1;\n\t\t}\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\n\t\tif (ans.y >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.y -= BASE_FOR_NUMBER;\n\t\t\tans.z += 1;\n\t\t}\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\n\t\tif (ans.z >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.z -= BASE_FOR_NUMBER;\n\t\t\tans.w += 1;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nivec4 Add(ivec4 a, ivec4 b)\n{\n\tivec4 ans = a + b;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\t}\n\n\treturn ans;\n}\n\n// a must be > b\nivec4 Sub(ivec4 a, ivec4 b)\n{\n\tivec4 ans = a - b;\n\n\tif (ans.x < 0)\n\t{\n\t\tans.x += BASE_FOR_NUMBER;\n\t\tans.y -= 1;\n\t}\n\n\tif (ans.y < 0)\n\t{\n\t\tans.y += BASE_FOR_NUMBER;\n\t\tans.z -= 1;\n\t}\n\n\tif (ans.z < 0)\n\t{\n\t\tans.z += BASE_FOR_NUMBER;\n\t\tans.w -= 1;\n\t}\n\n\treturn ans;\n}\n\nivec4 Add(ivec4 a, bool aneg, ivec4 b, bool bneg, out bool out_a_plus_b_neg)\n{\n\tif (aneg == bneg)\n\t{\n\t\tout_a_plus_b_neg = aneg;\n\n\t\treturn Add(a,b);\n\t}\n\n\t// Signs are different.\n\tint sign = CompareAbsValues(a,b);\n\n\tif (sign == 0)\n\t{\n\t\tout_a_plus_b_neg = false;\n\n\t\treturn ivec4(0,0,0,0);\n\t}\n\n\tif (sign < 0)\n\t{\n\t\tout_a_plus_b_neg = bneg;\n\t\t\t\n\t\treturn Sub(b,a);\n\t}\n\n\tout_a_plus_b_neg = aneg;\n\n\treturn Sub(a,b);\n}\n\n// Divides by BASE_FOR_NUMBER.\nvoid ApplyShift(out ivec4 a)\n{\n\ta.x = a.y;\n\ta.y = a.z;\n\ta.z = a.w;\n\ta.w = 0;\n}\n\t\n// Return Frac(10^power * Abs(num)/denom)\nfloat GetFractionalPart(ivec4 numerator, int denominator, int power_of_ten)\n{\n\tif (power_of_ten >= 0)\n\t{\n\t\tint m;\n\t\tDiv(numerator, denominator, m);\n\n\t\tconst int MAX_ITERS = MAX_DIGIT / POW10_PER_COMPONENT;\n\n\t\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t\t{\n\t\t\tif (power_of_ten < POW10_PER_COMPONENT)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tm *= BASE_FOR_NUMBER;\n\t\t\tm  = Mod(m, denominator);\n\n\t\t\tpower_of_ten -= POW10_PER_COMPONENT;\n\n\t\t\tif (m == 0)\n\t\t\t{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\n\t\tif (power_of_ten >= 4) {m = Mod(10000 * m, denominator); power_of_ten -= 4;}\n\t\tif (power_of_ten >= 2) {m = Mod(100   * m, denominator); power_of_ten -= 2;}\n\t\tif (power_of_ten >= 1) {m = Mod(10    * m, denominator); power_of_ten -= 1;}\n\t\t\t\n\t\treturn float(m) / float(denominator);\n\t}\n\n\tconst int NUM_POWERS_OF_10_TO_KEEP = 4;\n\n\t// Throw away terms we don't need.\n\tconst int MAX_ITERS = MAX_DIGIT / POW10_PER_COMPONENT;\n\n\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t{\n\t\tif (power_of_ten + POW10_PER_COMPONENT > -NUM_POWERS_OF_10_TO_KEEP)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tApplyShift(numerator);\n\n\t\tif (IsZero(numerator))\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tpower_of_ten += POW10_PER_COMPONENT;\n\t}\n\n\t// Divide by the denominator to get the fractional part in the wrong place...\n\tint the_mod;\n\n\tnumerator = Div(numerator, denominator, the_mod);\n\t\t\n\tfloat ans = float(the_mod) / float(denominator);\n\n\t// We can't divide by more than 100 at a time.\n\tconst int MAX_DIV100_ITERS = (NUM_POWERS_OF_10_TO_KEEP + POW10_PER_COMPONENT) / 2;\n\n\tfor (int iter = 0; iter < MAX_DIV100_ITERS; iter++)\n\t{\n\t\tif (power_of_ten > -2)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tnumerator = Div(numerator, 100, the_mod);\n\n\t\tans += float(the_mod);\n\t\tans *= 0.01;\n\n\t\tpower_of_ten += 2;\n\t}\n\n\t// And one more if required.\n\tif (power_of_ten == -1)\n\t{\n\t\tnumerator = Div(numerator, 100, the_mod);\n\n\t\tans += float(the_mod);\n\t\tans *= 0.1;\n\t}\n\n\treturn fract(ans);\n}\n\n// Im((2i - 1)^n) / (10^n n)\nfloat GetNthDigitOfSpiral2(int nth_digit)\n{\n\tint\t\tnum_terms\t= 8 + (MAX_2OVER11_TERMS-8) * nth_digit / (MAX_DIGIT-1);\n\tint\t\tshift\t\t= 0;\n\tfloat\tsum\t\t\t= 0.0;\n\n\tivec4 re = ivec4(1,0,0,0); bool re_neg = true;\n\tivec4 im = ivec4(2,0,0,0); bool im_neg = false;\n\n\tfor (int term = 1; term < MAX_2OVER11_TERMS; term++)\n\t{\n\t\tint shifted_digit = nth_digit - term + shift;\n\n\t\tfloat f = GetFractionalPart(im, term, shifted_digit);\n        \n\t\tif (im_neg)\n\t\t{\n\t\t\tsum -= f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += f;\n\t\t}\n\n\t\tif (im.w*3 < 0 ||\n\t\t\tre.w*3 < 0)\n\t\t{\n\t\t\tint mod;\n\n\t\t\tim = Div(im,10,mod);\n\t\t\tre = Div(re,10,mod);\n\n\t\t\tshift += 1;\n\t\t}\n\n\t\tbool new_re_neg;\n\t\tbool new_im_neg;\n\n\t\tivec4 new_re = Add(Double(im), !im_neg, re, !re_neg, new_re_neg);\n\t\tivec4 new_im = Add(Double(re),  re_neg, im, !im_neg, new_im_neg);\n\n\t\tre = new_re; re_neg = new_re_neg;\n\t\tim = new_im; im_neg = new_im_neg;\n\n\t\tif (term == num_terms)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsum = sum - floor(sum);\n\n\treturn sum;\n}\n\n// Im((3i + 1)^n) / (10^n n)\nfloat GetNthDigitOfSpiral3(int nth_digit)\n{\n\tint\t\tnum_terms\t= 8 + (MAX_1OVER3_TERMS-8) * nth_digit / (MAX_DIGIT-1);\n\tint\t\tshift\t\t= 0;\n\tfloat\tsum\t\t\t= 0.0;\n\n\tivec4 re = ivec4(1,0,0,0); bool re_neg = false;\n\tivec4 im = ivec4(3,0,0,0); bool im_neg = false;\n\n\tfor (int term = 1; term < MAX_1OVER3_TERMS; term++)\n\t{\n\t\tint shifted_digit = nth_digit - term + shift;\n\n\t\tfloat f = GetFractionalPart(im, term, shifted_digit);\n\n\t\tif (im_neg)\n\t\t{\n\t\t\tsum -= f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += f;\n\t\t}\n\n\t\tif (im.w*3 < 0 ||\n\t\t\tre.w*3 < 0)\n\t\t{\n\t\t\tint mod;\n\n\t\t\tim = Div(im,10,mod);\n\t\t\tre = Div(re,10,mod);\n\n\t\t\tshift += 1;\n\t\t}\n\n\t\tbool new_re_neg;\n\t\tbool new_im_neg;\n\n\t\tivec4 new_re = Add(Treble(im), !im_neg, re, re_neg, new_re_neg);\n\t\tivec4 new_im = Add(Treble(re),  re_neg, im, im_neg, new_im_neg);\n\n\t\tre = new_re; re_neg = new_re_neg;\n\t\tim = new_im; im_neg = new_im_neg;\n\n\t\tif (term == num_terms)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsum = sum - floor(sum);\n\n\treturn sum;\n}\n\nint GetNthDigitOfPi(int nth_digit)\n{\n\tfloat a = GetNthDigitOfSpiral3(nth_digit);\n\tfloat b = GetNthDigitOfSpiral2(nth_digit);\n\n\tfloat s = 4.0 * (a*3.0-b);\n\n\ts -= floor(s);\n\n\tint digit = int(floor(10.0 * s));\n\n\treturn digit;\n}\n\n// =========================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv\t\t= fragCoord.xy / iResolution.xy;\n    float\taspect\t= float(iResolution.x) / float(iResolution.y);\n\n    uv.y  = 1.0 - uv.y;\n    uv.x *= aspect;\n    uv   *= 10.0;\n    \n    // Scrolling through time...\n    float fdigit = uv.y + max(0.0, (iTime - 2.0) * 0.5);\n    \n    // So we get nice gaps.\n    if (fract(fdigit) < 0.1 || fract(fdigit) > 0.9 || fract(uv.x) < 0.1 || fract(uv.x) > 0.9)\n    {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n    \n    // -1 so we get a 3 first!\n    int digit_to_find\t= int(fdigit) - 1;\n    int nth_digit_of_pi\t= GetNthDigitOfPi(digit_to_find);\n    \n    if (int(uv.x) >= nth_digit_of_pi || digit_to_find >= MAX_DIGIT)\n    {\n        fragColor = vec4(0.1,0.1,0.1,1.0);\n        return;\n\t}\n\n    // Is it correct?\n\tbool correct = false;\n\n\tif (digit_to_find == -1 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find ==  0 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find ==  1 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find ==  2 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find ==  3 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find ==  4 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find ==  5 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find ==  6 && nth_digit_of_pi == 6) {correct = true;}\n\tif (digit_to_find ==  7 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find ==  8 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find ==  9 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find == 10 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 11 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 12 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 13 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 14 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 15 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 16 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 17 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 18 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 19 && nth_digit_of_pi == 6) {correct = true;}\n\tif (digit_to_find == 20 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 21 && nth_digit_of_pi == 6) {correct = true;}\n\tif (digit_to_find == 22 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 23 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 24 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 25 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 26 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 27 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 28 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 29 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 30 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find == 31 && nth_digit_of_pi == 0) {correct = true;}\n\tif (digit_to_find == 32 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 33 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 34 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 35 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 36 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find == 37 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 38 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 39 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find == 40 && nth_digit_of_pi == 6) {correct = true;}\n\tif (digit_to_find == 41 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 42 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 43 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 44 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 45 && nth_digit_of_pi == 3) {correct = true;}\n\tif (digit_to_find == 46 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 47 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find == 48 && nth_digit_of_pi == 1) {correct = true;}\n\tif (digit_to_find == 49 && nth_digit_of_pi == 0) {correct = true;}\n\tif (digit_to_find == 50 && nth_digit_of_pi == 5) {correct = true;}\n\tif (digit_to_find == 51 && nth_digit_of_pi == 8) {correct = true;}\n\tif (digit_to_find == 52 && nth_digit_of_pi == 2) {correct = true;}\n\tif (digit_to_find == 53 && nth_digit_of_pi == 0) {correct = true;}\n\tif (digit_to_find == 54 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 55 && nth_digit_of_pi == 7) {correct = true;}\n\tif (digit_to_find == 56 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 57 && nth_digit_of_pi == 9) {correct = true;}\n\tif (digit_to_find == 58 && nth_digit_of_pi == 4) {correct = true;}\n\tif (digit_to_find == 59 && nth_digit_of_pi == 4) {correct = true;}\n    \n\tif (correct)\n\t{\n\t    fragColor = vec4(0.1,1.0,0.2,1.0);\n\t}\n\telse\n\t{\n\t    fragColor = vec4(0.8,0.3,0.2,1.0);\n\t}\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}