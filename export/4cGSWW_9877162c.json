{"ver":"0.1","info":{"id":"4cGSWW","date":"1715214069","viewed":149,"name":"Fork Origami [318] ","username":"chenxiang","description":"I wanted to try out soft shading like paper, but quickly discovered it looks better with color and looks like bounce lighting!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["shadow","paper","golf","sub512"],"hasliked":0,"parentid":"ctGyWK","parentname":"Origami [318]"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Origami\" by @XorDev\n\n    I wanted to try out soft shading like paper,\n    but quickly discovered it looks better with\n    color and looks like bounce lighting!\n\n    X : X.com/XorDev/status/1727206969038213426\n    Twigl: twigl.app?ol=true&ss=-NjpcsfowUETZLMr_Ki6\n\n    <512 char playlist: shadertoy.com/playlist/N3SyzR\n    Thanks to FabriceNeyret2 for many tricks\n*/\n\n//#define ROT(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define ROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#ifdef UNIFORM_PARAM\n\nuniform int layers; //[1,5,10]\nuniform int rotStep; //[1,4,12]\n\nuniform float gap; //[0.01,0.1,0.2]\nuniform float radius; //[0.01,0.1,0.2]\nuniform float speed; //[1.0,4.0,8.0]\n\n#else\n\nconst int layers = 6;\nconst int rotStep = 4;\n\nconst float gap = 0.1;\nconst float radius = 0.1;\nconst float speed = 4.0;\n\n#endif\n\nvec3 gamma(vec3 c, float g) \n{\n    return vec3(pow(c.r, g), pow(c.g, g), pow(c.b, g)); \n}\n\nfloat sdfRect(vec2 p, float a)\n{\n    vec2 q = abs(p) - a;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0);\n}\n\nfloat sdfRRect(vec2 p, vec2 a, float r)\n{\n    vec2 q = abs(p) - a + r;\n    return length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - r;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 R = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - R) / min(R.x, R.y);\n    vec2 m = (2.0 * iMouse.xy - R) / min(R.x, R.y);\n    \n    float aa = 3.0 / min(R.x, R.y);\n    float tt = iMouse.z > 0.0 ? m.x : iTime;\n    \n    vec3 col = vec3(0.0);\n    for (int n = layers; n > 0; n--)\n    {\n        float i = float(n) * gap;\n\n        //Smoothly rotate 360/rotStep at a time\n        float a = (tt + i) * speed;\n        a -= sin(a);\n        a -= sin(a);\n        a /= float(rotStep);\n\n        //Compute round square SDF\n        vec2 pp = p - ROT(a) * clamp(p * ROT(a), -i, i);\n        //vec2 pp = p - clamp(p, -i, i);\n        \n        //Compute anti-aliased using SDF\n        float d = max(length(pp), radius);\n        float c = smoothstep(0.0, aa, d - radius);\n\n        //Pick layer color\n        vec3 h = sin(i / gap + a + vec3(1, 3, 5)) * 0.2 + 0.7;\n        \n        col = mix(h, col, c);\n        \n        //Soft shading\n        col *= mix(vec3(1), h + 0.5 * c * pp.y / d, radius / d);\n        \n        col = gamma(col, 0.95);\n    }\n\n     fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}