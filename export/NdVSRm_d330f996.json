{"ver":"0.1","info":{"id":"NdVSRm","date":"1634426221","viewed":192,"name":"Winding Number For Segment","username":"yabadabu","description":"Implementation of https://mobile.twitter.com/keenanisalive/status/1448036393012322313","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["windingnumbersegment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implementation of https://mobile.twitter.com/keenanisalive/status/1448036393012322313\n// Complex functions taken from https://www.shadertoy.com/view/fsyXzz\n\n#define PI 3.141592653589\n\nvec2 as_polar(vec2 z){\n    return vec2(\n      length(z),\n      atan(z.y, z.x)\n    );\n}\n\nvec2 c_pow(vec2 v, float p){\n    vec2 z = as_polar(v);\n    return pow(z.x, p) * vec2(cos(z.y * p), sin(z.y * p));\n}\n\nvec2 c_mul(vec2 a, vec2 b){\n    return vec2(\n      a.x * b.x - a.y * b.y,\n      a.x * b.y + a.y * b.x\n    );\n}\n\nvec2 c_div(vec2 a, vec2 b){\n  return vec2(\n    a.x * b.x + a.y * b.y,\n    a.y * b.x - a.x * b.y\n  ) / dot(b, b);\n}\n\nfloat im( vec2 z ) {\n  //return ( atan(z.y, z.x) + PI ) / ( 2.0 * PI );\n  return (( atan(z.y, z.x) / PI ) + 1.0 ) * 0.5;\n}\n\nfloat distanceToLine( vec2 z, vec2 p, vec2 q ) {\n    vec2 pz = z - p;\n    vec2 qz = z - q;\n\n    vec2 pz_over_qz = c_div( pz, qz );\n    vec2 log_pz_over_qz = c_pow( pz_over_qz, 1.0 );\n    float im_z = im( log_pz_over_qz );\n    return im_z;\n}\n\n// Just experimenting\nfloat distanceCurve( vec2 z, vec2 a, vec2 b, vec2 c ) {\n    \n    vec2 az = z - a;\n    vec2 bz = z - b;\n    vec2 cz = z - c;\n    \n    vec2 den = c_mul( az, az );\n    vec2 num = c_mul( bz, cz );\n    \n    vec2 pz_over_qz = c_div( num, den );\n    vec2 log_pz_over_qz = c_pow( pz_over_qz, 1.0 );\n    float im_z = im( log_pz_over_qz );\n    return im_z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 z = fragCoord/iResolution.xy * 2.0 - 1.0;\n    z.x *= iResolution.x / iResolution.y;\n\n    vec2 p0 = vec2(-0.7, 0.4);\n    vec2 q0 = vec2(0.7, 0.4);\n    vec2 p = p0 + vec2( 0, 0.4f * cos(iTime) );\n    vec2 q = q0;\n\n    // The line\n    float alpha = distanceToLine( z, p, q );\n    //float alpha1 = distanceToLine( z, p.yx, q );\n    //float alpha = ( alpha0 + alpha1 ) * 0.5;\n\n    // The Q\n    vec2 a = vec2(-0.4,0.4);\n    vec2 b = vec2(0.,0);\n    vec2 c = vec2(0.5,-0.5);\n    float alpha2 = distanceCurve( z, a, b, c );\n    alpha = alpha2;\n\n    // Add some color\n    vec3 c0 = vec3( 0,0.2,1 );\n    vec3 c1 = vec3( 1,0.7,0 );\n    vec3 col = c0 * alpha + c1 * ( 1.0 - alpha );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}