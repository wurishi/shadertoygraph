{"ver":"0.1","info":{"id":"7dlBRH","date":"1644584229","viewed":68,"name":"X tunnel but colored","username":"grandmaster_xav","description":"lot of color","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","palette","loop","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define iBass 0.5\n#define iTreble 0.5\n#define iMid 0.5\n\n#define PIA_1 vec3(0.9607, 0.545, 0.038)\n#define PIA_2 vec3(0.4039, 0.3882, 0.996)\n#define PIA_3 vec3(0.0863, 0.4863, 0.9725)\n\n#define NEON_NU 3.\nvec3 colors[3];\n\n#define pal(t) (0.5 + 0.5 * cos(6.283 * (t + vec3(0, 1, 2) / 3.)))\n\nvec3 grey_scale(vec3 color, float lerpVal)\n{\n    float greyCol = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n    vec3 grey = vec3(greyCol, greyCol, greyCol);\n    vec3 newColor = mix(color, grey, lerpVal);\n    return newColor;\n}\n\nvec3 holo(vec2 st, float c, vec3 color)\n{\n    float sat = 1.;\n    vec3 tex = vec3(0.0, 0.0, 0.0);\n    vec3 greyTex = grey_scale(tex, 1.);\n    float fres = (1. - dot(vec3(1.), normalize(-vec3(1.4 - c)))) * 3.;\n    vec3 irid = pal(c + fres * greyTex);\n    vec3 col = color + grey_scale(irid , 1. - sat) * c * 0.55;\n    return (col);\n}\n\nfloat neon_map(vec2 st, vec2 factor)\n{\n    vec2 g = st - factor;\n    // abs for reflection on each segment\n    // max between x and y stop the neon at y\n    // 0.1 to saturate the intensity\n    return (0.03 / max(abs(g.x), g.y));\n}\n\nfloat p(vec2 st, vec2 n)\n{\n    float neon = 0.;\n    st += n;\n    for (float i=0.1; i<1.;i+=0.2)\n        neon += neon_map(st, vec2(i, -i * 0.1));\n    for (float i=0.1; i<0.3;i+=0.1)\n        neon += neon_map(st, vec2(i + 0.9, -i * 3. - 0.1));\n    return (neon);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return palette( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 st = 2. * (fragCoord.xy - 0.5 *  iResolution.xy) / iResolution.y;\n    st.x = abs(-st.x + 0.001);\n    st.y = abs(-st.y + 0.001);\n\n    float inv = 1. / (min(abs(st.x + st.y), abs(st.x - st.y)));\n    if (distance(0., inv) > 10. * iBass)\n    {\n        fragColor = vec4(vec3(0.0, 0.0, 0.0), 1.);\n        return ;\n    }\n    st = st * inv - vec2(inv - iTime, 0.);\n    st = vec2(mod(st.x, 1.), mod(st.y, 1.) - 0.25);\n\n    colors[0] = PIA_1;\n    colors[1] = PIA_2;\n    colors[2] = PIA_3;\n\n    for (float i=0.1; i < 1.; i+=0.1)\n    {\n        vec2 arg = 0.5 - vec2(abs(sin(iTime)), abs(cos(iTime)));\n        float neon = p(st, arg);\n        // fragColor.rgb += neon * holo(st, smoothstep(0., 0.5, neon), colors[int(mod(i * 10., 3.))]) + neon * iMid;\n        fragColor.rgb += neon * spectrum(cos(iTime * 0.1) * pow(neon, 0.1));\n    }\n    fragColor.rgb /= NEON_NU;\n    fragColor.rgb -= 0.05;\n\n    // float total = floor(st.x * 10.) +\n    //               floor(st.y * 10.);\n    // bool isEven = mod(total, 2.0) == 0.0;\n    // vec3 col1 = vec3(0.0, 0.0, 0.0);\n    // vec3 col2 = vec3(1.0, 1.0, 1.0);\n    // fragColor.rgb = (isEven) ? col1 : col2;\n    // fragColor.rgb = vec3(st, 0.);\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}]}