{"ver":"0.1","info":{"id":"clsSzf","date":"1675127107","viewed":194,"name":"Bucket of fire","username":"ianertson","description":"You can use the mouse to rotate and look around.\n\nAlso feel free to play around with the `NUM_BOUNCES` constant, turning it up will make things a bit more interesting.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","raymarch","rays","fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hi! Use the mouse to look around.\n\n\n// This will essentially turn on some kind of Global Illumination,\n// will get a bit noisy if bounces is too low.\n// I defaulted it to zero just to not burn your computer up.\n#define NUM_BOUNCES 0\n// On my computer, the noise is barely visible if bounces is set to around 30\n// When bounces is set to zero you won't see any noise because the GI will be turned off.\n\n#define NEAR 0.016\n#define FAR 86.0\n#define STEPS 64\n#define SMOKE_STEPS 28\n\n#define R iResolution.xy\n#define T (iTime)\n#define ZERO (min(0, int(iTime)))\n// some ambient color\n#define MOON_COLOR (vec3(79.0, 105.0, 136.0) / 255.0)\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_THING 2\n#define ID_FIRE 3\n#define ID_LOG 4\n\n\nvec3 noise(vec3 p) {\n    float freq = 1.0;\n    vec3 n = vec3(0.0);\n    \n    float lod = 0.0;\n    float lScale = 0.16;\n    n += textureLod(iChannel2, p*freq, lod).xyz; freq *= 2.0; lod += lScale;\n    n += textureLod(iChannel2, (p+(n*0.01))*freq, lod).xyz; freq *= 2.0; lod += lScale;\n    n += textureLod(iChannel2, (p-(n*0.01))*freq, lod).xyz; freq *= 2.0; lod += lScale;\n    n += textureLod(iChannel2, (p + (n*0.02))*freq, lod).xyz; freq *= 2.0; lod += lScale;\n    \n    return n / 4.0;\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n};\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec2 uv;\n    float dist;\n    float depth;\n    int id;\n    int skip;\n    vec3 rd;\n    vec3 ro;\n    \n    vec3 spec;\n    vec3 albedo;\n    float emission;\n    \n    bool skip_smoke;\n};\n\nvoid dataInit(inout Data data) {\n    data.point = vec3(0.0);\n    data.normal = vec3(0.0);\n    data.uv = vec2(0.0);\n    data.dist = FAR;\n    data.depth = 1.0;\n    data.id = 0;\n    data.skip = 0;\n    data.spec = vec3(0.0);\n    data.albedo = vec3(0.0);\n    data.emission = 0.0;\n    data.rd = vec3(0.0);\n    data.ro = vec3(0.0);\n    data.skip_smoke = true;\n}\n\nfloat cylinderSDF(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t * ab;\n    \n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    \n    return e + i;\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\n\n#define SAMPLE(var, id_) if (data.skip != id_ && var < minDist) { minDist = var; data.id = id_; }\n\nfloat thingSDF(inout Data data, vec3 p) {\n    p.y -= 0.08;\n    float d = cylinderSDF(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), (0.3 + cos(1.0 - p.y))*0.5);\n    float sphere = sphereSDF(p + vec3(0, -1, 0), 0.6);\n    sphere -= 0.02;\n    \n    d -= 0.05;\n    d = max(-sphere, d);\n    \n    return d;\n}\n\nfloat fireSDF(inout Data data, vec3 p) {\n\n    const vec3 boxPos = vec3(0.0);\n    const vec3 boxSize = vec3(2.4, 10.0, 2.4);\n    const vec3 boxMin = boxPos - boxSize*0.5;\n    const vec3 boxMax = boxPos + boxSize*0.5;\n    if (!intersect_ray_box(data.ro, 1.0 / data.rd, boxMin, boxMax, NEAR, FAR)) return FAR;\n\n    vec3 na = noise(p*0.01);\n    na = na * 2.0 - 1.0;\n    vec3 offset = vec3(cos(T+na.x)*0.5, sin(T+na.y)*0.5, T+na.z);\n    vec3 n = noise((p+offset)*0.02);\n    \n    float lr = (abs(n.x) + abs(n.z)) / 2.0;\n    float Y = max(0.01, abs(p.y));\n    p += n*2.0-1.0;\n    p.x *= (1.0 + 0.5*(1.0/Y));\n    p.z *= (1.0 + 0.5*(1.0/Y));\n    float d = cylinderSDF(p - vec3(0.0, 0.5, 0.0), vec3(0.0), vec3(0.0, 2.6 * lr, 0.0), 0.33);\n\n    n = abs(n);\n    float mag = max(n.x, max(n.y, n.z));\n    return d / (1.0+mag*2.);\n}\n\nfloat logSDF(inout Data data, vec3 p) {\n    float r = 0.16;\n    float r2 = 0.12;\n    float w = 1.3;\n    float w2 = 1.1;\n    float d = cylinderSDF(p - vec3(0.7, r + 0.03, -1.1), vec3(0.0), normalize(vec3(1.0, 0.0, 1.0))*w, r);\n    \n    float d2 = cylinderSDF(p - vec3(0.7, r2 + 0.03, -2.1), vec3(0.0), normalize(vec3(0.4, 0.0, 0.01))*w2, r2);\n    return min(d, d2);\n}\n\nfloat groundSDF(inout Data data, vec3 p) {\n    vec3 n = vec3(0.0);\n    float freq = 0.009;\n    n += textureLod(iChannel2, p*freq, 0.05).xyz; freq *= 2.0;\n    n += textureLod(iChannel2, p*freq, 0.09).xyz; freq *= 2.0;\n    n += textureLod(iChannel2, p*freq, 1.0).xyz; freq *= 2.0;\n    n /= 3.0;\n    float h = n.y * 2.0;\n    \n    h *= smoothstep(0.0, 1.0, pow(length(p.xz), 2.0)*0.005)*2.0;\n    h = max(0.0, h);\n    \n    float d = p.y - h;\n    return d / (1.0 + (h*0.1));\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float minDist = FAR;\n    \n    float ground = groundSDF(data, p);\n    float thing = thingSDF(data, p);\n    float fire = fireSDF(data, p);\n    float slog = logSDF(data, p);\n    \n    SAMPLE(ground, ID_GROUND);\n    SAMPLE(thing, ID_THING);\n    SAMPLE(fire, ID_FIRE);\n    SAMPLE(slog, ID_LOG);\n    \n    return minDist;\n}\n\nvec3 getNormal(inout Data data, vec3 p, float s) {\n    vec2 e = vec2(s, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p-e.xyy),\n        getDist(data, p-e.yxy),\n        getDist(data, p-e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data) {\n    vec3 p = data.point;\n    vec3 n = data.normal;\n    vec2 uv = vec2(0.0);\n    uv = mix(uv, p.xy, abs(dot(n, vec3(0, 0, 1))));\n    uv = mix(uv, p.xz, abs(dot(n, vec3(0, 1, 0))));\n    uv = mix(uv, p.yz, abs(dot(n, vec3(1, 0, 0))));\n    return uv;\n}\n\nfloat smokeSDF(inout Data data, vec3 p) {\n    vec3 na = noise((p*0.04));\n    float ss = na.y*2.0-1.0;\n    vec3 offset = vec3(cos(T*0.5)*0.5, (-(T+ss))*0.5, 0.5*sin((T*0.5)+1.2915));\n    \n    vec3 n = noise((((p*na)+offset)*0.04));\n    vec3 s = noise(((p+(offset-n))*0.02)+vec3(0.215, 1.215, -3.121));\n    \n    \n    s = mix(vec3(-1.0), vec3(1.0), s);\n    n*=s;\n   \n   \n    float Y = abs(p.y);\n    vec3 pp = p;\n    pp += n*3.;\n    pp.x *= 1.5+clamp(((1.0 / Y)*2.0), 0.0, 4.0);\n    pp.z *= 1.5+clamp(((1.0 / Y)*2.0), 0.0, 4.0);\n    float sphere = sphereSDF(pp - vec3(0, 3.0, 0), 2.0);\n    \n   \n  \n    float d = length(p*n);\n    \n    d = max(sphere, -d);\n    \n    return d/2.0;\n}\n\nvec3 getNormalSmoke(inout Data data, vec3 p, float s) {\n    vec2 e = vec2(s, 0.0);\n    return normalize(getDist(data, p) - vec3(\n        smokeSDF(data, p-e.xyy),\n        smokeSDF(data, p-e.yxy),\n        smokeSDF(data, p-e.yyx)\n    ));\n}\n\nvec3 renderSmoke(inout Data data, vec3 p, in Light light) {\n    vec3 n = getNormalSmoke(data, p, 0.2);\n    vec3 L = normalize(p - light.pos) * -1.0;\n    \n    float NdotL = clamp(abs(dot(n, L)), 0.0, 1.0);\n    \n    return pow(vec3(NdotL), vec3(2.2));\n}\n\nvec3 marchSmoke(vec3 ro, vec3 rd, inout Data data, in Light light) {\n    float dist = 0.0;\n    vec3 col = vec3(0.0);\n    float count = 0.0;\n    \n    \n    const vec3 boxPos = vec3(0.0);\n    const vec3 boxSize = vec3(2.4, 10.0, 2.4);\n    const vec3 boxMin = boxPos - boxSize*0.5;\n    const vec3 boxMax = boxPos + boxSize*0.5;\n    if (!intersect_ray_box(ro, 1.0 / rd, boxMin, boxMax, NEAR, FAR)) return vec3(0.0);\n   \n\n    vec3 p = ro+rd*dist;\n    float stepSize = 0.5;\n    for (int i = ZERO; i < SMOKE_STEPS; i++) {\n        vec3 p = ro+rd*dist*stepSize;\n        float next = smokeSDF(data, p);\n        dist += next;\n        count += 1.0;\n        \n        \n        vec3 nextCol = renderSmoke(data, p, light);\n        col += nextCol;\n        \n        if (abs(dist) >= (FAR*0.76)) {\n            col = vec3(0.0);\n            break;\n        }\n    }\n    \n    dist = abs(dist);\n    if (dist >= FAR || count <= 0.0) return vec3(0.0);\n    \n    col /= count;\n    data.point = p;\n  //  float s = data.id == ID_FIRE ? 0.1 : 0.03;\n    //data.normal = getNormal(data, p, s);\n    //data.uv = getUv(data);\n    data.dist = dist;\n    data.depth = dist / FAR;\n    return col;\n}\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    data.ro = ro;\n    data.rd = rd;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(next) <= NEAR || abs(dist) >= FAR) break;\n    }\n    \n    dist = abs(dist);\n    if (dist >= FAR) return false;\n    \n    vec3 p = ro+rd*dist;\n    data.point = p;\n    \n    float s = data.id == ID_FIRE ? 0.16 : data.id == ID_GROUND ? 0.3 : 0.001;\n    \n    data.normal = getNormal(data, p, s);\n    data.uv = getUv(data);\n    data.dist = dist;\n    data.depth = dist / FAR;\n    return true;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec2 uv = data.uv;\n    float n = textureAntiRepeat(iChannel3, uv*0.5, vec2(0.5, 4.0)).r;\n    data.spec = max(vec3(0.0), vec3(1.0) - (n*2.)) * 0.5;\n   \n    return vec3(n) * vec3(0.25, 0.4, 0.2);\n}\n\nvec3 getAlbedoThing(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = textureAntiRepeat(iChannel0, uv, vec2(0.5, 4.0)).rgb;\n\n    data.spec = 2.0*max(vec3(0.0), vec3(1.0) - (col*0.5));\n\n    return col;\n}\n\nvec3 getAlbedoFire(inout Data data) {\n    vec2 uv = data.uv;\n    \n    data.emission = 4.0;\n    float s = textureLod(iChannel3, uv*0.006, 0.1).r;\n    data.spec = vec3(0.0);\n   \n    vec3 c1 = vec3(0.9, 0.2, 0.1);\n    vec3 c2 = vec3(0.8, 0.7, 0.3);\n    vec3 c3 = vec3(1.0, 0.6, 0.2);\n    vec3 c4 = vec3(1.0, 0.5, 0.4);\n    vec3 c5 = vec3(1.0, 0.01, 0.01);\n    \n    vec3 n = noise(data.point*0.1);\n    \n    vec3 col = mix(c1, c2, n.x);\n    col = mix(col, c3, n.y);\n    col = mix(col, c4, n.z);\n    col = mix(col, c5, s*s*s);\n    \n    return col*col;\n}\n\nvec3 getAlbedoLog(inout Data data) {\n    vec2 uv = data.uv;\n    \n    vec3 sides = texture(iChannel1, uv*0.1).rgb;\n    \n    data.spec = vec3(pow(length(sides), 4.0));\n    return sides;\n}\n\nvec3 getAlbedo(inout Data data) {\n    vec3 albedo = vec3(1.0, 0.0, 0.0);\n    switch (data.id) {\n        case ID_GROUND: albedo = getAlbedoGround(data); break;\n        case ID_THING: albedo = getAlbedoThing(data); break;\n        case ID_FIRE: albedo = getAlbedoFire(data); break;\n        case ID_LOG: albedo = getAlbedoLog(data); break;\n    }\n    \n    data.albedo = albedo;\n    \n    return albedo;\n}\n\nbool render(vec3 ro, vec3 rd, inout Data data, inout vec3 col) {\n    bool hit = false;\n    \n    vec3 moonLightColor = MOON_COLOR;\n    float dotup = max(0.0, dot(rd, vec3(0., 1., 0.)));\n    \n    Light light = Light(vec3(2, 6, 0.0), vec3(0.9, 0.67, 0.45), 16.0);\n    \n    if (march(ro, rd, data)) {\n        hit = true;\n        \n        float distFire = distance(data.point, vec3(0.0));\n        float iDistFire = smoothstep(0.0, 1.0, 1.0 / max(0.001, pow(distFire, 2.0)));\n        \n        \n        Data tmp = data;\n        light.color = mix(light.color, getAlbedoFire(tmp), iDistFire*0.6);\n        \n        \n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        \n        vec3 n = data.normal;\n        vec3 L = normalize(data.point - light.pos) * -1.0;\n        vec3 ref = normalize(reflect(L, n));\n        float VdotR = max(0.0, dot(rd, ref));\n        \n        float NdotL = max(0.0, dot(n, L));\n        float lightDist = distance(data.point, light.pos);\n        \n        float att = NdotL * (pow(light.strength, 2.0) / max(0.0001, pow(lightDist, 2.0)));\n        \n        Data ocData;\n        dataInit(ocData);\n        ocData.skip = data.id;\n        if (NdotL > 0.0 && data.id != ID_FIRE && march(data.point, L, ocData)) {\n            float nextLightDist = distance(ocData.point, light.pos);\n            float distToOc = distance(data.point, ocData.point);\n            att *= smoothstep(0.0, 1.0, distToOc);\n            att *= 0.85;\n        }\n        \n        #if NUM_BOUNCES <= 0\n            att = max(0.2, att);\n        #endif\n        \n        vec3 spec = data.spec * pow(VdotR, 32.0);\n        \n        float NdotU = max(0.0, dot(n, vec3(0.0, 1.0, 0.0)));\n        \n        col += (NdotU * (moonLightColor/TAU)) / TAU;\n        col += data.emission * albedo;\n        col += (diffuse + spec) * light.color * att;\n        col = saturate(col, iDistFire*0.4);\n    }\n\n    Data smokeData;\n    dataInit(smokeData);\n    vec3 smokeCol = data.skip_smoke ? vec3(0.0) : marchSmoke(ro, rd, smokeData, light);\n\n    col += (smokeCol * smoothstep(0.0, 1.0, max(0.0, data.dist - (smokeData.dist*0.5)))) / TAU;\n    col += mix(vec3(0.48), moonLightColor, clamp(smoothstep(0.0, 1.0, dotup*4.0), 0.0, 1.0)) * (data.depth/TAU);\n    return hit;\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 lookAt = point;\n    float zoom = 1.;\n    vec3 camForward = normalize(lookAt - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0, 1.0, -4.5);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (iMouse.z > 0.01) {\n        ro.yz *= rot(m.y * TAU);\n        rd.yz *= rot(m.y * TAU);\n        \n        ro.xz *= rot(m.x * TAU);\n        rd.xz *= rot(m.x * TAU);\n    } else {\n        float moveT = T*0.25;\n        ro.y += (0.5 + (0.5*sin(moveT)))*M_PI*0.5;\n        ro.xz = vec2(cos(moveT), sin(moveT))*4.0;\n        rd = look(uv, vec3(0.0, 0.8, 0.0), ro);\n        \n    }\n    \n    rd = normalize(rd);\n    Data data;\n    dataInit(data);\n    data.skip_smoke = false;\n    \n    if (render(ro, rd, data, col) && data.id != ID_FIRE) {\n      #if NUM_BOUNCES > 0\n      vec3 p = data.point;\n      vec3 sum = vec3(0.0);\n     \n      for (int i = 0; i < NUM_BOUNCES; i++) {\n        \n          float r1 = rand(p.xy+p.z, 3.2915 + (float(i) / float(NUM_BOUNCES)));\n          float r2 = rand(p.yz+p.x, 7.9326 + (float(i) / float(NUM_BOUNCES)));\n          vec3 Nt = vec3(0);\n          vec3 Nb = createCoordinateSystem(data.normal, Nt);\n\n          vec3 samp = uniformSampleHemisphere(r1, r2);\n\n          vec3 dir = vec3(\n            samp.x * Nb.x + samp.y * data.normal.x + samp.z * Nt.x,\n            samp.x * Nb.y + samp.y * data.normal.y + samp.z * Nt.y,\n            samp.x * Nb.z + samp.y * data.normal.z + samp.z * Nt.z\n          );\n\n          ro = data.point;\n          rd = dir;\n\n          vec3 nextCol = vec3(0.0);\n          Data nextData;\n          dataInit(nextData);\n          nextData.skip_smoke = true;\n          nextData.skip = data.id;\n          render(ro, rd, nextData, nextCol);\n          \n          p += nextData.point;\n\n          sum += nextCol;\n      }\n      \n      sum /= float(NUM_BOUNCES);\n      \n      col += (data.albedo) * (sum);\n      #endif\n    }\n    \n    col /= vec3(1.0) + col;\n    col += (col *luma(col));\n    col = pow(col, vec3(1.0 / 2.0));\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\nconst float HASH_MAP[16] = float[16](\n    0.4484410750068152, 0.5604512254151961, 0.49955284268263, 0.40679892641422355,\n    0.5180849501908357, 0.5472588115354913, 0.6766984192813609, 0.9064048675129073,\n    0.39864570212504613, 0.21022362764468383, 0.9516217965343488, 0.7301211180314449,\n    0.9928938541159735, 0.9095016245648258, 0.34485129267821846, 0.9842958980653165\n);\n#define IDX(v) (int(abs(v)*16.0) % 16)\n#define HASH(v) HASH_MAP[IDX(v)]\nfloat rand(vec2 p, float seed) {\n    p += vec2(cos(seed), sin(seed));\n    vec2 a = vec2(HASH(p.x), HASH(p.y))*10.0215;\n    vec2 b = vec2(HASH(p*a.x), HASH(p*a.y))*10.3921;    \n    return fract(20.0154*(dot(a, b) * dot(p, b)));\n}\n\nvec3 rand3(vec3 p, float seed) {\n    float x = rand(p.xz, seed);\n    float y = rand(p.yz, seed);\n    float z = rand(p.xy, seed);\n    return vec3(x, y, z) * 2.0 - 1.0;\n}\n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec4 textureAntiRepeat(sampler2D tex, vec2 uv) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 textureAntiRepeatSingleLayer(sampler2D tex, vec2 uv, vec2 dx, vec2 dy) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 9.78376;\n    float self = rand(id, seed);\n    float right = rand(id+vec2(1.0, 0.0), seed);\n    float top = rand(id+vec2(0.0, 1.0), seed);\n    float topRight = rand(id+vec2(1.0, 1.0), seed);\n    return mix(\n        mix(textureGrad(tex, uv*rot(self*6.28), dx, dy),\n            textureGrad(tex, uv*rot(right*6.28), dx, dy), sv.x),\n        mix(textureGrad(tex, uv*rot(top*6.28), dx, dy),\n            textureGrad(tex, uv*rot(topRight*6.28), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 textureAntiRepeatLayered(sampler2D tex, vec2 uv, vec2 scale) {\n    vec2 id = floor(uv);\n    vec2 sv = smoothstep(0.0, 1.0, fract(uv));\n    float seed = 3.31915;\n    float self = mix(scale.x, scale.y, rand(id, seed));\n    float right = mix(scale.x, scale.y, rand(id+vec2(1.0, 0.0), seed));\n    float top = mix(scale.x, scale.y, rand(id+vec2(0.0, 1.0), seed));\n    float topRight = mix(scale.x, scale.y, rand(id+vec2(1.0, 1.0), seed));\n    vec2 dx = dFdx(uv);\n    vec2 dy = dFdy(uv);\n    return mix(\n        mix(textureAntiRepeatSingleLayer(tex, (uv*self), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*right), dx, dy), sv.x),\n        mix(textureAntiRepeatSingleLayer(tex, (uv*top), dx, dy),\n            textureAntiRepeatSingleLayer(tex, (uv*topRight), dx, dy), sv.x),\n        sv.y\n    );\n}\nvec4 textureAntiRepeat(sampler2D tex, vec2 uv, vec2 scale) {\n    return textureAntiRepeatLayered(tex, uv, scale);\n}\n\nvec3 createCoordinateSystem(vec3 N, inout vec3 Nt)\n{\n    if (abs(N.x) > abs(N.y)) {\n        Nt = vec3(N.z, 0, -N.x) / sqrt(N.x * N.x + N.z * N.z);\n    } else {\n        Nt = vec3(0, -N.z, N.y) / sqrt(N.y * N.y + N.z * N.z);\n    }\n    return cross(N, Nt);\n}\n\nvec3 uniformSampleHemisphere(float r1, float r2)\n{\n    float theta = sqrt(1. - r1 * r1);\n    float phi = 2. * M_PI * r2;\n    return vec3(cos(phi) * theta, r1, sin(phi) * theta);\n}\n\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\nbool intersect_ray_box(vec3 org, vec3 inv_dir, vec3 box_min, vec3 box_max, float tnear, float tfar) {\n    vec3 tmin = (box_min - org) * inv_dir;\n    vec3 tmax = (box_max - org) * inv_dir;\n    vec3 t0 = min(tmin, tmax);\n    vec3 t1 = max(tmin, tmax);\n    vec2 v = vec2(\n        max(t0.x, max(t0.y, max(t0.z, tnear))),\n        min(t1.x, min(t1.y, min(t1.z, tfar))));\n        \n    return v.x < v.y;\n}","name":"Common","description":"","type":"common"}]}