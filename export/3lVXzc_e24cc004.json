{"ver":"0.1","info":{"id":"3lVXzc","date":"1583839677","viewed":97,"name":"My_Planet","username":"Jiayin","description":"planet","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 water = vec3(0.0,0.0,0.4);\nconst vec3 shore = vec3(0.5,0.5,0.4);\nconst vec3 rock = vec3(0.5,0.3,0.1);\nconst vec3 ice = vec3(1.0,1.0,1.0);\nconst vec3 tree = vec3(0.05,0.4,0.05);\nconst float h_water = 0.0;\nconst float h_shore = 0.05;\nconst float h_tree = 0.08;\nconst float h_rock = 0.10;\n\n// ----------------------------------------------------------------------------\n// Signed Distance Field \n// ----------------------------------------------------------------------------\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\nfloat map(vec3 p)\n{\n    float theta = 1e-1*iTime;\n    mat3 rotate = mat3(cos(theta), 0.0, sin(theta),\n                       0.0, 1.0, 0.0,\n                       -sin(theta), 0.0, cos(theta));\n    p = rotate*p;\n    float n = fbmL(5.0*normalize(p));\n    n = smoothstep(-1.0, 1.0, n);\n    n = mix(-0.15, 0.2, n);\n    if (n > 0.0) n *= 0.1;\n\treturn 0.2*(sdSphere(p - vec3(0.f, 0.f, 0.f), 1.0f) + n);\n}\n\nvec3 define_material(vec3 p) { //p: surface location\n    float height = length(p) - 1.0;\n   \tif (height < 0.0) return mix(water, vec3(0.0), -height/0.02);\n    else if (height < 0.05) return mix(water, shore, height/0.05);\n    else if (height < 0.08) return mix(shore, tree, (height-0.05)/0.03);\n    else if (height < 0.12) return mix(tree, rock, (height-0.08)/0.04);\n    else return ice;\n}\n\nvec3 computeNormal(vec3 p)\n{\n    float h = 1e-6;\n    vec3 normal;\n    vec3 dx = vec3(h,0.0,0.0);\n    vec3 dy = vec3(0.0,h,0.0);\n    vec3 dz = vec3(0.0,0.0,h);\n    float nx = (map(p+dx)-map(p-dx));\n    float ny = (map(p+dy)-map(p-dy));\n    float nz = (map(p+dz)-map(p-dz));\n    return normalize(vec3(nx,ny,nz));\n}\n\nbool sphere_tracing(ray r,\n               \t\tint max_iter,\n               \t\tout vec3 hit_loc,\n               \t\tout int iters)\n{\n    hit_loc = r.origin;\n    for (int iters = 0; iters<max_iter; iters++) {\n    \tfloat step_size = map(hit_loc);\n        if (step_size < EPSILON) return true;\n\t\thit_loc += r.direction*step_size;\n    }\n    return false;\n}\n\nfloat soft_shadow(ray r,\n                  int max_iter,\n                  float k)\n{\n    vec3 hit_loc = r.origin;\n    float ratio = 1.0;\n    float traversed = 0.0;\n    for (int iters = 0; iters<max_iter; iters++) {\n    \tfloat step_size = map(hit_loc);\n        if (step_size < EPSILON) break;\n\t\thit_loc += r.direction*step_size;\n        traversed += step_size;\n        ratio = min(ratio, step_size/traversed);\n    }\n    if (map(hit_loc) < EPSILON) return 0.0;\n    return k*ratio;\n}\n\nvec3 shade(vec3 p, int iters, vec3 material)\n{       \n    vec3 light_dir = normalize(vec3(-1.0, -1.0, 0.0));\n    vec3 light_color = vec3(1.0, 1.0, 1.0)*2.0;\n        \n    vec3 surface_color = material;\n        \n    float shadow_k = 1.0;\n        \n\tvec3 n = computeNormal(p);        \n    float cosnl = clamp(dot(-light_dir,n)/length(light_dir),0.0,1.0);\n    ray r;\n    r.origin = p + n*1e-3;\n    r.direction = -light_dir;\n    float ratio = soft_shadow(r, 100, shadow_k);\n    vec3 col = ratio*surface_color*light_color*cosnl;\n     \t\n    return col;\n}\n\nvec3 render(vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    camera cam = camera_const(vec3(5, 5.0, -2.0),\n    \t\t\t\t          vec3(0.0, 0.0, 0.0),\n                              vec3(0.0, 1.0, 0.0),\n                              20.0,\n                              640.0 / 360.0,\n                              0.0,\n                              sqrt(27.0));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    ray r = camera_get_ray(cam, uv);\n    \n    int max_iter = 1000;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 hit_loc;\n    int iters;\n    bool hit;\n    vec3 m;\n    \n    if (sphere_tracing(r, max_iter, hit_loc, iters))\n    {\n    \tm = define_material(hit_loc);\n        col = shade(hit_loc, iters, m);\n    }\n    \n    return pow(col, vec3(1.0 / 2.2));\n}\n\nfloat renderClouds(vec2 fragCoord)\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    camera cam = camera_const(vec3(5, 5.0, -2.0),\n    \t\t\t\t          vec3(0.0, 0.0, 0.0),\n                              vec3(0.0, 1.0, 0.0),\n                              20.0,\n                              640.0 / 360.0,\n                              0.0,\n                              sqrt(27.0));\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    ray r = camera_get_ray(cam, uv);\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 hit_loc = r.origin;\n    bool hit = false;\n    for (int iters = 0; iters<100; iters++) {\n    \tfloat step_size = length(hit_loc) - 1.15;\n        if (step_size < EPSILON) { hit = true; break; }\n\t\thit_loc += r.direction*step_size;\n    }\n    if (!hit) return 0.0;\n    \n    float theta = 1e-2*iTime;\n    mat3 rotate = mat3(cos(theta), 0.0, sin(theta),\n                       0.0, 1.0, 0.0,\n                       -sin(theta), 0.0, cos(theta));\n    vec3 loc = rotate*hit_loc;\n    \n    float t = fbmL(3.0*loc);\n    t = smoothstep(-1.0, 1.0, t);\n    vec3 normal = normalize(hit_loc);\n\n    t = clamp(0.1, 0.8, t) - 0.1;\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n#ifdef CLOUDS\n    vec3 col = mix(render(fragCoord),vec3(1.0),renderClouds(fragCoord));\n#else \n    vec3 col = render(fragCoord);\n#endif\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// pre-defined constants\n#define EPSILON 1e-4\n#define PI 3.1415926535897932384626433832795\n#define CLOUDS\n\n// ----------------------------------------------------------------------------\n// Noise function by iq from https://www.shadertoy.com/view/XsXfRH\n// ----------------------------------------------------------------------------\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\n// return value noise (in x) and its derivatives (in yzw)\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash(i+vec3(0.0,0.0,0.0));\n    float b = hash(i+vec3(1.0,0.0,0.0));\n    float c = hash(i+vec3(0.0,1.0,0.0));\n    float d = hash(i+vec3(1.0,1.0,0.0));\n    float e = hash(i+vec3(0.0,0.0,1.0));\n\tfloat f = hash(i+vec3(1.0,0.0,1.0));\n    float g = hash(i+vec3(0.0,1.0,1.0));\n    float h = hash(i+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z;\n}\n\n//\n// fbm by iq from https://www.shadertoy.com/view/4ttSWf\n//\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n// returns 3D fbm\nfloat fbm( in vec3 x, int octaves )\n{\n    float f = 1.98;  // could be 2.0\n    float s = 0.49;  // could be 0.5\n    float a = 0.0;\n    float b = 0.5;\n    vec3  d = vec3(0.0);\n    for( int i=0; i < octaves; i++ )\n    {\n       \tfloat n = noise(x);\n        a += b*n;          // accumulate values\n        b *= s;\n        x = f*m3*x;\n    }\n    return a;\n}\n\nfloat fbmL(in vec3 p) {return fbm(p,4);}\nfloat fbmM(in vec3 p) {return fbm(p,9);}\nfloat fbmH(in vec3 p) {return fbm(p,16);}\n\n\n// ----------------------------------------------------------------------------\n// Ray and Camera from assignment 6 starter code\n// ----------------------------------------------------------------------------\n\n//\n// Ray\n//\n    \nstruct ray\n{\n    vec3 origin;            // this is the origin of the ray\n    vec3 direction;         // this is the direction the ray is pointing in\n};\n    \n//\n// Camera\n//\n    \nstruct camera\n{\n    vec3 origin;            // this is the origin of your camera\n    vec3 lower_left_corner; // this is the location of the lower-left corner of the image in relation to the origin\n    vec3 horizontal;        // this is the horizontal extents of the image the camera sees\n    vec3 vertical;          // this is the vertical extents of the image the camera sees\n    vec3 u;\n    vec3 v;\n    float lens_radius;      // the radius of the lens\n};\n    \ncamera camera_const(vec3 lookfrom,\n                    vec3 lookat,\n                    vec3 up,\n                    float fov,\n                    float aspect,\n                    float aperture,\n                    float focal_dist)\n{\n    camera cam;\n    \n    vec3 w;\n    \n    cam.lens_radius = aperture / 2.0;\n    \n    float theta = fov * PI / 180.0;\n    float half_height = tan(theta / 2.0);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(up, w));\n    cam.v = cross(w, cam.u);\n    cam.lower_left_corner = cam.origin - half_width * cam.u * focal_dist - half_height * cam.v * focal_dist - w * focal_dist;\n    cam.horizontal = 2.0 * half_width * cam.u * focal_dist;\n    cam.vertical = 2.0 * half_height * cam.v * focal_dist;\n    \n    return cam;\n}\n\nray camera_get_ray(camera cam, vec2 uv)\n{\n    ray r;\n    \n    r.origin = cam.origin;\n    r.direction = normalize(cam.lower_left_corner + uv.x * cam.horizontal +\n                            uv.y * cam.vertical - cam.origin);\n    \n    return r;\n}\n\n\nstruct material {\n\tint type;\n    vec3 albedo;\n    float variable;\n};\n\n","name":"Common","description":"","type":"common"}]}