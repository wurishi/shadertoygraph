{"ver":"0.1","info":{"id":"ttSXzW","date":"1565183764","viewed":159,"name":"Hammersley Points","username":"NadirRoGue","description":"Test Hammersley points on the sphere","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MARCH_SAMPLES 150\n#define SPHERE_RADIUS 5.0\n#define EPSILON 0.001\n#define ANGLE_STEP 0.5\n\nconst vec3 lightDir = vec3(-1.0, 1.0, 0.0);\nfloat angle = 0.0;\nmat3 rotation;\n\nfloat radicalInverse_VdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley2d(uint i, uint N) \n{\n    return vec2(float(i)/float(N), radicalInverse_VdC(i));\n}\n\nconst float PI = 3.14159265358979;\n\nvec3 hemisphereSample_uniform(float u, float v) \n{\n    float phi = v * 2.0 * PI;\n    float cosTheta = 1.0 - u;\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    //return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n    \n    float theta = u * 2.0 * PI;\n    return vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta) / 2.0);\n}\n\nbool inSphere(in vec3 pos)\n{\n    return length(pos) <= SPHERE_RADIUS;\n}\n\nvec3 correctSpherePos(in vec3 pos)\n{\n \treturn normalize(pos) * (SPHERE_RADIUS + EPSILON);\n}\n\nbool raymarch(in vec3 startPos, in vec3 dir, out vec3 hitPos)\n{\n    float dist = length(startPos) + SPHERE_RADIUS;\n    float stepValue = dist / float(MARCH_SAMPLES);\n    \n    angle += ANGLE_STEP * iTime;\n    float cos0 = cos(angle);\n    float sin0 = sin(angle);\n    \n    vec3 c0 = vec3(cos0, 0, -sin0);\n    vec3 c1 = vec3(0, 1, 0);\n    vec3 c2 = vec3(sin0, 0, cos0);\n    rotation[0] = c0;\n    rotation[1] = c1;\n    rotation[2] = c2;\n    \n    rotation = inverse(rotation);\n        \n\tfor(int i = 0; i < MARCH_SAMPLES; i++)\n    {\n        vec3 pos = startPos + dir * stepValue * float(i);\n        if(inSphere(pos))\n        {\n            hitPos = correctSpherePos(pos);\n         \treturn true;   \n        }\n    }\n    \n    return false;\n}\n\n\nvec3 shadeSample(in vec3 pos)\n{\n    bool closeEnough = false;\n    vec3 tempPos = rotation * pos;\n    for(int i = 0; i < 200 && !closeEnough; i++)\n    {\n   \t\tvec2 uv = hammersley2d(uint(i), 200u);\n        vec3 testPos = normalize(hemisphereSample_uniform(uv.x, uv.y)) * SPHERE_RADIUS;\n        if(length(testPos - tempPos) < 0.08)\n        {\n         \tcloseEnough = true;   \n        }\n    }\n    \n    vec3 color = closeEnough? vec3(1,0,0) : vec3(1,1,0);\n    \n    vec3 normal = normalize(pos);\n    float d = dot(normalize(lightDir), normal);\n    d = clamp(d, 0.0, 1.0);\n    \n    return color * d + color * 0.25; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(45.0));\n    vec3 worldDir = normalize(vec3(xy, -z));\n    \n    const vec3 camPos = vec3(0.0, 0.0, 15.0);\n    \n    vec3 hitPos;\n    if(raymarch(camPos, worldDir, hitPos))\n    {\n    \tfragColor = vec4(shadeSample(hitPos), 1.0);\n    }\n    else\n    {\n    \t// Output to screen\n    \tfragColor = vec4(0,0,0,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}