{"ver":"0.1","info":{"id":"tlVSDz","date":"1582904711","viewed":49,"name":"tp TNCY","username":"Silith","description":"z","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" const float EPSILON=1e-3;\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n    \nstruct Material{\n  vec4 color;\n  bool emet;\n  bool reflet;\n        \n};\n    \nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n    \nstruct Object{\n    Sphere sphere;\n    Material material;\n};\n\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nbool intersect_sphere(in Ray R, in Sphere S,out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nObject objs[6];\n\nvoid init_scene(){\n    float cx = cos(iTime*2.0)*2.0;\n    float cy = sin(iTime*2.0)*2.0;\n    float dx = cx+cos(iTime*3.0)*0.5;\n    float dy = cy+sin(iTime*3.0)*0.5;\n    float kx = cx+sin(iTime*2.0)*0.4;\n    float ky = cy+cos(iTime*2.0)*0.4;\n    float kz = cos(iTime*2.0)*0.5;\n    float px = cos(iTime*7.0)*0.5;\n    float py = sin(iTime*7.0)*0.5;\n    \n    objs[0] = Object(Sphere(vec3(0.0, 0.0, 0.0), 0.4),\n                     Material(vec4(0.8,0.8,0.8,1.0),false,true));\n    objs[1]=Object(Sphere(vec3(cx, cy, 0.0), 0.2),\n                   Material(vec4(1.0,0.0,0.0,1.0),false,false));\n    objs[2]=Object(Sphere(vec3(dx, dy, 0.0), 0.1),\n                  Material(vec4(0.0,1.0,0.0,1.0),false,false));\n    objs[3]=Object(Sphere(vec3(kx,ky,kz),0.1),\n                   Material(vec4(1.0,1.0,0.0,1.0),false,false));\n    objs[4]=Object(Sphere(vec3(-5.0,5.0,5.0),0.5),\n                   Material(vec4(1.0,1.0,1.0,1.0),true,false));\n    objs[5]=Object(Sphere(vec3(px,py,.5),0.02),\n                   Material(vec4(1.0,0.0,0.5,1.0),true,false));\n}\n\nbool shadow(in Ray R) {\n   for(int i=0; i<objs.length(); ++i) {\n        float t;\n        if(\n          !objs[i].material.emet &&\n          intersect_sphere(R, objs[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    return false;\n}\n\nvec4 lighting(in vec3 P, in vec3 N, in Material material){\n    if (material.emet == true){\n        return material.color;\n    }\n    vec4 result = vec4(0.0,0.0,0.0,0.0);\n    \n    for (int i=0; i<objs.length(); i++){\n        if(objs[i].material.emet == true){\n            Ray R2 = Ray(P, objs[i].sphere.Center);\n            if(!shadow(R2)){\n                vec3 E = objs[i].sphere.Center-P;\n                float lamb = max(0.0, dot(E,N) /length(E));\n                result += lamb * material.color * objs[i].material.color;\n            }\n         }\n    }\n    return vec4(result.x,result.y,result.z,1.0);\n    \n}\nvec4 raytrace(in Material m, in Ray R, out vec3 P, out vec3 N)\n{\n  float t = 1e30;\n  vec4 color = lighting(P,N,m);\n    for (int i=0; i<objs.length(); i++){\n        float ti;\n        if( intersect_sphere(R, objs[i].sphere, ti) && ti < t && ti > 0.0 && ti > 1e-6){\n            t = ti;\n            P = R.Origin + 1e-3 * R.Dir;\n         \tN = normalize(P - objs[i].sphere.Center);\n            vec3 E = objs[i].sphere.Center-P;\n            float lamb = max(0.0, dot(E,N) /length(E));\n         \tcolor =lighting(P,N,objs[i].material)*0.9;   \n        }\n    }\n  return color;\n    \n}\n\nvoid mainImage(\n   out vec4 col,in vec2 coord\n) {     \n    \n\tfloat centrex = iResolution.x/2.0;\n\tfloat centrey = iResolution.y/2.0;\n\t   Camera C = camera(\n       vec3(2.0, 2.0, 1.5),\n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   Ray R = launch(C, coord);\n  \n   \n   col = vec4(0.0, 0.9, 0.8, 1.0);\n   init_scene();\n    \n    float t =1e30;\n    vec3 P;\n    vec3 N;\n    Material material;\n    for (int i=0; i<objs.length();++i){\n        float ti;\n        if( intersect_sphere(R,objs[i].sphere,ti) && ti<t){\n         t =ti;\n         P = R.Origin + t*R.Dir;\n         N = normalize(P - objs[i].sphere.Center);\n         material = objs[i].material;\n            \n        }\n        \n        \n    }\n    if (t != 1e30){\n        if(material.reflet==true){\n             Ray R2 = Ray(P,-2.0*dot(N,R.Dir)*N + R.Dir);\n            col = raytrace(material,R2,P,N);\n        }else{\n        col = lighting(P,N,material);\n        }\n        \n    }\n    \n}","name":"Image","description":"","type":"image"}]}