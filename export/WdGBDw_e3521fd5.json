{"ver":"0.1","info":{"id":"WdGBDw","date":"1607242090","viewed":1984,"name":"Sirenian Dawn VXAA T4X Filmic","username":"hypernewbie","description":"VXAA Filmic history tests using Serenian Dawn demo as example scene.\n  A = Orig shader color palette change - their TAA+ dither rays.\n  B = TAA upsample 4x using differential blending\n  C = TAA filmic morphological","likes":34,"published":3,"flags":32,"usePreview":0,"tags":["fog","mars","aa","atmosphere","dawn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sirenian Dawn by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsyGWV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tSee: https://en.wikipedia.org/wiki/Terra_Sirenum\n\n\tThings of interest in this shader:\n\t\t-A technique I call \"relaxation marching\", see march() function\n\t\t-A buffer based technique for anti-alisaing\n\t\t-Cheap and smooth procedural starfield\n\t\t-Non-constant fog from iq\n\t\t-Completely faked atmosphere :)\n\t\t-Terrain based on noise derivatives\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(texture(iChannel0, fragCoord.xy/iResolution.xy).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Sirenian Dawn by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsyGWV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define ITR 90\n#define FAR 400.\n#define time iTime\n\nconst vec3 lgt = vec3(-.523, .41, -.747);\nmat2 m2 = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n//form iq, see: https://iquilezles.org/articles/morenoise\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 p)\n{\n    float rz = 0.;\n    float z = 1.;\n\tvec2  d = vec2(0.0);\n    float scl = 2.95;\n    float zscl = -.4;\n    float zz = 5.;\n    for( int i=0; i<5; i++ )\n    {\n        vec3 n = noised(p);\n        d += pow(abs(n.yz),vec2(zz));\n        d -= smoothstep(-.5,1.5,n.yz);\n        zz -= 1.;\n        rz += z*n.x/(dot(d,d)+.85);\n        z *= zscl;\n        zscl *= .8;\n        p = m2*p*scl;\n    }\n    \n    rz /= smoothstep(1.5,-.5,rz)+.75;\n    return rz;\n}\n\nfloat map(vec3 p)\n{\n    return p.y-(terrain(p.zx*0.07))*2.7-1.;\n}\n\nfloat blue_noise( vec2 uv )\n{\n    return texture( iChannel1, uv ).r;\n}\n\n/*\tThe idea is simple, as the ray gets further from the eye, I increase \n\tthe step size of the raymarching and lower the target precision, \n\tthis allows for better performance with virtually no loss in visual quality. */\nfloat march(in vec3 ro, in vec3 rd, out float itrc, float noise)\n{\n    float t = noise * 0.01;\n    float d = map(rd*t+ro);\n    float precis = 0.0001;\n    \n    for (int i=0;i<=ITR;i++)\n    {\n        if (abs(d) < precis || t > FAR) break;\n        precis = t*0.0001;\n        float rl = max(t*0.02,1.);\n        t += d*rl;\n        d = map(rd*t+ro)*0.7;\n        itrc++;\n    }\n\n    return t;\n}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec3 rotz(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec3 normal(in vec3 p, in float ds)\n{  \n    vec2 e = vec2(-1., 1.)*0.0005*pow(ds,1.);\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat noise(in vec2 x){return texture(iChannel0, x*.01).x;}\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=0.5;\n\tfloat rz = 0.;\n\tfor (float i= 0.;i<3.;i++ )\n\t{\n        rz+= (sin(noise(p)*5.)*0.5+0.5) *z;\n\t\tz *= 0.5;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\nfloat bnoise(in vec2 p){ return fbm(p*5.); }\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(.005*ds,0);\n    float n0 = bnoise(p.zx);\n    vec3 d = vec3(bnoise(p.zx+e.xy)-n0, 1., bnoise(p.zx+e.yx)-n0)/e.x*0.025;\n    d -= n*dot(n,d);\n    n = normalize(n-d);\n    return n;\n}\n\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return .15/e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\n//Based on: https://iquilezles.org/articles/fog\nvec3 fog(vec3 ro, vec3 rd, vec3 col, float ds)\n{\n    vec3 pos = ro + rd*ds;\n    float mx = (fbm(pos.zx*0.1-time*0.05)-0.5)*.2;\n    \n    const float b= 1.;\n    float den = 0.3*exp(-ro.y*b)*(1.0-exp( -ds*rd.y*b ))/rd.y;\n    float sdt = max(dot(rd, lgt), 0.);\n    vec3  fogColor  = mix(vec3(0.15,0.4,0.5)*1.2, vec3(1.5,0.4,0.25)*1.3, pow(sdt,2.0)+mx*0.5);\n    return mix( col, fogColor, clamp(den + mx,0.,1.) );\n}\n\nfloat linstep(in float mn, in float mx, in float x){\n\treturn clamp((x - mn)/(mx - mn), 0., 1.);\n}\n\n//Complete hack, but looks good enough :)\nvec3 scatter(vec3 ro, vec3 rd)\n{   \n    float sd= max(dot(lgt, rd)*0.5+0.5,0.);\n    float dtp = 13.-(ro + rd*(FAR)).y*3.5;\n    float hori = (linstep(-1500., 0.0, dtp) - linstep(11., 500., dtp))*1.;\n    hori *= pow(sd,.04);\n    \n    vec3 col = vec3(0);\n    col += pow(hori, 200.)*vec3(1.0, 0.7,  0.5)*3.;\n    col += pow(hori, 25.)* vec3(1.0, 0.5,  0.25)*.3;\n    col += pow(hori, 7.)* vec3(1.0, 0.4, 0.5)*.8;\n    \n    return col;\n}\n\nvec3 nmzHash33(vec3 q)\n{\n    uvec3 p = uvec3(ivec3(q));\n    p = p*uvec3(374761393U, 1103515245U, 668265263U) + p.zxy + p.yzx;\n    p = p.yzx*(p.zxy^(p >> 3U));\n    return vec3(p^(p >> 16U))*(1.0/vec3(0xffffffffU));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = nmzHash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*4.7;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float noise = blue_noise( ( fragCoord.xy + iTime * 315.788f ) / 1024.0 );\n    fragCoord.xy += (iFrame % 2 == 0) ? vec2( 0.5f, 0.5f) : vec2( 0.0f, 0.0f );\n    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-.2,0.3):mo;\n    mo.x *= 1.2;\n    mo -= vec2(1.2,-0.1);\n\tmo.x *= iResolution.x/iResolution.y;\n    mo.x += sin(time*0.15)*0.2;\n\t\n    vec3 ro = vec3(650., sin(time*0.2)*0.25+10.,-time);\n    vec3 eye = normalize(vec3(cos(mo.x),-0.5+mo.y,sin(mo.x)));\n    vec3 right = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right + p.y*up)*1.05 + eye);\n    rd.y += abs(p.x*p.x*0.015);\n    rd = normalize(rd);\n\t\n    float count = 0.;\n\tfloat rz = march(ro,rd, count, noise);\n    \n    vec3 scatt = scatter(ro, rd);\n    \n    vec3 bg = stars(rd)*(1.0-clamp(dot(scatt, vec3(1.3)),0.,1.));\n    vec3 col = bg;\n    \n    vec3 pos = ro+rz*rd;\n    vec3 nor= normal( pos, rz );\n    if ( rz < FAR )\n    {\n        nor = bump(pos,nor,rz);\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lgt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lgt.x,0.0,-lgt.z))), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), lgt ), 0.0, 1.0 ),500.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        vec3 brdf = 1.*amb*vec3(0.10,0.11,0.12);\n        brdf += bac*vec3(0.15,0.08,0.1);\n        brdf += 2.3*dif*vec3(.9,0.4,0.25);\n        col = vec3(0.25,0.25,0.3);\n        float crv = curv(pos, 2.)*1.;\n        float crv2 = curv(pos, .4)*2.5;\n        \n        col += clamp(crv*0.9,-1.,1.)*vec3(0.25,.6,.5);\n        col = col*brdf + col*spe*.1 +.1*fre*col;\n        col *= crv*1.+1.;\n        col *= crv2*1.+1.;\n    }\n\t\n    col = fog(ro, rd, col, rz);\n    col = mix(col,bg,smoothstep(FAR-150., FAR, rz));\n    col += scatt;\n    \n    col = pow( col, vec3(0.93,1.0,1.0) );\n    col = mix(col, smoothstep(0.,1.,col), 0.2);\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1)*0.9+0.1;\n    \n    //vec4 past = texture(iChannel1, q);\n    //float tOver = clamp(iTimeDelta-(1./60.),0.,1.);\n    \n    //if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(1.0-iResolution.x*0.0003,0.,1.));\n    //if (count/pow(rz, 0.65) > 3.3) col = mix(col, past.rgb, clamp(0.85-iTimeDelta*7.,0.,1.));\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\n    -- Vertex Engine X --\n\n    Copyright 2020 UAA Software\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n    associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define VXAA_TEXTURE_CURRENT iChannel0\n#define VXAA_TEXTURE_PREV iChannel1\n\n#define VXAA_TEMPORALEDGE_THRES 0.08\n#define VXAA_TEMPORALEDGE_TIME_MIN 0.0000001\n#define VXAA_TEMPORALEDGE_TIME_MAX 1.5\n#define VXAA_SPATIAL_FLICKER_TIME 2.75\n\n#define VXAA_W 0\n#define VXAA_E 1\n#define VXAA_N 2\n#define VXAA_S 3\n#define VXAA_NW 0\n#define VXAA_NE 1\n#define VXAA_SW 2\n#define VXAA_SE 3\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nfloat VXAALuma( vec3 c )\n{\n    return dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\n}\n\nfloat VXAALumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nvec3 VXAAClampHistory( vec3 history, vec4 currN[4] )\n{\n    vec3 cmin = min( min( currN[0].rgb, currN[1].rgb ), min( currN[2].rgb, currN[3].rgb ) );\n    vec3 cmax = max( min( currN[0].rgb, currN[1].rgb ), max( currN[2].rgb, currN[3].rgb ) );\n    return vec3(\n        clamp( history.r, cmin.r, cmax.r ),\n        clamp( history.g, cmin.g, cmax.g ),\n        clamp( history.b, cmin.b, cmax.b )\n    );\n}\n\nvec2 VXAADifferentialBlendWeight( vec4 n[4] )\n{\n    float diffWE = VXAALumaDiff( n[ VXAA_W ].rgb, n[ VXAA_E ].rgb );\n    float diffNS = VXAALumaDiff( n[ VXAA_N ].rgb, n[ VXAA_S ].rgb );\n    return diffWE < diffNS ? vec2( 0.5, 0.0 ) : vec2( 0.0, 0.5 );\n}\n\nvec4 VXAADifferentialBlend( vec4 n[4], vec2 w )\n{\n    vec4 c = vec4( 0.0 );\n    c += ( n[ VXAA_W ] + n[ VXAA_E ] ) * w.x;\n    c += ( n[ VXAA_N ] + n[ VXAA_S ] ) * w.y;\n    return c;\n}\n\nvoid VXAAUpsampleT4x( out vec4 vtex[4], vec4 current, vec4 history, vec4 currN[4], vec4 histN[4] )\n{\n    vec4 n1[4], n2[4];\n    \n    n1[VXAA_W] = currN[VXAA_W];\n    n1[VXAA_E] = current;\n    n1[VXAA_N] = history;\n    n1[VXAA_S] = histN[VXAA_S];\n    \n    n2[VXAA_W] = history;\n    n2[VXAA_E] = histN[VXAA_E];\n    n2[VXAA_N] = currN[VXAA_N];\n    n2[VXAA_S] = current;\n    \n    \n    vec4 weights = vec4( VXAADifferentialBlendWeight( n1 ), VXAADifferentialBlendWeight( n2 ) );\n    vtex[VXAA_NW] = history;\n    vtex[VXAA_NE] = VXAADifferentialBlend( n2, weights.zw );\n    vtex[VXAA_SW] = VXAADifferentialBlend( n1, weights.xy );\n    vtex[VXAA_SE] = current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample scene and neighbourhood.\n    \n    vec4 current = clamp( vec4( texture( VXAA_TEXTURE_CURRENT, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    vec4 history = clamp( vec4( texture( VXAA_TEXTURE_PREV, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    current.a = VXAALuma( current.rgb ); history.a = VXAALuma( history.rgb );\n    \n    vec4 currN[4];\n    currN[VXAA_W] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2( -1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_E] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_N] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_S] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_W].a = VXAALuma( currN[ VXAA_W ].rgb );\n    currN[VXAA_E].a = VXAALuma( currN[ VXAA_E ].rgb );\n    currN[VXAA_N].a = VXAALuma( currN[ VXAA_N ].rgb );\n    currN[VXAA_S].a = VXAALuma( currN[ VXAA_S ].rgb );\n    \n    vec4 histN[4];\n    histN[VXAA_W] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2( -1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_E] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_N] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_S] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_W].a = VXAALuma( histN[ VXAA_W ].rgb );\n    histN[VXAA_E].a = VXAALuma( histN[ VXAA_E ].rgb );\n    histN[VXAA_N].a = VXAALuma( histN[ VXAA_N ].rgb );\n    histN[VXAA_S].a = VXAALuma( histN[ VXAA_S ].rgb );\n    history.rgb = VXAAClampHistory( history.rgb, currN );\n   \n    \n    // Temporal checkerboard upsample pass.\n    vec4 vtex[4];\n    VXAAUpsampleT4x( vtex, current, history, currN, histN );\n    \n    // Average all samples.\n    fragColor = ( vtex[VXAA_NW] + vtex[VXAA_NE] + vtex[VXAA_SW] + vtex[VXAA_SE] ) * 0.25f;\n    //if( iMouse.x > fragCoord.x ) fragColor = current;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n    -- Vertex Engine X --\n\n    Copyright 2020 UAA Software\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n    associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define VXAA_TEXTURE_CURRENT iChannel0\n#define VXAA_TEXTURE_PREV iChannel1\n\n#define VXAA_TEMPORALEDGE_THRES 0.05\n#define VXAA_TEMPORALEDGE_TIME_MIN 0.0000001\n#define VXAA_TEMPORALEDGE_TIME_MAX 1.15\n#define VXAA_SPATIAL_FLICKER_TIME 2.35\n#define VXAA_MORPHOLOGICAL_STRENGTH 0.42\n#define VXAA_MORPHOLOGICAL_SHARPEN 0.13\n\n#define VXAA_W 0\n#define VXAA_E 1\n#define VXAA_N 2\n#define VXAA_S 3\n#define VXAA_NW 0\n#define VXAA_NE 1\n#define VXAA_SW 2\n#define VXAA_SE 3\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nfloat VXAALuma( vec3 c )\n{\n    return dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\n}\n\nfloat VXAALumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nfloat VXAATemporalContrast( float currentLuma, float historyLuma )\n{\n    float x = saturate( abs( historyLuma - currentLuma ) - VXAA_TEMPORALEDGE_THRES );\n    float x2 = x * x, x3 = x2 * x;\n    return saturate( 3.082671957671837 * x - 3.9384920634917364 * x2 + 1.8518518518516354 * x3 );\n}\n\nfloat VXAAMorphStrengthShaper( float x )\n{\n    return 1.3 * x - 0.3 * x * x;\n}\n\nfloat VXAASpatialContrast( vec2 spatialLumaMinMax )\n{\n    float spatialContrast = spatialLumaMinMax.y - spatialLumaMinMax.x;\n    return mix( 0.0f, 1.0f, spatialContrast );\n}\n\nfloat VXAATemporalFilterAlpha( float fpsRcp, float convergenceTime )\n{\n    return exp( -fpsRcp / convergenceTime );\n}\n\nvec3 VXAAClampHistory( vec3 history, vec4 currN[4] )\n{\n    vec3 cmin = min( min( currN[0].rgb, currN[1].rgb ), min( currN[2].rgb, currN[3].rgb ) );\n    vec3 cmax = max( min( currN[0].rgb, currN[1].rgb ), max( currN[2].rgb, currN[3].rgb ) );\n    return vec3(\n        clamp( history.r, cmin.r, cmax.r ),\n        clamp( history.g, cmin.g, cmax.g ),\n        clamp( history.b, cmin.b, cmax.b )\n    );\n}\n\nvec4 VXAASharpen( vec4 history, vec4 histN[4] )\n{\n    vec4 nh = histN[VXAA_NW] + histN[VXAA_NE] + histN[VXAA_SW] + histN[VXAA_SE];\n    return mix( history, history * 5.0f - nh, VXAA_MORPHOLOGICAL_SHARPEN );\n}\n\nvec4 VXAAMorphological( vec2 uv, vec4 current, vec4 currN[4], float strength )\n{\n    if ( strength < 0.1f ) return current;\n    float lumaNW = currN[VXAA_NW].a, lumaNE = currN[VXAA_NE].a,\n        lumaSW = currN[VXAA_SW].a, lumaSE = currN[VXAA_SE].a;\n    lumaNE += 0.0025;\n    float lumaMin = min( current.a, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n    float lumaMax = max( current.a, max( max( lumaNW, lumaNE ), max( lumaSW, lumaSE ) ) );\n    \n    vec2 dir;\n    dir.x = ( lumaSW - lumaNE ) + ( lumaSE - lumaNW );\n    dir.y = ( lumaSW - lumaNE ) - ( lumaSE - lumaNW );\n    vec2 dirN = normalize( dir );\n    \n    vec4 n1 = texture( VXAA_TEXTURE_CURRENT, uv - dirN * strength / iResolution.xy );\n    vec4 p1 = texture( VXAA_TEXTURE_CURRENT, uv + dirN * strength / iResolution.xy );\n    return ( n1 + p1 ) * 0.5;\n}\n\nvec4 VXAAFilmic( vec2 uv, vec4 current, vec4 history, vec4 currN[4], vec4 histN[4] )\n{\n    // Temporal contrast weight.\n    float temporalContrastWeight = VXAATemporalContrast( current.a, history.a );\n\n    // Spatial contrast weight.\n    vec2 spatialLumaMinMaxC = vec2(\n        min( min( currN[0].a, currN[1].a ), min( currN[2].a, currN[3].a ) ),\n        max( max( currN[0].a, currN[1].a ), max( currN[2].a, currN[3].a ) )\n    );\n    vec2 spatialLumaMinMaxH = vec2(\n        min( min( histN[0].a, histN[1].a ), min( histN[2].a, histN[3].a ) ),\n        max( max( histN[0].a, histN[1].a ), max( histN[2].a, histN[3].a ) )\n    );\n    float spatialContrastWeightC = VXAASpatialContrast( spatialLumaMinMaxC );\n    float spatialContrastWeightH = VXAASpatialContrast( spatialLumaMinMaxH );\n    float spatialContrastWeight = abs( spatialContrastWeightC - spatialContrastWeightH );\n    \n    // Evaluate convergence time from weights.\n    float convergenceTime = mix( VXAA_TEMPORALEDGE_TIME_MIN, VXAA_TEMPORALEDGE_TIME_MAX, temporalContrastWeight );\n    convergenceTime = mix( convergenceTime, VXAA_SPATIAL_FLICKER_TIME, spatialContrastWeight );\n    float alpha = VXAATemporalFilterAlpha( iTimeDelta, convergenceTime );\n    \n    // Apply morpholigical AA filter and sharpen.\n    float strength = VXAAMorphStrengthShaper( spatialContrastWeightC * 4.0 ) * VXAA_MORPHOLOGICAL_STRENGTH;\n    current = VXAAMorphological( uv, current, currN, strength );\n    current = VXAASharpen( current, currN );\n    \n    // Clamp history to neighbourhood, and apply filmic blend.\n    history.rgb = VXAAClampHistory( history.rgb, currN );\n    current = mix( current, history, alpha );\n    return current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample scene and neighbourhood.\n    \n    vec4 current = clamp( vec4( texture( VXAA_TEXTURE_CURRENT, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    vec4 history = clamp( vec4( texture( VXAA_TEXTURE_PREV, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    current.a = VXAALuma( current.rgb ); history.a = VXAALuma( history.rgb );\n    \n    vec4 currN[4];\n    currN[VXAA_NW] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2( -1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_NE] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2(  1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_SW] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2( -1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_SE] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2(  1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_NW].a = VXAALuma( currN[VXAA_NW].rgb );\n    currN[VXAA_NE].a = VXAALuma( currN[VXAA_NE].rgb );\n    currN[VXAA_SW].a = VXAALuma( currN[VXAA_SW].rgb );\n    currN[VXAA_SE].a = VXAALuma( currN[VXAA_SE].rgb );\n    \n    vec4 histN[4];\n    histN[VXAA_NW] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2( -1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_NE] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2(  1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_SW] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2( -1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_SE] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2(  1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_NW].a = VXAALuma( histN[VXAA_NW].rgb );\n    histN[VXAA_NE].a = VXAALuma( histN[VXAA_NE].rgb );\n    histN[VXAA_SW].a = VXAALuma( histN[VXAA_SW].rgb );\n    histN[VXAA_SE].a = VXAALuma( histN[VXAA_SE].rgb );\n    \n    \n    // Filmic pass.    \n    fragColor = VXAAFilmic( uv, current, history, currN, histN );\n    //if( iMouse.x > fragCoord.x ) fragColor = current;\n}","name":"Buffer C","description":"","type":"buffer"}]}