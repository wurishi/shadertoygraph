{"ver":"0.1","info":{"id":"sly3Dc","date":"1638540147","viewed":86,"name":"Distorted circles","username":"Shirooo","description":"distorted circles","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["distortedcircles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.28318530718\n\n//3d continuous noise\nvec3 hash( vec3 p )\n{\n\tp *= mat3( 127.1,311.7,-53.7,\n\t\t\t   269.5,183.3, 77.1,\n\t\t\t  -301.7, 27.3,215.3 );\n\n\treturn 2.*fract(sin(p)*43758.5453123) -1.;\n}\n\nfloat noise( vec3 p )\n{\n    vec3 i = floor( p ),\n         f = fract( p ),\n\t     u = f*f*(3.-2.*f);\n      \n    return 2.*mix(\n              mix( mix( dot( hash( i + vec3(0,0,0) ), f - vec3(0,0,0) ), \n                        dot( hash( i + vec3(1,0,0) ), f - vec3(1,0,0) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,0) ), f - vec3(0,1,0) ), \n                        dot( hash( i + vec3(1,1,0) ), f - vec3(1,1,0) ), u.x), u.y),\n              mix( mix( dot( hash( i + vec3(0,0,1) ), f - vec3(0,0,1) ), \n                        dot( hash( i + vec3(1,0,1) ), f - vec3(1,0,1) ), u.x),\n                   mix( dot( hash( i + vec3(0,1,1) ), f - vec3(0,1,1) ), \n                        dot( hash( i + vec3(1,1,1) ), f - vec3(1,1,1) ), u.x), u.y), u.z);\n}\n\n//1D gradient noise\nfloat hash( uint n ) \n{   // integer hash copied from Hugo Elias\n\tn = (n<<13U)^n; \n    n = n*(n*n*15731U+789221U)+1376312589U;\n    return float(n&uvec3(0x0fffffffU))/float(0x0fffffff);\n}\n\nfloat gnoise( in float p )\n{\n    uint  i = uint(floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n\n    float g0 = hash(i+0u)*2.0-1.0;\n    float g1 = hash(i+1u)*2.0-1.0;\n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\n\nfloat circle(vec2 c, vec2 p, float radius, float t) \n{\n    float d = length(c-p) - radius;\n    return 1. - smoothstep(0., 1., abs(d) / t);\n}\n\n//input noise in [-1,1] range\nvec2 distortByAngle(float noise, float strength, vec2 p)\n{\n    noise = noise * 0.5 + 0.5;\n    float noiseAngle = noise * TWO_PI;\n    p.x = p.x + strength * cos(noiseAngle*1.86);\n    p.y = p.y + strength * sin(noiseAngle*1.3);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 normFragCoord = fragCoord.xy / iResolution.xy;\n    vec2 uv = normFragCoord * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float noise = noise(vec3(uv*1.5, iTime * 1.5));\n    vec2 distUV = distortByAngle(noise, 0.015, uv);\n    \n    float circlesInt=0.;\n    int imax = 90;\n    for(int i=0; i<imax; ++i)\n    {\n        float r = mix(0.05, 2.5, float(i)/float(imax));\n        \n        vec2 c = distortByAngle(gnoise(float(i)/float(imax)-iTime*0.1), 0.3, vec2(0.,0.));\n        circlesInt += circle(c, distUV, r, 0.03);\n    }\n    \n    vec3 col = mix(vec3(0.), texture(iChannel0, normFragCoord).xyz, circlesInt);\n    \n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}