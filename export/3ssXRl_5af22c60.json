{"ver":"0.1","info":{"id":"3ssXRl","date":"1551892248","viewed":417,"name":"Steel Alphabet","username":"BlueLightning42","description":"shitty practicing of drawing shapes/Glyphs from https://coppermind.net/wiki/Steel_alphabet\nlast minute domain warping added to background","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["glyph","mistborn","steelalphabet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n#define PI      3.14159265358979323846264\n#define TWO_PI  6.28318530717958647692528\n#define HALF_PI 1.57079632679489661923132\n#define TRQT_PI 4.71238898038468985769396\n\n#define PHI 1.61803398874989484820459\n\n\nfloat rand( in vec2 st ){\n    return fract(sin(dot(st, vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat rand( in float st, in float seed ){\n    return fract(sin(dot(vec2(st,seed), vec2(12.9898,78.233)))*43758.5453123);\n}\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat getAngle(in vec2 st){\n    return atan(0.5-st.y,0.5-st.x);\n}\nfloat getRadius(in vec2 st){\n    return length(0.5-st)*2.0;\n}\n// better performance than sqrt versions\nfloat drawCircle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.01),_radius+(_radius*0.01),dot(dist,dist)*4.0);\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n// messed up space this helps me move nicly (ish)\nvec2 translate(vec2 _t){\n    return vec2(-_t.y,_t.x);\n}\n\nvoid fill(inout vec3 bg, in vec2 st, in float a){\n    if (a < 1.0){\n        bg = hsb2rgb(vec3(getRadius(st)*0.2+sin(0.676+iTime)*.2,0.2,clamp(1.0 - fbm(st*10.)*.5,0.5,0.7)));\n    }\n}\n\n\nfloat positive(in float x){\n    if ( x <= 0.0){\n        return 0.0;\n    }else{\n        return x;\n    }\n}\nfloat drawMoon(in vec2 st, in float offset, in float smallRad){\n    return positive(drawCircle(st+.5,.4)-drawCircle(st+.5-offset,smallRad));\n}\nfloat partMoon(in vec2 st, in float angle){\n    if (angle < 1.0)\n    \treturn getAngle(st) > angle ? positive(drawCircle(st+.5,.4)-drawCircle(st+.4,.4)) : 0.0;\n    else\n        return getAngle(st) < fract(angle) ? positive(drawCircle(st+.5,.4)-drawCircle(st+.4,.4)) : 0.0;\n}\nfloat drawSpike(in vec2 st){\n    float a=1.0;\n    st.y -= .5;\n    if (abs(st.y)-pow((st.x-0.5)*4.+0.036,3.)*0.01 < 0.017 && st.x < 0.936){\n        a = 0.;\n    }\n    \n    return 1.-a;\n}\n\n\n//really awful transformations due to drawn objects not having an origin and me trying to account for that by switching around some things\nfloat glyph2(in vec2 _st, in float seed){\n    float r = rand(seed, PHI);\n    float a = 0.0;\n\n    _st -= .5;\n    if(r <= 1./24.){\n        a = drawSpike(_st * rotate2d(TRQT_PI)+vec2(0.470,0.480));\n    }else{\n        // 7 have same cresent\n        if(r <= 7./24.){\n            a += drawMoon(_st, .1, .4);\n            if(r <= 2./24.){ // Iron\n                a += drawSpike(_st * rotate2d(-1.992) * scale(vec2(1.990,1.460)) + translate(vec2(0.430,-0.050)));\n                a += drawSpike(_st * rotate2d(-2.648) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,0.020)));\n                a += drawCircle(_st-vec2(-0.560,-0.180),0.006);\n            }else if(r <= 3./24.){ // Zinc\n                a += drawSpike(_st * rotate2d(-1.032) * scale(vec2(1.690,1.560)) + translate(vec2(0.530,-1.080)));\n                a += drawSpike(_st * rotate2d(-1.060) * scale(vec2(1.690,1.560)) + translate(vec2(0.300,-0.990)));\n                a += drawCircle(_st-vec2(-0.360,-0.390),0.006);\n            }else if(r <= 4./24.){ // unkown/H\n                a += drawSpike(_st * rotate2d(-0.704) * scale(vec2(1.690,1.560)) + translate(vec2(0.600,-1.070)));\n                a += drawSpike(_st * rotate2d(0.348) * scale(vec2(1.690,1.560)) + translate(vec2(0.450,-1.070)));\n                a += drawCircle(_st-vec2(-0.360,-0.390),0.006);\n            }else if(r <= 5./24.){ // Malatium\n                a += drawSpike(_st * rotate2d(2.312) * scale(vec2(1.990,0.800)) + vec2(1.490,0.470));\n                a += drawSpike(_st * rotate2d(-1.824) * scale(vec2(1.790,1.560)) + translate(vec2(0.530,-1.120)));\n                a += drawSpike(_st * rotate2d(0.548) * scale(vec2(1.690,1.560)) + translate(vec2(0.460,-1.160)));\n                a += drawSpike(_st * rotate2d(-0.260) * scale(vec2(1.990,1.660)) + translate(vec2(0.450,-1.150)));\n                a += drawSpike(_st * rotate2d(-0.916) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n                a += drawCircle(_st-vec2(-0.360,-0.390),0.006);\n            }else if(r <= 6./24.){ // Lerasium\n                _st += 0.012;\n                a += drawSpike(_st * rotate2d(1.928) * scale(vec2(1.690,1.560)) + translate(vec2(0.400,-0.270)));\n                a += drawSpike(_st * scale(vec2(1.430,1.360)) * rotate2d(2.648)  + translate(vec2(0.590,-0.30))); //slight curve to nail with different order of transforms failed\n                a += drawCircle(_st-vec2(-0.360,-0.390),0.006);\n                a += partMoon(_st* rotate2d(0.488) * scale(vec2(1.290,0.910))+ vec2(+0.230,+0.110),1.648);\n            }else if(r <= 7./24.){ // Electrum\n                a += partMoon(_st  * rotate2d(7.088)* scale(vec2(1.3,1.000))+vec2(0.080,-0.020),0.472);\n                _st += 0.012;\n                a += drawSpike(_st  * rotate2d(3.952) * scale(vec2(1.290,1.260))  + translate(vec2(0.590,-0.30))); //slight curve to nail with different order of transforms failed\n                a += drawCircle(_st-vec2(-0.350,-0.570),0.006);\n            }\n        }else if(r <= 10./24.){\n            a += drawMoon(_st* rotate2d(5.512)* scale(vec2(0.960,0.980)),0.050, .28);\n            if(r <= 8./24.){ // Cadmium\n                a += drawSpike(_st * rotate2d(-PI) * scale(vec2(1.090,1.260)) + translate(vec2(0.580,-0.470)));\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,-1.120)));\n                a += drawCircle(_st-vec2(-0.480,-0.200),0.006);\n            }else if(r <= 9./24.){ // Chromium\n                a += drawSpike(_st * rotate2d(-2.160) * scale(vec2(1.390,1.060)) + translate(vec2(0.580,-0.870)));\n\t\t\t\ta += partMoon(_st  * rotate2d(5.076)* scale(vec2(1.3,1.300))+vec2(-0.110,-0.050),1.968);\n                a += drawCircle(_st-vec2(-0.480,-0.200),0.006);\n            }else if(r <= 10./24.){ // Malatium\n                _st = _st * rotate2d(-1.104); \n                a += drawSpike(_st * rotate2d(-2.524) * scale(vec2(1.790,1.560)) + translate(vec2(0.530,-1.120)));\n                a += drawSpike(_st * rotate2d(3.740) * scale(vec2(1.690,1.560)) + translate(vec2(0.560,-0.060)));\n\t\t\t\ta += drawSpike(_st * rotate2d(-1.500) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n                a += drawSpike(_st * rotate2d(-0.404) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n                a += drawCircle(_st-vec2(-0.310,-0.350),0.006);\n            }\n        }else if(r <= 14./24.){\n            if (r <= 12./24.) _st *= rotate2d(PI); // two left two right\n            a += drawMoon(_st* rotate2d(-0.600)* scale(vec2(0.780,-0.910))+ vec2(0.010,0.000),0.060, .29);\n            if(r <= 11./24.){ // unknown/C\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,-1.120)));\n                a += drawSpike(_st * rotate2d(+HALF_PI) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,-1.120)));\n                a += drawCircle(_st-vec2(-0.490,-0.500),0.006);\n            }else if(r <= 12./24.){ // unknown/X\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(0.790,1.460)) + translate(vec2(0.540,-0.580)));\n                a += drawCircle(_st-vec2(-0.60,-0.500),0.006);\n            }else if(r <= 13./24.){ // unknown/J\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(1.990,1.460)) + translate(vec2(0.490,-1.120)));\n                a += drawCircle(_st-vec2(-0.310,-0.520),0.006);\n            }else if(r <= 14./24.){ // Bendalloy\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(0.790,1.460)) + translate(vec2(0.540,-0.580)));\n                a += drawSpike(_st * rotate2d(-PI) * scale(vec2(0.790,1.460)) + translate(vec2(0.740,-0.580)));\n                a += drawCircle(_st-vec2(-0.350,-0.470),0.006);\n            }\n        }else if(r <= 21./24.){\n            if (r > 17./24.) _st *= rotate2d(PI) * scale(vec2(.8)); // three down rest up\n            a += drawMoon(_st* rotate2d(TRQT_PI/2.) * scale(vec2(1.3))+ vec2(0.010,0.000),0.036, .29);\n            if(r <= 15./24.){ // Tin\n                a += drawSpike(_st * rotate2d(-HALF_PI) * scale(vec2(1.00,1.460)) + translate(vec2(0.520,-0.520)));\n                a += drawCircle(_st-vec2(-0.490,-0.040),0.006);\n                a += drawMoon(_st* rotate2d(TRQT_PI/2.) * scale(vec2(0.8))+ vec2(0.010,0.000),0.036, .29);\n            }else if(r <= 16./24.){ // unknown/X\n                a += drawSpike(_st * rotate2d(-2.440) * scale(vec2(1.00,1.460)) + translate(vec2(0.520,-0.520)));\n                a += drawCircle(_st-vec2(-0.470,-0.640),0.006);\n                a += drawMoon(_st* rotate2d(TRQT_PI/2.) * scale(vec2(0.8))+ vec2(0.010,0.000),0.036, .29);\n            }else if(r <= 17./24.){ // Pewter\n                a += drawSpike(_st * rotate2d(-2.440) * scale(vec2(1.00,1.460)) + translate(vec2(0.520,-0.520)));\n                a += drawCircle(_st-vec2(-0.580,-0.590),0.006);\n                a += partMoon(_st* rotate2d(TRQT_PI/2.376) * scale(vec2(0.8,1.2))+ vec2(0.010,0.200), 0.610);\n            }else if(r <= 18./24.){ // Copper\n                a += drawSpike(_st * rotate2d(0.720) * scale(vec2(0.990,1.460)) + translate(vec2(0.470,-0.7040)));\n                a += drawSpike(_st * rotate2d(0.736) * scale(vec2(1.990,1.370)) + translate(vec2(0.60,-1.120)));\n                a += drawCircle(_st-vec2(-0.350,-0.470),0.006);\n            }else if(r <= 19./24.){ // Bronze\n                a += drawSpike(_st * rotate2d(4.336) * scale(vec2(1.10,1.460)) + translate(vec2(0.490,-0.5240)));\n                a += drawSpike(_st * rotate2d(3.992) * scale(vec2(1.390,1.370)) + translate(vec2(0.40,-0.320)));\n                a += drawCircle(_st-vec2(-0.590,-0.640),0.006);\n            }else if(r <= 20./24.){ // Atrium\n                _st = _st * rotate2d(2.192); \n                a += drawSpike(_st * rotate2d(-2.524) * scale(vec2(2.990,1.560)) + translate(vec2(0.530,-1.380)));\n                a += drawSpike(_st * rotate2d(3.740) * scale(vec2(2.890,1.60)) + translate(vec2(0.540,-0.130)));\n\t\t\t\ta += drawSpike(_st * rotate2d(-1.500) * scale(vec2(2.890,1.660)) + translate(vec2(0.600,-1.220)));\n                a += drawSpike(_st * rotate2d(-0.404) * scale(vec2(2.80,1.660)) + translate(vec2(0.540,-1.220)));\n                a += drawCircle(_st-vec2(-0.310,-0.350),0.006);\n            }else if(r <= 21./24.){ // Aluminum\n                _st = _st * rotate2d(2.192); \n                a += drawSpike(_st * rotate2d(-2.588) * scale(vec2(2.990,1.560)) + translate(vec2(0.530,-1.380)));\n                a += drawSpike(_st * rotate2d(1.092) * scale(vec2(2.890,1.60)) + translate(vec2(0.460,-1.280)));\n                a += drawSpike(_st * rotate2d(-0.740) * scale(vec2(2.80,1.660)) + translate(vec2(0.540,-1.220)));\n                a += drawCircle(_st-vec2(-0.310,-0.350),0.006);\n            }\n        }else if(r <= 22./24.){//Duralumin\n        \ta += drawMoon(_st* rotate2d(TRQT_PI/1.520) * scale(vec2(-0.900,0.900))+ vec2(-0.010,0.040),0.036, .29);\n            a += drawSpike(_st * rotate2d(0.836) * scale(vec2(2.290,1.560)) + translate(vec2(0.480,-1.380)));\n            a += drawSpike(_st * rotate2d(2.364) * scale(vec2(2.000,1.560)) + translate(vec2(0.380,-1.380)));\n            a += drawSpike(_st * rotate2d(2.364) * scale(vec2(2.000,1.560)) + translate(vec2(0.580,-1.380)));\n            a += drawSpike(_st * rotate2d(2.364+PI) * scale(vec2(2.000,1.560)) + translate(vec2(0.650,-1.380)));\n            a += drawSpike(_st * rotate2d(2.364+PI) * scale(vec2(2.000,1.560)) + translate(vec2(0.450,-1.380)));\n            a += drawCircle(_st-vec2(-0.470,-0.50),0.006);\n        }else if(r <= 23./24.){//Duralumin\n            _st *= rotate2d(3.304);\n        \ta += drawMoon(_st* rotate2d(TRQT_PI/1.520) * scale(vec2(-0.900,0.900))+ vec2(-0.010,0.040),0.076, 0.402);\n            a += drawSpike(_st * rotate2d(2.024) * scale(vec2(0.990,1.460)) + translate(vec2(0.770,-0.6040)));\n            a += drawSpike(_st * rotate2d(2.054) * scale(vec2(1.890,1.570)) + translate(vec2(0.640,-0.210)));\n            a += drawCircle(_st-vec2(-0.350,-0.470),0.006);\n        }else{ // 24.  Brass\n\t        a += drawMoon(_st* rotate2d(-1.792) * scale(vec2(-0.900,0.900))+ vec2(-0.010,0.040),0.044, 0.282);\n            _st = _st * rotate2d(-2.584) * 0.98+vec2(0.030,0.080); \n            a += drawSpike(_st * rotate2d(-2.524) * scale(vec2(1.790,1.560)) + translate(vec2(0.530,-1.120)));\n            a += drawSpike(_st * rotate2d(1.644) * scale(vec2(1.690,1.560)) + translate(vec2(0.490,-1.090)));\n\t\t\ta += drawSpike(_st * rotate2d(-1.500) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n            a += drawSpike(_st * rotate2d(-0.404) * scale(vec2(1.990,1.660)) + translate(vec2(0.500,-1.120)));\n            a += drawCircle(_st-vec2(-0.490,-0.500),0.006);\n        }\n    }\n\n      \n    return 1.-a;\n}\n\n//simple domain warping\nvec3 smoke(in vec2 st){\n    float a = fbm(st* 10. + (sin(iTime),iTime+cos(iTime*.5+.1)));\n    float b = fbm(st*4.+ a* vec2(sin(iTime),sin(iTime*.56))*.3);\n    float c = fbm(st * vec2(a,b));\n    return hsb2rgb(vec3(a*.2+0.832,b-.3,.3+c));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\t//st *= 20.;\n    vec3 color = smoke(st);\n    \n    st*=7.0;\n    vec2 ipos = floor(st);\n    \n    \n    st.y += +iTime * (rand(ipos.x,PI) * 2.+.2);\n    ipos.y = floor(st.y);\n    vec2 fpos = fract(st);\n    float a = glyph2(fpos, rand(ipos));\n\tfill(color, fpos, a);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}