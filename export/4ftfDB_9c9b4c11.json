{"ver":"0.1","info":{"id":"4ftfDB","date":"1733480038","viewed":81,"name":"Logistic Map Chaos","username":"koi","description":"Orbit diagram for the logistic map `f(x) = rx(1-x)`.\n\nThe chaotic part of the diagram is shown (r_inf < r < 4).\nDragging the mouse to the right reveals the full orbit diagram (1 < r < 4).\n\nNote: this entire beautiful graph is made by iterating a parabola!","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["animated","dynamics","chaos","render","orbitdiagram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hs_to_rgb(float h, float s)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(h + K.xyz) * 6.0 - K.www);\n    return mix(K.xxx, clamp(p - 1.0, 0.0, 1.0), s);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 d = texture(iChannel0, fragCoord / iResolution.xy);\n\n    // transform the numbers and make pretty colors\n    float h = 0.785 - 1.3 * min(d.x, 0.1);\n    float s = clamp(0.85 + 0.175 * log(d.y), 0.0, 0.5);\n    fragColor = vec4(hs_to_rgb(h, s), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEPS 500u\n\nfloat f(float x, float r)\n{\n    return r * x * (1.0 - x);                    // Logistic Map\n    //return r/4.0 * sin(x * 3.1415926535);      // Sine Map\n    //return r/4.0 * (1.0 - abs(2.0 * x - 1.0)); // Triangle Map\n}\n\nfloat rand_x0(vec2 uv)\n{\n    float x = fract(sin(dot(uv, vec2(iTime + 12.9898, 78.233))) * 43758.5453);\n    return mix(0.01, 0.99, x); // avoid fixed point at 0\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // nice mouse input\n    float m = 1.0 - pow(clamp(iMouse.x / iResolution.x, 0.0, 1.0), 2.5);\n\n    // transform coords\n    float r_min = mix(1.0, 3.569946, m);\n    float r = mix(r_min, 4.0, uv.x);\n    float x = uv.y;\n\n    // rescale to fit viewport\n    float xb = r / 4.0;\n    float xa = f(r / 4.0, r);\n    float xd = xb - xa;\n    x = mix(x, x * xd + xa, m);\n    \n    // calculate \"attractiveness\" of each point x given r\n    vec2 cds = vec2(0.0);\n    float xi = rand_x0(uv);\n    \n    for(uint i = 0u; i < STEPS; i++)\n    {\n        float d = abs(x - xi) * float(STEPS);\n        cds += vec2(pow(d, -0.7), 1.0 / d);\n        xi = f(xi, r);\n    }\n    \n    cds = 1.0 / cds;\n\n    // average values over time to reduce noise\n    vec4 data = texture(iChannel0, uv);\n    float frame = data.z * step(iMouse.z, 0.0);\n    float s = frame / (frame + 1.0);\n    fragColor = vec4(mix(cds, data.xy, s), frame + 1.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}