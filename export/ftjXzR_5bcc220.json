{"ver":"0.1","info":{"id":"ftjXzR","date":"1626932116","viewed":50,"name":"RayTracing(starting)","username":"SteelFlame","description":"Ray tracing","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float fov = 1.;\nvec3 cameraPosition = vec3(0.,0.,0.);\n/*vec3 cameraRotation = vec3(0.,0.,0.);\n\nvec3 getPointByCameraRotation(vec3 point) {\n    vec3 newPoint = point;\n    newPoint.x *= cos(cameraRotation.x)-sin(cameraRotation.x);\n}*/\n\nstruct Sphere {\n    vec3 Position;\n    float Radius;\n    vec4 Color;\n};\nstruct Plane {\n    vec3 minPoint;\n    vec3 maxPoint;\n    vec4 Color;\n};\nstruct DirLight {\n    vec3 Direction;\n    float Intensity;\n    //vec4 Color;\n};\nvec3 sphereReflectDirection(vec3 point, vec3 direction, Sphere sphere) {\n    vec3 normal = normalize(sphere.Position - point);\n    return reflect(direction, normal);\n}\n\nconst int spheresCount = 3; \nSphere spheres[spheresCount] = Sphere[spheresCount](\n    Sphere(vec3(-3.,0.,5.),1.,vec4(1.)),\n    Sphere(vec3(0.,0.,5.),1.,vec4(1.)),\n    Sphere(vec3(3.,0.,5.),1.,vec4(1.))\n);\nconst int planesCount = 1;\nPlane planes[planesCount] = Plane[planesCount](\n    Plane(vec3(0.,1.,4.),vec3(0.,-1.,3.),vec4(1.))\n);\n\nconst int dirLightsCount = 2;\nDirLight dirLights[dirLightsCount] = DirLight[dirLightsCount](\n    DirLight(vec3(1.,0.,0.),1.),\n    DirLight(vec3(-1.,0.,0.),.3)\n);\n\nvec2 raySphereIntersect(vec3 rayOrigin, vec3 rayDirection, Sphere sphere) {\n    vec3 posDelta = sphere.Position - rayOrigin;\n    float b = 2. * dot(normalize(rayDirection), posDelta);\n    float c = dot(posDelta,posDelta)-sphere.Radius*sphere.Radius;\n    \n    float D = b*b-4.*c;\n    if (D >= 0.) {\n        float t1 = (b-sqrt(D))/2.;\n        float t2 = (b+sqrt(D))/2.;\n        return vec2(max(t1,0.),max(t2,0.));\n    }\n    return vec2(0.);\n}\nvec3 getSphereNormalAtPoint(vec3 point, vec3 spherePosition) {\n    return normalize(point-spherePosition);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    cameraPosition += vec3(iMouse.xy/iResolution.xy*2.-1.,0);\n    spheres[1].Position = vec3(0.,0.,5.+sin(iTime)*2.7);\n    //spheres[0].Position = vec3(sin(iTime)*4.,0.,5.);\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float viewportScaleYError = iResolution.y/iResolution.x;\n    vec3 viewDirection = normalize(vec3(uv.x*2.-1., (uv.y*2.-1.)*viewportScaleYError, fov));\n    \n    fragColor = vec4(0.);\n    vec2 minIntersectData = vec2(9999.,9999.);\n    int minSphereIndex = 0;\n    for (int i = 0; i < spheresCount;i++) {\n        vec2 intersectData = raySphereIntersect(cameraPosition,viewDirection,spheres[i]);\n        if (intersectData.x > 0. && intersectData.x < minIntersectData.x) {\n            minIntersectData = intersectData;\n            minSphereIndex = i;\n        }\n    }\n    vec2 intersectData = raySphereIntersect(cameraPosition,viewDirection,spheres[minSphereIndex]);\n    if (intersectData.x > 0.) {\n        vec3 contactPoint = cameraPosition+viewDirection*intersectData.x;\n        float lightIntens = 0.;\n        vec3 reflectedRay = sphereReflectDirection(contactPoint,viewDirection,spheres[minSphereIndex]);\n        \n        float shadowIntensity = 1.;\n        vec4 reflectColor = vec4(0.);\n        for (int dirLightI = 0; dirLightI < dirLightsCount; dirLightI++) {\n            bool isReflectRayNotContntWithAnybody = true;\n            for (int j = 0; j < spheresCount; j++) {\n                if (minSphereIndex==j) continue;\n                vec2 shadowData = raySphereIntersect(cameraPosition+viewDirection*(intersectData.x-0.99),dirLights[dirLightI].Direction,spheres[j]);\n                if (shadowData.x > 0.) {\n                    isReflectRayNotContntWithAnybody = false;\n                    shadowIntensity += (shadowData.y-shadowData.x)*0.5;\n                    reflectColor = spheres[j].Color;\n                    break;\n                }\n            }\n            if (isReflectRayNotContntWithAnybody) {\n                float reflectLightDot = dot(dirLights[dirLightI].Direction,reflectedRay);\n                lightIntens += max(reflectLightDot,0.)*dirLights[dirLightI].Intensity*shadowIntensity;\n            }\n        }\n        fragColor = vec4(0.2)*max(.2,lightIntens)/shadowIntensity;\n        //fragColor = reflectColor*max(.2,lightIntens);\n    }\n}","name":"Image","description":"","type":"image"}]}