{"ver":"0.1","info":{"id":"4XG3R3","date":"1720150872","viewed":44,"name":"Sunny sand","username":"TomCarbon","description":"Sphere on basement with shadow and antialias.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","shadow","antialias"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const uint kMaxSteps = 255u;\nconst float kMinSurface = 0.0001;\nconst float kMaxDistance = 100.0;\n\nconst uint kAntiAlias = 4u;\n\n\nfloat sdSphere(vec3 p, vec4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\nfloat sdBox(vec3 p, vec3 b, vec3 offset)\n{\n    vec3 q = abs(p - offset) - b;\n    return length(max(q, 0.0)) + min(0.0, max(q.x, max(q.y, q.z)));\n}\n\nfloat map(vec3 p)\n{\n    float d = p.y;\n\n    d = min(d, sdSphere(p, vec4(0.0, 0.35, 0.0, 0.25)));\n    d = min(d, sdBox(p, vec3(0.3, 0.05, 0.3), vec3(0.0, 0.05, 0.0)));\n\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0, 0.0001);\n    vec3 n = map(p) - vec3(map(p - e.yxx), map(p - e.xyx), map(p - e.xxy));\n\n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float min, float max)\n{\n    float d = min;\n    \n    for (uint i = 0u; i < kMaxSteps; ++i)\n    {\n        vec3 p = ro + d * rd;\n\n        float sd = map(p);\n        if (sd < kMinSurface)\n            return d;\n            \n        d += sd;\n        if (d > max)\n            break;\n    }\n\n    return -1.0;\n}\n\nvec3 getColor(vec2 uv)\n{\n    float t = iTime;\n\n    vec3 ro = vec3(cos(t), 0.25, sin(t));\n    vec3 lookAt = vec3(0.0, 0.25, 0.0);\n    float fov = 1.5;\n    \n    vec3 zz = normalize(lookAt - ro);\n    vec3 xx = normalize(cross(zz, vec3(0.0, 1.0, 0.0)));\n    vec3 yy = normalize(cross(xx, zz));\n\n    vec3 rd = normalize(uv.x * xx + uv.y * yy + fov * zz);\n\n    vec3 color = vec3(0.4, 0.75, 1.0) - 0.7 * rd.y;\n    color = mix(color, vec3(0.7, 0.75, 0.8), exp(-10.0 * rd.y));\n    \n    float d = rayMarch(ro, rd, 0.0, kMaxDistance);\n    if (d > 0.0)\n    {\n        vec3 p = ro + d * rd;\n        vec3 n = getNormal(p);\n\n        vec3 mate = vec3(0.18);\n\n        vec3 sky_dir = vec3(0.0, 1.0, 0.0);\n        float sky_dif = clamp(0.5 + 0.5 * dot(n, sky_dir), 0.0, 1.0);\n\n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));\n        float sun_dif = clamp(dot(n, sun_dir), 0.0, 1.0);\n        float sun_sha = step(rayMarch(p + n * kMinSurface, sun_dir, 0.0, 20.f), 0.0);\n\n        float bce_dif = clamp(0.5 + 0.5 * dot(n, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        \n        color  = mate * vec3(7.0, 5.0, 3.0) * sun_dif * sun_sha;\n        color += mate * vec3(0.5, 0.8, 0.9) * sky_dif;\n        color += mate * vec3(0.7, 0.3, 0.2) * bce_dif;\n    }\n\n    return color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 pixel = vec3(0);\n\n    for (uint aa = 0u; aa < kAntiAlias * kAntiAlias; ++aa)\n    {\n        vec2 aaCoord = fragCoord + vec2(aa % kAntiAlias, aa / kAntiAlias) / float(kAntiAlias) - 0.5;\n        vec2 uv = (2.0 * aaCoord - iResolution.xy) / iResolution.y;\n\n        pixel += getColor(uv);\n    }\n\n    vec3 color = pixel / vec3(kAntiAlias * kAntiAlias);\n\n    color = pow(color, vec3(1.f / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}