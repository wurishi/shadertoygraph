{"ver":"0.1","info":{"id":"7ltGzl","date":"1636583205","viewed":316,"name":"vortex|blackhole","username":"Carandiru","description":"vortex of cellular automata","likes":5,"published":3,"flags":32,"usePreview":0,"tags":["automata","cellular","vortex","whirlpool"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// vortex|blackhole by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/7ltGzl\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    float v = textureLod(iChannel0, uv, 0.0f).x;\n    \n    vec3 color = vec3(0);\n    \n    color = vec3(v);\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// vortex|blackhole by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/7ltGzl\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0f * uv - 1.0f;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec2 nv = rotate(uv, -3.14f/1.0f);\n    float n = textureLod(iChannel0, fragCoord/1024.0f, 0.0f).r;\n        \n    float d = dot(uv,uv);\n    \n    float m = 0.09f;\n    float v = 0.0f;\n    \n    v = clamp((m * m) / (d - 0.1f), 0.0f, 1.0f);\n    \n    vec2 dir = normalize(nv + uv);\n    \n    nv = nv + v * (dir); \n    \n    float c = 0.0f;\n    \n    nv = rotate(nv, iTime);\n    c = textureLod(iChannel1, nv, 0.0f).r;\n    c = v + (1.0f - c) * v;\n    \n    \n    uv.x = (uv.x * 0.5f - uv.y * 2.0f);\n\n    for (float i = 0.001f; i < 4.0f; ++i)\n    {\n        d = dot(nv, nv) * d;\n        v = clamp((m * m) / (d - (0.15f * i + i * 0.1f * d)), 0.0f, 1.0f);\n\n        dir = normalize(nv - uv);\n\n        nv = uv + v * (dir) * 0.3333333f;\n        \n        float c2 = 0.0f;\n\n        c2 = textureLod(iChannel2, nv, 0.0f).r;\n\n        c += v * (smoothstep(0.9f,0.2f,abs(sqrt(d)))) * c2;\n    }   \n    \n    d = dot(nv, nv) * d * n;\n    v = clamp((m * m) / (d), 0.0f, 1.0f);\n\n    dir = normalize(nv + uv);\n\n    nv = uv + v * (dir) * 10.0f;\n\n    float c2 = 0.0f;\n\n    c2 = textureLod(iChannel2, nv, 0.0f).r;\n\n    c += v * c2;\n\n    \n    fragColor = vec4(c,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// vortex|blackhole by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/7ltGzl\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n#define fma(a,b,c) (a*b+c)\n\nvec2 rotate( in vec2 p, in float angle )\n{\n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}","name":"Common","description":"","type":"common"}]}