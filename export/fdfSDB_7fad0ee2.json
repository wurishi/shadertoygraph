{"ver":"0.1","info":{"id":"fdfSDB","date":"1619118765","viewed":150,"name":"Paint Swipe Shader","username":"Neblig","description":"based on https://www.shadertoy.com/view/sdjGRc\nTrying to emulate a splattery paint swipe","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","paint","art","swipe","splatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAGIC_BOX_ITERS = 11; //Adjust this: higher = more detail, 11\nconst float MAGIC_BOX_MAGIC = .6; //This number is scary, dont mess with it, .55\n\n\nfloat centerThreshold = 1.0; //Closer they are, further it goes?\nfloat edgeThreshold = 10.0;\n\nfloat splatFalloffSize = .7; //.9\nfloat splatCutoffSize = .1; //different dimesion\n\nvec4 defaultColor = vec4(0,0,0,0);\n \n//float temp = glutGet(GLUT_SCREEN_WIDTH/HEIGHT);\n\n\n//Fractal from https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\nfloat euclideanDistance(vec2 a, vec2 b){\n    return sqrt(pow((a.x - b.x), 2.0) + pow((a.y - b.y), 2.0));\n}\n\nfloat lerp(float a, float b, float w)\n{\n  return a + w*(b-a);\n}\n\nbool inRange(vec2 a, vec2 b, float maxDist){\n    return (euclideanDistance(a, b)/iResolution.y) < maxDist;\n}\n\nvec4 overlayColors(vec4 first, vec4 second){\n    return first * first.w + second * (1.0 - first.w);\n}\n\nvec4 splatColor(vec2 splatCenter, vec4 paintColor, vec2 fragCoord, vec2 uv, float falloffMod)\n{\n\n    //FRACTAL FUN:\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.3*M*vec3(uv, 0.0);\n    \n    float result = magicBox(p);\n    // Scale to taste.  Also consider non-linear mappings.\n    //result *= 0.025; \n       //TODO: Scale to dist\n        //Removed this since can just scale threshold by distance\n        \n        \n    //Setup Colors (fun)\n    //vec3 paintColor = vec3(255.0, 0.0, 0.0);\n    //vec3 paintColor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4 retColor;\n    \n    //Now clamp them values\n    //Set threshold to inverse distance\n    float dist = euclideanDistance(fragCoord, splatCenter); //Pixels\n    float screenDist = dist/iResolution.y; //0 to 1 scale, percent of screen\n    \n    //float threshold = centerThreshold + slope * adjDist; //.25\n    float threshold = lerp(centerThreshold, edgeThreshold, screenDist/(splatFalloffSize*falloffMod + .1)); \n    \n    //circle\n    //if(screenDist/splatCutoffSize > splatCutoffSize){retColor = black;}\n    \n    if (result > threshold){\n        retColor = paintColor;\n    }else{\n        retColor = defaultColor;\n    }\n \n    \n\treturn retColor;\n}\n\n\n\nfloat closestTOnLine(vec2 p, vec2 a, vec2 b){\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    //Squared magnitude of ab\n    float atb2 = ab.x*ab.x + ab.y*ab.y;\n    \n    float ap_dot_ab = ap.x*ab.x + ap.y*ab.y;\n    \n    //Normalized distance from a to closest point\n    float t = ap_dot_ab / atb2;\n\n    t = min(max(t,0.0), 1.0);\n    \n    return t;    \n}\n\nvec2 closestPointToLine(vec2 p, vec2 a, vec2 b, float t){\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    \n    return a + ab * t;\n}\n\n\n\n//Get color based on distance from two splat centers\n//1 - get distance to the line\nvec4 getOneStreak(vec2 center1, vec2 center2, vec4 paintColor1, vec4 paintColor2, vec2 fragCoord, vec2 uv){\n     \n    //T is distance from A to B  (1 to 2) from 0 to 1\n    float t = closestTOnLine(fragCoord, center1, center2);\n    \n    vec2 closestPoint = closestPointToLine(fragCoord, center1, center2, t);\n     \n    float alphaLerp = mix(paintColor1.w, paintColor2.w, t);\n    \n    //updated\n    float adjFalloff = alphaLerp;\n    float newAlpha = 1.0;\n    float fadePoint = .3;\n    \n    if(alphaLerp < fadePoint){\n        newAlpha = alphaLerp;\n    }\n    \n    vec4 passPaint = vec4(paintColor1.xyz, newAlpha);\n    \n    if(inRange(closestPoint,fragCoord, splatCutoffSize)){\n        //return vec4(255.0, 0.0, 255.0, 1.0);\n        return splatColor(closestPoint, passPaint, fragCoord, uv, adjFalloff);\n    }\n    \n    return defaultColor;\n    \n   \n}\n\n\n\n\n//Return the color at a point, (0,0,0) alpha 0 by default\n\nvec4 getSplatColorAtPixel(vec2 fragCoord, vec2 uv){\n    vec4 c1 = vec4(255.0, 0.0, 0.0, 0.0);\n    vec4 c2 = vec4(255.0, 0.0, 0.0, .3);\n    \n    \n    vec4 c3 = vec4(0.0, 0.0, 255.0, .5);\n    vec4 c4 = vec4(.0, 0.0, 255.0, 1.);\n    \n    vec2 s1 = vec2(100.0,100.0);\n    vec2 s2 = vec2(300.0,300.0);\n    \n    vec2 s3 = vec2(100.0,300.0);\n    vec2 s4 = vec2(500.0,100.0);\n    \n    vec4 retColor = defaultColor;\n    \n    retColor = overlayColors(retColor, getOneStreak(s1, s2, c1, c2, fragCoord, uv));\n    retColor = overlayColors(retColor, getOneStreak(s2, s4, c3, c4, fragCoord, uv));\n    \n    \n    \n    \n    return retColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // scroll a certain number of screenfuls/second\n    uv.x += iTime * 0.2;\n    \n    //splatColor(s1, fragCoord, uv, c1);\n    vec4 dotColor = getSplatColorAtPixel(fragCoord,uv);\n    \n    //Alpha blending - replace black w Result from textures\n    vec4 result = overlayColors(dotColor, defaultColor);\n    \n    //vec2 temp = glGet(\"GL_VIEWPORT\");\n    \n    fragColor = result;\n}\n","name":"Image","description":"","type":"image"}]}