{"ver":"0.1","info":{"id":"4tVczy","date":"1536795026","viewed":162,"name":"Homestuck Aspect Heart","username":"dahart","description":"Homestuck aspect Heart. use mouse to scrub time.\nInspired by https://www.reddit.com/r/homestuck/comments/7dwqs5/heart_pixel_art/","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","animation","heart","pixelart","aspect","homestuck","nepeta","yokcos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#pragma optimize(off)\n\n// https://www.reddit.com/r/homestuck/comments/7dwqs5/heart_pixel_art/ (found via https://www.reddit.com/user/yokcos700/posts?sort=top)\n// https://g.redditmedia.com/wsQ2RZgpaaI7gJ6iN1qSvxvE9PgloyPJ6sycUDtNhM0.gif?fm=mp4&mp4-fragmented=false&s=fe1f38884e7c869d01de06e032900290\n// https://www.reddit.com/r/PixelArt/comments/7j0h0t/homestuck_aspects_oc/\n// http://mspaintadventures.wikia.com/wiki/Aspect\n// http://mspaintadventures.wikia.com/wiki/Aspect?file=ZodiacAspects.png\n\n//#define PIXELATE\n\nconst vec3 white  = vec3(1., 1., 1.);\nconst vec3 yellow = vec3(1., 1., 0.);\nconst vec3 red    = vec3(.9, .1, .1);\nconst vec3 blue   = vec3(0., .2, .9);\nconst vec3 black  = vec3(0., 0., 0.);\n\nconst vec3 pink   = vec3(1., .3, .7);\n\nconst int NP = 11;\n\n#define S(a,b,t) smoothstep(a,b,t)\n#define unlerp(a,b,t) ((t-a)/(b-a))\n#define v30 vec3(0.)\n\n// lump between a and b. \n// returns 0 when t is outside [a,b]\n// returns 1 at t=(a+b)/2.\n// smoothstep from center to either end (t==a, t==b)\nfloat L(float a, float b, float t) {\n    float u = unlerp(a, b, t);\n    return S(0., 1., 2.*u) * S(0., 1., 2. - u*2.);\n}\n\n// take [0, 1], return [0, .5] + [.5, 0]\nfloat mirror(float x) { return .5-abs(x-.5); }\n\nfloat N(float t) {\n    return fract(sin(t*10234.324)*123423.23512);\n}\n\nvec2 rot90(vec2 v) {\n    return vec2(v.y, -v.x);\n}\n\nconst vec2 X = vec2(1., 0.);\nconst vec3 nop = vec3(-1., 0., 1.);\nconst float pi = 4. * atan(1.); //3.14159265358979323;\nconst float tau = 8. * atan(1.); //2. * pi;\nconst float maxFloat = intBitsToFloat(0x7f7fffff);\n\nvec4 premult(vec4 color) {\n    return vec4(color.rgb * color.a, color.a);\n}\n\nvec4 premult(vec3 rgb, float alpha) {\n    return vec4(rgb * alpha, alpha);\n}\n\nvec4 comp(vec4 bg, vec4 fg) {\n    return fg + bg * (1. - fg.a);\n}\n    \nvec4 comp(vec4 bg, vec3 fg, float a) {\n    return vec4(fg + bg.rgb * (1. - a), bg.a + a);\n}\n    \nvec3 comp(vec3 bg, vec3 fg, float a) {\n    return fg + bg * (1. - a);\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3., p3 = p*p*p;\n    float q = a * (2.*a*a - 9.*b) / 27. + c;\n    float d = q*q + 4.*p3 / 27.;\n    float offset = -a / 3.;\n    if(d >= 0.) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27. / p3) * q / 2.) / 3.;\n    float m = cos(v), n = sin(v)*1.732050808;//sqrt(3.);\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.) + offset;\n}\n\n// Test if point p crosses line (a, b), returns sign of result\nfloat testCross(vec2 a, vec2 b, vec2 p) {\n    return sign((b.y-a.y) * (p.x-a.x) - (b.x-a.x) * (p.y-a.y));\n}\n\n// Determine which side we're on (using barycentric parameterization)\nfloat signBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{ \n    vec2 a = C - A, b = B - A, c = p - A;\n    vec2 bary = vec2(c.x*b.y-b.x*c.y,a.x*c.y-c.x*a.y) / (a.x*b.y-b.x*a.y);\n    vec2 d = vec2(bary.y * 0.5, 0.0) + 1.0 - bary.x - bary.y;\n    return mix(sign(d.x * d.x - d.y), mix(-1.0, 1.0, \n        step(testCross(A, B, p) * testCross(B, C, p), 0.0)),\n        step((d.x - d.y), 0.0)) * testCross(A, C, B);\n}\n\n//https://www.shadertoy.com/view/ltXSDB\n// Find the signed distance from a point to a bezier curve\n// returns a vec4: (dist to boundary, dist to curve, sign, parameter [0-1])\nvec4 sdBezier(vec2 p, vec3 A, vec3 B, vec3 C)\n{    \n    //B = (4.0 * B - A - C) / 2.0;\n    // handle instability when B is midpoint between A and C\n    //B = vec3(mix(B.xy + vec2(1e-4), B.xy, abs(sign(B.xy * 2.0 - A.xy - C.xy))), B.z);\n    \n    vec3 a = B - A;\n    vec3 b = A - B * 2.0 + C;\n    vec3 c = a * 2.0;\n    vec2 d = A.xy - p;\n    \n    vec3 k = vec3(3.*dot(a.xy,b.xy),2.*dot(a.xy,a.xy)+dot(d.xy,b.xy),dot(d.xy,a.xy)) / dot(b.xy,b.xy);      \n    vec3 t = clamp(solveCubic(k.x, k.y, k.z), 0., 1.);\n    vec3 it = vec3(1.0) - t;\n\n    vec3 pos0 = A + (c + b*t.x)*t.x;\n    vec3 pos1 = A + (c + b*t.y)*t.y;\n    vec3 pos2 = A + (c + b*t.z)*t.z;\n\n    float dis0 = length(pos0.xy - p) - pos0.z;\n    float dis1 = length(pos1.xy - p) - pos1.z;\n    float dis2 = length(pos2.xy - p) - pos2.z;\n    \n    float minT = t.x;\n    vec3 minP = pos0;\n    float minDis = dis0;\n    if (dis1 < minDis) { minDis = dis1; minT = t.y; minP = pos1; }\n    if (dis2 < minDis) { minDis = dis2; minT = t.z; minP = pos2; }\n            \n    return vec4(minDis, minDis + minP.z, signBezier(A.xy, B.xy, C.xy, p), minT);\n}\n\nfloat sdBezierMin2(vec2 p, vec3 a, vec3 b, vec3 c, float dist) {\n    vec4 d = sdBezier(p, a, b, c);\n    if (d.x < dist) return d.x;\n    else return dist;\n}\n\nfloat sdBezier2(vec2 p, vec3 a, vec3 b, vec3 c) {\n    vec4 d = sdBezier(p, a, b, c);\n    return d.x;\n}\n\n// returns a vec4: (dist to boundary, dist to curve, sign, parameter [0-1])\nvec4 sdCurve(vec2 p, int n, vec3[NP] pts) {\n    int nn = n - 1;\n    vec4 d = vec4(maxFloat);    \n    vec3 pp1 = mix(pts[0], pts[1], -0.001), pp2;\n    float oofn = 1.0 / (float(n));\n    for (int i = 0; i < nn+min(0,iFrame); i++) {\n        pp2 = 0.5 * (pts[i] + pts[i+1]);\n        vec4 e = sdBezier(p, pp1, pts[i], pp2);\n        pp1 = pp2;\n        if (e.x < d.x) d = vec4(e.xyz, (e.w+float(i))*oofn);\n    }\n    pp2 = pts[nn];\n    vec4 e = sdBezier(p, pp1, pts[nn], pp2);\n    if (e.x < d.x) d = vec4(e.xyz, (e.w+float(nn))*oofn);\n\n    // signBezier fails on the first & last segments, here's a patch\n    if (d.w <= oofn) {\n        d.z = dot(p - pts[0].xy, rot90( pts[0].xy - pts[1].xy ) ) < 0. ? 1. : -1.;\n    }\n    else if (d.w >= 1.-oofn) {\n        d.z = dot(p - pts[nn].xy, rot90( pts[nn-1].xy - pts[nn].xy ) ) < 0. ? 1. : -1.;\n    }\n\n    return d;\n}\n\n// 2 output vectors: curvePoint, curveTangent\nvoid evalBezier(float t, vec2 a, vec2 b, vec2 c, out vec2 curvePoint, out vec2 curveTangent) {\n    t = clamp(t, 0., 1.);\n    curvePoint = mix(mix(a, b, t), mix(b, c, t), t);\n    curveTangent = 2. * (( a + c - 2. * b ) * t + ( b - a ));\n}\n\n// 2 output vectors: curvePoint, curveTangent\nvoid evalCurve(float t, int n, vec3[NP] pts, out vec2 curvePoint, out vec2 curveTangent) {\n    float nt = clamp(t, 0.0001, .9999) * float(n);\n    int j = int(nt);\n    int i = max(0, j - 1);\n    int k = min(n-1, j + 1);\n    float tSegment = nt - float(j);\n    \n    vec2 a = pts[i].xy;\n    vec2 b = pts[j].xy;\n    vec2 c = pts[k].xy;\n    \n    a = mix(a, b, .5);\n    c = mix(b, c, .5);\n    \n    curvePoint = mix(mix(a, b, tSegment), mix(b, c, tSegment), tSegment);\n    vec2 ba = b-a;\n    curveTangent = 2. * (( c - b - ba ) * tSegment + ( ba ));\n}\n\nstruct Hit {\n    float dBound;\n    float dCurve;\n    float sign;\n    vec2 pos;\n    vec2 tangent;\n    vec3 normal;\n    vec2 uv;\n};\n\n// vec4 d is the same format as return from sdBezier: vec4( dBound, dCurve, sign, param )\nvec2 calcBezierUv(float dBound, float dCurve, float sign, float param) {\n    return vec2(param, .5 + .5 * sign * dCurve / (abs(dBound) + dCurve));\n}\n\nvoid calcBezierHit(vec2 uv, vec3 a, vec3 b, vec3 c, out Hit hit) {\n    // Hit hit;\n    vec4 d = sdBezier(uv, a, b, c);\n    hit.dBound = d.x;\n    hit.dCurve = d.y;\n    hit.sign = d.z;\n    hit.uv = calcBezierUv(d.x, d.y, d.z, d.w);\n    evalBezier(d.w, a.xy, b.xy, c.xy, hit.pos, hit.tangent);\n    float z = sin(hit.uv.y * pi);\n    hit.normal = normalize(vec3( (1.-z)*normalize(uv - hit.pos), .25*z));\n    // return hit;\n}\n\n//Hit \nvoid calcCurveHit(vec2 uv, int n, vec3[NP] pts, out Hit hit) {\n    // Hit hit;\n    vec4 d = sdCurve(uv, n, pts);\n    hit.dBound = d.x;\n    hit.dCurve = d.y;\n    hit.sign = d.z;\n    hit.uv = calcBezierUv(d.x, d.y, d.z, d.w);\n    evalCurve(d.w, n, pts, hit.pos, hit.tangent);\n    float z = sin(hit.uv.y * pi);\n    hit.normal = normalize(vec3( (1.-z)*normalize(uv - hit.pos), .25*z));\n    // return hit;\n}\n\nvec3 calcCurveRoundNormal(vec2 uv, Hit hit) {\n    float z = sin(hit.uv.y * pi);\n    return normalize(vec3( (1.-z)*normalize(uv - hit.pos), .25*z));\n}\n\nvec3 calcCurveTentNormal(vec2 uv, Hit hit) {\n    float z = abs(hit.uv.y);\n    return normalize(vec3( (1.-z)*normalize(uv - hit.pos), .25*z));\n}\n\n// a & b are two points w/ radius. a.xy = 2d point, a.z = radius\n// u=along curve v=perpendicular\nfloat sdFatLine2All(vec2 p, vec3 a, vec3 b, out float distToCurve, out vec2 uv) {\n    vec2 d = b.xy - a.xy;\n    vec2 pd = p - a.xy;\n    float t = dot(pd, d) / dot(d, d);\n    t = min(1.0, max(0.0, t));\n    vec2 cp = a.xy + t * d;\n    \n    vec2 n = p - cp;\n    distToCurve = length(n);\n    \n    // remember a.z & b.z are radius\n    float cr = mix(a.z, b.z, t);\n    float v = .5 + .5 * dot(vec2(-pd.y, pd.x), normalize(d)) / cr;\n    uv = vec2(t, v);\n\n    float distToBoundary = distToCurve - cr;\n    \n    return distToBoundary;\n}\n\nfloat sdFatLine2(vec2 p, vec3 a, vec3 b)\n{\n    vec2 d = b.xy - a.xy;\n    vec2 pd = p - a.xy;\n    float t = dot(pd, d) / dot(d, d);\n    t = min(1.0, max(0.0, t));\n    vec2 cp = a.xy + t * d;\n    \n    vec2 n = p - cp;\n    float distToCurve = length(n);\n    \n    // remember a.z & b.z are radius\n    float cr = mix(a.z, b.z, t);\n    float v = .5 + .5 * dot(vec2(-pd.y, pd.x), normalize(d)) / cr;\n//    uv = vec2(t, v);\n\n    float distToBoundary = distToCurve - cr;\n    \n    return distToBoundary;\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat remap(float v, float min1, float max1, float min2, float max2) {\n    return min2 + (max2 - min2) * (v - min1) / (max1 - min1);\n}\n\nfloat bias(float x, float b) { return pow(x,log(b)/log(0.5)); }\n\nfloat gain(float x, float g) { return (x<0.5) ? bias(2.*x,1.-g)/2. : 1. - bias(2.-2.*x,1.-g)/2.; }\n\nfloat aaFloor(float x) {\n    float dx = 2. * length(vec2(dFdx(x), dFdy(x)));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? x - fx : remap(fx, idx, 1., x-fx, x);\n}\n\nfloat aaFract(float x) {\n    float dx = 2. * length(vec2(dFdx(x), dFdy(x)));\n    float fx = fract(x), idx = 1. - dx;\n    return (fx < idx) ? fx : remap(fx, idx, 1., fx, 0.);\n}\n\nfloat stairs(float x, float steps) {\n    return floor(x * steps) / steps;\n}\n\nfloat stairs2(float x, float steps) {\n    return round(x * steps) / steps;\n}\n\nfloat escalator(float x, float steps, float time) {\n    float dx = 1. / steps;\n    x = remap(x, 0., 1., -dx/2., 1.+dx/2.) + dx/2.;\n    float ex = (x - time*dx) * steps;\n    float ey = (aaFloor(ex) + time) * dx;\n    return clamp(ey, 0., 1.);\n}\n\nvec2 escalatorId(float x, float steps, float time) {\n    float dx = 1. / steps;\n    x = remap(x, 0., 1., -dx/2., 1.+dx/2.) + dx/2.;\n    float ex = (x - time*dx) * steps;\n    float id = floor(ex);\n    float ey = (aaFloor(ex) + time) * dx;\n    return vec2(clamp(ey, 0., 1.), id);\n}\n\nfloat saw(float x) {\n    float mx = mod(x,1.);\n    return 2. * min(mx, 1.-mx);\n}\n\nfloat dline(vec2 p, vec2 lp, vec2 ld) {\n    return dot(p-lp, ld);\n}\n\nfloat sqr(float x) { return x*x; }\n\nfloat d2a (vec2 d) {\n    return atan(d.y, d.x);\n}\n\nvec2 a2d (float a) {\n    return vec2(cos(a), sin(a));\n}\n\nfloat sdEdgeNormal(vec2 x, vec2 p, vec2 normal) {\n    return dot(x-p, normal);\n}\n\nfloat sdEdgePoints(vec2 x, vec2 p1, vec2 p2) {\n    return dot(x-p1, normalize(rot90(p2 - p1)));\n}\n\n\n// lots of distance functions from IQ\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdBox3( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox2( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat udRoundBox( vec2 p, vec2 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat udBox( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCircle( vec2 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCapsule2( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float distToCenter = length( pa - ba*h );\n    float distToBoundary = distToCenter - r;\n    return distToBoundary;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// d1 minus d2\nfloat sdSubtract( float d1, float d2 )\n{\n    return max(d1, -d2);\n}\n\n// d1 union d2\nfloat sdUnion( float d1, float d2 )\n{\n    return min(d1, d2);\n}\n\nstruct NepetaData {\n    vec2 x;\n    vec2 y;\n    vec3 pt0;\n    vec3 pt1;\n};\n\nconst NepetaData[] ND = NepetaData[5](\n    NepetaData(vec2(.6, 1.1), vec2(-.1, .55), vec3(vec2(.8, .1), .15), vec3(vec2(.74, .4), .1)),\n    NepetaData(vec2(.6, 1.1), vec2(-.1, .55), vec3(vec2(.85, .0), .20), vec3(vec2(.72, .4), .1)),\n    NepetaData(vec2(.77, 1.1), vec2(.4, .55), vec3(vec2(.80, .48), .03), vec3(vec2(.99, .45), .03)),\n    NepetaData(vec2(.2, .7), vec2(.25, .5), vec3(vec2(.70, .44), .03), vec3(vec2(.43, .30), .03)),\n    NepetaData(vec2(.2, .7), vec2(.25, .5), vec3(vec2(.43, .30), .03), vec3(vec2(.24, .50), .03))\n);\n\nvoid nep(NepetaData nd, vec2 uv, float dx, vec3 skinColor, inout vec4 color)\n{\n    if (uv.x > nd.x[0] && uv.x < nd.x[1] && uv.y > nd.y[0] && uv.y < nd.y[1]) {\n        float d = sdFatLine2(uv, nd.pt0, nd.pt1);\n        color = comp(color, premult(skinColor, S(0., -dx, d )));\n    }\n}\n\nvec4 nepeta(vec2 uv, float dx) \n{\n    vec3 skinColor = pink*.5;\n    vec4 color = vec4(0.);\n    float d = 0.;\n    dx *= 2.5;\n\n#if 1\n    for (int i = 0; i < 5; i++) {\n        nep(ND[i], uv, dx, skinColor, color);\n    }\n#else\n    // body\n    if (uv.x > .6 && uv.y < .55) {\n        d = sdFatLine2(uv, vec3(vec2(.8, .1), .15), vec3(vec2(.74, .4), .1));\n        color = comp(color, premult(skinColor, S(0., -dx, d )));\n        d = sdFatLine2(uv, vec3(vec2(.85, .0), .20), vec3(vec2(.72, .4), .1));\n        color = comp(color, premult(skinColor, S(0., -dx, d )));\n        //color += vec4(.5); // show bbox\n    }\n    \n    // left arm\n    if (uv.x > .8 && uv.y < .55 && uv.y > .4) {\n        d = sdFatLine2(uv, vec3(vec2(.80, .48), .03), vec3(vec2(.99, .45), .03));\n        if (d < dx) color = comp(color, premult(skinColor, S(0., -dx, d )));\n        //color += vec4(.5); // show bbox\n    }\n    \n    // right arm\n    if (uv.x > .2 && uv.x < .7 && uv.y > .25 && uv.y < .5) {\n        d = sdFatLine2(uv, vec3(vec2(.70, .44), .03), vec3(vec2(.43, .30), .03));\n        color = comp(color, premult(skinColor, S(0., -dx, d )));\n        d = sdFatLine2(uv, vec3(vec2(.43, .30), .03), vec3(vec2(.24, .50), .03));\n        color = comp(color, premult(skinColor, S(0., -dx, d )));\n        //color += vec4(.5); // show bbox\n    }\n#endif\n\n    // claws\n    vec2 cuv = vec2(uv.x - .03*L(.48, .65, uv.y), uv.y);\n    if (uv.x > .1 && uv.x < .3 && uv.y > .49 && uv.y < .7) {\n        float r = 0.006;\n        const vec2[4] a = vec2[4](vec2(.21, .50), vec2(.225, .50), vec2(.24, .50), vec2(.255, .50) );\n        const vec2[4] b = vec2[4](vec2(-.11, .07),vec2(-.12, .1),vec2(-.12, .13),vec2(-.09, .12));\n        const vec2[4] c = vec2[4](vec2(.015, -.02),vec2(.004, -.02),vec2(.004, -.02),vec2(.0, -.02));\n        for (int i = 0; i < 4+min(0,iFrame); i++) {\n            d = sdFatLine2(cuv, vec3(a[i], r*2.), vec3(a[i]+b[i], r));\n            color = comp(color, premult(skinColor, S(0., -dx, d )));\n            d = sdFatLine2(cuv, vec3(a[i]+b[i], r), vec3(a[i]+b[i]+c[i], r));\n            color = comp(color, premult(skinColor, S(0., -dx, d )));\n        }\n        //color += vec4(.5); // show bbox\n    }\n    \n    // head\n    if (uv.x > .55 && uv.x < .8 && uv.y > .4 && uv.y < .75) {\n        d = sdFatLine2(uv, vec3(vec2(.67, .53), .1), vec3(vec2(.67, .58), .1));\n        // horns / cat ears\n        d = sdUnion(d, sdFatLine2(uv, vec3(.73, .64, .03), vec3(.76, .71, 0.)));\n        d = sdUnion(d, sdFatLine2(uv, vec3(.62, .65, .03), vec3(.60, .71, 0.)));\n        if (d < dx) {\n            //d = sdSubtract(d, sdFatLine2(uv, vec3(vec2(.70, .85), .2), vec3(vec2(.70, .87), .2)));\n            // bangs\n            d = sdSubtract(d, sdFatLine2(uv, vec3(vec2(.71, .68), .015), vec3(vec2(.66, .65), .0)));\n            d = sdSubtract(d, sdFatLine2(uv, vec3(vec2(.68, .69), .015), vec3(vec2(.62, .65), .0)));\n            // mouth\n            float md = abs(uv.y - .53 + .01*sin(uv.x*66.)) - .01*L(.55, .74, uv.x) + 0.006;\n            // fangs\n            md = min(md, sdFatLine2(uv, vec3(vec2(.625, .50), 0.), vec3(vec2(.62, .530), .003)));\n            md = min(md, sdFatLine2(uv, vec3(vec2(.665, .50), 0.), vec3(vec2(.67, .525), .003)));\n            d = sdSubtract(d, md);\n            // nose, eyes\n            d = sdSubtract(d, length(uv-vec2(.65, .58)) - 0.005);\n            d = sdSubtract(d, length(uv-vec2(.61, .605)) - 0.01);\n            d = sdSubtract(d, length(uv-vec2(.70, .60)) - 0.01);\n            color = comp(color, premult(skinColor, S(0., -dx, d )));\n        }\n        //color += vec4(.5); // show bbox\n    }\n        \n    return color;\n}\n\nvec4 circles(vec2 uv, float time, float r, const float dx) \n{\n    vec4 color = vec4(0.);\n    float phase = -0.;\n    float r2 = mod(3.*time - phase, 3.);\n    float r1 = r2 - .5;\n    if (r >= r1 && r <= r2) {\n        float dx2 = dx * 2.5; // 1 for padding, 1.5 for antialiasing\n        color = premult(vec4(pink*.6, S(r1+dx, r1+dx2, r)*S(r2-dx, r2-dx2, r)));\n\n        r2 -= .1;\n        r1 = r2 - .3;\n        if (r >= r1 && r <= r2) {\n            float dx2 = dx * 2.5; // 1 for padding, 1.5 for antialiasing\n            color = comp(color, premult(vec4(pink*.8, S(r1+dx, r1+dx2, r)*S(r2-dx, r2-dx2, r))));\n\n            r2 -= .1;\n            r1 = r2 - .1;\n            if (r >= r1 && r <= r2) {\n                float dx2 = dx * 2.5; // 1 for padding, 1.5 for antialiasing\n                color = comp(color, premult(vec4(.5*(pink+white), S(r1+dx, r1+dx2, r)*S(r2-dx, r2-dx2, r))));\n            }\n        }\n    }\n\n        \n    return color;\n}\n\nconst vec3[] pts1 = vec3[NP](\n    vec3(vec2(.9,  -0.1), .01),\n    vec3(vec2(.9,  0.05), .01),\n    vec3(vec2(.71, .05), .01),\n    vec3(vec2(.87, .27), .01),\n    vec3(vec2(.79, .45), .01),\n    vec3(vec2(1., .50), .01),\n    v30,v30,v30,v30,v30 //,v30,v30,v30,v30,v30\n);\nconst int npts1 = 6;\n\nconst vec3[] pts2 = vec3[NP](\n    vec3(vec2(-0.03,  .313), .01),\n    vec3(vec2(.05,  .25), .01),\n    vec3(vec2(.15, .3), .01),\n    vec3(vec2(.25, .1), .01),\n    vec3(vec2(.1, .15), .01),\n    vec3(vec2(0., .05), .01),\n    v30,v30,v30,v30,v30 //,v30,v30,v30,v30,v30\n);\nconst int npts2 = 6;\n\nconst vec3[] pts3 = vec3[NP](\n    vec3(vec2(.33, .00), .01),\n    vec3(vec2(.35, .10), .01),\n    vec3(vec2(.45, .05), .01),\n    vec3(vec2(.50, .15), .01),\n    vec3(vec2(.55, .15), .01),\n    vec3(vec2(.69, .28), .01),\n    vec3(vec2(.65, .10), .01),\n    vec3(vec2(.68, .05), .01),\n    vec3(vec2(.68, .00), .01),\n    v30,v30//,v30,v30,v30,v30,v30\n);\nconst int npts3 = 9;\n        \nconst vec3[] pts4 = vec3[NP](\n    vec3(vec2(.65, .24), .01),\n    vec3(vec2(.70, .35), .01),\n    vec3(vec2(.53, .45), .01),\n    vec3(vec2(.58, .55), .01),\n    vec3(vec2(.50, .65), .01),\n    vec3(vec2(.63, .75), .01),\n    vec3(vec2(.60, .90), .01),\n    vec3(vec2(.74, .95), .01),\n    vec3(vec2(.73, 1.0), .01),\n    v30,v30 //,v30,v30,v30,v30,v30\n);\nconst int npts4 = 9;\n        \nconst vec3[] pts5 = vec3[NP](\n    vec3(vec2(.00, .50), .01),\n    vec3(vec2(.10, .50), .01),\n    vec3(vec2(.10, .40), .01),\n    vec3(vec2(.25, .35), .01),\n    vec3(vec2(.35, .45), .01),\n    vec3(vec2(.40, .65), .01),\n    vec3(vec2(.45, .80), .01),\n    vec3(vec2(.30, .85), .01),\n    vec3(vec2(.25, 1.0), .01),\n    v30,v30 //,v30,v30,v30,v30,v30\n);\nconst int npts5 = 9;\n        \nconst vec3[] pts6 = vec3[NP](\n    vec3(vec2(-.02, .90), .01),\n    vec3(vec2(.10, .80), .01),\n    vec3(vec2(.20, .88), .01),\n    vec3(vec2(.30, .75), .01),\n    vec3(vec2(.40, .70), .01),\n    vec3(vec2(.50, .74), .01),\n    vec3(vec2(.60, .80), .01),\n    vec3(vec2(.70, .80), .01),\n    vec3(vec2(.80, .75), .01),\n    vec3(vec2(.90, .90), .01),\n    vec3(vec2(1.0, .88), .01)\n    //,v30,v30,v30,v30,v30\n);\nconst int npts6 = 11;\n\n\nstruct VesselData {\n    float x1;\n    float x2;\n    float y1;\n    float y2;\n    float t;\n    int npts;\n    vec3 pts[NP];\n};\n\nconst VesselData[] VD = VesselData[6](\n    VesselData(0.72, 1.01, -0.1, 0.53, 0.40, npts1, pts1),\n    VesselData(-0.1, 0.25, -0.1, 0.33, 0.20, npts2, pts2),\n    VesselData(0.30, 1.01, -0.1, 0.29, 0.20, npts3, pts3),\n    VesselData(0.50, 0.78, 0.20, 1.10, 0.20, npts4, pts4),\n    VesselData(-0.1, 0.46, 0.34, 1.10, 0.40, npts5, pts5),\n    VesselData(-0.1, 1.01, 0.71, 0.93, 0.45, npts6, pts6)\n);\n\nvoid vessel(VesselData vd, vec2 uv, float time, float dx, \n    vec3 vesselColor, inout vec4 color) \n{\n    if (uv.x > vd.x1 && uv.x < vd.x2 && uv.y > vd.y1 && uv.y < vd.y2) {\n        vec4 d = sdCurve(uv, vd.npts, vd.pts);\n        float t1 = fract(time*.5 + vd.t);\n        float t2 = fract(t1+.5);\n        vec2 p1, p2, tan1, tan2;\n        evalCurve(t1, vd.npts, vd.pts, p1, tan1);\n        evalCurve(t2, vd.npts, vd.pts, p2, tan2);\n        d.x = smin(d.x, length(uv-p1)-.02, .05);\n        d.x = smin(d.x, length(uv-p2)-.02, .05);\n        if (d.x < dx) color = comp(color, premult(vesselColor, S(0., -dx, d.x)));\n    }\n}\n\nvec4 vessels(vec2 uv, float time, float dx) \n{\n    vec3 vesselColor = pink*.25;\n    vec4 color;\n#if 1\n    for (int i = 0; i < 6; i++) {\n        vessel(VD[i], uv, time, dx, vesselColor, color);        \n    }\n#else\n    if (uv.x > .72 && uv.y < .53) {\n        vec4 d = sdCurve(uv, npts1, pts1);\n        float t1 = fract(time*.5+.4);\n        float t2 = fract(t1+.5);\n        vec2 p1, p2, tan1, tan2;\n        evalCurve(t1, npts1, pts1, p1, tan1);\n        evalCurve(t2, npts1, pts1, p2, tan2);\n        d.x = smin(d.x, length(uv-p1)-.02, .05);\n        d.x = smin(d.x, length(uv-p2)-.02, .05);\n        if (d.x < dx) color = comp(color, premult(vesselColor, S(0., -dx, d.x)));\n        //color += vec4(.5); // show bbox\n    } else if (uv.x < .25 && uv.y < .33) {\n        vec4 d = sdCurve(uv, npts2, pts2);\n        float t1 = fract(time*.5+.2);\n        float t2 = fract(t1+.5);\n        vec2 p1, p2, tan1, tan2;\n        evalCurve(t1, npts2, pts2, p1, tan1);\n        evalCurve(t2, npts2, pts2, p2, tan2);\n        d.x = smin(d.x, length(uv-p1)-.02, .05);\n        d.x = smin(d.x, length(uv-p2)-.02, .05);\n        if (d.x < dx) color = comp(color, premult(vesselColor, S(0., -dx, d.x)));\n        //color += vec4(.5); // show bbox\n    } else if (uv.y < .29 && uv.x > .30) {\n        vec4 d = sdCurve(uv, npts3, pts3);\n        float t1 = fract(time*.5+.2);\n        float t2 = fract(t1+.5);\n        vec2 p1, p2, tan1, tan2;\n        evalCurve(t1, npts3, pts3, p1, tan1);\n        evalCurve(t2, npts3, pts3, p2, tan2);\n        d.x = smin(d.x, length(uv-p1)-.02, .05);\n        d.x = smin(d.x, length(uv-p2)-.02, .05);\n        if (d.x < dx) color = comp(color, premult(vesselColor, S(0., -dx, d.x)));\n        //color += vec4(.5); // show bbox\n    } \n    \n    if (uv.x > .50 && uv.x < .78 && uv.y > .2) {\n        vec4 d = sdCurve(uv, npts4, pts4);\n        float t1 = fract(time*.5+.2);\n        float t2 = fract(t1+.5);\n        vec2 p1, p2, tan1, tan2;\n        evalCurve(t1, npts4, pts4, p1, tan1);\n        evalCurve(t2, npts4, pts4, p2, tan2);\n        d.x = smin(d.x, length(uv-p1)-.02, .05);\n        d.x = smin(d.x, length(uv-p2)-.02, .05);\n        if (d.x < dx) color = comp(color, premult(vesselColor, S(0., -dx, d.x)));\n        //color += vec4(.5); // show bbox\n    }\n    \n    if (uv.x < .46 && uv.y > .34) {\n        vec4 d = sdCurve(uv, npts5, pts5);\n        float t1 = fract(time*.5+.4);\n        float t2 = fract(t1+.5);\n        vec2 p1, p2, tan1, tan2;\n        evalCurve(t1, npts5, pts5, p1, tan1);\n        evalCurve(t2, npts5, pts5, p2, tan2);\n        d.x = smin(d.x, length(uv-p1)-.02, .05);\n        d.x = smin(d.x, length(uv-p2)-.02, .05);\n        if (d.x < dx) color = comp(color, premult(vesselColor, S(0., -dx, d.x)));\n        //color += vec4(.5); // show bbox\n    }\n    \n    if (uv.y > .71 && uv.y < .93) {\n        vec4 d = sdCurve(uv, npts6, pts6);\n        float t1 = fract(time*.5+.45);\n        float t2 = fract(t1+.5);\n        vec2 p1, p2, tan1, tan2;\n        evalCurve(t1, npts6, pts6, p1, tan1);\n        evalCurve(t2, npts6, pts6, p2, tan2);\n        d.x = smin(d.x, length(uv-p1)-.02, .05);\n        d.x = smin(d.x, length(uv-p2)-.02, .05);\n        if (d.x < dx) color = comp(color, premult(vesselColor, S(0., -dx, d.x)));\n        //color += vec4(.5); // show bbox\n    }\n#endif\n\n    return color;\n}\n\nvec4 heartSymbol(vec2 uv, float time, float dx) {\n    uv = (uv - vec2(.5)) * (.7 - .1 * S(1., .9, time) * S(.3, .4, time)) + vec2(.5);\n    vec4 color = vec4(0.);\n\n    Hit hit;\n    \n    if (uv.x < .50) {\n        const vec3[3] pts = vec3[3](\n            vec3(vec2(.4, .6), .11), \n            vec3(vec2(.6, .4), .1), \n            vec3(vec2(.6, .2), .1)\n        );\n        \n        //hit = \n        calcBezierHit(uv, pts[0], pts[1], pts[2], hit);\n        //hit.dBound = sdSubtract(hit.dBound, sdBox2( uv - vec2(.6, .5), vec2(.1, .4)));\n        \n        if (length(uv - vec2(.45, .52)) < .09) {\n            Hit vhit, vhit2;\n\n            //*\n            const vec3[NP] pts = vec3[NP](\n                vec3(vec2(.52, .59), .005), \n                vec3(vec2(.48, .58), .008),\n                vec3(vec2(.47, .57), .010), \n                vec3(vec2(.46, .52), .008),       \n                vec3(vec2(.40, .50), .010), \n                vec3(vec2(.38, .40), .003),\n                v30,v30,v30,v30,v30//,v30,v30,v30,v30,v30\n            );\n            \n            //vhit = \n            calcCurveHit(uv, 6, pts, vhit);\n            if (hit.dBound < 0. && vhit.dBound < 0.) {\n                hit.normal = vhit.normal;\n            }\n            \n            //vhit2 = \n            calcBezierHit(\n                uv, vec3(.48, .579, .008), vec3(.45, .58, .006), vec3(.44, .55, .004), vhit2);\n            if (hit.dBound < 0. && vhit2.dBound < 0. && vhit2.dCurve < vhit.dCurve) {\n                hit.normal = normalize(mix(hit.normal, vhit2.normal, S(dx*1., -dx*1., vhit2.dCurve-vhit.dCurve)));\n            }\n            //*/\n            \n            //vhit2 = \n            calcBezierHit(\n                uv, vec3(.46, .53, .010), vec3(.46, .51, .007), vec3(.45, .49, .004), vhit2);\n            if (hit.dBound < 0. && vhit2.dBound < 0. && vhit2.dCurve < vhit.dCurve) {\n                hit.normal = normalize(mix(hit.normal, vhit2.normal, S(dx, -dx, vhit2.dCurve-vhit.dCurve)));\n            }\n\n            //vhit2 = \n            calcBezierHit(\n                uv, vec3(.43, .51, .010), vec3(.39, .52, .007), vec3(.37, .50, .004), vhit2);\n            if (hit.dBound < 0. && vhit2.dBound < 0. && vhit2.dCurve < vhit.dCurve) {\n                hit.normal = normalize(mix(hit.normal, vhit2.normal, S(dx, -dx, vhit2.dCurve-vhit.dCurve)));\n            }\n\n            //color.y += .2; // show bound\n        }\n    } else {\n         const vec3 heartPts[NP] = vec3[NP](\n             vec3(vec2(.50, .645), .003)\n            ,vec3(vec2(.54, .68), .010)\n            ,vec3(vec2(.61, .70), .017)\n            ,vec3(vec2(.69, .66), .025)\n            ,vec3(vec2(.70, .54), .025)\n            ,vec3(vec2(.56, .40), .015)\n            ,vec3(vec2(.50, .30), .005)\n            ,vec3(vec2(.495, .22), .000)\n             \n            ,v30,v30,v30//,v30,v30,v30,v30,v30 \n        );\n              \n        //hit = \n        calcCurveHit(vec2(uv.x-0.01, uv.y), 8, heartPts, hit);\n    }    \n        \n    const vec3 lightDir  = normalize(vec3(-1., 1., 1.5));\n    const vec3 shadowDir = normalize(vec3(1., -1., 0.5));\n        \n    float spec = pow(clamp(dot(hit.normal, lightDir), 0., 1.), 10.);\n    float shad = .25*pow(clamp(dot(hit.normal, shadowDir), 0., 1.), 3.);\n    if (uv.x < .5) shad += .25 * S(.1, .19, length(uv - vec2(.35, .57)));\n    color += vec4(pink + (spec-shad)*white, S(0., -dx, hit.dBound ));\n    \n    return premult(color);\n}\n\nvec4 Heart( vec2 uv, float time, float dx )\n{\n    const vec2 center = vec2(.5, .5);\n\n    // BG \n    vec2 tuv = uv - center;\n    float r = length(tuv);\n    //float dx = fwidth(r);\n    //float a = d2a(tuv);//atan(tuv.x, tuv.y)+pi+iTime;    \n    \n    int phase = int(time) & 0x3;\n    float phaseTime = fract(time);\n    \n    float phaseTimeEaseOut = sqrt(1.-sqr(1.-phaseTime));\n    float phaseTimeEaseOutFast = sqrt(1.-sqr(1.-min(phaseTime/.5, 1.)));\n        \n    float t = sqrt(1. - sqr(1. - clamp(phaseTime/.7, 0., 1.)))*.5 + .5;\n\n    // background\n    vec4 color = vec4(pink * .4, 1.);\n    \n    // layers: nepeta, circles, vessels, heart symbol\n    color = comp(color, nepeta(uv, dx));\n    color = comp(color, circles(uv, phaseTime, r, dx));\n    color = comp(color, vessels(uv, phaseTimeEaseOutFast, dx));\n    \n    // heart symbol\n    color = comp(color, heartSymbol(uv, phaseTime, dx));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime/1. + 3.*iMouse.x/iResolution.y;\n    float margin = .5 * (iResolution.x - iResolution.y);\n    vec2 uv = (fragCoord.xy - X*margin) / iResolution.yy;\n    float dx = fwidth(length(uv)) * 1.5;\n    \n    // pixel filter\n#ifdef PIXELATE\n    uv = floor(uv * 64.) / 64.;\n    time = floor(time * 16.) / 16.;\n#endif // PIXELATE\n\n    fragColor = vec4(0.);\n    if (uv.x >= 0.0 && uv.x <= 1.0) fragColor = Heart(uv, time, dx);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"","name":"Common","description":"","type":"common"}]}