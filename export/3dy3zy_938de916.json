{"ver":"0.1","info":{"id":"3dy3zy","date":"1570415842","viewed":95,"name":"HSV Color progress bar","username":"bolloxim","description":"HSV Color fade through hue from red to green smoothly based on 0-100%","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["hsv","progress","ui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Andi Smithers \n// button shader for smooth border edges\n// includes shadow both internal and drop shadow\n// 9 patch is basically preserving the edge with rectangle and doesnt stretch the image\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 0.6666666, 0.3333333, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float progress = mod(iTime, 1.0);\n\n    vec4 backCol = vec4(1,1,1,1);\n    // uniforms\n    float borderSize = 0.05;\n    float antiAliasSize = 0.03;\n    vec4 borderColor = vec4(1.0,1.0,0.95, 1);\n    vec4 centreColor = vec4(0.1,0.5,0.9,1);\n    float wobbly = iTime;\n\tfloat rounding = sin(wobbly)*3.0+4.0;\n    vec2 shadowVec = vec2(-0.01, 0.05);\n    float scaleBox = 1.2;\n\n    // alias thickness\n    float aascalar = 1.0 / antiAliasSize;\n    float outerAlias = 1.0 - antiAliasSize;\n    \n    // convert UV into normalized coord\n    vec2 iuv = fragCoord.xy / iResolution.xy;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // compute 9patch centre - xaxis\n    float centre = (iResolution.x - iResolution.y)/iResolution.x * 0.5 ;\n    if (abs(iuv.x-0.5)<centre) uv.x=0.5;\n    if(iuv.x>centre+0.5) uv.x-=0.5 + (iResolution.y/iResolution.x) * centre*2.0;\n\n    vec2 uvUnit = (uv*2.0-1.0) * scaleBox;\n    vec2 shadowUnit = uvUnit + shadowVec;\n    \n    // rounded edge - have to abs the value incase shader doesnt support negative powers\n    uvUnit = pow(abs(uvUnit), vec2(rounding));\n    shadowUnit = pow(abs(shadowUnit), vec2(rounding));\n    \n    // compute border\n    float borderEdge = pow(1.0-borderSize, rounding);\n    float borderAlias = borderEdge - antiAliasSize;\n    \n    // edge\n    float edge = length(uvUnit);\n    float outer = 1.0-(clamp(edge, outerAlias, 1.0)-outerAlias) * aascalar;\n    float inner = 1.0-(clamp(edge, borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowInner = 1.0-(clamp(length(shadowUnit), borderAlias, borderEdge)-borderAlias) * aascalar;\n    float shadowOuter = 1.0-(clamp(length(shadowUnit), outerAlias, 1.0)-outerAlias) * aascalar;\n    \n    // blow out outer then chose minimum this ensures a mask around the alpha output\n    float outermask = min(outer*1000.0, 1.0);\n    \n    // fetch image and poor mans chromakey alpha\n    vec4 barCol = vec4(hsv2rgb(vec3(progress*0.33333 - 0.1, 1.0, 1.0)), 1.0);\n    float blend = ((iuv.x - progress) <= 0.0 ? 1.0 : 0.0);\n    vec4 image = blend*barCol + backCol*(1.0-blend);\n    \n    \n    //image*= texture(iChannel0, iuv); if you want it textured\n    float alpha = length(image.rgb-vec3(0,1,0));\n    alpha = alpha> 0.5 ? 1.0 : 0.0;\n\n    // shadow\n    float shade = shadowInner<0.9 ? 0.8 + shadowInner*0.2: 1.0;\n    float shadeOut = shadowOuter>0.5 ? 0.0 + shadowOuter*0.2: 0.0;\t\n        \n    // blend inner/outer and image with image alpha\n    vec4 color = (centreColor*inner*(1.0-alpha)+image*alpha*inner)*shade + borderColor*(1.0-inner)*outermask;\n    color.a =  max(outer, shadeOut);\n    \n    // blend against a background texture - because shadertoy\n    vec4 background = texture(iChannel1, iuv);\n        \n    // and set the final color \n    fragColor = (color*color.a) + background*(1.0-color.a);\n}","name":"Image","description":"","type":"image"}]}