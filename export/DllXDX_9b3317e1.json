{"ver":"0.1","info":{"id":"DllXDX","date":"1675432059","viewed":66,"name":"Prabou_BASKARA_GLSL_partiel2","username":"prabou","description":"shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat map(vec3 pos) {\n    float v = 0.0;\n\n    vec3 sp1 = pos + vec3(3.0, 0.0, 0.0);\n    vec3 sp2 = pos + vec3(-3.0, 0.0, 0.0);\n    \n    v = sdSphere(sp1, 3.0);\n    v = mix(sdSphere(pos, 3.0), sdBox(pos, vec3(5.0)), sin(iTime));\n    \n    return v;\n}\n\nfloat CastRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0;                       //contact par defaut\n    for(int i=0; i<64; i++)              // 64 = nombre de marches ùax\n    { \n        float ray = map(ro + rd *c);        // calcul du volume\n        \n        if(ray < (0.00001*c))\n        {\n            return float(i)/32.;\n        }\n        \n        c+= ray;     \n     }\n     return -1.0;\n}\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    float contact = CastRay(ro, rd); // appel du raycast\n    vec3 col = vec3(0.0,0.0,0.0); // couleur par defaut du pixel\n    \n    vec3 pos = ro * rd + contact;\n    \n    if(contact == -1.0)   // condition = s'il n y a pas contact\n    {\n        col = vec3(0.5,0.1,0.5);\n        col += .1 + 0.5*sin(iTime+pos.xyx+vec3(2.0,2.0,10.0));\n    }\n    else                  // condition = s'il y a contact\n    {\n        col = vec3(sin(iTime*10.)*.8+.1,0.3,0.5)+contact;  // couleur du volume\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // centrer les UVs et l'echelle x = y\n    vec2 uv = 2.0*fragCoord/iResolution.xy-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // definir mes parametres de notre camera\n    vec3 cameraPos = vec3(0.0,0.0,10.0);\n    vec3 cameraTar = vec3(0.0);\n    \n    // definir le vecteur de direction depuis la camera\n    vec3 forward = normalize(cameraTar - cameraPos*iTime);\n    vec3 right = normalize(cross(vec3(0.0,-1.0,0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x*right+uv.y*up+2.0*forward);\n    \n    // test d'affichage des uvs centrés\n    vec3 col = render(cameraPos, viewDir);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}