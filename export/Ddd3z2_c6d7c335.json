{"ver":"0.1","info":{"id":"Ddd3z2","date":"1677550340","viewed":108,"name":"Parabolic Mobius Transform","username":"Borthralla","description":"Parabolic Mobius Transform with focus point at 0\nOn the reimann sphere, think of circles slicing through the south pole at various angles. \nThe real line is a circle that runs through the south pole (zero) and the north pole (infinity)","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["checkerboard","mobius","transform"],"hasliked":0,"parentid":"dst3RB","parentname":"Radial Checkerboard"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\nvec2 cMul(in vec2 z1, in vec2 z2) {\n    return  mat2(z1,-z1.y,z1.x) * z2;\n}\n\nvec2 cDiv(in vec2 z1, in vec2 z2) {\n    return z1 * mat2(z2,-z2.y,z2.x) / dot(z2,z2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec4 state = texelFetch( iChannel0, ivec2(0, 0), 0);\n    vec2 p = state.z * (2.*fragCoord-iResolution.xy) / max(iResolution.x, iResolution.y) - state.xy;\n    vec2 unit = vec2(1., 0.);\n    //p = cDiv(p + unit, p - unit); // 2 fixed points, loxodromic\n    p = cDiv(unit, p); // 1 fixed point, parabolic\n    \n    // Use these for elliptic/hyperbolic/loxodromic transforms depending on where itime is\n    // itime on both means loxodromic\n    // just on theta is elliptic\n    // just on length is hyerbolic\n    //float theta = atan(p.y, p.x);\n    //float len = length(p);\n    //float x_index = sin( PI* ( theta * 12. / PI + iTime ))\n    //float y_index = sin( PI* ( log(len) * 4. + iTime ))\n   \n    // Use these for parabolic mobious transformations\n    float x_index = sin( PI* ( p.x * 10.  ));\n    float y_index = sin( PI* ( p.y * 10. - iTime ));\n    \n    float v = x_index*y_index;\n    \n    \n    //float x_index = sin( PI* ( theta * 12. / PI + iTime )),\n    //      y_index = sin( PI* ( log(len) * 4.  )),\n    //      v = x_index*y_index;\n    fragColor = vec4( .5 + v/fwidth(v) );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_W = 87;\nconst int KEY_S = 83;\nconst int KEY_E = 69;\nconst int KEY_D = 68;\nconst int KEY_R = 82;\nconst int KEY_Z = 90;\nconst int KEY_SPACE = 32;\n\nbool keyPress(in int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > 0.;\n}\n\nbool keyTap(in int key) {\n    return texelFetch(iChannel1, ivec2(key, 1), 0).x > 0.;\n}\n\nbool keyToggle(in int key) {\n    return texelFetch(iChannel1, ivec2(key, 2), 0).x > 0.;\n}\n\nvec4 handleKeyboard(vec4 state) {\n    if (keyPress(KEY_LEFT)) {\n        state.x += .015 * state.z;\n    }\n    if (keyPress(KEY_UP)) {\n        state.y -= .015 * state.z;\n    }\n    if (keyPress(KEY_RIGHT)) {\n        state.x -= .015 * state.z;\n    }\n    if (keyPress(KEY_DOWN)) {\n        state.y += .015 * state.z;\n    }\n    if (keyPress(KEY_W)) {\n        state.z /=  1.05;\n    }\n    if (keyPress(KEY_S)) {\n        state.z *= 1.05;\n    }\n    if (keyPress(KEY_Z)) {\n        return vec4(0.0, 0.0, 2., 0.);\n    }\n    \n\n    return state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x < 1. && fragCoord.y < 1.){\n\n        vec4 state = texelFetch( iChannel0, ivec2(0, 0), 0);\n        if (iFrame == 0) {\n            state = vec4(0.0, 0.0, 2., 0.);\n        }\n    \n        state = handleKeyboard(state);\n\n        // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n        fragColor = state;\n    } \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}