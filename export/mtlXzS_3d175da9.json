{"ver":"0.1","info":{"id":"mtlXzS","date":"1675611830","viewed":150,"name":"ringed planet","username":"SupSy","description":"It's litteraly just a planet with a ring\n","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["planetnoisespace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Second pass bloom and overlay on top of the image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0, 0, 0);\n    float total = 0.0;\n    for (int i = -BLUR_SIZE; i < BLUR_SIZE; i++) {\n        vec2 uv = (fragCoord + vec2(0, i * BLUR_STEP)) / iResolution.xy;\n        float coef = float(BLUR_SIZE - abs(i)) / (float(BLUR_SIZE));\n        color += texture(iChannel0, uv).rgb * coef;\n        total += coef;\n    }\n    \n    color = color / total * 0.5 + texture(iChannel1, fragCoord / iResolution.xy).rgb;\n    \n    color *= vec3(1.0, 0.95, 1.1);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float interpolateCubic(float a, float b, float k) {\n    return (b - a) * ((k * (k * 6.0 - 15.0) + 10.0) * k * k * k) + a;\n}\n\nfloat rand3D(vec3 n) {\n    return fract(sin(dot(n, vec3(12.9898, 4.1414, 6.8726))) * 43758.5453);\n}\n\nvec2 rand2DUnit(vec2 n) {\n    float alpha = rand(n) * 2.0 * PI;\n    return vec2(cos(alpha), sin(alpha));\n}\n\nvec3 rand3DUnit(vec3 n) {\n    float beta = rand(n.yz) * PI;\n    vec2 base = rand2DUnit(n.xy);\n    return vec3(base * cos(beta), sin(beta));\n}\n\nfloat dotGrad(vec3 p, vec3 ip) {\n    vec3 u = p - ip;\n    vec3 v = rand3DUnit(ip);\n    return u.x*v.x + u.y*v.y + u.z*v.z;\n}\n\n\nfloat noise3Dgradiant(vec3 p) {\n    vec3 ip = floor(p);\n    vec3 u = fract(p);\n    vec2 v = vec2(1.0, 0.0);\n    u = u*u*(3.0-2.0*u);\n    \n    float dot1 = dotGrad(p, ip);\n    float dot2 = dotGrad(p, ip + v.xyy);\n    float dot3 = dotGrad(p, ip + v.yxy);\n    float dot4 = dotGrad(p, ip + v.xxy);\n    float dot5 = dotGrad(p, ip + v.yyx);\n    float dot6 = dotGrad(p, ip + v.xyx);\n    float dot7 = dotGrad(p, ip + v.yxx);\n    float dot8 = dotGrad(p, ip + v.xxx);\n\n    float resBottom = interpolateCubic(dot1, dot2, u.x);\n    float resTop = interpolateCubic(dot3, dot4, u.x);\n    float resFront = interpolateCubic(resBottom, resTop, u.y);\n    \n    resBottom = interpolateCubic(dot5, dot6, u.x);\n    resTop = interpolateCubic(dot7, dot8, u.x);\n    float resBack = interpolateCubic(resBottom, resTop, u.y);\n    \n    float resFinal = mix(resFront, resBack, u.z);\n    return resFinal * 0.5 + 0.5;\n}\n\n\nfloat noise3D(vec3 p) {\n    vec3 ip = floor(p);\n    vec3 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float resBottom = mix(rand3D(ip),rand3D(ip+vec3(1.0,0.0,0.0)),u.x);\n    float resTop = mix(rand3D(ip+vec3(0.0,1.0,0.0)), rand3D(ip+vec3(1.0,1.0,0.0)), u.x);\n    float resFront = mix(resBottom, resTop, u.y);\n    \n    resBottom = mix(rand3D(ip+vec3(0.0,0.0,1.0)),rand3D(ip+vec3(1.0,0.0,1.0)),u.x);\n    resTop = mix(rand3D(ip+vec3(0.0,1.0,1.0)), rand3D(ip+vec3(1.0,1.0,1.0)), u.x);\n    float resBack = mix(resBottom, resTop, u.y);\n    \n    float resFinal = mix(resFront, resBack, u.z);\n    return resFinal;\n}\n\nconst mat3 mtx = mat3( 0.80,  0.60, 0.0, -0.60,  0.80, 0.0, 0.0, 0.0, 1.0 );\n\nfloat pattern(vec3 base, int layers, float roughness) {\n    float f = 0.0;\n    vec3 coords = base;\n    float layersF = float(layers);\n    float tot = 0.0;\n    for (int i = 1; i <= layers; i++) {\n        float coeff = mix(1.0, 1.0 / pow(2.0, float(i)), roughness);\n        f += noise3Dgradiant(coords) * coeff;\n        coords = mtx*coords*2.0;\n        tot += coeff;\n    }\n    return f/tot;\n}\n\nfloat distort(vec3 uv, int layers, float roughness) {\n    return pattern(uv + pattern(uv + pattern(uv, layers, roughness), layers, roughness), layers, roughness);\n}\n\nvec3 makeCol(float noise) {\n    float mid = 0.325;\n    float inv_mid = 1.0/mid;\n    return mix(mix(vec3(1.0, 0.7, 0.1), vec3(0.2, 0.6, 0.5), noise <= mid ? noise * inv_mid : 1.0), vec3(0.2, 0.0, 0.2), noise > mid ? (noise - mid) * inv_mid : 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x + vec2(0.5, 0.0);\n    uv.y *= 3.0;\n    float pat = distort(vec3(uv * 10.0, iTime * 0.05), 5, 1.0);// iMouse.x / iResolution.x);\n    vec3 col1 = makeCol(pat);\n    \n    uv = fragCoord/iResolution.x - vec2(0.5, 0.0);\n    uv.y *= 3.0;\n    pat = distort(vec3(uv * 10.0, iTime * 0.05), 5, 1.0);\n    vec3 col2 = makeCol(pat);\n    \n    fragColor = vec4(mix(col1, col2, fragCoord.x/iResolution.x),1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Rotation functions [\nvec3 rotX(vec3 pos, float angle) {\n    float cosA = cos(angle); float sinA = sin(angle);\n    float y = cosA * pos.y + sinA * pos.z;\n    float z = - sinA * pos.y + cosA * pos.z;\n    return vec3(pos.x, y, z);\n}\n\nvec3 rotY(vec3 pos, float angle) {\n    float cosA = cos(angle); float sinA = sin(angle);\n    float x = cosA * pos.x + sinA * pos.z;\n    float z = - sinA * pos.x + cosA * pos.z;\n    return vec3(x, pos.y, z);\n}\n\nvec3 rotZ(vec3 pos, float angle) {\n    float cosA = cos(angle); float sinA = sin(angle);\n    float x = cosA * pos.x + sinA * pos.y;\n    float y = - sinA * pos.x + cosA * pos.y;\n    return vec3(x, y, pos.z);\n}\n// ]\n\n\n// Makes unit vector of sphere surface\nvec3 sphereNormals(vec2 uv) {\n    float sqrd = uv.x*uv.x + uv.y*uv.y;\n    float z = sqrd <= 1.0 ? sqrt(1.0 - sqrd) : -1000.0;\n    return vec3(uv.x, uv.y, z);\n}\n\n// UV coordinates on the sphere : wraps a plane on the unit sphere\nvec2 sphereUV(vec3 coords) {\n    vec3 vecY = vec3(0.0, 1.0, 0.0);\n    float cosAlpha = dot(coords.xz, vecY.yx) / length (coords.xz);\n    float signAlpha = sign(dot(coords.xz, vecY.xy));\n    \n    float alpha = acos(cosAlpha) * signAlpha;\n    \n    float beta = acos(dot(coords, vecY));\n                \n    return vec2((alpha + PI) / (2.0 * PI), beta / PI);\n}\n\n// Plane coordinates from parametric plane function\nvec3 planeCoords(vec3 normal, vec2 uv) {\n    return vec3(uv, - (normal.x * uv.x + normal.y * uv.y) / normal.z);\n}\n\n// UV coordinates on the plane [\nvec2 planeUVplanar(vec3 coord, vec3 normal, vec3 front) {\n    vec3 right = vec3(normal.y * front.z - normal.z * front.y,\n                      normal.z * front.x - normal.x * front.z,\n                      normal.x * front.y - normal.y * front.x);\n    float u = dot(front, coord);\n    float v = dot(right, coord);\n    return vec2(u,v);\n}\n// Supposed to map the image on the plane based on polar coordinates, but yeah...\nvec2 planeUVcircular(vec3 coord, vec3 normal, vec3 front, float angleOffset) {\n    //vec3 right = vec3(normal.y * front.z - normal.z * front.y,\n    //                  normal.z * front.x - normal.x * front.z,\n    //                  normal.x * front.y - normal.y * front.x);\n    //float cosAlpha = dot(coord, front);\n    //float sinAlpha = dot(coord, right) > 0.0 ? 1.0 : -1.0;\n    //float Alpha = acos(cosAlpha) * sign(sinAlpha);\n    \n    //return vec2((Alpha + PI) / (2.0 * PI) + angleOffset, length(coord)/4.0);\n    return vec2(angleOffset, length(coord)/1.0);\n}\n// ]\n\n// Fresnel effect\nfloat Fresnel(vec3 normal, float power) {\n    return pow(dot(normal, vec3(0.0, 0.0, 1.0)), power);\n}\n\n// Bad implementation of specular lighting\nfloat highlight(vec3 normal, vec3 cam, vec3 light) {\n    float Kd = 2.0;\n    float Ks = 0.05;\n    float n = 2.0;\n    vec3 R = light + 2.0 * (normal - light);\n    \n    return max(Kd * (dot(normal, light)) + Ks * pow((dot(R, cam)), n), 0.0);\n}\n\n// Other implementation of specular lighting\nfloat specular(vec3 normal, vec3 light, float smoothness) {\n    float angle = acos(dot(normalize(light - vec3(0, 0, 1)), normal));\n    float exponent = angle / smoothness;\n    return exp(-exponent * exponent);\n}\n\n// Generates normal map from texture\nvec3 makeHeight(vec2 uv, sampler2D tex) {\n    vec2 epsilon = vec2(0.001, 0.0);\n    vec3 color = texture (tex, uv).rgb; \n    vec3 color1 = texture (tex, uv + epsilon).rgb; \n    vec3 color2 = texture (tex, uv + epsilon.yx).rgb;\n    \n    float depth = (color.r + color.g + color.b) / 3.0;\n    float depth1 = (color1.r + color1.g + color1.b) / 3.0;\n    float depth2 = (color2.r + color2.g + color2.b) / 3.0;\n\n    return normalize(cross(vec3(epsilon.x, 0.0, depth1-depth), vec3(0.0, epsilon.x, depth2-depth)));\n}\n\n// Makes the planet color and depth\nvec4 makePlanet(vec2 uv, vec3 light) {\n    vec3 coordsOnSphere = sphereNormals (uv);\n    vec3 coordsOnSphereRotated = rotX(rotY(rotZ(coordsOnSphere, cos(iTime * 0.03) * 0.05 - 0.25), iTime * 0.3), sin(iTime * 0.01) * 0.1);\n    vec2 sphereUVs = sphereUV(coordsOnSphereRotated);\n    vec3 displacedSphere = coordsOnSphere + makeHeight(sphereUVs, iChannel1) * 0.025;\n    \n    float fresnelMask = Fresnel(displacedSphere, 0.7);\n    vec3 fresnelColor = vec3(0.3, 1.3, 1.9) * (1.0-fresnelMask) * 0.5;\n    \n    vec3 planetColor = texture (iChannel1, sphereUVs).rgb;\n    planetColor = mix(fresnelColor, planetColor, fresnelMask);\n    float planetSpecular = highlight(displacedSphere, vec3(0, 0, 1), light);\n    // float planetSpecular = specular(displacedSphere, light, 1.0);\n    float planetDiffuse = dot(displacedSphere, light);\n    planetColor = planetColor * (planetSpecular + planetDiffuse);\n    planetColor *= displacedSphere.z < -1.0 ? 0.0 : 1.0;\n    \n    return vec4(planetColor, coordsOnSphere.z < -1.0 ? -1000.0 : coordsOnSphere.z);\n}\n\n// Makes the ring color and depth\nvec4 makeRing(vec2 uv, vec3 light, out float opacity) {\n    \n    vec2 ringSize = vec2(1.4, 2.5);\n\n    vec3 planeNormal = rotX(rotY(rotZ(vec3(0, 1, 0), PI/6.0), 0.0 * iTime - PI/3.0), PI/18.0);\n    vec3 planeFront = rotX(rotY(rotZ(vec3(1, 0, 0), PI/6.0), 0.0 * iTime - PI/3.0), PI/18.0);\n    vec3 coordsOnPlane = planeCoords (planeNormal, uv);\n    vec2 planeUVs = planeUVcircular(coordsOnPlane, planeNormal, planeFront, 0.0002 * iTime);\n    vec3 displacedPlane = coordsOnPlane + makeHeight(planeUVs, iChannel0) * 0.1;\n    \n    vec3 ringColor = texture (iChannel0, planeUVs).rgb * vec3(0.55, 0.65, 0.6);\n    // float ringSpecular = highlight(displacedPlane, vec3(0, 0, 1), light) * 0.5;\n    float ringSpecular = specular(planeNormal + makeHeight(planeUVs, iChannel0) * 0.1, light, 0.9);\n    float ringDiffuse = dot(planeNormal + makeHeight(planeUVs, iChannel0) * 0.1, light) * 2.0;\n    ringColor = ringColor * (ringDiffuse + (ringSpecular*0.9) + 0.1);\n    opacity = length(displacedPlane) > ringSize.x && length(displacedPlane) < ringSize.y ? \n                max(0.0, min(1.0, (length(displacedPlane) - ringSize.x) * 5.0))\n              * max(0.0, min(1.0, (ringSize.y - length(displacedPlane)) * 5.0))\n              : 0.0;\n    \n    return vec4(ringColor, length(displacedPlane) > ringSize.x && length(displacedPlane) < ringSize.y ? coordsOnPlane.z : -1000.0);\n}\n\n// Make stars from some noise\nfloat makeStarMask(vec2 uv) {\n    vec2 iuv = floor(uv);\n    vec2[] units = vec2[](vec2(0, 0), vec2(1, 0), vec2(1, 1), vec2(0, 1),\n                    vec2(-1, 1), vec2(-1, 0), vec2(-1, -1), vec2(0, -1),\n                    vec2(1, -1));\n    \n    float mask = 0.0;\n    for (int i = 0; i < 9; i++) {\n        vec2 center = iuv + units[i] + vec2(rand(iuv + units[i]), rand(iuv + units[i] + vec2(1, 0)));\n        float comparant = rand(center) * 0.05 + 0.001;\n        mask = (mask + \n            mix(0.0, 1.0, max(0.0, (comparant - length(center - uv)) / comparant))\n            );\n    }\n    \n    return min(1.0, mask);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y * 2.75;\n    float mouseScale = 0.9;\n    vec3 mouse3D = vec3(2, 1.5, -1);\n    \n    if (iMouse.xy != vec2(0)) {\n        mouse3D = vec3((iMouse.x - iResolution.x * 0.5) / iResolution.y * 2.0, iMouse.y / iResolution.y * 2.0 - 1.0, 0.0);\n        mouse3D.z = (mouse3D.x*mouse3D.x + mouse3D.y+mouse3D.y) * mouseScale * mouseScale;\n        mouse3D.z = sqrt(abs(1.0 - mouse3D.z)) * sign(1.0 - mouse3D.z);\n    }\n    \n    vec3 sun = normalize(mouse3D);\n    \n    vec4 planet = makePlanet(uv, sun);\n    float opacity;\n    vec4 ring = makeRing(uv, sun, opacity);\n    \n    float mask = ring.w > planet.w ? 1.0 : 0.0;\n    float starMask = makeStarMask(uv * 15.0) * (planet.w <= -1000.0 ? 1.0 - opacity : 0.0) * texture(iChannel2, uv * 0.5).r * 2.0;\n    \n    vec3 finalColor = max(planet.xyz, 0.0) * (1.0-mask) + max(ring.xyz, 0.0) * mask * opacity + starMask * vec3(0.9, 0.9, 1.0);\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// First pass bloom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0, 0, 0);\n    float total = 0.0;\n    for (int i = -BLUR_SIZE; i < BLUR_SIZE; i++) {\n        vec2 uv = (fragCoord + vec2(i * BLUR_STEP, 0)) / iResolution.xy;\n        float coef = float(BLUR_SIZE - abs(i)) / (float(BLUR_SIZE));\n        vec3 tex = texture(iChannel0, uv).rgb;\n        color += tex * coef * (length(tex) > 1.0 ? 1.0 : 0.0);\n        total += coef;\n    }\n    \n    fragColor = vec4(color / total,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Size of bloom on pixel basis (laggy)\n#define BLUR_SIZE 32\n// Distance between to samples\n#define BLUR_STEP 4\n#define PI 3.1415\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}","name":"Common","description":"","type":"common"}]}