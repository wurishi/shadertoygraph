{"ver":"0.1","info":{"id":"dlSczw","date":"1691583837","viewed":26,"name":"CSellipse2","username":"2243798719","description":"CSellipse2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["csellipse2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec4 Black = vec4(0.,0.,0.,1.);\nconst vec4 White = vec4(1.,1.,1.,1.);\nconst vec4 Red = vec4(1.,0.,0.,1.);\nconst vec4 Green = vec4(0.,1.,0.,1.);\nconst vec4 Blue = vec4(0.,0.,1.,1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 split = vec2(3.,3.);\n    //Draw Grid\n    /*float row1 = iResolution.y/split.y;\n    float row2 = iResolution.y/split.y*2.;\n    float col1 = iResolution.x/split.x;\n    float col2 = iResolution.x/split.x*2.;\n    float thickness = 0.5;\n    if(abs(fragCoord.x - col1) <= thickness) {fragColor = Black;}\n    if(abs(fragCoord.x - col2) <= thickness) {fragColor = Black;}\n    if(abs(fragCoord.y - row1) <= thickness) {fragColor = Black;}\n    if(abs(fragCoord.y - row2) <= thickness) {fragColor = Black;}*/\n    \n    //Draw Point\n    float factorX = 53.39;\n    float factorY = 15.73;\n    vec4 PointColor = Red;\n    \n    float PointSize = 3.;\n    vec2 coord = StandardizationCoord(fragCoord, iResolution.xy/split);\n    /*vec2 p1 = floor(coord);\n    vec2 p2 = hashC(p1);//Random Point\n    if(length(fragCoord - RefragCoord(p1 + p2,iResolution.xy/split)) <= PointSize) {\n        fragColor = PointColor;\n    }*/\n    \n    float d = 1e10;\n    for(int i = 0;i<int(split.x);i++) {\n        for(int j = 0;j<int(split.y);j++) {\n            vec2 p = vec2(i,j);\n            vec2 _p = hashC(p);//Random Point\n            d=min(d,length(coord - (p+_p)));\n        }\n    }\n    fragColor = 1.-vec4(d);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hashA(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return p;\n}\nfloat hashB(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec2 hashC(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.x+1.1,p.y+0.3,p.x+0.57) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash22(vec2 p)//hascC Prototype\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nfloat hash_standardization(float min, float max, float factor) {\n    float t = abs(hashA(factor)) +1.;\n    while(t < min) {\n        t*=2.;\n    }\n    while(t > max) {\n        t/=2.;\n    }\n    while(t < min) {\n        t+=abs(fract(t));\n    }\n    while(t > max) {\n        t-=abs(fract(t));\n    }\n    return t;\n}\nvec2 StandardizationCoord(vec2 fragCoord, vec2 UnitLength) {\n    return fragCoord/UnitLength;\n}\nvec2 RefragCoord(vec2 StandardizationCoord, vec2 UnitLength) {\n    return StandardizationCoord*UnitLength;\n}\n","name":"Common","description":"","type":"common"}]}