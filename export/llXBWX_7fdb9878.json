{"ver":"0.1","info":{"id":"llXBWX","date":"1513574824","viewed":256,"name":"Texture_Tutorial","username":"dpadrial","description":"a","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // テクスチャ詳細\n    //\n    // プロジェクト単位で様々に取り決められるテクスチャ関連の規約だが、\n    // 基本的なテクスチャの理解がないままに設定等が行われているケースが散見されるので、\n    // この部分をしっかりと固めておく.\n    //\n    // POT/NPOT\n    // 昔のGPUは2の冪乗(POT)のテクスチャサイズ以外に処理できなかった事情、\n    // 及び今でも最も効率的に動くテクスチャサイズがPOTであることから、\n    // テクスチャサイズはPOTにすることが望まれている。\n    // しかし、今のGPUはPOTでなければ動かないことはなく、OpenGL2.0の時代から拡張仕様として\n    //\n    // GL_OES_texture_npot\n    //\n    // が存在しており、パフォーマンス面での制約及び古いGPUでの互換性が失われるという問題があるものの\n    // 仕様できないわけではない\n    //\n    //\n    // POTは正方形であることを要求していない\n    // 勘違いがものすごく多い点の１つだが、POTは2の冪乗であることを要求しているだけで、\n    // 16*2048のような極端な長方形もPOTであり、各種NPOTの制約には当てはまらない。\n    // 正方形を要求しているのは、PVRTC側の仕様である。\n    // このため、テクスチャサイズを正方形としているのはiOS/Androidの両方に同じサイズで対応する場合、\n    // PVRTCの仕様に引っ張られてしまうためであり、\n    // テクスチャ指定をPVRTCとした場合には正方形でない場合にはコンバートが失敗するため、\n    // Unity等ではエンジン内部で事前処理を行うしようとなっているにすぎない。\n    // \n    // こちらも勘違いが起こりやすいが、iOSの設定をPVRTC、Androidの設定をETC1/ETC2とするのは、\n    // iPhoneは一貫してPowerVR系を採用しているため、\n    // PowerVRのネイティブテクスチャであるPVRTCを採用し、\n    // AndroidではGPUの拡張仕様として採用されているETC1及びOpenGL|ES3.0より標準仕様となったETC2を\n    // 採用している.\n    // ここで勘違いしやすいが、iPhoneで採用されるPVRTCはネイティブテクスチャであり、\n    // GPUにとっては最も効率的なテクスチャアクセスができる形式であるが、\n    // Androidで採用されるETC系はGPUにとってネイティブテクスチャとは限らない.\n    // \n    // ネイティブテクスチャ\n    // GPUが最も駆動しやすいテクスチャ形式で、各種メーカーで異なる。\n    // ETC1をネイティブに採用しているのはMali400系であり、\n    // 他は全てETC系をサポートしているが、ネイティブテクスチャではない（確か）\n    //\n    // PowerVR:  PVRTC/PVRTC\n    // Adreno:   ATC\n    // Mali-400: ETC1/RGBA32\n    // Mali-600: ASTC\n    // Tegra:    DXT1/DXT5\n    //\n    // そして、この各種テクスチャ形式はGPUで互換性がないのが普通のため、まず動かない\n    // *Androidで最適化のためにネイティブテクスチャを採用した場合、珍しい端末で事故が起こる事例\n    // iPhone8/iPhoneX世代はAppleが独自に開発したGPUのため、PVRTCがネイティブなのかは不明.\n    //\n    // ミップマップ\n    // とある鉄火場プロジェクトではミップマップをオフにすれば綺麗になるとエンジニアが発言するほど\n    // 理解されていないですが、理由なくオフにしないでください\n    // 今回のサンプルが事例になります.\n    // ミップマップとは、オリジナルサイズを0として、n+1番のミップをn番目のテクスチャサイズの半分とする.\n    // マトリョーシカのようなテクスチャセットを言います.\n    // *1を末尾とするため、NPOTミップマップは作成可能である（また独自で作る場合もある）\n    // ミップマップを作成した場合、理論上は2倍、圧縮等に要素で約1.3倍の容量になるのが普通である.\n    // このミップマップは、描画ピクセルとテクスチャフェッチのアンバランスを解消するために仕様する.\n    // 例えば、1ピクセルの描画領域にUV(0-1)の512テクセルは無駄しかないため、\n    // それに相応しい1テクセルまで縮小になったミップを使用することでパフォーマンスを向上させる\n    // これは特にカメラと描画対象との距離で決まるため、3Dでは有効である。\n    // 逆にHUDはカメラ距離が常に固定なので、ミップマップ作成の容量の方が無駄が多くなる。\n    //\n    // 特にこの距離に応じてテクスチャの詳細度を変えることをLOD（Level of Detail）\n    // と呼ぶ。実際のゲームだとある距離からLODにより、詳細度が一気に落ちる現象をポッピングと呼ぶ\n    // * 詳細度が1/2になるのでこの現象が起こる.\n    \n\tfragColor = texture(iChannel0, uv, 2.2);\n}","name":"Image","description":"","type":"image"}]}