{"ver":"0.1","info":{"id":"cd3yW2","date":"1695485869","viewed":110,"name":"Waterfalls 2","username":"kastorp","description":"If we apply collision force only from particles with higher pressure, the fluid compression is greatly reduced.\nPressure waves are highlighted in blue.\n\npress SPACE BAR to view particles, R to reset, A to toggle elevator, B to togglepressure levelling\n","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["voronoi","water","particles","sph"],"hasliked":0,"parentid":"NlKSWz","parentname":"waterfalls"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Waterfalls 2 by Kastorp\n//------------------------------\n// If we apply collision force only from particles\n//  with higher pressure, the fluid compression is greatly reduced.\n// Pressure waves are highlighted in blue.\n//\n// keys:\n//  SPACE BAR to view particles, \n//  R to reset, \n//  A to toggle elevator, \n//  B to toggle pressure levelling\n//  C to toggle ghost recovery\n//-----------------------------------------------------\n\nGETTERS\n\nvec4 Voronoi(in vec2 pos){\n    ivec4 nb = getClosest(ivec2(pos/ZOOM));\n  \n    bool ghost;\n    vec4 pi0 = getParticle(nb[0],ghost);\n    vec4 pi1 = getParticle(nb[1],ghost);\n    vec4 pi2 = getParticle(nb[2],ghost);\n\n    float d0 = distance(pos/ZOOM,pi0.xy)*ZOOM;\n    float d1 = distance(pos/ZOOM,pi1.xy)*ZOOM;  \n    float d2 = distance(pos/ZOOM,pi2.xy)*ZOOM; \n      \n    return vec4(d0,d1,d2,float(nb[0]));\n}\n\n\nvoid mainImage( out vec4 O, in vec2 p ){\n\n    bool dbg =texelFetch(iChannel3,ivec2(32,0),0).x>.5;\n    \n    float s=RADIUS*ZOOM*1.;   \n    vec4 d = Voronoi(p);\n    float  df=  dbg?  min(min(d.x,d.y),d.z)*ZOOM*2. :  smin(smin(d.x,d.y,s),d.z,s) ;   \n    float foam=  clamp(1.-.2*smoothstep(s,s*.8 ,d.y)-.3*smoothstep(s,s*.8 ,d.z),0.,1.);\n    float pr=getPressure(int(d.w));\n    float db= map(p/ZOOM,size,iTime,elevator).x;\n    \n    vec3  col = smoothstep(s*1.1,s*.9,df)* mix( d.w==10000.?vec3(1,0,0):mix(vec3(0.2,0.6,0.9),vec3(0.,.1,1.),pr/2.),vec3(.8,1,1),foam) ; \n   \n    \n    col=mix(col,mix(vec3(.6),vec3(.2),smoothstep(-s*.3,s*.15,db)), smoothstep(s*.15,s*.1,db));\n\tO = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//configurable settings:\n//#define MANY \n#ifndef MANY\n    #define NP 30000. \n    #define NGH 1000 \n    #define dt .8 \n    #define RADIUS 2.2\n    #define PRED 1.\n    #define VSC .1\n    #define COL 1.\n#else\n    #define NP 100000. \n    #define NGH 1000 \n    #define dt .75 \n    #define RADIUS 1.\n    #define PRED 1.\n    #define VSC .15\n    #define COL 1.\n#endif\n\n//-----------------------\n#define MAXSIZE 400.\n#define ZERO  min(iFrame,0)\n#define N ivec2(int(sqrt(NP)),int(sqrt(NP)))\n#define size  min(vec2(MAXSIZE*iResolution.x/iResolution.y,MAXSIZE),vec2(iResolution.xy))\n#define RRADIUS RADIUS *min(iResolution.y/MAXSIZE,1.)\n#define ZOOM (iResolution.y/size.y)\n#define mouse (iMouse/ZOOM)\n#define tx(a, p) texelFetch(a, ivec2(p), 0)\n#define elevator (texelFetch(iChannel3,ivec2(65,2),0).x<.5)\n#define GETTERS ivec4 getClosest(ivec2 p){ return floatBitsToInt(tx(iChannel2, p));} \\\nivec4 getNeighbor(int id){ return floatBitsToInt(tx(iChannel1, i2xy(id)));} \\\nivec4[2] getNeighbor2(int id){ uvec4 v= floatBitsToUint(tx(iChannel1, i2xy(id))); return ivec4[2](ivec4(v&65535u), ivec4(v>>16)); }\\\nvec4 getParticle(int id,out bool ghost){ vec4 p= tx(iChannel0, i2xy(id));ghost=min(p.x,p.y)<0.;return vec4(abs(p.xy),p.zw); } \\\nfloat getPressure(int id){ \\\n   float pr=0.; \\\n   float dtp=dt*PRED;\\\n   bool ghost; \\\n   vec4 p=  getParticle(id,ghost); \\\n   ivec4 n=  getNeighbor(id); \\\n   for(int i=0;i<4;i++){ \\\n       vec4 nb= getParticle(n[i],ghost); \\\n       float dn=distance(nb.xy +nb.zw*dtp,p.xy+p.zw*dtp); \\\n       if( dn<RADIUS) pr+= RADIUS - dn; \\\n   } \\\n   vec3 df= map(p.xy +p.zw*dtp,size,iTime,elevator);\\\n   if( df.x<RRADIUS*1.) pr+= RRADIUS *1.5- df.x; \\\n   return pr; \\\n}\n\n\n\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(vec2 p)\n{\n    return int(p.x) + int(p.y)*N.x;\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin(in float a, in float b, in float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n//https://iquilezles.org/articles/distgradfunctions2d\nvec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\n\nvec3 sdgSegment( in vec2 p, in vec2 a, in vec2 b, in float r )\n{\n    vec2 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec3(d-r,q/d);\n}\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\n#define mmin(a,b) (a.x<b.x?a:b)\nvec3 map(vec2 p,vec2 sz,float t,bool e){\n    //t*=0.;\n     vec3 df = sdgCircle(p.xy -vec2(sz.x*.3,0),sz.y*.15);\n     df=mmin(df,-sdgBox(p-sz*.5*vec2(1,1.),sz*.49*vec2(1,1.)));\n     df=mmin(df,sdgBox(p-vec2(sz.x*.8,0),vec2(sz.x*.2,sz.y*.1)));\n     df=mmin(df,sdgBox(p-vec2(sz.x*.1,sz.y*.45),vec2(sz.x*.02,sz.y*.35)));\n     df=mmin(df,sdgSegment(p,vec2(.1,.8)*sz,vec2(.6,.6+sin(t)*.1)*sz,sz.y*.01));\n     df=mmin(df,sdgSegment(p,vec2(.6,.5)*sz,vec2(.9,.8)*sz,sz.y*.01));\n     float c=sz.y/6., q = mod(p.y - t*.05*sz.y +0.5*c,c)-0.5*c;\n    if(e)  df=mmin(df,sdgBox(vec2(p.x,q),vec2(sz.x*.08,sz.y*.01)));\n    return df;\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle physics\n\nGETTERS\n\nint cid;\n\n\nvec4 Fv(vec4 p0, int pid, float pr)\n{\n    if(pid < 0 || pid >= int(N.x*N.y) || pid == cid) return vec4(0);\n    bool ghost;\n    float dtp=PRED*dt;\n   \tvec4 p1 = getParticle(pid,ghost);\n    float d = distance(p1.xy+p1.zw*dtp,p0.xy+p0.zw*dtp),\n          x=d/RADIUS;\n\n    float pn=getPressure(pid), ps= (pn<pr?.0:1.) ; // if neighbour pressure is lower than mine, ignore it\n    if( texelFetch(iChannel3,ivec2(66,2),0).x>.5) ps=1.; //see difference\n   \n    vec2 viscosity_force =VSC*(p1.zw - p0.zw)/(1.+.05*x+1.5*x*x*x),   \n         collision_force = COL*  normalize(p1.xy-p0.xy)* \n                                  //min(.01,1./(1.+x)- 1.8* exp(-x) - .2*smoothstep(1.1,.9,x));\n                                  -clamp(15.*(1.-x),-1.,1.)*smoothstep(1.2,.0,x);\n    return vec4(viscosity_force + collision_force*ps,vec2(0));\n\n\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        bool gh;       \n        //this pixel value\n        U = getParticle(xy2i(pos),gh);\n       \n        U.xy=abs(U.xy);\n        int id = xy2i(pos);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10 || U==vec4(0) || texelFetch(iChannel3,ivec2(82,0),0).x>.5)\n        {\n            U.xy = size*vec2(p)/vec2(N);\n\t\t\tU.zw = vec2(0);\n      \t\treturn;\n        }\n        \n   \t\tivec4 cp = getNeighbor(id);\n   \t  \n        float pr=getPressure(id);\n        vec4 F =  vec4(0);\n        for(int i=0;i<4;i++) F+= Fv(U, cp[i],pr);\n\n\n        F.y-=.02*dt; //gravity \n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(mouse.xy, U.xy);\n            if(d<size.y*.3) F.xy -= 1.*normalize(mouse.xy - U.xy)/(sqrt(d)+2.);\n        } \n \n        //border conditions\n        vec3 df= map(U.xy,size,iTime,elevator);\n        if(df.x<RRADIUS*1.) { \n            F.zw= .8*(-df.x +RRADIUS*1.0)*df.yz;\n            F.xy+= (dot(U.zw,df.yz)<=0.) ? \n                   -df.yz*1.1*dot(U.zw,df.yz)/dt: \n                   vec2(0.); \n         }\n\n        //apply forces\n        U.zw += F.xy *dt;\n        U.zw*=.999;\n        \n        //apply velocity and impulse\n        U.xy += U.zw*dt +F.zw;\n       \n        U.xy = mod(U.xy, size);\n        \n        bool ghost=true;\n        ivec4 nb = getClosest(ivec2(U.xy));\n        for(int i = 0; i<4; i++)\n        {\n            if(nb[i]==id) {ghost=false; break;}\n        }\n        if(ghost) U.xy=-U.xy;\n        \n    }\n    else discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particcle connection\n\nGETTERS\n\n\n//sorting closest 4 particles\n\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp,ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getNeighbor(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 I )\n{  \n    \n    ivec2 p = ivec2(I);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(I);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    if(texelFetch(iChannel3,ivec2(67,2),0).x<.5)\n    for(int i = 0; i < NGH; i++)\n    {\n        //sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort  \n        int id=(iFrame*NGH+i) % int(NP);\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(id); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(nc[i]); \n    }\n    \n    ivec4 nb = getNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n         ivec4 nbb = getNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[j]); \n        }\n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(NP))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position\n\nGETTERS\n\n\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\nbool ghost;\n\n\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = distance(getParticle(utemp,ghost).xy, pos);\n    //sorting\n     if(d.w > dtemp){\n    if(d.x > dtemp)                     { d = vec4(dtemp, d.xyz);    u = ivec4(utemp, u.xyz);}\n    else if(d.y > dtemp && dtemp >= d.x) { d.yzw = vec3(dtemp, d.yz); u.yzw = ivec3(utemp, u.yz);}\n    else if(d.z > dtemp && dtemp >= d.y) { d.zw = vec2(dtemp, d.z);   u.zw = ivec2(utemp, u.z);}\n    else if(d.w > dtemp && dtemp >= d.z) { d.w = dtemp;               u.w = utemp;}\n    }\n}     \n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = getClosest(p);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid sortPart(int id)\n{\n\n    ivec4 nb = getNeighbor(id);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen\n    \n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    sortpos(p); //resort this position, cause particles are moving\n    \n    //jump flood sorting; minimized gere, raising to 12 or 16 has small effect and  high impact on framerate  \n    for(int i = ZERO; i < 12; i++)\n    { \n        ivec2 p2 =p+   (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n        \n        //if (! any(greaterThan(p2,ivec2(ceil(size)) )) && ! (! any(lessThan(p2,ivec2(0u) )))) \n        sortpos(p2); \n    }\n    \n    \n    // sort neighbors of closest particles\n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n    \n    // if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )  u = ivec4(0); \n    \n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}