{"ver":"0.1","info":{"id":"lXlyR7","date":"1726067261","viewed":22,"name":"Hierarchical Wang Tiles","username":"chronos","description":"Hierarchical Wang Tiles. Click to show subdivision / quadtree.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["multiscale","tiles","wang","quadtree","hierarchical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    \"Hierarchical Wang Tiles\" by chronos\n    ---------------------------------------------------\n    \n    Figured out how to do hierarchical Wang tiles!\n    There's probably other examples of this here already, but I haven't seen it before I think.\n    In any case I wanted to work it out for myself :)\n    \n    The tile edges are binary in this case, but it can be generalized\n    Binary edge constraints give 16 possible tiles\n    \n    You can tell that no edge constraints are violated, since there are no vertical or horizontal edges,\n    except for the outermost ones, of course.\n    \n    Using this connectivity info it is possible to draw shapes in the cells \n    with boundary conditions that will match that of neighboring cells.\n    \n    In this simple demonstration I only draw simple tiles in classical Wang tile fashion\n    with triangle colors corresponding to edge value.\n    \n    -------------------------------------------------------\n    \n    Self link: https://www.shadertoy.com/view/lXlyR7\n*/\n\n\n#define ss(D) smoothstep(ps, -ps, D)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (.5+(fragCoord - .5*iResolution.xy) / iResolution.y);\n    float ps   = 1. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 grid_uv = fract(uv);\n    vec2 grid_id = floor(uv);\n\n    vec2 cell_id = grid_id;\n    //vec2 cell_hw = vec2(.5); // Cell height and width. Unused for now but can be useful.\n\n    int num_levels = 7;\n\n    float T = mod(floor(iTime), 16.);\n\n    // x:bottom, y:right, z:top, w:left\n    vec4 boundaries = //vec4(1,0,0,1);\n        vec4(ivec4(T/8., T/4., T/2., T) % 2); // Animated by stepping through all 16 possible types.\n\n    int level = 0;\n    for(; level < num_levels; level++)\n    {\n        \n        // grid_id = \n        // 0,0 -> bottom left    -> inherit bottom and left from parent, and top from new left, right from new bot\n        // 1,0 -> bottom right   -> inherit bottom and right from parent, and top from new right, left from new bot\n        // 0,1 -> top left       -> inherit top and left from parent, and bot from new left, right from new top\n        // 1,1 -> top right      -> inherit top and right from parent, and left from new top, bot from new right\n        \n        // draw four random values to place on the new interior edges:\n        vec4 rnd = step(.5, texelFetch(iChannel0, ivec2(cell_id)%1024, 0));\n        float new_bot = rnd.r;\n        float new_right = rnd.g;\n        float new_top = rnd.b;\n        float new_left = rnd.a;\n        \n        // Subdivide grid:\n        grid_id = floor(2. * grid_uv);\n        grid_uv = fract(2. * grid_uv);\n\n        cell_id = cell_id * 2. + grid_id;\n        //cell_hw *= .5;\n        \n        if(grid_id.x < .5 && grid_id.y < .5) // bot left child\n            boundaries.zy = vec2(new_left, new_bot);      // top from new left, right from new bot\n            \n        if(grid_id.x > .5 && grid_id.y < .5) // bot right child\n            boundaries.zw = vec2(new_right, new_bot);     // top from new right, left from new bot\n            \n        if(grid_id.x < .5 && grid_id.y > .5) // top left child\n            boundaries.xy = vec2(new_left, new_top);      // bot from new left, right from new top\n            \n        if(grid_id.x > .5 && grid_id.y > .5) // top right child\n            boundaries.wx = vec2(new_top, new_right);     // left from new top, bot from new right\n    \n        // Use 'russian-roulette' termination condition for subdivision. \n        int id = (int(cell_id.y) << level) + int(cell_id.x);\n        \n        id += int(T); // animate\n        if(texelFetch(iChannel1, ivec2(id, id/256)%256, 0).r < .5) break;\n    }\n\n    // Unused for now, but the cell id can be useful in other shaders extending this method.\n    // int id = (int(cell_id.y) << num_levels) + int(cell_id.x);\n    // color = pow(texelFetch(iChannel0, ivec2(id/1024, id%1024), 0).rgb, vec3(3.));\n\n    ps = pow(2., float(level)) / iResolution.y; // Pixel size in grid/cell UV coordinates\n\n    vec2 diag = sqrt(2.)/2. * mat2(1,1,-1,1)*(grid_uv - .5); // Diagonals for triangle pattern, with center at (0,0)\n\n    float alpha = 0.;\n    alpha += ss(-diag.x) * ss( diag.y) * boundaries.x; // bot\n    alpha += ss(-diag.x) * ss(-diag.y) * boundaries.y; // right\n    alpha += ss( diag.x) * ss(-diag.y) * boundaries.z; // top\n    alpha += ss( diag.x) * ss( diag.y) * boundaries.w; // left\n    \n    color = mix(vec3(2,3,1), vec3(1,2,3), alpha)/3.; \n    \n    if(iMouse.z > .5)\n    {\n        color = \n        mix(color, vec3(1), \n            dot(max(\n                    smoothstep(3.*ps, 2.*ps, grid_uv),\n                    smoothstep(1.-3.*ps, 1.-2.*ps, grid_uv)\n                ), vec2(1))\n            );\n    }\n    \n    color *= (1.-step(1., uv.x)) * step(0., uv.x);\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}