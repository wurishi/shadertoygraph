{"ver":"0.1","info":{"id":"ttGfDD","date":"1614332368","viewed":233,"name":"Circle blur (Gaussian?)","username":"nebbul","description":"Making a blur by sampling a texture multiple times in a circlular pattern. Could be used in game engines on windows or something like that by sampling Scene Color texture\n\nAfter seeing what Gaussian blur does, I also added a quality feature","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["blur","glass","postprocess","gaussian","gaussian","circular","fakeblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\nvec2 Rotate2dVector(vec2 v, vec2 a) {\n\treturn vec2(a.x*v.x - a.y*v.y, a.y*v.x + a.x*v.y);\n}\n\nvec2 GetVector(vec2 v, float rad) {\n    vec2 angle = vec2(cos(rad),sin(rad)); // how much to rotate vector, rotate as a circle\n    return Rotate2dVector(v, angle);\n}\n\n// sample texture multiple times in a circular pattern, like a flower\n// params:\n//    blurRadius: how far to push the blur, higher values require higher samples & quality\n//    samples: lacking better description; how many petals the flower has\n//    quality: interpolated scale of the blur radius for every petal; sub-petals!\n//\n//    final sample count = (samples * quality) - 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float blurRadius = 0.05; // how far to push each sample\n    // uncomment to visualize blur radius\n    //blurRadius = mix(0., 0.1, smoothstep(0., 0.5, mod(iTime*0.3, 1.)) - smoothstep(0.5, 1., mod(iTime*0.3, 1.)));\n    \n    float samples = 32.; // how many times to sample, when blur radius increase, this should also be increased\n    //uncomment to visualize sample count\n    //samples = floor(mix(3., 30., smoothstep(0., 0.5, mod(iTime*0.1, 1.)) - smoothstep(0.5, 1., mod(iTime*0.1, 1.))));\n    \n    float quality = 4.; // at least 2\n    //uncomment to visualize quality\n    //quality = floor(mix(2., 16., smoothstep(0., 0.5, mod(iTime*0.4, 1.)) - smoothstep(0.5, 1., mod(iTime*0.4, 1.))));\n    \n    vec2 vec = vec2(1.,0.); // initial vector, this is to be rotated like the dial of a clock\n    \n    vec4 col = texture(iChannel0, uv + vec);\n    \n    for(float i = 0. ; i < samples ; i++)\n    {\n        vec = GetVector(vec, ((M_PI * 2.) / samples));\n        \n        // with quality\n        for(float j = 1. ; j < quality ; j++)\n        {\n            float q = j / quality;\n            vec2 offset = vec * blurRadius * q;\n            col += texture(iChannel0, uv + offset);\n        }\n        \n        // without quality\n        //col += texture(iChannel0, uv + (vec * blurRadius));\n    }\n    \n    // with quality\n    col /= (samples * quality) - (samples-1.);\n    \n    // without quality\n    //col /= samples+1.;\n    \n    fragColor = vec4(0.,0.,0.,1.);\n    \n    float line = (sin(iTime * 2.) + 1.0) / 2.0;\n    // compare blur and no blur\n    if(uv.x < line - 0.001) fragColor = vec4(col.rgb, 1.0);\n    if(uv.x > line + 0.001) fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n\n    // Output to screen\n    fragColor = vec4(fragColor.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}