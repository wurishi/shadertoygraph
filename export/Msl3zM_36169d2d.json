{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"music","id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Copyright (c) 2013 Andrew Baldwin (twitter: baldand, www: http://thndl.com)\n// License = Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n\n// \"Mars Fleet Inspection\"\n\n#define LIGHTS\n#define ENGINE_GLOW\n#define MORE_SHIPS\n#define POST_PROCESS\n\nvec3 rnd3(vec3 n)\n{\n\tvec3 m = floor(n)*.00001 + fract(n);\n\tconst mat3 p = mat3(13.323122,23.5112,21.71123,21.1212,28.7312,11.9312,21.8112,14.7212,61.3934);\n\tvec3 mp = (31415.9+m)/fract(p*m);\n\treturn fract(mp);\n}\n\nvec3 rotateXp1( vec3 p)\n{\n    float s = 0.09983341664682815;\n    float c = 0.9950041652780258;\n    mat2  m = mat2(c,-s,s,c);\n\tvec2 yz = m*p.yz;\n    vec3  q = vec3(p.x,yz);\n    return q;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 d = abs(p) - s;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat pipe(vec3 p,float r,vec3 s)\n{\n\tfloat round = length(p.yz)-r;\n\treturn max(box(vec3(p), s),round);\n}\n\nfloat pipes(vec3 p)\n{\n\tvec3 pm = mod(p,10.)-5.;\n\tpm = vec3(p.x,pm.yz);\n\treturn pipe(pm,3.33,vec3(1000.,3.,3.));\n}\n\nfloat scalesphere(vec3 p, vec3 scale)\n{\n\tfloat s = length(p/scale);\n\treturn s;\n}\n\nfloat ship3(vec3 p)\n{\n\tfloat sd = length(mod(p,10.)-5.)-4.5;\n\tfloat sdb = box(mod(p,8.)-4.,vec3(3.));\n\tfloat hull = scalesphere(p,vec3(3.,1.,1.));\n\thull = min(max(hull-51.5,min(sd,sdb)),hull-50.);\n\tfloat engine = pipe(p-vec3(-95.,0.,0.),47.,vec3(60.,40.,40.));\n\tfloat pi = pipes(p-vec3(-155.,0.,0.));\n\tfloat pibox = box(p-vec3(-150.,0.,0.),vec3(8.,30.,30.));\n\tfloat spar = length(p.yz);\n\tfloat sparmask = max(max(max(-spar+2.-.31*p.x,spar-100.),-p.x-140.),p.x+94.);\n\tfloat detail = box(mod(p-1.,2.)-1.,vec3(.5)-.6*rnd3(floor(p+vec3(2.79238,1.2,2.31))));\t\n\tfloat s = max(max(min(hull,min(engine,max(pi,pibox))),-sparmask),-detail);\n\treturn s;\n}\n\nfloat ship3enginelights(vec3 p)\n{\n\tvec3 pm = mod(p,10.)-5.;\n\tfloat round = length(pm.yz)-3.;\n\tfloat pibox = box(p-vec3(-160.,0.,0.),vec3(20.,30.,30.));\n\treturn clamp(-max(pibox,round),0.,1.);\n}\n\nfloat ship3cabinlights(vec3 p)\n{\n\tvec3 s = rnd3(floor(p+vec3(2.79238,1.2,2.31)));\n\ts = vec3(.5)-.6*s;\n\tfloat detail = box(mod(p-1.,2.)-1.,s);\t\n\tdetail = s.x*s.y*s.z;\n\treturn detail;\n\t\t\n}\n\nfloat ship4(vec3 p)\n{\t\n\tfloat hull1 = pipe(p-vec3(0.,0.,11.),12.,vec3(30.,10.,10.));\n\tfloat hull2 = pipe(p-vec3(0.,0.,-11.),12.,vec3(30.,10.,10.));\n\tfloat cabin = scalesphere(p-vec3(30.,0.,0.),vec3(5.,1.5,1.))-12.;\n\tfloat cabinbottom = pipe(p-vec3(0.,-16.,0.),12.,vec3(100.,10.,10.));\n\tfloat detail = box(mod(p-.5,1.)-.5,vec3(.4)-.8*rnd3(floor(p+vec3(1.29238))));\t\n\treturn max(min(min(hull1,hull2),max(cabin,-cabinbottom)),-detail);\n}\n\nfloat ship5(vec3 p)\n{\n\treturn pipe(p,5.5+2.*sin(p.x*.5),vec3(33.,5.,5.));\n}\n\nfloat planet(vec3 p)\n{\n\treturn length(p)-70300.0;\t\n}\n\nfloat map(vec3 position)\n{\n\tfloat p = planet(position-vec3(0.,-71500.0,0.));\n\tif (p<1000.) return p;\n\tif (p>1500.) return p-1000.;\n\tvec3 bs = vec3(1000.,300.,300.);\n\tvec3 sp = mod(position-vec3(500.,-500.,500.),bs)-bs*.5;\n\tvec3 spf = floor((position-vec3(500.,-500.,500.))/bs);\n\tfloat s;\n\tvec3 sc = sp;\n#ifdef MORE_SHIPS\n\tvec3 r = rnd3(spf);\n\tfloat cs = r.x;\n\tfloat cr = r.y;\n\tif (cr>.5) sc = rotateXp1(sp);\n\tif (cs>.75) s = ship5(sc);\n\telse if (cs>.5) s = ship4(sc);\n\telse  \n#endif\n\t\ts = ship3(sc);\n\tfloat fleetbox = box(position,vec3(1500.,100.,1000.));\n\treturn min(max(fleetbox,s),p);\n}\n\nfloat mat(vec3 position, out vec3 modelpos)\n{\n\tfloat p = planet(position-vec3(0.,-71500.0,0.));\n\tmodelpos = position;\n\tif (p<1000.0) return 0.; // Planet\n\tfloat fleetbox = box(position,vec3(1500.,100.,1000.));\n\tvec3 bs = vec3(1000.,300.,300.);\n\tvec3 sp = mod(position-vec3(500.,-500.,500.),bs)-bs*.5;\n\tvec3 spf = floor((position-vec3(500.,-500.,500.))/bs);\n\tmodelpos = sp;\n\tvec3 sc = sp;\n#ifdef MORE_SHIPS\n\tvec3 r = rnd3(spf);\n\tfloat cs = r.x;\n\tfloat cr = r.y;\n\tif (cr>.5) modelpos = rotateXp1(sp);\n\tif (cs<=.5) {\n#ifdef ENGINE_GLOW\n\t\tfloat engine = ship3enginelights(modelpos);\n#endif\n#ifdef LIGHTS\n\t\tfloat cabin = ship3cabinlights(modelpos);\n#endif\n\t\tif (fleetbox<0.01) {\n#ifdef ENGINE_GLOW\n\t\t\tif (engine>0.) {\n\t\t\t\tmodelpos.x = engine;\n\t\t\t\treturn 3.;\n\t\t\t}\n#endif\n#ifdef LIGHTS\n\t\t\tif (cabin>.1) {\n\t\t\t\tmodelpos.x = cabin*12.;\n\t\t\t\treturn 4.;\n\t\t\t}\n#endif\n\t\t}\n\t}\n#endif\n\tif (p<1500.0) return 1.; // Ships\n\tmodelpos = position;\n\treturn 2.; // Space\n}\nvec3 normal(vec3 pos,float e)\n{\n\tvec3 eps = vec3(e,0.,0.);\n\tfloat dx = map(pos+eps.xyy);\n\tfloat dy = map(pos+eps.yxy);\n\tfloat dz = map(pos+eps.yyx);\n\tfloat mdx = map(pos-eps.xyy);\n\tfloat mdy = map(pos-eps.yxy);\n\tfloat mdz = map(pos-eps.yyx);\n\treturn normalize(vec3(dx-mdx,dy-mdy,dz-mdz));\n}\n\n// From P_Malin https://www.shadertoy.com/view/lssGzn \n// http://en.wikipedia.org/wiki/Schlick's_approximation\nfloat Schlick( const in vec3 vNormal, const in vec3 vView, const in float fR0, const in float fSmoothFactor)\n{\n\tfloat fDot = dot(vNormal, -vView);\n\tfDot = min(max((1.0 - fDot), 0.0), 1.0);\n\tfloat fDot2 = fDot * fDot;\n\tfloat fDot5 = fDot2 * fDot2 * fDot;\n\treturn fR0 + (1.0 - fR0) * fDot5 * fSmoothFactor;\n}\n \nvoid flightPath(float time, out vec3 cameraPosition, out vec3 cameraTarget)\n{\n\tfloat radius = 180.;\n\tvec3 start = vec3(-2000.,-200.,120.);\n\tfloat ab = smoothstep(0.,20.,time);\n\tfloat rotate = max(time-20.0,0.)*.1;\n\tcameraPosition = mix(start,vec3(0.,0.,120.),ab) +  vec3(radius*cos(rotate),100.*sin(rotate*.7),radius*sin(rotate));\n\tcameraTarget = vec3(0.,-100.+200.0*iMouse.y/iResolution.y,0.); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = 10.*iMouse.x/iResolution.x-5.;\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.xy)-1.; // Covers space range (-1,-1) to (+1,+1). for x & y - could also be pre-provided as coordinate\n\tvec2 screen = uv*vec2(iResolution.x/iResolution.y,1.0); // Screen aspect ratio correction\n\t\n\t// Calculate the camera model and initial ray for this pixel\n\tvec3 cameraPosition, cameraTarget;\n\tflightPath(iTime,cameraPosition,cameraTarget);\n\tvec3 forwards = normalize(cameraTarget-cameraPosition); // Forwards direction\n\tvec3 upwards = normalize(vec3(0.0, 1.0, 0.0)); // Upwards direction\n\tvec3 screenX = normalize(cross(forwards,upwards)); // Screen x axis\n\tvec3 screenY = normalize(cross(screenX,forwards)); // Screen y axis\n\tvec3 rayDirection = normalize( screen.x*screenX + screen.y*screenY + 2.0*forwards ); // Screen is just ahead of camera\n\n    // Estimate with sphere-marching into distance-field intersection of ray with model\tsurface\n\tfloat distanceToSurface = 0.; \n\tbool surfaceNotHitYet = true;\n\tfloat distanceAlongRay = 0.; //\n\tvec3 position;\n\tfor (int i=0;i<150;i++) {\n\t\tif (surfaceNotHitYet) { // Optimisation if GPU can handle conditionals well\n\t\t\tdistanceAlongRay += distanceToSurface*.75; // Step forwards\n\t\t\tposition = cameraPosition + distanceAlongRay * rayDirection; // Calculate new position\n\t\t\tdistanceToSurface = map(position); // Find nearest surface\n\t\t\tif (distanceToSurface <= 0.001*distanceAlongRay) surfaceNotHitYet = false;\n\t\t\tif (distanceToSurface > 2000.0) surfaceNotHitYet = false;\n\t\t}\n\t}\n\t\n\t// Now march to check shadows from sunlight\n\tvec3 lightdir = vec3(2000.*cos(iTime*.01),2000.*sin(iTime*.01),2000.);\n\tvec3 light = position+lightdir;\n\tvec3 lightray = normalize(-lightdir);\n\tfloat ll = length(lightdir);\n\tdistanceToSurface = 0.; \n\tsurfaceNotHitYet = true;\n\tdistanceAlongRay = 0.;//\n\tvec3 lposition;\n\tfor (int i=0;i<50;i++) {\n\t\tif (surfaceNotHitYet) { // Optimisation if GPU can handle conditionals well\n\t\t\tdistanceAlongRay += distanceToSurface; // Step forwards\n\t\t\tlposition = light + distanceAlongRay * lightray; // Calculate new position\n\t\t\tdistanceToSurface = map(lposition); // Find nearest surface\n\t\t\tif (distanceToSurface <= 0.0001*distanceAlongRay) surfaceNotHitYet = false;\n\t\t\tif (distanceToSurface > ll) surfaceNotHitYet = false;\n\t\t}\n\t}\n\tfloat lit = .1+step(0.,distanceAlongRay-ll+1.); \n\tfloat p = length(position-cameraPosition);\n\tvec3 n = normal(position,0.002*p);\n\tvec3 ref = -reflect(-lightray,n);\n    float fre = Schlick(n, rayDirection, .3, 1.3);//pow(clamp(1.0 + dot(n,-rayDirection), 0.0, 1.0 ), 2.0 );\n\n\tvec3 modelpos;\n\tfloat m = mat(position,modelpos);\n\tvec3 bc;\n\tvec3 colour;\n\tif (m==0.0) { // Planet\n\t\tvec3 rc0 = rnd3(floor(modelpos*.00123)+.1212);\n\t\tbc = vec3(1.,.5,.2)*texture(iChannel0,vec2(modelpos.x+iTime*100.,modelpos.z)*.00001).rgb;\n\t    colour = lit*(bc*vec3(.1+max(0.,dot(n,normalize(lightdir))))+fre);\n\t} else if (m==1.0) { // Ships\n\t\tvec3 rc0 = rnd3(floor(modelpos*2.123)+.1212);\n\t\tvec3 rc1 = rnd3(floor(modelpos*.52)+.1212);\n\t\tvec3 rc2 = rnd3(floor(modelpos*.123)+.1212);\n\t\tbc = vec3(.8+.5*.3333*(rc0.r+rc0.g+rc0.b)*(rc1.r+rc1.g+rc1.b)*(rc2.r+rc2.g+rc2.b)+.2*rc1+.2*rc2+.2*rc0);\n\t    colour = lit*(bc*vec3(.1+max(0.,dot(n,normalize(lightdir))))+fre);\n\t} else if (m==2.0) { // Space\n\t\tcolour = vec3(0.);\n\t\tlit = 1.;\n\t} else if (m==3.0) { // Engines\n\t\tcolour = 3.*vec3(.3,.9,1.)*modelpos.x;\n\t} else if (m==4.0) {\n\t\tcolour = 1.75*vec3(1.,1.,.5)*modelpos.x*dot(n,-rayDirection);\n\t}\n\t\n\tcolour = colour / (1.0 + colour); // Tone mapping\n#ifdef POST_PROCESS\n\tcolour = pow(colour, vec3(2.2)); // Gamme\n\tcolour = 2.*colour-0.3; // Brightness/contrast\n\tcolour *= vec3( 1.04, 1.0, 1.0); // Redish tint\n\tvec2 vs = fragCoord.xy / iResolution.xy;\n\tcolour *= pow( 16.0*vs.x*vs.y*(1.0-vs.x)*(1.0-vs.y), 0.3 ); // Vignetting\n#endif\n\tfragColor = vec4(colour,0.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msl3zM","date":"1366647126","viewed":455,"name":"Mars Fleet","username":"baldand","description":"I wanted to make a fleet of big ships in the style of 70s sci-fi book cover artwork.\nMouse up/down to change view a bit.\nHigh quality render: http://www.youtube.com/watch?v=fw9o4KhaWIg","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""}}