{"ver":"0.1","info":{"id":"XtyyWD","date":"1537193651","viewed":89,"name":"assignment 1","username":"JBtheHUT1988","description":"unfinished","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n    //defining edges ( from point P0 to point P1\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n    //create vector from each triangle point to the sample point \"p\"\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n    \n    //\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\t//circle move\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 center = vec2(iMouse.x, iMouse.y);//+ (iMouse.x+iMouse.y);//* (iMouse.x+iMouse.y);\n    float radius = 25.0;\n\n    vec3 col = vec3(0.35);\n    \n    \n    //the if designates where the circle and to what dimensions the circle will be drawn\n    \n    if(sqrt(pow(center.x -fragCoord.x, 2.0)\n            +pow(center.y - fragCoord.y,2.0))<radius)\n        col = vec3(1.0);//then draw this color\n    \n    \n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    \n    //creating animated vertices for our triangle\n\tvec2 v1 = cos( iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = cos( iTime + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = cos( iTime + vec2(0.0,3.00) + 4.0 );\n\n    //distance from current Pixel to triangle\n\tfloat d = sdTriangle( v1, v2, v3, p );\n    \n    \n    //vec3 col = vec3(0.0);\n    float checkerSize = 20.0;\n    \n    vec3 checkCol = vec3(0.0);\n    \n    //handle X direction\n    if(int(fragCoord.x/checkerSize) % 2 == 0){\n        if(int(fragCoord.y/checkerSize) % 2 == 0)\n        \tcheckCol = vec3(1.0);\n    }\n    else // fragCoord.X % 2 == 1\n    \tif(int(fragCoord.y/checkerSize) % 2 == 1)\n       \tcheckCol = vec3(1.0);\n    \n    if(d < 0.0) //check if inside triangle\n       col = checkCol;\n        \n            \n \tcenter = vec2(iMouse.x+50.0, iMouse.y);//+ (iMouse.x+iMouse.y);//* (iMouse.x+iMouse.y);\n        \n            //the if designates where the circle and to what dimensions the circle will be drawn\n    if(sqrt(pow(center.x -fragCoord.x, 2.0)\n            +pow(center.y - fragCoord.y,2.0))<radius)\n        col = vec3(1.0);//then draw this color\n    \n    \n    center = vec2(150 , 350);//+ (iMouse.x+iMouse.y);//* (iMouse.x+iMouse.y);\n    \n                //the if designates where the circle and to what dimensions the circle will be drawn\n    if(sqrt(pow(center.x -fragCoord.x, 2.0)\n            +pow(center.y - fragCoord.y,2.0)*4.0)<radius)\n        col = vec3(1.0);//then draw this color\n    \n    /*\n\t// Throbby Rainbow by PixlPa\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Signed normalized\n    uv = uv*2.-1.;\n    // with aspect ratio applied\n    uv *= vec2(iResolution.x/iResolution.y,1.);\n\n    // Output to screen\n    fragColor = rainbow(uv,iTime*3.);\n\t*/\n    \n    vec2 uv2 = fragCoord/iResolution.xy;\n    uv2 = uv2*8.-1.;\n    uv2 *= vec2(iResolution.x/iResolution.y,1.);\n    \n    if(uv2.x < 2.0 && uv2.y < 2.0)\n    \tfragColor = rainbow(uv2,iTime*3.);\n    else\n    \tfragColor = vec4(col, 1.0);\n}\n\n\n/*\n--------Credits-------\n\t// Throbby Rainbow by PixlPa\nTriangle 2d\nLandon's files from blackboard\n--------End Credits-------\n*/\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\t//checkered triangle move\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tp *= 1.5;\n    \n    //creating animated vertices for our triangle\n\tvec2 v1 = cos( iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = cos( iTime + vec2(0.0,1.50) + 1.5 );\n\tvec2 v3 = cos( iTime + vec2(0.0,3.00) + 4.0 );\n\n    //distance from current Pixel to triangle\n\tfloat d = sdTriangle( v1, v2, v3, p );\n\n    vec3 col = vec3(0.0);\n    float checkerSize = 20.0;\n    \n    vec3 checkCol = vec3(0.0);\n    \n    //handle X direction\n    if(int(fragCoord.x/checkerSize) % 2 == 0){\n        if(int(fragCoord.y/checkerSize) % 2 == 0)\n        \tcheckCol = vec3(1.0);\n    }\n    else // fragCoord.X % 2 == 1\n    \tif(int(fragCoord.y/checkerSize) % 2 == 1)\n       \tcheckCol = vec3(1.0);\n    \n    if(d < 0.0) //check if inside triangle\n       col = checkCol;\n    \n\tfragColor = vec4(col,1.0);\n}\n*/\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec4 rainbow( vec2 st, float time )\n{\n   \t//band thickness\n    float thick = 0.4;\n    //start distance\n    float off = 0.1;\n    //drop UVs down to center the rainbow\n    vec2 lower = clamp(st + vec2(0.,0.5),vec2(-2,0.),vec2(2.));\n    \n    //distance from center (for a nice arc)\n    float rbg = length(lower);\n\t//angle\n    float angle = atan(lower.x,lower.y);\n    \n    //animate the gradient a little\n    rbg += sin(angle*2.+time*1.3)*0.1*thick;\n    rbg += sin(rbg*3.1+time)*0.2*thick;\n    //band logic\n    float band1 = step(0.5*thick+off,rbg)*step(rbg,1.*thick+off);\n    float band2 = step(1.0*thick+off,rbg)*step(rbg,1.5*thick+off);\n    float band3 = step(1.5*thick+off,rbg)*step(rbg,2.*thick+off);\n    float band4 = step(2.*thick+off,rbg)*step(rbg,2.5*thick+off);\n    float band5 = step(2.5*thick+off,rbg)*step(rbg,3.*thick+off);\n    float block = step(-0.75,st.y);\n    \n    //apply colors to bands\n    //it's not ROYGBIV but this is cartoons\n    //there's an unused \"band\" but whatever 4 seemed ok\n    vec4 rb = vec4(1.,0.,0.,1.)*band1;\n    rb += vec4(1.,0.8,0.,1.)*band2;\n    rb += vec4(0.7,1.,0.2,1.)*band3;\n    rb += vec4(0.,0.7,1.,1.)*band4;\n    rb *= block;\n    \n    return rb;\n}","name":"Common","description":"","type":"common"}]}