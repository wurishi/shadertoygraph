{"ver":"0.1","info":{"id":"Nt2XRw","date":"1627419896","viewed":97,"name":"Raymarching Infinite Blobs","username":"david_poj","description":"A classic implementation of raymarching with reflections.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","infinity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 1000.\n#define SURF_DIST 1e-3\n\nvec4 sdSphere(vec3 p, vec3 bp, float r){\n    p -= bp;\n    float dist = length(p) - r;\n    vec3 color = vec3(1.0, 1.0, 0.0);\n    return vec4(color, dist);\n}\n\nvec4 sdGradCheckPlane(vec3 p, vec3 n, float h){\n    float dist = dot(p, n) + h;\n    vec3 colorA = vec3(1.0,0.0,0.0);\n    vec3 colorB = vec3(0.3, 0.5, 1.0);\n    vec3 AB = mix(colorA, colorB, vec3(abs(p.z/12.)));\n    \n    vec3 q = floor(p);\n    float c = abs(mod((q.x + q.z), 2.0));\n    vec3 color = vec3(c)*AB;\n    return vec4(color, dist);\n}\n\nvec4 sdPlane(vec3 p, vec3 n, float h){\n    float dist = dot(p, n) + h;\n    vec3 color = vec3(1.0,1.0,1.0);\n    return vec4(color, dist);\n}\n\n\n\nvec4 sdInfSphere(vec3 p, vec3 bp, float r, float c){\n    p -= bp;    \n    vec3 q = mod(p+0.5*c, c) - (0.5*c);\n    float dist =  length(q) - r;\n    vec3 color = vec3(0.1, 0.1, .3);\n    float disp = sin(5.0 * p.x) * sin(5.0 * p.y) * cos(5.0 * p.z) * 0.25 * sin(iTime);\n    return vec4(color, dist+disp);\n}\n\nvec4 GetDist(vec3 p){\n    vec4 object;\n    vec4[] objects = vec4[](\n        sdInfSphere(p, vec3(0.,0.,-5), 1., max(3., sin(iTime)*10.0)),\n        sdGradCheckPlane(p, vec3(0,1,0), 1.)\n    );\n    float dist_min = MAX_DIST*MAX_DIST;\n    for (int j = 0; j < objects.length(); j++) {\n        float dist = objects[j].w;\n        if (dist < dist_min) {\n            dist_min = dist;\n            object = objects[j];\n        }\n    }\n\n    return object;\n}\n\n\nvec3 GetNormal(vec3 p){\n    vec2 e = vec2(1e-3, 0.);\n    vec3 n = GetDist(p).w - vec3(\n        GetDist(p - e.xyy).w,\n        GetDist(p - e.yxy).w,\n        GetDist(p - e.yyx).w);\n    return normalize(n);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd){\n    vec4 object;\n    float dist = 0.01;\n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + dist * rd;\n        object = GetDist(p);\n        dist += object.w;\n        object.w = dist;\n        if (object.w < SURF_DIST || dist > MAX_DIST) break;\n    }\n    return object;\n}\n\nvec4 traceRef(vec3 ro, vec3 rd){\n    vec4 object;\n    float dist = 0.;\n    for (int i = 0; i < (MAX_STEPS/2); i++){\n        vec3 p = ro + dist * rd;\n        object = GetDist(p);\n        dist += object.w;\n        object.w = dist;\n        if (object.w < SURF_DIST || dist > (MAX_DIST/2.)) break;\n    }\n    return object;\n}\n\n//https://iquilezles.org/articles/rmshadows\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDist(ro + rd*t).w;\n        if( h < 0.01)\n            return 0.0;\n        if(h > maxt){\n            return 1.0;\n        }\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        \n    }\n    return res;\n}\n\nvec3 GetLight(vec3 p, vec3 lightPos){\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = clamp(dot(n,l), 0., 1.);\n    \n    float distToLight = length(lightPos - p);\n    float shadow = softshadow(p + (n * 0.015 * 3.), l, 0., min(distToLight,100.), 32.);\n    return vec3(diff*shadow);\n}\n\nvec3 GetRayDir(vec2 uv, vec2 size, float fov){\n    float fovadj = tan(radians(fov) / 2.0);\n    float ar = size.x / size.y;\n    uv.x = (1.0 - (uv.x / size.x)*2.0)* ar * fovadj;\n    uv.y = ((uv.y / size.y)*2.0 - 1.0)* fovadj ;\n    return normalize(vec3(uv, -1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get Rays\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,2,0);\n    vec3 rd = GetRayDir(fragCoord.xy + 0.5, iResolution.xy, 90.);\n       \n    //First Pass\n    vec4 rm = RayMarch(ro, rd);\n    vec3 p = ro + rm.w * rd;\n    vec3 lightPos = vec3(2,2,-1);\n    vec3 diff = GetLight(p, lightPos)*2.0;\n    col = rm.xyz * diff;\n    \n    //Reflection Pass\n    vec3 norm = GetNormal(p);\n    vec3 rr = reflect(rd, norm);\n    vec3 newp = p + norm*0.1*3.;\n    vec4 refl = RayMarch(newp, rr)*0.9;\n    vec3 diff2 = GetLight(newp + (refl.w * rr), lightPos);\n    col += (refl.xyz * diff2);\n    \n    //Add Fog\n    float fog = smoothstep(0., .95, rm.w / 100.);\n    col = mix(col, vec3(0.3, 0.5, 1.0), fog);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}