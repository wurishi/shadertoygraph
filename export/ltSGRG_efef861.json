{"ver":"0.1","info":{"id":"ltSGRG","date":"1429816435","viewed":605,"name":"Experiment#DF2","username":"tomkh","description":"New version: [url=https://shadertoy.com/view/llSGRy]llSGRy[/url]  and [url=https://shadertoy.com/view/Xt23zG]Xt23zG[/url].\nInspired by \"The evolution of motion\" (by x1Tr1m), NVScene15 seminar (by Cupe) and pouet discussion.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Just for my own educational purposes...\n// tomkh@2015\n\n#define SCENE 0\n// 0 = centered bboxes\n// 1 = centered decorated bboxes\n// 2 = non-centered bboxes\n\nconst int ray_steps = 80;\nconst float dist_max = 10.0;\nconst float fog_start = 8.0;\nconst float fog_density = 0.15;\nconst float cam_dist = 10.0;\n\n// Tile space:\nconst float tile_d = 2.0;\nconst float tile_ood = 1.0/tile_d;\n\n// +-----+-----+\n// |     |     |\n// |  A--|--B  |\n// |  |p |  |  |\n// +-----+-----+\n// |  |  |  |  |\n// |  C--|--D  |\n// |     |     |\n// +-----+-----+\n// Say we want to find DF(p) = a distance field for \"p\",\n// and \"p\" is inside ABCD boundary, where A, B, C and D are our tiles (aka cells).\n// We have to assume max/min height for tiles outside A,B,C,D.\n// We call \"frame\", a bounding area for everything outside A,B,C,D (estimated using max/min height).\n// Algorithm:\n//   For \"p\" we evaluate DF for 4 tiles (A,B,C,D) (TODO: use distance-dependent rough estimation ala Cupe)\n//   and bound it additionally to distance to frame.\n// Note:\n//   Actually you would need this \"frame\" only in extreme cases\n//   (i.e. variations in height, some tiles almost empty),\n//   but I've added it here anyway just for correctness,\n//   as this is a framework that I plan to reuse in other experiments.\n\nfloat dist2frame(vec3 p, float box_y)\n{\n    vec3 dp = vec3(\n        tile_d-abs(p.x),\n        max(0.0,abs(p.y)-box_y),\n        tile_d-abs(p.z));\n    return length(vec2(min(dp.x,dp.z),dp.y));\n}\n\nfloat dist2box(vec3 p, float box_x, float box_y, float box_z, float box_r)\n{\n    // Distance to rounded box:\n    vec3 dp = vec3(\n        max(0.0,abs(p.x)-box_x),\n        max(0.0,abs(p.y)-box_y),\n        max(0.0,abs(p.z)-box_z));\n    return length(dp) - box_r;\n}\n\nfloat evaluate_tile(vec3 p, vec3 p_id, float dx, float dy)\n{\n    p_id.xz += vec2(dx,dy);\n    p.xz -= vec2(dx-.5,dy-.5)*tile_d;\n    float anim = iTime*.25;\n#if SCENE == 2\n    float p1 = 0.1 + abs(sin(p_id.x+anim)*sin(p_id.z+anim*.33))*.9;\n    float id = p_id.x + p_id.z;\n    vec3 p2 = p + vec3(cos(id*3.0+anim*1.11),0,sin(id*3.0+anim*1.11))*.5;\n    float dist = dist2box(p2, .25, p1, .25, 0.025);\n#else\n    float p1 = 0.2 + abs(sin(p_id.x+anim)*sin(p_id.z+anim*.33))*.8;\n    float p2 = 0.2 + abs(cos(p_id.x+anim*.5)*cos(p_id.z+anim*.66))*.7;\n    float dist = dist2box(p, p2, p1, p2, 0.025);\n    #if SCENE == 1\n        dist = min(dist, dist2box(p, p2+.1, p1-.1, .1, 0.025));\n        dist = min(dist, dist2box(p, .1, p1-.1, p2+.1, 0.025));\n    #endif\n#endif\n    return dist;\n}\n\nfloat get_distance(vec3 p)\n{\n    vec3 p_id = vec3(\n        floor(p.x*tile_ood),\n        0,\n        floor(p.z*tile_ood));\n    \n    p = vec3(\n        (fract(p.x*tile_ood)-.5)*tile_d,\n        p.y, //(fract(p.y*tile_ood)-.5)*tile_d,\n        (fract(p.z*tile_ood)-.5)*tile_d);\n    \n    float dist = dist2frame(p, 1.0);\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 1.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 1.0));\n\n    return dist;\n}\n\nvec3 get_normal(vec3 p)\n{\n    const float eps = 1e-3;\n    const vec3 x_eps = vec3(eps,0,0);\n    const vec3 y_eps = vec3(0,eps,0);\n    const vec3 z_eps = vec3(0,0,eps);\n    return normalize(vec3(\n        get_distance(p + x_eps) - get_distance(p - x_eps),\n        get_distance(p + y_eps) - get_distance(p - y_eps),\n        get_distance(p + z_eps) - get_distance(p - z_eps) ));\n}\n\nvec3 trace(vec3 p_start, vec3 n)\n{\n    float ray_len;\n    float dist;\n    const float dist_eps = .001;\n    vec3 p = p_start;\n    for(int k=0; k<ray_steps; ++k) {\n    \tdist = get_distance(p);\n        if (dist < dist_eps || dist > dist_max) break;\n        p += dist*n;\n        ray_len += dist;\n    }\n    \n    //vec3 light_dir = normalize(vec3(.1,1.0,-.3));\n    float light_ang = iMouse.x/iResolution.x*3.0;\n    vec3 light_dir = normalize(vec3(cos(light_ang),2.0,-sin(light_ang)));\n    vec3 normal = get_normal(p);\n    float shade = 0.0;\n    if (dist < dist_eps) {\n        //shade = (1.0 - dist/dist_eps)*dot(normal, light_dir);\n        shade = dot(normal, light_dir);\n        shade = max(0.0, shade);\n    }\n    \n    vec3 base_color = vec3(1.0,1.0,1.0);\n    vec3 color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),shade)*base_color;\n    \n    // Test ray with cut_plane:\n    float cut_plane = (iMouse.y / iResolution.y - 0.1) * 4.0;\n    if (p_start.y > cut_plane) {\n    \tfloat d = (p_start.y - cut_plane) / -n.y;\n        if (d < ray_len) {\n            vec3 hit = p_start + n*d;\n            float iso = fract(get_distance(hit)*5.0);\n            vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n            color = mix(color,dist_color,.5);\n            ray_len = d;\n        }\n    }\n    \n    vec3 fog_color = vec3(.8,.8,.8);\n    float fog = 1.0-1.0/exp(max(0.0,ray_len-fog_start)*fog_density);\n    color = mix(color,fog_color,fog);\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    \n    float anim = iTime*.25;\n    \n    float a = -0.2; //iMouse.x / iResolution.x * 2.0 - 1.0; \n    a += cos(anim)*.05;\n    float co = cos(a);\n    float si = sin(a);\n    vec3 p1 = vec3(-cam_dist*si, 0, -cam_dist*co);\n    vec3 n1 = normalize(vec3(uv,1));\n    vec3 n2 = vec3(n1.x*co + n1.z*si, n1.y, -n1.x*si + n1.z*co);\n    \n    //a = iMouse.y / iResolution.y * 2.0 + sin(anim*(2.0/3.0))*.2 - 2.0;\n    a = -.4;\n    co = cos(a);\n    si = sin(a);\n    vec3 p2 = vec3(p1.x, p1.y*co + p1.z*si, -p1.y*si + p1.z*co);\n    vec3 n3 = vec3(n2.x, n2.y*co + n2.z*si, -n2.y*si + n2.z*co);\n    \n    fragColor = vec4(trace(p2, n3), 1.0);\n    \n}","name":"","description":"","type":"image"}]}