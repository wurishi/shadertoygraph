{"ver":"0.1","info":{"id":"XldGDn","date":"1468755997","viewed":230,"name":"Jolanta Blues","username":"vapoi","description":"the outer smoke/light part of a shader i created for a music visualization.\nhttps://www.youtube.com/watch?v=xZhWhDayP5g","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","clouds","smoke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float fPi = 3.14159;\n\n\n// Noise part:\n    //\n    // GLSL textureless classic 2D noise \"cnoise\",\n    // with an RSL-style periodic variant \"pnoise\".\n    // Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n    // Version: 2011-08-22\n    //\n    // Many thanks to Ian McEwan of Ashima Arts for the\n    // ideas for permutation and gradient selection.\n    //\n    // Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n    // Distributed under the MIT license. See LICENSE file.\n    // https://github.com/ashima/webgl-noise\n    //\n\n    vec4 mod289(vec4 x)\n    {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n\n    vec4 permute(vec4 x)\n    {\n      return mod289(((x*34.0)+1.0)*x);\n    }\n\n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n\n    vec2 fade(vec2 t) {\n      return t*t*t*(t*(t*6.0-15.0)+10.0);\n    }\n\n    // Classic Perlin noise\n    float cnoise(vec2 P)\n    {\n      vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n      vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n      Pi = mod289(Pi); // To avoid truncation effects in permutation\n      vec4 ix = Pi.xzxz;\n      vec4 iy = Pi.yyww;\n      vec4 fx = Pf.xzxz;\n      vec4 fy = Pf.yyww;\n\n      vec4 i = permute(permute(ix) + iy);\n\n      vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n      vec4 gy = abs(gx) - 0.5 ;\n      vec4 tx = floor(gx + 0.5);\n      gx = gx - tx;\n\n      vec2 g00 = vec2(gx.x,gy.x);\n      vec2 g10 = vec2(gx.y,gy.y);\n      vec2 g01 = vec2(gx.z,gy.z);\n      vec2 g11 = vec2(gx.w,gy.w);\n\n      vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n      g00 *= norm.x;  \n      g01 *= norm.y;  \n      g10 *= norm.z;  \n      g11 *= norm.w;  \n\n      float n00 = dot(g00, vec2(fx.x, fy.x));\n      float n10 = dot(g10, vec2(fx.y, fy.y));\n      float n01 = dot(g01, vec2(fx.z, fy.z));\n      float n11 = dot(g11, vec2(fx.w, fy.w));\n\n      vec2 fade_xy = fade(Pf.xy);\n      vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n      float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n      return 2.3 * n_xy;\n    }\n\n\n// Shader part\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 pMid = vec2(-1.0, -1.0) + 2.0 * uv;\n    pMid.x *= iResolution.x / iResolution.y;\n    \n    float cTime = iTime * 01.3;\n    float v = 0.01;\n    vec3 colMixed = vec3(0.0);\n    float yHeight = uv.y * 2.0;\n    \n    float rndMidLine =   smoothstep(0.85, 01.0, yHeight) \n\t\t\t\t\t\t* smoothstep(-01.10, -0.8500, -yHeight);\n    \n    float rndT1 = cnoise(vec2(0.2, 0.3) * -cTime * 0.72 +  vec2(4.13, 3.2) * pMid) ;\n    float rndT2 = cnoise(vec2(0.2, 0.35) * -cTime * 2.72 +  vec2(3.13, 3.2) * pMid);\n\tfloat rndT2a = sin(cnoise(vec2(0.37, 0.43) * cTime * 3.32 -  vec2(3.3, 2.05) * pMid * 3.50) * fPi * 0.5);\n\tfloat rndTTT = rndT2 * 0.20 + rndT2a * 0.11;\n\tfloat rndDD1a = 0.0;\n    float jVal = 0.0;\n    \n\tfor (int j = 0; j < 3; j++)\n\t{\n        jVal = float(j) * 0.1;\n\t\t\t\n\t\trndDD1a += cnoise(pMid * vec2(0.70 , 1.20) * 2.20\n\t\t\t\t\t\t+ vec2(0.4 * rndTTT * rndMidLine, 19.95 + rndTTT * 0.2 + 0.29 * rndMidLine * (0.31 + jVal))\n\t\t\t\t\t\t- vec2(0.45 * max(0.0, (rndDD1a - 0.65)), 0.82 * (rndDD1a + 0.3))\n\t\t\t\t\t\t- vec2(0.01, 0.5) * (cTime * 0.83)\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t);\n\t}\n    \n    vec3 colV = vec3(0.5, 0.2, 0.05) * 0.65;\n\tcolV += 0.8 * vec3(0.750, 0.1, 0.050) \n\t\t\t\t* \n\t\t\t\t(abs(1.0 - cos(3.5 * max(rndDD1a - 0.5, 0.0) + rndTTT)) * 01.50)\n\t\t\t\t;\n\t\t\t\t\n    v = max(0.0, sin(rndDD1a + (rndTTT + 0.5) * 0.5) - 0.40) * 03.0;\n\tv = pow(v, 3.50) * 0.18;\n    \n    colV += (rndTTT + 0.5) * vec3(0.0, 0.30, .7) * (rndT2 * 0.5 + (rndT1 + 1.0) * 0.5) * 01.20;\n    \n    float blutOuter = 01.050;\n\tfloat outerBloodToGrey = 0.75;\n\tfloat gray = dot(colV, vec3(0.3, 0.6, 0.1));\n\tvec3 colOuterBlood = mix(vec3(.95, .90, 0.8) * gray, colV, 1.0 - outerBloodToGrey);\n\tcolMixed += blutOuter * colOuterBlood * v * \n\t\t\t\tsmoothstep(0.88, 01.0, yHeight) * smoothstep(0.4, 01.30, yHeight) *\n\t\t\t\tsmoothstep(-1.4, -1.20, -yHeight - 0.1 + rndTTT * 0.05);\n    \n    colMixed += mix(vec3(.60, 1.510, 1.0) , vec3(0.70, 01.2, 01.60) ,  max(-0.50, ((rndT2 * 0.5 + rndT2a * 0.0) + 1.0)) * 0.5) * colOuterBlood * gray * v \n\t\t\t\t* smoothstep(0.850, 0.87, yHeight)\n\t\t\t\t* smoothstep(-01.10, -0.8, -yHeight + rndTTT * 0.15)\n\t\t\t\t* 2.0;\n    \n    \n    float yLine = smoothstep(-0.90, -0.8, -yHeight);\n    \n    colMixed += yLine * vec3(1.0) * 0.25 * v;\n    \n    \n    \n\t// v * vec3(.50) * colV\n    \n\tfragColor = vec4(colMixed,1.0);\n}","name":"Image","description":"","type":"image"}]}