{"ver":"0.1","info":{"id":"MfcyDj","date":"1731164412","viewed":171,"name":"City-lights ","username":"Izixs","description":"Used in lesson, not originally mine","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Reinder Nijhoff 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/Xtf3zn\n//\n// Tokyo by night in the rain. The car model is made by Eiffie\n// (Shiny Toy': https://www.shadertoy.com/view/ldsGWB). \n// I have never been in Tokyo btw.\n\n\n#define BUMPMAP\n#define MARCHSTEPS 100\n#define MARCHSTEPSREFLECTION 48\n#define LIGHTINTENSITY 10.\n#define FOG_DENSITY 0.02\n#define FOG_HEIGHT_FALLOFF 0.15\n\n\n//----------------------------------------------------------------------\n\nconst vec3 backgroundColor = vec3(0.2,0.4,0.9) * 0.09;\n#define time (iTime + 90.)\n\n//----------------------------------------------------------------------\n// noises\n\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*687.3123);\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n//    f += 0.0625*noise( p );\n    \n    return f/0.9375;\n}\n\n//----------------------------------------------------------------------\n// distance primitives\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n\n\n\nfloat sdBox( in vec3 p, in vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( in vec3 p, in float s ) {\n    return length(p)-s;\n}\n\nfloat sdCylinder( in vec3 p, in vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------\n// distance operators\n\nfloat opU( float d2, float d1 ) { return min( d1,d2); }\nfloat opS( float d2, float d1 ) { return max(-d1,d2); }\nfloat smin( float a, float b, float k ) { return -log(exp(-k*a)+exp(-k*b))/k; } //from iq\n\n//----------------------------------------------------------------------\n// Map functions\n\n// car model is made by Eiffie\n// shader 'Shiny Toy': https://www.shadertoy.com/view/ldsGWB\n\nfloat mapCar(in vec3 p0){ \n\tvec3 p=p0+vec3(0.0,1.24,0.0);\n\tfloat r=length(p.yz);\n\tfloat d= length(max(vec3(abs(p.x)-0.35,r-1.92,-p.y+1.4),0.0))-0.05;\n\td=max(d,p.z-1.0);\n\tp=p0+vec3(0.0,-0.22,0.39);\n\tp.xz=abs(p.xz)-vec2(0.5300,0.9600);p.x=abs(p.x);\n\tr=length(p.yz);\n\td=smin(d,length(max(vec3(p.x-0.08,r-0.25,-p.y-0.08),0.0))-0.04,8.0);\n\td=max(d,-max(p.x-0.165,r-0.24));\n\tfloat d2=length(vec2(max(p.x-0.13,0.0),r-0.2))-0.02;\n\td=min(d,d2);\n\n\treturn d;\n}\n\nfloat dL; // minimal distance to light\n\nfloat map( const in vec3 p ) {\n\tvec3 pd = p;\n    float d;\n    \n    pd.x = abs( pd.x );\n    pd.z *= -sign( p.x );\n    //Purpose: Controls the spawning of cars along the road\n    float ch = hash( floor( (pd.z+18.* time)/40. ) );\n    \n    //Purpose: Creates variation in building lights and structures\n    float lh = hash( floor( pd.z/13. ) );\n    \n    \n    vec3 pdm = vec3( pd.x, pd.y, mod( pd.z, 10.) - 5. );\n    dL = sdSphere( vec3(pdm.x-8.1,pdm.y-4.5,pdm.z), 0.1 );\n    \n    //building lights \n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-9.5-lh,  mod( pd.z, 91.) - 45.5 ), vec3(0.2,4.5, 0.2) ) );\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-11.5+lh, mod( pd.z, 31.) - 15.5 ), vec3(0.22,5.5, 0.2) ) );\n    dL = opU( dL, sdBox( vec3(pdm.x-12., pdm.y-8.5-lh,  mod( pd.z, 41.) - 20.5 ), vec3(0.24,3.5, 0.2) ) );\n   \n    if( lh > 0.5 ) {\n    //Middle lights\n\t    dL = opU( dL, sdBox( vec3(pdm.x-12.5,pdm.y-2.75-lh,  mod( pd.z, 13.) - 6.5 ), vec3(0.1,0.25, 3.2) ) );\n    }\n    \n    vec3 pm = vec3( mod( pd.x + floor( pd.z * 4. )*0.25, 0.5 ) - 0.25, pd.y, mod( pd.z, 0.25 ) - 0.125 );\n\t//Creates the roundbox?\n    d = udRoundBox( pm, vec3( 0.245,0.1, 0.12 ), 0.005 ); \n      \n      //Road\n    d = opS( d, -(p.x+8.) );\n    d = opU( d, pd.y );\n    \n    \n    //Movement for the cars\n    vec3 pdc = vec3( pd.x, pd.y, mod( pd.z+18.*time, 40.) - 20. );\n    \n    // car\n    if( ch > 0.75 ) {\n        pdc.x += (ch-0.75)*4.;\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z ),    0.025 ) );\n\t    dL = opU( dL, sdSphere( vec3( abs(pdc.x-5.)-1.2,  pdc.y-0.65,  pdc.z+6.05 ), 0.025 ) );\n\n        d = opU( d,  mapCar( (pdc-vec3(5.,-0.025,-2.3))*0.45 ) );\n \t}\n    //Background buildings\n    d = opU( d, 13.-pd.x );\n        //LightPost\n    d = opU( d, sdCylinder( vec3(pdm.x-8.5, pdm.y, pdm.z), vec2(0.075,4.5)) );\n    d = opU( d, dL );\n    \n\treturn d;\n}\n\n//----------------------------------------------------------------------\n\n// Calculate surface normal without bump mapping\nvec3 calcNormalSimple(in vec3 pos) {   \n    // Small offset for numerical derivatives\n    const vec2 e = vec2(1.0,-1.0)*0.005;  // Creates tiny offsets for sampling\n\n    // Calculate normal by sampling 4 nearby points and getting their distance field values\n    // This creates a gradient that points perpendicular to the surface\n    vec3 n = normalize(\n        e.xyy*map(pos + e.xyy) +  // Sample +x direction\n        e.yyx*map(pos + e.yyx) +  // Sample +z direction\n        e.yxy*map(pos + e.yxy) +  // Sample +y direction\n        e.xxx*map(pos + e.xxx)    // Sample all positive directions\n    );  \n    return n;\n}\n\n// Calculate surface normal with optional bump mapping\nvec3 calcNormal(in vec3 pos) {\n    // Get base normal first\n    vec3 n = calcNormalSimple(pos);\n    \n    // For higher surfaces (above road level), return simple normal\n    if(pos.y > 0.12) return n;\n\n#ifdef BUMPMAP\n    // Calculate texture coordinates for bump mapping\n    // Creates a grid pattern for surface detail\n    vec2 oc = floor(vec2(pos.x+floor(pos.z * 4.)*0.25, pos.z) * vec2(2., 4.));\n\n    // Special case for road surface (when x is within Â±8 units)\n    if(abs(pos.x)<8.) {\n        oc = pos.xz;  // Use direct position for road texture\n    }\n    \n    // Scale position for noise sampling\n    vec3 p = pos * 250.;\n    // Create bump normal offset using noise\n    // First layer of detail\n    vec3 xn = 0.05*vec3(noise(p.xz)-0.5, 0., noise(p.zx)-0.5);\n    // Add second layer of detail using FBM for more complexity\n    xn += 0.1*vec3(fbm(oc.xy)-0.5, 0., fbm(oc.yx)-0.5);\n    \n    // Combine base normal with bump normal\n    n = normalize(xn + n);\n#endif\n    \n    return n;\n}\n\n// Global variables for storing intersection and lighting information\nvec3 int1, int2, nor1;    // int1/2: intersection points, nor1: surface normal\nvec4 lint1, lint2;        // Light intersection info (position + distance)\n\n// Main ray marching function that finds intersections with the scene\nfloat intersect(in vec3 ro, in vec3 rd) {\n    const float precis = 0.001;      // Precision/threshold for surface detection\n    float h = precis*2.0;            // Initial step size\n    float t = 0.;                    // Distance traveled along ray\n    int1 = int2 = vec3(-500.);      // Initialize intersection points\n    lint1 = lint2 = vec4(-500.);    // Initialize light intersection data\n    float mld = 100.;                // Minimum light distance\n    \n    // First pass: find primary intersection\n    for(int i=0; i < MARCHSTEPS; i++) {\n        h = map(ro+rd*t);            // Get distance to nearest surface\n        // Track closest approach to lights\n        if(dL < mld){\n            mld = dL;\n            lint1.xyz = ro+rd*t;      // Store position\n            lint1.w = abs(dL);        // Store distance to light\n        }\n        // If we hit a surface, store intersection point and break\n        if(h < precis) {\n            int1.xyz = ro+rd*t;\n            break;\n        } \n        t += max(h, precis*2.);      // Step along ray (at least precis*2 units)\n    }\n    \n    // Handle case where we didn't hit anything or went too far\n    if(int1.z < -400. || t > 300.) {\n        // Try to intersect with ground plane at y = -0.1\n        float d = -(ro.y + 0.1)/rd.y;\n        if(d > 0.) {\n            int1.xyz = ro+rd*d;\n        } else {\n            return -1.;              // No intersection found\n        }\n    }\n    \n    // Set up for reflection pass\n    ro = ro + rd*t;                  // Move to intersection point\n    nor1 = calcNormal(ro);           // Calculate surface normal\n    ro += 0.01*nor1;                 // Slight offset to prevent self-intersection\n    rd = reflect(rd, nor1);          // Calculate reflection direction\n    t = 0.0;                         // Reset distance\n    h = precis*2.0;                  // Reset step size\n    mld = 100.;                      // Reset minimum light distance\n    \n    // Second pass: find reflection intersection\n    for(int i=0; i < MARCHSTEPSREFLECTION; i++) {\n        h = map(ro+rd*t);            // Get distance to nearest surface\n        // Track closest approach to lights\n        if(dL < mld){\n            mld = dL;            \n            lint2.xyz = ro+rd*t;      // Store position\n            lint2.w = abs(dL);        // Store distance to light\n        }\n        // If we hit a surface, store intersection and return\n        if(h < precis) {\n            int2.xyz = ro+rd*t;\n            return 1.;                // Reflection hit found\n        }   \n        t += max(h, precis*2.);      // Step along ray\n    }\n    return 0.;                       // No reflection hit found\n}\n//----------------------------------------------------------------------\n// shade\n\nvec3 shade( in vec3 ro, in vec3 pos, in vec3 nor ) {\n   //Pavement color\n   //Light color\n   vec3  col = vec3(.183,.177,.163);\n    //Define a dark boundary between 15 and 8\n    if( abs(pos.x) > 15. || abs(pos.x) < 8. ) col = vec3( 0.02 );\n    //Whiite lines for the street\n    if( pos.y < 0.01 ) {\n        if( abs( int1.x ) < 0.1 ) col = vec3( 0.9 );\n        if( abs( abs( int1.x )-7.4 ) < 0.1 ) col = vec3( 0.9 );\n    }    \n    \n // Adjusted sky light direction and intensity for blue-ish atmosphere\n    float sh = clamp(dot(nor, normalize(vec3(-0.2, 0.6, -0.3))), 0.,2.);\n    // Mix with blue sky color\n    col *= (sh * mix(backgroundColor, vec3(0.1, 0.6, 1.0), 0.5));\n    if( abs( pos.x ) > 12.9 && pos.y > 9.) { // windows\n        float ha = hash(133.1234*floor(pos.y / 3.) + floor((pos.z) / 3.));\n        if( ha > 0.95) {\n            col = ((ha-0.95)*10.) * vec3(2.7, 2.8, 0.25); // Cooler window lights\n        }\n    }\n    \n    //atmospheric distance fog/haze effect, making distant objects blend with the background color\n\tcol = mix(  backgroundColor, col, exp( min(max(0.1*pos.y,0.25)-0.065*distance(pos, ro),0.) ) );\n  \n    return col;\n}\n\nvec3 getLightColor(in vec3 pos) {\n    // Initialize with warm white/orange base light color\n    vec3 lcol = vec3(1., .7, .5);  // Red=100%, Green=70%, Blue=50%\n    \n    // Create a copy of position for manipulation\n    vec3 pd = pos;\n    pd.x = abs(pd.x);           // Mirror the scene across x=0 for symmetry\n    pd.z *= -sign(pos.x);       // Flip z direction based on which side of x=0 we're on\n    \n    // Generate random value for car placement (changes with time)\n    // pd.z+18.*time makes cars move forward, /40. controls spacing between potential car positions\n    float ch = hash(floor((pd.z+18.*time)/40.));\n\n    // Calculate position for moving cars\n    // mod(..., 40.) - 20. keeps cars within a repeating 40 unit section, centered around 0\n    vec3 pdc = vec3(pd.x, pd.y, mod(pd.z+18.*time, 40.) - 20.);\n\n    if(ch > 0.75) { // Only spawn cars when random value > 0.75 (25% of the time)\n        pdc.x += (ch-0.75)*4.;  // Vary car's position across road width\n        \n        // Check if current point is within car taillight area\n        // Complex position calculation to place lights relative to car\n        if(sdSphere(vec3(abs(pdc.x-5.)-1.05, pdc.y-0.55, pdc.z), 0.25) < 2.) {\n            lcol = vec3(1., 0.05, 0.01);  // Bright red color for taillights\n        }\n    }\n\n    // Handle lower building lights (between 2 and 5 units high, and more than 10 units from center)\n    if(pd.y > 2. && abs(pd.x) > 10. && pd.y < 5.) {\n        float fl = floor(pd.z/13.);  // Create sections every 13 units along z\n        // Mix original color (40%) with randomized yellow-tinted color (50%)\n        lcol = 0.4*lcol +                         // Keep 40% of original color\n               0.5*vec3(hash(.1562+fl),           // Random red component\n                       hash(.423134+fl),          // Random green component\n                       0.);                       // No blue (creates yellow tint)\n    }\n\n    // Handle upper building lights (above 5 units high and more than 10 units from center)\n    if(abs(pd.x) > 10. && pd.y > 5.) {\n        float fl = floor(pd.z/2.);  // Create sections every 2 units along z\n        // Mix original color (50%) with fully random RGB color (50%)\n        lcol = 0.5*lcol +                         // Keep 50% of original color\n               0.5*vec3(hash(.1562+fl),           // Random red component\n                       hash(.923134+fl),          // Random green component\n                       hash(.423134+fl));         // Random blue component\n    }\n   \n    return lcol;  // Return the final light color\n}\nfloat randomStart(vec2 co){return 0.8+0.2*hash(dot(co,vec2(123.42,117.853))*412.453);}\n\n//----------------------------------------------------------------------\n// main\n\n// Main rendering function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n   // Convert pixel coordinates to normalized screen coordinates [0,1]\n   vec2 q = fragCoord.xy / iResolution.xy;\n   // Convert to [-1,1] range for ray direction calculation\n   vec2 p = -1.0 + 2.0*q;\n   // Correct for aspect ratio\n   p.x *= iResolution.x / iResolution.y;\n       \n   // Create black bars at top and bottom of screen (letterbox effect)\n   if (q.y < .12 || q.y >= .88) {\n       fragColor = vec4(0.,0.,0.,1.);\n       return;\n   } else {\n       // Camera setup\n       float z = time;                                    // Camera moves forward with time\n       float x = -10.9+1.*sin(time*0.2);                 // Camera sways side to side\n       // Camera position with subtle vertical movement\n       vec3 ro = vec3(x, 1.3+.3*cos(time*0.26), z-1.);\n       // Look-at point, also moves to create dynamic camera\n       vec3 ta = vec3(-8.,1.3+.4*cos(time*0.26), z+4.+cos(time*0.04));\n\n       // Calculate camera basis vectors for view matrix\n       vec3 ww = normalize(ta - ro);                      // Forward vector\n       vec3 uu = normalize(cross(ww,vec3(0.0,1.0,0.0))); // Right vector\n       vec3 vv = normalize(cross(uu,ww));                 // Up vector\n\n       // Calculate ray direction for this pixel\n       vec3 rd = normalize(-p.x*uu + p.y*vv + 2.2*ww);\n       \n       // Start with background color\n       vec3 col = backgroundColor;\n\n       // Perform ray marching\n       float ints = intersect(ro+randomStart(p)*rd, rd);\n       \n       // If we hit something\n       if(ints > -0.5) {\n           // Calculate surface reflectance\n           float r = 0.09;     \t        \n           // Different reflection values for different heights\n           if(int1.y > 0.129) \n               r = 0.025 * hash(133.1234*floor(int1.y / 3.) + floor(int1.z / 3.));\n           \n           // Special handling for road area\n           if(abs(int1.x) < 8.) {\n               if(int1.y < 0.01) { // road surface\n                   r = 0.007*fbm(int1.xz);  // Use FBM for road texture\n               } else { // car surface\n                   r = 0.02;\n               }\n           }\n           \n           // Increase reflectance for road markings\n           if(abs(int1.x) < 0.1) r *= 4.;              // Center line\n           if(abs(abs(int1.x)-7.4) < 0.1) r *= 4.;    // Edge lines\n           r *= 2.;                                    // Global reflection boost\n\n           // Calculate primary surface color\n           col = shade(ro, int1.xyz, nor1);\n\n           // Add reflection color if we hit something in reflection ray\n           if(ints > 0.5) {\n               col += r * shade(int1.xyz, int2.xyz, calcNormalSimple(int2.xyz));\n           }  \n           \n           // Add light contribution from reflection pass\n           if(lint2.w > 0.) {            \n               col += (r*LIGHTINTENSITY*exp(-lint2.w*7.0)) * getLightColor(lint2.xyz);\n           } \n       } \n\n       // Rain effect calculation\n       vec2 st = 256. * (p*vec2(.5, .01)+vec2(time*.13-q.y*.6, time*.13));\n       float f = noise(st) * noise(st*0.773) * 1.55;\n       f = 0.25 + clamp(pow(abs(f), 13.0) * 13.0, 0.0, q.y*.14);\n\n       // Add light contribution from primary ray\n       if(lint1.w > 0.) {\n           col += (f*LIGHTINTENSITY*exp(-lint1.w*7.0)) * getLightColor(lint1.xyz);\n       }  \n\n       // Post processing steps\n       // Gamma correction and color adjustment\n       col = pow(clamp(col, 0.0, 1.0), vec3(0.545));\n       col *= vec3(1.5, 1.0, 1.05);                   // Add slight red tint\n       col = clamp(1.06*col-0.03, 0., 1.);           // Contrast adjustment\n       \n       // Calculate vignette effect\n       q.y = (q.y-.12)*(1./0.76);                    // Adjust y coordinate for letterbox\n       // Apply vignette (darker corners)\n       col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1);\n\n       // Output final color\n       fragColor = vec4(col, 1.0);\n   }\n}\n\n","name":"Image","description":"","type":"image"}]}