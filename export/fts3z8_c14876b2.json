{"ver":"0.1","info":{"id":"fts3z8","date":"1621531967","viewed":83,"name":"Unsteady Eddy","username":"sandyblair","description":"Coloured blobs swirling down the plughole.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["screensaver","motionsickness"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float c (float oldCos) {\n    float newCos = 0.5 + 0.5*cos(oldCos*3.14159265359);\n    return newCos;\n    }\n\nfloat s (float oldSin) {\n    float newSin = 0.5 + 0.5*sin(oldSin*3.14159265359);\n    return newSin;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;  // Normalized pixel coordinates (from 0 to 1)\n    uv -= 0.5;                           // remap so 0,0 is in the middle of the screen.\n \n    float x = uv.x;\n    float y = uv.y;\n    float o = iTime * 0.25;\n    float d = length(uv);\n    float rad  = (3.14159265359 + atan(uv.y,uv.x)) * 0.15915494309  ;\n    //note - is this the best way to calculate normalised (0..1) radial angle??? \n    //Leave a comment if you read this and can improve it!\n    \n\n    // Time varying pixel color    \n    float r = s(c(d*4. + o*2.)+s((rad+c(o))*10.));\n    float g = s(d*6. + s(r*2.+o));\n    float b =s(r*8. + s(g*2.));\n    \n    vec3 col = vec3(r, g, b);\n       \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}