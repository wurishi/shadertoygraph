{"ver":"0.1","info":{"id":"lXlXWf","date":"1710124021","viewed":102,"name":"Polarizing Filter Effect","username":"HISEROD","description":"My attempt at simulating the effect of a rotating linear polarizer on a dielectric material.\nI'm not a physicist so while I was attempting to be accurate, I could have easily goofed somewhere.\nI'm also not a shader programmer so...","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection","pbr","polarization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185\n#define IOR 1.35\n\nvec3 linearToSrgb(vec3 linearColor) {\n    return mix(12.92 * linearColor, 1.055 * pow(linearColor, vec3(1.0 / 2.4)) - 0.055, step(0.0031308, linearColor));\n}\nvec3 srgbToLinear(vec3 srgbColor) {\n    return mix(srgbColor / 12.92, pow((srgbColor + 0.055) / 1.055, vec3(2.4)), step(0.04045, srgbColor));\n}\nvec3 rotateZ(vec3 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    // Rotation matrix for Z-axis\n    mat3 rotZ = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n    );\n    return rotZ * v;\n}\nvec3 rotateY(vec3 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    // Rotation matrix for Y-axis\n    mat3 rotY = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n    );\n    return rotY * v;\n}\nfloat Rs(float cosine, float ior) {\n    float a = sqrt(ior * ior - 1.0 + cosine * cosine);\n    float quot = (cosine - a) / (cosine + a);\n    return quot * quot;\n}\nfloat Rp(float cosine, float ior) {\n    float ior2 = ior * ior;\n    float a = sqrt(ior2 - 1.0 + cosine * cosine);\n    float b = ior2 * cosine;\n    float quot = (a - b) / (a + b);\n    return quot * quot;\n}\nfloat cos2(float x) {\n    float res = cos(x);\n    return res * res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate sphere normals' x and z coordinates\n    vec2 xz = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    // Calculate the 3rd coordinate\n    vec2 dist2 = xz*xz;\n    vec3 normal = vec3(xz.x, -sqrt(1. - dist2.x - dist2.y), xz.y);\n    \n    // View Direction will be pointing in the +y direction\n    vec3 viewDir = vec3(0., 1., 0.);\n\n    // Calculate reflection vectors\n    vec3 reflectDir = rotateZ(reflect(viewDir, normal), -iTime / 10.).xzy;\n\n    // Sample the cubemap using the reflection direction\n    vec3 envColor = srgbToLinear(texture(iChannel0, reflectDir).rgb);\n    \n    // Make a crude ambient light approximation\n    vec3 ambientColor = srgbToLinear(vec3(.5, .01, .01));\n    ambientColor *= 0.2 + 0.8 * smoothstep(0., 1., normal.z * .5 + .5);\n    \n    // Rotate the normals to rotate the polarizer\n    normal = rotateY(normal, -iTime / .6);\n    \n    // Mix between s- and p-polarized light using the normal angle\n    float fac = cos2(atan(normal.z, normal.x));\n    \n    float polarMask = mix(Rs(-normal.y, IOR), Rp(-normal.y, IOR), fac);\n\n    fragColor = vec4(linearToSrgb(mix(ambientColor, envColor, polarMask)), 1.);\n}\n","name":"Image","description":"","type":"image"}]}