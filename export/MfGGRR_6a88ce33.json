{"ver":"0.1","info":{"id":"MfGGRR","date":"1712308752","viewed":69,"name":"GummyBoid","username":"PiouPiou","description":"It's haribo's gummy bears flying like boids.\n(sorry for the performance issues)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["boid","gummybear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getBoidPosition(float id)\n{\n  return texture(iChannel1, vec2(id + .5, .5) / iResolution.xy).xyz;\n}\n\nvec3 getBoidVelocity(float id)\n{\n  return texture(iChannel0, vec2(id + .5, .5) / iResolution.xy).xyz;\n}\n\nstruct Surface\n{\n  float sd; // signed distance value\n  vec3 col; // color\n  vec3 emission; // emission color\n  float roughness; // surface roughness\n  float metallic; // metallic property\n};\n\n///////////////////////////////////////////////////////////\nSurface opUnion(Surface s1, Surface s2)\n{\n  if(s1.sd < s2.sd)\n    return s1;\n  else\n    return s2;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k)\n{\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nvec3 nrand(float id)\n{\n  return normalize(vec3(2.0 * fract(sin(id) * 43758.5453) - 1.0, 2.0 * fract(sin(id + 1.0) * 43758.5453) - 1.0, 2.0 * fract(sin(id + 2.0) * 43758.5453) - 1.0));\n\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nSurface sdSphere(vec3 p, float s, vec3 col, vec3 emission, float roughness, float metallic)\n{\n  return Surface(sdSphere(p, s), col, emission, roughness, metallic);\n}\n\nfloat sdCutSphere(vec3 p, float r, float h)\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r * r - h * h);\n\n  // sampling dependant computations\n  vec2 q = vec2(length(p.xz), p.y);\n  float s = max((h - r) * q.x * q.x + w * w * (h + r - 2.0 * q.y), h * q.x - w * q.y);\n  return (s < 0.0) ? length(q) - r : (q.x < w) ? h - q.y : length(q - vec2(w, h));\n}\n\nvec3 rotate(vec3 p, vec3 angle)\n{\n  float a = angle.x;\n  float b = angle.y;\n  float c = angle.z;\n  float sina = sin(a);\n  float cosa = cos(a);\n  float sinb = sin(b);\n  float cosb = cos(b);\n  float sinc = sin(c);\n  float cosc = cos(c);\n  mat3 ma = mat3(cosa, 0, sina, 0, 1, 0, -sina, 0, cosa);\n  mat3 mb = mat3(1, 0, 0, 0, cosb, -sinb, 0, sinb, cosb);\n  mat3 mc = mat3(cosc, -sinc, 0, sinc, cosc, 0, 0, 0, 1);\n  return mc * mb * ma * p;\n}\n\nfloat sdRotatedCutSphere(vec3 p, float r, float h, vec3 angle)\n{\n  p = rotate(p, angle); // Rotate the point\n  return sdCutSphere(p, r, h);\n}\n\nvec3 getGummyColor(float id)\n{\n  vec3 red = vec3(0.94, 0.11, 0.11);\n  vec3 orange = vec3(1.0, 0.30, 0.15);\n  vec3 yellow = vec3(1.0, 0.89, 0.2);\n  vec3 green = vec3(0.1, 0.89, 0.2);\n  vec3 whitered = vec3(1., 0.99, 0.69);\n\n  float i = mod(id, 5.);\n\n  if(i == 0.)\n    return red;\n  else if(i == 1.)\n    return orange;\n  else if(i == 2.)\n    return yellow;\n  else if(i == 3.)\n    return green;\n  else\n    return whitered;\n}\n\nSurface sdPlane(vec3 p, vec3 n, float h, vec3 col, vec3 emission, float roughness, float metallic)\n{\n  Surface s;\n  s.sd = dot(p, n) + h;\n  s.col = col;\n  s.emission = emission;\n  s.roughness = roughness;\n  s.metallic = metallic;\n  return s;\n}\n\nSurface sdGummyBear(vec3 pos, float scale, vec3 angle, vec3 color)\n{\n  if (dot(pos, pos) > 6.* scale)\n      return Surface(length(pos + vec3(0., -.5 * scale, 0.)) - 4.*scale, color, color + .5, 0.5, 0.2);\n         \n  pos = rotate(pos, angle);\n\n  vec3 p = pos;\n  float body = sdRoundBox(p, vec3(.7 * scale, 2. * scale, 1. * scale), 0.2 * scale);\n  float bear = body;\n\n  // Hands\n  p = pos + vec3(-.7 * scale, -0.6 * scale, -.8 * scale);\n  float rHand = sdSphere(p, .5 * scale);\n  bear = opSmoothUnion(bear, rHand, 0.5 * scale);\n\n  p = pos + vec3(-.7 * scale, -0.6 * scale, .8 * scale);\n  float lHand = sdSphere(p, .5 * scale);\n  bear = opSmoothUnion(bear, lHand, 0.5 * scale);\n\n  // Foots\n  p = pos + vec3(-.7 * scale, 2.1 * scale, -.6 * scale);\n  float rFoot = sdCutSphere(p, .5 * scale, 0.1 * scale);\n  bear = opSmoothUnion(bear, rFoot, 0.5 * scale);\n\n  p = pos + vec3(-.7 * scale, 2.1 * scale, .6 * scale);\n  float lFoot = sdCutSphere(p, .5 * scale, 0.1 * scale);\n  bear = opSmoothUnion(bear, lFoot, 0.5 * scale);\n\n  // Head\n  p = pos + vec3(0., -2.4 * scale, 0.);\n  float head = sdRoundBox(p, vec3(0.77 * scale, 0.7 * scale, 1. * scale), 0.3 * scale);\n  bear = opSmoothUnion(bear, head, 0.2 * scale);\n\n  // Ears\n  p = pos + vec3(-0.5 * scale, -3. * scale, -.8 * scale);\n  float rEar = sdRotatedCutSphere(p, .5 * scale, 0.01 * scale, vec3(0., 0.5, 01.5));\n  bear = opSmoothUnion(bear, rEar, 0.4 * scale);\n\n  p = pos + vec3(-0.5 * scale, -3. * scale, .8 * scale);\n  float lEar = sdRotatedCutSphere(p, .5 * scale, 0.01 * scale, vec3(0., -0.5, 01.5));\n  bear = opSmoothUnion(bear, lEar, 0.4 * scale);\n\n  vec3 emissionColor = color + vec3(0.5, 0.5, 0.5);\n  Surface res = Surface(bear, color, emissionColor, 0.5, 0.2);\n\n  return res;\n}\n\n///////////////////////////////////////////////////////////////\n\nSurface map(in vec3 pos)\n{\n  Surface res = Surface(100.0, vec3(0.0), vec3(0.0), 0.0, 0.0);\n\n  for(float i = 0.; i < numboids; i++)\n  {\n    vec3 boidPosition = getBoidPosition(i);\n    vec3 boidVelocity = normalize(getBoidVelocity(i));\n\n    vec3 p = pos - boidPosition;\n    Surface s = sdGummyBear(p, 0.05, boidVelocity * 3.1415, getGummyColor(i));\n\n    res = opUnion(res, s);\n  }\n\n    // Floor\n  vec3 p = pos + vec3(0, 4., 0);\n  Surface floors = sdPlane(p, vec3(0, 1, 0), 0.0, vec3(1.), vec3( 0.0), 0., 0.);\n  res = opUnion(res, floors);\n\n  return res;\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n  const float ep = 0.0001;\n  vec2 e = vec2(1.0, -1.0) * 0.5773;\n  return normalize(e.xyy * (map(pos + e.xyy * ep).sd) +\n    e.yyx * (map(pos + e.yyx * ep).sd) +\n    e.yxy * (map(pos + e.yxy * ep).sd) +\n    e.xxx * (map(pos + e.xxx * ep).sd));\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, float tmin, float tmax, const float k)\n{\n  float res = 1.0;\n  float t = tmin;\n  for(int i = 0; i < 50; i++)\n  {\n    Surface s = map(ro + rd * t);\n    float h = s.sd;\n    res = min(res, k * h / t);\n    t += clamp(h, 0.02, 0.20);\n    if(res < 0.005 || t > tmax)\n      break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 localRay;\n\nvoid CamPolar(out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord)\n{\n\t// get rotation coefficients\n  vec2 c = vec2(cos(rotation.x), cos(rotation.y));\n  vec4 s;\n  s.xy = vec2(sin(rotation.x), sin(rotation.y)); // worth testing if this is faster as sin or sqrt(1.0-cos);\n  s.zw = -s.xy;\n\n\t// ray in view space\n  ray.xy = fragCoord.xy - iResolution.xy * .5;\n  ray.z = iResolution.y * zoom;\n  ray = normalize(ray);\n  localRay = ray;\n\n\t// rotate ray\n  ray.yz = ray.yz * c.xx + ray.zy * s.zx;\n  ray.xz = ray.xz * c.yy + ray.zx * s.yw;\n\n\t// position camera\n  pos = origin - distance * vec3(c.x * s.y, s.z, c.x * c.y);\n}\n\nvec3 getBackground(vec2 fragCoord)\n{\n  vec2 uv = fragCoord / iResolution.xy;\n  uv.y -= 0.15;\n  return texture(iChannel2, uv).rgb;\n}\n\n//////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 tot = vec3(0.0);\n  vec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y; // center will be at (0,0) and aspect ratio will be 1.0\n  \n\n   //Better Camera \n  vec2 camRot = vec2(.5, .5) + vec2(-.35, 4.5);// * (iMouse.yx / iResolution.yx);\n  vec3 ro, rd;\n  CamPolar(ro, rd, vec3(0), camRot, 10.0, 0.8, fragCoord);\n\n  float t = 0.1;\n  float tend = 25.;\n  Surface s;\n  for(int i = 0; i < 128; i++)\n  {\n    vec3 p = ro + t * rd;\n    s = map(p);\n    float h = s.sd;\n    if(abs(h) < 0.0001 || t > tend)\n      break;\n    t += h;\n  }\n\n  vec3 col = getBackground(fragCoord);\n\n  vec3 ambiant_color = vec3(0.0, 0.02, 0.03);\n  vec3 light_color = vec3(0.97, 0.8, 0.8);\n  if(t < tend)\n  {\n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    vec3 lig = normalize(vec3(0.6, 0.7, 0.6));\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float sha = calcSoftshadow(pos, lig, 0.001, 6.0, 16.0);\n    float amb = 0.5 + 0.5 * nor.y;\n    col = ambiant_color * amb + light_color * dif * sha * s.col;\n\n    // Glass effect\n    vec3 refl = reflect(rd, nor);\n    vec3 refr = refract(rd, nor, 1.0 / 1.5);\n    float fresnel = 0.1 + 0.9 * pow(1.0 - dot(-rd, nor), 5.0);\n    col = ambiant_color * amb + light_color * dif * sha * s.col * (1.0 - fresnel) +\n      s.emission * fresnel * texture(iChannel0, p + refr.xy * s.roughness).rgb +\n      0.1 * texture(iChannel0, p + refl.xy * s.metallic).rgb;\n\n  }\n\n  col = sqrt(col);\n  tot += col;\n\n  fragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define speed 5.\t\t            // Boid speed\n#define a1 numboids*0.0000066667    // Collision factor\n#define a2 numboids*0.0000666667    // Cohesion factor\t\n#define a3 numboids*0.0003333333    // Alignment factor\n#define a4 numboids*0.0000016667    // Center attraction factor\n\nvec3 getBoidPosition(float id)\n{\n    return texture(iChannel1, vec2(id + .5, .5) / iResolution.xy).xyz;\n}\n\nvec3 getBoidVelocity(float id)\n{\n    return texture(iChannel0, vec2(id + .5, .5) / iResolution.xy).xyz;\n}\n\n// Then the main image program queries the boid data from this buffer.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\t\t\t// default data\n    if(fragCoord.y > 1. || fragCoord.x > numboids)\n        discard;\n\n    float id = floor(fragCoord.x);\n\n    // initialize random boid positions and velocities\n    if(iFrame <= 1)\n    {\n        vec3 init_v = vec3(sin(id), cos(id), -cos(id));\n        init_v /= speed * length(init_v);\n        fragColor = vec4(init_v, 1.);\n    }\n    else\n    {        \n\n        // boid of interest\n        vec3 v = getBoidVelocity(id);\n        vec3 p = getBoidPosition(id);\n\n        // Boundary conditions\n        vec3 maxBounds = vec3(1.5, 1.0, 1.0)*6.;\n        vec3 minBounds = (-maxBounds) + vec3(0.0, 4.5, 0.0);\n\n        // initialize velocity update vectors\n        vec3 v_collision, v_cohesion, v_alignment, v_center_attraction = vec3(0.);\n\n        // loop over neighboring boids and build update vectors accordingly\n        for(float nid = 0.0; nid < numboids; nid++)\n        {\n\n            if(nid != id)\n            {\n                vec3 p_neighbor = getBoidPosition(id);\t// nieghboring boid position\n                vec3 v_neighbor = getBoidVelocity(id);\t// neighboring boid velocity\n\n                vec3 sep = p_neighbor - p;\n                float ls = length(sep);\n                float r = 2.;\t\t\t\t// separation radius\n\n            \t// Boid Collision Update\n                if(ls < r)\n                {\n                    v_collision -= sep;\n                }\n\n                // Boundary Collision Update\n                for(int i = 0; i < 3; i++)\n                {\n                    if(p[i] > maxBounds[i])\n                        v_collision[i] -= 1.;\n                    if(p[i] < minBounds[i])\n                        v_collision[i] += 1.;\n                }\n\n                // Cohesion Update\n                v_cohesion += sep;\n\n                // Alignment Update\n                v_alignment += v_neighbor;\n            }\n\n            // Perceived values\n            v_cohesion = v_cohesion / (numboids - 1.0);\n            v_alignment = v_alignment / (numboids - 1.0) - v;\n\n            // Add an attractive force to the center of the screen\n            v_center_attraction = vec3(0., 2., 0.) - p;\n\n            // Apply position and velocity updates\n            v += a1 * v_collision + a2 * v_cohesion + a3 * v_alignment + a4 * v_center_attraction;\n            v /= length(v) * speed;\t\t// constrain velocity\n        }\n\n        // Add a bit of randomness to the boid movement\n        v += 0.01 * vec3(sin(id), cos(id), -cos(id));\n\n        fragColor = vec4(v.xyz, 1.);\n\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 getBoidPosition(float id)\n{\n    return texture(iChannel1, vec2(id + .5, .5) / iResolution.xy).xyz;\n}\n\nvec3 getBoidVelocity(float id)\n{\n    return texture(iChannel0, vec2(id + .5, .5) / iResolution.xy).xyz;\n}\n\nvec3 nrand(float id)\n{\n    return normalize(vec3(2.0 * fract(sin(id) * 43758.5453) - 1.0, 2.0 * fract(sin(id + 1.0) * 43758.5453) - 1.0, 2.0 * fract(sin(id + 2.0) * 43758.5453) - 1.0));\n\n}\n\n// Then the main image program queries the boid data from this buffer.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\t\t\t// default data\n\n    if (fragCoord.y > 1. || fragCoord.x > numboids) discard;\n\n    float id = floor(fragCoord.x);\n\n    // initialize random boid positions and velocities\n    if(iFrame <= 1)\n    {\n        vec3 init_p = nrand(id);\n        fragColor = vec4(init_p, 1.);\n    }\n    else\n    {        \n        // boid of interest\n        vec3 p = getBoidPosition(id);\n\n        // loop over neighboring boids and build update vectors accordingly\n        for(float nid = 0.0; nid < numboids; nid++)\n        {\n            p += iTimeDelta * getBoidVelocity(id) * 0.2;\t\t\t// update position\n        }\n        \n        // Add a little noise to the position\n        p += 0.01 * nrand(id);\n\n        fragColor = vec4(p.xyz, 1.);\n\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec4 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return vec4(c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y),1.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Create a rainbow gradient slowly moving from left to right following an arc\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float angle = atan(uv.y, uv.x);\n    float dist = length(uv);\n    float hue = (angle + 3.14159) / 6.28318;\n    float sat = dist;\n    float val = 1.0;\n\n    // Add the movement of the rainbow\n    hue += iTime * 0.1;\n\n    // Add a little bit of noise to the saturation\n    sat += 0.2 * cos(iTime * 0.9 + dist * 12.0);\n\n    // Add a little bit of noise to the value\n    val += 0.2 * cos(iTime * 0.5 + dist * 10.0);\n\n    // Add a little bit of noise to the hue\n    hue += 0.2 * sin(iTime * 0.5 + dist * 6.0);\n\n    // Clamp the values\n    hue = mod(hue, 1.0);\n    sat = clamp(sat, 0.0, 1.0);\n    val = clamp(val, 0.0, 1.0);\n\n    // Convert the HSV color to RGB\n    fragColor = hsv2rgb(vec3(hue, sat, val));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define numboids 100.\t\t        // Number of boids (must be integer value represented as float)\n","name":"Common","description":"","type":"common"}]}