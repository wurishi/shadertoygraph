{"ver":"0.1","info":{"id":"fdlSzS","date":"1618783475","viewed":164,"name":"Octahedron [fresnel/sdf]","username":"hant0508","description":"cmc cg task 2","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","glass","fresnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MARCHING_STEPS = 128;\nconst int ALIASING_STEPS = 1; // change to 2 to enable anti-aliasing\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 40.0;\nconst float EPSILON = 0.001;\n\nmat2 rot(float a) {\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(in vec3 p, in float radius) {\n\treturn length(p) - radius;\n}\n\nfloat sdPlane(in vec3 p) {\n  return p.y;\n}\n\nfloat sdOctahedron(in vec3 p, in float h){\n\tconst float c = 1.7320508;\n\treturn (dot(abs(p), vec3(1.0)) - h) / c;\n}\n\nvec2 opUnion(in vec2 a, in vec2 b) {\n    return abs(a.x) < abs(b.x) ? a : b;\n}\n\nfloat opDisplace(in vec3 p, float radius){\n    float d1 = sdSphere(p, radius);\n    float d2 = 0.02*sin(10.0*p.x)*sin(10.0*p.y)*sin(10.0*p.z);\n    // return d1+d2; // uncomment to enable distortion\n    return d1;\n}\n\nfloat sdCylinder(in vec3 p, in vec2 size) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - size;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec2 map(in vec3 p) {\n    vec2 d = vec2(sdPlane(p), 1.01);\n    \n    d = opUnion(d, vec2(sdSphere(p - vec3(4.0, 1.3, 1.0), 1.3), 1.02));\n    d = opUnion(d, vec2(opDisplace(p - vec3(0.0, 2.5, 0.0), 1.0), 2.03));\n    d = opUnion(d, vec2(sdOctahedron(p - vec3(0.0, 2.8, 0.0), 2.5), 2.04));\n    \n    d = opUnion(d, vec2(sdCylinder(p - vec3(0.0, 0.0, 0.0), vec2(1.5, 0.3)), 1.05));\n\td = opUnion(d, vec2(sdCylinder(p - vec3(0.0, 0.0, 0.0), vec2(2.0, 0.2)), 1.05));\n\td = opUnion(d, vec2(sdCylinder(p - vec3(0.0, 0.0, 0.0), vec2(2.5, 0.12)), 1.05));\n    \n\treturn d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy).x - map(p - e.xyy).x,\n\t\tmap(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n\t));\n}\n\nvec2 rayProcess(in vec3 camPos, in vec3 rayDir, in float start, in float end) {\n\tfloat depth = start;\n   \tvec2 e = vec2(end, 0.0);\n\tfor(int i = 0; i < MARCHING_STEPS; ++i) {\n\t\tvec2 dist = map(camPos + depth * rayDir);\n\t\tif(abs(dist.x) < EPSILON) return vec2(depth, dist.y);\n\t\tdepth += abs(dist.x);\n\t\tif(dist.x >= end) return e;\n\t}\n\treturn e;\n}\n\nvec3 rayDirection(in float camAngle, in vec2 coord) {\n\tvec2 uv = (coord - 0.5) * iResolution.xy;\n\tfloat focalDist = iResolution.y / 2.0 / tan(radians(camAngle) / 2.0);\n\treturn normalize(vec3(uv, -focalDist));\n}\n\nfloat checkerboard(in vec3 p) {\n    vec3 q = floor(p);\n    return mod(q.x + q.z, 2.0);\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n    const float maxHei = 2.0;\n    float tp = (maxHei - ro.y) / rd.y; \n    if(tp > 0.0)\n\t\ttmax = min(tmax, tp);\n\n    float res = 1.0;\n    float t = mint;\n    for(int i = min(0, iFrame); i < 16; i++)\n    {\n\t\tfloat h = map( ro + rd * t ).x;\n        res = min( res, 8.0 * h / t );\n        t += clamp( h, 0.02, 0.10 );\n        if(res < 0.005 || t > tmax) break;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 palette(in float t, in vec3 p) {\n    if (abs(t - 0.05) < EPSILON)\n        return texture(iChannel1, p.xz).xyz;\n\n    if (abs(t - 0.01) < EPSILON)\n        return texture(iChannel0, p.xz).xyz;\n\n    if (abs(t - 0.02) < EPSILON)\n        return vec3(0.4, 0.7, 0.2);\n\n    if (abs(t - 0.03) < EPSILON)\n        return vec3(1.0, 0.0, 0.0);\n\n    if (abs(t - 0.04) < EPSILON)\n        return vec3(0.85, 1.0, 1.0);\n        \n\treturn vec3(0.6, 0.5, 0.5); \n}\n\nvec3 applyLight(in vec3 p, in vec3 rd, in vec3 nor, in float id, in vec3 lp) {\n    vec3 col = vec3(0.0);\n\n    vec3 mate = 0.7 * palette(fract(id), p);\n    if(id < 1.0) {\n        float f = checkerboard(p);\n        mate = 0.2 + f * vec3(0.08);\n    }\n\n    vec3  lig = normalize(lp);\n    vec3  hal = normalize(lig - rd);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n\n    float spe = pow(abs(dot(nor, hal)), 100.0);\n    \n    dif *= calcSoftshadow(p, lig, 0.1, 3.0);\n\n    col = mate * 3.0 * dif * vec3(0.8, 0.7, 0.6);\n    col += 0.6 * spe * vec3(1.0, 0.7, 0.5);\n\n    float amb = 0.6;\n    col += mate*amb;\n    \n\treturn col;\n}\n\nvec3 refract2(in vec3 i, in vec3 n, in float eta) {\n    if(dot(i, n) < 0.0) eta = 1.0 / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\nvec3 basicShading(in vec3 ro, in vec3 rd, in int nStep) {\n    vec3 resCol = vec3(0.0);\n    vec3 p = ro;\n    float alpha = 1.0;\n    for(int i = nStep; i > 0; --i) {\n        vec2 d = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    \tp += d.x * rd;\n    \tvec3 nor = calcNormal(p);\n        \n    \tvec3 col = applyLight(p, rd, nor, d.y, vec3(-8.0, 8.0, 5.0))*0.5;\n        col += applyLight(p, rd, nor, d.y, vec3(2.0, 8.0, 4.0))*0.5;\n        col *= pow(abs(smoothstep(MAX_DIST, 10.0, d.x)), 2.0);\n        \n        if(d.y < 2.0) {\n        \tresCol += col * alpha;\n       \t\talpha *= 0.25;\n            rd = reflect(rd, nor);\n        } else {\n            float transparency = 0.3;\n            resCol += col * alpha * transparency;\n            alpha *= (1.0 - transparency);\n            if (d.y == 2.04)\n                rd = refract2(rd, nor, 1.5);\n            else\n                rd = refract2(rd, nor, 1.5 + 0.2);\n        }\n        \n        if(d.y < 1.0) break;\n        \n        p += rd * 0.01;\n    }\n    \n\treturn resCol;\n}\n\nvec3 shading(in vec3 ro, in vec3 rd) {\n    vec3 resCol = vec3(0.0);\n    vec3 p = ro;\n    float alpha = 1.;\n    for(int i = 10; i > 0; --i) {\n        vec2 d = rayProcess(p, rd, MIN_DIST, MAX_DIST);\n    \tp += d.x * rd;\n    \tvec3 nor = calcNormal(p);\n        \n    \tvec3 col = applyLight(p, rd, nor, d.y, vec3(-8.0, 8.0, 5.0))*0.5;\n        col += applyLight(p, rd, nor, d.y, vec3(2.0, 8.0, 4.0))*0.5;\n        col *= pow(abs(smoothstep(MAX_DIST, 10.0, d.x)), 2.0);\n        \n        if(d.y < 2.0) {\n       \t\tfloat kr = pow(abs(1.0 - abs(dot(nor,-rd))), 3.0) + 0.03 + 0.13 * step(d.y, 1.0);\n        \tresCol += col * alpha * (1.0 - kr);\n       \t\talpha *= kr;\n            rd = reflect(rd, nor);\n        } else {\n       \t\tfloat kr = 0.05 + pow(1.0 - abs(dot(nor,-rd)), 4.0);\n            vec3 rdRefl = reflect(rd, nor);\n            resCol += basicShading(p + rdRefl * 0.01, rdRefl, i) * alpha * kr;\n            float transparency = 0.1;\n            resCol += col * alpha * transparency;\n            \n            alpha *= (1.0 - kr) * (1.0 - transparency);\n\n            if (d.y == 2.04)\n                rd = refract2(rd, nor, 1.5);\n            else\n                rd = refract2(rd, nor, 1.5 + 0.2);\n        }\n        \n        if(d.y < 1.0) break;\n        \n        p += rd * 0.01;\n    }\n    \n\treturn resCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.0);\n    \n    for(int i = 0; i < ALIASING_STEPS; ++i) {\n        for(int j = 0; j < ALIASING_STEPS; ++j) {\n            vec2 offset = vec2(i, j) / 2.0 - 0.5;\n            vec3 camPos = vec3(0.0, 6.0, 10.0);\n            vec3 rd = rayDirection(50.0, (fragCoord + offset) / iResolution.xy);\n            \n            float ang = 0.5 * iTime;\n            camPos.zx *= rot(ang);\n            rd.yz *= rot(0.5);\n            rd.zx *= rot(ang);\n\n            vec3 col = vec3(0.0);\n            col = shading(camPos, rd);\n            \n            tot += pow(col, vec3(1.0 / 1.7));\n        }\n    }\n    \n\tvec2 uv = fragCoord/iResolution.yy;\n    float x = fragCoord.x / iResolution.x;\n    \n    tot /= float(ALIASING_STEPS * ALIASING_STEPS);\n\tfragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}