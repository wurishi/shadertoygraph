{"ver":"0.1","info":{"id":"MlVBDR","date":"1549046695","viewed":860,"name":"Cheap Bezier palettes","username":"nimitz","description":"Common tab for palette functions.\n\nClick and drag to rotate.","likes":36,"published":1,"flags":32,"usePreview":0,"tags":["procedural","palette","rgb","technique","colorspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cheap Bezier palettes\n// by nimitz 2019 (twitter: @stormoid)\n\n// Palette type and base color selection in the \"Common\" tab\n// Palette code also in the \"Common\" tab\n\n/*\n\tAn alternative to the simple sine offset procedural\n\tpalettes.\n\n\tPros: simple to parameterize, versatile, self-contained,\n\tlooping (0..1 interval) and cheap to evaluate.\n\n\tEvaluated as a combination of 3D quadtratic bezier curves which \n\tends up being only slighty (10 vs 9 instructions) more expensive\n\tto compute than the ubiquitous sine-based palette\n\n\tThe shader is also plotting the palette in 3D RGB space\n\twhich helps visualize the 3D path to design palettes\n*/\n\n\nfloat mag2(vec3 p){return dot(p,p);}\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n\nvec3 roty(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n\nvec4 draw(in vec3 ro, in vec3 rd)\n{\n    vec4 rez = vec4(0,0,0,110);\n    vec2 w = 1./iResolution.xy;\n    \n    for (int i = 0; i < 175; i++)\n    {\n        vec3 pos = texture(iChannel0, vec2(i,100.0)*w).rgb;\n        float d = mag2((ro + rd*dot(pos.xyz - ro, rd)) - pos.xyz);\n        d = smoothstep(.75, 0.2, d*2000.);\n       \trez.rgb = max(rez.rgb, d*pos.xyz);\n    }\n    \n    return rez;\n}\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 lineCub( in vec3 ro, in vec3 rd, vec3 pa, vec3 pb )\n{\n\tvec3 ba = pb - pa;\n\tvec3 oa = ro - pa;\n\tfloat oad  = dot(oa, rd);\n\tfloat dba  = dot(rd, ba);\n\tfloat baba = dot(ba, ba);\n\tfloat oaba = dot(oa, ba);\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\tvec3 p = pa + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n    float l = dot( p-q, p-q );\n    return clamp(0.001/(100.*l),0.,1.)*mix(pa, pb, th.y);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.15,0.):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n    mo *=vec2(6.14, -2.0);\n    \n    vec3 rd = normalize(vec3(p,1.7));\n    float angle = mo.x*0.5;\n    rd = rotx(rd, mo.y);\n    rd = roty(rd, angle);\n    \n    float camR = 1.37 * (cos(mo.y)+1.0);\n    vec3 ro = vec3(0.5 - sin(angle)*camR, sin(mo.y)*2.9 + .45, 0.5 - cos(angle)*camR);    \n    \n    vec4 col = draw(ro, rd);\n    col.rgb += lineCub(ro, rd, vec3(0,0,0), vec3(1,0,0));\n    col.rgb += lineCub(ro, rd, vec3(0,0,0), vec3(0,1,0));\n    col.rgb += lineCub(ro, rd, vec3(0,1,0), vec3(1,1,0));\n    col.rgb += lineCub(ro, rd, vec3(1,0,0), vec3(1,1,0));\n    \n    col.rgb += lineCub(ro, rd, vec3(0,0,1), vec3(1,0,1));\n    col.rgb += lineCub(ro, rd, vec3(0,0,1), vec3(0,1,1));\n    col.rgb += lineCub(ro, rd, vec3(0,1,1), vec3(1,1,1));\n    col.rgb += lineCub(ro, rd, vec3(1,0,1), vec3(1,1,1));\n    \n    col.rgb += lineCub(ro, rd, vec3(0,0,0), vec3(0,0,1));\n    col.rgb += lineCub(ro, rd, vec3(1,0,0), vec3(1,0,1));\n    col.rgb += lineCub(ro, rd, vec3(0,1,0), vec3(0,1,1));\n    col.rgb += lineCub(ro, rd, vec3(1,1,0), vec3(1,1,1));\n    \n    col.rgb += lineCub(ro, rd, vec3(0,0,0), vec3(1,1,1));\n    col.rgb += lineCub(ro, rd, vec3(0.5,0.5,0), vec3(0.5,0.5,1));\n    col.rgb += lineCub(ro, rd, vec3(0.5,0.,0.5), vec3(0.5,1.,0.5));\n    col.rgb += lineCub(ro, rd, vec3(0.,0.5,0.5), vec3(1.,.5,0.5));\n    \n    if (q.y < 0.09)\n        col.rgb = getPalette(q.x, COL1, COL2, PT1, PT2);\n    \n\tfragColor = vec4(col.rgb, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Cheap Bezier palettes by nimitz\n//by nimitz 2019 (twitter: @stormoid)\n\n/*\n\tAn alternative to the simple sine offset procedural\n\tpalettes.\n\n\tPros: simple to parameterize, versatile, self-contained,\n\tlooping (0..1 interval) and cheap to evaluate.\n\n\tEvaluated as a combination of 3D quadtratic bezier curves which \n\tends up being only slighty (10 vs 9 instructions) more expensive\n\tto compute than the ubiquitous sine-based palette\n\n\tThe shader is also plotting the palette in 3D RGB space\n\twhich helps visualize the 3D path to design palettes\n*/\n\n//Type 1 = Bezier based, Type 2 = Linearly interpolated, Type 3 = Sine based\n#define TYPE 1\n\n\n\n#if (TYPE ==1)\n\n#define COL1 vec3(0.8, .5, .3)\n#define PT1 vec3(.5, .7, .0)\n#define COL2 vec3(0.1, .7, .5)\n#define PT2 vec3(0.1, .1, .9)\n\n//Dual 3D Quadratic Bezier palette\n//10 Instructions\nvec3 getPalette(float x, vec3 c1, vec3 c2, vec3 p1, vec3 p2)\n{\n    \n    float x2 = fract(x);\n    x = fract(x*2.0);   \n    mat3 m = mat3(c1, p1, c2);\n    mat3 m2 = mat3(c2, p2, c1);\n    float omx = 1.0-x;\n    vec3 pws = vec3(omx*omx, 2.0*omx*x, x*x);\n    return clamp(mix(m*pws, m2*pws, step(x2,0.5)),0.,1.);\n}\n\n#elif (TYPE==2)\n\n#define COL1 vec3(0.8, .5, .2)\n#define PT1 vec3(0.1, .75, .5)\n#define COL2 vec3(0.5, .3, .7)\n#define PT2 vec3(0.5, .7, .3)\n\n//Linearly interpolated, 4-color looping palette \n//9 Instructions\nvec3 getPalette(float x, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    x = fract(x);\n    return mix(mix(mix(mix(a,b,clamp(x*4.,0.0,1.0)), c, clamp((x-0.25)*4.,0.0,1.0)), \n                   d, clamp((x-0.5)*4.,0.0,1.0)), a, clamp((x-0.75)*4.,0.0,1.0));\n}\n#else\n\n#define COL1 vec3(1., .0, .4)\n#define PT1 vec3(-2., 1.0, .1)\n#define COL2 vec3(-1., 2.0, .4)\n#define PT2 vec3(0.5, .5, .55)\n\n//Simple sine based palette, much harder to get specific colors\n//9 Instruction (8 in its simplest form)\nvec3 getPalette(float x, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    x *= 6.2831853;\n    return vec3(sin(x*a.x - a.y)*a.z + d.x, sin(x*b.x - b.y)*b.z + d.y, sin(x*c.x + c.y)*c.z + d.z);\n}\n#endif\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Cheap Bezier palettes by nimitz\n//by nimitz 2019 (twitter: @stormoid)\n\n#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tfragColor = vec4(getPalette(q.x*4.6, COL1, COL2, PT1, PT2), 1.);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}