{"ver":"0.1","info":{"id":"tt3XzH","date":"1580405152","viewed":172,"name":"Volumetric Shadows experiment","username":"peterbraden","description":"Soft shadows and volumes","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFINITY         999.9e16\n#define STEPS 100\n#define EPSILON         1e-5\n#define MAX_DEPTH       1000.0\n#define LIGHT \t\t\tnormalize(vec3(1.0, 2.0, 0.0))\n\nstruct Ray { vec3 origin; vec3 direction; };\n\nvec3 perspectiveCameraRayDirection(in vec2 pixelCoord) {\n  vec2 pixelPos = (pixelCoord) * 2.0 - 1.0;\n  vec2 aspect = iResolution.xy / iResolution.xx;\n  vec3 camRight   = vec3( 1.0,  0.0,  0.0);\n  vec3 camUp      = vec3( 0.0,  1.0,  0.0);\n  vec3 camForward = vec3(0.0, 0.0, 1.0);\n  return normalize( pixelPos.x * aspect.x * camRight + pixelPos.y * aspect.y * camUp + camForward );\n}\n\nfloat sdPlane( vec3 p ){\n\treturn p.y;\n}\n                     \nfloat sdSphere(vec3 p, float s){\n    return length(p)-s;\n}\n\n\nfloat sdScene(vec3 p){\n\treturn min(\n        min(\n          sdSphere(p - vec3(0.0, 6.0 + cos(iTime) * 5.0, 0.0), 2.0),\n          sdSphere(p - vec3(5.0, 6.0 + sin(iTime) * 5.0, 0.0), 2.0)\n        ),\n        min(\n          sdSphere(p - vec3(-5.0, 6.0 + sin(iTime-4.0) * 5.0, 0.0), 2.0),\n          sdPlane(p)\n        )\n    );\n}\n\n/*\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)) - sdScene(vec3(p.x - EPSILON, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)) - sdScene(vec3(p.x, p.y - EPSILON, p.z)),\n        sdScene(vec3(p.x, p.y, p.z  + EPSILON)) - sdScene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nfloat intersection(Ray r){\n  float depth = 0.0;\n  for (int i = 0; i < STEPS; i++) {\n    vec3 p = r.origin + depth * r.direction;\n    float dist = sdScene(p);\n    if (dist < EPSILON) {\n        return depth + dist;\n    }\n    depth += dist;\n    if (depth > MAX_DEPTH) {\n        return depth;\n    }\n  }\n  return depth;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow( Ray r, in float mint, in float tmax ){\n    float res = 1.0;\n    float t = mint;\n    for(int i=0; i<16; i++ ) {\n\t\tfloat h = sdScene( r.origin + r.direction*t );\n        float s = clamp(10.0 * h/t, 0.0 ,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += min( res, 10.0*h/t );\n        if( res < 0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 colorPt(vec3 pt){\n\tvec3 normal = estimateNormal(pt);\n    vec3 ambient = vec3(0.1);\n    float diffuse = max(dot(normal, LIGHT), 0.0);\n    float shadow = calcSoftShadow(Ray(pt, LIGHT), EPSILON, INFINITY);\n\treturn ambient + diffuse * shadow;\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float b = 0.05;\n    float fogAmount = 1.0 - exp( -distance*b );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nfloat fogAtPoint(vec3 pt){\n    float shadow = intersection(Ray(pt, LIGHT));\n    if (shadow < MAX_DEPTH) {\n    \treturn 0.99;\n    } else {\n    \treturn 1.005;\n    }\n}\n\nvec4 pixel(in vec2 uv ) {\n  Ray r = Ray( vec3(0.0, 3.0,  -15.0), perspectiveCameraRayDirection(uv));\n  vec3 pixel = vec3(0.0);\n  float depth = intersection(r);\n  vec3 ipt = r.origin + depth * r.direction;\n  if (depth < MAX_DEPTH) {\n    pixel = colorPt(ipt);\n  } else {\n\tpixel = vec3(0.5);\n  }\n    \n  float stepSize = 1.0 / 100.0 * 30.0;\n  pixel = applyFog(pixel, depth, r.direction, LIGHT);\n  for (int i = 0; i < 100; i++){\n    float sd = stepSize * float(i);\n  \tif (sd > depth) break;\n    pixel *= fogAtPoint(r.origin + r.direction * sd);\n  }\n  return vec4(pixel, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 aa = 0.25 / iResolution.xy;\n  fragColor = pixel(uv); \n  fragColor += pixel(uv + aa);\n  fragColor *= 0.5;  \n}","name":"Image","description":"","type":"image"}]}