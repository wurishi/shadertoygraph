{"ver":"0.1","info":{"id":"mt2GWh","date":"1673260092","viewed":120,"name":"raytrace reflect&refract","username":"lambwww","description":"参考了https://www.shadertoy.com/view/ttfyzN并添加了自己的一些修改，还有一些没弄明白，学习中","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//光线可以看到的最远距离\nconst float maxFar=10000.;\n//光线交叉的最短距离，防止刚反弹出来又弹射\nconst float minRayHitTime=0.01;\n//光线弹射次数\nconst int bounceTime=8;\n\nconst float pi=3.1415926535;\n//\nconst float c_rayPosNormalNudge = 0.01f;\n\n//交点信息\nstruct SRayHitInfo\n{\n    bool inside; //判断光线是否在物体内部\n    float dist;\n    vec3 normal;\n    vec3 albedo; //颜色\n    vec3 emission; //发光\n    \n    float percentSpecular; //镜面反射所占的比重，越大占的越多\n    float specularRoughness; //粗糙程度，越接近0镜面反射越清晰\n    vec3 specularColor; //镜面反射的颜色\n    float IOR; //index of refraction,介质自己的折射系数，也就是常说的n\n    \n    float percentRefract; //折射的比重\n    float refractRoughess; //折射时材质的浑浊度\n    vec3 refractColor;\n};\n\n//随机数处理使用了重要性采样，这里也有点没搞清楚原理\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\nvec3 RandomUnitVec(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * 2. * pi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\n//判断光线是否和球体相交\n//sphere.xyz代表球心位置，sphere.w代表球的半径大小\nbool TestSphereTrace(in vec3 ro, in vec3 rd, inout SRayHitInfo info, in vec4 sphere)\n{\n    float r=sphere.w*sphere.w;\n    \n    vec3 l=ro-sphere.xyz;\n    float s=dot(l,rd);\n    float c=dot(l,l)-sphere.w*sphere.w;\n    //当射线方向原理球体，且射线原点在球外，代表没有交点\n    if(s>.0 && c>.0) //这里有点不明白为什么是s>0，为什么不是s<0，小于0不是代表两者夹角大于90°吗\n        return false;\n     \n    float m=dot(l,l)-s*s;\n    //球心向光线做垂线，如果这段线距离大于球半径，代表没有交点\n    if(m>sphere.w*sphere.w)\n        return false;\n        \n    //计算相交点，选择最近的那个点\n    bool inside=false;\n    float q=sqrt(r-m);\n    float t=-s-q;\n    if(t<0.)//此时光线在内部，因为上面已经把光在外部的所有情况都走过一遍了\n    {\n        t=-s+q;\n        inside=true;\n    }\n    \n    //判断交点是否在可视范围内并赋值   \n    if(t>minRayHitTime && t<info.dist)\n    {\n        info.dist=t;\n        info.inside=inside;\n        info.normal=normalize(ro+t*rd-sphere.xyz)*(inside?-1.:1.);//计算交点的表面法线\n        return true;\n    }\n    return false;\n}\n//判断光线是否和矩形相交\n//a b c d是矩形的四个顶点，左下点开始逆时针分别是四个点\nbool TestQuadTrace(vec3 ro,vec3 rd,inout SRayHitInfo info,vec3 a,vec3 b,vec3 c,vec3 d)\n{\n    vec3 normal=normalize(cross(c-a,c-b));//两个向量叉乘获得垂直于矩形的法向量\n    //如果法线和光线夹角小于90度，就把法线和平面一块180度翻转一下\n    //这里暂时没搞懂为什么这样做，mark一下\n    if (dot(normal, rd) > 0.0f)\n    {\n        normal *= -1.0f;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = ro;\n    vec3 q = ro + rd;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n    \n    //以ac对角线为边界，判断光线在对角线上面还是下面\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;//交点\n    //将光线和矩形求交优化为光线和三角形求交\n    if (v >= 0.0f)\n    {\n        //和三角形abc求交\n        //三角形平面内任意点可表示为p=ua+vb+wc，abc是三角形三个顶点坐标，uvw根据重心坐标的性质有u+v+w=1\n        //将等号左边的射线式子和等号右边的三角形坐标式子联立：o+td=(1-u-v)a+ub+vc\n        //整理为矩阵形式并使用Cramer法则对方程求解\n        //原理参考了文章https://zhuanlan.zhihu.com/p/405075535\n        vec3 e1=b-a;\n        vec3 e2=c-a;\n        vec3 q1=cross(rd,e2);\n        float a1=dot(e1,q1);\n        float f=1./a1;\n        vec3 s=ro-a;\n        float u=f*dot(s,q1);\n        if(u<.0) return false;\n        vec3 r=cross(s,e1);\n        float w=f*dot(rd,r);\n        if(w<0. || w+u>1.) return false;\n        intersectPos=(1.-u-w)*a+u*b+w*c; //等号右边的三个参数对应重心性质的三个参数\n    }\n    else\n    {\n        //和三角形acd求交\n        //自己参考资料写的：\n        vec3 e1=d-a;\n        vec3 e2=c-a;\n        vec3 q1=cross(rd,e2);\n        float a1=dot(e1,q1);\n        float f=1./a1;\n        vec3 s=ro-a;\n        float u=f*dot(s,q1);\n        if(u<.0) return false;\n        vec3 r=cross(s,e1);\n        float w=f*dot(rd,r);\n        if(w<0. || w+u>1.) return false;\n        intersectPos=(1.-u-w)*a+u*d+w*c;\n    }\n    \n    float dist; //求距离值\n    if (abs(rd.x) > 0.1f)\n    {\n        dist = (intersectPos.x - ro.x) / rd.x;\n    }\n    else if (abs(rd.y) > 0.1f)\n    {\n        dist = (intersectPos.y - ro.y) / rd.y;\n    }\n    else\n    {\n        dist = (intersectPos.z - ro.z) / rd.z;\n    }\n    \n\tif (dist > minRayHitTime && dist < info.dist)\n    {\n        info.dist = dist;        \n        info.normal = normal;   \n        info.inside=false;\n        return true;\n    }    \n    \n    return false;\n}\n//场景\nvoid TestSceneTrace(vec3 ro,vec3 rd,inout SRayHitInfo info)\n{\n    //上面的球\n    //从左到右折射率逐渐减少\n    if(TestSphereTrace(ro,rd,info,vec4(-17.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo = vec3(0.75f, 0.75f, 0.75f);\n        info.emission = vec3(0.0f, 0.0f, 0.0f);        \n        info.percentSpecular = 0.1f;\n        info.specularRoughness = .1;\n        info.specularColor = vec3(1.0f, 1.0f, 1.0f);\n        info.IOR = 1.1f;\n        info.percentRefract = 1.f;\n        info.refractRoughess = .1;\n        info.refractColor = vec3(0.f, 0.f, .0f); \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(-10.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo = vec3(0.75f, 0.75f, 0.75f);\n        info.emission = vec3(0.0f, 0.0f, 0.0f);        \n        info.percentSpecular = 0.1f;\n        info.specularRoughness = .1;\n        info.specularColor = vec3(1.0f, 1.0f, 1.0f);\n        info.IOR = 1.1f;\n        info.percentRefract = .8f;\n        info.refractRoughess = .1;\n        info.refractColor = vec3(0.f, 0.f, .0f);      \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(-3.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo = vec3(0.75f, 0.75f, 0.75f);\n        info.emission = vec3(0.0f, 0.0f, 0.0f);        \n        info.percentSpecular = 0.1f;\n        info.specularRoughness = .1;\n        info.specularColor = vec3(1.0f, 1.0f, 1.0f);\n        info.IOR = 1.1f;\n        info.percentRefract = .6f;\n        info.refractRoughess = .1;\n        info.refractColor = vec3(0.f, 0.f, .0f);   \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(4.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo = vec3(0.75f, 0.75f, 0.75f);\n        info.emission = vec3(0.0f, 0.0f, 0.0f);        \n        info.percentSpecular = 0.1f;\n        info.specularRoughness = .1;\n        info.specularColor = vec3(1.0f, 1.0f, 1.0f);\n        info.IOR = 1.1f;\n        info.percentRefract = .4f;\n        info.refractRoughess = .1;\n        info.refractColor = vec3(0.f, 0.f, .0f);  \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(11.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo = vec3(0.75f, 0.75f, 0.75f);\n        info.emission = vec3(0.0f, 0.0f, 0.0f);        \n        info.percentSpecular = 0.1f;\n        info.specularRoughness = .1;\n        info.specularColor = vec3(1.0f, 1.0f, 1.0f);\n        info.IOR = 1.1f;\n        info.percentRefract = .2f;\n        info.refractRoughess = .1;\n        info.refractColor = vec3(0.f, 0.f, .0f); \n    }\n    if(TestSphereTrace(ro,rd,info,vec4(18.0f, 0.0f, 22.0f, 3.0f)))\n    {\n        //赋颜色值\n        info.albedo = vec3(0.75f, 0.75f, 0.75f);\n        info.emission = vec3(0.0f, 0.0f, 0.0f);        \n        info.percentSpecular = 0.1f;\n        info.specularRoughness = .1;\n        info.specularColor = vec3(1.0f, 1.0f, 1.0f);\n        info.IOR = 1.1f;\n        info.percentRefract = .0f;\n        info.refractRoughess = .1;\n        info.refractColor = vec3(0.f, 0.f, .0f); \n    }\n    //前面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(20.,-15.,25.),vec3(20.,15.,25.),vec3(-20.,15.,25.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n        info.IOR = 1.f;\n    }\n    //上面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,15.,25.),vec3(20.,15.,25.),vec3(20.,15.,17.),vec3(-20.,15.,17.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n        info.IOR = 1.f;\n    }\n    //下面的墙\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(20.,-15.,25.),vec3(20.,-15.,17.),vec3(-20.,-15.,17.)))\n    {\n        info.albedo=vec3(.7,.7,.7);\n        info.emission=vec3(.0,.0,.0);\n        info.IOR = 1.f;\n    }\n    //左\n    if(TestQuadTrace(ro,rd,info,vec3(-20.,-15.,25.),vec3(-20.,15.,25.),vec3(-20.,15.,17.),vec3(-20.,-15.,17.)))\n    {\n        info.albedo=vec3(0.7,.1,.1);\n        info.emission=vec3(.0,.0,.0);\n        info.IOR = 1.f;\n    }\n    //右\n    if(TestQuadTrace(ro,rd,info,vec3(20.,-15.,25.),vec3(20.,15.,25.),vec3(20.,15.,17.),vec3(20.,-15.,17.)))\n    {\n        info.albedo=vec3(0.1,.7,.1);\n        info.emission=vec3(.0,.0,.0);\n        info.IOR = 1.f;\n    }\n    //light\n    if(TestQuadTrace(ro,rd,info,vec3(-6.,14.9,23.),vec3(6.,14.9,23),vec3(6.,14.9,18.),vec3(-6.,14.9,18.)))\n    {\n        info.albedo = vec3(0.0f, 0.0f, 0.0f);\n        info.emission = vec3(1.0f, 0.9f, 0.7f) * 20.0f;\n    }\n}\n//菲涅尔，描述光在不同介质之间折射的行为\n//n1和n2代表光线入射前后的介质折射率，normal代表物体表面法线，dir代表光线击中对象时的方向，f0和f90分别代表光在入射角度0和90时的反射率（折射率则用1减去反射\nfloat fresnel(float n1,float n2,vec3 normal,vec3 dir,float f0,float f90)\n{\n    float r0=(n1-n2)/(n1+n2);\n    r0*=r0;\n    float cosDir=-dot(normal,dir);\n    float x=1.-cosDir;\n    float res=r0+(1.-r0)*x*x*x*x*x;\n    //根据菲涅尔公式算出来该角度对应的系数，让这个系数在最小反射率和最大的中间插值\n    return mix(f0,f90,res);\n    \n}\n//返回光线相交到点的颜色\nvec3 GetColorForRay(vec3 ro,vec3 rd, uint random)\n{\n    vec3 res=vec3(.0,.0,.0);\n    vec3 throughput = vec3(1.0f, 1.0f, 1.0f); //我的理解就是光线的颜色\n    \n    for(int i=0;i<bounceTime;i++)\n    {\n        SRayHitInfo hitInfo; //ray和物体的交点\n        hitInfo.dist=maxFar;\n        hitInfo.inside=false;\n        TestSceneTrace(ro,rd,hitInfo);\n        //代表没有相交物体\n        if(hitInfo.dist==maxFar)\n        {\n            res += texture(iChannel1, rd).rgb * throughput;\n            break; //这里可以添加一个环境光让整体更亮\n        }\n        if (hitInfo.inside)\n            throughput *= exp(-hitInfo.refractColor * hitInfo.dist);\n            \n        //漫反射光线\n        vec3 diffuseRd=normalize(hitInfo.normal+RandomUnitVec(random)); \n        //完全反射的镜面反射光线\n        vec3 specularRd=reflect(rd,hitInfo.normal); \n        //根据粗糙度对光线方向进行插值，如果粗糙度为0就是完全的镜面反射，如果粗糙度是1就是完全的漫反射\n        //如果粗糙度处于0到1中间，那么镜面反射光线就要根据粗糙度适当向漫反射光线接近\n        specularRd=normalize(mix(specularRd,diffuseRd,hitInfo.specularRoughness)); \n        //折射光线\n        //计算光线折射方向，方法第三个系数eta=入射物质IOR/折射物质IOR，判断光线投射的方向决定系数\n        vec3 refractRd=normalize(refract(rd,hitInfo.normal,hitInfo.inside?hitInfo.IOR:1.0/hitInfo.IOR));\n        //使用随机方法生成一个折射方向，根据材质的浑浊度refractRoughess给光线方向插值\n        refractRd=normalize(mix(refractRd,normalize(-hitInfo.normal+RandomUnitVec(random)),hitInfo.refractRoughess));\n        \n        //使用随机值，判断光线是漫反射、镜面反射还是折射\n        //获取反射和折射的比重\n        float percentSpecular=hitInfo.percentSpecular;\n        float percentRefract=hitInfo.percentRefract;\n        //使用菲涅尔反射获取当前角度的反射率\n        if (percentSpecular > 0.0f)\n        {\n            percentSpecular = fresnel(\n                1.0,\n                hitInfo.IOR,\n                hitInfo.normal,rd, percentSpecular, 1.0f);  \n        }\n        //判断光线下一步投射的方法\n        float doSpecular=0.;\n        float doRefract=0.;\n        float randomSelect=RandomFloat01(random); //使用随机数，选择随机数所在的区间，确认光线射的方式\n        if (percentSpecular > 0.0f && randomSelect < percentSpecular)\n        {\n            doSpecular = 1.0f;\n        }\n        else if (percentRefract > 0.0f && randomSelect < percentSpecular + percentRefract)\n        {\n            doRefract = 1.0f;\n        }\n        //更新位置\n        if(doRefract==1.)\n        {\n            ro=ro+hitInfo.dist*rd-hitInfo.normal*c_rayPosNormalNudge;\n        }\n        else\n        {\n            ro=ro+hitInfo.dist*rd+hitInfo.normal*c_rayPosNormalNudge;\n        }\n        //更新光线方向\n        rd = mix(diffuseRd, specularRd, doSpecular);\n        rd = mix(rd, refractRd, doRefract);\n        \n        res+=hitInfo.emission*throughput; //为当前像素的颜色赋值\n        \n        //为光线着色，折射不会为光线上色\n        if (doRefract == 0.)\n        \tthroughput *= mix(hitInfo.albedo, hitInfo.specularColor, doSpecular);\n        //使用了俄罗斯轮盘赌\n        {\n        \tfloat p = max(throughput.r, max(throughput.g, throughput.b));\n        \tif (RandomFloat01(random) > p)\n            \tbreak;\n\n        \t// 对光线的强度做衰减\n        \tthroughput *= 1.0f / p;            \n        }\n    }\n    \n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    vec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;//修改了变形\n    \n    vec3 ro=vec3(.0,.0,.0); //ray origin\n    vec3 rd=normalize(vec3(uv,1.)-ro); //ray dirction\n    \n    //生成随机数\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    //进行追踪\n    vec3 col=GetColorForRay(ro,rd,rngState);\n    //和上一帧的图像进行混合\n    vec3 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col = mix(lastFrameColor, col, 1.0/ float(iFrame+1));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}