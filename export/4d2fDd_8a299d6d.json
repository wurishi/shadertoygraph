{"ver":"0.1","info":{"id":"4d2fDd","date":"1502860643","viewed":288,"name":"Hyperbolic Trig","username":"dust","description":"Experimenting with ray-marched trig functions\nEDIT: Implemented DIY cosh/sinh to improve support for early versions of GLSL ES","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","grayscale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz * -1.0, qtn.w);\n}\n\n// Compute the product of two quaternions\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnProduct(qtn, vec4(vec, 0.0));\n    return QtnProduct(qv, QtnInverse(qtn)).xyz;\n}\n\n// Manual implementation of [sinh] for devices with early\n// versions of GLSL ES\nfloat Sinh(float area)\n{\n    float e = 2.718;\n    return (pow(e, area) - pow(e, area * -1.0)) / 2.0;\n}\n\n// Manual implementation of [cosh] for devices with early\n// versions of GLSL ES\nfloat Cosh(float area)\n{\n    float e = 2.718;\n    return (pow(e, area) + pow(e, area * -1.0)) / 2.0;    \n}\n\nfloat TrigDF(vec3 coord, vec3 trigPos)\n{\n    coord -= trigPos;\n    coord = QtnRotate(coord, vec4(vec3(0.9, 0.0, 0.0) * sin(iTime), cos(iTime)));\n    float coordAccum = coord.x * coord.y + coord.z;\n    return length(coord) - Cosh(coordAccum) / Sinh(coordAccum);\n}\n\nvec3 GetNormal(vec3 samplePoint, float eps, vec3 trigPos)\n{\n    float normXA = TrigDF(vec3(samplePoint.x + eps, samplePoint.y, samplePoint.z), trigPos);\n    float normXB = TrigDF(vec3(samplePoint.x - eps, samplePoint.y, samplePoint.z), trigPos);\n\n    float normYA = TrigDF(vec3(samplePoint.x, samplePoint.y + eps, samplePoint.z), trigPos);\n    float normYB = TrigDF(vec3(samplePoint.x, samplePoint.y - eps, samplePoint.z), trigPos);\n\n    float normZA = TrigDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z + eps), trigPos);\n    float normZB = TrigDF(vec3(samplePoint.x, samplePoint.y, samplePoint.z - eps), trigPos);\n\n    return normalize(vec3(normXA - normXB,\n                          normYA - normYB,\n                          normZA - normZB));\n}\n\nvec3 RayDir(float fovRads, vec2 viewSizes, vec2 pixID)\n{\n    vec2 xy = pixID - (viewSizes / 2.0);\n    float z = viewSizes.y / tan(fovRads / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float eps = 0.00001;\n    float currRayDist = 0.0;\n\tvec3 rayDir = RayDir(3.14 / 2.0, iResolution.xy, fragCoord);\n    vec3 trigPos = vec3(0.0, 0.0, 4.0);\n    for (int i = 0; i < 255; i += 1)\n    {\n        vec3 eyePos = vec3(0.0, 0.0, -3.0);\n    \tvec3 rayVec = eyePos + (rayDir * currRayDist);\n        float trgDist = TrigDF(rayVec, trigPos);\n        if (trgDist < eps)\n        {   \n            float nDL = dot(GetNormal(rayVec, eps, trigPos), \n                            normalize(vec3(1.0, 1.0, -1.0)));\n            fragColor = vec4(nDL, nDL, nDL, 1.0);\n            return;\n        }\n        \n        currRayDist += trgDist;\n    }\n    \n\tfragColor = vec4(0.8, 0.8, 0.8, 1.0);\n}","name":"Image","description":"","type":"image"}]}