{"ver":"0.1","info":{"id":"cdsSRS","date":"1699816622","viewed":106,"name":"Passing Voxels","username":"panna_pudi","description":"ヾ( `ー´)シφ__","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["voxels","isometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b)) / (x*(c*x+d)+e);\n}\n\nvec3 srgb_encode(vec3 v) {\n  return mix(12.92 * v, 1.055 * pow(v, vec3(.41666)) - .055, step(.0031308, v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 tex = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n\n    vec3 col = tex.rgb;\n    vec2 fc = fragCoord;\n\n    col = ACESFilm(col);\n    col = srgb_encode(col);\n    fragColor = vec4(col.rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// hit pass\n// Hit or miss? I guess I never miss, hah~\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord  +  1. * halton(iFrame + 1) - 1.;\n    uv = (uv - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ro, rd;\n    get_cam(uv, ro, rd);\n   \n    mat4 tr = translate(vec3(0., BBOX.y, -BBOX.z) \n                      + vec3(0., -0.011, 0.01));\n    vec2 advance = ibox(ro, rd, BBOX, inverse(tr));\n    float tmin = 0.;\n    if (advance.x > -0.5) { tmin = advance.x; }\n         else { fragColor = vec4(-1.); }\n\n    vec3 col = vec3(0.);\n    \n    vec2 res = trace(ro, rd, tmin);\n    \n    vec3 p = ro + rd * res.x;\n    vec3 nor = get_norm(p); vec3 alig, vPos;\n    res = marchVxl(ro, rd, tmin, 50., alig);\n    nor = -sign(rd)*alig;\n    float n = uintBitsToFloat(octahedral_32(nor));\n    \n    const float volume_fogDensity = .125;\n    float depth = res.x;\n    float absorb = exp(-depth * volume_fogDensity);\n    absorb = clamp(absorb,.75, 1.);\n    \n    fragColor = vec4(res, n, absorb);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = PI * 2.;\nconst float GOLDEN_RATIO = (1. + sqrt(5.)) * 0.5;\nconst float GOLDEN_ANGLE = 2.3999632297286533;\n#define sat(x) clamp(x, 0., 1.)\n\n#define MAX_DIST 1000.\n#define MIN_DIST .0001\n\nconst vec3 UP = vec3(0.0, 0.0, 1.0);\n\nconst vec3 LIGHT_DIR = normalize(vec3(-0.1, 0.8, 0.5));\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash31(vec3 p3) {\n    p3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash21(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash12(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nmat4 translate(float x, float y, float z) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n\t\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t\t0.0, 0.0, 1.0, 0.0,\n\t\t\t\tx,   y,   z,   1.0 );\n}\nmat4 translate(vec3 p) {\n    return translate(p.x, p.y, p.z);\n}\n\nvec2 ibox(in vec3 ro, in vec3 rd, vec3 boxSize, mat4 trans) {\n    rd = (trans * vec4(rd, 0.0)).xyz;\n\tro = (trans * vec4(ro, 1.0)).xyz;\n    \n    vec3 m = 1. / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if( tN > tF || tF < 0.0) return vec2(-1.);\n    return vec2(tN, tF);\n}\n\nvec2 _min(vec2 a, vec2 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nconst vec3 BBOX = vec3(100.);\n\nvec2 map(vec3 p) {\n    vec2 d = vec2(1e9, -1.);\n    \n    vec3 h = BBOX;\n    float box = sd_box(p - vec3(0., h.y, -h.z), h);\n    \n    h = vec3(3.);\n    float b = sd_box(p - vec3(0., h.y, -h.z) * 0.5, h);\n    box = max(box, -b) - 0.01;\n    d = _min(d, vec2(box, 1.));\n    \n    p.x = abs(p.x) - 1.;\n    float s = length(p - vec3(0., 1.5, -3.5)) - 0.5;\n    d = _min(d, vec2(s, 2.));\n    \n    return d;\n}\n\nvec2 trace(vec3 ro, vec3 rd, float tmin) {\n    float t = tmin;// + 0.0001;\n    for (int i = 0; i < 100; ++i) {\n        vec3 pos = ro + rd * t;\n        vec2 d = map(pos);\n        if ((d.x) < 0.001) {\n            return vec2(t, d.y);\n        }\n        t += d.x;\n        if (t > 50.) break;\n    }\n    return vec2(-1.);\n}\n\nvec3 get_norm(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(MIN_DIST);\n    return normalize(map(p).x - vec3(map(k[0]).x, map(k[1]).x, map(k[2]).x));\n}\n\n#define ITR 160\n#define FAR 10.\n\n//Voxel size\nconst float scl = 0.05;\nconst float hscl = scl*0.5;\nfloat dbox(vec3 ro, vec3 invrd, float size)  {\n    vec3 t = -ro * invrd + abs(invrd) * size;\n\treturn min(min(t.x, t.y), t.z);\n}\n\nvec2 marchVxl(in vec3 ro, in vec3 rd, float near, float far, out vec3 alig) {\n    float lastd = 0.0001;\n    float travel = near;\n    \n    float grid_stride = 0.;\n    vec3 ip = vec3(0);\n    vec3 invrd = 1. / rd;\n    vec2 bxNfo = vec2(0.);\n    \n    for(int i=0; i < ITR; i++) {\n        travel += lastd + grid_stride;\n        if(travel > far) break;\n        vec3 pos = ro + rd * travel;\n        float mapD = map(pos).x;\n        \n        if (mapD < (scl * 1.)) {\n            travel -= lastd * 1.;\n            pos = ro + rd * travel;\n            ip = (floor(pos / scl) + 0.5) * scl;\n        \tbxNfo = map(ip);\n            if (bxNfo.x < 0.0) break;\n            vec3 q  = fract(pos/scl) * scl - hscl;\n            grid_stride = dbox(q, invrd, hscl + 1e-6);\n            mapD = 0.;\n        } else { grid_stride = 0.; }\n        lastd = mapD;\n    }\n    \n    vec3 intc = -(fract((ro + rd * travel) / scl) * scl - hscl) * \n                invrd - abs(invrd) * hscl;\n    alig = step(intc.yzx, intc.xyz) * step(intc.zxy, intc.xyz);\n    \n\treturn vec2(travel, bxNfo.y);\n}\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm){\n    vec3 alig, vPos;\n    //return (marchVxl(ro + 0.002 * norm, rd, 0., 50., alig).y > 0. ? 0. : 1.);\n    return (trace(ro + 0.002 * norm, rd, 0.).y > 0. ? 0. : 1.);\n}\n\nvoid get_cami(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float zoom = 10.;\n    rd = normalize(vec3(1., 0., 0.));\n    ro = vec3(-10., 0., 0.) + vec3(1., uv * zoom);\n\n    ro.xz *= rot(-atan(1. / sqrt(2.)));\n    rd.xz *= rot(-atan(1. / sqrt(2.)));\n    ro.xy *= rot(PI / 4.);\n    rd.xy *= rot(PI / 4.);  \n}\n\nvoid get_cam(in vec2 uv, out vec3 ro, out vec3 rd) {\n    ro = vec3(-6., 1., -1.5);\n    rd = normalize(vec3(1., uv));\n \n    float a = -0.4;\n    ro.xz *= rot(a);\n    rd.xz *= rot(a);\n    ro.xy *= rot(PI / 4.);\n    rd.xy *= rot(PI / 4.);  \n}\n\nfloat seed;\nfloat hash11_seed() {\n    float p=seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    seed += 1.33;\n    return fract(p);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 get_cosine_wsample(vec3 dir, float radius) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(hash11_seed(), hash11_seed());\n\tr.x = r.x * 2.0 * PI;\n\tr.y = pow(r.y, radius);\n\tfloat oneminus = sqrt(abs(1.0-r.y*r.y));\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n// https://www.shadertoy.com/view/4llcRl\nuint pres = 16u;\nuint octahedral_32( in vec3 nor ) {\n    nor /= (abs(nor.x) + abs(nor.y) + abs(nor.z));\n    nor.xy = (nor.z >= 0.0) ? nor.xy : (1.0 - abs(nor.yx)) * sign(nor.xy);\n    vec2 v = 0.5 + 0.5 * nor.xy;\n\n    uint mu = (1u << pres) - 1u;\n    uvec2 d = uvec2(floor(v * float(mu) + 0.5));\n    return (d.y << pres) | d.x;\n}\n\nvec3 i_octahedral_32( uint data ) {\n    uint mu =(1u << pres)-1u;\n    \n    uvec2 d = uvec2( data, data >> pres ) & mu;\n    vec2 v = vec2(d) / float(mu);\n    \n    v = -1.0 + 2.0 * v;\n    vec3 nor = vec3(v, 1.0 - abs(v.x) - abs(v.y));\n    float t = max(-nor.z, 0.0);\n    nor.x += (nor.x > 0.0) ? -t : t;\n    nor.y += (nor.y > 0.0) ? -t : t;\n   \n    return normalize(nor);\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvoid halton_loop(inout vec2 s, inout vec4 a){\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(s, coprimes);\n    s = floor(s/coprimes);\n}\nvec2 halton (int index){\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    return a.zw;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nconst float sunAngulrDiameter = 2.5;\nconst float sunIluminance = 1.5;\n\nfloat calc_shadow(vec3 ro, vec3 rd, vec3 normal){\n\tfloat shadow = 0.0;\n    int rays_shadow = 3;\n    float rShadowRays = 1.0 / float(rays_shadow);\n    \n\tfor (int i = 0; i < rays_shadow; ++i){\n        vec3 dir = normalize(rd +  \n            get_cosine_wsample(rd, 0.25));\n        float ldotn = dot(dir, normal);\n        if (ldotn <= 0.0) continue;\n        \n        ldotn = sqrt(clamp(ldotn, 0.0, 1.0));\n        \n\t\tfloat light = sunIluminance * ldotn;\n        float rayHit = get_scene_intersect(ro, dir, normal);\n\t\t\n\t\tshadow += rayHit * light;\n\t}\n    \n    return shadow * rShadowRays;\n}\n#define AORays 2\nvec3 calculate_bouncelight_AO(vec3 ro, vec3 rd, vec3 normal, vec3 add_col){\t\n    vec3 AO = vec3(0.0);\n    const float rAORays = 1.0 / float(AORays);\n    \n\tfor (int i = 0; i < AORays; ++i){\n\t\tvec3 dir = normalize(normal + 5.*get_cosine_wsample(normal,0.5));\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;        \n        float rayHit = get_scene_intersect(ro, dir, normal);\n\t\tAO += rayHit * add_col;\n\t}\n    \n    AO = AO * rAORays * 2./PI;\n    \n\treturn AO;\n}\n\nconst int volumeSteps = 10;\nfloat raymarchVolume(vec3 ro, vec3 rd, float noise){\n    const float rSteps = 1.0 / float(volumeSteps);\n    \n    vec3 start = vec3(0.0);\n    vec3 end = ro;\n    float endDepth = length(end);\n    end /= max(endDepth,0.0001);\n    endDepth = min(length(ro), MAX_DIST);\n    end *= endDepth;\n    \n    vec3 increment = (end - start) * rSteps;\n    vec3 rayPosition = noise * increment + start;\n    \n    float fogLitPercent = 0.0f;\n    for (int i = 0; i < volumeSteps; i++){\n        float volumetricShadow = get_scene_intersect(rayPosition + rd, LIGHT_DIR, rayPosition + rd);\n        fogLitPercent = mix(fogLitPercent, volumetricShadow, 1.0 / float(i+1));\n        rayPosition +=  increment;\n     }\n    return fogLitPercent;\n}\n\nvec3 raymarchVolume_image(vec3 backGround, float absorb, vec3 sunColor, float lDotV, float fogLitPercent){    \n    vec3 c_fogColorLit = backGround+sunColor+0.0005*(0.5+sunColor*0.5);\n    const vec3 c_fogColorUnlit = vec3(0.);\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent*fogLitPercent*fogLitPercent);\n    return mix(fogColor, backGround, absorb);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    seed = hash21(fragCoord.xy+hash12(float(iFrame%10000)*0.333)*1234.123);\n    vec2 fc = fragCoord.xy;\n    vec4 hit = texelFetch(iChannel0, ivec2(fc), 0);\n    vec2 uv = fragCoord  +  2. * halton(iFrame + 1) - 1.;\n    uv = (uv - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 ro, rd;\n    get_cam(uv, ro, rd);\n    \n    vec3 pos = ro + rd * hit.x;\n    vec3 nor = i_octahedral_32(floatBitsToUint(hit.z));\n\n    vec3 albedo = vec3(0.1);\n    if (hit.y > .5) albedo = vec3(0.7);\n    if (hit.y > 1.5) albedo = vec3(0.7, 0.1, 0.1);\n    vec3 emission = vec3(0.);\n    if (hit.y > 1.5) emission = vec3(.2, 0., 0.3);\n\n    float diff = dot(LIGHT_DIR, nor);\n    diff = mix(diff * 0.5 + 0.5, max(diff, 0.), 0.25);\n\n    float fogLitPercent = raymarchVolume(pos - ro, ro, hash11_seed());\n\n\tvec3 color_light_AO = calculate_bouncelight_AO(pos, rd, nor, vec3(.1));\n    vec3 shadow = calc_shadow(pos, LIGHT_DIR, nor) * vec3(0.776,0.275,0.0) * 10.;\n\n    vec3 color = mix(color_light_AO+shadow,vec3(0.),dot(emission,vec3(1.))/3.);\n    color = mix(albedo*color, emission, dot(emission,vec3(1.))/3.);\n\n    float absorb = texelFetch(iChannel0, ivec2(fc), 0).a;\n    float lDotV = dot(rd, LIGHT_DIR); vec3 fog_col = vec3(0.776,0.275,0.0);\n    color = raymarchVolume_image(color, absorb, fog_col, lDotV, fogLitPercent);\n\n    vec3 last_frame_color = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    color = mix(last_frame_color, color, 1.0 / float(iFrame + 1));\n\n    fragColor = vec4(color, fogLitPercent);\n}","name":"Buffer B","description":"","type":"buffer"}]}