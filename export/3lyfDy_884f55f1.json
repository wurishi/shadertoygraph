{"ver":"0.1","info":{"id":"3lyfDy","date":"1614961855","viewed":109,"name":"electron orbitals","username":"stonedape","description":"the red and blue parts are the real and imaginary parts of the wave function respectively","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["djddkkss"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 I=vec2(0.,1.); //the imaginary unit\nfloat pi=3.141592653589793;\nfloat Z=1.;\nfloat _a=1.;\n\n\n//rotation matricies\nmat3 rotZ(float theta){\n    return mat3(cos(theta) ,sin(theta) ,0.,\n                -sin(theta), cos(theta),0.,\n                0.         ,0.         ,1.);\n}\n\nmat3 rotY(float theta){\n    return mat3(cos(theta),0.,-sin(theta),\n                0.        ,1.,         0.,\n                sin(theta),0., cos(theta));\n}\n\nmat3 rotX(float theta){\n    return mat3(1.,0.         ,0.        ,\n                0.,cos(theta) ,sin(theta),\n                0.,-sin(theta),cos(theta));\n}\n\n//helper functions\nfloat atan2(float y,float x){\n    if(x>0.) return atan(y/x);\n    if(y>=0. && x!=0.) return atan(y/x)+pi;\n    if(x==0.){\n        if(y>0.) return pi/2.;\n        return -pi/2.;\n    }\n    return atan(y/x)-pi;\n}\nfloat map(float t,float a,float b,float c,float d){\n    return c+(d-c)*(t-a)/(b-a);\n}\n\n//cartesian to spherical coordinates\nvec3 spherical(vec3 v){\n    return vec3(length(v),atan(length(v.xy)/v.z),atan2(v.x,v.y));\n}\n\n\n//math for complex numbers\nvec2 cxMult(vec2 a,vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 cxPow(vec2 a,vec2 b){\n    float len=length(a);\n    float theta=b.x*atan2(a.y,a.x);\n    float phi=b.y*log(len);\n    return vec2(cos(theta)*cos(phi)-sin(theta)*sin(phi),\n                cos(theta)*sin(phi)+sin(theta)*cos(phi))\n        \t\t*pow(len,b.x)*exp(-b.y*atan2(a.y,a.x));\n}\nvec2 cxPow(vec2 a,float b){\n    return cxPow(a,vec2(b,0.));\n}\nvec2 conj(vec2 z){\n    return vec2(z.x,-z.y);\n}\nvec2 cxDiv(vec2 a,vec2 b){\n    return cxMult(a,conj(b))/(b.x*b.x+b.y*b.y);\n}\nvec2 cxExp(vec2 a){\n    return exp(a.x)*vec2(cos(a.y),sin(a.y));\n}\n\n//factorial\nint fac(int n){\n    int f=1;\n    for(int i=2;i<=n;i++) f*=i;\n    return f;\n}\n//binomial coeffiecient\nint nCr(int n,int r){\n    return fac(n)/(fac(r)*fac(n-r));\n}\n//generalized binomial coeffiecient\nfloat gen_nCr(float a,int k){\n    float ak=1.;\n    for(int i=0;i<k;i++) ak*=a-float(i);\n    return ak/float(fac(k));\n    //return pow(a,float(k))/float(fac(k));\n}\n\n//laguerre polynomial\nfloat L(float x,int n,int a){\n    float s=0.;\n    for(int i=0;i<=n;i++){\n        s+=pow(-1.,float(i))*float(nCr(n+a,n-i))*pow(x,float(i))/float(fac(i));\n    }\n    return s;\n}\n//legendre polynomial\nfloat P(float x,int m,int l){\n    float scale=pow(-1.,float(m))*pow(2.,float(l))\n    *pow(1.-x*x,float(m)/2.);\n    float s=0.;\n    for(int k=m;k<=l;k++){\n        float ft=float(fac(k))/float(fac(k-m));\n        float ct=gen_nCr(float(l),k)\n                *gen_nCr(float(l+k-1)/2.,l);\n        s+=pow(x,float(k-m))*ct*ft;\n    }\n    return scale*s;\n}\nfloat P2(float x,int m,int l){\n    if(m<0) return P(x,-m,l)*pow(-1.,float(-m))\n                   *float(fac(l+m))/float(fac(l-m));\n    return P(x,m,l);\n}\n\n//the radial component\nfloat R(float r,int n,int l){\n    /*float cube=pow(2.*Z/(float(n)*_a),3.);\n    float facterm=float(fac(n-l-1))/float(2*n*fac(n+l));\n    float sqroot=-sqrt(cube*facterm);\n    float expterm=exp(-Z*r/(float(n)*_a));\n    float lpow=pow(2.*Z*r/(float(n)*_a),float(l));\n    float lagp=L(2.*Z*r/(float(n)*_a),n-l-1,2*l+1);\n    return sqroot*expterm*lpow*lagp;*/\n    float v=2.*Z/(float(n)*_a);\n    float facterm=float(fac(n-l-1))/float(2*n*fac(n+l));\n    float expterm=exp(-Z*r/(float(n)*_a));\n    float lagp=L(v*r,n-l-1,2*l+1);\n    return pow(v,3./2.+float(l))*sqrt(facterm)*lagp\n          *pow(r,float(l))*expterm;\n}\n\n\n\n//spherical harmonics\nvec2 Y(float phi,float theta,int m,int l){\n    \n    float a=(2.*float(l)+1.)/(4.*pi);\n    float facterm=float(fac(l-m))/float(fac(l+m));\n    float sqroot=pow(-1.,float(m))*sqrt(a*float(facterm));\n    vec2 expterm=cxExp(I*float(m)*(phi));\n    float pterm=P2(cos(theta),m,l);\n    \n    return cxMult(vec2(sqroot*pterm,0.),expterm);\n}\n\n//the wave function\nvec2 psi(float r,float theta,float phi,int n,int m,int l){\n    return cxMult(vec2(R(r,n,l),0.),Y(phi,theta,m,l));\n}\n//just a wrapper\nvec2 psi3(vec3 p,ivec3 qn){\n    p=spherical(p);\n    return psi(p.x,p.y,p.z,qn.x,qn.y,qn.z);\n}\n//rendering\nvec2 raytrace(vec3 p,vec3 v,ivec3 qn){\n    vec2 cx=vec2(0.);\n    float mx=0.;\n    int imax=20;\n    float dt=2.*length(p)/float(imax);\n    for(int i=0;i<imax;i++){\n        vec2 wf=psi3(p,qn);\n        /*if(length(wf)>mx){\n            mx=length(wf);\n            cx=wf;\n        }*/\n        cx=max(cx,abs(wf));\n        p+=v*dt;\n    }\n    return abs(cx);\n}\nvec2 cross_section(vec3 p,vec3 v,vec3 n,ivec3 qn,float d){\n    float t=(d-dot(n,p))/dot(n,v);\n    return abs(psi3(p+v*t,qn));\n}\n    \n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    // quantum numbers\n    // 0<n; 0<=l<n; -l<=m<=1;\n    // n:energy; l:angular momentum; m:magnatism\n    int n=5,l=3,m=1;\n    ivec3 qn=ivec3(n,m,l);\n    if(n<=0 || l<0 || l>=n || m<-l || m>l){\n        fragColor=vec4(1.,0.,0.,1.);\n        return;\n    }\n    //controll variables\n    bool cx=true;\n    bool cs=false;\n    \n    //screen space coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv*=2.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //define ray origin and direction vectors\n    vec3 v=vec3(uv.x,uv.y,-1.);\n    v=normalize(v);\n    vec3 p=vec3(0.,0.,pow(2.,3.5)*1.5*float(n));\n    \n    float rate=iTime/2.;\n    \n    //map mouse position to spherical coordinates\n    float theta=map(iMouse.x,0.,iResolution.x,-pi,pi);\n    float phi=map(iMouse.y,0.,iResolution.y,-pi/2.,pi/2.);\n    //rotate rays\n    v=rotY(-theta)*rotX(phi)*v;\n    p=rotY(-theta)*rotX(phi)*p;\n    vec3 planeN=rotY(-theta)*rotX(phi)*vec3(0.,0.,1.);\n    \n    //p=rotY(rate)*p;\n    //v=rotY(rate)*v;\n    \n    \n    int ti=int(mod(iTime,5.));\n    \n    \n    vec2 psipv;\n    if(!cs) psipv=raytrace(p,v,qn);\n    else    psipv=cross_section(p,v,planeN,qn,50.*sin(iTime));\n    vec3 col=vec3(0.,psipv);\n    \n    \n    float mag=length(psipv);\n    float sc=5e2;\n    \n    //\n    //if(length(col)!=length(col)) col=vec3(0.);\n    if(!cx) fragColor = vec4(sc*mag,0.,sc*mag,1.0);\n    else    fragColor = vec4(sc*col.yxz,1.0);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}