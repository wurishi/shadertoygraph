{"ver":"0.1","info":{"id":"wsGyDz","date":"1602582799","viewed":825,"name":"Escape Time Fractals","username":"Miestrode","description":"Escape time fractals, what are they?\nThink about a transformation iterating through,\neach of the coordinates on the screen, such that the new\ninput for the transformation is the transformed coordinate","likes":3,"published":3,"flags":48,"usePreview":0,"tags":["2d","rendering","smooth","coloring","customcomplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Yoav Greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\n// Escape time fractals, what are they?\n// Think about a transformation iterating through,\n// each of the coordinates on the screen, such that the new\n// input for the transformation is the transformed coordinate\n// and then check if that coordinate will converge to infinity.\n\n// P.S: Coordinates on the screen are actually Complex Numbers.\n\n// if it does converge, it isn't a part of the Escape Time Fractal.\n// using this and also storing the iterations we can create an image\n// of some fractal, here are some functions for famous ones:\n\n// The Mandelbrot Set:\n// z.n+1 = z.n^2 + c\n\n// The Multibrot Set:\n// z.n + 1 = z.n^k + c\n\n// The Burning Ship:\n// z.n + 1 = conjugate(|z.n|)^2 + c\n\n// The Leaf Fractal (Discovered by me, independently.):\n// z.n + 1 = conjugate(cart(z.n)^2) + polar(c)\n\n// The Mandelzip (Discovered by me, independently.):\n// z.n + 1 = cartesian(cartesian(z^2)) + cartesian(c)\n\n// The Inverse Bulb (Discovered by me, independently.):\n// z.n + 1 = inverse(cartesian(z^2) + polar(c^2))\n\n// The Unitbrot set (Discovered by Mechanist):\n// z.n + 1 = cPower(z, vec2( 2.0, 0.0 )) + cMultiply(c*0.5,vec2(1.0,0.0)-c*0.5) \n\n// The J Invariant - Mandelbrot duality (Discovered by me, and AlephNull):\n// z.n + 1 = z^2 - ln(c/c+1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = texture(iChannel0, uv);\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Yoav Greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\n// Here the main rendering happens, the \"Big Boy\" of the shader.\n\n// How does it work? \"Relatively simple\". at first, let's\n// iterate our function, which we can define using the library\n// of complex functions I constructed, using tools such as\n// algebraic manipulation. Once we do all that is left to do is coloring.\n\n// there are many methods to do this, what i did was use\n// the \"Smooth Iteration\" method, now of course iterations is counted with\n// Integers, so how could we possibly smooth it? well the short answer is\n// this formula:\n// n -= log(log2(length(z))/log(B))/log(2.0).\n\n// How did we get there is hard to explain in one sentence, but Inigo Quilez\n// made a great article about it:\n//https://iquilezles.org/articles/msetsmooth\n\n//=============================================================================================================\n// defineables\n//=============================================================================================================\n\n// anti-aliasing\n#define AA 4\n\n// constants\n#define pi 3.14159\n#define tau 6.28318\n\n//=============================================================================================================\n// complex functions\n//=============================================================================================================\n\nvec2 cMultiply( vec2 z, vec2 w )\n{ \n\treturn vec2 (z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec2 cMultiply( vec2 z, vec2 w, vec2 x )\n{ \n\treturn cMultiply(cMultiply(z, w), x);\n}\n\nvec2 cDivide( vec2 z, vec2 w )\n{\n\treturn vec2 (z.x*w.x + z.y*w.y, -z.x*w.y + z.y*w.x)/(w.x*w.x + w.y*w.y);\n}\n\n//-------------------------------------------------------------------------------------------------------------\n\nfloat cDis( vec2 z )\n{ \n    return sqrt(z.x*z.x + z.y*z.y);\n}\n\nfloat cArg( vec2 z )\n{\n\tif (z.x > 0.0)\n    { \n        return atan(z.y / z.x); \n    }\n    \n\tif (z.x < 0.0)\n    {\n        \n\t\tif (z.y < 0.0) \n        { \n            return atan(z.y / z.x) - pi;\n    \t}\n\t\treturn atan(z.y / z.x) + pi;\n\t}\n    \n\tif (z.y > 0.0)\n    { \n        return pi/2.0;\n    }\n    \n\tif (z.y < 0.0)\n    {\n        return pi/2.0;\n    }\n    \n\treturn 0.0;\n}\n\nvec2 cPolar( vec2 z )\n{\n    return vec2(cDis(z), cArg(z));\n}\n\nvec2 cCartesian( vec2 z )\n{ \n    return vec2 (cos(z.t), sin(z.t))*z.s;\n}\n\n//-------------------------------------------------------------------------------------------------------------\n\nfloat cReal( vec2 z )\n{ \n    return z.s*cos(z.t);\n}\n\nfloat cImaginary( vec2 z )\n{\n    return z.s*sin(z.t);\n}\n\nvec2 cConjugate( vec2 z )\n{ \n    return vec2 (z.x, -z.y);\n}\n\nvec2 cInverse( vec2 z )\n{\n\treturn vec2 (z.x, -z.y)/(z.x*z.x + z.y*z.y);\n}\n\n//-------------------------------------------------------------------------------------------------------------\n\nvec2 cLog( vec2 z )\n{ \n    return vec2 (log(z.x*z.x + z.y*z.y)/2.0, cArg(z));\n}\n\nvec2 cLog( vec2 b, vec2 z )\n{ \n    return cDivide(cLog(z), cLog(b));\n}\n\nvec2 cLogN( float n, vec2 z )\n{\n    return vec2 (log(z.x*z.x + z.y*z.y)/2.0, cArg(z) + n*tau);\n}\n\nvec2 cLogN( float n, vec2 b, vec2 z )\n{ \n    return cDivide(cLogN(n, z), cLog(b));\n}\n\nvec2 cExp( vec2 z )\n{ \n    return vec2 (cos(z.y), sin(z.y))*exp(z.x);\n}\n\nvec2 cExp( vec2 b, vec2 z )\n{ \n    return cExp(cMultiply(z, cLog(b)));\n}\n\n//-------------------------------------------------------------------------------------------------------------\n\nvec2 cSquare( vec2 z )\n{ \n    return vec2 (z.x*z.x - z.y*z.y, 2.0*z.x*z.y);\n}\n\nvec2 cPower( vec2 z, vec2 w )\n{ \n    return cExp(cMultiply(w, cLog(z)));\n}\n\nvec2 cCube( vec2 z )\n{\n\tfloat p = z.x*z.x;\n\tfloat q = z.y*z.y;\n\treturn vec2 (z.x*(p - 3.0*q), z.y*(3.0*p - q));\n}\n\nvec2 cSqrt( vec2 z )\n{\n\tfloat r = sqrt(z.x*z.x + z.y*z.y);\n\tfloat a = sqrt((r + z.x)/2.0);\n\tfloat b = sqrt((r - z.x)/2.0);\n\tif (z.y < 0.0) { return vec2 (a, -b); }\n\treturn vec2 (a, b);\n}\n\nvec2 cRoot( vec2 w, vec2 z )\n{ \n    return cExp(cDivide(cLog(w), z));\n}\n\nvec2 cRootN( float n, vec2 w, vec2 z )\n{ \n    return cExp(cMultiply(z, cLogN(n, w)));\n}\n\nvec2 cRootNW( float n, vec2 z, vec2 w )\n{ \n    return cExp(cDivide(cLogN(n, w), z));\n}\n\n//=============================================================================================================\n// main functions\n//=============================================================================================================\n\n// edit to your liking:\nvec2 function( in vec2 z, in vec2 c )\n{\n    vec2 zn = cPower( z, vec2( 2.0, 0.0 ) ) - cLog( cDivide( c, c + vec2( 1.0, 0.0 ) ) );\n    \n    return zn;\n}\n//---------------------\n\nfloat render( in vec2 c )\n{\n    const float B = 256.0;\n    float n = 0.0;\n    vec2 z = vec2( 0.0 );\n    \n    for( int i = 0; i < 512; i++ )\n    {\n        z = function( z, c );\n        if( dot( z, z ) > ( B * B ) )\n        {\n            break;\n        }\n        \n        n += 1.0;\n    }\n\n    if( n > 511.0 )\n    {\n       \treturn 0.0;\n    }\n    \n    n = n - log2(log2(dot(z,z))) + 4.0;\n\n    return n;\n}\n\n//=============================================================================================================\n// image\n//=============================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3( 0.0 );\n    \n#if AA > 1\n    for( int m = 0 ; m < AA; m++ )\n    for( int n = 0 ; n < AA; n++ )\n    {\n        vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + vec2( float( m ), float( n ) ) / float( AA ) ) ) / iResolution.y;\n        float w = float( AA * m + n );\n        float time = iTime + 0.5 * ( 1.0 / 24.0 ) * w / float( AA * AA );\n#else    \n        vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n        float time = iTime;\n#endif\n        \n//=============================================================================================================\n// controls\n//=============================================================================================================\n\n\t\tvec2 center_offset = texture( iChannel0, vec2(0.0) ).yx;\n        \n\t\tfloat zoom_offset = texture( iChannel0, vec2(0.0) ).z + 9.5;\n        \n//=============================================================================================================\n// rendering\n//=============================================================================================================\n        \n        float zoo = 1.0 / (zoom_offset * 0.1);\n        \n        float coa = cos( 0.15 * ( 1.0 - zoo ) );\n        float sia = sin( 0.15 * ( 1.0 - zoo ) );\n        zoo = pow( zoo, 20.0 );\n        vec2 xy = vec2( p.x * coa - p.y * sia, p.x * sia + p.y * coa);\n        vec2 c = vec2( -0.0, -0.0 ) + center_offset + xy * zoo;\n        \n        float v = render(c);\n\n        col += 0.5 + 0.5*cos( 3.0 + v*0.15 + vec3(0.0,0.5,1.0));\n#if AA>1\n    }\n    col /= float( AA * AA );\n#endif\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Yoav Greenland - 2020\n\n// This work is licensed under a Creative Commons\n// Attribution-ShareAlike 4.0 International License.\n\n// So, keyboard controls... kind of a tough thing to understand, at least for me.\n// I mean ASCII codes? Really? retriving what, coordinates from an image?! seems,\n// very messy if you ask me, of course I am still new though.\n\n// this part basically gives us the values for what to add to the center.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 center = texture(iChannel0, vec2( 0.0, 0.0 )).xy;\n    float zoom = texture(iChannel0, vec2( 0.0, 0.0 )).z;\n    \n    float center_speed = 0.05;\n    float zoom_speed = 0.05;\n    \n\tfloat zoom_offset = float( \n    \ttexture( iChannel1, vec2( 38.0/256.0, 0.0 ) ).x\n    \t- texture( iChannel1, vec2( 40.0/256.0, 0.0 ) ).x);\n    \n    zoom_offset /= length(zoom_offset) + step( length(zoom_offset), 0.5 );\n    zoom += zoom_offset*zoom_speed;\n    \n    vec2 center_offset = vec2( \n\t\ttexture( iChannel1, vec2( 87.0/256.0, 0.0 ) ).x\n    \t- texture( iChannel1, vec2( 83.0/256.0, 0.0 ) ).x, \n    \ttexture( iChannel1, vec2( 68.0/256.0, 0.0 ) ).x\n    \t- texture( iChannel1, vec2( 65.0/256.0, 0.0 ) ).x);\n    \n    center_offset /= length(center_offset) + step( length(center_offset), 0.5 );\n    center += center_offset*center_speed;\n    \n\n    fragColor = vec4(center, zoom, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}