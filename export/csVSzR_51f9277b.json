{"ver":"0.1","info":{"id":"csVSzR","date":"1680784265","viewed":107,"name":"Synthwave landscape","username":"Kakeutusse","description":"Synthwave landscape","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["synthwave","julespognante"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float PRECISION = 0.001;\nconst float VITESSE   = 50.;\nconst vec3  OFFSET    = vec3(0.,5.,8.);\n\n// fonction de hashage\nfloat hash13(vec3 p) {\n    return fract(sin(dot(p,vec3(12.9898,78.233,45.5432)))*43758.5453123);\n}\n\n// Structure permettant d'avoir des objets ayant leur propre couleur\n// et leur propre id, permettant d'effectuer certaines opérations\n// en fonction de l'id\nstruct Surface{\n    vec3 col;\n    float dist;\n    int id;\n};\n\n// https://iquilezles.org/articles/distfunctions/\nSurface opSmoothUnion( Surface d1, Surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist-d1.dist)/k, 0.0, 1.0 );\n    float dist = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h); \n    d1.dist = dist;\n    return d1;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nSurface sdCappedCylinder( vec3 p, float h, float r )\n{\n  // ajout d'un offset pour que les poteaux soient bien placés\n  p+=OFFSET;\n  \n  // couleur du poteau\n  vec3 col = vec3(.2,.2,.2);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  float dist = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n  return Surface(col, dist, 4);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nSurface sdPyramid( vec3 p, float h)\n{\n  // ajout d'un offset pour que les pyramides soient bien placées\n  p+=OFFSET;\n  float m2 = h*h + 0.25;\n  // couleur par défaut des pyramides\n  vec3 col = vec3(1,0,0);\n  float modPosX = mod(p.x,10.);\n  float modPosZ = mod(p.z,10.);\n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 3.;\n\n  vec3 q = vec3( p.z*10., h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  float dist = sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n  return Surface(col, dist, 3);\n}\n\n// fonction de génération de pyramides\n// basée sur la fonction opRep trouvable sur\n// ajout d'un offset pour que les pyramides soient bien placées\nSurface opRepPyramid( in vec3 p, float h, in float c)\n{\n    // on regarde si p.x est compris entre 5 et -5, si c'est le cas on affiche rien\n    vec3 q = p.x < 5. && p.x > -5.? vec3(0) : vec3(mod(p.x + 0.5 * c, c) - 0.5 * c, p.y, mod(p.z + 0.5 * c, c) - 0.5 * c);\n    return sdPyramid(q, h);\n}\n\n// fonction de génération de poteaux\n// basée sur la fonction opRep trouvable sur\n// ajout d'un offset pour que les pyramides soient bien placées\nSurface opRepCylindre( in vec3 p, float h, float r, in float c)\n{\n    // on regarde si p.x est compris entre 5 et -5 OU si p.x est inférieur à -16 ou supérieur à 16\n    // afin de n'avoir que deux rangées parallèles de poteaux\n    bool canCylindre = (p.x<2. && p.x>-2.) || (p.x>16. || p.x<-16.);\n    vec3 q = canCylindre ? vec3(0) : vec3(mod(p.x*1.5 + 0.5 * c, c) - 0.5 * c, p.y, mod(p.z*.5 + 0.5 * c, c) - 0.5 * c);\n    return sdCappedCylinder(q, h, r);\n}\n\n// fonction de noise\nfloat vnoise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\n    return mix(\n        mix(mix(hash13(p+vec3(0.,0.,0.)),hash13(p+vec3(1.,0.,0.)),f.x),\n        mix(hash13(p+vec3(0.,1.,0.)),hash13(p+vec3(1.,1.,0.)),f.x),f.y),\n        mix(mix(hash13(p+vec3(0.,0.,1.)),hash13(p+vec3(1.,0.,1.)),f.x),\n        mix(hash13(p+vec3(0.,1.,1.)),hash13(p+vec3(1.,1.,1.)),f.x),f.y),f.z);\n}\n\n// lie deux objets en conservant leur couleur\nSurface minWithColor(Surface obj1, Surface obj2){\n  if(obj2.dist < obj1.dist) return obj2;\n  return obj1;\n}\n\n// Fonction de génération d'une sphère\n// https://iquilezles.org/articles/distfunctions/\nSurface sdSphere(vec3 p, float r, vec3 offset )\n{\n  // on multiplie la valeur verte par la valeur y du point pour avoir\n  // un effet de dégradé\n  vec3 col=vec3(0.99, .035*p.y, 0.4);\n  \n  // on soustrait au float généré par la formule de la sphère pour avoir\n  // un effet de déformation aléatoire sur la sphère\n  float dist = length(p-offset)-r - vnoise(p)*2.;\n  return Surface(col, dist, 2);\n}\n\n// Fonction de génération d'un sol\n// https://iquilezles.org/articles/distfunctions/\nSurface sdFloor(vec3 p, float h){\n  vec3 col = vec3(0);\n  float modPosX = mod(p.x,6.);\n  float modPosZ = mod(p.z,6.);\n  // condition sous laquelle on veut tracer des lignes verticales :\n  // si -4<p.x%6<0 OU 0<p.x%6<4\n  bool ligneVerticale = (modPosX>-.4 && modPosX<0.) || (modPosX>0. && modPosX<.4);\n  // condition sous laquelle on veut tracer des lignes horizontales :\n  // si -4<p.z%6<0 OU 0<p.z%6<4\n  bool ligneHorizontale = (modPosZ>-.4 && modPosZ<0.) || (modPosZ>0. && modPosZ<.4);\n  \n  // si p est positionné à l'endroit où tracer une ligne verticale ou horizontale\n  // on change la couleur pour celle désirée pour les lignes\n  if(ligneVerticale || ligneHorizontale){\n      col = vec3(1, 0.21176470588, 0.8);\n  } \n  // sinon on met la couleur du sol par défaut\n  else {\n      col = vec3(0.2, 0., 0.2);    \n  }\n  //p.y -= -hash13(p)*.2;\n  float dist = p.y + h;\n  return Surface(col, dist, 1);\n}\n\n// Fonction qui génère la scène dans sa globalité\nSurface sdScene(vec3 p){\n    Surface sol = sdFloor(p, 5.);\n    // on utilise abs(sin(iTime*2)) pour générer le mouvement des pyramides\n    // en fonction du temps. sin permet d'avoir un mouvement 'sinusoidal' et abs\n    // permet d'éviter les problèmes en cas de valeur négative\n    Surface pyramide = opRepPyramid(p,abs(sin(iTime*2.)), 16.);\n    Surface basePoteau = opRepCylindre(p,14.,.8, 15.);\n    pyramide.col = sol.col;\n    \n    // le offset du soleil à pour valeur z -200.-iTime*VITESSE\n    // pour permettre de l'afficher au loin tout en permettant à la\n    // caméra d'avancer\n    Surface soleil = sdSphere(p, 40., vec3(0.1, 30., -200.-iTime*VITESSE));\n    Surface scene = opSmoothUnion(sol, pyramide, 1.);\n    scene = minWithColor(scene, soleil);\n    scene = minWithColor(scene, basePoteau);\n    return scene;\n}\n\n// Fonction de rayMarching basique\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface d;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = sdScene(p);\n    depth += d.dist;\n    if (d.dist < PRECISION || depth > end) break;\n  }\n  \n  d.dist = depth;\n\n  return d;\n}\n\n// Fonction de calcul de normale basique\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float h = 1.; // height of the floor\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).dist +\n      e.yyx * sdScene(p + e.yyx).dist +\n      e.yxy * sdScene(p + e.yxy).dist +\n      e.xxx * sdScene(p + e.xxx).dist);\n}\n\n// Fonction prise du modèle shadertoy suivant https://www.shadertoy.com/view/lt33z7\n// utile pour générer des lumières utilisant le modèle de réflexion de Phong\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// Fonction prise du modèle shadertoy suivant https://www.shadertoy.com/view/lt33z7\n// utile pour générer des lumières utilisant le modèle de réflexion de Phong\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  \n  // couleur du fond de l'animation\n  vec3 backgroundColor = vec3(0.14, 0.14, 0.2);\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0, -iTime*VITESSE ); // position de la caméra, z=-iTime*VITESSE -> permet de faire avancer la caméra\n  vec3 rd = normalize(vec3(uv, -1)); // direction de la caméra\n  float vitesseZ = -iTime*VITESSE;\n\n  Surface d = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n  \n  if (d.dist> MAX_DIST) {\n    col = backgroundColor; // si on a rencontré aucun point jusqu'à la distance maximale, on affiche la couleur\n                           // choisie pour le fond de l'animation\n  } else {\n    vec3 p = ro + rd * d.dist; // point découvert lors du ray marching\n    vec3 normal = calcNormal(p);\n    vec3 K_a = vec3(0., 0., 0.);  // couleur de la lumière ambiante\n    vec3 K_d = vec3(0.3, 0.2, 0.2); // couleur de la lumière diffuse\n    vec3 K_s = vec3(.5, .1, .0); // couleur spéculaire\n    float shininess = 2000.0;\n\n    if(d.id == 1 || d.id == 3){ // si le point touché appartient au sol (id==1) ou à une pyramide (id==3) alors\n                                // on affiche la réflexion engendrée par le modèle de Phong\n        col = phongIllumination(K_a, K_d, K_s, shininess, p, vec3(0., 1., -300.-iTime*VITESSE))+d.col;\n    } else { // sinon on affiche simplement la couleur du point\n        col = d.col;\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}