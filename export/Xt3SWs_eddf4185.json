{"ver":"0.1","info":{"id":"Xt3SWs","date":"1482021301","viewed":397,"name":"Meltdown","username":"huwb","description":"A day of random hacks. I started with a mandelbrot iteration and broke it enough to give an interesting appearance. I separate out the fractal into layers and add parallax to them individually to give the illusion of depth. ","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["fractal","fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERS 10.0\n\nbool intersectsLayer( vec2 fragCoord, float layer )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 c = (cos(.35*iTime)+20.) * (2.0 * uv - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n\tvec2 z = vec2( -3.5, -1.5 );\n\tfloat escapeRadius = 44.+4.*sin(iTime*.5);\n    \n\tfor (float i = 0.; i < MAX_ITERS; ++i)\n    {\n\t\tvec2 newz = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        z = newz / ( 0.01*dot(newz,z) - 2. ); // added hack, inspired by kaliset\n        \n        // is this the layer we're interested in?\n        if( i + 1. == layer )\n        {\n\t        // check for escape, if so then the pixel has hit this layer.\n            // also, vary escape radius over time to add a little more interest\n            return dot(z,z) > escapeRadius*escapeRadius;\n        }\n \t}\n    \n\treturn false;\n}\n\n// layer colors\nvec3 layerCol( float s )\n{\n    if( s == 10. ) return vec3(1.,.95,.95);\n    if( s == 9. ) return vec3(1.,1.,.2);\n    if( s == 8. ) return vec3(1.,1.,.2);\n    if( s == 7. ) return 1.2*vec3(1.,.75,.2);\n    if( s == 6. ) return vec3(1.,.5,.1);\n    if( s == 5. ) return vec3(1.,.2,0.);\n    if( s == 4. ) return vec3(.7,.0,0.);\n    if( s == 3. ) return vec3(.25,.0,0.);\n    return vec3(.15,.0,0.);\n}\n\nvec3 shade( vec2 fragCoord )\n{\n    // add some depth based on screen position (hack)\n    float zscr = dot(fragCoord/iResolution.xy-.5,fragCoord/iResolution.xy-.5);\n    zscr = .75*(.25-zscr);\n    \n    // process one layer of the fractal at a time so that we can apply different amounts of parallax to each\n    for( float layer = 2.; layer < MAX_ITERS; layer++ )\n    {\n        float parallaxZ = layer-1.; parallaxZ = 4.5*parallaxZ*parallaxZ + zscr;\n        vec2 off = vec2( cos(.33*iTime), sin(.133*iTime)) * 180./parallaxZ;\n        \n        if( intersectsLayer( fragCoord + off, layer ) )\n        {\n            return layerCol(layer);\n        }\n    }\n    // bg\n    return layerCol(10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // crude AA using N-Queens pattern, does the job. some kind of analytical version should be possible and could be cheaper.\n    fragColor.xyz  = shade( fragCoord + vec2(-3./8.,-1./8.) );\n    fragColor.xyz += shade( fragCoord + vec2(-1./8., 3./8.) );\n    fragColor.xyz += shade( fragCoord + vec2( 3./8., 1./8.) );\n    fragColor.xyz += shade( fragCoord + vec2( 1./8.,-3./8.) );\n    fragColor /= 4.;\n}\n","name":"Image","description":"","type":"image"}]}