{"ver":"0.1","info":{"id":"7dyyDt","date":"1655812079","viewed":210,"name":"My Best Ray Marcher","username":"Peace","description":"Marching rays","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["raymarcher","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 col;\n    float linear;\n    float quadratic;\n};\n\nstruct Material\n{\n    vec3 col;\n    float roughness;\n    float metallic;\n};\n\nstruct Object\n{\n    vec3 position;\n    vec3 scale;\n    Material material;\n};\n\nstruct HitInfo\n{\n    vec3 p;\n    vec3 normal;\n    float dist;\n    Object object;\n};\n\nfloat sphereSDF(vec3 p, Object sphere)\n{\n    return length(p - sphere.position) - sphere.scale.x;\n}\n\nfloat cubeSDF(vec3 p, Object cube)\n{\n  return length(max(abs(p - cube.position)-cube.scale,0.0));\n}\n\nvoid getCloser(inout HitInfo hit, in HitInfo hit2)\n{\n    if(hit.dist > hit2.dist)\n        hit = hit2;\n}\n\nHitInfo SDF(vec3 p)\n{\n    HitInfo hit;\n    hit.dist = 1e6f; \n    Object obj;\n    \n    obj = Object(vec3(0, 0, 1), vec3(.5), Material(vec3(1, 1, 1), 0.3, 0.2));\n    getCloser(hit, HitInfo(p, vec3(0), sphereSDF(p, obj), obj));\n    \n    obj = Object(vec3(.5, 0.25, 1.2), vec3(.5), Material(vec3(1, 1, 1), 0.3, 0.2));\n    getCloser(hit, HitInfo(p, vec3(0), sphereSDF(p, obj), obj));\n    \n    obj = Object(vec3(-.5, 0.25, 1.2), vec3(.5), Material(vec3(1, 1, 1), 0.3, 0.2));\n    getCloser(hit, HitInfo(p, vec3(0), sphereSDF(p, obj), obj));\n    \n    return hit;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.002,-0.002);\n    return normalize(e.xxx * SDF(p+e.xxx).dist\n                   + e.xyy * SDF(p+e.xyy).dist\n                   + e.yxy * SDF(p+e.yxy).dist\n                   + e.yyx * SDF(p+e.yyx).dist);\n}\n\nHitInfo raymarch(Ray ray)\n{\n    HitInfo result;\n    result.dist = 0.0f;\n    result.object = Object(vec3(0), vec3(0), Material(vec3(0), 0.0, 0.0));\n    for(int i = 0; i < MAX_STEPS; ++i)\n    {\n        HitInfo hit = SDF(ray.pos + ray.dir * result.dist);\n        result.dist += hit.dist;\n        if(result.dist > MAX_DIST)\n            return result;\n        if(abs(hit.dist) < SURFACE)\n        {\n            result.object = hit.object;\n            result.p = hit.p;\n            result.normal = getNormal(result.p);\n            return result;\n        }\n    }\n    result.dist = 1e7f;\n    return result;\n}\n\nvoid light(inout vec3 Lo, vec3 albedo, vec3 view_dir, vec3 F0, vec3 p, vec3 normal, float roughness, float metallic, Ray ray, Light light)\n{\n    vec3 light_dir = normalize(light.pos - p);\n    vec3 halfway_dir = normalize(view_dir + light_dir);\n    float dist = length(light.pos - p);\n    float attenuation = 1.0 / (1.0 + light.linear * dist + light.quadratic * (dist * dist)); \n    vec3 radiance = light.col * attenuation;\n    \n    float NDF = distributionGGX(normal, halfway_dir, roughness);\n    float G = geometrySmith(normal, view_dir, light_dir, roughness);\n    vec3 F = fresnelSchlick(max(dot(halfway_dir, view_dir), 0.0f), F0);\n   \n    vec3 kS = F;\n    vec3 kD = vec3(1) - kS;\n    kD *= 1.0 - metallic;\n    \n    vec3 numerator = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, view_dir), 0.0) * max(dot(normal, light_dir), 0.0) + 0.0001;\n    \n    vec3 specular = numerator / denominator;\n    float NdotL = max(dot(normal, light_dir), 0.0);\n    Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n}\n\nvoid ambient(inout vec3 Lo, vec3 albedo, vec3 view_dir, vec3 F0, vec3 p, vec3 normal, float roughness)\n{\n\t float ao = 1.0;\n\t float dist = 0.0;\n\t for(int i = 0; i <= AO_ITERATIONS; i++)\n\t {\n\t \tdist += AO_STEP_SIZE;\n\t \tao *= 1.0 - max(0.0, (dist - SDF(p + normal * dist).dist) * AO / dist );                                  \n\t }\n\t ao = max(ao, 0.0);\n     \n     vec3 kS = fresnelSchlickRoughness(max(dot(normal, view_dir), 0.0), F0, roughness);\n     vec3 kD = 1.0 - kS;\n     vec3 irradiance = texture(iChannel2, normal).rgb;\n     vec3 diffuse    = irradiance * albedo;\n     vec3 ambient    = (kD * diffuse) * ao; \n     Lo += ambient;\n}\n\nvec3 getRayDir(vec3 camera_dir, vec2 uv)\n{\n     const float fov = 1. / tan(radians(FOV) / 2.0);\n     vec3 rd = normalize(vec3(uv.x, uv.y, fov) + camera_dir);\n     return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 nuv = (fragCoord -  .5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n\n    Ray camera = Ray(vec3(0.0, 0.0, -1.0), getRayDir(vec3(0, 0, 0), nuv));\n    Light sun = Light(vec3(20, 100, -40), vec3(2), 0.0, 0.0);\n    \n    HitInfo hit = raymarch(camera);\n    if(hit.dist > MAX_DIST)\n        col = texture(iChannel3, camera.dir).rgb;\n    else\n    {\n        Material mat = hit.object.material;\n        vec3 Lo = vec3(0);\n        float roughness = texture(iChannel0, uv).r;\n        float metallic = texture(iChannel1, uv).r;\n        vec3 albedo = mat.col;\n        vec3 F0 = mix(vec3(0.04), albedo, metallic);\n        vec3 view_dir = normalize(camera.pos - hit.p);\n        light(Lo, albedo, view_dir, F0, hit.p, hit.normal, roughness, metallic, camera, sun);\n        ambient(Lo, albedo, view_dir, F0, hit.p, hit.normal, roughness);\n        col = Lo;\n        //col = col / (vec3(1) + col); //HDR\n        col = pow(col, vec3(1.0 / GAMMA));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_DIST 100.0\n#define MAX_STEPS 512\n#define SURFACE 0.0001\n#define FOV 90.0\n\n#define AO .1\n#define AO_ITERATIONS 32\n#define AO_STEP_SIZE 0.007\n\n#define MAX_REFLECTIONS 8\n\n\n#define AIR_IOR 1.01\n#define GLASS_IOR 1.45\n\n#define PI 3.1415926535\n#define GAMMA 2.2\n\n#define SUNLIGHT_COLOR vec3(0.9921568, 0.9843137, 0.8274509)\n\nfloat distributionGGX(vec3 N, vec3 H, float a)\n{\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom        = PI * denom * denom;\n\t\n    return nom / denom;\n}\n\nfloat geometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat geometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = geometrySchlickGGX(NdotV, roughness);\n    float ggx1  = geometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    if(cosTheta > 1.0)cosTheta = 1.0;\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n} \n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}  ","name":"Common","description":"","type":"common"}]}