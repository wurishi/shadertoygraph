{"ver":"0.1","info":{"id":"tdSBzG","date":"1590259833","viewed":175,"name":"Outline 2020 Freestyle Shader","username":"yx","description":"Coded live during a 2-hour freestyle session at Outline Online 2020. Posted here for archival purposes. Comments on how to \"improve\" the code will be deleted.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi acos(-1.)\n\nmat2 rotate(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat tick(float t)\n{\n\tt=fract(t);\n\tt=smoothstep(0.,1.,t);\n\tt=smoothstep(0.,1.,t);\n\treturn t;\n}\n\nvec2 pixelate(vec2 p)\n{\n\tfloat scale = .5;\n\tp*=scale;\n\tvec2 a = floor(p);\n\tvec2 b = fract(p);\n\tb = smoothstep(0.,1.,b);\n\tb = smoothstep(0.,1.,b);\n\tb = smoothstep(0.,1.,b);\n\treturn (a+b)/scale;\n}\n\nfloat scene2d(vec2 p, float t)\n{\t\n\tp.x += sin(iTime-t*.8);\n\tp.y += sin(iTime-t*.2);\n\t\n\t//p = pixelate(p);\n\t\n\tp.x += tick(fract(iTime))*24.;\n\t\n\tvec2 cell = floor((p.xy-12.)/24.);\n\tp.xy = mod(p.xy-12.,24.)-12.;\n\t\n\tp.xy *= rotate(t*.3);\n\t\n\tp.xy = abs(p.xy)-4.;\n\t\n\t\n\tfloat r = 1.+sin(t*5.)*.5;\n\t\n\tfloat d = (length(p.xy)-r);\n\tfloat d2 = max(abs(p.x),abs(p.y))-r;\n\t\n\td=mix(d,d2,sin(iTime));\n\t\n\t/*if (abs(d)<.3)\n\t\td-=texture(texNoise, vec2(t,atan(p.x,p.y)/pi)).r * .3;*/\n\t\n\treturn d;\n}\n\nfloat scene(vec3 p)\n{\n\tfloat speed = 4.;\n\t\n\tfloat s2 = scene2d(p.xz, p.y+iTime*speed);\n\t\n\treturn max(s2, p.y);\n}\n\nvec4 trace(vec3 cam, vec3 dir)\n{\n\tfloat marchspeed = .3;\n\t\n\tfloat t=0.;\n\tfloat k=0.;\n\tfor(int i=0;i<100;++i) {\n\t\tvec3 h = cam+dir*t;\n\t\tk=scene(h)*marchspeed;\n\t\tif(abs(k)<.01)\n\t\t\tbreak;\n\t\tt+=k;\n\t}\n\t\n\tif (abs(k)<.01) {\n\t\tvec3 h=cam+dir*t;\n\t\tvec2 o = vec2(.1,0);\n\t\tvec3 n = normalize(vec3(\n\t\t\tscene(h+o.xyy)-k,\n\t\t\tscene(h+o.yxy)-k,\n\t\t\tscene(h+o.yyx)-k\n\t\t));\n\t\t\n\t\treturn vec4(n*.5+.5,t);\n\t}\n\t\n\treturn vec4(0,0,0,100000);\n\treturn vec4(sin(iTime*4.+vec3(0,2,4))*.05+.05,10000);\n}\n\nfloat sb(float a, float b)\n{\n\treturn mix(a, b, sin(iTime*.2)*.5+.5);\n}\n\nfloat maze(vec2 uv)\n{\n\tvec2 cell = floor(uv);\n\tvec2 pos = fract(uv);\n\t\n\tfloat dir = step(0.,sin(cell.x*cell.y))*2.-1.;\n\t\n\tfloat a = fract(pos.y+pos.x*dir);\n\ta=abs(a-.5);\n\t\n\treturn a-.03;\n}\n\nfloat rate = 2.;\n\t\nfloat sprite()\n{\n\tint arr[]=int[](0xEAE8a5c,0xaa48b50,0xaa48adc,0xaa48a50,0xee4ea5c);\n\tvec2 fc = gl_FragCoord.xy;\n\tfc.y += sin(iTime*rate*3.+fc.x/100.)*50.;\n\tivec2 uv = ivec2(fc/(iResolution.y/28.))-ivec2(12,12);\n\tif (uv.x<0||uv.y<0||uv.y>=5||uv.x>=28)\n\t\treturn 0.;\n\treturn float((arr[4-uv.y]>>(28-uv.x))&1);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n\t\n\t//uv.x = abs(uv.x*2.-1.);\n\t\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\t\n\tif (length(uv.x)>.6) uv-=mod(uv,.005);\n\tif (length(uv.x)>.7) uv-=mod(uv,.01);\n\tif (length(uv.x)>.8) uv-=mod(uv,.02);\n\tif (length(uv.x)>.9) uv-=mod(uv,.04);\n\t\n\t//uv.y += sin(floor(uv.x*100.)*10.)*pow(sin(iTime*.5)*.5+.5,10.)*.01;\n\t\n\tuv *= 1.-dot(uv,uv)*.8;\n\n\t/*if (fract(iTime*rate)<.25)\n\t\tuv.x=abs(uv.x);\n\telse if (fract(iTime*rate)>.75)\n\t\tuv.x=-(uv.x);*/\n\t\n  vec3 cam = vec3(0,0,-25);\n\tvec3 dir = normalize(vec3(uv,1));\n\t\n\tcam.yz *= rotate(pi*sb(0.05,0.25));\n\tdir.yz *= rotate(pi*sb(0.05,0.25));\n\t\n\tcam.xz *= rotate(fract(iTime*.05)*pi);\n\tdir.xz *= rotate(fract(iTime*.05)*pi);\n\t\n\tcam = vec3(0,-10,0);\n\tdir = normalize(vec3(uv.xy,.1).xzy);\n\t\n\tvec4 pixel = trace(cam,dir);\n\t\n\tpixel.rgb *= pow(.97, pixel.w) + .5;\n\t\n\tfor(int i=0;i<10;++i) {\n\t\tfloat fy = -float(i)*1.;\n\t\tfloat t = (cam.y-fy)/-dir.y;\n\t\tif (t > 0. && t < pixel.w)\n\t\t{\n\t\t\tvec3 h = cam+dir*t;\n\t\t\tfloat d = scene(h);\n\t\t\tfloat alpha = tick(tick(sin(d*10.)*.5+.5)) * (1.-smoothstep(0.,1.,d));\n\t\t\tvec3 color = sin(iTime*4.+vec3(0,2,4));\n\t\t\tcolor =vec3(1);\n\t\t\tpixel.rgb = mix(pixel.rgb, color, alpha);\n\t\t}\n\t}\n\t\n\t/*for(int i=0;i<1;++i) {\n\t\tfloat fy = -float(i)*1.;\n\t\tfloat t = (cam.y-fy)/-dir.y;\n\t\tif (t > 0 && t < pixel.w)\n\t\t{\n\t\t\tvec3 h = cam+dir*t;\n\t\t\tvec3 color = sin(iTime*rate*4.+vec3(0,2,4).gbr);\n\t\t\t\n\t\t\tfloat d = maze(h.xz);\n\t\t\t\n\t\t\th=abs(h)-tick(iTime*2.)*2.;\n\t\t\th=abs(fract(h/2.)-.5);\n\t\t\td = min(h.x,h.z);\n\t\t\t\n\t\t\tfloat alpha = 1.-smoothstep(0.,.03,d);\n\t\t\tpixel.rgb = mix(pixel.rgb, color, alpha);\n\t\t}\n\t}*/\n\t\n\tout_color.rgb = 1.-pixel.rgb*2.;\n\t\n\tvec3 overcolor = cos(abs(uv.y)*vec3(6,3,1))*.4+.5;//sin(uv.y*6.+vec3(0,2,4)-tick(iTime)*6)*.5+.5;\n\tout_color.rgb = mix(out_color.rgb, pow(overcolor, out_color.rgb), 1.);\n\t\n\t/*if (mod(iTime*rate,3.)<.5)\n\t\tout_color.rgb = out_color.rrr;*/\n\t\n\tif (sprite() > 0.) {\n\t\tout_color.rgb=1.-out_color.brg*.5;\n\t}\n}","name":"Image","description":"","type":"image"}]}