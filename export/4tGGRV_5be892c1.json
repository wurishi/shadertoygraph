{"ver":"0.1","info":{"id":"4tGGRV","date":"1475457069","viewed":742,"name":"Library","username":"zackpudil","description":"AbsBox fractal with volumetric shadows and edge detection. ","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) {\n    return fract(sin(n)*43578.5453);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat de(vec3 p) {\n    vec4 q = vec4(p, 1);\n\tq.y = mod(q.y + 1.0, 2.0) - 1.0;\n    q.xyz -= 1.0;\n    \n    for(int i = 0; i < 3; i++) {\n        q.xyz = abs(q.xyz + 1.0) - 1.0;\n        q = 1.2*q/clamp(dot(q.xyz, q.xyz), 0.25, 1.0);\n    }\n    \n    float f = box(q.xyz, vec3(1.0))/q.w;\n    f = min(f, p.y + 2.0);\n    f = min(f, min(p.x + 3.0, -p.x + 3.0));\n    f = min(f, min(p.z + 3.0, -p.z + 3.0));\n    \n    return f;\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n    for(int i = 0; i < 80; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.001 || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\n// Approvement thanks to Shane. vstrace= shadow trace in volumentric loop.\n// less detailed, dithering and breaks quicker.\nfloat vstrace(vec3 ro, vec3 rd, float mx) {\n    float t = 0.1*hash(dot(ro, rd));\n    for(int i = 0; i < 50; i++) {\n        float d = de(ro + rd*t);\n        if(d < 0.01 || t >= mx) break;\n        t += d;\n    }\n    \n    if(t < mx) return t;\n    return -1.0;\n}\n\nvec3 normal(vec3 p, out float e) {\n    vec2 h = vec2(0.001, 0.0);\n    \n    vec3 n1 = vec3(\n        de(p + h.xyy),\n        de(p + h.yxy),\n        de(p + h.yyx)\n\t);\n    \n    vec3 n2 = vec3(\n        de(p - h.xyy),\n        de(p - h.yxy),\n        de(p - h.yyx)\n\t);\n    \n    // edge detection.\n    float d = de(p);\n    \n    vec3 e3 = abs(d - 0.5*(n1 + n2));\n    e = min(1.0, pow(e3.x + e3.y + e3.z, 0.55)*10.0);\n    return normalize(n1 - n2);\n}\n\nvec4 texcube(sampler2D s, vec3 p, vec3 n) {\n    vec3 m = pow(n, vec3(30.0));\n    vec4 x = texture(s, p.zy);\n    vec4 y = texture(s, p.xz);\n    vec4 z = texture(s, p.xy);\n    \n    return (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 ro = vec3(-2.9*sin(iTime*0.5), -1, 2.9*cos(iTime*0.5));\n    vec3 ww = normalize(vec3(0, -0.7, 0)-ro);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n    \n    vec3 col = vec3(0);\n    vec3 key = vec3(0, 0.0*sin(iTime*0.3), 0);\n    \n    float t = trace(ro, rd, 10.0);\n    if(t > 0.0) {\n        float edg;\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos, edg);\n        \n        // ambient occlusion.\n        float occ = 0.0, sca = 1.0, ste = 0.003;\n        for(int i = 0; i < 15; i++) {\n            float d = de(pos + nor*ste);\n            occ += (ste - d)*sca;\n            sca *= 1.0;\n            ste += ste/(float(i) + 1.0);\n        }\n        occ = 1.0 - clamp(occ, 0.0, 1.0);\n        \n        vec3 lig = normalize(key - pos);\n        float dis = length(pos - key);\n        \n        // direct lighting with hard shadows.\n        col += 0.3*clamp(dot(lig, nor), 0.0, 1.0)\n            *step(0.0, -trace(pos + nor*0.001, lig, dis));\n        \n        // indirect lighting with ambient occlusion.\n        col += 0.1*clamp(dot(-lig, nor), 0.0, 1.0)*occ;\n        \n        // material.\n        col *= texcube(iChannel0, 0.5*pos, nor).xyz;\n        \n        // edge emission texture           // avoid pixel dancing by fading the effect while the veiwer is farther away.\n        col += mix(col, vec3(0, 0.1, 2.1), edg/(0.7*length(ro)));\n    }\n    \n    // volumetric shadows\n    float s = hash(dot(uv, vec2(12.23, 39.343)))*0.05;\n    float vol = 0.0;\n    // need less light strength the closer you are to the light.\n    float e = 0.1*smoothstep(0.0, 3.5, length(key - ro));\n    for(int i = 0; i < 70; i++) {\n        if(s > t) break;\n        vec3 pos = ro + rd*s;\n        \n        vec3 lig = normalize(key - pos);\n        float dis = length(key - pos);\n        \n        // shadow trace at each position along the march.\n        float l = step(0.0, -vstrace(pos, lig, dis));\n        // light strength is proportional to distance from light.\n        l *= e/dis;\n        \n        vol += l;\n        s += 0.05;\n    }\n    \n    // blue light rays.\n    col += 0.6*vec3(0.5*vol, 0.5*vol, vol);\n    col = pow(col, vec3(1.0/2.2));\n    \n    // vignetting\n    vec2 q = fragCoord/iResolution.xy;\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}