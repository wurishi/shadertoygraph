{"ver":"0.1","info":{"id":"mscyWs","date":"1698691642","viewed":34,"name":"TP_IMAGE_SYNTHESE_AKSOY_ERKAN","username":"Erkan","description":"Tp pour le rendu UE IMAGE partie synthese - Aksoy Erkan","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tpimagesynthese"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Ellipsoid {\n    vec3 c;  // Centre\n    vec3 r;  // Rayons le long des axes x, y, et z\n    int i;   // Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct CylinderBox {\n    vec3 c;  // Centre\n    float h; // Hauteur\n    float r; // Rayon\n    int i;   // Texture Id\n};\n\nstruct Capsule {\n    vec3 a;      // Première extrémité\n    vec3 b;      // Seconde extrémité\n    float r;     // Rayon\n    int i;       // Texture Id\n};\n\nstruct Box {\n    mat4 transform;\n    mat4 inverseTransform;\n    vec3 dimensions;\n    int id;\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 a; // Composante ambiante\n    vec3 d; // Composante diffuse\n    vec3 s; // Composante spéculaire\n    float shininess; // Coefficient de brillance\n    float reflectivity; // réflection\n};\n\nMaterial TextureViolet() {\n    return Material(vec3(0.1, 0.1, 0.1),\n                        vec3(0.6, 0.3, 0.7),\n                        vec3(0.5, 0.5, 0.5),\n                        10.0,\n                        1.0);\n}\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\nfloat Checkers3D(in vec3 p, float size) {\n    vec3 modded = mod(p, size * 2.0); // twice the size because we want both colors in one size unit\n    if((modded.x < size) == (modded.y < size) == (modded.z < size)) {\n        return 1.0; // one color\n    }\n    return 0.0; // another color\n}\n\nMaterial TextureDamier(vec3 p) {\n    float checkerValue = Checkers3D(p, 0.5);\n    if (checkerValue > 0.5) {\n        // Case blanche : diffuse\n        return Material(vec3(0.1, 0.1, 0.1),\n                        vec3(1.0, 1.0, 1.0),\n                        vec3(0.0, 0.0, 0.0),\n                        10.0,\n                        1.0);\n    } else {\n        // Case noire : spéculaire\n        return Material(vec3(0.1, 0.1, 0.1),\n                        vec3(0.0, 0.0, 0.0),\n                        vec3(1.0, 1.0, 1.0),\n                        50.0,\n                        1.0);\n    }\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i == 1){\n        return TextureDamier(p);\n    }\n    else if(i == 2){\n        return TextureViolet();\n    }\n    else if(i == 3) {\n        vec3 axis = vec3(0.0, 1.0, 0.0); // Y-axis\n        float distanceFromAxis = length(p.xy); // distance in the XY plane from Y-axis\n        float lineValue = mod(distanceFromAxis, 0.5); // every 0.5 units, the color changes\n        return Material(vec3(0.1, 0.1, 0.1), \n                mix(vec3(0.0, 1.0, 1.0), vec3(1.0, 0.0, 1.0), lineValue), \n                vec3(0.5, 0.5, 0.5), \n                10.0,\n                1.0); \n\n    }\n    else if(i == 4) {\n        float distanceFromCenter = length(p - vec3(0.0)); \n        float ringValue = mod(distanceFromCenter, 0.5); // every 0.5 units, the color changes\n        return Material(vec3(0.1, 0.1, 0.1),\n                        mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), ringValue),\n                        vec3(0.5, 0.5, 0.5),\n                        10.0,\n                        1.0);\n\n    }\n    else if(i == 5) {\n        float checkerValue = Checkers3D(p, 0.5);\n        return Material(vec3(0.1, 0.1, 0.1),\n                        mix(vec3(.4, .5, .7), vec3(.1, .1, .1), checkerValue),\n                        vec3(0.5, 0.5, 0.5),\n                        10.0,\n                        1.0);\n\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(vec3(0.1, 0.1, 0.1),\n                        col,\n                        vec3(0.5, 0.5, 0.5),\n                        10.0,\n                        1.0);\n\n    }\n    return Material(vec3(0.0),\n                    vec3(0.0),\n                    vec3(0.0), \n                    1.0, \n                    0.0);      \n\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    vec3 oc = ray.o - ellipsoid.c;\n    vec3 invRadii = 1.0 / ellipsoid.r;\n\n    float a = dot(ray.d * invRadii, ray.d);\n    float b = 2.0 * dot(oc * invRadii, ray.d);\n    float c = dot(oc * invRadii, oc) - 1.0;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = (t1 > 0.0) ? t1 : t2;\n\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            vec3 normal = normalize(2.0 * (p - ellipsoid.c) / (ellipsoid.r * ellipsoid.r));\n            x = Hit(t, normal, ellipsoid.i);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool IntersectBox(Ray ray, Box box, out Hit hit)\n{\n    // Convert from ray to box space\n    vec3 rdd = (box.transform * vec4(ray.d, 0.0)).xyz;\n    vec3 roo = (box.transform * vec4(ray.o, 1.0)).xyz;\n\n    // Ray-box intersection in box space\n    vec3 m = 1.0 / rdd;\n    vec3 n = m * roo;\n    vec3 k = abs(m) * box.dimensions;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    // No intersection\n    if (tN > tF || tF < 0.0) return false;\n\n    hit.t = tN; // Assuming nearest intersection is desired\n    hit.n = normalize((box.inverseTransform * vec4(-sign(rdd) * step(vec3(tN), t1), 0.0)).xyz);\n    hit.i = box.id;\n\n    return true;\n}\n\nbool IntersectCapsule(Ray ray, Capsule capsule, out Hit x) {\n    \n    Sphere s1 = Sphere(capsule.a, capsule.r, capsule.i);\n    Sphere s2 = Sphere(capsule.b, capsule.r, capsule.i);\n    \n    Hit hit1;\n    Hit hit2;\n    bool intersectS1 = IntersectSphere(ray, s1, hit1);\n    bool intersectS2 = IntersectSphere(ray, s2, hit2);\n\n    // Intersection avec le cylindre\n    vec3 ba = capsule.b - capsule.a;\n    vec3 oa = ray.o - capsule.a;\n    float a = dot(ray.d, ray.d) - pow(dot(ray.d, ba), 2.0) / dot(ba, ba);\n    float b = 2.0 * (dot(ray.d, oa) - (dot(ray.d, ba) * dot(oa, ba)) / dot(ba, ba));\n    float c = dot(oa, oa) - pow(dot(oa, ba), 2.0) / dot(ba, ba) - capsule.r * capsule.r;\n    \n    float h = b*b - 4.0*a*c;\n\n    if(h >= 0.0) {\n        float t1 = (-b - sqrt(h)) / (2.0*a);\n        float t2 = (-b + sqrt(h)) / (2.0*a);\n\n        float t = (t1 > 0.0) ? t1 : t2;\n\n        vec3 pt = Point(ray, t);\n        vec3 projection = capsule.a + (dot(pt - capsule.a, ba) / dot(ba, ba)) * ba;\n\n        // Vérifier si le point d'intersection est à l'intérieur du segment du cylindre\n        if(t > 0.0 && dot(ba, projection - capsule.a) > 0.0 && dot(-ba, projection - capsule.b) > 0.0) {\n            x = Hit(t, normalize(pt - projection), capsule.i);\n            return true;\n        }\n    }\n\n    if(intersectS1 && (intersectS2 && hit1.t < hit2.t || !intersectS2)) {\n        x = hit1;\n        return true;\n    }\n\n    if(intersectS2) {\n        x = hit2;\n        return true;\n    }\n\n    return false;\n}\n\n\nbool IntersectCylinderBox(Ray ray, CylinderBox box, out Hit x) {\n    float tNear = -1.0e30;\n    float tFar  =  1.0e30;\n    vec3 norm;\n\n    // Test d'intersection avec le côté du cylindre\n    vec2 d = vec2(dot(ray.d, vec3(1,0,0)), dot(ray.d, vec3(0,1,0)));\n    vec2 o = vec2(dot(ray.o - box.c, vec3(1,0,0)), dot(ray.o - box.c, vec3(0,1,0)));\n\n    float a = dot(d, d);\n    float b = 2.0 * dot(d, o);\n    float c = dot(o, o) - box.r * box.r;\n    float delta = b * b - 4.0 * a * c;\n\n    if (delta >= 0.0) {\n        float sqrtDelta = sqrt(delta);\n        float t1 = (-b - sqrtDelta) / (2.0 * a);\n        float t2 = (-b + sqrtDelta) / (2.0 * a);\n\n        float y1 = (ray.o.z + t1 * ray.d.z) - box.c.z;\n        float y2 = (ray.o.z + t2 * ray.d.z) - box.c.z;\n        if ((y1 >= 0.0 && y1 <= box.h) || (y2 >= 0.0 && y2 <= box.h)) {\n            tNear = min(t1, t2);\n            tFar = max(t1, t2);\n            norm = normalize(vec3(o + tNear * d, 0.0));\n        }\n    }\n\n    // Test d'intersection avec les faces circulaires\n    float tTop = (box.c.z + box.h - ray.o.z) / ray.d.z;\n    float tBottom = (box.c.z - ray.o.z) / ray.d.z;\n\n    vec3 topPoint = ray.o + tTop * ray.d;\n    vec3 bottomPoint = ray.o + tBottom * ray.d;\n\n    if (length(topPoint.xy - box.c.xy) <= box.r) {\n        if (tTop > tNear) {\n            tNear = tTop;\n            norm = vec3(0.0, 0.0, 1.0);\n        }\n    }\n\n    if (length(bottomPoint.xy - box.c.xy) <= box.r) {\n        if (tBottom > tNear) {\n            tNear = tBottom;\n            norm = vec3(0.0, 0.0, -1.0);\n        } \n    }\n\n\n    if (tNear < tFar && tNear > 0.0) {\n        x = Hit(tNear, norm, box.i);\n        return true;\n    }\n\n    return false;\n}\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\nRay RotateRay(Ray ray, mat3 rotationMatrix) {\n    ray.o = rotationMatrix * ray.o;\n    ray.d = normalize(rotationMatrix * ray.d);\n    return ray;\n}\n\nRay TranslateRay(Ray ray, vec3 translationVector) {\n    ray.o += translationVector;\n    return ray;\n}\n\nRay ScaleRay(Ray ray, vec3 scale) {\n    ray.o = ray.o / scale;\n    return ray;\n}\n\nRay ScaleRay(Ray ray, float scale) {\n    ray.o = ray.o / scale;\n    return ray;\n}\n\nRay OscillateRay(Ray ray, float amplitude, float frequency, vec3 direction, float time) {\n    // Calculate oscillation offset\n    float offset = amplitude * sin(frequency * time);\n\n    // Apply the oscillation to the ray's origin\n    ray.o += direction * offset;\n\n    return ray;\n}\n\nRay RotateContinuouslyRay(Ray ray, mat3 rotationMatrix, float time) {\n    mat3 timeRotationMatrix = mat3(\n        cos(time), -sin(time), 0,\n        sin(time), cos(time), 0,\n        0, 0, 1\n    );\n    mat3 finalRotationMatrix = rotationMatrix * timeRotationMatrix;\n    ray.o = finalRotationMatrix * ray.o;\n    ray.d = normalize(finalRotationMatrix * ray.d);\n    return ray;\n}\n\nRay ZoomRay(Ray ray, float minScale, float maxScale, float frequency, float time) {\n    float scale = minScale + (maxScale - minScale) * (sin(frequency * time) + 1.0) / 2.0; // Oscillate between minScale and maxScale\n    ray.o *= scale;\n    return ray;\n}\n\nRay CircularMotionRay(Ray ray, vec3 center, float radius, float speed, float time) {\n    float angle = mod(time * speed, 2.0 * 3.14159265);\n    ray.o.x += center.x + radius * cos(angle);\n    ray.o.y += center.y + radius * sin(angle);\n    return ray;\n}\n\nRay BounceRay(Ray ray, vec3 axis, float amplitude, float frequency, float time) {\n    vec3 translation = amplitude * abs(sin(frequency * time)) * normalize(axis);\n    ray.o += translation;\n    return ray;\n}\n\nRay AnimateRay(Ray ray) {\n    // Animation basée sur le temps pour la rotation\n    float rotationSpeed = 0.5; // vitesse de rotation (en radians par seconde)\n    float currentAngle = rotationSpeed * iTime;\n    mat3 rotationMatrixY = mat3(\n        cos(currentAngle), 0, sin(currentAngle),\n        0, 1, 0,\n        -sin(currentAngle), 0, cos(currentAngle)\n    );\n    \n    // Animation basée sur le temps pour la translation (oscillation d'avant en arrière)\n    vec3 oscillationDirection = vec3(1.0, 0.0, 0.0);\n    float oscillationMagnitude = 1.0;\n    vec3 translationVector = oscillationMagnitude * oscillationDirection * sin(0.5 * iTime); // oscille avec une période de 2 * pi / 0.5\n    \n    ray = RotateRay(ray, rotationMatrixY);\n    ray = TranslateRay(ray, translationVector);\n    \n    return ray;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray, out Hit x)\n{\n    const Sphere sph1 = Sphere(vec3(1.5, -1., 1.), 1., 5);\n    const Plane pl = Plane(vec3(0., 0., 1.), vec3(0., 0., 0.), 0);\n    const Ellipsoid ellip = Ellipsoid(vec3(1.5, 1.5, 1.5), vec3(1.0, 1.5, 1.0), 3);\n    //const Ellipsoid ellip = Ellipsoid(vec3(0.0, 0.0, 1.5), vec3(2.0, 1.0, 3.0), 1);\n    const CylinderBox cylBox = CylinderBox(vec3(-2.0, 1.5, 1.5), 3.0, 1.0, 1);\n    const Capsule capsule = Capsule(vec3(-1.0, -2.0, 1.0), vec3(-1.0, -2.0, 5.0), 1.0, 4);\n    \n    const vec3 boxPos = vec3(0., -1., -5.);\n    const mat4 boxMatrix = mat4(\n          1.0, 0.0, 0.0, 0.0,\n          0.0, 1.0, 0.0, 0.0,\n          0.0, 0.0, 1.0, 0.0,\n          boxPos.x, boxPos.z, boxPos.y, 1.0\n    );\n\n    const Box box = Box(boxMatrix, inverse(boxMatrix), vec3(1.0, 1.0, 1.0), 2);\n\n    float time = iTime;\n    \n    float angleInDegrees = 45.0;\n    float angleInRadians = radians(angleInDegrees);\n    \n    // Rotation Matrix\n    mat3 rotationMatrixX = mat3(\n        1, 0, 0,\n        0, cos(angleInRadians), -sin(angleInRadians),\n        0, sin(angleInRadians), cos(angleInRadians)\n    );\n\n    mat3 rotationMatrixY = mat3(\n        cos(angleInRadians), 0, sin(angleInRadians),\n        0, 1, 0,\n        -sin(angleInRadians), 0, cos(angleInRadians)\n    );\n    \n    mat3 rotationMatrixZ = mat3(\n        cos(angleInRadians), -sin(angleInRadians), 0,\n        sin(angleInRadians), cos(angleInRadians), 0,\n        0, 0, 1\n    );\n    \n    // Parameters for continuous rotation\n    Ray rotatedRayX = RotateContinuouslyRay(ray, rotationMatrixX, time);\n    Ray rotatedRayY = RotateContinuouslyRay(ray, rotationMatrixY, time);\n    Ray rotatedRayZ = RotateContinuouslyRay(ray, rotationMatrixZ, time);\n    \n    // Parameters for oscillation\n    float amplitude = 2.0;\n    float frequency = 1.0;\n    vec3 direction = vec3(1.0, 0.0, 0.0); \n    Ray oscilatedRay = OscillateRay(ray, amplitude, frequency, direction, iTime);\n    \n    // Parameters for zoomed ray\n    Ray zoomedRay = ZoomRay(ray, 0.5, 1.5, 2.0, time);\n    \n    // Parameters for circular ray\n    vec3 center = vec3(0.0, 0.0, 0.0); \n    Ray circularRay = CircularMotionRay(ray, center, 2.0, 1.0, time);\n    \n    // Parameters for bouncing ray\n    vec3 bounceAxis = vec3(0.0, 1.0, 0.0); \n    Ray bouncedRay = BounceRay(ray, bounceAxis, 3.0, 2.0, time);\n    \n    // Parameters for normal translation and scale\n    vec3 translationVector = vec3(1.0, 0.0, 0.0);\n    float scaleFactor = 3.0;\n    vec3 scaleVector = vec3(2.0, 2.0, 2.0);\n    \n    x = Hit(1000., vec3(0), -1);\n    Hit current;\n    bool ret = false;\n    \n    \n    if (IntersectPlane(ray, pl, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectBox(rotatedRayZ, box, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectSphere(zoomedRay, sph1, current) && current.t < x.t)\n    {\n        x = current;\n        ret = true;\n        \n    }\n       \n    if (IntersectEllipsoid(circularRay, ellip, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectCylinderBox(oscilatedRay, cylBox, current) && current.t < x.t) {\n        \n        x = current;\n        ret = true;\n    }\n    \n    if(IntersectCapsule(bouncedRay, capsule, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    \n    return ret;\n}\n\nbool InShadow(vec3 pos, vec3 lightDir, float lightDistance) {\n    Ray shadowRay;\n    shadowRay.o = pos + 0.001 * lightDir; // Décalage pour éviter l'auto-intersection\n    shadowRay.d = lightDir;\n    \n    Hit shadowHit;\n    if (Intersect(shadowRay, shadowHit) && shadowHit.t < lightDistance) {\n        return true;\n    }\n    return false;\n}\n\nfloat shadowFactor(vec3 pos, vec3 lightDir, vec3 lightPos) {\n    float lightDistance = distance(pos, lightPos);\n    if (InShadow(pos, lightDir, lightDistance)) {\n        return 0.0; // Point dans l'ombre\n    } else {\n        return 1.0; // Point illuminé\n    }\n}\n\nvec3 phongLighting(vec3 pos, vec3 lightPos, vec3 lightDir, vec3 viewDir, vec3 normal, Material mat) {\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float shadow = shadowFactor(pos, lightDir, lightPos);\n\n    // Ambient\n    vec3 ambient = mat.a;\n\n    // Diffuse\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * mat.d * shadow; // multipliez par le facteur d'ombre\n\n    // Specular\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), mat.shininess);\n    vec3 specular = spec * mat.s * shadow; // multipliez par le facteur d'ombre\n\n    return ambient + diffuse + specular;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// N : Number of samples\nfloat AmbientOcclusion(vec3 p, vec3 n, int N)\n{\n    if(N == 0) { return 1.0; }\n    \n    float ao = 0.0;\n    float rayLength = 1.0;  \n\n    for(int i = 0; i < N; i++)\n    {\n        vec3 d = Hemisphere(i, n);  // Direction dans la demi-sphère\n        Ray ray = Ray(p + 0.01 * n, d);  // Lancer un rayon depuis un léger décalage par rapport au point pour éviter l'auto-intersection\n        Hit hitInfo;\n\n        if(Intersect(ray, hitInfo) && hitInfo.t < rayLength)\n        {\n            // Le rayon est obstrué avant d'atteindre rayLength.\n            ao += 1.0;  // Augmenter le compteur d'occlusion\n        }\n    }\n\n    return 1.0 - (ao / float(N));  // Renvoyer la moyenne des obstructions. Il s'agit de la fraction non occluse.\n}\n\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n)\n{\n    vec3 light=normalize(vec3(1,1,1));\n    \n    float diff=clamp(dot(n,light),0.,1.);\n    vec3 col=m.d*diff+vec3(.2,.2,.2);\n    return col;\n}\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    vec3 accumulatedColor = vec3(0.0);\n    vec3 currentWeight = vec3(1.0);\n\n    for (int i = 0; i < 2; ++i) // Limite à 2 itérations: 1 pour le rayon initial et 1 pour la réflexion\n    {\n        vec3 lightPos = vec3(0.0, -5.0, 10.0);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n        vec3 viewDir = normalize(-ray.d);\n\n        Hit x;\n        bool idx = Intersect(ray, x);\n\n        if (idx)\n        {\n            vec3 p = Point(ray, x.t);\n            Material mat = Texture(p, x.i);\n\n            float aoFactor = AmbientOcclusion(p, x.n, 150);\n            vec3 color = phongLighting(p, lightPos, lightDir, viewDir, x.n, mat);\n            color *= aoFactor;\n\n            // Accumuler la couleur pour cette itération\n            accumulatedColor += currentWeight * color;\n\n            // Mise à jour du poids pour la prochaine itération\n            currentWeight *= mat.reflectivity;\n\n            // Si le matériau n'est pas réfléchissant ou si nous avons atteint notre limite, sortir\n            if (mat.reflectivity == 0.0 || i == 1)\n            {\n                break;\n            }\n\n            // Préparer le rayon pour la prochaine itération (réflexion)\n            vec3 reflectedDir = reflect(ray.d, x.n);\n            ray = Ray(p + 0.001 * reflectedDir, reflectedDir);\n        }\n        else\n        {\n            // Si le rayon n'intersecte rien, ajouter la couleur d'arrière-plan\n            accumulatedColor += currentWeight * Background(ray.d);\n            break;\n        }\n    }\n\n    return accumulatedColor;\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}