{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Basic edge detection via convolution\n// Ken Slade - ken.slade@gmail.com\n// at https://www.shadertoy.com/view/ldsSWr\n\n// Based on original Sobel shader by:\n// Jeroen Baert - jeroen.baert@cs.kuleuven.be (www.forceflow.be)\n// at https://www.shadertoy.com/view/Xdf3Rf\n\n//options are edge, colorEdge, or trueColorEdge\n#define EDGE_FUNC trueColorEdge\n\n//options are KAYYALI_NESW, KAYYALI_SENW, PREWITT, ROBERTSCROSS, SCHARR, or SOBEL\n#define SOBEL\n\n// Use these parameters to fiddle with settings\n#ifdef SCHARR\n#define STEP 0.15\n#else\n#define STEP 1.0\n#endif\n\n\n#ifdef KAYYALI_NESW\nconst mat3 kayyali_NESW = mat3(-6.0, 0.0, 6.0,\n\t\t\t\t\t\t\t   0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t   6.0, 0.0, -6.0);\n#endif\n#ifdef KAYYALI_SENW\nconst mat3 kayyali_SENW = mat3(6.0, 0.0, -6.0,\n\t\t\t\t\t\t\t   0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t   -6.0, 0.0, 6.0);\n#endif\n#ifdef PREWITT\n// Prewitt masks (see http://en.wikipedia.org/wiki/Prewitt_operator)\nconst mat3 prewittKernelX = mat3(-1.0, 0.0, 1.0,\n\t\t\t\t\t\t\t\t -1.0, 0.0, 1.0,\n\t\t\t\t\t\t\t\t -1.0, 0.0, 1.0);\n\nconst mat3 prewittKernelY = mat3(1.0, 1.0, 1.0,\n\t\t\t\t\t\t\t\t 0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t\t -1.0, -1.0, -1.0);\n#endif\n#ifdef ROBERTSCROSS\n// Roberts Cross masks (see http://en.wikipedia.org/wiki/Roberts_cross)\nconst mat3 robertsCrossKernelX = mat3(1.0, 0.0, 0.0,\n\t\t\t\t\t\t\t\t\t  0.0, -1.0, 0.0,\n\t\t\t\t\t\t\t\t\t  0.0, 0.0, 0.0);\nconst mat3 robertsCrossKernelY = mat3(0.0, 1.0, 0.0,\n\t\t\t\t\t\t\t\t\t  -1.0, 0.0, 0.0,\n\t\t\t\t\t\t\t\t\t  0.0, 0.0, 0.0);\n#endif\n#ifdef SCHARR\n// Scharr masks (see http://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators)\nconst mat3 scharrKernelX = mat3(3.0, 10.0, 3.0,\n\t\t\t\t\t\t\t\t0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t\t-3.0, -10.0, -3.0);\n\nconst mat3 scharrKernelY = mat3(3.0, 0.0, -3.0,\n\t\t\t\t\t\t\t\t10.0, 0.0, -10.0,\n\t\t\t\t\t\t\t\t3.0, 0.0, -3.0);\n#endif\n#ifdef SOBEL\n// Sobel masks (see http://en.wikipedia.org/wiki/Sobel_operator)\nconst mat3 sobelKernelX = mat3(1.0, 0.0, -1.0,\n\t\t\t\t\t\t\t   2.0, 0.0, -2.0,\n\t\t\t\t\t\t\t   1.0, 0.0, -1.0);\n\nconst mat3 sobelKernelY = mat3(-1.0, -2.0, -1.0,\n\t\t\t\t\t\t\t   0.0, 0.0, 0.0,\n\t\t\t\t\t\t\t   1.0, 2.0, 1.0);\n#endif\n\n//performs a convolution on an image with the given kernel\nfloat convolve(mat3 kernel, mat3 image) {\n\tfloat result = 0.0;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\tresult += kernel[i][j]*image[i][j];\n\t\t}\n\t}\n\treturn result;\n}\n\n//helper function for colorEdge()\nfloat convolveComponent(mat3 kernelX, mat3 kernelY, mat3 image) {\n\tvec2 result;\n\tresult.x = convolve(kernelX, image);\n\tresult.y = convolve(kernelY, image);\n\treturn clamp(length(result), 0.0, 255.0);\n}\n\n//returns color edges using the separated color components for the measure of intensity\n//for each color component instead of using the same intensity for all three.  This results\n//in false color edges when transitioning from one color to another, but true colors when\n//the transition is from black to color (or color to black).\nvec4 colorEdge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY) {\n\t//get samples around pixel\n\tvec4 colors[9];\n\tcolors[0] = texture(iChannel0,center + vec2(-stepx,stepy));\n\tcolors[1] = texture(iChannel0,center + vec2(0,stepy));\n\tcolors[2] = texture(iChannel0,center + vec2(stepx,stepy));\n\tcolors[3] = texture(iChannel0,center + vec2(-stepx,0));\n\tcolors[4] = texture(iChannel0,center);\n\tcolors[5] = texture(iChannel0,center + vec2(stepx,0));\n\tcolors[6] = texture(iChannel0,center + vec2(-stepx,-stepy));\n\tcolors[7] = texture(iChannel0,center + vec2(0,-stepy));\n\tcolors[8] = texture(iChannel0,center + vec2(stepx,-stepy));\n\t\n\tmat3 imageR, imageG, imageB, imageA;\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 3; j++) {\n\t\t\timageR[i][j] = colors[i*3+j].r;\n\t\t\timageG[i][j] = colors[i*3+j].g;\n\t\t\timageB[i][j] = colors[i*3+j].b;\n\t\t\timageA[i][j] = colors[i*3+j].a;\n\t\t}\n\t}\n\t\n\tvec4 color;\n\tcolor.r = convolveComponent(kernelX, kernelY, imageR);\n\tcolor.g = convolveComponent(kernelX, kernelY, imageG);\n\tcolor.b = convolveComponent(kernelX, kernelY, imageB);\n\tcolor.a = convolveComponent(kernelX, kernelY, imageA);\n\t\n\treturn color;\n}\n\n//finds edges where fragment intensity changes from a higher value to a lower one (or\n//vice versa).\nvec4 edge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY){\n\t// get samples around pixel\n\tmat3 image = mat3(length(texture(iChannel0,center + vec2(-stepx,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(0,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(-stepx,0)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,0)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(-stepx,-stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(0,-stepy)).rgb),\n\t\t\t\t\t  length(texture(iChannel0,center + vec2(stepx,-stepy)).rgb));\n \tvec2 result;\n\tresult.x = convolve(kernelX, image);\n\tresult.y = convolve(kernelY, image);\n\t\n    float color = clamp(length(result), 0.0, 255.0);\n    return vec4(color);\n}\n\n//Colors edges using the actual color for the fragment at this location\nvec4 trueColorEdge(float stepx, float stepy, vec2 center, mat3 kernelX, mat3 kernelY) {\n\tvec4 edgeVal = edge(stepx, stepy, center, kernelX, kernelY);\n\treturn edgeVal * texture(iChannel0,center);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv.xy);\n#ifdef KAYYALI_NESW\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tkayyali_NESW, kayyali_NESW);\n#endif\n#ifdef KAYYALI_SENW\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tkayyali_SENW, kayyali_SENW);\n#endif\n#ifdef PREWITT\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tprewittKernelX, prewittKernelY);\n#endif\n#ifdef ROBERTSCROSS\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\trobertsCrossKernelX, robertsCrossKernelY);\n#endif\n#ifdef SOBEL\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tsobelKernelX, sobelKernelY);\n#endif\n#ifdef SCHARR\n\tfragColor = EDGE_FUNC(STEP/iResolution[0], STEP/iResolution[1],\n\t\t\t\t\t\t\tuv,\n\t\t\t\t\t\t\tscharrKernelX, scharrKernelY);\n#endif\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldsSWr","date":"1399528987","viewed":2163,"name":"edgedetect","username":"slade","description":"Detects edges, either black and white or in color.  Includes a few different kernels to try out.","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["sobel","edge","roberts","cross","detect","kayyali","prewitt","scharr"],"hasliked":0,"parentid":"","parentname":""}}