{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define time iTime\n#define resolution iResolution.xy\n\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec2 uv ){\n    vec3 x = vec3(uv, 0);\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    \n    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat2 m = mat2(0.8,0.6,-0.6,0.8);\n\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p*=m*2.02;\n    f += 0.2500*noise( p ); p*=m*2.03;\n    f += 0.1250*noise( p ); p*=m*2.01;\n    f += 0.0625*noise( p );\n    f /= 0.9375;\n    return f;\n}\n\nvec3 voronoi( in vec2 x )\n{\n    ivec2 p = ivec2(floor( x ));\n    vec2 f = fract(x);\n\n    ivec2 mb = ivec2(0);\n    vec2 mr = vec2(0.0);\n    vec2 mg = vec2(0.0);\n\n    float md = 8.0;\n    for(int j=-1; j<=1; ++j)\n    for(int i=-1; i<=1; ++i)\n    {\n        ivec2 b = ivec2( i, j );\n        vec2  r = vec2( b ) + noise( vec2(p + b) ) - f;\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = vec2(noise( vec2(p) + g ));\n        float d = length(r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    md = 8.0;\n    for(int j=-2; j<=2; ++j)\n    for(int i=-2; i<=2; ++i)\n    {\n        ivec2 b = ivec2( i, j );\n        vec2 r = vec2( b ) + noise( vec2(p + b) ) - f;\n\n\n        if( length(r-mr)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( md, mr );\n}\n\nvec2 tr(vec2 p)\n{\n \tp = -1.0+2.0*(p/resolution.xy);\n    p.x *= resolution.x/resolution.y;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float map_radius = mod(600.0 - 250.0 * (time*0.05),600.0);\n\tvec2 focus = vec2(map_radius,0.0);\n\tfloat crack_radius = 50.0;\n\n\tfloat radius = max(1e-20,map_radius);\n\tvec2 fc = fragCoord.xy + focus - resolution/2.0;\n\tvec2 p = tr(fc);\n\n\tvec3 col = \tvec3(0.0);\n\n\tvec3 lava = vec3(0.0);\n\tvec3 ground = vec3(0.5,0.3,0.1);\n\tfloat vor = 0.0;\n\tfloat len = length(fc) + cos(fbm(p*15.0)*15.0)*15.0;\n    float crack = smoothstep(radius-crack_radius,radius,len);\n\n\t{\n\t\tfloat val = 1.0 + cos(p.x*p.y + fbm(p*5.0) * 20.0 + time*2.0)/ 2.0;\n\t\tlava = vec3(val*1.0, val*0.33, val*0.1);\n\t\tlava = mix(lava*0.95,lava,len-radius);\n\t\tlava *= exp(-1.8);\n\t}\n\n\t{\n\t\tfloat val = 1.0 + sin(fbm(p * 7.5) * 8.0) / 2.0;\n\t\tground *= exp(-val*0.3);\n\t\tvec3 sand = vec3(0.2,0.25,0.0);\n\t\tground = mix(ground,sand,val*0.1);\n\t}\n\n\t{   \n\t\tvor = voronoi(p*3.5).x*(1.0-crack)*0.75;\n\t\tvor = 1.0-vor;\n\t\tvor *= smoothstep(0.0,radius,len);\n\t}\n\n\tcol = mix(ground,lava,crack);\n\tcol = mix(col,lava,smoothstep(radius-crack_radius,radius,vor*radius));\n\n\tfragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xtf3WB","date":"1424645266","viewed":1286,"name":"effusing lava","username":"nexor","description":"I tried to create a cracks as the lava covers the ground, but couldn't figure out how to control voronoi to look like it.\nHash, noise, fbm and voronoi functions are all taken from iq's tutorial.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","lava"],"hasliked":0,"parentid":"","parentname":""}}