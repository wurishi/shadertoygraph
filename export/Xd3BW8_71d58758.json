{"ver":"0.1","info":{"id":"Xd3BW8","date":"1524805941","viewed":292,"name":"Stochastic Routing","username":"rory618","description":"Here is a bare bones implementation with explanation of the stochastic routing idea I have used in a few shaders.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["stochastic","routing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 uv = i/R.xy;\n    o = vec4(0);\n    \n    for(int j = 0; j < 10; j++){//Rendering pass is just the last layer pass\n        \n        vec4 r = hash44(vec4(F,i,j));\n        r.zw = randn(r.zw);\n        float id;\n        \n        //Split the screen into four groups, and sample from different layers of the\n        //process. This is to make it clear what the effect of each layer is.\n        if(uv.x>.5){\n            if(uv.y>.5){\n       \t \t\tid = texture(iChannel1,(i+r.zw)/R.xy).x;\n            } else {\n                id = texture(iChannel1,(i+r.zw)/R.xy).y;\n            }\n        } else {\n            if(uv.y>.5){\n                id = texture(iChannel1,(i+r.zw)/R.xy).w;\n            } else {\n                id = texture(iChannel1,(i+r.zw)/R.xy).z;\n            } \n        }\n\n            \n        if(id >= 0.){\n            vec2 t = getParticle(id,R);\n\t\t\t//draw particles by signed distance function\n            //It is very convinient that everything is still done by distance function\n            //so far. In fact \n            //#define length(x) abs(20.-length(x)) \n            //in common will convert this shader to drawing circles instead.\n            //this time just use all 10 iterations for the output\n        \tfloat d = length(i-t*R.xy);\n            d = clamp(1.-d,0.,1.);\n            o += vec4(1)*d;\n            \n            //Hold space to render every data point as its distance from the location\n            //to the point it represents. This reveals the voroni structure that \n            //materializes out of the randomness\n            if( texelFetch( iChannel3, ivec2(32,0), 0 ).x>.5) \n \t\t       \to = exp(-vec4(length(t*R.xy-i)/30.));\n        }\n        \n                    \n        //Mark one of the particles, and draw red no matter where the particle is in\n        //relation to the pixel. This is to highlight how any one particle gets drawn,\n        //it starts of as a random uniform scattering of labels, which in latter layers\n        //converge into a tighter distribution.\n        if(floor(id)==mod(floor(iTime/5.),particles)){\n            \n            o+= vec4(1,-1e8,-1e8,0);//-1e8 hack to make the red cover any white\n         }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F iFrame\n\nfloat particles = 1e3;\n\n    \nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//Convert uniform random to normal\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(r.x));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n//This function defines the location of each particle. In other shaders I have used\n//A buffer instead, which is good for storing particles that are acting more complex.\n//But this is fastest.\nvec2 getParticle(float id, vec3 R){\n    vec4 r = hash44(vec4(0,0,0,id));\n    return .5+(randn(r.zw)*R.y/4.)/R.xy;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\nThe idea behind stochastic routing is to route information to all relevant \ndestinations by passing everything through a series of layers, taking a stochastic\npath, such that the information gets closer and closer to the destination over \neach layer. For graphics, the destination is one of the pixels rendered in image,\nand the information is the parameters of an obect to be drawn. In this example, a \npoint is stored as a vec2 and rendered as a gaussian.\n\nEach layer of computation, stored in channels x,y,z,w of this buffer, randomly\nsamples 10 points stored in the previous layer. Only the one closest to the fragCoord\nis saved, this satisfies that information gets closer to the destination over \neach layer. This is why normal distributions with shrinking sigma over the layers \nis used.\n\nAn id tag is passed through the channel output, which enables using one buffer to\nget a lot of passes in by pipelining through xyzw. Even more than 4 passes would be \npossible by using only 16 bits or so to store the tag to get twice the passes.\n\nNear the latter layers, the id tags become closer in fragCoord space to the pixels \nthat the associeted particles will be affected, so the final rendering pass only needs\nto scan a few nearby locations in order to find every relevant particle.\n\n\n*/\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(-1);\n    \n    \n    //Set the current best distance to infinity ish\n    float d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = floor(r.x * particles)+.5;\n        vec2 t = getParticle(id,R);//Uniformly sample one of the particles\n\n        float dp = length(i-t*R.xy);\n        //compute the length to see if it is closer than the current champion\n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.x = id;//Output the nearest points ID\n        }\n    }\n    //Repeat for each getParticle->x->y->z->w\n    d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        //Sample using a shrinking normal distribution\n        float id = texture(iChannel1,(i+randn(r.zw)*27.)/R.xy).x;\n        vec2 t = getParticle(id,R);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.y = id;\n        }\n    }\n    \n    d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*9.)/R.xy).y;\n        vec2 t = getParticle(id,R);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.z = id;\n        }\n    }\n    d=1e9;\n    \n    for(int j = 0; j < 10; j++){\n        vec4 r = hash44(vec4(j,F,i));\n        float id = texture(iChannel1,(i+randn(r.zw)*3.)/R.xy).z;\n        vec2 t = getParticle(id,R);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.w = id;\n        }\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"}]}