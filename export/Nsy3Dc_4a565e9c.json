{"ver":"0.1","info":{"id":"Nsy3Dc","date":"1634072282","viewed":113,"name":"M2 ModélisationGéométrique Blob","username":"Daedalus_SebDal","description":"TP Blob M2 MG","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n// Main\n\nconst int Steps = 200;\nconst float Epsilon = .05;// Marching epsilon\nconst float T =.5;\nconst float lipschit = 0.001;\n\n// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rA = 2.2;\nconst float rB = 100.;\n\n//1:trace   2:traceSphere   3:stepOver\n#define INTERSECT 3\n\n// 1: SDF \n#define TYPE_MODEL 1\n\n// 1: water drop\n// 2: hatsune miku (https://m.media-amazon.com/images/I/517fKX-nC-L._AC_SY741_.jpg)\n#define OBJECT 2\n\n// Animation \nconst float speedAnime = 5.5;\n\n\n\n\n\n\n\nconst float m_PI = 3.14159265359;\nconst float m_2PI = 2.0 * m_PI;\nconst float m_PI2 = m_PI/2.0;\nconst float m_PI4 = m_PI/4.0;\nconst float m_PI6 = m_PI/6.0;\nconst float m_PI8 = m_PI/8.0;\nconst float m_PI16 = m_PI/16.0;\nconst float m_PI24 = m_PI/24.0;\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n// Common\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed) * 43758.5453);\n}\n\n\n// Cosine direction\nvec3 Cosine(in float seed,  in vec3 nor)\n{\n  float u = Hash(78.233 + seed);\n  float v = Hash(10.873 + seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a = m_2PI * v;\n  u = 2. * u - 1.;\n  return normalize(nor + vec3(sqrt(1. - u * u) * vec2(cos(a), sin(a)), u));\n}\n\n\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n    float sa = sin(a);  float ca = cos(a);\n    return mat3(\n         ca, sa, 0.,\n        -sa, ca, 0.,\n         0., 0., 1.\n    );\n}\n\nmat3 rotate_x(float a)\n{\n    float sa = sin(a);  float ca = cos(a);\n    return mat3(\n        1., 0.,  0.,\n        0., ca, -sa,\n        0., sa,  ca\n    );\n}\n\nmat3 rotate_y(float a)\n{\n    float sa = sin(a);  float ca = cos(a);\n    return mat3(\n         ca, 0., sa,\n         0., 1., 0.,\n        -sa, 0., ca\n    );\n}\n\n\n\nmat3 CameraRotation( vec2 m )\n{\n    m.y = -m.y;\n    \n    vec2 s = sin(m);\n    vec2 c = cos(m);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, c.y, s.y, 0.0, -s.y, c.y);\n    mat3 rotY = mat3(c.x, 0.0, -s.x, 0.0, 1.0, 0.0, s.x, 0.0, c.x);\n    \n    return rotY + rotX;\n}\n\n\n\nvec2 scale(vec2 p, float sc){\n  return p* (1.0/sc);\n}\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,  in vec2 p,  out vec3 ro,  out vec3 rd)\n{\n  float a = 3. * m_PI * m.x;\n  float le = 3.8;\n  \n  ro  = vec3(40., 0., 5.);\n  ro *=  rotate_z(3.*m_PI*m.x);\n  //ro *= rotate_y(1. * m_PI * m.y);\n\n  p = scale(p, clamp((m.y/iResolution.y)*1000.+ 0.8, 0.2, 2.));\n\n\n  vec3 ta = vec3(0., 0., 1.);\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0., 0., 1.)));\n  vec3 vv = normalize(cross(uu, ww));\n  rd = normalize(p.x * uu + p.y * vv + le*ww);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\nstruct Result{\n  float valeur;\n  vec3 color;\n};\n\n// Transforms\nvec3 rotateX(vec3 p,  float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(\n      p.x, \n      ca * p.y - sa * p.z,\n      sa * p.y + ca * p.z\n  );\n}\n\n\n\n\n\nvec3 rotateY(vec3 p,  float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(\n      ca * p.x + sa * p.z,\n      p.y, \n      -sa * p.x + ca * p.z\n  );\n}\n\n\n\n\n\nvec3 rotateZ(vec3 p,  float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(\n      ca * p.x + sa * p.y,\n      -sa * p.x + ca * p.y,\n      p.z\n  );\n}\n\n\n\n\n\n\nvec3 rotation(vec3 p , vec3 angles){\n  return rotateX(rotateY(rotateZ(p,angles.z),angles.y),angles.x);\n}\n\n\n\n\n\nvec3 translation(vec3 p, vec3 trans){\n  return p+trans;\n}\n\n\n\n\nvec3 scale(vec3 p, float sc){\n  return p* (1.0/sc);\n}\n\n\n\n\nvec3 opElongate(in vec3 p, in vec3 h ){\n    return  p - clamp( p, -h, h ) ;\n}\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x,  float R)\n{\n  float u = clamp(x / R, 0., 1.);\n  float v = (1. - u * u);\n  return v * v * v;\n}\n\n\nhighp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n// Primitives\n// https://iquilezles.org/articles/distfunctions\n\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nResult blob_point(vec3 p,  vec3 c,  float e,  float R, vec3 color)\n{\n  return Result(\n    e * falloff(length(p - c), R), \n    color\n  );\n}\nResult sdf_point( vec3 p,  vec3 c, float s , vec3 color)\n{\n  return Result(\n    length(p-c) - s,\n    color\n  );\n}\nResult sdf_point( vec3 p, float s , vec3 color)\n{\n  return Result(\n    length(p) - s,\n    color\n  );\n}\n\n\n/**\n * Créer une cylindre avec des bords arrondie.\n *\n * vec3 p: point d'origine\n * vec3 a: point de dépard du cylindre\n * vec3 b: point d'arriver du cylindre\n * float r: rayon d'arrondicement des bords du cylindre \n * vec3 color: couleur de l'objet\n*/\nResult blob_line(vec3 p,  vec3 a, vec3 b,  float e,  float R, vec3 color)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  \n  return Result(\n    e * falloff(length(pa - ba*h ), R),\n    color\n  );\n}\nResult sdf_line( vec3 p, vec3 a, vec3 b, float r , vec3 color)\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return Result(\n    length( pa - ba*h ) - r,\n    color\n  );\n}\n\n\n/**\n  * Créer un cylindre vertical avec des bords arrondie.\n  *\n  * vec3 p: point d'origine\n  * vec3 a: point de dépard du cylindre\n  * float verticalH: hauteur du cylindre\n  * float r: rayon d'arrondicement des bords du cylindre \n  * vec3 color: couleur de l'objet\n*/\nResult blob_lineVertical(vec3 p,  vec3 a, float verticalH,  float e,  float R, vec3 color)\n{\n  vec3 b = vec3(a.x,a.y ,a.z- verticalH);\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\n  return Result(\n    e * falloff(length(pa - ba*h ), R),\n    color\n  );\n}\nResult sdf_lineVertical( vec3 p, vec3 a, float verticalH, float r, vec3 color)\n{\n  vec3 b = vec3(a.x, a.y, a.z- verticalH);\n  return sdf_line(p, a, b, r, color);\n}\n\n\n\n/**\n  * Créer un boite avec des bords arrondie.\n  *\n  * vec3 p: point d'origine\n  * vec3 b: taille de la boite\n  * float r: rayon d'arrondisement\n  * vec3 color: couleur de l'objet\n  */\nResult blob_RoundBox( vec3 p, vec3 box,  float e, float R , vec3 color)\n{\n  vec3 q = abs(p) - box;\n  return Result(\n     e * falloff(length(max(q, 0.0)) + min(max(q.x,max(q.y, q.z)), 0.0) , R),\n    color\n  );\n}\nResult sdf_RoundBox( vec3 p, vec3 b, float r , vec3 color)\n{\n  vec3 q = abs(p) - b;\n  return Result(\n    length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r,\n    color\n  );\n}\n\n\n\n/**\n  * Créer une boite.\n  *\n  * vec3 p: point d'origine de l'objet\n  * vec3 b: taille de la boite\n  * vec3 color: couleur de l'objet\n  */\nResult blob_Box( vec3 p, vec3 b, float e, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  return Result(\n    e * falloff(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), 0.0),\n    color\n  );\n}\nResult sdf_Box( vec3 p, vec3 b , vec3 color)\n{\n  vec3 q = abs(p) - b;\n  return Result(\n    length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),\n    color\n  );\n}\n\n\n\n/**\n  * Créer un donut.\n  *\n  * vec3 p: point d'origine de l'objet\n  * vec2 t: largeur du donut, épaisseur du donut\n  * vec3 color: couleur de l'objet\n*/\nResult blob_Torus( vec3 p, vec2 t ,float e, float R , vec3 color)\n{\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return Result(\n    e * falloff(length(q - t.y), R),\n    color\n  );\n}\nResult sdf_Torus( vec3 p, vec2 t, vec3 color )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Result(\n    length(q)-t.y,\n    color\n  );\n}\n\n\n\n\n/**\n  * Créer un plan plein d'un coté\n  *\n  * vec3 p: point d'origine de l'objet\n  * float h: Hauteur du plan\n  * vec3 color:  couleur de l'objet\n*/\nResult blob_plane(vec3 p, float h , vec3 color){\n  return Result(\n    p.z - h,\n    color\n  );\n}\nResult sdf_plane(vec3 p, float h , vec3 color){\n  return Result(\n    p.z + h,\n    color\n  );\n}\n\n\n\n/**\n  * Créer un cone avec la pointe coupée.\n  *\n  * vec3 p: point d'origine de l'objet\n  * vec3 a: point de départ du cone\n  * vec3 b: point d'arrivé\n  * float ra: rayon du point de départ\n  * float rb: rayon du point d'arrivé\n  * vec3 color: couleur de l'objet\n*/\nResult sdf_CappedCone( vec3 p, vec3 a, vec3 b, float ra, float rb, vec3 color)\n{\n  float rba  = rb-ra;\n  float baba = dot(b-a,b-a);\n  float papa = dot(p-a,p-a);\n  float paba = dot(p-a,b-a)/baba;\n  float x = sqrt( papa - paba*paba*baba );\n  float cax = max(0.0,x-((paba<0.5)?ra:rb));\n  float cay = abs(paba-0.5)-0.5;\n  float k = rba*rba + baba;\n  float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n  float cbx = x-ra - f*rba;\n  float cby = paba - f;\n  float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n\n  return Result(\n    s*sqrt( min(cax*cax + cay*cay*baba, cbx*cbx + cby*cby*baba) ),\n    color\n  );\n}\n\n\n/**\n  * Créer un cylindre.\n  *\n  * vec3 p: point d'origine de l'objet\n  * float h: hauteur du cylindre\n  * float r: rayon du cylindre\n  * vec3 color: couleur de l'objet\n*/\nResult sdf_CappedCylinder( vec3 p, float h, float r ,vec3 color)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return Result(\n    min(max(d.x,d.y),0.0) + length(max(d,0.0)),\n    color\n  );\n}\n\n\n/**\n  * Créer une cylindre avec des bords arrondie.\n  *\n  * vec3 p: point d'origine de l'objet\n  * float ra: rayon du cylindre\n  * float rb: rayon du cylindre\n  * float h: hauteur du cylindre\n  * vec3 color: couleur de l'objet\n*/\nResult sdf_RoundedCylinder( vec3 p, float ra, float rb, float h ,vec3 color)\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return Result(\n    min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb,\n    color\n  );\n}\n\n/**\n  * Créer un angle solide.\n  *\n  * vec3 p: point d'origine de l'objet\n  * vec2 c: \n  * float ra: \n  * vec3 color: couleur de l'objet\n*/\nResult sdf_SolidAngle(vec3 p, vec2 c, float ra, vec3 color)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return Result(\n    max(l,m*sign(c.y*q.x-c.x*q.y)),\n    color\n  );\n}\n\n\n/**\n  * Créer un cadre de boite.\n  *\n  * vec3 p: point d'origine de l'objet\n  * vec3 b: Taille de la boite\n  * float e: taille du cadre\n  * vec3 color: couleur de l'objet\n*/\nResult sdf_BoxFrame( vec3 p, vec3 b, float e , vec3 color)\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return Result(\n    min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0)),\n      color\n  );\n}\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n// Operators\n\nResult sdf_Union(Result a,  Result b)\n{\n  return Result(\n    min(a.valeur, b.valeur), \n    (a.valeur<b.valeur)?a.color:b.color\n  );\n}\nResult sdf_Inter(Result a,  Result b)\n{\n  return Result(\n    max(a.valeur, b.valeur), \n    (a.valeur>b.valeur)?a.color:b.color\n  );\n}\n\nvec2 opRepLim(in vec2 p, in float c, in vec2 l)\n{\n    return p-c*clamp(round(p/c),-l, l);\n}\n\n\n// Blending\n// a,b : field function of the sub-trees\nResult blob_Blend(Result a,  Result b)\n{\n  return Result(\n    a.valeur + b.valeur, \n    (a.valeur*a.color +b.valeur*b.color)/(a.valeur + b.valeur)\n  );\n}\nResult sdf_Blend(Result a,  Result b, float k)\n{\n  float h = clamp( 0.5 + 0.5*(b.valeur-a.valeur)/k, 0.0, 1.0 );\n\n  return Result(\n    mix( b.valeur, a.valeur, h ) - k*h*(1.0-h), \n    (b.valeur*a.color + a.valeur*b.color)/(a.valeur + b.valeur)\n  );\n}\n\n\n\n\nResult blob_sub(Result a,  Result b)\n{\n  return Result(\n    a.valeur - b.valeur, \n    (a.valeur*a.color +b.valeur*b.color)/(a.valeur - b.valeur)\n  );\n}\nResult sdf_sub(Result a,  Result b)\n{\n  a.valeur = -a.valeur;\n  return sdf_Inter(a, b);\n}\n\n\n\nResult sdf_subSmooth(Result a,  Result b, float k ) {\n    float h = clamp( 0.5 - 0.5*(b.valeur+a.valeur)/k, 0.0, 1.0 );\n    return Result(\n      mix( b.valeur, -a.valeur, h ) + k*h*(1.0-h),\n      (b.valeur*a.color + a.valeur*b.color)/(a.valeur - b.valeur)\n    ); \n}\n\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n// Parties des models \n\nResult cheveux(vec3 p, vec3 color){\n  Result hhh = sdf_Torus(\n    translation(p, vec3(-2., 0., 10.)),\n    vec2(9.3, 0.7),\n    color\n  );\n\n  hhh = sdf_sub(\n    sdf_plane(\n      rotateY(\n      translation(p, vec3(8., 0., 15.1)),\n      m_PI2+m_PI16\n      ),\n      5.,\n      color\n    ),\n    hhh\n  );\n  return hhh;\n}\nResult cheveux2(vec3 p, vec3 color){\n  Result hhh = sdf_Torus(\n    translation(p, vec3(-2., 0., 10.)),\n    vec2(1.6, 0.3),\n    color\n  );\n\n hhh = sdf_sub(\n    sdf_plane(\n      rotateY(\n      translation(p, vec3(3., 0., 15.1)),\n      m_PI2+m_PI16\n      ),\n      5.,\n      color\n    ),\n    hhh\n  );\n  return hhh;\n}\n\n\n\n\n\nResult noeud(vec3 p, vec3 b, float e , vec3 colorA, vec3 colorB){\n  Result box = sdf_Box(p,b-e,colorA);\n  box = sdf_Union(\n    box,\n    sdf_BoxFrame(\n      p,b,e,colorB\n    )\n  );\n  return box;\n}\n\n\n\n\n\nconst vec3 gColor = vec3(0.0, 0.6667, 1.0);\nconst vec3 g2Color = vec3(0.0, 0.4157, 1.0);\nResult goutte(vec3 p, vec3 translate, float TSim, float startT){\n  p=translation(p, translate);\n  \n  float stTsim = startT+iTime*speedAnime;\n  float stEndT = TSim+startT;\n  \n  float anim = mod(stTsim, stEndT);\n  \n  Result g = sdf_point(\n      translation(\n        p, \n        -vec3(0.0, 0.0, 8.*anim - 20.)\n      ), \n      vec3(0.0, 0.0, 0.0),\n      8., \n      gColor\n    );\n\n  Result c = sdf_Torus(\n      rotateX(\n        translation(\n          p, \n          -vec3(5., 5., ((anim < 1.0)? 6.: 2.))\n        ) + 5., \n        m_PI2\n      ),\n      vec2(7. * (anim-2.), 2.0),\n      gColor\n  );\n  \n  \n\n  return sdf_Blend(g, c, 5.5);\n}\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n// Potential field of the object\n// p : point\n\n\nvec3 g1 = vec3(0., 0., 0.);\nvec3 g2 = vec3(2., 2., 0.);\nvec3 g3 = vec3(16.,-5.,0.);\nvec3 g4 = vec3(-9.,-10.,0.);\nvec3 g5 = vec3(-16., 10., 0.);\n\nResult Object(vec3 p)\n{\n  p.z = -p.z - 8.5;\n  p.y = p.y - 0.;\n  \n#if OBJECT ==1\n  float TSim = 10.;\n  Result v = sdf_RoundBox(\n    -p, \n    vec3(100.0, 100.0, 0.0), \n    4.,\n    vec3(0.0118, 0.1647, 0.3686)\n  );\n \n  v= sdf_Blend( \n    v, \n    goutte(p, g1, TSim, 2.) \n    ,0.5\n  );\n  v= sdf_Blend( \n    v, \n    goutte(p, g2, TSim, 0.) \n    ,0.5\n  );\n  v= sdf_Blend( \n    v, \n    goutte(p, g3, TSim, 4.) \n    ,0.5\n  );\n  v= sdf_Blend( \n    v, \n    goutte(p, g4, TSim, 8.) \n    ,0.5\n  );\n  v= sdf_Blend( \n    v, \n    goutte(\n      scale(p, 1.2), \n      g5, \n      TSim, \n      9.\n    ),\n    0.5\n  );\n\n\n\n\n#elif OBJECT==2//=====================================================================================================\n  p = rotateZ(p, m_PI);\n\n  vec3 lightBlue = vec3(0.0196, 0.6235, 1.0);\n  vec3 black = vec3(0.);\n  vec3 skincolor = vec3(0.96, 0.82, 0.74);\n  vec3 gray = vec3(0.5451, 0.5451, 0.5451);\n  vec3 eye =vec3(0.302, 0.4745, 0.4);\n  vec3 centerEye = vec3(0.5686, 0.3647, 0.3647);\n  vec3 bouche = vec3(0.902, 0.4, 0.4);\n\n  vec3 red = vec3(1.,0.,0.);\n\n  Result Plateau = sdf_CappedCylinder(\n    rotateX(p, m_PI/2.), \n    5., \n    0.5, \n    vec3(0.8,0.8,0.8)\n  );\n\n /* pd: base pied droit */\n  Result pd = sdf_CappedCylinder(\n    opElongate(\n      translation(\n        rotateY(rotateX(p, m_PI2), m_PI4),\n        vec3(2., -.55, -1.)\n      ), vec3(.0, .0, .2)\n    ), \n    0.4, \n    0.05, \n    lightBlue\n  );\n  /* pg: base pied gauche */\n  Result pg = sdf_CappedCylinder(\n    opElongate(\n      translation(\n     \n        rotateX(p, m_PI2),\n        vec3(-2.2, -0.55, 0.2)\n      ),vec3(0.0, 0.0, 0.2)\n    ), \n    0.4, \n    0.05, \n    lightBlue\n  );\n /* pd2: dessus pied droit */\n  Result pd2 = sdf_line(\n    translation(\n      rotateY(rotateX(p, m_PI2), m_PI4),\n      vec3(2., -.55, -1.)\n    ), \n    vec3(0.1, 0.3, 0.3),\n   vec3(0.1, 0.4, -0.3), \n    0.3, \n    black\n  );\n  /* pg2: dessus pied gauche */\n  Result pg2 = sdf_line(\n    translation(\n      p,\n      vec3(-2.2, -0.55, 0.9)\n    ),\n    vec3(0., -0.35, 0.0),\n    vec3(0., -0.95, 0.0), \n    0.3, \n    black\n  );\n\n/* lld1: partie 1 du bas de la jambe droite */\n  Result lld1 = sdf_lineVertical(\n    translation(p, -vec3(2.1, 0., -1.)), \n    vec3(0., 0., -0.3), \n    2., \n    0.5, \n    black\n  );\n  /* lld2: partie 2 du bas de la jambe droite */\n  Result lld2 = sdf_line(\n    translation(p, -vec3(2.1, 0., -1.)), \n    vec3(0., 0., -0.3), \n    -vec3(0.4, .4, 3.2), \n    0.5, \n    black\n  );\n\n/* llg1: partie 1 du bas de la jambe gauche */\n  Result llg1 = sdf_lineVertical(\n    translation(p, -vec3(-2.2, -0.55, -1.)), \n    vec3(0., 0., -0.3), \n    2., \n    0.5, \n    black\n  );\n  /* llg2: partie 2 du bas de la jambe gauche */\n  Result llg2 = sdf_line(\n    translation(p, -vec3(-2.2, -0.55, -1.)), \n    vec3(0., 0., -.3), \n    -vec3(-0.6, .6, 3.2), \n    0.5, \n    black\n  );\n\n  /* lld :  bas de la jambe droite */\n  Result lld = sdf_Blend(lld1, lld2, .5);\n  /* llg :  bas de la jambe gauche */\n  Result llg = sdf_Blend(llg1, llg2, .5);\n\n/* uld1: partie 1 du haut de la jambe droite */\n Result uld1 = sdf_line(\n    translation(p, -vec3(-1.5, -1.05, -4.5)), \n    vec3(0., 0., 0.5), \n    -vec3(-0., .0, 1.2), \n    0.6, \n    black\n  );\n  /* uld2: partie 2 du haut de la jambe droite */\n  Result uld2 = sdf_Torus(\n    rotateX(translation(p, -vec3(-1.5, -1.05, -5.7)) ,m_PI2),\n    vec2(.6,.1),\n    lightBlue\n  );\n  /* uld3: partie 3 du haut de la jambe droite */\n  Result uld3 = sdf_line(\n    translation(p,  -vec3(-1.5, -1.05, -5.7)), \n    vec3(0., 0., 0.), \n    -vec3(-0., -0.5, 2.), \n    0.6, \n    skincolor\n  );\n\n  /* uld2: haut de la jambe droite */\n  Result uld = sdf_Union(sdf_Union(uld1, uld3), uld2);\n\n/*Result llg2 = sdf_line(\n    translation(p, -vec3(-2.2, -0.55, -1.)), \n    vec3(0., 0., 0.), \n    -vec3(-0.6, .4, 3.2), \n    0.4, \n    black\n  );*/\n\n  /* ulg1: partie 1 du haut de la jambe gauche */\n  Result ulg1 = sdf_line(\n    translation(p, -vec3(1.7, -0.4, -4.2)), \n    vec3(0., 0., 0.), \n    -vec3(-0., .0, 1.2), \n    0.6, \n    black\n  );\n  /* ulg2: partie 2 du haut de la jambe gauche */\n  Result ulg2 = sdf_Torus(\n    rotateX(translation(p, -vec3(1.7, -0.4, -5.7)) ,m_PI2),\n    vec2(.6,.1),\n    lightBlue\n  );\n  /* ulg3: partie 3 du haut de la jambe gauche */\n  Result ulg3 = sdf_line(\n    translation(p,  -vec3(1.7, -0.4, -5.7)), \n    vec3(0., 0., 0.), \n    -vec3(0.5, 0.1, 2.), \n    0.6, \n    skincolor\n  );\n\n/* ulg: haut de la jambe gauche */\n  Result ulg = sdf_Union(sdf_Union(ulg1, ulg3), ulg2);\n  //ulg = ulg1;\n  //uld = uld1;\n // lld=lld2;\n\n/* v: Object global */\n  Result v = sdf_Union(\n    Plateau\n    ,\n    sdf_Union(\n      sdf_Union(\n        pg\n        , \n        sdf_Blend(\n          pg\n          , \n          sdf_Blend(\n            pg2\n            ,\n            sdf_Blend(\n              llg\n              ,\n              ulg\n              ,\n              0.5\n            )\n            ,\n            0.5\n          )\n          , \n          0.5\n        )\n      )\n      ,\n      sdf_Union(\n        pd\n        , \n        sdf_Blend(\n          pd\n          , \n          sdf_Blend(\n            pd2\n            ,\n             sdf_Blend(\n              lld\n              ,\n              uld\n              ,\n              0.5\n            )\n            ,\n            0.5\n          )\n          , \n          0.5\n        )\n      )\n    )\n  );\n// end lower part\n\n/* jj: bas de la jupe*/\nResult jj = sdf_RoundedCylinder(\n  rotateX(translation(p, vec3(0.,0.5,7.2)), m_PI2),\n  1.3,\n  .1,\n  0.05,\n  lightBlue\n);\n\n/* jj2: torse*/\n\n// bas jupe\nResult jj2 = sdf_CappedCone(\n  rotateX(translation(p, vec3(0.,0.5,7.2)), m_PI2),\n  vec3(0.),\n  vec3(0.,2.5,0.0),\n  2.5,\n  1.0,\n  black\n);\n\n// torse partie 1\njj2=sdf_Blend(\n  jj2,\n  sdf_CappedCone(\n    rotateX(translation(p, vec3(0.,0.5,10.2)), m_PI2),\n  vec3(0.),\n    vec3(0.,3.0,0.0),\n    0.8,\n    1.0,\n    gray\n  )\n  ,\n  1.0\n);\n\n// torse partie 2\njj2=sdf_Blend(\n  jj2,\n  sdf_CappedCone(\n    rotateX(translation(p, vec3(0.,.5,12.9)), m_PI2),\n    vec3(0.),\n    vec3(0.,1.5,0.0),\n    1.0,\n    0.6,\n    gray\n  )\n  ,\n  1.5\n);\n\n\n\n\n// épaules\njj2=sdf_Blend(\n  jj2,\n    sdf_line(\n      translation(p, vec3(1.5, 1.5, 13.7)),\n      vec3(0.0),\n      vec3(3.0,2.0,0.),\n      0.4,\n      skincolor\n    ),\n  0.5\n);\n\n\n\n// bras droit\njj2=sdf_Blend(\n  jj2,\n  sdf_line(\n      translation(p, vec3(1.5, 1.5, 13.7)),\n      vec3(0.0),\n      vec3(-1.5,.0,5.),\n      0.4,\n      skincolor\n  ),\n  0.3\n);\n\njj2=sdf_Union(\n  jj2,\n  sdf_CappedCone(\n      translation(p, vec3(1.5, 1.5, 13.7)),\n      vec3(-0.3,0.0,1.0 ),\n      vec3(-1.1,.0,4.5),\n      0.4,\n      1.0,\n      black\n  )\n);\njj2 = sdf_Union(\n  jj2,\n  sdf_Torus(\n    rotateZ(\n    rotateX(\n      translation(p, vec3(1.75, 1.5, 12.7)),\n      m_PI2\n    ),\n    -m_PI8 +0.2\n    ),\n    vec2(0.4,.1),\n    lightBlue\n  )\n);\njj2 = sdf_Union(\n  jj2,\n  sdf_Torus(\n    rotateZ(\n    rotateX(\n      translation(p, vec3(2.6, 1.5, 9.2)),\n      m_PI2\n    ),\n    -m_PI8 +0.2\n    ),\n    vec2(1.0,.1),\n    lightBlue\n  )\n);\n\n\n\n\n// bras gauche\njj2=sdf_Blend(\n  jj2,\n  sdf_line(\n      translation(p, vec3(-1.5, -0.5, 13.7)),\n      vec3(0.0),\n      vec3(1.5,.0,5.),\n      0.4,\n      skincolor\n  ),\n  0.3\n);\n\njj2=sdf_Union(\n  jj2,\n  sdf_CappedCone(\n      translation(p, vec3(-1.5, -0.5, 13.7)),\n      vec3(0.3,.0,1.0),\n      vec3(1.1,.0,4.5),\n      0.4,\n      1.0,\n      black\n  )\n);\njj2 = sdf_Union(\n  jj2,\n  sdf_Torus(\n    rotateZ(\n    rotateX(\n      translation(p, vec3(-1.8, -0.5, 12.7)),\n      m_PI2\n    ),\n    m_PI8 -0.2\n    ),\n    vec2(0.4,.1),\n    lightBlue\n  )\n);\njj2 = sdf_Union(\n  jj2,\n  sdf_Torus(\n    rotateZ(\n    rotateX(\n      translation(p, vec3(-2.6, -0.5, 9.2)),\n      m_PI2\n    ),\n    m_PI8 -0.2\n    ),\n    vec2(1.0,.1),\n    lightBlue\n  )\n);\n\n\n\n\n\n\n\nv = sdf_Union(\n  v,\n  sdf_Union(\n    jj, jj2\n  )\n);\n\n\n\n\n/* head: Tête */\nResult head = sdf_point(\n  opElongate(\n    rotateZ(\n      translation(p, vec3(0.,0.5,16.4)),\n      m_PI4\n    ),\n    vec3(.15,0.0,.35)\n  ),\n  vec3(0.,0.,0.),\n  1.5,\n  skincolor\n);\nhead = sdf_Union(\n  head,\n  sdf_lineVertical(\n    translation(p, vec3(0.,0.5,16.2)),\n    vec3(0.),\n    -2.0,\n    0.4,\n    skincolor\n  )\n);\n\n// eye droit\nhead =sdf_subSmooth(\n  sdf_point(\n      translation(p, vec3(0.2,2.2,16.2)),\n    vec3(0.,0.,0.),\n    .5,\n    vec3(0.)\n  ),\n  head,\n  0.3\n);\nhead = sdf_Union(\n  sdf_SolidAngle(\n    rotateZ(\n    translation(p, vec3(0.1,1.5,16.1)),\n     m_PI\n    ),\n    vec2(2.,2.),\n    .7,\n    vec3(0.8)\n  ),\n  head\n);\nhead = sdf_Union(\n  sdf_SolidAngle(\n    rotateZ(\n    translation(p, vec3(0.05,1.68,16.1)),\n     m_PI\n    ),\n    vec2(2.,2.),\n    .58,\n    eye\n  ),\n  head\n);\nhead = sdf_Union(\n  sdf_SolidAngle(\n    rotateZ(\n    translation(p, vec3(-0.05,2.05,16.1)),\n     m_PI\n    ),\n    vec2(2.,2.),\n    .28,\n    centerEye\n  ),\n  head\n);\n\n\n\n\n\n// eye gauche\nhead = sdf_subSmooth(\n  sdf_point(\n  translation(p, vec3(-1.2,1.7,16.2)),\n    vec3(0.,0.,0.),\n    .5,\n    vec3(0.)\n  ),\n  head,\n  0.3\n);\nhead = sdf_Union(\n  sdf_SolidAngle(\n    rotateZ(\n    translation(p, vec3(-0.7,1.1,16.1)),\n     m_PI+m_PI4\n    ),\n    vec2(2.,2.),\n    .7,\n    vec3(0.8)\n  ),\n  head\n);\nhead = sdf_Union(\n  sdf_SolidAngle(\n    rotateZ(\n    translation(p, vec3(-0.78,1.28,16.1)),\n     m_PI+m_PI4\n    ),\n    vec2(2.,2.),\n    .58,\n    eye\n  ),\n  head\n);\nhead = sdf_Union(\n  sdf_SolidAngle(\n    rotateZ(\n    translation(p, vec3(-0.88,1.68,16.1)),\n     m_PI+m_PI4\n    ),\n    vec2(2.,2.),\n    .28,\n    centerEye\n  ),\n  head\n);\n\n\n\n\n/* mmm: Bouche */\nResult mmm = sdf_RoundedCylinder(\n  rotateZ(\n    translation(p, vec3(-0.3,1.45,15.2)),\n    m_PI8\n  ),\n  0.25,\n  0.4,\n  0.1,\n  bouche\n);\nmmm = sdf_sub(\n  sdf_plane(\n    translation(p, vec3(-0.3, 1.45, 15.1)),\n    0.1,\n    bouche\n  ),\n  mmm\n);\n\n\nhead = sdf_sub(\n  mmm,\n  head\n);\n\n\n\n\n/* hhh: Partie Principal des cheveux */\nResult hhh = cheveux(p, lightBlue);\nhhh = sdf_Union(\n  hhh,\n  cheveux(rotateZ(p, m_PI24) , lightBlue)\n);\nhhh = sdf_Union(\n  hhh,\n  cheveux(rotateZ(p, -m_PI24) , lightBlue)\n);\n\nhhh = sdf_Union(\n  hhh,\n  cheveux(rotateZ(translation(p,vec3(0.5,0.3,0.0)),m_PI+m_PI4) , lightBlue)\n);\nhhh = sdf_Union(\n  hhh,\n  cheveux(rotateZ(translation(p,vec3(0.5,0.3,0.0)),m_PI+m_PI4+m_PI24) , lightBlue)\n);\nhhh = sdf_Union(\n  hhh,\n  cheveux(rotateZ(translation(p,vec3(0.5,0.3,0.0)),m_PI+m_PI4-m_PI24) , lightBlue)\n);\nhhh = sdf_Blend(\n  hhh,\n  sdf_point(\n    translation(p, vec3(0.15,0.15,17.2)),\n    vec3(0.),\n    1.8,\n    lightBlue\n  ),\n  0.5\n);\nhhh = sdf_Blend(\n  hhh,\n  sdf_line(\n    translation(p, vec3(0.15,0.15,16.7)),\n    vec3(0.),\n    vec3(1.6,1.6,-1.0),\n    .7,\n    lightBlue\n  ),\n  0.5\n);\n\nhhh = sdf_Blend(\n  hhh,\n  sdf_line(\n    translation(p, vec3(0.15,0.15,16.7)),\n    vec3(0.),\n    vec3(-1.6,0.,-1.0),\n    .7,\n    lightBlue\n  ),\n  0.5\n);\n\n/* nnn: Noeud dans les cheveux */\nResult nnn = noeud(\n  rotation(\n    translation(p, vec3(2.0,0.0,17.9)),\n    vec3(m_PI4,m_PI8,-m_PI16)\n  ),\n  vec3(0.3,1.3,1.3),\n  0.08,\n  red,\n  black\n);\nnnn = sdf_Union(\n  nnn,\n  noeud(\n    rotation(\n      translation(p, vec3(-1.2,-1.25,17.9)),\n      vec3(m_PI4,-m_PI8,m_PI4-m_PI16)\n    ),\n    vec3(0.3,1.3,1.3),\n    0.08,\n    red,\n    black\n  )\n);\n\n\n\n/* shhh: petits cheveux */\nResult shhh=cheveux2(\n  rotateZ(\n    rotateY(\n    translation(p,vec3(4.2,1.5,7.0)),\n    m_PI16\n    ),\n    m_PI16\n  ) , \n  lightBlue\n);\nshhh = sdf_Union(\n  shhh,\n  cheveux2(\n    rotateZ(\n      rotateY(\n      translation(p,vec3(4.2,1.,7.0)),\n      m_PI16\n      ),\n      -m_PI16\n    ) , \n    lightBlue\n  )\n);\nshhh = sdf_Union(\n  shhh,\n  cheveux2(\n    rotateZ(\n      rotateY(\n      translation(p,vec3(-4.2,0.,7.0)),\n      -m_PI16\n      ),\n      m_PI+m_PI8\n    ) , \n    lightBlue\n  )\n);\nshhh = sdf_Union(\n  shhh,\n  cheveux2(\n    rotation(\n      translation(p,vec3(-3.7,4.9,8.8)),\n      vec3(-m_PI16, m_PI8,m_PI2+m_PI8)\n    ) , \n    lightBlue\n  )\n);\n\n\n\n\nhead = sdf_Union(\n  head,\n  sdf_Union(\n    sdf_Union(\n      hhh,\n      shhh\n    ),\n    nnn\n  )\n);\n\n//v = Result(10e40, vec3(0.));\nv=sdf_Union(\n  v,\n  head\n);\n\n#endif\n  return Result(v.valeur /*- T*/, v.color);\n}\n\n\n\n\n\n\n\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\nstruct ResultNormal{\n  vec3 normal;\n  vec3 color; \n};\n// Calculate object normal\n// p : point\nResultNormal ObjectNormal(in vec3 p)\n{\n  float eps =.0001;\n  vec3 n;\n  Result v = Object(p);\n  n.x = Object(vec3(p.x + eps, p.y, p.z)).valeur - v.valeur;\n  n.y = Object(vec3(p.x, p.y + eps, p.z)).valeur - v.valeur;\n  n.z = Object(vec3(p.x, p.y, p.z + eps)).valeur - v.valeur;\n  return ResultNormal(\n    normalize(n), \n    v.color\n  );\n}\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o,  vec3 u,  float rB,  out bool h,  out int s)\n{\n  h = false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n  for(s = 0; s < Steps; s++)\n  {\n    vec3 p = o + t * u;\n    float v = Object(p).valeur;\n    // Hit object\n    if(v < lipschit)\n    {\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += Epsilon;\n    // Escape marched far away\n    if(t > rB)\n    {\n      break;\n    }\n  }\n\n  return t;\n}\n\n\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,  vec3 u,  float rB,  out bool h,  out int s)\n{\n  h = false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t = rA;\n  for(s = 0; s < Steps; s++)\n  {\n    vec3 p = o + t * u;\n    float v = Object(p).valeur;\n    // Hit object\n    if(v < lipschit)\n    {\n      h = true;\n      break;\n    }\n    // Move along ray\n    t += max(Epsilon, abs(v) / 4.);\n    // Escape marched far away\n    if(t > rB)\n    {\n      break;\n    }\n  }\n\n  return t;\n}\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n\nfloat SphereTraceOverStep(vec3 o,  vec3 u,  float rB,  out bool h,  out int s)\n{\n  float omega = 1.2;\n  float t = rA;\n\n  float candidate_error = 1e10;\n  float candidate_t = rA;\n\n  float rayon_preced = 0.0;\n  float stepLength = 0.0;\n\n  float fonction_Signe = Object(o).valeur < 0.0 ? -1.0 : 1.0;\n\n  float rayon_signee, rayon, error;\n  bool depassement;\n\n  for (s = 0; s < Steps; ++s) {\n    rayon_signee = fonction_Signe * Object(o + t * u).valeur;\n    rayon = abs(rayon_signee);\n\n    // a t'on dépasser?\n    depassement = omega > 1.0 && (rayon + rayon_preced) < stepLength;\n\n    if (depassement) {\n      // retoure arriere\n      stepLength -= omega * stepLength;\n      omega -= 0.2;\n      //t += stepLength;\n      //break;\n\n    } else {\n      // on avance\n      stepLength = rayon_signee * omega;\n    }\n\n    rayon_preced = rayon;\n    error = rayon / t;\n\n    if (!depassement && error < candidate_error) {\n      candidate_t = t;\n      candidate_error = error;\n    }\n\n    if (!depassement && error < lipschit || t > rB)\n      break;\n\n    t += stepLength;\n  }\n\n\n  if (t > rB || candidate_error > lipschit) \n    return 1E10;\n\n  h = true; // on a atteint l'objectif\n  return candidate_t;\n}\n\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,  vec3 n,  int a)\n{\n  if(a == 0){return 1.;}\n  \n  float ao = 0.;\n  \n  for(int i = 0; i < a; i++)\n  {\n    vec3 d = Cosine(581.123*float(i), n);\n    \n    int s;\n    bool h;\n\n#if INTERSECT == 1\n  float t = Trace(p, d, 10., h, s);\n#elif INTERSECT == 2\n  float t = SphereTrace(p, d, 10., h, s);\n#elif INTERSECT == 3\n  float t = SphereTraceOverStep(p, d, 10., h, s);\n#endif\n\n\n    if(!h){ao += 1.;}\n    else if(t > 5.)\n    {\n      ao += 1.;\n    }\n  }\n  \n  ao /= float(a);\n  return ao;\n}\n\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(.652, .451, .995), vec3(.552, .897, .995), rd.z*.5 + .5);\n}\n\nfloat Light(vec3 p,  vec3 n)\n{\n  // point light\n  const vec3 lp = vec3(5., 10., 25.);\n  \n  vec3 l = normalize(lp - p);\n  \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = pow(.5*(1. + dot(n, l)), 2.);\n  \n  bool h;\n  int s;\n\n#if INTERSECT == 1\n  float t = Trace(p + .1*n, l, 100., h, s);\n#elif INTERSECT == 2\n  float t = SphereTrace(p + .1*n, l, 100., h, s);\n#elif INTERSECT == 3\n  float t = SphereTraceOverStep(p + .1*n, l, 100., h, s);\n#endif\n\n  if(!h)\n  {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,  vec3 n,  int a)\n{\n  if(a == 0)\n  return 1.;\n  \n  // point light\n  const vec3 lp = vec3(5., 10., 25.);\n  \n  vec3 l = normalize(lp - p);\n  \n  float lo = 0.;\n  \n  for(int i = 0; i < a; i++)\n  {\n    vec3 d = Cosine(581.123*float(i), n);\n    d = normalize(l + d*.15);\n    int s;\n    bool h;\n\n#if INTERSECT == 1\n  float t = Trace(p, d, 10., h, s);\n#elif INTERSECT == 2\n  float t = SphereTrace(p, d, 10., h, s);\n#elif INTERSECT == 3\n  float t = SphereTraceOverStep(p, d, 10., h, s);\n#endif\n\n    if(!h){lo += 1.;}\n    else if(t > 100.)\n    {\n      lo += 1.;\n    }\n  }\n  \n  lo /= float(a);\n  return lo;\n  \n}\n\n\n\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,  vec3 n)\n{\n  vec3 c = .25 + .25*background(n);\n  c += .15*AmbientOcclusion(p + .1*n, n, 0)*vec3(1., 1., 1.);\n  c += .35*Light(p, n);\n  return c;\n}\n\n\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t = float(n)/(float(Steps - 1));\n  return .5 + mix(vec3(.05, .05, .5), vec3(.65, .39, .65), t);\n}\n\n\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,  out bool pip)\n{\n  // Pixel coordinates\n  vec2 p = (-iResolution.xy + 2.*pixel)/iResolution.y;\n  if(pip == true)\n  {\n    const float fraction = 1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x < iResolution.x*fraction) && (pixel.y < iResolution.y*fraction))\n    {\n      p = (-iResolution.xy*fraction + 2.*pixel)/(iResolution.y*fraction);\n      pip = true;\n    }\n    else\n    {\n      pip = false;\n    }\n  }\n  return p;\n}\n\n\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n//=========================================================================================================\n\n// Image\nvoid mainImage(out vec4 color,  in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip = false;\n  \n  // Pixel\n  vec2 pixel = Pip(pxy, pip);\n  \n  // Mouse\n  vec2 m = iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro, rd;\n  Ray(m, pixel, ro, rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n#if INTERSECT == 1\n    float t = Trace(ro, rd, 100., hit, s);\n#elif INTERSECT == 2\n  float t = SphereTrace(ro, rd, 100., hit, s);\n#elif INTERSECT == 3\n  float t = SphereTraceOverStep(ro, rd, 100., hit, s);\n#endif\n  \n  // Position\n  vec3 pt = ro + t*rd;\n  \n  // Shade background\n  vec3 rgb = background(rd);\n  \n  if(hit)\n  {\n    // Compute normal\n    ResultNormal n = ObjectNormal(pt);\n    \n    // Shade object with light\n    rgb = n.color.rgb * Shade(pt, n.normal);\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip == true)\n  {\n    rgb = ShadeSteps(s);\n  }\n\n\n  color = vec4(rgb, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}