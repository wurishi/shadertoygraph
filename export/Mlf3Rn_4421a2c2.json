{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"vec3 normal(sampler2D sampler, in vec2 uv)\n{\n    //uv.y = 1.0 - uv.y;\n\tfloat x=1.;\n\tfloat y=1.;\n\t\n\tfloat M =abs(texture(sampler, uv + vec2(0., 0.)/ iResolution.xy).r); \n\tfloat L =abs(texture(sampler, uv + vec2(x, 0.)/ iResolution.xy).r);\n\tfloat R =abs(texture(sampler, uv + vec2(-x, 0.)/ iResolution.xy).r);\t\n\tfloat U =abs(texture(sampler, uv + vec2(0., y)/ iResolution.xy).r);\n\tfloat D =abs(texture(sampler, uv + vec2(0., -y)/ iResolution.xy).r);\n\tfloat X = ((R-M)+(M-L))*.5;\n\tfloat Y = ((D-M)+(M-U))*.5;\n\t\n\tfloat strength =.01;\n\tvec4 N = vec4(normalize(vec3(X, Y, strength)), 1.0);\n\n\treturn vec3(N.xyz * 0.5 + 0.5);\n}\n\nvec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  \tif (obj0.x < obj1.x)\n  \t\treturn obj0;\n  \telse\n\t\treturn obj1;\n}\n\nvec2 obj_floor(in vec3 p)\n{\n\treturn vec2(p.y+7.0,0);\n}\n\nvec2 obj_sphere(in vec3 p)\n{\n  \tfloat d = length(p)-1.9;\n  \treturn vec2(d,1);\n}\n\nvec2 obj_roundBox(in vec3 p){\n  \treturn vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);\n}\n\nvec2 opTwist( vec3 p )\n{\n    float c = cos(sin(iTime)*p.y);\n    float s = sin(sin(iTime)*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return obj_roundBox(q);\n}\n\nvec2 op_rep(vec3 p, vec3 c)\n{\n  \tvec3 q = mod(p,c)-0.5*c;\n  \treturn opTwist(q);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\n  \treturn obj_union(obj_floor(p), op_rep(p, vec3(8.0, 8.0, 8.0)));\n}\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 64; ++i )\n    {\n        vec2 h = distance_to_obj( ro + rd * t );\n        if ( h.x < 0.001 )\n            return 0.1;\n\t\t\n\t\tres = min( res, k * h.x / t );\n        t += h.x;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n\nvec3 floor_color(in vec3 p)\n{\n    return texture(iChannel0, vec2(p.x/20.0, p.z/20.0)).xyz;\n  \tif (fract(p.x*0.2)>0.2)\n  \t{\n   \t\tif (fract(p.z*0.2)>0.2)\n      \t\treturn vec3(0,0.1,0.2);\n    \telse\n      \t\treturn vec3(1,1,1);\n  \t}\n  \telse\n  \t{\n    \tif (fract(p.z*.2)>.2)\n      \t\treturn vec3(1,1,1);\n    \telse\n      \t\treturn vec3(0.3,0,0);\n   \t}\n}\n\nvec3 prim_c(in vec3 p)\n{\n  \treturn vec3(0.6,0.6,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 vPos = -1.0 + 2.0 * uv;\n\n   \tvec3 vuv=vec3(0,1,0); \n    vec3 vrp=vec3(0,0,0);\n\n\tvec3 prp = vec3(sin(iTime*0.5),sin(iTime*0.5),cos(iTime*0.5)); \n    \n    vec3 vpn = normalize(vrp-prp);\n  \tvec3 u = normalize(cross(vuv,vpn));\n  \tvec3 v = cross(vpn,u);\n  \tvec3 vcv = (prp+vpn);\n  \tvec3 scrCoord = vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n  \tvec3 scp = normalize(scrCoord-prp);\n    \n    vec3 lightPos = vec3(-sin(iTime)*8.0,sin(iTime),cos(iTime)*8.0);\n    \n    const vec3 e = vec3(0.02,0,0);\n  \tconst float maxd = 100.0;\n  \tvec2 d = vec2(0.02,0.0);\n  \tvec3 c,p,N;\n    \n    float f = 1.0;\n    for(int i = 0; i < 256; i++)\n    {\n     \tif((abs(d.x) < .001) || (f > maxd))\n        \tbreak;\n        f += d.x;\n        p = prp + scp * f;\n        d = distance_to_obj(p);\n    }\n    \n    if (f < maxd)\n  \t{\n        if (d.y==0.0) {\n      \t\tc=floor_color(p/20.0);\n            N = normal(iChannel0, vec2(p.x/20.0, p.z/20.0));\n        } else {\n      \t\tc=prim_c(p);\n    \t    N = vec3(d.x-distance_to_obj(p-e.xyy).x, d.x-distance_to_obj(p-e.yxy).x, d.x-distance_to_obj(p-e.yyx).x);\n        }\n        \n    \tN = normalize(N);\n    \tfloat b=dot(N,normalize(lightPos-p));\n        \n        float r = 15.;\n        float d = max(length(lightPos-p) - r, 0.0);\n        float denom = d/r + 1.0;\n    \tfloat attenuation = 1.0 / (denom*denom);\n        \n        float vis = shadowSoft( p, normalize(lightPos-p), 0.0625, length(lightPos-p), 32.0 );\n        \n        float ambient = 0.015;\n        \n    \tfragColor = vec4((b*c+pow(b,16.0))*(1.0-f*.01)*attenuation*vis+ambient,1.0);\n  }\n  else \n    fragColor=vec4(0,0,0,1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mlf3Rn","date":"1417740250","viewed":453,"name":"Let's Do Raymarching","username":"Slyth","description":"Just learning shtuff.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""}}