{"ver":"0.1","info":{"id":"csySzd","date":"1703594886","viewed":46,"name":"simple neural network training","username":"Anon3242","description":"NN test123 copy0 two layers fork\nFORK: neural network test123 copy0 two hidden layers\nBest viewed in 800x450.\nmade public at 2023.12.26\nPlease forgive my dead simple and bad code and poor documentation !!! my tiny brain almost exploded writing this.","likes":4,"published":1,"flags":32,"usePreview":1,"tags":["nn"],"hasliked":0,"parentid":"cdySzV","parentname":"neural network test123 copy0"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    //sharper\n    //return ceil(textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).xxxx-0.6);\n\t\n    return textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).xxxx;\n}\n\nvec4 printdec(float n, vec2 U, vec4 O){\n    \n    //O+= char(U,61);\n    //U.x-=.5; \n    if(n<0.0){\n        O+=char(U,45);\n        U.x-=.5;\n        n=-n;\n    }else{U.x-=.5;}\n    \n    O+= char(U,48+int(mod(n/100000.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/10000.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/1000.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/100.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/10.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n,10.0)));\n    U.x-=.5; \n\n    return O;\n}\n\nvec4 printfloat(float n, vec2 U, vec4 O){\n    \n    //O+= char(U,61);\n    //U.x-=.5; \n    if(n<0.0){\n        O+=char(U,45);\n        U.x-=.5;\n        n=-n;\n    }else{U.x-=.5;}\n    O+= char(U,48+int(mod(n/1000.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/100.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n/10.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n,10.0)));\n    U.x-=.5; \n    O+= char(U,46);\n    U.x-=.5; \n    O+= char(U,48+int(mod(n*10.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n*100.0,10.0)));\n    U.x-=.5; \n    O+= char(U,48+int(mod(n*1000.0,10.0)));\n    \n    return O;\n}\n\nvec4 pix(vec2 fragCoord,vec2 xy){\n    float size=0.6;\n    //if(fragCoord.x>=xy.x-size && fragCoord.x<=xy.x+size && fragCoord.y>=xy.y-size && fragCoord.y<=xy.y+size)\n    if(  fragCoord==vec2(float(int(xy.x))+0.5,float(int(xy.y))+0.5)  )\n    //if(fragCoord==xy)\n    {\n        return vec4(vec3(1.0),1.0);\n    }\n    else{return vec4(vec3(0.0),1.0);}\n}\n\nvoid mainImage( out vec4 O, vec2 coord )\n{\n    \n    O = vec4(0.0);\n    vec2 uv = coord/iResolution.y;\n    ivec2 icoord = ivec2(coord);\n    vec2 m = iMouse.xy/iResolution.y;\n    vec2 position = m;\n    position = vec2(0.0,0.0);\n    float FontSize = 4.92;\n    vec2 U = ( uv - position+vec2(0.015,0.002))*64.0/FontSize;\n\n\n    \n    O=printfloat(iTime,U,O);\n    \n    U.y-=0.8;\n    O=printdec(0.0+mod(iTime*2.0,256.0),U,O);\n    U.x-=3.5;O+=char(U,32);\n    U.x-=0.5;\n    O+= vec4(char(U,0+int(mod(iTime*2.0,256.0))).x,0,0,1.0);\n    U.x+=4.0;\n    \n    U.y-=0.8;\n    O=printfloat(iTimeDelta*10000.0,U,O);\n    \n    U.y-=0.8;\n    O=printdec(float(iFrame),U,O);\n    \n    //U.y-=1.6;\n    //O+= char(U,64+24);\n    //U.x-=.5; \n    //U.x-=.5;\n    //O=printfloat(m.x,U,O);\n    \n    //U.x-=5.0;\n    //O+= char(U,64+25);\n    //U.x-=.5; \n    //U.x-=.5;\n    //O=printfloat(m.y,U,O);\n    \n    \n    //U.y-=0.8;\n    //U.x+=7.0;\n    //O+= char(U,64+24);\n    //U.x-=.5; \n    //U.x-=.5;\n    //O=printfloat(iMouse.x,U,O);\n    \n    //U.x-=5.0;\n    //O+= char(U,64+25);\n    //U.x-=.5; \n    //U.x-=.5;\n    ///O=printfloat(iMouse.y,U,O);\n    \n    //LIVE LOSS MONITOR\n    if(int(coord.x)>=401 && int(coord.x)<=799){\n        //O+=pix(coord,vec2(coord.x,GETVAL0(int(coord.x)-399,0).x));\n        //O+=pix(coord,vec2(coord.x,GETVAL0(int(coord.x),0).x));\n        O+=pix(coord,vec2(coord.x,1600.0*GETVAL2(7,int(coord.x)-399).x));\n    }\n    \n    //for(int i=1;i<=400;i++){\n        //O+=pix(coord,vec2(400+i,GETVAL(i,0)));\n    //}\n    //for(int i=401;i<=799;i++){\n    //    O+=pix(coord,vec2(i,GETVAL(i,0)));\n    //}\n    \n    U.x+=0.0;\n    U.y-=0.8;\n    \n    \n    //U.y-=0.8;O=printfloat(GETVAL0(0,2).x,U,O);\n    //U.y-=0.8;O=printfloat(GETVAL0(200,2).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,0).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,1).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,2).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,3).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,4).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,5).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,6).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(0,7).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(8,0).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(7,400).x,U,O);\n    U.y-=0.8;O=printfloat(sin(rand()*2.0*trainrange*pi - trainrange*pi)-GETVAL2(4,1).x,U,O);\n    \n    U.x-=5.0;\n    U.y+=8.0;\n    O=printfloat(GETVAL2(1,0).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,1).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,2).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,3).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,4).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,5).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,6).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(1,7).x,U,O);\n    \n    U.x-=5.0;\n    U.y+=5.6;\n    O=printfloat(GETVAL2(2,0).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,1).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,2).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,3).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,4).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,5).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,6).x,U,O);\n    U.y-=0.8;O=printfloat(GETVAL2(2,7).x,U,O);\n    \n    U.x-=5.0;\n    U.y+=5.6;\n    O=printfloat(GETVAL2(3,0).x,U,O);\n   \n    \n    //U.y-=0.8;O=printfloat(fract(sin((iFrame/100.+1.0)*(91.3458)) * 47453.5453),U,O);\n    //O=mix(O,vec4(uv.x,uv.y,0.0,1.0),m.y);\n    //O = O.xxxx;\n    //U.y-=0.8;\n    //if(uv.y>0.5)O=vec4(printfloat(1234.56,U,O).x,0,0,1.0);\n    \n    O += 0.4*vec4(uv.x,uv.y,0.0,0.0);\n    \n    //function print\n    if(int(coord.x)>=0 && int(coord.x)<=799){\n        //O+=pix(coord,vec2(coord.x,sin((coord.x-iMouse.y)/100.0*4.0*m.x)*100.0+200.0));\n        \n        //O+=pix(coord,vec2(coord.x,400.0*sigmoid(coord.x/50.0-8.0)));\n        //O+=pix(coord,vec2(coord.x,400.0*sigmoid_derivative(coord.x/50.0-8.0)));\n        //O+=pix(coord,vec2(coord.x,mod(coord.x,100.0)));\n    }\n    \n    //PLOT TEST OUTPUTS\n    if(int(coord.x)>=int(300.0-testrange*50.0) && int(coord.x)<=int(300.0+testrange*50.0-1.0)){\n        O+=pix(coord,vec2(coord.x,60.0+50.0*GETVAL2(6,coord.x-(300.0-testrange*50.0)).x));\n    }\n    \n    //PLOT TARGET FUNCTION\n    if(int(coord.x)>=int(300.0-(testrange*50.0)) && int(coord.x)<=int(300.0+testrange*50.0)){\n        float x=(coord.x-300.0)/(50.0*testrange)*testrange*pi;\n        O+=pix(coord,vec2(coord.x,60.0+50.0*sin(x)));\n    }\n    \n    O+=texelFetch(iChannel0,ivec2(int(coord.x),int(coord.y)),0).xyzw/200.0;\n    \n    //PLOT PARAMS AND NEURONS AT buf\n    if(icoord.x>=730 && icoord.x<=800 && icoord.y >=(450-(NHIDDEN+2)*10) && icoord.y <=450){\n        icoord=icoord-ivec2(730,(450-(NHIDDEN+2)*10));\n        float val=texelFetch(iChannel2,ivec2(icoord/10),0).x;\n        if(val>0.0){\n            O=0.7*abs(val*vec4(0.14, 0.36, 0.91,0));\n        }else{\n            O=0.7*abs(val*vec4(0.78,0.15,0.15,0));\n        }\n        if(icoord.x%10==0)O=vec4(0.2);\n        if(icoord.y%10==0)O=vec4(0.2);  \n    }\n    \n}\n\n\n//line 12 -> x,y coordinates of text, counted from left down corner","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define GETVAL0(INDEXX,INDEXY)  texelFetch(iChannel0,ivec2(INDEXX,INDEXY),0)\n#define GETVAL0x(INDEXX,INDEXY) texelFetch(iChannel0,ivec2(INDEXX,INDEXY),0).x\n#define GETVAL1(INDEXX,INDEXY)  texelFetch(iChannel1,ivec2(INDEXX,INDEXY),0)\n#define GETVAL1x(INDEXX,INDEXY) texelFetch(iChannel1,ivec2(INDEXX,INDEXY),0).x\n#define GETVAL2(INDEXX,INDEXY)  texelFetch(iChannel2,ivec2(INDEXX,INDEXY),0)\n#define GETVAL2x(INDEXX,INDEXY) texelFetch(iChannel2,ivec2(INDEXX,INDEXY),0).x\n#define rand() fract(sin((float(iFrame)/100.+1.0)*(91.3458)) * 47453.5453)\n#define randidate() fract(sin((float(iDate.w)/100.+1.0)*(91.3458)) * 47453.5453)\n\n#define NHIDDEN 32\n#define LEARNING_RATE 0.001\n#define EPOCHS 1000000\n#define TESTINTERVAL 500.0\n#define pi 3.1416\n#define trainrange 2.0\n#define testrange 2.0\n#define biasinitrange 5.0 \n//biasinitrange 5.0 for -2pi~2pi\n\nfloat sigmoid(float x) {\n    return x>0.0?x:0.0;//ReLU\n    //return 1.0 / (1.0 + exp(-x));//Sigmoid\n}\n\nfloat sigmoid_derivative(float x) {\n    return x>0.0?1.0:0.0;//ReLU\n    //return x * (1.0 - x);//Sigmoid\n}\n\nfloat loss(float outp, float target) {\n    return pow(outp - target, 2.0);\n}\n\n//float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n//float rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n//float rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SETVALX(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(VAL,fragColor.y,fragColor.z,fragColor.w)\n#define SETVALY(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,VAL,fragColor.z,fragColor.w)\n#define SETVALZ(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,VAL,fragColor.w)\n#define SETVALW(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,fragColor.z,VAL)\n//FORWARD PASS I->H AND (previously in bufA) LIVE LOSS MONITOR AND RMSE UPDATING\n//IN: input (GLOBAL: rand of iFrame, reranged), weights_ih [0,0-3], bias_h [2,0-3], lastframeloss[4,0], \n//OUT: hidden [5, 0-3], LossLiveMonitor[7,0-400], LastTestRMSE@8,0, DEFAULT COPY\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float inp=rand()*trainrange*pi*2.0 - trainrange*pi;\n    ivec2 icoord = ivec2(fragCoord);\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    //IF TEST, CHANGE INPUT TO TEST INPUTS\n    if(mod(float(iFrame),TESTINTERVAL)<(testrange*100.0)){\n        inp=(mod(float(iFrame),TESTINTERVAL)-(testrange*50.0))/(testrange*50.0)*testrange*pi;\n    }\n    \n    //FORWARD PASS I->H\n    if(icoord.x == 5 && icoord.y>=0 && icoord.y<NHIDDEN){\n        for(int i=0;i<NHIDDEN;i++){\n            SETVALX(5,i,sigmoid(GETVAL0x(2,i)+inp*GETVAL0x(0,i)));\n        }\n    }\n    \n    //LiveLossMonitor@[7,0-400]\n    if(int(fragCoord.x)==7 && int(fragCoord.y)>=0 && int(fragCoord.y)<=399){\n            //SETVALX(int(fragCoord.x),0,GETVAL0(int(fragCoord.x)+1,0).x);\n            fragColor=vec4(GETVAL0x(7,int(fragCoord.y)+1),fragColor.y,fragColor.z,fragColor.w);\n    }\n    SETVALX(7,400,GETVAL0(4,0).x);\n    \n    //UPDATING LastTestRMSE@8,0\n    //IF FRAME ON TEST COMPLETE: USING LATEST TEST LOSSES FROM LIVE LOSS MONITOR TO UPDATE RMSE@8,0\n    if(mod(float(iFrame),TESTINTERVAL)==(testrange*100.0+1.0)){\n        float losssum=0.0;\n        for(int i=int(400.0+1.0-testrange*100.0);i<=400;i++){\n            losssum+=GETVAL0x(7,i);\n        }\n        SETVALX(8,0,sqrt(losssum/(testrange*100.0)));\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define SETVALX(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(VAL,fragColor.y,fragColor.z,fragColor.w)\n#define SETVALY(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,VAL,fragColor.z,fragColor.w)\n#define SETVALZ(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,VAL,fragColor.w)\n#define SETVALW(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,fragColor.z,VAL)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //DEFAULT COPY\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define SETVALX(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(VAL,fragColor.y,fragColor.z,fragColor.w)\n#define SETVALY(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,VAL,fragColor.z,fragColor.w)\n#define SETVALZ(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,VAL,fragColor.w)\n#define SETVALW(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,fragColor.z,VAL)\n//FORWARD PASS H->O\n//IN: hidden [5, 0-3], weights_ho [1, 0-3]\n//OUT: output@4,1, DEFAULT COPY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 icoord = ivec2(fragCoord);\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    if(icoord.x==4 && icoord.y==1){\n        float actsum=0.0;\n        for(int i=0;i<NHIDDEN;i++){\n            actsum+=GETVAL0x(5,i) * GETVAL0x(1,i);\n        }\n        SETVALX(icoord.x,icoord.y,actsum);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define SETVALX(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(VAL,fragColor.y,fragColor.z,fragColor.w)\n#define SETVALY(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,VAL,fragColor.z,fragColor.w)\n#define SETVALZ(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,VAL,fragColor.w)\n#define SETVALW(INDEXX,INDEXY,VAL) if(int(fragCoord.x)==INDEXX && int(fragCoord.y)==INDEXY) fragColor=vec4(fragColor.x,fragColor.y,fragColor.z,VAL)\n//IF FIRST FRAME THROW bufC OUT, INIT ALL PARAMS ONLY\n//BACKWARD PASS, EDITED FOR PARALLEL\n//IN: GLOBAL target=sin((ranged)rand()), GLOBAL input=(ranged)rand(), output@4,1,  hidden [5, 0-3], \n//OUT: weights_ho[1,0-3], bias_o@3,0, weights_ih[0,0-3], bias_h[2,0-3], loss@4,0, test_output[6,0-testrange*100-1]\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float inp=rand()*2.0*trainrange*pi - trainrange*pi;\n    //IF TEST, CHANGE INPUT TO TEST INPUTS\n    if(mod(float(iFrame),TESTINTERVAL)<(testrange*100.0)){\n        inp=(mod(float(iFrame),TESTINTERVAL)-(testrange*50.0))/(testrange*50.0)*testrange*pi;\n    }\n    \n    float target=sin(inp);\n    ivec2 icoord = ivec2(fragCoord);\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    \n    //IF FRAME==0, INIT AND RETURN\n    if(iFrame==0){\n        for(int i=0;i<NHIDDEN;i++){//INIT weights_ih\n            SETVALX(0,i,fract(randidate()+0.41+float(i)/10.0+0.09*float(i%2)+0.15*float(i%3))*2.0-1.0);\n        }\n        for(int i=0;i<NHIDDEN;i++){//INIT weights_ho\n            SETVALX(1,i,fract(randidate()+0.53+float(i)/10.0+0.12*float((i+3)%2)+0.9*float((i+2)%3))*2.0-1.0);\n        }\n        for(int i=0;i<NHIDDEN;i++){//INIT bias_h\n            SETVALX(2,i,fract(randidate()+0.66+float(i)/10.0+0.13*float((i+5)%2)+0.78*float((i+4)%3))*biasinitrange*2.0-1.0*biasinitrange);\n            //SETVALX(2,i,fract(randidate()+0.6+float(i)/30.0)*1.0-0.5);\n        }\n        SETVALX(3,0,fract(randidate()+0.75)*2.0-1.0);//INIT bias_o\n        //SETVALX(3,0,fract(randidate()+0.7)*1.0-0.5);//INIT bias_o\n        return;\n    } \n    \n    //SET LOSS FOR LOG\n    SETVALX(4,0,loss(GETVAL0x(4,1),target));\n    \n    //IF TEST, WRITE TEST OUTPUT DATA@[6,0-testrange*100-1] AND DO NOT UPDATE\n    if(mod(float(iFrame),TESTINTERVAL)<(testrange*100.0)){\n        SETVALX(6,int(mod(float(iFrame),TESTINTERVAL)),GETVAL0x(4,1));\n        return;\n    }\n    \n    if(icoord.x==3 && icoord.y==0){//update bias_o\n        SETVALX(icoord.x,icoord.y,fragColor.x-LEARNING_RATE*(GETVAL0x(4,1)-target));//BIASO\n    }\n    \n    if(icoord.x>=0 && icoord.x<=2 && icoord.y>=0 && icoord.y<NHIDDEN){\n        for(int i=0;i<NHIDDEN;i++){\n            //update weights_ho\n            SETVALX(1,i,fragColor.x-LEARNING_RATE*(GETVAL0x(4,1)-target)*GETVAL0x(5,i));\n            //update bias_h\n            SETVALX(2,i,fragColor.x-LEARNING_RATE*(GETVAL0x(4,1)-target)*(GETVAL0x(1,i)-LEARNING_RATE*(GETVAL0x(4,1)-target)*GETVAL0x(5,i))*sigmoid_derivative(GETVAL0x(5,i)));\n            //update weights_ih\n            SETVALX(0,i,fragColor.x-LEARNING_RATE*(GETVAL0x(4,1)-target)*(GETVAL0x(1,i)-LEARNING_RATE*(GETVAL0x(4,1)-target)*GETVAL0x(5,i))*sigmoid_derivative(GETVAL0x(5,i)) * inp);\n        }\n    }\n    \n    //DEBUGGING\n    //if(icoord.x>=0 && icoord.x<=2 && icoord.y>=0 && icoord.y<=3){fragColor=vec4(0.5,0,0,0);}\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}