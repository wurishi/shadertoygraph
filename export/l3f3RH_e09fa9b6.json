{"ver":"0.1","info":{"id":"l3f3RH","date":"1709781613","viewed":41,"name":"a_chelyshkin_Clock","username":"artemchelyshkin","description":"for education","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["task1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\n\nfloat plane ( in vec3 p, vec4 n )\n{\n    if (dot ( p, n.xyz ) + n.w > 0.0)\n        return 0.0;\n    else return 1.0;\n    return dot ( p, n.xyz ) + n.w;\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat sdSpheretr(vec3 p, float r, vec3 offset)\n{\n  return max(length(p - offset) - r, plane(p, vec4(normalize(offset.xy), 0, -dot(offset, normalize(vec3(offset.xy, 0))))));\n}\n\nfloat sdFloor(vec3 p) {\n  return p.y + 1.;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat scene(vec3 p, out int element) {\n  if (sdFloor(p) < PRECISION)\n      element = 0;\n  else if (sdCylinder(p, vec3(0, 0, -1), vec3(0, 0, -1.2), 0.47)  < PRECISION)\n      element = 1;\n      else element = 2;\n  float co = min(sdCylinder(p, vec3(0, 0, -1), vec3(0, 0, -1.2), 0.47),\n              min(sdCylinder(p, vec3(0, 0, -1), vec3(0, 0, -1.2), 0.5),\n              min(sdCappedCone(p, vec3(-0.32, -0.32, -1.1), vec3(-0.5, -0.5, -1.1), 0.1, 0.05), \n              min(sdCappedCone(p, vec3(0.32, -0.32, -1.1), vec3(0.5, -0.5, -1.1), 0.1, 0.05),\n              min(sdSpheretr(p, 0.3, vec3(0.3, 0.37, -1.1)),\n              min(sdSpheretr(p, 0.3, vec3(-0.3, 0.37, -1.1)),\n              min(sdCylinder(p, vec3(0, 0, -1.2), vec3(0.4 * cos(iTime), 0.4 * -sin(iTime), -1.2), 0.01),\n              min(sdCylinder(p, vec3(0, 0, -1.2), vec3(0.2 * cos(iTime / 10.0), -0.2 * sin(iTime / 10.0), -1.2), 0.015),\n              min(sdCylinder(p, vec3(0.45, 0, -1.2), vec3(0.5, 0, -1.2), 0.015),\n              min(sdCylinder(p, vec3(-0.45, 0, -1.2), vec3(-0.5, 0, -1.2), 0.015),\n              min(sdCylinder(p, vec3(0, 0.45, -1.2), vec3(0, 0.5, -1.2), 0.015),\n              min(sdCylinder(p, vec3(0, -0.45, -1.2), vec3(0, -0.5, -1.2), 0.015),\n              min(sdSphere(p, 0.015, vec3(0.0, 0.0, -1.2)),\n              min(sdTorus(p, vec2(-1,0.3)), sdFloor(p)))))))))))))));\n  return co;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int element) {\n  float depth = MIN_DIST;\n  float d;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p, element);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    int element;\n    return normalize(\n      e.xyy * scene(p + e.xyy, element) +\n      e.yyx * scene(p + e.yyx, element) +\n      e.yxy * scene(p + e.yxy, element) +\n      e.xxx * scene(p + e.xxx, element));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec3 backgroundColor = vec3(0.88, 0.96, 1) * (uv.y/0.7);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 0.25, -4);\n  vec3 rd = normalize(vec3(uv, 1));\n  vec3 obj_col = vec3(0, 0, 0.7);\n  int element;\n  float sd = rayMarch(ro, rd, element);\n  if (sd > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n    if (element == 0) {\n        obj_col = vec3(0.88, 0.96, 1) * (-uv.y/0.5);\n    }\n    if (element == 1) {\n        obj_col = vec3(1);\n    }\n    vec3 p = ro + rd * sd;\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = vec3(0.0 + cos(iTime), 3.0 + sin(iTime), -2.0);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.);\n    //col = vec3(dif);\n    col = dif * obj_col;\n  }\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}