{"ver":"0.1","info":{"id":"MlS3DG","date":"1431870018","viewed":371,"name":"RubiksCube","username":"dila","description":"Very slow rubix cube being solved. Kali did it before https://www.shadertoy.com/view/XtX3Rj","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cube","rubix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define STEP_COUNT 8\n\nconst float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat mask(float a, float b)\n{\n    return max(sign(a-b), 0.0);\n}\n\nfloat interp(float a, float b)\n{\n    float m = mask(a, b);\n    return m * pi * 0.5 * clamp(a-b, 0.0, 1.0);\n}\n\nmat3 scramble(vec3 p)\n{\n    mat3 r = mat3(1.0);\n    float pt = (0.5+0.5*sin(iTime*0.25)) * 6.0;\n\n    if (p.x == -1.0) {\n        r = r * xrot(interp(pt, 0.0));\n    }\n    \n    vec3 q = p * r;\n    if (floor(q.y+0.5) == -1.0) {\n        r = r * yrot(interp(pt, 1.0));\n    }\n    \n    q = p * r;\n    if (floor(q.z+0.5) == -1.0) {\n        r = r * zrot(interp(pt, 2.0));\n    }\n    \n    q = p * r;\n    if (floor(q.x+0.5) == 1.0) {\n        r = r * xrot(interp(pt, 3.0));\n    }\n    \n    q = p * r;\n    if (floor(q.y+0.5) == 1.0) {\n        r = r * yrot(interp(pt, 4.0));\n    }\n    \n    q = p * r;\n    if (floor(q.z+0.5) == 1.0) {\n        r = r * zrot(interp(pt, 5.0));\n    }\n    \n    return r;\n}\n\nfloat cube(vec3 p)\n{\n  vec3 d = abs(p) - vec3(1.0 / 32.0);\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(cube(p+o.xyy) - cube(p-o.xyy),\n                          cube(p+o.yxy) - cube(p-o.yxy),\n                          cube(p+o.yyx) - cube(p-o.yyx)));\n}\n\nvec3 colour(vec3 p)\n{\n\tvec3 sn = normal(p);\n    vec3 ln = 0.5 + 0.5 * sn;\n    vec3 asn = abs(sn);\n    float mc = max(asn.x, max(asn.y, asn.z));\n    \n    if (mc == asn.x) {\n        return mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0), ln.x);\n    }\n    \n    if (mc == asn.y) {\n        return mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), ln.y);\n    }\n    \n    if (mc == asn.z) {\n        return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.5, 0.0), ln.z);\n    }\n    \n    return vec3(0.0);\n}\n\nvec4 map(vec3 p)\n{\n    p *= xrot(iTime) * zrot(iTime*2.0);\n    \n    float d = 1000.0;\n    vec3 f = vec3(0.0);\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            for (int k = -1; k <= 1; ++k) {\n                vec3 v = vec3(float(i),float(j),float(k));\n                vec3 o = scramble(v) * p + v;\n                vec3 c = clamp(o, -0.45, 0.45);\n                float m = length(c - o);\n                if (m < d) {\n                    d = m;\n                    f = o;\n                }\n            }\n        }\n    }\n    return vec4(d, colour(f));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < STEP_COUNT; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p).x;\n        t += d;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    vec3 o = vec3(0.0, 0.0, -4.0);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec4 fd = map(w);\n    \n    float bl = 1.0 / (1.0 + t * t * 0.01 + fd.x * 100.0);\n    \n    vec3 bk = mix(vec3(0.8,0.8,1.0), vec3(0.5,0.5,0.5), 0.5+0.5*uv.y);\n    \n    vec3 fc = mix(fd.yzw, bk, 1.0-bl);\n    \n\tfragColor = vec4(fc,1.0);\n}","name":"","description":"","type":"image"}]}