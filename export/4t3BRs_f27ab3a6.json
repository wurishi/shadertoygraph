{"ver":"0.1","info":{"id":"4t3BRs","date":"1540564312","viewed":91,"name":"Fedora","username":"tristanC","description":"A red fedora..","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Fedora Shader\n\n   Code is mainly based on\n   https://www.shadertoy.com/view/4lK3Rc\n   Uploaded by iq in 2017-02-24\n*/\n\n// Primitives\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n  float k0 = length(p / r);\n  float k1 = length(p / (r * r));\n  return k0 * (k0 - 1.0) / k1 + sin(p.x) * .1;\n}\n\nfloat sdCappedCone(vec3 p, float h, float r1, float r2) {\n  vec2 q = vec2(length(p.xz), p.y);\n  vec2 k1 = vec2(r2, h);\n  vec2 k2 = vec2(r2 - r1, 2.0 * h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n  return s * sqrt(min(dot(ca, ca), dot(cb, cb)));\n}\n\nfloat sdPrismY(vec3 p, float rad, float h, float d) {\n  vec3 q = abs(p);\n  return max(q.y - d, max(q.x * rad + p.z * 0.5, -p.z) - h * 0.5 );\n}\n\nvec3 rotX(vec3 v, float r) {\n  return vec3(v.x, cos(r) * v.y + sin(r) * v.z, -sin(r) * v.y + cos(r) * v.z);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdHatTop(vec3 q) {\n  float cap = sdCappedCone(q - vec3(0., 15., 0.), 3., 9., 7.) - 5.;\n  float hole = length(q - vec3(0., 28.5, 0.)) - 8.;\n  float plane = sdBox(q - vec3(0., 23.5, 0.), vec3(10., 1., 10.));\n  float cut = sdBox(q - vec3(0., 8., 0.), vec3(20., 2.8, 20.));\n  return max(-cut, max(-smin(hole, plane, 1.), cap));\n}\n\nfloat sdHatShape(vec3 q) {\n  float top = sdHatTop(q);\n  float bottom = sdEllipsoid(q - vec3(.0, 10., 0.), vec3(22., 1., 22.));\n  float hole = length(q - vec3(0., 9., 0.)) - 11.;\n  float shape = max(-hole, smin(bottom, top, 1.5));\n  float knot = sdPrismY(rotX(q - vec3(0., 12.4, -14.), .3), 0.2, 1., 1.5);\n  return knot < shape ? knot : shape;\n}\n\nfloat sdBand(vec3 q) {\n  float band = sdBox(q - vec3(-9., 12.6, .0), vec3(25., 1.5, 25.));\n  return max(band, sdHatShape(q));\n}\n\nvec2 map(vec3 q) {\n  q *= 100.0;\n  float hat = sdHatShape(q);\n  float band = sdBand(q);\n  vec2 res = band <= hat ? vec2(band, .01) : vec2(hat, 1.);\n  res.x /= 100.0;\n  return res;\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n  float m, t = 0.02;\n  for(int i=0; i < 128; i++) {\n    vec2 res = map(ro + rd * t);\n    if ((res.x < 0.) || (t > 2.))\n      break;\n    t += res.x;\n    m = res.y;\n  }\n  if (t > 2.)\n    m = .0;\n  return vec2(t, m);\n}\n\nvec3 calcNormal(vec3 pos) {\n  vec3 eps = vec3(0.005, 0.0, 0.0);\n  return normalize(vec3(\n         map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n         map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n         map(pos+eps.yyx).x - map(pos-eps.yyx).x));\n}\n\nmat3 camRotation() {\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float y = 1. - iTime * 0.1 + 4. * mo.x;\n  float p = .6 + -6. * mo.y;\n  return mat3(1., 0., 0., 0., cos(p), -sin(p), 0., sin(p), cos(p)) *\n         mat3(cos(y), 0., sin(y), 0., 1., 0., -sin(y), 0., cos(y));\n}\n\nvec3 render(vec2 p) {\n  mat3 rot = camRotation();\n  vec3 rd = normalize(vec3(p, 1.)) * rot;\n  vec3 ro = vec3(0., 0.1, -.42) * rot;\n  vec3 col = vec3(.0);\n  vec2 res = intersect(ro,rd);\n  float t = res.x;\n\n  if (res.y <= 0.0) {\n    return col;\n  }\n  vec3  pos = ro + t * rd;\n  vec3  nor = calcNormal(pos);\n  vec3  ref = reflect(rd, nor);\n  float fre = clamp(1. + dot(nor, rd), 0., 1.);\n  vec3  lin = 4. * vec3(.7, .80, 1.) * (.5 + .5 * nor.y) + .5 * fre;\n\n  col = (vec3(.9, .0, .0) * 0.72 + 0.2 * fre * vec3(1., .8, .2)) * res.y * lin;\n  return col + 4. * vec3(.7, .8, 1.) * smoothstep(.0, .4, ref.y) * .4 *\n         (.06 + .94 * pow(fre, 5.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n  fragColor = vec4(render(uv), 1.);\n}\n","name":"Image","description":"","type":"image"}]}