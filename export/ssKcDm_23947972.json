{"ver":"0.1","info":{"id":"ssKcDm","date":"1655018571","viewed":269,"name":"Spark Volcano","username":"fenix","description":"Multipass particle physics simulation, colliding with a voxel grid. The number of particles rendered is dynamic and depends on frame rate. Basic mouse camera.\n\nVoxel rendering inspired by \"Branchless Voxel Raycasting\" https://www.shadertoy.com/view/4dX3zl","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["3d","collision","simulation","particles","physics","integration","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Multipass particle physics simulation, colliding with a voxel grid. The number of\n//  particles is dynamic and depends on frame rate. You may want to raise TARGET_FRAME_TIME\n//  in Buffer A on lower end devices.\n//\n//  Particles are attenuated by 2D distance to line segment for motion blur.\n// \n//  Buffer A computes the particle positions\n//  Buffer B computes the particle velocities\n//  Buffer C renders the background with depth in the w component\n//\n// ---------------------------------------------------------------------------------------\n\n#define DIFFUSE_PER_PARTICLE 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int particleCount = int(load(PARTICLE_COUNT));\n    \n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n     vec4 normalAndZ = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    CalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    // camera-to-world and world-to-camera transform\n    mat4 c2wNew = mat4(vec4(-0.5*iResolution.y / iResolution.x * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n    mat4 w2cNew = inverse(c2wNew);\n      \n    const float diffuseColor = 1.0;\n    float zDist = normalAndZ.w;\n\tconst vec3 reverseLightDir = normalize(vec3(1.0,2.0,3.0));\n\tconst vec3 lightColor = vec3(0.5,0.5,0.5);\t\n\tconst vec3 ambientColor = vec3(0.05,0.05,0.05);\n\n    // diffuse\n\tvec3 groundColor = diffuseColor * ambientColor;\n\tfloat dp = dot(normalAndZ.xyz, reverseLightDir);\n\tif(dp > 0.0)\n\t\tgroundColor += (diffuseColor * dp * lightColor);\n    \n    // specular\n    vec3 reflection = reflect(reverseLightDir, normalAndZ.xyz);\n    dp = dot(cameraFwd, reflection);\n    if (dp > 0.0)\n    {\n        groundColor += pow(abs(dp), 15.0) * vec3(0.5);\t\t\n    }  \n   \n    fragColor = vec4(groundColor, 0.0) * smoothstep(-50.0, -17.0, -zDist);\n    \n#if DIFFUSE_PER_PARTICLE\n\tvec3 rayDir = CalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    vec3 groundPos = cameraPos + rayDir * zDist;\n#endif // DIFFUSE_PER_PARTICLE\n\n    for (int particle = 0; particle < particleCount; ++particle)\n    {\n        vec4 oldPosAndAge = particleData(iChannel0, particle);\n        \n        vec3 oldPos = oldPosAndAge.rgb;\n        vec3 newPos = oldPos + particleData(iChannel1, particle).rgb;\n         \n#if DIFFUSE_PER_PARTICLE\n        const float GLOW_INTENSITY = 0.005;\n        vec3 groundDelta = oldPos - groundPos.xyz;\n        float groundDotParticle = dot(groundDelta, normalAndZ.xyz);\n        \n        if (groundDotParticle > 0.001)\n        {\n            float distToGround = length(groundDelta);\n            float glow = GLOW_INTENSITY * normalize(groundDotParticle) / (distToGround * distToGround * distToGround);\n            vec3 glowTemp  = BlackBody(MAX_TEMP * 1.0 * (1.0 - oldPosAndAge.w / 1.5));\n            fragColor += vec4(glow * glowTemp * diffuseColor, 0.0);\n        }\n#endif // DIFFUSE_PER_PARTICLE\n \n        // convert to camera space\n        vec3 oldPosCamera = (w2cNew * vec4(oldPos,1.0)).xyz;\n        oldPosCamera.xy = oldPosCamera.xy / oldPosCamera.z;\n        vec3 newPosCamera = (w2cNew * vec4(newPos,1.0)).xyz;\n        newPosCamera.xy = newPosCamera.xy / newPosCamera.z;\n        \n        // if in front of clipping plane\n        if(oldPosCamera.z > 0.01 && newPosCamera.z > 0.01 && zDist > oldPosCamera.z && zDist > newPosCamera.z)\n        {\n            vec2 pDelta = (p - oldPosCamera.xy);\n            vec2 cameraDelta = newPosCamera.xy - oldPosCamera.xy;\n            float cameraDeltaLen = dot(cameraDelta, cameraDelta);\n            \n            // Find the closest point on the line segment from old to new\n            vec2 closest;\n            if (cameraDeltaLen > 0.0001)\n            {\n                float cameraDeltaInvSqrt = inversesqrt(cameraDeltaLen);\n                vec2 cameraDeltaNorm = cameraDelta * cameraDeltaInvSqrt;\n                closest = oldPosCamera.xy + cameraDeltaNorm * max(0.0, min(1.0 / cameraDeltaInvSqrt, dot(cameraDeltaNorm, pDelta)));\n            }\n            else\n            {\n                closest = oldPosCamera.xy;\n            }\n            \n            // Distance to closest point on line segment\n            float dist = distance(closest, p);\n            \n            const float PARTICLE_SIZE = 0.025;\n            float particleTemp = max(0.0, PARTICLE_SIZE - dist) * MAX_TEMP / PARTICLE_SIZE;\n        \n            if (dist < PARTICLE_SIZE)\n            {\n                fragColor += vec4(BlackBody(particleTemp / (oldPosAndAge.w + 0.1)), 0);\n            }\n        }\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float MAX_AGE = 10.0;\n\n#define if_value_pixel(P) if (all(equal(ivec2(fragCoord), ivec2(P, int(iResolution.y) / 2))))\n#define store(P, V) if_value_pixel(P) fragColor = V\n#define load(P) texelFetch(iChannel0, ivec2(P, int(iResolution.y) / 2), 0)\n\nconst int PARTICLE_COUNT = 0;\n\nconst float PI = 3.1415926535;\n\nbool getVoxel(ivec3 c) {\n    return abs(c[0] + 3) + c[1] + abs(c[2]) < 1 ||\n    abs(c[0] - 3) + c[1] + abs(c[2]) < 0 ||\n    abs(c[0]) + c[1] + abs(c[2] + 3) < 2 ||\n    abs(c[0] - 6) + c[1] + abs(c[2] + 20) < -5 ||\n    abs(c[0] + 9) + c[1] + abs(c[2] - 11) < -3;    \n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec4 p){\n    const float scale = pow(2., -32.);\n    uvec4 h = hash(uvec4(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\nvoid CalcCamera(in float iTime, in vec4 iMouse, in vec3 iResolution, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float animate = (iMouse.x / iResolution.x) * 2.0 - 0.5;\n    \n    cameraLookAt = vec3(0.0, 0.0f, 0.0);\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 1.1*3.14 + iTime * 0.1;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.75*3.14;\n    cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 15.0;\n\n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft  = -normalize(cross(cameraFwd, vec3(0.0,1.0,0.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 CalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nvec4 particleData(in sampler2D sampler, int particle)\n{\n    return texelFetch(sampler, ivec2(particle & 1023, particle / 1024), 0);\n}\n\nvec4 particleData(in sampler2D sampler, in vec2 fragCoord)\n{\n    return texelFetch(sampler, ivec2(fragCoord), 0);\n}\n\nconst float MAX_TEMP = 1000.0;\n\nvec3 BlackBody(float _t)\n{\n#if 1\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n#else\n    // From https://www.shadertoy.com/view/MslSDl (but commented out)\n    \n    // See: http://en.wikipedia.org/wiki/Planckian_locus\n    //      under \"Approximation\"\n    \n    float u = (0.860117757 + 1.54118254e-4*_t + 1.28641212e-7*_t*_t)\n        / (1.0 + 8.42420235e-4*_t + 7.08145163e-7*_t*_t);\n    \n    float v = (0.317398726 + 4.22806245e-5*_t + 4.20481691e-8*_t*_t)\n        / (1.0 - 2.89741816e-5*_t + 1.61456053e-7*_t*_t);\n    \n    // http://en.wikipedia.org/wiki/CIE_1960_color_space\n    // -> http://en.wikipedia.org/wiki/XYZ_color_space\n    \n    float x = 3.0 * u / (2.0 * u - 8.0 * v + 4.0);\n    float y = 2.0 * v / (2.0 * u - 8.0 * v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = (Y/y) * x;\n    float Z = (Y/y) * z;\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    mat3 XYZtosRGB = mat3(\n         3.2404542,-1.5371385,-0.4985314,\n        -0.9692660, 1.8760108, 0.0415560,\n         0.0556434,-0.2040259, 1.0572252\n    );\n    \n    vec3 RGB = vec3(X,Y,Z) * XYZtosRGB;\n    return RGB * pow(0.0004*_t, 4.0);\n#endif\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n// Computes the position of each particle, one per texture fragment.\n//\n// Also maintains the particle count in coordinate 0, 0, raising it when the frame rate is\n// good and lowering it when the frame rate is not.\n// ---------------------------------------------------------------------------------------\n\nconst float TARGET_FRAME_TIME = 0.02; // Try 0.05 for mobile\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Update particle count\n    if_value_pixel(PARTICLE_COUNT)\n    {\n        vec4 particleCount = load(PARTICLE_COUNT);\n        \n        if (iFrame == 0)\n        {\n            particleCount.x = 0.0;\n        }\n        else if (iTimeDelta < TARGET_FRAME_TIME || particleCount.x < 128.0)\n        {\n            particleCount.x += 1.0;\n        }\n        else\n        {\n            particleCount.x -= 1.0;\n        }\n\n        store(PARTICLE_COUNT, particleCount);\n        return;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Integrate positions\n    vec4 oldPosAndAge = particleData(iChannel0, fragCoord);\n    vec3 newPos = oldPosAndAge.xyz + particleData(iChannel1, fragCoord).xyz;\n    float newAge = oldPosAndAge.w + min(iTimeDelta, 0.033) / MAX_AGE;\n    \n    // Record new position if it's not inside a voxel\n    if (!getVoxel(ivec3(floor(newAge))))\n    {\n        fragColor = vec4(newPos, newAge);\n    }\n        \n    // Reset particles that have gotten too old\n    if (newAge > 1.0)\n    {\n        fragColor = vec4(0.0, 0.1, 0.0, noise(ivec2(fragCoord) + 3) * 0.3);\n    }\n    \n    // Release particles slowly when shader starts\n    if (iFrame < int(fragCoord.x) * 3)\n    {\n        fragColor.w = 1.0;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n// Computes the velocity of each particle, one per texture fragment.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(0.0,-0.008,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = particleData(iChannel0, fragCoord).xyz;\n    \n    // Detect when the particle is reset and give it a random velocity\n    if (pos == vec3(0.0, 0.1, 0.0))\n    {\n        const float XZ_SPREAD = 0.02;\n        const float Y_SPREAD = 0.04;\n        const float Y_SPRAY = 0.15;\n\n        fragColor = (noise(ivec2(fragCoord)) - 0.5) * 2.0 * vec4(XZ_SPREAD, Y_SPREAD, XZ_SPREAD, 0.0);\n        fragColor.y += Y_SPRAY;\n    }\n    else\n    {\n        // Integrate velocities\n        vec3 newVel = particleData(iChannel1, fragCoord).xyz + GRAVITY;\n        ivec3 newMapPos = ivec3(floor(pos + newVel));\n        \n        // Detect if we're about to enter a voxel and bounce off\n        if (getVoxel(newMapPos))\n        {\n            ivec3 oldMapPos = ivec3(floor(pos));\n            ivec3 mapDelta = abs(newMapPos - oldMapPos);\n            \n            newVel += -1.6 * newVel * vec3(mapDelta);\n        }\n        \n        fragColor = vec4(newVel, 0.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n// Background rendering inspired by \"Branchless Voxel Raycasting\" by fb39ca4\n//    https://www.shadertoy.com/view/4dX3zl/\n//\n// Added zDist computation based on math from the source cited: https://lodev.org/cgtutor/raycasting.html\n// Resulting buffer contains (normal.x, normal.y, normal.z, zDist) for each pixel.\n// ---------------------------------------------------------------------------------------\n\nconst int MAX_RAY_STEPS = 90;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    CalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = CalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\t\t\t\n\tivec3 mapPos = ivec3(floor(cameraPos + 0.));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    ivec3 rayStep = ivec3(sign(rayDir));\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - cameraPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n    bool hit = false;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (getVoxel(mapPos))\n        {\n            hit = true;\n            \n            break;\n        }\n\n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n\t}\n\t\n    if (!hit)\n    {\n        fragColor=vec4(0.0, 0.0, 0.0, 1000000000.0);\n        return;\n    }\n    \n\tvec3 normal;\n    float perpWallDist;\n\tif (mask.x) {\n\t\tnormal = vec3(1.0, 0.0, 0.0);\n        perpWallDist = sideDist.x - deltaDist.x;\n\t}\n\tif (mask.y) {\n\t\tnormal = vec3(0.0, 1.0, 0.0);\n        perpWallDist = sideDist.y - deltaDist.y;\n\t}\n\tif (mask.z) {\n\t\tnormal = vec3(0.0, 0.0, 1.0);\n        perpWallDist = sideDist.z - deltaDist.z;\n\t}\n    \n    float zDist = dot(vec3(mapPos) - cameraPos, rayDir);\n\tfragColor = vec4(normal, perpWallDist);\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"}]}