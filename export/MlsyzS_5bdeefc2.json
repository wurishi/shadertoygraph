{"ver":"0.1","info":{"id":"MlsyzS","date":"1505345519","viewed":532,"name":"triangulation effect - delaunay","username":"ghost","description":"delaunay triangles from voronoi; triangulation size = # seeds\n","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["delanuay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Delaunay Triangulation effect based on tomkh's implementation of \n// JFA algorithm for Delaunay\n\n// (see Voronoi paper at: http://www.comp.nus.edu.sg/~tants/jfa/i3d06.pdf)\n// ( + Delaunay paper at: http://www.comp.nus.edu.sg/~tants/delaunay/GPUDT.pdf)\n// ---------------------------------------------------------------\n\n\n#define SHOW_LINES // Comment to see without lines\n\nvec2 getPixel(float p) { \n    float y = floor(p / iResolution.x);\n    return vec2( p - y * iResolution.x, y ) + .5;\n}\n\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nvec4 getTriangles(vec2 fragCoord)\n{\n    vec4 tri = texture(iChannel1, fragCoord/iResolution.xy);\n    \n    vec2 p0 = getPixel(tri.x);\n    vec2 p1 = getPixel(tri.y);\n    vec2 p2 = getPixel(tri.z);\n    \n    float d = sdTriangle(p2,p0,p1,fragCoord);\n\n    if (tri.w != 0.) {\n        vec2 p3 = getPixel(tri.w);\n        d = min(d, sdTriangle(p2,p1,p3,fragCoord)); \n    }\n    \n    d = smoothstep(-2.,2.,d); // inside tri -> neg -> closer to 0\n    d = 1.-d;\n    \n    //return vec4(vec3(d),1.); // debug tris    \n    \n    vec4 color = (texture(iChannel0, p0 / iChannelResolution[0].xy ) +\n                  texture(iChannel0, p1 / iChannelResolution[0].xy ) +\n                  texture(iChannel0, p2 / iChannelResolution[0].xy ) ) / 3.;\n    \n    #ifdef SHOW_LINES\n    color *= d;\n\t#endif\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy).wwww; //return; // debug seeds\n\n    vec3 color = getTriangles(fragCoord).xyz;\n\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A used to create seeds using thresholding method\n\n#define TESS .4\n#define ANIMATE\n\nfloat grayScale(vec4 c) { return c.x*.29 + c.y*.58 + c.z*.13; }\n\nvec3 animate() { return vec3(sin(iTime)*.0001, cos(iTime)*.0001, 0); }\n\nvec4 seed(in vec2 uv)\n{\n    vec3 dataStep = vec3(vec2(TESS)/iChannelResolution[0].xy, 0.);\n    \n    #ifdef ANIMATE\n    dataStep += animate();\n    #endif\n    \n    vec4 fragColor = texture( iChannel0, uv );\n    \n    float d = grayScale(fragColor);\n    float dL = grayScale(texture( iChannel0, uv - dataStep.xz ));\n    float dR = grayScale(texture( iChannel0, uv + dataStep.xz ));\n    float dU = grayScale(texture( iChannel0, uv - dataStep.zy ));\n    float dD = grayScale(texture( iChannel0, uv + dataStep.zy ));\n    \n    // if true, then seed\n    float w = float( d > max(max(dL, dR), max(dU, dD)) );\n    \n    fragColor.w = w;\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = seed(fragCoord.xy/iResolution.xy);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B used to run JFA\n   \n#define ROUNDS 8.\n\nvec4 initSeeds(vec2 fragCoord)\n{\n    vec4 seed = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    if (seed.w > 0.)\n        return vec4(fragCoord,0.,0.);\n    else \n        return vec4(0.);    \n}\n\nvec4 updateClosestSeed(inout vec2 uv, float k) \n{    \t   \n    vec2 closest_coord = vec2(0.);\n    float closest_dist = 9999.;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            // get seeds stored with pixels (x+i, y+j)\n            vec2 p = uv + vec2(i,j) * k;\n            vec2 seed = texture(iChannel1, p/iChannelResolution[1].xy).xy;   \n            float d = length(seed - uv);\n\n            // store closest seed\n            if (d < closest_dist) {\n                closest_dist = d;\n                closest_coord = seed;\n            }\n        }\n    }   \n    return vec4(closest_coord,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    float restart = mod(float(iFrame), ROUNDS);\n    \n    if (restart == 0.) {\n        fragColor = initSeeds(fragCoord);    \n        return;\n    }\n   \n    float k = exp2(ROUNDS-1.)/exp2(float(restart));\n    fragColor = updateClosestSeed(fragCoord, k); \n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C used to run triangle JFA\n\n#define ROUNDS 8.\n\nvec2 getSeed(vec2 uv) { return texture(iChannel0, uv / iChannelResolution[0].xy).xy; }\n\n// flattening x,y coordinate\nfloat setPixel(vec2 uv) { return floor(uv.y)*iResolution.x + floor(uv.x); }\n\nvec2 getPixel(float p) { \n    float y = floor(p / iResolution.x);\n    return vec2( p - y * iResolution.x, y ) + .5;\n}\n\n// iq: https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n// voronoi vertex: 4 incident pixels are of 3 or 4 different colors\n// 3 colors -> 1 triangle, 4 colors -> 2 triangles\n// if pixels have the same seed, they also have the same color\nvec4 findTriangles(vec2 uv)\n{    \n    // flatten x,y coord [for triangle vertex storage]\n    float c  = setPixel(getSeed(uv));                 // p0 for tri\n    float r  = setPixel(getSeed(uv + vec2(1,0)));     // p1\n    float d  = setPixel(getSeed(uv + vec2(0,-1)));    // p2\n    float dr = setPixel(getSeed(uv + vec2(1,-1)));    // p3\n\n    float count = float(c != r); \n    count += float(c != d); \n    count += float(c != dr);\n    count += float(r != d);\n    count += float(r != dr);\n    count += float(d != dr);\n    \n    // 4 different == 0 false count\n    if (count == 6.) {\n    \treturn vec4(c,r,d,dr);\n    }\n    \n    // 3 different == 1 false count\n    if (count == 5.) {\n        if (c == r) \n            return vec4(d,c,dr,0.); \n        else if (c == d)\n            return vec4(c,r,dr,0.);\n        else \n            return vec4(c,r,d,0.);\n    }\n    \n    return vec4(0.);\n}\n\n// similar JFA to voronoi, propogating triangles instead of seeds\nvec4 updateClosestTriangle(inout vec2 uv, float k) \n{    \t  \n    vec4 closest_tri = vec4(0.);\n    float closest_dist = 9999.;\n    \n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            // get triangle stored with pixels (x+i, y+j)\n            vec2 p = uv + vec2(i,j) * k;\n            vec4 tri = texture(iChannel1, p/iChannelResolution[1].xy);   \n            \n            if (tri.x == 0.) \n                continue;\n            \n            // get unflattened x,y coord\n            vec2 p0 = getPixel(tri.x);\n            vec2 p1 = getPixel(tri.y);\n            vec2 p2 = getPixel(tri.z);\n            \n            float d = sdTriangle(p2, p0, p1, uv);\n            \n            // 2 triangles\n            if (tri.w != 0.) {\n            \tvec2 p3 = getPixel(tri.w);\n                d = min(d, sdTriangle(p2, p1, p3, uv));\n            }\n            \n            // store closest triangle\n            if (d < closest_dist) {\n                closest_dist = d;\n                closest_tri = tri;\n            }\n        }\n    }   \n    return vec4(closest_tri);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float restart = mod(float(iFrame+1), ROUNDS);\n    \n    if (restart == 0.) {\n        fragColor = findTriangles(fragCoord);\n        return;\n    }\n    \n    float k = exp2(ROUNDS-1.)/exp2(restart);\n    fragColor = updateClosestTriangle(fragCoord, k); \n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer D to get clean Voronoi every N-th frame\n// Needed for seed params adjustment \n\n#define ROUNDS 8.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float restart = mod(float(iFrame+2), ROUNDS);\n    \n    if (restart == 0.) \n        fragColor = texture(iChannel0,fragCoord/iChannelResolution[0].xy); \n    else \n        fragColor = texture(iChannel1,fragCoord/iChannelResolution[1].xy);   \n\n}","name":"Buf D","description":"","type":"buffer"}]}