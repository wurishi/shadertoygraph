{"ver":"0.1","info":{"id":"dsVGDd","date":"1679254964","viewed":91,"name":"PBR cube by Bing AI","username":"IWBTShyGuy","description":"I only asked Bing AI to render the cube using PBR. Comments prefixed with \"///\" are by me.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bingai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// First raymarch cubes with PBR\n// by Bing (based on Camargo's code)\n// https://www.shadertoy.com/view/4sX3z4\n/// â†‘ mistake of Bing AI, this should be https://www.shadertoy.com/view/XsyXWV \n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\n/// the following constants are declared by me\n#define M_PI 3.141592\n#define M_EPSILON 1.0e-6\n\nfloat cubeSDF(vec3 p)\n{\n    vec3 d = abs(p) - vec3(1.0);\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 p)\n{\n    float d1 = cubeSDF(p);\n    float d2 = cubeSDF(p - vec3(2.0, 0.0, 0.0));\n    return min(d1, d2);\n}\n\nvec3 raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + t * rd;\n        float d = map(p);\n        if(d < SURF_DIST) return p;\n        t += d;\n        if(t > MAX_DIST) break;\n    }\n    return vec3(0.0);\n}\n\nvec4 PBR(vec3 ro, vec3 rd)\n{\n\t// Raymarch scene and get hit point\n\tvec4 col=vec4(1.);\n\tvec3 hp=raymarch(ro,rd);\n\n\t// If hit point is not zero (meaning we hit something)\n\tif(hp!=vec3(0))\n\t{\n\t    // Get normal vector at hit point by finite difference method\n\t    vec2 e = vec2(SURF_DIST * 10., 0.);\n\t    vec3 n = normalize(vec3(\n\t        map(hp + e.xyy) - map(hp - e.xyy),\n\t        map(hp + e.yxy) - map(hp - e.yxy),\n\t        map(hp + e.yyx) - map(hp - e.yyx)));\n\t    // Get light direction vector (assume a single point light at (5.0, 5.0, 5.0))\n\t    vec3 lp = vec3(5.0, 5.0, 5.0);\n\t    vec3 l = normalize(lp - hp);\n\t    \n\t    // Get view direction vector\n\t    vec3 v = normalize(ro - hp);\n\t    \n\t    // Get halfway vector between light and view\n\t    vec3 h = normalize(l + v);\n\t    \n\t    // Define some material parameters (you can change these values)\n\t    float roughness = 0.2; // how rough the surface is [0, 1]\n\t    float metallic = 0.8; // how metallic the surface is [0, 1]\n\t    vec3 albedo = vec3(1.0, 0.8, 0.6); // the base color of the surface\n\t    \n\t    // Calculate the normal distribution function (NDF) using GGX distribution\n\t    float alpha = roughness * roughness;\n\t    float alpha2 = alpha * alpha;\n\t    float nh = dot(n, h);\n\t    float nh2 = nh * nh;\n\t    float nom = alpha2;\n\t    float denom = (nh2 * (alpha2 - 1.0) + 1.0);\n        denom *= denom * M_PI;\n        float D = nom / denom;\n        \n        // Calculate the geometry function (G) using Smith's method with Schlick-GGX approximation\n        float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n        float nv = dot(n, v);\n        float nl = dot(n, l);\n        float gv = nv / (nv * (1.0 - k) + k);\n        float gl = nl / (nl * (1.0 - k) + k);\n        float G = gv * gl;\n        \n        // Calculate the Fresnel function (F) using Schlick's approximation\n        vec3 F0 = mix(vec3(0.04), albedo, metallic); \n        vec3 F= F0 + (vec3(1.) - F0) * pow(1.-dot(h,v),5.);\n        \n        // Calculate the BRDF value\n        vec3 BRDF= D*G*F/(4.*nv*nl+M_EPSILON); \n        \n        // Calculate the final color by multiplying BRDF with light intensity and color\n        col=vec4(BRDF*10.*vec3(1.),1.);\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\n    // Camera setup\n\tvec3 ro=vec3(5.*cos(iTime),sin(iTime),-5.*sin(iTime));\n\tvec3 ta=vec3(cos(iTime),sin(iTime),-sin(iTime));\n\tvec3 ww=normalize(ta-ro);\n\tvec3 uu=normalize(cross(ww,vec3(00.,10.,00.) ));\n\tvec3 vv=normalize(cross(uu ,ww));\n\n\t// Ray direction\n\tvec2 o=uv-vec2(.5,.5); o.x*=iResolution.x/iResolution.y;\n\tvec3 rd=normalize(o.x*uu+o.y*vv+ww);\n\n\t// Apply PBR to get final color\n\tfragColor=PBR(ro ,rd );\n}","name":"Image","description":"","type":"image"}]}