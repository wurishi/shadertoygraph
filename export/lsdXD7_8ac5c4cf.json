{"ver":"0.1","info":{"id":"lsdXD7","date":"1459826327","viewed":441,"name":"Sphere complex","username":"Fluffy","description":"Infinite spheres raymarched with a minimum marching distance.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define REFLECTIONS 2\n#define GLOSSY 0.9\n\n#define PI 3.14159265359\nvec3 sunDir;\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat terrainFunction(vec3 pos)\n{\n    float d = sin(iTime / 20.0) * 0.5 + 0.75;\n    vec3 c = vec3(d);\n    pos = mod(pos, c) - 0.5 * c;\n        \n    float time = iTime * 1.0;\n    \n    vec3 nPos1 = vec3(pos.x, pos.y - 1.0, pos.z);\n    vec3 nPos2 = vec3(pos.x, pos.y + 1.0, pos.z);\n    vec3 nPos3 = vec3(pos.x, pos.y, pos.z + 1.0);\n    vec3 nPos4 = vec3(pos.x, pos.y, pos.z - 1.0);\n    vec3 nPos5 = vec3(pos.x + 1.0, pos.y, pos.z);\n    vec3 nPos6 = vec3(pos.x - 1.0, pos.y, pos.z);\n    \n    return -\n        opS(sdSphere(nPos6, 0.5),\n        opS(sdSphere(nPos5, 0.5),\n        opS(sdSphere(nPos4, 0.5),\n        opS(sdSphere(nPos3, 0.5),\n        opS(sdSphere(nPos2, 0.5),\n        opS(sdSphere(nPos1, 0.5),\n        sdSphere(pos, 1.0)))))));\n}\n\nvec3 normalAt(vec3 pos)\n{\n    float epsilon = 0.01;\n    \n    float s = terrainFunction(pos);\n    float dx = s - terrainFunction(vec3(pos.x + epsilon, pos.y, pos.z));\n    float dy = s - terrainFunction(vec3(pos.x, pos.y + epsilon, pos.z));\n    float dz = s - terrainFunction(vec3(pos.x, pos.y, pos.z + epsilon));\n                                   \n    return normalize(vec3(dx, dy, dz));\n}\n\n\nfloat march(vec3 offset, vec3 dir)\n{\n    const float minDist = 3.0;\n    const float maxDist = 20.0;\n    const float delta = 1.0;\n\tfloat amp = 0.001;\n    \n    float lastTer = 0.0;\n    float closest = 0.0;\n    \n    float d = minDist;\n    \n    for (float t = 0.0; t < 256.0; t++)\n    {\n        if (d > maxDist)\n            break;\n        vec3 pos = offset + dir * d;\n        float ter = terrainFunction(pos);\n        \n        if (ter >= amp)\n            return d - delta + delta * ((amp -lastTer) / (ter - lastTer));\n        \n        lastTer = ter;\n        \n        if (ter > closest)\n            closest = ter;\n        \n        d += delta;\n    }\n    \n    return closest - amp;\n}\n\nvec3 rotX(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cy = c * vec.y;\n    float sy = s * vec.y;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(vec.x, cy - sz, sy + cz));\n}\n\nvec3 rotY(vec3 vec, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float cx = c * vec.x;\n    float sx = s * vec.x;\n    float cz = c * vec.z;\n    float sz = s * vec.z;\n    \n    return normalize(vec3(cx - sz, vec.y, sx + cz));\n}\n\nvec3 shade(vec3 position, vec3 rayDir)\n{\n    vec3 col = vec3(sin(iTime / 13.0) * 0.3 + 0.5, 0.8, sin(iTime / 4.0) * 0.2 + 0.8);\n    \n    float mul = 1.0;\n    \n    for (int i = 0; i < REFLECTIONS + 1; i++)\n    {\n    \tvec3 normal = normalAt(position);\n        col = col * (1.0 - mul) + mul * clamp(dot(normal, sunDir), 0.4, 1.0) * col * 1.4;\n        \n        vec3 dir = vec3(1.0, 0.0, 0.0);\n        col += vec3(sin(iTime / 10.0) * 0.5 + 0.5, 0.2, 0.6) * clamp(dot(normal, dir), 0.0, 1.0) * 0.5;\n        col *= sin(iTime / 4.0) / 4.0 + 1.0;\n        \n        rayDir = reflect(rayDir, normal);\n        \n        float dist = march(position, rayDir);\n        if (dist >= 0.0)\n            position = (position + rayDir * dist);\n        else\n            break;\n        \n        mul *= GLOSSY;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunDir = normalize(vec3(0.0, sin(iTime), cos(iTime)));\n    \n    vec3 cameraPos = vec3(sin(iTime / 7.0), sin(iTime / 5.0) * 3.0, sin(iTime / 13.0));\n    float focalLength = sin(iTime / 2.0) * 4.0 + 5.0;\n    float x = fragCoord.x / iResolution.x - 0.5;\n    float y = (fragCoord.y / iResolution.y - 0.5) * (iResolution.y / iResolution.x);\n    \n    float lookX = iTime / 4.0;\n    float lookY = iTime / 5.18513;\n    \n    vec3 rayDir = normalize(vec3(x * focalLength, -1, y * focalLength));\n    rayDir = rotX(rayDir, lookX);\n    rayDir = rotY(rayDir, lookY);\n    \n    float dist = march(cameraPos, rayDir);\n    if (dist < 0.0)\n        return;\n    \n    vec3 pos = (cameraPos + rayDir * dist);\n    \n\tvec3 color = shade(pos, rayDir);\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}