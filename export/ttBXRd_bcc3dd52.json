{"ver":"0.1","info":{"id":"ttBXRd","date":"1617245025","viewed":95,"name":"Crashed City","username":"dirkadirkadan","description":"Crashed alien structure in a city","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    fragColor = tex;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPS .001625\n#define SAMPLES 1.\n#define MAX_DISTANCE 90.\n#define LIGHT_INTENSITY 2.\n#define LIGHT_COLOR vec3(1., 1., .9997)\n#define STEP .399\n\n#define MODE ;\n\n#define FRACTAL_ITER 14\n\nfloat conv_factor = .405;\nvec3 init_pos = vec3(0.5, .3125, 0.);\nvec3 ldir = normalize (vec3(.1, -.3, .2));\nvec3 amb = vec3(.0);\n\n\n//#define ITERATIONS int(clamp(iTime*2.,20.,200.))\n\n#define ITERATIONS 165\n\n#define FLOOR   \t\t2\n#define WALL    \t\t3\n#define YELLOW_CONCRETE 4\n#define RED_CONCRETE \t5\n#define FLORETS \t\t6\n#define GLASS\t\t\t7\n#define JOINER \t\t\t8\n#define SKY\t\t\t\t9\n\n\nint matid;\n\nfloat dist_test(float current_min_dist, float test_distance, int mat)\n{\n    float d = current_min_dist;\n    \n    if (test_distance < current_min_dist)\n    {\n        d = test_distance;\n        matid = mat;\n    }\n    \n    return d;\n\n}\n\n\nmat3 material(vec3 p)\n{\n    mat3 m;\n    \n    m[0] = vec3(1.);\n    m[1].x = 0.;\n    m[1].y = 1.;\n        \n    if (matid == FLOOR)\n    {\n        m[0] = texture(iChannel0, .9*p.xz).rgb;\n        m[1].x = .418;\n        m[1].x = .590099760925;\n        m[1].y = .25000412293199;\n        \n//        m[0] = vec3(0., 0.2, .9);\n        m[1].y = 0.5;\n        m[1].x = 0.5*sin(iTime*.01)+0.5;;\n    }\n    \n    else if (matid == WALL)\n    {\n        m[0] = vec3(1.);\n        m[1].x = .69999489990;\n        m[1].y = .75990999;\n    }\n    \n    else if (matid == YELLOW_CONCRETE)\n    {\n        m[0] = vec3(.95, .95, .8);\n        m[1].x = 0.;\n        m[1].y = .0075;\n    }\n    \n    else if (matid == RED_CONCRETE)\n    {\n        m[0] = vec3(.2, 0.1, 0.1);\n        m[1].x = 0.0;\n        m[1].y = .02;\n    }\n    \n    else if (matid == FLORETS)\n    {\n        vec3 green = vec3(0., .7, 0.);\n        vec3 cray = clamp(vec3(sin(p.z+p.x), cos(p.z*3.), sin(p.y*p.z)), .0, 1.);\n        m[0] = mix(green, cray, clamp(sin(8.2*(p.x+p.y)), .0, 1.));\n        //m[0] = vec3(1.);\n        m[0] = vec3(.4, .4, .4);\n        m[0] = vec3(1.);\n        m[1].x = 0.995;\n        m[1].y = .059006;\n    }\n    \n    else if (matid == GLASS) {\n        m[0] = vec3(.3, .5, .9);\n        m[1].x = 0.999;\n        m[2].y = 1.;\n    }\n    \n    else if (matid == JOINER) {\n        m[0] = vec3(1.);\n        m[1].x = .8;\n        m[1].y = .6;\n    }\n    \n    else if (matid == SKY) {\n        m[0] = vec3(.3, .5, .9);\n        m[1].x = 0.999;\n        m[2].y = 1.;\n    }\n    \n//    if (matid != FLOOR)\n//        m[0] = vec3(.1);\n    \n    return m;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n//         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat de_meng(vec3 q)\n{\n    matid = WALL;\n    // Layer one. The \".05\" on the end varies the hole size.\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .35;\n    \n    // Layer two.\n    p =  abs(fract(q) - .5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\n   \n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \n\n    // Layer four. The little holes, for fine detailing.\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\n\n}\n\nfloat de_sierp (vec3 p)\n{\n    vec3 op = p;\n    float Scale = 1.9;\n    float Offset = 3.3;\n   float r;\n    int n = 0;\n    while (n < 10) {\n       if(p.x+p.y<0.) p.xy = -p.yx; // fold 1\n       if(p.x+p.z<0.) p.xz = -p.zx; // fold 2\n       if(p.y+p.z<0.) p.zy = -p.yz; // fold 3\t\n       p = p*Scale - Offset*(Scale-1.0);\n       n++;\n    }\n    float s = (length(p) ) * pow(Scale, -float(n));\n\tfloat f = op.y+.1;\n    \n    float d = 1000.;\n    d = dist_test(d, s, WALL);\n    d = dist_test(d, f, FLOOR);\n    \n    return d;\n}\n\nfloat sky (vec3 z) {\n//    return abs(length(z - vec3(1., .3, -1.)) - 4.);\n    return sdBox(z - vec3(1., -.3, -1.), vec3(.2));\n}\n\nfloat bldg1panes (vec3 z) {\n    float pane_thickness = .00725;\n    float panes = mod(z.y, .1)-pane_thickness;\n    panes = min(panes, mod(z.x, .1)-pane_thickness);\n    panes = min(panes, mod(z.z, .1)-pane_thickness);\n    \n    return panes;\n}\n\nfloat bldg1windows (vec3 z, float panes) {\n//    return 10.;\n    vec3 pos = vec3(-.4, -2., -4.5);\n    float main_box = sdBox(z - vec3(1., -.3, -1.), vec3(.2, 1.6, .2));\n    //sdBox(z - pos, vzec3(.75, 6., 2.));\n    \n//    removals = length(z - vec3(.77, .1, -.565)) - .3;\n//    return removals;\n  return max(main_box, -panes);  \n}\n\nfloat ground (vec3 z) {\n    \n    float flr = z.y + .3 - texture(iChannel0, .9*z.xz).b*.005;\n    flr = z.y + .3;\n\n    return flr;\n}\n\nfloat alien_structure(vec3 z) {\n    \n    float rep = 2.0;\n    \n    z.xz = mod(z.xz, rep) - .5*rep;\n\n    float Scale = 1.9;\n\tfloat Offset = .73;\n\n\tfloat th = conv_factor*sin(.6*171.45);\n\tfloat ct = cos(th);\n\tfloat st = sin(th);\n\tmat3 rot = mat3(ct, 0., st, 0., 1., 0., -st, 0., ct);\n\t\n    float r;\n    int n = 0;\n    while (n < FRACTAL_ITER) {\n\t\t\tz = rot * z;\n       if(z.x+z.y<0.) z.xy = -z.yx; // fold 1\n       if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n       if(z.y+z.z<0.) z.zy = -z.yz; // fold 3\t\n       z = z*Scale - Offset*(Scale-1.0);\n       n++;\n    }\n    \n       \n    float tri = (length(z) ) * pow(Scale, -float(n));\n\treturn tri;\n}\n\nfloat de(vec3 z)\n{\n    matid = WALL;\n\n    float d = 10000.;\n    d = dist_test(d, alien_structure(z), FLORETS);\n    d = dist_test(d, bldg1windows(z, bldg1panes(z)), GLASS);\n    d = dist_test(d, ground(z), FLOOR);\n //   d = dist_test(d, sky(z), SKY);\n\n    return d;\n}\n\n\nfloat de_highway(vec3 p)\n{\n\tfloat f = p.y+.1;\n    \n    ldir=vec3(1.,0.,0.);\n    \n    float r1h = 2.;\n    \n    vec3 q = p - vec3(1.2, r1h, 0.);\n    \n    q.x -= 2.5*sin(q.z*.8);\n    \n    float r1 = sdBox(q, vec3(.5, .4, 10.));\n    \n    vec3 qc = q;\n    qc.y += r1h;\n    qc.z = mod(qc.z, 2.) -1.;\n    \n    float cols = sdBox(qc, vec3(.2, r1h, .1));\n\n    float d = 1000.;\n    d = dist_test(d, r1, YELLOW_CONCRETE);\n    d = dist_test(d, f, FLOOR);\n    d = dist_test(d, cols, RED_CONCRETE);\n    \n    return d;\n}\n\nfloat de_dome(vec3 p)\n{\n\tfloat sphere = length(p)-.5;\n    float bump = texture(iChannel0, .9*p.xz).r*.01;\n    //bump = 0.;\n    float flr = p.y + .2 - bump;\n    \n//    return flr;\n    \n    float box = sdBox(mod(p, .1)-.05, vec3(.035));\n    \n    sphere = max(sphere,-box);\n    \n    float d = 100.;\n    d = dist_test(d, sphere, WALL);\n    d = dist_test(d, flr, FLOOR);\n    \n    return d;}\n\nvec3 norm(vec3 p)\n{\n    float d = de(p);\n    \n    float x = de(vec3(p.x+EPS, p.y, p.z)) - d;\n    float y = de(vec3(p.x, p.y+EPS, p.z)) - d;\n    float z = de(vec3(p.x, p.y, p.z+EPS)) - d;\n\n    return normalize(vec3(x,y,z));\n}\n\n\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\nvec2 hash2( const vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));\n}\nvec3 hash3( const vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(36.5453123,43.1459123,11234.3490423));\n}\n\n\nvec2 rv2;\n\n\n#ifndef M_PI\n#define M_PI                (3.1415926535897932384626433832795)\n#endif\n\nvec2 seed;\n\nvec2 rand2n() {\n    seed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n();\n\tr.x=r.x*2.*M_PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n \nvec3 getSample(vec3 dir) {\n\treturn getSampleBiased(dir,0.0); // <- unbiased!\n}\n\nvec3 getCosineWeightedSample(vec3 dir) {\n\treturn getSampleBiased(dir,1.0);\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n    // Formula 34 in GI Compendium\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r =  rand2n();\n\tr.x=r.x*2.*M_PI;\n\tr.y=1.0-r.y*extent;\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n\nvec3 cosWeightedRandomHemisphereDirection2( const vec3 n ) {\n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\n\nvec3 bounce(vec3 rd, vec3 nrm, mat3 material)\n{\n    float reflectance = material[1].x;\n   \n    rd = reflect(rd,nrm);\n    rd = reflectance*rd + (1.-reflectance)*getSample(nrm);\n    rd = normalize(rd);\n \n    return rd;\n    return reflect(rd, nrm);\n}\n\nvec3 getBrdfRay(vec3 eye, vec3 n)\n{\n    return cosWeightedRandomHemisphereDirection2(n);\n}\n\nvec3 fog(vec3 col, float dist)\n{\n    float amount = 1. - exp(-dist*.0072);\n    vec3 fogColor = vec3(.5, .6, 1.);\n    return mix(col, fogColor, amount);\n}\n\n\nvoid march(vec3 ro, vec3 rd, vec2 uv, out vec3 col)\n{\n    vec3 orig_ro = ro;\n    float d = 0.;\n    \n    bool hit = false;\n    vec3 pt = orig_ro;\n\n    vec3 lo = vec3(0.);\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        pt = ro + rd * d;\n        \n        float s = de(pt);        \n        d += STEP*s;\n        \n        if (s < EPS)\n        {\n            if (!hit) lo = LIGHT_INTENSITY * LIGHT_COLOR; hit = true;           \n            mat3 mat = material(pt);            \n            vec3 n = norm(pt);            \n            lo *= lo * 2. * mat[1].y * mat[0];\n            rd = bounce(rd, n, mat);\n\n            lo *= dot(n, rd);\n            \n            ro = pt;\n            d = EPS*2.;\n            \n            MODE\n        }\n        \n        if (s > MAX_DISTANCE)\n        {\n            break;\n        }\n    }\n    \n    float mr = 1.;\n    vec3 sky = vec3(mr, clamp(sqrt(uv.y+.3), 0.4, mr), 1.);\n    vec3 fogclr = vec3(.6);\n                           \n    col = hit ? clamp(amb+lo*clamp(dot(ldir,-rd),0.,1.)*1.,0.,1.) + .01 * sky: sky;\n    float final_dist = length(pt-orig_ro);\n    float fog = exp(-pow(final_dist,.2) * 5.12570555525052);\n    if (hit) col = mix(col, fogclr, fog);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    rv2 = hash2(iTime);\n  \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float blur = .0;\n        \n    vec3 ro = init_pos;\n    vec3 rd = normalize(vec3(uv*(1.-blur)+rv2*blur, -1.));\n\n    vec3 acc = vec3(0.);\n    \n    vec3 prev_col = vec3(0.);\n    \n    float th = 0.;//2.05;\n    float ct = cos(th);\n    float st = sin(th);\n    mat2 rot = mat2(ct, -st, st, ct);\n    rd.xz = rot * rd.xz;\n    \n    for (int i = 0; i < int(SAMPLES); i++)\n    {\n        prev_col = col;\n\t    seed = uv * (float(i) + iTime + 1.0);\n\t    rv2 = hash2(iTime+float(i)*rv2);\n        march(ro, rd, uv, col);\n\t//\tacc += max(prev_col, col);//max(acc/float(i+1),col);\n       acc += col;\n    }\n    \n    acc /= SAMPLES;\n\n    fragColor = vec4(acc,0.);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define SAMPLING clamp(float(iTime)*4.,3.,200.)\n\n//#define SAMPLING 30.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float weight = 1./SAMPLING;\n    vec4 tex = weight*texture(iChannel0, uv)+(1.-weight)*texture(iChannel1,uv);\n    fragColor = tex;\n}","name":"Buffer B","description":"","type":"buffer"}]}