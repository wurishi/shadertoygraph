{"ver":"0.1","info":{"id":"WtjBWt","date":"1600154787","viewed":419,"name":"Specular roughness with LOD+bump","username":"athibaul","description":"Who spilled paint on those balls?","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["bumpmapping","imagebasedlighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_BLUR0 1.\n#define MAX_BLUR0 32.\n#define MIN_LOD1 0.\n#define MAX_LOD1 8.\n#define GAMMA 2.2\n\n\n#define MAPMIN(a,b) (b.x < a.x) ? b : a\n\nstruct Material\n{\n    vec3 baseColor;\n    float metallic;\n    float roughness;\n};\n  \nconst vec3 DIELECTRIC_F0 = vec3(0.04);\nconst Material CHROME = Material(vec3(0.9,0.92,0.95), 1.0, 0.0);\nconst Material RED_PLASTIC = Material(vec3(0.95,0.3,0.2), 0.0, 0.3);\nconst Material BLUE_GRIME = Material(vec3(0.0,0.4,0.7), 0.0, 1.0);\nconst Material BLACK_PLASTIC = Material(vec3(0), 0.0, 0.0);\nconst Material GREEN_PLASTIC = Material(vec3(0.2,0.9,0.2), 0.0, 0.6);\n\nMaterial matmix(Material a, Material b, float x)\n{\n    return Material(mix(a.baseColor, b.baseColor, x),\n                    mix(a.metallic, b.metallic, x),\n                    mix(a.roughness,  b.roughness, x));\n}\n\n// Image-based lighting trick by reinder:\n// To approximate the integrated specular lobe in\n// environment maps, we can use them with\n// varying levels of detail.\n// https://www.shadertoy.com/view/lscBW4\n// https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n\n// Main problem : the mipmapping produces artifacts at object boundaries.\nvec3 getSpecularLightColor( vec3 rd, float roughness )\n{\n    roughness = clamp(roughness, 0.0, 1.0);\n    //float lod0 = mix(0.0, 8.0, roughness);\n    float lod0 = log2(MIN_BLUR0 + (MAX_BLUR0-MIN_BLUR0) * roughness);\n    float lod1 = mix(MIN_LOD1, MAX_LOD1, roughness);\n    vec3 t0 = pow(textureLod(iChannel0, rd.xzy, lod0).rgb, vec3(GAMMA));\n    vec3 t1 = pow(textureLod(iChannel1, rd.xzy, lod1).rgb, vec3(GAMMA));\n    //return 0.5+0.5*rd.xzy;\n    //return texture(iChannel0, rd.xzy, 0.).rgb;\n    return 3.0*mix(t0, t1, smoothstep(0.25,0.8,roughness));\n}\n\nvec3 getDiffuseLightColor( vec3 rd )\n{\n    // So yeah, we don't really have a diffuse model\n    return getSpecularLightColor(rd, 1.0);\n}\n\n\nvec4 map(vec3 p);\n// Stolen from iq\n// https://www.shadertoy.com/view/Xds3zN\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.z);\n}\n\n\nvec3 renderMaterial( vec3 p, vec3 rd, vec3 normal, Material mat )\n{\n    vec3 diffuseCol = getDiffuseLightColor(normal) * mat.baseColor * (1.0-mat.metallic);\n    float ao = calcAO(p, normal);\n    vec3 specularCol = getSpecularLightColor(reflect(rd, normal), mat.roughness);\n    vec3 F0 = mix(DIELECTRIC_F0, mat.baseColor, mat.metallic);\n    //vec3 F0 = DIELECTRIC_F0;\n    vec3 fre = F0 + (1.0-F0)*pow(clamp(1.0-dot(-rd,normal),0.0,1.0), 5.0);\n    //vec3 fre = F0;\n    vec3 col = mix(diffuseCol, specularCol, fre)*ao;\n    //col = specularCol;\n    return col;\n}\n\n\nvec4 map( vec3 p )\n{\n    // map() -> vec4(d, normal)\n    p.xy = mod(p.xy+0.5, 1.0)-0.5;\n    vec4 d = vec4(length(p)-0.4, normalize(p));\n    d = MAPMIN(d, vec4(p.z+0.41, vec3(0,0,1)));\n\treturn d;\n}\n\nfloat bump( vec3 p )\n{\n    if(p.z > -0.4 && mod(p.x-0.5, 2.0) < 1.0)\n        return 0.;\n    p = vec3(p.x+p.y, p.x-p.y, sqrt(2.)*p.z);\n    p = vec3(p.x+p.z, sqrt(2.)*p.y, p.x-p.z);\n    p = fract(p*10.);\n    float d = length(p - 0.5);\n    return d*0.004;\n}\n\nfloat bumpMap( vec3 p )\n{\n    return map(p).x - bump(p);\n}\n\n\nvec3 calcNormal( vec3 p )\n{\n    float eps = 1e-3;\n    vec2 e = eps*vec2(1,-1);\n    return normalize(\n          e.xxx*bumpMap(p+e.xxx)\n        + e.xyy*bumpMap(p+e.xyy)\n        + e.yxy*bumpMap(p+e.yxy)\n        + e.yyx*bumpMap(p+e.yyx));\n}\n\n\nMaterial getMaterial( vec3 p )\n{\n    Material mat;\n    if(p.z < -0.4)\n        mat = GREEN_PLASTIC;\n    else if (mod(p.x-0.5, 2.0) < 1.0)\n        mat = RED_PLASTIC;\n    else\n        mat = CHROME;\n        \n    float grime = smoothstep(0.1,0.6,texture(iChannel2,p.xy*0.1).r);\n    mat = matmix(mat, BLUE_GRIME, grime);\n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.x;\n    \n    float th = iTime * 0.1;\n    vec3 ro = vec3(3.0*cos(th), 3.0*sin(th), 3.0);\n    vec3 target = vec3(0);\n    vec3 camFwd = normalize(target-ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0,0,1)));\n    vec3 camUp = cross(camRight, camFwd);\n    float fov = 0.5;\n    vec3 rd = normalize(camFwd + fov*(uv.x*camRight + uv.y * camUp));\n    \n    vec3 col;\n    \n    #if 0\n    {\n    vec3 rdScreen = normalize(vec3(uv.x, uv.y, 2));\n    vec3 rd = rdScreen;\n    float th = 0.2*iTime;\n    float th2 = -sin(0.2*iTime);\n    rd.yz *= mat2(cos(th2),sin(th2),-sin(th2),cos(th2));\n    rd.xz *= mat2(cos(th),sin(th),-sin(th),cos(th));\n    \n    float nSpheres = 7.0;\n    vec2 c = 2./nSpheres * round(uv*nSpheres/2.);\n    c.x = clamp(c.x,-1.0,1.0);\n    c.y = clamp(c.y, -2.0/nSpheres, 0.0);\n    vec3 normal;\n    float d = length(uv - c) * nSpheres;\n    \n    col = getSpecularLightColor(rd, 0.0);\n   \tif(d < 0.98)\n    {\n        normal = normalize(vec3(uv-c, -sqrt(1.0-d*d)));\n        vec3 rr = reflect(normalize(vec3(uv-c, 2)), normal);\n        rr.yz *= mat2(cos(th2),sin(th2),-sin(th2),cos(th2));\n        rr.xz *= mat2(cos(th),sin(th),-sin(th),cos(th));\n        float roughness = smoothstep(-1.0, 1.0, c.x);\n        if(c.y < 0.0)\n        \troughness = mix(roughness, 1.0, texture(iChannel2, nSpheres*uv).r);\n        col = getSpecularLightColor(rr, roughness);\n    }\n    }\n    #endif\n    \n    vec4 d;\n    float t=0.0;\n    for(int i=0;i<256;i++)\n    {\n        d = map(ro+t*rd);\n        if(d.x < 0.001 || t > 100.) break;\n        t += d.x;\n    }\n    \n    if(d.x < 0.001)\n    {\n        vec3 p = ro+t*rd;\n        col = 0.1*vec3(t);\n        vec3 normal = calcNormal(p);\n        //vec3 normal = d.yzw;\n        Material mat = getMaterial(p);\n        col = renderMaterial(p, rd, normal, mat);\n        //col = mat.baseColor;\n        //col = 0.5+0.5*vec3(normal.x, p.z-0.4, normal.y);\n        //col = 0.5+0.5*normal;\n        //col = vec3(calcAO(p, normal));\n        //col = 0.5+0.5*vec3(reflect(rd, normal));\n    }\n    else\n    {\n        col = getSpecularLightColor(rd, 0.0);\n    }\n    \n    col = pow(col, vec3(1.0/GAMMA));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}