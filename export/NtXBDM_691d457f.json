{"ver":"0.1","info":{"id":"NtXBDM","date":"1650936810","viewed":116,"name":"Blue Haze","username":"TinyTexel","description":"best viewed in fullscreen","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n// x: [0, inf], s: (-1, 1]\nfloat SoftClip(float x, float s)\n{\n    return (1.0 + x - sqrt(1.0 - 2.0 * s * x + x*x)) / (1.0 + s);\n}\n\nfloat SoftClip(float x, float s, float start)\n{\n    if(x <= start) return x;\n    \n    float sx = 1.0 / (1.0 - start);\n    float ax = -start * sx;\n    \n    float sy = 1.0 - start;\n    float ay = start;\n    \n    return SoftClip(x * sx + ax, s) * sy + ay;\n}\n\nvec3 SoftClip(vec3 v, float s)\n{\n    return vec3(SoftClip(v.x, s),\n                SoftClip(v.y, s),\n                SoftClip(v.z, s));\n}\n\n\nfloat Toe(float x, float s)\n{\n    return x * (1.0 + s * (-1.0 + x * (2.0 - x)));\n}\n\nfloat Toe(float x, float s, float end)\n{\n    if(x >= end) return x;\n    \n    return Toe(x / end, s) * end;\n}\n\nvec3 Toe(vec3 x, float s, float end)\n{\n    return vec3(Toe(x.x, s, end),\n                Toe(x.y, s, end),\n                Toe(x.z, s, end));\n}\n\n\nfloat Bias(float x, float bias)\n{\n\treturn (x / ((((1.0/bias) - 2.0)*(1.0 - x))+1.0));\n}\n\n\nfloat Reinhard(float x, float s, float start)\n{    \n    if(x <= start) return x;\n \n #if 0\n    x = x / (1.0 - start) - start / (1.0 - start);// use if start is const\n #else\n    x = (x - start) / (1.0 - start);\n #endif\n\n    x += x * x * s;\n    //x = (x + x*x) * x + x;\n    x += x * x * (s*s);\n    float y = x / (x + 1.0);\n    \n    return y * (1.0 - start) + start;\n}\n\n\nvec3 Tonemap_sRGB(vec3 col, float shoulderStrength, float toeStrength, float desatBias)\n{\n    vec3 wL = vec3(0.212586230785595520, 0.71517030370341080, 0.07220049864333620);\n    \n    float L0 = dot(col, wL);\n\n    float L0t = Reinhard(L0, shoulderStrength, 0.18);\n\n    L0t = clamp01(L0t);\n\n    col *= L0t / L0;\n\n\n    float L1 = max(col.r, max(col.g, col.b));\n\n    float L1t = SoftClip(L1, 0.9);\n\n    col *= L1t / L1;\n\n\n    float L2 = dot(col, wL);\n\n    float sat = (L2 - L0t) / (L2 - 1.0);\n    \n    sat = Bias(sat, desatBias);\n    \n    col = mix(col, vec3(1.0), sat);\n\n\n    col = Toe(col, toeStrength, 0.18);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n#if 0\n    {\n        outCol.rgb = texelFetch(iChannel1, ivec2(uv0-0.5), 0).rgb;\n        outCol.a = 0.0;\n        return;\n    }\n#endif\n    // Time varying pixel color\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col = texelFetch(iChannel0, ivec2(uv0-0.5), 0).rgb;\n\n    vec2 tc = uv0 / iResolution.xy;\n    \n    #if 1\n    {\n        vec3 c0 = vec3(0.0);\n        vec3 c1 = vec3(0.0);\n        vec3 wa = vec3(0.0);\n        float count = 4.0;\n        for(float i = -count; i <= count; ++i)\n        {\n            vec3 w = vec3(1.0);\n            //w = abs(i)<2.0 ? 2.0 : 1.0;\n            //w = mix(vec3(1.0), vec3(1.0, 0.9, 0.9), abs(i)/count);\n            //w = 1.0 - abs(i)/(count-1.0);\n            float hu = abs(i)/count;\n            //hu = 1.0-pow(1.0-hu,2.0);\n            w = Hue_to_RGB((hu)*0.75 + (tc.y+tc.y*tc.y)*-0.1);\n            //w = Hue_to_RGB((abs(i)/count)*0.7 + (tc.y)*-0.);\n            //w = Hue_to_RGB((abs(i)/count)*0.9);\n//            w*=w;\n            w = mix(vec3(-0.2), vec3(1.0), w);\n            \n            float r = 2.6 + tc.y*tc.y*0.5;\n            \n            c0 += textureLod(iChannel0, (uv0 + i * vec2(1.0, 1.0)*r) / iResolution.xy, 0.0).rgb * w;\n            c1 += textureLod(iChannel0, (uv0 + i * vec2(1.0,-1.0)*r) / iResolution.xy, 0.0).rgb * w;\n            wa += w;\n        }\n        c0 /= wa;\n        c1 /= wa;\n\n        vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n        s *= s; s *= s; s *= s; s = 1.0 - s;\n        float u = 1.0 - (s.x*s.y);\n        \n        col *= max((c0 + c1)*0.5 - col, 0.0) * 1.0 + 1.0;\n        col = mix(col, (c0 + c1)*0.5, 0.5);\n    }\n    #endif\n   \n \n    #if 1\n    {\n        vec2 vec = (uv0 - iResolution.xy)/iResolution.xx;\n        float d2 = dot(vec, vec);\n        col *= 1.3;\n        col *= 1.0 + pow(max(1.0 - d2*1.0, 0.0), 2.0) * 0.3;\n        col += vec3(1.0, 1.0, 0.65) * pow(max(1.0 - d2*0.2, 0.0), 18.0) * 0.12;\n    }\n    #endif\n    \n    col *= mix(col, vec3(1.0), -0.63)*1.5;\n    col = mix(col, Tonemap_sRGB(max(col, 0.0), 1.0, 0.0, 0.25), 0.75);\n   \n    //col = clamp01(col);\n    #if 1\n    {\n        vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n        s *= s; s *= s; s *= s; s = 1.0 - s;\n        float u = 1.0 - sqrt(s.x*s.y);\n        //col *= mix(1.0, 0.5, u*u);\n        col *= mix(vec3(1.0), mix(col, vec3(1.0), 0.3), u*u);\n    }\n    #endif  \n    \n    #if 1\n    {\n        vec3 n = Hash01x3(uv0, 0x8A554E9Eu).rgb * 1.;\n        n = 1.0 - 2.0 * abs(fract(n + iTime) * 2.0 - 1.0);\n        col += n * 0.01;\n    }\n    #endif\n    \n    col = sRGB_Encode(clamp01(col));\n    \n    #if 1\n    {\n        float r2 = fract(dot(uv0-0.5, vec2(0.7548776662, 0.56984029)));\n        r2 = abs(r2 * 2.0 - 1.0);\n        col += (r2 * 2.0 - 1.0) * 0.01;\n    }\n    #endif    \n    \n    outCol = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 Resolution;\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n#define KEY_Z 90\n#define KEY_U 85\n#define KEY_I 73\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_Y 89\n#define KEY_X 88\n#define KEY_C 67\n#define KEY_V 86\n#define KEY_B 66\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_N0 48\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n#define KEY_N9 57\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvec2 CosSin(float x)\n{\t\n\treturn vec2(cos(x), sin(x));\n}\n\nvec2 CmplxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x); \n}\n\nvec2 Rotate(vec2 v, float ang)\n{\n    return CmplxMul(v, CosSin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat sRGB_Encode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_Decode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_Encode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_Decode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n    \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n\nvec4  Hash01x4(inout uint state) { return Float01(pcg4(state)   ); }\nvec3  Hash01x3(inout uint state) { return Float01(pcg3(state)   ); }\nvec2  Hash01x2(inout uint state) { return Float01(pcg3(state).xy); }\nfloat Hash01  (inout uint state) { return Float01(pcg (state)   ); }\n\nvec4  Hash11x4(inout uint state) { return Float11(pcg4(state)   ); }\nvec3  Hash11x3(inout uint state) { return Float11(pcg3(state)   ); }\nvec2  Hash11x2(inout uint state) { return Float11(pcg3(state).xy); }\nfloat Hash11  (inout uint state) { return Float11(pcg (state)   ); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) *  (1.0/6.0) + (1.0/3.0);\n    \n    return (rgb.b < rgb.g ? -v : v) + 0.5;     \n}\n\nvec3 RGB_to_HSV(vec3 rgb)\n{\n    float v = max(rgb.r, max(rgb.g, rgb.b));\n    \n    if(v == 0.0) return vec3(0.0);\n    \n    rgb /= v;\n    \n    float ds = min(rgb.r, min(rgb.g, rgb.b));\n    float s = 1.0 - ds;\n    \n    if(ds == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - ds) / s;\n    \n    float h = RGB_to_Hue(rgb);\n    \n    return vec3(h, s, v);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nfloat SimplexNoise(vec3 x, uint seed)\n{\n    // https://en.wikipedia.org/wiki/Simplex_noise\n    float F = 1.0/3.0;\n    float G = 1.0/6.0;\n    \n    vec3 xp = x + dot(x, vec3(1.0)) * F;\n    \n    vec3 xb = floor(xp);\n    vec3 xi = xp - xb;\n \n    vec3 m0 = step(0.0, xi - xi.zxy);\n    vec3 m1 = 1.0 - m0;\n    \n    vec3 v0 = vec3(0.0);\n\tvec3 v1 =       m0.xyz * m1.yzx;\n\tvec3 v2 = 1.0 - m0.yzx * m1.xyz;\n    vec3 v3 = vec3(1.0);\n    \n    vec3 o = x - xb + dot(xb, vec3(1.0)) * G;\n    \n    vec3 off0 = o - v0 + 0.0 * G;\n    vec3 off1 = o - v1 + 1.0 * G;\n    vec3 off2 = o - v2 + 2.0 * G;\n    vec3 off3 = o - v3 + 3.0 * G;\n     \n    #define HASH(x) Hash11x3(x, seed)\n     \n    vec4 d;\n\td.x = dot(normalize(HASH(xb + v0).xyz), off0);\n\td.y = dot(normalize(HASH(xb + v1).xyz), off1);\n\td.z = dot(normalize(HASH(xb + v2).xyz), off2);\n\td.w = dot(normalize(HASH(xb + v3).xyz), off3);    \n         \n    #undef HASH\n    \n    vec4 w;\n    w.x = dot(off0, off0);\n    w.y = dot(off1, off1);\n    w.z = dot(off2, off2);\n    w.w = dot(off3, off3);\n    \n    w = max(1.0 - 2.0 * w, 0.0);\n    w *= w * w;\n    //w *= w;\n    \n    return dot(d, w) * 4.73;\n}\n\n\nvec3 SimplexNoise2(vec3 x, uint seed)\n{\n    // https://en.wikipedia.org/wiki/Simplex_noise\n    float F = 1.0/3.0;\n    float G = 1.0/6.0;\n    \n    vec3 xp = x + dot(x, vec3(1.0)) * F;\n    \n    vec3 xb = floor(xp);\n    vec3 xi = xp - xb;\n \n    vec3 m0 = step(0.0, xi - xi.zxy);\n    vec3 m1 = 1.0 - m0;\n    \n    vec3 v0 = vec3(0.0);\n\tvec3 v1 =       m0.xyz * m1.yzx;\n\tvec3 v2 = 1.0 - m0.yzx * m1.xyz;\n    vec3 v3 = vec3(1.0);\n    \n    vec3 o = x - xb + dot(xb, vec3(1.0)) * G;\n    \n    vec3 off0 = o - v0 + 0.0 * G;\n    vec3 off1 = o - v1 + 1.0 * G;\n    vec3 off2 = o - v2 + 2.0 * G;\n    vec3 off3 = o - v3 + 3.0 * G;\n     \n    #define HASH(x) Hash11x3(x, seed)\n         \n    vec4 w;\n    w.x = dot(off0, off0);\n    w.y = dot(off1, off1);\n    w.z = dot(off2, off2);\n    w.w = dot(off3, off3);\n    \n    w = max(1.0 - 2.0 * w, 0.0);\n    w *= w * w;\n    //w *= w;\n    \n    vec3 d = vec3(0.0);\n    \n    d += HASH(xb + v0) * w.x;\n    d += HASH(xb + v1) * w.y;\n    d += HASH(xb + v2) * w.z;\n    d += HASH(xb + v3) * w.w;\n    \n    #undef HASH\n    \n    return d;\n}\n\n\nfloat Noise(vec2 p)\n{\n    vec2 p0 = p;\n    \n    float t = (iTime+120.0)*0.9;\n    \n    p.y += t*0.3;\n    float v = SimplexNoise(vec3(p.xy, t * 0.2), 0xBCEE8C9Bu)*0.5+0.5;\n    v = mix(v, SimplexNoise(vec3(-p.xy*0.5, t * 0.5), 0xD4C156FDu)*0.5+0.5, 0.26);\n    \n    float ms = 0.007;\n    float m = SimplexNoise(vec3(p0.xy*ms, t * 0.02), 0x4056D460u);\n    \n    float m2 = SimplexNoise(vec3(p0.xy*ms+0.5+m*0.75, -t * 0.01), 0x1F34D2ADu);\n    \n    m *= m;\n    m2 *= m2;\n    \n    m = max(m, m2);\n    \n    v *= mix(0.7, 1.0, smoothstep(0.0, 0.5, m));\n    \n    return v;\n}\n\nvec3 Noise2(vec2 p)\n{\n    vec2 p0 = p;\n    \n    float t = (iTime+120.0)*0.9;\n    \n    p.y += t*0.3;\n    return abs(normalize(SimplexNoise2(vec3(p.xy, t * 0.2), 0xBCEE8C9Bu)));\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 tc = uv0 / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    float v = 0.0;\n    \n    vec3 p;\n    p.xy = uv0 * 0.06;\n    p.y *= 3.0;\n    p.z = 0.0;\n    \n    v = Noise(p.xy);\n    \n   #if 1\n    float r2 = fract(dot(uv0-0.5, vec2(0.7548776662, 0.56984029)));\n    r2 = fract(r2 + float(iFrame) * rPhif1);\n    //r2 = 0.5;\n    \n    float s = exp2(-3.0);\n    float norm = 1.0 / (s * 1.5);\n    float dx = 0.0;\n    float dy = 0.0;\n    for(float i = 0.0; i < 3.0; ++i)\n    {\n        float ang = Pi*2.0/3.0 * (i + r2);\n        vec2 dir = CosSin(ang);\n        float v = Noise(p.xy + dir * s);\n        dx += v * dir.x;\n        dy += v * dir.y;\n    }\n    norm *= 1.1;\n    dx *= norm;\n    dy *= norm;\n   #else\n    float s = exp2(-14.0);\n    float dx = (Noise(vec2(p.x + s, p.y)) - Noise(vec2(p.x - s, p.y))) / (s * 2.0);\n    float dy = (Noise(vec2(p.x, p.y + s)) - Noise(vec2(p.x, p.y - s))) / (s * 2.0);\n   #endif\n    \n    \n\n    col = vec3(dx, 0.0, dy) * 0.1;\n    vec3 N = normalize(vec3(-dx, -dy, 1.4));\n    \n    vec3 L = normalize(vec3(1.0, -1.0, 1.0));\n    \n\nv = v*0.5+0.5;\n    v*=v*v;\n    \n    v = smoothstep(0.95, 0.99, dot(L, N))*2.4;\n    v += 0.6*smoothstep(0.88, 0.99, dot(L, N));\n    v += 0.1*smoothstep(0.1, 0.5, N.y);\n    //v += clamp01(dot(L, N));\n    \n    //col = vec3(v);\n    vec3 c = 1.0-Noise2(p.xy).grb;\n    \n    col = vec3(0.0, mix(0.51, 0.54, tc.x), 1.0)*0.5 + v*(0.3+c*1.2);\n    \n    col = mix(col, vec3(1.0), 1.0 - exp2(-0.2*uv0.y/iResolution.y));\n    \n    //vec3 old = texelFetch(iChannel0, ivec2(uv0-0.5), 0).rgb;\n    vec3 old = textureLod(iChannel0, (uv0+0.) / iResolution.xy, 0.0).rgb;\n    #if 1\n    {\n        float s = 0.5;\n        s = mix(s, 2.8, (tc.y*tc.y)*(tc.y*tc.y));\n        old = textureLod(iChannel0, (uv0 + vec2( s, s)) / iResolution.xy, 0.0).rgb;\n        old+= textureLod(iChannel0, (uv0 + vec2(-s, s)) / iResolution.xy, 0.0).rgb;\n        old+= textureLod(iChannel0, (uv0 + vec2(-s,-s)) / iResolution.xy, 0.0).rgb;\n        old+= textureLod(iChannel0, (uv0 + vec2( s,-s)) / iResolution.xy, 0.0).rgb;\n        old *= 0.25;\n        old = mix(old, old.gbr, -0.01*(tc.y+tc.y)+0.05);\n    }\n    #endif\n    \n    //outCol = vec4(col, 0.0); return;\n    \n    col = mix(col, old, 0.95);\n    vec3 oldB = textureLod(iChannel1, (uv0+0.) / iResolution.xy, 0.0).rgb;\n    \n    //col = mix(col, oldB, 0.5);\n    \n    //col = mix(col, old, tc.y*tc.y*0.95);\n    \n    outCol.rgb = col;\n    outCol.a = v;\n}\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 tc = uv0 / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    float v = 0.0;\n    \n    vec4 c0 = textureLod(iChannel1, (uv0+0.) / iResolution.xy, 0.0);\n    col = c0.rgb + c0.aaa*0.5;\n    vec3 old = textureLod(iChannel0, (uv0+0.) / iResolution.xy, 0.0).rgb;\n    #if 1\n    {\n        float s = 3.5;\n        //s = mix(s, 2.8, tc.y*tc.y);\n        old = textureLod(iChannel0, (uv0 + vec2( s, s)) / iResolution.xy, 0.0).rgb;\n        old+= textureLod(iChannel0, (uv0 + vec2(-s, s)) / iResolution.xy, 0.0).rgb;\n        old+= textureLod(iChannel0, (uv0 + vec2(-s,-s)) / iResolution.xy, 0.0).rgb;\n        old+= textureLod(iChannel0, (uv0 + vec2( s,-s)) / iResolution.xy, 0.0).rgb;\n        old *= 0.25;\n        //old = mix(old, old.gbr, -0.01*(tc.y+tc.y)+0.05);\n    }\n    #endif\n    \n    col = mix(col, old, 0.96);\n    //col = mix(col, old, tc.y*tc.y*0.95);\n    \n    outCol.rgb = col;\n    outCol.a = 1.0;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 tc = uv0 / iResolution.xy;\n    // Time varying pixel color\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col = texelFetch(iChannel0, ivec2(uv0-0.5), 0).rgb;\n    vec3 col2 = texelFetch(iChannel1, ivec2(uv0-0.5), 0).rgb;\n\n    #if 1\n    float w = dot(col, vec3(1.0))*0.333;\n    w *= w;\n    w *= w;\n    \n    col2 = mix(col2, col2.bgr*1., 0.2*tc.x*(1.0-tc.y));\n    col2 = mix(col2, col2.brg*1.2, 3.0*w*(1.0-tc.x)*(tc.y));\n    #endif\n    \n    //col2*=vec3(0.8, vec2(0.99));\n    //col *= pow(max(col2 - col, 0.0)*8.0,vec3(3.0))+1.0;\n    col = mix(col, col2*1.0, 0.4+tc.y*tc.x*0.3);\n    //col = max(col, col2);\n    //col = col2;\n\n    outCol = vec4(col,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    // Time varying pixel color\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    col = texelFetch(iChannel0, ivec2(uv0-0.5), 0).rgb;\n    // Output to screen\n\n    #if 1\n    {\n        vec2 vec = (uv0 - iResolution.xy*0.5)/(iResolution.xy*0.5);\n        float r2 = fract(dot(uv0-0.5, vec2(0.7548776662, 0.56984029)));\n        //r2 = abs(r2 * 2.0 - 1.0);\n        \n        vec3 c0 = vec3(0.0);\n        vec3 wa = vec3(0.0);\n        float count = 8.0;\n        vec *= mix(dot(vec, vec), 1.0, 0.5);\n        vec /= count;\n        vec *= -10.0;\n        for(float i = 0.0; i < count; ++i)\n        {\n            float j = i + 0.5;\n            vec3 w = vec3(1.0);\n            //w = mix(vec3(1.0), vec3(1.0, 0.9, 0.9), abs(i)/count);\n            //w = 1.0 - abs(i)/(count-1.0);\n            vec3 w3 = Hue_to_RGB((1.0-j/count)*0.7);\n            //w3*=w3;\n            w3 = mix(vec3(-0.15), vec3(1.0), w3);\n            c0 += textureLod(iChannel0, (uv0 + vec*j) / iResolution.xy, 0.0).rgb * w3;\n            wa += (w3);\n        }\n        c0 /= wa;\n        \n        col = c0;\n    }\n    #endif\n    \n    outCol = vec4(col,1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}