{"ver":"0.1","info":{"id":"mdX3WB","date":"1666719513","viewed":84,"name":"Blinn-Phong Sphere","username":"aiyopasta","description":"Hello world! My first shader here :)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["phong","raytrace","blinn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535897932384626433832795028841971\n\nfloat rho = 10.0;  // dist from world origin to eye\nfloat theta = 0.0;\nfloat phi = PI / 2.0;\nfloat focus = 1.0;  // must be less than rho!\nfloat s_width = 50.0;  // screen width, in the imaginary world (not actual screen)\n\n\n// Intersection Point\nstruct IntersectionPoint {\n    float t;\n    vec3 pos;\n    vec3 nor;\n};\n\n// Intersect ray with sphere\nIntersectionPoint intersect_sphere(vec3 origin, vec3 dir) {\n    // Sphere data\n    vec3 center = vec3(0, 0, 0);\n    float radius = 7.0;\n\n    // Find intersection point...\n    IntersectionPoint point;\n    point.t = -1.0;\n\n    // Build quadratic\n    float A = dot(dir, dir);\n    float B = 2.0 * dot(dir, origin - center);\n    float C = dot(origin - center, origin - center) - (radius * radius);\n    float disc = (B * B) - (4.0 * A * C);\n\n    // Solve quadratic\n    if (disc < 0.0) {\n        return point;\n    }\n    float t = min((-B + sqrt(disc)) / (2.0 * A), (-B - sqrt(disc)) / (2.0 * A));\n    if (t >= 0.0) {\n        point.t = t;\n        point.pos = origin + (t * dir);\n        point.nor = normalize(point.pos - center);\n    }\n    return point;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Dynamic constants\n    vec2 uv = fragCoord/iResolution.xy;\n    float AR = iResolution.x / iResolution.y;\n    float inv_AR = 1.0 / AR;\n    \n    // Get camera pos (in range [-1,1]^2) from mouse\n    vec2 mouseUV = ((iMouse.xy / iResolution.xy) * 2.0) - vec2(1.0);\n    theta -= mouseUV.x * 2.0;\n    phi += mouseUV.y * 2.0;\n    \n\n    // Point light\n    vec3 light_pos = 20.0 * vec3(1.0);\n    vec3 light_col = vec3(1.0, 0.0, 0.0);\n    vec3 ambient_col = vec3(0.3, 0.0, 0.0);\n\n    // Set eye position and virtual screen dimensions\n    vec3 eye = rho * vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n    float s_height = s_width * inv_AR;\n    \n    // Turn uv from [0,1]^2 range to [-1,1]^2 range (with y still up)\n    uv = (uv * 2.0) - vec2(1.0);\n    \n    // Single ray\n    vec3 theta_hat = vec3(-sin(theta), cos(theta), 0);\n    vec3 phi_hat = -vec3(cos(phi) * cos(theta), cos(phi) * sin(theta), -sin(phi));\n    vec3 point = (eye * (focus / rho)) + ((uv.x * (s_width / 2.0) * theta_hat) + (uv.y * (s_height / 2.0) * phi_hat));\n    vec3 ray_dir = normalize(point - eye);\n\n    IntersectionPoint isect = intersect_sphere(eye, point - eye);\n    vec3 rgb = vec3(0.0);\n    if (isect.t != -1.0) {\n        vec3 l = normalize(light_pos - isect.pos);\n        vec3 v = normalize(-ray_dir);\n        vec3 h = normalize(l + v);\n        vec3 n = isect.nor;\n\n        float ambient = 0.6;\n        float diffuse = max(dot(n, l), 0.0);\n        float specular = diffuse != 0.0 ? pow(max(dot(n, h), 0.0), 50.0) : diffuse;\n        rgb = vec3((0.3 * ambient_col * ambient) + light_col * ((0.6 * diffuse) + (0.3 * specular)));\n    }\n\n    // Gamma correct\n    rgb = pow(rgb, vec3(1.0/2.2));\n    \n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}