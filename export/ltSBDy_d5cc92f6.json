{"ver":"0.1","info":{"id":"ltSBDy","date":"1517441850","viewed":2638,"name":"flooded","username":"zguerrero","description":"Water!","likes":88,"published":1,"flags":32,"usePreview":1,"tags":["ray","terrain","sea","water","fluid","marching","ocean","distance","field"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 tex = texture(iChannel0, uv, 0.0);\n    \n    vec4 lf;\n    lf.x = texture(iChannel0, ((1.0-uv) - vec2(0.5))*0.4 + vec2(0.5)).w;\n    lf.y = texture(iChannel0, ((1.0-uv) - vec2(0.5))*1.0 + vec2(0.5)).w;\n    lf.z = texture(iChannel0, ((1.0-uv) - vec2(0.5))*1.75 + vec2(0.5)).w;\n    lf.w = texture(iChannel0, ((1.0-uv) - vec2(0.5))*10.0 + vec2(0.5)).w;\n    \n    lf = smoothstep(vec4(0.0, 0.75, 0.1, 0.0), vec4(0.25, 0.95, 0.4, 0.5), lf);\n \tfloat v = length(uv - 0.5);\n    \n    vec3 res = mix(tex.xyz, tex.xyz*tex.xyz*tex.xyz, v);\n    \n    vec3 lff = vec3(lf.x) * vec3(0.8, 0.7, 1.0)*0.125\n        \t\t+ vec3(lf.y) * vec3(1.0, 0.5, 0.6)*0.1\n     \t\t\t+ vec3(lf.z) * vec3(0.9, 0.6, 0.8)*0.2\n        \t\t+ vec3(lf.w) * vec3(1.0, 0.8, 0.5)*0.1;\n    \n\tfragColor = vec4(res + lff, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float epsilon = 0.05;\nconst int maxItter = 128;\nconst int underWaterMaxItter = 16;\nconst float maxDistance = 80.0;\nconst float waterMaxDepth = 7.0;\nconst float pi = 3.14159265359;\n\nconst vec3 color1 = vec3(0.2, 0.35, 0.45);\nconst vec3 color2 = vec3(0.3, 0.5, 0.55);\nconst vec3 color3 = vec3(0.1, 0.2, 0.3);\nconst vec3 groundColor = vec3(1.0, 0.9, 0.7);\n\nconst float wavesSize = 0.2;\nconst float wavesHeight = 1.6;\nconst float wavesSpeed = 2.0;\nconst float turbSpeed = 0.15;\n\nconst mat2 rot1 = mat2(0.99500416527,0.0998334166,-0.0998334166,0.99500416527);\nconst mat2 rot2 = mat2(0.98006657784,0.19866933079,-0.19866933079,0.98006657784);\nconst mat2 rot3 = mat2(0.95533648912,0.29552020666,-0.29552020666,0.95533648912);\nconst mat2 rot4 = mat2(0.921060994,0.3894183423,-0.3894183423,0.921060994);\nconst mat2 rot5 = mat2(0.87758256189,0.4794255386,-0.4794255386,0.87758256189);\nconst mat2 rot6 = mat2(0.82533561491,0.56464247339,-0.56464247339,0.82533561491);\nconst mat2 rot7 = mat2(0.76484218728,0.64421768723,-0.64421768723,0.76484218728);\nconst mat2 rot8 = mat2(0.69670670934,0.7173560909,-0.7173560909,0.69670670934);\nconst mat2 rot9 = mat2(0.62160996827,0.78332690962,-0.78332690962,0.62160996827);\nconst mat2 rot10 = mat2(0.54030230586,0.8414709848,-0.8414709848,0.54030230586);\n\n#define LIGHT normalize(vec3(0.0, 0.15, 1.0))\n#define LIGHTCOLOR vec3(1.0, 0.85, 0.5)*0.5\n\nvec2 sinNoise(vec2 p, vec4 s)\n{\n    vec4 ps = p.xyxy + s * iTime;\n    vec2 p1 = ps.xy;\n    vec2 p2 = ps.xy * rot2 * 0.4;\n    vec2 p3 = ps.zw * rot6 * 0.7;\n    vec2 p4 = ps.zw * rot10 * 1.5;\n\tvec4 s1 = sin(vec4(p1.x, p1.y, p2.x, p2.y));\n    vec4 s2 = sin(vec4(p3.x, p3.y, p4.x, p4.y));\n    \n    return ((s1.xy + s1.zw + s2.xy + s2.zw)*0.25);\n}\n\nvec4 waves(vec3 pos, float speed)\n{\n    pos *= wavesSize;\n    vec4 s;\n    s.xy = sinNoise(pos.xz*vec2(0.5, 1.0), vec4(0.2, 0.4, -0.1, 0.1)*speed);\n    s.zw = sinNoise(pos.xz*vec2(0.3, 0.6) + s.yx*5.0, vec4(-0.2, 0.6, 0.1, 0.3)*speed);\n    return abs(s);\n}\n\nfloat Sea(vec3 pos)\n{   \n\tvec4 s = waves(pos, wavesSpeed) + waves(pos * 1.5, wavesSpeed * 1.3) * 0.3;\n\treturn pos.y + (s.z + s.w)*wavesHeight;\n}\n\nfloat Ground(vec3 pos)\n{\n    vec2 s = sinNoise(pos.xz*vec2(0.2), vec4(0.0))*4.0;\n    float g = pos.y + 4.0;\n    \n    return g + s.x + s.y + textureLod(iChannel2, pos.xz*vec2(0.02, 0.07), 0.0).x;\n}\n\n//Bump method Taken from this shader by Shane : from https://www.shadertoy.com/view/XlXXWj\nfloat SeaBump(vec2 p)\n{\n    float n0 = 1.0 - textureLod(iChannel2, p*0.08 + iTime * vec2(1.0, 0.7)*turbSpeed, 0.0).x;\n    float n1 = 1.0 - textureLod(iChannel2, p*0.06 - iTime * vec2(0.8, 0.5)*turbSpeed + (n0 - 0.5)*0.08, 0.0).x;\n    float n2 = 1.0 - textureLod(iChannel2, p*0.1 + iTime * vec2(0.6, -0.9)*turbSpeed + (n0 - 0.5)*0.1, 0.0).x;\n    \n    return n1 + n2;\n}\n\nvec4 SeaBumpMap(vec2 uv, vec3 nor)\n{ \n    float ref = SeaBump(uv); \n    float e = 0.1;\n    vec3 grad = vec3(SeaBump(vec2(uv.x-e, uv.y))-ref, 0.0, SeaBump(vec2(uv.x, uv.y-e))-ref); \n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return vec4(normalize(nor + grad*3.0), ref);\n}\n\nstruct NormStruct\n{\n    vec3 norm;\n    vec4 bumped;\n};\n\n//Normal calculation method Taken from this shader by Nimitz : https://www.shadertoy.com/view/Xts3WM  \nNormStruct SeaNorm(in vec3 p)\n{\n    NormStruct o;\n    vec2 e = vec2(-epsilon, epsilon);   \n    float t1 = Sea(p + e.yxx), t2 = Sea(p + e.xxy);\n    float t3 = Sea(p + e.xyx), t4 = Sea(p + e.yyy);\n\n    o.norm = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    o.bumped = SeaBumpMap(p.xz, o.norm);\n    return o;\n}\n\n//Bump method Taken from this shader by Shane : from https://www.shadertoy.com/view/XlXXWj\nfloat GroundBump(vec2 p)\n{\n    return 1.0 - textureLod(iChannel2, p*0.15, 0.0).x;\n}\n\nvec3 GroundBumpMap(vec2 uv, vec3 nor)\n{ \n    float ref = GroundBump(uv); \n    float e = 0.05;\n    vec3 grad = vec3(GroundBump(vec2(uv.x-e, uv.y))-ref, 0.0, GroundBump(vec2(uv.x, uv.y-e))-ref); \n             \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*6.0);\n}\n\n//Normal calculation method Taken from this shader by Nimitz : https://www.shadertoy.com/view/Xts3WM \nvec3 GroundNorm(in vec3 p)\n{\n    vec2 e = vec2(-epsilon, epsilon);   \n    float t1 = Ground(p + e.yxx), t2 = Ground(p + e.xxy);\n    float t3 = Ground(p + e.xyx), t4 = Ground(p + e.yyy);\n\tvec3 n = normalize(e.yxx*t1 + e.xxy*t2 + e.xyx*t3 + e.yyy*t4);\n    \n    return GroundBumpMap(p.xz, n);\n}\n\n\nstruct rayMarchOut\n{\n    vec2 totalDistances;\n    vec3 opaqueNormal;\n    NormStruct transparentNormal;\n    vec3 refractedNormal;\n    float dist;\n    vec2 mask;\n};\n    \nrayMarchOut RayMarch(vec3 rayDir, vec3 cameraOrigin)\n{\n    rayMarchOut OUT;\n\n\tvec3 pos = cameraOrigin;\n\tOUT.totalDistances = vec2(0.0);\n    OUT.opaqueNormal = vec3(0.0, 1.0, 0.0);\n    OUT.transparentNormal.norm = vec3(0.0, 1.0, 0.0);\n    OUT.transparentNormal.bumped = vec4(0.0, 1.0, 0.0, 0.0);\n    OUT.refractedNormal = vec3(0.0, 1.0, 0.0);\n    OUT.mask = vec2(0.0);\n    bool hittedSea = false;\n    \n    for(int i = 0; i < maxItter; i++)\n\t{\n        float distSea = Sea(pos);\n        float distOpaque = Ground(pos);         \n        OUT.dist = min(distSea, distOpaque);\n        \n\t\tOUT.totalDistances.x += OUT.dist;\n\n\t\tpos += OUT.dist * rayDir;\n\n        if(OUT.dist < epsilon)\n\t\t{\n            OUT.mask = smoothstep(vec2(epsilon), vec2(epsilon) + vec2(0.25, 5.0), vec2(distOpaque));\n            \n            if(distSea < epsilon)\n            {\n                OUT.transparentNormal = SeaNorm(pos);\n                hittedSea = true;\n                break;\n            }\n            else\n            {\n                OUT.opaqueNormal = GroundNorm(pos);\n\t\t\t\tbreak;\n            }\n\t\t}   \n        \n        if(OUT.totalDistances.x > maxDistance)\n        {\n            break;\n        }\n\t}\n\n    if(hittedSea == true)\n    {   \n    \tvec3 refractedRay = normalize(refract(rayDir.xyz, OUT.transparentNormal.bumped.xyz, 1.0/1.333));\n    \tvec3 refractedPos = pos;\n        \n    \tfor(int j = 0; j < underWaterMaxItter; j++)\n    \t{                                    \n    \t\tfloat distRefracted = Ground(refractedPos);\n    \t\tOUT.totalDistances.y += distRefracted;         \n    \t\trefractedPos += distRefracted * refractedRay;\n                    \n    \t\tif(distRefracted < epsilon)\n    \t\t{\n    \t\t\tOUT.refractedNormal = GroundNorm(refractedPos);\n    \t\t\tbreak;\n    \t\t}\n                    \n    \t\tif(OUT.totalDistances.y > waterMaxDepth)\n    \t\t{\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    }\n    \n    return OUT;\n}\n\n\n//Camera Function by iq :\n//https://www.shadertoy.com/view/Xds3zN\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 SeaLighting(NormStruct n, vec3 rayDir, vec3 reflectDir)\n{\n    float diff = max(0.0, dot(LIGHT, n.norm));\n    float spec = smoothstep(0.98, 1.0, dot(reflectDir, LIGHT));\n    float fresnel = (1.0 - max(0.0, dot(-n.bumped.xyz, rayDir)));\n\t//smoothstep(0.25, 1.0, dot((rayDir + LIGHT), n.bumped.xyz));\n    return vec3(diff, spec*fresnel, fresnel); \n}\n\nvec2 GroundLighting(vec3 n, vec3 rayDir)\n{\n    float diff = max(0.0, dot(LIGHT, n));\n    float spec = smoothstep(0.5, 1.0, dot(reflect(rayDir, n), LIGHT));\n\tfloat fresnel = (1.0 - max(0.0, dot(-n, rayDir)));\n    \n    return vec2(diff, spec * fresnel); \n}\n\nstruct SkyStruct\n{\n    vec3 sky;\n    vec3 glow;\n    float lensFlare;\n};\n\nSkyStruct Sky(vec3 ray)\n{\n   SkyStruct o;\n    \n   vec3 diff = ray - LIGHT;\n   float sunDist = clamp(length(diff), 0.0, 1.0);\n   float at = (atan(diff.x, diff.y) + pi) / (2.0 * pi);\n   vec4 rays = textureLod(iChannel0, vec2(iTime*0.02, at), 0.0).x * (1.0 - sunDist) * vec4(0.0, 0.05, 0.1, 0.0);\n\n   vec4 sun = smoothstep(vec4(0.07, 0.3, 1.25, 0.5), vec4(0.0), vec4(sunDist)) * vec4(1.0, 0.2, 1.0, 1.0) + rays;\n   vec3 grad = mix(vec3(1.2, 0.85, 0.7), vec3(0.55, 0.6, 0.7), smoothstep(0.0, 1.0, ray.y*1.5+0.4));\n    \n   vec3 res = grad + (sun.x + sun.y) * LIGHTCOLOR;\n       \n   o.sky = res;\n   o.glow = sun.z * LIGHTCOLOR * 1.3;\n   o.lensFlare = sun.w;\n       \n   return o;\n}\n\nfloat FoamNoise(vec3 pos)\n{\n    vec2 s = iTime * vec2(0.01);\n    vec2 t1 = texture(iChannel1, pos.xz*0.03 + s).xz-0.5;\n    float t2 = texture(iChannel1, pos.xz*0.06 - s + t1*0.1).y;\n    \n    return t2;\n}\n\nfloat Foam(vec3 pos, float noise, vec2 mask)\n{\n    float t = smoothstep(max(0.0, pos.y*0.5+1.2), 0.0, noise);\n    float border = smoothstep(1.25, 1.5, (1.0 - mask.y)+noise) * mask.x * 0.75;\n    return smoothstep(0.7, 1.0, t)*0.4 + border;\n}\n\nvec3 FoamBumpMap(vec3 pos, vec3 nor, float ref, vec2 mask)\n{ \n    float e = 0.05;\n    vec3 p1 = vec3(pos.x - e, pos.y, pos.z);\n    vec3 p2 = vec3(pos.x, pos.y, pos.z - e);\n    float fn1 = FoamNoise(p1);\n    float fn2 = FoamNoise(p2);\n\n    vec3 grad = vec3(Foam(p1, fn1, mask)-ref, 0.0, \n                     Foam(p2, fn2, mask)-ref); \n    \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 s = sinNoise(vec2(0.0), vec4(0.0, 0.1, 0.0, 0.2));\n    \n    float camX = 0.0;\n    float camY = 7.0 - (s.x + s.y)*wavesHeight*2.0;\n    float camZ = iTime*10.0;                \n    vec3 cameraOrigin = vec3(camX, camY, camZ);\n\tvec3 cameraTarget = vec3(sin(iTime*0.25)*8.0, 0.0, cameraOrigin.z + 10.0);\n    \n\tvec2 screenPos = uv * 2.0 - 1.0;\n\tscreenPos.x *= iResolution.x/iResolution.y;\n    \n    mat3 cam = setCamera(cameraOrigin, cameraTarget, sin(iTime*0.3)*0.1);\n    \n    vec3 rayDir = cam*normalize(vec3(screenPos.xy,0.65));\n    \n    rayMarchOut r = RayMarch(rayDir, cameraOrigin);\n    \n    vec3 res = vec3(0.0);\n    \n    SkyStruct sky = Sky(rayDir);\n   \n    if(r.dist < epsilon)\n    {  \n        vec3 pos = cameraOrigin + r.totalDistances.x*rayDir;\n        vec3 rfrPos = pos + r.totalDistances.y*rayDir;\n\t\tvec3 groundPos = mix(pos, rfrPos, r.mask.x);\n        vec3 groundNorm = mix(r.opaqueNormal, r.refractedNormal, r.mask.x);\n        vec3 groundColors =  groundColor * (0.5 + 0.5 * texture(iChannel1, groundPos.xz*0.2).xyz);\n        vec3 groundAmb = mix(groundColors, groundColors * Sky(groundNorm).sky, 0.75);\n        vec2 groundLighting = GroundLighting(groundNorm, rayDir);\n        float rfrFog = clamp(smoothstep(waterMaxDepth, 0.0, r.totalDistances.y) + (1.0 - r.mask.x), 0.0, 1.0);\n        vec3 groundFinal = groundAmb + groundAmb * groundLighting.x * LIGHTCOLOR + groundLighting.y * LIGHTCOLOR;\n                \n        float foamNoise = FoamNoise(pos);\n        vec3 pf = pos + vec3(0.0, r.transparentNormal.bumped.w*0.75, 0.0);\n        float foam = Foam(pf, foamNoise, r.mask);   \n        r.transparentNormal.bumped.xyz = FoamBumpMap(pf, r.transparentNormal.bumped.xyz, foam, r.mask);\n        r.transparentNormal.norm = FoamBumpMap(pf, r.transparentNormal.norm, foam, r.mask);\n        \n        vec3 seaRefl = reflect(rayDir, r.transparentNormal.bumped.xyz);\n\t\tvec3 seaLighting = SeaLighting(r.transparentNormal, rayDir, seaRefl);\n        \n        float d = smoothstep(0.0, 20.0, r.totalDistances.x);\n        vec3 seaColor = mix(color3, mix(color1, color2, (pos.y + r.transparentNormal.bumped.w*1.5 + 0.25)), d) + foam;\n        vec3 seaAmb = mix(seaColor, seaColor * Sky(seaRefl).sky, 0.5);\n        vec3 seaFinal = mix(seaAmb, groundFinal, clamp(rfrFog - foam*0.6, 0.0, 1.0)) \n        + seaColor * (seaLighting.z * (1.0 - foam) + seaLighting.x) * LIGHTCOLOR + seaLighting.y * LIGHTCOLOR;\n        \n        float f = smoothstep(30.0, maxDistance, r.totalDistances.x);\n        res = mix(seaFinal, sky.sky, f);\n    }\n    else  \n    {\n        res = sky.sky;\n    }\n    \n    res += sky.glow * LIGHTCOLOR;\n    \n\tvec2 v = 1.0 - abs(uv - 0.5) * 2.0;\n    v.x *= v.y;\n    v.x = clamp(v.x*2.0, 0.0, 1.0);\n    \n\tfragColor = vec4(res, sky.lensFlare * v.x);\n}","name":"Buffer A","description":"","type":"buffer"}]}