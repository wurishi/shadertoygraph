{"ver":"0.1","info":{"id":"MtKyWz","date":"1535861705","viewed":148,"name":"A text party","username":"Veggiebob","description":"Something I saw in the Fortune's magazine: \"Make the World Great Again\" pg. 60 I think just in case you want to see it","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["sdf","text","diffuselight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const bool customWords = true;\n\n\n\n\n\nconst float EPSILON = pow(10., -3.);\nconst float PI = 3.1415926;\nvec2 rotate2D (vec2 p, float angle){\n    float a = atan(p.y, p.x)+angle;\n    float m = length(p);\n    return vec2(cos(a)*m, sin(a)*m);\n}\nvec4 SDF (vec3 p){\n    vec3 matCol = vec3(0.);\n    //p.xy = rotate2D(p.xy-0.5, p.z+PI/2.)+0.5;\n    float txtsdf = 0.;\n    if(customWords){   \n        txtsdf = texture(iChannel0, vec2(\n            p.x*0.3+0.5,\n            p.y*0.3+0.5\n        )).w;\n    } else {\n        txtsdf = texture(iChannel3, vec2(\n            p.x/16. - 18.5/16., \n            p.y/16. - 1.0/16.\n        )).w;\n    }\n    float total = max(txtsdf, 0.5)-max(p.z*0.3, 0.);\n    float intensity = pow(2., p.z-2.);\n    //total+=texture(iChannel1, p*intensity).r*0.1*max(intensity-1., 0.);\n    return vec4(total, matCol);\n}\nvec4 trace (vec3 o, vec3 r) {\n    float t = 0.;\n    vec3 p = o;\n    for(int i = 0; i<128; i++){\n        p = o+r*t;\n        float d = SDF(p).x;\n        t+=d*0.8;\n    }\n    return vec4(p, t);\n}\n//Credit to Jamie Wong http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)).x - SDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        SDF(vec3(p.x, p.y + EPSILON, p.z)).x - SDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)).x - SDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n//made this one myself with some tutorials I found out there on the web\nfloat diffuseLight (vec3 n, vec3 r){\n    return dot(n, -r);\n}\nfloat specularLight (vec3 n, vec3 r){\n    vec3 nr = reflect(r, n);\n    return pow(max(dot(nr, -r), 0.), 4.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy-0.5;\n    if(!customWords){\n    \tmouse*=2.;\n    }\n    \n    float lightDist = 2.;\n    vec3 light = vec3(sin(iTime)*lightDist, cos(iTime)*lightDist, -1.);\n    uv-=0.5;\n    vec3 camera = vec3(0., 0., 0.);\n    vec3 ray = vec3(uv*1., 1.);\n    ray = normalize(ray);\n    camera.yz = rotate2D(camera.yz, mouse.y);\n    ray.yz = rotate2D(ray.yz, mouse.y);\n    camera.xz = rotate2D(camera.xz, mouse.x);\n    ray.xz = rotate2D(ray.xz, mouse.x);\n    \n    \n    vec4 v = trace(camera, ray);\n    vec3 col = vec3(1.);\n    float st = 0.84;\n    col *= clamp(pow(mod(v.z-iTime*0.1, st)+st/1.5, 50.), 0., 0.5);\n    \n    vec3 norm = normalize(estimateNormal(v.xyz));\n    col+=texture(iChannel2, reflect(camera, norm)).rgb;\n    col += diffuseLight(norm, v.xyz-light)*0.1;\n\tcol += pow(v.w*2., 4.)*0.00001;//distance shading\n    // Output to screen\n    //col = texture(iChannel0, uv+0.5).rrr;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/** THE LETTERS MWAHAHAHAHAHA **/\n\n//A to Z is (1, 11) to (10, 10)\nconst vec2 _A = vec2(1, 11);\nconst vec2 _B = vec2(2, 11);\nconst vec2 _C = vec2(3, 11);\nconst vec2 _D = vec2(4, 11);\nconst vec2 _E = vec2(5, 11);\nconst vec2 _F = vec2(6, 11);\nconst vec2 _G = vec2(7, 11);\nconst vec2 _H = vec2(8, 11);\nconst vec2 _I = vec2(9, 11);\nconst vec2 _J = vec2(10,11);\nconst vec2 _K = vec2(11,11);\nconst vec2 _L = vec2(12,11);\nconst vec2 _M = vec2(13,11);\nconst vec2 _N = vec2(14,11);\nconst vec2 _O = vec2(15,11);\nconst vec2 _P = vec2(0, 10);\nconst vec2 _Q = vec2(1, 10);\nconst vec2 _R = vec2(2, 10);\nconst vec2 _S = vec2(3, 10);\nconst vec2 _T = vec2(4, 10);\nconst vec2 _U = vec2(5, 10);\nconst vec2 _V = vec2(6, 10);\nconst vec2 _W = vec2(7, 10);\nconst vec2 _X = vec2(8, 10);\nconst vec2 _Y = vec2(9, 10);\nconst vec2 _Z = vec2(10,10);\nconst vec2 _a = vec2(1, 9);\nconst vec2 _b = vec2(2, 9);\nconst vec2 _c = vec2(3, 9);\nconst vec2 _d = vec2(4, 9);\nconst vec2 _e = vec2(5, 9);\nconst vec2 _f = vec2(6, 9);\nconst vec2 _g = vec2(7, 9);\nconst vec2 _h = vec2(8, 9);\nconst vec2 _i = vec2(9, 9);\nconst vec2 _j = vec2(10,9);\nconst vec2 _k = vec2(11,9);\nconst vec2 _l = vec2(12,9);\nconst vec2 _m = vec2(13,9);\nconst vec2 _n = vec2(14,9);\nconst vec2 _o = vec2(15,9);\nconst vec2 _p = vec2(0, 8);\nconst vec2 _q = vec2(1, 8);\nconst vec2 _r = vec2(2, 8);\nconst vec2 _s = vec2(3, 8);\nconst vec2 _t = vec2(4, 8);\nconst vec2 _u = vec2(5, 8);\nconst vec2 _v = vec2(6, 8);\nconst vec2 _w = vec2(7, 8);\nconst vec2 _x = vec2(8, 8);\nconst vec2 _y = vec2(9, 8);\nconst vec2 _z = vec2(10,8);\nconst vec2 _space = vec2(15, 8);\nconst vec2 _exclam = vec2(1, 13);//       !\nconst vec2 _quote = vec2(2, 13);//        \"\nconst vec2 _apostrophe = vec2(7, 13);//   '\nconst vec2 _open_paren = vec2(8, 13);//   (\nconst vec2 _close_paren = vec2(9, 13);//  )\nconst vec2 _multiply = vec2(10, 13);// *\nconst vec2 _and = vec2(6, 13);//       &\nconst vec2 _at = vec2(0, 11);//        @\nconst vec2 _money = vec2(4, 13);//     $\nconst vec2 _percent = vec2(5, 13);//   %\nconst vec2 _hashtag = vec2(3, 13);//   #\nconst vec2 _filled_triangle_left = vec2(2, 15);\nconst vec2 _filled_triangle_right = vec2(5, 15);\n\n\nconst int letters = 12;\nconst vec2 [letters] word = vec2 [letters] (_H, _e, _l, _l, _o, _space, _W, _o, _r, _l, _d, _exclam);\n\nfloat text (vec4 box, vec2 character, vec2 uv){\n    vec4 t = texture(iChannel0, (vec2((uv.x-box.x)/box.z, (uv.y-box.y)/box.w)+character)/16.);\n    if(uv.x>box.x&&uv.y>box.y&&uv.x<box.x+box.z&&uv.y<box.y+box.w){\n        return t.w;\n    } else {\n        return -1.;\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(iTime<3.){\n        // setup coordinates of all the stuff\n        vec2 oldCoord = uv;\n        uv-=0.5;//-0.5 to -0.5\n        float aspect = iResolution.x/iResolution.y;\n        uv.x *= aspect;//fix aspect ratio\n        uv *= 0.43/8.*float(letters);//scale up to size of message\n        uv.x-=0.01;\n\n\n        //setup the parts for the words\n        //By the way, each letter has a pretty big border, so it moves less than the box size.\n        float col = 0.7; // set col as black\n        vec2 box = vec2(0.2, 0.2);//size of each letter\n        vec2 move = vec2(box.x*0.44, 0.0);//amount to move to place each new letter\n        vec2 stamp = vec2(-move.x*float(letters)/2.-box.x*0.28, -box.y/2.);//where to \"stamp\" the letter\n\n\n        //make all of the letters from word[]\n        for(int i = 0; i<letters; i++){\n\n            //each letter is like this\n            float tex = text(vec4(stamp, box), word[i], uv);\n            if(tex>=0.){\n                col = min(tex, col);\n            }\n            stamp+=move;\n            //just do all of that for each letter that you want.\n        }\n        //col = texture(iChannel0, oldCoord).r;//just for reference\n        fragColor = vec4(col)*1.;\n    } else {\n        fragColor = texture(iChannel1, uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}