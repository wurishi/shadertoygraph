{"ver":"0.1","info":{"id":"wtyXWG","date":"1583459922","viewed":357,"name":"mandala1 flash sat [spaz]","username":"HaleyHalcyon","description":"you are Anna's Doll","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// adjusts the saturation\nvec3 sat(vec3 rgb)\n{\n    // Algorithm from Chapter 16 of \"OpenGL Shading Language\"\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, 1.5); // adjust strength here\n}\n\n// varying speed\nfloat funkySpeed(float x)\n{\n    x = mod(x + 1.0, 2.0) - 1.0;\n    float n = x * x * x; // implement the speed change using x cubed\n\treturn (8. * n - 4. * x) * 3.14159265;\n}\n\n// gets brightness from some factor of dist and angle\nfloat fn(float x)\n{\n    float n = abs(sin(x));\n    return max((n - 0.5) * 1.5, 0.);\n}\n\n// makes edges darker than the center\nfloat vignette(float v, float d)\n{\n    return v * (0.8 - 0.35 * d);\n}\n\n// this is where most of the magic happens\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // some constants that we'll use thru-out the spiral\n    const float PI = 3.14159265; // of course, we need π for trig\n    const float PI_3 = PI / 3.; // pre-compute π/3 for hue rotation\n    const float speed = 0.4; // speed of spiral movement\n    float hue = fract(iTime * 1.2) * PI; // offset of hue [0, π)\n    \n    // Normalized pixel coordinates [-1, 1]\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= vec2(iResolution.x / scale, iResolution.y / scale) / 2.;\n    uv *= 2.0;\n    \n    // calculate \"distance\" to prepare for a log spiral\n    float distance = log(uv.x*uv.x+uv.y*uv.y);\n    // calculate angle [0, 2π)\n    float angle = atan(uv.y, uv.x);\n    \n    // Time varying pixel color\n    // spiral 1\n    float c1 = vignette(fn(distance * 1.5 + angle * 3.0 + funkySpeed(iTime * speed) + PI), distance);\n    // spiral 2\n    float c2 = vignette(fn(distance * 1.5 - angle * 3.0 + funkySpeed((iTime * speed) + 2. / 3.) + PI), distance);\n    // rings \n    float c3 = vignette(fn(angle * 16.0 + sin(iTime) * 8.0 - iTime * 0.5) * 0.5\n             + fn(distance * 4.0 + funkySpeed((iTime * speed) + 4. / 3.) * 0.5), distance);\n    \n    // Flashing\n    const float flashIntvl = 0.2;\n    const float flashStrength = 1.5;\n    const float flashSudden = flashStrength / flashIntvl * 6.0;\n    float f1 = max(0., flashStrength - mod(iTime, flashIntvl) * flashSudden);\n    float f2 = max(0., flashStrength - mod(iTime + flashIntvl * 1.0/3.0, flashIntvl) * flashSudden);\n    float f3 = max(0., flashStrength - mod(iTime + flashIntvl * 2.0/3.0, flashIntvl) * flashSudden);\n\tc1 += f1; c2 += f2; c3 += f3;\n\n    // Saturation\n    vec3 fragColorRGB = sat(\n        // this part rotates the hue away from each other by 2π/3 radians\n        vec3(\n        \tabs(c1 * sin(hue))        + abs(c2 * -sin(hue + PI_3)) + abs(c3 * -sin(hue - PI_3)),\n        \tabs(c1 * sin(hue + PI_3)) + abs(c2 * -sin(hue - PI_3)) + abs(c3 * -sin(hue)       ),\n        \tabs(c1 * sin(hue - PI_3)) + abs(c2 * -sin(hue))        + abs(c3 * -sin(hue + PI_3))\n        )\n    );\n    \n    // Output to screen\n    fragColor = vec4(fragColorRGB, 1); // just add alpha and we're done\n}","name":"Image","description":"","type":"image"}]}