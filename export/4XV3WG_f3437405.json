{"ver":"0.1","info":{"id":"4XV3WG","date":"1719137765","viewed":47,"name":"simple grid raymarch","username":"sam_hains","description":"Part of the Raymarching workshop\nhttps://github.com/electricsquare/raymarching-workshop","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"Xtcfzn","parentname":"Ray Marching Basics - Part 3a"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Returns signed distance to the surface of a sphere\n// p: sphere center position, r: sphere radius\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n// Returns signed distance to the surface of a plane\n// p: plane origin (position), n.xyz: plane surface normal, p.w: plane's distance from origin (along its normal)\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p+vec3(0.0, 0.0, 0.0), n.xyz) + n.w;\n}\n\n//------------------------------------------------------------------\n\n// Union operator\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\n\n//------------------------------------------------------------------\n\nvec2 SDF(vec3 pos)\n{\n    vec2 res = vec2(sdPlane(pos, vec4(0, 1, 0, 10)),          2.0);\n    \n    return res;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\t// Center sample\n    float c = SDF(pos).x;\n\t// Use offset samples to compute gradient / normal\n    vec2 eps_zero = vec2(0.001, 0.0);\n    return normalize(vec3(\n        SDF(pos + eps_zero.xyy).x,\n        SDF(pos + eps_zero.yxy).x,\n        SDF(pos + eps_zero.yyx).x) - c);\n}\n\n// Returns a vec2, x: signed distance to surface, y: material ID\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float tmax = 250.0;\n    // t stores the distance the ray travelled before intersecting a surface\n    float t = 0.0;\n    \n    vec2 result;\n    result.y = -1.0; // Default material ID\n    \n    for (int i = 0; i < 256; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * t);\n        if (res.x < (0.0001*t))\n        {\n            // When within a small distance of the surface, count it as an intersection\n            result.x = t;\n            return result;\n        }\n        else if (res.x > tmax)\n        {\n            // Indicate that this ray didn't intersect anything\n            result.y = -1.0;\n            result.x = -1.0;\n            return result;\n        }\n        t += res.x;\n        result.y = res.y; // Material ID of closest object\n    }\n    \n    result.x = t; // Distance to intersection\n    return result;\n}\n\nvec3 fogColor = vec3(0.2, 0.2, 0.2);\n\nvec3 applyFog(vec3 rgb, float dist, float startDist)\n{\n    float fogAmount = 1.0 - exp(-(dist-8.0) * (1.0/startDist));\n    return mix(rgb, fogColor, fogAmount);\n}\n\nvec3 triplanarMap(vec3 surfacePos, vec3 normal, float scale)\n{\n\t// Take projections along 3 axes, sample texture values from each projection, and stack into a matrix\n\tmat3x3 triMapSamples = mat3x3(\n\t\ttexture(iChannel0, surfacePos.yz * scale).rgb,\n\t\ttexture(iChannel0, surfacePos.xz * scale).rgb,\n\t\ttexture(iChannel0, surfacePos.xy * scale).rgb\n\t\t);\n\n\t// Weight three samples by absolute value of normal components\n\treturn triMapSamples * abs(normal);\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 col = fogColor - rayDir.y * 0.4;\n    vec2 res = castRay(rayOrigin, rayDir);\n    float t = res.x; // Distance to surface\n    float m = res.y; // Material ID\n\n    if (m > -1.0)\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        \n        if (m > -0.5)\n        {\n            col = col = vec3(0.18*m, 0.6-0.05*m, 0.2+0.2);\n\n            vec3 N = calcNormal(pos);\n            vec3 L = normalize(vec3(1.0, 0.5, -0.5));\n            // L is vector from surface point to light, N is surface normal. N and L must be normalized!\n            float NoL = max(dot(N, L), 0.0);\n            vec3 LDirectional = vec3(0.9, 0.9, 0.8) * NoL;\n            vec3 LAmbient = vec3(0.03, 0.04, 0.1);\n            vec3 diffuse = col * (LDirectional + LAmbient);\n            \n            if (m == 2.0)\n            {\n                diffuse *= triplanarMap(pos, N, 0.1);\n            }\n            \n        \tcol = diffuse;\n            \n        }\n     \n       col = applyFog(col, pos.z, 80.0);\n    }\n    \n    return col;\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camForward));\n\tvec3 camUp = normalize(cross(camForward, camRight));\n\t\t\t\t\t\t\n    // fPersp controls the camera's field of view. Try changing it!\n    float fPersp = 2.0;\n\tvec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n\n\treturn vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y; // Correct for aspect ratio\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec3 camPos = vec3(0, 0.0, -8.0);\n\n    vec3 at =  vec3(0, -.2, 8.0);\n    \n    vec2 uv = normalizeScreenCoords(fragCoord);\n    vec3 rayDir = getCameraRayDir(uv, camPos, at);\n    \n    vec3 col = render(camPos, rayDir);\n    \n    col = pow(col, vec3(0.4545)); // Gamma correction (1.0 / 2.2)\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}