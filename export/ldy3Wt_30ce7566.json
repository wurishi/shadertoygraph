{"ver":"0.1","info":{"id":"ldy3Wt","date":"1457223292","viewed":568,"name":"1D Metropolis Sampling","username":"mplanck","description":"1D metropolis sampling technique described on Page 659 of PBR 2nd Edition.  HUD = Total Samples | Num Samples Per Frame | Current X * 100","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["metropolis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value+.01)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n//-----------------------------------------------------------------\n\n\nfloat f(float x, float functionVal)\n{\n    float result = 0.;\n    if (functionVal > .5 && functionVal < 1.5)\n    {\n        result = 3.5 * step(0., x) * step(x, 1.) * (x - .5) * (x - .5);\n    }\n    else\n    if (functionVal > 1.5 && functionVal < 2.5)\n    {\n    \tresult = step(0., x) * step(x, 1.) * (0. + (.2 + .5 * sin(3.14 * x)) * abs(sin(5. * 3.14 * x)));\n    }\n    return result;\n}\n\n\nfloat plotValue(float y, float p)\n{\n    float d = 1. - abs(y - p);\n    return smoothstep(.98, 1., d*d);\n}\n\nfloat plotBar(float y, float p)\n{\n    return smoothstep(y - .01, y, p);\n}\n\nvoid mainImage( out vec4 fragColor, \n                in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x -= .08;\n    uv.x *= 1.2;\n    uv.y -= .05;\n            \n    vec3 stateVal = texture(iChannel0,vec2(0.0, 3.5/iResolution.y), -100.).rgb;\n    float currX = stateVal.r;\n    float numMutations = stateVal.g;\n    float numSamples = stateVal.b;\n    float functionVal = texture(iChannel0, vec2(uv.x, 4.5/iResolution.y), -100.).r;\n\n    \n    // TODO (mplanck): why do we need an arbitrary scalar on the samples?\n    float p = 210. * step(0.0, uv.x) * step(uv.x, 1.) * textureLod(iChannel0, vec2(uv.x, .5/iResolution.y), 0.).r/numSamples;\n    float a = step(0.0, uv.x) * step(uv.x, 1.) * textureLod(iChannel0, vec2(uv.x, 1.5/iResolution.y), 0.).r;\n    float r = step(0.0, uv.x) * step(uv.x, 1.) * textureLod(iChannel0, vec2(uv.x, 2.5/iResolution.y), 0.).r;\n\n\n    float s = 1.4 * plotValue(uv.y, p) + plotBar(uv.y, p) * (.7 * p + .3);\n    vec3 samples = vec3(.5 + r, .4 + a, 1.) * s;\n    vec3 actual = vec3(1.) * plotValue(uv.y, f(uv.x, functionVal));    \n    \n    float hud = PrintInt(30. * (uv - vec2(-.1,.85)), numSamples);\n    hud = max(hud, PrintInt(30. * (uv - vec2(.2,.85)), numMutations));\n    hud = max(hud, PrintInt(30. * (uv - vec2(.4,.85)), currX * 100.));\n    vec3 co = mix(samples + actual, vec3(1.), hud);\n    fragColor = vec4(co, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float DEFAULT_NUM_MUTATIONS_PER_FRAME = 4.;\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_MINUS = 189.5/256.0;\nconst float KEY_PLUS = 187.5/256.0;\nconst float KEY_ONE = 49.5/256.0;\nconst float KEY_TWO = 50.5/256.0;\n\n/*\nfloat hash11(float p)\n{\n\treturn fract(sin(p * 113.0)*43758.5453123);\n}\n*/\n\n//----------------------------------------------------------------------------------------\n// from dave hoskins: https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .103123\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nbool isThisPixelInThisRow(vec2 fragCoord, float r)\n{\n    return (step(r-.2, fragCoord.y) * step(fragCoord.y, r+1.2)) > .5;\n}\n\nbool isThisPixelInThisRowRange(vec2 fragCoord, float r0, float r1)\n{\n    return (step(r0-.01, fragCoord.y) * step(fragCoord.y, r1+1.01)) > .5;\n}\n\nfloat random(float offset)\n{\n    // TODO: get a better hash!\n    return hash11(float(iFrame) + offset);\n}\n\nfloat f(float x, float functionVal)\n{\n    float result = 0.;\n    if (functionVal > .5 && functionVal < 1.5)\n    {\n        result = 3.5 * step(0., x) * step(x, 1.) * (x - .5) * (x - .5);\n    }\n    else\n    if (functionVal > 1.5 && functionVal < 2.5)\n    {\n    \tresult = step(0., x) * step(x, 1.) * (0. + (.2 + .5 * sin(3.14 * x)) * abs(sin(5. * 3.14 * x)));\n    }\n    return result;\n}\n\nfloat accept(float oldX, float newX, float functionVal)\n{\n    float pr = f(newX, functionVal);\n    return step(0., pr) * min(1., pr/f(oldX, functionVal));\n}\n\nfloat mutateToRandom(float X, float seed)\n{\n    return random(5.129 * iTime + 232.21 * seed);\n}\n\nfloat mutateToNearby(float X, float seed)\n{\n    return X + .1*(random(3.848 * iTime + 1.932 * seed) - .5);\n}\n\nfloat chooseMutation(float sampleX, float seed)\n{\n    // mutate nearby 90% of the time, otherwise pick a random\n    // spot in the sampling domain of [0,1]\n    if (random(4.21 * iTime + 19.2317 * seed) < .1)\n    {\n        return mutateToRandom(sampleX, seed);\n    }\n    else\n    {\n        return mutateToNearby(sampleX, seed);\n    }\n}\n\nfloat pixelMask(float sampleX, float x)\n{\n    return step(x, sampleX) * step(sampleX, x + 1./iResolution.x);\n}\n\nvec3 record(float oldX, float newX, float x, float a)\n{\n    vec3 r = vec3(1.) * (1. - a) * pixelMask(oldX, x);\n    r += vec3(1.) * (a) * pixelMask(newX, x);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, \n                in vec2 fragCoord )\n{\n\t// 0th row: accumulating samples\n    // 1st row: recently accepted samples highlighting\n    // 2nd row: recently rejected samples highlighting\n    // 3rd row: store the current program state\n    // r := current sample value of iteration\n    // g := number of mutationt samples per frame (part 1)\n    // b := number of total samples\n    // a := was noticing buggy behavior by using 4th channel, so moved it to new \"state row\"\n    // 4th row: store the current program state (part 2)\n    // r := 1 or 2 to select function being drawn\n    // g := NOT USED\n    // b := NOT USED\n    // everything else: black\n    \n    if (!isThisPixelInThisRowRange(fragCoord, 0., 4.))\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    float resetFrame = 0.;\n    \n    float pressSpace = texture( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n\tif (pressSpace > .5 || iFrame == 0) { resetFrame = 1.; }\t\n    \n    float functionVal = texture(iChannel0,vec2(0.0, 4.5/iResolution.y), -100.).x;\n\n    float pressOne = texture( iChannel1, vec2(KEY_ONE,0.25) ).x;\n\tif (pressOne > .5) { resetFrame = 1.; functionVal = 1.; }\t\n    float pressTwo = texture( iChannel1, vec2(KEY_TWO,0.25) ).x;\n\tif (pressTwo > .5) { resetFrame = 1.; functionVal = 2.; }\t\n    \n    float x = fragCoord.x / iResolution.x;\n    \n\tvec3 acol = vec3(0.);      \n        \n    if (resetFrame < .5)\n    {\n        acol = texture(iChannel0,vec2(x, fragCoord.y/iResolution.y), -100.).rgb;\n     \n        vec3 stateVal = texture(iChannel0,vec2(0.0, 3.5/iResolution.y), -100.).rgb;\n        float currX = stateVal.r;\n        float numMutations = stateVal.g;\n        float numSamples = stateVal.b;\n        \n        float pressMinus = texture( iChannel1, vec2(KEY_MINUS,0.25) ).x;\n        float pressPlus = texture( iChannel1, vec2(KEY_PLUS,0.25) ).x;\n        if (pressMinus > .5) { numMutations = max(numMutations - 1., 1.); }\t\n        if (pressPlus > .5) { numMutations = min(numMutations + 1., 256.); }\t \n        \n        for (float i = 0.; i < 256.; i+=1.)\n        {                        \n            if (i >= numMutations)\n            {\n                break;\n            }\n            \n            float newX = chooseMutation(currX, i);\n            float a = accept(currX, newX, functionVal);\n\n            if (isThisPixelInThisRow(fragCoord, 0.))\n            {\n                acol += record(currX, newX, x, a);\n            }\n            else\n            // fade off the contribution of accepted samples\n            if (isThisPixelInThisRow(fragCoord, 1.))\n            {                    \n                acol = max(acol - vec3(.0125), vec3(.0));\n            }\n            else\n            // fade off contribution of rejected sample\n            if (isThisPixelInThisRow(fragCoord, 2.))\n            {                    \n                acol = max(acol - vec3(.0125), vec3(.0));\n            }\n\n\n            if (random(2.173 * iTime + 821.71 * i) < a)\n            {\n                currX = newX;\n                \n                // increase highlight of accepted samples\n                if (isThisPixelInThisRow(fragCoord, 1.))\n                {                    \n                    acol += pixelMask(currX, x);\n                }\n                   \n            }\n            else\n            {                \n                // increase highlight of rejected samples\n                if (isThisPixelInThisRow(fragCoord, 2.))\n                {                    \n                    acol += pixelMask(newX, x);\n                }\n            }\n            \n        }\n        \n        numSamples += numMutations;\n        \n        if (isThisPixelInThisRow(fragCoord, 3.))\n        {\n            // save program state0\n            acol = vec3(currX, numMutations, numSamples);    \n        }\n        else if (isThisPixelInThisRow(fragCoord, 4.))\n        {\n            // save program state1\n            acol = vec3(functionVal, 0., 0.);\n        }        \n        \n    }\n    else\n    {\n        // Reset sampling\n        if (isThisPixelInThisRow(fragCoord, 3.))\n        {\n        \tacol = vec3(random(9021.), DEFAULT_NUM_MUTATIONS_PER_FRAME, 0.);\n        }\n        else if (isThisPixelInThisRow(fragCoord, 4.))\n        {\n        \tacol = vec3(functionVal, 0., 0.);\n        }\n        else\n        {\n            acol = vec3(0.);\n        }\n    }\n    \n    // initialize function selection\n   \tif (iFrame == 0)\n    {        \n        if (isThisPixelInThisRow(fragCoord, 4.))\n        {\n        \tacol = vec3(2., 0., 0.);\n        }\n    }\n    \n    fragColor = vec4(acol,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}