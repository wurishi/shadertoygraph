{"ver":"0.1","info":{"id":"Xc2XR1","date":"1706058169","viewed":221,"name":"Animated lens flare","username":"Fewes","description":"Procedural lens flare function with analytic anti-aliasing. Fits nicely in a quad.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["light","flare","lensflare","mit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 TonemapACES(vec3 color)\n{\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (color * (a * color + b)) / (color * (c * color + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv0 = uv;\n    uv.x = (uv.x - 0.5) * aspect + 0.5;\n    mouse.x = (mouse.x - 0.5) * aspect + 0.5;\n    \n    ////////////////////////////////////////\n    // Position flare\n    float time = -iTime * 0.5;\n    vec2 position = vec2(0.5) + vec2(cos(time) * 2.0, sin(time)) * 0.25;\n    if (iMouse.z > 0.0)\n    {\n        position = mouse;\n    }\n    vec2 toCenter = vec2(0.5) - position;\n    uv += toCenter;\n    \n    ////////////////////////////////////////\n    // Get flare\n    vec3 lightColor = vec3(1.0, 0.4, 0.1);\n    float visibility = saturate(1.0 - length(toCenter));\n    vec3 color = GetFlare(uv, toCenter, visibility) * lightColor * visibility;\n    \n    ////////////////////////////////////////\n    // Output\n    color = TonemapACES(color);\n    color = pow(color, 1.0 / vec3(2.2));\n    vec3 dither = textureLod(iChannel0, uv0 * iResolution.xy / vec2(1024), 0.0).xyz;\n    dither = fract(dither + (0.61803398875 * float(iFrame & 255)));\n    color += dither / 255.0;\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n#define BLADE_COUNT1    4.0\n#define BLADE_COUNT2    8.0\n#define BLADE_COUNT3    16.0\n#define THICKNESS       3.0 // Controls the thickness of the limbs. Values below 2 will cause aliasing.\n#define GLARE_INTENSITY 0.2 // Strength of rainbow circle glare.\n#define GLARE_WIDTH     0.1 // Size of rainbow circle glare.\n#define GLOW_INTENSITY  0.1 // Intensity of rainbow circle glare.\n#define FACE_DIRECTION      // Rotate the flare to face the input direction\n\nfloat saturate(float x) { return clamp(x, 0.0, 1.0); }\nfloat remap (float x, float a, float b, float c, float d) { return saturate(c + (((x - a) / (b - a)) * (d - c))); }\nfloat remap01 (float x, float a, float b) { return saturate((x - a) / (b - a)); }\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract((p+1.0)*0.1031);\n    p *= p+33.33;\n    return fract(p*p*2.0);\n}\n\n// Copyright (c) 2024 Felix Westin\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat GetFlareBlades(float x, float y, float count, float size, float roll, float offset, float k)\n{\n    float x0 = x;\n    x = fract(x + 1.0 / count);\n    y = remap01(y, 0.0, size);\n    float s = x * count;\n    float hash = hash11(float(int(s) % int(count / 2.0)) + offset);\n    float blade = abs(fract(s + 0.5) - 0.5) * 2.0;\n    float aa = mix(fwidth(x * count), fwidth(fract(x + 0.5) * count), step(fract(x + 0.25), 0.5));\n    blade = remap01(blade, 1.0 - aa * THICKNESS, 1.0);\n    float l = cos(hash * 2.0 * PI + roll * 4.0) * 0.4 + 0.6;\n    return blade * remap01(y, l, 0.0);\n}\n\nvec3 GetFlare(vec2 uv, vec2 toCenter, float visibility)\n{\n    // The \"roll\" angle is used to rotate the flare if FACE_DIRECTION is defined\n    // and also to animate the blades.\n    // You can replace it with any animated value you desire (time for example).\n    float roll = atan(-toCenter.y, toCenter.x);\n    \n    vec2 dir = (uv - 0.5) * 2.0;\n    float y = length(dir);\n    dir /= y;\n    float theta = atan(dir.y, dir.x);\n#ifdef FACE_DIRECTION\n    theta += roll;\n#endif\n    float x = theta / (2.0 * PI) + 0.125;\n    float flare = \n        GetFlareBlades(x + 0.000, y, BLADE_COUNT1, visibility * 1.0, roll, 0.0,   40.0) * 0.4 +\n        GetFlareBlades(x + 0.125, y, BLADE_COUNT2, visibility * 0.6, roll, 10.0,  20.0) * 0.1 +\n        GetFlareBlades(x + 0.125, y, BLADE_COUNT3, visibility * 0.4, roll, 100.0, 2.0)  * 0.05;\n        \n    float glare = pow(saturate(1.0 - y), 4.0 + (1.0 - visibility) * 4.0) * 0.1;\n    vec3 n = vec3((uv - vec2(0.5)) * 2.0, 0.0);\n    n = normalize(vec3(n.xy, sqrt(1.0 - saturate(dot(n.xy, n.xy)))));\n    float glareSize = length(toCenter);\n    float glareWidth = GLARE_WIDTH;\n    float glareY = y - glareSize;\n    glare = saturate(dot(vec3(-toCenter, 0.5), n)) * smoothstep(glareWidth, 0.0, abs(glareY));\n    glare *= 0.5 + cos(theta * floor(500.0 * glareSize)) * 0.5;\n    float glareColorKey = (glareY / glareWidth + 0.5) * 0.5;\n    float r = (1.0 - glareColorKey);\n    float g = 1.0 - abs(glareColorKey - 0.5) * 2.0;\n    float b = glareColorKey;\n    vec3 glareColor = vec3(r, g, b) * glareSize * GLARE_INTENSITY;\n    \n    float glow = saturate(1.0 - y);\n    glow = glow*glow*GLOW_INTENSITY;\n    \n    return (flare + glow) / (y + 1e-5) + glare * glareColor;\n}","name":"Common","description":"","type":"common"}]}