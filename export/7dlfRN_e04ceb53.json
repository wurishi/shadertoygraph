{"ver":"0.1","info":{"id":"7dlfRN","date":"1644588354","viewed":266,"name":"Cubic to quad bezier approximat.","username":"slyvek","description":"Few methods to approximate cubic bezier curve with multiple quadratic beziers.\nWhite: cubic curve\nYellow: quadratic curves","likes":10,"published":1,"flags":0,"usePreview":1,"tags":["bezier","approximation","cubic","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2022 Sylwester Łoś\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Quadratic distance from: https://www.shadertoy.com/view/MlKcDD\n// Cubic distance from: https://www.shadertoy.com/view/4sKyzW\n// Cubic to Quadratic apporximation by Google from https://github.com/fonttools/fonttools\n// Cubic to 2 quadratic from https://github.com/ttnghia/QuadraticApproximation\n\n// 0: just convert cubic to quadratic (1 quadratic in sum)\n// 1: split cubic to 2 quadratics (2 quadratics in sum) - C1 Continuous\n// 2: split cubic to 2 cubics, then convert each to quadratic (2 quadratics in sum)\n// 3: the same as 2, but C1 Continuous\n\n// 4: split cubic to 2 cubics, then each to 2 quadratic (4 quadratics in sum) - C1 Continuous\n// 5: split cubic to 3 cubics, then each to 2 quadratic (4 quadratics in sum) - C1 Continuous\n// 6: split cubic to 4 cubics, then each to 2 quadratic (4 quadratics in sum) - C1 Continuous\n// 7: split cubic to 2, 3 or 4 cubics, then each to 2 quadratic (max 8 quadratics in sum) - C1 Continuous\n\n// 8: split cubic to 4 cubics, then convert each to quadratic (4 quadratics in sum)\n\n// 9: precise method (very slow) - C1 Continuous\n\n// 99: show inflection points\n\n\n#define METHOD 7\n\n#define METHOD_7_SPLIT_COUNT 4\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cro( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n// signed distance to a quadratic bezier\nfloat sdQuadraticBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b))/3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n    float sgn = 0.0;\n\n    float p  = ky - kx*kx;\n    float q  = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float p3 = p*p*p;\n    float q2 = q*q;\n    float h  = q2 + 4.0*p3;\n\n    if( h>=0.0 ) \n    {   // 1 root\n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n\n        #if 0\n        // When p≈0 and p<0, h-q has catastrophic cancelation. So, we do\n        // h=√(q²+4p³)=q·√(1+4p³/q²)=q·√(1+w) instead. Now we approximate\n        // √ by a linear Taylor expansion into h≈q(1+½w) so that the q's\n        // cancel each other in h-q. Expanding and simplifying further we\n        // get x=vec2(p³/q,-p³/q-q). And using a second degree Taylor\n        // expansion instead: x=vec2(k,-k-q) with k=(1-p³/q²)·p³/q\n        if( abs(p)<0.001 )\n        {\n            float k = p3/q;              // linear approx\n          //float k = (1.0-p3/q2)*p3/q;  // quadratic approx \n            x = vec2(k,-k-q);  \n        }\n        #endif\n\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        vec2  q = d+(c+b*t)*t;\n        res = dot2(q);\n    \tsgn = cro(c+2.0*b*t,q);\n    }\n    else \n    {   // 3 roots\n        float z = sqrt(-p);\n        float v = acos(q/(p*z*2.0))/3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0 );\n        vec2  qx=d+(c+b*t.x)*t.x; float dx=dot2(qx), sx = cro(c+2.0*b*t.x,qx);\n        vec2  qy=d+(c+b*t.y)*t.y; float dy=dot2(qy), sy = cro(c+2.0*b*t.y,qy);\n        if( dx<dy ) { res=dx; sgn=sx; } else {res=dy; sgn=sy; }\n    }\n    \n    return sqrt( res )*sign(sgn);\n}\n\nconst float eps = .000005;\nconst float zoom = 1.;\nconst float dot_size=.005;\nconst vec3 point_col=vec3(1,1,0);\nconst int halley_iterations = 8;\n\n//lagrange positive real root upper bound\n//see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(a0,a1,a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn max_max + max_max2;\n}\n\n//lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(-a0,a1,-a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn -max_max - max_max2;\n}\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0] = min(roots[0],min(roots[1],roots[2]));\n\ttmp[1] = max(roots[0],min(roots[1],roots[2]));\n\ttmp[2] = max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\nvoid sort_roots4(inout vec4 roots){\n\tvec4 tmp;\n\n\tvec2 min1_2 = min(roots.xz,roots.yw);\n\tvec2 max1_2 = max(roots.xz,roots.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\ttmp[0] = min(min1_2.x,min1_2.y);\n\ttmp[1] = min(maxmin,minmax);\n\ttmp[2] = max(minmax,maxmin);\n\ttmp[3] = max(max1_2.x,max1_2.y);\n\n\troots = tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n\treturn f;\n}\n\n//halley's method\n//basically a variant of newton raphson which converges quicker and has bigger basins of convergence\n//see http://mathworld.wolfram.com/HalleysMethod.html\n//or https://en.wikipedia.org/wiki/Halley%27s_method\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n        if(old_num!=num){\n            if(old_num == 0){\n                s[0] = tmp[0];\n                s[1] = tmp[1];\n            }\n            else{//old_num == 2\n                s[2] = tmp[0];\n                s[3] = tmp[1];\n            }\n        }\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\n//Sign computation is pretty straightforward:\n//I'm solving a cubic equation to get the intersection count\n//of a ray from the current point to infinity and parallel to the x axis\n//Also i'm computing the intersection count with the tangent in the end points of the curve\nfloat cubic_bezier_sign(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tint n_ints = 0;\n\n\tfor(int i=0;i<3;i++){\n\t\tif(i < n_roots){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos < uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvec2 tang1 = p0.xy - p1.xy;\n\tvec2 tang2 = p2.xy - p3.xy;\n\n\tvec2 nor1 = vec2(tang1.y,-tang1.x);\n\tvec2 nor2 = vec2(tang2.y,-tang2.x);\n\n\tif(p0.y < p1.y){\n\t\tif((uv.y<=p0.y) && (dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif(!(uv.y<=p0.y) && !(dot(uv-p0.xy,nor1)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(p2.y<p3.y){\n\t\tif(!(uv.y<=p3.y) && dot(uv-p3.xy,nor2)<0.){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\telse{\n\t\tif((uv.y<=p3.y) && !(dot(uv-p3.xy,nor2)<0.)){\n\t\t\tn_ints++;\n\t\t}\n\t}\n\n\tif(n_ints==0 || n_ints==2 || n_ints==4){\n\t\treturn 1.;\n\t}\n\telse{\n\t\treturn -1.;\n\t}\n}\n\nfloat sdCubicBezier(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\t//switch points when near to end point to minimize numerical error\n\t//only needed when control point(s) very far away\n\t#if 0\n\tvec2 mid_curve = parametric_cub_bezier(.5,p0,p1,p2,p3);\n\tvec2 mid_points = (p0 + p3)/2.;\n\n\tvec2 tang = mid_curve-mid_points;\n\tvec2 nor = vec2(tang.y,-tang.x);\n\n\tif(sign(dot(nor,uv-mid_curve)) != sign(dot(nor,p0-mid_curve))){\n\t\tvec2 tmp = p0;\n\t\tp0 = p3;\n\t\tp3 = tmp;\n\n\t\ttmp = p2;\n\t\tp2 = p1;\n\t\tp1 = tmp;\n\t}\n\t#endif\n\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n    \n    //compute polynomial describing distance to current pixel dependent on a parameter t\n\tfloat bc6 = dot(a3,a3);\n\tfloat bc5 = 2.*dot(a3,a2);\n\tfloat bc4 = dot(a2,a2) + 2.*dot(a1,a3);\n\tfloat bc3 = 2.*(dot(a1,a2) + dot(a0,a3));\n\tfloat bc2 = dot(a1,a1) + 2.*dot(a0,a2);\n\tfloat bc1 = 2.*dot(a0,a1);\n\tfloat bc0 = dot(a0,a0);\n\n\tbc5 /= bc6;\n\tbc4 /= bc6;\n\tbc3 /= bc6;\n\tbc2 /= bc6;\n\tbc1 /= bc6;\n\tbc0 /= bc6;\n    \n    //compute derivatives of this polynomial\n\n\tfloat b0 = bc1 / 6.;\n\tfloat b1 = 2. * bc2 / 6.;\n\tfloat b2 = 3. * bc3 / 6.;\n\tfloat b3 = 4. * bc4 / 6.;\n\tfloat b4 = 5. * bc5 / 6.;\n\n\tvec4 c1 = vec4(b1,2.*b2,3.*b3,4.*b4)/5.;\n\tvec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;\n\tvec2 c3 = vec2(c2[1],2.*c2[2])/3.;\n\tfloat c4 = c3[1]/2.;\n\n\tvec4 roots_drv = vec4(1e38);\n\n\tint num_roots_drv = solve_quartic(c1,roots_drv);\n\tsort_roots4(roots_drv);\n\n\tfloat ub = upper_bound_lagrange5(b0,b1,b2,b3,b4);\n\tfloat lb = lower_bound_lagrange5(b0,b1,b2,b3,b4);\n\n\tvec3 a = vec3(1e38);\n\tvec3 b = vec3(1e38);\n\n\tvec3 roots = vec3(1e38);\n\n\tint num_roots = 0;\n    \n\t//compute root isolating intervals by roots of derivative and outer root bounds\n    //only roots going form - to + considered, because only those result in a minimum\n\tif(num_roots_drv==4){\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) > 0.){\n\t\t\ta[0]=lb;\n\t\t\tb[0]=roots_drv[0];\n\t\t\tnum_roots=1;\n\t\t}\n\n\t\tif(sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1])) != sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[2]))){\n            if(num_roots == 0){\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=roots_drv[2];\n                num_roots=1;\n            }\n            else{\n            \ta[1]=roots_drv[1];\n\t\t\t\tb[1]=roots_drv[2];\n                num_roots=2;\n            }\n\t\t}\n\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[3]) < 0.){\n            if(num_roots == 0){\n                a[0]=roots_drv[3];\n                b[0]=ub;\n                num_roots=1;\n            }\n            else if(num_roots == 1){\n                a[1]=roots_drv[3];\n                b[1]=ub;\n                num_roots=2;\n            }\n            else{\n                a[2]=roots_drv[3];\n                b[2]=ub;\n                num_roots=3;\n            }\n\t\t}\n\t}\n\telse{\n\t\tif(num_roots_drv==2){\n\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) < 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=ub;\n\t\t\t}\n\t\t\telse if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1]) > 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum_roots=2;\n\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\n\t\t\t\ta[1]=roots_drv[1];\n\t\t\t\tb[1]=ub;\n\t\t\t}\n\n\t\t}\n\t\telse{//num_roots_drv==0\n\t\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\n\t\t\tvec2 roots_trd_drv=vec2(1e38);\n\t\t\tint num_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t\tnum_roots=1;\n\n\t\t\ta[0]=lb;\n\t\t\tb[0]=ub;\n\t\t}\n        \n        //further subdivide intervals to guarantee convergence of halley's method\n\t\t//by using roots of further derivatives\n\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\t\tsort_roots3(roots_snd_drv);\n\n\t\tint num_roots_trd_drv=0;\n\t\tvec2 roots_trd_drv=vec2(1e38);\n\n\t\tif(num_roots_snd_drv!=3){\n\t\t\tnum_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t}\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(i < num_roots){\n\t\t\t\tfor(int j=0;j<3;j+=2){\n\t\t\t\t\tif(j < num_roots_snd_drv){\n\t\t\t\t\t\tif(a[i] < roots_snd_drv[j] && b[i] > roots_snd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_snd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tif(j < num_roots_trd_drv){\n\t\t\t\t\t\tif(a[i] < roots_trd_drv[j] && b[i] > roots_trd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_trd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat d0 = 1e38;\n\n    //compute roots with halley's method\n    \n\tfor(int i=0;i<3;i++){\n\t\tif(i < num_roots){\n\t\t\troots[i] = .5 * (a[i] + b[i]);\n\n            for(int j=0;j<halley_iterations;j++){\n\t\t\t\troots[i] = halley_iteration5(b0,b1,b2,b3,b4,roots[i]);\n            }\n\t\t\t\n\n            //compute squared distance to nearest point on curve\n\t\t\troots[i] = clamp(roots[i],0.,1.);\n\t\t\tvec2 to_curve = uv - parametric_cub_bezier(roots[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,dot(to_curve,to_curve));\n\t\t}\n\t}\n\n\treturn sqrt(d0);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat drawCubicCurve(in vec2 p, in vec2 v0, in vec2 v1, in vec2 v2, in vec2 v3 ) {\n\n\n    float d = sdCubicBezier(p, v0,v1,v2,v3 );\n    float main = 1.0-smoothstep(0.008,0.015,abs(d));\n    \n    float linesAndDots = min(min( udSegment(p,v0,v1), udSegment(p,v1,v2) ), udSegment(p,v2,v3));\n    linesAndDots = min( linesAndDots, length(p-v0)-0.02 );\n    linesAndDots = min( linesAndDots, length(p-v1)-0.02 );\n    linesAndDots = min( linesAndDots, length(p-v2)-0.02 );\n    linesAndDots = min( linesAndDots, length(p-v3)-0.02 );\n        \n    float aux = 1.0-smoothstep(0.0,0.007,linesAndDots);\n    return max(main, aux * 0.5);\n}\n\n\nfloat drawQuadraticCurve(in vec2 p, in vec2 v0, in vec2 v1, in vec2 v2 ) {\n\n\n    float d = sdQuadraticBezier(p, v0,v1,v2 );\n    float main = 1.0-smoothstep(0.0,0.01,abs(d));\n    \n    float linesAndDots = min( udSegment(p,v0,v1), udSegment(p,v1,v2) );\n    linesAndDots = min( linesAndDots, length(p-v0)-0.02 );\n    linesAndDots = min( linesAndDots, length(p-v1)-0.02 );\n    linesAndDots = min( linesAndDots, length(p-v2)-0.02 );\n        \n    float aux = 1.0-smoothstep(0.0,0.007,linesAndDots);\n    return max(main, aux * 0.5);\n}\n\nfloat convertToQuadratic(in vec2 p, in vec2 A, in vec2 B, in vec2 C, in vec2 D, in float t ) {\n\n    vec2 q0 = A;\n    vec2 q1 = mix( mix(A, B, 1.5), mix(D, C, 1.5),t);\n    vec2 q2 = D;\n\n    \n    return drawQuadraticCurve(p, q0, q1, q2);\n}\n\n\nfloat splitToTwoQuadratic(in vec2 p, in vec2 A, in vec2 B, in vec2 C, in vec2 D ) {\n\n    float gamma = 0.5;\n    vec2 q0 = A;\n    vec2 q4 = D;\n    \n    vec2 q1 = mix(A, B, 1.5 * gamma);\n    vec2 q3 = mix(D, C, 1.5 * gamma);\n    \n    vec2 q2 = mix(q1, q3, 0.5);\n     \n     return max(drawQuadraticCurve(p, q0, q1, q2), drawQuadraticCurve(p, q2, q3, q4));\n}\n\n\nfloat splitToTwoCubicThenConvertToQuadratic(in vec2 p, in vec2 A, in vec2 B, in vec2 C, in vec2 D, in float phase1, in float phase2 ) {\n\n    vec2 mid = (A + 3.0 * (B + C) + D) * .125;\n    vec2 deriv3 = (D + C - B - A) * .125;\n    \n    vec2 A1 = A;\n    vec2 B1 = mix(A, B, 0.5);\n    vec2 C1 = mid - deriv3;\n    vec2 D1 = mid;\n    \n    vec2 A2 = mid;\n    vec2 B2 = mid + deriv3;\n    vec2 C2 = mix(C, D, 0.5);\n    vec2 D2 = D;\n\n\n\n    //return max(convertToQuadratic(p, A1, B1, C1, D1, 1.0/3.0), convertToQuadratic(p, A2, B2, C2, D2, 2.0/3.0));\n    \n    return max(convertToQuadratic(p, A1, B1, C1, D1, phase1), convertToQuadratic(p, A2, B2, C2, D2, phase2));\n}\n\n\nfloat splitToTwoCubicThenTwoQuadratic(in vec2 p, in vec2 A, in vec2 B, in vec2 C, in vec2 D ) {\n\n    vec2 mid = (A + 3.0 * (B + C) + D) * .125;\n    vec2 deriv3 = (D + C - B - A) * .125;\n    \n    vec2 A1 = A;\n    vec2 B1 = mix(A, B, 0.5);\n    vec2 C1 = mid - deriv3;\n    vec2 D1 = mid;\n    \n    vec2 A2 = mid;\n    vec2 B2 = mid + deriv3;\n    vec2 C2 = mix(C, D, 0.5);\n    vec2 D2 = D;\n\n\n    return max(splitToTwoQuadratic(p, A1, B1, C1, D1), splitToTwoQuadratic(p, A2, B2, C2, D2));\n}\n\n\nfloat splitToThreeCubicThenTwoQuadratic(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 ) {\n\n\n    float _27 = 1.0 / 27.0;\n\n    vec2 mid1 = (8.0*p0 + 12.0*p1 + 6.0*p2 + p3) * _27;\n    vec2 deriv1 = (p3 + 3.0*p2 - 4.0*p0) * _27;\n    vec2 mid2 = (p0 + 6.0*p1 + 12.0*p2 + 8.0*p3) * _27;\n    vec2 deriv2 = (4.0*p3 - 3.0*p1 - p0) * _27;\n    \n    vec2 A1 = p0;\n    vec2 B1 = (2.0*p0 + p1) / 3.0;\n    vec2 C1 = mid1 - deriv1;\n    vec2 D1 = mid1;\n    \n    vec2 A2 = mid1;\n    vec2 B2 = mid1 + deriv1;\n    vec2 C2 = mid2 - deriv2;\n    vec2 D2 = mid2;\n    \n    vec2 A3 = mid2;\n    vec2 B3 = mid2 + deriv2;\n    vec2 C3 = (p2 + 2.0*p3) / 3.0;\n    vec2 D3 = p3;\n\n    return max(max(splitToTwoQuadratic(p, A1, B1, C1, D1), splitToTwoQuadratic(p, A2, B2, C2, D2)), splitToTwoQuadratic(p, A3, B3, C3, D3));\n}\n\n\nfloat splitToFourCubicThenTwoQuadratic(in vec2 p, in vec2 A, in vec2 B, in vec2 C, in vec2 D ) {\n\n\n\n    vec2 mid = (A + 3.0 * (B + C) + D) * .125;\n    vec2 deriv3 = (D + C - B - A) * .125;\n     \n    \n    vec2 A1 = A;\n    vec2 B1 = mix(A, B, 0.5);\n    vec2 C1 = mid - deriv3;\n    vec2 D1 = mid;\n    \n    vec2 A2 = mid;\n    vec2 B2 = mid + deriv3;\n    vec2 C2 = mix(C, D, 0.5);\n    vec2 D2 = D;\n\n\n    vec2 mid1 = (A1 + 3.0 * (B1 + C1) + D1) * .125;\n    vec2 mid2 = (A2 + 3.0 * (B2 + C2) + D2) * .125;\n    \n    vec2 deriv31 = (D1 + C1 - B1 - A1) * .125;\n    vec2 deriv32 = (D2 + C2 - B2 - A2) * .125;\n\n\n    vec2 A11 = A1;\n    vec2 B11 = mix(A1, B1, 0.5);\n    vec2 C11 = mid1 - deriv31;\n    vec2 D11 = mid1;\n    \n    vec2 A12 = mid1;\n    vec2 B12 = mid1 + deriv31;\n    vec2 C12 = mix(C1, D1, 0.5);\n    vec2 D12 = D1;\n    \n    vec2 A21 = A2;\n    vec2 B21 = mix(A2, B2, 0.5);\n    vec2 C21 = mid2 - deriv32;\n    vec2 D21 = mid2;\n    \n    vec2 A22 = mid2;\n    vec2 B22 = mid2 + deriv32;\n    vec2 C22 = mix(C2, D2, 0.5);\n    vec2 D22 = D2;\n\n\n    float max1 = max(splitToTwoQuadratic(p, A11, B11, C11, D11), splitToTwoQuadratic(p, A12, B12, C12, D12));\n    float max2 = max(splitToTwoQuadratic(p, A21, B21, C21, D21), splitToTwoQuadratic(p, A22, B22, C22, D22));\n\n    return max(max1, max2);\n}\n\nfloat splitToTwoThreeFourCubicThenTwoQuadratic(in vec2 p, in vec2 A, in vec2 B, in vec2 C, in vec2 D ) {\n    \n    // check if points B and C are on the different sides of lines AC and BD\n    \n    float sideB = (C.x - A.x) * (B.y - A.y) - (C.y - A.y) * (B.x - A.x);\n    float sideC = (D.x - B.x) * (C.y - B.y) - (D.y - B.y) * (C.x - B.x);\n        \n    vec2 sweetSpotB = mix(A, D, 0.33);\n    vec2 sweetSpotC = mix(A, D, 0.66);\n    \n    float distFromSweet = max(length(B - sweetSpotB), length(C - sweetSpotC)) / length(A - D);\n    \n    bool loopOrSerpentine = dot(B - A, D - A) > dot(C - A, D - A);\n    bool sShape = sign(sideB) != sign(sideC);\n    bool controlNotVeryVeryClose = distFromSweet > 1.0 / 20.0;\n    bool controlNotVeryClose = distFromSweet > 1.0 / 6.0;\n    bool controlNotClose = distFromSweet > 2.0/3.0;\n\n    int splitNumber = 0;\n    if (loopOrSerpentine) splitNumber += 1;\n    if (sShape) splitNumber += 1;\n    if (controlNotVeryVeryClose) splitNumber += 1;\n    if (controlNotVeryClose) splitNumber += 1;\n    if (controlNotClose) splitNumber += 1;\n\n    if (splitNumber <= 1) { \n        return splitToTwoQuadratic(p, A, B, C, D);\n    } else if (splitNumber <= 2) { \n        return splitToTwoCubicThenTwoQuadratic(p, A, B, C, D);\n    } else if (splitNumber <= 3) { \n        return splitToThreeCubicThenTwoQuadratic(p, A, B, C, D);\n    } else {\n        return splitToFourCubicThenTwoQuadratic(p, A, B, C, D);\n    }\n}\n\nfloat splitToFourCubicThenConvertToQuadratic(in vec2 p, in vec2 A, in vec2 B, in vec2 C, in vec2 D, in bool continuous ) {\n\n    vec2 mid = (A + 3.0 * (B + C) + D) * .125;\n    vec2 deriv3 = (D + C - B - A) * .125;\n    \n    vec2 A1 = A;\n    vec2 B1 = mix(A, B, 0.5);\n    vec2 C1 = mid - deriv3;\n    vec2 D1 = mid;\n    \n    vec2 A2 = mid;\n    vec2 B2 = mid + deriv3;\n    vec2 C2 = mix(C, D, 0.5);\n    vec2 D2 = D;\n\n    vec4 phases;\n    if (continuous == true) {\n        phases = vec4(0.0, 1.0/3.0, 2.0/3.0, 1.0);\n    } else {\n        phases = vec4(0.5, 0.5, 0.5, 0.5);\n    }\n\n    return max(splitToTwoCubicThenConvertToQuadratic(p, A1, B1, C1, D1, phases.r, phases.g), splitToTwoCubicThenConvertToQuadratic(p, A2, B2, C2, D2, phases.b, phases.a));\n}\n\nvec2 cubicInflectionPointsT(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3 ) {\n    //return vec2(0.1, 0.2);\n     \n    vec2 pa = p1 - p0;\n    vec2 pb = p2 - (p1 * 2.0) + p0;\n    vec2 pc = p3 - (p2 * 3.0) + (p1 * 3.0) - p0;\n\n    float a = pb.x * pc.y - pb.y * pc.x;\n    float b = pa.x * pc.y - pa.y * pc.x;\n    float c = pa.x * pb.y - pa.y * pb.x;\n    \n    if (a == 0.0) {\n        // Not a quadratic equation.\n        if (b == 0.0) {\n            // Instead of a linear acceleration change we have a constant\n            // acceleration change. This means the equation has no solution\n            // and there are no inflection points, unless the constant is 0.\n            // In that case the curve is a straight line, essentially that means\n            // the easiest way to deal with is is by saying there's an inflection\n            // point at t == 0. The inflection point approximation range found will\n            // automatically extend into infinity.\n            if (c == 0.0) {\n               return vec2(-1.0);\n            }\n            return vec2(-1.0);\n        }\n        return vec2(-c / b, -1.0);\n    }\n    \n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant < 0.0) {\n        return vec2(-1.0);\n    }\n\n    if (discriminant == 0.0) {\n        return vec2(-b / (2.0 * a), -1.0);\n    }\n    \n\n    float discriminant_sqrt = sqrt(discriminant);\n    float q;\n    \n    if (b < 0.0) {\n        q = b - discriminant_sqrt;\n    } else { \n        q = b + discriminant_sqrt;\n    }\n    \n    q *= -0.5;\n\n    float t1 = q / a;\n    float t2 = c / q;\n    \n    if ((t1 > 0.0 && t1 < 1.0) && (t2 > 0.0 && t2 < 1.0)) {\n        if (t1 > t2) {\n            float tmp = t1;\n            t1 = t2;\n            t2 = tmp;\n        }\n\n        if (t2 - t1 > 0.00001) {\n            return vec2(t1, t2);\n        } else {\n            return vec2(t1, -1.0);\n        }\n     } else if (t1 > 0.0 && t1 < 1.0) {\n        return vec2(t1, -1.0);\n     } else if (t2 > 0.0 && t2 < 1.0) {\n        return vec2(t2, -1.0);\n     }\n    \n    return vec2(-1.0);\n}\n\nfloat showInflectionPoints(in vec2 p, in vec2 A, in vec2 B, in vec2 C, in vec2 D ) {\n\n    vec2 inflectionPoints = cubicInflectionPointsT(A, B, C, D);\n\n    \n    float dots = 1.0;\n    //dots = min( dots, length(p - parametric_cub_bezier(inflectionPoints.x,A,B,C,D))-0.02 );\n    //dots = min( dots, length(p - parametric_cub_bezier(inflectionPoints.y,A,B,C,D))-0.02 );\n    \n    if (inflectionPoints.x > 0.0) {\n        dots = min( dots, length(p - parametric_cub_bezier(inflectionPoints.x,A,B,C,D))-0.02 );\n    }\n    \n    if (inflectionPoints.y > 0.0) {\n        dots = min( dots, length(p - parametric_cub_bezier(inflectionPoints.y,A,B,C,D))-0.02 );\n    }\n    \n        \n    return 1.0 - smoothstep(0.0,0.007,dots);\n\t\t\n}\n\nmat3 calc_cubic_points(in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    vec2 p1 = d;\n    vec2 p2 = (c / 3.0) + d;\n    vec2 p3 = (b + c) / 3.0 + p2;\n    vec2 p4 = a + d + c + b;\n\n    return mat3(p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, 0.0);\n}\n\nvoid split_cubic_into_n_iter(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in int n, inout mat3[20] array) {\n    \n    vec2 c = (p1 - p0) * 3.0;\n    vec2 b = (p2 - p1) * 3.0 - c;\n    vec2 d = p0;\n    vec2 a = p3 - d - c - b;\n\n    float dt = 1.0 / float(n);\n    float delta_2 = dt * dt;\n    float delta_3 = dt * delta_2;\n    \n    for(int i = 0; i < n; i++) {\n        \n        float t1 = float(i) * dt;\n        float t1_2 = t1 * t1;\n\n        vec2 a1 = a * delta_3;\n        vec2 b1 = (3.0 * a * t1 + b) * delta_2;\n        vec2 c1 = (2.0 * b * t1 + c + 3.0 * a * t1_2) * dt;\n        vec2 d1 = a * t1 * t1_2 + b * t1_2 + c * t1 + d;\n        \n        mat3 cubicPoints = calc_cubic_points(a1, b1, c1, d1);\n        array[i] = cubicPoints;  \n    }\n}\n\n\nbool calc_intersect(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, inout vec2 intersection) {\n    vec2 ab = p1 - p0;\n    vec2 cd = p3 - p2;\n    vec2 p = vec2(ab.y, -ab.x);\n\n    float pcd = dot(p, cd);\n\n    if (pcd == 0.0) {\n        // colinear\n        return false;\n    }\n\n    float h = dot(p, p0 - p2) / pcd;\n\n    intersection = p2 + cd * h;\n    \n    return true;\n}\n        \nbool cubic_farthest_fit_inside4(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in float tolerance) {\n    if (abs(p2.x) <= tolerance && abs(p2.y) <= tolerance && abs(p1.x) <= tolerance && abs(p1.y) <= tolerance) {\n        return true;\n    }\n\n    return false;\n}\n        \nbool cubic_farthest_fit_inside3(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in float tolerance) {\n    if (abs(p2.x) <= tolerance && abs(p2.y) <= tolerance && abs(p1.x) <= tolerance && abs(p1.y) <= tolerance) {\n        return true;\n    }\n\n    vec2 mid = (p0 + 3.0 * (p1 + p2) + p3) * .125;\n\n    if (abs(mid.x) > tolerance || abs(mid.y) > tolerance) {\n        return false;\n    }\n\n    vec2 deriv3 = (p3 + p2 - p1 - p0) * .125;\n    \n\n    return cubic_farthest_fit_inside4(p0, (p0 + p1) * .5,  mid - deriv3, mid, tolerance)\n            && cubic_farthest_fit_inside4(mid, mid + deriv3, (p2 + p3) * .5, p3, tolerance);\n}\n\n\nbool cubic_farthest_fit_inside2(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in float tolerance) {\n    if (abs(p2.x) <= tolerance && abs(p2.y) <= tolerance && abs(p1.x) <= tolerance && abs(p1.y) <= tolerance) {\n        return true;\n    }\n\n    vec2 mid = (p0 + 3.0 * (p1 + p2) + p3) * .125;\n\n    if (abs(mid.x) > tolerance || abs(mid.y) > tolerance) {\n        return false;\n    }\n\n    vec2 deriv3 = (p3 + p2 - p1 - p0) * .125;\n    \n\n    return cubic_farthest_fit_inside3(p0, (p0 + p1) * .5,  mid - deriv3, mid, tolerance)\n            && cubic_farthest_fit_inside3(mid, mid + deriv3, (p2 + p3) * .5, p3, tolerance);\n}\n\n\nbool cubic_farthest_fit_inside(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in float tolerance) {\n    // simulated recurence\n    if (tolerance >= 99999.0) {\n        return true;\n    }\n    if (abs(p2.x) <= tolerance && abs(p2.y) <= tolerance && abs(p1.x) <= tolerance && abs(p1.y) <= tolerance) {\n        return true;\n    }\n\n    vec2 mid = (p0 + 3.0 * (p1 + p2) + p3) * .125;\n\n    if (abs(mid.x) > tolerance || abs(mid.y) > tolerance) {\n        return false;\n    }\n\n    vec2 deriv3 = (p3 + p2 - p1 - p0) * .125;\n    \n\n    return cubic_farthest_fit_inside2(p0, (p0 + p1) * .5,  mid - deriv3, mid, tolerance)\n            && cubic_farthest_fit_inside2(mid, mid + deriv3, (p2 + p3) * .5, p3, tolerance);\n}\n\nbool cubic_approx_quadratic(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, float tolerance, inout vec2[22] quadraticSplineArray) {\n         \n    vec2 q1;\n    bool intersected = calc_intersect(p0, p1, p2, p3, q1);\n\n    if (intersected == false) {\n        return false;\n    }\n\n    float _2_3 = 2.0/3.0;\n    \n    vec2 c0 = p0;\n    vec2 c3 = p3;\n    vec2 c1 = c0 + (q1 - c0) * _2_3;\n    vec2 c2 = c3 + (q1 - c3) * _2_3;\n\n\n    //if (!cubic_farthest_fit_inside(vec2(0.0), c1 - p1, c2 - p2, vec2(0.0), tolerance)) {\n    //    return false;\n    //}\n    \n    quadraticSplineArray[0] = c0;\n    quadraticSplineArray[1] = q1;\n    quadraticSplineArray[2] = c3;\n\n    return true;\n}\n\nfloat drawQuadraticSpline(in vec2 p, in int count, in vec2[22] splineArray) {\n    float draw = 0.0;\n    vec2 q0 = splineArray[0];\n    for (int i = 1; i < count - 2; i++) {\n        vec2 q1 = splineArray[i];\n        vec2 next = splineArray[i + 1];\n        vec2 q2 = mix(q1, next, 0.5);\n        draw = max(draw, drawQuadraticCurve(p, q0, q1, q2));\n        q0 = q2;\n    }\n    vec2 lastQ1 = splineArray[count - 2];\n    vec2 lastQ2 = splineArray[count - 1];\n    draw = max(draw, drawQuadraticCurve(p, q0, lastQ1, lastQ2));\n    return draw;\n}\n\nvec2 cubic_approx_control(in float t, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3) {\n    vec2 q1A = mix(p0, p1, 1.5);\n    vec2 q1B = mix(p3, p2, 1.5);\n    return mix(q1A, q1B, t);\n}\n\nbool splitWithCountAndTolerance(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, int count, float tolerance, inout vec2[22] quadraticSplineArray ) {\n\n    \n\n    if(count == 1) {\n        bool found = cubic_approx_quadratic(p0, p1, p2, p3, tolerance, quadraticSplineArray);\n\n        return found;\n    }\n    \n   \n    mat3[20] cubicArray;\n    split_cubic_into_n_iter(p0, p1, p2, p3, count, cubicArray);\n    \n    mat3 next_cubic = cubicArray[0];\n    vec2 next_c0 = vec2(next_cubic[0][0], next_cubic[0][1]);\n    vec2 next_c1 = vec2(next_cubic[0][2], next_cubic[1][0]);\n    vec2 next_c2 = vec2(next_cubic[1][1], next_cubic[1][2]);\n    vec2 next_c3 = vec2(next_cubic[2][0], next_cubic[2][1]);\n    vec2 next_q1 = cubic_approx_control(0.0, next_c0, next_c1, next_c2, next_c3);\n    quadraticSplineArray[0] = next_c0;\n    quadraticSplineArray[1] = next_q1;\n    int splineIndex = 2;\n\n    vec2 q2 = next_c0;\n    vec2 d1 = vec2(0.0);\n    \n    float _2_3 = 2.0/3.0;\n    \n    for (int i = 1; i <= count; i++) {\n        vec2 c0 = next_c0;\n        vec2 c1 = next_c1;\n        vec2 c2 = next_c2;\n        vec2 c3 = next_c3;\n        \n        vec2 q0 = q2;\n        vec2 q1 = next_q1;\n        \n        if (i < count) {\n            next_cubic = cubicArray[i];\n            next_c0 = vec2(next_cubic[0][0], next_cubic[0][1]);\n            next_c1 = vec2(next_cubic[0][2], next_cubic[1][0]);\n            next_c2 = vec2(next_cubic[1][1], next_cubic[1][2]);\n            next_c3 = vec2(next_cubic[2][0], next_cubic[2][1]);\n\n            next_q1 = cubic_approx_control(float(i) / float(count - 1), next_c0, next_c1, next_c2, next_c3);\n            quadraticSplineArray[splineIndex] = next_q1;\n            splineIndex++;\n            \n            q2 = (q1 + next_q1) * 0.5;\n        } else {\n            q2 = c3;\n        }\n        \n        vec2 d0 = d1;\n        d1 = q2 - c2;\n\n\n/*\n        if (d1.x > tolerance || d1.y > tolerance ||\n            !cubic_farthest_fit_inside(d0,\n                                       q0 + (q1 - q0) * _2_3 - c1,\n                                       q2 + (q1 - q2) * _2_3 - c2,\n                                       d1,\n                                       tolerance)) {\n            return false;\n        }\n        */\n        \n    }\n    \n    quadraticSplineArray[splineIndex] = p3;\n    \n    \n    return true;\n\t\n}\n\n\nfloat splitWithTolerance(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, float tolerance ) {\n\n    int maxCount = 20;\n    vec2[22] quadraticSplineArray;  // maxCount + 2\n    for (int i = 1; i < maxCount; i++) {\n        bool found = splitWithCountAndTolerance(p, p0, p1, p2, p3, i, tolerance, quadraticSplineArray);\n        if (found == true) {\n            int splinePoints = i + 2;\n            return drawQuadraticSpline(p, splinePoints, quadraticSplineArray);\n        }\n    }\n \n    return 0.0;\n}\n\n\nfloat splitWithCount(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, int maxCount ) {\n\n    vec2[22] quadraticSplineArray;  // maxCount + 2\n    splitWithCountAndTolerance(p, p0, p1, p2, p3, maxCount, 999999.0, quadraticSplineArray);\n    int splinePoints = maxCount + 2;\n    return drawQuadraticSpline(p, splinePoints, quadraticSplineArray);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float closeToSweets = cos(iTime*0.9) * 0.5 + 0.5;\n    \n\tvec2 v0 = vec2(1.3,0.9)*cos(iTime*0.5 + vec2(0.0,5.0) );\n    vec2 v1 = vec2(1.3,0.9)*cos(iTime*0.6 + vec2(3.0,4.0) );\n    vec2 v2 = vec2(1.3,0.9)*cos(iTime*0.7 + vec2(2.0,0.0) );\n    vec2 v3 = vec2(1.3,0.9)*cos(iTime*0.8 + vec2(2.0,0.0) );\n    \n    v1 = mix(v1, mix(v0, v3, 1.0/3.0), closeToSweets);\n    v2 = mix(v2, mix(v0, v3, 2.0/3.0), closeToSweets);\n\n    \n    //v0 = vec2(-1.0, 0.0);\n    //v1 = vec2(-0.8, 0.5);\n    //v2 = vec2(0.8, 0.5);\n    //v3 = vec2(1.0, 0.0);\n\n    vec3 col = vec3(0.1, 0.1, 0.2);\n    \n    float cubic = drawCubicCurve(p, v0, v1, v2, v3);\n    col = mix( col, vec3(1.0,1.0,1.0), cubic );\n    \n    \n    #if METHOD==0\n    float quadratic = convertToQuadratic( p, v0,v1,v2,v3, 0.5 );\n    #elif METHOD==1\n    float quadratic = splitToTwoQuadratic( p, v0,v1,v2,v3 );\n    #elif METHOD==2\n    float quadratic = splitToTwoCubicThenConvertToQuadratic( p, v0,v1,v2,v3, 0.5, 0.5 );\n    #elif METHOD==3\n    float quadratic = splitToTwoCubicThenConvertToQuadratic( p, v0,v1,v2,v3, 0.0, 1.0 );\n    \n    #elif METHOD==4\n    float quadratic = splitToTwoCubicThenTwoQuadratic( p, v0,v1,v2,v3 );\n    #elif METHOD==5\n    float quadratic = splitToThreeCubicThenTwoQuadratic( p, v0,v1,v2,v3);\n    #elif METHOD==6\n    float quadratic = splitToFourCubicThenTwoQuadratic( p, v0,v1,v2,v3);\n    #elif METHOD==7\n    float quadratic = splitToTwoThreeFourCubicThenTwoQuadratic( p, v0,v1,v2,v3);\n    \n    #elif METHOD==8\n    float quadratic = splitToFourCubicThenConvertToQuadratic( p, v0,v1,v2,v3, false);\n\n    \n    \n    //#elif METHOD==50\n    //float quadratic = splitToFourCubicThenConvertToQuadratic( p, v0,v1,v2,v3, true );\n\n    #elif METHOD==9\n    //float tolerance = 1.0 / max(iResolution.x, iResolution.y);\n    //float quadratic = splitWithTolerance( p, v0,v1,v2,v3, tolerance * 400.0 );\n    float quadratic = splitWithCount( p, v0,v1,v2,v3, METHOD_7_SPLIT_COUNT );\n\n    \n    #elif METHOD==99\n    float quadratic = showInflectionPoints( p, v0,v1,v2,v3 );\n\n    #endif\n    col = mix( col, vec3(1.0,0.5,0.0), quadratic );\n\n\n    \n    \n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}