{"ver":"0.1","info":{"id":"stKGzh","date":"1637175961","viewed":102,"name":"sprixels w improved motion","username":"jneen","description":"as seen in maj7 cover ring vol. 2 https://www.youtube.com/watch?v=FiC09s1ut2A\n\nandrew did some post-processing on it to add chromatic aberration and change the hue","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sprixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define I (1.)\n#define O (0.)\n#define time (iTime*.2)\n\nvec2 uv;\n\nfloat[16] T1 = float[16](\n  I,O,O,O,\n  O,O,O,O,\n  O,O,I,O,\n  O,O,O,O\n);\n\nfloat[16] T2 = float[16](\n  O,O,I,O,\n  O,I,O,O,\n  I,O,O,O,\n  O,I,O,O\n);\n\nfloat[16] T3 = float[16](\n  O,I,I,O,\n  I,O,I,I,\n  O,I,O,I,\n  O,O,I,O\n);\n\nfloat[16] T4 = float[16](\n  I,I,I,I,\n  I,O,I,I,\n  I,I,I,I,\n  I,I,O,I\n);\n\nfloat px(float[16] arr, vec2 p) {\n  p = fract(p);\n  int x = int(p.x*4.);\n  int y = int((1.-p.y)*4.);\n  return arr[4*y+x];\n}\n\nmat2 rot(float x) { float s=sin(x),c=cos(x); return mat2(c,s,-s,c); }\n\n\n#define nsin(x) (.5+.5*sin(x))\n#define pmod(x,j) (mod(x,j)-.5*(j))\n\n#define MISS(x) (x>1000.)\n\n\nfloat sphere(vec3 p, float r) { return length(p)-r; }\nfloat box(vec3 p, vec3 a) {\n  vec3 q = abs(p)-a;\n  return length(max(q, 0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat boxle(vec3 p, float r, float q) {\n  return max(box(p, vec3(r)),-sphere(p,q*r));\n}\n\nfloat S(vec3 p) {\n  float gt = time*2.;\n  gt = (gt +.2*sin(gt))*1.5;\n  //float gtm = pmod(gt, .1);\n  p.xy *= rot(time*2.);\n  //p.yz *= rot(gt*2.);\n  //p+=vec3(.2,.2,2);\n  float rad = fract(gt);\n  float root_id = floor(gt);\n  float S = 1001.;\n  \n  float ft=1.;\n  \n  for (float i=0.;i<=2.;i+=1.){\n    float id = root_id + i;\n    float r=rad+i;\n    p.xz *= rot(r*(.35+.2*sin(gt)));\n    p.xy *= rot(r*.1);\n    p.xy *= rot(r*.05);\n\n    S = min(S, boxle(p, r, 1.+.07*r*r*r));\n  }\n \n\n\n  return S+max(0.,-S)*.2;\n}\n\n\nfloat ray(vec3 p, vec3 dir) {\n  float d=0.;\n  for(int i=0;i<50;i++){\n    float c=S(p+d*dir);\n    d+=c;\n    if (c<.1) return d;\n    if (MISS(d)) return d;\n  }\n  \n  return d;\n}\n\nvec3 normal(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(1e-3);\n  return normalize(S(p)-vec3(S(k[0]), S(k[1]),S(k[2])));\n}\n\nvec3 sat(vec3 p, float amt) {\n    vec3 mid = vec3((p.x+p.y+p.z)/3.);\n    vec3 side = p - mid;\n    \n    return mix(mid, side,amt);\n\n}\n\nfloat light(vec3 o, vec3 dir, float dist) {\n  vec3 hit = o+dir*dist;\n  vec3 n = normal(hit);\n  \n  float diff = dot(dir,-n);\n  \n  return diff;\n}\nvec3 HUE = vec3(0);\n\n\nfloat pxsel(float x, vec2 p) {\n  x *= 3.5;\n  x-=.1;\n  \n  if (x<1.) { HUE=vec3(0, p); return px(T1,p); }\n  if (x<2.) { HUE=vec3(p,0); return px(T2,p); }\n  if (x<3.) { HUE=vec3(p.y,0,p.x);return px(T3,p); }\n  return px(T4,p);\n}\n\n#define tri(x) (2.*abs(.5-fract(x)))\n#define gmix(A,B,Q) (A * pow(B/A, Q))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n     uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 C;\n    \n    float t = time;\n    t = tri(.1*t+.3);\n    //t -= nsin(t)*pmod(t, 1./200.);\n    \n    float RES=mix(6., 88., t*t);\n    \n    \n    vec2 px_aln = uv;\n    px_aln *= RES;\n    px_aln = floor(px_aln);\n    px_aln /= RES;\n    \n    vec3 o = vec3(0,0,-5);\n    vec3 dir = normalize(vec3(px_aln,1));\n    \n    float dist = ray(o,dir);\n    float l = light(o,dir,dist);\n\n    if (MISS(dist)) {\n      C=pxsel(nsin(time), (uv+t)*RES)+vec3(1);\n      \n      C/=(RES*.2);\n    }\n    else {\n      float pix = pxsel(light(o,dir,dist),RES*(uv-px_aln));\n      C = vec3(rot(time)*uv+1.,0)*pix;\n      C.g *= .5;\n      C -= HUE;\n\n    }\n    \n    C = C.zxy;\n    //C = sqrt(C);\n    \n    //C = sqrt(C);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(C),1.0);\n}","name":"Image","description":"","type":"image"}]}