{"ver":"0.1","info":{"id":"cd3cDN","date":"1695051475","viewed":96,"name":"SDF First attempts","username":"tralf_strues","description":"SDF trials","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_IDX_RING 0.0\n#define MAT_IDX_CORE 1.0\n\nmat3 RotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 RotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 RotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct Point\n{\n    float material;\n    float sdf;\n};\n\nstruct Material\n{\n    vec3 diffuse;\n    vec3 emission;\n    int diffuse_tex_idx;\n};\n\nPoint SDF_Scene(vec3 pos);\n\nfloat NormP(vec2 vec, float p)\n{\n    return pow(pow(abs(vec.x), p) + pow(abs(vec.y), p), 1.0 / p);\n}\n\nfloat NormP(vec3 vec, float p)\n{\n    return pow(pow(abs(vec.x), p) + pow(abs(vec.y), p) + pow(abs(vec.z), p), 1.0 / p);\n}\n\nfloat Intersection(float sd1, float sd2)\n{\n    return max(sd1, sd2);\n}\n\nfloat Union(float sd1, float sd2)\n{\n    return min(sd1, sd2);\n}\n\nfloat Subtraction(float sd1, float sd2)\n{\n    return max(-sd1, sd2);\n}\n\nPoint SmoothIntersection(Point point1, Point point2, float k) {\n    \n    float h = clamp(0.5 - 0.5*(point2.sdf - point1.sdf)/k, 0.0, 1.0);\n    return Point(mix(point2.material, point1.material, h),\n                 mix(point2.sdf, point1.sdf, h) + k*h*(1.0 - h));\n}\n\nPoint SmoothUnion(Point point1, Point point2, float k) {\n    \n    float h = clamp(0.5 + 0.5*(point2.sdf - point1.sdf)/k, 0.0, 1.0);\n    return Point(mix(point2.material, point1.material, h),\n                 mix(point2.sdf, point1.sdf, h) - k*h*(1.0 - h));\n}\n\nPoint SmoothSubtraction(Point point1, Point point2, float k) {\n    \n    float h = clamp(0.5 - 0.5*(point2.sdf + point1.sdf)/k, 0.0, 1.0);\n    return Point(mix(point2.material, point1.material, h),\n                 mix(point2.sdf, -point1.sdf, h) + k*h*(1.0 - h));\n}\n\n\nvec3 Repeat(vec3 pos, float spacing)\n{\n    return pos - spacing * round(pos / spacing);\n}\n\nvec3 Twist(vec3 pos, float k)\n{\n    float c = cos(k*pos.y);\n    float s = sin(k*pos.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*pos.xz,pos.y);\n    return q;\n}\n\nfloat SDF_Box(vec3 pos, vec3 size, float r)\n{\n    vec3 pt = abs(pos) - size;\n\n    return length(max(pt, 0.0)) + min(max(pt.x, max(pt.y, pt.z)), 0.0) - r;\n}\n\nfloat SDF_Plane(vec3 pos, vec4 plane)\n{\n    return dot(pos, plane.xyz) + plane.w;\n}\n\nfloat SDF_Torus(vec3 pos, vec3 center, float R, float r, float p)\n{\n    float x = NormP((pos - center).xz, p) - R;\n    float y = (pos - center).y;\n    \n    return NormP(vec2(x, y), p) - r;\n}\n\nfloat SDF_CutSphere(vec3 pos, float r, float h)\n{\n  float w = sqrt(r*r-h*h);\n\n  vec2 q = vec2(length(pos.xz), pos.y);\n  float s = max((h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y);\n  return (s < 0.0) ? length(q)-r :\n         (q.x < w) ? h - q.y     :\n                     length(q-vec2(w,h));\n}\n\nPoint Displacement(Point point, vec3 pos, vec3 scale, float modifier)\n{\n    point.sdf += sin(scale.x * pos.x) * sin(scale.y * pos.y) * sin(scale.z * pos.z) * modifier;\n    return point;\n}\n\nPoint SDF_SceneInstance(vec3 pos)\n{\n    Point torus1 = Point(MAT_IDX_RING,\n                         SDF_Torus(inverse(RotateX(iTime)) * Twist(inverse(RotateX(3.14 / 1.0)) * pos, 0.1), vec3(0.0, 0.0, 0.0), 1.2, 0.2, 2.25));\n    Point torus2 = Point(MAT_IDX_RING,\n                         SDF_Torus(inverse(RotateZ(iTime)) * Twist(inverse(RotateX(3.14 / 1.0)) * pos, 0.1), vec3(0.0, 0.0, 0.0), 1.2, 0.2, 2.25));\n    torus1 = Displacement(torus1, pos, vec3(16.0), 0.02);\n    torus2 = Displacement(torus2, pos, vec3(16.0), 0.02);\n    \n    \n    Point box = Point(MAT_IDX_CORE,\n                      SDF_Box(inverse(RotateZ(5.0 * iTime)) * Twist(pos, 0.4), vec3(0.5), 0.1));\n    \n    Point cut_sphere1 = Point(MAT_IDX_CORE,\n                              SDF_CutSphere(vec3(0.0, 0.6, 0.0) + inverse(RotateX(3.1415)) * pos, 0.4, 0.2));\n    Point cut_sphere2 = Point(MAT_IDX_CORE,\n                              SDF_CutSphere(vec3(0.0, 0.6, 0.0) + pos, 0.4, 0.2));\n    \n    Point weird_chair = SmoothSubtraction(cut_sphere2, SmoothSubtraction(cut_sphere1, box, 0.7), 0.7);\n    weird_chair = Displacement(weird_chair, pos, vec3(8.0), 0.05);\n    \n    Point toruses = SmoothUnion(torus1, torus2, 0.05);\n    \n    return SmoothUnion(weird_chair, toruses, 0.3);\n    //return torus1;\n    //return box;\n    //return SmoothSubtraction(cut_sphere2, SmoothSubtraction(cut_sphere1, box, 0.7), 0.7);\n    //return SmoothSubtraction(cut_sphere2, box, 0.7);\n}\n\nPoint SDF_Scene(vec3 pos)\n{\n    return SDF_SceneInstance(Repeat(pos + vec3(0.0, 0.0, 2.0 * iTime), 8.0));\n}\n\n#define MAX_ITERS      120\n#define MAX_DIST       100.0\n#define STOP_THRESHOLD 0.001\nvec3 TraceRay(vec3 from, vec3 dir, out bool hit, out int steps, out Point point)\n{\n    vec3  pos        = from;\n    float total_dist = 0.0;\n    \n    hit = false;\n    \n    for (steps = 0; steps < MAX_ITERS; ++steps)\n    {\n        point = SDF_Scene(pos);\n        float dist = point.sdf;\n        \n        if (dist < STOP_THRESHOLD )\n        {\n            hit = true;\n            break;\n        }\n        \n        total_dist += dist;\n        \n        if ( total_dist > MAX_DIST )\n            break;\n            \n        pos += dist * dir;\n    }\n    \n    return pos;\n}\n\nvec3 CalcNormal(vec3 pos)\n{\n    const float EPS = 0.001;\n    float dx1 = SDF_Scene(pos + vec3(EPS, 0, 0)).sdf;\n    float dx2 = SDF_Scene(pos - vec3(EPS, 0, 0)).sdf;\n    float dy1 = SDF_Scene(pos + vec3(0, EPS, 0)).sdf;\n    float dy2 = SDF_Scene(pos - vec3(0, EPS, 0)).sdf;\n    float dz1 = SDF_Scene(pos + vec3(0, 0, EPS)).sdf;\n    float dz2 = SDF_Scene(pos - vec3(0, 0, EPS)).sdf;\n    \n    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));\n}\n\nfloat FogFactor(float depth)\n{\n    const float density = 7.0; \n    return clamp(1.0 - exp(-(depth * density) * (depth * density)), 0.0, 1.0);\n}\n\nvec3 FilmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\nvec4 SampleChannel(int channel, vec2 uv)\n{\n    if (channel == 0) {\n        return texture(iChannel0, uv);\n    } else if (channel == 1) {\n        return texture(iChannel1, uv);\n    } else if (channel == 2) {\n        return texture(iChannel2, uv);\n    } else if (channel == 3) {\n        //return texture(iChannel3, uv);\n    }\n    \n    return vec4(0.0);\n}\n\nvec3 GetTriplanarWeights(vec3 n, vec3 power)\n{\n    vec3 w = abs(n);\n    w = pow(w, power);\n\n    return w / (w.x + w.y + w.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Material materials[2] = Material[](\n        Material(vec3(0.0), vec3(0.0), 1),\n        Material(vec3(0.0), 0.75 * vec3(0.0, 1.0, 4.0), 0)\n    );\n\n    const vec3 eye = vec3(0.0, 2.5, 5.4);\n    \n    vec3 mouse = vec3(iMouse.xy / iResolution.xy - 0.5, iMouse.z - 0.5);\n    vec2 scale = 9.0 * iResolution.xy / max(iResolution.x, iResolution.y);\n    vec2 uv    = scale * (fragCoord / iResolution.xy - 0.5);\n    \n    vec3 dir = normalize(vec3(uv, 0.0) - eye);\n    dir = RotateY(0.25 * mouse.x) * RotateX(0.25 * mouse.y) * dir;\n\n    bool hit;\n    int  steps;\n    vec3 from = eye;\n    vec3 light = eye;\n    Point point;\n    vec3 pos = TraceRay(from, dir, hit, steps, point);\n    \n    const float light_range = 10.0;\n    const vec3 light_color = vec3(1.0, 1.0, 0.5);\n    const float light_intensity = 0.5;\n    \n    vec3 color;\n    if (hit) {\n        vec3 normal = CalcNormal(pos);\n        \n        vec3 to_light = normalize(light - pos);\n        float diffuse = max(0.0, dot(to_light, normal));\n        \n        vec3 to_eye = normalize(eye - pos);\n        vec3 h = normalize(to_light + to_eye);\n        float specular = pow(max(dot(h, normal), 0.0), 20.0);\n        \n        float dist = length(light - pos);\n        float attenuation = 1.0 / (1.0 + (dist * dist) / (light_range * light_range));\n        \n        vec3 light_radiance = light_color * light_intensity * attenuation;\n        \n        Material material;\n        if (abs(round(point.material) - point.material) < 0.001) {\n            material = materials[int(round(point.material))];\n        } else {\n            Material m1 = materials[int(floor(point.material))];\n            Material m2 = materials[int(ceil(point.material))];\n        \n            float f = fract(point.material);\n            \n            material.diffuse         = mix(m1.diffuse, m2.diffuse, f);\n            material.emission        = mix(m1.emission, m2.emission, f);\n            material.diffuse_tex_idx = materials[int(round(point.material))].diffuse_tex_idx;\n            \n            //if (m1.diffuse_tex_idx == -1 && m2.diffuse_tex_idx == -1) {\n            //    material.diffuse_tex_idx = -1;\n            //} else if (m1.diffuse_tex_idx != -1 && m2.diffuse_tex_idx == -1) {\n            //    material.diffuse_tex_idx = m1.diffuse_tex_idx;\n            //} else if (m1.diffuse_tex_idx == -1 && m2.diffuse_tex_idx != -1) {\n            //    material.diffuse_tex_idx = m2.diffuse_tex_idx;\n            //} else {\n            //    material.diffuse_tex_idx = round();\n            //}\n        }\n        \n        vec3 tws = GetTriplanarWeights(normal, vec3(2.0));\n        \n        vec3 q = from + dir * point.sdf;\n        vec3 cx = SampleChannel(material.diffuse_tex_idx, pos.yz*.5+.5).rgb;\n        vec3 cy = SampleChannel(material.diffuse_tex_idx, pos.zx*.5+.5).rgb;\n        vec3 cz = SampleChannel(material.diffuse_tex_idx, pos.xy*.5+.5).rgb;\n        vec3 tdiff = tws.x * cx + tws.y + cy + tws.z * cz;\n        \n        //vec3 mat_diffuse = tdiff;\n        vec3 mat_diffuse = material.diffuse + tdiff;\n        \n        //color = mat_diffuse * diffuse;\n        //color = material.emission * tdiff;\n        //color = material.emission + mat_diffuse * light_radiance * diffuse;\n        color = material.emission + mat_diffuse * light_radiance * diffuse + light_radiance * specular;\n        color = mix(color, texture(iChannel3, dir).rgb, FogFactor(length(pos - eye) / 150.0));\n    } else { \n        color = texture(iChannel3, dir).rgb;\n    }\n        \n    color = FilmicToneMapping(color);\n    \n    //color = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb;\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float random2d(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random2d(i);\n    float b = random2d(i + vec2(1.0, 0.0));\n    float c = random2d(i + vec2(0.0, 1.0));\n    float d = random2d(i + vec2(1.0, 1.0));\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st + vec2(0.1 * iTime, 0.5 * iTime);\n    \n    vec3 color = vec3(0.0);\n    \n    color = vec3(noise(16.0 * st));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    float power = 42.0 + 10.0 * sin(2.0 * iTime);\n\n    float alignment = pow(max(0.0, dot(rayDir, vec3(0.0, 0.0, -1.0))), power);\n    float intensity = 15.0 - 5.0 * sin(iTime);\n\n    vec3 color = mix(vec3(0.03), intensity * vec3(1.0, 0.2, 0.0), alignment); \n\n    // Output to cubemap\n    fragColor = vec4(color,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}