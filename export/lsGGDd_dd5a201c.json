{"ver":"0.1","info":{"id":"lsGGDd","date":"1457224940","viewed":14381,"name":"Load Custom Textures","username":"AntoineC","description":"A simple method to load custom image textures in Shadertoy. Read the instructions in the code. Let me know in the comments if it works on your system and browser...","likes":135,"published":1,"flags":0,"usePreview":0,"tags":["texture","earth","hack"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------------------\n//\t\"Load Custom Textures\" by Antoine Clappier - March 2015\n//\n//\tLicensed under a Creative Commons Attribution-ShareAlike 4.0 International License\n//\thttp://creativecommons.org/licenses/by-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n// Image credits:\n//  Nasa, http://visibleearth.nasa.gov/\n\n\n/*\n\nA simple method to load custom image textures in Shadertoy!\n-----------------------------------------------------------\n\nThe idea is to call directly the SetTexture function found in Shadertoy js code.\n\nHere is how to loads the three textures needed for this shader:\n - Open the javascript console of your browser:\n\t\t\t\t   Mac      /     Windows\n\tChrome:  cmd + opt + J  /  ctrl + shift J\n\tFirefox: cmd + opt + K  /  ctrl + shift K\n    IE:          na         /  F12   \n\n- Then copy the following lines in the console to load custom 2048x2048 textures:\n\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/88u2uo8dxdmgzxo/world2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/5rdhhnvnr5mochq/cloud2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://dl.dropboxusercontent.com/s/ojl5zoxgbdn5w5s/light2.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n- Or, the following lines for 1024x1024 textures:\n\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/0j4q7p4x0upj40q/world1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/26xr0l2ly68xgzh/cloud1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://dl.dropboxusercontent.com/s/b67udjdsw4gzf99/light1.jpg?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\n- hit return to execute and load the textures.\n\n\nUsing your own images:\n - The first argument of gShaderToy.SetTexture() is the iChannel index from 0 to 3\n - The second argument defines the url and additional parameters of the texture.\n - Your images must be hosted on a server (such as Dropbox) that allows direct link \n   from a different domain in javascript. Otherwise, you will get an error message:\n   \"'example.com has been blocked from loading by Cross-Origin Resource Sharing policy\"\n\n*/\n\n\n\n\n#define Pi 3.14159265359\n#define d2r(a) ((a)*180.0/Pi)\n#define RGB(r,g,b) pow(vec3(float(r), float(g), float(b))/255.0, vec3(2.22))\n\n#define R0 1.0000\t// Nomralized Earth radius (6360 km)\n#define R1 1.0094\t// Atmosphere radius (6420 km) \n\nvec3 Render(in vec2 uv)\n{\n    vec3 Color = vec3(0.0);\n    float t = 1.0*iTime;\n\n    // Sun:\n    vec3 L0 = vec3(cos(0.1*t), 0.0, sin(0.1*t));\n    float cs = cos(d2r(90.0 + 23.4)), sn = sin(d2r(90.0 + 23.4));\n    vec3 LightDir = vec3(cs*L0.x + sn*L0.y, cs*L0.y - sn*L0.x, L0.z);\n\n    vec2 SunC = -5.0*LightDir.xy/LightDir.z - uv;\n    float Halo = max(0.0, dot(LightDir, normalize(vec3(uv.x, uv.y, -5.0))));\n\tfloat SunRay = pow(texture(iChannel1, vec2(0.1*t, atan(SunC.x,SunC.y))).xyz, vec3(2.22)).x;\n    float Sun = 0.05*(1.0 + SunRay)*pow(Halo, 1000.0)*smoothstep(0.85, 1.3, length(SunC+uv));\n   \n    // Sphere hit:\n    float z = 1.0 - dot(uv, uv);\n    if(z < 0.0)\n    {\n        Sun += 1.5*pow(Halo, 10000.0);\n        return Sun*RGB(255,250,230);\n    }\n    \n    // Intersection:\n    vec3 Normal     = vec3(uv.x, uv.y, sqrt(z));\n    vec3 Reflection = reflect(vec3(0.0, 0.0, 1.0), Normal);\n\n\n    // Textures:\n\tfloat U = 1.0-atan(Normal.z, Normal.x) / (2.0*Pi);\n\tfloat V = 1.0-(atan(length(Normal.xz), Normal.y)) / Pi;\n \tvec3 Ground = pow(texture(iChannel0, vec2(U-t/80.0, V)).xyz, vec3(2.22));\n\tvec3 Cloud  = pow(texture(iChannel1, vec2(U-t/75.0, V)).xyz, vec3(2.22));\n\tvec3 Cloud2 = pow(texture(iChannel1, vec2(U-t/75.0+0.001, V)).xyz, vec3(2.22));\n\tvec3 KsMap  = pow(texture(iChannel1, vec2( -t/200.0, 0.8)).xyz, vec3(2.22));\n\tvec3 Night  = pow(texture(iChannel2, vec2(U-t/80.0, V)).xyz, vec3(2.22));\n\t\n    // Shading\n\tfloat Diffuse     = max(0.0, dot(Normal, LightDir));\n\tfloat Specular    = max(0.0, dot(-Reflection, LightDir));\n    float Scatter     = 4.0*pow((sqrt(R1 - dot(uv, uv)) - Normal.z) / sqrt(R1-R0), 1.35);\n    float Extinct     = pow(1.0 - Diffuse, 4.0);\n    float Sea         = smoothstep(1.0, 0.0, 100.0*length(Ground - RGB(2,5,20)));\n    float Shadow      = 1.0 - pow(Cloud2.x, 0.2);\n    \n    vec3 Light = mix(vec3(1.0), RGB(255, 150, 40), Extinct);\n \n    Color = Shadow*(Ground + 0.8*Sea*RGB(19,35,60));\n    Color = mix(Color, vec3(1.0), 2.0*Cloud);\n    Color *= Light*Diffuse;\n    Color += 2.0*Light*Diffuse*(0.3 + 0.7*KsMap.x)*mix(0.03, 0.4, Sea)*pow(Specular, (0.8 + 0.2*KsMap.x)*mix(9.0, 200.0, Sea));\n    Color += pow(max(0.0, dot(Normal, -LightDir)), 2.0)*Night*(1.0-pow(Cloud.x, 0.2));\n    Color *= mix(vec3(1.0), RGB(255-58,255-72,255-90), 1.0*Scatter);\n    Color += 4.0*Diffuse*(1.0 + Sea)*Scatter*RGB(58,72,90);\n\n    Color += Sun*RGB(255,250,230);\n    \n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 In )\n{\n\tvec2 uv = (2.0*In.xy - iResolution.xy) / iResolution.y;\n    vec3 Color = pow(Render(1.05*uv),  vec3(0.45));\n\tfragColor = vec4(Color, 1.0);\n}","name":"Image","description":"","type":"image"}]}