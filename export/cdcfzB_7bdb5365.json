{"ver":"0.1","info":{"id":"cdcfzB","date":"1697293506","viewed":88,"name":"Squares Intersection or distance","username":"kastorp","description":"squares must be with same size.\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["intersection","square","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Squares Intersection || distance \n//\n// Algorithm:\n// 0) if the distance between centers A and B is less than square size >> INTERSECTION, minimum segment is not applicable\n// 1) calculate the closest vertexes VA and VB  for each square, \n// 2) calculate the closeest points VAB and VBA  for each closest vertex \n// 3) if any of the closest vertexes is inside the other square >> INTERSECTION, otherwise NO INTERSECTION\n// 4) compare vertex distances\n//     - if almost equals and VA is far from  VAB  >> parallel case, minimum segment in the middle  of( VA,VAB) and (VB,VBA)  \n//     - if VA is closest >> minimum segment is from VA to VAB\n//     - otherwise  > minimum segment is from VB to VBA\n//--------------\n\n#define R iResolution.xy\n#define ROT(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//https://iquilezles.org/articles/distgradfunctions2d/\nfloat sdBox(vec2 p, float l){\n    \n    vec2 q = abs(p)-vec2(l);\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nvec3 sdgBox( in vec2 p,  float l )\n{\n    vec2 w = abs(p)-vec2(l);\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n//-------------------------\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    \n    vec2 uv = (I- R*.5)/R.y;\n\n    // SQUARE positions and rotations\n    float L =.1, EPS=L*.001;\n    \n    vec2  a =vec2(L,0)*ROT(-iTime*.7), \n          b = vec2(cos(iTime),sin(iTime))*vec2(5,2)*L*ROT(iTime*.1) ;\n    float ra= iTime*.3,\n          rb= iTime*1.2;\n  \n    //LOGIC:\n    mat2 rota=ROT(ra),rotb=ROT(rb);\n    vec2 va= a+ rota* sign((b-a)*rota)* vec2(L),\n         vb= b+ rotb*sign((a-b)*rotb)* vec2(L);\n    vec3  dva= sdgBox((va-b)*rotb,L),  \n          dvb= sdgBox((vb-a)*rota,L);\n    vec2 vab =va-rotb*dva.yz*dva.x,\n         vba =vb-rota*dvb.yz*dvb.x;\n          \n    bool intersect=  length(a-b)<L*2. || min(dva,dvb).x<0.;\n    float dc = dva.x - dvb.x;        \n\n    if(abs(dc)<EPS && length(vb-vab)>EPS){vb+=(vab-vb)*.5;va+=(vba-va)*.5;}\n    else if(dc<=0.) vb=vab;\n    else va=vba;\n       \n    if(length(a-b)<L*2.) {va=a;vb=b;} // special case when squares are almost overlapping\n    \n    //VISUALIZATION  \n    vec3 col = 0.5 + 0.1*cos(iTime+uv.xyx+vec3(0,2,4));  // background\n    if(sdBox((uv-a)*rota,L)<0.) col=intersect? vec3(.2,.8,.8):vec3(.1,.4,.4);\n    if(sdBox((uv-b)*rotb,L)<0.) col=intersect? vec3(.8,.2,.2):vec3(.4,.1,.1); \n    if(length(uv-va)<.01  ) col =vec3(1,1,0); \n    if(length(uv-vb)<.01 ) col =vec3(1,1,0); \n    if(sdSegment(uv,va,vb)<.005) col=vec3(0,.5,0);\n          \n    // Output to screen\n    O = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}