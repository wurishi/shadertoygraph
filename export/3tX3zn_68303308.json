{"ver":"0.1","info":{"id":"3tX3zn","date":"1555418660","viewed":1102,"name":"2d soft lights","username":"Jodie","description":"2d soft shadows","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["2d","shadow","lighting","penumbra","soft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 linearToSrgb(const vec3 x){\n    return sqrt((-2.8450663e-1*x+1.2580714)*x-2.4727747e-3);\n}\n\n\nconst float pi = radians(180.);\nconst float hpi = radians(90.);\n\nfloat mulSign(float x,float y){\n    return uintBitsToFloat(floatBitsToUint(x)^(floatBitsToUint(y)&0x80000000u));\n}\n\nfloat fast_acos(float x){\n    float u = 6.9905252e-2;\n    u = u * x + -3.3647389e-1;\n    u = u * x + 9.3061693e-1;\n    u = u * x + -3.1311627;\n    return sqrt(u * x + 2.4671144);\n}\n#define acos(x) fast_acos(x)\n#define asin(x) ( pi * .5 - acos(x) )\n#define saturate(x) clamp(x,0.,1.)\n\nstruct circle {\n    float distance;\n\tvec2 direction;\n\tfloat angularRadius;\n};\n\nfloat getLighting(const circle light, const circle occluder){\n    \n    bool behindOccluder = occluder.distance < light.distance;\n    \n    float offset = acos(saturate(dot(light.direction,occluder.direction)));\n\t\n    if(behindOccluder)\n\t\treturn light.angularRadius - max(occluder.angularRadius - offset,0.);\n    return light.angularRadius;\n}\n\nfloat dither(const vec2 fragCoord){\n\treturn (texture(iChannel0,fragCoord/8.)-.5).x/255.;\n}\n        \ncircle createCircle(vec2 position,const float radius,const vec2 fragCoord){\n\tcircle c;\n\n    position -= fragCoord;\n\tfloat distanceSquared = dot(position,position);\n\tfloat inverseDistance = inversesqrt(distanceSquared);\n    \n    c.distance = inverseDistance * distanceSquared;\n\tc.direction = position * inverseDistance;\n    c.angularRadius = asin(radius*inverseDistance);\n    \n    bool inside = c.distance < radius;\n    \n    if(inside) c.angularRadius = pi;\n\n    return c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    circle l0 = createCircle(\n        vec2((200.+cos(iTime)*100.),40.),\n        25.,\n        fragCoord\n    );\n    \n    circle l1 = createCircle(\n        vec2(30,100.+cos(iTime)*100.),\n        10.,\n        fragCoord\n    );\n    \n    circle l2 = createCircle(\n        iMouse.xy,\n        30.,\n        fragCoord\n    );\n    \n    circle o0 = createCircle(\n        vec2(150,160),\n        15.,\n        fragCoord\n    );\n    \n    circle o1 = createCircle(\n        vec2(350,130),\n    \t40.,\n        fragCoord\n    );\n    \n    fragColor.rgb = vec3(2,0,0) * min(getLighting(l0,o0),getLighting(l0,o1))+ \n    \t\t\t\tvec3(0,2,0) * min(getLighting(l1,o0),getLighting(l1,o1))+\n    \t\t\t\tvec3(0,0,2) * min(getLighting(l2,o0),getLighting(l2,o1));\n    \n    fragColor.rgb /= pi;\n\n    fragColor.rgb = linearToSrgb(fragColor.rgb) + dither(fragCoord);\n    \n    //fragColor.rgb=vec3(acos((fragCoord.x/iResolution.x)*2.-1.))/pi;\n}","name":"Image","description":"","type":"image"}]}