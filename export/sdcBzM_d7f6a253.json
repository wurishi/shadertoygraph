{"ver":"0.1","info":{"id":"sdcBzM","date":"1656212639","viewed":160,"name":"Worm Noise","username":"MisterSirCode","description":"Worm-like noise pattern produced by biquadratic interpolation","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["procedural","noise","texture","worm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 biqgrad(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res),\n         c = (q*(q - 1.0) + 0.5) / res,\n         w0 = uv - c,\n         w1 = uv + c,\n         cc = 0.5 / res,\n         ww0 = uv - cc,\n         ww1 = uv + cc;\n    vec3 nx0 = texture(channel, vec2(ww1.x, w0.y)).rgb - texture(channel, vec2(ww0.x, w0.y)).rgb,\n         nx1 = texture(channel, vec2(ww1.x, w1.y)).rgb - texture(channel, vec2(ww0.x, w1.y)).rgb,\n         ny0 = texture(channel, vec2(w0.x, ww1.y)).rgb - texture(channel, vec2(w0.x, ww0.y)).rgb,\n         ny1 = texture(channel, vec2(w1.x, ww1.y)).rgb - texture(channel, vec2(w1.x, ww0.y)).rgb;\n    vec2 gdr = vec2(nx0.r + nx1.r, ny0.r + ny1.r) / 2.0,\n         gdg = vec2(nx0.g + nx1.g, ny0.g + ny1.g) / 2.0,\n         gdb = vec2(nx0.b + nx1.b, ny0.b + ny1.b) / 2.0;\n\treturn vec3(max(abs(gdr.x), abs(gdr.y)),\n                max(abs(gdg.x), abs(gdg.y)),\n                max(abs(gdb.x), abs(gdb.y)));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec3 ej = biqgrad(iChannel0, res, fragCoord / res / 4.0);\n    fragColor = vec4(ej, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash3(i + vec2(0.0,0.0)), \n                   hash3(i + vec2(1.0,0.0)), u.x),\n               mix(hash3(i + vec2(0.0,1.0)), \n                   hash3(i + vec2(1.0,1.0)), u.x), u.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Dividing by iResolution.x will scale the noise to 0-1.\n    // You want it to match the screen resolution or else this whole thing doesnt work.\n    vec2 uv = (2.0 * fragCoord - iResolution.xy);\n    vec3 ns = noise(uv);\n    fragColor = vec4(ns, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}