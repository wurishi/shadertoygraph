{"ver":"0.1","info":{"id":"tltGDM","date":"1576583111","viewed":742,"name":"Unity Procedural Skybox","username":"PrzemyslawZaworski","description":" ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","scattering","skybox","rayleigh","mie","unity","atmospheric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nlicence.txt from Unity built-in shader source:\n\nCopyright (c) 2016 Unity Technologies\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*\nOriginal code was translated and adapted for ShaderToy by P.Z.\n*/\n\nconst vec4 _LightColor0 = vec4(0.9,0.9,0.9,1.0);\nconst  float _Exposure = 1.0;\nconst vec3 _GroundColor = vec3(.369, .349, .341);\nconst float _SunSize = 0.04;\nconst float _SunSizeConvergence = 5.0;\nconst vec3 _SkyTint = vec3(.5, .5, .5);\nconst float _AtmosphereThickness = 1.0; \n#define OUTER_RADIUS 1.025 \n#define kRAYLEIGH (mix(0.0, 0.0025, pow(_AtmosphereThickness,2.5))) \n#define kMIE 0.0010 \n#define kSUN_BRIGHTNESS 20.0 \n#define kMAX_SCATTER 50.0 \n#define MIE_G (-0.990) \n#define MIE_G2 0.9801 \n#define SKY_GROUND_THRESHOLD 0.02 \n#define SKYBOX_COLOR_IN_TARGET_COLOR_SPACE 0 \nconst vec3 ScatteringWavelength = vec3(.65, .57, .475);\nconst vec3 ScatteringWavelengthRange = vec3(.15, .15, .15);    \nconst float kOuterRadius = OUTER_RADIUS; \nconst float kOuterRadius2 = OUTER_RADIUS*OUTER_RADIUS;\nconst float kInnerRadius = 1.0;\nconst float kInnerRadius2 = 1.0;\nconst float kCameraHeight = 0.0001;\nconst float kHDSundiskIntensityFactor = 15.0;\nconst float kSunScale = 400.0 * kSUN_BRIGHTNESS;\nconst float kKmESun = kMIE * kSUN_BRIGHTNESS;\nconst float kKm4PI = kMIE * 4.0 * 3.14159265;\nconst float kScale = 1.0 / (OUTER_RADIUS - 1.0);\nconst float kScaleDepth = 0.25;\nconst float kScaleOverScaleDepth = (1.0 / (OUTER_RADIUS - 1.0)) / 0.25;\nconst float kSamples = 2.0;\n\nfloat Scale(float inCos)\n{\n\tfloat x = 1.0 - inCos;\n\treturn 0.25 * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nfloat SunAttenuation(vec3 lightPos, vec3 ray)\n{\n\tfloat EyeCos = pow(clamp(dot(lightPos, ray),0.0,1.0), _SunSizeConvergence);\t\t\n\tfloat temp = pow(1.0 + MIE_G2 - 2.0 * MIE_G * (-EyeCos), pow(_SunSize,0.65) * 10.);\n\treturn (1.5 * ((1.0 - MIE_G2) / (2.0 + MIE_G2)) * (1.0 + EyeCos * EyeCos) / max(temp,1.0e-4));\t\n}\n\nvec4 ProceduralSkybox(vec3 ro, vec3 rd)\n{\n    vec3 _WorldSpaceLightPos0 = vec3(2,sin(iTime*0.5)*10.0+1.0,20);\n    vec3 kSkyTintInGammaSpace = _SkyTint;\n    vec3 kScatteringWavelength = mix(ScatteringWavelength-ScatteringWavelengthRange,ScatteringWavelength+ScatteringWavelengthRange,vec3(1,1,1) - kSkyTintInGammaSpace);\n    vec3 kInvWavelength = 1.0 / (pow(kScatteringWavelength, vec3(4.0)));\n    float kKrESun = kRAYLEIGH * kSUN_BRIGHTNESS;\n    float kKr4PI = kRAYLEIGH * 4.0 * 3.14159265;\n    vec3 cameraPos = vec3(0,kInnerRadius + kCameraHeight,0);\n    vec3 eyeRay = rd;\n    float far = 0.0;\n    vec3 cIn, cOut;\n    if(eyeRay.y >= 0.0)\n    {\n        far = sqrt(kOuterRadius2 + kInnerRadius2 * eyeRay.y * eyeRay.y - kInnerRadius2) - kInnerRadius * eyeRay.y;\n        vec3 pos = cameraPos + far * eyeRay;\n        float height = kInnerRadius + kCameraHeight;\n        float depth = exp(kScaleOverScaleDepth * (-kCameraHeight));\n        float startAngle = dot(eyeRay, cameraPos) / height;\n        float startOffset = depth*Scale(startAngle);\n        float sampleLength = far / kSamples;\n        float scaledLength = sampleLength * kScale;\n        vec3 sampleRay = eyeRay * sampleLength;\n        vec3 samplePoint = cameraPos + sampleRay * 0.5;\n        vec3 frontColor = vec3(0.0, 0.0, 0.0);\n        for (int i=0; i<2; i++)\n        {\n            float height = length(samplePoint);\n            float depth = exp(kScaleOverScaleDepth * (kInnerRadius - height));\n            float lightAngle = dot(normalize(_WorldSpaceLightPos0.xyz), samplePoint) / height;\n            float cameraAngle = dot(eyeRay, samplePoint) / height;\n            float scatter = (startOffset + depth*(Scale(lightAngle) - Scale(cameraAngle)));\n            vec3 attenuate = exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));\n            frontColor += attenuate * (depth * scaledLength);\n            samplePoint += sampleRay;\n        }\n        cIn = frontColor * (kInvWavelength * kKrESun);\n        cOut = frontColor * kKmESun;\n    }\n    else\n    {\n        far = (-kCameraHeight) / (min(-0.001, eyeRay.y));\n        vec3 pos = cameraPos + far * eyeRay;\n        float cameraScale = Scale(dot(-eyeRay, pos));\n        float lightScale = Scale(dot(normalize(_WorldSpaceLightPos0.xyz), pos));\n        float sampleLength = far / kSamples;\n        float scaledLength = sampleLength * kScale;\n        vec3 sampleRay = eyeRay * sampleLength;\n        vec3 samplePoint = cameraPos + sampleRay * 0.5;\n        vec3 frontColor = vec3(0.0, 0.0, 0.0);            \n        float height = length(samplePoint);\n        float d = exp(kScaleOverScaleDepth * (kInnerRadius - height));\n        float scatter = d*(lightScale + cameraScale) - exp((-kCameraHeight) * (1.0/kScaleDepth))*cameraScale;\n        vec3 attenuate = exp(-clamp(scatter, 0.0, kMAX_SCATTER) * (kInvWavelength * kKr4PI + kKm4PI));\n        frontColor += attenuate * (d * scaledLength);\n        samplePoint += sampleRay;\n        cIn = frontColor * (kInvWavelength * kKrESun + kKmESun);\n        cOut = clamp(attenuate, 0.0, 1.0);\n    }\n    vec3 groundColor = _Exposure * (cIn + _GroundColor*_GroundColor * cOut);\n    vec3 skyColor = _Exposure * (cIn * (0.75 + 0.75 * dot(normalize(_WorldSpaceLightPos0.xyz), -eyeRay) * dot(normalize(_WorldSpaceLightPos0.xyz), -eyeRay))); \n    float lightColorIntensity = clamp(length(_LightColor0.xyz), 0.25, 1.0);\n    vec3 sunColor = kHDSundiskIntensityFactor * clamp(cOut,0.0,1.0) * _LightColor0.xyz / lightColorIntensity;\t    \n    vec3 ray = -rd;\n    float y = ray.y / SKY_GROUND_THRESHOLD;\n    vec3 color = mix(skyColor, groundColor, clamp(y,0.0,1.0));\n    if(y < 0.0) color += sunColor * SunAttenuation(normalize(_WorldSpaceLightPos0.xyz), -ray);\n    return vec4(sqrt(color),1.0);      \n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sphere( vec3 p, vec3 c,float s )\n{\n\treturn length(p-c)-s;\n}\n\nfloat box (vec3 p, vec3 c, vec3 s)\n{\n\tfloat x = max(p.x - c.x - s.x, c.x - p.x - s.x);\n\tfloat y = max(p.y - c.y - s.y, c.y - p.y - s.y);   \n\tfloat z = max(p.z - c.z - s.z, c.z - p.z - s.z);\n\treturn max(max(x,y),z);\n}\n\nfloat map (vec3 p)\n{\n\tfloat a = box(p,vec3(0.0),vec3(1000));\n\tfloat b = sphere(p,vec3(0.0),300.0);\n\treturn max(-b,a);\n}\n\nvec4 raymarch (vec3 ro, vec3 rd)\n{\n\tfor (int i=0;i<16;i++)\n\t{\n\t\tfloat t = map(ro);\n\t\tif (t<0.001) return ProceduralSkybox(ro,rd);     \n\t\tro+=t*rd;\n\t}\n\treturn vec4(0,0,0,1);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3 (0.,0.,0.);\n\tvec3 rd = normalize(vec3(uv,2.0));\n\tfragColor = raymarch(ro,rd);\n}","name":"Image","description":"","type":"image"}]}