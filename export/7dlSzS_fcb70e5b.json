{"ver":"0.1","info":{"id":"7dlSzS","date":"1618863858","viewed":77,"name":"2 task Алиса Боос","username":"ghostwheat","description":"куб с водой","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["alisa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 CAMERA_Position = vec3(0.5, 2.0, -9);\nconst float INF = 1e10;\nconst int LIGHT = 3;\n\nconst int EMISSION = 0;\nconst int DIFFUSE = 1;\nconst int REFLECTION = 2;\nconst int REFRACTION = 3;\nconst float WATER   = 0.6; \nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\n\nstruct Plane\n{\n    int coord;\n    float r;\n    vec3 center; \n};\n\nfloat tracePlane(vec3 Position, vec3 dir, out vec3 Normal, Plane p) \n{\n     \n    float hit= (p.center[p.coord] - Position[p.coord]) / dir[p.coord];\n    if(hit <= 0.0) {\n        return INF;\n    }\n    \n    int x = (p.coord != 0) ? 0 : 1;\n    int z = (p.coord != 2) ? 2 : 1;\n     \n    vec3 worldPosition = hit* dir + Position;\n    if ((abs(worldPosition[x]) > p.r) || (abs(worldPosition[z]) > p.r) )\n    {\n        return INF;\n    }\n    Normal = vec3(0.0);\n    Normal[p.coord] = 1.0 * float((p.center[p.coord] > 0.0) ? -1 : 1);\n    return hit;\n}\n\nstruct Cube\n{\n    vec3 center;\n    float size;\n    Plane side[6];\n};\n\nCube InitCube(vec3 center, float size)\n{\n    Plane side[6];\n    for (int i = 0; i < 6; i++)\n    {\n        int signx = ( i % 2 == 0 ) ? 1 : -1;\n        vec3 offset = vec3(0);\n        offset[i/2] = size * float(signx);\n        side[i] = Plane(i/2, size, center + offset);\n    }\n    return Cube(center, size, side);\n}\n\nfloat traceCube(vec3 Position, vec3 dir, out vec3 Normal, Cube cube)\n{\n    \n    float hit= INF;\n    for (int i = 0; i < 6; i++)\n    {\n        vec3 floor_Normal;\n        float floorT = tracePlane(Position, dir, floor_Normal, cube.side[i]);  //floor\n        if (floorT < hit) \n        {\n            hit= floorT;\n            Normal = floor_Normal;\n        }\n    }\n    \n    vec3 a = cube.center - Position;\n    if ((abs(a.x) < cube.size)&&(abs(a.y) < cube.size)&&(abs(a.z) < cube.size))\n    {\n        Normal = Normal * (-1.0);\n    }\n    return hit;\n}\n\n\nfloat traceSphere(vec3 Position, vec3 dir, float r, out vec3 Normal, float flag) {\n    float dis = flag * 0.2 * (sin(16.* (Position + dir).x)*\n                              sin(16.* (Position + dir).y)*\n                              sin(16.* (Position + dir).z));\n    float a = dot(dir, dir);\n    float b = dot(Position, dir);\n    float c = dot(Position, Position) - (r + dis) * (r + dis);\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float hit= -b - sqrt(D);\n    if(hit > 0.0) {\n        Normal = normalize(Position + hit* dir);\n        return hit;\n    }\n    hit= -b + sqrt(D);\n    if(hit < 0.0) {\n        return INF;\n    }\n    Normal = normalize(Position + hit* dir);\n    return hit;\n}\n\nfloat traceCylinder(vec3 Position, vec3 dir, out vec3 Normal) {\n    float hit= (-1.0 - 1e-4 - Position.y) / dir.y;\n    if(hit <= 0.0) {\n        return INF;\n    }\n    vec3 worldPosition = hit* dir + Position;\n    if (dot(worldPosition.xz, worldPosition.xz) < 0.5) {\n        Normal = vec3(0, 1, 0);\n        return hit;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(Position.xz, dir.xz);\n    float c = dot(Position.xz, Position.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    hit= (-b - sqrt(D)) / a;\n    if(hit > 0.0) {\n        worldPosition = hit* dir + Position;\n        if (worldPosition.y <= -1.0 - 1e-4) {\n            Normal = normalize(vec3(worldPosition.x, 0, worldPosition.z));\n            return hit;\n        }\n    }\n    hit= (-b + sqrt(D)) / a;\n    if(hit < 0.0) {\n        return INF;\n    }\n    worldPosition = hit* dir + Position;\n    if (worldPosition.y <= -1.0 - 1e-4) {\n        Normal = normalize(vec3(worldPosition.x, 0, worldPosition.z));\n        return hit;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 Position, vec3 target, Cube cube) {\n    vec3 dir = target - Position;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 cube_Normal;\n    float cubeT = traceCube(Position, dir, cube_Normal, cube);\n    if ((cubeT < dist))\n        return true;\n    vec3 cyl_Normal;\n    float cylT = traceCylinder(Position, dir, cyl_Normal);\n    return (cylT < dist);\n}\n\nstruct Light\n{\n    vec3 Position;\n    float radius;\n    vec3 color;\n    float brightness;\n};\n\nvec3 compLight(vec3 Position, vec3 color, vec3 Normal, Light l[LIGHT], Cube cube) \n{\n    \n    vec3 all = vec3(0, 0, 0);\n    \n    for (int i = 0; i < LIGHT; i++)\n    {\n        vec3 toLight = l[i].Position - Position;\n        float distSq = dot(toLight, toLight);\n        float att =  isOccluded(Position, l[i].Position, cube) ? 0.0 : l[i].brightness / distSq; \n        all = all + max(0.0, dot(Normal, normalize(toLight))) * att * l[i].color;\n    }\n    \n    return color * (all  + texture(iChannel1, Normal).rgb * 0.3);\n    \n}\n\nvec3 refraction(vec3 v, vec3 Normal, float n1, float n2) {\n    if (dot(v, Normal) < 0.0) {\n        Normal = -Normal;\n    }\n    float cosA = dot(v, Normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * Normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB >= 1.0)\n    {\n        return vec3(1000.0);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * Normal;\n}\n\n\nfloat pow2(float x) {\n    return x * x;\n}\n\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\nvec3 l_add (vec2 p) \n{\n\tfloat color1 = 4.0 - (2.0 * length(2.5 * p));\n\tvec3 coord = vec3(atan(p.x, p.y) / 6.2832 + 0.5, length(p) * 0.4, 0.5);\n\tfor(int i = 1; i <= 3; i++)\n\t{\n\t\tfloat power = pow(2.0, float(i));\n\t\tcolor1 += 0.5*(1.5 / power) * 0.1;\n\t}\n\tcolor1 *= 0.5;\n\treturn vec3( color1, pow(max(0.0, color1), 2.0)*0.4, pow(max(0.0, color1), 3.0) * 0.15);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 randV = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec3 front = normalize(-CAMERA_Position);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    vec2 uv = (fragCoord - iResolution.xy * 0.5  + (randV.xy - 0.5) * 1.0) / iResolution.x;\n    vec3 viewVec = normalize(front + up * uv.y + right * uv.x);\n    \n    Plane floor = Plane(1, 10.0, vec3(0, -1.5, 0));\n    Cube cube = InitCube(vec3(0, 0, 0), 1.0);   \n    Light l[LIGHT];\n    l[0] = Light(vec3(3, 2, 2), 0.75, vec3(1.0, 1.0, 0.0), 15.0f);\n    l[1] = Light(vec3(-2, 1, 5), 0.5, vec3(1.0, 0.0, 0.5), 20.0f);\n    l[2] = Light(vec3(-0.5, -0.5, -0.5) + randV * 1.1, 0.45, vec3(1.0, 1.0, 1.0), 2.0f);\n    \n    vec3 curPosition = CAMERA_Position;\n    vec3 cur_dir = viewVec;\n    vec3 colorMult = vec3(1, 1, 1);\n    float n1 = AIR_N;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n\n    vec4 colBuf = vec4(0.0);\n\n    float n2 = GLASS_N;\n    float mult = 1.0;\n\n    for(int i; i < 10; i++)\n    {\n        float hit= INF;\n        int matType;\n        vec3 color;\n        vec3 Normal;\n        \n        vec3 floor_Normal;\n        float floorT = tracePlane(curPosition, cur_dir, floor_Normal, floor);  //floor\n        if (floorT < hit) \n        {\n            hit= floorT;\n            matType = DIFFUSE;\n            vec3 worldPosition = hit* cur_dir + curPosition;\n            color = texture(iChannel0, worldPosition.xz * 0.1).rgb;\n            Normal = floor_Normal;\n        }\n        \n        for (int i = 0; i < LIGHT; i++)\n        {\n            vec3 l_Normal;\n            float lT = traceSphere(curPosition - l[i].Position, cur_dir, l[i].radius, l_Normal, 0.0);\n            if (lT < hit) \n            {\n                hit= lT;\n                if (i == 3)\n                    matType = EMISSION;\n                else\n                    matType = EMISSION;\n                color = l[i].color;\n                Normal = l_Normal;\n            }\n        }\n               \n        \n        vec3 cube_Normal;\n        float cubeT = traceCube(curPosition, cur_dir, cube_Normal, cube);\n        if (cubeT < hit) \n        {\n            hit= cubeT;\n            Normal = cube_Normal;\n            if (randV.x >= GLASS_R)\n            {\n                colorMult = vec3(0.5, 0.8, 1);\n                matType = REFRACTION;\n                vec2 p = (fragCoord.xy / iResolution.xy) - 0.5;\n                p.x *= iResolution.x / iResolution.y;\n                vec3 fo = l_add(p);\n                mult = 0.5;\n                colBuf += vec4(mix(vec3(0.01, 0.01, 0.2), fo * vec3(0.1, 0.5, 0.7), 0.7), 0.8);\n            }\n            else\n            {\n                matType = REFLECTION;\n            }\n        }\n        \n        vec3 cyl_Normal;\n        float cylT = traceCylinder(curPosition, cur_dir, cyl_Normal);\n        if (cylT < hit) {\n            hit= cylT;\n            matType = DIFFUSE;\n            vec3 worldPosition = hit* cur_dir + curPosition;\n            color = texture(iChannel0, worldPosition.xz * worldPosition.y).rgb;\n            Normal = cyl_Normal;\n            \n        }\n        \n        if (randV.x < WATER)\n        {\n            vec3 sph_Normal;\n            float sph2T = traceSphere(curPosition, cur_dir, 0.5, sph_Normal, 1.0);\n            if (sph2T < hit) \n            {\n                hit= sph2T;\n                Normal = sph_Normal;\n                vec3 worldPosition = hit* cur_dir + curPosition;\n                color = texture(iChannel2, uv).rgb + vec3(0, 0.3, 0.3);\n\n                if (randV.x < 0.5) \n                {\n                    matType = EMISSION;\n                } \n                else \n                {\n                    colorMult *= vec3(1, 0.5, 0.5);\n                    matType = REFRACTION;\n                    mult = 0.9;\n                }\n            }\n        }\n        \n        if(hit != INF)         \n        {\n            vec3 worldPosition = hit* cur_dir + curPosition;\n            colBuf += vec4(vec3(texture(iChannel0, worldPosition.xz).rgb * 0.1) * colorMult * mult, 0.0);\n            if (matType == EMISSION) \n            {\n                colBuf += vec4(color * colorMult * mult,  0.0);\n                break;\n            }\n            if (matType == DIFFUSE) \n            {\n                colBuf = vec4(compLight(worldPosition, color, Normal, l, cube) * colorMult, 1.0);\n                break;\n            }\n            if (matType == REFLECTION)\n            {\n                cur_dir = reflect(cur_dir, Normal);\n                curPosition = worldPosition + cur_dir * 1e-4;\n            }\n            if (matType == REFRACTION)\n            {\n                vec3 Dir = refraction(cur_dir, Normal, n1, n2);\n                if (Dir.x == 1000.0)\n                {\n                    cur_dir = reflect(cur_dir, Normal);\n                    curPosition = worldPosition + cur_dir * 1e-4;\n                }\n                else \n                {\n                    cur_dir = Dir;\n                    curPosition = worldPosition+ cur_dir * 1e-4;\n                    float tmp = n1;\n                    n1 = n2;\n                    n2 = tmp;\n                }\n            }\n        }\n        else\n        {\n            colBuf = vec4(texture(iChannel1, cur_dir).rgb * colorMult * mult, 1.0);\n        }\n    }\n    fragColor = colBuf;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}