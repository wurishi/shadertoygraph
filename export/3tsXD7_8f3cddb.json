{"ver":"0.1","info":{"id":"3tsXD7","date":"1563232485","viewed":4122,"name":"GoPro Virtual Lens","username":"DANewman","description":"Demo of 360 re-pointing a virtual GoPro with additional code to control the camera orientation and zoom. ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["viewport","360","gopro","overcapture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//GoPro Virtual Lens Repoint 360 is licensed under either:\n\n//Apache License, Version 2.0, (http://www.apache.org/licenses/LICENSE-2.0)\n//MIT license (http://opensource.org/licenses/MIT)\n//at your option.\n\n//Copyright 2019 GoPro, Inc.\n\n//Permission is hereby granted, free of charge, to any person obtaining a \n//copy of this software and associated documentation files (the \"Software\"), \n//to deal in the Software without restriction, including without limitation \n//the rights to use, copy, modify, merge, publish, distribute, sublicense, \n//and/or sell copies of the Software, and to permit persons to whom the \n//Software is furnished to do so, subject to the following conditions:\n\n//The above copyright notice and this permission notice shall be included \n//in all copies or substantial portions of the Software.\n\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS \n//OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL \n//THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \n//FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \n//DEALINGS IN THE SOFTWARE.\n   \n\n//Texture Controls\n#define GOPROLOOK  \t\t1\t\t//1 for a GoPro Lens Look, 0 for stereographic lens.\n#define CHECKERS  \t\t0\t\t//1 for a checkerboard instead of a texture.\n\n//Viewport Controls\n#define PAN_ANGLE\t\t0.0\t\t// camera orientation in degrees (unlimited)\n#define TILT_ANGLE\t\t0.0\t\t// camera orientation in degrees (unlimited)\n#define DUTCH_ANGLE\t\t0.0\t\t// camera orientation in degrees (unlimited)\n#define ZOOM_PERCENT\t100.0\t\t// 100 - GoPro Wide, 200 GoPro Narrow, 20 - little planet, good range 20 - 300 \n\n#define MOUSE_GAIN \t\t0.4\n\n#define PI 3.14159265359\n#define HPI 1.5707963268\n#define QPI 0.7853981634\n#define TWOPI 6.28318530718\n#define INV_PI 0.3183098862\n#define INV_TWOPI 0.1591549431\n#define I80_DIVPI 57.2957795131\n#define PI_DIV180 0.01745329\n\n#define DEG2RAD(d)    (PI_DIV180*(d))\n#define RAD2DEG(r)    (I80_DIVPI*(r))\n\n\n\nvec4 Repoint(vec2 coord, float pan, float tilt)\n{\n    vec4 color;\n    vec2 p = coord;\n    \n\tfloat changepan = DEG2RAD(PAN_ANGLE + pan);\n\tfloat changetilt = DEG2RAD(TILT_ANGLE + tilt);\n\tfloat changeinvzoom = 100.0 / ZOOM_PERCENT;\n\n\tfloat dutch_radians = DEG2RAD(DUTCH_ANGLE);\n\tfloat sin_theta = sin(dutch_radians);\n\tfloat cos_theta = cos(dutch_radians);\n  \n    float a, phid, alpha;\n    float xy_plane_angle;\n    float z_axis_angle;\n\n    float yz_plane_angle;\n    float x_axis_angle;\n\n    float xz_plane_angle;\n    float y_axis_angle;\n\n    float phi, theta, radius, r;\n    float x = coord.x * iResolution.x, y = coord.y * iResolution.y, z;\n\tfloat newx, newy, tmp, val;           \n    float u, v;\n    \n\tnewx = x - iResolution.x * 0.5;\n\tnewy = y - iResolution.y * 0.5;\n    \n\t//rotate around the projected center.\n\ttmp = newx * cos_theta - newy * sin_theta;\n\tnewy = newx * sin_theta + newy * cos_theta;\n\tnewx = tmp;\n\n    // zoom image\n    newx = newx * changeinvzoom;\n    newy = newy * changeinvzoom;\n\n    \n    // GoPro Lens module\n    float maxradius = 1.25*iResolution.x*0.5; // Maximum pixel radius for 4x3 sensor\n    radius = sqrt(newx * newx + newy * newy);\n    theta = atan(newy, newx);       \n    r = radius / maxradius;  // normalized_radius (corner of a 4x3 sensor has value 1.0)\n#if GOPROLOOK\n\tphi = DEG2RAD(r*85.6 - r * r*10.91); //GoPro Lens look for HERO4 thru HERO7\n#else\n    phi = atan(r/1.31)*2.0; // Stereographic projection that approximates a GoPro lens.\n#endif\n    \n    \n    \n    \n    //Repoint pan, tilt around the sphere\n    xy_plane_angle = phi;\n    z_axis_angle = theta;\n\n    x = sin(xy_plane_angle)*sin(z_axis_angle);\n    y = sin(xy_plane_angle)*cos(z_axis_angle);\n    z = cos(xy_plane_angle);\n\n    yz_plane_angle = acos(y);\n    x_axis_angle = atan(z, x);\n    x_axis_angle += changetilt;\n    \n    x = sin(yz_plane_angle)*sin(x_axis_angle);\n    y = sin(yz_plane_angle)*cos(x_axis_angle);\n    z = cos(yz_plane_angle);\n\n    xz_plane_angle = acos(y);\n    y_axis_angle = atan(z, x);\n    y_axis_angle += changepan;\n\n    x = sin(xz_plane_angle)*sin(y_axis_angle);\n    y = sin(xz_plane_angle)*cos(y_axis_angle);\n    z = cos(xz_plane_angle);\n\n    xy_plane_angle = acos(y);\n    z_axis_angle = atan(z, x);\n    z_axis_angle += PI;\n\n    x = sin(xy_plane_angle)*sin(z_axis_angle);\n    y = sin(xy_plane_angle)*cos(z_axis_angle);\n    z = cos(xy_plane_angle);\n\n    yz_plane_angle = acos(y);\n    x_axis_angle = atan(z, x);\n    x_axis_angle += HPI; \n    \n    x = sin(yz_plane_angle)*sin(x_axis_angle);\n    y = sin(yz_plane_angle)*cos(x_axis_angle);\n    z = cos(yz_plane_angle);\n\n    xz_plane_angle = acos(y);\n    y_axis_angle = atan(z, x);\n    \n    x = sin(xz_plane_angle)*sin(y_axis_angle);\n    y = sin(xz_plane_angle)*cos(y_axis_angle);\n    z = cos(xz_plane_angle);\n\n    xy_plane_angle = acos(y);\n    z_axis_angle = atan(z, x);\n\n    phi = xy_plane_angle;\n    theta = z_axis_angle;\n\n\n    u = (1.25 - theta * INV_TWOPI);\n    u -= floor(u);\n    v = phi * INV_PI;\n\n\n#if CHECKERS\n    newx = u * iResolution.x * 3.0; \n    newy = v * iResolution.y * 3.0;\n    p.x = floor(newx*0.01);\n    p.y = floor(newy*0.01);\n\n    float f = 0.5 + 0.5*mod( p.x+p.y, 2.0 );\n\n    color = vec4( f, f, f, 1.0 );\n#else\n    vec2 pixpos;\n    pixpos.x = u*2.0 - 1.0;\n    pixpos.y = v - 0.5;\n    \n    //Cubemap texture handling\n    vec2 thetaphi;\n    thetaphi.x = pixpos.x * PI;\n    thetaphi.y = pixpos.y * PI;\n    \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n\t\n    color = texture(iChannel0, rayDirection); \n    \n    //For ERP sources\n    //color = texture(iChannel1, pixpos);  \n#endif\n    \n    return color;\n}\n   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 coord = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    m -= 0.5;\n    m *= MOUSE_GAIN; // guess for gopro FOV and curvature\n    \n\tfloat pan = -m.x * 360.0;\n    float tilt = m.y * 180.0;  \n    \n    fragColor = Repoint(coord, pan, tilt);    \n}","name":"Image","description":"","type":"image"}]}