{"ver":"0.1","info":{"id":"7sdfWN","date":"1656529524","viewed":239,"name":"Reflective Fractal Torus","username":"snolot","description":"Continue my fractal session. find a lot of information from https://www.shadertoy.com/view/ftlXRM","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","sdf"],"hasliked":0,"parentid":"NdcBWN","parentname":"Reflective Fractal"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZERO_TRICK max(0, -iFrame)\n#define PI 3.14159265\n#define ITERATIONS 96\n#define dmin 0.001\n#define tmax 20.\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat sdf4(vec3 p){\n\t//Torus1\n\tfloat primaryRadius1=0.55;\n\tfloat secondaryRadius1=0.2;\n\treturn length(vec2(length(p.xz)-primaryRadius1,p.y))-secondaryRadius1;\n}\n\nconst float SCALE1=0.7;\n//Mandelbox1\nconst float S1=-2.9;\nconst float R1=0.35;\nconst int ITR1=10;\nconst float F1=1.;\n\nvec3 scale_color1(vec3 q){\n\tvec3 p=q/SCALE1;\n\treturn vec3(1,1,1);\n}\nfloat sdf1(vec3 p){\n\treturn sdf4(p);\n}\nfloat sdf2(vec3 p){\n\tvec3 sp1=p/SCALE1;\n\tvec4 q3=vec4(sp1,1.0);\n\tvec4 c1=vec4(sp1,1.0);\n    float temp = +asin(sin(iTime/2.))*0.15;\n\tfor (int a1=0;a1<ITR1;a1++){\n\t\tq3.xyz=F1*(clamp(q3.xyz,-1.0,1.0)*2.0-q3.xyz);\n\t\tq3 *=S1/clamp(dot(q3.xyz,q3.xyz),R1+temp,1.0);\n\t\tq3 +=c1;\n\t}\n\treturn (.333*length(q3.xyz)/abs(q3.w))*SCALE1;\n}\n\nfloat sdf3(vec3 p){\n\tfloat thickness=0.025;\n\tfloat surface=sdf1(p);\n\tfloat onioned=abs(surface)-thickness;\n\tif (onioned>thickness){\n\t\treturn onioned;\n\t}\n\telse if (surface<-thickness){\n\t\treturn surface;\n\t}\n\telse{\n\t\tfloat detail=sdf2(p);\n\t\tfloat dist = max(onioned,detail);\n\t\treturn min(dist,surface);\n\t}\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nvec3 pmin(vec3 a, vec3 b, float k) {\n  vec3 h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 pabs(vec3 a, float k) {\n  return -pmin(a, -a, k);\n}\n\nfloat glow  = 0.0;\nfloat glow2  = 0.0;\n\nfloat map(vec3 p){\n\n   \n    \n\t/*float s=3.;\n\tp=abs(p);\n    vec3  p0 = p *.9;\n    \n    for (float i=0.; i<4.; i++){\n        p = 2.-pabs(p,.12);\n        \n    \tfloat g=-4.5*clamp(.46*max(1.6/dot(p,p),.7),.0,1.2);\n    \tp*=g;\n    \tp+=p0;\n        s*=g;\n\t}\n    \n\ts=abs(s);\n\tfloat a=3.8;\n\tp-=clamp(p,-a,a);\n    */\n    \n    p.xy *= ROT(iTime*0.13);\n    p.yz *= ROT(1.57 + iTime*0.14);\n    \n    glow += 0.001 / max(0.0125,length(p));\n    glow2 =  .6 +max(0.005,length(p)) ;\n    \n\treturn sdf3(p);//(.333*length(q3.xyz)/abs(q3.w))*0.7;\n    \n    \n\t//return length(p)/s;\n\t\n}\n\nfloat trace(vec3 ro, vec3 rd){\n    float d = 0.;\n    float t = 0.;\n\n    \n    for(int i=0; i<ITERATIONS; i++){\n       d = map(ro + rd * t);\n       \n       if(d < dmin || t > tmax) break;\n       \n       t += d;\n    }\n    \n    return t;\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r = 0.0, w = 1.0, d;\n    for(float i=1.0; i<5.0+1.1; i++)\n    {\n        d = i/5.0;\n        r += w*(d - map(p + n*d));\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\nvec3 get_normal(vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy)-map(p - e.xyy), \n                          map(p + e.yxy)-map(p - e.yxy),\t\n                          map(p + e.yyx)-map(p - e.yyx)));\n}\n\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n\tfloat h = 1.0;\n    for( int i=0; i<24; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n        if( res<0.001 )break;\n        t += clamp( h, 0.01, 2. );\n    }\n    return clamp(res,0.,1.0);\n}\n\nvec3 get_col(vec3 p){\n    p.xy *= ROT(iTime*0.13);\n    p.yz *= ROT(1.57 + iTime*0.14);\n    \n    float d1 = sdf1(p);\n    float d2 = sdf2(p);\n    if (abs(d1)<abs(d2)){\n        \n        return vec3(.8, .0, 0.);\n    }\n    else{\n        return vec3(1.0,.7,0.0);\n    }\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse ){\n    float radius \t= 1.2 ;//+ sin(time*.25)*1.6;\n    float theta \t= -0.85 + 6.0*mouse.x;// - iTime*0.15;\n    float phi \t\t= .1 +1.57 ;//* mouse.y ;//.5 + sin(iTime*.05) *2.14159 ;//mouse.y - iTime*0.5;\n    \n    float pos_x = radius * cos(theta) * sin(phi);\n    float pos_z = radius * sin(theta) * sin(phi);\n    float pos_y = radius * cos(phi);\n    \n    camPos = vec3(pos_x, pos_y, pos_z);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nvec3 postProcess(in vec3 col, in vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(1.0/2.2)); \n  /*col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation*/\n  col*=0.5+0.5*pow(29.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),.5);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = (fragCoord* 2.0 - iResolution.xy) / iResolution.y;\n    vec2 q=fragCoord.xy/iResolution.xy; \n    /*vec3 ro = vec3(0,0.,1.75);\n    vec3 rd = normalize(vec3(uv,-2.0));*/\n    //vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(uv.xy,1.0) ); // 2.0 is the lens length\n    //vec3 col = texture(iChannel0, rd).rgb * .3;\n    vec3 col = pow(texture(iChannel0, rd).rgb, vec3(2.2));\n\n    float d = trace(ro,rd);\n    \n    if(d < tmax ){\n        vec3 p = ro + rd * d;\n       \n        \n        vec3 n = get_normal(p);      \n\t\tvec3 lightPos=vec3(0.,8.,2.);\n    \tvec3 li = lightPos - p;\n\t\tfloat len = length( li );\n\t\tli /= len;\n        float amb=0.5+0.5*n.y;\n\t\tfloat dif = clamp(dot(n, li), 0.4, 1.0);\n        float ao = get_ao(p,n);\n        float shd = softshadow(ro,rd,1.5);\n        \n        vec3 refl = reflect(rd,n);\n        //vec3 rf = texture(iChannel0, refl).xyz;\n        vec3 rf = pow(texture(iChannel0, refl).xyz, vec3(2.2));\n        \n        float spe = max(0.0, pow(clamp(dot(lightPos, reflect(rd, n)), 0.0, 1.0), 8.0)); \n        vec3 c =  get_col(p);\n        \n        col= c * (dif * amb) * ao ;\n        \n        col += vec3(spe * .0)  * ao;\n        //col += vec3(0.3) * glow  ;\n        col += rf * .4;\n        \n        if(c == vec3(1.0,.7,0.0)){//length(p)< 1.23)\n           //col*=  shd;\n           col *=  glow2 * ao ;\n           \n        }\n    }\n    \n    fragColor = vec4(postProcess(col, q),1.0);\n}","name":"Image","description":"","type":"image"}]}