{"ver":"0.1","info":{"id":"43sGR4","date":"1707203850","viewed":80,"name":"pov test","username":"chans","description":"inspired by https://www.youtube.com/watch?v=TdTMeNXCnTs\n\ncopied b&w shader from https://www.shadertoy.com/view/XsV3Rd","likes":0,"published":1,"flags":34,"usePreview":0,"tags":["noise","pov"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make the fragCoordinate within the range of 0 and 1\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    // Output to screen\n    fragColor =  texture(iChannel0,xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n   {\n    // Make the fragCoordinate within the range of 0 and 1\n    vec2 xy = fragCoord.xy / iResolution.xy;\n\n    // Rrutrn the color of the texture in Channel0\n    vec4 texColor = texture(iChannel3, xy);\n\n    // Initialize the variables\n    vec4 white = vec4(1, 1, 1, 1);\n    vec4 black = vec4(0, 0, 0, 1);\n    if (iTime <= 2.0) \n    \n    {\n        texColor = texture(iChannel0, xy);\n        // Average the color out\n        //float average = texColor.r + texColor.g + texColor.b/3.0;\n\n        // Check if it's closer to white or black\n       texColor = hash(xy)  < 0.5  ? black : white;\n\n    }\n    else \n    {\n        if (texture(iChannel1, xy) != texture(iChannel2, xy)) {\n             float average = texColor.r + texColor.g + texColor.b/3.0;\n            // Check if it's closer to white or black\n           texColor = average < 0.5  ? white : black;\n        }\n    }\n      // sets the pixels color\n    fragColor = texColor;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    \n    fragColor =  texture(iChannel0, xy);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make the fragCoordinate within the range of 0 and 1\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n   \n    // Rrutrn the color of the texture in Channel0\n    vec4 texColor = texture(iChannel0, xy);\n    \n \t// Initialize the variables\n    vec4 white = vec4(1, 1, 1, 1);\n    vec4 black = vec4(0, 0, 0, 1);\n    \n    // Average the color out\n\tfloat average = texColor.r + texColor.g + texColor.b/3.0;\n    \n    // Check if it's closer to white or black\n    if (average <= 0.5)\n    {\n        texColor = black;\n    }\n    else \n        texColor = white;\n\n  \t// sets the pixels color\n    fragColor = texColor;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// buf - iChannel to read from\n// addr - the data address in the form of an ivec2 (vector containing two integers)\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n// buf_pos - fragment position (fragCoord)\n// addr - the data address in the form of an ivec2\n// storeData() just evaluates if the data address matches the fragment position\n// in which case the data should be stored in fragColor.\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(7, 157))) * 2097152.0);\n}","name":"Common","description":"","type":"common"}]}