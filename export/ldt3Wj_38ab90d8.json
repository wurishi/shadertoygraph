{"ver":"0.1","info":{"id":"ldt3Wj","date":"1452274376","viewed":349,"name":"Quadratic Curve Control","username":"gaz","description":"can use the mouse. \ncheap bezier.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","curve","de"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// rewrite 16/01/14\n\n#define PI\t3.14159265359\n\nvec2 P0, P1, P2;\n\n// text\n// https://www.shadertoy.com/view/llSGRm\n#define CHAR_SIZE vec2(6, 7)\n#define CHAR_SPACING vec2(6, 9)\n#define DOWN_SCALE 2.0\n\nvec2 ch_0 = vec2(935221.0,731292.0);\nvec2 ch_1 = vec2(274497.0,33308.0);\nvec2 ch_2 = vec2(934929.0,1116222.0);\nvec2 ch_3 = vec2(934931.0,1058972.0);\nvec2 ch_4 = vec2(137380.0,1302788.0);\nvec2 ch_5 = vec2(2048263.0,1058972.0);\nvec2 ch_6 = vec2(401671.0,1190044.0);\nvec2 ch_7 = vec2(2032673.0,66576.0);\nvec2 ch_8 = vec2(935187.0,1190044.0);\nvec2 ch_9 = vec2(935187.0,1581336.0);\nvec2 ch_A = vec2(935188.0,780450.0);\nvec2 ch_B = vec2(1983767.0,1190076.0);\nvec2 ch_C = vec2(935172.0,133276.0);\nvec2 ch_D = vec2(1983764.0,665788.0);\nvec2 ch_E = vec2(2048263.0,1181758.0);\nvec2 ch_F = vec2(2048263.0,1181728.0);\nvec2 ch_G = vec2(935173.0,1714334.0);\nvec2 ch_H = vec2(1131799.0,1714338.0);\nvec2 ch_I = vec2(921665.0,33308.0);\nvec2 ch_J = vec2(66576.0,665756.0);\nvec2 ch_K = vec2(1132870.0,166178.0);\nvec2 ch_L = vec2(1065220.0,133182.0);\nvec2 ch_M = vec2(1142100.0,665762.0);\nvec2 ch_N = vec2(1140052.0,1714338.0);\nvec2 ch_O = vec2(935188.0,665756.0);\nvec2 ch_P = vec2(1983767.0,1181728.0);\nvec2 ch_Q = vec2(935188.0,698650.0);\nvec2 ch_R = vec2(1983767.0,1198242.0);\nvec2 ch_S = vec2(935171.0,1058972.0);\nvec2 ch_T = vec2(2035777.0,33288.0);\nvec2 ch_U = vec2(1131796.0,665756.0);\nvec2 ch_V = vec2(1131796.0,664840.0);\nvec2 ch_W = vec2(1131861.0,699028.0);\nvec2 ch_X = vec2(1131681.0,84130.0);\nvec2 ch_Y = vec2(1131794.0,1081864.0);\nvec2 ch_Z = vec2(1968194.0,133180.0);\n\nvec2 res;// = iResolution.xy / DOWN_SCALE;\nvec2 print_pos = vec2(0);\n\nfloat extract_bit(in float n, in float b)\n{\n    b = clamp(b,-1.0,22.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\nfloat sprite(in vec2 spr, in vec2 size, in vec2 uv)\n{\n    uv = floor(uv);\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    return bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;\n\n}\nfloat char(in vec2 ch, in vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\nvec2 pos2uv(in vec2 p)\n{\n    vec2 uv = iResolution.xy / 2.0 ;\n    uv += p * iResolution.y / 2.0;\n    uv /= DOWN_SCALE;\n \treturn  uv; \n}\n\n////////\n\nmat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix(vec3(1),clamp((abs(fract(h+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),s)* v;\n}\n\nfloat deSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n\tvec2 pa=p-a,ba=b-a;\n\tfloat h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn length(pa-ba*h);\n}\n\nfloat Cross(in vec2 a, in vec2 b ) \n{\n    return a.x*b.y-b.x*a.y;\n}\n\nvec2 intersection(in vec2 a, in vec2 b, in vec2 c, in vec2 d)\n{\n    float x0 = Cross(b-a,c-a);\n    float x1 = Cross(b-a,b-d);\n    return mix(c,d,x0/(x0+x1));\n}\n\n// https://www.nishnet.ne.jp/~math/diary/papers/houbutusen.pdf\nvec4 curveFocus(in vec2 a, in vec2 b, in vec2 c)\n{\n    vec2 m = mix(a,c,0.5);\n    vec2 v = normalize(b-m);\n    vec2 ab = b-a, cb = b-c;  \n    vec2 aa = a+v, cc = c+v;\n    vec2 p1 = mix(aa,intersection(a, b, aa, aa+vec2(1.0,-ab.x/ab.y)),2.0);\n    vec2 p2 = mix(cc,intersection(c, b, cc, cc+vec2(1.0,-cb.x/cb.y)),2.0);   \n    vec2 f = intersection(a,p1,c,p2 ); \n    float s1 = length(f-a), s2 = length(f-c);\n    vec2 f1 = intersection(a+v*s1, c+v*s2, f, f+v);\n    vec2 o = mix(f,f1,0.5);\n    return vec4(f,o);\n}\n\nvec2 curveTransform(in vec2 p, in vec4 f)\n{\n    p -= f.zw;\n    vec2 of = f.xy-f.zw;;\n    p *= rotate(atan(-of.x/of.y));\n    return p;\n}\n\nfloat curveGradient(in vec4 f)\n{\n    return sign(f.y-f.w)/(4.0*length(f.xy-f.zw));\n}\n\nvec2 curvePosition(in vec4 f, in vec2 a)\n{\n    vec2 of = f.xy -f.zw;\n    return vec2(sign(f.y-f.w)*Cross(a-f.xy, of)/length(of), 0.0);\n}\n\nvec4 curvePosition2(in vec4 f, in vec2 a, in vec2 b)\n{\n    vec2 of = f.xy -f.zw;\n    float len = length(of);\n    float s = sign(f.y-f.w);\n    a = vec2(s*Cross(a-f.xy, of)/len, 0.0);\n    b = vec2(s*Cross(b-f.xy, of)/len, 0.0);\n    return vec4(a,b);\n}\n\nvec2 opBend(in vec2 p, in float d) // used quadratic function\n{\n    p.y -= d*p.x*p.x;\n    p.y *= cos(atan(2.0*d*p.x));\n \treturn p;   \n}\n\nfloat deCurve(in vec2 p, in vec2 a, in vec2 b, in vec2 c)\n{\n\tvec4 f = curveFocus(a,b,c);\n    p = opBend(curveTransform(p,f), curveGradient(f));\n    //return deSegment(p, curvePosition(f,a), curvePosition(f,c));\n    vec4 pos = curvePosition2(f,a,c);\n    return deSegment(p, pos.xy, pos.zw);\n}\n\n// http://www.demoscene.jp/?p=1147\nfloat lengthN(vec2 p, float n)\n{\n  p = pow(abs(p), vec2(n));\n  return pow(p.x+p.y, 1.0/n);\n}\n\nfloat map(in vec3 p)\n{    \n    p.zx *= rotate(iTime * 0.3); \n    p.yz *= rotate(iTime * 0.5);    \n    vec2 q = vec2(0.8 * deCurve(p.xy,P0,P1,P2), p.z);\n    //return length(q) - 0.1;    \n    return lengthN(q, 3.0) - 0.1;    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 10.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis || t > maxd) break;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvec3 backBoard(in vec2 p , in vec2 fragCoord)\n{\n    vec2 a = P0, b = P1, c = P2;\n    \n    vec2 m = mix(a,c,0.5);\n    vec2 v = normalize(b-m);\n    vec2 ab = normalize(b-a), cb = normalize(b-c), ac = normalize(c-a);  \n    vec2 aa = a+v, cc = c+v;\n    vec2 p1 = mix(aa,intersection(a, b, aa, aa+vec2(1.0,-ab.x/ab.y)),2.0);\n    vec2 p2 = mix(cc,intersection(c, b, cc, cc+vec2(1.0,-cb.x/cb.y)),2.0);   \n    vec2 f = intersection(a,p1,c,p2 ); \n    float s1 = length(f-a), s2 = length(f-c);\n    vec2 f1 = intersection(a+v*s1, c+v*s2, f, f+v);\n    vec2 o = mix(f,f1,0.5);\n    \n    aa = a + s1*v;\n    cc = c + s2*v;\n\n    vec2 uv = fragCoord / DOWN_SCALE;\n    float size = 0.02;\n    float width = 0.01;\n    \n    vec3 txtCol = hsv(0.4, 0.7, 1.0);\n    vec3 pntCol1 = hsv(0.2, 0.7, 1.0);\n    vec3 pntCol2 = vec3(1.0);\n    vec3 pntCol3 = hsv(0.8, 0.7, 1.0);\n    vec3 lnCol1 = hsv(0.3, 0.7, 1.0);\n    vec3 lnCol2 = hsv(0.6, 0.7, 1.0);\n    vec3 lnCol3 = hsv(0.0, 0.7, 1.0);\n    \n    vec3 col = mix(vec3(0.05, 0.03, 0.0), vec3(0.8), smoothstep(0.4, 3.5, length(p)));\n\tcol = mix(col, lnCol1, smoothstep(width, 0.0, deSegment(p, a, b)));   \n    col = mix(col, lnCol1, smoothstep(width, 0.0, deSegment(p, b, c)));   \n\tcol = mix(col, lnCol1, smoothstep(width, 0.0, deSegment(p, c, a)));   \n\tcol = mix(col, lnCol1, smoothstep(width, 0.0, deSegment(p, b, mix(a,c,0.5))));   \n \n    col = mix(col, lnCol2, smoothstep(width, 0.0, deSegment(p, a, f)));   \n    col = mix(col, lnCol2, smoothstep(width, 0.0, deSegment(p, c, f)));   \n\n    col = mix(col, lnCol2, smoothstep(width, 0.0, deSegment(p, a, aa)));   \n    col = mix(col, lnCol2, smoothstep(width, 0.0, deSegment(p, c, cc)));   \n    col = mix(col, lnCol2, smoothstep(width, 0.0, deSegment(p, aa, f1)));   \n    col = mix(col, lnCol2, smoothstep(width, 0.0, deSegment(p, cc, f1)));   \n    col = mix(col, lnCol2, smoothstep(width, 0.0, deSegment(p, f, f1)));   \n\n  \tvec4 cf = curveFocus(a,b,c);\n    vec2 pp = opBend(curveTransform(p,cf), curveGradient(cf));\n    col = mix(col, lnCol2, smoothstep(width, 0.0, abs(pp.y))); \n       \n    float de = abs(deCurve(p,a,b,c));\n    col = mix(col, lnCol3, smoothstep(width*3.0, 0.0, de)); \n   \n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - a) - size));\n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - b) - size));\n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - c) - size));\n    col = mix(col, pntCol2, smoothstep(width, 0.0, length(p - o) - size));\n    col = mix(col, pntCol3, smoothstep(width, 0.0, length(p - f) - size));\n\tcol = mix(col, pntCol1, smoothstep(width, 0.0, length(p - aa) - size));\n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - cc) - size));\n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - f1) - size));\n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - m) - size));\n       \n    print_pos = pos2uv(a + vec2(-0.15, 0.05));\n    col = mix(col, txtCol , char(ch_A, uv));\n    print_pos = pos2uv(b + vec2(0.05));\n    col = mix(col, txtCol , char(ch_B, uv));\n    print_pos = pos2uv(c + vec2(0.05));\n    col = mix(col, txtCol , char(ch_C, uv));\n    \n    print_pos = pos2uv(f + vec2(0.05));\n    col = mix(col, txtCol , char(ch_F, uv));\n    print_pos = pos2uv(o + vec2(0.05));\n    col = mix(col, txtCol , char(ch_O, uv));\n        \n    print_pos = pos2uv(aa + vec2(-0.15, 0.05));\n    col = mix(col, txtCol , char(ch_A, uv));\n    col = mix(col, txtCol , char(ch_A, uv));\n    print_pos = pos2uv(cc + vec2(0.05));\n    col = mix(col, txtCol , char(ch_C, uv));\n\tcol = mix(col, txtCol , char(ch_C, uv));\n    print_pos = pos2uv(f1 + vec2(0.05));\n    col = mix(col, txtCol , char(ch_F, uv));\n\tcol = mix(col, txtCol , char(ch_1, uv));\n    print_pos = pos2uv(m + vec2(0.05));\n    col = mix(col, txtCol , char(ch_M, uv));\n\t  \n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy / DOWN_SCALE;\n    \n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;    \n    P0 = vec2(-1.0, -0.3);\n    P1 = length(iMouse.xy) > 0.0 ? m: vec2(0.0, sin(PI / 3.0) / 3.0);\n    P2 = vec2(1.0, -0.5);  \n    vec3 col = backBoard(p, fragCoord);\n    vec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 rd = normalize(vec3(p, -2.0));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    \tcol = vec3(0.7, 0.8, 0.9);\n        col *= max(dot(li, nor), 0.2);\n        col += pow(max(dot(vec3(0.0, 0.0, 1.0), reflect(-li, nor)), 0.0), 30.0);\n        col = pow(col, vec3(0.8)); \n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}