{"ver":"0.1","info":{"id":"4cXXRj","date":"1705417170","viewed":107,"name":"Solar activity","username":"Moumouke","description":"Domain warping combined with raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 sunpos = vec3(-150, -55, 140);\nfloat sunradius = 64.;\n\nstruct WarpData3d {\n    vec3 s1;\n    vec3 s2;\n    float sf;\n};\n\n// https://iquilezles.org/articles/palettes/\n// https://github.com/thi-ng/cgg\n// https://github.com/ReimuA/cgg\nvec3 palette(float x) {\n    float t = clamp(x, 0., 1.);\n    vec3 a = vec3(0.500, 0.500, -3.142);\n    vec3 b = vec3(1.098, 1.028, 0.500);\n    vec3 c = vec3(0.158, -0.372, 1.000);\n    vec3 d = vec3(-0.262, 0.498, 0.667);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 rotateX(vec3 p, float angle) {\n    return p * mat3x3(1.0, 0.0, 0.0, 0.0, cos(angle), -sin(angle), 0.0, sin(angle), cos(angle));\n}\n\nvec3 rotateY(vec3 p, float angle) {\n    return p * mat3x3(cos(angle), 0.0, sin(angle), 0.0, 1.0, 0.0, -sin(angle), 0.0, cos(angle));\n}\n\nvec3 rotateZ(vec3 p, float angle) {\n    return  p * mat3x3(cos(angle), -sin(angle), 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 1.0);\n}\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 perm(vec4 x) {\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nfloat noise3(vec3 p) {\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\nfloat fbm3(vec3 x, float h) {\n    vec3 p = x;\n    float g = exp2(-h);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n\n    for (int i = 0; i < 12; i++) {\n        t += a * noise3(f * p);\n        f *= 2.0;\n        a *= g;\n        p = rotateX(p, 0.4);\n        p = rotateY(p, 0.1);\n        p = rotateZ(p, 0.7);\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/warp/ (2d version)\nWarpData3d warp3d(vec3 point) {\n    WarpData3d warpData;\n\n    vec3 x = point;\n\n    vec3 s1 = vec3(\n        fbm3(x + vec3(32, 12, 2), 1.),\n        fbm3(x + vec3(-23, 51.3, -4), 1.),\n        fbm3(x + vec3(-3, 251.3, -14), 1.)\n    );\n\n    vec3 s2 = vec3(\n        fbm3(s1 * 3. + vec3(1245.7, 19.2, 14), 1.),\n        fbm3(s1 * 3. + vec3(0.3, 42.8, 4), 1.),\n        fbm3(s1 * 3. + vec3(12.3, 2.8, 14), 1.)\n    );\n\n    float p = fbm3(x + s2 * 2.1, 1.);\n\n    warpData.s1 = s1;\n    warpData.s2 = s2;\n    warpData.sf = p;\n    return warpData;\n}\n\nfloat c01(float p){\n    return clamp(p, 0.0, 1.0);\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdf(vec3 p) {\n    return sdfSphere(p - sunpos, sunradius);\n}\n\nstruct RaymarchData {\n    float distance;\n    float minDistance;\n};\n\nRaymarchData raymarch(vec3 rayOrigin, vec3 rayDirection) {\n    float distance = 0.0;\n    float maxDistance = 400.0;\n    float minHitDistance = 0.001;\n    RaymarchData rData;\n\n    rData.minDistance = 5000000.;\n\n    for (int i = 0; i < 64; i++) {\n        if (distance > maxDistance) {\n\t\t\tbreak;\n        }\n\n        vec3 pos = rayOrigin + rayDirection * distance;\n\n        float res = sdf(pos);\n\n        rData.minDistance = min(rData.minDistance, res);\n\n        if (res < minHitDistance) {\n            rData.distance = distance + res;\n            return rData;\n        }\n\n        distance += res;\n    }\n\n    rData.distance = -1.;\n\n    return rData;\n}\n\nvec3 render(vec3 rayOrigin, vec3 rayDirection) {\n    RaymarchData rData = raymarch(rayOrigin, rayDirection);\n\n    if (rData.distance < 0.) {\n        vec3 c = vec3(0.1, 0., 0);\n        float r = smoothstep(0., 1.5, rData.minDistance);\n        return mix(0.05 / c, vec3(0.), r);\n    }\n\n    vec3 point = rayOrigin + rayDirection * rData.distance;\n    vec3 nPos = point - sunpos;\n    nPos /= 10.;\n    nPos += vec3(1.1, -3, 12.) * iTime / 60.;\n    nPos = rotateY(nPos, 1. * iTime / 24.);\n    WarpData3d wd = warp3d(nPos);\n    float idx = mix(length(wd.s1) / 4., length(wd.s2) / 3.6, (wd.sf));\n    return palette(idx);\n}\n\nmat3x3 cam(vec3 ro, vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = cross(cu, cw);\n\n    return mat3x3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float camspeed = 1.25;\n    vec3 ta = vec3(0., -.75, 0.);\n    vec3 ro = ta + vec3(4.9, 2., -4.9);\n    mat3x3 ca = cam(ro, ta);\n\n    vec2 st = (2. * fragCoord.xy - iResolution .xy) / iResolution .y;\n    vec3 rd = normalize(ca * normalize(vec3(st, 2.5)));\n    vec3 color = render(ro, rd);\n    vec3 gammaCorrected = pow(color, vec3(1.0 / 2.6));\n    \n    fragColor = vec4(gammaCorrected, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}