{"ver":"0.1","info":{"id":"wtB3Wy","date":"1560920313","viewed":270,"name":"triplanar mapping test","username":"bitnenfer","description":"Applying a texture to a raymarched volume","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","triplanar","textures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 E = vec2(0.0001, 0.0);\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nmat2 rot(float r)\n{\n    float cr = cos(r);\n    float sr = sin(r);\n\treturn mat2(cr, sr, -sr, cr);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n\tvec3 d = abs(p) - s;\n    return length(max(d,0.0)) - min(max(d.x,max(d.y, d.z)),0.0);\n}\n\nmat2 tr;\nvec3 P;\nfloat map(vec3 p)\n{\n    vec3 pA = p + vec3(1.2+sin(iTime)*0.8, 0.0, 0.0);\n    vec3 pB = p - vec3(1.2+sin(iTime)*0.8, 0.0, 0.0);\n    mat2 r0 = rot(iTime);\n    mat2 r1 = rot(-iTime);\n    pA.xz *= r0;\n    pB.xz *= r1;\n\tfloat a = box(pA, vec3(1.0, 6.0, 1.0))-0.3;\n    float b = length(pB) - 1.2;\n    float dist = fOpUnionRound(a,b,0.5);\n    if (a < b) \n    {\n    \tP = pA;\n        tr = r0;\n    }\n    else\n    {\n    \tP = pB;\n    \ttr = r1;\n    }\n\treturn dist;\n}\n\nvec3 normal(vec3 p)\n{\n\treturn normalize(vec3(\n    \tmap(p + E.xyy) - map(p - E.xyy),\n    \tmap(p + E.yxy) - map(p - E.yxy),\n    \tmap(p + E.yyx) - map(p - E.yyx)\n    ));\n}\n\nfloat LOD(in vec2 uv)\n{\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n    float dp = max(dot(dx,dx), dot(dy,dy));\n    return max(0.0, 0.5 * log2(dp) - 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ar = vec2(iResolution.x/iResolution.y,1.0);\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * ar;\n    vec3 ro = vec3(0.0, 2.0, -8.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.8, 3.0));\n    vec3 col = vec3(0.0);\n    vec3 ld0 = normalize(vec3(0.5, 1.0, -0.8));\n    vec3 ld1 = normalize(vec3(-0.5, -1.0, 0.8));\n    float contrib = 0.0;\n    float t = 0.0;    \n    const float texScale = 0.5;\n    const vec2 texOffset = vec2(1.0, 1.0);\n    \n    ro.yz *= rot(iTime*0.2);\n    rd.yz *= rot(iTime*0.2);\n    \n    for (int i = 0; i < 800; ++i) \n    {\n        vec3 p = ro + rd * t;\n    \tfloat d = map(p);\n        if (d < 0.0001) \n        {\n\t\t\tcontrib = 1.0;\n            break;\n        }\n        t += d;\n        if (t > 100.0)\n        {\n        \tbreak;\n        }\n    }\n    \n    vec3 p = ro + rd * t;\n    vec3 v = normalize(ro - p);\n    vec3 h = normalize(v + ld0);\n    vec2 uvX = (P.zy + texOffset) * texScale;\n    vec2 uvY = (P.xz + texOffset) * texScale;\n    vec2 uvZ = (P.xy + texOffset) * texScale;\n    vec3 colX = texture(iChannel0, uvX).rgb;\n    vec3 colY = texture(iChannel0, uvY).rgb;\n    vec3 colZ = texture(iChannel0, uvZ).rgb;\n    vec3 n = normal(p);\n    vec3 n2 = n;\n    n2.xz *= -tr;\n    vec3 bw = abs(n2);\n    bw = bw / (bw.x + bw.y + bw.z);\n    col += colX * bw.x + colY * bw.y + colZ * bw.z;\n    col *= \n        (0.1 + max(dot(n, ld0), 0.0) + pow(max(dot(n, normalize(v + ld0)), 0.0), 16.0) * 0.2) +\n        (0.1 + max(dot(n, ld1), 0.0) + pow(max(dot(n, normalize(v + ld1)), 0.0), 32.0));\n    \n    fragColor = vec4(col * contrib, 1.0);\n}","name":"Image","description":"","type":"image"}]}