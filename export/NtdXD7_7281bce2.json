{"ver":"0.1","info":{"id":"NtdXD7","date":"1640474150","viewed":230,"name":"xmas-tree-2021","username":"rikardio","description":"Happy Hollidays!","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["glowing","xmastree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A x-mas tree quickly written on xmas-eve.\n// Warning: Might contain bugs and non-optimal code :)\n\n\n#define NUM_POINTS 140.\n\nvec2 rotate(vec2 v, float a) {\n  float s = sin(a);\n  float c = cos(a);\n  mat2 m = mat2(c, -s, s, c);\n  return m * v;\n}\n\nfloat hash21(vec2 p) {\n  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat ring(vec2 uv, float d) {\n  float l = smoothstep(0.1, 0., pow(abs(d - 0.1), 0.4));\n  return l;\n}\n\nfloat ambient_light(float d) { return smoothstep(0.4, 0., d) * 0.1; }\n\nfloat center(float d) { return pow(0.019 / d, 2.); }\n\nfloat beams(vec2 uv, vec3 p, float d) {\n  float invD = 1. / d;\n  float l = 0.;\n  for (float i = 0.; i < 6.28; i += .57) {\n    vec2 offset = p.xy;\n    vec2 rotated = offset + rotate(uv - offset, iTime + i * .5 + p.x * 100.);\n    l += smoothstep(0.005, 0., abs(rotated.x - p.x)) * invD * 0.03;\n  }\n  return l;\n}\n\nconst vec3[3] colors =\n    vec3[3](vec3(1.9, 1.3, 0.2), vec3(0.9, 0.3, 0.1), vec3(0.8, 1.2, 0.4));\n\nvec3 star(float index, vec2 uv, vec3 p, bool beam, bool halo) {\n  float r = p.z;\n  uv *= .5 + r * 10.;\n  float d = max(0.0001, distance(uv, p.xy));\n  float invD = 1. / d;\n  vec3 color = vec3(0.);\n\n  int iIndex = int(index);\n  vec3 ring_color = colors[(iIndex % 3)];\n  vec3 center_color = colors[(iIndex + 1) % 3];\n  vec3 ambient_color = colors[2];\n\n  // ring\n  if (halo) {\n    for (float i = 1.; i < mod(index, 5.); i++) {\n      color += ring(uv, d + i * 0.01) * ring_color * (1. / i);\n    }\n  }\n  // ambient light\n  color += ambient_light(d) * (center_color * ambient_color);\n\n  // center\n  color += center(d) * center_color;\n\n  // beams\n  if (beam) {\n    color += beams(uv, p, d) * ring_color;\n  }\n  return clamp(color * min(1., 0.012 / pow(p.z, 0.5)), 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates\n  vec2 uv = fragCoord / iResolution.xy;\n  uv -= .5;\n\n  float aspectRatio = iResolution.x / iResolution.y;\n  uv.x *= aspectRatio;\n\n  vec3 col = vec3(0., 0.05, 0.1);\n\n  float t = iTime * 0.2;\n\n  // Play with different values here for different designs\n  const float k = 102.;\n\n  vec3 origin = vec3(0, 0, 0.5 + cos(iTime * 0.1) * 0.1);\n\n  for (float i = 0.; i < NUM_POINTS; i++) {\n    float p = i / NUM_POINTS;\n    float pkt = p * k + t;\n    vec3 xyz =\n        vec3(cos(pkt) * (1. - p), -1.4 + p * 3., sin(pkt) * (1. - p) * 0.1);\n\n    // Only draw front\n    if (xyz.z < .0) {\n      col += star(i, uv, origin + xyz, xyz.z > 0.15, false) * 3.;\n    }\n  }\n\n  // Top star\n  col += star(3., uv, origin + vec3(0, 1.7, 0.0), true, false) * 30.;\n\n  col *= vec3(1, 0.8, 0.9);\n\n  // Gamma-corr\n  col = pow(col, vec3(0.4545));\n\n  // Noise\n  col *= 0.75 + hash21(uv.xy + fract(iTime)) * 0.25;\n\n  // vingette\n  float vignette = 1. - length(uv);\n  vignette = pow(abs(vignette), 0.3);\n\n  fragColor = vec4(col * vignette, 1.0);\n}","name":"Image","description":"","type":"image"}]}