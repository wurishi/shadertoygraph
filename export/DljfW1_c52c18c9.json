{"ver":"0.1","info":{"id":"DljfW1","date":"1694008561","viewed":38,"name":"FBM+voronoi terrain","username":"nasino","description":"More realistic balance of plains and mountain ranges, continuing topography of peninsulas and archipelagos.\n\nforked\n[url]https://shadertoy.com/view/lsVyRy[/url].","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain","fbm"],"hasliked":0,"parentid":"cl2fDh","parentname":"FBM simple terrain"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SEA_LEVEL 0.3\n#define MULTIPLE 5.0\n// variant of Vorocracks: https://shadertoy.com/view/lsVyRy\n// integrated with cracks here: https://www.shadertoy.com/view/Xd3fRN\n\n#define MM 0\n\n#define VARIANT 1              // 1: amplifies Voronoi cell jittering\n#if VARIANT\n      float ofs = .5;          // jitter Voronoi centers in -ofs ... 1.+ofs\n#else\n      float ofs = 0.;\n#endif\n    \n//int FAULT = 1;                 // 0: crest 1: fault\n\nfloat RATIO = 1.,              // stone length/width ratio\n /*   STONE_slope = .3,        // 0.  .3  .3  -.3\n      STONE_height = 1.,       // 1.  1.  .6   .7\n      profile = 1.,            // z = height + slope * dist ^ prof\n */   \n      CRACK_depth = 1.1,\n      CRACK_zebra_scale = 0.7,  // fractal shape of the fault zebra\n      CRACK_zebra_amp = .9,\n      CRACK_profile = 0.55,      // fault vertical shape  1.  .2 \n      CRACK_slope = 2.0,       //                      10.  1.4\n      CRACK_width = .02;\n    \n\n// std int hash, inspired from https://www.shadertoy.com/view/XlXcW4\nvec3 hash3( uvec3 x ) \n{\n#   define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) + 1e-30; // <- eps to fix a windows/angle bug\n}\n\n// === Voronoi =====================================================\n// --- Base Voronoi. inspired by https://www.shadertoy.com/view/MslGD8\n\n#define hash22(p)  fract( 18.5453 * sin( p * mat2(127.1,311.7,269.5,183.3)) )\n#define disp(p) ( -ofs + (1.+2.*ofs) * hash22(p) )\n\nvec3 voronoi( vec2 u )  // returns len + id\n{\n    vec2 iu = floor(u), v;\n\tfloat m = 1e9,d;\n#if VARIANT\n    for( int k=0; k < 25; k++ ) {\n        vec2  p = iu + vec2(k%5-2,k/5-2),\n#else\n    for( int k=0; k < 9; k++ ) {\n        vec2  p = iu + vec2(k%3-1,k/3-1),\n#endif\n            o = disp(p),\n      \t      r = p - u + o;\n\t\td = dot(r,r);\n        if( d < m ) m = d, v = r;\n    }\n\n    return vec3( sqrt(m), v+u );\n}\n\n// --- Voronoi distance to borders. inspired by https://www.shadertoy.com/view/ldl3W8\nvec3 voronoiB( vec2 u )  // returns len + id\n{\n    vec2 iu = floor(u), C, P;\n\tfloat m = 1e9,d;\n#if VARIANT\n    for( int k=0; k < 25; k++ ) {\n        vec2  p = iu + vec2(k%5-2,k/5-2),\n#else\n    for( int k=0; k < 9; k++ ) {\n        vec2  p = iu + vec2(k%3-1,k/3-1),\n#endif\n              o = disp(p),\n      \t      r = p - u + o;\n\t\td = dot(r,r);\n        if( d < m ) m = d, C = p-iu, P = r;\n    }\n\n    m = 1e9;\n    \n    for( int k=0; k < 25; k++ ) {\n        vec2 p = iu+C + vec2(k%5-2,k/5-2),\n\t\t     o = disp(p),\n             r = p-u + o;\n\n        if( dot(P-r,P-r)>1e-5 )\n        m = min( m, .5*dot( (P+r), normalize(r-P) ) );\n    }\n\n    return vec3( m, P+u );\n}\n\n// === pseudo Perlin noise =============================================\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\nint MOD = 1;  // type of Perlin noise\n    \n// --- 2D\n#define hash21(p) fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123)\nfloat noise2(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix(hash21(i+vec2(0,0)),hash21(i+vec2(1,0)),f.x),\n                  mix(hash21(i+vec2(0,1)),hash21(i+vec2(1,1)),f.x), f.y);\n\treturn   MOD==0 ? v\n\t       : MOD==1 ? 2.*v-1.\n           : MOD==2 ? abs(2.*v-1.)\n                    : 1.-abs(2.*v-1.);\n}\n\nfloat fbm2(vec2 p) {\n    float v = 0.,  a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 9; i++, p*=2.,a/=2.) \n        p *= R,\n        v += a * noise2(p);\n\n    return v;\n}\n#define noise22(p) vec2(noise2(p),noise2(p+17.7))\nvec2 fbm22(vec2 p) {\n    vec2 v = vec2(0);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 6; i++, p*=2.,a/=2.) \n        p *= R,\n        v += a * noise22(p);\n\n    return v;\n}\nvec2 mfbm22(vec2 p) {  // multifractal fbm \n    vec2 v = vec2(1);\n    float a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 6; i++, p*=2.,a/=2.) \n        p *= R,\n        //v *= 1.+noise22(p);\n          v += v * a * noise22(p);\n\n    return v-1.;\n}\n\nvec2 random2(in vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n                   dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat perlinNoise(in vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n\n    return mix( mix( dot( v00, f - vec2(0,0) ), dot( v10, f - vec2(1,0) ), u.x ),\n                 mix( dot( v01, f - vec2(0,1) ), dot( v11, f - vec2(1,1) ), u.x ), \n                 u.y)+0.5f;\n}\n\nfloat fBm (in vec2 st) \n{\n    float f = 0.0;\n    vec2 q = st + iTime * 0.05;\n\n    f += 0.5000*perlinNoise( q ); q = q*2.01;\n     f += 0.2500*perlinNoise( q ); q = q*2.02;\n    f += 0.1250*perlinNoise( q ); q = q*2.03;\n    f += 0.0625*perlinNoise( q ); q = q*2.01;\n\n    return f;\n}\n\nvec4 heightColor (in float h) {\n  if (h < SEA_LEVEL) {\n      h /= SEA_LEVEL;\n      return vec4(0.0,clamp((h-0.75)*4.0,0.0,1.0),clamp(h+0.4,0.0,1.0),1.0);\n  }\n  else {\n      h = (h - SEA_LEVEL) / (1.0 - SEA_LEVEL);\n      float r = clamp(2.5-abs(0.5-h)*7.0, 0.0, 1.0);\n      float g = clamp(1.2-abs(h-0.3)*2.0-0.3, 0.0, 1.0);\n      return vec4(r,g,0.0,1.0);\n  }\n}\n\nvec4 cracks(in vec2 U )\n{\n    vec4 O;\n    U *= MULTIPLE*0.5/iResolution.y;\n    U -= iTime*0.1;                                     // for demo\n // O = vec4( 1.-voronoiB(U).x,voronoi(U).x, 0,0 );   // for tests\n    vec2 I = floor(U/2.); \n    bool vert = mod(I.x+I.y,2.)==0.; //if (vert) U = U.yx;\n    vec3 H0;\n    O-=O;\n\n    for(float i=0.; i<CRACK_depth ; i++) {\n        vec2 V =  U / vec2(RATIO,1),                  // voronoi cell shape\n             D = CRACK_zebra_amp * fbm22(U/CRACK_zebra_scale) * CRACK_zebra_scale;\n        vec3  H = voronoiB( V + D ); if (i==0.) H0=H;\n        float d = H.x;                                // distance to cracks\n   /*         r = voronoi(V).x,                       // distance to center\n              s = STONE_height-STONE_slope*pow(r,profile);// stone interior\n    */                                                // cracks\n        d = min( 1., CRACK_slope * pow(max(0.,d-CRACK_width),CRACK_profile) );\n  \n        O += vec4(1.-d) / exp2(i);\n        U *= 1.5 * rot(.37);\n    }\n    /*\n    O = vec4( \n        FAULT==1 ? d * s                              // fault * stone\n                 : mix(1.,s, d)                       // crest or stone\n            ); */\n    //if (vert) O = 1.-O; O *= vec4(.9,.85,.85,1);      // for demo\n    \n#if MM\n    O.g = hash3(uvec3(H0.yz,1)).x;\n#endif\n    return O;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    float h = fBm(uv * MULTIPLE);\n    float c = cracks(fragCoord).x;\n    \n    h = mix(h - c*0.2, h * pow(c,3.4), 0.3);\n    \n    fragColor = heightColor(h);\n}","name":"Image","description":"","type":"image"}]}