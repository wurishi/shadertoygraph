{"ver":"0.1","info":{"id":"XsySzD","date":"1463158411","viewed":232,"name":"Voxel Beat","username":"akohdr","description":"Audio triggered voxel events.  Four beat frequencies trigger generation of traveling spherical voxel hulls.\nMotion from cellular automata in Buf A. Rotation and zoom from viewer.\n(background just happy accident of playing with HSV cycling)\n","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["sound","voxel","automata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Viewer - displays a voxel volume described by 2D tiled z-slices\n//\n\n#define FDIM vec3(15,7,105)\n#define RES iResolution.xy\n\nvec4 hsv4( vec3 c )\n{\n\treturn vec4(c.z * (1. - c.y * smoothstep(2.,1., abs( mod( c.x*6.+vec3(0,4,2), 6.) -3.) )),1);\n}\n\nvoid vignette( inout vec4 k, const in vec2 P)\n{\n\tvec2 uv = P / iResolution.xy;\n    vec2 p = (2.*uv - 1.) * (iResolution.x/iResolution.y);\n    float rf = .25 * sqrt(dot(p,p));\n    float rf2_1 = rf * rf + 1.;\n\tk *= vec4(vec3(1. / (rf2_1 * rf2_1)), 1.0);\n}\n\nvoid postProcessVoxel(inout vec4 k, const in vec3 p) \n{\n    if(k.x+k.y+k.z>0.) {\n        float l = length(p)*3.;\n        k = hsv4(vec3(l/25.,1.,1.));\n    }\n}\n\nbool isVoxel(out vec4 k, const in vec4 P)\n{\n    vec2 FRES = RES/FDIM.xy;\n    vec3 H = vec3(FRES,FDIM.z)/2.;\n    //if(any(greaterThan(abs(P.xyz),H))) return false; \t// bounds check, kills repetition \n    vec4 p = P + vec4(H.xyz,0);  \t\t\t\t\t\t// recenter volume in viewport\n\tfloat z = p.z, w = FDIM.x;\t\t\t\t\t\t\t// inlined prj4Dto2D()\n    vec2 p2 = FRES * floor(vec2(mod(z,w),z/w)) + mod(p.xy,FRES);\n\n    k = texture(iChannel0, p2/RES);\n    return k.x + k.y + k.z>0.;\t// anything but black\n}\n\nvoid mainImage(out vec4 k, vec2 P)\n{\n    float Rx = iResolution.x, Ry = iResolution.y;\n    \n    if((iMouse.z>0.) && (iMouse.y>250.)){\n        k = texture(iChannel0,P/RES); return;}  // show underlying state space\n    \n    float t = mod(iTime,20.), \n          T = 3.*sin(t/15.),\n          EYE = 70.+20.*T;\n    \n    vec2 h = vec2(0,.5),\n         u = (P - h*Ry)/Rx - h.yx;\n    vec3 v = vec3(cos(T), 1, sin(T)),\n         r = mat3(u.x,    0,   .8,\n                    0,  u.y,    0,\n                  -.8,    0,  u.x) * v,\n         o = vec3(EYE,0,-EYE)*v.zyx,\n         f = floor(o),\n         q = sign(r),\n         d = abs(length(r)/r),\n         s = d * ( q*(f-o + .5) +.5), m;\n\n    for(int i=0; i<199; i++) {\n        float a=s.x, b=s.y, c=s.z;\n        s += d*(m = vec3(a<b&&a<=c, b<c&&b<=a, c<a&&c<=b));\n        f += m*q;\n        \n        if(isVoxel(k, vec4(f, T))) {\n            k += m.x>.0 ? vec4(0) : m.y>.0 ? vec4(.6) : vec4(.3); \n            postProcessVoxel(k,f); return; }//early exit\n    }\n    k = hsv4(vec3(P.y/t*sin(P.x/30.)+cos(P.y/10.), 1.5, .6+.5*sin(T/5.)));\n\n    vignette(k,P);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// The Automata - 3D state space maintained in looped buffer of 2D tiled z-slices\n//\n#define FDIM vec3(15,7,105)\n#define RES  iResolution.xy\n#define FRES vec3(RES/FDIM.xy, FDIM.z)\n\n#define BLK vec4(.0,.0,.0,1.)\n#define RED vec4(1.,.1,.1,1.)\n#define GRN vec4(.0,1.,.0,1.)\n#define BLU vec4(.0,.0,1.,1.)\n#define YEL vec4(1.,1.,.0,1.)\n#define ANY vec4(-1)\n\n#define VX(x,y,z,K) if(length(q.xyz - vec3(x,y,z))<.5)k=K;\n\nvec2 prj4Dto2D(const in vec4 p)\n{\n    vec2 FR = FRES.xy;\n    float z = p.z, c = FDIM.x;\n    return FR * floor(vec2(mod(z,c), z/c)) + mod(p.xy, FR);\n//    return FR * floor(vec2(mod(z,c), z/c)) + mod(p.xy-vec2(.366669,0), FR);  // hmmm?!\n}\n\nvec4 prj2Dto4D(const in vec2 p)\n{\n    vec3 FR = FRES;\n    vec2 f = floor(p/FR.xy);\n    return vec4(mod(vec3(p, FDIM.x*f.y + f.x),FR), 0);//iTime);\n}\n\n// rule processing =========================================================================\n\nbool noMatch(const in vec4 p, const in float n, const in vec4 K)\n{\n    if(K==ANY) return false;\n    float s = mod(n,9.);\n    vec4 dp = floor(vec4(s/3., n/9., mod(s,3.), 1))-1.; \t// neighbor relative offset\n\n    vec4 nk = texture(iChannel0, prj4Dto2D(p+dp)/RES); \t// neighbor color\n    return nk.rgb != K.rgb;\n}\n\nvoid applyRule(const in vec4 p, const in vec4 r[28], inout vec4 k)\n{\n    // We group matches into adjacent texture lookups on same row aiming for cache hit\n    if((noMatch(p, 0., r[ 1]))||(noMatch(p, 1., r[ 2]))||(noMatch(p, 2., r[ 3]))) return;\n    if((noMatch(p, 3., r[ 4]))||(noMatch(p, 4., r[ 5]))||(noMatch(p, 5., r[ 6]))) return;\n    if((noMatch(p, 6., r[ 7]))||(noMatch(p, 7., r[ 8]))||(noMatch(p, 8., r[ 9]))) return;\n    if((noMatch(p, 9., r[10]))||(noMatch(p,10., r[11]))||(noMatch(p,11., r[12]))) return;\n    if((noMatch(p,12., r[13]))||(noMatch(p,13., r[14]))||(noMatch(p,14., r[15]))) return;\n    if((noMatch(p,15., r[16]))||(noMatch(p,16., r[17]))||(noMatch(p,17., r[18]))) return;\n    if((noMatch(p,18., r[19]))||(noMatch(p,19., r[20]))||(noMatch(p,20., r[21]))) return;\n    if((noMatch(p,21., r[22]))||(noMatch(p,22., r[23]))||(noMatch(p,23., r[24]))) return;\n    if((noMatch(p,24., r[25]))||(noMatch(p,25., r[26]))||(noMatch(p,26., r[27]))) return;\n    \n    k = r[0];\n}\n\n// mini-DSL for rule definitions ===========================================================\n#define APPLY(f) f(r);applyRule(q,r,k);\n#define RULE(n) void n(inout vec4 r[28]){clrRule(r,ANY);\n#define WHEN r[14]=\n#define OUT  r[0]=\n\nvoid clrRule(out vec4 k[28], const in vec4 K) \n{\n    k[0]=K;k[1]=K;k[2]=K;k[3]=K;k[4]=K;k[5]=K;k[6]=K;k[7]=K;k[8]=K;k[9]=K;\n    k[10]=K;k[11]=K;k[12]=K;k[13]=K;k[14]=K;k[15]=K;k[16]=K;k[17]=K;k[18]=K;k[19]=K;\n    k[20]=K;k[21]=K;k[22]=K;k[23]=K;k[24]=K;k[25]=K;k[26]=K;k[27]=K;\n}\n\n// local rules =============================================================================\n\nRULE(ruleRED)\t\t\t// rule name\n    WHEN BLK;\t\t\t// antecedent (center)\n\t OUT RED;\t\t\t// consequent (center evolution)\n    \tr[13] = RED;\t// qualifiers (optional, all must be satifisfied to evolve)\n}\n\nRULE(ruleGRN)\t\t\tWHEN BLK;\tOUT GRN;\tr[15] = GRN;}\nRULE(ruleBLU)\t\t\tWHEN BLK;\tOUT BLU;\tr[11] = BLU;}\nRULE(ruleYEL)\t\t\tWHEN BLK;\tOUT YEL;\tr[17] = YEL;}\n\nvoid applyLocalRules(inout vec4 k, const in vec4 q)\n{\n    k=BLK;\n    vec4 r[28];\n    // four rules for N S E W voxel movement\n    APPLY(ruleRED)\n    APPLY(ruleGRN)\n    APPLY(ruleBLU)\n    APPLY(ruleYEL)\n}\n\nvoid mainImage(out vec4 k, in vec2 p )\n{\n    vec4 q = prj2Dto4D(p);\t\t\t\t\t\t\t// 4D state position\n    vec2 uv = p/RES;\n    k = texture(iChannel0, uv);\t\t\t\t\t// retrieve prior state\n\n    if(length(q.xyz-FRES/2.)<iResolution.y/54.){\n        // we are on hull of sphere\n        // audio trigers coloring voxel in state space to one of four rule colors\n        // (note final screen color is product of post processing not voxel state color)\n        \n        k = BLK;\n        //TODO tune these\n        if(texture(iChannel3,vec2(.1, .9)).x>.7) k=RED;\n        if(texture(iChannel3,vec2(.65,.9)).x>.7) k=GRN;\n        if(texture(iChannel3,vec2(.45,.9)).x>.7) k=BLU;\n        if(texture(iChannel3,vec2(.95,.9)).x>.8) k=YEL;\n    }\n    else\n        // the automata provides magic to make the hulls move\n\t    applyLocalRules(k, q);\n}\n\n\n","name":"Buf A","description":"","type":"buffer"}]}