{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// FMS_Cat - Shell\n// GLSL Graphics for Tokyo Demo Fest 2015\n// 2015/02/22\n//\n// Greeting:\n//   doxas\n//   gyabo\n//   Jugem-T\n//   RTX1911\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define C vec3(.5,.1,.2)*2.\n#define ITER 72\n#define SITER 32\n\n#define tMax 40.\n#define t mod(iTime,tMax)\n#define r iResolution.xy\n#define v vec2(0.,1.)\n#define cl(i) clamp(i,0.,1.)\n#define PI 3.1415926\n\nfloat hash(vec2 _v)\n{\n  return fract(sin(dot(_v,vec2(89.44,19.36)))*229.22);\n}\n\nfloat iHash(vec2 _v,vec2 _r)\n{\n  float h00 = hash(vec2(floor(_v*_r+v.xx)/_r));\n  float h10 = hash(vec2(floor(_v*_r+v.yx)/_r));\n  float h01 = hash(vec2(floor(_v*_r+v.xy)/_r));\n  float h11 = hash(vec2(floor(_v*_r+v.yy)/_r));\n  vec2 ip = vec2(smoothstep(v.xx,v.yy,mod(_v*_r,1.)));\n  return (h00*(1.-ip.x)+h10*ip.x)*(1.-ip.y)+(h01*(1.-ip.x)+h11*ip.x)*ip.y;\n}\n\nfloat noise(vec2 _v)\n{\n  float sum = 0.;\n  for(int i=1; i<6; i++)\n  {\n    sum += iHash(_v+vec2(i),vec2(2.*pow(2.,float(i))))/pow(2.,float(i));\n  }\n  return sum;\n}\n\nfloat noiseT(vec2 _v)\n{\n  float sum = 0.;\n  for(int i=1; i<6; i++)\n  {\n    sum += iHash(_v+vec2(i)*t,vec2(2.*pow(2.,float(i))))/pow(2.,float(i));\n  }\n  return sum;\n}\n\nvec2 rotate(vec2 i,float th)\n{\n  return mat2(cos(th),-sin(th),sin(th),cos(th))*i;\n}\n\nfloat box(vec3 p,vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat box(vec3 p,float b){return box(p,vec3(b));}\n\nfloat bar(vec2 p,vec2 b)\n{\n  vec2 d=abs(p)-b;\n  return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat crossBar(vec3 p,float b)\n{\n  float da=bar(p.xy,vec2(b)),\n  db=bar(p.yz,vec2(b)),\n  dc=bar(p.zx,vec2(b));\n  return min(da,min(db,dc));\n}\n\nfloat spongePre(vec3 p)\n{\n  p.xy=rotate(p.xy,t*.23);\n  p.yz=rotate(p.yz,t*.13);\n  p.zx=rotate(p.zx,t*.43);\n  return box(p,.4);\n}\n\nvec2 sponge(vec3 p)\n{\n  p.xy=rotate(p.xy,t*.23);\n  p.yz=rotate(p.yz,t*.13);\n  p.zx=rotate(p.zx,t*.43);\n  float ret=box(p,.4);\n  vec3 pt=p;\n  for(float c=0.;c<4.;c+=1.)\n  {\n    p=pt;\n    float h0=pow(1.17+hash(floor(t/5.+361.)*v.yy),c*.5);\n    float h1=pow(1.17+hash(ceil(t/5.+361.)*v.yy),c*.5);\n    float pw=h1+exp(-mod(t,5.)*12.)*(h0-h1);\n    ret=max(ret,-crossBar(mod(p+.15/pw,.6/pw)-.15/pw,.1/pw));\n  }\n  return vec2(ret,0.);\n}\n\nvec2 oil(vec3 p)\n{\n  return vec2(p.y+.9,1.);\n}\n\nvec2 flo(vec3 p)\n{\n  return vec2(max(p.y+.7,.8-length(p.xz)),2.);\n}\n\nvec2 pole(vec3 p)\n{\n  return vec2(length(mod(p.xz,4.)-2.)-.3,2.);\n}\n\n#define check if(disC.x<dis.x){dis=disC;}\nvec2 distFunc(vec3 p)\n{\n  vec2 dis=spongePre(p)*v.yx;\n  if(dis.x<.1)\n  {\n    dis=sponge(p);\n  }\n  vec2 disC=oil(p);check;\n  disC=flo(p);check;\n  disC=pole(p);check;\n  return dis;\n}\n\nvec2 tube(vec3 p)\n{\n  vec2 dis=vec2(max(length(p.xz)-.8,-p.y-.7),0.);\n  vec2 disC=pole(p);check;\n  return dis;\n}\n\nvec3 getNormal(vec3 p,float d)\n{\n  return normalize(vec3(\n    distFunc(p+vec3(d,0.,0.)).x-distFunc(p+vec3(-d,0.,0.)).x,\n    distFunc(p+vec3(0.,d,0.)).x-distFunc(p+vec3(0.,-d,0.)).x,\n    distFunc(p+vec3(0.,0.,d)).x-distFunc(p+vec3(0.,0.,-d)).x\n    ));\n}\n\nfloat shadow(vec3 _ray,vec3 _lig,float k)\n{\n  vec3 ray=normalize(_lig-_ray);\n  float maxL=length(_lig-_ray);\n  float ret=1.;\n  float dist=0.;\n  float rayL=0.;\n  vec3 rayP=_ray;\n  for(int c=0;c<SITER;c++)\n  {\n    float dist=distFunc(rayP).x;\n    if(dist<1E-4){return 0.;}\n    rayL+=dist;\n    rayP=_ray+ray*rayL;\n    ret=min(ret,dist*k/rayL);\n    if(maxL<rayL){return ret;}\n  }\n  return 0.;\n}\n\nvec3 shadeBox(vec3 rayP,vec3 camP)\n{\n  vec3 col=v.xxx;\n\n  vec3 nor=getNormal(rayP,1E-4);\n\n  vec3 lig=v.xxx;\n  float dif=cl(dot(normalize(lig-rayP),nor))*.3;\n  float sha=shadow(rayP+1E-2*nor,lig,3E1);\n  float dec=exp(-length(lig-rayP)*.1);\n  col+=(dif*(sha*.5+.5)*dec*v.yyy)*C;\n\n  float edge=pow(cl((1.-dot(nor,getNormal(rayP,6E-3)))*8.+.1),14.)*(.01+floor(cl(1.-abs(mod(t/5.,1.)-length(rayP))*12.)*2.)*.4);\n  col+=edge*C;\n\n  return col;\n}\n\nvec3 shadeOil(vec3 rayP,vec3 camP)\n{\n  vec3 col=v.xxx;\n\n  vec3 nor=v.xyx;\n  nor.x+=(noiseT(rayP.xz*11.)-.5)*3.;\n  nor.z+=(noiseT(rayP.xz*11.+v.yy*29.)-.5)*3.;\n  nor=normalize(nor);\n\n  vec3 lig=v.xxx;\n  float sha=shadow(rayP+1E-2*nor,lig,3E1);\n  float spe=cl(pow(dot(normalize(normalize(lig-rayP)+normalize(camP-rayP)),nor)*1.02,3E2));\n  col+=spe*(sha*.9+.1)*C;\n\n  return col;\n}\n\nvec3 shadeFloor(vec3 rayP,vec3 camP)\n{\n  vec3 col=v.xxx;\n\n  vec3 nor=getNormal(rayP,1E-4);\n\n  vec3 lig=v.xxx;\n  float sha=shadow(rayP+1E-2*nor,lig,3E1);\n  float dif=cl(dot(normalize(lig-rayP),nor));\n  float spe=cl(pow(dot(normalize(normalize(lig-rayP)+normalize(camP-rayP)),nor),3E2));\n  float dec=exp(-length(lig-rayP)*.1);\n  col+=((dif*(sha*.7+.3))*v.yyy*dec+spe*sha*dec)*C;\n\n  float edge=cl(1.-abs(.3-rayP.y)*70.)*3.;\n  col+=edge*C;\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p=(fragCoord.xy*2.-r)/r.x;\n  p.x+=((hash(floor(p.yy*100.))-.5))*exp(-t*.8)*.4; // first horizontal glitch\n  p.x+=hash(vec2(p.y,t*8.))*exp(-(tMax-t))*.2; // last horizontal noise\n\n  float camR=4.+exp(-t*.4)*10.;\n  if(8.<t){ camR-=(1.-exp(-(t-8.)*5.))*2.; }\n\n  float camT=t*.1+.3;\n  if(8.<t){ camT+=(1.-exp(-(t-8.)*5.))*.4; }\n\n  vec3 camP=vec3(cos(camT),.1,sin(camT))*camR;\n  vec3 camC=vec3(0.,-.2,0.);\n  vec3 camA=vec3(0.,1.,0.);\n  vec3 camS=cross(normalize(camC-camP),camA);\n  vec3 camU=cross(camS,normalize(camC-camP));\n  vec3 ray=normalize(camS*p.x+camU*p.y+normalize(camC-camP));\n\n  vec2 dist=v.xx;\n  float rayL=0.;\n  vec3 rayP=camP;\n  for(int i=0;i<ITER;i++)\n  {\n    dist=distFunc(rayP);\n    rayL+=dist.x*.95;\n    if(length(camP)*10.<rayL){ break; }\n    rayP=camP+ray*rayL;\n  }\n\n  vec3 col=v.xxx;\n\n  if(abs(dist.x)<1E-3)\n  {\n    float dis=1.6/clamp(rayL,1.8,99.);\n    if(dist.y==0.)\n    {\n      col+=shadeBox(rayP,camP);\n    }\n    else if(dist.y==1.)\n    {\n      col+=shadeOil(rayP,camP);\n    }\n    else if(dist.y==2.)\n    {\n      col+=shadeFloor(rayP,camP);\n    }\n  }\n\n  col+=cl(1.-(abs(min(rayL,length(camP))-length(camP))*10.))*pow(cl(dot(-ray,normalize(camP))),1E3*length(camP))*(C+v.yyy);\n\n  if(.8<length(camP.xz))\n  {\n    rayL=0.;\n    rayP=camP;\n    for(int i=0;i<ITER;i++)\n    {\n      dist=tube(rayP);\n      rayL+=dist.x;\n      if(length(camP)*2.<rayL){ break; }\n      rayP=camP+ray*rayL;\n    }\n\n    if(dist.x<1E-3&&dist.y==0.)\n    {\n      col+=(C+v.yyy)*max(.2-rayP.y*.1,.05)*.2;\n\n      vec3 lig=v.xxx;\n      float sha=shadow(rayP,lig,3E1);\n      float dec=exp(-length(lig-rayP)*.1);\n      col+=.03*sha*dec*C;\n    }\n  }\n\n  col+=shadow(camP+ray*.1,v.xxx,3E1)*exp(-length(camP)*.1)*C*.4;\n\n  col=cl(cl(col+sin(p.y*500.+t*10.)*.003)*5.*exp(-length(p)*2.))-exp(-t*.8)-exp(-(tMax-t));\n\n  fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlX3DS","date":"1424622303","viewed":1648,"name":"[TDF15]Shell","username":"FMS_Cat","description":"GLSL Graphics for Tokyo Demo Fest 2015\nraymarching\nmenger sponge mutation II","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal"],"hasliked":0,"parentid":"","parentname":""}}