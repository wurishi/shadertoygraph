{"ver":"0.1","info":{"id":"ltyyDd","date":"1538557831","viewed":1426,"name":"Anisotropic Kuwahara v3","username":"kam19_77","description":"Anisotropic Kuwahara v3 by Jan Eric Kyprianidis","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int N = 8;\nconst float HALF_SQRT2 = 0.7071067811865475244f;\n\nconst float radius = 4.0;\nconst float alpha = 1.0;\nconst float q = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord/src_size;\n\n    vec4 t = texture(iChannel1, uv);\n    float a = radius * clamp((alpha + t.w) / alpha, 0.1, 2.0); \n    float b = radius * clamp(alpha / (alpha + t.w), 0.1, 2.0);\n\n    float cos_phi = cos(t.z);\n    float sin_phi = sin(t.z);\n\n    mat2 SR = mat2(cos_phi/a, -sin_phi/b, sin_phi/a, cos_phi/b);\n    \n    float aa = a * a;\n\tfloat bb = b * b;\n\tfloat coscos_phi = cos_phi * cos_phi;\n\tfloat sinsin_phi = sin_phi * sin_phi;\n\t\n\tint max_x = int(sqrt(aa * coscos_phi + bb * sinsin_phi));\n\tint max_y = int(sqrt(aa * sinsin_phi + bb * coscos_phi));\n\n    \n    vec4 m[8];\n    vec3 s[8];\n    {\n    \tvec3 c = texture(iChannel0, uv).rgb;\n        float w = 1.0f / float(N);\n        for (int k = 0; k < N; ++k) {\n            m[k] =  vec4(c * w, w);\n            s[k] = c * c * w;\n        }\n    }\n\n    for (int j = 0; j <= max_y; ++j)  {\n        for (int i = -max_x; i <= max_x; ++i) {\n            if ((j !=0) || (i > 0)) {\n                vec2 v = SR * vec2(i,j);\n                \n                float dotv = dot(v,v);\n\n                if (dotv <= 1.0f) {\n                    vec3 c0 = texture(iChannel0, uv + vec2(i,j)/src_size).rgb;\n                    vec3 c1 = texture(iChannel0, uv - vec2(i,j)/src_size).rgb;\n\n                    vec3 cc0 = c0 * c0;\n                    vec3 cc1 = c1 * c1;\n\n                    float sum = 0.0f;\n\t\t\t\t\tfloat w[8];\n\t\t\t\t\tfloat z, vxx, vyy;\n\t\t\t\t\t\n\t\t\t\t\tvxx = 0.33f - 3.77f * v.x * v.x;\n\t\t\t\t\tvyy = 0.33f - 3.77f * v.y * v.y;\n\t\t\t\t\tz = max(0.0f,  v.y + vxx); sum += w[0] = z * z;\n\t\t\t\t\tz = max(0.0f, -v.x + vyy); sum += w[2] = z * z;\n\t\t\t\t\tz = max(0.0f, -v.y + vxx); sum += w[4] = z * z;\n\t\t\t\t\tz = max(0.0f,  v.x + vyy); sum += w[6] = z * z;\n\n\t\t\t\t\tv = HALF_SQRT2 * vec2( v.x - v.y, v.x + v.y );\n\n\t\t\t\t\tvxx = 0.33f - 3.77f * v.x * v.x;\n\t\t\t\t\tvyy = 0.33f - 3.77f * v.y * v.y;\n\t\t\t\t\tz = max(0.0f,  v.y + vxx); sum += w[1] = z * z;\n\t\t\t\t\tz = max(0.0f, -v.x + vyy); sum += w[3] = z * z;\n\t\t\t\t\tz = max(0.0f, -v.y + vxx); sum += w[5] = z * z;\n\t\t\t\t\tz = max(0.0f,  v.x + vyy); sum += w[7] = z * z;\n\n\t\t\t\t\tfloat g = exp(-3.125f * dotv) / sum;\n\t\t\t\t\t\n\t\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\t\tfloat wk = w[k] * g;\n\t\t\t\t\t\tm[k] += vec4(c0 * wk, wk);\n\t\t\t\t\t\ts[k] += cc0 * wk;\n\t\t\t\t\t\tm[(k+4)&7] += vec4(c1 * wk, wk);\n\t\t\t\t\t\ts[(k+4)&7] += cc1 * wk;\n\t\t\t\t\t}\n                }\n            }\n        }\n    }\n    \n    \n    vec4 o = vec4(0.0);\n    for (int k = 0; k < N; ++k) {\n        m[k].rgb /= m[k].w;\n        s[k] = abs(s[k] / m[k].w - m[k].rgb * m[k].rgb);\n\n        float sigma2 = s[k].r + s[k].g + s[k].b;\n        float w = 1.0 / (1.0 + pow(255.0 * sigma2, 0.5 * q));\n\n        o += vec4(m[k].rgb * w, w);\n    }\n\n    fragColor = vec4(o.rgb / o.w, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord/src_size;\n    vec2 d = 1.0 / src_size;\n\n    vec3 c = texture(iChannel0, uv).xyz;\n    vec3 u = (\n           -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)).xyz +\n           -2.0 * texture(iChannel0, uv + vec2(-d.x,  0.0)).xyz + \n           -1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)).xyz +\n           +1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)).xyz +\n           +2.0 * texture(iChannel0, uv + vec2( d.x,  0.0)).xyz + \n           +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y)).xyz\n           ) / 4.0;\n\n    vec3 v = (\n           -1.0 * texture(iChannel0, uv + vec2(-d.x, -d.y)).xyz + \n           -2.0 * texture(iChannel0, uv + vec2( 0.0, -d.y)).xyz + \n           -1.0 * texture(iChannel0, uv + vec2( d.x, -d.y)).xyz +\n           +1.0 * texture(iChannel0, uv + vec2(-d.x,  d.y)).xyz +\n           +2.0 * texture(iChannel0, uv + vec2( 0.0,  d.y)).xyz + \n           +1.0 * texture(iChannel0, uv + vec2( d.x,  d.y)).xyz\n           ) / 4.0;\n    \n    vec3 col = vec3(dot(u, u), dot(v, v), dot(u, v));\n    //col = floor(col * 255.0) / 255.0;\t// denoise\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define DEBUG_VIEW_STRUCTURE_TENSOR\t\t0\n#define SMOOTHED_STRUCTURE_TENSOR\t\t1\n\nconst float sigma = 2.5;\n    \nvec3 gauss (vec2 uv, vec2 src_size, float sigma) {\n#if SMOOTHED_STRUCTURE_TENSOR\n    float twoSigma2 = 2.0 * sigma * sigma;\n    int halfWidth = int(ceil( 2.0 * sigma ));\n    \n    vec3 sum = vec3(0.0);\n    float norm = 0.0;\n    if (halfWidth > 0) {\n        for ( int i = -halfWidth; i <= halfWidth; ++i ) {\n            for ( int j = -halfWidth; j <= halfWidth; ++j ) {\n                float d = length(vec2(i,j));\n                float kernel = exp( -d *d / twoSigma2 );\n                vec3 c = texture(iChannel0, uv + vec2(i,j) / src_size ).rgb;\n                sum += kernel * c;\n                norm += kernel;\n            }\n        }\n    } else {\n        sum = texture(iChannel0, uv).rgb;\n        norm = 1.0;\n    }\n    return sum / norm;\n#else\n    return texture(iChannel0, uv).rgb;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 src_size = iResolution.xy;\n    vec2 uv = fragCoord / src_size;\n\n#if DEBUG_VIEW_STRUCTURE_TENSOR\n    fragColor = vec4(gauss(uv, src_size, sigma), 1.0);\n#else\t// DEBUG_VIEW_STRUCTURE_TENSOR\n    vec3 g = gauss(uv, src_size, sigma).xyz;\n\n    float lambda1 = 0.5 * (g.y + g.x +\n        sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n    float lambda2 = 0.5 * (g.y + g.x -\n        sqrt(g.y*g.y - 2.0*g.x*g.y + g.x*g.x + 4.0*g.z*g.z));\n\n    vec2 v = vec2(lambda1 - g.x, -g.z);\n    vec2 t;\n    if (length(v) > 0.0) { \n        t = normalize(v);\n    } else {\n        t = vec2(0.0, 1.0);\n    }\n\n    float phi = atan(t.y, t.x);\n\n    float A = (lambda1 + lambda2 > 0.0)?\n        (lambda1 - lambda2) / (lambda1 + lambda2) : 0.0;\n\n    fragColor = vec4(t, phi, A);\n#endif\t// DEBUG_VIEW_STRUCTURE_TENSOR\n}","name":"Buffer B","description":"","type":"buffer"}]}