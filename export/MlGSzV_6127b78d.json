{"ver":"0.1","info":{"id":"MlGSzV","date":"1489866446","viewed":984,"name":"Deus ex machina","username":"nimitz","description":"The initial state is simply a constant value for the whole domain, this specific version takes about 15 minutes to reach a \"stable\" state.","likes":58,"published":1,"flags":32,"usePreview":0,"tags":["cellularautomata","mechanical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Deus ex machina by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/MlGSzV\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tBase idea inspired by numberphile's \"Sandpiles\" video\n\thttps://www.youtube.com/watch?v=1MtEUErz7Gg\n\n\tSome of the main differences are that the numbers are encoded as\n\tfloating point, that the \"piles\" have 8 neighbors and that the values\n\tare clamped\n\n\tThe initial condition is just a completely uniform plane, all the\n\tcomplexity is created from the rule itself (and the boundary conditions)\n\n\tUnrelated: Am I the only one who gets very noticeable rendering speed variation\n\twith this shader? (this began when shadertoy moved to WebGL 2.0) It tends to oscillate\n\tbetween 30 fps and 60 fps\n*/\n\n#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = q-0.5;\n    float r = sqrt(length(p));\n    p *= .91 + r*0.11;\n    q = p+0.5;\n    \n    vec4 tex = texture(iChannel0, q);\n    \n    float rz = tex.x;\n    \n    vec3 col = sin(vec3(1,2,3) + rz +0.)*0.5+0.5;\n    \n    col = tex.yzw;\n    col = clamp(col,0.,1.);\n    \n    vec2 p2 = p*=1.85;\n    p2*=p2; p2*=p2; p2*=p2;\n    col *= 1.2-pow(length(p2)*1.3,.4);\n    col = clamp(col,0.,1.);\n    \n    col = pow(col, vec3(.8));\n    col = smoothstep(0.,1.,col);\n    col *= smoothstep(-1.,-0.9, sin(gl_FragCoord.y*3.14159265*.5 + 0.5))*0.1+1.;\n    col *= smoothstep(-1.,-0.9, sin(gl_FragCoord.x*3.14159265*.5 + 0.5))*0.1+1.;\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Deus ex machina by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define time iTime\n\n#define DROP_VAL 4.05\n#define SUB_OFFSET 0.0238321\n#define CLAMP_MAX 8.1\n\n//Main rule\nfloat spread(in ivec2 p, float h)\n{\n    //vec2 w = 1./iResolution.xy;\n    \n    vec4 texN = texelFetch(iChannel0, p + ivec2(0,1), 0);\n    vec4 texS = texelFetch(iChannel0, p + ivec2(0,-1), 0);\n    vec4 texE = texelFetch(iChannel0, p + ivec2(1, 0), 0);\n    vec4 texW = texelFetch(iChannel0, p + ivec2(-1, 0), 0);\n    \n    vec4 texNE = texelFetch(iChannel0, p + ivec2(1,1), 0);\n    vec4 texNW = texelFetch(iChannel0, p + ivec2(-1,1), 0);\n    vec4 texSE = texelFetch(iChannel0, p + ivec2(1,-1), 0);\n    vec4 texSW = texelFetch(iChannel0, p + ivec2(-1,-1), 0);\n    \n    texE *= step(gl_FragCoord.x+1., iResolution.x);\n    texW *= step(0., gl_FragCoord.x-1.);\n    texN *= step(0., gl_FragCoord.y-1.);\n    texS *= step(gl_FragCoord.y+1., iResolution.y);\n \n#if 1\n    //still works without all boundaries\n    texNE *= step(gl_FragCoord.x+1., iResolution.x)*step(0., gl_FragCoord.y-1.);\n    texSE *= step(gl_FragCoord.x+1., iResolution.x)*step(gl_FragCoord.y+1., iResolution.y);\n    texSW *= step(0., gl_FragCoord.x-1.)*step(gl_FragCoord.y+1., iResolution.y);\n    texNW *= step(0., gl_FragCoord.x-1.)*step(0., gl_FragCoord.y-1.);\n#endif\n    \n    if (h > DROP_VAL) h -= 8.0 - SUB_OFFSET;\n    \n    if (texN.x > DROP_VAL) h += 1.0;\n    if (texS.x > DROP_VAL) h += 1.0;\n    if (texE.x > DROP_VAL) h += 1.0;\n    if (texW.x > DROP_VAL) h += 1.0;\n    if (texNE.x > DROP_VAL) h += 1.0;\n    if (texNW.x > DROP_VAL) h += 1.0;\n    if (texSE.x > DROP_VAL) h += 1.0;\n    if (texSW.x > DROP_VAL) h += 1.0;\n    \n    h = clamp(h, 0.0, CLAMP_MAX);\n    \n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    \n    //vec4 tex = texture(iChannel0, q);\n    vec4 tex = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    float height = spread(ivec2(fragCoord.xy), tex.x);\n\n    if (iFrame < 10)\n  \t\theight = DROP_VAL + 0.1;\n    \n    float v = 4.0*step(sin(time*0.07),0.);\n    \n    #if 1\n    vec3 col = sin(vec3(.85,2.,3.)-vec3(-v*.98,v*.5,v*.8)*1.32 - v*1. + height + fract(height*7.0)*0.3)*0.4+0.4;\n    #else\n    vec3 col = sin(vec3(1.7,1.4,.8)*1.1-vec3(-v*.8,v*.56,-v*3.)*1.32 - v*0.18 + height + fract(height*7.0)*0.3)*0.45+0.4;\n    #endif\n    \n    col = mix(col, tex.yzw, 0.5);\n    \n    fragColor = vec4(height, col);\n}","name":"Buffer A","description":"","type":"buffer"}]}