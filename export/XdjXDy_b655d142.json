{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const float pi = 3.1415927;\n\n//From Dave (https://www.shadertoy.com/view/XlfGWN)\nfloat hash13(vec3 p){\n\tp  = fract(p * vec3(.16532,.17369,.15787));\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\nfloat hash(float x){ return fract(cos(x*124.123)*412.0); }\nfloat hash(vec2 x){ return fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); }\nfloat hash(vec3 x){ return fract(cos(dot(x.xyz,vec3(2.31,53.21,17.7))*124.123)*412.0); }\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pp = fragCoord.xy/iResolution.xy;\n\tpp = -1.0 + 2.0*pp;\n\tpp.x *= iResolution.x/iResolution.y;\n\n\tvec3 lookAt = vec3(0.0, -0.1, 0.0);\n    \n    float eyer = 2.0;\n    float eyea = (iMouse.x / iResolution.x) * pi * 2.0;\n    float eyea2 = ((iMouse.y / iResolution.y)-0.24) * pi * 2.0;\n    \n\tvec3 ro = vec3(\n        eyer * cos(eyea) * sin(eyea2),\n       eyer * cos(eyea2),\n        eyer * sin(eyea) * sin(eyea2)); //camera position\n    \n    \n\tvec3 front = normalize(lookAt - ro);\n\tvec3 left = normalize(cross(normalize(vec3(0.0,1,-0.1)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 rd = normalize(front*1.5 + left*pp.x + up*pp.y); // rect vector\n    \n    \n    vec3 bh = vec3(0.0,0.0,0.0);\n    float bhr = 0.3;\n    float bhmass = 5.0;\n   \tbhmass *= 0.001; // premul G\n    \n    vec3 p = ro;\n    vec3 pv = rd;\n    \n    p += pv * hash13(rd + vec3(iTime)) * 0.02;\n    \n    float dt = 0.02;\n    \n    vec3 col = vec3(0.0);\n    \n    float noncaptured = 1.0;\n    \n    vec3 c1 = vec3(0.5,0.35,0.1);\n    vec3 c2 = vec3(1.0,0.8,0.6);\n    \n    \n    for(float t=0.0;t<1.0;t+=0.005)\n    {\n        p += pv * dt * noncaptured;\n        \n        // gravity\n        vec3 bhv = bh - p;\n        float r = dot(bhv,bhv);\n        pv += normalize(bhv) * ((bhmass) / r);\n        \n        noncaptured = smoothstep(0.0,0.01,sdSphere(p-bh,bhr));\n        \n        \n        \n        // texture the disc\n        // need polar coordinates of xz plane\n        float dr = length(bhv.xz);\n        float da = atan(bhv.x,bhv.z);\n        vec2 ra = vec2(dr,da * (0.01 + (dr - bhr)*0.002) + 2.0 * pi + iTime*0.02 );\n        ra *= vec2(10.0,20.0);\n        \n        vec3 dcol = mix(c2,c1,pow(length(bhv)-bhr,2.0)) * max(0.0,texture(iChannel1,ra*vec2(0.1,0.5)).r+0.05) * (4.0 / ((0.001+(length(bhv) - bhr)*50.0) ));\n        \n        col += max(vec3(0.0),dcol * step(0.0,-sdTorus( (p * vec3(1.0,50.0,1.0)) - bh, vec2(0.8,0.99))) * noncaptured);\n        \n        //col += dcol * (1.0/dr) * noncaptured * 0.01;\n        \n        // glow\n        col += vec3(1.0,0.9,0.7) * (1.0/vec3(dot(bhv,bhv))) * 0.003 * noncaptured;\n        \n        //if (noncaptured<1.0) break;\n        \n    }\n    \n    // background - projection not right\n    //col += pow(texture(iChannel0,pv.xy+vec2(1.5)).rgb,vec3(3.0));\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdjXDy","date":"1415613005","viewed":12943,"name":"BlackHole","username":"bloodnok","description":"Attempting a raymarched approximation to the black hole rendering as used in Interstellar. Naive raymarch, but with gravity bending the ray. Simple model, doesn't take into account GR / frame dragging / redshift.","likes":118,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarch"],"hasliked":0,"parentid":"","parentname":""}}