{"ver":"0.1","info":{"id":"4sjBzd","date":"1501746004","viewed":85,"name":"36.0137","username":"etrepum","description":"Fig logo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["static"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n\n// http://blackpawn.com/texts/pointinpoly/\nfloat pointInTriangle( in vec2 p, in vec2 a, in vec2 b, in vec2 c ) {\n    vec2 v0 = c - a;\n    vec2 v1 = b - a;\n    vec2 v2 = p - a;\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n\tfloat u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\tfloat v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\t// Check if point is in triangle\n    return (1.0 - step(1.0, u + v)) * step(0.0, u) * step(0.0, v);\n    // Interestingly this doesn't appear to work on my MBP's NVIDIA GeForce GT 750M,\n    // but it worked on my PC's 1080 Ti.\n    /*\n    if ((u >= 0.0) && (v >= 0.0) && (u + v < 1.0))\n    {\n        return 1.0;\n    }\n    return 0.0;\n    */\n}\n\nfloat figLogo( in vec2 uv, in vec2 c, float dt )\n{\n    float rSmall = 0.044;\n    float rMed = 0.17;\n    float rBig = 0.40;\n\tfloat tBig = 0.25;\n    float inside = max(\n        1.0 - step(rBig, distance(uv, c)),\n        pointInTriangle(\n            uv,\n            vec2(c.x, 1.0),\n            c + rBig * vec2(cos(M_PI * (0.5 - tBig)), sin(M_PI * (0.5 - tBig))),\n            c + rBig * vec2(cos(M_PI * (0.5 + tBig)), sin(M_PI * (0.5 + tBig)))\n        )\n    );\n    inside *= step(rSmall, distance(uv, c));\n    for (float i = 0.0; i < 6.0; i += 1.0)\n    {\n        float theta = dt + (0.25 + i / 6.0) * 2.0 * M_PI;\n        inside *= step(rSmall, distance(uv, c + rMed * vec2(cos(theta), sin(theta))));\n    }\n    return inside;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = min(iResolution.x, iResolution.y);\n    float w = 0.8 * h;\n    vec2 c = 0.5 * vec2(iResolution.x, w);\n    float t = iTime;\n\tfragColor = mix(\n        vec4(1.0),\n        vec4(132.0/255.0, 80.0/255.0, 224.0/255.0, 1.0),\n        figLogo( fragCoord / h, c / h, sin(t * 0.015) * sin(t * 0.1) * M_PI )\n    );\n}","name":"Image","description":"","type":"image"}]}