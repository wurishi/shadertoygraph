{"ver":"0.1","info":{"id":"DdGGWK","date":"1679025875","viewed":81,"name":"Portable macro ray-marcher!","username":"ianertson","description":"The idea is to be able to define your\n scene in a more declarative manner, and\n  \"hide\" the ugly parts so that you can focus\n  on the scene you're creating.\n\nAnd as always, use the mouse to look around :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching","ray","rays","marching","raymarcher","portable","portableraymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n        PORTABLE RAY-MARCHER!\n-------------------------------------------\n        It's all in a macro :)\n        \n        ----------------------\n        \n    The idea is to be able to define your\n    scene in a more declarative manner, and\n    \"hide\" the ugly parts so that you can focus\n    on the scene you're creating.\n**/\n\n#define ID_GROUND 0\n#define ID_BOX 1\n#define ID_TORUS 2\n\nMARCHER(  \n    // Scene\n    {\n        float ground = groundSDF(p);\n        SAMPLE(ground, ID_GROUND);\n\n        float box = boxSDF(p - vec3(0, 1, 0), vec3(1.0)) - 0.016;\n        SAMPLE(box, ID_BOX);\n        \n        float torus = torusSDF(p - vec3(0, 2.05 + (0.5+(0.5*sin(T))), 0), 0.5, 0.05);\n        SAMPLE(torus, ID_TORUS);\n    },\n    // Textures    \n    {\n        case ID_GROUND: return texture(iChannel3, uv).rgb; break;\n        case ID_BOX: return texture(iChannel2, uv).rgb; break;\n        case ID_TORUS: return texture(iChannel1, uv).rgb; break;\n    },\n    // Setup lights\n    Light[3](\n        Light(vec3(1, 2, -3), vec3(0.0), COLOR_SUN, 0.5, LIGHT_AMBIENT),\n        Light(vec3(cos(T*2.)*4., 2.5, sin(T*2.)*4.), vec3(0.0), vec3(0.2, 0.9, 0.1), 4.0, LIGHT_POINT),\n        Light(vec3(0, 10, 0), normalize(vec3(sin(T)*0.5, -1., cos(T)*0.5)), vec3(0.1, 0.2, 0.9), 2.0, LIGHT_DIR)\n    ),\n    // How many lights\n    3\n)\n\nvoid mainImage( out vec4 O, in vec2 fc ) { O = blit(fc); }","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.05\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n#define ID_NONE -1\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, NEW_MATERIAL)\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\n#define MARCHER(SDF_FUN, TEX_LOOKUP, LIGHTS, NUM_LIGHTS)\\\n    mat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\\\n    float luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\\\n    vec3 aces(vec3 x) { return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\\\n    struct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\\\n    struct Data {\\\n        vec3 p;\\\n        vec3 n;\\\n        float d;\\\n        int skip;\\\n        int id;\\\n        Material m;\\\n    };\\\n    \\\n    struct Ray {\\\n        vec3 ro;\\\n        vec3 rd;\\\n    };\\\n    \\\n    \\\n    struct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\\\n    \\\n    vec3 getLightDir(in Light light, in vec3 p) {\\\n        return light.type == LIGHT_AMBIENT ? normalize(light.p) :\\\n               light.type == LIGHT_POINT ? normalize(light.p - p) :\\\n               normalize(-light.d);\\\n    }\\\n    \\\n    vec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\\\n        vec3 L = getLightDir(light, p);\\\n        float NdotL = max(AMBIENT, dot(n, L));\\\n        \\\n        switch (light.type) {\\\n            case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\\\n            case LIGHT_POINT: return light.c * NdotL * (\\\n                pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\\\n            ); break;\\\n            case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\\\n                normalize(light.p - p),\\\n                L\\\n            )); break;\\\n        }\\\n        \\\n        return vec3(0.0);\\\n    }\\\n    vec2 boxUv(in vec3 p, in vec3 n) {\\\n        return mix(mix(p.xy, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\\\n    }\\\n    \\\n    vec2 sphereUv(in vec3 p) {\\\n        float u = acos(p.y);\\\n        float v = atan(p.x, p.z);\\\n        \\\n        u = 0.5 - u / M_PI;\\\n        v = 0.5 + v / M_PI;\\\n        return vec2(u, v);\\\n    }\\\n    float sphereSDF(in vec3 p, in float r) {\\\n        return length(p) - r;\\\n    }\\\n    \\\n    float boxSDF(in vec3 p, in vec3 s) {\\\n        p = abs(p) - s;\\\n        return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\\\n    }\\\n    \\\n    float lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\\\n        vec3 pa = p - a;\\\n        vec3 ba = b - a;\\\n        return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\\\n    }\\\n    \\\n    float cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\\\n        vec3 ab = b - a;\\\n        vec3 ap = p - a;\\\n        float t = dot(ab, ap) / dot(ab, ab);\\\n        vec3 c = a + t * ab;\\\n        float x = length(p - c) - r;\\\n        float y = (abs(t - 0.5) - 0.5) * length(ab);\\\n        float e = length(max(vec2(x, y), 0.0));\\\n        float i = min(max(x, y), 0.0);\\\n        return e + i;\\\n    }\\\n    \\\n    float torusSDF(in vec3 p, in float r1, float r2) {\\\n        p = p.yzx;\\\n        float ll = length(p.yz)-r1;\\\n        return length(vec2(ll,p.x))-r2;\\\n    }\\\n    \\\n    float groundSDF(in vec3 p) {\\\n        return p.y;\\\n    }\\\n    float sdf(inout Data data, in vec3 p) {\\\n        int skip = data.skip;\\\n        int id = ID_NONE;\\\n        float dist = FAR;\\\n        SDF_FUN\\\n        data.id = id;\\\n        return dist;\\\n    }\\\n    \\\n    bool march(inout Data data, in vec3 ro, in vec3 rd) {\\\n        float d = 0.0;\\\n        for (int i = ZERO; i < STEPS; i++) {\\\n            vec3 p = ro+rd*d;\\\n            float next = sdf(data, p);\\\n            d += next;\\\n            if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\\\n            if (abs(d) >= FAR) return false;\\\n        }\\\n        \\\n        vec3 p = ro+rd*d;\\\n        vec2 e = vec2(NORMAL_RANGE, 0.0);\\\n        vec3 n = normalize(sdf(data, p) - vec3(\\\n            sdf(data, p - e.xyy),\\\n            sdf(data, p - e.yxy),\\\n            sdf(data, p - e.yyx)\\\n        ));\\\n        \\\n        data.d = d;\\\n        data.p = p;\\\n        data.n = n;\\\n        \\\n        return true;\\\n    }\\\n    \\\n    float getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float far, in int skip) {\\\n        float NdotL = cdot(n, rd);\\\n        if (NdotL <= SHADOW_NDOTL_EPSILON) return 1.0;\\\n        \\\n        Data data = NEW_DATA;\\\n        data.skip = skip;\\\n        \\\n        float d = 0.0;\\\n        float r = 1.0;\\\n        for (int i = ZERO; i < SHADOW_STEPS; i++) {\\\n            vec3 p = ro+rd*d;\\\n            float next = sdf(data, p);\\\n            r = min(r, next/0.44);\\\n            d += next*0.13;\\\n            if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\\\n            if (abs(d) >= far) break;\\\n        }\\\n        \\\n        return clamp(r + 0.77*(d / (1.0 + d)), AMBIENT, 1.0);\\\n    }\\\n    \\\n    Ray getRay(in vec2 uv, in vec4 m) {\\\n        vec3 ro = vec3(0, 0, -6.0);\\\n        vec3 rd = normalize(vec3(uv.xy, 1.0));\\\n        \\\n        if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\\\n            ro.yz *= rot(m.y*TAU);\\\n            ro.xz *= rot(m.x*TAU);\\\n            \\\n            rd.yz *= rot(m.y*TAU);\\\n            rd.xz *= rot(m.x*TAU);\\\n        } else {\\\n            rd.yz *= rot(radians(-20.));\\\n            rd.xz *= rot((T+0.231244)*0.7);\\\n            ro.xz *= rot((T+0.231244)*0.7);\\\n            ro.y += 1.;\\\n        }\\\n        ro.y += 2.;\\\n        ro.y = max(0.6, ro.y);\\\n        \\\n        return Ray(ro, rd);\\\n    }\\\n    vec3 getAlbedo(inout Data data) {\\\n        vec2 uv = boxUv(data.p, data.n);\\\n        switch (data.id) \\\n            TEX_LOOKUP\\\n        \\\n        \\\n        return vec3(0.77);\\\n    }\\\n    \\\n    vec3 getSky(in vec3 rd) {\\\n        float dotup = cdot(rd, vec3(0, 1, 0));\\\n        vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\\\n        return col;\\\n    }\\\n    \\\n    vec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\\\n        vec3 p = data.p;\\\n        vec3 n = data.n;\\\n        vec3 L = getLightDir(light, p);\\\n        vec3 ref = reflect(L, n);\\\n        float VdotR = cdot(rd, ref);\\\n        float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\\\n        vec3 att = getLightAtt(light, p, n);\\\n        float shadow = getShadow(p + (n*NEAR*2.0), L, n, light.type == LIGHT_AMBIENT ? FAR :\\\n            distance(light.p, p), data.id);\\\n            \\\n        return (diffuse + spec) * att * shadow; \\\n    }\\\n    vec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\\\n        vec3 col = vec3(0.0);\\\n        depth = 1.0;\\\n        \\\n        if (march(data, ro, rd)) {\\\n            vec3 albedo = getAlbedo(data);\\\n            vec3 diffuse = albedo / M_PI;\\\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\\\n                Light light = LIGHTS[i];\\\n                col += forEachLight(light, data, ro, rd, diffuse);\\\n            }\\\n        } else {\\\n            col += getSky(rd);\\\n        }\\\n        \\\n        depth = data.d / FAR;\\\n        \\\n        return col;\\\n    }\\\n    \\\n    vec4 blit(in vec2 fc) {\\\n        vec3 col = vec3(0.0);\\\n        vec2 uv = (fc-0.5*R.xy)/R.y;\\\n        vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\\\n        \\\n        Ray ray = getRay(uv, m);\\\n        vec3 ro = ray.ro;\\\n        vec3 rd = ray.rd;\\\n        Data data = NEW_DATA;\\\n        float depth = 1.0;\\\n        col += render(data, ro, rd, depth);\\\n        col = aces(col);\\\n        col = pow(col, vec3(1.0 / 2.2));\\\n        return vec4(col, depth);\\\n    }","name":"Common","description":"","type":"common"}]}