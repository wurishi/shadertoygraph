{"ver":"0.1","info":{"id":"XtKXWG","date":"1485825147","viewed":176,"name":"Colander hat","username":"balkhan","description":"requested by public_int_i","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","joke"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\nfloat \tt;\n\n#define I_MAX\t\t100\n#define E\t\t\t0.001\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvec2\trot(vec2 p, vec2 ang);\nvoid\trotate(inout vec2 v, float angle);\nvec2\trot_t;\nvec3\tbase;\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(-5.0, 5.0, 60.0);\n    t = iTime;\n\trot_t = vec2( cos(t), sin(t) );\n\n    vec4\tinter = (march(pos, dir));\n\tif (inter.y == 1.)\n\t{\n\t\tvec3\tv = pos+inter.w*dir;\n        vec3\tn = calcNormal(v, E, dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(100.0, 100.0, 700.0);\n\t\tvec3\tlight_color = vec3(.4, .5, .4);\n        vec3\tvl = normalize( (light_pos - v) );\n\t\tfloat\tdiffuse  = max(0., dot(vl, n));\n\t\tfloat\tspecular = pow(max(0., dot(vl, ref_ev)), 20. );\n\n    \tv.zy *= mat2(rot_t.x, rot_t.y, -rot_t.y, rot_t.x);\n        vec2\tuv_map = vec2(\n        \t\t\t\t\t\t.5 + atan(v.z, v.x)/6.28 ,\n        \t\t\t\t\t\t.5 - asin(v.y/5.)/3.14 );\n        base.xyz = vec3(.45,.45,.4);\n        base.xyz =1.5* texture(iChannel0, vec2( (uv_map.xy) )).xyz;\n\n        col.xyz = light_color * (specular) + diffuse * base;\n    }\n    c_out =  vec4(col,1.0);\n}    \n\nfloat sdCappedCylinder( vec3 p, vec2 h ); // iq's sdf\nfloat sdTorus( vec3 p, vec2 t );\n\nfloat\tde_0(vec3 p) // Collander\n{\n\tfloat\tmind = 1e5;\n\tfloat\tsphere_dist = 1e5;\n    float\tsphere_dist_2 = 1e5;\n    \n    sphere_dist   = mind = length(p) -15.4;\n    sphere_dist_2 = mind = max(mind, -(length(p-vec3(0.,-1.5, -0.)) -15.3 ) );\n\n    vec3 d = p;\n\tif (mind >= sphere_dist) // punch some holes in it\n    {\n        d.yz *= mat2(cos(1.57),sin(1.57),-sin(1.57),cos(1.57) );\n        if (dot(d.x,d.x)+dot(d.y,d.y) < 196. ) // but not too much\n    \td.yx = mod(d.yx, 2.)-1.;\n        mind = max(mind, -sdCappedCylinder(d, vec2(.81,20.2) ) );\n    }\n    \n    // add some handles\n\n    mind = min(mind, max(-sphere_dist, min(mind, sdTorus(p-vec3(-16.,1.5,0.), vec2(3.5, 1.5) ) ) ) );\n   \tmind = min(mind, max(-sphere_dist, min(mind, sdTorus(p-vec3(+16.,1.5,0.), vec2(3.5, 1.5) ) ) ) );\n    \n    // add a rope to stick to head\n\n    p.zy *= mat2(.0, 1., -1., .0);\n    mind = min(mind, max(-sphere_dist, min(mind, sdTorus(p-vec3(-0.,0.,-2.), vec2(15., .75) ) ) ));\n    \n\treturn (mind);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n\tvec2 d = (vec2(length(p.xy),p.z )) - h;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmind = 1e5;\n    p.zy *= mat2(rot_t.x, rot_t.y, -rot_t.y, rot_t.x);\t// view from angle\n\n\tmind = de_0(p);\n\t\n    return(mind);\n}\n\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\ts = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        if (dist.x < E )\n        {\n            s.y = 1.;\n            break;\n        }\n        s.x++;\n    }\n    s.w = dist.y+dist.x;\n    return (s);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           march(pos+eps.xyy, dir).w - march(pos-eps.xyy, dir).w,\n           march(pos+eps.yxy, dir).w - march(pos-eps.yxy, dir).w,\n           march(pos+eps.yyx, dir).w - march(pos-eps.yyx, dir).w ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n","name":"Image","description":"","type":"image"}]}