{"ver":"0.1","info":{"id":"4lj3Wh","date":"1428588846","viewed":295,"name":"light tracing test - public_int_","username":"public_int_i","description":"trying out light tracing, still have to improve a lot of stuff but looks alright","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["light","tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n//CONSTANTS\n\n#define prec .1\n\nconst float viewFar = 100.0;\nconst vec3 cameraUp = vec3(0.0,1.0,0.0);\n\n\nfloat noise2(in vec2 uv) {\n    return fract(uv.x*(uv.y-uv.x))-.5;\n}\n\n//axis aligned plane vs ray functions\nvoid xPlane(in vec3 rayPos, in vec3 rayDir, in vec3 pos, in vec2 size,\n            inout float closestHit, in int hitId, inout int curHitId) {\n    \n    float nX = pos.x-rayPos.x;\n    \n    nX /= rayDir.x;\n    if (nX < 0.) return;\n    if (nX < closestHit) {\n        vec3 hitPos = rayPos+rayDir*nX;\n        if (abs(hitPos.z-pos.z) <= size.x && abs(hitPos.y-pos.y) <= size.y) {\n            \n            closestHit = nX;\n            curHitId = hitId;\n            return;\n            \n        }\n    }\n    \n}\n\nvoid zPlane(in vec3 rayPos, in vec3 rayDir, in vec3 pos, in vec2 size,\n            inout float closestHit, in int hitId, inout int curHitId) {\n    \n    float nZ = pos.z-rayPos.z;\n    \n    nZ /= rayDir.z;\n    if (nZ < 0.) return;\n    if (nZ < closestHit) {\n        vec3 hitPos = rayPos+rayDir*nZ;\n        if (abs(hitPos.x-pos.x) <= size.x && abs(hitPos.y-pos.y) <= size.y) {\n            \n            closestHit = nZ;\n            curHitId = hitId;\n            return;\n            \n        }\n    }\n    \n}\n\nvoid yPlane(in vec3 rayPos, in vec3 rayDir, in vec3 pos, in vec2 size, inout float closestHit, in int hitId, inout int curHitId) {\n    \n    float nY = pos.y-rayPos.y;\n    \n    nY /= rayDir.y;\n    if (nY < 0.) return;\n    if (nY < closestHit) {\n        vec3 hitPos = rayPos+rayDir*nY;\n        if (abs(hitPos.x-pos.x) <= size.x && abs(hitPos.z-pos.z) <= size.y) {\n            \n            closestHit = nY;\n            curHitId = hitId;\n            return;\n            \n        }\n    }\n    \n}\n\n\n\nconst vec3 xWallPos = vec3(5.,20.,0.);\nconst vec3 xWallPos2 = vec3(-5.,20.,0.);\n\nconst vec3 floorPos = vec3(0.,15.,0.);\nconst vec3 ceilPos = vec3(0.,30.,0.);\nconst vec2 floorSize = vec2(20.);\nconst vec4 floorUvs = vec4(0.,0.,3.,3.);\n\n\nvoid scene(inout vec3 rayStartPos, inout vec3 rayStartDir, inout float dist, inout int id) {\n\tyPlane(rayStartPos,rayStartDir,floorPos,floorSize,dist,0,id);\n    yPlane(rayStartPos,rayStartDir,ceilPos,floorSize,dist,0,id);\n    xPlane(rayStartPos,rayStartDir,xWallPos,floorSize,dist,1,id);\n    xPlane(rayStartPos,rayStartDir,xWallPos2,floorSize,dist,1,id);\n    zPlane(rayStartPos,rayStartDir,xWallPos.zyx,floorSize,dist,2,id);\n    zPlane(rayStartPos,rayStartDir,xWallPos2.zyx,floorSize,dist,2,id);\n}\n\nvec3 normal(in int id, in vec3 rp) {\n    if (id == 0) {\n        if (rp.y-22. > 0.) {\n            return vec3(0.,sign(rp.y-ceilPos.y),0.);\n        } else {\n            return vec3(0.,sign(rp.y-floorPos.y),0.);\n        }\n    }\n    if (id == 1) {\n        if (rp.x > 0.) {\n            return vec3(sign(rp.x-xWallPos.x),0.,0.);\n        } else {\n            return vec3(sign(rp.x-xWallPos2.x),0.,0.);\n        }\n    }\n    if (id == 2) {\n        if (rp.z > 0.) {\n            return vec3(0.,0.,sign(rp.z-xWallPos.x));\n        } else {\n            return vec3(0.,0.,sign(rp.z-xWallPos2.x));\n        }\n    }\n    return vec3(0.);\n}\nvec3 color(in vec3 p, in int id) {\n    if (id == 0) {\n        return texture(iChannel0,p.xz*.1).xyz;\n    }\n    if (id == 1) {\n        return texture(iChannel0,p.zy*.1).xyz;\n    }\n    if (id == 2) {\n        return texture(iChannel1,p.xy*.1).xyz*vec3(1.,.3,.3);\n    }\n    \n    return vec3(0.0);\n}\n\n\n#define rs id = -1;d = viewFar;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //setup camera and light\n    vec3 lightDir = normalize(vec3(sin(iTime),0.,cos(iTime)));\n    vec3 cameraPosition = vec3(sin(iTime*.1)*50.0,sin(iTime*.5)*20.,cos(iTime*.1)*50.0);\n    vec3 cameraDirection = normalize(-cameraPosition);\n    cameraPosition.y += 20.;\n        \n    \n\tvec2 cUv = (fragCoord.xy/iResolution.xy)-vec2(0.5);\n    cUv.y *= iResolution.y/iResolution.x;\n    cUv *= 2.;\n    \n    \n  \tvec3 rayStartDir = normalize(cross(cameraDirection,cameraUp)*cUv.x + \n                  vec3(cameraDirection.x,cameraDirection.y+cUv.y,cameraDirection.z));\n    vec3 rayStartPos = cameraPosition;\n    \n    \n    //main rendering code\n    int id = -1;\n    float d = viewFar;\n   \n    //first main cast\n    scene(rayStartPos,rayStartDir,d,id);\n    \n    if (id == -1) {//no hit return bg light\n        fragColor = vec4(dot(rayStartDir,lightDir)>.8?1.:0.);\n        return;\n    }\n    \n    //hit, trace light path\n    rayStartPos += rayStartDir*d;\n    vec3 startPos = rayStartPos,startPos2,startPos3;\n\tvec3 tc = vec3(0.);\n    vec3 bc = color(rayStartPos,id),cc,dc;\n    vec3 norm = normal(id,rayStartPos);\n    \n    for (int k = 0; k < 12; k++) {\n        rayStartDir = normalize(vec3(noise2(rayStartPos.zy),\n                                     noise2(rayStartPos.xz),\n                                     noise2(rayStartPos.yx)));\n        if (dot(rayStartDir,norm) <0.) {\n            rayStartDir *= -1.;\n        }\n        rayStartPos = startPos;\n        \n        \n\t\trs\n        scene(rayStartPos,rayStartDir,d,id);\n        if (id == -1) {\n            tc += bc*(dot(rayStartDir,lightDir)>.8?1.:0.);\n            continue;\n        }\n        startPos2 = rayStartPos+rayStartDir*d;\n        cc = bc*color(startPos2,id);\n        /*\n        for (int i = 0; i < 4; i++) {\n        \trayStartDir = normalize(vec3(noise2(rayStartPos.zy),\n                                     \t noise2(rayStartPos.xz),\n                                    \t noise2(rayStartPos.yx)));\n            rayStartPos = startPos2;\n\t\t\trs\n            scene(rayStartPos,rayStartDir,d,id);\n            if (id == -1) {\n                tc += cc*(dot(rayStartDir,lightDir)>.8?1.:0.);\n                continue;\n            }\n            startPos3 = rayStartPos+rayStartDir*d;\n        \tdc = cc*color(startPos3,id);\n            for (int j = 0; j < 12; j++) {\n        \t\trayStartDir = normalize(vec3(noise2(rayStartPos.zy),\n                                     \t noise2(rayStartPos.xz),\n                                    \t noise2(rayStartPos.yx)));\n                rayStartPos = startPos3;\n                rs\n                scene(rayStartPos,rayStartDir,d,id);\n                if (id == -1) {\n                \ttc += dc*(dot(rayStartDir,lightDir)>.8?1.:0.);\n                }\n            }\n        }*/\t\n        \n        for (int i = 0; i < 16; i++) {\n            \n            d = viewFar;\n            id = -1;\n            scene(rayStartPos,rayStartDir,d,id);\n            if (id == -1) {//bg light hit\n                tc += cc * (dot(rayStartDir,lightDir)>.8?2.:0.);\n\t\t\t\tbreak;\n            }\n            \n            rayStartPos += rayStartDir*d;\n            rayStartDir = reflect(rayStartDir,normal(id,rayStartPos));\n            cc *= color(rayStartPos,id)*.6;\n        }\n    }\n    \n     fragColor = vec4(tc*.5,1.);\n}","name":"Image","description":"","type":"image"}]}