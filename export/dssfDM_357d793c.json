{"ver":"0.1","info":{"id":"dssfDM","date":"1688855456","viewed":66,"name":"Linear systems 3x3 (Cramer)","username":"Envy24","description":".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["linear","solution","cramers","rule","systems"],"hasliked":0,"parentid":"mdsfDM","parentname":"Linear systems 2x2 (Cramer)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 4. )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat cells(vec2 NDC)\n{\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_line(NDC, 0.), horizontal_line(NDC, 0.)) +\n        max(vertical_line(NDC, 0.), horizontal_line(NDC, 0.));\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// Line of intersection of two planes.\nfloat intersection_lineSDF(vec2 NDC, vec4 r1, vec4 r2)\n{\n    vec2 sol1 = solve_linear_system22(r1.xyw, r2.xyw);\n    r1.w += r1.z; r2.w += r2.z;\n    vec2 sol2 = solve_linear_system22(r1.xyw, r2.xyw);    \n    vec3 E = vec3(sol1, 1), B = vec3(sol2, 0);\n    vec3 dir = normalize(E - B);\n        E = B + dir * 200.;\n        B = B - dir * 200.;       \n    return segmentSDF_L2(NDC, B.xy, E.xy, 0.);\n}\n\n// Solve by Cramers rule.\nvec3 solve_linear_system33(vec4 r1, vec4 r2, vec4 r3) // plane-plane-plane intersection\n{\n    float delta = \n        determinant(mat3(\n            r1.x, r2.x, r3.x,\n            r1.y, r2.y, r3.y,\n            r1.z, r2.z, r3.z));\n    float inv = \n        delta == 0. ? // No solution (intersection)?\n            0. :\n            1. / delta; \n    \n    float delta1 = \n        determinant(mat3(\n            r1.w, r2.w, r3.w,\n            r1.y, r2.y, r3.y,\n            r1.z, r2.z, r3.z));\n            \n    float delta2 = \n        determinant(mat3(\n            r1.x, r2.x, r3.x,\n            r1.w, r2.w, r3.w,\n            r1.z, r2.z, r3.z));\n            \n    float delta3 =\n        determinant(mat3(\n            r1.x, r2.x, r3.x,\n            r1.y, r2.y, r3.y,\n            r1.w, r2.w, r3.w));\n            \n    // total: 39 muls, 20 subs/adds, 1 div\n    \n    return vec3(delta1, delta2, delta3) * inv;\n}\n/* For CPU *\nvec3 solve_linear_system33(vec4 r1, vec4 r2, vec4 r3)\n{\n    float a = r2.y * r3.z - r2.z * r3.y,\n          b = r2.x * r3.z - r2.z * r3.x,\n          c = r2.x * r3.y - r2.y * r3.x,\n          d = r2.w * r3.z - r2.z * r3.w,\n          e = r2.x * r3.w - r2.w * r3.x,\n          f = r2.y * r3.w - r2.w * r3.y;\n\n    float delta = r1.x * a - r1.y * b + r1.z * c;\n    float inv =\n        delta == 0. ? // No solution (intersection)?\n            0. :\n            1. / delta;\n\n    float delta1 = r1.w * a - r1.y * d - r1.z * f,\n          delta2 = r1.x * d - r1.w * b + r1.z * e,\n          delta3 = r1.x * f - r1.y * e + r1.w * c;\n\n    // total: 24 muls, 14 subs/adds, 1 div\n\n    return vec3(delta1, delta2, delta3) * inv;\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 5., vec2(0), true);\n    \n    vec3 color = vec3(1);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color -= cells(NDC)*0.2;\n    \n    float T = iTime * 0.5;\n    \n    /* Linear system with 3 unknowns. */\n    vec4 r1 = H4to4(vec4(   -T,  T*2., T*3., -T*2.));  // ax + by + cz = d\n    vec4 r2 = H4to4(vec4(    T, -T*4., -T*5., T*6.)); // ex + fy + gz = k\n    vec4 r3 = H4to4(vec4(-T*3., -T*4., -T*5., T));    // lx + my + pz = q\n    \n    //vec4 r1 = H4to4(vec4(2, 3, 5, 0));  // ax + by + cz = d\n    //vec4 r2 = H4to4(vec4(5, 4, -2, 0)); // ex + fy + gz = k\n    //vec4 r3 = H4to4(vec4(-T*3., -T*4., -T*5., T));    // lx + my + pz = q\n    /**/\n\n    /* Lines */    \n    color = mix(color, vec3(1,0,0), SMAA(intersection_lineSDF(NDC, r1, r2)));\n    color = mix(color, vec3(0,1,0), SMAA(intersection_lineSDF(NDC, r2, r3)));\n    color = mix(color, vec3(0,0,1), SMAA(intersection_lineSDF(NDC, r3, r1)));\n    /* */\n    \n    /* Solution */\n    vec3 xyz = solve_linear_system33(r1, r2, r3);\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, xyz.xy, 0.2)));\n    /* */\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n//https://www.shadertoy.com/view/fsGcRc\nfloat lineSDF_L2(vec2 NDC, float m, float k, float r)\n{\n    float x = (m*(NDC.y-k)+NDC.x) / (m*m + 1.);  // root of x+x*m^2+mk-mb-a=0\n\n    vec2 C = vec2(x, m*x+k);                     // Closest point on line y=mx+k to point NDC\n    \n    return length(C - NDC) - r;\n}\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 vector3HashUI32(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}\n#define H3to3(P) ( vector3HashUI32(uint(P.x), uint(P.y), uint(P.z)) )\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec4 vector4HashUI32(\n    const uint x,\n    const uint y,\n    const uint z,\n    const uint w)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n    uint value3 = w * entropy3 * entropy2 + w * entropy2 + w;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n    value3 += entropy1; value3 *= 445593459u; value3 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec4(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f,\n        float(value3 * value3 * value3) * 4.6566128730773926e-10f - 1.0f);\n}\n#define H4to4(P) ( vector4HashUI32(uint(P.x), uint(P.y), uint(P.z), uint(P.w)) )\n\nvec2 solve_linear_system22(vec3 r1, vec3 r2) // line-line intersection\n{\n    float delta = determinant(\n        mat2(\n            r1.x, r2.x,\n            r1.y, r2.y));\n    float inv = \n        delta == 0. ? // No solution (intersection)?\n            0. :\n            1. / delta; \n    \n    float delta1 = determinant(\n        mat2(\n            r1.z, r2.z,\n            r1.y, r2.y));\n            \n    float delta2 = determinant(\n        mat2(\n            r1.x, r2.x,\n            r1.z, r2.z));\n    \n    return vec2(delta1, delta2) * inv;\n}","name":"Common","description":"","type":"common"}]}