{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// based on Elevated demo by Inigo Quilez https://www.shadertoy.com/view/MdX3Rr\n\nconst int octaves = 7;\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// Value noise generator. Returns\n// three values on [-1, +1]\nvec3 noised(vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\t// The constant for tileWidth doesn't matter much unless it is too small\n    const float tileWidth = 1024.0;\n    float n = p.x + p.y * tileWidth;\n\n    // Grab noise values at four corners of a square\n    float a = hash(n +  0.0);\n    float b = hash(n +  1.0);\n    float c = hash(n + tileWidth);\n    float d = hash(n + tileWidth + 1.0);\n\n    // use smoothstep-filtered lerp for one component and compute the derivatives for the others\n\t// See https://iquilezles.org/articles/morenoise\n\n    // The (negative) smoothstep weight\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n// On the range [0, 1].  This is the sum\n// of a convergent series http://en.wikipedia.org/wiki/Series_(mathematics)#Convergent_series, \n// where each term has a pseudorandom weight on [-1, 1].  The largest sum is therefore\n// 2 (the smallest is -2), and the final line of code rescales this to the unit interval.\n// \nfloat heightfieldFcn(vec2 P) {\n    const mat2 M2 = mat2(1.6, -1.2, 1.2, 1.6);\n    float height = 0.0;\n\tvec2 d = vec2(0.0);\n\n    // Magnitude at this octave\n    float magnitude = 1.0;\n\n    // Add multiple octaves of noise, chosen from points that spiral outward\n    // to avoid hitting the tiling period of the noise function.\n    for (int i = 0; i < octaves; ++i) {\n        vec3 n = noised(P);\n        d += n.yz;\n\n        // The 1 + |d|^2 denominator creates the mountainous lumpiness.\n        // Without it, this is a standard value noise function.\n        height += magnitude * n.x / (1.0 + dot(d, d));\n        P = M2 * P;\n\t\tmagnitude *= 0.5;\n    }\n\n\t// iq's original had 0.5 here, but that doesn't fit the range\n    return height * 0.25 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n\tfragColor = vec4(vec3(heightfieldFcn(uv * 10.0 * (1.0 + sin(iTime * 0.2)))),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldfGWj","date":"1379206021","viewed":597,"name":"Elevated Heightfield","username":"morgan3d","description":"Commented version of the heightfield function from iq's Elevated (https://www.shadertoy.com/view/MdX3Rr), proving the bounds on the function and explaining how it works.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""}}