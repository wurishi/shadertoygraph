{"ver":"0.1","info":{"id":"DlVyzm","date":"1700070211","viewed":31,"name":"CCU Shader workshop 15_11_23","username":"Immute","description":"First steps in fragment shaders","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["firstthing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void drawSquare (out vec4 fragColor, in vec2 fragCoord)\n{\n\n} // Challenge, try to finish the function\n\n\nvoid drawCircle (vec2 pos, vec2 uv, float radius)\n{\n        \n} //challnge, try to finish this function\n\nmat2 rotation(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.9, 1.0, 0.0);\n    vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.xy; // Applying a fix to avoid stretching\n    \n    uv.x *= iResolution.x/iResolution.y; \n    \n    //uv = uv + vec2(0.1, 0.0); //Translating the space\n    //uv = uv * 1.0; //Scale // zoom\n    //uv = uv * rotation(0.5);\n    //vec2 treshold = vec2(0.5, 0.5);\n    //float offset = 0.1 + sin(iTime) * 0.2 * 0.2;\n    \n    vec2 position = vec2(0.0, 0.5);\n    float radius = 0.2;\n    \n    //float dist = distance (position, uv)-0.4; // Way to anti-alias your shapes\n    float dist = sdHeart(uv * 1.5 + position); // Way to anti-alias your shapes\n    \n    //dist = abs(dist) - 0.05 * sin(iTime) * 0.3; // Outline\n    //dist = abs(dist) - 0.09 * sin(iTime) * 0.5;\n    \n    float dist2 = sdHeart(uv*2.0+ position - vec2(-0.4, -.125)) ;\n    dist = abs(dist) -0.02;\n    dist = min(dist, dist2); //Union\n    \n    //dist = max(dist, -dist2); //Subtraction\n    //dist = max(dist, dist2); // Addition\n    \n    dist = dist; // Flips the shape\n    float mask = .5 - clamp(dist * (sin(iTime * 1.5) * 0.1)* iResolution.x/1.0, 0.0, 1.0); // 1.0 - (inverts the mask)\n    color = vec3(1.0, 0.1, 0.1) * mask; //By multiplying it with mask (which is clamped) we avoid saturating the colors (Blending)\n    \n    //if (dist < radius)\n      //  color = vec3(0.1, 0.1, 0.1);\n    \n    color.x -= uv.y + sin(iTime) * 0.1;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}