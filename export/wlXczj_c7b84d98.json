{"ver":"0.1","info":{"id":"wlXczj","date":"1592911987","viewed":135,"name":"simple animation 3d ball","username":"hahnzhu","description":"practice of Ray Marching & Sign Distance Function & Blinn-Phong refrection model with the toturials from [url=https://www.shadertoy.com/user/iq]iq[/url] and [url=https://www.shadertoy.com/user/jlfwong]jlfwong[/url]\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","blinnphone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\n// reference: https://iquilezles.org/articles/distfunctions\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat smoothMin(float dstA, float dstB, float k) {\n    float h = max(k-abs(dstA - dstB), 0.) / k;\n    return min(dstA, dstB) - h*h*h*k*1./6.0;\n}\n\nfloat sdBox( vec3 p, vec3 c, vec3 b ) {\n\tvec3 q = abs(p-c) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, vec3 c, float s ) {\n\treturn length(p-c)-s;\n}\n\nfloat GetDist(vec3 p) {\n    vec4 s = vec4(0., 1., 1., 1.);\n\n    float sphereDist = sdSphere(p, s.xyz, s.w);\n    \n    float boxDist = sdBox(p, vec3(sin(iTime),1.,1.), vec3(.5,.5,.5));\n\n    float planeDist = p.y;\n    \n    float d = smoothMin(sphereDist, boxDist, .5);\n\n    return min(d, planeDist);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat d0 = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd * d0; \n        float dS = GetDist(p);\n        d0 += dS; \n        if(d0>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n\treturn d0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat GetShadow(vec3 p, vec3 ld, float mint, float maxt){\n    for( float t=mint; t<maxt;) {\n        float h = GetDist(p + ld*t);\n        if( h<0.001)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nfloat GetSoftShadow(vec3 p, vec3 ld, float mint, float maxt, float k ) {\n    float res = 1.0;\n    for( float t=mint; t<maxt; ) {\n        float h = GetDist(p + ld*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat GetSoftShadowAdvance( in vec3 ro, in vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 cameraDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p), // forward\n        r = normalize(cross(vec3(0,1,0), f)), // right\n        u = cross(f,r),\t// up\n        c = p+f*z,\t// center\n        i = c + uv.x*r + uv.y*u, // intersection\n        d = normalize(i-p);\t// direction\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.01, 0);\n    vec3 n = vec3(\n        d - GetDist(p-e.xyy),\n        d - GetDist(p-e.yxy),\n        d - GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetDiffuse(vec3 p, vec3 lo, vec3 lc) {\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lo - p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = RayMarch(p+SURF_DIST*2., l);\n    if (d<length(lo-p) && p.y <= 0.01) dif *= .1;\n    return dif * lc;\n}\n\nvec3 GetSpecular(vec3 p, vec3 ro, vec3 lo, vec3 lc) {\n\tvec3 bisector = normalize(lo + ro);\n\tfloat scope = pow(max(0.0, dot(bisector, GetNormal(p))), 200.0);\n    return scope * lc;\n}\n\nvec3 rotate3D(float radius, float phiAngle, float thetaAngle) {    \n    float phi = radians(phiAngle);\t\n    float theta = radians(thetaAngle);\n    \n    return vec3(\n        radius * cos(phi) * cos(theta) * -1.,\n        radius * sin(phi),\n        radius * cos(phi) * sin(theta)\n    );\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*1.5 );\n    float sunAmount = max( dot( rayDir, sunDir ), 0. );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7)*.1, // bluish\n                           vec3(1.0,0.9,0.7)*.1, // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\n\n// source: https://www.shadertoy.com/view/lt33z7\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N), 0., 1.);\n    float dotRV = dot(R, V);\n    \n    //vec3 ro, vec3 rd, float mint, float maxt\n    float shadow = GetSoftShadowAdvance(p+SURF_DIST*2., L, 0., 10., 10.);\n    if (p.y < 0.1) lightIntensity *= shadow;\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n\n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse component\n        return lightIntensity * (k_d * dotLN);\n    }\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    vec3 color = k_a;\n    \n    float angle = mod(iTime/10., 1.)*360.;\n    float angle2 = mod(iTime/20., 1.)*360.;\n    \n    vec3 light1Pos = rotate3D(10., 50., angle);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity);\n    //color += applyFog(color, length(eye-p), normalize(eye-p), normalize(light1Pos-p));\n    \n    vec3 light2Pos = rotate3D(5., angle, angle2);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Intensity); \n\t//color += applyFog(color, length(eye-p), normalize(eye-p), normalize(light2Pos-p));\n    \n    return color;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0., 2., 5.);\n    vec3 lookat = vec3(0.);\n    float zoom = 1.;\n    \n    vec3 lightPos = vec3(0, 10., 5.);\n    vec3 lightPos2 = vec3(0, 10., 5.);\n    \n    vec3 ambientColor = vec3(.5, 1., 1.) * .5;\n    vec3 diffuseColor = vec3(1., .5, 1.);\n    vec3 specularColor = vec3(1., 1., 1.);\n    float shininessCoefficient = 50.;\n    \n    float angle = mod(iTime/10., 1.)*360.;\n\tro = rotate3D(length(ro-lookat), 10., angle);\n    \n    vec3 rd = cameraDir(uv, ro, lookat, zoom); \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    vec3 phongColor = phongIllumination(ambientColor, diffuseColor, specularColor, shininessCoefficient, p, ro);\n    \n    fragColor = vec4(phongColor,1.0);\n    //fragColor = vec4(vec3(shadow),1.0);\n}","name":"Image","description":"","type":"image"}]}