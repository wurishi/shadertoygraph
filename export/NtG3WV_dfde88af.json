{"ver":"0.1","info":{"id":"NtG3WV","date":"1732694081","viewed":26,"name":"Afro Ray Marching","username":"afrodex","description":"basic ray marching, kinda followed along with inigo's making a heart video","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100  //maximum number of steps to take in marcher\n#define MAX_DIST 50.  //the largest step size in marcher\n#define SURF_DIST .01  //maximum distance to register a hit\n#define STEP_SIZE .45   //scaling factor for step size to account for distortions\n\n//find distance from point to nearest object in scene\n//also defines objects in the scene\n\nmat2 rot(float a){\n    float sine = sin(a);\n    float cosine = cos(a);\n    \n    return mat2(cosine, -sine, sine, cosine);\n}\n\nfloat sdfHeart(vec4 sphere, vec3 p){\n\n\n    float a = 0.;\n    a = .1+.1*sin(6.28*iTime);\n    a = .1+.1*pow(.5+.5*sin(6.28*iTime), 4.);\n    a = .1+.1*pow(.5+.5*sin(6.28*iTime+.3*p.y*p.y), 4.);\n    \n    sphere.w += a;\n    \n    return length(vec3(p.x, .1+1.2*p.y-abs(p.x)*sqrt(1.7-abs(p.x)), (2.5-p.y*.3)*p.z)-sphere.xyz) - sphere.w;\n\n}\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0, 1, 0, 1); //sphere data: x, y, z, radius\n    float sphereDist = length(p-s.xyz) - s.w;\n    float heartDist = sdfHeart(s, p);\n    float planeDist = p.y;\n    float boxDist = length(max(abs(p-1.) - vec3(.5), 0.));\n    float m = iMouse.x/iResolution.x;\n    m = 1.;\n    float d = min(mix(sphereDist, heartDist, m), planeDist);\n    return d;\n}\n\n//ray marching loop\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.; //distance marched so far\n    \n    for (int i=0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO*STEP_SIZE;    //march the distance dO in the direction rd from point ro\n        float dS = GetDist(p);  //calculate the distance to the nearest object in the scene from current point\n        dO += dS;               //increase the total distance for the next iteration\n        if (dO>MAX_DIST || dS<SURF_DIST) break; //break out of loop if past the maximum distance or a hit is registered\n    }\n\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);  //find distance to nearest point\n    vec2 e = vec2(.01, 0.); //amount to step in each direction\n    \n    //use step to find new distance in each direction\n    //swizzle the e around to make the coding simpler\n    vec3 norm = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n        );\n        \n    return normalize(norm);\n}\n\n//gives light value at this point in the scene \nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, -4);     //position of light in the scene\n    lightPos.xz+= vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lightDir = normalize(lightPos - p);  //direction from light to point\n    vec3 norm = GetNormal(p);\n    \n    float dif = clamp(dot(lightDir, norm), 0., 1.); //lighting value at this point; between 0, 1\n    float shadDist = RayMarch(p+norm*SURF_DIST*1.5, lightDir);   //distance to nearest object between this point and the light source\n    if (shadDist<length(lightPos-p)) dif *=.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.x;\n    float mcos = pow(1. - mouse.x*mouse.x, .5);   //cosine version of mouse x\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 cam = vec3(0, 1, -6); //relative position of camera\n    //cam.xz = length(cam.xz)*vec2(mouse.x, -mcos);    //position with rotation from mouse\n    cam.xz *= rot(asin(mouse.x));\n    vec3 raydir = normalize(vec3(uv.x, uv.y, 1));    //direction of rays coming from camera\n    raydir.xz *= rot(asin(mouse.x));\n    //raydir = normalize(raydir - normalize(vec3(cam.x, 0., cam.z)));\n    float d = RayMarch(cam, raydir);   //distance to nearest object from camera\n    \n    vec3 p = cam + raydir * d*STEP_SIZE;   //hit position of current ray to nearest object (world space)\n    float dif = GetLight(p);    //light value from that object\n    \n    col = vec3(dif);\n    //col = vec3(abs(mouse.x));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}