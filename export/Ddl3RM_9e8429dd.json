{"ver":"0.1","info":{"id":"Ddl3RM","date":"1665853452","viewed":131,"name":"Better thick explicit graphs","username":"Envy24","description":".","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","graph","plot","thick","explicit"],"hasliked":0,"parentid":"msf3RM","parentname":"Better explicit graphs"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\n#define T       ( iTime )\n#define M       ( sinOSC(1., 15., iTime*0.5) )\n#define func(x) ( sin(x+iTime)*cos(M*(x)) )\n//#define func(x) ( cos(0.3*(x+T))*sin(100.0*cos(x+0.382*T)+T) )\n//#define func(x) ( fract((x)*5.+iTime) > 0.5 ? 1. : 0. )\n//#define func(x) ( tan(x) )\n//#define func(x) ( sign(x) )\n\n/*old*\nfloat explicit_sdf2(\n    in vec2 NDC,\n    in float pixel_size,\n    in float thickness)\n{\n    thickness = max(0., thickness);\n    float order = thickness + 4.;\n    \n    float minimal_distance = 99.;\n    vec2 B = vec2(NDC.x, func(NDC.x));\n    \n    for (float i = -order; i <= order; i += 1.)\n    {\n        float dx = pixel_size * i;\n        vec2 E = vec2(B.x + dx, func(B.x + dx));\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n    }\n    \n    return minimal_distance - pixel_size * thickness;\n}\n/**/\nfloat explicit_sdf(\n    in vec2 NDC,\n    in float pixel_size,\n    in float thickness)\n{\n    thickness = max(0., thickness);\n    float quality = 4., // higher - better AA\n          order = thickness + quality,\n          minimal_distance = 9e5;\n          \n    vec2 B = \n        vec2(NDC.x-order*pixel_size,\n             func(NDC.x-order*pixel_size));\n      \n    for (float i = -order + 1.; i <= order; i += 1.)\n    {\n        vec2 E = vec2(B.x + pixel_size, func(B.x + pixel_size));\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance - pixel_size * thickness;\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * 1.5;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n    /* Explicit function y=f(x) */\n         float thickness = ( sinOSC(0., 30., iTime) );\n         color = mix( color, vec3(1,0,0), SMAA(explicit_sdf(NDC, 2./R.y, thickness)) );     \n    /**/  \n         color -= vertical_line(NDC, -1.)*.2;   color -= vertical_line(NDC, 1.)*.2;\n         color -= horizontal_line(NDC, -1.)*.2; color -= horizontal_line(NDC, 1.)*.2; \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}","name":"Common","description":"","type":"common"}]}