{"ver":"0.1","info":{"id":"XlKGRh","date":"1473489218","viewed":542,"name":"1D celluar automata","username":"LukeRissacher","description":"A little noodling around with 1D celluar automata, using a pixel-art upscaler.","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["1d","cellular","automaton","pixelscaling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Here we just sample and upscale Buf A using a pixel-art scaling algorithm, \n// the automaton stuff happens there.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    const float SCALE = 1.0 / 2.0;\n    \n    // Sample the pixel and its neighbors in the lower quadrant of Buf A\n    vec2 uv = SCALE * fragCoord / iResolution.xy;\n    vec2 dx = 1.0 / iResolution.xy;\n    float center = texture(iChannel0, uv).r;\n    float left =   texture(iChannel0, uv + dx * vec2(-1,  0)).r;\n    float top =    texture(iChannel0, uv + dx * vec2( 0,  1)).r;\n    float right =  texture(iChannel0, uv + dx * vec2( 1,  0)).r;\n    float bottom = texture(iChannel0, uv + dx * vec2( 0, -1)).r;\n    \n    // Upscale using EPX pixel scaling to smooth edges\n    // https://en.wikipedia.org/wiki/Pixel_art_scaling_algorithms\n    float value = center;\n    float sum = left + top + right + bottom;\n    if (sum == 2.0) {\n        vec2 subPos = fract(uv / dx);\n        if (subPos.x < 0.5) { // left\n            if (subPos.y < 0.5) {\n                if (left == bottom) {\n                    value = left;\n                }\n            }\n            else {\n                if (left == top) {\n                    value = left;\n                }\n            }\n        }\n        else { // right\n            if (subPos.y < 0.5) {\n                if (right == bottom) {\n                    value = right;\n                }\n            }\n            else {\n                if (right == top) {\n                    value = right;\n                }\n            }\n        }\n    }\n    \n    // Show\n\tfragColor.rgb = vec3(value);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float SCALE = 1.0 / 2.0;\n\nfloat Rand(vec2 pos) {\n    return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    \n    // If we're in the 'pixel buffer' region...\n    vec2 bufSize = SCALE * iResolution.xy;\n    if (fragCoord.x < bufSize.x && fragCoord.y < bufSize.y) {\n    \t\n        // Most rows: copy from below (move upwards)\n        if (fragCoord.y > 0.9) {\n            vec2 uv = (fragCoord + vec2(0, -1)) / iResolution.xy;\n        \tfragColor.rgb = texture(iChannel0, uv).rgb;    \n        }\n        // Bottom row: run the automaton\n        else {\n            \n            // Sample previous neighboring values, wrapping at edges\n            // prev.xyz = (left, middle, right)\n            vec3 prev; \n            {\n                vec2 uv = fragCoord / iResolution.xy;\n                vec2 dx = vec2(1.0 / iResolution.x, 0.0);\n                prev.x = texture(iChannel0, mod(uv - dx, SCALE)).r;\n                prev.y = texture(iChannel0, uv).r;\n                prev.z = texture(iChannel0, mod(uv + dx, SCALE)).r;\n                prev = 1.0 - prev;\n            }\n            \n            // Pattern is binary 000-111 (0-7) representing past values\n            float pattern = dot(prev, vec3(4.0, 2.0, 1.0));\n            \n            // Rule number is a byte - each bit represents whether a given\n            // pattern of 3 neighboring pixels (000 - 111, 8 total) should produce a '1' result.\n            // See: https://en.wikipedia.org/wiki/Elementary_cellular_automaton for more info\n            float rule;\n            \n            // Choose the rule to follow; run thru different \"presets\"\n            int ROWS_PER_PRESET = int(bufSize.y);\n            float preset = mod(float(iFrame / ROWS_PER_PRESET), 14.0);\n            bool randomize;\n            if      (preset < 1.0)  { rule = 30.0;  randomize = false; }\n            else if (preset < 2.0)  { rule = 22.0;  randomize = false; }\n            else if (preset < 3.0)  { rule = 45.0;  randomize = true; }\n            else if (preset < 4.0)  { rule = 110.0; randomize = true; }\n            else if (preset < 5.0)  { rule = 73.0;  randomize = true; }\n            else if (preset < 6.0)  { rule = 75.0;  randomize = false; }\n            else if (preset < 7.0)  { rule = 105.0; randomize = false; }\n            else if (preset < 8.0)  { rule = 105.0; randomize = true; }\n            else if (preset < 9.0)  { rule = 60.0;  randomize = true; }\n            else if (preset < 10.0) { rule = 15.0;  randomize = true; }\n            else if (preset < 11.0) { rule = 22.0;  randomize = true; }\n            else if (preset < 12.0) { rule = 150.0; randomize = true; }\n            else if (preset < 13.0) { rule = 106.0; randomize = true; }\n            else                    { rule = 120.0; randomize = true; }\n\n            // At the start of each preset, either randomize or seed with a single \n            // pixel in the center as specified\n            if (mod(float(iFrame), float(ROWS_PER_PRESET)) < 1.0) {\n                if (randomize) {\n                \tpattern = floor(Rand(fragCoord + mod(iDate.w, 1000.0)) * 8.0);\n            \t}\n           \t\telse {\n                    pattern = (floor(fragCoord.x) == floor(bufSize.x / 2.0) ? 2.0 : 0.0);\n            \t}\n            }\n            \n            // Run the automaton: \n            float result = 0.0;\n            float bitValue = 128.0;\n            for (int i = 7; i >= 0; i--) {\n                if (rule >= bitValue) {\n                    rule -= bitValue;\n                    if (pattern == float(i)) {\n                        result = 1.0;\n                        break;\n                    }\n                }\n                bitValue /= 2.0;\n            }\n            \n            // Set the pixel: 1.0 = black\n            fragColor.rgb = vec3(1.0 - result);\n        }\n    }\n}","name":"Buf A","description":"","type":"buffer"}]}