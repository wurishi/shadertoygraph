{"ver":"0.1","info":{"id":"md2cDh","date":"1687794395","viewed":88,"name":"Cylindrical arc - Distance 3D","username":"Poisson","description":"Distance to a cylinder arc or box arc.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","raymarching","distancefield","sdf","torus","raymarcher","distance","box","field","rotation","cylinder","arc","circular","extrusion","revolution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2 // antialiasing\n\n// cylindrical arc sdf\nfloat sdArc(vec3 p, vec2 sc, float ra, float rb) {\n    p.x = abs(p.x); // symmetry\n    \n    vec3 q = p - vec3(sc*ra,0);\n    q.xy = mat2(sc.x,-sc.y,sc.y,sc.x) * q.xy; // rotation\n    \n    vec2 v = vec2(length(q.xz), abs(q.y)) - rb; // caps\n    vec2 w = vec2(length(p.xy) - ra, p.z); // torus\n    \n    return sc.y*p.x>sc.x*p.y ? length(max(v,0.)) + min(0.,max(v.x,v.y))\n                             : length(w) - rb;\n}\n\n/*\n// box version\nfloat sdArc(vec3 p, vec2 sc, float ra, float rb) {    \n    p.x = abs(p.x); // symmetry\n    \n    vec2 q = p.xy - sc*ra;\n    q = mat2(sc.x,-sc.y,sc.y,sc.x) * q; // rotation\n    \n    vec3 v = abs(vec3(q,p.z)) - rb; // caps\n    vec2 w = abs(vec2(length(p.xy)-ra, p.z)) - rb; // torus\n    \n    return sc.y*p.x>sc.x*p.y ? length(max(v,0.)) + min(0.,max(v.x,max(v.y,v.z)))\n                             : length(max(w,0.)) + min(0.,max(w.x,w.y));\n}\n*/\n\n// scene sdf\nfloat map(vec3 p) {\n    float ra = .5;\n    float rb = .1;\n    float th = .025+.025*sin(iTime);\n    \n    float an = .75*3.141592*(.5+.5*sin(.8*iTime));\n    vec2 sc = vec2(sin(an), cos(an));\n    \n    return sdArc(p, sc, ra, rb-th)-th;\n}\n\n// normal estimation using tetrahedron method\n// thanks to iq: https://iquilezles.org/articles/normalsSDF/\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(1,-1)*.5773;\n    const float eps = .0005;\n    return normalize(e.xyy*map(p + e.xyy*eps) + \n\t\t\t\t\t e.yyx*map(p + e.yyx*eps) + \n\t\t\t\t\t e.yxy*map(p + e.yxy*eps) + \n\t\t\t\t\t e.xxx*map(p + e.xxx*eps));\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat an = .4*iTime; // camera angle\n\tvec3 ro = vec3(cos(an), .2, sin(an)); // ray origin\n    vec3 ta = vec3(0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    // render\n    vec3 tot = vec3(0);\n    \n    #if AA>1\n    for (int m=0; m<AA; m++)\n    for (int n=0; n<AA; n++) {\n        vec2 off = vec2(m,n) / float(AA) - .5; // AA offset\n        vec2 p = (2.*(fragCoord+off) - iResolution.xy) / iResolution.y;\n        #else    \n        vec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n        #endif\n\n        vec3 rd = ca*normalize(vec3(p,1.5)); // ray direction\n\n        // raymarch\n        const float tmax = 5.;\n        float t = 0.;\n        \n        for (int i=0; i<256; i++) {\n            vec3 p = ro + rd*t;\n            float h = map(p);\n            if(h<.0001 || t>tmax) break;\n            t += h;\n        }\n        \n        vec3 col = vec3(0);\n        if (t<tmax) {\n            // lighting\n            vec3 p = ro + rd*t; // hit point\n            vec3 n = calcNormal(p); // surface normal\n            float dif = clamp(dot(n, vec3(.57703)), 0., 1.);\n            float amb = .5+.5*n.y; // fake AO\n            \n            col += vec3(.2,.3,.4)*amb;\n            col += vec3(.8,.7,.5)*dif;\n        }\n\n        col = pow(col, vec3(.4545)); // gamma correction\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}