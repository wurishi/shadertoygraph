{"ver":"0.1","info":{"id":"MdtGRn","date":"1447824980","viewed":231,"name":"Carbon","username":"sixstring982","description":"Carbon atom, first attempt at raymarching","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres","atom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define MAX_RAY_DIST 60.0\n#define CAMERA_DIST 4.0\n#define AUTOSPIN_SPEED 0.5\n#define MOUSE_SENSITIVITY 0.01\n#define EPSILON 0.0001\n#define BG_COLOR vec3(0.2, 0.2, 0.2)\n#define SPEC_POW 8.0\n\n#define PI 3.14159\n#define TAU 6.28318\n\nfloat box(in vec3 pos, in vec3 b) {  \n  vec3 d = abs(pos) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sphere(in vec3 pos, in float radius) {\n    return length(pos) - radius;\n}\n\nfloat opU(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2) {\n    return max(d1, -d2);\n}\n\nfloat opI(in float d1, in float d2) {\n    return max(d1, d2);\n}\n\nfloat map(in vec3 pos) {\n    const float SPHERE_COUNT = 6.0;\n    float m2 = 1e20;\n    \n    for (float i = 0.0; i < SPHERE_COUNT; i++) {\n        float dy = sin(i * (TAU / SPHERE_COUNT));\n        float dz = cos(i * (TAU / SPHERE_COUNT));\n        m2 = opU(m2, sphere(pos + vec3(0.25, 0.25 * dy, 0.25 * dz), 0.25));\n        m2 = opU(m2, sphere(pos + vec3(0.0, 0.25 * dz, 0.25 * dy), 0.25));\n    }\n    \n    for (float i = 0.0; i < SPHERE_COUNT; i++) {\n        float theta = mod(iTime * 2.0 + i * 2.0, TAU);\n        float phi = (TAU / SPHERE_COUNT) * (i * 0.75);\n        float r = 2.0;\n        \n        m2 = opU(m2, sphere(pos + vec3(r * sin(theta) * sin(phi),\n                                       r * sin(theta) * cos(phi),\n                                       r * cos(theta)), 0.2));\n    }\n    \n    return m2;\n}\n\nvec3 colorMap(in vec3 pos) {\n    if (length(pos) < 1.0) {\n        float gb = mix(0.0, 0.75, pos.x * 3.0 + 0.75);\n        return vec3(0.75, gb, gb);\n        \n    } else {\n    \treturn vec3(length(pos) * 0.15,\n\t                length(pos) * 0.2,\n\t                length(pos) * 0.2);\n    }\n}\n\nvec3 normalAt(in vec3 ro) {\n    vec2 ep = vec2(EPSILON, 0.0);\n    return normalize(vec3(map(ro + ep.xyy) - map(ro - ep.xyy),\n                          map(ro + ep.yxy) - map(ro - ep.yxy),\n                          map(ro + ep.yyx) - map(ro - ep.yyx)));\n}\n\nvec3 lighting(in vec3 ro, in vec3 rd) {\n    vec3 n = normalAt(ro);\n    float diffuse = max(0.0, dot(-rd, n));\n    float specular = pow(diffuse, SPEC_POW);\n    vec3 color = colorMap(ro);\n    return color * (diffuse + specular);\n}\n\nvec3 marchRay(in vec3 ro, in vec3 rd) {\n    const int MAX_ITERS = 100;\n    float dist = EPSILON;\n    float totalDist = 0.0;\n    \n    for (int i = 0; i < MAX_ITERS; i++) {\n        if (abs(dist) < EPSILON || totalDist > MAX_RAY_DIST) {\n            break;\n        }\n        \n        dist = map(ro);\n        ro += rd * dist;\n        totalDist += dist;\n    }\n    \n    if (abs(dist) < EPSILON) {\n        return lighting(ro, rd);\n    } else {\n        return BG_COLOR;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = ((fragCoord / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cop = vec3(-CAMERA_DIST * sin(iMouse.x * MOUSE_SENSITIVITY + iTime * AUTOSPIN_SPEED), \n                    CAMERA_DIST * cos(iMouse.y * MOUSE_SENSITIVITY), \n                    CAMERA_DIST * cos(iMouse.x * MOUSE_SENSITIVITY + iTime * AUTOSPIN_SPEED));\n    vec3 target = vec3(0, 0, 0);\n    vec3 up = normalize(vec3(cos(iTime + 1.0), \n                   \t\t\t sin(iTime), \n                             sin(iTime - 1.0)));\n    \n    vec3 cDir = normalize(target - cop);\n    vec3 cRight = normalize(cross(up, cop));\n    vec3 cUp = normalize(cross(cRight, cDir));\n    \n    vec3 rayDir = uv.x * cRight + uv.y * cUp + cDir;\n    \n\tfragColor = vec4(marchRay(cop, rayDir), 1.0);\n}","name":"","description":"","type":"image"}]}