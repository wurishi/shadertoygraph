{"ver":"0.1","info":{"id":"3s3fWH","date":"1604920460","viewed":116,"name":"2D triangle texture renderer","username":"HalbFettKaese","description":"Mainly useful for rasterization.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["triangle","texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nParametric plane equation:\nuv = v1 * t + v2 * s\n I.  uv.x = v1.x * t + v2.x * s\n II. uv.y = v1.y * t + v2.y * s\n \nII. * v1.x; I. * v1.y:\n I.  uv.x * v1.y = v1.x * v1.y * t + v2.x * v1.y * s\n II. uv.y * v1.x = v1.y * v1.x * t + v2.y * v1.x * s\n \nII. * v1.x - I. * v1.y:\n II. uv.y * v1.x - uv.x * v1.y = (v2.y * v1.x - v2.x * v1.y) * s\n II. (uv.y * v1.x - uv.x * v1.y)/(v2.y * v1.x - v2.x * v1.y) = s\n II. s = (uv.y * v1.x - uv.x * v1.y)/(v2.y * v1.x - v2.x * v1.y)\n\nTake initial I. and solve to t\n I.  uv.x = v1.x * t + v2.x * s\n I.  uv.x - v2.x * s = v1.x * t\n I.  (uv.x - v2.x * s)/v1.x = t\n I.  t = (uv.x - v2.x * s)/v1.x\n*/\n\nvec2 solvePlane(vec2 uv, vec2 p1, vec2 p2, vec2 p3) {\n    float eps = 1./max(iResolution.x, iResolution.y);\n    \n\tuv -= p1;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    if (abs(v1.x) < eps) v1.x = eps; // avoiding division by 0\n    float a = (v2.y * v1.x - v2.x * v1.y);\n    if (abs(a) < eps) a = eps; // avoiding division by 0\n    float s = (uv.y * v1.x - uv.x * v1.y)/a;\n    float t = (uv.x - v2.x * s)/v1.x;\n    return vec2(s, t);\n}\n\nvoid triangle(vec2 uv, inout vec3 col, vec2 p1, vec2 p2, vec2 p3, bool f) {\n    float eps = 1./max(iResolution.x, iResolution.y);\n    // Renders triangle if s > 0, t > 0 and s + t < 1, inputs s and t into the texture\n    vec2 params = solvePlane(uv, p1, p2, p3);\n    vec2 tparams = params;\n    if (f) tparams = 1. - tparams;\n\tcol = mix(col, texture(iChannel0, tparams).rgb, step(0., params.x) * step(0., params.y) * (1. - step(1. + eps, params.y + params.x)));\n}\n\nvoid parallelogram(vec2 uv, inout vec3 col, vec2 p1, vec2 p2, vec2 p3) {\n    // Renders parallelogram if 0 < s < 1 and 0 < s < 1, inputs s and t into the texture\n    vec2 params = solvePlane(uv, p1, p2, p3);\n\tcol = mix(col, texture(iChannel0, params).rgb, step(0., params.x) * step(0., params.y) * (1. - step(1., params.x))* (1. - step(1., params.y)));\n}\n\nvoid normalizeUV(inout vec2 uv) {\n\tuv /= iResolution.yy;\n    \n    uv -= .5;\n    \n    uv *= 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    normalizeUV(uv);\n    \n    vec2 M = iMouse.xy;\n    normalizeUV(M);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    triangle(uv, col, M, vec2(1, 0), vec2(0, 1), false);\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}