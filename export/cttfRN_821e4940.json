{"ver":"0.1","info":{"id":"cttfRN","date":"1701225885","viewed":83,"name":"Shoddy Synth Framework. ","username":"DwayneBrah","description":"OK - Meant to just have a fiddle with sound tab, but got waaaaaay too carried away. I really should sync some visuals too.\n\nI almost accidently built a whole godamn synthesezer framework- so addictive... Bedtime now. I will revisit this though!","likes":5,"published":1,"flags":40,"usePreview":0,"tags":["sound","music","audio","synth","musical","chords","midi","tune","instuments","voices"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// OK - Meant to just have a fiddle with sound tab, but got waaaaaay to carried away.\n// I really should sync some visuals too.\n\n// I almost accidently built a whole godamn synthesezer framework- so addictive...\n// Bedtime now. I will revisit this though!\n\n// IF YOU USE THIS - JUST LET ME KNOW WHAT YOU MAKE WITH IT!\n// OR IF YOU NEED SOME HELP WITH THIS KIND OF AUDIO STUFF.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col_a = texture(iChannel0, uv);\n    vec4 col_b = texture(iChannel1, uv);\n    \n    int this_beat = get_current_beat(iTime);\n    float this_beat_progress = get_beat_progress(iTime);\n\n    float kick_progress = 0.00;\n    float inverse_kick_progress = 0.00;\n    if (this_beat % 4 == 0) {\n        kick_progress = this_beat_progress;\n        inverse_kick_progress = 1.00 - kick_progress;\n    };\n    \n    float pulse_amount = clamp(kick_progress*10.0-9.0, 0.0, 1.0);\n    \n    vec4 col_a_zoom = texture(iChannel1, uv-(uv-0.5)/(4.0-pulse_amount));\n\n    \n    vec4 col_out = col_b;\n    \n    \n    \n    // Output to screen\n    fragColor = col_out;\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// OK - Meant to just have a fiddle with sound tab, but got waaaaaay to carried away.\n// I really should sync some visuals too.\n\n// I almost accidently built a whole godamn synthesezer framework- so addictive...\n// Bedtime now. I will revisit this though!\n\n// IF YOU USE THIS - JUST LET ME KNOW WHAT YOU MAKE WITH IT!\n// OR IF YOU NEED SOME HELP WITH THIS KIND OF AUDIO STUFF.\n\n\nvec2 mainSound( int samp, float time )\n{\n    \n    vec2 sound_out = vec2(0.0,0.0);\n    \n    \n    // TIMINGS\n    \n    int this_beat = get_current_beat(time);\n    int this_bar = get_current_bar(time);\n    float this_beat_progress = get_beat_progress(time);\n    float this_bar_progress = get_beat_progress(time/16.0);\n    float inverse_beat_progress = 1.0-this_beat_progress;\n    \n    \n    // PREPAIR CHORD AND KEY\n    \n    float[4] pitches = pitches_from_key_chord(get_current_chord(time), get_current_key(time));\n    float[4] pitches_oct = pitches_from_key_chord(get_current_chord(time), get_current_key(time)+12);\n    float[4] pitches_oct_down = pitches_from_key_chord(get_current_chord(time), get_current_key(time)-12);\n    \n    \n    // RHYTHM/ARP SYNTH //\n    vec2 synth_arp = delayed_arpeggiated_rhythm(time, pitches);\n    synth_arp += delayed_arpeggiated_rhythm(time, pitches_oct_down);\n\n\n    // RHYTHM/ORGAN-CHORDS SYNTH //\n    vec2 synth_chords = synth_1_poly(time, pitches);\n    vec2 synth_chords_drone = synth_1(time*0.75, (pitches[this_bar%3]) * (1.0 + (sin(time*50.0)*(0.000005*this_bar_progress))) );\n    // 2 OCTS DOWN, QUIETLY FOR ADDED BODY\n    synth_chords += synth_1_poly(time, pitches_oct)*0.25; \n    \n    \n    // ECHO - SHOULD THIS BE A BUS?\n    \n    float delay_spacing = duration_16th/1.3;\n    for (int delay = 1; delay < 4; delay++) {\n        \n        vec2 d = synth_1_poly(time - delay_spacing*float(delay), pitches);\n        d *= (0.35/float(delay));\n        \n        int ping_pong = delay % 2;\n        if (ping_pong == 0) {\n            d *= vec2(0.6, 1.0);\n        } else {\n            d *= vec2(1.0, 0.6);\n        };\n        \n        \n        synth_chords -= d;\n        \n        \n    };\n    \n    \n    \n    \n    // BASS\n    \n    vec2 synth_bass = synth_arpeggiated_bass(time, pitches);\n    \n    \n    \n    // DRUMS //\n    \n    vec2 drum_kick = vec2(0.0,0.0);\n    float kick_progress = 0.09;\n    if (this_beat % 4 == 0) {\n        kick_progress = this_beat_progress;\n        drum_kick += synth_kick(kick_progress);\n    };\n    \n    vec2 drum_highhat = vec2(0.0,0.0);\n    if (true) {\n        // ACCENT ATTRIBUTE FOR VARIATION\n        float accent = float(this_beat % 4)+6.0;\n        drum_highhat += synth_highhat(this_beat_progress, accent);\n    };\n    \n    vec2 drum_snare = vec2(0.0,0.0);\n    if (this_beat % 8 == 4) {\n        // \"STEREOIZE\" SARE WITH QUICK DELAY FOR CLAPPY EFFECT\n        drum_snare += synth_snare(this_beat_progress) * vec2(1.0,0.5);\n        drum_snare += synth_snare(this_beat_progress+0.15)* vec2(0.5,1.0);\n    };\n    \n    \n    \n    // FAKEY DYNAMICS/COMPRESSION/GATING //\n    \n    synth_chords *= (1.0 - kick_progress*kick_progress*0.05);\n    drum_highhat *= (1.0 - kick_progress*0.55);\n    synth_bass *= (1.0 - kick_progress*kick_progress*0.75);\n    synth_arp *= (1.0 - kick_progress*kick_progress*0.75);\n    synth_chords_drone *= (1.0 - kick_progress*1.00);\n    \n    float  master_volume = 0.33;\n    \n    // PARTS/BUS-VOLUME //\n    \n    // INTRO //\n    if (this_bar < 16) {\n    \n        float intro_progress = float(this_bar)/16.0;\n        \n        drum_kick *= 0.0;\n        drum_highhat *= intro_progress; \n        drum_snare *= 0.0;\n        synth_bass *= 0.0;\n        \n        \n        if (this_bar < 8) {\n            synth_arp *= 0.0;\n            synth_chords_drone *= 0.0;\n        } else {\n            synth_arp *= clamp(intro_progress*2.0-0.75, 0.0, 1.0);\n        };\n        \n        if (this_bar == 15 && this_bar_progress > 0.5) {\n        \n            synth_chords *= 0.0;\n            drum_highhat *= 0.0;\n            //synth_chords_drone *= 0.0;\n\n        };\n        \n    } else {\n        \n        bool is_verse = int(float(this_bar%32) / 16.0) == 0;\n        bool is_last_bar = this_bar%16 == 15;\n        \n        if (is_verse && !is_last_bar) {\n            synth_chords *= 0.25;\n            synth_arp *= 0.0;\n            drum_snare *= 0.6;\n        } else {\n            synth_chords_drone *= 0.0;\n        };\n        \n        if (is_last_bar) {\n            synth_chords *= 0.0;\n            drum_highhat *= 0.0;\n            drum_kick *= 0.0;\n            synth_bass *= 0.0;\n            //synth_chords_drone *= 0.0;\n        };\n    \n    };\n    \n    \n    // MIXING //\n    \n    sound_out += drum_kick*1.00;\n    sound_out += drum_highhat*0.06;\n    sound_out += drum_snare*0.60;\n    \n    sound_out += synth_bass*0.75;\n    \n    sound_out += synth_chords*0.65;\n    sound_out += synth_chords_drone*0.40;\n    sound_out += synth_arp*0.29;\n    \n    sound_out *= master_volume;\n    \n    return vec2( sound_out );\n    \n}\n\n\n","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"\n// OK - Meant to just have a fiddle with sound tab, but got waaaaaay to carried away.\n// I really should sync some visuals too.\n\n// I almost accidently built a whole godamn synthesezer framework- so addictive...\n// Bedtime now. I will revisit this though!\n\n// IF YOU USE THIS - JUST LET ME KNOW WHAT YOU MAKE WITH IT!\n// OR IF YOU NEED SOME HELP WITH THIS KIND OF AUDIO STUFF.\n\n#define middle_c 523.25 \n#define PI2 6.2831\n#define twelfth_root 1.059463094359\n\n\n#define song_speed        108.00\n#define duration_16th     (60.00/108.00) / 4.00\n\n// 0 = MAJOR, 1 = MINOR, 2 = 7th, 3 = m7TH //\nint[8] chord_type_sequence = int[8](\n    \n    1, 2, 1, 3,\n    1, 2, 1, 3\n    \n);\n// 0 = MIDDLE C, -12 = C 1 OCT DOWN, 2 = MIDDLE D ETC //\nint[8] key_sequence = int[8](\n    \n    -12, -9, -7, -7,\n    -12, -9, -5, -5\n    \n);\n\n// CHORD SPACINGS\nint[3] chord_major = int[3](\n    4,\n    7,\n    12\n);\nint[3] chord_minor = int[3](\n    3,\n    7,\n    12\n);\nint[3] chord_major_7th = int[3](\n    4,\n    7,\n    11\n);\nint[3] chord_minor_7th = int[3](\n    3,\n    7,\n    10\n);\n// I SHOULD USE ENVELOPES 100% OF TIME INSTEAD OF ON-THE-FLY FORMULA\nfloat[4] env_array_1  = float[4] (\n\n    0.02,    // ATTACK\n    0.20,    // DECAY\n    0.30,    // SUSTAIN\n    00.00    // RELEASE (NOT IMPLEMENTED YET)\n    \n);\nfloat get_envelope(float note_progress, float[4] env_array) {\n    \n    int current_stage = -1;\n    float stage_start = 0.0;\n    float stage_end;\n    float stage_progress;\n    \n    float envelope_value = 0.0;\n    \n    if (note_progress <= env_array[0]) {\n        current_stage = 0;\n        stage_start = 0.0;\n        stage_end = env_array[0];\n    };\n    if (note_progress > env_array[0]) {\n        current_stage = 1;\n        stage_start = env_array[0];\n        stage_end = stage_start + env_array[1];\n    };\n    if (note_progress > env_array[0] + env_array[1]) {\n        current_stage = 2;\n        stage_start = env_array[0] + env_array[1];\n        stage_end = stage_start + env_array[2];\n    };\n    \n    float stage_length = (stage_end-stage_start); \n    stage_progress = (note_progress-stage_start) / stage_length; \n    \n    if (current_stage == 0) {\n        envelope_value = stage_progress;\n        //envelope_value = 0.5;\n    };\n    if (current_stage == 1) {\n        envelope_value = 1.0;\n    };\n    if (current_stage == 2) {\n        envelope_value = 1.0-stage_progress;\n        //envelope_value *= envelope_value;\n    };\n    \n    if (note_progress > stage_end) {\n        envelope_value = 0.0;\n    };\n    \n    return(envelope_value*envelope_value);\n    \n}\nint[4] chord_from_key (int[3] chord_spacing, int key) {\n    \n    int[4] notes_out = int[4](\n        key,\n        key + chord_spacing[0],\n        key + chord_spacing[1],\n        key + chord_spacing[2]\n    );\n    \n    return(notes_out);\n    \n}\n\nfloat[12] custom_waveform_organ = float[12](\n    -0.6,\n    -0.7,\n    -0.4,\n    -0.0,\n     0.5,\n     0.8,\n     1.0,\n     0.7,\n     0.5,\n     0.1,\n    -0.4,\n    -1.0\n);\n\nfloat[12] custom_waveform_bass = float[12](\n    -0.6,\n     0.1,\n    -0.4,\n    -0.0,\n     0.5,\n     0.8,\n     1.0,\n     0.7,\n    -0.5,\n     0.1,\n    -0.4,\n    -1.0\n);\n\nfloat[12] custom_waveform_arp = float[12](\n    -0.6,\n     0.1,\n     0.4,\n    -0.0,\n     0.5,\n     0.8,\n     1.0,\n     -0.2,\n    -0.5,\n     0.1,\n    -0.4,\n    -1.0\n);\n\nfloat get_beat_progress (float time) {   \n    \n    //float beat_progress = mod(time/1.00, duration_16th) / (duration_16th);\n    //return(beat_progress); \n    \n    int current_beat = int((time*16.00)/duration_16th);\n    float beat_progress = (time*16.00)/duration_16th - float(current_beat);\n    \n    return(beat_progress);\n    \n}\nint get_current_beat (float time) {\n    \n    int current_beat = int((time*16.00)/duration_16th) % 16;\n    return(current_beat);\n    \n}\nint get_current_beat_full (float time) {\n    \n    int current_beat = int((time*16.00)/duration_16th);\n    return(current_beat);\n    \n}\nint get_current_bar (float time) {\n    \n    //int current_bar = int((time/2.00)/beat_duration) % 16;\n    int current_bar = int((time)/duration_16th);\n    return(current_bar);\n    \n}\nint get_current_key (float time) {\n    \n    int current_bar = get_current_bar(time);\n    return(key_sequence[current_bar%8]);\n    \n}\nint[3] get_current_chord (float time) {\n    \n    int bar = get_current_bar(time);\n    int chord_type = chord_type_sequence[bar%8];\n    \n    \n    int[3] chord = chord_major;\n    \n    if (chord_type == 1) {\n        chord = chord_minor;\n    };\n    if (chord_type == 2) {\n        chord = chord_major_7th;\n    };\n    if (chord_type == 3) {\n        chord = chord_minor_7th;\n    };\n    \n    return(chord);\n\n    \n}\n\nfloat pitch_from_note(int note) {\n    \n    float pitch = middle_c * pow(twelfth_root, float(note));\n    \n    return(pitch);\n    \n}\nfloat[4] pitches_from_key_chord(int[3] chord_spacing, int key) {\n    \n    int[4] chord_notes = chord_from_key(chord_spacing, key);\n    \n    float[4] pitches_out = float[4](\n        1.0 + (pitch_from_note(chord_notes[0])),\n        1.0 + (pitch_from_note(chord_notes[1])),\n        1.0 + (pitch_from_note(chord_notes[2])),\n        1.0 + (pitch_from_note(chord_notes[3]))\n    );\n    \n    \n    return(pitches_out);\n\n}\n\n\n\nfloat to_custom_wav_smooth(float phase, float[12] custom_waveform) {\n\n    phase = mod(phase, 1.0);\n    \n    int segment = int(phase*12.0) % 12;\n    int next_segment = int(phase*12.0+1.0) % 12;\n    \n    float next_value = custom_waveform[next_segment];\n    float this_value = custom_waveform[segment];\n    \n    float segment_progress = phase*12.0 - float(segment);\n    float inverted_segment_progress = 1.0-segment_progress;\n    \n    float wav_out = next_value*segment_progress + this_value*inverted_segment_progress;\n    \n    return(wav_out);\n    \n}\n\nfloat to_custom_wav(float phase, float[12] custom_waveform) {\n    \n    int segment = int(phase*12.0);\n    float wav_out = custom_waveform[segment];\n    \n    return(wav_out);\n\n}\n\nfloat to_sin_wav(float phase) {\n    \n    float wav_out = sin(phase*PI2);\n    \n    return(wav_out);\n\n}\n\n\n\n\nfloat ramp_wav (float time, float pitch) {\n    \n    float ramp = mod(time*pitch, 1.0);\n    \n    return( ramp );\n    \n}\nfloat sin_wav (float time, float pitch) {\n    \n    float wav_out = sin(time*pitch*PI2);\n    \n    return( wav_out );\n    \n}\nfloat ramp_wav_phased (float time, float pitch, float phase_shift) {\n    \n    float ramp = ramp_wav(time+phase_shift, pitch);\n    \n    return( ramp );\n    \n}\n\n/////////////////////////// RANDOM GENERATOR ////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(float time){\n    seed = uint(time*0.11 + time*0.23)+uint(time*0.33)*uint(20.22);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////// RANDOM GENERATOR ////////////////////////////\n\nfloat noise_wav (float time) {\n\n    initRandomGenerator(time);\n    float level = mod(random(), 1.0)*2.0 - 1.0;    \n    \n    return( level );\n\n\n}\n\n\n\n\n\n///////////// DRUMS //////////////////\n\nvec2 synth_kick (float beat_phase) {\n    \n    float inverse_beat_phase = 1.0-beat_phase;\n    inverse_beat_phase *= inverse_beat_phase;\n    float kick = sin(beat_phase*(100.0*inverse_beat_phase+70.0));\n    kick *= inverse_beat_phase*2.0;\n    \n    // FAKEY DSITORTION\n    kick = clamp(kick, -0.50, 0.50) + kick;\n    kick *= 2.0;\n    \n    vec2 sound_out = vec2(kick, kick);\n    \n    return( sound_out );\n\n}\n\nvec2 synth_highhat (float beat_phase, float accent) {\n    \n    float highhat = noise_wav(beat_phase*(11000.0+accent*2000.0));\n    highhat += noise_wav((beat_phase)*(9000.0-accent*2000.0));\n    highhat += noise_wav((beat_phase)*(9000.0-accent*2000.0));\n    float inverse_beat_phase = 1.0-beat_phase;\n    inverse_beat_phase *= inverse_beat_phase*inverse_beat_phase*(1.0+(accent*0.50));    \n    highhat *= inverse_beat_phase;\n    \n    vec2 sound_out = vec2(highhat, highhat);\n    sound_out *= 1.0;\n    \n    \n    return( sound_out );\n\n}\n\nvec2 synth_snare (float beat_phase) {\n    \n    float snare = noise_wav(beat_phase*1600.0)*1.5;\n    snare += noise_wav((beat_phase+0.01)*2400.0)*2.0;\n    snare += noise_wav(beat_phase*2500.0)*2.0;\n    \n    snare += sin(beat_phase*170.0)*0.70;\n    \n    float inverse_beat_phase = 1.0-beat_phase;\n    inverse_beat_phase *= inverse_beat_phase*inverse_beat_phase;    \n    snare *= inverse_beat_phase;\n\n    \n    // FAKEY DSITORTION\n    snare *= 2.0;\n    snare = clamp(snare, -0.70, 0.70) + snare*0.50;\n    \n    vec2 sound_out = vec2(snare, snare);\n    sound_out *= 1.0;    \n    return( sound_out );\n\n}\n\n\n\n///////////// SYNTHS /////////////////\n\n\n\nvec2 synth_1 (float time, float pitch) {\n    \n    vec2 sound_out = vec2(0.0, 0.0);\n    \n    // LFOs //\n    float lfo_1 = sin_wav(time, 0.61)*0.75;\n    float lfo_2 = sin_wav(time, 0.43)*0.75;\n    float lfo_3 = sin_wav(time, 0.71)*0.75;\n    \n    // PHASE PROGRESSES //\n    float phase = ramp_wav(time, pitch);\n    float phase_h1 = ramp_wav(time, pitch*2.0);\n    float phase_h2 = ramp_wav(time, pitch/2.0);\n    \n    // VOICES //\n    float voice_1 = to_custom_wav_smooth(phase, custom_waveform_organ);\n    float voice_2 = to_custom_wav_smooth(phase+lfo_1, custom_waveform_organ);\n    float voice_3 = to_custom_wav_smooth(phase_h1+lfo_2, custom_waveform_organ);\n    float voice_4 = to_custom_wav_smooth(phase_h2+lfo_2, custom_waveform_organ);\n\n    \n    sound_out += voice_1*0.50;\n    sound_out += voice_2*0.40;\n    sound_out -= voice_3*0.40;\n    sound_out -= voice_4*0.30;\n    \n    return(sound_out);\n    \n}\nvec2 synth_1_poly (float time, float[4] pitches) {\n    \n    vec2 w1 = synth_1( time, pitches[0] );\n    vec2 w2 = synth_1( time, pitches[1] );\n    vec2 w3 = synth_1( time, pitches[2] );\n    vec2 w4 = synth_1( time, pitches[3] );\n    \n    vec2 mixed = w1+w2+w3+w4;\n    \n    if (get_current_beat(time)%3 != 0) {\n        mixed *= 0.00;\n    };\n    \n    return( mixed*0.75 );\n    \n}\n\nvec2 synth_arpeggiated_bass (float time, float[4] pitches) {\n    \n    int this_beat = get_current_beat(time);\n    \n    int pitch_for_bass = 0;\n    float synth_bass_level = 0.0;\n    if (this_beat % 4 == 3) {pitch_for_bass = 3;};\n    if (this_beat % 8 == 7) {pitch_for_bass = 2;};\n    if (this_beat % 16 == 13) {pitch_for_bass = 1;};\n    \n    // VOICES\n    float phase_wav = ramp_wav(time, pitches[pitch_for_bass]*0.25);\n    synth_bass_level += to_custom_wav_smooth(phase_wav, custom_waveform_bass)*2.5;\n\n    phase_wav = ramp_wav(time, pitches[pitch_for_bass]*0.507);\n    synth_bass_level += to_custom_wav_smooth(phase_wav, custom_waveform_bass)*0.55;\n\n    float phase_wav_down = ramp_wav(time, pitches[pitch_for_bass]*0.50);\n    synth_bass_level += to_custom_wav_smooth(phase_wav_down, custom_waveform_bass)*0.30;\n    \n    // ENVELOPE //\n    float this_beat_progress = get_beat_progress(time);\n    float inverse_beat_progress = 1.0-this_beat_progress;\n    synth_bass_level *= clamp(inverse_beat_progress*1.50, 0.20, 1.00)-0.20;\n    \n    // DISTORTION //\n    synth_bass_level = clamp(synth_bass_level*1.20, -0.70, 0.70) * (1.0/0.50);\n    \n    vec2 synth_bass = vec2(synth_bass_level, synth_bass_level);\n    \n    return( synth_bass * 0.65 );\n    \n}\n\n\n// RHYTHM PORTAMENTO-ARPEGGIO SYNTH //\n\nfloat arped_pitch (int this_beat, float[4] pitches) { \n    int arp_index = this_beat%12;\n    int arp_pitch = arp_index % 4;\n\n    int arp_oct;\n    if (this_beat%2 == 0) {\n        arp_oct = int(float(this_beat-6)/3.0) % 3;\n    } else {\n        arp_oct = int(float(this_beat)/3.0) % 3;\n    };\n\n    float chosen_pitch = pitches[arp_pitch];\n    chosen_pitch *= pow(2.0, float(arp_oct));\n    return(chosen_pitch);\n\n}\n\nvec2 synth_arpeggiated_rhythm (float time, float[4] pitches) {\n    \n    int this_beat = get_current_beat_full(time);\n    float this_beat_progress = get_beat_progress(time);\n    \n    // ARP OVER SEVERAL OCTAVES\n    float this_pitch = arped_pitch(this_beat, pitches);\n    float last_pitch = arped_pitch(this_beat-1, pitches);\n    \n    // PORTAMENTO PITCHBEND\n    float portamento_progress = clamp(this_beat_progress*1.50+0.88, 0.00, 1.0);\n    this_pitch = mix(this_pitch, last_pitch, 1.0-portamento_progress);\n    \n    // VOICES\n    vec2 arp_level = vec2(0.0, 0.0);\n    float phase_wav = ramp_wav(time, this_pitch);\n    float phase_wav_1 = ramp_wav(time, this_pitch * 0.500 );\n    float phase_wav_1_b = ramp_wav(time, this_pitch * 0.505 );\n    float phase_wav_2 = ramp_wav(time, this_pitch * pow(twelfth_root, 5.0));\n    arp_level += to_custom_wav_smooth(phase_wav, custom_waveform_arp);\n    arp_level += to_custom_wav_smooth(phase_wav_1, custom_waveform_arp);\n    arp_level += to_custom_wav_smooth(phase_wav_1_b, custom_waveform_arp);\n    arp_level += to_custom_wav_smooth(phase_wav_2, custom_waveform_arp)*0.30;\n    \n    \n    // ENVELOPE //\n    arp_level *= get_envelope(this_beat_progress*1.10, env_array_1);\n    \n    // DISTORTION //\n    arp_level = clamp(arp_level, -0.50, 0.50)+arp_level;\n    \n    vec2 synth_arp = arp_level;\n    \n    // PAN\n    int panpos = this_beat % 3;\n    synth_arp.x *= 0.5 + float(panpos)/2.0;\n    synth_arp.y *= 0.5 + float(2-panpos)/2.0;\n    \n    \n    return( synth_arp * 0.50 );\n\n    \n}\n\n\nvec2 delayed_arpeggiated_rhythm (float time, float[4] pitches) {\n    \n    vec2 filtered_arp;\n    filtered_arp += synth_arpeggiated_rhythm(time, pitches);\n    filtered_arp += synth_arpeggiated_rhythm(time/2.0, pitches)*0.75;\n\n\n    float delay_spacing = duration_16th*3.04;\n    for (int delay = 1; delay < 4; delay++) {\n        \n        float back_time = delay_spacing*float(delay);\n        \n        vec2 d = synth_arpeggiated_rhythm(time - back_time, pitches);\n        d *= (0.65/float(delay));\n        \n        if (time - back_time < 0.0) {\n            d *= 0.0;\n        };\n        \n        int ping_pong = delay % 2;\n        if (ping_pong == 0) {\n            d *= vec2(1.0, 0.5);\n        } else {\n            d *= vec2(0.5, 1.0);\n        };\n        \n        filtered_arp += d;\n\n    };\n    \n    return( filtered_arp * 1.00 );\n\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col_a = texture(iChannel0, uv);\n    vec4 col_b = texture(iChannel1, uv);\n    \n    vec4 col_out = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float pitch = pitch_from_note(0);\n    float phase_duration = 1.0/pitch; \n        \n    float x_time = uv.x*0.01 + phase_duration*float(iFrame); \n\n    //float x_time = uv.x*0.01 + iTime; \n    float synth_1_ramp = ramp_wav(x_time, pitch);\n    \n    //float synth_1 = to_custom_wav(synth_1_ramp);\n    float synth_1_smooth = to_custom_wav_smooth(synth_1_ramp, custom_waveform_organ);\n    \n        \n    float[3] graphs = float[3](\n        synth_1_ramp,\n        synth_1_smooth,\n        synth_1(x_time, middle_c).x\n    );\n    \n    for (int g = 0; g < 3; g++) {\n        \n        float this_level = graphs[g] / 6.0;\n        int this_y_graph = int(uv.y*3.0);\n        \n        float y_base = (1.0-1.0/6.0) - (float(g)/3.00);\n        \n        \n        vec2 uv_graph = vec2(uv.x, uv.y-y_base);\n        float line_width = 0.01;\n        \n        col_out += float(this_y_graph)*0.02;\n\n        if (uv_graph.y > this_level && uv_graph.y < this_level+line_width) {\n            col_out  += 0.20;\n        };\n        if (uv_graph.y < this_level) {\n            col_out  += 0.10;\n        };\n\n\n        \n    };\n\n    \n    \n    \n    fragColor = col_out;\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float ar;\nvec2 outTexCoord;\nvec4 final_color;\n\n// A 2D point, moving in time with a sine wave function \nfloat dist_moving(float x_speed, float y_speed, float ripple_speed) {\n\t\n    // Centre and correct aspect ratio\n\tvec2 corrected_coord = vec2(outTexCoord.x*ar-0.50, outTexCoord.y);\n\t\n    // Set pace\n\tfloat time_adjusted = iTime*1.25;\n\t\n    // The point and distance from curent XY\n\tvec2 point_1 = vec2(0.5*(sin(time_adjusted*x_speed)+1.00), 0.5*(sin(time_adjusted*y_speed)-0.50)+1.00);\n\tfloat point_1_dist = distance(point_1, corrected_coord);\n\t\n    // Adjust distance scale ratio and return distance value\n\tfloat distance_multiplyer = 0.50;\n    return(point_1_dist*distance_multiplyer);\n\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Set aspect ratio\n    ar = iResolution.x/iResolution.y;\n\n    // Normalise X & Y\n    outTexCoord = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n    \n    // Create points and ripple the distance with a sine function\n\tfloat point_1_dist = dist_moving(-0.11, 0.17, 0.00);\n\tfloat point_1_dist_rippled = sin((point_1_dist)*30.00);\n\t\n\tfloat point_2_dist = dist_moving(0.04, -0.09, 0.04);\n\tfloat point_2_dist_rippled = sin(point_2_dist*30.00);\n\t\n\tfloat point_3_dist = dist_moving(0.09, 0.07, 0.33);\n\tfloat point_3_dist_rippled = sin(point_3_dist*30.00);\n\t\n\t// Create the coloured 'layer' \n\tvec4 colorful_rings = vec4(abs(point_1_dist_rippled), abs(point_2_dist_rippled), abs(point_3_dist_rippled), 1.00);\n\t\n    // Create the black & white 'layer' and ripple with a sinwave\n\tfloat color_intensity = (colorful_rings.r+colorful_rings.g+colorful_rings.b)/3.00;\n\tvec4 bw_rings = vec4(color_intensity, color_intensity, color_intensity, 1.00);\n\tfloat bw_rings_rippled = (sin(color_intensity*20.00));\n\t\n    // Chose between 'layers'\n    if (bw_rings_rippled > 0.50) {\n\t\tfinal_color = colorful_rings*colorful_rings;\n\t} else {\n\t\tfinal_color = vec4(bw_rings_rippled, bw_rings_rippled, bw_rings_rippled, 1.00);\n\t};\n\t\n\t// Output colour\n\tfragColor = final_color;\n\t\n}\n","name":"Buffer B","description":"","type":"buffer"}]}