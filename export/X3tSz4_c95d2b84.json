{"ver":"0.1","info":{"id":"X3tSz4","date":"1719127778","viewed":59,"name":"Pulse Object","username":"miguel000","description":"Object Pulse\nI made it with reference to https://www.shadertoy.com/view/lt3BW2","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Calc Intersection between ray and box\n// https://iquilezles.org/articles/boxfunctions/\n\n#define MAX_RAYMARCH_NUM 70\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metalness;\n};\n\nMaterial mixMaterial( Material a, Material b, float rate )\n{\n    Material ret_val;\n    ret_val.albedo = mix( a.albedo, b.albedo, rate );\n    ret_val.roughness = mix( a.roughness, b.roughness, rate );\n    ret_val.metalness = mix( a.metalness, b.metalness, rate );\n    \n    return ret_val;\n}\n\n#define SPHERE_NUM 16\nMaterial calcMaterial( int idx )\n{\n    Material mat;\n    \n    float phase = mod( iTime, float( SPHERE_NUM ) );\n    int main_index = int( floor( phase ) );\n    int next_index = ( main_index + 1 ) % SPHERE_NUM;\n    \n    float phase_rate = pow( fract( 1.0 - phase ), 5.0 );\n    float rate = main_index == idx ? phase_rate\n                 : next_index == idx ? 1.0 - phase_rate\n                 : 0.0;\n                 \n    \n    Material mat_a;\n    mat_a.albedo = vec3( 0.3 );\n    mat_a.roughness = 0.9;\n    \n    Material mat_b;\n    mat_b.albedo = vec3( 1.0, 0.1, 0.1 );\n    mat_b.roughness = 0.1;\n    \n    return mixMaterial( mat_a, mat_b, rate );\n}\n\nvec3 calcSpherePos( int idx )\n{\n    float pos_radius = 1.2;\n    \n    float rad = radians( float(idx) * 360.0 / float( SPHERE_NUM ) );\n    return vec3( cos( rad ) * pos_radius, 0.4 + sin( float(idx) * 1234.5 + iTime ) * 0.06, sin( rad ) * pos_radius );\n}\n\nfloat calcSphereRadius( int idx )\n{\n    float phase = mod( iTime, float( SPHERE_NUM ) );\n    int main_index = int( floor( phase ) );\n    int next_index = ( main_index + 1 ) % SPHERE_NUM;\n    \n    float phase_rate = pow( fract( 1.0 - phase ), 5.0 );\n    float rate = main_index == idx ? phase_rate\n                 : next_index == idx ? 1.0 - phase_rate\n                 : 0.0;\n                 \n    return mix( 0.25 + sin( iTime + 3456.7 * float(idx) ) * 0.02, 0.34, rate );\n}\n\nvoid map_sdf( out float out_sdf, out Material out_mat, in vec3 pos )\n{\n    out_sdf = pos.y; // Ground Plane\n    \n    out_mat.albedo = vec3( 0.8 ); // Ground Plane Material\n    out_mat.metalness = 0.0;\n    \n    if( sdBox( pos - vec3(0.0,2.0,0.0), vec3(5.0,4.0,5.0) ) < out_sdf )\n    {\n        float pos_radius = 1.2;\n        \n        float phase = fract( iTime );\n        float smooth_dist = pow( max( phase, 1.0 - phase ) * 2.0 - 1.0, 5.0 ) * 0.03 + 0.02;\n        \n        float sdf = sdSphere( pos - calcSpherePos(0), calcSphereRadius(0) );\n        Material mat = calcMaterial( 0 );\n        for( int i = 1; i < SPHERE_NUM; ++i )\n        {\n            float rad = radians( float(i) * 360.0 / float( SPHERE_NUM ) );\n            \n            vec3 sphere_pos = calcSpherePos( i );\n            \n            float a = sdSphere( pos - sphere_pos, calcSphereRadius(i) );\n            vec2 result = opSmoothUnion( sdf, a, smooth_dist );\n            sdf = result.x;\n            mat = mixMaterial( mat, calcMaterial( i ), result.y );\n        }\n        \n        if( sdf < out_sdf )\n        {\n            out_sdf = sdf;\n            out_mat = mat;\n        }\n    }\n}\n\nvoid raycast( out float out_dist, out Material out_mat, in vec3 ray_origin, in vec3 ray_dir )\n{\n    out_dist = -1.0;\n\n    float dist_min = 1.0;\n    float dist_max = 20.0;\n    float dist = -1.0;\n\n    // floor plane\n    {\n        const float floor_height = 0.0;\n        float dist_floor = ( floor_height - ray_origin.y ) / ray_dir.y;\n        if( dist_floor > 0.0 )\n        {\n            dist_max = min( dist_max, dist_floor );\n            dist = dist_floor;\n            \n            out_mat.albedo = vec3( 0.8 );\n            out_dist = dist;\n        }\n    }\n    \n    // spheres\n    {\n        float box_enter_dist, box_exit_dist;\n        BoxIntersection( box_enter_dist, box_exit_dist, ray_origin, ray_dir, vec3( 0.0, 0.5, 0.0 ), vec3( 3.0, 0.5, 3.0 ) );\n        \n        if( box_enter_dist < box_exit_dist && box_exit_dist > 0.0 && box_enter_dist < dist_max )\n        {\n            dist_min = max( dist_min, box_enter_dist );\n            dist_max = min( dist_max, box_exit_dist );\n            \n            float dist = dist_min;\n            for( int i = 0; i < MAX_RAYMARCH_NUM && dist < dist_max; i++ )\n            {\n                vec3 pos = ray_origin + ray_dir * dist;\n                \n                float sdf;\n                Material mat;\n                map_sdf( sdf, mat, pos );\n                \n                if( abs(sdf)<(0.0005*dist) )\n                { \n                    out_dist = dist;\n                    out_mat = mat;\n                    break;\n                }\n                dist += sdf;\n            }\n        }\n    }\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        float sdf;\n        Material mat;\n        map_sdf( sdf, mat, pos+0.0005*e );\n        n += e*sdf;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float dist = 0.01 + 0.03*float(i);\n        \n        float sdf;\n        Material mat;\n        map_sdf( sdf, mat, pos + dist*nor );\n        \n        occ += (dist-sdf)*sca;\n        sca *= 0.95;\n        \n        if( occ>0.35 ) break;\n    }\n    \n    float norm_y_01 = 0.5 + 0.5*nor.y;\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * norm_y_01;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ray_origin, in vec3 ray_dir, in float min_dist, in float max_dist )\n{\n    // bounding volume\n    float tp = ( 0.8 - ray_origin.y ) / ray_dir.y;\n    if( tp>0.0 )\n    {\n        max_dist = min( max_dist, tp );\n    }\n\n    float res = 1.0;\n    float dist = min_dist;\n    for( int i=0; i<70; i++ )\n    {\n        \n\t\tfloat sdf;\n        Material mat;\n        map_sdf( sdf, mat, ray_origin + ray_dir * dist );\n        float s = clamp( 8.0 * sdf / dist, 0.0, 1.0);\n        res = min( res, s );\n        dist += clamp( sdf, 0.01, 0.2 );\n        if( res<0.004 || dist>max_dist ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 render( in vec3 ray_origin, in vec3 ray_dir, in vec3 rdx, in vec3 rdy )\n{\n    // background\n    vec3 col = vec3(0.1);\n    \n    float dist;\n    Material mat;\n    raycast(\n        dist\n        , mat\n        , ray_origin\n        , ray_dir\n        );\n    \n    if( dist > 0.0 )\n    {\n        vec3 lin = vec3(0.0);\n        \n        vec3 pos = ray_origin + dist * ray_dir;\n        vec3 nor = /* (m<1.5) ? vec3(0.0,1.0,0.0) : */ calcNormal( pos );\n        vec3 ref = reflect( ray_dir, nor );\n        \n        vec3 light_dir = normalize( vec3(-0.5, 0.6, -0.6) );\n        \n        float occ = calcAO( pos, nor );\n        \n        float ks = 1.0 - mat.roughness;\n        \n        // sun\n        {\n            // diffuse\n            float diffuse = clamp( dot( nor, light_dir ), 0.0, 1.0 );\n            diffuse *= calcSoftshadow( pos, light_dir, 0.02, 2.5 );\n\n            // specular\n            vec3 half_vec = normalize( light_dir-ray_dir ); // half vector\n            float specular = pow( clamp( dot( nor, half_vec ), 0.0, 1.0 ),16.0);\n            // specular *= dif;\n            specular *= 0.04+0.96*pow(clamp(1.0-dot(half_vec, light_dir),0.0,1.0),5.0);\n\n            lin += mix( mat.albedo, vec3( 0.0 ), mat.metalness ) * diffuse;\n            lin += mix( vec3( 1.0 ), mat.albedo, mat.metalness ) * ks * specular;\n        }\n        \n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,ray_dir),0.0,1.0), 5.0 );\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15) * mix( mat.albedo, vec3( 0.0 ), mat.metalness );\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30) * ks * mix( vec3( 1.0 ), mat.albedo, mat.metalness );\n        }\n        \n        col = lin;\n    }\n    \n    return vec3( col );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 screen_pos = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\n    float time = 32.0 + iTime*1.5;\n    vec3 target = vec3( 0.0, 1.0, 0.0 );\n    vec3 ray_origin = target + vec3( 4.5*cos(0.1*time + 7.0*mouse.x), 2.2, 4.5*sin(0.1*time + 7.0*mouse.x) );\n    // vec3( 0.0, 3.0, -4.0 );\n    \n    mat3 camera = MakeCameraMtx( ray_origin, target, vec3( 0.0 ) );\n\n    const float cFovy = 30.0;\n    float focal_length = 1.0 / tan( radians( cFovy ) * 0.5 );\n    \n    vec3 ray_dir = normalize( vec3( screen_pos, focal_length ) );\n    ray_dir = camera * ray_dir;\n    \n    // ray differentials\n    vec2 px = ( 2.0 * ( fragCoord + vec2( 1.0, 0.0 ) ) - iResolution.xy ) / iResolution.y;\n    vec2 py = ( 2.0 * ( fragCoord + vec2( 0.0, 1.0 ) ) - iResolution.xy ) / iResolution.y;\n    vec3 rdx = camera * normalize( vec3( px, focal_length ) );\n    vec3 rdy = camera * normalize( vec3( py, focal_length ) );\n\n    // render\t\n    vec3 col = render( ray_origin, ray_dir, rdx, rdy );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 MakeCameraMtx( vec3 pos, vec3 up, vec3 target )\n{\n    vec3 z = normalize( target - pos );\n    vec3 x = normalize( cross( z, up ) );\n    vec3 y = normalize( cross( x, z ) );\n    return mat3( x, y, z );\n}\n\n//-------------------------------------------------\n\nvec2 opSmoothUnion( float a, float b, float k )\n{\n    float h = 1.0 - min( abs(a-b)/(4.0*k), 1.0 );\n    float w = h*h;\n    float m = w*0.5;\n    float s = w*k;\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n//-------------------------------------------------\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n//-------------------------------------------------\n\nvoid BoxIntersection( out float enter_dist, out float exit_dist, in vec3 ray_origin, in vec3 ray_dir, in vec3 box_pos, in vec3 box_half_size ) \n{\n    vec3 m = 1.0 / ray_dir;\n    vec3 n = m * ( ray_origin - box_pos );\n    vec3 k = abs( m ) * box_half_size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tenter_dist = max( max( t1.x, t1.y ), t1.z );\n\texit_dist  = min( min( t2.x, t2.y ), t2.z );\n}","name":"Common","description":"","type":"common"}]}