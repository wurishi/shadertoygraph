{"ver":"0.1","info":{"id":"clXBzs","date":"1693319663","viewed":33,"name":"shader 152138476523546","username":"snadaked","description":"code","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["code"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int n = 5;\nfloat A = 0.2;\nfloat B = 0.1;\nfloat C = 70.0;\nfloat D = 2000.0;\nfloat z_min = -100.0;\n\nvec3 col[6] = vec3[6](\n    vec3(0.870, 0.647, 0.100),\n    vec3(0.720, 0.9, 0.540),\n    vec3(0.9, 0.5, 0.270),  \n    vec3(0.9, 0.1, 0.468),\n    vec3(0.5, 0.2, 0.7),  \n    vec3(0.3, 0.7, 0.3)    \n);\nvec3 BG = vec3(0, 0, 0);\n\n\nvec2 RectangleBottomLeft = vec2(0.5, 0.05);\nvec2 RectangleTopRight = vec2(0.65, 0.65);\n\nvoid initRectangle(in float iTime) {\n    RectangleBottomLeft.x += 0.05 * sin(iTime);\n    RectangleTopRight.x += 0.05 * sin(iTime);\n}\n\nvec2 CircleCentre = vec2(0.4, 0.3);\nfloat CircleRadius = 0.05;\n\nvoid initCircle(in float iTime) {\n    CircleCentre.x += 0.05 * tan(iTime);\n    CircleCentre.y += 0.05 * sin(iTime);\n    CircleRadius = 0.3*(0.5 + 0.5 * sin(2.0 * iTime));\n}\n\n\nfloat z[6] = float[6](3., 10., 2.5, 2.0, 1.5, 1.0);\nint ind[7] = int[7](0, 4, 9, 12, 13, 14, 15);\n\n\n\nvec2 Centre = vec2(0.5, 0.5);\n\nvoid initEllipse(in float iTime) {\n    Centre.y += 100. * sin(iTime + 20.);\n}\n\n\n\n\n\n\nfloat get_z(vec2 uv, in int i) {\n    if(i == 0) return z[i] + 2.0 * sin(iTime);\n    if(i == 1) return (90.0 * D - 0.2 * B * uv.y - 0.5 * A * uv.x) / (100. * C) + 2.0 * cos(iTime);\n    if(i == 2) return z[i] + 2.0 * sin(2.0 * iTime);\n    if(i == 3) return z[i];\n    if(i == 4) return z[i] + 2.0 * cos(2.0 * iTime);\n    if(i == 5) return sqrt(A*B  - (uv.y - Centre.y)*(uv.y - Centre.y)- (uv.x - Centre.x)*(uv.x - Centre.x)) +100.0;;\n    return z_min;\n}\n\n\nbool inEllipse(in vec2 uv)\n{\n    if((uv.x - Centre.x)*(uv.x - Centre.x)/(A*A) + (uv.y - Centre.y)*(uv.y - Centre.y)/(B*B) <= 1.0) return true;\n    else return false;\n}\n\nbool inCircle(vec2 uv, vec2 center, float radius) {\n    return length(uv - center) <= radius;\n}\n\n\nbool inRectangle(vec2 uv, vec2 bottomLeft, vec2 topRight) {\n    return uv.x > bottomLeft.x && uv.x < topRight.x && uv.y > bottomLeft.y && uv.y < topRight.y;\n}\n\n\nbool inFigure(in vec2 uv, in int n1) {\n    if (n1 == 5) return inEllipse(uv);\n\n    if (n1 == 2) return inCircle(uv, CircleCentre, CircleRadius); \n    if (n1 == 3) return inRectangle(uv, RectangleBottomLeft, RectangleTopRight);\n    return false;\n}\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy * vec2(iResolution.x/iResolution.y, 1.0);\n    vec3 ellipseColorGradient = mix(col[5] * 0.7, col[5], uv.y);\n    \n    initRectangle(iTime);\n\n    initEllipse(iTime);\n    initCircle(iTime);\n\n    vec3 color = BG;\n    float z_max = z_min;\n    for(int i = 0; i <= n; i++) {\n        if(inFigure(uv, i)) {\n            float z_current = get_z(uv * iResolution.xy, i);\n             if (z_current > z_max) {\n                z_max = z_current;\n                if(i == 5) {\n                    color = ellipseColorGradient;\n                } else {\n                    color = col[i];\n                }\n             }\n        }\n    }\n\n    fragColor = vec4(color, 1.);\n    return;\n}","name":"Image","description":"","type":"image"}]}