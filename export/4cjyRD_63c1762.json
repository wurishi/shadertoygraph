{"ver":"0.1","info":{"id":"4cjyRD","date":"1722096142","viewed":99,"name":"Hommage à Robert Delaunay","username":"DrNoob","description":"Inspired by \"Disk Relief\" by Robert Delaunay.\nhttps://en.wikipedia.org/wiki/Robert_Delaunay\nhttps://fr.wikipedia.org/wiki/Robert_Delaunay#/media/Fichier:Robert_Delaunay_Relief-disques_1936.jpg","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["noise","repetition","palette","polarcoordinates"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Thomas Stehle\n// Title: Hommage à Robert Delaunay\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Inspired by the disk relief of Robert Delaunay.\n// https://en.wikipedia.org/wiki/Robert_Delaunay\n// https://fr.wikipedia.org/wiki/Robert_Delaunay#/media/Fichier:Robert_Delaunay_Relief-disques_1936.jpg\n\nconst float k_pi  = 3.141592653589793;\nconst float k_tau = 6.283185307179586;\n\nmat2 ab_rot2(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat ab_inv_lerp(in float v1, in float v2, in float v) {\n    return (v - v1) / (v2 - v1);\n}\n\nfloat ab_remap(in float v, in float min0, in float max0, in float min1, in float max1) {\n    return mix(min1, max1, ab_inv_lerp(min0, max0, v));\n}\n\nvec2 ab_cartesian_to_polar(in vec2 c) {\n    return vec2(length(c), atan(c.y, c.x));\n}\n\nvec2 ab_polar_to_cartesian(in vec2 p) {\n    return p.x * vec2(cos(p.y), sin(p.y));\n}\n\nvec3 ab_palette_chroma(in float t) {\n    const float k_delta = 0.5;\n    float freq = t * -k_pi;\n    vec3 color = vec3(sin(freq - k_delta), sin(freq), sin(freq + k_delta));\n    return pow(color, vec3(4.0));\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in float p) {\n    p = fract(p * 0.011);\n    p *= p + 7.5;\n    p *= p + p;\n    return fract(p);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.13);\n    p3 += dot(p3, p3.yzx + 3.333);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/XlGcRh\nvec2 hash2(in vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// https://www.shadertoy.com/view/4dS3Wd\nfloat vnoise(in float p) {\n    float i = floor(p);\n    float f = fract(p);\n    float u = f*f * (3.0 - 2.0 * f);\n    return -1.0 + 2.0 * mix(hash(i), hash(i + 1.0), u);\n}\n\n// https://www.shadertoy.com/view/XdXGW8\nfloat gnoise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f * (3.0 - 2.0 * f);\n    return mix(mix(dot(-1.0 + 2.0 * hash2(i + vec2(0, 0)), f - vec2(0, 0)),\n                   dot(-1.0 + 2.0 * hash2(i + vec2(1, 0)), f - vec2(1, 0)), u.x),\n               mix(dot(-1.0 + 2.0 * hash2(i + vec2(0, 1)), f - vec2(0, 1)),\n                   dot(-1.0 + 2.0 * hash2(i + vec2(1, 1)), f - vec2(1, 1)), u.x), u.y);\n}\n\n// https://www.shadertoy.com/view/WltSDj\nvec3 sdg_circle(in vec2 p, in float r) {\n    float d = length(p);\n    return vec3(d - r, p / d);\n}\n\nvec4 circular_segments(in vec2 pc, in vec2 steps) {\n    vec2 idx = vec2(0.0);   // Segment index\n    vec2 sc = vec2(0.0);    // Segment coordinates\n    idx.x = floor(steps.x * pc.x);\n    sc.x = fract(steps.x * pc.x);\n    sc.y = ab_remap(pc.y, -k_pi, k_pi, 0.0, 1.0);\n    idx.y = floor(steps.y * sc.y);\n    sc.y = fract(steps.y * sc.y);\n    return vec4(idx, sc);\n}\n\nvec3 modulated_color(in vec4 q, in float t) {\n    t += 0.1 * gnoise(2.0 * q.zw);  // Watercolor-type effect\n    t += 0.5 * sin(0.25 * iTime);   // Animation\n    return ab_palette_chroma(t);    // Sample from chroma palette\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Domain\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Disturb the domain a small amount\n    p += 0.005 * gnoise(20.0 * abs(p));\n\n    // Convert to polar coordinates\n    vec2 pc = ab_cartesian_to_polar(p);\n\n    // Base steps\n    const vec2 k_steps = vec2(5.0, 8.0); // x: radial, y: angular\n\n    // Background\n\n    // Repeat domain in circular segments\n    vec2 dSteps = k_steps;\n    dSteps.x += 0.5 * vnoise(15.0 * pc.x);  // Perturb radial\n    dSteps.x += 0.5 * sin(0.5 * iTime);     // Animate radial\n    dSteps.y += 4.0 * sin(0.01 * iTime);    // Animate angular\n    vec4 q = circular_segments(pc, dSteps);\n\n    // Color from cell index\n    vec3 col = modulated_color(q, hash(q.xy));\n    col = pow(col, vec3(0.3686, 0.3765, 0.8627)); // Accentuation\n    col = mix(col, 1.25 * col, q.w);              // Gradient\n\n    // Disk overlay\n\n    // Repeat disks in circular segments\n    vec2 oSteps = k_steps;\n    oSteps.y = dSteps.y;  // Take over domain animation\n    vec4 r = circular_segments(pc, oSteps);\n\n    // Disk placement across cells\n    float aOff = ab_remap(hash(r.xy), 0.0, 1.0, 0.25, 0.75);    // Angular offset\n    float rOff = ab_remap(r.x + 0.5, 0.0, oSteps.x, 0.0, 1.0);  // Radial offset\n    float angle = ab_remap(r.y + aOff, 0.0, oSteps.y, 0.0, k_tau);\n    vec2 o = ab_rot2(-angle) * p + vec2(rOff, 0.0);\n\n    // Random disk radius\n    vec2 radiusIv = vec2(0.025, 0.5 / oSteps.x);\n    float radius = ab_remap(hash(r.xy * 2.0), 0.0, 1.0, radiusIv.x, radiusIv.y);\n\n    // Remove some disks completely\n    radius *= step(0.5, rOff);              // Remove disks near center\n    radius *= step(0.75, hash(r.xy * 3.0)); // Remove disk with some probability\n\n    if (radius > 0.0) {\n        // Sample circle SDF with gradient info\n        vec3 disk = sdg_circle(o, radius);\n\n        // Two colors per disk\n        vec3 c1 = modulated_color(r, hash(r.xy * 4.0));\n        vec3 c2 = modulated_color(r, hash(r.xy * 5.0));\n\n        // Mix two colors in one of two ways, laterally or from distance\n        float m = (hash(r.xy * 6.0) > 0.5) ? step(disk.z, 0.0) : step(disk.x, -0.5 * radius);\n        vec3 dc = mix(c1, c2, m);\n\n        // Combine with background\n        col = mix(col, dc, step(disk.x, 0.0));\n    }\n\n    // Final color\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}