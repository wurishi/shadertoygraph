{"ver":"0.1","info":{"id":"wsBXzG","date":"1554202467","viewed":167,"name":"New Pixel Colorization method","username":"iopzxz","description":"this shader permutates through many possible combination of colors","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mixSinWaves(float x, float cycleA, float cycleB, float mixCycle) {\n\treturn sin(x / cycleA)*((1.0 + sin(x / mixCycle)) * 0.5) + sin(x / cycleB) * (1.0 - (1.0 + sin(x / mixCycle)) * 0.5);\n}\nfloat lerpThree(float H, float numA, float numB, float numC) {\n\tfloat c = 1.0;\n    float x = 1.0-abs(mod(H/60.0f,2.0f) -1.0);\n    float m = 0.0;\n\tfloat r = 0.0, g = 0.0, b = 0.0;\n\tr = float(((H < 60.0) || (H >= 300.0 && H < 360.0))) \n        +x * float(((H >= 60.0 && H < 120.0) || (H >= 240.0 && H < 300.0)));\n\tg = float((H >= 60.0 && H < 180.0)) + x * float(((H < 60.0) || (H >= 180.0 && H < 240.0)));\n\tb = float((H >= 180.0 && H < 300.0)) + x * float(((H >= 120.0 && H < 180.0) || (H >= 300.0 && H < 360.0)));\n\n\tfloat rgb = r+g+b+0.0001f;\n\tr /= rgb;\n\tg /= rgb;\n\tb /= rgb;\n\treturn (numA * r + numB * g + numC * b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n    float liftScaleFactor = 0.5;\n    float gainScaleFactor = 0.25;\n    float gammaScaleFactor = .5;\n    \n    vec3 sinWaves = vec3(\n        mixSinWaves(iTime, 2.1, 3.1,  7.0),\n        mixSinWaves(iTime, 3.1, 5.0,  7.4),\n        mixSinWaves(iTime, 2.0, 17.0, 6.7));\n    vec3 lift = vec3(\n        lerpThree(mod(iTime*0.1,360.0),sinWaves.x,sinWaves.y,sinWaves.z),\n        lerpThree(mod((iTime*0.1+120.0),360.0),sinWaves.x,sinWaves.y,sinWaves.z),\n        lerpThree(mod((iTime*0.1+240.0),360.0),sinWaves.x,sinWaves.y,sinWaves.z));\n    \n    vec3 gain = vec3(1.0,1.0,1.0);\n    vec3 gamma = vec3(1,1,1);\n    \n    \n    lift *= liftScaleFactor;\n    gain = 1.0 + gain  * gainScaleFactor;\n    gamma = 1.0 + gamma *gammaScaleFactor;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 texcolour = texture(iChannel0,uv).xyz;//Get the pixel at xy from iChannel0\n    \n    \n    // Output to screen\n    vec3 lgg = pow(clamp((gain*(texcolour+lift*(1.0-texcolour))),0.0,1.0),(1.0/gamma));\n    fragColor = vec4(lgg,1.0);\n}","name":"Image","description":"","type":"image"}]}