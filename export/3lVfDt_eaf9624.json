{"ver":"0.1","info":{"id":"3lVfDt","date":"1615295097","viewed":189,"name":"Light Experiment - Fresnel&&MSAA","username":"Learner_CC","description":"A simple fresnel reflection effect;\nUse MSAA to achieve Anti-aliasing.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fresnel","msaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV = 45.0;\nconst float EPSILON = 0.00001;\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst vec3 eyePos = vec3(0.0, 0.0, 8.0);\nconst int MSAA_n = 5;\n\nfloat random(float n) {\n    return fract(sin(dot(vec2(cos(n), sin(n)) ,vec2(27.9898, 38.233))) * 88.5453);\n}\n\n// -------- SDF -------- //\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n// -------- RayCast -------- //\nfloat castRay(vec3 eyePos, vec3 direction) {\n    float depth = 0.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sphereSDF(eyePos + depth * direction);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (dist >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\nvec3 getSphereNormal(vec3 p) {\n    return normalize(vec3(\n        sphereSDF(vec3(p.x + EPSILON, p.y, p.z)) - sphereSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sphereSDF(vec3(p.x, p.y + EPSILON, p.z)) - sphereSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sphereSDF(vec3(p.x, p.y, p.z + EPSILON)) - sphereSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// -------- Shading function -------- //\nfloat fresnelSchlick(vec3 v, vec3 n, float F0) {\n    float result = F0 + (1.0 - F0) * pow(1.0 - dot(v, n), 5.0);\n    return clamp(result, 0.0, 1.0);\n}\nvec4 shading(vec3 eyePos, vec3 rayDir, float dist) {\n    vec3 p = eyePos + dist * rayDir;\n    \n    vec4 result = vec4(vec3(0.0), 1.0);\n    // -------- Get Normal -------- //\n    vec3 normal = getSphereNormal(p);\n    vec3 view = normalize(eyePos);\n    // -------- Fresnel-Schlick -------- //\n    if (dist < 20.0) {\n        result = vec4(vec3(fresnelSchlick(view, normal, 0.1)), 1.0);\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    \n    vec4 color = vec4(0.0);\n    \n    // -------- MSAA -------- //\n    for (int i = 0; i < MSAA_n; i++) {\n        // -------- Get ray direction -------- //\n        vec2 xy = fragCoord.xy - iResolution.xy / 2.0 + vec2(random(float(i)), random(float(i) + 0.5)); \n        float z = iResolution.y / tan(radians(FOV) / 2.0);\n        vec3 rayDir = normalize(vec3(xy, -z));\n    \n        // -------- Cast Ray -------- //\n        float dist = castRay(eyePos, rayDir);\n        \n        // -------- Shading -------- //\n        color += shading(eyePos, rayDir, dist);\n    }\n    color /= float(MSAA_n); \n    \n    color.rgb += mix(vec3(0.1515, 0.2375, 0.5757), vec3(0.0546, 0.0898, 0.1953), uv.y);\n\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}