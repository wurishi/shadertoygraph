{"ver":"0.1","info":{"id":"ssVXWd","date":"1635554614","viewed":406,"name":"hilbert CA","username":"Carandiru","description":"Its moving & growing! like the worm in \"the abyss\". its slow-moving, patience required.\n\nadded \"precision\" option in common tab. off by default as it changes the shader a lot from previously - result: visibility precision increase!\n","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["noise","pixel","automata","hilbert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/ssVXWd\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     \n    float h = textureLod(iChannel0, uv / 1.0f, 0.0f).r;\n    \n    vec3 color;\n    color = vec3(0.9f, 0.05f, 0.35f) * h;\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/ssVXWd\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n\nuint width()\n{\n    uint mini = uint(min(iResolution.x, iResolution.y));\n    \n    --mini;\n    mini |= (mini >> 1u);\n    mini |= (mini >> 2u);\n    mini |= (mini >> 4u);\n    mini |= (mini >> 8u);\n    mini |= (mini >> 16u);\n    ++mini;\n    \n    return(max(1u, mini));\n}\n\nfloat hilbert1D(in uvec2 Position, in uint w){   \n    \n    uint Index = 0u;\n    \n    for(uint CurLevel = (w>>1u); CurLevel > 0u; CurLevel >>= 1u){\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel*CurLevel*((3u*Region.x)^Region.y);\n        if(Region.y == 0u){\n            if(Region.x == 1u){\n                Position = uvec2(w-1u) - Position;\n            }\n            Position.xy=Position.yx;\n        }\n    }\n    return (float(Index)/float(w*w));\n}\n\nvec2 hilbert2D(in uint Index, in uint w){   \n    \n    uvec2 Position = uvec2(0u);\n    \n    for(uint CurLevel = 1u; CurLevel < w; CurLevel <<= 1){\n        uvec2 Region;\n        Region.x = 1u & (Index >> 1u);\n        Region.y = 1u & (Index ^ Region.x);\n        if(Region.y == 0u){\n            if(Region.x == 1u){\n                Position = uvec2(CurLevel-1u) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n        Position += CurLevel * Region;\n        Index >>= 2u;\n    }\n    return vec2(Position);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 hn;\n    hn.x = textureLod(iChannel0, uv, 0.0f).r;\n    hn.y = textureLod(iChannel0, uv, 1.0f).r;\n    hn.z = textureLod(iChannel0, uv, 2.0f).r;\n    hn.w = textureLod(iChannel0, uv, 4.0f).r;\n    \n    vec4 nn;\n    nn.x = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0, 1)).r;\n    nn.y = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 0,-1)).r;\n    nn.z = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 1, 0)).r;\n    nn.w = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1, 0)).r;\n    \n    float s = 0.0f;\n    s = nn.x + nn.y + nn.z + nn.w;\n    s = bellcurve(s * 0.25f);\n    \n    uint w = width();\n    \n    vec2 hx = hilbert2D(uint(nn.x * float(iFrame)), w);\n    vec2 hy = hilbert2D(uint(nn.y * float(iFrame)), w);\n    vec2 hz = hilbert2D(uint(nn.z * float(iFrame)), w);\n    vec2 hw = hilbert2D(uint(nn.w * float(iFrame)), w);\n    \n    float h = hilbert1D(uvec2(fragCoord.xy + hx / s + hy / s + hz / s + hw / s), w);\n\n    h = bellcurve(h);\n    h = smoothstep(0.9999f, 1.0f, h);\n  \n    h = h + hn.x * 0.24999f + hn.y * 0.2499f + hn.z * 0.249f + hn.w * 0.248f;\n    \n    fragColor = vec4(h, hn.xyz);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// hilbert CA by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/ssVXWd\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define PI (3.141592654f)\n//#define PRECISE_OPTIMIZED     // uncomment to enable (precision fix)\n\n\n#ifndef PRECISE_OPTIMIZED\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n    const float sigma = float(0.5f);  // mu is 0.0 (centered)\n    const float b = float((2.0f * sigma) * (2.0f * sigma));\n    const float c = float((2.0f * PI * sigma) / 1.253314f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                                                      // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (x * 2.0f - 1.0f);  // converts input range\n\n    return(exp(-(x * x) / b / c));\n}\n\n#else\n\n// simplified and optimized - also higher precision is maintained. \n// (herbie helped me out, as well as desmos!)\n// also \n// best result when binned against a random number generator - thanks paniq (https://www.shadertoy.com/view/ssGXDd)\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(PI / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}\n\n#endif\n","name":"Common","description":"","type":"common"}]}