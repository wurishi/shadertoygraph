{"ver":"0.1","info":{"id":"ttKGRm","date":"1578705309","viewed":262,"name":"Ray traced terrain","username":"jesusdz","description":"Terrain test:\n- noise-based (fbm) heightmap, water ripples and clouds\n- ambient occlusion effect\n- water reflection\n- camera control","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_HEIGHT 60.0\n#define MAX_DISTANCE 400.0\n#define NOISE_SCALE 0.03\n#define WATER_HEIGHT 23.0\n\n#define PI 3.14159265359\n\nfloat hash( float n )\n{\n  return fract(cos(n)*41375.92653);\n}\n\nfloat noise2(in vec2 x)\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n\n  return mix(\n      mix(hash(n+0.0),  hash(n+1.0),  f.x),\n      mix(hash(n+57.0), hash(n+58.0), f.x),\n      f.y);\n}\n\nfloat fbm(in vec2 x)\n{\n    float val = 0.5 * noise2(x);\n    val += 0.25 * noise2(2.01 * x);\n    val += 0.12 * noise2(4.03 * x);\n    val += 0.06 * noise2(7.99 * x);\n    val += 0.03 * noise2(16.02 * x);\n    //val += 0.01 * noise2(32.04 * x);\n    return val/0.96;\n}\n\nfloat fbmDetailed(in vec2 x)\n{\n    float val = 0.5 * noise2(x);\n    val += 0.25 * noise2(2.01 * x);\n    val += 0.12 * noise2(4.03 * x);\n    val += 0.06 * noise2(7.99 * x);\n    val += 0.03 * noise2(16.02 * x);\n    //val += 0.01 * noise2(32.04 * x);\n    val += 0.002 * noise2(512.01 * x);\n    return val/0.962;\n}\n\nfloat heightmap(in vec2 p)\n{\n    float height = MAX_HEIGHT * fbm(NOISE_SCALE * p);\n    return height;\n}\n\nfloat heightmapDetailed(in vec2 p)\n{\n    float height = MAX_HEIGHT * fbmDetailed(NOISE_SCALE * p);\n    return height;\n}\n\nvec3 terrainNormal(in vec3 p)\n{\n    float eps = 0.3;\n    vec3 v1 = p - vec3(p.x-eps, heightmap(p.xz - vec2(eps,0.0)), p.z);\n    vec3 v2 = p - vec3(p.x,     heightmap(p.xz - vec2(0.0,eps)), p.z-eps);\n    vec3 n = normalize(cross(v2, v1));\n    return n;\n}\n\nvec3 terrainNormalDetailed(in vec3 p)\n{\n    float eps = 0.3;\n    vec3 v1 = p - vec3(p.x-eps, heightmapDetailed(p.xz - vec2(eps,0.0)), p.z);\n    vec3 v2 = p - vec3(p.x,     heightmapDetailed(p.xz - vec2(0.0,eps)), p.z-eps);\n    vec3 n = normalize(cross(v2, v1));\n    return n;\n}\n\nfloat fresnel(in vec3 eyeDir, float R0)\n{\n    return R0 + (1.0 - R0)*pow(1.0 - dot(eyeDir, vec3(0.0,1.0,0.0)), 5.0);\n}\n\nvec3 terrainColor(in vec3 p)\n{\n    float h = p.y;\n    float h2 = h + 5.0 * (2.0 * fbm(p.xz) - 1.0);\n    vec3 col = vec3(0.1,0.3,0.0);\n    col = mix(col, vec3(0.5,0.5,0.2), smoothstep(WATER_HEIGHT + 4.0, WATER_HEIGHT + 7.0, h2));\n    col = mix(col, vec3(0.9,0.6,0.3), smoothstep(WATER_HEIGHT + 12.0, WATER_HEIGHT + 15.0, h2));\n    col = mix(col, vec3(1.0,1.0,1.0), smoothstep(WATER_HEIGHT + 24.0, WATER_HEIGHT + 27.0, h2));\n    col = mix(col, vec3(0.2, 0.15, 0.1), 1.0 - smoothstep(WATER_HEIGHT, WATER_HEIGHT + 0.5, h));\n    return col;\n    \n    #if 0\n    float h = p.y / MAX_HEIGHT;\n    float h2 = h + 0.07*(2.0 * fbm(p.xz) - 1.0);\n    vec3 col = vec3(0.1,0.3,0.0);\n    col = mix(col, vec3(0.5,0.5,0.2), smoothstep(0.54, 0.58, h2));\n    col = mix(col, vec3(0.9,0.6,0.3), smoothstep(0.60, 0.64, h2));\n    col = mix(col, vec3(1.0,1.0,1.0), smoothstep(0.68, 0.72, h2));\n    col = mix(col, vec3(0.2, 0.15, 0.1), 1.0 - smoothstep(0.46, 0.465, h));\n    return col;\n    #endif\n}\n\nvec3 horizonCol = vec3(0.8, 0.95, 1.0);\n\nvec3 skyColor(in vec3 d)\n{\n    vec3 skyCol = vec3(0.1, 0.4, 0.8);\n    \n    vec2 uv = d.xz / d.y;\n    float cloudFactor = min(1.0, max(0.0, fbm(uv+iTime*0.05) - 0.5) * 15.0);\n    skyCol = mix(skyCol, vec3(1.0), cloudFactor * d.y);\n    \n    skyCol = mix(horizonCol, skyCol, sqrt(abs(d.y)));\n    \n    return skyCol;\n}\n\nfloat intersectTerrain(in vec3 o, in vec3 d)\n{\n    vec3 p = o;\n    float t0 = 0.0;\n    float t = 0.0;\n    float delta = 0.0;\n    float h = 0.0;\n    bool hit = false;\n    bool involume = true;\n\n    for (int i = 0; i < 140 && !hit && involume; ++i)\n    {\n        delta = max(0.01, 0.2*abs(p.y - h)) + t * 0.01;\n        t0 = t;\n        t += delta;\n        \n        p = o + t * d;\n        h = heightmap(p.xz);\n        hit = (p.y < h);\n        involume = (p.y < MAX_HEIGHT) && (t < MAX_DISTANCE);\n    }\n\n    if (hit)\n    {\n        // binary search\n        for (int i = 0; i < 10; ++i)\n        {\n            float tc = 0.5 * (t0 + t);\n        \tp = o + tc * d;\n\n        \th = heightmap(p.xz);\n            \n        \tif (p.y < h)\n        \t{\n                t = tc;\n                t0 = t0;\n        \t}\n            else\n            {\n                t = t;\n                t0 = tc;\n            }\n        }\n        \n        return t;\n    }\n    \n    return 0.0;\n}\n\nfloat calcAO(in vec3 p, in vec3 n)\n{\n    float ao = 0.0;\n    float r1 = 1.0;\n    float r2 = 1.0;\n    float r3 = 1.0;\n    vec3 uu = normalize(cross(vec3(1.0,0.0,0.0), n));\n    vec3 vv = n;\n    vec3 ww = cross(vv, uu);\n    mat3 rot = mat3(uu, vv, ww);\n    for (int i = 0; i < 6; ++i)\n    {\n        r1 = hash(435.627*r1) * 2.0 - 1.0;\n        r2 = hash(513.128*r2) * 2.0 - 1.0;\n    \tr3 = hash(198.731*r3);\n        vec3 disp = rot * vec3(r1,r3,r2) * float(i) * 1.0;\n        vec3 pb = p + disp;\n        float h = heightmap(pb.xz);\n        ao += max(0.0, smoothstep(float(i), 0.0, pb.y - h));\n    }\n    ao = 1.0 - ao/6.0;\n    ao *= ao;\n    return ao;\n}\n\nvec3 shadeTerrain(in vec3 p)\n{\n    vec3 col = vec3(0.0);\n    \n    // AO\n    float h = p.y;\n    vec3 n = terrainNormalDetailed(p);\n    float ao = calcAO(p, n);\n    vec3 mcolor = terrainColor(p);\n\n    // ambient\n    vec3 acolor = 0.5*vec3(0.5, 0.5, 0.6);\n    float amb = max(0.0, dot(0.5*n + 0.5, vec3(0.0, 1.0, 0.0)));\n    col += vec3(mcolor * acolor * amb * ao);\n\n    // diffuse\n    vec3 l = normalize(vec3(0.5, 1.0, 2.0));\n    vec3 dcolor = vec3(0.5, 0.5, 0.4);\n    float dif = max(0.0, dot(n, l));\n    col += vec3(mcolor * dcolor * dif);\n    \n    return col;\n}\n\nvec3 shadeWater(in vec3 obs, in vec3 p, in vec3 d, float groundDepth, in vec3 groundColor)\n{\n    // normal\n    vec2 eps = vec2(0.1,0.0);\n    vec3 n0 =      vec3(p.x        , fbm(3.0*p.xz + eps.yy + iTime), p.z);\n    vec3 n1 = n0 - vec3(p.x + eps.x, fbm(3.0*p.xz + eps.xy + iTime), p.z);\n    vec3 n2 = n0 - vec3(p.x        , fbm(3.0*p.xz + eps.yx + iTime), p.z + eps.x);\n    vec3 n = cross(n1, n2);\n    float att = length(obs - p) * 1.5;\n    n.y *= att;\n    n = normalize(n);\n    \n    // reflection\n    vec3 r = reflect(d, n);\n    vec3 reflectedCol = skyColor(r);\n    float t = intersectTerrain(p, r);\n    if (t > 0.0)\n    {\n        vec3 p = p + t*r;\n        reflectedCol = shadeTerrain(p);\n    }\n    \n    // refraction\n    vec3 deepBlue = vec3(0.0,0.05,0.2);\n    vec3 refractedCol = mix(deepBlue, groundColor, exp(-groundDepth*0.5));\n    \n    float f = fresnel(-d, 0.03);\n    vec3 col = mix(refractedCol, reflectedCol, f);\n\treturn col;\n}\n\nvec3 cameraPos(float time)\n{\n    float speed = 5.0;\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 pos = vec3(0.0, 0.0, 0.0) + speed*time*dir;\n    pos.y = heightmap(pos.xz) + 5.0;\n    pos.y = max(pos.y,WATER_HEIGHT + 5.0);\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // camera\n    float tf = mod(iTime, 1.0);\n    float t1 = iTime - tf;\n    float t2 = t1 + 1.0;\n    vec3 o1 = cameraPos(t1);\n    vec3 o2 = cameraPos(t2);\n    vec3 o = cameraPos(iTime);\n    o.y = mix(o1.y, o2.y, tf/1.0);\n    \n    vec3 c = o + vec3(cos(PI*iMouse.x/iResolution.x), 4.0*sin(iMouse.y/iResolution.y-0.5)-0.5, sin(PI*iMouse.x/iResolution.x));\n    vec3 ww = normalize(o - c);\n    vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n    vec3 vv = cross(ww, uu);\n    vec3 d = normalize(uu * uv.x + vv * uv.y - ww * 2.8);\n\n#if 0\n    // height projected on floor\n    float tf = -o.y / d.y;\n    if (tf > 0.0)\n    {\n       \tvec3 p = o + tf * d;\n        fragColor = vec4(vec3(fbm(0.04*p.xz)), 1.0);\n        return;\n    }\n#endif\n    \n    vec3 col = vec3(0.0);\n    \n    float t = intersectTerrain(o, d);\n        \n    if (t > 0.0)\n    {\n        vec3 p = o + t * d;\n        \n        col = shadeTerrain(p);\n        \n    \t// water\n        if (p.y < WATER_HEIGHT)\n        {\n\t    \tfloat t2 = (WATER_HEIGHT-o.y) / d.y;        \n       \t\tvec3 waterPos = o + t2 * d;\n            \n            col = shadeWater(o, waterPos, d, length(p - waterPos), col);\n        }\n        \n        col = mix(horizonCol, col, 1.0 - smoothstep(0.0, MAX_DISTANCE, t));//exp(-t*0.001));\n    }\n    else\n    {\n   \t\tcol = skyColor(d);\n    }\n    \n#if 0\n    // show material gradient\n    if (uv.y < -0.5)\n    {   \n        vec3 p = vec3(uv.x, MAX_HEIGHT*(uv.x * 0.5 + 0.5), uv.y);\n        col = colormap(p);\n    }\n#endif\n    \n    col = sqrt(col);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}