{"ver":"0.1","info":{"id":"XsfcR8","date":"1486875884","viewed":222,"name":"Lathe Operation","username":"marciot","description":"IQ's distance field operations did not include a lathe operation, so I decided to make my own.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distancefield","primitives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* An experiment in extending IQ's distance field primitives with\n * a lathe operation that takes a 2D distance field and sweeps\n * it around an axis to generate a 3D object.\n */\n\n#define PI 3.1415926535898\n\n/* Basic operations from:\n *   https://iquilezles.org/articles/distfunctions\n */\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\n/* 2D primitives based on IQ's 3D primitive functions */\n\nfloat sdCircle( vec2 p, float s ) {\n  return length(p)-s;\n}\n\n\nfloat udRectangle( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n// This function returns a distance field in 2D\nfloat crossSection(vec2 p) {\n    return opS(\n\t\tsdCircle(    p + vec2(0, -0.25), 0.125),\n    \tudRectangle( p + vec2(0,    0.0), vec2(.25,.25))\n    );\n}\n\nfloat map2(vec2 p) {\n    return crossSection(p+ vec2(-2., -0.25));\n}\n\n// The lathe operation rotates the 2D distance field\n// around the Y axis, generating a 3D object.\nfloat opLathe( vec3 p ) {\n    return map2(vec2(length(p.xz), p.y));\n}\n\n// 3D Primitives\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n/* This function returns a distance field in 3D. It consists of\n * a plane and a lathed object.\n */\nfloat map(vec3 p){\n    return opU(\n        sdPlane(p),\n    \topLathe(p-vec3(0., 1., 0.))\n    );\n}\n\n// Soft shadow code modified from: https://www.shadertoy.com/view/Xds3zN\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n/* Ray-marching code based on https://www.shadertoy.com/view/MlXSWX */\n\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\t\n\tconst float eps = 0.001;\n\treturn normalize(vec3(\n\t\tmap(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n\t\tmap(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n\t\tmap(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n\t));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 1.0, 0.0);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 2., -5); // Camera position, doubling as the ray origin.\n\n    // Lights\n    vec3 light_pos  = vec3(5., 15., -5.);\n    vec3 light_pos2 = vec3(0., 5., -5.);\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n    \n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n\t// Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = 0.0, dt;\n\tfor(int i=0; i<128; i++){\n\t\tdt = map(camPos + rd*t);\n\t\tif(dt<0.005 || t>150.){ break; } \n\t\tt += dt*0.75;\n\t}\n\t\n    // The final scene color. Initated to black.\n\tvec3 sceneCol = vec3(0.7, 0.7, 1.0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(dt<0.005){        \n\t\t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        if(sp.y < 0.03) {\n            // Checkerboard from: https://www.shadertoy.com/view/Xds3zN\n            float f = mod( floor(1.0*sp.z) + floor(1.0*sp.x), 2.0);\n            sceneCol = 0.3 + 0.1*f*vec3(1.0);\n        } else {\n            sceneCol = vec3(1., 0.5, .5);\n        }\n\n    \t// Light direction vectors.\n\t    vec3 ld  = light_pos-sp;\n\t    vec3 ld2 = light_pos2-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp  = max(length(ld),  0.001);\n\t    float distlpsp2 = max(length(ld2), 0.001);\n        \n    \t// Ambient light.\n\t    float ambience = 0.25;\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld  /= distlpsp;\n\t    ld2 /= distlpsp2;\n        \n    \t// Diffuse lighting.\n\t    float diff  = max( dot(sn, ld), 0.0);\n\t    float diff2 = max( dot(sn, ld2), 0.0);\n        \n        // Soft shadow based on:\n        //   https://www.shadertoy.com/view/Xds3zN\n        float shadow = softshadow( sp, ld, 0.02, 2.5 ) * softshadow( sp, ld2, 0.02, 2.5 ) ;\n        \n        sceneCol *= (diff+diff2)*shadow*0.5 + ambience*0.5;\n    }\n\n    fragColor = vec4(clamp(sceneCol, 0., 1.), 1.0);\n}","name":"Image","description":"","type":"image"}]}