{"ver":"0.1","info":{"id":"fl33WB","date":"1636596921","viewed":128,"name":"Pulsating customizable spiral","username":"feldim2425","description":"Spiral can be customized by modifying the constants in the shader.\nI didn't bother fitting the dimensions to any specific unit so most options a trial and error.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538\n\n// Size options\nfloat spiralSize = 20.0; // Smaller is bigger; 0 would just be a rotating line\nfloat spacing = 1.5; // Min. 1.0\nfloat pulsationStrength = 0.5; // from 0.0 to 1.0\nint armCount = 1; // 0 for rings; negative to flip the direction\n\n// Speed options\nfloat pulsespeed = 0.5; // 0.0 to disable pulsation\nfloat rotationspeed = 2.0; // 0.0 to disable rotation; negative -> CW; positive -> CCW\n\n// Color options\nfloat gradient = 2.0; // 0.0 -> Fix to inner color\nvec3 innerColor = vec3(1.0,1.0,1.0); // from 0.0 to 1.0 Red-Green-Blue\nvec3 outerColor = vec3(0.0,0.0,0.25); // from 0.0 to 1.0 Red-Green-Blue\nvec3 backColor = vec3(0.0,0.0,0.0); // from 0.0 to 1.0 Red-Green-Blue\n\n/*\n * Further info:\n * CW = Clockwise rotation\n * CCW = Counter clockwise rotation\n *\n * When using rings (0 arms) CW will move inwards while CCW moves outwards\n *\n * Please not that I did this as a learning project. It seemed both simple enough to do but also complex enough to learn \n * writing shader effects.\n */\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 pos = ( fragCoord.xy - iResolution.xy / 2.0 ) / max(iResolution.x, iResolution.y);\n\t\n    float scaling = (sin((iTime * pulsespeed) + length(pos)) * pulsationStrength + 1.0) * spiralSize;\n\tfloat rotation = atan(pos.x, pos.y) * float(armCount) * 0.5 / PI * spacing + (iTime * rotationspeed);\n\tfloat intensity = max(0.0, 1.0 - mod(rotation - length(pos) * scaling , spacing));\n    intensity = min(intensity, (1.0 - intensity) * intensity * 0.04 * iResolution.y); //Thanks to Shane for this anti-aliasing hack\n\t\n\tvec3 col = mix(innerColor,outerColor, length(pos) * gradient);\n\tfragColor = vec4( col * intensity + backColor * ( 1.0 - intensity ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}