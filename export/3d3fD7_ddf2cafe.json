{"ver":"0.1","info":{"id":"3d3fD7","date":"1605207591","viewed":348,"name":"Nil_Euclidean_Interpolation","username":"stevejtrettel","description":"Interpolation between the Nil metric and Euclidean metric","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","noneuclidean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n//======== TRACING THE XY PLANE ================\n//==================================================\n\n//parameter in the geodesic flow\nfloat xi=1.;\nfloat fov=120.;\n\n\n//flow by nil geodesics towards the xy plane.\nvec3 flow(vec3 eye, vec3 dir,float t){\n    \n    //get a and c and alpha:\n    float c=dir.z;\n    float a=length(dir.xy);\n    float alpha=atan(dir.y,dir.x);\n    \n    //give geodesic\n    float x=(a*sin(c*t*xi+alpha)-a*sin(alpha))/(c*xi);\n        \n    float y=(a*cos(c*t*xi+alpha)-a*cos(alpha))/(c*xi);\n    float z=((a*a*c+2.*c*c*c)*t*xi-a*a*sin(c*xi*t))/(2.*c*c*xi);\n    \n    return eye+vec3(x,y,z);\n}\n\n\nvec3 flow2(vec3 eye, vec3 dir,float t){\n    \n    //get a and c and alpha:\n    float c=dir.z;\n    float a=length(dir.xy);\n    float alpha=atan(dir.y,dir.x);\n    \n    //give geodesic\n    float x=2.*a/c*sin(c*t/2.)*cos(c*t/2.+alpha);\n    float y=2.*a/c*sin(c*t/2.)*sin(c*t/2.+alpha);\n    float z=c*t+0.5*a*a*(c*t-sin(c*t))/(c*c);\n    \n    return eye+vec3(x,y,z);\n}\n\n\n\n//are you above the plane?\nbool abovePlane(vec3 pos){\n    if(pos.z>0.){return true;}\n    else{return false;}\n}\n\n//given the initial conditions AND a distance just before\n//impacting the plane, do a binary search to find the plane:\nvec3 findPlane(vec3 eye, vec3 dir, inout float dist,float stp){\n\n    //flowing dist doesnt hit the plane, dist+step does:\n    float testDist=stp;\n    \n    for(int i=0;i<8;i++){\n        \n        //divide the step size in half\n         testDist=testDist/2.;\n\n        //if you are still above the plane, add to distance.\n        if(abovePlane(flow(eye,dir,dist+testDist))){\n            dist+=testDist;\n        }\n        //if not, then don't add: divide in half and try again\n    \n    }\n    \n    return flow(eye,dir,dist);\n    \n    \n}\n    \nvec3 trace(vec3 eye, vec3 dir,inout float totalDist){\n  \n    float stp=1.;\n    float dist=0.;\n    \n    vec3 endPt=eye;\n    \n\t//keep flowing along at fixed step size till you hit the plane.\n    for(int count=0;count<50;count++){\n      \n        dist+=stp;\n        endPt=flow(eye,dir,dist);\n        //check if you hit the plane\n        if(!abovePlane(endPt)){\n            break;}\n    }\n    \n    \n    //if you return here, that means dist is set to be right after you step past the plane:\n   \tdist=dist-stp;//right before you hit the plane.\n    \n    //now do binary search to find the plane.\n    endPt=findPlane(eye,dir,dist,stp);\n    \n\n    //return the point which actually lies on the plane.\n    totalDist=dist;\n    return endPt;\n}\n\n\n\n\n//======== COLORING THE PLANE ================\n//==================================================\n\n\nvec3 checkerboard(vec3 p,vec2 offset,float size){\n    float x=mod(size*p.x+offset.x,2.);\n    float y=mod(size*p.y+offset.y,2.);\n    \n    vec3 color=vec3(0.);\n    \n    //what to do if we hit the plane in the at z=0\n    if(abs(p.z)<0.5){\n    if(y<1.&&x<1.||y>1.&&x>1.)\n    {color=vec3(1.);}\n    }\n\n    return color;\n}\n\n\n\n\n//adjust the color computed at p by a fog:\nvec3 fog(vec3 p,vec3 color){\n    float r=length(p.xy);\n    \n\tfloat s=1./50.;\n    float fogginess=exp(-r*r*s);\n    return fogginess*color;\n}\n\n\n\n//======== SETTING UP THE VIEW ETC ================\n//==================================================\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n\n\n//viewDir is based around looking down the z-axis: this rotates coordinates \n//so the screen center is instead facing forwardVec\nvec3 rotateView(vec2 sphCoords,vec3 dir){\n\n    float theta=sphCoords.x;\n    float phi=sphCoords.y;\n\n \n    vec3 tempDir;\n    //first, rotate up in the phi direction, fixing the x axis:\n    tempDir.x=dir.x;\n    \n    tempDir.z= cos(phi)*dir.z-sin(phi)*dir.y;\n    tempDir.y= sin(phi)*dir.z+cos(phi)*dir.y;\n    \n    \n    vec3 newDir;\n    //now rotate about the z-axis\n    newDir.z=tempDir.z;\n    newDir.x=cos(theta)*tempDir.x-sin(theta)*tempDir.y;\n    newDir.y=sin(theta)*tempDir.x+cos(theta)*tempDir.y;\n    \n    return newDir;\n}\n\n\n//mostly linear but zero deriv at beginning and end\n\nfloat smoothTransition(float x){\n    if(x<0.){return 0.;}\n    else if(x>1.){return 1.;}\n    else{\n        return 3.*x*x-2.*x*x*x;\n    }\n}\n\n\n\n\n//======== TIMING FOR THE ANIMATION ================\n//==================================================\n\n//setting time intervals:\nfloat totalTime=5.;\nfloat time1;\nfloat time2;\nfloat time3;\nfloat time4;\n\nvoid setTimes(){\n    time1=0.25*totalTime;\n    time2=0.5*totalTime;\n    time3=0.75*totalTime;\n    time4=totalTime;\n}\n\n\n\n//intial starting location of your eye (should be along z axis).\nvec3 eyePosition(float time){\n    \n    //can only move your eye up and down on the z-axis so that \n    //everything is Euc translations and the geodesics are right.\n\n    float h,x;\n    \n    float eucHeight=3.;\n    float deltaHeight=8.;\n\n    \n    time=mod(time,totalTime);\n    \n    //start at a constant height while you turn your head up\n    if(time<time1){\n        h=eucHeight;\n    }\n    \n    //then move upwards as you distort the metric, and turn your head back down\n    else if(time<time3){\n        x=(time-time1)/(time3-time1);\n        h=eucHeight+deltaHeight*pow(smoothTransition(x),4.);\n    \n    }\n\n    //then move back downwards to the origin height.\n    else{\n        x=(time-time3)/(time4-time3);\n       h=eucHeight+deltaHeight-deltaHeight*smoothTransition(x);\n    }\n    \n    \n    return vec3(0.,0.,h);\n    \n}\n\n\n\n//initial starting direction in spherical coordinates in your tangent space:\nvec2 eyeDirection(float time){\n    \n    //no rotation in the xy plane: the twisting geodesics does enough of that!\n    float theta=0.;\n    //just raise our head up and down.\n    float phi;\n    \n    time=mod(time,totalTime);\n    \n    //turn your head up\n    if(time<time1){\n        phi=-smoothTransition(time/time1)*3.14/3.;\n    }\n    \n    //lower your head as you change the metric\n    else if(time<time3){\n        float x=(time3-time)/(time3-time1);\n        phi=-3.14/3.*smoothTransition(x);\n    }\n    \n    //be looking straight down for the descent\n    else{\n    phi=0.;\n    }\n    \n  \n    return vec2(theta,phi);\n}\n\n\nfloat nilify(float time){\n    //change the metric parameter between 0 and 1\n    float xi;\n\n    \n    time=mod(time,totalTime);\n    \n    if(time<time1){\n        //euclidean space (don't divide by zero!)\n        xi=0.0001;\n    }\n    \n    else if(time>time1 &&time<time2){\n        //smoothly interpolate until nil\n        xi=smoothTransition((time-time1)/(time2-time1));\n    }\n    \n    else if(time>time2&&time<time3){\n        //stay nil\n        xi=1.;\n    }\n    \n    else{\n        //smoothly interpolate back to euclidean\n        xi=smoothTransition(((time4-time)/(time4-time3)));\n    }\n    \n    \n    return xi;\n}\n\n\n\n//adjust the color computed at p by a fog:\nvec3 animateFog(vec3 p,vec3 color,float time){\n    float r=length(p.xy);\n    \n    time=mod(time,totalTime);\n    float s=(time/totalTime)*(1.-time/totalTime);\n    s=s/30.;\n    \n    float fogginess=exp(-r*r*s);\n    return fogginess*color;\n}\n\n\n\n\n//======== ANTI-ALIASING ================\n//==================================================\n\n\n//given eye position, direction and distance, get checker color\nvec3 getChecker(vec3 eye, vec3 dir, float dist){\n    float size=2.;\n    vec2 offset=vec2(0.1,0.2);\n    vec3 p=flow(eye, dir, dist);\n    return checkerboard(p,offset,size);\n}\n\n\n//set the initial direction from fragCoord\nvec3 tVector(vec2 fragCoord,float time){\n    \n\tvec3 dir = rayDirection(fov, iResolution.xy, fragCoord);\n    //give the initial direciton you look in as a funciton of theta/phi\n    //in the spherical coords on your tangent space. \n   \tvec2 eyeDir=eyeDirection(time);\n    dir=rotateView(eyeDir,dir);\n\n    return dir;\n}\n\n\n\nvec3 getColor(vec2 fragCoord,float time){\n    \n    float dist;\n    \n    //set the geometry\n    xi=nilify(time);\n    \n    //do the original tracing to get the distance:\n    vec3 eye=eyePosition(time);\n    vec3 dir=tVector(fragCoord,time);\n\n    //find the point on the plane you reach after raytracing\n    vec3 endPt=trace(eye,dir,dist);\n    \n    //offset to the checkerboard pattern to adjust\n    vec3 color=getChecker(eye,dir,dist);\n    \n    //fog is off at beginning and end, on in middle\n    color=animateFog(endPt,color,time);\n    \n  \treturn color;\n}\n\n\n\n\n\nvec3 timeAA(vec2 fragCoord,float time,int T){\n       \n    \n    float t=float(T);//T=length of time to sample over\n    //size of a timestep (should be related to frames...)\n    //make the step size increase over the time interval = more blur at the end\n    float stp=0.000+0.002*mod(time,totalTime)/totalTime;\n\n    \n    float newTime;\n    vec3 color=vec3(0.);\n    vec3 newDir;\n    float dist;\n    \n    //set the geometry\n    xi=nilify(time);\n    \n    //do the original tracing to get the distance:\n    vec3 eye=eyePosition(time);\n    vec3 dir=tVector(fragCoord,time);\n    vec3 endPt=trace(eye,dir,dist);\n    //now distance is saved:\n\n    //now iterate over a time interval, and take the average color\n    for(int k=-T;k<T+1;k++){\n        \tnewTime=time+stp*float(k);\n         \txi=nilify(newTime);\n        \teye=eyePosition(newTime);\n            newDir=tVector(fragCoord,newTime);\n            color+=getChecker(eye,newDir,dist);\n    }\n    \n   \tcolor=color/(2.*t+1.);\n    \n    color=animateFog(endPt,color,time);\n    \n  \treturn color;\n    \n}\n\n\n\n\n//======== MAKING THE IMAGE ================\n//==================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set the animation time cutoffs\n    setTimes();\n    fov=120.;\n    \n    vec3 color;\n\n    //get the color of the pixel at fragCoord at the time iTime.\n\tcolor=timeAA(fragCoord,iTime,5);\n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}