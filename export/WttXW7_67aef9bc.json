{"ver":"0.1","info":{"id":"WttXW7","date":"1581096464","viewed":296,"name":"sdf stars","username":"antovsky","description":"starry sky using signed distance fields","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// can use any hash function, but this works well enough\nfloat hash( in vec2 p )  \n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat sdCircle(in vec2 pos, float rad) {\n\treturn length(pos) - rad;\n}\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec3 field(vec2 pos_in_world) {\n    // scale of the starfield\n    float s = 8.0;\n    pos_in_world*=s;\n    \n    float d_ret = 10000.0; // any huge number\n    vec3 col_ret = vec3(1.0);\n    \n    for (int x = -1; x <= +1; ++x)\n    for (int y = -1; y <= +1; ++y) {\n        vec2 c = fract((pos_in_world+vec2(x,y)));\n        vec2 i = floor((pos_in_world+vec2(x,y)));\n        vec2 j = vec2(hash(i),hash(i+vec2(7.0,13.0)))*2.0 - 1.0;\n        const float jitter_amount = 0.5; // how jittery the stars are\n        vec2 star_in_world = (i+0.5+j*jitter_amount);\n        \n        vec2 pos_in_shape = pos_in_world-star_in_world;\n        float shape_size = mix(0.1,0.3,hash(i));\n        \n        // signed distance field of star shape\n        // you can use anything from:\n        // https://iquilezles.org/articles/distfunctions2d\n        \n        //float d = sdCircle(pos_in_shape, shape_size);\n        float d = sdStar5(pos_in_shape, shape_size, shape_size*2.0);\n        \n        if (d < d_ret) {\n            // just a crappy random color\n            vec3 col = vec3(mix(0.4,1.0,hash(i)),\n                            mix(0.4,1.0,hash(i+vec2(1.0))),\n                            mix(0.4,1.0,hash(i+vec2(3.0))));\n            \n            // width of the edge smoothing (should depend on size of pixels, hence *s)\n            float edge_width = 0.002 * s;\n            col_ret = vec3(1.0 - smoothstep(0.-edge_width, edge_width, d)) * col;\n            d_ret = d;\n        }\n    }\n    vec2 i = floor((pos_in_world));\n    \n    // uncomment this to see the underlying jitter grid\n    //col_ret += vec3((int(i.x)^int(i.y))&1)*0.25;\n    \n    return col_ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    // Evaluate star field\n    vec3 col = field(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}