{"ver":"0.1","info":{"id":"Ml33zB","date":"1469957579","viewed":170,"name":"Learning of Graident Noise","username":"panda1234lee","description":"Learning ofÂ  Graident Noise","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["gradientnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Gradient Noise (http://en.wikipedia.org/wiki/Gradient_noise), not to be confused with\n// Value Noise, and neither with Perlin's Noise (which is one form of Gradient Noise)\n// is probably the most convenient way to generate noise (a random smooth signal with \n// mostly all its energy in the low frequencies) suitable for procedural texturing/shading,\n// modeling and animation.\n//\n// It produces smoother and higher quality than Value Noise, but it's of course slighty more\n// expensive.\n//\n// The princpiple is to create a virtual grid/latice all over the plane, and assign one\n// random vector to every vertex in the grid. When querying/requesting a noise value at\n// an arbitrary point in the plane, the grid cell in which the query is performed is\n// determined (line 32), the four vertices of the grid are determined and their random\n// vectors fetched (lines 37 to 40). Then, the position of the current point under \n// evaluation relative to each vertex is doted (projected) with that vertex' random\n// vector, and the result is bilinearly interpolated (lines 37 to 40 again) with a \n// smooth interpolant (line 33 and 35).\n\n\nvec2 hash22( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat hash21(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    //vec3 p3  = fract(vec3(p.xyx) * .1931);\n    //p3 += dot(p3, p3.yzx + 19.19);\n    //return fract((p3.x + p3.y) * p3.z);\n}\n\n// =================================================================================\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n    // Ease Curve\n\t//vec2 u = f*f*(3.0-2.0*f);\n    vec2 u = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n\n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                   dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    //return dot(hash22(i+vec2(0.0, 0.0)), f-vec2(0.0, 0.0));\n    //return dot(hash22(i+vec2(1.0, 0.0)), f-vec2(1.0, 0.0));\n    //return mix(dot(hash22(i+vec2(0.0, 0.0)), f-vec2(0.0, 0.0)),\n    //           dot(hash22(i+vec2(1.0, 0.0)), f-vec2(1.0, 0.0)), u.x);\n    \n    //return dot(hash22(i+vec2(0.0, 1.0)), f-vec2(0.0, 1.0));\n    //return dot(hash22(i+vec2(1.0, 1.0)), f-vec2(1.0, 1.0));\n    //return mix(dot(hash22(i+vec2(0.0, 1.0)), f-vec2(0.0, 1.0)),\n    //           dot(hash22(i+vec2(1.0, 1.0)), f-vec2(1.0, 1.0)), u.x);\n}\n\nfloat noise_fractal(in vec2 p)\n{\n\tp *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise(p); \n    p = m*p;\n\tf += 0.2500*noise(p); p = m*p;\n\tf += 0.1250*noise(p); p = m*p;\n\tf += 0.0625*noise(p); p = m*p;\n    \n    return f;\n}\n\n\nfloat noise_sum_abs(vec2 p)\n{\n    float f = 0.0;\n    p = p * 7.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.2500 * abs(noise(p)); p = 2.0 * p;\n    f += 0.1250 * abs(noise(p)); p = 2.0 * p;\n    f += 0.0625 * abs(noise(p)); p = 2.0 * p;\n\n    return f;\n}\n\nfloat value_noise(vec2 p)\n{\n    p *= 56.0;\n    vec2 pi = floor(p);\n    //vec2 pf = p - pi;\n    vec2 pf = fract(p);\n\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n\n    return mix(mix(hash21(pi + vec2(0.0, 0.0)), hash21(pi + vec2(1.0, 0.0)), w.x),\n              mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),\n              w.y);\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy ;\n\n\tvec2 uv = p * vec2(iResolution.x/iResolution.y , 1.);\n\t\n\tfloat f = 0.0;\n\t\n    // left: perlin noise\t\n\tif( p.x<0.25 )\n\t{\n\t\tf = noise( 16.0 * uv );\n\t}\n    // right: fractal noise (4 octaves)\n    else if(p.x>=0.25 && p.x<0.5)\t\n\t{\n\t\tf = noise_fractal(uv);\n\t}\n    else if(p.x>=0.5 && p.x<0.75)\n    {\n    \tf = noise_sum_abs(uv);\n    }\n    else \n    {\n    \tf = value_noise(uv);\n    }\n\n\tf = 0.5 + 0.5*f;\n\t\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.25));\n    f *= smoothstep(0.0, 0.005, abs(p.x-0.5));\t\n\tf *= smoothstep(0.0, 0.005, abs(p.x-0.75));\n    \n\tfragColor = vec4( f, f, f, 1.0 );\n}","name":"Image","description":"","type":"image"}]}