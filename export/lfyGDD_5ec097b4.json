{"ver":"0.1","info":{"id":"lfyGDD","date":"1713177145","viewed":38,"name":"AimTrainer","username":"Guraoz","description":"A simple aim trainer game.\n\nMouse to shoot targets\nSpace to reset","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["game","aim","trainer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Settings in Common (:\n\n// Score text from IQ (https://www.shadertoy.com/view/MddGzf)\n//     Digit data by P_Malin (https://www.shadertoy.com/view/4sf3RN)\nconst int[] font = int[](0x75557, 0x22222, 0x74717, 0x74747, 0x11574, 0x71747, 0x71757, 0x74444, 0x75757, 0x75747);\nconst int[] powers = int[](1, 10, 100, 1000, 10000);\nint PrintInt( in vec2 uv, in int value ){\n    \n    uv *= 15.0;\n    \n    const int maxDigits = 3;\n    if( abs(uv.y-0.5)<0.5 )\n    {\n        int iu = int(floor(uv.x));\n        if( iu>=0 && iu<maxDigits )\n        {\n            int n = (value/powers[maxDigits-iu-1]) % 10;\n            uv.x = fract(uv.x);\n            ivec2 p = ivec2(floor(uv*vec2(4.0,5.0)));\n            return (font[n] >> (p.x+p.y*4)) & 1;\n        }\n    }\n    return 0;\n}\n\nvec3 drawTarget(vec2 uv, vec2 pos){\n    float tMask = 1.0-smoothstep(0.0375 * targetScale, 0.045 * targetScale,length(uv - pos));\n    float tDetail = 1.0-smoothstep(0.0, 0.5,sin(length(uv - pos)*(500.0/targetScale)));\n    \n    vec3 t = mix(RED, WHITE, tMask*tDetail);\n    t = mix(t, BLACK, 1.0-tMask);\n    \n    return clamp(t * 20., 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvS = fragCoord.xy / iResolution.xy;\n\n    vec2 uv = fragCoord - iResolution.xy * 0.5;\n    uv /= iResolution.y;\n    vec2 m = iMouse.xy - iResolution.xy * 0.5;\n    m /= iResolution.y;\n    \n    vec2 mC = iMouse.zw - iResolution.xy * 0.5;\n    mC /= iResolution.y;\n    \n    vec2 scoreTextPos = (uv + vec2(0.0925, 0.0325));\n    vec3 col = vec3(0.0);\n    \n//----------\n//    Load Data\n//----------\n    vec2 targetPos = loadData(iChannel0, txTarget).xy;\n    targetPos += 0.5;\n    float nTargetTime = loadData(iChannel0, txTarget).z;\n    float hit = loadData(iChannel0, txTarget).w;\n    \n    int score = int(loadData(iChannel0, txScore).x);\n    float missCount = loadData(iChannel0, txScore).y;\n    float fbTimer = loadData(iChannel0, txScore).z;\n    \n    vec2 clickPos = loadData(iChannel0, txClick).xy - iResolution.xy * 0.5;\n    clickPos /= iResolution.y;\n    float clickTime = loadData(iChannel0, txClick).z;\n    \n//----------\n//    Background & Edge\n//----------    \n    //Squares\n    vec2 tUv = uv;\n    tUv *= 15.;\n    tUv = fract(tUv) - 0.5;\n    float det = smoothstep(0.0, 1.0, length(tUv * pow(sin(length(uv) + fbTimer - 0.5), 4.0))) * clamp((fbTimer - 0.5), 0.0, 1.0) * 0.5;\n    float sDet = smoothstep(0.0, 1.0, length(tUv)) * (1.0-length(uv)) * 0.05;\n    \n    //Edge\n    vec3 scoreColor = vec3(1.0);\n    float edge = uvS.x * (1.0 - uvS.x) * uvS.y * (1.0 - uvS.y);\n    edge = clamp(0.0, 1.0, pow(edge * 64.0, 0.031));\n    \n    //Apply\n    vec3 edgeCol = vec3(0.0);\n    edgeCol = (hit == 1.0) ? GREEN : RED * min(5.0, (missCount + 1.0));\n    if (fbTimer > 0.001){\n        col = mix(mix(WHITE, edgeCol, fbTimer * 1.0), BGColor, edge);\n        scoreColor = mix(WHITE, edgeCol, fbTimer * 0.5);\n        if (hit == 0.0){\n            col = mix(col, scoreColor, det);\n        }\n    }else{\n        col = mix(WHITE, BGColor, edge);\n    }\n    \n    col -= sDet;\n    \n//----------\n//    Aiming Reticle\n//----------\n    float reticle = sin(1.0-smoothstep(0.00, 0.03, length((uv - m) * clamp((1.0-clickTime), 0.425 * (1.0/targetScale), 1.0))) * 10.0);\n    col += smoothstep(0.0, 1.0, reticle) * 2.0;\n    \n//----------\n//    Firing Feedback\n//----------\n    vec3 clickColor = vec3(0.0);\n    if (clickTime >= 0.001){        \n        clickColor = (hit > 0.5) ? GREEN : RED;\n        col = mix(col, mix(clickColor * 2.0, WHITE, clickTime), clamp(sin(pow(length((uv - clickPos.xy) * 40.), 2.0) - (1.0 - clickTime * 4.0))  * smoothstep(0.97, 0.975, (1.0-length(uv - clickPos.xy))), 0.0, 1.0));\n    }\n    \n//----------\n//    Draw Target\n//----------\n    vec3 t = drawTarget(uv, targetPos) * pow(nTargetTime, 1.5);\n\n    //Glow from alro (https://www.shadertoy.com/view/3s3GDn)\n    float targetGlowMask = length(uv-targetPos);\n    float glowD = 1.0/length(targetGlowMask);\n    glowD *= 0.04 * targetScale;\n    glowD = pow(glowD, 3.0);\n    \n    col = mix(col, t + mix(RED, WHITE * 2.0, pow(nTargetTime, 4.0)), clamp(glowD * fbTimer, 0.0, 1.0));\n    col = 1.0-exp(-col);\n    \n    col = mix(col, WHITE, t);\n    \n//----------\n//    Game Over\n//----------\n#ifndef DEBUG\n    if (int(missCount) >= lives){\n        col = clamp(col - (1.0 - fbTimer), 0.0, 1.0);\n    }\n#endif\n    \n//----------\n//    Show Score\n//----------\n    float scoreText = float(PrintInt(scoreTextPos, score))* 0.25;\n    col = mix( col, scoreColor, scoreText );\n\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float random (float x){\n    return fract(sin(x) * 1000000.0);\n}\n\nbool checkHitResult (in vec2 target, in vec2 hit, inout float score){\n    if (abs(distance(target + 0.5, hit)) < 0.045 * targetScale){\n        score = round(score + 1.0);\n        return true;\n    }else{\n        return false;\n    }\n}\n\n//Meh, kinda silly but less duplicating ¯\\_(ツ)_/¯\nvoid updateTarget (inout vec2 targetP, inout float targetT, inout float hit, inout float fbTimer, in bool b){\n    targetP.x = 0.5 + ((random(fract(iTime) + iMouse.x) - 0.5) * 0.8 * 2.0) - 1.0;\n    targetP.y = max(0.1, min(0.9, random(fract(iTime)))) - 1.0;\n    \n    targetT = 1.0;\n    fbTimer = 1.0;\n    hit = b ? 1.0 : 0.0;\n}\n\nvoid updateLives (inout float missCount, inout float hit, inout float fbTimer, bool b){\n    missCount = round(missCount + 1.0);\n    hit = 0.0;\n    \n    fbTimer = b ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 m = iMouse.xy - iResolution.xy*0.5;\n    m /= iResolution.y;\n    \n//----------\n//    Load Data\n//----------\n    float score = loadData(iChannel0, txScore).x;\n    float missCount = loadData(iChannel0, txScore).y;\n    float fbTimer = loadData(iChannel0, txScore).z;\n    \n    vec2 targetPos = loadData(iChannel0, txTarget).xy;\n    float nTargetTime = loadData(iChannel0, txTarget).z;\n    float hit = loadData(iChannel0, txTarget).w;\n    \n    float targetUptime = loadData(iChannel0, txSettings).x;\n    float currentTargetUptime = loadData(iChannel0, txSettings).y;\n    \n    vec2 clickPos = loadData(iChannel0, txClick).xy;\n    float clickTime = loadData(iChannel0, txClick).z;\n    \n    \n    int gameState = 0; \n    if (score == 0.0){\n        gameState = -1; //pre-game\n    }else if (int(missCount) < lives){\n        gameState = 0;  //game\n    }else{\n#ifndef DEBUG\n        gameState = 1;  //post-game\n#endif\n    }\n    \n//----------\n//    Loop\n//----------\n#ifdef DEBUG\n    if (true){\n#else\n    if (gameState != 1){\n#endif\n\n    //----------\n    //    Mouse Click\n    //----------\n        if (iMouse.z > 0.0 && iMouse.w > 0.0){\n            clickPos.x = iMouse.z;\n            clickPos.y = iMouse.w;\n            clickTime = iTime;\n            if (gameState == -1){ //pre-game can't miss\n                checkHitResult(targetPos, m, score);\n            }else if (gameState == 0){\n                if (!checkHitResult(targetPos, m, score)) { //hit\n#if DIFFICULTY < 1\n                    updateLives(missCount, hit, fbTimer, false); //miss\n#endif\n                }\n            }\n        }\n\n    //----------\n    //    Generate Target\n    //----------\n        //Target timed out\n        if (nTargetTime == 0.0){\n            updateLives(missCount, hit, fbTimer, true);\n        }\n        //Target was hit\n        if (score != loadData(iChannel0, txScore).x){\n            updateTarget(targetPos, nTargetTime, hit, fbTimer, true);\n            targetUptime = clamp(defaultTargetUptime - diffPerTarget * score, minTargetUptime, defaultTargetUptime);\n            currentTargetUptime = targetUptime;\n        }else if (missCount != loadData(iChannel0, txScore).y){  //We missed\n            updateTarget(targetPos, nTargetTime, hit, fbTimer, false);\n            currentTargetUptime = targetUptime;\n        }\n#ifdef DEBUG\n        targetPos.x = 0.5 - 1.0;\n        targetPos.y = 0.5 - 1.0;\n#endif\n        if (gameState > -1){ //Target only fades once we started\n            nTargetTime = clamp(currentTargetUptime / targetUptime, 0.0, 1.0);\n            currentTargetUptime = clamp(currentTargetUptime - iTimeDelta, 0.0, defaultTargetUptime);\n        }\n    }\n    \n//----------\n//    Tick Timers\n//----------\n    fbTimer = clamp(fbTimer - iTimeDelta, 0.0, 1.0);\n    clickTime = clamp(clickTime - iTimeDelta * 3.0, 0.0, 1.0);\n\n//----------\n//    Save Data\n//----------\n    fragColor = vec4(0.0);\n    if (iFrame == 0 || loadData(iChannel1, ivec2(32, 0)).x > 0.5){ //Initialize\n        storeData(vec4(0.0, 0.0, 0.0, 0.0), txScore, fragColor, ivec2(fragCoord));\n        storeData(vec4(-0.5, -0.5, 1.0, 0.0), txTarget, fragColor, ivec2(fragCoord));\n        storeData(vec4(defaultTargetUptime, defaultTargetUptime, 0.0, 0.0), txSettings, fragColor, ivec2(fragCoord));\n        storeData(vec4(0.0, 0.0, 0.0, 0.0), txClick, fragColor, ivec2(fragCoord));\n    }else{ //Update\n        storeData(vec4(score, missCount, fbTimer, 0.0), txScore, fragColor, ivec2(fragCoord));\n        storeData(vec4(targetPos.x, targetPos.y, nTargetTime, hit), txTarget, fragColor, ivec2(fragCoord));\n        storeData(vec4(targetUptime, currentTargetUptime, 0.0, 0.0), txSettings, fragColor, ivec2(fragCoord));\n        storeData(vec4(clickPos.x, clickPos.y, clickTime, 0.0), txClick, fragColor, ivec2(fragCoord));\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//----------\n//    Game Settings\n//----------\n#define DIFFICULTY 0\n/*\n    Difficulty\n    0 - lose a life on miss or target timeout\n    1 - lose a life on target timeout\n*/\nconst int lives = 3;                   //How many targets you can miss\nconst float targetScale = 1.0;         //Size of targets\nconst float defaultTargetUptime = 1.0; //Default target uptime\nconst float diffPerTarget = 0.02;      //Targets' uptime is reduced by this amount, each time a target is hit\nconst float minTargetUptime = 0.5;     //Targets will stay up for this long, at least\n\n//#define DEBUG                        //No lives, targets stay in center\n\n//----------\n//    Visuals\n//----------\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 WHITE = vec3(1.0);\nconst vec3 BLACK = vec3(0.0);\nconst vec3 BGColor = vec3(0.251,0.251,0.251); //Background color\n\n//----------\n//    Texels\n//----------\nconst ivec2 txScore  = ivec2(0,0);     //score, missCount, fbTimer\nconst ivec2 txTarget = ivec2(1,0);     //targetPos.x, targetPos.y, nTargetTime, hit\nconst ivec2 txSettings = ivec2(2,0);   //targetUptime, currentTargetUptime\nconst ivec2 txClick = ivec2(3,0);      //clickPos.x, clickPos.y, clickTime\n\nvoid storeData(in vec4 data, in ivec2 pos, inout vec4 fragColor, in ivec2 fragCoord){\n    fragColor = (pos == fragCoord) ? data : fragColor;\n}\n\nvec4 loadData(sampler2D ch, in ivec2 pos){\n    return texelFetch(ch, pos, 0);\n}","name":"Common","description":"","type":"common"}]}