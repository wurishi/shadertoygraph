{"ver":"0.1","info":{"id":"Ndt3Dj","date":"1630660018","viewed":843,"name":"Aliens motion tracker","username":"day9","description":"Sound ON\nPLEASE REWIND ON FIRST LOAD [|<], TO MAKE AUDIO SYNC.\n\nControls:\n- mouse \n- WASD / arrows\n- R / space\n\nСycle period ~90 sec","likes":44,"published":1,"flags":56,"usePreview":0,"tags":["retro","crt","radar","alien","tracker","detector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Aliens motion tracker\" by Denis Liubushkin @day9 - 2021\n// https://creativecommons.org/licenses/by-nc-sa/4.0/\n// self https://www.shadertoy.com/view/Ndt3Dj\n\n/*\nBig thanks:\n     for awesome lessons, guides and examples: \n         Inigo Quilez @iq\n         Patricio Gonzalez Vivo & Jen Lowe\n         Martijn Steinrucken @BigWIngs\n         Fabrice Neyret @FabriceNeyret2\n         Pekka Väänänen @cce\n         and many others\n     for font shader: \n         @Andre https://www.shadertoy.com/view/4s3XDn\n\nInspired by a similar scene from the movie Aliens 1986.\nI'm just learning, so the code may not look optimal.\nEnjoy!\n*/\n\n\n\n// SCENE\n\n\n#define MOUSE    texelFetch(iChannel1, ivec2(1,1), 0)         // MOUSE look\n#define ROTMOUSE texelFetch(iChannel1, ivec2(1,2), 0).x *0.0  // MOUSE // rotate with mouse (not used)\n#define HOLDZOOM texelFetch(iChannel1, ivec2(3,0), 0).x       // UP / DOWN shake\n#define ZOOM     texelFetch(iChannel1, ivec2(3,1), 0).x       // UP / DOWN\n#define ROT      texelFetch(iChannel1, ivec2(4,1), 0).x       // LEFT / RIGHT rotate\n#define HOLDROT  texelFetch(iChannel1, ivec2(5,1), 0).x       // LEFT / RIGHT shake\n#define TOGGLE   texelFetch(iChannel1, ivec2(6,0), 0).x       // R / SPACE\n\n#define white vec4(1.0)\n#define black vec4(0.01, 0.01, 0.01, 1.0)\n#define dark  vec4(0.05, 0.05, 0.05, 1.0)\n#define red   vec4(1.00, 0.30, 0.20, 1.0)\n#define dblue vec4(0.40, 0.46, 0.54, 1.0)\n#define green vec4(0.08, 0.09, 0.08, 1.0)\n\n\n\nfloat Circle(vec2 uv, float r, float blur, float d) \n{\n    return smoothstep(r+blur, r-blur, length( vec2(uv.x + uv.y * d, uv.y)));\n}\n\nvec2 CrtScreen(vec2 uv, float r) \n{\n    uv = r * uv / sqrt(r*r - dot(uv, uv));\n    uv += 0.5;\n    return uv;\n}\n\n// Simplex Noise by iq\n// https://www.shadertoy.com/view/Msf3WH\nfloat Noise( in vec2 p ) \n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n    vec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n    vec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3  n = h*h*h*h*vec3( dot(a,Hash2(i+0.0)), dot(b,Hash2(i+o)), dot(c,Hash2(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec2 RotAroundZ(vec2 uv)\n{\n    float rot = - PI - IDLE - MOUSE.x - HOLDROT*0.6;\n    vec2 uv2 = mat2(cos(rot), -sin(rot), sin(rot), cos(rot)) * uv;\n    return uv2;\n}\n\n\n\n////////////////////////// BODY //////////////////////////\n\nvec4 ScannerReflect(vec2 uv) \n{\n    float rot = ROT - ROTMOUSE*0.3;\n    vec2 rotUv = -mat2(cos(rot), -sin(rot), sin(rot), cos(rot)) * uv;\n\n    float fwd, fwo, frd, fro, t1, t2, t3, shadow;\n\n    fwd = 1.0 - dot(rotUv, rotUv - vec2(0.5,-1.5) );                  // flare white direct\n    fwo = 1.0 - dot(rotUv, rotUv - vec2(-0.5,1.5) );                  // flare white opposite\n    frd = 1.0 - dot(rotUv - vec2(-0.3,0.5), rotUv - vec2(-1.0,0.5));  // flare red direct\n    fro = 1.0 - dot(rotUv - vec2(0.3,-0.5), rotUv - vec2(1.0,-0.5));  // flare red opposite\n\n    t1 = LIGHT1 + 3.0;\n    t2 = LIGHT2;\n    t3 = ALIENWAVE * 1000.0;\n    shadow = smoothstep(1.0, 0.0, rotUv.x - rotUv.y + 10.0 - t3);     // shadow from alienwave\n\n    fwd = clamp(fwd, 0.0, 2.0) * t1 * 0.25 * shadow;\n    fwo = clamp(fwo, 0.0, 2.0) * t1 * 0.25;\n    frd = clamp(frd, 0.0, 2.0) * t2 * 0.50;\n    fro = clamp(fro, 0.0, 2.0) * t2 * 0.50;  \n\n    return vec4(fwd, fwo, frd, fro);\n}\n\nvec4 ScannerBody(vec2 uv, vec4 col) \n{   \n    // uvs\n    uv *= 1.0 + IDLE * 0.5 - ZOOM * 0.8 + abs(HOLDROT) * 0.02;  // SCALE w/key\n\n    vec2 pivotpos = vec2(1.5, 0.5);                             \n    vec2 scanPivotPoint = RotAroundZ(uv + pivotpos) + pivotpos; \n\n    vec2 i = MOUSE.xy * 0.6 + abs(HOLDROT) * 0.3 + HOLDZOOM* 0.1 + IDLE2 * 10.0; // XY ROT/POS w/mouse & w/key\n\n    float crt = 2.5; \n    vec2 uvA, uvS, uvE, uvW;\n\n    uvA = + uv\n          - scanPivotPoint * 0.06                                // Z ROT w/mouse & w/key\n          + vec2(i.x * 0.2, i.y * 0.1)                           // XY ROT/POS w/mouse\n          - vec2(HOLDROT * 0.06, 0.0)                            // X POS w/key\n          + IDLE * IDLE * 50.0 - vec2(IDLE, 0.0) * 0.8 ;         // XY POS idle\n\n    uvS = CrtScreen( uvA +i*0.01, crt -abs(i.x)*0.2 -0.0) -0.5;  // inner shape\n    uvE = CrtScreen( uvA,         crt -abs(i.x)*0.4 +1.0) -0.5;  // outer shape\n    uvW = vec2( abs(uvE.x) +abs(uvE.y*0.05), uvE.y );            // scanner mirror and skew\n\n    // color and roughness \n    vec4 d = dark + 0.0;\n    float n1 = Noise(100.0*uvA) * Noise(120.0*uvA);\n    float n2 = 0.7 + 0.4 * n1;\n\n    // round box base size\n    float w = 0.57;\n    float h = 0.4;\n    float b = 0.004;\n    float cr = 0.02; // corners\n\n    // environment reflection\n    vec4 f = ScannerReflect(uv);\n    float fwd, fwo, frd, fro;\n    fwd = f.r; // flare white direct\n    fwo = f.g; // flare white opposite\n    frd = f.b; // flare red direct\n    fro = f.a; // flare red opposite\n\n    // inner 4-side reflection\n    float l1, l2, l3, l4, light, lightc, lightd, lighte;\n    l1 = smoothstep( h/w - cr, h/w + cr + cr,      abs(atan(uvS.x, uvS.y)) / PI);\n    l2 = smoothstep( h/w - cr, h/w + cr + cr,      abs(atan(uvS.x,-uvS.y)) / PI);\n    l3 = smoothstep( w*h,      w*h - cr - cr - cr, abs(atan(uvS.y, uvS.x)) / PI);  \n    l4 = smoothstep( w*h,      w*h - cr - cr - cr, abs(atan(uvS.y,-uvS.x)) / PI); \n\n    light = + mix(l1, l2, 0.5 - i.y) \n            - mix(l3, l4, 0.5 - i.x) \n            + mix(l3, l4, i.x + 0.5) \n            - mix(l1, l2, i.y + 0.5);\n\n    lightc = min(l1, l3) + min(l1, l4) + min(l2, l3) + min(l2, l4);      // corner mask\n    lightd = RoundBox(uvE, vec2(w, h)        + 0.02, 0.10, - b * 16.0);  // AO 1\n    lighte = RoundBox(uvW, vec2(w + 0.02, h) + 0.26, 0.05, - b * 8.0);   // AO 2\n\n\n\n    // SCREEN\n    float scr1 = RoundBox(uvS, vec2(w, h) + 0.01, 0.030, b * 1.5);       // screen\n    float scr2 = RoundBox(uvS, vec2(w, h) + 0.05, 0.035, b);             // black border\n    vec4 screen = scr1 * 0.06 + scr2 * green;      \n\n    vec2 uvD = vec2(uvS.x * iResolution.y / iResolution.x, uvS.y) * 0.87 + 0.5; \n\n    // convex screen shift\n    vec2 uvC = i * smoothstep(0.5, 0.0, length(uvD - 0.5)) * 0.02 * scr1;   \n    \n    vec4 img = screen;\n    img = texture(iChannel3, uvD - uvC) - ZOOM*0.2;    // less brightness on zoom\n\n    // toggle screen\n    img = mix(screen, img, (smoothstep(0.0, 1.0, TOGGLE) * smoothstep(0.5, 0.7, TOGGLE)) ); \n    screen = mix(screen, img, scr1);\n\n    // vignetting\n    float vig =  10.0 * (uvS.x + w + 0.1) * (w + 0.1 - uvS.x) * clmp((uvS.y + h + 0.1) * (h + 0.1 - uvS.y));\n    vig = pow(clmp(vig + 0.0), 0.15);\n    screen *= vec4(vig);\n\n    // on screen shadows \n    vec2 uvR = vec2(sin(- ROT - 0.5), sin(- ROT + 0.5));\n    screen += \n            + screen.a * fwd*fwd * 0.1                  // white reflect\n                * RoundBox(uvS - i*0.1 + uvR*0.08 \n                            - IDLE*IDLE*30.0 - vec2(IDLE,0.0)*0.1,\n                                          vec2(w, h) + 0.02, 0.03, b*4.0) \n\n            + screen.a * frd*frd * red * 0.2            // red reflect\n                * RoundBox(uvS - i*0.2 - uvR*0.12\n                            + IDLE*IDLE*40.0 - vec2(IDLE,0.0)*0.2, \n                                          vec2(w, h) + 0.05, 0.04, b*6.0)             \n\n            + screen.a * n1 * 0.03;                     // dust on screen\n\n\n\n    // on screen sharp edge\n    vec4 sharpE = d                                  \n         * RoundBox(uvS, vec2(w, h) + 0.048, 0.03, -b)\n         * RoundBox(uvS, vec2(w, h) + 0.050, 0.04,  b); // mask\n    sharpE += \n            + sharpE.a * clmp(light * 2.0) * 0.3\n            + sharpE.a * fwo*fwo * 0.2\n            + sharpE.a * fro*fro * red * 0.3\n            + sharpE.a * img * 0.6;                     // reflections\n    sharpE = clmp(sharpE);\n\n\n    // inner body A\n    vec4 frameA = d                                 \n         * RoundBox(uvS, vec2(w, h) + 0.05, 0.03, -b)\n         * RoundBox(uvE, vec2(w, h) + 0.05, 0.11,  b)   // mask\n         - 0.03 ; \n    frameA += \n            - frameA.a * (0.4 - lightd) * 0.15          // occlusion  \n            + frameA.a * lightc * 0.05                  // corners \n            + frameA.a * clmp(light * 2.0) * 0.1        // inner 4-side reflection\n            + frameA.a * fwo * 0.05                     // white reflect\n            + frameA.a * fro * red * 0.1                // red reflect\n            + frameA.a * n1 * 0.02                      // roughness\n            + frameA.a * img * 0.3;                     // from screen light reflection\n    frameA = clmp(frameA);    \n\n\n    // inner edge A\n    vec4 edgeA = d\n         * RoundBox(uvE, vec2(w, h) + 0.050, 0.09, -b * 2.0)\n         * RoundBox(uvE, vec2(w, h) + 0.055, 0.10, +b); \n    edgeA += \n            + edgeA.a * clmp(light * 2.0 + 1.6) * n2 * 0.2\n            + edgeA.a * frd*frd * red * 0.1\n            + edgeA.a * fwo*fwo * n2 * 0.3\n            + edgeA.a * fro*fro * red * n2 * 0.3\n            + edgeA.a * n1 * 0.1;\n    edgeA = clmp(edgeA);\n\n\n    // outer body B\n    vec4 frameB = d\n         * RoundBox(uvE, vec2(w, h)        + 0.055, 0.09, -b)\n         * RoundBox(uvW, vec2(w + 0.04, h) + 0.190, 0.05, +b);\n    frameB += \n            + frameB.a * fwd*fwd * n2 * 0.1\n                * RoundBox(uvW + uvR * 0.010, vec2(w + 0.04, h) + 0.14, 0.04, b * 3.0)\n            + frameB.a * frd*frd * red * n2 * 0.2\n                * RoundBox(uvW - uvR * 0.015, vec2(w + 0.04, h) + 0.14, 0.04, b * 3.0) \n            + frameB.a * n1 * 0.02;\n    frameB = clmp(frameB);\n\n\n    // outer edge B\n    vec4 edgeB = d\n         * RoundBox(uvW, vec2(w + 0.04, h) + 0.16, 0.04, -b * 2.0)\n         * RoundBox(uvW, vec2(w + 0.04, h) + 0.19, 0.05, +b);\n    edgeB += +0.02\n            + edgeB.a * clmp(light * 2.0) * 0.05\n            + edgeB.a * fwo*fwo*fwo * 0.1\n            + edgeB.a * fro*fro*fro * red * 0.1\n            + edgeB.a * n1 * 0.05;\n    edgeB = clmp(edgeB);\n\n\n    // outer body C\n    vec4 frameC = d \n         * RoundBox(uvW, vec2(w + 0.04, h) + 0.17, 0.05, -b)\n         * RoundBox(uvW, vec2(w + 0.04, h) + 0.24, 0.05, +b);\n    frameC += + 0.0 \n            + frameC.a * fwd * n2 * 0.1\n            + frameC.a * frd * red * n2 * 0.1\n            + frameC.a * n1 * 0.02;\n    frameC = clmp(frameC);\n\n\n    // outer edge C\n    vec4 edgeC = d\n         * RoundBox(uvW, vec2(w + 0.04, h) + 0.24, 0.04, -b * 2.0)\n         * RoundBox(uvW, vec2(w + 0.04, h) + 0.25, 0.05, +b);\n    edgeC += \n            + edgeC.a * clmp(-light) * 0.05\n            + edgeC.a * fwd*fwd * n2 * 0.2\n            + edgeC.a * frd*frd * red * n2 * 0.5\n            + edgeC.a * n1 * 0.05;\n    edgeC = clmp(edgeC);\n\n\n    // outer body D\n    vec4 frameD = d\n         * RoundBox(uvW,  vec2(w + 0.04, h) + 0.24, 0.05, -b)\n         * RoundBox(uvW + vec2(uvE.x * i.x, i.y) * 0.05, vec2(w + 0.04, h) + 0.29, 0.05, b * 6.0); \n    frameD += \n            + frameD.a * 0.05\n            + frameD.a * (0.0 - lighte) * 0.06\n            + frameD.a * clmp(0.0 - light) * 0.1\n            + frameD.a * fwd*fwd  * 0.05\n            + frameD.a * frd*frd * red * 0.1;\n    frameD = clmp(frameD);\n\n\n\n    // Holder\n    float fov = (ZOOM + 0.25) * 0.02;\n    float alpha = \n        RoundBox(uvW + vec2(uvE.x * i.x, i.y) * 0.05, vec2(w + 0.04, h) + 0.29, 0.05, b * 2.0 + fov);\n\n    uvA *= 1.03 + ZOOM * 0.1 + IDLE * 0.1;                      // HOLDER SCALE w/key\n    vec2 uvH = vec2(uvA.x + 1.2, abs(uvA.y) + uvA.x * 0.1);\n\n    float box1, box2, box3, box4, box5, box6; \n    box1 = RoundBox(uvH - vec2(0.0, - uvA.y * i.y * 0.1 ), vec2(1.0 - i.x * 0.05, 0.5 + i.x * uvA.x*uvA.x * 0.006), 0.06, b*2.0 + fov); // lower part\n    box2 = RoundBox(uvH - vec2(0.0, + uvA.y * i.y * 0.0 ), vec2(0.8 - i.x * 0.05, 0.3 + i.x * uvA.x*uvA.x * 0.006), 0.06,-b*1.5 - fov); // upper part\n    box3 = RoundBox(uvH + vec2(0.0, - uvA.y * i.y * 0.0 ), vec2(1.0 - i.x * 0.06, 0.5 + i.x * uvA.x*uvA.x * 0.004), 0.02, b*1.5 + fov); // middle part\n    box4 = RoundBox(uvH + vec2(0.0, + uvA.y * i.y * 0.1 ), vec2(0.2 - i.x * 0.06, 0.3 + i.x * uvA.x*uvA.x * 0.004), 0.02,-b*2.0 - fov); // hole\n    box5 = RoundBox(uvA + i * 0.10, vec2(0.50 - abs(i.x) * 0.01, 0.65), 0.1, b*1.5 + fov); // bottom body\n    box6 = RoundBox(uvA + i * 0.16, vec2(0.48 - abs(i.x) * 0.01, 0.64), 0.1, b*2.0 + fov); // bottom body depth\n\n    vec4 holder = \n        + d * box1 * box2\n        + black * box3 * box4\n        + black * box5\n        + d * (box6 - box5);\n\n    holder += \n            + holder.a * n1 * 0.02\n            + holder.a * fwd*fwd * 0.03          // white reflect\n            + holder.a * fwo*fwo * 0.08          // white shadow\n                * (1.0 - RoundBox(uvW - vec2(0.1) - vec2(i.x, -i.y) * 0.4, vec2(w + 0.04, h) + 0.27, 0.2, b * 16.0))\n            + holder.a * frd*frd * red * 0.05    // red reflect\n            + holder.a * fro*fro * red * 0.15    // red shadow\n                * (1.0 - RoundBox(uvW - vec2(0.1) + vec2(i.x, -i.y) * 0.3, vec2(w + 0.04, h) + 0.27, 0.2, b * 16.0));\n\n    holder = clmp(holder - holder * alpha);\n\n\n    // \n    col = mix (col, screen, screen.a);\n    col = mix (col, sharpE, sharpE.a);\n    col = mix (col, frameA, frameA.a);\n    col = mix (col, edgeA,  edgeA.a);\n    col = mix (col, frameB, frameB.a);\n    col = mix (col, edgeB,  edgeB.a);\n    col = mix (col, frameC, frameC.a);\n    col = mix (col, edgeC,  edgeC.a);\n    col = mix (col, frameD, frameD.a);\n    col = mix (col, holder, holder.a);\n    \n\n    col.a = clmp(alpha + holder.a);\n\n    return col;\n}\n\n\n\n////////////////////////// FLOOR //////////////////////////\n\nvec4 FloorGrid(vec2 uv, float b) \n{\n    uv.y *= 1.25;\n    uv *= 8.0;\n    float y = uv.y;\n    float x = uv.x;\n\n    float count = 6.0;\n    float space = 32.0;\n    float mult = 0.26;\n    float c, alpha, x1, x2, x3, x4, y1, y2, y3, y4, y5;\n\n    x1 = (x * count + 1.0) * PI + PI*0.5;                                                  // x holes\n    x2 = clamp(mod(x * count + 1.0, space) * PI               - PI*0.5, -PI*0.5, PI*1.5);  // x edges of section\n    x3 = clamp(mod(x * count / mult + 1.0, space / mult) * PI - PI*0.5, -PI*0.5, PI*1.5);  // x gap between section\n    y2 = clamp(mod(y * count * mult + 1.0, space * mult) * PI - PI*0.5, -PI*0.5, PI*1.5);  // y edges of section\n    y3 = clamp(mod(y * count / mult + 1.0, space / mult) * PI - PI*0.5, -PI*0.5, PI*1.5);  // y gap between section\n    // little random colors\n    x4 = x * 0.59;  \n    y4 = y * 0.59;\n    y5 = clamp(y*0.59 + PI, -PI*0.5, PI*1.5);\n\n    x1 = smoothstep(-b, b, sin(sin(x1) + 0.5));\n    x2 = smoothstep(-b, b, sin(sin(x2) - 0.5));\n    x3 = smoothstep(-b * 2.00, 0.0, -sin(x3) * 0.25);\n    float bb =  pow(b, 0.1) - 0.75; // adaptive blur for y edges\n    y2 = smoothstep(-bb, +bb, sin(sin(y2)) );\n    y3 = smoothstep(-b * 2.00, 0.0, -sin(y3) * 0.25 );\n    //\n    x4 = smoothstep(-b * 0.02, b * 0.02, sin(x4));\n    y4 = smoothstep(-b * 0.02, b * 0.02, sin(y4)) ;\n    y5 = smoothstep(-b * 0.05, b * 0.05, sin(y5)) ;\n\n    float m = max(0.5 - 0.5 / b, 0.0);                // height level\n    c = (x1 + x2) * (1.0 - y2) + y2 - m;              // holes + sections\n    c = c * (x3 * y3);                                // gaps\n    c = c + (-x4 -y4 -y5 -y5) * 0.1 + clmp(abs(y * 0.03)) * x4 - clmp(abs(x * 0.01)) * y4; // colors variations\n    c = c + c * (max(b, 1.0) - 1.0) * 0.2;            // blur add brightness\n\n    alpha = (x1 + x2) * (1.0 - y2) + y2;              // holes + sections\n    alpha = pow(alpha,max(b, 1.0));                   // blur add brightness\n\n    vec4 col = vec4(vec3(c), alpha);\n    return col;\n}\n\nfloat UnderFloor(vec2 uv, float b) \n{\n    uv.y *= 1.25;\n    uv *= 10.0;\n    float y = uv.y;\n    float x = uv.x;\n\n    float count = 4.5;\n    float space = 4.0;\n    float y1;\n\n    y1 = clamp( mod(y * count + 1.0, space) * PI - PI*0.5, -PI*0.5, PI*1.5); // y floor underlaps    \n    y1 = smoothstep(-b, +b, sin(sin(y1)) );\n    return y1;\n}\n\nvec4 FloorWires(vec2 uv, float b) \n{\n    uv *= 8.0;\n\n    float n1, n2, n3;\n    n1 = Noise(vec2(uv.x * 0.1, 0.0));\n    n2 = smoothstep(0.0, 1.0, sin(uv.x * 0.1));\n    n3 = Noise(vec2(uv.x * 0.3, 0.0) ) * 0.1;\n    float uvW = uv.y + n1 - uv.x * 0.1; // wire uv shape\n\n    float w1, w2, w3, w4, v1, v2, v3, v4, j1, j2, j3, j4;\n    \n    // wire 1\n    w1 = abs(fract(clmp(uvW + n3 + 8.1) - 0.44) - 0.5);                      // color\n    w2 = abs(fract(clmp(uvW + n3 + 8.1) - 0.50) - 0.5 );                     // wire mask\n    w3 = clmp(smoothstep(0.4 - b * 0.05, 0.41 + b * 0.05, w2) * (1.0 + w2)); // alpha, width\n    w4 = fract(clmp(-uvW - n3 - 7.1) - 0.5) - 0.6;                           // shadow\n    float shadow1 = clmp(w4 * 2.0) * (1.0 - w3); \n    // wire 2\n    v1 = abs(fract(clmp(uvW + n3 + n2 + 8.3) - 0.45) - 0.5);\n    v2 = abs(fract(clmp(uvW + n3 + n2 + 8.3) - 0.5) - 0.5);\n    v3 = clmp(smoothstep(0.4 - b * 0.05, 0.41 + b * 0.05, v2) * (1.0 + v2));\n    v4 = fract(clmp(-uvW - n3 - n2 - 7.3) - 0.5) - 0.6;\n    float shadow2 = clmp(v4 * 2.0) * (1.0 - v3);\n    // wire 3\n    j1 = abs(fract(clmp(uvW - n3 * 2.0 - uv.x * 0.1 + 5.1) - 0.45) - 0.5);\n    j2 = abs(fract(clmp(uvW - n3 * 2.0 - uv.x * 0.1 + 5.1) - 0.50) - 0.5);\n    j3 = clmp(smoothstep(0.4 - b * 0.05, 0.41 + b * 0.05, j2) * (1.0 + j2));\n    j4 = fract(clmp(-uvW + n3 * 2.0 + uv.x * 0.1 - 4.1) - 0.5) - 0.6;\n    float shadow3 = clmp(j4 * 2.0) * (1.0 - j3);\n\n    float wires = max(max(w1, v1), j1) * 0.6 - 0.27;\n    float mask = max(max(w3, v3), j3);\n    float shadow =  max(max(shadow1, shadow2), shadow3);\n\n    vec4 col = vec4(vec3(wires), clmp(mask + shadow));\n    \n    return col;\n}\n\nvec4 SceneFloor(vec2 uv, vec4 col) \n{\n    uv *= 1.0 - IDLE2 * 1.0 - ZOOM * 0.4 - abs(HOLDROT) * 0.02; // FLOOR SCALE w/key\n\n    float farblur = abs(uv.y + 1.0);\n\n    // uvs\n    uv.x *= 0.15;\n    uv -= vec2(0.0, 1.25); \n    uv.y *= ((uv.y - 3.0 + IDLE * 1.0 - ZOOM * 0.3) / abs(uv.y)) * 0.1; // look angle, height\n\n    float rot = PI * 0.5 - MOUSE.x * 0.2 - ROTMOUSE * 0.3 - IDLE * 0.6 + ROT - 0.04; // FLOOR ROTATION w/key & w/mouse\n\n    float posY = -MOUSE.y * sin(ROT) * 0.05 + IDLE*IDLE * 40.0 ;  // FLOOR MOVE w/mouse \n    float posX = -MOUSE.y * cos(ROT) * 0.05 + IDLE * 0.3;         //\n\n    float x = uv.x / uv.y * cos(rot) + (1.0 / uv.y - 1.6) * sin(rot) + posX;\n    float y = uv.x / uv.y * sin(rot) - (1.0 / uv.y - 1.6) * cos(rot) + posY;\n    vec2 uvA = vec2(x, y) + 0.2; // rotation + floor shift from center\n\n    \n    // setting\n    float blur = 0.4 + farblur * 1.0 + (ZOOM + 0.2) * 3.0; // 0.4 1.0 3.0\n\n    float n1, n2, n3, n4, n5;\n    n1 = Noise(20.0 * uvA);\n    n2 = Noise( + vec2(uvA.x * 3.0, uvA.y) * 5.0\n                + Noise(30.0 * uvA) * (5.0 - blur) * 0.02\n                + Noise(80.0 * uvA) * (5.0 - blur) * 0.01)\n                    * 0.02 * (3.0 - blur);\n    n3 = Noise(800.0 * uvA) * Noise(900.0 * uv);\n    n4 = Noise(2.0 * uvA) * (1.0 + sin(ROT) * 0.5) * 0.05;\n\n    float t1, t2, t3;\n    t1 = LIGHT1 * 0.25 + 1.0; // white period\n    t2 = LIGHT2;              // red period\n    t3 = ALIENWAVE * 50.0;    // alien period\n\n\n    // floor lights\n    float fwd, fwo, frd, fro;\n    fwd = clamp(uvA.x - uvA.y + 2.0, 0.0, 1.0) * t1 + clmp(uvA.x - uvA.y) * t1;   // flare white direct\n    fwo = Circle(uvA + vec2(-2.2, 0.7), 0.6, 0.4, 0.5) * t1;                      // flare white opposite\n    frd = Circle(uvA + vec2(1.0, -1.0), 0.0, 4.0, 0.0) * t2;                      // flare red direct\n    fro = Circle(uvA + vec2(1.0, -1.0), 0.4, 0.4,-0.5) * t2;                      // flare red opposite\n\n    // floor shadows\n    float sh, wsh, wsh0, wsh1, wsh2, wsh3, rsh, rsh0, rsh1, rsh2, rsh3, rhumansh, fulldarkly;\n    // main diagonally shadow\n    sh = smoothstep(0.0, 0.1, uvA.x + uvA.y * 0.6 - 1.2);\n    // aliens shadows on white \n    wsh0 = Circle(vec2(uvA.x + n4 + 32.0 - t3 * 8.0, uvA.y + n4 + 34.0 - t3 * 8.0), 0.75, -0.25, 0.0);\n    wsh1 = Circle(vec2(uvA.x - 1.5 + n4 - t3 * 0.5 + IDLE * 10.0, -uvA.y - uvA.x + 1.0 + t3 * 0.3), 0.5, -0.1, 0.0);\n    wsh2 = Circle(vec2(uvA.x - 1.7 + n4 - t3 * 0.2, -uvA.y - uvA.x + 1.6 + t3 * 0.8), 0.5, -0.1, 0.0);\n    wsh3 = Circle(vec2(uvA.x - 1.9 + n4 - t3 * 0.9, -uvA.y - uvA.x + 2.2 + t3 * 0.8), 1.15, -0.75, 0.0);                                                    \n    wsh = clmp(wsh1 * wsh2 * wsh3);\n    // aliens shadows on red \n    rsh0 = Circle(vec2(uvA.x + uvA.y * 2.0 - 1.4 + n4 + t3 * 0.3 - IDLE * 5.0, uvA.y - 1.6 + n4 - t3 * 0.4), 0.65, -0.1, 0.0);\n    rsh1 = Circle(vec2(uvA.x + uvA.y + 0.4 + n4 + t3 * 0.4 + IDLE2 * 8.0, uvA.y - 0.6 + n4 - t3 * 0.7), 0.45, -0.1, 0.0);\n    rsh2 = Circle(vec2(uvA.x + uvA.y + 1.1 + n4 + t3 * 0.6, uvA.y - 0.2 + IDLE * 10.0 + n4), 0.42, -0.08, 0.0);\n    rsh3 = Circle(vec2(uvA.x + n4 + 1.1 + t3 * 0.8, uvA.y + uvA.x * 1.5 + 2.2 + n4), 0.52, -0.08, 0.0);\n    rsh = clmp(rsh0 * rsh1 * rsh2 * rsh3 + 0.3);\n    // human shadow on red \n    rhumansh = Circle(uvA + n4 * 0.5 + vec2(-0.55, -0.1), 0.35, -0.01 - blur * 0.02, 1.0) + 0.4; \n    fulldarkly = clmp(0.8 + t3 * 0.2);\n    \n\n    // floor grid uvs\n    vec2 uvT = vec2(-cos(-ROT), sin(-ROT)) * (1.0 + farblur) * 0.005;\n    vec2 uvP = vec2(uv.x * sin(-ROT), uv.x * cos(-ROT)) * 0.02;\n    vec2 uvG = uvP - uvT;                                              \n    // floor grid top layer\n    vec4 gr, gr1, gr2, wires;\n    gr1 = FloorGrid(uvA + n1 * 0.0006, blur);      // floor surface\n    gr2 = FloorGrid(uvA + uvG, blur);              // floor thickness\n    wires = FloorWires(uvA, blur);        \n    // floor grid bottom layer\n    float uf, uf1, uf2;\n    uf1 = UnderFloor(uvA + uvG, blur);             // under-floor surface\n    uf2 = UnderFloor(uvA + uvG + uvG * 0.6, blur); // under-floor thickness\n    uf = mix(uf2, uf1, uf1);\n\n    \n    // floor thickness lights and shadows \n        // white \n    vec2 uvw = vec2(sin(-ROT * 0.5 - PI * 0.5) * 4.0, -cos(-ROT * 2.0) + PI);\n    float wm1, wm2;\n    wm1 = 1.0 - FloorGrid(uvA - uvw * 0.002, blur).r;\n    wm2 = (cos(-ROT + PI) * 0.4 + 0.6) * clmp(uvA.x * 0.7 - uvA.y * 0.5 + 1.0); \n    vec4 whitemask = clmp(wm1 * wm2 * white * t1) * 2.0;\n        // red\n    vec2 uvr = vec2(-sin(-ROT * 0.5) * 4.0, -cos(-ROT * 2.0)+ PI);\n    float rm1, rm2;\n    rm1 = 1.0 -FloorGrid(uvA + uvr * 0.002, blur).r;\n    rm2 = (cos(-ROT) * 0.4 + 0.6) * clmp(1.0 - uvA.x * 0.7 + uvA.y * 0.5);\n    vec4 redmask = clmp(rm1 * rm2 * red * red * rhumansh * t2) * 1.5; \n    \n    gr2 = mix(vec4(uf) * 0.9, gr2 + whitemask + redmask, gr2.a);  // under-floor lights\n    gr2 = mix(black, gr2, gr2.a);                                 // background color\n    gr2 = gr2 * dblue * 0.2;                                      // under-floor color\n\n\n    // floor surface color\n    float alpha = gr1.a;\n    gr1 = \n        + gr1 * dblue * 0.3 - n2 * 0.5                             // color\n        + frd * red * 0.2 * rhumansh * rsh                         // red light \n        + fro * (red + 0.2) * 0.3 * (1.0 + n2 * 30.0) * rsh        // red reflection\n        + fwd * white * 0.1 * sh * wsh0 * wsh                      // white light \n        + fwo * white * 1.0 * sh * wsh0 * wsh * (1.0 + n2 * 30.0); // white reflection\n    gr = mix(gr2, gr1, alpha);\n\n    // wires color\n    float walpha = wires.a;\n    wires = \n        + wires * dblue + vec4(0.0, 0.01, 0.02, 1.0)\n        + wires * frd * red * 0.4\n        + wires * 1.0 * t2 * red * 0.1\n        + wires.a * fwd * white * 0.05 * sh * wsh;\n    gr = mix(gr, wires, walpha);\n\n    // color correction, noise, volume light\n    vec4 grid = \n            + 0.1\n            + gr + n3 * 0.08\n            + fwd * white * 0.03 * sh * wsh\n            + frd * frd * red * 0.06;\n\n    return vec4(vec3(grid * fulldarkly), 1.0);\n}\n\n\nvec4 Scene(vec2 uv, vec4 col) \n{\n    col = ScannerBody(uv, col);\n    col = mix(SceneFloor(uv, col), col, col.a);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 1.6; // 1.6\n\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    col = Scene(uv, col);\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// COMMON\n\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n#define clmp(x) clamp(x, 0.0, 1.0)\n\n//setting\n#define TIMESCALE 1.0                 \n#define COMPASS 1                            // NESW\n#define SECTORCLEAR 2.4                      // alien detection distance (24.0 meter)\n#define ALIENSPEED 0.01                      // 0.01\n#define TIME (iTime*1.5 * TIMESCALE + 165.0) // start on 165.0 // top on 310.0\n\n#define IDLE sin(TIME) * 0.01\n#define IDLE2 (sin(TIME - 0.7) * 0.01)\n#define ALIENWAVE sin(TIME*ALIENSPEED) * sin(TIME*ALIENSPEED)\n#define LIGHT1 sin(iTime*1.5 * TIMESCALE * 0.73)\n#define LIGHT2 abs(sin(iTime*1.5 * TIMESCALE * 2.73) + 1.0)\n\n\n\nfloat Hash(float seed)\n{\n    return fract(sin(seed) * 43758.5453);\n}\n\nvec2 Hash2(vec2 uv ) \n{\n    uv = vec2( dot(uv,vec2(127.1,311.7)), dot(uv,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(uv)*43758.5453123);\n}\n\nfloat RoundBox(vec2 uv, vec2 size, float r, float b) \n{\n    float box = length(max(abs(uv) - size, 0.0)) - r;\n    return smoothstep(+b, -b, box);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// INPUT\n\n\n#define keyboard(Key)  texelFetch( iChannel3, ivec2(Key,0), 0 ).x\n#define texel(a,b)  texelFetch(iChannel0, ivec2(a, b), 0)\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n#define KEY_W     87\n#define KEY_A     65\n#define KEY_S     83\n#define KEY_D     68\n#define KEY_R     82\n#define KEY_SPACE 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // hold left mouse\n    if (ivec2(fragCoord.xy) == ivec2(2, 0))\n    { \n        fragColor = texel(2, 0);\n        if (iMouse.z > 0.5) {\n            fragColor.x += 0.1; }\n        else {\n            fragColor.x -= 0.01 * TIMESCALE; }\n        fragColor = clmp(fragColor);\n    }\n    float holdmouse = texel(2, 0).x;\n\n    // save current mouse position\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        fragColor.xy = iMouse.xy/iResolution.xy;\n    }           \n\n    // look with hold mouse\n    if (ivec2(fragCoord.xy) == ivec2(1, 1)) // MOUSE \n    {\n        vec4 m2 = texel(1,1); \n        vec4 m1 = texel(1,0);\n        if (m2.z > 0.5) { \n            m2.xy += iMouse.xy/iResolution.xy - m1.xy; } \n        m2.z = iMouse.z; \n        fragColor = m2;\n        fragColor = clamp(fragColor, -1.0, 1.0) * holdmouse; \n    }\n\n    // rotate with mouse (not used)\n    if (ivec2(fragCoord.xy) == ivec2(1, 2)) // ROTMOUSE\n    {             \n        vec4 m3 = texel(1,2); \n        vec4 m1 = texel(1,0); \n        if (m3.z > 0.5) { \n            m3.xy += iMouse.xy/iResolution.xy - m1.xy; }\n        m3.z = iMouse.z;\n        fragColor = m3;\n    }\n\n\n\n    // shake with up-down keys \n    if (ivec2(fragCoord) == ivec2(3, 0))  // HOLDZOOM\n    { \n        fragColor = texel(3, 0); \n        if (keyboard(KEY_DOWN) > 0.5 || keyboard(KEY_S) > 0.5) {\n            fragColor.x += 0.1 * TIMESCALE; } \n        else { \n            fragColor.x -= 0.05 * TIMESCALE; } \n        if (keyboard(KEY_UP) > 0.5 || keyboard(KEY_W) > 0.5) {\n            fragColor.y += 0.1 * TIMESCALE; }\n        else {\n            fragColor.y -= 0.05 * TIMESCALE; }                          \n        fragColor = clmp(fragColor);\n    }\n    vec4 shakeup = texel(3, 0);\n\n    // zoom with up-down keys\n    if (ivec2(fragCoord) == ivec2(3, 1)) // ZOOM \n    {\n        fragColor = texel(3, 1);\n        fragColor = clamp(fragColor, -0.2, 0.4); \n        fragColor.x += (shakeup.y - shakeup.x) * 0.02 * TIMESCALE;\n    }\n\n\n\n    // rotate with left-right keys\n    if (ivec2(fragCoord) == ivec2(4, 0)) \n    {                              \n        fragColor = texel(4, 0); \n        if (keyboard(KEY_LEFT) > 0.5 || keyboard(KEY_A) > 0.5) {\n            fragColor.x += 0.02 * TIMESCALE; } \n        else { \n            fragColor.x -= 0.02 * TIMESCALE; }                              \n        if (keyboard(KEY_RIGHT) > 0.5 || keyboard(KEY_D) > 0.5) {\n            fragColor.y += 0.02 * TIMESCALE; }            \n        else { \n            fragColor.y -= 0.02 * TIMESCALE; }                                 \n        fragColor = clmp(fragColor); \n    }\n    vec4 rotlr = texel(4, 0);\n\n    if (ivec2(fragCoord) == ivec2(4, 1)) // ROT\n    {                              \n        fragColor = texel(4, 1);\n        fragColor.x += (rotlr.y - rotlr.x) * 0.02 * TIMESCALE;              \n    }\n\n    // shake with left-right keys (slowly)\n    if (ivec2(fragCoord) == ivec2(5, 0)) \n    {\n        fragColor = texel(5, 0); \n        if (keyboard(KEY_LEFT) > 0.5 || keyboard(KEY_A) > 0.5) {\n            fragColor.x += 0.05 * TIMESCALE; } \n        else { \n            fragColor.x -= 0.01 * TIMESCALE; }   \n        if (keyboard(KEY_RIGHT) > 0.5 || keyboard(KEY_D) > 0.5) {\n            fragColor.y += 0.05 * TIMESCALE; } \n        else { \n            fragColor.y -= 0.01 * TIMESCALE; }   \n        fragColor = clmp(fragColor);       \n    }\n    vec4 shakelr = texel(5, 0);\n\n    if (ivec2(fragCoord) == ivec2(5, 1))  // HOLDROT \n    {\n        fragColor = clamp(fragColor, -0.1, 0.1);\n        fragColor.x += (shakelr.y - shakelr.x); \n    }\n\n\n    // toggle with r-space keys\n    float r = texelFetch( iChannel3, ivec2(KEY_R,2),0 ).x; \n    float space = texelFetch( iChannel3, ivec2(KEY_SPACE,2),0 ).x;\n\n    if (ivec2(fragCoord) == ivec2(6, 0)) // TOGGLE\n    {                              \n        fragColor = texel(6, 0);              \n        if ( space > 0.5 || r > 0.5 ) {\n            fragColor.x -= 0.02; }                         \n        else {\n             fragColor.x += 0.02; }                                   \n        fragColor = clmp(fragColor);                         \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// DISPLAY\n\n\n#define MOUSE    texelFetch(iChannel1, ivec2(1,1), 0)        // MOUSE look\n#define ROTMOUSE texelFetch(iChannel1, ivec2(1,2), 0).x*0.0  // MOUSE // rotate with mouse (not used)\n#define ROT      texelFetch(iChannel1, ivec2(4,1), 0).x      // LEFT / RIGHT rotate\n\n#define white vec3(1.0)\n#define black vec3(0.0)\n#define red   vec3(0.9, 0.25,0.2)\n#define green vec3(0.5, 0.9, 0.5)\n#define blue  vec3(0.5, 0.8, 1.0)\n#define dblue vec3(0.1, 0.2, 0.7)\n\n\nfloat Circle(vec2 uv, float r, float blur) \n{\n    float c = smoothstep(r+blur, r-blur, length(uv));\n    return  c;\n}\n\nfloat Line(vec2 uv, vec2 a, vec2 b) \n{\n    float t = clamp(dot(uv-a, b-a) / dot(b-a, b-a), 0.0, 1.0);\n    return length(uv - a - (b-a) * t);\n}\n\nvec2 Puv(vec2 uv, float rot, float count) // Polar uv\n{ \n    float d = length(uv);\n    float a = atan(uv.y, uv.x) / PI * 0.5 + 0.5;\n    return vec2(fract((a + rot) * count) - 0.5, d); \n}\n\nvec2 Ruv(vec2 uv, float rot, float count) // Radial uv\n{ \n    float a = atan(uv.y, uv.x) / PI * 0.5 + 0.5; \n    a = floor((a + rot) * count) - rot * count; // split parts\n    a = (a + 0.5) * (PI * 2.0 / count);         // offset\n    vec2 parts = vec2(cos(a), sin(a)) + uv;\n    float r = -PI * 0.5 + a ;\n    return mat2(cos(r), -sin(r), sin(r), cos(r)) * parts;\n}\n\nfloat Distort(vec2 uv) \n{\n    float p1 = sin(uv.x);\n    float p2 = sin(uv.y);\n    float p3 = sin(uv.x - uv.y);\n    float p4 = sin(length(uv));\n    return p1 + p2 + p3 + p4;\n}\n\nvec2 RotWithInput(vec2 uv) \n{\n    float rot = - MOUSE.x*0.1 - ROTMOUSE*0.3 + ROT - PI - IDLE2; // mouse, idle, keys\n    return mat2(cos(rot), -sin(rot), sin(rot), cos(rot)) * uv; \n}\n\n\n\n////////////////////////// FONT BLOCK //////////////////////////\n// Shadertext shader by @Andre \n// https://www.shadertoy.com/view/4s3XDn\n\n// Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.1),uv.y+.4));\n}\nfloat ddiv(vec2 uv) {\n    return Line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat sp(vec2 uv) { // space\n    return 1.0;\n}\n// These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Numbers\nfloat _11(vec2 uv) {\n    return min(min(\n             Line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));            \n}\nfloat _22(vec2 uv) {\n    float x = min(Line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  Line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               Line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n// Characters\nfloat mm(vec2 uv) {\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\n\n// Capitals\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))), \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  Line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,Line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  Line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(Line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               Line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return Line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\n\n#define _dot ch(ddot,0.35);\n#define _und ch(und,0.7);\n#define _div ch(ddiv,0.9);\n#define _sp ch(sp, 0.1);\n\n#define _1 ch(_11,0.9);\n#define _2 ch(_22,0.9);\n#define _3 ch(_33,0.9);\n#define _4 ch(_44,0.9);\n#define _5 ch(_55,0.9);\n#define _6 ch(_66,0.9);\n#define _7 ch(_77,0.9);\n#define _8 ch(_88,0.9);\n#define _9 ch(_99,0.9);\n#define _0 ch(_00,0.9);\n\n#define a_ ch(aa,0.9);\n#define m_ ch(mm,1.0);\n\n#define C_ ch(CC,0.9);\n#define D_ ch(DD,0.9);\n#define E_ ch(EE,0.9);\n#define F_ ch(FF,0.9);\n#define M_ ch(MM,1.1);\n#define N_ ch(NN,0.9);\n#define S_ ch(SS,0.9);\n#define W_ ch(WW,1.1);\n#define X_ ch(XX,1.0);\n\n#define ch(letter,w) b = min(b, letter( charUv(uv,cp+=w,w) )); // print chars on canvas\n\nvec2 charUv(vec2 uv, float cp, float w) // shift position forward by 1 character width\n{ \n    return uv-vec2(cp-(w*.5),0.); \n}\n\nfloat get_digit(vec2 uv, float b, float cp, float d) // uv, canvas, space, number\n{\n    d = floor(d);\n    if(d == 0.0) return _0;\n    if(d == 1.0) return _1;\n    if(d == 2.0) return _2;\n    if(d == 3.0) return _3;\n    if(d == 4.0) return _4;\n    if(d == 5.0) return _5;\n    if(d == 6.0) return _6;\n    if(d == 7.0) return _7;\n    if(d == 8.0) return _8;\n    if(d == 9.0) return _9;\n    return b;\n}\n\nfloat FEMSCX(vec2 uv) {\n    float b = 1.0; // init chars canvas\n    float cp = 0.0;\n\n    F_ E_ _dot M_ _dot S_ _und _sp _sp _9 _dot _9 _4 _7 _dot _5 _2\n    b = ch(sp, 15.0); // space between two titles\n    C_ X_ _und _sp _sp _3 a_ _div _3 D_ _dot _0\n\n    float t = sin(iTime * TIMESCALE * 6.0); // jitter last number\n    if (t < 0.8) {_0} else if (t > 0.95) {_2} else {_1}\n\n    float w = 0.11;    // BOLD\n    float blur = 0.03; // blur\n    b = mix(0.0, 1.0, smoothstep(w-blur, w+blur, b));\n    return b;\n}\n\nfloat meterB(vec2 uv,  float dist) {\n    float b = 1.0;\n    float cp = 0.0;\n    float d = mod(dist * 100.0, 1.0);\n\n    _sp _dot _sp _dot _sp\n\n    if (dist * 10.0 < SECTORCLEAR) // if target detected\n    { \n        if (d < 0.25)      {_0 _0} \n        else if (d < 0.5)  {_2 _5} \n        else if (d < 0.75) {_5 _0} \n        else               {_7 _5} \n    }\n    else \n    { _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp _sp }\n\n    uv.y *= 1.2;\n    uv += vec2(0.4, 1.5); // m offset\n    m_\n\n    float w = 0.1;\n    float blur = 0.03; \n    b = mix(0.0, 1.0, smoothstep(w-blur, w+blur, b));\n    return b;\n}\n\nfloat meterA(vec2 uv, float dist) {\n    uv *= 0.5;\n    float b = 1.0;\n    float cp = 0.0;\n\n    if (dist*10.0 < 1.0)      {_sp _sp _sp _sp _sp _sp _sp _sp}\n    else if (dist*10.0 < 2.0) {_1} \n    else                      {_2}\n\n    b = get_digit(uv, b, cp, mod(dist*100.0, 10.0) );\n\n    if (dist*10.0 > SECTORCLEAR) {b = 1.0;} // if no target in range\n\n    float w = 0.07;\n    float blur = 0.03;\n    b = mix(0.0, 1.0, smoothstep(w-blur, w+blur, b));\n    return b;\n}\n\nfloat NESW(vec2 uv, int j) {\n    float b = 1.0;\n    float cp = 0.0;\n    if (j == 0)      {N_}\n    else if (j == 1) {E_}\n    else if (j == 2) {S_}\n    else if (j == 3) {W_}\n\n    float w = 0.11;\n    float blur = 0.05;\n    b = mix(0.0, 1.0, smoothstep(w-blur, w+blur, b));\n    return b;\n}\n\n\n\n////////////////////////// ALIENS //////////////////////////\n\n// speed shape\nfloat Tick(float shift, float phase)\n{\n    float speedup = 4.0;\n    return pow(mod(TIME - shift, phase), speedup);\n}\n\nfloat Scan(vec2 uv, float width, float shift, float phase, float blur) \n{ \n    float t = Tick(shift, phase);\n    float s1 = Circle(uv, t - width, -width);\n    float s2 = Circle(uv, t, -blur);\n    return mix(0.0, 1.0, clmp(s1 - s2));\n}\n\n// mask for split aliens\nfloat ScanMask(vec2 uv, float shift) \n{ \n    float t = Tick(0.0, 1.0);\n    float s2 = Circle(uv, t, -0.001);\n    return mix(0.0, 1.0, clmp(s2));\n}\n\nfloat AlienSeed(vec2 uv, float ti) \n{\n    float p = Distort(uv * 50.0) * 0.005;\n    uv *= 2.5 + p;\n\n    float c = 0.0;       // canvas\n    float count = 500.0; // 500\n    float range = 10.0;  // 10.0\n    float density = 1.8; // 1.8\n    float jitter = 50.0; // 30.0\n\n    float t = floor(ti) * ALIENSPEED;\n    float tsin = sin(t) * sin(t) * range + 1.4; // ~ ALIENWAVE\n    \n    for(float i = 0.0; i < count; i++) \n    {\n        float r = Hash(i) * density;\n        float theta = Hash(i-0.1) * PI * 2.0;\n        vec2 pos = vec2( (r + tsin*0.2) * cos(theta), (r + tsin*0.2) * sin(theta) );\n\n        float v1 = sin(t * Hash(i-0.1) * jitter);\n        float v2 = sin(t * Hash(i-0.2) * jitter);\n        float v3 = sin(t * Hash(i-0.3) * jitter);\n        pos += vec2(v1 - v2, v3) * 0.05;\n\n        float radius = Hash(i-0.4) * 0.01 + 0.01;\n\n        c += Circle(uv-pos, radius, 0.12);\n    }\n    return c;\n}\n\nvec3 Aliens(vec2 uv, vec3 col, float dist) \n{\n    float a = AlienSeed(uv, TIME) * ScanMask(uv, 0.0);\n    float b = AlienSeed(uv, TIME+1.0) * (1.0-ScanMask(uv, 0.0));\n    float mask = a + b;\n\n    float fade = clmp(1.3 - Scan(uv, 7.5, 0.0, 2.0, 0.001)) * clmp(1.3 - Scan(uv, 7.5, 1.0, 2.0, 0.001)); // 7.5\n\n    vec3 col1 = mix(col, blue, min(pow(mask, 0.5 + fade*0.4), 0.2) ) * (4.0-fade);\n    vec3 col2 = mix(col, blue, clmp(pow(mask, fade*2.0)) )  * (1.5-fade) - clmp(sqrt(mask)) * 0.3;\n\n    col = col1 + col2 * 0.7;\n    col += mix(col, black, sqrt(fade));\n\n    if (dist*10.0 > SECTORCLEAR) {col = vec3(0.0);} // if aliens far away clear display\n\n    col += // scanning effect\n        + Scan(uv, 0.03, 0.000, 1.0, 0.001) * 0.8\n        + Scan(uv, 0.08, 0.000, 1.0, 0.010 + pow(mod(TIME, 1.0), 4.0) * 0.10) * blue \n        + Scan(uv, 0.02, 0.085, 1.0, 0.001) * 0.2\n        + Scan(uv, 0.04, 0.085, 1.0, 0.010 + pow(mod(TIME, 1.0), 4.0) * 0.02) * blue ;\n\n    return col; \n}\n\n\n////////////////////////// DISPLAY //////////////////////////\n\nvec3 CompassChars(vec2 uv, vec3 col) \n{\n    float box = + RoundBox(abs(uv) - vec2(0.0, 0.48), vec2(0.015, 0.015), 0.01, 0.002)\n                + RoundBox(abs(uv) - vec2(0.48, 0.0), vec2(0.015, 0.015), 0.01, 0.002);\n\n    uv = uv*42.0;\n\n    float r = PI / 2.0;\n    vec2 p = mat2(cos(r),-sin(r), sin(r), cos(r)) * uv;\n\n    float n, e, s, w;\n    n = NESW(uv  + vec2(0.45, 20.2), 0 );\n    e = NESW(p   + vec2(0.45,-20.1), 1 );\n    s = NESW(-uv + vec2(0.45, 20.2), 2 );\n    w = NESW(-p  + vec2(0.55,-20.1), 3 );\n\n    if (COMPASS == 1)\n        {col = mix(blue, col*(1.0-box), 1.0-box*(n*e*s*w));}\n    else if (COMPASS == 0)\n        {col = col;}\n\n    return col;\n}\n\nvec3 GridLines(vec2 uv, vec3 col) \n{\n    uv*=4.0;\n\n    float gra, grb, grc, grd,                               // vertical lines\n          gre, grf, grg, grh, gri, grj, grk, grl, grm, grn, // small lines\n          gpa, gpb, gpc, gpd,                               // horizontal lines\n          gga, ggb, ggc, ggd,                               // small rings\n          group, group1, group2, group3, group4;\n   \n    gra = Line( Ruv(uv, 0.125, 4.0), vec2(0.0, 0.3),  vec2(0.0,-1.32) ); // (uv, rot, count), p1, p2\n    grb = Line( Ruv(uv, 0.000, 4.0), vec2(0.0,-0.12), vec2(0.0,-1.31) );\n    grc = Line( Ruv(uv, 0.000, 8.0), vec2(0.0,-1.08), vec2(0.0,-1.31) );\n    grd = Line( Ruv(uv, 0.000, 8.0), vec2(0.0,-0.0),  vec2(0.0,-0.17) );\n    \n    gre = Line( Ruv(uv, 0.193, 4.0), vec2(0.0,-0.04), vec2(0.0,-0.08) );\n    grf = Line( Ruv(uv,-0.193, 4.0), vec2(0.0,-0.04), vec2(0.0,-0.08) );\n    grg = Line( Ruv(uv, 0.004, 4.0), vec2(0.0,-0.04), vec2(0.0,-0.08) );\n    grh = Line( Ruv(uv,-0.004, 4.0), vec2(0.0,-0.04), vec2(0.0,-0.08) );\n    gri = Line( Ruv(uv, 0.185, 4.0), vec2(0.0,-1.12), vec2(0.0,-1.16) );\n    grj = Line( Ruv(uv,-0.185, 4.0), vec2(0.0,-1.12), vec2(0.0,-1.16) );\n    grk = Line( Ruv(uv,-0.1225,4.0), vec2(0.0,-1.12), vec2(0.0,-1.16) );\n    grl = Line( Ruv(uv, 0.1225,4.0), vec2(0.0,-1.12), vec2(0.0,-1.16) );\n    grm = Line( Ruv(uv,-0.1225,4.0), vec2(0.0,-1.24), vec2(0.0,-1.28) );\n    grn = Line( Ruv(uv, 0.1225,4.0), vec2(0.0,-1.24), vec2(0.0,-1.28) );\n    \n    gpa = Line( Puv(uv, 0.000, 1.0), vec2(0.5, 1.0),  vec2(-0.5, 1.0) );\n    gpb = Line( Puv(uv, 0.000, 1.0), vec2(0.5, 2.2),  vec2(-0.5, 2.2) );\n    gpc = Line( Puv(uv, 0.000, 4.0), vec2(0.24,1.12), vec2(-0.24,1.12) );\n    gpd = Line( Puv(uv, 0.125, 4.0), vec2(0.24,2.08), vec2(-0.24,2.08) );\n    \n    gga = Line( Puv(abs(uv) - vec2(0.0, 0.7), 0.0, 1.0), vec2(0.5, 0.04), vec2(-0.5, 0.04) );\n    ggb = Line( Puv(abs(uv) - vec2(0.7, 0.0), 0.0, 1.0), vec2(0.5, 0.04), vec2(-0.5, 0.04) );\n    ggc = Line( Ruv(uv, 0.110, 4.0), vec2(0.0, 0.30), vec2(-0.01,0.3) );\n    ggd = Line( Ruv(uv,-0.110, 4.0), vec2(0.0, 0.30), vec2(0.01, 0.3) );\n\n    group1 = min(gra, min(grb, min(grc, min(grd, 1.0) )));\n    group2 = min(gre, min(grf, min(grg, min(grh, min(gri, min(grj, min(grk, min(grl, min(grm, min(grn, 1.0) )))))))));\n    group3 = min(gpa, min(gpb, min(gpc, min(gpd, 1.0) )));\n    group4 = min(gga, min(ggb, min(ggc, min(ggd, 1.0) )));\n\n    group = min(group1, min(group2, min(group3, group4) ));\n\n    float w = 0.012;\n    float blur = 0.01;\n\n    col = mix(blue, col, smoothstep(w-blur, w+blur,  group) );\n\n    col = CompassChars(uv / 4.0, col);\n\n    return col;\n}\n\nfloat HudGlow(float dist)\n{\n    return pow(1.5 / dist * 0.05, 0.8);\n}\n\nvec3 Hud(vec2 uv, vec3 col) \n{\n    uv *= 5.0; \n    float band = step(uv.y, 0.02);\n    uv.x = abs(uv.x) - 0.5; // mirror hud\n\n    float g2, g3, g4, glow;\n    g2 = clmp(HudGlow(0.3 - uv.x*uv.y));\n    g3 = clmp(HudGlow(0.5 + uv.y));\n    g4 = clmp(HudGlow(0.2 + uv.y)); \n    glow = max(min(min(g4, g2), g2), g3);\n    glow = 1.0 - exp(-clmp(glow)); // add glow\n\n    uv.x = clamp(uv.x * 5.0, step(0.11, uv.x), 1.0); // chamfer\n    uv.y = uv.y * 2.8 + 1.0; // y pos\n    float hud = step(uv.y - uv.x, 0.0);\n\n    col = mix(col, black, band);\n    col = mix(col, dblue, max(hud, glow));\n    \n    return col;\n}\n\n\nvec3 Text(vec2 uv, vec3 col, float dist) \n{\n    uv = uv * 42.0 - vec2(-3.5, -2.1);\n\n    float text = FEMSCX(uv - vec2(-15.5, 0.0));\n    float metA = meterA(uv - vec2(0.0, 0.6), dist);\n    float metB = meterB(uv - vec2(3.5, 1.2), dist);\n\n    // text coloring\n    col = mix(blue, col, text);\n    col = mix(red, col, metA);\n    col = mix(red, col, metB);\n\n    return col;\n}\n\nvec3 Display(vec2 uv, vec3 col) \n{\n    float dist =  \n                + sin(floor(TIME) * ALIENSPEED) * sin(floor(TIME) * ALIENSPEED) * 0.25 // ~ ALIENWAVE\n                + sin(floor(TIME)) * 0.002 \n                + 0.01;\n\n    float display1 = RoundBox(uv, vec2(0.57, 0.4) + 0.03, 0.03, 0.004);\n    float display2 = RoundBox(uv, vec2(0.57, 0.4) + 0.05, 0.02, 0.002);\n\n    uv.y += 0.2;\n\n    vec2 rotUv = RotWithInput(uv);\n    vec3 aliens = Aliens(rotUv, col, dist);\n    vec3 grid = GridLines(rotUv, col);\n\n    col = grid + aliens * (1.0 - grid.g * 0.75);\n    col = Hud(uv, col);\n    col = Text(uv, col, dist);\n    \n    // screen border mask\n    col = mix(black, col, (display1 + display2) * 0.5);\n\n    // outside screen reflections\n    float band = smoothstep(-0.0, -0.3, uv.y - 0.2);\n    float scan = Scan(uv, 0.3, 0.02, 1.0, 0.2);\n    float ring = smoothstep(1.05, 0.0, length(uv - vec2(0.0, 0.12) ));\n    float freq1 = abs(sin(TIME * ALIENSPEED));\n    float freq2 = 0.5 +pow(mod(TIME, 1.0), 4.0) * 0.5;\n\n    col = mix(col, vec3(0.0,0.3,1.0) * 0.5, band * (1.0-display2)); // hud reflection\n    col = mix(col, white * 0.4, scan * 1.5 * (1.0-display2) * (1.0-band*scan) ); // scan reflection\n    col = mix(col, blue * 2.0, ring * (1.4-freq1) * (1.3-freq2) * (1.0-display2) * (1.4-band)); // alien reflection\n\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv *= 1.15;\n\n    vec3 col = vec3(0.0);\n    col = Display(uv, col);\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// DISPLAY POSTPROCESSING\n\n\n#define TOGGLE texelFetch(iChannel1, ivec2(6,0), 0).x    // R / SPACE\n#define ZOOM   texelFetch(iChannel1, ivec2(3,1), 0).x    // UP / DOWN\n\n\nvec4 blur(vec2 uv, vec4 col) \n{\n    vec2 dist = 2.0 / iResolution.xy;\n    int s = 2; // samples\n    for(int x = -s; x <= s; x++) {\n    \tfor(int y = -s; y <= s; y++) {\n\t\t\tcol += texture(iChannel2, uv + vec2(x,y) * dist);\n        }\n    }\n    return col *= 0.030;\n}\n\nvec2 AA(vec2 uv, float width)\n{\n    uv = uv * iResolution.xy;\n    vec2 uvf = floor(uv + 0.5);\n    uv = uvf + clamp((uv - uvf) / fwidth(uv) / width, -0.5, 0.5);\n    return uv / iResolution.xy;\n}\n\n// Hexgrid by laserdog\n// https://andrewhungblog.wordpress.com/2018/07/28/shader-art-tutorial-hexagonal-grids/\nvec4 calcHexInfo(vec2 uv, float c)\n{   \n    uv *= c;\n    vec2 s = vec2(1.0, 1.7320508);\n    vec4 hexCenter = round(vec4(uv, uv - vec2(0.5, 1.0)) / s.xyxy );\n    vec4 offset = vec4(uv - hexCenter.xy * s, uv - (hexCenter.zw + 0.5) * s);\n    return dot(offset.xy, offset.xy) < dot(offset.zw, offset.zw) ? vec4(offset.xy, hexCenter.xy) : vec4(offset.zw, hexCenter.zw);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy ;\n\n    vec2 uvD = uv - 0.5;\n    uvD *= 1.15;\n    uvD.x *= iResolution.x / iResolution.y;\n    float display = RoundBox(uvD , vec2(0.57, 0.4) + 0.05, 0.02, 0.001);\n\n    float t = iTime * TIMESCALE * 2.0;\n    float togg = 4.0 - TOGGLE * 4.0;\n    float timer = 1.15 - pow(sin(t + cos(t) + cos(t * 1.3 + cos(t * 2.3))) + 1.001, 0.1 + togg); // glitches timer\n    float glitch =  sin(30.0 * t + uv.y * 150.0) * sin(1.7 * t + uv.y * uv.y * 54.0) * timer * 0.004;\n\n\n    vec4 col = vec4(0.0);\n    col = texture(iChannel2,vec2(glitch + uv.x,uv.y ));\n    col = max(col, blur(uv, col));\n\n    // aberration\n    col.r += 0.15 * texture(iChannel2, vec2(glitch + uv.x + 0.0019, uv.y + 0.0027)).x +0.0;\n    col.g += 0.25 * texture(iChannel2, vec2(glitch + uv.x + 0.0016, uv.y - 0.0033)).y +0.0;\n    col.b += 0.25 * texture(iChannel2, vec2(glitch + uv.x - 0.0031, uv.y + 0.0013)).z +0.1;\n\n    // glitches\n\tfloat scans = \n            + 0.5\n            + sin(3.5 * iTime * TIMESCALE + uv.y * iResolution.y * 1.6) * 0.03\n            + sin(iTime * TIMESCALE * 100.0 + uv.y * 12.0) * timer * 0.3;\n\tcol *= vec4(0.5 + pow(clmp(scans), 1.00) * display);\n\n    // HEXs pixels\n    uvD = AA(uvD, 1.0);\n\n    float mult = clmp(1.0 - 320.0 / iResolution.y); \n    float pixelzoom = (ZOOM + 1.0); \n    float pixelresolution = 32.0 + clamp(iResolution.x / 10.0, 0.0, 220.0); \n   \n    float hexs = length(calcHexInfo(uvD, pixelresolution).xy) - 0.25;\n\n    col = col - hexs * display * mult * pixelzoom * 0.4;  \n\n    fragColor = vec4(col);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// SOUND\n\n\nfloat Scan(float t) {\n    float a, b;\n    a += sin(TAU * t * 50.0);\n    a = smoothstep(0.95, 1.0, a * 1.0);\n    a *= exp(-99.0 * mod(t, 1.0));\n    return a * 1.0;       \n}\n\n// Stable Oscillator by ttg\nfloat intfract(int s, float n) {\n  // Implements fract(s/n)\n  // Explanation and copyright: shadertoy.com/view/4ltfRN\n  // Given sample number and period, calculate phase with high accuracy.\n  // Uses integer overflow for modulo.\n  int sn = int(n), a = s%sn, b = (s/sn);\n  const float MAXF = float(uint(-1))+1.;\n  return fract(  (float(a)/n) + float((uint(b)*uint(MAXF*float(sn)/n)))/MAXF );\n}\n\nfloat Biper(float ti, float t) {\n    float s; float iTime = t; // fake iTime\n    s += mix(sin(TAU * ti * 6.0) * 0.5, sin(TAU * ti * 4.0), ALIENWAVE);\n    s *= sin(t * 5.0) * sin(t * 9.0); \n    float fadetime = fract(t * 1.4 + ALIENWAVE);\n    s *= max(0.0, 0.5 - fadetime * fadetime);\n    s *= min(1.0, fadetime * 20.0);\n    s *= smoothstep(0.92, 0.91, ALIENWAVE);\n    return s * 0.5;\n} \n\nfloat Ambient(float t, float iter, float tone) {\n    float freq = 440.0; float s;\n    for (float i=0.0; i<iter; i++)\n    {\n        s += sin( TAU * t * freq * Hash(i) + TAU * Hash(i + 1.0));\n        freq += tone;\n    }\n    return s *= 1.0 / iter * 0.6;\n}\n\nfloat RustleNoise(float t, float iter) {\n    float s;\n    for (float i = 0.0; i < iter; i++)\n    {\n\t\ts += Hash(iSampleRate * (t + i)) * 2.0 - 1.0;\n    }\n    return s *= 1.0 / iter;\n}    \n\nfloat HeavyStep(float t) \n{\n    t = mod(t, 0.9 );\n\n    float s = sin(10.0 * exp(-t * 2.0));\n    s *= min(1.0, t * 500.0); \n    s *= max(0.0, 1.0 - t);\n    s *= exp(-t * 5.0);\n    s *= cos(500.0 * exp(-t));\n    return s;\n}\n\nfloat Hiss(float ti, float t, float iter) \n{\n    float s, j, a, b;\n    for (float i = 0.0; i < iter; i++)\n        {\n        a = clmp(sin(t*0.7 + i*0.2)); // period\n        b = 0.5 + sin(t * 2.0 * (60.0 - sin(t)) + i*0.2) * i * 0.5; // gurgle\n        \n        s += RustleNoise(ti - i, 1.0) * a * b;\n        s += RustleNoise(ti - i*0.2, 1.0) * a * clamp(b, 0.4, 0.5);\n        s *= exp(-0.5 * mod(a, 1.0 ));      \n    }\n    return s/iter * 0.01;\n}\n\nvec2 mainSound( int samp, float t )\n{\n    float ti = intfract(samp, iSampleRate/440.0);\n\n    float iTime = t; // fake iTime\n    float s, a, \n          t0, t1, t2, t3;\n    vec2  b;\n    \n    t0 = (1.0 - ALIENWAVE) * smoothstep(1.0, 0.9, 1.0 - ALIENWAVE);\n    t1 = smoothstep(0.1, 1.0, sin(t * 7.0) * 0.2 + sin(t * 5.0) * 0.3);\n    t2 = smoothstep(0.1, 1.0, sin(t * 8.0) * 0.2 + sin(t * 6.0) * 0.3);\n    t3 = smoothstep(0.0, 1.5, clmp(sin(t * 9.0)) * 0.1 + sin(t * 4.0) * 0.2) * clmp(sin(t * 5.0));\n\n    s += Scan(t*1.5 * TIMESCALE)*0.15;    \n    s += Biper(ti, t  * TIMESCALE)*0.07;\n    s += Ambient(mod(t, 31.0), 400.0, -1.0) * (1.2 - ALIENWAVE) * 0.6;\n    s += Ambient(mod(t*0.2, 11.0), 400.0, 1.0);\n    \n    a += RustleNoise((t + sin(t) * 0.5) * 0.002, 2.0) * 0.01 * t3;\n\n    s += HeavyStep(t) * t1 * t0;\n    s += HeavyStep(t*0.9) * t2 * t0;\n    \n    b += vec2(Hiss(ti, t*1.1, 2.0), Hiss(ti, t*1.2, 2.0));\n    b += vec2(Hiss(ti, t*1.0 + 5.0, 2.0), Hiss(ti, t*0.9 + 3.0, 2.0)) * 0.7;\n    b += vec2(Hiss(ti, t*0.8 + 9.0, 2.0), Hiss(ti, t*1.1 + 9.0, 2.0)) * 0.6;\n    b += vec2(Hiss(ti, t*0.6 + 4.0, 2.0), Hiss(ti, t*0.7 + 5.0, 2.0)) * 0.5;\n    b += vec2(Hiss(ti, t*0.7 + 7.0, 2.0), Hiss(ti, t*0.5 + 6.0, 2.0)) * 0.4;    \n    b *= smoothstep(0.004, 0.0, ALIENWAVE);\n    \n    vec2 sound = vec2(s + a) + b;\n    \n    return sound;\n}","name":"Sound","description":"","type":"sound"}]}