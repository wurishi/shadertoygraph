{"ver":"0.1","info":{"id":"7tyBz1","date":"1664036635","viewed":80,"name":"Implicit Surface GearWheel ","username":"gPlatl","description":"Fork of \"Implicit Surface Rendering\":\n\nReplacing implicitFunc 'Gyroid' with 'GearWheel'. \n\nUse mouse to rotate object.\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","math","rgb","rendering","implicit","surface","gearwheel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ImplicitSurfaceGearWheel.glsl \n//\n// Fork of \"Implicit Surface Rendering\" by yvtjp. https://shadertoy.com/view/XsdXzN\n// 2022-09-24 15:50:52\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    fragColor.w = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// BufferB\n\nconst float FarDistance = 16.;\nconst int NumSteps = 16;\t\t// Number of samples per pixel (per frame)\nconst float DerivStep = 0.01;\t// For shading\nconst bool disableProgressiveRefinement = false;\n\n#define sq(x) (x*x)\n#define R 3.\n#define gr 14.\n\nfloat GearRing(vec3 pos)   \n{\n  float a = R + 0.8*sin(gr*atan(pos.x, pos.y));\n  return 0.15*a -0.1*(sq(pos.x) + sq(pos.y)) - pow(2.*pos.z,44.); \n}\n\nfloat implicitFunc(vec3 pos)\n{\n  return GearRing(pos); \n//  return 0.1 - pow(dot(sin(pos * 3. + iTime * 0.3), vec3(1.)), 2.)\n//    - pow(max(0., length(pos) - 1.7), 2.) * 10.; // bound by a ball\n}\n\nfloat ditherPattern(vec2 coord)\n{\n  coord = fract(coord * 0.5);\n  return dot(coord, vec2(0.25, 0.5));\n}\n\nvec3 computeNormalAt(vec3 pos)\n{\n  vec3 v = vec3(\n   \timplicitFunc(pos - vec3(DerivStep, 0., 0.)),\n   \timplicitFunc(pos - vec3(0., DerivStep, 0.)),\n   \timplicitFunc(pos - vec3(0., 0., DerivStep)));\n  vec3 v2 = vec3(\n  \timplicitFunc(pos + vec3(DerivStep, 0., 0.)),\n  \timplicitFunc(pos + vec3(0., DerivStep, 0.)),\n  \timplicitFunc(pos + vec3(0., 0., DerivStep)));\n  return normalize(v - v2);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid shade(vec3 pos, out vec3 color)\n{\n  vec3 surfNormal = computeNormalAt(pos);\n    \n  float h = pos.x * 0.25;\n  vec3 albedo = hsv2rgb(vec3(h, 1., 1.));\n    \n  float dtLt = dot(surfNormal, normalize(vec3(0.5, 1., 1.)));\n  float dtSky = dot(surfNormal, vec3(0., 0., 1.));\n  float diff = max(0., dtLt) + (dtSky * 0.5 + 0.5) * 0.2;\n    \n  color.xyz = albedo * diff;\n  color.xyz = sqrt(color.xyz); // gamma correction\n}\n\nbool trace(inout vec4 fragColor, vec3 cameraPos, vec3 rayDir, float farDist, float dither)\n{\n  fragColor.w = FarDistance; // reset upper bound\n    \n  // Start sampling\n  float interval = farDist / float(NumSteps + 1);\n  float d = interval * dither;\n  vec3 rayPos = vec3(0.);\n  float fval = implicitFunc(cameraPos + rayDir * d);\n    \n  for (int i = 0; i < NumSteps; ++i) {\n    float lastD = d;\n    // vec3 lastRayPos = rayPos;\n    float lastfval = fval;\n        \n    d += interval;\n    if (i == NumSteps - 1) \n      d = farDist;   \n        \n    rayPos = cameraPos + rayDir * d;\n    fval = implicitFunc(rayPos);\n        \n    if (fval > 0.) \n    { // refine\n      for (int k = 0; k < 12; ++k) \n      {\n        float midD = mix(lastD, d, 0.5);\n        vec3 midRayPos = cameraPos + rayDir * midD;\n        float midfval = implicitFunc(midRayPos);\n        if (midfval > 0.) \n          d = midD;   \n        else lastD = midD;   \n        \n        rayPos = midRayPos;\n      }\n      fragColor.w = lastD;\n      shade(rayPos, fragColor.xyz);\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n    \n  vec4 lastValue = iFrame == 0 ? vec4(0.) : texture(iChannel0, uv);\n    \n  fragColor = vec4(lastValue.xyz * .9, 1.0);\n    \n  float yaw = iTime * 0.02;   // rotation speed\n  float pitch = 0.7;\n  if (iMouse.z > 0.) \n  { vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n   \tyaw = mousePos.x * 6.;\n    pitch = mousePos.y * -4.;\n  }\n  vec3 cameraPos = vec3(cos(yaw)*cos(pitch),sin(yaw)*cos(pitch),sin(pitch)) * 8.;\n  vec3 cameraDir = normalize(-cameraPos);\n  vec3 cameraUp = vec3(0., 0., 1.);\n  vec3 cameraU = normalize(cross(cameraUp, cameraDir));\n  vec3 cameraV = cross(cameraDir, cameraU);\n  vec2 cameraUV = (uv - 0.5) * 0.5 * vec2(16./9.,1.);\n  vec3 rayDir = cameraDir + cameraU * cameraUV.x + cameraV * cameraUV.y;\n    \n  float farDist = clamp(lastValue.w * 1.01, 0.01, FarDistance);\n    \n  float dither = ditherPattern(fragCoord);\n  dither = fract(dither + 10. * cos(10. * cos(iTime + dot(fragCoord, vec2(11.4, 51.4)))));\n    \n  if (disableProgressiveRefinement || !trace(fragColor, cameraPos, rayDir, farDist, dither)) \n  { // Fail; reset the upper bound\n    trace(fragColor, cameraPos, rayDir, FarDistance, dither);\n  }\n}","name":"Buffer B","description":"","type":"buffer"}]}