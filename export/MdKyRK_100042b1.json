{"ver":"0.1","info":{"id":"MdKyRK","date":"1522670988","viewed":551,"name":"Real mirror test","username":"Zgragselus","description":"'tis just a real mirror test","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","pathtracing","smallpt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SAMPLES 8\n#define MAXDEPTH 256\n#define RRDEPTH 1\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define GGX 3\n#define DIEL 4\n#define NUM_SPHERES 9\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed++)*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e;\n    vec3 albedo;\n    vec3 ks;\n\tint refl;\n    float smoothness;\n    float metallic;\n    float reflectance;\n    float diffuse;\n    float ior;\n};\n\nSphere lightSourceVolume = Sphere(20., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), vec3(0.), DIFF, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(.75, .25, .25), vec3(0.), DIFF, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.25, .25, .75), vec3(0.), DIFF, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.9), vec3(.9), SPEC, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(.9), vec3(.9), SPEC, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), vec3(0.), DIFF, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), vec3(0.), DIFF, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);\n\tspheres[6] = Sphere(5., vec3(50., 70.33, 81.6),\tvec3(24.), vec3(0.), vec3(0.), DIFF, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f);\n\tspheres[7] = Sphere(20., vec3(75., 30., 85.), \tvec3(0.), vec3(1.), vec3(1.), REFR, 0.1, 0.5f, 1.0f, 1.0f, 1.55f);\n\tspheres[8] = Sphere(15., vec3(25., 20., 85.), \tvec3(0.), vec3(1.), vec3(1.), SPEC, 0.875, 0.0f, 0.0f, 1.0f, 1.55f);\n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness, float F0)\n{\n    vec3 H = normalize(V + L);\n    \n    float dotLH = max(dot(L, H), 0.0);\n    float dotNH = max(dot(N, H), 0.0);\n    float dotNL = max(dot(N, L), 0.0);\n    float dotNV = max(dot(N, V), 0.0);\n\n    float alpha = roughness * roughness + 0.0001;\n    \n    // GGX normal distribution\n    float alphaSqr = alpha * alpha;\n    float denom = dotNH * dotNH * (alphaSqr - 1.0) + 1.0;\n    float D = alphaSqr / (denom * denom);\n    \n    // Fresnel term approximation\n    float F_a = 1.0;\n    float F_b = pow(1.0 - dotLH, 5.0);\n    float F = mix(F_b, F_a, F0);\n    \n    // GGX self shadowing term\n    float k = (alpha + 2.0 * roughness + 1.0) / 8.0;\n    float G = dotNL / (mix(dotNL, 1.0, k) * mix(dotNV, 1.0, k));\n    \n    // '* dotNV' - Is canceled due to normalization\n    // '/ dotLN' - Is canceled due to lambert\n    // '/ dotNV' - Is canceled due to G\n    return max(0.0, min(10.0, D * F * G / 4.0));\n}\n\nvec3 angleToDir(vec3 n, float theta, float phi)\n{\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    vec3 w = normalize(n);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n    return (u * cos(theta) + v * sin(theta)) * sinPhi + w * cosPhi;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id = intersect(r, t, obj, id)) < 0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n        \n        if (depth > RRDEPTH)\n        {\n            if (rand() > max(max(mask.x, mask.y), mask.z))\n            {\n                return acc;\n            }\n            else\n            {\n                mask = mask * (1.0 / max(max(mask.x, mask.y), mask.z));\n            }\n        }\n\n        // Standard Diffuse Material\n\t\tif (obj.refl == DIFF) \n        {\n\t\t\tfloat r2 = rand();\n\t\t\tvec3 d = jitter(nl, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = vec3(0.);\n\t\t\t{\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 6;\n\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n\n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\te += (s.e * clamp(dot(l, n),0.,1.) * omega) / PI;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloat E = 1.;\n\t\t\tacc += mask * obj.e * E + mask * obj.albedo * e;\n\t\t\tmask *= obj.albedo;\n\t\t\tr = Ray(x, d);\n\t\t}\n        // Ideal Mirror Material\n        else if (obj.refl == SPEC) \n        {\n\t\t\tacc += mask * obj.e;\n\t\t\tmask *= obj.albedo;\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t} \n        // Ideal Dielectric Material\n        else if (obj.refl == REFR) \n        {\n\t\t\tfloat a=dot(n,r.d), ddn=abs(a);\n            \n\t\t\tfloat nc=1., nt=spheres[id].ior, nnt=mix(nc/nt, nt/nc, float(a>0.));\n            \n\t\t\tfloat cos2t=1.-nnt*nnt*(1.-ddn*ddn);\n            \n\t\t\tr = Ray(x, reflect(r.d, n));\n            \n\t\t\tif (cos2t>0.) \n            {\n\t\t\t\tvec3 tdir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n                \n\t\t\t\tfloat R0=(nt-nc)*(nt-nc)/((nt+nc)*(nt+nc)),\n\t\t\t\t\tc = 1.-mix(ddn,dot(tdir, n),float(a>0.));\n                \n\t\t\t\tfloat Re=R0+(1.-R0)*c*c*c*c*c,P=.25+.5*Re,RP=Re/P,TP=(1.-Re)/(1.-P);\n                \n\t\t\t\tif (rand()<P) \n                { \n                    mask *= RP; \n                }\n\t\t\t\telse \n                { \n                    mask *= obj.albedo*TP; \n                    r = Ray(x, tdir); \n            \t}\n\t\t\t}\n        } \n        // GGX PBR Material\n        else if (obj.refl == GGX) \n        {   \n\t\t\tfloat E = 1.;\n            float roughness = 1.0 - spheres[id].smoothness * spheres[id].smoothness;\n            float alpha = roughness * roughness;\n            float metallic = spheres[id].metallic;\n            float reflectance = spheres[id].reflectance;\n            float diffuse = spheres[id].diffuse;\n            float specular = 1.0 - diffuse;\n            vec3 color = spheres[id].albedo * diffuse + spheres[id].ks * specular;\n            \n            vec3 brdf = vec3(0.0);\n            \n            if (rand() < reflectance)\n\t\t\t{\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 6;\n\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n                \n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\tbrdf += (s.e * clamp(ggx(nl, r.d, l, roughness, metallic),0.,1.) * omega) / PI;\n\t\t\t\t}\n                             \n                float xsi_1 = rand();\n                float xsi_2 = rand();\n                float phi = atan((alpha * sqrt(xsi_1)) / sqrt(1.0 - xsi_1));\n                float theta = 2.0 * PI * xsi_2;\n                vec3 direction = angleToDir(nl, theta, phi);\n                r = Ray(x, direction);\n                acc += mask * obj.e * E + mask * color * brdf;\n                mask *= color;\n\t\t\t}\n            else\n            {\n                float r2 = rand();\n                vec3 d = jitter(nl, 2.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n                vec3 e = vec3(0.);\n                {\n                    Sphere s = lightSourceVolume;\n                    int i = 6;\n\n                    vec3 l0 = s.p - x;\n                    float cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n                    float cosa = mix(cos_a_max, 1., rand());\n                    vec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n\n                    if (intersect(Ray(x, l), t, s, id) == i) {\n                        float omega = 2. * PI * (1. - cos_a_max);\n                        e += (s.e * clamp(dot(l, n),0.,1.) * omega) / PI;\n                    }\n                }\n                float E = 1.;\n                acc += mask * obj.e * E + mask * color * e;\n                mask *= color;\n                r = Ray(x, d);\n            }\n        }\n        else\n        {   \n\t\t\tfloat E = 1.;\n            float roughness = 1.0 - spheres[id].smoothness * spheres[id].smoothness;\n            float alpha = roughness * roughness;\n            float metallic = spheres[id].metallic;\n            float reflectance = spheres[id].reflectance;\n            float diffuse = spheres[id].diffuse;\n            float specular = 1.0 - diffuse;\n            vec3 color = spheres[id].albedo * diffuse + spheres[id].ks * specular;\n            \n            vec3 brdf = vec3(0.0);\n            \n            if (rand() < reflectance)\n\t\t\t{                \n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 6;\n\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n                \n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\tbrdf += (s.e * clamp(ggx(nl, r.d, l, roughness, metallic),0.,1.) * omega) / PI;\n\t\t\t\t}\n                             \n                float xsi_1 = rand();\n                float xsi_2 = rand();\n                float phi = atan((alpha * sqrt(xsi_1)) / sqrt(1.0 - xsi_1));\n                float theta = 2.0 * PI * xsi_2;\n                vec3 direction = angleToDir(nl, theta, phi);\n                r = Ray(x, direction);\n                acc += mask * obj.e * E + mask * color * brdf;\n                mask *= color;\n\t\t\t}\n            else\n            {\n                \n                float a = dot(n,r.d);\n                float ddn = abs(a);\n\n                float nc = 1.0;\n                float nt = spheres[id].ior;\n                float nnt = mix(nc/nt, nt/nc, float(a>0.));\n\n                float cos2t = 1.0 - nnt * nnt * (1.0 - ddn * ddn);\n\n                vec3 reflDir = reflect(r.d, n);\n                float xsi_1 = rand();\n                float xsi_2 = rand();\n                float phi = atan((alpha * sqrt(xsi_1)) / sqrt(1.0 - xsi_1));\n                float theta = 2.0 * PI * xsi_2;\n                vec3 direction = angleToDir(reflDir, theta, phi);\n                \n                r = Ray(x, direction);\n\n                if (cos2t > 0.0) \n                {\n                    vec3 refrDir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n                    vec3 tdir = angleToDir(refrDir, theta, phi);;\n\n                    float R0=(nt-nc)*(nt-nc)/((nt+nc)*(nt+nc)),\n                        c = 1.0-mix(ddn,dot(tdir, n),float(a>0.));\n\n                    float fresnel = R0 + (1.0 - R0) * c * c * c * c * c;\n                    float P = 0.25 + 0.5 * fresnel;\n                    float RP = fresnel / P;\n                    float TP = (1.0 - fresnel) / (1.0 - P);\n\n                    if (rand()<P) \n                    { \n                        mask *= RP; \n                    }\n                    else \n                    { \n                        mask *= obj.albedo*TP; \n                        r = Ray(x, tdir); \n                    }\n                }\n                else\n                {                \n                    Sphere s = lightSourceVolume;\n                    int i = 6;\n\n                    vec3 l0 = s.p - x;\n                    float cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n                    float cosa = mix(cos_a_max, 1., rand());\n                    vec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n\n                    if (intersect(Ray(x, l), t, s, id) == i) {\n                        float omega = 2. * PI * (1. - cos_a_max);\n                        brdf += (s.e * clamp(ggx(nl, r.d, l, roughness, metallic),0.,1.) * omega) / PI;\n                    }\n\n                    acc += mask * obj.e * E + mask * color * brdf;\n                    mask *= color;\n                }\n            }\n        }\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n    vec2 fragCoordRand = fragCoord + vec2(mod(iTime * 23.75310853, 1.), mod(iTime * 21.95340893, 1.));\n\tseed = iTime + iResolution.y * fragCoordRand.x / iResolution.x + fragCoordRand.y / iResolution.y;\n\tvec2 uv = 2. * fragCoordRand.xy / iResolution.xy - 1.;\n\tvec3 camPos = vec3((2. * (iMouse.xy==vec2(0.)?.5*iResolution.xy:iMouse.xy) / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\tvec3 color = vec3(0.);\n\tfor (int i = 0; i < SAMPLES; ++i)\n    {\n\t\tcolor += 32.0 / float(SAMPLES) * radiance(Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz)));\n    }\n\tfragColor = vec4(pow(clamp(color/float(SAMPLES), 0., 1.), vec3(1./2.2)), 1.);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel1, uv) * (1. - 1./float(iFrame + 1)) + texture(iChannel0, uv) * 1./float(iFrame + 1);\n}","name":"Buf B","description":"","type":"buffer"}]}