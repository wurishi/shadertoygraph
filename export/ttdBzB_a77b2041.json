{"ver":"0.1","info":{"id":"ttdBzB","date":"1613005766","viewed":325,"name":"Anti-Aliased 2D Metaballs","username":"igneus","description":"2D metaballs using a variation on the classic point charge equation. The derivative of this function is better behaved meaning fewer iterations to find the root as well as cheap 1-sample anti-aliasing. ","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["blobs","metaballs","fluid","liquid","mercury","isosurfaces","levelset"],"hasliked":0,"parentid":"WldBW7","parentname":"Pan Tone Scratchpad"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kApplyVignette            true            // Apply vignette as a post-process\n\n#define kVignetteStrength         0.7             // The strength of the vignette effect\n#define kVignetteScale            0.7             // The scale of the vignette effect\n#define kVignetteExponent         4.0             // The rate of attenuation of the vignette effect\n\n#define kNumMetaballs             50\n#define kMetaRadius               0.1\n#define kMetaSpeed                0.001\n#define kMetaSpread               0.35\n#define kMetaCharge               0.05\n#define kMetaThreshold            8.0\n#define kMetaAA                   3.0\n#define kMetaColourPhase          0.0003\n#define kMaxTests                 20\n#define kEpsilon                  1e-2\n#define kDeltaT                   0.5\n\n#define kPi                    3.14159265359\n#define kTwoPi                 (2.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRoot2                 1.41421356237\n#define kFltMax                3.402823466e+38\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.0)\n#define kZero                  vec3(0.0)\n#define kPink                  vec3(1.0, 0.0, 0.2)\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nint sqr(int a)                 { return a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat length2(vec2 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\nvec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\nvec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\n\nivec2 kFragCoord;\nuvec4 rngSeed; \n\n// Maps the input xy texel coordinates to UV [0.0, 1.0] and distance R from center\nvec2 xyToUv(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = vec2(xy.x / iResolution.x, xy.y / iResolution.y);\n    uv.x = (uv.x - 0.5) * (iResolution.x / iResolution.y) + 0.5;     \n    return uv;\n}\n\n// Maps the input xy texel coordinates to UV [-1.0, 1.0] and distance R from center\nvec3 xyToUvr(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = xyToUv(xy, iResolution);    \n    float x = 2.0 * (uv.x - 0.5);\n    float y = 2.0 * (uv.y - 0.5);\n    \n    return vec3(uv, sqrt(x*x + y*y) / kRoot2);\n}\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\nuvec4 pcgAdvance()\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Seed the PCG hash function with the current frame multipled by a prime\nvoid pcgInitialise(int frame)\n{    \n    rngSeed = uvec4(20219u, 7243u, 12547u, 28573u) * uint(frame);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 rand()\n{\n    return vec4(pcgAdvance()) / float(0xffffffffu);\n}\n\n// Generates a hue\nvec3 hue(float phi, float saturation, float brightness)\n{\n    float phiColour = 6.0 * phi / kTwoPi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    vec3 rgb = mix(c0, c1, phiColour - float(i));\n    \n    return mix(vec3(mean(rgb)), rgb, saturation) * brightness;\n}\n\nvoid field(in vec2 xy, in float iFrame, vec3 iResolution, out float F, out vec2 delF, out vec3 colour)\n{      \n    pcgInitialise(0);\n    \n    F = 0.0;\n    delF = vec2(0.0);\n    float denom = 0.0;\n    float sumWeights = 0.0;\n    colour = kZero;\n    \n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n     \n    for(int i = 0; i < kNumMetaballs; i++)\n    {\n        vec4 xi1 = rand();        \n        vec4 xi2 = rand();\n        float r = kMetaRadius * mix(0.1, 1.0, xi1.x);\n        float c = kMetaCharge * mix(0.03, 1.0, pow(xi1.y, 4.0));\n        float d = kMetaSpread * mix(0.7, 1.0, sqrt(xi1.z));                   \n                     \n        vec2 p = vec2(cos((kMetaSpeed * mix(0.5, 1.0, xi2.x) * iFrame + xi2.y) * 1.0 * kTwoPi),\n                      sin((kMetaSpeed * mix(0.5, 1.0, xi2.x) * iFrame + xi2.y) * 2.0 * kTwoPi)) * aspectRatio * d;\n        \n        F += c / length2(xy - p);\n        \n        float n = sqr(xy.x - p.x) + sqr(xy.y - p.y);\n        delF.x += -c * 2.0 * (xy.x - p.x) / sqr(n);\n        delF.y += -c * 2.0 * (xy.y - p.y) / sqr(n);\n        \n        denom += c / n;\n        \n        float weight = pow(min(1e5, 1.0 / length2(xy - p)), 2.0);\n        \n        if(weight > 1e-2)\n        {        \n            //vec3 h = (xi2.z < 0.5) ? hue(kTwoPi * (iFrame * kMetaColourPhase + xi2.w * 0.1), 1.3, 1.0) : \n            //                         hue(kTwoPi * (iFrame * kMetaColourPhase + 0.5 + xi2.w * 0.1), 1.3, 1.0);  \n            vec3 h = hue(iFrame * kMetaColourPhase + kTwoPi * float(i) / float(kNumMetaballs), 1.3, 1.0);\n        \n            colour += h * weight;\n        \n            sumWeights += weight;\n        }\n    }\n    \n    colour /= sumWeights;    \n    F = 1.0 / sqrt(F) - 1.0 / sqrt(kMetaThreshold);   \n    delF = -0.5 * delF / pow(denom, 1.5);\n}\n\nvec3 renderMetaballs(vec2 fragCoord, vec3 iResolution, float iTime, samplerCube sampler)\n{                \n    vec2 xy = vec2((fragCoord.x - 0.5 * iResolution.x) / iResolution.y, \n                   (fragCoord.y - 0.5 * iResolution.y) / iResolution.y);\n\n    float F;\n    vec2 delF;\n    vec3 colour;\n    field(xy, iTime * 60.0, iResolution, F, delF, colour);           \n    \n    float mode = sin(iTime * 0.2 + kHalfPi);\n    float r = (abs(mode) - 0.8) / 0.05;\n    float d = length(xy);\n    float FMax = (kMetaAA / iResolution.x) * length(delF);\n    \n    if(r > d)\n    {\n        if(mode > 0.8)\n        {    \n            return vec3(normalize(delF) * 0.5 + vec2(0.5), 0.5);\n        }\n        else if(mode < -0.8)\n        {\n            colour = kOne * float(mod(F * 15.0, 1.0) < 0.1);\n        }\n    }\n\n    float delFLength = length(delF);\n    vec2 delFNorm = delF / ((delFLength > 1.0) ? delFLength : 1.0);\n            \n    delFNorm = delFNorm * 0.5 + vec2(0.5);   \n    \n    vec4 metaball = vec4(0.0);\n    if(F < FMax)\n    {\n        float alpha = min(1.0, (FMax - F) / FMax);\n        float z = pow(min(1.0, -F * 2.5), 0.5);\n        vec3 normal = normalize(vec3(delFNorm * (1.0 - z), z));                \n                \n        float L = (r > d && mode < -0.8) ? 0.0 : pow(luminance(texture(sampler, normal.xyz, 0.0).xyz), 2.0);\n        metaball = vec4(mix(colour, kOne, L), alpha); \n    }   \n \n    vec2 grid = mod((xy + vec2(100.0)) * 20.0, 1.0);\n    return mix(mix(vec3(0.1), vec3(0.05), float(grid.x < 0.05 || grid.y < 0.05)), metaball.xyz, metaball.w);\n}\n\nfloat vignette(in vec2 fragCoord)\n{\n    vec3 uvr = xyToUvr(fragCoord, iResolution);\t\t\t\t\n    return mix(1.0, max(0.0, 1.0 - pow(uvr.z * kVignetteScale, kVignetteExponent)), kVignetteStrength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 rgb = renderMetaballs(fragCoord, iResolution, iTime, iChannel0);\n    \n    rgb = clamp(rgb, vec3(0.0), vec3(1.0));\n    \n    if(kApplyVignette) { rgb *= vignette(fragCoord); }\n    \n    fragColor.xyz = rgb;\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"}]}