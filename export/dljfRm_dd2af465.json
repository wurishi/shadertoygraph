{"ver":"0.1","info":{"id":"dljfRm","date":"1693908490","viewed":76,"name":"Light twist in sugar experiment","username":"smarchevsky","description":"I tried to simulate polarized light twist in sugar solution.\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["spectrum","filter","light","dispersion","sugar","polarized"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I tried to simulate polarized light twist in sugar solution.\n\n// Steve Mould video:\n// https://www.youtube.com/watch?v=975r9a7FMqc\n\n// 3Blue1Brown videos:\n// https://www.youtube.com/watch?v=QCX62YJCmGk\n// https://www.youtube.com/watch?v=aXRTczANuIs\n\n// The result is what color will we see at distance along X\n// with both input and output filters polarized in same direction\n\n// Added dithering to ensure, there are no repeating patterns after several waves\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    const int num = 30; // spectrum sampling\n    const float div = 1. / float(num);\n\n    vec3 col = vec3(0);\n    \n    for(int i = 0; i < num; ++i)\n    {\n        float distribution = (float(i) \n         + hash13(uvec3(fragCoord.xy, i)) // without dithering wave pattern repeats after attenuation, that's wrong\n        ) * div; // sampling from 0 to 1\n        \n        float waveLength = mix(720., 380., distribution); // sampling red to violet\n\n        float waveFreq = 3e8f / waveLength;\n\n        float twist = uv.x * waveFreq * 2e-5; // light twists along X, and twists harder with wave freq increase\n\n        float twistCos = cos(twist); twistCos *= twistCos;\n\n        //if (abs(distribution - 0.7) < 0.1) // select wavelength range.\n        col += spectrum(waveLength) * twistCos;\n\n    }\n    col *= div;\n    \n    col *= vec3(1, 1.1, 1.6); // warm color compensation of spectrum function\n    \n    col = pow(col * 2., vec3(0.6)); // bright, gamma\n    fragColor = vec4(col ,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// SPECTRUM\n\n// https://www.shadertoy.com/view/wlSBzD\nvec3 spectrum(float x) {\n    x = (x - 380.) / (720. - 380.); // visible wavelength maps to 0...1\n    x = clamp(x, 0., 1.);\n    return (vec3( 1.220023e0,-1.933277e0, 1.623776e0)\n          +(vec3(-2.965000e1, 6.806567e1,-3.606269e1)\n          +(vec3( 5.451365e2,-7.921759e2, 6.966892e2)\n          +(vec3(-4.121053e3, 4.432167e3,-4.463157e3)\n          +(vec3( 1.501655e4,-1.264621e4, 1.375260e4)\n          +(vec3(-2.904744e4, 1.969591e4,-2.330431e4)\n          +(vec3( 3.068214e4,-1.698411e4, 2.229810e4)\n          +(vec3(-1.675434e4, 7.594470e3,-1.131826e4)\n          + vec3( 3.707437e3,-1.366175e3, 2.372779e3)\n            *x)*x)*x)*x)*x)*x)*x)*x)*x;\n}\n\n\n\n// DITHERING\n\n// https://www.shadertoy.com/view/XdGfRR\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n","name":"Common","description":"","type":"common"}]}