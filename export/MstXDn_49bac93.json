{"ver":"0.1","info":{"id":"MstXDn","date":"1459179184","viewed":347,"name":"Rush Hour - Boat Version","username":"rherraezj","description":"-Raquel Herraez\n-Juan Guerrero\n Letters are from Flyguy's Bit Packed Sprite: https://www.shadertoy.com/view/XtsGRl\n\nHelp red boat to reach the other end. Boats can only move forward and backward\nControls:\nRed: Q/W\nYellow: A/S\nBlue: E/D\nGreen: R/F","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["noise","game","water","worley","map","cells","pgatr","multipass","rush","migjrv","hour","boats"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float size = 6.0; //Number of squares for each dimension\n\nfloat redLength = 2.0;\n\n//Initial positions\nvec2 posRed = vec2(1.0*(1.0/size), 3.5*(1.0/size));\nvec2 posBlue = vec2(0.5*(1.0/size), 1.5*(1.0/size));\nvec2 posGreen = vec2(3.5*(1.0/size), 4.5*(1.0/size));\nvec2 posYellow = vec2(2.5*(1.0/size), 2.5*(1.0/size));\n\n//Color definition\nvec3 red = vec3 (1.0, 0.0, 0.0);\nvec3 blue = vec3 (0.0, 0.0, 1.0);\nvec3 green = vec3 (0.0, 1.0, 0.0); \nvec3 yellow = vec3 (1.0, 1.0, 0.0);\n\n//Draws a boat as addition of rectangles\nvec4 drawBoat(vec3 color, vec2 pos, vec2 uv, float width, float height){\n\n    vec4 boat = vec4(0.0, 0.0, 0.0, 0.0);\n    if(uv.x < pos.x + width*1.0/(4.0*size) && uv.y < pos.y + height*1.0/(2.0*size) && uv.x > pos.x - width*1.0/(4.0*size) && uv.y > pos.y - height*1.0/(2.0*size)) {\n        boat = vec4(color*0.5, 1.0);\n            \n    }\n\t\n    if(uv.x < pos.x + width*1.0/(2.0*size) && uv.y < pos.y + height*1.0/(4.0*size) && uv.x > pos.x - width*1.0/(2.0*size) && uv.y > pos.y - height*1.0/(4.0*size)) {\n        boat = vec4(color*0.5, 1.0);      \n    }\n    \n    if(uv.x < pos.x + width*1.0/(3.0*size) && uv.y < pos.y + height*1.0/(3.0*size) && uv.x > pos.x - width*1.0/(3.0*size) && uv.y > pos.y - height*1.0/(3.0*size)) {\n        boat = vec4(color*0.5, 1.0);    \n    }\n    \n    if(uv.x < pos.x + width*1.0/(4.0*size) && uv.y < pos.y + height*1.0/(4.0*size) && uv.x > pos.x - width*1.0/(4.0*size) && uv.y > pos.y - height*1.0/(4.0*size)) {\n        boat = vec4(color, 1.0);      \n    }\n    return boat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    vec4 buffer = texture(iChannel1, uv);\n    \n    //Updates values when keys are pressed\n    posRed.x = buffer.x;\n    posBlue.y = buffer.y;\n    posGreen.y = buffer.z;\n    posYellow.x = buffer.w;\n    \n    if(posRed.x+(redLength/2.0)*(1.0/size)>=1.0){ //If Victory, red boat in final position\n        fragColor = texture(iChannel3, uv);\n        fragColor += texture(iChannel2, uv);\n    }else{\n        fragColor += drawBoat(red, posRed, uv, 2.0, 1.0);  \n\t    fragColor += drawBoat(blue, posBlue, uv, 1.0, 3.0);  \n    \tfragColor += drawBoat(green, posGreen, uv, 1.0, 3.0);   \n    \tfragColor += drawBoat(yellow, posYellow, uv, 3.0, 1.0);\n        if(distance(fragColor,vec4(0.0,0.0,0.0,1.0))==0.0) fragColor = texture(iChannel2, uv);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Game Data. This saves the pieces' positions and applies the displacements when the keys are pressed.\n\nconst float size = 6.0; //board's size (in number of squares per dimension)\n\nconst float RED_LEFT  = 81.5/256.0; //Q\nconst float RED_RIGHT = 87.5/256.0; //W\nconst float YELLOW_LEFT = 65.5/256.0; //A\nconst float YELLOW_RIGHT = 83.5/256.0; //S\nconst float GREEN_UP  = 82.5/256.0; //R\nconst float GREEN_DOWN  = 70.5/256.0; //F\nconst float BLUE_UP  = 69.5/256.0; //E\nconst float BLUE_DOWN  = 68.5/256.0; //D\n\n//If the key asociated to the movement is pressed\nbool isRedLeft = false;\nbool isRedRight = false;\nbool isYellowLeft = false;\nbool isYellowRight = false;\nbool isGreenUp = false;\nbool isGreenDown = false;\nbool isBlueUp = false;\nbool isBlueDown = false;\n\n//Length of the boats\nfloat redLength = 2.0;\nfloat blueLength = 3.0;\nfloat greenLength = 3.0;\nfloat yellowLength = 3.0;\n\n//Initial positions for the center of the piece\nvec2 posRed = vec2(1.0*(1.0/size), 3.5*(1.0/size));\nvec2 posBlue = vec2(0.5*(1.0/size), 1.5*(1.0/size));\nvec2 posGreen = vec2(3.5*(1.0/size), 4.5*(1.0/size));\nvec2 posYellow = vec2(2.5*(1.0/size), 2.5*(1.0/size));\n\n//Color definition\nvec3 red = vec3 (1.0, 0.0, 0.0);\nvec3 blue = vec3 (0.0, 0.0, 1.0);\nvec3 green = vec3 (0.0, 1.0, 0.0); \nvec3 yellow = vec3 (1.0, 1.0, 0.0);\n\nvoid checkKeys(){\n\tisRedLeft = texture(iChannel0,vec2(RED_LEFT,0.5)).r >0.5;\n    isRedRight = texture(iChannel0,vec2(RED_RIGHT,0.5)).r >0.5;\n    isYellowLeft = texture(iChannel0,vec2(YELLOW_LEFT,0.5)).r >0.5;\n    isYellowRight = texture(iChannel0,vec2(YELLOW_RIGHT,0.5)).r >0.5;\n    isGreenUp = texture(iChannel0,vec2(GREEN_UP,0.5)).r >0.5;\n    isGreenDown = texture(iChannel0,vec2(GREEN_DOWN,0.5)).r >0.5;\n    isBlueUp = texture(iChannel0,vec2(BLUE_UP,0.5)).r >0.5;\n    isBlueDown = texture(iChannel0,vec2(BLUE_DOWN,0.5)).r >0.5;    \n}\n\n//Checks that the side that goes with the movement does not enter other piece\nbool isFree (vec3 color, vec2 pos){\n\n    bool free = true;\n    vec3 cmpColor;\n    vec2 cmpPos;\n    float height = 0.0;\n    float width = 0.0;\n    \n\tcmpPos = posRed;\n    height = 1.0;\n    width = redLength;\n    \n    if(pos.x <= cmpPos.x + (width/2.0)*(1.0/size) && pos.y <= cmpPos.y + (height/2.0)*(1.0/size) && pos.x > cmpPos.x - (width/2.0)*(1.0/size) && pos.y > cmpPos.y - (height/2.0)*(1.0/size)) {\n     \n        free = false;\n        cmpColor = red;\n    }\n    \n    cmpPos = posGreen;\n    height = 3.0;\n    width = greenLength;\n\n    if(pos.x < cmpPos.x + (width/2.0)*(1.0/size) && pos.y < cmpPos.y + (height/2.0)*(1.0/size) && pos.x > cmpPos.x - (width/2.0)*(1.0/size) && pos.y > cmpPos.y - (height/2.0)*(1.0/size)) {        \n        free = false;\n        cmpColor = green;\n    }\n    \n    cmpPos = posBlue;\n    height = 3.0;\n    width = blueLength;\n\n    if(pos.x < cmpPos.x + (width/2.0)*(1.0/size) && pos.y < cmpPos.y + (height/2.0)*(1.0/size) && pos.x > cmpPos.x - (width/2.0)*(1.0/size) && pos.y > cmpPos.y - (height/2.0)*(1.0/size)) {     \n        free = false;\n        cmpColor = blue;\n    }\n    \n    cmpPos = posYellow;\n    height = 1.0;\n    width = yellowLength;\n\n    if(pos.x < cmpPos.x + (width/2.0)*(1.0/size) && pos.y < cmpPos.y + (height/2.0)*(1.0/size) && pos.x > cmpPos.x - (width/2.0)*(1.0/size) && pos.y > cmpPos.y - (height/2.0)*(1.0/size)) {     \n        free = false;\n        cmpColor = yellow;\n    }\n    \n    free = free || cmpColor == color; //I the place is empty or is filled with another part of the same boat\n    \n    return free;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel1, uv);\n    if(iFrame == 0){\n        tex = vec4(1.0*(1.0/size),1.5*(1.0/size),4.5*(1.0/size),2.5*(1.0/size)); //Se almacena la coordenada cambiante de cada pieza\n    }\n    \n    posRed.x = tex.x;\n    posBlue.y = tex.y;\n    posGreen.y = tex.z;\n    posYellow.x = tex.w;\n    \n\tcheckKeys();\n    \n    //If the key is pressed, checks that the movement is not out of the bounds or the new position is filled for other boat\n    if(isRedLeft){\n        if(posRed.x-(redLength/2.0)*(1.0/size)>0.0 && isFree(red,posRed-vec2((redLength/size)-0.3,0.0)))posRed.x-=1.0/size;\n    }else if(isRedRight){\n        if(posRed.x+(redLength/2.0)*(1.0/size)<1.0 && isFree(red,posRed+vec2((redLength/size)-0.3,0.0)))posRed.x+=1.0/size;\n    }else if(isYellowLeft){\n        if(posYellow.x-(yellowLength/2.0)*(1.0/size)>0.0 && isFree(yellow,posYellow-vec2((-0.5+yellowLength-1.0)/size,0.0)))posYellow.x-=1.0/size;\n    }else if(isYellowRight){\n        if(posYellow.x+(yellowLength/2.0)*(1.0/size)<1.0 && isFree(yellow,posYellow+vec2((yellowLength-1.0)/size,0.0)))posYellow.x+=1.0/size;\n    }else if(isGreenUp){\n        if(posGreen.y+(greenLength/2.0)*(1.0/size)<1.0 && isFree(green,posGreen+vec2(0.0,(greenLength-1.0)/size)))posGreen.y+=1.0/size;\n    }else if(isGreenDown){\n        if(posGreen.y-(greenLength/2.0)*(1.0/size)>0.0 && isFree(green,posGreen-vec2(0.0,(greenLength-1.0)/size)))posGreen.y-=1.0/size;\n    }else if(isBlueUp){\n        if(posBlue.y+(blueLength/2.0)*(1.0/size)<1.0 && isFree(blue,posBlue+vec2(0.0,(blueLength-1.0)/size)))posBlue.y+=1.0/size;\n    }else if(isBlueDown){\n        if(posBlue.y-(blueLength/2.0)*(1.0/size)>0.0 && isFree(blue,posBlue-vec2(0.0,(blueLength-1.0)/size)))posBlue.y-=1.0/size;\n    }\n\n    \n    fragColor = vec4(posRed.x, posBlue.y, posGreen.y, posYellow.x);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This is the Worley Noise in blue hues\n\nvec2 Hash2(vec2 p)\n{\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r+0.015*p.y*iTime), fract(17.25865 * r+0.015*p.x*sin(iTime)));\n}\n\nconst int size = 2;\nconst int numCells = 10;\n\nvec2 worley(vec2 p){\n    vec4 fila1;\n    vec4 fila2;\n    vec4 fila3;\n    vec4 fila4;\n    \n    vec4 en_uso;\n    \n    vec2 mas_cercano;\n    float distancia = 14321.0;\n\n    vec2 ppp;\n    for(int i = 0; i<numCells; i++){\n        for(int j = 0; j<numCells; j++){\n            ppp = Hash2(vec2(float(i),float(j)));\n            \n            if(distance(ppp,p)<distancia){\n                mas_cercano = ppp;\n                distancia = distance(mas_cercano, p);\n            }\n        }\n        \n    }\n    return mas_cercano;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 valor = worley(uv);\n    //vec2 distancia = vec2(0.0,0.0)+abs(valor-uv)*float(size);  //less curvy, Manhattan distance\n    vec2 distancia = vec2(0.0,0.0)+distance(valor,uv)*float(size);  //more curvy, Euclidean distance\n\tfragColor = vec4(0.0, 0.5+distancia.x/4.0+distancia.y/4.0, 1.0, 1.0); //Escale of blues\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//From Flyguy's shader \"Bit Packed Sprites\": https://www.shadertoy.com/view/XtsGRl\n\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆ     010    \nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \nâ–ˆâ–ˆâ–ˆ -> 111 -> 010 101 101 111 101 101 101 -> 712557\nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \n*/\n\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\n#define res (iResolution.xy / 4.0)\nvec2 print_pos = vec2(2,2);\n\n//Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(float ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n//Returns the digit sprite for the given number.\nfloat get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return 0.0;\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= 0;i--)\n    {\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0); //Clip off leading zeros.\n        \n        float digit = mod(number / pow(10.0, float(i)),10.0);\n        \n        result += sprite(get_digit(digit),CHAR_SIZE, uv - dec_pos) * clip;\n        \n        dec_pos.x += CHAR_SPACING.x * clip;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / 4.0;\n    uv =  floor(uv);\n    \n    float col = 0.0;\n    \n    print_pos = vec2(res.x/2.0 - STRWIDTH(8.0)/2.0,res.y/2.0 - STRHEIGHT(1.0)/2.0);\n    print_pos = floor(print_pos);\n       \n    col += char(ch_y,uv);\n    col += char(ch_o,uv);\n    col += char(ch_u,uv);\n    \n    col += char(ch_sp,uv);\n    \n    col += char(ch_w,uv);\n    col += char(ch_i,uv);\n    col += char(ch_n,uv);\n    col += char(ch_exc,uv);\n    \n    /*\n    print_pos = vec2(2);\n    \n    col += char(ch_m,uv);\n    col += char(ch_o,uv);\n    col += char(ch_v,uv);\n    col += char(ch_e,uv);\n    col += char(ch_s,uv);\n    col += char(ch_col,uv);\n\t*/\n    \n    //col += print_number(iTime,print_pos,uv);\n    \n\tfragColor = vec4(vec3(col), 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}