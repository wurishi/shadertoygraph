{"ver":"0.1","info":{"id":"7lBSWV","date":"1630858595","viewed":334,"name":"Ray marched SDFs","username":"LiquidSentience","description":"My first shadertoy. This can raymarch any arbitrary shape, and reflect/raytrace light as long as it can be defined by a SDF\nAlso I added waves! ðŸŒŠI love waves","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["waves","raymarch","sdf","raytrace","distance","function","signed","propagation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHOW_NORMALS false\n#define MAX_BOUNCES 8\n#define MAX_SAMPLES 2\n\n#define REFRACTIVE_INDEX_AIR 1.0003\n#define REFRACTIVE_INDEX_GLASS  1.125\n#define REFRACTIVE_INDEX_WATER 1.333\n#define REFRACTIVE_INDEX_FLINT_GLASS 1.655\n#define REFRACTIVE_NONE -1.\n\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n#define EULER 2.7182818284590452353602874\n\n#define WAVE_SPEED 9.02\n#define WAVE_LENGTH .5\n#define WAVE_AMPLITUDE_FACTOR .5\n#define WAVE_PROP_TIME_FILTER 50.\n#define BOUNCE_RADIUS 45.\n\nconst int   MAX_RAYMARCH_STEPS = 350;\nconst float MIN_DIST = 0.01; \nconst float MAX_DIST = 800.0;\nconst float EPSILON  = 0.0001;\n\nconst vec3 light_blue  = vec3(0.27,0.73,.86) * .3;\nconst vec3 near_black  = vec3(0.00);\nconst vec3 navy_blue   = vec3(75, 78, 109) / 256. * .3;\nconst vec3 yellow      = vec3(235, 252, 27) / 256. * .3; \nconst vec3 shaded_blue = vec3(78, 107, 167) / 256. * .3;\n\n\n#define TOTAL_OBJECTS 5\n\n#define SKY -1\n#define CENTER_ORB 0\n#define BOUNCE_ORB 1\n#define FLOOR 2\n#define WALL 3\n#define WATER 4\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\nfloat distances[TOTAL_OBJECTS]; \n\nstruct Material\n{\n    float roughness; \n    vec3  albedo;\n    float absorbption; \n    int material_type; \n    float refract_idx; \n    \n};\n\nMaterial objectMaterials[TOTAL_OBJECTS];\nMaterial skyMaterial;\n\n\nint exitingThisObject = SKY; \nint enteringThisObject; \n\nvec4 mouseNorm;\n\nstruct hitData \n{\n    int inside; \n    Material hit_material; \n};\n\nstruct RayTraceOutput\n{\n    vec3 hit_color;\n    vec3 rayDir; \n};\n\nhitData hit_data;\nMaterial hit_material;\n   \n   \nMaterial getMaterial(int ID)\n{\n    if(ID == SKY)\n    {\n        return skyMaterial; \n    }\n    else\n    {\n        return objectMaterials[ID];\n    }\n}\n\nfloat getBounceHeight(float time)\n{\n    return  cos(time) *16.5; \n}\n\nvec3 getBounceTranslation(float time)\n{\n    vec3 elipseTransl  =  vec3( BOUNCE_RADIUS * sin(time/8.0), \n                                 getBounceHeight(time),\n                                 BOUNCE_RADIUS * -1. * cos(time/8.0) - 10.0) ;      \n    return elipseTransl;\n}\n\nfloat getTime() \n{\n    // mitigates error over time\n    return mod(iTime , 100.);\n}\n\n\nfloat waveHeight(vec2 pointHorizontal, \n                 vec2 wave_source, \n                 float speed , \n                 float wavelength, \n                 float timePhaseOffset,\n                 float amplitude) \n{\n    // inspired by https://www.shadertoy.com/view/XdtcD4\n\n    float horizontal_dst = distance(pointHorizontal, wave_source); //2d distance to emitter\n    \n    float phase_shift = (getTime()  + timePhaseOffset) * speed;\n    \n    // as horizontal_dist increases, sin(x) will oscilate it between troughs and peaks\n    // phase shift, shifts the sinusoid creating illusion of ripples\n    float wave_height = cos(horizontal_dst * wavelength - phase_shift);\n    \n    float slope_derivative_factor = EULER;\n    float sharper_peaks = pow(slope_derivative_factor, wave_height); // also makes it all positive\n    wave_height = sharper_peaks;\n    \n    wave_height *= amplitude;\n\n\treturn wave_height;\n}\n\nfloat waveFilter(float dist, float filter_width, float phase_offset, float wavelength)\n{\n        \n    float width_scale = 1.0 / (filter_width / 2.0);\n    float start_from_filter_edge = 1.2;\n    return max(-pow( (dist ) * width_scale -  phase_offset + start_from_filter_edge, 2.) + 1., 0.);\n\n}\n\nfloat wavePropogation(vec2 pointHorizontal, \n                 vec2  wave_source, \n                 float speed , \n                 float wavelength, \n                 float amplitude, \n                 float timeStart) \n{\n    // multiply wave function with filter dependent on time to mimic wave propgation\n\n    float waves_height  = waveHeight(pointHorizontal, \n                                  wave_source, \n                                  speed, \n                                  wavelength, \n                                  getTime(),\n                                  amplitude) ;\n\n    float horizontal_dst = distance(pointHorizontal, wave_source); //2d distance to emitter\n    float phase_offset = (iTime - timeStart) - .2;\n    \n    \n    return waves_height * waveFilter( horizontal_dst,  WAVE_PROP_TIME_FILTER, phase_offset, wavelength);\n}\n\nfloat wavesSDF(vec3 p)\n{\n    \n    float combined_waves_height = 0.;\n    \n   \n    vec3 wave_emitter_location;\n    \n    \n    float half_wavelength = PI; \n    float latest_surface_pierce = half_wavelength * floor(iTime / half_wavelength) ; \n\n    \n    float surfrace_drag_offset;\n    float pierce_time = latest_surface_pierce; \n\n    float center_time = latest_surface_pierce;\n    for ( int surface_breach_i = 0; surface_breach_i <  4 ; surface_breach_i++) \n    {\n        // bounce orb waves\n        for( surfrace_drag_offset = 0.0;  surfrace_drag_offset < 1.0 ; surfrace_drag_offset += .5)\n        {\n        \n            wave_emitter_location.y = getBounceHeight( pierce_time - surfrace_drag_offset);\n            wave_emitter_location.xz = getBounceTranslation( (pierce_time + PI/2.0) - surfrace_drag_offset ).xz;\n\n     \n            combined_waves_height += wavePropogation(p.xz, \n                                                wave_emitter_location.xz , \n                                                WAVE_SPEED, \n                                                WAVE_LENGTH, \n                                                WAVE_AMPLITUDE_FACTOR, \n                                                pierce_time - surfrace_drag_offset ) ;                                    \n        }\n\n        //center orb wave\n        combined_waves_height += wavePropogation(p.xz, \n                                                vec2(0.0,-10.0), \n                                                WAVE_SPEED, \n                                                WAVE_LENGTH, \n                                                WAVE_AMPLITUDE_FACTOR, \n                                                pierce_time );  \n\n        pierce_time -= PI; \n        \n    }\n    \n    \n    vec3 current_pos    = getBounceTranslation( iTime );\n\n    float waves_only    = p.y - combined_waves_height;\n    float centerWater   = sphereSDF( p  / 40.) * 40. ;// 40 = scale\n    float followed_body = boxSDF(p - vec3(current_pos.x, 11.0, current_pos.z - 15.), \n                                 vec3( 40. , 50. , 60.)); \n    return intersectSDF( waves_only, smoothUnion(centerWater, followed_body, 5.));\n\n}\n\nfloat orbSDF(vec3 samplePoint) \n{\n    float scale = 12.0;\n    vec3 translation =  getBounceTranslation(iTime); \n\n    float orbDist = sphereSDF((samplePoint - translation) / scale) * scale ;\n    return orbDist;\n}\n\n\nfloat centerOrbSDF(vec3 samplePoint)\n{\n     float scale = 10.0  + max( .3 ,  (1. - abs(cos(iTime))) ) * 5.;\n\n     vec3 translation =  vec3(0.0,12.0,-10.0);\n     float centerOrb = sphereSDF((samplePoint - translation) / scale) * scale ;\n\n     translation =  vec3(cos(iTime) * 24. ,13.0 + sin(iTime / 2.0) * 4.0 , -10.0 + cos(iTime/2.0) * 3.0 );     \n     scale = 6.667 +  (1. - abs(cos(iTime))) * 5.;\n     float orbit1 = sphereSDF((samplePoint - translation) / scale) * scale ;\n\n     centerOrb = smoothUnion(orbit1, centerOrb, 8.0);\n\n    return centerOrb; \n}\n\nfloat floorSDF(vec3 samplePoint)\n{\n    vec3 boxScale = vec3(130.0,2.0,100.0) * 1.;\n    vec3 box_translation = vec3(0.0,-40.0,0.0);\n    float rect = boxSDF(samplePoint - box_translation, boxScale);\n    \n    return rect;\n}\n\nfloat wallSDF(vec3 samplePoint)\n{\n    vec3 boxScale2 = vec3(100.0, 100.0, 50.0);\n    vec3 box_translation2 = vec3(0.0,20.0,-150.0);\n    float rect2 = sphereSDF((samplePoint - box_translation2) / boxScale2 ) * 50. ; // minDim(boxScale2) == 50.\n  \n    \n    return rect2;\n}\n\nvoid trimOverlaps()\n{\n    // For this case we only need to trim the water, otherwise we would define behavior for each object\n\n    // create temp copy of nontrimmed objects\n    float temp_dist = distances[WATER];\n    for(int i = 0 ; i < TOTAL_OBJECTS; i++)\n    {\n        if(i != WATER  )\n        {\n             temp_dist = differenceSDF(temp_dist, distances[i]); \n        }\n    }\n\n    \n    distances[WATER] = temp_dist;\n}\n\nfloat traverseScene()\n{\n    int closestObject; \n\n    \n    float min_dist =  MAX_DIST + EPSILON*2.;\n    float otherObjectsDist =  MAX_DIST + EPSILON*2.; \n    \n    float current_dist; \n    for(int i = 0 ; i < TOTAL_OBJECTS; i++)\n    {\n              \n            current_dist = distances[i]; \n            // closest object in either direct to edge\n            if(abs(current_dist) < min_dist && i != exitingThisObject)\n            {\n                min_dist = current_dist;\n                closestObject = i;\n\n            }\n    }\n       \n   if(exitingThisObject != SKY)\n   {\n   \n       current_dist = distances[exitingThisObject]; \n       if(abs(current_dist) < min_dist  && abs(min_dist) >= EPSILON)\n       {\n                \n            if(min_dist > 0.0) // if not inside anything\n            {\n                closestObject = SKY;\n            }\n\n            min_dist = current_dist;\n       }\n   \n   }\n    \n   if(abs(min_dist) < EPSILON)\n   {\n     enteringThisObject = closestObject;\n   }\n   \n   return min_dist;\n}\n\nvoid setUpMaterials()\n{\n    //SKY \n    skyMaterial                = Material(\n                                    0.0,\n                                    light_blue * .6, \n                                    1.0, \n                                    DIELECTRIC, \n                                    REFRACTIVE_INDEX_AIR);\n\n    objectMaterials[BOUNCE_ORB] = Material(\n                                  1.0,\n                                  yellow ,\n                                  1.0, \n                                  DIELECTRIC,\n                                  REFRACTIVE_INDEX_FLINT_GLASS);\n                                  \n    objectMaterials[CENTER_ORB] = Material(\n                                  0.0, \n                                  vec3(.8),\n                                  1.0,\n                                  DIELECTRIC, \n                                  REFRACTIVE_INDEX_FLINT_GLASS);                                \n\n    objectMaterials[FLOOR]       = Material(1.0, \n                                  vec3(.5),\n                                  1.0, \n                                  LAMBERTIAN, \n                                  REFRACTIVE_NONE);\n    \n    objectMaterials[WALL]       = Material(0.0, \n                                  vec3(0.113, 0.164, 0.117)* .6,\n                                  .5, \n                                  METAL, \n                                  REFRACTIVE_NONE); \n\n    objectMaterials[WATER]      = Material(1.0,\n                                  light_blue ,\n                                  1.0, \n                                  DIELECTRIC,           \n                                  REFRACTIVE_INDEX_WATER); \n  \n}\n\nvoid setNonOverlapedObjects(vec3 samplePoint)\n{\n    distances[BOUNCE_ORB] = orbSDF(samplePoint);\n    distances[CENTER_ORB] = centerOrbSDF(samplePoint);\n    distances[FLOOR]      = floorSDF(samplePoint);\n    distances[WALL]       = wallSDF( samplePoint);\n    distances[WATER]      = wavesSDF(samplePoint);\n\n    trimOverlaps();\n}\n\nfloat sceneSDF(vec3 samplePoint)\n{\n    setNonOverlapedObjects(samplePoint);\n    return traverseScene();\n}\n\nfloat raymarch(vec3 eye, vec3 rayDir, float start, float end)\n{\n    float depth = start; \n    for(int i = 0; i < MAX_RAYMARCH_STEPS; i ++)\n    {   \n         float dist = sceneSDF(eye + depth * rayDir);\n         dist = abs(dist);\n         \n         if(dist < EPSILON)\n         {\n             return depth;\n         }\n         //else\n         depth += dist; \n         if(depth >= end)\n         {\n             return end;\n         }\n    }\n\n    return end;\n}\n\n\nfloat sceneSDFforNormal(vec3 samplePoint)\n{\n    setNonOverlapedObjects(samplePoint); // enusres border of object in water is closest border\n    \n    float dist_to_surface = MAX_DIST; \n\n    if(exitingThisObject == SKY )\n    {\n        for(int i = 0 ; i < TOTAL_OBJECTS; i++ )\n        {\n            if(i != exitingThisObject)\n            {\n            dist_to_surface = smoothUnion(distances[i],  dist_to_surface, 2.0);\n            }\n        }\n    }\n    else\n    {\n        dist_to_surface = -1.0 * distances[exitingThisObject];\n    }\n    \n    return dist_to_surface; \n}\n\n\nfloat objectSDF(vec3 samplePoint, int object_id)\n{\n    //object ID must be valid index >=0 and < TOTAL_OBJECTS\n    setNonOverlapedObjects(samplePoint);        \n    return  distances[object_id];\n}\nvec3 getNormalForObject(vec3 p, int object_id)\n{\n   return normalize(  vec3( 1,-1,-1)*objectSDF( p + vec3( 1,-1,-1)*EPSILON , object_id) + \n                      vec3(-1,-1, 1)*objectSDF( p + vec3(-1,-1, 1)*EPSILON , object_id) + \n                      vec3(-1, 1,-1)*objectSDF( p + vec3(-1, 1,-1)*EPSILON , object_id) + \n                      vec3( 1 ,1, 1)*objectSDF( p + vec3( 1 ,1, 1)*EPSILON, object_id) );\n}\n\n\nvec3 estimateNormalTetra(vec3 p)\n{\n    // tetrahedron technique , https://iquilezles.org/articles/normalsSDF\n    return normalize( vec3( 1,-1,-1)*sceneSDF( p + vec3( 1,-1,-1)*EPSILON ) + \n                      vec3(-1,-1, 1)*sceneSDF( p + vec3(-1,-1, 1)*EPSILON ) + \n                      vec3(-1, 1,-1)*sceneSDF( p + vec3(-1, 1,-1)*EPSILON ) + \n                      vec3( 1 ,1, 1)*sceneSDF( p + vec3( 1 ,1, 1)*EPSILON) );\n}\n\n\n\n\nvec3 randomInsideUnitSphere(vec3 rayDir,vec3 rayPos)\n{\n    // credit: colin299\n    return vec3(rand01(iTime * (rayDir.x + rayPos.x + 0.357) ),\n                rand01(iTime * (rayDir.y + rayPos.y + 16.35647) ),\n                rand01(iTime * (rayDir.z + rayPos.z + 425.357) ));\n}\n\nfloat calcFresnelReflectivity(float refraction_ratio, float cos_theta)\n{\n     // Use Schlick's Fresnel  approximation for reflectance.\n   float r0 = (1.0 - refraction_ratio) / (1.0 + refraction_ratio);\n   float reflectance = (r0 * r0)  + (1.0 - r0) * pow((1.0 - cos_theta), 5.0);\n   return reflectance; \n}\n\nbool shouldReflect(vec3 unit_incident_dirt, vec3 normal, float refraction_ratio)\n{\n\n   //using snells law we can find when the equation has no solution:  sin(theta) = refration_ratio * sin'(theta') when right hand side > 1 (max of sin is 1) \n   float cos_theta = min(dot(-unit_incident_dirt, normal), 1.0); // calculcate sign by using cosign ans dot product properties\n   float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n   bool cannot_refract = refraction_ratio * sin_theta > 1.0;\n   \n                                                                           \n   if(cannot_refract || calcFresnelReflectivity(refraction_ratio, cos_theta) >  0.9) //rand01(iTime) gives flickering of light\n   {\n       return true;\n   }\n   else\n   {\n       return false;\n   }\n\n}\n\n\nbool near_zero(vec3 vec)\n{\n     // Return true if the vector is close to zero in all dimensions.\n     // this is useful in avoiding float point error leading to a near zero value when it should just be zero\n    return (abs(vec.x) < EPSILON) && (abs(vec.y) < EPSILON) && (abs(vec.z) < EPSILON);\n}\n\n\nRayTraceOutput getBouncedLight(vec3 hitpoint, vec3 incident_ray)\n{\n     //inspired by ray tracing in a weekend by Peter Shirley\n     vec3 normal    = estimateNormalTetra(hitpoint); // normal at point\n     vec3 randVec   = randomInsideUnitSphere(incident_ray,hitpoint);\n     RayTraceOutput output_ray; \n        \n     if(hit_material.material_type == LAMBERTIAN) // lambertian \n     {\n     \n        // get new diffuse bounce direction; based on lambertian refelction\n        vec3 scatter_direction = normal + randVec;\n\n        // Catch degenerate scatter direction, avoids error where diffuse bounce collapsing back to the point (zero direction) \n        if (near_zero(scatter_direction))\n        {\n            scatter_direction = normal;\n        }\n        \n        output_ray.hit_color = hit_material.albedo;\n        output_ray.rayDir    = normalize(scatter_direction);\n\n     }\n     else if (hit_material.material_type == METAL) // metal\n     {\n        vec3 reflected = reflect(incident_ray, normal) + hit_material.roughness * randVec;\n        \n        // if scattered direction is in same hempisphere as normal\n        bool away_from_surface = dot(reflected, normal) > 0.0 ;\n        output_ray.hit_color = hit_material.albedo; \n\n        if(away_from_surface)\n        {\n           output_ray.hit_color = hit_material.albedo; \n           output_ray.rayDir    = reflected;\n        }\n        else\n        {\n           // if not scattered, it is absorbed into object; end recursive raytracing here\n           output_ray.hit_color = vec3(0.0); \n           output_ray.rayDir    = vec3(0.0);\n        }\n     \n     }\n     else if(hit_material.material_type == DIELECTRIC) // dielectric\n     {\n     \n     \n              \n       float enter_idx = getMaterial(enteringThisObject).refract_idx;\n       float exit_idx  = getMaterial(exitingThisObject).refract_idx; \n       float refraction_ratio = exit_idx / enter_idx;\n        \n        if(exitingThisObject != SKY)\n        {\n            normal = getNormalForObject(hitpoint, exitingThisObject); \n            normal = normal * -1.0;\n        }\n\n       // float refraction_ratio =   outside_refractive / hit_material.refract_idx;\n        // if cant reflect due to snells law, or schlicks approximation of reflectance\n        if (shouldReflect(incident_ray, normal , refraction_ratio) )\n        {\n            output_ray.rayDir = reflect(incident_ray, normal);\n\n        }\n        else\n        {\n            output_ray.rayDir = refract(incident_ray, normal, refraction_ratio);   \n            exitingThisObject = enteringThisObject;\n        }\n        output_ray.hit_color = hit_material.albedo;\n     }\n\n  \n    if(SHOW_NORMALS == true)\n    {\n        output_ray.hit_color = normal;\n\n    }\n    else\n    {\n    \n        output_ray.hit_color = hit_material.albedo;\n\n    }\n    \n    return output_ray; \n}\n\nvec3 rayTrace(vec3 rayOrigin, vec3 rayDirWorld)\n{\n    vec3 color = vec3(0.0,0.0,0.0);\n\n    int current_bounce_depth = 0; \n    RayTraceOutput hit_output;\n    \n    float sky_weight; \n    \n     \n    float multiplier = 1.0;\n    float prev_refact_idx;\n    \n    \n    exitingThisObject = SKY;\n    prev_refact_idx = getMaterial(exitingThisObject).refract_idx;\n\n    for(current_bounce_depth = 0; current_bounce_depth < MAX_BOUNCES; current_bounce_depth++)\n    {\n    \n         float dist  = raymarch(rayOrigin, rayDirWorld, MIN_DIST, MAX_DIST);\n         bool  miss  = (dist > (MAX_DIST - EPSILON ));\n\n         vec3 hitpoint = rayOrigin + dist * rayDirWorld;\n        \n         if(current_bounce_depth == 0)\n         {\n             skyMaterial.albedo = mix(near_black,  vec3(0.729, 0.878, 0.909),   clamp(hitpoint.y / 330.0 + .5, 0.0,1.0) );\n         }\n        \n         if(miss) \n         {\n            // Didn't hit anything            \n            if(SHOW_NORMALS == true)\n            {\n               color = skyMaterial.albedo; \n\n            }\n            else\n            {\n                color += skyMaterial.albedo * multiplier; \n            }\n            \n            break;\n         }\n\n\n\n         hit_material =  getMaterial(enteringThisObject);\n         hit_output   =  getBouncedLight(hitpoint, rayDirWorld);\n   \n         multiplier   *= hit_material.absorbption;\n         rayDirWorld  =  hit_output.rayDir;\n         rayOrigin    =  hitpoint + rayDirWorld * EPSILON* 100.; //check \n         \n         \n         \n        if(SHOW_NORMALS == true)\n        {\n        \n            color = hit_output.hit_color;\n        }\n        else\n        {\n            color += hit_output.hit_color * multiplier;\n        \n        }\n                 \n         multiplier   *= .8;\n\n\n         if(length(rayDirWorld) == 0.0)\n         {\n             break;\n         }\n    }\n    \n    if((current_bounce_depth ) > 0 && !SHOW_NORMALS)\n    {\n        color = color / float(current_bounce_depth );\n\n    }\n    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    mouseNorm = iMouse/ iResolution.xyxy;\n\n    vec2 offset = vec2(250.0, 250.) * mouseNorm.xy  ;\n    \n    // eye will serve as ray origin\n    vec3 eye = vec3(0.0, 250.0 * mouseNorm.y, 250.0 * mouseNorm.x + 250.0) ;\n    eye.x = iMouse.w > 0.0 ? 250.0 * (mouseNorm.x - .5) : 10. * normSin(iTime/10.0);\n    eye.y = iMouse.z > 0.0 ? 250.0 * mouseNorm.y : 100. * normCos(iTime/8.0 - PI );\n    eye.z = iMouse.z > 0.0 ? 250.0 * mouseNorm.x + 250.0 : 150. * normSin(iTime/10.0) + 250.0;\n\n    setUpMaterials();\n    \n    // ray dir is relative to eye, so transform it to world space\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 viewDir;\n    vec3 rayDirWorld;\n    \n    // ray tracing\n    vec3 final_color = vec3(0.0); \n    vec3 sample_color = vec3(0.0);\n    vec2 target_pixel;\n            \n    // anti-alising\n    float max_offset = .5;\n    vec2 antiAlias_offset;\n     \n    for(int sample_i = 0; sample_i < MAX_SAMPLES; sample_i++)\n    {\n        if(sample_i == 0)\n        {\n            target_pixel = fragCoord;\n        }\n        else\n        {\n          //anti aliaising get samples near target smaple and blends them\n         antiAlias_offset = vec2(sin(float(sample_i ) ), cos(float(sample_i))) * max_offset;\n         target_pixel = fragCoord  + antiAlias_offset;\n        }\n        \n        // start condition for ray\n        viewDir     =  rayDirection(45.0, iResolution.xy, target_pixel); \n        rayDirWorld = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n        \n        sample_color += rayTrace(eye, rayDirWorld) ;\n    }\n    \n    if(MAX_SAMPLES > 0)\n    {\n        final_color =  sample_color / float(MAX_SAMPLES);\n    }\n    \n    // no gamma correction because on my computer it seems to do it automatically\n    // fragColor = vec4(final_color,1.0);\n    fragColor = vec4(pow(final_color, vec3(1.0/2.2)), 1.0);  // gamma correction\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nfloat smoothUnion(float a, float b, float k)\n{\n    // credit https://iquilezles.org/articles/smin\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\nfloat unionSDF(float distA, float distB)\n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat intersectSDF(float distA, float distB) \n{\n    return max(distA, distB);\n}\n\nfloat sphereSDF(vec3 point )\n{    \n    // credit https://iquilezles.org/articles/distfunctions\n    return length(point) - 1.0;\n}\n\n\nfloat boxSDF( vec3 p, vec3 b )\n{\n  // credit https://iquilezles.org/articles/distfunctions\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rand01(float seed) { return fract(sin(seed)*43758.5453123); }\n\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    // based off jaime-wongs tutorial http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n    vec3 forward     = normalize(center - eye); \n    vec3 side        = normalize(cross(forward, up)); \n    vec3 relative_up = cross(side, forward);\n\n    return mat4(\n           vec4(side, 0.0), \n           vec4(relative_up, 0.0), \n           vec4(-forward, 0.0),\n           vec4(0.0,0.0,0.0,1.0)\n        );\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0; // centers 'screen' at origin\n    // height from origin, angle is half of field of view\n    float z = (size.y  / tan(radians(fieldOfView) / 2.0) ); // adj = oppiste / tan()\n    \n    // normalize to make unit vecotr, -z = camera pointing in negative z direction\n    vec3 vector_to_pixel = vec3(xy.x, 0, 0) +  vec3(0, xy.y, 0) + vec3(0, 0, -z);\n    return normalize(vector_to_pixel); // make unit vector\n}\n\nfloat minDim(vec3 vec)\n{\n    return  min(vec.x, min(vec.y, vec.z));\n}\n\nfloat normSin(float x)\n{\n     return (sin(x)  + 1.0 ) /2.0;\n}\n\nfloat normCos(float x)\n{\n     return (cos(x)  + 1.0 ) /2.0;\n}\n\nvec3 mix3(vec3 firstColor, vec3 middleColor, vec3 endColor,float weight)\n{\n    float h = 0.8; // adjust position of middleColor\n    return mix(mix(firstColor, middleColor, weight/h), mix(middleColor, endColor, (weight - h)/(1.0 - h)), step(h, weight));\n    \n}\n\n","name":"Common","description":"","type":"common"}]}