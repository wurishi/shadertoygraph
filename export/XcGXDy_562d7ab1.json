{"ver":"0.1","info":{"id":"XcGXDy","date":"1715706185","viewed":100,"name":"Kulla Conty Energy Compensation","username":"mageswarankk","description":"PBR, w energy compensation (Kulla, Conty, et. al 2017)\nCredit for template code: https://learnopengl.com/PBR/Lighting","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["brdf","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// To import precomputed textures into iChannels:\n// cmd + opt + J / Ctrl + Shift + J (on Chrome)\n// You may have to 'allow pasting'\n// Run the following commands:\n// gShaderToy.SetTexture(0, {mSrc:'https://dl.dropbox.com/scl/fi/1qym0nibb6t77j3xdvpq8/E.png?rlkey=6t6ww2x3fhelh2cktoywt56w2&st=73mvpwrb&dl=1', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n// (optional) gShaderToy.SetTexture(1, {mSrc:'https://dl.dropbox.com/scl/fi/i7d6sf46wriwbcsav296x/Eavg.png?rlkey=wgif9r4fk39gwj31oarrwuw4d&st=ehbwqhfd&dl=1', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\nprecision highp float;\n\n// Parameters to tweak\nconst vec3 albedo           = vec3(1.000, 0.500, 0.000);\nconst float compensation_on = 1.0;\nconst float roughness       = 0.5;\nconst float metallic        = 1.0;\n\nconst float PI = 3.14159265359;\n\n// Normal distribution function\nfloat D_GGX (vec3 n, vec3 h, float roughness){\n    float a2    = roughness * roughness;\n    float NdotH = max (dot (n, h), 0.0);\n    float denom = (NdotH * NdotH * (a2 - 1.0) + 1.0);\n    return a2 / (PI * denom * denom);\n}\n\n// Shadow-masking function\nfloat G_SchlickGGX (float NdotV, float roughness){\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\nfloat G_Smith (vec3 n, vec3 v, vec3 l, float roughness){\n    return G_SchlickGGX (max (dot (l, n), 0.0), roughness) * \n           G_SchlickGGX (max (dot (v, n), 0.0), roughness);\n}\n\n// Fresnel function\nvec3 F_Schlick (float cosTheta, vec3 F0){\n    return F0 + (1.0 - F0) * pow (1.0 - cosTheta, 5.0);\n}\n\n// https://www.shadertoy.com/view/4d2XWV by Inigo Quilez\nfloat sphereIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h < 0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n// Kulla Conty Energy Compensation (Kulla Conty et. all 2017)\n// analytical approximations: https://patapom.com/blog/BRDF/MSBRDFEnergyCompensation/\nvec3 kulla_conty(float roughness, float uo, float ui, vec3 F0) {    \n    roughness = clamp(roughness, 0.05, 0.95); // edge cases\n\n    float E_uo  = texture(iChannel0, vec2(clamp(uo, 0.0156, 0.95), roughness)).x;\n    float E_ui  = texture(iChannel0, vec2(clamp(ui, 0.0156, 0.95), roughness)).x;\n    \n        \n    float numerator   = (1.0 - E_uo) * (1.0 - E_ui);\n    float denominator = PI - \n                        0.446898 * roughness - \n                        5.720190 * roughness * roughness +\n                        6.618480 * roughness * roughness * roughness -\n                        2.417270 * roughness * roughness * roughness * roughness;\n            \n    float ior_R = (1.0 + sqrt(F0.r)) / (1.0 - sqrt(F0.r + 0.001));\n    float ior_G = (1.0 + sqrt(F0.g)) / (1.0 - sqrt(F0.g + 0.001));\n    float ior_B = (1.0 + sqrt(F0.b)) / (1.0 - sqrt(F0.b + 0.001));\n    \n    clamp(ior_R, 1.001, 399.999);\n    clamp(ior_G, 1.001, 399.999);\n    clamp(ior_B, 1.001, 399.999);\n    \n    float F_avg_R = (ior_R - 1.0) / (4.08567 + 1.00071 * ior_R);\n    float F_avg_G = (ior_G - 1.0) / (4.08567 + 1.00071 * ior_G);\n    float F_avg_B = (ior_B - 1.0) / (4.08567 + 1.00071 * ior_B);\n    \n    vec3 F_avg = vec3(F_avg_R, F_avg_G, F_avg_B);\n        \n    float E_avg = (-denominator / PI) + 1.0;\n    \n    vec3 color = F_avg * E_avg / (1.0 - F_avg * (1.0 - E_avg));\n    \n    return color * vec3(numerator/denominator);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // float roughness = iMouse.x / 640.0;\n    // float metallic  = iMouse.y / 375.0;\n\n    vec2 vScreen = fragCoord.xy / iResolution.xy;\n    \n    // Calculate aspect ratio\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    \n    vec3 lightPos   = vec3(1.25, 1.0, -2);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 totColor = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    float time = iTime * 0.5;\n    ro.x = sin(time) * 4.0;\n    ro.z = cos(time) * 4.0;\n        \n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    \n    vec2 screenCoords = (vScreen * 2.0 - 1.0) * aspectRatio;\n\n    for (float x = 0.0; x <= 1.0; x += 1.0) {\n        for (float y = 0.0; y <= 1.0; y += 1.0) {\n\n            float fov = 40.0;\n\n            // Adjust ray direction based on FOV\n            float fovRatio = tan(radians(fov) / 2.0);\n            vec3 screenCoords = vec3((vScreen * 2.0 - 1.0) * aspectRatio * fovRatio, -1.0);\n\n            // Calculate ray direction\n            vec3 rd = normalize(forward + screenCoords.x * right + screenCoords.y * up);\n            float d = sphereIntersect(ro, rd, vec4(0,0,0,1));\n            \n            if (d > 0.0) {\n                vec3 worldPos = ro + d * rd;\n                vec3 n = normalize(worldPos);\n                vec3 v = -rd;\n                vec3 l = normalize(lightPos - worldPos);\n                vec3 h = normalize(v + l);\n                \n                // Cook-Torrance BRDF\n                vec3  F0 = mix(vec3(0.04), pow(albedo, vec3(2.2)), metallic);\n                float NDF = D_GGX(n, h, roughness);\n                float G   = G_Smith(n, v, l, roughness);\n                vec3  F   = F_Schlick(max(dot(h, v), 0.0), F0);\n                vec3  kD  = vec3(1.0) - F;\n                kD *= 1.0 - metallic;\t\n                \n                vec3  numerator   = NDF * G * F;\n                float denominator = 4.0 * max(dot(v, n), 0.0) * max(dot(l, n), 0.0);\n                vec3  specular    = numerator / max(denominator, 0.001);\n                \n                vec3 diffuse      = kD * pow(albedo, vec3(2.2)) / PI;\n                        \n                vec3 missing      = kulla_conty(roughness, dot(n,v), dot(n,l), F0);\n                    \n                float NdotL = max(dot(l, n), 0.0);                \n                vec3  color = lightColor * (specular + diffuse + missing * compensation_on) * \n                              (NdotL / dot(lightPos - worldPos, lightPos - worldPos));\n                              \n                totColor += color;\n            }\n            else { totColor = vec3(1.0); }\n        }\n    }\n    \n    // HDR tonemapping gamma correct\n    fragColor = vec4(pow(totColor/(totColor + 1.0), vec3(1.0/2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}