{"ver":"0.1","info":{"id":"XsV3Dc","date":"1456808961","viewed":108,"name":"mandelbrot hello world test","username":"amdbcg","description":"This is my attempt at a Mandelbrot set. I think some things are missing, namely how to write points, and maybe something is wrong with the function, since it is not returning a mandelbrot set.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mandlebrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 col;\nvec2 p ;\nvoid plotPoint(vec2 pt,  vec2 uv){\n    p = uv - pt;\n    float result = length(p)*16.0;\n    vec3 col1 = vec3(smoothstep(0.01, 2.88, result));\n    col *= vec3(smoothstep(0.2, .3, result));\n    col = mix (col , col1 , sin(result)); \n    // how do I make this have more contrast?\n    // better, how do I map these points to points on the screen? uv? \n\n}\nvoid plotCircle(vec2 pt, float r , vec2 uv){\n    \n    float theta;\n    for(float i = 0.0; i< 100.0; i++)\n    {\n     theta = degrees(i);\n      plotPoint(vec2(r*cos(theta)+pt.x,r*sin(theta))+pt.y,uv);\n        \n    \n    }\n}\nvoid plotMandelbrot(vec2 c, vec2 uv, out vec4 fragColor){\n    // We start with the form of Z = Z^2 + C, and first iteration, Z = 0 ,\n    // to get a mandelbrot set , we need C to have an imaginary part i to it\n    // imaginary (i) numbers will go in the y part of the vector. \n    // \n    vec2 z = vec2(0.0,0.0);\n \n    \n    for( int i =0 ; i<11; i++){\n        \n        if(z.y != 0.0)\n        {\n            // if z.y exists, we have an imaginary component \n            //subtract z.y*z.y from z.x*z.x \n            //set z.y to 2*z.x*z.y  (based on foil of (a^2 + b^2) of imaginary nums.\n            z.x = z.x*z.x - z.y*z.y + c.x;\n            z.y = 2.0*z.x*z.y + c.y;\n\n\n        }\n        else\n        {\n            // if z.y does not exist  (no imaginary numbers)\n            z.x = z.x*z.x +c.x;\n            z.y = c.y;\n        }\n   // plotPoint(z, uv);\n       fragColor= vec4(z.x, z.y,z.x, 1.0);\n    }\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    p = uv - vec2(.5,.5);\n    float result = length(p)*5.0;\n    vec3 col1 = vec3(smoothstep(0.1, 0.1, result));\n    \n    p = uv - vec2(0.1,0.5);\n    result = length(p)*4.0 ;\n    col = vec3( 0.4, 0.6, 0.7);\n    col *= vec3(smoothstep(0.1, .1, result));\n   \n   // plotPoint(vec2(0.5,0.6), uv);\n    //plotCircle(vec2(0.5,0.5), .2, uv);\n    vec2 c = vec2(p.x,p.y);\n    plotMandelbrot(c, uv,fragColor);\n\tfragColor /= vec4(col,1.0);\n}\n/**\nvec3 mandelbrotFirstAttempt(vec2 p){\n//vec2 p  = (iResolution.xy);\n    vec2 result;\nfloat x0;\nfloat y0;\nconst float maxIteration = 1000.0;\nfloat log_zn ;\nfloat nu ; \nvec3 color1;\nvec3 color2;\nvec3 color ;\n    float xtemp;\n    float r;\n    float r1;\n   // float iteration = 0.0;\nvec2 res = vec2(250.0, 200.0); // max iteration\n  for(float x = 0.0 ; x < 100.0; x++){\n      \n        for (float y = 0.0; y < 100.0; y++){\n        \tx0 = -x/2.5;\n            y0 = sin(y);\n            \n            for(float iteration = 0.0 ; iteration < maxIteration; iteration++ ){\n                if( x*x + y*y >= pow(2.0,8.0)){\n                    if( iteration > maxIteration){\n                        break;\n                    }\n                }\n            \txtemp = x*x - y*y +x0;\n                result.x = 2.0*x*y + y0;\n                result.y = xtemp;\n            \t//iteration = iteration+1.0;\n                \n            }\n            //if ( iteration < maxIteration)\n            float iteration =0.0;\n             log_zn = log( x*x + y*y)/ 2.0;\n             nu = log( log_zn / log(2.0) ) / log(2.0);\n             iteration = iteration + 1.0 - nu;\n       }\n    \n    }\n    \t\tfloat iteration =0.0;\n            r = floor(iteration);\n            r1 = r+1.0;\n            color1 = vec3( r, r, 0.0 );\n            color2 = vec3( r1, r1,r1);\n    \t\tcolor = mix(color1, color2, sqrt(p.x));\n    return color; \n\n}\n**/\n\n/**\nFor each pixel (Px, Py) on the screen, do:\n{\n  x0 = scaled x coordinate of pixel (scaled to lie in the Mandelbrot X scale (-2.5, 1))\n  y0 = scaled y coordinate of pixel (scaled to lie in the Mandelbrot Y scale (-1, 1))\n  x = 0.0\n  y = 0.0\n  iteration = 0\n  max_iteration = 1000\n  // Here N=2^8 is chosen as a reasonable bailout radius.\n  while ( x*x + y*y < (1 << 16)  AND  iteration < max_iteration ) {\n    xtemp = x*x - y*y + x0\n    y = 2*x*y + y0\n    x = xtemp\n    iteration = iteration + 1\n  }\n  // Used to avoid floating point issues with points inside the set.\n  if ( iteration < max_iteration ) {\n    // sqrt of inner term removed using log simplification rules.\n    log_zn = log( x*x + y*y ) / 2\n    nu = log( log_zn / log(2) ) / log(2)\n    // Rearranging the potential function.\n    // Dividing log_zn by log(2) instead of log(N = 1<<8)\n    // because we want the entire palette to range from the\n    // center to radius 2, NOT our bailout radius.\n    iteration = iteration + 1 - nu\n  }\n  color1 = palette[floor(iteration)]\n  color2 = palette[floor(iteration) + 1]\n  // iteration % 1 = fractional part of iteration.\n  color = linear_interpolate(color1, color2, iteration % 1)\n  plot(Px, Py, color)\n}\n**/\n/**\nwhere c is a complex parameter. For each c, one considers the behavior of the sequence\n\n(0, P_c(0), P_c(P_c(0)), P_c(P_c(P_c(0))),...)\nobtained by iterating P_c(z)\nstarting at critical point z = 0,\nwhich either escapes to infinity or stays within a disk of some finite radius. \n**/\n/**\nfloat mandelbrotRecursive(float z, float c, int n, out float result){\n    if ( n <= 0 ){\n    \treturn c;\n    }\n    else{\n    \tz = z*z + c;\n    \treturn ( z,c, n -1, result);\n    }\n    //float a, pi,b,n;\n    //pi = 3.1415926;\n    //a = pi*\n    \n//    return result;\n\n}\n**/","name":"Image","description":"","type":"image"}]}