{"ver":"0.1","info":{"id":"Dts3zB","date":"1671971870","viewed":99,"name":"Hexagon Cube","username":"Ark","description":"Using hexagonal coordinates","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["hexagon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793;\nconst float PI_2 = PI*2.;\n\n// [0, 1] -> [0, 1]\nfloat easeIn(float t) {\n  return t*t*t*t;\n}\n\n// [0, 1] -> [0, 1]\nfloat easeInOut(float t) {\n  if (t < 0.5) {\n    return easeIn(2.*t)/2.;\n  } else {\n    return 1. - easeIn(2. - 2.*t)/2.;\n  }\n}\n\nmat2 rot(float theta) {\n  return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nfloat crs(vec2 a, vec2 b) {\n  return a.x*b.y - a.y*b.x;\n}\n\nvec3 toHex(vec2 p) {\n  const mat2 m = mat2(sqrt(3.)/3., -1./3., 0., 2./3.);\n  vec2 q = p * m;\n  return vec3(q, -(q.x + q.y));\n}\n\nvec2 toCartesian(vec3 hex) {\n  const mat2 m = mat2(sqrt(3.), sqrt(3.)/2., 0., 3./2.);\n  return hex.xy * m;\n}\n\nfloat hexLength(vec3 pHex) {\n  vec2 q = toCartesian(pHex) * rot(PI/6.);\n  vec3 qHex = toHex(q);\n  vec3 t = abs(qHex);\n  return max(t.x, max(t.y, t.z)) * sqrt(3.);\n}\n\nfloat hexagon(vec2 p, float r) {\n  float len = hexLength(toHex(p));\n  return len - r;\n}\n\nfloat arcHexagon(vec2 p, float r, float theta1, float theta2) {\n  vec3 hex1 = toHex(vec2(cos(theta1), sin(theta1)));\n  float len1 = hexLength(hex1);\n  vec2 q1 = toCartesian(hex1) * (r/len1);\n  vec3 hex2 = toHex(vec2(cos(theta2), sin(theta2)));\n  float len2 = hexLength(hex2);\n  vec2 q2 = toCartesian(hex2) * (r/len2);\n\n  if (crs(p, q1) > 0.) {\n    return length(p - q1);\n  } else if (crs(p, q2) < 0.) {\n    return length(p - q2);\n  } else {\n    return abs(hexagon(p, r));\n  }\n}\n\nfloat gridHexagon(vec2 p, float r, float alpha) {\n  vec3 pHex = toHex(p);\n  vec3 qHex = floor(pHex + .5);\n  vec3 diff = abs(pHex - qHex);\n  if (diff.x > diff.y && diff.x > diff.z) {\n    qHex.x = -(qHex.y + qHex.z);\n  } else if (diff.y > diff.z) {\n    qHex.y = -(qHex.z + qHex.x);\n  } else {\n    qHex.z = -(qHex.x + qHex.y);\n  }\n\n  float theta1 = 0. + alpha;\n  float theta2 = PI_2/3. + alpha;\n  float d = arcHexagon(toCartesian(pHex - qHex), r, theta1, theta2);\n  return d;\n}\n\nvec3 draw(vec2 p, vec3 power) {\n  const float N = 3.;\n  float stepSecs = 9./N;\n  float t = mod(iTime, stepSecs*N);\n\n  // [0, stepSecs*N) -> [0, N)\n  t = floor(t/stepSecs) + easeInOut(fract(t/stepSecs));\n\n  vec2 q1 = (p - vec2(0, 0))*rot(PI_2/3.*0.);\n  vec2 q2 = (p - vec2(0, 1))*rot(PI_2/3.*1.);\n  vec2 q3 = (p - vec2(0, 2))*rot(PI_2/3.*2.);\n\n  float alpha = PI_2*(t/N) + PI/6.;\n  float r = 1.15;\n\n  float d1 = gridHexagon(q1, r, alpha);\n  float d2 = gridHexagon(q2, r, alpha);\n  float d3 = gridHexagon(q3, r, alpha);\n\n  vec3 c1 = power / min(d1, d2);\n  vec3 c2 = power / min(d2, d3);\n  vec3 c3 = power / min(d3, d1);\n\n  if (t < 1.) {\n    return mix(c1, c2, t - 0.);\n  } else if (t < 2.) {\n    return mix(c2, c3, t - 1.);\n  } else {\n    return mix(c3, c1, t - 2.);\n  }\n}\n\nvec3 palette(float t) {\n  vec3 a = vec3(.2, .7, .8);\n  vec3 b = vec3(.1, .3, .2);\n  vec3 c = vec3(1., 1., 1.);\n  vec3 d = vec3(2./3., 0./3., 1./3.);\n  return a + b*cos(PI_2*(c*t + d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (fragCoord*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n  \n  const float scale = 6.;\n  vec3 power = palette(iTime/12. + .5)*.2;\n  vec3 col = draw(p*scale, power);\n  \n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}