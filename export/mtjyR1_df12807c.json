{"ver":"0.1","info":{"id":"mtjyR1","date":"1691493431","viewed":38,"name":"Radial gradient multistop","username":"bkeenan","description":"Radial gradient with multiple color stops.\nAnimated breathing effect.\nIncludes timeline for debugging animation.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Radial gradient with multiple color stops.\n * Animated breathing effect.\n */\n\n// Use medium precision on mobile devices\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TAU (2.0*PI)\n\n#define COLOR_BLACK       vec3(0.0, 0.0, 0.0)\n#define COLOR_WHITE       vec3(1.0, 1.0, 1.0)\n#define COLOR_BLUE        vec3(0.0, 0.11, 0.41)\n#define COLOR_RED         vec3(0.79, 0.02, 0.16)\n\n// Size of one pixel in normalized texture coordinates (0-1)\nfloat pixel_size;\n\n// Duration of the animation in seconds\nfloat animation_duration = 5.0;\n\n\n/**\n * Add a progress bar to the bottom of the canvas for debugging.\n *\n * @param  {vec2} uv             Current fragment point (x,y) in the range [0, 1]\n * @param  {vec3} frag_color     The original color of the current fragment before modification.\n * @param  {float} progress      Progress of the bar, in the range [0, 1].\n * @return {vec3}                The modified color of the current fragment after applying the progress bar effect.\n */\nvec3 progress_bar(vec2 uv, vec3 frag_color, float progress) {\n  // Don't repeat\n  if(uv.x < 0.0 || uv.x > 1.0) {\n    return frag_color;\n  }\n\n  float height = pixel_size * 8.0;\n  float padding_bottom = pixel_size * 20.0;\n\n  // Skip if outside progress bar area\n  if(uv.y < padding_bottom || uv.y > padding_bottom + height) {\n    return frag_color;\n  }\n\n  // Background area\n  frag_color = mix(frag_color, COLOR_WHITE, 0.3);\n\n  // Add caps on the left and right sides of the background area\n  float cap_width = pixel_size * 2.0;\n  if(uv.x < cap_width || uv.x > (1.0 - cap_width)) {\n    frag_color = mix(frag_color, COLOR_WHITE, 0.4);\n  }\n\n  // Playhead\n  if(uv.x <= progress) {\n    frag_color = mix(frag_color, COLOR_WHITE, 0.6);\n  }\n\n  return frag_color;\n}\n\n/**\n * Bias Ease-In and Ease-Out\n * \n * @param  {float} x      The value to Ease (the input value to interpolate)\n * @param  {float} bias   Control parameter to vary the function from ease-out (0.0) to ease-in (1.0).\n *                        The midpoint is linear, no easing (0.5).\n * @param  {bool}  invert Invert the curve, e.g. to switch direction of interpolation.\n */\nfloat bias(float x, float bias, bool invert) {\n  if(invert)\n    bias = 1.0 - bias;\n\n  return x / ((1.0 / bias - 2.0) * (1.0 - x) + 1.0);\n}\n\n/**\n * Mix a gradient between two colors based on the input value within the specified stops.\n *\n * @param val       The input value for which the gradient is calculated.\n * @param stop1     Where the gradient starts.\n * @param stop2     Where the gradient ends.\n * @param midpoint  Midpoint controls where the transition occurs. 0-1 range, 0.5 is linear.\n * @param color_a   The starting color of the gradient.\n * @param color_b   The ending color of the gradient.\n * @return          The interpolated color between color_a and color_b based on the input value.\n */\nvec3 color_gradient(float val, float stop1, float stop2, float midpoint, vec3 color_a, vec3 color_b) {\n  // Clamp input value within the specified stops range\n  val = clamp(val, stop1, stop2);\n\n  // Calculate the relative position of val between the stops (0-1)\n  val = (val - stop1) / (stop2 - stop1);\n\n  // Calculate the gradient with a midpoint bias\n  float bias_ease = bias(val, midpoint, true);\n  float weight = mix(0.0, 1.0, bias_ease);\n\n  // mix the colors\n  return mix(color_a, color_b, weight);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Current fragment position in normalized coordinates (0-1)\n  vec2 uv = fragCoord / iResolution.xy;\n  // Size of one pixel in normalized texture coordinates (0-1)\n  pixel_size = 1.0 / iResolution.y;\n  // Canvas aspect ratio\n  float aspect_ratio = iResolution.x / iResolution.y;\n  // Centre horizontally (shift to origin, scale, shift back)\n  uv.x = (uv.x - 0.5) * aspect_ratio + 0.5;\n  \n  // Calculate the normalized time in the range [0, 1]\n  float normalized_time = mod(iTime, animation_duration) / animation_duration;\n  float oscillating_time = (0.5 + 0.5 * sin(2.0 * PI * normalized_time));\n\n  // Distance from the current fragment to the center (0.5, 0.5)\n  // Full range at the corners: 0 - âˆš(0.25+0.25) (approx 0.707)\n  float distance_to_center = distance(uv, vec2(0.5, 0.5));\n  // Circle that fits within the canvas has a max radius of 0.5\n  // Normalise distance, so a circle that fits within the canvas has a radius of 1.0\n  float unit_radius = distance_to_center * 2.0;\n\n  // Background color\n  vec3 color = COLOR_BLACK;\n  \n  // Define the gradient with color stops from 0.0 to 1.0\n  // float stop1 = 0.0;\n  // float midpoint1 = 0.998; // tight transition, close to next stop\n  // float stop2 = 0.55;\n  // float midpoint2 = 0.998; // tight transition, close to next stop\n  // float stop3 = 0.7;\n\n  // Breathing effect\n  float stop1 = 0.0;\n  float midpoint1 = mix(0.97, 0.992, oscillating_time);\n  float stop2 = mix(0.4, 0.65, oscillating_time);\n  float midpoint2 = mix(0.96, 0.985, oscillating_time);\n  float stop3 = mix(0.6, 0.8, oscillating_time);\n\n  // Mix the gradients between each stop\n  color = color_gradient(unit_radius, stop1, stop2, midpoint1, COLOR_RED, COLOR_WHITE);\n  color = color_gradient(unit_radius, stop2, stop3, midpoint2, color, COLOR_BLUE);\n\n  // Timeline\n  color = progress_bar(uv, color, oscillating_time);\n  \n  // Output to screen\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}