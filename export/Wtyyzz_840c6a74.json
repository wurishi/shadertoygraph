{"ver":"0.1","info":{"id":"Wtyyzz","date":"1610302942","viewed":148,"name":"terryspitz watchmen","username":"terryspitz","description":"Staring into the pool...\nBased on https://terryspitz.github.io/Pool/public/index.html","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float limit = 0.1;\nconst float ds = limit/10.;\n\n//for debugging\n//#define SHOW_TEXTURE\n//#define DEBUG_NUM\n\n#ifdef DEBUG_NUM\n    //from https://www.shadertoy.com/view/3dyyRh\n    #define GREEN vec3(.3,1.,.3)\n    #define FONT_CHANNEL iChannel1\n\n    // From: https://www.shadertoy.com/view/4sBfRd, in serious need of simplifying\n    vec4 char(vec2 p, int c) {\n        if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n        return texture( FONT_CHANNEL, p/16. + fract( vec2(c, 15-c/16) / 16. ));\n    }\n\n    float printNumber(vec2 fragCoord, float number) {\n        float fontSize = 16.;\n        // init digits\n        int digits[12];\n        // numbers start at 48 in font map\n        for(int i = 0; i <= 9; i++) digits[i] = 48 + i;\n        digits[10] = 46; // .\n        digits[11] = 45; // -\n\n        int a[15]; // array for digits of number\n        int c = 0; // counter for array = length\n        float tmp = abs(number);\n        // do not display numbers higher than this due to precision issues\n        if (tmp > 999999.) {\n            while(c < 8) a[c++] = 11; // --------\n        } else {\n            if(number < 0.) a[c++] = 11; // add - if number is negative\n            int v; // current digit\n            bool f; // true if first digit > 0 found\n            for(int i = 8; i >= -4; i--) {\n                v = int(tmp / pow(10., float(i))); // calculate digit\n                // omit leading zeros\n                if(v > 0 || f) {\n                    a[c++] = v; // add digits 0-9\n                    tmp -= float(v) * pow(10., float(i)); // subtract\n                    f = true;\n                }\n                //decimal point\n                if(i == 0 && abs(number) < 1.) a[c++] = 0; // add 0\n                if(i == 0) a[c++] = 10; // add .\n            }\n            while(a[c-1] == 0) c--; // strip 0\n            if(a[c-1] == 10) c--; // strip .\n        }\n        // coordinate system that starts at bottom left\n        // which is independent of aspect ratio\n        vec2 p = fragCoord.xy / iResolution.y;\n        float result;\n        // output number\n        for(int i = 0; i < c; i++) {\n            result += char(p * 256. / fontSize - vec2(float(i)/2., 0.0), digits[a[i]]).x;\n        }\n        return result;\n    }\n#endif\n\n//checks point is to the 'right' of line from p1 to p2\nbool right(vec2 p1, vec2 p2, vec2 point)\n{\n    return dot(p2-p1, point-p1) > 0.;\n}\n\nvec2 refractPt(vec2 pt)\n{\n    return pt + texture(iChannel0, pt).xy/2.;\n}\n\nfloat cross2(vec2 v1, vec2 v2)\n{\n    return v1.x*v2.y - v1.y*v2.x;\n}\n\n//calculate area of triangle p1, p2, p3\nfloat area(vec2 p1, vec2 p2, vec2 p3)\n{\n    return abs(cross2(p2-p1, p3-p1) / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 bottomPt = fragCoord.xy / max(iResolution.x,iResolution.y);\n#ifdef SHOW_TEXTURE\n    fragColor = texture(iChannel0, bottomPt);\n#else\n    float a = 0.1;\n    float debugNum = -999.;\n    for(float i=-limit; i<=limit; i+=ds) \n    for(float j=-limit; j<=limit; j+=ds) \n    {\n        vec2 top11 = bottomPt + vec2(i,j);\n        vec2 top22 = bottomPt + vec2(i+ds,j+ds);\n        //refracted points\n        vec2 r11 = refractPt(top11);\n        vec2 r12 = refractPt(vec2(top11.x, top22.y));\n        vec2 r21 = refractPt(vec2(top22.x, top11.y));\n        vec2 r22 = refractPt(top22);\n        //check bounds\n        if(right(r11, r12, bottomPt) &&\n            right(r12, r22, bottomPt) &&\n            right(r22, r21, bottomPt) &&\n            right(r21, r11, bottomPt))\n        {\n        //if(distance(refractedPt, bottomPt)<0.01)\n            //a += clamp(area(r11, r21, r22) + area(r21, r22, r12), 0., 0.5);\n            float a2 = area(r11, r12, r22) + area(r12, r22, r21);\n            float intensity = ds*ds/a2;\n            a += intensity/5.;\n            if(debugNum==-999.)\n                debugNum = intensity;\n            //a += 0.5;\n        }\n    }\n    vec3 col = vec3(a, a, 0.9);\n    #ifdef DEBUG_NUM\n    col = mix(col, GREEN, printNumber(fragCoord, debugNum));\n    #endif\n    fragColor = vec4(fract(col*10.), 1.);\n#endif\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int frequencies = 15;\nconst float speed = 0.05;\nconst float scaling = 0.0001;\n\nconst float TAU = 6.28318530718;\n#define SECOND_DERIV\n\nvec2 hash2( vec2  p ) \n{ p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\n#ifdef SECOND_DERIV\n    #define DTYPE vec4\n#else\n    #define DTYPE vec2\n#endif\n\nDTYPE d(vec2 uv, float t) \n{\n    DTYPE d;\n    for(int i=-frequencies; i<=frequencies; ++i)\n    {\n        for(int j=-frequencies; j<=frequencies; ++j)\n        {\n            vec2 amp_phase = hash2(vec2(i,j));// / float(i*i + j*j);\n            float amp = amp_phase.x, phase = amp_phase.y * TAU;\n            float theta = ( (uv.x + sign(float(i))*speed*t) *  float(i)\n                                   + (uv.y + sign(float(j))*speed*t) * float(j))\n                                 + phase;\n            float costheta = cos(theta);\n          #ifdef SECOND_DERIV\n            float sintheta = sin(theta);\n          #endif\n            d += DTYPE(amp * float(i) * costheta\n                      ,amp * float(j) * costheta\n                  #ifdef SECOND_DERIV\n                      ,amp * float(i) * sintheta\n                      ,amp * float(j) * sintheta\n                  #endif\n                  );\n        }\n    }\n    return d * scaling;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / max(iResolution.y,iResolution.x);\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    DTYPE d = d(uv, iTime);\n    \n    // Output to screen\n#ifdef SECOND_DERIV\n    fragColor = d;\n#else\n    fragColor = vec4(d, 0.9, 1.0);\n#endif\n}\n","name":"Buffer A","description":"","type":"buffer"}]}