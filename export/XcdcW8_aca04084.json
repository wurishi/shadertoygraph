{"ver":"0.1","info":{"id":"XcdcW8","date":"1730573591","viewed":123,"name":"DFT: Discrete Fourier Transform","username":"vchizhov","description":"Computes the discrete Fourier transform (DFT) and its inverse (IDFT). Visualises the power spectrum and applies (toroidal) Gaussian convolution through multiplication with a Gaussian in the frequency domain. See Common for more details.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["blur","gaussian","fourier","dft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n        \n#if MODE==0 || MODE==2\n    vec2 s = texture(iChannel1,fract(uv+vec2(0.5))).xy;\n    vec3 col = vec3(log(s.x*s.x+s.y*s.y)/10.0);\n#else\n    vec3 col = vec3(texture(iChannel0,uv).x);\n#endif\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // transforms the rows of the image\n    vec2 r = DFT_row_img_grey(iChannel3, fragCoord.xy, iResolution.xy);\n\n    fragColor = vec4(r,0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // transforms the columns of the image\n    vec2 r = DFT_col(iChannel0, fragCoord.xy, iResolution.xy);\n    \n    \n#if MODE>1\n    // frequencies increase until half of the screen, and then decrease\n    // thus we need to split the coordinates in 4 pieces\n    // also take into account the aspect ratio so that the Gaussian is isotropic\n    vec2 uv;\n    float ar = iResolution.x/iResolution.y;\n    if (1.0<=ar) // h<=w\n    {\n        uv = fragCoord.xy/iResolution.x;\n        if (uv.x>=0.5) uv.x = 1.0-uv.x;\n        if (uv.y>=0.5/ar) uv.y = 1.0/ar-uv.y;\n    }\n    else // h>w\n    {\n        uv = fragCoord.xy/iResolution.y;\n        if (uv.x>=0.5*ar) uv.x = 1.0*ar-uv.x;\n        if (uv.y>=0.5) uv.y = 1.0-uv.y;\n    }\n    // weigh with a Gaussian\n    r = r * exp(-PI*PI*dot(uv,uv)*(STD*STD));\n    \n#endif\n    \n    fragColor = vec4(r,0.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // backtransforms the columns of the image\n    vec2 r = IDFT_col(iChannel0, fragCoord.xy, iResolution.xy);\n    \n    fragColor = vec4(r,0.0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // backtransforms the rows of the image\n    vec2 r = IDFT_row(iChannel0, fragCoord.xy, iResolution.xy);\n\n    fragColor = vec4(r,0.0,1.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// README:\n\n// Applies the discrete Fourier transform (DFT) \n// along the rows (bufA), along the columns (bufB)\n// and then applies the inverse discrete Fourier transform (IDFT)\n// along the columns (bufC), along the rows (bufD)\n\n// Note that this is not the orthogonal version of the DFT.\n\n// MODE==0 visualizes the power spectrum |hat{u}|^2 of the image\n// MODE==1 transforms and backtransforms the image (it's just a sanity check)\n// MODE>2 applies Gaussian blur by multiplying the frequency representation \n// hat{u} of the image with the Fourier transform of the Guassian.\n// Due to the convolution theorem, multiplication in the Fourier domain \n// is convolution in the spatial domain.\n// MODE==2 visualizes the Gaussian weighted power spectrum\n// MODE==3 visualizes the Gaussian blurred image\n\n// MODE==0: power spectrum\n// MODE==1: video\n// MODE==2: power spectrum of the weighted transform\n// MODE==3: frequency-space blurred video\n#define MODE 0\n\n// standard deviation for the blurrng\n#define STD 10.0\n\n#define PI 3.14159265358979323846264338327950288420\n\n//////////////////////////////////////////////////////////////////////////////\n//                                                                          //\n//                                                                          //     \n//                  Discrete Fourier Transform of Scalar Data               //\n//                                                                          //\n//                                                                          //\n//////////////////////////////////////////////////////////////////////////////\n\n// For the definition see:\n// https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Definition\n// Note that I am not using the orthogonal version of the DFT\n\nvec2 DFT_row_img_grey(sampler2D f, vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int i = int(xy.x);\n    int j = int(xy.y);\n    \n    // discrete Fourier transform along the j-th row\n    float factor = 2.0*PI*float(i)/float(w);\n    float a = 0.0;\n    float b = 0.0;\n    for (int k=0; k<w; ++k)\n    {\n        vec4 s = texture(f, vec2(k,j)/res);\n        float v = dot(vec3(1.0/3.0), s.xyz);\n        float t = float(k)*factor;\n        a = a + cos(t) * v;// + sin(t) * 0;\n        b = b - sin(t) * v;// + cos(t) * 0;\n    }\n    \n    return vec2(a,b);\n}\n\nvec2 DFT_row(sampler2D f, vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int i = int(xy.x);\n    int j = int(xy.y);\n\n    // discrete Fourier transform along the j-th row\n    float factor = 2.0*PI*float(i)/float(w);\n    float a = 0.0;\n    float b = 0.0;\n    for (int k=0; k<w; ++k)\n    {\n        vec4 s = texelFetch(f, ivec2(k,j), 0);\n        float t = float(k)*factor;\n        a = a + cos(t) * s.x + sin(t) * s.y;\n        b = b - sin(t) * s.x + cos(t) * s.y;\n    }\n    \n    return vec2(a,b);\n}\n\nvec2 IDFT_row(sampler2D f, vec2 xy, vec2 res)\n{\n    int w = int(res.x);\n    int i = int(xy.x);\n    int j = int(xy.y);\n\n    // inverse discrete Fourier transform along the j-th row\n    float factor = 2.0*PI*float(i)/float(w);\n    float a = 0.0;\n    float b = 0.0;\n    for (int k=0; k<w; ++k)\n    {\n        vec4 s = texelFetch(f, ivec2(k,j), 0);\n        float t = float(k)*factor;\n        a = a + cos(t) * s.x - sin(t) * s.y;\n        b = b + sin(t) * s.x + cos(t) * s.y;\n    }\n    a = a/float(w);\n    b = b/float(w);\n    \n    return vec2(a,b);\n}\n\nvec2 DFT_col(sampler2D f, vec2 xy, vec2 res)\n{\n    int h = int(res.y);\n    int i = int(xy.x);\n    int j = int(xy.y);\n    \n    // discrete Fourier transform along the i-th column\n    float factor = 2.0*PI*float(j)/float(h);\n    float a = 0.0;\n    float b = 0.0;\n    for (int k=0; k<h; ++k)\n    {\n        vec4 s = texelFetch(f, ivec2(i,k), 0);\n        float t = float(k)*factor;\n        a = a + cos(t) * s.x + sin(t) * s.y;\n        b = b - sin(t) * s.x + cos(t) * s.y;\n    }\n    \n    return vec2(a,b);\n}\n\nvec2 IDFT_col(sampler2D f, vec2 xy, vec2 res)\n{\n    int h = int(res.y);\n    int i = int(xy.x);\n    int j = int(xy.y);\n    \n    // inverse discrete Fourier transform along the i-th column\n    float factor = 2.0*PI*float(j)/float(h);\n    float a = 0.0;\n    float b = 0.0;\n    for (int k=0; k<h; ++k)\n    {\n        vec4 s = texelFetch(f, ivec2(i,k), 0);\n        float t = float(k)*factor;\n        a = a + cos(t) * s.x - sin(t) * s.y;\n        b = b + sin(t) * s.x + cos(t) * s.y;\n    }\n    a = a/float(h);\n    b = b/float(h);\n    \n    return vec2(a,b);\n}\n\n","name":"Common","description":"","type":"common"}]}