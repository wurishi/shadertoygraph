{"ver":"0.1","info":{"id":"4fBGDR","date":"1714011738","viewed":42,"name":"Raymarching - Phong shading","username":"2x_Helix","description":"Code along of guide by Jamie Wong: https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nImplementation of Phong shading","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong","materials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \nBasically a code-along of jlfwong's demo: https://www.shadertoy.com/view/lt33z7\nhttps://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n*/\nconst int MAX_MARCHING_STEPS = 256;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.142;\nconst float K = 8.;\n\nstruct Material {\n    vec3 specular;\n    vec3 diffuse;\n    vec3 ambient;\n    float shininess;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 intensity;\n};\n\n/*\nSDF functions\nhttps://iquilezles.org/articles/distfunctions/\n*/\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat cappedCylinderSDF(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat planeSDF(vec3 p, vec3 n, float h) {\n    // n requires to be normalized\n    return dot(p, n) + h;\n}\n\n/*\nSDF operations\n*/\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nmat3 rotateX(float t) {\n    return mat3(vec3(1, 0, 0),\n                vec3(0, cos(t), -sin(t)),\n                vec3(0, sin(t), cos(t)));\n}\n\nmat3 rotateY(float t) {\n    return mat3(vec3(cos(t), 0, sin(t)),\n                vec3(0, 1, 0),\n                vec3(-sin(t), 0, cos(t)));\n}\n\nmat3 rotateZ(float t) {\n    return mat3(vec3(cos(t), -sin(t), 0),\n                vec3(sin(t), cos(t), 0),\n                vec3(0, 0, 1));\n}\n\n/*\nScene SDF\n*/\nfloat sceneSDF(vec3 samplePoint){\n    float scene;\n        \n    // Add spinning shape to scene \n    vec3 p = samplePoint * inverse(rotateX(iTime) * rotateY(iTime) * rotateZ(iTime));\n    \n    // Cylinder rotations for union shape\n    float c = PI / 2.;  \n    vec3 pX = p * inverse(rotateX(c));\n    vec3 pZ = p * inverse(rotateZ(c));\n    \n    scene = differenceSDF(\n                intersectSDF(\n                    sphereSDF(p, 1.3), \n                    boxSDF(p, vec3(1.))),\n                unionSDF(\n                    unionSDF(\n                        cappedCylinderSDF(p, 1.1, 0.55), \n                        cappedCylinderSDF(pX, 1.1, 0.55)), \n                    cappedCylinderSDF(pZ, 1.1, 0.55)));\n                          \n    // Add floor of scene                         \n    scene = unionSDF(scene, planeSDF(samplePoint, normalize(vec3(0., 1., 0.)), 1.5));\n    return scene;\n}\n\n/*\nShadow calculation\n*/\nfloat minDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, float penumbra) {\n    //float res = 1.0;\n    float depth = start;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS && depth < end; i++) \n    {\n        float dist = sceneSDF(eye + marchingDirection*depth);\n        \n        if (dist < EPSILON) {\n            return depth;\n            //return 0.0; \n        }\n        \n        // Move along view ray\n        //res = min(res, penumbra*dist/depth);\n        depth += dist;\n    }\n    return end;\n    //return res;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;  // Why does this work? divide by 2\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));    \n}\n\n\n/*\nMaterial calculation (Phong Shading)\n*/\n\n// albedo contributed by a singular light source\n// https://en.wikipedia.org/wiki/Phong_reflection_model\nvec3 phongLightContribution(Material mat, Light light, vec3 p, vec3 eye) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(light.position - p);\n    vec3 R = normalize(reflect(-L, N));  // Reflection of light on surface from calculated as (2. * dot(N,I) * N)\n    vec3 V = normalize(eye - p);  // Direction pointing to camera\n    \n    float dotLM = dot(L, N);  // Diffuse term\n    float dotRV = dot(R, V);  // Specular term\n    /* \n    Can clamp terms to resolve harsh line artifacts,\n    but results in always evaluating the full equation (pow calculation).\n    */\n    //float dotLM = clamp(dot(L, N), 0., 1.);  // Diffuse term\n    //float dotRV = clamp(dot(R, V), 0., 1.);  // Specular term\n    \n    // Light not visible on surface\n    if (dotLM < 0.) {\n        return vec3(0.);\n    }\n    \n    // exclude specular component\n    if (dotRV < 0.) {\n        return light.intensity * mat.diffuse * dotLM;\n    }\n    \n    return light.intensity * (mat.diffuse * dotLM + mat.specular * pow(dotRV, mat.shininess));\n}\n  \n// https://en.wikipedia.org/wiki/Phong_reflection_model\nvec3 phongIllumination(Material mat, vec3 p, vec3 eye) {\n    /*  :mat: Surface material\n        :p:   point on surface\n        :eye: Position of camera\n    */    \n    const vec3 ambientLight = 0.5 * vec3(1., 1., 1.);\n    vec3 colour = mat.ambient * ambientLight;\n    \n    // Light 1\n    Light l1 = Light(vec3(4., 2., 4.),\n                     vec3(0.4, 0.4, 0.4));                \n    colour += phongLightContribution(mat, l1, p, eye);\n    \n    // Light 2\n    Light l2 = Light(vec3(2., 2., 2.), \n                     vec3(0.4, 0.4, 0.4));\n    colour += phongLightContribution(mat, l2, p, eye);\n    \n    return colour;\n}\n\n/*\nMain function\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dir = rayDirection(45., iResolution.xy, fragCoord);\n    vec3 eye = vec3(0., 0., 15.);\n    float dist = minDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST, K);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0., 0., 0., 0.);\n        return;\n    }\n\n    vec3 p = eye + dist * dir;  // Closest point on surface to eyepoint along view ray\n\n    Material mat = Material(vec3(0.435,0.502,0.463),  // Specular\n                            vec3(0.431,0.541,0.867),  // Diffuse\n                            vec3(0.016,0.075,0.306),  // Ambient\n                            10.0);                    // Shininess\n    vec3 col = phongIllumination(mat, p, eye); \n    \n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(dist), 0.);\n}","name":"Image","description":"","type":"image"}]}