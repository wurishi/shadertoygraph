{"ver":"0.1","info":{"id":"stj3zK","date":"1624301718","viewed":135,"name":"Pride tunnel (twitch)","username":"rimina","description":"A shader that I did in my live coding stream at 21st of June 2021.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","pride"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2021-2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :)).\n\n\n#define PI 3.14159265359\n\nconst float E = 0.001;\nconst float FAR = 200.0;\nconst int STEPS = 64;\n\nfloat ID = 0.0;\nbool FLIP = false;\n\nvec3 glow = vec3(0.0);\n\nstruct Material{\n  vec3 l;\n  float li;\n  vec3 s;\n  float si;\n};\n\nMaterial red(){\n  \n  Material m;\n  m.l = vec3(1.0, 0.0, 0.0);\n  m.li = 0.5;\n  m.s = vec3(1.2, 0.2, 0.2);\n  m.si = 0.5;\n  \n  return m;\n}\n\nMaterial orange(){\n  \n  Material m;\n  m.l = vec3(1.0, 0.5, 0.0);\n  m.li = 0.5;\n  m.s = vec3(1.2, 0.7, 0.2);\n  m.si = 0.5;\n  \n  return m;\n}\n\nMaterial yellow(){\n  \n  Material m;\n  m.l = vec3(1.0, 0.8, 0.0);\n  m.li = 0.5;\n  m.s = vec3(1.2, 1.0, 0.2);\n  m.si = 0.5;\n  \n  return m;\n}\n\nMaterial green(){\n  \n  Material m;\n  m.l = vec3(0.0, 1.0, 0.0);\n  m.li = 0.5;\n  m.s = vec3(0.2, 1.2, 0.2);\n  m.si = 0.5;\n  \n  return m;\n}\n\nMaterial blue(){\n  \n  Material m;\n  m.l = vec3(0.0, 0.0, 1.0);\n  m.li = 0.5;\n  m.s = vec3(0.2, 0.2, 1.2);\n  m.si = 0.5;\n  \n  return m;\n}\n\nMaterial purple(){\n  \n  Material m;\n  m.l = vec3(0.8, 0.0, 0.6);\n  m.li = 0.5;\n  m.s = vec3(1.0, 0.2, 0.8);\n  m.si = 0.5;\n  \n  return m;\n}\n\nfloat sphere(vec3 p, float r){\n  return length(p) - r;\n}\n\nfloat cylinder(vec3 p, vec3 c){\n  return length(p.xz-c.xy)-c.z;\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n\nvoid rotate(inout vec2 p, float angle){\n  p = cos(angle) * p + sin(angle) * vec2(p.y, -p.x);\n}\n\n//USING HG SDF LIBRARY!\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.0*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.0;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.0;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.0)) c = abs(c);\n\treturn c;\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n    vec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat scene(vec3 p){\n  \n  vec3 pp = p;\n  \n  float offset = 12.0;\n  \n  float id = floor((pp.z + offset*0.5) / offset);\n  pp.z = mod(pp.z+offset*0.5, offset)-offset*0.5;\n  \n  rotate(pp.yz, radians(90.0));\n  \n  float tunnel = -fCylinder(pp, 12.0, 12.0);\n  \n  rotate(pp.yz, -radians(90.0));\n  \n  if(mod(id, 2.0) == 0.0){\n    rotate(pp.xy, iTime);\n  }\n  else{\n    rotate(pp.xy, -iTime);\n  }\n  \n  ID = pModPolar(pp.xy, offset);\n  pp.x -= offset*0.5;\n  pp -= noise(p)*0.9;\n  \n  float blob = sphere(pp, 1.0);\n  \n  glow += vec3(0.8, 0.2, 0.6) * 0.01 / (abs(tunnel) + 0.06);\n  \n  if(tunnel < blob){\n    FLIP = true;\n  }\n  else{\n    FLIP = false;\n  }\n  \n  return min(tunnel, blob);\n}\n\nfloat march(vec3 ro, vec3 rd){\n  float t = E;\n  vec3 p = ro;\n  for(int i = 0; i < STEPS; ++i){\n    float d = scene(p);\n    t += d;\n    p = ro + rd*t;\n    \n    if(d < E || t > FAR){\n      break;\n    }\n  }\n  \n  return t;\n}\n\n\nvec3 normals(vec3 p){\n  vec3 e = vec3(E, 0.0, 0.0);\n  return normalize(vec3(\n    scene(p + e.xyy) - scene(p - e.xyy),\n    scene(p + e.yxy) - scene(p - e.yxy),\n    scene(p + e.yyx) - scene(p - e.yyx)\n  ));\n}\n\nvec3 shade(vec3 rd, vec3 p, vec3 n, vec3 ld){\n  if(FLIP){\n    n = -n;\n    ld = -ld;\n  }\n  float lambertian = max(dot(n, ld), 0.0);\n  float angle = max(dot(reflect(ld, n), rd), 0.0);\n  float specular = pow(angle, 10.0);\n  \n  Material m = red();\n  \n  if(abs(ID) > 0.0 && abs(ID) <= 1.0){\n    m = orange();\n  }\n  else if(abs(ID) > 1.0 && abs(ID) <= 2.0){\n    m = yellow();\n  }\n  else if(abs(ID) > 2.0 && abs(ID) <= 3.0){\n    m = green();\n  }\n  else if(abs(ID) > 3.0 && abs(ID) <= 4.0){\n    m = blue();\n  }\n  else if(abs(ID) > 4.0 && abs(ID) <= 5.0){\n    m = purple();\n  }\n  \n  return lambertian * m.li * m.l + specular * m.si * m.s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.0, 2.0, iTime*10.0);\n    vec3 rt = vec3(0.0, 1.0, ro.z + 20.0);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x,y,z) * vec3(uv, radians(40.0)));\n\n    float t = march(ro, rd);\n    vec3 p = ro + t * rd;\n    vec3 n = normals(p);\n\n    vec3 ld = -z;\n\n    vec3 col = vec3(0.7, 0.3, 0.5);\n    if(t < FAR){\n    col = shade(rd, p, n, ld);\n    }\n    col += glow * 0.2;\n    float d = distance(p, ro);\n    float fog = 1.0 - exp(-d*0.005);\n    col = mix(col, vec3(0.8, 0.3, 0.6), fog);\n\n    col = smoothstep(-0.2, 1.1, col);\n  \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}