{"ver":"0.1","info":{"id":"llsfzB","date":"1512852306","viewed":409,"name":"Bitsweep","username":"shau","description":"Inspired by Beeple work of same name https://vimeo.com/channels/beeple/49241313","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 4.0\n#define PI 3.14159265359\n#define FAR 100.0 \n#define EPS 0.001\n#define STEP_SIZE 4.0\n#define FLOOR 1.0\n#define BRICK 2.0\n#define TOWER 3.0\n#define LIGHT3 6.0\n\nvec3 lp = vec3(0.0);\nfloat TX = 0.0;\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\nfloat tex(vec2 rp) {\n    float edge = 0.0;\n    edge = step(0.99, abs(rp.x));\n    edge += step(0.99, abs(rp.y));\n    return edge;\n}        \n\n// Cube mapping routine from Fizzer\nfloat fizz(vec3 rp, vec3 box) {\n    rp /= box;\n    vec3 f = abs(rp);\n    f = step(f.zxy, f) * step(f.yzx, f); \n    f.xy = f.x > .5 ? rp.yz / rp.x : f.y > .5 ? rp.xz / rp.y : rp.xy / rp.z; \n    return tex(f.xy);\n}\n\n//IQ Box, Sphere and DE functions\nvec3 boxIntersection(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n    float edge = 0.0;\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if( tN > tF || tF < 0.0) return vec3(-1.0); // no intersection\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    edge = fizz(ro + rd * tN, boxSize);\n    return vec3(tN, tF, edge);\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nstruct Scene {\n    float t;\n    float id;\n    vec3 n;\n    float edge;\n};\n    \nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n    \n    vec3 pc = vec3(0.0);\n    \n    vec3 rp = ro + rd * scene.t;\n    vec3 ld = normalize(lp - rp);\n    float lt = length(lp - rp);\n    float diff = max(dot(ld, scene.n), 0.05);\n    float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 32.0);\n    float atten = 1.0 / (1.0 + lt * lt * 0.02);\n    \n    vec2 grid = vec2((rp.x + 2.0) * 0.25, rp.z + 0.5);\n    vec2 cell = floor(grid);\n    vec2 cuv = fract(grid);\n\n    if (scene.id == FLOOR) {\n        \n        pc = vec3(0.3) * diff;\n        pc += vec3(1.0) * spec;\n        pc += (smoothstep(0.01, 0.005, cuv.x) + smoothstep(0.998, 0.999, cuv.x)) * vec3(0.0, 1.0, 0.0);\n        pc += (smoothstep(0.04, 0.01, cuv.y) + smoothstep(0.96, 0.99, cuv.y)) * vec3(0.0, 1.0, 0.0);\n        pc *= atten;\n    \n    } else if (scene.id == BRICK || scene.id == TOWER) {\n        \n        pc = vec3(0.3) * diff;  \n        pc += vec3(1.0) * spec;\n        pc = mix(pc, vec3(0.0, 1.0, 0.0) * scene.edge, 0.5);\n        pc *= atten;\n    }\n    \n    return pc;\n}\n\nScene drawScene(vec3 ro, vec3 rd) {\n\n    float mint = FAR;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n    float edge = 0.0;\n    \n    TX = (floor(T / 50.0) * 50.0) + 10.0;;\n    \n    vec3 fo = vec3(0.0, 0.0, 0.0);\n    vec3 fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0) {\n        mint = ft;\n        minn = fn;\n        id = FLOOR;\n    }\n    \n    vec3 tn = vec3(0.0);\n    vec3 tt = boxIntersection(ro - vec3(TX, 0.0, 1.0), rd, vec3(0.2, 2.5, 0.2), tn);\n    if (tt.x > 0.0 && tt.x < mint) {\n        vec3 tbase = boxIntersection(ro - vec3(TX, 0.0, 1.0), rd, vec3(0.2, 2.0, 0.2), tn);\n        if (tbase.x > 0.0 && tbase.x < mint) {\n            mint = tbase.x;\n            minn = tn;\n            edge = tbase.z;\n            id = TOWER;\n        }\n        vec3 tlight = boxIntersection(ro - vec3(TX, 2.1, 1.0), rd, vec3(0.15, 0.1, 0.15), tn);\n        if (tlight.x > 0.0 && tlight.x < mint) {\n            mint = tlight.x;\n            minn = tn;\n            id = LIGHT3;\n        }\n        vec3 troof = boxIntersection(ro - vec3(TX, 2.25, 1.0), rd, vec3(0.2, 0.1, 0.2), tn);\n        if (troof.x > 0.0 && troof.x < mint) {\n            mint = troof.x;\n            minn = tn;\n            edge = troof.z;\n            id = TOWER;\n        }        \n    }\n    \n    //vec3 bn = vec3(0.);\n    //vec3 bounds = boxIntersection(ro - vec3(T, 0.0, 1.0), rd, vec3(50.0, 1.3, 0.8), bn);\n    //if (bounds.x > 0.0) {\n        \n        float steps = 10.0;\n        float wmin = T - steps * STEP_SIZE;\n        wmin -= mod(wmin , STEP_SIZE);\n\n        for (float i = 0.0; i < steps + 4.0 * STEP_SIZE; i += 1.0) {\n            float xidx = wmin + i * STEP_SIZE;\n\n            float r = rand(vec2(xidx, 0.0));\n            vec3 bn;\n            float bh = 1.0 - r * 1.5;\n            if (bh > 0.0) {\n                vec3 box = boxIntersection(ro - vec3(xidx, 0.0, 0.0), \n                                           rd, \n                                           vec3(1.95, bh, 0.45), \n                                           bn);\n                if (box.x > 0.0 && box.x < mint) {\n                    mint = box.x;\n                    minn = bn;\n                    edge = box.z;\n                    id = BRICK;\n                }  \n            }\n\n            r = rand(vec2(xidx, 2.0));\n            bh = 1.0 - r * 1.2;\n            if (bh > 0.0) {\n                vec3 box = boxIntersection(ro - vec3(xidx, 0.0, 2.0), \n                                           rd, \n                                           vec3(1.95, bh, 0.45), \n                                           bn);\n                if (box.x > 0.0 && box.x < mint) {\n                    mint = box.x;\n                    minn = bn;\n                    edge = box.z;\n                    id = BRICK;\n                }  \n            }\n        }\n    //}\n    \n    return Scene(mint, id, minn, edge);\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(T, 0.0, 0.0);\n    lp = lookAt + vec3(4.0, 4.0, -2.0);\n    ro = lookAt + vec3(3.0 - sin(T * 0.1) * 2.0, 4.0, -4.0);\n    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        \n        vec3 oc = colourScene(ro, rd, scene);\n        \n        if (scene.id == 1.0) {\n            vec3 rp = ro + rd * (scene.t - EPS);\n            vec3 rrd = reflect(rd, scene.n);\n            Scene reflectedScene = drawScene(rp, rrd);\n\n            if (reflectedScene.t > 0.0 && reflectedScene.t < FAR) {\n                vec3 rc = colourScene(ro, rd, reflectedScene);\n                float atten = 1.0 / (1.0 + reflectedScene.t * reflectedScene.t * 2.2);\n                oc += rc * atten;\n            }\n        }\n        \n        pc = oc;\n    }\n    \n    vec3 bc = texture(iChannel0, uv).xyz;\n    \n\tfragColor = vec4(pc + bc, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime * 4.0\n#define PI 3.14159265359\n#define FAR 100.0 \n#define EPS 0.001\n#define STEP_SIZE 4.0\n#define FLOOR 1.0\n#define BRICK 2.0\n#define TOWER 3.0\n#define LIGHT1 4.0\n#define LIGHT2 5.0\n#define LIGHT3 6.0\n\nfloat SX1 = 0.0;\nfloat SX2 = 0.0;\nfloat TX = 0.0;\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nfloat rand(vec2 p) {return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453);}\n\n//IQ Box, Sphere and DE functions\nvec3 boxIntersection(vec3 ro, vec3 rd, vec3 boxSize, out vec3 outNormal) {\n    float edge = 0.0;\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if( tN > tF || tF < 0.0) return vec3(-1.0); // no intersection\n    outNormal = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return vec3(tN, tF, edge);\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nstruct Scene {\n    float t;\n    float id;\n    vec3 n;\n    float edge;\n};\n    \nvec3 colourScene(vec3 ro, vec3 rd, Scene scene) {\n    \n    vec3 pc = vec3(0.0);\n    \n    vec3 rp = ro + rd * scene.t;\n    \n    if (scene.id == LIGHT1) {\n        if (rp.x < SX1) {\n            pc = vec3(0.0, 1.0, 0.0);    \n        }\n    } else if (scene.id == LIGHT2) {\n        if (rp.x < SX2) {\n            pc = vec3(0.0, 1.0, 0.0);    \n        }\n    } else if (scene.id == LIGHT3) {\n        pc = vec3(0.0, 1.0, 0.0);    \n    }\n    \n    return pc;\n}\n\nScene drawScene(vec3 ro, vec3 rd) {\n\n    float mint = FAR;\n    vec3 minn = vec3(0.0);\n    float id = 0.0;\n    float edge = 0.0;\n    \n    SX1 = T + sin(T * 0.1) * 2.0;\n    SX2 = T + cos(T * 0.2) * 3.0;\n    TX = (floor(T / 50.0) * 50.0) + 10.0;;\n    \n    vec3 fo = vec3(0.0, 0.0, 0.0);\n    vec3 fn = vec3(0.0, 1.0, 0.0);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0.0) {\n        mint = ft;\n        minn = fn;\n        id = FLOOR;\n    }\n    \n    vec3 tn = vec3(0.0);\n    vec3 tt = boxIntersection(ro - vec3(TX, 0.0, 1.0), rd, vec3(0.2, 2.5, 0.2), tn);\n    if (tt.x > 0.0 && tt.x < mint) {\n        vec3 tbase = boxIntersection(ro - vec3(TX, 0.0, 1.0), rd, vec3(0.2, 2.0, 0.2), tn);\n        if (tbase.x > 0.0 && tbase.x < mint) {\n            mint = tbase.x;\n            minn = tn;\n            edge = tbase.z;\n            id = TOWER;\n        }\n        vec3 tlight = boxIntersection(ro - vec3(TX, 2.1, 1.0), rd, vec3(0.15, 0.1, 0.15), tn);\n        if (tlight.x > 0.0 && tlight.x < mint) {\n            mint = tlight.x;\n            minn = tn;\n            id = LIGHT3;\n        }\n        vec3 troof = boxIntersection(ro - vec3(TX, 2.25, 1.0), rd, vec3(0.2, 0.1, 0.2), tn);\n        if (troof.x > 0.0 && troof.x < mint) {\n            mint = troof.x;\n            minn = tn;\n            edge = troof.z;\n            id = TOWER;\n        }        \n    }\n    \n    //vec3 bn = vec3(0.);\n    //vec3 bounds = boxIntersection(ro - vec3(T, 0.0, 1.0), rd, vec3(50.0, 1.3, 0.8), bn);\n    //if (bounds.x > 0.0) {\n    \n        float steps = 10.0;\n        float wmin = T - steps * STEP_SIZE;\n        wmin -= mod(wmin , STEP_SIZE);\n\n        for (float i = 0.0; i < steps + 4.0 * STEP_SIZE; i += 1.0) {\n            float xidx = wmin + i * STEP_SIZE;\n\n            float r = rand(vec2(xidx, 0.0));\n            vec3 bn;\n            float bh = 1.0 - r * 1.5;\n            if (bh > 0.0) {\n                vec3 box = boxIntersection(ro - vec3(xidx, 0.0, 0.0), \n                                           rd, \n                                           vec3(1.95, bh, 0.45), \n                                           bn);\n                if (box.x > 0.0 && box.x < mint) {\n                    mint = box.x;\n                    minn = bn;\n                    edge = box.z;\n                    id = BRICK;\n                }  \n            }\n            vec3 box = boxIntersection(ro - vec3(xidx, 0.0, 0.0), \n                                       rd, \n                                       vec3(2.0, max(bh + 0.05, 0.05), 0.05), \n                                       bn);\n            if (box.x > 0.0 && box.x < mint) {\n                mint = box.x;\n                minn = bn;\n                edge = box.z;\n                id = LIGHT1;\n            }\n\n            r = rand(vec2(xidx, 2.0));\n            bh = 1.0 - r * 1.2;\n            if (bh > 0.0) {\n                vec3 box = boxIntersection(ro - vec3(xidx, 0.0, 2.0), \n                                           rd, \n                                           vec3(1.95, bh, 0.45), \n                                           bn);\n                if (box.x > 0.0 && box.x < mint) {\n                    mint = box.x;\n                    minn = bn;\n                    edge = box.z;\n                    id = BRICK;\n                }  \n            }\n            box = boxIntersection(ro - vec3(xidx, 0.0, 2.0), \n                                       rd, \n                                       vec3(2.0, max(bh + 0.05, 0.05), 0.05), \n                                       bn);\n            if (box.x > 0.0 && box.x < mint) {\n                mint = box.x;\n                minn = bn;\n                edge = box.z;\n                id = LIGHT2;\n            }\n        }\n    //}    \n    \n    return Scene(mint, id, minn, edge);\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(T, 0.0, 0.0);\n    ro = lookAt + vec3(3.0 - sin(T * 0.1) * 2.0, 4.0, -4.0);\n\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec3 pc = vec3(0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 ro, rd;\n    setupCamera(fragCoord, ro, rd);\n    \n    Scene scene = drawScene(ro, rd);\n    if (scene.t > 0.0 && scene.t < FAR) {\n        \n        vec3 oc = colourScene(ro, rd, scene);\n        \n        vec3 rp = ro + rd * (scene.t - EPS);\n        vec3 rrd = reflect(rd, scene.n);\n        Scene reflectedScene = drawScene(rp, rrd);\n        if (reflectedScene.t > 0.0 && reflectedScene.t < FAR) {\n            vec3 rc = colourScene(rp, rrd, reflectedScene);\n            float atten = 1.0 / (1.0 + reflectedScene.t * reflectedScene.t * 6.2);\n            oc += rc * atten;\n        }\n        \n        pc = oc;\n        pc /= scene.t * 0.1; \n    }\n    \n\tfragColor = vec4(pc, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}