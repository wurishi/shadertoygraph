{"ver":"0.1","info":{"id":"fssyWS","date":"1642790713","viewed":108,"name":"2D Interactive Scene","username":"Rebenn_","description":"W = Zoom in  |  S = Zoom out  |  Z =  Checkerboard  |  X = Marble  |  C = Rusty Chrome\n\nI tried to develop on the lab Color-cube and add in interactive elements, camera zoom ins and outs, changing the cube on key presses, distorting and moving screen.","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// colorcube evolved - make sure there is a cube map in channel 0\n//\n\nconst int shuffle[256] = int[256]\n(206,21,27,124,238,156,174,113,170,81,237,12,22,241,23,141,10,167,146,114,\n 162,9,13,5,139,216,91,65,6,189,221,86,7,187,212,166,67,149,131,98,126,1,\n 137,54,8,70,110,148,46,151,106,89,121,236,101,227,49,72,255,239,3,73,244,169,\n 157,96,175,75,77,205,160,30,36,178,112,88,154,228,104,68,185,43,184,182,14,163,\n 233,18,180,45,83,186,59,25,129,111,74,215,122,218,144,44,100,161,53,254,55,92,\n 35,145,220,119,195,66,130,150,140,181,57,56,84,207,245,231,191,248,61,52,118,168,\n 226,223,40,197,116,58,232,243,214,204,33,28,105,202,24,152,133,51,196,210,115,\n 190,97,147,143,132,50,94,165,109,198,39,134,120,2,85,128,135,20,79,123,90,222,\n 26,155,82,252,136,76,217,32,240,63,38,159,247,37,176,78,234,42,219,209,0,103,\n 64,99,15,95,242,47,11,246,211,199,17,62,29,192,69,183,200,34,225,138,224,127,\n 235,229,117,253,71,108,87,201,208,171,203,41,173,102,125,213,107,179,250,80,16,\n 4,153,142,251,31,172,164,188,249,93,60,230,194,177,193,48,158,19);    \n\nconst vec3 gradients[16] = vec3[16](\nvec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\nvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\nvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1),\nvec3(1,1,0),vec3(-1,1,0),vec3(0,-1,1),vec3(0,-1,-1));\n\nint Hash( in int i, in int j, in int k )\n{\n    return shuffle[(shuffle[(shuffle[i%256] + j)%256] + k)%256]%16;\n}\n\nvec3 Gradient( int i, int j, int k )\n{\n\treturn gradients[Hash(i,j,k)];\n}\n\nvec3 PositionVector( int i, int j, int k, vec3 pos )\n{\n\treturn (pos-vec3(i,j,k));\n}\n\nfloat Smoothstep( float f0, float f1, float x )\n{\n\tx = max(x, 0.0);\n\tx = min(x, 1.0);\n\tx = 3.0*x*x - 2.0*x*x*x;\n\treturn f0*(1.0f-x) + f1*x;\n}\n\n\nfloat PerlinNoise( vec3 pos, float iScale )\n{\n\tfloat noiseVals[8];\n\tpos = (pos + vec3(100,100,100))*iScale; // offset of 100 is to make sure it is in the positive quadrant\n\t// get the indices of the cube this vert is in\n\tint i = int( pos.x );\n\tint j = int( pos.y );\n\tint k = int( pos.z );\n\t// get the noise values at the vertices of the cube\n\tnoiseVals[0] = dot( Gradient(i,j,k),       PositionVector(i,j,k,pos) );\n\tnoiseVals[1] = dot( Gradient(i+1,j,k),     PositionVector(i+1,j,k,pos) );\n\tnoiseVals[2] = dot( Gradient(i+1,j,k+1),   PositionVector(i+1,j,k+1,pos) );\n\tnoiseVals[3] = dot( Gradient(i,j,k+1),     PositionVector(i,j,k+1,pos) );\n\tnoiseVals[4] = dot( Gradient(i,j+1,k),     PositionVector(i,j+1,k,pos) );\n\tnoiseVals[5] = dot( Gradient(i+1,j+1,k),   PositionVector(i+1,j+1,k,pos) );\n\tnoiseVals[6] = dot( Gradient(i+1,j+1,k+1), PositionVector(i+1,j+1,k+1,pos) );\n\tnoiseVals[7] = dot( Gradient(i,j+1,k+1),   PositionVector(i,j+1,k+1,pos) );\n\t// now do the interpolation\n\n\t// interpolation parameters tx, ty, tz\n\tvec3 t = pos - vec3(i,j,k);\n\n\tfloat ft, fb;\n\tfloat fy0, fy1;\n\t// bottom xz plane\n\tft = Smoothstep( noiseVals[3], noiseVals[2], t.x);\n\tfb = Smoothstep( noiseVals[0], noiseVals[1], t.x);\n\tfy0 = Smoothstep( fb, ft, t.z); \n\t// top xz plane\n\tft = Smoothstep( noiseVals[7], noiseVals[6], t.x);\n\tfb = Smoothstep( noiseVals[4], noiseVals[5], t.x);\n\tfy1 = Smoothstep( fb, ft, t.z); \n\t// y interpolation\n\treturn Smoothstep(fy0, fy1, t.y);\n}\n\nfloat ScaledNoise( vec3 pos, float iScale )\n{\n\treturn (1.0f + PerlinNoise( pos, iScale))*0.5f;\n}\n\nfloat FractalNoise( vec3 pos, float iScale, float mult, int numOctaves)\n{\n    float fac = 1.0f;\n    float noise = ScaledNoise(pos, iScale);\n    for ( int i = 0; i < numOctaves-1; i++ )\n    {\n    \tfac *= mult;\n        iScale *= 2.0;\n        noise += fac*ScaledNoise(pos, iScale);\n    }\n    return noise;\n}\n\n//---------------------------------------------------- ^^^^ Noise Functions ^^^^ ----------------------------------------------------------//\n\n\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n\n\n//---------------------------------------------------- vvvv Ripple Functions vvvv ---------------------------------------------------------//\n\nvec3 RippleNorm( in float x, in float z, in float time )\n{\n    float dx = -2.0*cos(3.0*x + 2.0*z + 3.0*time) + 3.0*cos(-1.0*x + 3.0*z + 4.0*time) - 2.0*cos(2.0*x -2.0*z + 5.0*time)\n        -0.5*cos(-2.0*x -0.5*z + 2.0*time); \n        \n    float dz = 3.0*cos(3.0*x + 2.0*z + 3.0*time) - cos(-1.0*x + 3.0*z + 4.0*time) + 2.0*cos(2.0*x -2.0*z + 5.0*time)\n        -2.0*cos(-2.0*x -0.5*z + 2.0*time);\n    return normalize(vec3(0.01*dx,1,0.01*dz));\n}\n\nfloat Ripple( in float x, in float z, in float time )\n{\n    return sin(3.0*x + 2.0*z + 3.0*time) + sin(-1.0*x + 3.0*z + 4.0*time) + sin(2.0*x -2.0*z + 5.0*time)\n        +sin(-2.0*x -0.5*z + 2.0*time);\n   \n}\n\n//---------------------------------------------------- ^^^^ Ripple Functions ^^^^ ---------------------------------------------------------//\n\n\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n\n\nbool RayCastPlane( in vec3 rayStart, in vec3 rayDir, in vec3 planePos, in vec3 planeNormal, out vec3 hitPos )\n{\n    float dp = dot(rayDir, planeNormal);\n    if ( dp >= 0.0 )\n        return false;\n    float hitU = dot(planePos-rayStart,planeNormal)/dp;\n    if ( hitU < 0.0 )\n        return false;\n    hitPos = rayStart + rayDir*hitU;\n    return true;\n}\n\nbool RayCubeIntersect(in vec3 rayPos, in vec3 rayDir, in vec3 cubePos, in mat3 cubeRot, in vec3 cubeScale,\n                     out vec3 hitPos, out vec3 hitNorm, out vec3 hitPosLocal)\n{\n    // rp, np define the six planes of the unit cube\n    const vec3 rp[6] = vec3[6](vec3(-1,-1,-1),vec3(-1,-1,-1),vec3(-1,-1,-1),\n                               vec3(1,1,1),vec3(1,1,1),vec3(1,1,1));\n    const vec3 np[6] = vec3[6](vec3(-1,0,0), vec3(0,-1,0), vec3(0,0,-1), vec3(1,0,0), vec3(0,1,0), vec3(0,0,1));\n    \n    // transformed versions\n    vec3 rpt[6], npt[6];\n    for ( int i = 0; i < 6; i++ )\n    {\n        rpt[i] = cubePos + cubeRot*(rp[i]*cubeScale);\n        npt[i] = cubeRot*np[i];\n    }\n    for ( int i = 0; i < 6; i++ )\n    {\n    \tfloat dp = dot(npt[i], rayDir);\n        if ( dp < 0.0f )\n        {\n            // not a back-face\n            float uHit = dot(rpt[i]-rayPos,npt[i])/dp;\n            if ( uHit > 0.0f )\n            {\n                // check this is actually a hit\n                hitPos = rayPos + rayDir*uHit;\n                bool allIn = true;\n                for ( int j = 0; j < 6; j++ )\n                {\n                    if ( i != j && dot(hitPos-rpt[j],npt[j]) > 0.0f )\n                    {\n                        allIn = false;\n                        break;\n                    }\n                }\n                if (allIn)\n                {\n                    hitNorm = npt[i];\n                    // hit position in local coords\n                    hitPosLocal = hitPos - cubePos;\n                    // transpose of a rotation matrix is its inverse\n                    hitPosLocal = transpose(cubeRot)*hitPosLocal;\n                    hitPosLocal = hitPosLocal/cubeScale;\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nmat3 rotMatrix( in vec3 about, in float angle )\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    float t = 1.0-c;\n    float x = about.x; \n    float y = about.y;\n    float z = about.z;\n    \n    mat3 rotMat;\n    rotMat[0] = vec3( t*x*x+c, t*x*y - z*s, t*x*z + y*s );\n    rotMat[1] = vec3( t*x*y + z*s, t*y*y + c, t*y*z - x*s);\n    rotMat[2] = vec3( t*x*z - y*s, t*y*z + x*s, t*z*z + c);\n    return rotMat;\n}\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n\n\n//------------------------------------------------------- vvvv Cube variations vvvv -------------------------------------------------------//\n\nvec4 proctexcolorcube( vec3 pos )\n{\n    return vec4( pos+0.5, 1.0);\n}\n\nvec4 proctexchecker( vec3 pos )\n{\n    pos += vec3 (1.001,1.001,1.001);\n    pos *= 3.0;\n    bool bx = fract(pos.x) < 0.5;\n    bool by = fract(pos.y) < 0.5;\n    bool bz = fract(pos.z) < 0.5;\n    \n    if( (bx^^by) ^^bz)\n        return vec4(1,1,1,1);\n    else\n        return vec4(0,0,0,1);\n}\n\n \nvec4 proctexmarble( vec3 pos )\n{\n    float A = 2.0;\n    float B = 3.0;\n    float scale = 1.0;\n    float x = 1.0 + sin(pos.y*A + FractalNoise(pos, scale, 0.5, 5)*B) *0.5;\n    vec4 color1 = vec4(1,2,5,0);\n    vec4 color2 = vec4(1,1,5,1);\n    return color1 * x + color2 * (1.0 - x);\n}\n\nvoid rustychrome( in vec3 pos, out vec4 color, out float reflectance )\n{\n    float noise0 = 0.5*FractalNoise(pos,1.0,0.5,5);\n    \n    if( noise0 < 0.5)\n    {\n        reflectance = 1.0;\n    }\n    else\n    {\n        reflectance = 0.0;\n        color = vec4(0,2,2.5,1);\n    }\n}\n\n//------------------------------------------------------- ^^^^ Cube variations ^^^^ -------------------------------------------------------//\n\n\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n\n\n//---------------------------------------------------- vvvv Scene Functions vvvv ---------------------------------------------------------//\n\nvec4 ColorCube( in vec3 r, in vec3 n, in float iTime )\n{\n    vec3 cubePos = vec3(0,1.7,4);\n    mat3 cubeRot = rotMatrix(normalize(vec3(0,1,1)), iTime);\n    vec3 cubeScale = vec3(1,1,1);\n\n    vec3 hitPos, hitNorm, hitPosLocal;\n    bool hit = RayCubeIntersect(r,n,cubePos,cubeRot,cubeScale,hitPos,hitNorm,hitPosLocal);\n\n    // Output to screen\n\tvec4 outColor;\n    if ( hit )\n    {\n        float light = 0.3 + 0.7*max(hitNorm.y,0.0);\n        vec4 baseColor = proctexcolorcube(hitPosLocal);\n        outColor = baseColor*light + 0.2*texture(iChannel0, reflect(n,hitNorm));\n    }\n\telse\n\t    outColor = texture(iChannel0, n);\n    return outColor;    \n}\n\nvec4 CheckerboardCube( in vec3 r, in vec3 n, in float iTime )\n{\n    vec3 cubePos = vec3(0,1.7,4);\n    mat3 cubeRot = rotMatrix(normalize(vec3(0,1,1)), iTime);\n    vec3 cubeScale = vec3(1,1,1);\n\n    vec3 hitPos, hitNorm, hitPosLocal;\n    bool hit = RayCubeIntersect(r,n,cubePos,cubeRot,cubeScale,hitPos,hitNorm,hitPosLocal);\n\n    // Output to screen\n\tvec4 outColor;\n    if ( hit )\n    {\n        float light = 0.3 + 0.7*max(hitNorm.y,0.0);\n        vec4 baseColor = proctexchecker(hitPosLocal);\n        outColor = baseColor*light + 0.2*texture(iChannel0, reflect(n,hitNorm));\n    }\n\telse\n\t    outColor = texture(iChannel0, n);\n    return outColor;    \n}\n\nvec4 MarbleCube( in vec3 r, in vec3 n, in float iTime )\n{\n    vec3 cubePos = vec3(0,1.7,4);\n    mat3 cubeRot = rotMatrix(normalize(vec3(0,1,1)), iTime);\n    vec3 cubeScale = vec3(1,1,1);\n\n    vec3 hitPos, hitNorm, hitPosLocal;\n    bool hit = RayCubeIntersect(r,n,cubePos,cubeRot,cubeScale,hitPos,hitNorm,hitPosLocal);\n\n    // Output to screen\n\tvec4 outColor;\n    if ( hit )\n    {\n        float light = 0.3 + 0.7*max(hitNorm.y,0.0);\n        vec4 baseColor = proctexmarble(hitPosLocal);\n        outColor = baseColor*light + 0.5*texture(iChannel0, reflect(n,hitNorm));\n    }\n\telse\n\t    outColor = texture(iChannel0, n);\n    return outColor;    \n}\n\nvec4 ChromeCube( in vec3 r, in vec3 n, in float iTime )\n{\n    vec3 cubePos = vec3(0,1.7,4);\n    mat3 cubeRot = rotMatrix(normalize(vec3(0,1,1)), iTime);\n    vec3 cubeScale = vec3(1,1,1);\n\n    vec3 hitPos, hitNorm, hitPosLocal;\n    bool hit = RayCubeIntersect(r,n,cubePos,cubeRot,cubeScale,hitPos,hitNorm,hitPosLocal);\n\n    // Output to screen\n\tvec4 outColor;\n    if ( hit )\n    {\n        float light = 0.3 + 0.7*max(hitNorm.y,0.0);\n        /*vec4 baseColor = proctexmarble(hitPosLocal);\n        outColor = baseColor*light + 0.2*texture(iChannel0, reflect(n,hitNorm));*/\n        vec4 baseColor;\n        float reflectance;\n        rustychrome( hitPosLocal, baseColor, reflectance );\n        outColor = baseColor*light*(1.0-reflectance) + reflectance*texture(iChannel0, reflect(n,hitNorm));\n    }\n\telse\n\t    outColor = texture(iChannel0, n);\n    return outColor;    \n}\n//---------------------------------------------------- ^^^^ Scene Functions ^^^^ ---------------------------------------------------------//\n\n\n\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n\n\n\n//-------------------------------------------- Keyboard Input: shadertoy.com/view/XlGfzt --------------------------------------------------//\n\n\nbool isPressed(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.25);\n        float key = texture(iChannel3, uv).r;\n\n        return key > 0.0;\n}\n\nbool isToggled(float keyCode) {\n        keyCode = (keyCode + 0.5) / 256.0;\n        vec2 uv = vec2(keyCode, 0.75);\n        float key = texture(iChannel3, uv).r;\n\n        return key > 0.0;\n}\n\n#define KEY_W 87.0\n#define KEY_S 83.0\n\n#define KEY_Z 90.0\n#define KEY_X 88.0\n#define KEY_C 67.0\n\n\n//---------------------------------------- ^^^^ Keyboard Input: shadertoy.com/view/XlGfzt ^^^^ --------------------------------------------//\n\n\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n//-----------------------------------------------------------------------------------------------------------------------------------------//\n\n\n//------------------------------------------------------------- Main ----------------------------------------------------------------------//\n\n\n vec3 camPos = vec3(0,0,-0.2);\n vec3 camPos2 = vec3(0,0,-0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= vec2(0.5,0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    vec4 m = iMouse / iResolution.x; // Mouse Input - https://www.shadertoy.com/view/Mss3zH\n    \n    if (isPressed(KEY_W)) \n    {\n        float fac = pow(2.0,-iTime*0.25); // Zooms in\n        uv *= fac;\n        uv -= vec2(0,-0.0375);\n    }\n   \n    if (isPressed(KEY_S)) \n    {\n        float fac = pow(2.0,iTime*0.25); // Zooms out\n        uv *= fac;\n        uv -= vec2(0,-0.0375);        \n    }\n  \n    \n    vec3 r = camPos;\n    vec3 r2 = camPos2;\n    vec3 n = normalize(vec3(uv,0)-camPos);\n\tvec3 hitPos;\n\n    bool hit = RayCastPlane( r, n, vec3(0,-1,0), vec3(0,1,0),hitPos);\n    bool mousePressed = m.z > 0.0; // Button is held down\n    bool mouseClicked = m.w > 0.0; // Button is just clicked \n    \n    if ( hit )\n    {\n\t\tvec3 norm = RippleNorm(hitPos.x, hitPos.z, iTime);\n       \tn = reflect(n,norm);\n        r = hitPos * 0.7;\n    }\n\n\tfragColor = ColorCube(r2, n, iTime);\n   \n\n    if(mousePressed) \n    {\n        vec3 norm = RippleNorm(hitPos.x, hitPos.z, iTime) ;\n        n = reflect(n,norm*0.5) * iTime;\n        r = hitPos += iTime;\n    }\n    \n    if (isPressed(KEY_Z)) \n    {\n        fragColor = CheckerboardCube(r2, n, iTime);\n    }\n    \n    if (isPressed(KEY_X)) \n    {\n        fragColor = MarbleCube(r2, n, iTime);\n    }\n    \n    if (isPressed(KEY_C)) \n    {\n        fragColor = ChromeCube(r2, n, iTime);\n    }\n}","name":"Image","description":"","type":"image"}]}