{"ver":"0.1","info":{"id":"wtsyRX","date":"1604395982","viewed":128,"name":"Reflections + Bump Mapping","username":"omegasbk","description":"Playing with reflections and simple bump mapping","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["reflection","bumpmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Darko (omegasbk) \n//\n// Darko's Gamedev Cookbok Youtube serial\n// https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA\n\n\n#define M_PI 3.1415926535897932384626433832795\n\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom; \n} camera;\n\nstruct Sphere\n{\n    vec3 color;\n    vec3 position;\n    float radius;     \n};\n\nstruct DirectionalLight\n{\n\tvec3 direction;    \n} directionalLight;\n\nstruct PointLight\n{\n    float intensity;\n    vec3 position;\n} pointLight;\n\nstruct Material \n{\n    float diffuse;\n    float specular;\n    float shininess;\n    float ambience;\n    float reflection;\n} materials[2];\n\nSphere spheres[2];\n\nvoid setupScene()\n{\n    camera.position = vec3(0., .0, 5.);\n    camera.direction = vec3(0., 0., -1.);\n    camera.zoom = 2.1;\n    \n    spheres[0].position = vec3(-0.6, 0., 0.3);\n    spheres[0].radius = 0.5;\n    spheres[0].color = vec3(0.6, 0.6, 0.9);\n    \n    spheres[1].position = vec3(0.6, 0., 0.);\n    spheres[1].radius = 0.5;\n    spheres[1].color = vec3(0.7, 0.7, 0.7);\n    \n    directionalLight.direction = normalize(vec3(0., -1., -0.78));\n    \n    materials[0].ambience = 0.2;\n    materials[0].diffuse = 0.7;\n    materials[0].specular = 0.2;\n    materials[0].shininess = 2.0; \n    materials[0].reflection = 1.; \n\n    \n    materials[1].ambience = 0.2;\n    materials[1].diffuse = 0.7;\n    materials[1].specular = 0.6;\n    materials[1].shininess = 14.0; \n    materials[1].reflection = 1.; \n\n    \n    pointLight.intensity = 0.4;\n    pointLight.position = vec3(0., 0.4, 0.5);\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nfloat getTexturedNormal(vec3 surfaceVector) \n{     \n    float depth = 0.005;\n    vec3 surfaceNormal = normalize(-surfaceVector);        \n   \n    vec2 uv = vec2((atan(surfaceNormal.z, surfaceNormal.x) / M_PI + 1.0) * 0.5,\n                   (asin(surfaceNormal.y) / M_PI + 0.5));  \n      \n    float d = texture(iChannel2,uv).b * depth;\n    \n    float distance = length(surfaceVector) - (1. + d);\n    distance = min(distance, surfaceVector.y + 1.);\n    \n    return distance;   \n}\n\nvec3 calcTexturedNormal(vec3 surfaceNormal) \n{ \n    vec2 depth = vec2(.01,0.);\n    \n    vec3 n   = vec3(getTexturedNormal(surfaceNormal+depth.xyy)-getTexturedNormal(surfaceNormal-depth.xyy),\n                    getTexturedNormal(surfaceNormal+depth.yxy)-getTexturedNormal(surfaceNormal-depth.yxy),\n                    getTexturedNormal(surfaceNormal+depth.yyx)-getTexturedNormal(surfaceNormal-depth.yyx));\n    \n    return normalize(n);\n}\n\nbool intersect(\n    vec3 origin, vec3 direction, Sphere sphere, \n    out float dist, out vec3 surfaceNormal, out vec3 Phit)\n{\n    vec3 L = origin - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        float t = t0;\n        if (t1 < t0)\n        {\n            t = t1;\n        }\n        \n        dist = t;\n        \n        Phit = origin + dist * direction;\n        surfaceNormal = normalize(Phit - sphere.position);\n        \n        surfaceNormal = calcTexturedNormal(surfaceNormal);\n\n        \n        return true;\n    }  \n     \n    return false;\n}\n\nvec3 calculateLitColor(Sphere sphere, vec3 surfaceNormal, Material material)\n{\n    vec3 lightDir = normalize(sphere.position - pointLight.position);\n    \n    \n    float coeff = -dot(lightDir, surfaceNormal);                          \n\n    vec3 ambient = material.ambience * sphere.color;\n    vec3 diffuse = material.diffuse * max(coeff, 0.) * sphere.color;\n\n    float shininess = pow(max(-dot(lightDir, reflect(lightDir, surfaceNormal)), 0.), material.shininess);\n    vec3 specular = material.specular * shininess * sphere.color;\n\n    vec3 color = ambient + diffuse + specular;\n    return color;\n}\n\nvec3 rayTrace(vec3 direction)\n{\n    vec3 surfaceNormal;\n    float dist = 0.;\n    float minDist = 1. / 0.; // Infinity \n    vec3 PHit;\n    bool hit = false;\n    \n    vec3 color = texture(iChannel0, direction).xyz;\n    \n    for(int i=0;i<2;++i)\n\t{\n        if (intersect(camera.position, direction, spheres[i], dist, surfaceNormal, PHit)) // Sphere is visible\n        {\n            hit = true;\n            \n            if (dist < minDist)\n                minDist = dist;\n            else \n                continue;\n                        \n            color = calculateLitColor(spheres[i], surfaceNormal, materials[i]);\n            \n            float distRefl = 0.;\n            float minDistRefl = 1. / 0.; // Infinity \n            vec3 surfaceNormalRefl;\n            vec3 PHitRefl;\n            vec3 colorRefl = color;\n            \n            // Reflection\n            vec3 reflectedBeam = reflect(direction, surfaceNormal);\n\n            for (int j=0; j < 2; ++j)\n            {\n                if (i == j) \n                    continue;\n                \n                if (distRefl < minDistRefl)\n                \tminDistRefl = distRefl;\n                else \n                    continue;\n                \n                \n                if (intersect(PHit, reflectedBeam, spheres[j], distRefl, surfaceNormalRefl, PHitRefl)\n                   && distRefl > 0.)\n                {          \n                    colorRefl = calculateLitColor(spheres[j], surfaceNormalRefl, materials[j]);\n                }\n                else\n                {\n                    colorRefl = texture(iChannel0, reflectedBeam).xyz;\n                }\n            }\n            \n            \n            vec2 uv = vec2((atan(surfaceNormal.z, surfaceNormal.x) / M_PI + 1.0) * 0.5,\n                           (asin(surfaceNormal.y) / M_PI + 0.5)); \n            \n            //color = mix(color, colorRefl, materials[i].specular * materials[i].reflection /** pow(materials[i].specular, materials[i].shininess)*/);\n            color = color * materials[i].diffuse + texture(iChannel2, uv).b * 2. * colorRefl * materials[i].specular;\n            \n        }\n    } \n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{        \n    setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n        \n    camera.position.x = cos(iTime) * 4.;\n    camera.position.z = sin(iTime) * 4.;\n    \n    // Camera movement\n    float rotation = iTime;\n    camera.position = vec3(cos(rotation), 0., sin(rotation)) * camera.zoom;\n    camera.direction = normalize(vec3(0.) - camera.position);\n    vec3 right = normalize(cross(camera.direction, vec3(0., 1., 0.)));\n    vec3 up = cross(right, camera.direction);\n   \tvec3 dir =  normalize(uv.x * right + uv.y * up + camera.direction);\n                     \n                     \n    //spheres[0].position.z = sin(iTime * 6.) / 3.;\n    //spheres[1].position.z = cos(iTime * 6.) / 3.;\n\n    \n    \n    pointLight.position.x = iMouse.x * 10. / iResolution.x - 5.;\n    pointLight.position.y = iMouse.y  * 10. / iResolution.y - 5.;\n    \n    \n    vec3 col = rayTrace(dir);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}