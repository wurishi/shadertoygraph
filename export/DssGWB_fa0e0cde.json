{"ver":"0.1","info":{"id":"DssGWB","date":"1666917433","viewed":106,"name":"JFA Vornoi","username":"inzombiak","description":"Combined \nhttps://www.shadertoy.com/view/NtB3Ry\nand\nhttps://www.shadertoy.com/view/MstBWX#\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["vornoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 seedCoord;\n    vec3 seedColor;\n    \n    vec4 read = texture(iChannel0, uv);\n    fragColor = read;\n   DecodeData(read, seedCoord, seedColor);\n    \n    float distSeed = distance(fragCoord, seedCoord);\n    float marker = (distSeed < 10.)?\n        \t\t\t2.:\n    \t\t\t\t1.;\n    \n    // Output to screen\n    fragColor = vec4(seedColor\n                     *marker\n                     *distSeed/100.\n                     , 1.);\n    \n    //fragColor = .01*vec4(seedCoord-fragCoord, vec2(0.));\n    //fragColor = vec4(seedColor, 1.0);\n    //fragColor = read;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Recreating Jump flood algorithm for learning purposes\n// Saw in https://www.shadertoy.com/view/Mdy3DK\n\n#define SEED_CHANCE .0005\n//============================================================\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat gerst_rand_util(in float x) {\n    vec2 x2 = vec2(x, x * .997);\n    return fract(sin(dot(x2.xy,\n                         vec2(12.9898,78.233)))* 43758.5453123);\n}\n\n// Putting coordinate encoded in the color\nvec4 EncodeData(vec2 coord, vec3 color)\n{\n\tvec4 ret = vec4(0.);\n\tret.xy = coord;\n    ret.z = floor(color.x * 255.)*256. + floor(color.y * 255.);\n    ret.w = floor(color.z * 255.);\n\treturn ret;\n}\n\n// Getting the coordinate out of the color\nvoid DecodeData(in vec4 data, out vec2 coord, out vec3 color )\n{\n\tcoord = data.xy;\n    color.x = floor(data.z/256.)/255.;\n    color.y = mod(data.z,256.)/255.;\n    color.z = mod(data.w,256.)/255.;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define SEED_FIXED 39.3\n#define SEED_ANIMATED 19.0\n#define SEED SEED_ANIMATED\n\n#define POINT_COUNT 50\n#define VISUALIZE_POINT true\n#define VERY_LARGE_NUMBER 999999999.\n\n\n\n\n\nfloat fit01(float val, float a, float b)\n{\n    return a+val*(b-a);\n}\n\nvec2 fit01(vec2 val, float a, float b)\n{\n    return vec2(fit01(val.x,a,b), fit01(val.y,a,b));\n}\n\n//bad rng..\nfloat r11(float seed)\n{\n    return fract(sin(499.0*seed + 199.0)*5869.0);\n}\n\nvec2 r12(float seed)\n{\n    float x = fract(sin(509.0*seed)*197.0);\n    float y = fract(sin(487.0*seed + 991.0)*991.0);\n    return vec2(x,y);\n}\n\nvec3 r13(float seed)\n{   \n    float x = fract(sin(277.0*seed)*613.0);\n    float y = fract(sin(97.0*seed + 607.0)*394.0);\n    float z = fract(sin(349.0*seed + 431.0)*124.0);\n    return vec3(x,y,z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y;\n    \n    //initialize points\n    vec2 points[POINT_COUNT];\n    for(int i=0; i<POINT_COUNT; i++)\n    {\n        float aspect = iResolution.x/iResolution.y;\n        points[i] = r12(float(i) * SEED);\n        points[i].x = fit01(points[i].x, -aspect,aspect);\n        points[i].y = fit01(points[i].y, -1.0,1.0);\n    }\n    \n    //find closest point\n    float closestPointDistance = VERY_LARGE_NUMBER;\n    int closestPointIndex = 0;\n    for(int i=0; i<POINT_COUNT; i++)\n    {\n        vec2 pPos = points[i];\n        float d = length(pPos - uv);\n        if(d < closestPointDistance)\n        {\n            closestPointDistance = d;\n            closestPointIndex = i;\n        }\n    }\n    \n    //random color for each cell\n    vec3 col = vec3(0.0);\n    //r13(float(closestPointIndex) * SEED);\n    \n        float pointVisualize = 0.;\n\n    if(true)\n    {\n        pointVisualize = 0.;\n        for(int i=0; i<POINT_COUNT; i++)\n        {\n            vec2 pPos = points[i];\n            float d = length(pPos - uv);\n            pointVisualize += smoothstep(0.01,0.009, d);\n        }\n        pointVisualize = round(pointVisualize);\n        col += r13(float(closestPointIndex) * SEED) * pointVisualize;\n    }\n    \n    fragColor = vec4(col,pointVisualize);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define JFA_MAX_STEPS 10\n#define FRAME_DELAY 4.\n\n\n//--------------------------------------------------\n\nvec4 JFAStep(vec2 fragCoord, int level)\n{\n    // current data in texture on fragCoord position\n    vec4 ret = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n    \n    // big number so any real distance will be smaller than that\n    float curDist = 999999999.;\n    \n    // that means the current data contains info of a nearby seed\n    if( ret != vec4(0.) )\n    {\n        vec2 seedCoord;\n\t\tvec3 seedColor;\n        \n        DecodeData(ret, seedCoord, seedColor);\n        \n        curDist = distance(fragCoord, seedCoord);\n    }\n    \n    vec2 offset = vec2(exp2(max(0., float(JFA_MAX_STEPS - level) ) ) );\n    \n    for(int x = -1; x <= 1; x++)\n    {\n    \tfor(int y = -1; y <= 1; y++)\n        {\n\t\t\tvec4 read = texture(iChannel0, (fragCoord + vec2(x,y)*offset)/iResolution.xy );\n            if( read != vec4(0.) )\n            {\n                vec2 coord;\n                vec3 color;\n                \n                DecodeData(read, coord, color);\n                \n                float dist = distance(coord, fragCoord);\n                \n                if( dist < curDist)\n                {\n                    ret = read;\n                }\n            }\n        }\n    }\n    \n    return ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    // Create seeds\n    if(iFrame == 0)\n    {\n        vec4 seed_color = texture(iChannel1, fragCoord/iResolution.xy);\n        if(seed_color.w > 0.0) {\n            fragColor = EncodeData(fragCoord,seed_color.xyz);\n         } else {\n            fragColor = vec4(0.0);\n         }\n    }\n    else\n    {\n        if(mod( float(iFrame), FRAME_DELAY) == 0.)\n        {\n        \tfragColor = JFAStep(fragCoord, iFrame);\n            \n        }\n        else\n        {\n    \n        \tfragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}