{"ver":"0.1","info":{"id":"WslGWj","date":"1547532779","viewed":348,"name":"Container","username":"gaz","description":"inspire https://www.shadertoy.com/view/4dyBzR","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","bokeh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time (iTime + 100.0)\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat hash(vec3 p)\n{\n    p  = fract(p * vec3(.16532, .17369, .15787));\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r)\n{\n  vec3 d = abs(p) - b;\n  return length(max(d, 0.0)) - r + min(max(d.x, max(d.y, d.z)), 0.0); \n}\n\nfloat map(vec3 p)\n{   \n    p.xy *= rotate(sin(time * 0.2) * 0.3);\n    p.z -= time * 2.8;\n    vec3 ip  = floor(p / 3.0);\n    p  = mod(p, 3.0) - 1.5;\n    float rnd  = hash(ip) * 2.0 - 1.0;\n    if (rnd < 0.4) return 0.5;\n    p.xy *= rotate(time * 1.5 * rnd);\n    p.yz *= rotate(time * 1.3 * rnd);\n    float a = atan(p.y, p.x);\n    p.xy += -0.05 * smoothstep(0.2, 0.0, abs(p.z)) * vec2(cos(a), sin(a));\n    a = atan(p.z, p.y);\n\tp.yz += -0.05 * smoothstep(0.2, 0.2, abs(p.x)) * vec2(cos(a), sin(a));\n    a = atan(p.x, p.z);\n    p.zx += 0.05 * smoothstep(0.2, 0.1, abs(p.y)) * vec2(cos(a), sin(a));\n    float size =hash(ip + vec3(123.123)) * 0.3 + 0.3;  \n    return sdRoundBox(p,vec3(size), 0.1);\n}\n\nvec3 calcNormal(vec3 p )\n{\n    vec2 e = vec2(1, -1) * 0.001;\n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\nvec3 doColor(vec3 p)\n{\n\treturn vec3(1.0, 0.3, 0.1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 bg=vec3(1);\n    vec3 ro = vec3(0, 0, 5);\n    vec3 rd = normalize(vec3(p, -1.8));\n\tfor (int j = 0; j < 5; j++)\n    {\n\t\tfloat z = 0.0, d, i, ITR=60.0;\n \t\tfor( i = 0.0; i < ITR; i++)\n  \t\t{\n    \t\tz += d = map(ro + rd * z);\n    \t\tif(d < 0.001 || z > 30.0) break;\n  \t\t}\n    \tif(d < 0.001)\n  \t\t{\n\t  \t\tvec3 p = ro + rd * z;\n\t \t\tvec3 nor = calcNormal(p);\n    \t\tvec3 li = normalize(vec3(1));\n        \tvec3 col = doColor(p);\n        \tcol *= pow(1.0 - i / ITR, 2.0); \n       \t \tcol *= clamp(dot(nor, li), 0.3, 1.0);\n        \tcol *= max(0.5 + 0.5 * nor.y, 0.0);\n        \tcol += pow(clamp(dot(reflect(normalize(p - ro), nor), li), 0.0, 1.0), 30.0);\n        \tcol *= exp(-z * z * 0.0001);\n        \tcol = pow(col,vec3(0.8));\n        \tcol = min(vec3(1), col * 3.0);\n        \tbg += col;\n    \t}\n\t\tro.z -= 0.07;\n\t}\n    bg = clamp(bg / 5.0, 0.0, 1.0);\n    fragColor = vec4(pow(bg,vec3(1.8))-0.1, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}