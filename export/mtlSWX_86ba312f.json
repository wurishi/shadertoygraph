{"ver":"0.1","info":{"id":"mtlSWX","date":"1675437431","viewed":49,"name":"Bubbly Bull","username":"Soupir","description":"blblbl","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["blblbl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//thanks to green chicken and the art of code ytb channel\n\n#define FOV 2.\n#define max_iteration 150\n#define max_distance 64.;\n#define surface_distance 0.01;\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat getDist(vec3 p){\n\n    p.z -= 2250. * 0.005;\n\n    vec4 sphere1 = vec4(0., 1.6, -5.2, 0.8);\n    vec4 sphere2 = vec4(sin(iTime) * 1., 1.2, -5., 0.05);\n    vec4 sphere3 = vec4(sin(iTime + 125.) * 1.0, 1.5 + sin(iTime + 125.) * 0.2, -5., 0.1);\n    vec4 sphere4 = vec4(sin(iTime + 65.) * 1.0, 1. - sin(iTime + 125.) * 0.2, -5., 0.1);\n    vec4 sphere5 = vec4(sin(iTime + 34.) * 1.1, 1. - sin(iTime + 125.) * 0.2, -5., 0.1);\n    \n    float sphere1Dist = length(p - sphere1.xyz) - sphere1.w;\n    float sphere2Dist = length(p - sphere2.xyz) - sphere2.w;\n    float sphere3Dist = length(p - sphere3.xyz) - sphere3.w;\n    float sphere4Dist = length(p - sphere4.xyz) - sphere4.w;\n    float sphere5Dist = length(p - sphere5.xyz) - sphere5.w;\n    \n    //noise\n    sphere1Dist -= sin(p.y * 12. + iTime * 6.) * 0.01;\n    sphere1Dist -= sin(p.y * 5. + iTime * 5.) * 0.01;\n    sphere1Dist -= sin(p.x * 3. + iTime * 5.) * 0.01;\n    \n    \n    float planeDist = p.y - 0.3;\n    \n    float distance = min(sphere1Dist, planeDist);\n    distance = opSmoothUnion(distance, sphere2Dist, 0.25);\n    distance = opSmoothUnion(distance, sphere3Dist, 0.25);\n    distance = opSmoothUnion(distance, sphere4Dist, 0.25);\n    distance = opSmoothUnion(distance, sphere5Dist, 0.25);\n    return distance;\n\n}\n\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceOrigin = 0.0;\n    \n    for(int i = 0; i < max_iteration; i++)\n    {\n        vec3 rayPosition = rayOrigin + rayDirection * distanceOrigin;\n        float distanceFromObject = getDist(rayPosition);\n        distanceOrigin += distanceFromObject;\n        \n        if(distanceOrigin > 200. || distanceFromObject < 0.01){\n            break;\n        }\n    }\n    \n    return distanceOrigin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv from -1 to 1 with ratio adaptation\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // locators\n    vec3 camPos = vec3(0. + sin(iTime) * 0.01, 0.6, 9.);\n    vec3 camTarget = vec3(0., 3.5, 0);\n    \n    // cam axis\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camForward, vec3(0., -1., 0.)));\n    vec3 camUp = normalize(cross(camForward, camRight));\n    \n    // the ray direction\n    vec3 viewDir = normalize(uv.x * camRight + uv.y * camUp + camForward * FOV);\n\n    vec3 col = vec3(0.0);\n    \n    float distance = clamp(rayMarch(camPos, viewDir), 1., 10.);\n    distance /= 5.;\n    vec3 palette =  palette(distance, vec3(0.7,0.1 + sin(iTime) * 0.01, 0.3 + sin(iTime) * 0.01),vec3(0.9,0.4,0.7),vec3(1.5,1.0,1.0),vec3(0.0,0.25,0.25) );\n    col = vec3(palette);\n    \n    float sphere = 1.0 - length(uv);\n    col += clamp(sphere * 0.5, 0.005, 1.) * 0.6;\n\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}