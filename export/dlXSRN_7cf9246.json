{"ver":"0.1","info":{"id":"dlXSRN","date":"1674394346","viewed":496,"name":"Volumetric Copper Mandelbulb","username":"Poisson","description":"A real time volumetric with shadows, ambient occlusion, fake global illumination, and rayleigh scattering.","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","fractal","ray","volume","gi","cloud","mandelbulb","blur","dof","volumetric","raymarcher","bloom","scattering","ao","dithering","scatter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A real time volumetric with shadows, ambient occlusion, and rayleigh scattering\n// I learned to make volume with the video of Sebastian Lague on clouds\n// https://www.youtube.com/watch?v=4QOcCGI6xOU\n// And I added other features like rayleigh scattering or ambient occlusion\n// move the mouse to rotate the camera\n\n// ACES tonemapper\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n// bloom function\nvec4 bloom(sampler2D sam, vec2 p) {    \n    vec4 col = vec4(0); // accumulated color\n    const int N = 8; // quality\n    \n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++)  {\n        vec2 off = vec2(i,j) / float(N); // blur offset\n        if (dot(off, off)<1.) { // inside disk\n            // blurred texture\n            col.rgb += textureLod(iChannel0, p+.07*off, 4.).rgb;\n            col.a += 1.;\n        }\n    }\n    // output\n    return col/col.a;\n}\n\n// depth of field function by iq\nvec4 dof(sampler2D sam, vec2 p) {\n    vec4 col = vec4(0); // accumulated color\n    const float focus = 1.3; // focus plane\n    const int N = 4; // quality\n    \n    for (int i=-N; i<=N; i++)\n    for (int j=-N; j<=N; j++) {\n        vec2 off = vec2(i,j); // blur offset\n        // blurred texture\n        vec4 tmp = texture(iChannel0, p+off/vec2(800,450)); \n        \n        float depth = tmp.w; // depth\n        vec3 color = tmp.xyz; // color\n        \n        float coc = 12.*abs(depth-focus) / depth;\n        if(dot(off,off) < coc*coc) { // inside disk (for bokeh)\n            float w = 1./(coc*coc); \n            col += vec4(color*w,w);\n        }\n    }\n    // output\n    return col/col.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = fragCoord/iResolution.xy;\n    // base color + dof\n    vec3 col = dof(iChannel0, p).rgb;\n\n    // post processing\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    // bloom\n    vec3 bloom = bloom(iChannel0, p).rgb;\n    col += bloom;\n    \n    col = ACES(col); // tonemapping\n    col = 1.2*pow(col,vec3(.9,1,1)); // add a bit of red\n    //col = col.xzy;\n    col *= .5+.5*pow(16. * p.x*p.y*(1.-p.x)*(1.-p.y), .1); // vignette\n            \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NUM_STEPS 64 // marching steps, higher -> better quality\n#define NUM_STEPS_LIGHT 32 // marching steps for light\n#define DITHERING // dithering on the distance\n\n// random float function\nfloat hash(float n) {return fract(sin(n)*43758.5453123);}\n\n// sphere intersection function\n// thanks to iq: https://iquilezles.org/articles/intersectors/\nvec2 sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    \n    if(h<0.) return vec2(-1);\n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\n// mandelbulb sdf\n// thanks to iq: https://www.shadertoy.com/view/ltfSWn\nfloat sdMandelbulb(vec3 p, float power, out vec4 resTrap) {\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.;\n    \n\tfor (int i=0; i<5; i++) {\n\t\tdz = power*pow(m,(power-1.)*.5)*dz + 1.;\n      \n        float r = length(w);\n        float b = power*acos(w.y/r);\n        float a = power*atan(w.x, w.z);\n        w = p + pow(r,power) * vec3(sin(b)*sin(a), cos(b), sin(b)*cos(a));\n        \n        trap = min(trap, vec4(abs(w),m));\n        \n        m = dot(w,w);\n\t\tif(m>256.) break;\n    }\n    resTrap = vec4(m,trap.yzw);\n\n    return .25*log(m)*sqrt(m)/dz;\n}\n\n// volume density\nfloat map(vec3 p, out vec4 trap) {\n    return 512.*-sdMandelbulb(p*vec3(1,-1,1), 6., trap);\n}\n\n// raymarching function\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.; // distance travelled\n    \n    for (int i=0; i<256; i++) {\n        vec3 p = ro + rd*t; // current point\n        \n        vec4 tmp;\n        float h = -map(p, tmp)/512.; // distance to the scene\n        if (h<.001) break; // we hit the surface\n        t += h; // march\n        if (t>8.) return 1e10;\n    }\n    // return the distance\n    return t;\n}\n\n// volume shadow\nfloat shadow(vec3 ro, vec3 rd) {\n    vec2 bound = sphIntersect(ro, rd, vec3(0), 1.2); // bounding sphere\n    float tmax = bound.y;\n    \n    float s = tmax / float(NUM_STEPS_LIGHT); // step size\n    float t = 0.; // distance travelled\n    \n    float res = 0.; // result\n    for (int i=0; i<NUM_STEPS_LIGHT; i++) { // marching loop\n        vec3 p = ro + rd*t; // current point\n        \n        vec4 tmp;\n        float h = max(0.,map(p, tmp)); // density\n        res += h*s;\n        \n        t += s; // march\n    }\n    return res;\n}\n\n// rendering\nvec3 render(vec3 ro, vec3 rd) {\n    // background color\n    vec3 bgCol = vec3(0);\n    \n    // bounding volume\n    vec2 bound = sphIntersect(ro, rd, vec3(0), 1.2);\n    float tmin = bound.x; // min distance\n    float tmax = bound.y; // max distance\n    \n    vec4 sum = vec4(0,0,0,1); // color and opacity\n    if (tmax<0.) return bgCol; // outside the bounding volume\n    \n    float s = (tmax-tmin) / float(NUM_STEPS); // step size\n    float t = tmin; // distance travelled\n    #ifdef DITHERING\n    // dithering\n    t += s*hash(iTime+gl_FragCoord.x*8315.9213/iResolution.x+gl_FragCoord.y*2942.5192/iResolution.y);\n    #endif\n    \n    for (int i=0; i<NUM_STEPS; i++) { // marching loop\n        vec3 p = ro + rd*t; // current point\n        vec4 trap;\n        float h = map(p, trap); // density\n        \n        if (h>0.) { // inside the volume\n            vec3 lig = normalize(vec3(2,1,1.5)); // light direction\n            float sha = shadow(p, lig); // shadows\n            \n            // scattered color\n            vec3 mat = vec3(1,2.5,4);\n            mat = mix(mat, vec3(8,3,3), clamp(1.5*trap.y*trap.y,0.,1.));\n            \n            vec3 col = 1.6*exp(-sha*mat*4.); // direct light\n            col += .4*exp(-h*.25*mat*mat); // ambien light\n            \n            sum.rgb += h*s*sum.a*col; // add the color to the final result\n            sum.a *= exp(-h*s*2.); // beer's law for light absorbtion\n        }\n        if (sum.a<.01) break; // optimization\n        t += s; // march\n    }\n    \n    vec3 col = bgCol*sum.a + sum.rgb; // mix the background color with the volume color\n    return col;\n}\n\n// camera function\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(w, vec3(0,1,0)));\n    vec3 v = cross(u, w);\n    return mat3(u, v, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates centered at the origin\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    float an = .1*iTime-1.; // camera angle\n    vec3 ro = 1.3*vec3(sin(an),1,cos(an)); // ray origin\n    vec3 ta = vec3(0,.7,0); // target\n    mat3 ca = setCamera(ro, ta); // camera matrix\n    \n    vec3 rd = ca * normalize(vec3(p,1.5)); // ray direction\n    \n    // rendering\n    vec3 col = render(ro, rd);\n    float t = intersect(ro, rd); // distance to the object (for the dof)\n    \n    // blend the color with the previous frame\n    vec2 q = fragCoord/iResolution.xy;\n    vec4 prev = texture(iChannel0, q);\n    fragColor = mix(vec4(col,t), prev, iFrame==0 ? 0. : .3);\n}","name":"Buffer A","description":"","type":"buffer"}]}