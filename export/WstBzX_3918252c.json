{"ver":"0.1","info":{"id":"WstBzX","date":"1605691744","viewed":219,"name":"Domain Warping.","username":"Logos","description":"Warping domain of Mandelbrot fractal.\n\nYou can use mouse to warp by yourself...","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","mandelbrot","warping","domain","complex","cardioid","unrolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Śmietana (Logos) - 18.11.2020\n// Bielsko-Biała, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\nvec3 fractal(vec2 p)\n{   \n    \n    //--- basic constants ---//\n    \n    const vec2\tO\t\t= vec2(1, 0);\n    const float\ts3d2\t= sqrt(3.0) * 0.5;\n\n    \n    //--- moebius transform coefficients ---//\n    \n    const vec2 a = vec2(-0.5, -s3d2);\n\tconst vec2 b = vec2(+1.5, -s3d2);\n\tconst vec2 c = vec2(+0.5, +s3d2);\n\tconst vec2 d = vec2(+1.5, -s3d2);\n\n    \n    //--- rolling cardioid ---//\n    \n    vec2 z = p;\n\n    z = cSqrt(O - 4.0 * z) - O;\n    z = cMobI(z, a, b, c, d);\n\n    \n    //--- domain warping as simple movement ---//\n    \n    float time = iMouse.z > 0.5? 10.0*(iMouse.x/iResolution.x - 0.5) : 2.0 * cos(0.12*iTime) - 2.0;\n    \n    z.x += time;\n    \n    \n    //--- unrolling cardioid ---//\n    \n    z = cMob(z, a, b, c, d);\n    z = 0.25 * (O - cMul(z + O, z + O));\n    \n\n    //--- generating \"before unrolling\" chessboard ---//\n    \n    vec2 q = floor(6.0*z);\t\t\t\t\t// checkboard size\n    bool ch = mod(q.x + q.y, 2.0) == 0.0;\n\n    \n    //--- calculate fractal ---//\n    \n    p = z;\n      \n\tfor (float i = 0.0; i < 160.0; i++)\n    {\n        z = cMul(z, z) + p;\t\t\t\t\t// Mandelbrot formulae\n\n\t\tif (4.0 < dot(z, z))\n        {\n            float f = 1.0 - i/160.0;\n            f *= f;\n\n            return ch? f*vec3(0.7, 0.8, 0.5) : vec3(0.9*f);\t// outside color\n\t\t}\n\t}\n\n    \n    //--- fractal body ---//\n\n    time = abs(time);\n\n    float d1 = abs(circlesegment(p + vec2(1.03, 0.0), 0.18, -0.77, +0.77) - 0.016);\n    float d2 = abs(       length(p + vec2(0.87, 0.0)) - 0.06);\n\n    if      (time < 0.45) { if (d1 < 0.01)                             return vec3(0); }\n    else if (time < 0.65) { if (mix(d1, d2, 5.0*(time - 0.45)) < 0.01) return vec3(0); }\n    else                  { if (d2 < 0.01)                             return vec3(0); }\n    \n    p.y = abs(p.y);\n\tif (abs(length(p + vec2(1.05, -0.1)) - 0.034) < 0.01) return vec3(0);\n    \n    return vec3(1);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- calculate point coordinates ---//\n\n    float ZOOM  = 2.221;\n    vec2  p\t\t= ZOOM * (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n\n    p.y += +0.6;\n\tp    = -p.yx;\n    \n    \n    //--- set final antialiased pixel color by accumulating samples ---//\n    \n    float a  = 2.0;\t\t\t\t\t// improves quality, use carefully (3-4 max), only ints!\n    float o  = 1.0 / (4.0*a*a);\n    float e  = 0.5 / min(iResolution.x, iResolution.y);    \n    float ea =   e / a * ZOOM;\n    \n    vec3 fc = vec3(0.0);\t\t\t// final color\n    \n    \n    //--- that is why \"a\" variable must be choosen carefully :D ---//\n    \n    for (float j = -a; j < a; j++)\n        for (float i = -a; i < a; i++)\n\n            fc += o*fractal(p + ea*vec2(i, j));\n        \n    fragColor = vec4(fc, 1.0); \n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 cMul(vec2 z, vec2 w)\n{\n    return vec2 (z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\n\nvec2 cDiv(vec2 z, vec2 w)\n{\n\treturn vec2 (z.x*w.x + z.y*w.y, -z.x*w.y + z.y*w.x)/(w.x*w.x + w.y*w.y);\n}\n\n\nvec2 cMob(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    return cDiv(cMul(a, z) + b, cMul(c, z) + d);\n}\n\n\nvec2 cMobI(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    return cDiv(cMul(d, z) - b, -cMul(c, z) + a);\n}\n\n\nfloat cMod(vec2 z)\n{\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\n\nvec2 cSqrt (vec2 z)\n{\n  float t = sqrt(2.0 * (cMod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n\nvec2 rot(vec2 v, float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    \n\treturn vec2(ca*v.x + sa*v.y, -sa*v.x + ca*v.y);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// taken from: https://www.shadertoy.com/view/wdtfWr\n\nfloat circlesegment(vec2 x, float r, float p0, float p1)\n{\n    float p = atan(x.y, x.x),\n        t = 2.*3.1415926535;\n    \n    vec2 philo = vec2(p0, p1);\n    philo = sign(philo)*floor(abs(philo)/t)*t;\n    philo = vec2(min(philo.x, philo.y), max(philo.x,philo.y));\n    philo.y = mix(philo.y,philo.x,.5+.5*sign(p0-p1));\n    \n    p0 -= philo.y;\n    p1 -= philo.y;\n    \n    philo = vec2(max(p0, p1), min(p0, p1));\n    \n    if((p < philo.x && p > philo.y) \n       || (p+t < philo.x && p+t > philo.y) \n       || (p-t < philo.x && p-t > philo.y)\n      )\n    \treturn abs(length(x)-r);\n    return min(\n        length(x-r*vec2(cos(p0), sin(p0))),\n        length(x-r*vec2(cos(p1), sin(p1)))\n        );\n}\n","name":"Common","description":"","type":"common"}]}