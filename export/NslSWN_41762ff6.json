{"ver":"0.1","info":{"id":"NslSWN","date":"1618676909","viewed":47,"name":"316_pakhnenko_v4v0","username":"piton322","description":"316_pakhnenko_v4v0","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["316pakhnenkov4v0"],"hasliked":0,"parentid":"sdfXDN","parentname":"test2m"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PHI (1.618033988749895)\n\nconst float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(-5, 0.6, -6);\nstruct light\n{\n    vec3 pos;\n    float r;\n    vec3 color;\n};\nlight light1 = light(vec3(2, 1, -1), 0.5, vec3(1, 1, 0));\nlight light2 = light(vec3(0, 0, 4), 0.4, vec3(0, 1, 0));\n\nvec3 randDir;\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal) \n{\n    float t = (-1.2 - pos.y) / dir.y;\n    if (t <= 0.0) \n    {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 50.0) \n    {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) \n{\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) \n    {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) \n    {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) \n    {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) \n{\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.5) \n    {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.5;\n    float D = b * b - a * c;\n    if (D < 0.0) \n    {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) \n    {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) \n        {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) \n    {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) \n    {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) \n{\n    vec3 dir = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 sphNorm;\n    float sphT = traceSphere(pos, dir, 1.0, sphNorm);\n    if (sphT < dist)\n        return true;\n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, cylNorm);\n    return (cylT < dist);\n}\n\nvec3 computeLight(vec3 pos, vec3 color, vec3 normal) \n{\n    vec3 toLight1 = light1.pos - pos;\n    float distSq1 = dot(toLight1, toLight1);\n    float att1 = isOccluded(pos, light1.pos + randDir * light1.r) ? 0.0 : 20.0f / distSq1;\n    vec3 toLight2 = light2.pos - pos;\n    float distSq2 = dot(toLight2, toLight2);\n    float att2 = isOccluded(pos, light2.pos + randDir * light2.r) ? 0.0 : 10.0f / distSq2;\n    return color * (\n        max(0.0, dot(normal, normalize(toLight1))) * att1 * light1.color\n        + max(0.0, dot(normal, normalize(toLight2))) * att2 * light2.color\n        + texture(iChannel1, normal).rgb * 0.1\n    );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) \n{\n    if (dot(v, normal) < 0.0) \n    {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\nfloat pow2(float x) \n{\n    return x * x;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nfloat d_max(float d, vec3 p, vec3 v)\n{\n    return max(d, abs(dot(p, v)));\n}\n\nfloat fDodecahedron(vec3 p, float r) \n{\n    float d = 0.;\n    d = d_max(d, p, normalize(vec3(0, PHI, 1)));\n    d = d_max(d, p, normalize(vec3(0, -PHI, 1)));\n    d = d_max(d, p, normalize(vec3(1, 0, PHI)));\n    d = d_max(d, p, normalize(vec3(-1, 0, PHI)));\n    d = d_max(d, p, normalize(vec3(PHI, 1, 0)));\n    d = d_max(d, p, normalize(vec3(-PHI, 1, 0)));\n    return d - r;\n}\n\nvec3 m_dod(vec3 pos, vec3 dir, float r, out float dist) \n{\n    dist = 0.0;\n    for(int i=0; i < 30; i++) \n    {\n        float dst = fDodecahedron(pos, r);\n        if (dst < 0.00001) break;\n        pos += dir*dst;\n        dist += dst;\n    }\n    return pos;\n}\n\n\nfloat traceDodecaedr(vec3 pos, vec3 dir, float r, out vec3 normal)\n{\n    float t;\n    vec3 pt = m_dod(pos, dir, r, t);\n    if (t <= 0.)\n    {\n        return INF;\n    }    \n    float t1;\n    float t2;    \n    vec3 ptx = m_dod(vec3(pos.x + 0.001, pos.y, pos.z), dir, r, t1);\n    vec3 pty = m_dod(vec3(pos.x, pos.y + 0.001, pos.z), dir, r, t2);\n    if (length(ptx - pos) < 100. && length(pty - pos) < 100.) \n    {\n        normal = -normalize(cross(ptx - pt, pty - pt));\n        return t;\n    }\n    return INF;\n}\n\nvec3 mod289(vec3 x) \n{ \n    return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec4 mod289(vec4 x) \n{ \n    return x - floor(x * (1.0 / 289.0)) * 289.0; \n}\n\nvec4 permute(vec4 x) \n{ \n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{ \n    return 1.79284291400159 - 0.85373472095314 * r; \n}\n\nstruct noise_p\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2;\n    vec3 p3;\n};\n\nvoid help_func(vec2 C, vec4 D, vec4 p, out noise_p res)\n{\n    float n_ = 0.142857142857;\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);\n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n    res = noise_p(vec3(a0.xy, h.x), vec3(a0.zw, h.y), vec3(a1.xy, h.z), vec3(a1.zw, h.w));\n}\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy;\n\tvec3 x3 = x0 - D.yyy;\n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    noise_p pp;\n    help_func(C, D, p, pp);\n    vec3 p0 = pp.p0;\n    vec3 p1 = pp.p1;\n    vec3 p2 = pp.p2;\n    vec3 p3 = pp.p3;\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat setNoise(vec3 pos, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.5 / qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n\tfor(int i=2; i >= 0 ; i--)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\t\tfOut *= 2.0;\n\t\tvalue += abs(snoise(pos * fOut)) / fOut;\n\t}\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\tvalue += fade * abs(snoise(pos * fOut))/fOut;\n\treturn 1.0-value;\n}\n\nvec4 makeColor(float t)\n{\n\tfloat c1 = clamp(t * 5.0 + 0.5, 0.0, 1.0);\n    float c2 = clamp(t * 5.0, 0.0, 1.0);\n    float c3 = clamp(t * 3.4 - 0.5, 0.0, 1.0);\n\tvec4 a = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(1.0, 0.8, 0.2, 1.0), c1);\n\tvec4 b = mix(a,     vec4(1.0, 0.03, 0.0, 1.0), c2);\n\treturn \t mix(b,     vec4(0.05, 0.02, 0.02, 1.0), c3);\n}\n\nfloat makeNoise(vec3 pos, out float t)\n{\n\tfloat noise = setNoise(pos * 25.0 + vec3(1.0, -1.0, 1.0) * iTime, 0.1, 1.5, 0.03) * 0.04;\n\tnoise = clamp(abs(noise), 0.0, 1.0);\n\tt = length(pos - vec3(0.0)) - 0.3 - noise;\n\treturn noise;\n}\n\nvec4 mFire(vec3 normal, vec3 dir)\n{\n\tvec3 pos = normal;\n\tfloat t;\n\tfloat res;\n\tfor(int i = 5; i >= 0  ; --i)\n\t{\n\t\tres = makeNoise(pos, t);\n\t\tif(t < 0.05) break;\n\t\tpos += dir * t;\n\t}\n\treturn mix(makeColor(res), vec4(0.1, 0.0, 0.0, 1.0), float(t >= 0.5));\n}\n\nfloat traceFireSphere(vec3 pos, vec3 dir, vec3 s_pos, float r, out vec3 normal)\n{\n\tvec3 p = (pos - s_pos);\n\tfloat b = dot(p, dir);\n\tfloat c = dot(p, p) - r * r;\n\tfloat t = b * b - c;\n\tnormal = pos + dir * (-b - sqrt(t));\n\tif (t <= 0.)\n    {\n        return INF;\n    }\n    return t;\n}\n\nstruct data\n{\n    float t;\n    int materialType;\n    vec3 color;\n    vec3 normal;\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float n1 = AIR_N;\n    const float D_N = 2.5;\n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float D_R = pow2(AIR_N - D_N) / pow2(AIR_N + D_N);\n    vec3 colorMult = vec3(1, 1, 1);\n    data my_data;\n    for (int i = 0; i < 10; ++i) {\n        my_data.t = INF;\n        float nEnter = AIR_N;\n        \n        // стол\n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < my_data.t) \n        {\n            my_data.t = planeT;\n            my_data.materialType = DIFFUSE;\n            vec3 worldPos = my_data.t * curDir + curPos;\n            my_data.color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            my_data.normal = planeNorm;\n        }\n        \n        // свет 1\n        vec3 l1Norm;\n        float light1T = traceSphere(curPos - light1.pos, curDir, light1.r, l1Norm);\n        if (light1T < my_data.t) \n        {\n            my_data = data(light1T, EMISSION, light1.color, l1Norm);\n        }\n        \n        // свет 2\n        vec3 l2Norm;\n        float light2T = traceSphere(curPos - light2.pos, curDir, light2.r, l2Norm);\n        if (light2T < my_data.t) \n        {\n            my_data = data(light2T, EMISSION, light2.color, l2Norm);\n        }\n        \n        // огонь\n        vec3 fireNorm;\n        float fireT = traceFireSphere(curPos, curDir, vec3(0.0), 0.3 + 0.04, fireNorm);\n        if (fireT < my_data.t)\n        {\n            my_data = data(fireT, 0, (mFire(fireNorm, curDir)).rgb, fireNorm);\n            if (randVals.x < GLASS_R) \n            {\n                my_data.materialType = REFLECTION;\n            }\n            else if (randVals.y < D_R) \n            {\n                my_data.materialType = REFRACTION;\n                if (dot(curDir, my_data.normal) > 0.0) \n                {\n                    nEnter = AIR_N;\n                } \n                else \n                {\n                    nEnter = D_N;\n                }\n            }\n        }\n        \n        // додекаэдр\n        vec3 dodNorm;\n        float dodT = traceDodecaedr(curPos, curDir, 1.0, dodNorm);\n        if (dodT < my_data.t) \n        {\n            my_data.t = dodT;\n            my_data.normal = dodNorm;\n            if (randVals.x < GLASS_R) \n            {\n                my_data.materialType = REFLECTION;\n            } else \n            {\n                colorMult *= vec3(0.7, 0.8, 0.5);\n                my_data.materialType = REFRACTION;\n                if (dot(curDir, my_data.normal) > 0.0) \n                {\n                    nEnter = AIR_N;\n                } else \n                {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        \n        // подставка\n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, cylNorm);\n        if (cylT < my_data.t) \n        {\n            my_data.t = cylT;\n            my_data.materialType = DIFFUSE;\n            vec3 worldPos = my_data.t * curDir + curPos;\n            my_data.color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            my_data.normal = cylNorm;\n        }\n        // обработка материалов\n        if (my_data.t != INF) \n        {\n            vec3 worldPos = my_data.t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (my_data.materialType == EMISSION) \n            {\n                fragColor.rgb = my_data.color * colorMult;\n                break;\n            } else if (my_data.materialType == DIFFUSE) \n            {\n                fragColor.rgb = computeLight(worldPos, my_data.color, my_data.normal) * colorMult;\n                break;\n            } else if (my_data.materialType == REFLECTION) \n            {\n                curDir = reflect(curDir, my_data.normal);\n                curPos = worldPos + curDir * 1e-5;\n            } else if (my_data.materialType == REFRACTION) \n            {\n                curDir = refraction(curDir, my_data.normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            }\n        } else \n        {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}