{"ver":"0.1","info":{"id":"WsjyWh","date":"1586563037","viewed":133,"name":"Grass 1.0","username":"DenZ33","description":"Drag to change view","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst int MAX_STEPS = 63;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1024.0;\nconst float EPSILON = 0.01;\n\n\n\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat halfEllipseSDF(vec3 smp,vec3 size){ //approx\n    float k0 = length(smp/size);\n    float k1 = length(smp/(size*size));\n\tif(smp.y > -EPSILON) return k0*(k0-1.0)/k1;\n    else return -smp.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p){\n \treturn p.y;   \n}\n\nvec2 getWindVec(vec2 sp,float t){\n\tvec2 pos = vec2(0.0,500.0);\n    vec2 pos2 = vec2(400.0,100.0);\n    float power1 = (sin(-length(pos - sp)*0.1 + t*5.0)*0.5+0.5);\n    float power2 = (sin(-length(pos2 - sp)*0.1 + t*3.0)*0.5+0.5);\n    vec2 dir = (normalize(pos - sp)*power1 + normalize(pos2 - sp)*power2);\n    return dir;   \n    \n}\n\nfloat grass1SDF(vec3 sp){\n const float md = 0.5;\n vec2 fact1 = sp.y*sp.y*getWindVec(sp.xz,iTime + sin(iTime)*0.5)*0.04; //deform global\n highp vec3 sp2 = sp + vec3(fact1.x,0.0,fact1.y) ; // wind\n sp2 = sp2 + vec3(sin(sp2.z)*md,0.0,sin(sp2.x)*md);\n    \n vec3 sp3 = vec3(mod(sp2.x,md*2.0)-md,sp2.y,mod(sp2.z,md*2.0)-md); // repeat\n   \n float p1 = halfEllipseSDF(sp3,vec3(0.3,4.0 + sin(sp2.x*2.0)*sin(sp2.z*2.0)*sin(sp2.x*0.9),0.4));\n    //float p2 = halfEllipseSDF(samplePoint2 + vec3(0.3,0.0,0.0),vec3(0.2+sin(samplePoint.x*0.1)*0.1,5.0,0.3 + sin(samplePoint.z*0.1)*0.1));\n return p1;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n\n   float p1 = grass1SDF(samplePoint);\n   return p1;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nfloat rayMarchScene(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    } \n    return end;\n}\n\nfloat rayMarchGround(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sdBox(eye + depth * marchingDirection + vec3(0.0,5.0,0.0),vec3(1000.0,5.0,1000.0));\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    } \n    return end;\n}\n\nfloat rayMarchBound(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sdBox(eye + depth * marchingDirection,vec3(1000.0,5.0,1000.0));\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nfloat rayMarchShadow(vec3 eye, vec3 marchingDirection, float start, float end){\n    float depth = start ;\n    float intens = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n       \tintens = min(intens,clamp(dist/depth*10.0,0.0,1.0));\n        if (dist < EPSILON) {\n\t\t\treturn 0.0;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return intens;\n        }\n    } \n    return intens;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 grassColor = vec3(0.2,0.55,0.2);\n    vec3 groundColor = vec3(0.5,0.3,0.2);\n    vec3 albedo = vec3(0.0);\n  \n    vec3 ldir = vec3(0.0,1.0,1.0);\n    vec2 mousev = (iMouse.xy-iResolution.xy*0.5)*0.1;\n   if(iMouse.xy == vec2(0.0,0.0))\n        mousev = vec2(sin(iTime*0.1)*50.0,cos(iTime*0.5)*5.0+6.0);\n    \n\tvec3 dir = rayDirection(90.0, iResolution.xy, fragCoord);\n    dir = ( vec4(dir,1.0) * rotationX(-mousev.y*0.05) * rotationY(mousev.x*0.05) ).xyz;\n    vec3 eye = vec3(mousev*5.0 + vec2(0.0,5.0) , 55.0);\n    \n    float distBound = rayMarchBound(eye, dir, MIN_DIST, MAX_DIST);\n    float distScene = rayMarchScene(eye , dir, distBound, MAX_DIST);\n    float distGround = rayMarchGround(eye, dir, MIN_DIST, MAX_DIST);\n   \n    float isGround = step(distScene,distGround);\n    float distMain = mix(distGround,distScene,isGround);\n    \n    vec3 pos = eye + dir*distMain;\n    \n    albedo = mix(groundColor,grassColor + texture(iChannel1,pos.xz*0.002).rgb*0.1-0.1,isGround);\n    \n    vec3 normal = mix(vec3(0.0,1.0,0.0),estimateNormal(eye+distMain*dir),isGround);\n\n    \n    if ((distMain > MAX_DIST - EPSILON) ) {\n        fragColor = mix(vec4(0.4, 0.8, 1.0, 0.0),vec4(1.0,1.0,0.9,0.0),(clamp(dot(dir,ldir)*30.0-41.0,0.0,1.0)));\n\t\treturn;\n\t}\n    \n\n\n    float ldist = rayMarchShadow(eye + dir*distMain,ldir,0.5,MAX_DIST);\n    float ldist2 = ldist;\n    \n    vec3 ambientColor = vec3(0.4,0.7,0.4)*(pos.y*0.2+0.3);\n    vec3 sunColor = vec3(1.0,1.0,0.8);\n   // fragColor = vec4(dist/MAX_DIST, nor.x*0.5+0.5, 0.0, 1.0);\n     //vec3 col = nor.xyz*0.5+0.5;\n     vec3 col = albedo * (sunColor * clamp(dot(ldir,normal),0.0,1.0)* ldist2 + ambientColor);\n     fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"}]}