{"ver":"0.1","info":{"id":"ct2fDd","date":"1694625271","viewed":72,"name":"My first GLSL ray tracer","username":"3TheHedgehogCoder3","description":"very raytracer","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int rays = 20;\nconst int numReflections = 10;\nconst int spheres = 3;\nconst int tris = 4;\nconst vec3 sunPos = vec3(0.5, 0.5, 1);\n\nvec3 spherePos[spheres];\nvec3 sphereCol[spheres];\nfloat sphereRadius[spheres];\nfloat sphereRoughness[spheres];\nvec3 triVert1[tris];\nvec3 triVert2[tris];\nvec3 triVert3[tris];\nvec3 triCol[tris];\nfloat triRoughness[tris];\nstruct Intersection {\n    vec3 pos;\n    vec3 normal;\n    bool intersecting;\n};\nstruct NewRay {\n    vec3 dir;\n    vec3 col;\n    bool reflection;\n};\n\nvoid setup() {\n  spherePos[0] = vec3(0,0,2);\n  sphereCol[0] = vec3(0.25,0.25,1);\n  sphereRadius[0] = 1.0;\n  sphereRoughness[0] = 0.5;\n  spherePos[1] = vec3(-1.5,0.25,2.1);\n  sphereCol[1] = vec3(1,0.25,0.25);\n  sphereRadius[1] = 0.5;\n  sphereRoughness[1] = 0.1;\n  spherePos[2] = vec3(1.1,0.5,1.4);\n  sphereCol[2] = vec3(0.25,1,0.25);\n  sphereRadius[2] = 0.25;\n  sphereRoughness[2] = 1.0;\n\n  triVert1[0] = vec3(0,-1.5,1);\n  triVert2[0] = vec3(-2,-2.75, 1.5);\n  triVert3[0] = vec3(-2,-1,3);\n  triCol[0] = vec3(0.6,1,0.8);\n  triRoughness[0] = 1.0;\n  triVert1[1] = vec3(0,-1.5,1);\n  triVert2[1] = vec3(-2,-1,3);\n  triVert3[1] = vec3(3,-1.25, 2.5);\n  triCol[1] = vec3(0.6,1,0.8);\n  triRoughness[1] = 1.0;\n  triVert1[2] = vec3(0,-1.5,1);\n  triVert3[2] = vec3(-2,-2.75, 1.5);\n  triVert2[2] = vec3(3,-1.25,2.5);\n  triCol[2] = vec3(0.6,1,0.8);\n  triRoughness[2] = 1.0;\n  triVert1[3] = vec3(-2,-1,3);\n  triVert3[3] = vec3(-2,-2.75, 1.5);\n  triVert2[3] = vec3(3,-1.25,2.5);\n  triCol[3] = vec3(0.6,1,0.8);\n  triRoughness[3] = 1.0;\n}\n\nfloat random(vec2 st){\n  return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 randomDir(vec2 pos) {\n  return normalize(vec3(\n  sqrt(-2.0 * log(random(pos + vec2(0.123,0.123)))) * cos(6.28318530718 * random(pos + vec2(0.123,0.456))),\n  sqrt(-2.0 * log(random(pos + vec2(0.456,0.456)))) * cos(6.28318530718 * random(pos + vec2(0.456,0.789))),\n  sqrt(-2.0 * log(random(pos + vec2(0.789,0.789)))) * cos(6.28318530718 * random(pos + vec2(0.789,0.123)))\n  ));\n}\n\nmat4 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, c, -s, 0.0,\n        0.0, s, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        c, 0.0, s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat4(\n        c, -s, 0.0, 0.0,\n        s, c, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvec3 diffuseDir(vec2 pos, vec3 normal) {\n  return normalize(randomDir(pos) + normal);\n}\n\nIntersection raySphereIntersection(vec3 o, vec3 u, vec3 c, float r) {\n  Intersection sphereIntersection;\n  vec2 quad = vec2(dot(u, o - c), dot(o - c, o - c) - r * r);\n  float t;\n  if (quad.y < 0.0) {\n    t = -quad.x+sqrt(quad.x * quad.x - quad.y);\n  } else {\n    t = -quad.x-sqrt(quad.x * quad.x - quad.y);\n  }\n  sphereIntersection.pos = o + t * u;\n  sphereIntersection.normal = (o + t * u - c) / r;\n  sphereIntersection.intersecting = (quad.x * quad.x > quad.y && t > 0.0);\n  return sphereIntersection;\n}\n\nIntersection rayTriIntersection(vec3 o, vec3 u, vec3 v1, vec3 v2, vec3 v3) {\n  Intersection triIntersection;\n  vec3 n = normalize(cross(v2 - v1, v3 - v1));\n  float t = dot(n,(v1 - o))/dot(n, u);\n  vec3 pos = o + t * u;\n  float d1 = dot(cross(v1-pos,v2-pos),n);\n  float d2 = dot(cross(v2-pos,v3-pos),n);\n  float d3 = dot(cross(v3-pos,v1-pos),n);\n  triIntersection.pos = pos;\n  triIntersection.normal = n;\n  triIntersection.intersecting = (t > 0.0 && d1 > 0.0 && d2 > 0.0 && d3 > 0.0);\n  return triIntersection;\n  \n}\n\nvec3 getSkyCol(vec3 dir) {\n  vec3 skyCol;\n  if (dot(dir,vec3(0,1,0)) < 0.0) {\n    float haze = exp(0.69314718056 - sqrt(0.99 + 0.01 / (dir.y * dir.y)));\n    skyCol = mix(vec3(0.92,0.97,1),vec3(0.5),haze);\n  } else {\n    vec3 sky = mix(vec3(0.92,0.97,1),vec3(0.4,0.7,1),dir.y);\n    float sun = 10.0 * pow(clamp(dot(dir,normalize(sunPos)), 0.0, 1.0),1000.0);\n    skyCol = vec3(1,0.97,0.95) * vec3(sun) + sky * max(1.0 - sun, 0.0);\n  }\n  return skyCol * skyCol;\n}\n\nNewRay getRayDir(vec2 coord, int scene, vec3 dir, float rayLength, vec3 col, vec3 normal, float roughness, float transmition, float smoothness, float refractIndex1, float refractIndex2) {\n  NewRay newRay;\n  newRay.reflection = true;\n  vec3 specular = reflect(dir,normal);\n  float fresnel = pow(-dot(dir,normal),1.0);\n  if (random(coord * float(scene)) * smoothness > fresnel) {\n    newRay.dir = specular;\n    newRay.col = vec3(1);\n  } else {\n    if (random(coord * float(scene) + vec2(10)) >= transmition) {\n        vec3 diffuse = diffuseDir(coord * float(scene), normal);\n        newRay.dir = mix(specular,diffuse,roughness);\n        newRay.col = col;\n    } else {\n      newRay.col = mix(col, vec3(1), exp(-rayLength));\n      newRay.dir = refract(dir, normal, refractIndex2 / refractIndex1);\n      if (length(newRay.dir) == 0.0) {\n        newRay.dir = reflect(dir, normal);\n      } else {\n        newRay.reflection = false;\n      }\n    }\n  }\n  return newRay;\n}\n\nvec3 getCol(vec2 coord, vec3 pixelDir, vec3 camera, int scene) {\n  vec3 rayDir = pixelDir;\n  vec3 rayOrigin = camera;\n  vec3 currentCol = vec3(1);\n  bool inside = true;\n  bool insideLast = true;\n  float refractIndex = 1.0;\n\n  for (int bounces = 1; bounces <= numReflections; bounces++) {\n    Intersection intersection;\n    bool touchingScene = false;\n    vec3 minNormal;\n    vec3 minCol = vec3(0);\n    float minDist = 100.0;\n    float roughness;\n    for (int i = 0; i < spheres; i++) {\n      intersection = raySphereIntersection(rayOrigin, rayDir, spherePos[i], sphereRadius[i]);\n      if (intersection.intersecting) {\n        if (distance(intersection.pos, rayOrigin) < minDist) {\n          minDist = distance(intersection.pos, rayOrigin);\n          minNormal = intersection.normal;\n          minCol = sphereCol[i];\n          touchingScene = true;\n          roughness = sphereRoughness[i];\n        }\n      }\n    }\n    for (int i = 0; i < tris; i++) {\n      intersection = rayTriIntersection(rayOrigin, rayDir, triVert1[i],triVert2[i],triVert3[i]);\n      if (intersection.intersecting) {\n        if (distance(intersection.pos, rayOrigin) < minDist) {\n          minDist = distance(intersection.pos, rayOrigin);\n          minNormal = intersection.normal;\n          minCol = triCol[i];\n          touchingScene = true;\n          roughness = triRoughness[i];\n        }\n      }\n    }\n    if (touchingScene) {\n      if (dot(minNormal, rayDir) > 0.0) {\n        minNormal = -minNormal;\n      }\n      vec3 prevRayDir = rayDir;\n      vec3 prevPos = rayOrigin;\n      float transmitionDepth;\n      float prevRefractIndex = refractIndex;\n      if (inside) {\n        refractIndex = 1.3;\n      } else {\n        refractIndex = 1.0;\n      }\n      if (insideLast) {\n        transmitionDepth = minDist;\n      } else {\n        transmitionDepth = 0.0;\n      }\n      insideLast = inside;\n      NewRay newRayDir = getRayDir(coord, scene, rayDir, transmitionDepth, minCol, minNormal, roughness, 0.0, 0.5, refractIndex, prevRefractIndex);\n      currentCol *= newRayDir.col;\n      rayDir = newRayDir.dir;\n      if (newRayDir.reflection == false) {\n        inside = !inside;\n      }\n      rayOrigin = rayOrigin + prevRayDir * minDist + rayDir * 0.0001;\n    } else {\n      currentCol *= getSkyCol(rayDir);\n      break;\n    }\n  }\n  return currentCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup();\n    float aspect = min(iResolution.x, iResolution.y);\n    vec2 coord = 2.0 * fragCoord / aspect - iResolution.xy / aspect;\n    vec2 mouse = 2.0 * iMouse.xy / aspect - iResolution.xy / aspect;\n    vec3 screenCol = vec3(0);\n    vec3 rayDirection = vec3((coord), 1);\n    vec4 rotatedDir = normalize(rotateY(-3.0 * mouse.x + iTime * 0.5) * rotateX(3.0 * mouse.y - 0.2) * vec4(rayDirection, 0.0));\n    for (int sceneNum = 1; sceneNum <= rays; sceneNum++) {\n      screenCol += getCol(coord, rotatedDir.xyz, vec3(3.0 * sin(iTime * 0.5), 1.0, 2.0 - 3.0 * cos(iTime * 0.5)), sceneNum);\n    }\n    screenCol /= float(rays);\n    fragColor = vec4(\n        screenCol,\n        1\n    );\n}","name":"Image","description":"","type":"image"}]}