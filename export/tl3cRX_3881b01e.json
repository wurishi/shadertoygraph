{"ver":"0.1","info":{"id":"tl3cRX","date":"1609600936","viewed":60,"name":"Planetes","username":"regis","description":"Planets and water","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","water","planetes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DIST 70.\n#define SURF_DIST .01\n#define EPSILON 0.01\n\nint what = 0;\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat GetDistPlan(vec3 p, vec2 uv){\n    vec4 s = vec4(0,3.5, 7, 0.1);\n    \n    float planeDist = dot(p, vec3(0.0, 1.0, 0.0))-sin(p.x+iTime*2.0)*0.2-cos(p.z+iTime)*0.5+sin(p.y*2.0+iTime*2.0)*0.3;\n           \n    vec3 nc = texture(iChannel0, normalize(uv*-iTime*.03) ).rgb;\n    \n    float d = planeDist - length(noise(uv))*1.5 - length(nc.rgb)*0.1;\n    \n    return d;\n\n}\n\nfloat GetDist(vec3 p, vec2 uv){\n    vec4 s = vec4(0,3.5, 7,1.5);\n    vec4 s2 = vec4(4.0,3.5, 10.0,1.5);\n    \n    float planeDist = dot(p, vec3(0.0, 1.0, 0.0))-sin(p.x+iTime)*0.2+cos(p.z+iTime)*0.05;\n    float sphereDist = length(p-s.xyz)-s.w;\n    float sphereDist2 = length(p-s2.xyz)-s2.w;\n    //float sphereDist = CubeApproxSDF(p, 2.0);\n    \n    vec3 nc = texture(iChannel0, uv*2.-iTime*.03).rgb;\n    \n    //float d = min(sphereDist-length(nc), planeDist-length(nc)*0.1);\n    \n     float d = min(sphereDist, sphereDist2);//-length(nc);\n    return d;\n\n}\n\nfloat RayMarch2(vec3 eye, vec3 viewRayDirection,vec2 uv){\n\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = GetDist(eye + depth * viewRayDirection, uv);\n        if (dist < SURF_DIST) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= MAX_DIST) {\n            // Gone too far; give up\n            return MAX_DIST;\n        }\n    }\n    return end;\n\n\n}\n\nfloat RayMarchPlan(vec3 eye, vec3 viewRayDirection,vec2 uv){\n\n    float depth = 0.0, end = 10.0;\n    for (int i = 0; i < 100; i++) {\n        float dist = GetDistPlan(eye + depth * viewRayDirection, uv);\n        if (dist < SURF_DIST) {\n            // We're inside the scene surface!\n            return depth;\n        }\n        // Move along the view ray\n        depth += dist;\n\n        if (depth >= MAX_DIST) {\n            // Gone too far; give up\n            return MAX_DIST;\n        }\n    }\n    return end;\n\n\n}\n\nvec3 GetNormal(vec3 p, vec2 uv){\n    float d = GetDist(p, uv);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, uv),\n        GetDist(p-e.yxy, uv),\n        GetDist(p-e.yyx, uv));\n        \n    return normalize(n);\n}\n\n\n\nfloat GetLight(vec3 p, vec2 uv){\n    vec3 lightpos = vec3(2.0, 5, -6);\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    \n    vec3 n = GetNormal(p, uv);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch2(p+n*SURF_DIST, l, uv);\n    if(d < length(lightpos-p))dif *= 0.1;\n    return dif ;\n\n}\n\nvec3 GetNormalPlan(vec3 p, vec2 uv){\n    float d = GetDistPlan(p, uv);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistPlan(p-e.xyy, uv),\n        GetDistPlan(p-e.yxy, uv),\n        GetDistPlan(p-e.yyx, uv)*0.9);\n        \n     \n    vec3 tx = texture(iChannel0, uv+iTime*.23 ).rgb*2.0+1.0;\n    n = n*500.0 -tx ;\n        \n    return normalize(n);\n}\n\nfloat GetLightPlan(vec3 p, vec2 uv){\n    vec3 lightpos = vec3(2.0, 5, -6);\n    lightpos.xz += vec2(sin(iTime), cos(iTime));\n    vec3 l = normalize(lightpos-p);\n    \n    \n    vec3 n = GetNormalPlan(p, uv);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarchPlan(p+n*SURF_DIST, l, uv);\n    if(d < length(lightpos-p))dif *= 0.1;\n    return dif ;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n     uv -= 0.5;\n     uv /= vec2(iResolution.y / iResolution.x, 1);\n    col = vec3(0.0);\n    \n    vec3 ro, rd, p;\n    float d , dif;\n    \n         \n     float fresnel = clamp(1.0 - dot(vec3(1.0, 1.0, 0.0),-vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n      \n      \n       ro = vec3(0, 2.0, -5.0);\n     rd = normalize(vec3(uv.x, uv.y, 1));\n    \n     d = RayMarch2(ro, rd, uv);\n     p = ro +rd * d;\n\n     dif =GetLight(p, uv);\n        \n           col += vec3(dif)* vec3(0.2, 1.0, 0.5)*texture(iChannel1, uv*2.-iTime*.01).rgb*2.0 -\n           vec3(dif)*vec3(0.0, 1.0, 1.0) + (vec3(173., 79., 9.)/255.) * vec3(dif);\n       \n       /*2*/\n      ro = vec3(0, 4.0, 3.0);\n      rd = normalize(vec3(uv.x, uv.y, 1));\n    \n      d = RayMarchPlan(ro, rd, uv);\n      p = ro +rd * d;\n    \n      dif =GetLightPlan(p, uv);\n     if (( dif <= 0.08) && ( dif > 0.05) ){\n          col +=  vec3(0.0, 0.8, 1.0);\n      }\n     else if (( dif <= 0.05)&& ( dif > 0.01)){\n         col +=  vec3(0.0, 0.75, 1.0);\n      }\n     else if (( dif <= 0.01) && ( dif > 0.005)){\n         col +=  vec3(0.0, .9, 1.0);\n     }\n     else if ( dif <= 0.005){\n         col +=  vec3(0.0, 1.0, 1.0);\n     \n     }else{\n        col += mix(vec3(0.0, 0.8, 1.0), vec3(dif)* vec3(0.0, 1.0, 1.0), smoothstep(0., 1.0, (dif)));\n       \n     }\n     \n     \n  \n       \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}