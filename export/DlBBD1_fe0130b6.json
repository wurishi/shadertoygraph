{"ver":"0.1","info":{"id":"DlBBD1","date":"1693985709","viewed":74,"name":"world inside torus","username":"Efim","description":"in this shader using analytic functions from shader \"Torus - intersection\" https://www.shadertoy.com/view/4sBGDy . Put cubemaps on torus inside","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","torus","intersection","analyticall"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\nmat3 rotateX(float f)\n{\n    return mat3(\n    vec3(1.0,    0.0,      0.0),\n    vec3(0.0,\t cos(f),  -sin(f)), \t\n\tvec3(.0, sin(f), cos(f))\n    );\n}\n\n\nmat3 rotateZ(float f)\n{\n    return mat3(\n    vec3(cos(f),    -sin(f),  0.0),\n    vec3(sin(f),\t cos(f),  0.0), \t\n\tvec3(0.0, 0.0, 1.0)\n    );\n    \n}\n\n\nmat3 rotateY(float f)\n{\n    return mat3(\n    vec3(cos(f), 0.0,  sin(f)),\n    vec3(0.0,\t 1.0,  0.0), \t\n\tvec3(-sin(f), 0.0, cos(f))\n    );\n}\n\n\nstruct HIT\n{\n    float dist;\n    vec3 nor;\n    vec3 pos;\n};\n\n#define TAU 6.28318530718\nfloat aafi(vec2 p) {\n    float fi = atan(p.y, p.x);\n    fi += step(p.y, 0.0)*TAU;\n    return fi;\n}\n\n//converts a vector on a sphere to longitude and latitude\nvec2 lonlat(vec3 p) {\n    float lon = aafi(p.xy) / TAU;\n    float lat = aafi(vec2(p.z, length(p.xy))) / PI;\n    return vec2(1.0 - lon, lat);\n}\n\nconst float dist_infin = 100000.0;\nconst HIT hit_inf = HIT(100000.0, vec3(0.0), vec3(0.0));\n\n\n\nvec3 culccolor(vec3 col_in, vec3 backcol, vec3 rd, vec3 light, vec3 nor)\n{\n    vec3 col = col_in;\n    float d = dot(rd, nor);\n    if (d < 0.0)\n        col = backcol;\n    \n    nor *= -sign(d);\n    float difu = dot(nor, light);\n    col *= clamp(difu, 0.4, 1.0);\n    return col;   \n}\n\n\n\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\n//analitic function https://www.shadertoy.com/view/4sBGDy\nfloat iTorus( in vec3 ro, in vec3 rd, in vec2 tor )\n{\n    float po = 1.0;\n    \n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n\t\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n\n    // bounding sphere\n    {\n\tfloat h = n*n - m + (tor.x+tor.y)*(tor.x+tor.y);\n\tif( h<0.0 ) return -1.0;\n\t//float t = -n-sqrt(h); // could use this to compute intersections from ro+t*rd\n    }\n    \n\t// find quartic equation\n    float k = (m - ra2 - Ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n + Ra2*rd.z*rd.z + k;\n    float k1 = k*n + Ra2*ro.z*rd.z;\n    float k0 = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    #if 1\n    // prevent |c1| from being too close to zero\n    if( abs(k3*(k3*k3 - k2) + k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n\t#endif\n\n    float c2 = 2.0*k2 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3 - k2) + k1;\n    float c0 = k3*(k3*(-3.0*k3*k3 + 4.0*k2) - 8.0*k1) + 4.0*k0;\n\n    \n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    \n    float Q = c2*c2 + c0;\n    float R = 3.0*c0*c2 - c2*c2*c2 - c1*c1;\n    \n\t\n    float h = R*R - Q*Q*Q;\n    float z = 0.0;\n    if( h < 0.0 )\n    {\n    \t// 4 intersections\n        float sQ = sqrt(Q);\n        z = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n    }\n    else\n    {\n        // 2 intersections\n        float sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n        z = sign(R)*abs( sQ + Q/sQ );\n    }\t\t\n    z = c2 - z;\n\t\n    float d1 = z   - 3.0*c2;\n    float d2 = z*z - 3.0*c0;\n    if( abs(d1) < 1.0e-4 )\n    {\n        if( d2 < 0.0 ) return -1.0;\n        d2 = sqrt(d2);\n    }\n    else\n    {\n        if( d1 < 0.0 ) return -1.0;\n        d1 = sqrt( d1/2.0 );\n        d2 = c1/d1;\n    }\n\n    //----------------------------------\n\t\n    float result = 1e20;\n\n    h = d1*d1 - z + d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -d1 + h - k3; t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=t1; \n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    h = d1*d1 - z - d2;\n    if( h > 0.0 )\n    {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;  t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = d1 + h - k3;  t2 = (po<0.0)?2.0/t2:t2;\n        if( t1 > 0.0 ) result=min(result,t1);\n        if( t2 > 0.0 ) result=min(result,t2);\n    }\n\n    return result;\n}\n\n// df(x)/dx\n//analitic function https://www.shadertoy.com/view/4sBGDy\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n\nHIT giper3D(vec3 ro, vec3 rd, vec2 torus)\n{\n    \n    float dist = iTorus( ro, rd, torus );\n    if( dist>0.0 )\n    {\n        vec3 pos = ro + dist*rd;\n        vec3 nor = nTorus( pos, torus );\n        return HIT(dist, nor, pos);\n    }\n    else\n        return hit_inf;    \n    \n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec3 light = normalize(vec3(0.0, 0.0, -1.0)); //light\n\n\t\t\n    //\n    \n    float t = iTime;\n    vec2 m = vec2(0.0, 0.0);\n    if  (iMouse.z > 0.0)\n      m = (-iResolution.xy + 2.0*(iMouse.xy))/iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 1.5); // camera\n    ro = rotateX(PI/2.0)*ro; //camera rotation\n    light = rotateX(PI/2.0)*light;\n    ro = rotateY(-m.x*TAU)*rotateX(-m.y*PI)*ro; //camera rotation\n    \n    \n    const float fl = 1.5; // focal length\n    float dist = dist_infin;\n    mat3 rota  = rotateZ(t/2.0)*rotateY(0.);\n    mat3 rota_1  = rotateY(0.)*rotateZ(-t/2.0);\n    //mat3 sky = rotateZ(0.0)*rotateX(PI/2.0);\n    \n    vec2 torus = vec2(1.0,0.8);\n    vec3 tot = vec3(0.0);\n    \n    #define AA 2\n    //antiblick\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec3 col = vec3(0.7, 0.7, 0.9); // background        \n            // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n            \n        \n        //vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        //vec3 rd = normalize( vec3(p,fl) ); // ray direction\n        vec3 rd = GetRayDir(p, ro, vec3(0,0.,0), fl); //ray direction\n\n        HIT giper = giper3D(rota*ro, rota*rd, torus);\n        if (giper.dist < dist)\n        {\n            //col = vec3(1.0, 1.0, 0.0);\n            vec3 backcol = vec3(0.0, 1.0, 1.0);\n            vec3 nor = rota_1*giper.nor;\n            //float x = aafi(vec2(giper.pos.x, giper.pos.y))/2.0;\n            //float y = aafi(vec2(torus.x - length(giper.pos.xy), giper.pos.z));\n            float l = abs(torus.x - length(giper.pos.xy));\n            vec3 pos = vec3(giper.pos.x, giper.pos.y, giper.pos.z*length(giper.pos.xy));\n            pos =  rotateX(PI/2.0)*pos;\n            col = texture(iChannel0, pos).rgb;\n            //col = culccolor(col,col, -rd, light, nor);\n            \n        }\n        //col = sqrt( col );\n        tot += col;\n    }\n    //antiblick\n    tot /= float(AA*AA);\n   \n    fragColor = vec4(tot,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}