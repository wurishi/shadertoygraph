{"ver":"0.1","info":{"id":"7tlyD2","date":"1648754812","viewed":79,"name":"Solar System Ray Casting","username":"havenousername","description":"A implementation of ray casting from the practices. Tried to be creative, but ended up with Solar System. \n- Implemented Möller-Tomborne triangle intersection\n- Used material properties for BRDF","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","raycasting","materials","educational","solar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 missColor(vec3 direction) {\n    return vec4(texture(iChannel1, direction).xyz, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (col.w == 0.5) {\n        fragColor = missColor(col.xyz);\n    } else {\n        fragColor = col;\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ---- Global constants and utils ----\n#define PI 3.1415926535897932384626433832795\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n\n// ---- Model objects ----\nstruct Sphere {\n    vec3 center; // center\n    float radius; // radius\n    int material;\n};\n\n\nstruct Plane {\n    vec3 p;\n    vec3 norm;\n    int material;\n};\n\n\nstruct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    int material;\n};\n\n// ---- Visualization structures ----\n\nstruct Ray {\n    vec3 origin;\n    float minDistance; // for omitting solutions where t < tMin\n    vec3 direction; //direction\n    float maxDistance; // for omitting solutions where t > tMax\n};\n\nstruct TraceResult {\n    vec3 norm;\n    float distance;  // Distance taken by the ray \n    int material;\n};\n\n\n\n// ---- BRDF parameters ----\n// ---- More about https://www.sciencedirect.com/topics/engineering/bidirectional-reflectance-distribution-function ----\n// https://www.shadertoy.com/view/llGyRd\nstruct Material {\n    vec3 color;\n    float roughness;\n    vec3 emission;\n    float metalness; \n};\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD + Arrows)\n\nconst int KeyLeft  = 37;\nconst int KeyRight = 39;\nconst int KeyUp    = 38;\nconst int KeyDown  = 40;\nconst int KeyW     = 87;\nconst int KeyS     = 83;\nconst int KeyA     = 65;\nconst int KeyD     = 68;\nconst int KeyStop  = 80;  \n\n\n// ---- Define global Material id for accesing them in array ----\n// Materials\n#define MATERIAL_METAL 0\n#define MATERIAL_METAL_RUSTY 1\n#define MATERIAL_METAL_OPAQUE 2\n#define MATERIAL_DEFAULT 3\n#define MATERIAL_DISNEY_BRIGHT 4\n#define MATERIAL_DISNEY_OPAQUE 5\n#define MATERIAL_GROUND 6\n#define MATERIAL_EMISSIVE 7\n#define MATERIAL_LIGHT_SOURCE 8\n\n#define COLOR_GROUND vec3(266, 266, 266)\n\n// Materials array (add first metal materials, after non-metal, ground, and last emissive ones)\n// (current implementation does not have reflections model, position of the emission objects are hardcoded based on the ray start) \nMaterial materials[] = Material[](\n    // metal materials\n    Material(vec3(0.815, .60418501512, .00180012), 2.53, vec3(0, .0, .0), 0.6),\n    Material(vec3(0.915, .60418501512, .00180012), .03, vec3(0, .0, .0), 1.),\n    Material(vec3(0.615, .60418501512, .00180012), .003, vec3(0, .0, .0), .6),\n    // not-metal materials\n    Material(vec3(35./256., 2./256., 240./256.), .53, vec3(0, .0, .0), 0.2),\n    Material(vec3(2./256., 246./ 256., 27./256.), 2.53, vec3(0., .0, .0), 0.02),\n    Material(vec3(0.515, .00418501512, .00180012), 0.0001, vec3(0, .0, .0), 0.02),\n    // ground materials\n    Material(COLOR_GROUND, .3,vec3(0, .0, .0), 0.2),\n    // emissive materials\n    Material(vec3(216./256., 250./256., 8./256.), 2.53, vec3(1., 1.0, .0), 0.02),\n    Material(vec3(1., 1., 1.), 2.53, vec3(1., 1.0, 1.0), 0.02)\n    \n);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---- Static arrays sizes ----\nconst int spheresNumber = 10;\nconst int trianglesNumber = 1;\nconst int planesNumber = 1;\n\n// ---- Number of current spheres (NOTE: Only spheres creation is testable) ----\n// TODO: Creation methods for all model structures\nint currentSpheresNumber = 0; \n\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n#define EYE_POSITION vec3(-50, 30, 19)\n\n// ---- Flags ----\n// Enable presentation mode : By changing value to 1 can see all types of materials without movement \n#define PRESENTATION_MODE 0\n// Camera: wont move if false\n#define IS_CAMERA_MOVABLE true\n// Camera speed. Make it bigger to move faster though the world\n#define CAMERA_SPEED 0.4\n\n// ---- Flags ----\nSphere spheres[spheresNumber];\nPlane planes[planesNumber];\nTriangle triangles[trianglesNumber];\n\n\n\n// ---- Intersection primivites implementations ----\nTraceResult intersectSphere(Ray ray, Sphere sphere) {\n    vec3 originCenter = ray.origin - sphere.center;\n    \n    // start to solve quadratic equation, since sphere fucntion is (x^2 + y^2) = r;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(originCenter, ray.direction);\n    float c =  dot(originCenter, originCenter) - sphere.radius * sphere.radius;\n    \n    float discriminant =   b * b - 4.0 * a * c;\n    if (discriminant < 0.) {\n        return TraceResult(vec3(0.), ray.maxDistance, sphere.material);\n    }\n    \n    float sqrtDisciminant = sqrt(discriminant);\n    float numerator = -b - sqrtDisciminant;\n    \n    if (numerator < 0.) {\n        numerator = -b + sqrtDisciminant;\n    }\n    \n    float distance = 0.5 * numerator / a;\n    vec3 pos = ray.origin + distance * ray.direction;\n    vec3 norm = normalize(vec3(pos.x, pos.y, pos.z ) - sphere.center);\n    \n    \n    return TraceResult(norm, distance, sphere.material);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane) {\n    float distance = dot(plane.p - vec3(ray.origin.x, ray.origin.y , ray.origin.z * cos(iTime)), plane.norm) / dot(ray.direction, plane.norm);\n    return TraceResult(plane.norm, distance, plane.material);\n}\n\n\n\n// Möller-Tomborne triangle intersection\n// https://www.shadertoy.com/view/MlGcDz\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n#if 0\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rd ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rd ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rd ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n#else\n    // The four determinants above have lots of terms in common. Knowing the changing\n    // the order of the columns/rows doesn't change the volume/determinant, and that\n    // the volume is dot(cross(a,b,c)), we can precompute some common terms and reduce\n    // it all to:\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n#endif    \n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n\n// Used res.x for from triIntersect to create a rectagle intersection\nTraceResult intersectTriangle(Ray ray, Triangle triangle) {\n    vec3 res = triIntersect(ray.origin, ray.direction, triangle.a, triangle.b, triangle.c);\n    vec3 pos = ray.origin + res.x  * ray.direction;\n    vec3 n = normalize(pos-res);\n    \n    if (res.x < 0.) {\n        return TraceResult(vec3(0.), ray.maxDistance, triangle.material);\n    }\n   \n    return TraceResult(n, res.x, triangle.material);\n}\n\n\n\n\n// ---- Raycast algorithm ----\n// can be refactored\nTraceResult raycast(Ray ray) {\n    TraceResult trace = TraceResult(vec3(0), ray.maxDistance, MATERIAL_DEFAULT);\n    \n    int shapesNumber = currentSpheresNumber;\n    #if PRESENTATION_MODE == 1\n        shapesNumber = spheresNumber;\n    #endif\n    for (int i = 0; i < shapesNumber; i++) {\n        TraceResult res = intersectSphere(ray, spheres[i]);\n        \n        if (res.distance < ray.maxDistance && res.distance > ray.minDistance && res.distance < trace.distance) {\n            trace = res;\n        }\n    }\n    \n    \n    for (int i = 0; i < planesNumber; i++) {\n        TraceResult res = intersectPlane(ray, planes[i]);\n        if (res.distance < ray.maxDistance && res.distance > ray.minDistance && res.distance < trace.distance) {\n            trace = res;\n        }\n    }\n    \n    \n    for (int i = 0; i < trianglesNumber; i++) {\n        TraceResult res = intersectTriangle(ray, triangles[i]);\n        \n        if (res.distance < ray.maxDistance && res.distance > ray.minDistance && res.distance < trace.distance) {\n            trace = res;\n        }\n    }\n    \n    return trace;\n}\n\n\n// ---- Camera algoritms, using keyboard and mouse for sheder navigation ----\nRay Camera(vec2 fragCoord, in vec3 eyePosition, out vec3 eye, out vec2 data2) {\n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0, 0), 0).yzw + eyePosition; // camera position \n    data2 = texelFetch(iChannel0, ivec2(1, 0), 0).zw; // spherical coordinates\n    \n    // vectice from data2, current x,y coordinates\n    vec2 uv = abs(data2);\n    \n    // check is mouse was held on last frame\n    if(iMouse.z>0. || data2.x >= 0.)\t\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    // up, down change\n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    // left, right change\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    \n    // get normalized pixel coordinate\n    vec2 px = (fragCoord / iResolution.xy * 2.-1.)*1. * normalize(iResolution.xy);\n    float speed = CAMERA_SPEED;\n    \n    if (IS_CAMERA_MOVABLE) {\n        if (isKeyHeld(KeyLeft) || isKeyHeld(KeyA)) eye -= u * speed;\n        if (isKeyHeld(KeyRight) || isKeyHeld(KeyD)) eye += u * speed;\n        if (isKeyHeld(KeyUp) || isKeyHeld(KeyW)) eye += w * speed;\n        if (isKeyHeld(KeyDown) || isKeyHeld(KeyS)) eye -= w * speed;\n    }\n    \n    \n    // save new state in data2 for mouse held\n    if (iMouse.z>= 0. && IS_CAMERA_MOVABLE) {\n        data2 = abs(data2.xy);\n    } else if (data2.x >= 0. && IS_CAMERA_MOVABLE) {\n        data2 = -mod(uv, 2. * PI);\n    }\n    \n    // ray generation\n    return Ray(eye, 0.5, normalize(w+px.x*u + px.y*v), 500.);\n}\n\n\n// ---- Metalness ----\n// metal influence https://www.shadertoy.com/view/llsXR7\nstruct Rust {\n    vec3 d;\n    vec3 s;\n    float r;\n    float b;\n};\n   \n// Creating rust coloring from texture in iChannel3    \nRust createRust(vec3 normal, vec3 color) {\n    float saturation = 1.0 - min(min(color.r, color.g), color.b) / ((color.r + color.g + color.b) * 0.3333333);\n    vec3 texture = texture(iChannel2, normal.xy * vec2(2.0)).xyz;\n    // Detect rust from metal texture\n    float rust = clamp(2.0 * texture.b - 0.5, 0.0, 1.0);    \n    // Tint diffuse based on color saturation\n    texture = mix(texture, vec3((texture.r + texture.g + texture.b) * 0.33333333), saturation);\n\n    Rust m;\n    // Get metal diffuse\n    m.d = 0.5 * texture * color;             \n    // Boost rust diffuse\n    m.d *= 1.-rust * 0.5;\n    \n    \n    rust = pow(rust, 0.25);\n    // Boost metal specular and take account rust\n    m.s = color * min(vec3(1.0), texture * rust * 1.5);\n\n\n    // Metal reflection is more blurry when rusty\n    m.b = mix(0.0, 1.0, clamp(1.0-rust*1.25, 0.0, 1.0));\n\n    // Reflectiveness coefficient (or base facing reflection)\n    m.r = 0.8;\n    \n    return m;\n}\n\n// end metal \n\n// ---- Colors ----\n\n// Metalness algorithm\nvec3 getMetal(vec3 color, vec3 light, Material mat) {\n    vec3 texture = texture(iChannel2,  sqrt(light.xz * 2.2) * vec2(2.0)).xyz;\n    // Detect rust from metal texture\n    if (mat.metalness >= 0.7) {\n        float met = saturate(mat.metalness);\n        float rust = clamp(1.9 * texture.b - 0.5, 0.0, 1.0);   \n        return mix(vec3(rust), color, abs(met - 1.));\n    }\n    \n    return color;\n}\n\nvec3 getNonMetal(vec3 color, vec3 light) {\n    return vec3(color);\n}\n\nvec3 getColor(vec3 color, int material, vec3 light, vec2 uv) {\n    switch(material) {\n        case MATERIAL_GROUND:\n            return pow(texture(iChannel3, sqrt(light.xy * 1.2) - 0.2).xyz, vec3(1.3));\n            break;\n        case MATERIAL_METAL: return getMetal(color, light, materials[material]);\n        case MATERIAL_METAL_RUSTY: return getMetal(color, light, materials[material]);\n        case MATERIAL_METAL_OPAQUE: return getMetal(color, light, materials[material]);\n        default: return getNonMetal(color, light);\n        break;\n    }\n}\n\n\nbool hasShadow(vec3 p, vec3 light, vec3 lightPos) {\n    Ray shadowRay = Ray(p, 0.001, light, length(lightPos - p));\n    TraceResult shadowRes = raycast(shadowRay);\n    if (shadowRes.distance < shadowRay.maxDistance) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n// ---- brdf algorithm ----\n\n// https://www.shadertoy.com/view/lsXfWS\n// takes the absolutes of the dot product (since we are between -1 and 1)\nfloat minMax(float d) {\n    return max(abs(d),0.0001);\n}\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nvec3 brdf(vec3 p, vec3 n, vec3 eye, vec3 lightPos, vec3 lightCol, vec3 mat) {\n    vec3 k1 = normalize(lightPos - p);\n    vec3 k2 = normalize(eye - p);\n    vec3 h = normalize(k1 + k2);\n    vec3 u = cross(n, vec3(1.0,0.0,0.0));\n    vec3 v = cross(n, u);\n    u = normalize(u);\n    v = normalize(v);\n    \n    // You can tweak n_u,n_v,Rs and the normal bump map \n    // to get different material metal look.\n    float n_u = 10.0;\n    float n_v = 100.0;\n    \n    float nDoth = minMax(dot(n,h));\n    float nDotk1 = minMax(dot(n,k1));\n    float nDotk2 = minMax(dot(n,k2));\n    float hDotu = minMax(dot(h,u));\n    float hDotv = minMax(dot(h,v));\n    float hDotn = minMax(dot(h,n));\n    float hDotk = minMax(dot(h,k1));\n    \n    vec3 Rs = vec3(0.1);\n    vec3 Rd =  mat * lightCol;\n    \n    // fresnal\n    vec3 F = Rs + (vec3(1.0) - Rs) * pow(1.0 - hDotk, 5.0);\n    \n    // specular\n    float specExp = (n_u * sqr(hDotu) + n_v * sqr(hDotv)) / (1.0 - sqr(hDotn));\n    vec3 spec = (sqrt((n_u + 1.0) * (n_v + 1.0)) / 8.0 * PI) *\n        (pow(nDoth, specExp) / (hDotk * max(nDotk1, nDotk2))) * F;\n            \n    // diffuse\n    vec3 diff = ((28.0 * Rd) / (23.0 * PI)) *\n        (vec3(1.0) - Rs) *\n        (1.0 - pow(1.0 - 0.5 * nDotk1, 5.0)) *\n        (1.0 - pow(1.0 - 0.5 * nDotk2, 5.0));\n    \n    diff *= 2.0;\n    \n    return diff + spec;\n}\n\n// end of external resource\n\n\n\n// ---- Main coloring algorithm ----\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos) {\n    vec3 p = ray.origin + ray.direction * tr.distance;\n    vec3 norm = tr.norm;\n    \n    vec3 direction = -ray.direction;\n    vec3 light1 = normalize(lightPos - p);\n    \n    // material \n    Material material = materials[tr.material];\n    \n    if (all(equal(p, light1))) {\n        return vec4(1.);\n    }\n    \n    \n    float cosTheta = max(dot(norm, light1), .0);\n    // diffuse\n    vec3 kDiffuse = material.emission * dot(norm, -direction);\n    \n    vec2 uv = dot(direction, ray.origin) * vec2(.5, 1.);\n    vec3 color = getColor(material.color, tr.material, light1, uv) + 2. *  kDiffuse * dot(norm, ray.direction);\n    \n    // return if the material is the source of light\n    if (material.emission.r > 0. || material.emission.g > 0. || material.emission.z > 0.) {\n        return vec4(color, 1.);\n    }\n   \n    \n    // shadow\n    if (hasShadow(p, light1, lightPos)) {\n        return vec4(0., 0., 0., 1.);\n    }\n    \n    // specular\n    vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.direction;\n    vec3 kSpecular = vec3(material.roughness);\n    \n    vec3 h = normalize(toLight + toEye);\n    float si = pow(clamp(dot(h, norm), 0., 1.), 100.);\n    \n    // sum \n    vec3 col = (color + si * kSpecular) * cosTheta;\n    \n    // metals only\n    if (tr.material < MATERIAL_DEFAULT) {\n     col *= 2.3 * brdf(p, (norm + vec3(cosTheta)) / 2.6, kSpecular, direction, material.color, material.color);\n    }\n    \n    return vec4(col , 1.);\n}\n\n\n// ---- Utils ----\n\n// Testable creator functions \n\nint createSphereModel(vec3 pos, float size, int material) {\n    if (currentSpheresNumber > spheresNumber) return 1;\n    spheres[currentSpheresNumber] = Sphere(pos, size, material);\n    currentSpheresNumber++;\n    return 0;\n}\n\nint changeSphereMaterial(int pos, int material) {\n    if (material > MATERIAL_LIGHT_SOURCE || material < MATERIAL_METAL) return 1;\n    if (pos > currentSpheresNumber) return 1;\n    spheres[pos].material = material;\n    return 0;\n} \n\n\nfloat xPos = 0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    planes[0] = Plane(vec3(0, 0, 100), normalize(vec3(0,1,0)), MATERIAL_GROUND);\n    #if PRESENTATION_MODE\n        spheres[0] = Sphere(vec3(7.,1.,10), 1.f, MATERIAL_METAL_RUSTY);\n        spheres[1] = Sphere(vec3(5,1,10), 1.f, MATERIAL_METAL);\n        spheres[2] = Sphere(vec3(-7,1,14), 1.f, MATERIAL_DEFAULT);\n        spheres[3] = Sphere(vec3(-3,1,14), 1.f, MATERIAL_DISNEY_BRIGHT);\n        spheres[4] = Sphere(vec3(-1,1,14), 1.f, MATERIAL_DISNEY_OPAQUE);\n        spheres[5] = Sphere(vec3(3,1,10), 1.f, MATERIAL_METAL_OPAQUE);\n        spheres[6] = Sphere(vec3(-1,1,10), 1.f, MATERIAL_EMISSIVE);\n        spheres[7] = Sphere(vec3(10., 16., 10.), 1.f, MATERIAL_LIGHT_SOURCE);\n        triangles[0] = Triangle(vec3(8, sin(iTime) * 5. + 2., sin(iTime)), vec3(12, 6, 1), vec3(18, -3, 1), 1);\n    #else\n        createSphereModel(vec3(10.,19.,10),  3., MATERIAL_LIGHT_SOURCE);\n        createSphereModel(vec3(17.,19.,10.),  3., MATERIAL_EMISSIVE);\n        \n        createSphereModel(vec3(20. * cos(iTime * 2.),18.,20. * sin(iTime * 2.)), 0.5f, MATERIAL_METAL);\n        createSphereModel(vec3(14. * cos(iTime * 1.),18.,14. * sin(iTime * 1.) * atan(iTime) + 3.6), 0.5f, MATERIAL_DEFAULT);\n        createSphereModel(vec3(26. * cos(iTime * 1.),18.,14. * smoothstep(0.2, 0.8, sin(iTime *  atan(iTime))) + 3.6), 1.5f, MATERIAL_DISNEY_BRIGHT);\n        \n        createSphereModel(vec3(28. * cos(iTime * 1.),18.,28. *sin(iTime) + 3.6), 1.5f, MATERIAL_DISNEY_OPAQUE);\n        createSphereModel(vec3(58. * cos(iTime * 1.),22.,28. *sin(iTime) + 3.6), 2.5f, MATERIAL_METAL_OPAQUE);\n        xPos += iTimeDelta;\n        triangles[0] = Triangle(vec3(xPos,  29. + xPos, 45. + xPos) * mix(cos(iTime), smoothstep(sin( 0.4), 0., 1.), 0.5), vec3(78, 45, 43) * cos(iTime), vec3(18, 34, 2) * cos(iTime), 1);\n       \n    #endif\n    \n    vec3 eye; vec2 data;\n    Ray ray = Camera(fragCoord, EYE_POSITION, eye, data);\n    \n    TraceResult result = raycast(ray);\n    \n    if (ray.maxDistance <= result.distance) {\n        fragColor = vec4(ray.direction, 0.5);\n    } else {\n        vec4 col = hitColor(ray, result, vec3(10., 14., 10.));\n        col += hitColor(ray, result, vec3(10., 14., 10.));\n        \n        col += hitColor(ray, result, vec3(17., 14., 10.));\n        fragColor = col;\n    }\n    \n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    // motion blur\n    //fragColor = 0.3 * prev + 0.7 * fragColor;\n    //fragColor.w = result.distance;\n    \n    if (fragCoord.x == 0.5 && fragCoord.y == 0.5) {\n        fragColor.yzw = eye - EYE_POSITION;\n    } \n    \n    if (fragCoord.x == 1.5 && fragCoord.y == 0.5) {\n        fragColor.zw = data;\n    } \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}