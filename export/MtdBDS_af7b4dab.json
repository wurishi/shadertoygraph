{"ver":"0.1","info":{"id":"MtdBDS","date":"1540925087","viewed":425,"name":"Dot Noise Triangle","username":"kaiware007","description":"Dot Noise triangle.\nColors change with 4 seasons.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n// cosine_gradient by sp4get\n// https://sp4ghet.github.io/grad/\nconst float TAU = 2. * 3.14159265;\n\nvec4 cosine_gradient(float x,  vec4 phase, vec4 amp, vec4 freq, vec4 offset){\n  phase *= TAU;\n  x *= TAU;\n\n  return vec4(\n    offset.r + amp.r * 0.5 * cos(x * freq.r + phase.r) + 0.5,\n    offset.g + amp.g * 0.5 * cos(x * freq.g + phase.g) + 0.5,\n    offset.b + amp.b * 0.5 * cos(x * freq.b + phase.b) + 0.5,\n    offset.a + amp.a * 0.5 * cos(x * freq.a + phase.a) + 0.5\n  );\n}\n\n#define SPRING_COL(x) cosine_gradient(x, vec4(0.09, 0.52, 0.06, 0.), vec4(0.66, 0.83, 0.17, 0.), vec4(0.32, 0.23, 0.63, 0.), vec4(0.19, 0.50, 0.09, 0.))\n#define SUMMER_COL(x) cosine_gradient(x, vec4(0.34, 0.28, 0.00, 0.), vec4(0.83, 0.61, 0.70, 0.), vec4(1.20, 0.89, 1.03, 0.), vec4(0.45, 0.32, 0.12, 0.))\n#define AUTUMN_COL(x) cosine_gradient(x, vec4(0.55, 0.07, 0.28, 0.), vec4(0.66, 0.92, 1.58, 0.), vec4(0.28, 0.41, 0.19, 0.), vec4(0.61, 0.09, 0.00, 0.))\n#define WINTER_COL(x) cosine_gradient(x, vec4(0.54, 0.41, 0.68, 0.), vec4(1.27, 1.01, 1.32, 0.), vec4(0.36, 0.58, 0.41, 0.), vec4(0.00, 0.09, 0.12, 0.))\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat circle(in vec2 uv, in float radius) {\n    vec2 l = uv - vec2(0.5);\n    return step(length(l) - radius, 0.);\n    //vec2 l = uv - vec2(0.5);\n    //return 1.0 - smoothstep(radius - (radius * 0.1), radius + (radius * 0.1), dot(l,l) * 4.0);\n}\n\nfloat triangle( vec2 p0, vec2 p1, vec2 p2, vec2 p )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, float r, float angle) {\n    float a1 = radians (-30. + angle);\n    float a2 = radians (-150. + angle);\n    float a3 = radians (-270. + angle);\n    \n    vec2 v1 = vec2(cos(a1), sin(a1)) * r;\n    vec2 v2 = vec2(cos(a2), sin(a2)) * r;\n    vec2 v3 = vec2(cos(a3), sin(a3)) * r;\n    \n    return triangle(v1, v2, v3, p);\n}\n\nfloat line( in vec2 p, in vec2 a, in vec2 b,in float t,in float blur)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n\n    float r = t;\n    float bl = blur;\n    float len = d - r;\n    \n    return (len < 0. ? 1. : len < bl ? mix(1., 0., len / bl) : 0.);\n}\n\nvec2 rot(vec2 p, float f){\n    float s=sin(f);float c=cos(f);\n    return p*mat2(c,-s,s,c);\n}\n\nvec3 render(vec2 uv, vec2 fragCoord)\n{\n    float divCount = 32.0;\n    float timeP = iTime;\n    //float timeP = 2.04;\n    //float timeP = 36.34;\n    //float timeP = 55.06;\n    //float timeP = 318.07;\n    //float timeP = 333.11;\n    \n    vec2 divUv = uv * divCount;\n    divUv = fract(divUv);\n    \n    // dot pattern\n    vec2 p1 = divUv;\n    vec2 p2 = fract(divUv + vec2(0.5, 0.5));\n    vec2 gridIndex1 = floor(uv * divCount);\n    vec2 gridIndex2 = floor((uv + vec2(0.5,0.5) / divCount) * divCount);\n    \n    float noiseScale = 0.035;\n    float noiseSpeed = timeP * 0.25;\n    float min_th = 0.1;\n    float max_th = 0.9;\n    float radius = 1.25;\n    //float an1 = smoothstep(min_th, max_th, (snoise(vec3((gridIndex1) * noiseScale + vec2(noiseSpeed, -noiseSpeed) * 0.5, -noiseSpeed)) * 0.5 + 0.5));\n    //float an2 = smoothstep(min_th, max_th, (snoise(vec3((gridIndex2) * noiseScale + vec2(noiseSpeed, -noiseSpeed) * 0.5, -noiseSpeed)) * 0.5 + 0.5));\n    float an1 = snoise(vec3((gridIndex1) * noiseScale + vec2(noiseSpeed, -noiseSpeed) * 0.5, -noiseSpeed)) * 0.5 + 0.5;\n    float an2 = snoise(vec3((gridIndex2) * noiseScale + vec2(noiseSpeed, -noiseSpeed) * 0.5, -noiseSpeed)) * 0.5 + 0.5;\n    \n    float c0 = circle(p1, an1 * radius);\n    float c1 = circle(p2, an2 * radius);\n\tfloat cc = max(c0, c1);\n    \n    float ts = 0.48; // triangle scale\n    //float ts = cos(iTime)*0.5+0.5;\n    \n    // triangle\n    vec2 uv2 = fragCoord/iResolution.xy + vec2(-0.5,-0.5);\n    uv2.x *= iResolution.x / iResolution.y;\t// aspect\n    uv2 = rot(uv2, radians(mod(iDate.w, 60.0) * 6.0));\n    \n    vec2 uv3 = uv2 - vec2(cos(radians(30.)), sin(radians(30.))) * ts;\n    vec2 uv4 = uv2 - vec2(cos(radians(150.)), sin(radians(150.))) * ts;\n    vec2 uv5 = uv2 - vec2(cos(radians(270.)), sin(radians(270.))) * ts;\n    \n    // inner triangle scale\n    float its = ts * 0.25;\n    //float its = ts * (sin(iTime) * 0.1 + 0.25);\n    \n    //float tri1 = 1. - smoothstep(0.0, 0.001, triangle(uv2, ts, 180.));\n    float tri1 = 1. - step(0., triangle(uv2, ts, 180.));\n    float tri = tri1;\n    \n    //uv2 = rot(uv2, iTime * -0.11);\n    uv2 = rot(uv2, -radians(mod(iDate.w, 60.0) * 12.0));\n    \n    // lines\n    vec2 lp1 = vec2(cos(radians(30.)), sin(radians(30.))) * its;\n    vec2 lp11 = lp1 + vec2(cos(radians(240.)), sin(radians(240.))) * ts / its;\n    float l1 = 1. - line(uv2, lp1, lp11, 0.005, 0.0);\n    \n    vec2 lp2 = vec2(cos(radians(150.)), sin(radians(150.))) * its;\n    vec2 lp22 = lp2 + vec2(cos(radians(0.)), sin(radians(0.))) * ts / its;\n\tfloat l2 = 1. - line(uv2, lp2, lp22, 0.005, 0.0);\n\n    vec2 lp3 = vec2(cos(radians(270.)), sin(radians(270.))) * its;\n    vec2 lp33 = lp3 + vec2(cos(radians(120.)), sin(radians(120.))) * ts / its;\n\tfloat l3 = 1. - line(uv2, lp3, lp33, 0.005, 0.0);\n\n    // merge\n    float o = cc * tri * l1 * l2 * l3;\n    \n    float h = snoise(vec3(uv.xy * (snoise(vec3(iTime * 0.1, 980.8, 289.59))*0.5+1.0), timeP * 0.1)) * 0.5 + 0.5;\n    vec3 col = vec3(0.0);\n    \n    if(iDate.y < 2. || iDate.y > 10.)\n    {\n        // Winter\n        col = WINTER_COL(h).rgb;\n    } else if(iDate.y < 5. && iDate.y > 1.)\n    {\n        // Spring\n        col = SPRING_COL(h).rgb;\n    } else if(iDate.y < 8. && iDate.y > 4.)\n    {\n        // Summer\n        col = SUMMER_COL(h).rgb;\n    } else\n    {\n        // Autumn\n        col = AUTUMN_COL(h).rgb;\n    }\n    \n    return col * o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        //vec2 uv = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        fragCoord = fragCoord + o;\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = (fragCoord)/iResolution.xy;\n#else\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n#endif\n\n    \n        uv.x *= iResolution.x / iResolution.y;\t// aspect\n    \n        vec3 col = render(uv, fragCoord);\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // Output to screen\n    fragColor = vec4(tot, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}