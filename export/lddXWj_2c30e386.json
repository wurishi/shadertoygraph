{"ver":"0.1","info":{"id":"lddXWj","date":"1461617133","viewed":135,"name":"7ujuK7ehQST","username":"diegov","description":"spheres","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float epsilon = 0.003;\n\nfloat sceneDistance(vec3 point) {\n    if (point.z > 0.65) {\n        return 0.65 - point.z;\n    }\n    float currMin = 100000000.0;\n    for (int j = 0; j < 10; ++j) {\n        float jf = float(j);\n        vec3 sphereCentre = vec3(sin(iTime / 2.0 + jf) * 0.4, cos(iTime / 3.1 + jf + 0.5) * 0.2, \n                                 cos(sin(iTime / 14.43 + jf * 3.0) * 5.0) * 0.5);\n        float dist = length(point - sphereCentre) - 0.1;\n        currMin = min(currMin, dist);\n    }\n    return min(currMin, 0.65 - point.z);\n}\n\nvec3 getNormal(vec3 point) {\n    return normalize(vec3(sceneDistance(vec3(point.x + epsilon, point.y, point.z)) - \n                          \tsceneDistance(vec3(point.x - epsilon, point.y, point.z)),\n                          sceneDistance(vec3(point.x, point.y + epsilon, point.z)) -\n                          \tsceneDistance(vec3(point.x, point.y - epsilon, point.z)),\n                          sceneDistance(vec3(point.x, point.y, point.z + epsilon)) - \n                          \tsceneDistance(vec3(point.x, point.y, point.z - epsilon))));\n}\n\nbool isLit(vec3 point, vec3 light, vec3 normal) {\n    vec3 direction = normalize(light - point);\n    vec3 curr = point + normal * epsilon * 1.1;\n    \n    for (int i = 0; i < 60; ++i) {\n        float dist = sceneDistance(curr);\n        float lightDist = length(light - curr);\n        if (lightDist < dist) {\n            return true;\n        }\n        if (dist < epsilon) {\n            return false;\n        }\n        curr = curr + direction * dist;\n    }\n    return false;\n}\n\nfloat lightContribution(vec3 point, vec3 light, vec3 normal) {\n    float lightContribution;\n    if (isLit(point, light, normal)) {\n    \tvec3 lightDist = light - point;\n        float lightDivisor = sqrt(1.0 + length(lightDist));\n        lightContribution = clamp(dot(normalize(lightDist), normal) / lightDivisor, 0.0, 1.0);\n    } else {\n    \tlightContribution = 0.0;\n    }\n    return lightContribution;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.y) - vec2(0.75, 0.5);\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    \n\tvec3 direction = normalize(cross(right, up) + vec3(0.5 * uv.x, 0.5 * uv.y, 0.0));\n    \n    float travelled = 0.0;\n    \n    vec3 camera =  vec3(uv / 1.6, -0.8);\n    \n    vec3 light1 = vec3(0.9, 0.5, -1.8);\n    vec3 light2 = vec3(-0.7, 1.5, -1.4);\n    \n    vec3 curr = camera;\n    for (int i = 0; i < 50; ++i) {\n        float dist = sceneDistance(curr);\n        travelled += dist;\n        \n        if (dist < epsilon) {\n            \n            vec3 normal = getNormal(curr);\n            float lightContribution1 = lightContribution(curr, light1, normal);\n            float lightContribution2 = lightContribution(curr, light2, normal);\n            \n            fragColor = vec4(1.0, 0, 0, 1) * (lightContribution1 + lightContribution2) / 1.5;\n            return;\n        }\n        if (travelled > 10.0) {\n            break;\n        }\n        curr = curr + (direction * dist);\n    }\n    \n    fragColor = vec4(0, 0, 0, 1);\n}","name":"Image","description":"","type":"image"}]}