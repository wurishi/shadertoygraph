{"ver":"0.1","info":{"id":"Dd3cz2","date":"1695224814","viewed":216,"name":"Madtracer color accumulation","username":"Virgill","description":"Slowed it down to show the buildup of a frame.\n","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["madtracing"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//***************************************************************************************************\n// madtracer color accumulation\n//***************************************************************************************************\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy/iResolution.xy)*vec2(1.0,-1.0);\n    fragColor = texture(iChannel0, uv);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//***************************************************************************************************\n// madtracer color accumulation\n//***************************************************************************************************\n\n#define ITER 200\n#define EPS 0.05\n\nvec3 scol;\nuint seed ;\nint  frame = 0;\nfloat rot = 0.6;\n\nvoid dmin(inout vec3 d, float x, float y, float z)\n{\n    if(x < d.x) d = vec3(x,y,z);\n}\n\nfloat noise(vec3 p) // from IQ & Shane\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec3 hashHs(vec3 n, uint seed) // from Fizzer\n{\n    float a=(float((seed*0x73491U)&0xf0f0fU)/float(0x100010))*2.-1.;\n    float b=6.283*(float((seed*0xAF71fU)&0xff0f0U)/float(0x101000));\n    float c=sqrt(1.-a*a);\n    vec3 r=vec3(c*cos(b),a,c*sin(b));\n    return r;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat box(vec2 p)\n{ \n    p=abs(p); return max(p.x, p.y); \n}\n\nvoid pR(inout vec2 p,float a) \n{\n\tp = cos(a)*p+sin(a)*vec2(p.y,-p.x);\n}\n\n//***************************************************************************************************\n// map\n//***************************************************************************************************\n\nvec3 map(vec3 p)\n{\n    vec3 d = vec2(0,1.).yxx;\n    float distort = 0.2*noise(10.*p);\n\n    // floor\n    dmin(d,smin(5.-p.z,1.5-p.y,10.),0.1+0.3*step(mod(4.*p.z,1.),.5),.0);\n\n    // sphere\n    vec3 q=p;\n    pR(q.xy,sin(rot)+0.2);\n    dmin(d, length(q+vec3(0.,0.,2.5))-.500, .9, 0.1); \n  \tdmin(d, length(q+vec3(0 ,0.,2.5))-.445-0.09*sin(43.*q.y), 1., 0.1); \n\n    //lattice\n    q = abs(p-round(p-.5)-.5);\n    float g = min(min(box(q.xy), box(q.xz)),box(q.yz))-.05;\n    float c = min(.6-abs(p.x+p.z), .45-abs(p.y));\n    dmin(d, max(g, c), .1, 0.5); \n    \n    // lightbox blue\n    dmin(d, box(p.zx+vec2(2.,2.))-.4-distort, 1., .4); \n    \n    // lightbox orange\n    dmin(d, box(p.zx+vec2(2.,-2.))-.4-distort, 1., -.4); \n\t\n    return d;\n   }\n\nvec3 normal(vec3 p)\n{\n    float m = map(p).x;\n\tvec2 e = vec2(0,EPS);\n\treturn normalize(m-vec3(map(p - e.yxx).x,map(p - e.xyx).x,map(p - e.xxy).x));\n}\n\n \n//***************************************************************************************************\n// madtracer\n//***************************************************************************************************\n\n\nvoid castRay(in vec3 ro1, in vec3 rd1) \n{\n    scol = vec3(0);\t\t// clear color accumulator \n    float t,t2 = 1.;  \n    vec3 m1,m2,rd2,ro2,nor2;\n   \tvec3 roold=ro1;\n\n    for (int i = 0; i < ITER; i++) \n\t{   \n        // antialiasing (could be used for dof)\n        ro1=mix(roold,hashHs(ro1,seed),0.002);\t\t\t\n        m1 = map (ro1+rd1*t);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n        m1.z!=0.?t+=0.25*abs(m1.x)+0.0004:t+=0.25*m1.x;\n        ro2 = ro1 + rd1*t; \n        // normal of new origin\n        nor2 = normal(ro2); \t\t\t\t\t\t\t\t\t\n        // new seed for every iteration\n        seed += uint(i)+uint(iTime*1999.*gl_FragCoord); \t\t\n        // reflect depending on material\n       \trd2 = mix(reflect(rd1,nor2),hashHs(nor2,seed),m1.y);\t\n        m2 = map(ro2+rd2*t2);\n        m2.z!=0.?t2+=0.25*abs(m2.x):t2+=0.25*m2.x;\n        \n        if(i==frame)\n        {\n            // accumulate colors\n            scol=(vec3(1.-m2.z, 1., 1.+m2.z)*step(1.,m2.y) + vec3(1.-m1.z, 1., 1.+m1.z)*step(1.,m1.y));  \n        }\n\t}\n}\n\n//***************************************************************************************************\n// main\n//***************************************************************************************************\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \tseed = uint(fragCoord) ^ uint(fragCoord.y); \n   \tvec3 bufa= texture(iChannel0,uv).xyz;\n    frame = int(mod(float(iFrame),float(ITER)));\n\n   \t// camera\n   \tvec3 ro,rd;\n\tvec2 uv2 = (2.*fragCoord.xy-iResolution.xy)/iResolution.x;\n\tro = vec3(0., -.0,-5.2);\n   \trd = normalize(vec3(uv2, 1));\n    if (frame == 0) \n    {\n        bufa=vec3(0);\n    \n    }\n    rot = floor(float(iFrame) / float(ITER));\n    pR(rd.yz,0.2*sin(rot)+0.2);  \n    pR(rd.yx,rot*0.2*sin(.3));  \n\n   \t// render    \n\tcastRay(ro, rd); \n\tfragColor =vec4(0.01*scol+1.*bufa,0.);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}