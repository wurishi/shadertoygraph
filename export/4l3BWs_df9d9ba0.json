{"ver":"0.1","info":{"id":"4l3BWs","date":"1542381884","viewed":183,"name":"Main Door","username":"Shadeyboi","description":"Main Door of to the school. (With Lighting!)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["environment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nconst float EPSILON = 0.001;\nconst vec3 deltax = vec3(EPSILON, 0., 0.);\nconst vec3 deltay = vec3(0., EPSILON, 0.);\nconst vec3 deltaz = vec3(0., 0., EPSILON);\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n\n    \n//=======================\n// Utility Functions\n//=======================    \n    \nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n} \n    \n// Maximum/minumum elements of a vector \n    \nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n\n// ============================ SHAPES\n\n\n// http://mercury.sexy/hg_sdf/\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*1.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n\n// =========================== COLOR FUNCTIONS\n\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\n\n//============================ MAKING PIECES\n\n\nShape FDoor(vec3 c){\n  Shape shape;\n  shape.dist = 1000.;\n  shape.color = vec4(1.); // Initial Color\n    \n  vec3 d = c; //Door modifer\n  vec3 a1 = c; //Arches\n  vec3 w = c; //Slanted Walls\n  vec3 wi = c; //Windows in Arched space\n  vec3 dw = c; //Door Windows\n  vec3 p = c; //Panels in the door\n  vec3 b = c; //Brick wall\n  vec3 bT = c; //Extra Brick Coverage\n  vec3 h = c; //Hinges\n  vec3 bl = c; //BrickLines\n  vec3 blA = c; //First set of vertical lines\n  vec3 blB = c; //Second set of vertical lines\n    //=====\n    \n    //Physical Door\n    vec4 dColor = vec4(.627, .34, .1, 1.);\n    d.x = abs(d.x)-1.;\n    float door = fBox(d+vec3(0.49, .6, -.3), vec3(.5, 1.2, .7));\n    \n    //Window cutouts in the door\n    float topBarsH = fBox(dw+vec3(0., -1., .39), vec3(.2, .01, .01));\n    dw.x = abs(dw.x)-1.; //These duplicate the windows\n    \n    float topBars1 = fBox(dw+vec3(0.93, -1., .39), vec3(.01, .31, .01));\n    \n    dw.y = -abs(dw.y+.1)-.22;\n    float doorWindows = fBox(dw+vec3(.35, .45, .31), vec3(.12, .2, .1));\n    float dW2 = fBox(dw+vec3(.65, .45, .31), vec3(.12, .2, .1));\n    \n    //Bars inside the windows\n    float dW1Bars1 = fBox(dw+vec3(.32, .45, .4), vec3(.01, .2, .01));\n    float dW1Bars2 = fBox(dw+vec3(.4, .45, .4), vec3(.01, .2, .01));\n    \n    //Horizontal Bars\n    float dW1BarsH = fBox(dw+vec3(.65, .45, .4), vec3(.11, .01, .01));\n    float dW2BarsH = fBox(dw+vec3(.36, .45, .4), vec3(.11, .01, .01));\n    \n    float dW2Bars1 = fBox(dw+vec3(.61, .45, .4), vec3(.01, .2, .01));\n    float dW2Bars2 = fBox(dw+vec3(.69, .45, .4), vec3(.01, .2, .01));\n    \n    //Panelling at the bottom of the door\n    p.x = abs(p.x)-1.;\n    float panel = fBox(p+vec3(.35, 1.15, .4), vec3(.12, .4, .02));\n    float pan2 = fBox(p+vec3(.65, 1.15, .4), vec3(.12, .4, .02));\n    \n    //Hinges and Handles\n    h.x = abs(h.x)-2.;\n    \n    float handleCover = fBox(h+vec3(1.88, 0.63, .305), vec3(.06, .17, .1));\n    float hingeMid = sdCapsule(h+vec3(1., 1., .4), vec3(.0, .3, .0), vec3(.0, .5, .0), .02);\n    \n    h.y = abs(h.y+.6)-1.;\n    float hingeTop = sdCapsule(h+vec3(1., 0.6, .4), vec3(.0, .3, .0), vec3(.0, .5, .0), .02);\n    \n    //=====\n    \n    //Inward-slanted wall\n    vec4 wColor = vec4(.75, .75, .75, 1.);\n    w.x = -abs(w.x);\n    w.xz *= rot(radians(54.));\n    float wall = fBox(w+vec3(.95, .4, -.70), vec3(.51, 1.4, .12));\n    \n    //Bricks\n    vec4 brickColor = vec4(.75, .37, .35, 1.);\n    b.x = abs(b.x)-5.66;\n    float bricks = fBox(b+vec3(2.834, -0.1, .73), vec3(1.5, 2.1, .12));\n    \n    bl.y = repeat(bl.y, .15);\n    bl.x = abs(bl.x)-2.82;\n    float brickLines = fBox(bl+vec3(0., 0., .93), vec3(4., .009, .09));\n    \n\tblA.x = repeat(blA.x, .5);\n    blA.y = repeat(blA.y, .3);\n    float vertLinesA = fBox(blA+vec3(0.25, 0., .78), vec3(.015, .075, .1));\n    \n    blB.x = repeat(blB.x, .5);\n    blB.y = repeat(blB.y+.15, .3);\n    float vertLinesB = fBox(blB+vec3(0., 0., .78), vec3(.012, .075, .1));\n    float vertLines = min(vertLinesA, vertLinesB);\n    \n    //Top Curve of Bricks\n    bT.x = -abs(bT.x)-.43;\n    bT.xy *= bT.x*(.1)+.05+rot(radians(30.));\n    float bTop = fBox(bT+vec3(.12, -2.4, .74), vec3(.85, .5, .11));\n    \n    //=====\n    \n    //Top-Windows arch-space\n    a1.x = -abs(a1.x)-0.43;\n    a1.xy *= a1.x*(.1)+.05+rot(radians(30.));\n    float winArch = fBox(a1+vec3(.03, -1.15, .2), vec3(.9, .4, .2));\n    \n    //Stone-Arch Connecting windows and slanted wall\n    float stoneArch = fBox(a1+vec3(.03, -1.84, .75), vec3(1., .077, .1));\n    \n    //Windows in Arch\n    float tri1 = sdTriPrism(wi+vec3(0., -1.3, .3), vec2(.15, .2));    \n    float outsideWindows = fBox(wi+vec3(0., -.99, .3), vec3(.19, .26, .2));\n    \n    //=====\n    \n    //Dividing bar/Doorframe\n    float bar = fBox(c+vec3(0., -.6, .47), vec3(1.05, .02, .05));\n    \n    float ground = fBox(c+vec3(0., 2.3, .4), vec3(1.4, .5, .45));\n\n    \n    //===================== ADDING PIECES\n    \n    \n    //Combined some parts to save space vertically\n    float doorTotal = min(fOpUnionStairs(door, bar, .1, 3.), fOpUnionStairs(winArch, stoneArch, .4, 7.));\n    float archExtras = min(outsideWindows, tri1);\n    float doorExtras = min(min(doorWindows, dW2), min(panel, pan2));\n    \n    //Adding everything to the frame\n    shape.dist = min(doorTotal, wall); //Adding base doorframe & surrounding shape\n    shape.dist = max(shape.dist, -archExtras);\n    shape.dist = max(shape.dist, -doorExtras);\n    shape.dist = min(shape.dist, min(hingeTop, hingeMid)); //Hinges of Door \n    shape.dist = min(shape.dist, min(handleCover, ground)); //Extra pieces of shader\n    \n    //Combining all Bar lines inside the door windows into one variable\n    float windowBars = min(min(min(dW1Bars1, dW1Bars2), min(dW2Bars1, dW2Bars2)), min(dW1BarsH, dW2BarsH));\n    shape.dist = min(shape.dist, windowBars);\n    shape.dist = min(shape.dist, max(bricks, -min(brickLines, vertLines)));\n    shape.dist = min(shape.dist, max(bTop, -min(brickLines, vertLines)));\n    shape.dist = min(shape.dist, topBarsH);\n    shape.dist = min(shape.dist, topBars1);\n    \n    \n    //===================== COLORS\n    \n    vec4 tan = vec4(.9, .85, .8, 1.);\n    \n    //Brick Wall Colors\n    shape.color = mix(brickColor, shape.color, mixColors(shape.dist, bricks, .0));\n    shape.color = mix(brickColor, shape.color, mixColors(shape.dist, bTop, .0));\n    //shape.color = mix(tan, shape.color, mixColors(shape.dist, brickLines, 0.));\n    \n    //Door Colors\n    shape.color = mix(vec4(0.3), shape.color, mixColors(shape.dist, windowBars, .0));\n    shape.color = mix(vec4(0.), shape.color, mixColors(shape.dist, min(hingeTop, hingeMid), .0));\n    shape.color = mix(vec4(.2), shape.color, mixColors(shape.dist, handleCover, .0));\n    shape.color = mix(dColor, shape.color, mixColors(shape.dist, door, .0));\n    shape.color = mix(dColor, shape.color, mixColors(shape.dist, fOpUnionStairs(door, bar, .1, 3.), 0.));\n    shape.color = mix(dColor, shape.color, mixColors(shape.dist, bar, .0));\n    shape.color = mix(dColor, shape.color, mixColors(shape.dist, winArch, .0));\n    \n    //Gray Stone Colors\n    shape.color = mix(wColor, shape.color, mixColors(shape.dist, min(min(wall, stoneArch), ground), .0));\n                    \n  return shape;\n}\n\n\n//================ MAPPING AND MARCHING\n\n\nShape map(vec3 c){\n  Shape mainEnt = FDoor(c);\n  return mainEnt;\n}\n\nfloat mapDist(vec3 c){\n  Shape mainEnt = FDoor(c);\n  return mainEnt.dist;\n}\n\nvec4 mapColor(vec3 c){\n  Shape mainEnt = FDoor(c);\n  return mainEnt.color;\n}\n\n//================ MARCHING/LIGHTING\n\nfloat trace(vec3 origin, vec3 r){\n  float t = 0.0;\n  float farPlane = 1000.;\n    for (int i = 0; i < 64; ++i){\n        float dist = mapDist(origin + r * t);\n        if(dist < EPSILON || t > farPlane){\n          break;\n      }\n        t += dist;\n    }\n    return t;\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = mapDist(p);\n    return normalize(vec3(\n            mapDist(vec3(p.x + EPSILON, p.y, p.z)) - d ,\n            mapDist(vec3(p.x, p.y + EPSILON, p.z)) - d ,\n            mapDist(vec3(p.x, p.y, p.z + EPSILON)) - d\n            ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l) {\n    return vec3(dot(normalize(l-p), n));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n  float stepSize = 0.01;\n  float t = stepSize;\n  float oc = 0.0;\n  for(int i = 0; i < 10; ++i){\n    float d = mapDist(p + n * t);\n    oc += t - d; // Actual distance to surface - distance field value\n    t += stepSize;\n  }\n\n  return clamp(oc, 0.0, 1.);\n}\n\nvec3 computeColor(vec3 origin, vec3 ray){\n  \n  float t = trace(origin, ray); \n  vec3 p = origin + ray * t; \n  float d = mapDist(p); \n  vec3 normal = computeSurfaceNormal(p);\n\n  vec3 light = vec3(5., 3., -3.);\n  vec3 mat = computeLambert(p, normal, light);\n  float ao = ambientOcclusion(p, normal);\n  mat = mat * (1.0 - ao);\n\n  return mat;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  vec3 cam = vec3(0., 0.075, -5.);\n  vec3 f = normalize(vec3(v, 1.));\n  vec3 scene = cam;\n  fragColor = vec4(0.);\n\n  vec3 fc = computeColor(cam, f);\n  fc *= vec3(mapColor(fc));\n    \n\n  // Output to screen\n  fragColor = vec4(vec3(fc), 1.);\n          \n    \n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.0001){\n      fragColor += c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n  }\n\n}","name":"Image","description":"","type":"image"}]}