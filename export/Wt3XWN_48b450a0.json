{"ver":"0.1","info":{"id":"Wt3XWN","date":"1633701838","viewed":132,"name":"Nano Hex","username":"spalmer","description":"golfing with [url]https://shadertoy.com/view/4scXWS[/url]\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["hexagon","distance","shape","golf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// golfing with Fabrice :)\n\n// ANTIALIASED\n\n/* * /\n// fabrice wins again! 99 ch\nvoid mainImage(out vec4 o, vec2 u) {\n    o = -( max(u = abs(u - (o.xy = .5*iResolution.xy)), 1.73*u.y) + u - o.y ).xxxx;\n}\n/* */\n\n/* */\n// 100 ch by spalmer\nvoid mainImage(out vec4 o, vec2 u) {\n    u = abs(u - (o.xy = .5*iResolution.xy));\n    o -= o - o.y + u.x + max(u.x, 1.73*u.y);\n}\n/* */\n\n/* * /\n// yeah but Fabrice's from https://shadertoy.com/view/4scXWS is aliasy\n// was only 88 ch, before the Big Change to mainImage.  But is now 102 ch by my count!\n// that means... I'm now in the lead?!! wth!\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, U = abs(u+u-R);\n    O = vec4(U.x < min(.5*R, R - U*1.7).y);\n} \n/* */\n\n/* * /\n// 105\nvoid mainImage(out vec4 o, vec2 u) {\n    o = abs(vec4(u,0,0) - .5*iResolution.xyxy);\n    o -= o - o.w + o.x + max(o.x, 1.74*o.y);\n}\n/* */\n\n/* * /\n// 107 ch\nvoid mainImage(out vec4 o, vec2 u) {\n    u = abs(u+u - (o.xy = iResolution.xy));\n    o = vec4(o.y - 2.*max(u.x, .5*u.x+.87*u.y));\n}\n/* */\n\n/* * /\n// now 109 ch  :(\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy, U = abs(u+u-R); O = vec4(\n        .5*R.y - max(U.x, .5*U.x+.87*U.y) );\n}\n/* */\n\n/* * /\n// 168 ch\n// and now for something completely different!  meh, I give up for now, not working out.\nvoid mainImage(out vec4 o, vec2 u) {\n    o = abs(vec4(u,0,0) - .5*iResolution.xyxy);\n    //mat2 m = mat2(.87,.5,-.5,.87); // 30 degrees\n    mat2 m = mat2(.5,.87,-.87,.5); // 60 degrees\n    o.xy *= m; // rotate\n    o.y = abs(o.y); //o = abs(o); //o.xy = abs(o.xy); // mirror again\n    o.xy *= transpose(m); // unrotate\n    o.x -= o.w; // relative corner\n    o = vec4(o.xy,0,0);\n    //o -= o + o.x;\n    //o -= o - length(o.xy) * sign(o.x);\n}\n/* */\n\n// from before anti-macro-hack change\n//#define mainImage(O, u) vec2 R = iResolution.xy, U = abs(u+u-R); O = vec4 \\\n//( .5*R.y - max(U.x, .5*U.x+.87*U.y) ) // 96\n//( .5*R.y - max(U.x, .5*U.x+.9*U.y) ) // 95 ! if use .9 instead of .87\n//( .5*(R.y - max(2.*U.x, U.x+1.7*U.y)) ) // 98 // Fabrice used this truncated constant so so can I\n//( min( .5*R ,R - U*1.7 ).y - U.x)  // 89 Fabrice's, converted back to SDF-ish mode\n//( R.y > U.x+max(U.x, 1.7*U.y) ) // 90 // aliased version since scale is wrong anyway\n//( R.y - max(2.*U.x, U.x+1.7*U.y) ) // 95 // lost the *.5 correction factor, can't visually tell very easily\n//( .5*R.y - max(U.x, .5*(U.x+U.y*1.8)) ) // 98\n//( .5*R.y - max(U.x, dot(U, vec2(.5,.9))) ) // 100 even\n//( .5*R.y - max(U.x, dot(U, vec2(.5,.85))) ) // 101\n//( .5*R.y - max(U.x, .5*dot(U, vec2(1,1.8))) ) // 103\n/**/\n\n// doesn't help, but if divide by R.y, no longer need R for some methods:\n// ALIASY, NORMALIZED COORDINATES\n/*\n#define mainImage(O, u) vec2 R = iResolution.xy, U = abs(u+u-R)/R.y; O = vec4 \\\n( U.x < min(.5, 1.-1.7*U.y) ) // 92\n//( U.x < min(.5, 1.-1.7*U.y) ) // 92, so guess it's not really an improvement (yet)\n/**/\n\n// ALIASY or at least bad or underscaled gradients; iso==0 close enough\n/*\n#define mainImage(O, u) vec2 R = iResolution.xy, U = abs(u+u-R); O = vec4 \\\n  ( R.y > U.x+max(U.x, 1.7*U.y) ) // 90 // aliased version since scale is wrong anyway - look how little it depends on R!\n//  ( U.x < min(.5*R, R-U*1.7).y )  // 89 Fabrice's - could swear I saw it say 88 once though\n//  ( min(.5*R, R - U*1.7).y - U.x )  // 89 Fabrice's, converted back to SDF-ish mode\n//\t( R.y - max(2.*U.x, U.x+1.7*U.y) ) // 95 // lost the *.5 correction factor, can't visually tell very easily\n//  ( R.y/U.x > 1.+max(1., 1.7*U.y/U.x) ) // 96 // aliased version didn't optimize down as hoped\n//  ( .5*R.y > max(U.x, .5*U.x+.87*U.y) )  // 96 avoid parens? hmm got a .5 back\n//  ( dot(U, vec2(1., 1.7)) ) // ? just gonna start over :(\n/**/\n\n\n// retrying with normalized U since it's ALIASY anyway\n// meh, no luck with the macro today.\n//#define U O.xy\n//#define mainImage(O, u) U = iResolution.xy; U = abs(u+u-U)/U.y; O = vec4 \\\n//  ( max(O.x, .5*O.x+.87*O.y) < .5 )  // 100! worse\n//  ( .5 > max(q.x, .5*q.x+.87*q.y) )  // 96 still - dang fp literals are not concise, channel accessors too\n\n\n// TODO should try to do a better macro anyway; StoQ-ish\n// for one thing, since we declare R, but then after using it, it's no longer needed,\n// we could get rid of U and re-use the R variable instead\n// Nope, it's still 92, same!  I like it, though.\n// NORMALIZED twist on the ALIASY macro\n/*\n#define mainImage(O, u) vec2 q = iResolution.xy; q = abs(u+u-q)/q.y; O = vec4 \\\n( q.x < min(.5, 1.-1.7*q.y) ) // 92\n/**/\n\n// had so many problems with the errors when using macros that \n// I made this section just in case, for debugging expressions\n\n/*\nvoid mainImage(out vec4 O,vec2 u)\n{\nvec2 R = iResolution.xy, U = abs(u+u-R)/R.y; O = vec4\n( U.x < min(.5, 1.-1.7*U.y) ) // shows 105 in this method vs 92 in macro method\n; // so the count is 105-92=13 over what it should be due to void function decl\n}\n/**/\n\n/*\nvoid mainImage(out vec4 O,vec2 u)\n{\nvec2 R = iResolution.xy, U = abs(u+u-R); O = vec4\n(U.x < min(.5*R, R-U*1.7).y ) // 102 here vs 89 in macro\n; // so the count is 102-89=13 over what it should be due to void function decl\n}\n/**/\n\n// Fabrice's other old entrants: need some assimilation or different host macro:\n//U = abs(U+U - (O.xy=iResolution.xy)) / O.y;\n//O = vec4 ( U.x < .5 && U.x + U.y*1.7 < 1. );                     // 103 aliased - Greg idea\n//O = vec4(max (U.x, U.x*.5+U.y*.87 ) < .5);                       // 107 aliased - Fab\n//U = smoothstep(.51,.5,U*mat2(1,0,.5,.87)); O += min(U.x,U.y) -O; // 130 smooth\n//U *= mat2(2,0,1,1.7); U=1./U/U/U/U; O += min(U.x,U.y) -O;        // 122 blurry\n//U *= mat2(2,0,1,1.7); O += 1./max(U.x,U.y) -O;                   // 112 blurry2\n//O += sin(1e2*max(U.x, U.x*.5+U.y*.87))-O;                        // 110 concentric\n\n/* * /\n// just a disc by itself is 85 ch\nvoid mainImage(out vec4 O, vec2 u) \n{\n    O.xyz = iResolution; O = vec4(.5*O.y - length(u + u - O.xy));\n}\n// FIXME gamma is wrong on antialiasing but idc\n/* */\n\n// Took my hex from https://shadertoy.com/view/3lG3Wh\n// that I had just slapped together for that, and it's already\n// fairly competitive.  I think if I actually worked at\n// actually golfing it, I could get down thereabouts.  Fun!\n// ok, another issue is that his hexagon is actually rotated\n// versus mine; that's easy enough to fix, just swap x and y.\n// also I had to tune my .86602 not only to shorten it, but\n// to match his hacked aspect ratio scale that resulted in slightly\n// shorter shape.  .86602 * 2 = 1.73204, he truncated to 1.7 \n \n/* */","name":"Image","description":"","type":"image"}]}