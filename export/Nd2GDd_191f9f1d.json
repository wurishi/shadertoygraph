{"ver":"0.1","info":{"id":"Nd2GDd","date":"1618155072","viewed":134,"name":"Render 2D light - Part 3","username":"johnao","description":"Inspired by https://github.com/miloyip/light2d.\n\nPart 1: Basic shapes and operations https://www.shadertoy.com/view/Ndj3Dt\nPart 2: Reflection https://www.shadertoy.com/view/fs23Wd\nPart 3: Refraction https://www.shadertoy.com/view/Nd2GDd","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["2d","light"],"hasliked":0,"parentid":"fs23Wd","parentname":"Render 2D light - Part 2"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord+.5*vec2(max(0.,iResolution.y-iResolution.x),max(0.,iResolution.x-iResolution.y)))/max(iResolution.x,iResolution.y);\n    vec4 data=texture(iChannel0,uv);\n    vec3 col=data.xyz/data.w;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// sampling directions\n#define N_DIRECTION 32\n#define fN_DIRECTION 32.\n\n// constants\n#define PI 3.1415926535\n#define TAU 6.2831853\n#define MAX_DISTANCE 2.\n#define MAX_DEPTH 3\n#define MAX_STEP 64\n#define BIAS 1e-4\n#define EPSILON 1e-6\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453);\n}\n\nfloat rand(float co){\n    return fract(sin(co*12.9898)*43758.5453);\n}\n\nvec4 opUnion(vec4 a,vec4 b){\n    return a.x<b.x?a:b;\n}\n\nvec4 opIntersect(vec4 a,vec4 b){\n    return a.x<b.x?vec4(b.x,a.yzw):vec4(a.x,b.yzw);\n}\n\nvec4 opSub(vec4 a,vec4 b){\n    return a.x>-b.x?vec4(a.x,a.yzw):vec4(-b.x,a.yzw);\n}\n\nvec4 opComp(vec4 a){\n    return vec4(-a.x,a.yzw);\n}\n\nfloat sdfCircle(vec2 c,float r,vec2 p){\n    return length(p-c)-r;\n}\n\nfloat sdfPlane(vec2 a,vec2 n,vec2 p){\n    return dot(p-a,n);\n}\n\nfloat sdfCapsule(vec2 a,vec2 b,float r,vec2 p){\n    vec2 ap=p-a,ab=b-a;\n    return length(ap-ab*clamp(dot(ap,ab)/dot(ab,ab),0.,1.))-r;\n}\n\nfloat sdfOrientedBox(vec2 a,vec2 b,float th,vec2 p){\n    float l=length(b-a);\n    vec2 d=(b-a)/l;\n    vec2 q=(p-(a+b)*.5);\n    q=mat2(d.x,-d.y,d.y,d.x)*q;\n    q=abs(q)-vec2(l,th)*.5;\n    return length(max(q,0.))+min(max(q.x,q.y),0.);\n}\n\nvec4 map(vec2 p){\n    // (sdf, emission, reflectivity, eta)\n    \n    /*\n    vec4 res=vec4(sdfCircle(vec2(-.2,1.2),.1,p),10.,0.,0.);\n    res=opUnion(res,vec4(sdfOrientedBox(vec2(.2,.5),vec2(.8,.5),.4,p),0.,.2,1.5));\n    */\n    vec4 res=vec4(sdfCircle(vec2(.5,1.5),.05,p),20.,0.,0.);\n    res=opUnion(res,opIntersect(vec4(sdfCircle(vec2(.5,.3),.25,p),0.,0.2,1.5),vec4(sdfCircle(vec2(.5,.7),.25,p),0.,0.2,1.5)));\n    \n    return res;\n}\n\nvec2 gradient(vec2 p){\n    vec2 eps=vec2(1e-4,0.);\n    return normalize(vec2(map(p+eps).x-map(p-eps).x,map(p+eps.yx).x-map(p-eps.yx).x));\n}\n\nfloat fresnel(float cosi, float cost, float etai, float etat) {\n    vec2 r = vec2((etat * cosi - etai * cost) / (etat * cosi + etai * cost),(etai * cosi - etat * cost) / (etai * cosi + etat * cost));\n    return dot(r,r) * .5;\n}\n\nfloat trace(vec2 ro,vec2 rd,float seed){\n    float t=1e-3;\n    float sum=0.;\n    float c_ref=1.;// discount of reflection\n    float c_sign=map(ro).x>0.?1.:-1.;// sign\n    for(int depth=0;depth<MAX_DEPTH;++depth){\n        bool ref=false;\n        for(int i=0;i<MAX_STEP&&t<MAX_DISTANCE;++i){\n            vec2 p=ro+t*rd;\n            vec4 res=map(p);\n            if(res.x*c_sign<EPSILON){\n                sum+=c_ref*res.y;\n                vec2 n=gradient(p)*c_sign;\n                c_ref*=2.;\n                if(res.w>0.){\n                    vec2 r=refract(rd,n,c_sign<0.?res.w:1./res.w);\n                    float cosi=-dot(rd,n);\n                    float cost=-dot(r,n);\n                    res.z=c_sign<0.?fresnel(cosi,cost,res.w,1.):fresnel(cosi,cost,1.,res.w);\n                    t=1e-3;\n                    ref=true;\n                    if(rand(float(depth)+seed)<.5){// randomly choose between refraction and reflection\n                        c_ref*=1.-res.z;\n                        if(dot(r,r)>.1){\n                            ro=p-n*BIAS;\n                            rd=r;\n                            c_sign*=-1.;\n                        }else{// total internal reflection\n                            ro=p+n*BIAS;\n                            rd=reflect(rd,n);\n                        }\n                    }else{\n                        ro=p+n*BIAS;\n                        rd=reflect(rd,n);\n                        c_ref*=res.z;\n                    }\n                }else if(res.z>0.){\n                    t=1e-3;\n                    ro=p+n*BIAS;\n                    rd=reflect(rd,n);\n                    c_ref*=res.z;\n                    ref=true;\n                }\n                break;\n            }\n            t+=res.x*c_sign;\n        }\n        if(!ref){\n            break;\n        }\n    }\n    return sum;\n}\n\nfloat sampling(vec2 p){\n    float s=0.;\n    float n=rand(p)+iTime;\n    for(int i=0;i<N_DIRECTION;++i){\n        n+=1.;\n        s+=trace(p,vec2(sin(n*TAU/fN_DIRECTION),cos(n*TAU/fN_DIRECTION)),n);\n    }\n    return s/fN_DIRECTION;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec2 uv=fragCoord/iResolution.xy;\n    float s=sampling(uv);\n    vec4 data=texture(iChannel0,uv);\n    if(iFrame==0){\n        data=vec4(0.);\n    }\n    data+=vec4(vec3(s),1.);\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}