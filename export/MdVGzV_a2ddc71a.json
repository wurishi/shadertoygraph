{"ver":"0.1","info":{"id":"MdVGzV","date":"1455473876","viewed":124,"name":"distance field shape calc","username":"ypn","description":"distance field floor","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["distancefieldfloor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TWO_PI 6.28318530718\n#define t iTime\n#define res iResolution.xy\n\nvec3 cpos = vec3(0.0, 0.0, 5.0);\nvec3 cdir = normalize(-cpos);\nvec3 cside = vec3(1.0, 0.0, 0.0);\nvec3 cup  = cross(cside, cdir);\nvec3 light = normalize(vec3(0.1, 0.2, 1.0));\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat opS( float d1, float d2 ){\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nfloat opI( float d1, float d2 ) {\n    return max(d1,d2);\n}\n\nfloat box( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat dist(vec3 p){\n    vec3 p0 = rotate(p, t * 2., vec3(0.0,1.0,0.0)) + vec3(-1.0, 0.0,0.0);\n    vec3 p1 = rotate(p, t, vec3(0.0,1.0,0.0)) + vec3(1.0, 0.0,0.0);\n    float d = 100.0;\n    d = opI(box(p0, vec3(1.2)),\n                opU(box(p, vec3(0.8))\n                    , box(p1, vec3(0.8))\n               \t)\n           );\n    return d;\n}\n\n\nvec3 norm(vec3 p){\n\tvec2 d = vec2(0.001, 0.0);\n    float di = dist(p);\n\treturn normalize(vec3(di - dist(p - d.xyy), di - dist(p - d.yxy), di - dist(p - d.yyx)));\n}\n\nfloat shadow(vec3 o, vec3 d){\n    o += norm(o) * 0.001;\n\tfloat len = 0.0, lev = 1.0;\n\tfor(float t = 0.0; t < 32.0; t++){\n\t\tfloat di = dist(o + d * len);\n\t\tif (di < 0.001){ return 0.5;}\n\t\tlev = min(lev, di  * 24.0 / min(len, 1.0));\n\t\tlen += di;\n\t}\n\treturn max(0.5, lev) ;\n}\n\nvec3 phong(vec3 p, vec3 ray) {\n    vec3 n = norm(p);\n    return vec3(0.2,0.2,0.2) * clamp(dot(light, n), 0.0, 1.0)\n\t\t+ pow(clamp(dot(normalize(light - ray), n), 0.0, 1.0), 256.0) * 0.2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - res) / min(res.x, res.y);\n\tvec3 ray = normalize(cside * p.x + cup * p.y + cdir * 2.0);\n\n\tfloat len = 0.0, di;\n\tvec3 rhead = cpos;\n\tfor(int i = 0; i < 64; i++){\n\t\tdi = dist(rhead);\n        if (abs(di) < 0.001) {\n            break;\n        }\n\t\tlen += di;\n\t\trhead = cpos + len * ray;\n\t}\n\n\tvec3 color = vec3(1.0);\n\tif(abs(di) < 0.001){\n        color = phong(rhead, ray) * shadow(rhead, light);\n\t} \n\tfragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}