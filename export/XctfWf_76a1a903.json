{"ver":"0.1","info":{"id":"XctfWf","date":"1733575402","viewed":74,"name":"Canny edge detector","username":"Nasoohu","description":"I made a canny edge detector","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["edgedetector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Convert the input color to grayscale using the luminosity method\nvec3 toGrayscale(vec3 color) {\n    float gray = dot(color, vec3(0.299, 0.587, 0.114)); // Luminosity weights\n    return vec3(gray); // Return as a grayscale color (vec3)\n}\n\n// Gaussian blur (simplified with a 3x3 kernel for demonstration)\nvec3 gaussianBlur(vec2 uv, vec2 texel) {\n    vec3 result = vec3(0.0);\n    float weight[3] = float[](0.25, 0.5, 0.25); // Simplified 1D kernel\n\n    // Apply horizontal blur (3x3)\n    for (int i = -1; i <= 1; i++) {\n        result += texture(iChannel0, uv + texel * float(i)).rgb * weight[i + 1];\n    }\n\n    return result;\n}\n\n// Sobel operator to detect gradients in the image (horizontal and vertical)\nvec2 sobelGradient(vec2 uv, vec2 texel) {\n    float Gx = 0.0;\n    float Gy = 0.0;\n\n    // Sobel kernels for X and Y directions (written out instead of using arrays of arrays)\n    Gx += texture(iChannel0, uv + texel * vec2(-1.0, -1.0)).r * -1.0;\n    Gx += texture(iChannel0, uv + texel * vec2(0.0, -1.0)).r * 0.0;\n    Gx += texture(iChannel0, uv + texel * vec2(1.0, -1.0)).r * 1.0;\n    Gx += texture(iChannel0, uv + texel * vec2(-1.0, 0.0)).r * -2.0;\n    Gx += texture(iChannel0, uv + texel * vec2(0.0, 0.0)).r * 0.0;\n    Gx += texture(iChannel0, uv + texel * vec2(1.0, 0.0)).r * 2.0;\n    Gx += texture(iChannel0, uv + texel * vec2(-1.0, 1.0)).r * -1.0;\n    Gx += texture(iChannel0, uv + texel * vec2(0.0, 1.0)).r * 0.0;\n    Gx += texture(iChannel0, uv + texel * vec2(1.0, 1.0)).r * 1.0;\n\n    Gy += texture(iChannel0, uv + texel * vec2(-1.0, -1.0)).r * -1.0;\n    Gy += texture(iChannel0, uv + texel * vec2(-1.0, 0.0)).r * -2.0;\n    Gy += texture(iChannel0, uv + texel * vec2(-1.0, 1.0)).r * -1.0;\n    Gy += texture(iChannel0, uv + texel * vec2(0.0, -1.0)).r * 0.0;\n    Gy += texture(iChannel0, uv + texel * vec2(0.0, 0.0)).r * 0.0;\n    Gy += texture(iChannel0, uv + texel * vec2(0.0, 1.0)).r * 0.0;\n    Gy += texture(iChannel0, uv + texel * vec2(1.0, -1.0)).r * 1.0;\n    Gy += texture(iChannel0, uv + texel * vec2(1.0, 0.0)).r * 2.0;\n    Gy += texture(iChannel0, uv + texel * vec2(1.0, 1.0)).r * 1.0;\n\n    return vec2(Gx, Gy); // Return the gradient vector (Gx, Gy)\n}\n\n// Calculate the magnitude and direction of the gradient\nvec2 calculateMagnitudeDirection(vec2 grad) {\n    float magnitude = length(grad); // Compute the magnitude (gradient strength)\n    float direction = atan(grad.y, grad.x); // Calculate the direction (angle) in radians\n    return vec2(magnitude, direction); // Return both magnitude and direction\n}\n\n// Apply edge thresholds to classify pixels as strong or weak edges\nvec3 applyThreshold(float magnitude, float lowThreshold, float highThreshold) {\n    if (magnitude > highThreshold) {\n        return vec3(1.0); // Strong edge (white)\n    } else if (magnitude > lowThreshold) {\n        return vec3(0.5); // Weak edge (gray)\n    } else {\n        return vec3(0.0); // No edge (black)\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (0.0 to 1.0)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 texel = 1.0 / iResolution.xy; // Size of one texel in UV space\n\n    // Convert the image to grayscale (to simplify processing)\n    vec3 gray = toGrayscale(texture(iChannel0, uv).rgb);\n\n    // Apply Gaussian Blur (for simplicity, we use a basic 3x3 filter here)\n    vec3 blurred = gaussianBlur(uv, texel);\n\n    // Compute the gradient using Sobel operator\n    vec2 grad = sobelGradient(uv, texel);\n    vec2 mag_dir = calculateMagnitudeDirection(grad);\n\n    // Apply edge thresholding\n    float lowThreshold = 0.1;\n    float highThreshold = 0.3;\n    fragColor = vec4(applyThreshold(mag_dir.x, lowThreshold, highThreshold), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}