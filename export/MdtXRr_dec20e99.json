{"ver":"0.1","info":{"id":"MdtXRr","date":"1457497593","viewed":275,"name":"Globby Gyroscope","username":"zackpudil","description":"Update: Removed goofy floor pattern. Removed reflection.  Updated to look like a spin top doing it's thang.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","brokendistancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float neLength(vec2 p, float l) {\n    return pow(\n        pow(abs(p.x), l) + pow(abs(p.y), l)\n    \t, 1.0/l);\n}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat dTorus(vec3 p, vec2 t) {\n    vec2 d = vec2(length(p.xz) - t.x, p.y);\n    return length(d) - t.y;\n}\n\nfloat dCircleTorus(vec3 p, vec2 t) {\n    vec2 d = vec2(length(p.xz) - t.x, p.y);\n    return neLength(d, 8.) - t.y;\n}\n\nfloat dBoxTorus(vec3 p, vec2 t) {\n    vec2 d = vec2(neLength(p.xz, 8.) - t.x, p.y);\n    return neLength(d, 8.) - t.y;\n}\n\nfloat dSegment(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\n\nvec2 opU(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nvec2 map(vec3 p) {\n\tvec2 p1 = vec2(p.y + 2.4, 0.0);\n    p.y -= .6;\n\trotate(p.xz, iTime);\n    p.x -= 2.5;\n    rotate(p.xy, 0.3*cos(2.0*iTime));\n\n    vec2 w = vec2(dSphere(p, .70 - 0.1*sin(10.0*p.x + 5.0*iTime)*sin(10.0*p.y)*sin(10.0*p.z + 5.0*iTime)), 1.0);\n    float radius = .15 - 0.1*smoothstep(2.3, 2.4, p.y > 0. ? p.y : abs(p.y + .4));\n    vec2 sp = vec2(dSegment(p, vec3(0, 2.4, 0), vec3(0, -3.0, 0), radius), 7.0);\n    rotate(p.zy, 3.14/2.0);\n    vec2 bt = vec2(dCircleTorus(p, vec2(1, .08)), 2.0);\n    for(int i = 0; i < 4; i++) {\n        rotate(p.xy, iTime + float(i));\n        p = p/1.2;\n        vec2 bts = vec2(dCircleTorus(p, vec2(1, 0.08))*1.2, 3.0 + float(i));\n        bt = opU(bt, bts);\n    }\n    \n    return opU(p1, opU(opU(w, sp), bt));\n}\n\nvec2 spheretrace(vec3 ro, vec3 rd, float tmin, float tmax) {    \n    float td = tmin;\n    float mid = -1.0;    \n    \n    for(int i = 0; i < 256; i++) {\n        vec2 s = map(ro + rd*td);\n        \n        if(abs(s.x) < 0.001 || td > tmax) break;\n        \n        td += s.x*0.5;\n        mid = s.y;\n    } \n    \n    if(td > tmax) mid = -1.0;\n    return vec2(td, mid);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.01, 0.0);\n    vec3 n = vec3(\n        map(p + h.xyy).x - map(p - h.xyy).x,\n        map(p + h.yxy).x - map(p - h.yxy).x,\n        map(p + h.yyx).x - map(p - h.yyx).x\n    );\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 l) {\n    float res = 1.0;\n    float td = 0.02;\n    \n    for(int i = 0; i < 256; i++) {\n        float h = map(p + l*td).x;\n        td += h*0.5;\n        res = min(res, 32.0*h/td);\n        if(abs(h) < 0.001 || td > 25.0) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 lighting(vec3 p, vec3 lp, vec3 rd) {\n    vec3 lig = normalize(lp);\n    vec3 n = normal(p);\n    vec3 ref = reflect(lig, n);\n    \n    float amb = clamp(0.7 + 0.3*abs(n.y), 0.0, 1.0);\n    float dif = clamp(dot(n, lig), 0.0, 1.0);\n    float spe = pow(clamp(dot(rd, ref), 0.0, 1.0), 52.0);\n    \n    dif *= shadow(p, lig);\n    \n    vec3 lin = vec3(0);\n    \n    lin += 0.4*amb*vec3(1);\n    lin += dif*vec3(1, .97, .85);\n    lin += spe*vec3(1, .97, .54);\n    \n    return lin;\n}\n\nvec3 material(float mid, vec3 p) {\n    vec3 col = vec3(1.);\n    \n    if(mid == 0.0) {\n        vec2 a = vec2(1)*smoothstep(-0.15, 0.15, mod(p.x, 2.))*smoothstep(-0.15, 0.15, mod(p.z, 2.));\n        col = vec3(a, 1);\n    }\n    \n    if(mid == 1.0) {\n        col = vec3(.2, .8, .001);\n    }\n    \n    if(mid >= 2.0 && mid < 7.0) {\n        col = mix(\n            vec3(1, .1, .1),\n            vec3(.1, .1, 1),\n            cos(mid + iTime));\n    }\n    \n    if(mid == 7.0) col = vec3(.65);\n    \n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 lp) {\n    vec2 i = spheretrace(ro, rd, 0.0, 25.0);\n    vec3 p = ro + rd*i.x;\n    vec3 m = material(i.y, p);\n    if(i.y == -1.0) return m;\n    \n    m *= lighting(p, lp, rd);\n    \n    return m;\n}\n\nmat3 camera(vec3 e, vec3 l) {\n    vec3 rl = vec3(0, 1, 0);\n    vec3 f = normalize(l - e);\n    vec3 r = normalize(cross(rl, f));\n    vec3 u = normalize(cross(f, r));\n    \n    return mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0+2.0*(fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float s = 0.;\n    if(iMouse.z > 0.) {\n        s = 0.01*iMouse.x;\n    } else {\n        s = 3.1;\n    }\n    \n    vec3 ro = 5.0*vec3(cos(s), 0.8, -sin(s));\n    vec3 rd = camera(ro, vec3(0))*normalize(vec3(uv, 2.0));\n    \n    vec3 lp = vec3(.75, .75, 0);\n    \n    vec3 rend = render(ro, rd, lp);\n    rend = pow(rend, vec3(.4545));\n    fragColor = vec4(rend, 1.0);\n}","name":"Image","description":"","type":"image"}]}