{"ver":"0.1","info":{"id":"4tGczm","date":"1535560232","viewed":652,"name":"Electric [rough]","username":"Hadyn","description":"Just wanted to try out a couple of ideas! Code is the result of experimentation without any cleanup whatsoever, so it's super rough / contains redundant vestigial stuff (sorry!).","likes":26,"published":1,"flags":0,"usePreview":1,"tags":["experiment","voronoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on original code by by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/ldl3W8\n// https://iquilezles.org/articles/voronoilines\n\n// Modified by hadyn lander\n\n#define PHASE_POWER 2.0\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 o;\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\tfloat oldDist;\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\t\n    oldDist = md;\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, oldDist );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.yy;\n    float pauseFreq = 20.0;\n    float pauseScale = 1.0; // range 0-1\n    float scaledTime = iTime * 0.50;\n    scaledTime += 0.05*uv.x;\n    float sinTime = sin(pauseFreq*scaledTime);\n    float sinTimeOffset = sin(pauseFreq*scaledTime - 0.5*3.141);\n    float timeStep = scaledTime + pauseScale*(sinTime/pauseFreq);\n    \n    vec2 p = uv;\n    vec4 c;\n    \n    \n    p *= 4.0;\n    // p.x += - timeStep*6.0;\n    // p.y += - timeStep*3.0;    \n    p.x = 0.5 - timeStep*3.0;\n    p.y = 0.5 - timeStep*3.0; \n    c = voronoi( p );\n    \n    float cellPos = (p.y+c.z)+ timeStep*3.0;\n    // uv.x += 0.5*(2.0 * cellPos-1.0) * (uv.y-0.5);\n    uv.x += 1.5*(2.0 * c.x-0.33) * (uv.y-0.5);\n\t// fragColor = vec4(2.5*(2.0 * cellPos-1.0) * (uv.y-0.5)); return;\n    \n    \n    uv.x *= 0.25; \n    p = uv;\n    p.y = max(p.y, 0.5); \n    p *= 12.0; // higher values zoom out further - don't go too high or the sine waves will become quite obvious...\n    p.x += timeStep*16.0;\n    p.y += timeStep*32.0;\n    c = voronoi( p );\n    // c.x = 1.0-pow(1.0-c.x, 2.0);\n    \n    \n\tfragColor = 0.5*vec4(c.x);\n    \n    float d = 0.0;\n    float edgeScale = 1.0-2.0*abs(fragCoord.x/iResolution.x - 0.5);\n    //edgeScale = fragCoord.x/iResolution.x ;\n    float scaleMulti = pow(0.5*sinTime + 0.5, 2.0);\n\tfloat dScale = 2.0 * edgeScale * (0.25+0.75*pow(0.5*sinTimeOffset + 0.5, 2.0));\n    \n    p.y = 0.5*12.0 + timeStep*3.0;\n    c = dScale*voronoi( p );\n    // float d = 1.0-abs(uv.y-c.x-0.25);\n    d = (uv.y+c.x-0.75);\n    \n    p.x = uv.x*12.0 - timeStep*6.0;\n    p.y = 4.5*12.0 - timeStep*3.0;\n    c = dScale*voronoi( p );\n    d = mix(d, (uv.y-c.x-0.25), 0.5);\n    \n    \n    d = 1.0-abs(d);\n    \n    fragColor = vec4(d);\n    //float lineWidth *= 1.0- pow(1.0-(0.5*sinTimeOffset + 0.5), 2.0);\n    float lineWidth = d+0.025*scaleMulti *edgeScale;\n\n\tfragColor = mix(vec4(0,1,1.5,1 ), vec4(1,2,2.0,1 ), scaleMulti) * smoothstep(1.0, 1.005, lineWidth);\n\t//fragColor += edgeScale*vec4(1,1,1.0,1 ) * smoothstep(1.0, 1.005, lineWidth);\n    \n    fragColor += edgeScale*pow(scaleMulti*smoothstep(0.75, 1.005, lineWidth), 16.0) * 0.5*vec4(.8,1,2.0,1 ) ;\n    \n    fragColor += 0.5*vec4(.1,0.05,0.2,1 );\n    \n}\n","name":"Image","description":"","type":"image"}]}