{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define EPS vec2(1e-3, 0.0)\n\nfloat time;\n\nvec3 rotateX(float a, vec3 v)\n{\n\treturn vec3(v.x, cos(a) * v.y + sin(a) * v.z,\n\t\t\t\tcos(a) * v.z - sin(a) * v.y);\n}\n\nvec3 rotateY(float a, vec3 v)\n{\n\treturn vec3(cos(a) * v.x + sin(a) * v.z,\n\t\t\t\tv.y, cos(a) * v.z - sin(a) * v.x);\n}\n\nfloat square(vec2 p, vec2 s)\n{\n\treturn length(max(vec2(0.0), abs(p) - s)) - 1e-3;\n}\n\nfloat edge(vec2 p, vec2 d)\n{\n\treturn dot(p, normalize(d.yx) * vec2(1.0, -1.0));\n}\n\nfloat trapezium(vec2 p, float y0, float y1, vec2 x0, vec2 x1)\n{\n\tfloat c0 = p.y - y1, c1 = -(p.y - y0);\n\tfloat e0 = -edge(p - vec2(x0.x, y0), vec2(x1.x, y1) - vec2(x0.x, y0));\n\tfloat e1 = edge(p - vec2(x0.y, y0), vec2(x1.y, y1) - vec2(x0.y, y0));\n\t\n\tc0 = max(0.0, c0);\n\tc1 = max(0.0, c1);\n\te0 = max(0.0, e0);\n\te1 = max(0.0, e1);\n\t\n\treturn sqrt(c0 * c0 + c1 * c1 + e0 * e0 + e1 * e1);\n}\n\nfloat leg(vec2 p)\n{\n\tfloat s0 = square(p - vec2(0.86, -0.38), vec2(0.071, 0.44));\n\tfloat s1 = square(p - vec2(0.68, -0.72), vec2(0.2, 0.1));\n\tfloat e0 = edge(p - vec2(0.68, -0.72), vec2(-1.0, -0.6));\n\treturn  min(s0, max(s1, e0));\n}\n\nfloat bodyParts0(vec2 p)\n{\n\tfloat p0 = square(p - vec2(0.86, 0.31), vec2(0.07, 0.1));\n\tfloat p1 = square(p - vec2(0.67, 0.32), vec2(0.07, 0.03));\n\tfloat p2 = trapezium(p, 0.04, 0.09, vec2(0.0, 0.15), vec2(0., 0.2));\n\treturn min(min(p0, p1), p2);\n}\n\nfloat bodyParts1(vec2 p)\n{\n\tfloat p0 = trapezium(p, 0.35, 0.44, vec2(0.0, 0.2), vec2(0., 0.275));\n\tfloat p1 = square(p - vec2(0.2, 0.479), vec2(0.16, 0.02));\n\tfloat p2 = square(p - vec2(0.44, 0.14), vec2(0.495, 0.02));\n\tfloat p3 = trapezium(p, 0.27, 0.5, vec2(0.4 - 0.24, 0.4 + 0.05), vec2(0.4 - 0.05, 0.4 + 0.24));\n\tfloat p4 = square(p - vec2(0.0, 0.22), vec2(0.16, 0.02));\n\tfloat p5 = square(p - vec2(0.21, 0.3), vec2(0.17, 0.03));\n\tfloat p6 = square(p - vec2(0.8, 0.479), vec2(0.2, 0.02));\n\treturn min(min(min(min(min(min(p0, p1), p2), p3), p4), p5), p6);\n}\n\nfloat bodyCrossSection0(vec2 p)\n{\n\tp.x = abs(p.x);\n\treturn bodyParts1(p);\n}\n\nfloat bodyCrossSection1(vec2 p)\n{\n\tp.x = abs(p.x);\n\tfloat p0 = leg(p);\n\tfloat p1 = bodyParts0(p);\n\treturn min(p0, p1);\n}\n\nfloat bodyProfile(vec2 p)\n{\n\tp -= vec2(0.2, 0.25);\n\treturn max(edge(p, vec2(0.3, 1.0)), edge(p, vec2(-0.3, 1.0)));\n}\n\nfloat headCrossSection(vec2 p)\n{\n\tp.x = abs(p.x);\n\tfloat d0 = square(p - vec2(0.0, 0.77), vec2(0.06, 0.03));\n\tfloat d1 = trapezium(p, 0.54, 0.74, vec2(0.0, +0.5), vec2(0.0, +0.05));\n\treturn min(d0, d1);\n}\n\nfloat headProfile(vec2 p)\n{\n\tfloat d0 = -p.x - 0.1;\n\tfloat d1 = edge(p - vec2(0.0, 0.54), vec2(-0.6, 1.0)) - 0.1;\n\treturn length(vec2(max(0.0, d0), max(0.0, d1)));\n}\n\nfloat body(vec3 p)\n{\n\tfloat d0 = bodyCrossSection0(p.xy);\n\tfloat d1 = bodyProfile(p.zy);\n\tfloat d2 = abs(p.z) - 0.1;\n\tfloat d3 = bodyCrossSection1(p.xy);\n\tfloat d4 = -p.z - 0.1;\n\t\n\treturn min(length(vec2(max(0.0, d2), max(0.0, d3))),\n\t\t\t   length(vec3(max(0.0, d4), max(0.0, d0), max(0.0, d1)))) - 0.001;  \n}\n\nfloat head(vec3 p)\n{\n\tfloat d0 = headCrossSection(p.xy);\n\tfloat d1 = headProfile(p.zy);\n\treturn length(vec2(max(0.0, d0), max(0.0, d1)));\n}\n\nfloat recogniserDist(vec3 p)\n{\n\tp.z -= sin(floor((p.x + 2.0) / 4.0) * 2.0);\n\tp.x = mod(p.x + 2.0, 4.0) - 2.0;\n\treturn min(body(p), head(p)) - 0.01;\n}\n\nvec3 recogniserNorm(vec3 p)\n{\n\tfloat d = recogniserDist(p);\n\treturn normalize(vec3(recogniserDist(p + EPS.xyy) - d, recogniserDist(p + EPS.yxy) - d,\n\t\t\t\t\t\t  recogniserDist(p + EPS.yyx) - d));\n}\n\nfloat recogniserCurve(vec3 p)\n{\n\tvec3 n0 = recogniserNorm(p);\n\tvec3 n1 = recogniserNorm(p + EPS.xyy);\n\tvec3 n2 = recogniserNorm(p + EPS.yxy);\n\tvec3 n3 = recogniserNorm(p + EPS.yyx);\n\treturn length(n1 - n0) + length(n2 - n0) + length(n3 - n0);\n}\n\nfloat floorTexMask(vec2 p, float s)\n{\n\tp = fract(p);\n\treturn max(step(p.x, s), step(p.y, s));\n}\n\nvec3 floorTex(vec2 p)\n{\n\tfloat m0 = floorTexMask(p, 0.02);\n\tfloat m1 = floorTexMask(p * 20.0, 0.04);\n\tvec2 p1 = p * 0.2 + vec2(time);\n\tfloat m2 = floorTexMask(p1, 0.01) * step(0.0, sin(floor(p1.x * 10.0) * 100.0 + floor(p1.y * 10.0) * 70.0));\n\treturn m0 * vec3(1.0, 0.0, 0.1) * 0.2 + m1 * vec3(1.0, 0.0, 0.1) * 0.1 +\n\t\t\tm2 * m0 * vec3(0.4);\n}\n\nfloat pyramid(float x)\n{\n\tx = fract(x);\n\treturn min(x * 2.0, 2.0 - x * 2.0);\n}\n\nfloat mountains(vec2 p)\n{\n\tfloat x = p.x / 3.1415926 * 10.0;\n\tfloat h = pyramid(x) * mix(0.0, 0.1, (0.5 + 0.5 * cos(floor(x) * 2.0) * cos(floor(x) * 0.01)));\n\treturn p.y - h;\n}\n\nvec3 backg(vec3 ro, vec3 rd)\n{\n\tfloat t = (-1.0 - ro.y) / rd.y;\n\tvec3 rp = ro + rd * t;\n\trp.z += time;\n\t\n\tvec3 sc = mix(0.1, 1.0, rd.y) * vec3(1.0, 0.3, 0.1) * 0.3;\n\tvec3 fc = floorTex(rp.xz) * (1.0 - smoothstep(0.0, 10.0, t));\n\t\n\tfloat m0 = mountains(vec2(atan(rd.z, rd.x), rd.y));\n\tfloat m1 = mountains(vec2(atan(rd.z, rd.x) * 2.0, rd.y));\n\t\n\tsc = mix(vec3(0.0), mix(vec3(1.0, 0.32, 0.32) * 0.3, sc, step(0.001, m0)), step(0.0, m0));\n\tsc = mix(vec3(0.0), mix(vec3(1.0, 0.32, 0.32) * 0.3, sc, step(0.001, m1)), step(0.0, m1));\n\t\n\treturn mix(sc, fc, step(0.0, t));\n}\n\nvec3 xform(vec3 v)\n{\n\treturn rotateY(time * 0.3 + (iMouse.x / iResolution.x - 0.5) * 4.0, rotateX(0.4 + (iMouse.y / iResolution.y - 0.5), v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 t = uv * 2.0 - vec2(1.0);\n\tt.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro = xform(vec3(0.01, 0.0, 3.0)), rd = xform(normalize(vec3(t.xy, -2.1)));\n\t\n\tfragColor.rgb = backg(ro, rd);\n\t\n\tfloat f = 0.0;\n\t\n\tfor(int i = 0; i < 60; ++i)\n\t{\n\t\tfloat d = recogniserDist(ro + rd * f);\n\t\t\n\t\tif(abs(d) < 1e-4)\n\t\t\tbreak;\n\t\t\n\t\tf += d * 0.8;\n\t}\n\t\n\tvec3 rp = ro + rd * f;\n\t\n\tfloat c = smoothstep(0.0, 0.2, recogniserCurve(rp)) / (2.0 + length(rp) + 0.5 * cos(rp.y * -3.0 + time * 10.0));\n\tvec3 n = recogniserNorm(ro + rd * f);\n\t\n\tfragColor.rgb = mix(fragColor.rgb, c * vec3(1.0, 0.0, 0.1), step(f, 10.0)) * 2.0;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdX3Dn","date":"1367143657","viewed":2222,"name":"Recogniser","username":"fizzer","description":"Tron recogniser. I decided to take on simesgreen's challenge (https://www.shadertoy.com/view/Xdf3z8). It is slightly simplified in that the 'head' part (where I think the cockpit is located) is missing some features. Use your mouse to move the camera.","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","distancefield","tron","laserlines","recogniser"],"hasliked":0,"parentid":"","parentname":""}}