{"ver":"0.1","info":{"id":"ldBfzw","date":"1499879422","viewed":6561,"name":"[SH17A] Fireworks","username":"BigWIngs","description":"Based on my previous fireworks shader:\nhttps://www.shadertoy.com/view/lscGRl\n\nThis is my first code golf exercise. I hope the masters of this can shave off a few more characters. I'm looking at you FabriceNeyret, GregRostami, Coyote, P_Malin :)","likes":83,"published":1,"flags":64,"usePreview":0,"tags":["fireworks","2tweets","codegolf","sh17a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXSWS","filepath":"https://soundcloud.com/gabriella-vargas/calvin-harris-florence-and-the","previewfilepath":"https://soundcloud.com/gabriella-vargas/calvin-harris-florence-and-the","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"[SH17A] Fireworks\" by Martijn Steinrucken aka BigWings/Countfrolic - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Based on https://www.shadertoy.com/view/lscGRl\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n\n// Greg Rostami & FabriceNeyret2 version -> 265 chars \n#define N(h) fract(sin(vec4(6,9,1,0)*h) * 9e2) \nvoid mainImage(out vec4 o, vec2 U) {\n    vec2 u = U/iResolution.y;\n    float e, d, i=-2.;\n    for(vec4 p; i++<9.; d = floor(e = i*9.1+iTime),p = N(d)+.3, e -= d)\n        for(d=0.; d++<50.;)\n            o += p*(1.-e) / 1e3 / length(u-(p-e*(N(d*i)-.5)).xy);\n    u.y<N(ceil(u.x*i+d+e)).x*.4 ? o-=o*u.y : o;}\n\n/* //Original version, 278 chars\n#define N(h) fract(sin(vec4(6,9,1,0)*h) * 9e2) \nvoid mainImage(out vec4 o,vec2 u )\n{\n    o-=o; \n    \n    u /= iResolution.y;\n    \n    float e, d, i=-2.; \n    \n    for(vec4 p; i++<9.; d = floor(e = i*9.1+iTime),p = N(d)+.3, e -= d)\n        for(d=0.; d++<50.;)\n            o += p*(1.-e) / 1e3 / length(u-(p-e*(N(d*i)-.5)).xy);  \n\n    if(u.y<N(ceil(u.x*i+d+e)).x*.4) o-=o*u.y;\n}\n*/\n\n/*\nEXPLANATION OF HOW THIS WORKS\n\n\n// turns 1 float into a pseudo random vec4 in the 0-1 range\n#define N(h) fract(sin(vec4(6,9,1,0)*h) * 9e2) \n\nvoid mainImage(out vec4 o,vec2 u )\n{\n    //initialize o to 0,0,0,0 in the shortest way possible\n    // o is what will hold the final pixel color\n    o-=o; \n    \n    // divide the uv pixel coordinates by the height to get aspect corrected 0-1 coords\n    u /= iResolution.y;\n    \n    // loop iterator defined here because it saves characters\n    // starts at -2 so it goes through 0, which gives the occasional rocket\n    float e, d, i=-2.; \n    \n    // outer loop, defines number of simultaneous explosions\n    // other var assignments inside of the for statement which \n    // saves chars on brackets around the for loop\n    // i++<9 which saves the i++; that usually goes at the end of the for\n    for(vec4 p; i++<9.; \n        // e = the time since the shader started + an offset per explosion\n        // d = the floored version of that, which stays the same for a second, then jumps\n        d = floor(e = i*9.1+iTime),\n        // the position of the explosion, as well as the color\n        // which is a pseudo random number made by throwing a large number into a sine function\n        // +.3 so the explosions are centered horizontally (because aspect ratio of screen)\n        p = N(d)+.3, \n        // turn e into the fractional component of time e.g. 10.546 -> 0.546\n        e -= d)\n        // inner loop, renders the particles in the explosion\n        for(d=0.; d++<50.;)\n            // add to final pixel col\n            // p = the color, 1.-e is a number that starts at 1 and goes to 0 \n            // over the duration of the explosion, essentially fading the particle\n            o += p*(1.-e) \n            // divide by 1000, otherwise the pixel colors will get too bright\n            / 1e3 \n            // divide by the distance to the particle, the farther away, the darker\n            // note that this never gets to 0, each tiny particle has an effect over the\n            // entire screen\n            // dist to particle is the length of the vector from the current uv coordinate (u)\n            // to the particle pos (p-e*(N(d*i)-.5)).xy\n            // particle pos starts at p, when e is 0\n            // N(d*i) gives a pseudo random vec4 in 0-1 range\n            // d*i to give different vec4 for each particle\n            // *i is not really necessary but when i=0 it gives 0 for the whole vec4\n            // which makes the appearance of the occasional rocket\n            // N(d*i)-.5 to go from 0-1 range to -.5 .5 range\n            / length(u-(p-e*(N(d*i)-.5)).xy);  \n\n   // draw skyline\n   // uv.x goes from 0 to 1.6  *i to make it larger i=9. (save a char cuz 9. is 2 chars)\n   // +d+e   d+e = iTime  -> this will make the skyline scroll\n   // ceil to go in steps (stay at one height, then jump to the next)\n   // N(..) to make a value 0, 1, 2, 3.. etc into random numbers in 0-1 range\n   // .x*4   N returns a vec4, but we only need a float, *.4 so buildings are lower\n   // o -= o*u.y   o-=o would make the buildings pitch black, *u.y to fade them towards the \n   // bottom, creating a bit of a fog effect     \n   if(u.y<N(ceil(u.x*i+d+e)).x*.4) o-=o*u.y;\n}\n\n*/","name":"Image","description":"","type":"image"}]}