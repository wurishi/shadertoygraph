{"ver":"0.1","info":{"id":"sdByzh","date":"1643069411","viewed":220,"name":"Visualising waveforms","username":"mrboggieman","description":"Simple rendering of a waveform (1d equation based on time)","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["wave","graph"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sampleBuffer(in float t) {\n    int channelWidth = int(iChannelResolution[0].x);\n\n    int channelIndex = int(t) % 4;\n    int pixIndex = int(t) / 4;\n    ivec2 bufferIndex = ivec2(pixIndex % channelWidth, pixIndex / channelWidth);\n    \n    //could we interpolate the value in combination with linear filtering?\n    return symmetricToNormalised(texelFetch(iChannel0, bufferIndex, 0)[channelIndex]);\n}\n\n//https://www.shadertoy.com/view/3tdSDj\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sampleCoverage(in float y, in float y2, in float actualY) {\n    //get the shortest distance from a virtual center point to the line formed from y and y2\n    vec2 from = vec2(0.0, y);\n    vec2 to = vec2(1.0, y2);\n    vec2 mid = vec2(0.5, actualY);\n    \n    return clamp(sdSegment(mid, from, to), 0.0, 1.0);\n}\n\nconst int samples = 8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoomAmount = sampleRate / iResolution.x; //fit one second on the screen\n    \n    //TODO: allow dragging and zooming using the mouse drag axis\n    float t = fragCoord.x * zoomAmount;\n    \n    //split the pixel into slices for anti-aliasing (needs work - replace with some real integration)\n    float pixStep = zoomAmount / float(samples);\n    \n    float col = 0.0;\n    float prevY = sampleBuffer(t) * iResolution.y;\n    float nextY;\n    \n    for (int i = 0; i < samples; i++) {\n        t += pixStep;\n        nextY = sampleBuffer(t) * iResolution.y;\n        col += sampleCoverage(prevY, nextY, fragCoord.y);\n        prevY = nextY;\n    }\n    \n    col /= float(samples);\n    \n    \n    fragColor = vec4(col, col, col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI2 = 6.28318530718;\nconst float E = 2.71828182845;\n\nconst float sampleRate = 44100.0;\n\nfloat sinWave(in float t, in float frequency, in float phase, in float amplitude) {\n    return sin(t * PI2 * frequency + phase) * amplitude;\n}\n\nfloat expDecay(in float t, in float k) {\n    return pow(E, -k * t);\n}\n\n//ranges\n// 0 -> 1, normalised\n// -1 -> 1, symmetric\n\nfloat normalisedToSymmetric(in float t) {\n    return t * 2.0 - 1.0;\n}\n\nfloat symmetricToNormalised(in float t) {\n    return (t + 1.0) / 2.0;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//compute our complex waveform here\nfloat makeWaveform(float t) {\n    float amplitude = sinWave(t, 40.0, 0.0, 1.0);\n    \n    amplitude *= expDecay(t, 2.0);\n    \n    return amplitude;\n}\n\nconst float sampleStep = 1.0 / sampleRate;\n\n//store the waveform in a buffer (matches the window size in shadertoy)\n//640 x 360 x 4 channels gives ~ 20 seconds of samples at 44.1kHz in a single frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //store the time across the whole buffer image (x and y)\n    float t = (floor(fragCoord.x) + (floor(fragCoord.y) * iResolution.x)) * sampleStep * 4.0;\n    \n    //lets pack the time into each channel too (each channel is 32-bit float)\n    fragColor = vec4(makeWaveform(t), makeWaveform(t+sampleStep), makeWaveform(t+sampleStep), makeWaveform(t+sampleStep));\n}\n","name":"Buffer A","description":"","type":"buffer"}]}