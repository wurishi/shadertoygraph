{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\nfloat MAXD=1000.0;\nint rm_Iterations =100;\nfloat perspective=1.25,zoom=1.2;\nvec3 cameraLocation=vec3(0.0, -12.5, -24.6);\nvec3 light=vec3(-0.1,-0.1, -1.);\nfloat rotX=1.5;\nfloat dist=.95;\nvec3 center=vec3(0.0,0.0,0.0);\nvec3 shift=vec3(64./2.,0.,36./1.5);\n\nvec3 rotateX( const in vec3 p, const in float angle ){\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\t\n\treturn vec3( p.x, c * p.y + s * p.z, -s * p.y + c * p.z);\n}\n\nfloat map( vec3 p ){\n\tp=rotateX(p,rotX);//a little tilted for mo' 3d effect\n\tp +=shift;\n\tif (p.x>-0.5 && p.x<64. && p.z>0. && p.z<48.){\n\tvec4 tex=textureLod(iChannel0,p.xz/vec2(64.0,48.0).xy,0.0);\n\n\tfloat tl=max(.3,tex.r*1.5);//small size vs. big size\n\tfloat div=2.;\n    p.x = mod( p.x + dist/div, dist ) - dist/div;\n    //float dist2=2.75;\n    //p.y = (mod( p.y + dist2/div, dist2 ) - dist2/div)-1.5;\n   \tp.z = mod( p.z + dist/div, dist ) - dist/div;\n\n    \treturn length( center - p ) - tl;\n    \t}\n    \telse return float(1.);\n}\n\n\nvec3 calc_normal(vec3 v){\n  \tfloat e=0.0001;\n  \tvec3 n=vec3(\n    map(vec3(v.x+e,v.y,v.z))-map(vec3(v.x-e,v.y,v.z)),\n    map(vec3(v.x,v.y+e,v.z))-map(vec3(v.x,v.y-e,v.z)),\n    map(vec3(v.x,v.y,v.z+e))-map(vec3(v.x,v.y,v.z-e)));\n  \treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n, float d){\n  \tfloat o=1.0,ii=5.0;\n  \tfor(int i=0;i<5;i++){\n    \tvec3 tmpV=p+n*(ii*d);\n    \tfloat tmp=map(tmpV);\n    \tif(tmp<0.0) tmp=0.0;\n    \to-=(ii*d-tmp)/pow(2.0,ii);\n    \tii=ii-1.0;\n  \t}\n  \treturn o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat x,y,off=0.0;\n\tvec4 col;\n  \tfloat rx,ry,d;\n  \tint steps=0;\n  \tvec3 ray,direction;\n\n  \tvec2 p = 2.0*fragCoord.xy;\n  \tp.x/= iResolution.x;\n  \tp.y/= iResolution.x;\n  \tp-=1.0;\n  \tp.y=-p.y;\n\tp=p/zoom;\n \tray=vec3(p.x,p.y,0);\n \tray=ray+cameraLocation;\n  \tdirection=vec3(p.x*perspective,p.y*perspective,1.0);\n  \tdirection=normalize(direction);\n  \tcol=vec4(0.25+(p.y+0.5)/3.0,0.25+(p.y+0.5)/3.0,0.33+(p.y+0.5)/3.0,1.0);\n\n  \tfor(int i=0;i<100;i++){\n\t\td=map(ray);\n      if(d>=MAXD){\n         // Infinite distance\n          break;\n      }\n      if(d<0.00001){\n      \tvec3 n=calc_normal(ray);\n      \t//float normlight=0.25*dot(light,n);\n\t\tfloat normlight=0.25*max(0.,dot(light,n));//thx @ las\n      \tfloat aolight=ao(ray,n,0.25);//float aolight=ao(ray,n,0.25);\n      \tif(normlight<0.0) normlight=0.0;\n        \tfloat ambient=0.75;\n      \tfloat c=(normlight+ambient)*aolight;\n      \tcol=vec4(c,c,c,1.0);\n\t\tvec3 p2=rotateX(ray,rotX);\n\t\tp2 +=shift;\n\t\tvec4 tex=texture(iChannel0,p2.xz/vec2(64.0,48.0).xy);\n\t\tcol *=tex /(1.+map(ray));//col +=vec3(1.,0.1,0.1) /(1.+map(ray));//thanks @ XT95\n        \tbreak;\n      }\n      ray+=direction*d;\n\t}\n\t\n\tfragColor = col;\n\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sfGR4","date":"1363103817","viewed":948,"name":"mod filter","username":"gtoledo3","description":"This is a raymarching setup that provides a DE that sizes objects according to pixel.r value. Main RM loop from the \"mickey mouse\" rm discussion around pp24~26 from pouet raymarching for beginners thread.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","filter","vfx"],"hasliked":0,"parentid":"","parentname":""}}