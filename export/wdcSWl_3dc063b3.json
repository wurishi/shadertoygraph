{"ver":"0.1","info":{"id":"wdcSWl","date":"1573108373","viewed":409,"name":"Liquid metal","username":"vegardno","description":"Just playing around with smoothmin on spheres","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","metal","liquid","smin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// https://iquilezles.org/articles/normalsSDF\nfloat sphereSDF(vec3 samplePoint, float r) {\n    return length(samplePoint) - r;\n}\n\n// https://iquilezles.org/articles/smin\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glRotate.xml\nmat4 rotate(float a, vec3 v)\n{\n    float c = cos(a);\n    vec3 ci = (1. - c) * v;\n    vec3 s = sin(a) * v;\n\n    return mat4(\n        ci.x * v.x + c, ci.x * v.y + s.z, ci.x * v.z - s.y, 0,\n        ci.y * v.x - s.z, ci.y * v.y + c, ci.y * v.z + s.x, 0,\n        ci.z * v.x + s.y, ci.z * v.y - s.x, ci.z * v.z + c, 0,\n        0, 0, 0, 1\n\t);\n}\n\n// https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float d = 1000.;\n    \n\tmat4 timeRotation = rotate(4. * iTime, normalize(vec3(-1, -1.5, 0)));\n    samplePoint = (timeRotation * vec4(samplePoint, 1)).xyz;\n    \n    for (int i = 0; i < 8; ++i) {\n\t\tfloat randA = 5. * (rand(vec2(float(i), 0.))- .5);\n        float randX = rand(vec2(float(i), 1.)) - .5;\n        float randY = rand(vec2(float(i), 2.)) - .5;\n        float randZ = rand(vec2(float(i), 3.)) - .5;\n        float sphere_radius = .2;\n        float freq = 1.;//3. + 5. * rand(vec2(float(i), 3.));\n        float phase = radians(360.) * rand(vec2(float(i), 5.));\n        float smin_k = 5. + 1.5 * sin(iTime);\n\n\t    mat4 axisRotation = rotate(randA, normalize(vec3(randX, randY, randZ)));\n\t    d = smin(d, sphereSDF((axisRotation * vec4(samplePoint, 1) + vec4(.9*sin(freq * iTime + phase), 0, 0, 1)).xyz, sphere_radius), smin_k);\n\t}\n\n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p)\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h ) + \n                      k.yyx*sceneSDF( p + k.yyx*h ) + \n                      k.yxy*sceneSDF( p + k.yxy*h ) + \n                      k.xxx*sceneSDF( p + k.xxx*h ) );\n}\n\n// http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(90.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n\n    vec3 lightDir = normalize(vec3(1, 1, 1));\n    vec3 normal = calcNormal(eye + dir * dist);\n\n    vec3 rgb = texture(iChannel0, normal).rgb;\n    \n    fragColor = vec4(max(.3, dot(lightDir, normal)) * rgb, 1);\n}","name":"Image","description":"","type":"image"}]}