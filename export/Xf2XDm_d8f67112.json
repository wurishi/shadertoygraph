{"ver":"0.1","info":{"id":"Xf2XDm","date":"1706434790","viewed":105,"name":"Separable Spirals","username":"laserbat","description":"2D cellular automaton is constructed by running a 1D CA along four directions, switching to the next direction each frame. This is similar to the idea of separable kernels.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["feedback","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 norm_coord = fragCoord / iResolution.xy;\n    \n    fragColor = texture(iChannel0, norm_coord);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simple time-dependant noise function, for seeding CA\nint noise(in vec2 co){\n    int x = int(co.x * float(M));\n    int y = int(co.y * float(M));\n    int z = int(iDate.a);\n    int w = int(fract(iDate.a) * float(M));\n    int res = hash(x + hash(y + hash(z + hash(w))));\n    \n    return res;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 norm_coord = fragCoord / iResolution.xy;\n\n    // Randomize initial state on 0th frame or if mouse button is pressed\n    if (iFrame <= 0 || iMouse.z > 0.0) {\n        fragColor.rgb = unpack(noise(norm_coord));\n        return;\n    }\n        \n    int vals[7];\n    int i = 0;\n    int idx = 0;\n\n    vec2 direction;\n\n    switch (iFrame % 4){\n        case 0:\n            direction = vec2( 1.0,  0.0);\n            break;\n        case 1:\n            direction = vec2( 1.0,  1.0);\n            break;\n        case 2:\n            direction = vec2( 0.0,  1.0);\n            break;\n        case 3:\n            direction = vec2(-1.0,  1.0);\n            break;\n\n    }\n            \n    for(float stp = -3.0; stp <= +3.0; stp++){\n        vec2 new_coord = (fragCoord + direction * stp) / iResolution.xy;\n        vals[i] = pack(texture(iChannel0, new_coord).rgb);\n        i += 1;\n     }\n\n\n    // Sort the array using a sorting network\n    swap(0,6); swap(2,3); swap(4,5);\n    swap(0,2); swap(1,4); swap(3,6);\n    swap(0,1); swap(2,5); swap(3,4);\n    swap(1,2); swap(4,6);\n    swap(2,3); swap(4,5);\n    swap(1,2); swap(3,4); swap(5,6);\n\n    idx = (vals[0] + vals[6]) % 7;\n\n    fragColor.rgb = unpack(vals[idx]);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define swap(x, y) if (vals[x] > vals[y]) {int t = vals[y]; vals[y] = vals[x]; vals[x] = t;};\n\n#define D 256\n#define M (D * D * D)\n\nint hash(int x) {\n    x++;\n    x ^= x >> 17;\n    x *= 0xed5ad4bb;\n    x ^= x >> 11;\n    x *= 0xac4c1b51;\n    x ^= x >> 15;\n    x *= 0x31848bab;\n    x ^= x >> 14;\n    return x;\n}\n\nvec3 unpack(int val){\n    vec3 res;\n    \n    res.r = float(val % D) / float(D);\n    val /= D;\n    res.g = float(val % D) / float(D);\n    val /= D;\n    res.b = float(val % D) / float(D);\n\n    return res;\n}\n\nint pack(vec3 val){\n    int res;\n    \n    res += int(float(D) * val.b);\n    res *= D;\n    res += int(float(D) * val.g);\n    res *= D;\n    res += int(float(D) * val.r);\n\n    return res;\n}","name":"Common","description":"","type":"common"}]}