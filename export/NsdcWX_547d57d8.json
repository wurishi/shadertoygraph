{"ver":"0.1","info":{"id":"NsdcWX","date":"1654163715","viewed":237,"name":"The Morphing Digits","username":"bitless","description":" This shader was inspired by the fine work of Xor \"The Typist\"","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["2d","digits","morphing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: The Morphing Digits\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n// This shader was inspired by the fine work of Xor.\n// The Typist  - https://www.shadertoy.com/view/sd3czM\n\n// Not so long ago I wrote code for changing numbers, but I couldn't think of a way to make\n// it interesting. \"The Typist\" gave me a good idea. \n// But I used a different method for the \"tilt shift\" effect.\n\n// \"Hash without Sine\" by Dave_Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// IQ's segment SDF \n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\n    return length( pa - ba*h );\n}\n\n#define hue(v) ( .7 + .4 * cos(6.3*(v) + vec4(0,23,21,0) ) ) //hue\n#define S(a,b,c) smoothstep (a+b, a-b, c)\n\nvoid mainImage( out vec4 O, in vec2 g )\n{\n    vec2 r = iResolution.xy\n        ,org = (g+g-r)/r.y;\n    \n    vec2 uv = org, p, v;\n    uv *= .5 + length(uv)*.02;  //camera barrel distortion\n    uv = (uv*mat2(10,-3,1,8)/(2.-org.y*.5)+iTime*.5)*.75; //camera rotation, skew and zoom\n    \n    vec2 lc = fract(uv)*vec2(1.8,3) + vec2(-.4,-1.5); //cell local coordinates\n\n    float H = hash12(floor(uv))*2.              //cell hash - determines the color of the digit and the timer offset\n        , ts = (1.-S(.6,.3,abs(org.y)))*1.2     //value of \"tilt shift\" effect\n        , N = (hash12(uv*50.)-.5)*ts*.01        //noise value\n        , f = 9.\n        , z = f\n        , a, b, l\n        , T = mod(iTime+H,2.);                 //cycle of digits change - 2 sec\n    \n    lc += N;    //add a fine noise shift \n    \n    //         1            Segment numbers and their drawing directions.\n    //      ╔═════╗\n    //      ║  ←  ║         The digit consists of seven segments and is coded as an integer.\n    //     0║↑   ↑║2        The bit number corresponds to the segment number.\n    //      ║  6  ║         The segment is defined by a start point and a vector to the end point.\n    //      ╠═════╣         The segment is also encoded by an integer, bits 0-4 being the start point\n    //      ║  ←  ║         and bits 4-8 being the vector.\n    //     5║↓   ↓║3\n    //      ║  ←  ║\n    //      ╚═════╝\n    //         4\n         \n    int s[7] = int[7](149,74,150,22,66,21,70)                //segments\n        , d[10] = int[10](63,12,118,94,77,91,123,14,127,95)  //digits\n        , i=0;\n    \n    for (;i<7;i++)      //draw all 7 segments\n    {\n        p = vec2((s[i] & 3) - 1, ((s[i]>>2) & 3) - 1);      //segment start point\n        v = vec2((s[i]>>4 & 3) - 1, (s[i]>>6 & 3) - 1);     //vector to the end point\n        \n        a =  float(d[int(hash12(vec2(floor((iTime+H)*.5),H))*10.)] >> i & 1);       //the current digit in the cell\n        b =  float(d[int(hash12(vec2(floor((iTime+H)*.5)+1.,H))*10.)] >> i & 1);    //digit in the cell in the next cycle\n        l = mix(a,b,smoothstep (.5,1.5,T));                 //segment is changing (or not) from 0.5 to 1.5 seconds of cicle \n        if (l > 0.) f = min(f,sdSegment(lc,p,p+v*l));       //SDF for segment\n        if (a > 0.) f = min(f, length(p - lc) + .5 * smoothstep (1.5,2.,T));    //fade out for old segments 1.5 to 2 seconds\n        if (b > 0.) f = min(f, length(p - lc) + .5 * smoothstep (.5,0.,T));     //fade in for new segments 1.5 to 2 seconds\n        \n        z = min(z,sdSegment(lc,p,p+v));     //SDF for digit background\n    }\n    \n    a = .25;                        //segment width\n    b = ts*.15+5./iResolution.y;    //segment \"blur factor\" for \"tilt shift\" effect \n    \n    O = vec4(0);\n    O = mix (                   //mix colors\n            mix(\n                mix(O,vec4(.1+S(.03,b,abs(z-a))*.1), S(a,b,z))      //digit background with outline \n                ,hue(H),S(a,b,f))                                   //digit foreground\n                ,vec4(0),S(.2,b, abs(fract(f*20.)-.5))*(.2-ts*.2)*step(f,.23));   //thin black lines\n\n    z = dot (vec2(sin(iTime)*.5-1.,1),normalize(vec2(dFdx(f),dFdy(f))));    //light direction and normal\n    O = O * (.8 + z*.5*S(.4,.2,abs(org.y))*S(.1,.1,abs(f-.2)))              //add lighting and shadows\n        + N*4.;     //and fine noise\n}","name":"Image","description":"","type":"image"}]}