{"ver":"0.1","info":{"id":"3lXGDH","date":"1612047472","viewed":108,"name":"Exercise: Lines / hyperspace","username":"endymion","description":"Trying to do one of the examples in https://thebookofshaders.com/10/","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["lines","hyperspace","bookofshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define SIZE 10.\n\n/**\n * Draw helper for better portability between environments \n */\nvec4 draw(vec2 coordinate, vec2 resolution, float time, vec2 mouse) {\n    float rows = resolution.y / SIZE;\n    float columns = resolution.x / SIZE;\n        \n    // Normalize coordinates and set up grid\n    vec2 uv = normalizedCoordinates(coordinate.xy, resolution.xy);\n    uv = vec2(uv.x * columns, uv.y * rows);\n    vec2 iPos = floor(uv); // get the integer coords\n    vec2 fPos = fract(uv); // get the fractional coords\n    \n\t// Velocity\n    float velocity = iTime * 50.; // Base velocity based on time\n    velocity *= -1. * random(1.0 + iPos.y); // Randomize by row index\n    float x = floor(uv.x + velocity); // Add velocity to current position\n    \n    // Get color from x position and mouse \n    float color = step(\n        0.25 + mouse.x / resolution.x, \n        random(100. + x * .000001) + random(x) * 0.5\n    );\n    \n    // Margins\n    color *= step(1. / SIZE, fPos.y);\n    color *= 1. - step(1. - 1. / SIZE, fPos.y);\n    \n    // Assign a random value based on the integer coord\n    return vec4(vec3(1. - color), 1.0);\n}\n\n/**\n * Main\n */\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = draw(fragCoord, iResolution.xy, iTime, iMouse.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Utilities\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\n/**\n * Pseudo-random based on sine\n * @src https://thebookofshaders.com/10/\n * @param seed {float}\n * @return {float}\n */\nfloat random(float seed) {\n    return fract(sin(seed)*1e4);\n}\n\n/**\n * Pseudo-random\n * @src https://thebookofshaders.com/10/\n * @param coordinate {vec2}\n * @return {float}\n */\nfloat random(vec2 coordinate) {\n    return fract(\n        sin(dot(\n            coordinate,\n            vec2(12.9898, 78.233)\n        )) \n    * 43758.5453123);\n}\n\n/**\n * Normalize coordinates\n * @param coordinate {vec2}\n * @param resolution {vec2}\n * @return {vec2} - coordinates normalized to 0-1 by resolution\n */\nvec2 normalizedCoordinates(vec2 coordinate, vec2 resolution) {\n    return coordinate / resolution;\n}\n\n/**\n * Tile coordinate system by zoom level\n * @param coordinates {vec2}\n * @param zoom {float}\n * @return {vec2} - coordinates scaled and tiled by zoom level\n */\nvec2 tile(vec2 coordinate, vec2 zoom) {\n    return fract(coordinate * zoom);\n}\n\n/**\n * Rotate coordinate system from the center by angle\n * @src https://thebookofshaders.com/08/\n * @param coordinates {vec2}\n * @param angle {float} - angle in radians (360 degrees = 2 * PI)\n * @return {vec2}\n */\nvec2 rotate2d(vec2 coordinate, float angle){\n    coordinate -= 0.5; // Move coordinate to center \n    coordinate = mat2(\n        cos(angle),\n        -sin(angle),\n        sin(angle),\n        cos(angle)\n    ) * coordinate; // Rotate coordinate\n    coordinate += 0.5; // Reset coordinate from center \n    return coordinate;\n}\n\n/**\n * Scale coordinate system\n * @src https://thebookofshaders.com/08/\n * @param coordinate {vec2}\n * @param scale {vec2}\n * @return {vec2}\n */\nvec2 scale(vec2 coordinate, vec2 scale){\n    coordinate -= 0.5; // Move coordinate to center \n    coordinate = mat2(scale.x, 0.0, 0.0, scale.y) * coordinate; // Scale coordinate\n    coordinate += 0.5; // Reset coordinate from center \n    return coordinate;\n}\n\n/**\n * Box color at coordinate\n * @src https://thebookofshaders.com/07/\n * @param coordinate {vec2}\n * @param size {vec2}\n * @param smoothEdges {float}\n * @return {float}\n */\nfloat box(vec2 coordinate, vec2 size, float smoothEdges){\n    size = vec2(0.5) - size * 0.5; // Center size\n    \n    vec2 aa = vec2(smoothEdges * 0.5);\n    \n    vec2 uv = smoothstep(size, size + aa, coordinate);\n    uv *= smoothstep(size, size + aa, vec2(1.0) - coordinate);\n    \n    return uv.x * uv.y;\n}\n\n\n/**\n * Distance field\n * @src https://thebookofshaders.com/07/\n * @param coordinate {vec2} - normalized (0-1, 0-1) coordinate\n * @param sides {int} - Number of sides of your shape\n * @return {float}\n */\nfloat distanceField(vec2 coordinate, int sides) {\n    // Remap the space to -1. to 1.\n    vec2 uv = coordinate * 2. - 1.;\n\n    // Angle and radius from the current pixel\n    float a = atan(uv.x, uv.y) + PI;\n    float r = TWO_PI / float(sides);\n\n    // Shaping function that modulate the distance\n    float d = cos(floor( .5 + a / r) * r - a) * length(uv);\n    return d;\n}\n\n/**\n * Rotate tile pattern\n * @src https://thebookofshaders.com/09/\n * @param coordinate {vec2} - normalized (0-1, 0-1) coordinate\n * @return {vec2}\n */\nvec2 rotateTilePattern(vec2 coordinate){\n\n    //  Scale the coordinate system by 2x2\n    coordinate *= 2.0;\n\n    //  Give each cell an index number\n    //  according to its position\n    float index = 0.0;\n    index += step(1., mod(coordinate.x,2.0));\n    index += step(1., mod(coordinate.y,2.0))*2.0;\n\n    //      |\n    //  2   |   3\n    //      |\n    //--------------\n    //      |\n    //  0   |   1\n    //      |\n\n    // Make each cell between 0.0 - 1.0\n    coordinate = fract(coordinate);\n\n    // Rotate each cell according to the index\n    if(index == 1.0){\n        //  Rotate cell 1 by 90 degrees\n        coordinate = rotate2d(coordinate, PI*0.5);\n    } else if(index == 2.0){\n        //  Rotate cell 2 by -90 degrees\n        coordinate = rotate2d(coordinate, PI*-0.5);\n    } else if(index == 3.0){\n        //  Rotate cell 3 by 180 degrees\n        coordinate = rotate2d(coordinate, PI);\n    }\n\n    return coordinate;\n}","name":"Common","description":"","type":"common"}]}