{"ver":"0.1","info":{"id":"Nt3Xzj","date":"1639684695","viewed":182,"name":"sdf raymarching experiments","username":"jtomsu","description":"smooth shadows","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","sdf","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\n\n#define SHADOW_MODE 0\n\n// the SDF functions are by Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\n\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat length_sq(vec3 v) { return(v.x*v.x + v.y*v.y + v.z*v.z); }\n\n// sd union\nfloat sdu(float sd1, float sd2 ) {\n\treturn (sd1 < sd2) ? sd1 : sd2;\n}\n\nbool checker_pattern_3(const vec3 pos, const vec3 scale) {\n\treturn(bool(\n\t\tint(mod(pos.x, scale.x * 2.0) < scale.x) ^\n\t\tint(mod(pos.y, scale.y * 2.0) < scale.y) ^\n\t\tint(mod(pos.z, scale.z * 2.0) < scale.x)));\n}\n\nbool block_pattern_3(const vec3 pos, const vec3 scale) {\n\treturn(bool(\n\t\t(mod(pos.x, scale.x * 2.0) < scale.x) &&\n\t\t(mod(pos.y, scale.y * 2.0) < scale.y) &&\n\t\t(mod(pos.z, scale.z * 2.0) < scale.x)));\n}\n\n\n\n\nfloat sd_sphere(const in vec3 p, const in float sph_rad) {\n    return(length(p) - sph_rad);\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sd_box_frame(vec3 p, vec3 b, float e) {\n  p = abs(p)-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// t.y = thickness\nfloat sd_torus(const in vec3 p, const in vec2 t) {\n    return(length( vec2(length(p.xz)-t.x,p.y) )-t.y);\n}\n\nfloat sd_octagon_prism(in vec3 p, in float r, const in float h ) {\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return(min(max(d.x,d.y),0.0) + length(max(d,0.0)));\n}\n\nfloat map(const in vec3 p) {\n    float sd = 1e10;\n    sd = sd_box(p - vec3(0,-10,0), vec3(60, 10, 60));\n    sd = min(sd, sd_box_frame(p - vec3( 0,5,0),   vec3(3,5,3), 0.4) - 0.05);\n    sd = sdu (sd, sd_box_frame(p - vec3(-8,2,9),  vec3(1,1,1), 0.0) - 0.05);\n    sd = sdu (sd, sd_box      (p - vec3( 4,5,20),  vec3(1,2,1))       - 0.2);\n    sd = smin(sd, sd_sphere   (p - vec3( -4,2,15), 1.5 )                    , 2.0);\n    sd = smin(sd, sd_octagon_prism((p - vec3(0,0,10)).xzy, 2.0, 3.0) - 0.3  , 1.0);\n    return(sd);\n}\n\nfloat raymarch(const in vec3 rp, const in vec3 rd) {\n    vec3 p = rp;\n    float t = 0.0;\n    for(int i = 0; i < 64; i++) {\n        float sd = map(p);\n        p += rd * sd;\n        t += sd;\n        if(sd < 0.001*t) { break; }\n    }\n    return(t);\n}\n\nfloat raymarch_shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        // use this if you are getting artifact on the first iteration, or unroll the\n        // first iteration out of the loop\n        //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n\nvec3 sdf_calc_normal(const in vec3 p) {\n    const float eps = 1e-4;\n    return normalize(vec3(\n        map(vec3(p.x+eps, p.y, p.z)) - map(vec3(p.x-eps, p.y, p.z)),\n        map(vec3(p.x, p.y+eps, p.z)) - map(vec3(p.x, p.y-eps, p.z)),\n        map(vec3(p.x, p.y, p.z+eps)) - map(vec3(p.x, p.y, p.z-eps))\n    ));\n}\n\nfloat specular_blinn_phong(in vec3 rp, in vec3 p, in vec3 n, in vec3 lp, in float shininess) {\n    vec3 light_dir   = normalize(lp - p);\n    vec3 view_dir    = normalize(rp - p);\n    vec3 halfway_dir = normalize(light_dir + view_dir);\n    float res = pow(max(dot(n, halfway_dir), 0.0), shininess);\n    return(res);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv = (fragCoord/iResolution.xx * 2.0) - vec2(1.0); // uv from -1 to 1\n    vec3 col = vec3(1.0);\n\n    vec3 cam_pos = vec3(sin(iTime*0.2), 0.1, cos(iTime*0.2)) * 16.0;\n    float yaw = (iMouse.x / iResolution.x) - 0.5;\n    float pitch = ((iResolution.y - iMouse.y) / iResolution.y) - 0.5;\n    vec3 cam_forw = normalize(-cam_pos);\n    vec3 cam_right = cross(cam_forw, vec3(0, 1, 0));\n    mat3 cam_rot = mat3(cam_right, cross(cam_right, cam_forw), cam_forw);\n    \n    vec3 lrd = normalize(vec3(nuv,0.5));\n    vec3 rd = normalize(cam_rot * lrd);\n    vec3 rp = cam_pos + vec3(0,8.0,0);\n    \n    {\n        float rm = raymarch(rp, rd);\n        vec3 p = rp + rd*rm;\n        vec3 n = sdf_calc_normal(p);\n        \n        bool pattern = checker_pattern_3(p, vec3(1.5));\n        col = pattern ? vec3(0.8) : vec3(0.6);\n        float roughness = pattern ? 50.0 : 25.0;\n        //roughness += float(checker_pattern_3(p, vec3(0.15))) * 0.2;\n\n        // point light\n        vec3 pl_pos = vec3(sin(-iTime*PI*0.5) * 10.0, 35, cos(iTime*PI*0.5) * 10.0);\n        vec3 pl_dir = pl_pos - p;\n        float pl_dist = length(pl_dir);\n        float pl_str;\n        pl_str = 500.0 * max(0.0, dot(normalize(pl_dir), n)) / (length_sq(pl_dir)*2.0);\n        float pl_spec = specular_blinn_phong(rp, p, n, pl_pos, roughness) * 0.2;\n        \n        // shadow\n        {\n            float shadow_str = raymarch_shadow(p + n*0.05, pl_dir / pl_dist, 0.01, 50.0);\n            float light = shadow_str;\n            pl_str *= light + 0.1;\n            pl_str += pl_spec * light;\n            col *= pl_str;\n            //col = vec3(light);\n        }\n    }\n    \n    // gamma correct\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(can_write_var(ADDR_CAM_POS, fragCoord)) {\n        vec3 prev = read_var(CHANNEL_VARS, ADDR_CAM_POS).rgb;\n        float yaw = (iMouse.x / iResolution.x) - 0.5;\n        float pitch = ((iResolution.y - iMouse.y) / iResolution.y) - 0.5;\n        vec3 cam_forw = yaw_pitch_to_dir(3.0*yaw, 3.0*pitch);\n        vec3 cam_right = cross(cam_forw, vec3(0, 1, 0));\n        vec3 dir = vec3(0.0);\n        dir += cam_right * read_var(CHANNEL_KEYS, ADDR_KEY_STATE_D).x - read_var(CHANNEL_KEYS, ADDR_KEY_STATE_A).x;\n        dir += vec3(0, 1, 0) * (read_var(CHANNEL_KEYS, ADDR_KEY_STATE_SPACE).x - read_var(CHANNEL_KEYS, ADDR_KEY_STATE_C).x);\n        dir += cam_forw * (read_var(CHANNEL_KEYS, ADDR_KEY_STATE_W).x - read_var(CHANNEL_KEYS, ADDR_KEY_STATE_S).x);\n\n        fragColor = vec4(dir, 1.0);\n        fragColor = vec4(prev + dir*iTimeDelta*2.0, 1.0);\n    }\n    \n    if(can_write_var(ADDR_CAM_ROT, fragCoord)) {\n    \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define CHANNEL_VARS iChannel0\n#define CHANNEL_KEYS iChannel1\n\nconst ivec2 ADDR_CAM_POS = ivec2(0, 0);\nconst ivec2 ADDR_CAM_ROT = ivec2(1, 0);\n\n#define ADDR_KEY_STATE_W ivec2(87, 0)\n#define ADDR_KEY_STATE_A ivec2(65, 0)\n#define ADDR_KEY_STATE_S ivec2(83, 0)\n#define ADDR_KEY_STATE_D ivec2(68, 0)\n#define ADDR_KEY_STATE_SPACE ivec2(32, 0)\n#define ADDR_KEY_STATE_C ivec2(67, 0)\n\n#define read_var(channel, addr) (texelFetch(channel, addr, 0))\n\nbool can_write_var(const in ivec2 addr, const in vec2 fragCoord) {\n   return(addr == ivec2(fragCoord));\n}\n\nvec3 yaw_pitch_to_dir(in float yaw, in float pitch) {\n\treturn(vec3(sin(yaw), cos(pitch), -sin(pitch) * cos(yaw)));\n}\n","name":"Common","description":"","type":"common"}]}