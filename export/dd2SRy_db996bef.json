{"ver":"0.1","info":{"id":"dd2SRy","date":"1670494496","viewed":73,"name":"Heart Flag","username":"greenbird10","description":"This is for knowledge sharing of basic shader functions","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["heart","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float x = uv.x;\n    float y = uv.y;\n    \n    // UV\n    //vec3 col = vec3(x, y, 0.);\n    \n    // gradient\n    //vec3 col = vec3(x, x, x);\n    \n    // circle\n    // x^2 + y^2 = 1\n    // (x - a)^2 + (y - b)^2 <= r\n    //float d = (x-0.5)*(x-0.5) + (y-0.5)*(y-0.5);\n    //float c = d <= 0.05 ? 1. : 0.;\n    //vec3 col = vec3(c);\n    \n    // optimised circle\n    //float c = step(pow(x-0.5,2.) + pow(y-0.5,2.), 0.05);\n    //vec3 col = vec3(c);\n    \n    // why it's stretched\n    //float newx = uv.x * iResolution.x / iResolution.y;\n    //float c = step(pow(newx-0.5,2.) + pow(y-0.5,2.), 0.05);\n    //vec3 col = vec3(c);\n    \n    // more shapes\n    /*\n    x = uv.x * iResolution.x / iResolution.y;\n    float posx = 1.;\n    float posy = 0.5;\n    float r = 0.1;\n    float c = step(pow(x-(posx+r),2.) + pow(y-posy,2.), r*r) * step(posy,y);\n    c += step(pow(x-(posx-r),2.) + pow(y-posy,2.), r*r) * step(posy,y);\n    c += step(y, posy) * step(posx, x) * step(x-posx, y-posy+2.*r);\n    c += step(y, posy) * step(x, posx) * step(posx-x, y-posy+2.*r);\n    vec3 col = vec3(c, 0., 0.);\n    */\n    \n    // moving\n    /*\n    x = uv.x * iResolution.x / iResolution.y;\n    float posx = sin(iTime)*0.5 + 0.9;\n    float posy = cos(iTime)*0.5 + 0.5;\n    float r = 0.1;\n    float c = step(pow(x-(posx+r),2.) + pow(y-posy,2.), r*r) * step(posy,y);\n    c += step(pow(x-(posx-r),2.) + pow(y-posy,2.), r*r) * step(posy,y);\n    c += step(y, posy) * step(posx, x) * step(x-posx, y-posy+2.*r);\n    c += step(y, posy) * step(x, posx) * step(posx-x, y-posy+2.*r);\n    vec3 col = vec3(c, 0., 0.);\n    */\n    \n    // tiling\n    x = uv.x * iResolution.x / iResolution.y;\n    float offset = floor(x * 10.) + floor(y * 10.);\n    x = fract(x * 10.);\n    y = fract(y * 10.);\n    float posx = (sin(iTime+offset)*0.5 + 0.5) * 0.5 + 0.25;\n    float posy = (cos(iTime+offset)*0.5 + 0.5) * 0.5 + 0.25;\n\n    float r = 0.1;\n    float c = step(pow(x-(posx+r),2.) + pow(y-posy,2.), r*r) * step(posy,y);\n    c += step(pow(x-(posx-r),2.) + pow(y-posy,2.), r*r) * step(posy,y);\n    c += step(y, posy) * step(posx, x) * step(x-posx, y-posy+2.*r);\n    c += step(y, posy) * step(x, posx) * step(posx-x, y-posy+2.*r);\n    vec3 col = vec3(c, 0., 0.);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}