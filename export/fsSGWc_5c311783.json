{"ver":"0.1","info":{"id":"fsSGWc","date":"1618613151","viewed":95,"name":"Doraemon close up","username":"jackisgames","description":"Your robot cat friend from the future","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarchdoraemon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy ) / iResolution.xy;\n    \n    fragColor = texture( iChannel0 , uv );\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 LIGHT_DIR = normalize( vec3( .2f, .3f, -.25f ) );\nconst float HEAD_SIZE = 2.15f;\n\n//////////////////////////////////\n\n//https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n////////////////////////////////////\n\n/*mat4 GetMatrix( vec3 pos, vec3 dir )\n{\n    dir = normalize(dir);\n    vec3 right = normalize( cross( vec3( 0.0f, 1.0f, 0.0f ), dir ) );\n    vec3 up = normalize( cross( dir, right ) );\n    return mat4\n    (\n         vec4( right, 0.0f),\n         vec4( up, 0.0f),\n         vec4( dir, 0.0f ),\n         vec4( pos ,1.0f)\n    );\n}*/\n\nmat3 GetMatrix( vec3 dir )\n{\n    dir = normalize(dir);\n    vec3 right = normalize( cross( vec3( 0.0f, 1.0f, 0.0f ), dir ) );\n    vec3 up = normalize( cross( dir, right ) );\n    return mat3\n    (\n         right,\n         up,\n         dir\n    );\n}\n\nvoid GetRay( in vec2 fragCoord, out vec3 pos, out vec3 dir )\n{\n    float distance = -6.5f;\n\n    float offset = 0.0f;\n    pos = vec3( sin(offset) * 8.0f , 1.0f, cos(offset) * -8.0f);\n\n    float n = .3f/max(iResolution.x, iResolution.y);\n    \n    vec3 camFwd = normalize( -pos );\n    vec3 camRight = cross( vec3( 0, 1, 0), camFwd );\n\n    mat3 cameraOrientation = mat3( \n     camRight.x, camRight.y, camRight.z ,\n     0, 1, 0 ,\n     camFwd.x, camFwd.y, camFwd.z );\n     \n    dir = normalize(vec3((fragCoord - iResolution.xy*0.5)*n, 0.5));;//cameraOrientation * normalize(vec3((fragCoord - iResolution.xy*0.5)*n, 0.5));\n}\n\nvec3 RayToPlane( vec3 pn, vec3 pp, vec3 rd, vec3 rp )\n{\n    float denom = dot( pn, rd );\n    \n    float t = dot( pp - rp, pn );\n    \n    return rp + rd * t;\n}\n\nvec3 Background( vec3 dir )\n{\n    float sun = max( 0.0, dot( dir, LIGHT_DIR));\n    sun = smoothstep( 0.199, 1.0, sun);\n    sun = pow(sun, 20.0);\n    \n    \n    float horizon = max( 0.0, dot( dir, vec3(0.0f, 1.0f, 0.0f )));\n    horizon = smoothstep( -.45f, .09f, horizon);\n \n    \n    return vec3( horizon + sun);\n}\n\nvec3 HeadColor( vec3 p, vec3 rayPos, vec3 rayDir, out vec3 normal )\n{\n    vec3 c = vec3(1);\n    {\n        //main head color\n        vec3 center = normalize(vec3( 0.0f, -.37f, -.8f) ) * HEAD_SIZE;\n        vec3 dt = center - p;\n        \n        const float edge = HEAD_SIZE * .9f;\n        float diff = clamp( (length(dt) - edge ) * 10.0f * 4.0f, -1.0f, 1.0f) ;\n        //https://blog.pablolarah.cl/2012/08/color-palette-3-doraemon.html\n\n        c = mix( vec3(1.0f), vec3( 25.0f / 255.0f, 171.0f / 255.0f, 255.0f / 255.0f), step(0.0f, diff )  );\n\n        c = mix( vec3(0.8f) * c, c, abs(diff) );\n        \n    }\n    \n    {\n        //eyes\n        float diff = HEAD_SIZE;\n        \n        const float edge = HEAD_SIZE * .185f;\n        \n        \n        for( int i = -1; i <= 1; i +=2)\n        {\n            vec3 eyePos = normalize(vec3( float( i ) * .17f, 0.42f, -.8f) ) * HEAD_SIZE;\n            vec3 dt = eyePos - p;\n            \n            float d = clamp( ( (dt.x * dt.x + dt.y * dt.y * (.8f - float(i) * (dt.x / edge) * .063f)) - edge * edge ) * 9.0f , -1.0f, 1.0f );\n            \n            diff = min( diff, d);\n           \n        }\n        diff = clamp(diff / HEAD_SIZE, -1.0f , 1.0f) * 62.0f;\n\n        c = mix( vec3(1.0f), c, step( 0.0f, diff));\n        \n        \n        \n\n        c = mix( c, vec3(0.8f) * c, exp(1.0 - abs(diff)) );\n        \n        const vec3 faceDirection = normalize(vec3(0.0,0.0, 1.0f));\n        vec3 targetDir;\n        vec3 targetPos;\n        GetRay(iMouse.xy, targetPos, targetDir);\n        \n        float blink = step( .045f , fract( iTime * .5f ) );\n        \n        for( int i = -1; i <= 1 ; i +=2)\n        {\n            //pupils\n            \n            vec3 eyePos = normalize(vec3( float( i ) * .16f, 0.4f, -.8f) ) * HEAD_SIZE;\n            \n            vec3 lookPos = RayToPlane(faceDirection, eyePos, targetDir, targetPos );\n            vec3 lookOffset = (lookPos - eyePos);\n            float eyeOffX= float(i) * .015f;\n\n            float lookAngle = atan( lookOffset.y * 2.0f, lookOffset.x );\n\n            float offsetx = clamp( lookOffset.x, -.23f + eyeOffX , .23f - eyeOffX  );\n            float offsety = clamp( lookOffset.y, -.28f, .3f);\n            \n            eyePos.x+= offsetx * ( 1.0f - abs( sin( lookAngle ) ) );\n            eyePos.y+= offsety;\n\n            vec3 eyePosProjected = RayToPlane(faceDirection, eyePos, rayDir, rayPos);\n\n            float pupil = edge * (.32f + (1.0f - blink) * .13f);     \n            \n            vec3 eyeDt = eyePos - eyePosProjected;\n            float eyeDist = length( eyeDt);\n            float eyeMain = clamp( (pupil - eyeDist) * 100.0f, 0.0f, 1.0f) ;\n\n            vec2 eyePosDelta = (eyePos.xy - eyePosProjected.xy);\n            float blinkMultiplier = step( abs( eyePosDelta.y), eyeMain * (0.025f + blink ) );\n            c = mix( c, vec3(0.0f), step( length( eyePosDelta), eyeMain * blinkMultiplier ));\n\n            float fallOff = (1.0f - clamp( eyeDt.y + 0.78f, 0.0f , 1.0f)) * 3.0f;\n            \n            \n            float pupilInnerA = pupil * .78f;\n            float eyeInnerA = (abs( pupilInnerA - eyeDist ) / pupilInnerA - .13f ) * 10.5f;\n\n            float pupilInnerB = pupil * .50f;\n            float eyeInnerB = (abs( pupilInnerB - eyeDist ) / pupilInnerB - .18f ) * 1.0f;\n            \n            c = mix( mix( vec3(209.0f / 255.0f, 135.0f / 255.0f , 65.0f / 255.0f), c, blinkMultiplier * fallOff) , c, clamp( 99.0f * (1.0f - blinkMultiplier ) + min( eyeInnerA, eyeInnerB ), 0.0f, 1.0f) );\n            \n            //eye glow\n            float glowAngle = iTime + sin(noise1d(iTime))* .01f;\n            vec2 glowOff = vec2( sin(glowAngle*20.0f) , cos(glowAngle * 15.0f)) * .0015f;\n            \n            float glowA = pupil * .1f;\n            vec3 eyeGlowAPosProjected = RayToPlane(faceDirection, eyePos, rayDir, eyePos - vec3( 0.035f, -0.035f, 0.0f) );\n            float glowDistA = length(eyeGlowAPosProjected.xy + glowOff - eyePosProjected.xy);\n            c = mix( c, vec3(1.0f), step(glowDistA, .025f * blink));\n            \n        }\n    }\n    \n    {\n        //details\n        const float start = .21f;\n        const float end =  -.07f;\n        const float width =  .006f;\n        \n        vec3 coordP = normalize(p);\n        \n        float diffX = clamp( 1.0f - abs( coordP.x )/width, 0.0f, 1.0f);\n        \n        float diffY = step( coordP.y, start) * step( end ,coordP.y);\n        \n        c = mix( c, vec3(.8f), diffX * diffY );\n    }\n    \n    return c;\n}\n\nvec3 NoseColor( vec3 n, vec3 dir )\n{\n    return vec3( dot( Background( reflect( dir, n )), vec3( 1.0f, 0.0f, 0.0f ) ), 0.0f, 0.0f);\n}\n\nRayData GetScene( vec3 p )\n{\n    float d = MAX_DISTANCE;\n    \n    {// main body\n    \n       {\n          //center\n          float s = sdSphere( p, HEAD_SIZE );\n          d = min(d, s);\n          \n          if( d < EPSILON )\n          {\n              return RayData(d, 0 );\n          }\n       }\n       \n       {\n          //nose\n          float s = sdSphere( p + normalize(vec3(0.0f, -.265f, 1.0f)) * HEAD_SIZE, HEAD_SIZE * .1f );\n          d = min(d , s);\n          \n          if( d < EPSILON )\n          {\n              return RayData(d, 1 );\n          }\n       }\n       \n       {\n           //whiskers\n           \n           for( int x = -1; x <= 1; x+= 2)\n           {\n               for( int y = 0; y < 3; y++ )\n               {\n                   vec3 pos = normalize(vec3(0.25f * float(x), .16f - float(y) * .1f, -1.02f)) * HEAD_SIZE;\n                   float c = sdCapsule( p, pos, pos + normalize(vec3( 0.7f * float(x), 0.3f  - float(y) * .3f, -.1f)) * 0.9f, .001f ); \n                   d = min(d , c);\n\n                   if( d < EPSILON )\n                   {\n                      return RayData(d, 2 );\n                   }\n               }\n           }\n           \n       }\n       \n       \n    }\n    \n    return RayData( d, -1);\n}\n\nvec3 GetNormal( vec3 p , vec3 dir )\n{\n                            \n    float d0 = GetScene( p ).d;\n    vec2 off = vec2( EPSILON, 0.0f );\n    vec3 d1 = vec3( GetScene( p - off.xyy ).d, GetScene( p - off.yxy ).d, GetScene( p - off.yyx ).d);\n    \n    return normalize( d0 - d1);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    vec3 pos, dir;\n    GetRay( fragCoord, pos, dir );\n    \n    \n    vec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    float distance = 0.0f;\n    vec3 color = Background( dir );\n    for( int i = 0; i < 256; i++)\n    {\n        vec3 p = pos + dir * distance;\n        vec3 c = vec3(0);\n        RayData rd = GetScene( p );\n\n        \n        if( rd.d < EPSILON )\n        {\n            vec3 n = GetNormal( p , dir );\n\n            if(rd.objId == 0 )\n            {\n                color = HeadColor(p, pos, dir, n );\n            }\n            else if( rd.objId == 1 )\n            {\n                color = NoseColor( n , dir );\n            }\n            else if( rd.objId == 2 )\n            {\n                color = vec3(0);\n            }\n            else if( rd.objId == 3 )\n            {\n                color = vec3(0.8f);\n            }\n\n            \n            float amb = (.4f + .3f * n.y );\n\n            color *= max( amb, dot( n, LIGHT_DIR ) );\n            \n            break;\n        }\n        else if( distance > MAX_DISTANCE )\n        {\n            break;\n        }\n\n        distance += rd.d;\n    }\n    \n    fragColor = vec4( color, 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//////////////////////////////////\n//https://www.shadertoy.com/view/lldBRn\n\nfloat noise1d(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\n//////////////////////////////////\nconst float EPSILON = .01f;\nconst float MAX_DISTANCE = 1000.0f;\n\nstruct RayData\n{\n    float d;\n    int objId;\n};\n\nfloat remap(float a, float b, float c, float d, float t) {\n\treturn (t-a)/(b-a) * (d-c) + c;\n}","name":"Common","description":"","type":"common"}]}