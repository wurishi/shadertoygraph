{"ver":"0.1","info":{"id":"XlfBzj","date":"1512423550","viewed":125,"name":"Power puffs heart","username":"kobilica","description":"Playing with modulus on scalar field of heart function. Heart function is actually algebraic curve.\n\nTried to mimic power puffs, I know it's quite off but I think idea is same.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["heart","scalarfield","modulus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://mathworld.wolfram.com/HeartCurve.html\n\n//heart formula\nfloat heartScalarField(in vec2 p) {\n    \n    float x  = p.x;\n    float x2 = p.x * p.x;\n    float y  = p.y;\n    \n    float A = (1.25*y - sqrt(abs(x)));\n    float A2 = A * A;\n    \n    return x2 + A2 - 1.;\n}\n\n//golden ratio\nconst float gr = 1.61803398875;\nconst float gr2 = gr * gr;\nconst float gr3 = gr2 * gr;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.x;\n    \n   \tvec2 c = uv - 0.5;\n    c += vec2(0., 0.25);\n    \n    //c = vec2(c.x + 0.1 * sin(1.5*iTime + c.y + c.x), c.y);\n    \n    //float myTime = 2.*iTime + 0.45*sin(4.*iTime) - 0.33*sin(8. * iTime);   \n    //float myTime = 0.;\n    float steps = .3333333;\n    float myTime = 0.25 + floor(3.*iTime/steps)*steps;\n    \n    float field = heartScalarField(c*4.);\n    \n    vec3 volume = vec3(1.0, 1.0,   1.0);\n    vec3 band   = vec3(1.0, 1.0,   1.0);   \n    vec3 phase  = vec3(0.0, 0.33, .66) * band;\n    vec3 speed  = vec3(1.0, 1.0,  1.0);\n    vec3 multi  = vec3(1.0, 1.0,  1.0);\n    \n    vec3 color = (mod(phase + multi*field - speed * myTime, band) / band) * volume;\n    \n    vec3 color1 = vec3(0.890, 0.509, 0.576) * color.r;   \n    vec3 color2 = vec3(0.901, 0.815, 0.843) * color.g;\n    vec3 color3 = vec3(0.772, 0.168, 0.270) * color.b;\n    \n\tfragColor = vec4(color1 + color2 + color3, 1.);\n    \n}","name":"Image","description":"","type":"image"}]}