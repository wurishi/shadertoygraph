{"ver":"0.1","info":{"id":"XsdfRn","date":"1524011999","viewed":107,"name":"F03 Moon","username":"Azunyan_Taichou","description":"Moon","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["moon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 colorA= vec3(0,0,0); // Black\nvec3 colorB= vec3(1.0,1.0,1); // Red\nvec3 colorC= vec3(0,0,0); // White\n\n// Value Noise\nfloat vhash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat vnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( vhash( i + vec2(0.0,0.0) ), \n                     vhash( i + vec2(1.0,0.0) ), u.x),\n                mix( vhash( i + vec2(0.0,1.0) ), \n                     vhash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// Gradient Noise\nvec2 ghash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( ghash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( ghash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( ghash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( ghash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// Simplex Noise\nvec2 shash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,shash(i+0.0)), dot(b,shash(i+o)), dot(c,shash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\nfloat circle(vec2 uv, vec2 pos, float radius, float width)\n{\n    float dist = distance(pos, uv);\n    float value = step(radius - width, dist) - step(radius - gnoise(uv *1005.) , dist);\n    \n    return value;\n}\n\nfloat rect(vec2 uv, vec2 pos, vec2 size)\n{\n\n    float value = step(pos.x,uv.x);\n    value = (step(pos.x,uv.x) - step(pos.x+size.x,uv.x)); \n    value *= (step(pos.y, uv.y) - step(pos.y+size.y,uv.y));\n   \n    return value;\n}\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    float zoom = 8.;\n    float scale = .02;\n    \n    float offset = gnoise(uv *zoom * iTime) * scale; // Noise\n   \tvec2 pos = vec2(0.5 *ratio, 0.5);\n    float radius = abs(0.2);\n    float width = 1.0;\n    float value = circle(uv, pos +offset, radius, width);\n    vec3 color = mix(colorC, colorB, value);\n\n   \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}