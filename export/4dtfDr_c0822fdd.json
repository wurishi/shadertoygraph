{"ver":"0.1","info":{"id":"4dtfDr","date":"1524753513","viewed":1830,"name":"Gerstner Waves","username":"nr4","description":"Analytic liquid rendering with Gerstner Waves.\nIntroduction: http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch01.html","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["waves","analytic","gerstner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Gerstner Waves\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n//Changes:\n//1: removed the incompatible inverse(.) call\n//2: removed the S() and C() functions\n//3: removed array setup and combined in one single function call\n\n//universal constants\nconst float pi = acos(-1.);\nconst vec2 c = vec2(1.,0.);\nconst int nwaves = 9;\n\nfloat rand(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvoid wave(in int i, out float st, out float am, out vec2 di, out float fr, out float sp)\n{\n    //setup wave params\n\tst = abs(.35*rand(vec2(float(i))));//qi\n\tam = .02+.005*rand(vec2(float(i+2)));//ai\n    di = (1.e0+vec2(1.7e0*rand(vec2(i,i+1)), 2.e0*rand(vec2(i+1,i))));//di\n    fr = 6.+12.*rand(vec2(float(i+5)));//wi\n    sp = 55.e-1+52.e-1*rand(vec2(float(i+4)));//phi\n}\n\nvoid gerst(in vec2 xy, in float t, out vec3 val, out vec3 deriv)\n{\n    val = vec3(xy, 0.);\n    deriv = c.yyy;\n    \n   \tfloat st,fr,sp,am;\n    vec2 di;\n    \n    for(int i=0; i<nwaves; ++i)\n    {\n   \t\twave(i, st, am, di, fr, sp);\n        \n        //gen values\n        float d = dot(di, xy);\n\t\tval += vec3(st*am*di*cos(fr*d+sp*t), am*sin(fr*d+sp*t));\n    }\n\n    for(int i=0; i<nwaves; ++i)\n    {\n        wave(i, st, am, di, fr, sp);\n        \n        //gen derivatives\n        deriv += vec3(\n            -di*fr*am*cos(fr*dot(di,val.xy)+sp*t),\n            1.-st*fr*am*sin(fr*dot(di,val.xy)+sp*t)\n        );\n    }\n    \n    deriv = normalize(deriv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //raytrace and colorize\n    vec2 uv = fragCoord/iResolution.yy;\n\tvec3 o = c.yyx, r = 1.*c.xyy, u = 1.*c.yxy+c.yyx, d = normalize(cross(u,r)),\n        ro = o+uv.x*r+uv.y*u;\n    \n    vec3 l = (c.yyx-3.*c.yxy),\n        //p = inverse(mat3(d,c.xyy,c.yxy))*ro, //unportable!\n        p = mat3(c.yxy, c.yyx, 1./d.z, -d.x/d.z, -d.y/d.z)*ro,\n        n, val;\n        \n    gerst(p.xy, iTime, val, n);\n    \n    vec3 re = normalize(reflect(-l, n)), \n        v = normalize(p-ro);\n    \n    vec3 col = .2*c.yxx+.2*c.yyx*dot(l, n)+3.6e1*c.xxx*pow(dot(re,v), 4.);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}