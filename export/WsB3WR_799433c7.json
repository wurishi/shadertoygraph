{"ver":"0.1","info":{"id":"WsB3WR","date":"1548699888","viewed":474,"name":"Distance Field XOR Patterns","username":"fizzer","description":"Following some discussion about XOR patterns on Twitter, I realised that the patterns could also be produced as signed distance fields. Shown here are 4 different patterns produced by \"XOR\", which are implemented as proper signed distance fields.\n","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["sdf","xor","tilings"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Following some discussion about XOR patterns on Twitter, I realised that the patterns\n// could also be produced as signed distance fields.\n//\n// https://twitter.com/paniq/status/1088804349860593665\n// https://twitter.com/RobFathauerArt/status/1088131858179575809\n// https://twitter.com/eddbiddulph/status/1088825455308931072\n//\n\n// Symmetric difference of two SDFs.\n// https://en.wikipedia.org/wiki/Symmetric_difference\nfloat symmetricDiff(float a, float b)\n{\n    // (A ∪ B) \\ (A ∩ B)\n    return max(min(a, b), -max(a, b));\n}\n\n// (3.6)² pattern\nfloat dist3636(vec2 p)\n{\n    float a = abs(fract(p.x) - .5) - .25;\n\n    a = symmetricDiff(a, abs(fract(dot(p, vec2(.5, .86602))) - .5) - .25);\n    a = symmetricDiff(a, abs(fract(dot(p, vec2(.5, -.86602))) - .5) - .25);\n\n    return a;\n}\n\n// 3^6 pattern\nfloat dist333333(vec2 p)\n{\n    float a=abs(fract(p.x) - .5) - .25;\n\n    a = symmetricDiff(a, abs(fract(dot(p, vec2(.5, .86602))) - .5) - .25);\n    a = symmetricDiff(a, abs(fract(dot(p, vec2(.5, -.86602)) - .25) - .5) - .25);\n\n    return a;\n}\n\n// 4^4 pattern\nfloat dist4444(vec2 p)\n{\n    return symmetricDiff(abs(fract(p.x) - .5) - .25, abs(fract(p.y) - .5) - .25);\n}\n\n// Combined rotated 4^4 patterns\nfloat dist4444b(vec2 p)\n{\n    float d = 1e4;\n    \n    for(int i = 0; i < 3; ++i)\n    {\n        float a = float(i) / 3. * 3.14159265358979 * 2.;\n        vec2 p2 = vec2(cos(a) * p.x + sin(a) * p.y, -sin(a) * p.x + cos(a) * p.y);\n        d = symmetricDiff(d, dist4444(p2));\n    }\n\n    return d;\n}\n\nfloat patternDist(vec2 p)\n{\n    vec2 p2 = p;\n    float s = .9;\n    p2 *= s;\n\n    float d0 = dist4444b(p2);\n\n    p2.y -= 1. - s;\n    \n    float d1 = dist3636(p2);\n\n    p2.y -= 1. - s;\n    \n    float d2 = dist333333(p2);\n\n    p2.y -= 1. - s;\n    \n    float d3 = dist4444(p2);\n\n    float pz2 = mod(p.y, 8.);\n\n    float d = 1e4;\n\n    d = min(d, max(d0, abs(pz2 - 1.) - s));\n    d = min(d, max(d1, abs(pz2 - 3.) - s));\n    d = min(d, max(d2, abs(pz2 - 5.) - s));\n    d = min(d, max(d3, abs(pz2 - 7.) - s));\n\n    return d / s;\n}\n\n\nfloat dist(vec3 p)\n{\n    float a = -patternDist(p.xz);\n\n    float b;\n\n    b = max(a, p.y - .1);\n    \n    b = min(b, length(max(vec2(abs(a), p.y) - vec2(.0, .105), 0.)) - .005);\n    b = min(b, p.y - .04);\n\n    return b;\n}\n\n// Forward-difference SDF gradients.\nvec3 distG(vec3 p)\n{\n    vec2 e = vec2(1e-3, 0);\n    return vec3(dist(p + e.xyy), dist(p + e.yxy), dist(p + e.yyx)) -\n        vec3(dist(p - e.xyy), dist(p - e.yxy), dist(p - e.yyx));\n}\n\n// Soft shadow for SDF, from IQ and Sebastian Aaltonen:\n// https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n\n    for( int i=0; i<32; i++ )\n    {\n        float h = dist( ro + rd*t );\n\n        // traditional technique\n        if( technique==0 )\n        {\n            res = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n\n        t += h;\n\n        if( res<0.0001 || t>tmax ) break;\n\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Primary ray.\n    vec3 ro = vec3(0, 1.5, 4.5 - iTime / 12.);\n    vec3 rd = normalize(vec3(uv, -1.9));\n\n    float an = 1.;\n    rd.yz *= mat2(cos(an), sin(an), -sin(an), cos(an));\n\n    vec3 rdx = rd + dFdx(rd);\n    vec3 rdy = rd + dFdy(rd);\n\n    // Raymarching.\n    \n    float t = .5;\n    for(int i = 0; i < 60; ++i)\n    {\n        float d = dist(ro + rd * t);\n        if(abs(d) < 1e-5)\n            break;\n        t += d;\n    }\n\n    // Shading and lighting.\n    \n    vec3 rp = ro + rd * t;\n    vec3 n = normalize(distG(rp));\n\n    vec3 dpdx = (ro + rdx * dot(rp - ro, n) / dot(rdx, n)) - rp;\n    vec3 dpdy = (ro + rdy * dot(rp - ro, n) / dot(rdy, n)) - rp;\n    \n    float lod = log2(max(length(dpdx), length(dpdy)) * 512.);\n    \n    vec3 ld = normalize(vec3(3, 3.5, -3.5));\n    vec3 r = reflect(rd, n);\n\n    fragColor.rgb = mix(textureLod(iChannel0, rp.xz, 100.).rgb,\n                        textureLod(iChannel0, rp.xz / 2., lod).rgb, max(0., n.y)) * (.5 + .5 * dot(n, ld));\n\n    fragColor.rgb = pow(fragColor.rgb, vec3(1, .7, .5).bgr * 2.);\n\n    float sh = calcSoftshadow(rp, ld, 1e-3, .5, 1);\n\n    fragColor.rgb *= mix(.1, 1., sh);\n\n    float f = mix(pow(1. - clamp(dot(-rd, n), 0., 1.), 1.), 1., clamp((rp.y - .101) * 256., 0., 1.));\n\n    f *= smoothstep(.0, .4, textureLod(iChannel0, rp.xz, lod).r);\n\n    fragColor.rgb = mix(fragColor.rgb, texture(iChannel1, r.zyx).rgb, f);\n    fragColor.rgb *= smoothstep(0., .1, rp.y);\n\n    float s = patternDist(rp.xz);\n    \n    if(s < -.005)\n        fragColor.rgb *= smoothstep(0., .04, -s - .005);\n    else if(s > .005)\n        fragColor.rgb *= mix(.2, 1., smoothstep(0., .022, s - .005));\n\n    fragColor.rgb = mix(vec3(.9), fragColor.rgb, exp(-t / 60.));\n\n    fragColor.rgb *= 1.3;\n\n    // vignete, from IQ.\n\tvec2 q = fragCoord / iResolution.xy;\n    fragColor *= 0.5 + 0.5 * pow( 16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1 );\n    \n    // Gamma.\n    fragColor.rgb = pow(fragColor.rgb,vec3 (1. / 2.2));\n}\n\n\n","name":"Image","description":"","type":"image"}]}