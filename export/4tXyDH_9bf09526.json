{"ver":"0.1","info":{"id":"4tXyDH","date":"1504533396","viewed":3447,"name":"dynamic Epsilon Moebius","username":"ollj","description":"iMous.y scales Epsilon, you want to keep that near the bottom\nimouse.y shows  3 modes in 3 segments\n\ngeometry is from\nhttps://www.shadertoy.com/view/XldSDs","likes":45,"published":3,"flags":0,"usePreview":1,"tags":["terrain","moebius","epsilon","epsilondynamiceps","dynamicepsilon","dynamiciterations"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//this logeps is VERY old, and obsoleted by logeps() of https://www.shadertoy.com/view/dlXyzs#\n\n//mod 3d moebius band terrain (good textureID code) dynamiceps.2\n//self  : https://www.shadertoy.com/view/4tXyDH\n//parent: https://www.shadertoy.com/view/XldSDs\n//removed iChannel calls must now be explicit\n#define UseIchannel\n//extended float trace(vec3 ro, vec3 rd,vec2 uv) to support 3 modes, set by EpsExp;\n\n/*\nThis demonstrates what i call [DynamicEps family] where epsilon depends on;\n - Previuus step length\n - Distance to camera\n - Silly things like iMouse.y (debugging and BAD field visualisation)\n - a linear function,  sqrt() or log()\n - all ot the above\n*/\n\n//best quality has makes epsilon logarythm; of squared distance , divided by last step length.\n\n//illustrating 3 modes below by making epsilon multiplied by iMouse.x\n#define EpsFactor ((iMouse.y/iResolution.x)*999.+.0001)\n//main purpose of EpsFactor is to illustrate the log()\n//set #defineEpsExpMO 2 below, to see how EpsFactor~=iMouse.y becomes nearly irrelevant.\n\n// if(EpsExpMO>-1) EpsExpMO ->overwrites-> EpsExp, making iMouse.x irrelevant.\n#define EpsExpMO -1\n\n/*\n[EpsExp] sets one of 3 modes within the raymarching loop \n (this should be more static in your implementation)\nEpsExp==0 ;the prrecious step lenghth is irrelevant, epsilon is static (besides EpsFactor)\nEpsExp==1 ;previous step length linearily scales epsilon.\nEpsExp==1 ;previous step length AND distance to camera logarrythmically scale epsilon.\n\n//d is accumulated euclidean distance to camera, d is euclidean distance ot the previous step\n         if(t>FAR) break;//marchign wend beyond zFAR\n#if   EpsExp==0\n         if(abs(d)<rmEps)break;  //constant epsilon\n#elif EpsExp==1\n         if(abs(d)<rmEps*(t*.125+1.)) break; //linear epsilon\n#else\n         if(0.<log(t*t*rmEps/d)||t>FAR)break; //log(epsilon)\n#endif\n\nEpsExp 2 has significantly better precision at roughly equal runtime.\nEpsExp 2 performs exponentially worse on higher resolutions,\n         and exponewntially better on lower resolutions.\n*/\n\n\n//in the long run, logarytmiceps seems to perform best.\n\n\n/*\nThis also spawns (and kind of begs for develipng)\nDynamicIter, where the number of raymarching iterations may depend on\n - uv.y             //more iteratons near horizon)\n - uv.x             //more iterations in the centr of a corridor)\n - length(uv-mouse) //more iterations near the mouse cursot \n - dither(hash(uv)) //hide understepping, low iteration count in hashed dithering. \n\nand this only makes sense because dynamiceps allows to scale Iteration count much higher.\n*/\n\n\n\n//shape is VERY nice, suits the dynamiceps demo:\n\n/*\n    Mobius Object\n    -------------\n\n\tI love looking at the Mobius-related renderings that artistically and scientifically inclined people\n\tput up on places like DeviantArt, etc. There are so many interesting variations and rendering styles \n\tout there. There's also a few interesting examples on this site. Anyway, here's yet another one.\n\n\tAesthetically speaking, I started with a clean look that emphasized the Mobius object, then lost focus \n    and got carried away with the surroundings, which for some reason, led to things resembling a grungey, \n\tbrooding early-2000s demo scene. :) I saved the cleaner version, so I might put that up later.\n\n\tTopology was a long time ago for me, so I'm not sure what the object is technically called, but it's \n\teasy to see that it's based on the Mobius strip. In descriptive terms, I guess it's a toroidal shape... \n\ttwisted in the poloidal direction about the toroidal axis? Either way, these things are not much more \n    difficult to code than a torus.\n\n\tAs for the Mobius object construction, it's pretty straight forward for anyone comfortable with the \n\tconcepts behind a toroidal distance field. As always, it was helpful to have examples on this site to \n\trefer to. One of Dr2's versions helped me correct an annoying quantization error I was making. I'm \n\thuman, and therefore prone to errors. Thankfully, Dr2 is not. :D\n\n\tOther examples:\n    \n\t// Interlinked Mobius strips. Really cool geometry.\n\tLinked Rings - Dr2    \n\thttps://www.shadertoy.com/view/XsGXR1\n\n\t// An Escher recreation: A lot of work went into it.\n\tMoebius Strip 2 - Dr2\n\thttps://www.shadertoy.com/view/MscXWX\n\n    // I love this one. More variation.\n\tTwisted Jewelry - vgs\n\thttps://www.shadertoy.com/view/MdjXzG\n\tBased on:\n\tMÃ¶bius Balls - xTr1m\n\thttps://www.shadertoy.com/view/ldl3zr\n\n*/\n\n\n#define FAR 40.\n\n// Scene object ID to separate the Mobius object from the terrain and a Mobius object ID to separate \n// the rails from the slats. It was easier to do it this way, but I'll amalgamate them later.\nfloat objID;\nfloat mObjID;\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// IQ's smooth minium function. \nfloat smin(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\n\n// Smooth maximum, based on the function above.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp( 0.5 + 0.5*(a-b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1.0-h)*s;\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(41, 289)));\n    return fract(vec2(262144, 32768)*n);\n    \n}//https://www.shadertoy.com/view/XldSDs\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n    // I'm not sure what the largest conceivable closest squared-distance would be, but I think \n    // values as high as 2.5 (center to non-diagonal outer square corner) are possible. Statistically, \n    // it's unlikely, so when scaling back the final value to the zero-to-one range, I divide by \n    // something less than my maximum and cap it to one... It's all a matter of what look you're \n    // trying to achieve.\n\tvec3 d = vec3(2.5);\n    \n\tfor(int y=-1; y<=1; y++){\n\t\tfor(int x=-1; x<=1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o);\n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\n    // Final value, with rough scaling.\n    return min((d.y - d.x)*.6, 1.); // Scale: [0, 1].\n    \n}\n\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(fract(x)-.5);} // Triangle function.\n//vec3 triSmooth(in vec3 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\n\n// This is a cheap...ish routine - based on the triangle function - that produces a pronounced jagged \n// looking surface. It's not particularly sophisticated, but it does a surprizingly good job at laying \n// the foundations for a sharp rock face. Obviously, more layers would be more convincing. In fact, \n// I'm disappointed that there weren't enough cycles for one more layer. Unfortunately, this is a \n// GPU-draining distance function. The really fine details have been bump mapped.\nfloat terrain(in vec3 p){\n    \n    \n    // This is just one variation on a common technique: Take a cheap function, then\n    // layer it by applying mutations, rotations, frequency and amplitude changes,\n    // etc. Feeding the function into itself, folding it, and so forth can also \n    // produce interesting surfaces, patterns, etc.\n    //\n    // Good examples of the technique include IQ's spiral noise and Nimitz's triangle\n    // noise, each of which can be found on Shadertoy. \n    //\n    float n = dot(tri(p*0.3 + tri(p.yzx*0.15)), vec3(0.44));\n    p = p*1.57;//1.5773;// - n; // The \"n\" mixes things up more.\n    p.yz = mat2(.866025, .5, -.5, .866025)*p.yz;\n    p.xz = mat2(.866025, .5, -.5, .866025)*p.xz;\n    n += dot(tri(p*0.45 + tri(p.yzx*0.225)), vec3(0.222));\n    \n    return smoothstep(0.3, .95, n); // Smoothstep for peaks and troughs. Range [0, 1]\n\n\n}\n\n// The Mobius object: Take an object, sweep it around in a path (circle) at radius R, and twist (roll) \n// with the axial plane as you do it. Essentially, that's all you're doing.\n//\n// By the way, I've explained the process in a hurry with a \"near enough is good enough\" attitude, \n// so if any topology experts out there spot any conceptual errors, mislabling, etc, feel free to \n// let me know.\nfloat Mobius(vec3 q){\n \n    //// CONSTANTS ////\n    const float toroidRadius = 1.25; // The object's disc radius.\n    //const float ringWidth = .15; \n    const float polRot = 4./4.; // Poloidal rotations.\n    const float ringNum = 32.; // Number of quantized objects embedded between the rings.\n    \n    \n    //// RAIL SECTION ////\n    vec3 p = q;\n    \n    // Angle of the point on the XZ plane.\n    float a = atan(p.z, p.x);\n    \n    // Angle of the point at the center of 32 (ringNum) partitioned cells.\n    //\n    // Partitioning the circular path into 32 (ringNum) cells - or sections, then obtain the angle of \n    // the center position of that cell. The reason you want that angle is so that you can render \n    // something at the corresponding position. In this case, it will be a squared-off ring looking object.  \t\n    float ia = floor(ringNum*a/6.2831853);  \n    // The \".5\" value for the angle of the cell center. It was something obvious that I'd overlooked.\n    // Thankfully, Dr2 did not. :)\n  \tia = (ia + .5)/ringNum*6.2831853; \n    \n    // Sweeping a point around a central point at a distance (toroidRadius), more or less. Basically, it's\n    // the toroidal axis bit. If that's confusing, looking up a toroidal\\poloidal image will clear it up.\n    p.xz *= r2(a);\n    p.x -= toroidRadius;\n    p.xy *= r2(a*polRot);  // Twisting about the poloidal direction (controlled by \"polRot) as we sweep.\n    \n\n    // The rail object. Taking the one rail, then ofsetting it along X and Y, resulting in four rails.\n    // This is a neat spacial partitioning trick, and worth knowing if you've never encountered it before.\n    // Basically, you're taking the rail, and splitting it into two along X and Y... also along Z, but since \n    // the object is contiunous along that axis, the result is four rails.\n    p = abs(abs(p) - .25); // Change this to \"p = abs(p),\" and you'll see what it does.\n\n    float rail = max(max(p.x, p.y) - .07, (max(p.y-p.x, p.y + p.x)*.7071 - .075)); // Makeshift octagon.\n    \n    \n    //// REPEAT RING SECTION ////\n    // The repeat square rings. It's similar to the way in which the rails are constructed, but since the object\n    // isn't continous, we need to use the quantized angular positions (using \"ia\").\n    p = q;\n    // Another toroidal sweep using the quantized (partitioned, etc) angular position.\n    p.xz *= r2(ia); // Using the quantized angle to obtain the position of the center of the corresponding cell.\n    p.x -= toroidRadius;\n    p.xy *= r2(a*polRot);  // Twisting about the poloidal direction - as we did with the rails.\n    \n    // Constructing some square rings.\n    p = abs(p);\n    float ring = max(p.x, p.y); // Square shape.\n    // Square rings: A flat cube, with a thinner square pole taken out.\n    ring = max(max(ring - .275, p.z - .03), -(ring - .2));\n    \n    \n    //// WHOLE OBJECT ////\n    // Object ID for shading purposes.\n    mObjID = step(ring, rail); //smoothstep(0., .07, rail - sqr);\n    \n    // Smoothly combine (just slightly) the square rings with the rails.\n    return smin(ring, rail, .07); \n\n}\n\n\n// Combining the Mobius object with the terrain.\nfloat map(vec3 p){\n    \n    // Mobius object, sitting a bit above the terrain.\n    float obj = Mobius(p - vec3(0, .4, 0));\n    \n    float ter = terrain(p); // The terrain.\n \n    float fl = p.y  - ter; // Adding it to a flat plane.\n    \n    // Creating a flat area to sit the Mobius object on.\n    fl =  smax(fl, -max(length(p - vec3(0, 2.5, 0)) - 3., - p.y - .0), .5);\n \n    // Object ID.\n    objID = step(obj, fl);\n    \n    // Putting the Mobius object on the terrain.\n    return min(fl, obj);\n \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd,vec2 uv){\n float t = .0;    \n float rmIte=32.;\n float rmEps=.002; \n int EpsExp=0;//left third of iMouse \n if(uv.x>(iMouse.x/iResolution.x)*2.-1.+.5){//central third ofiMouse\n  EpsExp=2;\n  //rmIte gets \"uo to 200-3000\" rmIte-rations, for being VERY convergent log()\n  //due to maximum convergende, it rarely ever uses that many iterations\n  rmIte=min(300.,48.*log(    min(iResolution.x,iResolution.y)));\n  //values above 1000 cause too high risk to crash some implementation's drivers.\n  // rmIte=min(1000.,.5*(length(vec2(iResolution.x,iResolution.y))));\n }else if(uv.x>(iMouse.x/iResolution.x)*2.-1.5){//right third ofiMouse\n  EpsExp=1;\n  rmIte=48.;//linear increasing eps gets a few more rmIte-rations, \n            //for being a bit more convergentt\n  rmEps=.001; //and a smaller epsilon\n }\n\n //manual overwrite\n #if EpsExpMO==1\n  EpsExp=1;\n  rmIte=48.;//linear increasing eps gets a few more rmIte-rations, \n            //for being a bit more convergentt\n  rmEps=.001;//and a smaller epsilon\n #elif EpsExpMO==2\n  EpsExp=2;\n  rmIte=min(300.,48.*log(min(iResolution.x,iResolution.y)));\n  //values above 1000 cause too high risk to crash some implementation's drivers.\n//float rmIte=min(1000.,.5*(length(vec2(iResolution.x,iResolution.y))));\n  //also allows for smaller epsilon\n  rmEps= .000001;\n #endif\n rmEps*=EpsFactor;//mouse.y scales this one\n for (float i=.0; i<rmIte; i++){\n   float d=map(ro + rd*t);\n     if(t>FAR) break;\n     if (EpsExp==0){\n      if(abs(d)<rmEps)break;\n     }else if (EpsExp==1){\n      if(abs(d)<rmEps*(t*.125+1.)) break;//scaling epsilon by lasr march distance is nice.\n     }else{\n      if(0.<log(t*t*rmEps/d))break;//also logarytmic epsilon allows for high values\n     }\n     t += d*.85;  // Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// The normal function with some edge detection rolled into it. Sometimes, it's possible to get away\n// with six taps, but we need a bit of epsilon value variance here, so there's an extra six.\nvec3 getNormal(vec3 p, inout float edge, inout float crv, float ef, float t){ \n\t\n    vec2 e = vec2(ef/iResolution.y, 0); // Larger epsilon for greater sample spread, thus thicker edges.\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n    \n    \n    //crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n\t\n    // Redoing the calculations for the normal with a more precise epsilon value.\n    e = vec2(.002, 0);//*min(1. + t, 5.)\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx); \n    \n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 20; \n    \n    vec3 rd = (lp-ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = 0.05;    \n    float end = max(length(rd), 0.001);\n    //float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        //dist += min( h, stepDist ); // So many options here: dist += clamp( h, 0.0005, 0.2 ), etc.\n        dist += clamp(h, 0.01, 0.5);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing.\n    return min(max(shade, 0.) + 0.2, 1.0); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\n \n\n// The bump mapping function.\nfloat bumpFunction(in vec3 p){\n    \n    // A reproduction of the lattice at higher frequency. Obviously, you could put\n    // anything here. Noise, Voronoi, other geometrical formulas, etc.\n    return Voronoi(p.xz*6.);\n   \n   \n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel width, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(1.5/iResolution.y, 0); \n    \n    float f = bumpFunction(p); // Hit point function sample.\n    \n    float fx = bumpFunction(p - e.xyy); // Nearby sample in the X-direction.\n    float fy = bumpFunction(p - e.yxy); // Nearby sample in the Y-direction.\n    float fz = bumpFunction(p - e.yyx); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunction(p + e.xyy); // Sample in the opposite X-direction.\n    float fy2 = bumpFunction(p + e.yxy); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunction(p+ e.yyx);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*2.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 6.*f);\n    edge = smoothstep(0., 1., edge/e.x);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n    #ifdef UseIchannel\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n    #else \n     return vec3(0);\n    #endif\n}\n    \n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// I think it's based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface, \n// which is pretty handy. I used it to do a bit of fake shadowing.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.125/(w*w) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 2.;\n    p.xz += iTime*.5;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*c*c*c, c*c, c); // Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665); // Mixing in a bit of purple.\n\n}\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n \n \n    \n\t// Camera Setup.\n\tvec3 lk = vec3(0, .25, 0);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(cos(iTime/4.)*2.8, cos(iTime/2.)*sin(iTime/4.)*.25 + .75, sin(iTime/4.)*3.3); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.85, 1.75, -1);// Put it a bit in front of the camera.\n\t\n\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.25; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + (rgt*uv.x + up*uv.y)*FOV);\n\n    \n    /*   \n    // Mouse controls.   \n\tvec2 ms = vec2(0);\n    if (iMouse.z > 1.0) ms = (2.*iMouse.xy - iResolution.xy)/iResolution.xy;\n    vec2 a = sin(vec2(1.5707963, 0) - ms.x); \n    mat2 rM = mat2(a, -a.y, a.x);\n    rd.xz = rd.xz*rM; \n    a = sin(vec2(1.5707963, 0) - ms.y); \n    rM = mat2(a, -a.y, a.x);\n    rd.yz = rd.yz*rM;\n    */\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd, uv);\n    \n    float svObjID = objID;\n    float svMObjID = mObjID;\n\t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n        // Edge and edge-factor. The latter was necessary, to even up the line width between\n        // the Mobius object and the terrain... but I ultimately didn't use it. :)\n        float edge, crv = 1., ef = 4.; // Curvature variable not used, and commented out in the function.\n        \n        // Texture scale factor.\n        float tSize0 = 1.;\n        \n        // Texture-based bump mapping factor.\n        float bf = .005;\n        \n        if(svObjID<0.5) { // Different setting for the terrain.\n            bf = .02;\n            tSize0 = 1./1.;\n            ef = 1.5;\n        }\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    vec3 sn = getNormal(sp, edge, crv, ef, t);\n        \n        // Texture-based bump mapping. Comment it out, if you prefer a cleaner look.\n        // I haven't decided yet. :)\n   \n\n        #ifdef UseIchannel\n         sn =texBump(iChannel0, sp*tSize0, sn, bf);\n        #else \n          //sn = vec3(.0);\n        #endif\n        \n        // Function-based bump mapping. Note the second edge variable used for bump mapped\n        // edging - as opposed to distance field edging. There's also a second curvature\n        // variable that isn't used.\n        float edge2 = 0., crv2 = 1.;    \n        if(svObjID<.5) sn = doBumpMap(sp, sn, .1/(1. + t/FAR), edge2, crv2);    \n        \n\n\t    \n        \n        // Obtaining the texel color. \n\t    vec3 texCol;        \n        \n        if(svObjID<0.5) { // Terrain texturing.\n            \n            //texCol = vec3(.5); \n            #ifdef UseIchannel\n             texCol =tex3D(iChannel0, sp*tSize0, sn);//*vec3(1, .6, .4);\n            #else \n             texCol = vec3(.1);\n            #endif\n            texCol = smoothstep(0.05, .5, texCol)*vec3(1, .75, .5);//*vec3(1, .7, .6);//\n            texCol *= terrain(sp)*.5 + .5;\n            //texCol *= crv*.75 + .25;\n        }\n        else { // Mobius texturing.\n            \n            texCol = vec3(.5); \n            #ifdef UseIchannel\n             texCol =tex3D(iChannel0, sp*tSize0, sn);\n            #else \n             texCol = vec3(.1);\n            #endif\n            texCol = smoothstep(0.05, .5, texCol);\n            \n            // Coloring the Mobius rings. Mixing to avoid nesting an \"if\" call.\n            texCol = mix(texCol, texCol*vec3(1, .4, .2)*2., svMObjID);\n        }\n\n\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = lp-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float lDist = max(length(ld), 0.001);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, 8.);\n    \tfloat ao = cAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*0.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        diff = pow(diff, 4.)*1.5; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n\n        \n        \n        // I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        // to produce a hint of reflectivity than an actual reflective pass. :)        \n        vec3 env = envMap(reflect(rd, sn))*2.; //envMap(refract(rd, sn, 1./1.3))*3.;\n        if(svObjID<.5) { // Lowering the terrain settings a bit.\n            env *= .25;\n            //diff *= .5;\n            spec *= .5;            \n            fre *= .5;\n        }\n        \n\n        // Combining the above terms to procude the final color.\n        sceneCol += (texCol*(diff + 0.15 + vec3(.7, .9, 1)*fre) + env + vec3(.7, .9, 1)*spec*2.);\n\n        \n        // Distance function edging for the Mobius object, and bump mapped edging only\n        // for the terrain.\n        if(svObjID>.5) sceneCol *= (1. - edge*.8);\n        else sceneCol *= (1. - edge2*.7); //*crv2;//(1. - edge*.8)*\n        \n\n        // Shading.\n        sceneCol *= ao*atten*sh;\n        \n        \n\t\n\t}\n    \n    // Simple dark fog. It's almost black, but I left a speck of blue in there to account for \n    // the blue reflective glow... Although, it still doesn't explain where it's coming from. :)\n    vec3 bg = mix(vec3(.6, .5, 1), vec3(.025, .05, .1), clamp(rd.y + .75, 0., 1.));\n    sceneCol = mix(sceneCol, bg/48., smoothstep(0., .95, t/FAR));\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n    \n    fragColor.r-=.1;//reduce red, as \"personal easy differentiable (water)mark\"\n    \n    #if EpsExpMO<0\n    //mix in white border lines\n                  uv.x-=iMouse.x/iResolution.x*2.-1.;\n    fragColor=mix(vec4(1.),fragColor,\n                  min(1.,sqrt(abs(abs((uv.x))-.5))+.7));\n    #endif\n      //abs(uv.x)-(iMouse.x/iResolution.x)*2.-.5))\n\t\n}","name":"Image","description":"","type":"image"}]}