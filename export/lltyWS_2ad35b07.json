{"ver":"0.1","info":{"id":"lltyWS","date":"1534111036","viewed":1369,"name":"Radar Trace","username":"jonnyjedjedi","description":"Learning Shaders so just testing some stuff out. ","likes":19,"published":1,"flags":0,"usePreview":1,"tags":["radar","trace","blip","sweep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\nconst int N = 3;\t\t\t\t// triangle polygons please\nconst float r0 = 0.01;\t\t\t// size of centre circle\nconst float r_blue = 0.025;\t\t// size of blue radar blips\nconst float r_red = 0.015;\t\t// size of red radar blips\nconst float edge = 0.95;\t\t// overall size\nconst float offset = 0.05;\n\nfloat plot(const vec2 st, const float pct, const float width)\n\t{\n        return smoothstep(pct - width, pct, st.y) -\n               smoothstep(pct, pct + width, st.y);\n    }\n\nfloat drawPolygon(const vec2 polygonCenter, const int N, const float radius, vec2 pos)\n\t{\n\t\tpos = pos - polygonCenter;\n\t\tfloat d = 0.0;\n\t\tfloat a = atan(pos.x, pos.y);\n\t\tfloat r = TWO_PI / float(N);\n\t\td = cos(floor(0.5 + a / r)*r - a)*length(pos);\n\t\treturn (1.0 - smoothstep(radius, radius + radius/10.0, d));\n\t}\n\nfloat gradations(const float a, const float gradNum, const float outRad, const float tickLen, const float tickWidth, const float r, const float move)\n\t{\n\t\tfloat f = step(0.0, cos((a + move)*gradNum) - tickWidth)*tickLen + (outRad - tickLen);\n    \treturn 1.0 - step(f, r) * 1.0 - step(r, outRad - tickLen);\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.y;\n\tvec2 pos = uv.xy - vec2(0.825, 0.5) ; // center what being drawn\n   \n   \tvec4 grndSpd = vec4(0.0, iTime/5.0, 0.0, 0.0);\n\tvec4 mapcol = texture(iChannel0,uv) * vec4 (0.0, 0.85, 0.0, 1.0);\n  \n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tfloat r = length(pos) * 2.0;\n\tfloat a = atan(pos.y, pos.x); // angle of pixel\n\tfloat an = PI - mod(iTime / 1.0, TWO_PI); // angle of radar sweep\n    float blipSpd = 3.0; // Blip / Trace speed\n\tvec2 translate1 = vec2(cos(iTime/ blipSpd), sin(iTime / blipSpd));\n\tvec2 translate2 = vec2(sin(iTime / blipSpd), cos(iTime / blipSpd));\n\tvec2 left1 = translate1 * 0.35;\n\tvec2 right1 = -translate1 * 0.30;\n\tvec2 left2 = translate2 * 0.15;\n\tvec2 right2 = -translate2 * 0.25;\n    \n// Radar Sweep\n   \tfloat sn = step(PI/2.0, an) * step(-PI/2.0, (a + an)) * step(r, edge) * (1.0 - 0.55 * (a + (TWO_PI) - an));\n\tfloat sw = step(an, a) * step(r, edge);\n\tfloat s_blade = sw * (1.0 - (a - an) * 20.0);\n\tfloat s = sw * (1.0 - 0.55 * (a - an));\n\ts = max(sn,s);\n\tfloat se = step(r, edge - 0.05);\n   \n// Center point\n\tfloat s1 = smoothstep(edge - 0.00, edge + 0.01, r)* smoothstep(edge + 0.02, edge + 0.01, r);   \n   \n// Circular concentric rings\n\tfloat s0 = 1.0 - smoothstep(r0 / 2.0, r0, length(pos));\n    float smb = (1.0 - smoothstep(0.2, 0.2 + 0.01, length(pos))) * (1.0 - smoothstep(0.2 +0.01, 0.2, length(pos)));\n    float smr = (1.0 - smoothstep(0.3, 0.3 + 0.01, length(pos))) * (1.0 - smoothstep(0.3 +0.01, 0.3, length(pos)));\n    \n// Circular concentric gradations\n\tfloat gradNum = 120.0;\n\tfloat tickWidth = 0.9;\n\tconst float tickLen = 0.04;\n\tfloat outRad = edge;\n\tfloat move = 0.0;\n\tfloat sm = 0.75*gradations(a, gradNum, outRad, tickLen, tickWidth, r, move);   \n   \n\tgradNum = 36.0;\n\ttickWidth = 0.95;\n\toutRad = 0.6;\n\tmove = sin(iTime/10.0);\n\tsmr += 0.5*gradations(a, gradNum, outRad, tickLen, tickWidth, r, move);\n\n\toutRad = 0.4;\n\tmove = cos(iTime/10.0);\n\tsmb += 0.5*gradations(a, gradNum, outRad, tickLen, tickWidth, r, move);\n\n// Radial spoke gradations \n\tfloat sr = plot(pos, pos.x, 0.003) * step(r, edge - 0.06);\n\tsr += plot(vec2(0.0, 0.0), pos.x, 0.002) * step(r, edge - 0.06);\n\tsr += plot(vec2(0.0, 0.0), pos.y, 0.003) * step(r, edge - 0.06);\n\tsr += plot(-pos, pos.x, 0.003) * step(r, edge - 0.06);\n    sr *= 0.75;\n\n// Blue circular radar blip traces\n\tvec2 st_trace1 = left2;\n\tfloat s_trace1 = s * (1.0 - smoothstep(r_blue / 10.0, r_blue, length(pos - st_trace1)));\n\ts_trace1 += s * (1.0 - smoothstep(r_blue / 10.0, r_blue, length(pos - st_trace1 + vec2(+offset, +offset))));\n\ts_trace1 += s * (1.0 - smoothstep(r_blue / 10.0, r_blue, length(pos - st_trace1 + vec2(+2.0 *offset, +2.0 *offset))));\n\n\tvec2 st_trace2 = right1;\n\tfloat s_trace2 = s * (1.0 - smoothstep(r_blue / 10.0, r_blue, length(pos - st_trace2)));\n\n// Red Trianglular radar flight blip trace \n\tvec2 st_trace3 = left1;\n\tfloat st1 = s * (drawPolygon(st_trace3, N, r_red , pos));\n\tst1 += s * (drawPolygon(st_trace3 + vec2(-offset, -offset), N, r_red, pos));\n\tst1 += s * (drawPolygon(st_trace3 + vec2(+offset, -offset), N, r_red, pos));\n\n\tvec2 st_trace4 = right2;\n\tfloat st2 = s * (drawPolygon(st_trace4, N, r_red, pos));  \n    \n// Lets add all the bits together and send them to screen\n\tfloat s_grn = max(s * mapcol.y, s_blade);\n\ts_grn = max(s_grn, (s0 +  sr + sm));\n\ts_grn += s1 / 1.5  + smb + smr;\n\n\tfloat s_red = st1*2.0 + st2*2.0 + smr;\n\t\t\n\tfloat s_blue = max(s_trace1 + s_trace2, s_blade) + smb;\n\n\tif (s_trace1 > 0.0 || s_trace2 > 0.0) { s_blue = max(s, s_blue); s_grn = max(s_grn, s_blue); }\n\n\tcolor += vec3(s_red , s_grn, s_blue);   \n    \n    vec4 texColor = mapcol * s;\n    \n    // Output to screen   \n    fragColor = vec4(color, 1.0);//Set the screen pixel to that color\n\n}","name":"Image","description":"","type":"image"}]}