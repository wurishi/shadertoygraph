{"ver":"0.1","info":{"id":"XsScDy","date":"1493503492","viewed":236,"name":"vr test","username":"rytone","description":"not bad","likes":2,"published":1,"flags":1,"usePreview":0,"tags":["3d","raymarching","vr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define FAR 16.0\n#define MAX_STEPS 64\n#define PI 3.14159265359\n#define DEG_TO_RAD PI / 180.0\n\nfloat hash( float n ){ return fract(cos(n)*45758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    n = max(n*n, 0.001); // n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nfloat prim_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat prim_box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map(vec3 q) {\n    // Layer one. The \".05\" on the end varies the hole size.\n \tvec3 p = abs(fract(q/3.)*3. - 1.5);\n \tfloat d = min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1. + .05;\n    \n    // Layer two.\n    p =  abs(fract(q) - .5);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./3. + .05);\n   \n    // Layer three. 3D space is divided by two, instead of three, to give some variance.\n    p =  abs(fract(q*2.)*.5 - .25);\n \td = max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - .5/3. - .015); \n\n    // Layer four. The little holes, for fine detailing.\n    p =  abs(fract(q*3./.5)*.5/3. - .5/6.);\n \treturn max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./18. - .015);\n    //return max(d, max(max(p.x, p.y), p.z) - 1./18. - .024);\n    //return max(d, length(p) - 1./18. - .048);\n    \n    //p =  abs(fract(q*3.)/3. - .5/3.);\n \t//return max(d, min(max(p.x, p.y), min(max(p.y, p.z), max(p.x, p.z))) - 1./9. - .04);\n}\n\nfloat march_map(vec3 eye, vec3 dir) {\n    float depth = 0.0;\n    vec3 pos = eye;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        float d = map(pos);\n        depth += d;\n        pos += dir * d;\n        \n        if (d < EPSILON) {\n            break;\n        }\n        \n        if (d >= FAR) {\n            return FAR;\n        }\n    }\n    \n    return depth;\n}\n\nvec3 map_nrm(vec3 p) {\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\n// Ambient occlusion, for that self shadowed look.\n// XT95 came up with this particular version. Very nice.\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO(vec3 p, vec3 n){\n    \n\tfloat ao = 0.0, l;\n\tconst float nbIte = 6.0;\n\tconst float falloff = 1.;\n    \n    const float maxDist = 1.;\n    for(float i=1.; i<nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - map( p + n*l ))/ pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n\nvec3 draw(vec3 eye, vec3 dir) {\n    vec3 sky = vec3(0.0);\n    float depth = march_map(eye, dir);\n    if (depth >= FAR) {\n        return sky;\n    } else {\n        vec3 hit_pos = eye + dir * depth;\n        vec3 nrm = map_nrm(hit_pos);\n     \tfloat d = depth / FAR;\n        \n        float ao = pow(calculateAO(hit_pos, nrm), 3.0 /* INTENSE */);\n        \n        vec3 diffuse = tex3D(iChannel0, hit_pos, nrm);\n        diffuse *= ao;\n        \n        return mix(diffuse, sky, pow(d, 2.0));\n    }\n}\n\nvec3 dir_from_fov(float fov, vec2 pos, vec2 res) {\n\tvec2 xy = pos - res * 0.5;\n\n\tfloat cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\t\n\tfloat z = res.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 look_at(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 eye = vec3(0.0, iTime * 2.0, 0.0);\n    vec3 look = vec3(sin(iTime / 3.0), sin(iTime / 2.0) * 2.0, cos(iTime / 3.0));\n    \n    look += eye;\n    vec3 dir = dir_from_fov(80.0, fragCoord, iResolution.xy);\n    mat3 view = look_at(eye, look, vec3(0, 1, 0));\n    dir = view * dir;\n    \n    fragColor = vec4(draw(eye, dir), 1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    vec3 eye = fragRayOri + vec3(0.0, iTime, 0.0);\n    fragColor = vec4(draw(eye, fragRayDir), 1.0);\n}","name":"Image","description":"","type":"image"}]}