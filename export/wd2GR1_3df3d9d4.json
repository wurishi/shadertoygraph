{"ver":"0.1","info":{"id":"wd2GR1","date":"1548205112","viewed":156,"name":"wannabe glass","username":"bitnenfer","description":"just testing some different materials","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 rp, vec3 co, float cr) {\n    return length(rp - co) - cr;\n}\n\nfloat box(vec3 rp, vec3 bo, vec3 bs) {\n    vec3 d = abs(rp - bo) - bs;\n    return length(max(d, 0.0)) + min(max(d.x,max(d.y, d.z)), 0.0);\n}\n\nvec2 opUnion(vec2 a, vec2 b) {\n    if (a.x < b.x) {\n        return a;\n    }\n    return b;\n}\n\nmat2 rotate(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); }\n\nvec2 scene(vec3 p) {\n    \n    vec3 p2 = p;\n    vec3 p3 = p;\n\n    vec3 p4 = p3;\n    p3.xz *= rotate(0.4 + p.y * (3.0 * sin(1.26)));\n    \n    float a = box(p3, vec3(0.0, 0.1, 0.0), vec3(0.1, 0.3, 0.3)) - 0.1;\n    a = min(a, sphere(p4, vec3(0.0, 0.5, 0.0), 0.25));\n    float b = sphere(p2, vec3(0., 0.0, .0), 0.3);\n    \n    vec2 va = vec2(a, 1.0);\n    vec2 vb = vec2(min(min(b, box(p2, vec3(0.5, 0.0, 1.0), vec3(0.1, 0.8, 0.1))), p.y + 0.3), 0.0);\n    \n    return opUnion(va, vb);\n}\n\nvec2 sceneOpaque(vec3 p) {\n\tvec3 p2 = p;\n    vec3 p3 = p;\n\n    vec3 p4 = p3;\n    \n    float b = sphere(p2, vec3(0., 0.0, .0), 0.3);\n\n    vec2 vb = vec2(min(min(b, box(p2, vec3(0.5, 0.0, 1.0), vec3(0.1, 0.8, 0.1))), p.y + 0.3), 0.0);\n    \n    return vb;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.0, 0.001);\n    return normalize(scene(p).x - vec3(\n        scene(p - e.yxx).x,\n        scene(p - e.xyx).x,\n        scene(p - e.xxy).x\n    ));\n}\n\nconst vec3 L = normalize(vec3(0.2, 1.0, -0.4));\n\nfloat NormalDistributionFunctionGGXTR(vec3 n, vec3 m, float a)\n{\n    float a2 = a * a;\n    float NdotM = max(0.0, dot(n, m));\n    float NdotM2 = NdotM * NdotM;\n    float denom = (NdotM * (a2 - 1.0) + 1.0);\n    denom = 3.14 * (denom * denom);\n    return a2 / denom;\n}\n\nfloat GeometryGGX(float NdotV, float a)\n{\n    float k = (a + 1.0) * (a + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat GeometrySmith(float NdotV, float NdotL, float a)\n{\n    float g1 = GeometryGGX(NdotL, a);\n    float g2 = GeometryGGX(NdotV, a);\n    return g1 * g2;\n}\n\nvec3 FresnelSchlick(vec3 v, vec3 h, vec3 F0)\n{\n    float VdotH = max(0.0, dot(v, h));\n    return F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);\n}\n\nvec3 ShadePBR(vec3 n, vec3 v, vec3 l, vec3 albedo, float roughness, float metallic, out vec3 BRDF)\n{\n    vec3 F0 = mix(vec3(0.04), albedo, metallic);\n    vec3 h = normalize(v + l);\n    roughness = roughness * roughness;\n    float NdotL = max(0.0, dot(n, l));\n    float NdotV = max(0.0, dot(n, v));\n    float D = NormalDistributionFunctionGGXTR(n, h, roughness);\n    vec3 F = FresnelSchlick(v, h, F0);\n    float G = GeometrySmith(NdotV, NdotL, roughness);\n    vec3 Kd = (1.0 - F) * (1.0 - metallic);\n    vec3 radiance = vec3(3.0);\n    vec3 num = D * F * G;\n    float denom = 4.0 * NdotL * NdotV;\n    vec3 specularBRDF = num / max(denom, .01);\n    \n    BRDF = specularBRDF;\n    \n    return (albedo * 0.08) + ((Kd * albedo / 3.14 + specularBRDF) * radiance * NdotL);\n}\n\nfloat uRefraction = 1.33;\nvec4 uGlassColor = vec4(5.0, 1.0, 1.0, 0.3); \n\nvec3 shade(vec2 S, vec3 P, vec3 N, vec3 V) {\n    float NdotL = max(0.0, dot(N, L));\n    float VdotN = max(0.0, dot(-V, N));\n    vec3 trColor = uGlassColor.rgb * uGlassColor.a;\n    vec3 fr = vec3(0.0);//(trColor + vec3(0.1)) * pow(1.0 - VdotN, 10.0);\n    float roughness = 0.5;\n    float metallic = 0.5;\n    float prevRoughness = roughness;\n    float prevMetallic = metallic;\n    vec3 albedo = vec3(0.5, 0.4, 0.9);\n    vec3 brdf = vec3(0.0);\n    if (S.y == 1.0)\n    {\n        roughness = 0.1;\n        metallic = 0.0;\n    }\n    vec3 pbr = ShadePBR(N, -V, L, albedo, roughness, metallic, brdf);\n    \n    roughness = prevRoughness;\n    metallic = prevMetallic;\n    if (S.y == 0.0) {\n        float t = 0.0;\n        vec3 rd = N;\n        vec3 ro = P + rd * 0.1;\n        float ao = 1.0;\n        for (int i = 0; i < 100; ++i) {\n            vec3 p = ro + rd * t;\n            vec2 s = scene(p);\n            if (s.x < 0.001) {\n                ao = clamp(t * 10.0, 0.0, 1.0);\n                break;\n            }\n            t += s.x;\n            if (t > 100.0) break;\n        }\n        vec3 P2 = P * 4.5;\n        float c = mod((floor(P2.x) + floor(P2.z) + floor(P2.y)), 2.0);\n        vec3 color = vec3(c) * 0.5;\n        color += pbr;\n        return mix(color, color * ao, 0.5);\n    } else {\n        pbr = fr + brdf;\n        {\n            float t = 0.0;\n            vec3 rd = normalize(refract(V, N, 1.0/uRefraction));\n            vec3 ro = P;\n            for (int i = 0; i < 200; ++i) {\n                vec3 p = ro + rd * t;\n                vec2 s = sceneOpaque(p);\n                if (s.x < 0.001 && s.y == 0.0) {\n                    vec3 ambient = vec3(0.1);\n                    vec3 diffuse = vec3(0.7);\n                    vec3 N = getNormal(p);\n                    vec3 brdf2;\n                    float RNdotL = max(0.0, dot(N, L));\n                    \n                    vec3 P2 = p * 4.5;\n        \t\t\tfloat c = mod((floor(P2.x) + floor(P2.z) + floor(P2.y)), 2.0);\n        \t\t\tvec3 color = vec3(c) * 0.05;\n                    \n                    pbr = 0.1*brdf + fr + color + ShadePBR(N, -normalize(rd), L, albedo, roughness, metallic, brdf2) * trColor;\n                    break;\n                }\n                t += s.x;\n                if (t > 100.0) break;\n            }\n        }\n        \n        {\n            float t = 0.0;\n            vec3 rd = normalize(reflect(V, N));\n            vec3 ro = P + rd;\n            for (int i = 0; i < 50; ++i) {\n                vec3 p = ro + rd * t;\n                vec2 s = scene(p);\n                if (s.x < 0.001 && s.y == 0.0) {\n                    vec3 ambient = vec3(0.1);\n                    vec3 diffuse = vec3(0.7);\n                    vec3 N = getNormal(p);\n                    vec3 brdf2;\n                    float RNdotL = max(0.0, dot(N, L));\n\t\t\t\t\t\n                    vec3 P2 = p * 4.5;\n        \t\t\tfloat c = mod((floor(P2.x) + floor(P2.z) + floor(P2.y)), 2.0);\n        \t\t\tvec3 color = vec3(c);\n                    \n                    pbr += 0.15 * (color + ShadePBR(N, -normalize(rd), L, albedo, roughness, metallic, brdf2)) * pow(1.0 - VdotN, 1.0);\n                    break;\n                }\n                t += s.x;\n                if (t > 100.0) break;\n            }\n        }\n    }\n    \n    \n    return pbr;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    float t = 0.0;\n    vec3 ro = vec3(uv.x, uv.y + 1.2, -3.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y-1.5, 5.0));\n    \n    float mx = (iMouse.x / iResolution.x * 2.0 - 1.0) * 3.14;\n    \n    ro.xz *= rotate(mx);\n    rd.xz *= rotate(mx);\n        \n    vec3 V = normalize(rd);\n    \n    for (int i = 0; i < 400; ++i)\n    {\n        vec3 p = ro + rd * t;\n        vec2 s = scene(p);\n        if (s.x < 0.001) {\n            color = shade(s, p, getNormal(p), V);\n            break;\n        }\n        t += s.x * 0.5;\n        if (t > 100.0) break;\n    }\n    \n    // tone mapping\n    color = color / (color + 1.0);\n\n    // gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}