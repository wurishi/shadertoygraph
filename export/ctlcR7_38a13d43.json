{"ver":"0.1","info":{"id":"ctlcR7","date":"1704572831","viewed":101,"name":"Shoot 'em up","username":"timestamp","description":"SHIFT to fire\nWASD or mouse to move\nGamepad  fire & move. Requires GamepadExtension!","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["game","hack","shooter","arcade","gamepad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// =============================================================================\n// Shoot 'em up\n//\n// (c) 2024, timestamp @ shadertoy.com\n// =============================================================================\n\n// Basically a playground for various tests and experiments,\n// but ended up to be fun just to play, in particular with a gamepad.\n//\n//\n//          SHIFT    fire\n//          WASD     move\n//          Mouse    move\n//          Gamepad  fire & move. Requires GamepadExtension!\n// \n//\n// Rorschach Test: Are you posting high-scores or code reviews?\n//\n// GamepadExtension: https://www.shadertoy.com/view/lcXGWN\n//\n\n\n#define iWarp ivec2(4,8) // Texels per warp (align with definition in Buffer A)\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    O *= 0.;\n    if(u.x < float(iWarp.x)) return;\n    O.xyz = texelFetch(iChannel0, ivec2(u), 0).xyz;\n    O.xyz = pow(O.xyz, vec3(.45));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// =============================================================================\n// Shoot 'em up\n//\n// (c) 2024, timestamp @ shadertoy.com\n// =============================================================================\n\n#define EnableWASD\n#define EnableMouse\n// #define GodMode\n\n// Gamepad extension, if available (#ifdef GamepadExtension)\nuniform float iGamepad_0b0m; // 0 = Pad 0, b0 = button 0, m = momentary: signal once when pressed\nuniform vec2  iGamepad_0a0;  // 0 = Pad 0, a0 = axis 0 (and 1 to fill vec2)\n\n#define fireButton (iGamepad_0b0m != 0.)\n#define stick      (iGamepad_0a0 * vec2(1,-1)) // flip y-axis\n\n#define Key_Shift         16\n#define Key_W             87\n#define Key_A             65\n#define Key_S             83\n#define Key_D             68\n#define keyClick(ascii)   (texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    (texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define NShots            4\n#define NBullets          10\n#define NUnits            14\n\n#define RPlayer           (1./17.) // player radius\n#define CRPlayer          (RPlayer*vec2(1,.6)) // collision radius\n#define RShot             (1./80.)\n#define REnemy            (1./20.)\n#define CREnemy           (REnemy*vec2(1.,1./1.3))\n#define RTurret           (1./15.)\n\n#define GradEps           vec2(.001,0)\n#define ShotVel           1.\n#define GndVel            (worldX/10.)\n\n#define Pii               6.2831853\n#define Inf               uintBitsToFloat(0x7F800000u) // 1./0.\n#define screen2World(p)   ((p - vec2(iWarp.x,0))/iResolution.y)\n\nvec4 col;           // output color\nvec2 cor;           // world coord\nfloat worldX;       // world [ (0,0) .. (worldX,1.) [\nvec4[NShots] shots; // player's shots\nvec4 player;        // player data\nfloat time;         // ignore iTime\nfloat deltaTime;    // ignore iTimeDelta\nuint pes;           // powerups | energy << 2 | score << 9\nint dix;            // data index of current texel\n\nfloat sqr(float x) { return x * x; }\nfloat dot2(vec3 a) { return dot(a, a); }\nfloat dot2(vec2 a) { return dot(a, a); }\n\nfloat rand1(inout uvec2 seed)\n{\n\tconst uvec2 p0 = uvec2(2751615673u, 3276581783u);\n\tconst uvec2 p1 = uvec2(2700620779u, 2533336579u);\n\tconst uvec2 p2 = uvec2(3505207399u, 2635594421u);\n\tseed = seed * p0 + seed.yx * p1 + p2;\n\treturn float(seed.x) / 4294967296.;\n}\n\nvec2 rot(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.y * cos(a) + p.x * sin(a));\n}\n\n// ==================================================================================================\n// State Storage\n// ==================================================================================================\n\n#define iWarp        ivec2(4,8) // Texels per warp (align with definition in Image)\n#define NextWarp(di) (((di)+iWarp.x*iWarp.y-1)/(iWarp.x+iWarp.y)*(iWarp.x+iWarp.y))\n#define DIGameState  0\n#define DIShots      NextWarp(DIGameState)\n#define DIBullets    NextWarp(DIShots+NShots)\n#define DIUnits      NextWarp(DIBullets+NBullets)\n\n#define TagOff       0.\n#define TagOn        1.\n#define TagSpawn     2.\n#define TagDie       3.\n\n// Player\n//    xy  position\n//    z   n/a\n//    w   0       TagOff (eg, score page\n//        ]0..1[  spawn sequence 1 sec\n//        1       TagOn\n//        ]1..2[  death sequence 1 sec\n//\n// Shot\n//    xy  position\n//    z   n/a\n//    w   tag     TagOn, TagOff\n//\n// Other (Enemy, turret, etc)\n//    xy  position\n//    z\n//    w   0       TagOff\n//        ]0..1[  death sequence\n//        1       TagOn\n//\n\n// powerups 2, energy 7, score 20 bits\nuvec3 decodePES() { return uvec3(pes & 3u, (pes >> 2) & 0x7fu, pes >> 9); }\nvoid encodePES(uvec3 vpes) { pes = vpes.x | (vpes.y << 2) | (vpes.z << 9); }\nvoid addScore(uint score) { pes += score << 9; }\nvoid addPowerUp(int n) { pes += uint(n); }\n\nbool putData(int idx, vec4 v)\n{\n\tbool b = idx == dix;\n\tif (b) col = v;\n\treturn b;\n}\n\nvec4 getData(int idx)\n{\t\n\tivec2 ic = ivec2(idx % iWarp.x, idx / iWarp.x);\n\treturn iFrame == 0 ? vec4(0) : texelFetch(iChannel0, ic, 0);\n}\n\nbool putShots()\n{\n\tbool b = dix >= DIShots && dix < DIShots + NShots;\n\tif(b) col = shots[dix - DIShots];\n\treturn b;\n}\n\n// ==================================================================================================\n// Draw\n// ==================================================================================================\n\nstruct M\n{\n\tfloat z;\n\tvec3 dif;\n\tvec3 emi;\n\tvec4 fog; // w = factor 0..1    \n\tvec3 n;\n\tvec2 uv;\n};\n\nfloat zEgg(vec2 p)\n{\n\tp.y *= 2. + p.x;\n\tfloat w = 1. - dot2(p);\n\treturn w < 0. ? -Inf : sqrt(w);\n}\n\nfloat zCylinder(vec2 p, float r)\n{\n\tr = r * r - p.y * p.y;\n\treturn r < 0. ? -Inf : sqrt(r);\n}\n\nfloat zSphere(vec2 p, float r)\n{\n\tr = r * r - dot2(p);\n\treturn r < 0. ? -Inf : sqrt(r);\n}\n\nvec4 zPlayer(vec2 p)\n{\n\tvec4 c0 = vec4(0.667, 0.133, 0.471, 0);\n\tvec4 c1 = vec4(0.863, 0.490, 0.118, 0);\n\tvec4 c2 = vec4(0.851, 0.149, 0.149, 0);\n\n\tfloat z0 = zEgg(p * 1.1 - vec2(.05, 0));\n\tfloat z1 = zEgg(p * 2.5 - vec2(.4, .16) * 2.5);\n\tfloat z2 = zCylinder(p + vec2(.2, 0.), .2);\n\tif (abs(p.x + .5) > .5) z2 = -Inf;\n\n\tif (z1 > z0) { c0 = c1; z0 = z1; }\n\tif (z2 > z0) { c0 = c2; z0 = z2; }\n\n\treturn vec4(c0.xyz, z0);\n}\n\nvoid drawPlayer(inout M m)\n{\n\tconst float z0 = 4. * RPlayer;\n\tfloat powerUpScale = .75;\n\tfloat powerUpY = 1. - CRPlayer.y * powerUpScale;\n\tfloat state = floor(player.w);\n\tvec2 p;\n\tif (cor.y >= powerUpY - CRPlayer.y * powerUpScale)\n\t{\n\t\tfloat dx = RPlayer * powerUpScale * 2.1;\n\t\tfloat x = cor.x - .01;\n\t\tfloat pui = floor(x / dx);\n\t\tif (pui<0. || pui > float(decodePES().x) - 1.) return;\n\t\tp = cor - vec2(.01 + (.5 + pui) * dx, powerUpY);\n\t\tp /= powerUpScale * RPlayer;\n\t}\n\telse\n\t{\n\t\tp = cor - player.xy;\n\t\tp /= RPlayer;\n\t\tif (state == TagSpawn)\n\t\t\tp.yx += (.5 - fract(player.w) * .5) * vec2(sin(cor * (time + .02) * 1212452.1231));\n\t\telse if (state == TagDie)\n\t\t\tp.yx += fract(player.w) * .5 * vec2(sin(cor * time * 1212452.1231));\n\t}\n\n\tvec4 z = zPlayer(p);\n\tif (z.w == -Inf) return;\n\tif (z.w < m.z) return;\n\tvec3 n = normalize(vec3(z.w - zPlayer(p + GradEps).w, z.w - zPlayer(p + GradEps.yx).w, GradEps.x));\n\tif (state == TagDie) z.xyz = mix(z.xyz, vec3(1, 0, 0), fract(player.w));\n\tm.z = z.w;\n\tm.n = n;\n\tm.uv = p;\n\tm.dif += z.xyz;\n}\n\nvoid drawShot(vec2 p, inout M m)\n{\n\tconst float c1 = 1. / .5 / RShot; // r=1 at .5\n\tconst float c0 = 1. / 1.5 / RShot;  // r=0 at 1.5 \n\tfloat r = inversesqrt(dot2(p - cor)) * (1. / (c1 - c0)) - c0 / (c1 - c0);\n\tm.emi += vec3(1, 1, 0) * clamp(r, 0., 1.);\n}\n\nvec4 zEnemy(vec2 p)\n{\n\tvec3 c0 = vec3(0.855, 0.063, 0.063); // body\n\tvec3 c1 = vec3(0.443, 0.294, 0.196); // engine\n\n\tp.y *= 1.3;\n\tfloat z0 = zSphere(p, 1.5);\n\tif (dot2(p) > 1.) z0 = -Inf;\n\tif (dot2(p - vec2(.5, 0)) < sqr(.6)) z0 = -Inf;\n\tfloat z = z0;\n\n\tfloat z1 = zCylinder(p, .2) + 3.;\n\tif (p.x > -1. && p.x < -.4 && z1 > z) { c0 = c1; z = z1; }\n\n\tz1 = zCylinder(vec2(p.x, abs(p.y) - .2), .12);\n\tif (p.x < .45 && p.x > -.5 && z1 > z) { c0 = c1; z = z1; }\n\treturn vec4(c0, z);\n}\n\nvoid drawEnemy(vec4 s, inout M m)\n{\n\tconst float z0 = 3. * RPlayer;\n\tvec2 p = cor - s.xy;\n\tp = rot(p, -s.z);\n\tp /= REnemy;\n\tvec4 z = zEnemy(p);\n\tif (z.w == -Inf) return;\n\tif (z.w <= m.z) return;\n\n\tvec3 n = normalize(vec3(z.w - zEnemy(p + GradEps).w, z.w - zEnemy(p + GradEps.yx).w, GradEps.x));\n\n\tm.z = z.w;\n\tm.dif = z.xyz;\n\tm.n = n;\n\tm.n.xy = rot(m.n.xy, s.z); // world coords\n\tm.uv = p;\n}\n\nvoid drawTurret(vec4 s, inout M m)\n{\n\tconst float rcyl = RTurret * .15;\n\tconst float rsph = RTurret * .7;\n\n\tif (m.z >= RPlayer || s.w == TagSpawn) return;\n\n\tvec2 p = cor.xy - s.xy;\n\tfloat z2 = zSphere(p, rsph);\n\n\tvec2 dp = normalize(player.xy - s.xy);\n\tvec2 q = vec2(p.x * dp.x + p.y * dp.y, p.y * dp.x - p.x * dp.y);\n\tfloat z1 = zCylinder(q, rcyl) + rsph * .75;\n\tif (q.x < 0. || q.x >= RTurret) z1 = -Inf;\n\n\tif (z1 <= m.z && z2 <= m.z) return;\n\n\tif (z1 > z2)\n\t{\n\t\tm.z = z1;\n\t\tm.dif += vec3(0.251, 0.255, 0.271);\n\t\tm.n = normalize(vec3(0, q.y, sqrt(max(0., sqr(rcyl) - sqr(q.y)))));\n\t\tm.n.xy = vec2(m.n.x * dp.x - m.n.y * dp.y, m.n.y * dp.x + m.n.x * dp.y);\n\t}\n\telse\n\t{\n\t\tm.z = z2;\n\t\tm.dif += vec3(0.106, 0.184, 0.412);\n\t\tm.n = normalize(vec3(p.x, p.y, sqrt(max(0., sqr(rsph) - dot2(p.xy)))));\n\t}\n}\n\nvoid drawExplosion(vec4 s, inout M m)\n{\n\tfloat r0 = fract(s.w);\n\tfloat lum = 1. - r0;\n\tr0 *= .3;\n\tfloat r = length(cor - s.xy);\n\tfloat dr = abs(r - r0);\n\tfloat a = 1. - dr / .1;\n\tif (dr > .1) return;\n\tvec4 fog = vec4(1, 1, 0, .5 * sqr(a) * lum);\n\tm.fog.xyz = m.fog.xyz * m.fog.w + fog.xyz;\n\tm.fog.w = 1. - (1. - m.fog.w) * (1. - fog.w);\n}\n\nbool drawScore()\n{\n\tfloat rDot = ceil(.01 * iResolution.y) / iResolution.y;\n\tfloat rDigit = 3. * rDot;\n\tfloat rxDigit = ceil(rDigit * 1.3 * iResolution.y) / iResolution.y;\n\tvec2 p = vec2(worldX - .02, .98) - cor;\n\tif (p.x < 0. || p.y < 0. || p.y >= 5. * rDot) return false;\n\tif (p.x >= 5. * rxDigit + rDigit) return false;   // max score 999999\n\tfloat iDigit = floor(p.x / rxDigit);\n\tp.x -= iDigit * rxDigit;\n\tif (p.x >= rDigit) return false; // digit spacing\n\tfloat iDotX = floor(p.x / rDot);\n\tfloat iDotY = floor(p.y / rDot);\n\n\tuint div = 1u;\n\tif (iDigit == 1.) div = 10u;\n\telse if (iDigit == 2.) div = 100u;\n\telse if (iDigit == 3.) div = 1000u;\n\telse if (iDigit == 4.) div = 10000u;\n\telse if (iDigit == 5.) div = 100000u;\n\tuint digit = decodePES().z / div;\n\tif (digit == 0u && iDigit > 0.) return false;\n\tdigit = digit % 10u;\n\tuint pat;\n\tif (iDotY == 0.) pat = 3959160828u;\n\telse if (iDotY == 1.) pat = 2856996020u;\n\telse if (iDotY == 2.) pat = 2885679868u;\n\telse if (iDotY == 3.) pat = 2831755952u;\n\telse pat = 3959028476u;\n\tpat <<= uint(iDotX) + digit * 3u;\n\tif (pat < 0x80000000u) return false;\n\tcol.xyz = vec3(.9);\n\treturn true;\n}\n\nbool drawEnergy()\n{\n\tfloat e = float(decodePES().y) / 100.;\n\tvec4 rect = vec4(4. * 2. * RPlayer, 1. - 1.5 * .02, .5, .02);\n\tif (cor.y >= rect.y\n\t\t&& cor.y < rect.y + rect.w\n\t\t&& cor.x >= rect.x\n\t\t&& cor.x < rect.x + rect.z * e)\n\t{\n\t\tcol.xyz = vec3(0, 0, .8);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfloat backgroundHeight(float x)\n{\n\tx += time * GndVel;\n\treturn sin(x * 4.) * .2 + sin(x * 7.3315 + .15) * .08 + (.28);\n}\n\nvoid drawBackground(inout M m)\n{\n\tconst float z0 = 0.;\n\tif (m.z >= z0) return;\n\tm.n = normalize(vec3(0, 1, 1));\n\tm.z = z0;\n\tfloat h = backgroundHeight(cor.x);\n\tif (cor.y < h)\n\t{\n\t\tm.dif += vec3(0.1, 1.0, 0.1) * .1;\n\t\treturn;\n\t}\n\tfloat x = cor.x + time * GndVel * .6;\n\th = sin(x * 3.315) * .17 + sin(x * 9.74355 + .225) * .036 + (.17 + .036);\n\tif (cor.y < h)\n\t{\n\t\tm.dif += vec3(0.2, 1.0, 0.2) * 0.05;\n\t\treturn;\n\t}\n\n\tfloat t = time * (Pii / 60.);\n\tfloat ct = cos(t);\n\tm.emi += mix(vec3(0.004), vec3(0.184, 0.337, 0.957) * .4, smoothstep(-.7, .3, ct));\n}\n\nvec3 applyLights(M m)\n{\n\tfloat t = time * (Pii / 60.);\n\tfloat ct = cos(t);\n\tvec3 ld = normalize(vec3(-sin(t), max(0., ct) * .7, .5));\n\tvec3 f = mix(vec3(.2, 0, 0),\n\t\tvec3(max(0., dot(m.n, ld))),\n\t\tsmoothstep(-.7, .3, ct));\n\treturn mix(m.emi + m.dif * f, m.fog.xyz, m.fog.w);\n}\n\n// ==================================================================================================\n// Step\n// ==================================================================================================\n\nbool collides(vec2 p, vec2 r0, vec2 r1)\n{\n\tr0 += r1;\n\tp = abs(p);\n\treturn p.x < r0.x && p.y < r0.y;\n}\n\nvoid stepShots()\n{\n\tfor (int i = 0; i < NShots; i++)\n\t{\n\t\tvec4 s = shots[i];\n\t\tif (s.w == TagOff) continue;\n\t\ts.x += ShotVel * deltaTime;\n\t\tif (s.x >= worldX + RShot) s.w = TagOff;\n\t\tshots[i] = s;\n\t}\n\n\tif (player.w > 0. && player.w <= 1.) // shoot only during spawn or alive\n\t{\n\t\tbool fire = keyClick(Key_Shift);\n#ifdef GamepadExtension\n\t\tfire = fire || fireButton;\n#endif\n\t\tif (fire)\n\t\t{\n\t\t\tfor (int i = 0; i < NShots; i++)\n\t\t\t{\n\t\t\t\tif (shots[i].w != TagOff) continue;\n\t\t\t\tshots[i] = vec4(player.xy + vec2(RPlayer, 0), 0, TagOn);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvec2 evalPath(float id, float t)\n{\n\tuvec2 seed = uvec2(id, id * 315.22);\n\tfloat ry = 1.;\n\tvec2 p0 = vec2(worldX + REnemy * 4., rand1(seed));\n\tvec2 p1 = vec2(.3, rand1(seed) * 1.2 - .1) * vec2(worldX, 1.);\n\tvec2 p2 = vec2(-REnemy * 4., rand1(seed));\n\n\tp2 = vec2(-REnemy * 4., fract(p1.y + .5));\n\n\tvec2 w0 = vec2(max(-.2, p1.x - .5), fract(p1.y + .25 + .5 * rand1(seed)));\n\tvec2 w1 = vec2(min(1.2, p1.x + .5), fract(p1.y + .5));\n\n\tfloat A = rand1(seed) * -.3 - .2;\n\tt = smoothstep(0., 1., t);\n\n\tvec2 q0, q1, q2, q3;\n\tt *= 2.;\n\tif (t <= 1.)\n\t{\n\t\tq0 = p0;\n\t\tq1 = w0;\n\t\tq2 = p1 + (p0 - p2) * A;\n\t\tq3 = p1;\n\t}\n\telse\n\t{\n\t\tt -= 1.;\n\t\tq0 = p1;\n\t\tq1 = p1 - (p0 - p2) * A;\n\t\tq2 = w1;\n\t\tq3 = p2;\n\t}\n\n\tq0 = mix(q0, q1, t);\n\tq1 = mix(q1, q2, t);\n\tq2 = mix(q2, q3, t);\n\tq0 = mix(q0, q1, t);\n\tq1 = mix(q1, q2, t);\n\tq0 = mix(q0, q1, t);\n\treturn q0;\n}\n\nvoid handleSpriteCollision(inout vec4 s)\n{\n\tfor (int j = 0; j < NShots; j++)\n\t{\n\t\tif (shots[j].w == TagOff) continue;\n\t\tif (collides(shots[j].xy - s.xy, vec2(RShot), CREnemy))\n\t\t{\n\t\t\ts.w = TagDie;\n\t\t\tshots[j].w = TagOff;\n\t\t\taddScore(50u);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (player.w == TagOn\n\t\t&& collides(player.xy - s.xy, CRPlayer, CREnemy))\n\t{\n#ifndef GodMode\n\t\tplayer.w = TagDie;\n#endif    \n\t\ts.w = TagDie;\n\t}\n}\n\nfloat aniLinear(float x, float x0)\n{\n\treturn max(0., x - x0);\n}\n\nfloat aniLinearU(float x, float x0, float x1)\n{\n\tx1 -= x0;\n\treturn clamp(x - x0, 0., x1) / x1;\n}\n\nfloat getPathsTime(float t, int i)\n{\n\tt = t - float(i) * .4;\n\tif (i >= 5) t -= 2.;\n\treturn \n\t\tclamp(t, -.001, 0.)\n\t\t+ aniLinearU(t, 0., 14.)\n\t\t+ aniLinearU(t, 14., 24.)\n\t\t+ aniLinear(t, 24.) / 14.;\n}\n\nbool stepEnemy(int i, inout vec4 s, inout int diSaveBullet)\n{\n\tfloat tpaths = getPathsTime(time - 2., i);\n\tfloat tpathsOld = getPathsTime(time - deltaTime - 2., i);\n\n\tfloat pathIdx = floor(tpaths);\n\tfloat t = tpaths - pathIdx;\n\tif (i >= 5) pathIdx += 7.321;\n\n\tvec2 p = evalPath(pathIdx, t);\n\tvec2 dp = evalPath(pathIdx, t + .005) - p;\n\tbool spawn = floor(tpaths) != floor(tpathsOld);\n\n\tif (spawn) {\n\t\ts.xy = p;\n\t\ts.z = 0.; // not used .. atan(dp.y,dp.x);\n\t\ts.w = TagOn;\n\t}\n\telse if (floor(s.w) == TagDie)\n\t{\n\t\ts.w += deltaTime;\n\t\tif (s.w >= TagDie + 1.) s.w = TagOff;\n\t}\n\telse if (s.w != TagOff)\n\t{\n\t\ts.xy = p;\n\t\ts.z = atan(dp.y, dp.x);\n\t\thandleSpriteCollision(s);\n\t\tfloat tshot = .2 + sqr(float(i - (i > 4 ? 4 : 0))) * (.6 / 5. / 5.);\n\t\tif (floor(tpaths - tshot) != floor(tpathsOld - tshot)\n\t\t\t&& diSaveBullet < DIBullets + NBullets\n\t\t\t&& dix == diSaveBullet++)\n\t\t{\n\t\t\tcol.xy = s.xy;\n\t\t\tvec2 ds = player.xy - col.xy;\n\t\t\tcol.z = atan(ds.y, ds.x);\n\t\t\tcol.w = TagOn;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool stepTurret(int i, inout vec4 s, inout int diSaveBullet)\n{\n\tvec2 p = vec2(1.5 * worldX - time * GndVel, .9);\n\tif ((i & 2) != 0) p.x += .9;\n\tif ((i & 1) != 0) p.x += .3;\n\n\tif (time >= .4 / GndVel * worldX) p.x = mod(p.x, 1.8 * worldX) - RTurret;\n\tp.y = backgroundHeight(p.x);\n\ts.xy = p;\n\tfloat state = floor(s.w);\n\tif (p.x <= -RTurret)\n\t{\n\t\ts.w = TagOff;\n\t}\n\telse if (p.x >= worldX + RTurret)\n\t{\n\t\ts.w = TagSpawn;\n\t\ts.z = 0.;\n\t}\n\telse if (state == TagDie)\n\t{\n\t\ts.w += deltaTime;\n\t\tif (floor(s.w) != TagDie) s.w = TagOff;\n\t}\n\telse if (s.w == TagSpawn)\n\t{\n\t\ts.w = TagOn;\n\t}\n\telse if(state != TagOff)\n\t{\n\t\tfor (int j = 0; j < NShots; j++)\n\t\t{\n\t\t\tif (shots[j].w == TagOff) continue;\n\t\t\tif (collides(shots[j].xy - s.xy, vec2(RShot), vec2(RTurret)))\n\t\t\t{\n\t\t\t\ts.w = TagDie;\n\t\t\t\tshots[j].w = TagOff;\n\t\t\t\taddScore(50u);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (dot2(player.xy - s.xy) < sqr(max(0., .6 - s.z))\n\t\t\t&& diSaveBullet < DIBullets + NBullets)\n\t\t{\n\t\t\ts.z += 0.1;\n\t\t\tif (dix == diSaveBullet++)\n\t\t\t{\n\t\t\t\tvec2 ds = player.xy - s.xy;\n\t\t\t\tcol.xy = s.xy + RTurret * normalize(ds);\n\t\t\t\tcol.z = atan(ds.y, ds.x);\n\t\t\t\tcol.w = TagOn;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool stepUnits(inout int diSaveBullet)\n{\n\tfor (int i = 0; i < NUnits; i++)\n\t{\n\t\tvec4 s = getData(DIUnits + i);\n\t\tint type = i < 10 ? 1 : 2; //todo - various sprite types\n\t\tif (type == 1) { if (stepEnemy(i, s, diSaveBullet)) return true; }\n\t\telse if (type == 2) { if (stepTurret(i, s, diSaveBullet)) return true; }\n\n\t\tif (dix == DIUnits + i) { col = s; return true; }\n\t}\n\treturn false;\n}\n\nbool stepLiveBullets(out int diSaveBullet)\n{\n\tdiSaveBullet = DIBullets;\n\tfor (int i = 0; i < NBullets; i++)\n\t{\n\t\tvec4 s = getData(DIBullets + i);\n\t\tif (s.w != TagOn) break;\n\t\ts.xy += vec2(cos(s.z), sin(s.z)) * .5 * ShotVel * deltaTime;\n\t\tif (player.w == TagOn && collides(s.xy - player.xy, vec2(RShot), CRPlayer)) {\n#ifndef GodMode\n\t\t\tplayer.w = TagDie;\n#endif    \n\t\t}\n\n\t\tif (s.x > worldX || s.x < 0. || s.y > 1. || s.y < 0.)\n\t\t{\n\t\t\ts.w = TagOff;\n\t\t}\n\t\telse if (dix == diSaveBullet++)\n\t\t{\n\t\t\tcol = s;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool stepDeadBullets(int diSaveBullet)\n{\n\tif (dix < diSaveBullet || dix >= DIBullets + NBullets) return false;\n\tcol = vec4(0, 0, 0, TagOff);\n\treturn true;\n}\n\nvoid stepPlayer()\n{\n\tfloat state = floor(player.w);\n\n\tif (state == TagOff)\n\t{\n\t\tplayer.w = TagSpawn;\n\t}\n\telse if (state == TagDie)\n\t{\n\t\tplayer.w += deltaTime * .5;\n\t\tif (floor(player.w) != TagDie)\n\t\t{\n\t\t\tplayer.w = TagSpawn;\n\t\t\tif (decodePES().x == 0u) // game over\n\t\t\t{\n\t\t\t\tencodePES(uvec3(3u, 100u, 0u));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\taddPowerUp(-1);\n\t\t\t}\n\t\t}\n\t}\n\telse // TagSpawn, TagOn\n\t{\n\t\tfloat maxd = .45 * deltaTime;\n\n#ifdef EnableWASD\n\t\tif (keyDown(Key_W)) player.y += maxd;\n\t\tif (keyDown(Key_A)) player.x -= maxd;\n\t\tif (keyDown(Key_S)) player.y -= maxd;\n\t\tif (keyDown(Key_D)) player.x += maxd;\n#endif     \n#ifdef GamepadExtension        \n\t\tplayer.xy += maxd * stick;\n#endif\n#ifdef EnableMouse\n\t\tif (iMouse.z > 0.)\n\t\t{\n\t\t\tfloat maxd = worldX / 4. * deltaTime;\n\t\t\tvec2 dp = screen2World(iMouse.xy) - player.xy;\n\t\t\tplayer.xy += min(1., maxd * inversesqrt(dot2(dp))) * dp;\n\t\t}\n#endif        \n\t\tif (state == TagSpawn)\n\t\t{\n\t\t\tplayer.w += deltaTime * .5;\n\t\t\tif (floor(player.w) != TagSpawn) player.w = TagOn;\n\t\t}\n\t}\n\n\tplayer.xy = clamp(player.xy, CRPlayer, vec2(worldX - RPlayer, 1. - RPlayer * 2.));\n}\n\nvoid mainImage()\n{\n\tdeltaTime = clamp(iTimeDelta, 0., 1. / 25.);\n\n\tif (iFrame == 0)\n\t{\n\t\tplayer = vec4(.25 * worldX, .5, 0, TagSpawn);\n\t\ttime = 0.;\n\t\tencodePES(uvec3(3u, 100u, 0u));\n\t\tfor (int i = 0; i < NShots; i++) shots[i] = vec4(0, 0, 0, TagOff);\n\t}\n\telse\n\t{\n\t\tplayer = getData(DIGameState);\n\t\tvec4 v = getData(DIGameState + 1);\n\t\ttime = v.x;\n\t\tpes = floatBitsToUint(v.y) & 0x3fffffffu;\n\t\tfor (int i = 0; i < NShots; i++)\n\t\t\tshots[i] = getData(DIShots + i);\n\t}\n\n\tif (cor.x >= 0.)\n\t{\n\t\tif (drawScore()) return;\n\t\t// if(drawEnergy()) return;\n\t\tM m;\n\t\tm.z = -1e10;\n\t\tdrawPlayer(m);\n\n\t\tfor (int i = 0; i < NShots; i++)\n\t\t{\n\t\t\tvec4 s = shots[i];\n\t\t\tif (s.w != TagOff) drawShot(s.xy, m);\n\t\t}\n\n\t\tfor (int i = 0; i < NBullets; i++)\n\t\t{\n\t\t\tvec4 s = getData(DIBullets + i);\n\t\t\tif (s.w == TagOff) break;\n\t\t\tdrawShot(s.xy, m);\n\t\t}\n\n\t\tfor (int i = 0; i < NUnits; i++)\n\t\t{\n\t\t\tint type = i < 10 ? 1 : 2; //todo\n\t\t\tvec4 s = getData(DIUnits + i);\n\t\t\tif (s.w == TagOff) continue;\n\t\t\tif (floor(s.w) == TagDie)\n\t\t\t\tdrawExplosion(s, m);\n\t\t\telse if (type == 1)\n\t\t\t\tdrawEnemy(s, m);\n\t\t\telse\n\t\t\t\tdrawTurret(s, m);\n\t\t}\n\n\t\tdrawBackground(m);\n\t\tcol.xyz = applyLights(m);\n\t\treturn;\n\t}\n\n\tstepShots();\n\tint diSaveBullet;\n\tif (stepLiveBullets(diSaveBullet)) return;\n\tif (stepUnits(diSaveBullet)) return;\n\tif (stepDeadBullets(diSaveBullet)) return;\n\tif (putShots()) return;\n\tstepPlayer();\n\n\tif (dix == DIGameState)\n\t\tcol = player;\n\telse if (dix == DIGameState + 1)\n\t{\n\t\tuint u = pes;\n\t\tif (u < (1u << 23)) u |= (1u << 30);\n\t\tcol = vec4(time + deltaTime, uintBitsToFloat(u), 0, 0);\n\t}\n\telse\n\t\tdiscard;\n}\n\nvoid mainImage(out vec4 _col, vec2 coord)\n{\n\tcor = screen2World(coord);\n\tdix = int(coord.x) + int(coord.y) * iWarp.x;\n\tworldX = screen2World(iResolution.xy).x;\n\tmainImage();\n\t_col = col;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}