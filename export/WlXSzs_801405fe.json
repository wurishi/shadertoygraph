{"ver":"0.1","info":{"id":"WlXSzs","date":"1563882391","viewed":367,"name":"Galaxy of Trigonometry","username":"musinghead","description":"Galaxy is a mix of chaos and harmony: unpredictable things happen at each moment while a few graceful math rules are revealed. By combining trigonometry and straight-line motions in a designed way, this project offers a glimpse of the beauty of Galaxy","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["raytracing","galaxy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4lsGzf","filepath":"https://soundcloud.com/ziad-a-mahmoud/interstellar-main-theme-extra-extended-soundtrack-by-hans-zimmer","previewfilepath":"https://soundcloud.com/ziad-a-mahmoud/interstellar-main-theme-extra-extended-soundtrack-by-hans-zimmer","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//============================================================================\n// PROJECT ID: 17\n//\n// GROUP NUMBER: 1\n//\n// STUDENT NAME: Bi Hanqi\n// NUS User ID.: t0918612\n//\n// STUDENT NAME: Hu Qihai\n// NUS User ID.: t0918554\n//\n// STUDENT NAME: Kuang Zhiyi\n// NUS User ID.: t0918062\n//\n// COMMENTS TO GRADER: \n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at http://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\nconst int NUM_LIGHTS = 1;\nconst int NUM_MATERIALS = 11;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 13;\nconst int NUM_BOXES = 7;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\nconst float PI = 3.1415926535;\n // Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * 3.1415926535 / 180.0; \n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// center of global scene\nconst vec3 global_center = vec3(0.0, 0.0, 10.0);\n// sphere\nconst float sphere_radius_1 = 0.5;\nconst float sphere_radius_2 = 0.3;\n// scene 1, size of box track\nconst float track_L = 8.0;\nconst float track_H = 4.0;\nconst float track_W = 0.4;\nconst float movement = track_H + 2.0 * sphere_radius_1;\n// scene 1, size of flag pole\nconst float pole_L = 0.8;\nconst float pole_H = 2.0 * movement;\nconst float pole_W = 0.8;\n// session 1\nconst float duration_1 = 64.0;\n// motion cycle period of balls\nconst float duration_sphere = 4.0;\n// camera distance\nconst float camera_distance = 32.0;\n// focus circle\nconst float focus_radius = track_L * track_L;\n// dark parameter\nconst vec3 focus_darker = vec3(0.1, 0.1, 0.1);\n// scene 2, moon tree\nconst float tree_distance = 0.4;\nconst float tree_W = 0.5;\nconst float tree_H = 12.0;\nconst float tree_diff = 2.0;\nconst vec3  tree_ball_center = global_center + vec3(0.0, tree_H * 2.0 / 3.0, 0.0);\n// scene 2, rotate cycle and radius of balls\nconst int NUM_TREE_BALL = 5;\nconst float ball_period = 4.0;\nconst float ball_distance = 3.0;\nconst float ball_radius_1 = 1.5;\nconst float ball_radius_2 = 1.0;\nconst float ball_radius_3 = 0.5;\n// scene 2, spherical coordinates of balls\nconst float ball_theta[NUM_TREE_BALL] = float[NUM_TREE_BALL](PI / 6.0, PI / 4.0, PI / 2.0, PI * 3.0 / 4.0, PI * 5.0 / 6.0);\nconst float ball_phi[NUM_TREE_BALL] = float[NUM_TREE_BALL](PI / 6.0, PI / 3.0, PI / 2.0, PI * 2.0 / 3.0, PI * 5.0 / 6.0);\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n    bool visible;\n};\n\nstruct Box_t {\n    vec3 corner1;\n    vec3 corner2;\n    float angle; // only rotate around y axis\n    bool visible;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0. \n};\n\n// camera parameter definition\nvec3 cam_pos;\nvec3 cam_lookat;\nvec3 cam_up_vec;\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of \n// Lecture 11 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS { \n//                   I_a * k_a + \n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nBox_t Box[NUM_BOXES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n// scene 1, y-coordinate moving function of spheres\n// during (20, 64]\nfloat y_sphere_common(in float offset) {\n    if (offset > 20.0 && offset <= 22.0)\n        return sin((offset - 20.0) / 2.0 * PI / 2.0) * movement + movement;\n    else if (offset > 22.0 && offset <= 30.0)\n        return movement * 2.0;\n    else if (offset > 30.0 && offset <= 64.0)\n        return sin((offset - 30.0) / 2.0 * PI / 2.0 + PI / 2.0) * 2.0 * movement;\n}\n\n// scene 1, y-coordinate moving function of sphere 0\nfloat y_sphere_0(in float offset) {\n    if (offset >= 0.0 && offset <= 2.0) \n        return sin(offset / 2.0 * PI / 2.0) * movement;\n    else if (offset > 2.0 && offset <= 20.0)\n        return movement;\n    else \n        return y_sphere_common(offset); \n    \n}\n\n// scene 1, y-coordinate moving function of sphere 1\nfloat y_sphere_1(in float offset) {\n    if (offset >= 0.0 && offset <= 4.0) \n        return 0.0;\n    else if (offset > 4.0 && offset <= 6.0)\n        return sin((offset - 4.0) / 2.0 * PI / 2.0) * movement;\n    else if (offset > 6.0 && offset <= 20.0)\n        return movement;\n    else\n        return y_sphere_common(offset);\n}\n\n// scene 1, y-coordinate moving function of sphere 2\nfloat y_sphere_2(in float offset) {\n    if (offset >= 0.0 && offset <= 8.0) \n        return 0.0;\n    else if (offset > 8.0 && offset <= 10.0)\n        return sin((offset - 8.0) / 2.0 * PI / 2.0) * movement;\n    else if (offset > 10.0 && offset <= 20.0)\n        return movement;\n    else \n        return y_sphere_common(offset);\n}\n\n// scene 1, y-coordinate moving function of sphere 3\nfloat y_sphere_3(in float offset) {\n    if (offset >= 0.0 && offset <= 12.0) \n        return 0.0;\n    else if (offset > 12.0 && offset <= 14.0)\n        return sin((offset - 12.0) / 2.0 * PI / 2.0) * movement;\n    else if (offset > 14.0 && offset <= 20.0)\n        return movement;\n    else \n        return y_sphere_common(offset);\n}\n\n// scene 1, y-coordinate moving function of tracks (boxes)\n// during (16, 64]\nfloat y_track_common(in float offset) {\n    if (offset > 16.0 && offset <= 18.0)\n        return sin((offset - 16.0) / 2.0 * PI / 2.0 + PI / 2.0) * movement;\n    else if (offset > 18.0 && offset <= 64.0)\n        return 0.0;\n}\n\n// scene 1, y-coordinate moving function of track 0\nfloat y_track_0(in float offset) {\n    if (offset >= 0.0 && offset <= 2.0) \n        return sin(offset / 2.0 * PI / 2.0) * movement;\n    else if (offset > 2.0 && offset <= 16.0)\n        return movement;\n    else \n        return y_track_common(offset);\n    \n}\n\n// scene 1, y-coordinate moving function of track 1\nfloat y_track_1(in float offset) {\n    if (offset >= 0.0 && offset <= 4.0)\n        return 0.0;\n    else if (offset > 4.0 && offset <= 6.0) \n        return sin((offset - 4.0) / 2.0 * PI / 2.0) * movement;\n    else if (offset > 6.0 && offset <= 16.0)\n        return movement;\n    else \n        return y_track_common(offset);\n}\n\n// scene 1, y-coordinate moving function of track 2\nfloat y_track_2(in float offset) {\n    if (offset >= 0.0 && offset <= 8.0)\n        return 0.0;\n    else if (offset > 8.0 && offset <= 10.0) \n        return sin((offset - 8.0) / 2.0 * PI / 2.0) * movement;\n    else if (offset > 10.0 && offset <= 16.0)\n        return movement;\n    else \n        return y_track_common(offset);\n}\n\n// scene 1, y-coordinate moving function of track 3\nfloat y_track_3(in float offset) {\n    if (offset >= 0.0 && offset <= 12.0)\n        return 0.0;\n    else if (offset > 12.0 && offset <= 14.0) \n        return sin((offset - 12.0) / 2.0 * PI / 2.0) * movement;\n    else if (offset > 14.0 && offset <= 16.0)\n        return movement;\n    else \n        return y_track_common(offset);\n}\n\n// scene 1, y-coordinate moving function of flag pole\nfloat y_pole(in float offset) {\n    if (offset >= 0.0 && offset <= 20.0)\n        return 0.0;\n    else if (offset > 20.0 && offset <= 22.0)\n        return sin((offset - 20.0) / 2.0 * PI / 2.0) * pole_H;\n    else if (offset > 22.0 && offset <= 30.0)\n        return pole_H;\n    else if (offset > 30.0 && offset <= 64.0)\n        return sin((offset - 30.0) / 2.0 * PI / 2.0 + PI / 2.0) * pole_H;\n}\n\n// scene 2, y-coordinate moving function of tree trunk\nfloat y_tree(in float offset) {\n    if (offset >= 0.0 && offset <= 32.0)\n        return 0.0;\n    else if (offset > 32.0 && offset <= 40.0)\n        return sin((offset - 32.0) / 8.0 * PI / 2.0) * tree_H;\n    else if (offset > 40.0 && offset <= 56.0)\n        return tree_H;\n    else if (offset > 56.0 && offset <= 64.0)\n        return sin((offset - 56.0) / 8.0 * PI / 2.0 + PI / 2.0) * tree_H;\n}\n\n// changing function of spherical coordinate of the camera\n// theta\nfloat getTheta(in float offset) {\n    if (offset >= 0.0 && offset <= 16.0)\n        return 150.0 - 60.0 * offset / 16.0;\n    else if (offset > 16.0 && offset <= 26.0)\n        return 90.0;\n    else if (offset > 26.0 && offset <= 32.0)\n        return 90.0 + 60.0 * (offset - 26.0) / 6.0;\n    else if (offset > 32.0 && offset <= 48.0)\n        return 150.0 - 120.0 * (offset - 32.0) / 16.0;\n    else if (offset > 48.0 && offset <= 64.0)\n        return 30.0 + 120.0 * (offset - 48.0) / 16.0;;\n}\n\n// changing function of spherical coordinate of the camera\n// phi\nfloat getPhi(in float offset) {\n    if (offset >= 0.0 && offset <= 16.0)\n        return 45.0;\n    else if (offset > 16.0 && offset <= 18.0)\n        return 45.0 - 15.0 * (offset - 16.0) / 2.0;\n    else if (offset > 18.0 && offset <= 24.0)\n        return 30.0;\n    else if (offset > 24.0 && offset <= 26.0)\n        return 30.0 + 15.0 * (offset - 24.0) / 2.0;\n    else if (offset > 26.0 && offset <= 64.0)\n        return 45.0;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // 64 seconds per cycle\n    // offset range [0, 64)\n    float time_offset = mod(iTime, duration_1);\n    float time_rate = time_offset / duration_1;\n\n    // camera position\n    float theta = getTheta(time_offset) / 180.0 * PI;\n    float phi = getPhi(time_offset) / 180.0 * PI;\n\n    // Position the camera.\n    cam_pos = global_center + vec3(\n        camera_distance * sin(phi) * cos(theta),\n        camera_distance * cos(phi),\n        camera_distance * sin(phi) * sin(theta)\n    );\n    cam_lookat = global_center;\n    cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 2.0;\n    Plane[1].materialID = 6;\n\n    // rotate position\n    float sphere_offset = mod(time_offset, duration_sphere);\n    float sphere_rate = sphere_offset / duration_sphere;\n\n    // first session, 32 seconds\n    if (time_offset >= 0.0 && time_offset <= 32.0) {\n        // four main balls\n        // sphere 0, move along z axis\n        Sphere[0].center = vec3( \n        global_center.x, \n        y_sphere_0(time_offset) - sphere_radius_1, \n        global_center.z + track_L / 2.0 * sin(sphere_rate * 2.0 * PI) );\n        Sphere[0].radius = sphere_radius_1;\n        // visible only in first session\n        Sphere[0].visible = (time_offset >= 0.0 && time_offset <= 32.0);\n        Sphere[0].materialID = 9;\n\n        // sphere 1, move along x axis\n        Sphere[1].center = vec3( \n            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 90.0 / 180.0 * PI), \n            y_sphere_1(time_offset) - sphere_radius_1, \n            global_center.z );\n        Sphere[1].radius = sphere_radius_1;\n        Sphere[1].visible = (time_offset >= 4.0 && time_offset <= 32.0);\n        Sphere[1].materialID = 10;\n\n        // sphere 2, move along [z - x = 0] line\n        Sphere[2].center = vec3( \n            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 45.0 / 180.0 * PI) / sqrt(2.0), \n            y_sphere_2(time_offset) - sphere_radius_1,  \n            global_center.z + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 45.0 / 180.0 * PI) / sqrt(2.0));\n        Sphere[2].radius = sphere_radius_1;\n        Sphere[2].visible = (time_offset >= 8.0 && time_offset <= 32.0);\n        Sphere[2].materialID = 10;\n\n        // sphere 3, move along [z + x = 0] line \n        Sphere[3].center = vec3( \n            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 135.0 / 180.0 * PI) / sqrt(2.0), \n            y_sphere_3(time_offset) - sphere_radius_1,  \n            global_center.z - track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 135.0 / 180.0 * PI) / sqrt(2.0));\n        Sphere[3].radius = sphere_radius_1;\n        Sphere[3].visible = (time_offset >= 12.0 && time_offset <= 32.0);\n        Sphere[3].materialID = 10;\n\n        // four assistant balls\n        // sphere 4, the same motion as sphere 0, located below sphere 0\n        Sphere[4].center = vec3( \n            global_center.x, \n            y_pole(time_offset) - pole_H / 5.0 - sphere_radius_2, \n            global_center.z + track_L / 2.0 * sin(sphere_rate * 2.0 * PI) );\n        Sphere[4].radius = sphere_radius_2;\n        Sphere[4].visible = (time_offset >= 20.0 && time_offset <= 32.0);\n        Sphere[4].materialID = 10;\n\n        // sphere 5, the same motion as sphere 1, located below sphere 1\n        Sphere[5].center = vec3( \n            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 90.0 / 180.0 * PI), \n            y_pole(time_offset) - pole_H / 5.0 - sphere_radius_2, \n            global_center.z );\n        Sphere[5].radius = sphere_radius_2;\n        Sphere[5].visible = (time_offset >= 20.0 && time_offset <= 32.0);\n        Sphere[5].materialID = 9;\n\n        // sphere 6, the same motion as sphere 2, located below sphere 2\n        Sphere[6].center = vec3( \n            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 45.0 / 180.0 * PI) / sqrt(2.0), \n            y_pole(time_offset) - pole_H / 5.0 - sphere_radius_2,  \n            global_center.z + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 45.0 / 180.0 * PI) / sqrt(2.0));\n        Sphere[6].radius = sphere_radius_2;\n        Sphere[6].visible = (time_offset >= 20.0 && time_offset <= 32.0);\n        Sphere[6].materialID = 9;\n\n        // sphere 7, the same motion as sphere 3, located below sphere 3\n        Sphere[7].center = vec3( \n            global_center.x + track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 135.0 / 180.0 * PI) / sqrt(2.0), \n            y_pole(time_offset) - pole_H / 5.0 - sphere_radius_2,  \n            global_center.z - track_L / 2.0 * sin(sphere_rate * 2.0 * PI + 135.0 / 180.0 * PI) / sqrt(2.0));\n        Sphere[7].radius = sphere_radius_2;\n        Sphere[7].visible = (time_offset >= 20.0 && time_offset <= 32.0);\n        Sphere[7].materialID = 9;\n\n        // track 0, along z axis\n        Box[0].corner1 = vec3(\n            global_center.x - track_W / 2.0, \n            y_track_0(time_offset) - track_H - 2.0 * sphere_radius_1, \n            global_center.z - track_L / 2.0);\n        Box[0].corner2 = vec3(\n            global_center.x + track_W / 2.0, \n            y_track_0(time_offset) - 2.0 * sphere_radius_1, \n            global_center.z + track_L / 2.0);\n        Box[0].angle = 0.0;\n        Box[0].visible = (time_offset >= 0.0 && time_offset <= 18.0);\n        Box[0].materialID = 5;\n\n        // track 1, along x axis\n        Box[1].corner1 = vec3(\n            global_center.x - track_L / 2.0, \n            y_track_1(time_offset) - track_H - 2.0 * sphere_radius_1, \n            global_center.z - track_W / 2.0);\n        Box[1].corner2 = vec3(\n            global_center.x + track_L / 2.0, \n            y_track_1(time_offset) - 2.0 * sphere_radius_1, \n            global_center.z + track_W / 2.0);\n        Box[1].angle = 0.0;\n        Box[1].visible = (time_offset >= 4.0 && time_offset <= 18.0);\n        Box[1].materialID = 5;\n\n        // track 2, along [z - x = 0] line\n        Box[2].corner1 = vec3(\n            global_center.x + (track_W / 2.0) / sqrt(2.0) - (track_L / 2.0) / sqrt(2.0), \n            y_track_2(time_offset) - track_H - 2.0 * sphere_radius_1, \n            global_center.z - (track_W / 2.0) / sqrt(2.0) - (track_L / 2.0) / sqrt(2.0));\n        Box[2].corner2 = vec3(\n            global_center.x - (track_W / 2.0) / sqrt(2.0) + (track_L / 2.0) / sqrt(2.0), \n            y_track_2(time_offset) - 2.0 * sphere_radius_1, \n            global_center.z + (track_W / 2.0) / sqrt(2.0) + (track_L / 2.0) / sqrt(2.0));\n        Box[2].angle = 45.0 / 180.0 * PI;\n        Box[2].visible = (time_offset >= 8.0 && time_offset <= 18.0);\n        Box[2].materialID = 5;\n        \n        // track 3, along [z + x = 0] line\n        Box[3].corner1 = vec3(\n            global_center.x + (track_W / 2.0) / sqrt(2.0) - (track_L / 2.0) / sqrt(2.0), \n            y_track_3(time_offset) - track_H - 2.0 * sphere_radius_1, \n            global_center.z + (track_W / 2.0) / sqrt(2.0) + (track_L / 2.0) / sqrt(2.0));\n        Box[3].corner2 = vec3(\n            global_center.x - (track_W / 2.0) / sqrt(2.0) + (track_L / 2.0) / sqrt(2.0), \n            y_track_3(time_offset) - 2.0 * sphere_radius_1, \n            global_center.z - (track_W / 2.0) / sqrt(2.0) - (track_L / 2.0) / sqrt(2.0));\n        Box[3].angle = -45.0 / 180.0 * PI;\n        Box[3].visible = (time_offset >= 12.0 && time_offset <= 18.0);\n        Box[3].materialID = 5;\n\n        // long thin flagpole\n        Box[4].corner1 = vec3(\n            global_center.x + track_L / 4.0 * cos(sphere_rate * 2.0 * PI) - pole_L / 2.0, \n            y_pole(time_offset) - pole_H, \n            global_center.z + track_L / 4.0 * sin(sphere_rate * 2.0 * PI) - pole_W / 2.0);\n        Box[4].corner2 = vec3(\n            global_center.x + track_L / 4.0 * cos(sphere_rate * 2.0 * PI) + pole_L / 2.0, \n            y_pole(time_offset), \n            global_center.z + track_L / 4.0 * sin(sphere_rate * 2.0 * PI) + pole_W / 2.0);\n        Box[4].angle = 0.0;\n        Box[4].visible = (time_offset >= 20.0 && time_offset <= 32.0);\n        Box[4].materialID = 5;\n    }\n\n    // second session\n    else if (time_offset >= 32.0 && time_offset <= 64.0) {\n        // balls on tree, combined together\n        // like a new-moon shape\n        float ball_x[NUM_TREE_BALL];\n        float ball_y[NUM_TREE_BALL];\n        float ball_z[NUM_TREE_BALL];\n        // all balls are rotating with 4 seconds cycle\n        float theta_offset = mod(time_offset, ball_period) / ball_period * 2.0 * PI;\n\n        for (int i = 0 ; i < NUM_TREE_BALL ; i++) {\n            // get catesian coordinates     \n            ball_x[i] = ball_distance * sin(ball_phi[i]) * cos(ball_theta[i] + theta_offset);\n            ball_y[i] = ball_distance * cos(ball_phi[i]);\n            ball_z[i] = ball_distance * sin(ball_phi[i]) * sin(ball_theta[i] + theta_offset);\n        }\n        \n        // ball 8, the first top-right ball of the new-moon\n        Sphere[8].center = tree_ball_center + vec3(\n            ball_x[0],\n            ball_y[0] - tree_H + y_tree(time_offset),\n            ball_z[0]\n        );\n        Sphere[8].radius = ball_radius_3;\n        Sphere[8].visible = (time_offset >= 32.0 && time_offset <= 64.0);\n        Sphere[8].materialID = 9;\n\n        // ball 9, the second top-right ball of the new-moon\n        Sphere[9].center = tree_ball_center + vec3(\n            ball_x[1],\n            ball_y[1] - tree_H + y_tree(time_offset),\n            ball_z[1]\n        );\n        Sphere[9].radius = ball_radius_2;\n        Sphere[9].visible = (time_offset >= 32.0 && time_offset <= 64.0);\n        Sphere[9].materialID = 10;\n        \n        // ball 10, at the center, the biggest ball\n        Sphere[10].center = tree_ball_center + vec3(\n            ball_x[2],\n            ball_y[2] - tree_H + y_tree(time_offset),\n            ball_z[2]\n        );\n        Sphere[10].radius = ball_radius_1;\n        Sphere[10].visible = (time_offset >= 32.0 && time_offset <= 64.0);\n        Sphere[10].materialID = 9;\n        \n        // ball 11, the second down-left ball of the new-moon\n        Sphere[11].center = tree_ball_center + vec3(\n            ball_x[3],\n            ball_y[3] - tree_H + y_tree(time_offset),\n            ball_z[3]\n        );\n        Sphere[11].radius = ball_radius_2;\n        Sphere[11].visible = (time_offset >= 32.0 && time_offset <= 64.0);\n        Sphere[11].materialID = 10;\n        \n        // ball 12, the first down-left ball of the new-moon\n        Sphere[12].center = tree_ball_center + vec3(\n            ball_x[4],\n            ball_y[4] - tree_H + y_tree(time_offset),\n            ball_z[4]\n        );\n        Sphere[12].radius = ball_radius_3;\n        Sphere[12].visible = (time_offset >= 32.0 && time_offset <= 64.0);\n        Sphere[12].materialID = 9;\n\n        // tree trunk 1, the left lower one\n        Box[5].corner1 = vec3(\n            global_center.x - tree_distance / 2.0 - tree_W, \n            y_tree(time_offset) - tree_H, \n            global_center.z - tree_W / 2.0);\n        Box[5].corner2 = vec3(\n            global_center.x - tree_distance / 2.0, \n            y_tree(time_offset) - tree_diff, \n            global_center.z + tree_W / 2.0);\n        Box[5].angle = 0.0;\n        Box[5].visible = (time_offset >= 32.0 && time_offset <= 64.0);\n        Box[5].materialID = 5;\n\n        // tree trunk 2, the right higher one\n        Box[6].corner1 = vec3(\n            global_center.x + tree_distance / 2.0, \n            y_tree(time_offset) - tree_H, \n            global_center.z - tree_W / 2.0);\n        Box[6].corner2 = vec3(\n            global_center.x + tree_distance / 2.0 + tree_W, \n            y_tree(time_offset), \n            global_center.z + tree_W / 2.0);\n        Box[6].angle = 0.0;\n        Box[6].visible = (time_offset >= 32.0 && time_offset <= 64.0);\n        Box[6].materialID = 5;\n    }\n    \n    // Silver material.\n    Material[0].k_d = vec3( 0.4, 0.4, 0.4 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // red ball\n    Material[1].k_d = vec3( 1.0, 0.0, 1.0 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = vec3(1.0, 1.0, 1.0);\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 128.0;\n\n    // blue ball\n    Material[2].k_d = vec3( 0.1176, 0.5647, 1.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // light floor\n    Material[3].k_d = vec3( 0.6, 0.6, 0.6 );\n    Material[3].k_a = 0.2 * Material[3].k_d;\n    Material[3].k_r = 2.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 64.0;\n\n    // orange ball\n    Material[4].k_d = vec3( 1.0, 0.647, 0.0 );\n    Material[4].k_a = 0.2 * Material[4].k_d;\n    Material[4].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 128.0;\n\n    // box track\n    Material[5].k_d = vec3( 1.0, 1.0, 1.0 );\n    Material[5].k_a = 0.2 * Material[3].k_d;\n    Material[5].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[5].k_rg = 0.5 * Material[3].k_r;\n    Material[5].n = 128.0;\n\n    // mirror\n    Material[6].k_d = vec3( 0.3, 0.3, 0.3 );\n    Material[6].k_a = 0.2 * Material[0].k_d;\n    Material[6].k_r = 2.0 * Material[0].k_d;\n    Material[6].k_rg = 0.5 * Material[0].k_r;\n    Material[6].n = 64.0;\n\n    // fire brick\n    Material[7].k_d = vec3( 1.0, 0.1882, 0.1882 );\n    Material[7].k_a = 0.2 * Material[4].k_d;\n    Material[7].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[7].k_rg = 0.5 * Material[4].k_r;\n    Material[7].n = 128.0;\n\n    // to store galaxy\n    Material[8].k_d = vec3( 0.0, 0.0, 0.0 );\n    Material[8].k_a = 0.2 * Material[0].k_d;\n    Material[8].k_r = 2.0 * Material[0].k_d;\n    Material[8].k_rg = 0.5 * Material[0].k_r;\n    Material[8].n = 64.0;\n\n    // yellow ball\n    Material[9].k_d = vec3( 1.0, 1.0, 0.0 );\n    Material[9].k_a = 0.2 * Material[4].k_d;\n    Material[9].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[9].k_rg = 0.5 * Material[4].k_r;\n    Material[9].n = 128.0;\n\n    // light yellow ball\n    Material[10].k_d = vec3( 1.0, 1.0, 0.8784 );\n    Material[10].k_a = 0.2 * Material[4].k_d;\n    Material[10].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[10].k_rg = 0.5 * Material[4].k_r;\n    Material[10].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 16.0 + 4.0 * sin(time_rate * 16.0 * PI), 18.0, 15.0);\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    // Light[1].position = vec3( -4.0, 20.0, 3.0 );\n    // Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    // Light[1].I_source = vec3( 0.8, 0.8, 0.8 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection \n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    // get relative position of the ray to the center of the sphere\n    Ray_t local_ray = Ray_t(ray.o - sph.center, ray.d);\n    // solve quadratic equation\n    float a = 1.0;\n    float b = 2.0 * dot(local_ray.d, local_ray.o);\n    float c = dot(local_ray.o, local_ray.o) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    // d <= 0.0 means no solution\n    if ( d <= 0.0 )\n        return false;\n    \n    float t_minus = ( -b - sqrt(d) ) / (2.0 * a);\n    float t_plus =  ( -b + sqrt(d) ) / (2.0 * a);\n    float t_positive = 0.0;\n    // get the smallest positive solution\n    if ( t_minus > 0.0 )\n        t_positive = t_minus;\n    else if ( t_plus > 0.0 )\n        t_positive = t_plus;\n    else\n        return false;\n    // if t value is out of range, no intersections\n    if ( t_positive < tmin || t_positive > tmax ) return false;\n    // return t value, hit position and normal vectors\n    t = t_positive;\n    hitPos = ray.o + t_positive * ray.d;\n    hitNormal = normalize(hitPos - sph.center);\n    return true;  // Replace this with your code.\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    // get relative postion of the ray to the center of the sphere\n    Ray_t local_ray = Ray_t(ray.o - sph.center, ray.d);\n    // solve quadratic equation\n    float a = 1.0;\n    float b = 2.0 * dot(local_ray.d, local_ray.o);\n    float c = dot(local_ray.o, local_ray.o) - sph.radius * sph.radius;\n    float d = b * b - 4.0 * a * c;\n    // d <= 0.0 means no intersection\n    if ( d <= 0.0 )\n        return false;\n        \n    float t_minus = ( -b - sqrt(d) ) / (2.0 * a);\n    float t_plus =  ( -b + sqrt(d) ) / (2.0 * a);\n\n    float t_positive = 0.0;\n    // get the smallest positive solution\n    if ( t_minus > 0.0 )\n        t_positive = t_minus;\n    else if ( t_plus > 0.0 )\n        t_positive = t_plus;\n    else\n        return false;\n    // if t value is out of range, no intersections\n    if ( t_positive < tmin || t_positive > tmax ) return false;\n\n    return true;  // Replace this with your code.\n\n}\n\n// assume all box is y-axis-aligned\n// allow rotation around y axis\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax,\n                  out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    Plane_t faces[6];\n    vec3 faces_normal[6];\n    // calculate normal vectors of 6 faces\n    faces_normal[0] = vec3(-cos(box.angle), 0.0, -sin(box.angle));\n    faces_normal[1] = vec3(cos(box.angle), 0.0, sin(box.angle));\n    faces_normal[2] = vec3(0.0, -1.0, 0.0);\n    faces_normal[3] = vec3(0.0, 1.0, 0.0);\n    faces_normal[4] = vec3(sin(box.angle), 0.0, -cos(box.angle));\n    faces_normal[5] = vec3(-sin(box.angle), 0.0, cos(box.angle));\n\n    for (int i = 0 ; i < 3 ; i++) {\n        // construct 6 planes\n        faces[2 * i] = Plane_t(faces_normal[2 * i].x, faces_normal[2 * i].y, faces_normal[2 * i].z,\n                              -dot(faces_normal[2 * i], box.corner1), box.materialID);\n        faces[2 * i + 1] = Plane_t(faces_normal[2 * i + 1].x, faces_normal[2 * i + 1].y, faces_normal[2 * i + 1].z,\n                      -dot(faces_normal[2 * i + 1], box.corner2), box.materialID);\n    }\n    \n    float largest_near = tmin;\n    float smallest_far = tmax;\n\n    vec3 near_hitPos;\n    vec3 near_hitNormal;\n    \n    for (int i = 0 ; i < 3 ; i++) {\n        // for each pair of parallel planes\n        // check if the ray intersects with each of them\n        float t_neg;\n        vec3 hitPos_neg;\n        vec3 hitNormal_neg;\n        bool hashit_neg = IntersectPlane(faces[2 * i], ray, tmin, tmax,\n                                         t_neg, hitPos_neg, hitNormal_neg);\n        \n        float t_pos;\n        vec3 hitPos_pos;\n        vec3 hitNormal_pos;\n        bool hashit_pos = IntersectPlane(faces[2 * i + 1], ray, tmin, tmax,\n                                         t_pos, hitPos_pos, hitNormal_pos);\n        // at most 2 hits\n        float t_near;\n        float t_far;\n        // if no hit\n        if (!hashit_neg && !hashit_pos) {\n            // check if origin of the ray is located between 2 planes \n            // and exactly parallel to these 2 planes\n            float res1 = dot(ray.o, vec3(faces[2 * i].A, faces[2 * i].B, faces[2 * i].C)) + faces[2 * i].D;\n            float res2 = dot(ray.o, vec3(faces[2 * i + 1].A, faces[2 * i + 1].B, faces[2 * i + 1].C)) + faces[2 * i + 1].D;\n            if (res1 < -tmin && res2 < -tmin)\n                // if it is, ignore\n                continue;\n            else \n                // otherwise there cannot be ray-box intersections\n                return false;\n        }\n        else if (hashit_neg && !hashit_pos) {\n            // only hit the negative plane, record it as t_far\n            t_far = t_neg;\n            if (smallest_far > t_far)\n                smallest_far = t_far;\n        }\n        else if (!hashit_neg && hashit_pos) {\n            // only hit the positive plane, record it as t_far \n            t_far = t_pos;\n            if (smallest_far > t_far)\n                smallest_far = t_far;\n        }\n        else if (hashit_neg && hashit_pos) {\n            // hit both planes\n            // the smaller t is t_near, the other is t_far\n            t_near = t_neg < t_pos ? t_neg : t_pos;\n            t_far = t_neg > t_pos ? t_neg : t_pos;\n            if (largest_near < t_near) {\n                // update if t_near is a larger one\n                largest_near = t_near;\n                near_hitPos = t_neg < t_pos ? hitPos_neg : hitPos_pos;\n                near_hitNormal = t_neg < t_pos ? hitNormal_neg : hitNormal_pos;\n            }\n            if (smallest_far > t_far) {\n                smallest_far = t_far;\n            }\n        }\n    }    \n    // if the ray exits a pair of planes while it has not enter another pair of planes\n    // then no ray-box intersection\n    if (largest_near >= smallest_far) return false;\n    t = largest_near;\n    hitPos = near_hitPos;\n    hitNormal = near_hitNormal;\n\n    return true;\n}\n\nbool IntersectBox(in Box_t box, in Ray_t ray, in float tmin, in float tmax)\n{\n    Plane_t faces[6];\n    vec3 faces_normal[6];\n    // calculate normal vectors of 6 faces\n    faces_normal[0] = vec3(-cos(box.angle), 0.0, -sin(box.angle));\n    faces_normal[1] = vec3(cos(box.angle), 0.0, sin(box.angle));\n    faces_normal[2] = vec3(0.0, -1.0, 0.0);\n    faces_normal[3] = vec3(0.0, 1.0, 0.0);\n    faces_normal[4] = vec3(sin(box.angle), 0.0, -cos(box.angle));\n    faces_normal[5] = vec3(-sin(box.angle), 0.0, cos(box.angle));\n    for (int i = 0 ; i < 3 ; i++) {\n        // construct 6 planes\n        faces[2 * i] = Plane_t(faces_normal[2 * i].x, faces_normal[2 * i].y, faces_normal[2 * i].z,\n                              -dot(faces_normal[2 * i], box.corner1), box.materialID);\n        faces[2 * i + 1] = Plane_t(faces_normal[2 * i + 1].x, faces_normal[2 * i + 1].y, faces_normal[2 * i + 1].z,\n                      -dot(faces_normal[2 * i + 1], box.corner2), box.materialID);\n    }\n    float largest_near = tmin;\n    float smallest_far = tmax;\n    vec3 near_hitPos;\n    vec3 near_hitNormal;\n    for (int i = 0 ; i < 3 ; i++) {\n        // for each pair of parallel planes\n        // check if the ray intersects with each of them\n        float t_neg;\n        vec3 hitPos_neg;\n        vec3 hitNormal_neg;\n        bool hashit_neg = IntersectPlane(faces[2 * i], ray, tmin, tmax,\n                                         t_neg, hitPos_neg, hitNormal_neg);\n        \n        float t_pos;\n        vec3 hitPos_pos;\n        vec3 hitNormal_pos;\n        bool hashit_pos = IntersectPlane(faces[2 * i + 1], ray, tmin, tmax,\n                                         t_pos, hitPos_pos, hitNormal_pos);\n        // at most 2 hits\n        float t_near;\n        float t_far;\n        // if no hit\n        if (!hashit_neg && !hashit_pos) {\n            // check if origin of the ray is located between 2 planes \n            // and exactly parallel to these 2 planes\n            float res1 = dot(ray.o, vec3(faces[2 * i].A, faces[2 * i].B, faces[2 * i].C)) + faces[2 * i].D;\n            float res2 = dot(ray.o, vec3(faces[2 * i + 1].A, faces[2 * i + 1].B, faces[2 * i + 1].C)) + faces[2 * i + 1].D;\n            if (res1 < -tmin && res2 < -tmin)\n                // if it is, ignore\n                continue;\n            else \n                // otherwise there cannot be ray-box intersections\n                return false;\n        }\n        else if (hashit_neg && !hashit_pos) {\n            // only hit the negative plane, record it as t_far\n            t_far = t_neg;\n            if (smallest_far > t_far)\n                smallest_far = t_far;\n        }\n        else if (!hashit_neg && hashit_pos) {\n            // only hit the positive plane, record it as t_far \n            t_far = t_pos;\n            if (smallest_far > t_far)\n                smallest_far = t_far;\n        }\n        else if (hashit_neg && hashit_pos) {\n            // hit both planes\n            // the smaller t is t_near, the other is t_far\n            t_near = t_neg < t_pos ? t_neg : t_pos;\n            t_far = t_neg > t_pos ? t_neg : t_pos;\n            if (largest_near < t_near) {\n                // update if t_near is a larger one\n                largest_near = t_near;\n                near_hitPos = t_neg < t_pos ? hitPos_neg : hitPos_pos;\n                near_hitNormal = t_neg < t_pos ? hitNormal_neg : hitNormal_pos;\n            }\n            if (smallest_far > t_far) {\n                smallest_far = t_far;\n            }\n        }\n    }    \n    // if the ray exits a pair of planes while it has not enter another pair of planes\n    // then no ray-box intersection\n    if (largest_near >= smallest_far) return false;\n    \n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow, \n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a + \n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n// --------------------------------------------------------------------\n// following code refers to another shader toy project: universe within\n// to simulate galaxy\n// url: https://www.shadertoy.com/view/lscczl\n// this project uses its output galaxy as the texture of floor, the horizontal plane\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[4], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.005/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += line(p[1], p[3], st);\n\tm += line(p[1], p[5], st);\n    m += line(p[7], p[5], st);\n    m += line(p[7], p[3], st);\n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\nvoid getGalaxy( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*2.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., .6, z)*S(1., .8, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.4), -sin(t*.24))*.4+.6;\n    vec3 col = baseCol*m;\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 10.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n    col *= 1.-dot(uv,uv);\n    t = mod(iTime, 230.);\n    col *= S(0., 20., t)*S(224., 200., t);\n    #endif\n    \n    fragColor = vec4(col,1);\n}\n// reference ends\n// -------------------------------------------------------------\n\nconst float galaxy_L = 80.0;\nconst float galaxy_W = 45.0;\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray, \n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg ) \n{\n    // Find whether and where the ray hits some object. \n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    // check if the ray intersects with each plane\n    for (int i = 0 ; i < NUM_PLANES ; i++) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, \n                                     temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            if (i == 0) {\n                // for the horizontal plane\n                // calculate texture coordinates of the galaxy floor\n                float galaxy_x = temp_hitPos.x - global_center.x + galaxy_L / 2.0;\n                float galaxy_y = temp_hitPos.z - global_center.z + galaxy_W / 2.0;\n                vec2 galaxy_coord = vec2(galaxy_x / galaxy_L * iResolution.x, galaxy_y / galaxy_W * iResolution.y);\n                vec4 galaxy_color;\n                // get galaxy color\n                getGalaxy(galaxy_color, galaxy_coord);\n                // if inside the focus circle, make it darker\n                float focus_distance = (temp_hitPos.x - global_center.x) * (temp_hitPos.x - global_center.x) + \n                              (temp_hitPos.z - global_center.z) * (temp_hitPos.z - global_center.z);\n                if (focus_distance <= focus_radius) galaxy_color.rgb *= focus_darker;\n                // set galaxy color to material 8, and it will be used later\n                Material[8].k_d = galaxy_color.rgb;\n                Material[8].k_a = 0.2 * Material[0].k_d;\n                Material[8].k_r = 2.0 * Material[0].k_d;\n                Material[8].k_rg = 0.5 * Material[0].k_r;\n                Material[8].n = 64.0;\n                nearest_hitMatID = 8;\n            }\n            else if (i == 1)\n                nearest_hitMatID = Plane[i].materialID;\n        }\n    }\n\n    // check if the ray intersects with each sphere\n    for (int i = 0 ; i < NUM_SPHERES ; i++) {\n        // if the ball is not visible right now, skip it\n        // to be more cost-efficient\n        if (!Sphere[i].visible) continue;\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, \n                             temp_t, temp_hitPos, temp_hitNormal);\n        // if hits and a smaller t value is got, update information of the nearest point\n        if (temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[i].materialID;\n        }\n    }\n\n    // check if the ray intersects with each box\n    for (int i = 0 ; i < NUM_BOXES ; i++) {\n        // if the ball is not visible right now, skip it\n        // to be more cost-efficient\n        if (!Box[i].visible) continue;\n        temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, \n                             temp_t, temp_hitPos, temp_hitNormal);\n        // if hits and a smaller t value is got, update information of the nearest point\n        if (temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Box[i].materialID;\n        }\n    }\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point. \n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the \n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    // for each light, check if it can reach the hitting point\n    for (int i2 = 0 ; i2 < NUM_LIGHTS ; i2++) {\n        // construct shadow ray, points from hitting point to the light source\n        vec3 shadow_ray_d = normalize( Light[i2].position - nearest_hitPos );\n        Ray_t shadow_ray = Ray_t(nearest_hitPos + shadow_ray_d * DEFAULT_TMIN, shadow_ray_d);\n        bool inShadow = false;\n        bool temp_inShadow = false;\n        // the shadow ray cannot reach any point beyond the light source\n        float tmax_to_light = dot(shadow_ray_d, (Light[i2].position - nearest_hitPos));\n\n        // check if any plane blocks the shadow ray\n        for (int j = 0 ; j < NUM_PLANES ; j++) {\n            temp_inShadow = IntersectPlane(Plane[j], shadow_ray, DEFAULT_TMIN, tmax_to_light);\n            if (temp_inShadow) {\n                inShadow = temp_inShadow;\n                break;\n            }\n        }\n\n        // check if any sphere blocks the shadow ray\n        if (!inShadow) {\n             for (int k = 0 ; k < NUM_SPHERES ; k++) {\n                 if (!Sphere[k].visible) continue;\n                 temp_inShadow = IntersectSphere(Sphere[k], shadow_ray, DEFAULT_TMIN, tmax_to_light);\n                 if (temp_inShadow) {\n                     inShadow = temp_inShadow;\n                     break;\n                 }\n             }\n        }\n        \n        // check if any box blocks the shadow ray\n        if (!inShadow) {\n             for (int m = 0 ; m < NUM_BOXES ; m++) {\n                 if (!Box[m].visible) continue;\n                 temp_inShadow = IntersectBox(Box[m], shadow_ray, DEFAULT_TMIN, tmax_to_light);\n                 if (temp_inShadow) {\n                     inShadow = temp_inShadow;\n                     break;\n                 }\n             }\n        }\n        // debug with default no shadow\n        I_local += PhongLighting(shadow_ray.d, nearest_hitNormal, -ray.d, inShadow, \n                                 Material[nearest_hitMatID], Light[i2]);\n            \n    }\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ ) \n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}