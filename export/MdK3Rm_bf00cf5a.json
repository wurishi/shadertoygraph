{"ver":"0.1","info":{"id":"MdK3Rm","date":"1454693494","viewed":448,"name":"Metal framework","username":"TambakoJaguar","description":"I like the Victorian times metal structures like those used in the Eiffel tower. I tried to recreate one and during coding I thought about the idea of the movement along this curved \"tunnel\", with fog.\nTurn anti-aliasing on if you have a good GPU.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","framework","fog","bars","metal","movement","structures","victorian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n#define pi 3.141593\n#define sin45 0.7071067\n\n// Switches, you can play with them!\n//#define shadow\n#define ambocc\n#define specular\n#define curved_framework\n#define color_changes\n#define fog_variation\n//#define antialiaising\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct DirLamp\n{\n  vec3 direction;\n  vec3 color;\n  float intensity;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \n//Lamp lamps[2];\nDirLamp lamps[3];\n\n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define FRAMEWORK_OBJ   1\n\n// Framework options\nconst float T0 = 1.;\nconst float T0D = 0.6;\nconst float TF = 8.;\nconst float TR = 150.;\n\n// Campera options\nvec3 campos;\nvec3 camdir;\nfloat fov = 2.;\nfloat cspeed = 180.;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.05;\n\n// Fog\nconst vec3 fogColor1 = vec3(0.7);\nconst vec3 fogColor2 = vec3(0.5, 0.73, 1.);\nvec3 fogColor;\nconst float fogdens0 = 0.0024;\nfloat fogdensf;\n\n// Shading options\nconst float specint = 0.2;\nconst float specshin = 20.;\nconst float aoint = 1.3;\nconst float shi = 0.85;\nconst float shf = 0.4;\n\n// Tracing options\nconst float normdelta = 0.002;\nconst float maxdist = 1000.;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.67;\nconst int aasamples = 2;\n\n// 1D hash function\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nvec2 rotateVec45(vec2 vect)\n{\n    vec2 rv;\n    rv.x = vect.x*sin45 - vect.y*sin45;\n    rv.y = vect.x*sin45 + vect.y*sin45;\n    return rv;\n}\n\nvec2 rotateVec45i(vec2 vect)\n{\n    vec2 rv;\n    rv.x = vect.x*sin45 + vect.y*sin45;\n    rv.y = vect.x*sin45 - vect.y*sin45;\n    return rv;\n}\n\n// Rotates the position vector in function of the position of the mouse\nvec3 getCameraDir()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy; \n   \n    float angle = -2.*pi*(iMouse2.x/iResolution.x - 0.5);\n    float angle2 = 0.8*pi*(iMouse2.y/iResolution.y - 0.47);  \n    \n    vec3 posr = vec3(0., 0., 1.);\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return normalize(posr);\n}\n\nfloat bar(vec3 pos, float e)\n{\n    vec2 d = abs(pos.xy) - vec2(e, e);\n    return min(max(d.x,max(d.y,d.y)),0.0) + length(max(d,0.0)); \n}\n\nfloat mapBarsRot(vec3 pos)\n{\n    vec3 posr = pos;\n    posr.z = mod(posr.z, TF);\n    posr.yz = rotateVec45(posr.yz);\n    vec3 posr2 = pos;\n    posr2.z = mod(posr2.z, TF);\n    posr2.yz = rotateVec45i(posr2.yz);\n    \n    float fact = T0*TF*0.5;\n\n    posr = abs(posr);\n    posr.xy-= vec2(fact, fact*sin45);\n    posr2 = abs(posr2);\n    posr2.xy-= vec2(fact, fact*sin45);\n        \n    return max(min(bar(posr.xyz, T0/2.), bar(posr2.xyz, T0/2.)), bar(pos.xyz, fact + T0/2.));\n}\n\nfloat mapBars(vec3 pos)\n{     \n    vec3 pos0 = pos;\n    float fact = T0*TF*0.5;\n    \n    vec3 posr = pos;\n    posr.z = mod(posr.z + 1000., TF*TF + 3.6);\n    posr.yz = rotateVec45(posr.yz);\n    vec3 posri = pos;\n    posri.z = mod(posri.z + 1000., TF*TF + 3.6);\n    posri.yz = rotateVec45i(posri.yz);\n   \n    pos = abs(pos);\n    pos.xy-= vec2(fact*TF);\n    \n    posr = abs(posr);\n    posr.xy-= vec2(fact*TF);\n    posr.y+= TF;\n \n    posri = abs(posri);\n    posri.xy-= vec2(fact*TF);\n    posri.y+= TF;\n    \n    vec3 pos2 = abs(pos);\n    pos2.xy-= vec2(fact);\n    \n    vec3 posr2 = abs(posr);\n    posr2.xy-= vec2(fact);\n    \n    vec3 posri2 = abs(posri);\n    posri2.xy-= vec2(fact);\n    \n    //return bar(pos2, T0/2.);\n        \n    float v1 = min(min(bar(pos2, T0/2.), mapBarsRot(pos)), mapBarsRot(pos.yxz));\n    float v2 = min(min(bar(posr2, T0/2.), mapBarsRot(posr)), mapBarsRot(posr.yxz));\n    float v3 = min(min(bar(posri2, T0/2.), mapBarsRot(posri)), mapBarsRot(posri.yxz));\n    float v4 = max(min(v2, v3), bar(pos0/TF, fact + T0/2.));\n    return min(v1, v4);\n}\n\nfloat mapBars2(vec3 pos)\n{\n    return min(mapBars(pos), mapBars(pos.yxz));\n}\n\nvec3 getWaveDelta(vec3 pos)\n{\n    #ifdef curved_framework\n    return vec3(35.*sin(pos.z/368.) + 41.*sin(pos.z/185.) + 2.*sin(pos.z/96.), \n                75.*sin(pos.z/225.) + 9.*sin(pos.z/78.) + 5.*sin(pos.z/118.), \n                0.);\n    #else\n    return vec3(0.);\n    #endif\n}\n\n// Combines all the distance fields\nvec2 map(vec3 pos)\n{\n    pos+= getWaveDelta(pos);\n    return vec2(mapBars2(pos), FRAMEWORK_OBJ);           \n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.;\n    float objnr = 0.;\n    \n    for (int i = 0; i < 64; ++i) // 64 85\n    {\n    \tvec3 pos = ray*t + cam;\n        vec2 res = map(pos);\n    \tfloat dist = res.x;\n        if (dist>maxdist || abs(dist)<0.08)\n            break;\n        t+= dist*(0.9 + float(i)*0.009);\n        //t+= dist*0.82;\n        objnr = abs(res.y);\n\t}\n\treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    e = pow(distance(campos, pos), 2.)*0.00001;\n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Gets the color of the metal rings\nvec3 framework_color(vec3 pos,vec3 norm)\n{\n    #ifdef color_changes\n    vec3 fc = vec3(0.58 + 0.03*sin(pos.z/687.), \n                   0.41 + 0.09*sin(pos.z/537.), \n                   0.12 + 0.07*sin(pos.z/856.));\n    #else\n    vec3 fc = vec3(0.58, 0.41, 0.12);\n    #endif\n    vec2 tpos = vec2(dot(pos.yx, norm.xy) + pos.z, dot(pos.yz, norm.zy) - 1.5*pos.z + 0.2);\n    vec3 mc = texture(iChannel0, 0.1*tpos).rgb;\n    float mc2 = texture(iChannel1, 0.01*tpos).r;\n    vec3 col1 = mix(mix(mc, fc*mc, 0.5), fc, 0.4);\n    col1 = mix(col1, vec3(0.05), smoothstep(0.65, 1., mc2));\n    col1 = mix(col1, vec3(0.42, 0.19, 0.13), smoothstep(0.55, 0., mc2));\n        \n    return col1;\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n    return fogColor;\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 5;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map(p + rd.x).x) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(DirLamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.direction);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dot(norm, pl));\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.direction) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(vec3(lamp.position.x, 4.9, lamp.position.z) - pos), shf, 100.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n \n    lamps[0] = DirLamp(vec3(-2., 1., -5.), vec3(1., 1., 1.), 1.5);\n    lamps[1] = DirLamp(vec3(2., 3., -5.), vec3(1., .95, .75), 1.5);\n    lamps[2] = DirLamp(vec3(2., -1., 5.), vec3(0.6, 0.75, 1.), 1.5);\n\n    // Fog\n    #ifdef fog_variation\n    fogdensf = 0.15*sin(tpos.z/452.) + 0.1*sin(tpos.z/216.) + 0.05*sin(tpos.z/143.);\n    #else\n    fogdensf = 0.3;\n    #endif\n    float fogdens = (1.2 + 2.*fogdensf)*fogdens0;\n    fogColor = mix(fogColor2, fogColor1, 0.7 + fogdensf);\n    \n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta);\n        col = framework_color(pos, norm);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm, 7., 1.1));\n        //col = vec3(calcAO(pos, norm, 25., 0.9));\n        #endif\n        \n        float fogd = clamp(exp(-pow(fogdens*tx, 2.)), 0., 1.);\n        col = mix (fogColor, col, fogd);\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections\nvec4 render(vec2 fragCoord)\n{   \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \n  RenderData traceinf = trace0(campos, ray, maxdist);\n  vec3 col = traceinf.col;\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    campos = vec3(0., 0., iTime*cspeed);\n    campos-= getWaveDelta(campos);\n    camdir = getCameraDir();\n    camdir+= (getWaveDelta(campos - camdir*vec3(0., 0., 0.)) - getWaveDelta(campos + camdir*vec3(0., 0., 20.)))*0.055;\n    \n    // Antialiasing\n    #ifdef antialiaising\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = render(fragCoord);\n    #endif \n}","name":"Image","description":"","type":"image"}]}