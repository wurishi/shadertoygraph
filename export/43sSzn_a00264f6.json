{"ver":"0.1","info":{"id":"43sSzn","date":"1709208038","viewed":303,"name":"Gemnerator","username":"SL0ANE","description":"本来还想随机面数和角度，\n但是编译出来超级慢不知道为什么。","likes":6,"published":1,"flags":48,"usePreview":1,"tags":["procedural","raymarching","sdf","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"zzzPathTracingPrototype002\" by SL0ANE. https://shadertoy.com/view/X3S3WG\n// 2024-02-28 02:35:30\n\n// Fork of \"zzzPathTracingPrototype001\" by SL0ANE. https://shadertoy.com/view/X3jGRw\n// 2024-02-24 11:54:07\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 col = texture(iChannel0, fragCoord / iResolution.xy);\n    col.rgb = pow(col.rgb / col.a, vec3(0.45));\n    \n    fragColor = vec4(col.rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Const\n# define VEC3_ZERO vec3(0.0, 0.0, 0.0)\n# define DEFAULT_COLOR vec4(0.5, 0.5, 0.5, 1.0)\n# define PI 3.1415926535897932384626433832795\n# define PHI 2.399963229728653322231555506633\n# define INT_MAX 0xffffffffu\n\n// Input\n# define POINTER_ROT ivec2(0, 1)\n# define POINTER_TIME ivec2(0, 2)\n# define POINTER_PRESS ivec2(0, 3)\n# define POINTER_MOUSE ivec2(0, 4)\n# define POINTER_RESETCAM ivec2(0, 5)\n# define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n# define load(P) texelFetch(iChannel2, ivec2(P), 0)\n# define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n# define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n# define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n# define QUA_ZERO vec4(0.0, 0.0, 0.0, 1.0)\n\n// Input Gem\n# define POINTER_GEM_COLOR ivec2(1, 0)\n# define POINTER_GEM_ABSORB ivec2(1, 1)\n# define POINTER_GEM_CENTER ivec2(1, 2)\n# define POINTER_GEM_EXTRA ivec2(1, 3)\n\n// Pro Ject\n# define FRAME_SAMPLES 4\n# define TOTAL_SAMPLES 512\n\n// Object Container\n# define DEFAULT_MATERIAL Material(DEFAULT_COLOR, DEFAULT_COLOR, DEFAULT_COLOR, VEC3_ZERO, VEC3_ZERO, VEC3_ZERO, 0.0, 0.0, 0.0, false, 0)\n# define DEFAULT_OBJECTINFO ObjectInfo(0.0, DEFAULT_MATERIAL)\n\nstruct Material\n{\n    // baseColor\n    vec4 color0;\n    // absorbtion\n    vec4 color1;\n    vec4 color2;\n    vec3 vect0;\n    vec3 vect1;\n    vec3 vect2;\n    // smoothness\n\tfloat t0;\n    float t1;\n    // fraction\n    float t2;\n    bool b0;\n    int index;\n};\n\nstruct ObjectInfo\n{\n\tfloat dis;\n    Material material;\n};\n\nstruct DirectionalLight\n{\n    vec3 dir;\n    vec3 color;\n\tfloat intensity;\n};\n// RNG\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash21(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nvec2 hash21(float src) {\n    uvec2 h = murmurHash21(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuint lgcCurrent;\nconst uint lgcFactor = uint(22695477);\nconst uint lgcAdder = uint(1);\n\nfloat lgc(inout uint current)\n{\n    current = (current * lgcFactor + lgcAdder) % INT_MAX;\n    return uintBitsToFloat(current & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat lgc()\n{\n    lgcCurrent = (lgcCurrent * lgcFactor + lgcAdder) % INT_MAX;\n    return uintBitsToFloat(murmurHash11(lgcCurrent) & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nvoid lgcInit(uint seed)\n{\n    lgcCurrent = seed;\n}\n\n\nvec3 cosineDirection(vec3 nor)\n{\n    float u = lgc();\n    float v = lgc();\n                \n    float ks = (nor.z>=0.0)?1.0:-1.0;\n    float ka = 1.0 / (1.0 + abs(nor.z));\n    float kb = -ks * nor.x * nor.y * ka;\n    vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n    vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n    float a = 6.2831853 * v;\n    return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n}\n\n// Quaternion\nvec4 conjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 quaternionInverse(vec4 q) {\n    return conjugate(q) / dot(q, q);\n}\n\nvec4 quaternionMul(vec4 left, vec4 right)\n{\n    float w = left.w*right.w - left.x*right.x - left.y*right.y - left.z * right.z;\n    float x = left.w*right.x + left.x*right.w + left.z*right.y - left.y * right.z;\n    float y = left.w*right.y + left.y*right.w + left.x*right.z - left.z * right.x;\n    float z = left.w*right.z + left.z*right.w + left.y*right.x - left.x * right.y;\n    \n    return vec4(x, y, z, w);\n}\n\nvec4 quaternionLerp(vec4 starting, vec4 ending, float t)\n{\n    float cosa = starting.x *ending.x + starting.y * ending.y + starting.z *ending.z  + starting.w * ending.w;\n    \n    if (cosa < 0.0) \n    {\n        ending.x = -ending.x;\n        ending.y = -ending.y;\n        ending.z = -ending.z;\n        ending.w = -ending.w;\n        cosa = -cosa;\n    }\n    \n    float k0, k1;\n    \n    if (cosa > 0.9995f) \n    {\n        k0 = 1.0 - t;\n        k1 = t;\n    }\n    else \n    {\n        float sina = sqrt(1.0 - cosa * cosa);\n        float a = atan(sina, cosa);\n        k0 = sin((1.0 - t) * a) / sina;\n        k1 = sin(t * a) / sina;\n    }\n    \n    vec4 result;\n    \n    result.x = starting.x * k0 + ending.x * k1;\n    result.y = starting.y * k0 + ending.y * k1;\n    result.z = starting.z * k0 + ending.z * k1;\n    result.w = starting.w * k0 + ending.w * k1;\n    \n    return result;\n}\n\nvec3 rotatePoint(vec3 p, vec3 center, vec4 q) {\n    vec4 pQuaternion = vec4(p - center, 0.0);\n\n    vec4 rotatedP = quaternionMul(quaternionMul(q , pQuaternion), conjugate(q));\n    vec3 rotatedPoint = rotatedP.xyz;\n    \n    rotatedPoint += center;\n    \n    return rotatedPoint;\n}\n\n// Object Operation\nObjectInfo objectMin(ObjectInfo a, ObjectInfo b)\n{\n    if(a.dis < b.dis) return a;\n    else return b;\n}\n\nObjectInfo objectCombine(ObjectInfo a, ObjectInfo b)\n{\n    bool inside = a.dis < 0.0;\n    if(inside && (b.dis < 0.0 || a.dis + 0.000001 <= -b.dis) || !inside && (a.dis > b.dis)) return b;\n    else return a;\n}\n// COLOR PROCESS\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// SDF Operation\nfloat sub(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\n// 3D SDF\nfloat sdSphere(vec3 p, vec3 sdf_pos, float sdf_rad)\n{\n    vec3 transPoint = p - sdf_pos;\n    return distance(transPoint, vec3(0)) - sdf_rad;\n}\n\nfloat sdBox( vec3 p, vec3 sdf_pos, vec3 b )\n{\n    vec3 transPoint = p - sdf_pos;\n    vec3 q = abs(transPoint) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 sdf_pos, vec3 sdf_normal)\n{\n    return dot(p - sdf_pos, sdf_normal);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"# define RECOVER_TIME 2.0\n# define SENSITIVE 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 curRot = load(POINTER_ROT);\n    float time = load(POINTER_TIME).x;\n    float press = load(POINTER_PRESS).x;\n    vec4 mouse = load(POINTER_MOUSE);\n    float reset = load(POINTER_RESETCAM).x;\n    if(curRot == vec4(0.0)) curRot = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iMouse.z > 0.0)\n    {\n        if(press < 1.0)\n        {\n            press = 1.0;\n            mouse = iMouse;\n        }\n        \n        vec2 curAng = vec2(PI * SENSITIVE * (iMouse.x - mouse.x) / iResolution.x, PI * SENSITIVE * (mouse.y - iMouse.y) / iResolution.x); \n        curRot = quaternionMul(quaternionMul(vec4(sin(curAng.y / 2.0), 0.0, 0.0, cos(curAng.y / 2.0)), vec4(0.0, sin(curAng.x / 2.0), 0.0, cos(curAng.x / 2.0))), curRot);\n        mouse = iMouse;\n        \n        time = 0.0;\n        reset = 0.0;\n    }\n    else if(keyDown(81)) {\n        float curAng = -PI * SENSITIVE * iTimeDelta;\n        curRot = -quaternionMul(vec4(0.0, 0.0, sin(curAng / 2.0), cos(curAng / 2.0)), curRot);\n        reset = 0.0;\n        time = 0.0;\n    }\n    else if(keyDown(69)) {\n        float curAng = PI * SENSITIVE * iTimeDelta;\n        curRot = -quaternionMul(vec4(0.0, 0.0, sin(curAng / 2.0), cos(curAng / 2.0)), curRot);\n        reset = 0.0;\n        time = 0.0;\n    }\n    else if(keyClick(82)) {\n        reset = 1.0;\n        time = 0.0;\n    }\n    else\n    {\n        press = 0.0;\n        time += iTimeDelta;\n    }\n    \n    if(reset > 0.0) {\n        float progress = time / RECOVER_TIME;\n        curRot = quaternionLerp(curRot, vec4(0.0, 0.0, 0.0, 1.0), clamp(progress, 0.0, 1.0));\n        time += iTimeDelta;\n        \n        if(progress >= 1.0) reset = 0.0;\n    }\n    \n    store(POINTER_ROT, curRot);\n    store(POINTER_TIME, vec4(time));\n    store(POINTER_PRESS, vec4(press));\n    store(POINTER_MOUSE, mouse);\n    store(POINTER_RESETCAM, vec4(reset));\n    \n    if(iFrame % (1 * TOTAL_SAMPLES / FRAME_SAMPLES) == 0)\n    {\n        lgcInit(floatBitsToUint(iDate.x) + floatBitsToUint(iDate.y) + floatBitsToUint(iDate.z) + floatBitsToUint(iDate.w));\n        store(POINTER_GEM_COLOR, vec4(hsv2rgb(vec3(lgc(), 0.76, 0.98 - lgc() * 0.5)), 1.0));\n        store(POINTER_GEM_ABSORB, vec4(hsv2rgb(vec3(lgc(), 1.0, 0.6)) * 4.0, 1.0));\n        store(POINTER_GEM_CENTER, vec4(vec3(0.0, 0.8, 0.0) * (lgc() * 2.0 - 1.0), 1.0));\n        store(POINTER_GEM_EXTRA, vec4(mix(0.98, 1.0, lgc()), mix(1.4, 2.3, lgc()), lgc(), 1.0));\n    }\n    else\n    {\n        store(POINTER_GEM_COLOR, load(POINTER_GEM_COLOR));\n        store(POINTER_GEM_ABSORB, load(POINTER_GEM_ABSORB));\n        store(POINTER_GEM_CENTER, load(POINTER_GEM_CENTER));\n        store(POINTER_GEM_EXTRA, load(POINTER_GEM_EXTRA));\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"# define MAX_STEP 512\n# define MAX_LENGTH 1024.0\n# define MAX_SHADOW 1024.0\n\n# define BACKGROUND_COLOR vec4(0.06, 0.01, 0.01, 1.0)\n# define SLOANE_COLOR vec4(0.98, 0.24, 0.24, 1.0)\n# define GROUND_COLOR vec4(0.05, 0.05, 0.05, 1.0)\n\n# define BOUNCE_TIME 8\n# define MIX_REFLECT\n# define REFRECTION_AIR 1.0\n\n// Light\nDirectionalLight light0 = DirectionalLight(normalize(vec3(-1.0, -2.0, 1.0)), vec3(1.0, 0.5, 0.4), 128.0);\nDirectionalLight light1 = DirectionalLight(normalize(vec3(0.2, -3.0, -0.5)), vec3(0.5, 0.8, 1.0), 128.0);\nDirectionalLight light2 = DirectionalLight(normalize(vec3(-0.5, -3.0, 0.2)), vec3(0.8, 0.5, 1.0), 128.0);\n\n// Camera Config\nfloat cameraFov = 48.0f;\n\n// Bone\nvec3 positionLocal_Camera = vec3(0.0, 0.0, 0.0);\nvec4 rotationLocal_Camera = vec4(0.0, 0.0, 0.0, 1.0);\nvec3 positionWorld_Camera;\nvec4 rotationWorld_Camera;\n\nvec3 positionLocal_Root = vec3(0.0, 0.0, 8.0);\nvec4 rotationLocal_Root = vec4(0.070, 0.858, -0.121, 0.495);\nvec3 positionWorld_Root;\nvec4 rotationWorld_Root;\n\n// GemInfo\nstruct GemInfo\n{\n    vec3 color;\n    vec3 absorbtion;\n    float smoothness;\n    float fraction;\n    \n    vec3 center;\n    float angleOffset;\n    \n    int surCount;\n};\n\nGemInfo defaultGemInfo = GemInfo(SLOANE_COLOR.rgb, vec3(0.1, 0.6, 0.0) * 3.0, 1.0, 1.6, vec3(0.0, -0.4, 0.0), 1.0, 24);\n\nObjectInfo objectGround(vec3 p, vec3 pos, vec3 size, vec3 color, vec3 absorbtion, float smoothness, bool istrans, float fraction, bool withMat)\n{\n    ObjectInfo info = DEFAULT_OBJECTINFO;\n    vec3 transPoint = p - pos;\n    \n    if(withMat)\n    {\n        vec2 uv = transPoint.xz / size.xz + 0.5;\n        info.material.color0.rgb = color * texture(iChannel3, uv).rgb;\n        info.material.color1.rgb = absorbtion;\n        info.material.t0 = smoothness;\n        info.material.t2 = fraction;\n        info.material.b0 = istrans;\n    }\n\n    info.dis = sdPlane(transPoint, vec3(1.0), vec3(0.0, 1.0, 0.0));\n    \n    return info;\n}\n\n\nObjectInfo objectSphere(vec3 p, vec3 pos, float size, vec3 color, vec3 absorbtion, float smoothness, bool istrans, float fraction, bool withMat)\n{\n    ObjectInfo info = DEFAULT_OBJECTINFO;\n    \n    if(withMat)\n    {\n        info.material.color0.rgb = color;\n        info.material.color1.rgb = absorbtion;\n        info.material.t0 = smoothness;\n        info.material.t2 = fraction;\n        info.material.b0 = istrans;\n    }\n    \n    vec3 transPoint = p - pos;\n    info.dis = sdSphere(transPoint, vec3(0), size);\n    \n    return info;\n}\n\nObjectInfo objectGem(vec3 p, vec3 pos, GemInfo gemInfo, bool withMat)\n{\n    ObjectInfo info = DEFAULT_OBJECTINFO;\n    \n    if(withMat)\n    {\n       info.material.color0.rgb = gemInfo.color;\n       info.material.color1.rgb = gemInfo.absorbtion;\n       info.material.t0 = gemInfo.smoothness;\n       info.material.t2 = gemInfo.fraction;\n       info.material.b0 = true;\n    }\n    \n    vec3 transPoint = p - pos;\n    info.dis = sdSphere(transPoint, vec3(0), 3.0);\n    vec3 point;\n    float rad;\n    float theta;\n    vec3 normal;\n    float inner = 2.0 * (1.0 - cos(sqrt(4.0 / float(gemInfo.surCount))));\n    for(int i = 0; i < gemInfo.surCount; i++)\n    {\n        point.y = 1.0 - float(i) / (float(gemInfo.surCount) - 1.0) * 2.0;\n        rad = sqrt(1.0 - point.y * point.y);\n        \n        theta = float(i) * PHI + gemInfo.angleOffset;\n        point.x = cos(theta) * rad;\n        point.z = sin(theta) * rad;\n        \n        normal = normalize(point - gemInfo.center);\n        \n        point -= inner * normal;\n        \n        info.dis = sub(info.dis, sdPlane(transPoint, point, -normal));\n    }\n    \n    return info;\n}\n\nObjectInfo sceneMap(vec3 p, bool withMat)\n{ \n    ObjectInfo info;\n    vec3 transPoint = rotatePoint(p - positionWorld_Root, vec3(0), quaternionInverse(rotationWorld_Root));\n    \n    info = objectGem(transPoint, vec3(0), defaultGemInfo, withMat);\n    info = objectCombine(info, objectGround(transPoint, vec3(-2.0), vec3(16.0, 1.0, 16.0), GROUND_COLOR.rgb, vec3(0.0), 0.4, false, 1.0, withMat));\n    \n    return info;\n}\n\nvec3 getNormal(vec3 point, float pixelSize)\n{\n    pixelSize *= 0.1;\n    \n    vec3 deltaX = vec3(pixelSize, 0.0, 0.0);\n    vec3 deltaY = vec3(0.0, pixelSize, 0.0);\n    vec3 deltaZ = vec3(0.0, 0.0, pixelSize);\n    \n    float center = sceneMap(point, false).dis;\n    \n    float x = sceneMap(point + deltaX, false).dis - center;\n    float y = sceneMap(point + deltaY, false).dis - center;\n    float z = sceneMap(point + deltaZ, false).dis - center;\n    \n    return normalize(vec3(x, y, z) * sign(center));\n}\n\nvec3 getSky(vec3 dir)\n{\n    return texture(iChannel1, dir).rgb;\n}\n\nvec3 getSun(vec3 dir)\n{\n    return smoothstep(0.95, 1.0, dot(-dir, light0.dir)) * light0.color * light0.intensity\n          +smoothstep(0.95, 1.0, dot(-dir, light1.dir)) * light1.color * light1.intensity;\n          +smoothstep(0.95, 1.0, dot(-dir, light2.dir)) * light2.color * light2.intensity;\n}\n\nvoid march(vec3 start, vec3 ray, vec3 front, float pixelSize, float maxLen, inout vec3 pos, inout float len, inout float curPixelSize, inout float camDis, inout bool hit)\n{\n    float dis = 0.0;\n    vec3 curPos = vec3(0.0);\n    \n    curPixelSize = camDis * pixelSize;\n    len = curPixelSize * 0.05;\n    \n    ObjectInfo curInfo;\n    float stepDis;\n    int stepCount = 0;\n    float sumCamDis;\n    hit = false;\n    \n    \n    while(len < maxLen && stepCount <= MAX_STEP)\n    {\n        curPos = len * ray + start;\n        pos = curPos;\n        \n        sumCamDis = abs(dot(pos - start, front)) + camDis;\n        curPixelSize = sumCamDis * pixelSize;\n\n        curInfo = sceneMap(curPos, false);\n        \n        dis = abs(curInfo.dis);\n        \n        if(dis < curPixelSize * 0.05)\n        {\n            hit = true;\n            break;\n        }\n        \n\n        stepDis = dis * 0.98;\n        len += stepDis;\n        stepCount += 1;\n    }\n    \n    camDis = sumCamDis;\n}\n\n// Shading\n\nvoid getBRDFRay(vec3 pos, vec3 normal, Material material, float curPixelSize, vec3 enterPos, inout bool inside, inout int bounceTime, inout vec3 origin, inout vec3 ray, inout vec3 indColor)\n{\n    if(material.b0)\n    {\n        origin = pos;\n        vec3 intoOrigin = origin - 1.0 * normal * curPixelSize;\n            \n        if(inside)\n        {\n            ObjectInfo intoInfo = sceneMap(intoOrigin, true);\n            float intoRefInd;\n            float factor;\n            float ndotl;\n            float refRat;\n            vec3 refraction;\n            float refRep;\n            float reflection;\n            \n            bool intoInside = intoInfo.dis < curPixelSize * 0.1;\n            if(!intoInside)\n            {\n                intoRefInd = REFRECTION_AIR;\n                factor = (material.t2 - intoRefInd) * (material.t2 - intoRefInd) / ((material.t2 + intoRefInd) * (material.t2 + intoRefInd));\n                ndotl = dot(ray, -normal);\n                \n                refRat = material.t2 / intoRefInd;\n                refraction = refract(ray, normal, refRat);\n                \n                refRep = 1.0 - ndotl;\n                refRep = refRep * refRep * refRep * refRep * refRep;\n                reflection = factor + (1.0 - factor) * refRep;\n                \n                if(lgc() < reflection)\n                {\n                    origin += normal * curPixelSize;\n                    ray = normalize(mix(cosineDirection(normal), reflect(ray, normal), material.t0));\n                \n                    if(intoInside && !intoInfo.material.b0) indColor *= intoInfo.material.color0.rgb;\n                }\n                else\n                {\n                    origin = intoOrigin;\n                    ray = normalize(mix(cosineDirection(-normal), refraction, material.t0));\n            \n                    bounceTime -= 1;\n                    inside = false;\n                }\n            }\n            else if(!intoInfo.material.b0)\n            {\n                intoRefInd = REFRECTION_AIR;\n                factor = (material.t2 - intoRefInd) * (material.t2 - intoRefInd) / ((material.t2 + intoRefInd) * (material.t2 + intoRefInd));\n                ndotl = dot(ray, -normal);\n                \n                refRat = material.t2 / intoRefInd;\n                refraction = refract(ray, normal, refRat);\n                \n                refRep = 1.0 - ndotl;\n                refRep = refRep * refRep * refRep * refRep * refRep;\n                reflection = factor + (1.0 - factor) * refRep;\n                \n                if(lgc() < reflection)\n                {\n                    origin += normal * curPixelSize;\n                    ray = normalize(mix(cosineDirection(normal), reflect(ray, normal), material.t0));\n                }\n                else\n                {\n                    bool reflected = false;\n                    origin += normal * curPixelSize;\n                    ray = normalize(mix(cosineDirection(-normal), refraction, material.t0));\n                    ray = normalize(mix(cosineDirection(normal), reflect(ray, normal), intoInfo.material.t0));\n\n                    indColor *= intoInfo.material.color0.rgb;\n                    bounceTime -= 1;\n                }\n            }\n            \n            float len = length(pos - enterPos);\n            indColor *= vec3(exp(-len * material.color1.r), exp(-len * material.color1.g), exp(-len * material.color1.b));\n        }\n        else\n        {\n            float intoRefInd = REFRECTION_AIR;\n            float factor = (material.t2 - intoRefInd) * (material.t2 - intoRefInd) / ((material.t2 + intoRefInd) * (material.t2 + intoRefInd));\n            float ndotl = dot(ray, -normal);\n            \n            float refRat = intoRefInd / material.t2;\n            vec3 refraction = refract(ray, normal, refRat);\n        \n            float refRep = 1.0 - ndotl;\n            refRep = refRep * refRep * refRep * refRep * refRep;\n            float reflection = factor + (1.0 - factor) * refRep;\n        \n            if(lgc() < reflection)\n            {\n                origin += normal * curPixelSize;\n                ray = normalize(mix(cosineDirection(normal), reflect(ray, normal), material.t0));\n                \n                indColor *= material.color0.rgb;\n            }\n            else\n            {\n                origin = intoOrigin;\n                ray = normalize(mix(cosineDirection(-normal), refraction, material.t0));\n            \n                bounceTime -= 1;\n                inside = true;\n                \n                indColor *= material.color0.rgb;\n            }\n        }\n    }\n    else\n    {\n        indColor *= material.color0.rgb;\n        origin = pos;\n        origin += normal * curPixelSize;\n        ray = normalize(mix(cosineDirection(normal), reflect(ray, normal), material.t0));\n    }\n}\n\nvec3 calculateColor(vec3 start, vec3 ray, vec3 front, float pixelSize, int bounce)\n{\n    vec3 pos;\n    float len;\n    vec3 normal;\n    Material material;\n    vec3 resColor = vec3(0.0);\n    vec3 dirColor;\n    vec3 indColor = vec3(1.0);\n    float curPixelSize;\n    vec3 origin = start;\n    float camDis = 0.0;\n    float RdotN;\n    bool hit;\n    bool inside = sceneMap(pos, true).dis < 0.0;\n    vec3 enterPos;\n\n    for(int i = 0; i < bounce; i++)\n    {\n        march(origin, ray, front, pixelSize, MAX_LENGTH, pos, len, curPixelSize, camDis, hit);\n\n        if(!hit)\n        {\n           dirColor = getSky(ray) + getSun(ray);\n           resColor += indColor * dirColor;\n           break;\n        }\n\n        material = sceneMap(pos, true).material;\n        if(inside) normal = getNormal(pos - 1.0 * ray * curPixelSize, curPixelSize);\n        else normal = getNormal(pos, curPixelSize);\n\n        // dirColor = applyLighting(pos, normal, ray, front, pixelSize, camDis, material);\n        \n        getBRDFRay(pos, normal, material, curPixelSize, enterPos, inside, i, origin, ray, indColor);\n        if(inside) enterPos = origin;\n\n        // resColor += indColor * dirColor;\n        // indColor *= material.color0.rgb;\n    }\n\n    return resColor;\n}\n\nvec3 calcPixelColor(vec2 fragCoord)\n{\n    vec3 col = vec3(0.0);\n    \n    for(int i = 0; i < FRAME_SAMPLES; i++)\n    {\n        vec2 uv = (fragCoord.xy + (vec2(lgc(), lgc()) - 0.5) - iResolution.xy / 2.0) / iResolution.x;\n        float delta = 1.0 / iResolution.x;\n        float tanFov = tan(cameraFov / 360.0 * PI);\n        vec3 ray = normalize(vec3(uv, 0.5 / tanFov));\n        \n        // 平面距离为1时，每个像素对应的大小\n        float pixelSize = 2.0 * tanFov / iResolution.x;\n        vec3 front = rotatePoint(vec3(0.0, 0.0, 1.0), vec3(0.0), rotationWorld_Camera);\n        ray = rotatePoint(ray, vec3(0.0), rotationWorld_Camera);\n        \n        col += calculateColor(positionWorld_Camera, ray, front, pixelSize, BOUNCE_TIME);\n    }\n    // col = col / float(FRAME_SAMPLES);\n\n    return col;\n}\n\nvoid update(vec2 fragCoord)\n{\n    float angle;\n    lgcInit(floatBitsToUint(iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.x));\n    \n    // 相机\n    positionWorld_Camera = positionLocal_Camera;\n    rotationWorld_Camera = rotationLocal_Camera;\n    \n    // 根\n    positionWorld_Root = positionLocal_Root;\n    // rotationLocal_Root = quaternionMul(load(POINTER_ROT), rotationLocal_Root);\n    rotationWorld_Root = rotationLocal_Root;\n    \n    light0.dir = normalize(rotatePoint(light0.dir, vec3(0.0), rotationWorld_Root));\n    light1.dir = normalize(rotatePoint(light1.dir, vec3(0.0), rotationWorld_Root));\n    light2.dir = normalize(rotatePoint(light2.dir, vec3(0.0), rotationWorld_Root));\n    \n    defaultGemInfo.color = load(POINTER_GEM_COLOR).rgb;\n    defaultGemInfo.absorbtion = load(POINTER_GEM_ABSORB).rgb;\n    defaultGemInfo.center = load(POINTER_GEM_CENTER).rgb;\n    \n    vec3 extra = load(POINTER_GEM_EXTRA).rgb;\n    defaultGemInfo.smoothness = extra.r;\n    defaultGemInfo.fraction = extra.g;\n    // defaultGemInfo.angleOffset = 2.0 * PI * load(POINTER_GEM_EXTRA);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 accum = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    \n    if(iMouse.z > 0.0) accum = vec4(0.0);\n    if(iFrame % (1 * TOTAL_SAMPLES / FRAME_SAMPLES) == 0)\n    {\n        accum = vec4(0.0);\n    }\n    \n    update(fragCoord);\n    \n    if(accum.a > 0.999) \n    {\n        fragColor = accum;\n        return;\n    }\n    float currentSamples = float(FRAME_SAMPLES) / float(TOTAL_SAMPLES) + accum.a;\n    fragColor = vec4(calcPixelColor(fragCoord) / float(TOTAL_SAMPLES) + accum.rgb, currentSamples);\n}","name":"Buffer A","description":"","type":"buffer"}]}