{"ver":"0.1","info":{"id":"ldtGWl","date":"1472145100","viewed":3641,"name":"Temporal reprojection","username":"Raxvan","description":"This is a proof of concept for temporal re-projection. BufferB computes 4 AO samples per pixel and uses the previous frame (if possible) to accumulate result.The new samples can be briefly drawn with inverted colors. You can use MOUSE to control rotation!","likes":47,"published":1,"flags":32,"usePreview":0,"tags":["reprojectionraytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\t\n//thanks to https://www.shadertoy.com/view/4ssXRX for noise functions\n//and https://www.shadertoy.com/view/ll2GD3 for colors\n\n#define COLOR 0 /*0,1,2*/\n\n//#define SHOW_NEW_PIXELS\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 b = texture(iChannel1,uv);\n   \n    vec3 color = vec3(0.0);\n    float ramp;\n    float flip = 0.0;\n    \n    if(b.x > -0.5)\n    {\n        ramp = pow(b.y / b.z,1.0 / 2.2);\n        flip = b.a;\n    }\n    else\n    {\n        ramp = pow(dot(b.yzw,vec3(1.0)) / 3.0,1.0/2.2);\n    }\n    \n    #if COLOR == 0\n    \tcolor = pal( ramp, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    #elif COLOR == 1\n    \tcolor = pal( ramp, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    #elif COLOR == 2\n    \tcolor = pal( ramp, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    #endif\n   \n    #ifdef SHOW_NEW_PIXELS\n   \t\tcolor = mix(color, vec3(1.0) - color,flip);//show new pixels\n    #endif\n    \n    fragColor = vec4(color,1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//handles camera position and direction\n\n#define CAMERA_ROTATION\n\nfloat isTexel( vec2 coord, vec2 pos ) { vec2 d = abs(coord - pos - 0.5); return 0.5 - max(d.x,d.y); }\nvec4 get( in vec2 position )\n{\n    vec2 uv = (position + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel0, uv, -256.0 );\n}\nvoid write( in vec4 value, in vec2 position, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isTexel(fragCoord,position ) > 0.0 ) ? value : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0.0);\n    }\n    else if(fragCoord.y > 5.0)\n    {\n    \tdiscard;\n    }\n    else\n    {\n    \tvec2 pixel_size = vec2(1.0) / iChannelResolution[0].xy;\n        \n        float rot;\n        float height;\n        \n       \trot = iMouse.x * 20.0 / iChannelResolution[0].x;\n       \theight = iMouse.y * 5.0 / iChannelResolution[0].y - 1.0;\n        \n        \n        if(iMouse.z < 0.5)\n        {\n        #ifdef CAMERA_ROTATION\n          \trot = -(iTime - 7.0) * 0.2;\n          \theight = 0.5;\n        #endif\n        }\n        \n        \n        vec3 camera_position = vec3(cos(rot),sin(rot),height) * 20.0;\n    \tvec3 camera_target = vec3(0.0,0.0,0.0);\n        \n        //save state:\n        vec3 camera_position_old = get(vec2(0.0,0.0)).xyz;\n    \tvec3 camera_target_old = get(vec2(0.0,1.0)).xyz;\n        \n        //store new position\n        write(vec4(camera_position,0.0),vec2(0.0,0.0),fragColor,fragCoord);\n        write(vec4(camera_target,0.0),vec2(0.0,1.0),fragColor,fragCoord);\n        \n        //store old position\n        write(vec4(camera_position_old,0.0),vec2(1.0,0.0),fragColor,fragCoord);\n        write(vec4(camera_target_old,0.0),vec2(1.0,1.0),fragColor,fragCoord);\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//computes ambient occlusion ammount on the scene;\n\n//RETURNS:\n//distance to intersection point; if < 0 -> no intersection\n//ambient occlusion ammount; >= 0\n//acctumulation count; >= 0\n//flag for pixels that are new;\n\n//left hand coord system\n//z-up\n\n//thanks to https://www.shadertoy.com/view/4ssXRX\n\n#define NEAR 2.0\n#define INF 1000.0\n#define MPI 3.1415926\n\n#define REPROJ_DELTA 0.01\n#define SAMPLE_COUNT 4.0\n\nstruct ray\n{\n    vec3 point;\n    vec3 dir;\n};\n\nstruct intersection_info\n{\n    vec3 \tpos_ws;\n    vec3 \tnormal_ws;\n    vec2 \tdist_id;//if dist_id.y < 0.0 -> intersection is invalid; or if dist_id.x > FAR\n};\n    \nray screen_space_to_world_space(vec3 camera_position,vec3 camera_target,vec2 uv)\n{\n    vec3 camera_dir = normalize(camera_target - camera_position);\n\tvec3 view_right = normalize(cross(vec3(0.0,0.0,1.0),camera_dir));\n    vec3 view_up = cross(camera_dir,view_right);\n    \n    ray r;\n    r.point = camera_position;\n    r.dir = normalize(camera_dir * NEAR + view_right * uv.x + view_up * uv.y);\n    \n    return r;\n}\n\n//returns xy->uv > [-1..1] (with aspect), z < 0 if invalid\nvec3 world_space_to_screen_space(vec3 camera_position,vec3 camera_target,vec3 position_ws)\n{\n    vec3 to_point = position_ws - camera_position;\n    vec3 to_point_nrm = normalize(to_point);\n    \n    vec3 camera_dir = normalize(camera_target - camera_position);\n\tvec3 view_right = normalize(cross(vec3(0.0,0.0,1.0),camera_dir));\n    vec3 view_up = (cross(camera_dir,view_right));\n    \n    vec3 fwd = camera_dir * NEAR;\n    \n    float d = dot(camera_dir,to_point_nrm);\n    if(d < 0.01)\n        return vec3(0.0,0.0,-1.0);\n    \n    d = NEAR / d;\n    \n    to_point = to_point_nrm * d - fwd;\n    \n    float x = dot(to_point,view_right);\n    float y = dot(to_point,view_up);\n    return vec3(x,y,1.0);\n}\n\n//-------------------------------------------------------------------------------------------------------\n\nvec2 intersect_sphere(vec3 ro, vec3 rd, float radius)\n{\n    float sq_radius = radius * radius;\n    float\t\trtl = dot(ro,ro);\n    if ( rtl <= sq_radius )\n        return vec2(INF,-INF); //inside sphere\n    float\t\tca = - dot(ro,rd);\n    if ( ca < 0.0 )\n        return vec2(INF,-INF); //ray is directed away from the sphere\n    float\t\thc = sq_radius - rtl + ( ca * ca );\n    if ( hc < 0.0 )\n        return vec2(INF,-INF);\n    hc = sqrt(hc);\n    return vec2(ca - hc,ca + hc);\n}\nvec2 intersect_box(vec3 ro, vec3 rd,vec3 _min,vec3 _max)\n{\n    vec3 start = (_min - ro) / rd;\n    vec3 end = (_max - ro) / rd;\n    \n    vec3 a = min(start,end);\n    vec3 b = max(start,end);\n    \n    return vec2(\n        \tmax(a.x,max(a.y,a.z)),\n    \t\tmin(b.x,min(b.y,b.z))\n        );\n}\nvec3 box_normal_from_point(vec3 point,vec3 box_extents)\n{\n\tvec3 normal = vec3(0.0);\n\tfloat m = INF;\n\tfloat d;\n\n\td = abs(box_extents.x - abs(point.x));\n\tif (d < m)\n\t{\n\t\tm = d;\n\t\tnormal = vec3(1.0,0.0,0.0) * sign(point.x);    // Cardinal axis for X\n\t}\n\n\td = abs(box_extents.y - abs(point.y));\n\tif (d < m)\n\t{\n\t\tm = d;\n\t\tnormal = vec3(0.0,1.0,0.0) * sign(point.y);    // Cardinal axis for Y\n\t}\n\n\td = abs(box_extents.z - abs(point.z));\n\tif (d < m)\n\t{\n\t\tm = d;\n\t\tnormal = vec3(0.0,0.0,1.0) * sign(point.z);    // Cardinal axis for Z\n\t}\n\n\treturn normal;\n}\n//-------------------------------------------------------------------------------------------------------\n\nfloat intersect_sphere(inout intersection_info inf,float id, vec3 ro, vec3 rd,vec3 pos, float radius)\n{\n    vec2 d = intersect_sphere(ro - pos,rd,radius);\n    //intersection is closer and avoid self intersection:\n    if(d.x < d.y && d.x < inf.dist_id.x && abs(inf.dist_id.y - id) > 0.5)\n    {\n        inf.pos_ws = ro + rd * d.x;\n        inf.normal_ws = normalize(inf.pos_ws - pos);\n    \tinf.dist_id = vec2(d.x,id);\n        return 1.0;\n    }\n    return 0.0;\n}\nfloat intersect_box(inout intersection_info inf,float id, vec3 ro, vec3 rd,vec3 _min, vec3 _max)\n{\n    vec2 d = intersect_box(ro,rd,_min,_max);\n    if(d.x > d.y || d.x < 0.0)\n        return 0.0;\n    if(d.x < inf.dist_id.x && abs(inf.dist_id.y - id) > 0.5)\n    {\n        vec3 center = (_max + _min) / 2.0;\n        inf.pos_ws = ro + rd * d.x;\n        inf.normal_ws = box_normal_from_point(inf.pos_ws - center,_max - center);\n    \tinf.dist_id = vec2(d.x,id);\n        return 1.0;\n    }\n    return 0.0;\n}\n\n//intersect with scene\nintersection_info \tscene(ray r,float ignore_obj, float exit_value)\n{\n    intersection_info inf;\n    inf.dist_id = vec2(INF,ignore_obj);\n    \n    //spheres\n    if(intersect_sphere(inf,1.0,r.point,r.dir,vec3(-4.0,5.5,0.0),3.0) > exit_value) return inf;\n    if(intersect_sphere(inf,2.0,r.point,r.dir,vec3(-4.0,12.0,0.0),2.0) > exit_value) return inf;\n    \n    //boxes\n    if(intersect_box(inf,3.0,r.point,r.dir,vec3(-70.0),vec3(70.0,70.0,-2.0)) > exit_value) return inf;\n    if(intersect_box(inf,4.0,r.point,r.dir,vec3(-3.0,-4.0,-2.0),vec3(2.0,2.0,5.0)) > exit_value) return inf;\n    if(intersect_box(inf,5.0,r.point,r.dir,vec3(-4.2,-3.5,1.0),vec3(-3.0,-2.5,4.0)) > exit_value) return inf;\n    if(intersect_box(inf,6.0,r.point,r.dir,vec3(-3.0,2.0,-4.0),vec3(-2.0,3.5,0.0)) > exit_value) return inf;\n    \n    if(intersect_box(inf,7.0,r.point,r.dir,vec3(7.0,4.0,-4.0),vec3(9.0,9.0,1.0)) > exit_value) return inf;\n    if(intersect_box(inf,8.0,r.point,r.dir,vec3(7.0,-4.0,-1.5),vec3(12.0,0.0,2.0)) > exit_value) return inf;\n    \n    if(intersect_box(inf,9.0,r.point,r.dir,vec3(12.0,12.0,-4.0),vec3(13.0,13.0,10.0)) > exit_value) return inf;\n    \n    if(intersect_box(inf,10.0,r.point,r.dir,vec3(-30.0,-30.0,-4.0),vec3(30.0,-13.0,5.0)) > exit_value) return inf;\n    \n    \n    \n    return inf;\n}\n\n//-------------------------------------------------------------------------------------------------------\n//some random stuff\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nfloat n1rand( vec2 n )\n{\n\tfloat t = fract( iTime );\n\tfloat nrnd0 = nrand( n + 0.07*t );\n\treturn nrnd0;\n}\nvec2 vec2_n1rand( vec2 n , float offset)\n{\n\tfloat t = fract( iTime ) + offset;\n\tfloat nrnd0 = nrand( n + 0.07 * t );\n    float nrnd1 = nrand( n + 0.075 * (t + 1.0) );\n\treturn vec2(nrnd0,nrnd1);\n}\nvec3 random_sphere_direction(vec2 random_value)\n{\n\tfloat s = random_value.x * MPI * 2.0;\n\tfloat t = random_value.y * 2.0 - 1.0;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 random_hemisphere_direction(vec3 dir,vec2 random_value)\n{\n\tvec3 v = random_sphere_direction(random_value);\n\treturn v * sign(dot(v, dir));\n}\n\n//-------------------------------------------------------------------------------------------------------\n//data reads\nfloat isTexel( vec2 coord, vec2 pos ) { vec2 d = abs(coord - pos - 0.5); return 0.5 - max(d.x,d.y); }\nvec4 get( in vec2 position )\n{\n    vec2 uv = (position + 0.5) / iChannelResolution[0].xy;\n    return texture( iChannel0, uv, -256.0 );\n}\n\n//-------------------------------------------------------------------------------------------------------\n\nfloat \tcompute_ao(intersection_info i,vec2 uv)\n{\n    float ao = 0.0;\n    const float count = SAMPLE_COUNT;\n\n    ray r;\n    r.point = i.pos_ws - i.normal_ws * 0.02;\n\n    for(float x = 0.0; x < count; x += 1.0)\n    {\n        r.dir = random_hemisphere_direction(i.normal_ws,vec2_n1rand(uv,x));\n        intersection_info j = scene(r, i.dist_id.y,0.5);\n        if(abs(j.dist_id.y - i.dist_id.y) > 0.5)\n        {\n            ao += 1.0;\n        }\n    }\n\n    ao /= count;\n\n    return (1.0 - ao);\n}\n\n//-------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    uv = uv * 2.0 - 1.0;\n\t\n    uv.x *= aspect;\n    \n    //uv.x -> [-1;1] * aspect ratio;\n    //uv.y -> [-1;1]\n  \n    //read from bufferA\n    vec3 camera_position = get(vec2(0.0,0.0)).xyz;\n    vec3 camera_target = get(vec2(0.0,1.0)).xyz;\n    \n    vec3 old_camera_position = get(vec2(1.0,0.0)).xyz;\n    vec3 old_camera_target = get(vec2(1.0,1.0)).xyz;\n    \n    //compute current ray:\n    ray r = screen_space_to_world_space(camera_position,camera_target,uv);\n\n    vec4 frame = vec4(0.0);\n\t//intersect scene and compute AO:\n    intersection_info i = scene(r, -1.0,1.5);\n    if(i.dist_id.y > -0.5)\n    {\n        frame.x = i.dist_id.x;\n        frame.y = compute_ao(i,uv);\n        frame.z = 1.0;\n        \n        //try to accumulate samples by reprojection:\n        vec3 reproj_uv = world_space_to_screen_space(old_camera_position,old_camera_target,i.pos_ws);\n        vec2 reproj_uv01 = reproj_uv.xy;\n        reproj_uv01.x /= aspect;\n        reproj_uv01 = reproj_uv01 * 0.5 + 0.5;\n        \n        if(\treproj_uv01.x > 0.0 && reproj_uv01.x < 1.0 && \n           \treproj_uv01.y > 0.0 && reproj_uv01.y < 1.0 &&\n\t\t\treproj_uv.z > -0.5\n          )\n        {\n            //we are using old viewport \n            vec4 old_pixel = texture(iChannel1,reproj_uv01);\n            if(old_pixel.x > 0.0)\n            {\n            \tray oldray = screen_space_to_world_space(old_camera_position,old_camera_target,reproj_uv.xy);\n            \tvec3 old_pos_ws = oldray.point + oldray.dir * old_pixel.x;\n                \n                float ofs = length(old_pos_ws - i.pos_ws);\n                if(ofs < REPROJ_DELTA)\n                {\n                    frame.y += old_pixel.y; //accumulate ao\n                    frame.z += old_pixel.z; //add weight\n                    \n                }\n                frame.w = ofs;\n\t\t\t}\n        }\n        \n    }\n    else\n    {\n        frame.x = -1.0;\n        frame.yzw = texture(iChannel2,r.dir).rgb;\n    }\n   \n        \n    \n\tfragColor = frame;\n    \n}","name":"Buf B","description":"","type":"buffer"}]}