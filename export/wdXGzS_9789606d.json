{"ver":"0.1","info":{"id":"wdXGzS","date":"1546629928","viewed":290,"name":"Broccoland","username":"dirkadirkadan","description":"Broccoli fractal on stone. Froccoli, perhaps?","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["fractal","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texture(iChannel0, uv);\n    fragColor = tex;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPS .01\n#define SAMPLES 1.\n#define MAX_DISTANCE 30.\n#define LIGHT_INTENSITY 2.\n#define LIGHT_COLOR vec3(1., 1., .9997)\n#define STEP .599\n\nvec3 ldir = normalize (vec3(-.1, -.3, .2));\nvec3 amb = vec3(.0);\n\n#define ITERATIONS 180\n\n#define FLOOR   \t\t2\n#define FLORETS \t\t3\n\nint matid;\n\nfloat dist_test(float current_min_dist, float test_distance, int mat)\n{\n    float d = current_min_dist;\n    \n    if (test_distance < current_min_dist)\n    {\n        d = test_distance;\n        matid = mat;\n    }\n    \n    return d;\n\n}\n\n\nmat3 material(vec3 p)\n{\n    mat3 m;\n    \n    m[0] = vec3(1.);\n    m[1].x = 0.;\n    m[1].y = 1.;\n        \n    if (matid == FLOOR)\n    {\n        m[0] = texture(iChannel0, .9*p.xz).rgb;\n        m[1].x = .18;\n        m[1].x = .3590099760925;\n        m[1].y = .25000412293199;\n    }\n        \n    else if (matid == FLORETS)\n    {\n        vec3 green = vec3(0., .7, 0.);\n        vec3 cray = clamp(vec3(sin(p.z+p.x), cos(p.z*3.), sin(p.y*p.z)), .0, 1.);\n        m[0] = mix(green, cray, clamp(sin(8.2*(p.x+p.y)), .0, 1.));\n        m[1].x = 0.;\n        m[1].y = .4999006;\n    }\n    \n    return m;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat de(vec3 z)\n{\n    float flr = z.y + .3 - texture(iChannel0, .9*z.xz).b*.005;\n    float rep = 2.0;\n    z.xz = mod(z.xz, rep) - .5*rep;\n\n    float Scale = 2.0;\n\tfloat Offset = .93;\n\n\tfloat th = sin(.6*171.45);\n\tfloat ct = cos(th);\n\tfloat st = sin(th);\n\tmat3 rot = mat3(ct, 0., st, 0., 1., 0., -st, 0., ct);\n\t\n    float r;\n    int n = 0;\n    while (n < 8) {\n\t   z = rot * z;\n        // Folding concept from http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\n       if(z.x+z.y<0.) z.xy = -z.yx;\n       if(z.x+z.z<0.) z.xz = -z.zx;\n       if(z.y+z.z<0.) z.zy = -z.yz;\t\n       z = z*Scale - Offset*(Scale-1.0);\n       n++;\n    }\n       \n    float tri = (length(z) ) * pow(Scale, -float(n));\n\n    float d = 10000.;\n    d = dist_test(d, tri, FLORETS);\n    d = dist_test(d, flr, FLOOR);\n\n    return d;\n}\n\nvec3 norm(vec3 p)\n{\n    float d = de(p);\n    \n    float x = de(vec3(p.x+EPS, p.y, p.z)) - d;\n    float y = de(vec3(p.x, p.y+EPS, p.z)) - d;\n    float z = de(vec3(p.x, p.y, p.z+EPS)) - d;\n\n    return normalize(vec3(x,y,z));\n}\n\n\nvec2 hash2( const float n ) {\n\treturn fract(sin(vec2(n,n+1.))*vec2(43758.5453123));\n}\nvec2 hash2( const vec2 n ) {\n\treturn fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(25.1459123,312.3490423));\n}\nvec3 hash3( const vec2 n ) {\n\treturn fract(sin(vec3(n.x, n.y, n+2.0))*vec3(36.5453123,43.1459123,11234.3490423));\n}\n\n\nvec2 rv2;\n\n\n#ifndef M_PI\n#define M_PI                (3.1415926535897932384626433832795)\n#endif\n\nvec2 seed;\n\nvec2 rand2n() {\n    seed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\tfract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n \nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getSampleBiased(vec3  dir, float power) {\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = rand2n();\n\tr.x=r.x*2.*M_PI;\n\tr.y=pow(r.y,1.0/(power+1.0));\n\tfloat oneminus = sqrt(1.0-r.y*r.y);\n\treturn cos(r.x)*oneminus*o1+sin(r.x)*oneminus*o2+r.y*dir;\n}\n \nvec3 getSample(vec3 dir) {\n\treturn getSampleBiased(dir,0.0); // <- unbiased!\n}\n\nvec3 bounce(vec3 rd, vec3 nrm, mat3 material)\n{\n    float reflectance = material[1].x;\n   \n    rd = reflect(rd,nrm);\n    rd = reflectance*rd + (1.-reflectance)*getSample(nrm);\n    rd = normalize(rd);\n \n    return rd;\n    return reflect(rd, nrm);\n}\n\nvoid march(vec3 ro, vec3 rd, vec2 uv, out vec3 col)\n{\n    vec3 orig_ro = ro;\n    float d = 0.;\n    \n    bool hit = false;\n    vec3 pt = orig_ro;\n\n    vec3 lo = vec3(0.);\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        pt = ro + rd * d;\n        \n        float s = de(pt);        \n        d += STEP*s;\n        \n        if (s < EPS)\n        {\n            if (!hit) lo = LIGHT_INTENSITY * LIGHT_COLOR; hit = true;           \n            mat3 mat = material(pt);            \n            vec3 n = norm(pt);            \n            lo *= lo * 2. * mat[1].y * mat[0];\n            rd = bounce(rd, n, mat);\n\n            lo *= dot(n, rd);\n            \n            ro = pt;\n            d = EPS*2.;\n        }\n        \n        if (s > MAX_DISTANCE)\n        {\n            break;\n        }\n    }\n    \n    float mr = 1.;\n    vec3 sky = vec3(mr, clamp(sqrt(uv.y+.3), 0.4, mr), 1.);\n    vec3 fogclr = vec3(.6);\n                           \n    col = hit ? clamp(amb+lo*clamp(dot(ldir,-rd),0.,1.)*1.,0.,1.) : sky;\n    float final_dist = length(pt-orig_ro);\n    float fog = exp(-pow(final_dist,.2) * 5.12570555525052);\n    if (hit) col = mix(col, fogclr, fog);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    rv2 = hash2(iTime);\n  \n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float blur = .0;\n        \n    vec3 ro = vec3(.8, 0.3, 1.5);\n    vec3 rd = normalize(vec3(uv*(1.-blur)+rv2*blur, -1.));\n\n    vec3 acc = vec3(0.);\n    \n    vec3 prev_col = vec3(0.);\n    \n    float th = -texture(iChannel1, vec2(0.)).x*9.5;\n    float ct = cos(th);\n    float st = sin(th);\n    mat2 rot = mat2(ct, -st, st, ct);\n    rd.xz = rot * rd.xz;\n    \n    for (int i = 0; i < int(SAMPLES); i++)\n    {\n        prev_col = col;\n\t    seed = uv * (float(i) + iTime + 1.0);\n\t    rv2 = hash2(iTime+float(i)*rv2);\n        march(ro, rd, uv, col);\n\t\tacc += max(prev_col, col);\n    }\n    \n    acc /= SAMPLES;\n\n    fragColor = vec4(acc,0.);\n//    fragColor = vec4(texture(iChannel1, vec2(0.)).z/200.);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    float f = clamp(iTime, 1.0, 200.);\n    vec2 old_mouse = texture(iChannel0, vec2(0.)).xy;\n    if (length(old_mouse - m) > .02) f = 1.;\n    vec4 d = vec4(m, f, -7.);\n    fragColor = d;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//#define SAMPLING clamp(float(iTime)*1.,3.,200.)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat SAMPLING = texture(iChannel2, vec2(2.)).z;\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float weight = 1./SAMPLING;\n    vec4 tex = weight*texture(iChannel0, uv)+(1.-weight)*texture(iChannel1,uv);\n    fragColor = tex;\n}","name":"Buffer C","description":"","type":"buffer"}]}