{"ver":"0.1","info":{"id":"Ms33z8","date":"1448001800","viewed":234,"name":"Basic reusable circle","username":"sepehr","description":"Just a super simple reusable circle function","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["basic","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*!\n * @fn\t\t\tcircle\n * @brief\t\tDraws an anti-aliased circle\n * @note\t\tBefore passing coordinates to this function, they must\n *\t\t\t\tbe device-normalized first. [0,0] at top-left of screen\n *\t\t\t\tand [AR,1] at bottom-right of screen where AR is Aspect Ratio.\n * @param[in]\tcenter\t\tCenter of the circle, must be normalized\n * @param[in]\tradius\t\tRadius of the circle, must be normalized\n * @param[in]\tuv\t\t\tCurrent frag position, must be normalized\n * @param[in]\tsmoothness\tSmoothness factor at circle's edges\n * @param[in]\tcolor\t\tColor of the circle\n * @param[out]\tcolorOut\tOutput color (usually fragColor)\n *\n * @details\n *\n * This is how it works:\n * 1) We get the distance of the current frag from the circle center\n * 2) We clamp the distance in the range [Radius, Radius + Smoothness]\n * 3) We subtract Radius from the clamped distance so we have it in [0, Smoothness]\n * 4) We divide the remapped clamped distance by Smoothness so we have it in [0, 1]\n * 5) We linearly interpolate between the circle color and frag color based on that\n * Output:\n * After (5) if the frag is at Radius + Smoothness or outside of it, frag color   -\n * - ratains its value. If frag is inside Radius then full circle color would get -\n * - assigned to it. Otherwise based on distance, frag would get an interpolated  -\n * - color assigned (interpolated between frag's current color and circle color).\n */\nvoid circle(\n    in vec2\t\tcenter,\n    in float\tradius,\n    in vec2\t\tuv,\n    in float\tsmoothness,\n    in vec4\t\tcolor,\n    inout vec4\tcolorOut)\n{\n    colorOut = mix( color, colorOut,\n\t((\n        clamp\n        (\n            length( uv - center ),\n            radius,\n            radius + smoothness ) - radius\n        \n    \t) / smoothness\n    ));\n}\n\n/*************************** sample usage ***************************/\n\nconst vec4 foreground \t= vec4(.9, .81, .54, 1.);\nconst vec4 background \t= vec4(.7, .41, .41, 1.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = background;\n    \n    vec2 \tar\t\t= vec2( iResolution.x / iResolution.y, 1.),\n\t\t\tuv\t\t= ( fragCoord / iResolution.xy ) * ar,\n        \tcenter\t= vec2( .5, .5 ) * ar;\n    float\tradius\t= .2,\n        \tsmoothi\t= .002;\n    \n    circle( center, radius, uv, smoothi, foreground, fragColor );\n}","name":"","description":"","type":"image"}]}