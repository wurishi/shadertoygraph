{"ver":"0.1","info":{"id":"dddyDB","date":"1695443915","viewed":163,"name":"rayTracing reflect refractshadow","username":"linround","description":"https://three.ucalendar.cn/light","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3dshadowrefractreflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define TWO_PI 6.28318530718\n#define PI 3.1415926\n#define TMIN     0.1\n#define TMAX     3000.0\n\n#define ID_NONE           -1.0\n#define ID_FLOOR           0.10\n#define ID_CEILING         0.11\n#define ID_WALL_BACK       0.12\n#define ID_WALL_RIGHT      0.13\n#define ID_WALL_LEFT       0.14\n#define ID_LIGHT           0.15\n#define ID_SPHERE_REFRACT  0.16\n#define ID_SPHERE_REFLECT  0.17\n#define ID_VOID            1.0\n\n#define GLASS_REFRACTION_INDEX    1.5\n\nconst float boxSize = 400.;\n// http://www.graphics.cornell.edu/o nline/box/data.html\nconst vec4 FLOOR          = vec4(boxSize, 0.0, boxSize, ID_FLOOR);// 定义地板的宽度 高度 深度\nconst vec4 CEILING        = vec4(boxSize, 0.0, boxSize, ID_CEILING);// 定义天花板的宽度 高度 深度\n\nconst vec4 WALL_BACK      = vec4(boxSize, boxSize, 0.0, ID_WALL_BACK);// 定义后墙的宽度 高度 深度\n\nconst vec4 WALL_RIGHT     = vec4(0.0, boxSize,boxSize, ID_WALL_RIGHT);// 定义右墙的宽度 高度 深度\nconst vec4 WALL_LEFT      = vec4(0.0,boxSize, boxSize, ID_WALL_LEFT);// 定义左墙的宽度 高度 深度\n\nconst vec4 LIGHT          = vec4(boxSize/10., boxSize/50., boxSize/10., ID_LIGHT);// 定义灯的宽度 高度 深度\nconst vec4 SPHERE_REFRACT = vec4(boxSize/10., 0.0, 0.0, ID_SPHERE_REFRACT);// 折射球 半径\nconst vec4 SPHERE_REFLECT = vec4(boxSize/5., 0.0, 0.0, ID_SPHERE_REFLECT); // 反射球 半径\n\n\nconst vec3 FLOOR_CENTER = vec3(-boxSize/2.,-boxSize,-boxSize/2.);// 定义地板的中心\nconst vec3 CEILING_CENTER = vec3(-boxSize/2.,0,-boxSize/2.);// 定义天花板的中心\n\nconst vec3 WALL_BACK_CENTER = vec3(-boxSize/2.,-boxSize/2.,-boxSize);// 定义后墙 的中心\n\nconst vec3 WALL_RIGHT_CENTER = vec3(-boxSize,-boxSize/2.,-boxSize/2.);// 定义 右墙 的中心\nconst vec3 WALL_LEFT_CENTER = vec3(0.,-boxSize/2.,-boxSize/2.);// 定义左墙 的中心\n\nconst vec3 lightPos = vec3(-boxSize/2., 0.0, -boxSize/2.);// 定义 灯 的中心\nconst vec3 SPHERE_REFRACT_CENTER = vec3(\n    FLOOR_CENTER.x+FLOOR.x/4.,\n    FLOOR_CENTER.y+SPHERE_REFRACT.x,\n    FLOOR_CENTER.z+FLOOR.z/4.);// 定义折射球 的中心\nconst vec3 SPHERE_REFLECT_CENTER = vec3(\n    FLOOR_CENTER.x-FLOOR.x/16.,\n    FLOOR_CENTER.y+SPHERE_REFLECT.x,\n    FLOOR_CENTER.z-FLOOR.z/16.);// 定义反射球 的中心\n\nconst vec3 FLOOR_COLOR = vec3(0.5);// 地板的颜色\nconst vec3 CEILING_COLOR = vec3(1.,0.,1.);// 地板的颜色\nconst vec3 WALL_BACK_COLOR = vec3(0.,1.,0.);// 地板的颜色\nconst vec3 WALL_RIGHT_COLOR = vec3(1.,0.,0.);// 地板的颜色\nconst vec3 WALL_LEFT_COLOR = vec3(0.,0.,1.);// 地板的颜色\nconst vec3 LIGHT_COLOR = vec3(1.);// 地板的颜色\n\n// 定义观察点的坐标\nvec3 eye = vec3(-boxSize/2., -boxSize/2., boxSize*1.5);\nvec3 ta = vec3(-boxSize*2., -boxSize*2., -boxSize*2.);\nvec3 LIGHT_E = vec3(18.4, 15.6, 8.0);\n\nfloat sdBox(in vec3 p, in vec3 box) {\n    vec3 d = abs(p) - box;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\n//返回\n// res.x 存储投射到的物体ID\n// res.y 存储投射端点离 物体的距离\nvec2 intersectSpheres(in vec3 p, bool refrSph) {\n    // hit object ID is stored in res.x, distance to object is in res.y\n\n    // res.x 存储投射到的物体ID\n    // res.y 存储投射端点离 物体的距离\n    vec2 res = vec2(ID_VOID, 2000.0);\n\n    float mF = (sin(iTime)+1.)/2.+0.2;\n    float mR = (cos(iTime)+1.)/2.+0.2;\n    if (refrSph){\n        // 折射球\n        res = vec2(ID_SPHERE_REFRACT, sdSphere(p - SPHERE_REFRACT_CENTER*mF, SPHERE_REFRACT.x));\n    }\n    // 反射球\n    vec2 obj = vec2(ID_SPHERE_REFLECT, sdSphere(p - SPHERE_REFLECT_CENTER*mR, SPHERE_REFLECT.x));\n    if (obj.y < res.y) {\n        res = obj;\n    }\n\n    return res;\n}\n\n// p 是世界坐标系中的点，因为观察坐标系原点是eye的世界坐标系的坐标\n// 同时   p的坐标点是通过迭代的方式，一步步进行逼近物体的\n// 通过在观察坐标系中，从而来计算投影平面像素点上世界坐标系的坐标值\nvec2 intersect(in vec3 p, bool refrSph) {\n    // res.x 保存了光线投射到的物体ID\n    // res.y 保存了当前 投射端点离物体表面的距离\n\n\n    vec2 res = vec2(ID_VOID, 2000.0);\n\n    // 这里是计算灯管处的SDF盒子\n    vec2 obj = vec2(ID_LIGHT, sdBox(p - (lightPos), LIGHT.xyz));\n    if (obj.y < res.y) {\n        res = obj;\n    }\n\n    // 这里是计算地板处的SDF盒子\n    obj = vec2(ID_FLOOR, sdBox(p - FLOOR_CENTER, FLOOR.xyz));\n    if (obj.y < res.y) {\n        res = obj;\n    }\n    // 这里是计算天花板处的SDF盒子\n    obj = vec2(ID_CEILING, sdBox(p - CEILING_CENTER, CEILING.xyz));\n    if (obj.y < res.y){\n        res = obj;\n    }\n\n    // 这里是计算内墙壁的SDF盒子\n    obj = vec2(ID_WALL_BACK, sdBox(p - WALL_BACK_CENTER, WALL_BACK.xyz));\n    if (obj.y < res.y) {\n        res = obj;\n    }\n\n    // 这里是计算右墙的SDF盒子\n    obj = vec2(ID_WALL_RIGHT, sdBox(p - WALL_RIGHT_CENTER, WALL_RIGHT.xyz));\n    if (obj.y < res.y) {\n        res = obj;\n    }\n\n    // 这里是计算左墙的SDF盒子\n    obj = vec2(ID_WALL_LEFT, sdBox(p - WALL_LEFT_CENTER, WALL_LEFT.xyz));\n    if (obj.y < res.y) {\n        res = obj;\n    }\n\n    // 计算相交球体\n    obj = intersectSpheres(p, refrSph);\n    if (obj.y < res.y) {\n        res = obj;\n    }\n\n    return res;\n}\n\n// res.x 保存了光线投射到的物体ID\n// res.y 保存了当前 投射端点离物体表面的距离\n// p是世界坐标系中的某个点\nvec2 intersect(in vec3 p) {\n    return intersect(p, true);\n}\n\n// ro 是观察点在世界坐标系的坐标 即 eye\n// rd 即将像素点xy映射到 观察坐标系的 uv平面,坐标cu,cv\n// rd 定义了一个cw（即观察坐标系的z轴） 固定的投影平面\n// cw 方向 是观察点指向 目标的方向 即 target-eye\nvec2 raymarchScene(in vec3 ro, in vec3 rd, in float tmin, in float tmax, bool refrSph) {\n    vec3 res = vec3(ID_NONE);\n    float t = tmin;// tmin 默认值为0.1\n    for (int i = 0; i < 100; i++) {\n        // p 点 是从eye出发，沿着投影平面上的点的方向行进\n        // t 最开始是0.1，即行进的距离初始为0.1\n        // 这里的p是世界坐标系的坐标点\n        vec3 p = ro + rd * t;\n\n        // res.x 保存了光线投射到的物体ID\n        // res.y 保存了当前 投射端点离物体表面的距离\n        // res.z 保存了从观察坐标系原点出发，距离物体表面的距离\n        res = vec3(intersect(p, refrSph), t);\n        float d = res.y;\n        // 最终得到距离投射端点 小于dRange的物体对象\n        float dRange = 0.05;\n        if (d < dRange || t > tmax){\n            break;\n        }\n        t += d;\n    }\n    // 最终返回的是 投射到的对象的ID 以及观察点距离距离物体表面点的距离\n    return res.xz;\n}\n\n// 传入的是p点 即世界坐标系的某个点的坐标\nvec3 getNormal(in vec3 p) {\n    // 偏移值越小，就越接近该平面上的邻点，从而更准确的确定该点处的的变化速率和方向\n    vec2 eps = vec2(0.001, 0.0);\n    // 各轴偏移0.005\n    // 偏移后 计算投射端点距离表面的变化值 Δ\n    // 计算出在微小范围的偏移导致的 Δ，使用Δ来表示该点的法向量\n\n    // 对交点 p各轴偏移后，计算偏移之后的两个点之间距离\n    // 这里需要进行 正负偏移，进而确定该点处具体的偏移方向\n    // 然后求取各方向的变化速率即可\n    return normalize(vec3(\n        (intersect(p + eps.xyy).y - intersect(p - eps.xyy).y)/(2.0*eps.x),// 计算Δx\n        (intersect(p + eps.yxy).y - intersect(p - eps.yxy).y)/(2.0*eps.x), // 计算Δy\n        (intersect(p + eps.yyx).y - intersect(p - eps.yyx).y)/(2.0*eps.x) //计算Δz\n    ));\n}\n\nmat4 roateMat(in vec3 u,in float theta){\n    float c = cos(theta) ;\n    float s = sin(theta);\n    u = normalize(u);\n    // 以下是构建一个三维旋转矩阵的列\n    vec4 c0 = vec4(u.x*u.x*(1.0-c)+c,u.x*u.y*(1.-c)+u.z*s,u.x*u.z*(1.-c)-u.y*s,0.0);\n    vec4 c1 = vec4(u.x*u.y*(1.-c)-u.z*s,u.y*u.y*(1.-c)+c,u.y*u.z*(1.-c)+u.x*s,0.0);\n    vec4 c2 = vec4(u.z*u.x*(1.-c)+u.y*s,u.z*u.y*(1.-c)-u.x*s,u.z*u.z*(1.-c)+c,0.0);\n    vec4 c3 = vec4(0.,0.,0.,1.);\n    return mat4(c0,c1,c2,c3);\n}\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n// ro 是某个点的坐标\n// rd 是该点的法向量\n// 使用一个随机轴对法向量旋转，得到新的向量\nmat3 getTBN(in vec3 ro,in vec3 rd){\n    vec3 temp = vec3(random(rd.x),random(rd.y),random(rd.x));\n    temp = normalize(temp);\n    rd = normalize(rd);\n    vec3 tangent = cross(rd,temp);\n    tangent = normalize(tangent);\n    vec3 bitangent = cross(rd,tangent);\n    bitangent = normalize(bitangent);\n    return mat3(\n    tangent,bitangent,rd);\n}\n// 均匀的取16个方向点\nvec3[160] makeDirs(){\n    vec3[160] items;\n    float r = 1.0;\n    for(int i=0;i<16;i++){\n        for(int j=0;j<10;j++){\n            int index = i*16+j;\n            float phi = TWO_PI*float(i)/16.;\n            float theta = PI*float(j)/10.;\n            float z = r*sin(phi);\n            float x = r*cos(phi)*cos(theta);\n            float y = r*cos(phi)*sin(theta);\n            items[index] = vec3(x,y,z);\n        }\n    }\n    return items;\n}\nfloat tbnRenderAO(in vec3 ro, in vec3 rd) {\n    float ao = 0.0;\n    mat3 tbn = getTBN(ro,rd);\n    vec3[160] dirs = makeDirs();\n    float len = float(dirs.length());\n    for (float i = 0.0; i < len; i++) {\n        vec3 dir = dirs[int(i)];\n        vec3 temp = dir.x*tbn[0]+dir.y*tbn[1]+dir.z*tbn[2];\n        temp = normalize(temp);\n        vec2 obj = raymarchScene(ro, temp, TMIN, TMAX, true);\n        // 投射有击中物体\n        // 说明有遮蔽，那么ao加该分量的比例\n        if(obj.x ==ID_SPHERE_REFLECT ){\n            rd = normalize(rd);\n            float aspect = dot(rd,temp);\n            // 计算 光线和法线方向\n            float nd = dot(rd,lightPos-ro);\n            // 小于0是球面背光处，大于零需要计算\n            aspect = nd>0.?1.:aspect;\n            ao+=(1.0*aspect);\n        }\n\n    }\n    // ao 代表的是遮蔽的的情况\n    // ao 越大,遮蔽因子越大，环境光照分量越小\n    return 1.-ao/len;\n}\n\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float step = 8.;\n    float ao = 0.;\n    float dist;\n    int num = 4;\n    for (int i = 1; i <= num; i++) {\n        dist = step * float(i);\n        // 这里计算每一步投射时的距离，找到距离该投射线最近的 物体位置\n        // 当物体表面距离越靠近该投射线的投射端点，\n        // 此时每次一投射结果的距离 会影响该因子的大小\n        // 距离比投射距离 还大的就直接记为0\n        // 距离再投射范围内的 使用下面的算法来统计该因子的影响程度\n        float v = (dist - intersect(p + n * dist).y) / dist;\n        ao += max(0., v);\n    }\n    return 1. - ao /float(num);\n}\n// ro 反射线方向进行投射时的交点位置\n// rd 反射线方向进行投射时，交点处的法向量\n// tmin 统一使用 80\n\n// 环境光遮蔽计算\n// 主要通过构建从表面上一点 朝其法线所在上半球的所有方向发出射线，\n// 然后检查他们是否与其他对象相交来计算环境光遮蔽因子\n\n// 这个遮蔽因子 用来估算环境光照分量的大小，遮蔽因子越大，环境光照分量越小\n// 反之环境光越大。\n\n\n\n// https://zhuanlan.zhihu.com/p/484196734\n// http://frederikaalund.com/a-comparative-study-of-screen-space-ambient-occlusion-methods/\n// SSAO 的技术实现的关键步骤\n// 1.延迟\nfloat raymarchAO(in vec3 ro, in vec3 rd) {\n    return ambientOcclusion(ro,rd); // 普通的采样算法\n//    return tbnRenderAO(ro,rd); // 计算TBN，均匀采样\n}\n\n\n// ro 开始投射处的位置\n// rd 开始投射的方向\n// 点向光源投射 越近的距离被遮挡，那么该点光源影响就越小 越接近0\n// 越远击中 那么该点的光源影响就越接近1\n// 未被遮挡 那么光源影响因子就是 1\nfloat raymarchShadows(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 100; i++) {\n        // 一开始使用tmin的距离投射，计算最近的距离点d\n        // 叠加d再次进行投射 t的距离\n        vec3 p = ro + rd * t;\n\n        //\n        float d = intersectSpheres(p, true).y;\n\n        // 投射击中处越近\n        // d 投射的距离\n        // t 为累计投射n次时的距离 t会不断变大\n        // 如果有遮挡 t会变大，越来越接近某个距离值，而d会越接近0，此时 d/t 会很小，sh就会变得很小,说明光源在该点的影响因子很小\n        // 如果越近的遮挡 那么就会t很小，比如先 t=1.，此时正好 d= 0.001\n        // d/t 即为0.001\n        // 如果没有遮挡，d /t就相对会大一些，可能大于1\n        sh = min(sh,16.* d / t);\n        t += d;\n        // d 小于0.01 说明击中了物体\n        if (d < 0.001 || t > tmax)\n        break;\n    }\n    // 直接返回1阴影几乎没有\n    return sh;\n}\n\n// obj 返回的是 投射到的对象的ID 以及观察点距离距离物体表面点的距离\n// pos 投射的交点坐标\n// rd 投射的方向 可当作入射光\n// nor 投射交点处的法向量\n// 获取该点各种反射光的集合结果\nvec3 getLightColor(in vec2 obj, in vec3 pos, in vec3 rd, in vec3 nor) {\n    // 定义漫反射光\n    vec3 difColor = LIGHT_E;\n\n    // 顶部墙体部分\n    // 漫反射部分\n    float lightPosY = -100.;\n    vec3 lightDir = normalize(vec3(lightPos.x, lightPosY, lightPos.z) - pos);\n    float lightDist = length(vec3(lightPos.x, lightPosY, lightPos.z) - pos);\n    float dif = max(0.0, dot(nor, lightDir));// 这里利用法向量和光源方向的点积 模拟材质的属性（）\n    // 光源 产生的漫反射信息 lightDist 减少光点的能量\n    vec3 lightColor =   difColor *(1.0 / (lightDist))* dif;\n\n    // 镜面反射主要反射了光的效果\n    vec3 ks = vec3(0.25,0.31,0.32);// 镜面反射参数 根据材质决定反射能量的大小，\n    float specularEx = 4.;// 镜面反射参数：光滑表面的值较大，理想反射器的值时无限的（决定镜面光斑的大小，可提高视觉效果）\n    vec3 h = normalize(-rd + lightDir);// 求得半角向量\n    float spe = pow(max(dot(h, nor), 0.0), specularEx);\n    vec3 lightSpecular = ks * difColor* spe;\n    // 漫反射加上镜面反射\n    lightColor += lightSpecular;\n\n\n\n    // 天花板处的墙体指向光源\n    lightDir = normalize(vec3(lightPos.x, lightPosY, lightPos.z) - pos);\n    // 获得整个空间高度，从而设置最大阴影计算高度\n    // 追踪范围应该在光线下面，太大容易造成多面阴影\n    float height = (CEILING_CENTER.y - FLOOR_CENTER.y)*0.5;\n    // 计算光照在该点的影响因子，首次投射0.1，最多投射整个空间高度\n    float sha = clamp(raymarchShadows(pos, lightDir, 0.1, height), 0.0, 1.0);\n    float id = obj.x;\n    // 天花板和灯本身 不受到该因子影响\n    if (id != ID_LIGHT && id != ID_CEILING) lightColor *= sha;\n\n    // 后墙壁中心点 可以看作一个光源\n    // 光线方向 从投射位置指向后墙中心\n    lightDir = normalize(WALL_BACK_CENTER - pos);\n    lightDist = length(WALL_BACK_CENTER - pos);\n    dif = max(0.0, dot(nor, lightDir));// 这里利用法向量和光源方向的点积 模拟材质的属性（例如漫反射值）\n\n    lightColor += WALL_BACK_COLOR * dif  * (1.0 / lightDist);\n\n\n    // 后墙的镜面反射\n    h = normalize(-rd + lightDir);// 半角向量\n    spe = pow(clamp(dot(h, nor), 0.0, 1.0), specularEx);\n    lightColor += ks * WALL_BACK_COLOR* spe ;\n\n\n\n    // 右边墙壁发出的满发射光\n    lightDir = normalize(WALL_RIGHT_CENTER - pos);\n    lightDist = length(WALL_RIGHT_CENTER - pos);\n    dif = max(0.0, dot(nor, lightDir));// 这里利用法向量和光源方向的点积 模拟材质的属性（例如漫反射值）\n    // lightDist 减少光点的能量\n    lightColor += dif * WALL_RIGHT_COLOR * (1.0 / lightDist);\n\n    // 右墙的镜面反射\n    h = normalize(-rd + lightDir);// 半角向量\n    spe = pow(clamp(dot(h, nor), 0.0, 1.0), specularEx);\n    lightColor += ks * spe * WALL_RIGHT_COLOR;\n\n    // 左边墙壁的发射光\n    lightDir = normalize(WALL_LEFT_CENTER - pos);\n    lightDist = length(WALL_LEFT_CENTER - pos);\n    dif = max(0.0, dot(nor, lightDir));// 这里利用法向量和光源方向的点积 模拟材质的属性（例如漫反射值）\n    lightColor += dif * WALL_LEFT_COLOR * (1.0 / lightDist);\n\n    // 镜面反射\n    h = normalize(-rd + lightDir);// 半角向量\n    spe = pow(clamp(dot(h, nor), 0.0, 1.0), specularEx);\n    lightColor += ks * spe * WALL_LEFT_COLOR;\n\n    return lightColor;\n}\n\nvec3 getWallColor(in vec2 obj) {\n    vec3 color = vec3(0.0);\n    float id = obj.x;\n    if (id == ID_FLOOR) color = FLOOR_COLOR;// 地板的颜色\n    if (id == ID_CEILING) color = CEILING_COLOR;// 天花板的颜色\n    if (id == ID_WALL_BACK) color = WALL_BACK_COLOR;// 后墙的颜色\n    if (id == ID_WALL_RIGHT) color = WALL_RIGHT_COLOR;// 右墙的颜色\n    if (id == ID_WALL_LEFT) color = WALL_LEFT_COLOR;// 左墙的颜色\n    if (id == ID_LIGHT) color = LIGHT_COLOR;// 灯光box的颜色\n    return color;\n}\n\n// 盒子各处的颜色\n// 即盒子墙体的颜色\nvec3 getBoxColor(in vec2 obj, in vec3 pos, in vec3 rd, in vec3 nor) {\n    // 得到击中的物体颜色\n    vec3 color = getWallColor(obj);\n    // 计算该点击中处的遮蔽因子\n    // 这是每个墙体坐标点处的遮蔽因子\n    float occ = clamp(raymarchAO(pos, nor), 0.0, 1.0);\n    // 获取该点各种反射光的集合结果\n    // 这是 天花板墙体 左右墙体 后面墙体产生的漫反射和镜面反射的光源之和\n    color *= getLightColor(obj, pos, rd, nor) * occ;\n    return color;\n}\n\n// pos 首次投射的交点坐标\n// rd 首次投射的方向\n// nor 首次投射处的法向量\nvec3 getMirrorBallColor(in vec3 pos, in vec3 rd, in vec3 nor) {\n    // 首次投射击中镜面, 镜面直接发生反射\n    // 反射向量 refl\n    vec3 refl = reflect(rd, nor);\n    // 从首次集中镜面出的位置，对反射方向进行投射\n    // robj 包括了击中物体的ID和距离\n    vec2 robj = raymarchScene(pos, refl, TMIN, TMAX, true);\n    // 找到反射线击中物体的位置\n    vec3 rpos = pos + refl * robj.y;\n    // 得到该位置处的法线\n    vec3 rnor = getNormal(rpos);\n    // 得到反射线击中的物体的颜色\n    vec3 color = getWallColor(robj);\n    // 得到反射线击中物体位置处的光线遮蔽因子\n    float occ = clamp(raymarchAO(rpos, rnor), 0.0, 1.0);\n    // 反射击中的是折射球\n    // 重新计算经过折射后的的光线击中的颜色和 击中处的环境遮蔽因子\n    if (robj.x == ID_SPHERE_REFRACT) {\n        // refl 发射首次击中时的反射向量，可以认为是击中折射球的入射光线\n        // rnor 首次反射线 击中处的位置的法向量，即击中的折射球体处的法向量\n        // 折射球此时产生反射线\n        vec3 rrefl = reflect(refl, rnor);\n        vec2 reflObj = raymarchScene(rpos, rrefl, TMIN, TMAX, true);\n        vec3 reflPos = rpos + rrefl * reflObj.y;\n        vec3 reflNor = getNormal(reflPos);\n        float reflOcc = clamp(raymarchAO(reflPos, reflNor), 0.0, 1.0);\n\n        // 折射球此时产生折射线\n        vec3 refr = refract(refl, rnor, 1.0 / (GLASS_REFRACTION_INDEX * 2.0));\n        robj = raymarchScene(rpos, refr, TMIN, TMAX, false);\n        rpos = rpos + refr * robj.y;\n        //\n        rnor = getNormal(rpos);\n        color = getWallColor(robj);\n        float occ = clamp(raymarchAO(rpos, rnor), 0.0, 1.0);\n        color *= occ;\n\n        // 折射球处的颜色 以产生折射线击中的颜色为底色，反射线为目标色进行适配\n        color = mix(color, getWallColor(reflObj) * reflOcc, 0.02);\n    }\n    // getLightColor 获取该点各种反射光的集合结果\n    color *= getLightColor(robj, rpos, refl, rnor) * occ;\n\n    return color;\n}\n\n\n// 玻璃材质有折射和反射\n// 这里先计算了反射\n\n// pos 投射交点坐标\n// rd 观察坐标系中，观察平面像素点与观察点之间的投射方向，（x,y,1）\n// nor 交点处的表面法向量\nvec3 getGlassBallColor(in vec3 pos, in vec3 rd, in vec3 nor) {\n    // 玻璃面上的点的反射计算\n    // 这里求反射向量 rd是入射向量，nor该点的法线方向\n    vec3 refl = reflect(rd, nor);\n    // 这里以交点处为起点  从该点以 反射方向进行投射。\n    // 投射 最终返回的是 投射到的对象的ID 以及投射起始点距离物体表面点的距离\n    vec2 reflObj = raymarchScene(pos, refl, TMIN, TMAX, true); // 反射遇见的物体\n    // 计算出反射线从交点pos进行投射时交点处的坐标\n    vec3 reflPos = pos + refl * reflObj.y;\n    // 再次计算反射线投射时，交点处的法向量\n    vec3 reflNor = getNormal(reflPos);\n\n\n    // reflPos 反射线方向进行投射时的交点位置\n    // reflNor 反射线方向进行投射时，交点出的法向量\n    float reflOcc = clamp(raymarchAO(reflPos, reflNor), 0.0, 1.0);\n\n\n\n    // 玻璃面上的点的折射计算\n    // refract 根据入射向量，法向量，折射率的关系计算折射方向\n    vec3 refr = refract(rd, nor, 1.0 / GLASS_REFRACTION_INDEX);\n    // 计算折射光线在场景中的交点（不考虑折射球）\n    // 最终返回的是 投射到的对象的ID 以及观察点距离距离物体表面点的距离\n    vec2 robj = raymarchScene(pos, refr, TMIN, TMAX, false);\n    // 找到折射光线与物体相交的点\n    vec3 rpos = pos + refr * robj.y;\n    // 计算折射光线的交点处的法向量\n    vec3 rnor = getNormal(rpos);\n\n    // 得到该交点处的基本颜色\n    // getWallColor 得到的始终是物体的颜色；因为其传入的始终是光线与某个对象的相交信息\n    //\n    vec3 color = getWallColor(robj);\n    // raymarchAO是求像素点的光线遮蔽，得到环境光遮蔽因子\n    // 这是光线交点处的环境遮蔽因子\n    float occ = clamp(raymarchAO(rpos, rnor), 0.0, 1.0);\n\n    // 玻璃球实际是一个折射球\n    // 玻璃球的折射光线 投射击中了反射球\n    if (robj.x == ID_SPHERE_REFLECT) {\n        // refr 折射向量\n        // rnor 折射向量投射处的交点法向量\n        // 由于折射光线击中反射球\n        // rrefl 为再次计算的折射线集中反射球处的 反射向量\n        vec3 rrefl = reflect(refr, rnor);\n        // robj 折射光线交点处的反射光线 进行投射 相交的物体\n        // rpos 折射光线的起始位置\n        // rrefl 折射光线击中物体处 产生的反射光线\n        robj = raymarchScene(rpos, rrefl, TMIN, TMAX, true);\n\n        // 折射光线的反射 光线 集中场景中物体的位置\n        rpos = rpos + rrefl * robj.y;\n        // 计算该点的法向量\n        rnor = getNormal(rpos);\n\n        // 计算该点处的实际颜色\n        color = getWallColor(robj);\n        // 折射光线的反射光线集中了 折射球\n        if (robj.x == ID_SPHERE_REFRACT) {\n            // rrefl 折射光线集中的反射球处的反射向量\n            // rnor 折射光线击中处的反射光线 击中折射球的法向量\n            // rrefr 折射球产生的折射光线\n            vec3 rrefr = refract(rrefl, rnor, 1.0 / (GLASS_REFRACTION_INDEX * 2.0));\n            // 折射球此时产生的折射光线再次 击中物体\n            vec2 rrobj = raymarchScene(rpos, rrefr, TMIN, TMAX, false);\n            // 计算击中物体处的位置\n            vec3 rrpos = rpos + rrefr * rrobj.y;\n            // 集中处的位置的法向量\n            vec3 rrnor = getNormal(rrpos);\n            // 击中处的颜色\n            color = getWallColor(rrobj);\n            // 计算环境光遮蔽因子\n            float occ = clamp(raymarchAO(rrpos, rrnor), 0.0, 1.0);\n            color *= occ;\n        }\n        float occ = clamp(raymarchAO(rpos, rnor), 0.0, 1.0);\n        color *= occ;\n    }\n    vec3 reflColor = getWallColor(reflObj);\n    reflColor *= reflOcc;\n    // 因为场景中只有一个反射球\n    // 以下条件语句是否执行作用不大\n    if (reflObj.x == ID_SPHERE_REFLECT) {\n        vec3 rrefl = reflect(refl, reflNor);\n        reflObj = raymarchScene(reflPos, rrefl, TMIN, TMAX, true);\n        reflPos = reflPos + rrefl * reflObj.y;\n        reflNor = getNormal(reflPos);\n        reflColor = getWallColor(reflObj);\n        float occ = clamp(raymarchAO(reflPos, reflNor), 0.0, 1.0);\n        reflColor *= occ;\n    }\n\n    // getLightColor 获取该点各种反射光的集合结果\n    color *= getLightColor(robj, rpos, refr, rnor) * occ;\n    color = mix(color, reflColor, 0.5);\n\n    return color;\n}\n\n// obj 返回的是 投射到的对象的ID 以及观察点距离距离物体表面点的距离\n// pos 首次投射的交点坐标\n// rd 首次投射的方向 可当作入射光\n// nor 首次投射处的法向量\nvec3 getFloorColor(in vec2 obj, in vec3 pos, in vec3 rd, in vec3 nor) {\n    // obj 返回的是 投射到的对象的ID 以及观察点距离距离物体表面点的距离\n    // pos 首次投射的交点坐标\n    // rd 首次投射的方向 可当作入射光\n    // nor 首次投射处的法向量\n    // 地板也属于盒子的地方\n    // 但是需要考虑折射球\n    vec3 color = getBoxColor(obj, pos, rd, nor);\n\n    vec3 lightDir = normalize(lightPos - pos);\n    // 地板的坐标 需要向光点进行投射\n    vec2 robj = raymarchScene(pos, lightDir, TMIN, TMAX, true);\n    // 击中了反球\n    if (robj.x == ID_SPHERE_REFRACT) {\n        // 计算击中该反射球的位置\n        vec3 rpos = pos + lightDir * robj.y;\n        // 计算击中位置处的法向量\n        vec3 rnor = getNormal(rpos);\n        // 计算该点处的折射方向\n        vec3 refr = refract(lightDir, rnor, 1.0 / GLASS_REFRACTION_INDEX);\n        // 从击中点 沿着折射方向进行投射\n        robj = raymarchScene(rpos, refr, TMIN, TMAX, false);\n        // 找到折射 投射集中的位置\n        rpos = rpos + refr * robj.y;\n        // 获取该位置的法向量\n        rnor = getNormal(rpos);\n        // 如果该折射方向处击中的是光源\n        // 因为其他物体 在实际生活中 不会产生明显的阴影光斑效果\n        if (robj.x == ID_LIGHT) {\n            vec3 difColor = LIGHT_E;\n            // 计算地板处的遮蔽因子\n            float occ = clamp(raymarchAO(pos, nor), 0.0, 1.0);\n            // 得到 以地板为底色，目标色为光源的底色\n            color = mix(color, difColor * occ, 0.02);\n        }\n\n    }\n    return color;\n}\n\nmat3 roateX(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 c1 = vec3(1,0,0);\n    vec3 c2 = vec3(0,c,s);\n    vec3 c3 = vec3(0,-s,c);\n    return mat3(\n    c1,c2,c3\n    );\n}\n\nmat3 roateY(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 c1 = vec3(c,0,-s);\n    vec3 c2 = vec3(0,1,0);\n    vec3 c3 = vec3(s,0,c);\n    return mat3(\n    c1,c2,c3\n    );\n}\nmat3 roateZ(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n\n    vec3 c1 = vec3(c,s,0);\n    vec3 c2 = vec3(-s,c,0);\n    vec3 c3 = vec3(0,0,1);\n    return mat3(\n    c1,c2,c3\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 定义屏幕的宽度\n    float width = 2.;\n    // 转换坐标范围 到[-1,1]\n    vec2 p =  fragCoord.xy / iResolution.xy;\n    p.x*=iResolution.x/iResolution.y;\n\n\n//    eye.xyz *= roateX(iTime);\n    //    eye.xyz *= roateY(iTime);\n    //    eye.xyz *= roateY(iTime);\n\n    vec3 ro = eye;\n\n    // 观察点指向 目标物体 的方向向量\n    vec3 cw = normalize(ta - ro);\n    // 使用y轴作为向上的向量，求得垂直于 y轴和cw方向向量所称平面的 cu向量\n    // 得到 观察坐标系的三个基底， cw,y,cu\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, .0), cw));\n    // 重新吹顶y这个向量，使得 cw cv cu 是互相垂直的\n    // cw y cv 是共面的三个坐标向量（y可能不垂直cw，但是cv是垂直于cw的）\n    vec3 cv = normalize(cross(cw, cu));\n    // 最终得到新的由 cu cv cw 组成的互相垂直的基底所形成的坐标系\n    // cw 是观察点指向 目标的向量\n    // cu 垂直于 cw于y轴形成的平面\n    // cv 垂直于 cw于cu\n    // 观察坐标系的原点实际就是 观察点(即eye坐标点)\n    mat3 cam = mat3(cu, cv, cw);\n\n\n    // 眼睛指向目标位置 方向 cw 作为 观察坐标系的 z 轴\n    // 与y,cw共面的        cv 作为观察坐标系的 y 轴\n    // 垂直于cw,cv的       cu 作为观察坐标系的 x 轴\n    vec3 rd =   normalize(vec3(p.xy,1.))*cam;\n\n    // 背景色\n    vec3 color = vec3(0.);\n\n    // 首次投射\n    // 找到光线在场景中的交点物体\n    // ro 是观察点在世界坐标系中的坐标\n    // rd 的xy 平面实际就是 当前的像素平面，也就是观察坐标系的 cu,cv平面\n    // 最终返回的是 投射到的对象的ID 以及观察点距离距离物体表面点的距离\n    vec2 obj = raymarchScene(ro, rd, TMIN, TMAX, true);\n\n    // obj 是得到的最终投射到的物体对象\n    // obj.x 是该投射对象的物体ID\n    // obj.y 观察点距离距离物体表面点的距离\n    float id = obj.x;\n\n    // 击中了立方体内部的物体（包括墙体和内部物品）\n    if (id != ID_VOID) {\n        // t 是观察点距离对象表面的距离\n        float t = obj.y;\n        // 求得表面处点的坐标\n        // 观察点+距离*观察坐标系的基地\n        // pos 是表面点的在世界坐标系中的坐标点\n        // 且pos是某个物体表面与投射线的交点位置处\n        vec3 pos = ro + rd * t;\n        // 得到该交点处的法向量\n        vec3 nor = getNormal(pos);\n\n        // 折射球体是玻璃材质\n\n        // 判断\n        // 击中的是折射球\n        if (id == ID_SPHERE_REFRACT) {\n            // pos 交点坐标\n            // rd 观察坐标系中，观察平面像素点与观察点之间的投射方向\n            // nor 交点处的表面法向量\n            color = getGlassBallColor(pos, rd, nor); // 玻璃球 折射\n        }\n        // 击中的是反射球\n        else if (id == ID_SPHERE_REFLECT) {\n            // pos 首次投射的交点坐标\n            // rd 首次投射的方向\n            // nor 首次投射处的法向量\n            color = getMirrorBallColor(pos, rd, nor); // 镜面球 高光\n        }\n        // 首次投射击中的是地板\n        else if (id == ID_FLOOR) {\n            // obj 返回的是 投射到的对象的ID 以及观察点距离距离物体表面点的距离\n            // pos 首次投射的交点坐标\n            // rd 首次投射的方向 可当作入射光\n            // nor 首次投射处的法向量\n            color = getFloorColor(obj, pos, rd, nor); // 地面\n        }\n        else {\n            // obj 返回的是 投射到的对象的ID 以及观察点距离距离物体表面点的距离\n            // pos 首次投射的交点坐标\n            // rd 首次投射的方向 可当作入射光\n            // nor 首次投射处的法向量\n            // 获取对应墙体的颜色即可\n            color = getBoxColor(obj, pos, rd, nor); // 墙体\n        }\n    }\n\n    // gamma correction\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}