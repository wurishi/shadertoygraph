{"ver":"0.1","info":{"id":"WdKyzV","date":"1603263006","viewed":178,"name":"crystal.ex","username":"tijit","description":"blue crystal texture","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["tijit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/\n\nconst float GRID = 4.;\nconst float PI = 3.14159265;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat circle(in vec2 _st, in vec2 _circle, in float _radius) {\n    vec2 d = _circle - _st;\n    return step(dot(d, d), _radius * _radius);\n}\n\nfloat poly(in vec2 _st, in vec2 _poly, in float _rad) {\n    // polygon is 4 points on a circle\n    // _poly is coordinates of origin of polygon\n    vec4 _angles = vec4(random(_poly+vec2(.1)), random(_poly+vec2(.2)),\n                    random(_poly+vec2(.3)), random(_poly+vec2(.4)) );\n    float _total = _angles[0] + _angles[1] + _angles[2] + _angles[3];\n    _angles *= 2. * PI / _total;\n    \n    _angles[1] += _angles[0];\n    _angles[2] += _angles[1];\n    _angles[3] += _angles[2];\n    \n    vec4 _a2 = vec4(0.);\n    \n    vec2 _p0 = vec2(_poly.x+_rad*cos(_angles[0]), _poly.y+_rad*sin(_angles[0]));\n    vec2 _p1 = vec2(_poly.x+_rad*cos(_angles[1]), _poly.y+_rad*sin(_angles[1]));\n    vec2 _p2 = vec2(_poly.x+_rad*cos(_angles[2]), _poly.y+_rad*sin(_angles[2]));\n    vec2 _p3 = vec2(_poly.x+_rad*cos(_angles[3]), _poly.y+_rad*sin(_angles[3]));\n    \n    _a2[0] = atan(_p0.y-_st.y, _p0.x-_st.x); // cant assign these in a loop?\n    _a2[1] = atan(_p1.y-_st.y, _p1.x-_st.x);\n    _a2[2] = atan(_p2.y-_st.y, _p2.x-_st.x);\n    _a2[3] = atan(_p3.y-_st.y, _p3.x-_st.x);\n    \n    vec4 _a3 = _a2.gbar;\n    \n    float _ret = 1.;\n    \n    for (int _i = 0; _i < 4; _i++) {\n        float _aDiff = _a3[_i] - _a2[_i];\n        \n        _aDiff = mod(_aDiff + 2.*PI, 2.*PI);\n        \n        // if angle difference > 180 degrees then return 0\n        _ret *= step(_aDiff,PI);\n    }\n    \n    \n    return _ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / 8.;\n    \n    float shade = 0.;\n    \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    vec3 col = vec3(0.);\n    \n    for (float xx = -GRID; xx <= GRID; xx++) {\n        for (float yy = -GRID; yy <= GRID; yy++) {\n        \n            vec2 i2 = i+vec2(xx,yy);\n            \n            float merge = random(i2+vec2(-1000.));\n            vec3 _col = vec3(0.,merge,1.);\n            \n            float brightOff = random(i2+vec2(-2000.)) * 2. * PI;\n            float brightness = (1.+sin(iTime + brightOff))*.5;\n            brightness = brightness * brightness * brightness;\n            _col = (1.-brightness)*_col + brightness * vec3(1.);\n            \n            float rad = .5+(GRID-.5)*random(i2);\n            \n            float _a = .5 * poly(st, i2+vec2(.5), rad);\n            col = (1.-_a) * col + _a * _col;\n        }\n    }\n    \n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}