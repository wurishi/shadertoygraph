{"ver":"0.1","info":{"id":"DlSyDW","date":"1691755155","viewed":465,"name":"line cube","username":"linround","description":"lenarning","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2dcubelearn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.1415926\n#define TWO_PI 6.28318530718\n\n\nmat4 roateMat(in vec3 u,in float theta){\n    float c = cos(theta) ;\n    float s = sin(theta);\n    u = normalize(u);\n    // 以下是构建一个三维旋转矩阵的列\n    vec4 c0 = vec4(u.x*u.x*(1.0-c)+c,u.x*u.y*(1.-c)+u.z*s,u.x*u.z*(1.-c)-u.y*s,0.0);\n    vec4 c1 = vec4(u.x*u.y*(1.-c)-u.z*s,u.y*u.y*(1.-c)+c,u.y*u.z*(1.-c)+u.x*s,0.0);\n    vec4 c2 = vec4(u.z*u.x*(1.-c)+u.y*s,u.z*u.y*(1.-c)-u.x*s,u.z*u.z*(1.-c)+c,0.0);\n    vec4 c3 = vec4(0.,0.,0.,1.);\n    return mat4(c0,c1,c2,c3);\n}\n\n\n// 点的正交投影\nvec2 pointOrthographic(in vec3 point){\n    return vec2(point.x,point.y);\n}\n\n// 点的透视投影\nvec2 pointPerspective(vec3 point){\n    vec3 projectPoint = vec3(0.,0.,15.);\n    vec3 viewPlane = vec3(0.,0.,5.);\n\n    // 利用相似三角形原理\n    float aspect = (viewPlane.z - projectPoint.z)/(point.z-projectPoint.z);\n    float x = aspect * (point.x-projectPoint.x)+projectPoint.x;\n    float y = aspect * (point.y-projectPoint.y)+projectPoint.y;\n    return vec2(x,y);\n}\n\nfloat project(in vec3 p0,in vec3 p1,in vec2 uv){\n\n    vec2 pp0;\n    vec2 pp1;\n\n    // 点的正交投影\n    pp0 = pointOrthographic(p0);\n    pp1 = pointOrthographic(p1);\n    // 点的透视投影\n    pp0 = pointPerspective(p0);\n    pp1 = pointPerspective(p1);\n\n    vec2 dir = normalize(pp1.xy-pp0.xy); // 计算方向向量\n    float len = distance(pp1.xy,pp0.xy); // 计算向量长度\n    float cosTheta = dir.x;\n    float sinTheta = dir.y;\n\n\n    mat2 roate2D = mat2(\n    vec2(cosTheta,sinTheta),\n    vec2(-sinTheta,cosTheta)\n    );\n\n    vec2 roateVector = (uv-pp0.xy)*roate2D; // 旋转 -Θ 度。，然后比较在x轴上的距离;此时注意起点要以pp0(投影之后的p0)为起点。\n    float minx = clamp(roateVector.x,0.0,len); // 在线段内部\n    float d = distance(vec2(minx,0.0),roateVector);// 直接比较内部垂直点的距离\n    return smoothstep(0.1,0.0,d);\n}\n\n\nvec3 renderLineCube(in vec2 st){\n    float size = 3.0;\n    // 定义立方体的八个顶点\n    vec3 vertexCubes[8] = vec3[](\n    vec3(1.,1.,1.),\n    vec3(-1.,1.,1.),\n    vec3(-1.,1.,-1.),\n    vec3(1.,1.,-1.),\n    vec3(1.,-1.,-1.),\n    vec3(1.,-1.,1.),\n    vec3(-1.,-1.,1.),\n    vec3(-1.,-1.,-1.)\n    );\n    vec3 color = vec3(0.,0.,0.);\n    vec3 lineColor = vec3(0.0,1.0,1.0);\n    float pct = 0.0;\n    mat4 roate = roateMat(vec3(1,1,1),iTime);\n\n    for(int i=0;i<8;i++){\n        vertexCubes[i] =(roate*vec4(vertexCubes[i]*size,0.0)).xyz;\n    }\n\n\n    pct+=project(vertexCubes[0],vertexCubes[1],st);\n    pct+=project(vertexCubes[1],vertexCubes[2],st);\n    pct+=project(vertexCubes[2],vertexCubes[3],st);\n    pct+=project(vertexCubes[3],vertexCubes[0],st);\n//\n//\n    pct+=project(vertexCubes[0],vertexCubes[5],st);\n    pct+=project(vertexCubes[1],vertexCubes[6],st);\n    pct+=project(vertexCubes[2],vertexCubes[7],st);\n    pct+=project(vertexCubes[3],vertexCubes[4],st);\n//\n//\n    pct+=project(vertexCubes[5],vertexCubes[6],st);\n    pct+=project(vertexCubes[6],vertexCubes[7],st);\n    pct+=project(vertexCubes[7],vertexCubes[4],st);\n    pct+=project(vertexCubes[4],vertexCubes[5],st);\n\n\n    color = mix(color,lineColor,pct);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 st =  (2.*fragCoord.xy - iResolution.xy)/iResolution.y;\n    // 将范围转换为[-1,1]\n    st = (st*2.0)-1.0;\n    // 将范围转换为[-10,10]\n    st*=3.0;\n    vec3 color = renderLineCube(st);\n    fragColor = vec4(color,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}