{"ver":"0.1","info":{"id":"fd2fzG","date":"1646545970","viewed":155,"name":"Doom 1993 melt effect","username":"sleeps_darkly","description":"a bit cheap implementation of a melt effect using a precalculated M_Random offset table; see original here: https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/m_random.c\nhttps://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/f_wipe.c","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["effect","doom","loading","melt","pixellation"],"hasliked":0,"parentid":"fsSfRG","parentname":"doom melt"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The easiest explanation of original Melt is here: \n// https://www.youtube.com/watch?v=lUsCXSNhHmI \n\n// Precalculated offset table using original DOOM's M_Random()\n// Random in DOOM 1993 is deterministic, and this array\n// replicates the offsets calculated for the \"New Game\" melt effect\n// which always begins from 0 in original M_Random\n// so we're precalculating and hardcoding it here \n// because it's resource intensive to calculate in a loop.\n// See lines 159-166 in https://github.com/id-Software/DOOM/blob/master/linuxdoom-1.10/f_wipe.c\n// this is the result of that.\n\n// Keep in mind that it also possibly puts a lot of VGPR pressure\nconst int offsetTable[320] = int[320](\n    -8, -8, -8, -9, -9, -8, -7, -8, -7, -6, -5, -5, -6, -5, -6, -6, -5, -4, -3, -3, -4, -4, -3, -2, -1, 0, -1, 0, 0, 0, -1, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, -1, 0, 0, -1, -2, -1, -2, -3, -4, -4, -5, -6, -5, -5, -6, -7, -7, -6, -6, -5, -5, -6, -6, -5, -5, -5, -6, -7, -6, -6, -6, -5, -4, -4, -5, -4, -5, -5, -6, -5, -4, -3, -3, -2, -2, -1, 0, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, -2, -2, -3, -2, -1, -2, -1, -2, -2, -2, -1, 0, 0, 0, 0, -1, -1, -2, -1, -2, -1, -2, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, -1, -2, -3, -4, -4, -4, -3, -3, -3, -3, -3, -4, -4, -3, -4, -5, -5, -6, -6, -5, -6, -6, -7, -6, -5, -5, -4, -5, -4, -4, -5, -6, -7, -8, -9, -8, -9, -10, -9, -9, -9, -10, -9, -8, -8, -9, -9, -8, -8, -9, -8, -8, -8, -7, -6, -5, -6, -7, -8, -8, -9, -8, -8, -9, -8, -7, -8, -7, -7, -7, -8, -8, -8, -8, -7, -8, -8, -9, -10, -9, -9, -8, -7, -6, -6, -7, -7, -6, -6, -6, -7, -7, -8, -8, -8, -9, -9, -8, -9, -10, -9, -9, -9, -10, -10, -9, -8, -9, -8, -7, -6, -6, -7, -6, -7, -7, -6, -5, -4, -4, -5, -5, -4, -3, -2, -1, -2, -1, 0, 0, -1, 0, 0, 0, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, -1\n);\n\nbool isBounded(in vec2 uv) {\n  return all(lessThanEqual(uv,    vec2(1.0, 1.0))) &&\n         all(greaterThanEqual(uv, vec2(0.0, 0.0)));\n}\n\nvec2 melt(in vec2 uv, in float delta) {\n  // pixelation pass\n  float pxWidth = 320.0;\n  float pxX     = floor(pxWidth * uv.x) / pxWidth;\n  \n  float offset = float(offsetTable[int(pxX * pxWidth)]);\n  offset = offset / (iResolution.y / 32.0);\n  \n  if (offset <= 0.0) {\n    offset = offset + (1.0 / iResolution.y) + delta;\n  } else {\n    offset = offset + (8.0 / iResolution.y) + delta;\n  }\n  \n  if (offset < 0.0) offset = 0.0;\n\n  return vec2(uv.x, uv.y + offset);\n}\n\nfloat delta(in float time, out bool shift) {\n  float wait         = 2.0;\n  float acceleration = 1.15;\n  \n  shift = mod(time, wait * 4.0) > wait * 2.0;\n  return max(mod(time, wait * 2.0) - wait, 0.0) * acceleration;\n}\n\nvec4 sampleTexture(in vec2 uv, in bool shift) {\n  if (shift) { return texture(iChannel0, uv); }\n  else       { return texture(iChannel1, uv); }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  bool shift;\n  vec2 uv     = fragCoord / iResolution.xy;\n  vec2 melted = melt(uv, delta(iTime, shift));\n\n  if (isBounded(melted)) { fragColor = sampleTexture(melted, shift);  }\n  else                   { fragColor = sampleTexture(uv,     !shift); }\n}","name":"Image","description":"","type":"image"}]}