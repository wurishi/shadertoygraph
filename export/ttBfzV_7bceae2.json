{"ver":"0.1","info":{"id":"ttBfzV","date":"1599697102","viewed":190,"name":"Wrapped Slider Puzzle","username":"spool2kool","description":"a puzzle game.\nchoose image/webcam to start.\nsolve each level by clicking the arrows.\ncompleting a puzzle goes to next level.\nthere are 16 levels in pairs. with each pair there are 2 types:\nnormal\nRGB split","likes":4,"published":1,"flags":34,"usePreview":0,"tags":["game","image","puzzle","sliding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int loadvar(ivec2 pos,int rgb,int low,int range)\n{\n    int ret=0;\n    vec4 t=texelFetch(iChannel2,pos,0);\n    if(rgb==0) ret=int(t.r*float(range)+float(low));\n    if(rgb==1) ret=int(t.g*float(range)+float(low));\n    if(rgb==2) ret=int(t.b*float(range)+float(low));\n    return ret;\n}\n\nvec4 animate_move(vec2 uv,float border,vec3 mask,ivec2 mov,int ch,int sze,int frame)\n{\n \tvec4 ret = texture(iChannel0,(uv-border)/(1.-border*2.))*vec4(mask,1.);\n    vec4 a= vec4(0.,0.,0.,1.);\n    vec4 b= vec4(0.,0.,0.,1.);\n    ivec2 pos=ivec2(uv*float(sze));\n    float offset=1./float(sze)/float(ani_len)*float(frame+1)*float(sign(mov.y))*(1.-border*2.);\n    vec3 mask1=vec3(0.);\n    vec3 mask2=vec3(0.);\n    \n    if(mov.x<sze)\n    {\n    \tif(mov.y<0)\n        {\n            if(uv.y>border-offset) mask2=vec3(1.,1.,1.);\n            b = texture(iChannel0,(uv+vec2(0.,offset+1.-2.*border)-border)/(1.-border*2.))*vec4(mask,1.)*vec4(1.-mask2,1.);\n        }\n        else\n        {\n\t\t\tif(uv.y<1.-(border+offset)) mask2=vec3(1.,1.,1.);\n            b = texture(iChannel0,(uv+vec2(0.,offset-1.+2.*border)-border)/(1.-border*2.))*vec4(mask,1.)*vec4(1.-mask2,1.);\n        }\n        a = texture(iChannel0,(uv+vec2(0.,offset)-border)/(1.-border*2.))*vec4(mask,1.)*vec4(mask2,1.);\n        \n    }\n    else\n    {\n        if(mov.y<0)\n        {\n            if(uv.x>border-offset) mask2=vec3(1.,1.,1.);\n            b = texture(iChannel0,(uv+vec2(offset+1.-2.*border,0.)-border)/(1.-border*2.))*vec4(mask,1.)*vec4(1.-mask2,1.);\n        }\n        else\n        {\n\t\t\tif(uv.x<1.-(border+offset)) mask2=vec3(1.,1.,1.);\n            b = texture(iChannel0,(uv+vec2(offset-1.+2.*border,0.)-border)/(1.-border*2.))*vec4(mask,1.)*vec4(1.-mask2,1.);\n        }\n        a = texture(iChannel0,(uv+vec2(offset,0.)-border)/(1.-border*2.))*vec4(mask,1.)*vec4(mask2,1.);\n        \n    }\n    \n   ivec2 pos2=ivec2((uv-border)/(1.-border*2.)*float(sze));\n        if(mov.x<sze)\n        {\n            //col\n            if(pos2.x==mov.x)\n            {\n                if(ch==0 || ch==3) mask1.r=1.;\n                if(ch==1 || ch==3) mask1.g=1.;\n                if(ch==2 || ch==3) mask1.b=1.;\n            }\n        }\n        else\n        {\n            //row\n            if(pos2.y==mov.x-sze)\n            {\n                if(ch==0 || ch==3) mask1.r=1.;\n                if(ch==1 || ch==3) mask1.g=1.;\n                if(ch==2 || ch==3) mask1.b=1.;\n            }\n        }\n    \n    ret=ret*vec4(1.-mask1,1.)+(a+b)*vec4(mask1,1.);\n    return ret;\n}\n//based on 3 point triangle     https://www.shadertoy.com/view/wdXBRs\n//based on this http://www.alternatievewiskunde.nl/sunall/suna57.htm\n\n\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n      vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    vec3 temp = abs(vec3(u,v,w));\n    if(temp.x+temp.y+temp.z>1.0001)return 0.;\n    return 1.;\n}\n\nvec4 arrows(vec2 uv,int mode,int sze,float border)\n{\n    vec3 ret=vec3(0.);\n    vec2 pos=vec2((uv-border)/(1.-border*2.));\n    vec2 pos1=floor(pos*float(sze));\n    vec2 pos2=floor(pos*float(sze*3));\n    if(mode==0)\n    {\n        vec2 a=border+(pos1+0.5)/float(sze)*(1.-border*2.);\n        vec2 b=border+pos1/float(sze)*(1.-border*2.);\n        vec2 c=border+(pos1+1.)/float(sze)*(1.-border*2.);\n        if(uv.y>border && uv.y<1.-border)\n        {\n            if(uv.x<border)\n            {\n               ret=vec3(triangle(uv,vec2(0.,a.y),vec2(border,b.y),vec2(border,c.y)));\n            }\n            if(uv.x>1.-border)\n            {\n               ret=vec3(triangle(uv,vec2(1.,a.y),vec2(1.-border,b.y),vec2(1.-border,c.y)));\n            }\n        }\n        if(uv.x>border && uv.x<1.-border)\n        {\n            if(uv.y<border)\n            {\n               ret=vec3(triangle(uv,vec2(a.x,0.),vec2(b.x,border),vec2(c.x,border)));\n            }\n            if(uv.y>1.-border)\n            {\n               ret=vec3(triangle(uv,vec2(a.x,1.),vec2(b.x,1.-border),vec2(c.x,1.-border)));\n            }\n        }\n    }\n    else\n    {\n        vec2 a=border+(pos2+0.5)/float(sze*3)*(1.-border*2.);\n        vec2 b=border+pos2/float(sze*3)*(1.-border*2.);\n        vec2 c=border+(vec2(pos2)+1.)/float(sze*3)*(1.-border*2.);\n        vec3 col=vec3(0.);\n        \n\t\tif(uv.y>border && uv.y<1.-border)\n        {\n           \tint ch=int(pos2.y)%3;\n            if(ch==0) col.r=1.;\n            if(ch==1) col.g=1.;\n            if(ch==2) col.b=1.;\n            if(uv.x<border)\n            {\n               ret=vec3(triangle(uv,vec2(0.,a.y),vec2(border,b.y),vec2(border,c.y)))*col;\n            }\n            if(uv.x>1.-border)\n            {\n               ret=vec3(triangle(uv,vec2(1.,a.y),vec2(1.-border,b.y),vec2(1.-border,c.y)))*col;\n            }\n        }\n        \n        if(uv.x>border && uv.x<1.-border)\n        {\n            int ch=int(pos2.x)%3;\n            if(ch==0) col.r=1.;\n            if(ch==1) col.g=1.;\n            if(ch==2) col.b=1.;\n            if(uv.y<border)\n            {\n               ret=vec3(triangle(uv,vec2(a.x,0.),vec2(b.x,border),vec2(c.x,border)))*col;\n            }\n            if(uv.y>1.-border)\n            {\n               ret=vec3(triangle(uv,vec2(a.x,1.),vec2(b.x,1.-border),vec2(c.x,1.-border)))*col;\n            }\n        }\n    }\n    return vec4(ret,1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mpos=iMouse.xy/iResolution.xy;\n    \n    int lvl=loadvar(var0,1,0,sizes*2);\n    int selected=loadvar(var0,0,-1,2);\n    int state=loadvar(var2,0,0,4);\n    int animating=loadvar(var2,2,0,1);\n    int ani_time=loadvar(var2,1,0,ani_len-1);\n    \n    int sze=(lvl/2)+2;//puzzle size\n    int mode=lvl%2;\n    \n    ivec2 move=ivec2(loadvar(var1,0,0,2*sze-1),loadvar(var1,1,-1,sze));\n    int ch=loadvar(var1,2,0,3);\n    \n    float border=1./float(sze)/6.;\n    \n    vec3 mask=vec3(0.);\n    if(uv.x>border && uv.x<1.-border && uv.y>border && uv.y<1.-border) mask=vec3(1.);\n    \n    if(selected==-1 || state==0)\n    {\n        fragColor = texture(iChannel1,uv);\n    }\n    else if(state==1)\n    {        \n        fragColor = texture(iChannel0,(uv-border)/(1.-border*2.))*vec4(mask,1.);\n    }\n    else\n    {\n        \n        if(animating==0)\n        {\n            if(mpos.x>border && mpos.x<1.-border && mpos.y>border && mpos.y<1.-border && iMouse.z>0.5)\n            {\n                fragColor = abs(texture(iChannel0,(uv-border)/(1.-border*2.))*vec4(mask,1.)-texture(iChannel1,(uv-border)/(1.-border*2.))*vec4(mask,1.));\n            }\n            else\n            {\n                fragColor = texture(iChannel0,(uv-border)/(1.-border*2.))*vec4(mask,1.)+arrows(uv,mode,sze,border);\n            }\n        }\n        else\n        {\n         \tfragColor = animate_move(uv,border,mask,move,ch,sze,(iFrame-ani_time)%ani_len);  \n        }\n    }\n    //fragColor+=texture(iChannel2,uv/10.);//debug\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"int loadvar(ivec2 pos,int rgb,int low,int range)\n{\n    int ret=0;\n    vec4 t=texelFetch(iChannel2,pos,0);\n    if(rgb==0) ret=int(t.r*float(range)+float(low));\n    if(rgb==1) ret=int(t.g*float(range)+float(low));\n    if(rgb==2) ret=int(t.b*float(range)+float(low));\n    return ret;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    vec2 mpos=iMouse.xy/iResolution.xy;\n    int selected=loadvar(var0,0,-1,2);\n    if(selected==-1)\n    {\n     \t//draw options\n        if(uv.x<0.5)\n        {\n            fragColor=texture(iChannel0,uv);\n        }\n        else\n        {\n           fragColor=texture(iChannel1,uv); \n        }\n        \n    }\n    if(selected==0) fragColor=texture(iChannel0,uv);\n    if(selected==1) fragColor=texture(iChannel1,uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int sizes=8;//half num of levels\nconst ivec2 arr0=ivec2(1,0);//start of save state\n\nconst ivec2 var2=ivec2(0,2);//lvlstate, ani_time,animating\nconst ivec2 var1=ivec2(0,1);//dir, amount, channel\nconst ivec2 var0=ivec2(0,0);//selected,level,mbtn\n\nconst int ani_len=15;\n\nfloat hash31(vec3 seed)\n{\n    return fract(sin(seed.x*315.41+seed.y*379.648+seed.z*339.287)*75731.967);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"int loadvar(ivec2 pos,int rgb,int low,int range)\n{\n    int ret=0;\n    vec4 t=texelFetch(iChannel0,pos,0);\n    if(rgb==0) ret=int(floor(t.r*float(range)+float(low)+0.5));\n    if(rgb==1) ret=int(floor(t.g*float(range)+float(low)+0.5));\n    if(rgb==2) ret=int(floor(t.b*float(range)+float(low)+0.5));\n    return ret;\n}\nvec4 savevar(vec4 old,vec2 xy,ivec2 pos,int rgb,int val,int low,int range)\n{\n    ivec2 ixy=ivec2(xy);\n    vec4 ret=old;\n    if(ixy.x==pos.x && ixy.y==pos.y)\n    {\n        if(rgb==0) ret.r=float(val-low)/float(range);\n        if(rgb==1) ret.g=float(val-low)/float(range);\n        if(rgb==2) ret.b=float(val-low)/float(range);\n    }\n    return ret;\n}\n\nvec4 arr0init(vec4 old,vec2 xy,int sze)\n{\n \tivec2 ixy=ivec2(xy);\n    vec4 ret=old;\n    if(ixy.x>=arr0.x && ixy.y>=arr0.y && ixy.x<arr0.x+sze && ixy.y<arr0.y+sze)\n    {\n        int id=(ixy.x-arr0.x)+(ixy.y-arr0.y)*sze;\n        ret=savevar(ret,xy,ixy,0,id,0,sze*sze-1);\n        ret=savevar(ret,xy,ixy,1,id,0,sze*sze-1);\n        ret=savevar(ret,xy,ixy,2,id,0,sze*sze-1);\n    }\n    return ret;\n}\n\nint is_solved(int sze)\n{\n    int ret=1;\n    for(int id=0;id<sze*sze;id++)\n    {\n        ivec2 pos=ivec2(id%sze,id/sze)+arr0;\n        vec4 t=texelFetch(iChannel0,pos,0);\n        ivec3 id2=ivec3(t.xyz*float(sze*sze-1));\n        if(id2.x!=id || id2.y!=id || id2.z!=id) ret=0;\n    }\n    return ret;\n}\n\nvec4 apply_move(vec4 old,vec2 xy,ivec2 mov,int ch,int sze)\n{\n    ivec2 ixy=ivec2(xy);\n    vec4 ret=old;\n    if(ixy.x>=arr0.x && ixy.y>=arr0.y && ixy.x<arr0.x+sze && ixy.y<arr0.y+sze)\n    {\n     \tivec2 pos=ixy-arr0;\n        if(mov.x<sze)\n        {\n            //col\n            if(pos.x==mov.x)\n            {\n                if(ch==0 || ch==3) ret=savevar(ret,xy,ixy,0,loadvar((pos+ivec2(0,mov.y+sze))%sze+arr0,0,0,sze*sze-1),0,sze*sze-1);\n                if(ch==1 || ch==3) ret=savevar(ret,xy,ixy,1,loadvar((pos+ivec2(0,mov.y+sze))%sze+arr0,1,0,sze*sze-1),0,sze*sze-1);\n                if(ch==2 || ch==3) ret=savevar(ret,xy,ixy,2,loadvar((pos+ivec2(0,mov.y+sze))%sze+arr0,2,0,sze*sze-1),0,sze*sze-1);\n            }\n        }\n        else\n        {\n            //row\n            if(pos.y==mov.x-sze)\n            {\n                if(ch==0 || ch==3) ret=savevar(ret,xy,ixy,0,loadvar((pos+ivec2(mov.y+sze,0))%sze+arr0,0,0,sze*sze-1),0,sze*sze-1);\n                if(ch==1 || ch==3) ret=savevar(ret,xy,ixy,1,loadvar((pos+ivec2(mov.y+sze,0))%sze+arr0,1,0,sze*sze-1),0,sze*sze-1);\n                if(ch==2 || ch==3) ret=savevar(ret,xy,ixy,2,loadvar((pos+ivec2(mov.y+sze,0))%sze+arr0,2,0,sze*sze-1),0,sze*sze-1);\n            }\n        }\n    }\n    return ret;\n}\n\nivec3 check_btns(vec2 mpos,int mode,int sze)\n{\n    float border=1./float(sze)/6.;\n    ivec3 ret=ivec3(0,0,3);\n    vec2 pos=(mpos-vec2(border))/vec2(1.-border*2.);\n    if(!(mpos.x>border && mpos.x<1.-border && mpos.y>border && mpos.y<1.-border))\n    {\n        \n        if(pos.x>0. && pos.x<1.)\n        {\n            \n            if(pos.y>1.) ret.y=-1;\n            if(pos.y<0.) ret.y=1;\n            if(mode==1) ret.z=int(pos.x*3.*float(sze))%3;\n            ret.x=int(pos.x*float(sze));\n        }\n        if(pos.y>0. && pos.y<1.)\n        {\n            \n            if(pos.x>1.) ret.y=-1; \n            if(pos.x<0.) ret.y=1;\n            if(mode==1) ret.z=int(pos.y*3.*float(sze))%3;\n            ret.x=int(pos.y*float(sze))+sze;\n        }\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mpos=iMouse.xy/iResolution.xy;\n    float seed=iDate.w/60.;\n    fragColor=texelFetch(iChannel0,ivec2(fragCoord),0);\n    if(iFrame==0)\n    {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n    else\n    {\n        //load vars\n        int selected=loadvar(var0,0,-1,2);\n        int lvl=loadvar(var0,1,0,sizes*2);\n        int mbtn=loadvar(var0,2,0,1);\n        int state=loadvar(var2,0,0,4);\n        int ani_time=loadvar(var2,1,0,ani_len-1);\n        int animating=loadvar(var2,2,0,1);\n        \n        int sze=(lvl/2)+2;//puzzle size\n        int mode=lvl%2;//norm/rgb mode\n        \n        ivec2 move=ivec2(loadvar(var1,0,0,2*sze-1),loadvar(var1,1,-1,sze));\n        int ch=loadvar(var1,2,0,3);\n        \n        if(iMouse.z>0.5) mbtn=1;\n        if(iMouse.z<0.5 && selected==-1 && mbtn==1)\n        {\n            if(mpos.x<0.5) selected=0; else selected=1;\n            mbtn=0;\n            state=0;\n        }\n        if(state==2)\n        {\n         \t\n            if(animating==1)\n            {\n                mbtn=0;\n                if((iFrame-ani_time)%ani_len==ani_len-1)\n                {\n                    animating=0;\n                    fragColor=apply_move(fragColor,fragCoord,move,ch,sze);\n                }\n            }\n            if(iMouse.z<0.5 && mbtn==1 && animating==0)\n            {\n                mbtn=0;\n                ivec3 temp=check_btns(mpos,mode,sze);\n                move=ivec2(temp.x,temp.y);\n                ch=temp.z;\n                if(move.y!=0)\n                {\n                    animating=1;\n                    ani_time=iFrame%ani_len;\n                }\n            }\n            \n            \n        }\n        if(state==1)\n        {\n         \tif(iFrame%2==1)\n            {\n                if(mode==0) fragColor=apply_move(fragColor,fragCoord,move,3,sze); else fragColor=apply_move(fragColor,fragCoord,move,int(hash31(vec3(iTime,3.,seed))*3.),sze);\n            }\n            else\n            {\n                move.x=int(hash31(vec3(iTime,1.,seed))*2.*float(sze));\n                move.y=int(hash31(vec3(iTime,2.,seed))*float(sze-1)+1.);\n            }\n            if(iMouse.z<0.5 && mbtn==1)\n            {\n                mbtn=0;\n                if(is_solved(sze)==0)\n                {\n                    state=2;\n                    move.y=0;\n                }\n            }\n        }\n        if(state==0 && iMouse.z<0.5 && mbtn==1 && iFrame%2==1)\n        {\n            mbtn=0;\n            state=1;\n            move=ivec2(0);\n            fragColor=arr0init(fragColor,fragCoord,sze);\n        }\n        if(state==4)\n        {\n         \tlvl==0;\n            selected=-1;\n            state=0;\n        }\n        if(is_solved(sze)==1 && state==2 && iFrame%2==0)\n        {\n            lvl++;\n            if(lvl<16)state=0; else state=4;\n        }\n        \n        //save vars\n        fragColor=savevar(fragColor,fragCoord,var1,0,move.x,0,2*sze-1);\n        fragColor=savevar(fragColor,fragCoord,var1,1,move.y,-1,sze);\n        fragColor=savevar(fragColor,fragCoord,var1,2,ch,0,3);        \n        \n        fragColor=savevar(fragColor,fragCoord,var2,0,state,0,4);\n        fragColor=savevar(fragColor,fragCoord,var2,1,ani_time,0,ani_len-1);\n        fragColor=savevar(fragColor,fragCoord,var2,2,animating,0,1);\n        \n        fragColor=savevar(fragColor,fragCoord,var0,0,selected,-1,2);\n        fragColor=savevar(fragColor,fragCoord,var0,1,lvl,0,sizes*2);\n        fragColor=savevar(fragColor,fragCoord,var0,2,mbtn,0,1);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int loadvar(ivec2 pos,int rgb,int low,int range)\n{\n    int ret=0;\n    vec4 t=texelFetch(iChannel1,pos,0);\n    if(rgb==0) ret=int(t.r*float(range)+float(low));\n    if(rgb==1) ret=int(t.g*float(range)+float(low));\n    if(rgb==2) ret=int(t.b*float(range)+float(low));\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=fragCoord/iResolution.xy;\n    \n    int lvl=loadvar(var0,1,0,sizes*2);\n    int state=loadvar(var2,0,0,4);\n    if(state==4) lvl++;\n    int sze=(lvl/2)+2;//puzzle size\n    ivec2 move=ivec2(loadvar(var1,0,0,2*sze-1),loadvar(var1,1,0,sze-1));\n    int ch=loadvar(var1,2,0,3); \n    \n   \n    \n    ivec2 pos=ivec2(uv*vec2(sze));\n    \n    \n    \n    ivec3 ids=ivec3(loadvar(pos+arr0,0,0,sze*sze-1),loadvar(pos+arr0,1,0,sze*sze-1),loadvar(pos+arr0,2,0,sze*sze-1));\n    ivec3 x=ids%sze;\n    ivec3 y=ids/sze;\n    vec3 col=vec3(0.);\n    \n    col.r=texture(iChannel0,mod(uv,1./float(sze))+vec2(x.r,y.r)/float(sze)).r;\n    col.g=texture(iChannel0,mod(uv,1./float(sze))+vec2(x.g,y.g)/float(sze)).g;\n    col.b=texture(iChannel0,mod(uv,1./float(sze))+vec2(x.b,y.b)/float(sze)).b;\n    fragColor = vec4(col,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}