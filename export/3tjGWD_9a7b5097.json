{"ver":"0.1","info":{"id":"3tjGWD","date":"1559622933","viewed":187,"name":"Visualization Menger sponge","username":"edo_m18","description":"Visualization Menger sponge","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["visualization","menger","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///\n/// This post purpose a menger sponge maze analyzing.\n///\n/// Refer to this post: https://www.shadertoy.com/view/ldyGWm\n///\n\n// 1 = Morphing ON, 0 = Morphing OFF\n#define USE_MORPHING 1\n\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n)\n{\n    n = max(n * n, 0.001);\n    n /= (n.x + n.y + n.z);\n    return (texture(tex, p.yz) * n.x\n          + texture(tex, p.zx) * n.y\n          + texture(tex, p.xy) * n.z).xyz;\n}\n\nfloat map(vec3 q)\n{\n    float s = 10.0;\n\tvec3 p = abs(fract(q / s) * s - s * 0.5); // Repeat space.\n    \n    // Get maximum distance of surface of cube?\n    float a1 = max(p.x, p.y);\n    float b1 = max(p.y, p.z);\n    float c1 = max(p.x, p.z);\n\t\n    float size = 1.0;\n    \n    float d1 = min(a1, min(b1, c1)) - size + 0.05; // Void Cube.\n    \n    s = 1.0;\n\tp = abs(mod(q, s) - s * 0.5); // Repeat space.\n    \n    // Get maximum distance of surface of cube?\n    float a2 = max(p.x, p.y);\n    float b2 = max(p.y, p.z);\n    float c2 = max(p.x, p.z);\n\t\n    size = 1.0 / 3.0;\n    \n    float d2 = min(a2, min(b2, c2)) - size + 0.05;\n    \n    float d = max(d1, d2);\n    \n    float m = abs(sin(iTime * 0.1));\n    float r = mix(d1, d2, m);\n    \n    #if USE_MORPHING == 1\n    return r;\n    #else\n    return d;\n    #endif\n}\n\nvec3 getNormal(vec3 p)\n{\n    const vec2 e = vec2(0.01, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p + e.xyy),\n        map(p + e.yxy),\n        map(p + e.yyx));\n    return normalize(n);\n}\n\nmat3 camera(vec3 ro, vec3 ta)\n{\n    vec3 up = vec3(0, 1, 0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 0, -5);\n    vec3 ta = vec3(0, 0, 0);\n    \n    vec3 ray = camera(ro, ta) * normalize(vec3(uv, 1.5));\n    \n    float d = 0.0, t = 0.0;\n    \n    vec3 p = ro;\n    \n    for (int i = 0; i < 64; i++)\n    {\n        d = map(p);\n        t += d;\n        if (d < 0.01) break;\n        p += ray * d;\n    }\n    \n    vec3 col = vec3(0.0);\n    \n    if (d < 0.01)\n    {\n        vec3 n = getNormal(p);\n        col = tex3D(iChannel0, p, n);\n        \n        float diff = clamp(dot(n, normalize(vec3(1.0, 1.0, 1.0))), 0.1, 1.0);\n        col *= diff;\n    }\n    \n    float fog = exp(-t * 0.02);\n    col *= fog;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}