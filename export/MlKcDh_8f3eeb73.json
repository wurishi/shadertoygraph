{"ver":"0.1","info":{"id":"MlKcDh","date":"1536182099","viewed":679,"name":"Another Path Tracer","username":"noxbuds","description":"Global illumination, reflection, refraction, caustics. Multiple lights can be added. Sadly takes a while to resolve (about 1-2 min at 10 samples)...","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["3d","ray","box","cornell","trace","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Trying to create a better and more compact  //\n//  base for my 3D shaders. Does path tracing   //\n//  with Monte Carlo integration.               //\n//                                              //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Burgess tonemapping - looks fairly bright/cheerful, has quite\n// a bit of contrast aswell\nvec3 burgess(vec3 col)\n{\n    vec3 maxCol = max(vec3(0.0), col - 0.004);\n    vec3 retCol = (maxCol * (6.2 * maxCol + 0.05)) / (maxCol * (6.2 * maxCol + 2.3) + 0.06);\n    return pow(retCol, vec3(1.0 / 2.2));\n}\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Grab colour from Buf A\n    col = texture(iChannel0, uv).rgb;\n    \n    // Tonemapping to make the scene look better\n    col = pow(col, vec3(2.2));\n    col = burgess(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Trying to create a better and more compact  //\n//  base for my 3D shaders. Does path tracing   //\n//  with Monte Carlo integration.               //\n//                                              //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Numbers\n#define PI 3.14159\n#define BIG_NUMBER 1e6\n#define EPS 1e-5\n#define MAX_DEPTH 3\n#define OBJ_COUNT 10\n#define SAMPLES 2.0\n\n// Object types\n#define NONE 0\n#define SPHERE 1\n#define PLANE 2\n#define BOX 3\n\n// Makes it noisy (doesn't smooth image out over time)\n//#define NOISY\n\n// Fake AA\n#define FAKE_AA\n\n/////////////////////////////////////////////////\n//                                             //\n//                 UTILITIES                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Random number generator\nfloat noisev(float p)\n{\n    return fract(sin(p * 1234.0) * 5647.0);\n}\n\n// Returns the minimum component of a vector\nfloat min3(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\n// Returns the maximum component of a vector\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\n// Swaps two terms\nvoid swap(inout float a, inout float b)\n{\n    float temp = a;\n    a = b;\n    b = temp;\n}\n\n// Random 3D vector function\nvec3 R3D(vec3 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec3(a.x * a.y, a.y * a.z, a.x * a.z));\n}\n\n// Orient a ray with vector v\nvec3 orientRay(vec3 ray, vec3 v)\n{\n    return normalize(dot(v, ray) * ray);\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//                  OBJECTS                    //\n//                                             //\n/////////////////////////////////////////////////\n\n// A general object data structure\nstruct Obj\n{\n    // Object type\n    int type;\n    \n    // Position, dimensions\n    vec3 pos;\n    vec4 dim;\n    \n    // Material properties\n    vec3 surface;\n    vec3 emission;\n    float roughness;\n    float ior;\n};\n\n// Blank object - used to represent the sky\nObj BlankObj;\n\n// List of objects\nObj[OBJ_COUNT] objects = Obj[](\n   \t\n    // Note: to go back to indirect lighting testing,\n    // move light to (0.0, 3.0, 0.0) and ceiling to (0.0, 1.5, -5.0)\n    \n    // Green right wall\n    Obj(BOX, vec3(1.0, 5.0, 0.0), vec4(0.5, 10.0, 10.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0), 0.7, 0.0),\n    \n    // Red left wall\n    Obj(BOX, vec3(-1.0, 5.0, 0.0), vec4(0.5, 10.0, 10.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0), 0.7, 0.0), \n    \n    // White back wall\n    Obj(BOX, vec3(0.0, 5.0, 1.0), vec4(10.0, 10.0, 0.5, 0.0), vec3(1.0), vec3(0.0), 0.7, 0.0),\n    \n    // Ceiling\n    Obj(BOX, vec3(0.0, 1.5, -5.0), vec4(10.0, 0.5, 10.0, 0.0), vec3(1.0), vec3(0.0), 0.55, 0.0),\n    \n    // Floor\n    Obj(PLANE, vec3(0.0), vec4(0.0), vec3(1.0), vec3(0.0), 1.0, 0.0),\n    \n    // Light\n    Obj(SPHERE, vec3(0.0, 3.0, 0.0), vec4(1.0), vec3(0.0), vec3(1.0, 1.0, 0.9), 0.0, 0.0),\n    \n    // Glass ball\n    Obj(SPHERE, vec3(-0.1, 0.3, -0.2), vec4(0.3), vec3(0.2, 0.2, 1.0), vec3(0.0), 0.02, 1.52),\n    \n    // Floating blue ball\n    Obj(SPHERE, vec3(-0.3, 1.2, 0.7), vec4(0.3), vec3(0.2, 0.2, 1.0), vec3(0.0), 0.01, 0.0),\n    \n    // Another ball\n    Obj(SPHERE, vec3(0.5, 0.3, -0.1), vec4(0.2), vec3(0.9, 0.0, 0.0), vec3(0.0), 0.2, 0.0),\n    \n    // Rough box\n    Obj(BOX, vec3(-0.4, 0.3, 0.4), vec4(0.6), vec3(1.0, 0.5, 0.0), vec3(0.0), 0.9, 0.0)\n);\n\n/////////////////////////////////////////////////\n//                                             //\n//           INTERSECTION FUNCTIONS            //\n//                                             //\n/////////////////////////////////////////////////\n\n// Sphere intersection\nfloat iSphere(Obj obj, vec3 o, vec3 r, inout vec3 n)\n{\n    // Move to local co-ordinates\n    o -= obj.pos;\n    n = vec3(0.0);\n    \n    // Solve the intersection equation\n    float ret = 0.0;\n    float b = 2.0 * dot(o, r);\n    float c = dot(o, o) - obj.dim.x * obj.dim.x;\n    float h = b * b - 4.0 * c;\n    if (h < 0.0) ret = -1.0;\n    else ret = (-b - sqrt(h)) / 2.0;\n    \n    // Return normal and distance\n    n = (o + r * ret) / obj.dim.x;\n    return ret;\n}\n\n// Plane intersection\nfloat iPlane(Obj obj, vec3 o, vec3 r, inout vec3 n)\n{\n    // Normal\n    if (o.y > obj.dim.x)\n        n = vec3(0.0, 1.0, 0.0);\n    else\n        n = vec3(0.0, -1.0, 0.0);\n    \n    // Intersection distance\n    return -o.y / r.y - obj.dim.x;\n}\n\n// Box intersection\nfloat iBox(Obj obj, vec3 o, vec3 r, inout vec3 n)\n{\n    // Calculate bounds\n    vec3 bmin = obj.pos - obj.dim.xyz / 2.0;\n    vec3 bmax = obj.pos + obj.dim.xyz / 2.0;\n    \n    // Calculate minima and maxima\n    vec3 tmin3 = (bmin - o) / r;\n    vec3 tmax3 = (bmax - o) / r;\n    \n    // Make sure they're the right way around\n    if (tmin3.x > tmax3.x) swap(tmin3.x, tmax3.x);\n    if (tmin3.y > tmax3.y) swap(tmin3.y, tmax3.y);\n    if (tmin3.z > tmax3.z) swap(tmin3.z, tmax3.z);\n    \n    // Calculate minimum and maximum distance\n    float tmin = max3(tmin3);\n    float tmax = min3(tmax3);\n    float t = min(tmin, tmax);\n    \n    // Skip over box if we're out of bounds\n    if (tmin > min3(tmax3) || max3(tmin3) > tmax)\n        t = -1.0;\n    \n    // Calculate normal\n    vec3 p = o + r * t;\n    vec3 sn = 2.0 * (p - obj.pos) / obj.dim.xyz;\n    n = vec3(0.0);\n    \n    // Calculate normal\n    if (sn.x > 1.0 - EPS * 2.0) n = vec3(1.0, 0.0, 0.0);\n    if (sn.x < EPS * 2.0 - 1.0) n = vec3(-1.0, 0.0, 0.0);\n    if (sn.y > 1.0 - EPS * 2.0) n = vec3(0.0, 1.0, 0.0);\n    if (sn.y < EPS * 2.0 - 1.0) n = vec3(0.0, -1.0, 0.0);\n    if (sn.z > 1.0 - EPS * 2.0) n = vec3(0.0, 0.0, 1.0);\n    if (sn.z < EPS * 2.0 - 1.0) n = vec3(0.0, 0.0, -1.0);\n    \n    // Return distance\n    return t;\n}\n\n// Calculates intersections with the scene\nObj intersect(vec3 o, vec3 r, out float t, inout vec3 n)\n{\n    // Return values\n    t = BIG_NUMBER;\n    int id = 0;\n    \n    // Loop through each object\n    for (int i = 0; i < OBJ_COUNT; i++)\n    {\n        // Current variables\n        float ct = BIG_NUMBER;\n        vec3 cn = vec3(0.0);\n        \n        // Check what type it is\n        if (objects[i].type == SPHERE)\n            ct = iSphere(objects[i], o, r, cn);\n        else if (objects[i].type == PLANE)\n            ct = iPlane(objects[i], o, r, cn);\n        else if (objects[i].type == BOX)\n            ct = iBox(objects[i], o, r, cn);\n        \n        // If the point is closer than the current\n        // point but still visible, use it instead\n        if (ct < t && ct > 0.0)\n        {\n            t = ct;\n            id = i;\n            n = normalize(cn);\n        }\n    }\n    \n    // If t < BIG_NUMBER (we hit something), return an object\n    if (t < BIG_NUMBER)\n    \treturn objects[id];\n    else\n        return BlankObj;\n}\n\n// Casts a ray and returns the final colour\nObj castRay(vec3 o, vec3 r, out vec3 n, out vec3 p)\n{\n    // Setup variables\n    vec3 col = vec3(0.0);\n    int rn = 0;\n    \n    // Initialise normal vector and distance\n    n = vec3(0.0);\n    float t = BIG_NUMBER;\n\n    // Calculate intersection\n    Obj obj = intersect(o, r, t, n);\n    \n    // Setup the point\n    p = o + r * t;\n    \n    // Return colour\n    return obj;\n}\n\n// Returns probability of reflection vs refraction\nfloat schlick(float cosine, float ior)\n{\n    float R0 = pow((1.0 - ior) / (1.0 + ior), 2.0);\n    return R0 + (1.0 - R0) * pow(1.0 - cosine, 5.0);\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup co-ordinates\n    vec2 uv = (fragCoord / iResolution.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Normalised mouse position\n    vec2 mp = iMouse.xy / iResolution.xy;\n    mp = (mp * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Base ray properties\n    vec3 o = vec3(mp.x * 3.0, 0.5, mp.y * 3.0);\n    o = vec3(0.05, 0.5, -1.8);\n    vec3 r = normalize(vec3(uv, 0.58 * PI));\n    \n    #ifdef FAKE_AA\n    // Add a random offset to the ray\n    vec3 rv = normalize(R3D(o + r * (iTime + 1.0)));\n    r = normalize(r + rv.xzy * 0.002);\n    #endif\n    \n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Previous object hit\n    Obj pobj;\n    \n    // Backward tracing\n    for (int rn = 0; rn < MAX_DEPTH; rn++)\n    {\n        // Cast a ray\n    \tvec3 n, p = vec3(0.0);\n    \tObj obj = castRay(o, r, n, p);\n    \tvec3 fcol = obj.surface;\n        \n        // Offset p a bit\n        p = p + n * EPS;\n        \n        // Generate a random vector for diffuse calculations\n        vec3 vDiff = normalize(R3D(p + iTime) * 2.0 - 1.0);\n        \n        // If the object is not refractive, align the ray with the normal.\n        // Otherwise, align the ray with the inverse normal to stop it from\n        // exiting the object\n        if (obj.ior == 0.0) vDiff = orientRay(vDiff, n);\n        else vDiff = orientRay(vDiff, -n);\n        \n        // Light sampling\n        vec3 shadow, cIndirect = vec3(0.0);\n        float ns = 0.0;\n        \n        // Sample\n        for (; ns < SAMPLES; ns++)\n        {\n            vec3 nDiff = normalize(R3D(p + iTime + ns) * 2.0 - 1.0);\n            nDiff = orientRay(nDiff, n);\n            \n            // Cast a ray in the direction\n            vec3 p_2, n_2 = vec3(0.0);\n            Obj iObj = castRay(p, nDiff, n_2, p_2);\n            cIndirect += iObj.surface + iObj.emission;\n            \n            // For shadows, loop through each object in the\n            // array, and calculate shadows if it's emissive\n            for (int i = 0; i < OBJ_COUNT; i++)\n            {\n                // Only create shadows if the object is emissive\n                if (objects[i].emission != vec3(0.0))\n                {\n                    // Setup some temp variables\n                    vec3 p_, n_ = vec3(0.0);\n\n                    // Shadow approximation; use p - o as light dir\n                    vec3 ld = objects[i].pos - p;\n                    vec3 lrDir = normalize(nDiff + ld);\n                    Obj sObj = castRay(p, lrDir, n_, p_);\n\n                    // If we hit the light source, add onto light multiplier\n                    if (sObj == objects[i])\n                        shadow += sObj.emission;\n                    else\n                    {\n                        // Bounce the ray a few times for caustics\n                        vec3 bkp = p;\n                        vec3 transmissionCol = vec3(1.0);\n                        for (int lrn = 0; lrn < MAX_DEPTH; lrn++)\n                        {\n                            // Set position\n                            p = p_ + n_ * EPS;\n                            \n                            // Generate a random vector for diffuse calculations\n                            vec3 lrDiff = normalize(R3D(p + iTime + ns) * 2.0 - 1.0);\n\t\t\t\t\t\t\tvec3 lrRef = vec3(0.0);\n                            \n                            // If the object is not refractive, align the ray with the normal.\n                            // Otherwise, align the ray with the inverse normal to stop it from\n                            // exiting the object\n                            if (sObj.ior == 0.0) lrDiff = orientRay(lrDiff, n_);\n                            else lrDiff = orientRay(lrDiff, -n_);\n                            \n                            // Generate random number\n                            float nv = noisev(p.x + p.y + p.z + iTime + ns);\n                            \n                            // If the number is above the angle of incidence,\n                            // or the object isn't refractive, reflect\n                            if (nv > 1.0 - schlick(dot(n_, -lrDir), sObj.ior) || sObj.ior == 0.0)\n                                lrRef = reflect(lrDir, n_);\n                            else\n                            {\n                                // Otherwise refract\n                                p -= n_ * EPS * 2.0;\n                                lrRef = refract(lrDir, n_, 1.0 / sObj.ior);\n                            }\n                            \n                            // Mix between the reflection types based on roughness\n                            lrDir = mix(lrRef, lrDiff, sObj.roughness);\n                            \n                            // Cast a ray\n                            sObj = castRay(p, lrDir, n_, p_);\n                            \n                            // If we hit a light, add colour and break\n                            if (sObj == objects[i])\n                            {\n                                shadow += sObj.emission * transmissionCol;\n                                break;\n                            }\n                            else\n                            {\n                                transmissionCol *= sObj.surface;\n                            }\n                        }\n                        p = bkp;\n                        //////////\n                    }\n                }\n            }\n        }\n        shadow /= ns;\n        cIndirect /= ns;\n        \n        // Add color\n        vec3 ld = normalize(vec3(-0.4, -0.6, 0.4));\n        col += fcol * cIndirect * shadow + obj.emission;\n        \n        // Calculate the reflected/refracted vector\n        float nv = noisev(p.x + p.y + p.z + iTime);\n        vec3 vRef = vec3(0.0);\n        if (obj.ior > 0.0)\n        {\n            if (nv > 1.0 - schlick(dot(n, -r), obj.ior))\n                vRef = reflect(r, n);\n            else\n            {\n                p -= n * EPS * 2.0;\n                vRef = refract(r, n, 1.0 / obj.ior);\n            }\n        }\n        else vRef = reflect(r, n);\n        \n        // Mix between the two based on roughness\n        r = mix(vRef, vDiff, obj.roughness);\n        \n        // Set previous object\n        pobj = obj;\n        o = p;\n    }\n    \n    \n    // Output to screen\n    #ifdef NOISY\n    fragColor = vec4(mix(col, texture(iChannel0, fragCoord / iResolution.xy).rgb, 0.5), 1.0);\n    #else\n    col += texture(iChannel0, fragCoord / iResolution.xy).rgb * float(iFrame);\n    fragColor = vec4(col / float(iFrame + 1), 1.0);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"}]}