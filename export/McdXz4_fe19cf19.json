{"ver":"0.1","info":{"id":"McdXz4","date":"1713686733","viewed":82,"name":"2D Polygon with Effects","username":"TLEsoft","description":"Try increasing the Pixelation value to increase image smoothness.\nTry increasing the ColorDepthCrunch value to reduce color banding.\nTry decreasing the NoiseAmplitude value to eliminate the \"claymation\" effect.\nTry altering aspects of the polygon.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","pixel","stopmotion","claymation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Values used for rounding the coordinate system for pixelation,\n//  and rounding the color to reduce depth.\n\nfloat pixelation = 32.0;\nfloat colorDepthCrunch = 16.0;\n\n\n// rotation and scale, self explanatory?\n\nfloat polygonRotation = 0.0;\nfloat polygonScaleX = 1.0;\nfloat polygonScaleY = 1.0;\n\n//Color input.\n\nvec3 baseColor = vec3(0.7,0.65,0.2);\nfloat baseAlpha = 1.0;\n\n//Side Count: number of sides the polygon has, non-integers result in uneven shapes.\n\nfloat sideCount = 5.0;\n\n//Curve Depth: zero is always a circle, max value gives a shape with hard edges.\n\nfloat curveDepth = 0.75;\n\n//Inner Vertex Length: zero is an infinitely thin stellated shape.\n//\tMax value is a \"regular\" polygon double the side count (assuming an integer side count).\n//\t(sideCount-2/sideCount-1) will result in a regular polygon of the base side count.\n\nfloat innerVertexLength = 0.25;\n\n//For example, a regular hexagon would be a side count of 6.0, curve depth of 1.0, IVL of 0.8.\n\nfloat pi = 3.14159265359;\n\n//Supply a texture. Low frequency noise will have a more \"clay-like\" texture.\n//\tHigh frequency noise may be more comparable to torn paper, though can produce a \"streaking\" effect.\n\n// [ Imagine if you were passing a uniform that this is where it would go, instead we'll use ShaderToy's iChannel0 ]\n\n//Noise Amplitude: how far in and out the edge of the shape will be moved.\n//\tI find values under 0.1 to be more natural, high values could be good for things like flames.\n\nfloat noiseAmplitude = 0.05;\n\n//Noise Frequency: how quickly the underlying noise values will shift.\n//\tHigh is slower, high values give a sort of \"fluid-like\" or gelatinous appearance.\n\nfloat noiseFrequency = 200.0;\n\n//Noise Frame Limit: how many frames need to pass before the actual visuals change.\n//\tI find 10-12 FPS produces stop-motion-like results.\n\nint noiseFrameLimit = 6;\n\n//Normal Shade Rotation: change the direction from which the polygon appears \"lit\".\n\nfloat normalShadeRotation = 0.0;\n\n//Round Normal Intensity: change how extreme the lighting based on the normal vector is.\n//\tHigh-medium values are \"orb-like\", medium-low values are \"stamp-like\".\n\nfloat roundNormalIntensity = 0.25;\n\n//Height Shade Intensity: shading based purely on the \"height map\".\n//\tThis is good for giving hard-edged polygons more definition.\n//\tSomeday I'll update this to actually use the outer-edge normals.\n\nfloat heightShadeIntensity = 0.45;\n\nmat2 matrixRotation(float rotationAngle){\n\treturn mat2(vec2(cos(rotationAngle),-sin(rotationAngle)),vec2(sin(rotationAngle),cos(rotationAngle)));\n}\n\nvec2 polarCoordinates(vec2 position){\n\treturn vec2(atan(position.x,position.y), length(position));\n}\n\n//The original polygon drawing function uses the value resulting from this function.\n//\t I altered the inputs to start with length for easier trig functions for future features.\nfloat getVertexDepth(float IVL){\n\tfloat VDmax = sideCount - (sideCount * (1.0/sideCount));\n\treturn mix(0.0,VDmax,IVL);\n}\n\n//Good resource for relationship between height and normal vector: https://www.youtube.com/watch?v=oku5FlQoEM8\nfloat getSimHeight(float distanceFromCenter){\n\tfloat simHeight = sqrt(1.0-(distanceFromCenter*distanceFromCenter));\n\treturn (simHeight+1.0)/2.0;\n}\n\n//Adapted from: https://habr.com/ru/articles/519954/\n//  Original function used a seemingly \"arbitrary\" value in place of IVL\nfloat newPolygonalRadius(float angle){\n\tfloat newVertexDepth = getVertexDepth(1.0-innerVertexLength);\n\tfloat top = cos(((2.0*asin(curveDepth))+(pi*newVertexDepth))/(2.0*float(sideCount)));\n\tfloat bot = cos(((2.0*asin(curveDepth*cos(float(sideCount)*angle)))+(pi*newVertexDepth))/(2.0*float(sideCount)));\n\tfloat clayNoise = texture(iChannel0,vec2(((angle+pi)/(2.0*pi)),floor(mod(iTime*float(noiseFrameLimit),noiseFrequency))/noiseFrequency)).x;\n\treturn ((top/bot)+(-clayNoise*noiseAmplitude));\n}\n\nfloat drawPolygon(vec2 cartesianCoords){\n\tvec2 CCtoPC = polarCoordinates(cartesianCoords);\n\tfloat newPolygonRadius = newPolygonalRadius(CCtoPC.x);\n\tif(CCtoPC.y < newPolygonRadius){\n\t\treturn distance(vec2(CCtoPC.y),vec2(newPolygonRadius));\n\t}\n\telse{\n\t\treturn 0.0;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfragColor = clamp(fragColor, vec4(0.0),vec4(1.0));\n    fragColor.a = 0.0;\n    fragColor.xyz = vec3(0.0);\n    vec2 UV = fragCoord/iResolution.xy;\n    UV.x = UV.x * (iResolution.x/iResolution.y);\n\tvec2 polygonScale = vec2(polygonScaleX,polygonScaleY);\n\tvec2 normalUV = (UV*2.0-1.0)/polygonScale;\n\tvec2 pixNUV =  (floor(normalUV * vec2(pixelation * polygonScale))/vec2(pixelation * polygonScale));\n\tfloat polygonalRadiusNormalized = drawPolygon(pixNUV * matrixRotation(-pi*polygonRotation));\n\tvec4 heightNoise = texture(iChannel0,vec2(mod(UV.x+iTime,2.0)/2.0,mod(UV.y+iTime,2.0)/2.0));\n\tvec3 roundNormal = vec3(pixNUV*matrixRotation(pi*normalShadeRotation),getSimHeight(1.0-polygonalRadiusNormalized));\n\tvec3 shade = baseColor.xyz + vec3((roundNormal.x-roundNormal.y)/roundNormal.z*roundNormalIntensity) + vec3((roundNormal.z*2.0-1.0)*heightShadeIntensity);\n    \n    //I'm being a little sloppy and fast here for the sake of demonstrating through ShaderToy, but...\n    //  you would maybe want to alter the alpha for the outline, rather than color.\n\tvec3 outline = vec3(smoothstep(0.0,0.02,polygonalRadiusNormalized) * baseAlpha);\n    fragColor.xyz += (shade*outline);\n\tfragColor.xyz = floor(fragColor.xyz * vec3(colorDepthCrunch))/vec3(colorDepthCrunch);\n}","name":"Image","description":"","type":"image"}]}