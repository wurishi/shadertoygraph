{"ver":"0.1","info":{"id":"Wl3cWM","date":"1609166363","viewed":81,"name":"Morphed Mirror","username":"darkeclipz","description":"Testing some raymarch stuff.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1.\n#define R iResolution.xy\nconst float pi = 3.14159;\nconst float inf = 999999.;\n\n#define MAT_FLOOR 0\n#define MAT_OBJ1 1\n#define MAT_OBJ2 2\nint materialId = MAT_FLOOR;\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r, float time) {;\n    return length(p) - r;\n}\n\nfloat sdSpheres(vec3 p, float time) {\n\n    float t = cos(time);\n    p.xz *= rot(3.*time);\n\n    p.xz = abs(p.xz);\n    \n    float d = inf;\n    float n = 4.;\n    \n    for(float i=0.; i <= n; i++) {\n        float a = pi/2./n*(i);\n        float co = cos(a), si = sin(a);\n        float r = 0.35;\n        float sph = sdSphere(p - vec3(r * co, 0.3, r * si), 0.025, time);\n        d = min(d, sph);\n    }\n    \n    return d;\n}\n\nfloat sdFloor(vec3 pos) {\n    return pos.y + 0.5;\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat map( in vec3 pos, float time )  \n{    \n    materialId = MAT_FLOOR;\n    float d = sdBox(pos, vec3(1.0, 0.01, 1.0));\n    \n    float deform = sin(20.*pos.x+time)*sin(20.*pos.y+time)*sin(20.*pos.z+time) / 20.;\n    float b = 140.;\n    float deform2 = sin(b*pos.x+time)*sin(b*pos.y+time)*sin(b*pos.z+time) / 100.;\n    \n    float s = sdSphere(pos - vec3(0,.3,0), 0.2, time) - deform - deform2*cubicPulse(0.5, 0.2, fract(time/4.));\n        \n    if(s < d) {\n        materialId = MAT_OBJ1;\n    }\n    d = min(d, s);\n    \n    float s2 = sdSpheres(pos, time);;\n    if(s2 < d) {\n        materialId = MAT_OBJ2;\n    }\n    d = smin(d, s2, 0.1);\n    \n    return d;\n}\n\nvec3 calcNormal( in vec3 pos, float t ) \n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize( vec3(map(pos+e.xyy,t)-map(pos-e.xyy,t),\n                           map(pos+e.yxy,t)-map(pos-e.yxy,t),\n                           map(pos+e.yyx,t)-map(pos-e.yyx,t) ) );\n}\n\nfloat castShadow( in vec3 ro, vec3 rd, float time )\n{\n    float res = 1.0;\n    float t = 0.;\n    for( int i=0; i< 100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos, time);\n        res = min( res, 16.0*h/t );\n        if ( res<0.0001 ) break;\n        t += h;\n        if( t > 10.0 ) break;\n    }\n\n    return clamp(res,0.0,1.0);\n} \n\nstruct hit {\n    float t;\n    float occl;\n    float minDist;\n    int minMaterialId;\n};\n\nhit castRay( in vec3 ro, vec3 rd, float time )\n{\n    float m = -1.0;\n    float t = 0.01;\n    float minDist = inf;\n    int minMaterialId = -1;\n    int i=0;\n    for(i=0; i<60; i++)\n    {\n        float precis = 0.0001 * t;\n        vec3 pos = ro + t*rd;\n\n        float h = map( pos, time );\n        if(h < minDist) {\n            minMaterialId = materialId;\n        }\n        minDist = min(h, minDist);\n        if(h < precis)\n            break;\n        t += h;\n        if (t > 20.0)\n            break;\n    }\n    return hit(t, 1. - float(i) / 60., minDist, minMaterialId);\n}\n\n// https://iquilezles.org/articles/biplanar\n// \"p\" point being textured\n// \"n\" surface normal at \"p\"\n// \"k\" controls the sharpness of the blending in the transitions areas\n// \"s\" texture sampler\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k ) {\n    vec4 x = texture( s, p.yz );\n    vec4 y = texture( s, p.zx );\n    vec4 z = texture( s, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n    return (x*w.x + y*w.y + z*w.z) / (w.x + w.y + w.z);\n}\n\nvec3 calcRayDirection(in vec2 p, in vec3 ta, in vec3 ro) {\n    vec3 ww = normalize( ta-ro );\n    vec3 uu = normalize( cross(ww, vec3(0,1,0)) );\n    vec3 vv = normalize( cross(uu,ww) );\n    return normalize( p.x*uu + p.y*vv + 1.8*ww );\n}\n\nvec3 matSphere(in vec3 pos, in vec3 rd, in vec3 nor, float time) {\n    vec3 mate = vec3(0);\n    vec3 refl = reflect(rd, nor);\n    mate = mix(mate, texture(iChannel0, refl).rgb, 0.75);\n    return mate;\n}\n\nvec3 matFloor(in vec3 pos, in vec3 nor, in vec3 rd, float time) {\n    vec3 mate = vec3(.9); \n    \n    vec3 refl = reflect(rd, nor);\n    hit hit = castRay(pos + nor*0.1, refl, time);\n    if(hit.t > 20.) {\n        mate = mix(mate, texture(iChannel0, refl).rgb, 0.5);\n    }\n    else {\n        if(materialId == MAT_OBJ1 || materialId == MAT_OBJ2) {\n            vec3 rpos = pos + hit.t*refl;\n            vec3 rnor = calcNormal(rpos, time);\n            mate = mix(mate, matSphere(rpos, rnor, rd, time), 0.5);\n        }\n    }\n    \n    float s = 8.;\n    float w = 0.025;\n    if(fract(pos.x*s) < w || fract(pos.z*s) < w) {\n        mate *= 0.9;\n    }\n    return mate;\n}\n\nvec3 calcMaterial(in vec3 pos, in vec3 nor, in vec3 rd, float time) {\n    vec3 mate = vec3(1); \n    if     (materialId == MAT_FLOOR)  mate = matFloor(pos, nor, rd, time);\n    else if(materialId == MAT_OBJ1)   mate = matSphere(pos, nor, rd, time);\n    else if(materialId == MAT_OBJ2)   mate = matSphere(pos, nor, rd, time);\n    return mate;\n}\n\nvec3 calcBRDF(in vec3 pos, in vec3 nor, in vec3 ro, in vec3 rd, float occl, float time) {\n    vec3  light1 = vec3(0.3, 1.0, -1 );\n    vec3  light2 = vec3(-2, 2, 3 );\n    float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n    float bac = clamp( dot( light2, nor ), 0.0, 1.0 );\n    float amb = (0.7+0.3*nor.y);\n    float shadow = clamp(castShadow(pos + nor*0.05, light1 - pos, time), 0., 1.);\n    \n    float shininess = 32.;\n    vec3 v = ro - pos;\n    vec3 l1 = light1 - pos;\n    vec3 l2 = light2 - pos;\n    float spec = 0.;\n\n    if(dot(nor,l1) > 0.) {\n        vec3 halfDir = normalize(l1 + v);\n        float specAngle = max(dot(halfDir, nor), 0.0);\n        spec += pow(specAngle, shininess);\n    }\n    \n    if(dot(nor, l2) > 0.) {\n        vec3 halfDir = normalize(l2 + v);\n        float specAngle = max(dot(halfDir, nor), 0.0);\n        spec += pow(specAngle, shininess);\n    }\n    \n    vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb;\n    brdf += 1.0*vec3(255, 248, 230)/255.*key*occl*shadow;\n    brdf += 1.0*vec3(230, 248, 255)/255.*bac*occl*shadow;\n    brdf += vec3(255, 248, 230)/255. * spec;\n    \n    return brdf;\n}\n\nvec3 calcColor(vec3 ro, vec3 rd, hit hit, float time) {\n    vec3 col = vec3(0);\n    float t = hit.t;\n    float occl = hit.occl;\n\n    if(t < 20.)\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, time);\n        vec3 mate = calcMaterial(pos, nor, rd, time);\n        vec3 brdf = calcBRDF(pos, nor, ro, rd, occl, time);\n        col = mate * brdf * exp(-0.6*t);\n    }\n    else {    \n        col = texture(iChannel0, rd).rgb;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    float time = iTime * 0.3;\n\n    vec3 col = vec3(0);\n    vec3 result = vec3(0);\n    \n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n        vec2 p = (2.*(U + vec2(aax, aay) / AA)-R)/R.y;\n        \n        vec3 ta = vec3(0,0.28,0);\n        vec3 ro = vec3(0, 0.5, -0.6);\n        ro.xz *= rot(time);\n        \n        vec3 rd = calcRayDirection(p, ta, ro);\n        hit hit = castRay(ro, rd, time);\n        vec3 col = calcColor(ro, rd, hit, time);\n\n        result += clamp(col, 0.0, 1.0);\n    }\n\n    col = pow(result/(AA*AA), vec3(0.4545));\n    O = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}