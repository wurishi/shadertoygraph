{"ver":"0.1","info":{"id":"3tfXWX","date":"1564438752","viewed":289,"name":"kind of cornell box","username":"bitnenfer","description":"Small test, it takes for ever to converge barely.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","cornell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    #if OLD_ACCUMULATOR\n    fragColor = vec4(texture(iChannel0, fragCoord.xy / iResolution.xy).rgb,1);\n\t#else\n    vec4 pixel = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    fragColor.rgb = pixel.rgb / pixel.a;\n    #endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define E 0.001\n#define MAX_DIST 200.0\n#define MIN_DIST E\n#define PI 3.14159265359\n\nstruct Material\n{\n    int emissive;\n    float reflective;\n    vec3 color;\n};\n\nstruct SceneData\n{\n    float dist;\n    Material material;\n};\n\nconst Material kInvMat = Material(0, 0.0, vec3(0.0));\nconst Material kWallMat = Material(0, 1.2, vec3(1.0));\nconst Material kBoxMat = Material(0, 1.2, vec3(1.0));\nconst Material kSphereMat = Material(0, 0.9, vec3(1.0));\nconst Material kRedMat = Material(0, 1.2, vec3(1.0, 0.0, 0.0));\nconst Material kGreenMat = Material(0, 1.2, vec3(0.0, 1.0, 0.0));\nconst Material kBlueMat = Material(0, 1.2, vec3(0.0, 0.0, 1.0));\nconst Material kEmissiveMat = Material(1, 1.0, 20.0 * vec3(1.3, 1.2, 1.0));\n\nfloat SEED = 0.0;\nvec2 UV;\n\nfloat hash( float n )\n{\n    return fract(sin(n + SEED)*43758.5453);\n}\n\nfloat random() {\n\n    return hash(fract(sin(dot(UV, vec2(12.9898, 78.233)) * (SEED += 1.0)) * 43758.5453));\n}\n\nvec3 randomUnitVector()\n{\n    float theta = random() * (PI*2.0);\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\n\nmat2 rot(float r)\n{\n    float cr = cos(r);\n    float sr = sin(r);\n    return mat2(cr, sr, -sr, cr);\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nSceneData opOR(in SceneData a, in SceneData b)\n{\n    if (a.dist < b.dist)\n    {\n        return a;\n    }\n    return b;\n}\n\nSceneData opNOT(in SceneData a, in SceneData b)\n{\n    if (a.dist > -b.dist)\n    {\n        return a;\n    }\n    return b;\n}\n\nSceneData map(vec3 p)\n{\n    p.z -= 9.0;\n    SceneData front = SceneData(box(p + vec3(0.0, 0.0, -3.0), vec3(3.1, 3.1, 0.1)), kWallMat);\n    SceneData back = SceneData(box(p + vec3(0.0, 0.0, 12.2), vec3(3.1, 3.1, 0.1)), kBlueMat);\n    SceneData left = SceneData(box(p + vec3(3.0, 0.0, 0.0), vec3(0.1, 3.1, 14.02)), kRedMat);\n    SceneData right = SceneData(box(p + vec3(-3.0, 0.0, 0.0), vec3(0.1, 3.1, 14.02)), kGreenMat);\n    SceneData bottom = SceneData(box(p + vec3(0.0, 3.0, 0.0), vec3(3.1, 0.1, 14.0)), kWallMat);\n    SceneData top = SceneData(box(p + vec3(0.0, -2.8, 0.0), vec3(3.1, 0.02, 14.0)), kWallMat);\n    SceneData topLight = SceneData(box(p + vec3(0.0, -3.75, 2.0), vec3(1.0, 1.0, 1.0)), kEmissiveMat);\n    \n    vec3 p1 = p + vec3(1.0, 1.0, -0.9);\n    vec3 p2 = p + vec3(-1.0, 2.0, 1.75);\n    \n    p1.xz *= rot(0.4);\n    p2.xz *= rot(-0.4);\n    \n    SceneData boxes = SceneData(\n        min(\n            box(p1, vec3(0.8, 2.0, 0.8)),\n            box(p2, vec3(0.8, 1.0, 0.8))\n        )\n    , kBoxMat);\n    \n    SceneData sphere = SceneData(\n        length(p + vec3(1.0, 2.0, 1.0)) - 1.0,\n        kSphereMat\n    );\n    \n    SceneData scene = opOR(front, left);\n    scene = opOR(scene, topLight);\n    scene = opOR(scene, back);\n    scene = opOR(scene, right);\n    scene = opOR(scene, bottom);\n    scene = opOR(scene, top);\n    scene = opOR(scene, boxes);\n    scene = opOR(scene, sphere);\n    \n    return scene;\n}\n\nvec3 norm(vec3 p)\n{\n    const vec2 ep = vec2(0.0, E);\n    return normalize(vec3(\n        map(p + ep.yxx).dist - map(p - ep.yxx).dist,\n        map(p + ep.xyx).dist - map(p - ep.xyx).dist,\n        map(p + ep.xxy).dist - map(p - ep.xxy).dist\n    ));\n}\n\nSceneData raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    SceneData sceneOutput = SceneData(MAX_DIST, kInvMat);\n    for (int i = 0; i < 90; ++i)\n    {\n        SceneData scene = map(ro + rd * t);\n        if (scene.dist < MIN_DIST)\n        {\n            sceneOutput = SceneData(t, scene.material);\n            break;\n        }\n        t += scene.dist;\n        if (t > MAX_DIST)\n        {\n            break;\n        }\n    }\n    return sceneOutput;\n}\n\n\n#define RAY_BOUNCES 5\nvec3 raytrace(in vec2 uv)\n{\n    vec3 ro = vec3(uv, 0.0);\n    vec3 rd = normalize(vec3(uv, 2.5));\n    vec3 color = vec3(0.0);\n    vec3 matColor = vec3(0.0);\n    float atten = 1.0;\n    float bounces = 1.0;\n    float rx = (iMouse.x / iResolution.x * 2.0 - 1.0) * (PI * 2.0);\n    float ry = (iMouse.y / iResolution.y * 2.0 - 1.0) * (PI * 2.0);\n   \tmat2 rxm = rot(rx);\n    mat2 rym = rot(ry);\n    \n    ro.yz *= rym;\n   \trd.yz *= rym;\n    \n    ro.xz *= rxm;\n    rd.xz *= rxm;\n    \n    for (int i = 0; i < RAY_BOUNCES; ++i)\n    {\n        SceneData scene = raymarch(ro, rd);\n        if (scene.material.emissive == 0)\n        {\n        \tvec3 p = ro + rd * scene.dist;\n            vec3 n = norm(p);\n\n            if (scene.material.reflective < 1.0)\n            {\n                vec3 d = normalize(reflect(rd, n)) + randomUnitVector() * 0.5;\n                vec3 o = p + d * 0.1;\n                SceneData refScene = raymarch(o, d);\n                atten *= 0.5;\n                matColor += (refScene.material.color * atten);\n                bounces += 1.0;\n            }\n            rd = n + randomUnitVector() * scene.material.reflective;\n            ro = p + rd * 0.1;\n            matColor += (scene.material.color) * atten;\n            bounces += 1.0;                        \n            atten *= 0.5;\n        }\n        else\n        {\n            color = mix(scene.material.color, matColor * scene.material.color, max(0.0, float(i)));\n            break;\n        }\n\n    }\n    \n    color /= bounces;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    UV = fragCoord.xy / iResolution.xy;\n    SEED = (iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y);\n    SEED += iTime+(UV.x+iResolution.x*UV.y)*1.51269341231;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    vec2 jitter = pixelSize * ((random()*2.0-1.0)*1.5);\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * ar;\n    vec4 color = vec4(raytrace(uv + jitter), 1.0);\n    \n    #if OLD_ACCUMULATOR\n    vec4 prevColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    float frames = 1.0 / float(iFrame + 1);\n    if (iFrame > 1)\n        color.rgb = mix(prevColor.rgb, color.rgb, frames);\n    fragColor = color;\n\t#else\n    // Stole this from xy's penrose pathracer.\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n    if (iMouse.z > 0.) fragColor *= 0.;\n    fragColor += color;\n    #endif\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define OLD_ACCUMULATOR 0","name":"Common","description":"","type":"common"}]}