{"ver":"0.1","info":{"id":"tdsSWj","date":"1552246114","viewed":62,"name":"Task_1","username":"kinzyabaev_i","description":"mash_graph","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//константы максимального числа шагов в ray_march, расстояние до гранифы области, константы для света\n#define STEP 100\n#define SURF 0.01\n#define DIST 60.\n\n/////////////////////////Функции для вращения глаза по кругу//////////////////////////////////\nmat2 Rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n/////////////////////////////////////Примитивы///////////////////////////////////////////////////\nfloat sdSphere(vec3 p) {\n    vec4 Spherechr = vec4(0, 1, 6, 1);\n\treturn length(p - Spherechr.xyz) - Spherechr.w;\n}\n\nfloat displacement(vec3 p) {\n    return (exp(- (p.x*p.y*p.z + 8.) * 6.) );\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = sdTorus(p, vec2(1.0, 0.5));\n    float d2 = displacement(p);\n    return d1+d2;\n}\n\n\nfloat udBox( vec3 p)\n{\n    vec3 b = vec3(1., 1., 1.);\n    vec3 boxPos = vec3(4, 1, 6);\n  \treturn length(max(abs(p - boxPos)-b,0.0));\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n/////////////////////////////Функция дистанции////////////////////////////////////////////////////\nvec2 obj_distance(vec3 p) {\n    float t = iTime;\n    \n\t//Плоскость\n    float planeDist = p.y;\n    \n    //Прыгающий тор\n    float y = -fract(t)*(fract(t)-1.);\t\t\n    vec3 tp = p;\n    tp -= vec3(-2, .8+3.*y, -4);\t\t\t\t\t\n    float squash = 1.+smoothstep(.15, .0, y)*.5;\n    tp.y *= squash;\n    tp = tp.xzy;\t\t\t\t\t\t\t\t\n    float scale = sdTorus(tp, vec2(1, .25))/squash;\n    \n\t//Квадрат, который превращается в кружок\n    float morph = mix(\n        length(p-vec3(4,1,2))-1., \n        dBox(p-vec3(4,1,2), vec3(1,1,1)), \n        sin(t)*.5+.5\n    );\n    \n\t//Примитивы попроще\n    float sphere = sdSphere(p);\n    float box = udBox(p);\n    float disp = opDisplace(p);\n    \n    float fklvavhrb = min(min(min(min(min(sphere, planeDist), box), scale), morph), disp);\n    \n    //возвращаем все объекты с флагами цветов\n    if (fklvavhrb == sphere) {\n        return vec2(1.0, sphere);\n    } else if (fklvavhrb == box) {\n        return vec2(2.0, box);\n    } else if (fklvavhrb == disp) {\n        return vec2(3.0, disp);\n\t} else if (fklvavhrb == scale) {\n        return vec2(4.0, scale);\n    } else if (fklvavhrb == morph) {\n        return vec2(5.0, morph);\n    } else {\n        return vec2(0.0, planeDist);\n    }\n}\n\n///////////////////////////////////Нормаль//////////////////////////////////////////////////////\nvec3 normal(vec3 p) {\n\tfloat d = obj_distance(p).y;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        obj_distance(p-e.xyy).y,\n        obj_distance(p-e.yxy).y,\n        obj_distance(p-e.yyx).y);\n    \n    return normalize(n);\n}\n\n/////////////////////////Сама функция RAY MARCHING///////////////////////////////////////////\nvec2 ray_march(vec3 eye, vec3 ray_dir) {\n\tfloat sum_dist = 0.;\n    vec2 dist1;\n    \n    for(int i = 0; i < STEP; ++i) {\n    \tvec3 p = eye + ray_dir * sum_dist;\n        dist1 = obj_distance(p);\n        float dist = dist1.y;\n        sum_dist += dist;\n        if (sum_dist > DIST) return vec2(dist1.x, sum_dist);\n        if (dist < SURF) return vec2(dist1.x, sum_dist);\n    }\n    \n    return vec2(dist1.x, sum_dist);\n}\n\n//////////////////////////////////Функция получения света////////////////////////////////////////////////////////////\nfloat Light(vec3 p) {\n    vec3 Light1 = vec3(0., 5., 3.);\n    vec3 l1 = normalize(Light1 - p);\n    vec3 n1 = normal(p);\n    \n    float dif_1 = clamp(dot(n1, l1), 0., 1.);\n    vec2 dist_1 = ray_march(p + n1 * SURF * 2., l1);\n    float d_1 = dist_1.y;\n    if(d_1<length(Light1 - p)) dif_1 *= .1;\n    \n    vec3 Light2 = vec3(0., 5., 3.);\n    Light2.xz += vec2(-sin(iTime)*6., -cos(iTime))*6.;\n    vec3 l2 = normalize(Light2-p);\n    vec3 n2 = normal(p);\n    \n    float dif_2 = clamp(dot(n2, l2), 0., 1.);\n    vec2 dist_2 = ray_march(p + n2 * SURF * 2., l2);\n    float d_2 = dist_2.y;\n    if(d_2<length(Light2-p)) dif_2 *= .1;\n    \n    dif_1 = dif_1 * 30. / ((length (Light1 - p) + 1.) * length (Light1 - p) );\n    dif_2 = dif_2 * 30. / ((length (Light2 - p) + 1.) * length (Light2 - p) );\n\n\n    return ((dif_2 + dif_1) / 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t//используем мышку для поворота экрана\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    vec3 col = vec3(0);\n    //вращаем экрана\n    float t = iTime/20.;\n    vec3 ro = vec3(0, 3, -11.);\n    ro.yz *= Rot(-m.y+.4);\n    ro.xz *= Rot(iTime*.2-m.x*6.2831);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    rd = R(uv, ro, vec3(0,0,0), .7);\n    //получаем расстояние до ближайшего объекта\n    vec2 d = ray_march(ro, rd);\n    \n    vec3 p = ro + rd * d.y;\n    //получаем свет\n    float dif = Light(p);\n    //разукрашиваем все наши объекты по цветам\n    if (d.x == 1.0) {\n        col = vec3(dif, 0., 0.);\n    } else if (d.x == 2.0) {\n        col = vec3(0., dif, 0.);\n    } else if (d.x == 3.0) {\n        col = vec3(0., 0., dif);\n    } else if (d.x == 4.0) { \n        col = vec3(dif, dif, 0.);\n    } else if (d.x == 5.0) {\n        col = vec3(dif, 0., dif);\n    } else {\n        col = vec3(dif);\n    }\n    \n    //получаем результат\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}