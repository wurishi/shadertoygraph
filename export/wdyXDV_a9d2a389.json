{"ver":"0.1","info":{"id":"wdyXDV","date":"1575005738","viewed":220,"name":"Basic raymarching test","username":"CoolerZ","description":"Basic raymarching with Phong lighting model.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// distance function starting with sd in the name were taken from https://iquilezles.org/articles/distfunctions\n\nfloat circle_d(vec2 uv)\n{\n    return length(uv);\n}\n\nfloat circle_m(vec2 uv)\n{\n    return smoothstep(1., .95, circle_d(uv));\n}\n\nfloat sphere_d(vec3 p)\n{\n    return length(p) - 1.;\n}\n\nvec3 trans(vec3 xyz, vec3 pos, float scale)\n{\n    return (xyz - pos) * scale;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat inside_out_box(vec3 p, vec3 b)\n{\n    return -sdBox(p, b);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 scene_d(vec3 p)\n{\n    vec3 box_dims = vec3(4.);\n    float db = inside_out_box(p, box_dims);\n    float ds = sphere_d(p);\n    vec3 cylinder_pos = vec3(0., -2., 0.);\n    float dc = sdCappedCylinder(p - cylinder_pos, 1., 1.);\n\n    vec2 ret = opU(vec2(db, DIFFUE_MATERAIL), vec2(ds, SHINY_MATERIAL));\n    ret = opU(ret, vec2(dc, SHINY_MATERIAL));\n    return ret;\n}\n\nvec3 scene_normal(vec3 p)\n{\n    float m_x = scene_d(p + vec3(-EPSILON, 0., 0.)).x;\n    float p_x = scene_d(p + vec3( EPSILON, 0., 0.)).x;\n\n    float m_y = scene_d(p + vec3(0., -EPSILON, 0.)).x;\n    float p_y = scene_d(p + vec3(0.,  EPSILON, 0.)).x;\n\n    float m_z = scene_d(p + vec3(0., 0., -EPSILON)).x;\n    float p_z = scene_d(p + vec3(0., 0.,  EPSILON)).x;\n\n    vec3 diffs = vec3((p_x - m_x), (p_y - m_y), (p_z - m_z));\n\n    return normalize(diffs / (2. * EPSILON));\n}\n\nvec3 circle_around_in_xz_plane(vec3 pos, float radius, float angle)\n{\n    vec3 offset = vec3(cos(angle), 0., sin(angle)) * radius;\n    return pos + offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5)/(iResolution.xy - 1.); // 0 to 1\n    uv = 2. * uv - 1.; // -1 to 1\n    uv.x *= iResolution.x/iResolution.y; // correct for aspect ratio.\n    \n    // vec2 mouse = iMouse.xy / iResolution.xy;\n\n    // test whether uvs are normalized properly\n\t// vec3 col = vec3(0.);\n    // col = mix(col, vec3(1.), circle_m(uv));\n\n    vec3 c_pos     = circle_around_in_xz_plane(vec3(0.), 2., sin(iTime) + iTime); // camera position.\n    c_pos.y += sin(PI * iTime / 10.) + 0.5 * cos(PI * iTime / 7.) + 1.;\n    vec3 c_look_at = vec3(0.); // what the camera is looking at.\n\n    vec3 c_dir     = normalize(c_look_at - c_pos); // camera direction.\n    float s_dist   = 1.; // how far in front of the camera the screen is located.\n    vec3 s_pos     = c_pos + c_dir * s_dist; // screen position.\n    vec3 world_up  = vec3(0., 1., 0.); // positive Y axis is up direction.\n    vec3 s_right   = normalize(cross(c_dir, world_up)); // screen right direction. can have problems when looking straight up or down.\n    vec3 s_up      = normalize(cross(s_right, c_dir)); // screen up direction.\n    vec3 pixel_pos = s_pos + s_right * uv.x + s_up * uv.y;\n    vec3 ray_dir   = normalize(pixel_pos - c_pos);\n\n    float d = 0.; // distance along the ray.\n    vec2 dist_material;\n    vec3 curr_pos;\n\n    for(int i = 0; i < MAX_ITERATIONS; ++i)\n    {\n        curr_pos = c_pos + ray_dir * d;\n        // dist_to_closest = sphere_d(trans(curr_pos, sphere_pos, sphere_scale));\n        dist_material = scene_d(curr_pos);\n\n        if(dist_material.x <= EPSILON)break;\n\n        d += dist_material.x;\n    }\n\n    vec3 col = vec3(0.);\n    vec3 light_pos = vec3(0., 3., -1.);\n    // vec3 light_pos = c_pos;\n\n    if(dist_material.x <= EPSILON)\n    {\n        int material = int(dist_material.y);\n        // Phong lighting model as given here https://www.fabrizioduroni.it/2017/07/26/phong-lighting-model.html\n        // emissive component\n        float k_e = 0.;\n        vec3 I_le = vec3(1.);\n        vec3 I_emissive = k_e * I_le;\n\n        // ambient component\n        float k_a = .2;\n        vec3 I_la = vec3(1.);\n        vec3 I_ambient = k_a * I_la;\n\n        vec3 I_diffuse = vec3(0.);\n        vec3 I_specular = vec3(0.);\n\n        vec3 normal        = scene_normal(curr_pos);\n        vec3 incident_dir  = normalize(curr_pos - light_pos);\n        float diffuse_attn = dot(-incident_dir, normal);\n\n        if(diffuse_attn > 0.)\n        {\n            // diffuse component\n        \tfloat k_d = material == SHINY_MATERIAL ? .25 : .5;\n        \tvec3 I_ld = material == SHINY_MATERIAL ? CYAN : RED;\n        \tI_diffuse = k_d * I_ld * diffuse_attn;\n\n            // specular component\n            vec3 reflected_dir  = reflect(incident_dir, normal);\n        \tvec3 view_dir       = normalize(c_pos - curr_pos);\n            float specular_attn = max(0., dot(view_dir, reflected_dir));\n            float shininess     = material == SHINY_MATERIAL ? 10. : .1;\n            float k_s           = material == SHINY_MATERIAL ? 1.  : .1;\n            vec3 I_ls           = vec3(1.);\n            I_specular     = k_s * I_ls * pow(specular_attn, shininess);\n        \t\n        }\n\n        col = I_emissive + I_ambient + I_diffuse + I_specular;\n\n        // Inspect normals\n        // col = normal;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265\n\n#define EPSILON 0.01\n#define MAX_ITERATIONS 100\n\n#define SHINY_MATERIAL 1\n#define DIFFUE_MATERAIL 2\n\n#define WHITE vec3(1.)\n#define RED vec3(1., 0., 0.)\n#define GREEN vec3(0., 1., 0.)\n#define BLUE vec3(0., 0., 1.)\n#define CYAN vec3(0., 1., 1.)\n","name":"Common","description":"","type":"common"}]}