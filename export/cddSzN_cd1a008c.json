{"ver":"0.1","info":{"id":"cddSzN","date":"1679481158","viewed":101,"name":"CG Praktikum Projekt","username":"JuliusSchellenberg","description":"Projektaufgabe CG Praktikum. Eine Welt mit Terrain und Wolken.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["cgpraktikum"],"hasliked":0,"parentid":"DdtXRn","parentname":"Obj+Kam+Keyb"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool intersectSphere(Point3 C, float r, vec3 eye, vec3 dir, inout float nearDistance, inout float farDistance) { \n    Point3 P = eye; \n    Vector3 w = dir; \n    Vector3 v = P - C; \n    float b = 2.0 * dot(w, v); \n    float c = dot(v, v) - square(r); \n    float d = square(b) - 4.0 * c; if (d < 0.0) { return false; } \n    float dsqrt = sqrt(d); \n    float t0 = infIfNegative((-b - dsqrt) * 0.5); \n    float t1 = infIfNegative((-b + dsqrt) * 0.5); \n    nearDistance = min(t0, t1); \n    farDistance  = max(t0, t1); \n    return (nearDistance < inf); \n}\n\nfloat cloudDensity(Point3 X, float t) {\n    Point3 p = X * vec3(1.5, 2.5, 2.0);\n\treturn fbm5(p + 1.5 * fbm3(p - t * 0.047) - t * vec3(0.03, 0.01, 0.01)) - 0.42;\n}\n\nconst Vector3     w_i             = Vector3(1.0, 1.3, 0.6) / 1.7464;\nconst Biradiance3 B_i             = Biradiance3(2.9);\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\n \nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    //samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    //float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7)) / 2.0;\n    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    \n    float cube = boxSDF(samplePoint, vec3(0.5 + 4.0 * abs(cos(iTime)), 0.5 + 4.0 * abs(sin(iTime)), 1.8));\n    \n    float sphere = sphereSDF(samplePoint, CLOUD_RADIUS);\n    \n    return sphere;\n}\n \nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n \nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n                          \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return (k_d * dotLN);\n    }\n    \n    float lambertian = max(dot(N, L), 0.0);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n        specular = pow(max(dot(R,V), 0.0),alpha);\n    }\n    \n    return lambertian*k_d + specular*k_s;\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3( 5.0 + 3.0 * sin(iTime),\n                          5.0,\n                          5.0 + 3.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += clamp(phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity), 0., 1.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offset = texelFetch( iChannel1, ivec2(0, 0), 0).xy;\n    float radius = 10.;\n    float phi = offset.x;\n    float theta = offset.y;\n    \n    vec3 eye = radius * normalize(vec3(sin(phi), sin(theta), cos(phi)));\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n\n    float nearSphere, farSphere;\n    \n    vec4 result = vec4(.0);\n    vec4 image = texelFetch( iChannel0, ivec2(fragCoord), 0);\n    vec3 color = image.xyz;\n    float dist = image.w; \n    vec4 phong;\n    if (intersectSphere(vec3(0), CLOUD_RADIUS, eye, worldDir, nearSphere, farSphere)) {\n    \n        const float  stepSize = 0.052;\n        const Color3 cloudColor = Color3(0.15);\n        \n        vec3 farHitPoint = eye + worldDir * farSphere;\n        \n        float t = farSphere > dist ? dist : farSphere;\n        for (int i = 0; i < MAX_MARCHING_STEPS; ++i) {\n            if (t > nearSphere) {\n                Point3 X = ((worldDir * t + eye));\n                float distToCenter = length(X);\n                // Sample the clouds at X\n                // vec4 phong = vec4(phongIllumination(vec3(0.1), vec3(0.5), vec3(1.0), 0.0, X, eye), 1.0); \n                float density = (cloudDensity(X, 2.0 * iTime)) / 40.0;\n            \n                if (density > 0.0) {\n\n                    //(-((distToCenter - RADIUS)/(CLOUD_RADIUS - RADIUS)) + 1.0\n                    if (distToCenter > RADIUS ) {\n                        result += max((1.0 - (distToCenter - RADIUS - 0.1) / (CLOUD_RADIUS - RADIUS - 0.1)) * (density), 0.0);\n                    } else {\n                        result += 4.0 * (density);// mix(result, vec4(L_o, 1.0), density * 0.5);\n                    }\n                \n                    // Step more slowly through empty space\n                    t += stepSize * 2.0;\n                } \n            \n                t -= stepSize * 3.0;\n            } else {\n                break;\n            }\n        }\n        phong = vec4(phongIllumination(vec3(.2), vec3(.8), vec3(1.0), 30.0, worldDir * nearSphere + eye, eye), 1.0);\n    }\n\n    fragColor = max(10.0 * result - vec4(0.2), vec4(0.0)) * phong + image;\n    //fragColor = image + result;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    offset += (left + up + right + down) * velocity;\n\n    \n    offset.y = clamp(offset.y, -1.5, 1.5);\n\n    return offset;\n}\n\nvec2 handleMouse(vec2 offset) {\n    vec4 m = iMouse / iResolution.x;\n    vec4 oldMouse = texelFetch( iChannel0, ivec2(2, 1), 0);\n    if (oldMouse.z > 0.0) {\n        offset += -1.0 * (m.xy - oldMouse.xy);\n    }\n    \n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(1, 2), 0).xy;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n    //if (offset.y < -1.5) offset.y = -1.5;\n    //if (offset.y > 1.5) offset.y = 1.5;\n\n    offset = handleMouse(offset);\n    //offset += vec2(-0.5, -0.5) + texelFetch( iChannel2, ivec2(0, 0), 0).xy;\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    if (fragCoord.x > 0.1 && fragCoord.x < 1.9) {\n        fragColor = vec4(offset, 0, 0);\n    }\n    else if (fragCoord.y > 0.1 && fragCoord.y < 1.9) {\n        vec4 m = iMouse / iResolution.x;\n        fragColor = m;\n    }\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"///////////////////////////////////////////////////////////////////////////////////\n// Constants etc.\n#define Vector2      vec2\n#define Point3       vec3\n#define Vector3      vec3\n#define Color3       vec3\n#define Radiance3    vec3\n#define Radiance4    vec4\n#define Irradiance3  vec3\n#define Power3       vec3\n#define Biradiance3  vec3\n\nconst float RADIUS = 1.5f;\nconst float CLOUD_RADIUS = RADIUS + 0.2;\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.1;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.0001;\nconst float pi          = 3.1415926535;\nconst float degrees     = pi / 180.0;\nconst float inf         = 1.0 / 1e-10;\n\nfloat square(float x) { return x * x; }\nfloat pow3(float x) { return x * square(x); }\nfloat pow4(float x) { return square(square(x)); }\nfloat pow8(float x) { return square(pow4(x)); }\nfloat pow5(float x) { return x * square(square(x)); }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\nstruct Ray { Point3 origin; Vector3 direction; };\t\nstruct Material { Color3 color; float metal; float smoothness; };\nstruct Surfel { Point3 position; Vector3 normal; Material material; };\nstruct Sphere { Point3 center; float radius; Material material; };\n   \n   \nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\nDEFINE_FBM(fbm5, 5)\nDEFINE_FBM(fbm6, 6)\n\n/////////////////////////////////////////////////////////////////////////////////////\n// Rotate\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n// SDF Functions\n\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat planeSDF(vec3 p, float h) {\n    return p.y - h;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n//Generation settings\n#define NOISE_ALPHA_MULTIPLIER 0.5\n#define NOISE_SIZE_MULTIPLIER 1.8\n\n//Uncomment to disable fog shape animation over time\n#define MUTATE_SHAPE\n\n//Rendering settings\n\n#define RAYS_COUNT 10\n#define STEP_MODIFIER 1.0175\n#define SHARPNESS 0.02\n#define NOISE_LAYERS_COUNT 3.0\n#define JITTERING 0.08\n\n#define DITHER 0.3\n#define NEAR_PLANE 0.6\n#define RENDER_DISTANCE 4.0\n\n//Colors\n#define BRIGHTNESS 1.0\n#define COLOR1 vec3(0.03, .2, 0.1)\n#define COLOR2 vec3(.8, 0.8, 0.8)\n\n//Camera and time\n#define TIME_SCALE 1.0\n#define CAMERA_SPEED 0.02\n#define CAMERA_ROTATION_SPEED 0.06\n#define FOG_CHANGE_SPEED 0.02\n\nfloat hash(vec3 v)\n{\n \treturn fract(sin(dot(v, vec3(11.51721, 67.12511, 9.7561))) * 1551.4172);   \n}\n\nfloat getNoiseFromVec3(vec3 v)\n{\n\tvec3 rootV = floor(v);\n    vec3 f = smoothstep(0.0, 1.0, fract(v));\n    \n    //Cube vertices values\n    float n000 = hash(rootV);\n    float n001 = hash(rootV + vec3(0,0,1));\n    float n010 = hash(rootV + vec3(0,1,0));\n    float n011 = hash(rootV + vec3(0,1,1));\n    float n100 = hash(rootV + vec3(1,0,0));\n    float n101 = hash(rootV + vec3(1,0,1));\n    float n110 = hash(rootV + vec3(1,1,0));\n    float n111 = hash(rootV + vec3(1,1,1));\n    \n    //trilinear interpolation\n    vec4 n = mix(vec4(n000, n010, n100, n110), vec4(n001, n011, n101, n111), f.z);\n    n.xy = mix(vec2(n.x, n.z), vec2(n.y, n.w), f.y);\n    return mix(n.x, n.y, f.x);\n}\n\nfloat volumetricFog(vec3 v, float noiseMod)\n{\n    float noise = 0.0;\n    float alpha = 1.0;\n    vec3 point = v;\n    for(float i = 0.0; i < NOISE_LAYERS_COUNT; i++)\n    {\n        noise += getNoiseFromVec3(point) * alpha;\n     \tpoint *= NOISE_SIZE_MULTIPLIER;\n        alpha *= NOISE_ALPHA_MULTIPLIER;\n    }\n    \n    //noise = noise / ((1.0 - pow(NOISE_ALPHA_MULTIPLIER, NOISE_LAYERS_COUNT))/(1.0 - NOISE_ALPHA_MULTIPLIER));\n    noise *= 0.575;\n\n    //edge + bloomy edge\n#ifdef MUTATE_SHAPE\n    float edge = 0.1 + getNoiseFromVec3(v * 0.5 + vec3(iTime * 0.03)) * 0.8;\n#else\n    float edge = 0.5;\n#endif\n    noise = (0.5 - abs(edge * (1.0 + noiseMod * 0.05) - noise)) * 2.0;\n    return (smoothstep(1.0 - SHARPNESS * 2.0, 1.0 - SHARPNESS, noise * noise) + (1.0 - smoothstep(1.3, 0.6, noise))) * 0.2;\n}\n\n\nvec3 nearPlanePoint(vec2 v, float time)\n{\n \treturn vec3(v.x, NEAR_PLANE * (1.0 + sin(time * 0.2) * 0.4), v.y);   \n}\n\nvec3 fogMarch(vec3 rayStart, vec3 rayDirection, float time, float disMod)\n{\n    float stepLength = RENDER_DISTANCE / float(RAYS_COUNT);\n \tvec3 fog = vec3(0.0);   \n    vec3 point = rayStart;\n    \n    for(int i = 0; i < RAYS_COUNT; i++)\n    {\n     \tpoint += rayDirection *stepLength;\n        fog += volumetricFog(point, disMod) // Nebel\n            * mix(COLOR1, COLOR2 * (1.0 + disMod * 0.5), getNoiseFromVec3((point + vec3(12.51, 52.167, 1.146)) * 0.5)) // Farbe\n            * mix(1.0, getNoiseFromVec3(point * 40.0) * 2.0, DITHER) // Zittern\n            * getNoiseFromVec3(point * 0.2 + 20.0) * 2.0; // Löcher\n        \n        stepLength *= STEP_MODIFIER;\n    }\n    \n    // Damit sieht es noch besser aus ...\n   \tfog = (fog / float(RAYS_COUNT)) * (pow(getNoiseFromVec3((rayStart + rayDirection * RENDER_DISTANCE)), 2.0) * 3.0 + disMod * 0.5);\n\t\n    return fog;\n}\n\n//Getting kick volume from spectrum\nfloat getBeat()\n{\n \tfloat sum = 0.0;\n    for (float i = 0.0; i < 16.0; i++)\n    {\n     \tsum += texture(iChannel0, vec2(i * 0.001 + 0.0, 0.0)).r;   \n    }\n    return smoothstep(0.6, 0.9, pow(sum * 0.06, 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    float musicVolume = getBeat();\n    vec2 res = iResolution.xy;\n    vec2 uv = (2.0 * fragCoord - res) / res.x;\n    \n    // Bewege Kamera über Zeit, damit es sich bewegt\n    vec3 cameraCenter = vec3(sin(time * CAMERA_SPEED) * 10.0, time * CAMERA_SPEED * 10.0, cos(time * 0.78 * CAMERA_SPEED + 2.14) * 10.0);\n    \n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    float radius = 10.;\n    float phi = offset.x;\n    float theta = offset.y;\n    \n    vec3 eye = radius * normalize(vec3(sin(phi), sin(theta), cos(phi)));\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    //Creating random rotation matrix for camera\n    float angleY = sin(theta);\n    float angleX = sin(phi);\n    float angleZ = cos(phi);\n    //float angleY = sin(time * CAMERA_ROTATION_SPEED * 2.0 + phi);\n    //float angleX = cos(time * 0.712 * CAMERA_ROTATION_SPEED + phi);\n    //float angleZ = sin(time * 1.779 * CAMERA_ROTATION_SPEED + theta);\n    mat3 rotation =   mat3(1, 0, \t\t\t0,\n                           0, sin(angleX),  cos(angleX),\n                           0, -cos(angleX), sin(angleX))\n        \t\t\t* mat3(sin(angleZ),  cos(angleZ), 0,\n                           -cos(angleZ), sin(angleZ), 0,\n                           0, \t\t\t 0, \t\t  1)\n        \t\t\t* mat3(sin(angleY),  0, cos(angleY),\n                           0, \t\t\t 1, 0,\n                           -cos(angleY), 0, sin(angleY));\n    \n    vec3 rayDirection = rotation * normalize(nearPlanePoint(uv, time));\n    vec3 rayStart = rayDirection * 0.2 + cameraCenter;\t//Ray start with little clipping\n    \n    //Thanks to adx for jittering tip, looks and works really better with this line:\n    rayStart += rayDirection * (hash(vec3(uv + 4.0, fract(iTime) + 2.0)) - 0.5) * JITTERING;\n    \n    vec3 fog = fogMarch(eye + cameraCenter, worldDir, time, musicVolume);\n    \n    // Farbe und Helligkeit\n    fog *= 2.5 * BRIGHTNESS;\n    fog += 0.07 * mix(COLOR1, COLOR2, 0.5);\t//Colouring the darkness\n    fog = sqrt(smoothstep(0.0, 1.5, fog)); //Dealing with too bright areas (sometimes it happen)\n    \n    fragColor = vec4(fog * smoothstep(0.0, 10.0, iTime), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// 3D Gradient noise from: https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noiseS( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n#define CAMERA_SPEED 0.02\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time = iTime;\n    vec2 res = iResolution.xy;\n    vec2 uv = (2.0 * fragCoord - res) / res.x;\n    \n    //Random camera movement\n    vec3 cameraCenter = vec3(sin(time * CAMERA_SPEED) * 10.0, time * CAMERA_SPEED * 10.0, cos(time * 0.78 * CAMERA_SPEED + 2.14) * 10.0);\n    \n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    float radius = 10.;\n    float phi = offset.x;\n    float theta = offset.y;\n    \n    vec3 eye = radius * normalize(vec3(sin(phi), sin(theta), cos(phi)));\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    // Sterne:\n    vec3 stars_direction = normalize(worldDir); // drehen sich mit Kamera\n\tfloat stars_threshold = 6.5f; // Parameter anpassen, damit es gut aussieht\n\tfloat stars_exposure = 25.0f; \n    // Noise Funktion aufrufen\n\tfloat stars = pow(clamp(noiseS(stars_direction * 200.0f), 0.0f, 1.0f), stars_threshold) * stars_exposure;\n\t// Flickern über Zeit\n    stars *= mix(0.4, 1.4, noiseS(stars_direction * 100.0f + 0.5 * vec3(iTime))); \n\t\n    // Output to screen\n    fragColor = vec4(vec3(stars),1.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n * Copied from https://www.shadertoy.com/view/4tcGDr\n * Copied from https://www.shadertoy.com/view/lt3XDM\n */\nvec3 color = vec3(.5);\n    \nfloat sphereWithTerrainSDF(vec3 p, float r) {\n\n    \n    // Move to the planet's reference frame (ideally, we'd just trace in the \n    // planet's reference frame and avoid these operations per distance\n    // function evaluation, but this makes it easy to integrate with a\n    // standard framework)\n    vec3 X = p;\n    Point3 surfaceLocation = normalize(X);\n    \n    // Compute t = distance estimator to the planet surface using a spherical height field, \n    // in which elevation = radial distance\n    //\n\t// Estimate *conservative* distance as always less than that to the bounding sphere\n    // (i.e., push down). Work on range [0, 1], and then scale by planet radius at the end\n    \n\tfloat mountain = clamp(1.0 - fbm6(surfaceLocation * 4.0) + (max(abs(surfaceLocation.y) - 0.6, 0.0)) * 0.03, 0.0, 1.0);\n    mountain = pow3(mountain) * 0.25 + 0.8;\n    \n    const float water = 0.85;\n    float elevation = mountain;\n\t\n    if (elevation < water) {\n        float relativeWaterDepth = min(1.0, (water - mountain) * 30.0);\n        const float waveMagnitude = 0.0014;\n        const float waveLength = 0.006;\n\n        // Create waves. Shallow-water waves conform to coasts. Deep-water waves follow global wind patterns.\n        const Color3 shallowWaterColor = Color3(0.4, 1.0, 1.9);\n        // How much the waves conform to beaches\n        const float shallowWaveRefraction = 4.0;        \n        float shallowWavePhase = (surfaceLocation.y - mountain * shallowWaveRefraction) * (1.0 / waveLength);\n\n        const Color3 deepWaterColor = Color3(0, 0.1, 0.7);\n        float deepWavePhase    = (atan(surfaceLocation.z, surfaceLocation.x) + noise(surfaceLocation * 15.0) * 0.075) * (1.5 / waveLength);\n\n        float wave =  (cos(shallowWavePhase + iTime * 1.5) * sqrt(relativeWaterDepth) + \n            cos(deepWavePhase + iTime * 2.0) * 2.5 * (1.0 - abs(surfaceLocation.y)) * square(1.0 - relativeWaterDepth)) *\n            waveMagnitude;\n    \n        elevation = water + wave;        \n    }\n    \n    \n    float colorNoise = noise(surfaceLocation * 200.0);\n    float waterBorder = water;\n    float beachBorder = (waterBorder + 0.01) * (1.0 - 0.02 * colorNoise);\n    float greenBorder = (beachBorder + 0.04) * (1.0 - 0.02 * colorNoise);\n    float greyBorder = (greenBorder + 0.03) * (1.0 - 0.02 * colorNoise);\n    \n    vec3 waterColorLB = vec3(.05, .05, .3);\n    vec3 waterColorUB = vec3(.2, .4, 0.8);\n    vec3 beachColorLB = vec3(.8, 1.0, .1);\n    vec3 beachColorUB = vec3(.8, 1.0, .1);\n    vec3 greenColorLB = vec3(0.01, 0.08, 0.01);\n    vec3 greenColorUB = vec3(0.1, 0.8, 0.1);\n    vec3 greyColorLB = vec3(0.2);\n    vec3 greyColorUB = vec3(0.5);\n    vec3 whiteColorLB = vec3(.4, .4, .4);\n    vec3 whiteColorUB = vec3(1., 1., 1.);\n    \n    \n    // Coloring\n    if (mountain <= waterBorder) {\n        float relativeWaterDepth = min(1.0, (water - mountain) * 30.0);\n        color = mix(waterColorLB, waterColorUB, 1. - relativeWaterDepth);//mountain / (water * 30.0)); //< .98 ? 0.0 : 1.0);\n    } else if (mountain > waterBorder && mountain <= beachBorder) {\n        color = beachColorUB;\n    } else if (mountain > beachBorder && mountain <= greenBorder) {\n        color = mix(greenColorLB, greenColorUB, (mountain - beachBorder) / (greenBorder - beachBorder));\n    } else if (mountain > greenBorder && mountain <= greyBorder) {\n        color = greyColorLB;\n    } else if (mountain > greyBorder) {\n        color = whiteColorUB;\n    }\n        \n    elevation *= r;\n    \n    float sampleElevation = length(X);\n    float t = sampleElevation - elevation;\n    \n    \n    // Be a little more conservative because a radial heightfield is not a great\n    // distance estimator.\n    t *= 0.8;\n    return t;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    \n    return sphereWithTerrainSDF(samplePoint, RADIUS);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n            \n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n                          \n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return (k_d * dotLN);\n    }\n    \n    float lambertian = max(dot(N, L), 0.0);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n        specular = pow(max(dot(R,V), 0.0),alpha);\n    }\n    \n    return lambertian*k_d + specular*k_s;\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nfloat Shadow(vec3 origin,vec3 direction,float max_dist){\n    float min_dist=.00001;\n    float shadow=1.;\n    float k=8.;\n    float marching_distance=0.;\n    for(int i=0;i<100;i++){\n        float dist=sceneSDF(origin+marching_distance*direction);\n        shadow=min(shadow,k*dist/marching_distance);\n        marching_distance+=dist;\n        if(marching_distance>max_dist){\n            break;\n        }\n    }\n    return 0.25*(1.0+shadow)*(1.0+shadow)*(2.0-shadow);\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3( 5.0 + 3.0 * sin(iTime),\n                          5.0,\n                          5.0 + 3.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += clamp(phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity), 0., 1.);\n          \n    color *= clamp(Shadow(p, normalize(light1Pos - p), length(light1Pos - p)), 0., 1.);\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    float radius = 10.;\n    float phi = offset.x;\n    float theta = offset.y;\n    \n    vec3 eye = radius * normalize(vec3(sin(phi), sin(theta), cos(phi)));\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        vec3 background = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n        vec3 stars = texelFetch(iChannel2, ivec2(fragCoord), 0).xyz;\n        fragColor = vec4(stars + background, dist);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = (vec3(.1));\n    vec3 K_d = color;\n    vec3 K_s = vec3(1.);\n    float shininess = 50.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    vec3 background = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    \n    \n    fragColor = vec4(background + color, dist);\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}