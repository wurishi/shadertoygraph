{"ver":"0.1","info":{"id":"WtSBDt","date":"1600092136","viewed":302,"name":"Gradient utility","username":"Krabcode","description":"Easy to use gradients with hexToRgb, adjustable color positions, adjustable color counts and 3 different blend types","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["color","gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 cv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n\n    // gradients from https://colorhunt.co/\n    colorPoint[colorsPerGradient] gradientLeft = colorPoint[](\n        colorPoint(0.,  hexToRgb(0x2a3d66)),\n        colorPoint(0.25,hexToRgb(0x5d54a4)),\n        colorPoint(0.5, hexToRgb(0x9d65c9)),\n        colorPoint(0.75,hexToRgb(0xd789d7)),\n        colorPoint(1.,  hexToRgb(0x2a3d66)));\n    colorPoint[colorsPerGradient] gradientRight = colorPoint[](\n        colorPoint(0.,  hexToRgb(0xffa372)),\n        colorPoint(0.4, hexToRgb(0xed6663)),\n        colorPoint(0.5, hexToRgb(0x43658b)),\n        colorPoint(1.,  hexToRgb(0x4e89ae)),\n        emptyColorPoint()\n    );\n\n    float t = float(iFrame)*.005;\n    vec3 col;\n    if(uv.x < .5){\n        float circlePos = mod(length(cv-vec2(-.5, 0.))-t, 1.);\n        col = gradientColorAt(circlePos, gradientLeft);\n    }else{\n        col = gradientColorAt(uv.y, gradientRight);\n    }\n\n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int colorsPerGradient = 5;\n\n//--------------------------------------GRADIENT-----------------------------------\n//--------------------------------color point array logic--------------------------\n//-------------------------------------by Krabcode---------------------------------\n\nstruct colorPoint\n{\n    float pos;\n    vec3 val;\n};\n\ncolorPoint emptyColorPoint()\n{\n    return colorPoint(1.1, vec3(1.,0.,0.));\n}\n\nfloat map(float value, float start1, float stop1, float start2, float stop2)\n{\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat norm(float value, float start, float stop)\n{\n    return map(value, start, stop, 0., 1.);\n}\n\nint findClosestLeftNeighbourIndex(float pos, colorPoint[colorsPerGradient] gradient)\n{\n    for(int i = 0; i < colorsPerGradient - 1; i++){\n        if(pos >= gradient[i].pos && pos <= gradient[i+1].pos){\n            return i;\n        }\n    }\n    return 0;\n}\n\nvec3 gradientColorAt(float normalizedPos, colorPoint[colorsPerGradient] gradient)\n{\n    float pos = clamp(normalizedPos, 0., 1.);\n    int leftIndex = findClosestLeftNeighbourIndex(pos, gradient);\n    int rightIndex = leftIndex + 1;\n    colorPoint A = gradient[leftIndex];    \n    colorPoint B = gradient[rightIndex];\n    float normalizedPosBetweenNeighbours = norm(pos, A.pos, B.pos);\n    return mix(A.val, B.val, normalizedPosBetweenNeighbours);\n}\n\nvec3 hexToRgb(int color)\n{\n    float rValue = float(color / 256 / 256);\n    float gValue = float(color / 256 - int(rValue * 256.0));\n    float bValue = float(color - int(rValue * 256.0 * 256.0) - int(gValue * 256.0));\n    return vec3(rValue / 255.0, gValue / 255.0, bValue / 255.0);\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    return pow(smoothstep(0., 1., rgb), vec3(1.0/2.2));\n}\n\nvec4 gammaCorrection(vec4 rgba){\n    return vec4(gammaCorrection(rgba.rgb), 1.);\n}\n\n/*\ncolorPoint[colorsPerGradient] gradient = colorPoint[](\n        colorPoint(0.0, hexToRgb(0x1b262c)*.5),\n        colorPoint(0.2, hexToRgb(0x1b262c)),\n        colorPoint(0.4, hexToRgb(0x0f4c75)),\n        colorPoint(0.6, hexToRgb(0x3282b8)),\n        colorPoint(0.8,hexToRgb(0xbbe1fa)),\n        colorPoint(1.0, hexToRgb(0xbbe1fa)));\n*/","name":"Common","description":"","type":"common"}]}