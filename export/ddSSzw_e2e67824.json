{"ver":"0.1","info":{"id":"ddSSzw","date":"1670112574","viewed":188,"name":"Fractalish Planet","username":"gee8sh","description":"A mediocre attempt to generate and render Earth-like planets. If you drag the mouse on the canvas, the islands/continents will appear to be moving/deforming. You could also tweak the constants at the beginning of the shader to control rendering aspects.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fractal","noise","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const uint depth = 16u;\n\n// Observer params\nconst float focalLength = 2.0;\nconst float distanceToGlobe = 4.0;\n\n// Planet/globe params\nconst float globeRadius = sqrt(3.0);\nconst float seaLevel = 0.10;\nconst float forestLevel = 0.12;\nconst float snowLevel = 0.24;\nconst float shininess = 64.0;\nconst float featuresProminence = 0.33;\nconst float rotationSpeed = 0.05;\nconst vec3 seaColor = vec3(0.2, 0.2, 1.0);\nconst vec3 beachColor = vec3(1.0, 0.75, 0.0);\nconst vec3 forestColor = vec3(0.0, 0.5, 0.0);\nconst vec3 snowColor = vec3(1.0);\n\n// Sun params\nconst vec3 sunDirection = normalize(vec3(1.0, 1.0, 1.0));\n\n// Initial noise params\nconst float spaceScale = sqrt(2.0);\nconst float noiseScale = 1.0 / spaceScale;\n\n// Precalculated values\nconst float globeRadiusSquared = globeRadius * globeRadius; \nconst float distanceToGlobeSquared = distanceToGlobe * distanceToGlobe;\nconst float c = distanceToGlobeSquared - globeRadiusSquared;\nconst float scale = \n    (1.0 - noiseScale) / \n    (1.0 - pow(noiseScale, float(depth) + 1.0));\n    \nconst float PI = 3.1415926535897932384626433832795;\n\nvec4 base(in vec3 v) {\n    vec3 alias = 2.0 * fract(0.5 * v) - 1.0;\n    vec3 a = abs(alias);\n    vec3 s = smoothstep(0.0, 1.0, a);\n    vec3 deriv = alias * (1.0 - a);\n    vec3 factors = vec3(s.y * s.z, s.z * s.x, s.x * s.y);\n    vec3 grad = deriv * factors;\n    float w = s.x * factors.x;\n    return vec4(grad * 6.0, w);\n}\n\nvec4 noise(in vec3 pos, mat3 matrix, vec3 displacement) {\n    vec3 v = pos;\n    mat3 m = matrix;\n    float s = noiseScale;\n    vec4 result = base(v);\n    for (uint i = 1u; i < depth; i++) {\n        v = spaceScale * matrix * v + displacement;\n        vec4 r = base(v);\n        result.w += s * r.w;\n        result.xyz += r.xyz * m;\n        m *= matrix;\n        s *= noiseScale;\n    }\n    return result * scale;\n}\n\nvec4 shootGlobe(in vec3 ray) {\n    float halfB = -distanceToGlobe * ray.z;\n    float delta = halfB * halfB - c;\n    float sqrtD = delta > 0.0 ? sqrt(delta) : halfB;\n    float hitDistance = max(halfB - sqrtD, 0.0);\n    return vec4(hitDistance * ray + vec3(0.0, 0.0, distanceToGlobe), min(hitDistance, 1.0));\n}\n\nvec3 tangent(in vec3 normal, in vec3 v) {\n    float perpendicular = dot(normal, v);\n    return v - perpendicular * normal;\n}\n\nvec3 calcNormal(in vec4 hitPosition, in vec4 noise) {\n    vec3 normal = normalize(hitPosition.xyz);\n    if (noise.w >= seaLevel) {\n        vec3 t = tangent(normal, noise.xyz);\n        normal = normalize(normal - featuresProminence * t);\n    }\n    return normal;\n}\n\nvec3 calcColor(in vec3 ray, in vec3 normal, in float noiseLevel) {\n    return noiseLevel < seaLevel \n        ? seaColor + 2.0 * pow(max(dot(reflect(ray, normal), sunDirection), 0.0), shininess)\n        : noiseLevel < forestLevel\n            ? beachColor\n            : noiseLevel < snowLevel\n                ? forestColor\n                : snowColor;\n}\n\nfloat calcShade(vec3 normal, float hit) {\n    float l = dot(normal, sunDirection);\n    return hit * max(l, 0.0);\n}\n\nmat3 rotation() {\n    float angle = iTime * PI * rotationSpeed;\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        vec3(  c, 0.0,   s),\n        vec3(0.0, 1.0, 0.0),\n        vec3( -s, 0.0,   c)\n    );\n}\n\nvec4 sampleColor(in vec2 xy, mat3 r, mat3 matrix, vec3 displacement) {\n    vec3 ray = normalize(vec3(xy, -focalLength));\n    vec4 hitPosition = shootGlobe(ray);\n    hitPosition.xyz = r * hitPosition.xyz;\n    vec4 noise = noise(hitPosition.xyz, matrix, displacement);\n    vec3 normal = calcNormal(hitPosition, noise);\n    normal *= r;\n    vec3 color = calcColor(ray, normal, noise.w);\n    float shade = calcShade(normal, hitPosition.w);\n    return vec4(color * shade, 1.0);\n}\n\nvec2 pixelCoordinates(in vec2 fragCoord, in float halfPixelSize) {\n    float aspect = iResolution.x * halfPixelSize;\n    return 2.0 * halfPixelSize * fragCoord - vec2(aspect, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float halfPixelSize = 1.0 / iResolution.y;\n\n    float x = iMouse.x * halfPixelSize * PI;\n    float y = iMouse.y * halfPixelSize * PI;\n    float rc = cos(x);\n    float rs = sin(x);\n    float dc = cos(y);\n    float ds = sin(y);\n    vec3 displacement = vec3(dc, dc + ds, ds);\n    vec3 i = normalize(vec3(1.0, rc, rs));\n    vec3 k = normalize(cross(i, i.zxy));\n    vec3 j = normalize(cross(k, i));\n    mat3 matrix = mat3(i, j, k);\n\n    vec2 xy = pixelCoordinates(fragCoord, halfPixelSize);\n    mat3 r = rotation();\n    \n    fragColor = 0.25 * (\n        sampleColor(xy, r, matrix, displacement) + \n        sampleColor(xy + vec2(halfPixelSize, 0.0), r, matrix, displacement) + \n        sampleColor(xy + vec2(0.0, halfPixelSize), r, matrix, displacement) + \n        sampleColor(xy + vec2(halfPixelSize), r, matrix, displacement)\n    );\n}\n\n","name":"Image","description":"","type":"image"}]}