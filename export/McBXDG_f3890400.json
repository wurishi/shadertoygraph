{"ver":"0.1","info":{"id":"McBXDG","date":"1706751278","viewed":140,"name":"naive clouds and scattering","username":"difool","description":"Based on Dynamic clouds by Inigo Quilez & Real-Time Outdoor Light Scattering by Hoffmann and Preetham","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","clouds","sky","scattering","atmosphere","rayleigh","mie"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float noise_res = 256.0;\nfloat offsets[8];\nvec3 beta_R = vec3(6.95e-2, 1.18e-1, 2.44e-1);\nvec3 beta_M = vec3(4e-2, 4e-2, 4e-2);\nconst float g = 0.9;\nvec3 E_sun = vec3(250.0, 235.0, 200.0);\n\nfloat random(vec2 v)\n{\n    return fract(sin(dot(v.xy,\n                         vec2(14.9898,78.233)))\n                 * 403758.5453123);\n}\n\nfloat noise(float step, vec2 v)\n{\n\t\tvec2 i = floor(v / step) * step;\n        vec2 f = fract(v / step);\n        float a = random(i);\n        float b = random(i + vec2(step, 0));\n        float c = random(i + vec2(0, step));\n        float d = random(i + vec2(step, step));\n        float xf = f.x;\n        float yf = f.y;\n        xf = xf*xf*(3.-2.*xf);\n        yf = yf*yf*(3.-2.*yf);\n        float nx0 = a*(1.-xf)+b*xf;\n        float nx1 = c*(1.-xf)+d*xf;\n        return(nx0*(1.-yf)+nx1*yf);\n}\n\nvec4 fbm(vec2 v, vec2 s)\n{\n    offsets[0] = -float(iFrame) * 0.1;\n    offsets[1] = -float(iFrame) * 0.02;\n    offsets[2] = -float(iFrame)* 0.05;\n    offsets[3] = -float(iFrame)* 0.1;\n    offsets[4] = -float(iFrame) * 0.02;\n    offsets[5] = -float(iFrame) * 0.03;\n    offsets[6] = -float(iFrame) * 0.02;\n    offsets[7] = -float(iFrame) * 0.3;\n    float sum[4];\n    float sum_weights = 0.;\n    for (int i = 0 ; i < 4 ; i++) {\n        sum[i] = 0.0;\n        sum_weights = 0.;\n        if (i != 0)\n\t\t\tv += s * 2.0;\n        for (int k = 0  ; k < 8; k++) {\n            float weight = pow(2.0, float(k));\n            sum[i] += noise(weight, vec2(v.x + offsets[k], v.y)) * weight;\n            sum_weights += weight;\n        }\n        sum[i] += 128.;\n        sum[i] /= 256.f;\n    }\n    return vec4(sum[0], sum[1], sum[2], sum[3]);\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uvMouse = (iMouse.xy / iResolution.xy);\n    uvMouse.x *= iResolution.x/iResolution.y;\n\n    vec3 Vd = normalize(vec3(fragCoord.x, 1000., fragCoord.y));\n    vec3 Sd = normalize(vec3(uvMouse.x, 1., uvMouse.y));\n    float cos_theta = dot(Vd, Sd);\n    float theta = acos(cos_theta);   \n    float Phi_R = 3.0 / (16.0 * 3.14) * (1.0 + cos_theta * cos_theta);\n\tfloat Phi_M = 1.0 / (4.0 * 3.14) * pow(1.0 - g, 2.0) / pow(1.0 + g * g - 2.0 * g * cos_theta, 1.5);\n    float s = 0.1 / (cos_theta + 0.15 * pow(93.885 - theta, -1.253));\n    vec3 F_ex = exp(-(beta_R+beta_M) * s);\n    vec3 L_in = ((beta_R * Phi_R + beta_M * Phi_M)/(beta_R + beta_M)) * (1.0 - F_ex)* E_sun;\n    vec3 sky_rgb = vec3(L_in);\n\n    \n    vec4 values = fbm(fragCoord.xy, vec2(Vd.x, Vd.y));\n    float alpha = smoothstep(0.9, 1.0, values.x); //density, cumulus like\n    float average_density = (values.x + values.y + values.z + values.w) / 4.0;\n    average_density = mix(1.0, 0.0, pow(average_density, 2.));\n    values.x = smoothstep(-0.8, 0.3, average_density);  \n\n    vec3 cloud_rgb = vec3(values.x * F_ex + (L_in * 0.5));\n    fragColor = vec4(mix(sky_rgb, cloud_rgb, alpha), 1.);\n}","name":"Image","description":"","type":"image"}]}