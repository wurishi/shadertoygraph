{"ver":"0.1","info":{"id":"ttc3zr","date":"1575459574","viewed":1727,"name":"High-quality hash function","username":"nojima","description":"High-quality hash functions using MurmurHash.\n\nMurmurHash is a widely adopted fast hash function. By using MurmurHash, robust outputs can be obtained even for extremely large inputs or inputs close to zero.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["noise","random","hash"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash Functions\n//\n// murmurHashNM() takes M unsigned integers and returns N hash values.\n// The returned values are unsigned integers between 0 and 2^32 - 1.\n//\n// hashNM() takes M floating point numbers and returns N hash values.\n// The returned values are floating point numbers between 0.0 and 1.0.\n\n//------------------------------------------------------------------------------\n\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 1 input\nfloat hash11(float src) {\n    uint h = murmurHash11(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 2 inputs\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash13(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 3 inputs\nfloat hash13(vec3 src) {\n    uint h = murmurHash13(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuint murmurHash14(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 4 inputs\nfloat hash14(vec4 src) {\n    uint h = murmurHash14(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash21(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 1 input\nvec2 hash21(float src) {\n    uvec2 h = murmurHash21(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash22(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 2 inputs\nvec2 hash22(vec2 src) {\n    uvec2 h = murmurHash22(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash23(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 3 inputs\nvec2 hash23(vec3 src) {\n    uvec2 h = murmurHash23(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec2 murmurHash24(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 2 outputs, 4 inputs\nvec2 hash24(vec4 src) {\n    uvec2 h = murmurHash24(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash31(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 1 input\nvec3 hash31(float src) {\n    uvec3 h = murmurHash31(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash32(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 2 inputs\nvec3 hash32(vec2 src) {\n    uvec3 h = murmurHash32(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec3 murmurHash34(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 4 inputs\nvec3 hash34(vec4 src) {\n    uvec3 h = murmurHash34(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash41(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 1 input\nvec4 hash41(float src) {\n    uvec4 h = murmurHash41(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash42(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 2 inputs\nvec4 hash42(vec2 src) {\n    uvec4 h = murmurHash42(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash43(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 3 inputs\nvec4 hash43(vec3 src) {\n    uvec4 h = murmurHash43(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n//------------------------------------------------------------------------------\n\nuvec4 murmurHash44(uvec4 src) {\n    const uint M = 0x5bd1e995u;\n    uvec4 h = uvec4(1190494759u, 2147483647u, 3559788179u, 179424673u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z; h *= M; h ^= src.w;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 4 outputs, 4 inputs\nvec4 hash44(vec4 src) {\n    uvec4 h = murmurHash44(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n//-- Demo ----------------------------------------------------------------------\n\n\n\nvec3 conventionalHash33_1(vec3 p) {\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec3 conventionalHash33_2(vec3 p3) {\n\tp3 = fract(p3 * vec3(10.31, 10.3, 9.73));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    float time = iTime * 1000.0;\n\n    vec3 color;\n    if (uv.x < -0.005) { // Left: MurmurHash-based method\n        if (uv.y > 0.01) {\n            color = hash33(vec3(uv, time));\n        }\n        if (uv.y < -0.01) {\n            color = vec3(hash13(vec3(uv, time)));\n        }\n    }\n    if (uv.x > 0.005) { // Right: conventional method\n        if (uv.y > 0.01) {\n            color = conventionalHash33_1(vec3(uv, time));\n        }\n        if (uv.y < -0.01) {\n            color = conventionalHash33_2(vec3(uv, time));\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}