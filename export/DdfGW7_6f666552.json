{"ver":"0.1","info":{"id":"DdfGW7","date":"1666194765","viewed":72,"name":"Erosion Lab Practice","username":"wqwang","description":"reosion\n","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 uv = fragCoord / iResolution.x;\n    if(iTime < 1.5) {\n        float f = fbm(uv);\n        vec2 warp1 = NoiseVectorFBM(uv) * 0.6;\n        float w = WorleyNoise(uv * vec2(1., 6.) + warp1);\n        float h = gain(mix(w, f, 0.33), 0.4);\n        \n        vec3 col = vec3(0.f,0.5f,0.f);\n        \n        col.r = mix(0.f, 1.f, h);\n        \n        fragColor = vec4(col, 1.);\n    }\n    else {\n        // Here's how to read a pixel from the input buffer. This gets us the cell stored in a single pixel\n        float curr = texture(iChannel0, fragCoord / iResolution.xy).r;\n        \n        // 1. Get the values from the neighboring cells\n        \n        float neighbors[9];\n        for (int i = -1; i <= 1; i++) {\n            for (int j = -1; j <= 1; j++) {\n                int idx = (i + 1) * 3 + (j + 1);\n                vec2 newCoord = fragCoord + vec2(i, j);\n                neighbors[idx] = texture(iChannel0, newCoord / iResolution.xy).r;\n            }\n        }\n        \n        // 2. Get change in slope b/t each of 8 neighbors\n        \n        float diffs[9];\n        for (int i = -1; i <= 1; i++) {\n            for (int j = -1; j <= 1; j++) {\n                int idx = (i+1) * 3 + (j+1);\n                diffs[idx] = neighbors[idx] - curr;\n            }\n        }\n        \n        // 3. For each negative slope, subtract height from\n        // curr proportional to diff. For each positive slope,\n        // add height to curr (represents neighbor losing\n        // height to us)\n        // To mimic erosion due to gravity, only do this when between\n        // certain thresholds. Here are some recommendations!\n\n       \n        #define THR_LOWER 0.0035\n        #define THR_UPPER 0.0085        \n       \n        for (int i = 0; i < 9; i++) {\n            if (abs(diffs[i]) < THR_UPPER && abs(diffs[i]) > THR_LOWER) {\n                curr += EROSION_SCALAR * diffs[i];\n            }\n        }\n        \n        vec3 colorPanel[5];\n        vec3 col = vec3(0.f,0.5f,0.f);\n        \n        col.r = mix(0.f, 1.f, curr);\n        \n        fragColor = vec4(col, 1.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EROSION_SCALAR 0.05\n#define FBM_OCTAVES 8\n\nfloat bias(float t, float b) {\n    return (t / ((((1.0/b) - 2.0)*(1.0 - t))+1.0));\n}\n\nfloat gain(float time, float gain)\n{\n  if(time < 0.5)\n    return bias(time * 2.0,gain)/2.0;\n  else\n    return bias(time * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float rad = deg * 3.14159 / 180.0;\n    return vec2(cos(rad) * p.x - sin(rad) * p.y,\n                sin(rad) * p.x + cos(rad) * p.y);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat mySmootherStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n    return mix(a, b, t);\n}\n\n\nfloat bilerpNoise(vec2 uv) {\n    ivec2 uvFloor = ivec2(floor(uv));\n    vec2 uvFract = fract(uv);\n    float ll = random1(vec2(uvFloor));\n    float lr = random1(vec2(uvFloor + ivec2(1, 0)));\n    float ul = random1(vec2(uvFloor + ivec2(0, 1)));\n    float ur = random1(vec2(uvFloor + ivec2(1, 1)));\n\n    float lerpXL = mySmootherStep(ll, lr, uvFract.x);\n    float lerpXU = mySmootherStep(ul, ur, uvFract.x);\n\n    return mySmootherStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.0;\n    for(int i = 0; i < FBM_OCTAVES; i++) {\n        sum += bilerpNoise(uv * freq) * amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum;\n}\n\nfloat WorleyNoise(vec2 uv) {\n    // Tile the space\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec2 NoiseVectorFBM(vec2 uv) {\n    float x = fbm(uv) * 2.0 - 1.0;\n    float y = fbm(rotate(uv, 60.0)) * 2.0 - 1.0;\n    return vec2(x, y);\n}","name":"Common","description":"","type":"common"}]}