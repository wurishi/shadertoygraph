{"ver":"0.1","info":{"id":"3lyfDt","date":"1615266707","viewed":80,"name":"Ray Marching Triangle Primitive","username":"kovacjosh","description":"some sdfs for ray marching primitives","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Global constants for rendering\nconst float maxSteps = 150.;\nconst float hitThreshold = .00001;\nconst float maxDistance = 1000.;\nconst float specExp = 6.;\n\n// Useful general purpose functions\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nmat3 rotMat(vec3 u, float t)\n{\n    float c = cos(t);\n    float nc = 1. - cos(t);\n    float s = sin(t);\n    float xy = u.x*u.y;\n    float yz = u.y*u.z;\n    float xz = u.x*u.z;\n    return mat3(\n        c+u.x*u.x*nc, xy*nc+u.z*s, xz*nc-u.y*s,\n        xy*nc-u.z*s, c+u.y*u.y*nc, yz*nc+u.x*s,\n        xz*nc+u.y*s, yz*nc-u.x*s,  c+u.z*u.z*nc\n    );\n}\n\n// Primitive Structs\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    vec3 color;\n};\nstruct Triangle\n{\n  vec3 a;\n  vec3 b;\n  vec3 c;\n  vec3 color;\n};\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\n// General Stucts and their functions\nstruct Light\n{\n    vec3 point;\n    float intensity;\n    vec3 color;\n    float sharpness;\n};\nstruct Hit\n{\n    float t;\n    vec3 color;\n};\nvec3 rayToPos(Ray ray, float t)\n{\n    return ray.origin + ray.dir * t;\n}\nHit hitMin(Hit a, Hit b)\n{\n    if (a.t < b.t)\n    {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n// Signed distance functions for primitives\nHit sphereSDF(vec3 p, Sphere s)\n{\n    return Hit(length(p-s.center)-s.radius, s.color);\n}\nHit boxSDF(vec3 p, Box b)\n{\n    vec3 q = abs(p - b.center) - (b.size);\n    float radius = 0.02;\n    return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);\n}\nHit triangleSDF(vec3 p, Triangle tri)\n{\n    vec3 ba = tri.b - tri.a; vec3 pa = p - tri.a;\n    vec3 cb = tri.c - tri.b; vec3 pb = p - tri.b;\n    vec3 ac = tri.a - tri.c; vec3 pc = p - tri.c;\n    vec3 nor = cross( ba, ac );\n\n    float dist = sqrt(\n        (sign(dot(cross(ba,nor),pa)) +\n         sign(dot(cross(cb,nor),pb)) +\n         sign(dot(cross(ac,nor),pc))<2.0)\n         ?\n         min( min(\n         dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n         dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n         dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n         :\n         dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n    return Hit(dist, tri.color);\n}\n\n// Where the scene is defined\nHit map(vec3 p)\n{\n    mat3 rot = rotMat(vec3(0.,1.,0.), iTime/5.);\n    vec3 rp = rot*p;\n    Hit hit1 = triangleSDF(rp, Triangle(\n        vec3(-1.0, -1.0, 1.0), \n        vec3(1.0, -1.0, 1.0), \n        vec3(0.0, 1.0, 0.0),\n        vec3(2.0, 0., 0.)\n    ));\n    Hit hit2 = triangleSDF(rp, Triangle(\n        vec3(1.0, -1.0, 1.0),\n        vec3(0.0, -1.0, -1.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0., 2.0, 0.)\n    ));\n    Hit hit3 = triangleSDF(rp, Triangle(\n        vec3(0.0, -1.0, -1.0),\n        vec3(-1.0, -1.0, 1.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0., 0., 2.0)\n    ));\n    \n    return hitMin(hit3, hitMin(hit1, hit2));\n}\n\n// Approximate the gradient of the world at a point\nvec3 calcNormal(vec3 p)\n{\n    const vec2 eps = vec2(0.001, 0);\n    \n    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;\n    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;\n    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;\n    \n    return normalize(vec3(deltaX, deltaY, deltaZ));\n}\n\n// Convert a ray into a shadow scalar\nfloat calcShadow(Ray ray, float maxT, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for (float t = hitThreshold * 50.; t < maxT; )\n    {\n        float h = map(rayToPos(ray, t)).t;\n        if (h < hitThreshold)\n        {\n            return 0.;\n        }\n        float hsqr = pow(h, 2.);\n        float y = hsqr/(2. * ph);\n        float d = sqrt(hsqr - pow(y, 2.));\n        res = min(res, k * d / max(0., t - y));\n        ph += h;\n        t += h;\n    }\n    return res;\n}\n\n// Combine all the lights in the scene to color objects\nvec3 calcLight(vec3 p, vec3 v, vec3 n)\n{\n    const int lCount = 3;\n    Light[lCount] lights = Light[lCount](\n        Light(vec3(0., 6., 5.), 20., vec3(1., .2, 0.), 8.),\n        Light(vec3(0., -5., 5.), 2., vec3(1., .5, .1), 8.),\n        Light(vec3(5., 0., 5.), 6., vec3(1., 0., 1.), 1.)\n    );\n    vec3 ambient = vec3(0.8,0.63,0.50) * .05;\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < lCount; i++)\n    {\n        vec3 ldir = lights[i].point - p;\n        float lmag = length(ldir); \n        ldir /= lmag;\n        \n        vec3 h = normalize(ldir - v);\n        float spec = max(0., pow(dot(n, h), specExp));\n        \n        float diff = max(0., dot(ldir, n));\n\n        float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness);\n        \n        float strength = shadow * lights[i].intensity * (1./pow(lmag, 2.));\n        color += strength * (lights[i].color * diff + vec3(1.) * spec);\n    }\n    \n    return ambient + color;\n}\n\n// Convert Pixel Rays to Colors\nvec3 raymarch(Ray ray)\n{\n    vec3 glow = vec3(1., .5, 1.) * .1;\n    float t = 0.;\n    float i = 0.;\n    while (i < maxSteps && t <= maxDistance)\n    {\n        vec3 currentPos = rayToPos(ray, t);\n        Hit closestHit = map(currentPos);\n        \n        if (closestHit.t < hitThreshold)\n        {\n            vec3 normal = calcNormal(currentPos);\n            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);\n            return color + glow * i/maxSteps;\n        }\n        t += closestHit.t;\n        i += 1.;\n    }\n    //\n    // Calculate skybox, change the vec3 below\n    //\n    return vec3(0.01, 0.02, 0.03) + glow * smoothstep(0., 1.5, i/maxSteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert pixel coordinates to uv coordinates\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    // Define Camera\n    vec3 viewpoint = vec3(0., 0., 0.);\n    vec3 e = vec3(0., 0., 1.7);\n    \n    // Construct camera Matrix\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = cross(w, up);\n    vec3 v = normalize(cross(u, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n    \n    // Create viewing rays and get colors from them\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    Ray viewRay = Ray(e, normalize(p - e));\n    fragColor = vec4(raymarch(viewRay) ,1.0);\n}","name":"Image","description":"","type":"image"}]}