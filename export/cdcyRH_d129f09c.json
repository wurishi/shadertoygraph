{"ver":"0.1","info":{"id":"cdcyRH","date":"1694700352","viewed":86,"name":"hexagonally grouped triangles","username":"jt","description":"In a regular triangular grid group coordinates of triangles so that adjacent triangles that form a hexagon share the same coordinates.\nAlternates between vertex-centered and edge centered variants.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["triangles","barycentric","coordinates","hexagonally","grouped"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/cdcyRH hexagonally grouped triangles, 2023 by jt\n\n// In a regular triangular grid group coordinates of triangles so that adjacent triangles that form a hexagon share the same coordinates.\n// Alternates between vertex-centered and edge centered variants.\n// Additional rotation by 90 degrees around main diagonal (1,1,1)\n// to align hexagonal coordinates with triangular coordinates.\n\n// tags: triangles, barycentric, coordinates, hexagonally, grouped\n\n// The MIT License\n// Copyright (c) 2023 Jakob Thomsen\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nbool align()\n{\n    return fract(iTime/5.0) > 0.5;\n}\n/*\nvec3 barycentric_even(vec2 p) // via 3x3 matrix\n{\n    p = vec2(-p.y,p.x); // rotate 90 deg\n    // full 3x3 matrix\n    // coordinate-system along plane orthogonal to diagonal (1,1,1)\n    mat3 T =\n        mat3 // TODO: rotate this 90 degrees so hexagonal coordinate directions match triangular coordinate directions\n        (\n            normalize(vec3(-1,+1, 0)),\n            normalize(vec3(-1,-1,+2)),\n            normalize(vec3(-1,-1,-1))\n        );\n    float s = sqrt(3.0), r = sqrt(2.0), rs = sqrt(6.0);\n    //return T*vec3((p*s-vec2(0,1))/r,-1)/s; // origin offset on y axis\n    //return T*vec3((p-vec2(0,1)/s)/r,-1.0/s); // origin offset on y axis\n    //return T*vec3((p-vec2(0,1)/s)/r,0) + T*vec3(0,0,-1.0/s); // origin offset on y axis\n    //return T*vec3((p-vec2(0,1)/s)/r,0) + 1./3.0; // origin offset on y axis\n    //return T*vec3((p-vec2(0,1)/s)/r,0) + 1./3.0; // origin offset on y axis\n    return T*vec3((p*s-vec2(0,1)),0)/rs + 1./3.0; // origin offset on y axis\n    //return T*vec3((p*s),0)/rs + 1./3.0; // center at (0,0,0) instead\n}\n*/\n\nvec3 barycentric_even(vec2 p) // via 2x3 matrix plus offset\n{\n    float s = sqrt(3.0), r = sqrt(2.0), rs = sqrt(6.0);\n    // essential 2x3 matrix, omitting last row, requires adding (1/3,1/3,1/3)\n    // because T*vec3(0,0,-1/sqrt(3.0)) == vec3(1.0/3.0) captures the information of the omitted row.\n    // coordinate-system along plane orthogonal to diagonal (1,1,1)\n/*\n    p = vec2(-p.y,p.x); // rotate 90 deg\n    mat2x3 T =\n        mat2x3\n        (\n            normalize(vec3(-1,+1, 0)),\n            normalize(vec3(-1,-1,+2))\n        );\n    return T*(p*s-vec2(0,1))/rs + 1./3.0; // origin offset on y axis\n    //return T*(p*s)/rs + 1./3.0; // center at (0,0,0) instead\n*/\n    // coordinate-system along plane orthogonal to diagonal (1,1,1)\n    mat2x3 T =\n        mat2x3 // including 90 degrees rotation so hexagonal coordinate directions match triangular coordinate directions\n        (\n            normalize(vec3(-1,-1,+2)),\n            normalize(vec3(+1,-1, 0))\n        );\n    return T*(p*s-vec2(1,0))/rs + 1./3.0; // origin offset on y axis\n}\n\nvec3 barycentric_odd(vec2 p) // via 3x3 matrix\n{\n    // full 3x3 matrix\n    // coordinate-system along plane orthogonal to diagonal (1,1,1)\n    mat3 T =\n        mat3\n        (\n            normalize(vec3(-1,+1, 0)),\n            normalize(vec3(-1,-1, 2)),\n            normalize(vec3(-1,-1,-1))\n        );\n        /*\n    float phi = radians(-90.0);\n    float C = cos(phi);\n    float S = sin(phi);\n    float C1 = 1.0 - C;\n    vec3 a = vec3(1)/sqrt(3.0);\n    mat3 U =\n        mat3 // rotate 90 degrees around (1,1,1) diagonal\n        (\n            vec3(C1*a.x*a.x,C1*a.x*a.y-a.z*S,C1*a.x*a.z+a.y*S),\n            vec3(C1*a.x*a.y+a.z*S,C1*a.y*a.y+C, C1*a.y*a.z-a.x*S),\n            vec3(C1*a.x*a.z-a.y*S,C1*a.y*a.z+a.x*S,C1*a.z*a.z+C)\n        );\n        */\n        /*\n    float u = 1.0/sqrt(3.0), t = 1.0/3.0;\n    mat3 R =\n        mat3 // rotate 90 degrees around (1,1,1) diagonal\n        (\n            vec3(t,t+u,t-u),\n            vec3(t-u,t,t+u),\n            vec3(t+u,t-u,t)\n        );\n        */\n    float s = sqrt(3.0), r = sqrt(2.0), rs = sqrt(6.0);\n        /*\n    mat3 R =\n        mat3 // rotate 90 degrees around (1,1,1) diagonal\n        (\n            vec3(1.0,1.0+s,1.0-s),\n            vec3(1.0-s,1.0,1.0+s),\n            vec3(1.0+s,1.0-s,1.0)\n        )/3.0;\n        */\n    mat3 R = // rotate 90 degrees around (1,1,1) diagonal\n        (\n            1.0\n            +\n            mat3\n            (\n                vec3(0,+s,-s),\n                vec3(-s,0,+s),\n                vec3(+s,-s,0)\n            )\n        )/3.0;\n    //return R*T*vec3(p*s,0)/rs;\n    //return R*T*vec3(p*s,0)/rs; // additionally rotate 90 degrees to align hexagonal coordinates with triangular coordinates\n\n    // combined\n    mat3 RT =\n        mat3\n        (\n            normalize(vec3(-1,-1,2)),\n            normalize(vec3(+1,-1,0)),\n            normalize(vec3(-1,-1,-1))\n        );\n    return RT*vec3(p*s,0)/rs; // additionally rotate 90 degrees to align hexagonal coordinates with triangular coordinates\n}\n\nint div_floor(int a, int b)\n{\n    return (a > 0 && b < 0) ? ((a - 1) / b) - 1 : (a < 0 && b > 0) ? (a + 1) / b - 1 : a / b; // codegolf this line\n    //return (a ^ b) < 0 && a != 0 ? (1 - abs(a)) / abs(b) - 1 : a / b; // fenix found this at https://blog.demofox.org/2022/07/21/rounding-modes-for-integer-division/\n    //return a * b < 0 // golfed version by Fabrice\n    //           ? (1 - abs(a)) / abs(b) - 1 \n    //           : a / b; \n}\n\nint mod_positive(int a, int b)\n{\n    return a - div_floor(a, b) * b;\n}\n\n/*\n// Problem: this fails for large ints\nivec3 div_floor(ivec3 a, int b)\n{\n    return ivec3(floor(vec3(a) / vec3(b)));\n}\n*/\n// https://www.shadertoy.com/view/DtjyWD integer division - rounding down\nivec3 div_floor(ivec3 a, int b) // vector version thanks to Fabrice\n{\n    ivec3  S = (sign(abs(a*b))-sign(a*b))/2; // 0 if a*b >= 0\n    return S * ((1 - abs(a)) / abs(b) - 1)+(1-S)*(a / b); // emulates ()?:\n}\n/*\n// https://www.shadertoy.com/view/DljcWD integer modulo strictly positive\nivec3 mod_positive(ivec3 a, int b) // vector version thanks to Fabrice XXX fails on linux?! XXX\n{\n    ivec3 s = (sign(abs(a*b))-sign(a*b))/2; // 0 if a*b >= 0\n    return (1-s)* (a%b) + s * ((a - sign(a)) % b + b + sign(a)); // emulates ()?: \n}\n*/\nivec3 mod_positive(ivec3 a, int b)\n{\n    return a - div_floor(a, b) * b;\n}\n\nivec3 hexagonal_even(ivec3 i) // group triangular coordinates to hexagonal coordinates (jt)\n{\n    return div_floor(i.zxy-i.yzx+ivec3(0,-1,+1),3); // NOTE: roll 0,-1,+1 to align hexagons differently\n}\n\nivec3 hexagonal_odd(ivec3 i) // group triangular coordinates to hexagonal coordinates (jt)\n{\n    return div_floor(i.zxy-i.yzx,3);\n}\n\nbool checker(ivec3 tile)\n{\n    return ((tile.x ^ tile.y ^ tile.z) & 1) != 0; // works for both even and odd configuration\n}\n\n#define N 4\n\nuint tricode(ivec3 tile)\n{\n    return uint(mod_positive(tile.z-tile.y, 3));\n}\n\nvec3 color(ivec3 tile)\n{\n    uint code = tricode(tile);\n    return code == 0u ? vec3(1,0,0) : code == 1u ? vec3(0,1,0) :  vec3(0,0,1);\n    //return vec3(mod_positive(tile, N))/float(N-1);\n}\n\n#define scale (8.0*sqrt(3.0))\n#define e (1./R.y*scale)\n\nvoid mainImage( out vec4 o, in vec2 I )\n{\n    vec2 R = iResolution.xy;\n    //I = 2.0 * I/R - 1.0;\n    I = (2.0 * I - R) / R.y; // mind aspect ratio\n\n    vec3 t = align() ? barycentric_even(I*scale) : barycentric_odd(I*scale);\n\n    ivec3 tile = ivec3(floor(t));\n    //bool flip = tile.x + tile.y + tile.z == 0; // works only for odd configuration\n    bool flip = checker(tile) != align();\n    //bool tri = any(lessThan(t, vec3(0))); // fundamental triangle\n    t = fract(t);\n    //t -= vec3(tile);\n    if(!flip) t = 1.0 - t;\n\n    tile = align() ? hexagonal_even(tile) : hexagonal_odd(tile); // group triangles to hexagons\n\n    o = vec4(color(tile),1); // color scheme from https://www.shadertoy.com/view/mstcW4 debugging triangular coordinates\n    o *= 0.5 + 0.5 * min(smoothstep(0.0,0.0+e,t.x), min(smoothstep(0.0,0.0+e,t.y), smoothstep(0.0,0.0+e,t.z)));\n    //if(tri) o.xyz = vec3(0,0,1); // fundamental triangle\n    //if(flip) o.xyz = vec3(1,0,0);\n    o *= smoothstep(0.0,0.01, abs(I.x));\n    o *= smoothstep(0.0,0.01, abs(I.y));\n    //o = vec4(t, 1);\n    o = sqrt(o); // gamma\n}\n","name":"Image","description":"","type":"image"}]}