{"ver":"0.1","info":{"id":"cslSRN","date":"1668646643","viewed":111,"name":"NewtonFractal.","username":"stevejtrettel","description":"Newton's Method for my Calculus Class","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complexnumbers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 toUV(vec2 pixelCoords){\n        return vec2(pixelCoords.x/iResolution.x,pixelCoords.y/iResolution.y);\n}\n    \nvec2 toCoords( vec2 uv ){\n    \n        return 30.*(1.001+sin(iTime/5.))*(uv-vec2(0.5));\n}\n\n\n\nvec2 f( vec2 z ){\n\n    return cmult(z,z,z)-2.*cmult(z,z)+3.;\n\n}\n\nvec2 fPrime( vec2 z ){\n\nreturn 3.*cmult(z,z)-4.*z;\n\n}\n\nvec2 newton( vec2 z ){\n    vec2 val = f(z);\n    vec2 deriv = fPrime(z);\n    vec2 adjust = cdiv(val,deriv);\n    \n    vec2 z1 = z - adjust;\n    return z1;\n}\n\nvec2 newtonIteration( vec2 z, int n ){\n\n    for(int i=0; i<n; i++){\n        z = newton(z);\n    }\n    \n    return z;\n   \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = toUV( fragCoord);\n    vec2 z = toCoords(uv);\n    \n//run newton's iteration at z:\n        vec2 w = newtonIteration(z, 30);\n        \n        //map w to a color value:\n        //check if we have converged, by applying newton one more time\n        vec3 color;\n        vec2 v = newton(w);\n        if(length(v-w)>0.0001){\n            color = vec3(0);\n        }\n        else{\n            //the system has converged: choose a color based on w:\n            color = vec3(w.x,w.y,0.);\n        }\n    \n        //return this to the shader\n        fragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex math! \n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\n\n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmult (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmult (vec2 a, vec2 b, vec2 c) {\n  return cmult(cmult(a, b), c);\n}\n\nvec2 cmult (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmult(cmult(a, b), cmult(c, d));\n}\n\nvec2 cmult (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmult(cmult(a, b, c), cmult(d, e));\n}\n\nvec2 cmult (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmult(cmult(a, b, c), cmult(d, e, f));\n} \n\n\n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n","name":"Common","description":"","type":"common"}]}