{"ver":"0.1","info":{"id":"Mf2SWy","date":"1706785504","viewed":106,"name":"RGB SUBPIXELS","username":"chronos","description":"what it says on the tin :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["simple","grid","basic","screen","crt","animated","rgb","monitor","pattern","subpixel","lcd"],"hasliked":0,"parentid":"lf2SWy","parentname":"Simple Grid Dot Pattern"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    RGB SUBPIXELS by chronos\n    \n       Example use of the simple grid pattern\n\n*/\n\nconst float grid_dim = 5.;\n\nvec3 dot_grid_pattern(vec2 p)\n{\n    vec2 cell_idx = floor(p);\n    \n    float hash_cnt = 0.;\n    \n    // can just remove these if you want a static pattern\n    float animation_offset = hash(vec3(cell_idx, hash_cnt++));\n    float animation = floor(iTime*.125 + animation_offset); \n    \n    float rnd = hash(vec3(cell_idx, animation));\n    \n    float subpixel = floor(fract(p.x) * 3.); // Subdiv in 3 along x direction n each cell\n    \n    vec3 RGB = vec3\n    (\n        hash(vec3(cell_idx, rnd + hash_cnt++)),\n        hash(vec3(cell_idx, rnd + hash_cnt++)),\n        hash(vec3(cell_idx, rnd + hash_cnt++))\n    );\n    \n    vec3 color = RGB * vec3(subpixel == 0., subpixel == 1., subpixel == 2.);\n    \n    \n    vec2 q = .5 + .5*cos(2.*PI * p * vec2(3,1) - PI);\n    return color * (q.x * q.y) * float(rnd > 0.5); // Last factor is the binary thresholded noise that is used as a mask\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    if(length(iMouse.xy) < 10.) mouse.xy = vec2(0, max(sin(iTime), 0.));\n\n    float zoom = 1. + mouse.y;\n\n    vec3 color = vec3(0);\n    \n    vec2 p = grid_dim * (zoom * uv + iTime*.25); // animated grid coordinates\n    \n    color += dot_grid_pattern(p);\n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n","name":"Common","description":"","type":"common"}]}