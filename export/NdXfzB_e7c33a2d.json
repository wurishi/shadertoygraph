{"ver":"0.1","info":{"id":"NdXfzB","date":"1648163688","viewed":197,"name":"Burning Forest Fractal","username":"c0rymcg","description":"A ducks/kali-like fractal with the julia set seed splined around a few interesting points.\nThe fractal is reflected z/reflected c + c\ncatmull rom code from https://www.shadertoy.com/view/MsXGDj\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"fdXBzr","parentname":"fractal code template"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TAU 6.28318\n#define maxIterations 30\n#define AA 2\n\n\nvec2 cMult(vec2 c1, vec2 c2){\n   //complex mult\n    float newR = c1.x*c2.x - c1.y*c2.y;\n\tfloat newI = c1.y*c2.x + c1.x*c2.y;\n\treturn vec2(newR,newI);\n}\nvec2 cDivide(vec2 c1, vec2 c2){\n\t//conjugate = a - bi;\n\t//to divide, multiply both sides by complex conjugate of denom\n\n\tfloat divisor = dot(c2,c2);\n\t\n\treturn vec2((c1.x*c2.x + c1.y*c2.y)/divisor, (c1.y*c2.x - c1.x*c2.y)/divisor);\n}\n\n\nvec2 f1(vec2 z, vec2 c) {\n    \n    return cDivide(vec2(abs(z.x),abs(z.y)),vec2(abs(c.x),abs(c.y)))+c;\n}\n\nvec3 palette(float loc, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( TAU*(c*loc+d) );\n}\n\nfloat logPotential(float d,float i){\n  \n\tfloat base=log(2.);\n\treturn i-(log(log(d)/base)/base);\n\n}\n\n//--------------------------------------------------------------------------------\nfloat CatmullRom(float x, float v0,float v1, float v2,float v3) \n{\n\tfloat c2 = -.5 * v0\t+ 0.5*v2;\n\tfloat c3 = v0\t\t+ -2.5*v1 + 2.0*v2 + -.5*v3;\n\tfloat c4 = -.5 * v0\t+ 1.5*v1 + -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n\t\n}\n\nvec2 p1 = vec2(-0.8,-0.2);\nvec2 p2 = vec2(-0.5,0.1);\nvec2 p3 = vec2(-0.45,0.4);\nvec2 p4 = vec2(-0.7,0.55);\nvec2 p5 = vec2(0.1,0.9);\nvec2 p6 = vec2(-0.5,0);\nvec2 p7 = vec2(-0.51,-0.75);\nvec2 p8 = vec2(-0.75,-0.45);\n\n\n\nvec2 calcjPos(float time){\n    \n    float phase = mod(time*8.,8.);\n    float x = fract(phase);\n    phase = floor(phase);\n    \n    vec2 result = vec2(0);\n    if(phase>=7.){\n        result.x = CatmullRom(x,p7.x,p8.x,p1.x,p2.x);\n        result.y = CatmullRom(x,p7.y,p8.y,p1.y,p2.y);\n    }else if(phase>=6.){\n        result.x = CatmullRom(x,p6.x,p7.x,p8.x,p1.x);\n        result.y = CatmullRom(x,p6.y,p7.y,p8.y,p1.y);\n    }else if (phase>=5.){\n        result.x = CatmullRom(x,p5.x,p6.x,p7.x,p8.x);\n        result.y = CatmullRom(x,p5.y,p6.y,p7.y,p8.y);\n    }else if (phase>=4.){\n        result.x = CatmullRom(x,p4.x,p5.x,p6.x,p7.x);\n        result.y = CatmullRom(x,p4.y,p5.y,p6.y,p7.y);\n    }else if (phase>=3.){\n        result.x = CatmullRom(x,p3.x,p4.x,p5.x,p6.x);\n        result.y = CatmullRom(x,p3.y,p4.y,p5.y,p6.y);\n    }else if (phase>=2.){\n        result.x = CatmullRom(x,p2.x,p3.x,p4.x,p5.x);\n        result.y = CatmullRom(x,p2.y,p3.y,p4.y,p5.y);\n        \n    }else if (phase>=1.){\n        result.x = CatmullRom(x,p1.x,p2.x,p3.x,p4.x);\n        result.y = CatmullRom(x,p1.y,p2.y,p3.y,p4.y);\n        \n    }else{\n        result.x = CatmullRom(x,p8.x,p1.x,p2.x,p3.x);\n        result.y = CatmullRom(x,p8.y,p1.y,p2.y,p3.y);\n        \n    }\n    return result;\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 aacol=vec3(0.);\n    float time = iTime;\n    \n    vec2 jPos = calcjPos(iTime/60.);//vec2(-0.8+cos(iTime/3.)*0.1,cos(iTime/4.)*0.4-0.3);\n    \n    //aa code here\n    for (int aax=0; aax<AA; aax++){\n    for (int aay=0; aay<AA; aay++){\n        \n        \n        vec2 uv = (fragCoord + vec2(aax,aay)/float(AA))/iResolution.xx;\n        uv -= 0.5;uv *= 1.3;uv += 0.5;\n        uv=3.*(uv-vec2(0.5,0.22));\n        \n         \n        \n        int i = 0;\n         if(iMouse.z>0.){\n            vec2 mPos = iMouse.xy/iResolution.xx;\n            mPos -= 0.5; mPos *= 1.3; mPos += 0.5;\n            mPos=3.*(mPos-vec2(0.5,0.22));\n            jPos=mPos;\n        }\n        \n        vec2 c=uv;\n        c=jPos;\n        vec2 z = uv;\n        \n        //iterate\n        float sum=0.; float fmin=10000.; float fmax=0.; float lenz=0.;\n        for (i = 0; i < maxIterations; i++) {\n          z = f1(z,c);\n\n          lenz = exp(0.-length(z));\n          if (lenz<fmin) fmin=lenz;\n          if (lenz>fmax) fmax=lenz;\n          sum+=lenz;\n          \n        }\n\n\t\t\t//exp smoothing color method\n\tfloat colval = sqrt(sum)/(1.+fmax-fmin);\n\n    \n    vec3 iterationCol = vec3(palette(colval/2., vec3(0.5),vec3(0.5),vec3(1.0, 1.0, 0.0),vec3(0.3, 0.2, 0.2)));\n    /* for debugging\n    if (distance(jPos,uv)<0.02)iterationCol=vec3(0);\n    \n    float distToControls = min(distance(p1,uv),distance(p2,uv));\n    distToControls=min(distance(p3,uv),distToControls);\n    distToControls=min(distance(p4,uv),distToControls);\n    distToControls=min(distance(p5,uv),distToControls);\n    distToControls=min(distance(p6,uv),distToControls);\n    distToControls=min(distance(p7,uv),distToControls);\n    distToControls=min(distance(p8,uv),distToControls);\n    \n    if (distToControls<0.02)iterationCol=vec3(0);\n    */\n    aacol+= iterationCol;\n    }\n    }\n    fragColor=vec4(aacol.xyz/4.,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}