{"ver":"0.1","info":{"id":"XddBD2","date":"1526808295","viewed":1773,"name":"Sponza pt1","username":"mmerchante","description":"Decided to build Sponza, took more time than expected to optimize the sdf... and it can still be improved, but at least it doesn't crash the compiler. Also, sponza without GI is ugly, so decided to do a very naive/broken pathtracer.\nPress SPACE to clear.","likes":47,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","sdf","gi","modeling","globalillumination","pathtracing","sponza"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 filmic(vec3 x)\n{\n\treturn ((x*(0.15f*x + 0.10f*0.50f) + 0.20f*0.02f) / (x*(0.15f*x + 0.50f) + 0.20f*0.30f)) - 0.02f / 0.30f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    if(abs(uv.y) > .75)\n    {     \n        fragColor = vec4(0.0);   \n        return;\n    }\n    \n    vec4 result = texture(iChannel0, fragCoord / iResolution.xy);\n    result += vec4(texture(iChannel1, fragCoord / iResolution.xy).rgb, 1.0);\n    result /= result.a;\n    \n\tvec3 vignette = mix(vec3(1.0, .8, .96) * .1, vec3(1.3), (1.0 - smoothstep(.0, 1.9, length(uv) / 0.70710678118f)));\n    vignette *= vignette;\n\t\n\tvec3 whiteScale = 1.0f / filmic(vec3(6.2f));\n    result.rgb = filmic(result.rgb * 24.0 * vignette);    \n    result.rgb = clamp(result.rgb * whiteScale, vec3(0.0), vec3(1.0));\n\tfragColor = pow(result, vec4(.4545));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BOUNCES 6\n\n#define MAX_STEPS 100\n\n#define MAX_DISTANCE 30.0\n#define EPSILON .01\n#define EPSILON_NORMAL .001\n\n// iq\nfloat hash(float seed)\n{\n    return fract(sin(seed)*43758.5453 );\n}\n\n// Projected into 1D, multiplying PI by some prime and using as axis\nfloat hash2D(vec2 x)\n{\n\tfloat i = dot(x, vec2(123.4031, 46.5244876));\n\treturn fract(sin(i * 7.13) * 268573.103291);\n}\n \nfloat hash3D(vec3 x)\n{\n\tfloat i = dot(x, vec3(123.4031, 46.5244876, 91.106168));\n\treturn fract(sin(i * 7.13) * 268573.103291);\n}\n\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n} \n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\n// hg\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// hg\nfloat fCylinder(vec3 p) {\n    float d = length(p.xz) - .5;\n    d = max(d, abs(p.y) - 1.0);\n    return d * .5;\n}\n\nvec3 domainRepeat(vec3 p, vec3 size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\nfloat domainRepeat1D(float p, float size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\n// hg\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.0 * 3.1415 / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*r;\n}\n\n// From https://www.shadertoy.com/view/ltXBz8\nvec3 SphereRand( uint seed )\n{\n    float a = (float((seed*0x73493U)&0xfffffU)/float(0x100000))*2. - 1.;\n    float b = 6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float cosa = sqrt(1.-a*a);\n    return vec3(cosa*cos(b),a,cosa*sin(b));\n}\n\nvec3 HemisphereRand( vec3 a, uint seed )\n{\n    vec3 r = SphereRand(seed);\n    return dot(r,a) > .0 ? r : -r;\n}\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 rdX(vec3 p)\n{\n    return vec3(p.x, p.z, -p.y);\n}\n\nvec3 rdY(vec3 p)\n{\n    return vec3(-p.z, p.y, p.x);\n}\n\nvec3 rdZ(vec3 p)\n{\n    return vec3(-p.y, p.x, p.z);\n}\n\n// hg\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// ----------------------------------------------------------\n\nconst mat4 tr[3] = mat4[3](\n\tmat4(1.0, .0, .0, .0, .0, .0, -1.0, .0, .0, 1.0, .0, .0, .0, .0, .0, 1.0),\n\tmat4(.0, -1.0, .0, .0, 1.0, .0, .0, .0, .0, .0, 1.0, .0, .21, .13, 1.08, 1.0),\n\tmat4(-.493, -.87, .0, .0, .87, -.493, .0, .0, .0, .0, 1.0, .0, .257, .539, 1.08, 1.0)\n);\n\n// Built with https://github.com/mmerchante/sdf-gen-unity\nfloat sdf(vec3 p)\n{\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n\ta0.xz = abs(a0.xz) * vec2(-1.0,1.0);\n\tvec4 a1 = a0 - vec4(6.24,.0,2.5,.0);\n\ta1.xz = pModPolar(a1.xz , 4.0);\n\tfloat d1 = dot(a1.xyz - vec3(11.49,.0,.0), vec3(-1.0,.0,.0));\n\tvec4 a2 = a1 - vec4(11.02,2.15,7.28,.0);\n\ta2.z = domainRepeat1D(a2.z , 2.0);\n\tvec4 a3 = a2;\n\twsPos = a3.xyz - vec3(-2.64,5.05,.0);\n\tfloat d3 = fBox(wsPos,vec3(.5,.5,.228));\n\twsPos = a3.xyz - vec3(-2.275,5.05,.0);\n\td3 = min(d3,fBox(wsPos,vec3(.383,.383,.175)));\n\twsPos = a3.xyz - vec3(-2.64,6.97,.0);\n\td3 = min(d3,fBox(wsPos,vec3(.5,.283,.111)));\n\twsPos = a2.xyz - vec3(-1.28,6.38,.287);\n\tfloat d2 = max(-d3,fBox(wsPos,vec3(1.5,1.893,6.673)));\n\td1 = min(d1,d2);\n\tvec4 a4 = a1 - vec4(9.18,-4.5,-.032,.0);\n\ta4.y = domainRepeat1D(a4.y , 4.5);\n\tvec4 a5 = a4;\n\ta5.z = domainRepeat1D(a5.z , 2.5);\n\tvec4 a6 = a5;\n\ta6.x = -a6.x;\n\tvec4 a7 = a6;\n\tvec4 a8 = a7 - vec4(.05,-.62,.0,.0);\n\ta8.xyz = rdZ(a8.xyz);\n\twsPos = a8.xyz;\n\tfloat d8 = (fCylinder(wsPos, 1.398,1.361)*.75);\n\twsPos = a8.xyz - vec3(.0,.152,.0);\n\td8 = max(-d8,(fCylinder(wsPos, 1.434,.531)*.75));\n\twsPos = a7.xyz - vec3(.786,.46,.0);\n\tfloat d7 = max(d8,fBox(wsPos,vec3(.523,.747,1.415)));\n\tvec4 a9 = a6;\n\twsPos = a9.xyz - vec3(.47,1.953,.0);\n\tfloat d9 = fBox(wsPos,vec3(.5,.075,1.5));\n\twsPos = a9.xyz - vec3(.58,2.03,.0);\n\td9 = min(d9,fBox(wsPos,vec3(.5,.075,1.5)));\n\tvec4 a10 = a9 - vec4(.463,-.51,1.179,.0);\n\ta10.z = domainRepeat1D(a10.z , 2.35);\n\twsPos = a10.xyz;\n\tfloat d10 = fBox(wsPos,vec3(.24,.033,.24));\n\twsPos = a10.xyz - vec3(.0,-.093,.0);\n\td10 = min(d10,fBox(wsPos,vec3(.24,.033,.24)));\n\twsPos = a10.xyz - vec3(-2.8,-.03,.0);\n\td10 = min(d10,fBox(wsPos,vec3(.25,.075,.25)));\n\tvec4 a11 = a10;\n\ta11.xz = pModPolar(a11.xz , 8.0);\n\twsPos = a11.xyz - vec3(.002,-1.07,.0);\n\tfloat d11 = fBox(wsPos,vec3(.17,1.053,.424));\n\td10 = min(d10,d11);\n\td9 = min(d9,d10);\n\tvec4 a12 = a9 - vec4(-1.03,-.518,.0,.0);\n\tvec4 a13 = a12;\n\ta13.xyz = rdZ(a13.xyz);\n\twsPos = (tr[0] * a13).xyz;\n\tfloat d13 = fCylinder(wsPos, 1.225,3.0);\n\twsPos = a13.xyz;\n\td13 = min(d13,fCylinder(wsPos, 1.094,2.061));\n\twsPos = a12.xyz - vec3(.12,1.27,.0);\n\tfloat d12 = max(-d13,fBox(wsPos,vec3(1.5,1.355,1.551)));\n\td9 = min(d9,d12);\n\tfloat d6 = min(d7,d9);\n\tvec4 a14 = a6 - vec4(.463,1.57,1.61,.0);\n\twsPos = (tr[1] * a14).xyz;\n\tfloat d14 = fCylinder(wsPos, .105,.046);\n\twsPos = (tr[2] * a14).xyz;\n\td14 = min(d14,fCylinder(wsPos, .025,.582));\n\td6 = min(d6,d14);\n\tfloat d5 = d6;\n\tfloat d4 = d5;\n\td1 = min(d1,d4);\n\tfloat d0 = min(d1,dot(a0.xyz - vec3(.0,-2.0,.0), vec3(.0,1.0,.0)));\n\td0 = min(d0, length(p - vec3(0.0, .35, .0)) - 1.5);\n    d0 = min(d0, -(p.y - 11.15));\n    return d0;\n}\n\nvec3 sdfNormal(vec3 p)\n{\n    float s = sdf(p);\n    vec3 eps = vec3(EPSILON_NORMAL, -EPSILON_NORMAL, 0.0);    \n\tfloat dX = s - sdf(p + eps.yzz);\n\tfloat dY = s - sdf(p + eps.zyz);\n\tfloat dZ = s - sdf(p + eps.zzy);\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\n// ----------------------------------------------------------\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n\nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nCamera GetCamera(vec2 uv, float zoom, float time)\n{\n    float dist = 6.5;\n    \n    vec3 target = vec3(0.4, 2.0, 0.0);\n    vec3 p = vec3(0.4, -.75, -10.0);\n    \n    float sa = hash(hash2D(uv) + 1113.1*time);\n    vec2 offset = -0.5 + vec2( hash(sa+13.271), hash(sa+63.216));\n    offset *= .125;\n\n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n        \n    // Intersect focal plane\n    float d = 10.0 / dot(cam.direction, forward);\n    vec3 focalPoint = cam.origin + (cam.direction * d);\n\n    cam.origin += (left * offset.x) + (up * offset.y);\n    cam.direction = normalize(focalPoint - cam.origin);\n        \n    return cam;\n}\n\nint BounceFrame(int frame)\n{\n    return frame % BOUNCES;\n}\n\nvoid Bounce(int frame, inout Camera camera, inout vec3 normal)\n{\n    normal = sdfNormal(camera.origin);\n    camera.origin += normal * EPSILON * 2.0;\n    \n    if(length(camera.origin - vec3(0.0, .35, .0)) < 1.75)\n\t\tcamera.direction = reflect(camera.direction, normal);\n    else\n    \tcamera.direction = HemisphereRand(normal, uint(hash3D(camera.origin) * 23248765.0) + uint(frame));    \n}\n\nvoid RebuildFrame(int frame, vec4 rawData, inout Camera camera, inout vec3 normal)\n{\n    int frameBounce = BounceFrame(frame);\n    \n    if(frameBounce > 0)\n    {        \n        if(frameBounce > 1)\n        {\n            // Jump once\n            camera.origin = rawData.yzw;\n            Bounce(frame, camera, normal);\n        }\n        \n        camera.origin = camera.origin + camera.direction * rawData.r;\n        Bounce(frame, camera, normal);\n    }    \n}\n\nvoid EvaluateBRDF(vec3 wo, vec3 wi, vec3 normal, vec3 p, inout vec3 totalEnergy, inout float throughput)\n{\n    // Some rays end too far from the geo, so just assume it is losing some energy\n    if(sdf(p) > EPSILON * 2.0)\n    {\n     \tthroughput *= .15;\n        return;\n    }\n    \n    float brdf = max(0.0, dot(normal, wi));    \n    brdf = mix(brdf, 1.0, step(length(p), 2.2));\n    \n    vec3 emission = vec3(1.3, .7, .4) * step(7.0, p.y) * smoothstep(1.75, 2.5, p.x) * 3.0;\n    emission = mix(emission, vec3(.1, .3, 1.0), step(11.0, p.y));\n\n    totalEnergy += throughput * emission;\n    throughput *= brdf;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float Raymarch(Camera camera, vec2 uv)\n{    \n    float totalDistance = 0.0;\n    \n    int bounceFrame = BounceFrame(iFrame);\n    \n    float maxDistance = MAX_DISTANCE;\n    \n    if(bounceFrame > 0)\n\t\tmaxDistance = 15.0;\n    \n\tfor(int j = 0; j < MAX_STEPS; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * totalDistance;\n\t\tfloat d = max(0.0, sdf(p));\n\n\t\ttotalDistance += d;\n                \n\t\tif(d < EPSILON || totalDistance > maxDistance)\n            break;\n\t}\n    \n    return totalDistance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 rawUV = fragCoord / iResolution.xy;\n    vec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;    \n    \n    if(abs(uv.y) > .75)\n    {\n        fragColor = vec4(0.0);\n        \n        if(iFrame == 0 || texelFetch(iChannel1, ivec2(32,0), 0).x > 0.0)\n            fragColor = vec4(1.0);\n        \n        return;\n    }\n    \n    Camera camera = GetCamera(uv, .5, iTime);    \n    vec4 rawA = texture(iChannel0, rawUV);    \n    vec3 normal = vec3(0.0);\n    RebuildFrame(iFrame, rawA, camera, normal);\n \n    float totalDistance = Raymarch(camera, rawUV);    \n\tfragColor = vec4(totalDistance, camera.origin);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rawUV = fragCoord / iResolution.xy;\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    \n    if(abs(uv.y) > .75)\n    {     \n        fragColor = vec4(0.0);   \n        return;\n    }\n    \n    Camera camera = GetCamera(uv, .5, iTime);\n    vec4 rawA = texture(iChannel0, rawUV);\n    \n    vec3 oldStartPosition = rawA.yzw;\n    vec3 normal = vec3(0.0);\n    \n    int bounceFrame = BounceFrame(iFrame);    \n    vec4 rawB = texture(iChannel1, rawUV);\n    \n    vec3 totalEnergy = rawB.rgb;\n    float throughput = rawB.a;\n\n    if(bounceFrame == 0 || rawA.r > MAX_DISTANCE)\n    {\n        totalEnergy = vec3(0.0);\n        throughput = 1.0;\n    }\n    else if(length(throughput) > .001) // prune dark rays\n    {\n        RebuildFrame(iFrame, rawA, camera, normal);\n        \n        vec3 wo = normalize(camera.origin - oldStartPosition);\n        vec3 wi = normalize(camera.direction);\n\n        EvaluateBRDF(wo, wi, normal, oldStartPosition, totalEnergy, throughput);\n    }    \n    \n\tfragColor = vec4(totalEnergy, throughput);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rawUV = fragCoord / iResolution.xy;\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    \n    if(abs(uv.y) > .75)\n    {     \n        fragColor = vec4(0.0);   \n        return;\n    }\n    \n    vec4 result = texture(iChannel2, rawUV);\n    \n    if(iFrame == 0 || texelFetch(iChannel0, ivec2(0), 0).x > 0.0)\n        result = vec4(0.0);\n    \n    int bounceFrame = BounceFrame(iFrame);\n    \n    if(bounceFrame == BOUNCES - 1)\n    {\n        result.rgb += texture(iChannel1, rawUV).rgb;\n        result.a += 1.0;   \n    }    \n    \n\tfragColor = result;\n}","name":"Buf D","description":"","type":"buffer"}]}