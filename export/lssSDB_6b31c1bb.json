{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\nvec3 opCheapBend(vec3 p)\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat displacement(in vec3 p)\n{\n\tfloat ret = sin(20.0 * p.x) * sin(20.0 * p.y) * sin(20.0 * p.z);\n\t\n\treturn ret;\n}\n\nfloat opDisplace(vec3 p, float d1)\n{\n    float d2 = displacement(p);\n    return d1 + d2;\n}\n\nfloat length2(in vec2 p, in float n)                                                                      \n{                                                                               \n    return pow(pow(p.x, n) + pow(p.y, n), 1.0/n);                               \n}\n\nfloat opU(in float d1, in float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opS(in float d1, in float d2)\n{\n    return max(-d1, d2);\n}\n\nfloat opI(in float d1, in float d2)\n{\n    return max(d1, d2);\n}\n\nfloat sphere(in vec3 p, in float r)\n{\n    return length(p) - r;  \n}\n\nfloat rbox(in vec3 p, in vec3 b, in float r)\n{\n    return length(max(abs(p)-b, 0.0)) - r;  \n}\n\nfloat torus(in vec3 p, in vec2 t, in float n1, in float n2)\n{\n    vec2 q = vec2(length2(p.xz, n1) - t.x, p.y);                              \n    return length2(q, n2) - t.y;                                         \n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec2 map(in vec3 p)                                                             \n{                                   \n    //float d = torus(p, vec2(0.5, 0.2), \n    //              2.0 + 8.0 * (1.0 + sin(iTime)), \n    //              2.0 + 8.0 * (1.0 + sin(iTime)));\n    \n    float d1 = torus(p, vec2(0.5, 0.2), 2.0, 2.0);\n\tfloat d = d1;\n\t\n    vec2 res = vec2(d, 1.0);                                                     \n                                                                                \n    return res;                                                                  \n}                                                                               \n                                                                                \nvec3 calcNormal(in vec3 p)                                                      \n{                                                                               \n    vec3 e = vec3(0.001, 0.0, 0.0);                                             \n    vec3 n;                                                                     \n                                                                                \n    n.x = map(p + e.xyy).x - map(p - e.xyy).x;                                  \n    n.y = map(p + e.yxy).x - map(p - e.yxy).x;                                  \n    n.z = map(p + e.yyx).x - map(p - e.yyx).x;                                  \n                                                                                \n    return normalize(n);                                                        \n}                                                                               \n                                                                                \nvec2 intersect(in vec3 ro, in vec3 rd)                                          \n{                                                                               \n    float t = 0.0;                                                              \n                                                                                \n    for (int i=0; i<1000; i++)                                                  \n    {                                                                           \n        vec2 h = map(ro + t * rd);                                              \n                                                                                \n        if (h.x < 0.001) return vec2(t, h.y);                                   \n                                                                                \n        t += h.x;                                                               \n                                                                                \n        if (t >= 6.0) break;                                                    \n    }                                                                           \n                                                                                \n    return vec2(0.0);                                                           \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )                                                                 \n{                                                                               \n    // the coordinate of the current fragment                                   \n    vec2 uv = fragCoord.xy / iResolution.xy;                                 \n    // adjustment for aspect ratio                                              \n    vec2 p = (-1.0 + 2.0 * uv) * vec2(iResolution.x/iResolution.y, 1.0);        \n                                                                                \n    // origin of ray                                                            \n    vec3 ro = 1.5 * vec3(cos(0.2 * iTime), 1.0, sin(0.2 * iTime));  \n    // direction of ray                                                         \n    vec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro);                              \n    vec3 uu = normalize(cross(vec3(00, 1.0, 0.0), ww));                         \n    vec3 vv = normalize(cross(ww, uu));                                         \n    vec3 rd = normalize(p.x * uu + p.y * vv + 1.5 * ww);                        \n                                                                                \n    // the light source                                                         \n    vec3 lig = normalize(vec3(1.0, 0.8, 0.6)); \n    vec3 lig2 = vec3(-lig.x, lig.y, -lig.z);\n                                                                                \n    // the base color                                                           \n    vec3 col = vec3(0.2);                                                       \n                                                                                \n    // calculate intersections with scene                                       \n    vec2 t = intersect(ro, rd);                                                 \n       \n    // if an intersection has occurred\n    if (t.y > 0.0)                                                              \n    {                                 \n        // calculate position of intersection\n        vec3 pos = ro + t.x * rd;            \n        // calculate normal of that point\n        vec3 nor = calcNormal(pos);    \n        // calculate reflected vector\n        vec3 ref = reflect(rd, nor);\n                     \n        // create ambiant, diffuse and specular light values\n        float con = 1.0;\n        float amb = 0.5 + 0.5 * nor.y;                                          \n        float dif = max(0.0, dot(nor, lig));                \n        float spe = pow(clamp(dot(lig,ref), 0.0, 1.0), 8.0);\n        float rim = pow(1.0 + dot(nor, rd), 2.5);\n        float bac = max(0.0, 0.2 + 0.8 * dot(nor, lig2));\n                        \n        //col  = con * vec3(0.1, 0.15, 0.2);\n        col  = amb * vec3(0.1, 0.15, 0.2);                                      \n        col += dif * vec3(0.85, 0.97, 0.0); \n        col += bac * vec3(0.25, 0.37, 0.5);\n        \n        col += 0.3 * rim * amb; \n        col += 0.3 * spe * amb;\n        \n    }             \n                                                                                \n    fragColor = vec4(col,1.0);                                               \n}  ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lssSDB","date":"1406592131","viewed":1156,"name":"Distance Function Torus","username":"sed","description":"Stolen from https://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","distancefunction"],"hasliked":0,"parentid":"","parentname":""}}