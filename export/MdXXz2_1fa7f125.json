{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"int imod(int a, int b)\n{\n\treturn a - a / b * b;\n}\nint xor(int a, int b)\n{\n\tint result = 0;\n\tint x = 1;\n\tfor(int i = 0; i <= 8; ++i)\n    {\n        if (imod(a,2) != imod(b,2))\n            result += x;\n        a /= 2;\n        b /= 2;\n        x *= 2;\n\t}\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 xy = uv * vec2(320.0,200.0);\n\tfloat z;\n    vec2 dist;\n    for(int i = 0; i < 256; ++i)\n    {\n\t\tz = float(i) / 255.0;\n\t\tdist = (xy - vec2(160.0,100.0)) * z;\t\t\n\t\tz = mod(z + iTime/4.0, 1.0);\n\t\tdist.x += sin(iTime*3.14)*15.0;\t\t\n\t\tint zz = int(z * 2.0);\n\t\tif (zz == 0) dist.x -= 10.0;\n\t\telse dist.x += 10.0;\t\t\n\t\tif ( (abs(dist.x) >= 25.0 && (imod(int(z*8.0),2)==0)) || abs(dist.y) >= 16.0)\n            break;\n\t}\n\tint texel = xor(xor(int(dist.x), int(dist.y)), int(mod(z, 0.25)*255.0));\n    texel = imod(texel, 16);\n    float c = float(texel) / 16.0;\n\tfragColor = vec4(c,c,c,1.0);\n\t//fragColor = vec4(z,z,z,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdXXz2","date":"1404050581","viewed":3439,"name":"wolf128","username":"finalpatch","description":"a webgl implementation of the wolf128.asm demo, analyzed and explained in my blog post http://finalpatch.blogspot.com.au/2014/06/dissecting-128-byte-raycaster.html","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["raycaster"],"hasliked":0,"parentid":"","parentname":""}}