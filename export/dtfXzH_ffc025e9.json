{"ver":"0.1","info":{"id":"dtfXzH","date":"1674270947","viewed":117,"name":"Ocean simulator 3","username":"ianertson","description":"Improved version of my old one here: https://www.shadertoy.com/view/DtBGWc\n\n* increased render distance by completely discarding rays towards the sky\n* some kind of \"sun flare\"\n* different camera movement\n* more realistic horizon\n* More realistic colors","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","ray","raymarch","raymarch","water","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 48\n#define THRESHOLD 0.02\n#define FAR 4000.0\n#define AA_ENABLED 1\n#define AA_FILTER_SIZE 2\n#define WAVE_FREQ 0.022\n#define WAVE_MOVE_FREQ 2.6\n#define WAVE_HEIGHT 9.0\n#define WATER_Y 70.0\n#define BUMP_SCALE 0.5\n#define BUMP_FREQ 0.5\n#define BUMP_MOVE_FREQ 0.9\n#define NORMAL_SOFTNESS 0.93\n#define TIME_SPEED 0.6\n\n\n#define BUMP_OFFSET  (noise((p+vec3(-0.01, 0.05, -0.43))*WAVE_FREQ)*WAVE_MOVE_FREQ*BUMP_MOVE_FREQ) * vec3(cos(T), sin(T), sin(T-0.231))\n#define POINT_OFFSET (noise((p+vec3(0.01, -0.02, 0.23))*WAVE_FREQ) * WAVE_MOVE_FREQ * vec3(sin(T), cos(T), cos(T+0.231)))\n\n#define RGB(g) (g / 255.0)\n#define\tBLUE0 RGB(vec3(15,94,156))\n#define\tBLUE1 RGB(vec3(35,137,218))\n#define\tBLUE2 RGB(vec3(28,163,236))\n#define\tBLUE3 RGB(vec3(90,188,216))\n#define\tBLUE4 RGB(vec3(116,204,244))\n\n#define S(g) smoothstep(0.0, 1.0, g)\n\n#define T (27.9 + (iTime * TIME_SPEED))\n\n\nvec2 rot2D(vec2 p, float angle) {\n  angle = radians(angle);\n  float s = sin(angle);\n  float c = cos(angle);\n  return p * mat2(c, s, -s, c);\n}\n\nvec3 controller(vec3 dir, vec4 c, vec2 res) {\n    vec2 m = ((c.xy == vec2(0.) ? vec2(.5) : (c.xy / res.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    return dir;\n}\n\nvec3 noise(vec3 p) { return textureLod(iChannel0, p, 0.0).xyz; }\nvec3 waveNoise(vec3 p) { return textureLod(iChannel2, (p.xy+p.z)/512.0, 0.0).xyz; }\nvec3 noiseK(vec3 p) {\n    p += (T*0.01)*(0.33+(0.5+(0.5*cos(T*0.001))));\n    vec3 a = noise(p);\n    vec3 b = noise(p*0.5)*1.1;\n    vec3 c = noise((p+(b*0.01))*0.9)*1.1;\n    vec3 d = noise((p+(c*0.2))*1.9)*1.1;\n    \n    float shiftT = T*0.9;\n    vec3 shift = vec3(shiftT+(a.x*0.1), shiftT+(b.y*0.1), shiftT+(c.z*0.1))*0.1;\n    vec3 e = pow(noise((p+shift)*0.15), vec3(2.6)) * 5.0;\n    \n    return ((a + b + c + d + e) / 5.0) * (0.5+e);\n}\n\nfloat getDistWater(vec3 p) {\n    vec3 plane = vec3(0.0, WATER_Y, 0.0);\n    float d = plane.y - -p.y;\n    vec3 height = noiseK(((p*0.7)+POINT_OFFSET)*(WAVE_FREQ/WAVE_HEIGHT))*WAVE_HEIGHT;\n    \n    vec3 c = abs(height);\n    float m = 1.0 + (max(c.x, max(c.y, c.z)) * 0.01);\n    return (d - height.y) / m;\n}\n\n\n\nfloat getDist(vec3 p) {\n   float water = getDistWater(p);\n   return min(water, FAR);\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_SOFTNESS, 0.0);\n    vec3 n = normalize(getDist(p) - vec3(getDist(p-e.xyy), getDist(p-e.yxy), getDist(p-e.yyx)));\n    \n    vec3 bump = normalize(waveNoise((p+BUMP_OFFSET*0.5)*BUMP_FREQ*0.25));\n    \n    n += cross(n,bump)*BUMP_SCALE;\n    \n    return normalize(n);\n}\n\n\nvec3 getColor(vec3 p, float dist) {\n    vec3 pn = p*0.9;\n    pn += vec3(pn.x*(1.0+(-T*0.001)), pn.y*(1.0+(T*0.001)), pn.z*(1.0+(-T*0.001)));\n    vec3 pattern = waveNoise(pn*0.09);\n    pn += pattern;\n    float D = dist / FAR;\n    vec3 n = noiseK(pn*0.001);\n    vec3 ratio = S(n);\n    vec3 col = vec3(0.0);\n    col = mix(col, BLUE0, ratio.x);\n    col = mix(col, BLUE1, ratio.y);\n    col = mix(col, BLUE2, ratio.z);\n    col = col*(0.5+pattern*(0.2+D));\n    col += (col*BLUE4)/3.14;\n    return col*col;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float distro = 0.0;\n    \n    float dp = (max(0.0, dot(rd, vec3(0.0, 1.0, 0.0))));\n    \n    if (dp > 0.005) return FAR;\n\n    \n    int count = 0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+(rd*distro);\n        float dist = getDist(p);\n        \n        distro += dist;\n        \n        if (abs(dist) >= FAR || abs(dist) <= THRESHOLD) break;\n        count++;\n    }\n    \n    distro = abs(distro+dp);\n    \n    return count <= 0 ? (FAR+(THRESHOLD*3.0)): distro;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n\n    float dist = march(ro, rd);\n    \n    vec3 lightPos = vec3(0.0, 10.0, 2.0);\n    vec3 lightColor = vec3(0.9, 0.4, 0.1);\n    vec3 L = normalize(vec3(0.0, -2.0, -3.0));\n    float lightStrength = 0.6;\n    vec3 p = ro+(rd*dist);\n    float dotUp = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    float dotLight = max(0.0, dot(-L, rd));\n    \n    if (dist < FAR) {\n        \n        \n        float lightDist = distance(p, lightPos);\n        vec3 norm = getNormal(p);\n\n        float NdotL = max(0.0, dot(norm, L));\n        float att = NdotL*lightStrength;\n        \n        vec3 viewdir = normalize(p - ro);\n        vec3 reflectDir = normalize(reflect(-L, norm));\n        float VdotR = max(dot(viewdir, reflectDir), 0.0);\n        \n        col += vec3(2.0) * pow(VdotR, 16.0);\n        \n        vec3 albedo = getColor(p, dist);\n        \n        col += albedo*lightColor*att;\n    } else {\n        col += clamp(BLUE1*3.6, 0.0, 1.0)*dotUp;\n    }\n    \n    vec3 flare = lightColor*clamp(pow(dotLight,3.0), 0.0, 1.0);\n     float dp = (max(0.0, dot(rd, vec3(0.0, 1.0, 0.0))));\n    \n    float depth = (abs(dist)/FAR);\n    depth += dp*FAR;\n    float fog = max(0.0, depth);\n\n    col +=  (fog * mix(BLUE1, BLUE0, clamp((depth*depth), 0.0, 1.0)));\n    col += flare*0.67;\n    \n    return col;\n}\n\nvec3 tonemap(vec3 col) {\n    vec3 x = col;\n    vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n    float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n    \n    x = clamp(\n        (x * (2.51 * x + 0.03)) /\n        (x * (2.23 * x + 1.0392) + 0.98),\n    0.0, 1.0);\n   \n    x = saturate(x, dotVio);\n    x = mix(x, pow(x, vec3(2.0)), 0.3491*pow(dotVio, 2.0));\n    x += luma(x)/6.28;\n    x = clamp(x+(x/6.28), 0.0, 1.0);\n    \n    return pow(x, vec3(0.5125));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 res = iResolution.xy;\n    vec2 uv = (fc-0.5*iResolution.xy)/res.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 0.1);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n   \n    ro.y += 8.0;\n    \n    \n    //ro.y += 50.0;\n    if (iMouse.z > 0.01 && iFrame > 16) {\n        rd = controller(rd, iMouse, res);\n        rd = normalize(rd);\n        \n        vec3 walk = texture(iChannel1, vec2(0.0)).xyz;\n        ro += walk;\n    } else  {\n        ro.z = T*100.2;\n        float fly = (0.5+(0.5*cos(T)))*33.0;\n        ro.y += fly;\n        \n        \n        float ry = iFrame <= 16 ? 0.0 : mix(radians(34.), radians(30.), 1.6*(0.5+(0.5*cos(T*3.0))));\n        vec3 rot = vec3(0.0, ry, 0.0);\n        rd = controller(rd, vec4(rot.xyz, 1.0), vec2(1.0));\n        rd.x += 0.5*sin(T);\n    }\n    \n    \n    \n    #if AA_ENABLED\n    const int filterSize = AA_FILTER_SIZE;\n    const int halfFilterSize = filterSize / 2;\n\n    const int start = -halfFilterSize;\n    const int end = -halfFilterSize + filterSize;\n\n    vec3 avg = vec3(0.0);\n    float texelSize = 1.0 / res.x;\n    for(int x = start; x < end; ++x)\n    {\n        for(int y = start; y <= end; ++y)\n        {\n          avg += render(ro, rd+(texelSize*vec3(x, y, 0.0)));\n        }\n    }\n\n    avg /= float(pow(float(filterSize), 2.));\n    col = avg;\n    #else\n    col += render(ro, rd);\n    #endif\n\n    col = tonemap(col);\n   // col = aces(col);\n    col = mix(col, col*col, 0.2);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.5 / 256.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,-3.);\n    \n    float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n    float speed = MOVE_SPEED * iTimeDelta;\n    \n    speed *= 1. + 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n    speed *= 3.0;\n    \n    float forwardBackward =\n\ttexture(iChannel0, vec2(KEY_W, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_S, 0.)).r;\n\n\tfloat leftRight =\n\ttexture(iChannel0, vec2(KEY_A, 0.)).r -\n\ttexture(iChannel0, vec2(KEY_D, 0.)).r;\n\n\tfloat s = sin(radians(mx));\n\tfloat c = cos(radians(mx));\n\n\tpos.x += speed * (forwardBackward * s - leftRight * c);\n\tpos.z += speed * (forwardBackward * c + leftRight * s);\n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n","name":"Common","description":"","type":"common"}]}