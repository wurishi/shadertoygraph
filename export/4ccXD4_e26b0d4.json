{"ver":"0.1","info":{"id":"4ccXD4","date":"1715432113","viewed":63,"name":"Sonic: gotta move quick!","username":"Miolith","description":"I wanted to make mario instead but nintendo lawyers started knocking at my door","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","vfx","sonic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = acos(-1.);\n\nfloat saturate(float x) { return clamp(x, 0., 1.); }\nvec2 saturate(vec2 v) { return vec2(saturate(v.x), saturate(v.y)); }\nconst vec3 sunLight = normalize(vec3(0.7,0.1,0.4));\nconst vec3 sunPos = sunLight * 1000.0;\n\nconst int SONIC = 0;\nconst int TERRAIN = 1;\nconst int MAIN_SPIN_AURA = 2;\n\nstruct Camera\n{\n    mat4 projToWorld;\n    mat4 camToWorld;\n    vec2 halfTanFov;\n};\n\nstruct Ray\n{\n    vec3 orig;\n    vec3 dir;\n};\n\nstruct RayHit\n{\n    int id;\n    float dist;\n};\n\nstruct RayHitVFX\n{\n    int id;\n    float dist;\n    float opacity;\n};\n\nRayHit minRay(RayHit a, RayHit b)\n{\n    if (a.dist < b.dist)\n        return a;\n    return b;\n}\n\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nCamera MakeCamera(vec3 position, vec3 target, vec2 tanHalfFov)\n{\n    vec3 up = vec3(0., 0., 1.);\n\n    float nearZ = 0.1;\n    float farZ = 1000.;\n    float zRange = farZ - nearZ;\n    float ooRange = 1. / zRange;\n    float foRange = farZ* ooRange;\n\n    vec3 camZ = normalize(target - position);\n    vec3 camX = normalize(cross(camZ, up));\n    vec3 camY = cross(camZ, camX);\n\n    mat4 PInv = mat4(0.);\n\n    PInv[0][0] = tanHalfFov.x;\n    PInv[1][1] = tanHalfFov.y;\n\n    PInv[3][2] = 1.;\n\n    PInv[0][3] = 0.;\n    PInv[1][3] = 0.;\n    PInv[2][3] = 1./(-nearZ*foRange);\n    PInv[3][3] = 1./nearZ;\n    Camera result;\n\n    mat4 camToWorld;\n    camToWorld[0] = vec4(camX, 0.);\n    camToWorld[1] = vec4(camY, 0.);\n    camToWorld[2] = vec4(camZ, 0.);\n    camToWorld[3] = vec4(position, 1.);\n\n    result.camToWorld = camToWorld;\n    result.projToWorld = camToWorld * PInv;\n    return result;\n}\n\nvoid updateCamera(out vec3 camera_target, out vec3 camera_position)\n{\n    camera_target = vec3(0., 0., 0.);\n    vec2 mouse = saturate(iMouse.xy / vec2(iResolution.xy)) * 2. - 1.;\n    float a = -3.5*mouse.x - 0.25*PI;\n    float b = (0.15 - 0.145 * mouse.y) * PI;\n    vec3 toCam = 25. * vec3(cos(a)*cos(b), sin(a)*cos(b), sin(b));\n    camera_position = camera_target + toCam;\n}\nRay GenerateCameraRay(vec2 uv)\n{\n    vec3 camera_target;\n    vec3 camera_position;\n    updateCamera(camera_target, camera_position);\n\n    const float camera_hfovX = 0.5;\n    float camera_hfovY = camera_hfovX * iResolution.y / iResolution.x;\n\n    Camera cam = MakeCamera(camera_position, camera_target, vec2(camera_hfovX, camera_hfovY));\n    Ray ray;\n    ray.orig = cam.camToWorld[3].xyz;\n    vec2 screenPosm11 = uv * 2. - 1.;\n    vec4 dirw4 = cam.projToWorld*vec4(screenPosm11, 1, 1);\n    ray.dir = normalize((dirw4).xyz);\n    return ray;\n}\n\nvec3 Sky(vec3 ray)\n{\n    return (1.0 + 0.5*ray.y) * vec3(0.600,0.757,0.945);\n}\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.3,0.4,0.5)*0.3 - 0.3*rd.y;\n\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel0, .000003*uv.yx ).x;\n        cl = smoothstep(0.3,0.7,cl);\n        col = mix( col, vec3(0.3,0.2,0.1), 0.1*cl );\n    }\n    \n    col = mix( col, vec3(0.2,0.25,0.30)*0.5, exp(-30.0*rd.y) ) ;\n    \n    float sd = pow( clamp( 0.25 + 0.75*dot(sunLight,rd), 0.0, 1.0 ), 4.0 );\n    col = mix( col, vec3(1.2,0.30,0.05)/1.2, sd*exp(-abs((60.0-50.0*sd)*rd.y)) ) ;\n    \n    return col;\n}\n\nvec3 bezier(vec3 a, vec3 b, vec3 c, float t)\n{\n    return mix(\n        mix(a, b, t),\n        mix(b, c, t),\n        t\n    );\n}\n\nfloat lineDist(vec3 pos, vec3 start, vec3 end, float r)\n{\n    vec3 line = end - start;\n    vec3 start_pos = pos - start;\n    \n    return length(start_pos - line*clamp(dot(start_pos, line)/dot(pos,pos), 0.0, 1.0)) - r;\n}\n\nfloat sdfBezier(vec3 pos, vec3 a, vec3 b, vec3 c)\n{\n    const int divide_factor = 20;\n    \n    float dist = 1e9;\n    float t0 = 0.0;\n    for (int i = 1; i <= divide_factor; i++)\n    {\n        float t1 = float(i)/float(divide_factor);\n        \n        dist = min(dist, lineDist(pos, bezier(a, b, c, t0), bezier(a, b, c, t1), 0.2));\n        \n        t0 = t1;\n    }\n    \n    return dist;\n}\n\nvoid swap(inout vec3 a, inout vec3 b)\n{\n    vec3 c = a;\n    a = b;\n    b = c;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nmat2 rotate2d(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nmat2 shear2d(float angle)\n{\n    return mat2(1, tan(angle),\n                0,          1);\n}\n\nRayHit sonic(vec3 pos)\n{\n    RayHit rh;\n    rh.id = SONIC;\n    \n    const float rad = 1.0;\n    pos.xy *= rotate2d(radians(90.0));\n    pos.xz *= shear2d(radians(10.0));\n    rh.dist = sdCappedCylinder(pos, 0.01, 1.0) - 1.5;\n    \n    return rh;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nRayHit terrain(vec3 pos)\n{\n    RayHit rh;\n    rh.id = TERRAIN;\n    \n    rh.dist = sdBox(pos+vec3(0.0,0.0,2.9), vec3(20.0, 100.0, 0.5));\n    \n    return rh;\n}\n\nRayHit sdfScene(vec3 pos)\n{\n    int time = int(iTime * 10.) / 3;\n    float fltime = float(time);\n    \n    vec3 a = vec3(0.0);\n    vec3 b = vec3(0.0, 2.0, 2.0);\n    vec3 c = vec3(0.0, 0.0, 4.0);\n    \n    return minRay(sonic(pos), terrain(pos));\n    //sdfBezier(pos, a, b, c);\n}\n\n#define ZERO (min(iFrame,0)) // non-constant zero\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float h = 0.0001;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdfScene(pos+e*h).dist;\n    }\n    return normalize(n);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<150 && t<maxt; i++ )\n    {\n        float h = sdfScene(ro + t*rd).dist;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\nvec3 phong(vec3 view, vec3 norm)\n{\n    return vec3(1.0) * pow(max(0., dot(view, reflect(sunLight, norm))), 16.);\n}\n\n\nRayHitVFX sdfSceneVFX(vec3 pos)\n{\n    RayHitVFX rh;\n    rh.id = MAIN_SPIN_AURA;\n    rh.opacity = 0.3;\n    \n    const float h = 1.5;\n    float angle = atan(pos.z, pos.y);\n    float len = length(pos.zy);\n    \n    angle -= len*0.5;\n    \n    pos.yz = len*vec2(cos(angle), sin(angle));\n    \n    pos.yz *= rotate2d(iTime * 15.0);\n    pos.xz *= rotate2d(radians(90.));\n    float d = sdEquilateralTriangle(pos.xy, 4.9);\n    vec2 w = vec2( d, abs(pos.z) - h );\n    rh.dist = min(max(w.x,w.y),0.0) + length(max(w,0.0)) - 0.4;\n\n    return rh;\n}\n\nvec3 RenderMain(uvec2 pixelPos, vec2 uv)\n{\n    Ray ray = GenerateCameraRay(uv);\n    \n    float t = 0.0;\n    vec3 pos;\n    RayHit rh;\n    for (int i = 0; i < 80; i++)\n    {\n        pos = ray.orig + ray.dir * t;\n        \n        rh = sdfScene(pos);\n        \n        if (rh.dist < 0.001 || t > 100.0)\n            break;\n        \n        t += rh.dist;\n    }\n    \n    vec3 ocol = vec3(0.0);\n    if (t <= 100.0)\n    {\n        vec3 norm = calcNormal(pos) ;\n        float contrib = max(0.0, dot(sunLight, norm));\n        \n        if (rh.id == SONIC)\n            ocol = contrib * vec3(0.051,0.051,0.600) + phong(ray.dir, norm);\n        else if (rh.id == TERRAIN)\n            ocol = contrib * texture(iChannel0, pos.xy*0.1+vec2(0.0, iTime*10.0)).rgb\n                    * softshadow(pos, sunLight, 0.01 , 100., 0.2);\n    }\n    else\n        ocol = Sky(ray.dir);\n    \n    RayHitVFX rh_vfx;\n    vec3 pos_vfx;\n    float t_vfx = 0.0;\n    \n    for (int i = 0; i < 50; i++)\n    {\n        pos_vfx = ray.orig + ray.dir * t_vfx;\n        \n        rh_vfx = sdfSceneVFX(pos_vfx);\n        \n        if (rh_vfx.dist < 0.001 || t_vfx > min(100.0, t))\n            break;\n        \n        t_vfx += rh_vfx.dist;\n    }\n    \n    if (t_vfx < min(100., t))\n    {\n        ocol = mix(ocol, vec3(0.208,0.518,0.894), rh_vfx.opacity);\n    }\n    \n    ocol = pow(ocol, vec3(0.45));\n    return ocol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 pixelPos = uvec2(fragCoord);\n    vec2 uv = fragCoord/vec2(iResolution.xy);\n    uv.y = 1.-uv.y;\n    fragColor.rgb = RenderMain(pixelPos, uv);\n}","name":"Image","description":"","type":"image"}]}