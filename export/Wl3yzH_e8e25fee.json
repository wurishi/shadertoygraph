{"ver":"0.1","info":{"id":"Wl3yzH","date":"1608441050","viewed":98,"name":"fucked up 3d rotation","username":"alice","description":"first raymarching thing. supposed to be an infinite field of cube/sphere intersection things, each with a random rotation. i messed up the rotation function though, and thought it looked cool. comment out line 47 to see how it looks unfucked","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","glitch","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Set this define for shadertoy\n#define shadertoy\n\n#ifndef shadertoy\n#define fragColor gl_FragColor\n#define fragCoord gl_FragCoord\n#define iResolution u_resolution\n#define iMouse u_mouse\n#define iTime u_time\n#endif\n\n#define PI 3.1415926538\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nconst int MAX_STEPS = 500;\nconst float MIN_RAY_LEN = .1;\nconst float MAX_RAY_LEN = 10000.;\nconst float RAY_HIT_THRESH = 0.01;\n\nfloat rand1(vec3 i){\n    return fract(sin(dot(i,vec3(15.736564920423735,87.35522147781187,78.89253088762932))) * 43758.5453);\n}\n\nvec3 rotateAxis(vec3 p, vec3 axis, float angle) {\n    return mix(dot(axis, p)*axis, p, cos(angle)) + cross(axis,p)*sin(angle); // ??? idk, it's from blackle\n}\n\nfloat sphere(vec3 samplePoint, float r) {\n    return length(samplePoint) - r;\n}\n\nfloat cube(vec3 samplePoint, float r) {\n  vec3 q = abs(samplePoint) - r;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n}\n\nvec3 repeat(vec3 samplePoint, vec3 pitch) {\n    return mod(samplePoint+0.5 * pitch, pitch)-0.5*pitch;\n}\n\nfloat scene(vec3 samplePoint) {\n    vec3 localPoint = repeat(samplePoint+1.5, vec3(3.));\n    vec3 gridPos = floor((samplePoint+1.5)/3.);\n    localPoint = rotateAxis(localPoint, vec3(rand1(vec3(gridPos.x+0.01, gridPos.y, gridPos.z)), rand1(vec3(gridPos.x, gridPos.y+0.01, gridPos.z)), rand1(vec3(gridPos.x, gridPos.y, gridPos.z+0.01))), PI);\n    return max(sphere(localPoint, 1.), cube(localPoint, 0.8));\n}\n\nvec3 rayDirection(vec2 fragCoord, vec2 image_size, float fov) {\n    vec2 xy = fragCoord.xy - image_size.xy / 2.;\n    float z = min(image_size.x, image_size.y) / tan(radians(fov) / 2.); // we don't need length(xy) here because fov just refers to the fov of a single axis\n    return normalize(vec3(xy, -z));\n}\n\nfloat shortestDistance(vec3 cameraPosition, vec3 rayDirection) {\n    float len = MIN_RAY_LEN;\n    for (int i=0; i < MAX_STEPS; i++) {\n        float dist = scene(cameraPosition + len * rayDirection);\n        // isn't there a better way than just getting infinitesimally closer till we're within some tiny radius?\n        // if we figured out the normal when we get close to the final surface, couldn't we extrapolate an expected point of intersection that way? then raymarch up to that, but allow the loop to continue in case we're just grazing past\n        if (dist < RAY_HIT_THRESH) {\n            return len;\n        }\n        len += dist;\n        if (len >= MAX_RAY_LEN) {\n            return MAX_RAY_LEN;\n        }\n    }\n    return MAX_RAY_LEN;\n}\n\nvec3 normal(vec3 p) {\n    float original_dist = scene(p);\n    // we lose a little precision by not having our normal centered on the target point but rather sticking out a bit by RAY_HIT_THRESH, but we're saving 2 SDF evaluations\n    return normalize(vec3(\n        scene(vec3(p.x + RAY_HIT_THRESH, p.y, p.z)) - original_dist,\n        scene(vec3(p.x, p.y + RAY_HIT_THRESH, p.z)) - original_dist,\n        scene(vec3(p.x, p.y, p.z + RAY_HIT_THRESH)) - original_dist\n    ));\n}\n\nvec2 circularMotion(float time, float radius) {\n    return vec2(sin(time), cos(time))*radius;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime/10.;\n    vec3 cameraPosition = vec3(circularMotion(time*3., 1.5), time*10.)+1.5;\n    vec3 dir = rotateAxis(rayDirection(fragCoord, iResolution.xy, 110.), vec3(0., 1., 0.), time);\n    float dist = shortestDistance(cameraPosition, dir);\n    vec3 point = cameraPosition + dist * dir;\n    vec3 normal = normal(point);\n    vec3 color = pow(normal*0.5+0.5, vec3(2.));\n    fragColor = vec4(dist >= MAX_RAY_LEN ? vec3(0) : color, 1.);\n}\n\n#ifndef shadertoy\nvoid main() {\n    mainImage(fragColor, fragCoord.xy);\n}\n#endif\n","name":"Image","description":"","type":"image"}]}