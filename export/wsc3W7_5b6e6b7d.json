{"ver":"0.1","info":{"id":"wsc3W7","date":"1583280357","viewed":164,"name":"VF IsoLines","username":"iaian7","description":"Testing WebGL performance versus the Vuo 2.0 beta using the IsoLines developed for Vectorform 2019 branding.\nCustom textures must be loaded for this to work, please follow the instructions in the comments at the top of the code block.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","screensaver","vectorform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCustom texture loading via https://www.shadertoy.com/view/lsGGDd\n\nOpen the console (command+option+J for Chrome in MacOS) and paste the four following lines:\n\ngShaderToy.SetTexture(0, {mSrc:'https://dl.dropboxusercontent.com/s/hfxl01sl3ouhorp/VF-IsoLines-img1.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(1, {mSrc:'https://dl.dropboxusercontent.com/s/irnn3l6fgqcb1zd/VF-IsoLines-img2.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(2, {mSrc:'https://dl.dropboxusercontent.com/s/q7ozunf5f2udedi/VF-IsoLines-img3.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\ngShaderToy.SetTexture(3, {mSrc:'https://dl.dropboxusercontent.com/s/yjbusr8mi0qwr9u/VF-IsoLines-img4.png?dl=0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n\nThis shader will not work without these texture inputs!\n*/\n\n\nfloat Perlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\n\nvec2 rotate2( vec2 xy, float r ) {\n\tvec2 ab = xy;\n\tab.x = xy.x * cos(r) - xy.y * sin(r);\n\tab.y = xy.y * cos(r) + xy.x * sin(r);\n\treturn ab;\n}\n\nfloat Screen(float a, float b) {\n\treturn 1.0 - ((1.0 - a) * (1.0 - b));\n}\n\nvec2 Rotate(vec2 xy, float angle){\n\treturn vec2(xy.x*cos(angle) - xy.y*sin(angle), xy.x*sin(angle) + xy.y*cos(angle));\n}\n\nvec2 Triangle(vec2 uv, float c){\n\tfloat r = 0.5235988;\n\tvec2 o = uv;\n\to.x = floor(uv.x * c + 0.5);\n\to.y = mix(floor(Rotate(uv * c + 0.5, r).y), floor(Rotate(uv * c + 0.5, -r).y), 0.5);\n//\to.y /= cos(0.5235988);\n//\to.y /= 0.86602539158;\n\to.y *= 1.154700555; // This shifts the Y channel back into a -0.5 to +0.5 range, otherwise scrolling the pattern actually changes the output range as well\n\treturn o / c;\n}\n\nvec2 TriangleUV(vec2 uv, float c, float r, float s){\n\tuv = Rotate(uv, r);\n\t// Fix alignment (based on the pre-rendered lines)\n\tuv.x += (1.0/c)*0.25;\n\tuv.y -= 0.01;\n\t// Larger numbers (over 10k) hit major issues with value rounding.\n\t// Scrolling needs to be within a much smaller range, so this is designed for a 0-1 loop.\n\t// The magic number scales the scrolling value to a compatible loop point.\n\tuv.y += s * 1.154700555;\n\tuv = Triangle(uv, c);\n\t// Invert the vertical scroll so the output UV values remain static, just the pattern scrolls\n\tuv.y -= s * 1.154700555;\n\tuv = Rotate(uv, -r);\n\tuv += 0.5;\n\n\treturn uv;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tfragColor = vec4((fragCoord/iResolution.xy).rg, 0.5, 1); // This is the default UV output\n\n\t// Declare variables (these were all dynamic inputs in the Quartz composition)\n\tfloat Time = iTime;\n\tfloat Scroll = 0.0125;\n\tfloat Depth = 0.25;\n\tfloat Cycle = 0.5;\n\tfloat CycleSpeed = -0.5;\n\tfloat Overlap = 0.75;\n\tfloat Rotation = -0.7854;\n\tfloat Contrast = 0.2;\n\tfloat NoiseStrength = 0.875;\n\tfloat NoiseSpeed = 1.0;\n\tvec4 Color1 = vec4(0.5962, 0.1490, 0.4745, 1.0); // Lines middle\n\tvec4 Color2 = vec4(0.1804, 0.1922, 0.4942, 1.0); // Lines sides\n\tvec4 ColorBG = vec4(0.07451, 0.09022, 0.2471, 1.0); // Background (mixed with black)\n\n\t// Process UV map\n\tvec2 uv = fragCoord.xy / 8192.0; // This sets a fixed resolution for the texture patterns instead of being screen dependent\n\tfloat gradient = abs((fragCoord.x / iResolution.x) - 0.5) * 2.0; // Screen width gradient\n\n\t// Create triangular noise pattern (initial magic number for the scale = 11.0)\n    float n = smoothstep(-Contrast, Contrast, Perlin3D(vec3(TriangleUV(uv + iMouse.xy, 11.0, Rotation, Time * Scroll)*10.0, Time * NoiseSpeed)));\n\n\t// Prep for image sampling\n\tuv = Rotate(uv, Rotation); // Rotate the UV map\n\tfloat cascade = Time * Scroll; // Scroll the UV map using time and scroll speed inputs\n\n\t// Create pulse\n\tfloat pulse = Time * CycleSpeed * -Cycle + uv.y * Cycle;\n\n\t// Sample textures and create the offset waves, combining RGB channels into just the red channel\n\tvec4 tex1 = texture(iChannel0, uv+vec2(0.0, cascade));\n\ttex1.rgb /= tex1.aaa;\n\ttex1.rgb = clamp((tex1.rgb*2.0)-1.0, 0.0, 1.0); // Thin out the lines without using Smoothstep\n\ttex1.rgb *= smoothstep(vec3(0.0), vec3(1.0), abs(mod(pulse + tex1.a + vec3(0.0, 0.3333, 0.6666),        1.0)*2.0-1.0))*Overlap*4.0+1.0-Overlap*4.0;; // Create the fade in/out cycle for all three channels\n\ttex1.r = max(max(tex1.r, tex1.g), tex1.b); // Combine channels (if the smoothstep line above is commented out)\n\n\tcascade += Time * Scroll * Depth;\n\tvec4 tex2 = texture(iChannel1, uv+vec2(0.0, cascade));\n\ttex2.rgb /= tex2.aaa;\n\ttex2.rgb = clamp((tex2.rgb*2.0)-1.0, 0.0, 1.0); // Thin out the lines without using Smoothstep\n\ttex2.rgb *= smoothstep(vec3(0.0), vec3(1.0), abs(mod(pulse + tex2.a + vec3(0.0, 0.3333, 0.6666) + 0.25, 1.0)*2.0-1.0))*Overlap*4.0+1.0-Overlap*4.0;; // Create the fade in/out cycle for all three channels\n\ttex2.r = max(max(tex2.r, tex2.g), tex2.b); // Combine channels (if the smoothstep line above is commented out)\n\n\tcascade += Time * Scroll * Depth;\n\tvec4 tex3 = texture(iChannel2, uv+vec2(0.0, cascade));\n\ttex3.rgb /= tex3.aaa;\n\ttex3.rgb = clamp((tex3.rgb*2.0)-1.0, 0.0, 1.0); // Thin out the lines without using Smoothstep\n\ttex3.rgb *= smoothstep(vec3(0.0), vec3(1.0), abs(mod(pulse + tex3.a + vec3(0.0, 0.3333, 0.6666) + 0.50, 1.0)*2.0-1.0))*Overlap*4.0+1.0-Overlap*4.0;; // Create the fade in/out cycle for all three channels\n\ttex3.r = max(max(tex3.r, tex3.g), tex3.b); // Combine channels (if the smoothstep line above is commented out)\n\n\tcascade += Time * Scroll * Depth;\n\tvec4 tex4 = texture(iChannel3, uv+vec2(0.0, cascade));\n\ttex4.rgb /= tex4.aaa;\n\ttex4.rgb = clamp((tex4.rgb*2.0)-1.0, 0.0, 1.0); // Thin out the lines without using Smoothstep\n\ttex4.rgb *= smoothstep(vec3(0.0), vec3(1.0), abs(mod(pulse + tex4.a + vec3(0.0, 0.3333, 0.6666) + 0.75, 1.0)*2.0-1.0))*Overlap*4.0+1.0-Overlap*4.0;; // Create the fade in/out cycle for all three channels\n\ttex4.r = max(max(tex4.r, tex4.g), tex4.b); // Combine channels (if the smoothstep line above is commented out)\n\n\t// Composite all four texture results\n\ttex1.r = max(max(tex1.r, tex2.r), max(tex3.r, tex4.r));\n//\ttex1.r = max(tex1.r, tex3.r);\n\n\t// Final output\n\tfragColor = mix(mix(ColorBG, ColorBG*NoiseStrength, n), mix(Color1, Color2, gradient), tex1.r);// * tex1.a;\n}","name":"Image","description":"","type":"image"}]}