{"ver":"0.1","info":{"id":"wtd3DB","date":"1577509864","viewed":115,"name":"Ornament 12272019","username":"bad_dreams_","description":"A little bit late for the holidays ðŸŽ„","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct HitResult {\n  float dist;\n  vec3 point;\n  vec3 normal;\n  int material;\n};\n\nfloat sphereDistance(vec3 point, float radius) {\n  return length(point) - radius;\n}\n\nfloat cylinderDistance(vec3 point, float radius, float height) {\n  vec2 d = abs(vec2(length(point.xz), point.y)) - vec2(radius, height);\n  return min(max(d.x,d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat torusDistance(vec3 point, vec2 radius) {\n  vec2 q = vec2(length(point.xy) - radius.x, point.z);\n  return length(q) - radius.y;\n}\n\nHitResult shapeUnion(HitResult a, HitResult b) {\n  if (a.dist < b.dist) { return a; }\n  return b;\n}\n\nHitResult smoothShapeUnion(HitResult a, HitResult b, float smoothness) {\n    float h = clamp(0.5 + 0.5 * (b.dist - a.dist) / smoothness, 0.0, 1.0);\n    float smoothedDist = mix(b.dist, a.dist, h) - smoothness * h * (1.0 - h);\n    \n    return HitResult(smoothedDist, b.point, vec3(0.0), a.material);\n}\n\nHitResult sceneDistance(vec3 point) {\n    mat4 roll = rotateZ(PI * 0.45);\n    point = (roll * vec4(point, 1.0)).xyz;\n    \n    float bulbDist = sphereDistance(point, 1.0);\n \tHitResult bulb = HitResult(bulbDist, point, vec3(0.0), MATBULB);\n    \n    float bulbTopDist = cylinderDistance(point - vec3(0.0, 1.0, 0.0), 0.13, 0.1);\n    HitResult bulbTop = HitResult(bulbTopDist, point, vec3(0.0), MATBULB);\n    \n    float capDist = cylinderDistance(point - vec3(0.0, 1.08, 0.0), 0.18, 0.055);\n    HitResult cap = HitResult(capDist, point, vec3(0.0), MATSILVER);\n    \n    float ringDist = torusDistance(point - vec3(0.0, 1.15, 0.0), vec2(0.08, 0.008));\n    HitResult ring = HitResult(ringDist, point, vec3(0.0), MATSILVER);\n    \n    return shapeUnion(\n        smoothShapeUnion(bulb, bulbTop, 0.15),\n        shapeUnion(cap, ring)\n    );\n}\n\nvec3 sceneNormal(vec3 point) {\n \tfloat epsilon = 0.01;\n    vec3 xOffset = vec3(epsilon, 0.0, 0.0);\n    vec3 yOffset = vec3(0.0, epsilon, 0.0);\n    vec3 zOffset = vec3(0.0, 0.0, epsilon);\n    \n    vec3 direction = vec3(\n        sceneDistance(point + xOffset).dist - sceneDistance(point - xOffset).dist,\n        sceneDistance(point + yOffset).dist - sceneDistance(point - yOffset).dist,\n        sceneDistance(point + zOffset).dist - sceneDistance(point - zOffset).dist\n\t);\n    \n    return normalize(direction);\n}\n\nvec3 normalToColor(vec3 direction) {\n \treturn (direction + vec3(1.0)) * 0.5;\n}\n\nvec3 envColor(vec3 direction, float roughness) {\n\treturn mix(\n        gamma(texture(iChannel1, direction).rgb, 2.2),\n        gamma(texture(iChannel0, direction).rgb, 2.2),\n        roughness\n\t);\n}\n\nvec3 materialColor(int material, vec3 point, vec3 viewDirection, vec3 normal) {\n    vec3 reflected = reflect(viewDirection, normal);\n    \n    float fresnel = (1.0 - dot(-normal, viewDirection));\n\tfresnel = pow(fresnel, 3.0);\n    \n    switch (material) {\n        case MATSILVER: {\n            float specularScale = clamp(0.9 + fresnel, 0.0, 1.0);\n            return specularScale * envColor(reflected, 0.5);\n        }\n        case MATBULB: {\n            float pattern = clamp(voronoi(point), 0.0, 1.0);\n            vec3 diffuse = vec3(1.0) * mix(0.4, 1.0, pattern);\n\n            float specularScale = clamp(0.1 + fresnel * 1.5, 0.0, 1.0);\n            float diffuseScale = 1.0 - specularScale;\n\n\t\t\treturn diffuseScale * diffuse + specularScale * envColor(reflected, pattern);\n        }\n        default: return vec3(0.0);\n    }\n}\n\nvec3 sceneColor(vec2 uv) {\n    vec3 origin = vec3(0.0, 0.2, -2.0);\n    vec3 direction = normalize(vec3(uv.x, uv.y, 0.6));\n\n\tmat4 pitch = rotateX(2.1);\n\tmat4 yaw = rotateY(iTime * 0.5);\n    mat4 transform = yaw * pitch;\n    \n    origin = (transform * vec4(origin, 1.0)).xyz;\n    direction = (transform * vec4(direction, 0.0)).xyz;\n    \n    int material = -1;\n    vec3 testPoint = vec3(0.0);\n    vec3 surfaceNormal = vec3(0.0);\n    \n    bool hit = false;\n    for (float time = 0.0; time < 8.0; time += 0.00001) {\n        testPoint = origin + direction * time;\n        HitResult result = sceneDistance(testPoint);\n        time += result.dist;\n        \n        if (result.dist < 0.0001) {\n            hit = true;\n            material = result.material;\n            surfaceNormal = sceneNormal(testPoint);\n            break;\n        }\n    }\n    \n    return hit\n        ? materialColor(material, testPoint, direction, surfaceNormal)\n        : envColor(direction, 0.2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 color = gamma(sceneColor(uv), 1.0 / 2.2);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n#define MATSILVER 0\n#define MATBULB 1\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nfloat rand(float time) {\n\treturn fract(sin(time * 39813.31) * 1983.013);\n}\n\nfloat voronoi(vec3 point) {\n    const float cells = 1024.0;\n    float closest = 1e16;\n    float value = 0.0;\n\n    for (float index = 0.0; index < cells; index += 1.0) {\n\t\tvec3 p = vec3(rand(index + 0.25), rand(index + 0.5), rand(index + 0.75));\n        p = p * 2.0 - vec3(1.0);\n\n        float v = rand(index);\n        float dist = distance(point, p);\n        \n        if (dist < closest) {\n            closest = dist;\n            value = v;\n        }\n    }\n    \n    return value;\n}\n\n\nmat4 rotateX(float angle) {\n\tfloat x = cos(angle);\n    float y = sin(angle);\n    return mat4(\n        1, 0,  0, 0,\n        0, y, -x, 0,\n        0, x,  y, 0,\n        0, 0,  0, 1\n\t);\n}\n\nmat4 rotateY(float angle) {\n\tfloat x = cos(angle);\n    float y = sin(angle);\n    return mat4(\n\t\tx, 0, y, 0,\n        0, 1, 0, 0,\n        y, 0,-x, 0,\n        0, 0, 0, 1\n    );\n}\n\nmat4 rotateZ(float angle) {\n\tfloat x = cos(angle);\n    float y = sin(angle);\n    return mat4(\n        y, -x, 0, 0,\n        x,  y, 0, 0,\n        0,  0, 1, 0,\n        0,  0, 0, 1\n\t);\n}\n\n\n","name":"Common","description":"","type":"common"}]}