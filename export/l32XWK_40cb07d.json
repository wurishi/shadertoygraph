{"ver":"0.1","info":{"id":"l32XWK","date":"1711217381","viewed":60,"name":"Trying to make volumetric fog","username":"TheJinxedArtist","description":"Behold, my latest attempt to make some volumetric fog. I plan on using this for an open world game, but can't seem to find a fast way to make the fog appear far away.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","volumetric","fog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c\n  );\n}\n\n//Fog's density map, just a gradient.\nfloat GetDensity(vec3 p) {\n    return p.y*.1;\n}\n\n//Distance to scene, just for making the fog interact with the scene.\nfloat Scene(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < 1024; i++) {\n        vec3 p = ro + rd * d;\n        d += min(length(p + vec3(0.0, 3.0, 0.0)) - 1.0, p.y + 3.0);\n        if(d < 0.001 || d > 1000.0) break;\n    }\n    return d;\n}\n\nconst float maxDist = 100.0;\nconst int samples = 512;\nconst float stepSize = maxDist / float(samples);\nfloat RayMarch(vec3 ro, vec3 rd, float scene, float jitter) {\n    float d = 0.0; //Distance to fog\n    float a = 0.0; //Fog accumulation\n    for(int i = 0; i < samples; i++) {\n        vec3 p = ro + rd * d; //Sample position\n        \n        //Create an invisible infinite plane to mask where the rays should and should't be calculated.\n        bool plane = dot(rd, vec3(0,1,0)) > 0.01 && p.y > 0.01;\n        if(plane) break;\n        \n        //Factor in the world's depth.\n        if(d >= scene) break;\n        \n        //Get the fog density.\n        float m = GetDensity(p);\n        \n        //If the ray is inside the fog, increment accumulation and distance.\n        if(m < 0.01) {\n            d += stepSize + jitter * stepSize;\n            a += (stepSize * -m) + jitter * stepSize;\n        } //If the ray is outside the fog, but will enter it, use spheretracing to conserve rays.\n        else if(m >= 0.01 && d < maxDist) {\n            d += m;\n        } //If the ray is too far away, destroy it.\n        else\n            break;\n    }\n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0, sin(iTime), -6.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    if(iMouse.x != 0.0 && iMouse.y != 0.0)\n        rd *= rotation3dX(mouse.y * 3.141592653589);\n    \n    float sceneDist = Scene(ro, rd);\n    \n    float jitter = texture(iChannel3, fragCoord.xy / 8.0).r;\n    float a = RayMarch(ro, rd, sceneDist, jitter*0.1);\n    a = 1.0 - exp(-a);\n    \n    vec3 c = sceneDist < 100.0 ? vec3(1,0,0) : texture(iChannel2, rd).rgb;\n    c = mix(c, vec3(1), a);\n    \n    fragColor = vec4(c, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}