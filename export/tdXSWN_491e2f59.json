{"ver":"0.1","info":{"id":"tdXSWN","date":"1551275117","viewed":177,"name":"1 000 000 dreams","username":"Ridge","description":"One of my first ray marching projects. This was made more than a year ago but this is probably the best that I've been able to do so far. Now it's finally published!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","water","balls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Create a two-dimensional rotation matrix\nmat2 rot(in float a){float s = sin(a); float c= cos(a); return mat2(c,s,-s,c);}\n\n// Signed distance field function of a sphere\nfloat sphere(vec3 p, float r){return length(p)-r;}\n// Use modulo to copy the spheres\nfloat copy(float p, float d){return mod(p, d) - d/2.0;}\n\n// The distance to the closest sphere\nfloat map(vec3 p){\n    p.y-= iTime;\n    p.xz = p.xz*rot(iTime/11.);\n    p.x -= iTime*3.0;\n    p.x = copy(p.x, 10.0);\n    p.z = copy(p.z, 10.0);\n    p.y = copy(p.y, 5.0);\n    float s1 = sphere(vec3(p.x, p.y - 0.0, p.z), 1.0);\n    float s2 = sphere(vec3(p.x, p.y - 2.5, p.z), 1.0);\n    float s3 = sphere(vec3(p.x, p.y + 2.5, p.z), 1.0);\n \treturn min(min(s1, s2), s3);\n}\n\n// The distance to the closest point on the water\nfloat wmap(vec3 p){\n \treturn p.y+0.3;\n}\n\n// Use raymacrching to get the point in which the ray hits a ball\nvec3 trace(vec3 ro, vec3 rd){\n    int i = 0;\n    vec3 mp = ro;\n \tfor (i = 0; i < 60; i++)\n    {\n        float dist = map(mp);\n        mp += rd*dist;\n        if(dist < 0.01){break;}\n    }\n\treturn mp;\n}\n\n// Distort the normal of the plane to create the water effect\nvec3 distort(vec3 p, float i){return vec3(p.x + sin(p.x*315.+iTime*1.2)*i/10.,p.y +cos(p.y*321.+iTime)*i,p.z + sin(p.z*300.+iTime)*i/10.);}\n\n// Use raymacrching to get the point in which the ray hits the water\nvec3 wtrace(vec3 ro, vec3 rd){\n    int i = 0;\n    vec3 mp = ro;\n \tfor (i = 0; i < 100; i++){\n        float dist = wmap(mp);\n        mp += rd*dist;\n        if(dist < 0.01){break;}\n    }\n\treturn mp;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates in the center of the screen are 0,0\n    // Using x-resolution to scale the coordinates (-1 to 1 on x axis)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    // Ray orignin and ray dispance for the ray marching loops\n    vec3 ro = vec3(0.0); vec3 rd = normalize(vec3(uv.x, uv.y, 2.0));\n    // How far the ray can travel before hitting a sphere\n    float dist1  = length(trace(ro, rd));\n    // The point in which the ray hits water\n    vec3 wp = wtrace(ro, rd);\n    // How far the ray cal travel before hitting water\n    float wdist = length(wp);\n    // The distorted reflection after hitting water\n    vec3 wnormal = normalize(distort(vec3(rd.x, -rd.y, rd.z), 0.02));\n    // The distance from water to the sphere the reflection ray hits\n    float rdist = length(trace(ro + rd*wdist, wnormal)) - wdist;\n    vec3 col = vec3(0.0);\n    // Background color\n    vec3 bgcol = vec3(0.125, 0.25, 0.5)*(uv.y+0.1);\n    // Water Background color\n    vec3 wbgcol = vec3(0.125, 0.25, 0.5)*(-uv.y*1.0-0.1);\n    // If the ray hits nothing, use the bg color\n    if(min(dist1, wdist) > 120.0)\n        col = bgcol;\n    else\n    {\n        // If the ray hits a sphere, use the sphere's white color, blend its color with the background\n        if(dist1 < wdist)\n            col = mix(vec3(1.0), bgcol, dist1/120.);\n        else\n        {\n            // Does the reflection ray hit a sphere? No: use the water background color\n            if(wdist + rdist > 120.)\n                col = wbgcol;\n            // Yes: Blend the sphere's color with the water background color\n            else\n        \t\tcol = mix(vec3(1.0), wbgcol, (wdist + rdist)/120.);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}