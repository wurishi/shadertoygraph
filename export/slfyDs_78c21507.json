{"ver":"0.1","info":{"id":"slfyDs","date":"1648917219","viewed":80,"name":"X^Y = Y^X single Input function","username":"CuttyFlamingo","description":"a single dimention representation of the curve  x^y = y^x Im no mathematician just bored.\ninspiration behind making this was Inigo Quilez and his video https://www.youtube.com/watch?v=p-R0druZiTs Pretty fun.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float ie = 0.36787944117;\nconst float e =  2.71828182846;\nconst float v =  2.45587374862;\nconst float emsqrte = 1.06956055776;\n\nfloat InversePow (float x){\n    float s = sign(x);\n    x*=s;\n    if( x < 1.0 || x == e ){\n        return x*s;\n    }\n    if(x<4.0){\n        float L = log(x);\n        float iL = 1.0/L;\n        float Lx = L/x;\n        float LL = log(Lx);\n        float NLL = log(-LL);\n\n        float O = e - x + exp(NLL-LL-(NLL/LL)) + (v *(ie - Lx));\n        float O1 = x*log(O)*iL;\n        float O2 = x*log(O1)*iL;\n        float B = O1-O;\n        O += (B*B)/(B+O1-O2);\n        O = (isnan(O) || isinf(O))? O2:O;\n        //Uncomment for Full accuracy\n        //O1 = x*log(O)*iL;\n        //O2 = x*log(O1)*iL;\n        //B = O1-O;\n        //O += (B*B)/(B+O1-O2);\n        //O = (isnan(O) || isinf(O))? O2:O;\n        //\n        return O * s;\n    }else{\n        float ix = 1.0/x;\n        float O = pow(x, (e/(x-emsqrte) + emsqrte)*ix);\n        float O1 = pow(x, O*ix);\n        float O2 = pow(x, O1*ix);\n        float B = O1-O;\n        O += (B*B)/(B+O1-O2);\n        O = (isnan(O) || isinf(O))? O2:O;\n        //Uncomment for Full accuracy\n        //O1 = pow(x, O*ix);\n        //O2 = pow(x, O1*ix);\n        //B = O1-O;\n        //O += (B*B)/(B+O1-O2);\n        //O = (isnan(O) || isinf(O))? O2:O;\n        //\n        return O * s;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv*=50.0;\n    float CurveX = InversePow(uv.y);\n    float CurveY = InversePow(uv.x);\n    float P = min(abs(CurveX - uv.x),abs(CurveY - uv.y));\n    // Time varying pixel color\n    vec3 col = vec3((0.1-P)/0.1);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}