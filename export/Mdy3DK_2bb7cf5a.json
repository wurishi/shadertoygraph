{"ver":"0.1","info":{"id":"Mdy3DK","date":"1456445571","viewed":7140,"name":"Jump Flood Algorithm: Points","username":"demofox","description":"Playing around with and trying to understand the technique at https://www.shadertoy.com/view/4syGWK.  That is from this paper http://www.comp.nus.edu.sg/~tants/jfa/i3d06.pdf","likes":37,"published":3,"flags":48,"usePreview":0,"tags":["2d","sdf","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float c_gamma = 2.2;\n\nconst float KEY_1 = 49.5/256.0;\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the data for this pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv);\n\n    // decode this pixel\n\tvec2 seedCoord;\n    vec3 seedColor;\n    DecodeData(data, seedCoord, seedColor);\n\n    // highlight the seeds a bit\n    if (length(fragCoord-seedCoord) > 5.0)\n        seedColor *= 0.75;\n    \n    // if the 1 key is pressed, show distance info instead\n    if (texture(iChannel1, vec2(KEY_1,0.25)).x > 0.1)\n    {\n        float dist = length(seedCoord - fragCoord) / 25.0;\n        seedColor = vec3(dist);\n    }      \n    \n    // gamma correct\n\tseedColor = pow(seedColor, vec3(1.0/c_gamma));\n    fragColor = vec4(seedColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// chance of a pixel being a seed, assuming rand() is a good rng\nconst float c_seedChance = 0.0005;\n\n// how many frames between steps.  1.0 = full speed.\nconst float c_frameStepDelay = 7.0;\n\n// how many JFA steps to do.  2^c_maxSteps is max image size on x and y\nconst float c_maxSteps = 10.0;\n\n//============================================================\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//============================================================\n// returns 0..1\nfloat Rand(vec2 co)\n{\n    co.x += fract(iDate.w * 5.342);\n    co.y += fract(iDate.w * 11.214);\n    return hash12(co);\n}\n\n//============================================================\nvec3 RandColor (vec2 co)\n{\n    return vec3\n    (\n        Rand(co),\n        Rand(co*2.143),\n        Rand(co*3.163)\n\t);\n}\n\n//============================================================\nvec4 EncodeData (in vec2 coord, in vec3 color)\n{\n    vec4 ret = vec4(0.0);\n    ret.xy = coord;\n    ret.z = floor(color.x * 255.0) * 256.0 + floor(color.y * 255.0);\n    ret.w = floor(color.z * 255.0);\n    return ret;\n}\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\n//============================================================\nvec4 StepJFA (in vec2 fragCoord, in float level)\n{\n    level = clamp(level-1.0, 0.0, c_maxSteps);\n    float stepwidth = floor(exp2(c_maxSteps - level)+0.5);\n    \n    float bestDistance = 9999.0;\n    vec2 bestCoord = vec2(0.0);\n    vec3 bestColor = vec3(0.0);\n    \n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            vec2 sampleCoord = fragCoord + vec2(x,y) * stepwidth;\n            \n            vec4 data = texture( iChannel0, sampleCoord / iChannelResolution[0].xy);\n            vec2 seedCoord;\n            vec3 seedColor;\n            DecodeData(data, seedCoord, seedColor);\n            float dist = length(seedCoord - fragCoord);\n            if ((seedCoord.x != 0.0 || seedCoord.y != 0.0) && dist < bestDistance)\n            {\n                bestDistance = dist;\n                bestCoord = seedCoord;\n                bestColor = seedColor;\n            }\n        }\n    }\n    \n    return EncodeData(bestCoord, bestColor);\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize random seed locations and colors\n    if (iFrame == 0) {\n        if (Rand(fragCoord) > (1.0 - c_seedChance))\n            fragColor = EncodeData(fragCoord, RandColor(fragCoord));\n        else\n            fragColor = vec4(0.0);\n        return;\n    }\n    \n    // periodic steps\n\tif (mod(float(iFrame), c_frameStepDelay) == 0.0)\n        fragColor = StepJFA(fragCoord, floor(float(iFrame) / c_frameStepDelay));\n    else\n        fragColor = texture( iChannel0, fragCoord.xy / iChannelResolution[0].xy);\n}","name":"Buf A","description":"","type":"buffer"}]}