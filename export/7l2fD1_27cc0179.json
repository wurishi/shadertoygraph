{"ver":"0.1","info":{"id":"7l2fD1","date":"1652177509","viewed":185,"name":"REFLACTOR SPINOR","username":"khlorghaal","description":"  60 fps big need\nconsume with a side of high bpm schranz","likes":1,"published":1,"flags":96,"usePreview":0,"tags":["raymarch","refraction","cube","epileptic"],"hasliked":0,"parentid":"Wld3R4","parentname":"REFLACTOR"},"renderpass":[{"inputs":[{"id":"ll2Xzz","filepath":"https://soundcloud.com/user-313199048/free-track","previewfilepath":"https://soundcloud.com/user-313199048/free-track","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Copyright 2019 khlorghaal most rights reserved\n\n//Cubes make me happy.\n\n//efine PANORAMIC\n#define LOCK\n#define INTERNAL_REFLECTION\n//#define ANIMATE_IOR\n//#define MOUSE_IOR\n//#define ORBIT_CAM\n#define SS 1\n#define COLOR_T 0\n//#define BRDF_EMISSIVE\n#define BRDF_PHONG\n#define BRDF_BOUNCE\n\n//#define DEBUG\n#ifdef DEBUG\n    vec3 _err= vec3(0.);\n    #define ass(pred,color) \\\n        if(!(pred)){ _err= color; return color; }\n#else\n    #define ass(_,__) void;\n#endif\n\nconst float FOV= 2.5;\nconst float TRANSMITTANCE= .84;//this affects lumianance spatial freqenz of result; .84 is especially magical\nconst float EXPOSURE= .25;\nconst float GAMMA= 1.51269;\n\n//PERF SETTINGS\nconst int   MIN_I= 1<<4;//distance\nconst int   MAX_I= 1<<8;\nconst int   MIN_BOUNCE= 2;//reflections\nconst int   MAX_BOUNCE= 10;\n//\nconst float IOR= -.82;//high abs ior will cause rapid extinction\nconst vec4  FOGCOLOR= vec4(.2,.65,.99, 2.);\nconst float FAST= 41.8;\n\nconst vec3 COLOR_A = vec3(.81,.6 ,2.);\nconst vec3 COLOR_B = vec3(0.7,-.2,0.3);\nconst vec3 COLOR_C = vec3(.9,1.7 ,2.5);\n\n#define R vec3(1.,0.,0.)\n#define G vec3(0.,1.,0.)\n#define B vec3(0.,0.,1.)\nconst vec3 COLOR_XN = R;\nconst vec3 COLOR_XP = G;\nconst vec3 COLOR_YN = R;\nconst vec3 COLOR_YP = G+R;\nconst vec3 COLOR_ZN = R;\nconst vec3 COLOR_ZP = G+R;\n#undef R\n#undef G\n#undef B\n\n\nbool stagger(vec3 p){\n\tint n= 1;\n\treturn \n\t((int(int(p.x)+int(p.x<0.))&n)==0)&&\n\t((int(int(p.y)+int(p.y<0.))&n)==0)&&\n\t((int(int(p.z)+int(p.z<0.))&n)==0);\n}\nvec3 img(vec2 uv){\n    vec2 uvn= nmaps(uv);\n    uvn.x*= asp;\n    \n    vec2 camangle; \n    \tfloat t_= time*.3;\n    \t//t_= max(0.,t_-1.);\n    \t//t_= min(8.,t_);\n    \n    \tfloat ang= t_;\n    \tang/= 8.;\n    \tang= ang*TAU;\n    \tcamangle= vec2(22.01169*ang,2.7569752269*ang);\n   \n    _FOV= FOV*(1.+.5*sin(143.*t_));\n    \n    #ifdef PANORAMIC\n    \tray r= look_pano(uvn, camangle);\n    #else\n    \t#ifndef ORBIT_CAM\n    \t\tray r= look_persp(uvn, camangle);\n    \t#else\n    \t\tray r= look_persp_orbit(uvn, camangle, .95*sqrt(1.+sqrt(2.)));\n    \t#endif\n    #endif\n    \t\n    vec3 ra= r.a;\n    vec3 rc= r.c;\n    //camera translation\n    rc-= -.5;\n    rc.y+=1.+t_*21.;\n    rc.x+=1.+t_*-21.;\n    //rc.y-= time*FAST;\n    \n    float ior;\n    ior= IOR;\n    float iorrcp= 1./ior;\n    \n\tvec3 p= rc;//position+near\n\tvec3 v= norm(ra);//march velocity\n\tvec3 a= BLACK;//accumulator\n\tvec3 n= vec3(ETA);//normal\n    ass(real(p+v+a+ra+rc),RED);\n    int b= 0;//bounce number\n\tfloat cmag= 1.;\n\tbool s= stagger(p);\n    int i=0;\n    float lod= tex(iChannel0,vec2(0.)).x;\n    lod= lod*lod;\n    int maxi= int(lerp(float(MIN_I),     float(MAX_I),      lod));\n    int maxb=  int(lerp(float(MIN_BOUNCE),float(MAX_BOUNCE), lod));\n    for(; i<maxi; i++){\n\t\tif(b>maxb)\n\t\t\tbreak;//worth the warp divergence\n\n\t\t//march\n\t\tvec3 sv= sign(v);\n\t\tvec3 ef= floor(p);\n\t\t//vec3 ec= ef+1.;\n\t\tvec3 e= ef+step(vec3(0.), sv);//next edges\n\t\t\n\t\tvec3 dp= e-p;//delta position to each next-edge\n\t\tvec3 edt= dp/nozero(v);//time to each edge\n\t\tfloat dt= minv(edt);//time to soonest edge\n        ass(dt>=0.,ORANGE);//assert no negative time\n        \n        dp= v*(dt+ETA*8.);//if very precisely into an edge, may diagonal leap, dependent on eta\n        //*8 because ?????\n        p+= dp;\n        n= ef-floor(p);\n        ass(len(n)>0., GREEN);\n        n= norm(n);\n        ass(len(n)<=1., RED);\n        ass(real(n),BLUE);\n        //ass(sum(abs(n))<=1., RED);\n\n\t\t\n\t\tbool ps= s;//previous\n        s= stagger(p);\n\t\tif(s^^ps){//transmission\n\t\t\tass(len(v)>ETA, WHITE);\n\t\t\tvec3 r;\n\t\t\tr= refract(v,n, s?ior:iorrcp);\n            ass(real(r),GREEN);//FIXME\n\t\t\tif(eqf(maxv(r),0.)){\n            \t#ifdef INTERNAL_REFLECTION\n                    r= reflect(v,n);\n                    v= -norm(r);\n                    b++;\n                    cmag*= TRANSMITTANCE;\n                    continue;\n                #else\n               \t\tbreak;\n            \t#endif\n\t\t\t}\n\t\t\tv= norm(r);\n            if(s){//hit\n                //brdf\n                    #if COLOR_T==0\n                        vec3 C= nmapu(n);\n                        vec3 c= \n                              C.x*COLOR_A\n                            + C.y*COLOR_B\n                            + C.z*COLOR_C;\n                    #else\n                        greagaerhgae hyae5 thaer5thvec3 CP= sat( n);bsgfthgtsrthgsz\n                        vec3 CN= sat(-n);\n                        vec3 c= \n                              CP.x*COLOR_XP\n                            + CP.y*COLOR_YP\n                            + CP.z*COLOR_ZP\n                            + CN.x*COLOR_XN\n                            + CN.y*COLOR_YN\n                            + CN.z*COLOR_ZN;\n                    #endif\n                a+= c*cmag;\n                cmag*= TRANSMITTANCE;\n                b++;\n            }\n\t\t}\n\t\tass(real(dt), CYAN);\n\t\tass(real(v), YELLOW);\n\t\tass(real(n), PURPLE);\n    }\n    float cnorm= 1.;///(1.-pow(1.-TRANSMITTANCE,float(maxb)));\n    //luminance normalization is empirical\n    //meaning i have no fucking clue how it works\n    \n    return a*cnorm;\n}\n\n#ifdef SHADERTOY\nvoid mainImage(out vec4 col, vec2 fg){\n    #ifndef SS\n        col=vec4(img(fg/res),1.);\n    #else\n        for(int x=0; x<SS; x++){\n            for(int y=0; y<SS; y++){\n                vec2 fg_= fg+vec2(x,y)/float(SS);\n                col+=vec4(img(fg_/res),1.);\n            }\n        }\n        col/= float(SS*SS);\n    #endif\n    \n    #ifdef DEBUG\n        col= vec4(_err,1.);\n        return;\n    #endif\n    \n    //tonemap\n    col*=EXPOSURE;\n    col*= 1.-1./(1.+maxv(col));\n    if(minv(col.rgb)<.2)//make darkness high contrast\n        col.rgb=vec3(0.);\n    col= pow(col,vec4(GAMMA));\n    col.a= 1.;\n}\n#endif\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Khlor's header\n//https://github.com/khlorghaal/shaderheaders\n//BSD license\n\n//vec3 img(vec2 uv){INIT; }\n\n//Define-Switches\n#define SHADERTOY\n#define GLES\n\n//hack from https://www.shadertoy.com/view/3ll3RH by ttg\n//violently jams uniforms into scope\nfloat _iTime= 1.;\nvec3 _iResolution= vec3(1.);\n#define INIT {_iTime=iTime; _iResolution=iResolution;}\n#define iTime _iTime\n#define iResolution _iResolution\n\n//Consts\n#define PI  3.14159265359\n#define TAU (PI*2.)\n#define PHI 1.61803399\n#define deg2rad 0.01745329251\n#define SQRT2 (sqrt(2.))\n#define SQRT3 (sqrt(3.))\n#define BIG 1e8\n#define SMALL 1e-8\n#define ETA 1e-4\n#define eqf(a,b) ( abs((a)-(b))<ETA )\n\n//Aliases\n#define fc (gl_FragCoord.xy)\n#define res (iResolution.xy)\n#define ires ivec2(iResolution.xy)\n#define aspect (res.x/res.y)\n#define asp aspect\n#define aspinv (1./aspect)\n#define vec1 float\n#define ivec1 int\n#define uvec1 uint\n#define len length\n#define lerp mix\n#define norm normalize\n#define sat saturate\n#define sats saturate_signed\n#define smooth(x) smoothstep(0.,1.,x)\n#define time float(iTime)\n#define mouse ((iMouse.xy-res/2.)/(res*2.))\n#define mouse_ang (mouse*TAU)\n#define tex texture\n\n\nvec3   srgb(vec3 c){ return pow(c,vec3(   2.2)); }\nvec3 unsrgb(vec3 c){ return pow(c,vec3(1./2.2)); }\nvec3 texsrgb(sampler2D s,   vec2 uv){ return unsrgb(texture(s,uv).rgb); }\nvec3 texsrgb(samplerCube s, vec3  r){ return unsrgb(texture(s, r).rgb); }\n\nvec2 mods(vec2 x, vec1 y){ return mod(x,vec2(y));}\nvec3 mods(vec3 x, vec1 y){ return mod(x,vec3(y));}\nvec4 mods(vec4 x, vec1 y){ return mod(x,vec4(y));}\n\nvec2 pows(vec2 x, vec1 y){ return pow(x,vec2(y));}\nvec3 pows(vec3 x, vec1 y){ return pow(x,vec3(y));}\nvec4 pows(vec4 x, vec1 y){ return pow(x,vec4(y));}\n\n vec2 clamps( vec2 x,  vec1 min,  vec1 max){ return clamp(x,  vec2(min), vec2(max));}\n vec3 clamps( vec3 x,  vec1 min,  vec1 max){ return clamp(x,  vec3(min), vec3(max));}\n vec4 clamps( vec4 x,  vec1 min,  vec1 max){ return clamp(x,  vec4(min), vec4(max));}\nivec2 clamps(ivec2 x, ivec1 min, ivec1 max){ return clamp(x, ivec2(min),ivec2(max));}\nivec3 clamps(ivec3 x, ivec1 min, ivec1 max){ return clamp(x, ivec3(min),ivec3(max));}\nivec4 clamps(ivec4 x, ivec1 min, ivec1 max){ return clamp(x, ivec4(min),ivec4(max));}\n\n vec2 mins( vec2 v,  vec1 s){ return min(v,  vec2(s));}\n vec3 mins( vec3 v,  vec1 s){ return min(v,  vec3(s));}\n vec4 mins( vec4 v,  vec1 s){ return min(v,  vec4(s));}\n vec2 maxs( vec2 v,  vec1 s){ return max(v,  vec2(s));}\n vec3 maxs( vec3 v,  vec1 s){ return max(v,  vec3(s));}\n vec4 maxs( vec4 v,  vec1 s){ return max(v,  vec4(s));}\n vec2 mins( vec1 s,  vec2 v){ return min(v,  vec2(s));}\n vec3 mins( vec1 s,  vec3 v){ return min(v,  vec3(s));}\n vec4 mins( vec1 s,  vec4 v){ return min(v,  vec4(s));}\n vec2 maxs( vec1 s,  vec2 v){ return max(v,  vec2(s));}\n vec3 maxs( vec1 s,  vec3 v){ return max(v,  vec3(s));}\n vec4 maxs( vec1 s,  vec4 v){ return max(v,  vec4(s));}\nivec2 mins(ivec2 v, ivec1 s){ return min(v, ivec2(s));}\nivec3 mins(ivec3 v, ivec1 s){ return min(v, ivec3(s));}\nivec4 mins(ivec4 v, ivec1 s){ return min(v, ivec4(s));}\nivec2 maxs(ivec2 v, ivec1 s){ return max(v, ivec2(s));}\nivec3 maxs(ivec3 v, ivec1 s){ return max(v, ivec3(s));}\nivec4 maxs(ivec4 v, ivec1 s){ return max(v, ivec4(s));}\nivec2 mins(ivec1 s, ivec2 v){ return min(v, ivec2(s));}\nivec3 mins(ivec1 s, ivec3 v){ return min(v, ivec3(s));}\nivec4 mins(ivec1 s, ivec4 v){ return min(v, ivec4(s));}\nivec2 maxs(ivec1 s, ivec2 v){ return max(v, ivec2(s));}\nivec3 maxs(ivec1 s, ivec3 v){ return max(v, ivec3(s));}\nivec4 maxs(ivec1 s, ivec4 v){ return max(v, ivec4(s));}\n\nfloat maxv( vec2 a){ return                 max(a.x,a.y)  ;}\nfloat maxv( vec3 a){ return         max(a.z,max(a.x,a.y)) ;}\nfloat maxv( vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\nfloat minv( vec2 a){ return                 min(a.x,a.y)  ;}\nfloat minv( vec3 a){ return         min(a.z,min(a.x,a.y)) ;}\nfloat minv( vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n int maxv(ivec2 a){ return                 max(a.x,a.y)  ;}\n int maxv(ivec3 a){ return         max(a.z,max(a.x,a.y)) ;}\n int maxv(ivec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}\n int minv(ivec2 a){ return                 min(a.x,a.y)  ;}\n int minv(ivec3 a){ return         min(a.z,min(a.x,a.y)) ;}\n int minv(ivec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}\n\nvec3 signv(vec3 v){ return vec3(sign(v.x),sign(v.y),sign(v.z));}\nvec3 steps(vec3 v,float s){ return vec3(step(v.x,s),step(v.y,s),step(v.z,s));}\n\nvec3 nozero(vec3 v){//if v has 0 component assign it eta, often to prevent div 0\n    vec3 iszero= 1.-step(SMALL,abs(v));\n    return v+iszero*SMALL;\n}\n\n\n//normalized map to signed\n//[ 0,1]->[-1,1]\nvec1 nmaps(vec1 x){ return x*2.-1.; }\nvec2 nmaps(vec2 x){ return x*2.-1.; }\nvec3 nmaps(vec3 x){ return x*2.-1.; }\nvec4 nmaps(vec4 x){ return x*2.-1.; }\n//normalized map to unsigned\n//[-1,1]->[ 0,1]\nvec1 nmapu(vec1 x){ return x*.5+.5; }\nvec2 nmapu(vec2 x){ return x*.5+.5; }\nvec3 nmapu(vec3 x){ return x*.5+.5; }\nvec4 nmapu(vec4 x){ return x*.5+.5; }\n\n//[0,1]\nfloat saw(float x){ return mod(x,1.); }\nfloat tri(float x){ return abs( mod(x,2.) -1.); }\n  int tri(int x, int a){ return abs( abs(x%(a*2))-a ); }\n\nfloat sum ( vec2 v){ return dot(v,vec2(1));}\nfloat sum ( vec3 v){ return dot(v,vec3(1));}\nfloat sum ( vec4 v){ return dot(v,vec4(1));}\n  int sum (ivec2 v){ return v.x+v.y;}\n  int sum (ivec3 v){ return v.x+v.y+v.z;}\n  int sum (ivec4 v){ return v.x+v.y+v.z+v.w;}\nfloat prod( vec2 v){ return v.x*v.y;}\nfloat prod( vec3 v){ return v.x*v.y*v.z;}\nfloat prod( vec4 v){ return v.x*v.y*v.z*v.w;}\n  int prod(ivec2 v){ return v.x*v.y;}\n  int prod(ivec3 v){ return v.x*v.y*v.z;}\n  int prod(ivec4 v){ return v.x*v.y*v.z*v.w;}\n\n#define sqrtabs(x) sqrt(abs(x))\n#define powabs(x,p) pow(abs(x),p)\n\nvec1 saturate(vec1 x){ return clamp (x, 0.,1.);}\nvec2 saturate(vec2 x){ return clamps(x, 0.,1.);}\nvec3 saturate(vec3 x){ return clamps(x, 0.,1.);}\nvec4 saturate(vec4 x){ return clamps(x, 0.,1.);}\n#define lerpsat(a,b,x) lerp(a,b,saturate(x))\n\nvec1 saturate_signed(vec1 x){ return clamp (x, -1.,1.);}\nvec2 saturate_signed(vec2 x){ return clamps(x, -1.,1.);}\nvec3 saturate_signed(vec3 x){ return clamps(x, -1.,1.);}\nvec4 saturate_signed(vec4 x){ return clamps(x, -1.,1.);}\n\n#define smoother(x) (x*x*x * (x*(x*6.-15.)+10.) )\n\n\nfloat pow2i(int x){ return float(1<<x); }\n\n//nearest power of\nint npo2(float x){ return int(log2(x)); }\nint npo3(float x){ return int(log(x)/log(3.)); }\n\nfloat angle(vec2 v){ return atan(v.y,v.x); }\nvec1 angn(vec1 t){ return t-ceil(t/TAU-.5)*TAU; }\nvec2 angn(vec2 t){ return t-ceil(t/TAU-.5)*TAU; }\n\nbool real(vec1 x){ return !( isnan(x)||isinf(x) ); }\nbool real(vec2 x){ return real(prod(x)); }\nbool real(vec3 x){ return real(prod(x)); }\nbool real(vec4 x){ return real(prod(x)); }\n\nvec1 rationalize(vec1 x){ return real(x)? x:vec1(0.); }\nvec2 rationalize(vec2 x){ return real(x)? x:vec2(0.); }\nvec3 rationalize(vec3 x){ return real(x)? x:vec3(0.); }\nvec4 rationalize(vec4 x){ return real(x)? x:vec4(0.); }\n\n#define count(_n) for(int n=0; n!=_n; n++)\n\n//im not sure if this is linear or srgb, or if that even matters much\n#define LUMVEC vec3(0.2126, 0.7152, 0.0722)\nfloat lum(vec3 c){ return dot(c,vec3(LUMVEC)); }\n\n#define BLACK  vec3(0.,0.,0.)\n#define RED    vec3(1.,0.,0.)\n#define GREEN  vec3(0.,1.,0.)\n#define BLUE   vec3(0.,0.,1.)\n#define YELLOW vec3(1.,1.,0.)\n#define CYAN   vec3(0.,1.,1.)\n#define MAGENTA vec3(1.,0.,1.)\n#define WHITE  vec3(1.,1.,1.)\n\n#define ORANGE vec3(1.,.5,0.)\n\n#define INT_MAX     0x7FFFFFFF\n#define INT_HALFMAX 0x00010000\n#define INT_MAXF     float(INT_MAX)\n#define INT_HALFMAXF float(INT_HALFMAX)\nvec1 unfix16(vec1 x){ return vec1(x)/INT_HALFMAXF; }\nvec2 unfix16(vec2 x){ return vec2(x)/INT_HALFMAXF; }\nvec3 unfix16(vec3 x){ return vec3(x)/INT_HALFMAXF; }\nvec4 unfix16(vec4 x){ return vec4(x)/INT_HALFMAXF; }\nivec1 fixed16(vec1 x){ return ivec1(INT_HALFMAXF*x); }\nivec2 fixed16(vec2 x){ return ivec2(INT_HALFMAXF*x); }\nivec3 fixed16(vec3 x){ return ivec3(INT_HALFMAXF*x); }\nivec4 fixed16(vec4 x){ return ivec4(INT_HALFMAXF*x); }\n\nivec4 hash(ivec4 x){\n\tx= ((x>>16)^x)*0x45d9f3b;\n\tx= ((x>>16)^x)*0x45d9f3b;\n\t//x=  (x>>16)^x;\n    return x;\n}\n//[-max,+max]->[0,1]\nvec1 hashf(vec1 x){ return abs(vec1(hash(ivec4(fixed16(x),0.,0.,0.)).x  ))/INT_MAXF; }\nvec2 hashf(vec2 x){ return abs(vec2(hash(ivec4(fixed16(x),0.,0.   )).xy ))/INT_MAXF; }\nvec3 hashf(vec3 x){ return abs(vec3(hash(ivec4(fixed16(x),0.      )).xyz))/INT_MAXF; }\nvec4 hashf(vec4 x){ return abs(vec4(hash(ivec4(fixed16(x)         ))    ))/INT_MAXF; }\n\n#define R2A vec2(.99231, .9933)\n#define R2B vec2(.99111, .9945)\n#define R3A vec3(.99312, .98313, .9846)\n#define R3B vec3(.99111, .98414, .9935)\n#define R4A vec4(.99412, .99343, .99565, .99473)\n#define R4B vec4(.99612, .99836, .99387, .99376)\nvec1 rand (vec1 x){ return hashf(x);   }\nvec2 rand (vec2 x){ return hashf(x*hashf(x+x.yx)); }\nvec3 rand (vec3 x){ return hashf(x*1.e2*hashf(R3A+x+x.yzx+x.zxy)); }\nvec4 rand (vec4 x){ return hashf(x*hashf(x+x.yzwx+x.zwxy+x.wxyz)); }\nvec1 rand1(vec2 x){ return hashf(dot(x*R2A-R2B,-x*R2B+R2A)/x.x);  }\nvec1 rand1(vec3 x){ return hashf(dot(x+R3A-R3B,-x+R3B+R3A));  }\nvec1 rand1(vec4 x){ return hashf(dot(x+R4A-R4B,-x+R4B+R4A));  }\nvec2 rand2(vec1 x){ return hashf(x+R2A);   }\nvec3 rand3(vec1 x){ return hashf(x+R3A);   }\n\nfloat bilerp(\n\tfloat nn, float np,\n\tfloat pn, float pp,\n\tvec2 l\n){\n\tvec2 lx= lerp(\n\t\tvec2(nn,np),\n\t\tvec2(pp,pp),\n\t\tl.x\n\t\t);\n\treturn lerp(lx.x,lx.y,l.y);\n}\nvec2 bilerp(\n\tvec2 nn, vec2 np,\n\tvec2 pn, vec2 pp,\n\tvec2 l\n){\n\tvec4 lx= lerp(\n\t\tvec4(nn,np),\n\t\tvec4(pp,pp),\n\t\tl.xxxx\n\t\t);\n\treturn lerp(lx.xy,lx.zw,l.yy);\n}\n\nfloat trilerp(float nnn,float nnp,float npn,float npp,float pnn,float pnp,float ppn,float ppp,  vec3 l){\n\tfloat lnn= lerp(nnn, pnn, l.x);\n\tfloat lnp= lerp(nnp, pnp, l.x);\n\tfloat lpn= lerp(npn, ppn, l.x);\n\tfloat lpp= lerp(npp, ppp, l.x);\n\n\tfloat lln= lerp(lnn,lpn, l.y);\n\tfloat llp= lerp(lnp,lpp, l.y);\n\n\treturn lerp(lln,llp, l.z);\n}\nvec3 trilerp(vec3 nnn,vec3 nnp,vec3 npn,vec3 npp,vec3 pnn,vec3 pnp,vec3 ppn,vec3 ppp,  vec3 l){\n\tvec3 lnn= lerp(nnn, pnn, l.x);\n\tvec3 lnp= lerp(nnp, pnp, l.x);\n\tvec3 lpn= lerp(npn, ppn, l.x);\n\tvec3 lpp= lerp(npp, ppp, l.x);\n\n\tvec3 lln= lerp(lnn,lpn, l.y);\n\tvec3 llp= lerp(lnp,lpp, l.y);\n\n\treturn lerp(lln,llp, l.z);\n}\n\n\nfloat vnse(vec1 x){ return lerp(rand(floor(x)),rand(ceil(x)),fract(x)); }\nfloat vnse(vec2 p){\n\tvec2 fr= fract(p);\n\tvec2 f= floor(p);\n\tvec2 c= ceil(p);\n\tfloat nn= rand1(vec2(f.x,f.y));\n\tfloat np= rand1(vec2(f.x,c.y));\n\tfloat pn= rand1(vec2(c.x,f.y));\n\tfloat pp= rand1(vec2(c.x,c.y));\n\tvec4 v= vec4(nn,np,pn,pp);\n\tvec2 lx= lerp(v.xy,v.zw, fr.xx);\n\treturn lerp( lx.x,lx.y, fr.y );\n}\nfloat vnse(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tfloat nnn= rand1(vec3(f.x,f.y,f.z));\n\tfloat nnp= rand1(vec3(f.x,f.y,c.z));\n\tfloat npn= rand1(vec3(f.x,c.y,f.z));\n\tfloat npp= rand1(vec3(f.x,c.y,c.z));\n\tfloat pnn= rand1(vec3(c.x,f.y,f.z));\n\tfloat pnp= rand1(vec3(c.x,f.y,c.z));\n\tfloat ppn= rand1(vec3(c.x,c.y,f.z));\n\tfloat ppp= rand1(vec3(c.x,c.y,c.z));\n\tvec4 zn= vec4(\n\t\tnnn,\n\t\tnpn,\n\t\tpnn,\n\t\tppn\n\t);\n\tvec4 zp= vec4(\n\t\tnnp,\n\t\tnpp,\n\t\tpnp,\n\t\tppp\n\t);\n\tvec4 lx= lerp(zn,zp, fr.zzzz);\n\tvec2 ly= lerp(lx.xz, lx.yw, fr.yy);\n\treturn lerp(ly.x,ly.y, fr.x);\n}\n\nfloat perlin(float p){\n\tfloat fr= fract(p);\n\tfloat frn= fr-1.;\n\tfloat f= floor(p);\n\tfloat c= ceil(p);\n\tfloat a= nmaps(rand(f));\n\tfloat b= nmaps(rand(c));\n\treturn lerp(a,b,smooth(fr));\n}\nfloat perlin(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 frn= fr-1.;\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tvec3 nnn= nmaps(rand(vec3(f.x,f.y,f.z)));\n\tvec3 nnp= nmaps(rand(vec3(f.x,f.y,c.z)));\n\tvec3 npn= nmaps(rand(vec3(f.x,c.y,f.z)));\n\tvec3 npp= nmaps(rand(vec3(f.x,c.y,c.z)));\n\tvec3 pnn= nmaps(rand(vec3(c.x,f.y,f.z)));\n\tvec3 pnp= nmaps(rand(vec3(c.x,f.y,c.z)));\n\tvec3 ppn= nmaps(rand(vec3(c.x,c.y,f.z)));\n\tvec3 ppp= nmaps(rand(vec3(c.x,c.y,c.z)));\n\tfloat d_nnn= dot(nnn, vec3(fr .x, fr .y, fr .z));\n\tfloat d_nnp= dot(nnp, vec3(fr .x, fr .y, frn.z));\n\tfloat d_npn= dot(npn, vec3(fr .x, frn.y, fr .z));\n\tfloat d_npp= dot(npp, vec3(fr .x, frn.y, frn.z));\n\tfloat d_pnn= dot(pnn, vec3(frn.x, fr .y, fr .z));\n\tfloat d_pnp= dot(pnp, vec3(frn.x, fr .y, frn.z));\n\tfloat d_ppn= dot(ppn, vec3(frn.x, frn.y, fr .z));\n\tfloat d_ppp= dot(ppp, vec3(frn.x, frn.y, frn.z));\n\tvec4 zn= vec4(\n\t\td_nnn,\n\t\td_npn,\n\t\td_pnn,\n\t\td_ppn\n\t);\n\tvec4 zp= vec4(\n\t\td_nnp,\n\t\td_npp,\n\t\td_pnp,\n\t\td_ppp\n\t);\n\tvec4 lx= lerp(zn,zp, smooth(fr.zzzz));\n\tvec2 ly= lerp(lx.xz, lx.yw, smooth(fr.yy));\n\treturn nmapu(lerp(ly.x,ly.y, smooth(fr.x)));\n}\n\n\n//value noise smooth vector\nvec2 vnsesv(vec2 p){\n\tvec2 fr= fract(p);\n\tvec2 frn= fr-1.;\n\tvec2 f= floor(p);\n\tvec2 c= ceil(p);\n\tvec2 nn= rand(vec2(f.x,f.y));\n\tvec2 np= rand(vec2(f.x,f.y));\n\tvec2 pn= rand(vec2(f.x,c.y));\n\tvec2 pp= rand(vec2(f.x,c.y));\n\n\treturn bilerp(nn,np,pn,pp, smooth(fr));\n}\nvec3 vnsesv(vec3 p){\n\tvec3 fr= fract(p);\n\tvec3 frn= fr-1.;\n\tvec3 f= floor(p);\n\tvec3 c= ceil(p);\n\tvec3 nnn= rand(vec3(f.x,f.y,f.z));\n\tvec3 nnp= rand(vec3(f.x,f.y,c.z));\n\tvec3 npn= rand(vec3(f.x,c.y,f.z));\n\tvec3 npp= rand(vec3(f.x,c.y,c.z));\n\tvec3 pnn= rand(vec3(c.x,f.y,f.z));\n\tvec3 pnp= rand(vec3(c.x,f.y,c.z));\n\tvec3 ppn= rand(vec3(c.x,c.y,f.z));\n\tvec3 ppp= rand(vec3(c.x,c.y,c.z));\n\n\treturn trilerp(nnn,nnp,npn,npp,pnn,pnp,ppn,ppp, smooth(fr));\n}\n\n\nfloat worley(vec3 c){\n    float acc= 1.;\n    vec3 cfl= floor(c);\n    vec3 cfr= fract(c);\n    for(int i=-1; i<=1; i++){\n    for(int j=-1; j<=1; j++){\n    for(int k=-1; k<=1; k++){\n        vec3 g= vec3(i,j,k)+cfl;\n        vec3 p= rand(g)+g;\n        float l= len(p-c);\n        acc= min(acc,l);\n    }}}\n\treturn acc;\n}\n\n#define dFdxy(x) (vec2(dFdx(x),dFdy(x)))\n#define grad2(f,x) \\\n\t((vec2( \\\n    \tf(x+vec2(ETA,0)), \\\n\t\tf(x+vec2(0,ETA)) \\\n\t  )-f(x))/ETA)\n#define grad3(f,x) \\\n\t((vec3( \\\n    \tf(x+vec3(ETA,0,0)), \\\n\t\tf(x+vec3(0,ETA,0)), \\\n\t\tf(x+vec3(0,0,ETA)) \\\n\t  )-f(x))/ETA)\n\n#define gradnorm2(f,x)  \\\n\tnorm(vec3(grad2(f,x),1.))\n#define gradnorm3(f,x)  \\\n\tnorm(grad3(f,x))\n\nmat2 rot2d(float t){\n    float c= cos(t);\n    float s= sin(t);\n    return mat2(\n        c,-s,\n        s, c\n    );\n    \n}\nmat3 rotx(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        1, 0, 0,\n        0, c,-s,\n        0, s, c\n    );\n}\nmat3 roty(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n         c,0,s,\n         0,1,0,\n    \t-s,0,c\n    );\n}\nmat3 rotz(float t){\n    float c= cos(t);\n    float s= sin(t);\n    \n    return mat3(\n        c,-s,0,\n        s, c,0,\n    \t0, 0,1\n    );\n}\n\n//azimuth, inclination\nvec3 azincl(vec2 a){\n    a.x+= PI/2.;\n    vec2 s= sin(a);//sin theta, sin phi\n    vec2 c= cos(a);//cos theta, cos phi\n    vec3 ret= vec3(c.x,s);\n    ret.xy*= c.y;\n    return ret;\n}\n\n//i am able to use quats, with barely any understanding of them\n//versor from axis-angle\nvec4 vrsr(vec3 w){\n    w.z*= -1.;\n\tvec3 wn= norm(w);\n    float th2= len(w)/2.;\n    return vec4(sin(th2)*wn,cos(th2));\n}\nvec3 rot(vec3 v, vec3 w){\n\tvec4 q= vrsr(w);\n    //copypasta\n\treturn v + 2.*cross(cross(v, q.xyz) + q.w*v, q.xyz);\n}\n\nstruct ray{\n\tvec3 a;\n    vec3 c;\n};\n\nfloat _FOV= .5;\n#define NEAR .0\n\nray look_persp(vec2 uvn, vec2 a){\n\tray o;\n    o.a= norm( roty(a.x) * rotx(-a.y) * vec3(uvn*_FOV,1.));\n    o.c= o.a*NEAR;\n    return o;\n}\nray look_persp_orbit(vec2 uvn, vec2 a, float d){\n    ray o;\n    mat3x3 mat= roty(a.x) * rotx(-a.y);\n    o.a= norm( mat * vec3(uvn*_FOV,1.));\n    o.c= mat[2]*-d + o.a*NEAR;\n\treturn o;\n}\nray look_pano(vec2 uvn, vec2 a){\n    ray o;\n    mat3x3 mat= roty(a.x) * rotx(-a.y);\n    o.a= mat * vec3(uvn,1.);\n    o.a= o.a-sin(PI*.125*len(uvn))*mat*vec3(0.,0.,1.);\n    o.a= norm(o.a);\n    o.c= o.a;\n\treturn o;\n}\n\nint doti(ivec2 a, ivec2 b){ return a.x*b.x + a.y*b.y; }\nint doti(ivec3 a, ivec3 b){ return a.x*b.x + a.y*b.y + a.z*b.z; }\nint doti(ivec4 a, ivec4 b){ return a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w; }\n\n//hacky\nint sqrti(int x){return int(sqrt(float(x)));}\nint cbrti(int x){return int( pow(float(x),1./3.));}\n\n\n\n#ifdef SHADERTOY\n//rip from https://www.shadertoy.com/view/llySRh\n#define KEY_LEFT   37\n#define KEY_UP     38\n#define KEY_RIGHT  39  \n#define KEY_DOWN   40   \n#define KEY_PGUP   33  \n#define KEY_PGDOWN 34  \n#define KEY_END    35  \n#define KEY_HOME   36\n#define KEY_SPACE  32\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#endif\n\n\n\n\n#undef iTime\n#undef iResolution","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//using buffer A is a hack\n//this should be done on cpu\n\n//author khlorghaal, GNU GPL\n\n/*\nrecommend applying a ramp to lod equal to its effect complexity\nie if you are using lod for both bounce count and draw distance, thats N**2\n\nthis is a very different case than PIDs because it has an aggressive memory\nand its very discrete/procedural compared to integrals\nremembers the highest lod used while above target fps and hunts about it\nattempting to maximize lod without going below target fps\n\nwill briefly dip below target fps during convergence\n\ntried additive increase/multiplicative decrease but surprisingly it did worse\n*/\n\nconst float FPS= 30.;\nconst float SHRINK= .6;\nconst float GROW=   .3;\n\n\nvoid mainImage(out vec4 col, vec2 fg){\n    if(sum(ivec2(fc.xy))!=0)\n        discard;\n        \n    float dt= iTimeDelta;\n    \n    float target= 1./FPS;\n    float actual= dt;\n    float err= actual - target;\n    \n    vec4 s= tex(iChannel0,vec2(0.));\n    float lod= s.x;\n    float cap= s.y;\n    if(cap==0.)\n        cap=1.;//init\n    \n    float shr= dt*SHRINK;\n    float grw= dt*GROW;\n    float tolerance= min(shr,grw)*2.;//must be larger than delta, or will never fall within range; *2 because magic\n    if(abs(err)<tolerance)\n        shr=grw=0.;\n    lod+= (err>0.? -shr:grw);\n    if(err>0.&&lod>cap){//remember the maximum lod when fps<target\n        cap= lod;\n    }\n    lod= min(lod,cap);\n    col= vec4(lod, cap,0.,0.);\n    col= sat(col);\n    \n    /*\n    NUKED.\n    PIDs SUCK\n    \n    //wikipedia.org/wiki/PID_controller\n    \n    const float MASS= FPS*8.;//overall resistance to change\n\n    #define NO_DT\n    //set delta time = 1\n    //delta time is proportionate to the control variable\n    // which is an odd situation for a pid, it causes a recursion\n    //having time as frames instead of real-time is sensible\n    const float LOD_BIAS= .001;//encourage ringing above the target fps instead of dropping below\n    //requestAnimationFrame's influence will be desirable iff lod is kept less than target\n\n    //p is fast reaction but causes ringing\n    //i is smooth but reacts slowly and increases overshoot\n    //d is kindof like a spring, but with DT non 1 is fucky aggro\n    //tune them by setting initial all 0, adjusting in order of p,i,d\n    //    increase p until it oscillates around the target value\n    //    sometimes negative values for i,d are useful\n    //ensure your shader doesnt stall at 1.0 lod because this will definitely happen while tuning\n\n    const vec3 Kpid= vec3(\n    #ifdef NO_DT\n        10.,0.,0.\n    #else\n        asdf 1.5,.0,.10\n    #endif\n    )/MASS;\n    const float DERIV_LERP= .5;//lowpass on derivative, too much makes it behave like integral\n    const float INTEGRAL_MITIGATOR= 8./MASS;\n    ...\n        float i= s.y;\n        float perr= s.z;\n\n        #ifdef NO_DT\n            #define dt (1.)\n        #endif\n\n        vec3 pid= vec3( err, i, (err-perr)/dt ) * Kpid;\n        float u= sat(sum(pid));\n\n        //control function ramp [0,1]\n        //linear is fine for most cases\n        //ideally inverse of lod complexity\n        //  ie if lod controls both distance and bounce count => N^2 => control function N^1/2\n        //  however pid by nature handles approximations well\n        float lod= u;\n        //lod= pow(lod,1./2.);\n        lod+= LOD_BIAS;\n        lod= sat(lod);\n        lod= .02;\n\n        i= u*dt+i;\n        i= clamp(i,-INTEGRAL_MITIGATOR,INTEGRAL_MITIGATOR);//mitigate overshoot\n        perr= lerp(err,perr,DERIV_LERP);\n    */\n}","name":"Buffer A","description":"","type":"buffer"}]}