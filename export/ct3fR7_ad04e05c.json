{"ver":"0.1","info":{"id":"ct3fR7","date":"1701153196","viewed":59,"name":"Faster FBM for Terrain","username":"Real_NC","description":"My first pass at implementing a gradient noise fbm with cached values instead of recalculating the hash thousands of times (\"rehashing\").","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["terrain","fbm","performance","cache"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Comment out USECACHE and the performance should get worse, but the scene doesn't change.\n#define USECACHE\n\n/*\n    This is my attempt at creating a more performant version of a classic FBM function. This implementation is not polished, and could use\n    a lot of work. Hopefully someone can help make this even better :P\n    \n    The principle is that, usually, when we are calling fbm noise many times per frame, the gradients for the lower octaves are recalculated\n    each time. This is not necessary, as it is often the case that the \n*/\n\n\n\n\n#define OCTAVES 16\n\nstruct square{\nvec2 a;\nvec2 b;\nvec2 c;\nvec2 d;\n\nuvec2 pos;\n};\n\nsquare[OCTAVES] squares; // list of squares\n\nvec2 pNext (vec2 p) // this can cause some dx11 bugs, unsure why\n{\n    return p.yx * 1.3 + vec2(13.7,19.1);\n}\n\nuvec2 p2pos (vec2 p) // gets the uvec2 \"square address\" from a given float coordinate\n{\n    return uvec2(mod(p, float(1<<15)))+1u; // why 1<<15 works, I don't know, but it avoids some very strange behaviors.\n    // adding 1u ensures there is never a zero value, which causes issues with the cached version of the fbm\n}\n\nsquare generateSquare(vec2 p) // gets the corner gradients for a specific square address\n{\n    vec2 q = vec2(1,0);\n    return square(\n    hash(p2pos(p + q.yy)) * 2. - 1.,\n    hash(p2pos(p + q.xy)) * 2. - 1.,\n    hash(p2pos(p + q.yx)) * 2. - 1.,\n    hash(p2pos(p + q.xx)) * 2. - 1.,\n    p2pos(p));\n}\n\nfloat cachedPerlin(vec2 p, square Square)\n{\n    p -= floor(p);\n    vec2 s = p*p*p*(6.0*p*p - 15.0*p + 10.0);\n    \n    vec2 q = vec2(1,0);\n    return mix(\n           mix(dot(Square.a, p - q.yy), dot(Square.b, p - q.xy), s.x),\n           mix(dot(Square.c, p - q.yx), dot(Square.d, p - q.xx), s.x),\n           s.y);\n    \n}\n\n\nfloat perlin(vec2 p)\n{\n    vec2 f = fract(p),\n    s = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n    p -= f;\n    vec2 q = vec2(1,0);\n    vec2 h[4] = vec2[4](\n    hash(p2pos(p + q.yy)) * 2. - 1.,\n    hash(p2pos(p + q.xy)) * 2. - 1.,\n    hash(p2pos(p + q.yx)) * 2. - 1.,\n    hash(p2pos(p + q.xx)) * 2. - 1.);\n    \n    return mix(\n           mix(dot(h[0], f - q.yy), dot(h[1], f - q.xy), s.x),\n           mix(dot(h[2], f - q.yx), dot(h[3], f - q.xx), s.x),\n           s.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float a = 1.0;\n    float n = 0.0;\n    \n    for(int i = 0; i < OCTAVES; i++)\n    {\n        n += perlin(p)*a;\n        a *= 0.8;\n        p = pNext(p);\n    }\n    \n    return n;\n}\n\n// would be nice to have more n = 1 performance, right now the cached method is 3 times the price.. oof\nfloat fbm2 (vec2 p) // generates fbm using cached random values when possible, otherwise calls hash again\n{\n    float a = 1.0;\n    float n = 0.0;\n    \n    for(int i = 0; i < OCTAVES; i++)\n    {\n        if(squares[i].pos != p2pos(p))\n        {\n            squares[i] = generateSquare(p);\n        }\n        n += cachedPerlin(p, squares[i])*a;\n        //n += cachedPerlin(p, generateSquare(p))*a;\n        //n += perlin(p)*a;\n        a *= 0.8;\n        p = pNext(p);\n    }\n    \n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0,5,iTime*2.0);\n    vec3 rd = normalize(vec3(uv, 1));\n    float d = 0.0;\n    \n    for (int i = 0; i <= 300; i++)\n    {\n        #ifdef USECACHE\n        float map = ro.y - fbm2(ro.xz*0.1)*10. + 10.*exp(-d*d*0.01);\n        #else\n        float map = ro.y - fbm(ro.xz*0.1)*10. + 10.*exp(-d*d*0.01);\n        #endif\n        d += map*0.4;\n        ro += rd*map*0.2;\n        if (d >= 100.0) break;\n        if (abs(map) <= 0.01) break;\n    }\n    #ifdef USECACHE\n    fragColor = vec4(fbm2(ro.xz*0.1));\n    #else\n    fragColor = vec4(fbm(ro.xz*0.1));\n    #endif\n    \n    if(ro.y <= 0.) {\n        fragColor *= vec4(-1,0,0,0);\n        fragColor += 0.1;\n    }\n    if(d >= 100.0) fragColor = uv.y * vec4(0.3,0,0,0);\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// iq hash modified for vec2\nconst uint k = 1103515245U;\n\nvec2 hash( uvec2 x)\n{\n    x = ((x>>8U)^x.yx)*k;\n    x = ((x>>8U)^x.yy)*k;\n    x = ((x>>8U)^x.xx)*k;\n    \n    return vec2(x)*(1.0/float(0xffffffffU));\n    //return hash(uvec3(x, 2)).xy;\n}","name":"Common","description":"","type":"common"}]}