{"ver":"0.1","info":{"id":"3djXR1","date":"1552950623","viewed":423,"name":"Elementary Cell.Auto. / Rule 126","username":"4rknova","description":"Elementary Cellular Automaton / Rule 126\nThis will break if the window is too small, switch to a smaller RESx value for D if that is the case.\n[url]http://www.4rknova.com/blog/2019/03/18/Elementary_Cell_Auto_Rule_126.html[/url]","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["cellular","automaton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BG   vec3(0.0745, 0.0862, 0.1058)\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    float v = texture(iChannel0, p / iResolution.xy).r;\n    c = vec4(mix(BG, vec3(v), v),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The MIT License\n// Copyright Â© 2019 Nikos Papadopoulos\n\n#define RES0 vec2(200, 64)\n#define RES1 vec2(400,128)\n#define RES2 vec2(800,256)\n\n#define D (iResolution.y < 200. ? RES0 : RES1)\n\n#define S(p,d) (texture(iChannel0, (p + d) / D).r > 0.5) // Sampling of pixel state\n    \nvoid mainImage(out vec4 c, in vec2 p)\n{\n    vec2 gc = floor(D * p.xy / iResolution.xy) + 0.5; // Grid Coordinates\n\n    // Initialization\n    if (iFrame == 1 && distance(gc, vec2(D.x*0.5, D.y - 1.)) < 1.){\n        c.x = 1.;\n        return;\n    }\n    \n    c.x = S(gc,vec2(0)) ? 1. : 0.; // Restore state\n    \n    // Every step (in this instance step = frame) calculate the next line.\n    float t = min((D.y - (float(iFrame))), D.y);\n    // This is a 1D automaton. To visualize it in 2D we choose time as our 2nd\n    // dimension. Each successive line in the grid is the evolution of the\n    // previous population in the line above.\n    if (gc.y - .5 == t){        \n    \tbool pl = S(gc, vec2(-1,1))\n\t       , pc = S(gc, vec2( 0,1))\n\t       , pr = S(gc, vec2( 1,1));\n        \n\t    // Rule 126.\n        // This essentially generates a Sierpinski triangle\n\t    c.x = (pl == pc && pc == pr ? 0.0 : 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}