{"ver":"0.1","info":{"id":"M3l3WM","date":"1707732545","viewed":32,"name":"[inspirnathan] 15 - channels,tex","username":"hrst4","description":"[inspirnathan] 15 - channels,tex","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/62-shadertoy-tutorial-part-15\n// [0-xx]\n\n#define PART 6\n\n/*\nSalutations, mes amis ! \nBienvenue dans la quinzième partie de ma série de tutoriels Shadertoy ! \nDans ce tutoriel, je vais expliquer comment utiliser les channels et les buffers dans Shadertoy, \nafin de pouvoir utiliser des textures et créer des shaders multi-passes.\n\n# Channels\n\nShadertoy utilise un concept connu sous le nom de canaux pour accéder à différents types de données. \nEn bas de l'interface utilisateur de Shadertoy, vous verrez quatre boîtes noires : iChannel0, iChannel1, iChannel2 et iChannel3.\n\nhttps://inspirnathan.com/_nuxt/img/img-1.aff7d0c.png\n\nSi vous cliquez sur l'un des canaux, une fenêtre contextuelle apparaît. \nVous pouvez choisir parmi une variété d'éléments interactifs, de textures, de cubemaps, de volumes, de vidéos et de musique.\n\nhttps://inspirnathan.com/_nuxt/img/img-2.bb5a850.png\n\nDans l'onglet \"Divers\", vous pouvez sélectionner des éléments interactifs tels qu'un clavier, une webcam, un microphone \nou même jouer de la musique à partir de SoundCloud. \n\nLes tampons, Buffer A, Buffer B, Buffer C et Buffer D, vous permettent de créer des shaders \"multi-pass\".\n\nConsidérez-les comme un shader supplémentaire que vous pouvez ajouter à votre pipeline de shaders. \n\nL'entrée \"Cubemap A\" est un type spécial de programme de shader qui vous permet de créer votre propre cubemap.\nVous pouvez ensuite transmettre cette cubemap à un tampon ou à votre programme \"Image\" principal. Nous parlerons des cubemaps dans le prochain tutoriel.\n\nL'onglet suivant est l'onglet \"Textures\".\nVous y trouverez trois pages de textures 2D parmi lesquelles choisir.\n\nLes textures 2D sont des images dont on peut extraire des valeurs de pixels. \n\nAu moment où nous écrivons ces lignes, vous ne pouvez utiliser que les textures fournies par Shadertoy\net vous ne pouvez pas importer d'images depuis l'extérieur de Shadertoy. \n\nCependant, il existe des moyens de contourner cela localement en utilisant des détails trouvés dans ce shader.\n\nhttps://inspirnathan.com/_nuxt/img/img-3.3cc9ee5.png\nhttps://inspirnathan.com/_nuxt/img/img-4.83c2778.png\nhttps://inspirnathan.com/_nuxt/img/img-5.18ffdf5.png\n\nL'onglet \"Cubemaps\" contient une sélection de cubemaps que vous pouvez choisir. \nNous en parlerons plus en détail dans le prochain tutoriel.\nLes cubemaps sont couramment utilisés dans les moteurs de jeu tels que Unity pour le rendu d'un monde 3D autour de vous.\n\nhttps://inspirnathan.com/_nuxt/img/img-6.0d0ba5a.png\n\nL'onglet \"Volumes\" contient des textures 3D. \nLes textures 2D typiques utilisent les coordonnées UV pour accéder aux données le long de l'axe x (valeur U) \net de l'axe y (valeur V). \n\nDans les textures 3D, vous utilisez les coordonnées UVW où la valeur W correspond à l'axe z. \nVous pouvez considérer les textures 3D comme un cube dont chaque pixel représente des données que nous pouvons extraire.\nCela revient à extraire des données d'un tableau tridimensionnel.\n\nhttps://inspirnathan.com/_nuxt/img/img-7.cff09c3.png\n\nL'onglet \"Videos\" contient des textures 2D (ou des images) qui changent avec le temps.\nEn d'autres termes, elles diffusent des vidéos dans le canvas Shadertoy.\n\nLes gens utilisent les vidéos sur Shadertoy pour expérimenter des effets de post-traitement ou des effets d'image \nqui s'appuient sur les données de l'image précédente. \nLes vidéos \"Britney Spears\" et \"Claude Van Damme\" sont idéales pour tester les effets d'écran vert (ou compositing Chroma key).\n\nhttps://inspirnathan.com/_nuxt/img/img-8.9fd8119.png\n\nEnfin, l'onglet \"Musique\" vous permet de jouer à partir d'une gamme de chansons que Shadertoy met à votre disposition. \nLa musique sera jouée automatiquement lorsqu'un utilisateur visitera votre Shader si vous avez choisi une chanson de cet onglet \ndans l'un de vos canaux.\n\nhttps://inspirnathan.com/_nuxt/img/img-9.25479d8.png\n\n# Utiliser les textures\n\nL'utilisation des textures est très simple dans Shadertoy. Ouvrez un nouveau shader et remplacez le code par le contenu suivant :\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n  vec4 col = texture(iChannel0, uv);\n\n  fragColor = vec4(col); // Output to screen\n}\n\nCliquez ensuite sur la case iChannel0. \nLorsque la fenêtre contextuelle apparaît, cliquez sur l'onglet \"Textures\". \nNous allons choisir la texture \"Abstract 1\", mais examinons quelques détails affichés dans le menu contextuel.\n\nhttps://inspirnathan.com/_nuxt/img/img-10.a669cd1.png\n\nElle indique que cette texture a une résolution de 1024x1024 pixels,\nce qui implique que cette image est mieux visualisée dans un canvas de type carré ou proportionnel.\n\nElle possède également 3 canaux (rouge, vert, bleu) qui sont chacun de type uint8, un entier non signé de 8 bits.\n\nCliquez sur \"Abstract 1\" pour charger cette texture dans iChannel0.\nEnsuite, lancez votre programme de shader. Vous devriez voir la texture apparaître dans le canvas Shadertoy.\n\nhttps://inspirnathan.com/_nuxt/img/img-11.73cebfe.png\n\nAnalysons le code de notre programme shader.\n\nLes coordonnées UV sont comprises entre zéro et un sur les axes x et y.\nN'oubliez pas que le point (0, 0) commence dans le coin inférieur gauche de la toile. \nLa fonction texture récupère ce que l'on appelle les \"texels\" d'une texture en utilisant iChannel0 et les coordonnées uv.\n\nUn texel est une valeur à une coordonnée particulière de la texture. \nPour les textures 2D telles que les images, un texel est une valeur de pixel. \n\nNous échantillonnons les textures 2D en supposant que les coordonnées UV sont comprises entre zéro et un sur l'image.\nNous pouvons ensuite \"mapper\" la texture sur l'ensemble de notre canevas Shadertoy.\n\nhttps://inspirnathan.com/_nuxt/img/img-12.6aa633e.png\n\nPour les textures 3D, vous pouvez considérer un texel comme une valeur de pixel à une coordonnée 3D.\nEn règle générale, les textures 3D ne sont pas utilisées très souvent, à moins qu'il ne s'agisse de générer du bruit \nou d'effectuer une marche volumétrique des rayons.\n\nVous êtes peut-être curieux de savoir quel est le type de iChannel0 lorsque nous le passons en paramètre à la fonction de texture.\nShadertoy se charge de mettre en place un échantillonneur (sampler) pour vous.\n\nUn échantillonneur est un moyen de lier des unités de texture à un shader. \nLe type d'échantillonneur change en fonction du type de ressource que vous chargez dans l'un des quatre canaux \n(iChannel0, iChannel1, iChannel2, iChannel3).\n\nDans notre cas, nous chargeons une texture 2D dans iChannel0. \n\nPar conséquent, iChannel0 aura le type sampler2D.\n\nVous pouvez voir quels sont les autres types d'échantillonneurs disponibles sur la page wiki OpenGL.\n\n\n\n\n\n*/\n\n\n#if PART == 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n  vec4 col = texture(iChannel0, uv);\n\n  fragColor = vec4(col); // Output to screen\n}\n\n/*\nSupposons que vous vouliez créer une fonction qui vous permette de passer l'un des canaux.\nVous pouvez le faire avec le code suivant :\n*/\n#elif PART == 1\nvec3 get2DTexture( sampler2D sam, vec2 uv ) {\n  return texture(sam, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n  vec3 col = vec3(0.);\n  \n  col = get2DTexture(iChannel0, uv);\n  col += get2DTexture(iChannel1, uv);\n\n  fragColor = vec4(col,1.0); // Output to screen\n}\n\n/*\nSi vous cliquez sur la case iChannel1, sélectionnez la texture \"Abstract 3\" et exécutez votre code, \nvous devriez voir deux images mélangées.\n\nLa fonction get2DTexture que nous avons créée accepte un type sampler2D comme premier paramètre. Lorsque vous utilisez une texture 2D dans un canal, Shadertoy renvoie automatiquement un type de données sampler2D.\n\nSi vous souhaitez lire une vidéo dans le canevas Shadertoy, vous pouvez suivre les mêmes étapes que pour la texture 2D.\nChoisissez simplement une vidéo dans iChannel0, et vous devriez voir la vidéo commencer à jouer automatiquement.\n\n# Paramètres des channels\n\nTrès bien, voyons maintenant quelques paramètres de canal que nous pouvons modifier. \nTout d'abord, collez le code suivant dans votre shader :\n\n*/\n#elif PART == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n  vec4 col = texture(iChannel0, uv);\n\n  fragColor = vec4(col); // Output to screen\n}\n/*\nEnsuite, nous allons utiliser une nouvelle texture. \nCliquez sur la boîte iChannel0, allez dans l'onglet \"Textures\", allez à la page 2, et vous devriez voir une texture \"Nyancat\".\n\nhttps://inspirnathan.com/_nuxt/img/img-14.98c9198.png\n\nLa texture \"Nyancat\" est une image de 256x32 avec 4 canaux (rouge, vert, bleu et alpha). \nCliquez sur cette texture pour qu'elle apparaisse dans iChannel0.\n\nhttps://inspirnathan.com/_nuxt/img/img-15.031eb1a.png\n\nLorsque vous exécutez le code, vous devriez voir apparaître des Nyan Cats, mais ils semblent flous.\n\nhttps://inspirnathan.com/_nuxt/img/img-16.b0b0ca2.png\n\nPour y remédier, nous devons ajuster les paramètres du canal en cliquant sur la petite icône en forme d'engrenage\ndans le coin inférieur droit de la boîte du canal.\n\nhttps://inspirnathan.com/_nuxt/img/img-17.162aaac.png\n\nUn menu s'ouvre alors avec trois paramètres : Filter, Wrap et VFlip.\n\nhttps://inspirnathan.com/_nuxt/img/img-18.f7b7394.png\n\nL'option Filter vous permet de modifier le type d'algorithme utilisé pour filtrer la texture. \n\nLes dimensions de la texture et du canvas Shadertoy ne correspondent pas toujours,\nc'est pourquoi un filtre est utilisé pour échantillonner la texture.\n\nPar défaut, l'option Filter est définie sur \"mipmap\". \n\nCliquez sur le menu déroulant et choisissez \"nearest\" pour utiliser \"nearest-neighboration interpolation\".\n\nCe type de filtre est utile lorsque vous avez des textures ou des images pixellisées et que vous souhaitez \nconserver cet aspect pixellisé.\n\nhttps://inspirnathan.com/_nuxt/img/img-19.080a8f1.png\n\nLorsque vous modifiez le filtre sur \"le plus proche\", vous devriez constater que les Nyan Cats sont très clairs et nets.\n\nLes Nyan Cats ont cependant l'air un peu écrasés. Corrigeons cela en augmentant l'échelle de l'axe des x de 0,25.\n\n\n\n*/\n#elif PART == 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n  \n  uv.x *= 0.25;\n\n  vec4 col = texture(iChannel0, uv);\n\n  fragColor = vec4(col); // Output to screen\n}\n\n/*\nLorsque vous exécutez le code, les Nyan Cats n'auront plus l'air écrasés.\nVous pouvez utiliser l'option VFlip pour retourner la texture à l'envers ou à la verticale. \nDécochez la case à côté de VFlip dans les paramètres du canal pour voir les Nyan Cats se retourner.\n\nRevenez en arrière et cochez l'option VFlip pour ramener les Nyan Cats à la normale.\nVous pouvez faire bouger les Nyan Cats en soustrayant un offset à uv.x et en utilisant iTime pour animer la scène.\n\nhttps://inspirnathan.com/_nuxt/img/gif-1.6a72a28.gif\n*/\n\n#elif PART == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n  \n  uv.x *= 0.25;\n  \n  uv.x -= iTime * 0.05;\n\n  vec4 col = texture(iChannel0, uv);\n\n  fragColor = vec4(col); // Output to screen\n}\n\n/*\nPar défaut, le mode Wrap est réglé sur \"repeat\". Cela signifie que lorsque les coordonnées UV \nse trouvent en dehors de la limite entre zéro et un, l'échantillonnage commence à partir de la texture et se répète\nentre zéro et un. \n\nPuisque nous réduisons de plus en plus uv.x, nous sortons définitivement de la limite de zéro, \nmais l'échantillonneur est suffisamment intelligent pour s'adapter.\n\nSi vous ne voulez pas de ce comportement répétitif, vous pouvez régler le mode Wrap sur \"clamp\" à la place.\n\nhttps://inspirnathan.com/_nuxt/img/img-23.c97d99b.png\n\nSi vous remettez le temps à zéro, vous verrez qu'une fois que les coordonnées UV sortent de la limite de zéro ou de un,\nnous ne voyons plus les Nyan Cats.\n\nhttps://inspirnathan.com/_nuxt/img/gif-2.dd49de2.gif\n\nComme la texture \"Nyancat\" fournit quatre canaux et donc un canal alpha, nous pouvons facilement changer l'arrière-plan.\nAssurez-vous que le timer est remis à zéro et exécutez le code suivant :\n\n\n*/\n\n#elif PART == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n  \n  vec4 col = vec4(0.75);\n  \n  uv.x *= 0.25;\n  uv.x -= iTime * 0.05;\n\n  vec4 texCol = texture(iChannel0, uv);\n  \n  col = mix(col, texCol, texCol.a);\n\n  fragColor = vec4(col); // Output to screen\n}\n\n/*\nLa texture \"Nyancat\" a une valeur alpha de zéro partout sauf là où se trouvent les Nyan Cats.\nCela nous permet de définir une couleur d'arrière-plan derrière eux.\n\nhttps://inspirnathan.com/_nuxt/img/img-24.bb4e6e4.png\n\nGardez à l'esprit que la plupart des textures ne comportent que trois canaux. \nCertaines textures n'ont qu'un seul canal, comme la texture \"Bayer\". \n\nCela signifie que le canal rouge contiendra des données, mais pas les trois autres canaux, \nce qui explique pourquoi vous verrez probablement du rouge lorsque vous l'utiliserez.\n\nCertaines textures sont utilisées pour créer du bruit ou déplacer des formes d'une manière particulière.\nVous pouvez même utiliser des textures comme cartes de hauteur pour modeler la hauteur des terrains en fonction des valeurs\nde couleur stockées dans la texture. \n\nLes textures ont de multiples fonctions.\n\n# Buffers\n\nShadertoy prend en charge les buffers. \nVous pouvez exécuter des shaders complètement différents dans chaque buffer.\n\nChaque shader aura sa propre fragColor finale qui peut être transmise à un autre buffer ou au shader principal \"Image\" dans lequel\nnous avons travaillé.\n\nIl y a quatre tampons : Buffer A, Buffer B, Buffer C et Buffer D. \nChaque buffer peut contenir ses quatre canaux.\n\nPour accéder à une mémoire tampon, nous utilisons l'un des quatre canaux.\nExerçons-nous avec les tampons pour voir comment les utiliser.\n\nAu-dessus de votre code, près du haut de l'interface utilisateur de Shadertoy, vous devriez voir un onglet intitulé \"Image\". \n\nL'onglet \"Image\" représente le shader principal que nous avons utilisé dans les tutoriels précédents.\n\nPour ajouter un buffer, il suffit de cliquer sur le signe plus (+) à gauche de l'onglet Image.\n\nhttps://inspirnathan.com/_nuxt/img/img-25.dd555af.png\n\nÀ partir de là, vous verrez une liste déroulante d'éléments à choisir :\nCommon, Sound, Buffer A, Buffer B, Buffer C, Buffer D, Cubemap A.\n\nhttps://inspirnathan.com/_nuxt/img/img-26.88cbc28.png\n\nL'option Common est utilisée pour partager le code entre le shader \"Image\", tous les tampons et les autres shaders, \ny compris Sound et Cubemap A. \n\nL'option Sound vous permet de créer un shader qui génère du son. \n\nL'option Cubemap A vous permet de générer votre propre cubemap. \n\nPour ce tutoriel, je vais passer en revue les buffers, qui sont des shaders normaux qui renvoient une couleur de type vec4\n(rouge, vert, bleu, alpha).\n\nAllez-y et sélectionnez Buffer A. Vous devriez voir le code par défaut fourni pour vous.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = vec4(0.0,0.0,1.0,1.0);\n}\n\nIl semble que ce code renvoie simplement la couleur bleue pour chaque pixel. \nRevenons ensuite à l'onglet \"Image\". \n\nCliquez sur iChannel0, allez dans l'onglet \"Misc\" et sélectionnez Buffer A. \nVous devriez maintenant utiliser Buffer A pour iChannel0. Dans le shader \"Image\", collez le code suivant.\n\n\n*/\n\n#elif PART == 6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n\n  vec3 col = texture(iChannel0, uv).rgb;\n  \n  col += vec3(1, 0, 0);\n\n  // Output to screen\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nLorsque vous exécutez le code, vous devriez voir la toile entière devenir violette.\nC'est parce que nous prenons les valeurs de couleur du tampon A, que nous les passons dans le shader Image, \nque nous ajoutons du rouge à la couleur bleue obtenue dans le tampon A et que nous affichons le résultat à l'écran.\n\nEssentiellement, les buffers vous donnent plus d'espace pour travailler. \n\nVous pouvez créer un shader entier dans le buffer A, passer le résultat dans un autre buffer pour le traiter davantage, \npuis passer le résultat au shader d'image pour obtenir le résultat final.\n\nIl s'agit en quelque sorte d'un pipeline dans lequel le résultat d'un shader est transmis au suivant.\nC'est pourquoi les shaders qui utilisent des buffers ou des shaders supplémentaires sont souvent appelés shaders multi-passes.\n\n# Utiliser le clavier\n\nVous avez peut-être vu sur Shadertoy des shaders qui permettent aux utilisateurs de contrôler la scène à l'aide d'un clavier. \nJ'ai écrit un shader qui montre comment déplacer des objets à l'aide d'un clavier et qui utilise un buffer\npour stocker les résultats de chaque pression de touche. \n\nSi vous allez sur ce shader, vous devriez voir un shader multi-passes avec un buffer, Buffer A, et le shader principal \"Image\".\nhttps://www.shadertoy.com/view/sdf3RS\n\n\n\nÀ l'intérieur du buffer A, vous devriez voir le code suivant :\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    offset += (left + up + right + down) * velocity;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0, 0);\n}\n\nÀ l'intérieur du shader \"Image\", vous devriez voir le code suivant :\n\nfloat sdfCircle(vec2 uv, float r, vec2 offset) {\n    float x = uv.x - offset.x;\n    float y = uv.y - offset.y;\n    \n    float d = length(vec2(x, y)) - r;\n    \n    return step(0., -d);\n}\n\nvec3 drawScene(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    // Fetch the offset from the XY part of the pixel values returned by Buffer A\n    vec2 offset = texelFetch( iChannel0, ivec2(0,0), 0 ).xy;\n    \n    float blueCircle = sdfCircle(uv, 0.1, offset);\n    \n    col = mix(col, vec3(0, 0, 1), blueCircle);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n\n    vec3 col = drawScene(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nMon shader multi-passes dessine un cercle sur la toile et vous permet de le déplacer à l'aide du clavier.\n\nCe qui se passe en réalité, c'est que nous obtenons une valeur de un ou de zéro à partir d'une pression sur une touche\net que nous utilisons cette valeur pour contrôler la valeur de décalage du cercle.\n\nhttps://inspirnathan.com/_nuxt/img/img-27.408ae06.png\n\nSi vous regardez à l'intérieur du Buffer A, vous remarquerez que j'utilise le Buffer A dans iChannel0 à partir du Buffer A.\nComment est-ce possible ? Lorsque vous utilisez le Buffer A dans le shader Buffer A,\nvous avez accès à la valeur fragColor de la dernière image qui a été exécutée.\n\nIl n'y a pas de récursivité.\nÀ ma connaissance, il n'est pas possible d'utiliser la récursivité en GLSL. \n\nPar conséquent, tout doit être codé de manière itérative. \n\nCependant, cela ne nous empêche pas d'utiliser des tampons image par image.\n\nLa fonction texelFetch effectue une recherche d'une seule valeur de texel dans une texture. \n\nUn clavier n'est pas une texture, alors comment cela fonctionne-t-il ? \nShadertoy a essentiellement collé les choses d'une manière qui nous permet d'accéder aux événements du clavier du navigateur\nà partir d'un shader comme s'il s'agissait d'une texture. \n\nNous pouvons accéder aux touches pressées en utilisant texelFetch pour vérifier si une touche a été pressée.\n\nNous obtenons un zéro ou un, selon qu'une touche n'est pas enfoncée ou qu'elle l'est, respectivement.\nNous pouvons alors multiplier cette valeur par une vitesse pour ajuster le décalage du cercle.\nLa valeur du décalage sera transmise à la prochaine image du Buffer A. Ensuite, elle sera transmise au shader \"Image\".\n\nSi la scène tourne à 60 images par seconde (fps), cela signifie qu'une image est dessinée toutes les 1/60 de seconde. \nAu cours d'une passe de notre shader multi-passes, nous extrairons la valeur du tampon A de la dernière image,\nla transmettrons au shader du tampon A de l'image actuelle,\ntransmettrons ce résultat au shader \"Image\", puis dessinerons le pixel sur le canvas.\n\nCe cycle se répète à chaque image ou 60 fois par seconde.\n\nD'autres éléments interactifs, tels que le microphone de notre ordinateur, peuvent également être accédés comme des textures.\nVeuillez lire les ressources ci-dessous pour voir des exemples créés par Inigo Quilez sur la façon d'utiliser divers éléments\ninteractifs dans Shadertoy.\n\n# Conclusion\n\nLes textures sont un concept très important dans l'infographie et le développement de jeux.\nGLSL et d'autres langages de shaders fournissent des fonctions permettant d'accéder aux données de texture.\nShadertoy prend en charge une grande partie du travail pour vous, afin que vous puissiez accéder rapidement aux textures\nou aux éléments interactifs via des canaux. \n\nVous pouvez utiliser les textures pour stocker des valeurs de couleur, puis utiliser ces couleurs pour représenter \ndifférents types de données telles que la hauteur, le déplacement, la profondeur ou toute autre chose à laquelle vous pouvez penser.\n\nVeuillez consulter les ressources ci-dessous pour apprendre à utiliser divers éléments interactifs dans Shadertoy.\n\n*/\n\n\n\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}