{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define SCENE 0\n//#define BUMPY\n#define AUTOCAM\n#define SPIN\n\nvec3 sunDir = normalize(vec3(0.0,0.3,1.0));\n\n\n\n// rotate camera\n#define pee 3.141592653\n#ifdef AUTOCAM\n#define anglex2 (sin(iTime*0.3)*0.4)\n#define angley2 (iTime*0.2-0.4)\n#else\nfloat anglex2 = (0.5 - iMouse.y/iResolution.y)*pee*1.2; // mouse cam\nfloat angley2 = -iMouse.x/iResolution.x*pee*2.0;\n#endif\n\nvec3 campos;\nvec3 dir;\n\n \nvec3 backGround2() // unused checkerboard\n{\n\tif (dir.y>0.0) return vec3(1,1,1);\n\tvec2 floorcoords = campos.xz + dir.xz*(-campos.y/dir.y);\n\tvec2 t = (fract(floorcoords.xy*0.5))-vec2(0.5,0.5);\n\treturn vec3(1,1,1) - vec3(0.6,0.3,0)*float(t.x*t.y>0.0);\n}\n\n\nfloat texture_iq_heart(vec2 pos) // let's steal his heart\n{\n\tfloat rot = pos.x;\n\tpos.x += pos.y*0.3; // rotate and scale to misalign\n\tpos.y -= rot*0.3;\n\tpos=(fract((pos))-vec2(0.5,0.7))*0.8; // fract makes it repetitive, 0.8 scales the heart size\n\tfloat f1 = abs(atan(pos.x,pos.y)/pee);\n\treturn (f1*6.5 - f1*f1*11.0 + f1*f1*f1*5.0)/(6.0-f1*5.0)-length(pos);\n}\n\n\nvec3 sky()\n{\n\tfloat f = max(dir.y,0.0);\n\tvec3 color = 1.0-vec3(1,0.85,0.7)*f;\n\tcolor *= dir.z*0.2+0.8;\n\t\n\tif (dot(sunDir,dir)>0.0)\n\t{\n\t f = max(length(cross(sunDir,dir))*10.0,1.0);\n\t\t\n\t color += vec3(1,0.9,0.7)*40.0/(f*f*f*f);\n\t}\n\treturn color;\n\t\n}\n\nvec3 backGround()\n{\n//    return vec3(dir.y*0.5+0.5);\n \tif (dir.y>=0.0) return sky();\n \tvec3 raypos2 = campos - dir*(campos.y / dir.y);\n\tfloat fog = exp(length(raypos2)/-8.0);\n \treturn sky()*(1.0-fog)+(vec3(0.3,0.5,0.7)+vec3(0.3,0.15,0.0)*((clamp(texture_iq_heart(raypos2.xz)*20.0,0.0,1.0))))*fog;\n}\n\n\n\nvec3 rotatex(vec3 v,float anglex)\n{\n\tfloat t;\n\tt =   v.y*cos(anglex) - v.z*sin(anglex);\n\tv.z = v.z*cos(anglex) + v.y*sin(anglex);\n\tv.y = t;\n\treturn v;\n}\n\nvec3 rotcam(vec3 v)\n{\n\tfloat t;\n\tv = rotatex(v,anglex2);\n\t\n\tt = v.x * cos(angley2) - v.z*sin(angley2);\n\tv.z = v.z*cos(angley2) + v.x*sin(angley2);\n\tv.x = t;\n\treturn v;\n}\n\nint side; // 1 for raytracing outside glass,  -1 for raytracing inside glass\n\nfloat gTravel;\nvec3 gNormal;\n\nfloat travelMax,travelMin;\nvec3 normalMax,normalMin;\n\n// a ray hits a surface surfaceside shows weather it hit from the rear or front of the plane \nvoid update(float surfaceside,float travel,vec3 normal)\n{\n\tif (surfaceside<0.0)\n\t{\n\t\tif (travelMax<travel)\n\t\t{\n\t\t\ttravelMax = travel;\n\t\t\tnormalMax = normal;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (travelMin>travel)\n\t\t{\n\t\t\ttravelMin = travel;\n\t\t\tnormalMin = normal;\n\t\t}\n\t}\n}\n\nvoid hitPlane(vec3 normal,float shift) // check ray-plane intersection. Planes are infinte large\n{\n#ifdef SPIN\n\tfloat angle = fract(iTime*0.25);\n\tangle = min(angle*1.5,1.0);\n\t\n\tnormal = rotatex(normal,angle*pee*2.0);        // rotate object\n#endif\n\tshift += normal.y*1.0;         // and shift up from the ground height\n\t\n\tfloat distFromPlane = dot(normal,campos) - shift;\n\tfloat travel = -distFromPlane / dot(normal,dir);\n\tupdate(dot(normal,dir),travel,normal);\n}\n\nvoid startObj()\n{\n\ttravelMax = -1e35;\n\ttravelMin = 1e35;\n}\n\nvoid endObj()\n{\n//\tif (travelMax<travelMin)     // enable this for nonconvex objects\n\t{\n\t\tif (side>0)\n\t\t{\n\t\t\tif (travelMax<travelMin && travelMax>0.0 && travelMax<gTravel)\n\t\t\t{\n\t\t\t\tgTravel = travelMax;\n\t\t\t\tgNormal = normalMax;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (travelMin>0.0 && travelMin<gTravel)\n\t\t\t{\n\t\t\t\tgTravel = travelMin;\n\t\t\t\tgNormal = -normalMin;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid hitKocka() // trace the mesh\n{\n\tstartObj();\n\t\t\n\tif (SCENE==0)\n\t{\n\t\n\t\thitPlane(vec3(1,0,0),0.6);\n\t\thitPlane(vec3(-1,0,0),0.6);\n\t\thitPlane(vec3(0,0,1),0.2);\n\t\thitPlane(vec3(0,0,-1),0.2);\n\t\thitPlane(vec3(0,1,0),0.75);\n\t\thitPlane(vec3(0,-1,0),0.75);\n\t\thitPlane(normalize(vec3(1,1,0)),0.6); // cut off it's edge\n\t}\n\t\n\tif (SCENE==1)\n\t{\n\t\tfor(float angle=0.0;angle<pee*2.0;angle+=pee/4.0)\n\t\t{\n\t\t\thitPlane(vec3(sin(angle),0.5,cos(angle)),0.4);\n\t\t\thitPlane(vec3(sin(angle),-2.0,cos(angle)),1.5);\n\t\t}\n\t}\n\t\n\tif (SCENE==2)\n\t{\n\t\tfor(float angle2=pee/8.0;angle2<pee;angle2+=pee/6.0)\n\t\tfor(float angle=0.0;angle<pee*2.0;angle+=pee/6.0)\n\t\t{\n\t\t\t{\n\t\t\t\thitPlane(vec3(sin(angle)*sin(angle2),cos(angle2),cos(angle)*sin(angle2)),0.7);\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\tendObj();\t\n}\n\n\n\nvec3 getInsideFake() // use this only for debigging\n{\n\tgTravel = 1e35;\n\thitKocka();\n\tif (gTravel>1e34){return  backGround();}\n\treturn vec3(  dot(vec3(0.7,0.7,0.2),gNormal)*0.5+0.5,0,0);\n}\n\n\nvec3 glassColorFunc(float dist) // exponentioanly turn light green as it travels within glass (real glass has this porperty)\n{\n\tif(side>0) return vec3(1,1,1);\n\treturn vec3(exp(dist*-0.4),exp(dist*-0.05),exp(dist*-0.2));\n}\n\nvec3 black()\n{\n\treturn vec3(0.0);\n}\n\n\nvoid bumpit()\n{\n#ifdef BUMPY\n\tgNormal.x += sin(campos.x*30.0)*0.007;\n\tgNormal.y += sin(campos.y*30.0)*0.007;\n\tgNormal.z += sin(campos.z*30.0)*0.007;\n\tgNormal = normalize(gNormal);\n#endif\n}\n\n\t\t\t\t\t \n// recursion unsupported, let's overcome it like this\n// CHILD0 refracted ray proc\n// CHILD1 reflected ray proc\n#define GET(BASE,CHILD0,CHILD1) vec3 BASE(){if (!(length(dir)<1.01) || !(length(dir)>0.99)) return vec3(0.0,0.0,0.0); gTravel = 1e35; hitKocka();if (gTravel>1e34){return  backGround();}campos += dir * gTravel;bumpit();vec3 glassColor = glassColorFunc(gTravel); vec3 originalDir = dir;\tvec3 originalPos = campos;\tvec3 originalNormal = gNormal;\tdir = refract(originalDir,originalNormal,side>0 ? 1.0/1.55 : 1.55);  float t = clamp(1.0+dot(gNormal,side>0?originalDir : dir),0.0,1.0);\tfloat fresnel = 0.1 + (t*t*t*t*t)*0.9;\t\tside *=-1; vec3 color =  CHILD0()*(1.0-fresnel);\tside *=-1; campos = originalPos;\tdir = reflect(originalDir,originalNormal);\t color += CHILD1()*(fresnel);  return color*glassColor;\t}\n\n\n// having to deal with just one convex object, any ray refracting out of it is casted \n// to the background directly without other ray checking\n\nGET(get8,backGround,black) \nGET(get7,backGround,get8)\nGET(get6,backGround,get7)\nGET(get5,backGround,get6)\nGET(get4,backGround,get5)\nGET(get3,backGround,get4)\nGET(get2,backGround,get3) \nGET(get,get2,backGround)  // starting from the camera, the reflected ray goes to the background, refrated part handled in get2\n\n\t\nfloat func(float x) // the func for HDR (looks better with HDR disabled)\n{\n\treturn x/(x+3.0)*3.0;\n}\nvec3 HDR(vec3 color)\n{\n\tfloat pow = length(color);\n\treturn color * func(pow)/pow*1.2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat brightNess = min(iTime/5.0,1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tcampos = vec3(0,1.0,0);\n\tdir = vec3(uv*2.0-1.0,1);\n\tdir.y *= 9.0/16.0; // wide screen\n\t\n\tdir = normalize(rotcam(dir));\n    \n\tcampos -= rotcam(vec3(0,0,2)); // back up from subject\n\t\n\tgTravel = 1e35;\n\tside = 1;\n\t\n\t\t\n\tfragColor = vec4((get()*brightNess),1.0); // add HDR() if you like it\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s2Gz3","date":"1391716994","viewed":5187,"name":"real glass","username":"archee","description":"my first try in shadertoy.\nChange #defines in the beginning for options","likes":57,"published":1,"flags":0,"usePreview":1,"tags":["raytrace","glass","heart"],"hasliked":0,"parentid":"","parentname":""}}