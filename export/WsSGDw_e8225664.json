{"ver":"0.1","info":{"id":"WsSGDw","date":"1548964816","viewed":870,"name":"Kilauea Volcano Lava (Worley)","username":"amally","description":"Inspired by https://www.reddit.com/r/gifs/comments/akb8l3/k%C4%ABlauea_hawaii/\n\nWill come back to this later to try and make the motion better match the motion of the reference.","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["procedurallava"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 a = vec3(0.5, 0.5, 0.4);\nconst vec3 b = vec3(0.5, 0.5, 0.43);\nconst vec3 c = vec3(0.46, 0.57, 0.4);\nconst vec3 d = vec3(0.63, 0.4233, -1.573);\n\nvec3 cosinePalette(float t) {\n    return clamp(a + b * cos(2.0 * 3.14159 * (c * t + d)), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float h = texture(iChannel0, uv).r;\n    //h = 1.0 - h;\n    fragColor = vec4(h, h, h, 1.0);\n    \n    \n    float c = 40.0; // Contrast factor\n    float contrastFactor = (259.0 * (c + 255.0)) / (255.0 * (259.0 - c));\n    //h = clamp(contrastFactor * (h - 0.5) + 0.5, 0.0, 1.0);\n\n    //h = 1.0 - sin(h * 3.14159 * 0.5);\n    h = min(1.0, pow(h, 2.0));\n\n    // Output to screen\n    fragColor = vec4(cosinePalette(h), 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec3 a = vec3(0.5, 0.5, 0.4);\nconst vec3 b = vec3(0.5, 0.5, 0.43);\nconst vec3 c = vec3(0.46, 0.57, 0.4);\nconst vec3 d = vec3(0.63, 0.4233, -1.573);\n\nvec3 cosinePalette(float t) {\n    return clamp(a + b * cos(2.0 * 3.14159 * (c * t + d)), 0.0, 1.0);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 mySmoothStep(vec2 a, vec2 b, float t) {\n    t = smoothstep(0.0, 1.0, t);\n    return mix(a, b, t);\n}\n\nvec2 interpNoise2D(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    vec2 ll = random2(floor(uv));\n    vec2 lr = random2(floor(uv) + vec2(1,0));\n    vec2 ul = random2(floor(uv) + vec2(0,1));\n    vec2 ur = random2(floor(uv) + vec2(1,1));\n\n    vec2 lerpXL = mySmoothStep(ll, lr, uvFract.x);\n    vec2 lerpXU = mySmoothStep(ul, ur, uvFract.x);\n\n    return mySmoothStep(lerpXL, lerpXU, uvFract.y);\n}\n\nvec2 fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 1.0;\n    vec2 sum = vec2(0.0);\n    float maxSum = 0.0;\n    for(int i = 0; i < 6; i++) {\n        sum += interpNoise2D(uv * freq) * amp;\n        maxSum += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum / maxSum;\n}\n\nfloat particleVis(vec2 uv) {\n    float minDist = 1.0;\n    \n    for(float i = 0.0; i < 400.0; i += 4.0) {\n        vec2 bufB_UV = vec2(i / float(iResolution.x), 0.0);\n        vec2 particlePos = texture(iChannel0, bufB_UV).xy;\n        \n        float dist = length(particlePos - uv);\n        minDist = min(dist, minDist);\n    }\n    return step(minDist, 0.05);\n}\n\nfloat worleyNoiseInefficient(vec2 uv) {\n    float minDist = 1.0;\n    \n    for(float i = 0.0; i < 100.0; ++i) {\n        vec2 bufB_UV = vec2(i / float(iResolution.x), 0.0);\n        vec2 particlePos = texture(iChannel0, bufB_UV).xy;\n        \n        float dist = length(particlePos - uv);\n        minDist = min(dist, minDist);\n    }\n    return minDist;\n}\n\nfloat WorleyNoise(vec2 uv)\n{\n    // Tile the space\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat iqsVoronoiDistanceInefficient( vec2 x ) {\n    float minDist = 1.0;\n    \n    vec2 mb;\n    vec2 mr;\n    \n    vec2 a, b;\n    \n    vec2 res = vec2(8.0);\n    for(float i = 0.0; i < 100.0; ++i) {\n        vec2 bufB_UV = vec2(i / float(iResolution.x), 0.0);\n        vec2 particlePos = texture(iChannel0, bufB_UV).xy;\n        \n        vec2 r = particlePos - x;\n        float dist = dot(r, r);\n        \n        if(dist < res.x) {\n            res.y = dist;\n            mr = r;\n            a = r;\n        }\n        else if(dist < res.y) {\n            res.y = dist;\n            b = r;\n        }\n    }\n    \n    /*\n    for(float i = 0.0; i < 100.0; ++i) {\n        vec2 bufB_UV = vec2(i / float(iResolution.x), 0.0);\n        vec2 particlePos = texture(iChannel0, bufB_UV).xy;\n        vec2 r = particlePos - x;\n        float dist = dot(0.5 * (mr + r), normalize(r - mr));\n        res = min(res, dist);\n    }\n\n    return res;\n\t*/\n    return dot(0.5 * (a + b), normalize(b - a));\n}\n\nfloat iqsVoronoiDistance( vec2 x ) {\n    vec2 p = vec2(floor(x));\n    vec2 f = fract(x);\n\n    vec2 mb;\n    vec2 mr;\n\n    float res = 8.0;\n    for(int j = -1; j <= 1; j++) {\n        for(int i = -1; i <= 1; i++) {\n            vec2 b = vec2(float(i), float(j));\n            vec2 o = random2(p + b);\n            o = 0.5 + 0.5 * sin(iTime + 6.2831 * o); // 0 to 1 range\n            vec2 r = vec2(b) + o - f;\n            float d = dot(r,r);\n\n            if( d < res ) {\n                res = d;\n                mr = r;\n                mb = b;\n            }\n    \t}\n    }\n\n    res = 8.0;\n    for(int j = -2; j <= 2; j++) {\n        for(int i = -2; i <= 2; i++) {\n            vec2 b = mb + vec2(float(i), float(j));\n            vec2 o = random2(p + b);\n            o = 0.5 + 0.5 * sin(iTime + 6.2831 * o); // 0 to 1 range\n            vec2 r = vec2(b) + o - f;\n            float d = dot(0.5 * (mr + r), normalize(r - mr));\n\n            res = min( res, d );\n        }\n    }\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    // Gridify and animate with rightward motion\n    uv = uv * 4.0;// - vec2(iTime, 0.0) + vec2(sin(iTime * 3.14159 * 0.25), cos(iTime * 3.14159 * 0.2) * 0.25);\n    vec2 offset = fbm(uv);\n    // [-1, 1]\n    offset = (2.0 * offset) - 1.0;\n    uv = uv + offset * 0.5;\n    // Worley cells\n    float h = worleyNoiseInefficient(uv);\n\n    // Output to screen\n    fragColor = vec4(h, h, h, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Each pixel represents a different cell\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(420.69,987.654)))*85734.3545);\n}\n\nvec2 randomVector2( vec2 p ) {\n    return normalize(2.0 * fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) - 1.0);\n}\n\nfloat bias(float t, float amt) {\n    return (t / ((((1.0 / amt) - 2.0) * (1.0 - t)) + 1.0));\n}\n\nfloat gain(float t, float amt) {\n    return step(t, 0.5) * bias(t * 2.0, amt) * 0.5 + step(0.5, t) * bias(t * 2.0 - 1.0, 1.0 - amt) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 origin = vec2(2.0, 1.0) * iResolution.x / iResolution.y;\n    vec2 dir = randomVector2(fragCoord.xy);\n    float timeOffset = sin(random1(fragCoord.xx * 0.01) * 3.14159 * 0.5) * 12.0;\n    //timeOffset = gain(timeOffset, 0.65);\n    float t = mod(iTime + timeOffset, 6.0);// + random1(gl_FragCoord.yz * 10.0) * 2.0;\n    \n    vec2 pos = origin + t * dir;\n    //pos = mod(pos, 1.0) * sign(pos);\n    \n    \n    //float coeff = mod(gl_FragCoord.x, 2.0);// * mod(gl_FragCoord.y + 1.0, 2.0);\n    \n    fragColor = vec4(pos, 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}