{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Use a closest point map to accelerate tracing through a grid\n// Works quickly with high resolutions except when grazing geometry\n// Tech demo so not bothering with antialiasing\n\n// Similar to Anisotropic Cone Mapping: \n// https://www.csie.ntu.edu.tw/~cyy/publications/papers/apsipa2009.pdf\n\nconst int MAX_STEPS = 40;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float scale = 1.0 / iResolution.y;\n    \n    vec2 uv = fragCoord * scale;\n    Settings settings = get_settings(iResolution.xy);\n    \n    // wait until the closest point map is computed\n    if (uint(iFrame) < settings.total_frames) {\n        fragColor = vec4(vec3(0.0),1.0);\n        return;\n    }\n    \n    Ray ray = Ray(vec2(0.6, 0.1), normalize(vec2(1.0, 1.0)));\n    \n    // draw the current mouse pos and direction ray\n    if (iMouse.z > 0.0) {\n        ray.pos = abs(iMouse.zw) * scale;\n        vec2 end_pos = iMouse.xy * scale;\n        \n        ray.dir = normalize(end_pos - ray.pos);\n    }\n    \n    // the ray\n    if (distance_to_ray(ray, uv) < scale) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    // start point\n    if (distance(uv, ray.pos) < scale * 5.0) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        return;\n    }\n    \n    // use different channels to lookup the closest point based in the direction\n    vec2 pos = ray.pos;\n\n    if (ray.dir.x >= 0.0) {\n        if (ray.dir.y >= 0.0) {\n            // top right\n            for (int step_index = 0; step_index < MAX_STEPS; step_index++) {\n                ivec2 cell_pos = ivec2(floor(pos / scale));\n\n                ivec2 step_amount = unpack_2d_pos(texelFetch(iChannel1, cell_pos, 0).x);\n\n                float radius = length(vec2(step_amount)) * scale;\n\n                if (radius < scale) {\n                    // hit so stop\n                    break;\n                }\n\n                // step along on the ray direction\n                vec2 next_pos = pos + ray.dir * radius;\n                if (distance(uv, next_pos) < scale * 5.0) {\n                    fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n                    return;\n                }\n\n                // circular segment\n                if (uv.x > pos.x && uv.y > pos.y && abs(distance(uv, pos) - radius) < scale) {\n                    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                }\n\n                // axis lines of circular segment\n                if (distance_to_line_segment(Line(pos, pos + vec2(radius, 0)), uv) < scale\n                || distance_to_line_segment(Line(pos, pos + vec2(0, radius)), uv) < scale) {\n                    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                }\n\n                // closest point\n                if (distance(uv, vec2(cell_pos + step_amount)*scale) < scale * 5.0) {\n                    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                }\n\n                pos = next_pos;\n            }\n        } else {\n            // bottom right\n            for (int step_index = 0; step_index < MAX_STEPS; step_index++) {\n                ivec2 cell_pos = ivec2(floor(pos / scale));\n\n                ivec2 step_amount = unpack_2d_pos(texelFetch(iChannel1, cell_pos, 0).y);\n\n                float radius = length(vec2(step_amount)) * scale;\n\n                if (radius < scale) {\n                    // hit so stop\n                    break;\n                }\n\n                // step along on the ray direction\n                vec2 next_pos = pos + ray.dir * radius;\n                if (distance(uv, next_pos) < scale * 5.0) {\n                    fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n                    return;\n                }\n\n                // circular segment\n                if (uv.x > pos.x && uv.y < pos.y && abs(distance(uv, pos) - radius) < scale) {\n                    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                }\n\n                // axis lines of circular segment\n                if (distance_to_line_segment(Line(pos, pos + vec2(radius, 0)), uv) < scale\n                || distance_to_line_segment(Line(pos, pos - vec2(0, radius)), uv) < scale) {\n                    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                }\n\n                // closest point\n                if (distance(uv, vec2(cell_pos + step_amount)*scale) < scale * 5.0) {\n                    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                    return;\n                }\n\n                pos = next_pos;\n            }\n        }\n    } else if (ray.dir.y >= 0.0) {\n        // top left\n        for (int step_index = 0; step_index < MAX_STEPS; step_index++) {\n            ivec2 cell_pos = ivec2(floor(pos / scale));\n\n            ivec2 step_amount = unpack_2d_pos(texelFetch(iChannel1, cell_pos, 0).w);\n\n            float radius = length(vec2(step_amount)) * scale;\n\n            if (radius < scale) {\n                // hit so stop\n                break;\n            }\n\n            // step along on the ray direction\n            vec2 next_pos = pos + ray.dir * radius;\n            if (distance(uv, next_pos) < scale * 5.0) {\n                fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n                return;\n            }\n\n            // circular segment\n            if (uv.x < pos.x && uv.y > pos.y && abs(distance(uv, pos) - radius) < scale) {\n                fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                return;\n            }\n\n            // axis lines of circular segment\n            if (distance_to_line_segment(Line(pos, pos - vec2(radius, 0)), uv) < scale\n            || distance_to_line_segment(Line(pos, pos + vec2(0, radius)), uv) < scale) {\n                fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                return;\n            }\n\n            // closest point\n            if (distance(uv, vec2(cell_pos + step_amount)*scale) < scale * 5.0) {\n                fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                return;\n            }\n\n            pos = next_pos;\n        }\n    } else {\n        // bottom left\n        for (int step_index = 0; step_index < MAX_STEPS; step_index++) {\n            ivec2 cell_pos = ivec2(floor(pos / scale));\n\n            ivec2 step_amount = unpack_2d_pos(texelFetch(iChannel1, cell_pos, 0).z);\n\n            float radius = length(vec2(step_amount)) * scale;\n\n            if (radius < scale) {\n                // hit so stop\n                break;\n            }\n\n            // step along on the ray direction\n            vec2 next_pos = pos + ray.dir * radius;\n            if (distance(uv, next_pos) < scale * 5.0) {\n                fragColor = vec4(0.0, 1.0, 1.0, 1.0);\n                return;\n            }\n\n            // circular segment\n            if (uv.x < pos.x && uv.y < pos.y && abs(distance(uv, pos) - radius) < scale) {\n                fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                return;\n            }\n\n            // axis lines of circular segment\n            if (distance_to_line_segment(Line(pos, pos - vec2(radius, 0)), uv) < scale\n            || distance_to_line_segment(Line(pos, pos - vec2(0, radius)), uv) < scale) {\n                fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                return;\n            }\n\n            // closest point\n            if (distance(uv, vec2(cell_pos + step_amount)*scale) < scale * 5.0) {\n                fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n                return;\n            }\n\n            pos = next_pos;\n        }\n        \n    }\n    \n    // draw the scene otherwise\n    if (texture(iChannel0, uv).r > 0.5) {\n        fragColor = vec4(vec3(1.0), 1.0);\n        return;\n    }\n\n    fragColor = vec4(vec3(0.0),1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Compute the closest-distance map: https://www.shadertoy.com/view/XcVBzh\n// could just do this once but will need to re-compute it when the scene changes\n// or when the resolution changes (resize / fullscreen) so just keep re-computing for demo\n\nbool hit_scene(in ivec2 coord) {\n    return texture(iChannel0, vec2(coord) / iResolution.y).r > 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(floor(fragCoord));\n    ivec2 res = ivec2(iResolution.xy);\n    Settings settings = get_settings(iResolution.xy);\n    uint frame = uint(iFrame) % settings.total_frames;\n    \n    // check collision with the scene for the first frame\n    if (frame == uint(0)) {\n        //sample this pixel first and just return if we get a result\n        if (hit_scene(coord)) {\n            fragColor = vec4(uintBitsToFloat(uint(0)));\n            return;\n        }\n        \n        // otherwise branch out in each direction linearly\n        // split the sampling of each direction so we can break early in each direction\n        \n        // top\n        uint closest_top = settings.max_value;\n        uint max_top_offset = min(settings.num_samples, uint(res.y - coord.y));\n        for (uint offset=uint(1); offset<max_top_offset; offset++) {\n            if (hit_scene(coord + ivec2(0, offset))) {\n                closest_top = offset;\n                break;\n            }\n        }\n\n        // right\n        uint closest_right = settings.max_value;\n        uint max_right_offset = min(settings.num_samples, uint(res.x - coord.x));\n        for (uint offset=uint(1); offset<max_right_offset; offset++) {\n            if (hit_scene(coord + ivec2(offset, 0))) {\n                closest_right = offset;\n                break;\n            }\n        }\n\n        // bottom\n        uint closest_bottom = settings.max_value;\n        uint max_bottom_offset = min(settings.num_samples, uint(coord.y));\n        for (uint offset=uint(1); offset<max_bottom_offset; offset++) {\n            if (hit_scene(coord + ivec2(0, -offset))) {\n                closest_bottom = offset;\n                break;\n            }\n        }\n\n        // left\n        uint closest_left = settings.max_value;\n        uint max_left_offset = min(settings.num_samples, uint(coord.x));\n        for (uint offset=uint(1); offset<max_left_offset; offset++) {\n            if (hit_scene(coord + ivec2(-offset, 0))) {\n                closest_left = offset;\n                break;\n            }\n        }\n\n        fragColor = vec4(\n            uintBitsToFloat(closest_top),\n            uintBitsToFloat(closest_right),\n            uintBitsToFloat(closest_bottom),\n            uintBitsToFloat(closest_left)\n        );\n\n        return;\n    }\n    \n    if (frame < settings.num_frames) {\n        // jump in a binary manner over multiple frames to find the closest distance for the entire resolution\n        vec4 last_value = texelFetch(iChannel1, coord, 0);\n        uint step_amount = uint(pow(float(settings.num_samples), float(frame)));\n        \n        uint step_max_offset = settings.num_samples * step_amount;\n\n        // top\n        uint last_top = floatBitsToUint(last_value.r);\n\n        if (last_top > step_amount) {\n            uint max_offset = min(step_max_offset, uint(iResolution.y) - uint(coord.y));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 top_neighbour = texelFetch(iChannel1, coord + ivec2(0, offset), 0);\n                uint closest_top = floatBitsToUint(top_neighbour.r) + offset;\n\n                if (closest_top < last_top) {\n                    last_top = closest_top;\n                    break;\n                }\n            }\n        }\n\n        // right\n        uint last_right = floatBitsToUint(last_value.g);\n\n        if (last_right > step_amount) {\n            uint max_offset = min(step_max_offset, uint(iResolution.x) - uint(coord.x));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 right_neighbour = texelFetch(iChannel1, coord + ivec2(offset, 0), 0);\n                uint closest_right = floatBitsToUint(right_neighbour.g) + offset;\n\n                if (closest_right < last_right) {\n                    last_right = closest_right;\n                    break;\n                }\n            }\n        }\n\n        // bottom\n        uint last_bottom = floatBitsToUint(last_value.b);\n\n        if (last_bottom > step_amount) {\n            uint max_offset = min(step_max_offset, uint(coord.y));\n        \n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 bottom_neighbour = texelFetch(iChannel1, coord + ivec2(0, -offset), 0);\n                uint closest_bottom = floatBitsToUint(bottom_neighbour.b) + offset;\n\n                if (closest_bottom < last_bottom) {\n                    last_bottom = closest_bottom;\n                    break;\n                }\n            }\n        }\n\n        // left\n        uint last_left = floatBitsToUint(last_value.a);\n\n        if (last_left > step_amount) {\n            uint max_offset = min(step_max_offset, uint(coord.x));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 left_neighbour = texelFetch(iChannel1, coord + ivec2(-offset, 0), 0);\n                uint closest_left = floatBitsToUint(left_neighbour.a) + offset;\n\n                if (closest_left < last_left) {\n                    last_left = closest_left;\n                    break;\n                }\n            }\n        }\n\n        // store the accumulated closest point\n        fragColor = vec4(\n            uintBitsToFloat(last_top),\n            uintBitsToFloat(last_right),\n            uintBitsToFloat(last_bottom),\n            uintBitsToFloat(last_left)\n        );\n        \n        return;\n    }\n\n    // once complete, compute the quadrant closest points using the distances computed\n    frame -= settings.num_frames;\n\n    if (frame == uint(0)) {\n        vec4 distances = texelFetch(iChannel1, coord, 0);\n        uint top_dist = floatBitsToUint(distances.r);\n        uint right_dist = floatBitsToUint(distances.g);\n        uint bottom_dist = floatBitsToUint(distances.b);\n        uint left_dist = floatBitsToUint(distances.a);\n        \n        // top right\n        ivec2 closest_top_right;\n        float closest_top_right_dist;\n        if (top_dist < right_dist) {\n            closest_top_right = ivec2(0, int(top_dist));\n            closest_top_right_dist = float(top_dist);\n        } else {\n            closest_top_right = ivec2(int(right_dist), 0);\n            closest_top_right_dist = float(right_dist);\n        }\n        \n        int max_top_right_offset = min(res.y - coord.y, min(res.x - coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_top_right_offset; offset++) {\n            ivec2 cell_offset = ivec2(offset, offset);\n            \n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n            \n            ivec2 closest_top = ivec2(0, int(floatBitsToUint(next_cells.r))) + cell_offset;\n            float closest_top_distance = dist(closest_top);\n\n            if (closest_top_distance < closest_top_right_dist) {\n                closest_top_right = closest_top;\n                closest_top_right_dist = closest_top_distance;\n            }\n\n            ivec2 closest_right = ivec2(int(floatBitsToUint(next_cells.g)), 0) + cell_offset;\n            float closest_right_distance = dist(closest_right);\n\n            if (closest_right_distance < closest_top_right_dist) {\n                closest_top_right = closest_right;\n                closest_top_right_dist = closest_right_distance;\n            }\n        }\n        \n        // bottom right\n        ivec2 closest_bottom_right;\n        float closest_bottom_right_dist;\n        if (bottom_dist < right_dist) {\n            closest_bottom_right = ivec2(0, -int(bottom_dist));\n            closest_bottom_right_dist = float(bottom_dist);\n        } else {\n            closest_bottom_right = ivec2(int(right_dist), 0);\n            closest_bottom_right_dist = float(right_dist);\n        }\n        \n        int max_bottom_right_offset = min(coord.y, min(res.x - coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_bottom_right_offset; offset++) {\n            ivec2 cell_offset = ivec2(offset, -offset);\n            \n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_bottom = ivec2(0, -int(floatBitsToUint(next_cells.b))) + cell_offset;\n            float closest_bottom_distance = dist(closest_bottom);\n\n            if (closest_bottom_distance < closest_bottom_right_dist) {\n                closest_bottom_right = closest_bottom;\n                closest_bottom_right_dist = closest_bottom_distance;\n            }\n\n            ivec2 closest_right = ivec2(int(floatBitsToUint(next_cells.g)), 0) + cell_offset;\n            float closest_right_distance = dist(closest_right);\n\n            if (closest_right_distance < closest_bottom_right_dist) {\n                closest_bottom_right = closest_right;\n                closest_bottom_right_dist = closest_right_distance;\n            }\n        }\n        \n        // bottom left\n        ivec2 closest_bottom_left;\n        float closest_bottom_left_dist;\n        if (bottom_dist < left_dist) {\n            closest_bottom_left = ivec2(0, -int(bottom_dist));\n            closest_bottom_left_dist = float(bottom_dist);\n        } else {\n            closest_bottom_left = ivec2(-int(left_dist), 0);\n            closest_bottom_left_dist = float(left_dist);\n        }\n        \n        int max_bottom_left_offset = min(coord.y, min(coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_bottom_left_offset; offset++) {\n            ivec2 cell_offset = ivec2(-offset);\n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_bottom = ivec2(0, -int(floatBitsToUint(next_cells.b))) + cell_offset;\n            float closest_bottom_distance = dist(closest_bottom);\n\n            if (closest_bottom_distance < closest_bottom_left_dist) {\n                closest_bottom_left = closest_bottom;\n                closest_bottom_left_dist = closest_bottom_distance;\n            }\n\n            ivec2 closest_left = ivec2(-int(floatBitsToUint(next_cells.a)), 0) + cell_offset;\n            float closest_left_distance = dist(closest_left);\n\n            if (closest_left_distance < closest_bottom_left_dist) {\n                closest_bottom_left = closest_left;\n                closest_bottom_left_dist = closest_left_distance;\n            }\n        }\n        \n        // top left\n        ivec2 closest_top_left;\n        float closest_top_left_dist;\n        if (top_dist < left_dist) {\n            closest_top_left = ivec2(0, int(top_dist));\n            closest_top_left_dist = float(top_dist);\n        } else {\n            closest_top_left = ivec2(-int(left_dist), 0);\n            closest_top_left_dist = float(left_dist);\n        }\n        \n        int max_top_left_offset = min(res.y - coord.y, min(coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_top_left_offset; offset++) {\n            ivec2 cell_offset = ivec2(-offset, offset);\n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_top = ivec2(0, int(floatBitsToUint(next_cells.r))) + cell_offset;\n            float closest_top_distance = dist(closest_top);\n\n            if (closest_top_distance < closest_top_left_dist) {\n                closest_top_left = closest_top;\n                closest_top_left_dist = closest_top_distance;\n            }\n\n            ivec2 closest_left = ivec2(-int(floatBitsToUint(next_cells.a)), 0) + cell_offset;\n            float closest_left_distance = dist(closest_left);\n\n            if (closest_left_distance < closest_top_left_dist) {\n                closest_top_left = closest_left;\n                closest_top_left_dist = closest_left_distance;\n            }\n        }\n\n        fragColor = vec4(\n            pack_2d_pos(closest_top_right),\n            pack_2d_pos(closest_bottom_right),\n            pack_2d_pos(closest_bottom_left),\n            pack_2d_pos(closest_top_left)\n        );\n\n        return;\n    }\n    \n    // for later frames we lookup the diagonal closest points and compare them to the existing closest point\n    int step_amount = int(pow(float(settings.num_samples), float(frame)));\n    int max_offset = step_amount * int(settings.num_samples);\n\n    vec4 last_closest = texelFetch(iChannel1, coord, 0);\n    \n    // top right\n    ivec2 last_top_right = unpack_2d_pos(last_closest.r);\n    float top_right_dist = dist(last_top_right);\n    int max_top_right_offset = min(min(res.y - coord.y, res.x - coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_top_right_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(1);\n        ivec2 test_top_right = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).r) + offset;\n        float test_top_right_dist = dist(test_top_right);\n\n        if (test_top_right_dist < top_right_dist) {\n            last_top_right = test_top_right;\n            top_right_dist = test_top_right_dist;\n        }\n    }\n    \n    // bottom right\n    ivec2 last_bottom_right = unpack_2d_pos(last_closest.g);\n    float bottom_right_dist = dist(last_bottom_right);\n    int max_bottom_right_offset = min(min(coord.y, res.x - coord.x), max_offset);\n    \n    for (int sample_index = step_amount; sample_index < max_bottom_right_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(1, -1);\n        ivec2 test_bottom_right = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).g) + offset;\n        float test_bottom_right_dist = dist(test_bottom_right);\n\n        if (test_bottom_right_dist < bottom_right_dist) {\n            last_bottom_right = test_bottom_right;\n            bottom_right_dist = test_bottom_right_dist;\n        }\n    }\n    \n    // bottom left\n    ivec2 last_bottom_left = unpack_2d_pos(last_closest.b);\n    float bottom_left_dist = dist(last_bottom_left);\n    int max_bottom_left_offset = min(min(coord.y, coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_bottom_left_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(-1);\n        ivec2 test_bottom_left = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).b) + offset;\n        float test_bottom_left_dist = dist(test_bottom_left);\n\n        if (test_bottom_left_dist < bottom_left_dist) {\n            last_bottom_left = test_bottom_left;\n            bottom_left_dist = test_bottom_left_dist;\n        }\n    }\n    \n    // top left\n    ivec2 last_top_left = unpack_2d_pos(last_closest.a);\n    float top_left_dist = dist(last_top_left);\n    int max_top_left_offset = min(min(res.y - coord.y, coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_top_left_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(-1, 1);\n        ivec2 test_top_left = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).a) + offset;\n        float test_top_left_dist = dist(test_top_left);\n\n        if (test_top_left_dist < top_left_dist) {\n            last_top_left = test_top_left;\n            top_left_dist = test_top_left_dist;\n        }\n    }\n\n    // store the accumulated closest point\n    fragColor = vec4(\n        pack_2d_pos(last_top_right),\n        pack_2d_pos(last_bottom_right),\n        pack_2d_pos(last_bottom_left),\n        pack_2d_pos(last_top_left)\n    );\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"const float PI = 3.14159265359;\n\n// settings - common throughout all buffers\nstruct Settings {\n    uint resolution;\n    uint num_samples;\n    uint num_frames;\n    uint total_frames;\n    uint max_value;\n};\n\nSettings get_settings(vec2 res) {\n    // the target width/height to cover\n    uint resolution = uint(ceil(max(res.x, res.y)));\n    \n    // the number of samples to take for each direction per frame\n    // optimal as a base of 2\n    uint num_samples = uint(4); // 4 = 16 samples per frame, halves the number of frames needed\n    \n    // frames needed per pass\n    uint num_frames = uint(ceil(log(float(resolution)) / log(float(num_samples))));\n    \n    // total frames needed before the map can be used\n    uint total_frames = num_frames * uint(2);\n    \n    // the maximum value to use as the default distance for no-hits\n    uint max_value = uint(ceil(sqrt(float(resolution * resolution) * 2.0)));\n\n    return Settings(\n        resolution,\n        num_samples,\n        num_frames,\n        total_frames,\n        max_value\n    );\n}\n\n// util functions\nstruct Ray {\n    vec2 pos;\n    vec2 dir;\n};\n\nstruct Line {\n    vec2 a;\n    vec2 b;\n};\n\n// some methods to package a 2 16-bit int into a single 32-bit float\nfloat pack_2d_pos(in ivec2 pos) {\n    return uintBitsToFloat(packSnorm2x16(vec2(pos) / 32767.0));\n}\n\nivec2 unpack_2d_pos(in float col) {\n    return ivec2(unpackSnorm2x16(floatBitsToUint(col)) * 32767.0);\n}\n\nfloat dist(in ivec2 a) {\n    return length(vec2(a));\n}\n\nfloat polar_angle(in vec2 a) {\n    return PI - atan(a.y, -a.x);\n}\n\nvec2 polar_position(in float radius, in float angle) {\n    return radius * vec2(cos(angle), sin(angle));\n}\n\nvec2 project(in vec2 a, in vec2 b) {\n    return dot(a, b)/dot(b, b) * b;\n}\n\nvec2 positive_project(in vec2 a, in vec2 b) {\n    return max(dot(a, b)/dot(b, b), 0.0) * b;\n}\n\nvec2 closest_point_on_ray(in Ray ray, in vec2 pos) {\n    return ray.pos + positive_project(pos - ray.pos, ray.dir);\n}\n\nfloat distance_to_ray(in Ray ray, in vec2 pos) {\n    return distance(closest_point_on_ray(ray, pos), pos);\n}\n\nvec2 closest_point_on_line(in Line line, in vec2 pos) {\n    return line.a + project(pos - line.a, line.b - line.a);\n}\n\nfloat distance_to_line_segment(in Line line, in vec2 pos) {\n    return distance(clamp(closest_point_on_line(line, pos), min(line.a, line.b), max(line.a, line.b)), pos);\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// this buffer renders buffer A when it is complete, keeping the result in the buffer until the next pass\n// only needed where the geometry is dynamic to ensure a map is available whilst being recomputed\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(floor(fragCoord));\n    Settings settings = get_settings(iResolution.xy);\n    uint frame = uint(iFrame);\n    \n    if (frame == uint(0)) {\n        fragColor = vec4(pack_2d_pos(ivec2(0)));\n        return;\n    }\n     \n    // the last frame should contain what we want to render\n    if ((frame % settings.total_frames) == (settings.total_frames - uint(1))) {\n        fragColor = texelFetch(iChannel0, coord, 0);\n        return;\n    }\n    \n    fragColor = texelFetch(iChannel1, coord, 0);\n}\n","name":"Buffer B","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lX3yD7","date":"1735172172","viewed":71,"name":"Tracing grid via nearest point","username":"mrboggieman","description":"Tracing a ray through a grid using nearest point map in each directional quadrant. Accelerates rays in fewer steps. Use mouse to plot a ray through the scene, the samples and radius are rendered.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["grid","cone","mapping","tracing","anisotropic","nearest"],"hasliked":0,"parentid":"","parentname":""}}