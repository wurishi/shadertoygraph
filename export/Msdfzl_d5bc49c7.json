{"ver":"0.1","info":{"id":"Msdfzl","date":"1526422548","viewed":243,"name":"TG:01","username":"tobySixx","description":"TG:01","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","wireframe","cubes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITERATIONS = 50;\nconst float MAX_DISTANCE = 30.0;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265359;\n\n#define AA 2   // make this 1 is your machine is too slow\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxRotated( vec3 p, mat4 m , vec3 s)\n{\n    vec3 q = vec3(transpose(m)*vec4(p, 1.0));\n    return sdBox(q, s);\n}\n\nfloat subtract( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat wireBox(vec3 p)\n{\n    float wireBox = 1000.0;\n    float boxSize = 0.5;\n    float lineSize = 0.03;\n\n    for(float i = 0.0; i<5.0; i++)\n    {\n        float angle = PI * 0.25;\n        mat4 rotationMatrix = xRotation(angle) * yRotation(angle) * translation(vec3(0.0, (i - 2.0) * 0.5 * 2.5, 0.0));\n        float outerBox = sdBoxRotated(p, rotationMatrix, vec3(boxSize));  \n        float innerBox = sdBoxRotated(p, rotationMatrix, vec3(boxSize + 0.1, boxSize - lineSize, boxSize - lineSize));\n        innerBox = min(innerBox, sdBoxRotated(p, rotationMatrix, vec3(boxSize - lineSize, boxSize + 0.1, boxSize - lineSize)));\n        innerBox = min(innerBox, sdBoxRotated(p, rotationMatrix, vec3(boxSize - lineSize, boxSize - lineSize, boxSize + 0.1)));\n        wireBox = min(wireBox, subtract(innerBox, outerBox));\n    }\n    for(float i = 0.0; i<5.0; i++)\n    {\n        float angle = PI * 0.25;\n        mat4 rotationMatrix = xRotation(angle) * yRotation(angle) * translation(vec3((i - 2.0) * 0.5 * 2.5, 0.0, 0.0));\n        float outerBox = sdBoxRotated(p, rotationMatrix, vec3(boxSize));  \n        float innerBox = sdBoxRotated(p, rotationMatrix, vec3(boxSize + 0.1, boxSize - lineSize, boxSize - lineSize));\n        innerBox = min(innerBox, sdBoxRotated(p, rotationMatrix, vec3(boxSize - lineSize, boxSize + 0.1, boxSize - lineSize)));\n        innerBox = min(innerBox, sdBoxRotated(p, rotationMatrix, vec3(boxSize - lineSize, boxSize - lineSize, boxSize + 0.1)));\n        wireBox = min(wireBox, subtract(innerBox, outerBox));\n    }\n    for(float i = 0.0; i<5.0; i++)\n    {\n        float angle = PI * 0.25;\n        mat4 rotationMatrix = xRotation(angle) * yRotation(angle) * translation(vec3(0.0, 0.0, (i - 2.0) * 0.5 * 2.5));\n        float outerBox = sdBoxRotated(p, rotationMatrix, vec3(boxSize));  \n        float innerBox = sdBoxRotated(p, rotationMatrix, vec3(boxSize + 0.1, boxSize - lineSize, boxSize - lineSize));\n        innerBox = min(innerBox, sdBoxRotated(p, rotationMatrix, vec3(boxSize - lineSize, boxSize + 0.1, boxSize - lineSize)));\n        innerBox = min(innerBox, sdBoxRotated(p, rotationMatrix, vec3(boxSize - lineSize, boxSize - lineSize, boxSize + 0.1)));\n        wireBox = min(wireBox, subtract(innerBox, outerBox));\n    }\n    \n    return wireBox;\n}\n\nfloat map(vec3 p)\n{\n    vec3 q = vec3(p.x, p.y, p.z);\n    return wireBox(q);\n}\n\nvec3 mapNormal(vec3 p)\n{\n    vec2 e = vec2(0.0, EPSILON);\n    return normalize(vec3(map(p + e.yxx) - map(p - e.yxx),\n        \t\t\t\t  map(p + e.xyx) - map(p - e.xyx),\n                          map(p + e.xxy) - map(p - e.xxy)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float cameraSize = 3.5;\n    uv *= cameraSize;\n\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 uv = (fragCoord+o)/iResolution.xy;\n        uv = uv * 2.0 - 1.0;\n        uv.x *= iResolution.x/iResolution.y;\n\n        float cameraSize = 3.5;\n        uv *= cameraSize;\n#endif\n      \n        // Ray marching vars\n        vec3 cameraOrigin = vec3(0.0, 0.0, 5.0);\n        vec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n        vec3 cameraDirection = normalize(cameraTarget - cameraOrigin);\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 cameraRight = normalize(cross(up, cameraDirection));\n        vec3 cameraUp = normalize(cross( cameraRight, cameraDirection));    \n        vec3 rayDirection = cameraDirection;\n\n        // Ray marching loop\n        vec3 p = cameraOrigin + cameraRight * uv.x + cameraUp * uv.y;\n        float d = EPSILON;\n        float totalDist = 0.0;\n        for(int i=0; i<MAX_ITERATIONS; i++)\n        {\n            if(totalDist > MAX_DISTANCE)\n            {\n                break;\n            }\n            if (d < EPSILON)\n            {\n                col += vec3(1.0, 1.0, 1.0);\n                break;\n            }\n            d = map(p);\n            totalDist += d;\n            p += rayDirection * d;\n        } \n        \n#if AA>1\n    }\n    col /= float(AA*AA);\n#endif\n    \n    // Rings\n    vec3 innerRing = vec3(1.0 - smoothstep(0.895, 0.9,length(uv * 0.284))) - vec3(1.0 - smoothstep(0.895, 0.9,length(uv * 0.287)));\n    vec3 outerRing = vec3(1.0 - smoothstep(0.895, 0.9,length(uv * 0.262))) - vec3(1.0 - smoothstep(0.895, 0.9,length(uv * 0.272)));\n    col = max(col, max(innerRing, outerRing));\n    \n    // Stripe    \n    vec3 top = vec3(step(2.4, uv.y));\n    vec3 bottom = vec3(step(2.4, -uv.y));\n    vec3 ttop = vec3(step(2.6, uv.y)) - vec3(step(2.7, uv.y));\n    vec3 bbottom = vec3(step(2.6, -uv.y)) - vec3(step(2.7, -uv.y));\n    vec3 stripe = max(max(1.0 - max(top, bottom), ttop), bbottom);\n    stripe -= vec3(1.0 - smoothstep(0.895, 0.9,length(uv * 0.25)));\n    col = max(col, stripe);\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat4 xRotation(float angle)\n{\n    mat4 m = mat4(0.0);\n    m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = 0.0;\n\tm[1][0] = 0.0; m[1][1] = cos(angle); m[1][2] = -sin(angle); m[1][3] = 0.0;\n\tm[2][0] = 0.0; m[2][1] = sin(angle); m[2][2] = cos(angle); m[2][3] = 0.0;\n    m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;\n    \n    return m;\n}\n\nmat4 yRotation(float angle)\n{\n    mat4 m = mat4(0.0);\n    m[0][0] = cos(angle); m[0][1] = 0.0; m[0][2] = sin(angle); m[0][3] = 0.0;\n\tm[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0; m[1][3] = 0.0;\n\tm[2][0] = -sin(angle); m[2][1] = 0.0; m[2][2] = cos(angle); m[2][3] = 0.0;\n    m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;\n    \n    return m;\n}\n\nmat4 zRotation(float angle)\n{\n    mat4 m = mat4(0.0);\n    m[0][0] = cos(angle); m[0][1] = -sin(angle); m[0][2] = 0.0; m[0][3] = 0.0;\n\tm[1][0] = sin(angle); m[1][1] = cos(angle); m[1][2] = 0.0; m[1][3] = 0.0;\n\tm[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = 0.0;\n    m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;\n    \n    return m;\n}\n\nmat4 translation(vec3 t)\n{\n    mat4 m = mat4(0.0);\n    m[0][0] = 1.0; m[0][1] = 0.0; m[0][2] = 0.0; m[0][3] = t.x;\n\tm[1][0] = 0.0; m[1][1] = 1.0; m[1][2] = 0.0; m[1][3] = t.y;\n\tm[2][0] = 0.0; m[2][1] = 0.0; m[2][2] = 1.0; m[2][3] = t.z;\n    m[3][0] = 0.0; m[3][1] = 0.0; m[3][2] = 0.0; m[3][3] = 1.0;\n    \n    return m; \n}\n\nvec3 rotationTranslation(vec3 p, mat4 m)\n{\n\treturn vec3(transpose(m)*vec4(p, 1.0));\n}","name":"Common","description":"","type":"common"}]}