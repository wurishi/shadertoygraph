{"ver":"0.1","info":{"id":"MXSBRG","date":"1729590581","viewed":30,"name":"SDF sphere: phong lighting","username":"Pikachuxxxx","description":"This is learning exercise to render a sphere using SDF and apply phong lighting to the rendered sphere.\n\nReferences: \n- https://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#the-raymarching-algorithm\n- https://iquilezles.org/articles/d","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    Ray ray;\n    ray.ro = vec3(0, 0, -2);\n    ray.rd = normalize(vec3(uv, 1.0f));\n    //ray.rd *= rotateY(sin(iTime) * 0.5);\n\n    float hit = RayMarch(ray);\n    \n    if(hit < MAX_STEP_DIST) {\n        // calculate hit point\n        vec3 hitPoint = ray.ro + ray.rd * hit;\n        vec3 normal = estimateNormal(hitPoint);\n        \n        \n        vec3 light_position = vec3(-5.0, 5.0, 2.0) * rotateY(sin(iTime));\n\n        float diffuse = calcDiffuse(hitPoint, light_position);\n    \n        // shade point\n        fragColor = vec4(vec3(diffuse), 1.0);\n    }\n    else\n    {\n        // background\n        vec3 col = texture(iChannel0, vec3(uv, 1.0f)).rgb;\n        fragColor = vec4(col, 1.0);\n    }\n    //fragColor = vec4(vec3(hit) / 20.0f, 1.0);\n\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////////////////\n// Constants\n#define MIN_STEP_DIST 0.01f\n#define MAX_STEP_DIST 100.0f\n#define MAX_STEPS 64\n#define EPSILON 0.01f\n////////////////////////////////////////////////////////\n// Math functions\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n////////////////////////////////////////////////////////\n// SDF functions\n\nfloat sphereSDF(vec3 p, vec3 center) \n{\n    return length(p - center) - 1.0;\n}\n\n////////////////////////////////////////////////////////\n// Scene\n\nfloat sceneSDF(vec3 viewDir)\n{\n    vec3 spherePos = vec3(0, 0, 3);\n    return sphereSDF(viewDir, spherePos);\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// Lighting\nfloat calcDiffuse(vec3 p, vec3 lightDir) \n{\n\n    // light direction\n    vec3 light_dir = normalize(lightDir - p);\n    \n    // calculate hitpoint normal (gradient of sdf at p)\n    vec3 normal = normalize(estimateNormal(p));\n    \n    // calculate diffuse contribution\n    return clamp(dot(normal, light_dir), 0.0, 1.0);\n}\n\n\n////////////////////////////////////////////////////////\n// Ray Marching\n/*\n * Function to ray march the scene\n * ro: ray origin, start point of the ray \n * rd: ray direction, direction in which the ray is pointing\n *\n * returns True if we the ray hits an object in the scene.\n */\n \n \n struct Ray\n {\n     vec3 ro;\n     vec3 rd;\n };\n \n \nfloat RayMarch(Ray ray)\n{\n    float depth = 0.0f;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ray.ro + ray.rd * depth;\n        float hitStep = sceneSDF(p);\n   \n        depth += hitStep;\n        if(depth > MAX_STEP_DIST || depth < MIN_STEP_DIST)\n            return depth;\n        \n    }\n}\n\n","name":"Common","description":"","type":"common"}]}