{"ver":"0.1","info":{"id":"4tfSRX","date":"1438290692","viewed":307,"name":"Testcard","username":"WilstonOreo","description":"There was no testcard shader yet, so I wrote my own :-)\n\nFont is from FlyGuy:\nhttps://www.shadertoy.com/view/Mt2GWD\n\nCheckboard pattern from iq:\nhttps://www.shadertoy.com/view/4dBSRK\n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["2d","test","image"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nconst float soft = 0.002;\nconst float PI = 3.14159265358979323846264;\n\nvec3 test_color = vec3(1.0,1.0,1.0);\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\n\n\nfloat circle(vec2 pos, float r)\n{\nfloat _distance = length(pos);\nfloat _v = (_distance ) / r;\nreturn 1.0 - smoothstep(1.0 - soft / r,1.0,_v); \n}\n\nfloat checkboard(vec2 pos)\n{ \nfloat id = 0.5 + 0.5*cos(iTime + sin(dot(floor(pos+0.5),vec2(113.1,17.81)))*43758.545);  \nvec2  pa = smoothstep( 0.0, 0.2, id*(0.5 + 0.5*cos(6.2831*pos)) );   \nreturn pa.x * pa.y;\n}\n\n\nfloat grid(vec2 pos)\n{\nfloat width = soft * 35.0;\npos += width * 0.5;\n\nreturn clamp(4.0 * \n    (min(smoothstep(0.0,width, mod(pos.x + 0.5,1.0)),\n    smoothstep(1.0 - width,1.0, mod(1.0 - pos.x - 0.5,1.0))) +\n    min(smoothstep(0.0,width, mod(pos.y + 0.5,1.0)),\n    smoothstep(1.0 - width,1.0, mod(1.0 - pos.y - 0.5,1.0)))),0.0,1.0);\n}\n\nvec3 palette(vec2 pos)\n{\nint index = int(clamp(pos.x*8.0,0.0,8.0));\n\n if (index == 0) return vec3(0.5,0.5,0.5);\n if (index == 1) return vec3(1.0,1.0,0.0);\n if (index == 2) return vec3(0.0,1.0,1.0);\n if (index == 3) return vec3(0.0,1.0,0.0);\n if (index == 4) return vec3(1.0,0.0,1.0);\n if (index == 5) return vec3(1.0,0.0,0.0);\n if (index == 6) return vec3(0.0,0.0,1.0);\n if (index == 7) return vec3(0.0,0.0,0.0);\n    \nreturn vec3(0.0);\n}\n\nvec3 grayscale(vec2 pos, float steps)\n{\nreturn vec3(0.3 + float(int(pos.x * steps)) / steps * float(0.7));\n}\n\nvec3 interference(vec2 pos, float steps)\n{\nfloat freq = pow((float(int(pos.x * steps)) / steps),2.0) * 100.0 * steps * PI;\n\nreturn vec3(0.5)*(1.0 + cos(pos.x * freq));\n}\n\nvec3 hueGradient(float t) {\n  vec3 p = abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);\nreturn (clamp(p - 1.0, 0.0, 1.0));\n}\n\nvec3 complementGradient(float t, vec3 color)\n{\nvec3 p = t <= 0.5 ?  \n  mix( vec3(0.0),color,t) :\n  mix( color,1.0 - color,t);\nreturn p; \n}\n\nvec3 complementGradient(vec2 pos)\n{\n  float oneThird = 1.0 / 3.0;\n    \n  if (pos.y <= oneThird) return complementGradient(pos.x,vec3(1.0,0.0,0.0));\n  if (pos.y <= 2.0 * oneThird) return complementGradient(pos.x,vec3(0.0,1.0,0.0));\n  if (pos.y <= 1.0) return complementGradient(pos.x,vec3(0.0,0.0,1.0));\n    \n  return vec3(1.0,1.0,1.0);\n}\n\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n  b = clamp(b,-1.0,24.0);\nreturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n  uv = floor(uv);\n  \n  //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n  float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n  \n  //Clipping bound to remove garbage outside the sprite's boundaries.\n  bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n  \n  float pixels = 0.0;\n  pixels += extract_bit(spr.x, bit - 72.0);\n  pixels += extract_bit(spr.y, bit - 48.0);\n  pixels += extract_bit(spr.z, bit - 24.0);\n  pixels += extract_bit(spr.w, bit - 00.0);\n  \n  return bounds ? pixels : 0.0;\n}\n\n\n#define CHAR_SIZE vec2(8.0, 12.0)\n#define CHAR_SPACING vec2(8.0, 12.0)\n#define MAX_INT_DIGITS 4\n\nvec2 print_pos = vec2(0.0);\n\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat print_char(vec4 ch, vec2 uv)\n{\n  float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n  print_pos.x += CHAR_SPACING.x;\n  return px;\n}\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n  d = floor(d);\n  \n  if(d == 0.0) return ch_0;\n  if(d == 1.0) return ch_1;\n  if(d == 2.0) return ch_2;\n  if(d == 3.0) return ch_3;\n  if(d == 4.0) return ch_4;\n  if(d == 5.0) return ch_5;\n  if(d == 6.0) return ch_6;\n  if(d == 7.0) return ch_7;\n  if(d == 8.0) return ch_8;\n  if(d == 9.0) return ch_9;\n  return vec4(0.0);\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n  float result = 0.0;\n  \nfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n  {\n      float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n      if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n      {\n        result += print_char(get_digit(digit),uv);\n      }\n  }   \n  return result;\n}\n\n\nvec3 text(vec2 pos) \n{\n\npos *= CHAR_SIZE;\npos.x *= CHAR_SIZE.x * 2.0;\npos.x -= CHAR_SIZE.x*2.0;\npos.y += 12.0; \nfloat col = 0.0;\ncol += print_char(ch_T,pos);\ncol += print_char(ch_e,pos);\ncol += print_char(ch_s,pos);\ncol += print_char(ch_t,pos);\npos.x -= CHAR_SIZE.x*1.0;\ncol += print_char(ch_C,pos);\ncol += print_char(ch_a,pos);\ncol += print_char(ch_r,pos);\ncol += print_char(ch_d,pos);\npos.x -= CHAR_SIZE.x*1.0;\ncol += print_integer(mod(iTime,100.0),2,pos);\nreturn vec3(col);\n}\n\nvec3 testcard(vec2 pos)\n{\nvec2 gridPos = pos* 8.0 - 0.5;\nvec3 g = vec3(grid(gridPos)) + test_color * checkboard(gridPos);\n\nif (abs(gridPos.x + 0.5) <= 5.99)\n{\n  float x = (gridPos.x + 0.5) / 12.0 + 0.5;\n  float y = gridPos.y + 0.5;\n  vec2 v = vec2(x,y);\n  if (y <= 4.99 && y >= 2.01) \n    g = palette(v);\n  if (y <= 1.99 && y >= 0.01) \n    g = grayscale(v,5.0);\n  if (y <= -0.01 && y >= -1.99) \n    g = text(v);\n\n  if (y <= -1.01 && y >= -1.99)\n    g = interference(v,10.0);\n  if (y <= -2.01 && y >= -2.99)\n    g = hueGradient(v.x);\n  if (y <= -3.01 && y >= -4.99) // Red complement \n    g = complementGradient((v + vec2(0.0,5.0))/vec2(1.0,2.0));\n}\n\ng += clamp(circle(pos,10.0 / 12.0) - circle(pos,10.0 / 12.0 - 0.005),0.0,1.0);\n\n\nreturn g;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\nvec2 pos = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    fragColor = vec4(testcard(pos),1.0);\n}","name":"","description":"","type":"image"}]}