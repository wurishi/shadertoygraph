{"ver":"0.1","info":{"id":"McXyzj","date":"1721403901","viewed":43,"name":"cmyk sweep halftone","username":"HaleyHalcyon","description":"aaaa","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["aaaaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HEX(x) (vec3((x >> 16) & 255, (x >> 8) & 255, x & 255) / 255.)\n#define ROT(x) mat2x2(cos(x), sin(x), sin(x), -cos(x))\nconst float TURN = 2. * acos(-1.);\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 1;\n    return float((xy.x ^ xy.y) * 2 + xy.y)/ 4.;\n}\n\n// takes in RGB, inverts to (pseudo-) CMYK colors\nvec3 colormap(vec3 rgb) {\n    const vec3 c000 = HEX(0xffffff);\n    const vec3 c001 = HEX(0x009be8);\n    const vec3 c011 = HEX(0x540abd);\n    const vec3 c010 = HEX(0xeb0072);\n    const vec3 c110 = HEX(0xd96b07);\n    const vec3 c100 = HEX(0xfff100);\n    const vec3 c101 = HEX(0x27b92d);\n    const vec3 c111 = HEX(0x010a31);\n    \n    vec3 c00x = mix(c000, c001, rgb.r);\n    vec3 c01x = mix(c010, c011, rgb.r);\n    vec3 c10x = mix(c100, c101, rgb.r);\n    vec3 c11x = mix(c110, c111, rgb.r);\n    \n    vec3 c0xx = mix(c00x, c01x, rgb.g);\n    vec3 c1xx = mix(c10x, c11x, rgb.g);\n    \n    return mix(c0xx, c1xx, rgb.b);\n}\n\nfloat dotgrid(vec2 uv, float angle, float t) {\n    uv *= ROT(angle);\n    \n    float r = length(fract(uv * 12. + 0.5) - 0.5);\n    return smoothstep(\n        -0.01, 0.01,\n        0.2 - r - 0.5 * cos((\n            min(fract(t) * 2.0, 1.0) +\n            0.2 * uv.x\n        ) * TURN)\n    );\n}\n\n// The time multiplier. 1x will cause it to loop once every second!\n#define SPEED 1./32.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * SPEED;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    const float rotation = -1. * TURN / 36.;\n    \n    vec3 rgb = vec3(\n        dotgrid(uv, rotation, t),\n        dotgrid(uv, rotation + 0.4 * TURN, t + 0.75),\n        dotgrid(uv, rotation + 0.1 * TURN, t + 0.5)\n    );\n    rgb += vec3(\n        dotgrid(uv, rotation + 0.7 * TURN, t + 0.25)\n    );\n    \n    rgb = clamp(rgb, 0., 1.);\n    \n    // crosshatching\n    /*\n    const float steps = 2.;\n    float thres = 1.0 - (\n    crosshatch(fragCoord) +\n    crosshatch(fragCoord / 2.) / 4. +\n    crosshatch(fragCoord / 4.) / 16.+\n    crosshatch(fragCoord / 8.) / 64.);\n    //v = fract(uv.x + 0.5); // crosshatch patterntest \n    rgb = clamp(\n    (floor(steps * rgb) + step(thres, fract(steps * rgb))) / steps\n    , vec3(0.), vec3(1.));\n    */\n    vec3 col = colormap(\n        rgb\n    );\n    \n    // masking where the center graphic will be\n    //col = mix(col, HEX(0x800030), step(uv.y*uv.y + uv.x*uv.x, 0.2));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}