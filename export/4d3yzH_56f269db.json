{"ver":"0.1","info":{"id":"4d3yzH","date":"1518120216","viewed":111,"name":"Tri-Colored Cube","username":"kMiller","description":"Hw for procedural graphics class","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","gif"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec4 blue = vec4(81.0 / 255.0, 65.0 / 255.0, 96.0 / 255.0, 1.0);\nconst vec4 green = vec4(169.0 / 255.0, 216.0 / 255.0, 190.0 / 255.0, 1.0);\nconst vec4 pink = vec4(232.0 / 255.0, 78.0 / 255.0, 128.0 / 255.0, 1.0);\nvec2 box( in vec3 pos );\nconst vec4[3] colors = vec4[](pink, blue, green);\n\nvec2 sceneSDF(vec3 pos) {\n    vec3 b = vec3(.4, .4, .4);\n\tfloat timeInt = mod(iTime * 1.3, 12.0);\n\tif (timeInt > 5.0 && timeInt < 6.0) { // rotate cube about Y\n        // rotate box\n      \tfloat c = cos(radians(timeInt - 5.0) * -90.0);\n        float s = sin(radians(timeInt - 5.0) * -90.0);\n        pos = vec3(pos.x * c - pos.z * s, pos.y, pos.x * s + pos.z * c);      \n    } else if (timeInt > 11.0 && timeInt < 12.0) { // rotate cube\n\t\tfloat c = cos(radians(timeInt - 5.0) * 90.0);\n        float s = sin(radians(timeInt - 5.0) * 90.0);\n        pos = vec3(pos.x * c + pos.y * s, pos.x * s - pos.y * c, pos.z);\n    }\n    return vec2(length(max(abs(pos) - b, 0.0)),0.0);\n}\n\nvec3 getNormal(vec3 pos) {\n    vec2 e = vec2(0.0, .01);\n    return normalize( vec3(sceneSDF(pos + e.yxx).x - sceneSDF(pos - e.yxx).x,\n                            sceneSDF(pos + e.xyx).x - sceneSDF(pos - e.xyx).x,\n                            sceneSDF(pos + e.xxy).x - sceneSDF(pos - e.xxy).x));\n}\n\nvec2 box( in vec3 pos)\n{\n    vec3 b = vec3(.4, .4, .4);\n    return vec2(length(max(abs(pos) - b, 0.0)),0.0);\n}\n\n\nvec2 raymarch(in vec3 origin, in vec3 dir)\n{\n    vec2 dist;\n    float dt = 0.01;\n    float t = 0.01;\n    \n    for(int i = 0; i < 200; i++)\n    {\n        dist = sceneSDF(origin + t * dir);\n\n        if(dist.x < 0.001)\n        {\n            return vec2(t, dist.y);\n        }\n        else if (t >100.0)\n        {\n            break;\n        }\n        \n        t += dist.x;\n    }\n    return vec2(-1.0, 0.0);\n}\n\nvec3 rayCast(vec2 pixel, vec3 origin)\n{\n    vec3 ref = vec3(0.0, 0.0, 0.0);\n    vec3 camLook = normalize(ref - origin);\n    vec3 camRight = normalize(cross(camLook, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = ref + pixel.x * camRight + pixel.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 scrPt = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 cameraPos = vec3(4, 4, 4);\n    vec3 rayDir = rayCast(scrPt, cameraPos);\n\tvec2 box = raymarch(cameraPos, rayDir);\n    float t = box.x;\n    float color = box.y;\n    vec3 point = cameraPos + rayDir * t;\n    \n    if (t > 0.0) // hit\n    {\n        vec3 normal = getNormal(point);\n        float theta = mod(atan(scrPt.y, scrPt.x) + 2.0 * 3.14159, 2.0 * 3.14159);\n        float timeInt = mod(iTime * 1.3, 12.0);\n        bool useTheta = false;\n        bool useTheta2 = false;\n        if(timeInt < 2.0) {\n           useTheta = true;\n        } else if (timeInt < 3.0) { // rotate color clockwise\n            theta += (timeInt - 2.0) * radians(120.0);\n           \tuseTheta = true; \n        } else if (timeInt < 5.0) { // do nothing, hold angle\n            theta += radians(120.0);\n            useTheta = true;\n        } else if (timeInt < 8.0) { // rotate cube\n\t\t\t// determine color based on normal\n        \t// this will be index in color array to go to\n        \tif(abs(normal.z) >= .9) {\n            \tfragColor = pink;\n        \t} else if (normal.x >= .9) {\n            \tfragColor = blue;\n        \t} else {\n\t\t\t\tfragColor = green;\n        \t}\n        } else if (timeInt < 9.0) { // rotate color\n\t\t\ttheta -= (timeInt - 2.0) * radians(120.0);  \n        \tuseTheta2 = true;\n        } else if(timeInt < 11.0){ // do nothing, hold color angle\n\t\t\ttheta -= radians(120.0);\n            useTheta2 = true;\n        } else if (timeInt < 12.0) { // rotate cube\n\t\t\t// determine color based on normal\n        \t// this will be index in color array to go to\n        \tif(abs(normal.z) >= .8) {\n            \tfragColor = green;\n        \t} else if (normal.x >= .8) {\n            \tfragColor = blue;\n        \t} else {\n\t\t\t\tfragColor = pink;\n        \t}\n\n        }\n        \n        if(useTheta) {\n        \ttheta = mod(theta, 2.0 * 3.14159);\n        \tif(theta > radians(30.0) && theta < radians(150.0)) {// top\n\t\t\t\tfragColor = blue;\n       \t \t} else if(theta < radians(270.0) && theta > radians(150.0)) {// left\n\t\t\t\tfragColor = green;\n        \t} else { // right\n\t\t\t\tfragColor = pink;\n        \t}\n        } else if (useTheta2) { // inverse orientation of colors\n            theta = mod(theta, 2.0 * 3.14159);\n\t\t\tif(theta > radians(30.0) && theta < radians(150.0)) {// top\n\t\t\t\tfragColor = green;\n       \t \t} else if(theta < radians(270.0) && theta > radians(150.0)) {// left\n\t\t\t\tfragColor = blue;\n        \t} else { // right\n\t\t\t\tfragColor = pink;\n        \t}  \n        }\n    }\n    else // miss\n    {\n        fragColor = vec4(1);\n    }\n}","name":"Image","description":"","type":"image"}]}