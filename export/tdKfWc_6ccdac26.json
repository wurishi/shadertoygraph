{"ver":"0.1","info":{"id":"tdKfWc","date":"1608250500","viewed":64,"name":"Understanding Ray Marching","username":"Dudeguy18","description":"Made to help understand Ray Marching\n\n - The Art of Code (https://www.youtube.com/watch?v=PGtv-dBi2wE)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This was made to help me understand basic \n// ray marching techniques.\n\n\n#define MAX_STEPS 60\n#define MAX_DIST 50.0\n#define SURF_DIST 0.001\n\n\n\n// -----------------------------------------------------------------------------------------------\n// Calculates Random Number\nfloat hash(vec2 p){\n    p = fract(p * vec2(125.76, 473.82));\n    p += dot(p, p + 86.12);\n    return fract(p.x * p.y);\n}\n\n// Perlin Noise\nfloat noise (vec2 st) {\n    vec2 i = floor(st); // Index\n    vec2 f = fract(st); // Fraction\n\n    // Four corners in 2D of a tile\n    float a = hash(i + vec2(0.0, 0.0));\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Calculate value to interpolate between corners\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    // Interpolate\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Fractal Brownian Motion\nfloat fbm(vec2 x, float amplitude, float frequency, float lacunarity, float gain, int iterations){\n\n    float y = 0.0;\n    \n    mat2 rot = mat2(cos(0.87), sin(0.87), -sin(0.87), cos(0.87));\n    for(int i=0; i < iterations; i++){\n\n        y += amplitude * noise(x * frequency); // Calculate Noise Layer\n        x *= rot;                              // rotate next iteration\n        frequency *= lacunarity;               // adjust lacunarity for next iteration\n        amplitude *= gain;                     // adjust gain for next iteration\n    }\n    \n\n    return y;\n}\n// -----------------------------------------------------------------------------------------------\n\n\n\n\n// -----------------------------------------------------------------------------------------------\n// Signed Distance Functions (https://iquilezles.org/articles/distfunctions)\nfloat sdPlane( vec3 p, vec3 n, float h ){\n  return dot(p,n) - h;\n}\nfloat sdSphere( vec3 p, float radius){\n    return length(p)-radius;\n}\nfloat sdSphereFun( vec3 p, float radius, vec2 uv){\n\n    // Playing around\n    float scale = 3.0;\n    float lacunarity = 1.21;\n    float gain = 0.388;\n    float t = iTime * 0.5;\n    \n    float up = fbm(uv + vec2(0.0, -t), 0.5, scale, lacunarity, gain, 10);\n    \n    radius += fbm(uv + 4.0*up, 0.5, scale, lacunarity, gain, 10);\n\n    return length(p)-radius;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h ){\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n// Returns shortest distance from vector p to any part of the scene\nfloat getDist(vec3 p, vec2 uv){\n\n    // Plane\n    vec3 planePos = vec3(0.0, 1.0, 0.0);\n    float planeHeight = 0.0;\n    \n    // Sphere1\n    vec3 sphere1Pos = vec3(-4.0, 2.2, 0.0);\n    float sphere1Width = 1.0;\n    \n    // Sphere2\n    vec3 sphere2Pos = vec3(0.0, 2.2, 0.0);\n    float sphere2Width = 1.0;\n    \n    // Rounded Cylinder\n    vec4 rCylinderPos = vec4(4.0, 2.2, 0.0, 1.0);\n    vec2 rCylinder = vec2(0.5, 0.4);\n    \n    \n    \n    // Calculate distance to all objects\n    float planeDist = sdPlane(p - planePos, normalize(planePos), planeHeight);\n    planeDist = p.y;\n    float sphere1Dist = sdSphere(p - sphere1Pos, sphere1Width);\n    float sphere2Dist = sdSphereFun(p - sphere2Pos, sphere2Width, uv);\n    float rCylinderDist = sdRoundedCylinder(p - rCylinderPos.xyz, rCylinder.x, rCylinder.y, rCylinderPos.w);\n    \n    // Calculate closest scene distance\n    float d = min(min(min(sphere1Dist,sphere2Dist), planeDist), rCylinderDist);\n \n    return d;\n}\n\n\n// Ray Marching\nfloat rayMarch(vec3 rayOrigin, vec3 rayDirection, vec2 uv){\n    \n    float originDistance = 0.0;\n    float sceneDistance = 0.0;\n    vec3 p = vec3(0.0);\n    \n    for(int i=0; i < MAX_STEPS; i++){\n        // p = current marching distance\n        p = rayOrigin + rayDirection * originDistance;\n        sceneDistance = getDist(p, uv);\n        originDistance += sceneDistance;\n        \n        if(originDistance > MAX_DIST || sceneDistance < SURF_DIST * 1.85 * (1.0 + originDistance)){\n            break;\n        }\n    \n    }\n    \n    return originDistance;\n}\n// -----------------------------------------------------------------------------------------------\n\n\n\n// -----------------------------------------------------------------------------------------------\n// Lighting\n\nvec3 getNormal(vec3 p, vec2 uv){\n    float d = getDist(p, uv);\n    \n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy, uv),\n        getDist(p-e.yxy, uv),\n        getDist(p-e.yyx, uv));\n       \n    \n    return normalize(n);\n}\n// -----------------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Basic Setup\n    vec3 col = vec3(0.0);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    // ------------------------------------------------------\n\n\n\n    // Camera\n    vec3 cameraPos = vec3(0.0, 6.0, -10.0);\n    vec3 cameraDir = vec3(0.0, -0.4, 0.0);\n    // ------------------------------------------------------\n    \n    \n    \n    // Ray Marching\n    vec3 rayOrigin = cameraPos;\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1.0) + cameraDir);\n    float distToScene = rayMarch(rayOrigin, rayDirection, uv);\n    \n    // Calculate Ray Destination Point\n    vec3 rayPoint = rayOrigin + rayDirection * distToScene;\n    // ------------------------------------------------------\n    \n    \n    \n    \n    // Light1\n    vec3 lightPos = vec3(0.0, 10.0, 0.0);\n    vec3 ambientColor = vec3(0.2, 0.2, 0.3);\n    vec3 diffuseColor = vec3(0.5, 0.5, 0.6);\n    vec3 specularColor = vec3(0.8, 0.8, 0.9);\n    float radius = 15.0;\n    float shininess = 10.0;\n    \n    // Move Light\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\n    \n    // Lighting\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 toLight = normalize(lightPos - rayPoint);\n    vec3 surfaceNormal = getNormal(rayPoint, uv);\n    \n    // Attenuation\n    float lightDist = length(lightPos - rayPoint);\n    float attenuation = clamp(1.0 - lightDist / radius, 0.0, 1.0);\n    \n    // Ambient\n    ambient += ambientColor;\n    \n    // Shadows - Calculate if ray destination point is in shadow or not\n    float toLightDist = rayMarch(rayPoint + surfaceNormal * SURF_DIST * 2.0, toLight, uv);\n    \n    // Shadow Test\n    if(toLightDist >= lightDist){\n    \n        // Diffuse\n        float difAngle = max(dot(surfaceNormal, toLight), 0.0);\n        diffuse += difAngle * diffuseColor * attenuation;\n        \n        // Specular - Blinn-Phong\n        vec3 toCamera = rayDirection;\n        vec3 half_way = normalize(toLight - toCamera);\n        float specAngle = pow(max(dot(surfaceNormal, half_way), 0.0), shininess);\n        specular += specAngle * specularColor * attenuation;\n        \n    }\n    // ------------------------------------------------------\n\n\n    // Calculate Frag Color\n    fragColor = vec4(ambient + diffuse + specular,1.0);\n    // ------------------------------------------------------\n}","name":"Image","description":"","type":"image"}]}