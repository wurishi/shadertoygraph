{"ver":"0.1","info":{"id":"XlXXW8","date":"1436857973","viewed":453,"name":"Night road v1","username":"Maurogik","description":"A simple raymarched scene complete with lighting, shadowing and light emission from light bulbs.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","light","stars","night"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//90Â° FOV\n#define FOCAL_LENGTH 1.0 \n#define MOVE_CAMERA 0.75\n#define MOVE_SPEED 5.0\n#define FX_SPEED 1000.0\n#define MAX_STEPS 512\n#define MIN_DIST 0.01\n#define MAX_DIST 110.0\n#define FOG_STR 1.0\n#define GRADIENT_OFFSET 0.1\n#define AMBIANT_LIGHT 0.05\n#define Z_REPEAT 10.0\n\n//scene data\nvec3 projectionUp;\nvec3 projectionRight;\nvec3 projectionForward;\nvec3 projectionCenter;\nvec3 cameraOffset;\nvec3 lightPos;\nvec3 skyColor;\nvec2 fragUV;\n\nfloat sqrLen(vec3 vec)\n{\n \treturn vec.x * vec.x + vec.y * vec.y + vec.z * vec.z;\n}\n\nvec3 lerp(vec3 from, vec3 to, float progress)\n{\n    return from * (1.0 - progress) + to * progress;\n}\n\nvec2 pixelToNormalizedspace(vec2 pixel)\n{\n    vec2 res;\n    res.x = pixel.x * 2.0 / iResolution.x - 1.0;\n    res.y = pixel.y * 2.0 / iResolution.y - 1.0;\n    res.y *= iResolution.y / iResolution.x;//correct aspect ratio\n    return res;\n}\n\nvec3 fragCoordToProjectionPlane(vec2 fragUv)\n{\n\tvec2 uv = pixelToNormalizedspace(fragUv);\n    return projectionCenter + projectionRight * uv.x + projectionUp * uv.y;\n}\n\n//project a direction onto the original (without rotation) projection plane\n//to get world space uv\nvec2 dirToWorldSpacedUV(vec3 dir)\n{\n    dir= normalize(dir);\n    vec3 projRight \t= vec3(1.0, 0.0, 0.0);\n    vec3 projUp \t= vec3(0.0, 1.0, 0.0);\n    vec3 projForw\t= vec3(0.0, 0.0, 1.0);\n\n    float u = dot(dir, projRight) / dot(projRight, projRight);\n    float v = dot(dir, projUp) / dot(projUp, projUp);\n    return vec2(u, v);\n}\n\nvec2 worldToProjectionPlane(vec3 point)\n{\n    vec4 camStart = vec4(projectionCenter + cameraOffset, 1.0);\n    vec4 camToPoint = vec4(normalize(point - camStart.xyz), 0.0);\n    vec4 projectionPlane = vec4(projectionForward, -FOCAL_LENGTH);\n    float intersectDist = dot(projectionPlane, camStart) / dot(projectionPlane, camToPoint);\n    vec3 pointOnPlane = camStart.xyz + camToPoint.xyz * intersectDist;\n    float u = dot(pointOnPlane, projectionRight) / dot(projectionRight, projectionRight);\n    float v = dot(pointOnPlane, projectionUp) / dot(projectionUp, projectionUp);\n    return vec2(u, v);\n}\n\n//Create a shape by removing shape2 from shape1\nfloat subtractField(float df1, float df2)\n{\n    return max(df1, -df2);\n}\n\n//get distance to a cylinder\nfloat cylinderDist(vec3 center, vec2 dimension, vec3 point)\n{\n  \tvec3 p = point - center;   \n  \tvec2 d = abs(vec2(length(p.xz), p.y)) - dimension;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n//get distance to an AA box\nfloat AABox(vec3 pmin, vec3 pmax, vec3 point)\n{\n\tfloat dx = max(0.0, max(pmin.x - point.x, point.x - pmax.x));\n    float dy = max(0.0, max(pmin.y - point.y, point.y - pmax.y));\n    float dz = max(0.0, max(pmin.z - point.z, point.z - pmax.z));\n    return sqrt(dx*dx + dy*dy + dz*dz);    \n}\n\n//get distance to surface of a sphere\nfloat sphereDist(vec4 sphere, vec3 point)\n{\n    return length(point - sphere.xyz) - sphere.w;\n}\n\n//get distance to surface of a plane\nfloat planeDist(vec4 plane, vec3 point)\n{\n    \n\treturn abs(dot(plane, vec4(point, 1.0)));\n}\n\n\n//Pack a plane as a [normal, distToOrigin] vector\nvec4 createPlane(vec3 normal, float dist)\n{\n\treturn vec4(normalize(normal), dist);\n}\n\n//Pack a sphere as a [center, radius] vector\nvec4 createSphere(vec3 pos, float radius)\n{\n \treturn vec4(pos, radius);   \n}\n\nvec3 cylinderPos\t= vec3(3.0, 1.0, 3.0);\nvec2 cylinderSize\t= vec2(0.1, 2.0);\nvec4 plane;\nvec4 sphere;\nvec3 roadPt1  \t\t= vec3(1.25, -0.95, 0.0) - vec3(2.5, 0.05, 20.0) * 0.5;\nvec3 roadPt2\t\t= vec3(1.25, -0.95, 0.0) + vec3(2.5, 0.05, 20.0) * 0.5;\nvec3 groundColor \t= vec3(0.3);\nvec3 poleColor\t\t= vec3(0.25);\nvec3 lampColor \t\t= vec3(5.0, 5.0, 5.0);\nvec3 roadColor\t\t= vec3(0.1);\n\nfloat calcColorWeight(float dist, float minDist)\n{\n    return clamp(1.0 - (dist / minDist - 1.0), 0.0, 1.0);\n}\n\nvec3 domainMod(vec3 point){\n    vec3 moddedPoint\t= point;\n    moddedPoint.x \t\t= abs(point.x); //symmetry\n    moddedPoint.z \t\t= mod(point.z, Z_REPEAT);\n    return moddedPoint;\n}\n\n//get distance and color to nearest surface\nvec4 colorDistanceField(vec3 point)\n{   \n    vec3 moddedPoint\t= domainMod(point);\n    \n    float roadDist\t\t= AABox(roadPt1, roadPt2, moddedPoint);\n    float distSphere \t= sphereDist(sphere, moddedPoint);\n    float distCylinder \t= cylinderDist(cylinderPos, cylinderSize, moddedPoint);\n    float distPlane\t\t= planeDist(plane, point);\n    float minDist\t\t= MAX_DIST;\n    minDist \t\t\t= min(distSphere, distCylinder);    \n    minDist \t\t\t= min(minDist, distPlane);\n    minDist \t\t\t= min(minDist, roadDist);\n        \n    //blend colors\n    vec3 color = vec3(0.0);\n    color += calcColorWeight(roadDist, minDist) \t* roadColor;\n    color += calcColorWeight(distSphere, minDist) \t* lampColor;\n    color += calcColorWeight(distCylinder, minDist) * poleColor;\n    color += calcColorWeight(distPlane, minDist) \t* groundColor;\n    \n\treturn vec4(color, minDist);\n}\n\n//get distance to nearest surface\nfloat distanceField(vec3 point)\n{   \n    vec3 moddedPoint = domainMod(point);\n    \n    float roadDist\t\t= AABox(roadPt1, roadPt2, moddedPoint);\n    float distSphere \t= sphereDist(sphere, moddedPoint);\n    float distCylinder \t= cylinderDist(cylinderPos, cylinderSize, moddedPoint);\n    float distPlane\t\t= planeDist(plane, point);\n    float minDist\t\t= MAX_DIST;\n    minDist \t\t\t= min(distSphere, distCylinder);    \n    minDist \t\t\t= min(minDist, distPlane);\n    minDist \t\t\t= min(minDist, roadDist);\n   \treturn minDist;\n}\n\n//get uv for road teture from a world point on a road tile\nvec2 pointToRoadUV(vec3 point){ \n    float y =  mod(point.z * 2.0, Z_REPEAT) / Z_REPEAT;\n    float x = (point.x - roadPt1.x) / (roadPt2.x - roadPt1.x);\n    return vec2(x, y);\n}\n\n//raymarch with atmospheric accumulation of color at sampling points\nvec4 rmAtmosphere(vec3 rayStart, vec3 rayDir, float minDist)\n{\n    float totalDist = minDist;\n    float dist;\n    vec3 color = vec3(0.0);\n    float stepBias;\n    vec3 atmColor;\n    vec4 dfRes;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {   \n        stepBias = max(0.5, float(i) / float(MAX_STEPS));//to avoid artefacts\n        dfRes = colorDistanceField(rayStart + rayDir * totalDist);\n        dist = dfRes.w;        \n        totalDist += dist * stepBias;\n        \n        if(dist <= MIN_DIST * stepBias)\n        {\n            atmColor = dfRes.xyz;\n            color = lerp(color, skyColor, pow(totalDist / MAX_DIST, 1.0 / FOG_STR));            \n        \treturn vec4((color + atmColor), totalDist);   \n        }\n        \n        if(totalDist >= MAX_DIST)\n        {\n            return vec4(color + skyColor, MAX_DIST);  \n        }                       \n        //color accumulation while raymarching to add emission FX\n        atmColor = dfRes.xyz;\n        color += (clamp(atmColor - vec3(1.0), vec3(0.0), vec3(3.0)) * max(1.5 - dist, 0.0)) / (totalDist * totalDist);    \n    }      \n        \n    return vec4(color + skyColor, totalDist);    \n}\n\n//simple distance raymarching\nfloat rmDist(vec3 rayStart, vec3 rayDir, float minDist)\n{\n    float totalDist = minDist;\n    float dist;\n    float stepBias;\n    \n    for(int i = 0; i < MAX_STEPS; ++i)\n    {   \n        stepBias = 1.0;\n        dist = distanceField(rayStart + rayDir * totalDist);\n        totalDist += dist * stepBias;\n        if(dist <= MIN_DIST)\n        {\n            return totalDist;\n        }\n        \n        if(totalDist >= MAX_DIST)\n        {\n            return MAX_DIST;  \n        }        \n    }      \n        \n    return totalDist;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    plane\t \t\t= createPlane(vec3(0.0, 1.0, 0.0), 1.0);\n\tsphere \t\t= createSphere(vec3(3.0, 3.0, 3.0), 0.3);\n    \n    fragUV = fragCoord;      \n\n    //Do camera setup from mouse coord\n    projectionCenter \t= vec3(0.0, 0.2, mod(MOVE_SPEED * iTime, 10.0));\n    projectionForward \t= vec3(0.0, 0.0, 1.0);\n    projectionUp \t\t= vec3(0.0, 1.0, 0.0);\n    projectionRight \t= vec3(1.0, 0.0, 0.0);        \n    vec3 mouseProj\t\t= (fragCoordToProjectionPlane(iMouse.xy));\n    cameraOffset\t\t= normalize(vec3(-mouseProj.x * MOVE_CAMERA, -mouseProj.y * MOVE_CAMERA, -1.0)) * FOCAL_LENGTH;\n    \n    //reproject the camera plane\n    projectionForward \t= normalize(-cameraOffset);\n    projectionUp \t\t= vec3(0.0, 1.0, 0.0);\n    projectionRight \t= cross(projectionUp, projectionForward);\n    projectionUp \t\t= cross(projectionForward, projectionRight);  \n    \n    lightPos\t\t\t= projectionCenter + cameraOffset + vec3(0.0, 3.0, 1.5);  \n            \n    //setup ray\n    vec3 rayPos \t\t\t\t= projectionCenter + cameraOffset;\n    vec3 pointOnProjectionPlane = fragCoordToProjectionPlane(fragCoord);\n    vec3 rayDirection \t\t\t= normalize(pointOnProjectionPlane - rayPos);\n    \n    //sky and stars\n    vec2 skyUV \t= dirToWorldSpacedUV(rayDirection) * 1.5;\n    vec3 stars \t= texture(iChannel0, skyUV).xyz;\n    stars      \t*= pow(sqrLen(stars) * 0.45, 10.0) * 0.5;\n    float skyDarkness\t= pow(abs(rayDirection.y) * 1.5, 0.5);\n    skyColor \t= lerp(\n          vec3(0.1, 0.1, 0.3)\n        , vec3(0.005, 0.005, 0.01) + stars * skyDarkness\n        , skyDarkness);    \n    \n    //march ray\n    vec4 rayMarchResult \t= rmAtmosphere(rayPos, rayDirection, 0.0);    \n    float dist \t\t\t\t= rayMarchResult.w;\n    float distAttenuation \t= pow(1.0 - dist/MAX_DIST * 0.8, 1.0);   \n    vec4 surfaceColor \t\t= vec4(rayMarchResult.xyz, 1.0);\n\n    if(dist < MAX_DIST && sqrLen(rayMarchResult.xyz) < 2.0)//to avoid shadowing the sky\n    {\n        vec3 endPoint \t\t= rayPos + rayDirection * (dist);\n        vec3 pointToLight \t= normalize(lightPos - endPoint);\n        \n        //add headlights\n        vec3 headlightPoint = endPoint;\n        headlightPoint.x \t= abs(headlightPoint.x * 3.5);\n        vec3 headlightDiff \t= projectionCenter + vec3(4.0, -0.5, -1.5) - headlightPoint; \n        headlightDiff.z \t*= 0.75;\n        float headlight \t= clamp(40.0 / sqrLen(headlightDiff), 0.0, 100.0);        \n        \n        //normal computation\n        float g1 = distanceField(endPoint + vec3(GRADIENT_OFFSET, 0.0, 0.0))\n            - distanceField(endPoint + vec3(-GRADIENT_OFFSET, 0.0, 0.0));\n        float g2 = distanceField(endPoint + vec3(0.0, GRADIENT_OFFSET, 0.0))\n            - distanceField(endPoint + vec3(0.0, -GRADIENT_OFFSET, 0.0));\n        float g3 = distanceField(endPoint + vec3(0.0, 0.0, GRADIENT_OFFSET))\n            - distanceField(endPoint + vec3(0.0, 0.0, -GRADIENT_OFFSET));\n        vec3 normal = normalize(vec3(g1, g2, g3));\n        \n        //road normal from texture\n        vec2 normalUV = pointToRoadUV(endPoint);\n        normal += texture(iChannel0, normalUV).xyz \n            * (1.0 - clamp(AABox(roadPt1, roadPt2, domainMod(endPoint)) * 5.0, 0.0, 1.0)) * 0.5;\n        normal = normalize(normal);\n        \n        //dist to lamps\n        float lampLight = min(pow(22.0 / sqrLen(domainMod(endPoint + normal * 0.1) - sphere.xyz), 20.0), 3.0);\n        lampLight /= 3.0;\n        \n        //lighting    \n        float spec = pow(clamp(dot(normalize(-rayDirection + pointToLight), normal), 0.0, 1.0), 16.0);\n        float ambiant = (AMBIANT_LIGHT * distAttenuation + lampLight) * pow(distAttenuation, 2.0);\n        surfaceColor = surfaceColor * ambiant \n            + surfaceColor * max(0.0, dot(normal, pointToLight) * headlight)\n            + vec4(0.8) * spec * headlight;\n        \n\t    //check for shadow casting        \n        float shadowDist \t= rmDist(endPoint + normal * 0.01, pointToLight, 0.0);    \n    \tfloat shadow\t\t\t= 1.0 - (shadowDist / MAX_DIST);\n        shadow\t\t\t\t\t= clamp(shadow - lampLight * 0.3, 0.0, 1.0);\n    \tfloat lightIntensity \t= 1.0 - pow(shadow, 4.0);\n \t   \tsurfaceColor \t\t\t*= lightIntensity;     \n    }\n    \n    fragColor = surfaceColor;\n}\n","name":"Image","description":"","type":"image"}]}