{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"vec3 rotateY(vec3 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);\n}\n\nfloat fresnel(float cosTheta, float F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 bumpMapping(vec3 N, vec2 uv) {\n    float bumpScale = 0.05;\n    float noise = sin(uv.x * 50.0) * sin(uv.y * 50.0) * \n                 sin((uv.x + uv.y) * 25.0 + iTime * 0.5);\n    return normalize(N + vec3(noise * bumpScale));\n}\n\nvec3 envMap(vec3 R) {\n    return texture(iChannel1, R).xyz;\n}\n\n// Combined sphere processing function\nvec3 processSphere(vec2 uv, vec2 center, float radius, float angle, vec3 lightPos, vec3 viewPos, \n                  bool isLeft, float W1[H1*I], float b1[H1], float W2[O*H1], float b2[O]) {\n    vec2 uvLocal = uv - center;\n    float r = length(uvLocal);\n    if (r > radius) return vec3(0.0);\n    \n    float z = sqrt(radius * radius - r * r);\n    vec3 pos = vec3(uvLocal, z);\n    vec3 N = normalize(pos);\n    vec3 RN = rotateY(N, angle);\n    N = bumpMapping(RN, uvLocal);\n    \n    // Lighting vectors\n    vec3 L = normalize(lightPos - pos);\n    vec3 V = normalize(viewPos - pos);\n    vec3 H = normalize(L + V);\n    vec3 R = reflect(-V, N);\n    \n    // Material properties\n    vec3 baseColor = isLeft ? groundTruth(RN) : mlpPredict(RN, W1, b1, W2, b2);\n    float roughness = 0.75;\n    float F0 = 0.1;\n    \n    // Lighting calculations\n    float NdotL = max(dot(abs(N), L), 0.0);\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotV = max(dot(N, V), 0.0);\n    \n    float specular = pow(NdotH, 32.0);\n    float fresnelTerm = fresnel(NdotV, F0);\n    vec3 envReflection = envMap(R);\n    \n    return baseColor * NdotL * (1.0 - fresnelTerm) +\n           envReflection * fresnelTerm +\n           + fresnelTerm * 0.1 +\n           + baseColor * 0.1 +\n           vec3(1.0) * specular * (1.0 - roughness);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float radius = 0.4;\n    \n    float W1[H1*I]; float b1[H1]; \n    float W2[O*H1]; float b2[O]; \n    loadWeights(W1, b1, W2, b2, iChannel0);\n    \n    float s = mix(-1.0, 1.0, smoothstep(0.4, 0.6, abs(cos(iTime * 0.25 + 0.5))) - 1.0);\n    float angle = smoothstep(-1.0, 1.0, sin(iTime * 4.0)) + PI + 0.5 * s * PI - PI * 0.125;\n    \n    vec2 leftCenter = vec2(-0.7, 0.0);\n    vec2 rightCenter = vec2(0.7, 0.0);\n    vec3 lightPos = vec3(2.0, 2.0, 2.0);\n    vec3 viewPos = rotateY(vec3(0.0, 0.0, 2.0), angle);\n    \n    vec3 leftColor = processSphere(uv, leftCenter, radius, angle, lightPos, viewPos, \n                                 true, W1, b1, W2, b2);\n    vec3 rightColor = processSphere(uv, rightCenter, radius, angle, lightPos, viewPos, \n                                  false, W1, b1, W2, b2);\n    \n    float rL = length(uv - leftCenter);\n    float rR = length(uv - rightCenter);\n    vec3 color;\n    \n    if (rL <= radius && rR <= radius) {\n        color = (leftColor + rightColor) * 0.5;\n    } else if (rL <= radius) {\n        color = leftColor;\n    } else if (rR <= radius) {\n        color = rightColor;\n    } else {\n        color = vec3(0.0);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    srand(ivec2(fragCoord), iFrame);\n    int x = int(fragCoord.x);\n    int y = int(fragCoord.y);\n    \n    int W1_size = H1*I;\n    int b1_start = W1_size;\n    int b1_size = H1;\n    int W2_start = b1_start + b1_size;\n    int W2_size = O*H1; \n    int b2_start = W2_start + W2_size;\n    int b2_size = O;   \n    int totalFloats = b2_start + b2_size;\n    int totalPixels = (totalFloats + 3) / 4;\n\n    if (y > 0 || x >= totalPixels) {\n        if (iFrame == 0)\n            fragColor = vec4(0.0);\n        else\n            fragColor = texelFetch(iChannel0, ivec2(x,y), 0);\n        return;\n    }\n\n    if (iFrame == 0) {\n        int floatIndex = x*4;\n        fragColor = initializeParameters(floatIndex, totalFloats, W1_size, b1_start, W2_start, b2_start);\n        return;\n    }\n\n    // Load parameters\n    float W1[H1*I];\n    float b1[H1];\n    float W2[O*H1];\n    float b2[O];\n    \n    loadWeights(W1, b1, W2, b2, iChannel0);\n\n    vec3 dir = randomOnSphere();\n    vec3 gtColor = groundTruth(dir);\n\n    // Forward pass\n    float hidden1[H1];\n    float preAct1[H1];\n\n    // First hidden layer\n    for (int h = 0; h < H1; h++) {\n        float sum = b1[h];\n        for (int i = 0; i < I; i++) {\n            sum += w0 * W1[h*I + i] * dir[i];\n        }\n        preAct1[h] = sum;\n        hidden1[h] = siren(sum);\n    }\n\n    // Output layer\n    vec3 pred = vec3(0.0);\n    float preActOut[O];\n    for (int o = 0; o < O; o++) {\n        float sum = b2[o];\n        for (int h = 0; h < H1; h++) {\n            sum += W2[o*H1 + h] * hidden1[h];\n        }\n        preActOut[o] = sum;\n        pred[o] = clamp(sum, 0.0, 1.0);\n    }\n\n    vec3 diff = pred - gtColor;\n\n    // Backprop\n    float dHidden1[H1];\n\n    // Gradient for hidden layer\n    for (int h = 0; h < H1; h++) {\n        float s = 0.0;\n        for (int o = 0; o < O; o++) {\n            s += W2[o*H1 + h] * diff[o];\n        }\n        dHidden1[h] = s * sirenDer(preAct1[h]);\n    }\n    \n    for (int o = 0; o < O; o++) {\n        for (int h = 0; h < H1; h++) {\n            W2[o*H1 + h] -= LR * diff[o] * hidden1[h];\n        }\n        b2[o] -= LR * diff[o];\n    }\n\n    for (int h = 0; h < H1; h++) {\n        for (int i = 0; i < I; i++) {\n            W1[h*I + i] -= LR * dHidden1[h] * dir[i] * w0;\n        }\n        b1[h] -= LR * dHidden1[h];\n    }\n\n    // Store updated parameters\n    vec4 outVal = vec4(0.0);\n    for (int comp = 0; comp < 4; comp++) {\n        int floatIndex = x*4 + comp;\n        float val = 0.0;\n        if (floatIndex < W1_size) val = W1[floatIndex];\n        else if (floatIndex < b1_start + b1_size) val = b1[floatIndex - b1_start];\n        else if (floatIndex < W2_start + W2_size) val = W2[floatIndex - W2_start];\n        else if (floatIndex < b2_start + b2_size) val = b2[floatIndex - b2_start];\n        outVal[comp] = val;\n    }\n    \n    fragColor = outVal;\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#define H1 9\n#define I 3 // input size (direction vector)\n#define O 3 // output size (color)\n#define LR mix(0.02, 0.002, smoothstep(0.0, 60.0, iTime))\n\nconst float w0 = 10.0; \nconst float c_first = 1.0 / w0;  \nconst float c_second = sqrt(6.0 / float(H1));\n\nfloat PI = 3.14159265358979323846;\n\nint seed = 539458;\nint randInt() { seed = seed*0x343fd + 0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(randInt())/32767.0; }\n\nvoid srand( ivec2 p, int frame ) {\n    int n = frame;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589; \n    n += p.y;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\nvec3 randomOnSphere() {\n    float theta = 6.283185 * frand();\n    float u = 2.0 * frand() - 1.0;\n    float s = sqrt(max(0.0, 1.0 - u*u));\n    return vec3(s*cos(theta), s*sin(theta), u);\n}\n\nfloat siren(float x) {\n    return sin(x);\n}\n\nfloat sirenDer(float x) {\n    return cos(x);\n}\n\n\nfloat getParam(int floatIndex, sampler2D iChannel0) {\n    int pixelIndex = floatIndex / 4;\n    int comp = floatIndex % 4;\n    return texelFetch(iChannel0, ivec2(pixelIndex,0), 0)[comp];\n}\n\nvec4 initializeParameters(int floatIndex, int totalFloats, int W1_size, int b1_start, \n                         int W2_start, int b2_start) {\n    vec4 outval = vec4(0.0);\n    for (int comp = 0; comp < 4; comp++) {\n        int fIndex = floatIndex + comp;\n        float val = 0.0;\n        \n        if (fIndex < W1_size) { val = (frand() * 2.0 - 1.0) * c_first; }\n        else if (fIndex < b1_start + H1) { val = 0.0; }\n        else if (fIndex < W2_start + O*H1) { val = (frand() * 2.0 - 1.0) * c_second; }\n        else if (fIndex < b2_start + O) { val = 0.0; }\n        else { val = 0.0; }\n     \n        outval[comp] = val;\n    }\n    return outval;\n}\n\nvoid loadWeights(out float W1[H1*I], out float b1[H1],  out float W2[O*H1], out float b2[O], sampler2D iChannel0) {\n    int W1_size = H1*I;\n    int b1_start = W1_size;\n    int b1_size = H1;\n    int W2_start = b1_start + b1_size;\n    int W2_size = O*H1;\n    int b2_start = W2_start + W2_size;\n    int b2_size = O;\n    \n    for (int i = 0; i < W1_size; i++) { W1[i] = getParam(i, iChannel0); }\n    for (int i = 0; i < b1_size; i++) { b1[i] = getParam(b1_start + i, iChannel0); }\n    for (int i = 0; i < W2_size; i++) { W2[i] = getParam(W2_start + i, iChannel0); }\n    for (int i = 0; i < b2_size; i++) { b2[i] = getParam(b2_start + i, iChannel0); }\n}\n\nvec3 mlpPredict(vec3 dir, float W1[H1*I], float b1[H1], float W2[O*H1], float b2[O]) {\n    float hidden1[H1];\n    for (int h = 0; h < H1; h++) {\n        float sum = b1[h];\n        for (int i = 0; i < I; i++) {\n            sum += w0 * W1[h*I + i] * dir[i];\n        }\n        hidden1[h] = siren(sum);\n    }\n    \n    vec3 outColor = vec3(0.0);\n    for (int o = 0; o < O; o++) {\n        float sum = b2[o];\n        for (int h = 0; h < H1; h++) {\n            sum += W2[o*H1 + h] * hidden1[h];\n        }\n        outColor[o] = clamp(sum, 0.0, 1.0);\n    }\n    \n    return outColor;\n}\n\nvec3 groundTruth(vec3 n) {\n    //float theta = atan(n.z, n.x);\n    //float phi   = acos(n.y);   \n\n    //float u = theta / (2.0 * PI) + 0.5;\n    // float v = phi / PI;\n    float u = n.x;\n    u *= 0.25;\n    \n    vec3 val = max(vec3(sin(u * 10.0 * PI), sin(u * 9.0 * PI),  sin(u * 8.0 * PI)), vec3(0.0));\n    \n    return val;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XfGBRd","date":"1734321796","viewed":475,"name":"Always Looking","username":"luckyballa","description":"Overfitting small NN for fun with sine activation","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["3d","optimization","training","neural","ml","overfitting"],"hasliked":0,"parentid":"","parentname":""}}