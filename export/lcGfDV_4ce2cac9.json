{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//这是一个悬浮的球\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 5.0;\nconst float PRECISION = 0.1;\nconst float EPSILON = 0.001;\nconst float PI = 3.14159265359;\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * EPSILON;\n    float r = 1.;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 rd, vec3 normal, vec2 uv2) {\n  vec3 cubemapReflectionColor = texture(iChannel0, uv2 * 1.).rgb;\n\n  vec3 K_a = cubemapReflectionColor; // Reflection\n  vec3 K_d = vec3(1);\n  vec3 K_s = vec3(0.1);\n  float alpha = 5.;\n\n  float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightDir, normal), -rd), 0., 1.), alpha);\n\n  return lightIntensity * (K_a + K_d * diffuse + K_s * specular);\n}\n\nfloat fresnel(vec3 n, vec3 rd) {\n  return pow(clamp(1. - dot(n, -rd), 0., 1.), 5.);\n}\nvec4 GaussBlur(vec2 uv){\n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 20.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 3.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 16.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    // Pixel colour\n    vec4 Color = texture(iChannel0, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    Color.rgb -= vec3(15,15,15);\n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    return Color;\n}\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 uv2 = fragCoord.xy/iResolution.xy;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n  vec3 col = texture(iChannel0, uv2).rgb;\n\n  float d = rayMarch(ro, rd);\n\n  vec3 p = ro + rd * d;\n  vec3 normal = calcNormal(p);\n\n  vec3 lightPosition1 = vec3(1, 1, 1);\n  vec3 lightDirection1 = normalize(lightPosition1 - p);\n  vec3 lightPosition2 = vec3(-8, -6, -5);\n  vec3 lightDirection2 = normalize(lightPosition2 - p);\n\n  float lightIntensity1 = .5;\n  float lightIntensity2 = .5;\n\n  vec3 sphereColor = phong(lightDirection1, lightIntensity1, rd, normal, uv2);\n  sphereColor += phong(lightDirection2, lightIntensity2, rd, normal, uv2);\n  sphereColor += fresnel(normal, rd) * 0.4;\n\n  //col = mix(col, sphereColor, step(d - MAX_DIST, 0.));\n\n  //fragColor = vec4(col, 1.0);\n  fragColor = mix(GaussBlur(uv2), vec4(sphereColor,1), step(d - MAX_DIST, 0.));\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"texture","id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define DRAG_MULT 0.38\n#define WATER_DEPTH 1.0 \n#define CAMERA_HEIGHT 2.5 \n#define ITERATIONS_RAYMARCH 12\n#define ITERATIONS_NORMAL 36\n#define pi 3.1415926535\n#define SKYCOLOR vec3(0.05, 0.05, 0.15)\n#define MOONLIGHTCOLOR vec3(0.2, 0.2, 0.35)\n#define SKYBYMOONLIGHTCOLOR vec3(0.1, 0.1, 0.3)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define NormalizedMouse (iMouse.xy / iResolution.xy)\n#define time (iTime + 23.0)\n#define moondir getMoonDirection()\n\nvec3 getMoonDirection() {\n    return normalize(vec3(-0.0773502691896258, 0.5 + sin(iTime * 0.2 + 2.6) * 0.45, 0.5773502691896258));\n}\n\nconst mat3 m = mat3( 0.00,  0.90,  0.60,\n                    -0.90,  0.36, -0.48,\n                    -0.60, -0.48,  0.34 );\n\nconst mat2 mr = mat2 (0.84147,  0.54030,\n                      0.54030, -0.84147 );\n                      \nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    f  =      0.5000*noise( p ); p = m*p*2.02;\n    f +=      0.2500*noise( p ); p = m*p*2.33;\n    f +=      0.1250*noise( p ); p = m*p*2.01;\n    f +=      0.0625*noise( p ); \n    return f/(0.9175);\n}\n\nfloat fbm( vec2 p ) {\n    float f;\n    f  =      0.5000*noise( p ); p = mr*p*2.02;\n    f +=      0.2500*noise( p ); p = mr*p*2.33;\n    f +=      0.1250*noise( p ); p = mr*p*2.01;\n    f +=      0.0625*noise( p ); \n    return f/(0.9175);\n}\n\nbool intersectSphere ( in vec3 ro, in vec3 rd, in vec4 sph, out float dist, out vec3 normal ) {\n    vec3  ds = ro - sph.xyz;\n    float bs = dot( rd, ds );\n    float cs = dot(  ds, ds ) - sph.w*sph.w;\n    float ts = bs*bs - cs;\n    if( ts > 0.0 ) {\n        ts = -bs - sqrt( ts );\n\t\tif( ts>0. ) {\n\t\t\tnormal = normalize( ((ro+ts*rd)-sph.xyz)/sph.w );\n\t\t\tdist = ts;\n\t\t\treturn true;\n\t\t}\n    }\n    return false;\n}\n\nbool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec3 pal(float t, vec3 a, vec3 b, vec3 c, vec3 d){\n    return a+b*cos(2.0*pi*(c*t+d));\n}\n\nvec3 spc(float n,float bright){\n    return pal(n,vec3(bright),vec3(0.5),vec3(1.0),vec3(0.0,0.33,0.67));\n}\n\nfloat spec = 0.13;\n\nvec3 skyColor( vec3 rd ) {\t\n    float moonglow = clamp( 1.0782 * dot(moondir, rd), 0.0, 2.0 );\n    vec3 col = SKYCOLOR * moondir.y;\n    col += 0.4 * SKYBYMOONLIGHTCOLOR * moonglow;\n    col += 0.43 * MOONLIGHTCOLOR * pow( moonglow, 21.0 );\n    float dist; vec3 normal; bool moonhit = false;\n    if (intersectSphere( vec3(0., 0., 0.), rd, vec4(moondir, 0.07), dist, normal)) {\n        float l = dot(normalize(vec3(-moondir.x, 0.0, -moondir.z) + vec3(2.2, -1.6, 0.)), normal);\n        col += 3.0 * MOONLIGHTCOLOR * clamp(l, 0.0, 1.);\n        moonhit = true;\n        }\n    if (!moonhit) {\n        vec3 rds = rd;\n        float v = 1.0 / (2. * (1. + rds.z));\n        vec2 xy = vec2(rds.y * v, rds.x * v);\n        float s = noise(rds.xz * 134.);\n        s += noise(rds.xz * 370.);\n        s += noise(rds.xz * 870.);\n        s = pow(s, 19.0) * 0.00000001 * max(rd.y, 0.0);\n        if (s > 0.1) {\n            vec3 backStars = vec3((1.0 - sin(xy.x * 20.0 + time * 13.0 * rds.x + xy.y * 30.0)) * 0.5 * s, s, s);\n            col += backStars;\n        }\n    }\n    float px = 1.5/min(iResolution.x,iResolution.y);\n    vec3 rdo = rd;\n    float rad = 0.075;\n    float sFade = 2.5/min(iResolution.x,iResolution.y);\n    float zFade = rd.z*0.5+0.5;\n    vec3 sc = spc(spec-0.1,0.6)*0.85;\n    float a = length(rd.xy);\n    vec3 moon=smoothstep(a-px-sFade,a+px+sFade,rad)*sc*zFade*2.;\n    float e = 0.;\n    vec3 p = rdo;\n    p.xz *= 0.4;\n    p.x += iTime * 0.007;\n    for (float s = 200.; s > 10.; s *= 0.8) {\n    p.xz *= rot(s);\n    p += s;\n    e += abs(dot(sin(p * s + iTime * 0.02) / s, vec3(1.65)));\n    }\n    e *= smoothstep(0.5, 0.4, e - 0.095);\n    vec3 cloudColor = vec3(0.3, 0.35, 0.4);\n    float cloudIntensity = smoothstep(-0.02, 0.3, rdo.y);\n    col += (e) * cloudIntensity * 0.8 * (1.0 - moon * 3.75) * cloudColor;\n    return col;\n}\n\nvec2 wavedx(vec2 position, vec2 direction, float frequency, float timeshift) {\n  float x = dot(direction, position) * frequency + timeshift;\n  float wave = exp(sin(x) - 1.0);\n  float dx = wave * cos(x);\n  return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations) {\n  float wavePhaseShift = length(position) * 0.1;\n  float iter = 0.0; \n  float frequency = 1.0; \n  float timeMultiplier = 2.0;\n  float weight = 1.0;\n  float sumOfValues = 0.0;\n  float sumOfWeights = 0.0;\n  for(int i=0; i < iterations; i++) {\n    vec2 p = vec2(sin(iter), cos(iter));\n    vec2 res = wavedx(position, p, frequency, iTime * timeMultiplier + wavePhaseShift);\n    position += p * res.y * weight * DRAG_MULT;\n    sumOfValues += res.x * weight;\n    sumOfWeights += weight;\n    weight = mix(weight, 0.0, 0.2);\n    frequency *= 1.18;\n    timeMultiplier *= 1.07;\n    iter += 1232.399963;\n  }\n  return sumOfValues / sumOfWeights;\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth) {\n  vec3 pos = start;\n  vec3 dir = normalize(end - start);\n  for(int i=0; i < 64; i++) {\n    float height = getwaves(pos.xz, ITERATIONS_RAYMARCH) * depth - depth;\n    if(height + 0.01 > pos.y) {\n      return distance(pos, camera);\n    }\n    pos += dir * (pos.y - height);\n  }\n  return distance(start, camera);\n}\n\nvec3 normal(vec2 pos, float e, float depth) {\n  vec2 ex = vec2(e, 0);\n  float H = getwaves(pos.xy, ITERATIONS_NORMAL) * depth;\n  vec3 a = vec3(pos.x, H, pos.y);\n  return normalize(\n    cross(\n      a - vec3(pos.x - e, getwaves(pos.xy - ex.xy, ITERATIONS_NORMAL) * depth, pos.y), \n      a - vec3(pos.x, getwaves(pos.xy + ex.yx, ITERATIONS_NORMAL) * depth, pos.y + e)\n    )\n  );\n}\n\nmat3 createRotationMatrixAxisAngle(vec3 axis, float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n  return mat3(\n    oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, \n    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, \n    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c\n  );\n}\n\nvec3 getRay(vec2 fragCoord) {\n  vec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0); \n  vec3 proj = normalize(vec3(uv.x, uv.y, 1.5));\n  if(iResolution.x < 600.0) {\n    return proj;\n  }\n  return createRotationMatrixAxisAngle(vec3(0.0, -1.0, 0.0), 3.0 * ((NormalizedMouse.x + 0.5) * 2.0 - 1.0)) \n    * createRotationMatrixAxisAngle(vec3(1.0, 0.0, 0.0), 0.5 + 1.5 * (((NormalizedMouse.y == 0.0 ? 0.27 : NormalizedMouse.y) * 1.0) * 2.0 - 1.0))\n    * proj;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { \n  return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\nvec3 aces_tonemap(vec3 color) {  \n  mat3 m1 = mat3(\n    0.59719, 0.07600, 0.02840,\n    0.35458, 0.90834, 0.13383,\n    0.04823, 0.01566, 0.83777\n  );\n  mat3 m2 = mat3(\n    1.60475, -0.10208, -0.00327,\n    -0.53108,  1.10813, -0.07276,\n    -0.07367, -0.00605,  1.07602\n  );\n  vec3 v = m1 * color;  \n  vec3 a = v * (v + 0.0245786) - 0.000090537;\n  vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n  return pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));  \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 ray = getRay(fragCoord);\n  if(ray.y >= 0.0) {\n    vec3 C = skyColor(ray);\n    fragColor = vec4(aces_tonemap(C * 2.0),1.0);   \n    return;\n  }\n  vec3 waterPlaneHigh = vec3(0.0, 0.0, 0.0);\n  vec3 waterPlaneLow = vec3(0.0, -WATER_DEPTH, 0.0);\n  vec3 origin = vec3(iTime * 0.2, CAMERA_HEIGHT, 1);\n  float highPlaneHit = intersectPlane(origin, ray, waterPlaneHigh, vec3(0.0, 1.0, 0.0));\n  float lowPlaneHit = intersectPlane(origin, ray, waterPlaneLow, vec3(0.0, 1.0, 0.0));\n  vec3 highHitPos = origin + ray * highPlaneHit;\n  vec3 lowHitPos = origin + ray * lowPlaneHit;\n  float dist = raymarchwater(origin, highHitPos, lowHitPos, WATER_DEPTH);\n  vec3 waterHitPos = origin + ray * dist;\n  vec3 N = normal(waterHitPos.xz, 0.01, WATER_DEPTH);\n  N = mix(N, vec3(0.0, 1.0, 0.0), 0.8 * min(1.0, sqrt(dist*0.01) * 1.1));\n  float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n  vec3 R = normalize(reflect(ray, N));\n  R.y = abs(R.y);\n  vec3 reflection = skyColor(R);\n  vec3 scattering = vec3(0.0293, 0.0698, 0.1717) * 0.1 * (0.2 + (waterHitPos.y + WATER_DEPTH) / WATER_DEPTH);\n  vec3 C = fresnel * reflection + scattering;\n  fragColor = vec4(aces_tonemap(C * 2.0), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lcGfDV","date":"1734462030","viewed":97,"name":"homework is used","username":"Qikaaa","description":"homework","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["waves","sea","water","ocean","seascape","scape"],"hasliked":0,"parentid":"lfyfWV","parentname":"Fork Fork Very  Qikaaa 178"}}