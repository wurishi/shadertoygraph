{"ver":"0.1","info":{"id":"l3sSzM","date":"1709286735","viewed":162,"name":"Worlds Generator","username":"Wildric","description":"This was the first version of a shader to generate planets.\nA (better) interactive version can be found here: \nhttps://wildric.itch.io/planet-generator\nMultiple improvement were added later, like raymarching being partially replaced with raytracinng.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise","fbm","planet","map","heightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define LIGHT_MOUSE 1\n\n\nint   gMaxRaySteps = 40;\nfloat gMinForInter = 0.0001;\nvec3  gBgCol       = vec3(0.05, 0.01, 0.01);\nvec3  gAmbientLight= vec3(0.045);\n\nvec2  gMouse;\n\nvec3 nullVec3;\n\nvec2 uv0;\n\nvec3 atmCol                   = vec3(1.0,0.5, 0.5);\nfloat atmThickness            = 0.3;\nfloat atmContrib              = 1.5; //From 1.0 to higher values\nfloat maxAtmInteriorThickness = 100.0;\n\nstruct Camera {\n    vec3 position;\n    vec3 rotation;\n    float nearPlane;\n    float farPlane;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec3 rotation;\n    vec3 color;\n};\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nstruct HitInfo {\n    vec3   color;\n    Sphere sphere;\n    float  height;\n    \n};\n\n\n//get if ray point->light.position intersect with the sphere s\nbool sphereIntersect(in vec3 p, inout Sphere s, inout Light l) {\n    float r2   = s.radius * s.radius; //radius squared\n    vec3  ray  = normalize(l.position - p);\n    p         += ray * 2.0 * gMinForInter;\n    float a    = dot(ray, ray);\n    float b    = 2.0 * dot(p - s.position, ray);\n    float c    = dot(p - s.position, p-s.position) - r2;    \n    float s1;\n    float s2;\n    if (!solveQuadratic(a,b,c, s1, s2))\n        return false;\n        \n    return (s1 > 0.2) || (s2 > 0.2);\n}\n\nfloat sdfSphere(vec3 pos, inout HitInfo hit) {\n    vec2 sphereUV;\n    \n    Sphere sphere     = hit.sphere;\n    \n    vec3 n     = (pos - sphere.position) / sphere.radius;\n    \n    sphereUV.x =  atan(n.x, - n.z) / (PI*2.0) + 0.5;\n    sphereUV.y =  0.5 + asin(n.y)/PI;\n    sphereUV.x += 0.1;\n    vec4 sampleBuff = texture(iChannel0, sphereUV);\n    hit.color = sampleBuff.xyz;\n    \n    hit.height = sampleBuff.w; \n    return distance(pos, sphere.position) - sphere.radius - sampleBuff.w * sampleBuff.w *0.001;\n}\n\nvec3 normalSphere(in vec3 pos, in HitInfo sphere) {\n    float dis = sdfSphere(pos, sphere);\n    vec2  eps = vec2(0.001, 0.0);\n    return normalize( dis - vec3(\n                      sdfSphere(pos - eps.xyy, sphere),\n                      sdfSphere(pos - eps.yxy, sphere),\n                      sdfSphere(pos - eps.yyx, sphere)\n                     ));\n}\n\nvoid rayMarch(in Camera cam, in vec2 uv, out vec3 col, out vec3 interPos) {\n    vec3 currentPosition = vec3(0.0);\n    float steps          = 0.0;\n    \n    \n    Sphere s;\n    Light  l;\n    s.position = vec3(-0.0, -0., 1.3);\n    s.radius   = 0.65;\n    s.color    = vec3(0.0, 0.0, .0);\n    \n    l.position = vec3(5.0,9.0, -2.);\n    #ifdef LIGHT_MOUSE\n    l.position = vec3(gMouse.x * 13.0, gMouse.y * 13.0, 0.3);\n    #endif\n    l.color    = vec3(1.0);\n    \n    HitInfo hit;\n    HitInfo hit0;\n    \n    hit.sphere  = s;\n    hit0.sphere = s;\n    \n    float minNear     = 10000.0;\n    float nearestStep = 10000.0;\n    float nearest;\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, cam.nearPlane));\n    for (int i = 0; i < gMaxRaySteps; i++) {\n        nearest = sdfSphere(currentPosition, hit);\n        steps          += nearest;\n        currentPosition = steps * rayDir;\n        nearestStep     = min(nearestStep, steps);\n        minNear         = min(minNear, nearest); //temp for atmosphere\n       \n\n        if (nearest > gMinForInter) {\n            continue;\n        }\n        \n        //Intersection occured\n        \n     \n        vec3 projection =  normalize(-currentPosition + l.position);\n        vec3 normal = normalSphere(currentPosition, hit0);\n        \n        vec3 reflection    = reflect(-projection, normal);\n        vec3 viewDir      = normalize(cam.position - currentPosition );\n        float p         =  (hit.height  < OCEAN_LEVEL + OCEAN_EDGE) ? 16.0 : 1.0;\n        \n        float specular  = pow(max(0.0,dot(viewDir, reflection)), p);\n        float diffuse   = max(0.0, dot(projection, normal));\n        vec3 result     = (specular * diffuse +diffuse+gAmbientLight)*l.color; \n\n        //Add atmosphere color\n        vec3 snormal = normalize(currentPosition - s.position);\n        float atmInt= min(1.0, abs(dot(snormal, normalize(cam.position - s.position))));\n        \n        col = hit.color;\n        col = mix(col, atmCol, min(atmThickness + (atmContrib - atmInt) * atmThickness, maxAtmInteriorThickness));\n        col*= result;\n        return;\n       \n        //-----------\n    }\n    //Calculate atmosphere\n    vec3 atmPos = nearestStep * rayDir; //Point in atmosphere\n    float temp = 0.0;\n    \n    float tempThick  = max(0.0, dot(normalize(atmPos - s.position), normalize(l.position - s.position )));\n    atmThickness     = tempThick * atmThickness;\n    \n    if (minNear < atmThickness) {\n        temp   = 1.0 - (atmThickness - minNear) / atmThickness;\n        temp   = exp(-5.0*temp); \n    }\n   \n    col = mix(texture(iChannel1, uv0).xyz, atmCol, temp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv  = (fragCoord - 0.5* iResolution.xy)/iResolution.y;\n    uv0      = fragCoord.xy / iResolution.xy;\n    gMouse   = iMouse.xy    / iResolution.xy;\n    \n    Camera cam;\n    cam.position = vec3(0.0);\n    cam.nearPlane = 0.8;\n    \n    vec3 temp;\n    vec3 col;\n    rayMarch(cam, uv, col, temp);\n    fragColor = vec4(tonemap(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OCEAN_LEVEL 0.5\n#define OCEAN_EDGE 0.05\n#define MOUNTAIN_LEVEL   0.7\n#define MOUNTAIN_LEVEL_2 0.95\n\n#define OCEAN_COLOR    vec3(0.5, 0.57, 0.2)\n#define PLAIN_COLOR    vec3(0.1, 0.3,0.0)\n#define MOUNTAIN_COLOR vec3(1.1)\n\n#define PI 3.14159265359\nfloat rand(in vec2 uv) {\n    return fract(sin(dot(uv,  vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat noise(in vec2 pos) {\n    vec2 localPos = fract(pos);\n    float a        = rand(floor(pos));\n    float b        = rand(floor(pos + vec2(1.0, 0.0)));\n    float c        = rand(floor(pos + vec2(1.0, 1.0)));\n    float d        = rand(floor(pos + vec2(0.0, 1.0)));\n    \n    vec2 xy = localPos*localPos*(3.0 - 2.0*localPos);\n    \n    return mix(mix(a, b, xy.x), mix(d, c, xy.x), xy.y);\n    \n}\n\nfloat fbm(in vec2 pos) {\n   float ret  = 0.0;\n   float freq = 1.0;\n   \n   ret += noise(pos);\n   ret += 0.5     * noise(2.0   * pos);\n   ret += 0.25    * noise(4.0   * pos);\n   ret += 0.125   * noise(8.0   * pos);\n   ret += 0.0625  * noise(16.0  * pos);\n   ret += 0.03125 * noise(32.0  * pos);\n   \n   return ret;\n}\n\n//--------------------------------------------\n\n\nbool solveQuadratic(float a, float b, float c, inout float s1, inout float s2) {\n    float delta = (b*b - 4.0*a*c);\n    if (delta < 0.0) \n        return false;\n    float sDelta= sqrt(delta);\n    s1          = (-b - sDelta)/(2.0*a);\n    s2          = (-b + sDelta)/(2.0*a);\n    return true;\n}\n\n\nvec3 tonemap(vec3 color)\n{\n   float gamma = 1.45;\n   float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n//Generates the map and writes it in bufferA\n\n\nfloat getHeight(in vec2 uv) {\n    float temp      = fbm(vec2(fbm(vec2(fbm(uv*1.0), fbm(uv*40.0))), fbm(uv * 20.0)));\n    temp           *= temp * temp;\n    return temp * 0.47;\n}\n\nfloat worldEdge(in vec2 uv, float worldHeight, float edgeHeight, in vec2 downLeft) {\n    float temp;\n    temp = mix(worldHeight, edgeHeight, clamp( (uv.x - 1.0 + downLeft.x ) / downLeft.x ,0.0, 1.0));    \n    temp = mix(temp, edgeHeight, clamp( (uv.y - 1.0 + downLeft.y) /downLeft.y ,0.0, 1.0)); \n    temp = mix(temp, edgeHeight, clamp( (downLeft.x - uv.x)     / downLeft.x ,0.0, 1.0)); \n    temp = mix(temp, edgeHeight, clamp( (downLeft.y - uv.y)     / downLeft.y ,0.0, 1.0)); \n    return temp;\n}\n\n\nvoid colorize(float height, out vec3 outputCol) {\n    vec3 temp = vec3(height);\n    if (height < OCEAN_LEVEL)\n        outputCol = OCEAN_COLOR * (OCEAN_LEVEL - 0.1 + height);\n    else if (height < OCEAN_LEVEL + OCEAN_EDGE){\n        float x = (height - OCEAN_LEVEL) / OCEAN_EDGE;\n        outputCol     = mix(OCEAN_COLOR, temp, x);\n    }\n        else if (height < MOUNTAIN_LEVEL)\n        outputCol = temp * PLAIN_COLOR;\n    else if (height < MOUNTAIN_LEVEL_2)\n        outputCol = temp * temp * temp * MOUNTAIN_COLOR;\n    else \n        outputCol = temp * MOUNTAIN_COLOR;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv         = fragCoord/iResolution.xy;  \n    float height    = getHeight(uv);\n    float borderLevel   = -0.0;\n    float edged = worldEdge(uv, height, borderLevel, vec2(0.45));\n    vec3 col;\n    colorize(edged, col);\n   \n    //Clouds\n    float clouds = fbm(uv* 10.0);\n    clouds = pow(clouds, 5.0);\n    clouds = worldEdge(uv, clouds, 0.0, vec2(0.4));\n   // col   += clouds / 10.0;\n    \n    \n    //col += temp;\n    \n    fragColor = vec4(col, edged);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n#define Nebula 100.0\n#define NebIntensity 1.0\n#define stars 700.0\n#define colIntensity vec3(1.,0.5,1.0)\n//Standard random function and noise to build perlin noise function with addition of octaves\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;  \n\n    float r = (fbm(uv * 10.0))*colIntensity.r; //arbitrary values in perlin function to generate \"galatical\" colors\n    float g = (fbm(uv * 20.0))*colIntensity.g;\n    float b = (fbm(uv * 300.0))*colIntensity.b;\n    float fade = pow(1.0 - fbm(uv * 10.0), 4.0);\n    vec3 col = vec3(r,g,b);\n    vec3 sky = vec3(pow(rand(uv), stars));\n    sky += col * fade;\n    fragColor = vec4(vec3(sky),1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}