{"ver":"0.1","info":{"id":"MlByz3","date":"1509487390","viewed":777,"name":"integration: golden ratio","username":"hornet","description":"redoing the results of https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\nleft to right: WhiteNoise -> InterleaveGradientNoise -> bad-bluenoise\ntop is the pattern\nmid is average of N patterns\nbottom is using the golden ratio","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n// (see also https://www.graphics.rwth-aachen.de/media/papers/jgt.pdf )\nconst float gr = (1.0 + sqrt(5.0)) / 2.0;\nfloat GoldenRatioMultiple( int multiple )\n{\n    return float(multiple) * gr;\n}\n\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\n//note: returns [-intensity;intensity[, magnitude of 2x intensity\n//note: from \"NEXT GENERATION POST PROCESSING IN CALL OF DUTY: ADVANCED WARFARE\"\n//      http://advances.realtimerendering.com/s2014/index.html\nfloat InterleavedGradientNoise( vec2 uv )\n{\n    const vec3 magic = vec3( 0.06711056, 0.00583715, 52.9829189 );\n    return fract( magic.z * fract( dot( uv, magic.xy ) ) );\n}\n\nfloat ScreenSpaceDither( vec2 vScreenPos )\n{\n\t// Iestyn's RGB dither (7 asm instructions) from Portal 2 X360, slightly modified for VR\n\t//vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy + iTime ) );\n    float vDither = dot( vec2( 171.0, 231.0 ), vScreenPos.xy );\n    return fract( vDither / 91.111 );\n    //vDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) );\n    //return vDither.rgb / 255.0; //note: looks better without 0.375...\n\n    //note: not sure why the 0.5-offset is there...\n    //vDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) ) - vec3( 0.5, 0.5, 0.5 );\n\t//return (vDither.rgb / 255.0) * 0.375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int idx = int( floor( 3.0 * uv.x ) + 3.0*floor( 3.0 * uv.y ) );\n\n    const int NUM_SAMPLES = 16;\n\tconst float RCP_NUM_SAMPLES_F = 1.0  / float(NUM_SAMPLES);\n\n    float sum = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        if ( idx == 6 )\n        {\n            sum = hash12n( uv + float(iFrame-i) );\n        }\n        if ( idx == 3 )\n        {\n            float rnd = hash12n( uv + float(iFrame-i) );\n            sum += RCP_NUM_SAMPLES_F * rnd;\n        }\n        else if ( idx == 0 )\n        {\n            float rnd = hash12n( uv );\n            \n            float grm = GoldenRatioMultiple( iFrame - i );\n            rnd = fract( rnd + grm );\n            \n            sum += RCP_NUM_SAMPLES_F * rnd;\n        }\n        else if ( idx == 8 )\n        {\n            //note: see https://www.shadertoy.com/view/4sGSDd\n            vec2 fc = fragCoord.xy;\n            fc += vec2(ivec2(1321,1327)*(iFrame-i));\n            vec2 p = fc/iChannelResolution[0].xy;\n            float s0 = texture( iChannel0, p, 0.0).r;\n            float s1 = texture( iChannel0, p, 1.0).r;\n            float rnd = s0 - s1 + 0.5;\n            \n            sum = rnd;\n        }\n        else if ( idx == 5 )\n        {\n            vec2 fc = fragCoord.xy;\n            fc += vec2(ivec2(1321,1327)*(iFrame-i));\n            vec2 p = fc/iChannelResolution[0].xy;\n            float s0 = texture( iChannel0, p, 0.0).r;\n            float s1 = texture( iChannel0, p, 1.0).r;\n            float rnd = s0 - s1 + 0.5;\n            \n            sum += RCP_NUM_SAMPLES_F*rnd;\n        }\n        else if ( idx == 2 )\n        {\n            vec2 fc = fragCoord.xy;\n            vec2 p = fc/iChannelResolution[0].xy;\n            float s0 = texture( iChannel0, p, 0.0).r;\n            float s1 = texture( iChannel0, p, 1.0).r;\n            float rnd = s0 - s1 + 0.5;\n            \n            float grm = GoldenRatioMultiple(iFrame-i);\n            rnd = fract(rnd + grm);\n            \n            sum += RCP_NUM_SAMPLES_F*rnd;\n        }\n        else if ( idx == 7 )\n        {\n            vec2 fc = fragCoord.xy;\n            fc += vec2(-11.0,7.0)*vec2(iFrame-i); //TODO: entirely empirical and likely terrible offset...\n            sum = InterleavedGradientNoise( fc );\n\t\t\t//sum = ScreenSpaceDither( fc );\n        }\n        else if ( idx == 4 )\n        {\n            vec2 fc = fragCoord.xy;\n            fc += vec2(-11.0,7.0)*vec2(iFrame-i); //TODO: entirely empirical and likely terrible offset...\n            \n            float ign = InterleavedGradientNoise( fc );\n            //float ign = ScreenSpaceDither( fc );\n            \n            sum += RCP_NUM_SAMPLES_F * ign;\n        }\n        else if ( idx == 1 )\n        {\n            vec2 fc = fragCoord.xy;\n            //fc += vec2(-11.0,7.0)*vec2(iFrame-i); //TODO: entirely empirical and likely terrible offset...\n            \n            float ign = InterleavedGradientNoise( fc );\n            //float ign = ScreenSpaceDither( fc );\n            \n            float grm = GoldenRatioMultiple(iFrame-i);\n            ign = fract(ign + grm);\n            \n            sum += RCP_NUM_SAMPLES_F*ign;\n        }\n    }\n    \n    fragColor = vec4( vec3(sum), 1.0 );\n    \n    //lines\n    fragColor *= step( 6.0/iResolution.x, 1.0-abs(2.0*fract(3.0*uv.x)-1.0));\n    fragColor *= 0.75+0.25*(step( 5.0/iResolution.y, 1.0-abs(2.0*fract(3.0*uv.y)-1.0)));\n\n}\n","name":"Image","description":"","type":"image"}]}