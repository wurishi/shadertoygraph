{"ver":"0.1","info":{"id":"McdSzS","date":"1714103277","viewed":105,"name":"Flood fill (recreation)","username":"Envy24","description":"Original: https://www.shadertoy.com/view/XcK3Wd\nClick to start fill process.\nPress Q to generate new maze.\nKey Z on/off magnification.\nKey F on/off filling.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["flood","maze","fill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ImageTab\n// Scene magnification.\n\n#define UNIT                      ( (2000.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nvec3 scene( in vec2 SC ) { return TEXF0(SC).rgb; }\n\nfloat squareSDF(in vec2 NDC, in vec2 C, in float r) \n{ \n    NDC -= C; NDC = abs(NDC) - vec2(r); \n    return length(max(NDC,vec2(0.))) + min(max(NDC.x, NDC.y),0.0);\n}\n\nvec3 mag_scene(vec2 NDC, vec2 pos, float mag, inout vec3 color)\n{\n    float r = 80., s = 20.0;\n    color = mix(color,                    vec3(1), SMAA(squareSDF(NDC, pos, r+1.) - s)); // outline\n    color = mix(color, scene((NDC-pos)/mag + pos), SMAA(squareSDF(NDC, pos, r) - s));    // magnified scene    \n    return color;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC ) \n{\n    vec2 MP = iMouse.xy == vec2(0) ? iResolution.xy * .5 : iMouse.xy;   \n    float mag = 3.;\n    \n    vec3 color = scene(SC);\n         \n    if (!KEY_Z_IS_TOGGLE)\n        color = mag_scene(SC, MP, mag, color);\n        \n    O = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(SC), 0) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define KEY_Q                     ( 81.5 )\n#define KEY_Z                     ( 90.0 )\n#define KEY_F                     ( 70.0 )\n#define KEY_Q_IS_PRESSED          ( texelFetch(iChannel3, ivec2(KEY_Q,1), 0).x > 0.)\n#define KEY_Q_IS_HOLD             ( texelFetch(iChannel3, ivec2(KEY_Q,0), 0).x > 0.)\n#define KEY_Z_IS_TOGGLE           ( texelFetch(iChannel3, ivec2(KEY_Z,2), 0).x > 0.)\n#define KEY_F_IS_TOGGLE           ( texelFetch(iChannel3, ivec2(KEY_F,2), 0).x > 0.)\n\n/*\n    Returns hash in range [0.0; 1.0].\n*/\nfloat fHuu(uint x, uint y)\n{\n    // Pick some seed values.\n    const uint seed0 = 123u;\n    const uint seed1 = 456u;\n    const uint seed2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value = y * seed2 + x;\n\n    // Calculate hash.\n\tvalue += seed1;\n\tvalue *= 445593459u;\n\tvalue ^= seed0;\n    \n    // 1.0f / 4294967295.0f = 2.32830644e-10\n\n    return float(value * value * value) * 2.32830644e-10;\n}\n#define FHUU(P) ( fHuu(uint(P.x), uint(P.y)) )","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// BufferA:\n// Maze generation and Flood fill\n\n#define WALL  vec3(0,.3,.5)\n#define FLOOR vec3(0)\n#define FILL  vec3(1,0,0)\nvec3 generate_maze(vec2 SC)\n{\n    float visibility_treshold = 0.6; // bigger value -> more black points -> better solvability\n    SC += vec2(iFrame);  \n    return FHUU(SC) > visibility_treshold ? WALL : FLOOR;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC ) \n{ \n    if ( iFrame == 0 || KEY_Q_IS_PRESSED ) // Generate maze?\n    {\n        O = vec4(generate_maze(SC), 1); return;       \n    }\n\n    vec3 state = TEXF0(SC).rgb; // Read cell state\n\n    if (LMB_IS_HOLD && floor(SC) == iMouse.xy && state != WALL && !KEY_F_IS_TOGGLE) // Start fill from mouse position?\n    {\n        O = vec4(FILL,1); return;\n    }  \n\n    if (state != FLOOR) // Filled cell or wall cell?\n    {\n        O = vec4(state, 1); return;\n    }\n    \n    vec3 N[4] = vec3[4](               // neigbour cells\n        TEXF0(SC+vec2( 0., 1.)).rgb,   // up\n        TEXF0(SC+vec2( 0.,-1.)).rgb,   // down\n        TEXF0(SC+vec2( 1., 0.)).rgb,   // right\n        TEXF0(SC+vec2(-1., 0.)).rgb ); // left\n\n    int is_reachable = 0;\n\n    for (int i = 0; i < 4; ++i)\n    {\n        int is_filled = N[i] == FILL ? 1 : 0;\n        is_reachable |= is_filled;\n    }\n\n    state = is_reachable == 1 ? FILL : state;\n            \n    O = vec4(state, 1);\n}","name":"Buffer A","description":"","type":"buffer"}]}