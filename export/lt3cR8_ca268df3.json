{"ver":"0.1","info":{"id":"lt3cR8","date":"1531469243","viewed":297,"name":"Rocks PBR texture try","username":"FlorianDuf","description":"Training with normal and noise","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fbm","pbr","rock","training"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n*\n*  \n*\tInspired by : https://iquilezles.org/articles/warp\n*\t\t\t\t& https://thebookofshaders.com/\n*\n*\n*/\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0,0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0.0,1.0, f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return 0.7*value;\n}\n\nvec3 normalFBM(in vec2 uv)\n{\n    \n    float neighbours = .0001;\n    \n    vec3 neighBX1 = vec3(uv.x+neighbours, uv.y, fbm(uv+vec2(neighbours, 0.0)));\n    vec3 neighBX2 = vec3(uv.x-neighbours, uv.y, fbm(uv-vec2(neighbours, 0.0)));\n    \n    vec3 neighBY1 = vec3(uv.x, uv.y+neighbours, fbm(uv+vec2(0.0, neighbours)));\n    vec3 neighBY2 = vec3(uv.x, uv.y-neighbours, fbm(uv-vec2(0.0, neighbours)));\n    \n    vec3 gX = normalize(neighBX1-neighBX2);\n    vec3 gY = normalize(neighBY1-neighBY2);\n    vec3 n = cross ( gX, gY );\n                         \n    return n;// * vec3(1.0,1.0,0.5) + vec3(0.0,0.0,0.5);\n}\n\nstruct Light {\n    vec3 pos;\n    float energy;\n};\n\nvec3 phong(in Light light, in vec3 p, in vec3 n, in float shininess)\n{\n    \n    vec3 lp = normalize(light.pos- p);\n    float d = clamp( dot( n,lp ),0.0,1.0);\n   \n    float s = pow(d, shininess);\n    float a = 0.0;\n    \n    return vec3(d, s, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = 10.0* fragCoord/iResolution.x;\n\n    vec3 n = normalFBM(uv);\n    vec3 col = vec3(n);\n    vec3 p = vec3(uv.x, uv.y, fbm(uv));\n\n    Light light = Light(vec3(5.0*sin(0.3774*iTime)+5.0,5.0*sin(0.2878785454*iTime)+5.0, 2.0) ,0.8);\n    \n\n    vec3 phong_ = phong(light, p, n, 10.0);\n    col = ( texture(iChannel0, uv/10.0).rgb * light.energy * phong_.x + vec3(0.1) * phong_.y );\n    col /= pow(distance(light.pos, p), 0.3);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define OCTAVES 6","name":"Common","description":"","type":"common"}]}