{"ver":"0.1","info":{"id":"MlcSDf","date":"1481823494","viewed":144,"name":"#Devember 2016 - day 14","username":"theGiallo","description":"Added line, ellipsoid and some toruses and spheres with different norms.\nIt's getting heavy with 34 + 8 =42 primitives, I should add frustum culling.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","primitives","devember"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT2 1.4142135623730950488016887242096980785696\n#define PI    3.1415926535897932384626433832795\n#define HPI   1.57079632679489661923132169\n#define QPI   0.785398163397448309615660845819875721\n#define TAU   6.283185307179586476925286766559\n\n#define INDEXED_MATERIALS 1\n\n#if INDEXED_MATERIALS\n#define MPt vec2\n#define distance x\n#else\n#define MPt Material_Point\n#endif\nstruct\nMaterial\n{\n    vec3 color;\n    float diffuse_reflection;\n    float specular_reflection;\n    float ambient_reflection;\n    float shininess;\n};\nstruct\nMaterial_Point\n{\n    float distance;\n    Material material;\n};\n    \n#define MAT_PLASTIC  0.0\n#define MAT_ORANGE   1.0\n#define MAT_RED      2.0\n#define MAT_GREEN    3.0\n#define MAT_BLUE     4.0\n#define MAT_FLOOR_W  5.0\n#define MAT_FLOOR_B  6.0\n#define MAT_COUNT    7\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nmanhattan( vec2 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nmanhattan( vec2 p0, vec2 p1 )\n{\n    float ret;\n    \n    vec2 d = abs ( p1 - p0 );\n    ret = d.x + d.y;\n    \n    return ret;\n}\nfloat\nmanhattan( in vec3 p )\n{\n    p = abs ( p );\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\nfloat\nsum( in vec2 p )\n{\n    float ret = p.x + p.y;\n    return ret;\n}\nfloat\nsum( in vec3 p )\n{\n    float ret = p.x + p.y + p.z;\n    return ret;\n}\n\nvec2\npow3( in vec2 v )\n{\n    v = v*v*v;;\n    return v;\n}\nvec3\npow3( in vec3 v )\n{\n    v = v*v*v;\n    return v;\n}\nvec2\npow4( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow4( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npow6( in vec2 v )\n{\n    vec2 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec3\npow6( in vec3 v )\n{\n    vec3 ret = v*v;\n    ret = ret*ret;\n    ret = ret * v;\n    return ret;\n}\nvec2\npow8( in vec2 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec3\npow8( in vec3 v )\n{\n    v = v*v;\n    v = v*v;\n    v = v*v;\n    return v;\n}\nvec2\npow( in vec2 v, in float exp )\n{\n    return pow( v, vec2(exp,exp) );\n}\nvec3\npow( in vec3 v, in float exp )\n{\n    return pow( v, vec3(exp,exp,exp) );\n}\n\nvec4\ncircle( vec4 color, vec2 pos, float radius, float border_width, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float dist = length( point - pos );\n    ret = color * (1.0 - smoothstep( radius, radius + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    \n    return ret;\n}\nvec4\nsquare_tex( vec4 color, vec2 pos, float side, float border_width, float rot_rad, vec2 point, sampler2D tex )\n{\n    vec4 ret = vec4(0);\n    color.rgb *= color.a;\n    \n    float max_d = SQRT2 * side;\n    vec2 rd = point - pos;\n    float tot_rad = QPI + rot_rad;\n    vec2 rd_rot;\n    rd_rot.x = rd.x * cos( tot_rad ) + rd.y * sin( tot_rad );\n    rd_rot.y = rd.x * sin( tot_rad ) - rd.y * cos( tot_rad );\n    float dist = manhattan( rd_rot );\n    ret = color * (1.0 - smoothstep( max_d, max_d + border_width, dist ) );\n    ret *= texture( tex, rd_rot * (0.5 / side ) + 0.5 );\n    \n    return ret;\n}\n\n// NOTE(theGiallo): pre-multiplied alpha\nvoid\nblend_pma( inout vec4 dst, in vec4 src )\n{\n    dst.rgb = src.rgb + dst.rgb * ( 1.0 - src.a );\n    dst.a = min( 1.0, dst.a + src.a );\n}\n\nfloat\nmirror( float x )\n{\n    x *= 0.5;\n    return 1.0 - abs( 2.0 * ( x - floor(x) ) - 1.0 );\n}\n\nfloat\ndecimal( float x )\n{\n    return x - floor(x);\n}\n\n// NOTE(theGiallo): h in [0,1)\nvec4\nrgb_from_hsv( vec4 hsv )\n{\n\tvec4 ret;\n\tret.a = hsv.a;\n\tfloat c = hsv.g * hsv.b;\n\tfloat hh = hsv.r * 6.0;\n\n\tfloat x = c * ( 1.0 - abs( hh - 2.0 * floor( hh / 2.0 ) - 1.0 ) );\n\n\tif ( hh < 1.0 || hh >= 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = x;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 2.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = c;\n\t\tret.b = 0.0;\n\t} else\n\tif ( hh < 3.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = c;\n\t\tret.b = x;\n\t} else\n\tif ( hh < 4.0 )\n\t{\n\t\tret.r = 0.0;\n\t\tret.g = x;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 5.0 )\n\t{\n\t\tret.r = x;\n\t\tret.g = 0.0;\n\t\tret.b = c;\n\t} else\n\tif ( hh < 6.0 )\n\t{\n\t\tret.r = c;\n\t\tret.g = 0.0;\n\t\tret.b = x;\n\t}\n\n\tfloat m = hsv.b - c;\n\tret.r += m;\n\tret.g += m;\n\tret.b += m;\n\n\treturn ret;\n}\n\n#define ORANGE_RGB vec3(1.0,0.4,0.0)\n#define T_EPS 0.001\n\nfloat\nmin( in vec3 v )\n{\n    return min( v.x, min( v.y, v.z ) );\n}\n\nfloat\nmax( in vec3 v )\n{\n    return max( v.x, max( v.y, v.z ) );\n}\n\nfloat\nmin( in vec2 v )\n{\n    return min( v.x, v.y );\n}\n\nfloat\nmax( in vec2 v )\n{\n    return max( v.x, v.y );\n}\n\n\nfloat\nlength3( in vec2 v )\n{\n    v = pow3(v);\n    return pow(sum(v),1.0/3.0);\n}\nfloat\nlength3( in vec3 v )\n{\n    v = pow3(v);\n    return pow(sum(v),1.0/3.0);\n}\n\nfloat\nlength4( in vec2 v )\n{\n    v = pow4(v);\n    return pow(sum(v),1.0/4.0);\n}\nfloat\nlength4( in vec3 v )\n{\n    v = pow4(v);\n    return pow(sum(v),1.0/4.0);\n}\nfloat\nlength6( in vec2 v )\n{\n    v = pow6(v);\n    return pow(sum(v),1.0/6.0);\n}\nfloat\nlength6( in vec3 v )\n{\n    v = pow6(v);\n    return pow(sum(v),1.0/6.0);\n}\nfloat\nlength8( in vec2 v )\n{\n    v = pow8(v);\n    return pow(sum(v),1.0/8.0);\n}\nfloat\nlength8( in vec3 v )\n{\n    v = pow8(v);\n    return pow(sum(v),1.0/8.0);\n}\n\n\n\nvec3\nat_pos( in vec3 pos, in vec3 p )\n{\n    return p-pos;\n}\n\nmat4\ntr( mat4 m )\n{\n    return mat4(\n       vec4(m[0][0],m[1][0],m[2][0],m[3][0]),\n       vec4(m[0][1],m[1][1],m[2][1],m[3][1]),\n       vec4(m[0][2],m[1][2],m[2][2],m[3][2]),\n       vec4(m[0][3],m[1][3],m[2][3],m[3][3])\n    );\n}\n\nvec3\nrotate( in vec3 r, in vec3 p )\n{\n\tmat4 Rx = mat4(\n\t   vec4( 1.0, 0.0,      0.0,       0.0 ),\n\t   vec4( 0.0, cos(r.x), -sin(r.x), 0.0 ),\n\t   vec4( 0.0, sin(r.x),  cos(r.x), 0.0 ),\n\t   vec4( 0.0, 0.0,      0.0,       0.0 ) );\n\tmat4 Ry = mat4(\n\t   vec4(  cos(r.y), 0.0, sin(r.y), 0.0 ),\n\t   vec4(  0.0,      1.0, 0.0,      0.0 ),\n\t   vec4( -sin(r.y), 0.0, cos(r.y), 0.0 ),\n\t   vec4(  0.0,      0.0, 0.0,      1.0 ) );\n\tmat4 Rz = mat4(\n\t   vec4( cos(r.z), -sin(r.z), 0.0, 0.0 ),\n\t   vec4( sin(r.z),  cos(r.z), 0.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       1.0, 0.0 ),\n\t   vec4( 0.0,      0.0,       0.0, 1.0 ) );\n\tmat4 m = Rz * Ry * Rx;\n\treturn (vec4(p,1.0)*m).xyz;\n}\n\nvec3\nat_angle( in vec3 a, in vec3 p )\n{\n    return rotate( -a, p );\n}\n\n#if INDEXED_MATERIALS\nvec2\nunion_op( vec2 p0, vec2 p1 )\n{\n    if ( p0.x < p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n#else\nMaterial_Point\nunion_op( Material_Point p0, Material_Point p1 )\n{\n    if ( p0.distance < p1.distance )\n    {\n        return p0;\n    }\n    return p1;\n}\n#endif\n\n#if INDEXED_MATERIALS\nvec2\nintersect_op( vec2 p0, vec2 p1 )\n{\n    if ( p0.x > p1.x )\n    {\n        return p0;\n    }\n    return p1;\n}\n#else\nMaterial_Point\nintersect_op( Material_Point p0, Material_Point p1 )\n{\n    if ( p0.distance > p1.distance )\n    {\n        return p0;\n    }\n    return p1;\n}\n#endif\n\nMaterial\nchange_color( Material m, vec3 color )\n{\n    Material ret = m;\n    ret.color = color;\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nfloat\nsphere_sd( in float sph_r, in vec3 p )\n{\n    return length( p ) - sph_r;\n}\n\nfloat\naab_sd( in vec3 sides, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return min( max( d ), 0.0 ) + length( max(d,0.0) );\n}\n\nfloat\nplane_sd( in vec3 p )\n{\n    return abs( p.z );\n}\n\n\nfloat\nhalf_space_sd( in vec3 p )\n{\n    return p.z;\n}\n\nfloat\nround_aab_ud( in vec3 sides, in float r, in vec3 p )\n{\n    sides *= 0.5;\n    p = abs( p );\n    vec3 d = p - sides;\n    return length( max(d, 0.0) ) - r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\nfloat\ncylinder_sd( in float r, in vec3 p )\n{\n    return length( p.xy ) - r;\n}\n\nfloat\ncapped_cylinder_sd( in vec2 rh, in vec3 p )\n{\n    vec2 d = abs( vec2( length( p.xy ), p.z ) ) - rh;\n    return min( max(d), 0.0 ) + length( max(d, 0.0) );\n}\n\nfloat\nhalf_cone_pos_sd( in vec2 c, in vec3 p )\n{\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncone_sd( in vec2 c, in vec3 p )\n{\n    p = abs(p);\n    vec2 c1 = vec2(c.y,-c.x);\n    return dot( c1, vec2(length(p.xy), p.z) );\n}\n\nfloat\ncapped_cone_as_intersections_sd( in float h, in float r1, in float r2, in vec3 p )\n{\n    float R1z = (r1*h)/(r2-r1);\n    float R2z = R1z + h;\n    p = at_pos(vec3(0.0,0.0,-R1z),p);\n\tvec2 c = vec2(r2/R2z,1.0);\n\treturn\n\tmax( max( -half_space_sd( at_pos(vec3(0.0,0.0,R1z), p) ), half_space_sd( at_pos( vec3(0.0,0.0,R2z), p ) ) ),\n         half_cone_pos_sd( c, p )\n       );\n}\n\n// NOTE(theGiallo): d.x is the depth of the prism(or height), d.y the radius\n// NOTE(theGiallo): depth on x axis, diameter on y axis\nfloat\nhex_prism_sd( in vec2 dr, in vec3 p )\n{\n    p = abs(p);\n    return max(p.x-dr.x*0.5,max(p.y*0.866025+p.z*0.5,p.z)-0.866025*dr.y);\n}\n\nfloat\ntri_prism_sd( in vec2 ds, in vec3 p )\n{\n  \tp.xy = abs(p.xy);\n    \n    return max( p.x - ds.x*0.5, max( p.y * 0.866025 + 0.5 * p.z - ds.y * 0.433012702, -p.z ) );\n}\n\nfloat\ntri_prism_bary_sd( in vec2 ds, in vec3 p )\n{\n    p.z += ds.y * 0.288675135;\n    \n    return tri_prism_sd( ds, p );\n}\n\nfloat\ntri_prism_bary_r_sd( in vec2 dr, in vec3 p )\n{\n    dr.y = dr.y * 1.732050808;\n    \n    return tri_prism_bary_sd( dr, p );\n}\n\nfloat\ncline_sd( in vec3 a, in vec3 b, in float r, in vec3 p )\n{\n    vec3 ap = p - a, ab = b - a;\n    float t = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    return length( ap - ab * t ) - r;\n}\n\nfloat\nellipsoid_sd( in vec3 r3, in vec3 p )\n{\n    return ( length( p/r3 ) - 1.0 ) * min(r3);\n}\n\nfloat\nsphere8_sd( in float sph_r, in vec3 p )\n{\n    return length8( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus82_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus88_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length8(p.xy)-torus.x,p.z);\n    return length8(q)-torus.y;\n}\n\n\nfloat\nsphere4_sd( in float sph_r, in vec3 p )\n{\n    return length4( p ) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus42_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus44_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length4(p.xy)-torus.x,p.z);\n    return length4(q)-torus.y;\n}\n\nfloat\nsphere3_sd( in float sph_r, in vec3 p )\n{\n    return length3(abs(p)) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus32_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus33_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length3(abs(p.xy))-torus.x,p.z);\n    return length3(abs(q))-torus.y;\n}\n\nfloat\nspheremh_sd( in float sph_r, in vec3 p )\n{\n    return manhattan(p) - sph_r;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorus2mh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n    return length(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmh2_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(length(p.xy)-torus.x,p.z);\n    return manhattan(q)-torus.y;\n}\n\n// NOTE(theGiallo): torus.x = big radius torus.y = solid radius\nfloat\ntorusmhmh_sd( in vec2 torus, in vec3 p )\n{\n    vec2 q = vec2(manhattan(p.xy)-torus.x,p.z);\n        return manhattan(q)-torus.y;\n}\n    \n//////////\n\nvec3 sky_color;\n\n#if INDEXED_MATERIALS\nvec2\n#else\nMaterial_Point\n#endif\nmap( in vec3 pos )\n{\n    #if 0\n    float r = 1.1;\n    float h = decimal( ( floor( pos.x / r + 0.5 ) + 50.0 ) / 10.0 );\n    float s = mirror( ( floor( pos.s / r + 0.5 ) + 50.0 ) / 30.0 );\n    vec3 color = rgb_from_hsv( vec4( h, s, 1.0, 1.0 ) ).rgb;\n    pos.x = mirror( pos.x / r ) * r;\n    pos.y = mirror( pos.y / r ) * r;\n    #else\n    vec3 color = ORANGE_RGB;\n    #endif\n    \n    float angle4 = iTime*TAU*0.25;\n    \n    MPt res;\n    #if INDEXED_MATERIALS\n    res.x = 1e38;\n    #else\n    res.distance = 1e38;\n    #endif\n    \n    #if !INDEXED_MATERIALS\n    Material plastic_m;\n    plastic_m.color = vec3(1.0);\n    plastic_m.diffuse_reflection  = 1.0;\n    plastic_m.specular_reflection = 1.0;\n    plastic_m.ambient_reflection  = 1.0;\n    plastic_m.shininess           = 15.0;\n\n    Material floor_m;\n    plastic_m.color = vec3(1.0);\n    floor_m.diffuse_reflection  = 1.0;\n    floor_m.specular_reflection = 0.2;\n    floor_m.ambient_reflection  = 0.5;\n    floor_m.shininess           = 1.0;\n\n    Material orange_m = plastic_m;\n    orange_m.color = ORANGE_RGB;\n    \n    Material red_m = plastic_m;\n    red_m.color = vec3(1.0,0.0,0.0);\n    Material green_m = plastic_m;\n    green_m.color = vec3(0.0,1.0,0.0);\n    Material blue_m = plastic_m;\n    blue_m.color = vec3(0.0,0.0,1.0);\n    #endif\n\n    float sr = 0.5;\n    float sd = 0.5;\n    #if 0\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI             ), sin( HPI             ) ), pos ) ),\n                          orange_mat ),\n\t      MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI + TAU / 3.0 ), sin( HPI + TAU / 3.0 ) ), pos ) ),\n                          orange_mat ) );\n    res =\n       union_op(\n          MPt( sphere_sd( sr, at_pos( sd * vec3(0.0, cos( HPI - TAU / 3.0 ), sin( HPI - TAU / 3.0 ) ), pos ) ),\n               orange_mat ),\n          res );\n    #endif\n    \n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0        ), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                        plastic_m\n                        #endif\n                       ), res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(1.0,0.0,0.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_RED\n                        #else\n                        red_m\n                        #endif\n                       ),res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,1.0,0.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_GREEN\n                        #else\n                        green_m\n                        #endif\n                       ),res );\n    res = union_op( MPt( sphere_sd( 0.1, at_pos( vec3(0.0,0.0,1.0), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_BLUE\n                        #else\n                        blue_m\n                        #endif\n                       ),res );\n    float m = mod( floor(pos.x * 2.0) + floor(pos.y * 2.0), 2.0 );\n    res = union_op( MPt( plane_sd( pos ),\n                        #if INDEXED_MATERIALS\n                        MAT_FLOOR_B * (1.0 - m) + MAT_FLOOR_W * m\n                        #else\n                         change_color( floor_m, vec3( 0.7 + 0.3 * m ) )\n                        #endif\n                       ),\n                    res );\n\n\n    res =\n       union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,pos.z * HPI * sin(iTime)), at_pos(vec3(2.0,0.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,0.0,iTime*0.05), at_pos(vec3(2.0,2.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                       ),\n                    res );\n    res = union_op( MPt( aab_sd( vec3(1.0), at_angle( vec3(0.0,pos.y * HPI,0.0), at_pos(vec3(-2.0,pos.y,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                       ),\n                    res );\n    res = union_op( MPt( round_aab_ud( vec3(0.9), 0.05, at_pos( vec3(2.0,-2.0,0.4), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                         change_color( plastic_m, rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb )\n                        #endif\n                       ),\n                    res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.4,0.1), at_angle( vec3(0.0,0.0,0.0), at_pos(vec3(2.0,4.0,0.1),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,6.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus_sd( vec2(0.38,0.12), at_angle( vec3(0.0,HPI, iTime + TAU * pos.z), at_pos(vec3(2.0,8.0,0.5),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( cylinder_sd( 0.5, at_angle( vec3(0.0,/*sin(iTime*TAU/7.0)**/QPI*0.25,angle4), at_pos(vec3(2.0,10.0,2.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( capped_cylinder_sd( vec2( 0.5, 1.0 ), at_angle( vec3(0.0,0.25*QPI*iTime,angle4), at_pos(vec3(2.0,12.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( cone_sd( vec2( 0.5, 1.0 ),\n                               at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                         at_pos(vec3(2.0,14.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                                  at_pos(vec3(2.0,16.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                        vec3(1.0,1.0,-1.0) *\n                                        at_angle( vec3(0.0,0.125*PI*sin(iTime*TAU/11.0),iTime*TAU/17.0),\n                                                  at_pos(vec3(2.0,18.0,1.0), pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op(\n          intersect_op(\n             MPt( half_cone_pos_sd( vec2( 0.5, 1.0 ),\n                                    vec3(1.0,1.0,-1.0) * at_pos(vec3(2.0,20.0,2.0), pos) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n             intersect_op(\n                MPt( half_space_sd( at_pos(vec3(2.0,20.0,1.5), pos) ),\n                     #if INDEXED_MATERIALS\n                      MAT_ORANGE\n                     #else\n                      orange_m\n                     #endif\n                ),\n                MPt( -half_space_sd( at_pos(vec3(2.0,20.0,0.5), pos) ),\n                     #if INDEXED_MATERIALS\n                      MAT_ORANGE\n                     #else\n                      orange_m\n                     #endif\n                )\n             )\n          ),\n          res );\n    \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.25, 0.5, at_pos(vec3(2.0,22.0,0.5), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );  \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.5, 0.25, at_pos(vec3(2.0,24,0.5), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );  \n    res =\n       union_op( MPt( capped_cone_as_intersections_sd(\n                         1.0, 0.25, 0.5, at_pos(vec3(2.0,24,1.6 + 0.05 * sin(angle4) ), pos) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( hex_prism_sd(vec2(0.5,0.5), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,26,0.5), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( hex_prism_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,28,0.866025), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( tri_prism_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,30.0,0.0), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res =\n       union_op( MPt( tri_prism_bary_sd(vec2(0.5,1.0), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,32.0,0.288675135), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res = union_op( MPt( sphere_sd( 0.05, at_pos( vec3(2.25,32.0,0.288675135), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                        plastic_m\n                        #endif\n                       ), res );\n    res =\n       union_op( MPt( tri_prism_bary_r_sd(vec2(0.5,0.5), at_angle( vec3(angle4,0.0,0.0), at_pos(vec3(2.0,34.0,0.5), pos) ) ),\n                      #if INDEXED_MATERIALS\n                       MAT_ORANGE\n                      #else\n                       orange_m\n                      #endif\n                    ),\n                 res );\n    res = union_op( MPt( sphere_sd( 0.05, at_pos( vec3(2.25,34.0,0.5), pos ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_PLASTIC\n                        #else\n                        plastic_m\n                        #endif\n                       ), res );\n    res = union_op( MPt( cline_sd( vec3(2.0,36.0,0.5), vec3(2.0,36,1.5), 0.5, pos ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                        orange_m\n                        #endif\n                       ), res );\n    res = union_op( MPt( cline_sd( vec3(0.0,0.0,-1.0), vec3(0.0,0.0,1.0), 0.25, at_angle( vec3( QPI * 0.5, 0.0, angle4), at_pos( vec3(2.0,38,1.5), pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                        orange_m\n                        #endif\n                       ), res );\n    res = union_op( MPt( ellipsoid_sd( vec3(0.5,0.25,1.0), at_angle( vec3( 0.0, 0.0, angle4), at_pos( vec3(2.0,40,1.5), pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                        orange_m\n                        #endif\n                       ), res );\n    \n    res =\n       union_op( MPt( torus82_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,42.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus88_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,44.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( sphere8_sd( 0.5, at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,46.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus42_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,48.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus44_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,50.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( sphere4_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,52.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus32_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,iTime*TAU/4.0), at_pos(vec3(2.0,54.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus33_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,56.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( sphere3_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,58.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torus2mh_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,60.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torusmh2_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,62.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( torusmhmh_sd( vec2(0.6,0.15), at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,64.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n    \n    res =\n       union_op( MPt( spheremh_sd( 0.5, at_angle( vec3(0.0,HPI,angle4), at_pos(vec3(2.0,66.0,1.0),pos) ) ),\n                        #if INDEXED_MATERIALS\n                         MAT_ORANGE\n                        #else\n                         orange_m\n                        #endif\n                    ),\n                 res );\n\treturn res;\n}\n\nvec3\ncalc_normal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,T_EPS*t),0.0,0.0);\n\treturn normalize( vec3(\n           map( pos + eps.xyy ).distance - map( pos - eps.xyy ).distance,\n           map( pos + eps.yxy ).distance - map( pos - eps.yxy ).distance,\n           map( pos + eps.yyx ).distance - map( pos - eps.yyx ).distance ) );\n}\n\n\n#if INDEXED_MATERIALS\nvec2\n#else\nMaterial_Point\n#endif\nraymarch( in vec3 start, in vec3 dir, inout float t, in float t_max )\n{\n    MPt mp;\n    for ( int it=0; it!=120; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        #if 1\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        t += mp.distance * 0.4;\n        #else\n        t += mp.distance;\n        #endif\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    return mp;\n}\n\nfloat\nshadow( in vec3 start, in vec3 dir )\n{\n    float ret = 1.0;\n    float c = step( mod( iTime, 4.0 ), 2.0 );\n    float t = 0.02, t_max = 16.0;\n    MPt mp;\n    \n    for ( int it=0; it!=16; ++it )\n    {\n        vec3 here = start + dir * t;\n        mp = map( here );\n        ret = min( ret, 8.0*mp.distance/t);\n        if ( mp.distance < ( T_EPS * t ) || t > t_max )\n        {\n        \tbreak;\n        }\n        \n        float inc;\n        // NOTE(theGiallo): this is to sample nicely the twisted things\n        inc = c * mp.distance * 0.4;\n\t\tinc += ( 1.0 - c ) * clamp( mp.distance, 0.02, 0.1 );\n        t += inc;\n    }\n    if ( t > t_max )\n    {\n        t = -1.0;\n    }\n    if ( c == 0.0 ) return 1.0 - clamp( ret, 0.0, 1.0 );\n\n    if ( t < 0.0 )\n    {\n        return 0.0;\n    }\n    //return 1.0;\n    ret = 1.0 / pow(1.0 - 1e-30 + max( mp.distance, 1e-30 ), 5.0 );\n    float th = 0.1;\n    return smoothstep( 0.0, 1.0, ( ret*1.1 - th ) / (1.0-th) );\n}\n\n\nfloat\nimg_scale_given_h_fov( float near, float fov )\n{\n    float hw = iResolution.x / min( iResolution.y, iResolution.x );\n    return tan( fov * 0.5 ) * near / hw;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 qc = 2.0 * q - 1.0;\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / min( iResolution.y, iResolution.x );\n    vec4 col = rgb_from_hsv(vec4(0.57,0.5,0.7,1.0));\n    sky_color = col.rgb;\n    vec3 sun_specular_color = vec3(0.8,1.0,1.0);\n        \n    vec3 sun_light_dir = normalize( vec3( 0.0, 1.0, -1.0 ) );\n    \n    float img_plane_dist = 0.05;\n    float img_scale = img_scale_given_h_fov( img_plane_dist, TAU / 3.0 );\n\n    float time = iTime * PI * 0.06125;\n    \n    const int p_count = 34;\n    float u = mirror( iTime / ( float(p_count) * 4.0 ) );\n\n    vec2 d = vec2(0.0,2.0);\n    #if 0\n    vec2 base = vec2(2.54,-2.0);\n    #elif 0\n    vec2 base = vec2(24.0,-2.0);\n    u = 0.5;\n    #else\n    vec2 base = vec2(4.0,-2.0);\n    #endif\n    //u = 1.0;\n    vec3 camera_pos;\n    float pu = 1.0 / float(p_count-1);\n    float pt = 0.0;\n    vec2 pxy = vec2(0.0);\n    for ( int i = 0; i!=p_count; ++i )\n    {\n        float s = pu * ( -0.5 + float(i) );\n        pxy +=\n           ( base + d * float(i) ) *\n           ( smoothstep( s - 0.1 * pu, s + 0.1 * pu, u ) - smoothstep( s + pu * 0.9, s + pu * 1.1, u ) );\n    }\n    camera_pos.xy = pxy;\n    camera_pos.z = 1.5;\n    vec3 look = normalize( vec3(-0.5,0.0,-0.1) );\n\n    vec3 up = vec3(0.0,0.0,1.0);\n    vec3 right = cross( look, up );\n    vec3 img_up = cross( right, look );\n    vec3 dir = look * img_plane_dist + right * p.x * img_scale + img_up * p.y * img_scale;\n    vec3 start = camera_pos + dir;\n    dir = normalize( dir );\n    \n    Material materials_table[MAT_COUNT];\n\n    materials_table[int(MAT_PLASTIC)].color = rgb_from_hsv( vec4(0.083,0.1,1.0,1.0) ).rgb;\n    materials_table[int(MAT_PLASTIC)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].specular_reflection = 1.0;\n    materials_table[int(MAT_PLASTIC)].ambient_reflection  = 1.0;\n    materials_table[int(MAT_PLASTIC)].shininess           = 15.0;\n\n    materials_table[int(MAT_FLOOR_B)].color = vec3(0.7);\n    materials_table[int(MAT_FLOOR_B)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_B)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_B)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_B)].shininess           = 1.0;\n\n    materials_table[int(MAT_FLOOR_W)].color = vec3(1.0);\n    materials_table[int(MAT_FLOOR_W)].diffuse_reflection  = 1.0;\n    materials_table[int(MAT_FLOOR_W)].specular_reflection = 0.2;\n    materials_table[int(MAT_FLOOR_W)].ambient_reflection  = 0.5;\n    materials_table[int(MAT_FLOOR_W)].shininess           = 1.0;\n\n    materials_table[int(MAT_ORANGE)] = change_color(materials_table[int(MAT_PLASTIC)], ORANGE_RGB );\n    materials_table[int(MAT_RED   )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(1.0,0.0,0.0) );\n    materials_table[int(MAT_GREEN )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,1.0,0.0) );\n    materials_table[int(MAT_BLUE  )] = change_color(materials_table[int(MAT_PLASTIC)], vec3(0.0,0.0,1.0) );\n    \n    float t = 0.0;\n    MPt mp = raymarch( start, dir, t, 1e2 );\n    Material mat;\n    #if INDEXED_MATERIALS\n    for ( int i = 0; i != MAT_COUNT; ++i )\n    {\n        if ( i == int(mp.y) )\n        {\n            mat = materials_table[i];\n        }\n\t}\n    #else\n    mat = mp.material;\n    #endif\n    if ( t > 0.0 )\n    {\n        vec3 point = start + dir * t;\n        vec3 normal = calc_normal( point, t );\n        // col.rgb = 0.5 + normal * 0.5;\n        float sh = 1.0 - shadow( point, -sun_light_dir );\n        float diffuse = sh * max( 0.0, dot( normal, -sun_light_dir ) );\n        float spec = sh * pow( max( 0.0, dot( reflect( dir, normal ) , -sun_light_dir ) ), mat.shininess  );\n        float ambient = 0.3;\n        col.rgb = ( diffuse * mat.diffuse_reflection +\n                    ambient * mat.ambient_reflection ) * mat.color +\n                    spec    * mat.specular_reflection * sun_specular_color;\n    } else\n    if ( t == 0.0 )\n    {\n        col.rgb = mat.color / ( 1.0 - 20.0 * mp.distance );\n    }\n    \n    // NOTE(theGiallo): gamma correction\n\t// col.rgb = pow( col.rgb, vec3(0.4545) );\n\n    fragColor = vec4(col.rgb,1);\n}","name":"Image","description":"","type":"image"}]}