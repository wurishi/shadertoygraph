{"ver":"0.1","info":{"id":"wt3Sz2","date":"1581342980","viewed":140,"name":"Plane Stripe AA","username":"spalmer","description":"draws an analytically antialiased striped plane. WIP\ncan compare methods split-window using mouse click.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["antialias","plane","stripe","splitscreen"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// derived from https://shadertoy.com/view/3tVGRz\n// see also https://shadertoy.com/view/wl3Sz2\n\n// a simple testbed for rendering an antialiased striped plane.\n// can contrast various filtering methods.\n// no texture samplers used!\n\n// probably should stay below .5 though, or may as well reverse the colors!\nconst float stripeThickness = .2; //.1; //.25; //.02; //\n\nconst vec3 Cfill = vec3(1.,1.,.9); //1.,1.,1.); //1.,1.,0.); //\nconst vec3 Cstripe = vec3(0.,0.,0.); //1.,0.,1.);\nconst vec3 Csky = vec3(.8,.9,1.);\n\n// refactored out the common derivative filtering portion:\n// trivial to change to any dimension.  \n// can ignore the axis not being striped\nfloat filterWidth1(float u)\n{\n    float dx = dFdx(u), dy = dFdy(u);\n    return dx * dx + dy * dy + .0001;\n}\n\nfloat filterWidth2(vec2 uv)\n{\n     vec2 dx = dFdx(uv), dy = dFdy(uv);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n   // btw fwidth totally works too\n//    vec2 fw = fwidth(uv); return dot(fw, fw) + .0001; //max(fw.x, fw.y) + .0001; //\n//    return max(dot(dx, dx), dot(dy, dy)) + .0001; // tried; looks same to me\n\nfloat filterWidth3(vec3 uvw)\n{\n    vec3 dx = dFdx(uvw), dy = dFdy(uvw);\n    return dot(dx, dx) + dot(dy, dy) + .0001;\n}\n\n// exp2 filters return 1 when should blur completely out\n// g is a positive distance to an edge to be smoothed\n// something wrong with one side though; sign/bias problem?\nfloat smoothGrid(float x, float s, float g, float w)\n{\n    return mix(x, s, exp2(-g / w));    \n}\n\nfloat smoothCheck(float x, float g, float w)\n{\n    return mix(x, .5, exp2(-g / w));    //smoothGrid(x, .5, g, w); //\n}\n\n// basically a 1D checkerboard because gridThickness is always .5\nfloat stripeThickUnfiltered(vec2 p)\n{\n    return float(int(floor(p.x))&1);\n}\n\n// it's simple because it uses simple tent function\n// and simple fwidth with relatively simple rational function inlined\nfloat stripeThickAASimple(vec2 p)\n{\n    vec2 f = fract(p); //p - floor(p); //\n    float x = stripeThickUnfiltered(p)\n    , g = min(f.x, 1.-f.x) * 2. //1.-2.* abs(f.x-.5) //\n    , w = fwidth(p.x) // + fwidth(p.y) //max(fwidth(p.x), fwidth(p.y)) //\n    , r = 2.*iResolution.y\n    , l = r*g / (1. + r*w); // can try different functions\n    return mix(.5, x, clamp(l, 0., 1.));\n}\n\n// somewhat filtered thick stripes \nfloat stripeThickFade(vec2 p)\n{\n    float x = stripeThickUnfiltered(p);\n    vec2 f = fract(p);\n    float g = f.x * (1. - f.x) * 4.; // parabola\n    return smoothCheck(x, .125 * g, filterWidth1(p.x));\n}\n\n\nfloat stripeThinUnfiltered2(vec2 p)\n{\n    return step(.5-.5*stripeThickness, abs(fract(p.x)-.5));\n}\n\nfloat stripeThinUnfiltered(vec2 p)\n{\n    p -= .5*stripeThickness; // center\n    return step(1.-stripeThickness, fract(p.x));\n}\n\nfloat stripeAASimple(vec2 p)\n{\n    vec2 f = fract(p);\n    float g = min(f.x, 1.-f.x) * 2. - stripeThickness\n    , x = step(g, 0.) //stripeThinUnfiltered(p)\n    , w = fwidth(p.x)\n    , r = 2.*iResolution.y\n    , l = r*abs(g) / (1. + r*w) // can try different functions\n    // up close, should blend toward 0.5,\n    // but far away should blend toward stripeThickness!\n    , t = mix(.5, stripeThickness, min(w, 1.));\n    return mix(t, x, clamp(l, 0., 1.));\n}\n\nfloat stripeSmooth(vec2 p)\n{\n    vec2 q = p;\n    q += .5;\n    q -= floor(q);\n    q = (stripeThickness + 1.) * .5 - abs(q - .5);\n    float w = 12.*filterWidth2(p);\n    float s = stripeThickness;\n    return smoothstep(.5-w*s,.5+w, q.x);\n}\n\n// the half stripeThickness bias is fairly tricky; \n// honestly I shouldn't need to involve smoothstep at all here, hold on\n// meh, still not working worth a dern, maybe someday\nfloat stripeLinear(vec2 p)\n{\n    vec2 q = p;\n    q += .5;\n    q -= floor(q);\n    q = (stripeThickness + 1.) * .5 - abs(q - .5);\n    float w = 12.*filterWidth2(p);\n    float s = stripeThickness;\n    return clamp((q.x - .5-w*s) / (w*(s+1.)), 0., 1.);\n}\n\n// filtered thin stripes! finally something half-decent.  PITA!\nfloat stripeThinFade(vec2 p)\n{\n    float x = stripeThinUnfiltered(p);\n    vec2 f = fract(p);\n    float g = max(0., .5 - abs(f.x - .5) - .5 * stripeThickness);\n    //g = pow(g, 1. + 1.5 * abs(stripeThickness - .5));\n    float s = stripeThickness;\n    return smoothGrid(x, s, .125 * g, filterWidth1(p.x)); // lame, really; just fades out    \n}\n\n// FIXME all these using filterWidth2 are probably wrong or overly complex\n// since we really just want the pixel's rate of change over the\n// x dimension of the grid, perpendicular to the stripes.\n\nfloat stripeExp(vec2 p)\n{\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    float g = f.x;\n    g = max(0., g - .5*stripeThickness);\n    g = exp2(-fadePower*g);\n    float s = stripeThickness;\n    return mix(g, s, exp2(-.02 / filterWidth2(p)));    \n}\n\nfloat stripePow(vec2 p)\n{\n    const float fadePower = 16.;\n    vec2 f = fract(p);\n    f = .5 - abs(.5 - f);\n    f = max(vec2(0), 1. - f + .5*stripeThickness);\n    f = pow(f, vec2(fadePower));\n    float g = f.x;\n    float s = stripeThickness;\n    return mix(g, s, exp2(-.01 / filterWidth2(p)));    \n}\n\n// originally from https://shadertoy.com/view/WlVGDh\n// this is just not the way to do grids, blurs\n// the corners too much, but it sort of works:\nfloat stripeSine(vec2 p)\n{\n    p *= 3.1415927;\n    float g = sin(p.x); // grid texture\n    g *= g; g = max(0., 1. - g);\n    g = pow(g, 8./stripeThickness);\n    float s = stripeThickness;\n    g = mix(g, s, min(1., 1.*filterWidth2(p))); //length(fwidth(p)))); // aa\n\treturn g;\n}\n\n// similar but with parabola - still just wrong at corners\nfloat stripePara(vec2 p)\n{\n    vec2 q = fract(p);\n    q = max(vec2(0), .5 - stripeThickness*.5 - abs(.5 - q));\n    q *= 1.-q; q = 4.*q;\n    float g = 1.-q.x; //*q.y;\n    g = pow(g, 1./stripeThickness);\n    float s = stripeThickness;\n    g = mix(g, s, min(1., 4.*filterWidth2(p))); //length(fwidth(p)))); // aa\n\treturn g;\n}\n\n// shown on right side of split screen\nfloat ImageR(vec2 uv)\n{\n    return stripeAASimple(uv);\n    return stripeSmooth(uv);\n    return stripePow(uv);\n    return stripePara(uv);\n    return stripeExp(uv);\n    return stripeSine(uv);\n    return stripeLinear(uv);\n///    return stripeThinFade(uv); // borked\n    return stripeThickAASimple(uv);\n    return stripeThickFade(uv);\n}\n// shown on left half of split screen\nfloat ImageL(vec2 uv)\n{\n    return stripeThinUnfiltered(uv);\n    return stripeThickUnfiltered(uv);\n}\n\n\nconst float maxd = 85000.;\n\n// halfspace\nfloat tracePlaneY(vec3 rp, vec3 rd)\n{\n    return rp.y <= 0. ? 0. :\n    \trd.y >= 0. ? -1. :\n    \trp.y / -rd.y;\n}\n\n\nvec2 rot(inout vec2 v, vec2 cs)\n{\n    float c = cs.x, s = cs.y; // cs is a cosine,sine pair representing angle of rotation\n    return v = vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvec2 rot(inout vec2 v, float radians)\n{\n    return rot(v, vec2(cos(radians), sin(radians)));\n}\n\n\nvec3 CameraRay(vec2 p)\n{\n    vec2 q = (2. * p - iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(q / 2., 1.));\n    float pitch = .4, yaw = iTime * .04;\n    rot(rd.yz, pitch);\n    rot(rd.xz, yaw);\n    return rd;\n}\n\n\n\nvoid mainImage(out vec4 c, in vec2 p)\n{\n    // a simple camera\n    vec3 rp = vec3(0,1,0);\n    rp.y += sin(iTime * 0.07) * .99; // bob slowly up and down\n    vec3 rd = CameraRay(p);\n    \n    // Y plane distance\n    float d = maxd;\n    float dplane = tracePlaneY(rp, rd);\n    vec2 cc = vec2(1, 0);\n    if (dplane >= 0.) {\n        d = min(d, dplane);\n\t    cc = rp.xz + rd.xz * d; // grid uv at hit point\n    \tcc *= 4.; // tiling\n    }\n    \n    // split screen at mouse click\n    float splits = p.x - iMouse.x;\n    bool left = splits < 0.;\n    // depending on last mouse click, split screen between two different functions\n    float stripes = left \n        ? ImageL(cc)\n        : ImageR(cc);\n\n    c.rgb = mix(Cfill, Cstripe, stripes); // colorize\n    \n    // no actual lighting in this simple test,\n    // but a few dot products would do it.\n    \n    float fog = 1.0 - exp2(-.03*d); //0.; //\n    c.rgb = mix(c.rgb, Csky, fog);\n    // green vertical line at split\n    c.rgb = mix(c.rgb, vec3(.0,.5,.0), exp2(-2. * abs(splits)));\n    \n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamma\n    c.a = 1.;\n}\n\n\n// clever; I broke it anyway.\n// from a Dave Hoskins bresenham shader\n//\tvec2 g2 = step(1., mod(q, R/1./float(grid)));\n//\tg *= g2.x*g2.y;\n// aliased gridlines but otherwise nice.\n\n\n//  if (!(d >= 0.)) d = maxd; // handle possible nan\n//  float dflat = d / rd.z;\n//  float aa = 1.0 - exp2(-.03*d); // HACK\n//    float g = exp2(-.03*d);\n//    c = vec3(g); // debug depths\n","name":"Image","description":"","type":"image"}]}