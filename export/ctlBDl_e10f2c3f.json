{"ver":"0.1","info":{"id":"ctlBDl","date":"1694124469","viewed":97,"name":"radioactive mbox sewer","username":"pb","description":"mandelbox yet again provides interesting structures to play with","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","godrays","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    fragColor = .3*texture(iChannel0, uv) + .8*vec4 ( vec3(1.) - texture( iChannel1, uv ).rgb, 1.);\n    \n    \n    fragColor = pow( fragColor, vec4( 2. ));\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float[] params = float[] ( \n-.24,\n10.,\n.1,\n.0,\n0.,\n0.,\n-.27,\n0.6,\n0.,\n0.,\n0.,\n0.,\n0.,\n1.,\n0.,\n0.1,\n2.,\n0.,\n-1.,\n-0.,\n0.,\n1.,\n0.,\n.2,\n.1,\n.04,\n-4.,\n0.5,\n0.4,\n0.1,\n0.,\n0.2,\n0.\n);\n\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float extraReflection = 0. ; //set this to one, but it makes a mess of things\n\nfloat num_iter, objid, inf=1e6, too_small=1e-6, \n    distToFloor, glow=0., maxDist=50., mmaxDist=50., tileColor=0.;\nvec3 ifs_color, ro;\n\nfloat sceneA = 0., sceneB=1., lz=0.;  //lz: we need the 2d position of the light for the fake god rays process\n\nfloat de(vec3 p) {\n\n    vec4 q = vec4( p, 2.);\n    \n    float nn=.5;\n    q.xz = mod(q.xz + nn, 2.*nn) - nn;\n    \n    vec4 q0 = q;\n\n\n    float i=0.;\n    for(; i < params[1]; i++) {\n    \n        q.xyz = clamp (q.xyz, -1.-params[5], 1.+params[5]) * (2.+params[2]) \n            - (1.+params[3])*q.xyz; \n\n\n        q = q * (2.52+params[6] )\n            / clamp ( sceneB*dot(q.xyz,q.xyz) + sceneA*max( dot(q.yz,q.yz), max(dot (q.xz, q.xz),  dot(q.xy,q.xy) ) ), \n            (-1.+params[15])-params[0], 1.+params[0]) + q0;\n\n    }\n    \n    \n    float d2 = length( q.xyz )/q.w;\n \n    float floor = p.y+.3-.5+.7+.05*sin(p.x*.8+.2+iTime*1.4)+.03*sin(p.z*2.7+iTime*2.5) - .3*exp(-d2);\n    \n \n    objid = d2 < floor ? 0. : 1.;\n\n    \n    return max( min(floor,d2) , -(length(p-ro)-params[7]) );\n}\n\nfloat march(vec3 ro, vec3 rd, float mx) {\n    float t = 0.0;\n  \n    float eps = 1e-5, distfac=20.;\n    float hitThreshold = eps;\n    for(int i = 0; i < 200; i++) {\n        float d = de(ro + rd*t);\n        if (d < hitThreshold || t >= mx) break;\n        t += d;\n        hitThreshold = eps*(1.+t*t*distfac);\n        glow += exp(-max(1.-d,0.)/25.);\n    }\n    return t;\n}\n\nvec3 phong(in vec3 pt, in vec3 prp, in vec3 normal, in vec3 light,\n              in vec3 color,in float spec, in vec3 ambLight)\n{\n\n   vec3  lightv = normalize(light-pt);\n   float lightDist =  length(lightv);\n   float diffuse=dot(normal,lightv);\n   vec3  refl=-reflect(lightv,normal);\n   vec3  viewv=normalize(prp-pt);\n   float specular=pow(max(dot(refl,viewv),0.0),spec+params[20]);\n   \n   return  4.*exp(-lightDist*lightDist/10.)*( (max(diffuse,0.))*(color) + 1.1*specular*vec3(.5,.7,.9)); \n  \n}\n\nvec3 normal(vec3 p, float dist) {\n    vec2 h = vec2(0.001*exp(-dist*dist/10.) + params[25] , 0.0);\n    return  normalize( vec3(\n        de(p + h.xyy) - de(p - h.xyy),\n        de(p + h.yxy) - de(p - h.yxy),\n        de(p + h.yyx) - de(p - h.yyx) )\n    );\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n\n \n    vec3 col = vec3(0.);\n    vec3 light_dir =  ro ; light_dir.z += lz;\n    vec3 color     = vec3( params[27], params[28], params[29]);\n    float specular_power = 32.;\n    vec3 ambient_light = vec3(.1);\n    vec3 floor_color = vec3(0.,0.5,1.);\n    float t = march(ro, rd, mmaxDist);\n    vec3 glowCol = vec3(.7,.6,.0);\n    \n    glow *=  exp(-t*t);\n    maxDist = t;\n    \n    if(t < mmaxDist) {\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos, t); \n        \n        if (objid == 1.) {color = .3*color + floor_color; glowCol = .3*floor_color; }\n        vec3 cf = phong( pos, ro, nor, light_dir, color, specular_power, ambient_light);       \n        col = cf;\n       \n        \n        if (params[21] > 0. ) {  //first reflection\n            vec3 pos2 = ro + rd*.999*t; \n            vec3 ref = reflect(rd, nor);\n            float tt =  march( pos2, ref, mmaxDist);\n            glow *= exp(-tt*tt*3e-2);\n\n\n            if ( tt < mmaxDist) {\n                vec3 ppos = pos2 + ref*tt;\n                vec3 nnor = normal(ppos, tt);\n                vec3 rref = reflect(ref, nnor);\n                \n                vec3 cf2 = phong( ppos, ro, nnor, light_dir, color, specular_power, ambient_light); \n                col += params[23] * cf2;                    \n                \n\n              if ( (params[21] + extraReflection) > 1.) {  //second reflection\n                vec3 pos3 = pos2  + ref*.999*tt;\n                float ttt = march( pos3, rref, mmaxDist);\n                glow *= .5*exp(-ttt*ttt/200.);\n                \n                if (ttt < mmaxDist ) {\n                   vec3 pppos = pos3 + rref * ttt;\n                   vec3 nnnor = normal(pppos, ttt);\n \n                   vec3 cf3 = phong( pppos, ro, nnnor, light_dir, color, specular_power, ambient_light);\n                   col += params[24] * cf3;\n                   \n                }\n              }\n            }\n        }\n        \n        col = clamp(col, 1e-6,inf);\n        col *= col;\n    }\n    \n\n    return col  + 1e-11*pow(glow,6.)*glowCol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p  = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    ro = vec3(0.,0., iTime/20.);\n    vec3 rd = normalize( vec3(p,1.5*(1.+.3*sin(iTime/5.))) );\n        \n    sceneA = 0.; //mod(iTime,50.) < 25. ? 0. : 1. ;\n    sceneB = 1.; //mod(sceneA+1.,2.);\n    lz =  min(40.,mod(iTime*5.,50.));\n    \n    vec3 col = render(ro, rd);\n    col = 1. - exp(-.3 * (1.+params[16]) * col);\n    \n    fragColor = vec4( col, lz);  //save z position of light for god rays positioning\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//philip,bertani@gmail.com\n//Buffer A is where it is at\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 texel = 1./iResolution.xy;\n    vec4 total_color;\n    float lz = texture(iChannel0, uv).a;\n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    fragColor = vec4(total_color.xyz,lz);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 uv )\n{\n\n    fragColor = vec4(1.) - texture(iChannel0,uv/iResolution.xy);\n    fragColor.a =  texture(iChannel0,uv).a;\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// thanks three.js\n\n#define TAPS_PER_PASS 900.\n\n#define fStepSize .003 // filter step size\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv ) {\n\n    uv /=  iResolution.xy;\t\n    \n    float lz = texture(iChannel0,uv).a;\n    \n    //vec2 delta = ( vec2(.5+.02*sin(iTime*2.),.5+.02*cos(iTime*2.)) - uv);   //hard coded light position for now\n    \n    vec2 delta = vec2(.5,  0. + lz/80.) - uv; \n    \n    //if (iMouse.w != 0.) delta = iMouse.xy / iResolution.xy - uv;\n    \n    float dist = length( delta );      //distance to light source\n\n    vec2 stepv = fStepSize * delta / dist;\n\n    float iters = dist/fStepSize;\n            \n    float col = 0.0;\n\n\n    for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\n\n\n        col += ( i <= iters ? dot(texture( iChannel0, uv ).rgb,vec3(1.2)) : 0.0 );\n\n        uv += stepv;\n\n    }\n\t\t\n\t\n    fragColor = vec4( col/TAPS_PER_PASS );\n    \n    fragColor.a = 1.0;\n\n}","name":"Buffer D","description":"","type":"buffer"}]}