{"ver":"0.1","info":{"id":"mdtXW7","date":"1680080229","viewed":91,"name":"Pampa 3 Pack ICE","username":"DENFOR","description":"2023.03.28  test pending","likes":4,"published":1,"flags":0,"usePreview":1,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" // created by dr2    https://www.shadertoy.com/view/ldScDt\n // created by Kali   https://www.shadertoy.com/view/ddBSWR\n#define trail\n#define letterboxfullscreen\n//#define startinlake\n//#define noplane\n//#define onlymouse\n\n#define resolution iResolution\n#ifdef startinlake\n    #define time mod(iTime*.83+120.,200.)\n#else\n    #define time mod(iTime*.83,200.)\n#endif\n\nfloat hashseed=0.;\nfloat det=.01;\nfloat maxdist=40.;\nvec3 objcol;\nvec3 ldir;\nfloat id=0.,oc=1.,dcab=0.,t=0.,h=0.,speed=0.,baja=0.,ref=0.;\nvec3 pos, pfus, pmot, pcab, parm, pwin, ptim, ptai, tpos;\nvec3 ppos=vec3(0.),ppos2=vec3(0.);\nmat2 rotyz, rotxy, rotxz;\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat interhash(float seed, float t) {\n    t+=hash(seed+hashseed)*123.;\n    return mix(hash(floor(t)),hash(floor(t+1.)),smoothstep(.3,1.,fract(t)));\n}\n\nfloat path(float t) {\n    return sin(t+cos(t*.5687))*.5  ;\n}\n\n\nmat2 rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat ssub ( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat box( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat capsule( vec3 p, float h, float r )\n{\n  p.z -= clamp( p.z, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat elipse( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n////////////////////////////////////////////  Pack ICE\nfloat PrSphDf (vec3 p, float s);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\n\nconst float pi = 3.14159;\n////////////////////////////////////////////////Pack ICE\n\n\nfloat cabina(vec3 p) {\n    p.z+=1.9;\n    p.y-=1.;\n    p.y+=pow(max(0.,-p.z+1.)*.31,2.);\n    p.y-=pow(max(0.,-p.z+3.5)*.3,1.5)*.1;\n    float d=elipse(p,vec3(.35,.5,2.9));\n    pcab=p;\n    dcab=d;\n    return d*.8;\n}\n\n\nfloat fuselaje(vec3 p, float cab) {\n    vec3 p2=p;\n    p.z+=5.5;\n    p.y-=smoothstep(2.,0.,p.z)*.2*abs(p.y);\n    p.y-=smoothstep(0.,4.,p.z)*.3;\n    p.y*=1.+smoothstep(4.,0.,p.z)*.2;\n    p.y-=smoothstep(2.,5.2,p.z)*.5*max(0.,p.y);\n    p.y-=min(.5,max(0.,p.z-5.2)*.06);\n    p.y*=1.+smoothstep(4.,13.,p.z)*.5;\n    p.y-=smoothstep(6.,9.,p.z)*.7*max(0.,-p.y+.3);\n    p.z*=1.+min(.2,max(0.,p.z-10.5-p.y)*.3);\n    vec3 t=vec3(.55,.7,5.5);\n    t.y*=1.-smoothstep(2.,11.,p.z)*.4;\n    p.x*=1.+smoothstep(8.,9.,p.z)*.25;\n    p.z-=5.5;\n    float d=elipse(p,t);\n    pfus=p;\n    p2.y+=.1;\n    d=max(d,-length(p2.xy)+.7*step(0.,p2.z));\n    oc*=step(0.,d+.2);\n    d=max(d,-cab);\n    return d*.5;\n}\n\nfloat motor(vec3 p) {\n    p*=1.05;\n    p.z-=.4;\n    p.y-=.25+exp(-5.*abs(p.x))*.1*smoothstep(2.,0.,p.z)+p.z*.03;\n    float h=length(pow(abs(p.xy),vec2(1.5))*vec2(1,3.))-.62+max(0.,p.z+1.);\n    h=min(h,length(p.xy)-.27);\n    float sc=1.+min(2.,pow(max(0.,p.z+2.3)*.23,3.));\n    p.x*=sc;\n    p.y*=1.+min(.5,pow(abs(p.z)*.37,6.));\n    p.y*=1.+min(1.,pow(max(0.,p.z+1.),2.)*.05);\n    p.x*=1.+min(1.,pow(abs(p.y),2.5));\n    float d=box(p,vec3(.65,.45,2.3),.2+max(0.,p.z)*.05);\n    oc*=max(0.,sign(d+.1));\n    d=ssub(h,d,.1*step(0.,-p.z));\n    pmot=p;\n    return d*.5/sc;\n}\n\nfloat alas(vec3 p) {\n    p.y-=1.2-abs(p.x)*.07;\n    p.z-=.3;\n    p.x+=smoothstep(0.,1.8,-p.z)*sign(p.x);\n    float w=abs(p.x)*.1;\n    p.y*=.7+min(1.5,pow(abs(p.z+.3),3.)+abs(p.x)*.3);\n    float d=box(p,vec3(4.5,-.1,.9-w),.2);\n    p.z+=w;\n    pwin=p;\n    return d*.4;\n}\n\nfloat cola(vec3 p) {\n    p.y-=1.-abs(p.x)*.15;\n    p.z-=4.;\n    p.z-=abs(p.x)*.3*smoothstep(-.2,0.2,-p.z);\n    float w=abs(p.x)*.1;\n    p.y*=.7+min(1.,pow(abs(p.z+.3),3.)+abs(p.x)*.5);\n    float d=box(p,vec3(1.7,-.13,.5),.2);\n    ptai=p;\n    return d*.5;\n}\n\nfloat timon(vec3 p) {\n    p.y-=1.;\n    p.z-=3.8;\n    p.z-=p.y*(step(p.z-.5,0.)+1.)*.4;;\n    float d=box(p,vec3(-.05-p.z*.02,1.5,.8),.1);\n    d=max(d,-p.y);\n    ptim=p;\n    return d*.5;\n\n}\n\nfloat arma1(vec3 p) {\n    p.y-=.3;\n    float b=box(p-vec3(0,0,p.y*.5),vec3(.0,.2,.35),0.05);\n    p.y+=.3;\n    p.z+=.9;\n    p.z-=length(p.xy)*.5;\n    float c=capsule(p,1.3,.23);\n    float d=min(b,c);\n    objcol+=max(0.,sign(.1-d))*vec3(1,0,0);\n    return d*.5;\n}\n\n\nfloat armas(vec3 p) {\n    vec3 p2=p;\n    p.x=abs(p.x)-1.5;\n    p.y-=.7;\n    p2.x=abs(p2.x)-2.;\n    p2.z-=.2;\n    p2.y-=.45;\n    float ar2=arma1(p2);\n    parm=p2;\n    return ar2;\n}\n\n/// Simple noise algorithm by Trisomie21\nfloat snoise( vec2 p ) {\n    p.y-=hashseed*100.;\n    p.xy=p.yx;\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1., v+1000.0, v+1001.);\n\tr = fract(12345.*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\n/*\nfloat terrain( vec2 p) {\n\tfloat h = 0.0; \n\tfloat w = .5; \n\tfloat m = .5; \n\tfor (int i=0; i<5; i++) {\n\t\th += w * snoise((p * m));\n\t\tw *= .25;\n\t\tm *= 4.;\n\t}\n    return h;\n}\n*/\n////////////////////////////////////// Pack ICE terrain(2)\nfloat VorDist (vec2 p)\n{\n  vec3 dv;\n  vec2 ip, fp, g, b;\n  ip = floor (p);\n  fp = fract (p);\n  dv = vec3 (8.);\n  b.x = 0.;\n  for (float gy = -1.; gy <= 1.; gy ++) {\n    for (float gx = -1.; gx <= 1.; gx ++) {\n      g = vec2 (gx, gy);\n      dv.z = length (g + 0.9 * Hashv2v2 (ip + g) - fp);\n      b.y = step (dv.z, dv.y) * (dv.z - dv.y);\n      dv.xy += b + step (dv.z, dv.x) * (dv.zx - dv.xy - b);\n    }\n  }\n  return dv.y - dv.x;\n}\n\nfloat terrain(vec2 p)  // GrndHt (vec2 p)\n{\n  float s;\n  s = Noisefv2 (0.3 * p.yx);\n  p += 1.5 * sin (2. * pi * s) +\n     0.1 * sin (2. * pi * Noisefv2 (2. * p.xy));\n  return 2. * smoothstep (0.2, 0.35 + 0.3 * s, VorDist (0.03 * p*5.))*1.5; // ice pack height *1.5\n}                                              //              p*5. =>mountains increase\n\n////////////////////////////////////////  Pack Ice    (2)\n\n\nfloat terrain(vec3 p) {\n    if (p.y>2.*1.5) return p.y+2.*1.5;  // change mountain flat\n    p.z+=time*3.;\n    float ini=smoothstep(100.,70.,p.z);\n    p.x+=ini*4.5*0.5;\n    p.y+=.4+smoothstep(120.*3.,130.*3.,p.z)*.65;\n    p.x-=path(p.z);\n\th = terrain(p.xz*vec2(.5,1.)) * 1.2;\n\th += smoothstep(-0.3, 1.5, h);\n    h*=1.-ini*.7;\n\tfloat ap=.3+max(0.,sin(p.z*.05+cos(p.z*.123)*.0))*.5;\n    h=mix(h,-1.,exp(-ap*(abs(p.x-.5*snoise(p.zz*.5)))));\n\tfloat d = p.y - h;\t\n    tpos=p;\n\treturn d*.5;\n}\n\nfloat pampa(vec3 p) {\n    p.z+=2.8;\n    p.y-=.8;\n    p.yz*=rotyz;\n    p.xz*=rotxz;\n    p.z-=2.8;\n    p.y+=.8;\n    p.xy*=rotxy;\n    float bound=box(p,vec3(5.,3.,6.),0.);\n#ifdef noplane\n    bound=box(p,vec3(1.,1.,2.3),0.);id=1.;return bound;\n#endif\n    if (bound>.65) return bound+.65;\n    objcol=vec3(1.);\n    p.z*=-1.05;\n    float cab=cabina(p);\n    float fus=fuselaje(p,cab);\n    float mot=motor(p);\n    float win=alas(p);\n    float tai=cola(p);\n    float tim=timon(p);\n    cab=abs(cab)-.02;\n    float arm=armas(p);\n    float d=smin(fus,cab,max(.001,.02*p.z));\n    d=min(d,mot);\n    d=min(d,win);\n    d=min(d,tai);\n    d=min(d,tim);\n    d=min(d,arm);\n    if (d==fus) id=0.;\n    if (d==mot) id=1.;\n    if (d==cab) id=2.;\n    if (d==win) id=3.;\n    if (d==tai) id=4.;\n    if (d==tim) id=5.;\n    if (d==arm) id=6.;\n    float t=step(abs(pcab.z+.3-pcab.y*.5),.07);\n    t=max(t,step(abs(pcab.z+1.4+pcab.y*.3),.05));\n    id-=step(1.,t);\n    id=max(0.,id);\n    pos=p;\n    return d*1.2;\n}\n\n\nfloat water(vec3 p) {\n    p.z+=time*3.*1.5;\n    p.x-=path(p.z);\n    p.x*=2.;\n    return (p.y+1.75+snoise(p.xz*20.+time*0.)*.0002)*.9;\n}\n\nvec2 contrail(vec3 p) {\n    vec3 pp=p-ppos;\n    float t2=(tpos.z/3.)*speed-2.+.04*speed;\n    float chx=(interhash(0.,t2)-.5)*4.5;\n    float chy=.8+(interhash(-10.,t2*.75)-.5)*1.5+.018-baja;\n    float w=.003+min(.05,-pp.z*.005)*2.;\n    w=min(.03,w);\n    float chorro=length(p.xy-vec2(chx,chy))-snoise(tpos.zz*15.)*w*.4;\n    chorro=max(.003,abs(chorro));\n    chorro=max(chorro,pp.z+.1);\n    chorro=max(chorro,-pp.z-14.);\n    return vec2(chorro,w);\n}\n\n\nfloat de(vec3 p) {\n    vec3 pos=p-ppos;\n    float pam=pampa(pos*20.)/20.;\n    float ter=terrain(p/1.5)*1.5;\n    float wat=water(p);\n    float d=min(wat,ter);\n    d=min(d,pam);\n    if (d==ter) id=-1.;\n    if (d==wat) id=-2.;\n    return d;\n}\n\n\nfloat ao(vec3 p, vec3 n) {\n    float st=.05;\n    float ao=0.;\n    for(float i=0.; i<8.; i++ ) {\n        float td=.02+st*i;\n        float d=de(p+n*td);\n        ao+=max(0.,(td-d)/td);\n    }\n    return clamp(1.-ao*.15,0.,1.);\n}\n\nfloat shadows(vec3 p, vec3 ldir) \n{\n    float td=.0,sh=1.,d=.01,dt;\n    for (int i=0; i<50; i++) {\n\t\tp+=ldir*d;\n        float map=de(p);\n        vec2 ctrail=contrail(p);\n        dt=ctrail.x-ctrail.y*1.5+.05;\n        d=min(map,dt);\n        td+=d;\n        if (dt<.05&&map>.01) {\n            sh=.6+ctrail.y*8.; break;\n        }\n\t\tif (d<.002) {\n            sh=.5;\n            break;\n        }\n        if (td>maxdist) break;\n    }\n    return clamp(sh,0.5,1.);\n}\n\n\nvec3 normal3(vec3 p) {\n    vec2 e=vec2(0.,det*.5);\n    return normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\n/// normal hack by Shane to reduce compilation time\nvec3 normal(vec3 pos) {\n    vec2 e=vec2(0.,det*.5);\n    vec3[4] ev = vec3[4](e.yxx, e.xyx, e.xxy, e.xxx-.000001);\n    vec3 nn = vec3(0);\n    for(int i = 0; i<4; i++){\n        nn += sign(ev[i])*de(pos + ev[i]);\n        if(nn.x<-1e8) break; // Fake break.\n    } \n    return normalize(nn);\n}\n\nvec3 normal2(vec3 p) {\n    vec2 e=vec2(0.,det*.5);\n    return normalize(vec3(water(p+e.yxx),water(p+e.xyx),water(p+e.xxy))-water(p));\n}\n\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n\t\t\t\t\t-0.80,  0.36, -0.48,\n\t\t\t\t\t-0.60, -0.48,  0.64 );\nfloat fbm(in vec3 q)\n{\n\tfloat f  = 0.5000*noise( q ); q = m3*q*2.01;\n\tf += 0.2500*noise( q ); q = m3*q*2.02;\n\tf += 0.1250*noise( q ); q = m3*q*2.03;\n\tf += 0.0625*noise( q ); q = m3*q*2.04;\n\treturn f;\n}\n\nvec3 pampaColors() {\n    vec3 base=vec3(117.,170.,219.)/255.;\n    vec3 sec=vec3(1.,.7,.3);\n    vec3 ter=mix(sec,base,(1.+cos(pos.z*3.))*.5);\n    ter=base;\n    vec3 col=mix(base,vec3(.9),smoothstep(.55,.6,max(noise(floor(pos*2.)),noise(floor(pos*4.)))));\n    col=mix(col,base,abs(pmot.x)*.25);\n    if (id==0.) {\n        col=mix(col,ter,step(abs(pfus.x+(noise(pos*5.+4.)-.5)*.0),.2));\n    }\n    if (id==2.) {\n        vec3 cab=vec3(.1);\n        float t=step(.07,abs(pcab.z+.3-pcab.y*.5));\n        t=min(t,step(.05,abs(pcab.z+1.4+pcab.y*.3)));\n        col=mix(ter,cab,t);\n    }\n    if (id==1.) {\n        col=mix(col,sec,step(2.1,-pmot.z)*step(0.,dcab-.1));\n        col=mix(col,sec,step(2.2,pmot.z));\n    }\n    if (id==3.) {\n        pwin.x=abs(pwin.x);\n        col=mix(col,sec,step(4.3,abs(pwin.x)));\n        col-=step(abs(pwin.z-.7),.03)*.2*step(pwin.x,4.3);\n        if (pwin.z>0.7) {\n            col-=step(abs(pwin.x-3.5),.03)*.2;\n            col-=step(abs(pwin.x-1.5),.03)*.2;\n        }\n    }\n    if (id==4.) {\n        ptai.x=abs(ptai.x);\n        col=mix(col,sec,step(1.6,ptai.x));\n        col-=step(abs(ptai.z-.35),.03)*.2*step(ptai.x,1.2);\n        col-=step(abs(ptai.x-1.2),.03)*.2;\n    }\n    if (id==5.) {\n        col=mix(col,sec,step(1.3,ptim.y));\n        col-=step(abs(ptim.z-.5),.03)*.2*step(ptim.y,1.3);\n    }\n    if (id==6.) {\n        col=mix(col,ter,step(length(parm.xy),.25));\n    }\n    \n    col*=.5+oc*.5;\n    col*=1.05-noise(pos*20.)*.1;\n    return col*vec3(1.,.95,.9);\n}\n\nvec3 terrainColors(vec3 p, vec3 n, float y) {\n  //vec3 col = mix( vec3(0.2, 0.18, 0.18)*.7, vec3(0.22, 0.19, 0.16)*.8, smoothstep(0.7, 1.0, n.y) *.5) * 3.;\n    vec3 col = mix( vec3(0.992, 0.9918, 0.9918)*.7, \n        vec3(0.99922, 0.99919, 0.99916)*.8, smoothstep(0.7, 1.0, n.y) *.5) * 3.;\n        \n    float r=snoise(p.xy*vec2(7., 50.0)*2.)*.8;\n    //col = mix( r*vec3(.5, 0.4, 0.4), col, n.y); \n      col = mix( r*vec3(.995, 0.994, 0.994), col, n.y);   // all white mountains\n      \n    float clear=smoothstep(.0,.07*3.,h+.75*0.65);\n    vec3 veg=vec3(.9, .77, .6)*.4;\n  //  veg=mix(veg,vec3(1.1,.95,0.7)*.23,smoothstep(0.,.5,snoise(p.xz*.5)));\n //   veg*=(1.+snoise(p.xz*90.)*.3);\n    col = mix( col, veg, clear*smoothstep(.8, .9, n.y) *smoothstep(1.,0.,snoise(p.xz+123.)));\n //   col*=1.-smoothstep(-.3,-1.2,p.y)*.7; \n    return col*1.6;\n}\n\nvec3 shade(vec3 p, vec3 dir) {\n    float y=tpos.y-h;\n    float id2=id;\n    vec3 n = normal(p);\n    vec3 col;\n    float oc=1.;\n    if (id<0.) col=terrainColors(tpos,n,y),oc=ao(p,n); else col=pampaColors();\n    float amb=max(.5,dot(-dir,n))*.5*oc;\n    amb=.4*oc;\n    float sh=1.;\n    if (ref<.5) sh=shadows(p,ldir);\n    float dif=max(0.,dot(ldir,n))*.6;\n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),50.);\n    if (id2!=2.) spe*=.3;\n    if (id2<0.) spe*=.4;\n    \n    return col*(amb+dif*sh)+spe*sh*vec3(1.1,1.,.9);\n}\n\nvec3 shadeRiver(vec3 p, vec3 dir) {\n    float sh=1.;\n    vec3 n = normal(p);\n    float tr=smoothstep(120.*3.,130.*3.,tpos.z);\n    vec3 col=mix(vec3(0.14,0.12,0.1)*2.,vec3(0.1,0.1,0.105)*3.3,tr);\n    col+=smoothstep(.05,.0,tpos.y-h)*.2;\n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),30.)*.55;\n    return col*(.7+sh*.3)+spe;\n}\n\nvec3 shadeVid(vec3 p, vec3 dir) {\n    vec3 cab=vec3(.1);\n    float t=step(.07,abs(pcab.z+.3-pcab.y*.5));\n    t=min(t,step(.05,abs(pcab.z+1.4+pcab.y*.3)));\n    vec3 col=cab;\n    vec3 n = normal(p);\n    float amb=.4;\n    float dif=max(0.,dot(ldir,n))*.5;\n    vec3 refl=reflect(ldir,n);\n    float spe=pow(max(0.,dot(dir,refl)),30.)*1.5;\n    return col*(amb+dif)+spe*vec3(1.1,1.,.9);\n}\n\n\n\nvec3 march(vec3 from, vec3 dir, vec2 uv) \n{\n    ldir = normalize(vec3(1,1.,1.5));\n    float d, td=0., td2=0., vid=0., g=0.,aro=g, chorro=1.;\n    vec3 p=from, col=vec3(.0), colvid=col, shaderef=col, pp=p, pref=p, odir=dir;\n    float h=hash(uv*1000.)*.1;\n    for (int i=0; i<250; i++) {\n        p+=d*dir;\n        d=de(p)*(1.0-h);\n        det=id<0.?.003:.0002;\n        det*=1.0+pow(td,1.2)*.75;\n        if (id==2.&&d<det) {\n            if (vid<.5) colvid=shadeVid(p,dir);\n            vid=1.;\n            d=max(.01,abs(d));\n        };\n        if (id==-2.&&d<det&&ref<.5) {\n            ref=1.;\n            pref=p;\n            vec3 n=normal2(p);\n            dir=reflect(dir,n);\n            p+=dir*.05;\n            td2=td;\n            d=det;\n            //continue;\n        };\n        if (d<det || td>maxdist) break;\n        pp=p-ppos;\n        aro=max(abs(pp.y)-.005,abs(length(pp.xz)-.3));\n        if (time>1.5 && time < 8.) d=min(d,aro);\n#ifdef trail\n        if (pp.z<-.1&&p.z>-14.){\n            vec2 ctrail=contrail(p);\n            float chorro=ctrail.x;\n            float w=ctrail.y;\n            d=min(d,chorro*(.5+w*17.));\n            g=max(g,max(0.,w-chorro)/w*smoothstep(-14.,0.,pp.z)*(1.-ref*.5)\n                *smoothstep(-.07,-.35,pp.z));\n        }\n#endif        \n        td+=d;\n    }\n    float id2=id;\n    float clou=0.;\n    vec3 sky=mix(vec3(.75,.77,.85)*1.0,vec3(0.6,.7,.85)*.9,clamp(p.y*.07+.2,-.4,1.))*.8;\n    sky+=pow(max(0.,dot(dir,ldir)),70.)*vec3(1.4,1.,.6)*.5;\n    vec3 colref=vec3(0.);\n    if (d<det&&d!=aro) {\n        p-=det*dir*2.;\n        col=shade(p, dir);\n    } else {\n        td=maxdist;\n        p=dir*maxdist;\n        vec3 ps=dir*2.5;\n        ps.y*=4.;\n        ps.z+=time*.05;\n        clou=fbm(ps);\n        clou=smoothstep(.4,1.2,clou);\n        clou*=smoothstep(0.,5.,p.y);\n    }\n    if (ref>.5) {\n        shaderef=shadeRiver(pref,odir);\n        colref=mix(shaderef,sky,td2/maxdist);\n    }\n    sky+=clou*step(td-.5,maxdist)*.3*vec3(1.,.85,.6)*(1.+ref*.7);\n    col=mix(col,sky,pow(td/maxdist,1.5));\n    col=mix(col,colvid,vid*.5);\n    if (ref>.5) col=colref*.5+col*.5;\n    col=mix(col,col.ggg,smoothstep(1.,0.,t));\n    vec3 back = vec3(length(smoothstep(.8,1.,fract(uv*20.)))*.2);\n    float b=max(-1.,1.5-time);\n    float c=max(-1.,3.7-time);\n    float li=smoothstep(.01,.0,abs(uv.x+.5-b))*step(abs(uv.y+.025),.425*min(1.,time*2.));\n    back+=li*step(.5,fract(sqrt(time*13332.654)));\n    back+=hash(uv*1234.+time)*.2;\n    if (time>2.5) {\n        li=smoothstep(.01,.0,abs(uv.y+.5-c))*step(abs(uv.x+.025),.425*min(1.,time*2.));\n        back+=li*step(.5,fract(sqrt(time*13332.654)));\n    }\n    if (id2<0.||uv.x<b-.5||(time>2.5&&uv.y<c-.5)) col=mix(col,back,smoothstep(1.,0.,t));\n    if (fract(time*10.)*step(abs(time-8.5),.5)>.5) col=back;\n    col=mix(col,back,step(time,9.5)*step(aro,d)*step(.5,fract(time*2.+1.*atan(pp.x,pp.z))));\n    g*=smoothstep(0.5,1.,t);\n    col=mix(col,vec3(.85,0.18,0.1),g*.5);   // de vec3(0.85)\n    return col;\n}\n\nmat3 lookat(vec3 dir,vec3 up) {\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    hashseed=floor(iTime*.83/200.);\n    vec2 uv = gl_FragCoord.xy/resolution.xy-.5;\n    uv.x*=resolution.x/resolution.y;\n    float fov=1.1;\n    fragColor=vec4(0.);\n#ifdef letterboxfullscreen\n    if (resolution.x>1500.&&abs(uv.y)>.37) return;\n    if (resolution.x>1500.) fov=.8;\n#endif\n    speed=.25;\n    t=time*speed-2.;\n    float start=smoothstep(0.,.5,t);\n    float t1=t*start;\n    float t2=time*speed+.13-2.;\n    t2*=start;\n    float z=-.65-interhash(11.,t1)*1.8;\n    float xz=1.-interhash(22.,t1*.5)*5.;\n    float yz=.3-interhash(33.,t1*.5)*1.1;\n    ppos.x=(interhash(0.,t1)-.5)*4.5;\n    ppos2.x=(interhash(0.,t2)-.5)*4.5;\n    baja=smoothstep(125.,130.,time)*1.65;\n    ppos.y=.8+(interhash(-10.,t1*.75)-.5)*1.5-baja;\n    ppos2.y=.8+(interhash(-10.,t2*.75)-.5)*1.5-baja;\n    rotyz=rot((ppos.y-ppos2.y)*.5);\n    rotxy=rot((ppos.x-ppos2.x)*.8);\n    rotxz=rot((ppos.x-ppos2.x)*.3);\n    vec3 from=vec3(0.,0.3,z);\n    vec2 m=iMouse.xy/iResolution.xy;\n    bool mouseon=false;\n#ifndef onlymouse\n    if (iMouse.z<1.) {\n        from.yz*=rot(yz);\n        from.xz*=rot(xz);\n    } else {\n        from.yz*=rot(.5-(1.-m.y)*1.5);\n        from.xz*=rot(-m.x*6.);\n        mouseon=true;\n    }\n#endif\n#ifdef onlymouse\n    from.yz*=rot(.5-(1.-m.y)*1.5);\n    from.xz*=rot(-m.x*6.);\n    mouseon=true;\n#endif\n    from+=ppos;\n    if (!mouseon && mod(time,30.)>24.) from=vec3(.7,0.,mod(-time*4.,30.)-15.),fov*=1.3;\n    vec3 g=mix(vec3(0.5,1.,0.),vec3(1.),smoothstep(0.,1.,t));\n    if (t<0.) {\n        ppos=vec3(0.);\n        ppos2=ppos;\n        from=vec3(0.,.6,-0.1);\n        if (time>2.8) from=vec3(.5,.3,0.), from.xz*=rot(-time*.3);\n    }\n    vec3 dir=normalize(vec3(uv,fov));\n    float s=sin(time*.3);\n    dir.xz*=rot(s*s*s*.25*start);\n    dir=lookat(ppos-from,vec3(0.,1.,0.))*dir;\n    vec3 col=march(from,dir,uv*max(1.,2.-time*2.))*g;\n    col=pow(col,vec3(1.2))*1.15;\n    col*=smoothstep(200.,198.,mod(time,200.));\n    col*=smoothstep(0.,.5,mod(time,200.));\n    fragColor = vec4(col,1);\n}\n\n///////////////////////////////////////////// dr2 data\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n","name":"Image","description":"","type":"image"}]}