{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// This helper function returns 1.0 if the current pixel is on a grid line, 0.0 otherwise\nfloat IsGridLine(vec2 fragCoord)\n{\n\t// Define the size we want each grid square in pixels\n\tvec2 vPixelsPerGridSquare = vec2(16.0, 16.0);\n\t\n\t// fragCoord is an input to the shader, it defines the pixel co-ordinate of the current pixel\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\t\n\t// Get a value in the range 0->1 based on where we are in each grid square\n\t// fract() returns the fractional part of the value and throws away the whole number part\n\t// This helpfully wraps numbers around in the 0->1 range\n\tvec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);\n\t\n\t// Convert the 0->1 co-ordinates of where we are within the grid square\n\t// back into pixel co-ordinates within the grid square \n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\n\t// step() returns 0.0 if the second parmeter is less than the first, 1.0 otherwise\n\t// so we get 1.0 if we are on a grid line, 0.0 otherwise\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\t\n\t// Combine the x and y gridlines by taking the maximum of the two values\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\t// return the result\n\treturn fIsGridLine;\n}\n\n// This helper function returns 1.0 if we are near the mouse pointer, 0.0 otherwise\nfloat IsWithinCircle(vec2 vPos, vec2 fragCoord)\n{\n\t// fragCoord is an input to the shader, it defines the pixel co-ordinate of the current pixel\n\tvec2 vScreenPixelCoordinate = fragCoord.xy;\n\n\t// We calculate how far in pixels we are from the mouse pointer\n\tfloat fPixelsToPosition = length(vScreenPixelCoordinate - vPos);\n\t\n\t// return 1.0 if the distance to the mouse pointer is less than 8.0 pixels, 0.0 otherwise\n\treturn step(fPixelsToPosition, 8.0);\n}\n\n// main is the entry point to the shader. \n// Our shader code starts here.\n// This code is run for each pixel to determine its colour\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// We are goung to put our final colour here\n\t// initially we set all the elements to 0 \n\tvec3 vResult = vec3(0.0);\n\n\t// We set the blue component of the result based on the IsGridLine() function\n\tvResult.b = IsGridLine(fragCoord);\n\n\t// 1.0 if we are near the mouse co-ordinates, 0.0 otherwise\n\tfloat fIsMousePointerPixelA = IsWithinCircle(iMouse.xy,fragCoord);\n\n\t// If the mouse button is pressed\n\tif(iMouse.z >= 0.0)\n\t{\n\t\t// we set the green component of the result\n\t\tvResult.g = fIsMousePointerPixelA;\n\t}\n\telse\n\t{\n\t\t// we set the red component of the result\n\t\tvResult.r = fIsMousePointerPixelA;\n\t}\n\n\tfloat fIsMousePointerPixelB = IsWithinCircle(abs(iMouse.zw),fragCoord);\n\tvResult.b = max(vResult.b, fIsMousePointerPixelB);\n\n\n\t// The output to the shader is fragColor. \n\t// This is the colour we write to the screen for this pixel\n\tfragColor = vec4(vResult, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdlGRr","date":"1361911238","viewed":4845,"name":"Grid","username":"P_Malin","description":"Visualise some of the shader inputs, pixel co-ordinate system and mouse input.","likes":41,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""}}