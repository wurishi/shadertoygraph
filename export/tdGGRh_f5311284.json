{"ver":"0.1","info":{"id":"tdGGRh","date":"1570273720","viewed":3133,"name":"Ethics Gradient","username":"shau","description":"3rd Iain M. Banks \"Culture\" ship shader. This time \"Mistake-Not\" and \"Ethics Gradient\". ","likes":46,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n    Iain M. Banks Culture ships \"Mistake Not\" and \"Ethics Gradient\"\n\n    Voxel code blatently borrowed from IQs Voxel Edges\n    https://www.shadertoy.com/view/4dfGzs\n\n    Model adapted from\n    \n    GSV\n    https://www.shadertoy.com/view/lstfz4\n\n\tMistake Not\n    https://www.shadertoy.com/view/4llfDl\n\n*/\n\n#define BODY 6.0\n#define GLOW 7.0\n#define CHROME 8.0\n\n//Nimitz\nfloat tri(float x) {\n    return abs(x - floor(x) - 0.5);\n} \n\nvec3 pointOnLine(in vec3 a, in vec3 b, in float t) {\n    return a + normalize(b-a)*length(b-a)*t;    \n}\n\n//IQ SDF Functions\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nfloat sdTorus2(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\n\nfloat sdConeSection(vec3 p, float h, float r1, float r2) {\n    float d1 = -p.y - h,\n          q = p.y - h,\n          si = 0.5 * (r1 - r2) / h,\n          d2 = max(sqrt(dot(p.xz, p.xz) * (1.0 - si * si)) + q * si - r2, q);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//Mercury SDF Functions\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0 * PI / repetitions,\n          a = atan(p.y, p.x) + angle / 2.0,\n          r = length(p),\n          c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec2 dfGun(vec3 rp) {\n    float grey = fCylinder(rp.xzy - vec3(0.0, 0.8, 0.0), 0.1, 0.4);\n    rp.z = abs(rp.z);\n    grey = min(grey, fCylinder(rp.xzy - vec3(0.0, 0.4, 0.0), 0.4, 0.04));   \n    pModPolar(rp.yx, 3.0);\n    float body = fCylinder(rp.xzy - vec3(0.0, 0.5, 0.2), 0.1, 0.1);\n    return nearest(vec2(body, BODY), vec2(grey, CHROME));\n}\n\nvec2 dfManipulator(vec3 rp, float ma) {\n    rp.yz *= rot(ma);\n    vec3 j5b = vec3(0.2, 0.0, 0.0),\n         j5a = j5b + vec3(0.0, 0.0, -1.0) * 0.2,\n         j5c = j5b + vec3(0.0, 0.0, 1.0) * 0.2,\n         j5d = vec3(0.0, j5c.yz);    \n    float body = fCylinder(rp.xzy - j5d.xzy, 0.4, 0.02),\n          manipulator = sdConeSection(rp.xzy - vec3(0.0, 1.2, 0.0), 1.0, 0.16, 0.01);\n    rp.x = abs(rp.x);\n    manipulator = min(manipulator, sdTorus2(rp - vec3(0.3,0.0,0.0), vec2(0.1, 0.04)));\n    body = min(body, fCylinder(rp.zxy - j5b.zxy, 0.14, 0.1));\n    float chrome = sdCapsule(rp, j5a, j5c, 0.05);\n    vec2 near = nearest(vec2(body, BODY), vec2(chrome, CHROME));\n    return nearest(near, vec2(manipulator, GLOW));\n}\n\n//la - lower arm angle, ua - upper arm angle, ma - manipulator angle \nvec4 dfArm(vec3 rp, float la, float ua, float ma, inout vec3 tipPos) {  \n    //calculate joint positions\n    vec3 lad = vec3(0.0, 1.0, 0.0);\n    lad.yz *= rot(la);\n    //lower arm\n    vec3 j1a = vec3(0.1, 0.0, 0.45),\n         j1b = j1a + lad * 2.0,\n         j1c = j1a + lad * 3.0,\n         j1d = j1a + lad * 4.0;\n    //lower arm piston\n    vec3 j2a = vec3(0.0, 0.0, -0.3),\n         j2b = vec3(0.0, j1b.yz),  \n         lad2 = normalize(j2b - j2a);\n    float adt = length(j2b - j2a);\n    vec3 j2c = j2a + lad2 * 0.4,\n         j2d = j2a + lad2 * (adt - 0.8);\n    //upper arm\n    vec3 uad = vec3(0.0, 0.0, 1.0),\n         uad2 = vec3(0.0, 0.0, 1.0);\n    uad.yz *= rot(ua);\n    uad2.yz *= rot(ua);\n    vec3 j3b = vec3(0.0, j1c.yz),\n         j3a = j3b + uad2 * -0.6,\n         j3c = j3b + uad * 3.5,\n         j3d = j3b + uad * 7.0;\n    //upper arm piston\n    vec3 j4a = vec3(0.0, j1d.yz),\n         ud3 = normalize(j3c - j4a),\n         j4b = j4a + ud3 * 0.6,\n         j4c = j4a + ud3 * 2.2,\n         j4d = vec3(0.2, j4c.yz),\n         j4e = vec3(0.2, j3c.yz),\n         j4f = j4a + ud3 * 1.8;\n    //lower arm piston\n    float body = fCylinder(rp.zxy - j2a.zxy, 0.14, 0.3),\n          chrome = sdCapsule(rp, j2a, j2b, 0.05);\n    body = min(body, sdCapsule(rp, j2c, j2d, 0.1));\n    //upper arm\n    chrome = min(chrome, sdCapsule(rp, j3a, j3d, 0.05));\n    body = min(body, fCylinder(rp.zxy - j3c.zxy, 0.14, 0.3));\n    body = min(body, fCylinder(rp.zxy - j3d.zxy, 0.14, 0.1));\n    //upper arm piston top\n    body = min(body, sdCapsule(rp, j4b, j4f, 0.1));\n    chrome = min(chrome, sdCapsule(rp, j4a, j4c, 0.05));\n    //manipulator\n    tipPos += j3d;\n    vec3 tipDir = vec3(0,0,1);\n    tipDir.yz *= rot(-ma);\n    tipPos += tipDir*2.2;\n    vec2 manipulator = dfManipulator(rp - j3d, ma);\n    rp.x = abs(rp.x);\n    //glow joints\n    float glow = sdTorus2(rp - vec3(0.3, j3c.y, j3c.z), vec2(0.1, 0.04));\n    glow = min(glow, sdTorus2(rp - vec3(0.3, j2a.y, j2a.z), vec2(0.1, 0.04)));\n    glow = min(glow, sdTorus2(rp - vec3(0.2, j1a.y, j1a.z), vec2(0.1, 0.04)));\n    glow = min(glow, sdTorus2(rp - vec3(0.2, j1b.y, j1b.z), vec2(0.1, 0.04)));\n    glow = min(glow, sdTorus2(rp - vec3(0.2, j1c.y, j1c.z), vec2(0.1, 0.04)));\n    glow = min(glow, sdTorus2(rp - vec3(0.2, j1d.y, j1d.z), vec2(0.1, 0.04)));\n    //lower arm\n    body = min(body, fCylinder(rp.zxy - j1a.zxy, 0.14, 0.1));    \n    chrome = min(chrome, sdCapsule(rp, j1a, j1d, 0.05));\n    body = min(body, fCylinder(rp.zxy - j1b.zxy, 0.14, 0.1));\n    body = min(body, fCylinder(rp.zxy - j1c.zxy, 0.14, 0.1));\n    body = min(body, fCylinder(rp.zxy - j1d.zxy, 0.14, 0.1));\n    //upper arm piston   \n    chrome = min(chrome, sdCapsule(rp, j4c, j4d, 0.05));\n    chrome = min(chrome, sdCapsule(rp, j4d, j4e, 0.05));\n    //get nearest\n    vec2 near = nearest(vec2(body, BODY), vec2(chrome, CHROME));\n    near = nearest(near, vec2(glow, GLOW));\n    return vec4(nearest(near, manipulator), glow, manipulator.x);\n}\n\nvec4 dfShip(vec3 p, inout vec3 tipPos) {   \n    vec3 q = p;\n    vec4 ani = texture(iChannel0, ARM/R);\n    p.xy *= rot(ani.w);\n    //ship body\n    float body = max(sdEllipsoid(p, vec3(0.5, 0.5, 4.0)), p.z*-1.0);\n    body = min(body, sdSphere(p, 0.5));\n    body = max(body, -fCylinder(p.xzy, 0.3, 1.0));\n    q.xy *= rot(PI / 3.0);\n    pModPolar(q.yx, 3.0);\n    body = max(body, -sdEllipsoid(q - vec3(0.0, 0.4, 3.0), vec3(0.2, 0.3, 2.0)));\n    body = min(body, sdTorus(p - vec3(0,0,2.6), vec2(0.34, 0.03)));\n    //gun mount\n    body = smin(body, sdBox(q - vec3(0.0, 0.6, 0.4), vec3(0.05, 0.8, 0.2)), 0.2);\n    body = min(body, fCylinder(q.xzy - vec3(0.0, 0.4, 1.5), 0.2, 0.4));\n    vec2 gun = dfGun(q - vec3(0.0, 1.5, 0.4));\n    //engine\n    float enginecowl = max(sdConeSection(p.xzy - vec3(0,-0.3,0), 0.3, 0.36, 0.46),\n                           -fCylinder(p.xzy, 0.3, 1.0));\n    float enginecore = sdSphere(p, 0.38);\n    //window\n    float window = sdEllipsoid(p, vec3(0.40, 0.40, 3.9));\n    window = max(window, p.z*-1.0);\n    q = p;\n    pModPolar(q.yx, 3.0); //arm platforms\n    body = smin(body, sdBox(q - vec3(0.0, 0.5, 0.6), vec3(0.1, 0.3, 0.6)), 0.2);\n    //armature mounts\n    float amount1 = fCylinder(q.zxy - vec3(1.0, 0.0, 0.5), 0.6, 0.01);\n    amount1 = max(amount1, q.z - 1.15);\n    body = min(body, amount1);\n    //arms\n    tipPos += vec3(0.0, 1.0, 0.5);\n    vec4 arm = dfArm(q - vec3(0.0, 1.0, 0.5), ani.x, ani.y, ani.z, tipPos);\n    tipPos.xy *= rot(-ani.w);\n    //armature mounts\n    q.x = abs(q.x);\n    float amount2 = fCylinder(q.zxy - vec3(0.1, 0.08, 0.5), 0.6, 0.01);\n    amount2 = max(amount2, -q.z + 0.05);\n    body = min(body, amount2);\n    //get nearest\n    vec2 near = vec2(body, BODY);\n    near = nearest(near, vec2(window, GLOW));\n    near = nearest(near, vec2(enginecowl, CHROME));\n    near = nearest(near, vec2(enginecore, GLOW));\n    near = nearest(near, gun);\n    return vec4(nearest(near, arm.xy), arm.z, arm.w);\n}\n\nstruct Ship {\n    float t;\n    float id;\n    float glj;\n    float glt;\n    vec3 tp;\n};\n\nShip map(vec3 p) {\n    vec4 shipPos = texture(iChannel0, SP/R);\n    vec4 ship = dfShip(p - shipPos.xyz, shipPos.xyz);\n    return Ship(ship.x, ship.y, ship.z, ship.w, shipPos.xyz);\n}\n\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).t + e.xxy * map(p + e.xxy).t + \n\t\t\t\t\t e.xyx * map(p + e.xyx).t + e.yyy * map(p + e.yyy).t);   \n}\n\nShip march(vec3 ro, vec3 rd, float maxt) {\n    vec3 tipPos = vec3(0.0);\n    float t = 0.0,\n          id = 0.0,\n          glj = 0.0,\n          glt = 0.0;\n    for (int i=ZERO; i<128; i++) {\n        vec3 p = ro + rd*t;\n        Ship ship = map(p);\n        tipPos = ship.tp;\n        if (abs(ship.t)<EPS) {\n            id = ship.id;\n            break;\n        }\n        //glow\n        glj += 0.1 / (1.0 + ship.glj*ship.glj*500.0);\n        glt += 0.1 / (1.0 + ship.glt*ship.glt*800.0);\n        if (t>FAR) break;\n        t += ship.t*0.8;\n    }\n    return Ship(t, id, glj, glt, tipPos);\n}\n\nvec3 fog(vec3 ro, vec3 rd, float maxt) {\n    vec3 pc = vec3(0);\n    float t = 0.0;\n    for (int i=ZERO; i <64; i++) {\n        vec3 p = ro + rd*t;\n        float light = 1.0 - vMap(vec3(p.x, 11.0, p.z));  //inverse\n        float dist = 20.0 - p.y;\n        float atten = 0.06 / (1.0 + dist*dist * 0.08);\n        pc += vec3(0.8,1,0.8) * atten * light;\n        pc += n3D(p+T*-2.6)*0.006; \n        t += 0.4 + hash12(p.xz*3.0)*0.2;\n        if (t>maxt) break;\n    }\n    return pc;\n}\n\nvec2 eMap(vec3 p, vec3 ballPos, vec3 tipPos1) {\n    \n    float amt = max(0.0, 1.0 - length(ballPos - p));\n    vec3 q = p;\n    q.xy *= rot(1.4 * amt * sin(T*0.6));\n\tq.xy += tri(p.y*1.7 + T*2.6)*0.2;\n\tq.xy += tri(p.y*4.9 - T*11.6)*0.1;\n    float width = 0.0008 * n3D(q*22.0 + T*12.7);\n    \n\tvec4 buf1a = texture(iChannel0, vec2(0.5, ELC1)/R),\n\t     buf1b = texture(iChannel0, vec2(1.5, ELC1)/R),\n\t     buf2a = texture(iChannel0, vec2(0.5, ELC2)/R),\n\t     buf2b = texture(iChannel0, vec2(1.5, ELC2)/R),\n\t     buf3a = texture(iChannel0, vec2(0.5, ELC3)/R),\n\t     buf3b = texture(iChannel0, vec2(1.5, ELC3)/R);\n    \n    vec3 h3 = clamp(hash33(p), 0.1, 0.4);\n    vec3 tipPos2 = tipPos1,\n         tipPos3 = tipPos1;\n    tipPos2.xy *= rot(2.094395);\n    tipPos3.xy *= rot(4.188790);\n    vec3 ballPos1a = ballPos + buf1a.xyz,\n         ballPos1b = pointOnLine(tipPos1, ballPos1a, h3.x),\n         ballPos2a = ballPos + buf2a.xyz,\n         ballPos2b = pointOnLine(tipPos2, ballPos2a, h3.y),\n         ballPos3a = ballPos + buf3a.xyz,\n         ballPos3b = pointOnLine(tipPos3, ballPos3a, h3.z);\n\n    float t = sdCapsule(q, tipPos1, ballPos1a, width);\n    t = min(t, sdCapsule(q, ballPos1b, ballPos + buf1b.xyz, width));\n    t = min(t, sdCapsule(q, tipPos2, ballPos2a, width));\n    t = min(t, sdCapsule(q, ballPos2b, ballPos + buf2b.xyz, width));\n    t = min(t, sdCapsule(q, tipPos3, ballPos + buf3a.xyz, width));\n    t = min(t, sdCapsule(q, ballPos3b, ballPos + buf3b.xyz, width));\n    \n    return vec2(t, width);\n}\n\nvec3 electric(vec3 ro, vec3 rd, float maxt, vec3 ballPos, vec3 tipPos) {\n\n    vec3 pc = vec3(0.0);\n       \n    float t = 0.0;\n    for (int i=ZERO; i<64; i++) {\n        vec3 p = ro + rd*t;\n        vec2 es = eMap(p, ballPos, tipPos);\n\t\tif (t>maxt) break;        \n        pc += vec3(0,1,0) * 0.2 / (1.0 + es.x*es.x*200.0);\n        pc += vec3(0.6,1,0.6) * es.y * 500.0 / (1.0 + es.x*es.x*100.0);\n        \n        t += es.x;\n    }\n    \n    return pc;\n}\n\nvoid mainImage(out vec4 C, in vec2 U) {\n    \n    vec3 pc = vec3(0),\n         ro = texture(iChannel0, CP/R).xyz,\n         la = texture(iChannel0, LA/R).xyz,  \n         sp = texture(iChannel0, SP/R).xyz,\n         lgt = texture(iChannel0, LGT/R).xyz,\n         rd = camera(U, R, ro, la, FL);\n    \n    float mint = FAR;\n    \n    vec4 buf = texture(iChannel1, U/R);\n    pc = buf.xyz;\n    mint = buf.w;\n    \n    //ball\n    vec4 ball = texture(iChannel0, BP/R);\n    vec2 bi = sphIntersect(ro, rd, ball);\n    float w = sphDensity(ro, rd, ball, FAR);\n    if (bi.x>0.0) {\n        mint = bi.x;   \n        vec3 p = ro + rd*bi.x;\n        vec3 bn = sphNormal(p, ball);\n        vec3 ld = normalize(ro - p);\n        pc = vec3(0.2) * max(0.05, dot(ld, bn));\n        float spec = pow(max(dot(reflect(-ld, bn), -rd), 0.0), 16.0);\n        pc += vec3(1) * spec;\n        pc += vec3(0.0, 1.0, 0.0) *w*w;\n        pc += vec3(0.4, 1.0, 0.2) *pow(w, 16.0) * 4.0;\n    }\n   \tvec2 ballB = sphIntersect(ro, rd, vec4(ball.xyz, 3.0));\n\n    //ship with bounds\n    vec2 shipB = sphIntersect(ro, rd, vec4(sp,9.0));\n    Ship ship = march(ro, rd, mint);\n    if (shipB.x>0.0 || shipB.y>0.0) {\n        if (ship.t>0.0 && ship.t<mint) {\n            mint = ship.t;\n            vec3 p = ro +rd*ship.t;\n            vec3 n = normal(p);\n            vec3 ld = normalize(ro - p);\n            vec3 bld = normalize(ball.xyz - p);\n            float blt = length(ball.xyz - p);\n            float atten = 1.0 / (1.0 + blt*blt*0.1);\n            float spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 16.0);\n            float fres = pow(clamp(dot(n, rd) + 1.0, 0.0, 1.0), 2.0);\n            float light = 1.0 - vMap(vec3(p.x, 11.0, p.z));\n            \n            vec3 sc = vec3(0);\n            if (ship.id == GLOW) {\n                sc = vec3(0,1,0);    \n            } else if (ship.id == BODY) {\n                sc = vec3(0.1);\n                pc += vec3(0,0.4,0) * light * max(0.0, n.y);\n            } else if (ship.id == CHROME) {\n                sc = vec3(0.6);\n                pc += vec3(0,0.4,0) * light * max(0.0, n.y);\n            } \n\n            pc = sc * max(0.05, dot(ld, n));\n            pc += vec3(0,0.2,0) * light * max(0.0, n.y);\n            pc += vec3(0,0,0.1) * max(0.0, n.y*-1.0);\n            pc += 0.4*renderVoxels(p, reflect(rd, n), ro, ball.xyz, lgt.x, ZERO, 96).xyz;\n            pc += vec3(0.8,1,0.8) * max(0.05, dot(bld, n)) * atten * lgt.x;\n            pc += vec3(0.8,1,0.8) * spec;\n        }\n    }\n    \n    pc += vec3(0,1,0)*ship.glj;\n    pc += vec3(0,1,0)*ship.glt * lgt.x;\n    pc += fog(ro, rd, FAR) * 0.3;\n    \n    if ((ballB.x > 0.0 || ballB.y > 0.0) && ballB.x < mint) {\n        vec3 p = ro + rd*ballB.x;\n        pc += lgt.x * electric(p, rd, ballB.y - ballB.x, ball.xyz, ship.tp);\n    }\n\n    /*\n    //debug ship bounds\n    if (shipB.x > 0.0 || shipB.y > 0.0) {\n        pc += vec3(1,0,0) * 0.3;   \n    }\n    //*/\n    \n    C = vec4(pc, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define ZERO (min(iFrame,0))\n#define R iResolution.xy\n#define EPS 0.005\n#define FAR 240.0\n#define PI 3.14159\n#define T mod(iTime, 19.0)\n#define H 20.0\n\n#define LA  vec2(0.5, 0.5)\n#define CP  vec2(1.5, 0.5)\n#define SP  vec2(3.5, 0.5)\n#define BP  vec2(4.5, 0.5)\n#define ARM vec2(5.5, 0.5)\n#define LGT vec2(6.5, 0.5)\n\n#define ELC1 100.5\n#define ELC2 200.5\n#define ELC3 300.5\n\n#define FL 2.0\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nfloat hash12(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec2 hash22(vec2 p) {\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Fabrice\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//IQ Sphere Functions\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd),\n          c = dot(oc, oc) - sph.w * sph.w,\n          h = b * b - c;\n    if (h < 0.0) return vec2(0.0);\n    h = sqrt(h);\n    float tN = -b - h,\n          tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    vec3  rc = (ro - sph.xyz) / sph.w;\n    float ndbuffer = dbuffer / sph.w,\n          b = dot(rd, rc),\n          c = dot(rc, rc) - 1.0,\n          h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h,\n          t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nvec3 sphNormal(in vec3 pos, in vec4 sph) {\n    return normalize(pos-sph.xyz);\n}\n\nvec3 camera(vec2 U, vec2 r, vec3 ro, vec3 la, float fl) {\n    vec2 uv = (U - r*.5)/r.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nfloat vMap(vec3 p) {\n    float hit = 0.0;\n    vec2 h2 = hash22(floor(p.xz*0.25));\n    if (p.z > 0.0) {\n        if (p.y < -10.0 && h2.x > 0.5) hit=1.0;\n        if (p.y > 10.0 && h2.y > 0.5) hit=1.0;\n    }\n    return hit;   \n}\n\n//Voxel Rendering\nfloat maxcomp(in vec4 v) {\n    return max(max(v.x,v.y), max(v.z,v.w));\n}\n\nfloat isEdge(in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd) {\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    return maxcomp(max(wb, wc));\n}\n\nfloat castRay(\n    in vec3 ro, \n    in vec3 rd, \n    out vec3 oVos, \n    out vec3 oDir, \n    in int zero, \n    in int steps) \n{\n\tvec3 pos = floor(ro),\n\t     ri = 1.0/rd,\n\t     rs = sign(rd),\n\t     dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor(int i =zero; i<steps; i++) {\n        float ns = vMap(pos);\n\t\tif (ns>0.5 ) {\n            res=1.0;\n            break;\n        }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nvec4 renderVoxels(\n    vec3 ro, \n    vec3 rd, \n    vec3 lp, \n    vec3 bp,\n    float lgt,\n    int zero, \n    int steps) \n{\n    \n    vec3 pc = vec3(0),\n         vos = vec3(0),\n         dir = vec3(0);\n    float mint = FAR;\n    float t = castRay(ro, rd, vos, dir, zero, steps);\n    \n    if (t>0.0) {\n        mint = t;\n        vec3 n = -dir*sign(rd);\n        vec3 p = ro + rd*t;\n        vec3 ld = normalize(lp - p);\n        vec3 bld = normalize(bp - p);\n        float blt = length(bp - p);\n        \n        vec3 uvw = p - vos;        \n        vec3 v1  = vos + n + dir.yzx;\n\t    vec3 v2  = vos + n - dir.yzx;\n\t    vec3 v3  = vos + n + dir.zxy;\n\t    vec3 v4  = vos + n - dir.zxy;\n\t\tvec3 v5  = vos + n + dir.yzx + dir.zxy;\n        vec3 v6  = vos + n - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + n - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + n + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\t\tvec4 vc = vec4(vMap(v1),  vMap(v2),  vMap(v3),  vMap(v4));\n\t    vec4 vd = vec4(vMap(v5),  vMap(v6),  vMap(v7),  vMap(v8));\n\t    vec4 va = vec4(vMap(v9),  vMap(v10), vMap(v11), vMap(v12));\n\t    vec4 vb = vec4(vMap(v13), vMap(v14), vMap(v15), vMap(v16));\n        \n        vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        pc = vec3(0.0,0.2,0.0) * max(0.05, dot(ld, n));\n        //ball glow\n        pc += vec3(0.8,1.0,0.0) * lgt * max(0.05, dot(bld, n)) / (1.0 + blt*blt*0.02);\n        //edges\n        pc += vec3(0.0,0.3,0.0)*(1.0-www) * step(p.y, 0.0);\n    }\n    \n    return vec4(pc, mint);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/* Animation Buffer */\n\n//Dave Hoskins - Pylon \n//https://www.shadertoy.com/view/XltSRf\n//Catmull-rom spline\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    \n    vec3 c2 = -0.5 * p0\t+  0.5 * p2;\n\tvec3 c3 =        p0\t+ -2.5 * p1 +  2.0 * p2 + -0.5 * p3;\n    vec3 c4 = -0.5 * p0\t+  1.5 * p1 + -1.5 * p2 +  0.5 * p3;\n\t\n    return(((c4 * t + c3) * t + c2) * t + p1);\n}\n\nvoid positionAtTime(inout vec3 cameraPosition) {\n    \n    //initialise camera arrays\n    //number of positions must be +3 number of seconds that loop plays\n    vec3 cameraPath[22];\n    cameraPath[0]  = vec3( 10.0,  0.0, 2.0);\n    cameraPath[1]  = vec3( 10.0,  0.0, 20.0);\n    cameraPath[2]  = vec3( 10.0,  2.0, 50.0);\n    cameraPath[3]  = vec3( 8.0,   4.0, 90.0);\n    cameraPath[4]  = vec3( 5.0,   5.0, 140.0);\n    cameraPath[5]  = vec3( 2.0,   6.0, 200.0);\n    cameraPath[6]  = vec3( 0.0,   6.0, 260.0);\n    cameraPath[7]  = vec3(-2.0,   6.0, 315.0);\n    \n    cameraPath[8]  = vec3( -4.0,  5.0, 370.0);\n    cameraPath[9]  = vec3( -6.0,  4.0, 425.0);\n    cameraPath[10] = vec3( -8.0,  2.0, 480.0);\n    \n    cameraPath[11] = vec3( -8.0,  0.0, 535.0);\n    cameraPath[12] = vec3( -8.0, -2.0, 590.0);\n    cameraPath[13] = vec3( -4.0, -5.0, 645.0);\n    cameraPath[14] = vec3( -2.0, -3.0, 695.0);\n    cameraPath[15] = vec3(  2.0, -1.0, 745.0);\n    cameraPath[16] = vec3(  6.0,  2.0, 795.0);\n    cameraPath[17] = vec3(  6.0,  3.0, 845.0);\n    cameraPath[18] = vec3(  6.0,  4.0, 895.0);\n    cameraPath[19] = vec3(  6.0,  5.0, 935.0);\n    cameraPath[20] = vec3(  6.0,  5.0, 965.0);\n    cameraPath[21] = vec3(  6.0,  5.0, 995.0);\n\n    int nt = int(T);\n    float ft = fract(T);\n    \n    vec3 p0 = cameraPath[nt];\n    vec3 p1 = cameraPath[nt + 1];\n    vec3 p2 = cameraPath[nt + 2];\n    vec3 p3 = cameraPath[nt + 3];\n    \n    cameraPosition = spline(p0, p1, p2, p3, ft);\n}\n\nvoid mainImage(out vec4 C, in vec2 U) {\n    \n    const float ballRad = 0.5;\n    \n    vec4 bp = vec4(0.0, 0.0, 40.0, ballRad);\n    vec3 la = vec3(0.0, 0.0, 0.0),\n         ro = vec3(0.0, 0.0, 0.0),\n         sp = vec3(0.0, 0.0, 0.0);\n    float vaa = 0.6,\n          haa = -0.4,\n          ta = 0.0,\n          sa = T*0.4,\n          spd = 50.0,\n          lgt = 0.0;\n    \n    //camera\n    positionAtTime(ro);\n    \n    //speed of ball and ship\n    float offset = min(31.0, T*4.0);\n    bp.z += T * spd;    \n    la.z += offset + T * spd;\n    sp.z += offset + T * spd;\n    \n    //arm angles\n    vaa -= clamp((T-5.0) * 0.2, 0.0, 0.2) - \n           clamp((T-15.0) * 0.1, 0.0, 0.2);\n    haa += clamp((T-5.0) * 0.1, 0.0, 0.3) -\n           clamp((T-10.0) * 0.1, 0.0, 0.3);\n    ta += clamp((T-6.0) * 0.3, 0.0, 0.6) -\n          clamp((T-10.0) * 0.2, 0.0, 0.6);\n    \n    //electricity\n    float h1 = hash12(U + 20.0) - 0.5;\n    vec2 h2 = (hash22(U+111.3+T*2.9)-0.5) * 2.0;    \n    vec3 bolt = vec3(h2.x, ballRad, h2.y);\n    bolt.xy *= rot(T*h1*17.0);\n    bolt.yz *= rot(-sa); //rotate with ship\n    bolt = normalize(bolt) * ballRad;\n    if (U.y==ELC1) {\n       C = vec4(bolt, 1.0); \n    } else if (U.y==ELC2) {\n       bolt.yz *= rot(-2.094395); \n       C = vec4(bolt, 1.0); \n    } else if (U.y==ELC3) {\n       bolt.yz *= rot(-4.188790); \n       C = vec4(bolt, 1.0); \n    }\n    \n    //light\n    lgt = step(8.0, T);\n    \n    if (U==LA) {\n        C = vec4(la, 0.0);    \n    } else if (U==CP) {\n        C = vec4(ro, 0.0);    \n    } else if (U==SP) {\n        C = vec4(sp, 0.0);    \n    } else if (U==BP) {\n        C = bp;    \n    } else if (U==ARM) {\n        C = vec4(vaa, haa, ta, sa);\n    } else if (U==LGT) {\n        C = vec4(lgt, 0.0, 0.0, 0.0);\n    } \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 fog(vec3 ro, vec3 rd, float maxt) {\n    vec3 pc = vec3(0);\n    float t = 0.0;\n    for (int i=ZERO; i <64; i++) {\n        vec3 p = ro + rd*t;\n        float light = 1.0 - vMap(vec3(p.x, 11.0, p.z));  //inverse\n        float dist = 20.0 - p.y;\n        float atten = 0.06 / (1.0 + dist*dist * 0.04);\n        pc += vec3(0,0.6,0) * atten * light;\n        pc += n3D(p+T*-2.6)*0.002; \n        t += 0.6 + hash12(p.xz*3.0)*0.2;\n        if (t>maxt) break;\n    }\n    return pc;\n}\n\nvoid mainImage(out vec4 C, in vec2 U) {\n    \n    vec3 pc = vec3(0),\n         ro = texture(iChannel0, CP/R).xyz,\n         la = texture(iChannel0, LA/R).xyz,\n         bp = texture(iChannel0, BP/R).xyz,\n         lgt = texture(iChannel0, LGT/R).xyz,\n         rd = camera(U, R, ro, la, FL);\n    \n    vec4 res = renderVoxels(ro, rd, ro, bp, lgt.x, ZERO, 256);\n    pc = res.xyz;\n    float mint = res.w;\n\t    \n    pc = mix(pc, vec3(0), mint/FAR);\n    pc += fog(ro, rd, mint) * 0.8;\n    C = vec4(pc, mint);\n}","name":"Buffer B","description":"","type":"buffer"}]}