{"ver":"0.1","info":{"id":"4l2XzG","date":"1444644005","viewed":197,"name":"Surface implicite","username":"Tsubaki","description":"projet surface implicite","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["surface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Blobs\n// Eric Galin\n\nconst float lambda = 1.717300206719838;\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// Noise ------------------------------------------------------------\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n  \treturn e*falloff(length(p-c),R);\n}\n\nfloat distLine(in vec3 p,in vec3 a, in vec3 b)\n{\n    vec3 u = normalize(b-a);\n    float dist = dot(u, (p-a));\n    \n    if(dist <0.0)\n        return length(p-a);\n        \n    if(dist > length(b-a))\n        return length(p-b);\n    \n    return length(p-(a+dist*u));\n}\n\nfloat distCircle(vec3 p, vec3 c, vec3 n, float r){\n    n= normalize(n);\n    vec3 cp=p-c;\n    float scal = dot(cp,n);\n    float dicarre=dot(cp,cp)-scal*scal;\n    float dist=abs(sqrt(dicarre)-r);\n    return sqrt(dist*dist+scal*scal);\n}\nfloat distDisk(vec3 p, vec3 c, vec3 n, float r){\n    n= normalize(n);\n    vec3 cp=p-c;\n    float scal = dot(cp,n);\n    float dicarre=dot(cp,cp)-scal*scal;\n    float dist=max(sqrt(dicarre)-r,0.0);\n    return sqrt(dist*dist+scal*scal);\n}\n\nfloat circle(vec3 p, vec3 c, vec3 n,float rad, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n  return e*falloff(distCircle(p,c,n,rad),R);\n}\n\nfloat disk(vec3 p, vec3 c, vec3 n,float rad, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n  return e*falloff(distDisk(p,c,n,rad),R);\n}\n\n\nfloat seg(in vec3 p,in vec3 a, in vec3 b, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n  return e*falloff(distLine(p,a,b) ,R);\n}\n\nfloat distCylindre(in vec3 p,in vec3 a, in vec3 b, in float rayon)\n{\n    vec3 u = normalize(b-a);\n    float ha = dot((p-a),u);\n    float hb = dot((p-b),u);\n    \n   \n    if(ha < 0.0)\n   \t\treturn  distDisk(p, a, b-a, rayon);\n    if(hb > 0.0)\n        return  distDisk(p, b, b-a, rayon);\n  \n    return max(distLine(p,a,b)-rayon,0.0);\n}\n\nfloat cylindre(in vec3 p,in vec3 a, in vec3 b, float rayon, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n    return e*falloff(distCylindre(p,a,b, rayon) ,R);\n}\n\nfloat distTube(in vec3 p,in vec3 a, in vec3 b, in float rayon)\n{\n    vec3 u = normalize(b-a);\n    float ha = dot((p-a),u);\n    float hb = dot((p-b),u);\n    \n   \n    if(ha < 0.0)\n   \t\treturn  distDisk(p, a, b-a, rayon);\n    if(hb > 0.0)\n        return  distDisk(p, b, b-a, rayon);\n  \n    return abs(distLine(p,a,b)-rayon);\n}\n\nfloat tube(in vec3 p,in vec3 a, in vec3 b, float rayon, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n    return e*falloff(distTube(p,a,b, rayon) ,R);\n}\n\nfloat distCube(in vec3 p,in vec3 a, in vec3 b)\n{\n    float d = 0.0;\n    \n    if(p.x < a.x)\n        d+=(a.x-p.x)*(a.x-p.x);\n    else if(p.x > b.x)\n        d+=(b.x-p.x)*(b.x-p.x);\n        else\n            d+=0.0;\n        \n    if(p.y < a.y)\n        d+=(a.y-p.y)*(a.y-p.y);\n    else if(p.y > b.y)\n        d+=(b.y-p.y)*(b.y-p.y);\n        else\n            d+=0.0;\n        \n    if(p.z < a.z)\n        d+=(a.z-p.z)*(a.z-p.z);\n    else if(p.z > b.z)\n        d+=(b.z-p.z)*(b.z-p.z);\n        else\n            d+=0.0;\n        \n        \n    return sqrt(d);\n}\n\nfloat cube(in vec3 p,in vec3 a, in vec3 b, float e,float R, out float lip)\n{\n    lip=e*lambda/R;\n    return e*falloff(distCube(p,a,b) ,R);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = lipA + lipB;\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = max(lipA, lipB);\n    return max(a,b);\n}\n\nfloat Intersection(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = max(lipA, lipB);\n    return min(a,b);\n}\n\nfloat Difference(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = max(lipA, lipB);\n    return min(a,2.0*T-b);\n}\n\nfloat DemandeAFlo(float a,float b, in float lipA, in float lipB, out float lip)\n{\n    lip = lipA + lipB;\n    return a-b;\n}\n\nfloat Minion(in vec3 p, out float lip)\n{\n    vec3 a = vec3(-0.9, 2.0, -2.0);\n    vec3 b = vec3(0.9, 2.0, -2.0);\n    vec3 directionZ = vec3(0.0, 0.0, 1.0);\n    float lip2;\n    \n  \tfloat v = seg(p,vec3( 0.0, -1.5, 0.0), vec3( 0.0, 2.0, 0.0), 1.0,4.5, lip);\n    //bandeau\n    v = Union(v, circle(p,vec3( 0.0, 2.0, 0.0), vec3( 0.0, 2.2, 0.0), 2.0, 1.0,0.5,lip2),lip,lip2,lip);\n    v =  Difference(v,cube(p,vec3( -0.7, 2.0, -2.0), vec3( 0.7, 2.0, -1.0), 0.7, 1.0,lip2),lip,lip2,lip); \n    //yeux\n   \tv = Union(v,cylindre(p,a, vec3( -0.9, 2.0,1.0), 0.25, 1.0,1.0,lip2),lip,lip2,lip);\n    v= Union(v,cylindre(p,b, vec3( 0.9, 2.0,1.0), 0.25, 1.0,1.0,lip2),lip,lip2,lip);\n    //lunettes\n    v =  Union(v,circle(p, a, directionZ , 0.6, 0.8,1.0,lip2),lip,lip2,lip);\n    v =  Union(v,circle(p, b, directionZ , 0.6, 0.8,1.0,lip2),lip,lip2,lip);\n    \n    //bras gauche\n    v = Blend(v,cylindre(p,vec3( 2.0, 0.25, 0.0), vec3( 3.0, -0.5, 0.0), 0.01, 1.0,0.6,lip2),lip,lip2,lip);\n    v = Blend(v,cylindre(p,vec3( 3.0, -0.5, 0.0), vec3( 3.0, -2.0, 0.0), 0.01, 1.0,0.5,lip2),lip,lip2,lip);\n    \n    vec3 couded= vec3( -4.2, 0.5, 0.0);\n    vec3 maind= vec3(-3.0, -0.5, 0.0);\n    float angle=cos(iTime*10.0);\n    maind= rotateZ(maind-couded,angle*3.14/4.0+3.5)+couded;\n    \n    //bras droit\n    v = Blend(v,cylindre(p,vec3(-2.0, 0.25, 0.0), vec3( -4.0, 0.5, 0.0), 0.01, 1.0,0.6,lip2),lip,lip2,lip);\n    v = Blend(v,cylindre(p,couded,maind, 0.01, 1.0,0.5,lip2),lip,lip2,lip);\n\n    //jambe droite\n    v = Blend(v, cylindre(p, vec3(-0.9, -3.0, 0.0), vec3(-0.9, -4.0, 0.0), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n    v = Blend(v, cylindre(p, vec3(-0.9, -4.25, 0.25), vec3(-1.1, -4.25, -0.75), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n    \n    \n    //jambe gauche\n    v = Blend(v, cylindre(p, vec3(0.9, -3.0, 0.0), vec3(0.9, -4.0, 0.0), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n    v = Blend(v, cylindre(p, vec3(0.9, -4.25, 0.25), vec3(1.1, -4.25, -0.75), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n    \n    v =  Difference(v,cube(p,vec3( -1.5, -5, -3.0), vec3( 1.5, -4.7, 1), 0.7, 1.0,lip2),lip,lip2,lip);;\n    \n    //bouche\n    float bouche=(cos(iTime)+1.0)/4.0;\n    v =  Difference(v,seg(p,vec3( -0.5, -0.5, -2), vec3( 0.5, -0.5, -2), 1.0,1.0-bouche,lip2),lip,lip2,lip); \n    \n    float nez=(cos(iTime*2.0)+1.0)*4.0;\n    v = Union(v, cylindre(p, vec3(0.0, 0.75, -2.0), vec3(0.0, 0.75, -2.0-nez), 0.01, 1.0, 0.66,lip2),lip,lip2,lip);\n\treturn v;\n}\n\n// Potential field of the object\n// p : point\nfloat object(in vec3 p, out float lip)\n{\n  p.z=-p.z;\n    float v;\n  //float v = Blend(point(p,vec3( 0.0, 1.0, 1.0),1.0,4.5),\n   //               point(p,vec3( 2.0, 0.0,-3.0),1.0,4.5));\n\n  //v=Blend(v,point(p,vec3(-3.0, 2.0,-3.0),1.0,4.5));\n  //v=Union(v,point(p,vec3(-1.0, -1.0, 0.0),1.0,4.5));\n    \n   \t/*vec3 temp=p*0.5;\n    float xw=noise(temp);\n    temp=temp*m;\n    float yw=noise(temp);\n    temp=temp*m;\n    float zw=noise(temp);\n    \n    vec3 pp=p;\n    pp.x+=xw;\n    pp.y+=yw;\n    pp.z+=zw;*/\n    \n    //v = point(p, vec3(0.0, 0.0, 0.0), 1.0,4.5, lip);\n    \n\t//v = seg(p,vec3(-2.5, 0.0, 0.0), vec3(2.5, 0.0, 0.0), 1.0,4.5, lip);\n    //v = circle(pp, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0),3.5, 1.0,1.0);\n    //v = disk(pp, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0),2.5, 1.0,1.0);\n    //v = cylindre(pp,vec3(-3.5, 0.0, 0.0), vec3(3.5, 0.0, 0.0), 2.5, 1.0,1.0);\n    //v = cube(pp,vec3(-1.5, -1.5, -1.5), vec3(1.5, 1.5, 1.5), 1.0,4.5);\n    \n    //v=DemandeAFlo(point(p,vec3(-1.5, 0.0, 0.0),1.0,4.5),\n    //        point(p,vec3( 1.0, 0.0,0.0),1.0,3.5));\n  \n    \n  v= Minion(p, lip);\n    \n  return v-T;\n}\n\n                 \n                  \n                   \n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n    float lip;\n  float v = object(p, lip);\n    \n  n.x = object( vec3(p.x+eps, p.y, p.z), lip) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z), lip ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps), lip ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n      float lip;\n    float v = object(p, lip);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n      float lip;\n    float v = object(p, lip);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/lip);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*0.25;\n  //ro = rotateY(ro, a);\n  //rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n\n","name":"","description":"","type":"image"}]}