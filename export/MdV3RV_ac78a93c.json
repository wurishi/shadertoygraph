{"ver":"0.1","info":{"id":"MdV3RV","date":"1455832514","viewed":1699,"name":"2048 game","username":"Andre","description":"This is an implementation of the 2048 game by Gabriele Cirulli https://gabrielecirulli.github.io/2048/. It still has a bug in shifting/adding tiles, can you find it? If not just try to make the 2048 tile before getting stuck","likes":30,"published":1,"flags":48,"usePreview":0,"tags":["game","multipass","2048"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define stateRes iChannelResolution[0].xy\n#define stateSample(x) texture(iChannel0,x)\n\nvec4 readState(vec2 pt) {\n    return stateSample((pt+.5)/stateRes);\n}\nfloat r = 0.1;\nfloat r2 = 0.1;\nfloat segment(vec2 uv, float ofs)\n{\n    uv = abs(uv);\n\tfloat f = 1.0-smoothstep(0.1-r,0.1+r,uv.x);\n    f *= 1.0-smoothstep(0.6-r,0.6+r,uv.y+uv.x);\n    return f;\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    \n    if (num>=0) {\n\t    if (num==0 || \n    \t        (uv.y<0.?((num==2)==(uv.x<0.) || num==6 || num==8):\n        \t    (uv.x>0.?(num!=5 && num!=6):(num>=4 && num!=7) )))\n        \tseg = max(seg,segment(abs(uv)-0.5,0.03)); \n        \n    \tif (num!=1 && num!=4 && (num!=7 || uv.y>0.))\n        \tseg = max(seg,segment(vec2(abs(uv.y)-1.0,uv.x),0.03));\n    }\n\tif (num>=2 && num!=7 || num==-2)\n\t\tseg = max(seg,segment(uv.yx,0.02));\n    \n\treturn seg;\n}\n\nfloat log10 = log(10.0);\nfloat showNum(vec2 uv,float nr, bool zeroTrim)\n{\n    nr = floor(nr);\n    bool neg = nr<0.0;\n    if (neg) nr *= -1.;\n    \n    float digitCount = floor(log(nr)/log10+.000001)+1.0;\n\tfloat seg= 0.0;\n    //float dc = digitCount-(nr==16384.||nr==1024.||nr==128.||nr==16.?0.5:0.0);\n    float dc = digitCount-(nr / pow(10.,digitCount-1.0)<2.0?0.5:0.0);\n    \n    r *= (3.5+dc)/6.5;\n    uv *= 3.5+dc;\n    uv.x -= dc * .75+ uv.y*0.07;\n\tif (uv.x>-10.5 && uv.x<0.0 && abs(uv.y)<1.5)\n\t{\n        float digit = floor(-uv.x / 1.5);\n\t\tnr /= pow(10.,digit);\n        nr = mod(floor(nr),10.0);\n        if (neg && digit==digitCount)\n            nr = -2.;\n        else\n\t\t    if (nr==0.0 && zeroTrim && digit>=digitCount && digit!=0.0)\n\t\t\t    nr = -1.0;\n\t\tseg += sevenSegment(uv+vec2( 0.75 + digit*1.5,0.0),int(nr));\n    }\n\treturn seg;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv )\n{\n    r = 0.05 * 512. / iResolution.y;\n    r2 = 0.01 * 512. / iResolution.y;\n    uv = 4.5*(uv-0.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    if (abs(uv.x)<2. && abs(uv.y)<2.) {\n    \t//float background = 1.0-clamp(length(smoothstep(0.48,.5,abs(mod(uv,1.0)-0.5))),0.0,0.3);\n    \n    \tuv += 2.0;\n    \tvec2 grid = floor(uv);\n        \n\t    //float nr = pow(2.0,grid.y*4.0+grid.x); //Test all numbers\n        \n        //float nr = readState(vec2(3.0,0.0)).z; \n        vec4 tileState = readState(grid+vec2(2.0,2.0));\n        float nr = tileState.a;\n        if (iFrame<40) {\n            float gix = grid.y*4.0;\n            gix += mod(grid.y,2.0)>=0.9?3.0-grid.x:grid.x;\n            if (gix+4. > float(iFrame)/2.0) {\n                nr = pow(2.0,gix); //Test all numbers\n            \ttileState.a = nr;\n            \ttileState.r = nr;\n            } else {\n                tileState.a = tileState.r;\n            }\n        }\n        \n        vec2 tileuv = mod(uv,1.0)-0.5;\n        //tileuv *= 1.0-(tileState.g/21.0);\n        //tileState.a = 10.;\n        //tileState.r = 20.;\n        float deform = 1.0;\n        if (tileState.r>1.9) \n            deform = pow(1.0-tileState.a/tileState.r,0.8);\n        //if (tileState.a <1.0)\n        //    deform *= .5;\n        if (tileState.r!=0.0)\n            tileuv *= 1.0-deform*cos((length(tileuv))*2.9)*0.7;\n        \n        float nr2 = tileState.r-tileState.a;\n        float prog = nr2/tileState.r;\n\t    float numbers = showNum(tileuv+vec2(0.,prog),nr,true);\n        numbers = max(numbers, showNum(tileuv-vec2(0.,0.5-prog),nr2,true)); \n        \n        tileuv = abs(tileuv);\n        if (tileState.a <2.0)\n            tileuv *= (2.0+tileState.a)*.5;\n    \n        float lnr = log2(nr);\n        float isEdge = smoothstep(0.46-r2,0.46+r2,max(tileuv.x,tileuv.y));\n        fragColor = vec4(\n                    mix(nr<1.0?vec3(0.6):\n                      clamp(\n                        vec3(1.0+ (nr<256.0?-0.7:1.0)*numbers)+deform*(1.-length(tileuv))\n                       -vec3(0.0\n                            ,lnr/14.\n                            ,mod(lnr,4.0)/12. + lnr/6.), 0.0, 1.0)\n                     ,vec3(0.7)   \n                     ,isEdge)\n                              ,1.0);\n    } else {\n\t    if (abs(uv.x)<2.04 && abs(uv.y)<2.04) {\n        \tfragColor = vec4(0.7);\n    \t} else {\n            //vec2(20.,0.)\n            vec4 score = readState(vec2(20.0,.0));\n            float div = score.b-score.a;\n            fragColor = clamp(vec4(0.82\n                                   -showNum(uv-vec2(3.0,2.0),score.a,true)\n                                   -showNum((uv-vec2(3.0,1.85-div*0.02))/(div*.02+0.25),div,true)*div*.1\n                                   //-showNum(uv-vec2(3.0,0.0),score.y,true)\n                                  ),0.0,1.0);\n        \t//fragColor = vec4(0.82);\n    \t}\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define stateRes iChannelResolution[0].xy\n#define stateSample(x) texture(iChannel0,x)\n#define newNr1 2.0\n#define newNr2 4.0\n#define countUpSpeed 0.25\n#define countUpFactor 0.005\n\n\n\nvec4 readState(vec2 pt) {\n    return stateSample((pt+.5)/stateRes);\n}\n\nbool checkCell(vec2 pt, vec2 coord) {\n    return abs(pt.x+0.5-coord.x)<0.15 && abs(pt.y+0.5-coord.y)<0.15;\n}\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\nconst float KEY_ADD   = 107.5/256.0;\nconst float KEY_SUBS  = 109.5/256.0;\nconst float KEY_EQUAL = 187.5/256.0;\nconst float KEY_MINUS = 189.5/256.0;\n\nbool checkKey(float key)\n{\n\treturn texture(iChannel1, vec2(key, 0.25)).x > 0.5;\n}\n\nbool checkKey(float key1, float key2)\n{\n    return checkKey(key1) || checkKey(key2);\n}\n\nbool checkKey(float key1, float key2, float key3)\n{\n    return checkKey(key1) || checkKey(key2) || checkKey(key3);\n}\n\n#define scorepos vec2(20.,0.)\n#define kbdpos vec2(3.,0.)\n#define gridofs vec2(2.,2.)\n\n#define mouseDown (iMouse.w>0.0 && iMouse.y<0.3*iResolution.y)\n#define mouseUp (iMouse.w>0.0 && iMouse.y>0.7*iResolution.y)\n#define mouseLeft (iMouse.w>0.0 && iMouse.x<0.2*iResolution.x)\n#define mouseRight (iMouse.w>0.0 && iMouse.x>0.7*iResolution.x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    fragColor = texture(iChannel0,fragCoord/ stateRes);\n    if (checkCell(kbdpos,fragCoord)) { \n        // Handle keyboard moves\n        vec2 delta = vec2( checkKey(KEY_LEFT ,KEY_A,KEY_Q) || mouseLeft?-1.:\n                           checkKey(KEY_RIGHT,KEY_D      ) || mouseRight? 1.:0.\n                         , checkKey(KEY_DOWN ,KEY_S      ) || mouseDown?-1.:\n                           checkKey(KEY_UP   ,KEY_W,KEY_Z) || mouseUp? 1.:0.);\n        if (delta.x!=0.) delta.y=0.;\n        \n        float deltaKey = delta.y*2.0+delta.x;\n        \n        if (fragColor.z > 0.1)\n\t\t\tfragColor.z -= 1.0;\n        else {\n        \tif (fragColor.w != deltaKey) {\n\t            if (abs(deltaKey)>0.1 && abs(fragColor.w) <0.1) {\n    \t        \tfragColor.z = 10.0;\n        \t\t\tfragColor.xy = delta;\n            \t}\n\t\t\t\tfragColor.w = deltaKey;\n    \t    }\n        }\n       \n        if (fragColor.z < 0.1) {\n\t\t\tfragColor.z = .0;\n        \tfragColor.xy = vec2(0.0);\n        }\n    } \n    else\n    if (fragCoord.x>2.0 && fragCoord.x<6.0 &&\n        fragCoord.y>2.0 && fragCoord.y<6.0) {\n\t\tvec2 gridPos = floor(fragCoord-gridofs);\n        if (iFrame<36)\n        {\n            //float r = tan(iDate.w*123578.)*gridPos.x*mod(iDate.w,7.)+gridPos.y*mod(iDate.w,9.);\n            //if ((r = mod(r,14.0))<2.0)\n\t\t\t//\tfragColor.r = r<0.2?4.:2.;\n            //else\n\t \t\t//\tfragColor = vec4(0.0);\n            if (abs(gridPos.x - gridPos.y)<0.1)\n\t\t\t\tfragColor.ra = vec2(newNr1,-gridPos.x-gridPos.y*2.-3.);\n            else\n\t \t\t\tfragColor = vec4(0.0);\n        } else {\n            vec4 kbdstate = readState(kbdpos);\n       \t    vec2 delta = kbdstate.xy;\n            float ks = kbdstate.z;\n            bool doAdd = ks > 4.9 && ks < 6.9;\n\t        if (delta.y != 0. || delta.x != 0.) {\n\t           \tvec4 numTop = floor(readState(gridPos + gridofs - delta));\n   \t\t\t\tvec4 numBot = floor(readState(gridPos + gridofs + delta));\n                if (doAdd) {\n    \t            bool isOdd = false;\n\t                if (delta.y != 0.) {\n                \t\tisOdd = abs(mod(gridPos.y,2.0)-1.0) < 0.1;\n                \t    isOdd = delta.y > 0.0?isOdd:!isOdd;\n            \t    } else {\n    \t            \tisOdd = abs(mod(gridPos.x,2.0)-1.0) < 0.1;\n                \t    isOdd = delta.x > 0.0?isOdd:!isOdd;\n            \t    }\n                    isOdd = abs(mod(kbdstate.z,2.0)-1.0) < 0.1?!isOdd:isOdd;\n                \n                    if (fragColor.g<0.9 && fragColor.r>0.9) {\n                \t    if (isOdd && abs(fragColor.r-numTop.r)<0.1 && numTop.g < 0.1) {\n    \t\t\t            fragColor.r += numTop.r;\n        \t                fragColor.g = 5.0;\n    \t                }\n\t\t\t            else\n        \t\t    \t\tif (!isOdd && (abs(fragColor.r - numBot.r)<0.1) && numBot.g < 0.1)\n   \t        \t    \t\t\tfragColor = vec4(0.);\n                    }\n                } else {\n    \t            if (abs(fragColor.r)<0.1 && numTop.r>0.)\n\t           \t        fragColor = numTop;\n        \t        else\n        \t\t    \tif (abs(numBot.r)<0.1)\n   \t        \t    \t\tfragColor = vec4(0.);\n                }\n            } else {\n           \t\tvec2 newPos = floor(readState(scorepos).xy);\n            \tif (distance(gridPos.xy,newPos)<0.1 )\n                    if (mod(iTime*13.,10.0)>9.0)\n     \t\t\t\t\tfragColor.ra = vec2(newNr2,-2.);\n                    else\n\t\t \t\t\t\tfragColor.ra = vec2(newNr1,-2.);\n            }\n            \n            if (!doAdd) {\n                if (fragColor.g>0.9)\n                  \tfragColor.g -= 1.0;\n                else\n                \tfragColor.g = 0.0;\n            }\n            \n        \tfloat d = fragColor.r-fragColor.a;\n        \tif (d > 1.0)\n    \t        fragColor.a += countUpSpeed+d*countUpFactor;\n\t        else\n        \t    fragColor.a = fragColor.r;\n        }\n    } else\n    if (fragCoord.x>10.0 && fragCoord.x<14.1 && abs(fragCoord.y)<1.0 ) {\n        vec4 kbdstate = readState(kbdpos);\n        if (abs(kbdstate.z-2.0)<0.1) {\n        \tvec2 p = gridofs;\n            p.x += floor(fragCoord.x-10.0);\n            float pwr = 1.0;\n            float s = fragColor.r;\n            float free = 0.0;\n        \tvec4 g = readState(p); s += g.g>2.1?g.r:.0; free += g.r<0.1?pwr:0.; pwr *= 2.0; p.y += 1.0;\n            \t g = readState(p); s += g.g>2.1?g.r:.0; free += g.r<0.1?pwr:0.; pwr *= 2.0; p.y += 1.0;\n            \t g = readState(p); s += g.g>2.1?g.r:.0; free += g.r<0.1?pwr:0.; pwr *= 2.0; p.y += 1.0;\n            \t g = readState(p); s += g.g>2.1?g.r:.0; free += g.r<0.1?pwr:0.; pwr *= 2.0;\n            fragColor.r = s;\n            fragColor.g = free;\n        } else\n        if (abs(kbdstate.z-1.0)<0.1) {\n            fragColor.r = 0.0;\n        }\n        if (iFrame<20)\n            fragColor = vec4(0.);\n    } else\n    if (checkCell(scorepos,fragCoord)) {\n        vec4 kbdstate = readState(kbdpos);\n        if (abs(kbdstate.z-1.0)<0.1) {\n        \tvec2 p = vec2(10.,0.);\n            float s = fragColor.b;\n            float free[4];\n        \tvec4 g = readState(p); s += g.r; free[0] = g.g; p.x += 1.0;\n            \t g = readState(p); s += g.r; free[1] = g.g; p.x += 1.0;\n            \t g = readState(p); s += g.r; free[2] = g.g; p.x += 1.0;\n            \t g = readState(p); s += g.r; free[3] = g.g; \n            //fragColor.r = free[0];\n            \n            ivec2 lastFree = ivec2(-1);\n            \n            fragColor.b = s;\n            int ct = 0;\n            int rnd = int(mod(iTime*12.,16.0));\n            for (int x = 0; x < 4; x++) {\n                float col = free[x];\n                for (int y = 0; y < 4; y++) {\n                    if (mod(col,2.0)>0.1)\n                        lastFree = ivec2(x,y);\n                    \n                    if (lastFree.x>-1 && ct++>=rnd)\n                        break;\n                    col = floor(col/2.0);\n                }\n                if (lastFree.x>-1 && ct++>=rnd)\n                    break;\n            }\n            fragColor.xy = vec2(lastFree);\n        } else\n            if (fragColor.y > -0.1)\n            \tfragColor.xy = vec2(-1.,0.0);\n            \n        float d = fragColor.b-fragColor.a;\n        if (d > 0.4)\n            fragColor.a += d*0.05;\n        else\n            fragColor.a = fragColor.b;\n        \n        if (iFrame<20)\n            fragColor = vec4(-1.,-1.,0.,0.);\n    } else        \n        fragColor = vec4(-1.,0.,0.,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}