{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Distributed under CC-BY-NC-SA license (c) 2013 by Anssi EtelÃ¤niemi, aetelani(a)live.com \n// mouse spins the scene.\nprecision lowp float;\nfloat map(vec3 pos);\nfloat dSphere(vec3, float);\nfloat dPlane(vec3, vec4);\nfloat dBox(vec3, vec3);\nfloat opRep(vec3, vec3);\nfloat opU(float, in float);\nfloat opBlend(vec3 p, float primA, float primB);\nfloat smin( float a, float b, float k );\nvec3 normal(vec3);\nvec2 obj_floor(vec3);\nfloat rand(vec2);\nconst float PI=3.14159265;\nconst float PI2= PI * 2.0;\nconst float PIp2= PI / 2.0;\nfloat t, aspect;\nvec2 uv0;\n//\nfloat map(vec3 p) {\n\tfloat sphere = dSphere(p - vec3(0.0, 0.5, 0.0), 0.6);\n\tfloat box = dBox(p + vec3(0.0, 0.0, 0.0), vec3(1.0, 0.5, 0.5));\n\tfloat plane = dPlane(p + vec3(0.0, 1.0, 0.0), normalize(vec4(0.0, 1.0, 0.0, 0.0)));\n\tfloat blend = opBlend(p, box, sphere);\n\tfloat res = opU(plane, opU(blend, opRep(p, vec3(30.0, 3.0, 2.0)) ));\n\treturn res;\n}\nfloat dSphere(vec3 p, float s) {\n  return max(0.0, length(p)-s);\n}\nfloat dBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat opU(float d1, float d2) {\n    return min(d1,d2);\n}\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat opBlend(vec3 p, float primA, float primB){\n    return smin( primA, primB,  0.5);\n}\nfloat dPlane( vec3 p, vec4 n ) { // n must be normalized\t\n\treturn dot(p,n.xyz) + n.w;\n}\nvec3 normal(vec3 p) {\n\tconst vec2 delta = vec2(0.0, 0.02);\n\tvec3 grad;\n\tgrad.x = map(p+delta.tss )-map(p-delta.tss); //stpq\n\tgrad.y = map(p+delta.sts )-map(p-delta.sts);\n\tgrad.z = map(p+delta.sst )-map(p-delta.sst);\n\treturn normalize(grad);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat opRep(vec3 p, vec3 c) {\n    vec3 q = mod(p,c)-0.5*c;\n    //return sdSphere(q,1.0);\n\treturn opBlend(q, dBox(q, vec3(1.0, 0.3, 0.5)), dSphere(q, 0.9));\n}\n//---------\nmat4 rotationMatrix(vec3 ax, float angle){\n    vec3 axis = normalize(ax);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nvec3 planeTexture(vec3 p) {\n//\tvec3 res = vec3(cos(p.x)*cos(p.z), sin(p.x), cos(p.z)*sin(p.x));\n\tmat4 R = rotationMatrix(vec3(1.0, 1.0, 0.0), mod(t,PI*2.0));\n\tvec3 res = vec3(R * vec4(p, 1.0)).xyz;\n\tvec3 tex = texture(iChannel0, p.xz).rgb;\n  return normalize(res)*tex;\n}\nvec4 trace(vec3 pos, vec3 ray) {\n\tconst float maxd=100.0;\n\tfloat dist = 0.01;\n\tvec3 rayPos;\n\t\n\tfloat scalar=0.0;\n\tfor(int i=0;i<256;i++){\n\t\tif(abs(dist) < .001 || scalar > maxd) break;\t\t\n\t\tscalar += dist;\n\t\trayPos=pos+ray*scalar;\n\t\tdist = map(rayPos);\n\t}\n\tif(scalar > maxd) scalar = 0.0;\n\treturn vec4(rayPos, scalar);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy/iResolution.xy - 0.5;\n    aspect = iResolution.x / iResolution.y;\n\tuv0 = fragCoord.xy/iResolution.xy;\n\n\tt = iTime;\t\t\n\tvec3 vuv=vec3(0,1,0); // view up vector.\t\t\n\tvec3 lookAt=vec3(0.0, 0.0, 0.0); // cam lookat.\n\t\n\tfloat mx=iMouse.x/iResolution.x*PI2 + 0.01;\n\tfloat my=iMouse.y/iResolution.y*PIp2 + 0.01;\n\t//vec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.0; \n\tvec3 camPos=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*7.0; \n\t\n\t// Camera setup.\n\tvec3 vpn=normalize(lookAt-camPos);\n\tvec3 u=normalize(cross(vuv,vpn));\n\tvec3 v=cross(vpn,u);\n\tvec3 vcv=(camPos+vpn);\n\tvec3 rayDir=vcv+uv.x*u*aspect+uv.y*v;\n\tvec3 scp=normalize(rayDir-camPos);\n\t\n\tconst float maxd=100.0;\n\tvec3 col;\t\n\tvec4 res = trace(camPos, scp);\n\tvec3 rayPos = res.xyz;\n\tfloat scalar = res.w;\n\tif (scalar>0.0) {\n\t\tif (rayPos.y < -0.99) {\n\t\t\tcol = planeTexture(rayPos);\n\t\t\t//if(scalar > 10.1) {\n\t\t\t\t\n\t\t\t//}\n\t\t} else {\n\t\t\tcol= vec3(0.6,0.7,0.3);\n\t\t}\n\t\t//col.rgb *= dot(vpn, rayPos);\n\t\tvec3 norm = normal(rayPos);\n\t\t\n\t\tvec3 light = vec3(sin(t)*10.0,10,cos(t)*10.0);\n\t\tfloat intensity=dot(norm,normalize(camPos - rayPos + light));\n\t\t//simple phong\n\t\tfragColor=vec4((intensity*col+pow(intensity,10.0))*(1.0-scalar*.01),1.0);\n\t} else {\n\t\tvec2 sp = fragCoord.xy/iResolution.xy;\n\t\tsp.x *= aspect;\n\t\tfloat r = 1.0 - length(sp);\n\t\tfloat f = (1.0 - sqrt(abs(1.0-r)))/(r);\n\t\tvec2 nuv;\n\t\tnuv.x = sp.x*f;\n\t\tnuv.y = sp.y*f;\n\t\tvec4 tex = texture(iChannel0, nuv);\n\t\tfragColor=tex; // background texture\n\t\tfragColor.rg *= dot(fragColor.rg,fragColor.rg);\n//\t\tfloat rnd = rand(texture(iChannel0,vec2(t,sin(t))).xy);\n\t}\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdBGRz","date":"1382786170","viewed":250,"name":"Simple RayMarching scene","username":"aetelani","description":"needs magic, click and rotate. like the light tho. lowfp","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere","plane"],"hasliked":0,"parentid":"","parentname":""}}