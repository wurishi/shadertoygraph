{"ver":"0.1","info":{"id":"XldBRM","date":"1539037402","viewed":958,"name":"Dot Matrix Display","username":"athlete","description":"emulation of a DMD, inspired by arcade game score DMDs","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["mouseinput","itsbritneybitch","dotmatrix","dmd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DOT 0.4 //for larger spacing + smaller dots, decrease value below 0.4\n#define RECT 0.5\n\nconst float pixSizeX = 6.0; //width of LED in pixel\nconst float pixSizeY = 6.0; //height of LED in pixel\nvec3 dmdColor = vec3(0.9, 0.0, 0.0); //specify color of Dotmatrix LED\nfloat pixThreshold = 0.45; //specify at what threshold a pixel will become either on or off\nbool flickering = true;//do you want flickering enabled? emulates line wise updating of LEDs, 0.0 = disabled, 1.0 = enable\nfloat dotOrRect = DOT; //DOT or RECT - LEDs in round or rectangular shape\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //indexing shenanigans needed for color averaging\n    float indexX = fragCoord.x - .5;\n    float indexY = fragCoord.y - .5;\n    float cellX = floor(indexX / pixSizeX)* pixSizeX;\n    float cellY = floor(indexY / pixSizeY)* pixSizeY;\n    \n    //handle mouse input, slide between greyscale and binary pixels\n    float binary = 0.0f;\n    if(indexX < iMouse.x)\n        binary = 1.0f;\n    \n    //sample texture color and create big dot matrix pixel from video\n    //way overkill for this application, single sample should be enough, but here we go anyway..\n    float texAvg = 0.0;\n    /*for(float j=0.0; j < pixSizeY; j++)\n    {\n        float yComp = (cellY + j)/iResolution.y;\n        for(float i=0.0; i < pixSizeX; i++)\n        {            \n            vec2 currUV = vec2((cellX + i)/iResolution.x, yComp);\n            vec3 currTexVal = texture(iChannel0, currUV).rgb; \n            texAvg += 0.3*currTexVal.r + 0.59*currTexVal.g + 0.11*currTexVal.b;\n        }\n    }\n\ttexAvg /= pixSizeX*pixSizeY;*/\n\n    //fast version of above nested loop\n    vec2 currUV = vec2(cellX/iResolution.x, cellY/iResolution.y);\n    vec3 currTexVal = texture(iChannel0, currUV).rgb; \n    texAvg = 0.3*currTexVal.r + 0.59*currTexVal.g + 0.11*currTexVal.b;\n    \n    //switch pixels on/off\n    texAvg = (1.0f-binary)*texAvg + binary*step(pixThreshold, texAvg);\n    \n    //colorize in dmd color\n    vec3 col = dmdColor * texAvg;\n    \n    //Apply black parts of matrix\n    vec2 uvDots = vec2(fract(indexX / pixSizeX), fract(indexY / pixSizeY));\n    float circle = 1. - step(dotOrRect, length(uvDots - .5));\n    col = col * circle;\n    \n    //flickering        \n    float f = 0.0;\n    if(flickering && length(col) > 0.0)\n        f = sin(cellY - iTime * 20.)*0.05;\n\n    // Output to screen\n    fragColor = vec4(col+f,1.0);    \n}","name":"Image","description":"","type":"image"}]}