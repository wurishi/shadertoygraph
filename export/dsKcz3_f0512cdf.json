{"ver":"0.1","info":{"id":"dsKcz3","date":"1696424380","viewed":172,"name":"Discretized Balanced GP Order","username":"MartyMcFly","description":"Scaling SFC aspect ratio results in different locality values. I found a way to discretize the Balanced Peano Curve such that it fills a regular grid, with highly competitive L2 Locality of ~4.65.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["hilbert","spacefillingcurves","peano"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n     The main \"performance\" criterion of a SFC is the L2 locality or the square-to-linear ratio.\n    \n                            ||f(t1) - f(t2)||²\n     L_2 locality :=   sup __________________    for all t1, t2 in domain\n                              |t2 - t1|\n                              \n     in 2D, this is the worst case value of distance² between any two points \n     divided by their index difference. The lower this value, the better the SFC.\n\n     Some values of L2 locality:\n\n     Z-Order                inf\n     Hilbert                6\n     Gosper Flowsnake       6.35\n   > Peano Curve            8\n     βΩ-Curve*              5       *bifractal, changes shape completely each iteration\n   > Balanced Peano         4.619    Peano scaled by sqrt(3) along one axis \n     H-Curve*               4       *forms a closed loop and consists of triangles\n      \n     As can be seen, scaling the Peano curve horizontally by sqrt(3) greatly improves its\n     L2 locality. Haverkort calls this modified curve \"balanced GP\".\n     \n          Peano             Balanced Peano  \n          . ...                .  ....\n         1. . .              1 .  .  . \n          ... .                ....  . \n            1                   1.73\n     \n     This means the pattern cannot be discretized to a unit grid as-is, as now the cells\n     are rectangular with an irrational aspect ratio. However, it is possible to fix that:\n     \n     1) scale peano curve by a ratio of M/N ~ sqrt(3)\n     2) each 1x1 unit grid cell of the final peano pattern becomes a MxN cell\n     3) fill MxN cell with a connectable pattern with low L2 locality\n     \n     Here, I used the following shape:\n\n       ....  .......   .....\n       .  .  .     .   .\n       .  ....  ....   .....\n       .        .          .\n       ....  ....  .....   . \n          .  .     .   .   .\n       ....  .......   .....\n       \n     A numerical benchmark for L2 locality returns an incredible ~4.65 which is just above\n     the ideal 4.619 and is the new best in literature for discrete SFC patterns that fill\n     rectangular shapes, only outperformed by the H-Curve which is a closed loop.\n*/\n\n//#define LEVELS 1 //uncomment to force a fixed level\n\n// the atomar 7x4 shape that is put in place for each unit cell of the peano curve\n\nint peano_atom(ivec2 p)\n{\n   int flat_idx = p.y * 7 + p.x;   \n   int table[4*7] = int[](0,1,16,17,18,21,22,3,2,15,14,19,20,23,4,7,8,13,12,25,24,5,6,9,10,11,26,27);  \n   return table[flat_idx];\n}\n\nint peano_opt(ivec2 p, int level)\n{\n    int i = 0; \n    \n    for(int b = int(round(pow(3.0, float(level)))); b > 0; b /= 3) \n    {\n        ivec2 tb = b * ivec2(7, 4);\n        \n        ivec2 t = p / tb;\n        int ti = 3 * t.x + t.y + (t.x * 2 & 2) * (1 - t.y);     \n        i = i * 9 + ti;   \n\n        p -= tb * t; \n\n        if(t.y == 1) p.x = tb.x - p.x - 1; \n        if(t.x == 1) p.y = tb.y - p.y - 1;       \n    }\n    \n    \n    i *= 4*7;    \n    i += peano_atom(p);    \n    return i;\n}\n\n//regular peano curve\nint peano(ivec2 p, int level)\n{\n    int i = 0; \n    \n    for(int b = int(round(pow(3.0, float(level)))); b > 0; b /= 3) \n    {\n        ivec2 t = p / b;\n        int ti = 3 * t.x + t.y + (t.x * 2 & 2) * (1 - t.y);     \n        i = i * 9 + ti;   \n\n        p -= b * t; \n\n        if(t.y == 1) p.x = b - p.x - 1; \n        if(t.x == 1) p.y = b - p.y - 1;       \n    }   \n   \n    return i;\n}\n\n\nfloat sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    vec2 d = pa - ba*h;\n    return dot(d,d);\n}\n\nvec3 turbo(float t) {\n\n    const vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n    const vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n    const vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n    const vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n    const vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n    const vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n    const vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = 1.0/iResolution.y;\n    \n    float timescale = iTime * 0.2;\n    \n    bool toggle = iMouse.x < fragCoord.x;  \n    \n    float wrap = sin(iTime);\n    int level = (int(timescale) % 4) + 1;  \n    \n    #ifdef LEVELS\n    level = LEVELS;\n    #endif\n    \n    ivec2 n = ivec2(round(pow(3.0, float(level)))); \n    if(toggle) n *= ivec2(7, 4);\n    vec2 w = 1.0 / vec2(n - 1);\n    \n    vec2 p = fragCoord / iResolution.xy;\n    p = p * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    p.x *= 4.0/7.0;\n    p *= 1.2;\n    \n    p *= 1.0 + w;\n    p = p * 0.5 + 0.5;\n    \n    if(abs(p.x - 0.5) > 0.5 + w.x * 0.5 || abs(p.y - 0.5) > 0.5 + w.y * 0.5){fragColor = vec4(0); return;}  \n    \n    ivec2 cp = ivec2(p * vec2(n - 1) + 0.5);    \n    int cidx = toggle ? peano_opt(cp, level) : peano(cp, level);     \n    \n    ivec2 neighbours[4] = ivec2[](ivec2(-1, 0), ivec2(1, 0), ivec2(0, -1), ivec2(0, 1));\n    \n    vec2 ratio_scale;\n    ratio_scale.y = sqrt(4.0/7.0);\n    ratio_scale.x = 1.0/ratio_scale.y;\n    \n    float d = 2.0;\n    for(int j = 0; j < 4; j++)\n    {\n        ivec2 tp = cp + neighbours[j];\n        tp = clamp(tp, ivec2(0), ivec2(n - 1)); //fixed wrap around\n        int tidx = toggle ? peano_opt(tp, level) : peano(tp, level);\n        if(abs(tidx - cidx) <= 1) d = min(d, sdSqLine(p*ratio_scale, vec2(cp)*w*ratio_scale, vec2(tp)*w*ratio_scale));        \n    }    \n\n    d = sqrt(d);\n    d /= e;\n\n    float f = 4.0/(0.001 + d*d);    \n    f /= 1.0 + f;\n    f *= f;\n    \n    float t = float(cidx)/float(n.x * n.y);\n    t = fract(t - iTime * 0.0625);\n    vec3 col = turbo(t);    \n    fragColor = vec4(f * sqrt(col), 1);\n}","name":"Image","description":"","type":"image"}]}