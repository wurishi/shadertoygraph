{"ver":"0.1","info":{"id":"dtVcDd","date":"1700904747","viewed":48,"name":"Koch by Darko","username":"omegasbk","description":"Just having fun","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["kochfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made by Darko Supe (omegasbk) 2023-11-25\n// Free to re-use, any credits very much appreciated though :) \n\n// This shader is not optimized at all, nor it was written to be short. \n// The main idea was to play with radial space division.\n\n#define PI 3.141592653589793238462\n\nfloat drawLine(vec2 uv, vec2 start, vec2 end, float thickness)\n{\n    // Make line thickness independent of screen size, wooooo\n    //vec2 relative = fwidth(uv);\n    //thickness *= relative.x + relative.y;\n\n    vec2 line = end - start;\n    vec2 lineN = normalize(line);\n    vec2 perpendicularN = vec2(lineN.y, -lineN.x);\n\n    vec2 d1 = uv - start;\n    vec2 d2 = uv - end;\n     \n    float limits = step(length(line), abs(dot(d1, lineN) + dot(d2, lineN)));\n    limits += smoothstep(thickness-thickness/4., thickness, abs(dot(d2, perpendicularN)));\n    \n    return max(0.0, 1. - limits);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nvec2 toPolar(vec2 cartesian)\n{\n\tfloat dist = length(cartesian);\n\tfloat angle = atan(cartesian.y, cartesian.x);\n\treturn vec2(angle / (2.*PI), dist);\n}\n\nvec2 toCartesian(vec2 polar)\n{\n    vec2 cartesian;\n    cartesian.y = sin(polar.x * (2.*PI));\n    cartesian.x = cos(polar.x * (2.*PI));\n    \n    return cartesian * polar.y;\n}\n\n//////////////////////////////////////////////////////////\n// \"Recursion\" \n#define k(koch,koch0) \\\nfloat koch(vec2 uv, vec2 start, vec2 end, float thickness){ \\\n    vec2 p1 = (2. * start + end) / 3.; \\\n    vec2 p2 = (start + 2. * end) / 3.; \\\n    vec2 pM = p1 + rotate2d(PI/3.) * (p2 - p1); \\\n    \\\n    float value = koch0(uv, start, p1, thickness); \\\n    value += koch0(uv, p1, pM, thickness); \\\n    value += koch0(uv, pM, p2, thickness); \\\n    value += koch0(uv, p2, end, thickness); \\\n    \\\n    return value; \\\n} \n\nk(koch1, drawLine)\nk(koch2, koch1)\nk(koch3, koch2)\nk(koch4, koch3)\n//////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv = rotate2d(iTime * 1.2) * uv;\n    \n    fragColor = vec4(0.);\n        \n    float radius = 0.4;\n    if (distance(uv, vec2(0.)) > 0.5)\n        return;\n    \n    vec2 polarUv = toPolar(uv);\n\n    float count = 2. + (sin(iTime) + 1.) * 2.;\n    \n    uv = polarUv;\n    uv.x = fract(uv.x * count);\n    \n    vec2 pol = uv;\n    uv.x = cos(pol.x * 2. * PI / count) * pol.y;\n    uv.y = sin(pol.x * 2. * PI / count) * pol.y;\n\n\n    vec2 p1 = toCartesian(vec2(0., radius));\n    vec2 p2 = toCartesian(vec2(1./count, radius));\n    \n    vec3 col = vec3(koch4(uv, p1, p2, 0.002));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}