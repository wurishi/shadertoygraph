{"ver":"0.1","info":{"id":"NlXGRB","date":"1622290826","viewed":392,"name":"Flocking Bubbles","username":"kastorp","description":"another variation on flocking particles\n","likes":32,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","particles","sort"],"hasliked":0,"parentid":"Nd2SWc","parentname":"Large scale Flocking (analysis)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Flocking Bubbles by kastorp\n//---------------------------------------------------------------------------------\n// code from:\n//     \"Large scale flocking\" by michael0884. https://shadertoy.com/view/tsScRG\n//     Shane \"Rounded Voronoi Borders\"  https://www.shadertoy.com/view/ll3GRM\n//     2D trabeculum - FabriceNeyret2 https://www.shadertoy.com/view/4dKSDV\n//     Iq \"palettes\" https://www.shadertoy.com/view/ll2GD3\n//---------------------------------------------------------------------------------\n\nGETTERS\n\n\nint idn;\n\n//\t2D trabeculum - FabriceNeyret2 https://www.shadertoy.com/view/4dKSDV\nfloat Voronoi(in vec2 pos){\n    ivec4 nb = getClosest(ivec2(pos/ZOOM));\n  \n    bool ghost;\n    vec4 pi0 = getParticle(nb[0],ghost);\n    vec4 pi1 = getParticle(nb[1],ghost);\n    vec4 pi2 = getParticle(nb[2],ghost);\n\n    float d0 = distance(pos/ZOOM,pi0.xy)*ZOOM;\n    float d1 = distance(pos/ZOOM,pi1.xy)*ZOOM;  \n    float d2 = distance(pos/ZOOM,pi2.xy)*ZOOM; \n     \n    float df =min(.4/(1./max(d1 - d0, .001) + 1./max(d2 - d0, .001)), 1.);\n    df*= smoothstep(RADIUS*ZOOM*1.8,0. ,d0);\n    \n    idn= nb[0];\n    return df;\n}\n\n\n//Shane \"Rounded Voronoi Borders\"  https://www.shadertoy.com/view/ll3GRM\nvec2 hMap(vec2 uv){    \n    float h = Voronoi(uv);   \n    float c =  smoothstep(0., fwidth(h)*2., h -.1 )*h;\n    c += (1.-smoothstep(0., fwidth(h)*3., h - .1))*c*.5;     \n    return vec2(clamp(c,0.,1.), h);    \n}\n\n//Iq palettes https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec2 p = fragCoord ;\n    \n    vec2 c = hMap(p);\n    float cid = fract(float(i2xy(idn).x)  /10.);\n   // vec3  col = pal( float(idn)/NP,  vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) )*c.x;\n    vec3  col = pal( cid, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) )*c.x;\n   \n    // Apply the bump - or a powered variation of it - to the color for a bit of highlighting.\n    vec2 c2 = hMap(p + 2.);\n    float b =  (c2.x - c.x)*ZOOM*.5;\n    col += vec3(1.)*(b*2. + b*b*b*12.);\t \n    \n    // Basic gamma correction\n\tfragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//configurable settings:\n#define NP 1600. //number of particles,  must be <=  (iResolution.x)^2\n#define NGH 400 // number of ghosts scanned each frame\n#define dt 2.5 // time interval;  \n#define RADIUS 7. //average dist\n//#define N8  //interact with 8 particles (default is with 4 particle)\n#define MAXSIZE 500.\n//#define WORMY\n//-----------------------\n#define ZERO  min(iFrame,0)\n#define N ivec2(int(sqrt(NP)),int(sqrt(NP)))\n#define size min(vec2(MAXSIZE*iResolution.x/iResolution.y,MAXSIZE),vec2(iResolution.xy))\n#define ZOOM (iResolution.y/size.y)\n#define mouse (iMouse/ZOOM)\n#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define GETTERS ivec4 getClosest(ivec2 p){ return floatBitsToInt(texel(iChannel2, p));} \\\nivec4 getNeighbor(int id){ return floatBitsToInt(texel(iChannel1, i2xy(id)));} \\\nivec4[2] getNeighbor2(int id){ uvec4 v= floatBitsToUint(texel(iChannel1, i2xy(id))); return ivec4[2](ivec4(v&65535u), ivec4(v>>16)); }\\\nvec4 getParticle(int id,out bool ghost){ vec4 p= texel(iChannel0, i2xy(id));ghost=min(p.x,p.y)<0.;return vec4(abs(p.xy),p.zw); }\n\nconst int tot_n = N.x*N.y;\n\n\nivec2 i2xy(int id)\n{\n    return ivec2(id%N.x, id/N.x);\n}\n\nint xy2i(ivec2 p)\n{\n    return p.x + p.y*N.x;\n}\n\nconst float stiffness=0.05;\nconst float damping=0.2;\n\n\nvec2  spring(vec2 posdif,vec2 veldif, float edgelen)\n{\n    vec2 vel = normalize(posdif)*(length(posdif)-edgelen)*stiffness; // spring\n    if(dot(veldif,veldif)!=0.)  vel +=normalize(posdif)*( dot(normalize(posdif),veldif)*damping); // damper\n    return vel;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//particle physics\n\nGETTERS\n\nint cid;\n\n\nvec2 Fv(vec4 p0, int pid)\n{\n    if(pid < 0 || pid >= tot_n || pid == cid) return vec2(0);\n    bool ghost;\n   \tvec4 p1 = getParticle(pid,ghost);\n    float d = distance(p1.xy,p0.xy);\n    \n    \n    float sc=  RADIUS, \n          fd = 0.8/(1.+d/sc) - 4.*exp(-d/sc);\n    \n    vec2 flocking_force =(p1.zw - p0.zw)/(1.+7.*d/sc);\n    \n    vec2 interaction = normalize(p1.xy-p0.xy)* min(0.01,fd);\n    return flocking_force*0.4 +\n        interaction*0.3;\n}\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    if(p.x < N.x && p.y < N.y)\n    {\n        pos = floor(pos); \n        //this pixel value\n        U = texel(iChannel0, pos);\n        U.xy=abs(U.xy);\n        int id = xy2i(p);\n        cid = id;\n        \n        //this pixel value\n        if(iFrame<10 || U==vec4(0))\n        {\n            U.xy = size*vec2(p)/vec2(N);\n\t\t\tU.zw = vec2(0);\n      \t\treturn;\n        }\n        \n#ifdef N8       \n   \t\tivec4[2] cp = getNeighbor2(id);\n   \t  \n        vec2 F = (Fv(U, cp[0].x) +\n            \t Fv(U, cp[0].y) +\n            \t Fv(U, cp[0].z) +\n                 Fv(U, cp[0].w) +\n                 Fv(U, cp[1].x) +\n            \t Fv(U, cp[1].y) +\n            \t Fv(U, cp[1].z) +\n                 Fv(U, cp[1].w))/2.;\n#else\n   \t\tivec4 cp = getNeighbor(id);\n   \t  \n        vec2 F = (Fv(U, cp.x) +\n            \t Fv(U, cp.y) +\n            \t Fv(U, cp.z) +\n                 Fv(U, cp.w));\n#endif\n        \n        bool gh;\n        vec4 p0 = getParticle(id,gh); \n#ifdef WORMY        \n        if(p.y>1) \n        {\n            vec4 p1 = getParticle(xy2i(ivec2(p.x,p.y-1)),gh); \n            F+= spring(p1.xy-p0.xy,p1.zw-p0.zw,RADIUS*2.);\n        }\n       if(p.y< N.y-1) \n        {\n            vec4 p1 = getParticle(xy2i(ivec2(p.x,p.y+1)),gh); \n            F+= spring(p1.xy-p0.xy,p1.zw-p0.zw,RADIUS*2.);\n        }\n#endif\n        if(iMouse.z > 0.) \n        {\n            float d = distance(mouse.xy, U.xy);\n            if(d<size.y*.3) F += 2.*normalize(mouse.xy - U.xy)/(sqrt(d)+2.);\n        }\n        \n        U.zw += (0.5*F)*dt;\n        \n        //random force field\n         U.zw +=.02*dt* ( -2. * texture(iChannel3, 0.6*U.xy/size).xy + 1.);\n        \n        //U.zw = normalize(U.zw);\n        U.xy += U.zw*dt;\n        \n        //border conditions\n        if(size.x - U.x < RADIUS*2.) { U.z = -abs(U.z); U.x = size.x - RADIUS*2.;}\n        if(U.x < RADIUS*2.) {U.z = abs(U.z);U.x = RADIUS*2.;}\n        if(size.y - U.y < RADIUS*2.) {U.w = -abs(U.w); U.y = size.y - RADIUS*2.;}\n        if(U.y < RADIUS*2.) {U.w = abs(U.w); U.y = RADIUS*2.;}\n\n         \n        \n        U.xy = mod(U.xy, size);\n        \n        bool ghost=true;\n        ivec4 nb = getClosest(ivec2(U.xy));\n        for(int i = 0; i<4; i++)\n        {\n            if(nb[i]==id) {ghost=false; break;}\n        }\n        if(ghost) U.xy=-U.xy;\n        \n    }\n    else discard;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//particcle connection\n\nGETTERS\n\n#ifndef N8\n//sorting closest 4 particles\n\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //this particle position\nint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp == tid || utemp < 0) return;\n       \n   \tvec4 part = getParticle(utemp,ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n    //sorting\n    if(dx.x > abs(dx.y))\n    {\n        if(d.x > dtemp) \n        {\n            d.x = dtemp;\n        \tu.x = utemp;\n        }\n    }\n    else if(dx.x < -abs(dx.y))\n    {\n        if(d.y > dtemp) \n        {\n            d.y = dtemp;\n        \tu.y = utemp;\n        }\n    }\n    else if(dx.y > abs(dx.x))\n    {\n        if(d.z > dtemp) \n        {\n            d.z = dtemp;\n        \tu.z = utemp;\n        }\n    }\n    else if(d.w > dtemp) \n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortneighbor(int id)\n{\n    ivec4 nb = getNeighbor(id);\n    for(int j = 0; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    tid = id;\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = 0; i < NGH; i++)\n    {\n        //sort(hash(ivec4(p, iFrame, i)).x%tot_n); //random sort  \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(id); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(nc[i]); \n    }\n    \n    ivec4 nb = getNeighbor(id);\n    for(int i = 0; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(nb[i]); \n         ivec4 nbb = getNeighbor(nb[i]);\n        for(int j = 0; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[j]); \n        }\n    }\n    \n    if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))))\n    {\n        u = ivec4(0);\n    }\n    \n    \n    U = intBitsToFloat(u);\n}\n#else\n\n//sorting closest 8 particles \n\nuvec4[2] u; //ids\nvec4[2] d; //distances\nvec2 pos; //this particle position\nuint tid;\nbool ghost;\n\n//insertion sort\nvoid sort(uint utemp)\n{\n    if(utemp == tid || utemp >=65536u) return; \n     if(  any(equal(u[0], uvec4(utemp))) ||  any(equal(u[1], uvec4(utemp)))) return;\n     \n       \n   \tvec4 part = getParticle(int(utemp),ghost);\n    vec2 dx = part.xy - pos;\n    float dtemp = length(dx);\n     \n\n    //sorting\n    if(d[0].x > dtemp )\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);         \n        d[0] = vec4(dtemp, d[0].xyz);\n        u[0] = uvec4(utemp, u[0].xyz);\n    }\n    else if(d[0].y > dtemp && dtemp > d[0].x)\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n         \n        d[0].yzw = vec3(dtemp, d[0].yz);\n        u[0].yzw = uvec3(utemp, u[0].yz);\n    }\n    else if(d[0].z > dtemp && dtemp > d[0].y)\n    {\n     \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n        \n        d[0].zw = vec2(dtemp, d[0].z);\n        u[0].zw = uvec2(utemp, u[0].z);\n    }\n    else if(d[0].w > dtemp && dtemp > d[0].z)\n    {\n  \n        d[1]= vec4(d[0].w, d[1].xyz);\n        u[1]= uvec4(u[0].w, u[1].xyz);\n          \n        d[0].w = dtemp;\n        u[0].w = utemp;\n    }\n     \n    else if(d[1].x > dtemp && dtemp > d[0].w)\n    {\n        d[1] = vec4(dtemp, d[1].xyz);\n        u[1] = uvec4(utemp, u[1].xyz);\n\n    }   \n    else if(d[1].y > dtemp && dtemp > d[1].x)\n    {\n        d[1].yzw = vec3(dtemp, d[1].yz);\n        u[1].yzw = uvec3(utemp, u[1].yz);\n    }\n    else if(d[1].z > dtemp && dtemp > d[1].y)\n    {\n        d[1].zw = vec2(dtemp, d[1].z);\n        u[1].zw = uvec2(utemp, u[1].z);\n    }\n    else if(d[1].w > dtemp && dtemp > d[1].z)\n    {\n        d[1].w = dtemp;\n        u[1].w = utemp;\n    }\n\n}\n\n\nvoid sortneighbor(int id)\n{\n    ivec4[2] nb = getNeighbor2(id);\n    for(int n=min(iFrame,0);n<2;n++)\n    for(int j = min(iFrame,0); j < 4; j++)\n    {\n        sort(uint(nb[n][j]));\n    }\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{  \n    \n    ivec2 p = ivec2(fragCoord);\n\n    if(p.x > N.x || p.y > N.y) discard;\n    \n    int id = xy2i(p);\n     \n    u = uvec4[2](uvec4(65536u),uvec4(65536u));\n    \n    d = vec4[2](vec4(1e10),vec4(1e10)); \n   \n    tid = uint(id);\n    pos = getParticle(id,ghost).xy;\n    \n    sortneighbor(id); \n    \n    for(int i = ZERO; i < NGH + ZERO; i++)\n    {\n \n        int id=(iFrame*NGH+i) % tot_n;\n        vec4 pp= getParticle(id,ghost);\n        if(ghost) sort(uint(id)); //random sort \n    }\n    ivec4 nc = getClosest(ivec2(pos));\n    for(int i = ZERO; i < 4; i++)\n    {\n        sort(uint(nc[i])); \n    }\n    \n    ivec4[2] nb = getNeighbor2(id);\n    for(int n1= ZERO;n1<2;n1++)\n    for(int i =ZERO; i < 4; i++)\n    {\n        //sort 4x4  particles \n        sortneighbor(int(nb[n1][i])); \n         ivec4[2] nbb = getNeighbor2(nb[n1][i]);\n         for(int n2=ZERO;n2<2;n2++)\n        for(int j = ZERO; j < 4; j++)\n    \t{\n            //sort 4x4x4  particles\n            sortneighbor(nbb[n2][j]); \n        }\n    }\n    \n\n\n    \n   \n    U = uintBitsToFloat(u[0]+(u[1]*65536u));\n}\n\n\n#endif","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//4th order voronoi particle tracking for each screen position\n\nGETTERS\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nivec4 u; //ids\nvec4 d; //distances\nvec2 pos; //pixel position\nbool ghost;\n\nfloat particleDistance(int id, vec2 p)\n{\n    return distance(getParticle(id,ghost).xy, p);\n}\n\n//insertion sort\nvoid sort(int utemp)\n{\n    if(utemp <0) return; \n   \tfloat dtemp = particleDistance(utemp, pos);\n    //sorting\n    if(d.x > dtemp)\n    {\n        d = vec4(dtemp, d.xyz);\n        u = ivec4(utemp, u.xyz);\n    }\n    else if(d.y > dtemp && dtemp > d.x)\n    {\n        d.yzw = vec3(dtemp, d.yz);\n        u.yzw = ivec3(utemp, u.yz);\n    }\n    else if(d.z > dtemp && dtemp > d.y)\n    {\n        d.zw = vec2(dtemp, d.z);\n        u.zw = ivec2(utemp, u.z);\n    }\n    else if(d.w > dtemp && dtemp > d.z)\n    {\n        d.w = dtemp;\n        u.w = utemp;\n    }\n}\n\nvoid sortpos(ivec2 p)\n{\n    ivec4 nb = getClosest(p);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n}\n\nvoid sortPart(int id)\n{\n#ifdef N8  \n    ivec4[2] nb = getNeighbor2(id);\n    for(int n = ZERO; n < 2; n++)\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[n][j]);\n    }\n#else\n    ivec4 nb = getNeighbor(id);\n    for(int j = ZERO; j < 4; j++)\n    {\n        sort(nb[j]);\n    }\n#endif\n}\n\nvoid mainImage( out vec4 U, in vec2 fragCoord )\n{\n    pos = fragCoord;\n    \n    if (any(greaterThan(pos,ceil(size) ))) { discard;} //skip pixels out of screen\n    \n    ivec2 p = ivec2(pos);\n     \n    u = ivec4(-1); d = vec4(1e10); \n   \n    sortpos(p); //resort this position, cause particles are moving\n    \n    //jump flood sorting; minimized gere, raising to 12 or 16 has small effect and  high impact on framerate  \n    for(int i = ZERO; i < 16; i++)\n    {\n        ivec2 p2 =p+cross_distribution(i);\n        \n        //if (! any(greaterThan(p2,ivec2(ceil(size)) )) && ! (! any(lessThan(p2,ivec2(0u) )))) \n        sortpos(p2); \n    }\n    \n    \n    // sort neighbors of closest particles\n    for(int i = ZERO; i<4; i++)\n    {\n        if(u[i]<0) continue;\n        sortPart(u[i]);       \n    }\n    \n    // if( any(lessThan(u, ivec4(-1))) || any(greaterThan(u, ivec4(tot_n))) )  u = ivec4(0); \n    \n    \n    U = intBitsToFloat(u);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}