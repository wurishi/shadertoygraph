{"ver":"0.1","info":{"id":"ltS3Wy","date":"1431877255","viewed":614,"name":"Broken - Mandelbrot","username":"TomHodson","description":"A really simple Mandelbrot shader","likes":3,"published":1,"flags":2,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//map screen space to world space\nvec2 screen_map(vec2 uv, vec2 center, vec2 zoom) {\n    return ((uv - vec2(0.5,0.5)) * zoom) - center;\n}\n\n//raise a complex number to an arbitrary power then add a constant\nvec2 power_add(vec2 z, float power, vec2 c) {\n    float r = length(z);\n    float t = atan(z.y, z.x);\n    return vec2(pow(r,power)*cos(power*t) + c.x, pow(r,power)*sin(power*t) + c.y);\n}\n\n//square a complex number just using components then add a constant\nvec2 square_add(vec2 z, vec2 c) {\n \treturn vec2((z.x*z.x - z.y*z.y) + c.x, (2.0 * z.y * z.x) + c.y);\n}\n\n//calculate if the given point is in the mandelbrot set\nfloat mandelbrot(vec2 c) {\n    \n \tconst float power = 2.0;// + (0.1 * iTime);\n   \tconst float limit = 2.0;// choose a limit of 2 becuase the point is guranteed to diverge once |z| > 2\n    vec2 z = c;\n    float escape = 0.0;\n    \n    for(int i = 0; i < 600; i++)\t{\n        \n        z = square_add(z, c);    \n        //z = power_add(z, power, c);\n        \n        if(length(z) > limit) {\n            //add a fractional part to the escape time to make the colours smoother\n            //based on the observation that the recursion formula is asymptopically just squaring\n            escape =  float(i) - log(log(length(z))/ log(limit)) / log(power) ;//float(i);\n            break;\n        }\n    }  \n    return escape;\n}\n\n//average the pixel value over an area\nfloat average_mandelbrot(vec2 c, float zoom) {\n  vec2 p = zoom / (iResolution.xy * 1.0);  \n float val = 3.0*mandelbrot(c) + mandelbrot(c + p * vec2(1.0, 1.0)) + mandelbrot(c + p * vec2(1.0, -1.0))+ mandelbrot(c + p * vec2(-1.0, 1.0)) + mandelbrot(c + p * vec2(-1.0, -1.0));\n return val / 10.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uv is a 2d vector represnting which pixel you're currently computing\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float zoom = exp(-iTime / 2.0);\n    \n    vec2 center = mix(vec2(0.6, 0.0), vec2(0.236835, 0.812488), clamp(1.0 - exp(-iTime), 0.0, 1.0));\n    vec2 z = screen_map(uv, center, vec2(3.0,2.0) * zoom * 1.1);\n    \n    float escape = average_mandelbrot(z, zoom);\n    //float escape = mandelbrot(z);\n    \n    float Pi = 3.14159;\n    float x = escape / 50.0;\n    vec4 orange = vec4(0.8, 0.2,0.1, 1.0);\n    vec4 black = vec4(0.0, 0.0,0.0, 1.0);\n    \n    fragColor = mix(black, orange, x*1.0);\n  \n}","name":"","description":"","type":"image"}]}