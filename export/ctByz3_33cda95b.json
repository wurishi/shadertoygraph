{"ver":"0.1","info":{"id":"ctByz3","date":"1692055302","viewed":120,"name":"Audio Visualizer Musifyze","username":"xephosbot","description":"Abstract audio visualizer\nReference: https://www.shadertoy.com/view/4stSRs","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["spectrum","audio","audiovisualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sc3D7","filepath":"https://soundcloud.com/diamond-music-official/tri-dnya-dozhdya-otpuskay","previewfilepath":"https://soundcloud.com/diamond-music-official/tri-dnya-dozhdya-otpuskay","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Shader that generates a dynamic visual effect\n\n// Frequency values for different layers\nfloat frequencies[16];\nconst vec2 zeroOne = vec2(0.0, 1.0);\nconst float PI = 3.141592653589793238;\n\n\n// Rotate 2D vector by an angle\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\n// 2D Hash function\nfloat hash2d(vec2 uv) {\n    float f = uv.x + uv.y * 47.0;\n    return fract(cos(f * 3.333) * 100003.9);\n}\n\n// Smoothly interpolate between two values\nfloat smoothInterpolation(float f0, float f1, float a) {\n    return mix(f0, f1, a * a * (3.0 - 2.0 * a));\n}\n\n// 2D Perlin noise function\nfloat noise2d(vec2 uv) {\n    vec2 fractUV = fract(uv.xy);\n    vec2 floorUV = floor(uv.xy);\n    float h00 = hash2d(floorUV);\n    float h10 = hash2d(floorUV + zeroOne.yx);\n    float h01 = hash2d(floorUV + zeroOne);\n    float h11 = hash2d(floorUV + zeroOne.yy);\n    return smoothInterpolation(\n        smoothInterpolation(h00, h10, fractUV.x),\n        smoothInterpolation(h01, h11, fractUV.x),\n        fractUV.y\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n        \n    if (aspectRatio > 1.0) {\n       // Landscape orientation\n       uv.x *= aspectRatio;\n       uv.xy *= iResolution.y / iResolution.x;\n    } else {\n       // Portrait orientation\n       uv.y /= aspectRatio;\n       uv.xy *= iResolution.x / iResolution.y;\n    }\n    \n    vec2 uv2 = uv;\n    uv2.xy *= 4.5;\n\n    float time = iTime + (2.0 * frequencies[0]);\n\n    vec3 color = vec3(0.0);\n    vec3 color2 = vec3(0.0);\n\n    for (int i = 0; i < 16; i++) {\n        frequencies[i] = clamp(1.75 * pow(texture(iChannel0, vec2(0.05 + 0.5 * float(i) / 16.0, 0.25)).x, 4.0), 0.0, 1.0);\n        //frequencies[i] = sin(iTime * (float(i) / 10000.0) + float(i) * 0.1234) * 0.25;\n\n        float wave = sqrt(sin((-(frequencies[i] * noise2d(uv * 3.5 + vec2(rotate2d(iTime)).xy)) * PI) + ((uv2.x * uv2.x) + (uv2.y * uv2.y))));\n\n        vec2 rotatedUV = rotate2d(iTime) * (uv * 1.75);\n\n        wave = smoothstep(0.8, 1.0, wave);\n        color2 += wave * (vec3(rotatedUV.x, rotatedUV.y, 1.7 - rotatedUV.y * rotatedUV.x) * 0.08) * frequencies[i];\n\n        wave = smoothstep(0.99999, 1.0, wave);\n        color2 += wave * vec3(0.2);\n    }\n\n    fragColor = vec4(color2, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}