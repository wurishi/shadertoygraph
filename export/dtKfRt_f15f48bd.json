{"ver":"0.1","info":{"id":"dtKfRt","date":"1702496765","viewed":17,"name":"Raymarching Test 1 (RS)","username":"roey_shap","description":"Got 'em\nCheese.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_MAX_STEPS 100\n#define EPSILON 0.001\n#define MARCH_MAX_DIS 10.0\n#define PI 3.1415926535\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n#define CLIPPING_PLANE_FAR 100.0\n#define numSpheres 10\n\n// WANT TO REFERENCE THIS LATER\n// https://iquilezles.org/articles/distfunctions/\n// https://www.alanzucconi.com/2016/07/01/signed-distance-functions/\n\nfloat map(float min1, float max1, float value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nvec3 map(float min1, float max1, vec3 value, float min2, float max2)\n{\n    float d2 = max2 - min2;\n    float d1 = max1 - min1;\n    float sizeRatio = d2 / d1;\n\n    return (value * sizeRatio) - (min1 * sizeRatio) + min2;\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n// from https://www.alanzucconi.com/2016/07/01/signed-distance-functions/\nfloat smoothUnionSDF(float a, float b)\n{\n    float k = 16.0; //map(-1.0, 1.0, sin(iTime), 2.0, 16.0);\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(max(0.0001,res)) / k;\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nfloat sphereSDF(vec3 position, vec3 center, float radius)\n{\n    return length(position - center) - radius;\n}\n\n// from https://iquilezles.org/articles/distfunctions/\nfloat cubeSDF(vec3 p, vec3 center, mat3 rotations, float b)\n{\n    p = (p * rotations) - center;\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d,0.0));\n}\n\nmat3 rotateX(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cosAngle, -sinAngle),\n        vec3(0.0, sinAngle, cosAngle)\n    );\n}\n\nmat3 rotateY(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(cosAngle, 0.0, sinAngle),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sinAngle, 0.0, cosAngle)\n    );\n}\n\nmat3 rotateZ(float angle)\n{\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    return mat3(\n        vec3(cosAngle, -sinAngle, 0.0),\n        vec3(sinAngle, cosAngle, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    float finalDist = MARCH_MAX_DIS;\n    vec3 spherePos = vec3(0.0);\n    float sphereRadius = 1.0;\n    float fi;\n    for (int i = 0; i < numSpheres; i++)\n    {\n        fi = float(i);\n        spherePos = vec3(sin(0.25 * fi) + cos(fi + iTime), sin(iTime + fi * 0.25) * fi / float(numSpheres), -fi * cos(sin(iTime / (fi + 1.0))));\n        sphereRadius = float(i % 6) * 0.45 * map(-1.0, 1.0, sin((fi * iTime / 10.0) + fi), 0.8, 1.0 / (1.0 + fi));\n        finalDist = smoothUnionSDF(finalDist, sphereSDF(samplePoint, spherePos, sphereRadius));\n    }\n    \n    mat3 xRot = rotateX(sin(iTime) * HALF_PI / 4.0);\n    mat3 yRot = rotateY(cos(iTime + 1.0) * HALF_PI / 2.0);\n    float cubeDist = cubeSDF(samplePoint, vec3(0.5, 0.0, -1.5), xRot * yRot, 0.9);\n    \n    //finalDist = differenceSDF(cubeDist, finalDist);\n    \n    return finalDist;\n/*\n\n    vec3 spherePos = vec3(0.25 + cos(iTime), sin(iTime + PI * 0.25), 0.3);\n    float sphereRadius = map(-1.0, 1.0, sin(iTime + (PI * 0.125)), 0.7, 0.8);\n    float sphereDist = sphereSDF(samplePoint, spherePos, sphereRadius);\n    \n    vec3 sphere2Pos = vec3(0.0, 0.0, 0.3);\n    float sphere2Radius = 1.0;\n    float sphere2Dist = sphereSDF(samplePoint, sphere2Pos, sphere2Radius);\n    //return sphere2Dist;   /// <-------------------------\n    \n    float metaBallDist = smoothUnionSDF(sphereDist, sphere2Dist);\n    return metaBallDist;\n    \n    mat3 xRot = rotateX(sin(iTime) * HALF_PI / 2.0);\n    mat3 yRot = rotateY(cos(iTime + 1.0) * HALF_PI / 2.0);\n    float cubeDist = cubeSDF(samplePoint, vec3(0.5, 0.0, 0.0), xRot * yRot, 0.8);\n    //return differenceSDF(cubeDist, metaBallDist);\n\n    //return smoothIntersectSDF(cubeDist, sphereDist);\n    //return unionSDF(cubeDist, sphereDist);\n    //return cubeDist;\n\n    //return mix(cubeDist, sphereDist, (sin(iTime) + 1.0) / 2.0);\n    */\n}\n\nfloat getObjectIntersectionDistance(vec3 cameraPosition, vec3 viewRayDirection, float maxMarchDistance)\n{\n    float depthMarched = 0.0;\n    for (int i = 0; i < MARCH_MAX_STEPS; i++)\n    {\n        float smallestDistanceToObj = sceneSDF(cameraPosition + (depthMarched * viewRayDirection));\n        if (smallestDistanceToObj < EPSILON)\n        {\n            return depthMarched;\n        }\n        \n        depthMarched += smallestDistanceToObj;\n        \n        if (depthMarched >= maxMarchDistance)\n        {\n            return maxMarchDistance;\n        }\n    }\n    \n    return maxMarchDistance;\n}\n\nvec3 estimateNormal(vec3 p) {\n    vec2 eps = vec2(EPSILON, 0.0);\n    return normalize(vec3(\n        sceneSDF(p + eps.xyy) - sceneSDF(p - eps.xyy),\n        sceneSDF(p + eps.yxy) - sceneSDF(p - eps.yxy),\n        sceneSDF(p + eps.yyx) - sceneSDF(p - eps.yyx)\n    ));\n}\n\nfloat getPlaneDistance(vec3 planeNormal, vec3 planePoint, vec3 rayOrigin, vec3 rayDirection)\n{\n    float inner = dot(planeNormal, rayDirection);\n    if (inner < EPSILON)\n    {\n        return CLIPPING_PLANE_FAR;\n    }\n    \n    return dot(planePoint - rayOrigin, planeNormal) / inner;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float focalDistance = 1.0;\n    vec3 cameraPosition = vec3(0.0, 0.0, focalDistance + 3.0);\n    \n    float smallerDim = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / smallerDim;\n\n    vec3 pixelPosition = vec3(uv, cameraPosition.z - focalDistance);\n    vec3 viewRayDirection = normalize(pixelPosition - cameraPosition);\n\n    float objDistance = getObjectIntersectionDistance(cameraPosition, viewRayDirection, MARCH_MAX_DIS);\n    \n    vec3 hitPoint = cameraPosition + (objDistance * viewRayDirection);\n    \n    vec3 skyColor = vec3(0.0, length(uv), length(uv));\n    vec3 col = vec3(0.0);\n    \n    // assume we have a single point light\n    float lx = 1.0; //map(-1.0, 1.0, sin(0.0), -3.0, 3.0);\n    float ly = 1.0; //-2.0;\n    float lz = -0.6; //map(-1.0, 1.0, sin(0.0), -8.0, -2.0);\n    vec3 lightPosition = vec3(lx, ly, lz);\n    \n    if (objDistance < MARCH_MAX_DIS)\n    {\n        //vec3 lightPosition = vec3(map(-1.0, 1.0, sin(iTime), -1.5, 0.5) + 1.0, -1.0, map(-1.0, 1.0, sin(iTime), -1.5, 0.5));\n        vec3 directionToLight = normalize(lightPosition - hitPoint);\n        \n        vec3 surfaceNormal = estimateNormal(hitPoint);\n        \n        vec3 ambient = vec3(0.8, 0.8, 0.0);\n        float ks = 0.8;\n        float kd = 0.5;\n        float shineSharpness = 10.0;\n        vec3 specularColor = vec3(1.0, 1.0, 1.0);\n        vec3 diffuseColor = vec3(1.0, 1.0, 0.0);\n        vec3 reflectedLightDir = reflect(directionToLight, surfaceNormal);\n        vec3 surfaceToCameraDir = -viewRayDirection;\n        float cosShineAmount = dot(reflectedLightDir, surfaceToCameraDir);\n        float specularAngleIntensity = cosShineAmount > 0.0 ? pow(cosShineAmount, shineSharpness) : 0.0;\n\n        vec3 specular = ks * specularAngleIntensity * specularColor;\n        float diffusionFactor = dot(directionToLight, surfaceNormal);\n        vec3 diffuse = kd * diffusionFactor * diffuseColor;\n        \n        col += ambient + specular + diffuse;\n    }\n    else\n    {\n        float d = getPlaneDistance(vec3(0.0, -1.0, 0.0), vec3(0.0, -2.0, 0.0), cameraPosition, viewRayDirection);\n        if (d < CLIPPING_PLANE_FAR)\n        {\n            //col = vec3(1.0);\n            col += vec3(1.0 - (d / CLIPPING_PLANE_FAR));\n        }\n        else\n        {\n            col = skyColor;\n        }\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}