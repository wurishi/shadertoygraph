{"ver":"0.1","info":{"id":"WscGDX","date":"1569351457","viewed":87,"name":"Rotating Circles Music","username":"MeleeCampz","description":"Just a bunch of circles rotating","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["grid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash12(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 Rot(vec2 inVec, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(\n        inVec.x * c - inVec.y * s,\n        inVec.x * s + inVec.y * c);\n}\n\nvec3 GetCircles(vec2 gv, vec2 id, int iterations, float size)\n{\n    float st = iTime;// mod(iTime * 0.5, 10.);\n    float checker = mod(id.x + id.y, 2.)*2. - 1.;\n    \n    vec3 col = vec3(0);\n    //Generate circles taht \n    for(int i=0; i < iterations; i++)\n    {\n        vec2 offset = vec2(i * 10);\n        \n        float rand01 = hash12(id + offset +id*100.);\n    \tfloat rand02 = hash12(id.yx + offset);\n \n        float circleSpeed = 2. * checker * rand01 * rand02;\n\n        float offsetTime = sin(iTime * 0.1) *.2;\n        offsetTime *= rand01 + rand02;\n        \n        \n        vec2 centerOffset = vec2(rand01, rand02) * offsetTime;\n        centerOffset += vec2(sin(st * circleSpeed), cos(st * circleSpeed));\n        centerOffset *= size;  \n\n        float circleDist = pow(length((centerOffset + gv) * checker),0.85);\n        float circleDistSmooth = smoothstep(.05, -.05, circleDist);      \n        float circle = circleDistSmooth;\n\n        col += circle * vec3(.5, .5, rand01);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y;\n    vec2 oUV = uv;\n    \n    vec3 col = vec3(0);\n    \n    // the sound texture is 512x2\n    int tx = int((fract(uv.x +.5))*512.0);\n    // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    // second row is the sound wave, one texel is one mono sample\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n    //Generate rotated uv\n    vec2 rotUV = Rot(uv, sin(iTime));\n    \n    //Ad music shake\n    uv *= 2. + (wave * .4);\n   \t//Local Zoom\n    uv *= sin(iTime * 0.5) * .5 + 1.0;\n    //Biiig Zoom slow\n    uv *= (cos(iTime * .1)*.5+.5) * 10.;\n    //Move very slowly\n    uv += vec2(iTime *0.1f, iTime *0.2f);\n    //Circle pan camera\n    uv += vec2(sin(iTime), cos(iTime));\n    \n    //Add alternating base color with changing strength\n    col += sin(iTime * 0.2) * vec3(.2,.05,.3);\n\tcol -= cos(iTime * 0.3) * vec3(.2,.05,.3);\n    col*= sin(iTime * 0.1f);\n    \n    //Add fullScreen Circles\n    //vec3 fCircles = GetCircles(oUV, vec2(1,1), 100, cos(iTime) + sin(iTime * 0.2f) * 0.2f);\n    //col += (sin(iTime)*.5+.5) * fCircles;\n\n    \n    //Normal and roated gridUvs;\n    vec2 gv = fract(uv) -.5;\n    vec2 rgv = fract(rotUV) -.5;\n\n    //Cell ids + checker flip\n    vec2 id = floor(uv); \n\tfloat checker = mod(id.x + id.y, 2.)*2. - 1.;\n    \n    //Ping pong between normal and rotated grid uvs\n    gv = mix(rgv, gv, cos(iTime * .5) *.5 +.5 );\n    //gv += vec2(sin(iTime), cos(iTime))* 0.05 * checker;\n    \n    //Geenrate smooth colored centers inside each grid\n    float outer = smoothstep(.5, -.5, length(gv * checker));\n    vec3 oc = vec3(outer * checker, .2, .5) * sin(iTime * 1.);\n    col += oc * outer;\n    \n    //Draw inner glowing circles per grind\n    col += GetCircles(gv, id, 100, .2 + sin(iTime * 0.3) * 0.2f);\n    \n    //Draw streaks per grid\n    float scaleInc = .2 / 10.;\n    float baseScale = 1.;\n    int amount = int((sin(iTime * 0.1)*.5+.5) * 10.) + 10; //10-20\n    int iterations = int((cos(iTime * 0.1)*.5+.5) * 40.) + 10; //10-50\n    for(int i=0; i < iterations; i++)\n    {\n        vec2 iuv = gv * sin(iTime * 0.1) * (baseScale + scaleInc * float(i));\n      \tcol += GetCircles(iuv, id, amount, 0.5f);\n    }\n    \n    //Add white diagnoal flashes\n    float width = (cos(iTime) +0.5) * 0.1;\n    vec2 grid = gv * checker * (sin(iTime) + .5);\n    float mask = smoothstep(.01, -.01, abs(grid.x + grid.y)-width);\n    col+= mask * wave * 0.1;    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}