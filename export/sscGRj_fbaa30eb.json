{"ver":"0.1","info":{"id":"sscGRj","date":"1630170159","viewed":87,"name":"Orbit camera","username":"noocar","description":"Simple statfull orbit camera template.\n\nContolling by WASDQE + mouse.","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["sdf","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.6, 0.9, 0.9);\nconst vec3 LIGHT_POSITION = vec3(2, 2, 7);\n\n\nstruct Surface {\n    float dist;\n    vec3 color;\n};\n\n\n// Signed Distance Functions\n// https://iquilezles.org/articles/distfunctions\nSurface sdTorus(vec3 p, vec2 t, vec3 col)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    float d = length(q)-t.y;\n    return Surface(d, col);\n}\n\nSurface sdCappedCone(vec3 p, float h, float r1, float r2, vec3 col)\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    float d = s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n    return Surface(d, col);\n}\n\nSurface sdOctahedron(vec3 p, float s, vec3 col)\n{\n    p = abs(p);\n    float d = (p.x+p.y+p.z-s)*0.57735027;\n    return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n    float d = p.y + 1.;\n    return Surface(d, col);\n}\n\nSurface sdUnion(Surface obj1, Surface obj2) {\n    if (obj2.dist < obj1.dist) return obj2;\n    return obj1;\n}\n// ----------\n\n\nSurface sdScene(vec3 p) {\n    // Floor\n    vec3 pos = p;\n    vec3 col = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0));\n    Surface s = sdFloor(p, col);\n  \n    // Torus\n    pos = rotateX(PI / 2.) * p + vec3(0., 0., 0.);\n    col = vec3(1., 0., 0.);\n    Surface torus = sdTorus(pos, vec2(.6, .2), col);\n    s = sdUnion(s, torus);\n  \n    // Cone\n    pos = p + vec3(2., 0., 0.);\n    col = vec3(0., 1., 0.);\n    Surface angle = sdCappedCone(pos, .7, .6, .3, col);\n    s = sdUnion(s, angle);\n  \n    // Octahedron\n    pos = p + vec3(-2., 0., 0.);\n    col = vec3(0., 0., 1.);\n    Surface octahedron = sdOctahedron(pos, .75, col);\n    s = sdUnion(s, octahedron);\n\n    return s;\n}\n\n// based on https://inspirnathan.com/posts/47-shadertoy-tutorial-part-1/\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface co; // closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n      vec3 p = ro + depth * rd;\n      co = sdScene(p);\n      depth += co.dist;\n      if (co.dist < PRECISION || depth > end) break;\n    }\n  \n    co.dist = depth;\n  \n    return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1., -1.) * EPSILON;\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).dist +\n        e.yyx * sdScene(p + e.yyx).dist +\n        e.yxy * sdScene(p + e.yxy).dist +\n        e.xxx * sdScene(p + e.xxx).dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 ro = load(POSITION).xyz; // ray origin\n    vec3 rd = camera(ro) * normalize(vec3(uv, -1)); // ray direction\n\n    vec3 col = BACKGROUND_COLOR;\n    Surface s = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n    if (s.dist <= MAX_DIST) {\n      vec3 p = ro + rd * s.dist;\n      vec3 normal = calcNormal(p);\n      vec3 lightDir = normalize(LIGHT_POSITION - p);\n      float dif = clamp(dot(normal, lightDir), 0.3, 1.); // diffuse reflection\n\n      col = dif * s.color + BACKGROUND_COLOR * .2; // Add a bit of background color to the diffuse color\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Keyboard keycodes\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_Q = 81;\nconst int KEY_S = 83;\nconst int KEY_W = 87;\n\n\n// Keyboard bindings\nconst int KEY_BIND_LEFT     = KEY_A;\nconst int KEY_BIND_RIGHT    = KEY_D;\nconst int KEY_BIND_UP       = KEY_W;\nconst int KEY_BIND_DOWN     = KEY_S;\nconst int KEY_BIND_FORWARD  = KEY_Q;\nconst int KEY_BIND_BACKWARD = KEY_E;\n\n\n// Camera constraints\nconst float MIN_YAW = 0. - EPSILON;\nconst float MAX_YAW = TWO_PI;\nconst float DEF_YAW = 0.0;\n\nconst float MIN_PITCH = 0.;\nconst float MAX_PITCH = HALF_PI - EPSILON;\nconst float DEF_PITCH = -PI;\n\nconst float DEF_ROLL = 0.0;\n\nconst float MIN_DIST = 2.;\nconst float MAX_DIST = 10.;\nconst float DEF_DIST = 5.;\n\n\n// Camera settings\nconst float KEYBOARD_MOVEMENT_SENSIVITY = 1. / 15.;\nconst float KEYBOARD_DIST_SENSIVITY = 1. / 5.;\nconst float MOUSE_MOVEMENT_SENSIVITY = PI;\n\n\nvec4 handleKeyboard(vec4 yprd) {\n    vec2 yp = vec2(\n        key(KEY_BIND_LEFT) - key(KEY_BIND_RIGHT),\n        key(KEY_BIND_UP) - key(KEY_BIND_DOWN)\n    );\n    float d = (key(KEY_BIND_BACKWARD) - key(KEY_BIND_FORWARD));\n    yprd += vec4(\n        yp * KEYBOARD_MOVEMENT_SENSIVITY,\n        0.0,\n        d * KEYBOARD_DIST_SENSIVITY\n    );\n\n    return yprd;\n}\n\n\nvec4 handleMouse(vec4 yprd) {\n    // (if mouse not down or mouse is clicked)\n    if (iMouse.z <= 0.0 || iMouse.w > 0.0) {\n        return yprd;\n    }\n\n    vec4 mouse = load(MOUSE);\n    vec2 yp = vec2(iMouse.xy - mouse.xy) / iResolution.xy;\n    yp.y = -yp.y;\n    \n    yprd += vec4(yp * MOUSE_MOVEMENT_SENSIVITY, 0.0, 0.0);\n    \n    return yprd;\n}\n\n\nvec4 constraint(vec4 yprd) {\n    float d = clamp(yprd.w, MIN_DIST, MAX_DIST);\n    vec3 ypr = vec3(\n        clamp(yprd.x, MIN_YAW, MAX_YAW),\n        clamp(yprd.y, MIN_PITCH, MAX_PITCH),\n        DEF_ROLL\n    );\n    ypr = mod(ypr, TWO_PI);\n    \n    return vec4(ypr, d);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0) {\n        vec4 yprd = vec4(DEF_YAW, DEF_PITCH, DEF_ROLL, DEF_DIST);\n        // Initialise\n        store(MOUSE, vec4(0.0));\n        store(YPRD, yprd);\n        store(POSITION, vec4(0.0));\n        \n        return;\n    }\n\n    vec4 yprd = load(YPRD); // Yaw, Pitch, Roll, Dist\n    yprd = handleKeyboard(yprd);\n    yprd = handleMouse(yprd);\n    yprd = constraint(yprd);\n    \n    vec3 radius = rotateYPR(yprd.xyz) * FORWARD * yprd.w;\n    vec3 pos = TARGET + radius;\n\n    store(MOUSE, iMouse);\n    store(YPRD, yprd);\n    store(POSITION, vec4(pos, 0.0));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BUFFER iChannel0\n#define KEYBOARD iChannel1\n\n// using https://www.shadertoy.com/view/4lVXRm\n#define store(P, V) if (all(equal(ivec2(fragCoord), P))) fragColor = V\n#define load(P) texelFetch(BUFFER, ivec2(P), 0)\n#define key(K)  texelFetch(KEYBOARD, ivec2(K, 0), 0).x\n\n// Store buffer keys\nconst ivec2 POSITION = ivec2(1, 0);\nconst ivec2 YPRD = ivec2(2, 0); // Yaw, Pitch, Roll, Dist\nconst ivec2 MOUSE = ivec2(3, 0);\n\n// Scene settings\nconst vec3 TARGET = vec3(0., 0., 0.);\n\n// Some constants\nconst float PI = 3.14159265359;\nconst float TWO_PI = PI * 2.;\nconst float HALF_PI = PI / 2.;\nconst float EPSILON = 0.0005;\n\nconst vec3 FORWARD = vec3(0., 0., 1.);\n\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 rotateYPR(vec3 ypr)\n{\n    return rotateY(ypr.x) * rotateX(ypr.y) * rotateZ(ypr.z);\n}\n\n\nmat3 camera(vec3 pos) {\n\tvec3 d = normalize(TARGET - pos); // camera direction\n\tvec3 r = normalize(cross(vec3(0, 1, 0), d)); // camera right\n\tvec3 u = normalize(cross(d, r)); // camera up\n\t\n\treturn mat3(-r, u, -d);\n}\n","name":"Common","description":"","type":"common"}]}