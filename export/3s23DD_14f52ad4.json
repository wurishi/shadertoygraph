{"ver":"0.1","info":{"id":"3s23DD","date":"1548923578","viewed":295,"name":"Shiny Bubbles","username":"xot","description":"Baby's First Ray Marcher â€” This is my first attempt at making anything \"3D\" in a shader. I am indebted to BigWIngs/@The_ArtOfCode for giving me the nudge I needed to get started.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","demoscene","demo","mirror","atari","xanth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//      ______   _\n//     / __/ /  (_)__  __ __\n//    _\\ \\/ _ \\/ / _ \\/ // /\n//   /___/_//_/_/_//_/\\_, /\n//               ___ /___/ __   __   __\n//              / _ )__ __/ /  / /  / /__ ___\n//             / _  / // / _ \\/ _ \\/ / -_|_-<\n//            /____/\\_,_/_.__/_.__/_/\\__/___/\n//\n//\tcopyright (c) 2019, John \"xot\" Leffingwell\n//  Creative Commons License (CC BY-NC-SA 3.0)\n//\n//\tBased on the \"Shiny Bubbles\" Atari ST demo\n//\tcreated by Xanth FX (released April, 1987)\n//\thttps://www.pouet.net/prod.php?which=14335\n//\n//\tThanks to Martijn Steinrucken for a helpful\n//\tand inspiring ray marching tutorial series.\n//\thttps://www.youtube.com/watch?v=PGtv-dBi2wE\n\n#define ANIM_SPEED .5\n#define MAX_BOUNCES 9\n#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .01\n#define PI 3.14159265\n\n#define bias(b,x) pow(x, log(b)/log(0.5))\n#define boxstep(a,b,x) clamp( ((x)-(a))/((b)-(a)) ,0. ,1.)\n\nstruct material \n{\n    vec3  color;\n    float ambient;\n    float diffuse;\n    float specular;\n    float gloss;\n};\n    \nstruct sphere \n{\n    vec3  center;\n    float radius;\n    int   material;\n};\n\nstruct plane \n{\n    vec4 normal;\n    int  material;\n};\n\nstruct light \n{\n    vec3  position;\n    vec3  color;\n    float intensity;\n};\n\nstruct raysample\n{\n    float dist;\n    vec3  point;\n    int   material;\n    vec3  color;\n};\n\n    \nmaterial M[3];\nplane P[2];\nsphere S[4];\nlight L[1];\n\nvec3  fogColor;\nfloat fogDist;\n\nfloat camFocalLength;\nfloat camPan;\nfloat camTilt;\nvec4  camMove;\n\nvoid Init() \n{\n     //\tMaterials\n    M[0] = material(vec3(1,1,1), 0.0, 0.0, .75, 1.0);\t//\tMirror Balls\n    M[1] = material(vec3(1,1,1), 0.7, 0.4, 0.0, 1.0);\t//\tXOT logotype\n    M[2] = material(vec3(1,1,1), 0.7, 0.8, 0.4, 1.0);\t//\tCheckerboard\n    \n    //\tPlanes\n\tP[0] = plane(vec4(normalize(vec3(0.0, 1.0, 0.0)), -1.5), 1);\n    P[1] = plane(vec4(normalize(vec3(0.0,-1.0, 0.0)), -8.0), 2);\n    \n    //\tSpheres\n    S[0] = sphere(vec3( 0.0, 0.0, 0.0), 1.3, 0);\n    S[1] = sphere(vec3( 0.0, 0.0, 0.0), 1.3, 0);\n    S[2] = sphere(vec3( 0.0, 0.0, 0.0), 1.3, 0);\n    S[3] = sphere(vec3( 0.0, 0.0, 0.0), 1.3, 0);\n    \n    //\tLights\n    L[0] = light(vec3(0, 5, 0), vec3(1.0,1.0,1.0), 1.0);\n    \n    //\tFog\n\tfogColor = vec3(0.35);\n\tfogDist = MAX_DIST;\n    \n    //  Camera\n    camFocalLength = 1.3;\n    camPan = radians(15.0);\n    camTilt = radians(40.0);\n    camMove = vec4(-1.0, 3.0,-4.0, 1.0);\n}\n\nfloat Xor(float a, float b) \n{\n    return a*(1.-b)+b*(1.-a);\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n    return dot(p,n.xyz)-n.w;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) \n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdTorus(vec3 p, vec2 r) \n{\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdXOT(vec3 p, float r) {\n    //\tXOT\n    float dist = MAX_DIST;\n    vec3 a,b;\n        \n    //\tX\n    a = vec3(0.2, 0.0, 0.2);\n    b = vec3(0.4, 0.0, 0.4);\n    dist = min(dist, sdCapsule(p, a, b, r));\n\n    a = vec3(0.4, 0.0, 0.2);\n    b = vec3(0.2, 0.0, 0.4);\n    dist = min(dist, sdCapsule(p, a, b, r));\n\n    //\tO\n    dist = min(dist, sdTorus(p-vec3(0.575, 0.0, 0.3), vec2(0.1, r)));\n\n    //\tT\n    a = vec3(0.75, 0.0, 0.4);\n    b = vec3(0.95, 0.0, 0.4);\n    dist = min(dist, sdCapsule(p, a, b, r));\n\n    a = vec3(0.85, 0.0, 0.2);\n    b = vec3(0.85, 0.0, 0.4);\n    dist = min(dist, sdCapsule(p, a, b, r));\n    \n    return dist;\n}\n\nfloat sdChecked(vec3 p) {\n    p = 2.0 * abs(mod(p, 1.0) - 0.5);\n\treturn Xor(p.x, Xor(p.y, p.z));\n}\n\n\nraysample GetDist(vec3 p) \n{\n    //\tReset Distance & Material\n    raysample d = raysample(MAX_DIST, p, 0, vec3(1));\n    \n    //\tDo Spheres\n    for (int i=0; i<S.length(); i++) \n    {\n        float dS = sdSphere(p-S[i].center, S[i].radius);\n        if (dS < d.dist) {\n            d.dist = dS;\n            d.material = S[i].material;\n        }\n    }\n    \n    //\tDo Planes\n    for (int i=0; i<P.length(); i++) \n    {\n        float dP = sdPlane(p, P[i].normal);\n        if  (dP < d.dist) {\n            d.dist = dP;\n            d.material = P[i].material;\n        }\n    }\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) \n{\n    raysample d = GetDist(p);\n    \n    vec2 e = vec2(.01, 0);\n    vec3 n = d.dist - vec3(\n        GetDist(p-e.xyy).dist,\n        GetDist(p-e.yxy).dist,\n        GetDist(p-e.yyx).dist);\n    \n    return normalize(n);\n}\n\nraysample RayMarch(vec3 rO, vec3 rD, int bounces, vec3 col) \n{\n    //\tSet Distance to Origin\n    raysample dO = raysample(0., rO, 0, col);\n    \n    for (int i=0; i<MAX_STEPS; i++) \n    {\n        //\tStep Forward\n        vec3 p = rO+dO.dist*rD;\n        raysample dS = GetDist(p);\n        dO.dist += dS.dist;\n        dO.point = p;\n        dO.material = dS.material;\n        \n        //\tOn surface? Can we stop?\n        if (dS.dist<SURF_DIST) {\n            //\tSurface has been hit.\n            //\tIs it a mirror? Can we bounce?\n            if (dO.material == 0 && bounces > 0) {\n                //\tReflect ray\n                rO = rO+dO.dist*rD;\n                rD = reflect(rD, GetNormal(rO));\n                rO = rO-dO.dist*rD;\n                //\tNudge ray away from surface\n                dO.dist += 2.0*SURF_DIST;\n                //\tPick up some color\n                dO.color *= M[dO.material].specular + M[dO.material].color * M[dO.material].diffuse;\n                bounces--;\n            } else {\n                break;\n            }\n        }\n        //\tTired of marching? Can we stop?\n        if (dO.dist>MAX_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetLight(vec3 point, vec3 incident, int mat, vec3 col) \n{\n    //\tLight Accumulator\n    vec3 lightTotal = vec3(0);\n    \n    for (int i=0; i<L.length(); i++) \n    {\n        //\tSurface Normal\n    \tvec3 normal = GetNormal(point);\n        \n        //\tLight Vector\n    \tvec3 light = L[i].position - point;\n        float d = length(light);\n        light = normalize(light);\n    \n        //\tBase Light\n        float lightFalloff = 1.0;//(d * d);\n        vec3 lightBase = col * L[i].color * L[i].intensity / lightFalloff;\n        \n        //\tAmbient Component\n        lightTotal += lightBase * M[mat].color * M[mat].ambient;\n\n        //\tTest for Shadows\n        raysample s = RayMarch(point+normal*SURF_DIST*2., light, 0, vec3(0));\n        \n        //\tNot In Shadow?\n        if (s.dist > d) \n        {\n\t\t    //\tDiffuse Component\n            lightTotal += lightBase * M[mat].color * M[mat].diffuse * max(dot(normal, light), 0.);\n\n            //\tSpecular Component\n            lightTotal += lightBase * M[mat].specular * pow(max(dot(reflect(incident, normal), light), 0.), M[mat].gloss);\n        }\n    }\n    return lightTotal;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Init();\n    \n    //\tNormalize UV\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    //\tAnimate Spheres Along 3-Petal Rose\n    for (int i=0; i<4; i++) {\n        float phi = (float(i)*PI/4.) + ANIM_SPEED * iTime;\n        float rad = 4.;\n        S[i].center = rad * vec3(cos(3.*phi)*sin(phi), 0.0, cos(3.*phi)*cos(phi));\n    }\n\t\n    //\tOrient Camera\n    mat4 mPan = mat4(cos(camPan), 0.0,-sin(camPan), 0.0,\n                     0.0,         1.0, 0.0,         0.0,\n                     sin(camPan), 0.0, cos(camPan), 0.0,\n                     0.0,         0.0, 0.0,         1.0);\n    \n    mat4 mTilt = mat4(1.0, 0.0,          0.0,          0.0,\n                      0.0, cos(camTilt), sin(camTilt), 0.0,\n                      0.0,-sin(camTilt), cos(camTilt), 0.0,\n                      0.0, 0.0,          0.0,          1.0);\n    \n    mat4 mMove = mat4(1.0, 0.0, 0.0, 0.0,\n                      0.0, 1.0, 0.0, 0.0,\n                      0.0, 0.0, 1.0, 0.0,\n                      camMove.x, camMove.y, camMove.z, 1.0);\n    \n    mat4 mCamera = mMove * mPan * mTilt;\n    \n    //\tCreate Camera Ray\n    vec4 rO = vec4(0.0, 0.0, -camFocalLength, 1.0);\n    vec4 rD = normalize(vec4(uv.x, uv.y, 0.0, 1.0) - rO);\n    rO = mCamera * rO;\n    rD = mCamera * rD;\n    \n    //\tMarch Through Geometry\n    raysample d = RayMarch(rO.xyz, rD.xyz, MAX_BOUNCES, vec3(1));\n    \n    //\tShade Point of Intersection\n    vec3 color = GetLight(d.point, rD.xyz, d.material, d.color);\n    \n    //\tXOT Texture\n    if  (d.material == 1)\n    {\n        //\tScale\n        float scale = 0.17;\n\t\t\n        //\tTranslate\n        vec3 translate = ANIM_SPEED * iTime * vec3(0,0,-2./PI);\n        \n        vec3 point = fract(scale*d.point+translate);\n        point.y = 0.0;\n        point = mod(point, vec3(1.0, 1.0, 0.5));\n\t\t\n        //\tXOT\n        float rad = 0.017;\n        float dist = sdXOT(point, rad);\n        \n\t\t//\tFilter Texture\n        float f = scale * fwidth(d.dist);\n        dist = smoothstep(rad-f, rad+f, dist);\n        \n        //\tBlue on White\n        color *= mix(vec3(0,0.45,0.68), vec3(1), dist);\n    }\n    \n    //\tCheckerboard Texture\n    if (d.material == 2)\n    {\n        //\tScale\n        float scale = 0.075;\n\t\t\n        //\tTranslate\n        vec3 translate = ANIM_SPEED * iTime * vec3(0,0,-4./PI);\n        \n        //\tCheckerboard\n        vec3 point = scale * d.point + translate;\n        float dist = sdChecked(point);\n        \n        //\tFilter Texture\n        float f = scale * fwidth(d.dist);\n        f *= step(0.1, f);\n        dist = smoothstep(0.5-f, 0.5+f, dist);\n        \n        //\tRed and Yellow\n        color *= mix(vec3(1.0,0.19,0.23), vec3(1.0,1.0,.76), dist);\n    }\n    \n    //\tApply Fog\n    color = mix(color, fogColor, bias(0.3, boxstep(0., fogDist, length(d.point))));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}