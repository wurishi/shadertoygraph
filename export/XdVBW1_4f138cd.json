{"ver":"0.1","info":{"id":"XdVBW1","date":"1528712109","viewed":1129,"name":"Dissolve Effects","username":"noxbuds","description":"Using noise to blend between an object being transparent and opaque. Added some bright edges with bloom to give it some kind of magic effect. Shadows can probably be done better but this works for now.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","dissolve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////\n//                                             //\n//  Testing a dissolve effect in 3D            //\n//                                  - Noxbuds  //\n//                                             //\n/////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.14159\n#define PHI 1.57080\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Comment out to disable bloom\n#define BLOOM\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Grab colour from Buf B\n    col = texture(iChannel0, uv).rgb;\n    \n    #ifdef BLOOM\n    \n    // Add some bloom\n    for (float xOff = -10.0; xOff <= 10.0; xOff++)\n    {\n        for (float yOff = -10.0; yOff <= 10.0; yOff++)\n        {\n            // Distance multiplier\n            float falloff = min(0.1 / pow(length(vec2(xOff, yOff)), 1.5), 1.0);\n            \n            // Get colour\n            vec3 ncol = texture(iChannel0, (fragCoord + vec2(xOff, yOff)) / iResolution.xy).rgb;\n            \n            float bright = calcBrightness(ncol);\n            \n            // Check if it's the bloom colour\n            col = mix(col, ncol, falloff * pow(bright, 2.0));\n        }\n    }\n    #endif\n\t\n    // Colour correction\n    //col = 0.2 * col + 0.8 * sqrt(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////\n//                                             //\n//  Testing a dissolve effect in 3D            //\n//                                  - Noxbuds  //\n//                                             //\n/////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.14159\n#define PHI 1.57080\nvec3 lightDir = normalize(vec3(-0.4, -0.6, 0.4));\n\n/////////////////////////////////////////////////\n//                                             //\n//              NOISE GENERATION               //\n//                                             //\n/////////////////////////////////////////////////\n\n// 2D value noise\nfloat noisev(vec2 p)\n{\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0) * 5647.0);\n}\n\n// Smoother noise\nfloat noise(vec2 uv)\n{\n    // Noise vector\n    vec2 nv = vec2(0.0);\n    \n    // Local positions\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    // Interpolate lv\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    // Calculate each corner\n    float bl = noisev(id);\n    float br = noisev(id + vec2(1, 0));\n    float tl = noisev(id + vec2(0, 1));\n    float tr = noisev(id + vec2(1, 1));\n    \n    // Interpolate values\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float n = mix(b, t, lv.y);\n    \n    // Return n\n    return n;\n}\n\n// FBM function\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p+vec2(0.0, 1.0)); p *= 2.02;\n    f += 0.1250 * noise(p+vec2(1.0, 0.0)); p *= 2.03;\n    f += 0.0625 * noise(p+vec2(1.0, 1.0)); p *= 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//             DISTANCE FUNCTIONS              //\n//                                             //\n/////////////////////////////////////////////////\n\n// Returns the maximum value in a vector\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\n// Sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Cube\nfloat sdBox(vec3 p, vec3 D)\n{\n    vec3 d = abs(p) - D;\n    return length(max(d, 0.0)) - max3(min(d, 0.0));\n}\n\n// Combine two objects\nvec2 combine(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//            RAYMARCHING ALGORITHMS           //\n//                                             //\n/////////////////////////////////////////////////\n\n// Map function\nvec2 map(vec3 p)\n{\n    // Very simple for testing purposes; draw a sphere,\n    // and a plane as a floor underneath.\n    vec2 v = vec2(0.0);\n    \n    // Plane\n    float pdist = sdBox(p + vec3(0.0, 3.2, 0.0), vec3(10.0, 1.0, 10.0));\n    \n    // Sphere\n    float sdist = sdSphere(p + vec3(2.0, 0.0, 0.0), 2.0);\n    \n    // Sphere 2\n    float sdist2 = sdSphere(p - vec3(2.0, 0.0, 0.0), 2.0);\n    \n    // Combine them\n    v = combine(vec2(pdist, 0.0), vec2(sdist, 1.0));\n    v = combine(v, vec2(sdist2, 2.0));\n    \n    // Return v\n    return v;\n}\n\n// Diffuse shading\nvec3 diffuse(vec3 col, vec3 n)\n{\n    return col * max(dot(-lightDir, n), 0.0);\n}\n\n// Specular shading\nvec3 specular(vec3 c, vec3 n, vec3 r)\n{\n    // Calculate diffuse\n    c = diffuse(c, n);\n    \n    // Calculate specular highlight\n    vec3 rr = reflect(-lightDir, n);\n    float spec = max(0.0, dot(rr, r));\n    \n    // Add in the specular hightlights\n    float ks = 0.5;\n    return c * (1.0 - ks) + ks * spec;\n}\n\n// Stretches a point to allow mapping to a sphere\nvec2 stretch(vec2 p)\n{\n    // Stretch near top and bottom\n    p.x *= p.y * 0.75 + 1.0;\n    p.x *= 1.0 - p.y * 0.75;\n    \n    // Return stretched co-ordinates\n    return p;\n}\n\n// Material shader\nvec4 material(float id, vec3 p, vec3 n, vec3 r, out bool hitDiffuse, out bool transparent) \n{\n    // Check the ID\n    if (id == 1.0)\n    {\n        // Test sphere\n        vec4 col = vec4(vec3(0.1, 0.2, 0.1), 0.4);\n        \n        // Calculate UV co-ordinates; we use\n        // cylindrical mapping here\n        vec2 uv = vec2(atan(n.x, n.z) / (2.0 * PI) + 0.5, p.y * 0.5 + 0.5);\n        \n        // Map a texture\n        uv.x = mod((uv.x + 0.22) * 2.0, 1.0);\n        col.rgb = texture(iChannel1, uv).rgb;\n        \n        // Correct the UV coordinates\n        uv = uv * 2.0 - 1.0;\n        \n        // Calculate some noise\n        float nv = fbm(uv * 5.0);\n        \n        // Noise threshold\n        float thresh = 0.5 + 0.5 * sin(iTime);\n        \n        // If the noise is above the thresold,\n        // do not render this; instead, carry\n        // on raymarching\n        if (nv > thresh)\n            transparent = true;\n        \n        // If noise is close to the threshold,\n        // change colour\n        if (nv > thresh - 0.1)\n        {\n            // Set a new colour\n            col = vec4(vec3(0.3, 1.0, 1.0), 0.0);\n            \n            // Return diffuse shading\n\t\t\treturn col;\n        }\n        \n        // Return the colour\n        return vec4(diffuse(col.rgb, n), col.a);\n    }\n    else if (id == 2.0)\n    {\n        // Test sphere 2\n        vec4 col = vec4(vec3(0.1, 0.2, 0.1), 0.4);\n        \n        // Calculate UV co-ordinates; we use\n        // cylindrical mapping here\n        vec2 uv = vec2(atan(n.x, n.z) / (2.0 * PI) + 0.5, p.y * 0.5 + 0.5);\n        \n        // Map a texture\n        uv.x = mod((uv.x + 0.22) * 2.0, 1.0);\n        col.rgb = texture(iChannel1, uv).rgb;\n        \n        // Correct the UV coordinates\n        uv = uv * 2.0 - 1.0;\n        \n        uv += vec2(fbm(uv * 2.0 + vec2(iTime, 0.0)));\n        \n        // Calculate some noise\n        float nv = noise(uv * 25.0);\n        \n        // Noise threshold\n        float thresh = 0.5 + 0.5 * sin(iTime);\n        thresh *= thresh + 0.1;\n        \n        // If the noise is above the thresold,\n        // do not render this; instead, carry\n        // on raymarching\n        if (nv > thresh)\n            transparent = true;\n        \n        // If noise is close to the threshold,\n        // change colour\n        if (nv > thresh - 0.1)\n        {\n            // Set a new colour\n            col = vec4(vec3(1.0, 1.0, 0.0), 0.0);\n            \n            // Return diffuse shading\n\t\t\treturn col;\n        }\n        \n        // Return the colour\n        return vec4(diffuse(col.rgb, n), col.a);\n    }\n    else\n        // Default material (test plane uses this)\n        return vec4(specular(vec3(0.9), n, r), 1.0);\n}\n\n// Calculate the normal of a point\nvec3 calcNormal(vec3 p)\n{\n    vec2 eps = vec2(0.002, 0.0);\n    return normalize(vec3(\n        map(p + eps.xyy).x - map(p - eps.xyy).x,\n        map(p + eps.yxy).x - map(p - eps.yxy).x,\n        map(p + eps.yyx).x - map(p - eps.yyx).x\n    ));\n}\n\n// Soft shadows\nfloat sshadow(vec3 o, vec3 r, float mint, float maxt, float k)\n{\n    float res = 1.0;\n    for (float t = mint; t < maxt;)\n    {\n        float h = map(o + r * t).x;\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;\n}\n\n// Raymarch function\nvec3 raymarch(vec2 uv)\n{\n    // Correct the UV co-ordinates\n    uv = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Setup ray origin\n    vec3 o = vec3(0.0, 1.5, -6.0);\n    \n    // Setup ray direction\n    vec3 r = vec3(uv, PHI);\n    \n    // Mouse position\n    vec2 mp = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    //mp.x *= iResolution.x / iResolution.y;\n    \n    // Rotate camera\n    float rot = -mp.y;\n    r.yz *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    \n    float yrot = -mp.x;\n    r.xz *= mat2(cos(yrot), -sin(yrot), sin(yrot), cos(yrot));\n    \n    // Sample the sky cubemap\n    vec3 col = texture(iChannel0, r).rgb;\n    \n    // Ray properties\n    float maxt = 25.0; // maximum raymarch dist\n    int rayCount = 5; // maximum ray bounces\n    bool rayCanTerminate = false;\n    vec4 firstData = vec4(0.0);\n    vec4 prevData = vec4(0.0);\n    bool hitTransparent = false;\n    \n    // Iterate through each ray\n    for (int rn = 0; rn < rayCount; rn++)\n    {\n        // Terminate if appropriate\n        if (rayCanTerminate)\n            break;\n        \n        // Ray distance travelled\n        float t = 0.0;\n        \n        // 'Falloff multiplier'; a multiplier used to make\n        // various things weaker the more times the ray has\n        // bounced (e.g reflections, shadows)\n        float falloff = 1.0 / float(rn + 1);\n        \n        // Id of the transparent object\n        float transpId = -1.0;\n        \n        // Raymarch    \n        for (int i = 0; i < 512; i++)\n        {\n            // Setup point to test. Margin added is the\n            // camera minimum clip distance\n            vec3 p = o + r * (t + 0.01);\n            \n            // Check if t is beyond the limit\n            if (t > maxt)\n            {\n                // If we've reflected, then add a\n                // sky colour\n                if (rn > 0)\n                    col += texture(iChannel0, r).rgb * falloff * prevData.a;\n                \n                // Terminate ray\n                rayCanTerminate = true;\n                break;\n            }\n            \n            // Evaluate map function\n            vec2 m = map(p);\n            \n            // Transparency\n            bool transparent = false;\n            \n            // Fog values\n            float fog1 = 1.0 / (1.0 + t * t * 0.2);\n            float fog2 = 1.0 / (0.3 + t * t * 0.02);\n            \n            // Check if we hit an object\n            if (m.x < 0.0005 && m.y != transpId)\n            {\n                // Calculate normal\n                vec3 n = calcNormal(p);\n                \n                // Calculate colour\n                vec4 matData = material(m.y, p, n, r, rayCanTerminate, transparent);\n                vec3 ncol = matData.rgb;\n                \n                // If the object is transparent, carry on raymarching\n                if (transparent)\n                {\n                    transpId = m.y;\n                    hitTransparent = true;\n                    continue;\n                }\n                else\n                {\n                    // Calculate shadows. Only calculate shadows if the\n                    // ray y direction is negative, the colour is not\n                    // the glowing dissolve colour and we haven't hit a transparent\n                    // object yet\n                    if (r.y <= 0.0 && calcBrightness(ncol) < 0.6 && !hitTransparent)\n                    \tncol = mix(ncol, ncol * sshadow(p, -lightDir, 0.01, 10.0, 2.0), 0.5 + 0.5 * sin(iTime));\n                    \n                    // Add the colour on\n                    vec3 fcol = falloff * ncol;\n\n                    // Interpolate between the colours based on the reflectiveness\n                    // 0 = only previous colour but darker\n                    // 1 = colour of reflected object\n                    if (rn > 0)\n                    {\n                        // Reflected colour\n                        vec3 rcol = col + fcol;\n\n                        // Mix between reflected colour and colour\n                        // based on the previous reflectiveness\n                        rcol = mix(col, rcol, prevData.a);\n\n                        // Blend between the reflection and the object,\n                        // based on the distance from the object\n                        col = mix(col, rcol, fog1);\n                    }\n                    else\n                        col = fcol;\n\n                    // Set the previous data\n                    prevData = matData;\n\n                    // Set the first data if need be\n                    if (rn < 1)\n                        firstData = matData;\n\n                    // Move the origin to the current point\n                    o = p;\n\n                    // Reflect the ray\n                    r = reflect(r, n);\n\n                    // Break out of the loop\n                    break;\n                }\n            }\n            \n            // Increment t\n            if (m.y != transpId)\n            \tt += m.x * 0.4;\n            else\n                t += 0.1;\n        }\n    }\n    \n    // Return colour\n    return col;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE COMPOSITION              //\n//                                             //\n/////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Do some raymarching\n    vec3 col = raymarch(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Calculates the brightness of a colour\nfloat calcBrightness(vec3 col)\n{\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722;\n}","name":"Common","description":"","type":"common"}]}