{"ver":"0.1","info":{"id":"cdByW3","date":"1688225135","viewed":52,"name":"Ray Marching Thales Macena","username":"chorival","description":"Thales Monteiro Pierini Macena - DRE 116194266","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ufrj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Martijn Steinrucken\n//\n// https://twitter.com/the_artofcode?lang=en\n// https://www.youtube.com/TheArtOfCodeIsCool \n//\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n// https://www.youtube.com/watch?v=Ff0jJyyiVyw\n// https://www.youtube.com/watch?v=AfKGMUDWfuE\n// https://www.youtube.com/watch?v=Vmb7VGBVZJA\n//\n// https://michaelwalczyk.com/blog-ray-marching.html\n// https://www.lcg.ufrj.br/cwdc/13-webgl/shaderToy.mp4\n//\n// A very simple ray marching implementation,\n// with a few SDF functions: sphere, torus, box, cylinder.\n// Boolean operations are also available: \n// union, intersection, difference and blend.\n// \n// The beauty of the method is that there are no more polygons or vertices, \n// but objects are just scalar fields, given by Signed Distance Functions (SDFs).\n//\n// Paulo Roma\n// 17/07/2022\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n\n// Color Functions\n\nfloat g2l(float x) {\n    return x <= 0.04045 ? x/12.92 : pow((x + 0.055)/1.055, 2.4);\n}\n\nvec3 g2l3(vec3 v) {\n    return vec3(g2l(v.x), g2l(v.y), g2l(v.z));\n}\n\n// Rotation matrix.\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat3 rotateY(float k) {\n    float c = cos(k);\n    float s = sin(k);\n    return mat3(c,  0, -s,\n                0,  1,  0,\n                s,  0,  c);\n}\n\n\nvec3 rgb(vec3 color) {\n  return color/255.;\n}\n\n// Shape, sf is the surface and rgb is the color\nstruct Shape {\n    float sf; \n    vec3 color;\n    bool isTexturized;\n    bool isBumped;\n};\n\nShape minShape(Shape spA, Shape spB) {\n  if (spB.sf < spA.sf) return spB; \n  return spA;\n}\n\n\n// SDF of a torus at the origin given its two radius.\nShape dTorus(vec3 p, vec2 r, vec3 color) {\n    Shape sp;\n    sp.color = color;\n    \n    float x = length(p.xz) - r.x;\n    sp.sf = length(vec2(x, p.y)) - r.y;\n    return sp;\n}\n\nShape dPrism( vec3 p, vec2 h, vec3 color ) {\n  Shape sp;\n  vec3 q = abs(p);\n  sp.sf = max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n  sp.color = color;\n  return sp;\n}\n\n// SDF of a box at the origin given its size (width, height and depth).\nShape dBox(vec3 p, vec3 s, vec3 color) {\n    Shape sp;\n    sp.color = color;\n    sp.sf = length(max(abs(p) - s, 0.0));\n    return sp;\n}\n\n// SDF of a sphere, given its center and radius.\nShape dSphere(vec3 p, vec4 s, vec3 color) {\n    Shape sp ;\n    sp.color=color;\n    sp.sf=length(p - s.xyz) - s.w;\n    return sp;\n}\n\nShape dOcta(vec3 p, float s, vec3 color) {\n    Shape sp ;\n    sp.color=color;\n    p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else{sp.sf= m*0.57735027;return sp;}\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  \n    sp.sf= length(vec3(q.x,q.y-s+k,q.z-k));\n  return sp;\n}\n\n// B + A\nShape unionSDF (Shape spA, Shape spB) {\n    return minShape(spA, spB);\n}\n\n// B * A\nShape intersectionSDF (Shape spA, Shape spB) {\n   if (spB.sf > spA.sf) return spB; \n   return spA;\n}\n\n// B - A\nShape differenceSDF (Shape spA, Shape spB) {\n    spA.sf*=-1.;\n    if (spB.sf > spA.sf) return spB; \n    return spA;\n}\n\n// Blend A and B\nShape blendSDF(Shape spA, Shape spB, float k, vec3 color) {\n    float h = clamp(0.5 + 0.5 * (spB.sf - spA.sf) / k, 0.0, 1.0);\n    Shape sp ;\n    sp.color=color;\n    sp.sf= mix(spB.sf, spA.sf, h) - k * h * (1.0 - h);\n    return sp;\n}\n\n// Scene SDF: signed distance function.\nShape getDist(vec3 p) {\n\n     float s = sin(iTime);\n \n    Shape planeDist;\n    planeDist.sf = p.y;\n    planeDist.color=rgb(vec3(190, 190, 250));\n    planeDist.isBumped = true;\n   \n    \n    // Position\n    vec3 sunP1 = p - vec3(0,1,6);\n    float sunDistortion = (sin(mod(2.*iTime,100.) *- p.z) * 0.01) /2.;\n    vec3 sunP = sunP1;\n    sunP.xz *= Rot(-1.*iTime);\n    \n    \n    vec3 mercuryP = p - vec3(0,0,6);\n    mercuryP = (mercuryP * rotateY(iTime * 1.) - vec3(1.) * rotateY(iTime * 4.));\n    mercuryP.xz *= Rot(1.*iTime);\n    \n    \n    vec3 venusP = p - vec3(0,-0.2,6);\n    venusP = (venusP * rotateY(iTime * 1.) - vec3(1.2) * rotateY(iTime * 2.5));\n    \n    vec3 earthP = p - vec3(0,-0.5,6);\n    earthP = (earthP * rotateY(iTime * 1.) - vec3(1.5) * rotateY(iTime * 2.));\n    \n    vec3 marsP = p - vec3(0,-1.,6);\n    marsP = (marsP * rotateY(iTime * 1.) - vec3(2.) * rotateY(iTime * 1.8));\n    marsP.yz *= Rot(1.*iTime);\n   \n   float jupyterDistortion = cos(mod(1.*iTime,50.) * p.y)  *  0.01;\n   vec3 jupyterP1 = p - vec3(0,-1.8,6) + jupyterDistortion;\n    vec3 jupyterP2 = p - vec3(0,-1.5,6) + jupyterDistortion;\n    vec3 jupyterP3 = p - vec3(0.5,-1.6,6) ;\n    vec3 jupyterP4 = p - vec3(0.6,-1.7,6);\n    jupyterP1 = (jupyterP1 * rotateY(iTime * 1.) - vec3(2.5) * rotateY(iTime * 1.3));\n    jupyterP2 = (jupyterP2 * rotateY(iTime * 1.) - vec3(2.5) * rotateY(iTime * 1.3));\n    jupyterP3 = (jupyterP3 * rotateY(iTime * 1.) - vec3(2.5) * rotateY(iTime * 1.3));\n    jupyterP4 = (jupyterP4 * rotateY(iTime * 1.) - vec3(2.5) * rotateY(iTime * 1.3));\n     \n    jupyterP1.y += 0.05*s;\n    jupyterP2.y -= 0.05*s;\n    jupyterP3.x += 0.1*s;\n    jupyterP4.x -= 0.1*s;\n    jupyterP1.xz *= Rot(1.*iTime);\n    jupyterP2.xz *= Rot(1.*iTime);\n    jupyterP3.xz *= Rot(1.*iTime);\n    jupyterP4.xz *= Rot(1.*iTime);\n  \n    \n   \n   float ringDistortion = cos(mod(1.*iTime,100.) * p.z)  *  0.01;\n \n    vec3 saturnP = p - vec3(0,-2.0,6);\n    vec3 ringP1 = p - vec3(0,-2.0,6) + ringDistortion;\n    vec3 ringP2 = p - vec3(0,-2.0,6) + ringDistortion;\n    saturnP = (saturnP * rotateY(iTime * 1.) - vec3(3.2) * rotateY(iTime * 1.24));\n    \n    \n    ringP1 = (ringP1 * rotateY(iTime * 1.) - vec3(3.2) * rotateY(iTime * 1.24));\n    ringP2 = (ringP2 * rotateY(iTime * 1.) - vec3(3.2) * rotateY(iTime * 1.24));\n    saturnP.xz *= Rot(1.*iTime);\n    ringP1.xz *= Rot(1.*iTime);\n    ringP2.xz *= Rot(1.*iTime);\n    \n    vec3 netuneBoxP = p - vec3(0,-2.5,6);\n    vec3 netuneSphereP = p - vec3(0,-2.5,6);\n    netuneBoxP = (netuneBoxP * rotateY(iTime * -1.) - vec3(3.7) * rotateY(iTime * -0.7));\n    netuneSphereP = (netuneSphereP * rotateY(iTime * -1.) - vec3(3.7) * rotateY(iTime * -0.7));\n    netuneBoxP.z +=0.05*s;\n    netuneBoxP.y +=0.05*s;\n    netuneBoxP.xz *= Rot(1.5*iTime);\n    netuneBoxP.yz *= Rot(1.5*iTime);\n    \n    vec3 uranusP = p - vec3(0,-3,6);\n     uranusP = (uranusP * rotateY(iTime * -1.) - vec3(4.2) * rotateY(iTime * -0.9));\n    uranusP.xz *= Rot(2.*iTime);\n    uranusP.xy *= Rot(2.*iTime);\n    uranusP.yz *= Rot(1.5708);\n  \n    \n    // sizes\n    vec4 sunS = vec4(0, 0, 0 , 1); // Sphere\n    vec2 mercuryS = vec2(0.05,0.05); // Prism\n    vec3 venusS = vec3(0.11); // Box\n    vec4 earthS = vec4(0, 0, 0 , 0.13); // Sphere\n   \n    vec4 moonS = vec4(0, 0, 0 , 0.04); // Sphere\n    vec2 marsS = vec2(0.06, 0.03); // Torus\n    vec4 jupyterS1 = vec4(0, 0, 0 , 0.3); // Blend Sphere\n    vec4 jupyterS2 = vec4(0, 0, 0 , 0.2); // Blend Sphere\n    \n    vec4 saturnS = vec4(0, 0, 0 , 0.3); // Sphere\n    vec2 ringS1 = vec2(0.4, 0.01); // Torus\n    vec2 ringS2 = vec2(0.5, 0.01); // Torus\n    \n    vec4 netuneSphereS = vec4(0, 0, 0 , 0.26); // Diff Sphere\n    vec3 netuneBoxS = vec3(0.22); // Diff Box\n   \n    float uranusS =  0.26; // Octo\n    \n    // Shapes\n    Shape sun = dSphere(sunP, sunS, texture(iChannel2, sunP.xz).xyz * rgb(vec3(255,255,0)) * 1.5);\n    // Shape sun = dSphere(sunP, sunS, texture(iChannel1, sunP.xz).xyz);\n    sun.isTexturized = true;\n\n    \n    Shape mercury = dPrism(mercuryP, mercuryS, rgb(vec3(99, 87, 74)) );\n    Shape venus = dBox(venusP, venusS, rgb(vec3(238,203,139)));\n    Shape earth = dSphere(earthP, earthS, rgb(vec3(100, 100, 255)));\n  \n    Shape mars = dTorus(marsP, marsS, rgb(vec3(205, 157, 117)));\n    \n    Shape jupyter1 = dSphere(jupyterP1, jupyterS1, vec3(149, 120, 90));\n    Shape jupyter2 = dSphere(jupyterP2, jupyterS2, vec3(167, 110, 64));\n    Shape jupyter3 = dSphere(jupyterP3, jupyterS1, vec3(149, 120, 90));\n    Shape jupyter4 = dSphere(jupyterP4, jupyterS2, vec3(167, 110, 64));\n    Shape jupyter = blendSDF(\n                        blendSDF(jupyter1,jupyter2,0.1,vec3(167, 110, 64)),\n                        blendSDF(jupyter1,jupyter2,0.04,vec3(167, 110, 64)),\n                        0.3,\n                        rgb(vec3(167, 110, 64))\n                   );\n    \n    Shape saturn = dSphere(saturnP, saturnS, rgb(vec3(234,214,184)));\n    \n    Shape ring1 = dTorus(ringP1, ringS1, rgb(vec3(227,224,192)));\n    Shape ring2 = dTorus(ringP2, ringS2, rgb(vec3(206,206,206)));\n    \n    Shape netune1 = dBox(netuneBoxP, netuneBoxS, rgb(vec3(238,203,139)));\n    Shape netune2 = dSphere(netuneSphereP, netuneSphereS, rgb(vec3(230, 230, 230)));\n    Shape netune = differenceSDF(netune2,netune1);\n    \n    Shape uranus =  dOcta(uranusP, uranusS, rgb(vec3(172, 211, 216)));\n \n    \n    Shape d = minShape(planeDist, sun);\n    d = minShape(d, mercury);\n    d = minShape(d, venus);\n    d = minShape(d, earth);\n    d = minShape(d, mars);\n    d = minShape(d, jupyter);\n    d = minShape(d, saturn);\n    d = minShape(d, ring1);\n    d = minShape(d, ring2);\n    d = minShape(d, netune);\n    d = minShape(d, uranus);\n    \n    return d;\n}\n\n// The normal is the gradient of the SDF scalar field at point p.\n// By using finite difference: \n// https://en.wikipedia.org/wiki/Finite_difference#Relation_with_derivatives \nvec3 getNormal(vec3 p) {\n    // arbitrary — should be smaller than any surface detail in your distance function, \n    // but not so small as to get lost in float precision\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = \n        vec3(\n        getDist(p + e.xyy).sf,\n        getDist(p + e.yxy).sf,\n        getDist(p + e.yyx).sf) - \n        vec3(\n        getDist(p - e.xyy).sf,\n        getDist(p - e.yxy).sf,\n        getDist(p - e.yyx).sf);\n        \n    return normalize(n);\n}\n\nvec3 getNormalBumped(vec3 p) {\n\n    vec2 texCoord = vec2(p.x, p.z); // calculate texture coordinates\n    vec3 bump = texture(iChannel1, texCoord).rgb; // sample bump map\n    bump = bump * 2.0 - 1.0; // convert from [0, 1] to [-1, 1] range\n    vec3 n = getNormal(p); // get normal from distance field\n    n += bump; // perturb normal using bump map\n    return normalize(n);\n    \n   \n}\n\n\n// Walk through empty spheres until the ray hits an object\n// or is beyond MAX_DIST, meaning no hit. \nShape rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    Shape sp;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        Shape distShape= getDist(p);\n        if (distShape.isTexturized) {\n            sp.color = distShape.color;\n            sp.isTexturized = true;\n        } else {\n            sp.isTexturized = false;\n          sp.color= g2l3(distShape.color);\n        }\n        \n        if (distShape.isBumped) {\n           sp.isBumped = true;\n        } else {\n        \n           sp.isBumped = false;\n        }\n        \n        float dS = distShape.sf;\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    sp.sf= dO;\n    return sp;\n}\n\n\n// Phong illumination model, given a point and camera position.\nfloat getLight(vec3 p, vec3 ro, Shape a) {\n    vec3 lightPos = vec3(-2, 5, 0);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 1.5;\n    \n    vec3 l = normalize(lightPos - p);\n    \n    vec3 n;\n    \n    if (a.isBumped) {\n       n = getNormalBumped(p);\n    } else {\n       n = getNormal(p);\n    }\n    vec3 r = reflect(-l,n);\n    \n    // ambient component\n    float amb = 0.1;\n    // ambient reflection coefficient\n    float ka = 1.0;\n    \n    // diffuse component - apply Lambert's cosine law\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    // diffuse reflection coefficient\n    float kd = 0.8;\n    \n    // specular component\n    float shininess = 100.;\n    vec3 v = normalize(ro-p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec,shininess);\n    // specular reflection coefficient\n    float ks = 1.0;\n    \n    // slightly move point p in the direction of the normal,\n    // so the distance is not zero. Otherwise, the first hit \n    // will be at the plane.\n    Shape d = rayMarch(p + 2. * n * SURF_DIST , l);\n    \n    // cast a ray to the light\n    if (d.sf < length(lightPos - p)) {\n        // point in the shadow\n        dif *= 0.1;\n        spec *= 0.5;\n    }\n    \n    // ambient + diffuse + specular components\n    return ka * amb + kd * dif + ks * spec;\n}\n\n// Fragment shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera position\n    vec3 ro = vec3(0, 2.3, -2.7);\n    \n    // projection plane z = 1\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Rotate camera down about the x-axis\n    rd.yz *= Rot(PI * 10. / 180.); \n    \n    Shape d = rayMarch(ro, rd);\n    \n    // point hit by the ray\n    vec3 p = ro + rd * d.sf;\n    \n    // illumination at point p\n    float light_intensity = getLight(p, ro, d);\n    \n    // dark grey\n    // vec3 background_color = vec3(.2, .2, .2);\n    vec3 background_color = texture(iChannel0, uv*vec2(1.,2.)).rgb ;\n    \n    // Antique White color #FAEBD7\n    vec3 surface_color = vec3(0,255,255) / 255.;\n    \n    // pixel color\n    vec3 color;\n    if (d.sf < MAX_DIST) {\n  \n         \n       color = d.color * vec3(light_intensity);\n    \n        \n    } else {\n        color = background_color;\n    }\n\n    // output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}