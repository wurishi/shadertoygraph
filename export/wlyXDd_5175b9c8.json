{"ver":"0.1","info":{"id":"wlyXDd","date":"1584110836","viewed":271,"name":"Ray Marching transparent voxels","username":"hamid","description":"Ray Marching transparent voxels","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ray","marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DIMENSION 10U\n\n//#define DISTANCE_DE_VISIBILITE 1000.0\n\n#define DENSITE 0.05\n\n//#define PLAN vec3(0.,0.,0.)\n\n#define TRANSPARENCE 0.75\n\n#define Seuil_Lumiere_Restante 0.05\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = p.x;\n    r.y = ca*p.y - sa*p.z;\n    r.z = sa*p.y + ca*p.z;\n    return r;\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    vec3 r;\n    r.x = ca*p.x + sa*p.z;\n    r.y = p.y;\n    r.z = -sa*p.x + ca*p.z;\n    return r;\n}\n\nvec4 Cellule(uvec3 coord) {\n\tvec4 h = vec4(hash1(4U*coord.x + 4U*DIMENSION*coord.y + 4U*DIMENSION*DIMENSION*coord.z)\n                 ,hash1(1U + 4U*coord.x + 4U*DIMENSION*coord.y + 4U*DIMENSION*DIMENSION*coord.z)\n                 ,hash1(2U + 4U*coord.x + 4U*DIMENSION*coord.y + 4U*DIMENSION*DIMENSION*coord.z)\n                 ,hash1(3U + 4U*coord.x + 4U*DIMENSION*coord.y + 4U*DIMENSION*DIMENSION*coord.z));\n    h.w = step(clamp(1.-DENSITE,0.,1.),h.w) * TRANSPARENCE;\n    return h;\n}\n\nfloat GetLight(vec3 p, vec3 lightPos, vec3 normal) {\n    \n    vec3 l = normalize(lightPos-p);\n    \n    float p_sca = dot(normal, l);\n    \n    return p_sca/2.+0.5;\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd, vec3 cnum) {\n    \n    vec3 foreground = vec3(0.,0.,0.);\n    vec3 background = vec3(1.,1.,1.);\n    \n    vec3 p = ro;\n    \n\tvec3 end = cnum / 2.;\n    vec3 beg = -end;\n    \n    float p1, p2, p3;\n    float dO;\n    \n    float l;\n    \n    if(!(p.x > beg.x && p.x < end.x && p.y > beg.y && p.y < end.y && p.z > beg.z && p.z < end.z)) {\n        \n    \tif(rd.x > 0.) p1 = (beg.x - p.x) / rd.x;\n    \telse p1 = (end.x - p.x) / rd.x;\n    \n    \tif(rd.y > 0.) p2 = (beg.y - p.y) / rd.y;\n    \telse p2 = (end.y - p.y) / rd.y;\n\n    \tif(rd.z > 0.) p3 = (beg.z - p.z) / rd.z;\n    \telse p3 = (end.z - p.z) / rd.z;\n    \n        dO = max(max(p1, p2), p3);\n        \n    \tp += rd * dO + sign(rd) * vec3(0.001,0.001,0.001);\n        \n    }\n    \n    \n    l = 1.;\n    \n    /*\n    vec3 vvv = step(0.05, abs(round(p) - p));\n    vec3 vvv2 = step(0.05, abs(p - PLAN));\n    \n    if(p.x > beg.x && p.x < end.x && p.y > beg.y && p.y < end.y && p.z > beg.z && p.z < end.z) {\n    if(vvv.x+vvv.y+vvv.z < 2.) {\n        if(vvv2.x+vvv2.y+vvv2.z < 3.) {\n        \tforeground = mix(foreground, vec3(0.75,0.75,0.75), l);\n        \tl = 0.;\n        }}}\n    */\n    \n    \n    \n    while(p.x > beg.x && p.x < end.x && p.y > beg.y && p.y < end.y && p.z > beg.z && p.z < end.z) {\n        \n        uvec3 coord = uvec3(floor(p.x - beg.x), floor(p.y - beg.y), floor(p.z - beg.z));\n        if(Cellule(coord).w > 0.)\n        {\n            \n            vec3 normal = vec3(0.,0.,0.);\n            if(dO == p1) normal.x = -sign(rd.x);\n            if(dO == p2) normal.y = -sign(rd.y);\n            if(dO == p3) normal.z = -sign(rd.z);\n\n            \n    \t\tfloat lum = GetLight(p, ro, normal);\n    \t\tvec3 col = Cellule(coord).rgb * lum * (1.);\n            \n            \n            \n            foreground = mix(foreground, col, l);\n            l -= l * Cellule(coord).w;\n            \n        }\n        \n            \n            p1 = floor(p.x-beg.x)+beg.x; if(rd.x > 0.) p1++;\n            p2 = floor(p.y-beg.y)+beg.y; if(rd.y > 0.) p2++;\n            p3 = floor(p.z-beg.z)+beg.z; if(rd.z > 0.) p3++;\n            \n            p1 = (p1 - ro.x) / rd.x;\n            p2 = (p2 - ro.y) / rd.y;\n            p3 = (p3 - ro.z) / rd.z;\n            \n            dO = min(min(p1, p2), p3);\n            p = ro + rd * dO + sign(rd) * vec3(0.001,0.001,0.001);\n            \n        \n        if(l < Seuil_Lumiere_Restante) return mix(foreground, background, l);\n        \n        /*\n        vvv = step(0.05, abs(round(p) - p));\n        vvv2 = step(0.05, abs(p - PLAN));\n        if(vvv.x+vvv.y+vvv.z < 2.) {\n            if(vvv2.x+vvv2.y+vvv2.z < 3.) {\n                foreground = mix(foreground, vec3(0.75,0.75,0.75), l);\n\t\t\t\tl = 0.;\n            }\n        }\n        */\n        \n        \n    }\n    \n    return mix(foreground, background, l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1.,0.,0.);\n\n    vec3 ro = vec3(0, 0, -sqrt(float(DIMENSION*DIMENSION/4U)+float(DIMENSION*DIMENSION/4U)+float(DIMENSION*DIMENSION/4U)));\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n\tvec2 a = vec2(0.0, 0.0);\n\tif (iMouse.x > 0.0) {\n\t\ta.x = -(1.0 - mouse.y)*1.5;\n\t    a.y = 4.5 -(mouse.x-0.5)*3.0;\n\t}\n\n    rd = rotateX(rd, a.x/1.);\n    ro = rotateX(ro, a.x/1.);\n\n    rd = rotateY(rd, a.y/1.);\n    ro = rotateY(ro, a.y/1.);\n\n    vec3 rm = RayMarch(ro, rd, vec3(DIMENSION));\n\n    \n    fragColor = vec4(rm,1.0);\n}","name":"Image","description":"","type":"image"}]}