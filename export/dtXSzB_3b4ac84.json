{"ver":"0.1","info":{"id":"dtXSzB","date":"1675109032","viewed":188,"name":"Non-Spherical Black Holes","username":"BrushC","description":"Rendering that allows for non-spherical black holes. This isn't completely accurate, and relies on euler integration and newtonian physics, but nonetheless the principles are the same.","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Tonemapping and bloom\n// \n\n// 0 -> best quality, worst performance\n// 1 -> better performance, worse quality\n// 2 -> off\n#define BLOOM_QUALITY 1\n\nvec3 acesTonemapping(vec3 color)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    vec3 finalColor = ((color * (a*color + b)) / (color * (c*color + d) + e));\n    return clamp(finalColor, 0.0, 1.0);\n}\n\nvec3 makeBloom(vec2 uv, int kernelSize) {\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec3 blurredImage = texture(iChannel0, uv).xyz;\n    float k = float(kernelSize);\n    float totalWeight = 0.0;\n    \n    for (float x = -k; x <= k; x++) {\n        for (float y = -k; y <= k; y++) {\n            vec2 offset = vec2(x, y) * 2.0 * pixelSize; // *2 makes the radius bigger but quality slightly worse\n            float weight = sqrt(k*k) - length(vec2(x, y));\n            weight = pow(weight, 9.0);\n            totalWeight += weight;\n            blurredImage += texture(iChannel0, uv + offset).xyz * weight;\n        }\n    }\n    \n    blurredImage /= (pow(2.0*k, 2.0) + 0.25*totalWeight);\n    blurredImage = max(vec3(0.0), blurredImage - 1.0);\n\n    return blurredImage;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.xy);\n    vec3 color = texture(iChannel0, uv).xyz;\n    \n    vec3 bloomThreshold = vec3(length(color) - 1.0);\n    bloomThreshold = max(vec3(0.0), bloomThreshold);\n    bloomThreshold *= color;\n    \n    vec3 bloom = vec3(0);\n    switch (BLOOM_QUALITY) {\n        default: break;\n        case (0): {\n            bloom += 0.1 * makeBloom(uv, 2);\n            bloom += 0.2 * makeBloom(uv, 5);\n            bloom += 0.5 * makeBloom(uv, 10);\n        } break;\n        case (1): {\n            bloom = 0.3 * makeBloom(uv, 4);\n        }\n    }\n    \n    color += bloom;\n    color = acesTonemapping(color);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Math\n#define PI 3.1415\n#define TAU 6.2831\n\n// Phyics\n#define C  2.99792458e8\n#define Mo 2e30\n#define G  6.67408e-11\n\n// Aesthetics\n#define REDSHIFT_BOOST 1.0\n\n// Control\n#define FLY_SPEED 0.2\n#define DAMPENING_FACTOR 0.9\n#define DAMPENING_SPEED 0.1\n\n//\n// Structs\n//\n\nstruct Ray {\n    vec3 position;\n    vec3 velocity;\n    float depth;\n    int steps;\n    float nearest;\n};\n\n\n//\n// Sampling\n//\n\nmat2 rotate(float theta) {\n    return mat2(\n        sin(theta), -cos(theta),\n        cos(theta),  sin(theta)\n    );\n}\n\nvec2 sampleEquirectangular(vec3 v) {\n    vec3 direction = normalize(v);\n\n    vec2 uv;\n\tuv.x = atan(direction.z, direction.x);\n\tuv.y = acos(direction.y);\n    \n\tuv /= vec2(TAU, -PI);\n    return uv;\n}\n\n\n\n//\n// SDFs\n//\n\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat sphereSDF(vec3 x, float r) {\n    return length(x) - r;\n}\n\nfloat boxSDF(vec3 x, vec3 box) {\n    vec3 q = abs(x) - box;\n    float a = length(max(q, 0.0));\n    float b = min(max(q.x, max(q.y, q.z)), 0.0);\n    return a + b;\n}\n\nfloat torusSDF(vec3 x, vec2 torus) {\n    vec2 q = vec2(length(x.xz) - torus.x, x.y);\n    return length(q) - torus.y;\n}\n\nfloat torusKnotSDF(vec3 x, vec4 torus, float spacing) {\n    float polar = atan(x.x, x.z);\n\n    vec2 q = vec2(length(x.xz) - torus.x, x.y);\n    q *= rotate(torus.z * polar + torus.w);\n    q.y = abs(q.y) - spacing * torus.y;\n    \n    return length(q) - torus.y;\n}\n\nfloat cylinderSDF(vec3 x, vec2 cylinder)\n{\n  vec2 d = abs(vec2(length(x.xz), x.y)) - vec2(cylinder.y, cylinder.x);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n//\n// Color stuff\n//\n\nfloat redshift(float velocity) {\n    float z = velocity / C;\n    return z;\n}\n\nvec3 applyRedshift(vec3 color, float z) {\n    vec3 wavelengths = vec3(630.0, 532.0, 465.0);\n    vec3 finalColor = color;\n    float shift = REDSHIFT_BOOST * z / wavelengths.r;\n    finalColor.r += shift;\n    finalColor.g += 0.5*shift;\n    return finalColor;\n}\n\nfloat luminance(vec3 color) {\n    return (color.r * 0.2126) + (color.g * 0.7152) + (color.b * 0.0722);\n}\n\n\n//\n// Extra\n//\n\nvec2 hash22(vec2 x) {\n    vec2 a = vec2(dot(x, vec2(23.582, -1053.83)), dot(x, vec2(3830.5423, 91.285)));\n    return fract(sin(a) * 20283.383);\n}\n\nfloat voronoi(vec2 coordinates) {\n    vec2 standardCoordinates = coordinates - vec2(0.5);\n    vec2 index = floor(standardCoordinates);\n    float minDistance = 1.0;\n    \n    for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n            vec2 offset = vec2(x, y);\n            vec2 point = index + offset;\n            point += hash22(point) - 0.5;\n            float pointDistance = length(point - standardCoordinates);\n            \n            minDistance = min(minDistance, pointDistance);\n        }\n    }\n    return minDistance;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Input and state saving\n//\n\n// https://keycode.info/\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_Q 81\n#define KEY_E 69\n\nvec3 handleKeyboard(vec2 rotations) {\n    // Get all of the amounts to move\n    float forward  = texelFetch(iChannel1, ivec2(KEY_W, 0), 0).x;\n    float backward = -texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x;\n    float right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x;\n    float left  = -texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x;\n    float up   = texelFetch(iChannel1, ivec2(KEY_Q, 0), 0).x;\n    float down = -texelFetch(iChannel1, ivec2(KEY_E, 0), 0).x;\n    \n    // Move according to transformed forward and right vectors\n    mat2 xzRotation = rotate((PI / 2.0) * rotations.x);\n    mat2 yzRotation = rotate((PI / 2.0) + rotations.y);\n    vec3 forwardVector = vec3(0, 0, -1);\n    forwardVector.yz *= yzRotation; forwardVector.xz *= xzRotation;\n    vec3 rightVector = vec3(1, 0, 0);\n    rightVector.yz *= yzRotation; rightVector.xz *= xzRotation;\n    \n    return vec3(0, up+down, 0) - (forwardVector * (forward+backward)) + (rightVector * (left+right));\n}\n\nvec4 handleMouse(vec4 mouseInfo) {\n    vec2 mouseNormalized = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    vec2 dMouse = mouseInfo.zw - mouseNormalized;\n    \n    // Hacky way of getting continuous rotation\n    if (abs(dMouse.x) >= 0.1 || abs(dMouse.y) >= 0.1) {\n        return vec4(mouseInfo.xy, mouseNormalized);\n    } else {\n        vec2 clampedMouse = mouseInfo.xy + dMouse;\n        clampedMouse.y = clamp(clampedMouse.y, -1.2, 1.2);\n        return vec4(clampedMouse, mouseNormalized);\n    }\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 slot0 = texelFetch(iChannel0, ivec2(0, 0), 0); // Velocity (x, y, z)\n    vec4 slot1 = texelFetch(iChannel0, ivec2(1, 0), 0); // Position (x, y, z)\n    vec4 slot2 = texelFetch(iChannel0, ivec2(2, 0), 0); // Rotation (theta, phi, px, py)\n    \n    slot2 = handleMouse(slot2);\n    slot0.xyz = mix(slot0.xyz * DAMPENING_FACTOR, FLY_SPEED * handleKeyboard(slot2.xy), DAMPENING_SPEED);\n    slot1.xyz += slot0.xyz;\n    \n    \n    // Default values\n    if (iFrame < 5) {\n        int index = int(fragCoord.x);\n        switch(index) {\n            case(0): { fragColor = vec4(0.0, 0.0, 0.0, 0.0); } break;\n            case(1): { fragColor = vec4(0.0, 2.0, -10.0, 0.0); } break;\n            case(2): { fragColor = vec4(PI / 3.0, 0.0, 0.0, 0.0); } break;\n            default: fragColor = vec4(0.0);\n        }\n        return;\n    }\n    \n    int index = int(fragCoord.x);\n    switch(index) {\n        case(0): { fragColor = slot0; } break;\n        case(1): { fragColor = slot1; } break;\n        case(2): { fragColor = slot2; } break;\n        default: fragColor = vec4(0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_STEPS 256\n#define MAX_DIST 1e3\n#define MIN_DIST 1e-2\n#define STEP_MULTIPLIER 0.8\n\n// (x, y, z, mass (in solar masses))\nfloat blackHoleMass = 5.0;\n\n// Where all the fun stuff happens\nfloat blackHoleDistance(vec3 x) {\n    vec3 point = x;\n    // point = abs(point) - vec3(15);\n    point.yz *= rotate(PI - 0.3);\n    // point.yz *= rotate(0.3 * iTime);\n    point.xy *= rotate(0.6 * iTime + 5.0);\n\n    // float blackHoleDistance = sphereSDF(point, 0.9);\n    // float blackHoleDistance = boxSDF(point, vec3(0.5));\n    // float blackHoleDistance = torusSDF(point, vec2(2.0, 0.04));\n    float blackHoleDistance = torusKnotSDF(point, vec4(2.0, 0.03, 0.0, iTime), 12.0);\n    \n    return blackHoleDistance;\n}\n\n// Standard raymarching distance estimator\nfloat distanceEstimator(vec3 x) {\n    float disk = cylinderSDF(x, vec2(0.01, 18.0));\n    float cube = boxSDF(x, vec3(3));\n    \n    return min(disk, blackHoleDistance(x));\n}\n\n// For lighting\nvec3 geometryNormal(vec3 samplePoint) {\n    vec2 d = vec2(0.01, 0.0);\n    \n    vec3 normal = distanceEstimator(samplePoint) - vec3(\n        distanceEstimator(samplePoint - d.xyy),\n        distanceEstimator(samplePoint - d.yxy),\n        distanceEstimator(samplePoint - d.yyx)\n    );\n    return normalize(normal);\n}\n\n// Gets the direction that light needs to travel when affected by gravity\nvec3 blackHoleNormal(vec3 samplePoint) {\n    vec2 d = vec2(0.01, 0.0);\n    \n    vec3 normal = blackHoleDistance(samplePoint) - vec3(\n        blackHoleDistance(samplePoint - d.xyy),\n        blackHoleDistance(samplePoint - d.yxy),\n        blackHoleDistance(samplePoint - d.yyx)\n    );\n    return normalize(normal);\n}\n\n// Applies newtonian kinematics to each ray as if it's a photon\nRay newtonianRaymarch(vec3 rayOrigin, vec3 rayDirection, float geometryInfluence) {\n    Ray ray = Ray(rayOrigin, rayDirection * C, 0.0, 0, 5.0);\n    \n    for (ray.steps = 0; ray.steps < MAX_STEPS; ray.steps++) {\n        float stepDistance = distanceEstimator(ray.position) * STEP_MULTIPLIER;\n        float r1 = blackHoleDistance(ray.position); // Radius from the object to the black hole\n        \n        stepDistance = mix(r1, stepDistance, geometryInfluence);\n        \n        float r2 = stepDistance; // Amount of distance traveled in current step\n        \n        ray.nearest = min(ray.nearest, r1);\n        \n        // Set each \"unit\" to be 100 kilometers\n        r1 *= 1e5;\n        r2 *= 1e5;\n        \n        // Physics\n        float velocityMagnitude = length(ray.velocity);\n        \n        float a = (G * blackHoleMass * Mo) / (r1*r1);\n        float t = r2 / velocityMagnitude;\n        vec3 tangentDirection = -blackHoleNormal(ray.position);\n        \n        ray.velocity += tangentDirection*a*t; // v = a * t\n        \n        // Standard raymarching\n        ray.position += stepDistance * normalize(ray.velocity);\n        ray.depth += stepDistance;\n        \n        if (ray.depth >= MAX_DIST || stepDistance <= MIN_DIST) break;\n    }\n    \n    ray.nearest /= 5.0;\n    return ray;\n}\n\nmat4 readVariables() {\n    mat4 vars;\n    vars[0] = texelFetch(iChannel1, ivec2(0, 0), 0);\n    vars[1] = texelFetch(iChannel1, ivec2(1, 0), 0);\n    vars[2] = texelFetch(iChannel1, ivec2(2, 0), 0);\n    vars[3] = texelFetch(iChannel1, ivec2(3, 0), 0);\n    return vars;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized and aspect corrected UVs\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Continuous variables\n    mat4 vars = readVariables();\n    \n    // Camera setup\n    vec3 rayOrigin = vec3(vars[1].xyz);\n    vec3 rayDirection = vec3(uv, 1.0);\n    \n    mat2 xzRotation = rotate((PI / 2.0) * vars[2].x);\n    mat2 yzRotation = rotate((PI / 2.0) + vars[2].y);\n    \n    rayDirection.yz *= yzRotation;\n    rayDirection.xz *= xzRotation;\n    \n    rayDirection /= sqrt(3.0);\n\n    // Raymarching\n    Ray backRayOutput = newtonianRaymarch(rayOrigin, rayDirection, 0.0); // Purely black hole rendering\n    Ray rayOutput = newtonianRaymarch(rayOrigin, rayDirection, 1.0); // Geometry and black hole\n    vec3 outDirection = normalize(backRayOutput.velocity);\n    float outVelocity = length(backRayOutput.velocity);\n    \n    // Separate channel for the geometry\n    vec4 geometryColor = vec4(0);\n    \n    // Need to find a way to remove the ugly and slow if statements\n    // Geometry rendering\n    if (\n    rayOutput.depth <= MAX_DIST &&\n    distanceEstimator(rayOutput.position) != blackHoleDistance(rayOutput.position)\n    ) {\n        vec3 surfacePoint = rayOutput.position + outDirection * distanceEstimator(rayOutput.position);\n        vec3 normal = geometryNormal(surfacePoint);\n        \n        vec2 uvs = surfacePoint.xz;\n        float scale = 0.3;\n        uvs *= scale;\n        uvs *= rotate(iTime * 0.08 + 30.0*scale*exp(-length(uvs)));\n        uvs.x += 0.1 * sin(4.0*length(surfacePoint.xz) - iTime);\n        uvs.y += 0.1 * cos(4.0*length(surfacePoint.xz) - iTime);\n        \n        float size = 1.2;\n        float falloff = scale*exp(-size * length(uvs));\n        falloff -= 3.0 * scale*exp(-2.1*size * length(uvs));\n        falloff = clamp(falloff, 0.0, 1.0);\n        falloff *= 10.0;\n        \n        \n        float density = texture(iChannel2, uvs).x;\n        density *= 4.0;\n        density += pow(density / 4.0, 8.0) * 100.0;\n        \n        geometryColor = vec4(vec3(1.0, 0.55, 0.25) * density, falloff);\n    }\n    \n    // Questionable masking approach to get transparency\n    float blackHoleMask = 0.0;\n    if (backRayOutput.depth <= MAX_DIST) {\n        blackHoleMask = 1.0;\n    }\n    \n    // Composition\n    float photonSphere = exp(-15.0*backRayOutput.nearest);\n    photonSphere *= 5.0;\n    \n    // photonSphere += (float(backRayOutput.steps) / float(MAX_STEPS));\n    \n    // Background texture\n    vec2 samplerCoordinates = sampleEquirectangular(outDirection);\n    samplerCoordinates *= 6.0 * vec2(1.0, -1.0);\n    samplerCoordinates *= rotate(0.01*iTime);\n    \n    vec3 backgroundTexture = texture(iChannel0, samplerCoordinates).xyz;\n    backgroundTexture = normalize(backgroundTexture) * pow(luminance(backgroundTexture), 3.0);\n    \n    vec3 color = backgroundTexture;\n    float z = redshift(outVelocity) * dot(outDirection, rayDirection);\n    color = applyRedshift(color, 1.0 - z);\n    \n    vec3 composition = max(vec3(0.0), color * (1.0 - photonSphere)) + (vec3(1.0, 0.55, 0.25) * 1.0 * photonSphere);\n    composition *= (1.0 - blackHoleMask);\n    composition = mix(composition, geometryColor.xyz, geometryColor.w);\n    composition = max(vec3(0.0), composition);\n    \n    fragColor = vec4(vec3(composition), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}