{"ver":"0.1","info":{"id":"MlBXDz","date":"1443509754","viewed":868,"name":"Alien homeworld","username":"AdamAlexander","description":"An alien planet.\n\nUncomment ENABLE_DETAILS to add details to the planet and clouds.","likes":26,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","planet","alien","atmosphericscattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define ENABLE_DETAILS\n#define ENABLE_CLOUDS\n\nconst float PI = 3.14159265359;\nconst float ROTATE_PERIOD = 240.0;\nconst float precis = .02;\nconst int IN_STEPS = 10;\nconst float FIN_STEPS = 10.0;\nconst int OUT_STEPS = 5;\nconst float FOUT_STEPS = 5.0;\n\n// Scale constants\nconst float SCALE = 100.0;\nconst float MAX = SCALE*100.0;\nconst float OCEAN_FLOOR = 0.98;\nconst float OCEAN = 0.99;\nconst float SEA_LEVEL= OCEAN*SCALE;\nconst float ATMOSPHERE = 1.05;\nconst float ATMOSPHERE_LOWER = SCALE;\nconst float ATMOSPHERE_UPPER = ATMOSPHERE*SCALE;\nconst float ATMOSPHERE_HEIGHT = ATMOSPHERE_UPPER - ATMOSPHERE_LOWER;\n\nconst float H0 = 4.0 / ATMOSPHERE_HEIGHT;\n\n// Scatter constants\nconst float K_R = 0.05;\nconst float K_M = 0.0025;\nconst float K_C = 6.0;\nconst float E = 14.3; \t\t\t\t\t\t// light intensity\nconst vec3 C_R = vec3(0.21, 0.66, 1.0);\t\t// 1 / wavelength ^ 4\nconst vec3 C_C = vec3(1.0);\nconst float G_M = -0.81;\t\t\t\t\t// Mie g\nconst float G_C = 0.10;\n\nmat3 rotX(float a) { return mat3(1.0, 0.0, 0.0, 0.0, cos(a), sin(a), 0.0, -sin(a), cos(a)); }\nmat3 rotY(float a) { return mat3(cos(a), 0.0, sin(a), 0.0, 1.0, 0.0, -sin(a), 0.0, cos(a)); }\nmat3 rotZ(float a) { return mat3(cos(a), sin(a), 0.0, -sin(a), cos(a), 0.0, 0.0, 0.0, 1.0); }\n\nmat3 planetSpin() { return rotY(-iTime*PI/ROTATE_PERIOD); }\n\nfloat time() {\n\tvec2 mo = iMouse.xy/iResolution.xy;\n    return iTime + mo.x*64.0;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n/* Noises ************************************************************************/\n\n/* From iq elevated shader: https://www.shadertoy.com/view/MdX3Rr */\nfloat noise3( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n/* From Ashima webgl noise library: https://github.com/ashima/webgl-noise/wiki */\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec2 cellular2x2x2(vec3 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 1/2-K/2\n#define K2 0.020408163265306 // 1/(7*7)\n#define Kz 0.166666666667 // 1/6\n#define Kzo 0.416666666667 // 1/2-1/6*2\n#define jitter 0.8 // smaller jitter gives less errors in F2\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\n\tvec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 p1 = permute(p + Pi.z); // z+0\n\tvec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\n\tvec4 ox1 = fract(p1*K) - Ko;\n\tvec4 oy1 = mod(floor(p1*K), 7.0)*K - Ko;\n\tvec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract(p2*K) - Ko;\n\tvec4 oy2 = mod(floor(p2*K), 7.0)*K - Ko;\n\tvec4 oz2 = floor(p2*K2)*Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter*ox1;\n\tvec4 dy1 = Pfy + jitter*oy1;\n\tvec4 dz1 = Pf.z + jitter*oz1;\n\tvec4 dx2 = Pfx + jitter*ox2;\n\tvec4 dy2 = Pfy + jitter*oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter*oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\tvec4 d = min(d1,d2); // F1 is now in d\n\td2 = max(d1,d2); // Make sure we keep all candidates for F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw\n\td.y = min(d.y, d.z); // nor in d.z\n\td.y = min(d.y, d.w); // nor in d.w\n\td.y = min(d.y, d2.x); // F2 is now in d.y\n\treturn sqrt(d.xy); // F1 and F2\n}\n/* End Noises *********************************************************************/\n\nvec2 planetMap(in vec3 p) \n{\n    p = planetSpin()*p;\n    \n    // Noises\n    float pn1 = noise3(p/32.0);\n    float pn2 = noise3(p*(2.1/32.0));\n    float pn3 = noise3(p*(4.2/32.0));\n    \n    // Perlin FBM\n    float pf1 = pn1 + 0.5*pn2 + 0.25*pn3;\n    \n    // Ridged multi fractal\n    float rmf = 0.0;\n    float signal = 0.0;\n    signal = pow(1.0-abs(pn2), 2.0); rmf += signal;\n    signal = pow((1.0-abs(pn3)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.5*signal;\n    \n#ifdef ENABLE_DETAILS\n    float pn4 = noise3(p*(8.82/32.0));\n    float pn5 = noise3(p*(18.522/32.0));\n    float pn6 = noise3(p*(38.8962/32.0));\n    \n    pf1 += 0.125*pn4 + 0.0625*pn5 + 0.03125*pn6;\n    \n    signal = pow((1.0-abs(pn4)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.25*signal;\n    signal = pow((1.0-abs(pn5)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.125*signal;\n    signal = pow((1.0-abs(pn6)), 2.0)*clamp(signal*1.5, 0.0, 1.0); rmf += 0.06125*signal;\n#endif\n    \n    float d = 0.0;\n    float mat = 1.0;\n    d += ATMOSPHERE_HEIGHT/4.0 * pf1;\n    float land = clamp(d/(ATMOSPHERE_HEIGHT/4.0), 0.0, 1.0);\n    \n    // Mountain\n    float mn = 2.5*rmf;\n    float mountainMask = smoothstep(0.55, 1.0, clamp(abs(0.925-pn2), 0.0, 1.0))*land;\n    \n    mat = mix(mat, 2.0, smoothstep(0.0, 0.5, mountainMask));\n    d += mix(0.0, mn, mountainMask);\n    \n    return vec2(sdSphere(p, SEA_LEVEL+d), mat);\n}\n\nfloat waterDepth(vec3 pos, float tol) {\n\tvec3 dir = -normalize(pos);\n    float t = 0.0;\n    for (int i=0; i < 10; i++) {\n    \tvec2 res = planetMap(pos+dir*t);\n        t += res.x*tol;\n    }\n    return t;\n}\n\nvec2 map(in vec3 pos) {\n    vec2 planet = planetMap(pos);\n    vec2 water = vec2(sdSphere(pos, SCALE*OCEAN), 10.0);\n  \n    vec2 res = opU(planet, water);\n    return res;\n}\n\n// From \"Ray Marching - Primitives\" shader: https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.25, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 sunDirection() { return normalize( vec3(0.0, 0.0, -1.0) ); }\nvec3 sunColour() { return vec3(1.0, 1.0, 1.0); }\n\nvec2 rayMarch(in vec3 ro, in vec3 rd, float tol, float tmin, float tmax) {\n\tfloat t = tmin;\n\tfloat m = -1.0;\n    \n    for (int i=0; i<60; i++) {\n\t\tvec2 res = map(ro+rd*t);\n        m = res.y;\n\t\tif (res.x < precis || t > tmax)  break;\n\t\tt += res.x*tol;\n\t}\n\n\tif (t > tmax) {\n\t\tm = -1.0;\n\t}\n\treturn vec2(t, m);\n}\n\n/* Atmospheric scattering code from gltracy shader: https://www.shadertoy.com/view/lslXDr\n * with additions for clouds and reflections from the planet surface. */\nvec2 lineIntersectSphere(in vec3 o, in vec3 dir, float r) {\n\tfloat b = dot( o, dir );\n\tfloat c = dot( o, o ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\nfloat phase_reyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat airDensity(vec3 p) {\n    return exp(-(max(length(p), ATMOSPHERE_LOWER) - SCALE) * H0);\n}\n\nfloat aerosolDensity(vec3 p) {\n    return exp(-(max(length(p), ATMOSPHERE_LOWER) - SCALE) * H0);\n}\n\n/* When cloudView is non-zero, clouds are faded out as they approach right angles with this\n * vector. Helps to stop artifacts on the horizon. */\nfloat cloudDensity(vec3 p, vec3 cloudView) {\n    vec3 np = planetSpin()*p;\n    float polarness = abs(dot(normalize(np), vec3(0.0,1.0,0.0)));\n    np *= rotY(0.5*(1.0-polarness*polarness)*sin(2.5*normalize(np).y + iTime/75.0) + 0.25*(1.0-polarness*polarness)*cos(2.5*normalize(np).x + iTime/150.0));\n    \n    // Noises\n\tfloat t = iTime/2.0;\n    vec3 dir = sin(t + PI*(p.x/4.0))*vec3(1.0,0.0,0.0) + cos(t + PI*(p.y/4.0))*vec3(0.0,1.0,0.0) + cos(t + PI*(p.z/4.0))*vec3(0.0,0.0,1.0);\n    float pn1 = (noise3((np + 0.5*dir)/14.0)-0.45)/0.55 + 3.0*pow(polarness, 1.75);\n    float pn2 = noise3((np + 0.5*dir)/7.0);\n    \n    float cn = 0.05*pn1 + 0.025*pn2;\n    \n#ifdef ENABLE_DETAILS\n    float pn3 = noise3((np + 0.5*dir)/3.5);\n    cn += 0.0125*pn3;\n#endif\n    \n    float edgeness = (1.0-length(cloudView))+abs(dot(normalize(p), cloudView));\n    edgeness = pow(edgeness, 1.5);\n    cn *= edgeness;\n    \n    float hs = clamp((length(p)-SCALE)/ATMOSPHERE_HEIGHT, 0.0, 1.0);\n    return exp(-pow(hs -.35, 2.0)/0.02)*clamp(cn, 0.0, 1.0)*2.0;\n}\n\nvec3 density(vec3 p, vec3 cloudView) {\n#ifdef ENABLE_CLOUDS\t\n    return vec3(airDensity(p), aerosolDensity(p), cloudDensity(p, cloudView));\n#else\n    return vec3(airDensity(p), aerosolDensity(p), 0.0);\n#endif    \n}\n\nvec3 optic(vec3 pa, vec3 pb, vec3 cloudView)\n{\n\tvec3 step = (pb - pa)/FOUT_STEPS;\n    vec3 pn = pa + step*0.5;\n    \n    vec3 sum = vec3(0.0);\n    for (int i = 0; i < OUT_STEPS; i++)\n    {\n        sum += density(pn, cloudView);\n    \tpn += step;\n    }\n    sum *= length(step)/ATMOSPHERE_HEIGHT;\n    \n    return sum;\n}\n\nvec3 attenuate(vec3 pa, vec3 pb, vec3 cloudView)\n{\n\tvec3 o = optic(pa, pb, cloudView) * (PI * 4.0);\n    return exp(-o.x*K_R*C_R -o.y*K_M - o.z*K_C*C_C);\n}\n\nvec3 in_scatter(vec3 o, vec3 dir, vec2 P)\n{\n\tvec3 sun = sunDirection();\n    float stepLength = (P.y-P.x)/FIN_STEPS;\n    vec3 step = dir*stepLength;\n    vec3 pa = o+dir*P.x;\n    vec3 pn = pa+step*0.5;\n    \n    vec3 air = vec3(0.0);\n    vec3 aerosols = vec3(0.0);\n    vec3 clouds = vec3(0.0);\n    for (int i = 0; i < IN_STEPS; i++)\n    {\n        vec2 c = lineIntersectSphere(pn, sun, ATMOSPHERE_UPPER);\n        vec3 ppc = pn + sun*c.y;\n        \n        vec3 d = density(pn, dir);\n        vec3 atn = attenuate(pa, pn, dir)*attenuate(pn, ppc, dir);\n        air += d.x*atn;\n        aerosols += d.y*atn;\n        clouds += d.z*atn;\n        \n        pn += step;\n    }\n    air *= stepLength/ATMOSPHERE_HEIGHT;\n    aerosols *= stepLength/ATMOSPHERE_HEIGHT;\n    clouds *= stepLength/ATMOSPHERE_HEIGHT;\n    \n    float c = dot(dir, -sun);\n    float cc = c*c;\n    \n    vec3 I = vec3(0.0);\n    I += K_R * C_R * phase_reyleigh(cc) * air;\n    I += K_M * phase_mie(G_M, c, cc) * aerosols;\n    I += K_C * C_C * phase_mie(G_C, c, cc) * clouds;\n    return I * E;\n}\n\nvoid planetColour(in vec3 pos, in float mat, out vec3 refl, out vec3 emitted) {\n    vec3 oldPos = pos;\n    pos = planetSpin()*pos;\n    float land = clamp((length(pos)-SEA_LEVEL)/(ATMOSPHERE_HEIGHT), 0.0, 1.0);\n    vec3 n = calcNormal(pos);\n    vec3 up = normalize(pos);\n    float updotn = dot(n, up);\n    float ydotn = dot(n, vec3(0.0, 1.0, 0.0));\n    float sundotn = dot(normalize(oldPos), sunDirection());\n    float h = waterDepth(oldPos, 0.5);\n    vec3 col = vec3(0.0);\n    emitted = vec3(0.0);\n    \n    // Detail noises\n    float pnb = noise3((pos+59.0)/16.0);\n    float pn1 = noise3(pos/2.0);\n    float pn2 = noise3((pos+59.0));\n    float pn3 = noise3((pos+129.0)*2.0);\n    \n    vec2 cn1 = cellular2x2x2(pos);\n    \n    float pf = pn1 + .5*pn2 + .25*pn3;\n    \n#ifdef ENABLE_DETAILS\n    float pn4 = noise3((pos+129.0)*4.0);\n    float pn5 = noise3((pos+129.0)*8.0);\n    float pn6 = noise3((pos+129.0)*16.0);\n    \n    pf += .125*pn4 + 0.0625*pn5 + 0.03125*pn6;\n#endif\n    \n    // Land\n    const vec3 cShore1 = vec3(0.62, 0.31, 0.4);\n    const vec3 cShore2 = vec3(1.2, 0.1, 0.1);\n    const vec3 cShore3 = vec3(1.2, 1.0, 1.0);\n    const vec3 cShore4 = vec3(1.0, 1.0, 1.0);\n    \n    vec3 cShoreMix1 = mix(cShore1, cShore2, (1.0+pf)/2.)*(0.25 + 0.75*smoothstep(0.0, 0.1, land));\n    vec3 cShoreMix2 = mix(cShore3, cShore4, (1.0+pf)/2.)*(0.25 + 0.75*smoothstep(0.0, 0.1, land));\n    vec3 shoreCol = mix(cShoreMix1, cShoreMix2, (1.+pnb)/2.);\n    float coastMask = smoothstep(0.04, 0.15, land+(0.04*pf));\n\n    // Land is divided into grass and dessert - yum\n    const vec3 cGrass1 = vec3(0.6, 0.9, 0.4)*0.65;\n    const vec3 cGrass2 = vec3(0.8, 0.8, 0.2)*0.75;\n    const vec3 cDesert = vec3(1.42, 0.8, 0.4);\n    vec3 cGrassMix = mix(cGrass1, cGrass2, pf);\n    float desertMask = smoothstep(0.1, 0.30, pnb+0.15*pf);\n    vec3 biomeCol = mix(cGrassMix, cDesert, desertMask);\n    \n    vec3 landCol = mix(shoreCol, biomeCol, clamp(coastMask+0.5*desertMask, 0.0, 1.0));\n    col += mix(vec3(0.0), landCol, clamp(1.0-abs(mat - 1.), 0.0, 1.0));\n    \n    // Cities in the desert - they turn their lights on at night, off during the day\n    float cityMask = (1.0-smoothstep(0.25, 0.26, sundotn))*(cn1.y - cn1.x)*desertMask;\n    vec3 cityLights = mix(vec3(0.0), vec3(2.0,0.5,1.5)*clamp(cityMask*pf, 0.0, 1.0), clamp(1.0-abs(mat - 1.), 0.0, 1.0));\n    \n    // Mountain\n    const vec3 cMountainTopLow = vec3(0.6, 0.55, 0.65)*0.75;\n    const vec3 cMountainTopHigh = vec3(1.2,1.2,1.2);\n    const vec3 cMountain = vec3(0.6,0.55,0.55);\n    vec3 mountainTopCol = mix(cMountainTopLow, cMountainTopHigh, smoothstep(0.7, 0.8, land));\n    vec3 mountainCol = mix(cMountain, mountainTopCol, clamp(pow(updotn, 12.0), 0.0, 1.0));\n    col += mix(vec3(0.0), mountainCol, clamp(1.0-abs(mat - 2.), 0.0, 1.0));\n    \n    // Sea\n    const vec3 oceanColour = vec3(0.1, 0.0, 0.4);\n    const vec3 shoreColour = vec3(.4, .5, .99)*1.0;\n    vec3 cSeaMix = mix(oceanColour, shoreColour, smoothstep(0.35, 0.0, h+0.05*pf));\n    col += mix(vec3(0.0), cSeaMix, float(mat==10.));\n\n    refl = col;\n    emitted = cityLights;\n}\n\nvec3 renderPlanet(in vec3 ro, in vec3 rd, vec2 map)\n{\n    float tMax = SCALE*25.0;\n    \n    float t = map.x;\n\tfloat m = map.y;\n\tvec3 pos = ro + t*rd;\n    \n    // Calculate sunlight after passing through atmosphere\n    vec3 sun = sunDirection();\n    vec3 cLow = pos * (ATMOSPHERE_LOWER/length(pos));\n    vec2 c = lineIntersectSphere(cLow, sun, ATMOSPHERE_UPPER);\n    vec3 ppc = pos + sun*c.y;\n    vec3 sunColour = attenuate(pos, ppc, vec3(0.0));\n    \n    // Fake a bit of skylight, depending on angle to the sun.\n    float sunAngle = dot(normalize(pos), sun);\n    sunColour += vec3(0.0, 0.235, 0.275) * sunAngle;\n    \n\tvec3 nor = calcNormal(pos);\n    vec3 ref = reflect( rd, nor );\n\n    float dif = clamp( dot( nor, sun ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe;\n    \n    vec3 col, em;\n    planetColour(pos, m, col, em);\n    vec3 brdf = vec3(0.0);\n    \n\t// Land\n    float isLand = mix(0.0, 1.0, float(m < 10.));\n    spe = pow(clamp( dot( ref, sun ), 0.0, 1.0 ),12.0);\n    brdf += 0.1*col * isLand;\n    brdf += 0.9*dif*col * isLand;\n    brdf += 0.01*spe*vec3(1.0, 1.0, 1.0)*dif * isLand;\n    \n    // Ocean\n    float isOcean = mix(0.0, 1.0, float(m == 10.));\n    spe = pow(clamp( dot( ref, sun ), 0.0, 1.0 ),16.0);\n    brdf += 0.4*col * isOcean;\n    brdf += 0.2*spe*vec3(1.0) * isOcean;\n    \n\treturn brdf*sunColour + em;\n}\n\nvec3 renderSpace(in vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    \n    // Noises\n    float pn1 = noise3(rd*2.0+iTime/400.0);\n    vec2 cellular = cellular2x2x2(rd*78.0*(1.+0.25*pn1));\n    \n    // Sun mixin factors\n    vec3 sun = sunDirection();\n    float f = clamp(dot(rd, sun), 0.0, 1.0);\n    f = pow(f, 30.0);\n    \n    // Mix in galaxy\n    vec3 gc = smoothstep(0.75+0.05*pn1, 1.0, (1.0 - cellular.x))*texture(iChannel1, rd.xy).xyz*2.5*(1.0-f);\n    gc *= (vec3(1.0) + vec3(0.0,0.0,1.5)*abs(pn1));\n    col += gc;\n    \n\t// Mix in sun\n    vec3 sunCol = vec3(0.85, 0.85, 1.0);\n    col += f*2.0*sunCol;\n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n\tvec2 atmosIntersect = lineIntersectSphere(ro, rd, ATMOSPHERE_UPPER);\n     \n    vec2 planetIntersectSphere = lineIntersectSphere(ro, rd, SCALE);\n    vec2 planetIntersect = rayMarch(ro, rd, 0.75, 1.0, MAX);\n    \n    vec2 P = vec2(atmosIntersect.x, min(atmosIntersect.y, planetIntersect.x));\n    \n    vec3 col = vec3(0.0);\n    if (atmosIntersect.x < MAX)\n    {\n        col += in_scatter(ro, rd, P);\n    }\n\n    if (planetIntersect.x < atmosIntersect.y)\n    {\n        vec3 pa = ro + rd*P.x;\n        vec3 pb = ro + rd*P.y;\n        col += renderPlanet(ro, rd, planetIntersect) * attenuate(pa, pb, vec3(0.0));\n    } else\n    {\n        col += renderSpace(rd);\n    }\n    \n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n\tvec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    // Camera origin\n    vec3 ro = vec3(sin(time()/8.0)*SCALE*2.0635, 0.0, cos(time()/8.0)*SCALE*2.0635);\n\n\t// Camera look-at pos\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.x/1.0, p.y, 2.0) );\n    \n\tvec3 col = render(ro, rd);\n    //col = pow( col, vec3(0.4545) );\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}