{"ver":"0.1","info":{"id":"slyyWR","date":"1661229625","viewed":151,"name":"Fork of Poisson pt but Prog","username":"trigophers","description":"progressive version. also ray tracing in one weekend is a bad starting point because usually people just blindly copy the code peter shirley wrote.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["progressive"],"hasliked":0,"parentid":"7tGczR","parentname":"Raytracer v 1.0"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel1, uv);\n    fragColor = vec4(col.xyz/col.w, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//IMPORTANT: Press pause while you are watching this shader\n\n#define PI 3.141592\n#define TAU 6.283185\n#define LAMB 0\n#define METAL 1\n#define SAMPLES 16 // try to increase it if you have a strong computer\n\nfloat seed;\n\nuint hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// randomSph function by Reinder: https://www.shadertoy.com/view/llVcDz\nvec3 randomSph(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nstruct Ray {\n    vec3 o, d; // origin and direction\n};\n\n// ray setup function\nRay getRay(vec2 uv, vec3 c, vec3 t, float z) {\n    vec3 f = normalize(t - c);\n    vec3 s = cross(vec3(0,1,0), f);\n    vec3 u = cross(f, s);\n    vec3 i = normalize(f*z + uv.x*s + uv.y*u);\n    \n    return Ray(c, i);\n}\n\nstruct Material {\n    int type;\n    vec3 col;\n    float k; // roughness\n};\n\nstruct Record {\n    float t;\n    vec3 p, n; // position and normal\n    Material mat;\n};\n\nstruct Sphere {\n    vec3 c; // center\n    float r; // radius\n};\n\nbool iSphere(Sphere s, Material mat, Ray r, inout Record rec) {\n    float t = dot(s.c - r.o, r.d);\n    vec3 p = r.o + r.d * t;\n    float a = length(p - s.c);\n    float b = sqrt(s.r*s.r - a*a);\n    t -= b;\n    if (t > 1e-6 && t < rec.t) {\n        rec.t = t;\n        rec.p = r.o + r.d * t;\n        rec.n = normalize(rec.p - s.c);\n        rec.mat = mat;\n        return true;\n    }\n    return false;\n}\n\nbool iPlane(vec3 n, float d, Material mat, Ray r, inout Record rec) {\n    n = normalize(n);\n    float t = (-d - dot(n, r.o)) / dot(n, r.d);\n    \n    if (t > 1e-6 && t < rec.t) {\n        rec.t = t;\n        rec.p = r.o + r.d * t;\n        rec.n = n;\n        rec.mat = mat;\n        return true;\n    }\n    return false;\n}\n\n// intersections function\nbool intersect(Ray r, out Record rec) {\n    rec.t = 1e10;\n    bool hit = false;\n    \n    hit = iSphere(Sphere(vec3(.5,0,0), .5), Material(LAMB, vec3(1), 0.), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(-.3,-.25,0), .25), Material(METAL, vec3(1), 0.), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(0,-.35,-.5), .15), Material(LAMB, vec3(0,0,1), 0.), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(-1.1,-.1,.25), .4), Material(METAL, vec3(1), .5), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(-.75,-.4,-1), .1), Material(LAMB, vec3(1,.5,1), 0.), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(.5,-.3,-1.25), .2), Material(METAL, vec3(1,0,1), .3), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(1.5,-.2,-.5), .3), Material(LAMB, vec3(1,.2,.8), .0), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(.85,-.4,-1.75), .1), Material(LAMB, vec3(1,.8,.4), .0), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(-1.75,-.3,0), .2), Material(LAMB, vec3(.5,1,.5), .0), r, rec) || hit;\n    hit = iSphere(Sphere(vec3(3.,-.3,-.1), .2), Material(METAL, vec3(.5,1,.5), 0.), r, rec) || hit;\n    hit = iPlane(vec3(0,1,0), .5, Material(LAMB, texture(iChannel0, rec.p.xz).rgb * vec3(1.4,1.3,1.1), 0.), r, rec) || hit;\n    hit = iPlane(vec3(0,0,-1), 1.5, Material(METAL, vec3(1,0,0), .1), r,  rec) || hit;\n    \n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 tot = vec3(0);\n    for (int i = 0; i < SAMPLES; i++) {\n        // antialiasing code by Reinder: https://www.shadertoy.com/view/llVcDz\n        seed = float(hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+float(i+iFrame*SAMPLES*2);\n        vec2 o = hash2(seed) - .5;\n        vec2 uv = (fragCoord + o - .5 * iResolution.xy) / iResolution.y;\n\n        vec3 camPos = vec3(0,(mouse.y)*4.,-3);\n        camPos.xz *= rot((mouse.x-.5)*PI*.5);\n        \n        Ray r = getRay(uv, camPos, vec3(0),1.);\n        Record rec;\n        \n        // intersection\n        bool hit = intersect(r, rec);\n        \n        // reflections\n        for (int j = 0; j < 8; j++) {\n            if (rec.mat.type == METAL && hit) {\n                r.o = rec.p;\n                r.d = normalize(reflect(r.d, rec.n) + randomSph(seed)*rec.mat.k);\n                hit = intersect(r, rec);\n            }\n        }\n        \n        vec3 col = mix(vec3(1), vec3(.5,.8,1), .5+.5*r.d.y);\n        if (hit) {\n            col = rec.mat.col * 2.;\n            \n            vec3 lig = vec3(-2.5,1,-3); // light pos\n            vec3 lit = normalize(lig - rec.p);\n            \n            // shadows\n            for (int j = 0; j < 8; j++) {\n                if (intersect(r, rec)) {\n                    col *= .5;\n                    r.o = rec.p;\n                    r.d = normalize(lit + rec.n + randomSph(seed));\n                }\n            }\n        }\n        col = pow(col, vec3(.4545)); // gamma correction\n        tot += col;\n    }\n    tot /= float(SAMPLES);\n    \n    vec4 data = texture(iChannel1, fragCoord/iResolution.xy);\n    if (iMouse.z > 0.0) data = vec4(0.0);\n    data += vec4(tot, 1.0); // accumulate\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}