{"ver":"0.1","info":{"id":"MltyR4","date":"1531847185","viewed":449,"name":"Fuzzy Noise","username":"TinyTexel","description":"algorithm overview in description","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","fuzzy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright Â© 2018 TinyTexel\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n/*\nbasic algorithm:\n\nv =         smoothstep(fbm);\nv = lerp(v, smoothstep(fbm), 0.45);\nv = lerp(v, smoothstep(fbm), 0.45);\n\nv = lerp(v, overlay(v, smoothstep(fbm)), 0.4);\nv = lerp(v, overlay(v, smoothstep(fbm)), 0.4);\nv = lerp(v, overlay(v, smoothstep(fbm)), 0.4);// slightly less harshly smoothstepped\n\nv = lerp(v, brightup(smoothstep(fbm)), 0.55);// not as harshly smoothstepped as the rest\n*/\n\n//#define DO_TILE_NOISE\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\nFUNC4_UINT(BJXorShift)    \n    \n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\nFUNC4_UINT(GMXorShift) \n    \n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\nFUNC4_UINT(WangHash) \n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nfloat SCurveC1(float x)\n{\n    return (x * -2.0 + 3.0) * x*x;\n}\n\nfloat SCurveC2(float x)\n{\n    return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;\n}\n\nfloat GNoise(vec2 uv, uvec2 seed)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = uv - iuv;\n    \n    vec2 fo = vec2(1.0 - SCurveC2(fuv.x), 1.0 - SCurveC2(fuv.y));   \n\n    float res = 0.0;\n\n    for(float i = 0.0; i < 2.0; ++i)    \n    {\n        for(float j = 0.0; j < 2.0; ++j)    \n        {\n            vec2 vert = vec2(i, j);\n            \n            vec2 vert2 = vert + iuv;\n            \n            float ang = Hash(vert2 * 1.257713 + 0.351831, seed);\n\n            vec2 g = AngToVec(ang * Pi);\n\n            vec2 vec = fuv - vert;\n\n\t\t\tfloat w = abs(i - fo.x) * abs(j - fo.y);\n\t\t\t\t\t\n            float v = dot(vec, g);\n\n            res += w * v;\n        }\n    }\n    \n    return res;\n}\n\nfloat GNoise(vec2 uv, ivec2 cells, uvec2 seed)\n{\n    vec2 iuv = floor(uv);\n    vec2 fuv = uv - vec2(iuv);\n    \n    ivec2 Iuv = ivec2(iuv);\n    \n    vec2 fo = vec2(1.0 - SCurveC2(fuv.x), 1.0 - SCurveC2(fuv.y));\n    \n    float res = 0.0;\n\n    int I, J = 0;\n    for(float i = 0.0; i < 2.0; ++i, ++I)    \n    {\n        for(float j = 0.0; j < 2.0; ++j, ++J)   \n        {\n            vec2 vert = vec2(i, j);\n            \n            ivec2 vert2 = (Iuv + ivec2(I, J)) % cells;\n            vert2.x = vert2.x < 0 ? vert2.x + cells.x : vert2.x;\n            vert2.y = vert2.y < 0 ? vert2.y + cells.y : vert2.y;\n            \n            float ang = Hash(vec2(vert2) * 1.257713 + 0.351831, seed);\n\n            vec2 g = AngToVec(ang * Pi);\n\n            vec2 vec = fuv - vert;\n\n\t\t\tfloat w = abs(i - fo.x) * abs(j - fo.y);\t\t\n            float v = dot(vec, g);\n\n            res += w * v;\n        }\n        \n        J = 0;\n    }\n    \n    return res;\n}\n\n\nfloat GNoise(vec2 uv) { return GNoise(uv, uvec2(0x0D66487Cu, 0x9A19276Bu)); }\nfloat GNoise(vec2 uv, ivec2 cells) { return GNoise(uv, cells, uvec2(0x0D66487Cu, 0x9A19276Bu)); }\n\n\nfloat Fbm(vec2 uv, uvec2 seed);\n\nfloat LayerA(vec2 uv, float s, uint seed)\n{\n    float v;\n    v = Fbm(uv, uvec2(GMXorShift(seed ^ 0xA64836AFu),\n                      GMXorShift(seed ^ 0x9700B457u)));\n            \n    v = clamp01(v * s + 0.5);\n    v = SCurveC1(v);    \n    \n    return v;\n}\n\nfloat LayerB(vec2 uv, float s, uint seed)\n{\n    float v;\n    v = Fbm(uv, uvec2(GMXorShift(seed ^ 0xA64836AFu),\n                      GMXorShift(seed ^ 0x9700B457u)));\n            \n    v = clamp01(v * s + (1.0 - s));\n    v = SCurveC1(v);    \n    \n    return v;\n}\n\nfloat overlay(float a, float b)\n{\n    return mix(a*a, 1.0-(1.0-a)*(1.0-a), b);\n}\n\nconst int NoiseCells = 5;\nconst float Octaves = 8.0;\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    float res = 512.0;\n    \n#if 0     \n    res = min(iResolution.x, iResolution.y);/// auto resolution\n#endif\n    \n#if 1    \n    uv0 -= (iResolution.xy - vec2(res)) * 0.5;/// center\n#endif\n    \n    vec2 uv2 = uv0 / res;\n      \n    vec2 uv = uv2 * float(NoiseCells);\n    \n    uint seed = 0xCFD58FE0u;\n        \n#if 1\n    seed += uint(iTime * 0.2) * 7u;/// swap through samples \n#endif    \n    \n    float v = 0.0;\n    \n    /// using loop to keep compile times short\n    for(float i = 0.0; i < 3.0; ++i)\n    {\n    \tv = mix(v, LayerA(uv, 8.0, seed), i == 0.0 ? 1.0 : 0.45);\n    \tseed = GMXorShift(seed);\n    } \n    \n    //outCol = vec4(v); return;\n    \n    for(float i = 0.0; i < 3.0; ++i)\n    {\n    \tv = mix(v, overlay(v, LayerA(uv, i == 2.0 ? 4.0 : 9.0, seed)), 0.4);\n    \tseed = GMXorShift(seed);\n    }    \n    \n    //outCol = vec4(v); return;\n    \n    float topL = 1.0 - pow(1.0 - LayerB(uv, 0.7, seed), 3.0);\n          topL = SCurveC1(topL);\n    \n    //v *= mix(topL, 1.0, mix(1.0, 0.8, v));// if v large and topL small mul topL and v before blend; helps to merge the textures better\n    float bf = 0.55;\n    bf = mix(bf, 1.0, Pow3(v - topL));// happy little accident; originally intented to apply an even power to the difference\n    v = mix(v, topL, bf);\n    \n#if 0 \n    if(uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0) v *= 0.5;\n#endif\n    \n    outCol = vec4(v);\n}\n\n\n\nfloat Fbm(vec2 uv, uvec2 seed)\n{    \n    float res = 0.0;\n    float accu_w = 0.0;\n    float w = 1.0;\n    \n    #ifdef DO_TILE_NOISE\n    int cells = NoiseCells;\n    #else\n    int cells = 1024;\n    #endif\n    //float rs = 0.2;\n    \n    for(float i = 0.0; i < Octaves; ++i)\n    {\n        vec2 off = vec2(HashFlt(seed.x, 0xE263C49Cu), \n                        HashFlt(seed.y, 0x786D0D5Fu)); \n        \n        float v = GNoise(uv + off, ivec2(cells, cells), seed);\n        \n        res += v * w;\n        \n        accu_w += w;\n        \n      \n        w *= 0.5;\n        uv *= 2.0;\n        cells *= 2;\n        \n        seed.x = GMXorShift(seed.x);\n        seed.y = GMXorShift(seed.y);        \n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\n\n","name":"Image","description":"","type":"image"}]}