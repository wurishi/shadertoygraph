{"ver":"0.1","info":{"id":"WslBzX","date":"1589015852","viewed":57,"name":"test for fun","username":"linkwwj","description":"test for fun","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//sdf\nfloat distance_from_sphere(in vec3 curPos, in vec3 sphereOri, in float r){\n\treturn length(curPos-sphereOri)-r;\n} \n\nfloat map_the_world(in vec3 p){\n    float displacement = sin(sin(iTime)*5.0 * p.x) * sin(sin(iTime)*5.0 * p.y) * sin(sin(iTime)*5.0 * p.z) * 0.25;\n\tfloat sphere_0 = distance_from_sphere(p,vec3(0.0), 1.0);\n    return sphere_0+displacement;\n}\n\nvec3 calc_normal(vec3 p){\n\n\tconst vec3 SMALL_STEP = vec3(0.001, 0.0, 0.0);\n        \n    float gradient_x = map_the_world(p+SMALL_STEP.xyy)-map_the_world(p-SMALL_STEP.xyy);\n    float gradient_y = map_the_world(p+SMALL_STEP.yxy)-map_the_world(p-SMALL_STEP.yxy);\n    float gradient_z = map_the_world(p+SMALL_STEP.yyx)-map_the_world(p-SMALL_STEP.yyx);\n    \n    vec3 normal = vec3(gradient_x,gradient_y,gradient_z);\n    \n    return normalize(normal);\n        \n\t\n}\n\n//ray march\nvec3 ray_march(in vec3 ro, in vec3 rd ){\n\t\n    float total_distance_marched = .0;\n    const int MAX_STEP = 32;\n    const float MIN_HIT_DISTANCE = 0.001;\n    const float MAX_MARCH_Distance = 1000.0;\n    \n    \n    for(int i=0;i<MAX_STEP;i++){\n    \t\n        vec3 currentPos = ro+rd*total_distance_marched;\n        float dist = map_the_world(currentPos);\n        //hit\n        if(dist < MIN_HIT_DISTANCE){\n            //shader\n        \tvec3 normal = calc_normal(currentPos);\n            vec3 lightPos = vec3(3.0,-5.0,3.0);\n            vec3 dir_to_light = normalize(-lightPos +currentPos);\n            \n            float diffuse = max(0.0, dot(normal, dir_to_light));\n            \n            return vec3(1.0,0.0,0.0)*diffuse;\n        }\n        total_distance_marched += dist;\n        //not hit\n        if(total_distance_marched > MAX_MARCH_Distance){\n        \tbreak;\n            \n        }\n        \n        \n    }\n    //return black\n    return vec3(.0);\n   \n    \n}\n\n\n\nfloat circle(in vec2 uv, in vec2 pos, in float r)\n{\n\tfloat d= length(uv-pos);\n    if(d<r)d = 1.0;\n    else d= 0.0;\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //set uv to [-0.5, 0.5] origin as (0, 0)\n    uv-=0.5;\n    //ratio\n    uv.x *= iResolution.x/iResolution.y;\n   \n    \n    //set camera\n    vec3 cameraPos = vec3(.0,.0,-5.0);\n    vec3 rd = vec3(uv,1.0);\n        \n    //shader\n    vec3 shadedColor = ray_march(cameraPos, rd);\n    \n    // Output to screen\n    fragColor = vec4(shadedColor,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}