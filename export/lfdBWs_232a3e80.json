{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// CC0: FXAA: Thinking Inside the Box\n\n#define RESOLUTION  iResolution\n\n// License: Unknowon, author: XorDev, found: https://github.com/XorDev/GM_FXAA\nvec4 fxaa(sampler2D tex, vec2 uv, vec2 texelSz) {\n  // See this blog\n  // https://mini.gmshaders.com/p/gm-shaders-mini-fxaa\n\n  // Maximum texel span\n  const float span_max    = 8.0;\n  // These are more technnical and probably don't need changing:\n  // Minimum \"dir\" reciprocal\n  const float reduce_min  = (1.0/128.0);\n  // Luma multiplier for \"dir\" reciprocal\n  const float reduce_mul  = (1.0/32.0);\n\n  const vec3  luma        = vec3(0.299, 0.587, 0.114);\n\n  // Sample center and 4 corners\n  vec3 rgbCC = texture(tex, uv).rgb;\n  vec3 rgb00 = texture(tex, uv+vec2(-0.5,-0.5)*texelSz).rgb;\n  vec3 rgb10 = texture(tex, uv+vec2(+0.5,-0.5)*texelSz).rgb;\n  vec3 rgb01 = texture(tex, uv+vec2(-0.5,+0.5)*texelSz).rgb;\n  vec3 rgb11 = texture(tex, uv+vec2(+0.5,+0.5)*texelSz).rgb;\n\n  //Get luma from the 5 samples\n  float lumaCC = dot(rgbCC, luma);\n  float luma00 = dot(rgb00, luma);\n  float luma10 = dot(rgb10, luma);\n  float luma01 = dot(rgb01, luma);\n  float luma11 = dot(rgb11, luma);\n\n  // Compute gradient from luma values\n  vec2 dir = vec2((luma01 + luma11) - (luma00 + luma10), (luma00 + luma01) - (luma10 + luma11));\n\n  // Diminish dir length based on total luma\n  float dirReduce = max((luma00 + luma10 + luma01 + luma11) * reduce_mul, reduce_min);\n\n  // Divide dir by the distance to nearest edge plus dirReduce\n  float rcpDir = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n  // Multiply by reciprocal and limit to pixel span\n  dir = clamp(dir * rcpDir, -span_max, span_max) * texelSz.xy;\n\n  // Average middle texels along dir line\n  vec4 A = 0.5 * (\n      texture(tex, uv - dir * (1.0/6.0))\n    + texture(tex, uv + dir * (1.0/6.0))\n    );\n\n  // Average with outer texels along dir line\n  vec4 B = A * 0.5 + 0.25 * (\n      texture(tex, uv - dir * (0.5))\n    + texture(tex, uv + dir * (0.5))\n    );\n\n\n  // Get lowest and highest luma values\n  float lumaMin = min(lumaCC, min(min(luma00, luma10), min(luma01, luma11)));\n  float lumaMax = max(lumaCC, max(max(luma00, luma10), max(luma01, luma11)));\n\n  // Get average luma\n  float lumaB = dot(B.rgb, luma);\n\n  //If the average is outside the luma range, using the middle average\n  return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? A : B;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 sz = 1.0/RESOLUTION.xy;\n  vec2 q = fragCoord*sz;\n  fragColor = fxaa(iChannel0, q, sqrt(2.0)*sz);\n  \n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"// CC0: Thinking Inside the Box\n//  A bit of tinkering with inner reflections\n\n// Controls how many lines the inner cube have\n//  On my 4K screen I like 3.0 but the aliasing is a\n//  bit intense in 1920x1080\n#define ZOOM        2.5\n// Like 0.0125 on 4K screens\n#define LINEWIDTH   0.02\n\n// Can't decide which I like the most\n// #define BOXVARIANT\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n#define FWD(x)      exp2((x)*ZOOM)\n#define REV(x)      (log2(x)/ZOOM)\n\n\nconst float pi      = acos(-1.);\nconst float tau     = 2.*pi;\nconst float upSat   = 1.2;\nconst float phi     = (sqrt(5.)+1.)/2.; \n\n// \"Fancy\" animated matrix.\n//  Got it off chat AI, I assume it is \"borrowed\" from somewhere\n//  The results looked ok though\nmat3 animatedRotationMatrix(float time) {\n  // Create a dynamic, multi-axis rotation\n  float angle1 = time * 0.5;       // Slower primary rotation\n  float angle2 = time * 0.707;     // Slightly faster secondary rotation\n  float angle3 = time * 0.33;      // Slower tertiary rotation\n    \n  // Trigonometric functions create interesting, non-linear rotation\n  float c1 = cos(angle1);\n  float s1 = sin(angle1);\n  float c2 = cos(angle2);\n  float s2 = sin(angle2);\n  float c3 = cos(angle3);\n  float s3 = sin(angle3);\n    \n  // Complex rotation matrix with multiple axis interactions\n  return mat3(\n      c1 * c2,  c1 * s2 * s3 - c3 * s1,  s1 * s3 + c1 * c3 * s2,\n      c2 * s1,  c1 * c3 + s1 * s2 * s3,  c3 * s1 * s2 - c1 * s3,\n      -s2,      c2 * s3,                 c2 * c3\n  );\n}\n\n// License: Unknown, author: XorDev, found: https://x.com/XorDev/status/1808902860677001297\nvec3 hsv2rgb_approx(vec3 hsv) {\n  return (cos(hsv.x*tau+vec3(0.,4.,2.))*hsv.y+2.-hsv.y)*hsv.z/2.;\n}\n\n#define  HSV2RGB_APPROX(hsv) ((cos(hsv.x*tau+vec3(0.,4.,2.))*upSat*hsv.y+2.-upSat*hsv.y)*hsv.z/2.)\n\n\nconst float beerHue = 0.75;\nconst vec3 reflCol      = HSV2RGB_APPROX(vec3(beerHue, 0.33, 0.33));\nconst vec3 groundCol    = HSV2RGB_APPROX(vec3(0.7, 0.2, 1.5));\nconst vec3 glowCol      = HSV2RGB_APPROX(vec3(0.06, 0.9, 3E-2));\nconst vec3 beerFactor   = -HSV2RGB_APPROX(vec3(beerHue+0.5, 0.75, 1.0)); \nconst vec3 skyCol       = HSV2RGB_APPROX(vec3(0.57, 0.70, 0.25));\nconst vec3 outerGlowCol = HSV2RGB_APPROX(vec3(0.66,0.5, 4E-3));\n\nconst int   maxRayMarchesInsides   = 50;\nconst float toleranceInsides       = .001;\nconst float normalEpisolonInsides  = 0.001;\nconst int   maxBouncesInsides      = 5;\nvec3 g_glowDistanceInsides;\n\nmat3 g_rot;\n\n\n//#define BACKSTEP_SHAPES\nconst int   maxRayMarchesShapes = 70;\nconst float toleranceShapes     = .001;\nconst float maxRayLengthShapes  = 20.;\nconst float normalEpisolonShapes= 0.01;\nvec2 g_glowDistanceShapes;\n\nconst vec3 rayOrigin    = normalize(vec3(0.0, 2., -5.))*10.;\nconst vec3 sunDir       = normalize(vec3(1.0));\nconst vec3  boxDim      = vec3(1.,phi,sqrt(phi))*1.9;\nconst float boxEdge     = 0.005; \n\nconst float bottom      = -boxDim.y-0.033;\n\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat box( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat ssphere4( vec3 p, float r ) {\n  p *= p;\n  return pow(dot(p, p), 0.25)-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat boxFrame( vec3 p, vec3 b, float e ) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec3 renderWorld(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n  \n  // Compute distance to floor \n  float bt   = -(ro.y-bottom)/(rd.y);\n\n  // Compute sky col  \n  col = hsv2rgb_approx(vec3(0.6, clamp(0.3+0.9*rd.y,0.0, 1.0), 2.*clamp(2.0-2.*rd.y*rd.y, 0.0, 2.)));\n  if (bt > 0.) {\n    vec3 bp = ro +rd*bt;\n    vec2 bpp = bp.xz;\n    // Creates a 1x1 coordinate system\n    vec2 npp = round(bpp);\n    vec2 cpp = bpp - npp;\n    vec2 app = abs(cpp);\n    // The grid distance field\n    // Detects if we are looking right at the grid or off an angle\n    float gfre = 1.+rd.y;\n    gfre *= gfre;\n    gfre *= gfre;\n    // If we are looking of an angle we let the line with goto 0, reduces aliasing\n    float gd = min(app.x, app.y)-mix(0.01,0.0, gfre);\n\n    // The ground color\n    // Fades out the ground, also helps reducing aliasing effects\n    float bfade = mix(1.,0.2,  exp(-0.3*max(bt-15., 0.)));\n    float aa = mix(0.0, 0.08, bfade);\n    vec3 bcol = mix(groundCol, groundCol*bfade, smoothstep(aa,-aa, gd));\n    // Fade in the sky\n    col = mix(col, bcol, exp(-0.008*bt));\n  }\n  \n\n\n  return col; \n}\n\n\nvec3 renderInnerWorld(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.0);\n\n\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(5.0, 9.0))-3.0;\n    \n    col += vec3(4.0)*skyCol*rd.y*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*skyCol*exp(-0.5*max(db, 0.0));\n    col += 0.25*sqrt(skyCol)*max(-db, 0.0);\n  }\n\n  return clamp(col, 0.0, 10.0);\n}\n\nfloat ssphere8(vec3 p, float r) {\n  p *= p;\n  p *= p;\n  return pow(dot(p,p),0.125)-r;\n}\n\n#ifdef BOXVARIANT\n#define BACKSTEP_INSIDES\nvec2 dfTheCube(vec3 p) {\n  float d0 = ssphere8(p, (1.0));\n  float d3 = ssphere4(p, 0.99);\n  \n  vec3 p2 = p;\n  p2 = abs(p2);\n  p2 -= 1.0;\n  \n  float fp2 = FWD(length(p2));\n\n  float n = floor(fp2);\n  \n  float x0 = REV(n);\n  float x1 = REV(n+1.0);\n\n  float m = (x0+x1)*0.5;\n  float w = x1-x0;\n  \n  float d2 = abs(length(p2)-m)-(w*0.5)+LINEWIDTH;\n\n  d0 = max(d0, d2);\n\n  float d = d0;\n  d = min(d, d3);\n  \n  float gd = 1E3;\n  gd = min(gd, d3);\n  \n  return vec2(d, gd);\n\n}\n#else\nvec2 dfTheCube(vec3 p) {\n  float d0 = box(p, vec3(1.0));\n  float d1 = boxFrame(p, vec3(1.01), 0.0)-0.005;\n  float d3 = ssphere4(p, 0.99);\n  \n  vec3 p2 = p;\n  p2 = abs(p2);\n  p2 -= 1.0;\n  \n  float fp2 = FWD(length(p2));\n\n  float n = floor(fp2);\n  \n  float x0 = REV(n);\n  float x1 = REV(n+1.0);\n\n  float m = (x0+x1)*0.5;\n  float w = x1-x0;\n  \n  float d2 = abs(length(p2)-m)-(w*0.5)+LINEWIDTH;\n\n  d0 = max(d0, d2);\n\n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d3);\n  \n  float gd = d1;\n  gd = min(gd, d3);\n  \n  return vec2(d, gd);\n\n}\n#endif\n\n// Distance fields for the objects inside the object\nfloat dfInsides(vec3 p) {\n  // The box, is negated because we are inside of it.\n  float dbox = -box(p, boxDim);\n  vec3 p0 = p;\n  p0 *= g_rot;\n  vec2 dtheCube = dfTheCube(p0); \n  // The glow frame\n  float dboxFrame = boxFrame(p, boxDim, 0.)-boxEdge;\n\n  float d = 1E3;\n  d = dbox;\n  d = min(d, dtheCube.x);\n\n  // Capture the glow distance  \n  float gd = 1E3;\n  gd = min(gd, dtheCube.y);\n\n  g_glowDistanceInsides = min(g_glowDistanceInsides, vec3(gd, dtheCube.x, dboxFrame));\n  \n  return d;\n}\n\n\nfloat rayMarchInsides(vec3 ro, vec3 rd, float tinit) {\n  float t = tinit;\n// This is something I learnt of IQ. This is to reduce artefacts\n//  that can happen if you look on a flat surface on a sharp angle\n//  This backsteps the point closes to the surface on a miss\n//  Sometimes improves things alot, sometimes it doesn't\n\n#if defined(BACKSTEP_INSIDES)\n  vec2 dti = vec2(1e10,0.0);\n#endif\n  int i;\n  for (i = 0; i < maxRayMarchesInsides; ++i) {\n    float d = dfInsides(ro + rd*t);\n#if defined(BACKSTEP_INSIDES)\n    if (d<dti.x) { dti=vec2(d,t); }\n#endif  \n    if (d < toleranceInsides) {\n      break;\n    }\n    t += d;\n  }\n#if defined(BACKSTEP_INSIDES)\n  if(i==maxRayMarchesInsides) { t=dti.y; };\n#endif  \n  return t;\n}\n\nvec3 normalInsides(vec3 pos) {\n  // Classic way to compute normal using the distance field\n  const vec2 eps = vec2(normalEpisolonInsides, 0.0);\n  return normalize(vec3(\n      dfInsides(pos+eps.xyy)-dfInsides(pos-eps.xyy)\n    , dfInsides(pos+eps.yxy)-dfInsides(pos-eps.yxy)\n    , dfInsides(pos+eps.yyx)-dfInsides(pos-eps.yyx))\n    );\n}\n\nvec3 renderInsides(vec3 ro, vec3 rd, float db) {\n  // Aggregated colors. Each reflection adds to it  \n  vec3 agg = vec3(0.0);\n  // Accumulated reflection factor\n  float ragg = 1.;\n  // Accumulated total distance \n  float tagg = 0.;\n    \n  float dist = sin(length(ro)*6.);\n  \n  g_rot = animatedRotationMatrix(sqrt(0.5)*0.5*TIME);\n  float blurIt = 0.;\n  for (int bounce = 0; bounce < maxBouncesInsides; ++bounce) {\n    if (ragg < 0.1) break;\n    g_glowDistanceInsides = vec3(1E3);\n    float it  = rayMarchInsides(ro, rd, db);\n    float glowDistanceInsides = g_glowDistanceInsides.x;\n    float innerBox = g_glowDistanceInsides.y;\n    float boxFrame = g_glowDistanceInsides.z;\n    \n    tagg      += it;\n    \n    vec3 ip     = ro+rd*it;\n    vec3 in_    = normalInsides(ip);\n    vec3 ir     = reflect(rd, in_);\n    // Fake fresnel effect\n    float ifre  = 1.+dot(in_,rd);\n    ifre *= ifre;\n    ifre = mix(0.8, 1., ifre)*0.8;\n\n    // Color is absorbed expotentially on the total distance travelled  \n    vec3 beer = ragg*exp(0.2*beerFactor*tagg);\n\n    // Add current glow color to accumulated color\n    // Random tinkering with the distance travelled to make the lines\n    // blur out, no thinking used. Just tinkering\n    vec3 tcol = vec3(0.0);\n    \n    tcol += glowCol*(1./max(glowDistanceInsides, 1E-3));\n    vec3 iwcol = renderInnerWorld(ip, ir);\n    if (innerBox < 10.*toleranceInsides) {\n      tcol += iwcol*ifre*0.66;\n      ifre *= 0.33;\n    }\n\n    ifre *= smoothstep(0.00, 0.03, boxFrame);\n    agg += tcol*beer;\n    // Compute next reflection factor using fresnel effect\n    ragg *= ifre;\n\n    if (glowDistanceInsides < 2.*toleranceInsides) {\n      // In this case we hit the glow which is non reflective\n      ragg = 0.;\n    }\n    \n    // Next rayorigin is current position\n    ro        = ip;\n    // Next raydirection is the reflection vector\n    rd        = ir;\n    // How much should we step away from the surface\n    //  The closer we are to the glow we are closed to the corners\n    //  and should step less\n    db        = clamp(boxFrame, 0.05, 0.25);\n    \n  }\n\n  return agg;\n}\n\n// Objects outside the objects\nfloat dfShapes(vec3 p) {\n  // The box\n  float dbox = box(p, boxDim);\n  // The box fame used for glow\n  float dboxFrame = boxFrame(p, boxDim, 0.)-boxEdge;\n  float d = 1E3;\n  d = dbox;\n  d = min(d,dboxFrame);\n\n  float gd = 1E3;\n  gd = dboxFrame;\n  \n  // Capture the glow distance  \n  g_glowDistanceShapes = min(g_glowDistanceShapes, vec2(gd, dboxFrame));\n  return d;\n}\n\nfloat rayMarchShapes(vec3 ro, vec3 rd, float tinit) {\n  float t = tinit;\n#if defined(BACKSTEP_SHAPES)\n  vec2 dti = vec2(1e10,0.0);\n#endif\n  int i;\n  for (i = 0; i < maxRayMarchesShapes; ++i) {\n    float d = dfShapes(ro + rd*t);\n#if defined(BACKSTEP_SHAPES)\n    if (d<dti.x) { dti=vec2(d,t); }\n#endif  \n    if (d < toleranceShapes || t > maxRayLengthShapes) {\n      break;\n    }\n    t += d;\n  }\n#if defined(BACKSTEP_SHAPES)\n  if(i==maxRayMarchesShapes) { t=dti.y; };\n#endif  \n  return t;\n}\n\nvec3 normalShapes(vec3 pos) {\n  const vec2 eps = vec2(normalEpisolonShapes, 0.0);\n  return normalize(vec3(\n      dfShapes(pos+eps.xyy)-dfShapes(pos-eps.xyy)\n    , dfShapes(pos+eps.yxy)-dfShapes(pos-eps.yxy)\n    , dfShapes(pos+eps.yyx)-dfShapes(pos-eps.yyx))\n    );\n}\n\nvec3 renderShapes(vec3 ro, vec3 rd) {\n  vec3 col = renderWorld(ro, rd);\n\n  // Distance to floor\n  float bt = -(ro.y-bottom)/(rd.y);\n  vec3 bp = ro+rd*bt;\n  // Used for fake shadow effect\n  float bd = dfShapes(bp);\n\n  g_glowDistanceShapes = vec2(1E3);\n  float st = rayMarchShapes(ro, rd, 0.);\n  float sglowDistance = g_glowDistanceShapes.x;\n  float sbox = g_glowDistanceShapes.y;\n  \n\n  vec3 sp = ro+rd*st;\n  vec3 sn = normalShapes(sp);\n\n  float sfre = 1.+dot(rd,+sn);\n  sfre *= sfre;\n  float refr_index    = mix(0.8, -0.8, sfre);\n  sfre = mix(0.05, 1.0,sfre);\n\n  vec3 sr = reflect(rd,sn);\n  vec3 srr= refract(rd,sn, refr_index);\n  // Fake fresnel effect\n\n  // The reflection color   \n  if (st < maxRayLengthShapes && (bt < 0.0 || st < bt)) {\n    // Hit the object\n    vec3 rwcol = renderWorld(sp, sr);\n    vec3 ricol = vec3(0.);\n    // If we hit the glow we don't compute the insides \n    if (sglowDistance > 2.*toleranceShapes) {\n      float stepIn = clamp(sbox, 0.05, 0.25);\n      ricol = renderInsides(sp, srr, stepIn)*(1.-sfre);\n    }\n    // In case of full reflection, can happen if refraction index > 1\n    if (srr == vec3(0.0)) {\n      col = rwcol*sqrt(sfre)*reflCol;\n    } else  {\n      col = mix(ricol*smoothstep(0., 0.25, sglowDistance), rwcol*reflCol, sfre); \n    }\n    \n  } else if (bt > 0.0) {\n    // Hit the floor\n    // Fake shadow\n    col *= mix(1.0, 0.125, exp(-bd));\n  }\n  \n  // Add the glow\n  col += outerGlowCol/max(sglowDistance, toleranceShapes);\n  \n  return col; \n}\n\nvec3 effect(vec2 p, vec2 pp) {\n  vec3 ro = rayOrigin;\n  const vec3 la = vec3(0.0, bottom*0.5, 0.0);\n  const vec3 up = vec3(0.0, 1.0, 0.0);\n  ro.xz *= ROT(0.0707*TIME);\n\n  // Classic way to setup the ray direction\n  //  uses the ray origin and look at\n  //  Don't worry if you don't get it. Do what everyone else does and copy paste it\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = (cross(ww,uu));\n  \n  const float fov = 2.;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = vec3(0.0);\n  \n  col = renderShapes(ro, rd);\n  col -= 0.03*vec3(2.0,3.0,1.0)*(length(p)+0.25);\n  col *= smoothstep(1.7, 0.8, length(pp));\n  // Aces approx converts color range from HDR ([0,inf]) to [0,1]\n  col = aces_approx(col);\n  // Fake RGB to sRGB conversion \n  col = sqrt(col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, pp);\n  \n  fragColor = vec4(col, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lfdBWs","date":"1733658351","viewed":141,"name":"FXAA: Thinking Inside the Box","username":"mrange","description":"Thinking Inside the Box\nA bit of tinkering with inner reflections\nnow with FXAA for those with \"lores\" screens\n\n","likes":7,"published":3,"flags":32,"usePreview":0,"tags":["3d","box"],"hasliked":0,"parentid":"lccBWl","parentname":"Thinking Inside the Box"}}