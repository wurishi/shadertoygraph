{"ver":"0.1","info":{"id":"wdSfW1","date":"1590448718","viewed":129,"name":"Truchet Tiling :P","username":"hopeliz","description":"Based on a tutorial by The Art of Code: https://youtu.be/2R7h76GoIJM\nCreated for Day 9 of a 100 Days of Shaders and Textures project","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["truchet","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Create a Hash that takes two values (vec2) and generates one output\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(310.34, 4315.345));\n    p += dot(p, p + 34.23);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // Move origin to the center\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 mouse = fragCoord/iMouse.xy;\n\n    // Default color\n    vec3 color = vec3(0.0);\n    \n    // Set speed;\n    float speed = 0.25;\n    \n    // Divide screen into a grid\n    \n    \n    // Controls the size of the grid squares\n    // The lower the number, the larger the squares\n    uv *= 5.0;\n    \n    // Make it move\n    uv += iTime * speed;\n    \n    // Equivalent to: uv - floor(uv)\n    vec2 griduv = fract(uv);\n    \n    // Create an id for each using the floor of each\n    vec2 id = floor(uv);\n    \n    // Create a \"random\" number based on the id\n    float n = hash21(id);\n    \n    // Move the origin of each square to the center\n    griduv -= 0.5; \n    \n    // Add color (r - red value, g - green value, b - blue value)\n    // Comment out or remove to see just the grid\n    //color.rb = griduv;\n    \n    // Create a diagonal mask that goes both ways\n    \n    // Set line thickness\n    float lineThickness = 0.1;\n    \n\n    // Swap horizontally (can be used to rotate)\n    //griduv.x *= -1.0;\n    if (n < 0.5) {\n        griduv.x *= -1.0;\n    }\n    \n    float distance = abs(abs(griduv.x + griduv.y) - 0.5);\n    vec2 circleuv = griduv-sign(griduv.x + griduv.y + 0.001) * 0.5;\n    \n    distance = length(circleuv);\n    //distance = length(griduv-0.5) - 0.5;\n        \n    float mask = smoothstep(0.01, -0.01, abs(distance - 0.5) - lineThickness);\n    //float mask = smoothstep(0.01, -0.01, abs(griduv.x + griduv.y) - lineThickness);\n    \n    // Add opposite circle\n    //distance = length(griduv+0.5) - 0.5;\n    //mask += smoothstep(0.01, -0.01, abs(distance) - lineThickness);\n    \n    // Get an angle between -pi and pi\n    float angle = atan(circleuv.x, circleuv.y);\n    \n    // Every other id gets its sign flipped\n    float checker = mod(id.x + id.y, 2.0) * 2.0 - 1.0;\n    float flow = sin(iTime * 2.0 - checker * angle * -26.0);\n    \n    float x = fract(angle/1.57) * 0.4;\n    float y = (distance - (0.5 - lineThickness)) / (2.0 * lineThickness);\n    y = abs(y - 0.5) * 0.4;\n    \n    vec2 tUv = vec2(x, y); \n    color += texture(iChannel0, tUv).rgb * mask * flow * vec3(1.0, 0.0, 0.75);\n    //color += x * mask;\n    //color.gb += tUv * mask;\n    //color += flow * mask;\n    //color += checker;\n    //color.rb += n;\n\n/*\n    // Create 0.02 width outlines of the squares\n    if (griduv.x > 0.48 || griduv.y > 0.48) {\n        // Draw magenta lines\n        color = vec3(1.0, 0., 1.0);\n    }\n\n*/\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}