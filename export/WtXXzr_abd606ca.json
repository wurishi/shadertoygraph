{"ver":"0.1","info":{"id":"WtXXzr","date":"1561714034","viewed":196,"name":"Goose bumps","username":"jblanper","description":"Experimenting with displacement functions applied to signed distance functions.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","bw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// most of the algorithms are derived from tutorial made \n// by BigWIngs (@The_ArtOfCode) and IÃ±igo Quilez\n\n#define MAX_STEPS 100\n#define MAX_DIST 60.\n#define EPSILON .001\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sceneSDF (vec3 p) {\n  float s = length(p - vec3(0.)) - .8;\n  s += sin(length((fract(p * 10.) - .5) * (sin(iTime * .4) * 3. + 4.2) * .2) * (cos(iTime * .1) * 1. + 2.) - iTime) * sin(iTime * .3) * .05;\n  s += sin((p.x * p.y + iTime * .08) * 10. * sin(iTime * .01) * 2.5) * .08;\n  return s * .8;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = sceneSDF(p);\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    sceneSDF(p - e.xyy),\n    sceneSDF(p - e.yxy),\n    sceneSDF(p - e.yyx)));\n}\n\nfloat raymarch (vec3 ro, vec3 rd) {\n  float depth = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    float dist = sceneSDF(ro + rd * depth);\n    if (dist < EPSILON) return depth;\n    depth += dist;\n    if (depth >= MAX_DIST) return 0.;\n  }\n  return 0.;\n}\n\nstruct Material {\n  float ambient;\n  float diffuse;\n  float specular;\n};\n\nfloat getLight (vec3 lightPos, vec3 p, vec3 rd, float lightOcclusion, Material material) {\n  // https://www.shadertoy.com/view/ll2GW1\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  // phong reflection\n  float ambient = clamp(.5 + .5 * normal.y, 0., 1.);\n  float diffuse = clamp(dot(normal, light), 0., 1.);\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 16.);\n\n  return (ambient * material.ambient * lightOcclusion) +\n   (diffuse * material.diffuse * lightOcclusion) +\n   (diffuse * specular * material.specular * lightOcclusion);\n}\n\nvec3 getRayDir (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n\n  // camera\n  vec3 ro = vec3(0., 0., -5.);\n  ro.xz *= rotate(iTime * .1);\n  vec3 rd = getRayDir(uv, ro, vec3(0., 0., 0.), 4.);\n\n  vec3 color = vec3(0.);\n  float d = raymarch(ro, rd);\n  vec3 p = ro + rd * d;\n\n  if (d > 0.) {\n    vec3 lightPos1 = vec3(8., 8., -5.);\n    vec3 lightPos2 = vec3(-12., -8., -10.);\n    lightPos2.xz *= rotate(iTime * .5);\n    float phong1 = getLight(lightPos1, p, rd, 1., Material(.1, .5, .7));\n    float phong2 = getLight(lightPos2, p, rd, .7, Material(.1, .6, 0.));\n    color += phong1;// * vec3(.5, .5, .7);\n    color += phong2;// * vec3(.5, .5, .7);\n  } else {\n    color += .05 / length(uv);\n  }\n\n  // gamma correction\n  color = pow(color, vec3(1.0/2.2));\n\n  fragColor = vec4(color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}