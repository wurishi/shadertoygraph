{"ver":"0.1","info":{"id":"lXfBRl","date":"1728761913","viewed":35,"name":"Stereoscopic Mandelbulb [Fork 2]","username":"rattlehead","description":"Fork of MXSyDV\nMandelbulb explorer: Drag the mouse to select sector,\nKEYS: [0-9]: select zoom level, [Q]: switch LQ / HQ, [S] SBS view on/off, [T] TAB view on/off, [A] aspect ratio half/full in stereo mode, [X] switch cross-eyed/parallel","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["mouse","raymarch","mandelbulb","stereo","stereoscopic","keyboard","buffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"             /////////////////////////////////////////\n            //                                     //\n           // Image                               //\n          //                                     //\n         // Setup:                              //\n        // iChannel0: Buffer A                 //\n       // iChannel1: Buffer B                 //\n      // iChannel2: Buffer C                 //\n     //                                     //\n    /////////////////////////////////////////\n   //                                     //\n  // CONFIGURE STUFF IN THE TAB \"COMMON\" //\n //                                     //\n/////////////////////////////////////////\n\n/////////////////////////////////////////\n// Channels                            //\n/////////////////////////////////////////\n\n// buffer for the rendered sector of the scene\n#define channelBuffer iChannel0\n// buffer for storing data, e.g. settings\n#define channelData iChannel1\n// buffer for a low-resolution version of the entire scene\n#define channelPreview iChannel2\n\n/////////////////////////////////////////\n// Code                                //\n/////////////////////////////////////////\n\n#ifdef BLINKIES_ENABLED\n    #define BLINKING_TIME_ORIGINAL .5\n    #define BLINKING_TIME_INDICATORS .5\n    #define BLINKING_TIME_TRANSITION .25\n\n    #define t0 BLINKING_TIME_TRANSITION\n    #define t1 (.5 * BLINKING_TIME_INDICATORS)\n    #define t2 (.5 * BLINKING_TIME_ORIGINAL)\n    #define m (.5 * t0 + t1 + t2)\n\n    vec4 showBlinkies(vec4 fragColor)\n    {\n        // Highlight blown-out whites\n        vec4 color = clamp(fragColor, 0., 1.);\n        float blownout = step(2.99, dot(color.rgb, vec3(1)));\n        color.rgb = mix(color.rgb, vec3(1,0,0), blownout);\n\n        // Highlight crushed blacks\n        float crushed = step(-.003, -dot(color.rgb, vec3(1)));\n        color.rgb = mix(color.rgb, vec3(0,0,1), crushed);\n        return mix(fragColor, color, smoothstep(t2, m - t1, abs(mod(iTime, 2. * m) - m)));\n    }\n#endif\n\nvec4 renderGrid(vec3 sectors, vec2 fragCoord, vec2 iResolution)\n{\n    float numTiles = 1. + 2. * sectors.z;\n    vec2 uv = vec2(fragCoord.xy / iResolution.xy) * numTiles;\n    vec4 col = vec4(0);\n\n    const float limit1 = .02;\n    const float limit2 = .015;\n    const float limit3 = .01;\n    const float limit4 = .005;\n    col.a += smoothstep(limit1, limit2, .5 - abs(fract(uv.x) - .5));\n    col.a += smoothstep(limit1 * ASPECT_RATIO, limit2, .5 - abs(fract(uv.y) - .5));\n    col.rgb += smoothstep(limit3, limit4, .5 - abs(fract(uv.x) - .5));\n    col.rgb += smoothstep(limit3 * ASPECT_RATIO, limit4, .5 - abs(fract(uv.y) - .5));\n    return clamp(col, 0., 1.);\n}\n\nvec4 renderPreview(vec4 selection, vec2 fragCoord, vec2 iResolution)\n{\n    // Pull image from the preview channel\n    vec4 color = texelFetch(channelPreview, ivec2(fragCoord / PIXEL_SIZE), 0);\n    // brighten selected, darken unselected sectors\n    color.rgb *= (getSector(fragCoord.xy / iResolution, selection.z) == selection.xy) ? 1.3 : .4;\n    return color;\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 action = loadData(addrActions) + defaultAction;\n    vec4 selection = loadData(addrSelect) + defaultSelection;\n\n    if (action.x > .5) {\n        // Selection screen\n        vec4 grid = renderGrid(selection.xyz, fragCoord, iResolution.xy);\n        vec4 scene = renderPreview(selection, fragCoord, iResolution.xy);\n        fragColor = mix(clamp(scene, 0., 1.), grid, grid.a);\n    } else {\n        // Scene\n        fragColor = texelFetch(channelBuffer, ivec2(fragCoord), 0).rgba;\n        #ifdef ANIMATE\n            // Cheap anti-aliasing, by sharing\n            // 2 samples with each direct neighbour and\n            // 1 sample with each diagonal neighbour\n            //\n            // There's got to be a name for this. If you\n            // know, tell me in the comments please!\n        fragColor += texelFetch(channelBuffer, ivec2(fragCoord) + ivec2(1,0), 0).rgba\n                   + texelFetch(channelBuffer, ivec2(fragCoord) + ivec2(0,1), 0).rgba\n                   + texelFetch(channelBuffer, ivec2(fragCoord) + ivec2(1,1), 0).rgba\n        ;\n        fragColor /= 4.;\n        #endif\n        \n    }\n\n    #ifdef BLINKIES_ENABLED\n        fragColor = showBlinkies(fragColor);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"        /////////////////////////////////////////\n       //                                     //\n      // Common                              //\n     //                                     //\n    /////////////////////////////////////////\n   //                                     //\n  // CONFIGURE STUFF IN THE TAB \"COMMON\" //\n //                                     //\n/////////////////////////////////////////\n\n// MODE\n#define ANIMATE\n// highlights blown-out whites and crushed blacks\n// #define BLINKIES_ENABLED\n\n// MATH\n#define PI  3.1415926536\n#define TAU 6.2831853072\n// MANDELBULB\n#define POWER 8.\n//    #define BOUNDING_RADIUS (1.1555 * (.5 - cos(.1*iTime) * .5))\n#define BOUNDING_RADIUS (1.1555)\n\n#define FRACTAL_ITERATIONS_LQ 8\n#define FRACTAL_ITERATIONS_HQ 16\n// RAYMARCHING\n#define MAX_SURFACE_DISTANCE_LQ 8e-4\n#define MAX_SURFACE_DISTANCE_HQ 2e-4\n#define MAX_ITERATIONS_LQ 750\n#define MAX_ITERATIONS_HQ 800\n#define MAX_DISTANCE 6.5\n#define ZOOM 1.7\n// COLORING\n#define STEP_FACTOR_LQ 1.5e-4\n#define STEP_FACTOR_HQ 1.1e-4\n// STEREOSCOPIC 3D\n#define DEFAULT_EYE_DISTANCE (.13)\n#define EYE_SHIFT_PER_KEYSTROKE 2e-3\n// ANTI-ALIASING\n#define AA_LQ 1\n#define AA_HQ 1\n// RENDERING CONTROL\n#define FRAMES_PER_IMAGE_LQ 1\n#define FRAMES_PER_IMAGE_HQ (int(iResolution.x) / 16)\n#define FRAMES_PER_IMAGE (qualityMode < .5 ? FRAMES_PER_IMAGE_LQ : FRAMES_PER_IMAGE_HQ)\n// PREVIEW\n#define PIXEL_SIZE 4.\n// DEFAULT VALUES\n// see Buffer B for what's what\n#define defaultQuality   vec4(1., 0., 0., 0.)\n#define defaultStereo    vec4(1., 1., DEFAULT_EYE_DISTANCE, 0.)\n#define defaultSelection vec4(-1., 1., 0., 0.)\n#define defaultAction    vec4(0.)\n#define defaultSectors defaultSelection\n// KEYBOARD\n#define KEY_0 48\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52\n#define KEY_5 53\n#define KEY_6 54\n#define KEY_7 55\n#define KEY_8 56\n#define KEY_9 57\n#define KEY_A 65\n#define KEY_D 68\n#define KEY_H 72\n#define KEY_L 76\n#define KEY_M 77\n#define KEY_N 78\n#define KEY_O 79\n#define KEY_Q 81\n#define KEY_R 82\n#define KEY_S 83\n#define KEY_T 84\n#define KEY_W 87\n#define KEY_X 88\n\n// SHORTHANDS\n#define ASPECT_RATIO (iResolution.x / iResolution.y)\n// Globally define function alias for loading data\n#define loadData(key) texelFetch(channelData, key, 0)\n\n// STORE ADDRESSES\n#define addrKeys     ivec2(1,0)\n#define addrQuality  ivec2(2,0)\n#define addrSectors  ivec2(3,0)\n#define addrActions  ivec2(4,0)\n#define addrSelect   ivec2(5,0)\n#define addrStereo   ivec2(6,0)\n\n\n\n\n// SDF for a sphere (precise)\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// SDF for a box (precise)\nfloat sdBox(vec3 p, vec3 s, float roundness)\n{\n    vec3 d = roundness + abs(p) - abs(s);\n    return length(max(d, 0.)) + min(0., max(d.x, max(d.y, d.z))) - roundness;\n}\n\n// transformation matrix for rotation about the z-axis (xy-plane)\nmat3 rotateZ(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        c, s, 0,\n       -s, c, 0,\n        0, 0, 1\n    );\n}\n\n// transformation matrix for rotation about the y-axis (zx-plane)\nmat3 rotateY(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        c, 0,-s,\n        0, 1, 0,\n        s, 0, c\n    );\n}\n\n// transformation matrix for rotation about the x-axis (yz-plane)\nmat3 rotateX(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat3(\n        1, 0, 0,\n        0, c, s,\n        0,-s, c\n    );\n}\n\nvec4 sdMandelbulb(vec3 p, float power, int FRACTAL_ITERATIONS)\n{\n    vec3 z = p;\n    float r = 0.;\n    float derivative = 1.;\n\n    vec4 color = vec4(0);\n    int i;\n    for (i = 0; i < FRACTAL_ITERATIONS; i++) {\n        r = length(z);\n        if (r > 4.) break;\n\n        derivative = power * pow(r, power - 1.) * derivative + 1.;\n        // to polar\n        float theta = acos(z.z / r); // polar angle\n        float phi = atan(z.y, z.x); // azimuth\n        // \"multiply\" by rotating and stretching\n        theta *= power;\n        phi *= power;\n        r = pow(r, power);\n        // to cartesian\n        z = r * vec3(\n            cos(phi) * sin(theta),\n            sin(phi) * sin(theta),\n            cos(theta)\n        );\n\n        z += p;\n        color.gba += vec3(theta, phi, r);\n    }\n    color.r = .05 * log(r) * r / derivative;\n    return color;\n}\n\nvec4 sdMandelbulb(vec3 p, int FRACTAL_ITERATIONS)\n{\n    return sdMandelbulb(p, POWER, FRACTAL_ITERATIONS);\n}\n\nvec4 getSignedDistance(vec3 p, mat3 rot, int FRACTAL_ITERATIONS)\n{\n    p = rot * p * .45;\n    float obj = 1.;\n    vec4 res;\n    res = sdMandelbulb(p, FRACTAL_ITERATIONS);\n//    res.x = min(res.x, sdSphere(p, 1.));\n//    d = sdBox(p, vec3(.75), .2);\n    return res;\n}\n\nfloat getSignedBoundingDistance(vec3 p, mat3 rot, float iTime)\n{\n    p = rot * p * .45;\n    return sdSphere(p, BOUNDING_RADIUS);\n}\n\n// Fixed directional artifact by applying central differences, in this case with the\n// tetrahedron technique described in https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(vec3 p, const mat3 rot, const float MAX_SURFACE_DISTANCE, const int FRACTAL_ITERATIONS)\n{\n    mat3 ignore = mat3(0);\n    float h = MAX_SURFACE_DISTANCE;\n    vec2 e = vec2(1, -1);\n    return normalize(\n        e.xyy * getSignedDistance(p + h * e.xyy, rot, FRACTAL_ITERATIONS).x +\n        e.yyx * getSignedDistance(p + h * e.yyx, rot, FRACTAL_ITERATIONS).x +\n        e.yxy * getSignedDistance(p + h * e.yxy, rot, FRACTAL_ITERATIONS).x +\n        e.xxx * getSignedDistance(p + h * e.xxx, rot, FRACTAL_ITERATIONS).x\n    );\n}\n\nvec3 getCamRight(vec3 pos, vec3 trg, vec3 up)\n{\n    vec3 forward = normalize(trg - pos);\n    return cross(forward, normalize(up));\n}\n\nvec3 getCamDir(vec2 uv, vec3 pos, vec3 trg, vec3 up, float zoom)\n{\n    vec3 forward = normalize(trg - pos);\n    vec3 right = cross(forward, normalize(up));\n    up = cross(right, forward);\n    return normalize(zoom * forward + uv.x * right + uv.y * up);\n}\n\n// Variant 1: texture mapping\n/*\nvec3 getColor1(vec3 p, vec3 n, mat3 rot, sampler channelTexture)\n{\n    mat3 inv = inverse(rot);\n    vec3 nObj = abs(n * inv);\n    n = pow(n, vec3(2));\n    n /= n.x + n.y + n.z;\n    p = rot * p;\n    vec3 colX = texture(channelTexture, .5 + .5 * p.yz).rgb;\n    vec3 colY = texture(channelTexture, .5 + .5 * p.zx).rgb;\n    vec3 colZ = texture(channelTexture, .5 + .5 * p.xy).rgb;\n    return nObj.x * colX + nObj.y * colY + nObj.z * colZ;\n}\n// */\n\n// Variant 2: no texture mapping\nvec3 getColor2(vec3 counts, float dif)\n{\n    vec3 col = vec3(.7);\n    col *= counts.brg / counts.rgb;\n    col = pow(col, vec3(1.5));\n    col *= pow(dif, 20.);\n    return smoothstep(0., 1., col);\n}\n\n// Variant 3: no texture mapping, use step count\nvec3 getColor3 (float scaledSteps)\n{\n    // the more steps, the darker the color's value\n    float val = 1. - scaledSteps / (scaledSteps + 1.);\n    // increase contrast\n    val = pow(val, 8.);\n    vec3 col = vec3(val);\n\n    col.r *= smoothstep(.10, .15, abs(scaledSteps - .21));\n    col.g *= smoothstep(.06, .09, abs(scaledSteps - .14));\n    col.b *= smoothstep(.01, .04, abs(scaledSteps - .07));\n    return col;\n}\n\nvec4 renderScene(vec2 uv, float offsetEye, vec4 settings, float iTime)\n{\n    float eyeFactor = offsetEye * settings.y;\n    // Quality settings\n    float highQuality = step(.5, settings.x);\n    int MAX_ITERATIONS = int(mix(float(MAX_ITERATIONS_LQ), float(MAX_ITERATIONS_HQ), highQuality));\n    float MAX_SURFACE_DISTANCE = mix(MAX_SURFACE_DISTANCE_LQ, MAX_SURFACE_DISTANCE_HQ, highQuality);\n    int FRACTAL_ITERATIONS = int(mix(float(FRACTAL_ITERATIONS_LQ), float(FRACTAL_ITERATIONS_HQ), highQuality));\n\n    mat3 ident = mat3(1,0,0,0,1,0,0,0,1);\n    mat3 rot = rotateY(.8 * PI) * rotateX(.3 * PI);\n\n    vec4 col = vec4(0);\n    float zoom = ZOOM; //+ 1.5 * smoothstep(-.15, .15, -cos(iTime * .6));\n    vec3 ro = vec3(0,2,5);\n    #ifdef ANIMATE\n        ro *= rotateY(.1 * iTime);\n    #else\n    #endif\n    vec3 rt = vec3(0);\n    vec3 right = getCamRight(ro, rt, vec3(0,1,0));\n    ro += right * eyeFactor;\n    vec3 rd = getCamDir(uv, ro, rt, vec3(0,1,0), zoom);\n\n    float steps = 0.;\n    float totalDistance = 0.;\n    // (x,y) = (distance, objectId)\n    float stepDistance = 10.;\n    vec3 p = ro;\n\n    // two-step raymarching:\n    int iteration = 0;\n    // spend some of the iterations to get to the bounding shape\n    for (; iteration < MAX_ITERATIONS / 10 && MAX_SURFACE_DISTANCE < stepDistance && totalDistance < MAX_DISTANCE; iteration++)\n    {\n        stepDistance = getSignedBoundingDistance(ro + rd * totalDistance, rot, iTime);\n        totalDistance += stepDistance;\n    }\n    // then go to the actual shapes contained within\n    stepDistance = 10.;\n    for (int iteration = 0; iteration < MAX_ITERATIONS && MAX_SURFACE_DISTANCE < stepDistance && totalDistance < MAX_DISTANCE; iteration++)\n    {\n//if (offsetEye < 0.) {\n//        stepDistance = getSignedBoundingDistance(ro + rd * totalDistance, rot, iTime);\n//} else {\n        stepDistance = getSignedDistance(ro + rd * totalDistance, rot, FRACTAL_ITERATIONS).x;\n//}\n        totalDistance += stepDistance;\n        steps++;\n    }\n\n    if (totalDistance < MAX_DISTANCE)\n    {\n        vec3 p = ro + rd * totalDistance;\n        vec3 n = getNormal(p, rot, MAX_SURFACE_DISTANCE, FRACTAL_ITERATIONS);\n\n        mat3 inv = inverse(rot);\n        float dif = dot(n, normalize(vec3(-2,3,4))) * .5 + .6;\n        vec3 nObj = abs(inv * n);\n\n        // Calculate Color\n\n        // scale down the number of steps to behave more nicely in calculations\n        col.rgb = pow(dif, 2.) * getColor3(steps * mix(STEP_FACTOR_LQ, STEP_FACTOR_HQ, highQuality));\n        col.b *= smoothstep(0., 1., col.r + col.g);\n    }\n\n    float transparency = pow(clamp(totalDistance / MAX_DISTANCE, 0., 1.), 2.);\n    col.a = 1. - transparency;\n\n    col = pow(col, vec4(.8));\n//    col = smoothstep(0., 1., col);\n//    col *= 1.34;\n\n    // add haze\n    col.rgb = mix(vec3(.15, .16, .20) * 0.5, col.rgb, col.a);\n\n    return clamp(col, 0., 1.);\n}\n\nvec4 render(vec4 quality, vec4 sectors, vec4 stereo, vec2 fragCoord, vec3 iResolution, float iTime)\n{\n    vec3 e = vec3(1,0,-1);\n    vec4 col = vec4(0);\n\n    int AA = .5 < quality.x ? AA_HQ : AA_LQ;\n    for (int i = 0; i < AA; i++)\n    {\n        for (int j = 0; j < AA; j++)\n        {\n            float numTiles = 1. + 2. * sectors.z;\n            vec2 totalSize = iResolution.xy * numTiles;\n            vec2 currentTile = floor(sectors.xy) + floor(sectors.z);\n            vec2 globalCoord = currentTile * iResolution.xy + fragCoord;\n            // Normalized global pixel coordinates (from -1 to 1)\n            vec2 uv = (2. * (globalCoord + vec2(i,j) / float(AA)) - totalSize.xy) / totalSize.x;\n            // # tiles: 1. + 2. * sectors.z\n            // length ([-1,1)-ranged tiles): 2. + 4. * sectors.z\n\n            ///////////////////////////////////////////\n            // Handle stereo settings                //\n            ///////////////////////////////////////////\n\n            // -1: shift for left eye   0: no shift   1: shift for right eye\n\n            float sbs = step(-.51, -abs(stereo.x - 1.));\n            float eye = sbs * (step(-.1, sign(uv.x)) * 2. - 1.);\n            uv.x += sbs * uv.x;\n            uv.x -= sbs * eye;\n            uv.y += sbs * step(.5, stereo.y) * uv.y;\n\n            float tab = step(-.5, -abs(stereo.x - 2.));\n            eye += tab * (step(-.1, sign(uv.y)) * 2. - 1.);\n            uv.y += tab * uv.y;\n            uv.y -= tab * eye / ASPECT_RATIO;\n            uv.x += tab * step(.5, stereo.y) * uv.x;\n/* unoptimised version:\n            if (.5 < stereo.x && stereo.x < 1.5) {\n                // count 0 as positive\n                eye = step(-.1, sign(uv.x)) * 2. - 1.;\n                uv.x *= 2.;\n                uv.x -= eye;\n                if (.5 < stereo.y) {\n                    uv.y *= 2.;\n                }\n            }\n            if (1.5 < stereo.x && stereo.x < 2.5) {\n                // count 0 as positive\n                eye = step(-.1, sign(uv.y)) * 2. - 1.;\n                uv.y *= 2.;\n                uv.y -= eye * iResolution.y / iResolution.x;\n                if (.5 < stereo.y) {\n                    uv.x *= 2.;\n                }\n            }\n// */\n\n            quality.y = stereo.z;\n            // incl. vignetting\n            col += renderScene(uv, eye, quality, iTime);\n        }\n    }\n    return col / float(AA * AA);\n}\n\nvec2 getSector(vec2 p, float numExtensions)\n{\n    float numTiles = 1. + 2. * numExtensions;\n    return floor(p * numTiles) - numExtensions;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"            /////////////////////////////////////////\n           //                                     //\n          // Buffer A                            //\n         //                                     //\n        // Setup:                              //\n       // iChannel0: Buffer A                 //\n      // iChannel1: Buffer B                 //\n     //                                     //\n    /////////////////////////////////////////\n   //                                     //\n  // CONFIGURE STUFF IN THE TAB \"COMMON\" //\n //                                     //\n/////////////////////////////////////////\n\n/////////////////////////////////////////\n// Channels                            //\n/////////////////////////////////////////\n\n#define channelBuffer  iChannel0\n#define channelData    iChannel1\n\n/////////////////////////////////////////\n// Shorthands                          //\n/////////////////////////////////////////\n\n#define V1 3.\n#define V2 2.\n#define H1 1.\n#define H2 .5\n\n#define INDICATOR vec4(smoothstep(V1, V2, abs(mod(fragCoord.y, 2. * (V1 + V2)) - V1 - V2)))\n\n/////////////////////////////////////////\n// Code                                //\n/////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 quality = loadData(addrQuality) + defaultQuality;\n    vec4 stereo = loadData(addrStereo) + defaultStereo;\n    vec4 sectors = loadData(addrSectors) + defaultSectors;\n\n#ifdef ANIMATE\n    fragColor = render(quality, sectors, stereo, fragCoord, iResolution, iTime);\n#else\n    vec4 action = loadData(addrActions) + defaultAction;\n\n    // Calculate a good (fingers crossed) number of columns to render per frame:\n    // 0: LQ, 1: HQ\n    float qualityMode = step(.5, quality.x);\n\n    // limit the number of columns that are to be rendered per frame\n    int thisColumn = int(fragCoord.x) % FRAMES_PER_IMAGE;\n    int renderingColumn = int(action.w);\n    float relPos = float(thisColumn - renderingColumn);\n    // if this is in the column that is currently rendering, call render()\n    // otherwise determine if we're about to render shortly and draw indicator line\n    // otherwise, just pull the pixel from cache\n    fragColor = (thisColumn == renderingColumn)\n        ? render(quality, sectors, stereo, fragCoord, iResolution, iTime)\n        : texelFetch(channelBuffer, ivec2(fragCoord), 0)\n    ;\n    fragColor = mix(fragColor, INDICATOR, qualityMode * smoothstep(H1, H2, abs(float(thisColumn) - action.w + H1)));\n#endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"            /////////////////////////////////////////\n           //                                     //\n          // Buffer B                            //\n         //                                     //\n        // Setup:                              //\n       // iChannel1: Buffer B                 //\n      // iChannel3: Keyboard                 //\n     //                                     //\n    /////////////////////////////////////////\n   //                                     //\n  // CONFIGURE STUFF IN THE TAB \"COMMON\" //\n //                                     //\n/////////////////////////////////////////\n\n/////////////////////////////////////////\n// Channels                            //\n/////////////////////////////////////////\n\n#define channelData     iChannel1\n#define channelKeyboard iChannel3\n\n// Shorthands\n#define readKey(key)       step(.5, texelFetch(channelKeyboard, ivec2(key, 0), 0).x)\n#define store(addr,val)    fragColor = addr == me ? val : fragColor;\n#define setSize(val,key)   selection.z = mix(selection.z, val, readKey(key));\n\n/////////////////////////////////////////\n// Code                                //\n/////////////////////////////////////////\n\n// Settings Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Keep track of which columns have been rendered\n    if (fragCoord.y == 1.) {\n        fragColor = texelFetch(channelData, ivec2(fragCoord), 0);\n        float prev = mix(2., texelFetch(channelData, ivec2(fragCoord.x - 1., 0.), 0).x, step(1., fragCoord.x));\n        fragColor.x = min(fragColor.x + 1., prev);\n        return;\n    }\n\n    ivec2 me = ivec2(fragCoord);\n\n    // x: quality: LQ < .5 < HQ\n    // y: copy of eye distance\n    // z,w: resolution the buffers have been rendered for\n    vec4 quality = loadData(addrQuality) + defaultQuality;\n\n    // x: stereo: none < .5 < sbs < 1.5 < tab\n    // y: aspect-ratio correction\n    // z: eye distance\n    // w: X\n    vec4 stereo = loadData(addrStereo) + defaultStereo;\n\n    // x,y: tile during selection\n    // z: number of tile extensions to each side, 0=1-by-1, 1=3-by-3, 2=5-by-5, ..., 9=19-by-19 tiles\n    // w: n/a                       [rem.: z is a copy of sectors.z for convenience]\n    vec4 selection = loadData(addrSelect) + defaultSelection;\n\n    // x,y: tile selection\n    // z: number of tile extensions to each side, 0=1-by-1, 1=3-by-3, 2=5-by-5, ..., 9=19-by-19 tiles\n    // w: n/a\n    vec4 sectors = loadData(addrSectors) + defaultSectors;\n\n    // x: A\n    // y: Q\n    // z: S\n    // w: T\n    vec4 keys = loadData(addrKeys);\n\n    // x: render scene < .5 < render selection screen\n    // y: n/a\n    // z: canUseCache for preview\n    // w: columns to render\n    vec4 action = loadData(addrActions) + defaultAction;\n\n    // remember the old values\n    vec4 qualityBak = quality;\n    vec4 sectorsBak = sectors;\n    vec4 stereoBak = stereo;\n    vec4 keysBak = keys;\n\n    keys = vec4(\n        readKey(KEY_A),\n        readKey(KEY_Q),\n        readKey(KEY_S),\n        readKey(KEY_T)\n    );\n    stereo.w = readKey(KEY_X);\n    float keyM = readKey(KEY_M);\n    float keyN = readKey(KEY_N);\n\n    stereo.z += step(.5, stereo.x) * EYE_SHIFT_PER_KEYSTROKE * (keyM - keyN);\n\n    // flip aspect-ratio if key is pressed and was not pressed before\n    stereo.y = mix(stereo.y, step(.5, 1. - stereo.y), step(.5, keys.x - keysBak.x));\n\n    // flip cross-eyed and parallel view\n    stereo.z = mix(stereo.z, -stereo.z, step(.5, stereo.w - stereoBak.w));\n\n    // flip quality if key is pressed and was not pressed before\n    quality.x = mix(quality.x, 1. - quality.x, step(.5, keys.y - keysBak.y));\n\n    // flip sbs stereo if key is pressed and was not pressed before\n    stereo.x = mix(stereo.x, step(.5, abs(1. - stereo.x)), step(.5, keys.z - keysBak.z));\n\n    // flip tab stereo if key is pressed and was not pressed before\n    stereo.x = mix(stereo.x, 2. * step(1.5, abs(3. - stereo.x)), step(.5, keys.w - keysBak.w));\n\n    setSize(9., KEY_9);\n    setSize(8., KEY_8);\n    setSize(7., KEY_7);\n    setSize(6., KEY_6);\n    setSize(5., KEY_5);\n    setSize(4., KEY_4);\n    setSize(3., KEY_3);\n    setSize(2., KEY_2);\n    setSize(1., KEY_1);\n    setSize(0., KEY_0);\n\n    vec2 mouseSector = getSector(iMouse.xy / iResolution.xy, selection.z);\n    selection.xy = mix(selection.xy, mouseSector, step(.5, iMouse.z));\n    sectors.xyz = mix(selection.xyz, sectors.xyz, step(.5, iMouse.z));\n    sectors.xy = clamp(sectors.xy, -sectors.z, sectors.z);\n\n    // If resolution changed, set quality to LQ\n    vec2 tmp = step(.5, float(iFrame)) * abs(quality.zw - iResolution.xy);\n    float qualityUnChanged = step(0., -tmp.x - tmp.y);\n    quality.x *= qualityUnChanged;\n    quality.zw = iResolution.xy;\n\n    // 0: LQ, 1: HQ\n    float qualityMode = step(.5, quality.x);\n\n    // render only rows with x modulo FRAMES_PER_IMAGE == action.w\n    vec2 e = vec2(-1, 1);\n    float diff1 = dot(e.xxxx, abs(quality - qualityBak))\n                + dot(e.xxxx, abs(stereo - stereoBak));\n    float diff2 = dot(e.xxxx, abs(sectors - sectorsBak));\n    float diff3 = dot(e.xx,   abs(quality.zw - iResolution.xy));\n    action.w = mix(float(FRAMES_PER_IMAGE), action.w - 1., step(.0, diff1 + diff2));\n    // channelPreview canUseCache?\n    action.z = step(.0, diff1 + diff3);\n\n//    action.w = (quality == qualityBak && sectors == sectorsBak && stereo == stereoBak) ? action.w - 1. : float(FRAMES_PER_IMAGE);\n    // channelPreview canUseCache?\n//    action.z = (quality == qualityBak && quality.zw == iResolution.xy && stereo == stereoBak) ? 1. : 0.;\n    // renderSelectionScreen?\n    action.x = step(.5, iMouse.z);\n\n    store(addrQuality, quality - defaultQuality);\n    store(addrStereo, stereo - defaultStereo);\n    store(addrSelect, selection - defaultSelection);\n    store(addrSectors, sectors - defaultSectors);\n    store(addrActions, action - defaultAction);\n    store(addrKeys, keys);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"            /////////////////////////////////////////\n           //                                     //\n          // Buffer C                            //\n         //                                     //\n        // Setup:                              //\n       // iChannel1: Buffer B                 //\n      // iChannel2: Buffer C                 //\n     //                                     //\n    /////////////////////////////////////////\n   //                                     //\n  // CONFIGURE STUFF IN THE TAB \"COMMON\" //\n //                                     //\n/////////////////////////////////////////\n\n/////////////////////////////////////////\n// Channels                            //\n/////////////////////////////////////////\n\n#define channelData    iChannel1\n#define channelPreview iChannel2\n\n/////////////////////////////////////////\n// Code                                //\n/////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 quality = loadData(addrQuality) + defaultQuality;\n    vec4 stereo = loadData(addrStereo) + defaultStereo;\n    vec4 action = loadData(addrActions) + defaultAction;\n\n    // No HQ\n    quality.x *= 0.;\n#ifdef ANIMATE\n    fragColor = render(quality, vec4(0), stereo, fragCoord * PIXEL_SIZE, iResolution, iTime);\n#else\n    fragColor = (action.z > .5)\n        ? texelFetch(channelPreview, ivec2(fragCoord), 0)\n        : render(quality, vec4(0), stereo, fragCoord * PIXEL_SIZE, iResolution, iTime);\n#endif\n}","name":"Buffer C","description":"","type":"buffer"}]}