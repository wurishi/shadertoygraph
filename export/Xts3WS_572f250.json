{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define DO_ROT 1\n\n#define M_PI 3.1415926535897932384626433832795\n\nconst int MAX_ITERS = 100;\nconst int BIN_ITERS =  5;\nconst float EPS = 0.001;\nconst float FOV_Y = 45.0 / 180.0 * M_PI;\nconst float FOG_DIST = 100.0;\n\nfloat smin( float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dist(vec3 pt)\n{      \n    float f = (1.0/15.0) * sin(iTime / (M_PI * 2.0));\n    \n    float rotAngle = pt.z * f;\n    float ca = cos(rotAngle);\n    float sa = sin(rotAngle);\n      \n    pt.xy = mat2(ca,sa,-sa,ca)*pt.xy;\n \n    pt += vec3(2.0, 2.0, 2.0);\n    pt = mod(pt + vec3(2.0,2.0,2.0), vec3(4.0,4.0,4.0)) - vec3(2.0,2.0,2.0);\n    \n    float d = length(pt) - 1.0;\n    \n    d = smin(d, length(pt.xy) - 0.2, 0.15);\n    d = smin(d, length(pt.yz) - 0.2, 0.15);\n    d = smin(d, length(pt.xz) - 0.2, 0.15);\n    \n    return d;\n}\n\nvec3 getGrad(vec3 pt)\n{\n    float d = dist(pt);\n   \tfloat dx = dist(pt + vec3(EPS, 0.0, 0.0));\n    float dy = dist(pt + vec3(0.0, EPS, 0.0));\n    float dz = dist(pt + vec3(0.0, 0.0, EPS));\n    \n    return vec3(dx,dy,dz) - d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    \n    float aspectX = iResolution.x / iResolution.y;\n    float fovCoef = tan(FOV_Y / 2.0);\n    \n    vec3 camPos = vec3(0.0,0.0,0.0);\n    \n   \tvec3 dir = normalize(vec3(uv.x * aspectX * fovCoef, uv.y * fovCoef, -1.0));\n  \n#if DO_ROT\n    float angle = iTime/10.0;\n    float pitch = sin(iTime/M_PI) / 6.0;\n    \n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    \n    dir.yz = mat2(cp,sp,-sp,cp) * dir.yz;\n    \n    float ca = cos(angle);\n    float sa = sin(angle);\n   \n    dir.xz = mat2(ca,-sa,sa,ca) * dir.xz; \n#endif\n    \n    dir = normalize(dir);\n    \n    vec3 p = camPos + dir * 0.1;\n   \tvec3 prevPt = vec3(0,0,0);\n    \n    vec3 epsDelta = dir*EPS;   \n    float val = 1.0;\n    bool hit = false;\n    \n    float d = 0.0;\n    float prevd = 0.0;\n    \n    for(int i = 0; i < MAX_ITERS; ++i)\n    {\n        d = dist(p);\n       \t\n        if(d < 0.0){\n            val = float(i) / float(MAX_ITERS-1);\n            hit = true;\n     \t\tbreak;       \n        }\n       \n        if(dot(p,p) > 1000.0*1000.0){\n            break;\n        }\n        \n        prevPt = p;\n        prevd = d;\n        p += d * dir + epsDelta;\n    }  \n    \n    // bin-search\n    if(hit)\n    {\n    \tfor(int j = 0; j < BIN_ITERS; ++j)\n    \t{\n\t    \tvec3 mid = (p + prevPt) / 2.0;               \n            if(dist(mid) < 0.0)\n            { p = mid; }\n            else {prevPt = mid;}\n\t    }\n    }       \n        \n   \tvec3 n = normalize(getGrad(p));\n    \n    float halo = 1.0 - max(dot(-dir, n), 0.0);\n    float camDist = length(camPos - p);\n    \n    vec3 objColor1 = vec3(val);\n    vec3 objColor2 = vec3(camDist/100.0) + pow(halo, 5.0)+ pow(val, 2.0);\n    //vec3 objColor2 = (n + vec3(1.0)) / 2.0; \n    \n    objColor2 = clamp(objColor2, vec3(0.0), vec3(1.0));\n    //vec3 objColor = step(0.0, uv.x) * objColor1 + (1.0 - step(0.0, uv.x)) * objColor2;\n    \n    //vec3 objColor = hit ? objColor2 : vec3(0.0);\n    vec3 objColor = objColor2;\n    //vec3 objColor = vec3(1.0);\n    \n    float fogCoef = max(0.0, 1.0 - exp(-(camDist-5.0) / FOG_DIST)); \n    vec3 fogColor = vec3(0.0,abs(dir.z),abs(dir.x));\n     \n    vec3 color = mix(objColor, fogColor, fogCoef);\n    \n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xts3WS","date":"1424815495","viewed":178,"name":"TwistyGrid","username":"Elkar","description":"simple twisting grid","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""}}