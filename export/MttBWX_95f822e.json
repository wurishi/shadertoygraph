{"ver":"0.1","info":{"id":"MttBWX","date":"1541464134","viewed":181,"name":"Shrine to a Sphere","username":"scratch13764","description":"I made pretty much everything here myself except for a few bits from IQ. I'm going to see about getting the mortar to be recessed between the bricks, I'm not sure how it'll go.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["distancefields","map"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926535\n#define TAU 2.*PI\n#define LIM 20.\n#define LOOPLIM 6000\n#define FOVDIV 4.\n#define AA 1 //Set this to 0 to turn off texture AA\n\nfloat DifferenceSDF (float a, float b) {return max(a,-b);}\n\nfloat PillarSDF(vec3 p,float Size, float CurrentMap){\n    float m = length(p.xy)-(.2*Size);\n    if (m < CurrentMap){\n\n        for(float i = 0.; i < TAU; i += TAU/10.)\n        {\n            m = max(m,-(length(p.xy-(vec2(sin(i),cos(i))*Size*.22))\n                       )+(.08*Size)\n                   );\n        }\n    return m;\n     \n    }else{return 10000.;}\n    \n    \n}\nvec3 LightVec (vec3 lightp, vec3 p)\n{\n    return normalize(lightp-p);\n}\nfloat SmoothUnion( float d1, float d2, float k ) //SmoothUnion by Inigo Quilez\n{\n\tfloat h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat Map (vec3 p){\n    float m = 10000000.;\n        m = min(m,PillarSDF(p-.45,.5,m)); //Pillars\n        m = min(m,PillarSDF(p+.45,.5,m));\n        m = min(m,PillarSDF(p-vec3(-.45,.45,0.),.5,m));\n        m = min(m,PillarSDF(p-vec3(.45,-.45,0.),.5,m));\n        m = max(m, p.z-.07);\n        m = //Restriction on pillars\n        m = min(m, max(length(p)-.781,\n                           max(length(vec3(max(abs(p.x)- .55,0.), // Main building roof thing\n                                   max(abs(p.y)- .55,0.),\n                                   max(abs(p.z/2.+.1)- .55,0.)\n                                            ))+\n                                   min(max(abs(p.x-.4),max(abs(p.y-1.),abs(p.z-.1))),0.)\n                                   -.01,-p.z+.06))\n                 );\n    \n        m = max(m, -(length(vec2(p.x,max(p.z,0.)))-.35)); //Archway restriction\n        m = max(m, -(length(vec2(p.y,max(p.z,0.)))-.35)); //Archway restriction\n        m = min(m, p.z+.5);\n        m = max(m, length(p)-1.3);\n        m = SmoothUnion(m, length(vec3(p.x,p.y,p.z+.3))-.2, .1);\n        m = min(m,length(vec3(p.xy,p.z+.3))-.21);\n        //m += sin(80.*p.x)*sin(80.*p.y)*sin(80.*p.z)/150.;\n        \n            \n    return m;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) //Based of of IQ's soft penumbra shadows and modified a bit\n{\n    float r = .8;\n    for( float t=mint; t < maxt;)\n    {\n        float h = Map(ro + rd*t);\n        if( h<.00001 )\n            return 0.0;\n        r = min( r, k*h/t );\n        t += h;\n    }\n    return r;\n}\n\n\nvec3 PlantText (vec3 u) //Plant texture\n{\n    vec3 c = vec3(0);\n    for(float i = 0.; i <= 1.; i+= .25)\n    c += (vec3(.1,.9,.1)*((texture(iChannel0,u*i).x/2.)+.5));\n    return c/5.;\n}\n\nvec3 BrickText (vec3 p){ // Brick Texture\n    vec3 u =p + (texture(iChannel0,p).x/120.);\n    vec3 c = vec3(.6,.25,.1);\n    if (mod(u.y,.1) < .007 || \n        (mod(u.x + \n                    (mod(u.y,.2)-mod(u.y,.1))\n                    ,.2) < .007)||\n        (mod(u.z + \n                    (mod(u.y,.2)-mod(u.y,.1))\n                    ,.2) < .003)\n        \n       )c = vec3(.8,.8,.7);\n        c *= (texture(iChannel0,u*5.).x)/3.+.9;\n        c *= .8;\n        return c;\n    }\nvec3 AaBrickText (vec3 p)\n{\n    vec3 c = vec3(0.); //9X MSAA, vertices and center of a cube. Helps reduce moire patterns.\n    if(AA == 1){\n    c += BrickText(p);\n    c += BrickText(p + vec3(-.001,-.001,-.001));\n    c += BrickText(p + vec3(-.001,-.001,.001));\n    c += BrickText(p + vec3(-.001,.001,-.001));\n    c += BrickText(p + vec3(-.001,.001,.001));\n    c += BrickText(p + vec3(.001,-.001,-.001));\n    c += BrickText(p + vec3(.001,-.001,.001));\n    c += BrickText(p + vec3(.001,.001,-.001));\n    c += BrickText(p + vec3(.001,.001,.001));\n    return c/9.;\n    }\n    else\n    {\n        return(BrickText(p));\n    }\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Declaring rendering variables\n    // Z is the height of the scene\n    \n    float CAM_DIST = 7. + (sin(iTime/5.)*2.);\n    float CAM_HEIGHT = .6 + (sin(iTime/5.)*.3);\n    \n    vec3 CAM_POS = vec3(sin(iTime*.1)*CAM_DIST,cos(iTime*.1)*CAM_DIST,CAM_HEIGHT); // X, Y, Z\n    vec2 CAM_DIR = vec2(iTime/10.+3.141, -.15); // Yaw, Pitch\n    vec2 RAY_DIR = vec2(uv.x/FOVDIV + CAM_DIR.x,uv.y/FOVDIV+ CAM_DIR.y);\n    \n    \n    \n    vec3 RAY = vec3(CAM_POS.x,CAM_POS.y,CAM_POS.z+.3);  // The position of the ray being marched\n    vec3 RAYV = vec3(vec2(sin(RAY_DIR.x),cos(RAY_DIR.x))*cos(RAY_DIR.y),sin(RAY_DIR.y)); // The number the ray will move if the step size was a constant 1: XYZ\n    float MAP; // The distance between the ray and the closest surface of an object\n    float ALSOMAP; // Displaying map on the plane on the bottom\n    float DIST; // The distance the ray has traveled, useful for distance fog and limiting the ray\n    \n    vec3 LIGHT1 =\n         normalize(vec3(sin(iTime*.15+1.),cos(iTime*.15+1.),.5))*5.;\n    \n    \n    // Declaring other variables\n    vec3 COLOR;\n    \n    // Ray Loop ---- Make this into a function so its easier to make reflections and such :)\n    for (int i; DIST <= LIM && i <= LOOPLIM; i++)\n    {\n        //Map\n        \n        MAP = Map(RAY);\n        \n        // March Ray\n        RAY += RAYV * MAP;\n        //RAY.xy = mod(RAY.xy+2., 4.)-2.; //Uncomment this line for domain repetition\n        DIST += MAP;\n        if (MAP <0.00001)\n        {\n                COLOR = AaBrickText(vec3(RAY.x,RAY.z+.05,RAY.y)*2.2);\n                COLOR *= ((vec3(softshadow(RAY,\n                                         LightVec(LIGHT1,RAY)\n                                         ,.001,5.,5.))+2.)/2.5);\n            break;\n        }\n            \n    }\n    COLOR /= .8+(DIST/20.);\n    if (DIST > LIM){\n        COLOR = texture(iChannel1,vec2(RAY_DIR.x*3.141,RAY_DIR.y*3.141)*2.).xyz/1.5;\n    }\n    fragColor = vec4(COLOR,1.0);\n}","name":"Image","description":"","type":"image"}]}