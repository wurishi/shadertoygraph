{"ver":"0.1","info":{"id":"Nl3yzf","date":"1660201299","viewed":120,"name":"Fire Burning","username":"nelsonkuang","description":"The Hell Fire Burning","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Let's play with fire\n// Liquid Fire from: https://www.shadertoy.com/view/stjyzK\n// Backgound Fire from: https://www.shadertoy.com/view/MdKfDh\n#define timeScale \t\t\tiTime * 1.0\n#define fireMovement \t\tvec2(-0.01, -0.5)\n#define distortionMovement\tvec2(-0.01, -0.3)\n#define normalStrength\t\t40.0\n#define distortionStrength\t10.1\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.1415926535897932384626433832795;\nconst mat3 m3 = mat3(0.00, 0.80, 0.60, -0.80, 0.36, -0.48, -0.60, -0.48, 0.64);\nconst mat2 m2 = mat2(1.6, 1.2, -1.2, 1.6);\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance value from SDF\n  Material mat; // material of object\n};\n\nMaterial fire() {\n  vec3 aCol = 0.8 * vec3(.5, 0.0, 0.0);\n  vec3 dCol = 0.6 * vec3(1.0, 1.0, 0.0);\n  vec3 sCol = 0.6 * vec3(1.0, 1.0, 0.0);\n  float a = .5;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nmat3 identity() {\n  return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n}\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n/*\nSurface IDs:\n1. Floor\n2. Box\n3. Sphere\n*/\nSurface sdFloor(vec3 p, float offset, Material mat) {\n  float d = p.y - offset;\n  return Surface(1, d, mat);\n}\n\nSurface sdBox(vec3 p, vec3 b, vec3 offset, Material mat, mat3 transform, vec3 transformOrigin) {\n  p = (p - offset) * transform - transformOrigin;\n  vec3 q = abs(p) - b;\n  float d = length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n  return Surface(2, d, mat);\n}\n\nSurface sdSphere(vec3 p, float r, vec3 offset, Material mat, mat3 transform, vec3 transformOrigin) {\n  p = (p - offset) * transform - transformOrigin;\n  return Surface(3, length(p) - r, mat);\n}\n\nfloat hash1(float n) {\n  return fract(n * 17.0 * fract(n * 0.3183099));\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Simplex noise\nfloat sNoise2D(in vec2 p) {\n  const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n  const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n  vec2 i = floor(p + (p.x + p.y) * K1);\n\n  vec2 a = p - i + (i.x + i.y) * K2;\n  vec2 o = step(a.yx, a.xy);\n  vec2 b = a - o + K2;\n  vec2 c = a - 1.0 + 2.0 * K2;\n\n  vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n\n  vec3 n = h * h * h * h * vec3(dot(a, hash2(i + 0.0)), dot(b, hash2(i + o)), dot(c, hash2(i + 1.0)));\n\n  return dot(n, vec3(70.0));\n}\n\n// Simplex noise.\nfloat sNoise3D(in vec3 x) {\n  vec3 p = floor(x);\n  vec3 w = fract(x);\n\n  vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);\n\n  float n = p.x + 317.0 * p.y + 157.0 * p.z;\n\n  float a = hash1(n + 0.0);\n  float b = hash1(n + 1.0);\n  float c = hash1(n + 317.0);\n  float d = hash1(n + 318.0);\n  float e = hash1(n + 157.0);\n  float f = hash1(n + 158.0);\n  float g = hash1(n + 474.0);\n  float h = hash1(n + 475.0);\n\n  float k0 = a;\n  float k1 = b - a;\n  float k2 = c - a;\n  float k3 = e - a;\n  float k4 = a - b - c + d;\n  float k5 = a - c - e + g;\n  float k6 = a - b - e + f;\n  float k7 = -a + b + c - d + e - f - g + h;\n\n  return -1.0 + 2.0 * (k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z);\n}\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm2(in vec2 p) {\n  float f = 0.0;\n  f = 0.5000 * sNoise2D(p);\n  p = m2 * p;\n  f += 0.2500 * sNoise2D(p);\n  p = m2 * p;\n  f += 0.1250 * sNoise2D(p);\n  p = m2 * p;\n  f += 0.0625 * sNoise2D(p);\n  p = m2 * p;\n  f = 0.5 + 0.5 * f;\n  return f;\n}\n// https://iquilezles.org/articles/fbm/\nfloat fbm3(in vec3 x) {\n  float f = 2.0;\n  float s = 0.5;\n  float a = 0.0;\n  float b = 0.5;\n  for(int i = min(0, iFrame); i < 4; i++) {\n    float n = sNoise3D(x);\n    a += b * n;\n    b *= s;\n    x = f * m3 * x;\n  }\n  return a;\n}\n\nvec3 bumpMap(vec2 uv) {\n  vec2 s = 1. / iResolution.xy;\n  float p = fbm2(uv);\n  float h1 = fbm2(uv + s * vec2(1., 0));\n  float v1 = fbm2(uv + s * vec2(0, 1.));\n\n  vec2 xy = (p - vec2(h1, v1)) * normalStrength;\n  return vec3(xy + .5, 1.);\n}\n\nSurface sdScene(vec3 p) {\n  vec3 fbmCoord = (p + 2.0 * vec3(iTime, 0.0, iTime)) / 1.5;\n  Surface co = sdSphere(p, 10., vec3(5.0 * sin(iTime), 3.0, 0), fire(), identity(), vec3(0));\n\n  co.sd += 7.0 * fbm3(fbmCoord / 3.2);\n\n  return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n  Surface co; // closest object\n\n  for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = sdScene(p);\n    depth += co.sd;\n    if(co.sd < PRECISION || depth > end)\n      break;\n  }\n\n  co.sd = depth;\n\n  return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n  vec2 e = vec2(1., -1.) * .0005; // epsilon\n  return normalize(e.xyy * sdScene(p + e.xyy).sd +\n    e.yyx * sdScene(p + e.yyx).sd +\n    e.yxy * sdScene(p + e.yxy).sd +\n    e.xxx * sdScene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n  vec3 up = vec3(0, 1, 0);\n  vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n  vec3 cr = normalize(cross(up, cd)); // camera right\n  vec3 cu = normalize(cross(cd, cr)); // camera up\n\n  return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n  vec2 mouseUV = iMouse.xy / iResolution.xy; // Range: <0, 1>\n\n  vec3 col = vec3(0);\n\n  vec3 lp = vec3(0, .5, -4); // lookat point - middle box\n\n  vec3 ro = vec3(0, 5, 0);\n\n  float cameraRadius = 3.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(PI / 2., 0., mouseUV.y)); // remap mouseUV.y to <pi/2, 0> range\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z); // remap mouseUV.x to <-pi, pi> range\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction，如果 -1 改为 1 就是反向的\n\n  Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // closest object\n\n  if(co.sd > MAX_DIST) {\n    // Backgound Fire\n    vec3 normal = bumpMap(uv * vec2(1.0, 0.3) + distortionMovement * timeScale);\n\n    vec2 displacement = clamp((normal.xy - .5) * distortionStrength, -1., 1.);\n    uv += displacement;\n\n    vec2 uvT = (uv * vec2(1.0, 0.5)) + fireMovement * timeScale;\n    float n = pow(fbm2(2.0 * uvT), 1.0);\n\n    float gradient = pow((1.0 - uv.y) / 2.0, 2.0) * 5.;\n    float finalNoise = n * gradient;\n\n    col = finalNoise * vec3(2. * n, 2. * n * n * n, n * n * n * n);\n\n    // col = vec3(2. * n, 2. * n * n * n, n * n * n * n);\n  } else {\n    // Liquid Fire\n    vec3 p = ro + rd * co.sd; // point on sphere or floor we discovered from ray marching\n    vec3 normal = calcNormal(p);\n\n      // light #1\n    vec3 lightPosition1 = vec3(-8, -6, -5);\n    vec3 lightDirection1 = normalize(lightPosition1 - p);\n    float lightIntensity1 = 0.9;\n\n      // light #2\n    vec3 lightPosition2 = vec3(1, 1, 1);\n    vec3 lightDirection2 = normalize(lightPosition2 - p);\n    float lightIntensity2 = 0.5;\n\n      // final color of object\n    col = lightIntensity1 * phong(lightDirection1, normal, rd, co.mat);\n    col += lightIntensity2 * phong(lightDirection2, normal, rd, co.mat);\n  }\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}