{"ver":"0.1","info":{"id":"lsGBWh","date":"1528532700","viewed":611,"name":"Toon Balls","username":"setchi","description":"Toon shading\nAnti-aliasing\nMotion Blur","likes":15,"published":1,"flags":8,"usePreview":0,"tags":["toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITERATION 120.\n#define EPS 1e-2\n#define FAR 100.0\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\nfloat TIME;\nvec3 HUE;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Camera {\n    vec3 eye, target;\n    vec3 forward, right, up;\n    float zoom;\n};\n\nstruct Intersection {\n    bool hit;\n    vec3 position;\n    float distance;\n    vec3 normal;\n    float count;\n};\n\nfloat Hash(float p) {\n  vec3 p3  = fract(vec3(p) * 0.1031);\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat BackIn(float t) {\n  return pow(t, 3.0) - t * sin(t * PI);\n}\n\nfloat Sphere(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nvec3 RotateX(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c * p.y + s * p.z, -s * p.y + c * p.z);\n}\n\nvec3 RotateY(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c * p.x - s * p.z, p.y, s * p.x + c * p.z);\n}\n\nvec3 RotateZ(vec3 p, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c * p.x + s * p.y, -s * p.x + c * p.y, p.z);\n}\n\nvec3 Rotate(vec3 p, vec3 rot) {\n    return RotateZ(RotateY(RotateX(p, rot.x), rot.y), rot.z);\n}\n\nvec3 SplitComplementaryHue(float a) {\n  float s = 1. / 9.;\n  return fract(vec3(a, a + .5 + s, a + .5 - s));\n}\n\nvec3 Hue(float hue) {\n\tvec3 rgb = fract(hue + vec3(0., 2. / 3., 1. / 3.));\n\trgb = abs(rgb * 2. - 1.);\n\treturn clamp(rgb * 3. - 1., 0., 1.);\n}\n\nvec3 HSVtoRGB(vec3 hsv) {\n\treturn ((Hue(hsv.x) - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nfloat Map(vec3 p) {\n  float r = (floor(TIME) + smoothstep(0.5, 1., fract(TIME))) * PI * 0.3;\n  p = Rotate(p, vec3(r, -r, r));\n  p = mod(p, 10.0) - 5.;\n  return Sphere(p, 3.5 + .5 * BackIn(1. - fract(TIME)));\n}\n\nvec3 Normal(vec3 p) {\n    vec3 e = vec3(EPS, 0.00, 0.00);\n    return normalize(vec3(\n      Map(p + e.xyy) - Map(p - e.xyy),\n      Map(p + e.yxy) - Map(p - e.yxy),\n      Map(p + e.yyx) - Map(p - e.yyx)));\n}\n\nfloat Toon(float t, float stripeCount) {\n    float modifiedT = mod(floor(t * stripeCount), stripeCount);\n    return mix(0.0, 1.0, modifiedT / (stripeCount - 1.0));\n}\n\nvec3 Lighting(in Camera camera, in Intersection intersection, in Ray light) {\n  vec3 fromPointToLight = normalize(light.origin - intersection.position);\n  float diffuseStrength = clamp(dot(intersection.normal, fromPointToLight), 0.0, 1.0);\n  diffuseStrength = Toon(diffuseStrength, 2.5);\n  vec3 diffuseColor = HSVtoRGB(vec3(HUE.y, 1., clamp(diffuseStrength + 0.2, 0., 1.)));\n\n  vec3 reflectedLightVector = normalize(reflect(-fromPointToLight, intersection.normal));\n  vec3 fromPointToCamera = normalize(camera.eye - intersection.position);\n  float specularStrength = pow(clamp(dot(reflectedLightVector, fromPointToCamera), 0.0, 1.0), 10.0);\n  specularStrength = Toon(specularStrength, 2.5);\n  specularStrength = min(diffuseStrength, specularStrength);\n  vec3 specularColor = specularStrength * vec3(1.0);\n\n  if (dot(fromPointToCamera, intersection.normal) < 0.3) {\n    return HSVtoRGB(vec3(HUE.z, 1., 1.));\n  }\n\n  return diffuseColor + specularColor;\n}\n\nvoid IntersectScene(inout Intersection intersection, inout Ray ray) {\n  intersection.distance = 0.0;\n  intersection.hit = false;\n\n  vec3 p = ray.origin;\n  float d;\n\n  for (float i = 0.0; i < ITERATION; i++) {\n    d = Map(p);\n    intersection.distance += d;\n    p = ray.origin + intersection.distance * ray.direction;\n    intersection.count = i;\n\n    if (abs(d) < EPS || intersection.distance > FAR) {\n      break;\n    }\n  }\n\n  if (abs(d) < EPS) {\n    intersection.hit = true;\n    intersection.position = p;\n    intersection.normal = Normal(p);\n  }\n}\n\nRay CreateRay(Camera c, vec2 uv) {\n  c.forward = normalize(c.target - c.eye);\n  c.right = normalize(cross(c.forward, c.up));\n  c.up = normalize(cross(c.right, c.forward));\n\n  Ray r;\n  r.origin = c.eye;\n  r.direction = normalize(uv.x * c.right + uv.y * c.up + c.zoom * c.forward);\n  return r;\n}\n\nCamera CreateCamera() {\n  float t = fract(TIME);\n  Camera camera;\n  camera.up = vec3(0, 1., 0.);\n  camera.eye = vec3(0.0, 0.0, -10.0 + BackIn(t + 0.2) * 4.);\n  camera.target = vec3(0);\n  camera.zoom = 1.3;\n  return camera;\n}\n\nRay CreateLight() {\n  Ray light;\n  float lx = mix(-1.5, 1.5, sin(1.) * 2. + 0.5);\n  float ly = 3.0 + mix(-1.5, 1.5, sin(1. * 3.) * 0.5 + 0.5);\n  light.origin = vec3(lx, ly, -10.0);\n  return light;\n}\n\nvec3 Render(vec2 uv) {\n  HUE = SplitComplementaryHue(Hash(floor(TIME)));\n\n  Camera camera = CreateCamera();\n  Ray ray = CreateRay(camera, uv);\n  Ray light = CreateLight();\n\n  Intersection intersection;\n  IntersectScene(intersection, ray);\n\n  vec3 color = intersection.hit\n    ? Lighting(camera, intersection, light)\n    : vec3(1);\n\n  float fog = clamp(intersection.distance / (FAR / 1.2), 0., 1.);\n  float aura = clamp(intersection.count / (ITERATION / 2.), 0., 1.);\n\n  color = mix(color, HSVtoRGB(vec3(HUE.x, 1., 1.)), aura);\n  color = mix(color, vec3(1), fog);\n\n  return color;\n}\n\nvec3 AaRender(vec2 p, float time) {\n  vec3 col = vec3(0.0);\n  const int num = 4;\n\n  for (int i = 0; i < num; i++) {\n    float fi = float(i + 1);\n    TIME = time - float(i) * 0.0045;\n    col += Render(p + vec2(step(fi, 2.001), mod(fi, 2.001)) * 0.0015);\n  }\n\n  return col / float(num);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 color = AaRender(uv, iTime) + 0.2;\n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592654\n#define TAU 6.283185307\n#define BPM 120.0\n\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define saturateA(i) clamp(i,-1.,1.)\n#define lofi(i,j) floor((i)/j)*j\n#define b2t(i) ((i)/BPM*60.0)\n#define noten(i) 440.0*pow(2.0,(float(i)+trans)/12.0)\n\nvec4 random2D( vec2 _v ) {\n  return vec4(fract(sin(dot(_v, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\nvec4 random( float _v ) {\n  return random2D( _v * V.yy );\n}\n\nvec2 kick2( float _phase ) {\n  if ( _phase < 0.0 ) { return V.xx; }\n  return V.yy * sin( _phase * 300.0 - exp( -_phase * 100.0 ) * 30.0 ) * exp( -_phase * 5.0 );\n}\n\nvec2 hihat( float _seed, float _dec ) {\n  return random( _seed ).xy * exp( -_dec );\n}\n\nvec2 mainSound( in int samp,float time) {\n  float t = time;\n    \n  float beat = t * BPM / 60.0;\n  float beatf = fract(beat);\n  float measure = floor(beat / 4.0);\n  \n  vec2 ret = V.xx;\n  float trans = 3.0;\n\n  float kickTime = b2t(beatf);\n  ret += kick2(kickTime);\n\n  if (mod(beat, 8.) < 7.) {\n  \tret += hihat(time, b2t(mod(beat + 0.5, 1.) * 50.));\n  }\n\n  return saturateA(ret);\n}\n","name":"Sound","description":"","type":"sound"}]}