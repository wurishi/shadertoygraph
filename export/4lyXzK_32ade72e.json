{"ver":"0.1","info":{"id":"4lyXzK","date":"1484882829","viewed":87,"name":"GR - Calc Edges Given Line","username":"bradleygriffith","description":"Calculate the edges given a slope and a point. In this particular example we demonstrate drawing a rotating line, marking its intersection with the edges and the intersection of the perpendicular angle to the line with the edges (designated in black).","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["line","intersection","slope","edges"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\nbool isinf(float val) {\n    return (val != 0.0 && val * 2.0 == val) ? true : false;\n}\n\n// Fix a floating point number to two decimal places\nfloat toFixedTwo(float f) {\n    return float(int(f * 100.0)) / 100.0;\n}\n\n// Returns the slope of a line given the degrees of the angle on which that line is rotated;\nfloat slopeForDegrees(float deg) {\n\t// Ensure degrees stay withing 0.0 - 360.0\n    deg = mod(deg, 360.0);\n    \n    float radians = deg * (PI / 180.0);\n\n    return tan(radians);\n}\n\n// Returns slope adjusted for screen ratio.\nfloat normalizedSlope(float slope) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n\treturn ((slope * 100.0) / p.x) / (100.0 / p.x);\n}\n\n// Returns offsets (+/-) for any coordinate at distance given slope.\n//   Note: This function does not normalize distance.\n//   Note: This function does not adjust slope for screen ratio.\nvec2 offsetsForCoordAtDistanceOnSlope(float d, float slope) {\n\treturn vec2(\n        (d * cos(atan(slope))),\n        (d * sin(atan(slope)))\n    );\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with an infinite line, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineIntersection (out vec2 intersect, in vec2 p1, in float m1, in vec2 p2, in float m2) {\n\t// See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n\t//      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n\tbool isIntersecting = false;\n\n\tfloat dx = 1.0;\n\tfloat dy = m1;\n\n\tfloat dxx = 1.0;\n\tfloat dyy = m2;\n\n\tfloat denominator = ((dxx * dy) - (dyy * dx));\n\tif (denominator == 0.0) {\n\t\t// Lines are parallel\n\t\treturn isIntersecting;\n\t}\n    \n   \tif (isinf(dy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(p1.x, p2.y);\n\t\treturn isIntersecting;\n\t}\n\n\tif (isinf(dyy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(p2.x, p1.y);\n\t\treturn isIntersecting;\n\t}\n\n\tfloat u = ((dx * (p2.y - p1.y)) + (dy * (p1.x - p2.x))) / denominator;\n\n\tisIntersecting = true;\n\tintersect = p2 + (u * vec2(dxx, dyy));\n\n\treturn isIntersecting;\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with a line segment, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineSegmentIntersection (out vec2 intersect, in vec2 point, in float m, in vec2 pA, in vec2 pB) {\n\t// See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n\t//      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n\tbool isIntersecting = false;\n\n\tfloat dx = 1.0;\n\tfloat dy = m;\n\n\tfloat dxx = pB.x - pA.x;\n\tfloat dyy = pB.y - pA.y;\n\n\tfloat denominator = ((dxx * dy) - (dyy * dx));\n\tif (denominator == 0.0) {\n\t\t// Lines are parallel\n\t\treturn isIntersecting;\n\t}\n\n\tif (isinf(dy)) {\n\t\tisIntersecting = true;\n\t\tintersect = vec2(point.x, pB.y);\n\t\treturn isIntersecting;\n\t}\n\n\tfloat u = ((dx * (pA.y - point.y)) + (dy * (point.x - pA.x))) / denominator;\n\n\tif (u >= 0.0 && u <= 1.0) {\n\t\t// Intersection occured on line segment\n\t\tisIntersecting = true;\n\t\tintersect = pA + (u * vec2(dxx, dyy));\n\t}\n\n\treturn isIntersecting;\n}\n\n// Dev Note: Terrible code. Needs refactor. Just trying to find \n//   which two edges of the rect the intersections occur at.\nvoid intersectsOnRectForLine(out vec2 iA, out vec2 iB, in vec2 rMinXY, in vec2 rMaxXY, in vec2 point, in float slope) {\n\tbool firstIntersectFound = false;\n\n\tvec2 intersectA = vec2(0.0);\n\tvec2 intersectB = vec2(0.0);\n\tvec2 intersectC = vec2(0.0);\n\tvec2 intersectD = vec2(0.0);\n\n\tbool intersectsLeft = lineLineSegmentIntersection(intersectA, point, slope, rMinXY, vec2(rMinXY.x, rMaxXY.y));\n\tbool intersectsTop = lineLineSegmentIntersection(intersectB, point, slope, vec2(rMinXY.x, rMaxXY.y), rMaxXY);\n\tbool intersectsRight = lineLineSegmentIntersection(intersectC, point, slope, rMaxXY, vec2(rMaxXY.x, rMinXY.y));\n\tbool intersectsBottom = lineLineSegmentIntersection(intersectD, point, slope, rMinXY, vec2(rMaxXY.x, rMinXY.y));\n\n\tif (intersectsLeft) {\n\t\tiA = intersectA;\n\t\tfirstIntersectFound = true;\n\t}\n    \n\tif (intersectsTop) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectB;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectB;\n\t\t\tfirstIntersectFound = true;\n\t\t}\n\t}\n    \n\tif (intersectsRight) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectC;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectC;\n\t\t\tfirstIntersectFound = true;\n\t\t}\n\t}\n    \n\tif (intersectsBottom) {\n\t\tif (firstIntersectFound) {\n\t\t\tiB = intersectD;\n\t\t}\n\t\telse {\n\t\t\tiA = intersectD;\n\t\t}\n\t}\n}\n\n\nfloat isEdge(vec2 uv, vec2 centerUv, float deg, float width) {\n    \n    // Setup\n    // -------------------------------\n    \n    // Dev Note: I've seen some strange artifacting when the input degrees have\n    //   a high number of decimal places. Fixing degrees to a max of two decimal places\n    //   fixes this bug. Not sure that it's the full solution but the problem is mitigated.\n\tdeg = toFixedTwo(deg);\n    \n    float halfWidth = width / 2.0;\n\tfloat slope = normalizedSlope(slopeForDegrees(deg));\n    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0\n    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg));\n   \n\n    // Get offset UVs for width of line, adjacent to center point\n    // --------------------------------------------------------------------\n\n    float angleA = perpendicularDeg;\n    float angleB = mod(perpendicularDeg + 180.0, 360.0); // Offset angle by 180.0, but keep it from exceeding 360.0\n    \n    float slopeA = normalizedSlope(slopeForDegrees(angleA));\n    float slopeB = normalizedSlope(slopeForDegrees(angleB));\n    \n    vec2 kA = offsetsForCoordAtDistanceOnSlope(halfWidth, slopeA);\n    vec2 kB = offsetsForCoordAtDistanceOnSlope(halfWidth, slopeB);\n    \n    vec2 offsetCoordA = centerUv * iResolution.xy;\n    vec2 offsetCoordB = centerUv * iResolution.xy;\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kA;\n    }\n    else {\n        offsetCoordA -= kA;\n    }\n\n    if (angleB <= 90.0 || angleB >= 270.0) {\n        offsetCoordB += kB;\n    }\n    else {\n        offsetCoordB -= kB;\n    }\n\t\n    // Denormalize uvs and uv offsets and find closest point on line for our uv, then renormalize.\n    vec2 uvA = vec2(0.0);\n\tlineLineIntersection(uvA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvA /= iResolution.xy;\n    vec2 uvB = vec2(0.0);\n\tlineLineIntersection(uvB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n\tuvB /= iResolution.xy;\n\n\n\t// Find intersects for line with edges of viewport\n    // -------------------------------\n\n    vec2 uvAIntersectA = vec2(0.0);\n    vec2 uvAIntersectB = vec2(0.0);\n    intersectsOnRectForLine(uvAIntersectA, uvAIntersectB, vec2(0.0), iResolution.xy, offsetCoordA, slope);\n    \n    vec2 uvBIntersectA = vec2(0.0);\n    vec2 uvBIntersectB = vec2(0.0);\n    intersectsOnRectForLine(uvBIntersectA, uvBIntersectB, vec2(0.0), iResolution.xy, offsetCoordB, slope);\n    \n    vec2 perpendicularIntersectA = vec2(0.0);\n    vec2 perpendicularIntersectB = vec2(0.0);\n    // Note: We use `uvA` here. `uvB` would have same effect and what we want is to\n    //   find the intersect perpedicular to the uv's closest point on the line.\n    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0), iResolution.xy, uvA * iResolution.xy, perpendicularSlope); \n\n\n    // Prepare line \n    // -------------------------------\n    \n   \tfloat distX = abs(step(uvB, uv).x - step(uvA, uv).x);\n   \tfloat distY = abs(step(uvB, uv).y - step(uvA, uv).y);\n   \tfloat line = max(distX, distY) * 0.05;\n\n\n    // Prepare edge markers (Dev Note: Pretty bad code in this form)\n    // -------------------------------\n\n    float dist1 = distance(uv * iResolution.xy, uvAIntersectA);\n    dist1 = 1.0 - step(10.0, dist1);\n\n    float dist2 = distance(uv * iResolution.xy, uvAIntersectB);\n    dist2 = 1.0 - step(10.0, dist2);\n\n    float dist3 = distance(uv * iResolution.xy, uvBIntersectA);\n    dist3 = 1.0 - step(10.0, dist3);\n\n    float dist4 = distance(uv * iResolution.xy, uvBIntersectB);\n    dist4 = 1.0 - step(10.0, dist4);\n\n    float perp1 = distance(uv * iResolution.xy, perpendicularIntersectA);\n    perp1 = 1.0 - step(10.0, perp1);\n\n    float perp2 = distance(uv * iResolution.xy, perpendicularIntersectB);\n    perp2 = 1.0 - step(10.0, perp2);\n\n\t// Dev Note: Again, this is ugly code.\n    return max(line, max(perp2, max(perp1, max(dist4, max(dist3, max(dist1, dist2))))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    lowp vec2 position = vec2(0.5, 0.5);\n    lowp float deg = 90.0;\n    if (iMouse.z > 1.0) {\n  \t\tposition = iMouse.xy / iResolution.xy;\n  \t\tdeg = position.x * 360.0;\n    }\n    \n    float width = 100.0;\n\tfloat speed = 0.025;\n    \n\n    // Prepare edge details \n    // -------------------------------\n\n\t//deg = fract(iTime * speed) * 360.0;\n    float edge = isEdge(uv, position, deg, width);\n    \n    fragColor = 1.0 - vec4(edge);\n}","name":"Image","description":"","type":"image"}]}