{"ver":"0.1","info":{"id":"NlSGWV","date":"1624776913","viewed":54,"name":"symmetric linking","username":"kajbostrom","description":"testing symmetry of linking closest neighbors across two hexagonal lattices/simplices.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["geometry","symmetry","lattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by Kaj Bostrom, 2021\n\n#define scale 20.0\n#define PI 3.1415926535898\n#define hash(x)  ( float( hashi(x) ) / float( 0xffffffffU ) )\n\nuint hashi(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nmat2 rotate(float theta)\n{\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\n// non-branching mod3\nint mod3(int n) {\n    int two_if_neg = int(n < 0)*2;\n    int sg = 1-two_if_neg;\n    return two_if_neg + sg*((two_if_neg + sg*n)%3);\n}\n\n// tweaked from iq's hexagonal grid traversal to be non-branching\nivec2 closestLatticeCoords(vec2 p, vec2 origin, float angle) \n{\n    p = rotate(angle)*(p - origin);\n\tvec2 q = vec2(p.x, p.x*0.5 + p.y*0.8660254037);\n\n    ivec2 i = ivec2(floor(q));\n\tvec2 f = fract(q);\n    \n\tint v = mod3(i.x + i.y);\n    ivec2 lc = i + v;\n    lc -= int(v == 2) * (ivec2(2, 1) + int(f.x > f.y)*ivec2(-1, 1));\n    \n    return ivec2( lc.x, (2*lc.y-lc.x)/3 );\n}\n\nvec2 latticePoint(ivec2 lc, vec2 origin, float angle )\n{\n    vec2 pt = vec2(float(lc.x),float(lc.y)*1.732050807);\n    return rotate(-angle)*pt + origin;\n}\n\n/*\n// Parallelogram lattice basis, doesn't provide accurate closest point\nivec2 closestLatticeCoords(vec2 uv, vec2 origin, float angle) {\n    uv = rotate(uv - origin, angle);\n    float row = uv.y / sin(PI/3.);\n    vec2 lp = vec2(uv.x + row*0.5, row);\n    return ivec2(round(lp.x), round(lp.y));\n\n}\n\nvec2 latticePoint(ivec2 lc, vec2 origin, float angle) {\n    vec2 pt = vec2(float(lc.x)-float(lc.y)*0.5, float(lc.y)*sin(PI/3.));\n    pt = rotate(pt, -angle) + origin;\n    return pt;\n}\n*/\n\nfloat tSegment( in vec2 p, in vec2 a, in vec2 b, out float ud)\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float t =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    ud = length(p - (a+t*ba));\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv *= scale;\n    \n    float pixd = scale/iResolution.x;\n    \n    vec2 lattice1Origin = vec2(0, 0);\n    float lattice1Angle = 0.0 + 0.01*iTime;\n    vec2 lattice2Origin = vec2(7.5, 2.5);\n    float lattice2Angle = 0.25*PI + 0.02*iTime;\n\n    //ivec2 lc = ivec2(0, 0);\n    ivec2 lc1 = closestLatticeCoords(uv, lattice1Origin, lattice1Angle);\n    ivec2 lc2 = closestLatticeCoords(uv, lattice2Origin, lattice2Angle);\n    //ivec2 lc = latticeCoords(vec2(0, 5));\n    vec2 lp1 = latticePoint(lc1, lattice1Origin, lattice1Angle);\n    vec2 lp2 = latticePoint(lc2, lattice2Origin, lattice2Angle);\n    float d1 = distance(uv, lp1);\n    float d2 = distance(uv, lp2);\n    float f1 = hash(hashi(uint(lc1.y)) + uint(lc1.x));\n    float f2 = hash(hashi(uint(lc2.y)) + uint(lc2.x));\n    float rg = 1.0;\n    ivec2 lc = lc1;\n    vec2 lp = lp1;\n    float d = d1;\n    float f = f1;\n    vec2 latticeOrigin = lattice1Origin;\n    float latticeAngle = lattice1Angle;\n    vec2 lattice3Origin = lattice2Origin;\n    float lattice3Angle = lattice2Angle;\n    if (d2 < d) {\n        d = d2;\n        lc = lc2;\n        lp = lp2;\n        f = f2;\n        rg = 0.0;\n        latticeOrigin = lattice2Origin;\n        latticeAngle = lattice2Angle;\n        lattice3Origin = lattice1Origin;\n        lattice3Angle = lattice1Angle;\n    }\n    ivec2 lc3 = closestLatticeCoords(lp, lattice3Origin, lattice3Angle);\n    vec2 lp3 = latticePoint(lc3, lattice3Origin, lattice3Angle);\n    ivec2 lc4 = closestLatticeCoords(lp3, latticeOrigin, latticeAngle);\n    float f3 = hash(hashi(uint(lc3.y)) + uint(lc3.x));\n    float dSeg = 0.0;\n    float tSeg = tSegment(uv, lp, lp3, dSeg);\n    float b = f;\n    if (lc == lc4) { //symmetric link\n        d = min(d, dSeg+0.1);\n        b = (1. - tSeg)*f + tSeg*f3;\n        rg += (1. - 2.*rg)*tSeg;\n    }\n    b = .75*b + .25;\n    vec4 colIn = vec4(rg*b,0.5+0.5*b,(1.0-rg)*b,1.0);\n    float bgBlend = smoothstep(0., 1., (d - 0.2)/pixd);\n    //float mix = smoothstep(0., 1., (d1 - 0.2)/pixd)*.5;\n    fragColor = (1.0-bgBlend)*colIn + bgBlend * vec4(1,1,1,1);\n    //fragColor = (1.0-mix)*vec4(1,1,1,1) + mix * vec4(f1, f1, f1, 1.);\n}","name":"Image","description":"","type":"image"}]}