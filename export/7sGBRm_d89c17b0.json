{"ver":"0.1","info":{"id":"7sGBRm","date":"1657840211","viewed":237,"name":"Fork zoom call  mds2 806","username":"mds2","description":"really simple modification of https://www.shadertoy.com/view/MtKyzc\n\nInspired by a New Yorker cartoon","likes":5,"published":1,"flags":34,"usePreview":0,"tags":["zoom","covid","videochat"],"hasliked":0,"parentid":"ttlyDj","parentname":"zoom call from hell"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat squash_squircle(in vec2 in_pos, in float aspect_ratio, in float rad4) {\n    vec2 aspect = vec2(aspect_ratio, 1.0);\n    vec2 pos = aspect * in_pos;\n    vec2 tmp = pos * pos;\n    vec2 deriv = 4.0 * pos * tmp;\n    tmp = tmp * tmp;\n    float val4 = dot(vec2(1.0, 1.0), tmp);\n    float deriv_mag = length(aspect * deriv);\n    float sdf = (val4 - rad4) / deriv_mag;\n    return 1.0 - clamp(0.5 * sdf * iResolution.y, 0.0, 1.0);\n}\n\nvec3 color_shift(in vec3 rgb, in float how_much) {\n    const mat3 to_yuvish = mat3(0.299, -0.14713, 0.615,\n                          0.587, -0.28886, -0.51499,\n                          0.114, 0.436, -0.10001);\n    const mat3 from_yuvish = mat3(1.0, 1.0, 1.0,\n                            0.0, -0.39465, 2.03211,\n                            1.13983, -0.58060, 0.0);\n\n    vec3 yuv = to_yuvish * rgb;\n    yuv += 0.3 * vec3(0.0, how_much * cos(how_much + iTime), how_much * sin(how_much + iTime));\n    yuv = clamp(yuv, vec3(0.0), vec3(1.0));\n    vec3 rgb_out = from_yuvish * yuv;\n    return smoothstep(vec3(0.0), vec3(1.0), rgb_out);\n}\n\nvec3 perturb(in vec3 pt) {\n    return pt + 0.1 * sin(4.0 * pt.x + 8.0 * iTime) * vec3(0.0, 1.0, 0.0);\n}\n\n\nvec3 vehicle_sdf_grad(in vec3 loc) {\n    float dist = vehicle_sdf(perturb(loc));\n    const float del = 0.01;\n    return vec3(vehicle_sdf(perturb(loc + vec3(del, 0.0, 0.0))) - dist,\n                vehicle_sdf(perturb(loc + vec3(0.0, del, 0.0))) - dist,\n                vehicle_sdf(perturb(loc + vec3(0.0, 0.0, del))) - dist) / del;\n}\n\n\nfloat cast_to_vehicle(in vec3 orig, in vec3 dir) {\n    vec3 p = orig;\n    float accum = 0.0;\n    for (int i = 0; i < 256; ++i) {\n    \tfloat remaining = 0.7 * vehicle_sdf(p);\n        accum += remaining;\n        p = orig + accum * dir;\n        p = perturb(p);\n        if (remaining < 1.0e-3 || accum > MAX_DIST) {\n            return accum;\n        }\n    }\n\treturn max(accum, MAX_DIST + 1.0);\n}\n\nvec3 get_bounce(in vec3 pt, in vec3 dir) {\n    vec3 norm = normalize(vehicle_sdf_grad(pt));\n    return normalize(reflect(dir, norm));\n}\n\nvec4 castRay(in vec2 tv_coord) {\n\tvec2 uv = 5.0 * tv_coord - vec2(2.5);\n    vec3 ray_orig = vec3(0.0, 0.5, -7.0);\n\tvec3 ray_dir = normalize(vec3(uv, 5.0));\n    \n    float wiggle = abs(mod(0.2 * iTime, 4.0) - 2.0) - 1.0;\n    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));\n    float ct = sin(wiggle);\n    float st = cos(wiggle);\n    mat3 twist = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n    ray_dir = twist * ray_dir;\n    ray_orig = twist * ray_orig;\n    \n    float d = MAX_DIST;\n    \n    if (abs(uv.y) < 1.0 && abs(uv.x) < 1.2) {\n\t    d = cast_to_vehicle(ray_orig, ray_dir);\n    }\n    if (d < MAX_DIST) {\n        vec3 pt = ray_orig + d * ray_dir;\n        ray_dir = get_bounce(pt, ray_dir);\n    }\n\n    return vec4(abs(0.5 + 0.5 * ray_dir), 1.0);\n}\n\nvec4 spaceship(in vec2 tv_coord, in vec2 tv_uv_size) {\n    vec2 pix_scale = tv_uv_size * 2.0 / iResolution.y;\n    vec4 outcolor = 0.25 * castRay(tv_coord + pix_scale * vec2(0.49, -0.47));\n    outcolor += 0.25 * castRay(tv_coord + pix_scale * vec2(0.5, 0.4));\n    outcolor += 0.25 * castRay(tv_coord + pix_scale * vec2(-0.35, 0.48));\n    outcolor += 0.25 * castRay(tv_coord + pix_scale * vec2(-0.48, -0.49));\n    return outcolor;\n}\n\nvec4 castRayUFO(in vec2 tv_coord, in float offset_t) {\n\tvec2 uv = 5.0 * tv_coord - vec2(2.5);\n    vec3 ray_orig = vec3(0.0, 0.5, -7.0);\n\tvec3 ray_dir = normalize(vec3(uv, 15.0));\n    \n    float wiggle = abs(mod(0.2 * iTime + 0.1 * offset_t, 4.0) - 2.0) - 1.0;\n    wiggle = sign(wiggle) * smoothstep(0.0, 1.0, abs(wiggle));\n    float ct = sin(wiggle);\n    float st = cos(wiggle);\n    mat3 twist = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n    ray_dir = twist * ray_dir;\n    ray_orig = twist * ray_orig;\n    wiggle = 0.1 * sin(iTime + offset_t);\n    ct = cos(wiggle);st = sin(wiggle);\n    twist = mat3(ct, st, 0.0,\n                 -st, ct, 0.0,\n                 0.0, 0.0, 1.0);\n    ray_dir = twist * ray_dir;\n    \n    ray_orig = ray_orig - vec3(0.0, 0.2, 0.0) -\n        sin(vec3(4.2, 1.2, 3.4) * (offset_t + iTime)) * vec3(0.5, 0.1, 0.2);\n    float closeness = MAX_DIST;\n    float d = cast_to_vehicle2(ray_orig, ray_dir, closeness);\n    \n    if (d < MAX_DIST) {\n        vec3 pt = ray_orig + d * ray_dir;\n        ray_dir = get_bounce2(pt, ray_dir);\n        // return vec4(abs(0.5 + 0.5 * ray_dir), 1.0);\n       // return vec4(0.0);\n    }\n\n    return vec4(vec3(0.1, 0.3, 1.0) + \n                0.8 * dot(ray_dir, vec3(0.48, 0.36, -0.8)) +\n                0.25 * vec3(1.0,0.7, -0.2) * smoothstep(0.5, 0.0, closeness) +\n                0.5 * vec3(1.0,0.7, -0.2) * smoothstep(0.15, 0.0, closeness), 1.0);\n}\n\n\nvec4 UFO(in vec2 tv_coord, in vec2 tv_uv_size, in float offset_t) {\n    vec2 pix_scale = tv_uv_size * 2.0 / iResolution.y;\n    vec4 outcolor = 0.25 * castRayUFO(tv_coord + pix_scale * vec2(0.49, -0.47), offset_t);\n    outcolor += 0.25 * castRayUFO(tv_coord + pix_scale * vec2(0.5, 0.4), offset_t);\n    outcolor += 0.25 * castRayUFO(tv_coord + pix_scale * vec2(-0.35, 0.48), offset_t);\n    outcolor += 0.25 * castRayUFO(tv_coord + pix_scale * vec2(-0.48, -0.49), offset_t);\n    // return vec4(1.0, 0.0, 0.0, 1.0);\n    return outcolor;\n}\n\nvec4 color_from(in vec2 in_uv, in vec2 delta, in int i) {\n    vec2 uv = in_uv - vec2(0.5);\n    uv = uv * (1.0 - 0.2 * smoothstep(0.25, 0.0, dot(uv, uv)));\n    uv = uv + vec2(0.5);\n    float float_i = float(i);\n    float t_wave = 2.0 * smoothstep(0.0, 4.0, mod(iTime * (1.0 + 0.01 * float_i), 4.0)) - 0.5;\n    float smooth_t_wave = smoothstep(0.75, 0.0, abs(t_wave - 0.5));\n    int switch_i = i % 10;\n    float spike = smoothstep(0.15, 0.0, abs(in_uv.y - t_wave));\n    \n    if (mod(iTime, 100.0) > 92.0) {\n      switch_i = 8 + (i % 2);\n    }\n    \n\n    switch (switch_i) {\n        case 0:\n        return texture(iChannel0, 0.5 * uv + vec2(0.5));\n        case 1:\n        vec3 col = texture(iChannel0, 0.5 * uv + vec2(0.0, 0.5)).rgb;\n        mat3 blowout = mat3(6.62337, 6.13667, 6.25027,\n                        6.13667, 6.36245, 7.10737,\n                        6.25027, 7.10737, 8.68193);\n    \tvec3 cent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n    \n        col = col - cent;\n        return vec4(cent + (0.7 * col + 0.3 * blowout * col), 1.0);  \n        case 2:\n        return texture(iChannel0, 0.5 * uv + vec2(0.5, 0.0));\n        case 3:\n        return texture(iChannel0, 0.5 * uv + vec2(0.0));\n        case 4:\n        return vec4(uv, smooth_t_wave, 1.0);\n        case 5:\n        return spaceship(uv, delta);\n        case 6:\n        return vec4(0.3 * spike, 0.1, 1.0, 1.0);\n        case 7:\n        \tcol = texture(iChannel0, (0.5 * uv + vec2(0.5)) + 0.2 * vec2(spike, 0.0)).rgb;\n         \tblowout = mat3(1.87583893, 0.96308725, 0.,\n       \t\t\t0.96308725, 1.17416107, 0.,\n       \t\t\t0.        , 0.        , 0.5);\n    \t\tcent = vec3(0.47968451, \n                     0.450743, \n                     0.45227517);\n\n   \n    \n    \t\tvec3 dir = blowout * (col - cent);\n    \n    \t\tvec3 maxes = (step(vec3(0.0), dir) - col)/dir;\n    \n    \t\tfloat amount = min(maxes.x, min(maxes.y, maxes.z));\n    \n    \t\t// amount = min(amount, 0.75);\n    \t\n    \n    \t\tcol = col + dir * amount;\n        \treturn vec4(color_shift(col, spike), 1.0);\n        case 8:\n        return UFO(uv, delta, float_i);\n        default:\n        \n        return vec4(color_shift(sin(vec3(0.9, 1.1, 0.7) * iTime + \n                                    1.0 * smooth_t_wave + vec3(1.0, 2.0, 3.0)),\n                                spike), 1.0) + texture(iChannel1, uv);\n    }\n}\n\nvec4 add_screen(in vec2 uv, in vec2 uv_min, in vec2 uv_max, in vec4 old_color,\n                in int i) {\n    vec2 delta = (uv_max - uv_min);\n    vec2 midpoint = 0.5 * (uv_max + uv_min);\n    float aspect = abs(delta.y / delta.x);\n    float rad = 0.4 * abs(delta.y);\n  \tfloat rad2 = rad * rad;\n    float rad4 = rad2 * rad2;\n    float outer_rad = rad + 0.05 * delta.y;\n\t//    float outer_aspect  = (rad * aspect + 0.05 * delta.y) / (rad + 0.05 * delta.y);\n    float outer_rad2 = outer_rad * outer_rad;\n    float outer_rad4 = outer_rad2 * outer_rad2;\n    float inside = squash_squircle(uv - midpoint, aspect, rad4); // abs(delta.x/delta.y), 0.01 * abs(delta.y));\n    float in_border = squash_squircle(uv - midpoint, aspect, outer_rad4);\n    vec4 color = color_from((uv - uv_min)/delta, delta, i);\n    color = mix(vec4(vec3(0.0), 1.0), color, inside);\n    return mix(old_color, color, in_border);\n}\n\nvec2 subdivide(in vec2 uv, in vec2 split, inout vec2 uv_min, inout vec2 uv_max, inout int i) {\n    vec2 delta = uv_max - uv_min;\n    vec2 local_split = uv_min + 0.5 * (1.0 + split) * delta;\n    vec2 out_sign = vec2(1.0);\n    if (uv.x > local_split.x) {\n        uv_min.x = local_split.x;\n    } else {\n        uv_max.x = local_split.x;\n        i = i + 1;\n        out_sign.y *= -1.0;\n    }\n    \n    if (uv.y > local_split.y) {\n        uv_min.y = local_split.y;\n        out_sign.x *= -1.0;\n    } else {\n        uv_max.y = local_split.y;\n        i = i + 2;\n    }\n    return out_sign;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord -iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec4 col = vec4(vec3(0.2), 1.0);\n\n    vec2 uv_min = -iResolution.xy / iResolution.y;\n    vec2 uv_max = iResolution.xy / iResolution.y;\n    int i = 0;\n    \n    vec2 s = subdivide(uv, vec2(0.1, -0.2), uv_min, uv_max, i);\n    i *= 4;\n    s = subdivide(uv, s * vec2(-0.1, 0.2), uv_min, uv_max, i);\n    i *= 4;\n    s = subdivide(uv, s * vec2(-0.2, -0.1), uv_min, uv_max, i);\n    // i = i & 7;\n    // Output to screen\n    fragColor = add_screen(uv, uv_min, uv_max, col, i);\n//    fragColor = vec4(0.5 + 0.5 * uv_min, 0.5 + 0.5 * uv_max.x, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_DIST 15.0\n\n\nfloat s_min(in float x, in float y, in float s) {\n\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return min(x,y) - 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat s_max(in float x, in float y, in float s) {\n    float bridge =\n        clamp(abs(x-y)/s, 0.0, 1.0);\n    return max(x,y) + 0.25 * s * (bridge - 1.0) * (bridge - 1.0);\n}\n\nfloat cone_sdf(in vec3 loc) {\n    float cone_length = \n        abs(loc.x) + length(loc.yz);\n\tcone_length = 0.7 * (cone_length - 1.5);\n\n\treturn cone_length;\n}\n\nfloat cyl_sdf(in vec3 loc) {\n    float r = length(loc.yz) - 0.5;\n    float cap1 = loc.x - 0.5;\n    float cap2 = -0.75 - loc.x;\n    return s_max(cap1, s_max(cap2, r, 0.2), 0.2);\n}\n\nfloat inv_sphere(in vec3 loc, in vec3 cent, in float rad) {\n  return max(-rad, rad - length(cent - loc));\n}\n\nfloat vehicle_sdf(in vec3 loc) {\n    float c = cone_sdf(loc);\n    float p = -loc.y;\n    float b = -loc.x + 0.2;\n    float shell = s_max(c, b, 0.6);\n    float back = s_max(cyl_sdf(loc), p, 0.1);\n    shell = s_min(shell, back, 0.4);\n    shell = s_max(shell,  p, 0.2);\n    \n    vec3 eye1 = vec3(0.7, 0.3, 0.3);\n    vec3 eye2 = vec3(0.7, 0.3, -0.3);\n    \n    return shell \n        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy - vec2(0.42, 0.0)))\n        + 0.1 * smoothstep(0.2, 0.0, length(loc.zy + vec2(0.42, 0.0)))\n        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye1))\n        - 0.25 * smoothstep(0.41, 0.0, length(loc - eye2))\n        - 0.1 * smoothstep(0.2, -0.0, loc.y) * (1.0 + 0.2 * smoothstep(0.4, 0.6, abs(loc.z)));\n}\n\nvec3 perturb2(in vec3 loc) {\n    return loc;\n}\n\nfloat vehicle_sdf2(in vec3 loc) {\n    float ball1 = length(loc - vec3(0.0, -0.8, 0.0)) - 1.0;\n    float ball2 = length(loc - vec3(0.0, 0.8, 0.0)) - 1.0;\n    float disc = s_max(ball1, ball2, 0.05);\n    float ball3 = length(loc - vec3(0.0, 0.1, 0.0)) - 0.2;\n    return s_min(disc, ball3, 0.1);\n}\n\nvec3 vehicle_sdf2_grad(in vec3 loc) {\n    float dist = vehicle_sdf2(perturb2(loc));\n    const float del = 0.01;\n    return vec3(vehicle_sdf2(perturb2(loc + vec3(del, 0.0, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, del, 0.0))) - dist,\n                vehicle_sdf2(perturb2(loc + vec3(0.0, 0.0, del))) - dist) / del;\n}\n\nfloat cast_to_vehicle2(in vec3 orig, in vec3 dir, out float mindist) {\n    vec3 p = orig;\n    float accum = 0.0;\n    mindist = MAX_DIST;\n    for (int i = 0; i < 256; ++i) {\n        float dist = vehicle_sdf2(p);\n        mindist = min(dist, mindist);\n    \tfloat remaining = 0.7 * dist;\n        accum += remaining;\n        p = orig + accum * dir;\n        p = perturb2(p);\n        if (remaining < 1.0e-3 || accum > MAX_DIST) {\n            return accum;\n        }\n    }\n\treturn max(accum, MAX_DIST + 1.0);\n}\n\nvec3 get_bounce2(in vec3 pt, in vec3 dir) {\n    vec3 norm = normalize(vehicle_sdf2_grad(pt));\n    return normalize(reflect(dir, norm));\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nmat3 global_twist = mat3(1.0, 0.0, 0.0,\n0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n\nvoid set_twist(in float time) {\n  float ct = cos(0.5 * time);\n  float st = sin(0.5 * time);\n  global_twist = mat3(ct, st, 0.0, -st, ct, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 get_orig(in float time) {\n  return vec3(0.0, 4.0, -8.0);\n}\n\nvec3 get_ray(in vec2 fragCoord, in vec2 resolution, in float time) {\n  vec2 uv = (2.0 * fragCoord - resolution) / max(resolution.x, resolution.y);\n  const mat3 tilt = mat3(1.0, 0.0, 0.0,\n                         0.0, 0.8660254, 0.5,\n                         0.0, -0.5, 0.8660254);\n  return normalize(tilt * vec3(uv, 1.7));\n}\n\nvec3 get_light(in float time) {\n  vec3 pt = get_orig(time);\n  return mat3(0.6, 0.0, 0.8,\n              0.0, 1.0, 0.0,\n              -0.8, 0.0, 0.6) * pt;\n}\n\nvec3 get_light_ray(in vec2 fragCoord, in vec2 resolution, in float time) {\n\n  vec2 uv = (2.0 * fragCoord - resolution) / max(resolution.x, resolution.y);\n  const mat3 tilt = mat3(1.0, 0.0, 0.0,\n                         0.0, 0.8660254, 0.5,\n                         0.0, -0.5, 0.8660254);\n  vec3 dir = normalize(tilt * vec3(uv, 0.45));\n  return mat3(0.6, 0.0, 0.8,\n              0.0, 1.0, 0.0,\n              -0.8, 0.0, 0.6) * dir;\n}\n\nvec2 light_ray_to_uv(in vec3 ray, in vec2 resolution, in float time) {\n  // will break if time starts to matter, makes assumptions\n  const mat3 inv_light = mat3(0.6, 0.0, -0.8, 0.0, 1.0, 0.0, 0.8, 0.0, 0.6);\n  const mat3 inv_tilt = mat3(1.0, 0.0, 0.0,\n                             0.0, 0.8660254, -0.5,\n                             0.0, 0.5, 0.8660254);\n  vec3 xformed =  inv_tilt * (inv_light * ray);\n  vec2 uv = 0.45 * xformed.xy/xformed.z;\n  uv *= max(resolution.x, resolution.y)/resolution.xy;\n  uv = 0.5 * uv + 0.5;\n  return clamp(0.25 * uv, 0.0, 0.25);\n}\n\nfloat calc_stop_per_d(in float scale, in vec2 resolution) {\n  float per_pix_at_plane = 2.0 / max(resolution.x, resolution.y);\n  return per_pix_at_plane / (scale * 1.7);\n}\n\n/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/** more expensive, but smoother, blend funcs */\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\n/** best of both worlds */\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat checked_smooth_isect(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, -b, k);\n}\n\nfloat checked_smooth_diff(in highp float a, in highp float b, in highp float k) {\n  return -checked_smooth_min(-a, b, k);\n}\n\nfloat super_egg(in vec3 pt) {\n  vec3 squares = pt * pt;\n  float l = sqrt(sqrt(dot(squares, squares)));\n  return l - 1.0;\n}\n\nfloat semi_egg(in vec3 pt) {\n  return super_egg(vec3(pt.x, length(pt.yz), 0.0));\n}\n\nfloat car_core(in vec3 pt) {\n  return super_egg(pt / vec3(9.0, 4.0, 1.0));\n}\n\nfloat cockpit(in vec3 pt) {\n  return checked_smooth_isect(semi_egg((pt.yzx - vec3(0.,1.75, 4.)) / vec3(3., 2., 7.)),\n                              semi_egg((pt.yzx - vec3(0., 1.5, 3.)) / vec3(4., 3., 5.)),\n                              0.25);\n} \n\nfloat car(in vec3 pt) {\n  return checked_smooth_min(car_core(pt), cockpit(pt), 1.25);\n}\n\nfloat engines(in vec3 pt) {\n  return min(semi_egg((pt + vec3(9., 4.75, -2.3)) / vec3(6.0, 1.0, 1.0)),\n             semi_egg((pt + vec3(9.0, -4.75, -2.3)) / vec3(6., 1., 1.)));\n}\n\nfloat box(in vec3 pt_min, in vec3 pt_max, in vec3 pt) {\n  vec3 dists = max(pt_min - pt, pt - pt_max);\n  return max(dists.x, max(dists.y, dists.z));\n}\n\nfloat wings(in vec3 pt) {\n  float unboxed = checked_smooth_diff(\n    -min(-super_egg((pt + vec3(5., 0., -2.)) / vec3(9., 5., 2.)),\n         super_egg((pt + vec3(2., 0., -2.1)) / vec3(8.75, 4.25, 1.6))),\n    super_egg((pt + vec3(4., 0., -4.5)) / vec3(3., 12., 3.)),\n    1.0);\n    \n    return checked_smooth_isect(box(vec3(-9.5, -5., -5.), vec3(-3., 5., 5.), pt),\n                                unboxed, 1.);\n}\n\nfloat sdf(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  float carval =  min(car(p), engines(p));\n  return checked_smooth_min(carval, wings(p), 0.5);\n}\n\nfloat cockpit_check(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  return checked_smooth_diff(cockpit(p), car_core(p), 0.25);\n}\n\nfloat engine_check(in vec3 pt) {\n  vec3 p = global_twist * (3.0 * pt.zxy);\n  return checked_smooth_min(engines(p), max(3.0 - p.z, wings(p)), 0.5);\n  // return checked_smooth_min(engines(p), wings(p), 0.5);\n  // return engines(p);\n}\n\nvec3 sdf_normal(in vec3 pt) {\n  float f = sdf(pt);\n  const float h = 0.001;\n  return normalize(vec3(sdf(pt + vec3(h, 0.0, 0.0)) - f,\n                        sdf(pt + vec3(0.0, h, 0.0)) - f,\n                        sdf(pt + vec3(0.0, 0.0, h)) - f));\n}\n\nfloat raymarch(in vec3 orig, in vec3 dir,\n               in float start_d, in float stop_per_d) {\n  float along = start_d;\n  for (int i = 0; i < 256; ++i) {\n    vec3 pt = orig + along * dir;\n    float d = sdf(pt);\n    if (along > MAX_DIST || abs(d) < stop_per_d * max(along, 1.0)) {\n      return along;\n    }\n    along = along + 0.25 * d;\n  }\n  return along;\n}\n\nfloat float_from_col(in vec4 rgba) {\n  return 256.0 * rgba.r + rgba.g + 0.00390625 * (rgba.b + 0.00390625 * rgba.a);\n}\n\n\n\nvec4 col_from_float(in float val) {\n  vec4 result;\n  result.r = mod(0.00390625 * val, 1.0);\n  val = val - 256.0 * result.r;\n  result.g = mod(val, 1.0);\n  val = val - result.g;\n  val = val * 256.0;\n  result.b = mod(val, 1.0);\n  val = val - result.b;\n  val = val * 256.0;\n  result.a = mod(val, 1.0);\n  return result;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    set_twist(iTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (uv.x > 0.5 || uv.y > 0.5) {\n      fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    \n    float speed_test = 0.0;\n    \n    vec3 orig = get_orig(iTime);\n    vec3 dir = get_ray(2.0 * fragCoord, iResolution.xy, iTime);\n\n    \n    vec4 col = vec4(0.0);\n    \n    float dist = float_from_col(col);\n    \n    float dist_refined = raymarch(orig, dir, speed_test * dist, 1.0e-4);\n    \n    \n    if (dist_refined > MAX_DIST) {\n      fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    \n    \n    vec3 loc = orig + dir * dist_refined;\n    \n    vec3 light = get_light(iTime);\n    \n    float dist_from_light = length(loc - light);\n    \n    vec2 light_uv = light_ray_to_uv(loc - light, iResolution.xy, iTime);\n    float light_dist_from_tex = 0.0;\n    float dist_from_light_to_surf = raymarch(light, normalize(loc - light),\n                                             speed_test * 0.5 * light_dist_from_tex, 1.0e-4);\n    float subsurf = max(0.0, dist_from_light - dist_from_light_to_surf);\n    \n        \n    vec3 spectrum =  60.0 * vec3(0.05, 0.25, 0.85);\n    \n    \n    float metal = smoothstep(0.3, 0.2, engine_check(loc));\n\n    if (metal > 0.5) {\n      spectrum = spectrum * 0.001;\n    }\n\n    vec3 subsurf_bright = spectrum / (spectrum + subsurf);\n    \n    vec3 normal = sdf_normal(loc);\n    vec3 bounce = normalize(reflect(dir, normal));\n    \n    float dot_light = dot(normalize(light - loc), bounce);\n    vec3 refl_bright = smoothstep(vec3(0.8, 0.85, 0.9), vec3(1.0), vec3(dot_light));\n    float diffuse = 0.2 + max(0.0, dot(normalize(light - loc), normal));\n\n    if (metal > 0.5) {\n      diffuse = 0.2 + 1.0 * max(0.0, dot_light); //  + 0.1 * sin(20.0 * bounce.y);\n    }\n    \n    vec3 color1 = 0.75 * subsurf_bright * diffuse + 0.5 * refl_bright + 0.15 * subsurf_bright;\n    vec3 color2 = 0.75 * smoothstep(0.95, 1.0, refl_bright) + 0.25 * (0.5 + 0.5 * bounce);\n    \n    float material = smoothstep(0.05, 0.1, 2.0 * cockpit_check(loc)); \n    // material = 0.0;\n    // Output to screen\n    fragColor = vec4(mix(color2, color1, material) + mix(vec3(1., 0.5, 0.), vec3(0.), speed_test), 1.0);\n   // fragColor = fragColor + 200.0 * texture(iChannel1,  0.5 * uv);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float ramp(in float a, in float b, in float x) {\n    return clamp((x-a)/(b-a), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (4.0 * fragCoord - vec2(0.0, iResolution.y))/iResolution.x;\n    \n    uv.x = 1.5 * uv.x - 1.0;\n    \n    float along = uv.x;\n    uv.x = mod(uv.x, 1.0);\n    \n    uv.y = clamp(uv.y, 0.0, 1.0);\n    \n    float tstep = mod(iTime, 16.0);\n    tstep = tstep - mod(tstep, 1.0);\n    \n    const vec2 ostart = vec2(15.0 / 16.0, 11.0 / 16.0);\n    const vec2 bstart = vec2(2.0 / 16.0, 11.0 / 16.0);\n    const vec2 estart = vec2(5.0 / 16.0, 11.0 / 16.0);\n    const vec2 ystart = vec2(9.0 / 16.0, 10.0 / 16.0);\n    const vec2 pstart = vec2(0.0 / 16.0, 10.0 / 16.0);\n    vec2 tstart = bstart;\n    vec2 vowel_start = mix(estart, ostart, step(mod(fragCoord.y / iResolution.y + 20.0 * iTime, 100.0), 50.0));\n    tstart = mix(tstart, vowel_start, step(1.0, along));\n    tstart = mix(tstart, vowel_start, step(2.0, along));\n    tstart = mix(tstart, pstart, step(3.0, along));\n    \n    \n    vec4 val = texture(iChannel0, tstart + uv / 16.0);\n    \n    const float scale = 1.0/256.0;\n    float dist = val.r + scale * (val.g + scale*val.b);\n\n    // Time varying pixel color\n    vec3 col = clamp(4.0 * sin(0.7521 * iTime) - 3.0, 0.0, 1.0) * vec3(ramp(0.3  , 0.7, dist));\n\n    // Output to screen\n    fragColor = vec4(col, col.r);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 decision = sign(uv - vec2(0.5));\n    if (decision.x * decision.y < 0.0) {\n      if (decision.y > 0.0) {\n        fragColor = texture(iChannel2, mod(2.0 * uv, vec2(1.0)));\n        return;\n      }\n      float theta = 0.1 * iTime;\n      float ct = cos(theta);\n      float st = sin(theta);\n      mat3 yaw = mat3(ct, 0.0, st,\n                      0.0, 1.0, 0.0,\n                      -st, 0.0, ct);\n      uv = (mod(4.0 * fragCoord.xy, 2.0 * iResolution.xy) - iResolution.xy)/iResolution.y;\n      vec3 dir = yaw * normalize(vec3(uv, 0.5));\n      fragColor = texture(iChannel1, dir);\n      return;\n    }\n    uv.x = abs(2.0 * uv.x - 1.0);\n    uv.y = mod(2.0 * uv.y, 1.0);\n    fragColor = texture(iChannel0, 0.5 * uv);\n}","name":"Buffer C","description":"","type":"buffer"}]}