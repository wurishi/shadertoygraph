{"ver":"0.1","info":{"id":"WsVfWD","date":"1607172508","viewed":53,"name":"fractal images","username":"lewismills2k","description":"lab3","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["p3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// WEEK 4 WEBINAR 1 PERLIN NOISE EX 2-----------------------------------------------------------------------------------\n\nconst int shuffle[256] = int[256]\n(206,21,27,124,238,156,174,113,170,81,237,12,22,241,23,141,10,167,146,114,\n 162,9,13,5,139,216,91,65,6,189,221,86,7,187,212,166,67,149,131,98,126,1,\n 137,54,8,70,110,148,46,151,106,89,121,236,101,227,49,72,255,239,3,73,244,169,\n 157,96,175,75,77,205,160,30,36,178,112,88,154,228,104,68,185,43,184,182,14,163,\n 233,18,180,45,83,186,59,25,129,111,74,215,122,218,144,44,100,161,53,254,55,92,\n 35,145,220,119,195,66,130,150,140,181,57,56,84,207,245,231,191,248,61,52,118,168,\n 226,223,40,197,116,58,232,243,214,204,33,28,105,202,24,152,133,51,196,210,115,\n 190,97,147,143,132,50,94,165,109,198,39,134,120,2,85,128,135,20,79,123,90,222,\n 26,155,82,252,136,76,217,32,240,63,38,159,247,37,176,78,234,42,219,209,0,103,\n 64,99,15,95,242,47,11,246,211,199,17,62,29,192,69,183,200,34,225,138,224,127,\n 235,229,117,253,71,108,87,201,208,171,203,41,173,102,125,213,107,179,250,80,16,\n 4,153,142,251,31,172,164,188,249,93,60,230,194,177,193,48,158,19);    \n\nconst vec3 gradients[16] = vec3[16](\nvec3(1,1,0),vec3(-1,1,0),vec3(1,-1,0),vec3(-1,-1,0),\nvec3(1,0,1),vec3(-1,0,1),vec3(1,0,-1),vec3(-1,0,-1),\nvec3(0,1,1),vec3(0,-1,1),vec3(0,1,-1),vec3(0,-1,-1),\nvec3(1,1,0),vec3(-1,1,0),vec3(0,-1,1),vec3(0,-1,-1));\n\nint Hash( in int i, in int j, in int k )\n{\n    return shuffle[(shuffle[(shuffle[i%256] + j)%256] + k)%256]%16;\n}\n\nvec3 Gradient( int i, int j, int k )\n{\n\treturn gradients[Hash(i,j,k)];\n}\n\nvec3 PositionVector( int i, int j, int k, vec3 pos )\n{\n\treturn (pos-vec3(i,j,k));\n}\n\nfloat Smoothstep( float f0, float f1, float x )\n{\n\tx = max(x, 0.0);\n\tx = min(x, 1.0);\n\tx = 3.0*x*x - 2.0*x*x*x;\n\treturn f0*(1.0f-x) + f1*x;\n}\n\n\nfloat PerlinNoise( vec3 pos, float iScale )\n{\n\tfloat noiseVals[8];\n\tpos = (pos + vec3(100,100,100))*iScale; // offset of 100 is to make sure it is in the positive quadrant\n\t// get the indices of the cube this vert is in\n\tint i = int( pos.x );\n\tint j = int( pos.y );\n\tint k = int( pos.z );\n\t// get the noise values at the vertices of the cube\n\tnoiseVals[0] = dot( Gradient(i,j,k),       PositionVector(i,j,k,pos) );\n\tnoiseVals[1] = dot( Gradient(i+1,j,k),     PositionVector(i+1,j,k,pos) );\n\tnoiseVals[2] = dot( Gradient(i+1,j,k+1),   PositionVector(i+1,j,k+1,pos) );\n\tnoiseVals[3] = dot( Gradient(i,j,k+1),     PositionVector(i,j,k+1,pos) );\n\tnoiseVals[4] = dot( Gradient(i,j+1,k),     PositionVector(i,j+1,k,pos) );\n\tnoiseVals[5] = dot( Gradient(i+1,j+1,k),   PositionVector(i+1,j+1,k,pos) );\n\tnoiseVals[6] = dot( Gradient(i+1,j+1,k+1), PositionVector(i+1,j+1,k+1,pos) );\n\tnoiseVals[7] = dot( Gradient(i,j+1,k+1),   PositionVector(i,j+1,k+1,pos) );\n\t// now do the interpolation\n\n\t// interpolation parameters tx, ty, tz\n\tvec3 t = pos - vec3(i,j,k);\n\n\tfloat ft, fb;\n\tfloat fy0, fy1;\n\t// bottom xz plane\n\tft = Smoothstep( noiseVals[3], noiseVals[2], t.x);\n\tfb = Smoothstep( noiseVals[0], noiseVals[1], t.x);\n\tfy0 = Smoothstep( fb, ft, t.z); \n\t// top xz plane\n\tft = Smoothstep( noiseVals[7], noiseVals[6], t.x);\n\tfb = Smoothstep( noiseVals[4], noiseVals[5], t.x);\n\tfy1 = Smoothstep( fb, ft, t.z); \n\t// y interpolation\n\treturn Smoothstep(fy0, fy1, t.y);\n}\n\nfloat ScaledNoise( vec3 pos, float iScale )\n{\n\treturn (1.0f + PerlinNoise( pos, iScale))*0.5f;\n}\n\nfloat FractalNoise( vec3 pos, float iScale, float mult, int numOctaves)\n{\n    float fac = 1.0f;\n    float noise = PerlinNoise(pos, iScale);\n    for ( int i = 0; i < numOctaves-1; i++ )\n    {\n    \tfac *= mult;\n        iScale *= 2.0;\n        noise += fac*PerlinNoise(pos, iScale);\n    }\n    return noise;\n}\n//----------------------------------------------------------------------------------------------------------------------\n\nconst vec2 points[8] = vec2[8](\n    vec2(0.1, 0.2),\n    vec2(0.9, 0.8),\n    vec2(0.3, 0.3),\n    vec2(0.7, 0.5),\n    vec2(0.8, 0.3),\n    vec2(0.6, 0.6),\n    vec2(0.3, 0.1),\n    vec2(0.4, 0.5)\n);\nconst vec4 colors[8] = vec4[8](\n    vec4(0.5, 0.3, 0.9, 1.0),\n    vec4(0.2, 0.7, 0.2, 1.0),\n    vec4(0.7, 0.5, 0.1, 1.0),\n    vec4(0.8, 0.9, 0.3, 1.0),\n    vec4(0.3, 0.8, 0.7, 1.0),\n    vec4(0.4, 0.1, 0.8, 1.0),\n    vec4(0.6, 0.4, 0.4, 1.0),\n    vec4(0.9, 0.2, 0.7, 1.0)\n);\n\nconst float a[8] = float[8](0.3, 0.2, 0.1, -0.4, -0.3, 0.1, 0.05, 0.4);\nconst float b[8] = float[8](0.2, 0.8, 0.1, 0.7, -0.2, -0.5, 0.9, -0.6);\nconst float c[8] = float[8](2.0, 3.0, 6.0, 3.0, 1.0, 3.0, 1.0, 1.0 );\n\nvec4 hsv2rgb(vec3 c) \n{\n    vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0.,4.,2.),6.)-3.)-1.,0.,1.);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    vec3 color = c.z * mix(vec3(1.0), rgb, c.y);\n    return vec4(color,1);\n}\n\nvec4 GetColor(in int i)\n{\n\tfloat noise0 = 0.5*(1.0 + PerlinNoise(vec3(points[i], iTime*0.01), 5.0));\n    float noise1 = 0.5*(1.0 + PerlinNoise(vec3(points[i], iTime*0.01+1000.0), 5.0));\n    vec3 hsv = vec3(noise0, 0.7+0.3*noise1, 1.0);\n    return hsv2rgb(hsv);\n}\n\nvec2 GetPoint(in int i) //elliptical orbit\n{\n    // move the points on orbits\n    float x = points[i].x + a[i]*sin(c[i]*iTime*0.1);    \n    float y = points[i].y + b[i]*sin(c[i]*iTime*0.1); \n  \treturn vec2(x,y);\n}\n\nvec4 GetVoronoiColor( in vec2 point ) //loops through points, finds nearest color assosiated\n{\n    float nearDistSq = 1e20;\n    vec4 color;\n    vec2 offset;\n    offset.x = 0.5*FractalNoise(vec3(point, iTime*0.2), 2.0, 0.5, 3);\n    offset.y = 0.5*FractalNoise(vec3(point, iTime*0.2 + 100.0), 2.0, 0.5, 3);\n\n    for ( int i = 0; i < 8; i++ )\n    {\n        vec2 diff = point+offset-GetPoint(i);\n        float d2 = dot(diff,diff);\n        if ( d2 < nearDistSq )\n        {\n            nearDistSq = d2;\n            color = GetColor(i);\n        }\n    }\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\tfragColor = GetVoronoiColor(uv);\n}","name":"Image","description":"","type":"image"}]}