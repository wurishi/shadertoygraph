{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//http://www.matrix67.com/blog/archives/506\n\n\n#define M_PI 3.141592653\n#define M_EPSILON 0.005\n#define K_MACRO_STEP 48\n#define K_MICRO_STEP 16\n\n\nmat3 AddRotateX(in mat3 m,in float angle)\n{\n\tfloat cosa = cos(angle);\n\tfloat sina = sin(angle);\n\tmat3 mr = mat3(1.0,  0.0,  0.0,\n\t\t\t\t   0.0,  cosa, sina,\n\t\t\t\t   0.0,  -sina,cosa);\n\treturn m * mr;\n}\nmat3 AddRotateY(in mat3 m,in float angle)\n{\n\tfloat cosa = cos(angle);\n\tfloat sina = sin(angle);\n\tmat3 mr = mat3(cosa,  0.0, sina,\n\t\t\t\t   0.0,   1.0, 0.0,\n\t\t\t\t   -sina, 0.0, cosa);\n\treturn m * mr;\n}\nmat3 AddRotateZ(in mat3 m, in float angle)\n{\n\tfloat cosa = cos(angle);\n\tfloat sina = sin(angle);\n\tmat3 mr = mat3(cosa, sina, 0.0,\n\t\t\t\t   -sina,cosa, 0.0,\n\t\t\t\t   0.0,  0.0,  1.0);\n\treturn m * mr;\n}\n\nmat3 Euler2Matrix(in vec3 euler)//y:heading, x:pitch, z:bank\n{\n\tmat3 m = mat3(1.0,0.0,0.0,\n\t\t   0.0,1.0,0.0,\n\t\t   0.0,0.0,1.0);\n\treturn AddRotateZ(AddRotateX(AddRotateY(m, euler.y), euler.x), euler.z);\n}\n\nvec2 DoRotate(in vec2 pos, in float angle)\n{\n\tfloat cosa = cos(angle);\n\tfloat sina = sin(angle);\n\treturn vec2(pos.x*cosa - pos.y*sina, pos.x*sina + pos.y*cosa);\n}\n\nstruct STransform\n{\n\tvec3 m_off;\n\tvec3 m_euler;\n\tfloat m_scale;\n};\n\nvec3 Transform(in vec3 xyz, in STransform trans)\n{\n\tmat3 r = Euler2Matrix(trans.m_euler);\n\treturn r * xyz * trans.m_scale + trans.m_off; \n}\nvec3 InvTransform(in vec3 xyz, in STransform trans)\n{\n\tvec3 re = xyz - trans.m_off;\n\tmat3 r = Euler2Matrix(-trans.m_euler);\n\treturn r * re / trans.m_scale; \n}\n\nstruct Material\n{\n\tvec4 m_diffuse;\n\tfloat m_specular_pow;\n\tfloat m_edge_pow;\n};\n\nfloat HitStar(in vec3 p)\n{\n    float v1 = p.x*p.x*p.y*p.y + p.y*p.y*p.z*p.z + p.x*p.x*p.z*p.z;\n\tfloat v2 = (p.x*p.x + p.y*p.y + p.z*p.z - 1.0);\n    float re = v1 + 0.02 * v2*v2*v2;\n\t\n\tif( re < 0.0)\n\t\treturn -re;\n\treturn -1.0;\n}\n\nbool Hit(in vec3 p, in vec3 pre_p, inout vec3 hit_pos)\n{\n\t\t\n\t\t//float mod_timex = mod(iTime,M_PI*2.0);\n\t\tfloat mod_timey = mod(iTime,M_PI*2.0);\n\t\t\n\t\t//world inv trans\n\t\tSTransform trans = STransform(vec3(0, 0, 1.0), vec3(0.0, mod_timey, 0.0), 1.0/*sin(iTime*4.0)*/ );\n\t\tvec3 pos1 = InvTransform(p, trans);\n\t\n\t\tfloat re1 = HitStar(pos1);\n\t\tif (re1>=0.0)\n\t\t{\n\t\t\tvec3 pre_pos = InvTransform(pre_p, trans);\n\t\t\tvec3 pos2 = pre_pos;\n\t\t\tvec3 delta2 = (pos1-pre_pos) /float(K_MICRO_STEP);\n\t\t\n\t\t\tfor (int ii=0; ii<K_MICRO_STEP; ++ii)\n\t\t\t{\n\t\t\t\tfloat re2 = HitStar(pos2);\n\t\t\t\tif (re2 >= 0.0)\n\t\t\t\t{\n\t\t\t\t\thit_pos = (pos2 * re1 - pos1 * re2)/(re1-re2);//exact value by linear estimate method......\n\t\t\t\t\thit_pos = Transform(hit_pos, trans);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpos2+=delta2;\n\t\t\t}\n\t\t}\n\treturn false;\n}\n\nvec3 GetNormal(in vec3 hit_pos, in float delta)\n{\n\tvec3 pre_p = hit_pos - vec3(0,0,delta);\n\tvec3 p = hit_pos + vec3(0,0,delta);\n\t\n\tvec3 t, l, r, b;\n\tt = l = r = b =  hit_pos + vec3(0.0,0.0, 10000.0);//hit very far away\n\tvec3 eps = vec3(M_EPSILON, 0.0, 0.0);\n\tt += eps.yxy;\n\tl -= eps.xyy;\n\tr += eps.xyy;\n\tb -= eps.yxy;\n\t\n\tHit(p + eps.yxy , pre_p + eps.yxy, t);\n\tHit(p -eps.xyy , pre_p -eps.xyy, l);\n\tHit(p + eps.xyy , pre_p + eps.xyy, r);\n\tHit(p -eps.yxy , pre_p -eps.yxy, b);\n\n\treturn normalize(cross(r-l, t-b));\n}\n\nbool RayMarching(in vec2 screen_pos, in float near, in float far, out vec3 hit_pos, out float cal_delta)\n{\n\tconst float delta = 1.0/float(K_MACRO_STEP);\n\t\n\tfloat z_param1 = far-near;\n\tfloat z_param2 = near/z_param1;\n\t\n\tfor (int i=0;i<K_MACRO_STEP; ++i)\n\t{\n\t\tvec3 pos = vec3(screen_pos, float(i)*delta);\n\t\t//ortho inv trans\n\t\tpos.z += z_param2;\n\t\tpos.z *= z_param1;\n\t\t\n\t\t//view inv trans\n\t\t//pass\n\t\t\n\t\tvec3 pre_pos = vec3(pos.xy, pos.z - delta * z_param1);\n\t\t\n\t\tvec3 re = pre_pos;\n\t\tif( Hit(pos, pre_pos, re))\n\t\t{\n\t\t\thit_pos = re;\n\t\t\tcal_delta = delta*z_param1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//view port inv transform\n\tvec2 pos = (fragCoord.xy -iResolution.xy*0.5) / iResolution.xy * 2.0;\n\t\n\tvec3 hit_p = vec3(0.0,0.0,0.0);\n\tfloat delta = 1.0;\n\tbool re = RayMarching(pos, 0.0, 1.3, hit_p, delta);\n\tif (re)\n\t{\n\t\tvec3 nor = GetNormal(hit_p, delta);\n\t\tfloat mod_timey = mod(iTime*3.0,M_PI*2.0);\n\t\tvec3 light = vec3(sin(mod_timey),cos(mod_timey*4.0),0.2);\n\t\tfloat reflez= reflect(light - hit_p, nor).z;\n\t\treflez = pow(reflez, 5.0)*0.7;\n\t\tfragColor = vec4(1.0-nor.y + reflez, 1.0-nor.z + reflez, 1.0-nor.x + reflez, 1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(0.0,0.0,0.0,1.0);\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xs2XDd","date":"1417355346","viewed":214,"name":"star 3d by equation","username":"jedi_cy","description":"ray marching star 3d by equationï¼š http://www.matrix67.com/blog/archives/506","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","star","equation"],"hasliked":0,"parentid":"","parentname":""}}