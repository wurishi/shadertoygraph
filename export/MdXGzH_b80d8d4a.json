{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define time iTime\n#define resolution (iResolution.xy)\n#define mouse (iMouse.xy)\n#define seconds (iDate.w)\n#define minutes (seconds/60.0)\n#define hours (minutes/60.0)\n\n\nconst vec3 light = vec3(5.5, 10.0, 5.5);\n\nconst int raytraceDepth = 5;\nconst float attenuation = 0.5;\nconst float max_cube_size = 1.0;\nconst float todeg = 3.14159265358 / 180.0;\n\nstruct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 c;\n    float r;\n    vec4 col;\n};\n\nstruct Plane\n{\n    vec3 p;\n    vec3 n;\n    vec4 col1, col2;\n};\n\n\nstruct Cube\n{\n    vec3 c;\n    vec3 h_side;\n    vec4 col;\n};\n\nstruct Intersection\n{\n    float t;\n    vec3  p;                    // hit point\n    vec3  n;                    // normal\n    int   hit;\n    vec4  col;\n};\n\nvec3 random(vec3 p)\n{\n    return fract(1e4*sin(vec3(1e3, 2.2223e3, 3.117e3) *\n                         (p + 2.1*p.yzx + 3.2*p.zxy)));\n}\n\nvoid sphere_intersect(Sphere s,  Ray ray, inout Intersection isect)\n{\n    // rs = ray.org - sphere.c\n    vec3 rs = ray.org - s.c;\n    float B = dot(rs, ray.dir);\n    float C = dot(rs, rs) - (s.r * s.r);\n    float D = B * B - C;\n\n    if (D > 0.0)\n    {\n        float t = -B - sqrt(D);\n        if (t > 0.0 && t < isect.t)\n        {\n            isect.t = t;\n            isect.hit = 1;\n\n            // calculate normal.\n            vec3 p = vec3(ray.org.x + ray.dir.x * t,\n                          ray.org.y + ray.dir.y * t,\n                          ray.org.z + ray.dir.z * t);\n            vec3 n = p - s.c;\n            n = normalize(n);\n            isect.n = n;\n            isect.p = p;\n            isect.col = s.col;\n        }\n    }\n}\n\nfloat dpmod(float x) { return mod(x, 1.0) - 0.5; }\n\nvoid plane_intersect(Plane pl, Ray ray, inout Intersection isect)\n{\n    float d = -dot(pl.p, pl.n);\n    float v = dot(ray.dir, pl.n);\n\n\n    // Check if the plane is parallel to the ray.\n    if (abs(v) < 1.0e-6)\n        return;\n\n    float t = -(dot(ray.org, pl.n) + d) / v;\n\n    if ( (t > 0.0) && (t < isect.t) )\n    {\n        isect.hit = 1;\n        isect.t   = t;\n        isect.n   = pl.n;\n\n        vec3 p = vec3(ray.org.x + t * ray.dir.x,\n                      ray.org.y + t * ray.dir.y,\n                      ray.org.z + t * ray.dir.z);\n        isect.p = p;\n        float offset = 0.2;\n        vec3 dp = p + offset;\n\n        if (dpmod(dp.x) * dpmod(dp.y) * dpmod(dp.z) < 0.0)\n            isect.col = pl.col1;\n        else\n            isect.col = pl.col2;\n    }\n}\n\n\nvoid cube_intersect(Cube c,  Ray ray, inout Intersection isect)\n{\n    vec3 vertex1 = c.c - c.h_side;\n    vec3 vertex2 = c.c + c.h_side;\n    vec3 ro = ray.org;\n    vec3 rd = ray.dir;\n\n    float t;\n    float tNear = isect.t;\n    vec3 normal = vec3(1);\n    vec3 interp = ro;\n\n#define CHECK_CUBE_COORD(A, B, C) if(rd.A == 0.0) { if(ro.A < vertex1.A || ro.A > vertex2.A) return; } else { if (rd.A > 0.0) t = (vertex1.A - ro.A) / rd.A; else t = (vertex2.A - ro.A) / rd.A; if(t >= 0.0 && t < tNear) { vec3 ip = ro + rd * t; if (ip.B >= vertex1.B && ip.B <= vertex2.B && ip.C >= vertex1.C && ip.C <= vertex2.C) { tNear = t; normal.A = -sign(rd.A); normal.B = 0.0; normal.C = 0.0; interp = ip; } } } \n\n    CHECK_CUBE_COORD(x, y, z);\n    CHECK_CUBE_COORD(y, x, z);\n    CHECK_CUBE_COORD(z, x, y);\n\n    t = tNear;\n    if (t > 0.0 && t < isect.t)\n    {\n        isect.t = t;\n        isect.hit = 1;\n        isect.p = interp;\n        isect.col = c.col;\n        isect.n = normal;\n    }\n}\n\t\t\n\nvoid cube_compute(vec3 iip, out Cube cu)\n{\n    cu.c = iip + (0.1 * random(1.113 * iip) - 0.05);\n    cu.h_side = vec3(0.08) + 0.05 * random(2.117*iip).z;\n    vec3 col = vec3(0.1, 0.6, 0.2)*random(0.997*iip) + vec3(0.6, 1.4, 1.9);\n    cu.col = vec4(col, 4.4);\n}\n\nvoid cubes_intersect(float z, Ray ray, inout Intersection isect)\n{\n    ray.org.x += time;\n    vec3 ro = ray.org;\n    vec3 rd = ray.dir;\n    float t0 = isect.t;\n\n    // Compute intersection with plane at z\n    if (abs(rd.z) < 1e-5)\n        return;\n    float t = (z - ro.z)/rd.z;\n    if (t < 0.0 || t >= t0)\n        return;\n\n    // Find the cube for that intersection\n    vec3 ip = ro + t * rd;\n    vec3 iip = floor(5.0 * ip + 0.5) * 0.2;\n    if (abs(iip.y - 2.0) > 2.0)\n        return;\n\n    // Check cube at given z.\n    Cube cu;\n    cube_compute(iip, cu);\n    cube_intersect(cu, ray, isect);\n    if (isect.t < t0)\n        isect.p.x -= time;\n}\n\n\nSphere sphere[4];\nCube cube[1];\nPlane plane[2];\n\nvoid Intersect(Ray r, inout Intersection i)\n{\n    sphere_intersect(sphere[0], r, i);\n    sphere_intersect(sphere[1], r, i);\n    sphere_intersect(sphere[2], r, i);\n    sphere_intersect(sphere[3], r, i);\n\n    cube_intersect(cube[0], r, i);\n\n    plane_intersect(plane[0], r, i);\n\n    cubes_intersect(0.0, r, i);\n}\n\nvec4 computeLightShadow(in Intersection isect)\n{\n    int i, j;\n    int ntheta = 16;\n    int nphi   = 16;\n    float eps  = 0.001;\n\n    // Slightly move ray org towards ray dir to avoid numerical problem.\n    vec3 p = vec3(isect.p.x + eps * isect.n.x,\n                  isect.p.y + eps * isect.n.y,\n                  isect.p.z + eps * isect.n.z);\n    vec4 result;\n\n    Ray ray;\n    ray.org = p;\n    ray.dir = normalize(light - p);\n\n    Intersection lisect;\n    lisect.hit = 0;\n    lisect.t = 1e30;\n    lisect.n = lisect.p = vec3(0);\n    lisect.col = vec4(0);\n    Intersect(ray, lisect);\n    if (lisect.hit != 0)\n    {\n        result = vec4(0.1, 0.1, 0.1, 10.0);\n    }\n    else\n    {\n        float shade = max(0.0, dot(isect.n, ray.dir));\n        shade = pow(shade,2.0) + shade * 0.5;\n        result = vec4(shade, shade, shade, 0);\n    }\n\n#if 0\n\t// Second light\n    ray.dir = normalize(light2 - p);\n    lisect.hit = 0;\n    lisect.t = 1e30;\n    lisect.n = lisect.p = vec3(0);\n    lisect.col = vec4(0);\n    Intersect(ray, lisect);\n    if (lisect.hit != 0)\n    {\n        result += vec4(0.1, 0.1, 0.1, 10.0);\n    }\n    else\n    {\n        float shade = max(0.0, dot(isect.n, ray.dir));\n        shade = pow(shade,2.0) + shade * 0.5;\n        result += vec4(shade, shade, shade, 0);\n    }\n#endif\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = fragCoord.xy / resolution.xy - 0.5;\n    position.x *= resolution.x / resolution.y;\n\tfloat angle = mouse.x * 0.1 - 30.1;\n    float radius = 20.5 - 0.05 * mouse.y;\n\n    float ss = sin(angle * todeg);\n    float cc = cos(angle * todeg);\n    vec3 org = vec3(ss*radius,2.0,cc*radius);\n    vec3 dir = normalize(vec3(position.x*cc-ss,position.y, -position.x*ss-cc));\n\n    vec3 center = vec3(-1.0, sin(0.1*time)*1.0+1.5, 2.75);\n    sphere[0].c   = center;\n    sphere[0].r   = 0.5;\n    sphere[0].col = vec4(1,0.5,0.3, 0.5);\n\n    const float sixtieth = 1.0 / 60.0;\n    const float secminfac = 2.0 * 3.1415965358 * sixtieth;\n    const float hourfac = secminfac * 5.0;\n\n    float seca = seconds * secminfac;\n    sphere[1].c   = center + 0.6 * vec3(sin(seca), cos(seca), 1.0);\n    sphere[1].r   = 0.2;\n    sphere[1].col = vec4(0.3,1,0.3, 2.5);\n\n    float mina = minutes * secminfac;\n    sphere[2].c   = center + 0.7 * vec3(sin(mina), cos(mina), 0.0);\n    sphere[2].r   = 0.3;\n    sphere[2].col = vec4(0.43,0.3,1, 0.0);\n\n    float hrsa = hours * hourfac;\n    sphere[3].c   = center + 0.5 * vec3(sin(hrsa), cos(hrsa), 0.5);\n    sphere[3].r   = 0.2;\n    sphere[3].col = vec4(0.8,0.0,0.0, 0.1);\n\n    cube[0].c = vec3(-1.0, 0.5, 1.5);\n    cube[0].h_side = vec3(0.5, 3.0, 1.0);\n    cube[0].col = vec4(1.0, 0.8, 0.7, 3.1);\n\n    plane[0].p = vec3(0,-0.5, 0);\n    plane[0].n = vec3(0, 1.0, 0);\n    plane[0].col1 = vec4(0.6,0.8,1, 0.0);\n    plane[0].col2 = vec4(0.0,0.0,0.3, 0.5);\n\n    plane[1].p = vec3(0,0, -2.5);\n    plane[1].n = vec3(0.0, 0, 1.0);\n    plane[1].col1 = vec4(0,0,0.3, 0.0);\n    plane[1].col2 = vec4(0.0,0.3,0.0, 0.0);\n\n    Ray r;\n    r.org = org;\n    r.dir = dir;\n    vec4 col = vec4(0,0,0,1);\n    float eps  = 0.0001;\n    vec4 bcol = vec4(1,1,1,1);\n    for (int j = 0; j < raytraceDepth; j++)\n    {\n        Intersection i;\n        i.hit = 0;\n        i.t = 1e30;\n        i.n = i.p = vec3(0);\n        i.col = vec4(0);\n\n        Intersect(r, i);\n        if (i.hit != 0)\n        {\n            vec4 shadow = computeLightShadow(i);\n            col += bcol * i.col * shadow;\n            bcol *= i.col / (1.0 + i.col.a * i.t + shadow.a);\n        }\n        else\n        {\n            if (j == 0)\n                discard;\n            break;\n        }\n\n        r.org = vec3(i.p.x + eps * i.n.x,\n                     i.p.y + eps * i.n.y,\n                     i.p.z + eps * i.n.z);\n        r.dir = reflect(r.dir, vec3(i.n.x, i.n.y, i.n.z));\n    }\n    col.a = 1.0;\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdXGzH","date":"1362347134","viewed":626,"name":"Blue Wall Clock Raytrace","username":"c3d","description":"A clock made of three spheres in front of a continuously moving wall of blue bricks of all sizes. You can also see this shader in stereoscopic mode at http://www.taodyne.com/shop/en/blog/67-real-time-stereoscopic-raytracing.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","clock","infinitewall"],"hasliked":0,"parentid":"","parentname":""}}