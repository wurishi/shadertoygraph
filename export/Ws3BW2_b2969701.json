{"ver":"0.1","info":{"id":"Ws3BW2","date":"1605966186","viewed":126,"name":"black triangles water","username":"Felics","description":"black triangles water\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["watertriangles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define float3 vec3\n#define float2 vec2\n#define frac fract\n#define fmod mod\n#define lerp mix\n\n#define Hash(p) (frac(sin(dot((p), float2(127.1,311.7))) * 43758.5453123))\n#define HeightU(p) (frac((p)) * frac((p)) * (3.0 - 2.0 * frac((p))))\n#define Height(p, time) (frac(-1.0 + 2.0 * lerp(lerp(Hash(floor((p)) + float2(0.0, 0.0)), Hash(floor((p)) + float2(1.0, 0.0)), HeightU(p).x), lerp(Hash(floor((p)) + float2(0.0, 1.0)), Hash(floor((p)) + float2(1.0, 1.0)), HeightU(p).x), HeightU(p).y)) + sin((p).x * 2.0 + (time)) * 0.25)\n#define Intersection(p, p0, p1, p2) (dot((p) - (p0), normalize(cross((p0) - (p1), (p0) - (p2)))))\n#define Distance(p, time) (min(max(Intersection(float3(fmod((p).xy, 1.0), (p).z), float3(0, 0, 0), float3(1.0, 1.0, 0), float3(0, 0, 1.0)), Intersection(float3(fmod((p).xy, 1.0), (p).z), float3(0, 0, -Height(floor((p).xy) + float2(0, 0), (time))), float3(0, 1.0, -Height(floor((p).xy) + float2(0, 1), (time))), float3(1.0, 1.0, -Height(floor((p).xy) + float2(1, 1), (time))))), max(-Intersection(float3(fmod((p).xy, 1.0), (p).z), float3(0, 0, 0), float3(1.0, 1.0, 0), float3(0, 0, 1.0)), Intersection(float3(fmod((p).xy, 1.0), (p).z), float3(0, 0, -Height(floor((p).xy) + float2(0, 0), (time))), float3(1.0, 1.0, -Height(floor((p).xy) + float2(1, 1), (time))), float3(1.0, 0, -Height(floor((p).xy) + float2(1, 0), (time)))))))\n\nfloat3 Color(float3 worldPosition, float time)\n{\n    worldPosition *= 0.005;\n    float x = frac(worldPosition.x);\n    float y = frac(worldPosition.y);\n\n    float3 origin = float3(x, y, -16.0);\n    float3 direction = normalize(float3(x, y, 0.5));\n\n    float dist = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        float sceneDist = Distance(origin + direction * dist, time);\n        dist += sceneDist * 0.5;\n\n        if(abs(sceneDist) <  0.0001)\n        {\n            break;\n        }\n    }\n\n    float3 p = origin + direction * dist;\n    float3 off = float3(0.002, 0, 0);\n    float3 normal = normalize\n    ( \n        float3\n        (\n            Distance(p + off.xyz, time) - Distance(p - off.xyz, time),\n            Distance(p + off.zxy, time) - Distance(p - off.zxy, time),\n            Distance(p + off.yzx, time) - Distance(p - off.yzx, time)\n        )\n    );\n\n    float color = 0.15 * -dot(normal, direction);\n    return float3(color, color, color);\n}\n\nvoid mainImage( out vec4 fragColor, in float2 fragCoord )\n{\n    float2 uv = fragCoord.xy / iResolution.y;\n    float3 worldPosition = float3(uv, 0.0) * 100.0 - vec3(500.0, 500.0, 0.0);\n    \n    fragColor = vec4(Color(worldPosition, iTime), 1.0);\n}","name":"Image","description":"","type":"image"}]}