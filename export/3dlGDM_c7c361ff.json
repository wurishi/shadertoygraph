{"ver":"0.1","info":{"id":"3dlGDM","date":"1546520305","viewed":884,"name":"Motion Vectors Visualization","username":"boksajak","description":"A quick way for visualizing motion vectors as a post-processing pass (a full-screen quad).\n1. For each pixel within a n x n block, load motion vector in its center\n2. Draw black or white based on distance of current pixel to line denoting a motion vector ","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["motion","debug","vectors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INVALID_UVS vec2(-10.0f, -10.0f)\n\nfloat distanceFromLineSegment(vec2 p, vec2 start, vec2 end) {\n    float len = length(start - end);\n\tfloat l2 = len * len; \n\tif (l2 == 0.0f) return length(p - start);   \n\tfloat t = max(0.0f, min(1.0f, dot(p - start, end - start) / l2));\n\tvec2 projection = start + t * (end - start);\n\treturn length(p - projection);\n}\n\nvec2 getPreviousFrameUVs(vec2 pos) {\n    \n    // TODO: Load your motion vector here and figure\n    // out the screen coordinates (UV) of this pixel\n    // in previous frame (in <0, 1> range).\n    // Often, just add motion vector to the \"pos\" variable \n    \n    // We just return some random time varying numbers for this example\n    return 0.5 + 0.5*cos(iTime+pos/iResolution.xy);\n}\n\nvec3 visualizeMotionVectors(vec2 pos)\n{\n\tfloat lineThickness = 1.0f;\n\tfloat blockSize = 32.0f;\n\n\t// Divide the frame into blocks of \"blockSize x blockSize\" pixels\n    // and get the screen coordinates of the pixel in the center of closest block\n\tvec2 currentCenterPos = floor(pos / blockSize) * blockSize + (blockSize * 0.5f);\n\n\t// Load motion vector for pixel in the center of the block\n    vec2 previousCenterPos01 = getPreviousFrameUVs(currentCenterPos);\n    vec2 previousCenterPos = previousCenterPos01 * iResolution.xy;\n\n\t// Reject invalid motion vector (e.g. for failed reprojection, indicated by INVALID_UVS value)\n    bool rejectReprojection = (previousCenterPos01.x == INVALID_UVS.x && previousCenterPos01.y == INVALID_UVS.y);\n    if (rejectReprojection) previousCenterPos = currentCenterPos;\n\n\t// Get distance of this pixel from motion vector line on the screen\n\tfloat lineDistance = distanceFromLineSegment(pos, currentCenterPos, previousCenterPos);\n\n\t// Draw line based on distance\n\treturn (lineDistance < lineThickness) \n        ? vec3(1.0f, 1.0f, 1.0f) \n        : vec3(0.0f, 0.0f, 0.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // TODO: depth is not needed for motion vectors vizualization, but I recommend \n    // adding a linearized depth in <0;1> range to the result to show the geometry currently in frame\n\tfloat depth = 0.0f;\n    \n    fragColor = vec4(depth + visualizeMotionVectors(fragCoord), 1.0f);\n}\n","name":"Image","description":"","type":"image"}]}