{"ver":"0.1","info":{"id":"Xfc3Dr","date":"1711548720","viewed":40,"name":"OKLab Slicing","username":"Skelly","description":"Mouse y level = slice L level","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gamut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define anim_speed .1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float my;\n    if (iMouse.y == 0.)\n    {\n        float t = .15 + iTime*anim_speed;\n        t = fract(fract(t) * sign(fract(t/2.) - .5));\n        my = t;\n    }\n    else\n    {\n        my = iMouse.y/iResolution.y;\n    }\n    \n    vec3 col = oklab2rgb( vec3( my, (1. - 2.*uv)/3. ));\n\n    bool in_range = min(col.r, min(col.g, col.b)) >= 0. && max(col.r, max(col.g, col.b)) <= 1.;\n\n    fragColor = in_range? vec4(col, 1.) : vec4(.12, .12, .12, 0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://bottosson.github.io/posts/oklab/\n\n#define TAU 6.28318530718\n\nmat3 m1 = mat3(+0.4122214708, +0.5363325363, +0.0514459929,\n               +0.2119034982, +0.6806995451, +0.1073969566,\n               +0.0883024619, +0.2817188376, +0.6299787005);\n\nmat3 inverse_m1 = mat3(+4.0767416621, -3.3077115913, +0.2309699292,\n                       -1.2684380046, +2.6097574011, -0.3413193965,\n                       -0.0041960863, -0.7034186147, +1.7076147010);\n\nmat3 m2 = mat3(+0.2104542553, +0.7936177850, -0.0040720468,\n               +1.9779984951, -2.4285922050, +0.4505937099,\n               +0.0259040371, +0.7827717662, -0.8086757660);\n\nmat3 inverse_m2 = mat3(1., +0.3963377774, +0.2158037573,\n                       1., -0.1055613458, -0.0638541728,\n                       1., -0.0894841775, -1.2914855480);\n\nfloat cbrt( float x ) // https://www.shadertoy.com/view/wts3RX (needed for negative cube roots)\n{\n\tfloat y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n\n\tfor( int i = 0; i < 1; ++i )\n    \ty = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < 1; ++i )\n    {\n    \tfloat y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    \n    return y;\n}\n\nvec3 cbrt( vec3 xyz )\n{\n    return vec3(cbrt(xyz.x), cbrt(xyz.y), cbrt(xyz.z));\n}\n\nvec3 rgb2oklab(vec3 rgb)\n{\n    return cbrt(rgb * m1)*m2;\n}\n\nvec3 oklab2rgb(vec3 oklab)\n{\n    return pow(oklab * inverse_m2, vec3(3.)) * inverse_m1;\n}\n\nvec3 oklab2oklch(vec3 oklab)\n{\n    return vec3(oklab.x,\n    sqrt(oklab.y * oklab.y + oklab.z * oklab.z),\n    atan(oklab.z, oklab.y)/TAU);\n}\n\nvec3 oklch2oklab(vec3 oklch)\n{\n    return vec3(oklch.x,\n    oklch.y * cos(oklch.z*TAU),\n    oklch.y * sin(oklch.z*TAU));\n}\n\nvec3 rgb2oklch(vec3 rgb) { return oklab2oklch(rgb2oklab(rgb)); }\nvec3 oklch2rgb(vec3 oklch) { return oklab2rgb(oklch2oklab(oklch)); }","name":"Common","description":"","type":"common"}]}