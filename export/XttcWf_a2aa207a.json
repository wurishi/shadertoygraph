{"ver":"0.1","info":{"id":"XttcWf","date":"1614397565","viewed":368,"name":"Cube Island","username":"mhnewman","description":"Island scene using same render engine as [url=http://www.shadertoy.com/view/llccD2]Brute Force Accumulation[/url]\n\nCloud transparency through probabilistic transmission.","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["cloud","cube","voxel","transparent","island","mountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Brute force ambient occlusion, depth of field, spherical aberration,\n// and anti aliasing using accumulation buffer.\n//\n// Based on www.shadertoy.com/view/llccD2 Brute Force Accumulation.\n// Create your scene by filling in setCamera(), voxelHit(), and voxelColor().\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = pow(1.0 - pow(1.0 - texture(iChannel0, fragCoord / iResolution.xy), vec4(2.0)), vec4(1.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Island height map\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = floor(fragCoord - 0.5 * iResolution.xy);\n    float r = length(pos);\n    float h = fbm1(0.07 * pos.xy) - 0.0004 * r * r + 0.3;\n    h = 10.0 * (exp(0.7 * h) - 1.0);\n    \n    float cloud = 10.0 + 10.0 * fbm1(0.08 * pos.xy + 7.5);\n    fragColor = vec4(max(h, 0.0), h, cloud, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Brute force ambient occlusion, depth of field, spherical aberration,\n// and anti aliasing using accumulation buffer.\n//\n// Based on www.shadertoy.com/view/llccD2 Brute Force Accumulation.\n// Create your scene by filling in setCamera(), voxelHit(), and voxelColor().\n\nconst float sphericalAberration = 0.1;\nconst float vignetting = 0.5;\nconst vec3 backgroundColor = vec3(0.0);\nconst int maxIter = 300;\n\n// Set Camera will position and aim the camera.\n//   eye := The location of the camera.\n//   center := The location at which the camera is looking.\n//   focalDist := Center of focus\n//   blurAmount := Amount of depth of field\n//   Return value := Camera focal length.\nfloat setCamera(out vec3 eye, out vec3 center, out float focalDist, out float blurAmount) {\n    focalDist = 133.0;\n    blurAmount = 0.022;    \n    \n    vec2 m = vec2(0.2, 0.7);\n    m *= 6.283185 * vec2(1.0, 0.25);    \n    float dist = 140.0;\n    center = vec3(0.0, 0.0, 0.0);\n    eye = center + vec3(dist * sin(m.x) * sin(m.y), dist * cos(m.x) * sin(m.y), dist * cos(m.y));\n    return 6.0;\n}\n\n// Voxel Hit returns true if the voxel at pos should be filled.\nbool voxelHit(vec3 pos, float time) {\n    vec4 height = texture(iChannel0, (pos.xy + 0.5) / iResolution.xy + 0.5);\n    return pos.z < height.x ||\n           (pos.z > 10.0 && pos.z < height.z && hash1(vec4(pos, time)) < 0.2);\n}\n\n// Voxel Color returns the color at pos with normal vector norm.\nvec3 voxelColor(vec3 pos, vec3 norm) {\n    vec3 p = floor(pos);\n    float h = hash1(p);\n    vec4 height = texture(iChannel0, (p.xy + 0.5) / iResolution.xy + 0.5);\n    vec3 water = mix(vec3(0.5, 0.8, 1.0), vec3(0.0, 0.1, 0.6), pow(clamp(-0.1 * height.y + 0.15 * h, 0.0, 1.0), 0.3));\n    vec3 mountain = mix(vec3(0.3, 0.4, 0.2), vec3(0.5, 0.4, 0.3), h);\n    vec3 grass = mix(vec3(0.4, 0.8, 0.1), vec3(0.0, 0.5, 0.0), h);\n    vec3 sand = mix(vec3(1.0, 1.0, 0.0), vec3(0.7, 0.5, 0.0), h);\n    vec3 cloud = vec3(1.0);\n    vec3 land = mix(sand, grass, step(1.0, p.z));\n    land = mix(land, mountain, step(7.0 + 4.0 * h, p.z));\n    land = mix(water, land, step(0.0, p.z));\n    return mix(land, cloud, step(height.x + 0.5, p.z));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Fill in the functions above.\n// The engine below does not need to be modified.\n////////////////////////////////////////////////////////////////////////////////\n\nfloat castRay(vec3 eye, vec3 ray, float time, out float dist, out vec3 norm) {\n    vec3 pos = floor(eye);\n    vec3 ri = 1.0 / ray;\n    vec3 rs = sign(ray);\n    vec3 ris = ri * rs;\n    vec3 dis = (pos - eye + 0.5 + rs * 0.5) * ri;\n    \n    vec3 dim = vec3(0.0);\n    for (int i = 0; i < maxIter; ++i) {\n        if (pos.z < 0.0 || voxelHit(pos, time)) {\n            dist = dot(dis - ris, dim);\n            norm = -dim * rs;\n            return 1.0;\n        }\n    \n        dim = step(dis, dis.yzx);\n\t\tdim *= (1.0 - dim.zxy);\n        \n        dis += dim * ris;\n        pos += dim * rs;\n    }\n\n    if (ray.z < 0.0) {\n        dist = -eye.z / ray.z;\n        norm = vec3(0.0, 0.0, 1.0);\n        return 1.0;\n    }\n\treturn 0.0;\n}\n\nvec3 pass(vec2 coord, float time) {\n    vec3 eye, center;\n    float focalDist, blurAmount;\n    float zoom = setCamera(eye, center, focalDist, blurAmount);\n    \n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n\n    // Anti aliasing\n    vec2 hash = hash2(vec3(time, coord));\n    vec2 xy = (2.0 * (coord + hash - 0.5) - iResolution.xy) / iResolution.y;\n    \n    // Spherical aberration\n    xy /= cos(sphericalAberration * (1.0 + 0.3 * hash1(vec3(time, coord))) * length(xy));\n    \n    vec3 ray = normalize(xy.x * right + xy.y * up + zoom * forward);\n    \n    // Depth of field    \n    hash = hash2(vec3(time + 0.1, coord));\n    float a = sqrt(hash.x);\n    float b = a * cos(6.283185 * hash.y);\n    float c = a * sin(6.283185 * hash.y);\n\n    vec3 target = eye + ray * focalDist / dot(ray, forward);\n    eye += focalDist * blurAmount * (b * right + c * up);\n    ray = normalize(target - eye);\n    \n    // Cast Ray\n    float dist;\n    vec3 norm;\n    float hit = castRay(eye, ray, time, dist, norm);\n    vec3 pos = eye + dist * ray;\n\n    vec3 color = voxelColor(pos - 0.001 * norm, norm);\n    \n    // Ambient occlusion\n    pos += 0.001 * norm;\n\n    vec3 z = norm;\n    vec3 x = normalize(cross(z, vec3(-0.36, -0.48, 0.8)));\n    vec3 y = normalize(cross(z, x));\n\n    hash = hash2(vec3(time + 0.2, coord));\n    a = sqrt(hash.x);\n    b = a * cos(6.283185 * hash.y);\n    c = a * sin(6.283185 * hash.y);\n    a = sqrt(1.0 - hash.x);\n    vec3 shadeDir = b * x + c * y + a * z;\n    color *= 1.0 - castRay(pos, shadeDir, time, dist, norm);\n    \n    return mix(backgroundColor, color, hit);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    // Restart accumulation on window resize\n    vec3 frame = texture(iChannel1, vec2(0.5) / iResolution.xy).xyz;\n    float resize = step(abs(frame.x - iResolution.x) + abs(frame.y - iResolution.y), 0.5);\n    frame.xy = iResolution.xy;\n    frame.z = mix(1.0, frame.z + 1.0, resize);\n    \n    // Render pass\n\tvec3 color = pass(fragCoord, iTime);\n    \n    // 10 passes on the first frame to render the preview.\n    if (resize < 0.5) {\n        for (int i = 1; i < 10; ++i)\n\t        color += pass(fragCoord, iTime + 0.01 * float(i));\n        color *= 0.1;\n    }\n\n    // Vignetting\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    color *= vignetting * pow((1.0 - uv.x * uv.x) * (1.0 - uv.y * uv.y), 0.2) + 1.0 - vignetting;\n    \n    // Accumulate color\n    vec3 oldColor = texture(iChannel1, fragCoord.xy / iResolution.xy).rgb;\n    vec3 accum = mix(oldColor, color, 1.0 / frame.z);\n    fragColor = vec4(mix(accum, frame, step(fragCoord.x + fragCoord.y, 1.5)), 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash1(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec2 p2) {\n\tp2 = fract(p2 * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash1(vec3 p3) {\n    p3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract(p3.x * p3.y * p3.z);\n}\n\nfloat hash1(vec4 p4) {\n    p4 = fract(p4 * vec4(5.3983, 5.4427, 6.9371, 5.8815));\n    p4 += dot(p4.zwxy, p4.xyzw + vec4(21.5351, 14.3137, 15.3219, 19.6285));\n\treturn fract(p4.x * p4.y + p4.z * p4.w);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(5.3983, 5.4427, 6.9371));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat noise1(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(mix(hash1(i + vec2(0.0, 0.0)), \n                               hash1(i + vec2(1.0, 0.0)), u.x),\n                           mix(hash1(i + vec2(0.0, 1.0)), \n                               hash1(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat fbm1(vec2 p) {\n    float f = noise1(p); p = m * p;\n    f += 0.5 * noise1(p); p = m * p;\n    f += 0.25 * noise1(p); p = m * p;\n    f += 0.125 * noise1(p); p = m * p;\n    f += 0.0625 * noise1(p);\n    return f / 1.9375;\n}","name":"Common","description":"","type":"common"}]}