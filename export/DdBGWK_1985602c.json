{"ver":"0.1","info":{"id":"DdBGWK","date":"1668542078","viewed":77,"name":"Quake Palette experiments 4","username":"ManuKman","description":"Quake palette based color grading LUT","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["blur","palette","quake"],"hasliked":0,"parentid":"4lXXWn","parentname":"Gaussian Blur (Edited)"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = RGBtoSRGB(okhsl_to_linear_srgb(texture(iChannel0,fragCoord/iChannelResolution[0].xy).rgb));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A used to create seeds using thresholding method\n\n// https://www.shadertoy.com/view/MlsyzS\n\n#define TESS .4\n#define ANIMATE\n\nfloat grayScale(vec4 c) { return c.x*.29 + c.y*.58 + c.z*.13; }\n\nvec3 animate() { return vec3(sin(iTime)*.0001, cos(iTime)*.0001, 0); }\n\nvec4 seed(in vec2 uv)\n{\n    vec3 uv_hsl = vec3(uv.x, uv.y, 0.66);\n\n    vec3 c = uv_hsl;\n    vec4 fragColor;\n    \n    float dist_threshold = 0.25;\n    float border_threshold = 0.03;\n\n    float borderfactor = 0.006;\n    float l_factor = 0.00;\n    \n    float w = 0.0;\n    \n    for(int i = 0; i < 256; i++) {\n       vec3 p_hsl = linear_srgb_to_okhsl(SRGBtoRGB(paletteFull[i]));\n       //float dist = length(p_hsl.xy-uv_hsl.xy);\n       float dist = getMatchDistanceW(uv_hsl,p_hsl, vec3(1.0,1.0,l_factor));\n\n        /*\n        if(uv.x < border_threshold || (1.0-uv.x) < border_threshold) {\n            dist = getMatchDistanceW(uv_hsl,p_hsl, vec3(borderfactor,0.9,l_factor));\n        } \n        \n        if(uv.y < border_threshold || (1.0-uv.y) < border_threshold) {\n            dist = getMatchDistanceW(uv_hsl,p_hsl, vec3(0.9,borderfactor,l_factor));\n        } \n        */\n        if((uv.x < border_threshold || (1.0-uv.x) < border_threshold)\n        && (uv.y < border_threshold || (1.0-uv.y) < border_threshold)) {\n            dist = getMatchDistanceW(uv_hsl,p_hsl, vec3(borderfactor*0.1,borderfactor*0.1,l_factor));\n        } \n        \n            \n       // if true, then seed\n       if(dist < dist_threshold) {\n           c = p_hsl;\n           w = 1.0;\n       }\n\n    }\n    \n   if(uv.x < border_threshold || (1.0-uv.x) < border_threshold || uv.y < border_threshold || (1.0-uv.y) < border_threshold) \n   {\n       float grid_threshold = 0.4;\n        vec2 grid = fract((uv*16.0)+grid_threshold*0.5);\n        if(grid.x<grid_threshold && grid.y<grid_threshold) \n        {\n            c = oklab_to_okhsl(getPaletteMatchLABSimpleCore(okhsl_to_oklab(uv_hsl), vec3(1.0,0.4,l_factor)));\n            w = 1.0;\n        }\n\n    }\n    \n    c = vec3(c.x, uv_hsl.y*0.5 + c.y*0.5, uv_hsl.z*0.5 + c.z*0.5);\n    \n\n    fragColor.xyz = c*w;\n    fragColor.w = w;\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    fragColor = seed(uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float EPSILON = 1e-10;\n\n#define ROUNDS 40.\n\n// sRGB color transform and inverse from \n// https://bottosson.github.io/posts/colorwrong/#what-can-we-do%3F\n\nvec3 linear_srgb_from_srgb(vec3 x) {\n\n    vec3 xlo = x / 12.92;\n    vec3 xhi = pow((x + 0.055)/(1.055), vec3(2.4));\n    \n    return mix(xlo, xhi, step(vec3(0.04045), x));\n\n}\n\n\nvec3 srgb_from_linear_srgb(vec3 x) {\n\n    vec3 xlo = 12.92*x;\n    vec3 xhi = 1.055 * pow(x, vec3(0.4166666666666667)) - 0.055;\n    \n    return mix(xlo, xhi, step(vec3(0.0031308), x));\n\n}\n\n\n\nvec3 SRGBtoRGB(vec3 srgb) {\n    // See http://chilliant.blogspot.co.uk/2012/08/srgb-approximations-for-hlsl.html\n    // This is a better approximation than the common \"pow(rgb, 2.2)\"\n    // return pow(srgb, vec3(2.1632601288));\n    return linear_srgb_from_srgb(srgb);\n}\n\nvec3 RGBtoSRGB(vec3 rgb) {\n    // This is a better approximation than the common \"pow(rgb, 0.45454545)\"\n    // return pow(rgb, vec3(0.46226525728));\n    return srgb_from_linear_srgb(rgb);\n}\n\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Chroma-Value [0..1]\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 HSVtoRGB(in vec3 hsv)\n{\n    // Hue-Saturation-Value [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 HSLtoRGB(in vec3 hsl)\n{\n    // Hue-Saturation-Lightness [0..1] to RGB [0..1]\n    vec3 rgb = HUEtoRGB(hsl.x);\n    float c = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * c + hsl.z;\n}\n\nvec3 RGBtoHSV(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Value [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\nvec3 RGBtoHSL(in vec3 rgb)\n{\n    // RGB [0..1] to Hue-Saturation-Lightness [0..1]\n    vec3 hcv = RGBtoHCV(rgb);\n    float z = hcv.z - hcv.y * 0.5;\n    float s = hcv.y / (1. - abs(z * 2. - 1.) + EPSILON);\n    return vec3(hcv.x, s, z);\n}\n\n\n// LAB/RGB converstions - https://code.google.com/archive/p/flowabs/\n// HSV/RGB conversion - http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2xyz( vec3 c ) {\n    vec3 tmp;\n    tmp.x = ( c.r > 0.04045 ) ? pow( ( c.r + 0.055 ) / 1.055, 2.4 ) : c.r / 12.92;\n    tmp.y = ( c.g > 0.04045 ) ? pow( ( c.g + 0.055 ) / 1.055, 2.4 ) : c.g / 12.92,\n    tmp.z = ( c.b > 0.04045 ) ? pow( ( c.b + 0.055 ) / 1.055, 2.4 ) : c.b / 12.92;\n    return 100.0 * tmp *\n        mat3( 0.4124, 0.3576, 0.1805,\n              0.2126, 0.7152, 0.0722,\n              0.0193, 0.1192, 0.9505 );\n}\n\nvec3 xyz2lab( vec3 c ) {\n    vec3 n = c / vec3( 95.047, 100, 108.883 );\n    vec3 v;\n    v.x = ( n.x > 0.008856 ) ? pow( n.x, 1.0 / 3.0 ) : ( 7.787 * n.x ) + ( 16.0 / 116.0 );\n    v.y = ( n.y > 0.008856 ) ? pow( n.y, 1.0 / 3.0 ) : ( 7.787 * n.y ) + ( 16.0 / 116.0 );\n    v.z = ( n.z > 0.008856 ) ? pow( n.z, 1.0 / 3.0 ) : ( 7.787 * n.z ) + ( 16.0 / 116.0 );\n    return vec3(( 116.0 * v.y ) - 16.0, 500.0 * ( v.x - v.y ), 200.0 * ( v.y - v.z ));\n}\n\nvec3 rgb2lab(vec3 c) {\n    vec3 lab = xyz2lab( rgb2xyz( c ) );\n    return vec3( lab.x / 100.0, 0.5 + 0.5 * ( lab.y / 127.0 ), 0.5 + 0.5 * ( lab.z / 127.0 ));\n}\n\nvec3 lab2xyz( vec3 c ) {\n    float fy = ( c.x + 16.0 ) / 116.0;\n    float fx = c.y / 500.0 + fy;\n    float fz = fy - c.z / 200.0;\n    return vec3(\n         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n    );\n}\n\nvec3 xyz2rgb( vec3 c ) {\n    vec3 v =  c / 100.0 * mat3( \n        3.2406, -1.5372, -0.4986,\n        -0.9689, 1.8758, 0.0415,\n        0.0557, -0.2040, 1.0570\n    );\n    vec3 r;\n    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;\n    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;\n    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;\n    return r;\n}\n\nvec3 lab2rgb(vec3 c) {\n    return xyz2rgb( lab2xyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// oklab transform and inverse from\n// https://bottosson.github.io/posts/oklab/\n\n\nconst mat3 fwdA = mat3(1.0, 1.0, 1.0,\n                       0.3963377774, -0.1055613458, -0.0894841775,\n                       0.2158037573, -0.0638541728, -1.2914855480);\n                       \nconst mat3 fwdB = mat3(4.0767245293, -1.2681437731, -0.0041119885,\n                       -3.3072168827, 2.6093323231, -0.7034763098,\n                       0.2307590544, -0.3411344290,  1.7068625689);\n\nconst mat3 invB = mat3(0.4121656120, 0.2118591070, 0.0883097947,\n                       0.5362752080, 0.6807189584, 0.2818474174,\n                       0.0514575653, 0.1074065790, 0.6302613616);\n                       \nconst mat3 invA = mat3(0.2104542553, 1.9779984951, 0.0259040371,\n                       0.7936177850, -2.4285922050, 0.7827717662,\n                       -0.0040720468, 0.4505937099, -0.8086757660);\n\nvec3 oklab_from_linear_srgb(vec3 c) {\n\n    vec3 lms = invB * c;\n            \n    return invA * (sign(lms)*pow(abs(lms), vec3(0.3333333333333)));\n    \n}\n\nvec3 linear_srgb_from_oklab(vec3 c) {\n\n    vec3 lms = fwdA * c;\n    \n    return fwdB * (lms * lms * lms);\n    \n}\n\n\n\n\n#define M_PI 3.14159265358979323846264338327954\n\nfloat cbrt( float x )\n{\n    return sign(x)*pow(abs(x),1.0f/3.0f);\n}\n\n\nvec3 linear_srgb_to_oklab(vec3 c)\n{\n\tfloat l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;\n\tfloat m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;\n\tfloat s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;\n\n\tfloat l_ = cbrt(l);\n\tfloat m_ = cbrt(m);\n\tfloat s_ = cbrt(s);\n\n\treturn vec3(\n\t\t0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,\n\t\t1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,\n\t\t0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_\n\t);\n}\n\nvec3 oklab_to_linear_srgb(vec3 c)\n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b)\n{\n\t// Max saturation will be when one of r, g or b goes below zero.\n\n\t// Select different coefficients depending on which component goes below zero first\n\tfloat k0, k1, k2, k3, k4, wl, wm, ws;\n\n\tif (-1.88170328f * a - 0.80936493f * b > 1.f)\n\t{\n\t\t// Red component\n\t\tk0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;\n\t\twl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;\n\t}\n\telse if (1.81444104f * a - 1.19445276f * b > 1.f)\n\t{\n\t\t// Green component\n\t\tk0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;\n\t\twl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;\n\t}\n\telse\n\t{\n\t\t// Blue component\n\t\tk0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;\n\t\twl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;\n\t}\n\n\t// Approximate max saturation using a polynomial:\n\tfloat S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n\t// Do one step Halley's method to get closer\n\t// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n\t// this should be sufficient for most applications, otherwise do two/three steps \n\n\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t{\n\t\tfloat l_ = 1.f + S * k_l;\n\t\tfloat m_ = 1.f + S * k_m;\n\t\tfloat s_ = 1.f + S * k_s;\n\n\t\tfloat l = l_ * l_ * l_;\n\t\tfloat m = m_ * m_ * m_;\n\t\tfloat s = s_ * s_ * s_;\n\n\t\tfloat l_dS = 3.f * k_l * l_ * l_;\n\t\tfloat m_dS = 3.f * k_m * m_ * m_;\n\t\tfloat s_dS = 3.f * k_s * s_ * s_;\n\n\t\tfloat l_dS2 = 6.f * k_l * k_l * l_;\n\t\tfloat m_dS2 = 6.f * k_m * k_m * m_;\n\t\tfloat s_dS2 = 6.f * k_s * k_s * s_;\n\n\t\tfloat f = wl * l + wm * m + ws * s;\n\t\tfloat f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n\t\tfloat f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n\t\tS = S - f * f1 / (f1 * f1 - 0.5f * f * f2);\n\t}\n\n\treturn S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b)\n{\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(a, b);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n\tfloat L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2( L_cusp , C_cusp );\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)\n{\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)\n\t{\n\t\t// Lower half\n\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n\t}\n\telse\n\t{\n\t\t// Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));\n\n\t\t// Then one step Halley's method\n\t\t{\n\t\t\tfloat dL = L1 - L0;\n\t\t\tfloat dC = C1;\n\n\t\t\tfloat k_l = +0.3963377774f * a + 0.2158037573f * b;\n\t\t\tfloat k_m = -0.1055613458f * a - 0.0638541728f * b;\n\t\t\tfloat k_s = -0.0894841775f * a - 1.2914855480f * b;\n\n\t\t\tfloat l_dt = dL + dC * k_l;\n\t\t\tfloat m_dt = dL + dC * k_m;\n\t\t\tfloat s_dt = dL + dC * k_s;\n\n\n\t\t\t// If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n\t\t\t{\n\t\t\t\tfloat L = L0 * (1.f - t) + t * L1;\n\t\t\t\tfloat C = t * C1;\n\n\t\t\t\tfloat l_ = L + C * k_l;\n\t\t\t\tfloat m_ = L + C * k_m;\n\t\t\t\tfloat s_ = L + C * k_s;\n\n\t\t\t\tfloat l = l_ * l_ * l_;\n\t\t\t\tfloat m = m_ * m_ * m_;\n\t\t\t\tfloat s = s_ * s_ * s_;\n\n\t\t\t\tfloat ldt = 3.f * l_dt * l_ * l_;\n\t\t\t\tfloat mdt = 3.f * m_dt * m_ * m_;\n\t\t\t\tfloat sdt = 3.f * s_dt * s_ * s_;\n\n\t\t\t\tfloat ldt2 = 6.f * l_dt * l_dt * l_;\n\t\t\t\tfloat mdt2 = 6.f * m_dt * m_dt * m_;\n\t\t\t\tfloat sdt2 = 6.f * s_dt * s_dt * s_;\n\n\t\t\t\tfloat r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;\n\t\t\t\tfloat r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;\n\t\t\t\tfloat r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;\n\n\t\t\t\tfloat u_r = r1 / (r1 * r1 - 0.5f * r * r2);\n\t\t\t\tfloat t_r = -r * u_r;\n\n\t\t\t\tfloat g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;\n\t\t\t\tfloat g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;\n\t\t\t\tfloat g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;\n\n\t\t\t\tfloat u_g = g1 / (g1 * g1 - 0.5f * g * g2);\n\t\t\t\tfloat t_g = -g * u_g;\n\n\t\t\t\tfloat b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;\n\t\t\t\tfloat b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;\n\t\t\t\tfloat b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;\n\n\t\t\t\tfloat u_b = b1 / (b1 * b1 - 0.5f * b * b2);\n\t\t\t\tfloat t_b = -b * u_b;\n\n\t\t\t\tt_r = u_r >= 0.f ? t_r : 10000.f;\n\t\t\t\tt_g = u_g >= 0.f ? t_g : 10000.f;\n\t\t\t\tt_b = u_b >= 0.f ? t_b : 10000.f;\n\n\t\t\t\tt += min(t_r, min(t_g, t_b));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0)\n{\n\t// Find the cusp of the gamut triangle\n\tvec2 cusp = find_cusp(a, b);\n\n\treturn find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 gamut_clip_preserve_chroma(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = clamp(L, 0.f, 1.f);\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L0 = 0.5;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat L0 = cusp.x;\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat Ld = L - 0.5f;\n\tfloat e1 = 0.5f + abs(Ld) + alpha * C;\n\tfloat L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)\n{\n\tif (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)\n\t\treturn rgb;\n\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n\n\tfloat L = lab.x;\n\tfloat eps = 0.00001f;\n\tfloat C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\t// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat Ld = L - cusp.x;\n\tfloat k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);\n\n\tfloat e1 = 0.5f * k + abs(Ld) + alpha * C / k;\n\tfloat L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));\n\n\tfloat t = find_gamut_intersection(a_, b_, L, C, L0);\n\tfloat L_clipped = L0 * (1.f - t) + t * L;\n\tfloat C_clipped = t * C;\n\n\treturn oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nfloat toe(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));\n}\n\nfloat toe_inv(float x)\n{\n\tfloat k_1 = 0.206f;\n\tfloat k_2 = 0.03f;\n\tfloat k_3 = (1.f + k_1) / (1.f + k_2);\n\treturn (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nvec2 to_ST(vec2 cusp)\n{\n\tfloat L = cusp.x;\n\tfloat C = cusp.y;\n\treturn vec2( C / L, C / (1.f - L) );\n}\n\n// Returns a smooth approximation of the location of the cusp\n// This polynomial was created by an optimization process\n// It has been designed so that S_mid < S_max and T_mid < T_max\nvec2 get_ST_mid(float a_, float b_)\n{\n\tfloat S = 0.11516993f + 1.f / (\n\t\t+7.44778970f + 4.15901240f * b_\n\t\t+ a_ * (-2.19557347f + 1.75198401f * b_\n\t\t\t+ a_ * (-2.13704948f - 10.02301043f * b_\n\t\t\t\t+ a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\tfloat T = 0.11239642f + 1.f / (\n\t\t+1.61320320f - 0.68124379f * b_\n\t\t+ a_ * (+0.40370612f + 0.90148123f * b_\n\t\t\t+ a_ * (-0.27087943f + 0.61223990f * b_\n\t\t\t\t+ a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_\n\t\t\t\t\t)))\n\t\t);\n\n\treturn vec2( S, T );\n}\n\nvec3 get_Cs(float L, float a_, float b_)\n{\n\tvec2 cusp = find_cusp(a_, b_);\n\n\tfloat C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);\n\tvec2 ST_max = to_ST(cusp);\n\t\n\t// Scale factor to compensate for the curved part of gamut shape:\n\tfloat k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);\n\n\tfloat C_mid;\n\t{\n\t\tvec2 ST_mid = get_ST_mid(a_, b_);\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tfloat C_a = L * ST_mid.x;\n\t\tfloat C_b = (1.f - L) * ST_mid.y;\n\t\tC_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));\n\t}\n\n\tfloat C_0;\n\t{\n\t\t// for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.\n\t\tfloat C_a = L * 0.4f;\n\t\tfloat C_b = (1.f - L) * 0.8f;\n\n\t\t// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n\t\tC_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));\n\t}\n\n\treturn vec3( C_0, C_mid, C_max );\n}\n\n\n\nvec3 okhsl_to_oklab(vec3 hsl)\n{\n\tfloat h = hsl.x;\n\tfloat s = hsl.y;\n\tfloat l = hsl.z;\n\n\tif (l == 1.0f)\n\t{\n\t\treturn vec3( 1.f, 1.f, 1.f );\n\t}\n\n\telse if (l == 0.f)\n\t{\n\t\treturn vec3( 0.f, 0.f, 0.f );\n\t}\n\n\tfloat a_ = cos(2.f * M_PI * h);\n\tfloat b_ = sin(2.f * M_PI * h);\n\tfloat L = toe_inv(l);\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat C, t, k_0, k_1, k_2;\n\n\tif (s < mid)\n\t{\n\t\tt = mid_inv * s;\n\n\t\tk_1 = mid * C_0;\n\t\tk_2 = (1.f - k_1 / C_mid);\n\n\t\tC = t * k_1 / (1.f - k_2 * t);\n\t}\n\telse\n\t{\n\t\tt = (s - mid)/ (1.f - mid);\n\n\t\tk_0 = C_mid;\n\t\tk_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tk_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tC = k_0 + t * k_1 / (1.f - k_2 * t);\n\t}\n    \n    return vec3( L, C * a_, C * b_ );\n}\n    \n    \nvec3 okhsl_to_linear_srgb(vec3 hsl)\n{\n   vec3 lab = okhsl_to_oklab(hsl);\n\treturn oklab_to_linear_srgb(lab);\n}\n\nvec3 oklab_to_okhsl(vec3 lab)\n{\n\tfloat C = sqrt(lab.y * lab.y + lab.z * lab.z);\n\tfloat a_ = lab.y / C;\n\tfloat b_ = lab.z / C;\n\n\tfloat L = lab.x;\n\tfloat h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;\n\n\tvec3 cs = get_Cs(L, a_, b_);\n\tfloat C_0 = cs.x;\n\tfloat C_mid = cs.y;\n\tfloat C_max = cs.z;\n\n\t// Inverse of the interpolation in okhsl_to_srgb:\n\n\tfloat mid = 0.8f;\n\tfloat mid_inv = 1.25f;\n\n\tfloat s;\n\tif (C < C_mid)\n\t{\n\t\tfloat k_1 = mid * C_0;\n\t\tfloat k_2 = (1.f - k_1 / C_mid);\n\n\t\tfloat t = C / (k_1 + k_2 * C);\n\t\ts = t * mid;\n\t}\n\telse\n\t{\n\t\tfloat k_0 = C_mid;\n\t\tfloat k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n\t\tfloat k_2 = (1.f - (k_1) / (C_max - C_mid));\n\n\t\tfloat t = (C - k_0) / (k_1 + k_2 * (C - k_0));\n\t\ts = mid + (1.f - mid) * t;\n\t}\n\n\tfloat l = toe(L);\n\treturn vec3( h, s, l );\n}\n\nvec3 linear_srgb_to_okhsl(vec3 rgb)\n{\n\tvec3 lab = linear_srgb_to_oklab(rgb);\n    return oklab_to_okhsl(lab);\n}\n\n\n\n\n\nvec3 paletteFull[256] =\nvec3[256](\nvec3(000.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(015.0/256.0,  015.0/256.0,  015.0/256.0),\nvec3(031.0/256.0,  031.0/256.0,  031.0/256.0),\nvec3(047.0/256.0,  047.0/256.0,  047.0/256.0),\nvec3(063.0/256.0,  063.0/256.0,  063.0/256.0),\nvec3(075.0/256.0,  075.0/256.0,  075.0/256.0),\nvec3(091.0/256.0,  091.0/256.0,  091.0/256.0),\nvec3(107.0/256.0,  107.0/256.0,  107.0/256.0),\nvec3(123.0/256.0,  123.0/256.0,  123.0/256.0),\nvec3(139.0/256.0,  139.0/256.0,  139.0/256.0),\nvec3(155.0/256.0,  155.0/256.0,  155.0/256.0),\nvec3(171.0/256.0,  171.0/256.0,  171.0/256.0),\nvec3(187.0/256.0,  187.0/256.0,  187.0/256.0),\nvec3(203.0/256.0,  203.0/256.0,  203.0/256.0),\nvec3(219.0/256.0,  219.0/256.0,  219.0/256.0),\nvec3(235.0/256.0,  235.0/256.0,  235.0/256.0),\n\nvec3(015.0/256.0,  011.0/256.0,  007.0/256.0),\nvec3(023.0/256.0,  015.0/256.0,  011.0/256.0),\nvec3(031.0/256.0,  023.0/256.0,  011.0/256.0),\nvec3(039.0/256.0,  027.0/256.0,  015.0/256.0),\nvec3(047.0/256.0,  035.0/256.0,  019.0/256.0),\nvec3(055.0/256.0,  043.0/256.0,  023.0/256.0),\nvec3(063.0/256.0,  047.0/256.0,  023.0/256.0),\nvec3(075.0/256.0,  055.0/256.0,  027.0/256.0),\nvec3(083.0/256.0,  059.0/256.0,  027.0/256.0),\nvec3(091.0/256.0,  067.0/256.0,  031.0/256.0),\nvec3(099.0/256.0,  075.0/256.0,  031.0/256.0),\nvec3(107.0/256.0,  083.0/256.0,  031.0/256.0),\nvec3(115.0/256.0,  087.0/256.0,  031.0/256.0),\nvec3(123.0/256.0,  095.0/256.0,  035.0/256.0),\nvec3(131.0/256.0,  103.0/256.0,  035.0/256.0),\nvec3(143.0/256.0,  111.0/256.0,  035.0/256.0),\n\nvec3(011.0/256.0,  011.0/256.0,  015.0/256.0),\nvec3(019.0/256.0,  019.0/256.0,  027.0/256.0),\nvec3(027.0/256.0,  027.0/256.0,  039.0/256.0),\nvec3(039.0/256.0,  039.0/256.0,  051.0/256.0),\nvec3(047.0/256.0,  047.0/256.0,  063.0/256.0),\nvec3(055.0/256.0,  055.0/256.0,  075.0/256.0),\nvec3(063.0/256.0,  063.0/256.0,  087.0/256.0),\nvec3(071.0/256.0,  071.0/256.0,  103.0/256.0),\nvec3(079.0/256.0,  079.0/256.0,  115.0/256.0),\nvec3(091.0/256.0,  091.0/256.0,  127.0/256.0),\nvec3(099.0/256.0,  099.0/256.0,  139.0/256.0),\nvec3(107.0/256.0,  107.0/256.0,  151.0/256.0),\nvec3(115.0/256.0,  115.0/256.0,  163.0/256.0),\nvec3(123.0/256.0,  123.0/256.0,  175.0/256.0),\nvec3(131.0/256.0,  131.0/256.0,  187.0/256.0),\nvec3(139.0/256.0,  139.0/256.0,  203.0/256.0),\n\nvec3(000.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(007.0/256.0,  007.0/256.0,  000.0/256.0),\nvec3(011.0/256.0,  011.0/256.0,  000.0/256.0),\nvec3(019.0/256.0,  019.0/256.0,  000.0/256.0),\nvec3(027.0/256.0,  027.0/256.0,  000.0/256.0),\nvec3(035.0/256.0,  035.0/256.0,  000.0/256.0),\nvec3(043.0/256.0,  043.0/256.0,  007.0/256.0),\nvec3(047.0/256.0,  047.0/256.0,  007.0/256.0),\nvec3(055.0/256.0,  055.0/256.0,  007.0/256.0),\nvec3(063.0/256.0,  063.0/256.0,  007.0/256.0),\nvec3(071.0/256.0,  071.0/256.0,  007.0/256.0),\nvec3(075.0/256.0,  075.0/256.0,  011.0/256.0),\nvec3(083.0/256.0,  083.0/256.0,  011.0/256.0),\nvec3(091.0/256.0,  091.0/256.0,  011.0/256.0),\nvec3(099.0/256.0,  099.0/256.0,  011.0/256.0),\nvec3(107.0/256.0,  107.0/256.0,  015.0/256.0),\n\nvec3(007.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(015.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(023.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(031.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(039.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(047.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(055.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(063.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(071.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(079.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(087.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(095.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(103.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(111.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(119.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(127.0/256.0,  000.0/256.0,  000.0/256.0),\n\nvec3(019.0/256.0,  019.0/256.0,  000.0/256.0),\nvec3(027.0/256.0,  027.0/256.0,  000.0/256.0),\nvec3(035.0/256.0,  035.0/256.0,  000.0/256.0),\nvec3(047.0/256.0,  043.0/256.0,  000.0/256.0),\nvec3(055.0/256.0,  047.0/256.0,  000.0/256.0),\nvec3(067.0/256.0,  055.0/256.0,  000.0/256.0),\nvec3(075.0/256.0,  059.0/256.0,  007.0/256.0),\nvec3(087.0/256.0,  067.0/256.0,  007.0/256.0),\nvec3(095.0/256.0,  071.0/256.0,  007.0/256.0),\nvec3(107.0/256.0,  075.0/256.0,  011.0/256.0),\nvec3(119.0/256.0,  083.0/256.0,  015.0/256.0),\nvec3(131.0/256.0,  087.0/256.0,  019.0/256.0),\nvec3(139.0/256.0,  091.0/256.0,  019.0/256.0),\nvec3(151.0/256.0,  095.0/256.0,  027.0/256.0),\nvec3(163.0/256.0,  099.0/256.0,  031.0/256.0),\nvec3(175.0/256.0,  103.0/256.0,  035.0/256.0),\n\nvec3(035.0/256.0,  019.0/256.0,  007.0/256.0),\nvec3(047.0/256.0,  023.0/256.0,  011.0/256.0),\nvec3(059.0/256.0,  031.0/256.0,  015.0/256.0),\nvec3(075.0/256.0,  035.0/256.0,  019.0/256.0),\nvec3(087.0/256.0,  043.0/256.0,  023.0/256.0),\nvec3(099.0/256.0,  047.0/256.0,  031.0/256.0),\nvec3(115.0/256.0,  055.0/256.0,  035.0/256.0),\nvec3(127.0/256.0,  059.0/256.0,  043.0/256.0),\nvec3(143.0/256.0,  067.0/256.0,  051.0/256.0),\nvec3(159.0/256.0,  079.0/256.0,  051.0/256.0),\nvec3(175.0/256.0,  099.0/256.0,  047.0/256.0),\nvec3(191.0/256.0,  119.0/256.0,  047.0/256.0),\nvec3(207.0/256.0,  143.0/256.0,  043.0/256.0),\nvec3(223.0/256.0,  171.0/256.0,  039.0/256.0),\nvec3(239.0/256.0,  203.0/256.0,  031.0/256.0),\nvec3(255.0/256.0,  243.0/256.0,  027.0/256.0),\n\nvec3(011.0/256.0,  007.0/256.0,  000.0/256.0),\nvec3(027.0/256.0,  019.0/256.0,  000.0/256.0),\nvec3(043.0/256.0,  035.0/256.0,  015.0/256.0),\nvec3(055.0/256.0,  043.0/256.0,  019.0/256.0),\nvec3(071.0/256.0,  051.0/256.0,  027.0/256.0),\nvec3(083.0/256.0,  055.0/256.0,  035.0/256.0),\nvec3(099.0/256.0,  063.0/256.0,  043.0/256.0),\nvec3(111.0/256.0,  071.0/256.0,  051.0/256.0),\nvec3(127.0/256.0,  083.0/256.0,  063.0/256.0),\nvec3(139.0/256.0,  095.0/256.0,  071.0/256.0),\nvec3(155.0/256.0,  107.0/256.0,  083.0/256.0),\nvec3(167.0/256.0,  123.0/256.0,  095.0/256.0),\nvec3(183.0/256.0,  135.0/256.0,  107.0/256.0),\nvec3(195.0/256.0,  147.0/256.0,  123.0/256.0),\nvec3(211.0/256.0,  163.0/256.0,  139.0/256.0),\nvec3(227.0/256.0,  179.0/256.0,  151.0/256.0),\n\nvec3(171.0/256.0,  139.0/256.0,  163.0/256.0),\nvec3(159.0/256.0,  127.0/256.0,  151.0/256.0),\nvec3(147.0/256.0,  115.0/256.0,  135.0/256.0),\nvec3(139.0/256.0,  103.0/256.0,  123.0/256.0),\nvec3(127.0/256.0,  091.0/256.0,  111.0/256.0),\nvec3(119.0/256.0,  083.0/256.0,  099.0/256.0),\nvec3(107.0/256.0,  075.0/256.0,  087.0/256.0),\nvec3(095.0/256.0,  063.0/256.0,  075.0/256.0),\nvec3(087.0/256.0,  055.0/256.0,  067.0/256.0),\nvec3(075.0/256.0,  047.0/256.0,  055.0/256.0),\nvec3(067.0/256.0,  039.0/256.0,  047.0/256.0),\nvec3(055.0/256.0,  031.0/256.0,  035.0/256.0),\nvec3(043.0/256.0,  023.0/256.0,  027.0/256.0),\nvec3(035.0/256.0,  019.0/256.0,  019.0/256.0),\nvec3(023.0/256.0,  011.0/256.0,  011.0/256.0),\nvec3(015.0/256.0,  007.0/256.0,  007.0/256.0),\n\nvec3(187.0/256.0,  115.0/256.0,  159.0/256.0),\nvec3(175.0/256.0,  107.0/256.0,  143.0/256.0),\nvec3(163.0/256.0,  095.0/256.0,  131.0/256.0),\nvec3(151.0/256.0,  087.0/256.0,  119.0/256.0),\nvec3(139.0/256.0,  079.0/256.0,  107.0/256.0),\nvec3(127.0/256.0,  075.0/256.0,  095.0/256.0),\nvec3(115.0/256.0,  067.0/256.0,  083.0/256.0),\nvec3(107.0/256.0,  059.0/256.0,  075.0/256.0),\nvec3(095.0/256.0,  051.0/256.0,  063.0/256.0),\nvec3(083.0/256.0,  043.0/256.0,  055.0/256.0),\nvec3(071.0/256.0,  035.0/256.0,  043.0/256.0),\nvec3(059.0/256.0,  031.0/256.0,  035.0/256.0),\nvec3(047.0/256.0,  023.0/256.0,  027.0/256.0),\nvec3(035.0/256.0,  019.0/256.0,  019.0/256.0),\nvec3(023.0/256.0,  011.0/256.0,  011.0/256.0),\nvec3(015.0/256.0,  007.0/256.0,  007.0/256.0),\n\nvec3(219.0/256.0,  195.0/256.0,  187.0/256.0),\nvec3(203.0/256.0,  179.0/256.0,  167.0/256.0),\nvec3(191.0/256.0,  163.0/256.0,  155.0/256.0),\nvec3(175.0/256.0,  151.0/256.0,  139.0/256.0),\nvec3(163.0/256.0,  135.0/256.0,  123.0/256.0),\nvec3(151.0/256.0,  123.0/256.0,  111.0/256.0),\nvec3(135.0/256.0,  111.0/256.0,  095.0/256.0),\nvec3(123.0/256.0,  099.0/256.0,  083.0/256.0),\nvec3(107.0/256.0,  087.0/256.0,  071.0/256.0),\nvec3(095.0/256.0,  075.0/256.0,  059.0/256.0),\nvec3(083.0/256.0,  063.0/256.0,  051.0/256.0),\nvec3(067.0/256.0,  051.0/256.0,  039.0/256.0),\nvec3(055.0/256.0,  043.0/256.0,  031.0/256.0),\nvec3(039.0/256.0,  031.0/256.0,  023.0/256.0),\nvec3(027.0/256.0,  019.0/256.0,  015.0/256.0),\nvec3(015.0/256.0,  011.0/256.0,  007.0/256.0),\n\nvec3(111.0/256.0,  131.0/256.0,  123.0/256.0),\nvec3(103.0/256.0,  123.0/256.0,  111.0/256.0),\nvec3(095.0/256.0,  115.0/256.0,  103.0/256.0),\nvec3(087.0/256.0,  107.0/256.0,  095.0/256.0),\nvec3(079.0/256.0,  099.0/256.0,  087.0/256.0),\nvec3(071.0/256.0,  091.0/256.0,  079.0/256.0),\nvec3(063.0/256.0,  083.0/256.0,  071.0/256.0),\nvec3(055.0/256.0,  075.0/256.0,  063.0/256.0),\nvec3(047.0/256.0,  067.0/256.0,  055.0/256.0),\nvec3(043.0/256.0,  059.0/256.0,  047.0/256.0),\nvec3(035.0/256.0,  051.0/256.0,  039.0/256.0),\nvec3(031.0/256.0,  043.0/256.0,  031.0/256.0),\nvec3(023.0/256.0,  035.0/256.0,  023.0/256.0),\nvec3(015.0/256.0,  027.0/256.0,  019.0/256.0),\nvec3(011.0/256.0,  019.0/256.0,  011.0/256.0),\nvec3(007.0/256.0,  011.0/256.0,  007.0/256.0),\n\nvec3(255.0/256.0,  243.0/256.0,  027.0/256.0),\nvec3(239.0/256.0,  223.0/256.0,  023.0/256.0),\nvec3(219.0/256.0,  203.0/256.0,  019.0/256.0),\nvec3(203.0/256.0,  183.0/256.0,  015.0/256.0),\nvec3(187.0/256.0,  167.0/256.0,  015.0/256.0),\nvec3(171.0/256.0,  151.0/256.0,  011.0/256.0),\nvec3(155.0/256.0,  131.0/256.0,  007.0/256.0),\nvec3(139.0/256.0,  115.0/256.0,  007.0/256.0),\nvec3(123.0/256.0,  099.0/256.0,  007.0/256.0),\nvec3(107.0/256.0,  083.0/256.0,  000.0/256.0),\nvec3(091.0/256.0,  071.0/256.0,  000.0/256.0),\nvec3(075.0/256.0,  055.0/256.0,  000.0/256.0),\nvec3(059.0/256.0,  043.0/256.0,  000.0/256.0),\nvec3(043.0/256.0,  031.0/256.0,  000.0/256.0),\nvec3(027.0/256.0,  015.0/256.0,  000.0/256.0),\nvec3(011.0/256.0,  007.0/256.0,  000.0/256.0),\n\nvec3(000.0/256.0,  000.0/256.0,  255.0/256.0),\nvec3(011.0/256.0,  011.0/256.0,  239.0/256.0),\nvec3(019.0/256.0,  019.0/256.0,  223.0/256.0),\nvec3(027.0/256.0,  027.0/256.0,  207.0/256.0),\nvec3(035.0/256.0,  035.0/256.0,  191.0/256.0),\nvec3(043.0/256.0,  043.0/256.0,  175.0/256.0),\nvec3(047.0/256.0,  047.0/256.0,  159.0/256.0),\nvec3(047.0/256.0,  047.0/256.0,  143.0/256.0),\nvec3(047.0/256.0,  047.0/256.0,  127.0/256.0),\nvec3(047.0/256.0,  047.0/256.0,  111.0/256.0),\nvec3(047.0/256.0,  047.0/256.0,  095.0/256.0),\nvec3(043.0/256.0,  043.0/256.0,  079.0/256.0),\nvec3(035.0/256.0,  035.0/256.0,  063.0/256.0),\nvec3(027.0/256.0,  027.0/256.0,  047.0/256.0),\nvec3(019.0/256.0,  019.0/256.0,  031.0/256.0),\nvec3(011.0/256.0,  011.0/256.0,  015.0/256.0),\n\nvec3(043.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(059.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(075.0/256.0,  007.0/256.0,  000.0/256.0),\nvec3(095.0/256.0,  007.0/256.0,  000.0/256.0),\nvec3(111.0/256.0,  015.0/256.0,  000.0/256.0),\nvec3(127.0/256.0,  023.0/256.0,  007.0/256.0),\nvec3(147.0/256.0,  031.0/256.0,  007.0/256.0),\nvec3(163.0/256.0,  039.0/256.0,  011.0/256.0),\nvec3(183.0/256.0,  051.0/256.0,  015.0/256.0),\nvec3(195.0/256.0,  075.0/256.0,  027.0/256.0),\nvec3(207.0/256.0,  099.0/256.0,  043.0/256.0),\nvec3(219.0/256.0,  127.0/256.0,  059.0/256.0),\nvec3(227.0/256.0,  151.0/256.0,  079.0/256.0),\nvec3(231.0/256.0,  171.0/256.0,  095.0/256.0),\nvec3(239.0/256.0,  191.0/256.0,  119.0/256.0),\nvec3(247.0/256.0,  211.0/256.0,  139.0/256.0),\n\nvec3(167.0/256.0,  123.0/256.0,  059.0/256.0),\nvec3(183.0/256.0,  155.0/256.0,  055.0/256.0),\nvec3(199.0/256.0,  195.0/256.0,  055.0/256.0),\nvec3(231.0/256.0,  227.0/256.0,  087.0/256.0),\n\nvec3(127.0/256.0,  191.0/256.0,  255.0/256.0),\nvec3(171.0/256.0,  231.0/256.0,  255.0/256.0),\nvec3(215.0/256.0,  255.0/256.0,  255.0/256.0),\n\nvec3(103.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(139.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(179.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(215.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(255.0/256.0,  000.0/256.0,  000.0/256.0),\n\nvec3(255.0/256.0,  243.0/256.0,  147.0/256.0),\nvec3(255.0/256.0,  247.0/256.0,  199.0/256.0),\nvec3(255.0/256.0,  255.0/256.0,  255.0/256.0),\n\nvec3(159.0/256.0,  091.0/256.0,  083.0/256.0)\n);\n\nvec3 palette[47] =\nvec3[47](\n\nvec3(000.0/256.0,  000.0/256.0,  000.0/256.0),\n\nvec3(187.0/256.0,  187.0/256.0,  187.0/256.0),\n\nvec3(115.0/256.0,  087.0/256.0,  031.0/256.0),\n\nvec3(115.0/256.0,  115.0/256.0,  163.0/256.0),\n\nvec3(083.0/256.0,  083.0/256.0,  011.0/256.0),\n\nvec3(103.0/256.0,  000.0/256.0,  000.0/256.0),\n\nvec3(139.0/256.0,  091.0/256.0,  019.0/256.0),\n\nvec3(207.0/256.0,  143.0/256.0,  043.0/256.0),\n\nvec3(183.0/256.0,  135.0/256.0,  107.0/256.0),\n\nvec3(139.0/256.0,  103.0/256.0,  123.0/256.0),\n\nvec3(151.0/256.0,  087.0/256.0,  119.0/256.0),\n\nvec3(175.0/256.0,  151.0/256.0,  139.0/256.0),\n\nvec3(087.0/256.0,  107.0/256.0,  095.0/256.0),\n\nvec3(203.0/256.0,  183.0/256.0,  015.0/256.0),\n\nvec3(027.0/256.0,  027.0/256.0,  207.0/256.0),\n\nvec3(043.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(059.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(075.0/256.0,  007.0/256.0,  000.0/256.0),\nvec3(095.0/256.0,  007.0/256.0,  000.0/256.0),\nvec3(111.0/256.0,  015.0/256.0,  000.0/256.0),\nvec3(127.0/256.0,  023.0/256.0,  007.0/256.0),\nvec3(147.0/256.0,  031.0/256.0,  007.0/256.0),\nvec3(163.0/256.0,  039.0/256.0,  011.0/256.0),\nvec3(183.0/256.0,  051.0/256.0,  015.0/256.0),\nvec3(195.0/256.0,  075.0/256.0,  027.0/256.0),\nvec3(207.0/256.0,  099.0/256.0,  043.0/256.0),\nvec3(219.0/256.0,  127.0/256.0,  059.0/256.0),\nvec3(227.0/256.0,  151.0/256.0,  079.0/256.0),\nvec3(231.0/256.0,  171.0/256.0,  095.0/256.0),\nvec3(239.0/256.0,  191.0/256.0,  119.0/256.0),\nvec3(247.0/256.0,  211.0/256.0,  139.0/256.0),\n\nvec3(167.0/256.0,  123.0/256.0,  059.0/256.0),\nvec3(183.0/256.0,  155.0/256.0,  055.0/256.0),\nvec3(199.0/256.0,  195.0/256.0,  055.0/256.0),\nvec3(231.0/256.0,  227.0/256.0,  087.0/256.0),\n\nvec3(127.0/256.0,  191.0/256.0,  255.0/256.0),\nvec3(171.0/256.0,  231.0/256.0,  255.0/256.0),\nvec3(215.0/256.0,  255.0/256.0,  255.0/256.0),\n\nvec3(103.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(139.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(179.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(215.0/256.0,  000.0/256.0,  000.0/256.0),\nvec3(255.0/256.0,  000.0/256.0,  000.0/256.0),\n\nvec3(255.0/256.0,  243.0/256.0,  147.0/256.0),\nvec3(255.0/256.0,  247.0/256.0,  199.0/256.0),\nvec3(255.0/256.0,  255.0/256.0,  255.0/256.0),\n\nvec3(159.0/256.0,  091.0/256.0,  083.0/256.0)\n);\n\n\nvec3 paletteDoomFull[249] =\nvec3[249](\nvec3(0.0/256.0,0.0/256.0,0.0/256.0),\nvec3(31.0/256.0,23.0/256.0,11.0/256.0),\nvec3(23.0/256.0,15.0/256.0,7.0/256.0),\nvec3(75.0/256.0,75.0/256.0,75.0/256.0),\nvec3(255.0/256.0,255.0/256.0,255.0/256.0),\nvec3(27.0/256.0,27.0/256.0,27.0/256.0),\nvec3(19.0/256.0,19.0/256.0,19.0/256.0),\nvec3(11.0/256.0,11.0/256.0,11.0/256.0),\nvec3(7.0/256.0,7.0/256.0,7.0/256.0),\nvec3(47.0/256.0,55.0/256.0,31.0/256.0),\nvec3(35.0/256.0,43.0/256.0,15.0/256.0),\nvec3(23.0/256.0,31.0/256.0,7.0/256.0),\nvec3(15.0/256.0,23.0/256.0,0.0/256.0),\nvec3(79.0/256.0,59.0/256.0,43.0/256.0),\nvec3(71.0/256.0,51.0/256.0,35.0/256.0),\nvec3(63.0/256.0,43.0/256.0,27.0/256.0),\nvec3(255.0/256.0,183.0/256.0,183.0/256.0),\nvec3(247.0/256.0,171.0/256.0,171.0/256.0),\nvec3(243.0/256.0,163.0/256.0,163.0/256.0),\nvec3(235.0/256.0,151.0/256.0,151.0/256.0),\nvec3(231.0/256.0,143.0/256.0,143.0/256.0),\nvec3(223.0/256.0,135.0/256.0,135.0/256.0),\nvec3(219.0/256.0,123.0/256.0,123.0/256.0),\nvec3(211.0/256.0,115.0/256.0,115.0/256.0),\nvec3(203.0/256.0,107.0/256.0,107.0/256.0),\nvec3(199.0/256.0,99.0/256.0,99.0/256.0),\nvec3(191.0/256.0,91.0/256.0,91.0/256.0),\nvec3(187.0/256.0,87.0/256.0,87.0/256.0),\nvec3(179.0/256.0,79.0/256.0,79.0/256.0),\nvec3(175.0/256.0,71.0/256.0,71.0/256.0),\nvec3(167.0/256.0,63.0/256.0,63.0/256.0),\nvec3(163.0/256.0,59.0/256.0,59.0/256.0),\nvec3(155.0/256.0,51.0/256.0,51.0/256.0),\nvec3(151.0/256.0,47.0/256.0,47.0/256.0),\nvec3(143.0/256.0,43.0/256.0,43.0/256.0),\nvec3(139.0/256.0,35.0/256.0,35.0/256.0),\nvec3(131.0/256.0,31.0/256.0,31.0/256.0),\nvec3(127.0/256.0,27.0/256.0,27.0/256.0),\nvec3(119.0/256.0,23.0/256.0,23.0/256.0),\nvec3(115.0/256.0,19.0/256.0,19.0/256.0),\nvec3(107.0/256.0,15.0/256.0,15.0/256.0),\nvec3(103.0/256.0,11.0/256.0,11.0/256.0),\nvec3(95.0/256.0,7.0/256.0,7.0/256.0),\nvec3(91.0/256.0,7.0/256.0,7.0/256.0),\nvec3(83.0/256.0,7.0/256.0,7.0/256.0),\nvec3(79.0/256.0,0.0/256.0,0.0/256.0),\nvec3(71.0/256.0,0.0/256.0,0.0/256.0),\nvec3(67.0/256.0,0.0/256.0,0.0/256.0),\nvec3(255.0/256.0,235.0/256.0,223.0/256.0),\nvec3(255.0/256.0,227.0/256.0,211.0/256.0),\nvec3(255.0/256.0,219.0/256.0,199.0/256.0),\nvec3(255.0/256.0,211.0/256.0,187.0/256.0),\nvec3(255.0/256.0,207.0/256.0,179.0/256.0),\nvec3(255.0/256.0,199.0/256.0,167.0/256.0),\nvec3(255.0/256.0,191.0/256.0,155.0/256.0),\nvec3(255.0/256.0,187.0/256.0,147.0/256.0),\nvec3(255.0/256.0,179.0/256.0,131.0/256.0),\nvec3(247.0/256.0,171.0/256.0,123.0/256.0),\nvec3(239.0/256.0,163.0/256.0,115.0/256.0),\nvec3(231.0/256.0,155.0/256.0,107.0/256.0),\nvec3(223.0/256.0,147.0/256.0,99.0/256.0),\nvec3(215.0/256.0,139.0/256.0,91.0/256.0),\nvec3(207.0/256.0,131.0/256.0,83.0/256.0),\nvec3(203.0/256.0,127.0/256.0,79.0/256.0),\nvec3(191.0/256.0,123.0/256.0,75.0/256.0),\nvec3(179.0/256.0,115.0/256.0,71.0/256.0),\nvec3(171.0/256.0,111.0/256.0,67.0/256.0),\nvec3(163.0/256.0,107.0/256.0,63.0/256.0),\nvec3(155.0/256.0,99.0/256.0,59.0/256.0),\nvec3(143.0/256.0,95.0/256.0,55.0/256.0),\nvec3(135.0/256.0,87.0/256.0,51.0/256.0),\nvec3(127.0/256.0,83.0/256.0,47.0/256.0),\nvec3(119.0/256.0,79.0/256.0,43.0/256.0),\nvec3(107.0/256.0,71.0/256.0,39.0/256.0),\nvec3(95.0/256.0,67.0/256.0,35.0/256.0),\nvec3(83.0/256.0,63.0/256.0,31.0/256.0),\nvec3(75.0/256.0,55.0/256.0,27.0/256.0),\nvec3(63.0/256.0,47.0/256.0,23.0/256.0),\nvec3(51.0/256.0,43.0/256.0,19.0/256.0),\nvec3(43.0/256.0,35.0/256.0,15.0/256.0),\nvec3(239.0/256.0,239.0/256.0,239.0/256.0),\nvec3(231.0/256.0,231.0/256.0,231.0/256.0),\nvec3(223.0/256.0,223.0/256.0,223.0/256.0),\nvec3(219.0/256.0,219.0/256.0,219.0/256.0),\nvec3(211.0/256.0,211.0/256.0,211.0/256.0),\nvec3(203.0/256.0,203.0/256.0,203.0/256.0),\nvec3(199.0/256.0,199.0/256.0,199.0/256.0),\nvec3(191.0/256.0,191.0/256.0,191.0/256.0),\nvec3(183.0/256.0,183.0/256.0,183.0/256.0),\nvec3(179.0/256.0,179.0/256.0,179.0/256.0),\nvec3(171.0/256.0,171.0/256.0,171.0/256.0),\nvec3(167.0/256.0,167.0/256.0,167.0/256.0),\nvec3(159.0/256.0,159.0/256.0,159.0/256.0),\nvec3(151.0/256.0,151.0/256.0,151.0/256.0),\nvec3(147.0/256.0,147.0/256.0,147.0/256.0),\nvec3(139.0/256.0,139.0/256.0,139.0/256.0),\nvec3(131.0/256.0,131.0/256.0,131.0/256.0),\nvec3(127.0/256.0,127.0/256.0,127.0/256.0),\nvec3(119.0/256.0,119.0/256.0,119.0/256.0),\nvec3(111.0/256.0,111.0/256.0,111.0/256.0),\nvec3(107.0/256.0,107.0/256.0,107.0/256.0),\nvec3(99.0/256.0,99.0/256.0,99.0/256.0),\nvec3(91.0/256.0,91.0/256.0,91.0/256.0),\nvec3(87.0/256.0,87.0/256.0,87.0/256.0),\nvec3(79.0/256.0,79.0/256.0,79.0/256.0),\nvec3(71.0/256.0,71.0/256.0,71.0/256.0),\nvec3(67.0/256.0,67.0/256.0,67.0/256.0),\nvec3(59.0/256.0,59.0/256.0,59.0/256.0),\nvec3(55.0/256.0,55.0/256.0,55.0/256.0),\nvec3(47.0/256.0,47.0/256.0,47.0/256.0),\nvec3(39.0/256.0,39.0/256.0,39.0/256.0),\nvec3(35.0/256.0,35.0/256.0,35.0/256.0),\nvec3(119.0/256.0,255.0/256.0,111.0/256.0),\nvec3(111.0/256.0,239.0/256.0,103.0/256.0),\nvec3(103.0/256.0,223.0/256.0,95.0/256.0),\nvec3(95.0/256.0,207.0/256.0,87.0/256.0),\nvec3(91.0/256.0,191.0/256.0,79.0/256.0),\nvec3(83.0/256.0,175.0/256.0,71.0/256.0),\nvec3(75.0/256.0,159.0/256.0,63.0/256.0),\nvec3(67.0/256.0,147.0/256.0,55.0/256.0),\nvec3(63.0/256.0,131.0/256.0,47.0/256.0),\nvec3(55.0/256.0,115.0/256.0,43.0/256.0),\nvec3(47.0/256.0,99.0/256.0,35.0/256.0),\nvec3(39.0/256.0,83.0/256.0,27.0/256.0),\nvec3(31.0/256.0,67.0/256.0,23.0/256.0),\nvec3(23.0/256.0,51.0/256.0,15.0/256.0),\nvec3(19.0/256.0,35.0/256.0,11.0/256.0),\nvec3(11.0/256.0,23.0/256.0,7.0/256.0),\nvec3(191.0/256.0,167.0/256.0,143.0/256.0),\nvec3(183.0/256.0,159.0/256.0,135.0/256.0),\nvec3(175.0/256.0,151.0/256.0,127.0/256.0),\nvec3(167.0/256.0,143.0/256.0,119.0/256.0),\nvec3(159.0/256.0,135.0/256.0,111.0/256.0),\nvec3(155.0/256.0,127.0/256.0,107.0/256.0),\nvec3(147.0/256.0,123.0/256.0,99.0/256.0),\nvec3(139.0/256.0,115.0/256.0,91.0/256.0),\nvec3(131.0/256.0,107.0/256.0,87.0/256.0),\nvec3(123.0/256.0,99.0/256.0,79.0/256.0),\nvec3(119.0/256.0,95.0/256.0,75.0/256.0),\nvec3(111.0/256.0,87.0/256.0,67.0/256.0),\nvec3(103.0/256.0,83.0/256.0,63.0/256.0),\nvec3(95.0/256.0,75.0/256.0,55.0/256.0),\nvec3(87.0/256.0,67.0/256.0,51.0/256.0),\nvec3(83.0/256.0,63.0/256.0,47.0/256.0),\nvec3(159.0/256.0,131.0/256.0,99.0/256.0),\nvec3(143.0/256.0,119.0/256.0,83.0/256.0),\nvec3(131.0/256.0,107.0/256.0,75.0/256.0),\nvec3(119.0/256.0,95.0/256.0,63.0/256.0),\nvec3(103.0/256.0,83.0/256.0,51.0/256.0),\nvec3(91.0/256.0,71.0/256.0,43.0/256.0),\nvec3(79.0/256.0,59.0/256.0,35.0/256.0),\nvec3(67.0/256.0,51.0/256.0,27.0/256.0),\nvec3(123.0/256.0,127.0/256.0,99.0/256.0),\nvec3(111.0/256.0,115.0/256.0,87.0/256.0),\nvec3(103.0/256.0,107.0/256.0,79.0/256.0),\nvec3(91.0/256.0,99.0/256.0,71.0/256.0),\nvec3(83.0/256.0,87.0/256.0,59.0/256.0),\nvec3(71.0/256.0,79.0/256.0,51.0/256.0),\nvec3(63.0/256.0,71.0/256.0,43.0/256.0),\nvec3(55.0/256.0,63.0/256.0,39.0/256.0),\nvec3(255.0/256.0,255.0/256.0,115.0/256.0),\nvec3(235.0/256.0,219.0/256.0,87.0/256.0),\nvec3(215.0/256.0,187.0/256.0,67.0/256.0),\nvec3(195.0/256.0,155.0/256.0,47.0/256.0),\nvec3(175.0/256.0,123.0/256.0,31.0/256.0),\nvec3(155.0/256.0,91.0/256.0,19.0/256.0),\nvec3(135.0/256.0,67.0/256.0,7.0/256.0),\nvec3(115.0/256.0,43.0/256.0,0.0/256.0),\nvec3(255.0/256.0,219.0/256.0,219.0/256.0),\nvec3(255.0/256.0,187.0/256.0,187.0/256.0),\nvec3(255.0/256.0,155.0/256.0,155.0/256.0),\nvec3(255.0/256.0,123.0/256.0,123.0/256.0),\nvec3(255.0/256.0,95.0/256.0,95.0/256.0),\nvec3(255.0/256.0,63.0/256.0,63.0/256.0),\nvec3(255.0/256.0,31.0/256.0,31.0/256.0),\nvec3(255.0/256.0,0.0/256.0,0.0/256.0),\nvec3(239.0/256.0,0.0/256.0,0.0/256.0),\nvec3(227.0/256.0,0.0/256.0,0.0/256.0),\nvec3(215.0/256.0,0.0/256.0,0.0/256.0),\nvec3(203.0/256.0,0.0/256.0,0.0/256.0),\nvec3(191.0/256.0,0.0/256.0,0.0/256.0),\nvec3(179.0/256.0,0.0/256.0,0.0/256.0),\nvec3(167.0/256.0,0.0/256.0,0.0/256.0),\nvec3(155.0/256.0,0.0/256.0,0.0/256.0),\nvec3(139.0/256.0,0.0/256.0,0.0/256.0),\nvec3(127.0/256.0,0.0/256.0,0.0/256.0),\nvec3(115.0/256.0,0.0/256.0,0.0/256.0),\nvec3(103.0/256.0,0.0/256.0,0.0/256.0),\nvec3(91.0/256.0,0.0/256.0,0.0/256.0),\nvec3(231.0/256.0,231.0/256.0,255.0/256.0),\nvec3(199.0/256.0,199.0/256.0,255.0/256.0),\nvec3(171.0/256.0,171.0/256.0,255.0/256.0),\nvec3(143.0/256.0,143.0/256.0,255.0/256.0),\nvec3(115.0/256.0,115.0/256.0,255.0/256.0),\nvec3(83.0/256.0,83.0/256.0,255.0/256.0),\nvec3(55.0/256.0,55.0/256.0,255.0/256.0),\nvec3(27.0/256.0,27.0/256.0,255.0/256.0),\nvec3(0.0/256.0,0.0/256.0,255.0/256.0),\nvec3(0.0/256.0,0.0/256.0,227.0/256.0),\nvec3(0.0/256.0,0.0/256.0,203.0/256.0),\nvec3(0.0/256.0,0.0/256.0,179.0/256.0),\nvec3(0.0/256.0,0.0/256.0,155.0/256.0),\nvec3(0.0/256.0,0.0/256.0,131.0/256.0),\nvec3(0.0/256.0,0.0/256.0,107.0/256.0),\nvec3(0.0/256.0,0.0/256.0,83.0/256.0),\nvec3(255.0/256.0,235.0/256.0,219.0/256.0),\nvec3(255.0/256.0,215.0/256.0,187.0/256.0),\nvec3(255.0/256.0,199.0/256.0,155.0/256.0),\nvec3(255.0/256.0,179.0/256.0,123.0/256.0),\nvec3(255.0/256.0,163.0/256.0,91.0/256.0),\nvec3(255.0/256.0,143.0/256.0,59.0/256.0),\nvec3(255.0/256.0,127.0/256.0,27.0/256.0),\nvec3(243.0/256.0,115.0/256.0,23.0/256.0),\nvec3(235.0/256.0,111.0/256.0,15.0/256.0),\nvec3(223.0/256.0,103.0/256.0,15.0/256.0),\nvec3(215.0/256.0,95.0/256.0,11.0/256.0),\nvec3(203.0/256.0,87.0/256.0,7.0/256.0),\nvec3(195.0/256.0,79.0/256.0,0.0/256.0),\nvec3(183.0/256.0,71.0/256.0,0.0/256.0),\nvec3(175.0/256.0,67.0/256.0,0.0/256.0),\nvec3(255.0/256.0,255.0/256.0,215.0/256.0),\nvec3(255.0/256.0,255.0/256.0,179.0/256.0),\nvec3(255.0/256.0,255.0/256.0,143.0/256.0),\nvec3(255.0/256.0,255.0/256.0,107.0/256.0),\nvec3(255.0/256.0,255.0/256.0,71.0/256.0),\nvec3(255.0/256.0,255.0/256.0,35.0/256.0),\nvec3(255.0/256.0,255.0/256.0,0.0/256.0),\nvec3(167.0/256.0,63.0/256.0,0.0/256.0),\nvec3(159.0/256.0,55.0/256.0,0.0/256.0),\nvec3(147.0/256.0,47.0/256.0,0.0/256.0),\nvec3(135.0/256.0,35.0/256.0,0.0/256.0),\nvec3(79.0/256.0,59.0/256.0,39.0/256.0),\nvec3(67.0/256.0,47.0/256.0,27.0/256.0),\nvec3(55.0/256.0,35.0/256.0,19.0/256.0),\nvec3(47.0/256.0,27.0/256.0,11.0/256.0),\nvec3(0.0/256.0,0.0/256.0,71.0/256.0),\nvec3(0.0/256.0,0.0/256.0,59.0/256.0),\nvec3(0.0/256.0,0.0/256.0,47.0/256.0),\nvec3(0.0/256.0,0.0/256.0,35.0/256.0),\nvec3(0.0/256.0,0.0/256.0,23.0/256.0),\nvec3(0.0/256.0,0.0/256.0,11.0/256.0),\nvec3(255.0/256.0,159.0/256.0,67.0/256.0),\nvec3(255.0/256.0,231.0/256.0,75.0/256.0),\nvec3(255.0/256.0,123.0/256.0,255.0/256.0),\nvec3(255.0/256.0,0.0/256.0,255.0/256.0),\nvec3(207.0/256.0,0.0/256.0,207.0/256.0),\nvec3(159.0/256.0,0.0/256.0,155.0/256.0),\nvec3(111.0/256.0,0.0/256.0,107.0/256.0),\nvec3(167.0/256.0,107.0/256.0,107.0/256.0)\n);\n\n\nfloat getMatchDistanceHue(vec3 c, vec3 p_c) {\n   return min(abs(c.x - p_c.x), abs(c.x + 1.0 - p_c.x ));\n}\n\n\nfloat getMatchDistanceW(vec3 c, vec3 p_c, vec3 w) {\n    vec3 d = vec3(getMatchDistanceHue(c, p_c),abs(c.y-p_c.y),abs(c.z-p_c.z))*w;\n    vec3 d2 = d*d;\n    return sqrt(d.x+d.y+d.z);\n}\n\n\nfloat getMatchDistance(vec3 c, vec3 p_c) {\n    vec3 w = vec3(1.0,1.0,1.0);\n    return getMatchDistanceW(c,p_c,w);\n}\n\n\nvec3 createFromMatch(vec3 c, vec3 p_c) {\n  return vec3(mix(p_c.x,c.x,0.0), mix(p_c.y,c.y,0.0), mix(p_c.z,c.z,0.0));\n}\n\nvec3 mixLAB(vec3 p_A, float distA, vec3 p_B, float distB) {\n  float m = clamp((distB+EPSILON)/(distA+distB+EPSILON),0.0,1.0);\n  return mix(p_A,p_B,m);\n}\n\nvec3 getPaletteMatchLABSimpleCore(vec3 lab, vec3 w) {\n    vec3 c = oklab_to_okhsl(lab);\n    float dist = 1.0;\n    vec3 match = c;\n\n    for(int i = 0; i < 256; i++) {\n        vec3 p_rgb = SRGBtoRGB(paletteFull[i]);\n        vec3 p_lab = linear_srgb_to_oklab(p_rgb);\n        vec3 p_c =  oklab_to_okhsl(p_lab);\n   \n        float p_dist = getMatchDistanceW(c, p_c, w);\n        \n        if(p_dist < dist) {\n            dist = p_dist;\n            match = p_lab;\n        }\n    }\n    \n    return match;\n}\n\nvec3 getPaletteMatchLABCore(vec3 lab) {\n\n    vec3 c = oklab_to_okhsl(lab);\n    \n    float distA = 1000.0;\n    vec3 p_A = vec3(0.0,0.0,0.0);\n    float distB = 1000.0;\n    vec3 p_B = vec3(-1.0,-1.0,-1.0);\n\n    for(int i = 0; i < 256; i++) {\n        vec3 p_rgb = SRGBtoRGB(paletteFull[i]);\n        vec3 p_lab = linear_srgb_to_oklab(p_rgb);\n        vec3 p_c =  oklab_to_okhsl(p_lab);\n   \n        float p_dist = getMatchDistance(c, p_c);\n        float p_distA = getMatchDistance(p_A, p_c);\n        float p_distB = getMatchDistance(p_B, p_c);\n        float distAB = getMatchDistance(p_A, p_B);\n        \n        if(p_dist-EPSILON < distA // closer than current match\n        //&& p_distAB+EPSILON >= p_dist  // A/B not on same side\n        ){ \n            distA = p_dist;\n            p_A = p_lab;\n        }\n        else \n        if(p_dist-EPSILON < distB // closer than current match\n        //&& p_dist-EPSILON < distA*2.0 // not farther than 2xA\n        //&& distAB+EPSILON >= p_distA  // old span bigger than new span\n        && p_distA+EPSILON >= p_dist  // A/B not on same side\n        && false\n        ){ \n            distB = p_dist;\n            p_B = p_lab;\n        }\n        \n    }\n    \n    if(p_B.x < 0.0)\n        p_B = p_A;\n    \n    vec3 match = mixLAB(p_A, distA, p_B, distB);\n    return match;\n}\n\n\nvec3 getPaletteMatchLAB(vec3 rgb) {\n    vec3 lab = linear_srgb_to_oklab(rgb);\n    \n    vec3 match = getPaletteMatchLABCore((lab));\n    \n    /*\n    float d = 0.001;\n    vec3 match1 = getPaletteMatchLABCore((lab+vec3(0,0,1)*d));\n    vec3 match2 = getPaletteMatchLABCore((lab+vec3(0,0,-1)*d));\n    vec3 match3 = getPaletteMatchLABCore((lab+vec3(0,1,0)*d));\n    vec3 match4 = getPaletteMatchLABCore((lab+vec3(0,-1,0)*d));\n    \n    \n    match = match*0.6+match1*0.1+match1*0.1+match1*0.1+match1*0.1;\n    */\n    \n    match = oklab_to_okhsl(match);\n    \n    vec3 c = oklab_to_okhsl(lab);\n    c = createFromMatch(c, match);\n    return okhsl_to_linear_srgb(c);\n}\n\n\n\nvec3 getPaletteMatchHSL(vec3 rgb) {\n    vec3 c = RGBtoHSL(rgb);\n    float dist = 1000.0;\n    vec3 match = vec3(0,0,0);\n\n    for(int i = 0; i < 256; i++) {\n        vec3 p_rgb = SRGBtoRGB(paletteFull[i]);\n        vec3 p_c = RGBtoHSV(p_rgb);\n   \n        float p_dist = getMatchDistance(c, p_c);\n        \n        if(p_dist-EPSILON < dist) {\n            dist = p_dist;\n            match = p_c;\n        }\n        \n    }\n    c = createFromMatch(c, match);\n    return HSLtoRGB(c);\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float restart = mod(float(iFrame+2), ROUNDS);\n    \n    if (restart == 0.) \n        fragColor = texture(iChannel0,fragCoord/iChannelResolution[0].xy); \n    else \n        fragColor = texture(iChannel1,fragCoord/iChannelResolution[1].xy);   \n\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec4 draw(vec2 uv) {\n\n    float restart = mod(float(iFrame+2), ROUNDS);\n    \n    return texture(iChannel0,vec2(fract(uv.x),uv.y)).rgba;   \n    //return texture(iChannel0,uv).rgb;  \n}\n\nfloat grid(float var, float size) {\n    return floor(var*size)/size;\n}\n\nfloat rand(vec2 co){\n    //return 1.0;//co.x;\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    float bluramount = 0.02;\n   \n    float dists = 360.;\n    vec4 blurred_image = vec4(0.);//draw(uv);\n    #define repeats 360.\n    for (float i = 0.; i < repeats; i++) { \n        //Older:\n        //vec2 q = vec2(cos(degrees((grid(i,dists)/repeats)*360.)),sin(degrees((grid(i,dists)/repeats)*360.))) * (1./(1.+mod(i,dists)));     \n        //vec2 q = vec2(cos(degrees((i/repeats)*360.)),sin(degrees((i/repeats)*360.))) * (rand(vec2(i,uv.x+uv.y))+bluramount); \n        vec2 q = vec2(cos(degrees((i/repeats)*360.)),sin(degrees((i/repeats)*360.))); \n        vec2 uv2 = uv+(q*bluramount);\n        vec4 shifted_image = draw(uv2);\n        blurred_image += shifted_image/repeats;\n    }\n    \n    vec4 image = draw(uv);\n    float w = ((1.0-image.w) + blurred_image.w)*0.5;\n    fragColor =  image * (1.0-w) + blurred_image * w;\n    \n    fragColor = blurred_image;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float restart = mod(float(iFrame+2), ROUNDS);\n    \n    if (restart == 0.) \n        fragColor = texture(iChannel0,fragCoord/iChannelResolution[0].xy); \n    else \n        fragColor = texture(iChannel1,fragCoord/iChannelResolution[1].xy);   \n\n}","name":"Buffer C","description":"","type":"buffer"}]}