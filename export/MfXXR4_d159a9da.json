{"ver":"0.1","info":{"id":"MfXXR4","date":"1705018651","viewed":50,"name":"round ball of rock and water","username":"foxnerdsaysmoo","description":"A little spinning planet.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nCode by Zebulon Taylor, licensed under the MIT license.\n\nContains code written by Inigo Quilez which was under the MIT license.\n\n*/\n\n#define PI 3.1415926535897932384626433832795\n#define BIG 1000000000000000.0\n\nstruct ray {\n    vec3 orig;\n    vec3 dir;\n    float t;\n};\n\nstruct material {\n    vec3 col;\n    float specular_coeff;\n    float hardness;\n    vec3 norm_offset;\n};\n\nstruct light {\n    vec3 center;\n    float brightness;\n    float falloff;\n};\n\nstruct fog_hit {\n    float fog_thickness;\n    float first_hit;\n};\n\nvec3 r2p(ray r) {\n    return r.orig + r.dir*r.t;\n}\n\nfloat smooth_step(float a, float b, float c) {\n    float x = clamp((c - a)/(b - a), 0., 1.);\n    return x * x * (3. - 2.*x);\n}\n\nvec3 hash(vec3 co){\n    return vec3(fract(sin(dot(co, vec3(12.9898, 78.233, 47.1421))) * 43758.5453));\n}\n\n// Noise function by Inigo Quilez under MIT license\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nfloat fbm( in vec3 x, in float H, in int lod, float f, float f2 ) {\n    float G = exp2(-H);\n    float a = 1.0;\n    float t = 0.0;\n    float theta = 1.;\n    mat3 rot = mat3(1,0,0,0,cos(theta),-sin(theta),0,sin(theta),cos(theta));\n    mat3 r = rot;\n    for( int i=0; i<lod; i++ )\n    // TODO: ADJUST LOD BASED ON DISTANCE, IE SHORTER DISTANCE -> HIGHER LOD\n    {\n        t += a*noise(f*x*r);\n        r *= rot;\n        f *= f2;\n        a *= G;\n    }\n    return t;\n}\n\nfloat fbm_unbiased( in vec3 x, in float H, in int lod, float f, float f2 ) {\n    float G = exp2(-H);\n    float a = 1.0;\n    float t = 0.0;\n    float theta = 1.;\n    mat3 rot = mat3(1,0,0,0,cos(theta),-sin(theta),0,sin(theta),cos(theta)) * mat3(cos(theta),-sin(theta),0,sin(theta),cos(theta),0,0,0,1);\n    mat3 r = rot;\n    for( int i=0; i<lod; i++ )\n    // TODO: ADJUST LOD BASED ON DISTANCE, IE SHORTER DISTANCE -> HIGHER LOD\n    {\n        t += a*noise(f*x*r);\n        r *= rot;\n        f *= f2;\n        a *= G;\n    }\n    return t;\n}\n\nfloat planet_sdf(vec3 p) {\n    return distance(p, vec3(0.,0.,0.))-1.;\n}\n\nfloat cloud_sdf(vec3 p) {\n    vec3 p2 = vec3(iTime/7.,0.,0.);\n    float theta = iTime/4.;\n    p2 += normalize(p)*mat3(cos(theta),-sin(theta),0,sin(theta),cos(theta),0,0,0,1);\n    return max(planet_sdf(p)-.4*fbm(p2,2.,3,1.6,1.7)-.05,-planet_sdf(p)+.07);\n}\n\nbool cast_ray(inout ray r, int steps, float stopat) {\n    for (int i=0; i<steps; i++) {\n        vec3 p = r2p(r);\n\n        float dist = planet_sdf(p);\n        r.t += dist;\n        if (dist < 0.001) {return true;}\n        if (r.t > stopat) {return false;}\n    }\n    return false;\n}\n\nfloat get_dist(vec3 p) {\n    return planet_sdf(p);\n}\n\nvec3 get_normal(vec3 p) {\n    vec3 small_step = vec3(0.1,0.0,0.0);\n    return normalize(vec3(\n        get_dist(p + small_step.xyz) - get_dist(p - small_step.xyz),\n        get_dist(p + small_step.zxy) - get_dist(p - small_step.zxy),\n        get_dist(p + small_step.yzx) - get_dist(p - small_step.yzx)\n    ));\n}\n\nmaterial get_color(vec3 p) {\n    float theta = iTime/4.;\n    p *= mat3(cos(theta),-sin(theta),0,sin(theta),cos(theta),0,0,0,1);\n    vec3 cyl = vec3(normalize(p.xy),p.z);\n    float iciness = clamp(\n        6.*(abs(p.z)-.65)+fbm(cyl,1.,1,2.,sqrt(2.)),\n        0.,\n        1.\n    );\n    float wetness = clamp(\n        round(20.*(fbm(cyl,.4,7,.3,2.))),\n        0.,\n        1.\n    );\n    float waves = clamp(\n        fbm(cyl,.5,10,.3,2.)+.1,\n        0.,\n        1.\n    );\n    float vegetation = clamp(\n        fbm(cyl+1.,.8,10,2.,2.)+.1,\n        0.,\n        1.\n    );\n    material result;\n    \n    // Color\n    result.col = mix(\n        mix(vec3(0.5,0.7,0.4),vec3(0.2,0.6,0.2),vegetation),\n        mix(vec3(0.3,0.4,0.7),vec3(0.2,0.2,0.6),waves),\n        wetness\n    );\n    result.col = mix(result.col,vec3(0.8,0.8,0.9),iciness);\n    \n    // Specular\n    result.specular_coeff = mix(\n        mix(.3,.3,vegetation),\n        mix(.9,1.1,waves),\n        wetness\n    );\n    result.specular_coeff = mix(result.specular_coeff,0.05,iciness);\n    \n    result.hardness = mix(\n        mix(1.,3.,vegetation),\n        mix(10.,12.,waves),\n        wetness\n    );\n    result.hardness = mix(result.hardness,0.05,iciness);\n    \n    // Normal offset\n    result.norm_offset = hash(vec3(waves));\n    \n    return result;\n}\n\nvec3 get_stars(ray r) {\n    r.dir += vec3(iTime/200.,0.,0.);\n    float brightness = 3.*(clamp(fbm_unbiased(r.dir, 0.553, 3, 50., 1.5),0.4,1.)-.4);\n    return vec3(brightness);\n}\n\nfloat get_specular(ray r, light l) {\n    vec3 norm = get_normal(r2p(r));\n    r.orig += r.dir*r.t;\n    vec3 light_dir = normalize(l.center - r.orig);\n    return max(0.,dot(r.dir, reflect(light_dir, norm)));\n}\n\nfloat get_lighting(ray r_old, light target, material m) {\n    vec3 p = r2p(r_old);\n    ray r;\n    r.orig = p;\n    r.dir = normalize(target.center-p);\n    r.t=0.;\n    float d = distance(target.center,p);\n    bool does_hit = cast_ray(r, 100, d+1.);\n    if (does_hit) {return 0.;}\n    \n    float brightness = .2;\n    brightness += max(target.brightness / pow(d,target.falloff) * dot(get_normal(p)+0.01*m.norm_offset, r.dir),0.);\n    brightness += pow(get_specular(r_old, target),m.hardness)*m.specular_coeff;\n    return brightness;\n}\n\nfog_hit get_fog(in ray r, int steps, float stopat) {\n    r.t = 0.;\n    float first_hit = 0.;\n    float total_fog = 0.;\n    for (int i=0; i<steps; i++) {\n        vec3 p = r2p(r);\n\n        float dist = cloud_sdf(p);\n        r.t += max(dist*.8,0.01);\n        if (dist < 0.) {\n            if (first_hit == 0.) {first_hit = r.t;}\n            total_fog += 0.01;\n        }\n        if (r.t-max(dist*.3,0.01) >= stopat) {break;}\n    }\n    fog_hit res;\n    res.first_hit = first_hit;\n    res.fog_thickness = total_fog;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // SUN\n    light sun;\n    sun.center = vec3(-100.,-100.,9.);\n    sun.brightness = .7;\n    sun.falloff = 0.;\n\n    // RAY\n    vec2 uv = fragCoord - iResolution.xy/2.0;\n\n    ray r;\n    r.orig = vec3(-4.,0.,0.);\n    \n    float theta = 0.;\n    mat3 rotation = mat3(cos(theta),-sin(theta),0,sin(theta),cos(theta),0,0,0,1);\n    r.dir = rotation * normalize(vec3(iResolution.x,uv));\n    r.t = 0.0;\n\n    // RENDER\n    vec3 col = vec3(0.0,0.0,0.0);\n    bool does_hit = cast_ray(r, 100, 10.);\n    \n    material res;\n    vec3 norm = get_normal(r2p(r));\n    ray r2 = r;\n    r2.orig += 0.1*norm;\n    \n    if (does_hit) {\n        res = get_color(r2p(r));\n        col = res.col;\n        col = pow(col,vec3(1./get_lighting(r2, sun, res)));\n    } else {\n        col = get_stars(r);\n    }\n    \n    res.col = vec3(0.8,0.8,0.8);\n    res.specular_coeff = 0.;\n    res.hardness = 1.;\n    res.norm_offset = vec3(0.);\n    \n    fog_hit fog = get_fog(r, 100, r.t);\n    r2.t = fog.first_hit;\n    col = mix(col, pow(res.col,vec3(1./get_lighting(r2, sun, res))), 1.-exp(-fog.fog_thickness*50.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}