{"ver":"0.1","info":{"id":"4c2XD1","date":"1706288048","viewed":102,"name":"Stylized raymarching","username":"FrederickAmpsUp","description":"\"drawn\" look I hope","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"lflSWs","parentname":"Ray Marching starter"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks to https://www.shadertoy.com/view/ls3GWS\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    \n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    vec3 col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n    \n    fragColor = vec4( col, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define STEPS 50\n\n#define MISS 1000.0\n#define SURF 0.005\n\n#define SQRT_SAMPLES sqrt(4.0)\n#define GI_STRENGTH 1.0\n\nstruct Material {\n    vec3 colDiffuse;\n    vec3 colEmission;\n    \n    vec3 colSpecular;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n    \n    float size;\n};\n\n#define N_LIGHTS 1\nLight lights[N_LIGHTS] = Light[N_LIGHTS](\n    Light(vec3(0.0, 1.5, 0.5), vec3(0.6,0.6,0.6), 0.25)\n);\nstruct SDF3d {\n    float dist;\n    Material mat;\n};\n\nfloat gaussian(float x, float mu, float sigma) {\n    return exp(-0.5 * pow((x - mu) / sigma, 2.0)) / (sigma * sqrt(2.0 * 3.14159265359));\n}\n\nfloat gaussian(float x) {\n    return gaussian(x, 0.0, 0.3);\n}\n\nstruct Hit {\n    bool hit;\n    vec3 pos;\n    float dst;\n    vec3 norm;\n    \n    Material mat;\n};\n\nstruct Ray {\n    vec3 org;\n    vec3 dir;\n};\n\nSDF3d sdSphere(vec3 p, vec3 c, float r, Material mat) {\n    SDF3d sdf;\n    sdf.dist = length(p - c) - r;\n    sdf.mat = mat;\n    \n    return sdf;\n}\n\nSDF3d sdBox( vec3 p, vec3 b, Material mat ) {\n    vec3 q = abs(p) - b;\n    return SDF3d(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), mat);\n}\n\nSDF3d sdBox( vec3 p, vec3 b ) {\n    return sdBox(p,b,Material(vec3(1), vec3(0), vec3(0)));\n}\n\nSDF3d sdSphere(vec3 p, vec3 c, float r) {\n    return sdSphere(p, c, r, Material(vec3(1), vec3(0), vec3(0)));\n}\n\nMaterial mix(Material m1, Material m2, float t) {\n    return Material(mix(m1.colDiffuse, m2.colDiffuse, t), mix(m1.colEmission, m2.colEmission, t), mix(m1.colSpecular, m2.colSpecular, t));\n}\n\nSDF3d mix(SDF3d d1, SDF3d d2, float t) {\n    return SDF3d(mix(d1.dist, d2.dist, t), mix(d1.mat, d2.mat, t));\n}\n\nSDF3d opUnion(SDF3d obj1, SDF3d obj2) {\n    return mix(obj2, obj1, float(obj1.dist < obj2.dist));\n}\n\nvec3 rotateY(in vec3 p, in float t) {\n    float cosT = cos(t), sinT = sin(t);\n    return vec3(p.x * cosT - p.z * sinT, p.y, p.x * sinT + p.z * cosT);\n}\n\nSDF3d map(vec3 p, bool shadow) {\n    // cornell box scene to demonstrate global illumination\n    SDF3d scene;\n    scene = sdSphere(p, vec3(0, -1000, 0), 1000.0);\n    \n    scene = opUnion(scene, sdSphere(p, vec3(-1002.0, 0.5, 1.0), 1000.0, Material(vec3(1,0,0), vec3(0), vec3(0))));\n    scene = opUnion(scene, sdSphere(p, vec3( 1002.0, 0.5, 1.0), 1000.0, Material(vec3(0,1,0), vec3(0), vec3(0))));\n    scene = opUnion(scene, sdSphere(p, vec3(0.0, 0.5,  1001.6), 1000.0, Material(vec3(0,0,1), vec3(0), vec3(0))));\n    scene = opUnion(scene, sdSphere(p, vec3(0.0, 0.5, -1002.0), 1000.0, Material(vec3(1,1,1), vec3(0), vec3(0))));\n    scene = opUnion(scene, sdSphere(p, vec3(0.0,  1002.0, 0.0), 1000.0, Material(vec3(1,1,1), vec3(0), vec3(0))));\n\n\n        // mirror ball\n    scene = opUnion(scene, sdSphere(p, vec3(1, 0.5, 0.5), 0.5, Material(vec3(0), vec3(0), vec3(1))));\n    \n        // Rotated box\n    float ang = -0.15 * 3.14159;\n    scene = opUnion(scene, sdBox(rotateY(p, ang) - rotateY(vec3(-0.8, 0.2, 0.5), ang), vec3(0.3, 1.0, 0.2), Material(vec3(1.0, 0.8, 0.0), vec3(0), vec3(0))));\n    if (!shadow) // Add the lights in the scene. This should be removed for scenes with different shaped lights.\n        scene = opUnion(scene, sdBox(p - lights[0].pos - vec3(0.0, 0.4, 0.0), vec3(0.5, 0.1, 0.5), Material(vec3(0), vec3(1), vec3(0))));\n    \n    return scene;\n}\n\nvec3 normal(vec3 pos, float dist) {\n    float epsilon = SURF;\n    return normalize(\n        vec3(\n            dist - map(pos - vec3(epsilon, 0, 0), false).dist,\n            dist - map(pos - vec3(0, epsilon, 0), false).dist,\n            dist - map(pos - vec3(0, 0, epsilon), false).dist\n        )\n    );\n}\n\nvec3 shadow(Ray r, float lightDist, float lightSize) {\n    float res = 1.0;\n    float t = 2.0 * SURF;\n    SDF3d scene;\n    for( int i=0; i<STEPS && t<lightDist; i++ ) {\n        scene = map(r.org + r.dir * t, true);\n        float h = scene.dist;\n        res = min( res, h/(lightSize*t) );\n        t += clamp(h, 0.005, 0.50);\n        if(res<-1.0) break;\n    }\n    res = max(res,-1.0);\n    if (res != res) return vec3(1.0);\n    vec3 final = vec3(0.25*(1.0+res)*(1.0+res)*(2.0-res));\n    return final;\n}\n\nHit march(Ray r) {\n    float t = 0.0;\n    vec3 pos;\n    \n    Hit hit;\n    SDF3d scene;\n    \n    for (int i = 0; i < STEPS; i++) {\n        pos = r.org + r.dir * t;\n        scene = map(pos, false);\n        \n        if (scene.dist < SURF || scene.dist > MISS) break;\n        t += scene.dist;\n    }\n    hit.hit = t < MISS;\n    hit.pos = pos;\n    hit.dst = t;\n    if (hit.hit) hit.norm = normal(pos, scene.dist);\n    hit.mat = scene.mat;\n    \n    return hit;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"    // https://www.shadertoy.com/view/Xltfzj\nvec4 blur(sampler2D textureSampler, vec2 uv, float Size) {\n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 32.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 8.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel0, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    \n    lights[0].pos.z = sin(iTime)/2.0;\n    lights[0].pos.x = cos(iTime)/2.0;\n\n    Ray cam = Ray(vec3(0,0.7,-1), normalize(vec3(ndc, 1.0)));\n    Hit hit = march(cam);\n    \n    vec3 direct = vec3(0.0);\n\n    for (int light = 0; light < N_LIGHTS; light++) {\n        Light l = lights[light];\n        vec3 dirToLight = normalize(l.pos - hit.pos);\n        float diffuse = max(0.0, dot(hit.norm, dirToLight));\n        diffuse /= dot(l.pos - hit.pos, l.pos - hit.pos);\n        vec3 shadowT = shadow(Ray(hit.pos, dirToLight), length(l.pos - hit.pos), l.size);\n\n        direct += hit.mat.colDiffuse * max(vec3(0.02), shadowT * diffuse) * l.col;\n    }\n    direct *= float(hit.hit);\n\n    vec3 emitted = hit.mat.colEmission;\n    emitted *= float(hit.hit);\n    \n    vec3 origCol = hit.mat.colDiffuse;\n    \n    vec3 specular = hit.mat.colSpecular * float(hit.hit);\n    vec3 directRefl = vec3(0.0);\n    cam.org = hit.pos + hit.norm * 2.0 * SURF;\n    cam.dir = reflect(cam.dir, hit.norm);\n    hit = march(cam);\n    \n    for (int light = 0; light < N_LIGHTS; light++) {\n        Light l = lights[light];\n        vec3 dirToLight = normalize(l.pos - hit.pos);\n        float diffuse = max(0.0, dot(hit.norm, dirToLight));\n        vec3 shadowT = shadow(Ray(hit.pos, dirToLight), length(l.pos - hit.pos), l.size);\n        \n        directRefl += hit.mat.colDiffuse * max(vec3(0.3), shadowT * diffuse) * l.col;\n    }\n    directRefl *= float(hit.hit);\n    specular *= directRefl + hit.mat.colEmission;\n    specular *= float(hit.hit);\n    \n    vec3 color = direct + emitted + specular;\n    \n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define HATCH_SCALE 20.0\n#define HATCH_LEVELS 5.0\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\nfloat lerp(float a, float b, float k) { return mix(a,b,k); }\n\nfloat noise( vec3 x ) {\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),\n        lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),\n        lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    col *= 0.5;\n    float mag = length(col);\n    \n        // https://www.shadertoy.com/view/td2yDm\n        // edge detection\n    float h = 1.0;\n    \n    vec4 o = texture(iChannel0, (fragCoord + vec2( 0, 0))/iResolution.xy);\n\tvec4 n = texture(iChannel0, (fragCoord + vec2( 0, h))/iResolution.xy);\n    vec4 e = texture(iChannel0, (fragCoord + vec2( h, 0))/iResolution.xy);\n    vec4 s = texture(iChannel0, (fragCoord + vec2( 0,-h))/iResolution.xy);\n    vec4 w = texture(iChannel0, (fragCoord + vec2(-h, 0))/iResolution.xy);\n    \n    vec4 dy = (n - s)*.5;\n    vec4 dx = (e - w)*.5;\n    \n    vec4 edge = sqrt(dx*dx + dy*dy)*2.0;\n    vec3 background = vec3(0.95, 0.9, 0.8) * min(1.0, 0.4+length(texture(iChannel1, uv*5.0)) * 0.5);\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.x += 0.005*noise(vec3(uv*HATCH_SCALE*5.0, 0.0+float(iFrame/10)));\n    uv.y += 0.005*noise(vec3(uv*HATCH_SCALE*5.0, 0.5+float(iFrame/10)));\n    float uvSqLen = uv.x+uv.y;\n    float scale = HATCH_SCALE*round((1.0-mag)*HATCH_LEVELS-HATCH_LEVELS/2.0);\n    uvSqLen = mod(uvSqLen, 1.0 / scale) * scale;\n    float crossHatch = 1.0-smoothstep(0.6, 1.0, 1.0-uvSqLen/(scale/HATCH_SCALE));\n    if (mag > 0.5) crossHatch = 1.0;\n    \n    fragColor = vec4(normalize(col)*background*(mag+min(crossHatch, round(mag*HATCH_LEVELS)/HATCH_LEVELS)+length(5.0*edge)), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}