{"ver":"0.1","info":{"id":"NdtcD8","date":"1653403384","viewed":209,"name":"Dodecaplex2","username":"afoksha","description":"Continue experiments with rendering regular 4-polytopes. Added ao. Tried to make it metallic.\n\n","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3sphere","poincarespace","binaryicosahedralgroup"],"hasliked":0,"parentid":"NtBfDc","parentname":"Dodecaplex"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==============================================================================================================================================================\n//  Created by Alexander Foksha\n//\n//  Do with this or without this code whatever you wish at your own risk.\n//  You have been warned !!\n//==============================================================================================================================================================\n\n#if 0\n\n/* =========================== Binary icosahedral group =========================== */\n\nconst vec4 BI[120] = vec4[]\n(\n    /* 4-vector with components {x, y, z, w} represents quaternion w + xi + yj + zk */\n\n    /* 8 basic unit quaternions :: ±1, ±i, ±j, ±k */\n    /* these eight elements form a subgroup S */\n    /*               g0 = */ vec4( 0.0,  0.0,  0.0,  1.0),      /* +1, order :: 1  */\n    /*               g1 = */ vec4( 0.0,  0.0,  0.0, -1.0),      /* -1, order :: 2  */\n    /*               g2 = */ vec4( 1.0,  0.0,  0.0,  0.0),      /* +i, order :: 4  */\n    /*               g3 = */ vec4(-1.0,  0.0,  0.0,  0.0),      /* -i, order :: 4  */\n    /*               g4 = */ vec4( 0.0,  1.0,  0.0,  0.0),      /* +j, order :: 4  */\n    /*               g5 = */ vec4( 0.0, -1.0,  0.0,  0.0),      /* -j, order :: 4  */\n    /*               g6 = */ vec4( 0.0,  0.0,  1.0,  0.0),      /* +k, order :: 4  */\n    /*               g7 = */ vec4( 0.0,  0.0, -1.0,  0.0),      /* -k, order :: 4  */\n\n    /* 16 unit Hurwitz quaternions */\n    /* these 16 elements together with first 8 form a subgroup H (Hurwitz subgroup) */\n    /* as a union of right conjugacy classes H = { S * g0, S * g8, S * g16 } */\n    /* as a point set they form vertices of the octaplex, self-dual 24-cell in spherical space */\n\n    /*   g8 =   1 *  g8 = */ vec4( 0.5,  0.5,  0.5,  0.5),      /* order :: 6  */\n    /*   g9 =  -1 *  g8 = */ vec4(-0.5, -0.5, -0.5, -0.5),      /* order :: 3  */\n    /*  g10 =   i *  g8 = */ vec4( 0.5,  0.5, -0.5, -0.5),      /* order :: 3  */\n    /*  g11 =  -i *  g8 = */ vec4(-0.5, -0.5,  0.5,  0.5),      /* order :: 6  */\n    /*  g12 =   j *  g8 = */ vec4(-0.5,  0.5,  0.5, -0.5),      /* order :: 3  */\n    /*  g13 =  -j *  g8 = */ vec4( 0.5, -0.5, -0.5,  0.5),      /* order :: 6  */\n    /*  g14 =   k *  g8 = */ vec4( 0.5, -0.5,  0.5, -0.5),      /* order :: 3  */\n    /*  g15 =  -k *  g8 = */ vec4(-0.5,  0.5, -0.5,  0.5),      /* order :: 6  */\n\n    /*  g16 =   1 * g16 = */ vec4( 0.5,  0.5,  0.5, -0.5),      /* order :: 3  */\n    /*  g17 =  -1 * g16 = */ vec4(-0.5, -0.5, -0.5,  0.5),      /* order :: 6  */\n    /*  g18 =   i * g16 = */ vec4(-0.5,  0.5, -0.5, -0.5),      /* order :: 3  */\n    /*  g19 =  -i * g16 = */ vec4( 0.5, -0.5,  0.5,  0.5),      /* order :: 6  */\n    /*  g20 =   j * g16 = */ vec4(-0.5, -0.5,  0.5, -0.5),      /* order :: 3  */\n    /*  g21 =  -j * g16 = */ vec4( 0.5,  0.5, -0.5,  0.5),      /* order :: 6  */\n    /*  g22 =   k * g16 = */ vec4( 0.5, -0.5, -0.5, -0.5),      /* order :: 3  */\n    /*  g23 =  -k * g16 = */ vec4(-0.5,  0.5,  0.5,  0.5),      /* order :: 6  */\n\n    /* the whole group B is a union of 5 conjugacy classes w.r.t subgroup H\n       B = { H * g0, H * g24, H * g48, H * g72, H * g96 } */\n\n    /*  g24 =  g0 * g24 = */ vec4( psi,  0.0,  0.5,  phi),      /* order :: 10 */\n    /*  g25 =  g1 * g24 = */ vec4(-psi,  0.0, -0.5, -phi),      /* order :: 5  */\n    /*  g26 =  g2 * g24 = */ vec4( phi, -0.5,  0.0, -psi),      /* order :: 5  */\n    /*  g27 =  g3 * g24 = */ vec4(-phi,  0.5,  0.0,  psi),      /* order :: 10 */\n    /*  g28 =  g4 * g24 = */ vec4( 0.5,  phi, -psi,  0.0),      /* order :: 4  */\n    /*  g29 =  g5 * g24 = */ vec4(-0.5, -phi,  psi,  0.0),      /* order :: 4  */\n    /*  g30 =  g6 * g24 = */ vec4( 0.0,  psi,  phi, -0.5),      /* order :: 3  */\n    /*  g31 =  g7 * g24 = */ vec4( 0.0, -psi, -phi,  0.5),      /* order :: 6  */\n    /*  g32 =  g8 * g24 = */ vec4( phi,  psi,  0.5,  0.0),      /* order :: 4  */\n    /*  g33 =  g9 * g24 = */ vec4(-phi, -psi, -0.5,  0.0),      /* order :: 4  */\n    /*  g34 = g10 * g24 = */ vec4( phi,  0.0, -psi,  0.5),      /* order :: 6  */\n    /*  g35 = g11 * g24 = */ vec4(-phi,  0.0,  psi, -0.5),      /* order :: 3  */\n    /*  g36 = g12 * g24 = */ vec4( psi, -0.5,  phi,  0.0),      /* order :: 4  */\n    /*  g37 = g13 * g24 = */ vec4(-psi,  0.5, -phi,  0.0),      /* order :: 4  */\n    /*  g38 = g14 * g24 = */ vec4( psi, -phi,  0.0,  0.5),      /* order :: 6  */\n    /*  g39 = g15 * g24 = */ vec4(-psi,  phi,  0.0, -0.5),      /* order :: 3  */\n    /*  g40 = g16 * g24 = */ vec4( 0.0,  phi,  0.5,  psi),      /* order :: 10 */\n    /*  g41 = g17 * g24 = */ vec4( 0.0, -phi, -0.5, -psi),      /* order :: 5  */\n    /*  g42 = g18 * g24 = */ vec4( 0.0,  0.5, -psi,  phi),      /* order :: 10 */\n    /*  g43 = g19 * g24 = */ vec4( 0.0, -0.5,  psi, -phi),      /* order :: 5  */\n    /*  g44 = g20 * g24 = */ vec4(-0.5,  0.0,  phi,  psi),      /* order :: 10 */\n    /*  g45 = g21 * g24 = */ vec4( 0.5,  0.0, -phi, -psi),      /* order :: 5  */\n    /*  g46 = g22 * g24 = */ vec4(-0.5, -psi,  0.0,  phi),      /* order :: 10 */\n    /*  g47 = g23 * g24 = */ vec4( 0.5,  psi,  0.0, -phi),      /* order :: 5  */\n\n    /*  g48 =  g0 * g48 = */ vec4(-psi,  0.0,  0.5,  phi),      /* order :: 10 */\n    /*  g49 =  g1 * g48 = */ vec4( psi,  0.0, -0.5, -phi),      /* order :: 5  */\n    /*  g50 =  g2 * g48 = */ vec4( phi, -0.5,  0.0,  psi),      /* order :: 10 */\n    /*  g51 =  g3 * g48 = */ vec4(-phi,  0.5,  0.0, -psi),      /* order :: 5  */\n    /*  g52 =  g4 * g48 = */ vec4( 0.5,  phi,  psi,  0.0),      /* order :: 4  */\n    /*  g53 =  g5 * g48 = */ vec4(-0.5, -phi, -psi,  0.0),      /* order :: 4  */\n    /*  g54 =  g6 * g48 = */ vec4( 0.0, -psi,  phi, -0.5),      /* order :: 3  */\n    /*  g55 =  g7 * g48 = */ vec4( 0.0,  psi, -phi,  0.5),      /* order :: 6  */\n    /*  g56 =  g8 * g48 = */ vec4( 0.5,  0.0,  phi,  psi),      /* order :: 10 */\n    /*  g57 =  g9 * g48 = */ vec4(-0.5,  0.0, -phi, -psi),      /* order :: 5  */\n    /*  g58 = g10 * g48 = */ vec4( 0.5,  psi,  0.0,  phi),      /* order :: 10 */\n    /*  g59 = g11 * g48 = */ vec4(-0.5, -psi,  0.0, -phi),      /* order :: 5  */\n    /*  g60 = g12 * g48 = */ vec4( 0.0, -phi,  0.5,  psi),      /* order :: 10 */\n    /*  g61 = g13 * g48 = */ vec4( 0.0,  phi, -0.5, -psi),      /* order :: 5  */\n    /*  g62 = g14 * g48 = */ vec4( 0.0, -0.5, -psi,  phi),      /* order :: 10 */\n    /*  g63 = g15 * g48 = */ vec4( 0.0,  0.5,  psi, -phi),      /* order :: 5  */\n    /*  g64 = g16 * g48 = */ vec4(-psi,  0.5,  phi,  0.0),      /* order :: 4  */\n    /*  g65 = g17 * g48 = */ vec4( psi, -0.5, -phi,  0.0),      /* order :: 4  */\n    /*  g66 = g18 * g48 = */ vec4(-psi,  phi,  0.0,  0.5),      /* order :: 6  */\n    /*  g67 = g19 * g48 = */ vec4( psi, -phi,  0.0, -0.5),      /* order :: 3  */\n    /*  g68 = g20 * g48 = */ vec4(-phi, -psi,  0.5,  0.0),      /* order :: 4  */\n    /*  g69 = g21 * g48 = */ vec4( phi,  psi, -0.5,  0.0),      /* order :: 4  */\n    /*  g70 = g22 * g48 = */ vec4(-phi,  0.0, -psi,  0.5),      /* order :: 6  */\n    /*  g71 = g23 * g48 = */ vec4( phi,  0.0,  psi, -0.5),      /* order :: 3  */\n\n    /*  g72 =  g0 * g72 = */ vec4( 0.0,  0.5,  psi,  phi),      /* order :: 10 */\n    /*  g73 =  g1 * g72 = */ vec4( 0.0, -0.5, -psi, -phi),      /* order :: 5  */\n    /*  g74 =  g2 * g72 = */ vec4( phi, -psi,  0.5,  0.0),      /* order :: 4  */\n    /*  g75 =  g3 * g72 = */ vec4(-phi,  psi, -0.5,  0.0),      /* order :: 4  */\n    /*  g76 =  g4 * g72 = */ vec4( psi,  phi,  0.0, -0.5),      /* order :: 3  */\n    /*  g77 =  g5 * g72 = */ vec4(-psi, -phi,  0.0,  0.5),      /* order :: 6  */\n    /*  g78 =  g6 * g72 = */ vec4(-0.5,  0.0,  phi, -psi),      /* order :: 5  */\n    /*  g79 =  g7 * g72 = */ vec4( 0.5,  0.0, -phi,  psi),      /* order :: 10 */\n    /*  g80 =  g8 * g72 = */ vec4( psi,  0.5,  phi,  0.0),      /* order :: 4  */\n    /*  g81 =  g9 * g72 = */ vec4(-psi, -0.5, -phi,  0.0),      /* order :: 4  */\n    /*  g82 = g10 * g72 = */ vec4( phi,  0.5,  0.0,  psi),      /* order :: 10 */\n    /*  g83 = g11 * g72 = */ vec4(-phi, -0.5,  0.0, -psi),      /* order :: 5  */\n    /*  g84 = g12 * g72 = */ vec4( 0.0, -psi,  phi,  0.5),      /* order :: 6  */\n    /*  g85 = g13 * g72 = */ vec4( 0.0,  psi, -phi, -0.5),      /* order :: 3  */\n    /*  g86 = g14 * g72 = */ vec4( 0.5, -psi,  0.0,  phi),      /* order :: 10 */\n    /*  g87 = g15 * g72 = */ vec4(-0.5,  psi,  0.0, -phi),      /* order :: 5  */\n    /*  g88 = g16 * g72 = */ vec4(-0.5,  phi,  psi,  0.0),      /* order :: 4  */\n    /*  g89 = g17 * g72 = */ vec4( 0.5, -phi, -psi,  0.0),      /* order :: 4  */\n    /*  g90 = g18 * g72 = */ vec4( 0.0,  phi, -0.5,  psi),      /* order :: 10 */\n    /*  g91 = g19 * g72 = */ vec4( 0.0, -phi,  0.5, -psi),      /* order :: 5  */\n    /*  g92 = g20 * g72 = */ vec4(-phi,  0.0,  psi,  0.5),      /* order :: 6  */\n    /*  g93 = g21 * g72 = */ vec4( phi,  0.0, -psi, -0.5),      /* order :: 3  */\n    /*  g94 = g22 * g72 = */ vec4(-psi,  0.0, -0.5,  phi),      /* order :: 10 */\n    /*  g95 = g23 * g72 = */ vec4( psi,  0.0,  0.5, -phi),      /* order :: 5  */\n\n    /*  g96 =  g0 * g96 = */ vec4( 0.0, -0.5,  psi,  phi),      /* order :: 10 */\n    /*  g97 =  g1 * g96 = */ vec4( 0.0,  0.5, -psi, -phi),      /* order :: 5  */\n    /*  g98 =  g2 * g96 = */ vec4( phi, -psi, -0.5,  0.0),      /* order :: 4  */\n    /*  g99 =  g3 * g96 = */ vec4(-phi,  psi,  0.5,  0.0),      /* order :: 4  */\n    /* g100 =  g4 * g96 = */ vec4( psi,  phi,  0.0,  0.5),      /* order :: 6  */\n    /* g101 =  g5 * g96 = */ vec4(-psi, -phi,  0.0, -0.5),      /* order :: 3  */\n    /* g102 =  g6 * g96 = */ vec4( 0.5,  0.0,  phi, -psi),      /* order :: 5  */\n    /* g103 =  g7 * g96 = */ vec4(-0.5,  0.0, -phi,  psi),      /* order :: 10 */\n    /* g104 =  g8 * g96 = */ vec4( phi,  0.0,  psi,  0.5),      /* order :: 6  */\n    /* g105 =  g9 * g96 = */ vec4(-phi,  0.0, -psi, -0.5),      /* order :: 3  */\n    /* g106 = g10 * g96 = */ vec4( psi,  0.0, -0.5,  phi),      /* order :: 10 */\n    /* g107 = g11 * g96 = */ vec4(-psi,  0.0,  0.5, -phi),      /* order :: 5  */\n    /* g108 = g12 * g96 = */ vec4( 0.5, -phi,  psi,  0.0),      /* order :: 4  */\n    /* g109 = g13 * g96 = */ vec4(-0.5,  phi, -psi,  0.0),      /* order :: 4  */\n    /* g110 = g14 * g96 = */ vec4( 0.0, -phi, -0.5,  psi),      /* order :: 10 */\n    /* g111 = g15 * g96 = */ vec4( 0.0,  phi,  0.5, -psi),      /* order :: 5  */\n    /* g112 = g16 * g96 = */ vec4( 0.0,  psi,  phi,  0.5),      /* order :: 6  */\n    /* g113 = g17 * g96 = */ vec4( 0.0, -psi, -phi, -0.5),      /* order :: 3  */\n    /* g114 = g18 * g96 = */ vec4(-0.5,  psi,  0.0,  phi),      /* order :: 10 */\n    /* g115 = g19 * g96 = */ vec4( 0.5, -psi,  0.0, -phi),      /* order :: 5  */\n    /* g116 = g20 * g96 = */ vec4(-psi, -0.5,  phi,  0.0),      /* order :: 4  */\n    /* g117 = g21 * g96 = */ vec4( psi,  0.5, -phi,  0.0),      /* order :: 4  */\n    /* g118 = g22 * g96 = */ vec4(-phi, -0.5,  0.0,  psi),      /* order :: 10 */\n    /* g119 = g23 * g96 = */ vec4( phi,  0.5,  0.0, -psi)       /* order :: 5  */\n);\n\n#endif\n\n/* helper function :: exchanges the values if necessary so on return we have v0 <= v1 */\nvoid order(inout float v0, inout float v1)\n{\n    float vm = max(v0, v1);\n    v0 = min(v0, v1);\n    v1 = vm;\n}\n\n/* helper function :: smoothed minimum */\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n    return mix(b, a, h) - k * h * (1.0f - h);\n}\n\nconst float phi = 0.8090169943749474f;  /* (sqrt(5) + 1) / 4 = psi + 0.5 */\nconst float psi = 0.3090169943749474f;  /* (sqrt(5) - 1) / 4 */\n\nconst float pi = 3.14159265358979324f;\nconst float two_pi = 6.28318530717958648f;\nconst float inv_pi = 0.31830988618379067f;  /* 1 / pi */\nconst float gamma = 2.2f;\n\n/* const vec4 g24 = vec4( psi,  0.0,  0.5,  phi); */\n/* const vec4 g48 = vec4(-psi,  0.0,  0.5,  phi); */\n/* const vec4 g72 = vec4( 0.0,  0.5,  psi,  phi); */\n/* const vec4 g96 = vec4( 0.0, -0.5,  psi,  phi); */\n\n/* right multiplications by basic quaternions i, j, k */\nvec4 mulr_i(vec4 p) { return vec4(p.wz, -p.yx); }\nvec4 mulr_j(vec4 p) { return vec4(-p.z, p.wx, -p.y); }\nvec4 mulr_k(vec4 p) { return vec4(p.y, -p.x, p.w, -p.z); }\n\n/*             | vertices | edges |        2-faces |        3-cells  | */\n/* =================================================================== */\n/* SIMPLEX     |        5 |    10 |   10 triangles |   5 tetrahedra  | */\n/* TESSERACT   |       16 |    32 |   24 squares   |   8 cubes       | */\n/* ORTHOPLEX   |        8 |    24 |   32 triangles |  16 tetrahedra  | */\n/* OCTAPLEX    |       24 |    96 |   96 triangles |  24 octahedra   | */\n/* DODECAPLEX  |      600 |  1200 |  720 pentagons | 120 dodecahedra | */\n/* TETRAPLEX   |      120 |   720 | 1200 triangles | 600 tetrahedra  | */\n\n/* dot products are maximal when distances between points are minimal */\n\n/*\n   returns maximal dot product of p with the vertices of the octaplex\n   which, as a point set, coincide with the Hurwitz subgroup of the\n   binary icosahedral group\n\n   24 points\n*/\nvec4 octaplex_max_dp4(vec4 p)\n{\n    /* (xi + yj + zk + w) * g8 =\n       (xi + yj + zk + w) * (i + j + k + 1) / 2 =\n        { +xi +yj +zk +w } +\n        { +wi +zj -yk -x } +\n        { -zi +wj +xk -y } +\n        { +yi -xj +wk -z } =  p + s\n    */\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n\n    /* (xi + yj + zk + w) * g16 =\n       (xi + yj + zk + w) * (i + j + k - 1) / 2 =\n       -{ +xi +yj +zk +w }\n        { +wi +zj -yk -x } +\n        { -zi +wj +xk -y } +\n        { +yi -xj +wk -z } = -p + s\n    */\n    vec4 p16 = 0.5 * (s - p);\n\n    /* taking absolute value of the dot product computes minimum\n       distance to the pair of opposite points on the sphere */\n    return max(abs(p), max(abs(p8), abs(p16)));\n}\n\n/*\n    returns pair of maximal dot products of p with the vertices of the octaplex\n    these two maximal dot products always belong to different orthoplectic subsets\n*/\nvec2 octaplex_max_dp2(vec4 p)\n{\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n    vec4 p16 = 0.5 * (s - p);\n\n    vec4 q0 = abs(p);\n    vec4 q1 = abs(p8);\n    vec4 q2 = abs(p16);\n\n    q0.xy = max(q0.xy, q0.zw);\n    q1.xy = max(q1.xy, q1.zw);\n    q2.xy = max(q2.xy, q2.zw);\n\n    float s0 = max(q0.x, q0.y);\n    float s1 = max(q1.x, q1.y);\n    float s2 = max(q2.x, q2.y);\n\n    order(s0, s1);\n    order(s1, s2);      /* s2 is maximal */\n\n    s1 = max(s0, s1);   /* s1 is second maximal */\n\n    return vec2(s1, s2);\n}\n\nfloat octaplex_max_dp1(vec4 p)\n{\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n    vec4 p16 = 0.5 * (s - p);\n\n    vec4 dp = max(abs(p), max(abs(p8), abs(p16)));\n    dp.xy = max(dp.xy, dp.zw);\n    return max(dp.x, dp.y);\n}\n\n/*\nconst vec4 simplex[5] = vec4[]\n(\n    vec4(  mu,  mu,  mu, -0.25),\n    vec4(  mu, -mu, -mu, -0.25),\n    vec4( -mu,  mu, -mu, -0.25),\n    vec4( -mu, -mu,  mu, -0.25),\n    vec4( 0.0, 0.0, 0.0,   1.0)\n);\n*/\nconst float mu = 0.5590169943749474f;  /* sqrt(5) / 4 */\n\n/*\n   returns maximal dot product of p with the vertices of the simplex,\n   which does not fit into general scheme of working with binary icosahedral\n   group and quaternions, so we just compute distances directly, also note that\n   simplex is not symmetric about the origin, e.g if v is the vertex,\n   then -v is not, so absolute values of the dot products should not be taken\n\n   5 points\n*/\nfloat simplex_max_dp(vec4 p)\n{\n    float qw = 0.25f * p.w;\n    float gx = mu * p.x;\n    float gy = mu * p.y;\n    float gz = mu * p.z;\n\n    /* four dot products */\n    vec4 dp = vec4(\n         gx +  gy +  gz - qw,\n         gx + -gy + -gz - qw,\n        -gx +  gy + -gz - qw,\n        -gx + -gy +  gz - qw\n    );\n\n    dp.xy = max(dp.xy, dp.zw);\n\n    /* the 5th dot product is simply p.w */\n    return max(max(dp.x, dp.y), p.w);\n}\n\n/* returns pair of maximal dot products of p with the vertices of the simplex */\nvec2 simplex_max_dp2(vec4 p)\n{\n    float qw = 0.25f * p.w;\n    float gx = mu * p.x;\n    float gy = mu * p.y;\n    float gz = mu * p.z;\n\n    /* five dot products */\n    float q0 =  gx +  gy +  gz - qw;\n    float q1 =  gx + -gy + -gz - qw;\n    float q2 = -gx +  gy + -gz - qw;\n    float q3 = -gx + -gy +  gz - qw;\n    float q4 = p.w;\n\n    order(q0, q1);\n    order(q1, q2);\n    order(q2, q3);\n    order(q3, q4);      /* q4 is now second maximal */\n\n    q1 = max(q0, q1);\n    q3 = max(q2, q3);\n    q3 = max(q1, q3);   /* q3 is now second maximal */\n\n    return vec2(q3, q4);\n}\n\n/*\n   returns maximal dot product of p with the vertices of the orthoplex, which,\n   as a point set, coincide with basic quaternions { ±1, ±i, ±j, ±k }\n\n   8 points\n*/\nfloat orthoplex_max_dp(vec4 p)\n{\n    vec4 d = abs(p);\n    d.xy = max(d.xy, d.zw);\n    return max(d.x, d.y);\n}\n\n/* returns pair of maximal dot products of p with the vertices of the orthoplex */\nvec2 orthoplex_max_dp2(vec4 p)\n{\n    vec4 q = abs(p);\n    order(q.x, q.y);\n    order(q.y, q.z);\n    order(q.z, q.w);                /* q.w is now maximal */\n    q.z = max(q.z, max(q.x, q.y));  /* q.z is second maximal */\n    return q.zw;\n}\n\n/*\n   returns maximal dot product of p with the vertices of the tesseract, which,\n   as a point set, coincide with half-integral Hurwitz quaternions\n\n   16 points\n*/\nfloat tesseract_max_dp(vec4 p)\n{\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n    vec4 p16 = 0.5 * (s - p);\n    vec4 dp = max(abs(p8), abs(p16));\n    dp.xy = max(dp.xy, dp.zw);\n    return max(dp.x, dp.y);\n}\n\n/*\n    returns pair of maximal dot products of p with the vertices of the tesseract\n    these two maximal dot products always belong to different orthoplectic subsets\n*/\nvec2 tesseract_max_dp2(vec4 p)\n{\n    vec4 s = mulr_i(p) + mulr_j(p) + mulr_k(p);\n    vec4 p8 = 0.5 * (s + p);\n    vec4 p16 = 0.5 * (s - p);\n    vec4 dp0 = abs(p8);\n    vec4 dp1 = abs(p16);\n    dp0.xy = max(dp0.xy, dp0.zw);\n    dp1.xy = max(dp1.xy, dp1.zw);\n\n    float q0 = max(dp0.x, dp0.y);\n    float q1 = max(dp1.x, dp1.y);\n    return vec2(min(q0, q1), max(q0, q1));\n}\n\n/*\n   returns maximal dot product of p with the vertices of the tetraplex\n   which, as a point set, coincide with the elements of the whole binary\n   icosahedral group\n\n   120 points\n*/\n\nfloat tetraplex_max_dp(vec4 p)\n{\n    /* p * g24 =  psi * (p * i) + 0.5 * (p * k) + phi * p */\n    /* p * g48 = -psi * (p * i) + 0.5 * (p * k) + phi * p */\n    /* p * g72 =  0.5 * (p * j) + psi * (p * k) + phi * p */\n    /* p * g96 = -0.5 * (p * j) + psi * (p * k) + phi * p */\n\n    vec4 psi_p = psi * p;\n    vec4 half_p = 0.5f * p;\n\n    vec4 psi_pi = mulr_i(psi_p);\n    vec4 half_pj = mulr_j(half_p);\n    vec4 half_pk = mulr_k(half_p);\n    vec4 psi_pk = mulr_k(psi_p);\n    vec4 phi_p = psi_p + half_p;\n\n    vec4 p24 = phi_p + half_pk + psi_pi;\n    vec4 p48 = phi_p + half_pk - psi_pi;\n    vec4 p72 = phi_p + psi_pk  + half_pj;\n    vec4 p96 = phi_p + psi_pk  - half_pj;\n\n    vec4 q0 = octaplex_max_dp4(p);\n    vec4 q1 = octaplex_max_dp4(p24);\n    vec4 q2 = octaplex_max_dp4(p48);\n    vec4 q3 = octaplex_max_dp4(p72);\n    vec4 q4 = octaplex_max_dp4(p96);\n\n    vec4 d = max(q0, max(q1, max(q2, max(q3, q4))));\n    d.xy = max(d.xy, d.zw);\n    return max(d.x, d.y);\n}\n\n/*\n    returns pair of maximal dot products of p with the vertices of the tetraplex,\n    these two maximal dot products always belong to different octaplectic subsets\n*/\nvec2 tetraplex_max_dp2(vec4 p)\n{\n    vec4 psi_p = psi * p;\n    vec4 half_p = 0.5f * p;\n\n    vec4 psi_pi = mulr_i(psi_p);\n    vec4 half_pj = mulr_j(half_p);\n    vec4 half_pk = mulr_k(half_p);\n    vec4 psi_pk = mulr_k(psi_p);\n    vec4 phi_p = psi_p + half_p;\n\n    vec4 p24 = phi_p + half_pk + psi_pi;\n    vec4 p48 = phi_p + half_pk - psi_pi;\n    vec4 p72 = phi_p + psi_pk  + half_pj;\n    vec4 p96 = phi_p + psi_pk  - half_pj;\n\n    float q0 = octaplex_max_dp1(p);\n    float q1 = octaplex_max_dp1(p24);\n    float q2 = octaplex_max_dp1(p48);\n    float q3 = octaplex_max_dp1(p72);\n    float q4 = octaplex_max_dp1(p96);\n\n    order(q0, q1);\n    order(q1, q2);\n    order(q2, q3);\n    order(q3, q4);      /* q4 is now maximal */\n\n    q1 = max(q0, q1);\n    q3 = max(q2, q3);\n    q3 = max(q1, q3);   /* q3 is now second maximal */\n\n    return vec2(q3, q4);\n}\n\nfloat octa_sdf(vec4 p)\n{\n    vec2 dp = octaplex_max_dp2(p);\n    vec2 alpha = acos(min(dp, 1.0f));\n    float edge_sdf = alpha.x + alpha.y - 1.0495f;\n    float vertex_sdf = alpha.y - 0.077f;\n    return smin(edge_sdf, vertex_sdf, 0.005f);\n}\n\nfloat linked_octaplexi_sdf(vec4 p)\n{\n    vec4 psi_p = psi * p;\n    vec4 half_p = 0.5f * p;\n\n    vec4 psi_pi = mulr_i(psi_p);\n    vec4 half_pj = mulr_j(half_p);\n    vec4 half_pk = mulr_k(half_p);\n    vec4 psi_pk = mulr_k(psi_p);\n    vec4 phi_p = psi_p + half_p;\n\n    vec4 p24 = phi_p + half_pk + psi_pi;\n    vec4 p48 = phi_p + half_pk - psi_pi;\n    vec4 p72 = phi_p + psi_pk  + half_pj;\n    vec4 p96 = phi_p + psi_pk  - half_pj;\n\n    float q0 = octa_sdf(p);\n    float q1 = octa_sdf(p24);\n    float q2 = octa_sdf(p48);\n    float q3 = octa_sdf(p72);\n    float q4 = octa_sdf(p96);\n\n    return min(q0, min(q1, min(q2, min(q3, q4))));\n}\n\n//#define RENDER_SIMPLEX\n//#define RENDER_DUAL_SIMPLEX\n//#define RENDER_SIMPLEX_PAIR\n\n//#define RENDER_ORTHOPLEX\n//#define RENDER_DUAL_TESSERACT\n//#define RENDER_ORTHOPLEX_DUAL_TESSERACT_PAIR\n\n//#define RENDER_TESSERACT\n//#define RENDER_DUAL_ORTHOPLEX\n//#define RENDER_TESSERACT_DUAL_ORTHOPLEX_PAIR\n\n//#define RENDER_OCTAPLEX\n//#define RENDER_DUAL_OCTAPLEX\n//#define RENDER_OCTAPLEX_PAIR\n#define RENDER_LINKED_OCTAPLEXI\n\n//#define RENDER_TETRAPLEX\n//#define RENDER_DODECAPLEX\n\n/*\n   removing spheres in the centers of 3-cells of a 4-polyhedron is\n   the same as removing spheres around vertices of the dual 4-polyhedron,\n   so to render dodecaplex we use distance-to-vertices function of the\n   dual polyhedron, the tetraplex\n*/\n\n#if defined(RENDER_DUAL_SIMPLEX) || defined(RENDER_DUAL_ORTHOPLEX) || defined(RENDER_DUAL_TESSERACT) || defined(RENDER_DUAL_OCTAPLEX) || defined(RENDER_TETRAPLEX)\nfloat id = 1.0f;\n#else\nfloat id = 0.0f;\n#endif\n\nfloat sdf(vec4 p)\n{\n#if defined(RENDER_SIMPLEX)\n    /* simplex is self-dual */\n    float dp = clamp(simplex_max_dp(p), -1.0f, 1.0f);\n    float s = acos(dp);\n    return 1.108f - s;\n#elif defined(RENDER_DUAL_SIMPLEX)\n    vec2 dp = clamp(simplex_max_dp2(p), -1.0f, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.838f;\n    float v_sdf = a2 - 0.243f;\n    return smin(e_sdf, v_sdf, 0.005f);\n#elif defined(RENDER_SIMPLEX_PAIR)\n    vec2 dp = clamp(simplex_max_dp2(p), -1.0f, 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.838f;\n    float v_sdf = a2 - 0.243f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n    float sdf2 = 1.108f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n#elif defined(RENDER_ORTHOPLEX)\n    /* dual to orthoplex is tesseract */\n    float dp = min(tesseract_max_dp(p), 1.0f);\n    float s = acos(dp);\n    return 0.761f - s;\n#elif defined(RENDER_DUAL_TESSERACT)\n    vec2 dp = min(tesseract_max_dp2(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 0.812f * (a1 + a2 - 1.062f);\n    float v_sdf = a2 - 0.173f;\n    return smin(e_sdf, v_sdf, 0.005f);\n#elif defined(RENDER_ORTHOPLEX_DUAL_TESSERACT_PAIR)\n    vec2 dp = min(tesseract_max_dp2(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.062f;\n    float v_sdf = a2 - 0.173f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n    float sdf2 = 0.761f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n#elif defined(RENDER_TESSERACT)\n    /* dual to tesseract is orthoplex */\n    float dp = min(orthoplex_max_dp(p), 1.0f);\n    float s = acos(dp);\n    return 0.914f - s;\n#elif defined(RENDER_DUAL_ORTHOPLEX)\n    vec2 dp = min(orthoplex_max_dp2(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.584f;\n    float v_sdf = a2 - 0.181f;\n    return smin(e_sdf, v_sdf, 0.005f);\n#elif defined(RENDER_TESSERACT_DUAL_ORTHOPLEX_PAIR)\n    vec2 dp = min(orthoplex_max_dp2(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 1.584f;\n    float v_sdf = a2 - 0.181f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n    float sdf2 = 0.914f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n#elif defined(RENDER_OCTAPLEX)\n    /* octaplex is self-dual */\n    vec4 dp4 = octaplex_max_dp4(p);\n    dp4.xy = max(dp4.xy, dp4.zw);\n    float dp = min(max(dp4.x, dp4.y), 1.0f);\n    float s = acos(dp);\n    return 0.604f - s;\n#elif defined(RENDER_DUAL_OCTAPLEX)\n    vec2 dp = min(octaplex_max_dp2(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 1.211f * (a1 + a2 - 1.051f);\n    float v_sdf = a2 - 0.137f;\n    return smin(e_sdf, v_sdf, 0.005f);\n#elif defined(RENDER_OCTAPLEX_PAIR)\n    vec2 dp = min(octaplex_max_dp2(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = 1.211f * (a1 + a2 - 1.051f);\n    float v_sdf = a2 - 0.137f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);\n    float sdf2 = 0.604f - a2;\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n#elif defined(RENDER_LINKED_OCTAPLEXI)\n    return linked_octaplexi_sdf(p);\n#elif defined(RENDER_TETRAPLEX)\n    /*\n       here we do not want to compute the distance-to-600-points function, so we use different idea\n       that in the vicinity of tetraplex edges the sum of the two minimal distances will be slightly\n       greater than the length of the tetraplex edge, and is substantially greater everywhere else\n\n       the same we use to compute sdf for dual simplex and dual octaplex - the sum of the two minimal\n       distances to the vertices reaches minimum on the edges of the 4-polyhedron, so if one\n       subtracts slightly more than the length of the edge one gets a tube around the edge, where\n       sdf is negative\n    */\n    vec2 dp = min(tetraplex_max_dp2(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 0.631f;\n    float v_sdf = a2 - 0.091f;\n    return smin(e_sdf, v_sdf, 0.005f);                            /* tetraplex sdf */\n#elif defined(RENDER_DODECAPLEX)\n    /* dual to dodecaplex is tetraplex */\n    float dp = min(tetraplex_max_dp(p), 1.0f);\n    float s = acos(dp);\n    return 0.351f - s;\n#else /* RENDER BOTH */\n    vec2 dp = min(tetraplex_max_dp2(p), 1.0f);\n    float a1 = acos(dp.x);\n    float a2 = acos(dp.y);\n    float e_sdf = a1 + a2 - 0.631f;\n    float v_sdf = a2 - 0.091f;\n    float sdf1 = smin(e_sdf, v_sdf, 0.005f);                      /* tetraplex sdf  */\n    float sdf2 = 0.351f - a2;                                     /* dodecaplex sdf */\n    id = step(sdf1, sdf2);\n    return min(sdf1, sdf2);\n#endif\n}\n\n/* ambient occlusion : from this website */\nfloat ambient_occlusion(vec4 p, vec4 n) \n{\n    const int ao_iterations = 16;\n    const float ao_step = 0.01f;\n    const float ao_scale = 7.5f;\n    \n\tfloat sum = 0.0f;\n\tfloat att = 1.0f;\n\tfloat l = ao_step;\n    \n\tfor (int i = 0; i < ao_iterations; ++i) \n    {\n\t\tsum += (l - sdf(p * cos(l) + n * sin(l))) * att;\n\t\t\n\t\tl += ao_step;\n\t\t\n\t\tatt *= 0.75f;\n\t}\n\t\n\treturn max(1.0f - sum * ao_scale, 0.0f);\n}\n\n//==============================================================================================================================================================\n//   SDF gradient :: 4-point tetrahedral evaluation\n//\n//   A good thing is that 3-sphere is a parallelizable manifold, so that at any point\n// one can explicitly specify tangent basis triple, which smoothly varies with the point\n//\n//   Such a basis for example is: { p*i, p*j, p*k }\n//==============================================================================================================================================================\nvec4 spherical_gradient4(vec4 p)\n{\n    const float eps = 0.0525f;\n\n    vec4 pi = mulr_i(p);\n    vec4 pj = mulr_j(p);\n    vec4 pk = mulr_k(p);\n\n    float v0 = sdf(normalize(p + eps * (+ pi - pj - pk)));\n    float v1 = sdf(normalize(p + eps * (- pi - pj + pk)));\n    float v2 = sdf(normalize(p + eps * (- pi + pj - pk)));\n    float v3 = sdf(normalize(p + eps * (+ pi + pj + pk)));\n\n    vec3 g = normalize(\n        vec3(\n              v0 - v1 - v2 + v3,\n            - v0 - v1 + v2 + v3,\n            - v0 + v1 - v2 + v3\n        )\n    );\n\n    return g.x * pi + g.y * pj + g.z * pk;\n}\n\n//==============================================================================================================================================================\n//   SDF gradient :: standard 6-point evaluation\n//==============================================================================================================================================================\nvec4 spherical_gradient6(vec4 p)\n{\n    const float eps = 0.0125f;\n\n    vec4 pi = mulr_i(p);\n    vec4 pj = mulr_j(p);\n    vec4 pk = mulr_k(p);\n\n    float norm = sqrt(1.0 + eps * eps);\n    float inv_norm = 1.0f / norm;\n    float f = eps * inv_norm;\n    vec4 pn = inv_norm * p;\n\n\n    float di = sdf(pn + f * pi) - sdf(pn - f * pi);\n    float dj = sdf(pn + f * pj) - sdf(pn - f * pj);\n    float dk = sdf(pn + f * pk) - sdf(pn - f * pk);\n\n    vec3 g = normalize(vec3(di, dj, dk));\n    return g.x * pi + g.y * pj + g.z * pk;\n}\n\nvec4 raymarch(vec4 origin, vec4 ray, out float dist)\n{\n    const float eps = 0.00005f;\n    dist = -1.0f;\n\n    vec4 p = origin;\n    float d = sdf(p);\n    float t = 0.0f;\n\n    while (t < two_pi && d > eps)\n    {\n        t += d;\n        p = cos(t) * origin + sin(t) * ray;\n        d = sdf(p);\n    }\n\n    if (d < eps)\n        dist = t;\n\n    return p;\n}\n\n/* p and n are assumed perpendicular and lie on the unit sphere */\nvec3 sample_tex4d(sampler2D sampler, sampler2D nrm_sampler, vec4 p, vec4 n,\n    out vec4 b, out float roughness, out float metalness)\n{\n    /* we use the same idea as the idea going around for 3d case -- \n       sample in all planes and blend with appropriate weights */\n    const float scale = 7.0f;\n\n    /* we have 6 possible planes xy, yz, zw, wz, xz and yw */\n    vec3 rgb_xy = texture(sampler, scale * p.xy).rgb;\n    vec3 rgb_yz = texture(sampler, scale * p.yz).rgb;\n    vec3 rgb_zw = texture(sampler, scale * p.zw).rgb;\n    vec3 rgb_wx = texture(sampler, scale * p.wx).rgb;\n    vec3 rgb_xz = texture(sampler, scale * p.xz).rgb;\n    vec3 rgb_yw = texture(sampler, scale * p.yw).rgb;\n\n    /* normal in RG, roughness in B, metalness in A */\n    vec4 nrm_xy = texture(nrm_sampler, scale * p.xy);\n    vec4 nrm_yz = texture(nrm_sampler, scale * p.yz);\n    vec4 nrm_zw = texture(nrm_sampler, scale * p.zw);\n    vec4 nrm_wx = texture(nrm_sampler, scale * p.wx);\n    vec4 nrm_xz = texture(nrm_sampler, scale * p.xz);\n    vec4 nrm_yw = texture(nrm_sampler, scale * p.yw);\n    \n    /* projections of the area element spanned by vectors p and n \n       onto 6 coordinate planes are */\n       \n    vec3 area_012 = p.xyz * n.yzw - p.yzw * n.xyz; /* xy, yz and zw */\n    vec3 area_345 = p.wxy * n.xzw - p.xzw * n.wxy; /* wx, xz and yw */   \n    \n    /* when the shaded fragment position { x, y, z, w } varies, it varies in such a way \n       that the differential in the neighbourhood stays orthogonal to both n and p directions, \n       so samples in 'perpendicular' planes should obtain higher weights, which means, in terms \n       of areas, the lower the area the higher should be the weight \n       \n       also note, that sum of squares of elements of area_012 and area_345 should \n       add to 1 = the square of the area element spanned by p and n\n    */\n    \n    const float tau = 7.0f;\n    area_012 = exp(-tau * area_012 * area_012);\n    area_345 = exp(-tau * area_345 * area_345);\n    \n    /* blending axes with the same weights as colors were blended with \n       somehow works */\n    vec4 X = vec4(area_012.xy + area_345.yz, area_012.z, area_345.x);\n    vec4 Y = vec4(area_345.x, area_012.x, area_012.yz + area_345.yz);\n\n    X -= dot(X, p) * p;\n    X -= dot(X, n) * n;\n    X = normalize(X);\n\n    Y -= dot(Y, p) * p;\n    Y -= dot(Y, n) * n;\n    Y = normalize(Y);\n\n    float w = dot(area_012 + area_345, vec3(1.0f));     /* total weight */\n    float inv_w = 1.0f / w;\n\n    vec4 Q = inv_w * (area_012.x * nrm_xy +\n                      area_012.y * nrm_yz +\n                      area_012.z * nrm_zw +\n                      area_345.x * nrm_wx +\n                      area_345.y * nrm_xz +\n                      area_345.z * nrm_yw);\n                      \n    roughness = Q.b;\n    metalness = Q.a;\n\n    Q.rg = 2.0f * Q.rg - 1.0f;\n    float z = sqrt(max(1.0f - dot(Q.rg, Q.rg), 0.0f));\n    b = Q.r * X + Q.g * Y + z * n;\n    b = normalize(b);\n\n    return inv_w * (area_012.x * rgb_xy + \n                    area_012.y * rgb_yz +\n                    area_012.z * rgb_zw +\n                    area_345.x * rgb_wx +\n                    area_345.y * rgb_xz +\n                    area_345.z * rgb_yw);\n}\n\nconst int LIGHT_COUNT = 8;\n\nconst vec4 light_ws[LIGHT_COUNT] = vec4[]\n(\n    vec4( 0.0f,  0.0f,  0.0f,  1.0f),\n    vec4( 1.0f,  0.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  1.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  0.0f,  1.0f,  0.0f),\n    vec4( 0.0f,  0.0f,  0.0f, -1.0f),\n    vec4(-1.0f,  0.0f,  0.0f,  0.0f),\n    vec4( 0.0f, -1.0f,  0.0f,  0.0f),\n    vec4( 0.0f,  0.0f, -1.0f,  0.0f)\n);\n\nfloat smootherstep(float edge0, float edge1, float x)\n{\n    float t = clamp((x - edge0) / (edge1 - edge0), 0.0f, 1.0f);\n    return t * t * t * ((6.0f * t - 15.0f) * t + 10.0f);\n}\n\nfloat DistributionGGX(float cos_phi, float roughness)\n{\n    float a = roughness * roughness;\n    float a_sqr = a * a;\n    float cos_phi_sqr = cos_phi * cos_phi;\n    float q = (cos_phi_sqr * (a_sqr - 1.0f) + 1.0f);\n    return a_sqr / (pi * q * q);\n}\n\nfloat GeometrySchlickGGX(float cos_angle, float roughness)\n{\n    float r = 1.0f + roughness;\n    float k = 0.125f * r * r;\n    return cos_angle / (cos_angle * (1.0f - k) + k);\n}\n\nfloat GeometrySmith(float cos_theta, float cos_gamma, float roughness)\n{\n    return GeometrySchlickGGX(cos_theta, roughness) * GeometrySchlickGGX(cos_gamma, roughness);\n}\n\nvec3 fresnel_schlick(float cos_alpha, vec3 F0)\n{\n    return F0 + (1.0f - F0) * pow(1.0f - cos_alpha, 5.0f);\n}\n\nvec3 fresnel_schlick_roughness(float cos_theta, vec3 F0, float roughness)\n{\n    return F0 + (max(vec3(1.0f - roughness), F0) - F0) * pow(1.0f - cos_theta, 5.0f);\n}\n\nconst vec3 albedo_silver   = vec3(0.971519f, 0.959915f, 0.915324f);\nconst vec3 albedo_gold     = vec3(1.000000f, 0.765557f, 0.336057f);\nconst vec3 albedo_copper   = vec3(0.955008f, 0.637427f, 0.538163f);\nconst vec3 albedo_chromium = vec3(0.549585f, 0.556114f, 0.554256f);\nconst vec3 albedo_nickel   = vec3(0.659777f, 0.608679f, 0.525649f);\nconst vec3 albedo_titanium = vec3(0.541931f, 0.496791f, 0.449419f);\nconst vec3 albedo_cobalt   = vec3(0.662124f, 0.654864f, 0.633732f);\nconst vec3 albedo_platinum = vec3(0.672411f, 0.637331f, 0.585456f);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 1.83f * (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n\n    float t = 0.5f * iTime;\n\n    float t0 = 0.375f * t -  0.213f;\n    float t1 = 0.151f * t +  2.091f;\n    float t2 = 0.253f * t - 11.512f;\n    float t3 = 0.853f * t +  3.277f;\n\n    float c0 = cos(t0);\n    float s0 = sin(t0);\n    float c1 = cos(t1);\n    float s1 = sin(t1);\n    float c2 = cos(t2);\n    float s2 = sin(t2);\n    float c3 = cos(t3);\n    float s3 = sin(t3);\n\n    /* if anyone knows how to smoothly fly through without entering areas\n       with sdf < 0 let me know */\n\n    vec4 camera_ws = vec4(-c1 * s0, s1 *  c0 * s2, c0 * c2, s0 * s1);\n    camera_ws = normalize(camera_ws);\n\n    vec4 X = mulr_i(camera_ws);\n    vec4 Y = mulr_j(camera_ws);\n\n    vec4 camera_X =  c3 * X + s3 * Y;\n    vec4 camera_Y = -s3 * X + c3 * Y;\n    vec4 camera_Z = mulr_k(camera_ws);\n\n    vec4 view_ray = uv.x * camera_X + uv.y * camera_Y - camera_Z;\n    view_ray = normalize(view_ray);\n\n    float dist;\n    vec4 position = raymarch(camera_ws, view_ray, dist);\n    vec3 color = vec3(0.0f);\n\n    if (dist >= 0.0f)\n    {\n        /*\n           normal, view, and light vectors should be tangent at 'position' point on the sphere\n           for the light calculations to make sense, which actually means that they must be normal\n           to 'position' viewed as 4-vectors\n\n           !! view_ray can not be used as a view vector because it is tangent at 'camera_ws'\n           point, but we need a vector tangent at 'position' point\n        */\n\n        bool dual = id > 0.0f;                      /* save the value as normal computation will modify it */\n        vec4 normal = spherical_gradient6(position);\n        \n        vec4 b;\n        float roughness;\n        float metalness;\n        \n        vec3 rgb = sample_tex4d(iChannel0, iChannel1, position, normal, \n            b, roughness, metalness);\n\n        // albedo_silver\n        // albedo_gold\n        // albedo_copper\n        // albedo_chromium\n        // albedo_nickel\n        // albedo_titanium\n        // albedo_cobalt\n        // albedo_platinum\n        \n        vec3 metal_albedo = dual ? albedo_gold : albedo_copper;\n        vec3 albedo = mix(metal_albedo, rgb, roughness);\n        normal = b;\n\n        /* some pseudo-scientific computations from online OpenGL pbr tutorials */\n        vec3 F0 = vec3(0.04f);\n        F0 = mix(F0, albedo, metalness);\n\n        vec4 view = normalize(camera_ws - dot(camera_ws, position) * position);\n        float ao = ambient_occlusion(position, normal);\n        float cos_gamma = clamp(dot(normal, view), 0.0f, 1.0f);\n\n        vec3 F = fresnel_schlick_roughness(cos_gamma, F0, roughness);\n        vec3 kS = F;\n        vec3 kD = 1.0f - kS;\n        kD *= 1.0f - metalness;\n        \n        /* TODO :: raymarch in the normal direction to get environment color */\n        vec3 diffuse = albedo;\n        vec3 specular = 0.45f * F + 0.05f;\n        vec3 ambient = 0.171f * exp(-2.27f * dist) * ao * (kD * diffuse + specular);\n\n        /* for now ambient term looks like a crap, something to be done here, \n           or, since the final result is more or less acceptable, maybe ambient term\n           should be like this ? */\n           \n        color = ambient;                            \n        vec3 R = vec3(0.0f);                        /* will accumulate inputs from all light sources */\n        \n        for (int i = 0; i < LIGHT_COUNT; ++i)\n        {\n            vec4 light = light_ws[i];\n            float dp = dot(light, position);\n            light = light - dp * position;\n            light = normalize(light);\n            vec4 h = normalize(light + view);       /* should be orthogonal to position as both light and view are */\n\n            vec3 radiance = vec3(1.0f);             /* light color */\n            float intensity = 1.07f * (0.5f + 0.5f * dp) * exp(-2.47f * dist);\n\n            float cos_theta = clamp(dot(normal, light), 0.0f, 1.0f);\n            float cos_alpha = clamp(dot(h, view), 0.0f, 1.0f);\n            float cos_phi   = clamp(dot(normal, h), 0.0f, 1.0f);\n\n            float NDF = DistributionGGX(cos_phi, roughness);\n            float G = GeometrySmith(cos_theta, cos_gamma, roughness);\n            vec3 F = fresnel_schlick(cos_alpha, F0);\n            vec3 specular = (NDF * G * F) / (4.0f * cos_gamma * cos_theta + 0.001f);\n\n            vec3 kS = F;\n            vec3 kD = vec3(1.0f) - kS;\n            kD *= 1.0f - metalness;\n\n            R += (inv_pi * kD * albedo + specular) * radiance * (intensity * cos_theta);\n        }\n        \n        color += R;\n       \n        //color = ambient;\n        //color = diffuse;\n        //color = specular;\n        //color = vec3(roughness);\n        //color = vec3(metalness);\n    }\n\n    /* everyone does it, i will do it also */\n    color = color / (1.0f + color);\n    color = sqrt(color);\n\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/* ============================== normal generation ============================== */\n\nconst vec3 rgb_power = vec3(0.299f, 0.587f, 0.114f);\n\nfloat luminosity(sampler2D sampler, vec2 uv, int lod)\n{\n    return dot(textureLod(sampler, uv, float(lod)).rgb, rgb_power);\n}\n\nvec3 symm_diff(sampler2D sampler, vec2 uv, int lod)\n{\n    const float amplitude = 2.7f;\n    \n    vec2 texel_size = 1.0f / vec2(textureSize(iChannel0, lod));\n\n    vec2 uv0 = uv;\n    vec2 uvp = uv + texel_size;\n    vec2 uvm = uv - texel_size;\n\n    float b = luminosity(sampler, vec2(uv0.x, uvm.y), lod);             /* bottom */\n    float l = luminosity(sampler, vec2(uvm.x, uv0.y), lod);             /* left   */\n    float r = luminosity(sampler, vec2(uvp.x, uv0.y), lod);             /* right  */\n    float t = luminosity(sampler, vec2(uv0.x, uvp.y), lod);             /* top    */\n\n    vec2 dL = vec2(r - l, t - b);\n    vec3 n = vec3(amplitude * dL, 1.0);\n    return normalize(n);\n}\n\nconst int MAX_LOD = 8;\nconst float lod_intensity[MAX_LOD] = float[]\n(\n    1.001f,\n    2.774f,\n    2.549f,\n    1.363f,\n    0.924f,\n    0.673f,\n    0.297f,\n    0.125f\n);\n\n/* ============================== roughness generation ============================== */\nconst float two_pi = 6.28318530717958648f;\n\nfloat hash(uint a, uint b, uint q)\n{\n    a *= uint(9629);\n    b *= uint(7853);\n    a += uint(10709) * q;\n    b += uint(11311) * q;    \n    a = (a ^ uint(61)) ^ b;\n    b = b + (a << 3);\n    a = a ^ (b >> 4);\n    b = a * uint(0x27d4eb2d);\n    a = b ^ (a >> 15);\n    a = a & uint(0xFFFF);\n    return float(a) / 65535.0;\n}\n\nconst float roughness_intensity[MAX_LOD] = float[]\n(\n    0.075f,\n    0.374f,\n    0.949f,\n    1.263f,\n    0.724f,\n    0.373f,\n    0.102f,\n    0.057f\n);\n\nfloat roughness(sampler2D sampler, vec2 uv, int lod)\n{\n    const float amplitude = 140.0f;\n    \n    float h = hash(uint(uv.x * iResolution.x), uint(uv.y * iResolution.y), uint(lod));\n    float alpha = two_pi * h;\n    \n    vec2 texel_size = 3.781f * vec2(cos(alpha), sin(alpha)) / vec2(textureSize(iChannel0, lod));\n\n    vec2 uv0 = uv;\n    vec2 uvp = uv + h * texel_size;\n    vec2 uvm = uv - h * texel_size;\n    \n    float c = luminosity(sampler, uv, lod);                             /* center */\n\n    float b = luminosity(sampler, vec2(uv0.x, uvm.y), lod);             /* bottom */\n    float l = luminosity(sampler, vec2(uvm.x, uv0.y), lod);             /* left   */\n    float r = luminosity(sampler, vec2(uvp.x, uv0.y), lod);             /* right  */\n    float t = luminosity(sampler, vec2(uv0.x, uvp.y), lod);             /* top    */\n\n    float q = min(\n                 min(abs(b - c), abs(l - c)),\n                 min(abs(r - c), abs(t - c))\n              );\n\n    return amplitude * q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 A = normalize(texture(iChannel0, uv, 16.0f).rgb);\n    vec3 T = texture(iChannel0, uv).rgb;  \n    \n    /* ==================================================== */\n    vec3 n = vec3(0.0f);\n    \n    for (int l = 0; l < MAX_LOD; ++l)\n        n += lod_intensity[l] * symm_diff(iChannel0, uv, l);\n    \n    n = normalize(n);\n\n    /* ==================================================== */\n    const float min_r = 0.05f;\n    float r = 0.0f;\n    for (int l = 0; l < MAX_LOD; ++l)\n        r += roughness_intensity[l] * roughness(iChannel0, uv, l);\n\n    r *= length(A - T);\n    r = (min_r + r) / (1.0f + r);\n    \n    /* ==================================================== */\n    float max_m = 0.97f;\n    float m = max_m * pow(1.0f - r, 2.2f);\n\n    fragColor = vec4(0.5f + 0.5f * n.x, 0.5f + 0.5f * n.y, r, m);\n    //fragColor = vec4(0.5f + 0.5f * n, 1.0f);\n    //fragColor = vec4(vec3(r), 1.0f);\n    //fragColor = vec4(vec3(m), 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"}]}