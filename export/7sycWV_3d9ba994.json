{"ver":"0.1","info":{"id":"7sycWV","date":"1655625472","viewed":145,"name":"Lava Volcano","username":"fenix","description":"+-*/ count, up/down arrow spawn rate. This is my attempt to accelerate particle rendering. Buffer B compute the particles needed for a 4x4 pixel cell, which we can then use to render. You can render up to 9999 but your graphics card might overheat :).","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["3d","collision","simulation","particles","physics","integration","multipass"],"hasliked":0,"parentid":"NdVcRG","parentname":"Spark Volcano w/ Count"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Lava Volcano SDF\" by fenix. https://shadertoy.com/view/NdyyRt\n// 2022-06-16 07:08:11\n\n// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Multipass particle physics simulation, colliding with a voxel grid. The number of\n//  particles is dynamic and depends on frame rate. You may want to raise TARGET_FRAME_TIME\n//  in Buffer A on lower end devices.\n//\n//  Particles are attenuated by 2D distance to line segment for motion blur.\n// \n//  Buffer A computes the particle positions\n//  Buffer B computes the particle velocities\n//  Buffer C renders the background with depth in the w component\n//\n// ---------------------------------------------------------------------------------------\n\n#define DIFFUSE_PER_PARTICLE 1\n\n//thanks to PrzemyslawZaworski and his https://www.shadertoy.com/view/4sBfRd for text rendering:\n//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C(c) U.x-=.5; fragColor+= char(U,64+c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel3, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).xxxx;\n}\n\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\nvoid renderParticle(in vec4 newPos, in vec4 oldPos, in float zDist, in vec3 groundPos, in vec4 normalAndZ, in mat4 w2cNew, in vec2 p, inout vec4 fragColor)\n{\n    if (newPos.w < 8.0) return;\n    \n#if DIFFUSE_PER_PARTICLE\n    const float GLOW_INTENSITY = 0.5;\n    vec3 groundDelta = oldPos.xyz - groundPos.xyz;\n    float groundDotParticle = dot(groundDelta, normalAndZ.xyz);\n\n    if (groundDotParticle > 0.001)\n    {\n        float distToGround = length(groundDelta);\n        float glow = GLOW_INTENSITY * normalize(groundDotParticle) / (distToGround * distToGround * distToGround);\n        vec3 glowTemp  = BlackBody(MAX_TEMP * 1.0 * (1.0  / 1.5));\n        fragColor = min(vec4(1.0, 1.0, 1.0, 1.0), fragColor + vec4(glow * glowTemp, 0.0));\n    }\n#endif // DIFFUSE_PER_PARTICLE\n\n    // convert to camera space\n    vec3 oldPosCamera = (w2cNew * vec4(oldPos.xyz,1.0)).xyz;\n    oldPosCamera.xy = oldPosCamera.xy / oldPosCamera.z;\n    vec3 newPosCamera = (w2cNew * vec4(newPos.xyz,1.0)).xyz;\n    newPosCamera.xy = newPosCamera.xy / newPosCamera.z;\n\n    // if in front of clipping plane\n    if(oldPosCamera.z > 0.01 && newPosCamera.z > 0.01 && zDist > oldPosCamera.z && zDist > newPosCamera.z)\n    {\n        vec2 pDelta = (p - oldPosCamera.xy);\n        vec2 cameraDelta = newPosCamera.xy - oldPosCamera.xy;\n        float cameraDeltaLen = dot(cameraDelta, cameraDelta);\n\n        // Find the closest point on the line segment from old to new\n        vec2 closest;\n        if (cameraDeltaLen > 0.0001)\n        {\n            float cameraDeltaInvSqrt = inversesqrt(cameraDeltaLen);\n            vec2 cameraDeltaNorm = cameraDelta * cameraDeltaInvSqrt;\n            closest = oldPosCamera.xy + cameraDeltaNorm * max(0.0, min(1.0 / cameraDeltaInvSqrt, dot(cameraDeltaNorm, pDelta)));\n        }\n        else\n        {\n            closest = oldPosCamera.xy;\n        }\n\n        // Distance to closest point on line segment\n        float dist = distance(closest, p);\n\n        const float PARTICLE_SIZE = 0.05;\n        float particleTemp = max(0.0, PARTICLE_SIZE - dist) * newPos.w * 1.9 / PARTICLE_SIZE;\n\n        if (dist < PARTICLE_SIZE)\n        {\n            //fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n            fragColor += vec4(BlackBody(particleTemp * 1.4), 0);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec4 normalAndZ = texelFetch(iChannel2, ivec2(fragCoord), 0);\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    CalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    float zDist = normalAndZ.w;\n\tconst vec3 reverseLightDir = normalize(vec3(1.0,2.0,3.0));\n\tconst vec3 lightColor = vec3(0.5,0.5,0.5);\t\n\tconst vec3 ambientColor = vec3(0.05,0.05,0.05);\n\n    // diffuse\n\tvec3 groundColor = ambientColor;\n\tfloat dp = dot(normalAndZ.xyz, reverseLightDir);\n\tif(dp > 0.0)\n\t\tgroundColor += (dp * lightColor);\n    \n    // specular\n    vec3 reflection = reflect(reverseLightDir, normalAndZ.xyz);\n    dp = dot(cameraFwd, reflection);\n    if (dp > 0.0)\n    {\n        groundColor += pow(abs(dp), 15.0) * vec3(0.5);\t\t\n    }  \n       \n    const vec3 sdfColor = vec3(0.3, 0.3, 0.3);\n    const vec3 sdfGlow = vec3(8.0, 0.0, 0.0);\n\tvec3 rayDir = CalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    ivec2 cell = getCell(fragCoord);\n\n    fragColor = vec4(groundColor, 0.0) * smoothstep(-140.0, -70.0, -zDist);\n\n    vec4 particleInfo = loadValue(PARTICLE_INFO);\n    float particleBegin = particleInfo.x;\n    float particleEnd = particleInfo.y;\n    float particleMax = iResolution.x * iResolution.y;\n    int particleCount = int(mod(particleEnd - particleBegin, particleMax));\n\n#if 1\n    // camera-to-world and world-to-camera transform\n    mat4 c2wNew = mat4(vec4(-0.5*iResolution.y / iResolution.x * cameraLeft, 0.0),\n        vec4(-0.5*cameraUp, 0.0),\n        vec4(cameraFwd, 0.0),\n        vec4(cameraPos, 1.0));\n    mat4 w2cNew = inverse(c2wNew);\n          \n#if DIFFUSE_PER_PARTICLE\n\t//vec3 rayDir = CalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n    vec3 groundPos = cameraPos + rayDir * zDist;\n#endif // DIFFUSE_PER_PARTICLE\n\n    for (int particleY = 0; particleY < CELL_SIZE; ++particleY)\n    {\n        for (int particleX = 0; particleX < CELL_SIZE; ++particleX)\n        {\n            float particleId;\n            vec4 newPos, oldPos;\n\n#define RENDER_PARTICLE_1(X) \\\n            particleId = getCellParticleData(cell, ivec2(particleX, particleY), iChannel1).X; \\\n            if (particleId == -1.0) break; \\\n            newPos = getParticleData(int(particleId), PARTICLE_POS); \\\n            oldPos = getParticleData(int(particleId), PARTICLE_PREV_POS); \\\n            renderParticle(newPos, oldPos, zDist, groundPos, normalAndZ, w2cNew, p, fragColor);\n\n            RENDER_PARTICLE_1(x);\n            RENDER_PARTICLE_1(y);\n            RENDER_PARTICLE_1(z);\n            RENDER_PARTICLE_1(w);\n        }\n    }\n    for (int particleY = 0; particleY < CELL_SIZE; ++particleY)\n    {\n        for (int particleX = 0; particleX < CELL_SIZE; ++particleX)\n        {\n            float particleId;\n            vec4 newPos, oldPos;\n\n#define RENDER_PARTICLE_2(X) \\\n            particleId = getCellParticleData(cell, ivec2(particleX, particleY), iChannel3).X; \\\n            if (particleId == -1.0) break; \\\n            newPos = getParticleData(int(particleId), PARTICLE_POS); \\\n            oldPos = getParticleData(int(particleId), PARTICLE_PREV_POS); \\\n            renderParticle(newPos, oldPos, zDist, groundPos, normalAndZ, w2cNew, p, fragColor);\n\n            RENDER_PARTICLE_2(x);\n            RENDER_PARTICLE_2(y);\n            RENDER_PARTICLE_2(z);\n            RENDER_PARTICLE_2(w);\n        }\n    }\n#endif\n\n    //fragColor = texture(iChannel1, fragCoord);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float MAX_AGE = 10.0;\nconst float MAX_TEMP = 1000.0;\nconst float PARTICLE_MIN_Y = -100.0;\nconst float INIT_PARTICLES = 1500.0;\nconst float INIT_RESPAWN_RATE = 2.0;\n\nconst vec3 WORLD_MIN = vec3(-1000.0, -1000.0, -1000.0);\nconst vec3 WORLD_MAX = vec3( 1000.0,  1000.0,  1000.0);\n\n// Texture variables\nconst int PARTICLE_INFO = 0;\nconst int FIRST_ACTUAL_PARTICLE = 1;\n\n#define ifValuePixel(P) if (all(equal(ivec2(fragCoord), ivec2(P, 0))))\n#define storeValue(P, V) ifValuePixel(P) fragColor = V\n#define loadValue(P) texelFetch(iChannel0, ivec2(P, 0), 0)\n\n// Per-particle attributes\nconst int PARTICLE_POS = 0;\nconst int PARTICLE_PREV_POS = 1;\nconst int NUM_DATA_PER_PARTICLE = 2;\n\nint calcDataIndex(in int particle, in int dataType)\n{\n    return FIRST_ACTUAL_PARTICLE + (particle * NUM_DATA_PER_PARTICLE) + dataType;\n}\n\nvec2 calcDataAddress(in vec2 iResolution, in int particle, in int dataType)\n{\n    int index = calcDataIndex(particle, dataType);\n    float fi = float (index);\n    \n    return (vec2 (mod (fi, iResolution.x), floor (fi / iResolution.x)) + 0.5) / iResolution;\n}\n\nint calcParticleIndex(in vec2 fragCoord, in vec3 iResolution)\n{\n    return int(fragCoord.x) + int(fragCoord.y) * int(iResolution.x) - FIRST_ACTUAL_PARTICLE;\n}\n\nvec4 getParticleDataInternal(in sampler2D sampler, in vec2 iResolution, in int particle, in int dataType)\n{\n    vec2 address = calcDataAddress(iResolution, particle, dataType);\n//    return texelFetch(sampler, ivec2(address), 0).xyz; Why don't these work? Shouldn't they be faster?\n//    return textureLod(sampler, address, 0.0).xyz;\n  return texture (sampler, address);\n}\n\nconst int CELL_SIZE = 4;\n\n#define getParticleData(X, Y) getParticleDataInternal(iChannel0, iChannelResolution[0].xy, X, Y)\n\nivec2 getCell(in vec2 fragCoord)\n{\n    return ivec2(fragCoord) / ivec2(CELL_SIZE);\n}\n\nint calcCellDataIndex(in vec2 iResolution, in ivec2 cell, in ivec2 particle)\n{\n    return particle.x + cell.x * CELL_SIZE + (particle.y + CELL_SIZE * cell.y) * int(iResolution.x);\n}\n\nvec2 calcCellDataAddress(in vec2 iResolution, in ivec2 cell, in ivec2 particle)\n{\n    int index = calcCellDataIndex(iResolution, cell, particle);\n    float fi = float (index);\n    \n    return (vec2 (mod (fi, iResolution.x), floor (fi / iResolution.x)) + 0.5) / iResolution;\n}\n\nvec4 getCellParticleDataInternal(in sampler2D sampler, in vec2 iResolution, in ivec2 cell, in ivec2 particle)\n{\n    vec2 address = calcCellDataAddress(iResolution, cell, particle);\n//    return texelFetch(sampler, ivec2(address), 0).xyz;\n//    return textureLod(sampler, address, 0.0).xyz;\n  return texture (sampler, address);\n}\n\n#define getCellParticleData(X, Y, Z) getCellParticleDataInternal(Z, iChannelResolution[1].xy, X, Y)\n\nfloat distanceSquared(vec3 a, vec3 b)\n{\n    vec3 delta = a - b;\n    return dot(delta, delta);\n}\n\nconst float PI = 3.1415926535;\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec4 p){\n    const float scale = pow(2., -32.);\n    uvec4 h = hash(uvec4(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\nconst float SQRT3 = 1.7320;\n\nvoid CalcCamera(in float iTime, in vec4 iMouse, in vec3 iResolution, out vec3 cameraLookAt, out vec3 cameraPos, out vec3 cameraFwd, out vec3 cameraLeft, out vec3 cameraUp)\n{\n    cameraLookAt = vec3(-15.0, -15.0f, -15.0);\n    float animate = iTime * 0.1 + 8.0 * iMouse.x / iResolution.x;\n    cameraPos = vec3(2.0 * cos(animate), -cos(animate) + SQRT3 * sin(animate), -cos(animate) - SQRT3 * sin(animate)) * 40.0\n    + vec3(20.0, 20.0, 20.0);\n    \n    cameraFwd  = normalize(cameraLookAt - cameraPos);\n    cameraLeft  = -normalize(cross(cameraFwd, vec3(1.0,1.0,1.0)));\n    cameraUp   = normalize(cross(cameraLeft, cameraFwd)) * 0.5;\n}\n\nvec3 CalcRay(in vec2 fragCoord, in vec3 iResolution, in vec3 cameraFwd, in vec3 cameraUp, in vec3 cameraLeft)\n{\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 1.0 - 0.5;\n\treturn normalize(cameraFwd - screenPos.x * cameraLeft - screenPos.y * cameraUp);\n}\n\nbool voxelSphere(ivec3 c, vec3 center, float r)\n{\n    return distanceSquared(center, vec3(c)) < r * r;\n}\n\nconst float COS45 = 0.7071;\nconst float SQRT2 = 1.4142;\n\nbool voxelSkewMountain(ivec3 c, vec3 peak, float height, float r)\n{\n    vec3 p = vec3(c);\n    vec3 axis = vec3(0.0, 1.0, 1.0) * SQRT2;\n    p = cross(axis, p) * COS45 + axis * dot(axis, p) * (1.0 - COS45) - peak;\n    return p.y < smoothstep(0.0, r, length(p.xz)) * -height;\n}\n\nbool voxelBox(ivec3 c, vec3 center, vec3 halfExtents)\n{\n    return all(lessThan(abs(center - vec3(c)), halfExtents));\n}\n\nbool voxelScene(ivec3 c)\n{\n    bool inVoxel = \n        voxelSkewMountain(c, vec3(1.0, 0.0, 0.0), 80.0, 70.0)\n            && !voxelSphere(c, vec3(1.0, -1.0, -1.0), 15.0)\n            && !voxelSphere(c, vec3(-2.0, -12.0, -3.0), 7.0)\n            && !voxelSphere(c, vec3(3.0, -20.0, 1.0), 11.0)\n        || voxelSkewMountain(c, vec3(20.0, -20.0, -20.0), 80.0, 70.0);\n    \n    return inVoxel;\n}\n\nbool getVoxel(ivec3 c)\n{\n    return voxelScene(c)\n    || (voxelScene(c - ivec3(1, 1, 1)) && noise(c).x < 0.5);\n}\n\nconst int MAX_RAY_STEPS = 250;\n\nvec4 IntersectRayVoxel(in vec3 rayPos, in vec3 rayDir)\n{\n\tivec3 mapPos = ivec3(floor(rayPos + 0.));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n    ivec3 rayStep = ivec3(sign(rayDir));\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n    bool hit = false;\n\t\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n\t\tif (getVoxel(mapPos))\n        {\n            hit = true;\n            \n            break;\n        }\n\n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n\t\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n\t}\n\t\n    if (!hit)\n    {\n        return vec4(0.0, 0.0, 0.0, 1000000000.0);\n    }\n    \n\tvec3 normal;\n    float perpWallDist;\n\tif (mask.x) {\n\t\tnormal = vec3(1.0, 0.0, 0.0);\n        perpWallDist = sideDist.x - deltaDist.x;\n\t}\n\tif (mask.y) {\n\t\tnormal = vec3(0.0, 1.0, 0.0);\n        perpWallDist = sideDist.y - deltaDist.y;\n\t}\n\tif (mask.z) {\n\t\tnormal = vec3(0.0, 0.0, 1.0);\n        perpWallDist = sideDist.z - deltaDist.z;\n\t}\n    \n    float zDist = dot(vec3(mapPos) - rayPos, rayDir);\n\treturn vec4(normal, perpWallDist);\n}\n\nvec3 BlackBody(float _t)\n{\n#if 1\n    vec3 temp = vec3(min(1.0, _t / MAX_TEMP), min(1.0, _t / (2.0 * MAX_TEMP)), min(1.0, _t / (3.0 * MAX_TEMP)));\n    return temp * temp * temp * temp;\n#else\n    // From https://www.shadertoy.com/view/MslSDl (but commented out)\n    \n    // See: http://en.wikipedia.org/wiki/Planckian_locus\n    //      under \"Approximation\"\n    \n    float u = (0.860117757 + 1.54118254e-4*_t + 1.28641212e-7*_t*_t)\n        / (1.0 + 8.42420235e-4*_t + 7.08145163e-7*_t*_t);\n    \n    float v = (0.317398726 + 4.22806245e-5*_t + 4.20481691e-8*_t*_t)\n        / (1.0 - 2.89741816e-5*_t + 1.61456053e-7*_t*_t);\n    \n    // http://en.wikipedia.org/wiki/CIE_1960_color_space\n    // -> http://en.wikipedia.org/wiki/XYZ_color_space\n    \n    float x = 3.0 * u / (2.0 * u - 8.0 * v + 4.0);\n    float y = 2.0 * v / (2.0 * u - 8.0 * v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = (Y/y) * x;\n    float Z = (Y/y) * z;\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    mat3 XYZtosRGB = mat3(\n         3.2404542,-1.5371385,-0.4985314,\n        -0.9692660, 1.8760108, 0.0415560,\n         0.0556434,-0.2040259, 1.0572252\n    );\n    \n    vec3 RGB = vec3(X,Y,Z) * XYZtosRGB;\n    return RGB * pow(0.0004*_t, 4.0);\n#endif\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n// Computes the position of each particle, one per texture fragment.\n//\n// Also maintains the particle count in coordinate 0, 0, raising it when the frame rate is\n// good and lowering it when the frame rate is not.\n// ---------------------------------------------------------------------------------------\n\nconst vec3 GRAVITY = vec3(-1.0, -1.0, -1.0);\n\n#define ENABLE_PARTICLE_PARTICLE_INTERACTIONS 1\n#define ENABLE_VOXEL_COLLISIONS 1\n\nfloat UpdateParticleCount(float particleCount)\n{\n    if (keyDown(107))\n    {\n        particleCount++;\n    }\n    if (keyDown(109))\n    {\n        particleCount--;\n    }\n    if (keyDown(106))\n    {\n        particleCount += 100.0;\n    }\n    if (keyDown(111))\n    {\n        particleCount -= 100.0;\n    }\n    if (particleCount < 0.0)\n    {\n        particleCount = 0.0;\n    }\n    if (particleCount > 9999.0)\n    {\n        particleCount = 9999.0;\n    }\n    \n    return particleCount;\n}\n\nfloat UpdateRespawnRate(float respawnRate)\n{\n    if (keyDown(40))\n    {\n        respawnRate -= 0.1;\n    }\n    if (keyDown(38))\n    {\n        respawnRate += 0.1;\n    }\n    if (respawnRate < 0.0)\n    {\n        respawnRate = 0.0;\n    }\n\n    return respawnRate;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float particleMax = iResolution.x * iResolution.y;\n\n    // Update the particle count\n    ifValuePixel(PARTICLE_INFO)\n    {\n        if (iFrame < 5)\n        {\n            fragColor = vec4(0.0, INIT_PARTICLES, INIT_RESPAWN_RATE, 0.0);\n        }\n        else\n        {\n            vec4 oldParticleInfo = loadValue(PARTICLE_INFO);\n            \n            float particleBegin = oldParticleInfo.x;\n            float particleEnd = oldParticleInfo.y;\n            float particleCount = mod(particleEnd - particleBegin, particleMax);\n\n            particleCount = UpdateParticleCount(particleCount);\n            \n            float respawnRate = oldParticleInfo.z;\n            float newParticleEnd = mod(particleEnd + respawnRate, particleMax);\n            float newParticleBegin = mod(newParticleEnd - particleCount, particleMax);\n\n            float newRespawnRate = UpdateRespawnRate(respawnRate);\n            \n            float showControls = oldParticleInfo.w;\n            if (keyClick(32)) showControls = 1.0 - showControls;\n            \n            fragColor = vec4(newParticleBegin, newParticleEnd, newRespawnRate, showControls);\n        }\n        \n        return;\n    }\n\n    vec4 particleInfo = loadValue(PARTICLE_INFO);\n    float particleBegin = particleInfo.x;\n    float particleEnd = particleInfo.y;\n    int respawnRate = int(particleInfo.z);\n\n    vec4 newPosAndTemp;\n    int mId;\n    vec2 kv = floor (fragCoord);\n    mId = int (kv.x + iResolution.x * kv.y) - FIRST_ACTUAL_PARTICLE;\n    int pId = mId / 2;\n    if (kv.x >= iResolution.x) discard;//\n    vec4 oldPosAndTemp = getParticleData(pId, PARTICLE_POS);\n    vec3 oldPos = oldPosAndTemp.xyz;\n    if (iFrame == 0)\n    {\n        newPosAndTemp.xyz = oldPos = WORLD_MIN;\n        newPosAndTemp.w = MAX_TEMP;\n    }\n    else\n    {\n        if (((int(particleEnd) - pId) % int(particleMax)) <= respawnRate)\n        {\n            const vec3 INIT_CENTER = vec3(-6.0, -9.0, -6.0);\n            const vec3 INIT_EXTENTS = vec3(0.2, 0.2, 0.2);\n            vec3 initPos = (noise(ivec4(int(fragCoord.x) / 2, fragCoord.y, int(fragCoord.x) / 2 + 2, fragCoord.y + 2.0)).xyz - 0.5) * INIT_EXTENTS + INIT_CENTER;\n\n            newPosAndTemp.xyz = oldPos = initPos;\n            newPosAndTemp.w = MAX_TEMP;\n        }\n        else\n        {\n            vec3 olderPos = getParticleData(pId, PARTICLE_PREV_POS).xyz;\n\n            newPosAndTemp.xyz = oldPos + (oldPos - olderPos) * 0.9 + GRAVITY * 0.033;\n            newPosAndTemp.w = 0.9995 * oldPosAndTemp.w;\n         }\n    }\n    \n#if ENABLE_PARTICLE_PARTICLE_INTERACTIONS\n    float minDist = 1e20;\n    int particleCount = int(mod(particleEnd - particleBegin, particleMax));\n    for (int otherParticle = 0; otherParticle < particleCount; ++otherParticle)\n    {\n        int otherParticleIndex = int(mod(particleBegin + float(otherParticle), particleMax));\n        if (otherParticleIndex != pId)\n        {\n            const float PARTICLE_REPEL = 0.3;\n            const float MAX_PARTICLE_REPEL = 0.3;\n            vec4 otherPosAndTemp = getParticleData(otherParticleIndex, PARTICLE_POS);\n            vec3 otherPos = otherPosAndTemp.xyz;\n            vec3 delta = otherPos - newPosAndTemp.xyz;\n            float dist = length(delta);\n            minDist = min(minDist, dist);\n            if (dist > 1e-6 && dist < 1.0)\n            {\n                //newPos -= PARTICLE_REPEL * (delta - 0.05);\n                newPosAndTemp.xyz -= min(MAX_PARTICLE_REPEL, PARTICLE_REPEL * (3.2 - smoothstep(0.0, 1.0, abs(dist - 1.0)))) * normalize(delta);\n                newPosAndTemp.w = mix(newPosAndTemp.w, otherPosAndTemp.w, 0.4);\n            }\n        }\n    }\n    \n    if (minDist > 3.0)\n    {\n        // Quickly cool particles that get too far away from other particles\n        newPosAndTemp.w *= 0.9;\n    }\n#endif\n\n#if ENABLE_VOXEL_COLLISIONS\n    // Detect if we're about to enter a voxel and bounce off\n    const int MAX_VOXEL_COLLISION_ITERS = 3;\n    for (int i = 0; i < MAX_VOXEL_COLLISION_ITERS; ++i)\n    {\n        ivec3 newMapPos = ivec3(floor(newPosAndTemp.xyz));\n\n        if (getVoxel(newMapPos))\n        {\n            vec3 direction = normalize(newPosAndTemp.xyz - oldPos);\n            vec4 rayHit = IntersectRayVoxel(oldPos, direction);\n            vec3 surfacePos = oldPos + direction * rayHit.w;\n            vec3 reflected = reflect(direction, rayHit.xyz);\n            newPosAndTemp.xyz = surfacePos + reflected * dot(direction, newPosAndTemp.xyz - surfacePos) * 0.6;\n        }\n        else\n        {\n            break;\n        }\n    }\n#endif\n\n    newPosAndTemp.xyz = clamp(newPosAndTemp.xyz, WORLD_MIN, WORLD_MAX);\n                                                    \n    vec4 valueToStore = (mId == pId * 2) ? newPosAndTemp : vec4(oldPos, 0.0);\n  \n    //storeParticleData(pId, PARTICLE_POS, valueToStore);\n    fragColor = valueToStore;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float PARTICLE_CULL_DISTANCE = 1.4;\n\nint imod(in int a, in int b) { return a-a/b*b; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 particleInfo = loadValue(PARTICLE_INFO);\n    float particleBegin = particleInfo.x;\n    float particleEnd = particleInfo.y;\n    float particleMax = iResolution.x * iResolution.y;\n    int particleCount = int(mod(particleEnd - particleBegin, particleMax));\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    CalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec2 adjustedCoord = floor(fragCoord / vec2(float(CELL_SIZE))) * vec2(float(CELL_SIZE)) + vec2(float(CELL_SIZE / 2));\n    vec3 rayDir = CalcRay(adjustedCoord, iChannelResolution[0], cameraFwd, cameraUp, cameraLeft);\n    \n    int positionInCell = imod(int(fragCoord.x), CELL_SIZE) + CELL_SIZE * imod(int(fragCoord.y), CELL_SIZE);\n    int computingCellPosition = 0;\n    \n    //vec4 closestParticles[16];\n    fragColor = vec4(-1.0);\n    int particleIds[4] = int[4]( -1, -1, -1, -1 );\n    int numParticleIds = 0;\n          \n    for (int particle = particleCount / 2; particle < particleCount; ++particle)\n    {\n        int particleIndex = int(mod(particleBegin + float(particle), particleMax));\n        vec4 particlePosAndTemp = getParticleData(particleIndex, PARTICLE_POS);\n        float t = dot(particlePosAndTemp.xyz - cameraPos, rayDir);\n        \n        // if in front of clipping plane\n        if (t > 0.0)\n        {\n            vec3 closest = cameraPos + rayDir * t;\n            vec3 delta = particlePosAndTemp.xyz - closest;\n            float dist2 = dot(delta, delta);\n            \n            if (dist2 < PARTICLE_CULL_DISTANCE * PARTICLE_CULL_DISTANCE)\n            {\n                particleIds[numParticleIds++] = particleIndex;\n                \n                if (numParticleIds == 4)\n                {\n                    if (computingCellPosition == positionInCell)\n                    {\n                         break;\n                    }\n\n                    ++computingCellPosition;\n\n                    if (computingCellPosition >= CELL_SIZE * CELL_SIZE)\n                    {\n                        return;\n                    }\n                    \n                    numParticleIds = 0;\n                }\n            }\n        }\n    }\n    \n    if (computingCellPosition == positionInCell && numParticleIds > 0)\n    {\n        fragColor = vec4(float(particleIds[0]), float(particleIds[1]), float(particleIds[2]), float(particleIds[3]));\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// ---------------------------------------------------------------------------------------\n// Background rendering inspired by \"Branchless Voxel Raycasting\" by fb39ca4\n//    https://www.shadertoy.com/view/4dX3zl\n//\n// Added zDist computation based on math from the source cited: https://lodev.org/cgtutor/raycasting.html\n// Resulting buffer contains (normal.x, normal.y, normal.z, zDist) for each pixel.\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    CalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec3 rayDir = CalcRay(fragCoord, iResolution, cameraFwd, cameraUp, cameraLeft);\n\t\t\t\n\tfragColor = IntersectRayVoxel(cameraPos, rayDir);\n}\n\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XdfGR8","channel":0}],"code":"const float PARTICLE_CULL_DISTANCE = 1.4;\n\nint imod(in int a, in int b) { return a-a/b*b; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 particleInfo = loadValue(PARTICLE_INFO);\n    float particleBegin = particleInfo.x;\n    float particleEnd = particleInfo.y;\n    float particleMax = iResolution.x * iResolution.y;\n    int particleCount = int(mod(particleEnd - particleBegin, particleMax));\n\n    vec3 cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp;\n    CalcCamera(iTime, iMouse, iResolution, cameraLookAt, cameraPos, cameraFwd, cameraLeft, cameraUp);\n\n    vec2 adjustedCoord = floor(fragCoord / vec2(float(CELL_SIZE))) * vec2(float(CELL_SIZE)) + vec2(float(CELL_SIZE / 2));\n    vec3 rayDir = CalcRay(adjustedCoord, iChannelResolution[0], cameraFwd, cameraUp, cameraLeft);\n    \n    int positionInCell = imod(int(fragCoord.x), CELL_SIZE) + CELL_SIZE * imod(int(fragCoord.y), CELL_SIZE);\n    int computingCellPosition = 0;\n    \n    //vec4 closestParticles[16];\n    fragColor = vec4(-1.0);\n    int particleIds[4] = int[4]( -1, -1, -1, -1 );\n    int numParticleIds = 0;\n          \n    for (int particle = 0; particle < particleCount / 2; ++particle)\n    {\n        int particleIndex = int(mod(particleBegin + float(particle), particleMax));\n        vec4 particlePosAndTemp = getParticleData(particleIndex, PARTICLE_POS);\n        float t = dot(particlePosAndTemp.xyz - cameraPos, rayDir);\n        \n        // if in front of clipping plane\n        if (t > 0.0)\n        {\n            vec3 closest = cameraPos + rayDir * t;\n            vec3 delta = particlePosAndTemp.xyz - closest;\n            float dist2 = dot(delta, delta);\n            \n            if (dist2 < PARTICLE_CULL_DISTANCE * PARTICLE_CULL_DISTANCE)\n            {\n                particleIds[numParticleIds++] = particleIndex;\n                \n                if (numParticleIds == 4)\n                {\n                    if (computingCellPosition == positionInCell)\n                    {\n                         break;\n                    }\n\n                    ++computingCellPosition;\n\n                    if (computingCellPosition >= CELL_SIZE * CELL_SIZE)\n                    {\n                        return;\n                    }\n                    \n                    numParticleIds = 0;\n                }\n            }\n        }\n    }\n    \n    if (computingCellPosition == positionInCell && numParticleIds > 0)\n    {\n        fragColor = vec4(float(particleIds[0]), float(particleIds[1]), float(particleIds[2]), float(particleIds[3]));\n    }\n}\n","name":"Buffer D","description":"","type":"buffer"}]}