{"ver":"0.1","info":{"id":"dd2czz","date":"1687380125","viewed":24,"name":"Concentric Metal Vortex","username":"thedarkbunny","description":"It's blue, it spins, that's about all I can say.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spiral","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415927\n#define TWOPI 6.2831853\n\n#define T_SCALE -0.02\n#define R_SCALE -0.5\n\nfloat iRidge(in float v){\n    v = clamp(v,0.,1.);\n    return 1. - (v * (1.-v) * 4.);\n\n}\n\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y * 2.;\n    \n    float dcf = length(uv);\n    float acf = fract(atan(uv.x,uv.y)/TWOPI);\n    \n    float di = floor(dcf*5.-0.5);\n    float df = fract(dcf*5.-0.5);\n    float as = di*2.+3.;\n    //float aso = 1./(as*2.+as*as)+0.618034*di*di + as*iTime/10.;\n    float aso = as*as*iTime*T_SCALE;\n    float as2 = di*2.+5.;\n    //float aso2 = 1./(as2*2.+as2*as2)+0.618034*(di+1.)*(di+1.)  + as2*iTime/10.;\n    float aso2 = as2*as2*iTime*T_SCALE;\n    \n    //float ai = floor(acf*as);\n    //float af = fract(acf*as+aso);\n    float af0 = acos( cos((acf*as+aso+df*R_SCALE)*TWOPI) )/TWOPI;\n    float af1 = acos( cos((acf*as2+aso2+df*R_SCALE)*TWOPI) )/TWOPI;\n    //float af = acos(cos( (acf*mix(as,as2,df)+mix(aso,aso2,df))*TWOPI ) )/TWOPI   ;\n    //float af = mix(af0,af1,smoothstep(0.,1.,df));\n    float af = 1.-sqrt((1.-af0)*(1.-af1));\n    //float af = (af0+af1)/2.;\n    \n    float rdf = iRidge(df);\n    float raf = iRidge(af);\n\n    \n    fragColor = vec4(rdf*raf,(rdf*raf+raf)/2.,raf,1.0);\n}\n\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n        //O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Image","description":"","type":"image"}]}