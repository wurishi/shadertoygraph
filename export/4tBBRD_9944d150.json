{"ver":"0.1","info":{"id":"4tBBRD","date":"1514718223","viewed":320,"name":"r3dux 3D Starfield Test 2","username":"r3dux","description":"31/12/2017 - First attempt at making a 3D starfield - only learnt how to use a little ShaderToy today, so the struggle is definitely real! ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 red = vec3(1.0, 0.1, 0.1);\nvec3 green = vec3(0.1, 1.0, 0.1);\nvec3 blue = vec3(0.1, 0.1, 1.0);\n\nfloat rand(float t)\n{\n    return fract(sin(t * 123.456) * 768.89);\n}\n\nvec3 rotateX(vec3 v, float angleRads)\n{ \n\tfloat c = cos(angleRads);\n    float s = sin(angleRads);\n  \treturn vec3(v.x, v.y * c - v.z * s, v.y * s + v.z * c);\n}\n\nvec3 rotateY(vec3 v, float angleRads)\n{ \n\tfloat c = cos(angleRads);\n    float s = sin(angleRads);\n  \treturn vec3(v.x * c + v.z * s, v.y, -v.x * s + v.z * c);\n}\n\nvec3 rotateZ(vec3 p, float angleRads) { \n\tfloat c = cos(angleRads);\n    float s = sin(angleRads);\n  \treturn vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);\n}\n\nfloat distanceFromPointToLine(vec3 rayOrigin, vec3 rayDirection, vec3 point)\n{\n\treturn length(cross(point - rayOrigin, rayDirection)) / length(rayDirection);   \n}\n\nvoid drawPoint(vec3 rayOrigin, vec3 rayDirection, vec3 point, float size, float blur, out vec4 fragColor, int starNum, float t)\n{\n    float dist = distanceFromPointToLine(rayOrigin, rayDirection, point);\n    \n    dist = smoothstep(size, size * (1.0 - blur), dist); // 2nd param means blur is always that percentage of point size\n                      \n    vec3 col = vec3(0.0);    \n    if (starNum % 3 == 0) { col = red;   }\n    if (starNum % 3 == 1) { col = green; }\n    if (starNum % 3 == 2) { col = blue;  }\n    \n    fragColor += vec4(vec3(dist * col), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // Range is 0 to 1    \n    uv -= vec2(0.5);                         // Adjust range to -0.5 to +0.5 so (0,0) is in centre of screen \n\tuv.x *= iResolution.x / iResolution.y;   // Correct aspect ratio\n    float t = iTime * 0.3;                   // Get the time and slow it down by multiplying by a small value\n    \n\tvec3 rayOrigin = vec3(0.0, 0.0, 0.0); // i.e. Camera origin\n    \n    vec3 lookAt = vec3(0.0, 0.0, 1); // Looking into the screen (negative on the Z-axis points outward from the screen)\n    \n    // Generate ortho camera normal basis using global Y-axis for up when generating right (positive X-axis) vector\n    float zoom = 1.0;\n    vec3 forward = normalize(lookAt - rayOrigin);\n    vec3 right = cross(vec3(0.0, 1.0, 0.0), forward);\n    vec3 up = cross(forward, right);\n    \n    vec3 centreOfScreen = rayOrigin + forward * zoom;     \n    vec3 intersection = centreOfScreen + uv.x * right + uv.y * up;        \n    vec3 rayDirection = intersection - rayOrigin;\n    \n    vec3 point = vec3(0.4, 0.4, 15.0);\n    \n    float pointSize = 0.1;\n    float pointBlur = 0.3;\n    \n    const float numParticles = 20.0;\n    float loopStep = 1.0 / numParticles;\n    int starNum = 0;\n    \n    float oneTenthRads = 6.28 / 10.0;\n    \n    for (int camTwistLoop = 0; camTwistLoop < 10; camTwistLoop++)\n    {\n    \n        for (float loop = 0.0; loop < 1.0; loop += loopStep)\n        {\n            float timeStepped = fract(t + loop);\n\n            drawPoint( rayOrigin, rayDirection, vec3(point.x, point.y, point.z - timeStepped * point.z), pointSize, pointBlur, fragColor, starNum++, t);\n        }\n        \n        point = rotateZ(point, oneTenthRads * t * 2.0);        \n    }\n}","name":"Image","description":"","type":"image"}]}