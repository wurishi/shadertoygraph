{"ver":"0.1","info":{"id":"7lXfz7","date":"1650642770","viewed":1019,"name":"Neon Futures","username":"Hyeve","description":"...well this turned out well. It's, not unexpectedly, very slow, so I've cut down quality significantly for better speed here.","likes":25,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","raymarching","transparency","glass","reflections","reflections","metal","metal","crystal3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec2 uv;\nvec3 cp,cn,cr,ss,oc,gl,vb,rp;\nvec4 fc,cc;\nfloat tt,cd,sd,md,io,oa,td,tc;\nint es=0,ec;\n\n\n\n//-------------- CHANGE THIS TO FALSE FOR HIGH QUALITY (but much slower)\n#define LOWQ true\n\n\nfloat bx(vec3 p,vec3 s){vec3 q=abs(p)-s;return min(max(q.x,max(q.y,q.z)),0.)+length(max(q,0.));}\n\nfloat h11 (float a){return fract(sin((a)*12.9898)*43758.5453123);}\n\nvec3 rdg = vec3(0);\nfloat dibox(vec3 p,vec3 b,vec3 rd){\n    vec3 dir = sign(rd)*b;   \n    vec3 rc = (dir-p)/rd;\n    return min(rc.x,rc.z); \n}\n\nfloat mp(vec3 p)\n{\n\t\tvec3 pp=p;\n\n\t\tp.z = mod(p.z, 25.);\n\t\n\t\tvec4 range = vec4(-25, 50, -25, 50);\n\t\n\t\tvec2 axis = p.xz;\n\t\n\t\tfloat id = 0.;\n\t\n\t\tvec2 diff = vec2(1);\n\t\n\t\tfor(float i = 1.; i < 5.; i++)\n\t\t{\n\t\t\tfloat shiftFreq = pow(i/5.,8.);\n\t\t\tfloat hash1 = tanh(sin(i*2.+tt+id)*shiftFreq*50.)*0.35+0.5;\n\t\t\tfloat hash2 = tanh(cos(i*3.+tt+id*3.)*shiftFreq*40.)*0.35+0.5;\t\t\t\n            vec2 pos = vec2(hash1, hash2) * 0.4 + 0.3;\n\t\t\tvec2 di=range.xz+range.yw*pos;\n\t\t\tdiff = step(p.xz,di)-vec2(h11(diff.x)*10.,h11(diff.y)*10.);\n\t\t\tid = length(diff)*100.0;\n            if(di.x<axis.x){range.y=range.x+range.y-di.x;range.x=di.x;}\n            else range.y=di.x-range.x;\n            if(di.y<axis.y){range.w=range.z+range.w-di.y;range.z=di.y;}\n            else range.w=di.y-range.z;  \n\t\t}\n\t\n\t\tp.xz -= range.xz + range.yw * 0.5;\n\t\t\n\t\tvec3 bs = vec3(range.y*0.5,1,range.w*0.5);\n\t\t\n\t\tfloat hid = h11(id);\n\t\t\n\t\tfloat h = (hid > 0.5 && length(range.x) > 5. && length(range.z) > 5.) ? clamp(h11(id+1.)*20.,5.,20.) : 1.;\n\t\t\n\t\tsd = bx(p,bs+vec3(-0.2,h+0.1,-0.2));\n        \n        vec2 pv = abs(p.xz) - bs.xz + vec2(0.3);\n        vec3 pvv = vec3(pv.x, p.y, pv.y);\n        \n        float ebx = bx(pvv,vec3(0.0,h+0.7,0.0))-0.18;\n        \n        sd = min(sd, ebx);\n\t\t\n\t\tfloat bound = abs(dibox(p, bs+vec3(0,h,0),rdg))+0.02;\n\t\t\n\t\tsd=min(sd, bound);\n\t\t\n\t\tfloat g = pp.y-1.95;\n\t\t\n\t\tgl += exp(-g*25.) * mix(vec3(0,0.4,1), vec3(0.5,0.2,1.),hid)*2.;\n\t\t\n\t\tfloat tb = bx(p - vec3(0,h+1.,0),bs+vec3(0,-0.99,0.));\n\t\t\n\t\tif(h>1.) gl += exp(-tb*3.) * mix(vec3(0.9,0.2,0.2), vec3(0.2,0.2,0.9),pow(hid,2.))*2.;\n\t\t\n\t\tvec3 pos = pp-rp-vec3(-1,0,50);\n\t\tpos.xz*=rot(tt*0.1);\n\t\tfloat bh = 15.+sin(tt*0.5);\n\t\tfloat bp = bx(pos,vec3(3.5,bh,3.5));\n\t\t\n\t\tfloat spire = length(pos-vec3(0,bh+2.,0)) - 6.5;\n\t\t\n\t\tpos.xz=abs(pos.xz) - 3.5;\n\t\tfloat bpe = bx(pos,vec3(0.01,bh,0.01))-0.05;\n\t\t\n\t\tsd =min(sd,spire);\n        \n        \n\t\tgl += exp(-bpe*5.) * vec3(0,0.5,1)*5.;\n\t\tsd = min(sd, bpe);\n\t\tsd = min(sd,bp);\n\t\tsd=min(sd,g);\n        \n        \n\t\tif(h>1.) sd=min(sd,tb);\n\n\t\tsd=abs(sd)-0.01;\n\n\t\tif(sd<0.06)\n\t\t{\t\n\t\t\tio=-1.;\n\t\t\toc=vec3(0.,0.,0.1);\n            float ran = pow(1.-pow(cos(tt*0.3)*0.5+0.5,5.),5.);\n\t\t\toa=spire<sd+0.1?0.1:mix(0.5,1.,1.-ran);\n            if(ebx<sd+0.1)oa=1.;\n\t\t\tss=vec3(0.);\n\t\t\tec=2;\t\n\t\t}\n\t\treturn sd;\n}\n\nvoid nm(){mat3 k=mat3(cp,cp,cp)-mat3((LOWQ?0.01:0.001));cn=normalize(mp(cp)-vec3(mp(k[0]),mp(k[1]),mp(k[2])));}\n\nfloat tr(vec3 ro, vec3 rd)\n{rdg=rd;cd=0.;md=64.;for(tc=1.;tc<(LOWQ?64.:256.);tc++){mp(cp=ro+rd*cd);cd+=sd;td+=sd;\nif(sd<md&&sd<cd-0.06)md=sd;if(sd<(LOWQ?0.01:0.0001)||cd>64.)break;}nm();return cd;}\n\n\nvoid px(vec3 rd)\n{\n  cc.rgb=vec3(0.,0.,0.1)+length(pow(abs(rd+vec3(0,0,0)),vec3(10)))*vec3(0.1,0.,0.1)+gl/tc;\n  if(cd>64.){cc.a=1.;return;}cc.a=oa;\n    vec3 ld = -normalize(cp+cn-vec3(10.,10,-20.+mod(tt*3.,25.)));\n  float df=clamp(length(cn*ld),0.,1.);\n  vec3 fr=pow(1.-abs(dot(rd,-cn)),3.)*mix(cc.rgb,vec3(0.4),0.3)*0.5;\n  cc.rgb=(oc*(df+fr+ss)+fr+gl/tc);tr(cp+cn*0.06,ld);\n\t\n}\n\nvec3 cam()\n{\n\treturn vec3(2.5,4,mod(tt*3.,25.));\n}\n\nvec3 look(vec3 ro)\n{\n\treturn ro + vec3(sin(tt*0.1)*0.05,sin(tt*0.2)*0.1+0.1,1);\n}\n\nvec3 ray(vec3 p, vec3 l, vec2 uv, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid render(vec2 frag, vec2 res, float time, out vec4 col)\n{\n  uv=vec2(frag.x/res.x,frag.y/res.y);\n  uv-=0.5;uv/=vec2(res.y/res.x,1);\n\ttt=mod(time,300.);\n  vec3 ro=rp=cam(),rd=ray(ro,look(ro),uv, 1.);\n\t\n\tfor(int i=0;i<(LOWQ?5:10);i++)\n  {\n\t\tfloat d=tr(ro,rd);\n\t\tro=cp-cn*(io<0.?-0.01:0.01);\n\t\tcr=refract(rd,cn,i%2==0?1./io:io);\n\t\ti=io<0.?i+1:i;\n    if((length(cr)==0.&&es<=0)||io<0.)\n\t\t{cr=reflect(rd,cn);es=(io<0.?es:ec);}\n\t\tpx(rd); if(max(es,0)%3==0&&d<64.)rd=cr;es--;\n\t\tfc=fc+vec4(cc.rgb*cc.a,cc.a)*(1.-fc.a);\n\t\tif(fc.a>=1.)break;\n  }\n  col = fc/fc.a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    render(fragCoord.xy,iResolution.xy,iTime,fragColor);\n}","name":"Image","description":"","type":"image"}]}