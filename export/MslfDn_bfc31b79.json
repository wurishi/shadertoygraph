{"ver":"0.1","info":{"id":"MslfDn","date":"1496115099","viewed":128,"name":"Learning Raymarching - fscur","username":"fscur","description":"learning raymarch","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 128\n#define FAR 5.0\n#define NEAR 1.0\n#define EPS 0.01\n#define time iTime\n#define PI 3.1416\n\nfloat lerp(float a, float b, float t)\n{\n\treturn a + t * (b - a);\n}\n\nvec2 hash2( vec2 p ) \n{  \t\t\t\t\t\t\n\tp = vec2(dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)));\n    \n\treturn -1.0 + 2.0 * fract(sin(p + 20.0) * 53758.5453123);\n}\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat hash1(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noisev( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\t//vec2 u = f*f*(3.0-2.0*f);\n\t\n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    return mix( mix( hash1( i + vec2(0.0,0.0) ), \n                     hash1( i + vec2(1.0,0.0) ), u.x),\n                mix( hash1( i + vec2(0.0,1.0) ), \n                     hash1( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise(in vec2 p)\n{\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n    \n    //grid points\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(1.0, 0.0);\n    vec2 p2 = vec2(0.0, 1.0);\n    vec2 p3 = vec2(1.0, 1.0);\n    \n    //distance vectors to each grid point\n    vec2 s0 = f - p0;\n    vec2 s1 = f - p1;\n    vec2 s2 = f - p2;\n    vec2 s3 = f - p3;\n    \n    //random gradient vectors on each grid point\n    vec2 g0 = hash(i + p0);\n    vec2 g1 = hash(i + p1);\n    vec2 g2 = hash(i + p2);\n    vec2 g3 = hash(i + p3);\n    \n    //gradient values\n    float q0 = dot(s0, g0);\n    float q1 = dot(s1, g1);\n    float q2 = dot(s2, g2);\n    float q3 = dot(s3, g3);\n    \n    //interpolant weights\n    //vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    \n    //bilinear interpolation\n    float l0 = lerp(q0, q1, u.x);\n    float l1 = lerp(q2, q3, u.x);\n    float l2 = lerp(l0, l1, u.y);\n    \n    return l2;\n}\n\nfloat fbm(vec2 uv, float persistence, int octaves) \n{\n    float total = 0.0;\n    float maxValue = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    \n    for(int i=0; i<octaves;++i)\n    {\n        total += noise(uv * frequency) * amplitude;\n        maxValue += amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n    }\n    \n    return total/maxValue;\n}\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n\treturn (a.x < b.x) ? a : b;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat sdSphere(vec3 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\nfloat sdPlane(vec3 p, float d)\n{\n    return p.y - d;\n}\n\nfloat sdOcean(vec3 p, float d)\n{\n    return p.y - d - (sin(p.x * 2.3 + iTime) * 0.05) - (sin(p.z * 2.3 - cos(iTime)) * 0.09);\n}\n\nfloat sdTerrain(vec3 p)\n{\n    float intensity = 3.0;\n    float spread = 1.0 / intensity;\n    return p.y - (fbm(p.xz * spread, 0.4, 8) * intensity);\n}\n\nvec2 map(in vec3 pos)\n{   \n    \n    vec2 res = opUnion(\n        \t\t\tvec2(sdOcean(pos, 0.0), 3.0),\n\t              \tvec2(sdTerrain(pos), 1.0));\n    \n    //res = opUnion(\n        \t\t\t//vec2(sdPlane(pos), 1.0),\n\t              \t//vec2(sdSphere(opRep(pos - vec3(0.0, 0.25, 0.0), vec3(0.0, 0.0, 0.0)), 0.25), 2.0));\n    \n    return res;\n    \n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float tmin = 0.5;\n    float tmax = 60.0;\n\tfloat t = tmin;\n    float m = 0.0;\n    \n    for (int i = 0; i < 128; ++i)\n    {\n        float precis = 0.0005 * t;\n    \tvec3 p = ro + rd * t;\n        \n        vec2 res = map(p);\n        \n        if (res.x < precis || t > tmax)\n            break;\n        \n        t += res.x * 0.5;\n        m = res.y;\n    }\n    \n\tif (t > tmax)\n        m = -1.0;\n    \n    return vec2(t, m);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nmat3 lookAt( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 bg = vec3(0.5, 0.4,0.3) + rd.y * 0.8;\n\tvec3 color = vec3(0.0);\n    \n    //float d = rayMarch(ro, rd, p);\n    \n    vec2 res = rayMarch(ro,rd);\n    float d = res.x;\n    vec3 pos = ro + rd * d;\n    \n    if (res.y == 1.0)\n    {\n        if (pos.y < 0.2)\n            color = vec3(0.5, 0.5, 0.0);\n        else if (pos.y < 0.7)\n            color = vec3(0.0, 0.5, 0.0);\n        else\n            color = vec3(1.0);\n            \n    }\n    else if (res.y == 2.0)\n    {\n        //float f = mod(floor(1.0 * pos.z) + floor(1.0 * pos.x), 2.0);\n        \n    \t\n       \t\n        color = vec3(pos.y);\n    } \n    else if (res.y == 3.0)\n    {\n    \tcolor = vec3(0.0, 0.5, 1.0);\n    }\n    \n    vec3 normal = calcNormal(pos);\n        float lighting = dot(normal, normalize(vec3(1.0)));\n        color *= lighting;\n    \n    float fog = 1.0 / (0.8 + d * d * 0.0015);\n    \n    return mix(color, bg, 1.0 - fog);\n    //return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float zoom = 15.0;\n    \n    vec3 ro = vec3(zoom * cos(mo.x * PI * 5.5), 1.5 + mo.y * zoom, zoom * sin(mo.x * PI * 5.5));\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n    mat3 ca = lookAt(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n    \n    \n    vec3 color = render(ro, rd);\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}