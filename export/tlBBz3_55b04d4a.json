{"ver":"0.1","info":{"id":"tlBBz3","date":"1599471233","viewed":670,"name":"5th Dimentional Flower 1.","username":"julianlumia","description":"Not really 5D I know:p still it looks kinda cool;)","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["creature"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n  vec4 col = T(uv);\n    col.xyz = 2.-texture(iChannel2, uv).xyz* .96 ;           \n\n    \n    float f = length(uv  - 0.5);\n    col.x = T(uv + f*0.001).x;\n    col.y = T(uv -f*0.001).y;\n    col.z = T(uv-f*0.06).z;\n    \n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define T (iTime*0.125)\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define pmod(p, x) mod(p, x) - 0.5*x\n#define lmod(d, x) (mod(d,x)/x - 0.5)\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define MAX_STEPS 64\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\n\nfloat displacement(vec3 p, float scale)\n{\n    return sin(scale*p.x)*sin(scale*p.y)*sin(scale*p.z);\n}\n\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\nfloat g5;\n\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nconst float PI = 3.14159265;\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nvec3 p7;\n\nvec2 path(float z){\n    float x = sin(z) + 2.0 * cos(z * 0.5) - 1.5 * sin(z * 0.12345);\n    float y = cos(z) + 2. * sin(z * 1.3) + .2 * cos(z * 2.12345);\n    return vec2(x,y);\n}\nmat2 E;\n\nvec3 spherepos;\n\n\n\nvec2 N(float angle)\n{\n return vec2(sin(angle),cos(angle));\n}\nvec3 text(vec2 t, vec3 p){\n vec3 o = vec3(0);\n float d = 10e6;\n t = pmod(t,1./.2);\n t *=2.;\n float yid = (floor( (p.y + 0.)*0. ) );\n float W = .2;\n float modd = 2.1;\n float sqD = max(abs(t.x), abs(t.y));\n sqD +=.5 + yid*0.4;\n float sqid = floor(sqD/modd);\n sqD = lmod(sqD, modd);  \n d = min(d, sqD);\n o +=  pal(0.6, vec3(1.,0.7,0.6)*0.5, vec3(8.4 ,4.19,7.4 - yid*0.2), vec3(3.,7.,3.),-1. + iTime + sqid*0.5 + p.z + t.x*2.5 - t.y*1.5);\n o *= step(sin(sqid*10.), -0.);\n float aa = 20.;\n sqD -= 0.5;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n sqD -= 1.;\n sqD = abs(sqD*1.);\n o -= exp(-sqD*aa)*1.;\n return o;\n}\n\n\n//float g1;\n#define time iTime\nvec2 mouse;\n//float PI = acos(-1.);\n\nfloat dBox(vec3 p, vec3 s)\n{\n return length (max (abs(p)-s,0.));    \t    \n}\n\nmat2 rot2d(float a) {\n float c = cos(a), s = sin(a);\n return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p, float s, float tf) {\n //float t = tf * time*0.01;\n    float f = sin(iTime*.3)-2.;\n for (int i = 0; i <2; i++) {\n   p.xy *= -rot2d(sin(f));\n   p.zy *= rot2d(f);\n   p.xz *= rot2d(f);\n   p =  (max (abs(p)-vec3(0.01,0.1,0.01),0.));  \n  // s *= 1. + .1 ;\n  }\n  return p;\n}\n\nvec3 tex3D(  in vec3 p, in vec3 n ){\n\n vec2 d =vec2(0.); \n float dp = dot(p,p*0.1)*.7;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot((iTime*.01));\n //    p.zx *=  Rot(iTime*.1-0.2);\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;\n vec3 q = (text(p.xy, p*1.)).xyz*1.;\n return q;\n}\n\n\n\nvec2 GetDist(vec3 p) {\n\n vec2 d =vec2(0.);\n vec3 q = p;\n float dp = dot(p,p*0.1)*.7;\n p = kifs(p, 1., 2.);\n p /= dp;\n p.xy*= Rot((iTime*.01));\n //p.zx *=  Rot(iTime*.1-0.2);\n p = rotate( ( vec3(cos(p.xzy*1.+iTime*1.) ) ), 300.)*p;\n p.z=sin(p-vec3(-T*tau*1.,-T*tau*2.,-T*tau*1.+sin(iTime)*1.)).z*.1;   \n d = vec2(sdBox(p,vec3(2.5)) + sdBox(q,vec3(0,0.,0.)),1);\n d.x *=1.;\n d.x =(((d.x*dp)/5.));\n g1 +=1./(.00001+pow(abs(d.x),4.));\n d = condmin( d,d);   \n vec2 d4 = d;  \n \n    p = q;\n float r = 3.14159*sin(p.z*0.4);//+cos(T*0.025*1.);\n E = mat2(cos(r), sin(r), -sin(r), cos(r));\n p.xy*= E;  \n float the =sin((p.z*.2 *.2));\n p.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 o = path(p.z) / 4.0;\n p = vec3(p.x,p.y,p.z)-vec3(o.x,o.y,0.);  \n the =sin((p.z*.1-iTime *.01));\n p.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec3 o5 = p;\n float gap =4.;\n p.z = mod(p.z + gap,2.0 * gap) - gap; \n p.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n d = vec2((p.y) +9.75,5);\n vec3 p4 = p;\n vec3 p2 = p;   \n p7 = p-vec3(sin(p.z*0.7)*0.2,-2.7,-.5);\n p7.z = mod(p7.z , 2.) - 1.;\n the = iTime; \n vec3 op = o5;\n gap =1.;\n the = sin(o5.z*1.+iTime*1.);  \n op.z = mod(op.z + gap,2.0 * gap) - gap; \n op.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec3 op1 = op;\n vec3 snakesize =vec3(.01,0.01,.01);   \n op =op-vec3(sin(o5.z*2.+iTime*0.)*.5,cos(o5.z*.1+iTime*0.3)+0.0*1.,1);\n vec2 box13 = vec2((sdBox(op, snakesize)),2.);\n vec2 box15 = vec2((sdBox(op1, vec3(0.05,0.1,1.))),2.);\n box13.x = min(box13.x,box15.x);\n box13.x*= 1.;\n d.x = smin(box15.x,box13.x,1.);\n d = condmin(d,d4);\n g2 +=.001/(.005+pow(abs(box13.x),3.));\n  d.x = smin(d4.x,box13.x,1.3);\n  \n return d;\n}\n\nvec2 RayMarch (vec3 ro, vec3 rd) \n {\n vec2 h, t=vec2( 0.);\n for (int i=0; i<MAX_STEPS; i++) \n  {\n h = GetDist(ro + t.x * rd);\n if(h.x<SURF_DIST||t.x>MAX_DIST) break;\n  t.x+=h.x*1.;\n  t.y=h.y;\n }\n if(t.x>100.) t.x=0.;\n return t;\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(sin(iTime)*1., cos(iTime)*2., 2);\n//     vec3 lightPos = vec3(0.,0.,0.);\n vec3 l = normalize(p-lightPos);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n vec2 d = RayMarch(p+n*SURF_DIST*1., l);\n return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;  \n vec3 col = vec3(0);  \n vec3 ro = vec3(3.,3., 5.);\n ro.zy *= Rot(iTime*.1);\n ro.xz *= Rot(1.8);\n vec3 rd = R(uv, ro, vec3(1,1,1), 1.);\n vec2 d = RayMarch(ro, rd);\n float t2;\n t2=d.x;   \n if(t2>0.)\n {\n  vec3 p = ro + rd * t2;\n  vec3 n = GetNormal(p);\n  vec3 baseColor = vec3(.0);\n  //   vec3 baseColor = vec3(0.,0.6,0.);\n  float dif = GetLight(p);\n  col = vec3(dif);\n  col+=baseColor;\n if(d.y==1.) col += tex3D(p,n)*4.;\n\n     \n }\n    \n col*=g1*vec3(.0001,.0001,.00004);  \n float fog = 1. / (5. + d.x * d.x *5.);\n    \n col *= vec3(fog); \n// col+=g1*vec3(.0000);  \n     col +=g2*vec3(1.)*vec3(1.,0.,0.0)*1.;    \n col*= 1.5; \n\n     col=pow(col, vec3(0.64545));\n// col*= 2.; \n fragColor = vec4(col,t2);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Dof code from: 42yeah, https://shadertoy.com/view/wsXBRf\n\n// Random hash function\nvec2 rand2d(vec2 uv) {\n    return fract(sin(vec2(\n        dot(uv, vec2(215.1616, 82.1225)),\n        dot(uv, vec2(12.345, 856.125))\n    )) * 41234.45) * 2.0 - 1.0;\n}\n\n// Calculate CoC: https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch23.html\nfloat getCoC(float depth, float focalPlane) {\n    float focalLength = 0.005;\n    float aperture = min(1.0, focalPlane * focalPlane);\n    return abs(aperture * (focalLength * (focalPlane - depth)) /\n        (depth * (focalPlane - focalLength)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Sample original texture data at uv\n    vec4 texData = texture(iChannel0, uv);\n    \n    // Get its depth\n    float depth = texData.w;\n    \n    // Focal plane at 3.9 (the camera is looking at the center from ~4.0)\n    float focalPlane =2.5;\n    \n    // Calculate CoC, see above\n    float coc = getCoC(depth, focalPlane);\n    \n    // Sample count\n    const int taps = 32;\n    \n    // Golden ratio: https://www.youtube.com/watch?v=sj8Sg8qnjOg\n    float golden = 3.141592 * (3.0 - sqrt(5.0));\n    \n    // Color & total weight\n    vec3 color = vec3(0.0);\n    float tot = 0.05;\n    \n    for (int i = 0; i < taps; i++) {\n        // Radius slowly increases as i increases, all the way up to coc\n        float radius = coc * sqrt(float(i)) / sqrt(float(taps));\n        \n        // Golden ratio sample offset\n        float theta = float(i) * golden;\n        vec2 tapUV = uv + vec2(sin(theta), cos(theta)) * radius;\n        \n        // Sample the bit over there\n        vec4 tapped = texture(iChannel0, tapUV);\n        float tappedDepth = tapped.w;\n\n        if (tappedDepth > 0.0) {\n            // Use CoC over there as weight\n            float tappedCoC = getCoC(tappedDepth, focalPlane);\n            float weight = max(0.001, tappedCoC);\n            \n            // Contribute to final color\n            color += tapped.rgb * weight;\n            // And final weight sum\n            tot += weight;\n        }\n    }\n    // And normalize the final color by final weight sum\n    color /= tot;\n    fragColor = vec4(color, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//radial blur code from jeyko: https://www.shadertoy.com/view/WlKXRR :)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 uvn = (fragCoord - 0.5*iResolution.xy)/iResolution.xy;\n    float steps = 20.0;\n    float scale = 0.00 + pow(length(uv - 0.5)*1.2,3.)*0.4;\n    float chromAb = pow(length(uv - 0.5),1.4)*2.1;\n    vec2 offs = vec2(0);\n    vec4 radial = vec4(0);\n    for(float i = 0.; i < steps; i++){  \n        scale *= -1.2;\n        vec2 target = uv + offs;\n        offs -= normalize(uvn)*scale/steps;\n    \tradial.r += texture(iChannel0, target + chromAb*1./iResolution.xy).x;\n    \tradial.g += texture(iChannel0, target).y;\n    \tradial.b += texture(iChannel0, target - chromAb*1./iResolution.xy).z;\n    }\n    radial /= steps;  \n    fragColor = radial*1.2;   \n    fragColor *= 1.;\n    fragColor = mix(fragColor,smoothstep(0.,1.,fragColor), .2);  \n    fragColor = max(fragColor, 0.);\n  //  fragColor.xyz = pow(fragColor.xyz, vec3(3.,sin(iTime)*0.+1.,1.));\n    fragColor *= 1. - dot(uvn,uvn)*1.;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//slide\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n vec2 uv = fragCoord.xy/iResolution.xy;\n float sup = 3.;\n float sdown =5.;\n vec4 in1 = texture(iChannel0, uv);\n vec4 in2 = texture(iChannel1, uv);\n vec4 sld = vec4(1.0 / sdown);\n vec4 slu = vec4(1.0 / sup);\n vec4 down = in1 + ((in2 - in1) * sld);\n vec4 up = in1 + ((in2 - in1) * slu);\n fragColor = mix(down, up, 1.);    \n}","name":"Buffer D","description":"","type":"buffer"}]}