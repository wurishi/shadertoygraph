{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define R 1.0\n#define max_distance 300.0\n#define epsilon 0.001\n#define max_steps 200\n#define K 0.37\n#define shininess 5.0\n#define ambient 0.2\n#define bump_factor 0.05\n#define specular_koef 4.5\n#define diffuse_koef 2.0\n#define FOV 60.0\n\nvec4 texture3d (sampler2D t, vec3 p, vec3 n, float scale) {\n\treturn \n\t\ttexture(t, p.yz * scale) * abs (n.x) +\n\t\ttexture(t, p.xz * scale) * abs (n.y) +\n\t\ttexture(t, p.xy * scale) * abs (n.z);\n}\n\nfloat smin( float a, float b, float k) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat get_distance(vec3 point) {\n\tfloat bump = 0.0;\n\tfloat elevation = -1.0;\n\t\n\tif ( length(point) < R + bump_factor) {\n\t\tbump = bump_factor * texture3d(iChannel1, point, normalize(-point), 0.5).r;\n\t}\n\treturn min(\n\t\tlength(point) - R + bump,\n\t\tdot(point, vec3(0.0, 1.0, 0.0)) - elevation\n\t);\n}\n\nfloat raymarch(vec3 ray_origin, vec3 ray_direction) {\n\tfloat d = 0.0;\n\t\n\tfor (int i = 0; i < max_steps; i++) {\n\t\tvec3 new_point = ray_origin + ray_direction*d;\n\t\tfloat s = get_distance(new_point);\n\t\tif (s < epsilon) return d;\n\t\td += s;\n\t\tif (d > max_distance) return max_distance;\n\t}\n\treturn max_distance;\n}\n\nvec3 get_normal(vec3 point) {\n\tfloat d0 = get_distance(point);\n\tfloat dX = get_distance(point-vec3(epsilon, 0.0, 0.0));\n\tfloat dY = get_distance(point-vec3(0.0, epsilon, 0.0));\n\tfloat dZ = get_distance(point-vec3(0.0, 0.0, epsilon));\n\t\t\n\treturn normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nmat3 rotateY(float fi) {\n\treturn mat3(\n\t    cos(fi), 0.0, sin(fi),\n\t  \t0.0, 1.0, 0.0,\n\t\t-sin(fi), 0.0, cos(fi)\n\t);\n}\n\nmat3 rotateX(float fi) {\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cos(fi), -sin(fi),\n\t\t0.0, sin(fi), cos(fi)\n\t);\t\n}\n\nfloat shadow_sample (vec3 org, vec3 dir) {\n    float res = 1.0;\n    float t = epsilon*200.0;\n    for (int i =0; i < 100; ++i){\n        float h = get_distance (org + dir*t);\n\t\tif (h <= epsilon) {\n            return 0.0;\n\t\t}\n        res = min (res, 32.0*h/t);\n        t += h;\n\t\tif (t >= max_distance) {\n      \t\treturn res;\n\t\t}\n\t\t\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tuv *= tan (radians (FOV)/2.0);\n\t\n\tvec4 color = vec4(0.0);\n\t\n\tvec3 light = vec3(0.0, 3.0, -2.0) * rotateY(iTime*2.0) ;\n\tmat3 rotated = rotateY(sin(iTime));\n\t\n\tvec3 eye_pos = rotated*vec3(0.0, 0.0, -4.0);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 forward = rotated*vec3(0.0, 0.0, 1.0);\n\tvec3 right = cross(up, forward);\t\n\t\n\tvec3 ray_dir = normalize(up * uv.y + right *uv.x + forward);\n\n\tfloat d = raymarch(eye_pos, ray_dir);\n\tvec3 point = (eye_pos+ray_dir*d);\t\t\t\n\t\n\tif (d < max_distance) {\t\t\n\t\tvec3 point_normal = get_normal(point);\n\t\t\n\t\tvec3 light_dir = -normalize(light-point);\n\t\tvec3 reflected_light_dir = reflect(-light_dir, point_normal);\n\t\tfloat attenuation = 1.0 / (1.0 + K*pow( length(light - point), 2.0));\n\t\t\t\n\t\tfloat dotp_diffuse = max(0.0, dot(light_dir, point_normal));\n\t\tfloat dotp_specular = pow(max(0.0, dot(ray_dir, reflected_light_dir)), shininess);\n\t\t\n\t\t// no diffuse -> no specular\n\t\tif (dotp_diffuse <= 0.0) dotp_specular = 0.0;\n\t\t\n\t\tfragColor = vec4(1.0, 1.0, 1.0, 1.0) * (ambient + (dotp_diffuse*diffuse_koef + dotp_specular*specular_koef) * shadow_sample(point, -light_dir) * attenuation) * texture3d(iChannel0, point, point_normal, 0.5);\n\t} else {\t\t\t\n\t    fragColor = vec4(0.0);\t\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XssXDH","date":"1400271259","viewed":1876,"name":"Ray marched moon","username":"LukasPukenis","description":"Moon","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","moon"],"hasliked":0,"parentid":"","parentname":""}}