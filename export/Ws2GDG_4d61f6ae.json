{"ver":"0.1","info":{"id":"Ws2GDG","date":"1549893512","viewed":157,"name":"Simple perlin noise","username":"Eren213","description":"Simple perlin noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n\n\n// Pseudo-random value in half-open range [0:1].\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nfloat noise(vec3 pos)\n{\n    float n = 0.;\n    const float persistence = 0.8;\n    float frequency = 2.;\n    const int octaves = 8;\n    float size = 256., pers = persistence;\n    \n    for(int i = 0;  i < octaves; i++)\n    {\n        vec3 min = floor(pos / size) * size;\n        \n        float tmp;\n        \n        #define G(g, x, y, z,r) vec3 g = (pos - (vec3(float(x), float(y), float(z)) * size) - min) / size; \\\n        \ttmp = random(min + vec3(float(x), float(y), float(z)) * size); \\\n            float r = dot(g, 2.*vec3(tmp, random(tmp), random(tmp))-1.);\n        \n        G(g000,0,0,0,r000)\n        G(g001,0,0,1,r001)        \n        G(g010,0,1,0,r010)        \n        G(g011,0,1,1,r011)        \n        G(g100,1,0,0,r100)        \n        G(g101,1,0,1,r101)        \n        G(g110,1,1,0,r110)        \n        G(g111,1,1,1,r111)        \n        \n        float i001 = mix(r000, r001, (pos.z - min.z) / size);\n        float i002 = mix(r010, r011, (pos.z - min.z) / size);\n        float i003 = mix(r100, r101, (pos.z - min.z) / size);\n        float i004 = mix(r110, r111, (pos.z - min.z) / size);\n        float i010 = mix(i001, i002, (pos.y - min.y) / size);\n        float i020 = mix(i003, i004, (pos.y - min.y) / size);\n        float i100 = mix(i010, i020, (pos.x - min.x) / size);\n        \n        float f = i100;\n        \n        n += f * pers;\n        size /= frequency;\n        pers *= persistence;\n    }\n    \n    return (n + 1.0 ) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(vec3(noise(vec3(gl_FragCoord.xy+iTime, iTime * 10.))), 1.0);\n}","name":"Image","description":"","type":"image"}]}