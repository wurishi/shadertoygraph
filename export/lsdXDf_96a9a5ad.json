{"ver":"0.1","info":{"id":"lsdXDf","date":"1461946737","viewed":675,"name":"Searching Through Fog","username":"imagicien","description":"Searching Through Fog.","likes":21,"published":1,"flags":64,"usePreview":0,"tags":["phare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsXGRs","filepath":"https://soundcloud.com/arlviriste/cloud-dies-to-mountain-par-ab","previewfilepath":"https://soundcloud.com/arlviriste/cloud-dies-to-mountain-par-ab","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define SIN_PERIOD 15.0 * PI\n#define LONG_AIGUILLE 1.0\n#define TIME_SCALE 1.0\n\n#define CLOUDS_SCALE 2.0\n#define CLOUDS_TIME_SCALE 0.2\n#define ADDNOISE(n) k = pow(2.0, n); gray += noise(vec3((uv.x * CLOUDS_SCALE + shift * (n+1.0)*0.2) * k, uv.y * CLOUDS_SCALE * k, 0.0)) / k; total += 1.0/k;\n\n// Noise function adapted from a shader found on ShaderToy.com\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\nfloat noise(in vec3 x)\n{\n    // Perlin noise\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0 - 2.0*f);\n\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n + 0.0),   hash(n + 1.0),   f.x),\n                   mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n                   mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nvec4 clouds(in vec2 uv)\n{\n    float shift = iTime * CLOUDS_TIME_SCALE;\n    \n    float gray = 0.0;\n    float total = 0.0;\n    float k = 0.0;\n    ADDNOISE(0.0);\n    ADDNOISE(1.0);\n    ADDNOISE(2.0);\n    ADDNOISE(3.0);\n    ADDNOISE(4.0);\n    ADDNOISE(5.0);\n    //ADDNOISE(64.0);\n    gray /= total;\n    \n    gray = clamp((gray - 0.1) * 1.2, 0.0, 1.0);\n    \n    return vec4(vec3(gray), 1.0);\n    //return gray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 cFragCoord = fragCoord.xy - iResolution.xy * 0.5;\n    \n    vec2 pos = cFragCoord / iResolution.y;\n    \n    //vec2 pos = (uv - 0.5) * 2.0;\n    float x = pos.x;\n    float y = pos.y;\n\n    float rho = sqrt(x*x + y*y);\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    //=================\n    float phi = atan(y, x);\n    //float nPhi = phi / (2.0 * PI) + 0.5;\n    vec2 circlePos = vec2(\n        LONG_AIGUILLE * cos(phi),\n        LONG_AIGUILLE * sin(phi)\n    );\n\n    //float seconds = iDate.w * TIME_SCALE;\n    float seconds = iTime;\n    float trotteuse = 1.0 - sin(SIN_PERIOD * fract(seconds)) / (SIN_PERIOD * fract(seconds));\n    float nPhiSecSimul = (floor(seconds) - 1.0 + trotteuse) / 60.0;\n\n    float phiSec = (1.25 - nPhiSecSimul) * 2.0 * PI;\n    vec2 trottPos = vec2(\n        LONG_AIGUILLE * cos(phiSec),\n        LONG_AIGUILLE * sin(phiSec)\n    );\n\n    //float wave = (sin(iTime) * 0.5 + 0.5) * 0.75 + 0.25;\n    float wave = sin(iTime) * 0.375 + 0.625;\n    float light = wave * clamp(1.0 - length(circlePos - trottPos), 0.0, 1.0);\n\n    vec4 lightCol = vec4(light, 0.0, 0.0, 1.0);\n    //=================\n    \n    vec4 ocean = vec4(0.0, 0.1, 0.2, 1.0);\n    ocean *= clamp(sign(rho - 0.03), 0.0, 1.0);\n    \n    \n    fragColor = clamp(fragColor + clouds(pos), 0.0, 1.0);\n    //fragColor = mix(fragColor, vec4(1.0), clouds(pos));\n    \n    \n    fragColor *= (1.0 - rho * 1.5);\n    \n    fragColor += clamp(sign(rho - 0.01), 0.0, 1.0) * (ocean + lightCol);\n}","name":"Image","description":"","type":"image"}]}