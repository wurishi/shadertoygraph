{"ver":"0.1","info":{"id":"WsBBRD","date":"1594379085","viewed":185,"name":"Cuboids","username":"jbsiraudin","description":"Some squishy isometric cuboids - pure 2D drawing.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pixelWidth 2.0/iResolution.y\n#define N 4\n#define A 0.59\n#define red vec3(1.0, 0.0, 0.0)\n#define white vec3(1.0)\n\nvec3 light = vec3(0.05, 1.0, 0.85);\n\n// sdPoly adapted from https://www.shadertoy.com/view/WdSGRd \nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    float d = dot(p-v[0],p-v[0]);\n    float s = -1.0;\n    for( int i=0, j=N-1; i<N; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w = p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n        \n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return smoothstep(-pixelWidth, pixelWidth, s*sqrt(d));\n}\n\nvoid drawCuboid(inout vec4 c, vec2 p, vec3 color, float width, float height, float depth)\n{   \n    height = max(pixelWidth, height);\n    vec2 v0 = vec2(0, height);\n    vec2 v1 = v0 + vec2(depth, A*depth);\n    vec2 v2 = v1 - vec2(0, height);\n    vec2 v3 = v0 - vec2(0, height);\n    \n    vec2 v4 = v0 - vec2(width, -A*width);\n    vec2 v5 = v4 - vec2(0, height);\n    \n    vec2 v6 = v4 + vec2(depth, A*depth);\n    \n    vec2[] polyRight = vec2[](v0,v1,v2,v3);\n    vec2[] polyLeft = vec2[](v0,v4,v5,v3);\n    vec2[] polyTop = vec2[](v0,v4,v6,v1);\n    \n    float right = sdPoly(polyRight, p);\n    float left = sdPoly(polyLeft, p);\n    float top = sdPoly(polyTop, p);\n    \n    float a = clamp(top + right + left, 0.0, 1.0);\n    \n    //Crayon-like border\n    //vec3 result = step(0.9, top) * vec3(1.0) + step(0.9, right) * vec3(0.85) + step(0.9, left) * vec3(0.05);\n\n    vec4 result = vec4(light.y*color, top);\n    result = mix(result, vec4(light.z*color, right), right);\n    result = mix(result, vec4(light.x*color, left), left);\n    \n    c = mix(c, result, pow(a, 4.0));\n}\n\nfloat st(float a, vec2 uv)\n{\n    return sin(a*iTime+a*uv.y*uv.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 U = (2.0*fragCoord-iResolution.xy)/(iResolution.y);\n    vec2 p = fract(U) - vec2(.5, 0.4);\n    \n    float s = 0.2*.6;\n    \n    vec4 col = vec4(0);\n    \n    //Lighting change\n    light.x = 0.5 + 0.35*pow(sin(iTime), 3.);\n    light.z = 0.5 + 0.35*pow(sin(iTime + 3.), 3.);\n    \n    // Draw red cuboid\n    drawCuboid(col, p, red, s*(1.0+0.5*st(3.5, U)), s*(1.0+st(5., U)), s*(1.0+0.25*st(2., U)));\n    // Draw blue-ish one\n    U *= 1.1;\n    drawCuboid(col, p-vec2(0.1,-0.2), vec3(0.6, 0.8, 1.0), s*(1.0+0.5*st(3.5, U)), s*(1.0+st(5., U)), s*(1.0+0.25*st(2., U)));    \n\n    \n\tfragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}