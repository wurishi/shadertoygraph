{"ver":"0.1","info":{"id":"td33Df","date":"1569407580","viewed":885,"name":"Quantum Harmonic Oscillator","username":"Kerdek","description":"Simulates a particle in a quantum harmonic oscillator using energy eigenfunction composition.\n\nThe green area is the probability density. The red and blue lines are the real and imaginary parts of the wave function.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["physics","quantum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 c, in vec2 ij )\n{  \n\tvec2 uv = ij.xy / iResolution.xy;\n        \n    vec3 plotv = (texture(iChannel0, vec2(uv.x, 0.5 / iResolution.y)).xyz - rmin.y) / rspan.y;\n        \n    c.xyz = vec3(abs(plotv.x - 0.166667 - uv.y) < line_thickness, plotv.z + 0.166667 > uv.y && uv.y > -rmin.y / rspan.y + 0.166667, abs(plotv.y - 0.166667 - uv.y) < line_thickness);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// The domain and range of the plots\n\nconst vec2 xrange = vec2(-1.0, 1.0);\nconst vec2 yrange = vec2(-10.0, 10.0);\n\n// Other plot parameters\n\nconst float line_thickness = 0.006;\n\n// Physical parameters of the oscillator\n\nconst float hbar = 1.0;\nconst float m = 40.0;\nconst float w = 1.0;\n\n// Energy state decomposition of the oscillator (complex coefficients not currently supported, but easy to implement)\n\nconst int decomp_count = 50;\n\nconst float decomp_abs[decomp_count] = float[decomp_count](\n    0.06198372625682101,\t0.15399980600999372,\t0.2656801797687563,\t\t0.36713067301599644,\t0.4305066580572734,\n    0.4418549915678565,\t\t0.4045076394080826,\t\t0.334403921605262,\t\t0.2517014314151477,\t\t0.17342140632157638,\n    0.10972106444214996,\t0.06382093806306956,\t0.034101384708417073,\t0.016685626239353327,\t0.007428308075986638,\n    0.002974167807514042,\t0.0010481861241782885,\t0.00031102453363822635,\t0.00006895437921119347,\t5.666605312574491e-6,\n    4.319487594088388e-6,\t2.956331856797536e-6,\t1.097064477650279e-6,\t2.4708339083132666e-7,\t5.97880555575911e-9,\n    2.3931804586714903e-8,\t1.2310200561602617e-8,\t3.266389239112657e-9,\t1.8325380847429325e-10,\t2.683153738721648e-10,\n    1.4225303377040308e-10,\t4.685905997920021e-11,\t4.13018135885236e-11,\t4.41202177520526e-11,\t4.800683812915734e-11,\n    7.457760086895218e-10,\t4.703328384255315e-10,\t6.557123607745412e-10,\t6.392710163126244e-10,\t6.360866217521084e-9,\n    1.4303251532552374e-9,\t4.680316286308498e-9,\t1.2941402162935327e-9,\t1.738328728325258e-8,\t5.757350060600977e-9,\n    4.7912327127505095e-8,\t2.9372829890810356e-8,\t8.78354495006912e-8,\t4.8131155786533476e-8,\t7.197961000836568e-8);\n\n//Some useful mathematical constants\n\nconst float root_2 = 1.41421356237;\nconst float inv_fourth_root_pi = 0.75112554446494248286;\n\n// Some plotting parameters derived from the above\n\nconst vec2 rmin = vec2(xrange.x, yrange.x);\nconst vec2 rmax = vec2(xrange.y, yrange.y);\nconst vec2 rspan = rmax - rmin;\n\n// Some physical quantities derived from the above\n\nconst float mw_over_hbar = m * w / hbar;\nconst float root_mw_over_hbar = sqrt(mw_over_hbar);\nconst float fourth_root_mw_over_pi_hbar = sqrt(root_mw_over_hbar) * inv_fourth_root_pi;\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 c, in vec2 ij )\n{\n    if(ij.y > 1.0)\n    {\n        c.xyz = vec3(0.0, 0.0, 0.0);\n        return;\n    }\n    \n    float x = ij.x / iResolution.x * rspan.x + rmin.x;\n    \n    vec2 psi = vec2(0.0, 0.0);\n    \n    float wt = w * iTime;\n    \n    float psi_n_0;\n    float psi_n_1;\n    float tde;\n    \n    if(decomp_count > 0)\n    {    \n        psi_n_0 = fourth_root_mw_over_pi_hbar * exp(-0.5f * mw_over_hbar * x * x);\n        tde = -0.5 * wt;\n        psi += decomp_abs[0] * psi_n_0 * vec2(cos(tde), sin(tde));\n    }\n    \n    if(decomp_count > 1)\n    {\n        psi_n_1 = root_2 * root_mw_over_hbar * x * psi_n_0;\n        tde = -1.5 * wt;    \n        psi += decomp_abs[1] * psi_n_1 * vec2(cos(tde), sin(tde));\n    }    \n    for(int n = 2; n < decomp_count; n++)\n    {\n        float psi_n = (root_mw_over_hbar * x * psi_n_1 - sqrt(float(n - 1) / 2.0) * psi_n_0) * sqrt(2.0 / float(n));\n    \ttde = -(float(n) + 0.5) * wt;\n        psi += decomp_abs[n] * psi_n * vec2(cos(tde), sin(tde));\n            \n        psi_n_0 = psi_n_1;\n        psi_n_1 = psi_n;\n    }\n    \n    c.xyz = vec3(psi, dot(psi, psi));\n}","name":"Buffer A","description":"","type":"buffer"}]}