{"ver":"0.1","info":{"id":"ctK3WV","date":"1684778114","viewed":128,"name":"ray tracer - reflect refract","username":"timknip","description":"ray tracing attempt. Use a stack to render both reflection and refraction. No clue yet how to get the color of the ray correctly.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracingrayytracingreflectionrefraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265\n#define TWO_PI 6.28318530\n#define MAX_RAY_DEPTH 4\n\nfloat _x = 0.0;\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float fresnel;\n    int type;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n    float reflectivity;\n    float transparency;\n    vec3 emission;\n};\n\nstruct Hit {\n    float t;\n    vec3 pt;\n    vec3 normal;\n    Sphere sphere;\n    int idx;\n};\n\nbool intersectSphere (in Ray ray, in Sphere sphere, inout float t) {\n    vec3 L = sphere.center - ray.origin;\n    float tca = dot(L, ray.direction);\n    float d2 = dot(L, L) - (tca * tca);\n    float radius2 = sphere.radius * sphere.radius;\n    \n    if (d2 > radius2) {\n        return false;\n    }\n    \n    float thc = sqrt(radius2 - d2);\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    \n    if (t0 > t1) {\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    \n    if (t0 < 0.0) {\n        t0 = t1;\n        if (t0 < 0.0) {\n            return false;\n        }\n    }\n    \n    t = t0;\n    \n    return true;\n}\n\nSphere objects[] = Sphere[](\n    Sphere(vec3(0.0, -10004.0, -20.0), 10000.0, vec3(0.2,0.2,0.2), 0.0, 0.0, vec3(0.0)),\n    Sphere(vec3(0.0, 0.0, -20.0), 4.0, vec3(1,0.32,0.36), 1.0, 0.5, vec3(0.0)),\n    Sphere(vec3(5.0, -1.0, -15.0), 2.0, vec3(0.90, 0.76, 0.46), 1.0, 0.6, vec3(0.0)),\n    Sphere(vec3(5.0, 0.0, -25.0), 3.0, vec3(0.65, 0.77, 0.9), 1.0, 0.6, vec3(0.0)),\n    Sphere(vec3(-5.5, 0.0, -15.0), 3.0, vec3(0.9, 0.9, 0.9), 1.0, 0.5, vec3(0.0))\n    // light\n    \n);\n\nconst Sphere lights[] = Sphere[](\n    Sphere(vec3(0.0, 20.0, -30.0), 3.0, vec3(0.0), 0.0, 0.0, vec3(1.0, 1.0, 1.0))\n);\n\nfloat schlick_approximation(in float cosine, in float refraction_factor) {\n    float r0 = (1.0 - refraction_factor) / (1.0 + refraction_factor);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\nbool intersect(in Ray ray, out Hit hit) {\n    \n    float min_t = 1000000.0;\n    float t;\n    bool has_hit = false;\n    \n    for (int i = 0; i < 5; i++) {\n       if (intersectSphere(ray, objects[i], t)) {\n           if (t < min_t) {\n               min_t = t;\n               \n               hit.t = t;\n               hit.sphere = objects[i];\n               hit.idx = i;\n               has_hit = true;\n           }\n       }\n    }\n \n    if(has_hit) {\n        hit.pt = ray.origin + ray.direction * hit.t;\n        hit.normal = normalize(hit.pt - hit.sphere.center);\n    }\n    \n    return has_hit;\n}\n\nvec3 shade(in Ray ray, in Hit hit, inout vec3 color) {\n    float bias = 1.0e-2;\n    \n    //vec3 color = vec3(0.0);\n    vec3 transmission = vec3(1.0);\n    vec3 lightDirection = normalize(lights[0].center - hit.pt);\n    \n    Ray shadow_ray = Ray(hit.pt + hit.normal * bias, lightDirection, 1.0, 3);\n    Hit hit2;\n    \n    float t;\n    \n    for (int j = 0; j < 5; j++) {\n        if (j != hit.idx) {\n            if(intersectSphere(shadow_ray, objects[j], t)) {\n                transmission = vec3(0.0);\n                break;\n            }\n        }\n        color += hit.sphere.color * transmission * max(0.0, dot(hit.normal, lightDirection)) * lights[0].emission;\n    }\n    return color;\n}\n\nvec3 trace(in Ray ray) {\n    vec3 color = vec3(0.0);\n    \n    float bias = 1.0e-3;\n    int max_bounces = 4;\n    int depth = 0;\n    float reflAmt = 1.0;\n    bool continueLoop = true;\n    vec3 global_attenuation = vec3(1.0);\n    \n    Hit hit;\n    \n    Ray stack[10];\n    int sp = -1;\n\n    /*\n    surfaceColor = (\n            reflection * fresneleffect +\n            refraction * (1 - fresneleffect) * sphere->transparency) * sphere->surfaceColor;\n    */\n    while(continueLoop) {\n    //for (int i = 0; i < max_bounces; i++) {\n        //color = vec3(1.0);\n\n        if(intersect(ray, hit)) {\n            \n            depth++;\n            shade(ray, hit, color);// * reflAmt;\n            \n            color *= reflAmt;//(1.0 / float(depth+1));\n            //color += (hit.sphere.color * ray.fresnel);\n            //color = hit.sphere.color * global_attenuation;\n            bool inside = false;\n            if(dot(ray.direction, hit.normal) > 0.0) {\n                inside = true;\n                hit.normal *= -1.0;\n            }\n            \n            if(hit.sphere.reflectivity > 0.0 && depth < MAX_RAY_DEPTH) {\n                \n                float facingratio = -dot(ray.direction, hit.normal);\n                // change the mix value to tweak the effect\n                float fresneleffect = mix(pow(1.0 - facingratio, 3.0), 1.0, 0.9);\n        \n                if(hit.sphere.transparency > 0.0) {\n                    float ior = 1.1;\n                    float eta = inside ? ior : 1.0 / ior; // are we inside or outside the surface?\n                    \n                    if(inside) {\n                        float travel_distance = length(hit.pt - ray.origin);\n                        vec3 absorbance = hit.sphere.color * (travel_distance * -0.25);\n                        vec3 att = vec3(exp(absorbance.x), exp(absorbance.y), exp(absorbance.z));\n                        global_attenuation *= att;\n                    }\n                    \n                    vec3 refrdir = refract(ray.direction, hit.normal, eta);\n                    stack[++sp]= Ray(hit.pt - hit.normal * bias, refrdir, (1.0 - fresneleffect) * hit.sphere.transparency, 2);\n                    depth++;\n                }\n                ray = Ray(hit.pt + hit.normal * bias, reflect(ray.direction, hit.normal), fresneleffect, 1);\n                reflAmt *= 0.5;\n            } else {\n                // diffuse\n                //shade(ray, hit, color);\n                continueLoop = false;\n            }\n            \n\n           // break;\n        } else {\n            //color = vec3(1.0);\n            continueLoop = false;\n        }\n        \n        if (!continueLoop && sp >= 0) {\n            ray = stack[sp--];\n            depth--;\n            continueLoop = true;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float scale = tan((40.0 * 0.5)*(PI / 180.0));\n    float aspect = iResolution.x / iResolution.y;\n\n    float x = (2.0 * ((uv.x * iResolution.x) + 0.5) / iResolution.x - 1.0) * aspect * scale;\n    float y = (1.0 - 2.0 * ((uv.y * iResolution.y) + 0.5) / iResolution.y) * scale;\n    \n    objects[3].center.z = -25.0 + cos(iTime*2.0) * 5.0;\n    objects[2].center.x = 3.0 + sin(iTime) * 8.0;\n    objects[2].center.z = -16.0 + cos(iTime) * 8.0;\n    objects[1].center.x = cos(iTime) * 3.0;\n    objects[1].center.z = -20.0+cos(iTime);\n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.direction = normalize(vec3(x, -y, -1.0));\n    ray.fresnel = 1.0;\n    ray.type = 0;\n    \n   \n    fragColor = vec4(trace(ray), 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}