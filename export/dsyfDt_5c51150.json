{"ver":"0.1","info":{"id":"dsyfDt","date":"1728586168","viewed":46,"name":"Versel-Projection","username":"Versel","description":"3D Projection","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*(fragCoord)-iResolution.xy)/ iResolution.y;\n    vec3 rayPos;\n    vec3 ray = getCameraRay(vec3(0.0,rawTerrainHeight(vec2(0.0, -iTime/5.0), 4.0).x + 5.0,-iTime/5.0), vec3(-3.14159265/7.0,0.0,0.0), p, rayPos);\n    \n    vec3 color = vec3(0.0,0.0,0.0);\n    vec4 hit = marchRay(rayPos, ray, color);\n    float dist = hit.w;\n    \n    \n    //float height = terrainHeight(p, 5.0); //terrainHeight(p, floor(p.x*(iResolution.x/64.0)));\n    //fragColor = vec4(height,height-1.0,height-2.0,1.0);\n    if (dist == -1.0)\n    {\n        fragColor = vec4(addFog(vec3(0.0,0.0,0.0), hit.xyz, 1000.0, ray),1.0);\n        return;\n    }\n    \n    color = calcLight(hit.xyz, color, ray);\n    \n    color = addFog(color, hit.xyz, dist, ray);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Hash functions\n\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// Noise\n\nvec3 noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash33(i+vec3(0,0,0)), \n                        hash33(i+vec3(1,0,0)),f.x),\n                   mix( hash33(i+vec3(0,1,0)), \n                        hash33(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash33(i+vec3(0,0,1)), \n                        hash33(i+vec3(1,0,1)),f.x),\n                   mix( hash33(i+vec3(0,1,1)), \n                        hash33(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// Helpers\n\nvec3 lerp(vec3 a, vec3 b, float t)\n{\n    return a*(1.0-t) + b*t;\n}\n\n#define FREQUENCY 0.25\n#define AMPLITUDE 4.0\n#define OCTAVES 6.0\n\n#define TERRAIN_SEED 16.0\n\nvec3 terrainHeightOct(vec2 p, float freq)\n{\n    //return 0.0;\n    vec3 pos = vec3(p*freq, TERRAIN_SEED + freq);\n    vec3 n = noise(pos);\n    //float n = 1.0+cos(p.x*freq)*sin(p.y*freq)*2.0;// * hash13(pos); // FASTER BUT NOT RANDOM\n    return n;\n    \n}\n\n#define NORMAL_DELTA 0.1\n\nvec2 rawTerrainHeight(vec2 p, float octaves)\n{\n    float n = 0.0;\n    for (float i=1.0; i<=octaves; i+=3.0)\n    {\n        vec3 no = terrainHeightOct(p, i*FREQUENCY);\n        n += no.x/pow(1.75,i) + no.y/pow(1.75,i+1.0) + no.x/pow(1.75,i+2.0);\n    }\n    //n = smoothstep(0.25, 0.75, n);\n    n *= AMPLITUDE;\n    n += (AMPLITUDE/2.0)*smoothstep(AMPLITUDE*0.65, AMPLITUDE*0.85, n);\n    \n    return vec2(n,0.0);\n    \n}\n\nvec2 terrainHeight(vec2 p, float octaves, out vec3 normal)\n{\n    float n = rawTerrainHeight(p, octaves).x;\n    \n    if (normal == vec3(-1.0,-1.0,-1.0)) return vec2(n, 0.0);\n    \n    // Calc Normal\n    \n    vec3 neg = vec3(-1.0,-1.0,-1.0);\n    \n    float r_l = rawTerrainHeight(vec2(p.x+NORMAL_DELTA,p.y), octaves).x - rawTerrainHeight(vec2(p.x-NORMAL_DELTA,p.y), octaves).x;\n    float b_t = rawTerrainHeight(vec2(p.x,p.y-NORMAL_DELTA), octaves).x - rawTerrainHeight(vec2(p.x,p.y+NORMAL_DELTA), octaves).x;\n    normal = normalize(vec3(r_l/(2.0*NORMAL_DELTA), -1, b_t/(2.0*NORMAL_DELTA)));\n    \n    vec3 up = vec3(0.0,1.0,0.0);\n    \n    return vec2(n,dot(normal, up));\n    \n}\n\n#define WATER_HEIGHT 2.0\n#define WATER_COLOR vec3(0.2,0.4,1.0)\n#define BEACH_HEIGHT 2.5\n#define BEACH_COLOR vec3(1.0, 1.0, 0.5)\n\nvec3 terrainD(vec2 p, float octaves, out vec2 height)\n{\n    vec3 normal = vec3(0.0,0.0,0.0);\n    height = terrainHeight(p, octaves, normal);\n    float steepness = 1.0-abs(height.y);\n    vec3 color = vec3(0.0,1.0,0.0);\n    color = lerp(color, vec3(0.75,0.75,0.25), smoothstep(0.0, 0.8, steepness));\n    color = lerp(color, vec3(1.0,1.0,1.0), smoothstep(0.0,7.0, height.x));\n    color = lerp(BEACH_COLOR, color, smoothstep(WATER_HEIGHT,BEACH_HEIGHT, height.x));\n    color = lerp(WATER_COLOR, color, smoothstep(WATER_HEIGHT-0.2,WATER_HEIGHT, height.x));\n    if (fract(height.x*5.0) < 0.05) color = color - 0.5/(max(1.0, (WATER_HEIGHT - height.x)*8.0));\n    return color;\n}\n\nvec3 getCameraRay (vec3 pos, vec3 rot, vec2 sCoord, out vec3 offset)\n{\n    rot.y += sCoord.x*(3.14159265/6.0); // 60 deg fov\n    rot.x += sCoord.y*(3.14159265/6.0); // 60 deg fov\n    mat3 rotX = mat3(1.0, 0.0, 0.0,\n                     0.0, cos(rot.x), sin(rot.x),\n                     0.0, -sin(rot.x), cos(rot.x));\n    mat3 rotY = mat3(cos(rot.y), 0.0, -sin(rot.y),\n                     0.0, 1.0, 0.0,\n                     sin(rot.y), 0.0, cos(rot.y));\n    mat3 rotZ = mat3(cos(rot.z), sin(rot.z), 0.0,\n                     -sin(rot.z), cos(rot.z), 0.0,\n                     0.0, 0.0, 1.0);\n    //pos.x += sCoord.x;\n    //pos.y += sCoord.y;\n    vec3 cam = vec3(0.0,0.0,0.0);\n    cam = rotX * cam;\n    cam = rotY * cam;\n    cam = rotZ * cam;\n    cam += pos;\n    offset = cam;\n    cam = vec3(0.0,0.0,-1.0);\n    cam = rotX * cam;\n    cam = rotY * cam;\n    cam = rotZ * cam;\n    return cam;\n}\n\n#define MAX_STEPS 200\n#define CONE_SLOPE 10.0\n#define EPSILON 0.2\n\nvec4 marchRay(vec3 pos, vec3 dir, out vec3 color)\n{\n    normalize(dir);\n    vec3 p = pos;\n    float height = 0.0;\n    float dist = 0.0;\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec2 d = rawTerrainHeight(p.xz, OCTAVES);\n        float delta = d.x;\n        height = delta;\n        delta = p.y - delta;\n        delta *= 1.0/sqrt((CONE_SLOPE * CONE_SLOPE)+1.0);\n        delta *= sign(p.y-height);\n        p += dir * delta;\n        dist += delta;\n        if (abs(p.y-height) < EPSILON)\n        {\n            vec2 d = vec2(0.0,0.0);\n            color = terrainD(p.xz, OCTAVES, d);\n            return vec4(p.x, height, p.z, dist);\n        }\n    }\n    return vec4(p, -1.0);\n    \n    \n}\n\n#define SUN_DIR normalize(vec3(1.0,-1.0,1.0))\n#define SUN_DELTA 0.1\n#define MAX_HEIGHT 10.0\n#define SUN_COLOR vec3(1.0,1.0,0.9)\n#define HORIZON_SCATTER_AMOUNT 4.0\n#define FOG_COLOR vec3(0.75,0.75,0.75)\n#define HORIZON_COLOR vec3(0.4,0.6,1.0)\n#define FOG_DENSITY 0.125\n#define HORIZON_HEIGHT 3.5\n#define HORIZON_DENSITY 0.02\n#define WATER_DENSITY 1.0\n\nbool inShadow(vec3 p)\n{\n    vec3 dir = -SUN_DIR;\n    float delta = SUN_DELTA;\n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        p += dir * delta;\n        vec2 height = rawTerrainHeight(p.xz, OCTAVES);\n        //delta = p.y - height.x;\n        //delta *= 1.0/sqrt((CONE_SLOPE * CONE_SLOPE)+1.0);\n        if (p.y < height.x)\n            return true;\n        if (p.y >= MAX_HEIGHT)\n            return false;\n        \n    }\n    return false;\n}\n\n#define ASORB_AMOUNT 0.8\n\nvec3 asorb(vec3 color, vec3 light)\n{\n    return color * light * ASORB_AMOUNT;\n}\n\nvec3 calcLight(vec3 pos, vec3 color, vec3 ray)\n{\n    vec3 outColor = color;\n    vec3 light = .1 * HORIZON_COLOR * HORIZON_SCATTER_AMOUNT;\n    float distThroughWater = length(max(0.0, (WATER_HEIGHT-pos.y)/abs(ray.y))*ray); //return vec3(distThroughWater);\n    if (!inShadow(pos))\n    {\n        light += SUN_COLOR;\n        light -= smoothstep(0.0, 1.0, distThroughWater * WATER_DENSITY);\n        vec3 reflector = normalize(vec3(1.0-abs(cos(pos.x*2.0)), 1.0, 1.0-abs(sin(pos.z*2.0))));\n        vec3 reflRay = ray * reflector;\n        float reflAmount = smoothstep(0.0, 1.0, dot(reflRay, SUN_DIR));\n        light *= (1.0+(smoothstep(WATER_HEIGHT, WATER_HEIGHT-0.2, pos.y)*reflAmount*4.0))*SUN_COLOR;\n    }\n    else\n    {\n        light -= smoothstep(0.0, 1.0, distThroughWater * WATER_DENSITY);\n    }\n    light = vec3(max(0.0, light.x), max(0.0, light.y), max(0.0, light.z));\n    outColor = asorb(outColor, light);\n    return outColor;\n}\n\n\nvec3 addFog(vec3 color, vec3 pos, float dist, vec3 ray)\n{\n    float distThroughFog = length(max(0.0, (HORIZON_HEIGHT-pos.y)/abs(ray.y))*ray); //return vec3(distThroughFog);\n    float distThroughWater = length(max(0.0, (WATER_HEIGHT-pos.y)/abs(ray.y))*ray); //return vec3(distThroughWater);\n    float distThroughHorizon = dist - distThroughWater;\n    vec3 fogc = lerp(color, HORIZON_COLOR*SUN_COLOR, smoothstep(0.0, 1.0, distThroughHorizon * HORIZON_DENSITY));\n    fogc = lerp(fogc, FOG_COLOR*SUN_COLOR, smoothstep(0.0, 1.0, distThroughFog * FOG_DENSITY));\n    return fogc; //lerp(watc, fogc, smoothstep(FOG_START, FOG_END, /*smoothstep(WATER_HEIGHT-0.2, WATER_HEIGHT, pos.y)**/dist)); \n}","name":"Common","description":"","type":"common"}]}