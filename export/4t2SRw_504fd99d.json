{"ver":"0.1","info":{"id":"4t2SRw","date":"1442460528","viewed":123,"name":"HAHAHAHA I DID IT!","username":"reymakes","description":"I MADE A SHADER .\n\nI FRANKENSTEINED SOME THINGS AND I GOT IT TO THIS THING","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","ball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //This is the Fragmented Coordinates on the UV Map of our shader\n    //I don't actually know what this means.\n    //Is it that it divides the coordinates into the resolution?\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    \n    \n    //Okay, so this Vector2 below is the \"position\" of the ball\n    //first X is the speed in which it goes across the screen\n    //the Y is how fast and where it goes up and down on the screen\n    //The reason I'm clamping the X is because it kind of goes through the whole wave and that's\n    //bigger than the screen, so I am clamping it to the absolute value of the Cosine of time\n    //Which to me seems to keep it in the position...kind of.\n\n    //DO I NEED PI so I can keep it from hitting the edge? I think so.\n    //I do not know what that did...\n    //I removed it\n    \n \n    \n    float pi = 3.14;\n    \n    vec2 ballPos = vec2(clamp(fragCoord.x, 2.,abs(cos(iTime/4.))),abs(sin(iTime)));\n    \n    //This clamps the position of the vector2 to the pos that the ball will appear\n    //it clams it from 1 to where the pos of the ball to the size of the UV from 0 to 1\n    \n    float ball = 1.-clamp((length(uv-ballPos)- .1)*100., 0., 1.);\n\t\n    //What I think this does is that it makes the color\n    \n    vec3 color = vec3(ball,0,clamp(1.-ball,0.,1.));\n    \n\tfragColor = vec4(color,.2);\n}\n","name":"","description":"","type":"image"}]}