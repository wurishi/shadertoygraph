{"ver":"0.1","info":{"id":"llGGzV","date":"1475525616","viewed":144,"name":"My Own Raymarcher","username":"efairbanks","description":"Iterative well-commented raymarcher so I can understand.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray{\n \tvec3 position;\n    vec3 direction;\n};\n\n// get the distance from a torus (how does this work?)\nfloat distTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// get the distance from a sphere\nfloat distSphere( vec3 p, float s )\n{\n  p = p - vec3(0.,0.,-0.25);\n  return length(p)-s;\n}\n\nfloat distBox(vec3 p, vec3 b, float roundness)\n{\n\treturn length(max(abs(p)-(b-vec3(roundness)),0.0))-roundness;\n}\n\nray getLookRayFlawed(vec2 uv, vec3 eye, vec3 target, float fov)\n{\n\ttarget = vec3(target.x + (uv.x*fov), target.y + (uv.y*fov), target.z);\n    vec3 fwdDirection = normalize(target-eye);\n    return ray(eye,fwdDirection);\n}\n\nray getLookRay(vec2 uv, vec3 cameraPos, vec3 target, float fov)\n{\n\tvec3 forward = normalize(target-cameraPos);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward,right));\n    \n    right = right*uv.x*fov;\n    up = up*uv.y*fov;\n    \n    return ray(cameraPos,right+up+forward);\n}\n/*\nfloat dist(vec3 p) {\n\tfloat d = 0.;\n    \n    d = distBox(p-vec3(0.,0.,-0.15),vec3(0.2,0.2,0.15),0.05);\n    d = max(-distSphere(p+vec3(0.,0.,-0.1), 0.2),d);\n    d += 0.005;\n    \n    float e = 0.;\n    \n    e = distTorus(p-vec3(0.,0.,-0.25), vec2(0.05+(0.02*sin(iTime*4.4)), 0.01));\n    e = max(-distTorus(p-vec3(0.,0.,-0.25), vec2(0.11+(0.02*sin(iTime*4.4)), 0.055)),e);\n    e = min(distSphere(p, 0.03+(0.01*sin((iTime+0.14)*4.4))),e);\n    e -= 0.005;\n    \n    float f = 0.;\n    f = min(d, e);\n    \n\td = f;\n    \n    return d;\n}\n*/\n\nfloat dist(vec3 p)\n{\n\tfloat d = 0.;\n    \n    d = distBox(p, vec3(0.09), 0.05);\n    d = max(-distTorus(p, vec2(0.08,0.045)), d);\n    \n    return d;\n}\n\nconst float maxSteps = 80.;\nfloat marchRay(ray marcher)\n{\n    float hitDistance = 0.00001;\n    float distanceTravelled = 0.;\n\tfor(float i=0.0; i<maxSteps; i++)\n    {\n        float nextDistanceTravelled = dist(marcher.position + (marcher.direction * distanceTravelled));\n        if(nextDistanceTravelled < hitDistance) return 1.-(i/maxSteps);\n        distanceTravelled += nextDistanceTravelled;\n    }\n    return 0.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // scale fragCoord xy to 0.0 -> 1.0\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    // transform uv x/y to go from -1.0 -> 1.0\n    uv = uv * vec2(2) - vec2(1);\n    // tranform uv x axis so that it's not skewed by aspect ratio\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    \n    float mask = 1.0-distance(uv, vec2(0.,0.));\n    vec3 rot = vec3(-6.,-6.,-6.);\n    rot = vec3(sin(iTime), cos(iTime*0.5), cos(iTime)) * 30.;\n    ray lookRay = getLookRay(uv, rot, vec3(0.,0.,0.), 0.005);\n\tmask = marchRay(lookRay);\n    fragColor = vec4(mask,mask,mask,1.);\n}","name":"Image","description":"","type":"image"}]}