{"ver":"0.1","info":{"id":"ft3cW8","date":"1659959526","viewed":170,"name":"Futuristic triangles","username":"sp33s","description":"Wanted to create a sci-fi triangle effect as seen in some games like Horizon. \nClick and drag mouse over canvas for another effect.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["triangle","triangles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PHI = 1.61803398874989484820459; // Î¦ = Golden Ratio\nconst float THIRD = 1.0 / 3.0;\nconst vec4 BG_COLOR = vec4(1.0, 1.0, 1.0, 1.0) * 0.15;\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat GRID_WIDTH;\nfloat GRID_HEIGHT;\nfloat GRID_HEIGHT_HALF;\n\n\n// Ripped from https://stackoverflow.com/a/28095165/9763789\nfloat GoldNoise(const in vec2 xy, const in float seed)\n{\n    return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);\n}\n\n// Returns the current index based on full width grid and half grid height making each index half a triangle\nvec2 GetPosIndex(const in vec2 fragCoord)\n{\n    return vec2(floor(fragCoord.x / GRID_WIDTH), floor(fragCoord.y / GRID_HEIGHT_HALF));\n}\n\n// Returns the lower left coordinate in canvas space snapped to grid positions\nvec2 GetPosOrigin(const in vec2 fragCoord)\n{\n    // Returns the current index based on a full grid\n    vec2 indices = vec2(floor(fragCoord.x / GRID_WIDTH), floor(fragCoord.y / GRID_HEIGHT));\n    \n    vec2 origin = vec2(indices.x * GRID_WIDTH, indices.y * GRID_HEIGHT);\n    \n    return origin;\n}\n\n// Returns a float based in the pos index\nvec3 GetColorByIndex(in vec2 posIndex)\n{\n    // Offset x by one because x = 0.0 always returns black\n    posIndex.x += 1.0;\n    \n    float brightness = GoldNoise(posIndex, 50.76);\n    if (brightness > 0.7 && GoldNoise(posIndex, 78.22) > 0.75)\n    {\n        return vec3(1.0, 0.7, 0.0);\n    }\n    \n    brightness = (brightness / 1.25) + 0.2; // Let color sit at [0.2 - 1.0] so blacks aren't as deep\n    \n    return vec3(brightness, brightness, brightness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    GRID_WIDTH = iResolution.x * 0.067;\n    GRID_HEIGHT = GRID_WIDTH * 1.166667;\n    GRID_HEIGHT_HALF = GRID_HEIGHT / 2.0;\n    \n\n    ////////////////////// Get data\n    \n    vec2 posIndex = GetPosIndex(fragCoord);\n    vec2 posOrigin = GetPosOrigin(fragCoord);\n    \n    // Position origin at 0,0 so we don't have to deal with offsets\n    vec2 localFragCoord = fragCoord - posOrigin;\n    \n    bool isLowerHalf = localFragCoord.y < GRID_HEIGHT_HALF;\n\n    float xIncrementPerLine = GRID_WIDTH / GRID_HEIGHT_HALF;\n    float crossPoint = isLowerHalf ? localFragCoord.y * xIncrementPerLine : (GRID_HEIGHT - localFragCoord.y) * xIncrementPerLine;\n\n    // Are we an uneven column?\n    bool flip = floor(mod(posIndex.x, 2.0)) == 1.0;\n    if (flip)\n        crossPoint = GRID_WIDTH - crossPoint;\n    \n    // Segment being half a triangle, dealing with blocks from 4 half triangles\n    bool isSegmentA = isLowerHalf && ((!flip && localFragCoord.x > crossPoint) || (flip && localFragCoord.x < crossPoint));\n    bool isSegmentB = isLowerHalf && ((!flip && localFragCoord.x < crossPoint) || (flip && localFragCoord.x > crossPoint));\n    bool isSegmentC = !isLowerHalf && ((!flip && localFragCoord.x < crossPoint) || (flip && localFragCoord.x > crossPoint));\n    bool isSegmentD = !isLowerHalf && ((!flip && localFragCoord.x > crossPoint) || (flip && localFragCoord.x < crossPoint));\n    \n    // Does this triangle point right?\n    bool pointsRight = localFragCoord.x < crossPoint;\n    \n    // Offset our index to find the right color\n    vec2 triangleIndex = posIndex;\n    if (pointsRight && isLowerHalf || !pointsRight && !isLowerHalf)\n        triangleIndex.y += flip ? -1.0 : 1.0;\n\n            \n    ////////////////////// Scale\n\n    \n    float triangleScale;\n    \n    if (iMouse.z <= 0.0) // LMB not pressed\n    {\n        triangleScale = (sin(iTime * 1.0 + triangleIndex.x / 8.0 + triangleIndex.y / 10.0) + 1.0) / 2.0;\n        triangleScale = 1.0 - pow(triangleScale, 50.0);\n    }\n    else // LMB pressed\n    {\n        // Find the center of each triangle\n        vec2 centerOfTri = vec2(triangleIndex.x * GRID_WIDTH, triangleIndex.y * GRID_HEIGHT_HALF);\n        vec2 offset = vec2(GRID_WIDTH * THIRD, GRID_HEIGHT_HALF);\n        if (!pointsRight)\n            centerOfTri += vec2(GRID_WIDTH - offset.x, 0);\n        else\n            centerOfTri += offset;\n    \n        // Find distance from mouse cursor\n        vec2 deltaToMouse = iMouse.xy - centerOfTri;\n        float deltaLength = sqrt(pow(abs(deltaToMouse.x), 2.0) + pow(abs(deltaToMouse.y), 2.0));\n         \n        // Scale based on distance, larger gap at larger res\n        triangleScale = smoothstep(0.0, iResolution.x * 0.3, deltaLength);\n    }\n       \n    // Calculate margin width based on the scale\n    vec2 margin = vec2(GRID_WIDTH, GRID_HEIGHT_HALF) * (1.0 - triangleScale);\n    margin /= 2.0; // margin works on both sides\n    \n    // Trim diagonal sides\n    float distanceFromCrossPoint = abs(crossPoint - localFragCoord.x);\n    float third = 1.0 / 3.0;\n    if (distanceFromCrossPoint < margin.x * 4.0 * THIRD) // 1.3333 in weight, so diagonals grow towards tri's center of gravity\n    {\n        fragColor = BG_COLOR;\n        return;\n    }\n    \n    // Trim vertical side\n    float distanceFromSide = pointsRight ? localFragCoord.x : GRID_WIDTH - localFragCoord.x;\n    if (distanceFromSide < margin.x * 2.0 * THIRD) // 0.6666 in weight, so side grows towards tri's center of gravity\n    {\n        fragColor = BG_COLOR;\n        return;\n    }\n    \n    ////////////////////// Color + fade\n\n    vec3 col = GetColorByIndex(triangleIndex);\n    \n    // Calculate the t over the y of each triangle, and slightly darken over t\n    float tOverY;\n    if (isSegmentA)\n        tOverY = 0.5 + localFragCoord.y / GRID_HEIGHT;\n    else if (isSegmentB || isSegmentC)\n        tOverY = localFragCoord.y / GRID_HEIGHT;\n    else if (isSegmentD)\n        tOverY = localFragCoord.y / GRID_HEIGHT / 2.0;\n    \n    \n    // Introduce a small blink\n    float tBlink = pow((cos(PI * triangleScale + PI / 0.75) + 1.0) / 2.0, 10.0);\n    col += vec3(0.3) * tBlink;\n    \n    // Lerp color between index color and darkened variant for fade\n    vec3 darkenedCol = col * 0.6;\n    col = mix(darkenedCol, col, pow(tOverY, 0.75));\n    \n    // Lerp between background color and index color to simulate depth\n    col = mix(BG_COLOR.xyz, col, pow(triangleScale, 0.1));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}