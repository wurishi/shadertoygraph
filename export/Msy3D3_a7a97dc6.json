{"ver":"0.1","info":{"id":"Msy3D3","date":"1456696181","viewed":242,"name":"Morphball","username":"piratehurrdurr","description":"Testing some shapes and distortion here. Thanks to iq for the smin, and raymarching code. Enjoy this weird blob!\nPS: As an optimization I raytrace a sphere around the actual blob. I can improve this by actually starting the raymarch from the sphere thoug","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","test","displacement","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IT 4096*1\n#define MAX 64.0\n#define EP 1e-3\n#define EPN 1e-2\n#define CS .xzy\n\n#define E 2.71828182845904523536028747135266249775724709369995\n\n//Uncomment to only see AO\n//#define AMBONLY\n\n#define aoc 12\n#define aos 0.05\n#define aoa 5.0\n\nvec3 aoOffsets[aoc];\n\nvec3 amb(vec3 dir) {\n    \n    vec3 skyBase = vec3(0.6, 0.8, 0.6)*(1.0+0.6*dot(dir, vec3(0.0,0.0,-1.0)));\n    float sunStr = pow(max(1.05* dot(dir, normalize(vec3(1.0,1.0,1.0))),0.0),6.0);\n\tvec3 skySun = vec3(0.5,0.5,0.2)*sunStr;\n    return skySun+skyBase;\n    \n    /*\n    vec3 skyBase = vec3(0.6, 0.8, 0.9)*(1.0+0.6*dot(dir, vec3(0.0,0.0,-1.0)));\n    float sunStr = pow(max(1.05* dot(dir, normalize(vec3(1.0,1.0,1.0))),0.0),6.0);\n\tvec3 skySun = vec3(0.5,0.5,0.2)*sunStr;\n    return skySun+skyBase;\n\t*/\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nbool rtSphere(vec3 pos, vec3 n, float rad) {\n    \n    float tca = dot(pos, -n);\n    if (tca<EP) {\n        return false;\n    }\n    float d2 = dot(pos,pos)-tca*tca;\n    float rad2 = rad*rad;\n    if (d2>rad2) {\n        return false;\n    }\n    float thc = sqrt(rad2-d2);\n    float t0 = tca-thc;\n    float t1 = tca+thc;\n    if (t0>t1) {\n        float t2 = t1;\n        t1 = t0;\n        t0 = t2;\n    }\n    if (t0<0.0) {\n        t0 = t1;\n        if (t0<0.0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat displace(vec3 pos){\n    pos.z+=iTime/24.0;\n        return sin(pos.x*16.0+pos.y*8.0)*sin(pos.y*16.0+pos.z*8.0)*sin(pos.z*16.0+pos.x*8.0)/8.0;\n}\n\nfloat dist(vec3 pos) {\n    \n    float main = displace(pos)/5.0+\n        smin(\n        max(sphere(pos,0.4)+abs(displace(pos))/2.0+displace(pos.zyx)/2.0, displace(pos.yzx)*0.2+box(pos-vec3(-0.2),vec3(0.3))),\n            max(displace(pos)/5.0+sphere(pos,0.25+sin(iTime/5.6)*0.1), displace(-pos)+ box(pos+vec3(-0.2), vec3(0.3))),\n            12.0+sin(iTime)/6.0\n            );\n    \n    \n    return main;\n        \n    \n        /*\n    return \n        smin(\n        max(sphere(pos, 0.5)+abs(displace(pos)),\n               box(pos-vec3(-0.2),vec3(0.3))\n               ),16.0\n        //max(sphere(pos,0.35),48.0,box(pos+vec3(0.2),vec3(0.1))))\n        //);\n          */\n    //return max(box(pos,vec3(0.3)),-sphere(pos/vec3(1.0,2.0,1.0)+vec3(0.2),0.2));\n    \n}\n\n\nfloat AO(vec3 pos) {\n    float hit;\n    \n    \n    for (int i=0; i<aoc; i++) {\n        float d = dist(pos+aoOffsets[i]);\n        if (d>0.0) {\n            hit+=d;\n        }\n    }\n    \n    //float total = 3.0*3.0*3.0;\n    //for (int i=-1; i<=1; i++) {\n    //    for (int j=-1; j<=1; j++) {\n    //        for (int k=-1; k<=1; k++) {\n    //            float d= dist(pos+vec3(i,j,k)*0.1);\n    //            if (d>=0.0) {\n    //                hit+=d;\n    //            }\n    //                 }\n    //    }\n    //}\n    float total = float(aoc);\n    return max(min(hit/aos/total*aoa,1.0),0.0);\n}\n\nvec3 scan(vec3 pos, vec3 dir) {\n    \n    if (!rtSphere(pos, dir, 0.5))\n    {\n        return amb(dir);\n    }\n    \n    float totalDistance=0.0;\n    for (int i=0; i<IT; i++) {\n        float rayDist = dist(pos);\n        totalDistance+=rayDist;\n        if (abs(rayDist)<=EP) {\n            \n           #ifdef AMBONLY\n            return vec3(AO(pos));\n            #endif\n            \n            \n            \n            vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(pos + eps.yxx) - dist(pos - eps.yxx),\n    \t\tdist(pos + eps.xyx) - dist(pos - eps.xyx),\n    \t\tdist(pos + eps.xxy) - dist(pos - eps.xxy)));\n            \n            \n            \n            vec3 sunColor = vec3(1.0,0.8,0.4);\n            vec3 sunVector = normalize(vec3(1.0,1.0,1.0));\n            float sunAtten = max(0.0, dot(sunVector,normal));\n            \n            vec3 ambientColor = vec3(0.6,0.8,0.6);\n            float ambientAtten = AO(pos);\n            \n            vec3 reflDir = reflect(dir, normal);\n            sunAtten+=pow(max(dot(reflDir, sunVector),0.0),16.0)*ambientAtten;\n            \n            float fresnel = pow(1.0- abs(dot(dir,normal)),2.0);\n            \n            //return vec3(ambientAtten);\n            \n            vec4 fog = vec4(0.6, 0.8, 0.6,1.0-1.0/pow(E,totalDistance*0.05));\n            \n            vec3 light = mix(sunColor*sunAtten + ambientColor*ambientAtten, amb(reflDir)*ambientAtten, fresnel);\n            vec3 world = vec3(0.9,0.3,0.8)*light;\n            return mix(world, fog.rgb,fog.a);//*texture(iChannel2, normal).rgb;\n        }\n        if (totalDistance>=MAX) {\n            return amb( dir);\n        }\n        pos+=dir*(rayDist)*0.25;\n    }\n    \n    \n    return amb(dir);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 uv){\n    uv = (uv-iResolution.xy/2.0)/iResolution.y;\n    float a = iTime*0.125;\n    \n    \n\naoOffsets[0]=vec3(\taos*0.0\t\t\t,aos*-0.525731\t\t,aos*0.850651);\naoOffsets[1]=vec3(\taos*0.850651\t,aos*0.0\t\t\t\t,aos*0.525731);\naoOffsets[2]=vec3(\taos*0.850651\t,aos*0.0\t\t\t\t,aos*-0.525731);\naoOffsets[3]=vec3(\taos*-0.850651\t,aos*0.0\t\t\t\t,aos*-0.525731);\naoOffsets[4]=vec3(\taos*-0.850651\t,aos*0.0\t\t\t\t,aos*0.525731);\naoOffsets[5]=vec3(\taos*-0.525731\t,aos*0.850651\t\t,aos*0.0);\naoOffsets[6]=vec3(\taos*0.525731\t,aos*0.850651\t\t,aos*0.0);\naoOffsets[7]=vec3(\taos*0.525731\t,aos*-0.850651\t\t,aos*0.0);\naoOffsets[8]=vec3(\taos*-0.525731\t,aos*-0.850651\t\t,aos*0.0);\naoOffsets[9]=vec3(\taos*0.0\t\t\t,aos*-0.525731\t\t,aos*-0.850651);\naoOffsets[10]=vec3(\taos*0.0\t\t\t,aos*0.525731\t\t,aos*-0.850651);\naoOffsets[11]=vec3(\taos*0.0\t\t\t,aos*0.525731\t\t,aos*0.850651);\n\t\n\n    \n    //vec3 pos = vec3(cos(a/4.0+sin(a/2.0)),cos(a*0.2),sin(a*0.31)/4.5+1.0)*3.0;\n    vec3 pos = vec3(cos(iMouse.x/64.0),sin(iMouse.x/64.0),(iMouse.y-0.5)/512.0);\n    vec3 on = vec3(1.0,uv.x,uv.y);\n    vec3 n = normalize(pos);\n\n    //n = normalize(pos + (0.1*vec3(cos(a*2.3),cos(a*2.61),cos(a*1.62))));\n\tvec3 crossRight = normalize( cross(n,vec3(0.0,0.0,1.0)));\n\tvec3 crossUp = normalize(cross(n, crossRight));\n\tn = n*0.8 + crossRight*uv.x + crossUp*uv.y;\n    n = -normalize(n);\n    \n    fragColor.rgb = scan(pos,n).rgb;\n}","name":"Image","description":"","type":"image"}]}