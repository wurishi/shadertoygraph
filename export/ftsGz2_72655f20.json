{"ver":"0.1","info":{"id":"ftsGz2","date":"1622446962","viewed":1140,"name":"Raytracing Strange Jellyfish","username":"bloxard","description":"The first species of antigravity jellyfish discovered on the coast of Vanuatu. \nLocal fisherman Frank Wilson told reporters at the Vanuatu Daily: \"That shit is floatin' and whatnot.\" end quote.","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","transparency","grid","sun","spectrum","antialias","animation","jellyfish","quadratic","quartic","atmosphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Per Bloksgaard, 2021 - https://perbloksgaard.dk\n// Raytracing a strange antigravity jellyfish.\nconst float PI = 3.14159;\n\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n\tfloat hA = angle * 0.5;\n\tfloat s = sin(hA);\n\tfloat c = cos(hA);\n\treturn vec4(axis*s, c);\n}\n\nvec4 QuatMul(vec4 q, vec4 r)\n{\n\tvec4 nq;\n\tnq.x = q.w * r.x + q.x * r.w + q.y * r.z - q.z * r.y;\n\tnq.y = q.w * r.y - q.x * r.z + q.y * r.w + q.z * r.x;\n\tnq.z = q.w * r.z + q.z * r.w - q.y * r.x + q.x * r.y;\n\tnq.w = q.w * r.w - q.x * r.x - q.y * r.y - q.z * r.z;\n\treturn nq;\n}\n\nmat4 QuatToMat(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat4(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),0.,2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),0.,2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy),0.,0.,0.,0.,1.);\n}\n\nmat3 QuatToMat3(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat3(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy));\n}\n\nmat4 createObjectRotationMatrix(float fAzimuth, float fZenith, float fRoll)\n{\n\tvec4 u = QuatFromAxisAngle(vec3(0., 1., 0.), -fAzimuth);\n\tvec4 v = QuatFromAxisAngle(QuatToMat3(u) * vec3(1., 0., 0.), fZenith);\n\tv = QuatMul(v,u);\n\tvec4 w = QuatFromAxisAngle(QuatToMat3(v) * vec3(0., 0., 1.), -fRoll);\n\treturn QuatToMat(QuatMul(w,v));\n}\n\nmat3 createCameraRotationMatrix(float fU, float fV)\n{\n\tvec4 u = QuatFromAxisAngle(vec3(0., 1., 0.), -fU);\n\tvec4 v = QuatFromAxisAngle(QuatToMat3(u) * vec3(1., 0., 0.), fV);\n\treturn QuatToMat3(QuatMul(u,v));\n}\n\nmat4 translate(vec3 v)\n{\n\treturn mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., v.x, v.y, v.z, 1.);\n}\n\nfloat derivative(vec2 p)\n{\n\tvec2 dx = dFdx(p);\n\tvec2 dy = dFdy(p);\n\tvec2 d = p - floor(p);\n\treturn exp2(-0.31 * min((1. - d.x) * d.x, (1. - d.y) * d.y) / (dot(dx, dy) + dot(dy, dy) + 8e-4));\n}\n\nfloat floorGrid(vec2 p, float od)\n{\n\tvec2 d = p - floor(p);\n\treturn exp2(-0.23 * min((1. - d.x) * d.x, (1. - d.y) * d.y) / clamp(od * -1e-3 + od * od *25e-5,3e-3,1e4));\n}\n\nfloat waveSin(float x, float t)\n{\n\tfloat scalar = sin(x * PI / 8.);\n\tfloat y = sin((x + t * 0.25) * -1.3) * 2.38;\n\ty += sin((x + t * -0.075) * -23.89) * 1.41;\n\ty *= scalar * 0.34;\n\ty += scalar * 3.3;\n\treturn y;\n}\n\nvec3 skyColor(vec3 p)\n{\n\tfloat u = atan(p.z, p.x) + 0.68;\n\tp.x = cos(u);\n\tp.z = abs(sin(u));\n\tvec3 sunPos = vec3(0., 0.0998, 0.995);\n\tfloat h = 0.75 - 0.75 * dot(p, sunPos) * clamp(1. - 3.2*p.y, 0., 1.) * 0.89384734;\n\tfloat w = length(sunPos - p) * 20.;\n\tfloat fSkylar = clamp(1. - w * w * 73e-5, 0., 1.);\n\tvec3 vA = mix(vec3(0.894111, 0.517647, 0.109803), vec3(0.658823, 0.545098, 0.325490) * fSkylar, 4. * (h * 2. - 0.25)) * 0.75;\n\tvec3 vB = vec3(0.25 + 0.278285 * (dot(p, sunPos) + 1.));\n\tvec3 vC = (vA + vB) * 0.5;\n\tfloat l = w * 0.048402;\n\tvec3 z = vec3(1.,2.,3.) * 0.0446 - 0.8;\n\tvec3 sunColor = vec3(0.0028) / ((pow(vec3(0.5) + l + 1.8611 * (cos(0.5 - z)) * abs(sin(l * 8.9583 - z * 2.)), vec3(1.2)) - vec3(0.5)) * l);\n\treturn max(mix(vC, vC * 0.4 + sunColor, length(sunColor) * 1.5) + sunColor, vec3(0.2,0.25,0.4));\n}\n\nvec3 calcSceneColorNonDerivative(in vec3 vCamPos, in vec3 vRayDir)\n{\n\tfloat d = min(-vCamPos.y / min(vRayDir.y, -1e-6), 1e6);\n\tif (vRayDir.y > 0.)\n\t{\n\t\treturn skyColor(vRayDir);\n\t}\n\telse\n\t{\n\t\tvec3 vHitPos = vCamPos + vRayDir * d;\n\t\tfloat vDer = floorGrid(vHitPos.xz, d - acos(vRayDir.y)*d*0.4);\n\t\treturn clamp(mix(skyColor(vec3(vRayDir.x, -vRayDir.y, vRayDir.z)), vec3(1. - vDer), smoothstep(0., -0.2, vRayDir.y)), 0., 1.);\n\t}\n}\n\nvec3 calcSceneColorDerivative(in vec3 vCamPos, in vec3 vRayDir)\n{\n\tfloat d = min(-vCamPos.y / min(vRayDir.y, -1e-6), 1e6);\n\tif (vRayDir.y > 0.)\n\t{\n\t\treturn skyColor(vRayDir);\n\t}\n\telse\n\t{\n\t\tvec3 vHitPos = vCamPos + vRayDir * d;\n\t\tfloat fD = derivative(vHitPos.xz);\n\t\treturn clamp(mix(skyColor(vec3(vRayDir.x, -vRayDir.y, vRayDir.z)), vec3(1. - fD), smoothstep(0., -0.2, vRayDir.y)), 0., 1.);\n\t}\n}\n\nfloat addv(vec2 a)\n{\n\treturn a.x + a.y;\n}\n\nvec2 findQuadraticRoots(vec2 coeffs, float a)\n{\n\tfloat p = coeffs.y * 0.5;\n\tfloat D = p * p - coeffs.x;\n\tif (D <= 0.)\n\t{\n\t\treturn vec2(-1.);\n\t}\n\telse\n\t{\n\t\treturn vec2(-1, 1) * sqrt(D) - (p + a * 0.25);\n\t}\n}\n\nfloat findCubicRoot(vec3 a)\n{\n\tfloat p = a.y - a.x*a.x / 3.;\n\tfloat p3 = p*p*p;\n\tfloat q = a.x*(2.*a.x*a.x - 9.*a.y) / 27. + a.z;\n\tfloat d = q*q + 4.*p3 / 27.;\n\tfloat e = -a.x / 3.;\n\tif (d>.0)\n\t{\n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z, -z) - q) * 0.5;\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn e + uv.x + uv.y;\n\t}\n\tfloat v = acos(-sqrt(-27. / p3)*q*.5) / 3.;\n\treturn (cos(v)*2.) * sqrt(-p/3.) + e;\n}\n\nvec4 findQuarticRoots(vec4 qc)\n{\n\tfloat aa = qc.x*qc.x;\n\tfloat p = -0.375*aa+qc.y;\n\tfloat q = 0.125*aa*qc.x-0.5*qc.x*qc.y+qc.z;\n\tfloat r = -3./256.*aa*aa+1./16.*aa*qc.y-0.25*qc.x*qc.z+qc.w;\n\tfloat z = findCubicRoot(vec3(-0.5*p,-r,0.5*r*p-0.125*q*q));\n\tfloat u = z*z-r;\n\tfloat v = 2.*z-p;\n\tif (u > 0.)\n\t{\n\t\tu = sqrt(u);\n\t}\n\telse\n\t{\n\t\treturn vec4(-1.);\n\t}\n\tif (v > 0.)\n\t{\n\t\tv = sqrt(v);\n\t}\n\telse\n\t{\n\t\treturn vec4(-1.);\n\t}\n\tfloat sQ = sign(q);\n\treturn vec4(findQuadraticRoots(vec2(z-u,v*sQ),qc.x),findQuadraticRoots(vec2(z+u,v*-sQ),qc.x));\n}\n\nfloat evalQuad(float x, vec3 C)\n{\n\treturn C.z + x * (C.y + x * C.x);\n}\n\nvoid findCylinderNearFar(vec3 ro, vec3 rd, float r, vec2 cy, out float fNear, out float fFar)\n{\n\t// x^2 + z^2 = r^2 => (ro.x + t*rd.x)^2 + (ro.z + t*rd.z)^2 = r^2\n\tfloat fA = dot(rd.xz, rd.xz);\n\tfloat fB = 2. * dot(rd.xz, ro.xz);\n\tfloat fC = dot(ro.xz, ro.xz) - r * r;\n\tfloat fDet = fB * fB - 4. * fA * fC;\n\tif (fDet < 0.)\n\t{\n\t\tfNear = 0.;\n\t\tfFar = -1.;\n\t\treturn;\n\t}\n\tfloat sqrtD = sqrt(fDet);\n\tfloat inv2A = 1. / (2. * fA);\n\tvec2 p = (cy - ro.y) / rd.y;\n\tp += step(rd.y,0.) * (p.yx - p);\n\tfNear = max((-fB - sqrtD) * inv2A, p.x);\n\tfFar = min((-fB + sqrtD) * inv2A, p.y);\n}\n\nvec4 findQuarticMinDistance(vec3 Q, float offset, float fYDirectionDevisor, float cylinderRadius, vec3 rd, vec3 ro)\n{\n\trd.y /= fYDirectionDevisor;\n\tro.y += fYDirectionDevisor * 0.5;\n\tro.y -= offset;\n\tro.y /= fYDirectionDevisor;\n\tfloat near;\n\tfloat far;\n\tfindCylinderNearFar(ro, rd, cylinderRadius + 1e-3, vec2(-1e-3, 1. + 1e-3), near, far);\n\tif (far < 1e-3 || near > far)\n\t{\n\t\treturn vec4(0.,0.,0.,1e5);\n\t}\n\tnear = max(0., near);\n\tro += rd * near;\n\t// Equation solution here: perbloksgaard.dk/research/RayDistanceToBezierCylinder.jpg\n\tfloat A = Q.x * Q.x * rd.y * rd.y * rd.y * rd.y;\n\tfloat B = 2. * Q.x * rd.y * rd.y * rd.y * (2. * Q.x * ro.y + Q.y);\n\tfloat C = rd.y * rd.y * (6. * Q.x * ro.y * (Q.x * ro.y + Q.y) + 2. * Q.x * Q.z + Q.y * Q.y) - rd.x * rd.x - rd.z * rd.z;\n\tfloat D = rd.y * (ro.y * (Q.x * (4. * Q.x * ro.y * ro.y + 6. * Q.y * ro.y + 4. * Q.z) + 2. * Q.y * Q.y) + 2. * Q.y * Q.z) - 2. * (rd.x * ro.x + rd.z * ro.z);\n\tfloat E = ro.y * (Q.x * ro.y * (Q.x * ro.y * ro.y + 2. * Q.y * ro.y + 2. * Q.z) + Q.y * (Q.y * ro.y + 2. * Q.z)) + Q.z * Q.z - ro.x * ro.x - ro.z * ro.z;\n\tvec4 roots = findQuarticRoots(vec4(D, C, B, A) / E);\n\tfloat l = 1. / max(roots.x, max(roots.y, max(roots.z, roots.w)));\n\tif ((l > 1e-3) && l < (far - near))\n\t{\n\t\tvec3 w = ro + rd * l;\n\t\tvec3 q = vec3(normalize(w.xz) * (Q.y + Q.x * w.y * 2.), 1.);\n\t\treturn vec4(vec3(w.x*q.z,-w.x*q.x-w.z*q.y, w.z*q.z), near + l);\n\t}\n\treturn vec4(0.,0.,0.,1e5);\n}\n\nvec3 render(in vec2 uv, float aW[12], float aL[9], float aR[9], float maxGlobalRadius, vec3 vCamPosition, mat3 vCamMat, mat4 txx, mat4 txi)\n{\n\tconst int iC = 9;\n\tconst float fFocalLength = 3.732051;\n\tvec3 totalColorSum = vec3(0.);\n\tvec2 vScreenPixel = vec2(0.5) / vec2(iResolution);\n\tvec3 backGroundColor = calcSceneColorDerivative(vCamPosition, normalize(uv.x * vCamMat[0] + uv.y * vCamMat[1] + fFocalLength * vCamMat[2]));\n\tfor (int iR = 0; iR < 4; iR++)\n\t{\n\t\tint iX = iR / 2;\n\t\tint iY = iR % 2;\n\t\tvec3 rd = normalize((uv.x -vScreenPixel.x + vScreenPixel.x * 2. * float(iX)) * vCamMat[0] + (uv.y -vScreenPixel.y + vScreenPixel.y * 2. * float(iY)) * vCamMat[1] + fFocalLength * vCamMat[2]);\n\t\tvec3 ro = vCamPosition;\n\t\tvec3 lRD = (txi * vec4(rd, 0.)).xyz;\n\t\tvec3 lRO = (txi * vec4(ro, 1.)).xyz;\n\t\tvec3 colorSum = vec3(0.);\n\t\tfloat near, far;\n\t\tfindCylinderNearFar(lRO, lRD, maxGlobalRadius + 1e-3, vec2(-1e-3, float(iC) + 1e-3), near, far);\n\t\tif (far < 1e-3 || near > far)\n\t\t{\n\t\t\treturn backGroundColor;\n\t\t}\n\t\tfloat nearY = lRO.y + lRD.y * near;\n\t\tfloat farY = lRO.y + lRD.y * far;\n\t\tint iVEnd = iC;\n\t\tint iA = 0;\n\t\tint iANear = 0;\n\t\tint iAFar = 0;\n\t\tfloat fOffsetNear = 0.;\n\t\tfloat fOffsetFar = 0.;\n\t\tif (nearY > fOffsetNear)\n\t\t{\n\t\t\tfor (; iANear < 8; iANear++)\n\t\t\t{\n\t\t\t\tif ((fOffsetNear < nearY) && ((fOffsetNear + aL[iANear]) > nearY))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfOffsetNear += aL[iANear];\n\t\t\t}\n\t\t}\n\t\tif (farY > fOffsetFar)\n\t\t{\n\t\t\tfor (; iAFar < 8; iAFar++)\n\t\t\t{\n\t\t\t\tif ((fOffsetFar < farY) && ((fOffsetFar + aL[iAFar]) > farY))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfOffsetFar += aL[iAFar];\n\t\t\t}\n\t\t}\n\t\tfloat fInt = 1.;\n\t\tfloat localReflection = 1.0526315;\n\t\tfor (int h = 0; h < 4; h++)\n\t\t{\n\t\t\tvec4 i = vec4(0., 0., 0., 1e3);\n\t\t\tfloat fD = sign(float(iAFar - iANear));\n\t\t\tint dL = int(fD);\n\t\t\tint iAIdx = (fD > 0.) ? 0 : iC - 1;\n\t\t\tfloat fYOffset = (fD > 0.) ? 2e-2 : 2e-2 + float(iC);\n\t\t\tiVEnd = abs(iAFar - iANear) + 1;\n\t\t\tiAIdx = iANear;\n\t\t\tfYOffset = fOffsetNear;\n\t\t\tint iBIdx = iAIdx + 1;\n\t\t\tint iCIdx = iBIdx + 1;\n\t\t\tfor (int iV = 0; iV < iVEnd; iV++)\n\t\t\t{\n\t\t\t\tfloat a = aW[iAIdx];\n\t\t\t\tfloat b = aW[iBIdx];\n\t\t\t\tfloat c = aW[iCIdx];\n\t\t\t\tfYOffset += aL[iAIdx] * 0.5;\n\t\t\t\tvec4 di = findQuarticMinDistance(vec3(a-2.*b+c,-2.*a+2.*b,a+b), fYOffset, aL[iAIdx], aR[iAIdx], lRD, lRO);\n\t\t\t\tif (di.w > 1e-4 && di.w < 1e3)\n\t\t\t\t{\n\t\t\t\t\ti = di;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfYOffset += aL[iAIdx] * 0.5;\n\t\t\t\tif (dL < 0)\n\t\t\t\t{\n\t\t\t\t\tfYOffset -= aL[iAIdx];\n\t\t\t\t}\n\t\t\t\tiAIdx += dL;\n\t\t\t\tiBIdx += dL;\n\t\t\t\tiCIdx += dL;\n\t\t\t\tif (dL < 0)\n\t\t\t\t{\n\t\t\t\t\tfYOffset -= aL[iAIdx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i.w > 1e2)\n\t\t\t{\n\t\t\t\tif (h == 0)\n\t\t\t\t{\n\t\t\t\t\treturn backGroundColor;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolorSum += calcSceneColorNonDerivative(ro, rd) * fInt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec3 n = (txx * vec4(normalize(i.xyz), 0.)).xyz;\n\t\t\tvec3 posZNormal = faceforward(n, rd, n);\n\t\t\tfloat refac = mix(0.027, 0.77, clamp(pow(1. - dot(rd, -posZNormal), 2.8), 0., 1.));\n\t\t\tro += rd * (i.w + 2e-2) - posZNormal * abs(dot(rd, n) * 2e-2);\n\t\t\tvec3 color = clamp(calcSceneColorNonDerivative(ro, reflect(rd, posZNormal)) * refac * fInt, 0., 1.);\n\t\t\tif (h > 0)\n\t\t\t{\n\t\t\t\tcolor *= (1. + i.w * 9e-2);\n\t\t\t}\n\t\t\tcolorSum += color;\n\t\t\tfInt *= pow(0.36, refac);\n\t\t\trd = refract(rd, posZNormal, localReflection);           \n\t\t\tlRD = (txi * vec4(rd, 0.)).xyz;\n\t\t\tlRO = (txi * vec4(ro, 1.)).xyz;\n\t\t\tlocalReflection = 1.;\n\t\t}\n\t\ttotalColorSum += colorSum;\n\t}\n\treturn totalColorSum * 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat t = iTime + 126.5;\n\tfloat aW[12];\n\tfloat aL[9];\n\tfloat aR[9];\n\taW[1] = (waveSin(0.5, t) + waveSin(1., t))*0.35;\n\taW[0] = -aW[1];\n\tfor (int iWIdx = 2; iWIdx < 10; iWIdx++)\n\t{\n\t\taW[iWIdx] = waveSin(float(iWIdx - 1), t) - aW[iWIdx - 1];\n\t}\n\taW[9] = -aW[8] + aW[7] * 0.5;\n\taW[10] = -aW[9];\n\taW[11] = 0.0;\n\tfloat fSin;\n\taL[4] = 1.;\n\tfSin = sin(t*-1.5 + pow(0.4, 0.3)) * pow(0.4, 0.25);\n\taL[3] = 1. + fSin;\n\taL[5] = 1. - fSin;\n\tfSin = sin(t*-1.5 + pow(0.4, 0.3*2.)) * pow(0.4, 0.25*2.);\n\taL[2] = 1. + fSin;\n\taL[6] = 1. - fSin;\n\tfSin = sin(t*-1.5 + pow(0.4, 0.3*3.)) * pow(0.4, 0.25*3.);\n\taL[1] = 1. + fSin;\n\taL[7] = 1. - fSin;\n\tfSin = sin(t*-1.5 + pow(0.4, 0.3*4.)) * pow(0.4, 0.25*4.);\n\taL[0] = 1. + fSin;\n\taL[8] = 1. - fSin;\n\tfloat maxGlobalRadius = 0.;\n\tfor (int iR = 0; iR < 9; iR++)\n\t{\n\t\tfloat a = aW[iR];\n\t\tfloat b = aW[iR + 1];\n\t\tfloat c = aW[iR + 2];\n\t\tvec3 Q = vec3(a - 2.*b + c, -2.*a + 2.*b, a + b);\n\t\tfloat maxRadius = max(evalQuad(clamp(-Q.y / (2.*Q.x), 0., 1.), Q), max(evalQuad(0., Q), evalQuad(1., Q)));\n\t\tmaxGlobalRadius = max(maxGlobalRadius, maxRadius);\n\t\taR[iR] = maxRadius;\n\t}\n\tmat4 qM = createObjectRotationMatrix(sin(t*1e-2)*1e-2,sin(t*0.37)*0.45-4.67,sin(t*0.25)*0.9+1.1);\n\tvec3 vObjPos = vec3(cos(0.8)*t*-2.1, 5.63, sin(0.8)*t*-2.1);\n\tvec3 vObjCenter = vec3(0., 4.5, 0.);\n\tmat4 txi = translate(vObjCenter) * qM * translate(-vObjPos);\n\tmat4 txx = inverse(txi);\n\tmat3 vCamMat = createCameraRotationMatrix(-cos(t*0.11)*0.25+9.87, sin(-t*0.31)*0.16-0.007158);\n\tmat3 iQM = inverse(mat3(qM));\n\tvec3 vCamPosition = vObjPos - vCamMat[2] * (17. - cos(t * 0.4) * 7.);\n\tvCamPosition.xz += iQM[1].xz * (dot(vObjPos - vCamPosition, iQM[1]) / dot(iQM[1], iQM[1])) * 0.6;\n    vec2 s = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n\tfragColor = vec4(render(s, aW, aL, aR, maxGlobalRadius, vCamPosition, vCamMat, txx, txi),1.);\n}\n","name":"Image","description":"","type":"image"}]}