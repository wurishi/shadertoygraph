{"ver":"0.1","info":{"id":"fsGfzK","date":"1658447296","viewed":199,"name":"Cartoon Physics Timing Curve","username":"ShinyFilms","description":"Plot Kinematic Timing Curve with animated motion sample demonstrating the \"cartoon physics\" effects. \nAs seen in Kinematic Timing Curves: Cartoon Physics with Ease https://www.jcgt.org/published/0011/03/02/\nThe curve color shows the velocity.\n","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["animation","smoothstep","ease","timingcurve","cartoonphysics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Kinematic Timing Curve - Cartoon Physics With Ease\n\n// PLOT CONFIGURATION\n// Plotting code thanks to \"2D Function Plotter\" by inequation \n// https://www.shadertoy.com/view/4d23Rm\n\n// Very nice sliders from \"2D Canvas with UI\" by Good\n// https://www.shadertoy.com/view/XlG3WD\n\n// function sampling range\nvec2 xRange = vec2(-0.10, 1.1);\n// drawn range of the Y axis\nvec2 yRange = vec2(-0.1, 1.25);\n\n// colours\nconst vec4 background = vec4(0.20, 0.20, 0.20,1.0);\nconst vec3 functionHot = vec3(1.0, 0.0, 0.0);\nconst vec3 functionCold = vec3(0.0, 0.0, 1.0);\nconst vec3 axes = vec3(0.0, 0.0, 0.0);\nconst vec4 discColor = vec4(0.0, 1.0, 0.0, 1.0);\n\n\n// function plot line thickness in pixels\nconst float thickness = 5.0;\n// function plot-following dot thickness in pixels\nconst float dotThickness = 12.0;\nconst float M_PI = 3.141592;\n\n//  Kinematic Timing Curve parameters\nfloat anticipationTime;\nfloat midPoint;\nint Bounces;\n\n// Smooth timing curve value\nfloat Xs(float t, float ta, float tmid) {\n    float tam = ta - tmid - tmid; // ta - 2tmid\n    \n    if(t<=tmid) { \n        return (2.0*t*(ta - t) / (ta*tmid + tam));\n    }\n    float xd = ((t - 2.0)*t*tam + (ta - 2.0)*tmid*tmid);\n    xd /= ((tmid-1.0)*(ta*tmid + tam));\n    \n    return xd;\n}\n\n// Overshoot timing curve value\nfloat Xo(float t, float ta, float tmid, float B) {\n    float tma = tmid - ta; \n\n    if(t>tmid) {   \n        float td = 1.0 - tmid; \n        float amp = td*(tmid + tma)/(tmid*tma*B*M_PI);\n\n        float xd = amp * sin(B*M_PI*(t - tmid)/td);\n        xd *= exp(-(t - tmid)*(B/(4.0*td)));\n        return xd + 1.0;\n    }\n    return t*(t - ta) / (tmid*tma);\n}\n\n// Timing curve with anticipation, ta, midpoint, tmid, and bounces, B \nfloat KinematicTiming(float t, float ta, float tmid, int B) {\n    return B>=1 ? Xo(t,ta,tmid,float(B)) : Xs(t,ta,tmid);\n}\n\n// Speed of curve, for coloring\nfloat Vs(float t, float ta, float tmid) {\n    float tam = ta - tmid - tmid; // ta - 2tmid\n    float va = (2.0*(ta - 2.0*t) / (ta*tmid + tam));    \n    float vd = (t - 1.0)*2.0*tam/((tmid-1.0)*(ta*tmid + tam));\n    \n    return t<tmid ? va : vd;\n}\n\nfloat Vo(float t, float ta, float tmid, float B) {\n    float tma = tmid - ta; \n\n    if (t>tmid) {    \n        float amp = (1.0 - tmid)*(tmid + tma)/(tmid*tma*B*M_PI);\n        float dk = -B/(4.0*(1.0-tmid));\n        float e = exp(dk*(t - tmid));\n        float vd = (B*M_PI/(1.0 - tmid)) * e * cos(B*M_PI*(t - tmid)/(1.0 - tmid));\n        vd += dk * e * sin(B*M_PI*(t - tmid)/(1.0 - tmid));\n        vd *= amp;\n        return vd;\n    }    \n    \n    return (2.0*t - ta) / (tmid*tma);    \n}\n\nfloat Speed(float t, float ta, float tmid, int B) {\n    return B>=1 ? Vo(t,ta,tmid,float(B)) : Vs(t,ta,tmid);\n}\n\n// function to sample\nfloat f(float x)\n{\n    return KinematicTiming(x,anticipationTime, midPoint, Bounces);\n    return (3.0 - 2.0*x)*x*x;\n\treturn sin(x);\n\treturn 0.5 * x;\n}\n\nfloat v(float x)\n{\n    return Speed(x,anticipationTime, midPoint, Bounces);\n}\n\n// @return\tGiven relative real Y value converted to pixels.\nfloat realYToPixels(float real)\n{\n\treturn real / (yRange.y - yRange.x) * iResolution.y;\n}\n\n// @return\tGiven relative real X value converted to pixels.\nfloat realXToPixels(float real)\n{\n\treturn real / (xRange.y - xRange.x) * iResolution.x;\n}\n\n// @return\tAlpha for a pixel which is dist away for a given max allowed radius.\nfloat coverage(float dist, float radius)\n{\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\n\n// render disc at pos at cenRad.xy, with radius cenRad.z over bg\nvec4 Disc(vec2 pos, vec3 cenRad, vec4 color, vec4 bg) {\n    float d = length(pos - cenRad.xy);\n    return d<cenRad.z ? color : bg;\n}\n\n//////////////////////////////\n//   Read UI State          //\n//////////////////////////////\nfloat readFloat(float address) { return texture(iChannel0, (floor(vec2(address, 1))+0.5) / iChannelResolution[0].xy).r; }\nvec4 readVec4(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    midPoint = clamp(readFloat(1.),0.1, 0.9);\n    anticipationTime = 0.2*readFloat(3.);\n    Bounces = int(6.0*readFloat(2.));\n\n    float w = (xRange.y - xRange.x);\t\n\tfloat x = xRange.x + w * (fragCoord.x / iResolution.x);\n    float y = x>=0.0 ? (x>1.0 ? 1.0:f(x)) : 0.0;\n\tvec2 actualYRange = yRange;\t\n\n\tfloat speed  = 0.25;\n\tfloat actualY = actualYRange.x + (actualYRange.y - actualYRange.x) * (fragCoord.y / iResolution.y);\n\t\n\t// plot dot :)\n\tfloat dotX = xRange.x + fract(speed*iTime) * w;\n    int stp = int(speed*iTime); \n\t// function heat\n\tfloat heat = (x - dotX) / w;\n\tif (heat < 0.0)\n\t\theat += 1.0;\n\tvec3 funcColour = mix(functionCold, functionHot, heat);\n    funcColour = mix(functionCold, functionHot, 0.25*(1.0 + (x>1.0 ? 0.0:v(x)) ));\n\t// plot colour\n\tfloat distY = abs(y - actualY)*(iResolution.y/iResolution.x);\n\tvec4 plot = vec4(funcColour, coverage(realYToPixels(distY), thickness));\n\t// plot dot, continued\n\tfloat distX = abs(x - dotX);\n\tfloat dist = sqrt(distY * distY  + distX * distX);\n\t// composition\n\tplot = mix(plot, discColor, coverage(realYToPixels(dist), dotThickness));\n\t\n\t// axis colour\n\tvec4 xAxis = vec4(axes, coverage(realXToPixels(abs(x)), thickness));\n\tvec4 yAxis = vec4(axes, coverage(realYToPixels(abs(actualY)), thickness));\n\tvec4 axis = xAxis * xAxis.a + yAxis * yAxis.a;\n    \n    float dash = actualY<0.0 || mod(fragCoord.y,16.0) > 8.0 ? 0.0 : 1.0;\n\txAxis = vec4(axes+0.7, dash*coverage(realXToPixels(abs(x-1.0)), thickness*0.5));\n    dash = x<0.0 || mod(fragCoord.x,16.0) > 8.0 ? 0.0 : 1.0;\n\tyAxis = vec4(axes+0.7, dash*coverage(realYToPixels(abs(actualY-1.0)), thickness*0.5));\n    axis += xAxis * xAxis.a + yAxis * yAxis.a;\n    \n    yAxis.x = Bounces>0 ? 1.0 : midPoint;\n    dash = mod(fragCoord.y,32.0) > 8.0 ? 0.0 : (actualY >0.0 && actualY<yAxis.x ? 1.0 : 0.0);\n\txAxis = vec4(axes+0.7, dash*coverage(realXToPixels(abs(x-midPoint)), thickness*0.5));\n    axis += xAxis * xAxis.a;\n\t\n\tvec4 foreground = mix(axis, plot, plot.a);\n\tfragColor = mix(background, foreground, foreground.a);\n    \n    float tfrac = fract(speed*iTime);\n \n    fragColor = Disc(fragCoord/iResolution.xx, vec3(0.1/w + f(tfrac)/w,0.5, 0.01),discColor,fragColor);\n    fragColor = Disc(fragCoord/iResolution.xx, vec3(0.1/w + 1.0/w,0.5, 0.0075*(1.0 - tfrac)),discColor,fragColor);\n    fragColor = Disc(fragCoord/iResolution.xx, vec3(0.1/w ,0.5, 0.0075*tfrac),discColor,fragColor);\n   \n    //UI integration\n    vec4 ui = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor.rgb = mix(fragColor.rgb,ui.rgb, ui.a*0.8);\n        \n\tfragColor = vec4( fragColor.rgb, 1. );\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// originally: https://www.shadertoy.com/view/XlG3WD\n\n#define UI_COLOR vec3(1,1,1)\n\n//8x8 font \n#define _A text.w += char(0x386C, 0xC6C6, 0xFEC6, 0xC600); \n#define _B text.w += char(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00);\n#define _C text.w += char(0x3C66, 0xC0C0, 0xC066, 0x3C00);\n#define _D text.w += char(0xF8CC, 0xC6C6, 0xC6CC, 0xF800);\n#define _E text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00);\n#define _F text.w += char(0xFEC0, 0xC0FC, 0xC0C0, 0xC000);\n#define _G text.w += char(0x3E60, 0xC0CE, 0xC666, 0x3E00);\n#define _H text.w += char(0xC6C6, 0xC6FE, 0xC6C6, 0xC600);\n#define _I text.w += char(0x7E18, 0x1818, 0x1818, 0x7E00);\n#define _J text.w += char(0x606, 0x606, 0x6C6, 0x7C00);\n#define _K text.w += char(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00);\n#define _L text.w += char(0x6060, 0x6060, 0x6060, 0x7E00);\n#define _M text.w += char(0xC6EE, 0xFEFE, 0xD6C6, 0xC600);\n#define _N text.w += char(0xC6E6, 0xF6FE, 0xDECE, 0xC600);\n#define _O text.w += char(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _P text.w += char(0xFCC6, 0xC6C6, 0xFCC0, 0xC000);\n#define _Q text.w += char(0x7CC6, 0xC6C6, 0xDECC, 0x7A00);\n#define _R text.w += char(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00);\n#define _S text.w += char(0x78CC, 0xC07C, 0x6C6, 0x7C00);\n#define _T text.w += char(0x7E18, 0x1818, 0x1818, 0x1800);\n#define _U text.w += char(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00);\n#define _V text.w += char(0xC6C6, 0xC6EE, 0x7C38, 0x1000);\n#define _W text.w += char(0xC6C6, 0xD6FE, 0xFEEE, 0xC600);\n#define _X text.w += char(0xC6EE, 0x7C38, 0x7CEE, 0xC600);\n#define _Y text.w += char(0x6666, 0x663C, 0x1818, 0x1800);\n#define _Z text.w += char(0xFE0E, 0x1C38, 0x70E0, 0xFE00);\n\n#define A text.w += char(0x0, 0x7C06, 0x7EC6, 0x7E00);\n#define B text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00);\n#define C text.w += char(0x0, 0x7EC0, 0xC0C0, 0x7E00);\n#define D text.w += char(0x606, 0x7EC6, 0xC6C6, 0x7E00);\n#define E text.w += char(0x0, 0x7CC6, 0xFEC0, 0x7C00);\n#define F text.w += char(0xE18, 0x7E18, 0x1818, 0x1800);\n#define G text.w += char(0x0, 0x7EC6, 0xC67E, 0x67C);\n#define H text.w += char(0xC0C0, 0xFCC6, 0xC6C6, 0xC600);\n#define I text.w += char(0x1800, 0x3818, 0x1818, 0x7E00);\n#define J text.w += char(0xC00, 0x1C0C, 0xC0C, 0xC78);\n#define K text.w += char(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00);\n#define L text.w += char(0x3818, 0x1818, 0x1818, 0x7E00);\n#define M text.w += char(0x0, 0xFCB6, 0xB6B6, 0xB600);\n#define N text.w += char(0x0, 0xFCC6, 0xC6C6, 0xC600);\n#define O text.w += char(0x0, 0x7CC6, 0xC6C6, 0x7C00);\n#define P text.w += char(0x0, 0xFCC6, 0xC6FC, 0xC0C0);\n#define Q text.w += char(0x0, 0x7EC6, 0xC67E, 0x606);\n#define R text.w += char(0x0, 0x6E70, 0x6060, 0x6000);\n#define S text.w += char(0x0, 0x7CC0, 0x7C06, 0xFC00);\n#define T text.w += char(0x1818, 0x7E18, 0x1818, 0x1800);\n#define U text.w += char(0x0, 0xC6C6, 0xC6C6, 0x7E00);\n#define V text.w += char(0x0, 0x6666, 0x663C, 0x1800);\n#define W text.w += char(0x0, 0xB6B6, 0xB6B6, 0x7E00);\n#define X text.w += char(0x0, 0xC6FE, 0x38FE, 0xC600);\n#define Y text.w += char(0x0, 0xC6C6, 0xC67E, 0x67C);\n#define Z text.w += char(0x0, 0xFE1C, 0x3870, 0xFE00);\n\n#define _0 text.w += char(0x384C, 0xC6C6, 0xC664, 0x3800);\n#define _1 text.w += char(0x1838, 0x1818, 0x1818, 0x7E00);\n#define _2 text.w += char(0x7CC6, 0xE3C, 0x78E0, 0xFE00);\n#define _3 text.w += char(0x7E0C, 0x183C, 0x6C6, 0x7C00);\n#define _4 text.w += char(0x1C3C, 0x6CCC, 0xFE0C, 0xC00);\n#define _5 text.w += char(0xFCC0, 0xFC06, 0x6C6, 0x7C00);\n#define _6 text.w += char(0x3C60, 0xC0FC, 0xC6C6, 0x7C00);\n#define _7 text.w += char(0xFEC6, 0xC18, 0x3030, 0x3000);\n#define _8 text.w += char(0x78C4, 0xE478, 0x9E86, 0x7C00);\n#define _9 text.w += char(0x7CC6, 0xC67E, 0x60C, 0x7800);\n#define EXC text.w += char(0x3838, 0x3830, 0x3000, 0x3000);\n#define QTN text.w += char(0x7CFE, 0xC60C, 0x3800, 0x3800);\n#define COM text.w += char(0x0, 0x0, 0x30, 0x3060);\n#define APO text.w += char(0x3030, 0x3000, 0x0, 0x0);\n\n#define MINUS text.w += char(0x0, 0x003c, 0x0, 0x0); \n#define STP text.z-=2.0; text.w += char(0x0, 0x0, 0x30, 0x3000); text.z-=4.0;\n\n#define SP text.z+=4.;\n#define _ text.z+=4.;\n#define NL text.z=0.; text.y-=9.0;\n\nvec2 pixel;\nvec4 text;//x y index result\nfloat ui = 0.0;\nvec4 result;    \n\nfloat char(int b1, int b2, int b3, int b4){\n  int bin; \n  vec2 p = pixel - text.xy - vec2(text.z, 0); \n  text.z += 9.0; \n  if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n  p = floor(8.0-p);    int c = int(p.y / 2.0);\n  if (c == 0){bin = b1;}else if (c == 1){bin = b2;}else if (c == 2){bin = b3;}else if(c == 3){bin = b4;}\n  if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n  return mod(floor(float(bin) / pow(2.0, p.x)), 2.0);\n}\nvoid digit(float d){\n    if(d == 0.)_0 else if(d == 1.)_1 else if(d == 2.)_2 else if(d == 3.)_3 else if(d == 4.)_4\n    else if(d == 5.)_5 else if(d == 6.)_6 else if(d == 7.)_7 else if(d == 8.)_8 else if(d == 9.)_9        \n}\nvoid drawNumber(float val, float fractPrecision){  \n    if(sign(val)==-1.0) MINUS //draw minus sign if needed\n    val = abs(val);    \n    float intCount = floor(val)==0.0 ? 1.0 : floor(log(val)/2.302585) +1.;//calculate int part length\n    // log10(val) = log(val)/2.302585    \n    if(fractPrecision > 0.){val *= pow(10.,fractPrecision);}  // move decimal point \n    val = floor(val); // strip the fractional part   \n    float count = intCount + fractPrecision; //totla number of digits to print    \n    if(count > 8.){ E R R O R return;} //show error if count > 8 \n    float pw = pow(10., count-1.);\n    for(float i = 8.;i > 0.;i--){ // 8 is max digit per number\n        if(count<i){ continue;} //skip unnecessary loops\n        if(i-fractPrecision == 0.){STP} //draw decimal point        \n        float d = floor(val/pw); //get one digit\n        digit( d ); //draw digit\n        val -= d*pw; pw /= 10.; //prepare for next iteration\n    }\n}\n\n\nvoid newText(vec2 p, in vec2 o){pixel = p; text= vec4(o, 0,0);}\nvoid moveCursor(in vec2 o){text.xy = o; text.z=0.0;}\nfloat outputText(){return text.w;}\n\nfloat printFloat(float val, float prec, vec2 p, vec2 o){\n    newText(p, o);  drawNumber(val, prec); return outputText();\n}\n\nfloat printVec2(vec2 val, float prec, vec2 p, vec2 o){ \n    newText(p, o);\n    float str = 0.0;\n    drawNumber(val.x, prec);\n    _ COM _\n    drawNumber(val.y, prec);    \n    str += outputText();    \n    return str;\n}\n\n\n\n// distance functions\nfloat dfBox(vec2 p, vec2 size) {vec2 d = abs(p)-size; return max(d.x, d.y);}\nfloat dfBox(vec2 p, vec4 b) {vec2 d = abs(-b.xy-b.zw*.5 + p) - b.zw*.5; return max(d.x, d.y);}\nfloat dfBoxRounded(vec2 p, vec2 size, float radius){ size -= vec2(radius); vec2 d = abs(p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat dfBoxRounded(vec2 p, vec4 b, float radius){ vec2 size = b.zw*.5-vec2(radius); vec2 d = abs(-b.xy-b.zw*.5 + p)-size;  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;}\nfloat fillMask(float dist){return clamp(-dist, 0.0, 1.0);}\n\n\n// read/write\nvec4 readPixel(vec2 address) { return texture(iChannel0, (floor(address)+0.5) / iChannelResolution[0].xy); }\nbool isCell(in vec2 p, in vec2 a) { return floor(p.x) == a.x && floor(p.y) == 1.0;}    \nvoid setPixel(vec2 address, vec4 val){if(isCell(pixel, address)){result=val;}}\n\n//slider\nvoid drawSlider(int id, float val, inout float ui, vec2 p, vec4 b){  \n    \n    float gap = 5.;\n    vec4 data = readPixel(vec2(id,1)); \n    \n    //if first frame write default value\n    if(data.g < 0.1){ \n        data = vec4(val,.4,0,1);\n        setPixel(vec2(id,1), data);\n    }    \n    \n    //draw bg\n    ui = mix(ui, .6, fillMask(dfBoxRounded(p,b,4.0))); \n    \n    //if mouse over slider write new value\n    if(dfBox(iMouse.xy,b)<=gap){\n        float distanceFromLeftEdge = clamp(iMouse.x, b.x, b.x+b.z)-b.x;\n        data.r = distanceFromLeftEdge/ b.z;        \n        //data.a=1.0;\n        setPixel(vec2(id,1), data);\n        \n        b.w=35.0;\n    }\n    \n    //draw sliding bar   \n    if(ui >=0.6){\n    \tb.z *= data.r;\n        ui = mix(ui, .8, fillMask(dfBox(p,b)));\n    }\n    \n    //draw number    \n    vec4 tmp = text;\n    ui = mix(ui, 0., printFloat(data.r, 3., p, b.xy + vec2(8., 5.)));\n    text = tmp;\n    \n}\n\n\nvec4 bounds = vec4(0.1,0.7,0.2,18);\n#define EASYSLIDER(id,val) drawSlider(id, val, ui, pixel, bounds); moveCursor(bounds.xy + vec2(3,20)); bounds.y -=40.;\n\nvec4 def = vec4(0.5,0.01,0.001,0) ;\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = fragCoord.xy;\n    bounds.xyz *= iResolution.xyx;\n    result = p.y<2.0 ? vec4(texture(iChannel0, p/iResolution.xy).rgb, 0) : vec4(0);\n    newText(p,vec2(0)); //for labels\n\n    //define sliders    \n    EASYSLIDER(1,def.x)  _M I D P O I N T  \n    EASYSLIDER(2,def.y)  _B O U N C E S      \n    EASYSLIDER(3,def.z)  _A N T I C I P A T E   \n          \n    result = mix(result, vec4(UI_COLOR,1), ui); //add sliders\n    result = mix(result, vec4(UI_COLOR,1), text.w*.8); //add labels\n\n    fragColor=result;    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}