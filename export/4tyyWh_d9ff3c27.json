{"ver":"0.1","info":{"id":"4tyyWh","date":"1536079625","viewed":619,"name":"[ZMB] TileNoise","username":"ZiMMaBuE","description":"Tile noise inspired by: https://www.shadertoy.com/view/4dlGW2\n\nMove the MOUSE to change the OFFSET of the noise or you can change it in the PARAMETERS!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","value","tile","ridged"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------------------------------------\n//------TILE-NOISE------------------------------------\n//------by-ZiMMaBuE--------(@zimmabue Twitter)--------\n//----------------------------------------------------\n//\n// The original version was created by David Hoskins, Sept. 2013.\n// https://www.shadertoy.com/view/4dlGW2\n//\n// Hold down the left button and move the MOUSE to change the\n// OFFSET of the noise or you can change it in the PARAMETERS\n//\n// Uncomment the HASH_VIEW to see only the hash function\n//\n//----------------------------------------------------\n//------PARAMETERS------------------------------------\n//----------------------------------------------------\n//#define HASH_VIEW\n#define SHOW_TILE\n\nconst vec2 OFFSET = vec2(11, 21);\nconst int MODE = 1; \t\t//0: FBM, 1: RIDGED, 2: VORONOI\nconst int OCTAVES = 5;\nconst float SCALE = 5.0;\nconst int TILING = 3;\n\n//----------------------------------------------------\n//------NOISE-----------------------------------------\n//----------------------------------------------------\n\nint p[] = int[](151,160,137,91,90,15,\n 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,\n               \n 151,160,137,91,90,15,\n 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180);\n\nfloat currentTiling = SCALE;\n\nfloat hash(vec2 uv)\n{\n    uv = mod(uv, currentTiling);\n    uv += OFFSET + floor(iMouse.xy * .1);\n    \n    int ix = int(uv.x);\n    int iy = int(uv.y);\n    \n    ix &= 255;\n    iy &= 255;\n    \n    return float(p[ix + p[iy]]) / 255.0;\n}\n\nvec2 hash2(vec2 uv)\n{\n    uv = mod(uv, currentTiling);\n    uv += OFFSET + floor(iMouse.xy * .1);\n    \n    int ix = int(uv.x);\n    int iy = int(uv.y);\n    \n    ix &= 255;\n    iy &= 255;\n    \n\treturn vec2(p[ix + p[iy]], p[iy + p[ix]]) / 255.;\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1., 0.));\n    float c = hash(i + vec2(0., 1.));\n    float d = hash(i + vec2(1., 1.));\n    \n    float m1 = mix(a, b, f.x);\n    float m2 = mix(c, d, f.x);\n    return mix(m1, m2, f.y);\n}\n\nfloat fbm(vec2 p, int oct)\n{\n\tfloat amp = 1.;\n    float freq = 1.;\n    float sum = amp;\n    \n    float res = 0.;\n    for(int i=0; i<oct; i++){\n    \tres += noise(p * freq) * amp;\n        amp *= .5;\n        freq *= 2.;\n        currentTiling *= 2.;\n        sum += amp;\n    }\n    \n    return res / sum;\n}\n\nfloat ridged(vec2 p, int oct)\n{\n\tfloat amp = 1.;\n    float freq = 1.;\n    float sum = amp;\n    \n    float res = 0.;\n    for(int i=0; i<oct; i++){\n    \tres += abs(noise(p * freq) * 2.-1.) * amp;\n        amp *= .5;\n        freq *= 2.;\n        currentTiling *= 2.;\n        sum += amp;\n    }\n    \n    return pow(1.-(res / sum), 3.);\n}\n\nfloat voronoi(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    \n    float minDist = 8.0;\n    for(int j=-2; j<=2; j++)\n    {\n    \tfor(int i=-2; i<=2; i++)\n        {\n            vec2 id = vec2(float(i), float(j));\n            vec2 cellPoint = hash2(id + ip);\n            vec2 realPoint = id + cellPoint - fp;\n            \n            float d = dot(realPoint, realPoint);\n            minDist = min(minDist, d);\n            \n        }\n    }\n    \n    return minDist;\n}\n\n//----------------------------------------------------\n//------MAIN------------------------------------------\n//----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= ((iResolution.x - iResolution.y) * .5) / iResolution.y;\n    if(uv.x > 1. || uv.x < 0.){\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec4 col = vec4(0.);\n    \n    // Noise coloring\n    uv *= SCALE * float(TILING);\n    \n    #ifdef SHOW_TILE\n        vec2 line = smoothstep(.99, .999, fract(uv / SCALE));\n        col += vec4(1,1,0,1) * (line.x + line.y);\n    #endif\n    \n    #ifdef HASH_VIEW\n    \tcol += vec4(hash(uv));\n        fragColor = col;\n        return;\n    #endif\n    \n    float value = 0.0;\n    if(MODE == 0)\n    \tvalue = fbm(uv, OCTAVES);\n    else if(MODE == 1)\n        value = ridged(uv, OCTAVES);\n\telse\n        value = voronoi(uv);\n    col += vec4(value);\n\n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}