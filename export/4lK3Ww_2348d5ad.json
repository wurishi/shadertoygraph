{"ver":"0.1","info":{"id":"4lK3Ww","date":"1474950609","viewed":447,"name":"Fibonacci Ballet","username":"villedieumorgan","description":"Little visual experiment since I've always be amazed by Mathematical beauty. \nStarted with the simple idea of uniformly arranging points on a sphere using Fibonacci Lattices.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","math","music","sphere","dots","points","fibonacci"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n/* \nMADE BY MORGAN VILLEDIEU\nTW : https://twitter.com/VilledieuMorgan\nClick and drag to rotate and to toggle the noise effect\nto read more about the distribution\nhttp://blog.wolfram.com/2011/07/28/how-i-made-wine-glasses-from-sunflowers/\n*/\n\n#define TAU asin(1.)*4.\n#define PI TAU*0.5\n#define N 300.\n#define PS 0.0001\n#define R 0.1\n#define DIST_CAM 3.8\n#define SPEED_ANIM 0.001\n#define NOISE_ANIM true\n\nvec3 Rxy( const in vec3 vP, const in vec2 m )\n{\n  float s = sin(m.x);\n  float c = cos(m.x);\n  float sb = sin(m.y);\n  float cb = cos(m.y);\n  vec3 newVP = vec3( vP.x, c * vP.y + s * vP.z, -s * vP.y + c * vP.z);\n  return vec3( cb * newVP.x + sb * newVP.z, newVP.y, -sb * newVP.x + cb * newVP.z);\n}\n\nfloat sdC(vec3 p, vec3 t, float r){return length(p-t)-r;}\nvec3 MixS(float sd, vec3 f, vec3 t){return mix(f, t, smoothstep(0.0,1.0/iResolution.y, sd));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.y;\n  uv -= (iResolution.xy / iResolution.y) / 2.0;\n  vec2 rUV = fragCoord.xy/iResolution.xy;\n  vec2 m = (iMouse.xy /iResolution.xy) * 2.-1.;\n  float dC = DIST_CAM;\n  bool md = iMouse.z < 1.;\n  vec3 col = md ? vec3(0.) : vec3(1.);\n  vec3 pc = !md ? vec3(0.) : vec3(1.);\n  float tNoise = texture(iChannel0, rUV).r * texture(iChannel1, rUV).r * min(iTime*0.01, 1.);\n  dC *= NOISE_ANIM && md ? tNoise + 0.9 : 1.;\n  float at = min(iTime*SPEED_ANIM, 1.);\n  float tn = (2. * N + 1.);\n  vec2 uvDc = uv/dC;\n  for(float i = -N;i <= N;i+=1.)\n  {\n    vec2 ll = vec2(mod(i * at, 1.618034) * 3.883222, asin((2. * i) / tn));  \n    vec3 d = Rxy( R * vec3( cos(ll.x) * cos(ll.y), cos(ll.x) * sin(ll.y), sin(ll.x)), m.yx );\n    float pd = sdC(vec3(uvDc, d.z), d, PS);\n    col = MixS(pd, pc + 20.*(d.z/dC), col);\n  }\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}