{"ver":"0.1","info":{"id":"XdV3DK","date":"1456478779","viewed":148,"name":"BezierPathTest Multiple Paths","username":"Sleicreider","description":"This is a Bezier Path Test Simulation for me.. nooby pls dont judge me","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","noob","bezierpath"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define YELLOW vec3(1.,1.,0.)\n#define BLUE vec3(0.,0.,1.)\n\nstruct Rect\n{\n    float width;\n    float height;\n    float x;\n    float y;\n    vec3  color;\n    float rotation;\n    \n    vec2 csys; //it's own coordinate system\n};\n   \nRect CreateRect(float width, float height, float x, float y, vec3 color)\n{\n    Rect rect;\n    \n    rect.width = width;\n    rect.height = height;\n    rect.x = x;\n    rect.y = y;\n    rect.color = color;\n    \n    return rect;\n}\n\nvoid DrawRect(inout Rect rect,vec2 p, inout vec3 pix)\n{\n    \n   \tfloat dx = p.x - rect.x;\n    float dy = p.y - rect.y;\n    \n    dx = cos(rect.rotation)*(p.x - rect.x) + sin(rect.rotation)*(p.y - rect.y);\n    dy = -sin(rect.rotation)*(p.x - rect.x) + cos(rect.rotation)*(p.y - rect.y);\n    \n    float fL = - rect.width/2.;  //far left\n    float fR = + rect.width/2.;  //far right\n    float fT = + rect.height/2.; //far top\n    float fB = - rect.height/2.; //far bottom\n\n    //anti-aliasing\n    float del;\n    del =  smoothstep(fL - 0.005, fL + 0.005,dx);\n    del *= 1. - smoothstep(fR - 0.005, fR + 0.005,dx);\n    del *=  smoothstep(fB - 0.005, fB + 0.005,dy);\n    del *= 1. - smoothstep(fT - 0.005, fT + 0.005,dy);\n    \n    float d = 0.005;\n    \n    if(dx > fL-d && dx < fR+d \n    && dy < fT+d && dy > fB-d)\n    {\n        pix = mix(pix,rect.color,del);\n    }\n    \n    rect.csys = vec2(dx,dy);\n}\n\nfloat GetPathCoord(float p1, float p2, float percent)\n{\n   return p1 + ((p2 - p1) * percent);\n}\n\nconst int NUM_PATHS = 6;\nvec2 BezierPaths[NUM_PATHS];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.* vec2(fragCoord.xy - .5*iResolution.xy)/iResolution.y;\n    vec3 pixel = vec3(0.);\n    \n\tBezierPaths[0] = vec2(0.,1.);\n    BezierPaths[1] = vec2(0.2,1.);\n    BezierPaths[2] = vec2(0.,0.);\n    BezierPaths[3] = vec2(0.4,0.0);\n    BezierPaths[4] = vec2(0.45,0.0);\n\n    BezierPaths[5] = vec2(1.,0.);\n    \n    //Draw the bezier path points\n    \n    for(int i = 0; i < NUM_PATHS; i++)\n    {\n        Rect tmp_rect = CreateRect(0.05,0.05,BezierPaths[i].x, BezierPaths[i].y,YELLOW);\n        DrawRect(tmp_rect,r,pixel);\n    }\n     \n    float percent = (mod(iTime,4.0))/ 4.0;\n    \n    //Bezier path calculation for multiple paths\n    float tmp_x = 0.;\n    float tmp_y = 0.;\n    vec2 x[NUM_PATHS-1];\n    \n    for(int i = 0; i < NUM_PATHS-1; i++)\n    {\n        tmp_x = GetPathCoord(BezierPaths[i].x , BezierPaths[i+1].x, percent);\n        tmp_y = GetPathCoord(BezierPaths[i].y , BezierPaths[i+1].y, percent);\n        \n        x[i] = vec2(tmp_x,tmp_y);\n    }\n    \n    float tmp_nx = GetPathCoord(x[0].x, x[1].x,percent);\n    float tmp_ny = GetPathCoord(x[0].y, x[1].y,percent);\n    \n    for(int i = 2; i < NUM_PATHS-1; i++)\n    {\n        tmp_nx = GetPathCoord(tmp_nx,x[i].x,percent);\n    \ttmp_ny = GetPathCoord(tmp_ny,x[i].y,percent);\n    }\n    \n    //Draw Bezier Point which follows the path\n    Rect rp = CreateRect(0.05,0.05,tmp_nx,tmp_ny,BLUE);\n\tDrawRect(rp,r,pixel);\n\n\n    \n    fragColor = vec4(pixel,1.);\n}","name":"Image","description":"","type":"image"}]}