{"ver":"0.1","info":{"id":"7tBcRy","date":"1650309002","viewed":138,"name":"Cornell Box Tri Intersection","username":"snipet","description":"Cornell Box raytracer featuring metal, specular, diffuse, and emission.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","raytracing","specular","cornell","diffuse","fresnel","emission","metallic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CREDIT TO THE FOLLOWING SHADERS:\n//https://www.shadertoy.com/view/XlKSDR\n//https://www.shadertoy.com/view/Xt3cDn\n//https://www.shadertoy.com/view/3dfGR2\n//https://www.shadertoy.com/view/MtfGR4\n\n//This is my first raytracer that I am sharing. It is far, far from perfect,\n//so please tell me what I can improve on!\n//\n//FEATURES:\n//  - Tri intersection https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-rendering-a-triangle\n//  - Specular shading with basic fresnel\n//  - Metallic shading\n//  - Diffuse shading (Lambert style)\n//  - Emission\n//  - Cubemap Environments + Lighting\n//\n//PROBLEMS:\n//  - Noise algorithm shows artifacts\n//  - Not completely physically correct\n//  - Specular is my rednecked approach and can be greatly improved on\n//  - Could be faster (how?)\n//\n//Materials are defined in Common\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    vec3 col = data.rgb / data.w;\n    col = Tonemap_ACES(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926535897;\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n//RANDOM FUNCTION  ==================================================\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 cosWeightedRandomHemisphereDirection( const vec3 n, inout float seed ) {\n  \tvec2 rv2 = hash2(seed);\n    \n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\t\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n    \n    return normalize( rr );\n}\n\n\n//CAMERA ==================================================\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n//MATERIAL ==================================================\nstruct Material{\n    vec3 base_color;\n    vec3 emission_color;\n    float roughness;\n    float metallic;\n    float specular;\n};\n\nMaterial getMaterial(int m){\n    switch(m){\n        case 0:\n            return Material(vec3(1,1,1), vec3(0), 1., 0., 0.); //White\n        case 1:\n            return Material(vec3(1,0.5,0.5), vec3(0), 1., 0., 0.); //Red\n        case 2:\n            return Material(vec3(0.5,1,0.5), vec3(0), 1., 0., 0.); //Green\n        case 3:\n            return Material(vec3(1,1,1), vec3(30), 1., 0., 0.); //Light\n        case 4:\n            return Material(vec3(1,1,1), vec3(0), 1., 0., 0.); //Cube\n    }\n}\n\n\n//MESH / RAYS ==================================================\nstruct Triangle{\n    vec3 v0,v1,v2; //Vertices\n    int material;\n};\n\n\nstruct Ray{\n    vec3 ro; //Ray orgin\n    vec3 rd; //Ray direction\n    vec3 color_amp;\n    vec3 color_mult;\n};\n\nvec3 calcTriNormal(Triangle tri, Ray ray, bool different_sides){\n    vec3 normal = normalize(cross(tri.v1 - tri.v0, tri.v2 - tri.v0));\n    //float denom = normalize(dot(N,N));\n    if(dot(ray.rd, normal)>0. && different_sides){\n        normal = -normal;\n    }\n    return (normal);\n}\n\nvec3 calcTriIntersection(in Triangle tri, in Ray ray, out bool hitTri, out float dist){\n    vec3 n = calcTriNormal(tri, ray, false);\n    vec3 e1 = tri.v1 - tri.v0;\n    vec3 e2 = tri.v2 - tri.v1;\n    vec3 e3 = tri.v0 - tri.v2;\n    \n    float d = -dot(n, tri.v0);\n    float t = -(dot(n, ray.ro) + d) / dot(n, ray.rd);\n    vec3 p = ray.ro + t * ray.rd;\n    dist = t;\n    vec3 c0 = p - tri.v0;\n    vec3 c1 = p - tri.v1;\n    vec3 c2 = p - tri.v2;\n    hitTri = (dot(abs(n), cross(e1, c0)) > 0.) &&\n             (dot(abs(n), cross(e2, c1)) > 0.) &&\n             (dot(abs(n), cross(e3, c2)) > 0.);\n    if(t<0.){\n        hitTri = false;\n    }\n    return p;\n}\n\n#define QUAD(a,b, material) Triangle(a,b, vec3(b.x,b.y, a.z), material),\\\n                  Triangle(a, vec3(a.x, a.y, b.z), b, material)\n\n//SCENE ==================================================\nTriangle[] scene = Triangle[](\n    //Triangle(vec3(-2, -2, -2), vec3(2, -2, 2), vec3(2, -2, -2), 0),\n    //Triangle(vec3(-2, -2, -2), vec3(-2, -2, 2), vec3(2, -2, 2), 0),\n    QUAD(vec3(-2, -2, -2),vec3(2, -2, 2), 0),\n    QUAD(vec3(-2, -2, 2), vec3(-2, 2, -2), 1),\n    //Triangle(vec3(-2, -2, -2), vec3(-2, 2, -2), vec3(-2, -2, 2), 1),\n    //Triangle(vec3(-2, 2, -2), vec3(-2, 2, 2), vec3(-2, -2, 2), 1),\n    QUAD(vec3(2, 2, -2), vec3(2, -2, 2), 2),\n    //Triangle(vec3(2, 2, 2), vec3(2, -2, 2), vec3(2, 2, -2), 2),\n    //Triangle(vec3(2, -2, 2), vec3(2, -2, -2), vec3(2, 2, -2), 2),\n    Triangle(vec3(-2, -2, -2), vec3(2, -2, -2), vec3(2, 2, -2), 0),\n    Triangle(vec3(-2, -2, -2), vec3(2, 2, -2), vec3(-2, 2, -2), 0),\n    //Triangle(vec3(-2, 2, -2), vec3(2, 2, 2), vec3(2, 2, -2), 0),\n    //Triangle(vec3(-2, 2, -2), vec3(-2, 2, 2), vec3(2, 2, 2), 0),\n    QUAD(vec3(-2, 2, -2),vec3(2, 2, 2), 0),\n    //Triangle(vec3(-0.5, 1.99, -0.5), vec3(-0.5, 1.99, 0.5), vec3(0.5, 1.99, 0.5), 3),\n    //Triangle(vec3(-0.5, 1.99, -0.5), vec3(0.5, 1.99, 0.5), vec3(0.5, 1.99, -0.5), 3)\n    QUAD(vec3(-0.5, 1.99, -0.5),vec3(0.5, 1.99, 0.5), 3),\n    Triangle(vec3(-1.3, -2, -0.8), vec3(0.3, -2, -0.8), vec3(0.3, -0.4, -0.8), 4),\n    Triangle(vec3(-1.3, -2, -0.8), vec3(0.3, -0.4, -0.8), vec3(-1.3, -0.4, -0.8), 4),\n    Triangle(vec3(-0.8, -1.5, -0.7), vec3(-0.2, -1.5, -0.7), vec3(-0.2, -0.9, -0.7), 3),\n    Triangle(vec3(-0.8, -1.5, -0.7), vec3(-0.2, -0.9, -0.7), vec3(-0.8, -0.9, -0.7), 3),\n    QUAD(vec3(-1.3, -0.4, -0.8), vec3(-1.3, -2, 0.3), 4),\n    QUAD(vec3(0.3, -0.4, -0.8), vec3(0.3, -2, 0.3), 4),\n    QUAD(vec3(-1.3, -0.4, -0.8), vec3(0.3, -0.4, 0.3), 4)\n);\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float RAND_MIX = 0.;\n\n//RAND FUNCTION FROM Inigo Quilez\nint   seed = 1;\nint   rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n\nvec3 getEnvironment(vec3 rd){\n    return texture(iChannel0, rd).rgb;\n    //return vec3(0);\n}\n\nvoid applyMaterialToRay(inout Ray ray, vec3 normal, int material, inout float seed){\n    float fresnel = saturate(pow( 1.+dot(normal,ray.rd), 5. ) + 0.25);\n    Material mat = getMaterial(material);\n    //ray.color = vec3(fresnel);\n    float spec_mix = 0.;\n    if(RAND_MIX * 2. < mix(mat.specular*0.45, mat.specular, fresnel)){\n        spec_mix = 1.;\n    }\n    float lin_roughness = mat.roughness * mat.roughness;\n    \n    vec3 glossy_rd = cosWeightedRandomHemisphereDirection(normal, seed) * mat.roughness + reflect(ray.rd, normal) * (1.-mat.roughness);\n    vec3 diffuse_rd = cosWeightedRandomHemisphereDirection(normal, seed);\n    vec3 spec_rd = spec_mix * glossy_rd + diffuse_rd * (1.-spec_mix);\n    vec3 new_rd = mat.metallic * glossy_rd + spec_rd * (1.-mat.metallic);\n    \n    ray.rd = new_rd;\n    ray.color_mult *= mat.base_color;\n    ray.color_amp += mat.emission_color;\n}\n\n//Shoots a ray in the scene and returns if the ray hit something\nbool shootRay(inout Ray ray, inout int last_hit_tri, inout float seed){\n    float min_dist = 9999999.;\n    int best_tri = -1;\n    vec3 best_p;\n    for(int i = 0; i<scene.length(); i++){\n        bool hit = false;\n        float d = 999999.;\n        vec3 p = calcTriIntersection(scene[i], ray, hit, d); //Get intersection existance & position for current triangle\n        if(hit && i != last_hit_tri){\n            //The ray hit an object\n            if(d < min_dist){\n                min_dist = d;\n                best_tri = i;\n                best_p = p;\n            }\n        }\n    }\n    \n    if(best_tri != -1){\n        //Do stuff because the ray hit something\n        ray.ro = best_p;\n        applyMaterialToRay(ray, calcTriNormal(scene[best_tri], ray, true),scene[best_tri].material, seed);\n        last_hit_tri = best_tri;\n        return true;\n    }else{\n        last_hit_tri = -1;\n        return false;\n    }\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec2 fragCoord, inout float seed){\n    vec4 past_values = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    RAND_MIX = mod(iTime * 1655.2362, 1.);\n    vec3 col = vec3(0);\n    //Ray ray = Ray(ro, rd, vec3(0), normalize(vec3(fract(iTime*12.543525), fract(iTime*165.5436525),fract(iTime*1535.6324677654))));\n    Ray ray = Ray(ro, rd, vec3(0), vec3(1));\n    int last_hit_tri = -1;\n    if(shootRay(ray,last_hit_tri, seed)){\n        for(int i = 0; i<20; i++){\n            if(!shootRay(ray,last_hit_tri, seed)){\n                ray.color_amp += getEnvironment(ray.rd);\n                col += (ray.color_amp * ray.color_mult) / float(i+1);\n                //col = vec3(1);\n                break;\n            }else{\n            }\n            \n        }\n    }else{\n        col = getEnvironment(rd);\n    }\n    return col;\n}\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 past_values = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec2 mouseUV = iMouse.xy/iResolution.xy;\n    if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float seed = (fract(uv.x * 1453.025364625787644) + fract(uv.y * 18753.43121412313) + fract(12.12345314312*iTime)) / iTime;\n    \n    vec3 ro = vec3(0,0,5);\n    ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n    ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n    vec3 rd = camera(ro, vec3(0,0,0)) * normalize(vec3(uv, -1));\n    \n    float jitter = 0.002;\n    float jitter_seed = iTime * 12.3454432345;\n    rd = rd * (1.-jitter) + cosWeightedRandomHemisphereDirection(rd, jitter_seed) * jitter;\n    \n    vec3 col = getColor(ro, rd, fragCoord, seed);\n    if(iMouse.z > 0.){\n        fragColor = vec4(col,1.0);\n    }else{\n        fragColor = vec4(col,1.0) + past_values;\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}