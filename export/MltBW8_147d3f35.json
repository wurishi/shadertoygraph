{"ver":"0.1","info":{"id":"MltBW8","date":"1539480217","viewed":106,"name":"sphere tracing 3","username":"stuxxnet42","description":"sphere tracing 3","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphere","tracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//threshold for hit testing\nconst float epsilon = 1.0;\n\n// Distance field of a sphere at c with radius r, sampled at p.\nfloat sphere(vec3 c, float r, vec3 p) {\n\treturn length(p - c) - r;\n}\n// The Scene\nfloat distanceField(vec3 pos) {\n    pos.x = pos.x+20.0*cos(0.1*pos.x+2.31);\n    pos.y = pos.y + 20.0*sin(0.1*pos.y+4.0*iTime);\n    //pos.x = mod(pos.x, 300.0);\n\tfloat s1 = sphere(vec3(400.0,150.0*cos(iTime*2.0),0.0), 250., pos);\n    float s2 = sphere(vec3(-400.0,150.0*sin(iTime*2.0),0.0), 250., pos);\n    vec3 pos2 = vec3(pos.x * cos(iTime*0.1) - pos.y * sin(iTime*0.1), pos.x * sin(iTime*0.1) + pos.y * cos(iTime*0.1), pos.z);\n    pos2.y*=1.0-0.1*cos(iTime*3.0);\n    float s3 = sphere(vec3(250.0,250.0*sin(iTime*2.0),300.0), 200., pos2);\n\treturn min(min(s1,s2),s3);\n}\n\n// Approximates the normal vector at pos.\nvec3 distanceFieldNormal(vec3 pos) {\n\t// Method of central differences.\n\tconst float s = 1. / 2.;\n\t\n\tvec3 n = vec3(distanceField(pos + vec3(s, 0, 0)) - distanceField(pos - vec3(s, 0, 0)),\n\t\t\t\t  distanceField(pos + vec3(0, s, 0)) - distanceField(pos - vec3(0, s, 0)),\n\t\t\t\t  distanceField(pos + vec3(0, 0, s)) - distanceField(pos - vec3(0, 0, s)));\n\treturn normalize(n);\n}\n\n\n// Light source intensity\nconst float i_a = 0.3;\nconst float i_d = 0.6;\nconst float i_s = 0.4;\n\n// Material reflectiveness and color\nconst float k_a = 0.6;\nconst float k_d = 0.7;\nconst float k_s = 0.8;\nconst float alpha = 8.;\nconst vec3 matColor = vec3(1, 0.2, 0.7);\n\nconst vec3 lightpos = vec3(0.0, 1.0, -1.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat near = -iResolution.x * 1.2 / 2.;\n\tfloat far  =  iResolution.x * 1.2 / 2.;\n\t\n\tvec3 cameraPosition = vec3(0, 0, -1);\n\t\n\tvec3 pos = vec3(fragCoord.xy - iResolution.xy / 2., near);\n\t\n\tvec3 npos = pos / iResolution.x;\n\t\n\tvec3 dir = normalize(npos - cameraPosition);\n\tvec3 toEye = -dir;\n\tfragColor = vec4(0.0, 0.0, 0.0, 1);\n    int stepsTaken = 0;\n    for (int steps = 0; steps < 50; ++steps) {\n\t\tstepsTaken = steps;\n\t\tfloat d = distanceField(pos);\n\n\t\tif (d < epsilon) {\n            vec3 normal = distanceFieldNormal(pos);\n\t\t\tvec3 nl_m = normalize(lightpos);\n\t\t\tvec3 r_m = -reflect(nl_m, normal);\n            \n            float ambient = i_a * k_a;\n            float k_d_2 = 0.5+0.5*cos(pos.z*0.2);\n\t\t\tfloat diffuse = i_d * k_d_2 * max(dot(nl_m, normal), 0.);\n\t\t\tfloat spec    = i_s * k_s * pow(max(dot(r_m, toEye), 0.), alpha);\n            \n            vec3 light = matColor * (ambient + diffuse) + spec;\n            light.x += 0.1*cos(pos.x*0.1);\n            light.y += 0.5*cos((pos.y*pos.x*0.01));\n            \n\t\t\tfragColor = vec4(light, 1);\n\t\t\treturn;\n\t\t} else {\n\t\t\tpos += d * dir;\n\t\t}\n\t}\n}","name":"Image","description":"","type":"image"}]}