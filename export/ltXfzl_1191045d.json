{"ver":"0.1","info":{"id":"ltXfzl","date":"1512881352","viewed":232,"name":"Joy In Repetition","username":"Del","description":"Joy In Repetition - Flower loading animation... (added a box merge on mouse)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","flower","mod","polar","lit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2d sdf + lighting code taken from https://www.shadertoy.com/view/MsXBWH by wutzhuhn\n// repeating flowers added by Del 10/12/17\n#define roundnes 0.035\n\n#define PI 3.14159265\n#define DEG2RAD ((PI * 2.0) / 360.0)\n\nfloat subtract(float a, float b)\n{\n\treturn min(max(a, -b), -roundnes) + length(max(vec2(roundnes) + vec2(a, -b), vec2(0.0)));\n}\n\nfloat merge(float a, float b)\n{\n\treturn max(min(a, b), roundnes) - length(max(vec2(roundnes) - vec2(a, b), vec2(0.0)));\n}\n\nmat2 rotate(float a)\n{\n    float sa = sin(a), ca = cos(a);\n\treturn mat2(ca, -sa, sa, ca);\n}\n\nfloat box(vec2 p, vec2 size)\n{\n\tvec2 d = abs(p) - size + roundnes;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - roundnes;\n}\n\n\n// http://mercury.sexy/hg_sdf/\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions)\n{\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// render 16 flowers with 9 petals each...\nfloat shapeDist(vec2 p)\n{\n    float d1 = box(p+vec2(0.0,0.0), vec2(1.0, 1.0));\t\t// main box to subtract\n    vec2 p2 = p * rotate(iTime*0.25*PI);\n    float offset = pModPolar(p2,16.0);\n    vec2 p3 = (p2-vec2(0.45,0.0)) * rotate(iTime*0.8);\n\tpModPolar(p3,9.0);    \n    float d2 = box(p3-vec2(0.05,0.0), vec2(0.04, 0.02));\n    \n    // Mouse click box! :)\n    if (iMouse.z>0.5)\n    {\n        vec2 mousep = (  iMouse.xy -.5*iResolution.xy ) / iResolution.y;\n        float d4 = box(p-mousep,vec2(0.1,0.1));\n        d2 = merge(d2,d4);\n    }\n    \n    float dist = subtract(d1,d2);\n    return dist;\n}\n\nfloat maskSharp(vec2 p)\n{\n    return clamp(shapeDist(p) * 100.0, 0.0, 1.0);\n}\n\nfloat maskBlurry(vec2 p)\n{\n    return clamp((shapeDist(p ) + 0.003) * 75.0, 0.0, 1.0);\n}\n\nvec3 normalAt(vec2 p)\n{\n    float ps = 1.0 / iResolution.x;\n    float x = maskBlurry(p - vec2( ps, 0.0)) - maskBlurry(p + vec2( ps, 0.0));\n    float y = maskBlurry(p - vec2(0.0,  ps)) - maskBlurry(p + vec2(0.0,  ps));\n    return normalize(vec3(x, y, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = ( fragCoord -.5*iResolution.xy ) / iResolution.y;\n    vec3 color = vec3(0.1,0.3,0.1);\n    \n    float val = maskSharp(p);\n    float shade = 0.0;\n    if (val>0.0)\n    {\n        float z = (0.5+sin(iTime*3.5))*0.1;\n        vec3 lightPos = vec3(0.0, 0.0, 0.2+z);\n        vec3 toLight = lightPos - vec3(p, 0.0);\n        vec3 normal = normalAt(p);\n\t\tshade = 0.3 + maskSharp(p) * 0.7;\n        float col = clamp(dot(normalize(toLight), normal), 0.0, 1.0) / length(toLight) * shade;\n        color = vec3(0.6,0.2,0.9)*col;\n    }\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}