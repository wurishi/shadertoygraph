{"ver":"0.1","info":{"id":"dlXfW4","date":"1692917596","viewed":40,"name":"Haute","username":"nebgor","description":"Random forms and transparent ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["generatedforms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec2 x) \n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 s = f*f*(3.0-2.0*f);\n    float n = p.x + p.y * 57.0;\n    float res = mix(mix( hash(n+0.0), hash(n+1.0), s.x), mix( hash(n+57.0), hash(n+58.0), s.x), s.y);\n    return res;\n}\n\n// ... [other functions such as noise, hash remain unchanged]\n\nfloat shape(vec2 uv, vec2 position, float size, float curvature)\n{\n    uv -= position;\n    uv.y -= curvature * sin(uv.x * 3.14);\n    return length(uv) - size;\n}\n\n// ... [other functions such as noise, hash, and shape remain unchanged]\n\nfloat generativeSilhouette(vec2 uv, vec2 position, float time)\n{\n    // Random offsets based on position and time\n    float randSize = noise(position.xy * 10.0 + vec2(time));\n    float randCurve = noise(position.xy * 20.0 + vec2(time));\n    \n    uv -= position;\n    uv.y += randCurve * sin(uv.x * 3.14);  // Random curvature\n    \n    float head = shape(uv, vec2(0.0, 0.15 + 0.05 * randSize), 0.08 + 0.02 * randSize, 0.0); // Random size and position\n    float body = shape(uv, vec2(0.0, 0.05 * randSize), 0.15 + 0.03 * randSize, 0.5 + 0.1 * sin(time)); // Random size\n    float waist = shape(uv, vec2(0.0, -0.05 * randSize), 0.12 + 0.02 * randSize, 1.0 - 0.1 * sin(time)); // Random size and position\n    \n    return min(min(head, body), waist);\n}\n\nvec3 getColorForForm(vec2 uv, vec2 position, float time)\n{\n    float form = generativeSilhouette(uv, position, time);\n\n    // Haute Color Palette\n    vec3 deepPurple = vec3(0.3, 0.0, 0.3); // Darkened\n    vec3 richGold = vec3(0.7, 0.6, 0.0);  // Darkened\n    vec3 midnightBlue = vec3(0.05, 0.05, 0.3); // Darkened\n\n    // Blend colors based on the form's noise\n    float blend = noise(uv + time);\n    vec3 color = mix(deepPurple, richGold, blend);\n    color = mix(color, midnightBlue, 1.0 - blend);\n\n    // Darken the boundaries of the silhouette further\n    float edge = smoothstep(0.0, 0.02, form);\n    return mix(color, color * 0.7, edge); // Multiplying with a value less than 1 darkens the color\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float texture = noise(uv * 10.0 + vec2(iTime));\n    vec3 cloudColor = mix(vec3(0.1, 0.1, 0.2), vec3(0.5, 0.5, 0.7), texture);\n    vec3 col = cloudColor;\n\n    // Loop to render multiple forms\n    for(float i = 0.0; i < 5.0; i += 1.0)\n    {\n        vec2 position = vec2(i * 0.2 + 0.1, 0.5 + 0.1 * sin(iTime + i));\n        vec3 formColor = getColorForForm(uv, position, iTime + i);\n        \n        // If the pixel is part of the silhouette, blend its color\n        float silhouetteValue = generativeSilhouette(uv, position, iTime + i);\n        if(silhouetteValue < 0.02)\n        {\n            col = mix(col, formColor, 0.5);\n        }\n    }\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0); // Ensure color values remain within [0, 1]\n}","name":"Image","description":"","type":"image"}]}