{"ver":"0.1","info":{"id":"ltGBzc","date":"1543403487","viewed":185,"name":"TDF logo sample","username":"kaiware007","description":"Tokyo Demo Fest 2018 Logo by raymarching sample\n\nOriginal Raymarching code(CalcNormal, CalcAO)\nDeformed by XBE\nhttps://www.shadertoy.com/view/XdfSDB","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// TDF logo sample\n//\n// Original Raymarching code(CalcNormal, CalcAO)\n// Deformed by XBE\n// https://www.shadertoy.com/view/XdfSDB\n\n#define PI 3.14159265359\n\n// black triangle size\n#define BTRI_SIZE 0.5\n// black triangle depth\n#define BTRI_Z 0.15\n// red triangle depth\n#define RTRI_Z 0.15\n\n// Distance function by iq\n// https://iquilezles.org/articles/distfunctions\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nvec3 repeat(vec3 pos, vec3 span)\n{\n\treturn mod(pos, span) - span * 0.5;\n    //return mod(pos + 0.5 * span, span) - span * 0.5;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec2 map( in vec3 pos )\n{    \n    \n    pos = repeat(pos, vec3(2.5, 1.5, 2.5));\n\n    pos = rotate(pos, iTime * -2.5, vec3(0., 1., 0.));\n    \n    // reverse triangle pos\n    vec3 pos2 = rotate(pos, 1.0 * PI, vec3(0., 0., 1.));\n    \n    // black triangle\n    float d1 = sdTriPrism(pos2 - vec3(-BTRI_SIZE, -0.25, 0.), vec2(BTRI_SIZE, BTRI_Z));\n    float d2 = sdTriPrism(pos, vec2(BTRI_SIZE, BTRI_Z));\n    float d3 = sdTriPrism(pos2 - vec3(BTRI_SIZE, -0.25, 0.), vec2(BTRI_SIZE, BTRI_Z));\n    \n    // red triangle\n    float r1 = sdTriPrism(pos - vec3(0.1, 0.1, 0.), vec2(0.325, RTRI_Z));\n    float r2 = sdTriPrism(pos2 - vec3(0.65, -0.125, 0.), vec2(0.375, RTRI_Z));\n    \n    float btri = opU(opU(d1, d2), d3);\n\tfloat rtri = opU(r1, r2);\n    \n    float l = min(btri, rtri);\n    float mat = btri < rtri ? 0. : 1.;\n    \n    return vec2(l, mat);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n\t\tmap(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t\tmap(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t\tmap(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n\n// Raymarching\nbool raymarch(vec3 origin, vec3 dir, out float dist, out vec3 norm, out float mat)\n{\n\tfloat epsilon = 0.001;\n\tfloat maxdist = 10.0;\n\tfloat marched = 0.0;\n\tfloat delta = 2.*epsilon;\n    float m = 0.;\n\tdist = -1.0;\n\tfor (int steps=0; steps < 128; steps++)\n\t{\n\t\tif ( ( abs(delta) < epsilon ) || (marched > maxdist) ) continue;\n\t\tdelta *= 0.5;\n        \n        marched += delta;\n        vec2 ret = map(origin + marched * dir);\n\t\tdelta = ret.x;\n        m = ret.y;\n\t}\n\tbool res = false;\n\tif (marched < maxdist)\n\t{\n\t\tnorm = calcNormal(origin + marched * dir);\n\t\tdist = marched;\n        mat = m;\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n\tfloat dist = 0.;\n    float mat = 0.;\n\tvec3 nor = vec3(0.,0.,0.);\n\t//\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\tvec3 sky = vec3(0.32,0.36,0.4) - rd.y*0.4;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tsky += vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n\tsky *= 0.9;\n\t//\n    if ( raymarch(ro, rd, dist, nor, mat) )\n    {\n        vec3 pos = ro + dist*rd;\n\n\t\tcol = (mat == 0.) ? vec3(0.05, 0.05, 0.06) : vec3(1., 0.2, 0.25);\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tvec3 brdf = vec3(0.0);\n//\t\tbrdf += 2.20*amb*vec3(0.20,0.22,0.26)*ao;\n\t\tbrdf += 1.20*amb*vec3(0.20,0.22,0.26)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.00*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(0.8)*vec3(1.00,0.70,0.60)*spe + 0.2*fre*(0.5+0.5*col);\n\t\tcol = mix( col, sky, 1.0-exp(-0.0025*dist*dist*dist) );\n\t}\n\telse\n\t{\n\t\tcol = sky;\n\t}\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\tfloat Time = 0.45*(15.0 + iTime);\n\tvec3 pos = vec3(0.,0.,1.) * Time * 8.;\n\t//vec3 pos = vec3(0, 0., 0.);\n    \n\t// camera\t\n\t//vec3 ro = vec3( 4.0*cos(Time+45.), 0.0, 2.0*sin(Time) );\n\t//vec3 ro = vec3( 1.0*cos(Time), 0.5, 1.0*sin(Time) );\n    vec3 ro = vec3( 0., 0.75, -2. ) + pos;\n\t//vec3 ta = vec3( 0.0, 0.65, 1.) + pos;\n\tvec3 ta = ro + vec3( 1.0*cos(Time), 0.0, 1.0*sin(Time) );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n\tcol = sqrt(col);\n\t\n\tfragColor=vec4( clamp(col,0.,1.), 1.0 );\n}","name":"Image","description":"","type":"image"}]}