{"ver":"0.1","info":{"id":"3ssGDr","date":"1545820089","viewed":326,"name":"Snowi Tempest","username":"Draedrus","description":"Snow tempest","likes":12,"published":1,"flags":40,"usePreview":0,"tags":["snow","gaussianblurr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_GAUSSIAN_BLUR\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    #ifdef USE_GAUSSIAN_BLUR\n    vec2 cBlurDir = vec2(0.0, 1.0);\n    vec2 cBlurRadius = vec2(1.0/iResolution.y);\n    float cBlurSigma = 1.2;\n    fragColor = GaussianBlur(GAUSS_KERNEL_SIZE, cBlurDir, cBlurRadius, cBlurSigma, iChannel0, uv); \n\t#else\n    fragColor = texture(iChannel1, uv);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TEMPEST_LAYERS 6\n\n/** HASH **/\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash2D(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat perlin_hash2D(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash2D(lower+vec2(0.0, 0.0)), hash2D(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash2D(lower+vec2(0.0, 1.0)), hash2D(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash2D(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*perlin_hash2D(uv); uv*=2.001;\n    total += 0.2500*perlin_hash2D(uv); uv*=2.003;\n    total += 0.1250*perlin_hash2D(uv); uv*=2.002;\n    total += 0.0625*perlin_hash2D(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nmat3 cam(vec3 ro, vec3 target, vec3 up)\n{\n    vec3 z = normalize(target-ro);\n    vec3 x = normalize(cross(z, up));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\n// Gaussian blurr\n#define PI 3.1415\n#define PI2 6.2830\n\n#define GAUSS_KERNEL_SIZE 2\n\n// Adapted: http://callumhay.blogspot.com/2010/09/gaussian-blur-shader-glsl.html\nvec4 GaussianBlur(int blurKernelSize, vec2 blurDir, vec2 blurRadius, float sigma, sampler2D tex, vec2 texCoord)\n{\n    int blurKernelHalfSize = blurKernelSize / 2;\n\n    // Incremental Gaussian Coefficent Calculation (See GPU Gems 3 pp. 877 - 889)\n    vec3 gaussCoeff;\n    gaussCoeff.x = 1.0 / (sqrt(2.0 * PI) * sigma);\n    gaussCoeff.y = exp(-0.5 / (sigma * sigma));\n    gaussCoeff.z = gaussCoeff.y * gaussCoeff.y;\n\n    vec2 blurVec = blurRadius * blurDir;\n    vec4 avgValue = vec4(0.0, 0.0, 0.0, 0.0);\n    float gaussCoeffSum = 0.0;\n\n    avgValue += texture(tex, texCoord) * gaussCoeff.x;\n\n    gaussCoeffSum += gaussCoeff.x;\n    gaussCoeff.xy *= gaussCoeff.yz;\n\n    for (int i = 1; i <= blurKernelHalfSize; i++)\n    {\n        avgValue += texture(tex, texCoord - float(i) * blurVec) * gaussCoeff.x;\n        avgValue += texture(tex, texCoord + float(i) * blurVec) * gaussCoeff.x;\n\n        gaussCoeffSum += 2.0 * gaussCoeff.x;\n        gaussCoeff.xy *= gaussCoeff.yz;\n    }\n\n    return avgValue / gaussCoeffSum;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 path(float t)\n{\n    return vec2(4.6*sin(t*0.25), t+1.8*cos(t*0.25));\n}\n\nfloat maps(vec3 p)\n{\n    //p.xy -= path(p.z);\n\treturn p.y+0.6*(sin(0.3*p.x)+cos(0.6*p.z));\n}\n\nfloat map(vec3 p)\n{\n    float b = fbm_hash2D(p.xz);\n\treturn maps(p)-b-b*iTime*0.01;\n}\n\nfloat mapdet(vec3 p)\n{\n    return map(p)*(0.9+(hash2D(1000.0*p.xz)*0.1));\n}\n\nbool raymarch(vec3 ro, vec3 rd, float tmin, float tmax, out float depth)\n{\n    float res = tmin;\n    \n    depth = tmax;\n    \n    for(int i = 0;i<120;++i)\n    {\n        vec3 p = ro+rd*res;\n        \n        // depth\n        float m = map(p);\n        // resolution\n        if(m<tmin || res>tmax)\n        {\n            depth = res;\n            return res<tmax;\n        }\n        res += 0.5*m;\n    }\n    depth = res;\n    return true;\n}\n\nvec3 normal(vec3 p, float e)\n{\n    vec3 n;\n    n.y = mapdet(p);\n    n.x = mapdet(p+vec3(e, 0.0, 0.0)) - n.y;\n    n.z = mapdet(p+vec3(0.0, 0.0, e)) - n.y;\n    n.y = e;\n    return normalize(n);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\nfloat beckmannDistribution(float roughness, float NdotH)\n{\n    float r1 = 1.0 / max(0.0001, 4.0 * roughness * roughness * pow(NdotH, 4.0));\n    float r2 = (NdotH * NdotH - 1.0) / (roughness * roughness * NdotH * NdotH);\n    return r1 * exp(r2);\n}\n\nfloat GGX(float a, float NoV, float NoL)\n{\n    float a2 = a*a;\n    float G_V = NoV + sqrt( (NoV - NoV * a2) * NoV + a2 );\n    float G_L = NoL + sqrt( (NoL - NoL * a2) * NoL + a2 );\n\treturn 1.0/( G_V * G_L );\n}\n\n// https://github.com/stackgl/glsl-specular-cook-torrance/blob/master/index.glsl\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.01);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.01);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.01);\n  float VdotH = max(dot(viewDirection, H), 0.0001);\n  float LdotH = max(dot(lightDirection, H), 0.0001);\n  float G1 = (2.0 * NdotH * VdotN) / VdotH;\n  float G2 = (2.0 * NdotH * LdotN) / LdotH;\n  float G = max(0.00001, min(1.0, min(G1, G2)));\n  \n  //Distribution term\n  //float D = GGX(roughness, VdotN, LdotN);\n  float D = beckmannDistribution(roughness, NdotH);\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\t//return D;\n  //Multiply terms and done\n  return  G *F * D;\n}\n\nvec3 brdf(\n    float Ks,\n    float Kr,\n    float Kd,\n    float roughness,\n    float opacity,\n    float depth,\n    vec3 specularColor,\n    vec3 refractiveColor,\n    vec3 diffuseColor,\n    vec3 I,\n    vec3 N,\n    vec3 L)\n{\n    vec3 Vn = -I;\n    float NdotV = max(0.0, dot(Vn, N));\n    float NdotL = max(0.0, dot(N, L));\n    vec3 C = vec3(0.0);\n    float Oi = opacity;\n    float spec = 0.0;\n    \n    float F = Fresnel_Schlick(1.0, 1.3, NdotV);\n    spec = cookTorranceSpecular(L, Vn, N, roughness, F);\n    //return vec3(F);\n    //return vec3(spec);\n    return (Kr*refractiveColor*F+Kd*diffuseColor\n            +Ks*specularColor*spec\n    ) * Oi;\n}\n\nvec3 render(vec3 ro, vec3 V, vec3 p, vec3 n, float depth, float depthNormalized)\n{\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float fog = depthNormalized*depthNormalized;\n    fog = fog*fog*fog;\n    fog = fog*fog*fog;\n    \n    vec3 L = normalize(vec3(0.0, 1.0, 0.0));\n    \n    vec3 cDiff = vec3(1.0);\n    vec3 cRefr = vec3(0.3, 0.8, 1.0);\n    vec3 cSpec = vec3(0.4, 0.6, 0.8);\n    \n    col = brdf(1.0, 0.6, 1.0, 0.7, 1.0,\n               depth, cSpec, cRefr, cDiff,\n               V, n, L);\n\n    return mix(vec3(0.0, 0.0, 0.0), exp(col), fog);\n}\n\n// https://www.shadertoy.com/view/lstSRS\nvec3 tonemapping(vec3 color)\n{\n    float f = 1.5;\n    //Tonemapping and color grading\n    color = pow(color, vec3(f));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / f));\n\n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\tcolor = clamp(color * 1.01, 0.0, 1.0);\n    \n    color = pow(color, vec3(1.0 / 2.2)); // 0.7/2.2\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 rd = vec3(-1.0+2.0*uv, 1.0);\n    \n    // path\n    vec2 p = path(iTime);\n    vec2 t = path(iTime+10.0);\n    \n    vec3 ro = vec3(p.x, 2.0-maps(vec3(p.x, 0.0, p.y)), p.y);\n    vec3 tg = vec3(t.x, 0.0, t.y);\n    \n    rd = normalize(cam(ro, tg, vec3(0.0, 1.0, 0.0))*rd);\n\n    float d;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float tmin = 0.00001, tmax = 100.0;\n    if(raymarch(ro, rd, tmin, tmax, d))\n    {\n        vec3 p = ro+rd*d;\n        vec3 n = normal(p, 0.0001);\n    \tcol = render(ro, rd, p, n, d, (tmax-d)/(tmax-tmin));\n    }\n    \n    vec3 temp = vec3(0.0);\n    //uv.x+=fract(iTime);\n    //float pert = exp(pow(1.0-(uv.x-0.5)*(uv.x-0.5), 120.0))-1.0;\n    //uv = max(uv, rot(uv, sin(pert)));\n    #if TEMPEST_LAYERS>5\n    temp += 0.1*fbm_hash2D(uv*30.0+vec2(100.0*iTime, iTime));\n    #endif\n    #if TEMPEST_LAYERS>4\n    temp += 0.2*fbm_hash2D(uv*20.0+vec2(80.0*iTime, 2.0*iTime));\n    #endif\n    #if TEMPEST_LAYERS>3\n    temp += fbm_hash2D(uv*1.0+vec2(5.0*iTime, iTime));\n    #endif\n    \n    #if TEMPEST_LAYERS>2\n    temp += 0.1*fbm_hash2D(uv*20.0+vec2(-100.0*iTime, iTime));\n    #endif\n    #if TEMPEST_LAYERS>1\n    temp += 0.2*fbm_hash2D(uv*10.0+vec2(-80.0*iTime, 2.0*iTime));\n    #endif\n    #if TEMPEST_LAYERS>0\n    temp += fbm_hash2D(uv*0.5+vec2(-5.0*iTime, iTime));\n    #endif\n    \n    fragColor = vec4(tonemapping(col+exp(-temp)),1.0);\n    //fragColor = vec4(uv, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cBlurDir = vec2(1.0, 0.0);\n    vec2 cBlurRadius = vec2(1.0/iResolution.x);\n    float cBlurSigma = 1.2;\n    fragColor = GaussianBlur(GAUSS_KERNEL_SIZE, cBlurDir, cBlurRadius, cBlurSigma, iChannel0, uv);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat hash(float uv)\n{\n \tfloat suv = sin(uv*13.130345242942);\n    return fract(suv);\n}\n\nfloat perlin(float uv)\n{\n \tfloat lower\t= floor(uv);\n    float frac \t= fract(uv);\n    float f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(hash(lower-0.1), hash(lower+0.1), f);\n}\n\nfloat fbm(float uv)\n{\n    float total = 0.0;\n    total += 0.5000*perlin(uv); uv*=2.001;\n    total += 0.3500*perlin(uv); uv*=2.002;\n    total += 0.2500*perlin(uv); uv*=2.003;\n    total += 0.1250*perlin(uv); uv*=2.002;\n    total += 0.0625*perlin(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat cont(float x)\n{\n    return 0.5*(1.0+sin(x));\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    float hzWBase = 440.0; // 440\n    float amp = 16.0;\n    float downfreq = 0.00006;\n    float sound = cont(time);\n    // tempest noise\n    float tmin = 14.0, tmax = 24.0;\n    for(float i = tmin;i<tmax;++i) // 14 -> 24 not bad\n    {\n        float b = pow(i, 1.8); // 1.8 > 1.655\n        sound += fbm(b*time);\n    }\n    // post effect\n    sound = (amp/*+4.0*sin(time) sounds like sea beach*/)*(sound-tmin)/(tmax-tmin+1.0);\n    // disables sound\n    //sound = 0.0;\n    return vec2( sound*hzWBase*downfreq, sound*hzWBase*downfreq );\n}","name":"Sound","description":"","type":"sound"}]}