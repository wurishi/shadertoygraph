{"ver":"0.1","info":{"id":"Ml3fWX","date":"1541320425","viewed":118,"name":"Reflection Refraction Test","username":"Minus256","description":"tried refraction alg.\npush ray inside sdf and pull it back.\nmouse x is positon of ball\nmouse y is refract value. (upside is 1.33, downside is 1.00)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raymarch","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//MinusRefraction\nconst float err = 0.001;\nconst float eserr = 0.001;\nconst float sta = 0.0;\nconst float end = 1000.0;\nconst int mxmrch = 2000;\n\n//Calculate Ray Dir\nvec3 raydir(float fov,vec2 res,vec2 pos)\n{\n    vec2 norpos = (pos.xy-res.xy/2.0)/(res.xx/2.0);\n    float depth = 1.0/(tan(radians(fov/2.0)));\n    return normalize(vec3(vec2(norpos.xy),depth));\n}\n\n//Transformation Set\nmat3 viewmat(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat3 rX(float th)\n{\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rY(float th)\n{\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rZ(float th)\n{\n    float c = cos(th);\n    float s = sin(th);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat opDisplace( vec3 p ,float iloveyou)\n{\n    float d2 = sin(iloveyou*p.x)*sin(iloveyou*p.y)*sin(iloveyou*p.z);\n    return d2;\n}\n\n//Material Getting\nfloat mat1sdf(vec3 point)\n{\n    //return -(length(point)-10.0);\n    return min(-(sdBox(point,vec3(100.0)))+opDisplace(point*0.25,1.0),length(point-vec3(-160.0*((iMouse.x/iResolution.x)-0.5) /*sin(iTime)*/ ,0.0,-80.0))-10.0);\n}\n\nfloat mat2sdf(vec3 point)\n{\n    return sdBox((point-vec3(40.0,20.0,-100.0))* rZ(-iTime) * rY(iTime),vec3(10.0));\n}\n\nfloat mat3sdf(vec3 point)\n{\n    vec3 rp = (point-vec3(0.0,0.0,-40.0)) * rZ(iTime) * rY(iTime);\n    //return length(point-vec3(1.0,0.0,-3.0))-1.0;\n    return sdBox(rp,vec3(10.0))+opDisplace(point,0.5);\n}\n\nvec3 scdstmat(vec3 p)\n{\n    float sdf = min(mat1sdf(p),min(mat2sdf(p),mat3sdf(p)));\n    float minussdf = max(mat1sdf(p),max(mat2sdf(p),mat3sdf(p)));\n    float matnum = 0.0;\n    if(mat3sdf(p) == sdf)\n        matnum = 3.0;\n    else if(mat2sdf(p) == sdf)\n        matnum = 2.0;\n        else\n            matnum = 1.0;\n        return vec3(sdf,minussdf,matnum);\n}\n\n//Scene Distance Function\nfloat scenesdf(vec3 point)\n{\n    return scdstmat(point).x;\n}\n\nfloat minussdf(vec3 point)\n{\n    return scdstmat(point).y;\n}\n\nfloat getmat(vec3 point)\n{\n    return scdstmat(point).z;\n}\n\n//Get length\nfloat veclength(vec3 pos,vec3 dir)\n{\n    float depth = sta;\n    float dist = 0.0;\n    \tfor(int i = 0; i < mxmrch; i++)\n    \t{\n        \tdist = scenesdf(pos + dir * depth);\n            \tif(abs(dist) < err)\n            \t{\n                \treturn abs(depth);\n            \t}\n        \tdepth += dist;\n        \tif(abs(depth) >= end)\n        \t{\n            \treturn end;\n        \t}\n    \t}\n    return end;\n}\n\n//Normal Estimation\nvec3 normal(vec3 p)\n{\n    return normalize(vec3(\n        scenesdf(vec3(p.x + eserr,p.y,p.z)) - scenesdf(vec3(p.x - eserr,p.y,p.z)),\n        scenesdf(vec3(p.x,p.y + eserr,p.z)) - scenesdf(vec3(p.x,p.y - eserr,p.z)),\n        scenesdf(vec3(p.x,p.y,p.z + eserr)) - scenesdf(vec3(p.x,p.y,p.z - eserr))\n        ));\n}\n\n//Not Great Refracting Method\n//Actually, this is total mess.\n//I Hate \"Bound\" So Much....\n//if there is better \"full refract\"method, let me know about it!\nvec4 posMath(vec3 firpos,vec3 firdir)\n{\n        float refval = 1.0 + 0.33*(iMouse.y/iResolution.y);\n    float leng = veclength(firpos,firdir);\n    float minusleng , plusleng = .0;\n    float mat = 0.0;\n    vec3 pos = firpos + firdir*leng;\n    vec3 dir = firdir;\n    vec3 refvec ,fravec= vec3(.0);\n    for(int i = 0;i < 20;i++)\n    {\n    mat = getmat(pos);\n        if(mat == 1.0)\n    \t{\n        \treturn vec4(pos,leng);\n    \t}\n    \telse if(mat == 2.0)\n    \t{\n            pos += normal(pos)*2.0*err;\n        \trefvec = reflect(dir,normal(pos));\n            plusleng = (veclength(pos,refvec));\n        \tleng += plusleng;\n        \tpos += refvec*plusleng;\n            dir = refvec;\n        }\n        else if(mat == 3.0)\n        {\n            if(length(dir+normal(pos))>sqrt(2.0))\n            {\n            \tfravec = refract(dir,normal(pos),refval);\n            \tpos -= (normal(pos)*(4.0*err));\n            \tminusleng = (veclength(pos,-fravec));\n            \tpos += (fravec*minusleng);\n            }\n            else\n            {\n                pos -= (normal(pos)*(4.0*err));\n                minusleng = 0.0;\n                fravec = dir;\n            }\n            pos += (normal(pos))*(4.0*err);\n            fravec = refract(fravec,-normal(pos),1.0/refval);\n            leng += minusleng;\n            dir = fravec;\n            pos += dir*veclength(pos,dir);\n            leng += veclength(pos,fravec);\n        }\n    }\n    return vec4(pos,leng);\n}\n\n//Phong Illumination\nvec3 phongContribForLight(vec3 k_d,vec3 k_s,float alpha,vec3 p,vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity,vec3 ffff)\n\t{\n    vec3 N = ffff;\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));   \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0)\n    {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n//Phong Illumination Collect\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,vec3 ffff) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(-10.0,0.0,-70.0);\n    vec3 light1Intensity = vec3(0.3, 0.3, 0.3);\n    \n    color += phongContribForLight(k_d,k_s,alpha,p,eye,light1Pos,light1Intensity,ffff);\n    \n        vec3 light2Pos = vec3(-10.0,0.0,-50.0);\n    vec3 light2Intensity = vec3(0.6, 0.6, 0.6);\n    \n    color += phongContribForLight(vec3(0.0),vec3(0.5),alpha,p,eye,light2Pos,light2Intensity,ffff);\n    return color;\n}\n\n//Main Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 90.0;\n    vec3 viewDir = raydir(fov,iResolution.xy,fragCoord.xy);\n    vec3 point = vec3(0.0,0.0,1.0);\n    vec3 center = vec3(0.0,0.0,2.0);\n    vec3 roll = vec3(0.0,1.0,0.0);\n    mat3 viewToWorld = viewmat(point,center,roll);\n    vec3 worldDir = viewToWorld * viewDir;\n    vec4 posmap = posMath(point,worldDir);\n    vec3 p = point + abs(length(point - posmap.xyz)) * worldDir;\n    vec3 sp = point + veclength(point,worldDir) * worldDir;\n    vec3 snormal = normal(sp);\n    \n    vec3 a = vec3(0.3,0.3,0.3);\n    vec3 d = vec3(0.5,0.5,0.5);\n    vec3 s = vec3(1.0,1.0,1.0);\n    float al = 1.0;\n\n    vec3 normal = normal(posmap.xyz);\n    vec3 color = phongIllumination(a,d,s,al,p,point,normal);\n    vec3 scolor = phongIllumination(vec3(.0),vec3(7.8),s,al,sp,point,snormal);\n    float shad = posmap.w/(4.0*end);\n    fragColor = vec4(color,al);\n       // vec4(vec3(0.5)-normal/2.0,al);\n}","name":"Image","description":"","type":"image"}]}