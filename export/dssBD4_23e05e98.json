{"ver":"0.1","info":{"id":"dssBD4","date":"1688757850","viewed":67,"name":"Unpleasant artifacts (fixed)","username":"Envy24","description":"Can someone explain why twisted box look so ugly, and maybe how to fix this?\nUse mouse to control light position.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube","box","twisted"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  p = rotY(iTime*0.2)*p;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat udBoxTwisted( vec3 p, vec3 b, float k )\n{    \n    return sdBox(rotY(k*p.y)*p, b);\n}\n#define TO_RAD                      0.017453292519943295        // Convert degrees to radians\n\nfloat find_closest_scene_object(in vec3 marching_point)\n{\n    return udBoxTwisted(marching_point, vec3(1., 2., 1.), 90.*TO_RAD);\n}\n\nfloat ray_march(\n    vec3 ray_origin,\n    vec3 ray_direction,\n    float max_num_of_steps,\n    float max_distance,\n    float surface_distance) \n{\n    float marched_distance = 0.0; // Distance marched from ray origin.\n    float minimal_distance = 0.0; // Current distance to closest object.\n\n    bool quit = false;\n\n    for (float step = 0.; (step < max_num_of_steps) && (quit == false); step += 1.)\n    {\n        // Calculate current coordinates at ray.\n        vec3 marching_point = ray_origin + ray_direction * marched_distance;\n\n        // Find distance to closest object to point.\n        minimal_distance = find_closest_scene_object(marching_point);\n\n        // March.\n        //marched_distance += minimal_distance; // Problem\n        marched_distance += minimal_distance * 0.5; // Solution \n\n        quit = \n            marched_distance > max_distance ||    // Marched in infinity?\n            minimal_distance < surface_distance;  // Hit some object?\n    }\n\n    return marched_distance;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    // Calculate distance to closest object.\n    vec3 minimal_distance = vec3(find_closest_scene_object(p));\n    \n    vec3 aux = vec3(\n        find_closest_scene_object(p - vec3(0.001, 0.0,  0.0)),\n        find_closest_scene_object(p - vec3(0.0, 0.001,  0.0)),\n        find_closest_scene_object(p - vec3(0.0, 0.0,  0.001))\n    );\n    \n    return normalize(minimal_distance - aux);\n}\n\n#define NZMX                      ( (2.*iMouse.x-iResolution.x) / iResolution.x )  // in range [-1.0; 1.0]\n#define NZMY                      ( (2.*iMouse.y-iResolution.y) / iResolution.y )  // in range [-1.0; 1.0]\nfloat linear_point_light(in vec3 hit_point) // AA is ugly, why?\n{\n    const float inv_half_pi = 0.6366197723675813;\n    float intensity = 1.;\n\n    // Define light source\n    vec3 light_source = iMouse.xy == vec2(0) ? vec3(30., -30., -20) : vec3(NZMX*100., NZMY*100., -20.0);\n\n    // Calculate hit_point to light_source direction.\n    vec3 hp_to_l_dir = normalize(light_source - hit_point);\n    \n    // Numerically calculate normal.\n    vec3 normal = calculate_normal(hit_point);\n\n    // Calculate angle between light and normal, then normalize.\n    float theta = acos(dot(normal, hp_to_l_dir)) * inv_half_pi;\n\n    return clamp(intensity * (1. - theta), 0., 1.);\n}\n\nvec4 scene(in vec2 SC)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), false);\n\n    /* Perspective camera. */\n    vec3 lookAt = vec3(0.);\n\n    float zFocalLength = 90.0; // mm.\n    vec3 camera = vec3(10.0, -15.0, -15.0);\n\n    vec3 f = normalize(lookAt - camera),               // forward\n         r = normalize(cross(vec3(0.0, 1.0, 0.0), f)), // right\n         u = normalize(cross(f, r));                   // up\n        \n    float size = 36.0,\n          aspectRatio = iResolution.x / iResolution.y,\n          vpWidth = size,\n          vpHeight = vpWidth / aspectRatio;\n           \n    // Before uv=[0;1][0;1]\n    vec2 uv = SC / iResolution.xy;\n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n    // After uv=[-vpWidth*0.5; vpWidth*0.5][-vpHeight*0.5; vpHeight*0.5]\n               \n    vec3 ray_origin = camera;\n    vec3 ray_direction = normalize(uv.x * r + uv.y * u + f * zFocalLength);\n    /* Perspective camera */\n      \n    // March through scene.\n    float marched_distance = ray_march(ray_origin, ray_direction, 200., 1000.0, 0.0001);\n    \n    // Restore hit point coordinates.\n    vec3 hit_point = ray_origin + ray_direction * marched_distance;\n\n    float diffuse = linear_point_light(hit_point);\n\n    return vec4(mix(vec3(0,0,0), vec3(0,1,0), diffuse), 1);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec4 col = vec4(0);\n    float order = 3.;\n\n    // Supersample.\n    for (float y = 0.; y < order; y += 1.0)\n    {\n        for (float x = 0.; x < order; x += 1.0)\n        {\n            /* Jitter antialiasing */\n            vec2 jitter = abs(HASH(y, x)) * 2.0;\n            col += scene(SC + jitter);\n            /* Offset antialiasing *\n            vec2 offset = (2.*vec2(x, y)) / order;\n            col += scene(SC + offset);\n            /**/\n        }\n    }\n    \n    O = col / (order*order);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH(x, y)                ( hash2to2(uint(x), uint(y)) )\n\nmat3 rotY(float rad)\n{\n    float s = sin(rad), c = cos(rad);\n    mat3 M = mat3(\n         c, 0, s,\n         0, 1, 0,\n        -s, 0, c);\n    return transpose(M);\n}","name":"Common","description":"","type":"common"}]}