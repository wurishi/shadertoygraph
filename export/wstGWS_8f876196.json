{"ver":"0.1","info":{"id":"wstGWS","date":"1569248991","viewed":293,"name":"Mandala Stone","username":"ParaBellum","description":"Experimenting displacement mapping","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["3d","displacement","mandala"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define MIN_DIST .0001\n#define MAX_DIST 10.\n\n#define MIN_SHADOW .1\n#define MAX_SHADOW .10\n\n#define AO_SAMPLES 1.\n#define AO_INTENSITY 1.\n\n#define T iTime\n#define L_P vec3(cos(T*.5), .75, sin(T*.5))*5.\n#define SHININNESS 64.\n\nfloat sdSphere(in vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat sdCube(in vec3 p, float r)\n{\n    p = abs(p)-r;\n    return max(p.x,max(p.y,p.z));\n}\n\nvec2 uv(in vec3 p, in vec3 n)\n{\n    return (p.xy+1.)*.5 * abs(n.z) + (p.xz+1.)*.5 * abs(n.y) + (p.yz+1.)*.5 * abs(n.y);\n}\n\nfloat scene(in vec3 p)\n{\n    float b = 0.;\n    \n    float pr = .04;\n   \tb += texture(iChannel0, .5*(p.xy+1.)).x*pr;\n    b += texture(iChannel0, .5*(p.xz+1.)).x*pr;\n    b += texture(iChannel0, .5*(p.yz+1.)).x*pr;\n    \n    float s = sdCube(p, 1.)-b;\n    return s;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, 0.);\n    float d = scene(p);\n    vec3 n = d - vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx));\n    return normalize(n);\n}\n\nfloat phong(in vec3 p, in vec3 n, in vec3 o)\n{\n    vec3 ld = normalize(L_P - p);\n    vec3 vd = normalize(o - p);\n    vec3 hv = normalize(ld + vd);\n    \n    float Kd = max(dot(n, ld), 0.);\n    float Ks = pow(max(dot(n, hv), 0.), SHININNESS);\n    \n    return Kd+Ks;\n}\n\nfloat hShadow(in vec3 o)\n{\n    vec3 d = normalize(L_P - o);\n    float t = MIN_SHADOW;\n    for (int i = 0; i < 1; i+=0)\n    {\n        float s = scene(o + d * t);\n        if (s < .01)\n            return 0.5;\n        if (t > MAX_SHADOW)\n            break;\n        t += s;\n    }\n   \treturn 1.;\n}\n\nfloat ambientOcclusion(in vec3 p, in vec3 n)\n{\n    float s = 1. / AO_SAMPLES;\n    float ao = clamp((s-scene(p + n * s))*AO_INTENSITY, 0., 1.);\n    return 1. - ao / AO_SAMPLES;\n}\n\nfloat shade(in vec3 p, in vec3 o)\n{\n    vec3 n = normal(p);\n    float ph = phong(p, n, o);\n    float a = .3;\n    float s = hShadow(p);\n    s = pow(s, 4.);\n    float ao = ambientOcclusion(p, n);\n    return clamp(ph*s + a*ao, 0., 1.);\n}\n\nfloat march(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float s = scene(o + d * t);\n        if (s < MIN_DIST)\n            return t;\n        if (s > MAX_DIST)\n            return -1.;\n        t += s*.7;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    float a = T*.25;\n    vec3 o = vec3(sin(a)*2.5, 1.75-5.*iMouse.y/iResolution.y, cos(a)*2.5);\n    vec3 lp = vec3(0., 0., .0);\n    vec3 f = normalize(lp-o);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    vec3 d = (uv.x*r + uv.y*u + f);\n    \n    float m = march(o, d);\n    if ( m > -1.)\n    {\n    vec3 p = o + d * m;\n    float s = shade(p, o);\n    col += s;\n    }\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define RAD 3.141592/180.\n#define OCTAVES 5\n\nfloat quad(vec2 p)\n{\n    p = abs(p);\n    return 1.-max(p.x, p.y);\n}\n\nfloat octagon(vec2 p)\n{\n    p = abs(p);\n    float o = max(p.x, p.y);\n    return 1.-max(o, dot(p, vec2(.7071)));\n}\n\nfloat petal(vec2 p, float w)\n{\n    p = abs(p);\n    p.y += w;\n    return 1.-length(p);\n}\n\nfloat circle(vec2 p)\n{\n    return dot(p, p);\n}\n\nfloat cone(vec2 p)\n{\n    return length(p);\n}\n\nvec2 hash22( vec2 p ) \n{\n    return fract(sin(vec2(dot(p,vec2(1.,3.)),dot(p,vec2(2.,1.)))));\n}\n\nfloat voronoi(vec2 p, float s)\n{\n    p *= s;\n    vec2 i = floor(p);\n    float m_d = 1.;\n    vec2 c;\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 n = vec2(float(x), float(y))+i;\n            vec2 a = hash22(n)+n;\n            float d = length(p-a);\n            if (d < m_d)\n            {\n                m_d = d;\n                c = n;\n            }\n        }\n    }\n    \n    m_d = 1.;\n    for (int y = -2; y <= 2; y++)\n    {\n        for (int x = -2; x <= 2; x++)\n        {\n            vec2 n = vec2(float(x), float(y))+c;\n            vec2 o = hash22(c)+c;\n            vec2 k = .5*((hash22(n)+n)+o);\n            float d = dot(normalize(o-k), p-k);\n            m_d = min(d, m_d);\n        }\n    }\n    \n    return m_d;\n}\n\nfloat hash21( vec2 p ) \n{\n    return fract(sin(dot(p,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat vnoise(vec2 p, float s)\n{\n    p *= s;\n    vec2 i = floor(p);\n    vec2 e = vec2(1., 0.);\n    float v0 = hash21(i);\n    float v1 = hash21(i+e.xy);\n    float v2 = hash21(i+e.yx);\n    float v3 = hash21(i+e.xx);\n    \n    vec2 u = smoothstep(0., 1., fract(p));\n    \n    float b = mix(v0, v1, u.x);\n    float t = mix(v2, v3, u.x);\n    return mix(b, t, u.y);\n}\n\nfloat fbm(vec2 p)\n{\n    float n = 0.;\n    float a = .5;\n    for (int i = 0; i < OCTAVES; i++)\n    {\n        n += a*vnoise(p+10., 3.);\n        p = p*2.+p+.3;\n        a *= .5;\n    }\n    return n;\n}\n\nfloat qudFrame(vec2 p)\n{\n    float n = fbm(p*2.);\n    float q_01 = clamp(quad(p)/.05, 0., 1.);\n    float n_01 = smoothstep(.0, .01, q_01)*n;\n    q_01 *= smoothstep(.5, 1.5, q_01+n_01);\n    \n    float q_02 = clamp(quad(p/.9)/.05, 0., 1.);\n    float n_02 = smoothstep(.0, .01, q_02)*n;\n    q_02 *= smoothstep(.5, 1.3, q_02+n_02);\n    \n    return mix(q_01, q_02, .5);\n}\n\nfloat octFrame(vec2 p)\n{   \n    float n = fbm(p*5.);\n    \n    float o_01 = octagon(p/1.13)/.05;\n    float o_02 = octagon(p/.925)/.05;\n    float s_01 = clamp(min(o_01, 1.-o_02), 0., 1.);\n    \n    float n_01 = smoothstep(.0, .01, s_01)*n;\n    s_01 *= smoothstep(.5, 1.5, s_01/n_01);\n    \n    float o_03 = octagon(p/1.06)/.05;\n    float o_04 = octagon(p/.99)/.05;\n    float s_02 = min(o_03, 1.-o_04);\n    float n_02 = smoothstep(.0, .25, s_02)*n;\n    s_02 *= smoothstep(.5, 1.25, s_02/n_02);\n    \n    float r = mix(s_01, s_02, .5);\n    \n    return r;\n}\n\nfloat flower(vec2 p, float m, float t, float tp, float s, float o, float g, float sh, float c)\n{\n    float p_01 = 0.;\n    p = abs(p)-m;\n    \n    float n = fbm(p*5.);\n    \n    for (int i = 0; i < 3; i++)\n    {\n        float a = t*float(i)*RAD+(tp*RAD);\n       \tvec2 n = p*s;\n        n *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        n -= vec2(o, .0);\n        p_01 = max(p_01, petal((n)/1., g)/.1);\n    }\n    float n_01 = smoothstep(.0, .1, p_01)*n;\n    p_01 *= smoothstep(.5, 1.5, p_01/n_01);\n    \n    float ps_01 = p_01/sh;\n    p_01 = clamp(min(p_01, 1.-ps_01), 0., 1.);\n    p_01 *= clamp(cone(p)*(sh*.4), 0., 1.);\n    \n    float fc_01 = 1.-circle(p/c);\n    float n_02 = smoothstep(.0, .1, fc_01)*n;\n    fc_01 *= smoothstep(.0, 1., fc_01+n_02);\n    \n    float fcs_01 = 1.-(1.-cone(p/c));\n    fc_01 *= clamp(mix(fc_01, fcs_01, .7), 0., 1.)+.15;\n    \n    return max(fc_01, (p_01-fc_01));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    \n    uv *= 1.0;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 st = fract(uv*2.)*2.-1.;\n    \n    // Quad frame\n    float qf = qudFrame(uv);\n    float mk_01 = clamp(quad(uv/.7)/.01, 0., 1.);\n    qf = min(qf, 1.-mk_01);\n\n    // Octagon frame\n    float of = octFrame(st);\n    // Big flower\n    // uv, mirror, angle, extra angle, size, spread level, gradient, shadow size, center size\n    float bf = flower(st, 0., 45., 0., 2., 1., .625, 5., .225);\n    // Small flower\n    float sf = flower(st, 1., 90., 45., 5., .6, .45, 8., .1);\n    // Flowers\n    float f = max(bf, sf);\n    // Flowers and Octagons\n    float fo = max(of, f);\n    // Tile\n    float t = max(qf, min(fo, step(.01, mk_01)));\n    // Cracks\n    float fn = fbm(uv)*.1;\n    float vn = vnoise(uv+fn, 5.);\n    float c = smoothstep(.0, .2, voronoi(uv+fn+vn*.05, 1.5))+.2;\n    float q_01 = clamp(quad(uv)/.05, 0., 1.);\n    c = smoothstep(0., 1., min(c, q_01));\n    // Result\n    float r = min(t+.15,c);\n    \n    col += r; \n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}