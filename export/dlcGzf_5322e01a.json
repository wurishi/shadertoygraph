{"ver":"0.1","info":{"id":"dlcGzf","date":"1683104848","viewed":93,"name":"Regular hyperbolic octagon","username":"cancrizans","description":"Regular octagon with angles pi/8 can be glued together to form a smooth surface of genus two and constant negative curvature.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gamma = 5. + 4.*sqrt(2.0);\nconst float gammabeta = sqrt(gamma*gamma-1.0);\n\nconst float beta = gammabeta/gamma;\nconst float eta = .5 * log((1.+beta)/(1.-beta));\n\n\nconst float PI_4 = 0.78539816339 ;\n\nconst float INVSQRT2 = 1.0/sqrt(2.0);\n\n\n\nvec3 fundamental_domain(vec2 w){\n    float wnorm2 = dot(w,w);\n    float wnorm = sqrt(wnorm2);\n    float l = log((1.+wnorm)/(1.-wnorm));\n    \n    vec3 tone = vec3(w.x,.25+.333*w.y,-w.y)/wnorm;\n    \n    return (.5 + .5*(fract(4.*l))) * tone;\n}\n\nvec3 pix(vec2 fragCoord){\n    vec2 z_flat = 2.*((fragCoord-iResolution.xy*.5) / iResolution.y);\n    float norm2z = dot(z_flat,z_flat);\n    if(norm2z>1.)\n    {\n        return vec3(0.,0.,0.);\n        \n    }\n\n    vec3 z = vec3( 2.*z_flat, 1.+ norm2z)/(1.-norm2z);\n    \n    float tl = (fract(0.1*iTime-.5)-.5) * eta;\n    float etl = .5*exp(tl);\n    float emtl = .5*exp(-tl);\n    float tlgamma = etl + emtl;\n    float tlgammabeta = etl - emtl;\n    \n    z = vec3(z.z*tlgammabeta + z.x*tlgamma, z.y,z.z*tlgamma + z.x*tlgammabeta);\n    \n    \n    for(int i=0; i<25; i++){\n        float t = z.z;\n        bool has_transformed = false;\n        \n        for(int j = 0; j< 8; j++){\n            \n            \n            \n            float nt = gamma * z.z - gammabeta * z.x;\n\n            if(nt < t){\n                z = vec3(- gammabeta*z.z + gamma * z.x ,z.y, nt);\n                has_transformed = true;\n                \n                float angle = float(j) * PI_4;\n                float c = cos(angle);\n                float s = sin(angle);\n                \n                z.xy = vec2(c*z.x - s * z.y, s*z.x + c *z.y);\n                break;\n            }\n            \n           \n            \n            z.xy = INVSQRT2 * vec2(z.x+z.y, -z.x+z.y);\n        }\n        \n        if(!has_transformed)\n            break;\n    \n    }\n\n    vec2 w = z.xy/(1.+z.z);\n    return fundamental_domain(w);\n\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.,0.,0.);\n    col += .25*pix(fragCoord-.25);\n    col += .25*pix(fragCoord+.25);\n    col += .25*pix(fragCoord+vec2(.25,-.25));\n    col += .25*pix(fragCoord+vec2(-.25,+.25));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}