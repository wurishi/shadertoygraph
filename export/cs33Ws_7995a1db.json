{"ver":"0.1","info":{"id":"cs33Ws","date":"1678008069","viewed":115,"name":"SDF demo for my presentation","username":"bmateusz","description":"Slides for my presentation that I will show on an internal conference at Prezi: https://bmateusz.github.io/presentations/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","demo","presentation","prezi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, float s )\n{\n   return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n// https://www.shadertoy.com/view/7tyGWw\nfloat sdDashedCircle( in vec2 p )\n{\n    float arcRadius = length(p);\n\n    const float RadiusOuter = 0.44;\n    const float RadiusInner = 0.36;\n    const float NumDashes = 30.;\n    const float DashRatio = 0.5;  // set between 0-1 to adjust the empty space between dashs\n\n    // Compute the radial distance field coming out from the center of a torus\n    const float hw = (RadiusOuter-RadiusInner)*0.5; // half width from center of torus to edge\n    float radialDF = arcRadius - (RadiusOuter-hw);  // creates a torus\n    radialDF = abs(radialDF)-hw; // give an inside and outside to the torus\n\n\n    // Compute the gradient along the length of the arc\n    float arcGradient = atan(p.y,p.x)/6.283185;\n    arcGradient = fract(arcGradient*NumDashes);\n    arcGradient = abs((arcGradient-0.5)*2.0);  // make the gradient a linear, continous 0-1-0-1 repeating pattern\n    arcGradient = arcGradient-DashRatio; // split the arc into positive and negative sections\n    float Theta = arcGradient * (3.1415927/NumDashes); // gets us a signed angle from the nearest dash edge, in radians\n\n    // figure out the point closest to us on the nearest dash edge\n    float s = sin(Theta);\n    float c = cos(Theta);\n    float edgeProjection = clamp(c*arcRadius,RadiusInner,RadiusOuter); // project point p but bound it between the innner and outer radii of the dash\n    vec2  nearestEdgeP = mat2(c,-s,s,c)*p * edgeProjection/arcRadius;\n    float edgeDF = length(p-nearestEdgeP);\n\n    return (Theta   >0.0) ? edgeDF   :\n           (radialDF>0.0) ? radialDF :\n                            max(-edgeDF,radialDF);\n}\n\nfloat sdTorusDashed( vec3 p )\n{\n    p = vec3(p.y, p.z, p.x);\n    float h = 0.01;\n    float d = sdDashedCircle(p.xy);\n    vec2 w = vec2( d, abs(p.z) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s);\n    return length(vec3(q.x,q.y-s+k,q.z-k));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n// vec3 round( in vec3 p ) {\n//     return floor(p+0.5);\n// }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opRepLimBox( in vec3 p, in float c, in vec3 l, in vec3 box )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdBox( q, box );\n}\n\nfloat sdOchedronWithTorus( vec3 pos, float s, float fade ) {\n  float r = (sin(iTime) + 1.0) / 2.0;\n  return opSmoothUnion(\n    sdOctahedron(pos, 0.4 * r * fade),\n    sdTorus(pos, vec2(0.4, 0.1) * (1.0 - r) * fade),\n    0.3\n  );\n}\n\nfloat sdPlate( vec3 pos, float ir, float r ) {\n  float rect = sdBox(pos, vec3(0.01, r, r));\n  float sphere = sdSphere(pos, r);\n  float iSphere = sdSphere(pos, ir);\n  return max(-iSphere, max(rect, sphere));\n}\n\nfloat sdPrezi( vec3 pos, float slide, float fade ) {\n  float t1 =         sdTorus(pos.yxz, vec2(0.28, 0.01));\n  float t2 = min(t1, sdTorus(pos.yxz, vec2(0.31, 0.01)));\n  float t3 = min(t2, sdTorus(pos.yxz, vec2(0.34, 0.01)));\n\n  // float t1 =         sdPlate(pos.xyz, 0.27, 0.29);\n  // float t2 = min(t1, sdPlate(pos.xyz, 0.30, 0.32));\n  // float t3 = min(t2, sdPlate(pos.xyz, 0.33, 0.35));\n\n  // one standing rectangle\n  float oneLine = sdBox(pos, vec3(0.01, 0.3, 0.01));\n  // multiple rectangles next to each other\n  vec3 l = vec3(0.0, 0.0, 3.0);\n  float c = 0.08;\n  vec3 boxQ = pos-c*clamp(round(pos/c),-l,l);\n  float lines = sdBox(boxQ, vec3(0.01, 0.3, 0.02));\n  float linesBound = sdSphere(pos, 0.25);\n  float inside = max(lines, linesBound);\n  // b = opRepLimBox(pos, 0.1, vec3(0.0, 0.0, 2.0), vec3(0.01, 0.3, 0.01));\n  float t3OneLine = min(t3, oneLine);\n  float t3Lines = min(t3, lines);\n  float t3LinesBound = min(t3Lines, linesBound);\n  float t3Inside = min(t3, inside);\n\n  // float plate = sdPlate(pos, 0.4, 0.5);\n  // move position to the top of the plate\n\n  // failed attempt to make the plate move with the torus\n  // vec3 qPlate = pos - vec3(0.0, 0.39, 0.0);\n  // vec3 plateBox = vec3(0.01, 0.03, 0.01);\n  // // repeat the plate around the torus, with a slight offset, rotating the plates to face them to the center\n  // vec3 lPlate = vec3(0.0, 0.0, 3.0);\n  // float cPlate = 0.08;\n  // vec3 boxQPlate = qPlate-cPlate*clamp(round(qPlate/cPlate),-lPlate,lPlate);\n  // float plate = sdBox(boxQPlate, plateBox);\n\n  float plate = sdTorusDashed(pos);\n  float prezi = min(t3Inside, plate);\n\n  if (slide >= 19.0) {\n    return prezi;\n  }\n  if (slide >= 18.0) {\n    // return prezi;\n    return mix(t3Inside, prezi, fade);\n  }\n  if (slide >= 17.0) {\n    // return t3Inside;\n    return mix(t3LinesBound, t3Inside, fade);\n  }\n  if (slide >= 16.0) {\n    // return t3LinesBound;\n    return mix(t3Lines, t3LinesBound, fade);\n  }\n  if (slide >= 15.0) {\n    return mix(t3OneLine, t3Lines, fade);\n  }\n  if (slide >= 14.0) {\n    return mix(t3, t3OneLine, fade);\n  }\n  if (slide >= 13.0) {\n    return mix(t2, t3, fade);\n  }\n  if (slide >= 12.0) {\n    return mix(t1, t2, fade);\n  }\n  return sdTorus(pos.yxz, vec2(0.28 * fade, 0.01)); // t1 with fade\n}\n\nfloat map( in vec3 pos, float slide )\n{\n    float fade = fract(slide);\n    if (slide >= 11.0) {\n        return sdPrezi(pos, slide, fade);\n    }\n    if (slide >= 10.0) {\n        return sdBox(pos, vec3(0.2 * (1.0 - fade)));\n    }\n    if (slide >= 9.0) {\n        float r = 1.0 + 100.0 * (1.0 - fade);\n        return opRepLimBox(pos,2.0,vec3(r, 1.0, r), vec3(0.2));\n    }\n    if (slide >= 8.0) {\n        float r = 2.0 + 98.0 * fade;\n        return opRepLimBox(pos,2.0,vec3(r, 1.0, r), vec3(0.2));\n    }\n    if (slide >= 7.0) {\n        float r = 1.0 + fade;\n        return opRepLimBox(pos,2.0,vec3(r, 1.0, r), vec3(0.2));\n    }\n    if (slide >= 6.0) {\n        // return sdBox(pos, vec3(0.2));\n        return opRepLimBox(pos,2.0,vec3(fade), vec3(0.2));\n    }\n    if (slide >= 5.0) {\n        return mix(\n            sdOchedronWithTorus(pos, 0.4, 1.0),\n            sdBox(pos, vec3(fade * 0.2)),\n            fade\n        );\n    }\n    if (slide >= 4.0) {\n        return mix(\n            sdTorus(pos, vec2(0.4, 0.1)),\n            sdOchedronWithTorus(pos, 0.4, fade),\n            fade\n        );\n    }\n    if (slide >= 3.0) {\n        return mix(\n            sdOctahedron(pos, 0.4),\n            sdTorus(pos, vec2(0.4, 0.1) * fade),\n            fade\n        );\n    }\n    if (slide >= 2.0) {\n        return mix(\n            sdSphere(pos, 0.4),\n            sdOctahedron(pos, 0.4 * fade),\n            fade\n        );\n    }\n    if (slide >= 1.0) {\n        return sdSphere(pos, 0.4 * fade);\n    }\n    return 10.0; // always outside\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, float slide )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps, slide ) +\n            e.yyx*map( pos + e.yyx*eps, slide ) +\n            e.yxy*map( pos + e.yxy*eps, slide ) +\n            e.xxx*map( pos + e.xxx*eps, slide ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // calculate fragColor using fragCoord and iTime\n    vec3 rainbow = vec3(\n        0.5 + 0.5 * cos(iTime + fragCoord.x / 500.0),\n        0.5 + 0.5 * sin(iTime + fragCoord.y / 500.0),\n        0.5 + 0.5 * sin(iTime + fragCoord.x / 500.0 + fragCoord.y / 500.0)\n    );\n\n    float slide = iTime * 0.2;\n\n    // camera movement\n    float an = 0.5*(iTime-10.0);\n    vec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 300.0;\n    float t = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos, slide);\n        if( h<0.0001 || t>tmax ) break;\n        t += h;\n    }\n\n    // shading/lighting\n    // vec3 col = rainbow.zxy;\n    vec3 col = vec3(0.8, 0.9, 1.0);\n    if( t<tmax )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, slide);\n        vec3 dif_color = rainbow; // vec3(0.0,1.0,0.0);\n        float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n        float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n        col = vec3(0.2,0.3,0.4)*amb + dif_color*dif;\n        // col = mix(rainbow, col, abs(sin(iTime / 1.)));\n    }\n\n    // gamma\n    // col = sqrt( col );\n    tot += col;\n\n    if (slide <= 2.0) {\n        tot = mix(rainbow, tot, abs(slide - 1.0));\n    }\n\n    fragColor = vec4( tot, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}