{"ver":"0.1","info":{"id":"tldXDs","date":"1582004557","viewed":160,"name":"Sparkly Garbage","username":"okelly4408","description":"just throwing a few things together. hopefully this leads to more progress. Anyone know how to get rid of that edge ray marching step artefact on the ground fog?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sigh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FOG\n#define CLOUDS\n#define TERRAIN\nconst vec3 sun = normalize(vec3(1.0, 1.0, 1.0));\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\nfloat cfbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*(1.0 - abs(noise( p ))); p = m*p*2.02;\n    f += 0.2500*(1.0 - abs(noise( p ))); p = m*p*2.03;\n    f += 0.1250*(1.0 - abs(noise( p ))); p = m*p*2.01;\n    f += 0.0625*(1.0 - abs(noise( p )));\n    return f;\n}\nfloat fbm(vec3 v)\n{\n    float frequency = 1.0;\n    float gain = 1.0;\n    float damp = 0.5;\n    float lacunarity = 1.81;\n\tfloat sum = 0.0;\n    for (int i = 0; i < 8; i++)\n    {\n        sum += (1.0 - pow(abs(noise(v * frequency)), 2.0) )* (gain);\n        frequency *= lacunarity;\n        gain *= damp;\n    }\n    return sum * 0.75;\n}\n//Musgrave's algorithm from \"Texturing and Modeling: A Procedural Approach\"\nfloat RMF(in vec3 v)  {\n\n\tfloat result, frequency, signal, weight;\n    float H = 0.05;\n\tfloat lacunarity = 2.13413;\n\tint octaves = 6;\n\tfloat offset = 1.0;\n\tfloat gain = 1.4;\n    int i;\n    frequency = 1.0;\n      \n    signal = noise(v);\n                      \n    signal = offset - signal;\n         \n    signal *=signal;\n        \n    result = signal;\n    weight = 1.0;\n\n\tfor (i = 1; i < octaves; i++) {   \n\t\tv*=lacunarity;         \n\t\tweight = clamp(signal * gain, 0.0, 1.0); \n\t\tsignal = (noise(v));                 \n \t\tsignal = offset - signal;\n\t\tsignal *= signal;\n\t\tsignal *= weight;\n\t\tresult += signal * pow(frequency, -H);\n\t\tfrequency *= lacunarity;\n\t}       \n    return (result);        \n}\nfloat getTerraced(float val, float n, float power)\n{\n\tfloat dVal = val * n;\n\tfloat f = fract(dVal);\n\tfloat i = floor(dVal);\n\n\treturn (i + pow(f, power)) / n;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat dScene(in vec3 p)\n{\n    //p.xz = mod(p.xz, vec2(4.0)) - 2.0;\n    float plane = p.y - ((getTerraced(RMF((p / 4.0))+0.5, 1.3, 1.9) * 2.0) + 5.0);\n    //p.y += noise(p * 2.0);\n    return plane;\n}\nfloat calcIntersection( in vec3 ro, in vec3 rd, out float dist)\n{\n\tconst float maxd = 80.0;           \n\tconst float precis = 0.001;        \n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    vec3 pos = ro;\n    for( int i=0; i<90; i++ )          \n    {\n        if( h<precis||t>maxd) \n            break;\n        pos = ro+rd*t;\n\t    h = dScene(pos);\n        t += h;\n    }\n    dist = -1.0;\n    if( t<maxd )\n    {\n        res = t;\n        dist = t;\n    }\n    ;\n    return res;\n}\n\nfloat marchFog( in vec3 ro, in vec3 rd, float intersection)\n{\n    const float maxd = 20.0;           \n    float t = 0.0;\n    vec3 pos = ro;\n    float density = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n        if(t > maxd || t > intersection) \n            break;\n        density += cfbm(pos) * (1.0 - smoothstep(6.0, 6.2, pos.y));\n        pos += 0.5 * rd;\n        t += 0.25;\n    }\n    return density;\n}\n\nfloat marchClouds(in vec3 ro, in vec3 rd, in float intersection)\n{\n\n    float sum = 0.0;\n    float t = 0.0;\n    vec3 pos = ro;\n\tfor (int i = 0; i < 150; i++)\n    {\n        if(t > intersection && intersection > 0.0)\n            break;\n        pos += (rd * t);\n        float n = fbm(pos / 32.0);\n        sum += n;\n        t = n;\n    }\n    sum /= 405.0;\n    float blend = smoothstep(0.25, 0.5, sum * 1.1);\n    float fog = mix(0.0, 1.0, blend);\n    return fog;\n    //vec3 color = mix(vec3(sum * 3.2) * ((1. / exp( sum * 0.45 )) * 1.25), vec3(0.0, 0.2, 0.5), fog);\n    //fragColor = vec4(fog + vec3(0.0, 0.2, 0.5), 1.0);\n}\n\nvec3 getCloudPointColor(in vec3 pos)\n{\n    const float eps = 0.002;             \n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n    \n    return normalize( v1*fbm( (pos + v1*eps) / 32.0 ) + \n\t\t\t\t\t  v2*fbm( (pos + v2*eps) / 32.0 ) + \n\t\t\t\t\t  v3*fbm( (pos + v3*eps) / 32.0 ) + \n\t\t\t\t\t  v4*fbm( (pos + v4*eps) / 32.0 ) );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             \n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*dScene( pos + v1*eps ) + \n\t\t\t\t\t  v2*dScene( pos + v2*eps ) + \n\t\t\t\t\t  v3*dScene( pos + v3*eps ) + \n\t\t\t\t\t  v4*dScene( pos + v4*eps ) );\n}\n\nvec3 skyColor( in vec3 rd )\n{\n    vec3 sundir = normalize( vec3(2.0, -2.0, 0.0) );\n    \n    float yd = min(rd.y, 0.);\n    rd.y = max(rd.y, 0.);\n    \n    vec3 col = vec3(0.);\n    \n    col += vec3(.4, .4 - exp( -rd.y*20. )*.3, .0) * exp(-rd.y*9.); // Red / Green \n   // col += vec3(.3, .5, .6) * (1. - exp(-rd.y*8.) ) * exp(-rd.y*.9) ; // Blue\n    \n///col = mix(col*1.2, vec3(.3),  1.-exp(yd*100.)); // Fog\n    \n   // col += vec3(1.0, .8, .55) * pow( max(dot(rd,sundir),0.), 15. ) * .6; // Sun\n  //  col += pow(max(dot(rd, sundir),0.), 150.0) *.15;\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rd = normalize(vec3((fragCoord.xy-0.5*iResolution.xy)/iResolution.y, 1.));\n\tvec3 ro = vec3(0., 9., 70.);\n    ro.z += iTime;\n    ro.xz += iMouse.xy;\n\tvec3 col = vec3(0.1, 0.25, 0.65);\n\tfloat intersection;\n    \n    #ifdef TERRAIN\n\tfloat res = calcIntersection(ro, rd, intersection);\n    \n    if (res > -1.0) { \n        vec3 normal = calcNormal(vec3(ro + (rd * res)));\n        float dif = dot(normal, normalize(vec3(1.0, 1.0, 1.0)));\n        \n        col = skyColor(normal) * 4.0;\n        col = mix(normal, col, normal.y);\n        col *= dif + 0.1;        \n    }\n    #endif\n    #ifdef FOG\n\tfloat fogDensity = marchFog(ro, rd, intersection) / 16.0;\n    fragColor.rgb = mix(vec3(1.0), col.rgb, exp(-fogDensity));\n    #else\n    fragColor = vec4(col, 1.0);\n    #endif\n    \n    #ifdef CLOUDS\n    float clouds = marchClouds(ro, rd, intersection);\n    if (res == -1.0) {\n        fragColor.rgb = mix(getCloudPointColor(ro), fragColor.rgb, clouds);\n    }\n    #endif\n}","name":"Image","description":"","type":"image"}]}