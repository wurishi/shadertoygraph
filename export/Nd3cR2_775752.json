{"ver":"0.1","info":{"id":"Nd3cR2","date":"1654044813","viewed":167,"name":"Hyperbolic_Space","username":"afoksha","description":"The goal is to render dodecahedral subdivision analogous to sphere subdivision. Precision of float, or, more precisely, the lack of it, starts playing seriously when one leaves vicinity of the origin. ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["dodecahedron","hyperbolicspace","lorentzspace","hyperboloidmodel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*      Regular dodecahedra in hyperbolic 3-space H form a one parameter family up to hyperbolic motions. They are\n    parameterized by, say, the length of their edge. The angle between two adjacent faces takes all the values\n    below the euclidean value of the angle, 2 arctan(ϕ) = 116.56... degrees down the value of the angle if ideal\n    dodecahedron, π/3. There is thus the unique up to motion right-angled dodecahedron D. The face angles of D \n    are also π/2 and exactly three faces meet in one vertex. Reflections in face planes and all the possible \n    combinations of such reflections of D tesselate H. 8 dodecahedra meet at each vertex. Reflections however \n    change space orientation and it is better to use their compositions with reflection about center of D. The \n    discrete subgroup of hyperbolic motions generated by these 12 transformation we will denote by G. Generators \n    of G are pure hyperbolic translations combined with rotation by π along the axis of translation, which joins \n    centers of opposite faces of D. Pure translation (along a geodesic) here means that normal basis is mapped \n    in such a way as it would do by parallel transport defined in riemannian geometry.\n\n        It is a hyperbolic group, meaning that the number of different group elements generated by the words on\n    generators of length <= N grows exponentially with N. This is obvious also from the fact that the volume of a\n    ball of radius R grows exponentially with R, and so does the number of dodecahedra that fit into this ball.\n\n        D is the fundamental domain of the G-action, meaning that if any transformation of G maps D to itself, then\n    it is the identity transformation. If that were not true, smaller part of D would be a fundamental domain. This\n    can be restated as follows: if two transformations of G map D to the same dodecahedron D' then these\n    transformations are equal.\n\n        Call these 12 generators P, p, Q, q, R, r, S, s, T, t, U, u ::\n\n        P = |     -1,      0,      0,      0 |\n            |      0,      0,    phi,  alpha |\n            |      0,    phi,    phi,   beta |\n            |      0,  alpha,   beta,  gamma |\n\n        p = |     -1,      0,      0,      0 |\n            |      0,      0,    phi, -alpha |\n            |      0,    phi,    phi,  -beta |\n            |      0, -alpha,  -beta,  gamma |\n\n        Q = |     -1,      0,      0,      0 |\n            |      0,      0,   -phi, -alpha |\n            |      0,   -phi,    phi,   beta |\n            |      0, -alpha,   beta,  gamma |\n\n        q = |     -1,      0,      0,      0 |\n            |      0,      0,   -phi,  alpha |\n            |      0,   -phi,    phi,  -beta |\n            |      0,  alpha,  -beta,  gamma |\n\n        R = |    phi,      0,    phi,   beta |\n            |      0,     -1,      0,      0 |\n            |    phi,      0,      0,  alpha |\n            |   beta,      0,  alpha,  gamma |\n\n        r = |    phi,      0,    phi,  -beta |\n            |      0,     -1,      0,      0 |\n            |    phi,      0,      0, -alpha |\n            |  -beta,      0, -alpha,  gamma |\n\n        S = |    phi,      0,   -phi,  -beta |\n            |      0,     -1,      0,      0 |\n            |   -phi,      0,      0,  alpha |\n            |  -beta,      0,  alpha,  gamma |\n\n        s = |    phi,      0,   -phi,   beta |\n            |      0,     -1,      0,      0 |\n            |   -phi,      0,      0, -alpha |\n            |   beta,      0, -alpha,  gamma |\n\n        T = |      0,    phi,      0,  alpha |\n            |    phi,    phi,      0,   beta |\n            |      0,      0,     -1,      0 |\n            |  alpha,   beta,      0,  gamma |\n\n        t = |      0,    phi,      0, -alpha |\n            |    phi,    phi,      0,  -beta |\n            |      0,      0,     -1,      0 |\n            | -alpha,  -beta,      0,  gamma |\n\n        U = |      0,   -phi,      0, -alpha |\n            |   -phi,    phi,      0,   beta |\n            |      0,      0,     -1,      0 |\n            | -alpha,   beta,      0,  gamma |\n\n        u = |      0,   -phi,      0,  alpha |\n            |   -phi,    phi,      0,  -beta |\n            |      0,      0,     -1,      0 |\n            |  alpha,  -beta,      0,  gamma |\n\n        alpha = sqrt((sqrt(5) + 1) / 2) = 1.2720196495140690\n        beta  = sqrt(sqrt(5) + 2)       = 2.0581710272714923\n        gamma = (sqrt(5) + 3) / 2       = 2.6180339887498948\n        phi   = (sqrt(5) + 1) / 2       = 1.6180339887498948\n\n        P and p, Q and q, ... etc. are inverse of each other. Another set of relations are commutation relations. Their\n    meaning is that when multiplying 4 generators that subsequently shift D around one of its edges one gets identity at\n    the end, half of these relations follow from the rest:\n\n            Qp = Pq, qP = pQ\n            Rp = Pr, rP = pR\n            Sp = Ps, sP = pS\n            Tp = Pt, tP = pT\n            Up = Pu, uP = pU\n            Rq = Qr, rQ = qR\n            Sq = Qs, sQ = qS\n            tq = QT, TQ = qt\n            uq = QU, UQ = qu\n            sr = RS, SR = rs\n            Tr = Rt, tR = rT\n            ur = RU, UR = ru\n            ts = ST, TS = st\n            Us = Su, uS = sU\n            Ut = Tu, uT = tU\n\n        The number of (unique) dodecahedra generated by k = 0, 1, ... 5 application of generator transforms (and no less) is\n            1, 12, 102, 812, 6402, 50412\n*/\n\n/* helper function :: exchanges the values if necessary so on return we have v0 <= v1 */\nvoid order(inout float v0, inout float v1)\n{\n    float vm = max(v0, v1);\n    v0 = min(v0, v1);\n    v1 = vm;\n}\n\n/* helper function :: smoothed minimum */\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5f + 0.5f * (b - a) / k, 0.0f, 1.0f);\n    return mix(b, a, h) - k * h * (1.0f - h);\n}\n\nfloat arccosh(float q)\n{\n    q = max(q, 1.0f);\n    float s = q + sqrt(q * q - 1.0f);\n    return log(s);\n}\n\nfloat hyp_norm(vec4 v)\n    { return dot(v.xyz, v.xyz) - v.w * v.w; }\n\nfloat hyp_dot(vec4 u, vec4 v)\n    { return dot(u.xyz, v.xyz) - u.w * v.w; }\n\nfloat hyp_distance(vec4 u, vec4 v)\n    { return arccosh(-hyp_dot(u, v)); }\n\n/* time-like vector normalization :: scales the vector to get\n   xx + yy + zz - ww = -1. Points of hyperbolic space H^3 are time-like 4-vectors */\nvec4 normalize_t(vec4 v)\n{\n    float inv_l = 1.0f / sqrt(-hyp_dot(v, v));\n    return inv_l * v;\n}\n\n/* space-like vector normalization :: scales the vector to get\n   xx + yy + zz - ww = +1. Tangent directions to H^3 are space-like 4-vectors */\nvec4 normalize_s(vec4 v)\n{\n    float inv_l = 1.0f / sqrt(hyp_dot(v, v));\n    return inv_l * v;\n}\n\n/* centers of neighbouring domains */\nconst float alpha = 1.2720196495140690f;        /* sqrt((sqrt(5) + 1) / 2)          */\nconst float beta  = 2.0581710272714923f;        /* sqrt(sqrt(5) + 2)                */\nconst float gamma = 2.6180339887498948f;        /* (sqrt(5) + 3) / 2                */\n\n/* face reflection directions */\nconst float mu    = 0.7071067811865475f;        /* 1 / sqrt(2)                      */\nconst float nu    = 1.1441228056353686f;        /* (1 + sqrt(5)) / (2 * sqrt(2))    */\nconst float tau   = 0.8994537199739336f;        /* sqrt(sqrt(5) + 1) / 2            */\n\n/* dodecahedron vertices */\nconst float psi   = 1.8512295868219161f;        /* sqrt(3 * sqrt(5) + 7) / 2       */\nconst float chi   = 1.4553466902253548f;        /* sqrt(2 * sqrt(5) + 4) / 2       */\nconst float rho   = 0.5558929702514212f;        /* sqrt(sqrt(5) - 1) / 2        */\n\n//==========================================================================================================================\n//      The main function: finds the point in the orbit of p under the action of described above hyperbolic isometries\n// group closest to the origin, or, the same, finds point equivalent to p in the main fundamental dodecahedron\n//==========================================================================================================================\nvec4 bounce(vec4 P)\n{\n    int k = 0;\n\n    /*\n        Hyperbolic reflection directions ::\n\n            {  mu,  nu, 0.0, tau }\n            { -mu, -nu, 0.0, tau }\n            { -mu,  nu, 0.0, tau }\n            {  mu, -nu, 0.0, tau }\n            { 0.0,  mu,  nu, tau }\n            { 0.0, -mu, -nu, tau }\n            { 0.0, -mu,  nu, tau }\n            { 0.0,  mu, -nu, tau }\n            {  nu, 0.0,  mu, tau }\n            { -nu, 0.0, -mu, tau }\n            { -nu, 0.0,  mu, tau }\n            {  nu, 0.0, -mu, tau }\n    */\n\n    /* to avoid possible infinite loops for points lying on the faces of the main dodecahedron */\n    while (k < 16)\n    {\n        vec3 q = abs(P.xyz);\n        q = mu * q + nu * q.yzx;\n\n        float W = tau * P.w;\n\n        if (q.x > q.y)\n        {\n            if (q.x > q.z)\n            {\n                /* q.x = mu * |p.x| + nu * |p.y| is maximal */\n                if (q.x > W)\n                {\n                    P = P - 2.0f * (q.x - W) * vec4(mu * sign(P.x), nu * sign(P.y), 0.0f, tau);\n                    P.xyz = -P.xyz;\n                    ++k;\n                    continue;\n                }\n            }\n            else\n            {\n                /* q.z = mu * |p.z| + nu * |p.x| is maximal */\n                if (q.z > W)\n                {\n                    P = P - 2.0f * (q.z - W) * vec4(nu * sign(P.x), 0.0f, mu * sign(P.z), tau);\n                    P.xyz = -P.xyz;\n                    ++k;\n                    continue;\n                }\n            }\n\n        }\n        else    /* q.y >= q.x */\n        {\n            if (q.z > q.y)\n            {\n                /* q.z = mu * |p.z| + nu * |p.x| is maximal */\n                if (q.z > W)\n                {\n                    P = P - 2.0f * (q.z - W) * vec4(nu * sign(P.x), 0.0f, mu * sign(P.z), tau);\n                    P.xyz = -P.xyz;\n                    ++k;\n                    continue;\n                }\n            }\n            else\n            {\n                /* q.y = mu * |p.y| + nu * |p.z| is maximal */\n                if (q.y > W)\n                {\n                    P = P - 2.0f * (q.y - W) * vec4(0.0f, mu * sign(P.y), nu * sign(P.z), tau);\n                    P.xyz = -P.xyz;\n                    ++k;\n                    continue;\n                }\n            }\n        }\n\n        break;\n    }\n\n    return P;\n}\n\nfloat spheric_sdf(vec4 p)\n{\n    p = bounce(p);\n    float d = arccosh(p.w);\n    float sdf0 = d - 0.31f;\n    float sdf1 = 1.01f - d;\n    return min(sdf0, sdf1);\n}\n\nfloat face_sdf(vec4 p)\n{\n    p = bounce(p);\n    float d = arccosh(p.w);\n\n    vec3 q = abs(p.xyz);\n    q = alpha * q + beta * q.yzx;\n\n    float dp = gamma * p.w - max(max(q.x, q.y), q.z);\n    float d1 = arccosh(dp);\n\n\n    float sdf0 = d - 0.31f;\n\n    float b_sdf = 0.98f - d;\n    float f_sdf = 0.5f * (d1 - d - 0.018f);\n    float sdf1 = max(b_sdf, f_sdf);\n\n    return min(sdf0, sdf1);\n}\n\n/*\n    Vertices of the main dodecahedron ::\n\n        { -tau, -tau, -tau, psi }\n        {  tau,  tau,  tau, psi }\n        {  tau, -tau, -tau, psi }\n        { -tau,  tau,  tau, psi }\n        { -tau,  tau, -tau, psi }\n        {  tau, -tau,  tau, psi }\n        {  tau,  tau, -tau, psi }\n        { -tau, -tau,  tau, psi }\n        { -rho,  0.0, -chi, psi }\n        {  rho,  0.0,  chi, psi }\n        {  rho,  0.0, -chi, psi }\n        { -rho,  0.0,  chi, psi }\n        { -chi, -rho,  0.0, psi }\n        {  chi,  rho,  0.0, psi }\n        { -chi,  rho,  0.0, psi }\n        {  chi, -rho,  0.0, psi }\n        {  0.0, -chi, -rho, psi }\n        {  0.0,  chi,  rho, psi }\n        {  0.0, -chi,  rho, psi }\n        {  0.0,  chi, -rho, psi }\n*/\n\nfloat edge_sdf(vec4 p)\n{\n    p = bounce(p);\n\n    vec4 c = vec4(chi, -chi, rho, -rho);\n\n    vec4 A = p.x * c.yxyx + p.y * c.wzzw;\n    vec4 B = p.y * c.xyyx + p.z * c.zzww;\n    vec4 C = p.z * c.yyxx + p.x * c.zwzw;\n    vec4 D = tau * vec4(p.yxz - p.zyx - p.xzy, p.x + p.y + p.z);\n    vec4 E = -D.yxzw;\n\n    vec4 abcd = max(max(A, B), max(C, D));\n\n    E.xy = max(E.xy, E.zw);\n    float e = max(E.x, E.y);\n\n    order(abcd.x, abcd.y);\n    order(abcd.y, abcd.z);\n    order(abcd.z, abcd.w);\n    order(abcd.w, e);\n\n    abcd.xy = max(abcd.xy, abcd.zw);\n\n    vec2 dp = psi * p.w - vec2(max(abcd.x, abcd.y), e);\n\n    float a1 = arccosh(dp.x);\n    float a2 = arccosh(dp.y);\n    float e_sdf = 0.75f * (a1 + a2 - 1.078f);\n    float v_sdf = a2 - 0.197f;\n    float d = smin(e_sdf, v_sdf, 0.005f);\n    return d;\n}\n\nfloat sdf(vec4 p)\n{\n    //return spheric_sdf(p);\n    //return face_sdf(p);\n    return edge_sdf(p);\n}\n\nvec4 raymarch(vec4 origin, vec4 ray, out float dist)\n{\n    const float eps = 0.0005f;\n    dist = -1.0f;\n\n    vec4 p = origin;\n    float d = sdf(p);\n    float t = 0.0f;\n\n    const int MAX_ITERATIONS = 64;\n\n    int i = 0;\n    while ((i < MAX_ITERATIONS) && (d > eps) && (t < 32.0))\n    {\n        t += d;\n        //float s = t;                            /* sh(t) = t + ttt/6 + ttttt/120 + ... */\n        float s = sinh(t);\n        float c = sqrt(1.0f + s * s);\n        p = c * origin + s * ray;\n        d = sdf(p);\n        ++i;\n    }\n\n    if (d < 0.05f)\n        dist = t;\n\n    return p;\n}\n\n//==============================================================================================================================================================\n//      SDF gradient :: standard 6-point evaluation\n//      Standard orthonormal basis at origin parallel translated along the geodesic into a generic point P = { x, y, z, w }\n//  looks like:\n//\n//       X = { 1.0f + (x * x) / (w + 1),        (x * y) / (w + 1),        (x * z) / (w + 1), x },\n//       Y = {        (y * x) / (w + 1), 1.0f + (y * y) / (w + 1),        (y * z) / (w + 1), y },\n//       Z = {        (z * x) / (w + 1),        (z * y) / (w + 1), 1.0f + (z * z) / (w + 1), z },\n//\n//      They are normalized, orthogonal among themselves and orthogonal to P.\n//==============================================================================================================================================================\nvec4 hyperbolic_gradient6(vec4 p)\n{\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float inv_w = 1.0f / (1.0f + p.w);\n\n    vec4 X = vec4(1.0f + inv_w * x * x,        inv_w * x * y,        inv_w * x * z, x);\n    vec4 Y = vec4(       inv_w * y * x, 1.0f + inv_w * y * y,        inv_w * y * z, y);\n    vec4 Z = vec4(       inv_w * z * x,        inv_w * z * y, 1.0f + inv_w * z * z, z);\n\n    const float eps = 0.00625f;\n\n    float di = sdf(normalize_t(p + eps * X)) - sdf(normalize_t(p - eps * X));\n    float dj = sdf(normalize_t(p + eps * Y)) - sdf(normalize_t(p - eps * Y));\n    float dk = sdf(normalize_t(p + eps * Z)) - sdf(normalize_t(p - eps * Z));\n\n    vec4 g = di * X + dj * Y + dk * Z;\n    return normalize_s(g);\n}\n\n/* distance to origin :: arccosh(2) = 1.316958 */\nconst vec4 light_ws[8] = vec4[]\n(\n    vec4(+1, +1, +1, 2),\n    vec4(+1, +1, -1, 2),\n    vec4(+1, -1, +1, 2),\n    vec4(+1, -1, -1, 2),\n    vec4(-1, +1, +1, 2),\n    vec4(-1, +1, -1, 2),\n    vec4(-1, -1, +1, 2),\n    vec4(-1, -1, -1, 2)\n);\n\n//==============================================================================================================================================================\n//   Computes direction in 4-space hyperbolic-orthogonal to P, A, and B\n//   Note: if P is time-like (e.g. represents a point), and A, B are \n// space-like (e.g. represent directions) then cross-product is also space-like, \n// so is space-like normalizable\n//==============================================================================================================================================================\nvec4 hyp_cross(vec4 P, vec4 A, vec4 B)\n{\n    /* six 2x2 minors constructed from the rows A and B */\n    vec4 det2x2_1 = A * B.yzwx - B * A.yzwx;       /* xy, yz, zw, wx */\n    vec2 det2x2_2 = A.xy * B.zw - B.xy * A.zw;     /* xz, yw */\n\n    return vec4( \n        +P.y * det2x2_1.z - P.z * det2x2_2.y + P.w * det2x2_1.y,\n        -P.z * det2x2_1.w - P.w * det2x2_2.x - P.x * det2x2_1.z,\n        +P.w * det2x2_1.x + P.x * det2x2_2.y + P.y * det2x2_1.w,\n        +P.x * det2x2_1.y - P.y * det2x2_2.x + P.z * det2x2_1.x\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.77f * (fragCoord - 0.5f * iResolution.xy) / iResolution.y;\n\n    float t = 1.7f * iTime;\n\n    float t0 = 0.375f * t -  0.213f;\n    float t1 = 0.151f * t +  2.091f;\n    float t2 = 0.253f * t - 11.512f;\n    float t3 = 0.853f * t +  3.277f;\n\n    float c0 = cos(t0);\n    float s0 = sin(t0);\n    float c1 = cos(t1);\n    float s1 = sin(t1);\n    float c2 = cos(t2);\n    float s2 = sin(t2);\n    float c3 = cos(t3);\n    float s3 = sin(t3);\n    \n    float R = 1.32f + 0.32f * c1 + 0.371f * s0;\n    float W = sqrt(1.0f + R * R);\n    vec3 camera_xyz = R * normalize(vec3(-c1 * s0, s1 *  c0 * s2, s0 * c2));\n    vec4 camera_ws = vec4(camera_xyz, W);\n\n    /* compute some random directions in 3 space, lift them to hyperboloid and \n       apply Gram-Schmidt orthogonalization process on the fly */\n\n    float r = 0.75f;                                 /* look at close to origin */\n    vec3 z = camera_xyz + r * vec3(s1 * c0, -s0 * c2, s3 *  c1 * s2); \n    vec4 Z = vec4(z, dot(camera_xyz, z) / W);        /* lift it up to hyperboloid tangent space, Z is orthogonal to camera_ws */\n    Z = normalize_s(Z);                              /* normalize */\n    \n    vec3 x = vec3(s2 * c0, -s1 * c1, c2);            /* generate some random direction */\n    vec4 X = vec4(x, dot(camera_xyz, x) / W);        /* lift it up to hyperboloid tangent space, X is orthogonal to camera_ws */\n    X = X - hyp_dot(X, Z) * Z;                       /* make it hyperbolic-orthogonal to Z, it should remain orthogonal to camera_ws */\n    X = normalize_s(X);                              /* normalize */\n\n    vec4 Y = hyp_cross(camera_ws, Z, X);             /* compute the last basis vector as a cross product */\n    Y = normalize_s(Y);                              /* normalize, should not be needed */\n\n    vec4 view_ray = uv.x * X + uv.y * Y - Z;\n    view_ray = normalize_s(view_ray);\n\n    float dist;\n    vec4 position = raymarch(camera_ws, view_ray, dist);\n    vec3 color = vec3(0.0f);\n\n    if (dist >= 0.0f && dist < 7.2f)\n    {\n        float W = position.w;\n        vec4 n = hyperbolic_gradient6(position);\n        \n        const vec3 hue = vec3(1.41f, 1.73f, 2.72f);\n        float c = 1.0 / (1.0f + 0.175f * sqrt(position.w));\n        vec3 rgb = pow(vec3(c), 4.0f * hue);\n\n        vec3 view = camera_ws.xyz - position.xyz;\n        vec4 v = vec4(view, dot(view, position.xyz) / W);\n        v = normalize_s(v);                                     /* unit view vector at tangent space at position */\n\n        color = 0.225f * rgb;                                   /* ambient */\n\n        for (int i = 0; i < 8; ++i)\n        {\n            vec4 light = light_ws[i];\n            float dp = dot(light.xyz, position.xyz);\n            float hyp_dp = W * light.w - dp;                    /* ch(distance), can be used directly for attenuation */\n\n            /* lift of the light direction to the hyperboloid */\n            vec4 l = vec4(light.xyz - position.xyz, -W + ((dp + 1.0f) / W));\n            l = normalize_s(l);                                 /* unit light vector at tangent space at position */\n\n            float a = 0.75f / (1.0f + 0.025f * hyp_dp);\n\n            float cos_theta = max(hyp_dot(l, n), 0.0f);\n            vec4 h = normalize_s(l + v);\n\n            float cos_alpha = max(hyp_dot(h, n), 0.0f);\n            vec3 diffuse  = (0.475f * cos_theta) * rgb;\n            vec3 specular = vec3(0.562f) * pow(cos_alpha, 88.0f);\n\n            color += a * (diffuse + specular);\n        }\n    }\n\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"}]}