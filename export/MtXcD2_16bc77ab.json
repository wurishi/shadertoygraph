{"ver":"0.1","info":{"id":"MtXcD2","date":"1513848862","viewed":960,"name":"cheap smooth outline","username":"nyu","description":"dirt cheap (but ugly) outline effect,\nwithout blur and synchronized with Post process AA algorithm (SMAA or FXAA) it should look fine","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["dithering","outline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLURRED\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 blur(in vec2 fragCoord )\n{\n    vec4 fragColor;\n\tvec3 c = texture(iChannel1, fragCoord.xy / iResolution.xy).rgb;\n\n\t\t\n\t\t//declare stuff\n\t\tconst int mSize = 7;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 7.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel1, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\tfragColor = vec4(final_colour/(Z*Z), 1.0);\n    return fragColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 chan0 = texture(iChannel0, uv);\n    vec3 outlineColour = vec3(0.7, 0.85, 0.0);\n    \n    if (chan0.w > 0.5) {\n#ifdef BLURRED\n        fragColor = vec4((1.0 - blur(fragCoord).xxx) * outlineColour, 1.0);\n#else\n        fragColor = vec4((1.0 - texture(iChannel1, uv).xxx) * outlineColour, 1.0);\n#endif\n        \n    } else {\n        vec3 normal = (chan0.xyz * 2.0) - 1.0;\n        vec3 phong = normalize(vec3(5.0 * sin(iTime * 0.8), 5.0 * abs(cos(iTime * 0.8)), 5.0) - vec3(0.0, 0.0, 0.0));\n        phong = (dot(phong, normal) * vec3(0.0, 0.3, 0.4)) + vec3(0.1, 0.1, 0.1);\n        fragColor = vec4(phong, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1416\n\nfloat SdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat SdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat SdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\nfloat SdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat OpU( float d1, float d2 )\n{\n\treturn min(d1, d2);\n}\n\nfloat OpS( float d1, float d2 )\n{\n    return max(-d2, d1);\n}\n\nfloat Map( vec3 pos )\n{\n    //float res = SdPlane(pos);\n    float res = SdCylinder(pos - vec3(0, 0.1, 0), vec2(0.65, 0.06));\n    res = OpU( res, SdSphere(pos - vec3(0, 1.15, 0), 0.75));\n    \n    res = OpU( res, OpS(SdBox(pos - vec3(0, 0.06, 0), vec3(0.8, 0.06, 0.8)),   \n                        SdCylinder(pos - vec3(0, 0.1, 0), vec2(0.66, 0.065))));\n    \n    res = OpU( res, OpS(SdSphere(pos - vec3(0, 1.15, 0), 1.0), \n                        OpU(SdSphere(pos - vec3(0, 1.15, 0), 0.77), \n                            SdSphere(pos - vec3(0.7, 1.6, 0.7), 0.7))));\n                        \n    return res;\n}\n\nfloat CastRay( vec3 camPos, vec3 rayDir )\n{\n    float nearClip = 0.1;\n    float farClip = 10.0;\n    \n    float dis = nearClip;\n    for(int i = 0; i < 50; i++)\n    {\n\t    float res = Map(camPos + rayDir * dis);\n        if(res < 0.001) \n            break;\n        \n        dis += res;\n        if(dis > farClip)\n        {\n            dis = 10.0;\n            break;\n        }\n    }\n    \n    return dis;\n}\n\n//---render-------------------------------------------------\nvec3 GetNormal( vec3 pos )\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(Map(pos + eps.xyy) - Map(pos - eps.xyy),\n                    Map(pos + eps.yxy) - Map(pos - eps.yxy),\n                    Map(pos + eps.yyx) - Map(pos - eps.yyx));\n\treturn normalize(nor); \n}\n\nvec4 Render( vec3 camPos, vec3 localViewDir, mat3 cam2worldMatrix, mat3 world2camMatrix )\n{\n    vec4 col;    \n    vec3 pos = camPos;\n    vec3 rayDir = cam2worldMatrix * localViewDir;\n    \n    float dis = CastRay(pos, rayDir);\n    if(dis > 0.0)\n    {\n        pos += rayDir * dis;\n\n        vec3 nor = GetNormal(pos);\n        nor = world2camMatrix * nor;\n        nor.z *= -1.0;\n\n        float zDelta = localViewDir.z;\n        zDelta *= dis / 10.0;\n        \n        col = vec4(nor, zDelta);\n    }\n    else\n    {\n        col = vec4(vec3(0.0), 1.0);\n    }\n    \n    return col;\n}\n//--------------------------------------------------------\n\nmat3 SetCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nmat3 TransposeMatrix( mat3 mat )\n{\n    return mat3(mat[0][0], mat[1][0], mat[2][0],\n               mat[0][1], mat[1][1], mat[2][1],\n               mat[0][2], mat[1][2], mat[2][2]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 camPos = vec3(3.0 * cos(7.0 * mouse.x), 1.0 + 2.0 * mouse.y, 3.0 * sin(7.0 * mouse.x));\n    vec3 camLookAt = vec3(0.0, 1.0, 0.0);\n    \n    mat3 cam2worldMatrix = SetCamera(camPos, camLookAt, 0.0);\n    mat3 world2camMatrix = TransposeMatrix(cam2worldMatrix);\n    \n    vec3 localViewDir = normalize(vec3(p.xy, 1.5));\n    \n    fragColor = Render(camPos, localViewDir, cam2worldMatrix, world2camMatrix);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define COUNT 5.0\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 ditheredSampling(in vec2 uv,in vec2 fragCoord) {\n    float radius = 0.035;\n    vec2 off = vec2(0.0, 0.0);\n    float hit = 1.0;\n    \n    for (float i = 0.0; i < COUNT; ++i) {\n        vec2 rd = vec2((rand(uv + i) * radius * sin(i)), \n                       (rand(uv - i) * radius * cos(i)));\n        off = rd;\n       \n        if (texture(iChannel0, uv + off).w < 0.5) {\n            hit -= 0.34;\n            if (hit < 0.001){\n               break;\n            }\n       }\n    }\n    \n    return vec3(uv + off, hit);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = vec4(ditheredSampling(uv, fragCoord).zzz, 1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}