{"ver":"0.1","info":{"id":"3tsSzl","date":"1563926525","viewed":986,"name":"Ditherer","username":"Myro","description":"My interpretation of the Valve's dithering method, aka a mish-mash of hornet and Zavie take on the matter.\ntheir shaders :\nhttps://www.shadertoy.com/view/MslGR8 \nhttps://www.shadertoy.com/view/4dcSRX\n\nHow and why dither :\nhttp://loopit.dk/banding_in_game","likes":3,"published":1,"flags":2,"usePreview":0,"tags":["postprocessing","dither"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// How to give the illusion of a milion colors with just a few ? dithering !\n// This is my take on implementing Valve's algorithm as described from various sources\n//\n// To my understanding, this algo adds noise patterns to the whole image and\n// then diminishes the color space. Pixels near the border between 2 colors can either\n// get the dark or the light color with the correct proportion and based on the pattern\n//\n// Inspired by\n// https://www.shadertoy.com/view/MslGR8 \n// https://www.shadertoy.com/view/4dcSRX\n// http://loopit.dk/banding_in_game\n// -------------------------------------------------------------------------------------\n\n// activate dither\n#define DITHER\n\n// How many colors do you want on the final image ? (per channel)\n#define COLORDEPTH 1.0\n\n#define GREYSCALEINPUT\n#define GREYSCALEOUTPUT\n\n// Scale of the pixels\n#define RESOLUTIONFACTOR 2.0\n\n// use a true triangle function (different kind of noise) \n#define TRUETRIANGLE\n\n// using a triangular function based noise give smoother noise repartition\n// (this is not really a triangle function, it produces a bit more noise)\n// i added the true triangle function as an option (read the pdf to understand)\nfloat remap_noise_tri_erp( const float v )\n{\n    #if ( defined TRUETRIANGLE )\n    return abs(fract(v+0.5)-0.5)+.25;\n\t#endif\n    float r2 = 0.5 * v;\n    float f1 = sqrt( r2 );\n    float f2 = 1.0 - sqrt( r2 - 0.25 );    \n    return (v < 0.5) ? f1 : f2;\n}\n\n\nvec3 ValveScreenSpaceDither(vec2 vScreenPos, float colorDepth)\n{\n    // creating the dither pattern\n    vec3 vDither = vec3( dot( vec2( 171.0, 231.0 ), vScreenPos.xy ) );\n    // shifting r,g & b channels different angles to break the repetition and smooth even more\n\tvDither.rgb = fract( vDither.rgb / vec3( 103.0, 71.0, 97.0 ) );\n    \n    //note: apply triangular pdf\n    vDither.r = remap_noise_tri_erp(vDither.r)*2.0-1.0;\n    vDither.g = remap_noise_tri_erp(vDither.g)*2.0-1.0;\n    vDither.b = remap_noise_tri_erp(vDither.b)*2.0-1.0;\n    \n    return vDither.rgb / colorDepth;\n}\n\nvec3 TextureDither(vec2 vScreenPos, float colorDepth)\n{\n    // creating the dither pattern\n    float x = mod(vScreenPos.x/iChannelResolution[1].x, float(iChannelResolution[0]));\n    float y = mod(vScreenPos.y/iChannelResolution[1].y, float(iChannelResolution[0]));\n    vec3 vDither = texture(iChannel1, vec2(x,y)/RESOLUTIONFACTOR).rrr;\n    \n    //vec3 finalColor = texture(iChannel0, fragCoord.xy/iResolution.xy).rgb// shifting r,g & b channels different angles to break the repetition and smooth even more\n\t//vDither.rgb = fract( vDither.rgb / vec3(103.0, 71.0, 97.0) );\n    \n    //note: apply triangular pdf\n    //vDither.r = remap_noise_tri_erp(vDither.r)*2.0-0.5;\n    //vDither.g = remap_noise_tri_erp(vDither.g)*2.0-0.5;\n    //vDither.b = remap_noise_tri_erp(vDither.b)*2.0-0.5;\n    \n    return (0.5-vDither);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    float colorDepth = COLORDEPTH;\n\t// downscaling the resolution so you can appreciate the effect better\n    fragCoord = floor(fragCoord /RESOLUTIONFACTOR)*RESOLUTIONFACTOR;\n    // getting pixel color from buffer\n\tvec3 finalColor = texture(iChannel2, fragCoord.xy/iResolution.xy).rgb;\n    #if defined ( GREYSCALEINPUT )\n    finalColor = finalColor.rrr;\n    #endif\n    #if defined ( DITHER )\n\t// applying dithering (left for Valve dither, right for texture dither)\n  \tif (fragCoord.x < 0.5*iResolution.x)\n    \tfinalColor += ValveScreenSpaceDither(fragCoord.xy, colorDepth);\n\telse \n    \tfinalColor += TextureDither(fragCoord.xy, colorDepth);\n    #endif\n    #if defined ( GREYSCALEOUTPUT )\n    finalColor = 0.333*vec3(finalColor.r+finalColor.g+finalColor.b);\n    #endif\n\t// limitating color depth and outputing final color\n    fragColor = vec4(finalColor,1.0);\n    fragColor = vec4(floor(finalColor * colorDepth+0.5) / colorDepth, 1.0);\n\t\t\t\t\n}","name":"Image","description":"","type":"image"}]}