{"ver":"0.1","info":{"id":"dsfXDN","date":"1668938774","viewed":204,"name":"Three Circles","username":"mla","description":"Three circles & their chords of intersection. This is quite fiddly, but seems to work.\n\nMouse moves circle 2, see header for other controls.","likes":15,"published":3,"flags":16,"usePreview":0,"tags":["circles","three"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Three Circles\n//\n// Draw three circles and their chords of intersection (segments between the\n// points of intersection of each pair). If the chords themselves intersect,\n// just show the 'external' parts of the chords.\n//\n// Finds nearest points (q0,q1,q2) on the visible part of each of the three circles.\n//\n// 'x': show chords\n// '1'-'3': show distance from q0,q1,q2\n// 'd': show distance field\n// 'r': show full circles & chords, for reference\n// 's': use 'large' radius for free circle (c2)\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Circles represented by vec3(centre,radius)\n// Lines represented as vec3(n,d) where |n| = 1 and dot(l,p) = 0 iff p lies on l.\n\n// eps is fudge to deal with points 'exactly' on the circle, which we don't\n// want to count as inside.\nbool inside(vec2 p, vec3 c, float eps) {\n  p -= c.xy;\n  return dot(p,p) <= c.z*c.z - eps;\n}\n\nbool inside(vec2 p, vec3 c) {\n  return inside(p,c,0.0);\n}\n\n// Find the radical axis of two circles, \"line of equal power\"\nvec3 axis(vec2 c, float r, vec2 d, float s) {\n  // power(p,c,r) = p² - 2p.c + c² - r²\n  // power(p,d,s) = p² - 2p.d + d² - s²\n  // So: 2p.(c-d) - (c²-r²-d²+s²) = 0\n  vec3 res = vec3(2.0*(c-d),dot(d+c,d-c)+(r-s)*(r+s));\n  return res/length(res.xy);\n}\n\nvec3 axis(vec3 c0, vec3 c1) {\n  return axis(c0.xy,c0.z,c1.xy,c1.z);\n}\n\nvec4 points(vec3 l) {\n  // Return two points on the line l, packed in a vec4\n  vec2 n = l.xy;\n  float d = l.z;\n  // want kn.n+d = 0\n  // but n is normalized\n  vec2 p0 = -d*l.xy;\n  vec2 p1 = p0+vec2(-n.y,n.x);\n  return vec4(p0,p1);\n}\n\nfloat linedistance(vec2 p, vec3 l) {\n  return dot(l,vec3(p,1));\n}\n\n// Intersect a line through points p,q with circle c\nbool intersect(vec2 p, vec2 q, vec3 c, out vec4 res) {\n  vec2 r = q-p; // direction\n  p -= c.xy;    // rebase\n  p -= dot(p,r)*r; // Now p.r = 0\n  // Want |p+tr| = c.z, so p.p + t²r.r = c.z²\n  float t = (c.z*c.z-dot(p,p))/dot(r,r);\n  if (t < 0.0) return false;\n  t = sqrt(t);\n  p += c.xy; // undo rebase\n  res = vec4(p+t*r,p-t*r);\n  return true;\n}\n\n// Intersect line l with circle c\nbool intersect(vec3 l, vec3 c, out vec4 res) {\n  vec4 pq = points(l);\n  return intersect(pq.xy,pq.zw,c,res);\n}\n\n// Closest point to p on circle c\nvec2 closest(vec2 p, vec3 c) {\n  p -= c.xy;\n  return p*c.z/length(p)+c.xy;\n}\n\n// Whichever of q or r is nearest to p\nvec2 nearest(vec2 p, vec2 q, vec2 r) {\n  if (distance(p,q) < distance(p,r)) return q;\n  else return r;\n}\n\n// q and r packed in a vec4\nvec2 nearest(vec2 p, vec4 qr) {\n  vec2 q = qr.xy, r = qr.zw;\n  return nearest(p,q,r);\n}\n\n// Projective magic\nvec2 intersectlines(vec3 l, vec3 m) {\n  vec3 p = cross(l,m);\n  return p.xy/p.z;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  float scale = 2.0;\n  vec2 mouse = vec2(0,-1);\n  vec2 p = scale*(2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n  if (iMouse.x > 0.0) mouse = scale*(2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n  float px = fwidth(length(p));\n  float lwidth = 0.01;\n  float pwidth = 3.0*lwidth;\n  vec3 c0 = vec3(-0.5,0,1);\n  vec3 c1 = vec3(0.5,0.0,1.2);\n  vec3 c2 = vec3(mouse,key(CHAR_S)?1.4:0.8);\n  \n  // Radical axes\n  vec3 a0 = axis(c0,c1), a1 = axis(c1,c2), a2 = axis(c2,c0);\n  vec4 i0,i1,i2; // Chords of intersection\n  bool b0 = intersect(a0,c0,i0), b1 = intersect(a1,c1,i1), b2 = intersect(a2,c2,i2);\n  vec2 q0 = closest(p,c0), q1 = closest(p,c1), q2 = closest(p,c2);\n  float d = 1e8;\n  vec3 col = vec3(0.8);\n  if (!key(CHAR_R)) {\n    // Show the full circles, for reference.\n    d = min(d,distance(p,q0));\n    d = min(d,distance(p,q1));\n    d = min(d,distance(p,q2));\n    if (b0) d = min(d,segment(p,i0));\n    if (b1) d = min(d,segment(p,i1));\n    if (b2) d = min(d,segment(p,i2));\n    col = 0.6+0.2*vec3(smoothstep(0.0,px,d-lwidth));\n  }\n  // d0-d2 indicate if c0-c2 should be drawn at all\n  bool d0 = true, d1 = true, d2 = true;\n  vec2 pcentre = intersectlines(a0,a1); // The \"centre of power\"!\n  d = 1e8;\n  // If the power centre is inside the circles, then we have\n  // three segments meeting at the centre.\n  if (inside(pcentre,c0)) {\n    // Get external ends of the segments\n    vec2 r0 = !inside(i0.xy,c2) ? i0.xy : i0.zw;\n    vec2 r1 = !inside(i1.xy,c0) ? i1.xy : i1.zw;\n    vec2 r2 = !inside(i2.xy,c1) ? i2.xy : i2.zw;\n    // If closest on circle is inside the others, use segment ends \n    if (inside(q0,c1) || inside(q0,c2)) q0 = nearest(p,r0,r2);\n    if (inside(q1,c2) || inside(q1,c0)) q1 = nearest(p,r1,r0);\n    if (inside(q2,c0) || inside(q2,c1)) q2 = nearest(p,r2,r1);\n    d = min(d,distance(p,q0));\n    d = min(d,distance(p,q1));\n    d = min(d,distance(p,q2));\n    if (!key(CHAR_X)) {\n      d = min(d,segment(p,pcentre,r0));\n      d = min(d,segment(p,pcentre,r1));\n      d = min(d,segment(p,pcentre,r2));\n    }\n    \n  } else {\n    // Chords of intersections of the three pairs of circles are disjoint,\n    // if they exist. Lots of cases & no obvious way to simplify.\n    if (inside(q0,c1)) {\n      if (!b0) d0 = false;\n      else q0 = nearest(p,i0);\n    }\n    if (inside(q0,c2)) {\n      if (!b2) d0 = false;\n      else q0 = nearest(p,i2);\n    }\n    if (inside(q1,c2)) {\n      if (!b1) d1 = false;\n      else q1 = nearest(p,i1);\n    }\n    if (inside(q1,c0)) {\n      if (!b0) d1 = false;\n      else q1 = nearest(p,i0);\n    }\n    if (inside(q2,c0)) {\n     if (!b2) d2 = false;\n     else q2 = nearest(p,i2);\n    }\n    if (inside(q2,c1)) {\n      if (!b1) d2 = false;\n      else q2 = nearest(p,i1);\n    }\n    if (true) {\n      // This covers the case where one circle is entirely within\n      // the other two together, but not entirely within either on its own.\n      // A cleaner solution would be nice.\n      float eps = 1e-4; // Yuk!\n      if (inside(q0,c1,eps) || inside(q0,c2,eps)) d0 = false;\n      if (inside(q1,c2,eps) || inside(q1,c0,eps)) d1 = false;\n      if (inside(q2,c0,eps) || inside(q2,c1,eps)) d2 = false;\n    }\n    \n    if (d0) d = min(d,distance(p,q0));\n    if (d1) d = min(d,distance(p,q1));\n    if (d2) d = min(d,distance(p,q2));\n    if (!key(CHAR_X)) {\n      if (b0 && !inside(i0.xy,c2)) d = min(d,segment(p,i0));\n      if (b1 && !inside(i1.xy,c0)) d = min(d,segment(p,i1));\n      if (b2 && !inside(i2.xy,c1)) d = min(d,segment(p,i2));\n    }\n  }\n  if (key(CHAR_0+1) && d0) col.r *= 0.5-0.5*cos(20.0*PI*distance(p,q0));\n  else if (key(CHAR_0+2) && d1) col.g *= 0.5-0.5*cos(20.0*PI*distance(p,q1));\n  else if (key(CHAR_0+3) && d2) col.b *= 0.5-0.5*cos(20.0*PI*distance(p,q2));\n  else if (key(CHAR_D)) col *= 0.75-0.15*cos(20.0*PI*d);\n  col *= smoothstep(0.0,px,d-lwidth);\n  col = pow(col,vec3(0.4545));\n  col = max(col,alert);\n  fragColor = vec4(col,1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.141592654;\n\nvec3 alert = vec3(0);\nvoid assert(bool b, int i) {\n  if (!b) alert[i] = 1.0;\n}\nvoid assert(bool b) {\n  assert(b,0);\n}\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  p -= a; b -= a;\n  float h = dot(p,b)/dot(b,b);\n  h = clamp(h, 0.0, 1.0);\n  return length(p-b*h);\n}\n\nfloat segment(vec2 p, vec4 ab) {\n  return segment(p,ab.xy,ab.zw);\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\nconst int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\n// const int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\nconst int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n","name":"Common","description":"","type":"common"}]}