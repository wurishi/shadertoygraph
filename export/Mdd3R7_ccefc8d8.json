{"ver":"0.1","info":{"id":"Mdd3R7","date":"1448754187","viewed":971,"name":"SunflowerTransform","username":"jt","description":"An efficient (loop-less) transformation to \"sunflower coordinates\".","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["spiral","sunflower","loopless","coordinatetransformation","vogelspiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Sunflower Transform - written 2015-11-18 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Thanks to FabriceNeyret2 for optimizations!\n\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat circ(vec2 v)\n{\n    v = fract(v)-.5;\n    return max(     smoothstep(.4, .5, length(v)), \n                (1.-smoothstep(.0, .1, abs(v.y))) * mirror(iTime*.1) );\n}\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n\tvec2 R = iResolution.xy; \n    I = 8.* (I+I-R)/R.y;\n\n    //I = vec2(0, length(I)) + fract( atan(I.y, I.x) / 2./3.1415926 );\n    I = vec2(0, length(I)) + fract( atan(I.y, I.x) / 6.283 );\n    I.x = ceil(I.y) - I.x;\n    //I.x *= I.x * (sqrt(5.)-1.)*2.;\n    I.x *= I.x * 2.4; // approximation to golden angle pi * (3-sqrt(5))\n    //I.x *= I.x * 3.1415926/(sqrt(5.)-1.);\n    //I.x *= I.x * (sqrt(5.)-1.)*2.*mirror(iTime*.01);\n    //I.x -= iTime;\n\n    O = vec4(circ(I));\n    //O = vec4(length(fract(I)-.5));\n}\n\n/*\n#define mirror(v) abs(2. * fract(v / 2.) - 1.)\n\nfloat circ(vec2 v)\n{\n    //return smoothstep(.4, .5, length(fract(v)-.5));\n    return max(smoothstep(.4, .5, length(fract(v)-.5)), (1.- smoothstep(.0, .1, abs(fract(v.y)-.5)))*mirror(iTime * .1));\n    //return smoothstep(.0, .1, abs(length(fract(v)-.5)-.4));\n    //return smoothstep(.0, .1, abs(length(fract(v)-.5)-.4)) * smoothstep(.0, .1, abs(fract(v.y)-.5));\n    //return max(smoothstep(.0, .1, abs(length(fract(v)-.5)-.4)), (1.- smoothstep(.0, .1, abs(fract(v.y)-.5)))*mirror(iTime * .1));\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n\tI = 2.*I/iResolution.xy-1.;\n    I.x *= iResolution.x / iResolution.y;\n    I *= 8.;\n    float a = fract(atan(I.y, I.x) / 2./3.1415926);\n    float b = length(I) + a;\n    I = vec2(a, b);\n    I.x = ceil(b) - I.x;\n    I.x *= I.x * (sqrt(5.)-1.)*2.;\n\n    O = vec4(circ(I));\n}\n*/","name":"Image","description":"","type":"image"}]}