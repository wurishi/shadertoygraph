{"ver":"0.1","info":{"id":"4dVyWy","date":"1523304984","viewed":333,"name":"Scrambling","username":"AntoineC","description":"A simple experiment in higher order smoothstep and motion blur.","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["motionblur","smoothstep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Pi 3.14159265359\n#define RotX(a) mat3(1.,0.,0.,0.,cos(a),sin(a),0.,-sin(a),cos(a))\n#define RotY(a) mat3(cos(a),0.,-sin(a),0.,1.,0.,sin(a),0.,cos(a))\n#define RotZ(a) mat3(cos(a),sin(a),0.,-sin(a),cos(a),0.,0.,0.,1.)\n\nfloat Smoothstep2(float t)\n{\n    return t*t*t*(10.0 + 6.0*t*t - 15.0*t);\n}\n\nfloat Smoothstep3(float t)\n{\n    float t2 = t*t;\n    float t3 = t*t2;\n    float t4 = t*t3;\n    return t4*(35.0 - 20.0*t3 + 70.0*t2 - 84.0*t);\n}\n\n\nfloat Smoothstep4(float t)\n{\n    float t2 = t*t;\n    float t3 = t*t2;\n    float t4 = t*t3;\n    float t5 = t*t4;\n    return t5*(126.0 + 70.0*t4 - 315.0*t3 + 540.0*t2 - 420.0*t);\n}\n\n\n\n    \nvec4 Sphere(vec2 uv, float eps)\n{\n    const float r = 0.8;\n\n    \n    float d = length(uv);\n    float z = d < r ? sqrt(r*r - d*d) : 0.0;\n\n    vec3 n = vec3(uv, z);\n    n = normalize(n);\n \n    float a = smoothstep(0., -eps, d - r);\n    \n    return vec4(n, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0*(fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    float eps = 1.0/iResolution.y;\n\n    // Scene:\n    vec4 na = Sphere(uv, 4.0*eps);\n\tfloat a = na.a;\n    vec3 n0 = na.xyz;\n\n    // Normal and reflection:\n    vec3 r = reflect(vec3(0.0, 0.0, -1.0), n0);\n    mat3 rot = RotY(-0.5)*RotX(-0.3);\n    r = rot*r;\n    n0 = rot*n0;\n    \n    // Shading:\n    vec3 l = normalize(vec3(-1.5, 2.0, 1.0));\n    \n    float d = dot(n0,l);\n    d = d*step(0.0,d);\n    \n    float s = dot(r,l);\n    s = pow(s*step(0.0,s), 4.0);\n    d = 0.4*d + 0.4*s;\n    \n    vec3 shd = 0.8*vec3(0.05+0.95*pow(d, 2.2));\n    \n\t// Reflection:\n  \tfloat kr = 1.7*mix(1.0, pow(1.0 - na.z, 0.9), 0.5);\n    vec3 rfl = kr*pow(texture(iChannel0, r, 4.0 ).xyz * vec3(0.95, 0.97, 1.0), vec3(1.2));\n    \n    \n    float sum = 0.0;\n    const float pass = 5.0;\n    for(float i=0.0; i<pass; i++)\n    {\n        for(float j=0.0; j<pass; j++)\n        {\n            float t = 0.1*(iTime + (pass*i+j)/(60.0*pass*pass));\n            vec2 uvs = uv + 4.0*eps*vec2(i, j)/pass;\n\n            // Global rotation:\n            mat3 rot3 = RotY(-2.0*t);\n            vec3 n = rot3*rot*Sphere(uvs, eps).xyz;\n\n\n            // Tweeners:\n            t = 3.0*t;\n            float t0 = 1.0-t*mod(floor(t), 2.0);\n            float t1 = t*mod(floor(t+1.0), 2.0);\n            t0 = Smoothstep2(fract(t0));    \n            t1 = Smoothstep2(fract(t1));    \n\n            // Segment rotations:\n            float count = 11.0;\n            vec3 nr = vec3(0);\n\n            // X-Axis:\n            nr.x = count*(1.1*(n.x + 1.0)/2.0 - 0.05);\n            //float nxi = abs(floor(nr.x) - floor(count/2.0));\n            //n = RotX(-2.0*Pi*t0*pow(nxi, 2.0)/4.0)*n;\n            float nxi = floor(nr.x) - floor(count/2.0);\n            n = RotX(-2.0*Pi*t0*sign(nxi)*pow(abs(nxi), 2.0)/4.0)*n;\n\n            // Y-Axis:\n            nr.y = count*(1.1*(n.y + 1.0)/2.0 - 0.05);\n            float nyi = abs(floor(nr.y) - floor(count/2.0));\n            n = RotY(-2.0*Pi*t1*pow(nyi, 2.0)/4.0)*n;\n            //float nyi = floor(nr.y) - floor(count/2.0);\n            //n = RotY(-2.0*Pi*t1*sign(nyi)*pow(abs(nyi), 2.0)/4.0)*n;\n\n            // Pattern:\n            nr.x = count*(1.1*(n.x + 1.0)/2.0 - 0.05);\n            nr.z = count*(1.1*(n.z + 1.0)/2.0 - 0.05);\n\n            vec3 th = 0.05*(1.0-0.7*abs(n));\n            nr = smoothstep(0.85*th, th, 0.5-abs(fract(nr)-0.5));\n\n            sum += nr.x*nr.y*nr.z;\n        }\n    }\n    sum /= pass*pass;\n    \n    float bck = length(uv)-0.6;\n    bck = 0.25*smoothstep(0.0, 0.4, bck) + 0.06*pow(length(uv), 2.0);\n    vec3 color = mix(vec3(0.4*bck), mix(shd, rfl, sum), a);\n    \n\tfloat rand = fract(sin((iTime + dot(fragCoord.xy, vec2(12.9898, 78.233))))* 43758.5453);\n    color = (floor(255.0*color) + step(rand, fract(255.0*color)))/255.0;\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}