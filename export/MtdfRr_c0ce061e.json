{"ver":"0.1","info":{"id":"MtdfRr","date":"1538502646","viewed":66,"name":"Layered House Amelia","username":"evilMia","description":"Homework 2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 houseCenter = vec2(.25, 0);\nvec2 houseSize= vec2(.5, .4);\nfloat houseLayerA = 1.0;\n\nvec2 chimneyCenter = vec2(.3, .7);\nvec2 chimneySize = vec2(.09, .1);\nfloat chimneyLayerA = 1.0;\n\nvec2 windowCenter = vec2(.35, .25);\nvec2 windowSize = vec2(.1, .15);\n\nvec2 window2Center = vec2(.55, 0);\nvec2 window2Size = vec2(.15, .25);\nfloat windowLayerA = 1.0;\n\nvec4 red = vec4(1, 0 , 0, 1);\nvec4 gray = vec4(.4, .4, .4, 1);\nvec4 green = vec4(0, 1, 0, 1);\n\n\nfloat isInRect(in vec2 uv, in vec2 corner, in vec2 size);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 background = vec4(0, 1.0-uv.y, 1.0, 1);\n    vec4 houseLayer = red;\n    vec4 chimneyLayer = gray;\n    vec4 windowLayer = green;\n    \n    float aspectRatio = iResolution.y /iResolution.x;\n    uv.y *= aspectRatio;\n    \n    houseCenter.y *= aspectRatio;\n    chimneyCenter.y *= aspectRatio;\n    windowCenter.y *= aspectRatio;\n    window2Center.y *= aspectRatio;\n\n    \n   \thouseLayer.a = houseLayerA;\n    houseLayer.a *= isInRect(uv, houseCenter, houseSize);\n    \n    chimneyLayer.a = chimneyLayerA;\n    chimneyLayer.a *= isInRect(uv, chimneyCenter, chimneySize);\n    \n    windowLayer.a = windowLayerA;\n    windowLayer.a *= (isInRect(uv, windowCenter, windowSize)+ isInRect(uv, window2Center, window2Size));\n    \n    \n    \n    vec4 composit;\n    \n    composit = mix(background, chimneyLayer, chimneyLayer.a);\n    composit = mix(composit, houseLayer, houseLayer.a);\n    composit = mix(composit, windowLayer, windowLayer.a);\n    \n    \n    // Output to screen\n    fragColor = composit;\n}\n\n\nfloat isInRect(in vec2 uv, in vec2 corner, in vec2 size){\n    float inRec = step( corner.x, uv.x)* step(uv.x, (corner.x+size.x))* step(corner.y, uv.y) *step(uv.y, corner.y+size.y);\n    \n    //inRec = float(((uv.x  > corner.x) && (uv.x < corner.x + size.x)) \n      // && ((uv.y  > corner.y) && (uv.y < corner.y + size.y)));\n        \n        \n    return inRec;\n}","name":"Image","description":"","type":"image"}]}