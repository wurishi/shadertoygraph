{"ver":"0.1","info":{"id":"lcjSRh","date":"1706037792","viewed":51,"name":"path_tracing_glsl_shadertoy","username":"alexydens","description":"path tracing","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Macro consts\n#define MAX_BOUNCES 8\n#define NUM_RAYS    8\n\n#define NUM_SPHERES 4\n\n#define PI          3.1415926535\n\n// Material\nstruct Material {\n    vec3 albedo;\n    float emissionStrength;\n    vec3 emissionColor;\n};\n\n// Sphere\nstruct Sphere {\n    float radius;\n    vec3 centre;\n    Material material;\n};\n\n// Ray\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// Hit info\nstruct HitInfo {\n    bool didHit;\n    float hitDist;\n    vec3 hitPos;\n    vec3 hitNormal;\n    Material hitMaterial;\n};\n\n// RNG\nfloat randomNumber(inout uint state) {\n    state = state * 747796405u + 2891336453u;\n    uint result = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\tresult = (result >> 22) ^ result;\n    return float(result) / 4294967295.0;\n}\n// In normal weighted distribution\nfloat randomNumberNormal(inout uint state) {\n    float theta = 2.0 * PI * randomNumber(state);\n    float rho = sqrt(-2.0 * log(randomNumber(state)));\n    return rho * cos(theta);\n}\n// A random direction\nvec3 randomDirection(inout uint state) {\n    float x = randomNumberNormal(state);\n    float y = randomNumberNormal(state);\n    float z = randomNumberNormal(state);\n    return (vec3(x, y, z));\n}\n// Random hemisphere direction\nvec3 randomHemisphereDirection(inout uint state, vec3 normal) {\n    vec3 res = randomDirection(state);\n    return res * sign(dot(normal, res));\n}\n\n// Sphere intersection\nHitInfo sphereIntersection(Sphere sphere, Ray ray) {\n    float a = dot(ray.direction, ray.direction);\n    float b = dot((2.0 * (ray.origin - sphere.centre)), ray.direction);\n    float c = dot(ray.origin - sphere.centre, ray.origin - sphere.centre) - sphere.radius * sphere.radius;\n    HitInfo hitInfo;\n    if ((b*b - 4.0*a*c) >= 0.0) {\n        hitInfo.didHit = true;\n        float t = (-b - sqrt(b * b - 4.0 * a * c)) / 2.0 * a;\n        hitInfo.hitDist = t;\n        hitInfo.hitPos = ray.origin + ray.direction * t;\n        hitInfo.hitNormal = normalize(sphere.centre - hitInfo.hitPos);\n        hitInfo.hitMaterial = sphere.material;\n    }\n    return hitInfo;\n}\n// Multiple sphere intersections\nHitInfo closestHit(Sphere spheres[NUM_SPHERES], Ray ray) {\n    HitInfo closestHit;\n    closestHit.hitDist = 100000000.0;\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        HitInfo hitInfo = sphereIntersection(spheres[i], ray);\n        if (hitInfo.didHit && hitInfo.hitDist < closestHit.hitDist)\n            closestHit = hitInfo;\n    }\n    return closestHit;\n}\n\n// Actual path tracing\nvec3 pathTracing(Sphere spheres[NUM_SPHERES], Ray ray, inout uint state) {\n    vec3 incomingLight = vec3(0.0);\n    vec3 rayColor = vec3(1.0);\n    \n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        HitInfo hitInfo = closestHit(spheres, ray);\n        if (hitInfo.didHit) {\n            ray.origin = hitInfo.hitPos;\n            ray.direction = normalize(hitInfo.hitNormal + randomDirection(state));//randomHemisphereDirection(state, hitInfo.hitNormal);\n            \n            Material material = hitInfo.hitMaterial;\n            vec3 emittedLight = material.emissionColor * material.emissionStrength;\n            incomingLight += emittedLight * rayColor;\n            rayColor *= material.albedo;\n        }\n        else {\n            break;\n        }\n    }\n    \n    return incomingLight;\n}\n\n// The test spheres\n// sphere:\n// - radius\n// - centre\n// - material\n//     - albedo\n//     - emissionStrength\n//     - emissionColor\nSphere testSpheres[NUM_SPHERES] = Sphere[NUM_SPHERES](\n    Sphere(3.50, vec3(2.2,  2.5, 6.5), Material(vec3(0.0, 0.0, 0.0), 2.5, vec3(0.9, 1.0, 0.7))),\n    Sphere(1.75, vec3(0.1, -2.0, 1.8), Material(vec3(0.6, 0.7, 0.8), 0.0, vec3(0.0))),\n    Sphere(0.25, vec3(0.4,  0.0, 1.8), Material(vec3(0.4, 0.8, 0.4), 0.0, vec3(0.0))),\n    Sphere(0.40, vec3(0.4,  0.3, 2.5), Material(vec3(0.4, 0.1, 0.8), 0.0, vec3(0.0)))\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Get previous frame color\n    vec4 prevFrame = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    // The ray\n    Ray ray;\n    \n    // Camera position\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    \n    // Ray direction\n    vec3 rayTarget = vec3((fragCoord/iResolution.xy) * 2.0 - 1.0, 1.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n    rayTarget.y /= aspectRatio;\n    ray.direction = normalize(rayTarget - ray.origin);\n    \n    // Generate seed for RNG\n    uvec2 numPixels = uvec2(iResolution.xy);\n    uvec2 pixelCoord = uvec2(fragCoord) * numPixels;\n    uint pixelIndex = pixelCoord.y * numPixels.x + pixelCoord.x;\n    uint rngState = pixelIndex * uint(iFrame);// + uint(prevFrame.x + prevFrame.y + prevFrame.z);\n            \n    // Trace multiple rays\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    for (int i = 0; i < NUM_RAYS; i++) {\n        fragColor += vec4(pathTracing(testSpheres, ray, rngState), 1.0);\n    }\n    fragColor /= float(NUM_RAYS);\n    \n    // Mix both frames\n    //fragColor = max(prevFrame, fragColor);\n    //fragColor = mix(prevFrame, fragColor, 1.0 / float(iFrame+1));\n    fragColor = (fragColor + prevFrame) / 2.0;\n}","name":"Buffer A","description":"","type":"buffer"}]}