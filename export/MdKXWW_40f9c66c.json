{"ver":"0.1","info":{"id":"MdKXWW","date":"1464522199","viewed":732,"name":"Ngon mask over persp.transform 2","username":"PeterVivo","description":"implement polygon fill :: http://alienryderflex.com/polygon/\n\nfork: https://www.shadertoy.com/view/Xd3SR8#\nprevious version: https://www.shadertoy.com/view/lsVSWW\n","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["video","interactive","mask","inversebilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//adapted from this opengl method:\n//http://stackoverflow.com/questions/16989181/whats-the-correct-way-to-draw-a-distorted-plane-in-opengl\n\n\n\n//drags from buffer\n//buffer variables\nconst int maxCount = 11;\nvec2 PP[maxCount];  //store the buffer drags values\nconst float radius = 5.0;\nconst float border = .5;\n\nconst float statePos = float(maxCount);\n#define BufA(x) texture(iChannel0, (vec2(x, 0.0) + 0.5) / iResolution.xy)\n\n// From: Iq\n// https://www.shadertoy.com/view/lsBSDm\n// given a point p and a quad defined by four points {a,b,c,d}, return the bilinear\n// coordinates of p in the quad. Returns (-1,-1) if the point is outside of the quad.\nfloat xross( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = xross( g, f );\n    float k1 = xross( e, f ) + xross( h, g );\n    float k0 = xross( h, e );\n    \n    float w = k1*k1 - 4.0*k0*k2;\n    \n    if( w<0.0 ) return vec2(-1.0);\n\n    w = sqrt( w );\n    \n    float v1 = (-k1 - w)/(2.0*k2);\n    float v2 = (-k1 + w)/(2.0*k2);\n    float u1 = (h.x - f.x*v1)/(e.x + g.x*v1);\n    float u2 = (h.x - f.x*v2)/(e.x + g.x*v2);\n    bool  b1 = v1>0.0 && v1<1.0 && u1>0.0 && u1<1.0;\n    bool  b2 = v2>0.0 && v2<1.0 && u2>0.0 && u2<1.0;\n    \n    vec2 res = vec2(-1.0);\n\n    if(  b1 && !b2 ) res = vec2( u1, v1 );\n    if( !b1 &&  b2 ) res = vec2( u2, v2 );\n    \n    return res;\n}\n\n\n// http://alienryderflex.com/polygon/\n\n    bool innerNgonFill( vec2 uv, vec2 PPi , vec2 PPj , bool isInner )\n    {\n        if (( PPi.y < uv.y && PPj.y >= uv.y || PPj.y < uv.y && PPi.y >= uv.y ) && ( PPi.x <= uv.x || PPj.x <= uv.x )) \n        {\n            if ( PPi.x + ( uv.y - PPi.y ) / ( PPj.y -PPi.y ) * ( PPj.x - PPi.x ) < uv.x ) \n            {\n                isInner=!isInner; \n            }\n        }  \n\n        return isInner;\n    }\n\n\nbool ngonFill( vec2 uv , vec2 PP[ maxCount ] )\n{\n    \n    bool  isInner = false;\n\n    // instead for \n    isInner = innerNgonFill( uv , PP[  4 ] , PP[ 10 ] , isInner ) ;        \n    isInner = innerNgonFill( uv , PP[  5 ] , PP[  4 ] , isInner ) ;\n    isInner = innerNgonFill( uv , PP[  6 ] , PP[  5 ] , isInner ) ;\n    isInner = innerNgonFill( uv , PP[  7 ] , PP[  6 ] , isInner ) ;\n    isInner = innerNgonFill( uv , PP[  8 ] , PP[  7 ] , isInner ) ;\n    isInner = innerNgonFill( uv , PP[  9 ] , PP[  8 ] , isInner ) ;\n\tisInner = innerNgonFill( uv , PP[ 10 ] , PP[  9 ] , isInner ) ;\n\n    return isInner;        \n} \n    \n\nfloat line(vec2 uv, vec2 origin, vec2 destiny, float radius){\n    destiny -= origin;\n\tfloat color = length( clamp( dot(uv-origin,destiny)/dot(destiny,destiny), 0.,1.) *destiny - uv+origin );\n    return smoothstep(color-0.0005,color+0.0005, radius);    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // read drag buffer\n    vec4 state = BufA(statePos);\n    float curr = 0.0;\n    float dist = radius + 1.0;\n    for (int i = 0; i < maxCount; ++i) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        float d = distance(fragCoord, center);\n        if (d < dist) {\n            dist = d;\n            curr = f;\n        }\n    }\n    for (int i = 0; i < maxCount; i++) {\n        float f = float(i);\n        if (f >= state.y)\n            break;\n        vec2 center = BufA(f).xy;\n        \n        //store drag values\n        PP[i] = center/iResolution.xy;\n    }\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // background\n    vec3 color = mix( texture(iChannel2, uv).rgb , vec3(.7) , vec3(1.2) ) ; //background\n   \n\n    // ngon fill\n   \tbool isMask = ngonFill( uv , PP ) ;\n\n    // distort\n    vec2 texUv = invBilinear( uv, PP[0], PP[1], PP[2], PP[3] );\n    if( texUv.x>-0.5 && isMask )\n    {        \n        color = texture( iChannel1, texUv ).xyz + mix( texture(iChannel2, texUv ).rgb , vec3(.1) , vec3(1.2) ) ;\n    }\n    \n    // darw inverse bilinear texture edges\n    \n    vec3 dotCol = vec3( .7,.7,.7 );\n    color = mix(color, dotCol , line(uv, PP[0], PP[1], .002));\n    color = mix(color, dotCol , line(uv, PP[1], PP[2], .002));\n    color = mix(color, dotCol , line(uv, PP[2], PP[3], .002));\n    color = mix(color, dotCol , line(uv, PP[3], PP[0], .002));\n    \n    // draw ngon Mask edges\n\n    dotCol = vec3( .2,.8 ,.2 );\n    color = mix(color, dotCol , line(uv, PP[4], PP[5], .002));\n    color = mix(color, dotCol , line(uv, PP[5], PP[6], .002));\n    color = mix(color, dotCol , line(uv, PP[6], PP[7], .002));    \n    color = mix(color, dotCol , line(uv, PP[7], PP[8], .002));\n    color = mix(color, dotCol , line(uv, PP[8], PP[9], .002));\n    color = mix(color, dotCol , line(uv, PP[9], PP[10], .002));\n    color = mix(color, dotCol , line(uv, PP[10], PP[4], .002));\n\n    \n    //drags\n\n    if (dist < radius) {\n        if (dist > radius - border) {\n            color = vec3( .0,.0,.0 ); // border\n        } else {\n            if (curr == state.x)\n                if (state.z > 0.0)                    \n                    color = vec3( .0,.7,.9 ); //mouse pressed\n                else\n                    color = vec3(.5,.5,.5 ); //last pressed\n            else                \n                color = vec3(.5,.5,.5 ); //standby\n        }\n    }\n\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Drag and drop framework\n// https://www.shadertoy.com/view/4dtSRn\n// by mhnewman\n//\n// maxCount := the maximum number of objects that can be represented.\n//\n// Buffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n//  * .x := the object's x coordinate.\n//  * .y := the object's y coordinate.\n//\n// Buffer pixel (maxCount, 0) := the current state.\n//  * .x := the index of the currently selected object.\n//  * .y := the number of active objects.\n//  * .z := the mouse state.\n//\n// Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\nconst int maxCount = 11;\n\nconst float radius = 50.0;\n\nconst float statePos = float(maxCount);\nconst float offsetPos = float(maxCount + 1);\n\n#define addObject(xPos, yPos) { if (p.x == count) fragColor = vec4((xPos), (yPos), 0.0, 0.0); count += 1.0; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = fragCoord - 0.5;\n    vec3 IR = iResolution;\n    \n    if (p.y > 0.0 || p.x > offsetPos) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (iFrame == 0) {\n        float count = 0.0;\n\n        // Initial conditions\n        \n        // perspective start coords\n        addObject(0.2 * IR.x+0.01, 0.1 * IR.y);\n        addObject(0.8 * IR.x, 0.2 * IR.y);\n        addObject(0.7 * IR.x, 0.7 * IR.y);\n        addObject(0.2 * IR.x, 0.87 * IR.y);\n        \n        // mask start coords\n        addObject( 0.25 * IR.x, 0.75 * IR.y);\n        addObject( 0.45 * IR.x, 0.70 * IR.y);\n        addObject( 0.49 * IR.x, 0.40 * IR.y);\n        addObject( 0.70 * IR.x, 0.45 * IR.y);        \n        addObject( 0.79 * IR.x, 0.22 * IR.y);\n        addObject( 0.22 * IR.x, 0.12 * IR.y);\n        addObject( 0.35 * IR.x, 0.30 * IR.y);\n        \n        if (p.x == statePos)\n            fragColor = vec4(2.0 * statePos, count, 0.0, 0.0);\n        return;\n    }\n    \n    vec4 state = texture(iChannel0, vec2(0.5 + statePos, 0.5) / IR.xy);\n    vec4 offset = texture(iChannel0, vec2(0.5 + offsetPos, 0.5) / IR.xy);\n\n    if (state.z <= 0.0 && iMouse.z > 0.0) {\n        float r = radius + 1.0;\n        for (int i = 0; i < maxCount; ++i) {\n            float f = float(i);\n            if (f >= state.y)\n                break;\n            vec4 center = texture(iChannel0, vec2(0.5 + f, 0.5) / IR.xy);\n            float d = distance(iMouse.xy, center.xy);\n            if (d < r) {\n                r = d;\n                state.x = f;\n                offset = center - iMouse;\n            }\n        }\n        if (r > radius) {\n            if (state.y >= statePos) {\n                state.x = 2.0 * statePos;\n            } else {\n                state.x = state.y;\n                state.y += 1.0;\n            }\n        }\n    }\n    state.z = iMouse.z;\n    \n    if (p.x == statePos) {\n        fragColor = state;\n        return;\n    }\n    \n    if (p.x == offsetPos) {\n        fragColor = offset;\n        return;\n    }\n\n    if (p.x == state.x && state.z > 0.0) {\n        fragColor = iMouse + offset;\n        return;\n    }\n    \n    fragColor = texture(iChannel0, fragCoord / IR.xy);\n}","name":"Buf A","description":"","type":"buffer"}]}