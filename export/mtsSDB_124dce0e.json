{"ver":"0.1","info":{"id":"mtsSDB","date":"1675673462","viewed":211,"name":"Fork Fur Distan inode 325","username":"inode","description":"Based on (www.shadertoy.com/view/XsfGWN),  I wanted to implement fur on a more generic distance field, The idea is to apply the deformations from the distance field to the fur density in the radial direction, and the shading from the original field.","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","distancefield","fur"],"hasliked":0,"parentid":"XsfSR8","parentname":"Fur Distance Field"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\t\n\tconst int max_iterations = 45;\n\tconst float stop_threshold = 0.001;\n\tconst float grad_step = 0.001;\n\tconst float clip_far = 4.0;\n\tconst float PI = 3.14159265359;\n\n\tconst float furDepth = 0.5;\n\tconst int furLayers = 50;\n\tconst float rayStep = furDepth * 2.0 / float(furLayers);\n\tconst float furThreshold = 0.4;\n\tconst float uvScale = 0.5;\n\n\tfloat r = 1.;\n\tfloat rotation;\n\tfloat elevation;\n\n\n\tmat3 rotX(float g) {\n\t\tg = radians(g);\n\t\tvec2 a = vec2(cos(g), sin(g));\n\t\treturn mat3(1.0, 0.0, 0.0,\n\t\t\t\t\t0.0, a.x, -a.y,\n\t\t\t\t\t0.0, a.y, a.x);\n\t}\n\t\n\tmat3 rotY(float g) {\n\t\tg = radians(g);\n\t\tvec2 a = vec2(cos(g), sin(g));\n\t\treturn mat3(a.x, 0.0, a.y,\n\t\t\t\t\t0.0, 1.0, 0.0,\n\t\t\t\t\t-a.y, 0.0, a.x);\n\t}\n\n\tvec3 map(vec3 p) {\n\t\tp.y -= elevation;\n\t\tp *= rotY(rotation);\n\t\tfloat s = (length(p) - r); // - 0.12 * sin(6. * p.x) * cos(6. * p.y)* sin(6. * p.z);\n\t\treturn vec3(s * 0.5);\t\n\t}\n\n\n\tvec2 cartesianToSpherical(vec3 p) {\t\n\t\tfloat r = length(p);\n\t\tp = normalize(p);\n\t\tfloat t = (r - (1.0 - furDepth)) / furDepth;\n\t\tp.zyx *= rotX(rotation);\n\t\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\n\t\t\n\t\tuv.y -= t * t * elevation;\n\t\t\n\t\treturn uv;\n\t}\n\n\tfloat furDensity(vec3 pos) {\n\t\tvec2 uv = cartesianToSpherical(pos.xzy);\t\n\t\tvec4 tex = textureLod(iChannel0, uv * uvScale, 0.0);\n\n\t\tfloat density = smoothstep(furThreshold, 1.0, tex.x);\n        // float density = 1.0;\n\t\n\t\tpos.y -= elevation;\n\t\tvec3 p = pos;\n\t\t// p *= rotY(rotation);\n\t\tfloat r = length(pos); //  - 0.12 * sin(6. * p.x) * cos(6. * p.y)* sin(6. * p.z);;\n\t\tfloat t = r * (r - (1. - furDepth)) / furDepth;\n\n\t\treturn density * (1. - t);\n\t\t\n\t}\n\n\tvec3 furNormal(vec3 pos, float density) {\n    \tfloat eps = 0.0001;\n    \tvec3 n;\n    \tn.x = furDensity( vec3(pos.x + eps, pos.y, pos.z)) - density;\n    \tn.y = furDensity( vec3(pos.x, pos.y + eps, pos.z)) - density;\n    \tn.z = furDensity( vec3(pos.x, pos.y, pos.z + eps)) - density;\n    \treturn normalize(n);\n\t}\n\n\n\tvec3 furShade(vec3 pos, vec3 color, vec3 light, vec3 eye, float density) {\n\t\t\n\t\tvec3 v = normalize(light - pos);\n\t\tvec3 n = furNormal(pos, density);\n\t\tvec3 ev = normalize(pos - eye);\n\t\tvec3 h = reflect(ev, n);\n\t\t\n\t\tfloat diff = max(0.0, dot(v, n)) + 0.4;\n\t\tfloat spec = pow(max(0.0, dot(v, h)), 64.);\n\n\t\tfloat r = length(pos);\n\t\tfloat t = (r - (1.0 - furDepth)) / furDepth;\n\t\tt = clamp(t, 0.3, 1.);\n\t\t\n\t\tdiff = mix(diff, 1., 0.5);\n\t\t\n\t\treturn color * t * (diff + 1.9 * spec);\n\t}\n    \n    vec3 furShade2(vec3 pos, vec3 color, vec3 light, vec3 eye, float density)\n    {\n        vec3 v = normalize(light - pos);\n\t\tvec3 n = furNormal(pos, density);\n\t\tvec3 ev = normalize(pos - eye);\n\t\tvec3 h = reflect(ev, n);\n\t\t\n\t\tfloat diff = max(0.0, dot(v, n)) + 0.4;\n        \n        float t = (r - (1.0 - furDepth)) / furDepth;\n\t\tt = clamp(t, 0.3, 1.);\n\t\t\n\t\tdiff = mix(diff, 1., 0.5);\n        \n        return vec3(diff * 0.2, 0.0, 0.0);\n    }\n\n\t\n\tvec3 gradient( vec3 v ) {\n\t\tconst vec3 delta = vec3( grad_step, 0.0, 0.0 );\n\t\tfloat va = map( v ).x;\n\t\treturn normalize (\n\t\t\tvec3(\n\t\t\t\tmap( v + delta.xyy).x - va,\n\t\t\t\tmap( v + delta.yxy).x - va,\n\t\t\t\tmap( v + delta.yyx).x - va\t\t\t\n\t\t\t)\n\t\t);\n\t}\n\n\tvec3 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\t\n\t\tfloat depth = start;\n\t\tvec3 salida = vec3(end);\n\t\tvec3 dist = vec3(0.1);\n\t\t\n\t\tfor ( int i = 0; i < max_iterations; i++ ) \t\t{\n\t\t\tif ( dist.x < stop_threshold || depth > end ) break;\n                dist = map( origin + dir * depth );\n                depth += dist.x;\n\t\t}\n\t\t\n\t\tsalida = vec3(depth, dist.y, dist.z);\n\t\treturn salida;\n\t}\n\n\tvec3 shading( vec3 v, vec3 n, vec3 eye, vec3 lightMix) {\n\t\n\t\tvec3 final = vec3( 0.0 );\n\t\tvec3 ev = normalize( v - eye );\n\t\tvec3 ref_ev = reflect( ev, n );\n\t\tvec3 light_pos   = vec3(0.0, 2.0, -2.0);\n\t\tvec3 vl = normalize( light_pos - v );\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, lightMix.x );\n\t\tfinal += vec3( 0.9 ) * ( diffuse * lightMix.y + specular * lightMix.z);\t\n\t\tfinal += vec3(0.2);\n\t\n\t\treturn final;\n\t}\n\n\tvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\t\tvec2 xy = pos - size * 0.5;\n\n\t\tfloat cot_half_fov = tan(radians( 90.0 - fov * 0.5 ));\t\n\t\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\t\treturn normalize( vec3( xy, z ) );\n\t}\n\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t{\t\t\t\n        rotation = 20. * (iTime);\n        elevation = 0.25; // * cos(iTime * 2.5);\n\n\t\tvec3 rd = ray_dir(60.0, iResolution.xy, fragCoord.xy );\n\t\t\n\t\tvec3 eye = vec3( .0, .0, -2.8 );\n\t\t\t\n\t\tvec3 lightMix = vec3(6., 0.45, 0.15);\n\t\tvec3 color = vec3(0.);\n\n\t\tvec3 data = ray_marching( eye, rd, 0.0, clip_far );\n\t\tif ( data.x < clip_far ) {\n\t\t\t\n\t\t\tvec3 pos = eye + rd * data.x;\n\t\t\tvec3 n = gradient( pos );\n\t\t\t\n\t\t\tvec3 lightColor =  shading( pos, n, eye, lightMix) * 2.0;\t\t\t\n\t\t\tcolor = vec3(1.0) * lightColor;\n\t\t\t\t\n\t\t\tvec4 c = vec4(0.0);\n\t\t\t\n\t\t\tfor(int i=0; i<furLayers; i++) {\n\t\t\t\tvec4 sampleCol;\n\t\t\t\tsampleCol.a = furDensity(pos);\n\t\t\t\tif( c.a > 0.99 ) break;\n\t\t\t\tif (sampleCol.a > 0.) {\n\t\t\t\t\tsampleCol.rgb = sampleCol.a * furShade(pos, vec3(85., 72., 56) * lightColor / 255., vec3(0.0, 2.0, -2.0), eye, sampleCol.a);\n\t\t\t\t\tc = c + sampleCol * (1.0 - c.a);\n\t\t\t\t}\n\t\t\t\tpos += rd * rayStep;\n\t\t\t}\n\t\t\t\n\t\t\tcolor = c.xyz;\n\t\t}\n\t\t\t\n\t\tfragColor = vec4(2. * color, 1.0 );\n\t} ","name":"Image","description":"","type":"image"}]}