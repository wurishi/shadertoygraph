{"ver":"0.1","info":{"id":"Xdy3WV","date":"1456349597","viewed":196,"name":"Battered Orb","username":"piratehurrdurr","description":"Trying to batter a ball. There is minor distortion. Does someone know how to do this without any distortion?","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IT 256\n#define MAX 2.0\n#define EP 1e-4\n#define EPN 1e-4\n#define PI 3.14159256\n#define E 2.71828182845904523536028747135266249775724709369995\n\nvec3 amb(vec3 dir) {\n\n    vec3 skyBase = vec3(0.6, 0.8, 0.9)*(1.0+0.6*dot(dir, vec3(0.0,0.0,-1.0)));\n    float sunStr = pow(max(1.05* dot(dir, normalize(vec3(1.0,1.0,1.0))),0.0),6.0);\n\tvec3 skySun = vec3(0.5,0.5,0.2)*sunStr;\n    \n    \n    vec3 bot = vec3(0.4,0.2,0.15);\n    vec3 sky = skySun+skyBase;\n    \n    return mix(bot, sky, dot(vec3(0.0,0.0,1.0),dir)/2.0+0.5);\n    \n}\n\nvec3 ambSharp(vec3 dir) {\n\n    vec3 skyBase = vec3(0.6, 0.8, 0.9)*(1.0+0.6*dot(dir, vec3(0.0,0.0,-1.0)));\n    float sunStr = pow(max(1.05* dot(dir, normalize(vec3(1.0,1.0,1.0))),0.0),6.0);\n\tvec3 skySun = vec3(0.5,0.5,0.2)*sunStr;\n    \n    vec3 sky = skySun+skyBase;\n    \n    if (dir.z<0.0) {\n        \n        float d = 2.0/dir.z;\n        dir *= d;\n        \n        float effect = 1.0/d;\n        \n        float fog = 1.0- 1.0/(1.1-d*0.005);\n        //fog = 0.0;\n\n        //fog = clamp(fog,0.0,1.0);\n        vec3 bot = vec3(0.4,0.2,0.15)* (1.0+(0.5+texture(iChannel2,dir.xy/8.0).rgb)/d);\n        \n        return bot+(sky-bot)*fog;\n        \n        //return mix(, sky, fog);\n    }\n    \n    return sky;\n    \n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\n\n\nfloat dist(vec3 pos) {\n    \n    float scale =0.5;\n    float scale2 =0.7;\n    float strength = -0.08;\n    float strength2 = 0.11;\n    \n    vec3 texPos = pos*scale+vec3(1.0);\n    vec3 npos = normalize(pos);\n    \n    float ex, ey, ez;\n    ex = abs(dot(vec3(1.0,0.0,0.0),npos));\n    ey = abs(dot(vec3(0.0,1.0,0.0),npos));\n    ez = abs(dot(vec3(0.0,0.0,1.0),npos));\n    \n    strength /= ex+ey+ez;\n    \n    float modify = texture(iChannel0,texPos.xy).r*ez;\n    modify+= texture(iChannel0,texPos.xz).r*ey;\n    modify+= texture(iChannel0,texPos.yz).r*ex;\n    \n    \n    texPos = pos*scale2;\n    texPos+=vec3(0.5);\n    ez*=strength2;\n    ey*=strength2;\n    ex*=strength2;\n    modify+= texture(iChannel2,texPos.xy).r*ez;\n    modify+= texture(iChannel2,texPos.xz).r*ey;\n    modify+= texture(iChannel2,texPos.yz).r*ex;\n    \n    \t\n\treturn sphere(pos, 0.5+modify*strength);\n}\n\n\nvec3 scan(vec3 pos, vec3 dir) {\n    \n    float totalDistance=0.0;\n    for (int i=0; i<IT; i++) {\n        float rayDist = dist(pos);\n        totalDistance+=rayDist;\n        if (rayDist<=EP) {\n            \n            vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(pos + eps.yxx) - dist(pos - eps.yxx),\n    \t\tdist(pos + eps.xyx) - dist(pos - eps.xyx),\n    \t\tdist(pos + eps.xxy) - dist(pos - eps.xxy)));\n            \n            vec3 reflDir = reflect(dir, normal);\n            \n            //return amb(reflDir);\n            float fres = abs(dot(dir,normal));\n            return vec3(0.85,0.75,0.2)*mix(amb(reflDir), amb(normal),1.0-fres);\n        }\n        if (totalDistance>=MAX) {\n            return ambSharp(dir);\n        }\n        pos+=dir*(rayDist);\n    }\n    \n    \n    return ambSharp(dir);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 uv){\n    uv = (uv-iResolution.xy/2.0)/iResolution.y;\n    float a = iTime*0.125;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.y/1.1;\n    mouse.y+=0.05;\n    \n    //vec3 pos = vec3(cos(a/4.0+sin(a/2.0)),cos(a*0.2),sin(a*0.31)/4.5+1.0)*3.0;\n    vec3 pos = vec3(cos(mouse.x*PI*2.0),sin(mouse.x*PI*2.0),0.0);\n    pos*=cos(mouse.y*PI+PI/2.0);\n    pos.z = sin(mouse.y*PI+PI/2.0);\n    pos = normalize(pos)*2.0;\n    vec3 on = vec3(1.0,uv.x,uv.y);\n    vec3 n = pos;\n\n    //n = normalize(pos + (0.1*vec3(cos(a*2.3),cos(a*2.61),cos(a*1.62))));\n\tvec3 crossRight = normalize( cross(n,vec3(0.0,0.0,1.0)));\n\tvec3 crossUp = normalize(cross(n, crossRight));\n\tn = n*0.5 + crossRight*uv.x + crossUp*uv.y;\n    \n    fragColor.rgb = sqrt(scan(pos,-normalize(n)).rgb);\n}","name":"Image","description":"","type":"image"}]}