{"ver":"0.1","info":{"id":"XlSGzt","date":"1431205706","viewed":156,"name":"Basic Reflection Test","username":"resonance","description":"Just testing some basic stuff.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","reflection","csg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/* Victor Franco (resonance) */\n\n#define FAR 50.0\n#define EPS 0.001\n#define STEPS 256\n\n#define PI    3.14159265359\n#define TWOPI 6.28318530718\n\nstruct Inter {\n\tint id;\n\tfloat dist;\n};\n\nInter iCilindroZ(int id, vec3 p, float s) {\n \treturn Inter (id, length(p.xy) - s);   \n}\n\nInter iSphere(int id, vec3 p, float s) {\n \treturn Inter (id, length(p) - s);\n}\n\nInter iCube(int id, vec3 p, float s) {\n \treturn Inter(id, length(max(abs(p) - s, 0.0)));   \n}\n\nInter opU(in Inter a, in Inter b) {\n \treturn a.dist > b.dist ? b : a;   \n}\n\nInter opS(in Inter a, in Inter b) {\n\tb.dist = -b.dist;\n    return a.dist > b.dist ? a : b;\n}\n\nInter map(vec3 p) {\n    vec3 pCubos  = p;\n    vec3 pCubos2 = p;\n    \n    float t  = iTime * 0.075 + 0.5 * TWOPI * pCubos.z/FAR;    \n    float t2 = iTime * 0.075 + 0.5 * TWOPI * pCubos.x/FAR;\n    \n    pCubos.xy += 18.0 * vec2(cos(t), sin(t));    \n    pCubos.xy = mod(pCubos.xy, 10.0) - 5.0;\n    pCubos.z  = mod(pCubos.z,  1.25) - 0.625;\n    \n    pCubos2.xy += 18.0 * vec2(cos(t), sin(t));    \n    pCubos2.zy = mod(pCubos2.zy, 10.0) - 5.0;\n    pCubos2.x  = mod(pCubos2.x,  1.25) - 0.625;\n    \n    vec3 pEsfera = p;\n    pEsfera.z += -5.2;\n    \n \treturn opU(\n        iSphere(1, pEsfera, 1.0),\n        opS(opU(iCube(2, pCubos,  1.0),\n                iCube(2, pCubos2, 1.0)),\n        \tiSphere(3, pEsfera, 1.8)\n        \t));\n}\n\nvec3 colorize(Inter inter) {\n    if (inter.id == 1) return vec3(0.3, 0.4, 0.6);\n    if (inter.id == 2) return vec3(0.4);\n    if (inter.id == 3) return vec3(0.0);\n    return vec3(1.0);\n}\n\nvec3 normals(vec3 p) {\n \tvec2 e = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).dist - map(p - e.xyy).dist,\n        map(p + e.yxy).dist - map(p - e.yxy).dist,\n        map(p + e.yyx).dist - map(p - e.yyx).dist));\n}\n\nbool raymarch(out Inter inter, in vec3 ro, in vec3 rd) \n{\n    Inter deltaInter;  // InterseÃ§Ã£o temporÃ¡ria do ponto de\n                       // marching atÃ© o objeto\n    \n    float dist;        // DistÃ¢ncia real do 'ro' atÃ© o objeto\n    \n    // Intersecta\n    for (int i = 0; i < STEPS; i++) {\n        deltaInter = map(ro + dist * rd);\n\n        // Caso passemos da distÃ¢ncia mÃ¡xima, para o loop\n        if (dist > FAR)\n            break;\n        \n        // Caso ocorra colisÃ£o, move as informaÃ§Ãµes da interseÃ§Ã£o\n        // temporÃ¡ria para a interseÃ§Ã£o final e retorna verdadeiro\n        if (deltaInter.dist < EPS)\n        {\n            inter.id   = deltaInter.id;\n            inter.dist = dist;\n            return true;\n        }\n        \n        dist += deltaInter.dist;\n    }\n    \n    // Retorna que nÃ£o foi possÃ­vel encontrar uma interseÃ§Ã£o\n\treturn false;\n}\n\nvec3 renderPixel(in vec2 coord)\n{\n    // PosiÃ§Ã£o da colisÃ£o e cor da colisÃ£o\n\tInter inter;\n    vec3 col = vec3(0.0);\n    \n    // Coordenadas do plano\n    vec2 uv = 1.0 - 2.0 * (coord.xy / iResolution.xy);\n         uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 ro = vec3(0.0);\n    \n    // Se acontecer raymarching\n    float realDist;\n    \n    for (int i = 0; i < 3; i++) {\n        // Realiza o raymarching\n        if (!raymarch(inter, ro, rd))\n        \tbreak;\n       \n        if (i == 0)\n            realDist = inter.dist;\n        \n        // PosisÃ£o de colisÃ£o e normal\n        vec3 pos = ro + rd * (inter.dist - EPS);\n        vec3 normal = normals(pos);\n        \n        // Pinta\n        if (i == 0)\n            col = colorize(inter);\n        else\n        \tcol += 0.2 * colorize(inter);\n        \n        //if (inter.id == 1)\n        //    break;\n        \n        // Muda o referencial para o ponto de colisao\n\n        ro = pos;\n        rd = reflect(rd, normal);\n    }\n    \n    col = mix(col, vec3(1.0), realDist/FAR);\n    return realDist == 0.0 ? vec3(1.0) : col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 e = vec2(0.5, 0.0);\n    \n    // 2x multisampling;\n  \tvec3 col = renderPixel(fragCoord + e.xx)\n             + renderPixel(fragCoord + e.xy);\n    \n\tfragColor = vec4(col/2.0, 1.0);\n}\n    \n    ","name":"","description":"","type":"image"}]}