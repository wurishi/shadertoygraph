{"ver":"0.1","info":{"id":"cllXzl","date":"1675210527","viewed":85,"name":"Procedural texels - azavier","username":"azavier","description":":)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 50.\n\n#define sat(a) clamp(a, 0., 1.)\n\n#define PI 3.1415926\n\nmat2x2 rot(float a) {\n  float c = cos(a), s = sin(a);\n  return mat2x2(c, -s, s, c);\n}\n\nfloat sdf(in vec3 p) {\n  float d = FAR;\n  \n  float sphere = length(p) - 1.;\n  d = min(d, sphere);\n  \n  return d;\n}\n\nvec3 normal(in vec3 p, in float d) {\n  vec2 dt = vec2(0.01, 0);\n  vec3 grad = vec3(\n    sdf(p-dt.xyy),\n    sdf(p-dt.yxy),\n    sdf(p-dt.yyx)\n  );\n  \n  return normalize(sdf(p) - grad);\n}\n\nfloat trace(in vec3 ro, in vec3 rd) {\n  float dis = 0.;\n  \n  float sdis;\n  for(int i = 0; dis < FAR && i < 150; i++) {\n    sdis = sdf(ro + rd*dis);\n    \n    if(abs(sdis) < 0.001)\n      break;\n      \n    dis += sdis;\n  }\n  \n  return dis;\n}\n\nvec3 getbg(in vec3 rd) {\n  vec3 sunp = normalize(vec3(0.7,0.5,-1));\n  sunp.yx *= rot(iTime*0.2);\n\n  vec3 skyc = mix(vec3(1.,0.82,0.21), vec3(0.15,0.5,0.9), smoothstep(0.05, 0.3, sunp.y));\n  skyc = mix(vec3(0.08,0.19,0.32), skyc, smoothstep(-0.2, 0.05, sunp.y));\n  vec3 horizon = mix(vec3(1.,0.93,0.29), vec3(0.6,0.8,0.9), smoothstep(0.05, 0.3, sunp.y));\n  horizon = mix(vec3(0.31,0.41,0.52), horizon, smoothstep(-0.1, 0.05, sunp.y));\n  \n  skyc += mix(vec3(0), 3.*horizon, smoothstep(0.995, 1., dot(rd, sunp)));\n  \n  vec3 ground = vec3(0.3,0.34,0.4);\n  ground = mix(ground, vec3(0.01,0.14,0.2), -rd.y);\n  \n  vec3 sky = mix(horizon, skyc, smoothstep(0.04, 0.7, rd.y+sat(sin(rd.y*rd.x*rd.z+iTime*0.4))));\n  \n  vec3 bg = mix(ground, sky, smoothstep(0., 0.015, rd.y));\n  \n  float horizonIntensity = mix(1.3, 1.9, smoothstep(0.1, 0., sunp.y));\n  bg *= mix(vec3(1), horizonIntensity*horizon, smoothstep(0.05, 0., abs(rd.y)));\n  \n  return bg;\n}\n\nvec3 getTexel(in vec3 ro, in vec3 rd, in float dist) {\n  vec3 tex = vec3(0.6);\n  \n  vec3 p = ro + rd*dist;\n  vec3 n = normal(p, dist);\n  \n  vec3 spot = vec3(1,0,0);\n  vec3 spotdir = vec3(1,0,0);\n  \n  float t0 = smoothstep(0.8, 1., abs(dot(n, spotdir)));\n  tex *= mix(vec3(1), spot, t0);\n  \n  spot = vec3(0,1,0);\n  spotdir = vec3(0,1,0);\n  \n  t0 = smoothstep(0.8, 1., abs(dot(n, spotdir)));\n  tex *= mix(vec3(1), spot, t0);\n  \n  spot = vec3(0,0,1);\n  spotdir = vec3(0,0,1);\n  \n  t0 = smoothstep(0.8, 1., abs(dot(n, spotdir)));\n  tex *= mix(vec3(1), spot, t0);\n  \n  return tex;\n}\n\nvec3 pixCol(in vec2 uv) {\n  vec3 pixelColor;\n  /// Gracefully stolen from https://www.shadertoy.com/view/tlKSzK\n  float orbit = -2.*PI*iMouse.x/iResolution.x;\n  vec3 ro;\n  if(iMouse.z > 0.)\n    ro = vec3(sin(PI - orbit)*5.1, 1. - 2.*iMouse.y/iResolution.y, cos(PI - orbit)*5.1);\n  else\n    ro = vec3(sin(iTime), cos(iTime), 5.);\n  ///\n  vec3 foc = vec3(0);\n  \n  vec3 fwd = normalize(foc - ro);\n  vec3 rgt = normalize(cross(vec3(0,1,0), fwd));\n  vec3 up = cross(rgt, fwd);\n  \n  vec3 rd = normalize((uv.x*rgt + uv.y*up)*1.2 + fwd);\n  \n  float sd = trace(ro, rd);\n  \n  if(sd < FAR)\n    pixelColor += getTexel(ro, rd, sd);\n  else\n    pixelColor += getbg(rd);\n  \n  return pixelColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n  uv.y *= -1.;\n  vec3 col;\n  \n  col += pixCol(uv);\n  \n  fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}