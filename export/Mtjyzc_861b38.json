{"ver":"0.1","info":{"id":"Mtjyzc","date":"1509651019","viewed":351,"name":"integration: golden vs VDC","username":"hornet","description":"analyzing results from // https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\nuniform sampling vs golden ratio sampling vs van der corput sequence\nLMB controls number of samples - best analyzed in fullscreen","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sampling","integration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//gold: avg of noise + N golden ratios\n//blue: avg of noise + i/N (van der corput ordering)\n//green: avg of noise + i/N (uniform)\n\n// https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\nconst float gr = (1.0 + sqrt(5.0)) / 2.0;\nfloat GoldenRatioMultiple( int multiple )\n{\n    return float(multiple) * gr;\n}\n\n//note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nconst vec4 RED   = vec4(1.0,0.2,0.1,1.0);\nconst vec4 GREEN = vec4(0.5,1.0,0.3,1.0);\nconst vec4 BLUE  = vec4(0.1,0.3,1.0,1.0);\nconst vec4 BLACK = vec4(0.0,0.0,0.0,1.0);\nconst vec4 GOLD  = vec4(1.0,0.7,0.1,1.0);\n\nvoid mainImage( out vec4 oc, in vec2 fc )\n{\n\tvec2 uv = fc.xy / iResolution.xy;\n    int idx = int( floor( 4.0 * uv.y ) );\n    \n    const int NUM_SAMPLES = 8;\n\tconst float RCP_NUM_SAMPLES_F = 1.0  / float(NUM_SAMPLES);\n\n    int sample_limit = int( 8.0 * uv.x ) + 1;\n    if ( iMouse.z > 0.5 )\n    {\n        sample_limit = int(8.0*iMouse.x/iResolution.x)+1;\n        if ( uv.y > 0.9875)\n        {\n            oc = vec4(vec3(step(uv.x-float(sample_limit)/float(NUM_SAMPLES), 0.0)), 1.0 ); return;\n        }\n    }\n\n    float rcp_sample_limit = 1.0 / float(sample_limit);\n    \n    vec2 seed = 101.0 * uv;\n    \n    float sum = 0.0;\n    for ( int i=0; i<NUM_SAMPLES; ++i )\n    {\n        if ( i >= sample_limit )\n            break;\n\n        if ( idx == 3 )\n        {\n            //note: (truncated) uniform offset per sample - assuming max_samples, but getting fewer\n            if ( uv.x < 0.006125 ) { oc=RED; return; }\n            float rnd = hash12n( seed );\n\n            float ofs = float(i) / float(NUM_SAMPLES);\n            //ofs += hash12n( vec2(i) ) / float(sample_limit); //note: uniform-step sized random offset\n            rnd = fract( rnd + ofs );\n\n            sum += rcp_sample_limit * rnd;\n        }\n        if ( idx == 2 )\n        {\n            //note: uniform offset per sample\n            if ( uv.x < 0.006125 ) { oc=GREEN; return; }\n            float rnd = hash12n( seed );\n\n            float ofs = float(i) / float(sample_limit);\n            //ofs += hash12n( vec2(i) ) / float(sample_limit); //note: uniform-step sized random offset\n            rnd = fract( rnd + ofs );\n\n            sum += rcp_sample_limit * rnd;\n        }\n        else if ( idx == 1 )\n        {\n            //note: uniform, but van der corput ordering\n            if ( uv.x < 0.006125 ) { oc=BLUE; return; }\n            float rnd = hash12n( seed );\n\n            //note: as good as uniform for exactly 2^n samples\n            const float van_der_corput16[16] = float[16] (0.0, 1.0/2.0, 1.0/4.0, 3.0/4.0, 1.0/8.0, 5.0/8.0, 3.0/8.0, 7.0/8.0, 1.0/16.0, 9.0/16.0, 5.0/16.0, 13.0/16.0, 3.0/16.0, 11.0/16.0, 7.0/16.0, 15.0/16.0 );\n\t\t\tfloat ofs = van_der_corput16[ (i<16) ? i : (i-16) ];\n            \n            rnd = fract( rnd + ofs );\n            sum += rcp_sample_limit * rnd;\n        }\n        else if ( idx == 0 )\n        {\n            //note: average using golden ratio offset per sample\n            if ( uv.x < 0.006125 ) { oc=GOLD; return; }\n            float rnd = hash12n( seed );\n            float grm = GoldenRatioMultiple( i ); \n            rnd = fract( rnd + grm );\n            sum += rcp_sample_limit * rnd;\n        }\n    }\n    \n    oc  = vec4( vec3(sum), 1.0 );\n    \n    //lines\n\tif ( iMouse.z < 0.5 )\n    \toc *= step( 16.0/iResolution.x, 1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n    \n    oc *= step( 6.0/iResolution.y, 1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n\n}\n","name":"Image","description":"","type":"image"}]}