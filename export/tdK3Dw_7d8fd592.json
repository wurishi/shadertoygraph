{"ver":"0.1","info":{"id":"tdK3Dw","date":"1570368402","viewed":250,"name":" Test of \"bleeding\" color v2","username":"jorge2017a1","description":" Test of \"bleeding\" color\nhttps://www.shadertoy.com/view/XdSXWR","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["testofbleedingcolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created by predatiti in 2015-01-06\n///https://www.shadertoy.com/view/XdSXWR\n//mnodificado por jorge2017a1--5--oct-2019\n//mover con el mouse!!!\n\nconst float t = 16.0;//nr. sample per pixel\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[4];\nBox boxe[15];\nCylinder cylinder[4];\n//Material material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 cub, lcub;\nvec2 uvCoord;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time ;\nfloat f0, f1,f2,f3;\nvec2 cw = vec2(-0.4,0.1);\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) ;   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y-cylinder.c.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\t/*s = (cylinder.h - ro.y+cylinder.c.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}*/\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    //nor.y = 1.0*sign(hit.y-cylinder.c.y);\n    return nor;\n}\n\nvoid initscene()\n{\n    box0.min = vec3(-2.0, -1.2, -2.0);//room\n   \tbox0.max = vec3( 2.0,  1.2,  2.0);\n    \n    light = vec3(cos(time *0.0)*1.65-0.5, sin(time*0.0)*0.65+0.7, sin(time*0.5)*1.65);\n\n    float h = sin(time*3.0)*0.03;\n    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;\n    sfere[0].center_radius = vec4( 0.0, h-0.3, 0.0,    0.523);//rosu\n   \tsfere[1].center_radius = vec4( 0.0, h-0.29, 0.0,    0.520);//verde\n   \tsfere[2].center_radius = vec4(sinr, h+0.1,cosr,    0.123);//albastru\n    \n    vec3 center = vec3(0.8,-0.8,-1.6); \n    cylinder[0].c = vec3( 0.55,0.0, 0.25) + center;\n    cylinder[0].r = 0.04;\n    cylinder[0].h = 0.4;\n    \n    cylinder[1].c = vec3( 0.55,0.0,-0.25) + center;\n    cylinder[1].r = 0.04;\n    cylinder[1].h = 0.4;\n    \n    cylinder[2].c = vec3(-0.55,0.0, 0.25) + center;\n    cylinder[2].r = 0.04;\n    cylinder[2].h = 0.4;\n    \n    cylinder[3].c = vec3(-0.55,0.0,-0.25) + center;\n    cylinder[3].r = 0.04;\n    cylinder[3].h = 0.4;\n\n   \tcenter = vec3(-1.55,-0.2, 0.5);\n    cub = vec3(0.0, 0.0, 0.0) + center;//corp dulap\n    lcub = vec3(0.4, 1.0, 0.8);    \n   \tboxe[0].min = cub - lcub;\n   \tboxe[0].max = cub + lcub;\n    \n   \tcub = vec3(0.5, 0.0, +0.0) + center;//fanta\n   \tlcub = vec3(0.12, 0.98, 0.01);\n   \tboxe[1].min = cub - lcub;\n   \tboxe[1].max = cub + lcub;\n    \n   \tcub = vec3(0.02, 0.99, 0.0) + center;//plafon\n   \tlcub = vec3(0.43, 0.015, 0.85);\n   \tboxe[2].min = cub - lcub;\n   \tboxe[2].max = cub + lcub;   \n    \n   \tcub = vec3( 0.380, 0.0, 0.385) + center;//oglinda dreapta\n   \tlcub = vec3(0.03, 0.77, 0.18);    \n   \tboxe[3].min = cub - lcub;\n   \tboxe[3].max = cub + lcub;\n    \n   \tcub = vec3(0.385, 0.0, -0.385) + center;//oglinda stanga\n   \tlcub = vec3(0.03, 0.77, 0.18);\n   \tboxe[4].min = cub - lcub;\n   \tboxe[4].max = cub + lcub;\n\n   \tcub = vec3(0.41, 0.0, 0.06) + center;//maner dreapta\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[5].min = cub - lcub;\n   \tboxe[5].max = cub + lcub;\n\n   \tcub = vec3(0.41, 0.0, -0.06) + center;//maner stanga\n   \tlcub = vec3(0.021, 0.1, 0.01);\n   \tboxe[6].min = cub - lcub;\n   \tboxe[6].max = cub + lcub;\n\n   /*\tcub = vec3(0.0, 0.0, 0.0) + center;//bbox\n   \tlcub = vec3(0.47, 1.2, 0.87);\n   \tboxe[7].min = cub - lcub;\n   \tboxe[7].max = cub + lcub;*/\n//dulap\n\n//birou\n\tcenter = vec3(0.8,-0.8,-1.6);\n   \tcub = vec3( 0.0, 0.4, 0.0) + center;//tablie\n   \tlcub = vec3(0.65, 0.015, 0.35);\n   \tboxe[7].min = cub - lcub;\n   \tboxe[7].max = cub + lcub;\n\n//scaun\n   \tcub = vec3(-0.0, 0.1, 0.5) + center;//tablie\n   \tlcub = vec3(0.25, 0.015, 0.25);\n   \tboxe[8].min = cub - lcub;\n   \tboxe[8].max = cub + lcub;\n\n   \tcub = vec3(-0.22, -0.15, 0.28) + center;//picior stanga fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[9].min = cub - lcub;\n   \tboxe[9].max = cub + lcub;\n\n   \tcub = vec3( 0.22, -0.15, 0.28) + center;//picior dreapta fata\n   \tlcub = vec3(0.03, 0.25, 0.03);\n   \tboxe[10].min = cub - lcub;\n   \tboxe[10].max = cub + lcub;\n\n   \tcub = vec3( 0.22, 0.2,  0.72) + center;//picior dreapta spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[11].min = cub - lcub;\n   \tboxe[11].max = cub + lcub;\n\n   \tcub = vec3(-0.22, 0.2,  0.72) + center;//picior stanga spate\n   \tlcub = vec3(0.03, 0.60, 0.03);\n   \tboxe[12].min = cub - lcub;\n   \tboxe[12].max = cub + lcub;\n\n   \tcub = vec3(-0.0, 0.6,  0.74) + center;//spatar\n   \tlcub = vec3(0.25, 0.10, 0.01);\n   \tboxe[13].min = cub - lcub;\n   \tboxe[13].max = cub + lcub;\n    \n    cub = vec3(-0.4,-0.87,  1.9) ;//calorifer\n   \tlcub = vec3(0.55, 0.3, 0.06);\n   \tboxe[14].min = cub - lcub;\n   \tboxe[14].max = cub + lcub;\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i, bool bl)\n{\n    float tSphere6 = intersectSphere(ro, rd, sfere[3]);\n    if(tSphere6 < t && bl) { t = tSphere6;i=6;}\n\n   \t/*float tSphere = intersectSphere(ro, rd, sfere[0]);\n    if(tSphere < t) { t = tSphere;i=0;}\n   \ttSphere = intersectSphere(ro, rd, sfere[1]);\n    if(tSphere < t) { t = tSphere;i=1;}\n   \ttSphere = intersectSphere(ro, rd, sfere[2]);\n    if(tSphere < t) { t = tSphere;i=2;}\n\t*/\n    \n    \n\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    if(tcyl<t) {t = tcyl; i = 10;}\n    tcyl = iCylinder(ro, rd, cylinder[1]);\n    if(tcyl<t) {t = tcyl; i = 11;}\n    tcyl = iCylinder(ro, rd, cylinder[2]);\n    if(tcyl<t) {t = tcyl; i = 12;}\n    tcyl = iCylinder(ro, rd, cylinder[3]);\n\tif(tcyl<t) {t = tcyl; i = 13;}\n    \n\tvec2 tboxc = intersectCube(ro, rd, boxe[0]); \n    if(tboxc.x>0.0 && tboxc.x<tboxc.y && tboxc.x < t) {t = tboxc.x; i = 20;}\n    vec2 tboxf = intersectCube(ro, rd, boxe[1]); \n    //if(tboxf.x>0.0 && tboxf.x<tboxf.y && tboxf.x < t) {t = tboxf.x; i = 21;}\n    vec2 tbox = intersectCube(ro, rd, boxe[2]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 22;}\n    tbox = intersectCube(ro, rd, boxe[3]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 23;}\n    tbox = intersectCube(ro, rd, boxe[4]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 24;}\n    tbox = intersectCube(ro, rd, boxe[5]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 25;}    \n    tbox = intersectCube(ro, rd, boxe[6]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 26;} \n\n    float t1 = 200000.0;\n    float t2 = 200000.0;  \n    if(tboxf.x>0.0 && tboxf.x<tboxf.y) {t1 = tboxf.y; t2=tboxf.x;}\n    if(t1>t && t2<t && i==20) {t=t1; i=21;}\n\n    tbox = intersectCube(ro, rd, boxe[7]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 27;}\n    tbox = intersectCube(ro, rd, boxe[8]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 28;}\n    tbox = intersectCube(ro, rd, boxe[9]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 29;}\n    tbox = intersectCube(ro, rd, boxe[10]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 30;}\n    tbox = intersectCube(ro, rd, boxe[11]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 31;}\n    tbox = intersectCube(ro, rd, boxe[12]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 32;}\n    tbox = intersectCube(ro, rd, boxe[13]); \n\tif(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 33;}\n    \n    tbox = intersectCube(ro, rd, boxe[14]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t) {t = tbox.x; i = 34;}\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n\t\tmref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        if(abs(normal.x)>0.0)\n        { \n            mcol.xyz = vec3(0.95,0.95,0.95);\n            mref = vec2(0.0,1.0);\n        } \n         else if(normal.y>0.0)\n        {\n            vec3 tcol = texture(iChannel1,1.0-(hit.xz-vec2(1.5,1.5))/3.5).xyz;\n            float s = tcol.y+0.1;//-d\n            s = pow(s,3.0)*0.75+0.01;\n            mref = vec2((s*0.5+0.1),pow(1.0-s,2.0));\n            mcol.xyz = vec3(0.9);//tcol+0.4;\n        } \n        else if(abs(normal.z)>0.0)\n        {\n            mcol.xyz = vec3(0.95,0.15,0.19);\n            mref = vec2(0.0,1.0);\n            \n            if(normal.z<0.0)\n\t\t\t{\n            \t//cw = vec2(-0.4,0.1);\n            \tif(\tall(lessThanEqual(hit.xy,vec2(-0.05,0.6)+cw)) &&\n               \t\tall(greaterThanEqual(hit.xy,vec2(-0.7,-0.6)+cw)) ||\n               \t\tall(lessThanEqual(hit.xy,vec2(0.7,0.6)+cw)) &&\n               \t\tall(greaterThanEqual(hit.xy,vec2(0.05,-0.6)+cw)))\n               \t\tmcol = vec4(vec3(1.1),2.0);\n\t\t\t}\n        }\n\t}     \n\telse   \n\t{\n        \t if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==6) {normal = normalForSphere(hit, sfere[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==12) {normal = normalforCylinder(hit, cylinder[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==13) {normal = normalforCylinder(hit, cylinder[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,1000.0);}\n        else if(id==20) {normal = normalForCube(hit, boxe[0]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==21) {normal = normalForCube(hit, boxe[1]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==22) {normal = normalForCube(hit, boxe[2]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.0,0.0);}\n        else if(id==23) {normal = normalForCube(hit, boxe[3]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,9000.0);}\n        else if(id==24) {normal = normalForCube(hit, boxe[4]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,9000.0);}\n        else if(id==25) {normal = normalForCube(hit, boxe[5]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,10.0);}\n        else if(id==26) {normal = normalForCube(hit, boxe[6]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(1.0,10.0);}\n        else if(id==27) {normal = normalForCube(hit, boxe[7]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.8,0.8);}\n        else if(id==28) {normal = normalForCube(hit, boxe[8]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==29) {normal = normalForCube(hit, boxe[9]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==30) {normal = normalForCube(hit, boxe[10]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==31) {normal = normalForCube(hit, boxe[11]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==32) {normal = normalForCube(hit, boxe[12]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==33) {normal = normalForCube(hit, boxe[13]); mcol = vec4(0.1,0.1,0.1,0.0); mref = vec2(0.6,0.8);}\n        else if(id==34) {normal = normalForCube(hit, boxe[14]); mcol = vec4(0.9,0.9,0.9,0.0); mref = vec2(0.05,3.8);}\n        \n        if(id>19 && id<23)//material for dulap\n        {\n            vec2 uv = hit.yz;\n            uv = abs(normal.y) > 0.0 ? hit.zx : uv;\n            uv = abs(normal.z) > 0.0 ? hit.yx : uv; \n            mcol.xyz = texture(iChannel1,1.0-(uv - vec2(1.5,-1.0))/vec2(5.5,0.5)).xyz - vec3(0.35,0.2,0.2);\n            mref = vec2(0.0,0.2);// transparent, glossines\n            mcol.xyz = vec3(0.1,0.99,0.1);// color\n            \n            if(id==21)\tnormal = -normal;\n        }\n        \n        if(id>26 && id<34)//masa scaun\n        {\n            mcol.xyz = vec3(0.9);\n            mref = vec2(0.0,0.7);// transparent, glossines\n            //if(id==27) mcol.xyz = vec3(0.9,0.9,0.9);// color\n            \n            if(id==21)\tnormal = -normal;\n        }\n        \n        if(id==34)//calorifer\n        {\n            mcol.xyz = vec3(sin(hit.x*59.0)+2.0-0.2);\n            mref = vec2(0.0,0.0);\n        }\n    }  \n}\n\nvec3 directLight(vec3 hit, vec3 normal, vec3 lightf, vec3 cl, inout bool i)\n{\n   vec3 color = vec3(0.0);\n   int id = -1;\n   i = false;\n   //vec3 toLight = (lightf-hit);\n   //float sqdist = dot(toLight,toLight);\n   vec3 L = normalize(lightf-hit);;//(toLight*rsqrt(sqdist);\n   float diffuse = clamp(dot(normal,L),0.0,0.7)+0.3;\n \n   if(diffuse>0.0)\n   {\n      float ldist =distance(lightf,hit);// sqrt(sqdist);\n      float sh = 1000.0;//distance(lightf,hit);\n      intersectscene(hit + normal * 0.0001, L, sh, id, false);           \n      if(sh>ldist)\n         {color += cl * (diffuse/(ldist))*0.32; i = true;}\n   }\n   return color;\n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    int tm = -1;\n    \n    for(int i=0; i<6; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\t\t\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n    \n    \tintersectscene(ro, rd, t, id, true);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.99),0.0);\n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.00001;\n         \n        vec2 rnd = rand2();\n        rnd = vec2(0.3,0.6);\n        \n        \n        \n        //rnd.x = 1.0/6.0 * ( float(i) + rnd.x );\n        col *= mcol.xyz;\n     \n        \n        \n        if(mcol.w>0.0) \n        {\n            if(i==0) {color = mcol.xyz; break;}\n            float df=max(dot(rd,-normal),0.0)*2.0; //if(tm==1) df *= 19.0;\n            color += col*mcol.xyz*mcol.w * df ;\n            //if(tm==1) color += col * 1.5;\n            break;\n        }\n        \n        \n        \n        \n\t\ttm = -1;\n        if(rnd.x>abs(mref.x))//diffuse\n        {\n            \n            rnd=vec2(0.5,0.6);\n        \trd = CosineWeightedSampleHemisphere ( normal, rnd);      \n        \ttm = 0;   \n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0);\n           // color += col * 0.1;\n            \n            bool isLight = false;\n         \t//vec3 rnd3 = vec3(rand2(),rand2().x) *2.0 -1.0;\n            rnd = rand2()*2.0-1.0;\n            \n            rnd=vec2(1.0,1.0);\n            \n            //cw = vec2(-0.4,0.1);\n         \tvec3 lightf = vec3(cw,2.2) + vec3(rnd.x*0.65,rnd.y * 0.6,0.0);\n         \tvec3 dl = directLight(hit, normal, lightf, vec3(0.9,0.9,0.9), isLight);\n            float nd = max(0.0,dot(lightf,vec3(0.0,0.0,1.0)))+max(0.0,dot(lightf,normal));\n         \tcolor += col * dl*5.0 *nd;\n\n\t\t\n         \tif(isLight) break;\n            \n          \n            \n        }       \n        else \n        {\n            vec3 nrd = reflect(rd,normal); tm = 1;//reflect\n       \t\t/*if(mref.x<0.0)//refract\n            {\n                //if(id==30)\n                    //if(dot(rd,normal)>0.0) normal = -normal;\n            \tvec3 ior=vec3(1.0,1.52,1.0/1.12); tm = 2;\n           \t \tvec3 refr=refract(rd,normal,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n           \t \tvec2 ca=vec2(dot(normal,rd),dot(normal,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n            \tif(rand2().y>0.5*(pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)))\n               \t\tnrd=refr;\n            }*/\n            rd = cosPowDir(nrd, mref.y*1.0);\n            col *= 1.2;\n        }\n        \n        ro = hit + rd * 0.0001; \n        \n        if(dot(col,col) < 0.1 && i>3) break;\n    }\n    \n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    p = -1.0+2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 3.0*cos(8.0*mo.x), -0.9 + 2.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2 * iTime;\n    vec3 path = vec3(sin(time*0.5)*2.0, sin(time)*0.7, cos(time*0.5)*2.0);    \n    //ro = path; ta = path + vec3(-sin(time*0.5)*0.5+0.0, -cos(time)*0.2, -cos(time*0.5)*0.5+0.0);\n    \n    //view of raymarch\n    //ro = vec3(-0.4,-0.8, 1.0); ta = vec3(-0.4,-0.8, 1.5);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n//    for(float i=0.0; i<t; i++)\n//    {\n//        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n//        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n//    \tcol += getColor( ro, rd );\n//    }\n    \n    \n    for(float i=0.0; i<1.0; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.7 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    \n\n    //col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.65) );\n    col = pow( clamp( col/1.0, 0.0, 1.0 ), vec3(0.65) );\n    \n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}