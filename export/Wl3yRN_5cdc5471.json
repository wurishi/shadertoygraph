{"ver":"0.1","info":{"id":"Wl3yRN","date":"1608520073","viewed":69,"name":"crag coloring with noise","username":"wnu","description":"noise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat random3 (in vec3 _st) {\n    return fract(sin(dot(_st,\n                         vec3(12.9898,78.233,123.24647)))*\n      43758.5453123);\n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nfloat noise3 (in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 fr = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random3(i);\n    float b = random3(i + vec3(1.0, 0.0, 0.0));\n    float c = random3(i + vec3(0.0, 1.0, 0.0));\n    float d = random3(i + vec3(1.0, 1.0, 0.0));\n    \n    float e = random3(i + vec3(0.0, 0.0, 1.0));\n    float f = random3(i + vec3(1.0, 0.0, 1.0));\n    float g = random3(i + vec3(0.0, 1.0, 1.0));\n    float h = random3(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = fr * fr * (3.0 - 2.0 * fr);\n    \n    float bf = mix(a,b,u.x);\n    float bb = mix(c,d,u.x);\n    \n    float bot = mix(bf,bb,u.y);\n    \n    float tf = mix(e,f,u.x);\n    float tb = mix(g,h,u.x);\n    \n    float top = mix(tf,tb,u.y); \n\n    return mix(bot,top,u.z);\n}\n\n#define NUM_OCTAVES 6\n\nfloat fbm3 ( in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    float offset = 0.;\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        //v += a * sin((_st.y + _st.x+ _st.y)*10.)*1.5;\n        offset += a*2.5/1.5;\n        v += a * noise3(_st)*2.5;\n        _st = _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v/offset;\n}\n\nfloat fbmN(vec3 _st, int n){\n\tfloat v = 0.;\n    for (int i = 0;i<4;i++){\n        if(i>=n) break;\n        v= fbm3(_st + v*4.);\n    }\n    \n    return v;\n}\n\nfloat map(vec3 pos){\n    float circle = length(pos) - 1.;\n    float plane = pos.y;\n    //plane += fbmN(vec3(pos.xz,0.),2)/1.;\n    plane += fbm3(vec3(pos.xz,0.))/1.;\n    //plane += noise3(vec3(pos.xz,0.))/1.;\n    //plane += random3(vec3(pos.xz,0.))*10.;\n    float d= plane;\n    return d*0.5;   \n}\n\n//int MAX_STEPS = 100;\n//float MAX_DIST = 10.;\n//float SURF_DIST = 0.05;\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nfloat rayMarch(vec3 ro, vec3 rd){\n    float d = 0.;\n    \n    for(int i = 0;i<MAX_STEPS; i++){\n        vec3 p = ro + rd*d;\n        float dS = map(p);\n        d += dS;\n        if(d>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = map(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        map(p-e.xyy),\n        map(p-e.yxy),\n        map(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p,vec3 lightPos) {\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = rayMarch(p+n*SURF_DIST*2., l);\n   // if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z ,\n        i = c + uv.x*r + uv.y*u ,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mat4 rot = rotationMatrix(vec3(1.,1.,1.),0.);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m = vec2(0.5,0.35);\n\n    vec3 offset = vec3(0.,0.,-iTime/2.);\n    vec3 ro = vec3(0, 4, -5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    ro += offset;\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0)+ offset, 1.);\n    \n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    \n    float d = rayMarch(ro,rd);\n    \n    if(d<MAX_DIST){\n        vec3 p = ro + rd*d;\n        float dif = GetLight(p,vec3(3, 5, 4));\n        vec3 sun = vec3(0.8,0.2,0.2);\n        //sun = vec3(0.3,0.5,0.6);\n        vec3 dep = vec3(0.7,0.5,0.2);\n        //dep = vec3(0.5,0.5,0.5);\n        vec3 cra = vec3(1.,0.1,0.1);\n        //cra = vec3(0.1,0.1,1.);\n        \n        vec3 sun2 = vec3(0.7,0.6,0.2);\n        float dif2 = GetLight(p,vec3(-50,1,-4));\n        \n        vec3 sun_col = vec3(dif)*sun;\n        float depth = -p.y;\n        vec3 dep_col = dep*depth;\n        float crag = smoothstep(-0.8,-1.,p.y);\n        vec3 crag_col = cra*crag;\n        col = mix(sun_col,dep_col,0.5);\n        col += crag_col;\n        //col += dif2*sun2/2.;\n    }\n    \n    //float c = step(10.,d);\n    \n    //col = vec3(c);\n    \n\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}