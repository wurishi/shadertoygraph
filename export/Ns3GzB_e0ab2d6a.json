{"ver":"0.1","info":{"id":"Ns3GzB","date":"1649210086","viewed":65,"name":"Earth Simulation","username":"andrew741","description":"A realistic atmosphere shader. The camera moves between sea level and 131234 feet.\n\nUse the mouse to look around.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["volume","sunset","sun","sky","volumetric","green","scattering","night","blue","atmosphere","day","scatter","land","eartth","volumectrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// 2d rotation matrix (the matrix was from some website because i dont know much about matricies)\nvec2 rot2D(vec2 v, float a)\n{\n    mat2x2 rot = mat2x2(cos(a), -sin(a), sin(a), cos(a));\n    return v * rot;\n}\n\n\nvec3 Transform(vec2 uv, vec2 m, float roll)\n{\n    vec3 ro = vec3(0, 1, -1) * 20.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(rot2D(uv, roll), ro, vec3(0,0.,0), 1.);\n    return rd;\n}\n\n\n// finds where (if at all) a ray hits a sphere (i found this function on yt, not my own)\nvec2 RaySphere(vec3 rd, vec3 ro, vec3 sc, float r)\n{\n    vec3 offset = ro - sc;\n    float b = 2. * dot(offset, rd);\n    float c = dot(offset, offset) - r * r;\n\n    float discriminant = b * b - 4. * c;\n\n    if (discriminant > 0.)\n    {\n        float s = sqrt(discriminant);\n        float dstToSphereNear = max(0., (-b - s) / 2.);\n        float dstToSphereFar = (-b + s) / 2.;\n\n        if (dstToSphereFar > 0.)\n        {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n    }\n    return vec2(999999999999999999., 0);\n}\n\n\n// returns the desntiy of the atmosphere (found on yt not my own)\nfloat Density(float dstToPlannet, float r, float fallOff)\n{\n    float density_fall_off = fallOff;\n    float h = dstToPlannet / r;\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n\nstruct CloudAndDepth\n{\n    float dst, avDensity;\n};\n\n\nfloat CloudDensity(vec3 p)\n{\n    return 1. - clamp(length(p - (vec3(1., 6369.784 + 0.00113636 + 8.1480392, 0.))) * 0.9, 0., 1.);\n}\n\n\n// not my own again but i did modify it\nCloudAndDepth opticalDepth(vec3 ro, vec3 rd, float rayLength, float ps, float r, float fallOff)\n{\n    vec3 p = ro;\n    float step_size = rayLength / 16.;\n    vec3 v3_step_size = rd * step_size;\n    float lstepSize = length(v3_step_size);\n    float odepth = 0.;\n    float ldense;\n    float avDensity = 0.;\n    // stepping throught the atmosphere\n    for (int s = 0; s < 15; s++)\n    {\n        p += v3_step_size;\n        //avDensity += CloudDensity(p) * lstepSize;\n        ldense = Density(length(p) - ps, r, fallOff);\n        odepth += ldense * step_size;\n    }\n    return CloudAndDepth(odepth, avDensity);\n}\n\n\n// Is from another shader (the part where its rendering the lens flair but not the part where the 2d screenspace coord of the sun is being calculated)\nfloat lensflare(vec2 fragCoord, vec3 sun_dir) {\n    vec3 ro, ta;\n    vec2 m = iMouse.xy / iResolution.xy;\n    // finding the position of the sun (after being rotated with the view direction of the player)\n    vec3 sun_dir2 = sun_dir;\n    if (sun_dir.z < 0.) m.y = m.y * -1. + 0.15;\n    sun_dir2.yz *= Rot(m.y*3.14+1.4);\n    sun_dir2.xz *= Rot(m.x*6.2831);\n\n    // the 2/screenspace coord of the sun (not my own)\n    vec3 cpos = sun_dir2;\n    vec2 pos = 1.5 * cpos.xy / cpos.z;\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    // rendering the sun (not my own)\n\tvec2 uvd = uv*(length(uv));\n\tfloat f = 0.1/(length(uv-pos)*16.0+1.0);\n\tf += max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*0.25;\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\tf += max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tf += max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n\tuvx = mix(uv,uvd,-0.4);\n\tf += max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n    \n\treturn f;\n}\n\n\n// From https://www.shadertoy.com/view/4sjBDG\nfloat numericalMieFit(float costh)\n{\n    // This function was optimized to minimize (delta*delta)/reference in order to capture\n    // the low intensity behavior.\n    float bestParams[10];\n    bestParams[0]=9.805233e-06;\n    bestParams[1]=-6.500000e+01;\n    bestParams[2]=-5.500000e+01;\n    bestParams[3]=8.194068e-01;\n    bestParams[4]=1.388198e-01;\n    bestParams[5]=-8.370334e+01;\n    bestParams[6]=7.810083e+00;\n    bestParams[7]=2.054747e-03;\n    bestParams[8]=2.600563e-02;\n    bestParams[9]=-4.552125e-12;\n    \n    float p1 = costh + bestParams[3];\n    vec4 expValues = exp(vec4(bestParams[1] *costh+bestParams[2], bestParams[5] *p1*p1, bestParams[6] *costh, bestParams[9] *costh));\n    vec4 expValWeight= vec4(bestParams[0], bestParams[4], bestParams[7], bestParams[8]);\n    return dot(expValues, expValWeight);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y * 1.;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 rd = Transform(uv, m, 0.);\n    float scale = (sin(iTime * 0.5 + 3.14159 * 0.5) * 0.5 + 0.5) * 40.;  // 0-40km\n    //scale = 4.2672;  // top of a fourteener\n    //scale = 8.8489536;  // mt everest\n    vec3 ro = vec3(0., 6369.784 + 0.00113636 + scale, 0.);  // 29,029 ft: 8.8489536 km       7500 ft: 2.286 km     14,000 ft: 4.2672 km\n    float e_ = 2.;\n    \n    // shows from the pov of a iss\n    //ro = vec3(0., (6369.784 + 220.) * cos(iTime * 0.025 + e_), (6369.784 + 220.) * sin(iTime * 0.025 + e_));\n    //rd.yz = rot2D(rd.yz, iTime * 0.025 + e_);\n    \n    float time = iTime * 0.175;// - 0.95;\n    time *= 0.2;\n    time -= 0.1;\n    float t = 0.015;\n    vec3 sun_dir = normalize(vec3(0., sin(time+t), cos(time+t)));\n    vec3 sun_col = vec3(0.95, 0.6, 0.2);\n\n    vec3 col = vec3(0.);\n    \n    float r_off = 3.;\n    vec3 moon_p = vec3(cos(iTime * 0.1 + r_off) * 384400.*0.15 - 6369.784-1737., 10000., cos(iTime * 0.1 + r_off) * 384400.*0.15 - 6369.784-1737.);\n    float r = 3.14159 * +1.75;\n    //ro = moon_p + vec3(0., (1737. + 0.0011) * cos(r + e_), (1737. + 0.0011) * sin(r + e_));\n    //rd.yz = rot2D(rd.yz, r + e_);\n    vec2 moon_dst = RaySphere(rd, ro, moon_p, 1737.);\n    moon_dst = vec2(9999999999., 0.);\n    \n    float depth = 999999999.;\n    vec2 dstEarth = RaySphere(rd, ro, vec3(0.), 6369.784);\n    if (dstEarth.y > 0. && dstEarth.x < depth)\n    {\n        depth = dstEarth.x;\n        vec3 cp = ro + rd * dstEarth.x;\n        vec3 norm = normalize(cp);\n        vec3 ob = vec3(0.2, 0.8, 0.2);\n        ob *= max(dot(sun_dir, norm), 0.);\n        col = ob;\n    }\n    \n    if (moon_dst.x < depth && moon_dst.y > 0.)\n    {\n        depth = moon_dst.x;\n        vec3 cp = ro + rd * moon_dst.x;\n        vec3 norm = normalize(cp - moon_p);\n        vec3 ob = vec3(0.9, 0.9, 0.9);\n        ob *= max(dot(sun_dir, norm), 0.);\n        col = ob;\n    }\n    \n    vec3 finalSunCol = sun_col;\n    vec2 dstAtmo = RaySphere(rd, ro, vec3(0.), 6369.784 + 50.);\n    if (dstAtmo.y > 0.)\n    {\n        float f = 500.;\n        float r = 6369.784 + 50.;\n        \n        vec3 cp = ro + rd * dstAtmo.x;\n        vec3 exit = ro + rd * dstAtmo.x + rd * dstAtmo.y;\n        float dstThrough = length(exit - cp);\n        if (dstThrough > depth)\n        {\n            dstThrough = depth - dstAtmo.x;\n            exit = ro + rd * depth;\n        }\n        float stepSizeF = dstThrough / 26.;\n        vec3 stepSize = rd * stepSizeF;\n        \n        vec3 p = cp;\n        \n        // the scattering coeficents\n        float scatteringStrength = 5.;  // the amount of separation of the colors (create nice bands)\n        vec3 scatteringCoefficents = pow(vec3(400) / vec3(700, 530, 440), vec3(4.)) * scatteringStrength;  // finding the different scattering coefficents for different wavelengths of light (red, green, blue in this case)\n        \n        float rayLeighPhase = numericalMieFit(dot(sun_dir, rd));\n        \n        // the density\n        float density;\n        // the distance to the sun\n        float dst_sun;\n        // the transmittance\n        vec3 transmittance;\n        // the optical depths \n        float sunRayOpticalDepth;\n        float veiwRayOpticalDepth;\n        // the inscattered light\n        vec3 inScatteredLight = vec3(0.);\n        float cloud_density = 0.;\n        // stepping throught the atmosphere\n        for (float s = 0.; s < 20.; s++)\n        {\n            // moving the ray\n            p += stepSize;\n            // finding the distance through the atmosphere in the direction of the sun\n            dst_sun = RaySphere(sun_dir, p, vec3(0.), r).y;\n            // finding the optical depth for the view ray and sun ray\n            CloudAndDepth sunRay = opticalDepth(p, sun_dir, dst_sun, 6369.784, r, f);\n            sunRayOpticalDepth = sunRay.dst * 0.025;\n            CloudAndDepth veiwRay = opticalDepth(p, -rd, stepSizeF * s, 6369.784, r, f);\n            veiwRayOpticalDepth = veiwRay.dst * 0.025;\n            // finding the transmittance\n            transmittance = exp(vec3(-(sunRayOpticalDepth + veiwRayOpticalDepth)) * scatteringCoefficents) * (rayLeighPhase * 0.5 + 0.5);\n            //transmittance *= exp(-veiwRay.avDensity);\n            //cloud_density += veiwRay.avDensity;\n            density = Density(length(p) - 6369.784, r, f);\n            \n            // finding the amount of addition light\n            inScatteredLight += vec3(density) * transmittance * scatteringCoefficents * (stepSizeF * 0.075);\n            //inScatteredLight += CloudDensity(p) * stepSizeF * vec3(1., 1., 1.) * exp(-(sunRay.avDensity + sunRayOpticalDepth));\n        }\n        // adding the atmosphere to the color\n        col = col * mix(1., exp(-(veiwRayOpticalDepth + cloud_density)), smoothstep(0.4, 0.7, length(inScatteredLight))) + inScatteredLight;\n        finalSunCol += inScatteredLight;\n        //col=vec3(smoothstep(0.4, 0.7, length(inScatteredLight)));\n    }\n    \n    if (depth > 999999.)\n    {\n        col = mix(col, finalSunCol * 10.5, pow(max(dot(rd, sun_dir), 0.), 4000.));\n    }\n    \n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    col =  clamp((col*(a*col+b))/(col*(c*col+d)+e), 0., 1.);\n    \n    vec3 forwards = Transform(vec2(0.), m, 0.);\n    forwards.yz = rot2D(forwards.yz, iTime * 0.025 + e_);\n    //if (dot(forwards, sun_dir) > 0.6425 && RaySphere(ro, sun_dir, vec3(0.), 6369.784.).x > 999999.)\n    //if (dot(forwards, sun_dir) > 0.6425 && RaySphere(sun_dir, ro, vec3(0.), 6369.784).x > 999999.)\n        //col += finalSunCol * 2.5 * lensflare(fragCoord, sun_dir);\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// bloom\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // do 4 copies, each with a lower resolution\n    float b1 = max(length(texture(iChannel0, uv)) - 0.75, 0.);\n    float b2 = max(length(texture(iChannel0, uv)) - 0.75, 0.);\n    float b3 = max(length(texture(iChannel0, uv)) - 0.75, 0.);\n    float b4 = max(length(texture(iChannel0, uv)) - 0.75, 0.);\n    fragColor = vec4(b1, b2, b3, b4);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}