{"ver":"0.1","info":{"id":"43G3Wy","date":"1718308859","viewed":187,"name":"4D Voronoi Marble","username":"gllama","description":"Inspired from [url=\"https://www.shadertoy.com/view/Xs3fR4\"]FabriceNeyret2's Vorrocracks[/url]. Added 4D/3D noise to create an evolving spherical marble texture.\n\n[url=\"https://www.shadertoy.com/view/4XG3WV\"]Cheaper Version[/url]\n\nLicense CC0-1.0","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","perlin","brownian","motion","marble","cc0","equirectangular","fractional"],"hasliked":0,"parentid":"4XyGWG","parentname":"Expensive Veroni Marble"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ðŸ—¿ 4D Voronoi Marble (Equirectangular/Spherical)\n// License CC0-1.0\n//\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Technique inspired from FabriceNeyret2's Vorrocracks https://www.shadertoy.com/view/Xs3fR4\n//\n// Noise functions boosted up a dimension or two to create spherical/equirectangular texture.\n// UV => Spherical coords and then searches for the closest voronoi cell edge in 4D and then \n// distorts with fractional-brownian-motion.\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n//\n// Cheaper cut-down version of this effect w/better performance avail here : https://www.shadertoy.com/view/4XG3WV#\n\n#define PI 3.1415926535897932384626433832795\n\nbool darkmode = false;\n\nint Seed = 420, // < Changes your current Voronoi Cell\n    MOD = 2;  // type of Perlin noise [0,1,2,3]\n\nvec3 Voronoi_Shape = vec3(.5), // 3D Shape/Scale of Voronoi Cells\n     Movement_3D = vec3(0.,1.,.0); // The direction & speed of movement through XYZ of 4D voronoi space (Higher values = faster speed)\n\nfloat Layers = 3., // Number of Layers\n      Curve_Frequency = 2., // Higher Values = More Curves\n      Smoothness = 1., // Higher Values = Smoother Curves\n      Saturation = 1.1,     // Higher Values = More Saturated\n      Line_Width = 30.,  //  Higher Values = Thinner Lines\n      Line_Scale = 0., // Higher Values = bigger lines \n      ofs = .0001; // Alters 4D displacement \n      \n      \n\n\n\n#define hash44(p) fract(18.5453 * sin(p * mat4(127.1, 311.7, 269.5, 183.3, 421.1, 547.6, 231.3, 298.4, 87.6, 123.4, 356.1, 654.3, 765.1, 876.4, 132.5, 234.8)))\n#define disp(p) ( -ofs + (1.0 + 2.0 * ofs) * hash44(p) )\n\nfloat voronoi4D_edge_distance(vec4 u) \n{\n    // We triangle-wave loop through u.w which \"breathes\" our current Voronoi-Cell\n    u.w *= 0.1;\n    u.w = 1.0 - 2.0 * abs(fract(u.w + 0.5) - 0.5);\n    u.w *= 0.99;\n       \n    u.w += float(Seed); // Apply current Voronoi-Cell Seed\n    u.xyz += Movement_3D*iTime; // Apply XYZ Movement-Vector for 3D movement through the pattern\n    \n    vec4 iu = floor(u);\n    float m = 1e9, m2 = 1e9;\n    vec4 P, P2;\n    \n    vec4 iu_offset = iu - 0.5;\n    vec4 p, o, r;\n    float d;\n    vec4 new = vec4(1.);\n    \n    // Loop over a 2x2x2x2 grid of cells around the current cell\n    for (int k = 0; k < 8; k++) {\n        p = iu_offset +  vec4(k % 2, (k / 2) % 2, (k / 4) % 2, k / 8); // Center the cell at its position\n        o = disp(p);  // Get the displacement for this cell\n        r = p - u + o;\n        d = dot(r, r);\n\n        if (d < m) {\n            m2 = m;\n            P2 = P;\n            m = d;\n            P = r;\n        } else if (d < m2 && dot(P - r, P - r) > 1e-5) {\n            m2 = d;\n            P2 = r;\n        }\n    }\n    \n    // Calculate the final value using the closest cells found\n    if (m2 < 1e9) {\n        m2 = 0.5 * dot((P + P2), normalize(P2 - P));\n    }\n\n    return m2;\n}\n\n\n\n// Fractional Brownian Motion && Perlin Stuff\n\n// Rotation matrix for 3D (rotation around z-axis)\nmat3 rot3(float angle) {\n    float c = cos(angle), s = sin(angle);\n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\n// Hash function for 3D to 1D\n#define hash31(p) fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123)\n\n// Perlin Noise function for 3D\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p); f = f * f * (3.0 - 2.0 * f); // smoothstep\n\n    float v = mix(\n                mix(\n                    mix(hash31(i + vec3(0, 0, 0)), hash31(i + vec3(1, 0, 0)), f.x),\n                    mix(hash31(i + vec3(0, 1, 0)), hash31(i + vec3(1, 1, 0)), f.x), f.y),\n                mix(\n                    mix(hash31(i + vec3(0, 0, 1)), hash31(i + vec3(1, 0, 1)), f.x),\n                    mix(hash31(i + vec3(0, 1, 1)), hash31(i + vec3(1, 1, 1)), f.x), f.y), f.z);\n    \n    return MOD == 0 ? v\n         : MOD == 1 ? 2.0 * v - 1.0\n         : MOD == 2 ? abs(2.0 * v - 1.0)\n                    : 1.0 - abs(2.0 * v - 1.0);\n}\n\n// Noise function for 3D\n#define noise33(p) vec3(noise3(p), noise3(p + vec3(17.7)),noise3(p + vec3(34.1)))\n\n// Fractional Brownian Motion function for 3D\nvec3 fbm33(vec3 p) {\n    vec3 v = vec3(0.0);\n    float a = 0.5;\n    mat3 R = rot3(0.37);\n\n    for (int i = 0; i < 6; i++, p *= 2.0, a /= 2.0) {\n        p = R * p;\n        v += a * noise33(p); // Perlin noise3 with different offsets for XYZ\n    }\n\n    return v;\n}\n\n\n// UV coords to 3D space\nvec3 uvToCartesian3D(vec2 uv) {\n    // Convert UV to spherical coords\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359; // Latitude\n    // Convert Spherical Coords to \n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    return vec3(x, y, z);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = vec4(0.,0.,0.,1.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; \n    // UV => 3D transformation\n    vec3 pos = uvToCartesian3D(uv);\n\n\n\n    for(float i=0.; i<Layers ; i++) {\n        vec3 V = pos/Voronoi_Shape;\n        vec3 D = Curve_Frequency * fbm33(pos/Smoothness) * Smoothness;\n        float d=voronoi4D_edge_distance(vec4(V+D,iTime));\n        d = min( 1., Line_Width * pow(max(0.,d-Line_Scale),Saturation) );\n        fragColor += vec4(1.-d) / exp2(i);\n        pos*= 1.5 * rot3(.37);\n    }\n \n    if(!darkmode){fragColor = vec4(vec3(1.)-fragColor.xyz,1.);}\n}","name":"Image","description":"","type":"image"}]}