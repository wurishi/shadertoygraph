{"ver":"0.1","info":{"id":"wtlfzr","date":"1596072303","viewed":76,"name":"Raytracing Testing","username":"wessles","description":"This is the hacked together beginning of a raytracer. The reflections are fake right now, I will implement real ones next. Also my MSAA implementation will need some reworking","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float lit(vec3 l, vec3 n, vec3 v) {\n    vec3 r_l = reflect(-l, n);\n    float s = clamp01(100.0 * dot(r_l, v) - 97.0);\n    return s;\n}\n\nvec3 ray_color(vec4 r, mat4 camera) {\n    \n    \n    mat4 camI = inverse(camera);\n    \n    \n    vec4 lightPos = camI * (rotate(vec3(0, 1, 0), iTime) * vec4(1., .1, 1., 1.) * 2.);\n    \n    vec4 sphereCenter = camI * vec4(0., 0., 0., 1.);\n    float sphereRadius = .5;\n\n    vec4 planePoint = camI * vec4(0., -0.5, 0., 1.);\n    vec4 planeNormal = camI * vec4(0., 1., 0., 0.);\n    \n    bool hit = false;\n    \n    vec3 col;\n    \n    float minT = 1. / 0.;\n    \n    float sphereT = hit_sphere(sphereCenter, sphereRadius, r);\n    if(sphereT > 0.0) {\n        vec3 hitPoint = (camera * vec4(0., 0., 0., 1.) + camera * r * sphereT).xyz;\n        vec3 n = normalize(hitPoint - (camera * sphereCenter).xyz);\n        vec3 l = normalize((camera * lightPos).xyz - hitPoint);\n        vec3 v = normalize(-(camera * r).xyz);\n        \n        vec3 cSurface = vec3(1., .2, .2);\n        vec3 cCool = vec3(0., 0., 0.55) + 0.25 * cSurface;\n        vec3 cWarm = vec3(.3, .3, 0.) + 0.25 * cSurface;\n        vec3 highlight = vec3(2.);\n        \n        float NdL = clamp01(dot(n, l));\n        float s = lit(l, n, v);\n        col = .5 * cCool + NdL * mix(cWarm, vec3(1.), s);\n        \n        hit = true;\n        minT = sphereT;\n    }\n\n    float floorT = hit_plane(planePoint, planeNormal, r);\n    if(floorT > 0.0 && (!hit || floorT < sphereT)) {\n        vec3 hitPoint = (camera * vec4(0., 0., 0., 1.) + camera * r * floorT).xyz * 2.;\n        vec3 n = normalize((camera * planeNormal).xyz);\n        vec3 L = (camera * lightPos).xyz - hitPoint;\n        vec3 l = normalize(L);\n        vec3 v = normalize(-(camera * r).xyz);\n        \n        vec3 color = vec3(1., 1., 1.);\n        vec3 highlight = vec3(2.);\n        \n        col = vec3(checker(vec2(hitPoint.x, hitPoint.z) * .25));\n        col *= mix(color, highlight, lit(l, n, v));\n        col *= vec3(.5) * 1. / length(L);\n        \n        hit = true;\n        minT = floorT;\n    }\n    \n    \n    float lightT = .5*hit_sphere(lightPos, 0.5, r);\n    if(lightT > 0.0 && (!hit || (lightT < minT))) {\n        return vec3(2.);\n    }\n    \n    return col;\n}\n\nmat4 LookAt(vec3 eye, vec3 at, vec3 up)\n{\n  vec3 zaxis = normalize(at - eye);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  zaxis = -zaxis;\n\n  mat4 viewMatrix = translate(-eye.x, -eye.y, -eye.z) * mat4(\n    vec4(xaxis.x, xaxis.y, xaxis.z, 0),\n    vec4(yaxis.x, yaxis.y, yaxis.z, 0),\n    vec4(zaxis.x, zaxis.y, zaxis.z, 0),\n    vec4(0, 0, 0, 1)\n  );\n\n  return viewMatrix;\n}\n\nvec3 ray_color_random(vec4 ray, mat4 camera, float res, float seed) {\n    float offsetX = random(vec2(ray.x+seed, ray.y));\n    float offsetY = random(vec2(ray.x, ray.y+seed));\n    vec2 offset = vec2(offsetX, offsetY);\n    offset *= 2./res;\n    return ray_color(ray + vec4(offset.x, offset.y, 0., 0.), camera);\n}\n\n#define AA\n#define GAMMA_CORRECT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float FOV = 50. * 3.14/180.0;\n    float uvProtusion = 1.0 / tan(FOV/2.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv * 2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    float res = iResolution.y;\n    uv = round(uv * res) / res;\n    \n    \n    vec4 camPos = vec4(0.0, 0. - iMouse.y/100., -4., 1.);\n    camPos = \n        rotate(vec3(0., 1., 0.), iTime/100. + iMouse.x/100.)\n        //* rotate(vec3(1., 0., 0.), iTime/100. + iMouse.y/1000.)\n        * camPos;\n    \n    mat4 camera = LookAt(camPos.xyz, vec3(0.), vec3(0., 1., 0.));\n    \n    vec4 ray = vec4(vec3(uv, uvProtusion), 0.0);\n    vec3 col = vec3(0.);\n    \n    #ifdef AA\n    float n = 4.;\n    int N = 4;\n    for(int i = 0; i < N; i++) {\n    \tcol += ray_color_random(ray, camera, res, float(i)) / n;\n    }\n    #else\n    col = ray_color(ray, camera);\n    #endif\n    \n    #ifdef GAMMA_CORRECT\n    col.rgb = pow(col.rgb, vec3(1.0/2.2));\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hit_sphere(vec4 center, float radius, vec4 r) {\n    vec3 oc = -center.xyz;\n    vec3 ray = r.xyz;\n    float a = dot(ray, ray);\n    float b = 2.0 * dot(oc, ray);\n    float c = dot(oc, oc) - radius*radius;\n    float discriminant = b*b - 4.0*a*c;\n\n    if (discriminant < 0.0) {\n        return -1.0;\n    } else {\n        return (-b - sqrt(discriminant) ) / (2.0*a);\n    }\n}\n\nfloat hit_plane(vec4 p, vec4 n, vec4 r) {\n    float denom = dot(n, r);\n    if (abs(denom) > 0.0001f) // your favorite epsilon\n    {\n        float t = dot(p, n) / denom;\n        return t;\n    }\n    return -1.;\n}\n\nfloat clamp01(float x) {\n    return max(0., min(1., x));\n}\n\nfloat checker(vec2 uv) {\n    float x = round(fract(uv.x * 2.));\n    float y = round(fract(uv.y * 2.));\n    return float(x==y);\n}\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nmat4 rotate(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 translate(float x, float y, float z) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n    \t0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        x,   y,   z,   1.0\n    );\n}\n\nmat4 lookAt(vec3 cam, vec3 target) {\n    vec3 v = normalize(cam - target);\n    vec3 r = cross(v, vec3(0., 1., 0.));\n    vec3 u = -cross(v, r);\n    return mat4(\n        r.x, u.x, v.x, 0.0,\n        r.y, u.y, v.y, 0.0,\n        r.z, u.z, v.z, 0.0,\n        -cam.x, -cam.y, -cam.z, 1.0\n    );\n}","name":"Common","description":"","type":"common"}]}