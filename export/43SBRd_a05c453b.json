{"ver":"0.1","info":{"id":"43SBRd","date":"1729870627","viewed":46,"name":"Rotating Lorenz","username":"blayman","description":"Another Lorenz render. Special thanks to claude.ai for the point projection in particular.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["lorenz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 rungeKutta4(vec3 xyz)\n{\n    // --------The Lorenz System ODEs--------\n    // dx/dt = sigma*(y-x)\n    // dy/dt = x*(rho-z)-y\n    // dz/dt = x*y-beta*z\n\n    // Define constants\n    float sigma = 10.0;\n    float rho = 24.0;\n    float beta = 8.0 / 3.0;\n    \n    // Define time step\n    float h = TIMESTEP;\n    \n    // -------------------\n    // -------- X --------\n    // -------------------\n    \n    // k constants\n    float k11 = sigma*(xyz.y-xyz.x);\n    \n    float a12 = xyz.x + h * k11 / 2.0;\n    float k12 = sigma*(xyz.y-a12);\n    \n    float a13 = xyz.x + h * k12 / 2.0;\n    float k13 = sigma*(xyz.y-a13);\n    \n    float a14 = xyz.x + h * k13;\n    float k14 = sigma*(xyz.y-a14);\n    \n    // Use calculated k values to determine x_n+1\n    float x_n1 = xyz.x + h/6.0*(k11+2.0*k12+2.0*k13+k14);\n    \n    // -------------------\n    // -------- Y --------\n    // -------------------\n    \n    // k constants\n    float k21 = xyz.x*(rho-xyz.z)-xyz.y;\n    \n    float a22 = xyz.y + h * k21 / 2.0;\n    float k22 = xyz.x*(rho-xyz.z)-a22;\n    \n    float a23 = xyz.y + h * k22 / 2.0;\n    float k23 = xyz.x*(rho-xyz.z)-a23;\n    \n    float a24 = xyz.y + h * k23;\n    float k24 = xyz.x*(rho-xyz.z)-a24;\n    \n    // Use calculated k values to determine y_n+1\n    float y_n1 = xyz.y + h/6.0*(k21+2.0*k22+2.0*k23+k24);\n    \n    // -------------------\n    // -------- Z --------\n    // -------------------\n    \n    // k constants\n    float k31 = xyz.x*xyz.y-beta*xyz.z;\n    \n    float a32 = xyz.z + h * k31 / 2.0;\n    float k32 = xyz.x*xyz.y-beta*a32;\n    \n    float a33 = xyz.z + h * k32 / 2.0;\n    float k33 = xyz.x*xyz.y-beta*a33;\n    \n    float a34 = xyz.z + h * k33;\n    float k34 = xyz.x*xyz.y-beta*a34;\n    \n    // Use calculated k values to determine z_n+1\n    float z_n1 = xyz.z + h/6.0*(k31+2.0*k32+2.0*k33+k34);\n    \n    return vec3(x_n1, y_n1, z_n1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int index = int(fragCoord.x) % NUM_POINTS;\n\n    // Initial xyz value\n    vec4 initVal = vec4(1.0,1.0,1.0,1.0);\n    \n    // Sample the buffer for the previous xyz value\n    vec4 texValue = texture(iChannel0, vec2( float(NUM_POINTS-1) / iResolution.x, 0));\n    \n    // Use the initial value on frame 0, otherwise prev value from buffer\n    vec4 inputVal = mix(initVal, texValue, float(iFrame > 0));\n    \n    // Calculate the xyz value using RK4\n    vec3 rk4 = inputVal.xyz;\n    for(int i = 0; i < index % NUM_POINTS; ++i)\n    {\n        rk4 = rungeKutta4(rk4);\n    }\n    \n    fragColor = vec4(rk4, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float LINE_THICKNESS = 0.002;\nconst float CAMERA_RADIUS = 50.0;\nconst float FADE_SPEED = 0.1;  // Higher values = faster fade, lower = longer trails\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        c, 0, -s,\n        0, 1, 0,\n        s, 0, c\n    );\n}\n\nvec2 projectPoint(vec3 viewPos) {\n    return viewPos.xy / CAMERA_RADIUS;\n}\n\nfloat drawLine(vec2 uv, vec2 p1, vec2 p2) {\n    vec2 dir = p2 - p1;\n    float len = length(dir);\n    if(len < 0.0001) return 0.0;\n    \n    dir = dir / len;\n    vec2 toPixel = uv - p1;\n    float proj = clamp(dot(toPixel, dir), 0.0, len);\n    vec2 closest = p1 + dir * proj;\n    float d = length(uv - closest);\n    \n    return smoothstep(LINE_THICKNESS, LINE_THICKNESS * 0.8, d);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Set up background first\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.1, 0.1, 0.2) * (1.0 - length(uv));\n    \n    vec2 texCoord = fragCoord.xy / iResolution.xy;\n    vec3 eye = vec3(0.0, 0.0, CAMERA_RADIUS);\n    mat3 rotation = rotateY(iTime * 0.5);\n    vec3 col = backgroundColor;  // Start with background\n    \n    // Draw current frame\n    vec3 lines = vec3(0.0);\n    for(float i = 0.0; i < float(NUM_POINTS - 1); i++) {\n        vec2 coord1 = vec2(i / float(NUM_POINTS), 0.0);\n        vec4 data1 = texture(iChannel0, coord1);\n        vec3 worldPos1 = rotation * data1.xyz;\n        vec3 viewPos1 = worldPos1 - eye;\n        vec2 screenPos1 = projectPoint(viewPos1);\n        \n        vec2 coord2 = vec2((i + 1.0) / float(NUM_POINTS), 0.0);\n        vec4 data2 = texture(iChannel0, coord2);\n        vec3 worldPos2 = rotation * data2.xyz;\n        vec3 viewPos2 = worldPos2 - eye;\n        vec2 screenPos2 = projectPoint(viewPos2);\n        \n        float line = drawLine(uv, screenPos1, screenPos2);\n        lines += vec3((1.+sin(iTime))/2., (1.+sin(iTime+1.046))/2., (1.+sin(iTime+2.092))/2.) * line;\n    }\n    \n    // Read and fade previous frame (excluding background)\n    vec3 prevCol = texture(iChannel1, texCoord).rgb - backgroundColor;\n    prevCol = max(prevCol, 0.0);  // Ensure we don't go negative\n    prevCol *= (1.0 - FADE_SPEED);\n    \n    // Combine everything\n    col += max(lines, prevCol);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int NUM_POINTS = 1000;\nconst float TIMESTEP = 0.001;","name":"Common","description":"","type":"common"}]}