{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n// Calculate a 'closest point' map for every pixel for each quadrant direction\n// Can be used to accelerate ray traces within the grid, scales to high resolutions (4k+)\n//   Buffer A - Stores the geometry\n//   Buffer B - Calculates the distances in each x/y direction then the closest point in each quadrant\n//   Buffer C - Caches and updates using Buffer C when rendering is complete\n//   Image - Shows distance map, geometry and accumulation maps using keyboard\n\n// Quicker version: https://www.shadertoy.com/view/XcVBzh\n// Ray trace example: https://www.shadertoy.com/view/lX3yD7\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(floor(fragCoord));\n\n    // show the geometry map instead of the cone map\n    if (texelFetch(iChannel2, ivec2(50, 2), 0).r >= 1.0) {\n        fragColor = texelFetch(iChannel1, coord, 0);\n        return; \n    }\n    \n    // show the acculated distance map as it is being created (flash warning)\n    vec4 last_value;\n\n    if (texelFetch(iChannel2, ivec2(51, 2), 0).r >= 1.0) {\n        last_value = texelFetch(iChannel3, coord, 0);\n    } else {\n        last_value = texelFetch(iChannel0, coord, 0);\n    }\n\n    ivec2 last_top_right = unpack_2d_pos(last_value.r);\n    ivec2 last_bottom_right = unpack_2d_pos(last_value.g);\n    ivec2 last_bottom_left = unpack_2d_pos(last_value.b);\n    ivec2 last_top_left = unpack_2d_pos(last_value.a);\n    \n    // the scale will be max distance but for the demo set it low so we can visualise more easily\n    //float scale = max(iResolution.x, iResolution.y);\n    float scale = 80.0; \n    \n    if (texelFetch(iChannel2, ivec2(52, 2), 0).r >= 1.0) {\n        // represent all 4 channels in rgb so use cmyk instead\n        vec4 cmyk = vec4(\n            clamp(dist(last_top_right) / scale, 0.0, 1.0),\n            clamp(dist(last_bottom_right) / scale, 0.0, 1.0),\n            clamp(dist(last_bottom_left) / scale, 0.0, 1.0),\n            clamp(dist(last_top_left) / scale, 0.0, 1.0)\n        );\n\n        fragColor = vec4(\n            (1.0 - cmyk.xyz) * (1.0 - cmyk.w),\n            1.0\n        );\n        return;\n    }\n    \n    // show the closest pixel from the coord in all directions for the demo\n    float closest_dist = min(min(min(\n        dist(last_top_right) / scale, \n        dist(last_bottom_right) / scale),\n        dist(last_bottom_left) / scale),\n        dist(last_top_left) / scale);\n    \n    fragColor = vec4(vec3(clamp(closest_dist, 0.0, 1.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// this buffer contains the geometry that can interacted with\nconst float THRESHOLD = 0.6;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uint frame = uint(iFrame);\n\n    if (frame == uint(0)) {\n        // start with the opening scene\n        float height = float(texture(iChannel0, fragCoord / iResolution.xy).r > THRESHOLD);\n\n        fragColor = vec4(vec3(height), 1.0);\n        return;\n    }\n    \n    // if the mouse is pressed then add a blob to the scene\n    if (iMouse.z > 0.0) {\n        if (distance(fragCoord.xy, iMouse.xy) < 10.0) {\n            // if the keyboard key is down then remove geometry instead\n            float col = 0.0;\n            \n            if (texelFetch(iChannel2, ivec2(49, 2), 0).r < 1.0) {\n                col = 1.0;\n            }\n            \n            fragColor = vec4(vec3(col), 1.0);\n            return;\n        }\n    }\n    \n    // store itself for the next frame\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"// settings - common throughout all buffers\nstruct Settings {\n    uint resolution;\n    uint num_frames;\n    uint total_frames;\n    uint max_value;\n};\n\nSettings get_settings(vec2 res) {\n    // the target width/height to cover\n    uint resolution = uint(ceil(max(res.x, res.y)));\n    \n    // frames needed per pass\n    uint num_frames = uint(ceil(log(float(resolution)) / log(2.0)));\n    \n    // total frames needed before the map can be used\n    uint total_frames = num_frames * uint(2);\n    \n    // the maximum value to use as the default distance for no-hits\n    uint max_value = uint(ceil(sqrt(float(resolution * resolution) * 2.0)));\n\n    return Settings(\n        resolution,\n        num_frames,\n        total_frames,\n        max_value\n    );\n}\n\n\n// util functions\n\n// some methods to package a 2 16-bit int into a single 32-bit float\nfloat pack_2d_pos(in ivec2 pos) {\n    return uintBitsToFloat(packSnorm2x16(vec2(pos) / 32767.0));\n}\n\nivec2 unpack_2d_pos(in float col) {\n    return ivec2(unpackSnorm2x16(floatBitsToUint(col)) * 32767.0);\n}\n\nfloat dist(in ivec2 a) {\n    return length(vec2(a));\n    //return sqrt(float((a.x * a.x) + (a.y * a.y)));\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// this buffer computes the closest distance in each x/y direction for every pixel\n// it does this by checking neighbours in a binary-tree like manner over multiple frames\n// then it computes the closest point for each quadrant in a binary-tree manner\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(floor(fragCoord));\n    ivec2 res = ivec2(iResolution.xy);\n    \n    Settings settings = get_settings(iResolution.xy);\n    uint frame = uint(iFrame) % settings.total_frames;\n    \n    // check collision with the scene for the first frame\n    if (frame == uint(0)) {\n        if (texelFetch(iChannel0, coord, 0).r > 0.5) {\n            fragColor = vec4(uintBitsToFloat(uint(0)));\n        } else {\n            fragColor = vec4(uintBitsToFloat(settings.max_value));\n        }\n\n        return;\n    }\n\n    if (frame < settings.num_frames) {\n        // for next frames check all of the axis directions and find the closest distance\n        uint step_amount = uint(pow(2.0, float(frame) - 1.0)); //2 ^ (frame - 1) does not work\n\n        ivec2 top_step = ivec2(0, step_amount);\n        ivec2 left_step = ivec2(-step_amount, 0);\n        ivec2 right_step = ivec2(step_amount, 0);\n        ivec2 bottom_step = ivec2(0, -step_amount);\n\n        // update the closest distance for each direction\n        vec4 last_value = texelFetch(iChannel1, coord, 0);\n        uint last_top = floatBitsToUint(last_value.r);\n        uint last_right = floatBitsToUint(last_value.g);\n        uint last_bottom = floatBitsToUint(last_value.b);\n        uint last_left = floatBitsToUint(last_value.a);\n\n        // top\n        if (step_amount < uint(res.y - coord.y)) {\n            vec4 top_neighbour = texelFetch(iChannel1, coord + top_step, 0);\n            uint closest_top = floatBitsToUint(top_neighbour.r) + step_amount;\n            last_top = min(last_top, closest_top);\n        }\n\n        // right\n        if (step_amount < uint(res.x - coord.x)) {\n            vec4 right_neighbour = texelFetch(iChannel1, coord + right_step, 0);\n            uint closest_right = floatBitsToUint(right_neighbour.g) + step_amount;\n            last_right = min(last_right, closest_right);\n        }\n        \n        // bottom\n        if (step_amount < uint(coord.y)) {\n            vec4 bottom_neighbour = texelFetch(iChannel1, coord + bottom_step, 0);\n            uint closest_bottom = floatBitsToUint(bottom_neighbour.b) + step_amount;\n            last_bottom = min(last_bottom, closest_bottom);\n        }\n\n        // left\n        if (step_amount < uint(coord.x)) {\n            vec4 left_neighbour = texelFetch(iChannel1, coord + left_step, 0);\n            uint closest_left = floatBitsToUint(left_neighbour.a) + step_amount;\n            last_left = min(last_left, closest_left);\n        }\n\n        // store the accumulated closest point\n        fragColor = vec4(\n            uintBitsToFloat(last_top),\n            uintBitsToFloat(last_right),\n            uintBitsToFloat(last_bottom),\n            uintBitsToFloat(last_left)\n        );\n\n        return;\n    }\n\n    // once complete, compute the quadrant distances\n    frame -= settings.num_frames; \n    \n    // for the first frame of the second step read the closest ponts from the directionals\n    if (frame == uint(0)) {\n        vec4 dir_distances = texelFetch(iChannel1, coord, 0);\n        uint top_dist = floatBitsToUint(dir_distances.r);\n        uint right_dist = floatBitsToUint(dir_distances.g);\n        uint bottom_dist = floatBitsToUint(dir_distances.b);\n        uint left_dist = floatBitsToUint(dir_distances.a);\n        \n        ivec2 closest_top_right;\n        if (top_dist < right_dist) {\n            closest_top_right = ivec2(0, int(top_dist));\n        } else {\n            closest_top_right = ivec2(int(right_dist), 0);\n        }\n        \n        ivec2 closest_bottom_right;\n        if (bottom_dist < right_dist) {\n            closest_bottom_right = ivec2(0, -int(bottom_dist));\n        } else {\n            closest_bottom_right = ivec2(int(right_dist), 0);\n        }\n        \n        ivec2 closest_bottom_left;\n        if (bottom_dist < left_dist) {\n            closest_bottom_left = ivec2(0, -int(bottom_dist));\n        } else {\n            closest_bottom_left = ivec2(-int(left_dist), 0);\n        }\n        \n        ivec2 closest_top_left;\n        if (top_dist < left_dist) {\n            closest_top_left = ivec2(0, int(top_dist));\n        } else {\n            closest_top_left = ivec2(-int(left_dist), 0);\n        }\n        \n        fragColor = vec4(\n            pack_2d_pos(closest_top_right), //top right\n            pack_2d_pos(closest_bottom_right), //bottom right\n            pack_2d_pos(closest_bottom_left), //bottom left\n            pack_2d_pos(closest_top_left) //top left\n        );\n        return;\n    }\n    \n    // for later frames lookup the diagonal closest points and compare them to the existing closest point\n    vec4 last_closest = texelFetch(iChannel1, coord, 0);\n    ivec2 last_top_right = unpack_2d_pos(last_closest.r);\n    ivec2 last_bottom_right = unpack_2d_pos(last_closest.g);\n    ivec2 last_bottom_left = unpack_2d_pos(last_closest.b);\n    ivec2 last_top_left = unpack_2d_pos(last_closest.a);\n    \n    int step_amount = int(pow(2.0, float(frame) - 1.0)); //2 ^ (frame - 1) does not work\n    \n    ivec2 top_right_step = ivec2(step_amount, step_amount);\n    ivec2 bottom_right_step = ivec2(step_amount, -step_amount);\n    ivec2 bottom_left_step = ivec2(-step_amount, -step_amount);\n    ivec2 top_left_step = ivec2(-step_amount, step_amount);\n    \n    // top right\n    if (step_amount < min(res.y - coord.y, res.x - coord.x)) {\n        ivec2 test_top_right = unpack_2d_pos(texelFetch(iChannel1, coord + top_right_step, 0).r) + top_right_step;\n\n        if (dist(test_top_right) < dist(last_top_right)) {\n            last_top_right = test_top_right;\n        }\n    }\n    \n    // bottom right\n    if (step_amount < min(coord.y, res.x - coord.x)) {\n        ivec2 test_bottom_right = unpack_2d_pos(texelFetch(iChannel1, coord + bottom_right_step, 0).g) + bottom_right_step;\n\n        if (dist(test_bottom_right) < dist(last_bottom_right)) {\n            last_bottom_right = test_bottom_right;\n        }\n    }\n    \n    // bottom left\n    if (step_amount < min(coord.y, coord.x)) {\n        ivec2 test_bottom_left = unpack_2d_pos(texelFetch(iChannel1, coord + bottom_left_step, 0).b) + bottom_left_step;\n\n        if (dist(test_bottom_left) < dist(last_bottom_left)) {\n            last_bottom_left = test_bottom_left;\n        }\n    }\n    \n    // top left\n    if (step_amount < min(res.y - coord.y, coord.x)) {\n        ivec2 test_top_left = unpack_2d_pos(texelFetch(iChannel1, coord + top_left_step, 0).a) + top_left_step;\n\n        if (dist(test_top_left) < dist(last_top_left)) {\n            last_top_left = test_top_left;\n        }\n    }\n\n    // store the accumulated closest point\n    fragColor = vec4(\n        pack_2d_pos(last_top_right),\n        pack_2d_pos(last_bottom_right),\n        pack_2d_pos(last_bottom_left),\n        pack_2d_pos(last_top_left)\n    );\n}\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// this buffer renders buffer B when it is complete, keeping the result in the buffer until it is rendered again\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(floor(fragCoord));\n    Settings settings = get_settings(iResolution.xy);\n    uint frame = uint(iFrame);\n    \n    if (frame == uint(0)) {\n        fragColor = vec4(pack_2d_pos(ivec2(0)));\n        return;\n    }\n     \n    // the last frame should contain what we want to render\n    if ((frame % settings.total_frames) == (settings.total_frames - uint(1))) {\n        fragColor = texelFetch(iChannel0, coord, 0);\n        return;\n    }\n    \n    fragColor = texelFetch(iChannel1, coord, 0);\n}\n","name":"Buffer C","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lftfDX","date":"1735172142","viewed":38,"name":"Fast closest point (2 pass)","username":"mrboggieman","description":"A 'closest point' map for every pixel in each directional quadrant. Use for accelerating ray tracing in a grid and creating Voronoi. Draw with mouse.\nKeys:\n  '1' - add/remove geometry\n  '2' - geometry map\n  '3' - acc map (flash warning)\n  '4' - split dir","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["trace","closest"],"hasliked":0,"parentid":"","parentname":""}}