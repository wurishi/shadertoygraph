{"ver":"0.1","info":{"id":"3tVfWR","date":"1614178055","viewed":56,"name":"My shaderToy project","username":"skillermaniac","description":"My Computer graphics project :D","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nSphere[spheres_num] spheres;\nCamera camera;\n\n// Method that initializes all objects\nvoid initializeObjects() {\n    // Sun\n    Sphere Sun = Sphere(vec3(0.0, 2.5, 0.0), 0.01, lightSource(1.0)); \n    spheres[0] = Sun;\n    // Blue sphere\n    Sphere sphereA = Sphere(cos(iTime)*vec3(0.0, 0.0, 0.03), 0.5,\n    reflective(vec3(0.0, 0.0, 1.0),0.2));\n    spheres[1] = sphereA;\n    // Moving red sphere\n    float rotation = iTime;\n    float rotation_2 = 2.0 * rotation;\n    Sphere sphereB = Sphere(sphereA.Center + vec3(1.5 * vec3(cos(rotation), sin(rotation), 0)), 0.3, crude(vec3(0.0, 1.0, 1.0)));\n    spheres[2] = sphereB;\n    Sphere sphereC = Sphere(vec3(0.0, .4, 1.3 + 0.1 * cos(iTime)), 0.3, \n    reflective(vec3(0.0, 1.0, 0.0),0.7)); //reflective sphere\n    spheres[3] = sphereC;\n    //red sphere\n    Sphere sphereD = Sphere(sphereB.Center + (0.4 * vec3(cos(rotation_2), sin(rotation_2), 0)), 0.1,\n    crude(vec3(1.0, 0.0, 0.0)));\n    spheres[4] = sphereD;\n    Sphere sphereE = Sphere(sphereB.Center + (0.64 * vec3(0, sin(rotation_2), cos(rotation_2))), 0.1,\n    crude(vec3(1.0, 0.0, 0.0)));\n    spheres[5] = sphereE;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initializeObjects();\n    Camera cam = createCamera(vec3(3.0, 3.0, 1.5),\n    vec3(0.5, 0.5, 0.5), 50.0, iResolution);\n    vec3 BackgroundColor = vec3(0.5, 0.5, 1.0);\n    fragColor.a = 1.0;\n    Ray ray = launchRay(cam, fragCoord); // We will use this ray and compute its intersections in order to change pixelcolors\n    // We need to bounce the ray if its in contact wit a reflective material\n    vec3 ReflectionRatio = vec3(1.0, 1.0, 1.0);\n    IntersectionInfo info;\n    for (int i = 0; i < 9; i++) { // Up to 9 reflections\n      info = getIntersectionInfo(ray, spheres);\n      if (info.tVal != INFINITY && info.tVal > 0.0) {\n        fragColor.rgb += (lighting(spheres, info) * ReflectionRatio);\n        if (info.sphere.material.Kr == Zero3) {\n          break; // If the sphere is crude : no need to reflect the ray\n        } else {\n          ReflectionRatio *= info.sphere.material.Kr;\n          // We create a reflexion ray and then track it;\n          ray = reflectRay(info);  \n        }\n      } else {\n          fragColor.rgb += ReflectionRatio * BackgroundColor;\n          break;\n      }\n\n    }\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float INFINITY = 1e30;\nconst float EPSILON = 1e-3;\nconst vec3 Zero3 = vec3(0.0, 0.0, 0.0);\nconst vec3 One3 = vec3(1.0, 1.0, 1.0);\nconst int spheres_num = 6; // 5 spheres + a lightSource\n// Camera for 3D visualizations\nstruct Camera {\n    vec3 Observer;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float screenHeight;\n    float screenWidth;\n    float screen_observer_distance;\n};\nstruct Ray { // a Ray that the camera will launch in order to find the right colors\n    vec3 Source;\n    vec3 Direction;\n};\nstruct Material {\n    vec3 Kd; // diffuse color\n    vec3 Ke; // emissive color\n    vec3 Kr; // reflective material\n};\nstruct Sphere {\n    vec3 Center;\n    float radius;\n    Material material; //whether its a crude, light or reflective type sphere\n};\n\nMaterial crude(in vec3 Kd) {\n   return Material(Kd, Zero3, Zero3);\n}\n\nMaterial lightSource(float intensity) {\n   return Material(Zero3, intensity * One3, Zero3);\n}\n\nMaterial reflective(in vec3 Kd, in float Kr) {\n   return Material(Kd, Zero3, Kr * One3);\n}\nstruct IntersectionInfo {\n    Sphere sphere;\n    vec3 IntersectionPoint;\n    bool doesIntersectASphere;\n    float tVal;\n    Ray incidenceRay;\n};\n\nCamera createCamera(in vec3 Observer, in vec3 LookAt, in float aperture, vec3 iResolution) {\n    Camera camera;\n    camera.Observer = Observer;\n    camera.View = normalize(LookAt - Observer);\n    vec3 KAxis = vec3(0.0, 0.0, 1.0);\n    camera.Horiz = normalize(cross(KAxis, camera.View));\n    \n    //no need to normalize up since view and horiz are already normalized;\n    camera.Up = cross(camera.View, camera.Horiz);\n    camera.screenHeight = iResolution.y;\n    camera.screenWidth = iResolution.x;\n    camera.screen_observer_distance = (camera.screenHeight / 2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n    return camera;\n}\n// launches a ray : {Source : camera, direction: the corresponding pixel of the screen}\nRay launchRay (in Camera camera, in vec2 pixCoord) {\n    float adjustedX = pixCoord.x - camera.screenWidth / 2.0;\n    float adjustedY = pixCoord.y - camera.screenHeight / 2.0;\n    return Ray(camera.Observer, camera.screen_observer_distance * camera.View \n    + adjustedX * camera.Horiz \n    + adjustedY * camera.Up);\n}\n\n\n/*\n   If bool = true , the intersection will be at : M = RayOrigin + atT * Dir\n*/\nbool doesIntersectSphere(in Ray ray, in Sphere sphere, out float atT) {\n    vec3 SC = ray.Source - sphere.Center;\n    float a = dot(ray.Direction, ray.Direction);// R.dirÂ²;\n    float b = 2.0 * dot(ray.Direction, SC);\n    float c = dot(SC, SC) - sphere.radius * sphere.radius;\n    float delta = b * b - 4.0 * a * c;\n    if(delta < 0.0) {\n        return false;\n    };\n    atT = (- b - sqrt(delta)) / (2.0 * a);\n    return true;\n}\n\nIntersectionInfo getIntersectionInfo(in Ray ray, in Sphere[spheres_num] spheres) {\n    IntersectionInfo info;\n    float t = INFINITY;\n    info.doesIntersectASphere = false;\n    info.incidenceRay = ray;\n    for (int i = 0; i < spheres_num; i++) {\n        Sphere sphere = spheres[i];\n        float potentialT;\n        if (doesIntersectSphere(ray, sphere, potentialT)) {\n            if (potentialT < t && potentialT > 0.0) {\n                t = potentialT;\n                info.sphere = sphere;\n                info.IntersectionPoint = ray.Source + potentialT * ray.Direction;\n                info.tVal = potentialT;\n            }\n        }\n        \n    }\n    info.doesIntersectASphere = (info.tVal != INFINITY);\n    \n    return info;\n}\nfloat getLightingRatio(in Sphere sphere, in vec3 IntersectionPoint, in vec3 Sun) {\n    vec3 NormaleVec = normalize(IntersectionPoint - sphere.Center);\n    vec3 IncidenceVec = Sun - IntersectionPoint;\n    float incidence = max(dot(NormaleVec, IncidenceVec) / (length(IncidenceVec)), 0.0);\n    return incidence;\n}\nbool hasShadow(in Ray shadowRay, in Sphere[spheres_num] spheres) {\n    for (int i = 0; i < spheres_num; i++) { // For every sphere that isn't a light source\n        float tVal;\n        if (spheres[i].material.Ke == Zero3) {\n            Sphere crudeSphere = spheres[i];\n            if (doesIntersectSphere(shadowRay, crudeSphere, tVal) && (tVal>EPSILON && tVal < 1.0)) { // If there is a crude sphere in between\n                return true; // then it has shadow\n            }\n        }\n\n    }\n    return false;\n}\nvec3 lighting(Sphere[spheres_num] spheres, IntersectionInfo info) {\n   if(info.sphere.material.Ke != Zero3) {\n      return info.sphere.material.Ke; //If it has an emission! we give it the emission color\n   }  \n   vec3 Result = vec3(0.0, 0.0, 0.0);\n   //P intersection point //N normale\n   for(int i = 0; i < spheres.length(); ++i) {\n      if (spheres[i].material.Ke != Zero3) { // if spheres[i] is a light source\n        //Lets check if it has shadow. We use the light ray which origin is the lightsource and is directed to the intersectionPoint\n        // If there is an object in between then there is shadow\n        Sphere lightSource = spheres[i];\n        Ray shadowRay = Ray(info.IntersectionPoint, lightSource.Center);\n        \n        if (!hasShadow(shadowRay, spheres)) {\n            // The incidence vector\n            vec3 Incidence = lightSource.Center - info.IntersectionPoint;\n            // The normale vector\n            vec3 IntersectionNormale = normalize(info.IntersectionPoint - info.sphere.Center);\n            /* If Incidence is parallel to the Normale, \n            the intencity will be equal to 1 and the pixel will take the sphere's color */\n            float intensity = max(0.0, dot(Incidence,IntersectionNormale) / length(Incidence));\n            vec3 sphereDiffuse = info.sphere.material.Kd;\n            // takes into account all light sources\n            Result += intensity * sphereDiffuse * lightSource.material.Ke;\n        }\n        \n         \n      }\n   }\n   \n   return Result;\n}\nRay reflectRay(in IntersectionInfo info) {\n    vec3 Normale = normalize(info.IntersectionPoint - info.sphere.Center);\n    return Ray(info.IntersectionPoint,\n     (info.incidenceRay.Direction -2.0 * dot(Normale, info.incidenceRay.Direction) * Normale));\n}\n","name":"Common","description":"","type":"common"}]}