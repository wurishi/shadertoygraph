{"ver":"0.1","info":{"id":"DscfD7","date":"1697215717","viewed":71,"name":"distortion universes","username":"nayk","description":"universes","likes":1,"published":1,"flags":1,"usePreview":0,"tags":["universes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.850\n\n#define SLICES \t\t\t50.0\n\n#define START_AMPLITUDE\t0.01\n\n#define START_FREQUENCY\t1.25\n\n#define START_DENSITY\t0.0\n\n#define ANIMATION_SPEED 0.075\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n// set to 1 for 2 octaves\t\n#if 0\t\n\treturn f/0.75;\n#else\t\n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n// set to 1 for 3 octaves, 0 for 4 octaves\t\n#if 1\t\n\treturn f/0.875;\n#else\t\n\tp = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n#endif\t\n#endif\t\n}\n\n\nvec3 gradient(float s)\n{\n\treturn vec3(0.0, max(1.0-s*2.0, 0.0), max(s>0.5?1.0-(s-0.5)*5.0:1.0, 0.0));\n}\n\n\n#define RADIUS 0.5\nbool intersectSphere(vec3 origin, vec3 direction, out float tmin, out float tmax)\n{\n    bool hit = false;\n\tfloat a = dot(direction, direction);\n    float b = 2.0*dot(origin, direction);\n    float c = dot(origin, origin) - 0.5*0.5;\n    float disc = b*b - 4.0*a*c;           // discriminant\n    tmin = tmax = 0.0;\n\n    if (disc > 0.0) {\n        // Real root of disc, so intersection\n        float sdisc = sqrt(disc);\n        float t0 = (-b - sdisc)/(2.0*a);          // closest intersection distance\n        float t1 = (-b + sdisc)/(2.0*a);          // furthest intersection distance\n\n\t\ttmax = t1;\n        if (t0 >= 0.0) \n            tmin = t0;\n        hit = true;\n    }\n\n    return hit;\n}\n\n\nvec2 rt(vec2 x,float y)\n{\n\treturn vec2(cos(y)*x.x-sin(y)*x.y,sin(y)*x.x+cos(y)*x.y);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>9) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.05,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.004);\n\tfloat time=iTime*speed+.25;\n    float time2 = iTime;\n    float rotTime = sin(time);\n    \n    vec3 color1 = vec3(0.8, 0.5, 0.3);\n    vec3 color2 = vec3(rotTime, 0.2, 0.3);\n    \n  float k = 1.0 * sin( iTime * .9 );\n    float kcube = .5 * sin( iTime );\n    \n    float offset = .1 * sin( iTime * .5 );\n    \n  vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n    p.x *= iResolution.x/ iResolution.y;\n\n\t// camera and user input\n\tvec3 oo = vec3(0, 0, 1.0-100.*cos(iTime)/iResolution.y);\n\tvec3 od = normalize(vec3(p.x, p.y, -2.0));\n\tvec3 o,d;\t\n\to.xz = rt(oo.xz, 16.3*cos(iTime)/iResolution.x);\n\to.y = oo.y;\n\td.xz = rt(od.xz, 6.3*cos(iTime)/iResolution.x);\n\td.y = od.y;\n\n\t// render\n\tvec4 col = vec4(0, 0, 0, 0);\n\tfloat tmin, tmax;\n\tif (intersectSphere(o, d, tmin, tmax))\n\t{\t\n\t\t// step thoug the sphere with max SLICES steps\n\t\tfor (float i = 0.0; i < SLICES; i+=1.0)\n\t\t{\n\t\t\t// stay within the sphere bounds\n\t\t\tfloat t = tmin+i/SLICES;\n\t\t\tif (t > tmax) \n\t\t\t\tbreak;\n\t\t\tvec3 curpos = o + d*t;\n\t\t\t\n\t\t\t// get sphere falloff in s\n\t\t\tfloat s = (0.5-length(curpos))*2.0;\n\t\t\ts*=s;\n\n\t\t\t// get turbulence in d\n\t\t\tfloat a = START_AMPLITUDE;\n\t\t\tfloat b = START_FREQUENCY;\n\t\t\tfloat d = START_DENSITY;\n\t\t\tfor (int j = 0; j < 2; j++)\t\t\t\t\t\t\t\t\t\n\t\t\t{\n\t\t\t\td += 0.5/abs((fbm(3.0*curpos*b+ANIMATION_SPEED*iTime/b)*2.0-0.1)/a);\n\t\t\t\tb *= 0.20;\n\t\t\t\ta /= 1.0;\n\t\t\t}\n\t\t\t\n\t\t\t// get gradient color depending on s\n\t\t\tcol.rgb += gradient(s)*max(d*s,0.0);\n\t\t}\t\t\n\t}\n\n  \n\ndir+=col.xyz;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\t\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\n    \n}\n","name":"Image","description":"","type":"image"}]}