{"ver":"0.1","info":{"id":"tdSSWc","date":"1561552732","viewed":421,"name":"Neon Room","username":"taso69","description":"Neon Room\nReferenced the techniques in these shaders\nhttps://www.shadertoy.com/view/MlscDj\nhttps://www.shadertoy.com/view/ldGyWW","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["3d","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14195265359\n#define EPS 0.001\n\nmat2 rotate(float a){\n\tfloat s = sin(a); float c = cos(a);\n\treturn mat2(c, -s,s, c);\n}\n\nfloat hash21( vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvec2 hash22(vec2 p){\n    float n = hash21(p);\n    return vec2(n,hash21(n+p));\n}\n\n//https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdCappedCylinder( vec3 pos, vec2 h ){\n  vec2 d = abs(vec2(length(pos.xz),pos.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 pos, vec3 a, vec3 b, float r ){\n    vec3 pa = pos - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdWireBox(vec3 pos,float W,float H, float D){\n    float r = 0.01;\n    float hw = 0.5*W, hh = 0.5*H, hd = 0.5*D;\n    float d= sdCapsule(pos- vec3(-hw,0.0,-hd),vec3(0.0,hh,0.0),vec3(0.0,-hh,0.0),r);\n    d = min(d,sdCapsule(pos- vec3(-hw,0.0,hd),vec3(0.0,hh,0.0),vec3(0.0,-hh,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(hw,0.0,-hd),vec3(0.0,hh,0.0),vec3(0.0,-hh,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(hw,0.0,hd),vec3(0.0,hh,0.0),vec3(0.0,-hh,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(0.0,-hh,-hd),vec3(hw,0.0,0.0),vec3(-hw,0.0,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(0.0,-hh,hd),vec3(hw,0.0,0.0),vec3(-hw,0.0,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(0.0,hh,-hd),vec3(hw,0.0,0.0),vec3(-hw,0.0,0.0),r));\n    d = min(d,sdCapsule(pos- vec3(0.0,hh,hd),vec3(hw,0.0,0.0),vec3(-hw,0.0,0.0),r)); \n    d = min(d,sdCapsule(pos- vec3(-hw,-hh,0.0),vec3(0.0,0.0,hd),vec3(0.0,0.0,-hd),r)); \n    d = min(d,sdCapsule(pos- vec3(-hw,hh,0.0),vec3(0.0,0.0,hd),vec3(0.0,0.0,-hd),r)); \n    d = min(d,sdCapsule(pos- vec3(hw,-hh,0.0),vec3(0.0,0.0,hd),vec3(0.0,0.0,-hd),r)); \n    d = min(d,sdCapsule(pos- vec3(hw,hh,0.0),vec3(0.0,0.0,hd),vec3(0.0,0.0,-hd),r)); \n    return d;\n}\n\n\nfloat sdBox(vec3 pos, vec3 b){\n    vec3 d = abs(pos) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere(vec3 pos, float r){\n    return length(pos) - r;\n}\n\nfloat sdWall(vec3 pos){\n    pos.xz = abs(pos.xz);\n    return min(5.0-pos.z,5.0-pos.x);\n}\n\n//Roof and Floor\nfloat sdRF(vec3 pos){\n    return min(pos.y + 1.0,3.0 - pos.y);\n}\n\nvec2 matMin(vec2 a, vec2 b){\n    return (a.x < b.x) ? a : b;\n}\n\n//https://www.shadertoy.com/view/ldGyWW\nvec3 map(vec3 pos){\n    vec2 dist = vec2(10000.0,-1.0);//x:dist, y:material\n    float light = 10000.0;//light object\n    \n    vec3 p = pos;\n    float rep = 2.5;\n    vec3 id = floor(pos/rep);\n    p.xz = mod(p.xz,rep) - rep*0.5;\n    vec2 rand = 1.2*hash22(id.xz) - vec2(0.6);\n    p -= vec3(rand.x,0.0,rand.y); \n    p.xz *= rotate(iTime);\n    p.y += 8.0*fract(-hash21(id.zz)*iTime*0.7+hash21(id.xz))-4.0; \n    float cube = sdWireBox(p,0.4,0.4,0.4);\n    dist = matMin(dist,vec2(cube,1.0));\n   \n    p = pos;\n    rep = 3.0;\n    id = floor(pos/rep);\n    p.xz = mod(p.xz,rep) - rep*0.5;\n    rand = 1.3*hash22(id.zx) - vec2(0.65);\n    p -= vec3(rand.x,0.0,rand.y); \n    p.y += 8.0*fract(-hash21(id.xz)*iTime*0.25+hash21(id.zx))-4.0;\n    float sphere = sdSphere(p,0.5);\n    dist = matMin(dist,vec2(sphere,2.0));\n\n    p = pos;\n    float wall = sdWall(p);\n    dist = matMin(dist,vec2(wall,1.0));\n    float roof = sdRF(p);\n    dist = matMin(dist,vec2(roof,2.0));\n\n    p = pos;\n    float tRep = 0.75;\n    vec2 tId = floor(pos.xz/tRep); \n    float lam = hash21(hash22(tId))*2.0 + 0.5;\n     float speed = 2.0*hash21(tId) - 1.0; \n    p.xz = mod(p.xz,tRep) - tRep*0.5;\n    p.y = mod(p.y+speed*iTime,lam) - lam * 0.5;\n    float tile = sdBox(p,vec3(tRep*0.45,lam*0.48,tRep*0.45));\n    float mask = clamp(5.0+4.0*sin(iTime),3.0,4.8);\n    tile = max(tile, -sdBox(pos,vec3(mask)));\n    dist = matMin(dist,vec2(tile,2.0));\n\n    light = min(cube,wall);\n    return vec3(dist,light);\n}\n\nvec3 calcNorm(vec3 pos){\n    float d = 0.0001;\n    return normalize(vec3(\n        map(pos + vec3(  d, 0.0, 0.0)).x - map(pos + vec3( -d, 0.0, 0.0)).x,\n        map(pos + vec3(0.0,   d, 0.0)).x - map(pos + vec3(0.0,  -d, 0.0)).x,\n        map(pos + vec3(0.0, 0.0,   d)).x - map(pos + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nvec3 light = normalize(vec3(0.0,5.0,3.0));\n\nvec3 render(vec3 ro, vec3 rd){\n    vec3 col = vec3(0.0);\n    float gl =  0.0;\n    vec3 col_gl = pal(iTime*0.1, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n    vec3 col_rGl = pal(iTime*0.1+0.3, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n\n    float t = 0.0;\n    vec3 m;\n    vec3 pos;\n    for(int i = 0; i < 64; i++){\n        pos = ro + t*rd;\n      \tm = map(pos);\n        if(m.x < EPS) break;\n        //t += m.x*0.75;\n        //https://qiita.com/ukeyshima/items/221b0384d39f521cad8f\n        t += min(min((step(0.0,rd.x)-fract(pos.x))/rd.x, \n            (step(0.0,rd.z)-fract(pos.z))/rd.z)+0.01,m.x)*0.75;\n        gl += 0.1 / (m.z*m.z*300.0);\n    }\n    pos = ro + t*rd;\n   \n    vec3 norm = calcNorm(pos);\n    vec3 v = normalize(ro-pos);\n    vec3 l = normalize(light-pos);\n    vec3 r = normalize(reflect(rd,norm));\n    \n    t = 0.0;\n    vec3 rRo = pos + norm*0.05;\n    vec3 rPos;\n    vec3 rM;\n    float rGl = 0.0;\n    for(int i = 0; i < 32; i++){\n        rPos = rRo + t * r;\n        rM = map(rPos);\n        if(rM.x < EPS) break;\n        //t += m.x * 0.75;\n        t += min(min((step(0.0,r.x)-fract(rPos.x))/r.x, \n            (step(0.0,r.z)-fract(rPos.z))/r.z)+0.01,rM.x)*0.75;\n        rGl += 0.1 / (rM.z*rM.z*300.0);\n    }\n    \n    float diff = clamp(dot(l, norm), 0.1, 1.0);//diffuse\n   \n    if(m.y == 2.0){\n        col = diff*vec3(0.10) + col_gl*gl + col_rGl*rGl;\n    }else{//grow object\n        col = col_gl * gl;\n    }  \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 p = (fragCoord.xy*2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    if ((iResolution.x/iResolution.y) < (16.0/9.0)){\n        p /= (iResolution.x/iResolution.y) / (16.0/9.0);\n    }\n    \n    vec3 up = vec3(0.,1.,0.);\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    vec3 ro = vec3(0.0,0.75,3.0);\n   \tro.xz *= rotate(iTime*0.25);\n    \n    vec3 cDir = normalize(lookAt-ro);\n    vec3 cSide = normalize(cross(cDir,up));\n    vec3 cUp = normalize(cross(cSide,cDir));\n     \n    vec3 rd= normalize(cSide * p.x + cUp * p.y + cDir * 2.0 );\n \n\tvec3 col = render(ro,rd);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}