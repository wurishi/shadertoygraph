{"ver":"0.1","info":{"id":"ssVSzG","date":"1634861313","viewed":256,"name":"The Ancient Ocean of Terror","username":"drone1","description":"Let me know if you find bugs or have feedback. Thank you!\n\nWould love to make it more performant if anyone has suggestions :)","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["ball"],"hasliked":0,"parentid":"NsKSRy","parentname":"Alien Miner Energy Blob"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAIN_MATERIAL 0.0\n#define HARVESTER_MATERIAL 1.0\n#define MAX_MARCH_Z 115.0\n\n//#define ENABLE_FOG\n#ifdef ENABLE_FOG\n#define FOG_START 10.0\n#define FOG_END -25.0\n#define FOG_COLOR vec3(0.7*0.93)\n#endif\n\nfloat clamp01(float x) {\n    return clamp(x, 0., 1.);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat noise1( sampler3D tex, in vec3 x )\n{\n    return textureLod(tex,(x+0.5)/32.0,0.0).x;\n}\nfloat noise1( sampler2D tex, in vec2 x )\n{\n    return textureLod(tex,(x+0.5)/64.0,0.0).x;\n}\n\nfloat fbm( sampler3D tex, in vec3 x )\n{\n    float f = 0.0;\n    f += 0.5000*noise1(tex,x); x*=2.01;\n    f += 0.2500*noise1(tex,x); x*=2.01;\n    f += 0.1250*noise1(tex,x); x*=2.01;\n    f += 0.0625*noise1(tex,x); x*=2.01;\n    f += 0.0312*noise1(tex,x);\n    return f;\n}\n\n// n must be normalized\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  return dot(p,n) + h;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(in vec3 p, float r) {\n    return length(p)-r;\n}\n\nconst float s = 10.;\n\nfloat blob(in vec3 p, in float tt, in float tide) {\n    vec3 bob = vec3(0.,.2+0.6*sin(tide),0.);\n    vec3 pp = bob+p+vec3(0.05,0.,-.5+0.05*sin(tt));\n    vec3 c = vec3(0.12-0.10*smoothstep(0.5,0.0,p.y));\n    pp = mod(pp+0.5*c,c)-0.5*c;\n    float f = 2.0+8.0*(0.5+0.5*sin(tt*1.5));\n    float s = 0.1*sin(f*p.x)*cos(f*p.y);\n    float ff = 20.0*f;\n    float ss = smoothstep(0.3,0.0,p.y)*0.001*sin(ff*p.x)*cos(ff*p.y);\n    return max(\n        s+sdSphere(p+bob,0.5) + .02*sin(tt+s*p.x)*cos(0.63*tt+s*p.z),\n        ss-sdSphere(pp, 0.001+0.01*(0.5+0.5*sin(tt+pp.x*5.0)))\n    );\n}\n\nvec2 map(in vec3 p) {\n    float tt = 0.1*iTime;\n    vec3 p2 = p;\n    float tide = 0.5+0.5*sin(tt*1.5+p.x*0.015);\n    float terrain = mix(0.0, \n        -0.9+smoothstep(1.0,-3.0,p.z)*\n            (.2-1.5*sin(0.1*p.x)*cos(0.05*p.z)) +\n            smoothstep(-4.0,-10.0,p.z)*\n                   abs(.2-.5*sin(0.1*p.x+tt)*cos(0.1*p.z+tt))+\n                   abs(0.2*smoothstep(0.1,-3.0,p.z)*sin(iTime+p.x)*cos(iTime-p.z))+\n                   0.8+abs(0.03*fbm(iChannel0,20.0*p+vec3(iTime*0.1,iTime*0.1,(1.-2.*tide)*10.0+iTime*0.02))),\n               smoothstep(1.0+2.0*tide, -2.0+2.0*tide, p.z));\n    float d = smin(\n        blob(p, tt, tide),\n        terrain+sdPlane(p2, vec3(0.,1.,0.), 0.5)+0.01*sin(p.x)*cos(p.z),\n        0.6*(0.5+0.5*cos(tt))\n    );\n    vec3 pp = (vec3(p.x,-p.y,p.z)\n        +vec3(15.0,20.0,25.0))/s;\n    vec2 pc = vec2(5.0);\n    vec2 pid = round(pp.xz/pc.xy);\n    pp.xz = mod(pp.xz+0.5*pc,pc)-0.5*pc;\n    float pbob = 1.0*(0.5+0.5*sin(tt+5.*pid.x+100.0*pid.y));\n    float ps = 15.0;\n    pp.y += pbob;\n    float pn = 2.0*fbm(iChannel0,pp);\n    \n    // RAIN\n /*   vec3 rc = vec3(5.0);\n    vec2 rid = round(p.xz/rc.xz);\n    vec3 sp = p;\n//    sp = mod(sp+0.5*rc,rc)-0.5*rc;\n//    vec3 rl = vec3(1000.0);\n//    sp.xz = sp.xz-rc.xz*clamp(round(sp.xz/rc.xz),-rl.xz,rl.xz);\n    sp += vec3(0., .0*-3.*iTime*rid.x*rid.y*1.0, 0.);\n\n    sp.z = mod(sp.z,2.0);\n    d = min(d, sdSphere(sp,0.01+0.02*clamp(rid.x*rid.y,0.,1.0)));\n*/\n    float d2 = max(\n        max(\n            pn+sdPyramid(pp,5.0)*s+clamp01(sin(pp.x*pp.z*3.0+1.+5.5*pp.y)),\n            -sdBox(pp,vec3(100.0,0.1,100.0))\n        ),\n        sdPlane(p, vec3(0.,-1.,0.), .1)\n    );\n    if (d < d2) return vec2(d, MAIN_MATERIAL);\n    return vec2(d2, HARVESTER_MATERIAL);\n}\n\nfloat march(in vec3 eye, in vec3 dir) {\n    float t = 0.0;\n    \n    for (int i=0; i<100; ++i) {\n        vec3 p = eye + t*dir;\n        vec2 res = map(p);\n        float d = res.x;\n        float mat = res.y;\n\n        if (t > MAX_MARCH_Z)\n            return -1.0;\n        else if (d < 0.001)\n            break;\n\n        t += .9*d;\n    }\n    \n    return t;\n}\n\nvec3 norm( in vec3 p) \n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0 );\n\n\treturn normalize( vec3( map(p+eps.xyy).x - map(p-eps.xyy).x,\n\t\t\t\tmap(p+eps.yxy).x - map(p-eps.yxy).x,\n\t\t\t\tmap(p+eps.yyx).x - map(p-eps.yyx).x ) );\n}\n\nfloat skyTex(in vec3 uv) {\n    vec3 np = 5.0*uv+ \n        vec3(iTime*.02,13423.0,234.0);\n    return fbm(iChannel0,np);\n}\n\nvec3 skyNorm( in vec3 p) \n{\n\tvec3 eps = vec3(0.05, 0.0, 0.0 );\n\n\treturn normalize( vec3( skyTex(p+eps.xyy) - skyTex(p-eps.xyy),\n\t\t\t\tskyTex(p+eps.yxy) - skyTex(p-eps.yxy),\n\t\t\t\tskyTex(p+eps.yyx) - skyTex(p-eps.yyx) ) );\n}\n\nfloat sky(in vec3 eye, in vec3 dir, in vec2 uv) {\n    float g = 1.2*(uv.x+2.0)*pow(dir.y*1.1,1.2); // gradient\n    vec3 p = vec3(0.5*uv,-20.0);\n    vec3 sn = skyNorm(p);\n    vec3 moonPos = normalize(vec3(1.0));\n    float diff = max(0., dot(sn,moonPos));\n    return pow(\n        min(\n            g*.8*pow(skyTex(p),0.2)*(.8+0.2*diff),\n            2.0\n        )*.85,\n        .5\n    );\n}\n\n// iq\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 light(in vec3 eye, in vec3 dir, in vec3 p, float t) {\n    vec3 amb = vec3(0.08);\n    vec3 n = norm(p);\n    vec3 light_pos = vec3(1.0);\n    vec3 diff = 0.5*vec3(max(0.0,dot(normalize(light_pos-p),n)));\n    float h = pow(max(0.0,p.y+0.49),0.3);\n    diff.r += h-.1*smoothstep(1.0,-1.0,p.x)-smoothstep(5.2,-10.8,p.z);\n    diff.g += 0.4*h;\n    diff.b += 0.6*h;\n    diff.rg += 0.1*smoothstep(-0.5,-3.0,p.z);\n    diff = 0.7*min(diff,vec3(1.0));\n    diff = pow(diff, vec3(1.5));\n    vec3 spec = vec3(pow(\n        max(0.0,dot(n, normalize(-light_pos))),\n            .01\n    ));\n    float sk = sky(eye, dir, p.xz);\n\n    vec3 o = amb+min(1.0,0.3+n.y)*(min(1.0,0.2+.8*sk)*spec+diff);\n    \n    // LIGHT2 - LEFT\n    o += max(0.0, dot(n, normalize(vec3(-1.0,-.1,-0.2)))) *\n        5.0*vec3(0.137,0.137,0.20);\n       \n    // LIGHT3 - LEFT\n    o += max(0.0, dot(n, normalize(vec3(1.0,-.1,-0.2)))) *\n        1.0*vec3(0.137,0.137,0.20);\n        \n    // SHADOW\n    float sh = shadow(p, normalize(light_pos-p), 0.1, length(p-light_pos));\n    o = (0.5+min(1.,sh))*o;\n    \n    // Add some color with depth of scene\n#ifdef ENABLE_FOG\n    float fog = clamp01((FOG_START-p.z)/abs(FOG_END-FOG_START));\n    fog = clamp01(pow(fog, 0.5));\n    o += 0.5*vec3(0.22, 0.2, 0.08)*fog;\n\n    float intensity = 0.21*o.r+0.72*o.g+0.07*o.b;\n    //o = mix(o, mix(FOG_COLOR, o, 0.5*intensity), pow(fog,128.));\n    o = mix(o, FOG_COLOR, 1.0-exp( -0.0001*t*t*t ) );\n#endif\n    return o;\n}\n\nvec3 sun(in vec2 uv, in vec3 sk) {\n    vec2 delta = vec2(1.1, 0.7)-uv;\n    float distToSun = length(delta)+.01*sin(iTime+100.0*delta.x*delta.y);\n    float r = 0.1*sin(iTime+5.*atan(delta.y,delta.x));\n    return sk + \n        pow(\n            smoothstep(0.5+.3*(.5+.5*sin(r+iTime*.1)), 0.0, distToSun),\n            5.0\n        )*2.0*vec3(1.0, 1.0, 0.8)*(1.-sk);\n}\n\nvec3 render(in vec2 uv) {\n    vec3 eye = vec3(0.,-0.3+.3*(.5+.5*sin(iTime*.01)),1.9);\n    vec3 dir = normalize(vec3(uv.xy,0.0)-eye);\n    float t = march(eye, dir);\n    vec3 col;\n    if (t < 0.0) {\n        vec3 s = sun(uv, sky(eye, dir, uv) *\n            5.0*vec3(0.1-.02*(uv.x-1.3),0.11,0.12+0.01*uv.y));\n#ifdef ENABLE_FOG\n        col = mix(s, FOG_COLOR, clamp01(1.0-uv.y));\n        float x = .35*MAX_MARCH_Z;\n        col = mix(s, FOG_COLOR, 1.0-exp( -0.0001*x*x*x ) );\n#else\n        col = s;\n#endif\n   } else {\n        col = light(eye, dir, eye+t*dir, t);\n    }\n    col = pow(col, vec3(2.3));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = (-1.+2.*fragCoord/iResolution.xy);\n    uv.x *= aspect;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}