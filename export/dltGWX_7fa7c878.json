{"ver":"0.1","info":{"id":"dltGWX","date":"1683262647","viewed":46,"name":"CS-6366-Project","username":"ani1311","description":"Project for CS-6366","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cs6366"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPISILON.0001\nconst float PI=3.14159265359;\nconst int MAX_MARCHING_STEPS=255;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=100.;\nconst float PRECISION=.001;\n\nstruct Material{\n    vec3 ambientColor;// k_a * i_a\n    vec3 diffuseColor;// k_d * i_d\n    vec3 specularColor;// k_s * i_s\n    float alpha;// shininess\n};\n\nstruct Surface{\n    int id;// id of object\n    float sd;// signed distance\n    Material mat;\n};\n\nMaterial materialWithColor(vec3 color){\n    return Material(color*.1,color*.6,color*.9,.1);\n}\nMaterial gold(){\n    vec3 aCol=.5*vec3(.7,.5,0);\n    vec3 dCol=.6*vec3(.7,.7,0);\n    vec3 sCol=.6*vec3(1,1,1);\n    float a=5.;\n    \n    return Material(aCol,dCol,sCol,a);\n}\n\nMaterial silver(){\n    vec3 aCol=.4*vec3(.8);\n    vec3 dCol=.5*vec3(.7);\n    vec3 sCol=.6*vec3(1,1,1);\n    float a=5.;\n    \n    return Material(aCol,dCol,sCol,a);\n}\n\n// Rotate around a circular path\nmat2 rotate2d(float theta){\n    float s=sin(theta),c=cos(theta);\n    return mat2(c,-s,s,c);\n}\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta){\n    float c=cos(theta);\n    float s=sin(theta);\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,c,-s),\n        vec3(0,s,c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta){\n    float c=cos(theta);\n    float s=sin(theta);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta){\n    float c=cos(theta);\n    float s=sin(theta);\n    return mat3(\n        vec3(c,-s,0),\n        vec3(s,c,0),\n        vec3(0,0,1)\n    );\n}\n\n// Identity matrix.\nmat3 identity(){\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1)\n    );\n}\n\n//----------------------------------------------------\n// perlin noise stuff\nfloat hash(float n){\n    return fract(sin(n)*43758.5453);\n}\n\n// Function for interpolating between two values using a smooth curve\nfloat smoothFn(float t){\n    return t*t*t*(t*(t*6.-15.)+10.);\n}\n\n// Function for generating 2D gradients\nvec2 grad2(float n){\n    return vec2(cos(n*2.*3.14159265359),sin(n*2.*3.14159265359));\n}\n\n// Function for generating 2D Perlin noise\nfloat perlinNoise(vec2 p){\n    vec2 pi=floor(p);\n    vec2 pf=fract(p);\n    float h00=hash(pi.x+hash(pi.y));\n    float h01=hash(pi.x+hash(pi.y+1.));\n    float h10=hash(pi.x+1.+hash(pi.y));\n    float h11=hash(pi.x+1.+hash(pi.y+1.));\n    \n    vec2 g00=grad2(h00);\n    vec2 g01=grad2(h01);\n    vec2 g10=grad2(h10);\n    vec2 g11=grad2(h11);\n    \n    vec2 d00=pf;\n    vec2 d01=pf-vec2(0.,1.);\n    vec2 d10=pf-vec2(1.,0.);\n    vec2 d11=pf-vec2(1.,1.);\n    \n    float s00=dot(g00,d00);\n    float s01=dot(g01,d01);\n    float s10=dot(g10,d10);\n    float s11=dot(g11,d11);\n    \n    vec2 fade=vec2(smoothFn(pf.x),smoothFn(pf.y));\n    float mix1=mix(s00,s10,fade.x);\n    float mix2=mix(s01,s11,fade.x);\n    \n    return mix(mix1,mix2,fade.y)*.5+.5;\n}\n\n// ----------------------------------------------------\n\nSurface sdfGround(vec3 p,float h,vec3 baseColor){\n    float height=perlinNoise(2.*vec2(p.xz*2.));\n    float displacement=height*.08;\n    float d=p.y-h-displacement;\n    \n    vec3 color=mix(vec3(1.,.8745,.3725),baseColor,height*.5+.5);\n    Material m=Material(color*.2,color*.01,color*.1,.1);\n    return Surface(0,d,m);\n}\n\nSurface sdfSphere(vec3 p,vec3 c,float r,vec3 color){\n    Material m=gold();\n    return Surface(1,length(p-c)-r,m);\n}\n\nfloat random(vec2 st){\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nSurface minWithColor(Surface a,Surface b){\n    if(a.sd<b.sd){\n        return a;\n    }else{\n        return b;\n    }\n}\n\nvec3 movingSpherePosition(float time){\n    float x=sin(time*.5)*11.5;\n    float y=cos(time*.7)*2.5+3.;\n    float z=sin(time*.3)*20.5-22.;\n    return vec3(x,y,z);\n}\n\n// SDF cylinder for the tree trunk\nSurface sdfTreeTrunk(vec3 p,vec3 center,float r,float h,vec3 color){\n    vec3 centered_p=p-center;\n    vec2 d=abs(vec2(length(centered_p.xz),centered_p.y))-vec2(r,h*.5);\n    Material m=materialWithColor(color);\n    return Surface(1,min(max(d.x,d.y),0.)+length(max(d,0.)),m);\n}\n\n// SDF sphere for the tree foliage\nSurface sdfTreeFoliage(vec3 p,vec3 center,float r,vec3 color){\n    // return vec4(length(p-center)-r,color);\n    Material m=materialWithColor(color);\n    return Surface(2,length(p-center)-r,m);\n}\n\n// SDF for a torus\nSurface sdfTorus(vec3 p,vec3 center,float r1,float r2,vec3 color){\n    vec2 q=vec2(length(p.xz-center.xz)-r1,p.y-center.y);\n    Material m=materialWithColor(color);\n    return Surface(3,length(q)-r2,m);\n}\n\nvec3 orbitingTorusPosition(float time){\n    float angle=time*.5;\n    float radius=1.;\n    vec3 center=vec3(0.,2.,0.);\n    vec3 pos=center+radius*vec3(cos(angle),0.,sin(angle));\n    return pos;\n}\n\nfloat smoothMin(float a,float b,float k){\n    float h=clamp(.5+.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nSurface blendSDFs(Surface a,Surface b,float k){\n    float blendedSDF=smoothMin(a.sd,b.sd,k);\n    return Surface(4,blendedSDF,a.mat);\n}\n\nSurface sdfTree(vec3 p){\n    float c=11.;\n    p.xz=mod(p.xz+.5*c,c)-.5*c;\n    \n    ivec2 cellIndex=ivec2(floor((p.xz+.5*c)/c));\n    \n    // Generate random values for height, trunk radius, and torus radius\n    float randomHeight=mix(2.,4.,random(vec2(cellIndex)));\n    float randomTrunkRadius=mix(.1,3.3,random(vec2(cellIndex+ivec2(1337,4242))));\n    float randomTorusRadius=mix(.1,.9,random(vec2(cellIndex+ivec2(2141,6879))));\n    \n    Surface tree=minWithColor(\n        sdfTreeTrunk(p,vec3(0.,0.,0.),randomTrunkRadius,randomHeight,vec3(.4,.2,.1)),\n        sdfTreeFoliage(p,vec3(0.,randomHeight,0.),1.5,vec3(0.,.8,0.))\n    );\n    \n    vec3 torusCenter=orbitingTorusPosition(iTime);\n    Surface torus=sdfTorus(p,torusCenter,1.,randomTorusRadius,vec3(.3,.6,1.));\n    \n    float blendSmoothness=.5;\n    \n    Surface res=blendSDFs(tree,torus,blendSmoothness);\n    \n    return res;\n}\n\nSurface sdScene(vec3 p){\n    Surface d=sdfGround(p,0.,vec3(.58,.29,0.));\n    \n    d=minWithColor(d,sdfGround(p,-1.,vec3(.58,.29,0.)));\n    \n    d=minWithColor(d,sdfTree(p));\n    \n    vec3 spherePos=movingSpherePosition(iTime);\n    float sphereRadius=.7;\n    \n    Surface sphere=sdfSphere(p,spherePos,sphereRadius,vec3(1.,0.,0.));\n    \n    d=minWithColor(d,sphere);\n    \n    return d;\n}\n\nSurface rayMarch(vec3 ro,vec3 rd){\n    float depth=MIN_DIST;\n    Surface co;\n    \n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        vec3 p=ro+depth*rd;\n        co=sdScene(p);\n        depth+=co.sd;\n        if(co.sd<PRECISION||depth>MAX_DIST)break;\n    }\n    \n    co.sd=depth;\n    \n    return co;\n}\n\nvec3 calcNormal(vec3 p){\n    vec2 e=vec2(1.,-1.)*.0005;\n    return normalize(\n        e.xyy*sdScene(p+e.xyy).sd+\n        e.yyx*sdScene(p+e.yyx).sd+\n        e.yxy*sdScene(p+e.yxy).sd+\n        e.xxx*sdScene(p+e.xxx).sd\n    );\n}\n\nfloat fractalNoise(vec2 p){\n    float f=0.;\n    float scale=1.;\n    for(int i=0;i<4;i++){\n        f+=perlinNoise(p*scale)/scale;\n        scale*=2.;\n    }\n    return f;\n}\n\nmat3 camera(vec3 cameraPos,vec3 lookAtPoint){\n    vec3 cd=normalize(lookAtPoint-cameraPos);// camera direction\n    vec3 cr=normalize(cross(vec3(0,1,0),cd));// camera right\n    vec3 cu=normalize(cross(cd,cr));// camera up\n    \n    return mat3(-cr,cu,-cd);\n}\n\nvec3 phong(vec3 lightDir,vec3 normal,vec3 rd,Material mat){\n    // ambient\n    vec3 ambient=mat.ambientColor;\n    \n    // diffuse\n    float dotLN=clamp(dot(lightDir,normal),0.,1.);\n    vec3 diffuse=mat.diffuseColor*dotLN;\n    \n    // specular\n    float dotRV=clamp(dot(reflect(lightDir,normal),-rd),0.,1.);\n    vec3 specular=mat.specularColor*pow(dotRV,mat.alpha);\n    \n    return ambient+diffuse+specular;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv=fragCoord/iResolution.xy;\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseUV=iMouse.xy/iResolution.xy;// Range: <0, 1>\n    mouseUV-=.5;\n    mouseUV.x*=2.;\n    mouseUV.y*=.4;\n    mouseUV.y+=.3;\n    \n    vec3 lp=vec3(0,.5,-4);// lookat point (aka camera target)\n    // vec3 ro=vec3(0,5,0);// ray origin that represents camera position\n    \n    // Calculate time-dependent camera offset in x direction\n    // float x_offset=4.*sin(iTime*.5)+2.;\n    float x_offset=2.;\n    \n    vec3 ro=vec3(\n        x_offset,\n        5.,\n        0.\n    );\n    \n    float cameraRadius=2.;\n    ro.yz=ro.yz*cameraRadius*rotate2d(mix(PI/2.,0.,mouseUV.y));\n    ro.xz=ro.xz*rotate2d(mix(-PI,PI,mouseUV.x))+vec2(lp.x,lp.z);\n    \n    vec3 rd=camera(ro,lp)*normalize(vec3(uv,-1.));// ray direction\n    \n    // vec3 ro=vec3(0.,0.,3.);\n    // vec3 rd=normalize(vec3(uv,-1.));\n    \n    Surface co=rayMarch(ro,rd);\n    \n    // Calculate fractal noise for the sky\n    float skyNoise=fractalNoise(uv*10.);\n    vec3 skyColor=mix(vec3(0.,0.,.9882),vec3(.9,.9,1.),skyNoise);\n    \n    vec3 bgCol=vec3(1.,1.,1.);\n    vec3 col=vec3(0.);\n    if(co.sd>=MAX_DIST){\n        col=skyColor;\n        \n    }else{\n        vec3 p=ro+rd*co.sd;\n        vec3 n=calcNormal(p);\n        \n        // light #1\n        vec3 lightPosition1=vec3(-8,-6,-5);\n        vec3 lightDirection1=normalize(lightPosition1-p);\n        float lightIntensity1=.9;\n        \n        // light #2\n        vec3 lightPosition2=vec3(1,1,1);\n        vec3 lightDirection2=normalize(lightPosition2-p);\n        float lightIntensity2=.5;\n        \n        // final color of object\n        col=lightIntensity1*phong(lightDirection1,n,rd,co.mat);\n        col+=lightIntensity2*phong(lightDirection2,n,rd,co.mat);\n        \n        // float diff=max(0.,dot(n,lightDir));\n        \n        // col=co.yzw*diff+.1*bgCol;\n    }\n    \n    // Output to screen\n    fragColor=vec4(col,1.);\n}\n","name":"Image","description":"","type":"image"}]}