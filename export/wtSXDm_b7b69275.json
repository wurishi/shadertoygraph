{"ver":"0.1","info":{"id":"wtSXDm","date":"1566096648","viewed":198,"name":"hair-corruption-test","username":"gankra","description":"Test of an effect where a character's hair smears across the screen glitchily","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float inEar(vec2 earPos, vec2 coord) {\n\tvec2 delta = earPos - coord;\n    return step(-delta.y + abs(delta.x * 2.0), earSize) \n        * step(delta.y, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{     \n    // This is all just a ton of jank to draw the fur and face\n    vec2 charPos = getSnappedPos(iTime, iResolution.xy);\n    vec2 coord = snap(fragCoord);\n    \n    vec2 headPos = charPos + headOffset;\n    vec2 ear1Pos = charPos + ear1Offset;\n    vec2 ear2Pos = charPos + ear2Offset;\n    vec2 hairPuffPos = charPos + hairPuffOffset;\n    vec2 eye1Pos = charPos + eye1Offset;\n    vec2 eye2Pos = charPos + eye2Offset;\n    vec2 mouthPos = charPos + mouthOffset;\n    vec2 bodPos = charPos + bodOffset;\n    vec2 legPos = charPos + legOffset;\n    \n    vec2 headDist = headPos - coord;\n    float insideHead = step(length(headDist), headRadius);\n    float insideFur = max(max(max(max(\n        insideHead, \n        inEar(ear1Pos, coord)), \n        inEar(ear2Pos, coord)), \n        inRect(coord, bodPos, bodSize)),\n        inRect(coord, legPos, legSize));\n    \n    // Mask out part of the head with a parabolic hairline\n    float x = headDist.x + 10.0;\n    float underHair = max(step(30.0, (0.02 * x * x - headDist.y) * insideHead),\n                          inCircle(coord, hairPuffPos, hairPuffRadius));\n    \n    // Cover everything with face\n    float underEyes = max(max(inRect(coord, eye1Pos, eyeSize), \n                          inRect(coord, eye2Pos, eyeSize)),\n                          inRect(coord, mouthPos, mouthSize));\n    \n    // Draw the fur/face on top of the hair\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 hair = texture(iChannel1, uv);\n    \n    vec4 layer1 = mix(hair, vec4(furColor, 1.0), insideFur * (1.0 - underHair));\n    vec4 layer2 = mix(layer1, vec4(eyeColor, 1.0), underEyes);\n\tfragColor = layer2;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Buffer A contains the \"fresh\" hair that\n    // gets fed into Buffer B to get corrupted.\n    \n    // This could probably just be inlined into the code\n    // for Buffer B, but I wanted that to be focused on\n    // the effect and not how the fresh hair was formed.\n    \n    // This is just boring shape drawing\n    vec2 charPos = getSnappedPos(iTime, iResolution.xy);\n    vec2 coord = snap(fragCoord);\n    \n    vec2 hairPos = charPos + hairOffset;\n    vec2 hairPuffPos = charPos + hairPuffOffset;\n    float insideHair = max(inCircle(coord, hairPos, hairRadius),\n                           inCircle(coord, hairPuffPos, hairPuffRadius));\n  \n    fragColor = vec4(hairColor, insideHair);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    // This shader creates a fading effect by repeatedly drawing\n    // the previous frame back into itself. New content is overlaid\n    // using transparency, and old content has a random chance\n    // of decaying away.\n    \n    // Decay is currently implemented by just hashing (fnv) position\n    // and time together, and checking if the hash is big or small.\n    // We chunk positions together into randomly sized blocks to \n    // look more like random corruptions.\n    float minBlockSize = pixelSize;\n    float maxBlockSize = pixelSize * 8.0;\n    \n    // chunk randomly-ish\n    vec2 blockSize = snap(max(vec2(minBlockSize),\n                         vec2(mod(iTime * 173.0, maxBlockSize), \n                              mod(iTime * 241.0, maxBlockSize))));\n    vec2 roundedCoord = floor(fragCoord / blockSize) * blockSize;\n    \n    // weight chance of decay by area, because an entire block\n    // only gets one chance to decay, and a tiny block and a\n    // big block having the same odds doesn't look great\n    // (256 is impossible, 0 is guaranteed)\n    float decayChance = 245.0 + 10.0 / (maxBlockSize * maxBlockSize) * (blockSize.x * blockSize.y);\n    \n    \n    // compute decay for the chunk\n    int hash = fnv(fnv(fnv(0, roundedCoord.x), roundedCoord.y), iTime);\n    int mergedHash = byte(hash, 0) ^ byte(hash, 1) ^ byte(hash, 2) ^ byte(hash, 3);\n    float decay = step(float(mergedHash), decayChance);\n    \n    // merge old and new while applying decay\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 old = texture(iChannel1, uv);\n    vec4 new = texture(iChannel0, uv);\n    fragColor = mix(mix(vec4(0.0), old, decay), new, new.w);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// lol why did i do this\nconst float pixelSize = 4.0;\nconst vec3 hairColor = vec3(55.0, 180.0, 224.0) / 255.0;\nconst vec3 furColor = vec3(177.0, 66.0, 72.0) / 255.0;\nconst vec3 eyeColor = vec3(0.0);\n\nconst float headRadius = 12.0 * pixelSize;\nconst vec2 headOffset = vec2(0.0) * pixelSize;\n\nconst vec2 ear1Offset = headOffset + vec2(-7.0, 6.0) * pixelSize;\nconst vec2 ear2Offset = headOffset + vec2(4.0, 7.0) * pixelSize;\nconst float earSize = 8.0 * pixelSize;\n\nconst float hairRadius = 12.0 * pixelSize;\nconst vec2 hairOffset = headOffset + vec2(-2.0, 2.0) * pixelSize;\n\nconst vec2 hairPuffOffset = headOffset + vec2(-12.0, 0.0) * pixelSize;\nconst float hairPuffRadius = 6.0 * pixelSize;\n\nconst vec2 eye1Offset = headOffset + vec2(-2.0, 0.0) * pixelSize;\nconst vec2 eye2Offset = headOffset + vec2(6.0, 0.0) * pixelSize;\nconst vec2 eyeSize = vec2(4.0, 1.0) * pixelSize;\n\nconst vec2 mouthOffset = headOffset + vec2(0.0, -6.0) * pixelSize;\nconst vec2 mouthSize = vec2(5.0, 1.0) * pixelSize;\n\nconst vec2 bodOffset = headOffset + vec2(-8.0, -30.0) * pixelSize;\nconst vec2 bodSize = vec2(15.0, 30.0) * pixelSize;\n\nconst vec2 legOffset = bodOffset + vec2(2.0, -10.0) * pixelSize;\nconst vec2 legSize = vec2(10.0, 10.0) * pixelSize;\n\n\n\n\nint byte(int val, int byteNum) {\n    int offset = byteNum * 8;\n\treturn (val & (0xff << offset)) >> offset;\n}\n\nint fnv(int curHash, float newData) {\n    int data = floatBitsToInt(newData);\n    \n    // fixed iteration loops are just sugar for copy-pasting code :p\n    for (int i=0; i<4; ++i) {\n    \tcurHash = curHash ^ byte(data, i);\n    \tcurHash = curHash * 0x100001b3;\n    }\n    return curHash;\n}\n\nvec2 snap(vec2 point) {\n    return floor(point / pixelSize) * pixelSize;\n}\n\n// unused, too tedious and stiff\nvec2 getPosKeyed(float time) {\n    vec2 keyFrames[4];\n    keyFrames[0] = vec2(0.2, 0.2);\n    keyFrames[1] = vec2(0.5, 0.5),\n    keyFrames[2] = vec2(0.3, 0.8),\n    keyFrames[3] = vec2(0.2, 0.2);\n                \n    float animTime = 4.0;\n    float pos = mod(time, animTime) / animTime * float(keyFrames.length() - 1);\n    float firstFrame = floor(pos);\n    float secondFrame = ceil(pos);\n    float tween = pos - firstFrame;\n    \n    return mix(keyFrames[int(firstFrame)], keyFrames[int(secondFrame)], tween);\n}\n\nvec2 getPosPattern(float time) {\n\treturn vec2(0.5 + 0.35 * sin(time * 1.5 + 0.79),\n                0.6 + 0.10 * sin(time * 5.5)); \n}\n\nvec2 getPos(float time) {\n\treturn getPosPattern(time);\n}\n\nvec2 getSnappedPos(float time, vec2 resolution) {\n    float scale = min(resolution.x, resolution.y);\n    vec2 scale2 = resolution.xy / scale;\n    \n    float scaledTime = time / scale * 400.0;\n    \n    vec2 pos = getPos(scaledTime) * scale2;\n    return snap(pos * scale);\n}\n\nfloat inCircle(vec2 point, vec2 origin, float radius) {\n\treturn step(distance(point, origin), radius);\n}\n\nfloat inRect(vec2 point, vec2 origin, vec2 bounds) {\n\treturn float(point.x >= origin.x && \n                 point.y >= origin.y && \n                 point.x < origin.x + bounds.x &&\n                 point.y < origin.y + bounds.y);\n}","name":"Common","description":"","type":"common"}]}