{"ver":"0.1","info":{"id":"4fjSR1","date":"1706632227","viewed":45,"name":"Leaning about Ray Marching","username":"Blue_ish","description":"I'm just learning about ray marching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","testing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec4 unionSDF(vec4 a, vec4 b) {\n    return a.w < b.w? a : b;\n}\n\nvec4 intersectSDF(vec4 a, vec4 b) {\n    return a.w > b.w? a : b;\n}\n\nvec4 differenceSDF(vec4 a, vec4 b) {\n    return a.w > -b.w? a : -b;\n}\n\nfloat DE(vec3 pos, float Power) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 30 ; i++) {\n\t\tr = length(z);\n\t\tif (r>2.0) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat sphereSDF(vec3 rayPos, vec3 shapePos, float radius)\n{\n    return length(shapePos-rayPos)-radius;\n}\n\nfloat boxFrameSDF( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec4 SceneSDF(vec3 cameraPos)\n{\n    vec2 uMouse = (iMouse.xy/iResolution.xy)*2.-1.;\n    \n    /*\n    vec3 current = (cameraPos.xyz-vec3(0.0, 0.0, -3.));\n    current.zxy*=rotateX(-uMouse.y*3.0);\n    current*=rotateX(uMouse.x*3.0);\n    return vec4(0.,0.,1.,DE(vec3(current.x, current.y, current.z)*.8, iTime/10.0+1.0));\n    */\n\n    /*\n    vec3 current = (cameraPos.xyz)*rotateX(radians(cos(iTime)*20.0));\n    current.yzx *= rotateX(radians(sin(iTime)*10.0));\n    current = fract(current+vec3(0.0, 0.0, iTime)) - 0.5;\n    current = current.zxy*rotateX(radians(iTime*45.0));\n    \n    float a = 20.0;\n    float dis = sin(a*current.x)*sin(a*current.y)*sin(a*current.z)*0.04;\n    float sphere = sphereSDF(current, vec3(0.0), 0.25);\n    \n    return vec4(1.0, 0.0, 0.0, sphere+dis);\n    */\n    \n    cameraPos *= rotateX(radians(uMouse.x*180.));\n    \n    \n    float s = sphereSDF(cameraPos, vec3(-2., cos(iTime), -2.0), .5);\n    vec3 ballPos = vec3(1.*sin(1.*sin(1.*iTime)), -1.*cos(1.*sin(1.*iTime)), -2.);\n    float s0 = sphereSDF(cameraPos, ballPos, .4);\n    float f = cameraPos.y+2.;//+sin(cameraPos.x*.4)+2.;\n    float b = boxFrameSDF((cameraPos-vec3(2.,0.,0.))*rotateX(radians(iTime*45.)), vec3(1.,1.,1.), .1);\n    \n    return unionSDF(vec4(.3,.3,1.,b), unionSDF(vec4(1., .5, .3, s0), unionSDF(vec4(.4, .9, .3, f), vec4(.8, 0.3, 0.9, s))));\n    \n}\n\nvec3 findNormal(vec3 hitPoint)\n{\n    vec2 offset = vec2(0.001, 0.0);\n    \n    float gradientX = (SceneSDF(hitPoint+offset.xyy)-SceneSDF(hitPoint-offset.xyy)).w;\n    float gradientY = (SceneSDF(hitPoint+offset.yxy)-SceneSDF(hitPoint-offset.yxy)).w;\n    float gradientZ = (SceneSDF(hitPoint+offset.yyx)-SceneSDF(hitPoint-offset.yyx)).w;\n    \n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\nfloat shadowMarch(vec3 cameraPos, vec3 ray, float Max_Distance)\n{\n    const float Min_Distance = 0.001;\n    int Num_Steps = 128;\n    \n    float distanceTraveled = 0.;\n    vec4 closest;\n    float shaded = 1.;\n    \n    for(int i=0; i<Num_Steps; i++)\n    {\n        \n        vec3 currentPos = cameraPos + distanceTraveled*ray;\n        \n        // find distance to travel next loop\n        closest = SceneSDF(currentPos);\n        \n        // go past the light\n        if(distanceTraveled > Max_Distance)\n        {\n            return 1.;\n            return shaded;\n        }\n        \n        // hit object\n        if(closest.w < Min_Distance)\n        {\n            return 0.5;\n            //break;\n        }\n        \n        // move along ray\n        distanceTraveled += max(closest.w, 0.02);\n        \n        shaded = min(shaded, (closest.w/distanceTraveled));\n    }\n    return 0.5;\n}\n\n\nvec3 rayMarch(vec3 cameraPos, vec3 ray)\n{\n    vec2 uMouse = (iMouse.xy/iResolution.xy)*2.-1.;\n    float Max_Distance = 64.;\n    const float Min_Distance = .001;\n    int Num_Steps = 128;\n    \n    float distanceTraveled = 0.0;\n    vec4 closest;\n    \n    for(int i=0; i<Num_Steps; i++)\n    {\n        \n        vec3 currentPos = cameraPos + distanceTraveled*ray;\n        \n        // find distance to travel next loop\n        closest = SceneSDF(currentPos);\n        \n        // hit object\n        if(closest.w < Min_Distance)\n        {\n            vec3 color = closest.xyz;\n            \n            //surface normal\n            vec3 normal = findNormal(currentPos);\n            \n            //light position\n            vec3 light = vec3(2.0, 2.0, -2.);\n            vec3 lightColor = vec3(1.);\n            light *= rotateX(radians(-uMouse.x*180.));\n            \n            //vector facing the light\n            vec3 directionToLight = normalize(light-currentPos);\n            \n            \n            // ambient\n            float ambientStrength = 0.1;\n            float ambient = ambientStrength;\n            \n            //diffuse lighting\n            \n            float diffuseStrength = .75;\n            float diffIntensity = max(0.0, dot(normal, directionToLight));\n            float diffuse = diffuseStrength * diffIntensity;\n            \n            //specular lighting\n            \n            float specularStrength = 0.25;\n            float specIntensity = max(0.0, dot(directionToLight, normalize(reflect(ray, normal))));\n            float specular = specularStrength * pow(specIntensity, 32.);\n            \n            color *= (ambient+diffuse+specular)*lightColor;\n            \n            //shadows\n            \n            float dist = shadowMarch(currentPos+normal*.1, directionToLight, length(light-currentPos));\n            \n            /*\n            //if it didn't hit the light\n            if(dist < length(light-currentPos))\n            {\n                color *= .5;\n            }\n            */\n            \n            color *= dist;\n            \n            //gamma correction\n            color = pow(color, vec3(1./2.2));//*3.;///distanceTraveled;\n            \n            return color;\n        }\n        \n        // out of bounds\n        if(distanceTraveled > Max_Distance)\n        {\n            return vec3(0., .6, 0.6);\n        }\n        \n        // move along ray\n        distanceTraveled += closest.w;\n    }\n    return vec3(0.);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.0-1.0;\n    uv*=vec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 col = rayMarch(vec3(0.0, 0.0, -5.0), normalize(vec3(uv, 1.0))).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}