{"ver":"0.1","info":{"id":"fldyRH","date":"1659275883","viewed":99,"name":"Fork Drop Impac - Normal diff","username":"mehow_one","description":"Practicing my hash routines.\n\nSimulation of water droplets hitting a solid surface.\nWe can have a pretty good close form solution for the profile of a drop impacting and spreading on a solid surface","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["simulation","water","droplet","impact"],"hasliked":0,"parentid":"3sjXDh","parentname":"Drop Impact on a Solid Surface"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n    \n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://people.maths.bris.ac.uk/~majge/retractionPOF.pdf\n// http://www.off-ladhyx.polytechnique.fr/people/josserand/papier/annrev.pdf\n// https://www.researchgate.net/publication/258661354_Spreading_dynamics_of_drop_impacts\n\n\n// ALL THE HASHES ! https://www.shadertoy.com/view/4djSRW\n\n#define displayNormalMap\n#define normalStrength 120.0\n#define simulationSpeed 5.0\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nconst float timefloor = 10.;\nconst float timeceil = 10.;\nconst float averageRadius = 20.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float globalH = 0.0;\n    const int NDroplets = 4;\n    float seed = hash11(floor(iTime*0.1))*100.;\n    \n    for(int i = 0; i < NDroplets; i++)\n    {\n        vec2 uv_droplets = 0.25 + hash21(float(i*200)+seed)*.5;\n        float r = length(uv_droplets-uv);\n        r *= averageRadius / (hash11(float(i+128))*.5+.25);\n        float off = timefloor + hash11(float(i+64))*timeceil;\n        float t = mod(simulationSpeed * iTime, off);\n        \n        float h = 4.0/(t*t) * 1.0/pow(1.0 + 0.625*(r/t)*(r/t),6.0);\n        globalH += h;//min(globalH+h,1.0);\n    }\n\tglobalH = min(globalH,1.0);\n    \n    float dHdx = normalStrength*dFdx(globalH);\n    float dHdy = normalStrength*dFdy(globalH);\n\tvec3 N = vec3(dHdx,dHdy,1.0);\n    N = normalize(N);\n\n    // Output to screen\n    fragColor = vec4(globalH);\n    #ifdef displayNormalMap\n        fragColor = vec4(0.5*N+0.5,0.0);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"}]}