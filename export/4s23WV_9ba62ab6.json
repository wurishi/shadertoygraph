{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n  email: muuuusk at gmail dot com\n\n2016-02-02:\n\n  Added fixes to make it more compatible.\n  Also added some comments + shading improvements\n  By now you can use a multipass aproach, \n  this method was for tha times when passes were not avaiable.\n\n\n2014-03-01:\n\n  Derivative based edge detection. \n  dFdx() and dFdy() are applied to the surface normal. \n  It will detect discontinuities in the normal.\n\n*/\n\n#define BACKGROUND_COLOR vec3(1.0)\n#define EDGE_COLOR vec3(0.0)\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n// a short hand for time, because I hate typing out iTime\n#define t (iTime - 4.0)\n\nfloat df_back(vec3 p)\n{\n\treturn (16.0-length(p));\n}\n\n//the rotation of the object\n#define rot (rotate_x(t*.5)*rotate_y(t*.5)*rotate_z(t*.5))\n#define trans (vec3(sin(t),cos(t),sin(t))*.1)\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n//distance function for the rotating object\nfloat df_obj(vec3 p)\n{\n\tp += trans;\n\tp *= rot;\n\t\n\t//p = mod(p+vec3(2.0),4.0)-vec3(2.0);\n\tfloat s0 = dot(abs(p),vec3(1.0))-1.5;\n\ts0*=.5;\n\t\n\t//p*=rot;\n\t\n    //all those spheres\n\tfloat s1 = length(p+vec3(1.,.0,.0))-.5;\n\tfloat s2 = length(p+vec3(.0,1.,.0))-.5;\n\tfloat s3 = length(p+vec3(.0,.0,1.))-.5;\n\tfloat s4 = length(p-vec3(1.,.0,.0))-.5;\n\tfloat s5 = length(p-vec3(.0,1.,.0))-.5;\n\tfloat s6 = length(p-vec3(.0,.0,1.))-.5;\n    \n    //combine the spheres with union and intersect into s0\n\ts0 = min(s0,s1);\n\ts0 = min(s0,s2);\n\ts0 = min(s0,s3);\n\ts0 = max(s0,-s4);\n\ts0 = max(s0,-s5);\n\ts0 = max(s0,-s6);\n\t\n    //apply rotation\n\tp*=rot;\n\t\n    //combine into s0 a bunch of cubes\n\ts0 = min(s0,max(max(abs(p.x+2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+2.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-2.0),abs(p.x)),abs(p.y))-.25);\n\t\n    //apply rotation again\n\tp*=rot;\n\t\n    //combine 6 other cubes (the outer ones that rotate faster\n\ts0 = min(s0,max(max(abs(p.x+4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+4.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-4.0),abs(p.x)),abs(p.y))-.25);\n\t\n\treturn s0;\n}\n\n\n//distance function for the whole scene\nfloat df(vec3 p)\n{\n\treturn min(df_obj(p),df_back(p));\n}\n\n//normal function for the whole scene\nvec3 nf(vec3 p)\n{\n\tfloat e = .01;\n\tfloat dfp = df(p);\n\treturn vec3(\n\t\t(dfp+df(p+vec3(e,.0,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,e,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,.0,e)))/e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //compte screen space, center around the center of the screen\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y; //aspect ratio correction\n\t\n    //compute mouse position in screen space (multiplied by 2, for greater effect)\n\tvec2 mouse = iMouse.xy/ iResolution.xy*2.0-1.0;\n\tmouse.x *= iResolution.x/iResolution.y*4.0;\n\t\n    //the rotation matrix for the mouse\n\tmat3 rotmat = rotate_y(mouse.x) * rotate_x(mouse.y);\n\t\n    //initial position, 0,0,-3 rotated by mouse movements\n\tvec3 pos = vec3(.0,.0,-3.0)*rotmat ;\n    \n    //ray direction\n\tvec3 dir = normalize(vec3(uv*.5,1.0-length(uv)*.25))*rotmat;\n\t\n    //light direction\n\tvec3 light_dir = normalize(vec3(.4,.5,.6));\n    //light color\n\tvec3 light_color = vec3(.6,.5,.4);\n\t\n    //raymarch to intersect screen ray with scene\n\tfor (int i=0; i<80; i++){\n\t\tfloat dist = df(pos);\n\t\tpos+=dir*dist;\n\t\tif (dist<.00001) break;\n\t}\n\t\n\tvec3 color = vec3(1.0);\n\tvec3 n = nf(pos);\n\t\n    //here is where we get the derivatives for the normal function\n\tvec3 dfdxn = dFdx(n);\n\tvec3 dfdyn = dFdy(n);\n\t\n    //edges become sum of amplitudes of the derivatives\n\tfloat lines = length(dfdxn) + length(dfdyn);\n    \n    //some post processing to make it better\n    lines = lines*12.75;\n\tlines = lines-1.0;\n\tlines = clamp(lines,.0,1.0);\n\t\n\tif (length(pos)>5.0)\n\t{\n        //background\n\t\tcolor = BACKGROUND_COLOR;\n\t}\n\telse\n\t{\n        //object shading\n\t\t\n        //ambient occlsion\n\t\tfloat oa = 0.5;\n\t\tfor (int i=0; i<30; i++)\n\t\t{\n\t\t\tfloat fi = float(i);\n\t\t\toa += df_obj(pos+noise(fi)-vec3(.5))*.15;\n\t\t}\n\t\toa = min(1.0,oa);\n\t\t\n        //secondary ray for soft shadow\n\t\tvec3 ocdir = light_dir;\n\t\tvec3 ocpos = pos+ocdir*.1;\n\t\tfloat od = 1.0;\n\t\tfor (int i=0; i<60; i++)\n\t\t{\n\t\t\tfloat dist = df_obj(ocpos);\n\t\t\tod = min(od,dist*10.);\n\t\t\tocpos += ocdir*dist*.3;\n\t\t\tif (dist<.0||dist>10.0) break;\n        }\n\t\tod = max(.0,od);\n\t\t\n        //compute diffuse component\n\t\tfloat diffuse = max(.0,dot(n,light_dir)*.8+.2)*od*oa*1.5;\n        \n        //compute specular component\n        float specular = pow(max(.0,dot(reflect(dir,n),light_dir)),16.0)*oa*od;\n        \n       \t//combine diffuse specular and add ambient\n\t\tcolor = vec3(.1,.2,.3)*oa + diffuse*light_color;\n        color += vec3(specular);\n\t}\n\t\n\tvec3 color0 = mix(color,EDGE_COLOR,lines);\n\tvec3 color1 = n*.4+.4;\n\tvec3 color2 = dfdxn+dfdyn;\n\tvec3 color3 = vec3(lines);\n\t\n\tfloat mt = mod(t,32.0);\n\tfloat mti = mod(t,1.0);\n\t\n    //material preview transition :)\n    //it's basically a switchtable\n\tif (mt<7.0){color = color0;}\n\telse if (mt<8.0){color = mix(color0,color1,mti);}\n\telse if (mt<11.0){color = color1;}\n\telse if (mt<12.0){color = mix(color1,color2,mti);}\n\telse if (mt<13.0){color = color2;}\n\telse if (mt<14.0){color = mix(color2,color3,mti);}\n\telse if (mt<18.0){color = color3;}\n\telse if (mt<19.0){color = mix(color2,color1-color3,mti);}\n\telse if (mt<24.0){color = color1-color3;}\n\telse if (mt<25.0){color = mix(color1-color3,color,mti);}\n\telse if (mt<29.0){;}\n\telse if (mt<30.0){color = mix(color,color0,mti);}\n\telse if (mt<32.0){color = color0;}\n\t\n    //post processing\n    color *= 2.0-length(uv)*.5;\n\tcolor += noise(vec3(fragCoord.xy,t*60.0))*0.01;\n\tcolor = color*vec3(1.7,1.5,1.4)/(vec3(1.0)+color);\n\tfragColor = vec4(pow(color,vec3(.5)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s23WV","date":"1393692019","viewed":2729,"name":"Edge Detect","username":"mu6k","description":"Derivative based edge detection. dFdx() and dFdy() are applied to the surface normal. It will detect discontinuities in the normal.","likes":45,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","edge","derivative","toon"],"hasliked":0,"parentid":"","parentname":""}}