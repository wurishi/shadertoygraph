{"ver":"0.1","info":{"id":"3lc3zS","date":"1576689351","viewed":576,"name":"kitty","username":"ga354","description":"Still a bit of a wip, code is horrible, ty to iq and candycat for the distance functions and antialiased sdf rendering respectively!","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["cat","kitty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec2 p, float radius)\n{    \n    return length(p) - radius;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b, float thinness)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\n    return thinness*length( pa - ba*h );\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\nfloat sdfLine(vec2 p0, vec2 p1, float width, vec2 coord)\n{\n    vec2 dir0 = p1 - p0;\n\tvec2 dir1 = coord - p0;\n\tfloat h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n\treturn (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat sdfUnion( const float a, const float b )\n{\n    return min(a, b);\n}\n\nfloat sdfDifference( const float a, const float b)\n{\n    return max(a, -b);\n}\n\nfloat sdfIntersection( const float a, const float b )\n{\n    return max(a, b);\n}\n\nfloat sdTriangleIsosceles(in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec2 rot( in vec2 p, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s,\n                s, c)*p;\n}\n\nvec4 render(float d, vec3 color, float stroke)\n{\n    //stroke = fwidth(d) * 2.0;\n    float anti = fwidth(d) * 1.0;\n    vec4 strokeLayer = vec4(vec3(0.05), 1.0-smoothstep(-anti, anti, d - stroke));\n    vec4 colorLayer = vec4(color, 1.0-smoothstep(-anti, anti, d));\n\n    if (stroke < 0.000001) {\n    \treturn colorLayer;\n    }\n    return vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\nvec4 blockRender(float d, vec3 color, float stroke)\n{\n    \n    //stroke = fwidth(d) * 2.0;\n    float anti = fwidth(d) * 1.0;\n    vec4 colorLayer = vec4(color, 1.0-smoothstep(-anti, anti, d));\n\n    if (stroke < 0.000001) {\n    \treturn colorLayer;\n    }\n    return colorLayer;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTri( in vec2 p )\n{\n    p.y = -p.y;\n    const float k = sqrt(3.);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y) - .2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat size = min(iResolution.x, iResolution.y);\n    float pixSize = 1.0 / size;\n\tvec2 Ouv = fragCoord.xy / iResolution.x;\n    float stroke = pixSize * 2.5;\n    vec2 center = vec2(0.5, 0.5 * iResolution.y/iResolution.x);\n    \n    vec2 uv = Ouv;\n    uv.x = center.x - abs(uv.x - center.x);\n    \n    //head\n    float face = sdEllipse(uv - center, vec2(0.275 - 0.003*sin(iTime), 0.15));\n    float ears = sdVesica(rot(uv - vec2(center), 0.1*sin(sin(iTime))) + vec2(0.13, 0.0), 0.28, 0.15);\n    \n    float earsInner = sdVesica(rot(uv - vec2(center), 0.1*sin(sin(iTime))) + vec2(0.13, 0.0), 0.27, 0.16);\n    earsInner = max(earsInner,-sdEllipse(uv - center, vec2(0.275 - 0.003*sin(iTime), 0.15)));\n    earsInner = max(-(uv.y - center.y), earsInner);\n\n\n    ears = max(-(uv.y - center.y), ears);\n    float d = min(ears, face);\n\n    \n    //black of face\n    float eye = sdEllipse(rot(uv - center, -0.5 + 0.05*sin(iTime)) + vec2(0.14, 0.05), vec2(0.035, 0.045));\n    // mouth\n    float bF = min(eye, sdLine(rot(uv - center, -0.1*sin(iTime)) - vec2(0., 0.03 - 0.015*sin(iTime)), vec2(0.1, -0.02), vec2(-.015, -0.08),  2.2));\n\n    //whiskers\n    for (int i = 0; i<3; i++){\n        \n    \tbF = min(bF, sdLine(rot(rot(uv, -length(uv) + 0.35 - 0.02*sin(iTime)) - center, -float(i)*0.1), vec2(-0.26, -0.05), vec2(-.35, -0.1),  10.*length(uv-center)));\n    \n    }\n    \n    float eyeSpec = sdSphere(rot(uv - center, -0.25 + 0.06*sin(iTime)) + vec2(0.138, -0.009), 0.02);\n\n    //nose\n    float nose = sdTri(70.*(uv - center - vec2(0., 0.008 -0.005*sin(iTime))));\n    \n    vec4 layer0 = render(d, vec3(0.504, 0.498, 0.378), stroke);\n    \n    vec4 layer0_5 = blockRender(earsInner, 0.8*vec3(0.504, 0.498, 0.378), stroke);\n    \n    //eye black\n    vec4 layer1 = render(bF, vec3(0.), stroke);\n    //eye spec\n    vec4 layer2 = blockRender(eyeSpec, vec3(1.), stroke);\n    \n    //itty bitty kitty nose\n    vec4 layer3 = blockRender(nose, vec3(.9, .65, 0.6), stroke);\n    \n    \n    //BG KITTIES\n    //uv.x = center.x - abs(uv.x - center.x);\n    \n    //vec2 bUV = vec2(length(Ouv - center), abs(0.5*atan((Ouv.x - center.x)/(Ouv.y - center.y))));\n    \n    vec2 bUV = Ouv;\n\n    float rep = 0.06;\n    bUV = mod(bUV + rep, 2.*rep) - rep;\n    bUV.x = -abs(bUV.x);\n    \n    float sz = 0.1;\n \n    float bgHead = sdEllipse(bUV, vec2(0.05, 0.03));\n    float bgEars = sdTri(50.*rot(bUV, 1.4) + vec2(-1.0, -1.7));\n\n    float bgKitty = min(bgEars, bgHead);\n    \n    bgKitty = max(bgKitty, -sdSphere(bUV+ vec2(0.025, -.007), 0.007));\n    bgKitty = max(bgKitty, -sdTri(200.*(bUV)));\n\n   \n    \n    vec4 bg = 1.3*vec4(0.8, 0.5, .6, 0.);\n    vec4 bgKitties = blockRender(bgKitty, 0.94*bg.rgb, stroke);\n\n    fragColor.rgb = mix(bg.xyz, bgKitties.rgb, bgKitties.a);\n\n    fragColor.rgb = mix(fragColor.xyz, layer0.rgb, layer0.a);\n    fragColor.rgb = mix(fragColor.rgb, layer0_5.rgb, layer0_5.a);\n    fragColor.rgb = mix(fragColor.rgb, layer1.rgb, layer1.a);\n    fragColor.rgb = mix(fragColor.rgb, layer2.rgb, layer2.a);\n    fragColor.rgb = mix(fragColor.rgb, layer2.rgb, layer2.a);\n    fragColor.rgb = mix(fragColor.rgb, layer3.rgb, layer3.a);\n\n\n\n    \n    \n}","name":"Image","description":"","type":"image"}]}