{"ver":"0.1","info":{"id":"ftSfRw","date":"1652394595","viewed":181,"name":"Earthrise","username":"Krafpy","description":"An attempt to recreate the famous picture of the Earthrise took during the Apollo 8 mission : https://en.wikipedia.org/wiki/Earthrise\nUse the camera to rotate around. Wait to enter in the night side if you want to see stars.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","terrain","fbm","planet","stars","moon","lensflare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    My attempt to recreate a similar landscape to the Earthrise picture took during the Apollo 8 mission :\n    https://en.wikipedia.org/wiki/Earthrise\n    \n    Use the mouse to rotate around. Wait to enter the night side for stars.\n    \n    Buffer A generates earth's continents and clouds maps, as well as the moon's surface\n    terrain. Only the square region visible by the camera in orbit is generated in the\n    texture.\n    I also implemented some stars that appear when the camera enters the night side of the moon,\n    as well as some lens flare when looking at the sun.\n    \n    Quick antialiasing is performed using the method nimitz implemented in his shader Sirenian Dawn.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat fbm(vec3 p){\n    vec3 k = normalize(vec3(0.347, 1.07, -3.31));\n\n    float f = 0.;\n    f += 0.5*noise(1.*p); p = rotate(p, k, 0.205);\n    f += 0.25*noise(2.*p); p = rotate(p, k, -0.65);\n    f += 0.125*noise(4.*p); p = rotate(p, k, 0.33);\n    f += 0.0625*noise(8.*p); p = rotate(p, k, -0.91);\n    f += 0.03125*noise(16.*p); p = rotate(p, k, -1.17);\n    f += 0.015625*noise(32.*p);\n    f += 0.01*noise(64.*p);\n    \n    return f;\n}\n\n\nstruct Crater {\n    float radius;\n    float depth;\n    float floorHeight;\n    float rimHeight;\n    float rimWidth;\n};\n\n// Crater shape, inspired from : https://www.youtube.com/watch?v=lctXaT9pxA0\nfloat craterShape(float x, Crater c){\n    // x : distance to the center of the crater\n    \n    float def = step(x, c.radius + c.rimWidth);\n    \n    float cavity = (c.rimHeight - c.depth) / (c.radius*c.radius);\n    cavity *= x * x;\n    cavity += c.depth;\n    \n    float rim = x - c.radius - c.rimWidth;\n    rim *= rim;\n    rim *= c.rimHeight / (c.rimWidth * c.rimWidth);\n    \n    return smin(smax(cavity, c.floorHeight, 0.01), rim, 0.01) * def;\n    \n}\n\n// Infinite random crater grid\nfloat craters(vec2 p, float numBias, Crater crat, float sizeRand){\n    vec2 q = floor(p);\n    \n    float res = 0.;\n    \n    float n = 1.;\n    for(float i = -n; i <= n; ++i){\n        for(float j = -n; j <= n; ++j){\n            vec2 g = q + vec2(i, j); // tile coordinate\n            \n            if(hash21(g) > numBias) continue; // randomly ignore some craters\n            \n            vec2 o = g + 0.5*hash22(g); // crater coordinate for this tile\n            \n            // Randomizing the crater from the template\n            Crater c = crat;\n            c.radius += sizeRand*(-0.5+0.5*hash21(g + vec2(0.7, -0.11)));\n            float k = c.radius/crat.radius;\n            c.rimHeight *= k;\n            c.depth *= k;\n            \n            if(c.radius < 0.01) continue; // Ignore if the crater is too small\n            \n            float d = distance(o, p);\n            \n            res += craterShape(d, c);\n        }\n    }\n    \n    return res;\n}\n\nfloat moonMap(vec3 p, vec2 uv){\n    float ter = 0.;\n\n    // Terrain\n    float mask = fbm(0.5*p + 0.2*fbm(10.*p) + 5.);\n    mask = pow(mask, 1.15);\n    mask = smoothstep(0.4, 0.5, mask)*smoothstep(0.7, 0.5, mask);\n    ter = 0.5 * mask * fbm(5.*p) + 0.25*fbm(30.*p);\n    ter += 0.2*fbm(50.*p);\n    ter = gain(ter, 3.);\n    //ter = max(0.025, ter);\n    \n    // Adding craters\n    uv *= 20.;\n    ter += craters(uv, 0.25, Crater(0.3, -0.1, -0.05, 0.1, 0.2), 0.5);\n    ter += craters(5.*uv, 0.1, Crater(0.5, -0.02, -0.01, 0.02, 0.4), 0.4);\n    ter += craters(10.*uv, 0.1, Crater(0.5, -0.025, -1., 0.0, 0.2), 0.3);\n    ter += craters(3.*uv+12.3, 0.025, Crater(0.8, -0.1, -0.05, 0.005, 0.3), 0.2);\n    \n    return ter;\n}\n\n\n// Earth's clouds base noise map\nfloat cloudsNoise(vec3 p){\n    float f = fbm(3.*p + 7.*fbm(1.5*p) + 1.9);\n    return f;\n}\n\n// Earth's continents base noise map\nfloat continentsNoise(vec3 p){\n    return fbm(2.*p+3.);\n}\n\n\n// Position vector on unit sphere from latitude and longitude\nvec3 latLon2UnitPoint(float lat, float lon){\n    return vec3(\n        cos(lon)*cos(lat),\n        sin(lat),\n        sin(lon)*cos(lat)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Moon terrain\n    // We generate only the part of the map that is visible\n    // by the camera in orbit to have a better resolution,\n    // instead of generating the entire moon map in a texture\n    float a = LAT_LON_RANGE;\n    float lat = mix(-a, a, uv.y) + 0.05;\n    float lon = -CAM_LON + mix(-a, a, uv.x) + 0.2;\n    vec3 p = latLon2UnitPoint(lat, lon);\n    // Since the camera orbits equator (low latitude), we\n    // can directly use the longitude and latitude as UV\n    // coordinates for craters without any visible distortions\n    float mm = moonMap(p, vec2(lon, lat));\n    \n    \n    // Earth texture, the entire map is generated\n    lat = mix(-PI*0.5, PI*0.5, uv.y);\n    lon = mix(0., 2.*PI, uv.x);\n    \n    // Continents\n    p = latLon2UnitPoint(lat, lon);\n    float cts = continentsNoise(p);\n    \n    // Clouds, stretched along the equator\n    lon *= 0.5;\n    p = latLon2UnitPoint(lat, lon);\n    float cls = cloudsNoise(p);\n    \n    fragColor = vec4(mm, cls, cts, 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n\n// Orbital velocity\n#define ANGULAR_VEL -0.008\n// The range of latitude and longitude the texture represent\n#define LAT_LON_RANGE 0.22\n// Global access to the camera longitude at any time\n#define CAM_LON (ANGULAR_VEL*iTime)\n\nfloat mdot(vec3 u, vec3 v){\n    return max(0., dot(u, v));\n}\n\n// Rodrigue's 3D rotation formula\nvec3 rotate(vec3 v, vec3 k, float a){\n    float c = cos(a);\n    float s = sin(a);\n    return v*c + cross(k,v)*s + k*dot(k,v)*(1.-c);\n}\n\n// 2D rotation matrix\nmat2 matrot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// Linear interpolation from one interval to another\nfloat interp(float x,\n    float a1, float b1,\n    float a2, float b2){\n  return (x-a1)*(b2-a2)/(b1-a1) + a2;\n}\n\n\n\n// Noise functions mostly from : https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash31(vec3 p){\n    p *= 0.3183099;\n    p = 50.*fract(p+vec3(2.424,-3.145,1.131));\n    return fract(dot(p.xxy*p.yzz,p.xxy+p.yzz));\n}\n\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = p.xyx*vec3(.1031, .1030, .0973);\n\tp3 = fract(p3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n// 3D noise\nfloat noise(vec3 p){\n    vec3 i = floor(p);\n    vec3 w = fract(p);\n    vec3 u = w*w*w*(w*(6.*w-15.)+10.);\n    \n    vec2 h = vec2(1.,0.);\n    float a = hash31(i+h.yyy);\n    float b = hash31(i+h.xyy);\n    float c = hash31(i+h.yxy);\n    float d = hash31(i+h.yyx);\n    float e = hash31(i+h.xxy);\n    float f = hash31(i+h.yxx);\n    float g = hash31(i+h.xyx);\n    float t = hash31(i+h.xxx);\n    \n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = d-a;\n    float k4 = e+a-b-c;\n    float k5 = f+a-c-d;\n    float k6 = g+a-b-d;\n    float k7 = t-k0-k1-k2-k3-k4-k5-k6;\n    \n    vec3 k123 = vec3(k1,k2,k3);\n    vec3 k456 = vec3(k4,k5,k6);\n    \n    float n = k0 + dot(k123, u) + dot(k456*u, u.yzx) + k7*u.x*u.y*u.z;\n    return n;\n}\n\n\n// gain function by iq : https://iquilezles.org/articles/functions/\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\n// smooth min by iq : https://iquilezles.org/articles/smin/\nfloat smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.)/k;\n    return min(a, b) - h*h*k*(1./4.);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return -smin(-a, -b, k);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Uncomment to see the whole moon\n// (only the terrain visible from low orbit is generated)\n//#define DEBUG\n\n\nconst vec3 sunDir = normalize(vec3(1.,0.,0.));\n\nconst vec3 earthPos = 1000.*vec3(-0.3, 0., 1.);\nconst float earthRadius = 50.;\n\nconst float moonRadius = 2.;\nconst float orbitRatio = 1.028;\nconst float orbitRadius = moonRadius*orbitRatio;\nconst float heightScale = 0.02;\nconst float camTilt = -0.1;\n\n\nstruct Camera{\n    vec3 p;\n    vec3 u,v,w;\n} cam;\n\nCamera getCamera(float lon, vec3 mouse){\n    vec3 p = vec3(1., 0., 0.);\n    vec3 w = vec3(0., 0., 1.);\n    vec3 u = vec3(0., -1., 0.);\n    vec3 v = vec3(1., 0., 0.);\n    \n    mat2 r = matrot(lon);\n    p.xz *= r;\n    v.xz *= r;\n    w.xz *= r;\n    \n    if(mouse.z <= 0. || iFrame < 10) {\n        r = matrot(camTilt);\n        w.xz *= r;\n        v.xz *= r;\n    } else {\n        mouse.y = -mix(-0.5*PI, 0.5*PI, mouse.y);\n        mouse.x = mix(-PI, PI, mouse.x);\n        \n        w = rotate(w, p, mouse.x);\n        u = rotate(u, p, mouse.x);\n        \n        w = rotate(w, u, mouse.y);\n        v = rotate(v, u, mouse.y);\n    }\n    \n    p *= orbitRadius;\n    \n    return Camera(p, u, v, w);\n}\n\n\nfloat sphereItsc(vec3 ro, vec3 rd, vec4 s)\n{\t\n    vec3 ce = s.xyz;\n    float ra = s.w;\n    vec3 oc = ro - ce;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - ra*ra;\n    float h = b*b - c;\n    if(h < 0.) return -1.;\n    return -b-sqrt(h);\n}\n\n\nfloat moonHeight(vec3 p){\n    float lat = asin(p.y/length(p));\n    p.xz *= matrot(-CAM_LON);\n    float lon = atan(p.z, p.x);\n    float a = LAT_LON_RANGE;\n    vec2 uv = vec2(\n        interp(lon, -a, a, 0., 1.),\n        interp(lat, -a, a, 0., 1.)\n    );\n    return texture(iChannel0, uv).x;\n}\n\nfloat sdf(vec3 p){\n    float dsph = length(p) - moonRadius;\n    float h = heightScale * moonHeight(p);\n    return dsph - h;\n}\n\nvec3 normal(vec3 p){\n    vec2 h = vec2(0.001, 0.);\n    return normalize(vec3(\n        sdf(p+h.xyy)-sdf(p-h.xyy),\n        sdf(p+h.yxy)-sdf(p-h.yxy),\n        sdf(p+h.yyx)-sdf(p-h.yyx)\n    ));\n}\n\nvec2 raymarch(vec3 ro, vec3 rd){\n    const float eps = 0.0005;\n    const float maxSteps = 400.;\n    float t = 0.;\n    float i = 0.;\n    float k = 0.3;\n    for(; i < maxSteps; i++){\n        float d = sdf(ro + rd * t);\n        if(d < eps) return vec2(t, i/maxSteps);\n        t += k*d;\n    }\n    return vec2(-1.);\n}\n\n\nvec3 moonColor(vec3 p, vec3 n){\n    vec3 col = vec3(0.);\n\n    // low and high altitude colors\n    vec3 low = 0.6*vec3(0.32, 0.32, 0.33);\n    vec3 high = vec3(0.51, 0.51, 0.52);\n\n    float h = moonHeight(p);\n    //h = smoothstep(0., 1., h);\n    h = gain(h+0.35, 6.);\n    col = mix(low, high, h);\n    col = clamp(col, 0., 1.);\n    \n    // Shadow\n    // Hacking in some way to have full light on the sunny side\n    // while increasing the contrast to have stronger diffuse shadows\n    vec3 ns = normalize(p);\n    float s1 = dot(ns, sunDir);\n    s1 = smoothstep(-0.2, 0.2, s1);\n    float s2 = mdot(normalize(n-0.5*ns), sunDir);\n    s2 = pow(s2, 2.5);\n    col *= (s1+0.2)*s2 + 0.1;\n    \n    //col = clamp(col, 0., 1.);\n    return col;\n}\n\nvec3 earthColor(vec3 p, vec3 rd){ // p relative to earth's center\n    vec3 col = vec3(0.);\n    vec3 n = normalize(p);\n    \n    // UV texture coordinate on the map\n    float lat = asin(p.y/length(p));\n    float lon = atan(p.z, p.x);\n    vec2 uv = vec2(\n        interp(lon, -PI, PI, 0., 1.),\n        interp(lat, -0.5*PI, 0.5*PI, 0., 1.)\n    );\n    \n    // Ground and ocean\n    \n    vec3 ocean = 0.65*vec3(0.37, 0.5, 0.64);\n    // Add specular reflection on oceans\n    vec3 r = reflect(sunDir, n);\n    vec3 k = 0.7*vec3(0.5,0.5,0.4)*pow(mdot(r, rd), 10.);\n    ocean = clamp(ocean+k, 0., 1.);\n    \n    // Continents coloring\n    float g = texture(iChannel0, uv).z;\n    float f = step(0.6, g);\n    g = clamp(f*g-0.12, 0., 1.);\n    g = gain(g, 4.);\n    vec3 ground = mix(vec3(0.8,0.4,0.1), vec3(0.1,0.25,0.05), g);\n    ground = mix(ground, ocean, 0.5); // mix a bit with the blue\n    col = ground*f + (1.-f)*ocean;\n    \n    // Clouds\n    float c = texture(iChannel0, uv).y; // contains only the base noise\n    c = smoothstep(0.4, 0.6, gain(c, 0.5));\n    vec3 clouds = vec3(1.);\n    col = mix(col, clouds, c*0.8);\n    \n    // Shadow\n    float shad = dot(n, sunDir);\n    shad = smoothstep(-0.15, 0.15, shad);\n    col *= shad;\n    \n    // Brighten the borders and make them fade in the dark\n    f = smoothstep(0.5, -0.1, dot(normalize(p-earthPos), n));\n    f *= shad;\n    col *= (1.-0.8*f);\n    col = mix(col, vec3(0.8,0.9,1.), f);\n    \n    return col;\n}\n\n\nvec3 sun(vec3 rd, float amp){\n    vec3 col = vec3(0.);\n    \n    // Sun\n    float s = mdot(rd, sunDir);\n    vec3 p = rd - s*sunDir;\n    \n    // UV coordinates on a plane perpendicular to the\n    // sun's direction\n    vec3 u = vec3(0.,1.,0.);\n    vec3 v = vec3(0.,0.,1.);\n    u -= dot(sunDir, u)*sunDir;\n    v -= dot(sunDir, v)*sunDir;\n    vec2 uv = vec2(dot(p, u), dot(p, v));\n    float d = length(uv);\n    uv /= d;\n    \n    // Quick FBM using the uv coordinates around the sun's\n    // position for a looping noise to make sun rays\n    float f = 0.;\n    float w = 1.;\n    for(float i = 1.; i <= 5.; i++){\n        f += w*noise(5.*i*vec3(uv,0.)+1.5);\n        w *= 0.7;\n    }\n    \n    // Rays' attenuation\n    f *= 0.5*clamp(exp(-16.*d)*(1.-d+0.1),0.,1.);\n    col = vec3(f);\n    \n    // Amplifying the light near the center\n    d *= 50.;\n    d = max(d*d, 0.1); // Avoid dividing by 0\n    col += (1.+f)/d * amp;\n    \n    col *= vec3(0.8,0.8,0.9); // slightly blueish color\n    col *= s;\n    \n    \n    // Sun flare (the wider line in the middle)\n    f = abs(dot(rd, v));\n    f = 0.5*smoothstep(0.01, 0., f);\n    f *= smoothstep(0.9, 1., s);\n    f *= f;\n    \n    col += f * vec3(0.7, 0.8, 1.);\n    \n    col *= amp;\n    \n\n    //col = clamp(col, 0., 1.);    \n    return col;\n}\n\n\nvec3 lensCircle(vec2 ci, vec2 uv, float r, vec2 off){\n    vec3 col = vec3(0.);\n    \n    float d = length(uv-ci);\n    float f = smoothstep(-0.25*r, r, d);\n    f *= smoothstep(r, 0.7*r, d);\n    \n    // color shift factor (turn some parts more red or blue)\n    float k = dot(normalize(uv-ci), normalize(off));\n    float s = step(0., k);\n    k = smoothstep(0., 1., abs(k));\n    \n    // color shift : more red in the direction facing away\n    // from the sun, and more blue in the other direction\n    vec3 cs = vec3(1.,0.4,0.3)*s;\n    cs += vec3(0.3,0.8,1.)*(1.-s);\n    cs *= f*0.5;\n    \n    vec3 col1 = 0.25*f*vec3(0.85,0.95,1.); // white circles\n    vec3 col2 = mix(col1, cs, k*length(off)*0.8); // color addition\n    \n    col = 0.5*mix(col1, col2, k);\n    \n    return col;\n}\n\nvec3 lensflare(vec3 rd, vec2 uv){\n    vec3 col = vec3(0.);\n    \n    // Whether the flare should be visible depending on\n    // how the sun is oriented\n    float vis = dot(cam.w, sunDir);\n    vis = smoothstep(0.5, 1., vis);\n    \n    // Project the sun's position on the camera's UV plane\n    vec3 c3 = sunDir - dot(sunDir, cam.w)*cam.w;\n    vec2 c = vec2(dot(c3, cam.u), dot(c3, cam.v));\n    \n    float lc = length(c);\n    vec2 dir = -c/lc;\n    \n    vec2 off, ci;\n    // Position offset from the sun's position, \n    // the use of the smoothstep avoids a simple linear\n    // motion of the circles\n    float k = mix(0., 0.7, smoothstep(0., 1., lc));\n    \n    // Create the three offseted flare circles\n    off = dir*k;\n    col += lensCircle(c + off, uv, 0.07, off); \n    \n    off = dir*k*1.5;\n    col += lensCircle(c + off, uv, 0.21, off);\n    \n    off = dir*k*1.7;\n    col += lensCircle(c + off, uv, 0.03, off); \n    \n    col *= vis;\n  \n    return col;\n}\n\n\nfloat stars2d(vec2 uv){\n    // Simple infinite 2D star field\n    float f = 0.;\n    uv *= 50.;\n    vec2 i = floor(uv);\n    vec2 o = hash22(i);\n    float d = distance(i + o, uv);\n    f = step(d, 0.06);\n    f *= step(0.95, hash21(i)) * hash21(i+13.3);\n    \n    return f;\n}\n\nvec3 stars(vec3 rd){\n    // Projects the a star field on the sky map\n    // using triplanar mapping\n    \n    vec3 col = vec3(0.);\n    \n    float f = 0.;\n    vec3 ar = abs(rd);\n    f += ar.y*stars2d(rd.xz);\n    f += ar.x*stars2d(rd.yz);\n    f += ar.z*stars2d(rd.xy);\n    f /= ar.x+ar.y+ar.z;\n    \n    f = f*step(0.25, f);\n    \n    \n    float k = noise(100.*rd);\n    \n    vec3 a = vec3(1., 0.8, 0.8);\n    vec3 b = vec3(0.8, 0.8, 1.);\n    col = f*mix(a, b, k);\n    \n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.);\n    \n    vec2 uv01 = fragCoord/iResolution.xy;\n    vec2 uv = uv01;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    #ifdef DEBUG\n    vec2 mr = iMouse.xy/iResolution.xy;\n    mr -= 0.5;\n    mr.x *= iResolution.x / iResolution.y;\n    mr *= 3.141592;\n    \n    vec3 ro = vec3(0.,0.,-orbitRadius-4.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    ro.yz *= matrot(mr.y);\n    rd.yz *= matrot(mr.y);\n    ro.xz *= matrot(mr.x);\n    rd.xz *= matrot(mr.x);\n    \n    #else\n    vec3 mouse = iMouse.xyz/vec3(iResolution.xy, 1.);\n    cam = getCamera(CAM_LON, mouse);\n    \n    vec3 ro = cam.p;\n    \n    // Randomize the ray for AA\n    vec2 rnd = hash22(uv + vec2(iTime*.73, -iTime*.31));\n    rnd *= 0.001;\n    vec3 rd = normalize(\n        cam.u*(uv.x+rnd.x) + cam.v*(uv.y+rnd.y) + cam.w\n    );\n    \n    #endif\n    \n    \n    col = vec3(0.);\n    \n    // Moon surface and earth\n    \n    vec2 hit = raymarch(ro, rd);\n    float t = hit.x;\n    vec3 p, n;\n    \n    if(t > 0.){\n        p = ro + rd * t;\n        n = normal(p);\n        col = moonColor(p, n);\n        \n    } else {\n        t = sphereItsc(ro, rd, vec4(earthPos, earthRadius));\n        if(t > 0.) {\n            p = ro + rd * t;\n            col = earthColor(p - earthPos, rd);\n        }\n    }\n    \n    #ifndef DEBUG\n    // Sun and stars\n    vec3 su, st;\n    if(t < 0.) {\n        su = sun(rd, 1.);\n        st = stars(rd);\n    } else {\n        // Have the sun fade smoothly in the ground\n        // and not get cut abruptly below the horizon\n        float k = dot(sunDir, normalize(p));\n        k = smoothstep(-0.1, 0., k);\n        su = sun(rd, k);\n    }\n    // Make the sun smoothly disappear when the camera is\n    // far enough on the dark side, and make stars visible at\n    // the same time\n    float f = dot(sunDir, normalize(cam.p));\n    f = smoothstep(-0.243, -0.24, f);\n    su *= f;\n    st *= 1.-f;\n    \n    col += su + st;\n    \n    \n    // Lens flare\n    col += lensflare(rd, uv)*f;\n    \n    #endif\n    \n\n    col = clamp(col, 0., 1.);\n    \n    // Add a darker outline on the borders of the screen\n    float k = 16.*uv01.x*(1.-uv01.x)*uv01.y*(1.-uv01.y);\n    k = pow(k, 1./20.);\n    col *= k;\n    \n    \n    // Antialiasing by nimitz : https://www.shadertoy.com/view/XsyGWV\n    vec3 prev = texture(iChannel1, uv01).rgb;\n    col = mix(col, prev, clamp(0.85-iTimeDelta*7.,0.,1.));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}