{"ver":"0.1","info":{"id":"3d3czj","date":"1601237612","viewed":199,"name":"Ray Marching - More basic Shapes","username":"qw","description":"signed distance field sphere, torus, capsule, box\ntri-planar mapping\nshape blending\nplane cutting","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.01\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0);\n    return min(a, b) - h*h*h/(6.0*k*k);\n}\n \nvec2 opBlend(vec2 d1, vec2 d2, float t)\n{\n    float k = 5.0 * t;\n    float d = sminCubic(d1.x, d2.x, k);\n    float m = mix(d1.y, d2.y, clamp(d1.x-d,0.0,1.0));\n    return vec2(d, m);\n}\n\nvec2 opUnion(vec2 a, vec2 b)\n{\n    if( a.x < b.x)\n    {\n        return a;\n    }\n    return b;\n}\n\nvec2 opCut(vec2 a, vec2 b)\n{\n    if( -a.x > b.x )\n    {\n        return a;\n    }\n    return b;\n}\n\n\nfloat sdCapsule(vec3 position, vec3 capAPos, vec3 capBPos, float radius)\n{\n    vec3 ab = capBPos-capAPos;\n    vec3 ap = position - capAPos;\n    \n    // projecting ab on ap and normalizing by length of a<->b, ie: dot product ab.ab\n    float t = dot(ab, ap) / dot(ab,ab);\n\t//clamp value to stay between a & b\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 closestPoint = capAPos + ab * t;\n    float distance = length(position - closestPoint) - radius;\n    return distance;\n}\n\nfloat sdTorus( vec3 position, vec3 torusOrigin, float torusRadius, float width )\n{\n    vec3 posToTorus = torusOrigin - position;\n    float x = length( posToTorus.xz) - torusRadius;\n    float y = posToTorus.y;\n    return length(vec2(x,y)) - width;\n}\n\n\nfloat sdBox(vec3 position, vec3 origin, vec3 size)\n{\n    vec3 boxPos = position - origin;\n    return length( max(abs( boxPos ) - size, 0.0) );\n}\n               \n\nfloat sdCylinder(vec3 position, vec3 capAPos, vec3 capBPos, float radius)\n{\n    vec3 ab = capBPos-capAPos;\n    vec3 ap = position - capAPos;\n    \n    // projecting ab on ap and normalizing by length of a<->b, ie: dot product ab.ab\n    float t = dot(ab, ap) / dot(ab,ab);\n\t//clamp value to stay between a & b\n    //t = clamp(t, 0.0, 1.0);\n    \n    vec3 closestPoint = capAPos + ab * t;\n    \n    float x = length(position - closestPoint) - radius;\n    float y = (abs(t- 0.5) - 0.5) * length(ab);\n    float exteriorDist = length( max( vec2(x,y), 0.0) );\n    \n    //fix for inaccuracy distance estimation\n    float interriorDist = min( max(x,y),0.0);\n    float distance = exteriorDist + interriorDist; \n    \n    return distance;\n}\n\nvec2 GetDistanceToScene(vec3 position)\n{\n\t//Sphere (pos.xyz, radius)\n    vec4 sphere = vec4(2.5 * cos(iTime),1.0, 4.0 + (-sin(iTime)), 1.0);\n    float sphereDistance = length( sphere.xyz - position) - sphere.w; \n    \n    //Plane (plane is flat at height 0, which means it's at \"y\" distance from camera\n    float planeDistance = position.y;\n    \n    float capsuleDistance = sdCapsule(position, vec3(-3.0,2,2), vec3(-2.0,1,2), 0.20);\n    float torusDistance = sdTorus(position, vec3(0,1.2,4), 2.0, 0.2);\n    vec3 repeatedPos = position;\n    float boxDistance = sdBox(position, vec3(0.0, 1, 4.0), vec3(0.9) );\n    float cylinderDistance = sdCylinder(position, vec3(-4.0,0.4,2.5), vec3(-1.0,0.4,1.5), 0.30);\n    \n    //Box 2\n    float box2IntersectionPlane = dot(position + vec3(0,0, 1.5*( sin(iTime) *0.5)+0.5 ), normalize(vec3(-1,1,-1)) )+1.1; \n    float box2Distance = sdBox(position, vec3(3.0, 0.6, 0.5), vec3(0.5) );\n    box2Distance = max( box2IntersectionPlane, box2Distance);\n    box2Distance = abs(box2Distance) - 0.3;\n    \n    \n    // find closest object('s distance)\n    vec2 distance = opBlend( vec2( sphereDistance, 1),vec2(torusDistance,3) , 0.2 /*(sin(iTime) *0.5)+0.5*/ );\n    distance = opUnion(distance, vec2(capsuleDistance,2) );\n    distance = opUnion(distance, vec2(boxDistance, 4));\n    distance = opUnion(distance, vec2(cylinderDistance, 5));\n\tdistance = opUnion( distance, vec2(planeDistance,0) );    \n\n    distance = opUnion(distance,  vec2(box2Distance,6));\n    \n    return distance;\n}\n\n\n\nvec2 RayMarch(vec3 rayOrigin, vec3 rayDir )\n{\n    //Vec2 (X = distanceToScene, Y = object ID - used for differentiation like different textures)\n    vec2 distanceFromOrigin = vec2(0.0, 0.0);\n    \n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrigin + rayDir*distanceFromOrigin.x;\n        vec2 distanceToSceneData = GetDistanceToScene(pos);\n        distanceFromOrigin.x += distanceToSceneData.x;\n        distanceFromOrigin.y = distanceToSceneData.y;\n        if(distanceFromOrigin.x > MAX_DISTANCE || distanceToSceneData.x < SURFACE_DISTANCE)\n        {\n        \tbreak;\n        }    \n        \n    }\n    \n    \n    return distanceFromOrigin;\n}\n\n\nvec3 GetNormal(vec3 scenePos)\n{\n    vec2 distanceData = GetDistanceToScene(scenePos);\n    float distance = distanceData.x;;\n    \n    //We use derivatives to calculate normal of a position\n    vec2 smallDiff = vec2(0.01, 0);\n    \n    vec3 normal = distance - vec3(\n        GetDistanceToScene(scenePos - smallDiff.xyy).x,\n        GetDistanceToScene(scenePos - smallDiff.yxy).x,\n        GetDistanceToScene(scenePos - smallDiff.yyx).x\n        );\n\n\treturn normalize(normal);\n    \n}\n\nfloat GetLight( vec3 scenePos , vec3 normal)\n{\n    //Light position in world\n    vec3 lightPos = vec3(0, 3.5, 2);\n    //make light move in circle\n    //lightPos.xz += vec2(cos(iTime), -sin(iTime) ) * 2.0;\n    lightPos.y += sin(iTime) * .5;\n    \n    \n    vec3 lightDir = normalize( lightPos-scenePos);\n\n    float diffuse = dot(normal, lightDir);\n    //Clamp diffuse\n    diffuse = clamp(diffuse,0.0,1.0);\n    \n    //Shadow ((normal*SURFACE_DISTANCE*2.0) -> offset shading point a little bit away of surface to not intersect with it again,\n    //*2 is to avoid artefacts\n    float distanceToLightRayMarch = RayMarch(scenePos + (normal*SURFACE_DISTANCE*2.0), lightDir).x;\n    if( distanceToLightRayMarch < length( scenePos - lightPos) )\n    {\n        //something is in between the point in the world and the light, ie: we're in shadow\n        diffuse *= 0.1;\n    }\n    \n    return diffuse;\n}\n\n\nvec3 GetAlbedo( vec3 scenePos, vec3 normal, float objectID)\n{\n    // apply tri-planar mapping\n    mat3 triMapSamples;    \n\t//first we calculate planar mapping for each 3 directions\n    //Support multiple textures based on objectID\t\n    if(objectID == 0.0) //wood\n    {\n    \n    \ttriMapSamples = mat3(\n                texture(iChannel0, scenePos.yz).rgb,\n                texture(iChannel0, scenePos.xz).rgb,\n                texture(iChannel0, scenePos.xy).rgb\n        \t);\n    }\n    else if(objectID < 4.0) //Metal\n    {\n    \n    \ttriMapSamples = mat3(\n                texture(iChannel1, scenePos.yz).rgb,\n                texture(iChannel1, scenePos.xz).rgb,\n                texture(iChannel1, scenePos.xy).rgb\n        \t);\n    }\n    else // tiles\n    {\n    \ttriMapSamples = mat3(\n                texture(iChannel2, scenePos.yz).rgb,\n                texture(iChannel2, scenePos.xz).rgb,\n                texture(iChannel2, scenePos.xy).rgb\n        \t);\n    \n    }\n        \n    //Then we \"weigh\" this 3x3 matrix by the normal, this is our result\n    return triMapSamples * abs(normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n  \t//Change to square aspect ratio & center in middle of viewport\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    \n    vec3 cameraPos = vec3(0,3,-4);\n    vec3 cameraLookDir = normalize( vec3(0.0,-0.3,1.0));\n    vec3 rayDir = normalize(vec3(uv.xy+cameraLookDir.xy, cameraLookDir.z));\n        \n    \n    //Vec2 (X = distanceToScene, Y = object ID - used for differentiation like different textures)\n    vec2 rayMarchData = RayMarch(cameraPos, rayDir);\n    float rayMarchDistance = rayMarchData.x;\n    float objecID = rayMarchData.y;\n    vec3 scenePos = cameraPos + rayDir * rayMarchDistance;\n    \n    vec3 normal = GetNormal(scenePos);\n    \n    vec3 albedo = GetAlbedo(scenePos, normal, objecID); \n\tfloat diffuseLighting = GetLight(scenePos, normal);\n    \n    vec3 lightColor = vec3(0.9,0.9,0.8);\n       \n\tvec3 col = albedo * vec3(lightColor*diffuseLighting);\n    \n    vec3 ambientColor = vec3(0.1,0.1,0.1);\n    col += ambientColor;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}