{"ver":"0.1","info":{"id":"ttfBR8","date":"1595951640","viewed":230,"name":"Tileable Curl Noise","username":"ming","description":"Tileable Curl Noise","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["curl","tileable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec4 triplanar(vec3 p, vec3 n)\n{\n    vec3 blending = abs( n );\n    blending = normalize(max(blending, 0.00001)); // Force weights to sum to 1.0\n    float b = (blending.x + blending.y + blending.z);\n    blending /= vec3(b);\n\n    vec4 xaxis = texture( iChannel0, p.yz);\n    vec4 yaxis = texture( iChannel0, p.xz);\n    vec4 zaxis = texture( iChannel0, p.xy);\n    return xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;\n}\n\n//----------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//#define SHOW_2D_VERSION 1\n#ifdef SHOW_2D_VERSION\n    // uv should be within 0-1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // debug for tiling\n    //uv *= 2.0;\n    \n    vec3 c = TileableCurlNoise(vec3(uv + vec2(0.0, iTime * 0.25), 0.0), 4.0, 3) * 0.5 + 0.5;\n    fragColor = vec4(c, 1.0);\n#else\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.1*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.9);\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n        vec3 uvw = pos * 0.5;\n        vec3 curl_offset = vec3(0.0, iTime * 0.25, 0.0);\n        vec3 curl = TileableCurlNoise(pos + curl_offset, 4.0, 3);\n        \n        uvw += curl * 0.03;\n\t    \n\t\tcol = (fragCoord.x > iResolution.x * 0.5) ? triplanar(uvw, nor).xyz : pow((curl.xyz * 0.5 + 0.5), vec3(0.4545));\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//----------------------------------------------------------------------------------------\nvec3 HashALU(in vec3 p, in float numCells)\n{\n\t// This is tiling part, adjusts with the scale\n\tp = mod(p, numCells);\n\t\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + fract(sin(p)*43758.5453123) * 2.0;\n}\n\n#define Hash HashALU\n\n//----------------------------------------------------------------------------------------\nfloat TileableNoise(in vec3 p, in float numCells )\n{\n\tvec3 f, i;\n\t\n\tp *= numCells;\n\n\t\n\tf = fract(p);\t\t// Separate integer from fractional\n    i = floor(p);\n\t\n    vec3 u = f*f*(3.0-2.0*f); // Cosine interpolation approximation\n\n    return mix( mix( mix( dot( Hash( i + vec3(0.0,0.0,0.0), numCells ), f - vec3(0.0,0.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,0.0), numCells ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,0.0), numCells ), f - vec3(0.0,1.0,0.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,0.0), numCells ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( Hash( i + vec3(0.0,0.0,1.0), numCells ), f - vec3(0.0,0.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,0.0,1.0), numCells ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( Hash( i + vec3(0.0,1.0,1.0), numCells ), f - vec3(0.0,1.0,1.0) ), \n                          dot( Hash( i + vec3(1.0,1.0,1.0), numCells ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat TileableNoiseFBM(in vec3 p, float numCells, int octaves)\n{\n\tfloat f = 0.0;\n    \n\t// Change starting scale to any integer value...\n    p = mod(p, vec3(numCells));\n\tfloat amp = 0.5;\n    float sum = 0.0;\n\t\n\tfor (int i = 0; i < octaves; i++)\n\t{\n\t\tf += TileableNoise(p, numCells) * amp;\n        sum += amp;\n\t\tamp *= 0.5;\n\n\t\t// numCells must be multiplied by an integer value...\n\t\tnumCells *= 2.0;\n\t}\n\n\treturn f / sum;\n}\n\nvec3 snoiseVec3( vec3 x, in float numCells, int octaves )\n{\n   \n  float s  = TileableNoiseFBM(vec3( x ), numCells, octaves);\n  float s1 = TileableNoiseFBM(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ), numCells, octaves);\n  float s2 = TileableNoiseFBM(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ), numCells, octaves);\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n\n}\n\nvec3 TileableCurlNoise(vec3 p, in float numCells, int octaves)\n{\n  const float e = .1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx, numCells, octaves );\n  vec3 p_x1 = snoiseVec3( p + dx, numCells, octaves );\n  vec3 p_y0 = snoiseVec3( p - dy, numCells, octaves );\n  vec3 p_y1 = snoiseVec3( p + dy, numCells, octaves );\n  vec3 p_z0 = snoiseVec3( p - dz, numCells, octaves );\n  vec3 p_z1 = snoiseVec3( p + dz, numCells, octaves );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n  // technically incorrect but I like this better...\n  //return normalize(vec3( x , y , z ));\n}\n","name":"Common","description":"","type":"common"}]}