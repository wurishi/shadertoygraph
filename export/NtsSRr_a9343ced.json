{"ver":"0.1","info":{"id":"NtsSRr","date":"1625098889","viewed":74,"name":"Raymarching Diffuse Lighting","username":"RossBorchers","description":"You know it!\nhttps://www.youtube.com/watch?v=PGtv-dBi2wE","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["newbie","basicraymarching","artofcode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.003\n\n\n//From https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat opSubtraction( float d1, float d2 ) \n{\n    return max(-d1,d2); \n}\n\nfloat GetDist(vec3 p)\n{\n    //Distance to plane. flat on ground.\n    float dPlaneBottom = p.y;\n    float dPlaneTop = 12.0 - p.y;\n    \n    //Distance to sphere.\n    //distance of camera to sphere position minus radius\n    //xyz, radius\n    vec4 sphere= vec4(-1, 1.7, 6, 1);\n    float dSphere = length(p-sphere.xyz)-sphere.w;\n    \n     vec4 sphere2 = vec4(1, 1.2, 6.5, 0.9);\n    float dSphere2 = length(p-sphere2.xyz)-sphere2.w;\n    \n      vec4 sphere3 = vec4(0, 0, 7.3, 3.2);\n    float dSphere3 = length(p-sphere3.xyz)-sphere3.w;\n    float dFloorBottom = opSubtraction(dSphere3, dPlaneBottom);\n    \n    vec3 boxPos = vec3(3, 1, 5);\n    float dBox = sdRoundBox(p -boxPos , vec3(0.25,2,0.25), 0.02);\n    \n    vec3 box2Pos = vec3(3, 1, 10);\n    float dBox2 = sdRoundBox(p -box2Pos , vec3(0.25,2,0.25), 0.02);\n    \n    vec3 box3Pos = vec3(-3, 1, 10);\n    float dBox3 = sdRoundBox(p -box3Pos , vec3(0.25,2,0.25), 0.02);\n    \n    vec3 box4Pos = vec3(-3, 1, 5);\n    float dBox4 = sdRoundBox(p -box4Pos , vec3(0.25,2,0.25), 0.02);\n    \n    float dMarch = opSmoothUnion(dSphere2, dSphere, 0.7);\n    dMarch = min(dMarch, dFloorBottom);\n    dMarch = min(dMarch, dPlaneTop);\n    dMarch = opSmoothUnion(dMarch, dBox, 0.1);\n    dMarch = opSmoothUnion(dMarch, dBox2, 0.1);\n    dMarch = opSmoothUnion(dMarch, dBox3, 0.1);\n    dMarch = opSmoothUnion(dMarch, dBox4, 0.1);\n    return dMarch;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    //Distance from origin.\n    float dO = 0.0;\n    \n    //Delimit max steps to avoid infinate loop\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        //new point to evaluate. camera origin + current distance from origin * ray direction \n        vec3 p = ro+(dO*rd);\n        \n        //Get current distance to scene (sphere trace)\n        float dS = GetDist(p);\n        \n        //increment distnace for next iteration\n        dO += dS;\n        \n        //exit if we are close to surface or we are too far away from camera.\n        if(dS<SURFACE_DIST || dO > MAX_DIST)\n        {\n            break;\n        }\n    }\n    \n    //return the distance that we either exited early or at scene object.\n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    \n    // create vec2 so we can swizzle between small value and nothing\n    vec2 e = vec2(0.01, 0);\n\n    //get distance on every axis, a little bit offset from the point being evaluated.\n    vec3 offsetDistance = vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n    \n    //get normal by comparing distances between 2 close points\n    vec3 n = d-offsetDistance;\n    \n    return normalize(n);\n        \n}\n\nfloat GetLight(vec3 p)\n{\n    const float ambientLight = 0.0;\n    \n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    vec3 l = normalize(lightPos -p);\n    vec3 n = GetNormal(p);\n    \n    //raymarch to light to see if we are in shadow\n    float d = RayMarch(p+n*SURFACE_DIST*2.0, l);\n    \n    float dif = dot(n, l);\n    dif = clamp(dif, 0.0, 1.0);\n    \n    //if in shadow\n    if(d<length(lightPos-p))\n    {\n        dif *= 0.1f;\n    }\n    \n    return dif + ambientLight;\n}\n\n\nvec3 applyFog(in float d)\n{\n    float fogAmount = 1.0 - exp( -d *0.01);\n    return mix( vec3(0), vec3(1), fogAmount );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1). Center on middle of screen.\n    vec2 uv = (fragCoord-0.5f*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n\n    // Basic camera model.\n    vec3 ro = vec3(0,1,0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //get closest point in scene... move forward to that point. Iterativley find distance.\n \n    float d = RayMarch(ro, rd);\n    \n    col = applyFog(d);\n    \n    //get hit point\n    vec3 p = ro + rd * d;\n    \n    //diffuse lighting\n    float dif = GetLight(p);\n    col = vec3(dif) + col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}