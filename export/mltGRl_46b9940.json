{"ver":"0.1","info":{"id":"mltGRl","date":"1682963382","viewed":54,"name":"raytracing practice","username":"schzna","description":"practice","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265;\n\nfloat atan2(in float y, in float x){\n    return x == 0.0 ? sign(y)*PI/2.0 : atan(y, x);\n}\n\nvec3 gen_perpvec(vec3 n){\n    if(n.x == 0.0){\n        return vec3(1.0, 0.0, 0.0);\n    }\n    return normalize(vec3(n.y/n.x+n.z/n.x, -1.0, -1.0));\n}\n\nvec2 proj2d(vec3 v, vec3 b1, vec3 b2){\n    return vec2(dot(v, b1), dot(v, b2));\n}\n\nmat3 rot3d_x(float t){\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(t), -sin(t),\n        0.0, sin(t), cos(t)\n    );\n}\n\nmat3 rot3d_y(float t){\n    return mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n}\n\nmat3 rot3d_z(float t){\n    return mat3(\n        cos(t), -sin(t), 0.0,\n        sin(t), cos(t), 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n\nstruct lookpoint{\n    float k;\n    vec3 col;\n    vec3 n;\n};\n\nstruct figure{\n    //0: none\n    //1: sphere\n    //2: plane\n    int type;\n    \n    //common\n    vec3 pos;\n    vec3 col;\n    \n    //for sphere\n    float radius;\n    \n    //for plane\n    vec3 normal;\n    vec2 size;\n};\n\nstruct light{\n    //0: none\n    //1: parallel\n    //2: point\n    int type;\n    \n    float intensity;\n    \n    vec3 pos;\n    vec3 dir;\n};\n\nlookpoint look_sphere(vec3 ray, lookpoint cur, figure body){\n    float rc = dot(ray, body.pos);\n    float sqc = dot(body.pos, body.pos);\n    float sqr = dot(ray, ray);\n    \n    float D = rc * rc - sqr*(sqc - body.radius*body.radius);\n    \n    if(D < 0.0){\n        return cur;\n    }\n    \n    float k = (rc - sqrt(D))/sqr;\n    if(k < cur.k){\n        lookpoint new;\n        new.k = k;\n        new.n = normalize(k* ray - body.pos);\n        new.col = body.col;\n        return new;\n    }\n    return cur;\n}\n\nlookpoint look_plane(vec3 ray, lookpoint cur, figure body){\n    vec3 b1 = gen_perpvec(body.normal);\n    vec3 b2 = cross(body.normal, b1);\n    \n    vec2 pos2d = proj2d(body.pos, b1, b2);\n    vec2 ray2d = proj2d(ray, b1, b2);\n    float k = dot(body.normal, body.pos)/dot(body.normal, ray);\n    \n    if(k < cur.k && abs(k*ray2d.x - pos2d.x) < body.size.x/2.0 && abs(k*ray2d.y - pos2d.y) < body.size.y/2.0){\n        lookpoint new;\n        new.k = k;\n        new.n = body.normal;\n        new.col = body.col;\n        return new;\n    }\n    return cur;\n}\n\nvec3 light_para(lookpoint lp, light l){\n    return lp.col*pow(max(dot(lp.n.xyz, -normalize(l.dir)), 0.0), 0.8);\n}\n\nvec3 light_point(lookpoint lp, vec3 ray, light l){\n    vec3 d = l.pos-lp.k*ray;\n    return l.intensity*lp.col*pow(max(dot(lp.n.xyz, normalize(d)), 0.0), 0.6)/(1.0+dot(d,d));\n}\n\n//adhoc\nconst int max_num_figures = 4;\nconst int max_num_lights = 2;\nstruct world{\n    figure figures[max_num_figures];\n    light lights[max_num_lights];\n};\n\nvec4 raytrace_ref(world w, vec3 ray, vec3 pos){\n    mat3 to_forward = rot3d_y(PI/2.0-atan2(ray.z, ray.x));\n    vec3 nn = to_forward * ray;\n    mat3 down = rot3d_x(-atan2(nn.y, nn.z));\n    mat3 rot = down * to_forward;\n    ray = vec3(0.0, 0.0, -1.0);\n    \n    lookpoint lp;\n    lp.k = 100.0;\n    for(int i=0;i<max_num_figures;i++){\n        figure f = w.figures[i];\n        f.pos -= pos;\n        f.pos = rot * f.pos;\n        if(f.type == 1){\n            lp = look_sphere(ray, lp, f);\n        }else if(f.type == 2){\n            lp = look_plane(ray, lp, f);\n        }\n    }\n    \n    vec3 t = lp.n * dot(-ray, lp.n);\n    vec3 ref = 2.0*t+ray;\n    \n    vec3 col = vec3(0.0);\n    for(int i=0;i<max_num_lights;i++){\n        light l = w.lights[i];\n        l.pos -= pos;\n        l.pos = rot * l.pos;\n        if(l.type == 1){\n            col += light_para(lp, l);\n        }else if(l.type == 2){\n            col += light_point(lp, ray, l);\n        }\n    }\n    float shadow = 0.0;\n    return vec4(col, shadow);\n}\n\nvec3 raytrace(world w, vec3 ray){\n    lookpoint lp;\n    lp.k = 100.0;\n    lp.n = vec3(0.0);\n    for(int i=0;i<max_num_figures;i++){\n        figure f = w.figures[i];\n        if(f.type == 1){\n            lp = look_sphere(ray, lp, f);\n        }else if(f.type == 2){\n            lp = look_plane(ray, lp, f);\n        }\n    }\n    \n    vec3 t = lp.n * dot(-ray, lp.n);\n    vec3 ref = normalize(2.0*t+ray);\n    \n    \n    vec3 col = vec3(0.0);\n    for(int i=0;i<max_num_lights;i++){\n        light l = w.lights[i];\n        if(l.type == 1){\n            col += light_para(lp, l);\n        }else if(l.type == 2){\n            col += light_point(lp, ray, l);\n        }\n    }\n    //col += vec3(0.4)/(length(col)+1.0);\n    if(lp.k < 100.0){\n        vec4 refcol = raytrace_ref(w, ref, lp.k*ray);\n        if(refcol.w > 0.5){\n            col = vec3(0.0);\n        }else{\n            col = refcol.xyz * 0.5 + 0.5 * col;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 v = (fragCoord-iResolution.xy*0.5)/iResolution.yy;\n    float time = iTime * 1.0;\n    world w;\n    w.figures[0].type = 1;\n    w.figures[0].pos = vec3(cos(time), 0.0, 3.0);\n    w.figures[0].radius = 0.4;\n    w.figures[0].col = vec3(1.0, 1.0, 1.0);\n    \n    w.figures[1].type = 2;\n    w.figures[1].pos = vec3(0.0, -0.5, 3.0);\n    w.figures[1].normal = vec3(0.0, 1.0, 0.0);\n    w.figures[1].size = vec2(3.0, 5.0);\n    w.figures[1].col = vec3(0.0, 0.7, 1.0);\n    \n    w.figures[2].type = 1;\n    w.figures[2].pos = vec3(cos(2.0*time), 0.0, 3.0);\n    w.figures[2].radius = 0.4;\n    w.figures[2].col = vec3(1.0, 1.0, 1.0);\n    \n    w.lights[0].type = 2;\n    w.lights[0].intensity = 0.4;\n    w.lights[0].pos = vec3(-1.0, 1.0, 1.0);\n    \n    w.lights[1].type = 2;\n    w.lights[0].intensity = 5.0;\n    w.lights[1].pos = vec3(3.0, 3.0, 1.0);\n    \n    vec3 ray = normalize(vec3(v.x, v.y, 1.0));\n    vec3 col = raytrace(w, ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}