{"ver":"0.1","info":{"id":"dtGGDm","date":"1684114067","viewed":86,"name":"Fork Glittering","username":"mehow_one","description":"Glittering orb","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","orb","fresnel","glitter"],"hasliked":0,"parentid":"WltXDM","parentname":"Glittering orb"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 irri(float hue) {\n  \n  return .5+ .55 *cos(( 9.*hue)+ vec3(0,23.,21.));\n\n}\n\nconst int steps = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0.);\n    vec4 tex = texelFetch(iChannel0,ivec2(fragCoord),0);\n    // Post processing\n    \n    float thresh = 1.8;\n    float amt = 0.00225;\n    float tint_amt = .00025;\n    vec4 glow = vec4(0.);\n    for(int i = 0; i < steps; i++){\n        vec4 col1 = texelFetch(iChannel0,ivec2(fragCoord)+i*2,0);\n        vec4 col2 = texelFetch(iChannel0,ivec2(fragCoord)-i*2,0);\n        vec4 tint = vec4(irri(float(i*steps)*6.2830+iTime),0.)*tint_amt;\n        if(length(col1) > thresh){\n            col += col1 *amt * float(steps-i)+tint* float(steps-i);\n        }\n                if(length(col2) > thresh){\n            col += col2 *amt  * float(steps-i)+tint* float(steps-i);\n        }\n          col1 = texelFetch(iChannel0,ivec2(fragCoord)+i*ivec2(-1,1)*2,0);\n          col2 = texelFetch(iChannel0,ivec2(fragCoord)-i*ivec2(-1,1)*2,0);\n        if(length(col1) > thresh){\n            col += col1 *amt * float(steps-i)+tint* float(steps-i);\n        }\n                if(length(col2) > thresh){\n            col += col2 *amt  * float(steps-i)+tint* float(steps-i);\n        }\n        glow += col;\n    }\n    glow /= 40.;\n    \n    fragColor = vec4(tex.xyz+col.xyz+glow.xyz*.5,1.0);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEPS 100\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\n\nvec3 irri(float hue) {\n  \n  return .5+ .55 *cos(( 9.*hue)+ vec3(0,23.,21.));\n\n}\n\nmat3 rotY(float angle)\n{\n    return mat3\n        (\n            cos(angle),\t\t0,\t\tsin(angle),\n            0,\t\t\t\t1.0,\t0,\n            -sin(angle),\t0,\t\tcos(angle)\n        );\n}\n\nfloat lambert(vec3 normal, vec3 lightPos)\n{\n\treturn max(dot(normal, lightPos), 0.05);\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    vec3 p = vec3(pos.x+cos(pos.y*10.)*.125,pos.y,pos.z+sin(pos.y*10.)*.125+.25);\n    return length(p - center) - radius;\n}\n\nvec3 sdSphereNormal(vec3 pos, vec3 center, float radius)\n{\n\tconst vec2 eps = vec2(0.01, 0.0);\n    return normalize\n\t(\tvec3\n     \t(\tsdSphere(pos + eps.xyy, center, radius) - sdSphere(pos - eps.xyy, center, radius),\n\t\t\tsdSphere(pos + eps.yxy, center, radius) - sdSphere(pos - eps.yxy, center, radius),\n\t\t\tsdSphere(pos + eps.yyx, center, radius) - sdSphere(pos - eps.yyx, center, radius)\n\t\t)\n\t);\n}\n\nfloat sdSphereRender(vec3 pos, vec3 center, float radius, vec3 lightPos)\n{\n\tvec3 normal = sdSphereNormal(pos, center, radius);\n    float grain = pow(max(dot(normalize(textureLod(iChannel0, fract(pos +iTime*.0125)*2., 0.0).rgb - 0.5), center), 0.0), 250.0);\n\treturn lambert(normal, lightPos+grain*.75);\n}\n\nfloat sdSphereRaymarch(vec3 pos, vec3 dir, vec3 center, float radius, int steps, float minDist, float maxDist)\n{\n    float curDist = minDist;\n\tfor(int i = 0; i < steps; i++)\n\t{\n\t\tfloat dist = sdSphere(pos + curDist * dir, center, radius);\n\t\tif(dist < EPSILON) return curDist;\n\t\tcurDist += dist;\n\t}\n\treturn maxDist;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float res = min(iResolution.x, iResolution.y);\n    vec2 p = (fragCoord.xy - 0.5 * iResolution.xy) / res;\n    vec2 um = (iMouse.xy - 0.5 * iResolution.xy) / res;\n    \n    float a = 0.5 * sin(iTime);\n\tvec3 cam = vec3(0.0, 1.0, 5.5) * rotY(a);\n    vec3 tgt = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ww = normalize(tgt - cam);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 ray = normalize(p.x * uu + p.y * vv + 1.5 * ww);\n\t\n    vec3 center = vec3(0, 0, 0);\n    float radius = 1.5;\n    vec3 light = normalize(vec3(0.0, 6.0, 3.0));\n\t\n    float d = sdSphereRaymarch(cam, ray, center, radius, STEPS, MIN_DIST, MAX_DIST);\n    vec3 sphere = cam + ray * d;\n    float f = sdSphereRender(sphere, center, radius, light);\n    vec3 n = sdSphereNormal(sphere, center, radius);\n    \n    float fresnel = pow(1. + dot(n, ray), 0.75)*1.25;\n    float sparkles = pow(max(dot(normalize(textureLod(iChannel0, sphere, 0.0).rgb - 0.5), ray), 0.0), 250.0);\n\t\n    vec3 sphereColor = irri(n.z*0.125+iTime*0.125)*.5+.5;\n    vec3 emissiveColor = irri(n.z*0.125+iTime*0.25+fresnel*.925*n.z)*.5;\n    vec3 skyColor = vec3(0.0);\n    \n    vec3 col = mix(sphereColor, emissiveColor, fresnel);\n    col += sparkles * (1.25 - clamp(fresnel, 0.0, 1.0));    \n    col = mix(col * f, skyColor, step(MAX_DIST - EPSILON, d));\n    //col = mix(textureLod(iChannel0, sphere * 0.01, 0.0).rgb, skyColor, step(MAX_DIST - EPSILON, d));\n    //col += mix(n, skyColor, step(MAX_DIST - EPSILON, d))*0.125;\n    \n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}