{"ver":"0.1","info":{"id":"mtdczM","date":"1699023481","viewed":158,"name":"defender fork","username":"jorge2017a2","description":"defender fork","likes":13,"published":3,"flags":32,"usePreview":0,"tags":["defenderfork"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///---por jorge flores\n//jorge2017a1\n///defender fork ---- 3-nov-2023\n//referencia\n//https://www.shadertoy.com/view/ml3cRH\n\nvec3 cuadroChico(vec2 p, vec3 col, vec3 col2)\n{\n    vec2 pos=p-vec2(0.5,0.9);\n    vec2 pos2=p-vec2(0.5,0.9);\n    float d0= sdBox(pos, vec2(0.135,0.075) );\n    float d1= sdBox(pos2, vec2(0.125,0.068) );\n    vec3 colin=col2;\n    col= DrawFigBorde(vec3(1.0,0.0,0.0), col, abs(d0)-0.015);\n    col= DrawFigSolo(colin, col, d1);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv0 = fragCoord.xy/iResolution.xy;\n    \n    vec3 col=texture(iChannel0,uv).xyz;\n    vec3 col2=texture(iChannel0,uv*4.6+vec2(-1.85,-3.8)).xyz;\n    col+= cuadroChico(uv,col, col2);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define antialiasing(n) n/min(288.,512.)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nconst int ENEMY_BITMAP[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,2,2,2,2,0,0,0,0,0,0,\n0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,\n0,0,0,0,1,1,2,2,2,2,1,1,0,0,0,0,\n0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,\n0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,\n0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,\n0,0,0,0,1,1,2,1,2,2,1,0,0,0,0,0,\n0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,\n0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,\n0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,\n0,0,1,0,0,0,0,1,0,0,0,0,1,0,0,0,\n0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n\nconst int NAVE_BITMAP[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,\n0,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,\n0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,\n0,2,1,2,2,1,1,1,1,0,0,0,5,0,0,0,\n0,0,0,2,2,2,1,1,1,1,1,1,1,3,4,0,\n0,0,0,2,2,1,3,4,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n\nconst int NAVE_E_BITMAP[256] = int[]\n(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,\n0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,\n0,1,0,0,0,3,3,0,3,3,0,0,0,1,0,0,\n0,1,2,2,0,3,2,0,3,2,0,2,2,1,0,0,\n0,0,1,2,2,2,2,2,2,2,2,2,1,0,0,0,\n0,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\nconst int NAVE_BOMBA[256] = int[](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,\n0,0,0,0,0,2,2,2,2,2,2,2,2,2,2,0,\n0,0,0,1,1,1,1,1,1,1,1,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,0,0,0,0,0,0,1,1,2,2,0,\n0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\n \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\nvec3 RGB3(float r ,float g, float b)\n{ return vec3(r/255.,g/255.,b/255.);}\n\n\n\nint readEnemyBitMap(in vec2 uv) \n{ return ENEMY_BITMAP[int(uv.y) * 16 + int(uv.x)]; }\n\n\nvec3 GetColorEnemy(int opc)\n{   switch(opc)\n    {   case 0:return RGB3(0.,0.,0.);\n        case 1:return RGB3(0.,184.,0.);\n        case 2:return RGB3(254.,184.,0.);\n    }\n    return vec3(1.0);\n}\n\n\nvec3 GetColorNave(int opc)\n{   switch(opc)\n    {\n        \n    case 0:return RGB3(0.,0.,0.);\n    case 1:return RGB3(140.,140.,140.);\n    case 2:return RGB3(255.,0.,255.);\n    case 3:return RGB3(255.,255.,255.);\n    case 4:return RGB3(0.,159.,98.);\n    case 5:return RGB3(255.,255.,0.);\n\n    }\n    return vec3(1.0);\n}\n\n\nvec3 GetColorNave_E(int opc)\n{   switch(opc)\n    {\n    //(0,0,0),(0,0.624,0.384),(1,0.976,0.616),(1,0,0),\n    case 0:return vec3(0.,0.,0.);\n    case 1:return vec3(0,0.624,0.384);\n    case 2:return vec3(1,0.976,0.616);\n    case 3:return vec3(1,0,0);\n    }\n    return vec3(1.0);\n}\n\nvec3 GetColorBOMBA(int opc)\n{   switch(opc)\n    {\n    case 0:return vec3(0.,0.,0.);\n    case 1:return vec3(0.953,0.62,0.467);\n    case 2:return vec3(0.886,0,0.498);\n    }\n    return vec3(1.0);\n}\n\n\nvec3 PonerEnemy(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( ENEMY_BITMAP[pix.x+pix.y*16] );    \n        if(opc!=0)\n        col=GetColorEnemy(opc); \n    }\n    return col;\n}\n\n\nvec3 PonerNave(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( NAVE_BITMAP[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColorNave(opc);\n    }\n    return col;\n}\n\n\nvec3 PonerNave_E(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( NAVE_E_BITMAP[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColorNave_E(opc);\n    }\n    return col;\n}\n\n\nvec3 PonerBOMBA(vec2 uv, ivec2 pos, vec3 col)\n{   int opc;\n    ivec2 pix = ivec2(uv*256.)+ivec2(-pos.x*16,-16*pos.y);\n     pix.y=-pix.y+15;\n    if (min(pix.x, pix.y) >= 0 && max(pix.x, pix.y) < 16) \n    {   opc=int( NAVE_BOMBA[pix.x+pix.y*16] );\n        if(opc!=0) col=GetColorBOMBA(opc);\n    }\n    return col;\n}\n\n\n// T = terrain world position\nvec3 Terrain(vec2 uv, float T, vec3 col)\n{\n    float scale = 64.;\n    float a = T*.25 + uv.x*7.;\n    float elev = sin(a+cos(a)*1.205-sin(a*4.)*cos(a))*.1+.2+sin(a*17.)*.01;\n    float uy = floor(uv.y*scale)/scale;\n    if (abs(uy-elev) < .007)\n    {\n        col = vec3(1.,.4,0);\n    }\n    return col;\n}\n\n\nvec3 hacertierraB(vec2 p, vec3 col)\n{\n    float fx=(2.0*sin(p.y));\n    fx=abs(fx)-0.1;\n    col= DrawFigBorde(vec3(0.0), col, abs(fx)-0.001);\n    \n    return col;\n}\n\nvec3 monta(vec2 p, vec3 colOut,vec3 colIn)\n{   float d1=(cos(p.x*0.25 +cos(p.x*0.5)))+p.y-2.0;\n    float d2=abs(d1)-0.05;\n    d1=d2;\n    colOut= DrawFigBorde(colIn,colOut,d1);\n    return colOut;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//https://www.shadertoy.com/view/ml3cRH\nvec3 Stars(vec2 w, vec3 col)\n{\n    if (w.y > .2)\n    {\n        float y = w.y * 50.;\n        if (sin(y) > .9 && sin(iTime*.5 + w.x*2. + w.y*43100.+cos(w.y)) > .9999991) return vec3(1);\n    }\n    return col;\n}\n\nfloat rand(vec2 co)\n{ return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);}\n\nfloat noise(vec2 co)\n{\n    vec2 p = floor(co);\n    vec2 f = fract(co);\n    float a = rand(p);\n    float b = rand(p + vec2(1.0, 0.0));\n    float c = rand(p + vec2(0.0, 1.0));\n    float d = rand(p + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n//https://www.shadertoy.com/view/DscSWX\nvec3 stars3(vec2 uv, vec3 col )\n{\n    float time = mod(iTime, 100.);\n    float speed = 1.0;\n    float frequency = 6.0;\n    float density = 0.2;\n    int depth = 2;\n    vec3 color = vec3(0.8, 0.8, 1.);\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    float noiseValue = 0.0;\n    for (int i = 0; i < depth; i++) {\n        noiseValue += noise(uv * frequency + vec2(-time * speed, 0.0)) * density;\n        frequency *= 2.0;\n        density *= 0.5;\n    }\n    col+=color * noiseValue;\n    return col;\n}\n\nvec3 fuego(vec2 p,vec2 pos,  vec3 col)\n{   if( p.x>pos.x && p.x<pos.x+0.5)\n    { float d1=p.y+pos.y;\n        col= DrawFigSolo(vec3(1.0,0.0,0.0), col, abs(d1)-0.001);\n    }\n    return col;\n}\n\nvec3 soloLinea(vec2 p, vec3 col)\n{   float d1=p.y-0.8;\n    col= DrawFigSolo(vec3(1.0,0.0,0.0), col, abs(d1)-0.001);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec3 col;\n    float t=iTime;\n    col= soloLinea(uv,col);\n    col= monta( uv*11.0+vec2(t,0.0),col,vec3(1.0,1.0,1.0));\n    col=Stars(uv, col);\n    if (2.0*sin(t)>0.0)\n        col=stars3(uv,col );\n        \n    ivec2 posi=ivec2(2,2);\n    ivec2 pos2=ivec2(5,5);\n    ivec2 pos3=ivec2(10+int(5.0*sin(iTime)),8);\n    col= PonerEnemy(uv, posi+ivec2(0,int(4.0*abs(sin(t)))), col);\n    col=PonerNave(uv*0.75, pos2, col);\n    col= fuego(uv,vec2(0.5+ mod(iTime,1.5),-0.445), col);\n    col=PonerNave_E(uv,pos3,col);\n     col=PonerBOMBA(uv, ivec2(15,9+int(4.0*sin(t))),col);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}