{"ver":"0.1","info":{"id":"Xdtyzj","date":"1519995817","viewed":502,"name":"Shading Experiment","username":"gam0022","description":"- Ambient Occlusion\n- Soft Shadow\n- Fog\n- Cubemap","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n//#define AO_NONE\n#define AO_TYPE1\n//#define AO_TYPE2\n\n//#define DEBUG_AO\n//#define DEBUG_FIX_CAMERA\n\n#define FOG_ON\n#define SHADOW_ON\n\n#ifdef GLSLSANDBOX\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#endif\n\n// consts\nconst float INF = 1e+10;\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\nconst float PI = 3.14159265359;\nconst float PI2 = 6.28318530718;\nconst float PIH = 1.57079632679;\nconst float PIQ = 0.78539816339;\n\nconst float GROUND_BASE = 0.0;\n\n\n// globals\nconst vec3 lightDir = vec3( -0.48666426339228763, 0.8111071056538127, 0.3244428422615251 );\n\nfloat lTime;\n#define LOOP_TIME (60.0)\n\n// ray\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\n// camera\nstruct Camera {\n    vec3 eye, target;\n    vec3 forward, right, up;\n    float zoom;\n};\n\nRay cameraShootRay(Camera c, vec2 uv) {\n    c.forward = normalize(c.target - c.eye);\n    c.right = normalize(cross(c.forward, c.up));\n    c.up = normalize(cross(c.right, c.forward));\n\n    Ray r;\n    r.origin = c.eye;\n    r.direction = normalize(uv.x * c.right + uv.y * c.up + c.zoom * c.forward);\n\n    return r;\n}\n\n// intersection\nstruct Intersection {\n    bool hit;\n    vec3 position;\n    float distance;\n    vec3 normal;\n    vec2 uv;\n    float count;\n\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float reflectance;\n\n    vec3 color;\n};\n\n// util\n#define saturate(x) clamp(x, 0.0, 1.0)\n    \n#define calcNormal(p, dFunc) normalize(vec2(EPS_N, -EPS_N).xyy * dFunc(p + vec2(EPS_N, -EPS_N).xyy) + vec2(EPS_N, -EPS_N).yyx * dFunc(p + vec2(EPS_N, -EPS_N).yyx ) + vec2(EPS_N, -EPS_N).yxy * dFunc(p + vec2(EPS_N, -EPS_N).yxy) + vec2(EPS_N, -EPS_N).xxx * dFunc(p + vec2(EPS_N, -EPS_N).xxx))\n\nfloat sdGround(in vec3 p) {\n    return p.y + GROUND_BASE;\n}\n\nvoid intersectGround(inout Intersection intersection, inout Ray ray) {\n    float t = -(ray.origin.y + GROUND_BASE) / ray.direction.y;\n    if (t > 0.0) {\n        intersection.distance = t;\n        intersection.hit = true;\n        intersection.position = ray.origin + t * ray.direction;\n        intersection.normal = vec3(0.0, 1.0, 0.0);\n        intersection.ambient = vec3(0.3);\n        intersection.diffuse = vec3(0.3);\n        intersection.specular = vec3(0.5);\n        intersection.reflectance = 0.1;\n    }\n}\n\n// Distance Functions\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat dSphereCenter(vec3 p) {\n    return dSphere(p - vec3(0.0, 1.0, -0.5), 1.0);\n}\n\nfloat dSphereLeft(vec3 p) {\n    return dSphere(p - vec3(2.5, 1.0, 0.0), 1.0);\n}\n\nfloat dBar(vec2 p, float width) {\n    vec2 d = abs(p) - width;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) + 0.01 * width;\n}\n\nfloat dCrossBar(vec3 p, float x) {\n    float bar_x = dBar(p.yz, x);\n    float bar_y = dBar(p.zx, x);\n    float bar_z = dBar(p.xy, x);\n    return min(bar_z, min(bar_x, bar_y));\n}\n\nfloat dMengerSponge(vec3 p) {\n    float d = sdBox(p, vec3(1.0));\n    float one_third = 1.0 / 3.0;\n    for (float i = 0.0; i < 3.0; i++) {\n        float k = pow(one_third, i);\n        float kh = k * 0.5;\n        d = max(d, -dCrossBar(mod(p + kh, k * 2.0) - kh, k * one_third));\n    }\n    return d;\n}\n\nfloat dMengerSpongeRight(vec3 p) {\n    return dMengerSponge(p - vec3(-2.5, 1.0, 0.0));\n}\n\nfloat dObjects(vec3 p) {\n    float d = dSphereCenter(p);\n    d = min(d, dSphereLeft(p));\n    d = min(d, dMengerSpongeRight(p));\n    return d;\n}\n\nfloat dScene(vec3 p) {\n    float d = dObjects(p);\n    d = min(d, sdGround(p));\n    return d;\n}\n\n// color functions\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, saturate(p - K.xxx), c.y);\n}\n\nvoid intersectObjects(inout Intersection intersection, inout Ray ray) {\n    float d;\n    float distance = 0.0;\n    vec3 p = ray.origin;\n\n    for (float i = 0.0; i < 100.0; i++) {\n        d = dObjects(p);\n        distance += d;\n        p = ray.origin + distance * ray.direction;\n        intersection.count = i;\n        if (abs(d) < EPS || distance > 100.0) break;\n    }\n\n    if (abs(d) < EPS && distance < intersection.distance) {\n        intersection.distance = distance;\n        intersection.hit = true;\n        intersection.position = p;\n        intersection.normal = calcNormal(p, dScene);\n        if (abs(dSphereLeft(p)) < EPS) {\n            intersection.ambient = vec3(0.0);\n            intersection.diffuse = vec3(0.0);\n            intersection.specular = vec3(0.5);\n            intersection.reflectance = 0.9;\n        } else if (abs(dSphereCenter(p)) < EPS) {\n            intersection.ambient = vec3(0.3, 0.3, 0.6) * 1.2;\n            intersection.diffuse = vec3(0.3, 0.3, 0.6) * 0.5;\n            intersection.specular = vec3(0.3);\n            intersection.reflectance = 0.2;\n        } else if (abs(dMengerSpongeRight(p)) < EPS) {\n            intersection.ambient = vec3(0.1, 0.2, 0.1) * 2.0;\n            intersection.diffuse = vec3(0.1, 0.2, 0.1) * 0.2;\n            intersection.specular = vec3(0.0);\n            intersection.reflectance = 0.0;\n        }\n    }\n}\n\nvoid intersectScene(inout Intersection intersection, inout Ray ray) {\n    intersection.distance = INF;\n    intersectGround(intersection, ray);\n    intersectObjects(intersection, ray);\n}\n\nfloat calcAo(in vec3 p, in vec3 n){\n    float k = 1.0, occ = 0.0;\n    for(int i = 0; i < 5; i++){\n        float len = 0.15 + float(i) * 0.15;\n        float distance = dScene(n * len + p);\n        occ += (len - distance) * k;\n        k *= 0.5;\n    }\n    return saturate(1.0 - occ);\n}\n\nfloat calcShadow(in vec3 p, in vec3 rd) {\n    float d;\n    float distance = OFFSET;\n    float bright = 1.0;\n    float shadowIntensity = 0.8;\n    float shadowSharpness = 10.0;\n\n    for (int i = 0; i < 30; i++) {\n        d = dScene(p + rd * distance);\n        if (d < EPS) return shadowIntensity;\n        bright = min(bright, shadowSharpness * d / distance);\n        distance += d;\n    }\n\n    return shadowIntensity + (1.0 - shadowIntensity) * bright;\n}\n\nvoid calcRadiance(inout Intersection intersection, inout Ray ray, int bounce) {\n    intersection.hit = false;\n    intersectScene(intersection, ray);\n\n    if (intersection.hit) {\n        // shading\n        float diffuse = saturate(dot(lightDir, intersection.normal));\n        float specular = pow(saturate(dot(reflect(lightDir, intersection.normal), ray.direction)), 10.0);\n        \n        #ifdef AO_TYPE1\n        float ao = calcAo(intersection.position, intersection.normal);\n        #endif\n        \n        #ifdef AO_TYPE2\n\t\tfloat ao = saturate(1.0 - 0.02 * intersection.count);\n        #endif\n        \n        #ifdef AO_NONE\n\t\tfloat ao = 1.0;\n        #endif\n        \n        #ifdef SHADOW_ON\n        float shadow = calcShadow(intersection.position, lightDir);\n        #else\n        float shadow = 1.0;\n        #endif\n        \n        #ifdef DEBUG_AO\n        intersection.color = vec3(ao);\n        #else\n        intersection.color = \n            intersection.ambient * ao +\n            intersection.diffuse * diffuse * shadow +\n            intersection.specular * specular * shadow;\n        #endif\n        \n        // fog\n\t\t#ifdef FOG_ON\n        intersection.color = mix(intersection.color, vec3(0.8), \n                                 1.0 - exp(-0.0001 * intersection.distance * intersection.distance * intersection.distance));\n        #endif\n    } else {\n        intersection.color = texture(iChannel0, ray.direction).rgb;\n    }\n}\n\n#ifdef DEBUG_AO\n#define BOUNCE_LIMIT (1)\n#else\n#define BOUNCE_LIMIT (3)\n#endif\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // set globals\n    //lTime = 2.5;\n    //lTime = mod(iTime, LOOP_TIME);\n\n    // fragment position\n    // vec2 uv = (gl_FragCoord.xy * 2.0 - resolution ) / min( resolution.x, resolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    float cameraR = 8.0;\n    \n    #ifdef DEBUG_FIX_CAMERA\n    mouseUV = vec2(0.45, 0.8);\n    #endif\n    \n    // camera and ray\n    Camera camera;\n    camera.eye.x = cameraR * sin(mouseUV.y * PIH) * cos(mouseUV.x * PI + PI);\n    camera.eye.z = cameraR * sin(mouseUV.y * PIH) * sin(mouseUV.x * PI + PI);\n    camera.eye.y = cameraR * cos(mouseUV.y * PIH);\n    camera.target = vec3(-0.3, 1.0, 0.0);\n    camera.up = vec3(0.0, 1.0, 0.0);// y-up\n    camera.zoom = 3.0;\n    Ray ray = cameraShootRay(camera, uv);\n\n    vec3 color = vec3(0.0);\n    float reflection = 1.0;\n    Intersection intersection;\n\n    for (int bounce = 0; bounce < BOUNCE_LIMIT; bounce++) {\n        calcRadiance(intersection, ray, bounce);\n        color += reflection * intersection.color;\n        if (!intersection.hit) break;\n        reflection *= intersection.reflectance;\n        ray.origin = intersection.position + intersection.normal * OFFSET;\n        ray.direction = normalize(reflect(ray.direction, intersection.normal));\n    }\n\n    //gl_FragColor = vec4(color, 1.0);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}