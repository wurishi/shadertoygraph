{"ver":"0.1","info":{"id":"NlBcRc","date":"1649991929","viewed":118,"name":"Moduli of Right Angled Pentagons","username":"stevejtrettel","description":"Tessellating the hyperbolic plane with pentagons in various ways!\n(Math Description:) There is a 2-dimensional moduli space of representations of the right angled pentagon reflection group in Isom(H2) up to conjugacy: this program draws them!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolicgeometry","coxetergroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//default is drawn in poincare disk:\n//switch to upper half plane?\nbool halfPlane=false;\n\n\n//------------------------------------------\n//Useful Constants\n//------------------------------------------\n\nfloat PI = 3.14159;\nfloat sqrt2 = sqrt(2.);\nfloat sqrt3 = sqrt(3.);\nvec2 I = vec2(0.,1.);\n\n//floating point infinity:\n//the funciton isinf() tests if a value is infinite, returning a boolean\nfloat infty = 1./0.;\n\n\n\n//------------------------------------------\n//Useful Colors\n//------------------------------------------\n\nvec3 lightBlue = vec3(170,210,255)/255.;\nvec3 medBlue = vec3(120, 170, 250)/255.;\nvec3 darkBlue = vec3(110, 155, 240)/255.;\n\nvec3 lightPurple = vec3(170,210,255)/255. + vec3(0.2,0,0);\nvec3 medPurple = vec3(120, 170, 250)/255. + vec3(0.3,0,0);\nvec3 darkPurple = 0.7*(vec3(110, 155, 240)/255. + vec3(0.3,0,0));\n\nvec3 lightGreen = vec3(149, 245, 181)/255.;\nvec3 medGreen = vec3(149, 245, 181)/255.;\n\nvec3 pink = vec3(255, 117, 133)/255.;\n\n\n    vec3 usfYellow = vec3(255, 184, 28)/255.;\n    vec3 usfGray = vec3(117,120,123)/255.;\n    vec3 usfGreen = vec3(32,92,64)/255.;\n    vec3 white = vec3(1,1,1);\n\n\n//----------------------------------------------\n//------------------------------------------\n//SETUP\n//------------------------------------------\n//----------------------------------------------\n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizeCoords( vec2 fragCoord ){\n\n    // Normalized the pixel coordinates from 0 to 1\n    //fragCoord is a vector of integers, giving the pixel on the screen\n    //its (0,0) in the top left, increasing down and to the right.\n    //iResolution is a uniform giving the total number of pixels across x,y\n    //the bottom right corner of the screen has pixel coordinates (iResolution.x, iResolution.y)\n\n\n    //dividing fragCoord by iResolution results in coordinates running from (0,0) to (1,1)\n    vec2 uv =fragCoord/iResolution.xy;\n\n    //translate so coordinates run (-0.5, 0.5)\n    uv = uv - vec2(0.5);\n\n    //preserve original aspect ratio\n    float aspect = iResolution.y/iResolution.x;\n    uv = vec2(1,aspect)*uv;\n\n    //rescale however you like\n    uv = 4.*uv;\n\n    return uv;\n}\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//COMPLEX NUMBERS\n//------------------------------------------\n//----------------------------------------------\n\n//points in the hyperbolic plane are represented by vec2(x,y)\n//these can be added, subtracted and scalar multiplied by built-in operations\n//these can be multiplied and inverted (as complex numbers) using the following\n\n\n//turn a real number into a complex number\nvec2 toC( float x ){\n    return vec2(x,0);\n}\n\n\n\n//complex multiplication\nvec2 mult( vec2 z, vec2 w )\n{\n    float re = z.x*w.x - z.y*w.y;\n    float im = z.x*w.y + z.y*w.x;\n\n    vec2 res = vec2(re, im);\n    return res;\n}\n\n\n//complex conjugation, negates imaginary party\nvec2 conj( vec2 z )\n{\n    vec2 res = vec2(z.x,-z.y);\n    return res;\n}\n\n\n//inverse of the complex number z\nvec2 invert( vec2 z )\n{\n    float mag2 = dot(z,z);\n    vec2 res = conj(z)/mag2;\n    return res;\n}\n\n\n//compute the quotient z/w\nvec2 divide( vec2 z, vec2 w )\n{\n    return mult(z,invert(w));\n}\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//CONVERSIONS BETWEEN MODELS\n//------------------------------------------\n//----------------------------------------------\n\n\n//------------------------------------------\n//Poincare Disk Model\n//------------------------------------------\n\n\n//check if you are inside the unit disk or not\nbool insidePD( vec2 z )\n{\n    //returns true if the inequality is satisfied, falso otherwise\n    return dot(z,z)<1.;\n}\n\n\n\n//apply the mobius transformation taking a point to UHP\n//this is the map z -> (iz+1)/(z+i)\nvec2 toHP( vec2 z ){\n\n    vec2 num = z+I;\n    vec2 denom = mult(I,z)+toC(1.);\n    vec2 res = divide(num,denom);\n    return res;\n}\n\n\n\n\n\n\n\n\n\n//------------------------------------------\n//Upper Half Plane Model\n//------------------------------------------\n\n//check if you are in the upper half plane or not\nbool insideHP( vec2 z )\n{\n    //returns true if the inequality is satisfied, falso otherwise\n    return z.y>0.;\n}\n\n\n//take a point in the upper half plane and map it to the disk\n//this is the transformation z -> (z-i)/(z+i)\nvec2 toPD(vec2 z){\n    vec2 num = z-I;\n    vec2 denom = z+I;\n    vec2 res = divide(num,denom);\n    return res;\n}\n\n\n\n\n\n//------------------------------------------\n//BAND MODEL:\n//------------------------------------------\n\n\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\nvec2 cdiv(vec2 a, vec2 b)\n{\n    float b2 = dot(b, b);\n    return vec2(dot(a, b), a.y * b.x - a.x * b.y) / b2;\n}\nvec2 ctanh(vec2 z)\n{\n    float d = cosh(2.*z.x) + cos(2.*z.y);\n    return vec2(sinh(2.*z.x), sin(2.*z.y)) / d;\n}\n\n\n\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//Upper Half Plane\n//------------------------------------------\n//----------------------------------------------\n\n//this is a general mobius transformation applied to points in upper half space\n//do the mobius transformation ((a,b),(c,d)).z\nvec2 applyMobius(vec4 mob, vec2 z){\n    float a=mob.x;\n    float b=mob.y;\n    float c=mob.z;\n    float d=mob.w;\n\n    vec2 num = a*z+toC(b);\n    vec2 denom = c*z + toC(d);\n\n    vec2 res = divide(num,denom);\n\n    return res;\n\n}\n\n\n\n\n//return result of the isometry in stab(infty) which sends origin to p, applied to z\nvec2 originToP(vec2 p, vec2 z){\n    float x = p.x;\n    float y = p.y;\n\n    //expand by y\n    z = y*z;\n    \n    //slide by x\n    z=z+vec2(x,0);\n    \n    //together this took (0,1) to (0,y) to (x,y)\n    return z;\n}\n\n\nvec2 pToOrigin(vec2 p, vec2 z){\n    float x = p.x;\n    float y = p.y;\n    float r = x;\n\n    //slide by x\n    z = z - vec2(x, 0.);\n\n    //divide by y\n    z = z/y;\n\n    //now; p has been moved to (x,y)->(0,y)->(0,1)\n    //which is the origin of UHP\n    return z;\n}\n\n\n\n\n\n\n//------------------------------------------\n//Points\n//------------------------------------------\n// a point is just a vec2, thought of as a complex number;\n//no special structure here\n\n\n//measure the distance to a point\nfloat dist(vec2 z, vec2 p){\n\n    //just directly using distance function in UH\n    vec2 rel = z-p;\n    float num = dot(rel,rel);\n    float denom = 2.*z.y*p.y;\n    return acosh(1.+num/denom);\n\n}\n\n\n\n\n\n\n//------------------------------------------\n//Geodesics\n//------------------------------------------\n\n\n//a geodesic is encoded by remembering its two boundary points\n//these are real numbers (or the constant infty)\nstruct Geodesic{\n//first endpoint\n    float p;\n//second endpoint\n    float q;\n};\n\n\n\n//check if a geodesic is a line\nbool isLine( Geodesic geo ) {\n    return isinf(geo.p)||isinf(geo.q);\n}\n\n\n\n\n//check if a geodesic is a line, and return its endpoint\nbool isLine( Geodesic geo, out float endpt ) {\n\n    //if p is infinity, q is the real endpoint\n    if(isinf(geo.p)){\n        endpt = geo.q;\n        return true;\n    }\n\n    //if q is infinity, p is the real endpoint\n    else if ( isinf(geo.q) ){\n        endpt = geo.p;\n        return true;\n    }\n\n    //if neither is infinity, its not a line\n    return false;\n}\n\n\n\n\n\n//reflect in the geodesic geo\nvec2 reflectIn(vec2 z, Geodesic geo){\n\n    float endpt;\n\n    //if its a line, do one thing\n    if(isLine(geo,endpt)){\n        z.x -= endpt;\n        z.x *= -1.;\n        z.x += endpt;\n        return z;\n    }\n\n    //else, if its a circle do something else\n    else{\n        float center = (geo.p+geo.q)/2.;\n        float radius = abs((geo.p-geo.q))/2.;\n\n        z.x -= center;\n        z /= radius;\n        z /= dot(z,z);\n        z *= radius;\n        z.x += center;\n\n        return z;\n    }\n}\n\n\n\n//measure the distance to a geodesic\nfloat dist(vec2 z, Geodesic geo){\n\n    float endpt;\n\n    //if its a vertical line\n    if(isLine(geo,endpt)){\n        //translate to the origin\n        z.x-=endpt;\n        //measure distance as angle\n        float secTheta=length(z)/abs(z.y);\n        return acosh(secTheta);\n    }\n\n    //otherwise, its a circle\n    else{\n\n        //build mobius transformation taking geo to (0,infty)\n        vec4 mob=vec4(1.,-geo.p,1.,-geo.q);\n        z = applyMobius(mob, z);\n\n        //now measure the distance to this vertical line\n        //measure distance as angle\n        float secTheta=length(z)/abs(z.y);\n        return acosh(secTheta);\n    }\n}\n\n\n\n\n\n\n\n\n//------------------------------------------\n//Half Spaces\n//------------------------------------------\n\n\n//a half space is bounded by a geodesic,\n//and is all the area on one side of it\n//side is - if it contains a portion of the real line (bounded area in model)\n//side is + if it contains infinity\nstruct HalfSpace{\n    Geodesic bdy;\n    float side;\n};\n\n\n\n//inside checks if you are in a half space or not:\nbool inside(vec2 z, HalfSpace hs){\n\n    float endpt;\n\n    //if the half space is bounded by a line:\n    if( isLine( hs.bdy, endpt ) ){\n\n        //is point to the right (+) or left (-) of the boundary?\n        float side = sign(z.x - endpt);\n\n        //check if this is inside (+) or outside (-) the halfspace\n        return side*hs.side>0.;\n    }\n\n    //otherwise, the half space is bounded by a circle\n    //endpoint was never assigned so dont use it\n    else{\n\n        float center = (hs.bdy.p+hs.bdy.q)/2.;\n        float radius = abs((hs.bdy.p-hs.bdy.q))/2.;\n\n        //get relative position\n        vec2 rel = z-toC(center);\n        //get radius\n        float dist2 = dot(rel,rel);\n\n        //get inside (+) or outside (-) circle\n        float side = sign(dist2-radius*radius);\n\n        //return true (+) if in half space, false if not\n        return side*hs.side>0.;\n    }\n}\n\n\n\n\n//reflect into a half space:\n//if you are inside already, do nothing\n//if you are outside, reflect in the boundary\n//parity is +-1, if we do a reflection we multiply it by -1.\nvec2 reflectIn( vec2 z, HalfSpace hs, inout float parity) {\n    if(!inside(z,hs)){\n        vec2 res = reflectIn(z,hs.bdy);\n        parity*=-1.;\n        return res;\n    }\n\n    return z;\n}\n\n\n\n\n\n//------------------------------------------\n//Right Angled Pentagons\n//------------------------------------------\n\n//a  right angled pentagon is the intersection of 5 orthognal half spaces\n//we will call these a, b, c, d, and e\nstruct Pentagon{\n    HalfSpace a;\n    HalfSpace b;\n    HalfSpace c;\n    HalfSpace d;\n    HalfSpace e;\n};\n\n\n\n\nbool inside(vec2 z, Pentagon P){\n    //check if you are inside all three half-spaces\n    return inside(z,P.a)&&inside(z,P.b)&&inside(z,P.c)&&inside(z,P.d)&&inside(z,P.e);\n}\n\n\n\n\n//reflect in each side of the triangle,\n//if the point is on the wrong side of the half space\nvec2 reflectIn(vec2 z, Pentagon P, inout float parity){\n    z = reflectIn(z, P.a, parity);\n    z = reflectIn(z, P.b, parity);\n    z = reflectIn(z, P.c, parity);\n    z = reflectIn(z, P.d, parity);\n    z = reflectIn(z, P.e, parity);\n    return z;\n}\n\n\n\n\n//iteratively reflect until you end up in the domain\n//report the parity of the number of flips:\nvec2 moveInto(vec2 z, Pentagon P, out float parity){\n\n    parity=1.;\n\n    for(int i=0;i<50;i++){\n        z=reflectIn(z,P,parity);\n        if(inside(z,P)){\n            break;\n        }\n    }\n\n    return z;\n\n}\n\n\n\nfloat dist( vec2 z, Pentagon P){\n    float d;\n    d = dist(z, P.a.bdy);\n    d = min(d, dist(z, P.b.bdy));\n    d = min(d, dist(z, P.c.bdy));\n    d = min(d, dist(z, P.d.bdy));\n    d = min(d, dist(z, P.e.bdy));\n    return d;\n}\n\n\n\nPentagon createPentagon(float A, float B){\n\n    //to the right of the vertical line\n    HalfSpace a = HalfSpace(Geodesic(0.,infty),1.);\n\n    //above the unit circle\n    HalfSpace b = HalfSpace(Geodesic(-1.,1.),1.);\n\n    //above the circle which is translate of vertical line along unit circle by dist B\n    HalfSpace c = HalfSpace(Geodesic(tanh(B/2.),1./tanh(B/2.)),1.);\n\n\n    //below the circle at height A above unit circle\n    HalfSpace e = HalfSpace(Geodesic(exp(A),-exp(A)),-1.);\n\n\n\n    //this final circle is the translate of the vertical geodesic along unit circle by E, then dilation z->exp(A)z\n    //the computaiton is annoying because we need tanh(E/2) and coth(E/2) for the endpoints; but need them in terms of A and B\n\n    float cA = cosh(A);\n    float sA = sinh(A);\n    float cB = cosh(B);\n    float sB = sinh(B);\n\n    float cD = sA*sB;\n    float sD = sqrt(cD*cD-1.);\n\n    //coshE and sinhE:\n    float cE = sB*cA/sD;\n    float sE = cB/sD;\n\n    //tanh(E/2):\n    float tanhE2 = sE/(1.+cE);\n    float eA = exp(A);\n\n    float end1 = eA*tanhE2;\n    float end2 = eA/tanhE2;\n\n    //above this circle\n    HalfSpace d = HalfSpace(Geodesic(end1,end2),1.);\n\n    Pentagon P = Pentagon(a,b,c,d,e);\n    return P;\n}\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//PRODUCING THE IMAGE\n//------------------------------------------\n//----------------------------------------------\n\n\n\n//set representation to any vector (A,B) of two positive real numbers satisfying the inequality\n//sinh(A)sinh(B)>1.\n//the example here has the side lengths oscilating periodically about 1.3\nvec2 chooseRepresentation(){\n    float A = 1.3+0.2*sin(iTime);\n    float B = 1.3+0.3*sin(iTime/2.);\n    return vec2(A,B);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //the vector that will store our final color:\n    vec3 color=vec3(0);\n    //an overall scaling factor to lighten/darken the image\n    float adjustment = 1.;\n\n    // Normalized pixel coordinates\n    vec2 z = normalizeCoords( fragCoord );\n    vec2 mouse = normalizeCoords(iMouse.xy);\n    \n    //band model\n    //z=ctanh(z);\n    \n    \n    if(halfPlane){\n         //this is actually easier to compute: we just begin automatially with the half plane\n        //need to shift downwards\n        z=z+vec2(0,1.);\n        mouse=mouse+vec2(0,1.);\n    \n        //turn down the exposure if in lower half plane\n        if(z.y<0.){\n            adjustment=0.2;\n        }\n        \n        //move the origin of PD to mouse location\n       z = pToOrigin(mouse,z);\n    }\n    \n    //the default view: start from the poincare disk\n    else{\n         //rotate slowly around the center of the poincare disk for fun\n        float c=cos(iTime/50.);\n        float s=sin(iTime/50.);\n        mat2 rot = mat2(c,s,-s,c);\n        z=rot*z;\n\n        //check if insidePD\n        //if not, turn down the exposure\n        if(!insidePD(z)){\n            adjustment =0.2;\n        }\n\n       //move to upper half plane for computations\n       z = toHP(z);\n       vec2 mouseHP = toHP(mouse);\n        \n       //move the origin of PD to mouse location\n       z = pToOrigin(mouse,z);\n       \n       \n        //transform things so that the pentagon's \"center\" is in the middle\n        vec2 cent = vec2(1.,1.5)+0.25*vec2(sin(iTime/3.),sin(iTime/2.));\n        z=pToOrigin(cent, z);\n    }\n    \n    \n    //create a geometric representataion of the right angled pentagon\n    vec2 rep = chooseRepresentation();\n    Pentagon P = createPentagon(rep.x,rep.y);\n\n    \n    //set background color of the disk\n    color =1.3*usfGreen;\n\n    \n    //color the fundamental domain\n    if(inside(z,P)){\n        color=usfYellow;\n    }\n\n    \n    //reflect all other points into the fundamental domain:\n    //color orientation preserving and revesing pentagons depending on parity\n    float parity=1.;\n    vec2 w = moveInto(z,P,parity);\n    if(parity==-1.){\n        color=1.5*usfGreen+vec3(0.1);\n    }\n    \n    \n    //color the edges of the pentagonal tiling\n    float d = dist(w, P);\n    if(d<0.015){color=white;}\n\n\n\n    //take the computed color and apply the adjustment\n    color = adjustment*color;\n    //output to the computer screen\n    fragColor=vec4(color,1);\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}