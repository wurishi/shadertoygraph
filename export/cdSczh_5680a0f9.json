{"ver":"0.1","info":{"id":"cdSczh","date":"1687384513","viewed":33,"name":"Merging Bubbles","username":"BrandonS","description":"Ooooh","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"dsscRM","parentname":"Intro to art coding"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nprecision highp float;\n\nfloat remap(float x, float min1,float min2, float max1, float max2){\n    float remapped = min2 + (x - min1) * (max2 - min2) / (max1 - min1);\n    return remapped;\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3[4] colors )\n{\n\n    return colors[0] + colors[1]*cos( 6.28318*(colors[2]*(t/2.5)+colors[3]) );\n}\nfloat N21(vec2 p){\n    p = p*451.243;\n    p += dot(p, p+67.1);\n    return fract(p.x*p.y);\n}\n\nvec3[] pinkBlueGreen = vec3[] (\n    vec3(0.660, 0.560, 0.680), \n    vec3(-3.142, 0.438, 0.720), \n    vec3(1.858, 1.978, 0.520), \n    vec3(-0.430, -0.397, -0.083)\n);\n\nvec3[] blueWhiteRed = vec3[](\n        vec3(0.660, 0.560, 0.680),\n        vec3(0.718, 0.438, 0.720),\n        vec3(0.520, 0.800, 0.520),\n        vec3(-0.430, -0.397, -0.083)\n        ); // Initial intensities of colors\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = ((fragCoord*2.0 - iResolution.xy)/iResolution.y);\n    //uv.x *= iResolution.x/iResolution.y;\n    uv *= uv *2.0;\n    \n    uv = fract(uv);\n    uv -=0.5;\n    \n    float d = length(uv);\n    float circleRadius = 0.2;\n    float numOfCircles = 9.;\n    \n    float circle = 0.;\n    \n    circle = sin(d*numOfCircles +iTime) / numOfCircles; // Use sin to get variance from -1 to 1\n    circle = abs(circle); // Hollow Out the center of the circles\n    \n    circle = smoothstep(0.0,circleRadius,circle); // Refine the border of the circles\n    \n    circle = 0.02/circle; // High saturation close to the border with steep drop off. WIthout this it gets fat and even distributed.\n    vec3 color = palette(iTime,pinkBlueGreen);\n    color *= circle; // Multiply by our calculated distance from center to produce more vibrant colors at the edges.\n    \n    fragColor =  vec4(color, 1.0);\n    //fragColor = vec4(uv, 0.0,1.0);\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* Old Main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = ((fragCoord*2.0 - iResolution.xy)/iResolution.y);\n    //uv.x *= iResolution.x/iResolution.y;\n    uv *= uv *2.0;\n    \n    uv = fract(uv);\n    uv -=0.5;\n    \n    float d = length(uv);\n    float circleRadius = 0.2;\n    float numOfCircles = 9.;\n    \n    float circle = 0.;\n    \n    circle = sin(d*numOfCircles +iTime) / numOfCircles; // Use sin to get variance from -1 to 1\n    circle = abs(circle); // Hollow Out the center of the circles\n    \n    circle = smoothstep(0.0,circleRadius,circle); // Refine the border of the circles\n    \n    circle = 0.02/circle; // High saturation close to the border with steep drop off. WIthout this it gets fat and even distributed.\n    vec3 color = palette(iTime,pinkBlueGreen);\n    color *= circle; // Multiply by our calculated distance from center to produce more vibrant colors at the edges.\n    \n    fragColor =  vec4(color, 1.0);\n    //fragColor = vec4(uv, 0.0,1.0);\n\n}\n*/","name":"Image","description":"","type":"image"}]}