{"ver":"0.1","info":{"id":"4sscDn","date":"1487703010","viewed":1893,"name":"Z-curve / Morton code","username":"FabriceNeyret2","description":"Among others, Z-curves are use in texture encoding, so that near (x,y) pixels are mapped in close memory location (as progressively drawn on top right).","likes":16,"published":3,"flags":0,"usePreview":0,"tags":["zcurve","mortoncode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Z-curve / Morton code\n// refs : https://en.wikipedia.org/wiki/Z-order_curve\n//        https://fgiesen.wordpress.com/2009/12/13/decoding-morton-codes/\n\nint MASKS[] = int[] (0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF, 0x0000FFFF);\n\nint xy2z(vec2 U) {       // --- grid location to curve index\n    ivec2 I = ivec2(U);\n    int n=8;\n    for (int i=3; i>=0; i--)\n        I =  (I | (I << n)) & MASKS[i],\n        n /= 2;\n    return I.x | (I.y << 1);\n}\n\nivec2 z2xy(int z) {      // --- curve index to grid location \n    int n=1;\n    ivec2 I = ivec2(z,z>>1) & MASKS[0];\n    for (int i=1; i<=4; i++)\n        I = (I | (I >>  n)) & MASKS[i],\n        n *= 2;\n    return I;\n}\n\n\n    \nvoid mainImage( out vec4 O,  vec2 U )\n{\n    U /= 2.;\n    float R = exp2(floor(log2(iResolution.y/2.)));\n    O = max(U.x,U.y) < R ? vec4(U/R, .5,0) : vec4(0);\n    \n    int Z = xy2z(U);\n    \n // O = vec4( Z ) / R/R;               // display Z-index\n // O = vec4( z2xy(Z),0,0)/ R;         // pos from Z\n // O = vec4(ivec2(U)== z2xy(iFrame)); // browse index on Z-curve.\n    \n    if (Z < iFrame) O = vec4(Z)/float(iFrame); // * vec4(U,0,0)/R;\n    \n    if (fract(U.y)==.75) return;\n    U = iResolution.xy/2.-ceil(U);\n    if ( U.x < R) {\n        Z = int(U.x+R*U.y);\n        if (Z < iFrame ) O = fract(vec4(z2xy(Z),R/2.,0)/R);\n    }\n}\n","name":"Image","description":"","type":"image"}]}