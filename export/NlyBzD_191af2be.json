{"ver":"0.1","info":{"id":"NlyBzD","date":"1664149267","viewed":64,"name":"Homework 2 - Textured Beer Mug","username":"KULICH","description":"Homework 2 - Textured Beer Mug","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DISTANCE 100.0\n#define SURFACE_DISTANCE 0.001\n\nmat3 rotateX(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat2 rotatePlane(float angle) \n{\n    float s=sin(angle), c=cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nvec3 Transform(vec3 p) \n{\n\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z-.5);\n    mat3 m     = rotateX(6.0*mouse.y) * rotateY(-6.0*mouse.x);\n    //p.zy *= rotatePlane(5.0 * mouse.y);\n    //p.zx *= rotatePlane(5.0 * mouse.x);    \n    p*=m;\n    return p;\n}\n\nfloat length8 ( in vec2 p )\n{\n    return pow(pow(abs(p.x), 8.0) + pow(abs(p.y), 8.0), 1.0 / 8.0);\n}\n\nfloat sdTorus(vec3 p, vec2 radius)\n{\n    float x = length(p.xz) - radius.x;\n    return length(vec2(x, p.y)) - radius.y;\n}\nfloat sdTorus8(vec3 p, vec2 radius)\n{\n    float x = length8(p.xz) - radius.x;\n    return length(vec2(x, p.y)) - radius.y;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\nfloat smoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n\n#define GLASS_WIDTH 0.3\n#define GLASS_HEIGHT 0.5\nfloat GetMugDist(vec3 point)\n{\n    float roundBoxDist = sdRoundBox(point, vec3(GLASS_WIDTH, GLASS_HEIGHT, GLASS_WIDTH), 0.1);\n    float roundBoxDist2 = sdRoundBox(point - vec3(0, 0.2, 0), vec3(GLASS_WIDTH - 0.1, GLASS_HEIGHT - 0.1, GLASS_WIDTH - 0.1), 0.1);\n    float linkDist = sdLink(point + vec3(0.55, 0,0), 0.2, 0.2, 0.07);\n\n    float dist = smoothSubtraction(roundBoxDist2, roundBoxDist, 0.1);\n    dist = smoothUnion(dist, linkDist, 0.1);\n    for (int i = 0; i < 12; i++)\n    {\n        dist = smoothUnion(dist, sdTorus8(point + vec3(0., -0.55 + 0.1 * float(i), 0.), vec2(0.38, 0.0025)), 0.07);\n    }\n    return dist;\n}\n\nfloat GetPlaneDist(vec3 point, float height)\n{\n    return point.y + height;\n}\n\nfloat GetDist(vec3 point)\n{\n    vec3 q = Transform(point);\n    \n    float planeDist = GetPlaneDist(point, 1.4);\n    float mugDist = GetMugDist(q);\n\n    float dist = unionSDF(mugDist, planeDist);\n\n    return dist;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, out bool hit)\n{\n    float distanceFromOrigin = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 point = ro + rd * distanceFromOrigin;\n        float distanceToSurface = GetDist(point);\n        if (distanceToSurface < SURFACE_DISTANCE)\n        {\n            hit = true;\n            break;\n        }\n        distanceFromOrigin += distanceToSurface;\n        if (distanceFromOrigin > MAX_DISTANCE)\n        {\n            break;\n        }\n    }\n    return distanceFromOrigin;\n}\n\nvec3 GetNormal(vec3 p) \n{\n    float d = GetDist(p);\n    vec2 e = vec2(0.001, 0.);\n    vec3 normal = d - vec3(\n        GetDist(p - e.xyy), \n        GetDist(p - e.yxy), \n        GetDist(p - e.yyx)\n      );\n    return normalize(normal); \n\n}\n\nfloat GetLight(vec3 pointToShade, vec3 camera, out float sp)\n{\n    vec3 lightPos = vec3(-1, 4, -8);\n    vec3 light = normalize(lightPos - pointToShade);\n    vec3 normal = GetNormal(pointToShade);\n    \n    float diffuse = clamp(dot(normal, light), 0.0, 1.0);\n    \n    bool hit;\n    float pointLightDist = RayMarch(pointToShade + normal * SURFACE_DISTANCE * 1., light, hit);\n    if (pointLightDist < length(lightPos - pointToShade))\n    {\n        diffuse *= 0.25;\n    }\n    \n    vec3  v  = normalize(camera - pointToShade);\n    float nl = max(0.0, dot(normal, light));\n    vec3  h  = normalize(light + v);\n    float hn = max (0.0, dot(h, normal));\n    sp = pow (hn, 110.0);\n    \n    return diffuse;\n}\n\nint GetTexture(vec3 p)\n{\n    vec3 q = Transform(p);\n    float plane = GetPlaneDist(p, 1.4);\n    float mug = GetMugDist(q);\n    float closest = min(plane, mug);\n    if (plane == closest)\n    {\n        return 1;\n    }\n    else if (mug == closest)\n    {\n        return 2;\n    }\n    return 0;\n}\n\nvec2 MovingTiles(in vec2 uv, in vec2 div)\n{\n    vec2 orinal_uv = uv;\n    uv = mod(uv * div, vec2(1.0));\n    float shift = mod(floor(orinal_uv.y * div.y), 2.0) - 0.5;\n    uv = mod(uv + vec2(sin(iTime) * 0.5 * shift, 0.0), vec2(1.0)) + vec2(0.5);\n    return uv;\n}\n\nvec3 GetColor(vec3 p, vec2 uv)\n{\n    vec3 col;\n    vec3 normal = GetNormal(p);\n    \n    int tex = GetTexture(p);\n    if (tex == 2)\n    {\n        p = Transform(p);\n        normal = Transform(normal);\n        \n        vec3 colXZ = texture(iChannel0, p.xz * .5 + .5).rgb;\n        vec3 colYZ = texture(iChannel0, p.yz * .5 + .5).rgb;\n        vec3 colXY = texture(iChannel0, p.xy * .5 + .5).rgb;\n        \n        normal = abs(normal);\n        normal *= pow(normal, vec3(2.));\n        normal /= normal.x + normal.y + normal.z;\n        \n        col = colYZ * normal.x + colXZ * normal.y + colXY * normal.z;\n    }\n    else if (tex == 1)\n    {        \n        vec3 colXZ = texture(iChannel1, p.xz * 0.1 + MovingTiles(p.xz, vec2(0.2, 0.3))).rgb;\n        col = colXZ * normal.y;\n    }\n    else \n    {\n        col = vec3(1, 1., 1.);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.18, 0.18, 0.13);\n\t\n    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z-.5);\n    mat3 m     = rotateX(6.0*mouse.y) * rotateY(-6.0*mouse.x);\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    bool hit;\n    float dist = RayMarch(ro, rd, hit);\n    vec3 p = ro + rd * dist;\n    \n    float sp = 0.;\n    float diffuseLighting = GetLight(p, ro, sp);\n    if (hit)\n    {\n        col = vec3(diffuseLighting) * 0.5 * vec3(1, 1, 1) + 0.5 * sp * vec3(1, 1, 1);\n        col *= GetColor(p, uv);\n    }\n    \n    col = pow(col, vec3(.5));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}