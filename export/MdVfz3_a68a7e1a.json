{"ver":"0.1","info":{"id":"MdVfz3","date":"1529872011","viewed":401,"name":"Banding reduction HDR dithering","username":"nomadiclizard","description":"Eliminates the banding caused by default quantisation on an 8 bit panel by adding random noise.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThe thought struck that HDR could be simulated on an 8 bit panel by dithering\nat a higher resolution than the source. Sadly it's not an original thought :(\n\ne.g. http://sandervanrossen.blogspot.com/2012/02/hdr-dithering.html\n\nThe lower half of the screen is using default quantisation, the upper half\nhas [0:1/256] noise added to it to eliminate the banding.\n\nNoise function from:\n\nhttps://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n\nchanged slightly to do a divide by 256 in the bitmask\n\n*/\n\n/*\n    static.frag\n    by Spatial\n    05 July 2013\n*/\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n// Compound versions of the hashing algorithm I whipped together.\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    // const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeMantissa = 0x00007FFFu;\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\n// Pseudo-random value in half-open range [0:1].\n// NL because of >>8 mantissa returns in range [0:1/256] which is perfect for quantising\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\n/* stuff by nomadic lizard */\n\nvec3 quantise(in vec3 fragColor, in vec2 fragCoord)\n{\n    return fragColor + random(vec3(fragCoord, iTime));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 posn = fragCoord/iResolution.xy;\n    vec2 uv = posn / 5.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xxx);\n\n    // Quantise with random when in top half of screen\n    if(posn.y > 0.5) {\n    \tcol = quantise(col, fragCoord);\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}