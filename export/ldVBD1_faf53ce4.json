{"ver":"0.1","info":{"id":"ldVBD1","date":"1528751207","viewed":124,"name":"Blue Depths","username":"AustinSpafford","description":"Early water shader ported over from BookOfShaders (due to chrome apparently breaking that site).","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nconst float k_two_pi = 6.283185;\n\nconst float k_max_velocity = 0.1;\n\nfloat random(\n    vec2 st)\n{\n\treturn fract(\n\t\tsin(dot(st.xy, vec2(12.9898, 78.233))) * \n\t\t43758.5453123);\n}\n\nfloat roaming_ripple_strength(\n    vec2 st,\n\tvec2 velocity,\n\tfloat inner_radius,\n\tfloat outer_radius)\n{\n    vec2 center = (iTime * velocity);\n    \n    vec2 cell_origin = (center - 0.5);\n    \n    // Stagger the rows... poorly.\n    cell_origin.x += (floor(st.y - cell_origin.y) / 2.0);\n    \n    float dist = distance(mod((st - cell_origin), 1.0), vec2(0.5));\n    \n    float strength = (\n    \t((2.0 * smoothstep(0.0, inner_radius, dist)) - 1.0) -\n    \tsmoothstep(inner_radius, outer_radius, dist));\n    \n    // Mute the strength, specifically to make it so many layers have to stack before either extreme can be reached.\n    strength *= 0.25;\n    \n    return strength;\n}\n\nfloat apply_strength(\n\tfloat brightness,\n\tfloat strength)\n{\n    // return (brightness * (strength + 1.0));\n    \n    // return (brightness * ((strength + 1.0) / 2.0));\n    \n    return (1.0 - ((1.0 - brightness) * (1.0 - strength))); // smooth-addition (normally doesn't exceed 1.0)\n}\n\nvec2 rotate_vec2(\n\tvec2 point,\n\tfloat theta)\n{\n    float cos_theta = cos(theta);\n    float sin_theta = sin(theta);\n    \n    return vec2(\n        (point.x * cos_theta) + (point.y * sin_theta),\n    \t(point.x * (-1.0 * sin_theta)) + (point.y * cos_theta));\n}\n\nvoid mainImage(\n    out vec4 fragColor,\n    in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy);\n    \n    // Tiling-test.\n    uv *= 3.0;\n    \n    // Aspect-ratio correction.\n    uv.x *= (iResolution.x / iResolution.y);\n\n    float brightness = 0.5;\n    \n    for (int index = 0; index < 10; ++index)\n    {\n        float plane_theta = \n            (k_two_pi * random(vec2(float(index), 0.0)));\n        \n        vec2 velocity = vec2(\n            ((2.0 * random(vec2(float(index), 1.0))) - 1.0),\n            ((2.0 * random(vec2(1.0, float(index)))) - 1.0));\n        \n        vec2 position_offset = vec2(\n            ((2.0 * random(vec2(float(index), 2.0))) - 1.0),\n            ((2.0 * random(vec2(2.0, float(index)))) - 1.0));\n        \n        velocity *= k_max_velocity;\n        \n    \tfloat ripple_zoom_factor = (1.0 + (0.25 * float(index)));\n        \n        float strength = roaming_ripple_strength(\n            ((rotate_vec2(uv, plane_theta) + position_offset) * ripple_zoom_factor),\n            velocity,\n            0.25,\n            0.4);\n\n        brightness = apply_strength(brightness, strength);        \n    }\n    \n    // Place focus on the highlights.\n    brightness = pow(brightness, 5.0);\n    \n    // Add a bluish tint while keeping white highlights by filtering out some of the low-end on the red/green channels.\n    // Also add small hot-spot highlights, by slightly clamping at the ceiling.\n    float high_end_clamp = 0.9;\n    vec3 color = vec3(\n    \tsmoothstep(0.25, high_end_clamp, brightness),\n        smoothstep(0.1, high_end_clamp, brightness),\n        smoothstep(0.0, high_end_clamp, brightness));\n\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}