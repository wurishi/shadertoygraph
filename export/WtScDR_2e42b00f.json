{"ver":"0.1","info":{"id":"WtScDR","date":"1594142181","viewed":130,"name":"Vlams' Path tracer","username":"vlams1","description":"Path tracer built on a raymarcher.\nBasic material support, acceptable refraction and beautiful volumetrics.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarcher","pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define C(c) t=max(t,smoothstep(.5,.47,texture(iChannel3,clamp(P,0.,.0625)+vec2(c%16,15-c/16)/16.).w));P.x-=.03;\n#define N(a,b) f=float(a)*pow(.1,float(b)-1.);for (int i;i<int(b);i++) {C((int(mod(f,10.))+48));f*=10.;}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.x;\n    vec4 d = texelFetch(iChannel0,ivec2(0),0); //Data\n    vec3 c = texelFetch(iChannel0,ivec2(fragCoord),0).xyz/d.z; //Color\n    c /= 1. + c * .8; //Tonemapping\n    c = pow(c,vec3(.45)); //Gamma correction\n    \n    float t, f;vec2 P=uv;\n    N(d.z+1.,5);C(32);C(83);C(65);C(77);C(80);C(76);C(69);C(83);\n    P=uv-vec2(0,.04);\n    C(32);C(32);N(d.z/(iTime-d.w),3);C(32);C(70);C(80);C(83);\n    P=uv-vec2(0,.08);\n    \n    fragColor = vec4(mix(c,vec3(1),t),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float h21(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx)*345.2927);\n    p3 += dot(p3, p3.yzx + 64.37);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat h31(vec3 p) {\n    p += dot(p,abs(p)+3817.34);\n    p = fract(sin(p)*5823.35);\n    return fract(p.x*-p.y+p.y*-p.z+dot(p,p.yzx+336.33));\n}\n\nvec3 h43(vec4 p) {\n    return vec3(h21(p.xy),h21(p.yz),h21(p.zw));\n}\n\nfloat n31(vec3 p) {\n    vec3 m = sin(fract(p)*3.14159-1.57079)*.5+.5;\n    vec2 o = vec2(1,0);\n    p = floor(p);\n    float a = mix(h31(p),h31(p+o.yyx),m.z);\n    float b = mix(h31(p+o.xyy),h31(p+o.xyx),m.z);\n    float c = mix(h31(p+o.yxy),h31(p+o.yxx),m.z);\n    float d = mix(h31(p+o.xxy),h31(p+o.xxx),m.z);\n    return mix(mix(a,c,m.y),mix(b,d,m.y),m.x);\n}\n\nvec3 rpos(vec4 s) {\n    return normalize(sin(h43(s)*6.283185));\n}\n\nmat2 r(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nmat3 look(vec3 o, vec3 t) {\n    vec3 f = normalize(t-o);\n    vec3 r = normalize(cross(f,vec3(0,1,0)));\n    vec3 u = cross(r,f);\n    return mat3(r,u,f);\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 q = abs(p)-b;\n    return length(max(q,0.)) + min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat torus(vec3 p, float r) {\n    return length(vec2(length(p.xz)-r,p.y));\n}\n\n#define SD .002\n\n#define mmin(a,b) a.x < b.x ? a : b;\n#define mmax(a,b) a.x > b.x ? a : b;\n#define d(a) d = mmin(d,a);\n\nvec2 dist(vec3 p) {\n    vec2 d = vec2(100);\n    d(vec2(length(p-5.)-2.,1));\n    d(vec2(p.y+1.,2));\n    d(vec2(box(p+1.,vec3(1))-.2,3));\n    d(vec2(torus(p+vec3(0,1,0),1.)-.5,4));\n    d(vec2(length(p-1.)-1.,5));\n    return d;\n}\nvec3 P,D,N,C;\n\nfloat raymarch(vec3 p, vec3 r, float l, float md) {\n    for (int i; i < 512; i++) {\n        float d = dist(p+r*l).x;\n        l += d;\n        if (abs(d) < SD || l > md) break;\n    }\n    return min(l,md);\n}\n\nfloat refractmarch(vec3 p, vec3 r, float l, float md) {\n    for (int i; i < 128; i++) {\n        float d = dist(p+r*l).x;\n        l += abs(d);\n        if (abs(d) < SD || l > md) break;\n    }\n    return min(l,md);\n}\n\nvec3 normal(vec3 p) {\n    vec2 o = vec2(SD,0);\n    return normalize(vec3(dist(p+o.xyy).x,dist(p+o.yxy).x,dist(p+o.yyx).x)-dist(p).x);\n}\n\nfloat volumetrics(float l) {\n    //return l;\n    float r = h21(vec2(D.x,iFrame));\n    //return r > exp(-l*.05) ? l*r : l;\n    for (float o; o < l; o+=1.) {\n        vec3 p = P+D*o;\n        if (r < smoothstep(.3,.8,n31(p*.1))*.98) return o+r;\n    }\n    return l;\n}\n\nvec3 tex(sampler2D t, vec3 s, float b) {\n    vec3 x = texture(t,P.zy/s.zy).xyz;\n    vec3 y = texture(t,P.xz/s.xz).xyz;\n    vec3 z = texture(t,P.xy/s.xy).xyz;\n    vec3 m = normalize(pow(abs(N), vec3(b)));\n    return x*m.x+y*m.y+z*m.z;\n}\n\nstruct material {\n    vec3 a,e;\n    float s,t,r;\n};\n\nmaterial getmat(int m) {\n    switch(m) {\n        case 0:\n            return material(vec3(0),vec3(0),0.,0.,0.);\n        case 1:\n            return material(vec3(0),N*50.+50.,0.,0.,0.);\n        case 2:\n            return material(vec3(.2,.2,.6),vec3(0),1.,0.,0.);\n        case 3:\n            return material(vec3(1,.2,.2),vec3(0),1.,0.,0.);\n        case 4:\n            return material(vec3(.9),vec3(0),0.,0.,0.);\n        case 5:\n            return material(vec3(.4,.6,.8),vec3(0),0.,abs(dot(D,N)),2.);\n    }\n}\n\n#define steps 8\n#define dispersion .03\n\nvec3 sampleColor() {\n    float p = float((iFrame%steps))/float((steps+1));\n    return max(vec3(0),sin((vec3(0,.3333,.6666)+p+.5)*6.28318)) * 2.5;\n}\n\nfloat sampleDispersion() {\n    return (float(iFrame%steps)/float(steps)-.5)*dispersion+1.;\n}\n\nvec3 render(vec2 uv) {\n    uv += sin(vec2(152.,123.62)*iTime)/iResolution.xy*.5; //Jitter UVs\n    vec2 m = iMouse.xy / iResolution.xy;\n    P = vec3(0,0,-5); //Set ray origin\n    P.yz *= r(-m.y*2.+1.5); P.xz *= r(m.x*8.); //Rotate ray origin\n    uv *= sampleDispersion();\n    D = look(P,vec3(0)) * normalize(vec3(uv,1)); //Set ray direction\n    \n    vec3 r = vec3(1);\n    r *= sampleColor();\n    for (int i; i<5; i++) {\n    \tfloat l = raymarch(P,D,.1,20.*pow(1.,float(i))); //Raymarch\n        float v = volumetrics(l);\n        if (v<l) {\n            l = v;\n            P += D*l;\n            D = rpos(vec4(P,iFrame));\n            r *= .5;\n            continue;\n        }\n        P += D*l;\n        vec3 n = h43(vec4(P,iFrame));\n        N = normal(P); //Calculate normals\n        vec2 d = dist(P); //Sample distance field\n        if (abs(d.x)>SD) d.y = 0.; //Turn failed raymarches into sky material\n        material m = getmat(int(d.y)); //Get material properties\n        if (length(m.e)>SD) C += r*m.e; //Render emissive surface\n        if (n.x < m.t) {\n            m.r *= sampleDispersion();\n            P -= N * SD * 2.;\n            D = refract(D,N,1./m.r);\n            l = refractmarch(P,D,0.,5.);\n            P += D * l;\n            P -= N * SD * 2.;\n            D = refract(D,N,1./m.r);\n            r *= pow(m.a,vec3(l));\n            continue;\n        }\n        vec3 p = rpos(vec4(P,iFrame)); //Get random point in sphere\n        D = normalize(mix(reflect(D,N),dot(p,N) > 0. ? p : -p, m.s)); //Scatter ray\n        r *= m.a * max(dot(D,N),.4); //Calculate reflection color\n        if (length(r)<SD) break; //Return if surface isn't reflective\n    }\n    return C;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 d = texelFetch(iChannel0,ivec2(0),0);\n    bool a = length(d.xy-iMouse.xy) < 1.;\n    if (length(fragCoord)<1.) {\n        fragColor = a ? d + vec4(0,0,1,0) : vec4(iMouse.xy,1,iTime);\n    } else {\n        fragColor = vec4(render((fragCoord-.5*iResolution.xy)/iResolution.y),1.) +\n            (a ? texelFetch(iChannel0,ivec2(fragCoord),0) : vec4(0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}