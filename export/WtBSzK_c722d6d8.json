{"ver":"0.1","info":{"id":"WtBSzK","date":"1566371627","viewed":218,"name":"[phreax] xference","username":"phreax","description":"Experimenting with inference patterns and different distance functions","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","pattern","tiling","aztec"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n   phreax 2019\n*/\n\nvec3 col1 = vec3(0.05, 0.7, 0.6);\nvec3 col2 = vec3(0.8, 0.2, 0.05);\n\nfloat manhattanDist(vec2 a, vec2 b) {\n\treturn abs(a.x-b.x)+abs(a.y-b.y);\n\n}\n\nfloat manhattanDist2(vec2 a, vec2 b) {\n    return abs(a.x-b.x)-abs(a.y-b.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy,\n         uv = (fragCoord-.5*R.xy)/R.y,\n         c = vec2(0.5);    // center\n\n    uv = fract(uv*vec2(4., 3.));        // partition space in 4x3\n\n    float md = manhattanDist2(uv, c);\n    float d = manhattanDist(uv, c);\n    //    d = distance(uv, c);\n    \n    float mp = sin(2.*iTime+abs(sin(0.2*iTime+5.*md*md)*md)*20.);  // manhattan pattern\n    float mp2 = sin(2.*iTime+abs(sin(0.2*iTime+5.*md*md)*md)*40.); // another manhattan pattern\n    float ep = sin(10.*iTime-d*70.);                               // circular (euclidian) pattern\n    mp = smoothstep(-0.1, 0.1, mp);\n    mp2 = 1.-smoothstep(-0.1, 0.1, mp2);\n    ep = smoothstep(-0.1, 0.1, ep);\n\n    vec3 col = mix(mp*col1, mp2*col2, ep);\n    // vec3 col = mix(mp*vec3(0.02, 0.42, 0.4), mp2*vec3(0.8, 0.1, 0.15), ep);\n    \n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}