{"ver":"0.1","info":{"id":"XXXczH","date":"1725807427","viewed":26,"name":"Void_GLSL_var2","username":"TRASHTRASH","description":"simple but classic iteration","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rave","visuals","void"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//by Joshua deLorimier\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize coordinates (fragCoord is pixel position)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Centered coordinates in range [-1.0, 1.0]\n    vec2 p = (uv - 0.5) * 2.0;\n\n    // Hexagon parameters\n    float baseSize = 0.0001; // Base size for the smallest hexagon\n    float sizeIncrement = 0.03; // Amount by which each hexagon size increases\n    float outlineWidth = 0.04; // Approximate 2 pixels in normalized coordinates\n    float numHexagons = 50.0; // Number of hexagons\n    float glowIntensity = 0.04; // Stronger intensity of the glow\n    float glowRadius = 0.06; // Smaller radius for more concentrated glow\n\n    // Initialize the background color\n    vec3 bgColor = vec3(0.0); // Black background\n\n    // Distance from the center (used for brightness)\n    float centerDist = length(p);\n\n    // Optical flow distortion effect\n    float timeFlow = iTime * 0.5;\n\n    // Optical flow field for distortion (flowing sine wave pattern)\n    vec2 flowField = vec2(\n        sin(uv.y * 10.0 + timeFlow) * 0.02, // Horizontal distortion\n        cos(uv.x * 10.0 + timeFlow) * 0.02  // Vertical distortion\n    );\n\n    // Apply flowField to UV coordinates to distort the scene\n    vec2 distortedUV = uv + flowField;\n\n    // Recalculate centered coordinates after distortion\n    vec2 p_distorted = (distortedUV - 0.5) * 2.0;\n\n    // Loop over each hexagon\n    vec3 color = bgColor; // Default to background color\n    for (float i = 0.0; i < numHexagons; i++)\n    {\n        // Offset each hexagon's time by `i` for animation effect\n        float timeOffset = i * 0.15; // Adjust the offset as needed\n        float angle = iTime + timeOffset; // Rotation angle based on time and offset\n\n        // Increment size for each hexagon\n        float size = baseSize + i * sizeIncrement;\n\n        // Rotation matrix for hexagon\n        float cosA = cos(angle);\n        float sinA = sin(angle);\n        vec2 p_rot = vec2(\n            cosA * p_distorted.x - sinA * p_distorted.y,\n            sinA * p_distorted.x + cosA * p_distorted.y\n        );\n\n        // Calculate hexagon distance from the center\n        float length = abs(p_rot.x) + abs(p_rot.y / 1.732);\n        float hexDist = max(length - size, 0.0);\n\n        // Calculate smooth outline\n        float outline = smoothstep(outlineWidth - 0.005, outlineWidth + 0.005, hexDist);\n\n        // Brightness increases as distance from the center increases\n        float brightness = smoothstep(0.0, 1.0, centerDist);\n\n        // Determine fill and outline colors\n        vec3 fillColor = vec3(1.0) * brightness; // Brighter on the edges\n        vec3 outlineColor = vec3(0.0); // Black outline\n\n        // Mix fill and outline colors\n        vec3 hexColor = mix(fillColor, outlineColor, outline);\n\n        // Stronger Glow Effect\n        float glow1 = smoothstep(glowRadius, glowRadius + 0.05, hexDist) * glowIntensity;\n        float glow2 = smoothstep(glowRadius + 0.05, glowRadius + 0.15, hexDist) * (glowIntensity * 0.5); // Second layer of glow for strength\n        vec3 glowColor = vec3(1.0, 0.9, 0.6) * (glow1 + glow2); // Brighter and warmer glow\n\n        // Combine hexagon color with glow\n        hexColor += glowColor;\n\n        // Combine hexagon color with background\n        color = mix(color, hexColor, outline);\n    }\n\n    // Final color output\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}