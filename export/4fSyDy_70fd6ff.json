{"ver":"0.1","info":{"id":"4fSyDy","date":"1722887983","viewed":24,"name":"Monte carlo sampling glitch","username":"Yeeun","description":"Added random glitch using monte carlo sampling","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["curve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SAMPLES 100\n#define MONTE_CARLO_SAMPLES 10\n#define GLITCH_FREQUENCY 0.1\n#define GLITCH_AMPLITUDE 0.2\n#define ANIMATION_SPEED 1.0\n#define WAVE_AMPLITUDE 0.3\n\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvec2 glitch(vec2 p, float time) {\n    float noise = random(p + time);\n    if (noise < GLITCH_FREQUENCY) {\n        float glitchAmount = (noise / GLITCH_FREQUENCY) * GLITCH_AMPLITUDE;\n        p.x += sin(time * 50.0 + p.y * 10.0) * glitchAmount;\n        p.y += cos(time * 60.0 + p.x * 12.0) * glitchAmount;\n    }\n    return p;\n}\n\nvec2 cubicBezier(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float mt = 1.0 - t;\n    float mt2 = mt * mt;\n    float mt3 = mt2 * mt;\n    return p0 * mt3 + p1 * 3.0 * mt2 * t + p2 * 3.0 * mt * t2 + p3 * t3;\n}\n\nfloat distToLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    \n    vec2 p0 = vec2(-0.8, 0.0);\n    vec2 p3 = vec2(0.8, 0.0);\n    \n    float time = iTime * ANIMATION_SPEED;\n    \n    float lineThickness = 0.004;\n    float smoothing = 0.001;\n    \n    vec3 glitchedColor = vec3(0.0);\n    vec3 smoothedColor = vec3(0.0);\n    vec3 stabilizedColor = vec3(0.0);\n    \n    vec2 prevStabilizedPoint = p0;\n    vec2[NUM_SAMPLES + 1] stabilizedPoints;\n    \n    for (int j = 0; j < MONTE_CARLO_SAMPLES; j++)\n    {\n        float timeOffset = random(vec2(float(j), iTime)) * 0.1 - 0.05;\n        vec2 p1 = vec2(-0.4, sin(time + timeOffset) * WAVE_AMPLITUDE);\n        vec2 p2 = vec2(0.4, sin(time + timeOffset + 3.14159) * WAVE_AMPLITUDE);\n        \n        vec2 prevGlitchedPoint = glitch(p0, iTime + timeOffset);\n        vec2 prevSmoothedPoint = p0;\n        \n        for (int i = 0; i <= NUM_SAMPLES; i++)\n        {\n            float t = float(i) / float(NUM_SAMPLES);\n            \n            vec2 glitchedCurvePoint = cubicBezier(\n                glitch(p0, iTime + timeOffset),\n                glitch(p1, iTime + timeOffset),\n                glitch(p2, iTime + timeOffset),\n                glitch(p3, iTime + timeOffset),\n                t\n            );\n            \n            vec2 smoothedCurvePoint = cubicBezier(p0, p1, p2, p3, t);\n            \n            if (j == 0) {\n                stabilizedPoints[i] = smoothedCurvePoint;\n            } else {\n                stabilizedPoints[i] += smoothedCurvePoint;\n            }\n            \n            if (i > 0) {\n                float distToGlitched = distToLine(uv, prevGlitchedPoint, glitchedCurvePoint);\n                float distToSmoothed = distToLine(uv, prevSmoothedPoint, smoothedCurvePoint);\n                \n                glitchedColor += vec3(1.0, 0.0, 0.0) * smoothstep(lineThickness + smoothing, lineThickness - smoothing, distToGlitched);\n                smoothedColor += vec3(0.0, 1.0, 0.0) * smoothstep(lineThickness + smoothing, lineThickness - smoothing, distToSmoothed);\n            }\n            \n            prevGlitchedPoint = glitchedCurvePoint;\n            prevSmoothedPoint = smoothedCurvePoint;\n        }\n    }\n    \n    // Calculate stabilized curve\n    for (int i = 1; i <= NUM_SAMPLES; i++) {\n        stabilizedPoints[i] /= float(MONTE_CARLO_SAMPLES);\n        float distToStabilized = distToLine(uv, prevStabilizedPoint, stabilizedPoints[i]);\n        stabilizedColor += vec3(0.0, 0.5, 1.0) * smoothstep(lineThickness + smoothing, lineThickness - smoothing, distToStabilized);\n        prevStabilizedPoint = stabilizedPoints[i];\n    }\n    \n    glitchedColor /= float(MONTE_CARLO_SAMPLES);\n    smoothedColor /= float(MONTE_CARLO_SAMPLES);\n    stabilizedColor /= float(NUM_SAMPLES);\n    \n    glitchedColor = pow(glitchedColor, vec3(0.4545));\n    smoothedColor = pow(smoothedColor, vec3(0.4545));\n    stabilizedColor = pow(stabilizedColor, vec3(0.4545));\n    \n    vec3 finalColor = glitchedColor + stabilizedColor;\n\n    float glow = max(max(glitchedColor.r, smoothedColor.g), stabilizedColor.b);\n    finalColor += glow * vec3(0.5, 0.5, 0.5) * 0.5;\n    \n    finalColor = mix(vec3(0.0), finalColor, smoothstep(0.0, 0.05, max(max(finalColor.r, finalColor.g), finalColor.b)));\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}