{"ver":"0.1","info":{"id":"NdXGWH","date":"1636836695","viewed":64,"name":"Noobtracer v3.14","username":"Chosen","description":"Blinn-phong raytraced spheres, cubes and tetrahedrons.","likes":0,"published":1,"flags":64,"usePreview":0,"tags":["raytracing","simple","tetrahedron","blinnphong"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"ltSXDz","filepath":"https://soundcloud.com/arcade-music-tribute/afterburner2","previewfilepath":"https://soundcloud.com/arcade-music-tribute/afterburner2","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    The Art of Code - ShaderToy Tutorial - The simplest 3D\n    https://www.youtube.com/watch?v=dKA5ZVALOhs\n\n    The Art of Code - How to create a camera in ShaderToy\n    https://www.youtube.com/watch?v=PBxuVlp7nuM\n    \n    Inigo Quilez articles - Intersectors\n    https://iquilezles.org/articles/intersectors\n*/\n\n#define ROT_SPD .5\n#define DIST 13.\n#define GRIDX 12.\n#define GRIDY 11.\n// lighting\n#define AMB .1\n#define SHINY 40.\n#define SUN vec3(.5)\n\n#define R iResolution\n#define T iTime\n#define TAU 6.283185\n#define SQ(X) ((X) * (X))\n\nconst vec3 C = vec3(0, 1., -1.);\n\nmat4 translate(vec3 loc)\n{ \n    return mat4(C.yxxx, C.xyxx, C.xxyx, vec4(loc, 1));\n}\n\nmat3 rotate(vec3 axis, float angle)\n{\n    // https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n//    axis = normalize(axis);\n    float s = -sin(angle);\n    float c = cos(angle);\n    float oc = 1. - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,   oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,            oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,   oc * axis.z * axis.z + c);\n}\n\n// https://www.shadertoy.com/view/MdB3Dw\nfloat hitSphere(vec3 ro, vec3 rd, vec4 sp, out vec3 norm)\n{\n    float t = -1.;\n\tnorm = vec3(0.);\n\t\n\tvec3 rc = ro - sp.xyz;\n\tfloat b = dot(rc, rd);\n\tfloat c = dot(rc, rc) - sp.w * sp.w;\n\tfloat k = b * b - c;\n\tif (k > 0.) {\n\t\tt = -b - sqrt(k);\n\t\tnorm = normalize(ro + rd * t - sp.xyz);\n\t}\n\treturn t;\n}\n\n// https://www.shadertoy.com/view/ld23DV\nfloat hitBox(vec3 ro, vec3 rd, vec3 size, out vec3 norm) \n{\n    vec3 m = 1. / rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m * ro;\n    vec3 k = abs(m) * size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if( tN > tF || tF < 0.)\n        return -1.; // no intersection\n    norm = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    return tN;\n}\n\nfloat hitPlane(vec3 ro, vec3 rd, vec4 p)\n{\n    // http://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\n    return (p.w - dot(ro, p.xyz)) / dot(rd, p.xyz);\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 uv = (U - .5 * R.xy) / min(R.x, R.y);\n    /*  ro : Ray origin\n        rd : Ray direction\n        lp : Look at point */\n    vec3 ro = vec3(0, 3. * cos(T), -DIST);\n    vec3 lp = vec3(0);\n    vec3 forward = normalize(lp - ro);\n    vec3 right = cross(C.xyx, forward);\n    vec3 up = cross(forward, right);\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n    \n    vec3 frag = texture(iChannel0, vec3(-rd.z, rd.y, rd.x)).xyz;\n\n    \n    // light direction (towards the light)\n    vec3 ld = //-rd;\n        normalize(C.zyz);\n    vec3 hv = normalize(ld - rd); // halfway vector\n    mat3 rot = rotate(C.xyx, ROT_SPD * T * TAU);\n    vec3 rdLocal = rot * rd;\n    int symbol[11] = int[] (0, 0, 1020, 144, 144, 144, 144, 144, 1020, 0, 0);\n    float depth = 1000.;\n    float hit;\n    vec3 n;\n    \n    // face distance, size, normal and rotation for tetrahedron\n#define FD 1. / sqrt(3.)\n#define TET FD / 3.\n#define FN normalize(vec3(0, FD, -sqrt(2. * FD + 1.)))\n#define RF rotate(C.xyx, TAU / 3.)\n\n    vec4 face[4] = vec4[] (vec4(0, -1, 0, TET), vec4(FN, TET), vec4(FN * RF, TET), vec4(RF * FN, TET));\n    int shape = int(mod(ROT_SPD * T * .5, 3.));\n    \n    for (float loopY = 0.; loopY < GRIDY; ++loopY) {\n        for (float loopX = 0.; loopX < GRIDX; ++loopX) {\n            vec3 item = vec3(loopX - GRIDX / 2. + .5, loopY - GRIDY / 2. + .5,\n                0.);\n                //.25 * sin(20. * T + loopY));\n            vec3 roLocal = (translate(-item) * mat4(rot) * vec4(ro, 1)).xyz;\n\n            switch (shape) {\n                case 0:\n                    // sphere\n//                    hit = hitSphere(ro, rd, vec4(item * rot, .5), n);\n                    hit = hitSphere(roLocal, rdLocal, vec4(vec3(0), .5), n);\n                    n *= rot;\n                    break;\n                case 1:\n                    // box\n                    hit = hitBox(roLocal, rdLocal, vec3(.5), n);\n                    n *= rot;\n                    break;\n                case 2:\n                    // tetrahedron\n                    float faceDepth = 0., backDepth = 1000., faceHit;\n                    vec3 bestNorm = vec3(0);\n                    hit = -1.;\n                    mat3 spin = rotate(normalize(C.yyy), .5 * T * TAU);\n                    for (int loopF = 0; loopF != 4; ++loopF) {\n                        vec4 plane = face[loopF];\n                        plane.xyz *= spin;\n                        faceHit = hitPlane(roLocal, rdLocal, plane);\n                        n = plane.xyz * rot;\n                        // Want the furthest plane towards us\n                        if (dot(n, rd) < 0.) {\n                            if (faceHit > faceDepth) {\n                                faceDepth = faceHit; // furthest so far\n                                bestNorm = n;\n                            }\n                        } else\n                            // If there is a back of a plane nearer, we're outside\n                            if (faceHit < backDepth)\n                                backDepth = faceHit;\n                    }\n                    if (faceDepth < backDepth) {\n                        hit = faceDepth;\n                        n = bestNorm;\n                    }\n                    break;\n            }\n            if (hit != -1. && hit < depth) {\n                depth = hit;\n                frag = (symbol[int(loopY)] >> int(loopX) & 1) != 0\n                    ? SQ(vec3(220, 60, 0) / 255.) // red\n                    : SQ(vec3(80, 60, 220) / 255.); // blue\n\n                // https://en.wikipedia.org/wiki/Blinn-Phong_reflection_model\n                // Albedo *= diffuse + ambient\n                frag *= max(0., dot(n, ld)) + AMB;\n                // + Specular highlight\n                frag += SUN * vec3(pow(max(0., dot(n, hv)), SHINY));\n            }\n        }\n    }\n\n    O = vec4(pow(frag, vec3(1./2.2)), 1);\n}","name":"Image","description":"","type":"image"}]}