{"ver":"0.1","info":{"id":"4lccR4","date":"1531662778","viewed":145,"name":"Raytracing in one weekend2","username":"darkeclipz","description":"following tutorial from ray tracing in one weekend. not gonna make it this weekend lol. will continue later.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (in vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }\nvec3 randomInUnitSphere() {\n\tvec3 p;\n    /*do {\n        vec2 rand = vec2(iTime, iTime+3.567);\n    \tp = vec3( random(rand), random(rand+1.), random(rand+2.) );\n    } while( length(p) >= 1.0 );*/\n    return p;\n}\n\nmat3 rotY(float angle) {\n\treturn mat3( cos(angle), 0, sin(angle), 0, 1, 0, -sin(angle), 0, cos(angle) );    \n}\n\nvec2 random2(float x) {\n    // might give problems later because its [0,1] and needs to be [0,1).\n    return vec2( random(vec2(x)), random(vec2(x))+1. );\n}\n\nstruct ray {\n\tvec3 origin;\n    vec3 direction;\n};\n    \nstruct sphere {\n\tvec3 position;\n    float radius;\n};\n    \nstruct hit {\n    ray r;\n    bool traced;\n\tvec3 point;\n    vec3 normal;\n    float t;\n    int level;\n    vec3 color;\n};\n\nconst int HIT_STACK_SIZE = 16;\nhit hitStack[HIT_STACK_SIZE];\nint hitStackSp=0;\nvoid push_hit(hit h) { hitStack[hitStackSp++] = h; }\nhit pop_hit() {\treturn hitStack[--hitStackSp]; }\n    \n#define N_SPHERES 2\nsphere spheres[N_SPHERES];\nsphere createSphere(vec3 p, float r) { sphere s; s.position = p; s.radius = r; return s; }\n\nvec3 pointAt(ray r, float t) {\n\treturn r.origin + t * r.direction;\n}\n\nfloat raySphereIntersect(ray r, sphere s) {\n    vec3 oc = r.origin - s.position;\n    float a = dot(r.direction, r.direction);\n    float b = 2.*dot(oc, r.direction);\n    float c = dot(oc, oc) - s.radius*s.radius;\n    float d = b*b-4.*a*c;\n    if(d < 0.) return -1.;\n    return (-b-sqrt(d))/(2.*a);\n}\n#define normalize(v) normalize(v+1e-6)\nvec3 trace(ray r) {\n    \n    // Background.\n    float t = 0.5*(normalize( r.direction ).y+1.0);\n    vec3 col = mix(vec3(0.),vec3(0.), t);\n    \n    for(int i=0; i < N_SPHERES; i++) { \n        sphere s = spheres[i];\n        \n\t\t// Intersection.\n        float hit = raySphereIntersect(r, s);\n        if(hit >= 0.) {\n            \n            vec3 p = pointAt(r, hit);\n\n            // Surface normal\n            vec3 sn = 0.5*(normalize(p - s.position) + 1.);\n            col = sn;\n            \n            ray target;\n            target.origin = p;\n            target.direction = p + sn ;\n            \n            //return mix(col, trace(target), 0.5); // fuuu\n            return col;\n        }\n    }\n    \n    return col;\n}\n\n#define SAMPLES 4.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    \n    spheres[0] = createSphere(vec3(0,0,-3), 1.3);\n    spheres[1] = createSphere(vec3(0,-100.5,0), 100.);\n    \n    vec2 M = (2.*iMouse.xy-R)/R.y;\n    //mat3 rot = rotY(M.x*2.);\n    vec3 col = vec3(0); \n    \n    for(float i=0.; i<SAMPLES; i++) {\n        vec2 uv = (2.*(fragCoord + random2(i)) - R)/R.y;\n    \tray r;\n        r.origin = vec3(0,0,2);\n        r.direction = /*rot**/(vec3(uv.x, uv.y, 0) - r.origin);    \n        col += trace(r);\n    }\n    \n    col /= SAMPLES;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}