{"ver":"0.1","info":{"id":"stsyW8","date":"1716556686","viewed":26,"name":"Newton fractal animation by Erik","username":"eriben0628","description":"df","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["af"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846264338327950288419716939937510582097494459230781640628\nvec3 colors[5] = vec3[5](vec3(1.,0.,0.), vec3(0.,1.,0.), vec3(0.,0.,1.), vec3(1.,0.,1.), vec3(0.,1.,1.));\n\nfloat atan2(vec2 a) {\n    float v = atan(a.y/a.x);\n    if(a.x<0.) v += PI;\n    return v;\n}\n\nvec2 imPow(vec2 a, float p) {\n    vec2 polar;\n    polar.x = atan2(a)* p;\n    polar.y = length(a);\n    \n    a.x = cos(polar.x)*pow(polar.y, p);\n    a.y = sin(polar.x)*pow(polar.y, p);\n    \n    return a;\n}\n\nvec2 imMul(vec2 a, vec2 b) {\n    float x = a.x*b.x - a.y*b.y;\n    float y = a.y*b.x + a.x*b.y;\n    return vec2(x,y);\n}\n\nvec2 imDiv(vec2 a, vec2 b) {\n    vec2 t = imMul(a, vec2(b.x,-b.y));\n    t = t/(b.x*b.x+b.y*b.y);\n    return t;\n}\n\nvec2 P(vec2 z, vec2 root[5]) {\n    vec2 a = z - root[0];\n    vec2 b = z - root[1];\n    vec2 c = z - root[2];\n    vec2 d = z - root[3];\n    vec2 e = z - root[4];\n    \n    vec2 p = imMul(a,b);\n    p = imMul(p, c);\n    p = imMul(p, d);\n    p = imMul(p, e);\n    \n    return p;\n}\n\nvec2 p(vec2 z, vec2 root[5]) {\n    vec2 deltaZ = vec2(0.001,0.001);\n\n    vec2 p = imDiv(P(z+deltaZ, root)-P(z, root), deltaZ);\n    return p;\n}\n\nvec2 imStep(vec2 z, vec2 root[5]) {\n    return -imDiv(P(z,root),p(z,root));\n}\n\n\nvec3 picture(vec2 uv, vec2 root[5]) {\n    vec2 z = uv;\n    vec2 c = z;\n    vec3 color;\n    int MaxIterations = 1000;\n    float iterations = 0.;\n    \n    for(int i = 0; i < MaxIterations; i++) {\n        vec2 newZ = z + imStep(z, root);\n        if(length(newZ-z) < 0.001) {\n            z = newZ;\n            break;\n        }\n        z = newZ;\n        iterations += 0.01;//1./float(MaxIterations);\n    }\n    \n    float d = 10000.;\n    int ID = 0;\n    for(int i = 0; i < 5; i++) {\n        if(length(z-root[i]) < d) {\n            d = length(z-root[i]);\n            ID = i;\n        }\n    }\n    \n    color = colors[ID];\n    return vec3(iterations)*color;//*vec3(z,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    //uv *= 0.5;\n    vec2 a = vec2(cos(iTime/3.),sin(iTime/3.));//*sin(iTime/3.);\n    vec2 b = vec2(cos(iTime/5.),sin(iTime/5.));//*sin(iTime/5.);\n    vec2 c = vec2(cos(iTime/7.),sin(iTime/7.));//*sin(iTime/7.);\n    vec2 d = vec2(cos(iTime/11.),sin(iTime/11.));//*sin(iTime/11.);\n    vec2 e = vec2(cos(iTime/13.),sin(iTime/13.));//*sin(iTime/13.);\n    \n    vec2 root[5] = vec2[5](a, b, c, d, e);\n\n    // Time varying pixel color\n    vec3 col = picture(uv, root)*5.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}