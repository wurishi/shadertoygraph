{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const int rays_hits=9;\nconst float epsilon=0.001;\nvec3 vertical;\n\nvec3 sphere1;\nvec3 sphere2;\nvec3 sphere3=vec3(1.0,1.0,1.0);\n\nvec3 back(vec3 rd)\n{\n\tfloat s=pow(dot(rd,vertical),0.68);//Sky\n\tfloat f=dot(rd,-vertical);//floor\n\tvec3 sc=s*vec3(66.0/255.0,111.0/255.0,169.0/255.0);\n\tvec3 fc=f*vec3(185./255.,122./255.,87./255.);\n\treturn max(sc,fc);\n}\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius, float closed_hit, out vec3 normal)\n{\n  vec3 rc = ray-center;\n  float c = dot(rc, rc) - (radius*radius);\n  float b = dot(dir, rc);\n  float d = b*b - c;\n  float t = -b - sqrt(abs(d));\n  if (d < 0.0 || t < 0.0 || t > closed_hit) \n\treturn closed_hit;\n  else {\n    normal = center-(ray+dir*t);\n\treturn t;\n }\n \n}\n\nfloat scene(vec3 ro, vec3 rd, out vec3 normal, float max_dist)\n{\n\tfloat dist=max_dist;\n\tdist=sphere(ro,rd,sphere1,0.7,dist,normal);\n\tdist=sphere(ro,rd,sphere2,0.5,dist,normal);\n\tdist=sphere(ro,rd,sphere3,0.88,dist,normal);\n\treturn dist;\n}\n\n\nmat2 rotate2D(float a)\n{\n\treturn mat2(cos(a), -sin(a),\n\t\t\t\tsin(a),  cos(a));\n}\n\nvec2 rotateY(vec2 v, float a)\n{\n\treturn v*rotate2D(a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vertical = vec3(sin(0.8*iTime),1.0,0.0);\n    sphere1=vec3(0.0,0.0,-2.0);\n\tsphere2=vec3(0.0,sin(iTime),0.0);\n    vec2 v = (-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n\tvec3 light = vec3(0.0);    \n\tvec3 transmit = vec3(1.0); \n\tvec3 ro=vec3(3.0*cos(iTime),0.0,3.0*sin(iTime))+vertical;   \n\tvec2 vd=normalize(vec3(0.0,0.0,0.0) - ro).xz; //View direction\n\tfloat va=atan(vd.y,vd.x);\n\tvec2 r2d=rotateY(vec2(1.0,v.x),va);\n\tvec3 rd=normalize(vec3(r2d.x,v.y,r2d.y));    //direction \n\t\n\tfor (int r=0;r < rays_hits; r++)\n\t{\n\t\tvec3 normal;\n\t\tfloat max_dist=1000.0;\n\t\tfloat dist=scene(ro,rd,normal,max_dist);\n\t\tif (dist < max_dist)\n\t\t{\n\t\t\t\n\t\t\ttransmit*=0.9;\n\t\t\tro += rd*dist;\n\t\t\trd =reflect(rd,normalize(normal));\n\t\t\tro += rd*epsilon; \n\t\t}\n\t\telse { //Hit infinite (or default object)\n\t\t\tlight += transmit*back(rd); //here background fonction\n\t\t\tbreak;\n\t\t}\n\t}\n\tfragColor = vec4(light, 1.0); // Set pixel color to the amount of light seen.\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsSSDK","date":"1415751503","viewed":169,"name":"3 Spheres","username":"lamogui","description":"i try to GLSL in 3D for the first time","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""}}