{"ver":"0.1","info":{"id":"XlXcRM","date":"1503917871","viewed":347,"name":"Curtains Visualiser","username":"zoweb","description":"A visualiser that looks similar to curtains.\n\nContains some nice colour gradients, a vignette, blurring and a bit of colour grading.\nAlso has a bit of flickering and camera shake.\n\nThe song is iChannel0 in Buffer C. Look in each channel for options & docs","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","sound","visualiser"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\tCurtains Visualiser\n\t===================\n\n\tby zoweb\n\t--------\n\n\tA simple visualiser with a bunch of effects that make it look quite nice.\n\tYou might be able to tell that it is pretty much a raw output from Shadertoy's\n\tsound inputs, however I made them be mirrored from the centre so that it\n\twouldn't look just like that.\n\n\tSome colour correction and grain makes it look a bit better. Then some\n\thorizontal blur who's size depends on how quiet the song is, and some camera\n\tshake and flicker. Oh, and a bit of vignette that is really not made properly\n\tbut it works :)\n\n\tIf you feel like exploring the unneat code, I've added in some comments.\n\n\tSome default songs that are recommended.\n\tChange the song by going into Buf C, and setting iChannel0 to something in the\n\tmusic tab or by setting it to Soundcloud.\n\n\tRECOMMENDED SONGS:\n\t------------------\n\t - 8 bit mentality\n\t - Tropical Beeper\n\t - Experiment\n\t - ourpithyator\n\t - (Other 8 bit songs probably will work well. Even some songs with vocals work OK!)\n\n\n\tOPTIONS:\n\t--------\n\n\tBuffer: Image\n\t - float GRAIN: Sets how dark the grain speckles will be. Setting to 0. turns\n\t\tit off. Default is .1, and you probably shouldn't go above 2.\n\t - float GRAIN_HIDE_AMNT: Defines how much lightness will remove the grain, similar\n\t\tto real life. Setting to 0 turns it off, and a higher number means increasingly\n\t\tdark areas will remove the grain more.\n\t\n\tBuffer: A\n\t - float AUDIO_STEPS: Defines how many steps there will be in the audio. This\n\t\tdoesn't effect rendering time, it is just to make it look a bit nicer.\n\t - int USE_AUDIO_STEPS: If this is one, AUDIO_STEPS will do something.\n\t\tOtherwise AUDIO_STEPS will do nothing.\n\n\t - float MIX_POS: This is a frequency on the audio where the value for mixing\n\t\twill be taken from. The value should be within 0. and 1., where 0. is the\n\t\tlowest frequency that Shadertoy gives you and 1. is the highest. Setting this\n\t\tvalue to -1 will use the current pixel, instead of the music, instead of the\n\t\tmusic, to determine mixing.\n\t - int AUTO_FRAME_MIX: If this is one, the current frame will mix with the\n\t\tprevious frame (with the amount depending on the audio at MIX_POS).\n\t\tThis looks good for some songs but for most it doesn't, unless you set MIX_POS\n\t\tto -1 where it actually can look quite good :)\n\n\tBuffer: B\n\t - int USE_BLUR: If this is one then there will be nice horizontal blurs. This\n\t\tis default a focal blur but it can be changed in Buf B.\n\n\t - float MAX_BLUR: This is the maximum amount of blur. This will be reached when\n\t\tthe volume at BLUR_POS is 0.\n\t - float MIN_BLUR: This is the minimum amount of blur. This will be reached when\n\t\tthe volume at BLUR_POS is 1. Don't set this to 0, it breaks things.\n\n\t - float BLUR_POS: This is a frequency on the audio where the value for blurring\n\t\twill be taken from. The value should be within 0. and 1., where 0. is the\n\t\tlowest frequency that Shadertoy gives you and 1. is the highest.\n\n\tBuffer: D\n\t - float SHAKE_AMNT: This is the maximum shake amount. 20 seems like a good value,\n\t\tbut for more upbeat songs you might want to set it higher.\n\t - float FLICKER_AMNT: The amount of flicker. A higher value means the screen will\n\t\tchange brightness more.\n\t - float MUSIC_SHAKE_AMNT_POS: This is a frequency on the audio where the value for\n\t\tshaking will be taken from. The value should be within 0. and 1., where 0. is\n\t\tthe lowest frequency that Shadertoy gives you and 1. is the highest. \n\n*/\n\n#define GRAIN .1\n#define GRAIN_HIDE_AMNT 2.\n\n// From https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n    \n    // Grain - from https://www.shadertoy.com/view/4dBcDK (yupferris)\n    float grainStrength = 50.0;\n    float x = (uv.x + 4.0) * (uv.y + 4.0) * (iTime + 10.0) * 10.0;\n\tfloat grain = clamp(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01) - 0.005, 0.0, 1.0) * grainStrength;\n    \n    // Convert the grain to RGB. Use the previous colour's grain as the seed.\n    float grainColorR = rand(grain);\n    float grainColorG = rand(grainColorR);\n    float grainColorB = rand(grainColorG);\n    \n    vec4 grainColor = vec4(grainColorR, grainColorG, grainColorB, 1.);\n    \n    // Make the grain more powerful in darker areas, like in real life\n    // You can visualise this by setting \"+=\" to \"=\" and GRAIN to 1.\n    fragColor += pow(1. - dot(fragColor.rgb, vec3(.33)), GRAIN_HIDE_AMNT) * (grainColor * GRAIN);\n    \n    \n    // Some slight colour grading\n    fragColor *= vec4(.9, 1., 1.1, 1.); // remove blue tones\n    fragColor *= pow(fragColor, vec4(.5454)); // gamma correction\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define AUDIO_STEPS 64.\n#define USE_AUDIO_STEPS 1\n\n#define MIX_POS -1.\n#define AUTO_FRAME_MIX 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float soundPitch = abs(.5 - uv.x);\n    float verticalSoundPitch = abs(.5 - uv.y);\n    \n#if (USE_AUDIO_STEPS == 1)\n    soundPitch = float(int(soundPitch * AUDIO_STEPS)) / AUDIO_STEPS;\n    verticalSoundPitch = float(int(verticalSoundPitch * AUDIO_STEPS)) / AUDIO_STEPS;\n#endif\n    \n    float opacity = texture(iChannel0, vec2(soundPitch, 0.)).r;\n    \n    float xDist = uv.x - 0.5;\n    float yDist = uv.y - 0.5;\n    float dist = sqrt(xDist * xDist + yDist * yDist);\n    \n    // vignette\n    opacity *= (1. - dist) * 2.;\n    \n    fragColor = vec4(uv.x, uv.y, 1., 1.);\n    fragColor *= opacity;\n    \n    fragColor = mix(fragColor, fragColor * texture(iChannel0, vec2(verticalSoundPitch, 0)).r, .2);\n    \n\tfloat bgOpacity = texture(iChannel0, vec2(0.5, 0)).r;\n    fragColor += vec4(texture(iChannel0, vec2(0.2, 0) * 0.1).r,\n                      texture(iChannel0, vec2(0.8, 0)).r * 0.2,\n                      texture(iChannel0, vec2(0.5, 0)).r * 0.4, 1.) * bgOpacity;\n    \n#if (AUTO_FRAME_MIX == 1)\n    float mixAmnt = 0.;\n    if (MIX_POS > 0.) {\n        mixAmnt = 1. - texture(iChannel0, vec2(MIX_POS, 0.)).r;\n    } else {\n        mixAmnt = dot(fragColor.rgb, vec3(.33));\n    }\n    \n    fragColor = mix(texture(iChannel1, uv), fragColor, mixAmnt + .01);\n#endif\n    \n    fragColor = clamp(fragColor, 0., 1.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define USE_BLUR 1\n\n#define MAX_BLUR 50.\n#define MIN_BLUR 1.\n\n#define BLUR_POS .01\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n#if (USE_BLUR > 0)\n    // Horizontal Blur\n    vec4 totalPixels = vec4(0);\n    \n    // The amount of blur depends on the pixel at just right of the centre of the screen.\n    // It ranges from a blur of 1 (where the pixel's blue is fully on) to 50 (where the pixel's blue is fully off)\n    int size = int(MAX_BLUR + MIN_BLUR - texture(iChannel1, vec2(BLUR_POS, 0.)).r * MAX_BLUR) * 2 + 1;\n    float totalWeight = 0.;\n    \n    for (int i = -size; i < size + 1; i = i + 1) {\n        // float weight is the current pixel's weight.\n        // having \"1. - ...\" makes it a focal blur (the edges have more weight than the centre).\n        // removing the \"1. -\" makes it a Gaussian-like blur, where the edges have less weight than the centre.\n        // Weight is always a number between 0 and 1.\n        float weight = 1. - float(size - abs(i)) / float(size);\n        totalPixels += texture(iChannel0, vec2(fragCoord.x + float(i), fragCoord.y) / iResolution.xy) * weight;\n        totalWeight += weight;\n    }\n    \n    fragColor = totalPixels / totalWeight;\n#else\n    fragColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n#endif\n    \n    // Use the below to test for new BLUR_POS settings:\n    //fragColor = mix(texture(iChannel1, fragCoord.xy / iResolution.xy), texture(iChannel1, vec2(BLUR_POS, 0)), 1.);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adds sound as a buffer\n    fragColor = texture(iChannel0, vec2(fragCoord.x / iResolution.x, 0));\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define SHAKE_AMNT 20.\n#define FLICKER_AMNT .1\n#define MUSIC_SHAKE_AMNT_POS .01\n\n// From https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){\n    return fract(sin(n) * 43758.5453123);\n}\n// End from github\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera shake\n    float shakeMultiplier = ((1. - texture(iChannel1, vec2(MUSIC_SHAKE_AMNT_POS)).r) - .5) * SHAKE_AMNT;\n    vec2 shakeAmount = shakeMultiplier * vec2(rand(iTime) - .5, rand(rand(iTime)) - .5) - shakeMultiplier / 2.;\n    vec2 newCoord = (fragCoord.xy + shakeAmount) / iResolution.xy;\n    \n    fragColor = texture(iChannel0, newCoord);\n    \n    // Flicker\n    float flickerMultiplier = texture(iChannel1, vec2(MUSIC_SHAKE_AMNT_POS)).r * FLICKER_AMNT;\n    vec2 flickerAmount = flickerMultiplier * vec2(rand(iTime), rand(rand(iTime))) - flickerMultiplier / 2.;\n    fragColor *= 1. - flickerAmount.x;\n}","name":"Buf D","description":"","type":"buffer"}]}