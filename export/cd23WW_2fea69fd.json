{"ver":"0.1","info":{"id":"cd23WW","date":"1667607312","viewed":125,"name":"Quadratic Hermit Spline SDF L2","username":"Envy24","description":"C0-continuous.\nData defined in Commod tab.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sdf","spline","distance","quadratic","equation","segment","parametric","metric","euclid","hermit","l2"],"hasliked":0,"parentid":"dsBGWD","parentname":"Quadratic Segment SDF L2"},"renderpass":[{"inputs":[],"outputs":[],"code":"/**/\nconst int num_of_ctrls = 8; /* 2 control points for first segment, then + 1 ctrl per segment. */\nconst int num_of_derivatives = num_of_ctrls - 1;\nvec2 derivatives[num_of_derivatives];\n//vec2 ctrls[num_of_ctrls]; // for num_of_ctrls differ from 8 )\n/**/\nvec2 ctrls[num_of_ctrls] = vec2[num_of_ctrls](\n    vec2( -1.6, -0.9),\n    vec2( -1.5, -0.9),\n    vec2( -1.0, -0.9),\n    vec2(-0.33,  0.9),\n\n    vec2( 0.33, -0.9),\n    vec2(  1.0,  0.9),\n    vec2(  1.5,  0.9),\n    vec2(  1.6,  0.9)\n);\n/**/\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float r)\n{\n    return length(C - NDC)-r;\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    float discriminant = b * b - 4.0 * a * c;;\n    float INVa = 1.0 / (2. * a);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - b) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-b - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n/*  https://www.shadertoy.com/view/ssKBRD\n    Solves ax^3+bx^2+cx+d=0.\n\n    Return value:\n        0 - no roots when A==0, B==0, C==0;\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicVietaForReal(\n    inout vec2[3] roots,\n    float aa, float bb, float cc, float dd)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / aa;\n    float A = bb * inv;\n    float B = cc * inv;\n    float C = dd * inv;\n\n    float Q = (A * A - 3.0 * B) / 9.0;\n    float R = (2.0 * A * A * A - 9.0 * A * B + 27.0 * C) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - A * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - A * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - A * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * sign(R) * sqrt(Q) * cosh(phi) - A * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n\n        roots[0].x = -2.0 * sign(R) * sqrt(abs(Q)) * sinh(phi) - A * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        roots[0].x = -pow(C - A * A * A / 27.0, oneThird) - A * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - A * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - A * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\n/* \n    Returns number of real roots.       \n*/\nint solve3(\n    inout vec2[3] roots,\n    float a, float b, float c, float d)\n{\n    // Cubic equation?\n    if (a != 0.0)\n    {\n        return solveCubicVietaForReal(roots, a, b, c, d);\n    }\n    \n    // Quadratic equation?\n    if (b != 0.0)\n    {\n        vec2 roots_[2];\n\n        int num = solveQuadraticForReal(roots_, b, c, d);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (c != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -d/c; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (c == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 123u;\n    const uint entropy1 = 456u;\n    const uint entropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * entropy2 + x;\n    uint value1 = x * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nvoid randomize_ctrls(float time)\n{\n    time *= 0.3;\n    float t = fract(time);\n    uint T = uint(time);\n\n    for (int k = 0; k < num_of_ctrls; ++k)\n    {\n        uint x = T + uint(k);\n        uint y = 2u * T + uint(k * 2);\n        vec2 c = vector2HashUI32(x, y);\n        vec2 n = vector2HashUI32(x + 1u, y + 2u);\n    \n        ctrls[k] = c * (1. - t) + n * t;\n        ctrls[k] *= vec2(3.5, 2.5);      \n    }\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define INITIALLY_FAR               9e30\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define SCENE_SCALE               ( 3.0 )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nfloat L2(vec2 B, vec2 E)\n{\n    vec2 D = E - B;\n    return sqrt(D.x*D.x + D.y*D.y);\n}\n\nfloat quadratic_HermitSDF_L2(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 dP0)\n{\n    vec2 a = P1 - dP0 - P0, b = dP0, c = P0, d = P0 - NDC;\n    \n    float coef[4] = float[4](\n        2. * dot(a, a),\n        3. * dot(a, b),\n        2. * dot(a, d) + dot(b, b),\n             dot(b, d)\n    );\n    vec2 roots[3];\n    \n    int case_ = solve3(roots, coef[0], coef[1], coef[2], coef[3]);\n    \n    float minSq = INITIALLY_FAR;\n\n    for (int i = 0; i < case_; ++i)\n    {\n        // Possibly closest point of curve.\n        float x = clamp(roots[i].x, 0., 1.);\n        vec2 P = a*x*x+b*x+c;\n        \n        vec2 diff = P - NDC;\n        \n        // Find minimal squared distance\n        minSq = min(dot(diff, diff), minSq);\n    }\n   \n    //return sqrt(minSq);\n    return minSq;\n}\n\nfloat quad_Hermit_splineSDF_L2(\n    in vec2 NDC,\n    inout vec2[num_of_derivatives] derivatives,\n    in vec2[num_of_ctrls] ctrls)\n{\n    float min_dist = INITIALLY_FAR;  \n    int num_of_segments = num_of_ctrls - 1; // 3 knots per segment\n\n    for (int s = 0; s < num_of_segments; ++s)\n    {   \n        min_dist = \n            min(\n                min_dist,\n                quadratic_HermitSDF_L2(NDC, ctrls[s], ctrls[s + 1], derivatives[s]));\n    }\n\n    float R = sinOSC(0.0, 0.05, iTime);\n    //return min_dist - R;\n    return sqrt(min_dist) - R;\n}\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./R.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./R.y, 0., abs(dist)) );\n}\n\nvec3 add_metric_circle(\n    vec2 NDC,\n    inout vec2[num_of_derivatives] derivatives,\n    in vec2[num_of_ctrls] ctrls,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            map_to_centered_ndc(iMouse.xy, SCENE_SCALE, vec2(0), false) :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5) * 1.5;\n            //vec2(0);\n    \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float dist_form_point_to_box_edge = L2(NDC, M) - abs(quad_Hermit_splineSDF_L2(M, derivatives, ctrls));\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric circle\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n\n\nvoid calculateDerivatives(\n    inout vec2[num_of_derivatives] derivatives,\n    in vec2[num_of_ctrls] ctrls,\n    in vec2 dP0,\n    in float amount)\n{\n    derivatives[0] = dP0 * amount;\n    \n    for (int d = 1; d < num_of_derivatives; ++d)\n    {\n        derivatives[d] = amount * (2.0 * (ctrls[d] - ctrls[d-1]) - derivatives[d - 1]);\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);  \n    \n    randomize_ctrls(iTime);\n    \n    calculateDerivatives(derivatives, ctrls, vec2(0.5, 0.5), 0.5);\n    float min_dist = quad_Hermit_splineSDF_L2(NDC, derivatives, ctrls);\n\n    // Blending.\n    vec3 color = colorize_field(min_dist, vec3(0.1, 0.4, 0.7));\n    color = add_metric_circle(NDC, derivatives, ctrls, color);\n    \n    /**/\n    #define UNIT ( 8./R.y )  \n    float dc = 1./float(num_of_ctrls-1);\n    for (int i = 0; i < num_of_ctrls; ++i)\n    {\n        float c = float(i)*dc;\n        color = mix( color, vec3(1.,c,1.-c), smoothstep(UNIT, 0., diskSDF_L2(NDC, ctrls[i], 3.*UNIT)) );\n    }\n    /**/\n\n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}