{"ver":"0.1","info":{"id":"DlBcWD","date":"1695085421","viewed":28,"name":"3D and Ray Marching","username":"c0b0w","description":"Nathan Vaughn @ https://inspirnathan.com/posts/52-shadertoy-tutorial-part-6\nNathan Vaughn @ https://inspirnathan.com/posts/52-shadertoy-tutorial-part-7","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","sky","ball","rotation","axis","cardinal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\n#define COLOR_BACKGROUND vec3(0., 0.75, 1)\n\nstruct Material {\n  vec3 ambientColor; // k_a * i_a\n  vec3 diffuseColor; // k_d * i_d\n  vec3 specularColor; // k_s * i_s\n  float alpha; // shininess\n};\n\nMaterial solidColor(vec3 rgb, float pct) {\n  vec3 aCol = pct * rgb;\n\n  return Material(aCol, vec3(0), vec3(0), 0.);\n}\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n  vec3 aCol = 0.4 * vec3(0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial purple() {\n  vec3 aCol = 0.7 * vec3(0.78, 0.4, 0.98);\n  vec3 dCol = 0.8 * vec3(0.5, 0.23, 0.62);\n  vec3 sCol = 0.25 * vec3(1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n  vec3 aCol = vec3(1. + 0.7*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nstruct Surface {\n  int id; // id of object\n  float sd; // signed distance value from SDF\n  Material mat; // material of object\n};\n\n\n\n// https://iquilezles.org/articles/distfunctions/\n// operation union, return the closest object to the ray \nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\nfloat calculPente(vec2 p1, vec2 p2) {\n\n    return (p2.y - p1.y) / (p2.x - p1.x);\n}\n\n\n//**************** sd Objects ****************\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere(vec3 p, float r, vec3 offset) {\n  return length(p - offset) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdFloor(vec3 p) {\n    return p.y + 1.;\n}\n\nfloat sdfCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// ðŸ‘½ \nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\n//******************************************\n\n//**************** Transformation Matrix **************** \n// retourne la matrice de transformation autour de l'angle theta\nmat3 rotationMatrixX(float theta) {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, cos(theta), -sin(theta)),\n        vec3(0, sin(theta), cos(theta))\n    );\n}\n\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// pitch\nvec3 rotateVectorX(vec3 vector, float angle) {\n    return vec3(\n            vector.x, \n            vector.y*cos(angle) - vector.z*sin(angle),\n            vector.y*sin(angle) + vector.z*cos(angle));\n}\n\n// yaw\nvec3 rotateVectorY(vec3 vector, float angle) {\n    return vec3( \n            vector.x*cos(angle) + vector.z*sin(angle),\n            vector.y,\n            vector.x* -sin(angle) + vector.z*cos(angle));\n}\n\n\n// roll\nvec3 rotateVectorZ(vec3 vector, float angle) {\n    return vec3( \n            vector.x*cos(angle) - vector.y*sin(angle),\n            vector.x*sin(angle) + vector.y*cos(angle),\n            vector.z);\n}\n\n//**********************************************\n\n// https://inspirnathan.com/posts/53-shadertoy-tutorial-part-7\n// Initiate object and give them an id for the coloring\nvec2 map(vec3 p) {\n    // draw cardinal axis \n    float axisRadius = 0.025;\n    vec2 xAxis = vec2(sdCappedCylinder(p, vec3(0, 0, 0), vec3(50, 0, 0), axisRadius), 4.);\n    vec2 yAxis = vec2(sdCappedCylinder(p, vec3(0, 0, 0), vec3(0, 50, 0), axisRadius), 4.1);\n    vec2 zAxis = vec2(sdCappedCylinder(p, vec3(0, 0, 0), vec3(0, 0, 50), axisRadius), 4.2);\n    \n    \n    vec2 res = vec2(1e10, 0.); // ID = 0\n    vec2 damier = vec2(sdFloor(p), 0.1); // ID = 0.1\n    vec2 sphereLeft = vec2(sdSphere(p, 1., vec3(-2, 0, 0)), 2.); // ID = 2\n    vec2 sphereRight = vec2(sdSphere(p, 1., vec3(2, 0, 0)), 3.); // ID = 3\n    \n    vec3 box_coord = rotateVectorY(vec3(p.x-1., p.y-2., p.z), iTime);\n    vec2 box = vec2(sdBox(box_coord, vec3(0.5, 0.5, 0.5)), 5);\n\n    res = opU(res, damier);\n    res = opU(res, xAxis);\n    res = opU(res, yAxis);\n    res = opU(res, zAxis);\n    \n    res = opU(res, sphereLeft);\n    res = opU(res, sphereRight);\n    res = opU(res, box);\n    return res; // the y-component is the ID of the object hit by the ray\n}\n\n// Improved version of the map function with Material for the color\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nSurface scene(vec3 p) {\n    float axisRadius = 0.025;\n    vec3 box_coord = rotateVectorY(vec3(p.x-1., p.y-2., p.z), iTime);\n    \n    Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n    Surface xAxis = Surface(2, sdCappedCylinder(p, vec3(0, 0, 0), vec3(50, 0, 0), axisRadius), solidColor(vec3(1, 0, 0), 0.8));\n    Surface yAxis = Surface(3, sdCappedCylinder(p, vec3(0, 0, 0), vec3(0, 50, 0), axisRadius), solidColor(vec3(0, 1, 0), 0.8));\n    Surface zAxis = Surface(4, sdCappedCylinder(p, vec3(0, 0, 0), vec3(0, 0, 50), axisRadius), solidColor(vec3(1., 1., 0.6), 0.8));\n    Surface sSphereGold = Surface(5, sdSphere(p, 1., vec3(-2, 0, 0)), gold());\n    Surface sSphereSilver = Surface(6, sdSphere(p, 1., vec3(2, 0, 0)), silver());\n    Surface rotatingBox = Surface(7, sdBox(box_coord, vec3(0.5, 0.5, 0.5)), purple());\n    \n    \n    Surface res = opUnion(sFloor, xAxis); // closest object\n    res = opUnion(res, yAxis);\n    res = opUnion(res, zAxis);\n    res = opUnion(res, sSphereGold);\n    res = opUnion(res, sSphereSilver);\n    res = opUnion(res, rotatingBox);\n    return res;\n}\n\n\n// Nathan Vaughn\n// returns a ray direction that represents the direction a point on the surface it's facing.\n// Donc la normale d'un point Ã  la surface d'un objet \nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n        e.xyy * scene(p + e.xyy).sd +\n        e.yyx * scene(p + e.yyx).sd +\n        e.yxy * scene(p + e.yxy).sd +\n        e.xxx * scene(p + e.xxx).sd);\n}\n\n// Nathan Vaughn @ https://inspirnathan.com/posts/52-shadertoy-tutorial-part-6\nSurface rayMarch(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST; \n    Surface co; // initialize result to zero for signed distance value and ID\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd; // first ray from the camera to the center\n        co = scene(p);\n        depth += co.sd;\n        \n        if (co.sd < PRECISION || depth > MAX_DIST) break; // if it's at 0.001 distance, we say it reached, if > 100 units, it's way past it\n    }\n    co.sd = depth;\n    \n    return co;\n}\n\n// https://inspirnathan.com/posts/57-shadertoy-tutorial-part-11\nvec3 phong(vec3 lightDir, vec3 normal, vec3 rd, Material mat) {\n  // ambient\n  vec3 ambient = mat.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = mat.diffuseColor * dotLN;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n  vec3 specular = mat.specularColor * pow(dotRV, mat.alpha);\n\n  return ambient + diffuse + specular;\n}\n\n\n// https://inspirnathan.com/posts/56-shadertoy-tutorial-part-10\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cameraDirection = normalize(lookAtPoint - cameraPos); \n\tvec3 cameraRight = normalize(cross(vec3(0, 1, 0), cameraDirection)); \n\tvec3 cameraUp = normalize(cross(cameraDirection, cameraRight));\n\t\n\treturn mat3(-cameraRight, cameraUp, -cameraDirection);\n}\n\n\nvec3 render(vec3 camPosition, vec3 rayDirection) {\n    vec3 col = COLOR_BACKGROUND; // background\n    Surface co = rayMarch(camPosition, rayDirection); // closest object\n    \n    float depth = co.sd; // signed distance value \n    \n    if (depth > MAX_DIST) {\n        return col; // ray didn't hit anything\n    } else {\n        // col = vec3(0, 0, 1); // ray hit something without light\n        vec3 p = camPosition + rayDirection * depth; // point on the object it's touching \n        vec3 normal = calcNormal(p); // normal du point sur l'objet \n        \n        // light #1\n        vec3 lightPosition1 = vec3(-8, -6, -5);\n        vec3 lightDirection1 = normalize(lightPosition1 - p);\n        float lightIntensity1 = 0.9;\n\n        // light #2\n        vec3 lightPosition2 = vec3(1, 1, 1);\n        vec3 lightDirection2 = normalize(lightPosition2 - p);\n        float lightIntensity2 = 0.5;\n        \n        // col = vec3(0., 0., diffuseReflection);\n        col = lightIntensity1 * phong(lightDirection1, normal, rayDirection, co.mat);\n        col += lightIntensity2 * phong(lightDirection2, normal , rayDirection, co.mat); //second light in the scene\n        \n        return col;\n    }\n}\n\n\n// z en profondeur, y en hauteur et x en largeur\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // <0, 1>\n    uv -= 0.5; // <-0.5,0.5>\n    uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n    \n    vec3 col = vec3(0);\n    \n    // Camera\n    vec3 lookAtPoint = vec3(0, 0, 0);\n    vec3 camPosition = vec3(0, 3, 9); // 10 units along de z axis (behind the center)\n    camPosition = rotateVectorY(camPosition, iTime / 3.); \n    vec3 rayDirection = camera(camPosition, lookAtPoint) * normalize(vec3(uv, -1)); \n    // rayDirection = normalize(rotateVectorY(vec3(uv, -1), iTime / 3.));\n    \n    \n    col = render(camPosition, rayDirection);\n    \n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}