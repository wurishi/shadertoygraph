{"ver":"0.1","info":{"id":"flKyzK","date":"1661831758","viewed":198,"name":"Parallax mapping for Bricsys","username":"SergeySivak","description":"This is an extension of the normal mapping that gives a solution to the texturing problems for curved geometres with ups and downs.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["normalmapping","parallaxmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define heightCoef 20.\n#define lightDir normalize(vec3(1.,1.,0.5))\n#define PI 3.14\n#define cameraPos vec3(0.75, 0.75, 2.)\n#define parallaxScale (0.35)\n\n\nvec3 getNormal(vec2 uv);\nvec3 animateLightPoint();\nvec2 mapParallaxPoint(vec2 textureCoordinates, vec3 directionOfView);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvOriginal = fragCoord/iResolution.xy*1.5;\n    \n    vec3 texPosition = vec3(uvOriginal.x, uvOriginal.y, 0.0);\n    vec3 viewDirection = cameraPos - texPosition;\n    \n    vec2 uv = mapParallaxPoint(uvOriginal, viewDirection);\n    if(uv.x > iResolution.x || uv.y > iResolution.y || uv.x < -iResolution.x || uv.y < -iResolution.y)\n        discard;    \n    \n    vec3 lightPos = vec3(5.5, 4.5, 4.5);\n    vec3 L = normalize(lightPos - vec3(uv, 0.));\n    vec3 N = getNormal(uv);\n    //phong\n    float attenuation = dot(N, L);\n    \n    fragColor = vec4(vec3(attenuation), 1.);\n \n}\n\nvec3 getNormal(vec2 uv)\n{\n    vec3 vector1;\n    vec3 vector2;\n    float deltaHeight;\n    float stepUv = 1./512.;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x, uv.y+stepUv)).x - texture(iChannel0, vec2(uv.x, uv.y-stepUv)) ).x * heightCoef;\n    vector1.x = 0.;\n    vector1.y = deltaHeight;\n    vector1.z = 0.5;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x+stepUv, uv.y)).x - texture(iChannel0, vec2(uv.x-stepUv, uv.y)) ).x * heightCoef;\n    vector2.x = 1.;\n    vector2.y = deltaHeight;\n    vector2.z = 0.5;\n    \n    return normalize(cross(vector1, vector2));\n}\n\nvec2 mapParallaxPoint(vec2 textureCoordinates, vec3 directionOfView)\n{\n    //return textureCoordinates;\n    float height =  (1.0 - texture(iChannel0, textureCoordinates).x) * parallaxScale;\n    vec2 p = directionOfView.xy / directionOfView.z * height;\n       \n    return textureCoordinates - p;\n}\n\n","name":"Image","description":"","type":"image"}]}