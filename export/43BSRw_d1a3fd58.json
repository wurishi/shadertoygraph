{"ver":"0.1","info":{"id":"43BSRw","date":"1710349129","viewed":203,"name":"Improved Stupid Space","username":"jcarrano","description":"I took this shader https://www.shadertoy.com/view/4XBSRW and added the VHS from https://www.shadertoy.com/view/XlsczN\n\nCredits to the original authors.","likes":13,"published":1,"flags":96,"usePreview":0,"tags":["text","astrophysics","vhs","vibes","chromaticabberration"],"hasliked":0,"parentid":"4XBSRW","parentname":"Stupider Jupiter"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xs33Dl","filepath":"https://soundcloud.com/astrolives/oneironaut","previewfilepath":"https://soundcloud.com/astrolives/oneironaut","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//YIQ/RGB shit\n\tvec3 rgb2yiq(vec3 c){   \n\t\t\t\t\treturn vec3(\n\t\t\t\t\t\t(0.2989*c.x + 0.5959*c.y + 0.2115*c.z),\n\t\t\t\t\t\t(0.5870*c.x - 0.2744*c.y - 0.5229*c.z),\n\t\t\t\t\t\t(0.1140*c.x - 0.3216*c.y + 0.3114*c.z)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\tvec3 yiq2rgb(vec3 c){\t\t\t\t\n\t\t\t\t\treturn vec3(\n\t\t\t\t\t\t(\t 1.0*c.x +\t  1.0*c.y + \t1.0*c.z),\n\t\t\t\t\t\t( 0.956*c.x - 0.2720*c.y - 1.1060*c.z),\n\t\t\t\t\t\t(0.6210*c.x - 0.6474*c.y + 1.7046*c.z)\n\t\t\t\t\t);\n\t\t\t\t}\n        \n        vec2 Circle(float Start, float Points, float Point) \n{\n\tfloat Rad = (3.141592 * 2.0 * (1.0 / Points)) * (Point + Start);\n\t//return vec2(sin(Rad), cos(Rad));\n\t\treturn vec2(-(.3+Rad), cos(Rad));\n\n}\n\nvec3 Blur(vec2 uv, float f, float d){\n  //  d=abs(d);\n  float t = (sin(iTime*5.0+uv.y*5.0))/10.0;\n    float b = 1.0;\n   //t=sin(iTime*5.0+f)/10.0;\n    t=0.0;\n    vec2 PixelOffset=vec2(d+.0005*t,0);\n    \n    float Start = 2.0 / 14.0;\n    vec2 Scale = 0.66 * 4.0 * 2.0 * PixelOffset.xy;\n    \n    vec3 N0 = texture(iChannel0, uv + Circle(Start, 14.0, 0.0) * Scale).rgb;\n    vec3 N1 = texture(iChannel0, uv + Circle(Start, 14.0, 1.0) * Scale).rgb;\n    vec3 N2 = texture(iChannel0, uv + Circle(Start, 14.0, 2.0) * Scale).rgb;\n    vec3 N3 = texture(iChannel0, uv + Circle(Start, 14.0, 3.0) * Scale).rgb;\n    vec3 N4 = texture(iChannel0, uv + Circle(Start, 14.0, 4.0) * Scale).rgb;\n    vec3 N5 = texture(iChannel0, uv + Circle(Start, 14.0, 5.0) * Scale).rgb;\n    vec3 N6 = texture(iChannel0, uv + Circle(Start, 14.0, 6.0) * Scale).rgb;\n    vec3 N7 = texture(iChannel0, uv + Circle(Start, 14.0, 7.0) * Scale).rgb;\n    vec3 N8 = texture(iChannel0, uv + Circle(Start, 14.0, 8.0) * Scale).rgb;\n    vec3 N9 = texture(iChannel0, uv + Circle(Start, 14.0, 9.0) * Scale).rgb;\n    vec3 N10 = texture(iChannel0, uv + Circle(Start, 14.0, 10.0) * Scale).rgb;\n    vec3 N11 = texture(iChannel0, uv + Circle(Start, 14.0, 11.0) * Scale).rgb;\n    vec3 N12 = texture(iChannel0, uv + Circle(Start, 14.0, 12.0) * Scale).rgb;\n    vec3 N13 = texture(iChannel0, uv + Circle(Start, 14.0, 13.0) * Scale).rgb;\n    vec3 N14 = texture(iChannel0, uv).rgb;\n    \n    vec4 clr = texture(iChannel0, uv);\n    float W = 1.0 / 15.0;\n    \n    clr.rgb= \n\t\t(N0 * W) +\n\t\t(N1 * W) +\n\t\t(N2 * W) +\n\t\t(N3 * W) +\n\t\t(N4 * W) +\n\t\t(N5 * W) +\n\t\t(N6 * W) +\n\t\t(N7 * W) +\n\t\t(N8 * W) +\n\t\t(N9 * W) +\n\t\t(N10 * W) +\n\t\t(N11 * W) +\n\t\t(N12 * W) +\n\t\t(N13 * W) +\n    (N14 * W);\n    \n   \n    return  vec3(clr.xyz)*b;\n    }\n\n\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // float d = (iResolution.x/500.0)/2.0-.1*iMouse.x/50.0;\n    float d = .1*iMouse.x/50.0;\n   // d=.1-round(mod(iTime/3.0,1.0))*.1;\n    \tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\n    float s = (texture(iChannel1,fragCoord).r);// - texture(iChannel1,vec2(0.01+uv.y/1000.0,1.0)).r)*2.0;\n   \n        \n            float e = min(.30,pow(max(0.0,cos(uv.y*4.0+.3)-.75)*(s+0.5)*1.0,3.0))*25.0;\n     s-=pow(texture(iChannel1,vec2(0.01+((uv.y)*32.0)/32.0,1.0)).r,1.0);\nuv.x+=e*abs(s*3.0);\n    float r = texture(iChannel2,vec2(mod(iTime*10.0,mod(iTime*10.0,256.0)*(1.0/256.0)),0.0)).r*(2.0*s);\n    uv.x+=abs(r*pow(min(.003,(uv.y-.15))*6.0,2.0));\n    \n    d=.051+abs(sin(s/4.0));\n    float c = max(0.0001,.002*d);\n\tvec2 uvo = uv;\n   // uv.x+=.1*d;\n    fragColor.xyz =Blur(uv,0.0,c+c*(uv.x));\n    float y = rgb2yiq(fragColor.xyz).r;\n    \n    \n    \n   uv.x+=.01*d;\n    c*=6.0;\n    fragColor.xyz =Blur(uv,.333,c);\n    // texture(iChannel0, uv);\n    float i = rgb2yiq(fragColor.xyz).g;\n    \n    \n    uv.x+=.005*d;\n    \n    c*=2.50;\n    fragColor.xyz =Blur(uv,.666,c);\n    float q = rgb2yiq(fragColor.xyz).b;\n    \n   \n    \n    fragColor.xyz=yiq2rgb(vec3(y,i,q))-pow(s+e*2.0,3.0);\n    fragColor.xyz*=smoothstep(1.0,.999,uv.x-.1);\n    \n   // fragColor.xyz-=min(0.10,pow(uv.x,3.0))*d;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float ANGLE = 3.125;\n\nconst float RAD_ANGLE = ANGLE / 360. * 6.28315;\n\nconst mat2 rotationMatrix = mat2(cos(RAD_ANGLE),-sin(RAD_ANGLE),sin(RAD_ANGLE),cos(RAD_ANGLE));","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This thing is just for handling the silly text I'm putting over this\n// made johnny-on-the-spot for this one shader in particular\n// (I'm sure there are better text impls on ShaderToy but this one is mine <3)\n\nconst int message[] = int[](102,117,99,107,105,110,103,32,108,111,118,101,32,115,112,97,99,101);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Intentionally in pixels for once, instead of ratios\n    vec2 messageStart = vec2(\n        0.5 * iResolution.x - 9.5*24.,\n        0.5 * iResolution.y\n    );\n    if(fragCoord.y < messageStart.y && \n    fragCoord.y > messageStart.y - 32. &&\n    fragCoord.x > messageStart.x && \n    fragCoord.x < messageStart.x + 18.*24.\n    ) {\n        \n        int letter = message[(int(floor(fragCoord.x - messageStart.x)) / 24) % 18];\n        \n        vec2 fontRes = iChannelResolution[0].xy;\n        \n        vec2 spriteLoc = vec2(float(letter % 16) / 16., 1.0 - float(letter/16 + 1) / 16.);\n        \n        vec2 uv = fragCoord - messageStart;\n        uv.x = mod(uv.x,24.);\n        uv.y = mod(uv.y,32.);\n        \n        float letterness = texture(iChannel0,spriteLoc + uv*0.0018).r;\n        \n        fragColor = vec4(letterness,letterness,letterness * 0.5,letterness);\n    } else {\n        fragColor = vec4(0.05,0.02,0.05,0.05);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Given texture coordinate, output appropriate surface colour\nvec3 gasGiantSurface(in vec2 uv, float flowSpeed) {\n    // Doing a modulo here to cap out the floating-point error\n    float temps = mod(iTime*2.95,6.2831855 * 20.0);\n    vec2 point = uv * vec2(15.,5.5) + vec2(1.,2.1);\n    point.y -= temps * .1;\n\n    float a_x = 0.2 * flowSpeed;\n    float a_y = .05 * flowSpeed;\n    \n    for(int i=1; i<int(12); i++){\n        float float_i = float(i); \n        vec2 delta = vec2(\n            a_x*sin(float_i*point.y+temps/point.x),\n            a_y*cos(float_i*point.x+temps)\n        );\n        point += delta;\n    }\n    point = abs(vec2(\n        cos(point.x+point.y),\n        sin(point.x+point.y))\n    );\n    // point = normalize(point) * 2.0; // <-- Alternative mapping for point\n    \n    // Matrix for mapping point position to colour\n    // Top row affects point.x, bottom row affects point.y\n    mat2x3 colorMap = mat2x3(\n        0.3,0.12,0.55,\n        0.95,0.34,0.6\n    );\n    \n    vec3 col = colorMap * point;\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Getting our usual shader bearings...\n    fragColor.rgb = vec3(0.0); // Doing this for the Windows users out there <3\n    vec2 oldCoord = fragCoord; // surprise tool that will help us later (to draw text)\n    \n    fragCoord = rotationMatrix * (fragCoord/2.)+fragCoord/2.;\n    \n \n    // The funny for loops are for the supersampling we're doing here.\n    for(int x = -1; x < 2; ++x)\n    {\n        \n        vec2 coord = fragCoord + vec2(float(x),0.2*float(x))*1.5;\n        \n        vec2 texCoord = (coord.xy / iResolution.xy).yx;\n        vec2 position = ( coord.xy / iResolution.xy );\n\n        // Some pre-branch calculations...\n        vec2 center = iResolution.xy / 2.;\n        float centerDistance = distance(center, coord.xy);\n        float radius = iResolution.y / 2.2;\n        vec3 atmosphereColor = vec3(0.8, .1, .6);\n\n        // Find planet coordinates...\n        vec2 posOnPlanet = (coord.xy - (center - radius));\n        vec2 planetCoord = posOnPlanet / (radius * 2.0);\n\n        // Calculate light amounts...\n        float dduv = dot(planetCoord,planetCoord);\n        float light = min(1.0,length(planetCoord/(sqrt(1.4-dduv) + .85)));\n        float lightAtmosphere = light * 0.75;\n\n        // okay lets do it\n        if (centerDistance < radius) { // Within the planet\n\n            // Apply surface with lighting\n            vec3 surfaceColor = gasGiantSurface(\n                texCoord,\n                clamp(radius/centerDistance,0.2,1.25)\n            );\n\n            // Adding some extra rim lighting rq\n            light += smoothstep(0.98,1.0,centerDistance / radius) * texCoord.x *light *light;\n            surfaceColor *= max(light,0.12);\n\n            // Atmosphere\n            float fresnelIntensity = pow(centerDistance / radius, 3.);\n            vec3 fresnel = mix(surfaceColor, atmosphereColor, fresnelIntensity * lightAtmosphere);\n\n            fragColor[x+1] = (fresnel * max(1.0,texCoord.x * 2.))[x+1];\n        } else { // Beyond the planet\n            // Do stars\n            float starriness = step(0.95,texture(iChannel0,position).r);\n\n            // Fuzzy outer atmosphere\n            vec3 fuzziness = atmosphereColor * \n                (1.0 - smoothstep(radius,radius*1.1,centerDistance)) *\n                max(0.25,lightAtmosphere);\n\n            fragColor[x+1] += (fuzziness + starriness)[x+1];\n        }\n    }\n    \n    vec2 uv = oldCoord / iResolution.xy;\n    \n    // Do the text\n    fragColor.gb += texture(iChannel2,uv).gb;\n    fragColor.r += texture(iChannel2,uv + 0.002).r;\n    \n    // yeah.\n    fragColor.a = 1.0;\n}","name":"Buffer B","description":"","type":"buffer"}]}