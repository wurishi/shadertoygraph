{"ver":"0.1","info":{"id":"XlcXDl","date":"1482029253","viewed":196,"name":"K2SO - Rogue One","username":"Nesvi7","description":"Rogue One's K2SO","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 dof(sampler2D buffer, vec2 uv, float distanceOfFocus){\n\tvec3 finalColor = vec3(0.0);\n    const float squareEdge = 5.0;\n    const float iters = (squareEdge*2.0+1.0)*(squareEdge*2.0+1.0);\n    float l = abs(distanceOfFocus-texture(buffer,uv).a);\n    float radiousOfDepth = 3.0;\n    float dofLevel = clamp((l-radiousOfDepth )*0.1,0.0,1.0);    \n    for( float i = -squareEdge; i <= squareEdge; i++)\n        for( float j = -squareEdge; j <= squareEdge; j++)\n            finalColor += texture(buffer,uv+vec2(i,j)*0.0015*dofLevel).xyz;\n        \n    finalColor /= iters;\n    \n    //return vec3(dofLevel);\n    return finalColor;\n}\nvec3 GammaCorrection(vec3 inColor){\n\tconst vec3 gammaExp = vec3(1.0/2.2);\n    return pow(inColor,gammaExp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tfragColor = vec4(dof(iChannel0,uv,4.54),1.0);\n    \n    fragColor.xyz = GammaCorrection(fragColor.xyz);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define cameraMove 0\n//By Nestor Vina\n\n// ray marching\nconst int max_iterations = 100;\nconst float stop_threshold = 0.02;\nconst float grad_step = 0.01;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec3 sunDir = normalize(vec3(-0.5,-1.0,-1.0));\nvec3 lightColor = vec3(0.9,0.9,0.8);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 rotate( vec3 p, vec3 rot ){\n    rot.z = -rot.z;\n    mat3 ry = mat3(cos(rot.y), 0.0,-sin(rot.y),\n\t\t\t   0.0, 1.0, 0.0, \n\t\t\t   sin(rot.y), 0.0, cos(rot.y)  );\n    \n\tmat3 rz = mat3(cos(rot.z),-sin(rot.z), 0.0,\n\t\t\t   sin(rot.z), cos(rot.z), 0.0,\n\t\t\t   0.0, 0.0, 1.0 );\n     \n\tmat3 rx = mat3(1.0, 0.0, 0.0,\n\t\t\t   0.0, cos(rot.x), sin(rot.x), \n\t\t\t   0.0,-sin(rot.x), cos(rot.x) );\n    return p*rz*ry*rx;\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x, \n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opUS( vec2 d1, vec2 d2, float _smooth )\n{\n\treturn vec2(smin(d1.x,d2.x, _smooth), (d1.y<d2.y)?d1.y:d2.y);\n}\n\n//Primitives\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat sdCappedCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\n//Map\n\nvec2 K2SOEyes(vec3 p){\n    float theDist;    \n    \n    const float ipd = 0.37;\n    const float eyeHeight = 0.0;\n    float eyeL = length(p-vec3(-ipd,eyeHeight,-0.75))-0.15;\n    float eyeR = length(p-vec3(ipd,eyeHeight,-0.75))-0.15;\n    \n    \n    float eyeLHole = length((p-vec3(-ipd,eyeHeight,-0.9))*vec3(1.0,1.0,0.2))-0.07;\n    float eyeRHole = length((p-vec3(ipd,eyeHeight,-0.9))*vec3(1.0,1.0,0.2))-0.07;\n    \n    theDist = min(eyeL,eyeR);\n    theDist = max(theDist,-eyeLHole);\n    theDist = max(theDist,-eyeRHole);\n    return vec2(theDist,3.0);\n}\n\nvec2 K2SOHead( vec3 p ){\n\tvec2 theDist;\n    \n    const float cutSeparation = -0.9;\n    float verticalCutL = -p.x + cutSeparation;\n    float verticalCutR = p.x + cutSeparation;\n    \n    //return vec2(verticalCutR,0.0);\n    theDist = vec2(smin(length((p+vec3(0.0,-0.3,0.0))*vec3(1.0,0.8,0.9))-1.0,verticalCutL,-8.0),0.0);    \n    theDist.x = smin(theDist.x,verticalCutR,-8.0);  \n    \n    float horizontalCut = p.y - 0.5;\n    float horizontalCutTop = -p.y - 0.9;\n    \n    theDist.x = max(theDist.x,horizontalCut);\n    theDist.x = smin(theDist.x,horizontalCutTop,-8.0);\n    \n    const float ipd = 0.37;\n    const float eyeHeight = 0.0;\n    float eyeL = sdCapsule(p,vec3(-ipd,eyeHeight,0.0), vec3(-ipd,eyeHeight,-2.0),0.15);\n    float eyeR = sdCapsule(p,vec3(ipd,eyeHeight,0.0), vec3(ipd,eyeHeight,-2.0),0.15);\n    \n    theDist.x = max(theDist.x,-eyeL);\n    theDist.x = max(theDist.x,-eyeR);\n    \n    float mouthGroove = sdBox((p+vec3(0.0,-0.9,+1.0))*vec3(4.0*min(p.y+1.11-2.0,1.0),1.0,1.0),vec3(0.5,0.5,0.5));\n    theDist.x = max(theDist.x, -mouthGroove);\n    \n    float mouth = sdBox(p+vec3(0.0,-0.65,0.7),vec3(0.23,0.2,0.4));\n    mouth = max(mouth, -sdBox(p+vec3(0.0,-0.9,0.8),vec3(0.13,0.2,0.4)));\n    theDist = opU(theDist, vec2(mouth,1.0));//boca\n    \n    float mouthLateralThingL = sdBox(p+vec3(0.3+p.z*0.08,-0.75,0.6),vec3(0.07,0.07,0.4));\n    float mouthLateralThingR = sdBox(p+vec3(-0.3-p.z*0.08,-0.75,0.6),vec3(0.07,0.07,0.4));\n    theDist = opU(theDist, vec2(mouthLateralThingL,1.0));\n    theDist = opU(theDist, vec2(mouthLateralThingR,1.0));\n    \n    float cheekL = sdBox(p+vec3(0.3,-0.53,0.6),vec3(0.1,0.1,0.4));\n    cheekL = max(cheekL,-sdBox(p+vec3(0.4,-0.66,0.7),vec3(0.1,0.1,0.4)));\n    cheekL = min(cheekL,sdBox((p+vec3(0.26,-0.53,1.04))*rotationXY(vec2(0.0,-1.0)),vec3(0.03,0.03,0.05)));\n    float cheekR = sdBox(p+vec3(-0.3,-0.53,0.6),vec3(0.1,0.1,0.4));\n    cheekR = max(cheekR,-sdBox(p+vec3(-0.4,-0.66,0.7),vec3(0.1,0.1,0.4)));\n    cheekR = min(cheekR,sdBox((p+vec3(-0.26,-0.53,1.04))*rotationXY(vec2(0.0,1.0)),vec3(0.03,0.03,0.05)));\n    \n    theDist = opU(theDist, vec2(cheekL,1.0));\n    theDist = opU(theDist, vec2(cheekR,1.0));\n    \n    float chin = sdBox(p+vec3(0.0,-0.8,0.65),vec3(0.13,0.2,0.4));\n    chin = max(chin, -sdBox((p+vec3(0.0,-0.9,1.2))*rotationXY(vec2(-0.8,0.0)),vec3(0.5,0.13,0.4)));\n    theDist = opU(theDist, vec2(chin,2.0));\n    \n    float mandible = sdBox(p+vec3(0.0,-0.65,0.4),vec3(1.-p.y*0.9,0.2,0.2));\n    \n    theDist = opU(vec2(mandible,2.0),theDist);\n    \n    theDist = opU(theDist,K2SOEyes(p));\n    \n    return theDist;\n}\n\nvec2 K2SONeck(vec3 p ){\n\tfloat theDist = sdCappedCylinder(p+vec3(0.0,-1.0,0.0),vec2(0.25,0.7));\n    \n    return vec2(theDist,0.0);\n}\n\nvec2 K2SOBody(vec3 p ){\n    p += vec3(0.0,0.1,0.0);\n\tfloat theDist = sdEllipsoid(p+vec3(0.0,-3.5,-0.8), vec3(2.3,2.4,2.0) );\n    theDist = max(theDist, -(length(p+vec3(0.0,-0.85,0.3))-0.9));   \n    theDist = smin(theDist,-(length(p+vec3(5.0,-4.0,0.0))-3.0),-2.0); \n    theDist = smin(theDist,-(length(p+vec3(-5.0,-4.0,0.0))-3.0),-2.0);  \n    theDist = smin(theDist,length((p+vec3(0.0,-4.0,4.5))*vec3(7.0,1.0,1.0))-3.0,2.0);\n    theDist = max(theDist,-p.z-1.2);\n    \n    float shoulder = sdCappedCone( (p+vec3(2.8,-2.8,-0.7))*rotationXY(vec2(PI*0.5,-PI*0.5)), vec3(1.0,1.0,1.0) );\n    shoulder = max(shoulder, -(length(p+vec3(3.,-2.8,-0.7))-1.0));\n    shoulder = min(shoulder, sdCappedCone( (p+vec3(-2.8,-2.8,-0.7))*rotationXY(vec2(PI*0.5,PI*0.5)), vec3(1.0,1.0,1.0) ));\n    shoulder = max(shoulder, -(length(p+vec3(-3.,-2.8,-0.7))-1.0));\n    \n    theDist = smin(theDist, shoulder,8.0);\n    \n    return vec2(theDist,0.0);    \n}\n\nvec2 K2SOArms(vec3 p){\n    float theDist;\n    \n    vec3 armLP = p + vec3(-0.5,0.0,0.0);\n    float armL = sdCapsule(armLP,-vec3(2.8,-2.8,-0.7),-vec3(2.8,-5.0,-0.7),0.6);   \n    armL = max(armL, -armLP.x-3.3);\n    armL = max(armL, armLP.x+2.8);\n    \n    vec3 armRP = (p + vec3(0.5,0.0,0.0))*vec3(-1.0,1.0,1.0);\n    float armR = sdCapsule(armRP,-vec3(2.8,-2.8,-0.7),-vec3(2.8,-5.0,-0.7),0.6);   \n    armR = max(armR, -armRP.x-3.3);\n    armR = max(armR, armRP.x+2.8);\n    \n    theDist = min(armL,armR);\n    \n    return vec2(theDist,0.0);\n}\n\n\nvec2 K2SO( vec3 p ){\n    vec2 result = opU(K2SOHead(p*rotationXY(vec2(0.0,sin(iTime)))),K2SONeck(p));\n    result = opU(result,K2SOBody(p));\n    result = opU(result,K2SOArms(p));\n\treturn result;\n    \n}\n\nvec2 map( vec3 p) {\n    vec2 theMap = K2SO(p+vec3(1.8,0.0,0.0));\n    //theMap = opU(theMap,vec2(-p.y+10.0,4.0));\n    //theMap = opU(theMap,vec2(-p.y+10.0-texture(iChannel0,p.xz*0.01).x*5.0*clamp(-1.0-p.z*0.001,0.0,1.0),4.0));\n    \n    theMap = opU(theMap,vec2(-p.y+10.0-texture(iChannel0,p.xz*0.01).x*2.0+9999.0*step(50.0,p.z),4.0));\n    theMap = opU(theMap,vec2(-p.y+10.0,4.0));\n    \n    return theMap;\n}\n// ray marching\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\t\n    float depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n        vec2 distResult = map( origin + dir * depth );\n\t\tfloat dist = distResult.x;\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn vec2(depth,distResult.y);\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn vec2(end,-1.0);\n\t\t}\n\t}\n\treturn vec2(end,-1.0);\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\t\n\treturn normalize( vec3( -xy, -z ) );\n}\n\nvec3 normal( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).x - map( pos - dx ).x,\n\t\t\tmap( pos + dy ).x - map( pos - dy ).x,\n\t\t\tmap( pos + dz ).x - map( pos - dz ).x\t\t\t\n\t\t)\n\t);\n}\n\n\n\nfloat fresnel(vec3 n, vec3 d, float exp ){\n    return pow(1.0-dot(d,n),exp);\n}\n\nfloat calculateAmbientOcclusion(vec3 p, vec3 n, const float stepDistance){\n    #ifdef low\n    return 0.0;\n    #else\n    float ao = 0.0;\n    float difference = 0.0;\n    float depth = 0.0;\n    for(float i = 0.0; i < 10.0; i++){\n        ao += map(p+depth*n).x;\n        depth += stepDistance;\n    }\n    \n    return ao / 10.0;\n    #endif\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float k )\n{\n    #ifdef low\n    return 1.0;\n    #else\n    float t = 0.1;\n    float res = 1.0;\n    for ( int i = 0; i < 10; i++ ) \n    {\n        if(t>15.0)\n            return 1.0;\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        \n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n    #endif\n}\n\nvec3 material( vec3 p, vec3 n, vec3 eye ) {    \n    vec2 uv = p.xy;    \n    n += (texture(iChannel1,uv).xyz-vec3(0.5))*0.2;\n    vec3 baseColor = vec3(0.05,0.05,0.05);\n    //BaseColor\n    vec3 albedo = baseColor;    \n    \n    vec3 viewDir = normalize(eye-p);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float shadow = softshadow(p,sunDir,2.5);\n    \n    float ao = max(0.0,calculateAmbientOcclusion(p,n,0.1)*2.0);\n    float diffuse = max(0.0,dot(sunDir,n));\n    vec3 ambient = mix(vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.05),ao);\n    \n    return albedo*ambient*mix(1.0,4.0,diffuse*shadow)+diffuse*shadow*0.01;\n}\n\nvec3 material1( vec3 p, vec3 n, vec3 eye ) {    \n    vec2 uv = p.xy;    \n    n += (texture(iChannel1,uv).xyz-vec3(0.5))*0.2;\n    vec3 baseColor = vec3(0.04,0.04,0.04);\n    //BaseColor\n    vec3 albedo = baseColor;    \n    \n    vec3 viewDir = normalize(eye-p);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float shadow = softshadow(p,sunDir,2.5);\n    \n    float ao = max(0.0,calculateAmbientOcclusion(p,n,0.1)*2.0);\n    float diffuse = max(0.0,dot(sunDir,n));\n    vec3 ambient = mix(vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.01),ao);\n    \n    return albedo*ambient*mix(0.0,4.0,diffuse*shadow)+diffuse*shadow*0.003;\n}\n\nvec3 material2( vec3 p, vec3 n, vec3 eye ) {    \n    vec2 uv = p.xy;    \n    n += (texture(iChannel1,uv).xyz-vec3(0.5))*0.2;\n    vec3 baseColor = vec3(0.04,0.04,0.04);\n    //BaseColor\n    vec3 albedo = baseColor;    \n    \n    vec3 viewDir = normalize(eye-p);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float shadow = softshadow(p,sunDir,2.5);\n    \n    float ao = max(0.0,calculateAmbientOcclusion(p,n,0.1)*2.0);\n    float diffuse = max(0.0,dot(sunDir,n));\n    vec3 ambient = mix(vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.01),ao);\n    \n    return albedo*ambient*mix(0.0,4.0,diffuse*shadow)+diffuse*shadow*0.015;\n}\n\nvec3 material3( vec3 p, vec3 n, vec3 eye ) {    \n    vec2 uv = p.xy;    \n    n += (texture(iChannel1,uv).xyz-vec3(0.5))*0.2;\n    vec3 baseColor = vec3(0.04,0.04,0.04);\n    //BaseColor\n    vec3 albedo = baseColor;    \n    \n    vec3 viewDir = normalize(eye-p);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float shadow = softshadow(p,sunDir,2.5);\n    \n    float ao = max(0.0,calculateAmbientOcclusion(p,n,0.1)*2.0);\n    float diffuse = max(0.0,dot(sunDir,n));\n    vec3 ambient = mix(vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.01),ao);\n    \n    return albedo*ambient*mix(0.0,4.0,diffuse*shadow)+diffuse*shadow*0.15*mix(0.1,1.0,sin(p.x*100.0)*0.5+0.5);\n}\n\nvec3 terrain( vec3 p, vec3 n, vec3 eye ) {    \n\tvec2 uv = p.xy;    \n    n += (texture(iChannel1,uv).xyz-vec3(0.5))*0.2;\n    vec3 baseColor = vec3(0.04,0.04,0.04);\n    //BaseColor\n    vec3 albedo = baseColor;    \n    \n    vec3 viewDir = normalize(eye-p);    \n    vec3 fresnelColor = vec3(0.4,0.3,0.7) * fresnel(n,viewDir,2.0);    \n    \n    float shadow = softshadow(p,sunDir,2.5);\n    \n    float ao = max(0.0,calculateAmbientOcclusion(p,n,0.1)*2.0);\n    float diffuse = max(0.0,dot(sunDir,n));\n    vec3 ambient = mix(vec3(0.0,0.0,0.0),vec3(0.6,0.4,0.1),ao);\n    \n    return albedo*ambient*mix(0.0,4.0,diffuse*shadow)+diffuse*shadow*0.06;\n}\n\nvec3 Background(vec3 dir){\n\tfloat grad = (dot(dir,vec3(0.0,1.0,0.0))+1.0)*0.5;\n    return mix(vec3(0.6,0.6,0.8),vec3(0.1,0.2,0.7),grad);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\t\n    \n    //sunDir = normalize(vec3(1.0,-1.0,1.0))*rotationXY(vec2(0.0,iTime));\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 8.0 );\n\n\t// rotate camera\n    #if cameraMove\n    mat3 rot = rotationXY( vec2(iMouse.y*0.05,iMouse.x*0.05));\n    #else\n\tmat3 rot = rotationXY( vec2(0.3,PI));////vec2(-0.2, iTime/2.0 ) );\n    #endif\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n    vec3 bg = Background(dir);\n    \n\t// ray marching\n    vec2 rayResult = ray_marching( eye, dir, 0.0, clip_far );\n\tfloat depth = rayResult.x;\n\tif ( depth >= clip_far ) {        \n\t\tfragColor = vec4(bg,depth);//Background color\n        return;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = normal( pos );\n    vec3 fogColor = vec3(bg);\n    \n    if( rayResult.y == 0.0 )\n    \tfragColor = vec4(material( pos, n, eye ), depth);\n    else if(rayResult.y == 1.0 )\n        fragColor = vec4(material1( pos, n, eye ), depth);\n    else if(rayResult.y == 2.0 )\n        fragColor = vec4(material2( pos, n, eye ), depth);\n    else if(rayResult.y == 3.0 )\n        fragColor = vec4(material3( pos, n, eye ), depth);\n    else if(rayResult.y == 4.0 )\n        fragColor = vec4(terrain( pos, n, eye ), depth);\n    \n}","name":"Buf A","description":"","type":"buffer"}]}