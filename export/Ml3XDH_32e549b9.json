{"ver":"0.1","info":{"id":"Ml3XDH","date":"1479351805","viewed":302,"name":"Latticed","username":"VoidChicken","description":"In an infinite lattice. Can't. Find. A. Way. Out!!!\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","distancefield","raymarch","texture","distance","field","rotation","chicken","lattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Creative Commons Attribution-ShareAlike License 4.0 to VoidChicken\n//by VoidChicken 2016\n//Comment out line below for cylindrical lattice\n#define USE_CUBOID_LATTICE\n#define pi 3.14159265358979\nfloat R(float x) {return x+fract(x)<.5?0.:1.;}\nfloat cuboid ( vec3 p, vec3 b ) {\n\tfloat f = 0.;\n    vec3 a = abs(p)-b;\n    f = max(a.x, max(a.y, a.z));\n    \n    return f;\n}\n\nfloat lattice( vec3 p ) {\n\n    float f = 0.;\n    float r = .1;\n    float b = cuboid(p, vec3(1));\n    #ifdef USE_CUBOID_LATTICE\n    f = max(abs(p.x)-r, abs(p.y)-r);\n    f = min(f, max(abs(p.x)-r, abs(p.z)-r));\n    f = min(f, max(abs(p.y)-r, abs(p.z)-r));\n    #else\n        f = length(p.xy)-r;\n    \tf = min(f, length(p.xz)-r);\n    \tf = min(f, length(p.yz)-r);\n    #endif\n    return max(f, b);//+(length(p)-1.)/5.;\n    \n}\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\nfloat map ( vec3 p ) {\n\n    p=fract(p)-.5;\n\treturn lattice(p);    \n}\nvec3 calcNormal( in vec3 x )\n{\n    vec2 e = vec2( .001, 0.0 );\n    return normalize( vec3( map(x+e.xyy) - map(x-e.xyy),\n                            map(x+e.yxy) - map(x-e.yxy),\n                            map(x+e.yyx) - map(x-e.yyx) ) );\n}\nfloat trace (vec3 o, vec3 d) {\n\tfloat t = 0.;\n    for (int i = 0; i < 64; ++i) {\n        float f = map(o+t*d);\n        \n        if (t>50.||f<.002) break;\n        t+=f;\n    }\n    return t;\n}\n\nvec3 uniperp ( vec3 n ) {\n\treturn n.yzx+n;    \n}\nvec3 stx (vec2 u) {\n\treturn texture(iChannel0,u).rgb;    \n}\nvec3 render( vec2 uv ) {\n    vec3 col = vec3(0);\n\tvec3 ro = vec3 (0,0, 4.);\n    ro*=rotationMatrix(vec3(-1,0,0),iTime/5.);\n    vec3 rd = vec3 (vec2(1, iResolution.y/iResolution.x)*(uv*2.-1.), 1);\n    rd=normalize(rd);\n    rd*=rotationMatrix(vec3(0,0,1),iTime);\n    rd*=rotationMatrix(vec3(1,1,0),iTime/5.);\n    float t = trace( ro, rd );\n    vec3 i = ro+rd*t;\n    float m = map(i);\n    if (m<.2) {\n        \n         vec3 l = vec3 (0,0, 4.);\n    \tl*=rotationMatrix(vec3(-1,0,0),iTime/5.+.314);\n        \n        vec2 uv = vec2(0);\n        vec3 n = calcNormal(i);\n        \n        uv=vec2(dot(i,uniperp(n)),dot(i,cross(uniperp(n), n)));\n        float u = .3*distance(l, i);\n        u=sqrt(u);\n        u/=dot(n,normalize(l-i));\n    \tcol = (stx(uv))*(1./t)/(u);    \n    }    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 col = vec3(0);\n\t\n    vec3 pxl = vec3(1./iResolution.xy,0);\n   \t\n    col+=render(uv);\n    col+=render(uv+pxl.xz);\n    col+=render(uv+pxl.xy);\n    col+=render(uv+pxl.zy);\n    col/=4.;\n    fragColor = 1.-exp(-(vec4(col*(1.-length(uv-.5)),1.0)*sin(clamp(iTime-.25, 0., pi/2.)))*.6);\n}","name":"Image","description":"","type":"image"}]}