{"ver":"0.1","info":{"id":"mdsfDM","date":"1688855386","viewed":47,"name":"Linear systems 2x2 (Cramer)","username":"Envy24","description":".","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["linear","solution","cramers","rule","systems"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 4. )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat cells(vec2 NDC)\n{\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_line(NDC, 0.), horizontal_line(NDC, 0.)) +\n        max(vertical_line(NDC, 0.), horizontal_line(NDC, 0.));\n}\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// Solve by Kramer rule.\nvec2 solve_linear_system22(vec3 r1, vec3 r2) // line-line intersection\n{\n    float delta = determinant(\n        mat2(\n            r1.x, r2.x,\n            r1.y, r2.y));\n    float inv = \n        delta == 0. ? // No solution (intersection)?\n            0. :\n            1. / delta; \n    \n    float delta1 = determinant(\n        mat2(\n            r1.z, r2.z,\n            r1.y, r2.y));\n            \n    float delta2 = determinant(\n        mat2(\n            r1.x, r2.x,\n            r1.z, r2.z));\n    \n    return vec2(delta1, delta2) * inv;\n}\nvec2 solve_linear_system22(vec2 c1, vec2 c2, vec2 c3)\n{\n    float delta = determinant(mat2(c1, c2)),\n          delta1 = determinant(mat2(c3, c2)),           \n          delta2 = determinant(mat2(c1, c3)),\n          inv = \n              delta == 0. ? // No solution (intersection)?\n                  0. :\n                  1. / delta; \n    \n    return vec2(delta1, delta2) * inv;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 5., vec2(0), true);\n    \n    vec3 color = vec3(1);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n         color -= cells(NDC)*0.2;\n    \n    float T = iTime * 0.5;\n    \n    /* Linear system with 2 unknowns. */\n    vec3 r1 = H3to3(vec3(-T, T*2., T*3.));  // ax + by = c     line1: y = (c - ax) / b = -a/b * x + c/b = mx + k\n    vec3 r2 = H3to3(vec3(T, -T*4., -T*5.)); // dx + ey = f     line2: y = (f - dx) / e = ...\n    /**/\n\n    /* Lines */\n    float m1 = -r1.x / r1.y, k1 = r1.z / r1.y,\n          m2 = -r2.x / r2.y, k2 = r2.z / r2.y;\n    color = mix(color, vec3(1,0,0), SMAA(lineSDF_L2(NDC, m1, k1, 0.01)));\n    color = mix(color, vec3(0,0,1), SMAA(lineSDF_L2(NDC, m2, k2, 0.01)));\n    /* */\n    \n    /* Solution (variant 1) */\n    vec2 xy = solve_linear_system22(r1, r2);\n    color = mix(color, vec3(0,1,0), SMAA(diskSDF_L2(NDC, xy, 0.2)));\n    /* */\n    \n    /* Solution (variant 2) */\n    vec2 c1 = vec2(r1.x, r2.x), c2 = vec2(r1.y, r2.y), c3 = vec2(r1.z, r2.z),\n         XY = solve_linear_system22(c1, c2, c3);\n    color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, XY, 0.1)));\n    /* */\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\n//https://www.shadertoy.com/view/fsGcRc\nfloat lineSDF_L2(vec2 NDC, float m, float k, float r)\n{\n    float x = (m*(NDC.y-k)+NDC.x) / (m*m + 1.);  // root of x+x*m^2+mk-mb-a=0\n\n    vec2 C = vec2(x, m*x+k);                     // Closest point on line y=mx+k to point NDC\n    \n    return length(C - NDC) - r;\n}\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n/* \n    Returns random vec3([-1.0; 1.0], [-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec3 vector3HashUI32(\n    const uint x,\n    const uint y,\n    const uint z)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 1200u;\n    const uint entropy1 = 4500u;\n    const uint entropy2 = 6700u;\n    const uint entropy3 = 8900u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = z * entropy3 * entropy2 + y * entropy2 + x;\n    uint value1 = y * entropy3 * entropy2 + x * entropy2 + z;\n    uint value2 = x * entropy3 * entropy2 + z * entropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += entropy1; value0 *= 445593459u; value0 ^= entropy0;\n    value1 += entropy1; value1 *= 445593459u; value1 ^= entropy0;\n    value2 += entropy1; value2 *= 445593459u; value2 ^= entropy0;\n\n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return vec3(\n        float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n        float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f,\n        float(value2 * value2 * value2) * 4.6566128730773926e-10f - 1.0f);\n}\n#define H3to3(P) ( vector3HashUI32(uint(P.x), uint(P.y), uint(P.z)) )","name":"Common","description":"","type":"common"}]}