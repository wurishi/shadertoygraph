{"ver":"0.1","info":{"id":"DdSBDy","date":"1703847860","viewed":583,"name":"Moving around scene with TAA","username":"morimea","description":"Simple scene moving around.\nPathtracer with reprojection and some volumetric shadows and TAA.\n\nPrerendered 360-youtube video - [url]https://youtu.be/v8O2ZEeMiRE[/url]\n","likes":41,"published":1,"flags":48,"usePreview":1,"tags":["procedural","antialiasing","repetition","pathtracer","reprojection","temporal","taa","agx"],"hasliked":0,"parentid":"dldGWj","parentname":"TEMPLATE 3d pathtracer TAA"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Created by Danil (2023+) https://github.com/danilw\n// License - License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/DdSBDy\n\n\n// For Quality:\n// increase number of rays in Common \n\n// Control:\n// WASD or arrows to move, mouse click to rotate camera\n// move_SUN_circle_inf in Common to keep Sun in same position when move_rounds\n\n// Camera collision - remove #define move_rounds in Common, or Collision_floor line 78 in BufA\n// Clouds rendered in BufD - this why on camera rotate clouds with delay movement.\n// Other options in Common.\n\n// using:\n// TAA from https://www.shadertoy.com/view/DsfGWX\n// RayTracing Radial Repetition https://www.shadertoy.com/view/stKcWD\n// clouds from https://www.shadertoy.com/view/DtBGR1\n// Agx from https://www.shadertoy.com/view/cd3XWr\n\n// this pathtracer template https://www.shadertoy.com/view/dldGWj\n\n\n\n// remember to set mipmaps to iChannel3 in Image to use bloom\n#define use_bloom\n#ifdef use_bloom\nmat3 gaussianFilter = mat3(41, 26, 7,\n                           26, 16, 4,\n                           7,  4,  1) / 273.;\n// bloom\nvec3 bloom(float scale, float threshold, vec2 fragCoord, sampler2D ich){\n    // this does not alway work\n    // Shadertoy allocate mipmap once and forever - no way to know if they exit actually\n    // maybe this is another webbrower WebGL implementation feature/bug idk\n    if(textureSize(ich,1).x<10) return vec3(0.);\n    float logScale = log2(scale);\n    vec3 bloom = vec3(0);\n    for(int y = -2; y <= 2; y++)\n        for(int x = -2; x <= 2; x++)\n            bloom += gaussianFilter[abs(x)][abs(y)] * textureLod(ich, (fragCoord+vec2(x, y)*scale)/iResolution.xy, logScale).rgb;\n    return max(bloom - vec3(threshold), vec3(0.));\n}\n#endif\n\n#ifdef use_dynamic_TAA\n#ifdef enable_volume\n// from https://www.shadertoy.com/view/Xltfzj\nvec4 GaussianBlur(in vec2 fragCoord, sampler2D ich)\n{\n    float Directions = 6.0;\n    float Quality = 3.0;\n    float Size = 3.0;\n    vec2 Radius = Size/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 Color = texture(ich, uv);\n    for( float d=0.0; d<TAU; d+=TAU/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.001; i+=1.0/Quality)\n        {\n\t\t\tColor += textureLod( ich, uv+vec2(cos(d),sin(d))*Radius*i, 0.);\t\t\n        }\n    }\n    Color /= Quality * Directions+1.;\n    return Color;\n}\n#endif\n#endif\n\n// volume raymarch mix color\n//----------------------------------------------\n#ifdef enable_volume\n\nvec3 raymarchVolume_image(vec3 backGround, float absorb, vec3 sunColor, float lDotV, float fogLitPercent){\n    \n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    vec3 c_fogColorLit = backGround+sunColor * phaseMie*0.5+0.0025*(0.5+sunColor*0.5);\n    const vec3 c_fogColorUnlit = vec3(0.);\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent*fogLitPercent*fogLitPercent);\n    return mix(fogColor, backGround, absorb);\n}\n#endif\n//----------------------------------------------\nvec3 color2agx(vec3 col);\nvec4 toLinear(vec4 sRGB);\nvec3 srgb_encode(vec3 v);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n#ifdef move_rounds\n    float l_t = load(LOCAL_T,iChannel0);\n    rtimer = l_t;\n    float l_t_last = load(LOCAL_T_last,iChannel0);\n    rtimer_last = l_t_last;\n#ifdef move_SUN_circle_inf\n    lightDir.xz=lightDir.xz*MD(-rtimer*rspd);\n#endif\n#endif\n    vec2 fc = fragCoord.xy;\n    vec3 texture_color = vec3(1.);\n#ifdef use_dynamic_TAA\n    vec3 color = texelFetch(iChannel3, ivec2(fc), 0).rgb;\n#else\n    vec3 color = texelFetch(iChannel2, ivec2(fc), 0).rgb;\n#ifdef enable_textures\n    texture_color = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fc), 0).a);\n#endif\n#endif\n    \n#ifndef enable_textures\n#ifdef enable_volume\n    \n    // unjittering volume fog\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    if(load(INPUT0,iChannel0)<1.) halton_px_shift =vec2(0.);\n\n#ifdef use_dynamic_TAA\n#ifdef add_clouds\n    float absorb = GaussianBlur(fc-halton_px_shift, iChannel2).a;\n#else\n    //float absorb = texelFetch(iChannel3, ivec2(fc), 0).a;\n    float absorb = GaussianBlur(fc, iChannel3).a; //additional Blur on top of TAA\n#endif\n    float fogLitPercent = GaussianBlur(fc-halton_px_shift, iChannel1).a;\n#else\n    float absorb = textureLod(iChannel2, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n    float fogLitPercent = textureLod(iChannel1, vec2(fc-halton_px_shift)/iResolution.xy, 0.).a;\n#endif\n\n    vec2 uv = (fragCoord)/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n\n    vec3 sunColor = calculateSunColor(lightDir.y);\n    float lDotV = dot(rd, lightDir);\n    color = raymarchVolume_image(color, absorb, sunColor, lDotV, fogLitPercent);\n#endif\n#endif\n    vec3 blom = vec3(0.);\n#ifdef use_bloom\n#ifdef use_dynamic_TAA\n    blom += bloom(.015 * iResolution.y, 0.002,fragCoord,iChannel3)*0.05;\n    blom += bloom(.05 * iResolution.y, 0.002,fragCoord,iChannel3)*0.025;\n#else\n    //blom += bloom(.015 * iResolution.y, 0.002,fragCoord,iChannel2)*0.05;\n    //blom += bloom(.05 * iResolution.y, 0.002,fragCoord,iChannel2)*0.025;\n#endif\n#endif\n    \n    //color = ACESFilm(color*texture_color+blom);\n    //color = srgb_encode(color);\n    \n    //color = toLinear(vec4(color, 1.0)).rgb;\n    color = color2agx(color*texture_color+blom);\n    \n\tfragColor = vec4(color, 1.0 );\n   \n}\n\nvec3 srgb_encode(vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,step(.0031308,v));\n}\n\n\n\n\n// Agx from https://www.shadertoy.com/view/cd3XWr\n#define AGX_LOOK 2\n\n// AgX\n// ->\n\n// Mean error^2: 3.6705141e-06\nvec3 agxDefaultContrastApprox(vec3 x) {\n  vec3 x2 = x * x;\n  vec3 x4 = x2 * x2;\n  \n  return + 15.5     * x4 * x2\n         - 40.14    * x4 * x\n         + 31.96    * x4\n         - 6.868    * x2 * x\n         + 0.4298   * x2\n         + 0.1191   * x\n         - 0.00232;\n}\n\nvec3 agx(vec3 val) {\n  const mat3 agx_mat = mat3(\n    0.842479062253094, 0.0423282422610123, 0.0423756549057051,\n    0.0784335999999992,  0.878468636469772,  0.0784336,\n    0.0792237451477643, 0.0791661274605434, 0.879142973793104);\n    \n  const float min_ev = -12.47393f;\n  const float max_ev = 4.026069f;\n\n  // Input transform\n  val = agx_mat * val;\n  \n  // Log2 space encoding\n  val = clamp(log2(val), min_ev, max_ev);\n  val = (val - min_ev) / (max_ev - min_ev);\n  \n  // Apply sigmoid function approximation\n  val = agxDefaultContrastApprox(val);\n\n  return val;\n}\n\nvec3 agxEotf(vec3 val) {\n  const mat3 agx_mat_inv = mat3(\n    1.19687900512017, -0.0528968517574562, -0.0529716355144438,\n    -0.0980208811401368, 1.15190312990417, -0.0980434501171241,\n    -0.0990297440797205, -0.0989611768448433, 1.15107367264116);\n    \n  // Undo input transform\n  val = agx_mat_inv * val;\n  \n  // sRGB IEC 61966-2-1 2.2 Exponent Reference EOTF Display\n  //val = pow(val, vec3(2.2));\n\n  return val;\n}\n\nvec3 agxLook(vec3 val) {\n  const vec3 lw = vec3(0.2126, 0.7152, 0.0722);\n  float luma = dot(val, lw);\n  \n  // Default\n  vec3 offset = vec3(0.0);\n  vec3 slope = vec3(1.0);\n  vec3 power = vec3(1.0);\n  float sat = 1.0;\n \n#if AGX_LOOK == 1\n  // Golden\n  slope = vec3(1.0, 0.9, 0.5);\n  power = vec3(0.8);\n  sat = 0.8;\n#elif AGX_LOOK == 2\n  // Punchy\n  slope = vec3(1.0);\n  power = vec3(1.35, 1.35, 1.35);\n  sat = 1.4;\n#endif\n  \n  // ASC CDL\n  val = pow(val * slope + offset, power);\n  return luma + sat * (val - luma);\n}\n\n// <-\n\nvec4 toLinear(vec4 sRGB) {\n  bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n  vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n  vec4 lower = sRGB/vec4(12.92);\n  \n  return mix(higher, lower, cutoff);\n}\n\nvec3 color2agx(vec3 col)\n{\n  //col = toLinear(vec4(col, 1.0)).rgb;\n\n  col = agx(col);\n  col = agxLook(col);\n  col = agxEotf(col);\n\n  return col;\n}\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// this exist just because Shadertoy has only 4 buffers\n\n// r is OBJ_ID\n// g is current depth\n// b is last depth\n\n// camera control use 1 alpha pixel per value\n\n// also in alpha saved noise\n// noise everywhere except MEMORY_BOUNDARY and top right pixel\n\n#define keyboard_texture iChannel3\n\n#ifdef move_rounds\nconst vec3 start_pos = vec3(-49., 6.5, 0.); //do not edit this\nconst vec3 start_pos_edit = vec3(1.7, .1, 0.); //edit this\n#else\nconst vec3 start_pos = vec3(-49., 6.5, 0.1); //edit this\n#endif\nconst vec2 start_mouse = vec2(-0.05, -0.25);\n\nconst float speed = 2.5;\n\n\nvoid store(ivec2 P, ivec2 ipx, float V, inout vec4 fc){ if(ipx==P) fc.a = V;}\n\nfloat key(int K, sampler2D kb){return step(0.5, texelFetch(kb, ivec2(K, 0), 0).x);}\n\n\n\nconst int Key_Backspace = 8, Key_Tab = 9, Key_Enter = 13, Key_Shift = 16, Key_Ctrl = 17, \nKey_Alt = 18, Key_Pause = 19, Key_Caps = 20, Key_Escape = 27, Key_Space = 32, \nKey_PageUp = 33, Key_PageDown = 34, Key_End = 35,Key_Home = 36, Key_LeftArrow = 37, \nKey_UpArrow = 38, Key_RightArrow = 39, Key_DownArrow = 40, Key_Insert = 45, \nKey_Delete = 46, Key_0 = 48, Key_1 = 49, Key_2 = 50, Key_3 = 51, Key_4 = 52,\nKey_5 = 53, Key_6 = 54, Key_7 = 55, Key_8 = 56, Key_9 = 57, Key_A = 65, Key_B = 66, \nKey_C = 67, Key_D = 68, Key_E = 69, Key_F = 70, Key_G = 71, Key_H = 72,Key_I = 73, \nKey_J = 74, Key_K = 75, Key_L = 76, Key_M = 77, Key_N = 78, Key_O = 79, Key_P = 80,\nKey_Q = 81, Key_R = 82, Key_S = 83, Key_T = 84, Key_U = 85,Key_V = 86, Key_W = 87, \nKey_X = 88, Key_Y = 89, Key_Z = 90, Key_LeftWindow = 91, Key_RightWindows = 92, \nKey_Select = 93, Key_Numpad0 = 96, Key_Numpad1 = 97, Key_Numpad2 = 98, Key_Numpad3 = 99,\nKey_Numpad4 = 100, Key_Numpad5 = 101, Key_Numpad6 = 102, Key_Numpad7 = 103, \nKey_Numpad8 = 104, Key_Numpad9 = 105, Key_NumpadMultiply = 106, Key_NumpadAdd = 107,\nKey_NumpadSubtract = 109, Key_NumpadPeriod = 110, Key_NumpadDivide = 111, Key_F1 = 112,\nKey_F2 = 113, Key_F3 = 114, Key_F4 = 115, Key_F5 = 116, Key_F6 = 117, Key_F7 = 118,\nKey_F8 = 119, Key_F9 = 120, Key_F10 = 121, Key_F11 = 122, Key_F12 = 123, \nKey_NumLock = 144, Key_ScrollLock = 145,Key_SemiColon = 186, Key_Equal = 187, \nKey_Comma = 188, Key_Dash = 189, Key_Period = 190, Key_ForwardSlash = 191, \nKey_GraveAccent = 192, Key_OpenBracket = 219, Key_BackSlash = 220, \nKey_CloseBraket = 221, Key_SingleQuote = 222;\n\n\n\nvec2 KeyboardInput(sampler2D kb) {\n    ivec4 inputs1 = ivec4(Key_UpArrow, Key_DownArrow, Key_RightArrow, Key_LeftArrow); //ARROWS\n    ivec4 inputs2 = ivec4(Key_W, Key_S, Key_D, Key_A);//WASD\n    //ivec4 inputs2 = ivec4(Key_E, Key_D, Key_F, Key_S);//ESDF\n    \n\tvec2 i = vec2(max(key(inputs1.z,kb),key(inputs2.z,kb))   - max(key(inputs1.w,kb),key(inputs2.w,kb)), \n                  max(key(inputs1.x,kb),key(inputs2.x,kb)) - max(key(inputs1.y,kb),key(inputs2.y,kb)));\n    \n    float n = abs(abs(i.x) - abs(i.y));\n    return i * (n + (1.0 - n)*0.707106);\n}\n\nvec3 CameraDirInput(vec2 vm, sampler2D kb) {\n    vec2 m = vm;\n    m.y = -m.y;\n    \n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    \n    return (rotY * rotX) * vec3(KeyboardInput(kb), 0.0).xzy;\n}\n\nvoid Collision_floor(vec3 prev, inout vec3 p) {\n    //return;\n    if(length(p.xz-vec2(49.,0.))>49.8){\n        float a = angle2d(prev.xz-vec2(49.,0.),vec2(0.,0.));\n        vec2 ta = -(vec2(min(length(prev.xz-vec2(49.,0.)),50.),0.)*MD(a)-vec2(49.,0.));\n        p.xz=ta;\n        p.y=prev.y;\n    }\n    if(length(p.xz-vec2(49.,0.))<44.3){\n        float a = angle2d(prev.xz-vec2(49.,0.),vec2(0.,0.));\n        vec2 ta = -(vec2(max(length(prev.xz-vec2(49.,0.)),44.3),0.)*MD(a)-vec2(49.,0.));\n        p.xz=ta;\n        p.y=prev.y;\n    }\n    \n    if (p.y < -1.05) p = vec3(prev.xz, max(-1.05, prev.y)).xzy;\n    if (p.y > 2.85) p = vec3(prev.xz, min(2.85, prev.y)).xzy;\n}\n\nvec2 render_new_minDist(in vec2 fragCoord, vec2 halton_px_shift, vec3 ro, vec2 m) {\n\n    vec2 fc=fragCoord.xy;\n    fragCoord.xy += halton_px_shift;\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 rd;\n    SetCamera_m(uv, m, rd, iResolution.xy);\n    \n    HitInfo hit;\n\tbool rayHit = minDist(ro, rd, hit);\n    \n    return vec2(float(hit.obj_type)+0.5,hit.t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    float l_t = load(LOCAL_T,iChannel0);\n    float l_t_last = load(LOCAL_T_last,iChannel0);\n    float llmc = load(LMC,iChannel0);\n    \n#ifdef move_rounds\n    if (iMouse.z>0.0){llmc+=-2.5*iTimeDelta*llmc-0.001;}else{llmc+=1.25*iTimeDelta*llmc+0.001;}\n    llmc=clamp(llmc,0.,1.);\n    l_t_last = l_t;\n    rtimer_last = l_t_last;\n    l_t+=iTimeDelta*llmc;\n    rtimer = l_t;\n#ifdef move_SUN_circle_inf\n    lightDir.xz=lightDir.xz*MD(-rtimer*rspd);\n#endif\n#endif\n\n    ivec2 ipx = ivec2(fragCoord);\n    \n    vec2 res_l = vec2(load(RES_LAST0,iChannel0),load(RES_LAST1,iChannel0));\n    bool input_registered = false;\n    bool res_ch = ivec2(res_l)!=ivec2(iResolution.xy);\n    input_registered = res_ch;\n    // resolution control\n    input_registered = input_registered||(load(ivec2(iResolution.xy)-1, iChannel0))<0.5;\n    //input_registered=true;\n    bool input_registered_TMP = input_registered;\n    \n    \n    vec3 target      = vec3(load(TARGET0, iChannel0),load(TARGET1, iChannel0),load(TARGET2, iChannel0));   \n#ifdef move_rounds\n    vec3 htarget     = vec3(load(HTARGET0, iChannel0),load(HTARGET1, iChannel0),load(HTARGET2, iChannel0));   \n#endif\n    vec3 position    = vec3(load(POSITION0, iChannel0),load(POSITION1, iChannel0),load(POSITION2, iChannel0));\n    vec3 position_l = position;\n    \n    vec2 pm          = vec2(load(PMOUSE0, iChannel0),load(PMOUSE1, iChannel0));\n    vec3 vm          = vec3(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0),load(VMOUSE2, iChannel0));\n    \n    bool is_init = load(INIT0, iChannel0)<1.;\n    if (iFrame == 0 || is_init) \n    {\n        target = start_pos;\n#ifdef move_rounds\n        htarget = start_pos_edit;\n        position = start_pos+start_pos_edit;\n        position_l = start_pos+start_pos_edit;\n#else\n        position = start_pos;\n        position_l = start_pos;\n#endif\n        pm = start_mouse;\n        vm.xy = start_mouse.xy;\n    }\n#ifdef move_rounds\n    vec3 ptarget = htarget;\n    htarget += CameraDirInput(vm.xy, keyboard_texture) * min(iTimeDelta,1./10.) * speed;\n    Collision_floor(ptarget, htarget);\n#else\n    vec3 ptarget = target;\n    target += CameraDirInput(vm.xy, keyboard_texture) * min(iTimeDelta,1./10.) * speed;\n    //Collision_floor(ptarget, target);\n#endif\n    \n    vec3 lp = position;\n#ifdef move_rounds\n    target.xz = vec2(-49.,0.)*MD(-rtimer*rspd);\n    target.y = 6.5+htarget.y;\n    target.xz+=htarget.xz*MD(-rtimer*rspd);\n#endif\n    position += (target - position) * min(iTimeDelta,1./10.) * 5.0;\n\n    \n    \n    if(length(abs(position)-abs(lp))>0.0001)input_registered=true;\n    \n    vec3 ro = position;\n    vec2 im = vec2(0.);\n    \n    if (iMouse.z>0.0) {\n        vec2 tpm = pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y;\n        input_registered=input_registered||(abs(tpm.x-vm.x)>.5/iResolution.y||abs(tpm.y-vm.y)>.5/iResolution.y);\n    \tim = tpm;\n    }\n    else {\n    \tim = vm.xy;\n    }\n\n#ifdef use_dynamic_TAA\n    vec2 halton = (halton(iFrame % 16 + 1) - 0.5f);\n#else\n    vec2 halton = input_registered?vec2(0.):halton(iFrame % 16 + 1) - 0.5f;\n#endif\n    \n    fragColor.rg = render_new_minDist(fragCoord, halton, ro, im);\n    fragColor.b = texelFetch(iChannel0,ipx,0).y;\n    fragColor.a = texelFetch(iChannel0,ipx,0).a;\n    \n    if(ipx==ivec2(iResolution.xy)-1){\n        fragColor.a=2.; // resolution control for pause case\n        return;\n    }\n//--------------------\n    \n    \n    float bnoise=fragColor.a;\n    if(input_registered_TMP||iFrame==0)\n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))){bnoise=Bnoise(fragCoord+iDate.w*0.01);fragColor.a=bnoise;}\n    \n    if (any(greaterThan(ipx, MEMORY_BOUNDARY))) return;\n    \n    vec2 vm_l = vec2(load(VMOUSE0, iChannel0),load(VMOUSE1, iChannel0));\n    \n    if (iFrame == 0 || is_init) {\n        vm_l=start_mouse;\n#ifdef move_rounds\n        vec3 position_l = start_pos+start_pos_edit;\n        vec3 start_pos_t = start_pos+start_pos_edit;\n#else\n        vec3 position_l = start_pos;\n        vec3 start_pos_t = start_pos;\n#endif\n        store(POSITION0, ipx, start_pos_t.x, fragColor); // ro\n        store(POSITION1, ipx, start_pos_t.y, fragColor);\n        store(POSITION2, ipx, start_pos_t.z, fragColor);\n        store(POSITION_last0, ipx, position_l.x, fragColor); // last_ro\n        store(POSITION_last1, ipx, position_l.y, fragColor);\n        store(POSITION_last2, ipx, position_l.z, fragColor);\n        store(TARGET0, ipx, start_pos_t.x, fragColor); // mouse look\n        store(TARGET1, ipx, start_pos_t.y, fragColor);\n        store(TARGET2, ipx, start_pos_t.z, fragColor);\n#ifdef move_rounds\n        store(HTARGET0, ipx, start_pos_edit.x, fragColor); // mouse look\n        store(HTARGET1, ipx, start_pos_edit.y, fragColor);\n        store(HTARGET2, ipx, start_pos_edit.z, fragColor);\n#endif\n        store(VMOUSE0, ipx, start_mouse.x, fragColor); // virtual mouse (rotation_mat)\n        store(VMOUSE1, ipx, start_mouse.y, fragColor);\n\n        store(VMOUSE_last0, ipx, vm_l.x, fragColor); // last virtual mouse\n        store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n        store(PMOUSE0, ipx, start_mouse.x, fragColor); // real mouse pos\n        store(PMOUSE1, ipx, start_mouse.y, fragColor);\n        store(INIT0, ipx, 2., fragColor); // is_init(0 false, 2 true)\n        store(RES_CHANGE, ipx, 0., fragColor); // 0 true 1 false\n        store(INPUT0, ipx, 2., fragColor); // key_pressed(0 false, 2 true) \n        store(RES_LAST0, ipx, iResolution.x, fragColor); // xy = last_resolution\n        store(RES_LAST1, ipx, iResolution.y, fragColor);\n        store(HALTON0, ipx, halton.x, fragColor);\n        store(HALTON1, ipx, halton.y, fragColor);\n        store(HALTON_last0, ipx, 0., fragColor);\n        store(HALTON_last1, ipx, 0., fragColor);\n        store(LOCAL_T, ipx, 0., fragColor);\n        store(LOCAL_T_last, ipx, 0., fragColor);\n        store(LMC, ipx, 0., fragColor);\n        return;\n    }\n    \n    store(LMC, ipx, llmc, fragColor);\n    store(LOCAL_T, ipx, l_t, fragColor);\n    store(LOCAL_T_last, ipx, l_t_last, fragColor);\n    store(TARGET0, ipx, target.x, fragColor);\n    store(TARGET1, ipx, target.y, fragColor);\n    store(TARGET2, ipx, target.z, fragColor);\n#ifdef move_rounds\n    store(HTARGET0, ipx, htarget.x, fragColor);\n    store(HTARGET1, ipx, htarget.y, fragColor);\n    store(HTARGET2, ipx, htarget.z, fragColor);\n#endif\n    store(POSITION0, ipx, position.x, fragColor);\n    store(POSITION1, ipx, position.y, fragColor);\n    store(POSITION2, ipx, position.z, fragColor);\n    \n    if (iMouse.z>0.0) {\n        vec2 tpm = pm + (abs(iMouse.zw) - iMouse.xy)/iResolution.y;\n        input_registered=input_registered||(abs(tpm.x-vm.x)>.5/iResolution.y||abs(tpm.y-vm.y)>.5/iResolution.y);\n    \tstore(VMOUSE0, ipx, tpm.x, fragColor);\n        store(VMOUSE1, ipx, tpm.y, fragColor);\n        store(VMOUSE2, ipx, 1., fragColor);\n    }\n    else if (vm.z > 0.5) {\n    \tstore(PMOUSE0, ipx, vm.x, fragColor);\n        store(PMOUSE1, ipx, vm.y, fragColor);\n        store(VMOUSE2, ipx, 0., fragColor);\n    }\n    store(POSITION_last0, ipx, position_l.x, fragColor);\n    store(POSITION_last1, ipx, position_l.y, fragColor);\n    store(POSITION_last2, ipx, position_l.z, fragColor);\n    store(VMOUSE_last0, ipx, vm_l.x, fragColor);\n    store(VMOUSE_last1, ipx, vm_l.y, fragColor);\n    \n    store(INPUT0, ipx, input_registered?2.:0., fragColor);\n    \n    \n    store(HALTON0, ipx, halton.x, fragColor);\n    store(HALTON1, ipx, halton.y, fragColor);\n    \n    vec2 halton_last = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    store(HALTON_last0, ipx, halton_last.x, fragColor);\n    store(HALTON_last1, ipx, halton_last.y, fragColor);\n    \n    store(RES_LAST0, ipx, iResolution.x, fragColor);\n    store(RES_LAST1, ipx, iResolution.y, fragColor);\n    \n    store(RES_CHANGE, ipx, res_ch?0.:1., fragColor);\n    \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//#define move_SUN_circle_inf\n#define move_rounds\n#ifdef move_rounds\nconst float rspd = 0.0235; //rotation speed\n#endif\n\n// change number of rays for better qality\n#define AORays 6\n#define reflectionRays 4\n#define shadowRays 4\n\n#ifdef move_rounds\nvec3 lightDir = normalize(vec3(0.045, .15, 1.0));\n#else \nconst vec3 lightDir = normalize(vec3(0.045, .15, 1.0));\n#endif\n\n// edit parameters\n// ---------------\n\n// when enabled 2nd light bounce (num of rays=AORays)\n#define sunlight_2nd_bounce\n\n#define enable_reflections\n#define reflection_color_emi\n\n// when ConeVector used in bounce light and emision light have not correct form \n// (compare to CosineWeightedSample, comment define below)\n#define use_ConeVector\n#define use_reproject_TAA\n\n// when turned off dymanic TAA - BufD is unused\n#define use_dynamic_TAA\n\n// texture or volume, texture use single float in BufB\n// and BufC copy to self alpha, just to have less texture reads in BufD that apply albedo TAA\n// albedo addition to color moved to BufD because TAA-pixel-jitter\n// no textures in this shader\n//#define enable_textures\n\n// when enabled dynamic TAA - there visible \"border\" on volume-shadow and object edges\n// I did unjitter it in Image shader // unjittering volume fog\n// it better now, line not jittering but it still visible 1 pixel around objects when camera move\n#define enable_volume\n\n#define volumeSteps 10\nconst float volume_fogDensity = .125;\n\nconst float camera_fov = 70.;\n\n\n\n#define add_clouds\n\n#define cloud_render_scale\n#define rscale ivec2(2,2)\n\n// ---------------\n\n\n// ---------------\n//ANGLE\n\n//#define ANGLE_loops 0\n#define ANGLE_loops min(iFrame,0)\n\n\n\n\n#define MAX_DIST 1000.\n#define MIN_DIST .0001\n\n\n// OBJ_ is >=0, not negative\n#define OBJ_SKY 0\n#define OBJ_SPHERE 1\n#define OBJ_FLOOR 2\n#define OBJ_FLOOR2 3\n#define OBJ_FLOOR3 4\n#define OBJ_FLOOR4 5\n#define OBJ_BOX 6\n#define OBJ_BOX2 7\n#define OBJ_SPHERE2 8\n#define OBJ_SPHERE3 9\n#define OBJ_BEZIER1 10\n\n//#define OBJ_CYL_bot 18\n//#define OBJ_CYL_top 19\n#define OBJ_CYL1 20\n#define OBJ_CYL2 21\n#define OBJ_CYL3 22\n#define OBJ_CYL4 23\n#define OBJ_CYL5 24\n#define OBJ_CYL6 25\n\n// range 50+ number of repetitions RREP_num - if needed, not used here, id is static OBJ_RR_CYL, look RayTracing_Radial_RepetitionMin\n#define OBJ_RR_CYL 50\n#define OBJ_RR_CYL2 51\n#define OBJ_RR_CYL3 52\n\n//\n\n\nconst vec3 upVec = vec3(0.0, 1.0, 0.0);\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define c_goldenRatioConjugate 0.61803398875f\n\n\n\n// Camera related (just to have less code in buffers)\n// ---------------\nconst ivec2 MEMORY_BOUNDARY = ivec2(2, 16); //BufA reserved (and top right pixel)\n\nconst ivec2 RES_LAST0 = ivec2(0, 0);\nconst ivec2 RES_LAST1 = ivec2(0, 1);\nconst ivec2 INIT0 = ivec2(0, 2);\nconst ivec2 TARGET0 = ivec2(0, 3);\nconst ivec2 TARGET1 = ivec2(0, 4);\nconst ivec2 TARGET2 = ivec2(0, 5);\n\nconst ivec2 POSITION0 = ivec2(0, 6);\nconst ivec2 POSITION1 = ivec2(0, 7);\nconst ivec2 POSITION2 = ivec2(0, 8);\nconst ivec2 POSITION_last0 = ivec2(0, 9);\nconst ivec2 POSITION_last1 = ivec2(0, 10);\nconst ivec2 POSITION_last2 = ivec2(0, 11);\n\nconst ivec2 VMOUSE0 = ivec2(1, 0);\nconst ivec2 VMOUSE1 = ivec2(1, 1);\nconst ivec2 VMOUSE2 = ivec2(1, 2);\nconst ivec2 VMOUSE_last0 = ivec2(1, 3);\nconst ivec2 VMOUSE_last1 = ivec2(1, 4);\n\nconst ivec2 INPUT0 = ivec2(1, 5);\nconst ivec2 HALTON0 = ivec2(1, 6);\nconst ivec2 HALTON1 = ivec2(1, 7);\nconst ivec2 HALTON_last0 = ivec2(1, 8);\nconst ivec2 HALTON_last1 = ivec2(1, 9);\nconst ivec2 PMOUSE0 = ivec2(1, 10);\nconst ivec2 PMOUSE1 = ivec2(1, 11);\n\nconst ivec2 LOCAL_T = ivec2(0, 12);\nconst ivec2 LOCAL_T_last = ivec2(0, 13);\nconst ivec2 LMC = ivec2(0, 14);\n\nconst ivec2 HTARGET0 = ivec2(1, 12);\nconst ivec2 HTARGET1 = ivec2(1, 13);\nconst ivec2 HTARGET2 = ivec2(1, 14);\n\nconst ivec2 RES_CHANGE = ivec2(1, 15);\n\nfloat load(ivec2 P, sampler2D self){return texelFetch(self, ivec2(P), 0).a;}\n\nmat3 rotx(float a){float s = sin(a);float c = cos(a);return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, s), vec3(0.0, -s, c));  }\nmat3 roty(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, 0.0, s), vec3(0.0, 1.0, 0.0), vec3(-s, 0.0, c));}\nmat3 rotz(float a){float s = sin(a);float c = cos(a);return mat3(vec3(c, s, 0.0), vec3(-s, c, 0.0), vec3(0.0, 0.0, 1.0 ));}\n\n// Camera\n#ifdef move_rounds\nfloat rtimer = 0.;\nfloat rtimer_last = 0.;\n#endif\nmat3 rotationMatrix(vec2 m){\n  mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n  mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n#ifdef move_rounds\n  return roty(-rtimer*rspd)*rotY*rotX;\n#else\n  return rotY*rotX;\n#endif\n}\n\nmat3 rotationMatrix_last(vec2 m){\n  mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n  mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n#ifdef move_rounds\n  return roty(-rtimer_last*rspd)*rotY*rotX;\n#else\n  return rotY*rotX;\n#endif\n}\n\nvoid SetCamera(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION0,caminfo),load(POSITION1,caminfo),load(POSITION2,caminfo));\n    vec2 m = vec2(load(VMOUSE0,caminfo),load(VMOUSE1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\nvoid SetCamera_prev(vec2 uv, sampler2D caminfo, out vec3 ro, out vec3 rd, vec2 ires)\n{\n    ro = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo));\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix_last(m) * rd;\n}\n\nvoid SetCamera_m(vec2 uv, vec2 m, out vec3 rd, vec2 ires)\n{\n    m.y = -m.y;\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    //rd+=0.000001*(1.-abs(sign(rd)));\n    rd = normalize(rd);\n    rd = rotationMatrix(m) * rd;\n}\n\n// ---------------\n\n\n\n// ---------------\n\n// material by object id\n// remember about dFd bugs\n// ---------------\n\nvoid material_OBJ_FLOOR(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1.,1.,1.);\n    emission = vec3(0.,0.,0.);\n    roughness = 0.742531;\n    metalness = 0.1521;\n}\nvoid material_OBJ_FLOOR4(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = 0.5*vec3(1.,1.,1.);\n    emission = vec3(0.,0.,0.);\n    roughness = 0.2;\n    metalness = 0.9;\n}\n\n\nvoid material_OBJ_FLOOR2(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    float tp = 1.-step(0.2,abs(length(pos.xz)-47.5));\n    albedo = mix(vec3(1.,1.,1.),vec3(1.,1.,0.),tp);\n    emission = vec3(0.,0.,0.);\n    roughness = 0.2531-0.2*tp;\n    metalness = 0.521-0.42*tp;\n}\n\nvoid material_OBJ_RRT(vec3 pos, int obj, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo = vec3(1., 1., 1.)*0.81;\n    emission = vec3(0.,0.,0.);\n    roughness = 0.6531;\n    metalness = 0.7521;\n}\n\nvoid material_OBJ_CYL(vec3 pos, vec3 norm, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness, int obj){\n    float a = float(obj!=OBJ_CYL1);\n    albedo = vec3(1., 1., 1.)-a*.05;\n    emission = vec3(0., 0., 0.);\n    roughness = 0.31-0.11*a;\n    metalness = 0.17+0.473*a;\n    if(obj==OBJ_CYL6||obj==OBJ_CYL1){\n        vec2 tuv=0.5+vec2(atan(pos.z,pos.x)/(3.1415926*2.), pos.y);\n#ifndef move_SUN_circle_inf\n        emission = float(obj==OBJ_CYL6)*7.*vec3(0.75,0.95,1.25)*step(0.8,fract(tuv.x*20.))*step(tuv.x,0.35);\n#endif\n        if(obj==OBJ_CYL1){\n            vec2 p = vec2((fract(tuv.x*11.)-0.5)*5.5,(tuv.y-7.5)*0.25);\n            vec2 td = abs(p)-vec2(0.8,0.1);\n            float d = length(max(td,0.0)) + min(max(td.x,td.y),0.0);\n            float tx=step(abs(d-0.2)-0.12,0.);\n            vec3 c = mix(vec3(1., .35, 0.051),vec3(.251, 1., 0.75),float(int(tuv.x*11.)%2));\n            vec2 tp = p;tp+=vec2(0.6*(1.-2.*float(int(tuv.x*11.)%2)),0.025);\n            p = vec2((fract(tuv.x*600.)-0.5),fract((tuv.y)*2.5)-0.5);\n            float tvv = 0.45-0.85*(tp.x*tp.x)-1.282*tp.y;\n            float ep = step(length(p),tvv*step(0.15,tvv))*step(tp.y,.12+0.025);\n            albedo = mix(mix(vec3(1.),vec3(0.25),ep),c,tx);\n            roughness = mix(mix(roughness,0.2,tx),0.15,ep);\n#ifndef move_SUN_circle_inf\n            emission = 6.*(c*0.5+0.5)*(1.-step(0.,d-0.12))*step(floor(tuv.x*11.),4.5);\n#endif\n        }\n    }\n}\n\nvec3 get_normal_OBJ_FLOOR(vec3 pos, vec3 ro){\n    return normalize(vec3(0.0,sign(sign(-pos.y+ro.y)+0.001),0.0));\n}\n\nvec3 cylNormal(in vec3 p, float ra, float ins);\nvec3 get_normal_OBJ_CYL(vec3 pos, float ra, float ins){\n    return cylNormal(pos, ra, ins);\n}\n/*\nvec3 get_normal_OBJ_CYL_top(){\n    return vec3(0.,1.,0.);\n}\nvec3 get_normal_OBJ_CYL_bot(){\n    return vec3(0.,-1.,0.);\n}\n*/\n\n// ---------------\n\n\n\n// sky\n//----------------------------------------------\n\nconst float sunAngularDiameter = 2.5;\n\nconst float sunIluminance = 1.5;\n\nconst float goldenAngle = 2.3999632297286533;\n\n// sky from https://www.shadertoy.com/view/3dlSW7\n\nfloat hGPhase(float cosTheta, const float g){\n\tfloat g2 = g * g;\n    \n    return 0.25 * (1.0 - g2) * pow(g2 - 2.0 * g * cosTheta + 1.0, -1.5);\n}\n\nvec3 calculateSunColor(float sunZenith){\n\treturn mix(vec3(1.0, 0.4, 0.05), vec3(1.0), max(sunZenith, 0.0));\n}\n\n// sun dot turned off in this shader - it have bad visible trace on movement when intersect with objects\nfloat calculateSun(float lDotV){return 0.;}\n/*\nfloat calculateSun(float lDotV){\n    const float cosRad = cos(radians(sunAngularDiameter));\n    const float sunLuminance = sunIluminance / ((1.0 - cosRad) * TAU);\n    \n    return smoothstep(cosRad,cosRad*1.001, lDotV) * sunLuminance;\n}\n*/\n\nvec3 calculateSky(vec3 background, float lDotU, float lDotV){\n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    float zenith = max(lDotU, 0.0);\n    \n    float sunZenith = lightDir.y;\n    const vec3 topCol = vec3(0.1, 0.34, 1.0);\n    \n    const vec3 bottomCol = 0.8+0.2*vec3(0.1, 0.34, 1.0);\n    //const vec3 bottomCol = vec3(1.0);\n    \n    vec3 sky = mix(topCol, (bottomCol + topCol), exp2(-zenith * 8.0));\n         sky += phaseMie * exp2(-zenith * 6.0);\n    \n    vec3 absorbColor = calculateSunColor(1.0 - exp2(-zenith * 2.0));\n    \n    sky = sky * mix(absorbColor * 0.9 + 0.1, vec3(1.0), sunZenith);\n\treturn background * absorbColor + sky * sunIluminance * (1.0 - clamp(-sunZenith * 10.0, 0.0, 1.0));\t\n}\n\n//----------------------------------------------\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n// with ConeVector better visual result\n// ConeVector distribution, look this screenshots\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr1.jpg\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/upl_demos/pathtracer/ray_distr2.png\n#ifdef use_ConeVector\n\nmat3 calculateTangentMatrix(vec3 direction){\n\tvec3 c1 = cross(direction, vec3(0.0, 0.0, 1.0));\n\tvec3 c2 = cross(direction, vec3(0.0, 1.0, 0.0));\n    \n    vec3 tangent = dot(c1, c1) > dot(c2, c2) ? c1 : c2;\n    vec3 biDir = cross(direction, tangent);\n    \n    return mat3(tangent, biDir, direction);\n}\n\nvec3 calculateConeVector(const float i, const float angularRadius, const int steps) {\n    float x = i * 2.0 - 1.0;\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    \n    float angle = acos(x) * radians(angularRadius) * 1./PI;\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\nvec3 calculateRoughSpecular(const float i, const int steps, float roughness) {\n    float r = roughness * roughness * roughness * roughness;\n    float x = (r * i) / max(1.0 - i,0.0001);\n    float y = i * float(steps) * 16.0 * 16.0 * goldenAngle;\n    //if(1.0 - i<0.)\n    //x = (r * i)*1000.;\n    float c = inversesqrt(x + 1.0);\n    float s = sqrt(x) * c;\n\n    return vec3(cos(y) * s, sin(y) * s, c);\n}\n\n#else\n\n// CosineWeightedSample\n\nfloat seed;\nfloat hash11_seed()\n{\n    float p=seed;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    seed+=1.33;\n    return fract(p);\n}\n\nvec3 ortho(vec3 v) {\n  return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nvec3 getCosineWeightedSample(vec3 dir, float radius) {\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\tvec2 r = vec2(hash11_seed(), hash11_seed());\n\tr.x = r.x * 2.0 * PI;\n\tr.y = pow(r.y, radius);\n\tfloat oneminus = sqrt(abs(1.0-r.y*r.y));\n\treturn cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir;\n}\n\n\n#endif\n//----------------------------------------------\n\n// reprojection\n//----------------------------------------------\n\nvec2 pos2uv(vec3 pos, sampler2D caminfo, vec2 ires){\n    vec3 ro_old = vec3(load(POSITION_last0,caminfo),load(POSITION_last1,caminfo),load(POSITION_last2,caminfo));\n    vec2 m_old = vec2(load(VMOUSE_last0,caminfo),load(VMOUSE_last1,caminfo))*vec2(1.,-1.);\n    vec3 td = pos - ro_old;\n    if(length(td)<0.0001)return vec2(-1.);\n    vec3 dir = normalize(td) * (rotationMatrix_last(m_old));\n    float fov=camera_fov;\n    float aspect = ires.x / ires.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    dir.z+=0.0001*(1.-abs(sign(dir.z)));\n    return dir.xy * (.5/screenSize) / dir.z ;\n}\n\nfloat distancePixel( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).b;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\n\n#define PixelAcceptance 4.\n#define PixelCheckDistance .5\nvec4 previousSample(vec3 ro, vec3 pos, sampler2D caminfo, sampler2D last_pos_fbo, sampler2D last_color, vec2 ires){\n    vec2 old_halton_px_shift=vec2(load(HALTON_last0,caminfo),load(HALTON_last1,caminfo));\n    vec2 prevUv = pos2uv(pos, caminfo, ires) - old_halton_px_shift/ires.y;\n    vec2 prevFragCoord = prevUv * ires.y + ires.xy/2.0;\n    \n    vec2 pfc=vec2(0.);\n    vec2 finalpfc=vec2(0.);\n    float dist, finaldist = MAX_DIST;\n    for(int x = -1; x <= 1; x++){\n        for(int y = -1; y <= 1; y++){\n            pfc = prevFragCoord + PixelCheckDistance*vec2(x, y);\n            vec2 tuv = pfc/ires.xy * 2.0 - 1.0;\n            tuv.y *= ires.y/ires.x;\n            vec3 p_ro;\n            vec3 p_rd;\n            SetCamera_prev( tuv, caminfo, p_ro, p_rd, ires);\n            dist = distancePixel(pfc, pos, last_pos_fbo, ires, p_ro, p_rd);\n            if(dist < finaldist){\n                finalpfc = pfc;\n                finaldist = dist;\n            }\n      }\n    }\n    \n    if(finaldist < (PixelAcceptance/ires.y)*(length(pos-ro)))\n        return textureLod(last_color, finalpfc/ires.xy,0.);\n    return vec4(0.);\n}\n\n//----------------------------------------------\n\n\n\n\n\n\n// intersection template\n//----------------------------------------------\n\nstruct HitInfo {\n    float t;\n    vec3 norm;\n    vec4 color;\n    vec3 emisson;\n    float rough;\n    float metal;\n    int obj_type;\n};\n\n\nbool boxAABB(in vec3 dims, vec3 ro, vec3 rd) {\n    rd += 0.0001 * (1.0 - abs(sign(rd)));\n    vec3 n = ro / rd;\n    vec3 k = dims / abs(rd);\n    vec3 t1 = -k - n, t2 = k - n;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    return tN < tF && tF > 0.0;\n}\n\nbool PlaneIntersect(vec4 Plane, vec3 ro, vec3 rd, out float t, out vec3 norm) {\n    norm=vec3(0.,1.,0.);\n    t=-1.;\n    float dd = dot(rd, Plane.xyz);\n    if (dd == 0.0) return false;\n    float t1 = -(dot(ro, Plane.xyz) + Plane.w) / dd;\n    if (t1 < 0.0) return false;\n    norm = normalize(Plane.xyz);\n    t = t1;\n    return true;\n}\n\nvec3 cylNormal( in vec3 p, float ra, float ins)\n{\n    vec3 a=vec3(0.,1.,0.);\n    vec3 b=vec3(0.,-1.,0.);\n    vec3  pa = p - a;\n    vec3  ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float h = dot(pa,ba)/baba;\n    return ins*(pa - ba*h)/ra;\n}\n\nbool CylinderInfIntersect( in vec3 ro, in vec3 rd, in float ra, vec3 ca, out float tN, out vec3 norm, float ins) \n{\n    norm=vec3(0.,1.,0.);\n    tN=MAX_DIST;\n    vec3  oc = ro;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 ) return false;\n    h = ins*sqrt(h);\n    float t=(-b-h)/a;\n    if( t<0.0 ) return false;\n    tN=t;\n    norm=cylNormal( ro+tN*rd, ra, ins);\n    return true;\n}\n\nvoid CylinderInfIntersectMin(vec3 ro, vec3 rd, float rad, float heigh, vec3 opos, int obj, inout bool result, inout HitInfo hit, float ins) {\n    float tnew;\n    vec3 normnew;\n    ro -= opos;\n    if (CylinderInfIntersect(ro, rd, rad, vec3(0.,1.,0.), tnew, normnew, ins)) {\n        if (tnew < hit.t) {\n            vec3 pos = ro+rd*tnew;\n            if(abs(pos.y)>heigh){\n                return;\n            }\n            \n            hit.t = tnew;\n            hit.norm = normnew;\n            hit.emisson = vec3(0.,0.,0.);\n            vec3 albedo;\n            material_OBJ_CYL(pos+opos, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal, obj);\n            hit.color = vec4(albedo, 1.);\n            hit.obj_type = obj;\n            result = true;\n        }\n    }\n}\n\n\nvoid GroundIntersectMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, int obj, vec2 r) {\n    float tnew;\n    vec3 normnew;\n    vec4 pp=vec4(normalize(vec3(0.0, 1., 0.0)), 0.);\n    \n    // sunlight_2nd_bounce can be buggere here - visual bugs on floor\n    // +vec3(0.,1.,0.) - change y component to bigger, I do it in minDist, no idea why\n    \n    if (PlaneIntersect(pp, ro+vec3(0.,1.,0.), rd, tnew, normnew)) {\n        if (tnew < hit.t) {\n            if ((step(r.x,length((ro+rd*tnew).xz))<0.5) && (step(r.y,length((ro+rd*tnew).xz))>0.5)) {\n                hit.t = tnew;\n                hit.norm = normnew;\n\n                hit.emisson = vec3(0.,0.,0.);\n                vec3 albedo;\n                if(obj==OBJ_FLOOR4)material_OBJ_FLOOR4(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n                else{\n                if(obj==OBJ_FLOOR2)\n                material_OBJ_FLOOR2(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n                else\n                material_OBJ_FLOOR(ro+rd*hit.t, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n                }\n                hit.color = vec4(albedo, 1.);\n                hit.obj_type = obj;\n                result = true;\n            }\n        }\n    }\n}\n\n\n\n// base on RayTracing Radial Repetition \n// https://www.shadertoy.com/view/stKcWD\n\nstruct its\n{\n\tfloat t;\n\tvec3 n;    //normal \n\t\n};\nconst its  NO_its=its(MAX_DIST,vec3(0.,1.,0.));\n\nstruct span\n{\n\tits n;\n\tits f;\n    bool next;\n};\n\nspan iPlane( in vec3 ro, in vec3 rd, in vec3 n ,float h)\n{\n    float d1= -dot(ro,n)/dot(rd,n),   d2= -(dot(ro-h*n,n))/dot(rd,n);\n    vec3  u = normalize(cross(n,vec3(0,0,1))), v = normalize(cross(u,n) );\n    vec3 oNor=n;\n    if(d1<d2) return span(its(d1,-oNor),its(d2,oNor),false);\n    return span(its(d2,oNor),its(d1,-oNor),false);\n}\n\nspan iCylinder( in vec3 ro, in vec3 rd, in vec3 ca, float cr )\n{\n    vec3  oc = ro ;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return span(NO_its,NO_its,false); //no intersection\n    h = sqrt(h);\n    vec2 t =vec2(-b-h,-b+h)/a;\n    vec2 d= vec2(dot(oc +t.x*rd,ca) ,dot(oc +t.y*rd,ca) );\n    vec3 nN=normalize( oc +t.x*rd -d.x*ca),nF=normalize( oc +t.y*rd -d.y*ca);\n    its iN= its( t.x, nN); //todo uv\n    its iF= its( t.y, nF);\n    return  span(iN , iF,false );   \n}\n\nspan Inter(span a, span b)\n{\n   \n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t);\n   if(b.n.t==MAX_DIST || a.n.t==MAX_DIST) return span(NO_its,NO_its,false);\n   else if(cp.x && cp.z) return span(NO_its,NO_its,false);\n   else if(cp.x && !cp.z && cp.w)  return span(b.n,a.f,false);\n   else if(cp.x && !cp.z && !cp.w) return b;\n   else if(!cp.x && cp.y &&  cp.w) return a;\n   else if(!cp.x && cp.y &&  !cp.w) return span(a.n,b.f,false);\n   else return span(NO_its,NO_its,false);\n}\n\nspan Sub(span a, span b)\n{\n\n   bvec4 cp = bvec4(a.n.t<b.n.t,a.n.t<b.f.t,a.f.t<b.n.t,a.f.t<b.f.t); \n    if(a.n.t==MAX_DIST) return span(NO_its,NO_its,false);\n    else if(b.n.t==MAX_DIST) return a;   \n   else if(cp.x && cp.z) return a;\n   else if(cp.x && !cp.z && cp.w)  return span(a.n,b.n,false);\n   else if(cp.x && !cp.z && !cp.w && b.n.t>0.) return span(a.n,b.n,true); \n   else if(cp.x && !cp.z && !cp.w && b.n.t<0.) return span(b.f,a.f,false); //+ secondary span =  span(b.f,a.f)\n   else if(!cp.x && cp.y && cp.w) return span(NO_its,NO_its,false);\n   else if(!cp.x && cp.y && !cp.w) return span(b.f,a.f,false);\n   else return a;\n   \n}\n\n\nvec3 opU( vec3 d, span s, inout vec3 normal, float mat ) {\n    its ix= s.n;   \n    //if(ix.t<0.) ix=s.f;\n    if( ix.t<d.y && ix.t>d.x) {\n        normal=ix.n;\n        d=vec3(d.x, ix.t, mat);\n    }\n\treturn d;\n}\n\nvec3 RayTracing_Radial_Repetition( in vec3 ro, in vec3 rd, out vec3 normal, vec4 prm, float rtc) {\n    float RREP_tk = prm.x;\n    float RREP_num = prm.y;\n    float RREP_r = prm.z;\n    float RREP_h = prm.w;\n    \n    float RREP_thc = rtc*RREP_r*2./RREP_num;\n    vec3  d_ret = vec3(MIN_DIST, MAX_DIST, 0.);\n        \n    span s2,s3,s4;\n    \n    s2= iCylinder(ro,rd, vec3(0,1,0), RREP_r+RREP_tk );\n    s3= iPlane(ro,rd,vec3(0,1.,0),RREP_h);\n    s2= Inter(s2,s3);\n    s4= iCylinder(ro,rd, vec3(0,1,0), RREP_r-RREP_tk );\n\n    //backward disk intersection\n    span s5=span(s4.f,s2.f,false);\n    float d2=s4.f.t;\n    \n    //front disk intersection\n    s2=Sub(s2,s4);\n    \n    // outside of cylinder - can be removed if visual impact minimal\n    \n    if(s2.n.t<MAX_DIST  ){\n         vec2 p =  s2.n.t<0.? ro.xz:\n             (ro+rd*s2.n.t).xz;\n         float an = atan(p.y,p.x)+PI,\n               id= floor(an/TAU*RREP_num),\n               anc=(id+.5)/RREP_num*TAU,\n               sg= sign(dot(vec2(-sin(anc),cos(anc)),rd.xz));\n          // this for loop - 2 iterations may be not enough - visible transparent steps on RREP_num=6 \n          for(int i=0; i<2;i++){ \n             vec3 nm= vec3(sin(anc),0.,-cos(anc)); s3=iPlane(ro+nm*RREP_thc*0.5,rd,nm,RREP_thc);           \n             s4=Inter(s2,s3);             \n             d_ret= opU(  d_ret,  s4,normal , id);\n             anc-=sg/RREP_num*TAU;\n             id-=sg;\n             if(id>=RREP_num)id = 0.;\n             if(id<0.)id = RREP_num-1.;\n         }     \n     }\n     \n     // inside of cylinder - can be removed if visual impact minimal\n     /*\n     if(s2.n.t<MAX_DIST  && s2.next){\n         vec2 p = (ro+rd*d2).xz;\n         float an = atan(p.y,p.x)+PI,\n               id= floor(an/TAU*RREP_num),\n               anc=(id+.5)/RREP_num*TAU,\n               sg= sign(dot(vec2(-sin(anc),cos(anc)),rd.xz));\n          for(int i=0; i<2;i++){ \n             vec3 nm= vec3(sin(anc),0.,-cos(anc)); s3=iPlane(ro+nm*RREP_thc*0.5,rd,nm,RREP_thc);\n             s4=Inter(s5,s3);\n             d_ret= opU(  d_ret,  s4,normal , id);\n             anc-=sg/RREP_num*TAU;\n             id-=sg;\n             if(id>=RREP_num)id = 0.;\n             if(id<0.)id = RREP_num-1.;\n          }      \n      \n    }\n    */\n    if(dot(rd,normal)>0.) normal=-normal;\n    d_ret.z+=0.5;\n    return d_ret;\n}\n\nvoid RayTracing_Radial_RepetitionMin(vec3 ro, vec3 rd, inout bool result, inout HitInfo hit, vec4 prm, float rtc, int obj) {\n    float tnew;\n    vec3 normnew;\n    vec3 rrt = RayTracing_Radial_Repetition(ro, rd, normnew, prm, rtc);\n    tnew = rrt.y;\n    if (tnew < hit.t) {\n        hit.t = tnew;\n        hit.norm = normnew;\n        vec3 albedo;\n        material_OBJ_RRT(ro+rd*hit.t, obj, hit.norm,  albedo, hit.emisson, hit.rough, hit.metal);\n\n        hit.color = vec4(albedo, 1.);\n        hit.obj_type = obj; //+int(rrt.z); //ID is +0.5 and +OBJ_RR_CYL - if needed\n        result = true;\n    }\n}\n\n//----------------------------------------------\n\n\n\n// render NOT OPTIMIZED\n// can be optimized by separating normal/albedo calculation and hit(bool)\n// by making two functions, one used by shadows other by pathtracing\n// look get_scene_ \n//----------------------------------------------\n\nconst float RREP_tk1=.065;\nconst float RREP_num1=900.;\nconst float RREP_r1 = 50.-RREP_tk1*0.85;\nconst float RREP_h1 = 1.;\nconst float RREP_rtc1 = 0.35;\nconst vec3 RR1pos = vec3(0., -5., 0.);\nconst vec4 RR1prm = vec4(RREP_tk1, RREP_num1, RREP_r1, RREP_h1);\n\nconst float RREP_tk2=.75;\nconst float RREP_num2=50.;\nconst float RREP_r2 = 58.;\nconst float RREP_h2 = 300.;\nconst float RREP_rtc2 = .5;\nconst vec3 RR2pos = vec3(0., 150., 0.);\nconst vec4 RR2prm = vec4(RREP_tk2, RREP_num2, RREP_r2, RREP_h2);\n\nconst float RREP_tk3=.7;\nconst float RREP_num3=800.;\nconst float RREP_r3 = 45.75;\nconst float RREP_h3 = .15;\nconst float RREP_rtc3 = 1.;\nconst vec3 RR3pos = vec3(0., -5., 0.);\nconst vec4 RR3prm = vec4(RREP_tk3, RREP_num3, RREP_r3, RREP_h3);\n\nconst vec2 TTor = vec2(44.0,0.5);\nconst vec3 TTor_pos=vec3(0.,-5.25,-0.);\n\nbool minDist(vec3 ro, vec3 rd, out HitInfo hit)\n{\n    hit.t = MAX_DIST;\n    hit.obj_type = OBJ_SKY;\n    hit.norm = vec3(0.,1.,0.);\n    \n    float lDotU = dot(rd, upVec);\n    float lDotV = dot(rd, lightDir);\n    \n    hit.color=vec4(calculateSky(calculateSun(lDotV)*calculateSunColor(lightDir.y), lDotU, lDotV),1.);\n    hit.emisson = vec3(0.,0.,0.);\n    bool result = false;\n\n\n    GroundIntersectMin(ro+vec3(.0, -6., .0), rd, result, hit, OBJ_FLOOR, vec2(50.,0.001));\n    GroundIntersectMin(ro+vec3(.0, -6.-.35, .0), rd, result, hit, OBJ_FLOOR2, vec2(50.,47.));\n    GroundIntersectMin(ro+vec3(.0, -6.-4.5, .0), rd, result, hit, OBJ_FLOOR3, vec2(50.,0.001));\n    \n    GroundIntersectMin(ro+vec3(.0, -6.-.25, .0), rd, result, hit, OBJ_FLOOR4, vec2(46.2,46.1));    \n    GroundIntersectMin(ro+vec3(.0, -6.-.25, .0), rd, result, hit, OBJ_FLOOR4, vec2(45.4,45.3));    \n\n\n    CylinderInfIntersectMin(ro, rd,44.2,4.47,vec3(0.,5.,0.),OBJ_CYL1,result, hit, 1.);\n    \n    CylinderInfIntersectMin(ro, rd,46.2,.05,vec3(0.,5.2,0.),OBJ_CYL2,result, hit, 1.);\n    CylinderInfIntersectMin(ro, rd,46.1,.05,vec3(0.,5.2,0.),OBJ_CYL3,result, hit, -1.);\n    \n    CylinderInfIntersectMin(ro, rd,45.4,.05,vec3(0.,5.2,0.),OBJ_CYL4,result, hit, 1.);\n    CylinderInfIntersectMin(ro, rd,45.3,.05,vec3(0.,5.2,0.),OBJ_CYL5,result, hit, -1.);\n    \n    CylinderInfIntersectMin(ro, rd,47.3,.3485,vec3(0.,5.,0.),OBJ_CYL6,result, hit, -1.);\n    \n    RayTracing_Radial_RepetitionMin(ro+RR1pos, rd, result, hit, RR1prm, RREP_rtc1, OBJ_RR_CYL);\n    RayTracing_Radial_RepetitionMin(ro+RR2pos, rd, result, hit, RR2prm, RREP_rtc2, OBJ_RR_CYL2);\n    RayTracing_Radial_RepetitionMin(ro+RR3pos, rd, result, hit, RR3prm, RREP_rtc3, OBJ_RR_CYL3);\n\n    \n    \n    return result;\n}\n\n//----------------------------------------------\n\n\n// noise https://www.shadertoy.com/view/7sGBzW\n// hash https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n\n// saved in BufA as alpha\nfloat Bnoise(vec2 U) {\n    float v = 0.;\n    for (int k=0; k<9; k++)\n        v += hash12( U + vec2(k%3-1,k/3-1) ); \n    v=.9 *( 1.125*hash12(U)- v/8.) + .5;\n    //return clamp(v,0.,1.);\n    //return fract(abs(v));\n    return v < 0. ? -v : v > 1. ? 2.-v : v ;\n}\n\n// halton low discrepancy sequence, from https://www.shadertoy.com/view/wdXSW8\nvoid halton_loop(inout vec2 s, inout vec4 a){\n    const vec2 coprimes = vec2(2.0f, 3.0f);\n    a.xy = a.xy/coprimes;\n    a.zw += a.xy*mod(s, coprimes);\n    s = floor(s/coprimes);\n}\nvec2 halton (int index){\n    vec2 s = vec2(index, index);\n\tvec4 a = vec4(1,1,0,0);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    if (s.x > 0. && s.y > 0.)halton_loop(s, a);\n    return a.zw;\n}\n\n\n\n// https://www.shadertoy.com/view/3ddfDj\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\nvec4 triplanar( sampler2D sam, in vec3 p, in vec3 n, vec3 dpdx, vec3 dpdy )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    \n    vec3 m = pow( abs(n), vec3(8.0) );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n\n\n// https://www.shadertoy.com/view/Nls3Rn\n\n#define pack_Snormfloat3x10(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_Snormfloat3x10(x) unpackSnorm3x10(floatBitsToUint(x))\n//#define pack_Unormfloat3x10(x) uintBitsToFloat(packSnorm3x10((x-0.5)*2.))\n//#define unpack_Unormfloat3x10(x) (unpackSnorm3x10(floatBitsToUint(x))/2.+0.5)\n\n// NOTE - Unormfloat3x10 above result noticeable \"jump\" when color~=0.5\n// Unormfloat3x10 will down/upscale 0.5+-0.001 to 0.5\n// look last few lines in BufB where pack_Unormfloat3x10 used for TAA feedback\n\n// As solution I use only >0 region of Snorm\n\n#define pack_Unormfloat3x10(x) uintBitsToFloat(packSnorm3x10(x))\n#define unpack_Unormfloat3x10(x) (unpackSnorm3x10(floatBitsToUint(x)))\n\nuint packSnorm3x10(vec3 x) {\n    x = clamp(x,-1., 1.) * 511.;\n    uvec3 sig = uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x),vec3(0))));\n    uvec3 mag = uvec3(abs(x));\n    uvec3 r = sig.xyz << 9 | mag.xyz;\n    return r.x << 22 | r.y << 12 | r.z << 2;\n}\n\nvec3 unpackSnorm3x10(uint x) {\n    uvec3 r = (uvec3(x) >> uvec3(22, 12, 2)) & uvec3(0x3FF);\n    uvec3 sig = r >> 9;\n    uvec3 mag = r & uvec3(0x1FF);\n    vec3 fsig = mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n    vec3 fmag = vec3(mag) / 511.;\n    return fsig * fmag;\n}\n\n#ifdef add_clouds\n#ifdef cloud_render_scale\nvec3 texture_Bilinear( sampler2D c, vec2 t )\n{\n    const int fx = 1;\n    ivec2 res = textureSize(c,0).xy/rscale;\n    vec2 p = vec2(res-fx)*t - 0.5+float(fx);\n    vec2 f = fract(p);\n    ivec2 i = ivec2(p);\n\n    return mix(mix(unpack_Unormfloat3x10(texelFetch(c,clamp(i+ivec2(0,0),ivec2(0),res-1),0).a),\n                   unpack_Unormfloat3x10(texelFetch(c,clamp(i+ivec2(1,0),ivec2(0),res-1),0).a), f.x),\n               mix(unpack_Unormfloat3x10(texelFetch(c,clamp(i+ivec2(0,1),ivec2(0),res-1),0).a),\n                   unpack_Unormfloat3x10(texelFetch(c,clamp(i+ivec2(1,1),ivec2(0),res-1),0).a), f.x), f.y);\n}\n#endif\n#endif\n\n\n// https://www.shadertoy.com/view/NtXyD8\n// thanks to https://www.wolframalpha.com/input?i=2.51y%5E2%2B.03y%3Dx%282.43y%5E2%2B.59y%2B.14%29+solve+for+y\nvec3 ACES_Inv(vec3 x) {\n    x = clamp(x, 0., 1.);\n    return (sqrt(-10127.*x*x + 13702.*x + 9.) + 59.*x - 3.) / (502. - 486.*x); \n}\n\nvec3 ACESFilm( vec3 x )\n{\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    return clamp((x*(tA*x+tB))/(x*(tC*x+tD)+tE),0.0,1.0);\n}\n\nfloat angle2d(vec2 c, vec2 e) {\n    float theta = atan(e.y-c.y, e.x-c.x);\n    return theta;\n}\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n// using pathtracer functions https://www.shadertoy.com/view/3dlSW7\n// using reprojection functions https://www.shadertoy.com/view/WdjcDd\n\n// this pathtracer template https://www.shadertoy.com/view/dldGWj\n\n// BufB - pathtraced bounce lighting and AO with reprojection of last frame \n// BufB (alpha) save fogLitPercent or Albedo when #define enable_textures set in Common\n\n//----------------------------------------------\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.002*norm, rd, hit)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.002, rd, hit);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\nvoid get_scene_material(bool d, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR||obj_id==OBJ_FLOOR3)\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_FLOOR2)\n            material_OBJ_FLOOR2(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_FLOOR4)\n            material_OBJ_FLOOR4(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_CYL1||obj_id==OBJ_CYL2||obj_id==OBJ_CYL3||obj_id==OBJ_CYL4||obj_id==OBJ_CYL5||obj_id==OBJ_CYL6)//||obj_id==OBJ_CYL_top||obj_id==OBJ_CYL_bot)\n            material_OBJ_CYL(pos, norm, albedo, emission, roughness, metalness, obj_id);\n        else if(obj_id==OBJ_RR_CYL)\n            material_OBJ_RRT(pos, OBJ_RR_CYL, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_RR_CYL2)\n            material_OBJ_RRT(pos, OBJ_RR_CYL2, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_RR_CYL3)\n            material_OBJ_RRT(pos, OBJ_RR_CYL3, norm, albedo, emission, roughness, metalness);\n    }\n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\n\n\n\nfloat calculateShadow(vec3 ro, vec3 rd, vec3 normal, float dither, int rays_shadow){\n\tfloat shadow = 0.0;\n    float rShadowRays = 1.0 / float(rays_shadow);\n    \n#ifdef use_ConeVector\n    mat3 tbl = calculateTangentMatrix(rd);\n#endif\n\tfor (int i = 0; i < rays_shadow+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbl * calculateConeVector((float(i) + dither) * rShadowRays, sunAngularDiameter, rays_shadow);\n#else\n        vec3 dir = normalize(rd+radians(sunAngularDiameter)*getCosineWeightedSample(lightDir,0.15));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        \n\t\tfloat light = sunIluminance * lDotN;\n        float rayHit = get_scene_intersect(ro, dir, normal);\n\t\t\n\t\tshadow += rayHit * light;\n\t}\n    \n    return shadow * rShadowRays;\n}\n\nvec3 calculate_bouncelight_AO(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 sunColor, float noise){\t\n    vec3 AO = vec3(0.0);\n    const float rAORays = 1.0 / float(AORays);\n    \n#ifdef sunlight_2nd_bounce\n    vec3 bouncedLight = vec3(0.0);\n    vec3 abso = vec3(1.);\n#endif\n    \n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n\tfor (int i = 0; i < AORays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n\t\tvec3 dir = tbn * calculateConeVector((float(i) + noise) * rAORays, 90.0, AORays);\n#else\n\t\tvec3 dir = normalize(normal + 5.*getCosineWeightedSample(normal,0.5));\n#endif\n        float lDotN = dot(dir, normal);\n        if (lDotN <= 0.0) continue;\n        \n        lDotN = sqrt(clamp(lDotN, 0.0, 1.0));\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n        \n\t\tvec3 light = calculateSky(vec3(0.0), lDotU, lDotV) * lDotN;\n        \n#ifdef sunlight_2nd_bounce\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal);\n        if(rayHit<0.5)\n        {\n            vec3 bouncedLighting = calculateShadow(bouncePos, lightDir, bounceNormal, noise, 2)*sunColor;\n            bouncedLighting += abso * (bouncedEmissive + bouncedAlbedo*bouncedLighting);\n            abso *= bouncedAlbedo;\n            bouncedLight += bouncedLighting * (1.0 - rayHit) * lDotN;\n        }\n#else\n        float rayHit = get_scene_intersect(ro, dir, normal);\n#endif\n\t\tAO += rayHit * light;\n\t}\n    \n    AO = AO * rAORays * 2./PI;\n#ifdef sunlight_2nd_bounce\n    bouncedLight = bouncedLight * rAORays;\n    AO+=bouncedLight;\n#endif\n    \n\treturn AO;\n}\n\n//----------------------------------------------\n\n// volume\n//----------------------------------------------\n#ifdef enable_volume\nfloat raymarchVolume(vec3 ro, vec3 rd, float noise){\n    const float rSteps = 1.0 / float(volumeSteps);\n    \n    vec3 start = vec3(0.0);\n    vec3 end = ro;\n    float endDepth = length(end);\n    end /= max(endDepth,0.0001);\n    endDepth = min(length(ro), MAX_DIST);\n    end *= endDepth;\n    \n    vec3 increment = (end - start) * rSteps;\n    vec3 rayPosition = noise * increment + start;\n    \n    float fogLitPercent = 0.0f;\n    for (int i = 0; i < volumeSteps+ANGLE_loops; i++){\n        float volumetricShadow = get_scene_intersect(rayPosition + rd, lightDir, rayPosition + rd);\n        fogLitPercent = mix(fogLitPercent, volumetricShadow, 1.0 / float(i+1));\n        rayPosition +=  increment;\n     }\n    //return fogLitPercent;\n    return fogLitPercent;\n}\n#endif\n//----------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#ifdef move_rounds\n    float l_t = load(LOCAL_T,iChannel0);\n    rtimer = l_t;\n    float l_t_last = load(LOCAL_T_last,iChannel0);\n    rtimer_last = l_t_last;\n#ifdef move_SUN_circle_inf\n    lightDir.xz=lightDir.xz*MD(-rtimer*rspd);\n#endif\n#endif\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec2 this_id_d = texelFetch(iChannel0, ivec2(fc), 0).xy;\n    int obj_id = int(this_id_d.x);\n    vec3 pos=ro+rd*this_id_d.y;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n    \n    // restore normals from obj_id\n    vec3 box=-vec3(-4.0, 0.0, -7.0);\n    vec3 box2=-vec3(-1.8, 0.0, -5.0);\n    vec3 sphere3=-vec3(-3.0, -2.0, -5.51);\n    vec3 sphere2=-vec3(-7.0, -0.5, -5.51);\n    vec3 sphere=-vec3(-4.4, -0.25, -4.51);\n    vec3 quadratic_pos=vec3(1.,2.,6.);\n    \n    if(obj_id==OBJ_FLOOR||obj_id==OBJ_FLOOR2||obj_id==OBJ_FLOOR3||obj_id==OBJ_FLOOR4)normal=get_normal_OBJ_FLOOR(pos,ro);\n    if(obj_id==OBJ_CYL1)normal=get_normal_OBJ_CYL(pos-vec3(0.), 44.2, 1.);\n    if(obj_id==OBJ_CYL2)normal=get_normal_OBJ_CYL(pos-vec3(0.), 46.2, 1.);\n    if(obj_id==OBJ_CYL3)normal=get_normal_OBJ_CYL(pos-vec3(0.), 46.1, -1.);\n    if(obj_id==OBJ_CYL4)normal=get_normal_OBJ_CYL(pos-vec3(0.), 45.4, 1.);\n    if(obj_id==OBJ_CYL5)normal=get_normal_OBJ_CYL(pos-vec3(0.), 45.3, -1.);\n    if(obj_id==OBJ_CYL6)normal=get_normal_OBJ_CYL(pos-vec3(0.), 47.3, -1.);\n    \n    //if(obj_id==OBJ_CYL_top)normal=get_normal_OBJ_CYL_top();\n    //if(obj_id==OBJ_CYL_bot)normal=get_normal_OBJ_CYL_bot();\n    if(obj_id==OBJ_RR_CYL){\n        vec3 rrt = RayTracing_Radial_Repetition(ro+RR1pos, rd, normal, RR1prm, RREP_rtc1);\n    }\n    if(obj_id==OBJ_RR_CYL2){\n        vec3 rrt = RayTracing_Radial_Repetition(ro+RR2pos, rd, normal, RR2prm, RREP_rtc2);\n    }\n    if(obj_id==OBJ_RR_CYL3){\n        vec3 rrt = RayTracing_Radial_Repetition(ro+RR3pos, rd, normal, RR3prm, RREP_rtc3);\n    }\n    \n    get_scene_material(rayHit, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n\tvec3 color_light_AO = calculate_bouncelight_AO(pos, rd, normal, metal, rough, sunColor, noise);\n    \n    vec3 shadow = calculateShadow(pos, lightDir, normal, noise, shadowRays)*sunColor;\n    vec3 color = mix(color_light_AO+shadow,vec3(0.),dot(emission,vec3(1.))/3.);\n    color = mix(albedo*color, emission, dot(emission,vec3(1.))/3.);\n    if (!rayHit) \n    {\n        float lDotU = dot(rd, upVec);\n        float lDotV = dot(rd, lightDir);\n        color=vec3(0.);\n        color = calculateSun(lDotV)*calculateSunColor(lightDir.y);\n        color = calculateSky(color, lDotU, lDotV);\n#ifdef add_clouds\n        bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n#ifdef cloud_render_scale\n        if(iFrame==0||res_ch){}\n        else{\n            color = texture_Bilinear(iChannel3, fragCoord/iResolution.xy);\n            color = ACES_Inv(color);\n        }\n#else\n        if(iFrame==0||res_ch){}\n        else{color = unpack_Unormfloat3x10(texelFetch(iChannel3, ivec2(fragCoord), 0).a);}\n#endif\n#endif\n        \n    }\n    \n    float fogLitPercent = 0.;\n#ifdef enable_textures\n    fogLitPercent = pack_Unormfloat3x10(triplanar( iChannel3, pos, normal, dFdx(pos), dFdy(pos) ).rgb);\n    // avoiding dfd bugs\n    if(obj_id==OBJ_SKY)fogLitPercent=pack_Unormfloat3x10(vec3(1.));\n#else\n#ifdef enable_volume\n    #ifdef use_ConeVector\n    fogLitPercent = raymarchVolume(pos - ro, ro, noise);\n    #else\n    fogLitPercent = raymarchVolume(pos - ro, ro, hash11_seed());\n    #endif\n#endif\n#endif\n    \n    color = max(color, 0.0);\n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, fogLitPercent);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor=clamp(fragColor,0.,100.); \n#ifdef enable_textures\n    fragColor.a = fogLitPercent;\n#endif\n#ifdef use_reproject_TAA\n    // reprojection TAA\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    if(input_registered||res_ch){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel1, iResolution.xy);\n        float factor = (oldCol.a == 0.||res_ch) ? 0. : (rayHit ? .95 : 0.05);//limit sky reproject trails\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n#endif\n        //fragColor.a=fogLitPercent; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texelFetch(iChannel1, ivec2(fc),0);\n        fragColor.rgb = mix(fragColor.rgb, backColor.rgb, 0.95 * (1.-float(input_registered)));\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, backColor.a, 0.95 * (1.-float(input_registered)));\n#else\n        fragColor.a = pack_Unormfloat3x10(mix(unpack_Unormfloat3x10(fragColor.a), unpack_Unormfloat3x10(backColor.a), 0.95 * (1.-float(input_registered))));\n#endif\n        \n    }\n#ifndef enable_textures\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag for previousSample in Comon, it return alpha 0. when no reprojection\n#endif\n}\n\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\n// using https://www.shadertoy.com/view/3dlSW7\n// using https://www.shadertoy.com/view/WdjcDd\n\n// this pathtracer template https://www.shadertoy.com/view/dldGWj\n\n// fragColor = vec4(color, absorb); // absorb for volumetric, volumetric rendered in Image\n\n//----------------------------------------------\n\n\nfloat get_scene_intersect(vec3 ro, vec3 rd, vec3 norm){\n    HitInfo hit;\n    //0.002 is light leak\n    return (minDist(ro+0.002*norm, rd, hit)?0.:1.);\n}\n\nfloat get_scene_bounce_light(vec3 ro, vec3 rd, vec3 innorm, out vec3 ndir, out vec3 albedo, out vec3 emission, out vec3 norm){\n    HitInfo hit;\n    bool d = minDist(ro+innorm*0.002, rd, hit);\n    ndir=vec3(0.0001);\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    norm = vec3(0.0001);\n    if(d){\n        ndir=ro+rd*hit.t;\n        albedo=hit.color.rgb;\n        emission=hit.emisson;\n        norm = hit.norm;\n    }\n    \n    return d?0.:1.;\n}\n\nvoid get_scene_material(bool d, vec3 pos, vec3 norm, int obj_id, out vec3 albedo, out vec3 emission, \n                        out float roughness, out float metalness){\n    albedo=vec3(0.0);\n    emission=vec3(0.0);\n    roughness=0.0001;\n    metalness=0.0001;\n    // pos+= objpos todo\n    if(d){\n        if(obj_id==OBJ_FLOOR||obj_id==OBJ_FLOOR3)\n            material_OBJ_FLOOR(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_FLOOR2)\n            material_OBJ_FLOOR2(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_FLOOR4)\n            material_OBJ_FLOOR4(pos, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_CYL1||obj_id==OBJ_CYL2||obj_id==OBJ_CYL3||obj_id==OBJ_CYL4||obj_id==OBJ_CYL5||obj_id==OBJ_CYL6)//||obj_id==OBJ_CYL_top||obj_id==OBJ_CYL_bot)\n            material_OBJ_CYL(pos, norm, albedo, emission, roughness, metalness, obj_id);\n        else if(obj_id==OBJ_RR_CYL)\n            material_OBJ_RRT(pos, OBJ_RR_CYL, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_RR_CYL2)\n            material_OBJ_RRT(pos, OBJ_RR_CYL2, norm, albedo, emission, roughness, metalness);\n        else if(obj_id==OBJ_RR_CYL3)\n            material_OBJ_RRT(pos, OBJ_RR_CYL3, norm, albedo, emission, roughness, metalness);\n    }\n}\n\n//----------------------------------------------\n\n\n\n\n\n// pathtracing functions\n//----------------------------------------------\n\nfloat calculateFresnel(float cosTheta, float f0){\n    cosTheta = 1.0 - cosTheta;\n\tcosTheta = cosTheta * cosTheta * cosTheta * cosTheta * cosTheta;\n    \n    return cosTheta * (1.0 - f0) + f0;\n}\n\n#ifdef enable_reflections\nvec3 calculateReflection(vec3 ro, vec3 rd, vec3 normal, float percentSpecular, float roughness, vec3 totalLighting, float noise){\t\n#ifdef use_ConeVector\n    mat3 tbn = calculateTangentMatrix(normal);\n#endif\n    vec3 reflection = vec3(0.0);\n    float rReflectionRays = 1.0 / float(reflectionRays);\n    float fresnel = 0.0;\n\n    for (int i = 0; i < reflectionRays+ANGLE_loops; ++i){\n#ifdef use_ConeVector\n        vec3 dir = tbn * calculateRoughSpecular(fract((float(i) + noise) * rReflectionRays), reflectionRays, roughness);\n#else\n        vec3 dir = normalize(normal + 3.5*roughness*roughness*getCosineWeightedSample(normal,0.1+0.4*roughness));\n#endif\n        dir = reflect(rd, dir);\n\n        float lDotN = dot(dir, normal);\n        float f = lDotN;\n        if (lDotN <= 0.0) continue;\n\n        float lDotU = dot(dir, upVec);\n        float lDotV = dot(dir, lightDir);\n\n        fresnel += calculateFresnel(f, percentSpecular);\n\n        vec3 light = calculateSky(vec3(0.0), lDotU, lDotV);\n        \n#ifdef reflection_color_emi\n        vec3 bouncePos;\n        vec3 bounceNormal;\n        vec3 bouncedAlbedo;\n        vec3 bouncedEmissive;\n        float rayHit = get_scene_bounce_light(ro, dir, normal, bouncePos, bouncedAlbedo, bouncedEmissive, bounceNormal);\n        reflection += rayHit * light;\n        reflection += (1.-rayHit) * bouncedEmissive;\n#else\n        float rayHit = get_scene_intersect(ro, dir, normal);\n        reflection += rayHit * light;\n#endif\n    }\n    \n    reflection = reflection * rReflectionRays;\n    fresnel = fresnel * rReflectionRays;\n\n    totalLighting = mix(totalLighting, reflection, fresnel);\n\t\n\treturn totalLighting;\n}\n#endif\n//----------------------------------------------\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#ifdef move_rounds\n    float l_t = load(LOCAL_T,iChannel0);\n    rtimer = l_t;\n    float l_t_last = load(LOCAL_T_last,iChannel0);\n    rtimer_last = l_t_last;\n#ifdef move_SUN_circle_inf\n    lightDir.xz=lightDir.xz*MD(-rtimer*rspd);\n#endif\n#endif\n#ifndef use_ConeVector\n    seed = hash12(fragCoord.xy+hash21(float(iFrame%10000)*0.333)*1234.123);\n#endif\n    vec2 fc=fragCoord.xy;\n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    fragCoord.xy += halton_px_shift;\n\n    vec2 screen_uv = fc.xy / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    \n    float noise=0.; \n    \n#ifdef use_ConeVector\n    // noise for ConeVector\n    \n    ivec2 ipx = ivec2(fc);\n    ivec2 reserv = ivec2(5,MEMORY_BOUNDARY.y+5);\n    ipx=ipx%(ivec2(textureSize(iChannel0,0).xy)-reserv);\n    float n0 = texelFetch(iChannel0, textureSize(iChannel0,0).xy-ipx-1, 0).a;\n    noise = fract(n0 + 0.75*float(iFrame % 264) * c_goldenRatioConjugate);\n\n    // test hash12 as noise\n    //vec2 tfc = fc.xy+hash21(float(iFrame%10000)*0.333)*iResolution.y*2.;\n    //noise = hash12(tfc);\n    \n#endif\n\n    vec2 this_id_d = texelFetch(iChannel0, ivec2(fc), 0).xy;\n    int obj_id = int(this_id_d.x);\n    vec3 pos=ro+rd*this_id_d.y;\n    \n    bool rayHit = obj_id>0;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emission;\n    float rough;\n    float metal;\n    \n    \n    // restore normals from obj_id\n    vec3 box=-vec3(-4.0, 0.0, -7.0);\n    vec3 box2=-vec3(-1.8, 0.0, -5.0);\n    vec3 sphere3=-vec3(-3.0, -2.0, -5.51);\n    vec3 sphere2=-vec3(-7.0, -0.5, -5.51);\n    vec3 sphere=-vec3(-4.4, -0.25, -4.51);\n    vec3 quadratic_pos=vec3(1.,2.,6.);\n    \n    if(obj_id==OBJ_FLOOR||obj_id==OBJ_FLOOR2||obj_id==OBJ_FLOOR3||obj_id==OBJ_FLOOR4)normal=get_normal_OBJ_FLOOR(pos,ro);\n    if(obj_id==OBJ_CYL1)normal=get_normal_OBJ_CYL(pos-vec3(0.), 44.2, 1.);\n    if(obj_id==OBJ_CYL2)normal=get_normal_OBJ_CYL(pos-vec3(0.), 46.2, 1.);\n    if(obj_id==OBJ_CYL3)normal=get_normal_OBJ_CYL(pos-vec3(0.), 46.1, -1.);\n    if(obj_id==OBJ_CYL4)normal=get_normal_OBJ_CYL(pos-vec3(0.), 45.4, 1.);\n    if(obj_id==OBJ_CYL5)normal=get_normal_OBJ_CYL(pos-vec3(0.), 45.3, -1.);\n    if(obj_id==OBJ_CYL6)normal=get_normal_OBJ_CYL(pos-vec3(0.), 47.3, -1.);\n    //if(obj_id==OBJ_CYL_top)normal=get_normal_OBJ_CYL_top();\n    //if(obj_id==OBJ_CYL_bot)normal=get_normal_OBJ_CYL_bot();\n    if(obj_id==OBJ_RR_CYL){\n        vec3 rrt = RayTracing_Radial_Repetition(ro+RR1pos, rd, normal, RR1prm, RREP_rtc1);\n    }\n    if(obj_id==OBJ_RR_CYL2){\n        vec3 rrt = RayTracing_Radial_Repetition(ro+RR2pos, rd, normal, RR2prm, RREP_rtc2);\n    }\n    if(obj_id==OBJ_RR_CYL3){\n        vec3 rrt = RayTracing_Radial_Repetition(ro+RR3pos, rd, normal, RR3prm, RREP_rtc3);\n    }\n    \n    get_scene_material(rayHit, pos, normal, obj_id, albedo, emission, rough, metal);\n    \n    vec3 sunColor = calculateSunColor(lightDir.y);\n    vec3 color = texelFetch(iChannel1, ivec2(fc), 0).rgb;\n#ifdef enable_reflections\n    color = calculateReflection(pos, rd, normal, metal, rough, color, noise);\n#endif\n    \n\tfloat lDotU = dot(rd, upVec);\n\tfloat lDotV = dot(rd, lightDir);\n\t\n    if (!rayHit) \n    {\n        color = vec3(0.0);\n        color += calculateSun(lDotV)*calculateSunColor(lightDir.y);\n        color = calculateSky(color, lDotU, lDotV);\n#ifdef add_clouds\n        bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n#ifdef cloud_render_scale\n        if(iFrame==0||res_ch){}\n        else{\n            color = texture_Bilinear(iChannel3, fragCoord/iResolution.xy);\n            color = ACES_Inv(color);\n        }\n#else\n        if(iFrame==0||res_ch){}\n        else{color = unpack_Unormfloat3x10(texelFetch(iChannel3, ivec2(fragCoord), 0).a);}\n#endif\n#endif\n    }\n    float absorb = 0.;\n    \n#ifdef enable_textures\n    absorb = texelFetch(iChannel1, ivec2(fc), 0).a;\n#else\n#ifdef enable_volume\n    float depth = length(ro-pos);\n    absorb = exp(-depth * volume_fogDensity);\n    absorb = clamp(absorb,.25,1.);\n    absorb = 1.-(1.-smoothstep(MAX_DIST-MAX_DIST*0.1,MAX_DIST,depth))*(1.-absorb);\n#endif\n#endif\n    \n    color = max(color, 0.0);\n    bool input_registered = load(INPUT0,iChannel0)>1.;\n    fragColor = vec4(color, absorb);\n    //protection when camera go inside of shape and intersection function may return inf or nan\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); \n#ifdef use_reproject_TAA\n    // reprojection TAA\n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    if(input_registered||res_ch){\n        vec4 oldCol = previousSample(ro, pos,iChannel0, iChannel0, iChannel2, iResolution.xy);\n        float factor = (oldCol.a == 0.||res_ch) ? 0. : (rayHit ? .90 : 0.01);//limit sky reproject trails\n        fragColor.rgb = mix(fragColor.rgb, oldCol.rgb, factor);\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, oldCol.a, factor*0.75); \n#endif\n        //fragColor.a=absorb; // to disable reproj for volumtertic shadow\n    }else\n#endif\n    // default TAA\n    {\n        vec4 backColor = texture(iChannel2, screen_uv);\n        fragColor.rgb = mix(fragColor.rgb, backColor.rgb, 0.905 * (1.-float(input_registered)));\n#ifndef enable_textures\n        fragColor.a = mix(fragColor.a, backColor.a, 0.905 * (1.-float(input_registered)));\n#else\n        fragColor.a = fragColor.a; //copy BufB texture color\n#endif\n    }\n#ifndef enable_textures\n    fragColor.a=max(fragColor.a,0.00001); // reprojection flag for previousSample in Comon, it return alpha 0. when no reprojection\n#endif\n    \n}\n\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// TAA from https://www.shadertoy.com/view/DsfGWX\n\n\n#ifdef add_clouds\nvoid mainImage_cloud( out vec4 fragColor, in vec2 fragCoord);\n#endif\n\n#ifndef use_dynamic_TAA\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n#ifdef add_clouds\n    vec4 tcol;\n    mainImage_cloud(tcol,fragCoord);\n    fragColor.a=pack_Snormfloat3x10(tcol.rgb);\n#endif\n\n}\n#else\n\n#define ENABLE_TAA\n#define TEMPORAL_REPROJECT\n\n#define VARIANCE_CLIPPING\n\n// debug\n//#define SHOW_MOTION\n//#define SHOW_DISOCCLUSION\n\n// TAA\n// alpha of this shader is unused, it used to store curr_d but hist.a used only in SHOW_DISOCCLUSION\n\n// --when define enable_volume set - this Alpha used to filter absorb from BufC - so debug wont work here\n// above replaced with - now alpha used to store cloud-sky\n\n#define EPS 1e-4\n\n\n\n#define OFFSET_COUNT 4\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n \tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n/*\n#define OFFSET_COUNT 8\n\nconst ivec2 off[OFFSET_COUNT] = ivec2[OFFSET_COUNT](\n    ivec2(-1, -1), ivec2(-1,  1), \n\tivec2( 1, -1), ivec2( 1,  1), \n\tivec2( 1,  0), ivec2( 0, -1), \n\tivec2( 0,  1), ivec2(-1,  0)\n);\n*/\n\n\nvec3 rgb2ycocg(in vec3 rgb)\n{\nreturn rgb;\n    float co = rgb.r - rgb.b;\n    float t = rgb.b + co / 2.0;\n    float cg = rgb.g - t;\n    float y = t + cg / 2.0;\n    return vec3(y, co, cg);\n}\n\n\nvec3 ycocg2rgb(in vec3 ycocg)\n{\nreturn ycocg;\n    float t = ycocg.r - ycocg.b / 2.0;\n    float g = ycocg.b + t;\n    float b = t - ycocg.g / 2.0;\n    float r = ycocg.g + b;\n    return vec3(r, g, b);\n}\n\nvec3 RGBtoYCoCg(vec3 c)\n{\nreturn c;\n    //return rgb2ycocg(c);\n    return mat3(0.25, 0.5, -0.25, 0.5, 0, 0.5, 0.25, -0.5, -0.25) * c;\n}\n\nvec3 YCoCgToRGB(vec3 c)\n{\nreturn c;\n    //return ycocg2rgb(c);\n    return mat3(1, 1, 1, 1, 0, -1, -1, 1, -1) * c;\n}\n\nvec4 clipToAABB(in vec4 cOld, in vec4 cNew, in vec4 center, in vec4 halfSize)\n{\n    vec4 r = cOld - cNew;\n    vec4 m = (center + halfSize) - cNew;\n    vec4 n = (center - halfSize) - cNew;\n    \n    if (r.x > m.x + EPS)\n\t\tr *= (m.x / r.x);\n\tif (r.y > m.y + EPS)\n\t\tr *= (m.y / r.y);\n\tif (r.z > m.z + EPS)\n\t\tr *= (m.z / r.z);\n    if (r.w > m.w + EPS)\n\t\tr.w *= (m.w / r.w);\n\n\tif (r.x < n.x - EPS)\n\t\tr *= (n.x / r.x);\n\tif (r.y < n.y - EPS)\n\t\tr *= (n.y / r.y);\n\tif (r.z < n.z - EPS)\n\t\tr *= (n.z / r.z);\n    if (r.w < n.w - EPS)\n\t\tr.w *= (n.w / r.w);\n\n\treturn cNew + r;\n}\n\nvec4 SampleTextureCatmullRom(sampler2D tex, vec2 texSize, vec2 uv)\n{\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    vec2 f = samplePos - texPos1;\n\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / w12;\n\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += textureLod(tex, vec2(texPos0.x,  texPos0.y), 0.) * w0.x * w0.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos0.y), 0.) * w12.x * w0.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos0.y), 0.) * w3.x * w0.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos12.y), 0.) * w0.x * w12.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos12.y), 0.) * w12.x * w12.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos12.y), 0.) * w3.x * w12.y;\n\n    result += textureLod(tex, vec2(texPos0.x,  texPos3.y), 0.) * w0.x * w3.y;\n    result += textureLod(tex, vec2(texPos12.x, texPos3.y), 0.) * w12.x * w3.y;\n    result += textureLod(tex, vec2(texPos3.x,  texPos3.y), 0.) * w3.x * w3.y;\n\n    return result;\n}\n\nfloat distancePixel22( vec2 prevFragCoord, vec3 pos, sampler2D samplerx, vec2 ires, vec3 p_ro, vec3 p_rd){\n    if(  min(ires.xy-1., prevFragCoord) != prevFragCoord\n      || max(vec2(0.)      , prevFragCoord) != prevFragCoord) return MAX_DIST;\n    \n    float prev_d = textureLod(samplerx, prevFragCoord/ires.xy,0.).a;\n    vec3 prevPos = p_ro + p_rd*prev_d;\n    return length(prevPos-pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef move_rounds\n    float l_t = load(LOCAL_T,iChannel0);\n    rtimer = l_t;\n    float l_t_last = load(LOCAL_T_last,iChannel0);\n    rtimer_last = l_t_last;\n#endif\n    float a = .1;\n    \n    ivec2 ipx = ivec2(fragCoord);\n    \n    // adding halton_px_shift to fragCoord not needed\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec2 halton_px_shift = vec2(load(HALTON0,iChannel0),load(HALTON1,iChannel0));\n    float curr_d = textureLod(iChannel0, (fragCoord - halton_px_shift) / iResolution.xy, 0.).y;\n    vec4 curr_color = textureLod(iChannel2, (fragCoord - halton_px_shift) / iResolution.xy, 0.).rgba;\n    vec3 curr_texture_col = vec3(1.);\n    \n#ifdef enable_textures\n    //texelFetch because data packed\n    curr_texture_col = unpack_Unormfloat3x10(texelFetch(iChannel2, ivec2(fragCoord - halton_px_shift), 0).a);\n#endif\n    vec4 new = vec4(RGBtoYCoCg(curr_color.rgb*curr_texture_col),curr_color.a);\n\n#ifdef TEMPORAL_REPROJECT\n\n    vec3 ro;\n    vec3 rd;\n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    \n    vec3 pro;\n    vec3 prd;\n    SetCamera_prev(uv, iChannel0, pro, prd, iResolution.xy);\n    \n    vec3 pos = ro + rd * curr_d;\n    \n    // adding prevUv to fragCoord not needed\n    vec2 prevUv = pos2uv(pos, iChannel0, iResolution.xy);\n    vec2 prevFragCoord = prevUv * iResolution.y + iResolution.xy/2.0;\n    vec2 puv = prevFragCoord/iResolution.xy;\n    \n    \n    //vec4 hist = texture(iChannel3, puv);\n    //vec4 hist = getTextureSmooth(iChannel3, iResolution.xy, puv);\n    vec4 hist = SampleTextureCatmullRom(iChannel3, iResolution.xy, puv);\n\n    vec4 old = vec4(RGBtoYCoCg(hist.rgb),hist.a);\n#else\n    vec4 old = vec4(RGBtoYCoCg(texelFetch(iChannel3, sp, 0).rgb),texelFetch(iChannel3, sp, 0).a);\n#endif\n\n#ifdef VARIANCE_CLIPPING\n    vec4 avg = new;\n    vec4 var = new * new;\n    \n    for (int i = 0; i < OFFSET_COUNT; i++)\n    {\n        vec4 tex_data = texelFetch(iChannel2, ipx + off[i], 0);\n        vec3 tex_color = vec3(1.);\n#ifdef enable_textures\n        tex_color = unpack_Unormfloat3x10(tex_data.a);\n#endif\n        vec4 tex = vec4(RGBtoYCoCg(tex_data.rgb*tex_color),tex_data.a);\n        \n        avg += tex;\n        var += tex * tex;\n    }\n    avg /= float(OFFSET_COUNT + 1);\n    var /= float(OFFSET_COUNT + 1);\n\n    vec4 sig = sqrt(max(var - avg * avg, vec4(0)));\n    \n    const float g = 1.;\n    vec4 cmin = avg - sig * g;\n    vec4 cmax = avg + sig * g;\n    \n    #if 0\n    vec4 clip = clamp(old, cmin, cmax);\n    #else\n    vec4 clip = clipToAABB(old, clamp(avg, cmin, cmax), avg, sig);\n    #endif\n    \n    old = mix(old, clip, 1.);\n#endif\n    \n    bool res_ch = load(RES_CHANGE,iChannel0)<0.5;\n    vec4 col = iFrame != 0 || res_ch ? mix(old, new, a) : new;\n#ifdef ENABLE_TAA\n#ifdef enable_volume\n    fragColor = vec4(YCoCgToRGB(col.rgb), col.a);\n#else\n    fragColor = vec4(YCoCgToRGB(col.rgb), curr_d);\n#endif\n#else\n    fragColor = vec4(texelFetch(iChannel2, ivec2(fragCoord), 0).rgb, curr_d);\n#endif\n\n\n#ifdef SHOW_DISOCCLUSION\n\n    if (puv.x < 0. || puv.x >= 1. || puv.y < 0. || puv.y >= 1. ||\n        distance(pos, (pro+prd*hist.a)) > 2.*0.1*curr_d)\n    {\n        fragColor = vec4(1, 0, 0, curr_d);\n    }\n#endif\n\n#ifdef SHOW_MOTION\n    fragColor = vec4((fragCoord/iResolution.xy - puv) * 50., 0, curr_d);\n#endif\n\n#ifdef add_clouds\n    vec4 tcol;\n    mainImage_cloud(tcol,fragCoord);\n    fragColor.a=pack_Unormfloat3x10(tcol.rgb);\n#endif\n    fragColor.rgb=clamp(fragColor.rgb,0.,100.); // seems color can be little negative\n}\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#ifdef add_clouds\n\n\n// clouds from https://www.shadertoy.com/view/DtBGR1\n\nconst int MAX_STEPS = 128;\nconst float DRAW_DISTANCE = 300.0;\n\n\nconst float INSIDE_STEP_SIZE = 0.6;\nconst int STEP_OUTSIDE_RATIO = 2;\nconst float OUTSIDE_STEP_SIZE = INSIDE_STEP_SIZE * float(STEP_OUTSIDE_RATIO);\n\nvec3 renderSky(vec3 rd) {\n    rd = rd.xzy;\n    float lDotU = dot(rd, upVec);\n    float lDotV = dot(rd, lightDir);\n    vec3 color = calculateSun(lDotV)*calculateSunColor(lightDir.y);\n    color = calculateSky(color, lDotU, lDotV);\n    \n    float haze = pow(max(1.002 - abs(lDotU),0.002), 6.0) * (lDotV + 1.0) * 0.5;\n    \n    color = ACESFilm(color);\n    color = color*0.35+0.65*mix(color, vec3(0.99, 0.98, 0.96), clamp(haze, 0.0, 1.0));\n    \n    return color;\n}\n\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\nvec4 alphaOver(vec4 top, vec4 bottom) {\n    float A1 = bottom.a * (1.0 - top.a);\n    //A1 = bottom.a * exp(-.5-2.*top.a); //+-1.\n    float A0 = top.a + A1;\n    return vec4(\n        (top.rgb * top.a + bottom.rgb * A1) / A0,\n        A0\n    );\n}\n\n\nfloat sampleCloudMapDensity(vec3 pos) {\n    // Defines where the cloud are. Ideally this function acts a bit\n    // like a distance field - the density should not have any sharp edges in it.\n    //\n    // This function gets called a lot, so try to maximize it's performance.\n    \n    vec4 cloud_map = textureLod(iChannel1, pos.xy * 0.005, 0.0);\n    \n    float density = 0.0;\n    density = (cloud_map.r - 0.4 - abs((0.5 + pos.z - cloud_map.r * 2.0) * 0.1));\n    //density += pow(abs(cloud_map.g - p.z * 0.1), 3.);\n    density = max(density, cloud_map.b - 0.1 - abs(1.0 - cloud_map.b * 0.5 + pos.z * 0.1));\n    \n    density = max(density, 0.0);\n    density = pow(density * 2.0, 2.0);\n    \n    \n    density = min(density,0.051*(length(pos.xy)-49.));\n    \n    return density;\n}\n\n\nvec3 lightMarch(vec3 ro, vec3 rd) {\n    // Computes the lighting in the cloud at a given point\n    float lighting = 1.0;\n    float transmission = 1.0 - dot(lightDir.xzy, rd);\n    transmission += 0.1;\n    lighting *= clamp(1.0 - sampleCloudMapDensity(ro + lightDir.xzy * 1.0) * 0.2 * transmission, 0.0, 1.0); // Self\n    lighting *= clamp(1.0 - sampleCloudMapDensity(ro + lightDir.xzy * 2.0) * 0.2 * transmission, 0.0, 1.0); // Far\n    lighting *= clamp(1.0 - sampleCloudMapDensity(ro + lightDir.xzy * 4.0) * 0.2 * transmission, 0.0, 1.0); // Far\n    lighting *= clamp(1.0 - sampleCloudMapDensity(ro + lightDir.xzy * 8.0) * 0.2 * transmission, 0.0, 1.0); // Far\n    return vec3(lighting);\n}\n\n\nfloat noise(in vec3 x);\nfloat noise_texture2d(in vec3 x);\nfloat noise_local( in vec3 p ){\n    return noise(p*30.); //hash\n}\nvec4 renderScene(vec3 ro, vec3 rd) {\n    ro = ro.xzy;rd = rd.xzy;\n    vec4 accumulation = vec4(0.0, 0.0, 0.0, 0.001);\n    \n    float dist_from_camera = 0.0;\n    int steps_outside_cloud = 0;\n    \n    float noise = hash14(vec4(rd * 1000.0, iTime * 10.0));\n    \n    vec3 sky = renderSky(rd);\n        \n    for (int i=0; i<MAX_STEPS; i++) {\n        //dist_from_camera = max(dist_from_camera,10.*clamp(length(rd),0.,1.));\n        vec3 current_position = ro + (dist_from_camera + noise * INSIDE_STEP_SIZE) * rd;\n        float cloud_map = sampleCloudMapDensity(current_position);\n        \n        if (cloud_map > 0.0) {\n            if (steps_outside_cloud != 0) {\n                // First step into the cloud;\n                steps_outside_cloud = 0;\n                dist_from_camera = dist_from_camera - OUTSIDE_STEP_SIZE + INSIDE_STEP_SIZE;\n                continue;\n            }\n            steps_outside_cloud = 0;\n        } else {\n            steps_outside_cloud += 1;\n        }\n        \n        float step_size = OUTSIDE_STEP_SIZE;\n        \n        if (steps_outside_cloud <= STEP_OUTSIDE_RATIO && cloud_map > 0.0) {  \n            step_size = INSIDE_STEP_SIZE;\n            \n            float density = cloud_map * 5.0;\n\n            if (accumulation.a < 0.8) {\n                // If we are already mostly opaque, there's no point sampling extra-detail.\n                float n = noise_local(current_position * 0.05 + vec3(0,iTime * 0.02,0));\n                density -= pow(n, 3.0) * 3.0;\n            } else {\n                density -= 0.5;\n            }\n            density *= step_size;\n            density = clamp(density, 0.0, 1.0);\n            \n            float fog = pow(1.0 - (dist_from_camera / DRAW_DISTANCE), 0.5);\n                        \n            vec3 lighting = lightMarch(current_position, rd);\n            \n            vec3 cloud_color = mix(\n                sky,\n                lighting,\n                clamp(fog, 0.0, 1.0)\n            );\n            \n            accumulation = alphaOver(accumulation, vec4(cloud_color, density));\n            \n        }\n        \n\n        dist_from_camera += step_size;\n        \n        if (accumulation.a > 0.98 || dist_from_camera > DRAW_DISTANCE) {\n            break;\n        }\n    }\n    \n    return vec4(alphaOver(accumulation, vec4(sky, 1.0)).rgb, dist_from_camera);\n}\n\n\nvoid mainImage_cloud( out vec4 fragColor, in vec2 fragCoord)\n{\n#ifdef move_rounds\n    float l_t = load(LOCAL_T,iChannel0);\n    rtimer = l_t;\n    float l_t_last = load(LOCAL_T_last,iChannel0);\n    rtimer_last = l_t_last;\n#ifdef move_SUN_circle_inf\n    lightDir.xz=lightDir.xz*MD(-rtimer*rspd);\n#endif\n#endif\n\n#ifdef cloud_render_scale\n    fragCoord = floor(fragCoord)*vec2(rscale)+0.5;\n    fragColor = vec4(0.);\n    if(any(greaterThan(fragCoord,iResolution.xy)))return;\n#endif\n\n    vec3 ro; vec3 rd;\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    SetCamera(uv, iChannel0, ro, rd, iResolution.xy);\n    //ro.y+=-6.;\n    fragColor = renderScene(ro, rd);\n    \n    fragColor = clamp(fragColor, 0., 1.);\n    \n}\n\n\n\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n#endif\n\n\n\n","name":"Buffer D","description":"","type":"buffer"}]}