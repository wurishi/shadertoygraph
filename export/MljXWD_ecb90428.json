{"ver":"0.1","info":{"id":"MljXWD","date":"1443901480","viewed":208,"name":"Projected Sphere Radius","username":"jeannekamikaze","description":"Equation for the radius of a circle approximating the projection of a sphere.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere","circle","projection","radius"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define TO_RAD 0.01745329251\n\nfloat fovy = 60.0;\nfloat near = 1.0;\nfloat far  = 2.0;\n\nvec3  sphere_center = vec3(0,0,-230);\nfloat sphere_radius = 50.0;\n\nfloat r = iResolution.x / iResolution.y;\n\nvec3 L = vec3(0.1, 0.1, 1.0);\n\n// compute radius of circle approximating the projection of the sphere\nfloat circle_radius (float sphere_radius, float z, float fovy, float r)\n{\n    float c = 1.0 / tan(fovy*TO_RAD/2.0);\n    //return sphere_radius * -c*(1.0+r)/(4.0*r*z);\n    return sphere_radius * -c*(1.0+r) / (r*r*r*z);\n}\n\nmat4 projection (float fovy, float aspect, float near, float far)\n{\n    float f = 1.0 / tan(fovy*TO_RAD/2.0);\n    return mat4\n        (f/aspect, 0, 0, 0\n        ,0 , f, 0, 0\n        ,0, 0, (near+far)/(near-far), -1\n        ,0, 0, 2.0*near*far/(near-far), 0);\n}\n\n// project from view space to texture space\nvec2 project (vec3 p)\n{\n    vec4 clip = projection(fovy, r, near, far) * vec4(p, 1.0);\n    vec4 ndc  = clip / clip.w;\n    return ndc.xy*0.5 + 0.5;\n}\n\nvec3 intersect_sphere (vec3 ray_dir)\n{\n    vec3 t; // x = tmin, y = tmax, z = {>0, intersection, <0 no intersection}\n    t.z = -1.0;\n    vec3 l = sphere_center - vec3(0); // ray centered at (0,0,0)\n    float l2 = dot(l,l);\n    float r2 = sphere_radius * sphere_radius;\n    float p = dot (l, ray_dir);\n    if (p < 0.0) return t; // no intersection\n    float a2 = l2 - p*p;\n    if (a2 < r2)\n    {\n        float k = sqrt(r2 - a2);\n        t.x = p-k;\n        t.y = p+k;\n        t.z = 1.0;\n        return t;\n    }\n    return t; // no intersection\n}\n\nvec3 cam_ray (vec2 texcoord)\n{\n    float d = 0.5 / tan(fovy*TO_RAD/2.0);\n    return normalize(vec3((texcoord.x - 0.5) * r, texcoord.y - 0.5, -d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 texcoord = fragCoord.xy / iResolution.xy;\n    \n    // intersect sphere\n    sphere_center = sphere_center\n                  + vec3(40.0*sin(1.5*t), -30.0*cos(2.7*t), 190.0*sin(0.7*t)*cos(pow(t,1.05)));\n    vec3 ray = cam_ray(texcoord);\n    vec3 intersection = intersect_sphere(ray);\n    \n    // circle center and radius\n    float projected_sphere_radius = circle_radius(sphere_radius, sphere_center.z, fovy, r);\n    vec2  projected_center = project(sphere_center);\n    \n    vec3 colour = vec3(0);\n    \n    // shade based on whether there is intersection with the sphere\n    vec3 albedo = 1.3 * vec3(1.2, 1.4, 1.1);\n    if (intersection.z > 0.0)\n    {\n        vec3 pmin = ray * intersection.x;\n        vec3 normal = normalize(pmin-sphere_center);\n        vec3 k = albedo * texture(iChannel1, normal).rgb;\n        vec3 s = texture(iChannel0, reflect(ray,normal)).rgb;\n        colour += mix(k*dot(normal, normalize(L)), s, 0.3);\n    }\n    else colour = texture(iChannel0, ray).rgb;\n    \n    // shade based on whether the fragment is within the projection of the sphere\n    vec2 v = (texcoord - projected_center) * vec2(r, 1.0);\n    float vv = dot(v,v);\n    float R2 = projected_sphere_radius*projected_sphere_radius;\n    if (vv <= R2 && vv >= 0.8*R2)\n        colour *= vec3(1.2, 1.7, 0.3);\n    \n    fragColor = vec4(colour, 1.0);\n}","name":"","description":"","type":"image"}]}