{"ver":"0.1","info":{"id":"4tKBDw","date":"1542795706","viewed":374,"name":"DrawSphere","username":"wenyu","description":"DrawSphere","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["drawsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\nmat3 Rotate(vec3 euler)\n{\n\t//欧拉角 h - p - b\n    return mat3(\n    \t\n        cos(euler.y) * cos(euler.z) + sin(euler.y) * sin(euler.x) * sin(euler.z),\n        -cos(euler.y) * sin(euler.z) + sin(euler.y) * sin(euler.x) * cos(euler.z),\n        sin(euler.y) * cos(euler.x),\n        sin(euler.z) * cos(euler.x),\n        cos(euler.z) * cos(euler.x),\n        -sin(euler.x),\n        -sin(euler.y) * cos(euler.z) + cos(euler.y) * sin(euler.x) * sin(euler.z),\n        sin(euler.z) * cos(euler.y) + cos(euler.y) * sin(euler.x) * cos(euler.z),\n        cos(euler.y) * cos(euler.x)    \n    );\n    \n}\n\nvec3 DiffuseLightColor(vec3 worldNormal, vec3 lightColor, vec3 lightDir)\n{\n    //漫反射光\n    vec3 diffuse = lightColor * max(0.0 , dot(worldNormal,lightDir));\n    return diffuse;\n}\n\nvec3 SpecularLightColor(vec3 worldNormal, vec3 lightColor, vec3 lightDir, vec3 viewDir, float specularGloss)\n{\n\n    //高光phong\n    vec3 h = normalize(viewDir + lightDir);\n    vec3 specular = lightColor * pow(max(0.0,dot(h,worldNormal)),specularGloss);\n    \n    return specular;\n}\n\n\nvec4 Render(vec2 fragCoord , float radius)\n{\n    \n    //坐标从【0,fragCoordTrans】~【-fragCoordTrans,fragCoordTrans】\n\tvec2 fragCoordTrans = (fragCoord * 2.0 - iResolution.xy);\n    \n    //每一个像素的在球面上的三维坐标\n    vec3 pos = vec3(fragCoordTrans,0);\n    //z的平方\n    float z_Square = radius * radius - dot(pos.xy,pos.xy);\n    if( z_Square <= .0)\n        return vec4(.0,.0,.0,.0);\n    pos.z = sqrt(z_Square);\n        \n    //法线向量\n    vec3 normalDir = normalize(pos - vec3(0.0));\n    //灯光方向\n    vec3 lightDir = vec3(1.0,1.0,1.0);\n    //灯光颜色\n    vec3 lightColor = vec3(1.0,1.0,0.0) * 0.2;\n    //相机位置\n    vec3 cameraPos = vec3(0,0,-10);\n\t//视线方向\n    vec3 viewDir = normalize(cameraPos - pos);\n    \n    //环境光\n    vec3 ambient = vec3(0.0); \n    //自发光 \n    \n   \tpos *= Rotate(vec3(.0,1.0 * iTime,.0));\n    float lon = atan(pos.x/pos.z);\n    lon -= PI * step(pos.z,.0);\n    float lat = acos(pos.y/radius);\n    \n    vec2 uv = vec2(lon,lat) / vec2(PI * 2.0,-PI);\n    vec3 emission = texture(iChannel0,uv).rgb;\n    //漫反射 - 兰伯特\n    vec3 diffuseCol = DiffuseLightColor(normalDir,lightColor,lightDir);\n    //高光\n    vec3 specularCol = SpecularLightColor(normalDir,lightColor,lightDir,viewDir,3.0);\n    \n    vec3 color = ambient + emission + diffuseCol + specularCol;\n    return vec4(color,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 lightCol = Render(fragCoord.xy ,iResolution.y).xyz;\n\tvec3 col = lightCol;\n    \n    // Output to screen\n    fragColor =vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}