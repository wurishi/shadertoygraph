{"ver":"0.1","info":{"id":"csdXRB","date":"1681861521","viewed":38,"name":"Ray Traced Spheres with Lighting","username":"BhamMuseum","description":"Some Ray Traced spheres with Phong Lighting","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytraced"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ball\n{\n    vec3  position;\n    float radius;\n    vec3  color;\n};\n\nstruct AmbientLight\n{\n    vec3  color;\n    float strength;\n};\n\nstruct PointLight\n{\n    vec3  position;\n    vec3  color;\n};\n\nstruct Camera\n{\n\tvec3 position;\n    vec3 lookAt;\n};\n    \nstruct Ray\n{\n    vec3 origin; // start\n    vec3 dir;\t // direction from start (should generally be normalized)\n};\n    \nfloat calculateDistanceFromRayToPoint( Ray ray, vec3 point )\n{\n    vec3 nearestPointOnRay = ray.origin + ray.dir*dot(point-ray.origin, ray.dir);\n    float distance = length(nearestPointOnRay-point);\n    return distance;\n}\n\nvec3 calculateNearestPointOfRayToPoint( Ray ray, vec3 point )\n{\n    vec3 nearestPointOnRay = ray.origin + ray.dir*dot(point-ray.origin, ray.dir);\n    return nearestPointOnRay;\n}\n\nvec3 calculatePixel( vec3 position, vec3 normal, vec3 materialColor, \n                     AmbientLight ambientLight, PointLight pointLight )\n{\n\t // Ambient\n    vec3 ambient = ambientLight.color * ambientLight.strength;\n\n    // Diffuse (from PointLight)\n    vec3 toLight = pointLight.position - position;\n    toLight = normalize(toLight);\n    float intensity = dot( normal, toLight );\n    float diff = max(0.0, intensity);\n    vec3 diffuse = diff*pointLight.color;\n\n    // Specular\n    float specularStrength = 1.0;     // specular intensity. Move to top\n    float specularPower = 64.0;       // Shininess\n\n    vec3 viewDir = vec3(0.0,0.0,1.0); // Looking straight forwards\n\n    vec3 reflectDir = reflect( toLight, normal );\n    float spec = max( 0.0, dot(viewDir, reflectDir) );\n    spec = pow( spec, specularPower );\n    float specular = specularStrength * spec;\n\n    // Add up all light contributions\n    vec3 color = (ambient + diffuse + specular) * materialColor;    \n\n    return color;\n}\n\n\nfloat g_screenDistance = 1.0; // How far 2d-screen is from camera\n\n#define MAX_OBJECT_DIST 50.0\n\nconst float numBalls = 7.0;\nfloat angleInc = 0.11*3.14159;\n\nfloat getDistanceToNearestObject( vec3 pos )\n{\n    float nearestDistance = MAX_OBJECT_DIST;\n    for( float ballNum=0.0; ballNum<numBalls; ballNum+=1.0)\n    {\n        vec3 ballPos = vec3( 3.0*sin(iTime + ballNum*angleInc), 0.0, 5.0 + 3.0*cos(iTime + ballNum*angleInc));\n        \n        float ballDistance = length(ballPos - pos)- 0.5; // dist to ball - radius\n        \n\t\tif( nearestDistance > ballDistance )\n            nearestDistance = ballDistance;\n    }\n    \n    return nearestDistance;\n}\n\n#define MAX_RAYMARCH_STEPS 100\n#define MAX_RAYMARCH_DIST 100.0\n#define SURFACE_DISTANCE_MIN_THRESHOLD 0.01\nfloat rayMarch( Ray ray )\n{\n    float distance = 0.0;\n    \n    for( int n=0; n<MAX_RAYMARCH_STEPS; n++ )\n    {\n        vec3 pos = ray.origin + ray.dir*distance;\n        float nearestObjectDistance = getDistanceToNearestObject(pos);\n        distance += nearestObjectDistance;\n        if( distance > MAX_RAYMARCH_DIST || nearestObjectDistance < SURFACE_DISTANCE_MIN_THRESHOLD )\n            break;\n    }\n    return distance;\n}\n\n#define EPSILON 0.01\nvec3 calculateNormal( vec3 pos )\n{\n    float distance = getDistanceToNearestObject(pos);\n    vec3 normal = vec3( distance - getDistanceToNearestObject(pos - vec3(EPSILON, 0.0, 0.0)),\n       \t\t\t\t\tdistance - getDistanceToNearestObject(pos - vec3(0.0, EPSILON, 0.0)),\n\t\t\t\t\t\tdistance - getDistanceToNearestObject(pos - vec3(0.0, 0.0, EPSILON)) );\n\treturn normalize(normal);    \n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy; // *2.0 -1.0;\n    uv -= 0.5;\t                        //from -0.5,-0.5 to 0.5,0.5\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera\n    // ------\n    Camera camera = Camera( vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 0.0, 1.0) );\n    vec3 camLookDir = normalize( camera.lookAt - camera.position );\n    \n    // Lights\n    // ------\n    AmbientLight ambientLight = AmbientLight( vec3(255.0/255.0, 255.0/255.0, 255.0/255.0),\n                                              0.2);\n\n    PointLight pointLight = PointLight( vec3(2.0, 5.0, 1.0),\n                                    \tvec3(255.0/255.0, 255.0/255.0, 255.0/255.0) );\n\n    Ray ray = Ray( camera.position, \n    \t\t\t   normalize( vec3(uv.x, uv.y, g_screenDistance) - camera.position) );\n\n    float distance = rayMarch( ray );\n    \n    vec3 pos = ray.origin + ray.dir*distance;\n    vec3 normal = calculateNormal(pos);\n\tvec3 color = calculatePixel( pos, normal, vec3(204.0/255.0, 151.0/255.0, 151.0/255.0), ambientLight, pointLight );\n    \n    vec3 reflectionDir = reflect( ray.dir, normal );\n    vec3 reflectionEnvMapColor = texture( iChannel0, reflectionDir ).rgb;\n\n\tfragColor = vec4( color, 1.0 );\n\tfragColor = vec4( reflectionEnvMapColor, 1.0 );\n    \n    float shininess = 1.0;\n    vec3 totalCol = color*1.0 + reflectionEnvMapColor*.5 * shininess;\n    \n\tfragColor = vec4( totalCol, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}