{"ver":"0.1","info":{"id":"dscBzS","date":"1697980993","viewed":56,"name":"HappyBirthday!!","username":"Eddy","description":"Happy Birthday!!","likes":3,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","volumetric","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MATERIAL_DISH 0.0\n#define MATERIAL_DESK 1.0\n#define MATERIAL_CANDLE 2.0\n#define MATERIAL_CAKE 3.0\n#define MATERIAL_ROOM 4.0\n#define MATERIAL_DESK_FOOT 5.0\n#define MATERIAL_STRAWBERRY 6.0\n#define MATERIAL_FLAME 7.0\n#define MATERIAL_SPOTLIGHT 8.0\n#define MATERIAL_PARTICLE 9.0\n#define MATERIAL_BOARD 10.0\n\n#define time iTime\n\nfloat pi = acos(-1.0);\nfloat jitter = 0.0;\nfloat ft;\nfloat pAt = 0.0;\n\nfloat random1d1d(float v)\n{\n    return fract(sin(v * 924.5326) * 12457.214);\n}\n\nfloat random1d2d(vec2 p){\n    return fract(sin(dot(p.xy, vec2(12.575, 78.2356)))*43578.2356);\n}\n\nfloat random3d1d(vec3 v) { \n\treturn fract(sin(dot(v, vec3(12.9898, 78.233, 19.8321))) * 43758.5453);\n}\n\nfloat valueNoise(vec3 v) {\n\tvec3 i = floor(v);\n\tvec3 f = smoothstep(0.0, 1.0, fract(v));\n\treturn  mix(\n\t\tmix(\n\t\t\tmix(random3d1d(i), random3d1d(i + vec3(1.0, 0.0, 0.0)), f.x),\n\t\t\tmix(random3d1d(i + vec3(0.0, 1.0, 0.0)), random3d1d(i + vec3(1.0, 1.0, 0.0)), f.x),\n\t\t\tf.y\n\t\t),\n\t\tmix(\n\t\t\tmix(random3d1d(i + vec3(0.0, 0.0, 1.0)), random3d1d(i + vec3(1.0, 0.0, 1.0)), f.x),\n\t\t\tmix(random3d1d(i + vec3(0.0, 1.0, 1.0)), random3d1d(i + vec3(1.0, 1.0, 1.0)), f.x),\n\t\t\tf.y\n\t\t),\n\t\tf.z\n\t);\n}\n\nfloat fbm(vec3 v) {\n\tfloat n = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < 5; i++) {\n\t\tn += a * valueNoise(v);\n\t\tv *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn n;\n}\n\nvec3 hsv2rgb(float h, float s, float v){\n    vec3 rgb = clamp(abs(mod(h * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return v * mix(vec3(1.0), rgb, s);\n}\n\nvec2 random2dPolar(float n){\n    float x = fract(sin(n*546.25)*222.223)*pi*2.0;\n    float y = (fract(sin(n*222.25)*622.223) - 0.5)*5.0;\n\n    return vec2(cos(x), sin(x))*y;\n}\n\nvec2 random2d(float n){\n    float x = (fract(sin(n*246.25)*422.223) - 0.5)*2.0;\n    float y = (fract(sin(n*522.25)*722.223) - 0.5)*2.0;\n\n    return vec2(x, y);\n}\n\n// Coding a fireworks effect : https://www.youtube.com/watch?v=xDxAnguEOn8\nfloat explode(vec2 pos, float t, float coef){\n    float c = 0.0;\n\n    for(float i = 0.0; i <= 10.0; i+=1.0){\n        vec2 dir = random2dPolar(i+floor(t)+coef*100.0);\n        vec2 p = pos - dir*t;\n        float d = dot(p, p);\n        float b = mix(0.0, 0.0005, smoothstep(1.0, 0.0, t));\n        c += b/d;\n    }\n\n    return c;\n}\n\n\nmat2 rotate(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat bounceOut(float t) {\n\tconst float a = 4.0 / 11.0;\n\tconst float b = 8.0 / 11.0;\n\tconst float c = 9.0 / 10.0;\n\t\n\tconst float ca = 4356.0 / 361.0;\n\tconst float cb = 35442.0 / 1805.0;\n\tconst float cc = 16061.0 / 1805.0;\n\t\n\tfloat t2 = t * t;\n\t\n\treturn t < a\n\t\t? 7.5625 * t2\n\t\t: t < b\n\t\t? 9.075 * t2 - 9.9 * t + 3.4\n\t\t: t < c\n\t\t? ca * t2 - cb * t + cc\n\t\t: 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\nfloat easeInOutExpo(float t) {\n    if (t == 0.0 || t == 1.0) {\n        return t;\n    }\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * pow(2.0, 10.0 * (t - 1.0));\n    } else {\n        return 0.5 * (-pow(2.0, -10.0 * (t - 1.0)) + 2.0);\n    }\n}\n\nfloat linearStep(float start, float end, float t){\n    return clamp((t - start)/(end - start), 0.0, 1.0);\n}\n\nvec2 polarMod(vec2 p, float r)\n{\n    float a =  pi / r - atan(p.x, p.y);\n    float n = (pi * 2.0) / r;\n    a = floor(a/n)*n;\n    return p * rotate(-a);\n}\n\nvec2 optionMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x) ? a : b;\n}\n\nfloat smoothMin(float a, float b, float k){\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// https://neort.io/art/c78r3o43p9f3hsjeassg\nfloat sdSphere(vec3 iPos, vec3 fPos, vec3 c){\n    float r = random3d1d(iPos + c);\n    if(r > 0.95){\n        r = fract(sin(r)) * 0.01;\n    }\n    else{ \n        r =- 0.5;\n    }\n\n    return length(fPos - c) - r;\n}\n\n// https://neort.io/art/c78r3o43p9f3hsjeassg\nfloat sdSphereR(vec3 p){\n    float d = 0.0;\n    p.y += time * 2.4;\n    vec3 iPos = floor(p);\n    vec3 fPos = fract(p);\n\n    d += sdSphere(iPos, fPos, vec3(0.0, 0.0, 0.0));\n    d = min(d, sdSphere(iPos, fPos, vec3(0.0, 0.0, 1.0)));\n    d = min(d, sdSphere(iPos, fPos, vec3(0.0, 1.0, 0.0)));\n    d = min(d, sdSphere(iPos, fPos, vec3(1.0, 0.0, 0.0)));\n    d = min(d, sdSphere(iPos, fPos, vec3(1.0, 1.0, 0.0)));\n    d = min(d, sdSphere(iPos, fPos, vec3(1.0, 0.0, 1.0)));\n    d = min(d, sdSphere(iPos, fPos, vec3(0.0, 1.0, 1.0)));\n    d = min(d, sdSphere(iPos, fPos, vec3(1.0, 1.0, 1.0)));\n\n    return d;\n}\n\nvec2 sdDish(vec3 p){\n    p.y += 0.2;\n    float d = sdCappedCylinder(p, 0.01, 1.5);\n    d = smoothMin(d, sdCappedCylinder(p - vec3(0.0, 0.2, 0.0), 0.04, 3.0), 0.25);\n\n    vec3 p1 = p;\n    p1.xz = polarMod(p1.xz, 40.0);\n    d = smoothMin(d, sdSphere(p1 - vec3(0.0, 0.2, 3.0), 0.02), 0.3);\n\n    vec3 p2 = p;\n    p2.xz *= rotate(pi*0.025);\n    p2.xz = polarMod(p2.xz, 10.0);\n    d = smoothMin(d, sdSphere(p2 - vec3(0.0, 0.3, 3.0), 0.02), 0.3);\n    return vec2(d, MATERIAL_DISH);\n}\n\nvec2 sdCake(vec3 p){\n    p.y -= 1.0;\n    float d = sdCappedCylinder(p, 1.0, 2.0);\n\n    vec3 p1 = p;\n    p1.xz = polarMod(p1.xz, 120.0);\n    d = smoothMin(d, sdSphere(p1 - vec3(0.0, 0.7, 2.0), 0.2), 0.6);\n    vec3 p2 = p;\n    p2.xz *= rotate(pi*0.25);\n    p2.xz = polarMod(p2.xz, 100.0);\n    d = smoothMin(d, sdSphere(p2 - vec3(0.0, -0.6, 2.0), 0.4), 0.8);\n\n    p.y -= 1.0;\n    d = smoothMin(d, sdCappedCylinder(p, 1.0, 1.0), 0.6);\n    \n    vec3 p3 = p;\n    p2.xz *= rotate(pi*0.25);\n    p3.xz = polarMod(p3.xz, 100.0);\n    d = smoothMin(d, sdSphere(p3 - vec3(0.0, 0.8, 0.8), 0.2), 0.5);\n\n    vec3 p4 = p;\n    p4.xz *= rotate(pi*0.025);\n    p4.xz = polarMod(p4.xz, 12.0);\n    p4.z -= 1.7;\n    p4.xz = polarMod(p4.xz, 12.0);\n    p4 -= vec3(0.0, 0.2, 0.1);\n\n    d = smoothMin(d, sdSphere(p4, 0.1), 0.2);\n\n    return vec2(d, MATERIAL_CAKE);\n}\n\nvec2 sdCakeDecorate(vec3 p)\n{\n    vec2 d = vec2(10e8);\n    vec3 p1 = p;\n    p1.xz *= rotate(pi*0.025);\n    p1.xz = polarMod(p1.xz, 12.0);\n    float berry = 10e8;\n    berry = min(berry, sdSphere(p1 - vec3(0.0, 2.3, 1.7), 0.2));\n    berry = smoothMin(berry, sdSphere(p1 - vec3(0.0, 2.6, 1.7), 0.01), 0.3);\n    d = optionMin(d, vec2(berry, MATERIAL_STRAWBERRY));\n\n    return d;\n}\n\nvec2 sdFlame(vec3 p)\n{\n    vec2 d = vec2(10e8);\n    vec3 p1 = p;\n\n    float tF = linearStep(27.0, 28.0, ft);\n    float fRadius1 = 0.12 - mix(0.0, 0.12, easeInOutExpo(tF));\n    float fRadius2 = 0.06 - mix(0.0, 0.06, easeInOutExpo(tF));\n    float flame1 = 10e8;\n    flame1 = min(flame1, sdSphere(p1 - vec3(0.0, 3.85, 0.0), fRadius1));\n    flame1 = smoothMin(flame1, sdSphere(p1 - vec3(sin(time + floor(length(p1.x)))*0.1, 3.9 + (fract(time*2.0)*0.2 + 0.1)*0.8, 0.0), fRadius2  * (1.0 - fract(time*1.0))), 0.2 * (1.0 - fract(time*1.0)));\n    d = optionMin(d, vec2(flame1, MATERIAL_FLAME));\n\n    vec3 p2 = p;\n    p2.xz *= rotate(pi*0.025);\n    p2.xz = polarMod(p2.xz, 6.0);\n    float flame2 = 10e8;\n    float fRadius3 = 0.05 - mix(0.0, 0.05, easeInOutExpo(tF));\n    float fRadius4 = 0.04 - mix(0.0, 0.04, easeInOutExpo(tF));\n    flame2 = min(flame2, sdSphere(p2 - vec3(0.0, 3.45, 0.8), fRadius3));\n    flame2 = smoothMin(flame2, sdSphere(p2 - vec3(sin(time + random1d1d(floor(p2.x) * 100.0))*0.05, 3.55 + (fract(time*2.0 + floor(p2.x))*0.2 + 0.1)*0.4, 0.8), fRadius4 * (1.0 - fract(time*1.0))), 0.2  * (1.0 - fract(time*1.0)));\n    d = optionMin(d, vec2(flame2, MATERIAL_FLAME));\n    return d;\n}\n\nvec2 sdCandle(vec3 p){\n    p.y -= 2.0;\n    float d = sdCappedCylinder(p, 1.8, 0.1);\n\n    vec3 p1 = p;\n    p1.xz *= rotate(pi*0.025);\n    p1.xz = polarMod(p1.xz, 6.0);\n    d = min(d, sdCappedCylinder(p1 - vec3(0.0, 0.0, 0.8), 1.4, 0.06));\n    \n    return vec2(d, MATERIAL_CANDLE);\n}\n\nvec2 sdDesk(vec3 p){\n    p.y += 0.4;\n    float d = sdBox(p, vec3(4.8, 0.05, 4.8));\n    return vec2(d, MATERIAL_DESK);\n}\n\nvec2 sdDeskFoot(vec3 p)\n{\n    float d = 10e8;\n    p.y += 3.4;\n    d = smoothMin(d, sdBox(p - vec3(4.5, 0.0, 4.5), vec3(0.5, 3.0, 0.5)), 0.2);\n    d = smoothMin(d, sdBox(p - vec3(4.5, 0.0, -4.5), vec3(0.5, 3.0, 0.5)), 0.2);\n    d = smoothMin(d, sdBox(p - vec3(-4.5, 0.0, 4.5), vec3(0.5, 3.0, 0.5)), 0.2);\n    d = smoothMin(d, sdBox(p - vec3(-4.5, 0.0, -4.5), vec3(0.5, 3.0, 0.5)), 0.2);\n\n    d = smoothMin(d, sdBox(p - vec3(0.0, 2.6, -4.5), vec3(5.0, 0.5, 0.5)), 0.2);\n    d = smoothMin(d, sdBox(p - vec3(0.0, 2.6, 4.5), vec3(5.0, 0.5, 0.5)), 0.2);\n    d = smoothMin(d, sdBox(p - vec3(-4.5, 2.6, 0.0), vec3(0.5, 0.5, 5.0)), 0.2);\n    d = smoothMin(d, sdBox(p - vec3(4.5, 2.6, 0.0), vec3(0.5, 0.5, 5.0)), 0.2);\n\n    return vec2(d, MATERIAL_DESK_FOOT);\n}\n\nvec2 sdSpotLight(vec3 p, vec3 offset)\n{\n    vec2 d = vec2(10e8);\n\n    float lightLen = 30.0;\n    vec3 p1 = p - offset;\n    float fR = easeInOutExpo(linearStep(1.0, 2.0, ft));\n    float r = mix(0.0, 0.3 + length(p1) * 0.3, fR);\n    d = optionMin(d, vec2(sdCappedCylinder(p1 + vec3(0.0, lightLen, 0.0), lightLen, r), MATERIAL_SPOTLIGHT));\n\n    return d;\n}\n\nvec2 sdBoard(vec3 p)\n{\n    float tB= linearStep(7.0, 17.0, ft);\n    vec2 d = vec2(10e8);\n\n    p.y -= 40.0;\n    float yPos = 40.0 * tB;\n    p.y += yPos;\n    float bFrame = 10e8;\n    bFrame = min(bFrame, sdBox(p - vec3(0.0, 5.0, 15.0), vec3(20.0, 10.0, 1.5)));\n    bFrame = min(bFrame, sdBox(p - vec3(10.0, 40.0, 15.0), vec3(0.5, 40.0, 1.5)));\n    bFrame = min(bFrame, sdBox(p - vec3(-10.0, 40.0, 15.0), vec3(0.5, 40.0, 0.5)));\n    bFrame = max(bFrame, -sdBox(p - vec3(0.0, 5.0, 15.0), vec3(20.0, 10.0, 1.7)));\n    d = optionMin(d, vec2(bFrame, MATERIAL_DESK_FOOT));\n\n    d = optionMin(d, vec2(sdBox(p - vec3(0.0, 5.0, 15.0), vec3(20.0, 10.0, 0.8)), MATERIAL_BOARD));\n\n    return d;\n}\n\nvec2 distanceFunction(vec3 p)\n{\n    vec2 d = vec2(10e8, 0.0);\n    d = optionMin(d, sdDish(p));\n    d = optionMin(d, sdCake(p));\n    d = optionMin(d, sdCandle(p));\n    d = optionMin(d, sdFlame(p));\n    d = optionMin(d, sdCakeDecorate(p));\n    d = optionMin(d, sdDesk(p));\n    d = optionMin(d, sdDeskFoot(p));\n    d = optionMin(d, sdBoard(p));\n\n    vec2 b3 = vec2(-sdBox(p - vec3(0.0, 20.0, 0.0), vec3(60.0, 30.0, 60.0)), MATERIAL_ROOM);\n    d = optionMin(d, b3);\n\n    d = optionMin(d, vec2(sdSphereR(p), MATERIAL_PARTICLE));\n\n    pAt += 0.01/(0.01 + abs(sdSphereR(p)));\n\n    return d;\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 err = vec2(0.001, 0.0);\n    return normalize(vec3(\n        distanceFunction(p + err.xyy).x - distanceFunction(p - err.xyy).x,\n        distanceFunction(p + err.yxy).x - distanceFunction(p - err.yxy).x,\n        distanceFunction(p + err.yyx).x - distanceFunction(p - err.yyx).x\n    ));\n}\n\nvec3 volumetric(vec3 p){\n    vec3 col = vec3(0.0);\n    col += fbm(p + vec3(time*0.92, 0.0, 0.0)) * 0.02;\n    return col;\n}\n\nvec3 roomVolumetric(vec3 p){\n    vec2 uv = p.xz * 1.0;\n\n    vec3 col = vec3(0.0);\n    vec2 grid = smoothstep(0.45, 0.4, fract(uv) - 0.5);\n    vec2 cell = floor(uv);\n    col += min(grid.x, grid.y);\n    col *= vec3(random1d2d(cell + 78.214), random1d2d(cell + 38.214), random1d2d(cell + 57.214));\n    return col;\n}\n\nfloat getAO(vec3 p, vec3 n){\n    float occ = 0.0;\n    float sca = 1.0;\n\n    for(int i = 0; i < 5; i++){\n        float h = 0.01 + 0.12 * float(i) / 4.0;\n        float d = distanceFunction(p + h * n).x;\n        occ += (h - d) * sca;\n        if(occ > 0.35){\n            break;\n        }\n    }\n\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0) * (0.5 + 0.5 * n.y);\n}\n\nfloat getSoftShadow(vec3 camPos, vec3 rayDir, float tMin, float tMax){\n    float tp = (0.8 - camPos.y) / rayDir.y;\n    if(tp > 0.0){\n        tMax = min(tMax, tp);\n    }\n\n    float res = 1.0;\n    float t = tMin;\n    for(int i = 0; i < 24; i++){\n        float h = distanceFunction(camPos + rayDir * t).x;\n        float s = clamp(8.0 * h / t, 0.0, 1.0);\n        res = min(res, s * s * (3.0 - 2.0 * s));\n        t += clamp(h, 0.02, 0.2);\n        if(res < 0.004 || tMax < t){\n            break;\n        }\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 material(vec3 p, vec3 n, vec3 rayDir, vec2 df, float fog){\n    vec3 color = vec3(0.0);\n    vec3 roomColor = vec3(1.0);\n    float metalic = 0.0;\n    vec3 albedo = vec3(0.0);\n    vec3 emissive = vec3(0.0);\n\n    if(df.y == MATERIAL_DISH){\n        albedo = mix(vec3(0.6549, 0.6784, 0.5059), vec3(1.0, 1.0, 1.0), fbm(vec3(length(p)*100.0)));\n        metalic = 0.3;\n        emissive = vec3(0.6)*pow(length(p.xz * 0.37), 10.0);\n    }\n    if(df.y == MATERIAL_DESK){\n        albedo = mix(vec3(0.0, 0.0, 0.0), vec3(0.8745, 0.4549, 0.1098), fbm(vec3(p.x, p.yy)));\n    }\n    if(df.y == MATERIAL_CANDLE){\n        albedo = vec3(0.7294, 0.8745, 0.8353);\n        emissive = vec3(0.4);\n    }\n    if(df.y == MATERIAL_CAKE){\n        albedo = vec3(1.0);\n        emissive = vec3(0.4);\n    }\n    if(df.y == MATERIAL_ROOM){\n        vec3 rp = p * 0.25;\n        albedo += roomVolumetric(rp);\n        albedo += 2.0 / (2.0 + length(p.xz));\n        metalic = 0.8;\n    }\n    if(df.y == MATERIAL_DESK_FOOT){\n        albedo = vec3(1.0);\n        metalic = 0.9;\n        emissive = vec3(0.4);\n    }\n    if(df.y == MATERIAL_STRAWBERRY){\n        albedo = vec3(0.9294, 0.0863, 0.0863);\n        metalic = 0.1;\n        emissive = vec3(0.4039, 0.0275, 0.0275);\n    }\n    if(df.y == MATERIAL_FLAME){\n        albedo = mix(vec3(0.9765, 0.7333, 0.2392), vec3(0.9098, 0.5098, 0.5098), smoothstep(3.85, 4.0, p.y));\n        metalic = 0.1;\n        emissive = vec3(0.9098, 0.0706, 0.0706);\n    }\n    if(df.y == MATERIAL_PARTICLE){\n        albedo += pAt * 0.2;\n    }\n    if(df.y == MATERIAL_BOARD){\n        float t8 = easeInOutExpo(linearStep(19.0, 21.0, ft));\n        float tF = easeInOutExpo(linearStep(27.0, 28.0, ft));\n        vec2 uv2 = vec2(((p.xy + vec2(10.0, 5.2)) / vec2(20.0, 20.0)) - 0.5);\n        for(float i = 0.0; i <= 50.0; i+=1.0){\n            float t = time+i/50.0;\n            float ft = floor(t);\n            vec2 offset = random2d(i+2.0+ft);\n            float coef = random1d1d(i+2.0+ft+ft);\n            albedo += explode(uv2 - offset, fract(t), coef)*hsv2rgb(coef, 1.0, 1.0);\n        }\n        albedo *= (t8 - tF);\n    }\n\n    vec3 lightDir = normalize(vec3(1.0, 2.0, -3.0));\n\n    float diff = clamp(dot(n, lightDir), 0.0, 1.0);\n    float specular = pow(clamp(dot(reflect(lightDir, n), rayDir), 0.0, 1.0), 10.0);\n    float ao = getAO(p, n);\n    float shadow = getSoftShadow(p, lightDir, 0.22, 4.0);\n    color += albedo * diff * shadow * (1.0 - metalic);\n    color += albedo * specular * shadow * metalic;\n    color += albedo * clamp(0.5 + 0.5 * n.y, 0.0, 1.0) * 0.2;\n    color += albedo * ao * roomColor;\n    color += emissive;\n    return color;\n}\n\nvec3 acesFilm(vec3 col){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((col * (a * col + b)) / (col * (c * col + d) + e), 0.0, 1.0);\n}\n\nfloat lightDistanceFunction(vec3 p)\n{\n    float lightDF = 1.0 - sdSpotLight(p,  vec3(0.0, 30.0, 0.0)).x;\n\treturn min(max(0.0, lightDF), 1.0);\n}\n\nvec3 renderingFunc(vec2 uv){\n    ft = mod(time, 30.0);\n\n    float t1 = linearStep(1.0, 2.0, ft);\n    float t2 = linearStep(4.0, 5.0, ft);\n\n    float t3 = linearStep(7.0, 8.0, ft);\n    float t4 = linearStep(9.0, 10.0, ft);\n    float t5 = linearStep(11.0, 12.0, ft);\n    float t6 = linearStep(13.0, 14.0, ft);\n    float t7 = linearStep(15.0, 16.0, ft);\n    float camZ = -25.0 + mix(0.0, 6.0, t3) + mix(0.0, 5.0, t4) + mix(0.0, 4.0, t5) + mix(0.0, 3.0, t6) + mix(0.0, 2.0, t7);\n\n    float t33 = bounceIn(linearStep(11.0, 12.0, ft));\n    float t44 = bounceIn(linearStep(13.0, 14.0, ft));\n    float t55 = bounceIn(linearStep(15.0, 16.0, ft));\n    float t66 = bounceIn(linearStep(13.0, 14.0, ft));\n    float t77 = bounceIn(linearStep(15.0, 16.0, ft));\n    float camY = 7.0 + mix(0.0, -0.8, t33) + mix(0.0, -0.6, t44) + mix(0.0, -0.4, t55) + mix(0.0, -0.2, t66) + mix(0.0, -0.1, t77);\n\n    vec3 color = vec3(0.0);\n    vec3 camPos = vec3(0.0, camY, camZ);;\n    vec3 lookPos = vec3(0.0, 3.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 forward = normalize(lookPos - camPos);\n    vec3 right = normalize(cross(up, forward));\n    up = normalize(cross(forward, right));\n    float fov = 1.0;//0.2 + tick(time*1.2, 1.8, 10.0)*0.8;\n    vec3 rayDir = normalize(uv.x * right + uv.y * up + fov * forward);\n    float rand = random1d2d(uv);\n\n    float t8 = easeInOutExpo(linearStep(18.0, 20.0, ft));\n    float t9 = easeInOutExpo(linearStep(22.0, 24.0, ft));\n    float camAngle = mix(0.0, -0.5, t8 - t9);\n    camPos.yz *= rotate(camAngle);\n    rayDir.yz *= rotate(camAngle);\n\n    vec3 p = camPos;\n    vec2 df = vec2(0.0);\n    float d = 0.0;\n    bool isHit = false;\n    float dd = 0.0;\n    for(int i = 0; i < 200; i++){\n        p = camPos + rayDir * d;\n        df = distanceFunction(p);\n        if(df.x > 100.0){\n            dd = 100.0;\n            break;\n        }\n        if(df.x <= 0.0001){\n            isHit = true;\n            break;\n        }\n        d += df.x;\n        dd += df.x;\n    }\n\n    float density = 0.;\n    float stepSize = 0.1;\n    vec3 stepRay = stepSize * rayDir;\n    vec3 p2 = camPos+stepRay*rand;\n    float stepDist = rand*stepSize;\n    float stepLength = 0.8;\n    vec4 sum = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 at = vec3(0.0);\n    for(int i = 0; i < 100; i++){\n        if(stepDist > d){\n            break;\n        }\n\n        at += pow(volumetric(p2) * 4.2, vec3(2.0));\n        stepDist += stepSize;\n        p2 += stepRay;\n    }\n\n    // Referenct : https://www.shadertoy.com/view/WdXGRj\n    vec3 p3 = camPos + rayDir * rand * stepLength;\n    for (int i = 0; i < 100; i++)\n    {\n        if (sum.a < 0.1) {\n        \tbreak;\n        }\n        float d = lightDistanceFunction(p3);\n    \n        if( d > 0.001)\n        {\n            density = clamp((d / 100.0)*10.0, 0.0, 1.0);\n            sum.rgb += vec3(density);\n            sum.a *= 1.0 - density;\n        }\n        p3 += rayDir * stepLength;\n    }\n\n    if(isHit){\n        vec3 normal = getNormal(p);\n        float fogRangeCoef = mix(10.0, 50.0, easeInOutExpo(t1));\n        float fog = 1.0 - clamp(dd/fogRangeCoef, 0.0, 1.0);\n        vec3 mat = material(p, normal, rayDir, df, fog);\n        color += mat;\n        color *= fog;\n        color *= sum.rgb * (sum.a * 30.0) * at * t1;\n        color = mix(color, mat * fog + sum.rgb * (sum.a * 3.0) * at, t2);\n        float t9 = linearStep(29.0, 30.0, ft);\n        color = mix(color, vec3(0.0), easeInOutExpo(t9));\n    }\n\n    color = acesFilm(color * 0.8);\n    color = pow(color, vec3(1.0/2.2));\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord.xy * 2.0 - iResolution.xy ) / min(  iResolution.x,  iResolution.y );\n\n    vec3 color = vec3(0.0);\n    jitter = random1d1d(uv.x + uv.y * 57.0);\n\n    color += renderingFunc(uv);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}