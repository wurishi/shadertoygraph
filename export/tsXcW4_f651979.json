{"ver":"0.1","info":{"id":"tsXcW4","date":"1584803044","viewed":311,"name":"[old school] wildfire","username":"sylefeb","description":"Wildfire","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","fire","demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @sylefeb 2020-03-20 wildfire!\n//\n// specially made demo for the jFIG 2020 shader competion\n\n// text string (see also at the end)\nint strlen = 219;\nint[] string = int[](\n36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,38,38,25,10,27,29,34,36,22,24,13,14,36,14,23,10,11,21,14,13,38,38,36,36,36,36,36,36,36,36,36,36,36,36,36,28,34,21,14,15,14,11,36,25,27,14,28,14,23,29,28,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,10,23,36,24,21,13,36,28,12,17,24,24,21,36,12,21,10,28,28,18,12,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,32,18,21,13,15,18,27,14,38,38,38,38,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,32,14,36,30,28,14,13,36,29,24,36,12,24,13,14,36,29,17,10,29,36,18,23,36,25,30,27,14,36,10,28,22,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,11,10,12,20,36,18,23,36,29,17,14,36,9,0,28,38,38,38\n);\n\n// logo bitmap!\n// who needs textures? this is *old school*\nint[] jfig_logo = int[]( // 16x12\n0,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,\n0,0,1,0,1,0,0,0,0,1,0,1,0,0,0,0,\n0,0,0,0,1,1,0,0,0,1,0,1,0,0,0,0,\n0,0,1,0,1,0,0,0,0,1,0,1,0,1,1,1,\n0,0,1,0,1,0,0,0,0,1,0,1,0,0,0,1,\n0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,1,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,0,1,1,0,0,1,0,0,0,1,1,0,0,1,0,\n0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,\n0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,\n0,0,1,0,0,1,0,1,0,0,1,0,0,1,0,1,\n0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0\n);\n\n// sample the logo\nfloat logo(vec2 luv)\n{\n  ivec2 ij = ivec2(luv*vec2(16.0,12.0));\n  if (ij.x>15 || ij.y>11) return 0.0;\n  int idx  = ij.x + (ij.y << 4);\n  return float(jfig_logo[idx]);\n}\n\n// make the final image, adding the text on top of the wildfire\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 tex  = ( fragCoord ) / iResolution.xy;\n    fragColor = texture(iChannel0,tex);\n\n    vec2 uv = ( fragCoord ) / min(iResolution.x,iResolution.y);\n    uv.y    = 1.0 - uv.y;       \n    \n    // fade to black at the bottom so we can read the text more easily\n    fragColor = fragColor * clamp(1.2 - 1.0*uv.y,0.0,1.0);\n    \n    fragColor += vec4(0.5*logo(uv*7.0*vec2(0.85,1.0)));\n    \n    // text rendering\n    const float txtsize  = 0.05;\n    const float txtspace = 0.1;\n    const float txtspeed = 0.6;\n    // wave\n    uv.y += 0.1*sin(-3.0*iTime + 3.0*uv.x);\n    // in text line?\n    if (uv.y > 1.0 - txtsize - txtspace && uv.y < 1.0 - txtspace ) {\n      // offset to the text (scrolling!)\n      float offset = -iTime*txtspeed;\n      vec2 tuv     = ( uv - vec2(offset,txtspace) ) / txtsize;\n      vec2 luv     = fract(tuv); // letter-space uv\n      int  ioff    = max(0,int(floor(tuv.x))) % strlen; // string pos\n      int  lidx    = string[ioff]; // lookup letter\n      fragColor    = letter(luv,lidx).x > 0.0 ? vec4(1.0) : fragColor; // compose\n    }\n}\n\n/*\n\n// Small C program to translate a string into the array for the shader\n// use any online C compiler, eg. https://cpp.sh\n\n#include <stdio.h>\n#include <ctype.h>\n#include <cstring>\n\nint main()\n{\n    const char *txt = \"                        !!party mode enabled!!             sylefeb presents               an old-school classic               wildfire!!!!               we used to code that in pure asm                back in the 90s!!!\";\n\n    printf(\"int strlen = %d;\\n\",strlen(txt));\n    printf(\"int[] string = int[](\\n\");\n    for (int i = 0; i < strlen(txt) ; i++) {\n      if (isalpha(txt[i])) {\n        printf(\"%d,\",(int)txt[i] - (int)'a' + 10);\n      } else if (isdigit(txt[i])) {\n        printf(\"%d,\",(int)txt[i] - (int)'0' + 0);\n      } else if (txt[i] == '!') {\n        printf(\"38,\");\n      } else {\n        printf(\"36,\");\n      }\n    }\n\n    return 0;\n}\n\n*/\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// @sylefeb 2020-03-20 wildfire!\n// the basic tools: font, random and cellular pattern\n\n// ======================== Text rendering ======================\n\n// hand made font\nint letters[] = int[2496](\n  //[0] 0\n  0,0,1,1,1,1,0,0,\n  0,1,0,0,0,1,1,0,\n  0,1,0,0,1,0,1,0,\n  0,1,0,0,1,0,1,0,\n  0,1,0,1,0,0,1,0,\n  0,1,0,1,0,0,1,0,\n  0,1,1,0,0,0,1,0,\n  0,0,1,1,1,1,0,0,\n  // 1\n  0,0,0,0,1,0,0,0,\n  0,0,0,1,1,0,0,0,\n  0,0,1,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,1,1,1,0,0,\n  // 2\n  0,0,1,1,1,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,0,0,0,1,1,1,0,\n  0,0,0,1,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,1,1,1,1,0,0,\n  // 3\n  0,0,1,1,1,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,0,0,0,0,0,1,0,\n  0,0,0,1,1,1,0,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,0,0,1,0,\n  0,0,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  // 4\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,1,1,0,0,\n  0,0,0,1,0,1,0,0,\n  0,0,1,0,0,1,0,0,\n  0,1,1,1,1,1,1,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,0,1,0,0,\n  // 5\n  0,1,1,1,1,1,1,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,1,1,1,1,0,0,\n  0,0,0,0,0,0,1,0,\n  0,0,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  // 6\n  0,0,0,0,0,1,1,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  0,1,1,1,1,1,0,0,\n  1,0,0,0,0,0,1,0,\n  1,0,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  // 7\n  0,1,1,1,1,1,0,0,\n  0,0,0,0,0,0,1,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  // 8\n  0,1,1,1,1,1,0,0,\n  1,0,0,0,0,0,1,0,\n  1,0,0,0,0,0,1,0,\n  1,0,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  1,0,0,0,0,0,1,0,\n  1,0,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  // [9] 9\n  0,1,1,1,1,1,0,0,\n  1,0,0,0,0,0,1,0,\n  1,0,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  //[10] a\n  0,0,0,1,1,0,0,0,\n  0,0,1,0,0,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,1,1,1,1,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  // b\n  0,1,1,1,1,0,0,0,\n  0,1,0,0,0,1,0,0,\n  0,1,0,0,0,1,0,0,\n  0,1,0,0,1,0,0,0,\n  0,1,1,1,1,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  // c\n  0,0,0,1,1,1,0,0,\n  0,0,1,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  0,0,0,1,1,1,1,0,\n  // d\n  0,1,1,1,1,0,0,0,\n  0,1,0,0,0,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,1,1,0,\n  0,1,1,1,1,0,0,0,\n  // e\n  0,1,1,1,1,1,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,1,1,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,1,1,1,1,1,0,\n  // f\n  0,1,1,1,1,1,1,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,1,1,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  // g\n  0,0,0,1,1,1,0,0,\n  0,0,1,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,1,1,1,0,\n  0,1,0,0,0,0,1,0,\n  0,0,1,0,0,0,1,0,\n  0,0,0,1,1,1,1,0,\n  // h\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,1,1,1,1,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  // i\n  0,0,0,1,1,0,0,0,\n  0,0,0,1,1,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  // j\n  0,0,0,0,1,1,0,0,\n  0,0,0,0,1,1,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,0,1,0,0,\n  0,1,0,0,0,1,0,0,\n  0,0,1,1,1,0,0,0,\n  // k\n  0,1,0,0,1,0,0,0,\n  0,1,0,0,1,0,0,0,\n  0,1,0,0,1,0,0,0,\n  0,1,0,1,0,0,0,0,\n  0,1,1,1,0,0,0,0,\n  0,1,0,0,1,0,0,0,\n  0,1,0,0,0,1,0,0,\n  0,1,0,0,0,1,0,0,\n  // l\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,0,1,1,1,1,0,0,\n  // m\n  0,0,0,0,0,0,0,0,\n  0,1,1,0,0,1,1,0,\n  1,0,0,1,1,0,0,1,\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  // n\n  0,1,0,0,0,0,1,0,\n  0,1,1,0,0,0,1,0,\n  0,1,0,1,0,0,1,0,\n  0,1,0,0,1,0,1,0,\n  0,1,0,0,0,1,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  // o\n  0,0,1,1,1,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,0,1,1,1,1,0,0,\n  // p\n  0,0,1,1,1,1,0,0,\n  0,0,1,0,0,0,1,0,\n  0,0,1,0,0,0,1,0,\n  0,0,1,0,0,0,1,0,\n  0,0,1,1,1,1,1,0,\n  0,0,1,0,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  // q\n  0,0,1,1,1,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,1,0,0,1,0,\n  0,0,1,0,0,0,1,0,\n  0,1,0,1,1,1,0,0,\n  // r\n  0,1,1,1,1,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  0,1,0,0,0,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,0,1,\n  // s\n  0,0,1,1,1,1,0,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,0,1,1,1,1,0,0,\n  0,0,0,0,0,0,1,0,\n  0,0,0,0,0,0,1,0,\n  0,1,1,1,1,1,0,0,\n  // t\n  1,1,1,1,1,1,1,0,\n  0,0,0,1,0,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,0,1,0,0,0,0,\n  // u\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,0,1,1,1,1,0,0,\n  // v\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  0,1,0,0,0,0,1,0,\n  0,1,0,0,0,0,1,0,\n  0,0,1,0,0,1,0,0,\n  0,0,1,0,0,1,0,0,\n  0,0,0,1,1,0,0,0,\n  // w\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  1,0,0,0,0,0,0,1,\n  0,1,0,0,0,0,1,0,\n  0,1,0,1,1,0,1,0,\n  0,1,0,1,1,0,1,0,\n  0,0,1,0,0,1,0,0,\n  // x\n  0,1,0,0,0,1,0,0,\n  0,1,0,0,0,1,0,0,\n  0,1,0,0,0,1,0,0,\n  0,0,1,0,1,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,1,0,1,0,0,0,\n  0,1,0,0,0,1,0,0,\n  0,1,0,0,0,1,0,0,\n  // y\n  1,0,0,0,0,1,0,0,\n  1,0,0,0,0,1,0,0,\n  0,1,0,0,1,0,0,0,\n  0,0,1,0,1,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  //[35] z\n  0,1,1,1,1,1,1,0,\n  0,0,0,0,0,0,1,0,\n  0,0,0,0,0,1,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,1,0,0,0,0,\n  0,0,1,0,0,0,0,0,\n  0,1,0,0,0,0,0,0,\n  0,1,1,1,1,1,1,0,\n  //[36] <space>\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  //[37] <->\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,1,1,1,1,1,1,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,\n  //[38]\n  0,0,0,1,1,0,0,0,\n  0,0,0,1,1,0,0,0,\n  0,0,0,1,1,0,0,0,\n  0,0,0,1,1,0,0,0,\n  0,0,0,0,1,0,0,0,\n  0,0,0,0,0,0,0,0,\n  0,0,0,1,1,0,0,0,\n  0,0,0,1,1,0,0,0\n);\n\n// render a letter\nvec4 letter(vec2 luv,int idx)\n{\n  ivec2 ij = ivec2(luv*8.0);\n  int   l  = (idx<<6) + (ij.x + (ij.y<<3));\n  return letters[l] == 1 ? vec4(1.0) : vec4(0.0);\n}\n\n// ======================== Random ======================\n\n// whatever ...\nvec3 hash( ivec3 ijk )\n{\n  ivec4 h = ivec4(ijk.xyzy);\n  for (int i=0;i<4;i++) {\n    h = ivec4((h.y ^ (h.x*113 ))&65535, \n              (h.x ^ (h.w*8081))&65535,\n              (h.w ^ (h.z*1471))&65535, \n              (h.z ^ (h.y*827 ))&65535);\n  }\n  return vec3( \n      fract(float(h.x ^ (h.z*113))/11261.0), \n      fract(float(h.y ^ (h.w*827))/18199.0),\n      fract(float(h.z ^ (h.w*273))/17197.0)\n  );\n}\n\n// interpolate noise, super cheap, enough for us!\nvec3 noise(vec3 uvw)\n{\n  ivec3 nijk = ivec3(floor(uvw));\n  vec3  luvw = uvw - vec3(nijk);\n  vec3  n000 = hash(nijk+ivec3(0,0,0));\n  vec3  n100 = hash(nijk+ivec3(1,0,0));\n  vec3  n010 = hash(nijk+ivec3(0,1,0));\n  vec3  n110 = hash(nijk+ivec3(1,1,0));\n  vec3  n001 = hash(nijk+ivec3(0,0,1));\n  vec3  n101 = hash(nijk+ivec3(1,0,1));\n  vec3  n011 = hash(nijk+ivec3(0,1,1));\n  vec3  n111 = hash(nijk+ivec3(1,1,1));\n  return  (1.0-luvw.x)*(1.0-luvw.y)*(1.0-luvw.z) * n000\n       +  (    luvw.x)*(1.0-luvw.y)*(1.0-luvw.z) * n100\n       +  (1.0-luvw.x)*(    luvw.y)*(1.0-luvw.z) * n010\n       +  (    luvw.x)*(    luvw.y)*(1.0-luvw.z) * n110\n       +  (1.0-luvw.x)*(1.0-luvw.y)*(    luvw.z) * n001\n       +  (    luvw.x)*(1.0-luvw.y)*(    luvw.z) * n101\n       +  (1.0-luvw.x)*(    luvw.y)*(    luvw.z) * n011\n       +  (    luvw.x)*(    luvw.y)*(    luvw.z) * n111\n      ;\n}\n\n// ======================== Voronoi ======================\n\n// produces a random seed that moves around its base position\n// with random speed and radius\nvec2 seed(float step,int i,int j,float tm)\n{\n  vec2 center = vec2( float(i)*step , float(j)*step );\n  vec2 n      = hash(ivec3(i,j,0)).xy;\n  float s     = 6.0 * (n.y-0.5);\n  float a     = tm * s + 6.28 * (n.x-0.5);\n  return center + 0.707 * vec2(cos(a),sin(a)) * step;\n}\n\n// produces a cellular pattern, Voronoi style\n// records two closest and generates the edge pattern\n// by outputing the distance between both (outlines\n// the Voronoi cell boundaries in an organic fashion)\nfloat cellular( vec2 world, float tm )\n{\n  // Step size for the\n  // Voronoi seed grid\n  float step = 0.3;\n  // which grid cell are we in?\n  int xid = int(floor(world.x / step));\n  int yid = int(floor(world.y / step));\n  // now produce (pseduo) random seeds in each grid cell\n  // within a neighborhood and track closes\n  ivec4 closest_0_1;\n  vec2  closest_dist_0_1 = vec2(1e9);\n  for (int nj = yid-2 ; nj <= yid+2 ; nj ++) {\n    for (int ni = xid-2 ; ni <= xid+2 ; ni ++) {\n      vec2  s = seed(step,ni,nj,tm);\n      float d = length(s - world.xy);\n      if (d < closest_dist_0_1.x) {\n        closest_dist_0_1.y = closest_dist_0_1.x;\n        closest_0_1.zw     = closest_0_1.xy;\n        closest_dist_0_1.x = d;       \n        closest_0_1.xy     = ivec2(ni,nj);\n      } else if (d < closest_dist_0_1.y) {\n        closest_dist_0_1.y = d;       \n        closest_0_1.zw     = ivec2(ni,nj);        \n      }\n    }\n  }\n  // produce a color from the seed and ditances  \n  return \n      (1.0 - 2.0 * abs(closest_dist_0_1.x-closest_dist_0_1.y)/step);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// @sylefeb 2020-03-20 wildfire!\n\n// produces the heat map from which the fire emerges\n// and composes it with the ongoing fire\n// (BufferA reads BufferB)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv      = ( fragCoord ) / min(iResolution.x,iResolution.y);\n    uv.y         = 1.0 - uv.y;\n    float aspect = iResolution.x/iResolution.y;\n    \n    // cellular pattern with perspective\n    // -> we produce a tilted plane texture coord\n    vec2 cuv;    \n    float y_eye = 0.5;\n    const float z_n   = 1.0;\n    cuv.x      = (uv.x-0.5*aspect) * y_eye / uv.y;\n    cuv.y      = z_n * y_eye / uv.y;\n    // -> animate a bit\n    cuv        = cuv + vec2(0.0,0.1*iTime);\n    // -> now we produce the cellular pattern\n    float heat = cellular(1.0*cuv,iTime) * max(0.0,(1.0 - 0.2 * y_eye / uv.y));\n    \n    // -> some noise to make it look like a fire\n    float wave  = 0.2 + 0.9 * noise(vec3(cuv*1.0,iTime*3.0)).x;\n    float ember = noise(vec3(cuv*110.0,iTime*8.0)).x;\n    heat        = heat * ember * wave;\n    \n    // -> outputs the heat map and composes with the fire, with attenuation\n    vec2 tex  = ( fragCoord ) / iResolution.xy;\n    fragColor = vec4(heat) + 0.93 * texture(iChannel0,tex); \n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// @sylefeb 2020-03-20 wildfire!\n\n// creates the fire effect by taking the heat map (buffer A)\n// and copying it shifted up with some lateral noise for good measure\n// (BufferB reads BufferA)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tex  = ( fragCoord ) / iResolution.xy;\n    // scroll fire up\n    tex.y    -= 0.006;\n    // wavy\n    tex.x    += 0.002 * (noise(vec3(tex*3.0,2.0*iTime)).y - 0.5);\n    tex.x    += 0.001 * (noise(vec3(tex*10.0,5.0*iTime)).x - 0.5);\n    // final color, shifts yellow/red\n    fragColor = vec4(0.98,0.84,0.35,1.0) * texture(iChannel0,tex);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}