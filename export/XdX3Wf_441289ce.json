{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Original by WAHa_06x36 at https://www.shadertoy.com/view/ldfGWn\n// Modified by Michael Mara to have a slowly changing distance norm.\n\n// Besides these comments, the only new lines are lines 18-21, which changes the metric\n// used for length throughout the rest of the shader based on time.\n// The other modification is to multiply the raymarch step size by sqrt(3),\n// which is only necessary when p<2 and the step size was not conservative.\n\n// You probably can just paste those four lines at the top of a shader and it'll work,\n// though raymarching may need to be tweaked since it'll screw with the distance estimates\n// (Be prepared for major slowdowns though... each length call is replaced with 4 pows..)\n// For more information on how this code works (and what it does), \n// see my L_p Unit Sphere shader at https://www.shadertoy.com/view/lslGW2\n// I chose this shader to modify since I thought the aesthetic was kinda cool, but it's\n// really just to show off the 4 lines\n// http://en.wikipedia.org/wiki/Lp_space#The_p-norm_in_finite_dimensions\n\nfloat length_p( vec3 v, float p ) {vec3 a = abs(v); return p > 12.0 ? max(a.x,max(a.y,a.z)) : pow( pow(a.x,p) + pow(a.y,p) + pow(a.z,p), 1.0/p );}\nfloat length_p( vec2 v, float p ) {vec2 a = abs(v); return (p > 12.0) ? max(a.x,a.y) : pow( pow(a.x,p) + pow(a.y,p), 1.0/p );}\nfloat getPForLength( float x ) {return 1.0/(1.0-x); }\n#define length(x) length_p(x, getPForLength(-sin(iTime*0.3)*0.5+0.5))\n\nfloat rand(vec3 r) { return fract(sin(dot(r.xy,vec2(1.38984*sin(r.z),1.13233*cos(r.z))))*653758.5453); }\n\n#define Iterations 64\n#define Thickness 0.1\n#define SuperQuadPower 8.0\n#define Fisheye 0.5\n\nfloat truchetarc(vec3 pos)\n{\n\tfloat r=length(pos.xy);\n//\treturn max(abs(r-0.5),abs(pos.z-0.5))-Thickness;\n//\treturn length(vec2(r-0.5,pos.z-0.5))-Thickness;\n\treturn pow(pow(abs(r-0.5),SuperQuadPower)+pow(abs(pos.z-0.5),SuperQuadPower),1.0/SuperQuadPower)-Thickness;\n}\n\nfloat truchetcell(vec3 pos)\n{\n\treturn min(min(\n\ttruchetarc(pos),\n\ttruchetarc(vec3(pos.z,1.0-pos.x,pos.y))),\n\ttruchetarc(vec3(1.0-pos.y,1.0-pos.z,pos.x)));\n}\n\nfloat distfunc(vec3 pos)\n{\n\tvec3 cellpos=fract(pos);\n\tvec3 gridpos=floor(pos);\n\n\tfloat rnd=rand(gridpos);\n\n\tif(rnd<1.0/8.0) return truchetcell(vec3(cellpos.x,cellpos.y,cellpos.z));\n\telse if(rnd<2.0/8.0) return truchetcell(vec3(cellpos.x,1.0-cellpos.y,cellpos.z));\n\telse if(rnd<3.0/8.0) return truchetcell(vec3(1.0-cellpos.x,cellpos.y,cellpos.z));\n\telse if(rnd<4.0/8.0) return truchetcell(vec3(1.0-cellpos.x,1.0-cellpos.y,cellpos.z));\n\telse if(rnd<5.0/8.0) return truchetcell(vec3(cellpos.y,cellpos.x,cellpos.z));\n\telse if(rnd<6.0/8.0) return truchetcell(vec3(cellpos.y,1.0-cellpos.x,cellpos.z));\n\telse if(rnd<7.0/8.0) return truchetcell(vec3(1.0-cellpos.y,cellpos.x,cellpos.z));\n\telse  return truchetcell(vec3(1.0-cellpos.y,1.0-cellpos.x,cellpos.z));\n}\n\nvec3 gradient(vec3 pos)\n{\n\tconst float eps=0.0001;\n\tfloat mid=distfunc(pos);\n\treturn vec3(\n\tdistfunc(pos+vec3(eps,0.0,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,eps,0.0))-mid,\n\tdistfunc(pos+vec3(0.0,0.0,eps))-mid);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float pi=3.141592;\n\n\tvec2 coords=(2.0*fragCoord.xy-iResolution.xy)/length(iResolution.xy);\n\n\tfloat a=iTime/3.0;\n\tmat3 m=mat3(\n\t0.0,1.0,0.0,\n\t-sin(a),0.0,cos(a),\n\tcos(a),0.0,sin(a));\n\tm*=m;\n\tm*=m;\n\n\tvec3 ray_dir=m*normalize(vec3(1.4*coords,-1.0+Fisheye*(coords.x*coords.x+coords.y*coords.y)));\n\n\tfloat t=iTime/3.0;\n\tvec3 ray_pos=vec3(\n    2.0*(sin(t+sin(2.0*t)/2.0)/2.0+0.5),\n    2.0*(sin(t-sin(2.0*t)/2.0-pi/2.0)/2.0+0.5),\n    2.0*((-2.0*(t-sin(4.0*t)/4.0)/pi)+0.5+0.5));\n\n\tfloat i=float(Iterations);\n\tfloat p = getPForLength(-sin(iTime*0.3)*0.5+0.5);\n\tfloat stepModifier = min(1.0, sqrt(3.0) / pow(3.0, 1.0/p));\n\tfor(int j=0;j<Iterations;j++)\n\t{\n\t\tfloat dist=distfunc(ray_pos);\n\t\tray_pos+=dist*stepModifier*ray_dir;\n\n\t\tif(abs(dist)<0.001) { i=float(j); break; }\n\t}\n\n\tvec3 normal=normalize(gradient(ray_pos));\n\n\tfloat ao=1.0-i/float(Iterations);\n\tfloat what=pow(max(0.0,dot(normal,-ray_dir)),2.0);\n\tfloat vignette=pow(1.0-length(coords),0.3);\n\tfloat light=ao*what*vignette*1.4;\n\n\tfloat z=ray_pos.z/2.0;\n//\tvec3 col=(sin(vec3(z,z+pi/3.0,z+pi*2.0/3.0))+2.0)/3.0;\n\tvec3 col=(cos(ray_pos/2.0)+2.0)/3.0;\n\n\tvec3 reflected=reflect(ray_dir,normal);\n\tvec3 env=texture(iChannel0,reflected*reflected*reflected).xyz;\n\n\tfragColor=vec4(col*light+0.1*env,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdX3Wf","date":"1380238010","viewed":644,"name":"Truchet Tentacles L_p","username":"Mx7f","description":"More fun with modifying the distance norm. See the (fantastic) original by WAHa_06x36 at https://www.shadertoy.com/view/ldfGWn. For more information on distance norms see my first shader at https://www.shadertoy.com/view/lslGW2.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield","truchet","lp","distancenorm"],"hasliked":0,"parentid":"","parentname":""}}