{"ver":"0.1","info":{"id":"WdB3Ry","date":"1549208739","viewed":1078,"name":"Pla.net","username":"Gaxil","description":"First planet rendering & first shadertoy shader ... I use a trick for the planet normal map that compute a normal with only two height samples, it's definitely a shortcut but the result is ok.\nBeside that, I uses some tricks and code from IQ (thanks BTW!)","likes":21,"published":1,"flags":64,"usePreview":1,"tags":["raytracing","earth","space","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MlfGW8","filepath":"https://soundcloud.com/gil-damoiseaux/mistymorning","previewfilepath":"https://soundcloud.com/gil-damoiseaux/mistymorning","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define OCEANS_LEVEL .60\n#define PLANETCENTER vec3(-4, -3, 25)\n#define PLANETRADIUS 7.0\n#define MOONCENTER vec3(54, -50, 145)\n#define MOONRADIUS 7.0\n#define ATMOSPHERETHICKNESS .5\n#define ATMOSPHEREDENSITY 2.0\n#define LIGHTPOS vec3(20*3, 15*3, 10)\n\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\nvec2 sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    // from Inigo Quilez\n    // https://iquilezles.org/articles/intersectors\n\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h < 0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\nvec2 inverseSF( vec3 p, float n ) \n{\n    // from IQ\n    // https://www.shadertoy.com/view/lllXz4\n\n    float m = 1.0 - 1.0/n;\n    \n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) \n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        \n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return vec2( j, sqrt(d) );\n}\n\nfloat GetHash1(float p)\n{\n    // from IQ\n    return fract(sin(p)*158.5453123);\n}\n\nfloat GetHash(vec3 p)\n{\n    // from IQ\n\tp  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat GetNoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( GetHash(p+vec3(0,0,0)), \n                        GetHash(p+vec3(1,0,0)),f.x),\n                   mix( GetHash(p+vec3(0,1,0)), \n                        GetHash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( GetHash(p+vec3(0,0,1)), \n                        GetHash(p+vec3(1,0,1)),f.x),\n                   mix( GetHash(p+vec3(0,1,1)), \n                        GetHash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat GetFBM(vec3 p)\n{\n    float noise = 0.0;\n    \n    // Domain warping\n    vec3 warp = vec3(GetNoise(p*0.8+vec3(13.0, 44.0, 15.0)),\n                     GetNoise(p*0.8+vec3(43.0, 74.0, 25.0)),\n                     GetNoise(p*0.8+vec3(33.0, 14.0, 75.0)));\n                     \n    warp -= vec3(0.5);\n    \n    p+= vec3(123.0, 234.0, 55.0);\n    p+= warp*0.6;\n    \n    noise = GetNoise(p) * 1.0 +\n\t        GetNoise(p*2.02) * 0.49 + \n\t        GetNoise(p*7.11) * 0.24 + \n\t        GetNoise(p*13.05) * 0.12 + \n\t        GetNoise(p*27.05) * 0.055 + \n\t        GetNoise(p*55.25) * 0.0025+ \n\t        GetNoise(p*96.25) * 0.00125; \n\n    return noise;\n}\n\nfloat GetFBMClouds(vec3 p)\n{\n    float noise = 0.0;\n    // Domain warping\n    vec3 warp = vec3(GetNoise(p*0.8+vec3(13.0, 44.0, 15.0)),\n                     GetNoise(p*0.8+vec3(43.0, 74.0, 25.0)),\n                     GetNoise(p*0.8+vec3(33.0, 14.0, 75.0)));\n                     \n    warp -= vec3(0.5);\n    \n    p+= vec3(123.0, 234.0, 55.0);\n    p+= warp*0.2;\n    \n    noise = GetNoise(p) * 1.0 +\n\t        GetNoise(p*5.02) * 0.49 + \n\t        GetNoise(p*11.11) * 0.24 + \n\t        GetNoise(p*23.05) * 0.12 +\n\t        GetNoise(p*45.05) * 0.055; \n\treturn noise;\n}\n\nvec3 GetNormal(vec3 p) \n{\n    return normalize(p-PLANETCENTER);\n}\n\nfloat GetSceneDistance(vec3 ro, vec3 rd)\n{\n    float dO=0.;\n \n    vec2 inter = sphIntersect( ro, rd, PLANETCENTER, PLANETRADIUS);\n\tif (inter.x>=0.0)\n        return inter.x;\n    else\n        return MAX_DIST;\n}\n\nvec3 RotateY(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x * cos(angle) - pos.z * sin(angle),\n        pos.y,\n        pos.x * sin(angle) + pos.z * cos(angle)\n    );\n}\n\nvec3 RotateX(vec3 pos, float angle) \n{\n\treturn vec3(\n        pos.x,\n        pos.y * cos(angle) - pos.z * sin(angle),\n        pos.y * sin(angle) + pos.z * cos(angle)\n    );\n}\n\nfloat GetLight(vec3 p, vec3 n, float height, float waterMask) \n{\n    vec3 lightPos = LIGHTPOS;\n    vec3 l = normalize(lightPos-p);\n\n    // Tricky way to compute the normal ... seems acceptable on screen, only one extra height sample to compute\n    vec3 pBis =normalize(p+l*0.01 - PLANETCENTER)*0.5*PLANETRADIUS;\n    pBis = RotateY(pBis, iTime*0.05);\n    float heightBis = GetFBM(pBis) * 0.6;\n    float deltaH = heightBis-height;\n    \n   \tn = normalize(n-deltaH*l*40.0*(1.0-waterMask));\n    \n    float dif = dot(n, l); // can go - (used for night lights)\n    float d = GetSceneDistance(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nfloat Density(vec3 pos)\n{\n    float distanceToCenter =  length(pos - PLANETCENTER);\n    float relativePos = clamp((distanceToCenter-PLANETRADIUS)/ATMOSPHERETHICKNESS, 0.0, 1.0);\n    \n    return ATMOSPHEREDENSITY* exp(-relativePos);\n}\n\nfloat smin( float a, float b)\n{\n    float k = 0.03;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 RayTrace(vec3 ro, vec3 rd, vec4 noise) \n{\n\tvec3 color = vec3(0,0,0);\n    \n    float dist = GetSceneDistance(ro,rd);\n\n    vec2 atmosInOut = sphIntersect( ro, rd, PLANETCENTER, ATMOSPHERETHICKNESS+PLANETRADIUS);\n    \n    if (dist<MAX_DIST)\n    {\n        // Hit planet\n\n        atmosInOut.y = dist;\n        vec3 pos = ro + rd * dist;   \n\t\tvec3 n = GetNormal(pos);\n        \n        vec3 localPos = (pos - PLANETCENTER)*0.5;\n\t\tlocalPos = RotateY(localPos, iTime*0.05);\n        float heatDistribution = smoothstep(2.5, 0.5, (abs(localPos.y) + GetNoise(localPos+vec3(-20,55,20))));\n        \n        float height = GetFBM(localPos) * 0.6;\n        float waterMask = smoothstep(OCEANS_LEVEL+0.05, OCEANS_LEVEL-0.05, height);\n\n        float waterHeight = clamp((height / OCEANS_LEVEL),0.0,1.1); \n        float groundHeight = clamp(((height-OCEANS_LEVEL) / (1.0-OCEANS_LEVEL)),0.0,1.0); \n        float foamNoise =  GetNoise(localPos*7.0*(0.75+0.25*sin(iTime*0.1)))*0.25;\n        float foamLimit = smoothstep(0.6+foamNoise, 1.0, waterHeight);\n        foamLimit = 0.7*foamLimit + 0.3*fract(foamLimit*4.0-iTime*.2)*foamLimit*smoothstep(1.0, 0.85, foamLimit);\n\n\t\tfloat iceDistribution = smoothstep(4.0, 4.3, foamLimit + smoothstep(0.7, 0.85, height)*0.25+ (abs(localPos.y) -waterMask*0.5 + height*0.5 + GetNoise(localPos+vec3(-20,55,20))));\n\t\tfloat wideIceDistribution = smoothstep(2.5, 3.0, foamLimit + smoothstep(0.7, 0.85, height)*0.25+ (abs(localPos.y) -waterMask*0.5 + height*0.5));\n\n        float flatening = waterMask*(1.0-iceDistribution);\n        flatening = max(flatening, iceDistribution*0.75);\n        \n        float light = GetLight(pos, n, height, flatening);\n        float dif = clamp(light, 0., 1.);\n        float invdif = smoothstep(0.1, 0.1-0.05, light);\n        \n\t\tvec3 lightPos = LIGHTPOS;\n\t    vec3 l = normalize(lightPos-pos);\n\t    float rawNdotL = clamp(dot(n, l), 0.0, 1.0);\n        rawNdotL = smoothstep(0.0, 0.2, rawNdotL);\n\t\tdif = max(dif,rawNdotL*0.4); \n        dif*=rawNdotL;\n        \n        vec3 groundColor = mix (vec3(.3,.1,0), vec3(1.0,.5,.40),clamp(groundHeight*3.0, 0.0, 1.0));\n        groundColor = mix (groundColor, vec3(0.76,.36,.36),clamp((groundHeight-0.23)*3.0, 0.0, 1.0));\n        groundColor = mix (groundColor, vec3(0.86,.8,.8),clamp((groundHeight-0.53)*6.0, 0.0, 1.0));\n        vec3 hotWaterColor =mix (vec3(0.0,.2,.6), vec3(0.0,.4,1.00),smoothstep(0.0, 0.9, waterHeight)); \n        vec3 coldWaterColor =mix (vec3(0.15,.3,0.500), vec3(0.2,0.5,.7), smoothstep(0.0, 0.9, waterHeight)); \n        vec3 waterColor =mix (coldWaterColor, hotWaterColor, heatDistribution); \n\t\twaterColor = mix (waterColor , vec3(0.7,.8,0.9),foamLimit);\n\n        vec3 finalColor = mix(groundColor, waterColor, waterMask);\n\n\t\tfinalColor = mix (finalColor, mix(vec3(1.1,1.1,1.1),vec3(.9,1.0,1.0),abs(sin(height*10.0))), iceDistribution);\n\n        float fresnel =pow (1.0-clamp(dot(n, -rd), 0., 1.), 3.0);\n\n        invdif*= (1.0-fresnel);\n        dif *= (1.0-fresnel);\n        color = vec3(dif) * finalColor;\n        \n\t\tfloat citiesLimit = smoothstep(0.0, 0.1, groundHeight)*smoothstep(0.15, 0.13, groundHeight)*(1.0-waterMask)*(1.0-iceDistribution);\n\n        float greenArea = smoothstep(0.0, 0.01, groundHeight)*smoothstep(0.45, 0.3, groundHeight)*(1.0-waterMask)*(1.0-wideIceDistribution);\n\n        vec2 cityInfo = inverseSF(normalize(localPos), 150.0)+\n            inverseSF(normalize(localPos), 100.0);\n        localPos = normalize(localPos);\n        \n        vec2 lightInfo1 = inverseSF(localPos, 23000.0);\n        vec2 lightInfo2 = inverseSF(RotateX(localPos, 1.0), 38000.0);\n        vec2 lightInfo3 = inverseSF(RotateX(localPos, 1.5), 33000.0);\n\n        float townMask = smoothstep(0.28, 0.1, cityInfo.y);\n        \n\t\tfloat lightIntensity = min(min(lightInfo1.y*1.25*(1.0+smoothstep(0.8,0.4, GetHash1((lightInfo1.x)*.015))), \n\t\t\t\t\t\t\t\tlightInfo2.y*1.75*(1.0+smoothstep(0.8,0.4, GetHash1((lightInfo1.x)*.015)))\n                                ), lightInfo3.y*(1.0+smoothstep(0.8,0.4,GetHash1((lightInfo1.x)*.015))));\n\t\tlightIntensity = smoothstep(0.01, 0.000, lightIntensity);\n        \n        float cityArea = smoothstep(0.2, 0.18, cityInfo.y) * citiesLimit;\n\t\tcitiesLimit*=townMask* lightIntensity;\n\t        \n        greenArea *=smoothstep(0.4, 0.3, cityInfo.y)*smoothstep(0.25, 0.28, cityInfo.y);\n        color = mix (color,vec3(dif) * mix(vec3(.45, .65, .15),vec3(.1, .35, .1), GetNoise(localPos*150.0))\n                     , clamp(greenArea-GetNoise(localPos*70.0)*0.6, 0.0, 1.0));\n        \n        color = mix (color, vec3(.15, .15, .15), cityArea);\n        color = mix(color, vec3(.35, .35, .35), clamp(citiesLimit*2.0, 0.0, 1.0));\n    \tcolor += vec3(0.95, 0.8, 0.5)*invdif*citiesLimit*2.0;\n  \n\t\tvec3 localPosClouds = (pos - PLANETCENTER)*0.25;\n\t\tlocalPosClouds = RotateY(localPosClouds, iTime*0.055 + localPosClouds.y*0.85);\n        float clouds = GetFBMClouds(localPosClouds*3.0-vec3(iTime*0.025)) * 0.6;\n\n\t\tvec3 localPosCloudsBis = (pos+l*0.1 - PLANETCENTER)*0.25;\n\t\tlocalPosCloudsBis = RotateY(localPosCloudsBis, iTime*0.055);\n        float cloudsBis = GetFBMClouds(localPosCloudsBis*3.0-vec3(iTime*0.025)) * 0.6;\n\n        float level = smoothstep(OCEANS_LEVEL-0.1, OCEANS_LEVEL+0.6, height);\n        clouds = smoothstep(0.5+level*0.85, 0.8+level*0.85, clouds);\n        float cloudShadow = 1.0-smoothstep(0.5+level*0.85, 1.0+level*0.85, cloudsBis)*0.75*(1.0 - clamp(dot(n, l), 0.0, 1.0));\n        \n        color = mix (color*cloudShadow, vec3(1)*rawNdotL*cloudShadow, clouds);\n    }\n    else\n    {\n        \n\t\tfloat dO=0.;\n \n\t    vec2 inter = sphIntersect( ro, rd, MOONCENTER, MOONRADIUS);\n\t\tif (inter.x>=0.0)\n        {\n            // moon hit\n            \n            vec3 hitPos = inter.x * rd + ro;\n            vec3 hitNormal = normalize(hitPos-MOONCENTER);\n       \t\tvec3 lightPos = LIGHTPOS;\n\t\t    vec3 l = normalize(lightPos-hitPos);\n\n            float dif = clamp(dot(l, hitNormal), 0.0, 1.0);\n            float noise = GetFBM(hitPos*0.4);\n            color = mix(vec3(0.2), vec3(.4), noise)*dif;\n        }\n\t\telse\n        {\n            // background\n            \n            vec3 pos = normalize(ro + rd * 1000.0);   \n            pos = pos.xyz;\n\n            for(float i=0.0;i<5.0;i++)\n            {\n                vec2 info = inverseSF(pos, 50000.0 + i*5000.0);\n                float random = GetHash1((info.x + i*10.0)*.015);\n                float distToStar = smoothstep(0.00025+0.0015*pow((1.0-random), 15.0), 0.0002,info.y) * smoothstep(0.1, 0.0,random ); \n\n                color = max(color, vec3(distToStar));\n            }\n                \n            float noise = GetFBM(pos*2.0 + vec3(0.0, 0.0, iTime*0.05));\n            float nebulae = smoothstep(0.4, 1.8, noise);\n\t\t\tfloat nebulae1 = max(0.3-abs(nebulae-0.3), 0.0)*1.0;\n\t\t\tfloat nebulae2 = max(0.2-abs(nebulae-0.4), 0.0)*1.0;\n\t\t\tfloat nebulae3 = max(0.3-abs(nebulae-0.5), 0.0)*1.0;\n\n            vec3 nebulaeColor = vec3(0.0, 0.2, 0.7)*nebulae1 + vec3(0.5, 0.4, 0.3)*nebulae2 + vec3(0.1, 0.2, 0.4)*nebulae3;\n\n            color += nebulaeColor;\n        }        \n    }\n    \n    if (atmosInOut.x>=0.0)\n    {\n        float density = .1;\n        \n        atmosInOut.x-=noise.r;\n        // Atmosphere\n        float atmosphereToGo = atmosInOut.y - atmosInOut.x;\n        \n        vec3 startPosition = ro + rd * atmosInOut.x;\n        \n        float lightEnergy  = 0.0;\n        float transmittance = 1.0;\n        float steps = 0.0051;\n        for(float i = 0.0; i<atmosphereToGo;i+=steps)\n        {\n\t\t\tvec3 pos = startPosition+rd*i;\n            \n            float localDensity = Density(pos)*steps;\n            vec3 lightDir = -normalize(pos-LIGHTPOS);\n            float shadow = GetSceneDistance(pos, lightDir);\n            shadow = step(MAX_DIST*0.9, shadow);\n            \n            lightEnergy+=  localDensity * shadow;\n\t\t\ttransmittance *= (1.0-localDensity*1.0);\n            \n        }\n        color = mix(color, \n                    mix( vec3(0.1,0.15,0.7), vec3(0.65,0.8,1.0),(1.0-exp(-lightEnergy*0.6)))\n                        *clamp(lightEnergy*0.5, 0.0, 1.0),(1.0-transmittance)* (1.0-exp(-lightEnergy*0.6)));\n    }\n    \n\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec4 noise = texture(iChannel0, fragCoord/1024.0); \n    vec3 offset =  vec3(sin(iTime*0.1)*3.0, 0.25+(cos(iTime*0.1)*.5), 0);\n    offset = mix(offset, vec3(4.0-iMouse.x/iResolution.x*8.0, 4.0-(iMouse.y/iResolution.y)*8.0, 0), step( 0.001, iMouse.z ));\n    \n    vec3 ro = offset + vec3(0.0, 12.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 2));\n    rd = RotateX(rd, 0.5);\n    vec3 col = RayTrace(ro, rd, noise);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}