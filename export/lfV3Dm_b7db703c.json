{"ver":"0.1","info":{"id":"lfV3Dm","date":"1713203482","viewed":36,"name":"Kaban_shader","username":"Kaban179","description":"very good shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["kabaniiiiii"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Eps 1e-6\n#define maxZ 1000.0\n\nconst int n = 3; // число фигур\nvec3 colAr[n] = vec3[n](vec3(0.5, 0.0, 0.5), vec3(0.0, 1.0, 0.0), vec3(0.0, 1.0, 1.0)); // цвета фигур\nvec3 BGcol = vec3(0.0, 0.0, 0.0); // цвет фона\nfloat zAr[n] = float[n](-0.04, 0.05, 0.15); // z-координаты плоских фигур\nint inds[n+1] = int[n+1](0, 4, 7, 10); // массив индексов\nconst int m = 14; // число вершин\nvec2 polygons[m]; // массив координат вершин (крайних точек) полигонов\nvoid initPolygons(out vec2 polygons[m], in float time){\n    polygons[0] = vec2(0.5 + cos(time*1.7)* 0.25, 0.5 - sin(time*1.7)* 0.25);//Трапеция\n    polygons[1] = vec2(0.5 + cos(time*1.7)* 0.25, 0.6 - sin(time*1.7)* 0.25);\n    polygons[2] = vec2(0.7 + cos(time*1.7)* 0.25, 0.7 - sin(time*1.7)* 0.25);\n    polygons[3] = vec2(0.7 + cos(time*1.7)* 0.25, 0.5 - sin(time*1.7)* 0.25);\n\n    polygons[4] = vec2(0.3 + cos(time/3.0)* 0.2, 0.7 + sin(time/1.05)* 0.3);//треугольник\n    polygons[5] = vec2(0.5 + cos(time/3.0)* 0.2, 0.6 + sin(time/1.05)* 0.3);\n    polygons[6] = vec2(0.3 + cos(time/3.0)* 0.2, 0.5 + sin(time/1.05)* 0.3);\n\n    polygons[7] = vec2(0.7 - 0.1*sin(time), 0.8 - 0.1*cos(time));//треугольник\n    polygons[8] = vec2(0.6 - 0.1*sin(time), 0.5 - 0.1*cos(time));\n    polygons[9] = vec2(0.8 - 0.1*sin(time), 0.5 - 0.1*cos(time));\n\n\n}\n\nmat3 rotateX(float fi) {\n    float c = cos(fi);\n    float s = sin(fi);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n\nmat3 rotateY(float fi ) {\n    float c = cos(fi);\n    float s = sin(fi);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float fi) {\n    float c = cos(fi);\n    float s = sin(fi);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nvec3 past(vec3 a, float x, float y, float z){\n    return a * rotateX(x* iTime) * rotateY(y* iTime) * rotateZ(z * iTime);\n}\n\n// Rotation around the Z axis.\n\nbool inPolygon( in vec2 p, in int num) {\n    bool ans = false;\n    int i = inds[num];\n    if ((inds[num + 1] - inds[num]) == 4){\n        int k = 0;\n        for (int i = inds[num]; i < inds[num + 1] - 1; i++){\n            for (int j = i + 1; j < inds[num + 1]; j++){\n                if ((i - j) ==1 || (j - i)==1){\n                    if((polygons[i].y > p.y) != (polygons[j].y > p.y) && // Проверка, что точка на нужном отрезке по y\n                       (p.x  - polygons[i].x < (polygons[j].x - polygons[i].x) * (p.y - polygons[i].y) / (polygons[j].y - polygons[i].y))){\n                       k++;\n                }   }\n            }\n        }\n        if (k % 2 != 0){\n            ans = true;\n        }\n    }\n    else{\n        int k = 0;\n        for (int i = inds[num]; i < inds[num + 1] - 1; i++){\n            for (int j = i + 1; j < inds[num + 1]; j++){\n                if((polygons[i].y > p.y) != (polygons[j].y > p.y) && // Проверка, что точка на нужном отрезке по y\n                   (p.x  - polygons[i].x < (polygons[j].x - polygons[i].x) * (p.y - polygons[i].y) / (polygons[j].y - polygons[i].y))){\n                   k++;\n                }\n            }\n        }\n        if (k % 2 != 0){\n            ans = true;\n        }\n    }\n    return ans;\n}\n\n//vec3 BGcol = vec3(0.0, 0.0, 0.0); // цвет фона\n\nfloat ball[4] = float[4](.5, .5, .5, 0.3);// шар\nfloat In_circle(in vec3 c){\n    bool ans = (c.x - ball[0])*(c.x - ball[0]) + (c.y - ball[1])*(c.y - ball[1]) < (ball[3]*ball[3]);\n    float z = ((ball[3]*ball[3]) - (c.x - ball[0])*(c.x - ball[0])*2.7 - (c.y - ball[1])*(c.y - ball[1]));\n    return -sqrt(z) + 0.3;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float closest = maxZ;\n     vec2 uv = fragCoord/iResolution.xy; // нормализация координат, деление покомпонентное!\n     initPolygons(polygons, iTime);\n     vec3 col= BGcol;\n          // расчет цвета col, через поиск фигур, которые накрывают точку uv и выбор ближайшей из них\n     for(int i = 0; i < n; i++){\n        if(inPolygon(uv, i) && zAr[i] < closest){\n            closest = zAr[i];\n            col = colAr[i];\n            if (i == 0){\n                col = colAr[i] + vec3(0.4- 5.0* (uv.x - (0.5 + cos(iTime*1.7)* 0.25)), 5.0* (uv.x - (0.5 + cos(iTime*1.7)* 0.25)), 0.2 - 5.0* (uv.x - (0.5 + cos(iTime*1.7)* 0.25)));// цвет от координаты\n            }\n        }\n    }\n    vec3 c = vec3(uv.x, uv.y, 0.4);\n    float zb =  ((0.5)/5.0 - 0.5);\n    if((In_circle(c) > zb) && (In_circle(c)) < closest){\n        //closest = In_circle(c);\n        //col = vec3(0.4 + In_circle(c)*2.0, 0.0, .4 - In_circle(c)*2.0);\n    }\n\n    vec2 uv1 = uv- vec2(0.2, 0.5);\n\n    vec3 coordP;\n    bool f = true;\n    float lx = 0.5, ly =0.5, lz = 0.5; //coordinates\n\n    for (float z = 200.0; z >= -200.0; z -= 2.){\n        float nz = z / 1000.0;\n\n        coordP = past(vec3(uv1, nz), 1., 1., 1.);\n        //if (coordP.z < closest){\n\n        if (abs(coordP.z + 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.y) <= 0.1){\n            if (coordP.z < closest){col = vec3(0.0, 1.0, 0.0);closest = coordP.z;}\n            //break;\n        }\n        if (abs(coordP.x - 0.1) <= 0.001 && abs(coordP.z) <= 0.1 && abs(coordP.y) <= 0.1){\n            if (coordP.z < closest){col = vec3(1.0, 0.0, 0.0);closest = coordP.z;}\n            //break;\n        }\n        if (abs(coordP.x + 0.1) <= 0.001 && abs(coordP.z) <= 0.1 && abs(coordP.y) <= 0.1){\n            if (coordP.z < closest){col = vec3(0.0, 1.0, 1.0);closest = coordP.z;}\n            //break;\n        }\n        if (abs(coordP.y - 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.z) <= 0.1){\n            if (coordP.z < closest){col = vec3(1.0, 0.0, 1.0);closest = coordP.z;}\n            //break;\n        }\n        if (abs(coordP.y + 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.z) <= 0.1){\n            if (coordP.z < closest){col = vec3(1.0, 1.0, 0.0);closest = coordP.z;}\n            //break;\n        }\n        if (abs(coordP.z - 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.y) <= 0.1){\n            if (coordP.z < closest){col = vec3(0.0, 0.0, 1.0);closest = coordP.z;}\n            //break;\n        }\n    }\n    //vec3 c = vec3(uv.x, uv.y, 0.1);\n    //float zb =  (sin(iTime)/5.0 - 0.5);\n    if((In_circle(c) > zb) && (In_circle(c)) < closest){\n        closest = In_circle(c);\n        col = vec3(0.4 + In_circle(c)*2.0, 0.0, .4 - In_circle(c)*2.0);\n    }\n    //}\n\n\n    fragColor = vec4(col,0.0);\n}\n","name":"Image","description":"","type":"image"}]}