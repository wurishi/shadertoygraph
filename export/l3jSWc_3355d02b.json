{"ver":"0.1","info":{"id":"l3jSWc","date":"1711170505","viewed":77,"name":"Riley slice shrinking line","username":"Vectornaut","description":"Pick a geodesic g on the punctured square torus. For each uniformly hyperbolic SL(2,C) local system E on the torus, there's a line L in C^2 that shrinks along g. Here, g is the golden geodesic, E varies over the Riley slice, and we plot L on CP^1.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["holomorphic"],"hasliked":0,"parentid":"7sGyWV","parentname":"Quasicrystal renormalization"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----------------------sRGB----------------------\n// from nmz's 3d color space visualization\n// https://www.shadertoy.com/view/XddGRN\n\n// map colors from RGB space to sRGB space. in RGB space, color value is\n// proportional to light intensity, so linear color-vector interpolation\n// corresponds to physical light mixing. in sRGB space, the color encoding\n// used by many monitors, we use more of the value interval to represent low\n// intensities, and less of the interval to represent high intensities. this\n// improves color quantization\n\nfloat sRGB(float t){ return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n//----------------------CIE Lab----------------------\n// from nmz's 3d color space visualization\n// https://www.shadertoy.com/view/XddGRN\n\n// map colors from Lab space to RGB space. see explore-lab/explore-lab-l.frag\n// to learn more\n\nconst vec3 wref =  vec3(.95047, 1.0, 1.08883);\n\nfloat xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }\n\nvec3 lab2rgb(in vec3 c)\n{\n    float lg = 1./116.*(c.x + 16.);\n    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),\n                    wref.y*xyzR(lg),\n                    wref.z*xyzR(lg - 0.005*c.z));\n    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,\n                        -0.9689,  1.8758, 0.0415,\n                         0.0557, -0.2040, 1.0570);\n    return rgb;\n}\n\n// --- chromasphere ---\n// adapted from endolith's complex_colormap code\n// https://github.com/endolith/complex_colormap/tree/master/complex_colormap\n\n// endolith created this palette for phase plots of complex functions, like the\n// ones in this article. (the article uses a different palette---possibly based\n// on a CMYK color wheel?)\n// https://www.ams.org/notices/201106/rtx110600768p.pdf\n\n// at each lightness `l`, we want to use a constant-chroma color wheel with the\n// most saturated colors an RGB monitor can display. this function approximates\n// the radius of that color wheel using an efficient piecewise-linear formula\nfloat appx_chromawheel(in float l) {\n    if (l <= 0.0 || 100.0 <= l) return 0.0;\n    float lpts [5];\n    float cpts [5];\n    lpts[0] =   0.0; lpts[1] =   9.2; lpts[2] =  73.8; lpts[3] =  90.0; lpts[4] = 100.0;\n    cpts[0] =   0.0; cpts[1] =  10.8; cpts[2] =  39.9; cpts[3] =  12.5; cpts[4] =   0.0;\n    float lbot; float ltop;\n    float cbot; float ctop;\n    if      (l < lpts[1]) { lbot = lpts[0]; ltop = lpts[1]; cbot = cpts[0]; ctop = cpts[1]; }\n    else if (l < lpts[2]) { lbot = lpts[1]; ltop = lpts[2]; cbot = cpts[1]; ctop = cpts[2]; }\n    else if (l < lpts[3]) { lbot = lpts[2]; ltop = lpts[3]; cbot = cpts[2]; ctop = cpts[3]; }\n    else                  { lbot = lpts[3]; ltop = lpts[4]; cbot = cpts[3]; ctop = cpts[4]; }\n    float t = (l - lbot) / (ltop - lbot);\n    return (1.0-t)*cbot + t*ctop;\n}\n\n// this should return false for +Inf, -Inf, NaN, and enormous numbers\nbool in_range(float t) {\n    return -1.0e38 < t && t < 1.0e38;\n}\n\n// translate a complex number `z` into a color. the lightness shows the absolute\n// value of `z`, and the hue shows the phase of `z`\nvec3 chromasphere(vec2 z) {\n    if (in_range(z.x) && in_range(z.y)) {\n        float r = length(z);\n        vec2 u = z/r;\n        float l = 100.*(1. - 1./(1. + pow(r, 1./3.)));\n        return lab2rgb(vec3(l, appx_chromawheel(l)*u));\n    } else {\n        return vec3(1.);\n    }\n}\n\n// --- complex arithmetic ---\n\nconst vec2 ONE = vec2(1., 0.);\nconst vec2 I   = vec2(0., 1.);\n\n//  the complex conjugate of `z`\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\n// the product of `z` and `w`\nvec2 mul(vec2 z, vec2 w) {\n    return mat2(z, conj(z).yx) * w;\n}\n\n// the reciprocal of `z`\nvec2 rcp(vec2 z) {\n    // 1/z = z'/(z'*z) = z'/|z|^2\n    return conj(z) / dot(z, z);\n}\n\n// the square root of `z`, from the complex arithmetic code listing in\n// Appendix C of _Numerical Recipes in C_\n//\n// William Press, Saul Teukolsky, William Vetterling, and Brian Flannery,\n// _Numerical Recipes in C_, 2nd edition. Cambridge University Press, 1992\n//\nvec2 csqrt(vec2 z) {\n    // sqrt(0) = 0\n    if (z.x == 0. && z.y == 0.) {\n        return vec2(0.);\n    }\n    \n    // calculate w\n    vec2 a = abs(z);\n    float w;\n    if (a.x >= a.y) {\n        float sl = a.y / a.x;\n        w = sqrt(a.x) * sqrt(0.5*(1. + sqrt(1. + sl*sl)));\n    } else {\n        float sl = a.x / a.y;\n        w = sqrt(a.y) * sqrt(0.5*(sl + sqrt(1. + sl*sl)));\n    }\n    \n    // construct output\n    if (z.x >= 0.) {\n        return vec2(w, z.y / (2.*w));\n    } else if (z.y >= 0.) {\n        return vec2(z.y/(2.*w), w);\n    } else {\n        return -vec2(z.y/(2.*w), w);\n    }\n}\n\n// the trace of a complex 2 by 2 matrix\nvec2 ctrace(mat4 t) {\n    return vec2(t[0][0], t[0][1]) + vec2(t[2][2], t[2][3]);\n}\n\n// --- main ---\n\nfloat norm_sup(mat4 t) {\n    float sup = 0.;\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            sup = max(sup, abs(t[i][j]));\n        }\n    }\n    return sup;\n}\n\nmat4 lower(vec2 s) {\n    // GLSL stores matrices column by column, so the rows shown here are the\n    // columns of the matrix\n    return mat4(\n        1., 0.,  s.x, s.y,\n        0., 1., -s.y, s.x,\n        0., 0.,   1., 0.,\n        0., 0.,   0., 1.\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // set viewing window\n    // the known spectrum runs roughly from -2.856 to 0\n    // the big bright pole is around -1.5862\n    const float win_left = -1.7862;\n    const float win_right = 0.2;\n    vec2 t = (fragCoord - 0.5*iResolution.y*I) / iResolution.x;\n    vec2 u = win_left*(ONE - t) + win_right*t;\n    \n    // initialize transfer matrices\n    mat4 a = lower(u);\n    mat4 b = transpose(lower(ONE));\n    float a_scale = 1.;\n    float b_scale = 1.;\n    \n    // inflate\n    const int iters = 16;\n    for (int n = 0; n < iters; n++) {\n        // inflate transfer matrices\n        mat4 a_new = b*a;\n        mat4 b_new = a;\n        a = a_new;\n        b = b_new;\n        \n        // inflate scale factors\n        float a_scale_new = b_scale*a_scale;\n        float b_scale_new = a_scale;\n        a_scale = a_scale_new;\n        b_scale = b_scale_new;\n        \n        // rescale\n        float a_norm = norm_sup(a);\n        a /= a_norm;\n        a_scale *= a_norm;\n    }\n    \n    // find the small eigenvalue of `a`. for numerical stability, we do this by\n    // taking the reciprocal of the large eigenvalue\n    vec2 tr_a = ctrace(a);\n    vec2 discrim = csqrt(mul(tr_a, tr_a) - (4./(a_scale*a_scale))*ONE);\n    vec2 eigval1 = tr_a + discrim;\n    vec2 eigval2 = tr_a - discrim;\n    vec2 small_eigval;\n    if (dot(eigval1, eigval1) > dot(eigval2, eigval2)) {\n        small_eigval = rcp(eigval1) / a_scale;\n    } else {\n        small_eigval = rcp(eigval2) / a_scale;\n    }\n    \n    // find the small eigenline of `a`\n    vec2 small_eigline = mul(-vec2(a[2][0], a[2][1]), rcp(vec2(a[0][0], a[0][1]) - small_eigval));\n    \n    fragColor = vec4(sRGB(chromasphere(small_eigline)), 1.);\n}","name":"Image","description":"","type":"image"}]}