{"ver":"0.1","info":{"id":"4s3yDM","date":"1519073136","viewed":794,"name":"Spinal Cave","username":"lsdlive","description":"Monday doodling.\nStill training geometry.\n\nShading is just texture, lambert & a little bit of tweaking, it's simple & gives an old pc game horror style.","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","raymarch","horror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define PI 3.14159\n#define TWO_PI 2.*PI\n\n// hglib / iq\n// http://mercury.sexy/hg_sdf/\n// https://iquilezles.org/articles/distfunctions\nfloat rep(float p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nvec3 rep(vec3 p, float d) {\n\treturn mod(p - d*.5, d) - d*.5;\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n\tp.x = abs(p.x) - d.x;\n\tp.y = abs(p.y) - d.y;\n\tif (p.y > p.x)p = p.yx;\n}\n\nvoid amod(inout vec2 p, float m) {\n\tfloat a = rep(atan(p.x, p.y), m);\n\tp = vec2(cos(a), sin(a)) * length(p);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n#define sph(p, r) (length(p) - r)\n#define cube(p, b) length(max(abs(p) - vec3(b), 0.))\n\nfloat cyl(vec3 p, float r, float h) {\n\treturn max(length(p.xz) - r, abs(p.y) - h);\n}\n\n// signed\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// iq via leon/koltes\nfloat smoo(float a, float b, float r) {\n\treturn clamp(.5 + .5*(b - a) / r, 0., 1.);\n}\n\nfloat smin(float a, float b, float r) {\n\tfloat h = smoo(a, b, r);\n\treturn mix(b, a, h) - r*h*(1. - h);\n}\n\nfloat smax(float a, float b, float r) {\n\tfloat h = smoo(a, b, r);\n\treturn mix(a, b, h) + r*h*(1. - h);\n}\n\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n\nvec4 opu(vec4 a, vec4 b) {\n\treturn a.w < b.w ? a : b;\n}\n\n//return vec4: vec3 color + float distance\nvec4 de(vec3 p) {\n\n\tvec4 surface;\n\tvec3 q;\n\n\tp.xy -= path(p.z);\n\n\n\tfloat bg_tun = -length(p.xy) + 4.;\n\n\tp.xy *= r2d(-3.14*.5);\n\tp.xy *= r2d(p.z*.1);\n\tp.y = abs(p.y) - .5;\n\tp.xy *= r2d(1.4);\n\n\t// spinal\n\tfloat t = 2.;\n\tp.z = mod(p.z - t*.5, t) - t*.5;\n\tfloat d = max(cyl(p.yzx, 1.2, .1), -cyl(p.yzx - vec3(.15, 0, 0), 1.1, .9));\n\td = smin(d, box(p - vec3(0, -1.05, 0), vec3(.1, .1, 1.)), .4);\n\tsurface = vec4(1, 1, 1, d);\n\n\tq = p;\n\n\t// medium tubes\n\tp.y -= 2.;\n\tamod(p.xy, 8.);\n\tmo(p.xy, vec2(.4, .1));\n\td = sph(p.xy, .1);\n\tp.z = rep(p.z, 6.);\n\tp.y *= .7;\n\td = min(d, sph(p, .15));\n\td = min(d, bg_tun);\n\tsurface = opu(surface, vec4(.2, .3, .4, d));\n\n\t// big tubes\n\tp = q;\n\tamod(p.xy, 3.);\n\tmo(p.xy, vec2(1.9));\n\td = sph(p.xy, .8);\n\tsurface = opu(surface, vec4(.7, .1, .1, d));\n\n\t// small tubes\n\tp = q;\n\tp.x -= .1;\n\tp.y += .5;\n\tamod(p.xy, 8.);\n\tmo(p.xy, vec2(.1, .1));\n\td = sph(p.xy, .02);\n\tsurface = opu(surface, vec4(.3, .2, .2, d));\n\n\treturn surface;\n\n}\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\nvec3 normal(in vec3 pos)\n{\n\tvec2 e = vec2(1., -1.)*.5773*.0005;\n\treturn normalize(e.xyy*de(pos + e.xyy).w +\n\t\te.yyx*de(pos + e.yyx).w +\n\t\te.yxy*de(pos + e.yxy).w +\n\t\te.xxx*de(pos + e.xxx).w);\n}\n\n// from iq's boxmapping: https://www.shadertoy.com/view/MtsGWH\nvec4 boxmap(sampler2D sam, in vec3 p, in vec3 n, in float k)\n{\n\tvec3 m = pow(abs(n), vec3(k));\n\tvec4 x = texture(sam, p.yz);\n\tvec4 y = texture(sam, p.zx);\n\tvec4 z = texture(sam, p.xy);\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 uv = (q - .5) * iResolution.xx / iResolution.yx;\n\n\n\tfloat dt = iTime * 6.;\n\tvec3 ro = vec3(cos(iTime)*.5, sin(iTime)*.5, -4. + dt);\n\tvec3 ta = vec3(0, 0, dt);\n\tvec3 rd;\n\n\tro.xy += path(ro.z);\n\tta.xy += path(ta.z);\n\n\trd = camera(ro, uv, ta);\n\n\tvec3 p;\n\tvec4 res;\n\tfloat ri, t = 0.;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tres = de(p);\n\t\tif (res.w<.001 || t>30.) break;\n\t\tt += res.w;\n\t}\n\n\tvec3 bg = vec3(.15, .0, .0);\n\tvec3 col = bg;\n\tif (t <= 100.) {\n\t\tvec3 n = normal(p);\n\t\tcol = boxmap(iChannel0, p + .3, n, 32.).rgb * res.rgb;\n\t\tcol = col * (uv.y + .5)*1.7;\n\t\tcol *= dot(n, normalize(vec3(1., 1., -1.)));\n\t\tcol = smoothstep(0., 1., col);\n\t}\n\n\tfloat dist = length(ro - p);\n\tcol = mix(col, bg, 1. - exp(-.007 * dist*dist));\n    \n    col *= 2.;\n    col /= col + 1.; // then remap, with tone mapping\n    \n    // you may try this to increase brighness (proposed by movAX13h)\n    col = clamp(col, 0., 1.);\n\tcol = pow(col, vec3(2.2, 2.4, 2.5)) * 3.9;\n\tcol = pow(col, vec3(.4545));\n    \n\t// iq's vignetting\n\tcol *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0 - q.x)*(1.0 - q.y), 0.25);\n\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}