{"ver":"0.1","info":{"id":"ddjGzW","date":"1667328433","viewed":166,"name":"Geom. Series Square Tiling SDF","username":"jt","description":"Using [url=https://en.wikipedia.org/wiki/Geometric_series]Geometric Series[/url] to calculate a loopless exact euclidean SDF tiling the plane with squares of increasing size.\nExtension to 3d [url=https://www.shadertoy.com/view/DdS3Dh]here[/url].","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["sdf","square","distance","tiling","infinite","euclidean","geometric","loopless","series","exact","sum","telescoping"],"hasliked":0,"parentid":"dd2GRW","parentname":"Geometric Series Square Tiling"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/ddjGzW Geometric Series Square Tiling SDF 2022-11-01 by Jakob Thomsen\n// based on https://www.shadertoy.com/view/dd2GRW Geometric Series Square Tiling\n// based on https://www.shadertoy.com/view/Ds23zD Textured Geometric Series Coords\n// based on https://www.shadertoy.com/view/fd2czy Textured Geometric Series\n// based on https://www.shadertoy.com/view/7dScRG 1/4+1/16+1/64+1/256+...\n\n// tags: sdf, square, distance, tiling, infinite, euclidean, geometric, loopless, series, exact, sum, telescoping\n\n// Using Geometric Series to calculate a loopless exact euclidean SDF tiling the plane with squares of increasing size.\n\n// see https://en.wikipedia.org/wiki/Geometric_series\nfloat geometric_series_square_tiling(vec2 p, float n)\n{\n    p = abs(p);\n\n    float n1 = n - 1.0;\n    float b = n / n1;\n    vec2 s = floor(log2(p)/log2(b));\n    float m = max(s.x, s.y);\n    p = fract(p/pow(b, m)*n1);\n\n    p = 0.5-abs(p-0.5);\n    float d = min(p.x, p.y);\n    //d = min(d,length(p-0.5)-0.5); // circles\n    return d*pow(b, m)*b/n;\n}\n\nfloat map(vec2 p, float n)\n{\n    return geometric_series_square_tiling(p, n);\n}\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    vec2 R = iResolution.xy;\n\ti = (2.0 * i - R) / R.y;\n    vec2 m = (2.0 * iMouse.xy - R) / R.y;\n\n    float n = floor((0.5 - 0.5 * cos(iTime)) * 10.0 + 2.0);\n    float d = map(i, n);\n    \n\t// using iq's sdf visualization\n    vec3 col = (d > 0.0) ? vec3(0.9, 0.6, 0.3) : vec3(0.65, 0.85, 1.0);\n    col *= 1.0 - exp(-6.0 * abs(d));\n\tcol *= 0.8 + 0.2 * cos(150.0 * d);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d)));\n\n    if(iMouse.z > 0.001)\n    {\n        d = map(m, n);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(i - m) - abs(d)) - 0.0025));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(i - m) - 0.015));\n    }\n\n    o = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}