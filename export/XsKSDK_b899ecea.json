{"ver":"0.1","info":{"id":"XsKSDK","date":"1466676055","viewed":714,"name":"Judgment Day","username":"Passion","description":"Combining some terrain with tunnels and atmospheric scattering. Use the mouse to move the sun around. Lots of the comments in the code are from users Shane and Hamneggs.","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["noise","tunnel","scattering","bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Sky Scattering taken from Round Rock Island by 'Hamneggs' */\n//https://www.shadertoy.com/view/4d3GRX\n\n/* Bump mapping and tunnel distance function taken from user Shane's raymarch site */\n//view-source:raymarching.com/WebGL/WebGL_TextureBumpedTunnel.htm\n\n#define NUM_STEPS 64\n#define PI   3.141593\n#define EPS 0.001\n#define CINEMATIC\n//#define SNOW\n//#define JAGGED\n\n// Frequencies and amplitudes of tunnel \"A\" and \"B\". See then \"path\" function.\nconst float freqA = 0.05;\nconst float freqB = 0.09;\nconst float ampA = 6.4;\nconst float ampB = -2.7;\n\n/***** -Begin Atmospheric Scattering- *****/\n/* \n\tOkay this is not my atmospheric scattering solution, and for the\n\tlife of me I can't find the shader that I'm borrowing it from.\n\tIt's an implementation of the method discussed in this paper:\n\thttp://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\n\n\tThe nice thing is that it's not the usual Scratchapixel solution.\n*/\nfloat saturatedDot( in vec3 a, in vec3 b )\n{\n\treturn max( dot( a, b ), 0.0 );   \n}\nvec3 YxyToXYZ( in vec3 Yxy )\n{\n\tfloat X = Yxy.g * ( Yxy.r / Yxy.b );\n\tfloat Z = ( 1.0 - Yxy.g - Yxy.b ) * ( Yxy.r / Yxy.b );\n\n\treturn vec3(X,Yxy.r,Z);\n}\nvec3 XYZToRGB( in vec3 XYZ )\n{\n\t// CIE/E\n\treturn XYZ * mat3\n\t(\n\t\t 2.3706743, -0.9000405, -0.4706338,\n\t\t-0.5138850,  1.4253036,  0.0885814,\n \t\t 0.0052982, -0.0146949,  1.0093968\n\t);\n}\nvec3 YxyToRGB( in vec3 Yxy )\n{\n\tvec3 XYZ = YxyToXYZ( Yxy );\n\tvec3 RGB = XYZToRGB( XYZ );\n\treturn RGB;\n}\nvoid calculatePerezDistribution( in float t, out vec3 A, out vec3 B, out vec3 C, out vec3 D, out vec3 E )\n{\n\tA = vec3(  0.1787 * t - 1.4630, -0.0193 * t - 0.2592, -0.0167 * t - 0.2608 );\n\tB = vec3( -0.3554 * t + 0.4275, -0.0665 * t + 0.0008, -0.0950 * t + 0.0092 );\n\tC = vec3( -0.0227 * t + 5.3251, -0.0004 * t + 0.2125, -0.0079 * t + 0.2102 );\n\tD = vec3(  0.1206 * t - 2.5771, -0.0641 * t - 0.8989, -0.0441 * t - 1.6537 );\n\tE = vec3( -0.0670 * t + 0.3703, -0.0033 * t + 0.0452, -0.0109 * t + 0.0529 );\n}\nvec3 calculateZenithLuminanceYxy( in float t, in float thetaS )\n{\n\tfloat chi  \t \t= ( 4.0 / 9.0 - t / 120.0 ) * ( PI - 2.0 * thetaS );\n\tfloat Yz   \t \t= ( 4.0453 * t - 4.9710 ) * tan( chi ) - 0.2155 * t + 2.4192;\n\n\tfloat theta2 \t= thetaS * thetaS;\n    float theta3 \t= theta2 * thetaS;\n    float T \t \t= t;\n    float T2 \t \t= t * t;\n\n\tfloat xz =\n      ( 0.00165 * theta3 - 0.00375 * theta2 + 0.00209 * thetaS + 0.0)     * T2 +\n      (-0.02903 * theta3 + 0.06377 * theta2 - 0.03202 * thetaS + 0.00394) * T +\n      ( 0.11693 * theta3 - 0.21196 * theta2 + 0.06052 * thetaS + 0.25886);\n\n    float yz =\n      ( 0.00275 * theta3 - 0.00610 * theta2 + 0.00317 * thetaS + 0.0)     * T2 +\n      (-0.04214 * theta3 + 0.08970 * theta2 - 0.04153 * thetaS + 0.00516) * T +\n      ( 0.15346 * theta3 - 0.26756 * theta2 + 0.06670 * thetaS + 0.26688);\n\n\treturn vec3( Yz, xz, yz );\n}\nvec3 calculatePerezLuminanceYxy( in float theta, in float gamma, in vec3 A, \n                                 in vec3 B, in vec3 C, in vec3 D, in vec3 E )\n{\n\treturn ( 1.0 + A * exp( B / cos( theta ) ) ) * \n           ( 1.0 + C * exp( D * gamma ) + E * cos( gamma ) * cos( gamma ) );\n}\nvec3 calculateSkyLuminanceRGB( in vec3 s, in vec3 e, in float t )\n{\n\tvec3 A, B, C, D, E;\n\tcalculatePerezDistribution( t, A, B, C, D, E );\n\tfloat thetaS = acos( saturatedDot( s, vec3(0,1,0) ) );\n\tfloat thetaE = acos( saturatedDot( e, vec3(0,1,0) ) );\n\tfloat gammaE = acos( saturatedDot( s, e )\t\t   );\n\tvec3 Yz = calculateZenithLuminanceYxy( t, thetaS );\n\tvec3 fThetaGamma = calculatePerezLuminanceYxy( thetaE, gammaE, A, B, C, D, E );\n\tvec3 fZeroThetaS = calculatePerezLuminanceYxy( 0.0,    thetaS, A, B, C, D, E );\n\tvec3 Yp = Yz * ( fThetaGamma / fZeroThetaS );\n\treturn YxyToRGB( Yp );\n}\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t\t\t\t\t// An up vector.\n\n/*\n\tCombines the sky radiance from the magic above with a specular \n\thighl^H^H^H^H^H^Hsun.\n*/\nvec3 sky( in vec3 d, in vec3 ld )\n{\n    // Get the sky color.\n    vec3 sky = calculateSkyLuminanceRGB(ld, d, 3.0);\n    \n    // How night time is it? This variable will tell you.\n    float night = smoothstep(-0.0, -0.5, clamp(dot(ld, UP),-0.5, -0.0));\n    // Set a general brightness level so we don't just have a white screen,\n    // and artificially darken stuff at night so it looks good.\n    sky *= .040-.035*night;\n    \n    // Create a spot for the sun. This version gives us some nice edges\n    // without having a pow(x,VERY_LARGE_NUMBER) call.\n    \n    \n   \t// Mix the sky with the sun.\n    //sky = sky*(1.0+sunspot);\n    \n    // Also add in the stars.\n    return sky;\n}\n\n/***** -End Atmospheric Scattering- *****/\n\nmat2 r2(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s, -c, c,  s);\n}\n\n//Random function\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n//Noise function\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB)); }\nvec2 path2(in float z){ return vec2(ampB*sin(z * freqB*1.5), ampA*cos(z * freqA*1.3)); }\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\nvec3 triSmooth(in vec3 x){return cos(x*6.2831853)*0.25+0.25;} // Smooth version. Not used here.\n\nfloat surfFunc(in vec3 p){\n        \n   \n    float n = dot(tri(p*0.48 + tri(p*0.24).yzx), vec3(0.444));\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 0.7071;\n    return dot(tri(p*0.72 + tri(p*0.36).yzx), vec3(0.222)) + n; // Range [0, 1]\n    \n    \n    // Other variations to try. All have range: [0, 1]\n    \n    /*\n\treturn dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.666));\n\t*/\n    \n    /*\n    return dot(tri(p*0.5 + tri(p*0.25).yzx), vec3(0.333)) + \n           sin(p.x*1.5+sin(p.y*2.+sin(p.z*2.5)))*0.25+0.25;\n\t*/\n    \n    /*\n    return dot(tri(p*0.6 + tri(p*0.3).yzx), vec3(0.333)) + \n           sin(p.x*1.75+sin(p.y*2.+sin(p.z*2.25)))*0.25+0.25; // Range [0, 1]\n    */\n    \n    /*\n    p *= 0.5;\n    float n = dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.66));\n    p *= 1.5;\n    p.xz = vec2(p.x + p.z, p.z - p.x) * 1.7321*0.5;\n    n += dot(tri(p + tri(p*0.5).yzx), vec3(0.666*0.34));\n    return n;\n    */\n    \n    /*\n    p *= 1.5;\n    float n = sin(p.x+sin(p.y+sin(p.z)))*0.57;\n    p *= 1.5773;\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.28;\n    p *= 1.5773;\n    p.xy = vec2(p.x + p.y, p.y - p.x) * 1.7321*0.5;\n    n += sin(p.x+sin(p.y+sin(p.z)))*0.15;\n    return n*0.4+0.6;\n    */\n\n}\n// Cheap...ish smooth minimum function.\nfloat smoothMinP( float a, float b, float smoothing ){\n    float h = clamp((b-a)*0.5/smoothing + 0.5, 0.0, 1.0 );\n    return mix(b, a, h) - smoothing*h*(1.0-h);\n}\n// Smooth maximum, based on the function above.\nfloat smoothMaxP(float a, float b, float smoothing){\n    float h = clamp((a - b)*0.5/smoothing + 0.5, 0.0, 1.0);\n    return mix(b, a, h) + h*(1.0 - h)*smoothing;\n}\nfloat map(vec3 p){\n    vec2 tun = p.xy - path(p.z);\n    vec2 tun2 = p.xy - path2(p.z);\n    float d = 1.- smoothMinP(length(tun), length(tun2), 4.) + (0.5-surfFunc(p));\n    float dd = (sin(p.x/2.)+cos(p.z/1.5));\n\n#ifdef JAGGED\n    return max(d, noise(p.zx/2.)+p.y+noise(p.xz/3.)+dd+surfFunc(p/2.));\n#endif    \n    return smoothMaxP(d, (noise(p.zx/2.)+p.y+noise(p.xz/3.)+dd+surfFunc(p/2.)), .5);\n}\n\nfloat trace(vec3 r, vec3 o){\n    float t, d = 0.0;\n    \n    for(int i = 0; i < NUM_STEPS; i++){\n        vec3 p = o + t*r;\n        d = map(p);\n        if(d < EPS) break;\n        t += d *.5;\n    }\n    return t;\n}\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(EPS, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\nvec3 getNormal2(vec3 p)\n{\n    const float d = EPS;\n    return normalize(vec3(map(p+vec3(d,0.0,0.0))-map(p+vec3(-d,0.0,0.0)),\n                          map(p+vec3(0.0,d,0.0))-map(p+vec3(0.0,-d,0.0)),\n                          map(p+vec3(0.0,0.0,d))-map(p+vec3(0.0,0.0,-d))));\n}\nvec3 getNormal(vec3 p) {\n\tvec2 e = vec2(EPS, 0.0);\n\treturn normalize((vec3(map(p+e.xyy), map(p+e.yxy), map(p+e.yyx)) - map(p)) / e.x);\n}\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float t = iTime;\n    vec2 mm = iMouse.xy/iResolution.xy;\n    mm.xy -= .5;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * .15));\n    if(iMouse.z < 1.0)\n        mm = (vec2(.0, .2));\n        \n    vec3 l = normalize(vec3(mm, .2));\n    //l.xz *= r2(t);\n    // Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, t*4.);  // \"Look At\" position.\n\tvec3 o = lookAt + vec3(0.0, 0.0, -0.1); // Camera position, doubling as the ray origin.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\to.xy += path2(o.z);\n\t\n    r.yx*=r2(noise(vec2(t/3.))+1.);\n    r.zy*=r2(noise(vec2(t/2.))+1.3);\n    \n    vec3 s = sky(r, l);\n    \n    float sunspot = smoothstep(.99935, .99965, max(dot(r,l),0.0));\n    sunspot += smoothstep(.98000, 1.0, max(dot(r,l),0.0))*.05; // Corona.\n    \n    float hit = trace(r, o);\n    vec3 sp = (o+hit*r);\n    float d = map(sp);\n    vec3 norm = getNormal(sp);   \n    norm = doBumpMap(iChannel0, (sp)*(1.0/3.0), norm, 0.05);\n\n    fragColor.a = 1.0; \n    vec4 tex = vec4(tex3D(iChannel0,(sp)*(1.0/3.0), norm), 1.0);\n\tfloat c = .0;\n    c = max(c + dot(hash33(vec3(r))*2.-1., vec3(0.025)), 0.);\n    float diffuse = clamp(dot(norm, l), 0.1, 1.0);\n\n#ifdef SNOW\n    if(dot(norm,UP) > .93)\n        tex.rgb +=1.; \n#endif\n    \n    if(d < .5){\n        float fog = smoothstep(0.4, 0.8 ,hit*.03);\n        fragColor = mix(vec4(tex*diffuse), vec4(s, 1.0), fog);\n    }\n    else{\n        fragColor.rgb = s * (1.0 + sunspot);\n    }\n    \n#ifdef CINEMATIC\n    if(uv.y > .75 || uv.y < -.75)\n        fragColor=vec4(0.0);\n    \n    fragColor+=-c;\n#endif\n}","name":"Image","description":"","type":"image"}]}