{"ver":"0.1","info":{"id":"ftVyzD","date":"1661070714","viewed":145,"name":"XOR Mandelbrot","username":"MisterSirCode","description":"Why has no one ever explored the beauty of bitwise + complex numbers... this is incredible.\n\nLet it sample out for a few seconds, and then the final result will be visible","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["fractal","mandelbrot","animation","bitwise","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float frac = texture(iChannel0, fragCoord / iResolution.xy).x;\n    \n    vec3 accent = vec3(0.4, 1.0, 1.7) * frac * 2.0;\n    vec3 primary = vec3(1.5, 0.5, 0.1) * frac * 2.0;\n    \n    fragColor = vec4(mix(primary, accent, (sin(pow(frac, 0.5) * 7.0) + 1.0) / 2.0), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 bitwise(vec2 inp, float level) {\n    inp *= level;\n    int xorx = int(inp.x) | int(inp.y);\n    int xory = int(inp.y) ^ int(inp.x);\n    inp = vec2(xorx, xory) / level;\n    return inp;\n}\n\nfloat mandelbrot(vec2 z, vec2 c) {\n    float l = 0.0;\n    for (l = 0.0; l < 100.0; l += 1.0) {\n        z = vec2(z.x * z.x - z.y * z.y, abs(2.0 * z.x * z.y)) + c;\n        z = mix(bitwise(z, 100000.0), z, 0.4);\n        if(dot(z, z) > 65536.0) break;\n    }\n    return l - log2(log2(dot(z, z))) + 4.0;\n}\n\nvec2 diskPt(vec2 p) {\n    return sqrt(p.x) * vec2(sin(6.2832 * p.y), cos(6.2832 * p.y));\n}\n\nbool useSquareDistribution = false; // Disk is much cleaner\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn v * mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec4 pr = texture(iChannel0, fragCoord / res);\n    vec2 uv = ((2. * fragCoord - res) / res.x) * 4.0;\n    float ct = pr.w;\n    uv.x -= 0.5;\n    uv.y += 0.8;\n    uv = rotate(uv, -1.0);\n    \n    if (useSquareDistribution) {\n        vec2 pad = 1.333 * hash21(mod(iTime, 1000.)) / res;\n        uv += pad;\n    } else {\n        vec2 pad = 1.15 * diskPt(hash21(mod(iTime, 1000.))) / res;\n        uv += pad;\n    }\n    \n    float fr;\n    \n    fr = mandelbrot(vec2(0), uv * -2.0);\n    fr = (fr > 99.) ? 0. : sin(fr / 20.);\n    fr = clamp(fr, 0., 1.);\n    \n    float cfr = mix(fr, pr.x, .99);\n    cfr = mix(fr, cfr, clamp(ct, 0.0, 1.0));\n    \n    ct += 0.01;\n    fragColor = vec4(vec3(cfr, res), ct);\n}","name":"Buffer A","description":"","type":"buffer"}]}