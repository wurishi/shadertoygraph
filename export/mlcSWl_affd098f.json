{"ver":"0.1","info":{"id":"mlcSWl","date":"1686508784","viewed":163,"name":"Conveyor System pt.4","username":"kastorp","description":"  mouse drag on a node to move it\n  mouse click on  conveyor borders to invert its direction\n  S + mouse click: add/remove conveyor\n  A + mouse click: add/remove node (only disconected nodes can be removed)","likes":17,"published":1,"flags":48,"usePreview":0,"tags":["game","simulation","conveyors","packs"],"hasliked":0,"parentid":"mslXWB","parentname":"Conveyor System pt.3"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Conveyor System pt.4 by Kastorp\n//-----------------------------------------------\n// \n// ACTIONS:\n//   mouse drag on node to move it\n//   mouse click on conveyor border to invert its direction\n//   T: reset \n//   S + mouse click: add/remove conveyor\n//   A + mouse click: add/remove node (only disconected nodes can be removed)\n//\n//-----------------------------------------------\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n        \n    vec2 u =pos(I,R);\n    vec2 M =pos(iMouse.xy,R);\n    uvec4 vf= V(I); //get closest conveyors\n    vec4 bgcol= mix(vec4(0.67,0.67,0.47,0),vec4(0.7,0.7,0.5,0),step(0.,sign(sin(u.x*PI)*sin(u.y*PI))))\n               ,//+vec4(.1*float(vf.w)*cos(vec3(0,2,4)+float(vf.x)*2.5),0), //DEBUG \n         col=bgcol; \n    \n     \n    int LV =LVC, LE=LEC,jjo=0;\n    for(int j=0;j<int(vf.w);j++){ \n        int jj=int(vf[j]);       \n        ivec2 cd=C(jj);\n        int cIn=cd.x,cOut=cd.y;\n        int type=0; //0: connection,1=target:2:source\n        if(cOut<0) {type=2; cOut=cd.x;}\n        if(cIn<0) {type=1; cIn=cd.y;}\n        vec2 s1=N(cOut).xy,s2=N(cIn).xy;\n      \n        vec3 s =segment(u,s1,s2);\n                 \n        if(s.x>CTK && col.w<1.) {\n            if(type>0 && length(s2-u)<ETK) col=vec4(type==1?vec3(.1,.6,0):vec3(.7,0,0),0);//*(.7+ .3*cos(s.x*40.));;   \n            //else if(j==0) {col.xyz +=vec3(1)*(.1+ .1*cos(s.x*40.));col.w=0.;}\n           // continue;\n        }\n\n        if(s.x<CTK && type==0){\n            float sh=float(iFrame)/120.*DT,zm=ceil(length(s1-s2)*2.)/2.;\n            //conveyor            \n            bool connected=false;\n            ivec4 co=CO(jj),ci=CI(jj);\n            for(int k=0;k<4;k++) {\n                if(ci[k]==jjo || co[k]==jjo )  \n                connected=true;\n            }\n            if( col.w<1. || (!connected &&jjo>jj  )){\n\n               col.xyz=vec3(.35)*(1.-0.*step(.01,s.x))*(.9+.1*sign(sin(((s.y*zm+sh)*6.28*2.))));\n               //col.xyz +=vec3(1)*(.1+ .1*cos(s.x*40.));\n               if(s.x>CTK*.8) col.xyz=(iMouse.z>0. &&  LE>0 && LE==jj)? vec3(1,1,0):vec3(1);\n                //col.z=float(jj)/26.;\n                \n                col.w=1.;\n                jjo=jj;\n            }                        \n        }\n        \n\n        //HIGHLIGHT SELECTED VERTEX\n        if(iMouse.z>0. &&type==0  ){\n            if(length(u-s2.xy)<CTK*.5) col.xyz= LV==cIn ? vec3(1,1,0):vec3(0,0,1); \n            if(length(u-s1.xy)<CTK*.5) col.xyz= LV==cOut? vec3(1,1,0):vec3(0,0,1);       \n        }\n\n    }\n    //orphan nodes\n    if(iMouse.z>0.) for(int i =1;i<=NVE;i++) {\n        vec3 v=N(i);\n        if(v.z>=1.)continue;\n        float d = length(u-v.xy);\n        if(d<CTK*.5 ) col=vec4(0);\n     } \n\n    O = col;\n    \n     //objects:\n#ifdef VBOX\n     uvec4 bd= B(I); //get closest boxes\n         //col+=vec4(.5*cos(float(bd.x)/float(NBOX)*6.+vec3(0,2,4))*.5,0);\n    for(int k=0;k<4;k++){\n       int i =int(bd[k]);\n#else\n    for(int i=0;i<NBOX;i++){\n#endif\n       vec3 t= getObject(iChannel2,u,i);\n       col.xyz= .5+.5*cos(vec3(0,2,4)+ 6.* float(i)/float(NBOX));\n       int jjb=int(texelFetch(iChannel2,ivec2(i,1),0).w); //current box conveyor\n       if(jjb==0 || jjb==jjo) \n       O = mix(O, col, smoothstep(.003,-0.003,t.x));\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// circuit configuration\n//----------------------------\n       \nvoid mainImage( out vec4 O, in vec2 I )\n{\n   \n    ivec2 c=ivec2(I);\n    if(iFrame==0 ||pressed(84) ){ //INIT CIRCUIT\n        // endpoint positions\n        const vec2[] NOD=vec2[](\n            vec2(-3,-1.5),vec2(-2,-2),vec2(-1,-1.5),vec2(-1,-.5),vec2(-1,1),//1-5\n            vec2(-1,2),vec2(0,2),vec2(3.,2),vec2(0,-.5),vec2(2,1),        //6-10\n            vec2(-3,0.5),vec2(-3,-.5), vec2(3.,1.),vec2(2.,-1.),vec2(3.,0),  //11-15\n            vec2(2.,-2.),vec2(-1,-2),vec2(0,-1.5),vec2(-2,-1.5),vec2(-2,-.5), //16-20\n            vec2(1,-2),vec2(2,2),vec2(0,1),vec2(3,-1),vec2(-2,1),         //21-25\n            vec2(0,-2),vec2(1,1),vec2(1,-1.5),vec2(1,-.5),vec2(1,2),      //26-30\n            vec2(-1.5,.5),vec2(-.5,.5),vec2(.5,0),vec2(1.5,0)   //31-35\n            );\n        // connections \n        const vec2[] CON=vec2[](\n            vec2(1,2),vec2(2,3),vec2(3,4),vec2(5,6),vec2(6,7),\n            vec2(7,30),vec2(12,1),vec2(4,5),vec2(5,25),\n            vec2(13,8),vec2(9,18), vec2(14,29),vec2(22,10),vec2(23,9),\n            vec2(10,13),vec2(14,16),vec2(16,21),vec2(21,18),vec2(17,19),\n            vec2(19,20),vec2(18,3),vec2(20,4),vec2(8,22),vec2(27,23),\n            vec2(25,11),vec2(26,17),vec2(10,27),vec2(9,29),vec2(34,15),\n            vec2(29,28),vec2(28,26),vec2(7,23),vec2(30,22),vec2(20,31),\n            vec2(31,32),vec2(32,33),vec2(24,14),vec2(33,34),vec2(15,24),\n            vec2(27,34),vec2(11,12),vec2(13,15)   \n            );\n        O=vec4(0,0,0,iFrame);\n        if(c.y>1 || c.x>max(NOD.length(),CON.length())) {O*=0.;return;};\n        if(c.y==1 && c.x==0) O.xy= vec2(CON.length()+1,0);\n        else if(c.y==0 && c.x==0) O.xy= vec2(NOD.length(),0);\n        else if(c.y==1) O.xy=CON[c.x-1];\n        else if(c.y==0) O.xy=NOD[c.x-1];        \n    }\n    else {\n        int N = NVE;\n        int M = NCO;\n        int LA = LAC; //last action\n        int LV = LVC; //last action\n        O=vec4(0);\n        if(max(c.y,c.x)==0) O.w=LRES;\n        ivec2 cd=ivec2(-1);\n        bool DELAY=(iFrame - LA)>WAIT ;\n        if(c.y>3 || c.x>max(N,M)+1) discard; \n        if(c.y>1)  cd=C(c.x);\n        if(c.y==1) O.xy=vec2(C(c.x));\n        if(c.y==0) O.xy=N(c.x).xy;\n        \n        vec2 m =vec2(0,1e8);\n        vec2 MO =pos(iMouse.xy,R); \n         \n        //get closest vertex \n        for(int i =1;i<=N;i++) {\n            float d = length(MO-N(i).xy);\n            if(m.y>d) m=vec2(i,d);\n            if( LV==i  && !DELAY) m=vec2(i,0.);\n         } \n         \n         \n        //get closest potential edge\n        vec3 ms =vec3(0,0,1.2);\n        for(int i =1;i<= N;i++) for(int j =i+1;j<= N;j++){\n            float d = segment(MO, N(i).xy, N(j).xy).x,\n                  l = length(N(i).xy -N(j).xy);\n            if(d<CTK && l<ms.z) ms=vec3(i,j,l);\n        }\n        //get closest existing edge\n        int  id=0,nco=0,nvc=0;ivec4 co=ivec4(0);\n        for(int j =1;j<= M;j++) {\n            ivec2 nd =C(j).xy;\n            if(any(lessThan(nd,ivec2(0)))) continue;\n            float d = segment(MO, N(nd.x).xy, N(nd.y).xy).x;\n            if( d<CTK) id=j;\n            //edge connections\n            if(nco<4 && j!=c.x && (nd.y==cd.x || nd.x==cd.x )&& c.y==2) co[nco++]=j;\n            if(nco<4 && j!=c.x && (nd.x==cd.y || nd.y==cd.y ) && c.y==3)  co[nco++]=j; \n            //vertex connection counter\n            if(nd.y==c.x || nd.x==c.x) nvc++;\n        }\n        if(c.y==0 && c.x>0) O.z=float(nvc);\n        //store selected edge\n        if(c.y==1 && c.x==0) O.z=float(id);\n        \n        if(c.y>1) {O=vec4(co); return;}\n        if(iMouse.z<=0.) return;\n        \n        vec2 d =MO-N(c.x).xy;    \n        //selected vertex\n        if( int(m.x)>0 && m.y<CTK && iMouse.z>0. &&!pressed(EDGE_MODE) && !pressed(VERTEX_MODE) ) {\n            if(c.y==0 && c.x==int(m.x) ) O.xy += d*.3;\n            if(c.y==1 && c.x==0 ) O.xy=vec2(M,iFrame); //drag\n            if(c.y==0 && c.x==0) O.z=float(m.x); //store vertex\n        }\n        //edge actions\n        else if( !pressed(EDGE_MODE) && !pressed(VERTEX_MODE) && m.y>CTK && iMouse.z>0. && DELAY) {                    \n            ivec2 nd =C(id).xy;\n            float d = segment(MO, N(nd.x).xy, N(nd.y).xy).x;\n           // if(id>0 && c.y==0 && (c.x==nd.x || c.x==nd.y)) O.xy -= d*.01; //stretch\n            if(id>0 &&d>CTK*.8){  //invert                     \n                if(c.y==1  && c.x== id ) O.xy= vec2(nd.yx);\n                if(c.y==1  && c.x==0) O.xy=vec2(M,iFrame); \n            }\n         }\n        //add vertex\n        if( pressed(VERTEX_MODE)  && iMouse.z>0.  && m.y> CTK && DELAY) { \n                  \n            if(c.y==0 && c.x==N+1)  O.xy =vec2(MO); \n            if(c.y==0 && c.x==0) O.xy=vec2(N+1,iFrame);\n            if(id>0 && c.y==1){\n                if( c.x==id) O.x=float(N+1);\n                if( c.x==M+1) O.xy =vec2(C(id).x, N+1);\n                if( c.x==0) O.xy=vec2(M+1,iFrame);                 \n            }            \n        }\n        //remove unconnected vertex\n         if(  pressed(VERTEX_MODE)  && iMouse.z>0. && m.y< CTK  && DELAY ) { \n           int  id=0;\n            for(int j =1;j<= M;j++) {\n                ivec2 nd =C(j).xy;\n                if(any(lessThan(nd,ivec2(0)))) continue;\n                if(float(nd.x)==m.x || float(nd.y)==m.x ) id=j;\n            }\n            if(id==0){\n                if(c.y==0 && c.x>= int(m.x) ) O.xy= N(c.x+1).xy;\n                if(c.y==0 && c.x==0) O.xy=vec2(N-1,iFrame);\n                if( c.y==1 && c.x>0 && O.x>m.x) O.x-=1.;\n                if( c.y==1 && c.y>0 && O.y>m.x) O.y-=1.;\n            }\n        } \n        if( pressed(EDGE_MODE)  && iMouse.z>0. && DELAY ) {\n           \n            \n            //remove edge\n            if( id>0  && (iFrame - LA)>WAIT){                           \n                if(c.y==1  && c.x>= id ) O.xy= vec2(C(c.x+1).xy);\n                if(c.y==1  && c.x==0) O.xy=vec2(M-1,iFrame);\n            }\n            //add edge\n            else if(id==0 && ms.x!=0. && (iFrame - LA)>WAIT){\n                if(c.y==1  && c.x==M+1)  O.xy = ms.xy;\n                if(c.y==1  && c.x==0) O.xy=vec2(M+1,iFrame); \n            } \n            else if(m.y> .5 && m.y<1.5 &&N>0){           \n                if(c.y==0 && c.x==N+1)  O.xy =vec2(MO); \n                if(c.y==0 && c.x==0) O.xy=vec2(N+1,iFrame); \n                if(c.y==1  && c.x==M+1) O.xy = vec2(N+1,m.x);\n                if(c.y==1  && c.x==0) O.xy=vec2(M+1,iFrame); \n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//CONFIGURATION SETTINGS:\n#define CTK .2 //conveyor thickness\n#define ETK .3\n#define VBOX\n#define NBOX 400 //number of boxes\n#define BOX vec2(.05,.05) //box size\n#define VOR_DIST 2.4\n#define DT .8 //stability vs fun\n#define NCP 15  //number of collision points\n#define NIT 15 //number of iterations for each collision point\n#define ELASTICITY  1.\n#define REPOS .05 //enforce distance \n//--------------------------\n\n#define PI 6.2830\n#define R iResolution.xy\n#define ZERO min(iFrame,0)\n#define ONE min(iFrame,1)\n#define pressed( k)  (texelFetch(iChannel3, ivec2(k, 0), 0).x > 0.5)\n#define ROT(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define NCO  int(texelFetch(iChannel0,ivec2(0,1),0).x)\n#define NVE  int(texelFetch(iChannel0,ivec2(0,0),0).x)\n#define LAC  int(max(texelFetch(iChannel0,ivec2(0,0),0).y,texelFetch(iChannel0,ivec2(0,1),0).y))\n#define LVC  int(texelFetch(iChannel0,ivec2(0,0),0).z)\n#define LEC  int(texelFetch(iChannel0,ivec2(0,1),0).z)\n#define LRES  (texelFetch(iChannel0,ivec2(0,0),0).w)\n#define C(i) ivec2(texelFetch(iChannel0,ivec2(i,1),0).xy)\n#define CI(i) ivec4(texelFetch(iChannel0,ivec2(i,2),0))\n#define CO(i) ivec4(texelFetch(iChannel0,ivec2(i,3),0))\n#define N(i) texelFetch(iChannel0,ivec2(i,0),0).xyz\n#define V(c) floatBitsToUint(texelFetch(iChannel1,ivec2(c),0))\n#define B(c) floatBitsToUint(texelFetch(iChannel3,ivec2(c),0))\n#define VERTEX_MODE 65\n#define EDGE_MODE 83\n#define RESET 82\n#define WAIT 15\n//------------------------------\n//SHARED FUNCTIONS:\n\nvec2 pos(vec2 I,vec2 r) {return (I/r.y *2.- r/r.y)*2.2 ;}\nvec2 ipos(vec2 p,vec2 r){ return (p/2.2+r/r.y)*r.y/2.;}\n\n// SDFs from iquilezles.org/articles/distfunctions2d\n// .x = f(p), .yz = ∇f(p) with ‖∇f(p)‖ = 1\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    \n    float g = max(w.x,w.y);\n\tvec2  q = max(w,0.0);\n    float l = length(q);\n    \n    return vec3(   (g>0.0)?l: g,\n                s*((g>0.0)?q/l : ((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nvec3 segment(vec2 p,vec2 a,vec2 b) {\n    float l= length(b - a);\n    vec2 n=normalize(b - a),\n         cp=mix(a, b, clamp(dot(p - a, n) / l, 0., 1.));\n    float x = dot(p-a,n), y = length(p-a-x*n);\n    return vec3(distance(p, cp),x/l,y);\n}\n\nvec4 sdgSegment( in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  q = pa-h*ba;\n    float d = length(q);\n    return vec4(d,q/d,h);\n}\n\nvec3 objectSDF(vec2 p,int ch,vec4 t){\n    p=(p-t.xy)/t.z*ROT(t.w);\n    vec3 d= sdgBox(p,BOX);\n    return vec3(d.x*t.z,-d.yz*ROT(-t.w));\n}\n\n\nvec3 getObject(sampler2D chnData, vec2 p, int id){\n    vec4 data=  texelFetch(chnData,ivec2(id,0),0);\n    int ch = id;\n    return objectSDF(p,ch,data);\n}\n\n\n//----------------------\n//Iq https://www.shadertoy.com/view/XlXcW4\nvec3 hash( uvec3 x )\n{\n    const uint k = 1103515245U;  // GLIB C\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Voronoi, get 3 closest segments\n\nconst uint EMPTY=0xFFFFu;\nconst float MAXD=1e10;\n\nfloat getDist(vec2 u, uint id){\n    if(id==EMPTY) return MAXD;\n    ivec2 cd=C(id);\n    \n    vec2 s1=N(cd.y).xy,s2=N(cd.x).xy; \n    if(cd.x<0 ) return length(u-s1);\n    if(cd.y<0 ) return length(u-s2);\n    vec3 s =segment(u,s1,s2);\n    return s.x;\n}\nvec4 getDists(vec2 u, uvec4 d){\n   vec4 ds;\n   for(int i=0;i<3;i++) ds[i]=getDist(u,d[i]);\n   return ds;\n}\nvoid clean(inout uvec4 d,int NC){\n    if(any(greaterThan(d.xyz,uvec3(NC)))) d.xyz=uvec3(EMPTY);\n     if(any(lessThan(d.xyz,uvec3(1u)))) d.xyz=uvec3(EMPTY);\n   \n    if(d.y==d.x) d.y=EMPTY;\n    if(d.z==d.x || d.z==d.y ) d.z=EMPTY;\n}\nvoid insert(inout uvec4 d,inout vec4 df,uint id, float f){\n    if(id==0u || id==d.x ||id==d.y ||id==d.z ) return;\n    if(f<df.x){\n        d=uvec4(id,d.xyz); df=vec4(f,df.xyz);\n    }\n    else if(f<df.y){\n        d=uvec4(d.x,id,d.yz); df=vec4(df.x,f,df.yz);\n    }\n    else if(f<df.z){\n        d=uvec4(d.xy,id,d.z); df=vec4(df.xy,f,df.z);\n    }\n   \n} \n\nivec2 cross_distribution(int i,int lv)\n{\n    return (1<<lv) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   int fr=iFrame;\n   if(fr==0 ||pressed(84))  {O=uintBitsToFloat(uvec4(EMPTY));return;}\n   if((iFrame-LAC)>WAIT && (iFrame&7)!=0) { O= uintBitsToFloat(V(I)); return;}\n   //fr/=2;\n   ivec2 c=ivec2(I);\n   int NC=NCO;\n   uvec4 d= V(c);\n   clean(d,NC);\n   vec2 u =pos(I,R);\n   vec4 ds = getDists(u,d);\n   //SORT\n   if(ds.z<ds.y ||(ds.z==ds.y && d.z<d.y)){d.w=d.y;d.yz=d.zw;ds.w=ds.y;ds.yz=ds.zw;}\n   if(ds.y<ds.x ||(ds.y==ds.x && d.y<d.x)){d.w=d.x;d.xy=d.yw;ds.w=ds.x;ds.xy=ds.yw;}\n   if(ds.z<ds.y ||(ds.z==ds.y && d.z<d.y)){d.w=d.y;d.yz=d.zw;ds.w=ds.y;ds.yz=ds.zw;}\n   \n   //if((fr&2)==0)\n   for(int i=ZERO;i<4;i++){\n       uint id = 1u+ uint(hash(uvec3(iFrame,c)).x *float(NC));\n       float f = getDist(u,id);\n       insert(d,ds,id,f);\n   }\n   //else\n   for(int i=ZERO;i<4;i++){\n       int l=fr&7;\n       ivec2 nc = clamp(ivec2(0),ivec2(R), c+ cross_distribution(i,l));\n       uvec4 n  = V(nc);\n       vec4  nd =getDists(u,n);\n       for(int j=0;j<3;j++) insert(d,ds,n[j],nd[j]);\n   }\n   d.w=0u;\n    ds = getDists(u,d);\n   for(int j=0;j<3;j++) if(ds[j]<VOR_DIST)d.w++; //number of close point\n\n   O=uintBitsToFloat(d);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec4 getPos(int id){ return  texelFetch(iChannel2,ivec2(id,0),0);}\nvec4 getVel(int id){ return  texelFetch(iChannel2,ivec2(id,1),0);}\n\nvec4 getCollision(int ch1,int ch2, vec4 l1, vec4 l2,  vec2 cm)\n{\n    bool hit=false;       \n    vec3 t1d,t2d;      \n    for(int i=0;i<NIT;i++){     \n        t1d = objectSDF(cm,ch1,l1),\n        t2d = objectSDF(cm,ch2,l2);              \n        hit = max(t1d.x, t2d.x) <.002;\n        //cm += ( t1d.x*t1d.yz + t2d.x*t2d.yz)*.5;\n        cm += (max(t1d.x, t2d.x)<0. ?.1:1. )* ((t1d.x>t2d.x)  ? t1d.x*t1d.yz : t2d.x*t2d.yz);  //MATTZ algorithm\n    } \n    return vec4(cm,hit?normalize(-t1d.yz+t2d.yz):vec2(0));   \n}\n\nfloat cross2(vec2 a, vec2 b) {\n    return a.x * b.y - a.y * b.x;\n}\nvec2 cross2(vec2 a, float b) {\n    return vec2(a.y * b, a.x * -b);\n}\nvec2 cross2(float a, vec2 b) {\n    return vec2(b.y * -a, b.x * a);\n}\n\n//based on https://www.shadertoy.com/view/NtlGz7 by TDM\nvoid solveCollision(vec4 l1,vec4 l2,vec4 v1, vec4 v2, vec4 c , inout vec3 dPos, inout vec3 dVel){\n      \n   \n#if 0  \n    //no rotation   \n    vec2 n= c.zw;\n    vec4 rv=v2-v1,rp=l2-l1;\n    float pen=min(dot(rv.xy,n),0.);\n    dPos+= vec3(pen*n*2.,0);\n    dVel+= vec3(dot(rv.xy,n) <0.? dot(rv.xy,n)*n*.8:vec2(0),0.);\n#else\n    \n    //TODO:\n    // apply real mass, inertia and barycenter from here https://www.shadertoy.com/view/flySzm\n\n    vec2 n= - c.zw;\n    \n    // inverse of mass and inertia\n    float IM1=1.,IM2=IM1,\n          II1=15.,II2=II1;           \n          \n    vec2 arm1=c.xy-l1.xy,\n         arm2=c.xy-l2.xy;\n    \n    vec2 cv1=v1.xy + cross2(v1.z,arm1),\n         cv2=v2.xy + cross2(v2.z,arm2),\n         rv=cv1-cv2;\n    \n    float w1 = cross2(arm1,n),\n          w2 = cross2(arm2,n);\n          \n    float a =(1.0 + ELASTICITY) * dot(n,rv);\n    float b = IM1 + IM2 +\n            w1 * w1 * II1 +\n            w2 * w2 * II2;\n    float lambda = max(-a / b, 0.0);\n    \n    dVel += vec3(n * (lambda * IM1), cross2(arm1, n) * lambda* II1);\n    \n    float pen =min(dot(rv.xy,n),-.002);\n    dPos -= vec3(pen*n,0.);\n#endif\n\n    //hack - prevent overlaps \n    if(length(l1.xy-l2.xy)<length(BOX)*.7 && length(dPos)<length(BOX)*.7) dPos.xy=normalize(l1.xy-l2.xy)*length(BOX)*.7;\n}\nvec4 circuit( in vec2 u, out float co,in int jjb)\n{     \n    co=0.;\n    vec4 O=vec4(0);\n    vec2 I =ipos(u,R);  \n    uvec4 vf= V(I); //get closest conveyors\n    for(int j=0;j<int(vf.w);j++){ \n        int jj=int(vf[j]);       \n        ivec2 cd=C(jj);\n        int cIn=cd.x,cOut=cd.y;\n        int type=0; //0: connection,1=target:2:source\n       \n        vec2 s1=N(cOut).xy,s2=N(cIn).xy;\n        vec3 s =segment(u,s1,s2);\n        vec4 sdg= sdgSegment(u,s1,s2);\n        if(jjb>0 && jjb!=jj) continue;//skip if box if on different conveyor\n        O.xy= sdg.yz*sdg.x;\n        if(s.y>.2 && s.y<.8) co=float(jj); //current conveyor\n        vec2 n = vec2(-sdg.z,sdg.y);\n        O.zw=normalize(s2-s1);//*ceil(length(s1-s2)*2.)/2.;\n        if(cOut>=0 && cIn>=0) break;\n    }\n    return O;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O=vec4(0);\n    if(U.x>float(NBOX+1) || U.y>2.) discard;\n    int id =int(U.x-.5);  \n    \n     vec4 l1=getPos(id),v1=getVel(id);\n      \n    //collision routine \n    vec3 dPosT=vec3(0),dPosM=dPosT, dVelT=vec3(0);\n#ifdef VBOX \n     vec2 I =ipos(l1.xy,R); \n     uvec4 bd= B(I); //get closest boxes\n     \n     for(int k=0;k<4;k++){\n        int id2 =int(bd[k]);   \n        if(id2==0)continue;\n#else    \n    for(int id2=0;id2<NBOX;id2++){\n#endif\n        if(id==id2) continue;\n           \n        vec4 l2=getPos(id2),\n             v2=getVel(id2);  \n         \n        if(  min(v1.w,v2.w)>0. &&v1.w!=v2.w) continue; //skip if different conveyor\n        //predict future position:\n        l1+=vec4(v1.xy,0,v1.z)*DT;  l2+=vec4(v2.xy,0,v2.z)*DT;\n\n        vec3 dPos=vec3(0), dVel=vec3(0);\n        float hitt=0.;\n        \n        for(int k=0;k<NCP;k++) {           \n            float j= -2. + 4.*float(k)/float(NCP-1);\n            vec2 cm= (l1.xy*.1+l2.xy*.9) +  (l1.xy-l2.xy)*.5 *mat2(0,-j,j,0);\n            vec4 cl=getCollision( id, id2,  l1,  l2,   cm);  \n            \n            if(length(cl.zw)>0.) {\n          \n                 solveCollision( l1,l2,v1,v2,  cl,  dPos, dVel);\n                 hitt++;\n                 \n            } \n        }  \n        \n        if(length(dPosM.xy)<length(dPos.xy))dPosM=dPos;\n        dPosT+= dPos/max(hitt,1.);\n        dVelT+=dVel/max(hitt,1.);  \n    }\n    \n    bool reset=( getPos(id)==vec4(0)|| iFrame==0 ||pressed(82));\n        \n    if(iFrame-int(LRES)<15)  reset=true;  \n    if(U.y<1.){\n        //position\n        if(reset){\n          float x =float(id)/float(NBOX);\n          vec2 p0=  hash(uvec3(id,id,iFrame)).xy*4.-2.;\n          O= vec4(p0 ,.7,0);       \n       } else{\n           O=   getPos(id);           \n           vec4 vel = getVel(id);\n           O.xy+=vel.xy*DT;\n           O.w+=vel.z*DT;            \n           \n            O.xyz+=(dPosT*(1.- REPOS) + dPosM*.5*REPOS);\n       }\n    }  else if(U.y<2.){  \n        //velocity\n        float a =6.28* float(id)/float(NBOX);\n        if(reset) O*=0.;\n        else{\n            O=  getVel(id);\n            //O.xy-=dt*normalize(getPos(id).xy)*.00004; //attraction\n            float co=0.;\n            vec4 ds= circuit(getPos(id).xy,co,int(O.w));\n            vec2 fr= clamp(vec2(-2),vec2(2),normalize(ds.xy)*smoothstep(CTK*.1,CTK*1.,length(ds.xy)));\n            //O.xy-=dt*ds.xy*.002;\n            O.xy-=DT*fr*.002;\n            vec2 av =-smoothstep(CTK*.9,CTK*.5,length(ds.xy))*ds.zw*DT*.01;\n            O.xy=(O.xy-av)*.95+av;\n            O.z*=.98;\n            if(co>0. && O.w==0.) O.w=co; //current conveyor\n            else if(co==0. && O.w>0.) O.w=0.;\n            //O.y=dt * (getPos(id).y<-1. && O.y<0.? .05:-.003);\n            O.xyz+=dVelT;                                                            \n        }\n        \n    }  \n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Voronoi, get 4 closest boxes\n\nconst uint EMPTY=0xFFFFu;\nconst float MAXD=1e10;\n\nfloat getDist(vec2 u, uint id){\n    if(id==EMPTY) return MAXD;\n    return getObject(iChannel2,u,int(id)).x;\n\n}\nvec4 getDists(vec2 u, uvec4 d){\n   vec4 ds;\n   for(int i=0;i<4;i++) ds[i]=getDist(u,d[i]);\n   return ds;\n}\nvoid clean(inout uvec4 d,int NC){\n    if(any(greaterThan(d.xyz,uvec3(NC)))) d.xyz=uvec3(EMPTY);\n     if(any(lessThan(d.xyz,uvec3(1u)))) d.xyz=uvec3(EMPTY);\n   \n    if(d.y==d.x) d.y=EMPTY;\n    if(d.z==d.x || d.z==d.y ) d.z=EMPTY;\n    if(d.w==d.x || d.w==d.y || d.w==d.z ) d.w=EMPTY;\n}\nvoid insert(inout uvec4 d,inout vec4 df,uint id, float f){\n    if(id==0u || id==d.x ||id==d.y ||id==d.z ) return;\n    if(f<df.x){\n        d=uvec4(id,d.xyz); df=vec4(f,df.xyz);\n    }\n    else if(f<df.y){\n        d=uvec4(d.x,id,d.yz); df=vec4(df.x,f,df.yz);\n    }\n    else if(f<df.z){\n        d=uvec4(d.xy,id,d.z); df=vec4(df.xy,f,df.z);\n    }\n    else if(f<df.w){\n        d=uvec4(d.xyz,id); df=vec4(df.xyz,f);\n    }\n} \n\nivec2 cross_distribution(int i,int lv)\n{\n    return (1<<lv) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n   int fr=iFrame;\n   if(fr==0 ||pressed(84))  {O=uintBitsToFloat(uvec4(EMPTY));return;}\n   if((iFrame-LAC)>WAIT && (iFrame&7)!=0) { O= uintBitsToFloat(B(I)); return;}\n   //fr/=2;\n   ivec2 c=ivec2(I);\n   int NB=NBOX;\n   uvec4 d= B(c);\n   clean(d,NB);\n   vec2 u =pos(I,R);\n   vec4 ds = getDists(u,d);\n   //SORT\n   float tf;uint tu;\n   if(ds.y<ds.x){tu=d.x;d.x=d.y;d.y=tu;tf=ds.x;ds.x=ds.y;ds.y=tf;} //XY\n   if(ds.w<ds.z){tu=d.w;d.w=d.z;d.z=tu;tf=ds.w;ds.w=ds.z;ds.z=tf;} //ZW\n   if(ds.z<ds.x){tu=d.x;d.x=d.z;d.z=tu;tf=ds.x;ds.x=ds.z;ds.z=tf;} //XZ\n   if(ds.w<ds.y){tu=d.w;d.w=d.y;d.y=tu;tf=ds.w;ds.w=ds.y;ds.y=tf;} //UW\n   if(ds.z<ds.y){tu=d.z;d.z=d.y;d.y=tu;tf=ds.z;ds.z=ds.y;ds.y=tf;} //YZ\n   \n   //if((fr&2)==0)\n   for(int i=ZERO;i<4;i++){\n       uint id =  uint(hash(uvec3(iFrame,c)).x *float(NB));\n       float f = getDist(u,id);\n       insert(d,ds,id,f);\n   }\n   //else\n   for(int i=ZERO;i<32;i++){\n       int l=(i/4);\n       ivec2 nc = clamp(ivec2(0),ivec2(R), c+ cross_distribution(i&3,l));\n       uvec4 n  = B(nc);\n       vec4  nd =getDists(u,n);\n       for(int j=0;j<4;j++) insert(d,ds,n[j],nd[j]);\n   }\n   d.w=0u;\n    ds = getDists(u,d);\n   for(int j=0;j<4;j++) if(ds[j]<VOR_DIST)d.w++; //number of close point\n\n   O=uintBitsToFloat(d);\n}","name":"Buffer D","description":"","type":"buffer"}]}