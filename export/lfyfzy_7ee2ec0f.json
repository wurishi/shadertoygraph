{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 lighten(vec3 color, vec3 overlay, float factor) {\n    return mix(color, max(color, overlay), factor);\n}\n\nvec3 darken(vec3 color, vec3 overlay, float factor) {\n    return mix(color, min(color, overlay), factor);\n}\n\nvec3 recomb(vec3 color, vec3 factor) {\n    // Grabs only colors containing r/g/b\n    // Hue of image can be adjusted beforehand to manipulate behavior here.\n    vec3 exr = darken(color, vec3(color.x), 1.0);\n    vec3 exg = darken(color, vec3(color.y), 1.0);\n    vec3 exb = darken(color, vec3(color.z), 1.0);\n    // Extract the HSV\n    vec3 hsvr = RGBtoHSV(exr);\n    vec3 hsvg = RGBtoHSV(exg);\n    vec3 hsvb = RGBtoHSV(exb);\n    // Adjust the hues\n    hsvr.x = mod(hsvr.x + factor.x, 1.0);\n    hsvg.x = mod(hsvg.x + factor.y, 1.0);\n    hsvb.x = mod(hsvb.x + factor.z, 1.0);\n    // Convert the shifted channels back into colors\n    vec3 adr = HSVtoRGB(hsvr);    \n    vec3 adg = HSVtoRGB(hsvg);    \n    vec3 adb = HSVtoRGB(hsvb);\n    return vec3(lighten(lighten(adr, adg, 1.0), adb, 1.0)); // Combine the modified hues together\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 rgb = texture(iChannel0, uv).rgb;\n    fragColor = vec4(recomb(rgb, vec3(0.0, mod(iTime / 10.0, 1.0), 0.0)), 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"const float EPS = 0.00001;\n\nvec3 HUEtoRGB(float hue) {\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 RGBtoHCV(vec3 rgb) {\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPS) + q.z);\n    return vec3(h, c, q.x);\n}\n\n\nvec3 HSVtoRGB(vec3 hsv) {\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 RGBtoHSV(vec3 rgb) {\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPS);\n    return vec3(hcv.x, s, hcv.z);\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfyfzy","date":"1734144845","viewed":30,"name":"Hue Recombination","username":"MisterSirCode","description":"An interesting effect I stumbled on\n\nIt does not use keying.. simply math and hues to manipulate how colors are represented on videos... This math allows you to hue-shift specific colors without breaking grayscale or ruining other colors in the video.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["video","filter","camera","effect","photo"],"hasliked":0,"parentid":"","parentname":""}}