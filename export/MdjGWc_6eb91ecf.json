{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\nvoid MakeViewRay(in vec2 fragCoord, out vec3 eye, out vec3 ray)\n{\n\tvec2 ooR = 1./iResolution.xy;\n    vec2 q = fragCoord.xy * ooR;\n    vec2 p =  2.*q -1.;\n    p.x *= iResolution.x * ooR.y;\n\t\n    vec3 lookAt = vec3(0.,0.,0.+iTime*.0);\n\teye = vec3(2.5,3.,-2.5) * 1.5 + lookAt; \t\n\t\n    // camera frame\n    vec3 fo = normalize(lookAt-eye);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    float fov = .25;\n\t\n    ray = normalize(fo + fov*p.x*ri + fov*p.y*up);\n}\n\n//#define CHEAPER_NOISES\n\nfloat Noise( in vec3 x, float lod_bias )\n{\t\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n#ifndef CHEAPER_NOISES\t\n\tf = f*f*(3.0-2.0*f);\t//not terribly noticeable for higher freq noises anyway\n#endif\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n#ifdef CHEAPER_NOISES\t\n\tvec2 rg = texture( iChannel1, uv*(1./256.0), lod_bias ).yx;\n#else\t\n\tvec2 rg = texture( iChannel1, (uv+ 0.5)/256.0, lod_bias ).yx;\n#endif\t\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec2 Noise2( in vec3 x, float lod_bias )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = texture( iChannel1, uv*(1./256.0), lod_bias ).yxwz;\n\treturn mix( rg.xz, rg.yw, f.z );\n}\n\nvec4 BlendUnder(vec4 accum,vec4 col)\n{\n\tcol = clamp(col,vec4(0),vec4(1));\t\n\tcol.rgb *= col.a;\n\taccum += col*(1.0 - accum.a);\t\n\treturn accum;\n}\n\nvec2 Turbulence2(vec3 p, float lod)\n{\t\n\tvec2 t = vec2(0.);\n\tfloat oof = 1.;\n\tfor (int i=0; i<5; i++)\n\t{\n\t\tt += abs(Noise2(p,lod))*oof;\n\t\toof *= 0.5;\n\t\tp *= 2.7;\t//bigger number, more detail\n\t}\n\t\n\treturn t-vec2(1.);\n}\n\nvec2 PhaseShift2(vec3 p)\n{\n\tfloat g = (p.y+2.);\t //fall off with height\n\t\n\tfloat lod = -100.;\n\t\t\t//g*2.;\n\t\n\tp *= .4;\n\t\n\tp.x += g * iTime * .02;\n\tp.y += -iTime;\n\t\n\t\n\treturn g * Turbulence2(p, lod);\n}\n\nfloat Density(vec3 p)\n{\t\n \t//rotate Z randomly about Y  =~ swirly space\n\tfloat t = Noise(p,-100.);\n\tt *= (180. / 3.1415927)*.005 * (p.y+2.);\n\tfloat s = sin(t); float c = cos(t);\n\tp.z = p.x*s+p.z*c;\n\t\n\t//\n\tp.xz += PhaseShift2(p);\n\t\n\t//repeat it just because we can\n\tfloat f = 3.;\n\tp.xz = mod(p.xz, f) - f*.5;\n\t\n\t//column as distance from y axis\n\tfloat rx = dot(p.xz,p.xz)*5.  -p.y*0.25;\n\tif (rx < 1.)\n\t{\n\t\tfloat s = sin(3.1415927*rx);\t//hollow tube\n\t\treturn s*s*s*s;\n\t}\t\n\t\n\treturn 0.;\n}\n\nvec4 March(vec4 accum, vec3 viewP, vec3 viewD, vec2 mM)\n{\n\t//exponential stepping\n#define SHQ\t\n//#define MEDQ\t\n//#define YUCKQ\t\n#ifdef SHQ\n\t#define STEPS\t128\t\n\tfloat slices = 512.;\n#endif\t\n#ifdef MEDQ\n\t#define STEPS\t64\t\n\tfloat slices = 256.;\n#endif\t\n#ifdef YUCKQ\t\n\t#define STEPS\t32\t\n\tfloat slices = 128.;\n#endif\n\t\n\tfloat Far = 10.;\n\t\n\tfloat sliceStart = log2(mM.x)*(slices/log2(Far));\n\tfloat sliceEnd = log2(mM.y)*(slices/log2(Far));\n\t\t\t\n\tfloat last_t = mM.x;\n\t\n\tfor (int i=0; i<STEPS; i++)\n\t{\t\t\t\t\t\t\t\n\t\tsliceStart += 1.;\n\t\tfloat sliceI = sliceStart;// + float(i);\t//advance an exponential step\n\t\tfloat t = exp2(sliceI*(log2(Far)/slices));\t//back to linear\n\n\t\tvec3 p = viewP+t*viewD;\n\t\n\t\tfloat dens = Density(p);\n\t\tdens *= (t-last_t)*1.5;\n\t\t\t\t\n\t\t//color gradient\n\t\tvec3 c = mix( vec3(0.5,0.6,.7), vec3(0.2), p.y);\n\t\t\t\n\t\tc *= min(-t*.6+7.,1.);\n\t\t\n\t\taccum = BlendUnder(accum,vec4(c,dens));\n\t\t\t\n\t\tlast_t=t;\n\t}\n\t\n\treturn accum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(fragCoord,viewP, viewD);\n\n\t//ground plane\n\tfloat floor_height = -1.;\n\tfloat floor_intersect_t = (-viewP.y + floor_height) / (viewD.y);\n\tvec3 p = viewP+viewD*floor_intersect_t;\n\tvec3 c = texture(iChannel0,(p.xz)*0.125+vec2(0.575,0.575),floor_intersect_t*0.-16.).xyz;\n\tc = pow(c,vec3(2.2));\n\tc *= 0.2;\n\tfloat ceil_intersect_t = (-viewP.y + 1.) / (viewD.y);\n\n\tvec4 a = March(vec4(0), viewP, viewD, vec2(ceil_intersect_t,floor_intersect_t));\n\tc = BlendUnder(a,vec4(c,1.)).xyz;\n\tc=pow(c,vec3(1./2.2));\n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdjGWc","date":"1394704555","viewed":5762,"name":"smoke columns","username":"Antonalog","description":"Following along with Texturing & Modelling: A Procedural Approach, Chapter 9.  Distort domain, raymarch density. And simplify, simplify, simplify!","likes":151,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""}}