{"ver":"0.1","info":{"id":"4cGGz3","date":"1713199878","viewed":98,"name":"business city","username":"0x177","description":"aimed for realism, failed","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 50.\n#define SURF_DIST .0001\n#define TAU 6.283185\n#define PI 3.141592\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 1.0; // how strong is the diffuse lightning\nconst float globalSpecular = 1.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 64.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.0, 1000.0, 0.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(0.1); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat stairsmin(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 hash_v( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash_v(i+0.0)), dot(b,hash_v(i+o)), dot(c,hash_v(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat boxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nvec3 GetDist(vec3 p) {\n    float n = noise(p.xz*vec2(10.0));\n    float pl = p.y+n*0.005;\n    float d = pl;\n    float mat = 1.0;\n    \n    vec3 q = p;\n    float spacing_b = 4.0; \n    q.xz = mod(q.xz,spacing_b)-spacing_b*0.5;\n    \n    vec2 id = floor((p.xz/spacing_b));\n   \n    float val = 0.43+hash(id+100.0)*1.0;\n    \n    vec3 bp = q-vec3(0.0,val,0.0);\n    vec3 bs = vec3(1.83-val,val,1.83-val);\n    \n    float bf = boxFrame(bp,bs,0.045)*0.5;\n    float bi = box(bp,bs-0.055);\n    float b = min(bf,bi);\n    float bm = (b==bi) ? 2.0 : 0.0;\n    \n    mat = (min(d-0.1,b) == b) ? bm : 1.0;\n    d = stairsmin(d,b,0.1,4.);\n    \n    return vec3(d,mat,hash(id));\n}\n\nvec3 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec2 mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec3 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.yz;\n        \n        if(dO>MAX_DIST || abs(dS.x)<=SURF_DIST) break;\n    }\n    \n    return vec3(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\n  vec3 blinn_phong(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n\n    return ambientFactor + diffuseFactor + specularFactor;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 render(inout vec3 ro,inout vec3 rd,inout float ref) {\n    //this looks like shit but idk how to improve it\n    vec3 bg = (ref==0.0) ? mix(vec3(0.0),vec3(starfield((rd.xy+ro.z*0.005)*200.0,0.9))*5.0,rd.y-0.17) : vec3(0.0);\n    vec3 col = bg;\n   \n    vec3 rm = RayMarch(ro, rd);\n    float d = rm.x;\n    \n    float sp = globalSpecularExponent;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n\n        if (rm.y == 0.0) {\n            col = vec3(0.3);\n            ref = 0.001;\n        } else if (rm.y == 1.0) {\n            col = vec3(0.05);\n            ref = 0.0;\n            sp = 0.0;\n        } else if (rm.y == 2.0) {\n            col = 0.5 + 0.5*sin( 1.0 + 2.0*rm.z + vec3(1.4,1.6,2.0) );\n            ref = 0.8;\n        } else if (rm.y == 3.0) {\n            col = vec3(1.0);\n            ref = 0.0;\n        }\n        \n        col *= blinn_phong(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,sp,ro);\n        col *= ambientOcclusion(p+n*0.1,n);\n        col *= softshadow(p,lightPos,0.1,10.);\n        \n        ro = p+n*SURF_DIST*10.0;\n        rd = reflect(rd,n);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 1, -iTime);\n\n    \n    vec3 rd = vec3(uv,-1.0);\n    float ref = 0.0;\n    vec3 col = render(ro,rd,ref);\n    \n    if (ref>0.0) {\n        col += render(ro,rd,ref)*ref;\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//https://www.shadertoy.com/view/Md2SR3\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat starfield( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}","name":"Common","description":"","type":"common"}]}