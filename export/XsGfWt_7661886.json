{"ver":"0.1","info":{"id":"XsGfWt","date":"1530964625","viewed":526,"name":"Iridescent sphere","username":"JohnnyYuge","description":"I'm trying to create iridescence using thin film.\nMy thin film is wrong so far but by a little. I'd appreciate help !\n(only specular light is shown)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sphereiridescence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define SQR(x) ((x)*(x))\n#define PI 3.1415962\n#define F_BOOST 20.0\n\nvec3 sphereCenter = vec3(0.0);\nfloat sphereRadius = 4.0;\nfloat roughness = 0.0;\n\nvec3 cameraPos = vec3(0.0,0.0,10.0);\nvec3 cameraLook = vec3(0.0);\nvec2 cameraViewport = vec2(16.0,9.0);\n\n// Light\nvec3 lightPos = vec3(0.0);\nvec3 lightDir = vec3(0.0);\n\nvoid moveLight( ) {\n\tlightPos = cameraPos;\n    lightPos.x += 4.0;\n    lightPos.y += 4.0;\n    lightDir = normalize(lightPos - cameraLook);\n}\n\n// ===  Computation on sphere ===\n// Test if the screen coordinate is the sphere\nfloat collideWithSphere( vec2 coord ) {\n  \n    vec3 worldCoordinate = vec3(coord, 0);\n    float distance2 = pow(worldCoordinate.x - sphereCenter.x,2.0)\n        + pow(worldCoordinate.y - sphereCenter.y,2.0)\n        + pow(worldCoordinate.z - sphereCenter.z,2.0);\n    return distance2 > (sphereRadius * sphereRadius) ? 0.0 : 1.0;\n}\n\n// Transform the coordinate of screen into the coordinate of the sphere in this point\nvec3 sphereWorldCoord( vec2 coord ) {\n    vec3 pos = vec3(coord, 0.0);\n    pos.z = SQR(sphereRadius *1.2) - (SQR(coord.x - sphereCenter.x) + SQR(coord.y - sphereCenter.y));\n    pos.z = sqrt(pos.z);\n    return pos;\n}\n\n// Compute the normal of the surface of the sphere in this screen point\nvec3 sphereNormal( vec2 coord ) {\n\tvec3 swc = sphereWorldCoord( coord );  \n    return normalize(swc - sphereCenter);\n}\n\n// === BRDF (ggx) ===\nvec3 F0 = vec3(1.0,1.0,1.0) * 0.1;\nvec3 fresnel( vec3 F0, vec3 V, vec3 N ) {\n    float NdotV = dot(N,V);\n    return F0 + (1.0 - F0) * pow(1.0 - NdotV, 5.0);\n}\n\nfloat distribution(float roughness, vec3 N, vec3 H)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\nfloat geometryGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\nfloat geometry(float roughness, vec3 N, vec3 V, vec3 L)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = geometryGGX(NdotV, roughness);\n    float ggx1  = geometryGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\nvec2 translateInCameraViewport( vec2 coord ) {\n    return coord - cameraViewport / 2.0;\n}\n\n// Colors of the background in screen coordinates\nvec3 background( vec2 coord ) {\n    float skyline = 0.0;\n    vec3 skycolor = vec3(0.9,0.9,1.0) * 0.3;\n    vec3 groundcolor = vec3(1.0,0.9,0.8) * 0.2;\n    \n    float th = 0.1;\n    if(abs(coord.y - skyline) < th)\n        return mix(skycolor, groundcolor, (skyline - coord.y + th) / th / 2.0);\n    return coord.y > skyline ? skycolor : groundcolor;\n}\n\nvec2 oldMouse = vec2(0.5);\nfloat lightAngle = PI/4.0;\n\nvoid moveLightAngle() {\n    vec2 mo = (iMouse.xy/iResolution.xy - 1.0) * 2.0;\n    vec2 delta = mo - oldMouse;\n    oldMouse = mo;\n    lightAngle += delta.x;\n \t\n    lightPos.x = sin(lightAngle) * 10.0;\n  \tlightPos.z = cos(lightAngle) * 10.0;\n    lightPos.y += (delta.y +1.0) * cameraViewport.y;\n}\n\n// Reinhard (not used)\nvec3 toHDR( vec3 l ) {\n    return l / (vec3(1.0) + l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //moveLight();\n\tmoveLightAngle();\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * cameraViewport;\n\tuv = translateInCameraViewport( uv );\n\n    vec3 isSphere = vec3(collideWithSphere( uv ));\n    vec3 vertex = sphereWorldCoord( uv );\n    \n    //roughness = pow(abs(cos(iTime)), .5);\n    roughness = 1.0;\n    vec3 V = normalize(cameraPos - vertex);\t// View vector\n    vec3 N = normalize(sphereNormal( uv ));\t// Normal vector\n    vec3 L = normalize(lightPos - vertex);\t// Light vector\n    vec3 H = normalize(V + L);\t\t\t\t// Half vector\n    \n    float cosTheta = dot(N,H);\n    float theta = acos( cosTheta );\n    \n    vec2 fi = vertex.xy * 0.5;\n    float step = 5.0;\n    float speed = 0.1;\n    float t = iTime;\n        //- floor(iTime / step) * step;\n    float blend = (cos(t * PI * speed) * cos(-t * PI * speed)) * step;\n    float thickness = cos((fi.x) * blend / 160.0) \n        + sin((fi.y) * blend / 98.0);\n    \n    // Perlin noise\n    vec2 pos = uv.yx*vec2(10.,3.)*.3;\n    float pattern = pos.x;\n    pos = rotate2d( noise(pos) ) * pos;\n    thickness = lines(pos * (cos(iTime) + sin(iTime*.2)),.5);\n\n    vec3 cra = thinFilmRefl( 1.0 , theta, 1.1, 1.9 + 1.0, 1. + blend);\n\n    float D = distribution( roughness, N, H);\n    float G = geometry( roughness, N, V, L);\n    vec3 F = fresnel( cra, V, N ) * F_BOOST;\n    float denom = 4.0 * dot(N,V) * dot(N,L);\n    vec3 specular = D * G * F / denom ;\n    vec3 diffuse = (1.0 - F);\n    \n    vec3 lighting = (vec3(.5) + specular) * max(dot(N,L),0.0);\n    //lighting = toHDR( lighting );\n   \t//vec3 lighting = cra;\n    // Output to screen\n    fragColor = vec4(background(uv),1.0);\n    if(isSphere.r == 1.0) {\n        fragColor.r = mix(fragColor.r, lighting.r, lighting.r);\n        fragColor.g = mix(fragColor.g, lighting.g, lighting.g);\n        fragColor.b = mix(fragColor.b, lighting.b, lighting.b);\n    }\n        \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define LIGHT_CELERITY 299792458.0;\n#define PI 3.1415962\n#define SQR(x) ((x)*(x))\n\n// Modify n for each color of white light\nvec3 colorIOR( float n1 ) {\n    return vec3( n1, pow(n1,1.1), pow(n1,1.4));\n}\n\n// Compute angle of light reflected between M1 and M2\nfloat reflAngle( float n1, float n2, float theta ) {\n    float s = n1 * sin(theta) / n2;\n    return s <= 1.0 ? asin(s) : 0.0;\n}\n\n// Compute angle of light reflected between M1 and M2 for RGB\nvec3 reflAngle( vec3 n1, vec3 n2, vec3 theta ) {\n    vec3 ra = vec3(1.0);\n    ra.r = reflAngle( n1.r, n2.r, theta.r );\n    ra.g = reflAngle( n1.g, n2.g, theta.g );\n    ra.b = reflAngle( n1.b, n2.b, theta.b );\n    return ra;\n}\n\n// Compute angle of light reflected between M1 and M2 for RGB with modified n by RGB\nvec3 reflAngle( vec3 n1, vec3 n2, float theta ) {\n    return reflAngle( n1, n2, vec3(theta));\n}\n\n// Compute reflectivity for white light\nfloat refl( float na, float thetaa, float nb, float thetab ) {\n    float costhetaa = cos(thetaa);\n    float costhetab = cos(thetab);\n    float num = nb * costhetaa - na * costhetab;\n    float denom = nb * costhetaa + na * costhetab;\n    return num / denom;\n}\n\n// Compute reflectivity for colored light\nvec3 refl( vec3 na, vec3 thetaa, vec3 nb, vec3 thetab ) {\n    vec3 r = vec3( \n        refl( na.r, thetaa.r, nb.r, thetab.r ),\n        refl( na.g, thetaa.g, nb.g, thetab.g ),\n        refl( na.b, thetaa.b, nb.b, thetab.b )\n        );\n   \treturn r;\n}\n\n// Compute refraction angle for colored light\nvec3 colorReflAngle( vec3 n1, vec3 n2, vec3 theta ) {\n    return reflAngle( n1, n2, theta );\n}\n\n// Compute refraction angle for white light\nvec3 colorReflAngle( float n1, float n2, vec3 theta ) {\n    vec3 coloredIOR1 = colorIOR( n1 );\n    vec3 coloredIOR2 = colorIOR( n2 );\n    vec3 ra = reflAngle( coloredIOR1, coloredIOR2, theta );\n    return ra;\n}\n\n// Compute refraction angle for white light\nvec3 colorReflAngle( float n1, float n2, float theta ) {\n    return colorReflAngle( n1, n2, vec3(theta) );\n}\n \n// Compute thin film reflection for colored light\nvec3 thinFilmRefl( float d, float theta, float n1, float n2, float n3 ) {\n    vec3 color = vec3(1.0);\n    vec3 n1c = colorIOR( n1 );\n    vec3 n2c = colorIOR( n2 );\n    vec3 n3c = colorIOR( n3 );\n    vec3 theta1 = vec3( theta );\n    vec3 theta2 = colorReflAngle( n1c, n2c, theta1 );\n    vec3 theta3 = colorReflAngle( n2c, n3c, theta2 );\n    \n    vec3 r12 = refl( n1c, theta1, n2c, theta2 );\n    vec3 r23 = refl( n2c, theta2, n3c, theta3 );\n\t\n    float epsilonb = 2.0;\n    float w = 10.0 * PI * LIGHT_CELERITY;\n    vec3 kbz = sqrt(epsilonb - epsilonb * SQR(sin( theta2 )));\n    kbz = kbz * w / LIGHT_CELERITY;\n    vec3 cexpi = cos( 2.0 * kbz * d);                  \n    vec3 sexpi = sin( 2.0 * kbz * d );                                 \n    vec3 numr = r12 + r23 * cexpi;\n    vec3 numi = r12 + r23 * sexpi;\n    vec3 denomr = 1.0 + r12 * r23 * cexpi;\n    vec3 denomi = r12 * r23 * sexpi;\n    \n    vec3 numR = numr * denomr + numi * denomi;\n    vec3 denom = denomr * denomr + denomi * denomi;\n    return max(numR / denom, 0.0);\n}\n\n// NOISE\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n","name":"Common","description":"","type":"common"}]}