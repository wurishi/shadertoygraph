{"ver":"0.1","info":{"id":"WtcGRr","date":"1575455127","viewed":108,"name":"snail_char","username":"skaplun","description":"Original - https://www.pinterest.ca/pin/581527370619326518/","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["sdf","ao","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FARCLIP 3.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = vec4(1.) * step(texture(iChannel1, fragCoord.xy/iResolution.xy).a, FARCLIP)\n              * pow(texture(iChannel0, fragCoord.xy/iResolution.xy).r, 2.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Box{ vec3 origin; vec3 bounds;};\nstruct Ray{ vec3 origin, dir;};\nstruct HitRecord{vec2 dist;vec3 ptnt[2];};\nstruct Plane{ vec3 origin; vec3 normal;};\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye),\n         s = normalize(cross(f, up)),\n         u = cross(s, f);\n    return mat4(vec4(s, 0.), vec4(u, 0.), vec4(-f, 0.), vec4(vec3(0.), 1.));\n}\n\nmat3 calcLookAtMatrix(in vec3 camPosition, in vec3 camTarget, in float roll) {\n  vec3 ww = normalize(camTarget - camPosition);\n  vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\n// IQ's polynomial-based smooth minimum function.\nfloat smin( float a, float b, float k ){\n\n    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define ANIMATE\nvec2 hash22(vec2 p) { \n    float n = sin(dot(p, vec2(41, 289)));\n    p = fract(vec2(262144, 32768)*n); \n    return sin( p*6.2831853 + iTime )*.35 + .65; \n    \n}\n\nfloat Voronoi(in vec2 p){\n\tvec2 g = floor(p), o; p -= g;\n\tvec3 d = vec3(1);\n    float r = 0.;\n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n\t\t\tr = dot(o, o);\n            d.z = max(d.x, max(d.y, min(d.z, r)));\n            d.y = max(d.x, min(d.y, r));\n            d.x = min(d.x, r);\n\t\t}\n\t}\n\td = sqrt(d);\n    return min(2./(1./max(d.y - d.x, .001) + 1./max(d.z - d.x, .001)), 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    //if(iFrame != 0) discard;\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    fragColor.r = Voronoi(uv);\n    fragColor.g = Voronoi(uv + vec2(25.)) - .05;\n    fragColor.b = Voronoi(uv + vec2(50.)) - .1;\n    fragColor.a = Voronoi(uv + vec2(-72.)) - .1;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define MAX_FLOAT 1e5\n#define MIN_FLOAT 1e-5\n\nfloat opExtrussion(in vec3 p, in float sdf, in float h){\n    vec2 w = vec2( sdf, abs(p.y) - h );\n  \treturn min(max(w.x,w.y), 0.0) + length(max(w,0.0));\n}\n\n#define INSIDE(c, r) (c.x >= r.x && c.x <= r.x + r.z && c.y >= r.y && c.y <= r.y+r.w)\n#define REMAP(from, to) vec2((from.x - to.x)/to.z, (from.y - to.y)/to.w)\nfloat getChar(sampler2D Font, vec2 P, int L){\n   return texture(Font, (P + vec2(L%16, 15-L/16))/16.).a;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat map(vec3 p){\n    vec4 noiseVals = texture(iChannel0, p.xz*.5 + .5);\n    \n    float charVal = getChar(iChannel1, p.xz*vec2(.25, .35)+vec2(.5, .55), 176);\n    charVal = opExtrussion(p, .5 - charVal, .5);\n    charVal = smin(charVal, opExtrussion(p, noiseVals.r, .5), .2);\n    charVal = max(max(p.y, -p.y-.05), charVal);\n    \n    float res = charVal;\n    res = min(res, max(max(p.y+.05, -p.y-.1), opExtrussion(p, noiseVals.g, .5)));\n    res = min(res, max(max(p.y+.1,  -p.y-.15), opExtrussion(p, noiseVals.b, .5)));\n    res = min(res, max(max(p.y+.15, -p.y-.2), opExtrussion(p, noiseVals.a, .5)));\n    //res = min(res, p.y+.2);\n    return res;\n}\n\nconst float epsilon = 0.001;\nvec3 calculateNormals(vec3 pos){\n    vec2 eps = vec2(0.0, epsilon);\n    vec3 n = normalize(vec3(\n    map(pos + eps.yxx) - map(pos - eps.yxx),\n    map(pos + eps.xyx) - map(pos - eps.xyx),\n    map(pos + eps.xxy) - map(pos - eps.xxy)));\n    return n;\n}\n\nconst int stepsCnt = 64;\nfloat march(in vec3 eye, in vec3 dir){\n    float t = MIN_FLOAT;\n    for(int i = 0; i <= stepsCnt; i++){\n        vec3 p = eye + dir * t;\n        float dst = map(p);\n        \n        if(dst < .001){\n            return t;\n        }\n        \n        t += dst;\n    }\n    return -1.;\n}\n\n#define FARCLIP 3.\n\nvec4 color(vec3 camPos, vec3 localViewDir, mat3 cam2worldMatrix){\n    vec4 col;    \n    vec3 pos = camPos;\n    vec3 rayDir = cam2worldMatrix * localViewDir;\n    \n    float dis = march(pos, rayDir);\n    if(dis >= 0.){\n        pos += rayDir * dis;\n\n        vec3 nor = calculateNormals(pos);\n        nor = inverse(cam2worldMatrix) * nor;\n        nor.z *= -1.0;\n\n        float zDelta = localViewDir.z;\n        zDelta *= dis / FARCLIP;\n        \n        col = vec4(nor, zDelta);\n    }else{\n        col = vec4(FARCLIP + 1.);\n    }\n    \n    return col;\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr){\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec4 render(in vec2 fragCoord){\n\tvec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec3 camPos = vec3(0., 2., .3);\n    vec3 camLookAt = vec3(0.);\n    mat3 cam2worldMatrix = SetCamera(camPos, camLookAt, 0.0);\n    vec3 localViewDir = normalize(vec3(uv, 2.));\n    return color(camPos, localViewDir, cam2worldMatrix);\n}\n\n#define AA 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = vec4(0.);\n    for(int y = 0; y < AA; ++y)\n        for(int x = 0; x < AA; ++x){\n            fragColor += clamp(render(fragCoord + vec2(x, y) / float(AA)), 0., 1.);\n        }\n    fragColor.rgb /= float(AA * AA);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define COUNT 32\n#define FARCLIP 3.\n#define BIAS .05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\n    vec4 norz = texture(iChannel0, uv);\n    float depth = norz.w * FARCLIP;\n    float radius = .075;\n    float scale = radius / depth;\n    \n    float ao = 0.0;\n    for(int i = 0; i < COUNT; i++){\n        vec2 randUv = (fragCoord.xy + 23.71 * float(i)) / iChannelResolution[1].xy;\n        vec3 randNor = texture(iChannel1, randUv).xyz * 2.0 - 1.0;\n        if(dot(norz.xyz, randNor) < 0.0)\n            randNor *= -1.0;\n        \n        vec2 off = randNor.xy * scale;\n        vec4 sampleNorz = texture(iChannel0, uv + off);\n        float depthDelta = depth - sampleNorz.w * FARCLIP;\n        \n        vec3 sampleDir = vec3(randNor.xy * radius, depthDelta);        \n        float occ = max(0.0, dot(normalize(norz.xyz), normalize(sampleDir)) - BIAS) / (length(sampleDir) + 1.0);\n        ao += 1.0 - occ;\n    }\n    ao /= float(COUNT);\n    \n    fragColor = vec4(vec3(ao), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}