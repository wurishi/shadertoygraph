{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//#define BIG_PIXELS\n\n#define LIMIT_IT 32\n#define PI 3.14159265\n#define NEAR 0.0\n#define FAR 64.0\n#define INF (FAR+1.0);\n#define RADIUS 2.0\n\n#define DRAW_LIGHT_SOURCE\n\n//vec3 lightSource = vec3(4.0*sin(iTime), 0.0+4.0*(sin(iTime*4.0)+1.0)/2.0, 4.0*cos(iTime));\n#define lightSource vec3(4.0*sin(iTime),0.0+4.0*(sin(iTime*4.0)+1.0)/2.0,4.0*cos(iTime))\n\n\nfloat sphere (vec3 o, vec3 d) {\n    // <xyz,xyz> = R^2\n    float disc = 4.0*dot(d,o)*dot(d,o)-4.0*dot(d,d)*(dot(o,o)-RADIUS*RADIUS);\n    if (disc < 0.0) return INF;\n    return (-2.0*dot(d,o)-sqrt(disc))/(2.0*dot(d,d));\n}\n\nfloat plane (vec3 o, vec3 d) {\n    // y = p plane\n    float p = -RADIUS - abs(sin(iTime*2.0))*0.25;\n    float t = (p-o.y) / d.y;\n    if (t < 0.0) return INF;\n    return t;\n}\n\nfloat scene (vec3 o, vec3 d) {\n    float intSphere = sphere(o, d);\n    float intPlane = plane(o, d);\n    float inter = min(intPlane, intSphere);\n    return inter;\n}\n\nfloat shadow (vec3 o) {\n    vec3 dir = lightSource-o;\n    vec3 lightDirection = -normalize(dir);\n    float t = iTime;\n    float shadow = 1.0;\n    for (int i = 0; i < 16; ++i) {\n        float ar = float(i)/16.0 * 2.0 - 1.0;\n        vec3 sample_ = vec3(ar,1.0-ar,1.0-ar);\n        vec3 lightDir = -lightDirection+sample_*0.05;\n        // ray to the light source\n        vec3 or = o;\n        if (o.y < -RADIUS + 0.0001)\n            or += lightDir*0.01;\n        else\n            or -= lightDir*0.01;\n        float lightInter = scene(or, lightDir);\n        if (lightInter > 0.0 && lightInter < length(dir))\n        shadow *= 0.95;\n\t}\n    return shadow;\n}\n\nfloat fog (vec3 o) {\n    return (FAR-length(o)) / (FAR-NEAR);\n}\n\nvec3 normal (vec3 o) {\n    vec3 normal = vec3(0,1,0);\n    if (o.y > -RADIUS+0.0001) {\n    \t/* get the sphere normal */\n    \tnormal = normalize(o);\n    }\n    return normal;\n}\n\nfloat light (vec3 o) {\n    vec3 lightDirection = -normalize(lightSource-o);\n    vec3 n = normal(o);\n    float light = max(0.0, dot(-lightDirection, n));\n    \n    /* specular */\n    float spec = pow(light,128.0) + pow(light,32.0);\n    \n    return mix(0.5, 1.0, light)+spec;\n}\n\nvec3 fragmentColor (vec3 o) {\n    vec3 color = vec3(0.0);\n     if (o.y < -RADIUS+0.0001) {\n            /* texture ground channel0 */\n         \tcolor = texture(iChannel0, o.xz*0.25).rgb;\n        } else {\n         \tvec2 ballUv = (o.xy/RADIUS+1.0)*0.5;\n         \t/* texture sphere */\n            //color.rgb = vec3(1.0, 0.75, 0.5);\n         \tcolor = texture(iChannel2, ballUv).rgb;\t\n        \tif (o.z < 0.0) {\n         \t\t/* blend with webcam channel1 */\n         \t\tcolor = mix(color, texture(iChannel1, ballUv).rgb, pow(-o.z/RADIUS, 5.0));\n            }\n        }\n    return color;\n}\n\nvec3 pointLight (vec3 o, vec3 d, float limit) {\n    float light = 0.0;\n    for (int i = 0; i < LIMIT_IT; ++i) {\n        float fi = float(i);\n        if (fi > limit) break;\n     \tvec3 sam = o+d*fi*0.5;\n        light += exp(-length(sam-lightSource)*4.0);\n        if (light >= 1.0)\n            break;\n    }\n    \n    return vec3(clamp(pow(light, 8.0) + light,0.0,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n//void main(void)\n{\n    vec3 color = vec3(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0-1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    float t = iTime;\n    \n    #ifdef  BIG_PIXELS\n    uv.xy = floor(uv.xy*26.0)/26.0;\n    #endif\n    \n    vec3 o = vec3(uv.x + sin(t*0.5) * 2.0, uv.y + RADIUS * 0.25, -RADIUS-2.0+cos(t*0.125)*1.0);\n    vec3 d = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float inter = scene(o, d);\n    float fogV = 0.0;\n    if (inter < FAR) {\n        vec3 point = o+inter*d;\n        color = vec3(1.0);\n        color *= fragmentColor(point);\n        color *= light(point);\n        color *= shadow(point);\n        fogV = fog(point);\n        if (point.y < RADIUS/2.0) {\n         \t// fake ao\n            if (point.y > -RADIUS+0.0001) {\n                color *= pow(1.0 - exp(-length(point.xz)*3.85), 64.0);    \n            } else {\n\t\t\t\tcolor *= pow(1.0 - exp(-length(point.xz)*(1.5+2.0* abs(sin(iTime*2.0)) )), 8.0) ;        \t\n            }\n        }\n        \n       \n    }\n    color *= fogV;\n    #ifdef DRAW_LIGHT_SOURCE\n    color += pointLight(o, d, inter);\n    #endif\n    fragColor = vec4(color, 1.0);\n}\n\n    // xyz = o+t*d     (t > 0)\n    // <o+t*d, o+t*d> = R^2\n    // <o,o> + t*2*<d,o> + t^2 * <d,d> = R^2\n    // (<d,d>)*t^2 + (2*<d,o>)*t + (<o,o>-R^2) = 0\n    // t = (-2*<d,o> +- sqrt( 4*<d,o>^2 - 4*<d,d>*(<o,o>-R^2)) )/ (2*<d,d>)","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":true,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsjXzh","date":"1409156990","viewed":1055,"name":"germangb simple raytracer","username":"germangb","description":"Trying to make a raytracer","likes":11,"published":1,"flags":2,"usePreview":0,"tags":["simple","raytracer"],"hasliked":0,"parentid":"","parentname":""}}