{"ver":"0.1","info":{"id":"wdtcD2","date":"1601812909","viewed":71,"name":"24 - Eye","username":"Krabcode","description":"Wise men say that in this shader you can see your future if you imagine it hard enough.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["noise","displacement","colors","gradient","backbuffer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"19 - Feedback\" by Krabcode. https://shadertoy.com/view/wdcczX\n// 2020-10-04 10:43:49\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n    colorPoint[colorsPerGradient] gradient = colorPoint[](\n        colorPoint(0.0, vec4(hexToRgb(0x1b262c)*.5, 1.)),\n        colorPoint(0.6, vec4(hexToRgb(0x1b262c), 1.)),\n        colorPoint(0.7, vec4(hexToRgb(0x0f4c75), 1.)),\n        colorPoint(0.8, vec4(hexToRgb(0x3282b8), 1.)),\n        colorPoint(0.95, vec4(hexToRgb(0xbbe1fa), 1.)),\n        colorPoint(1.0, vec4(hexToRgb(0xbbe1fa), 1.))\n        // colorPoint(1., vec4(vec3(1), 1.))\n    );\n    \n    float pct = -1.0+pow(length(texture(iChannel0, uv)), 1.3);\n    \n    vec4 color = gradientColorAt(pct, gradient, 0);\n    \n    float innerCircleBlack = smoothstep(innerRadius-innerTransition, innerRadius, length(cv));\n    color.rgb *= innerCircleBlack;\n    \n    float outerCircleGray = smoothstep(outerRadius-outerTransition, outerRadius,  length(cv));\n    color.rgb = mix(color.rgb, vec3(.0), outerCircleGray);\n    fragColor = gammaCorrection(color);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define t iTime*0.75\n#define PI 3.14159\n\nmat2 rotate(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// cubic pulse by inigo quilez\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\t  \nfloat iqNoise(vec3 x){\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f  = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix(hash(n+0.0), hash(n+1.0), f.x),\n    mix(hash(n+57.0), hash(n+58.0), f.x), f.y),\n    mix(mix(hash(n+113.0), hash(n+114.0), f.x),\n    mix(hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec2 p, float time){\n    float sum = 0.;\n    float freq = 0.5;\n    float amp = 1.;\n    for (int i = 0; i < 4; i++){\n        sum += amp*(1.-2.*iqNoise(vec3(p*freq, time)));\n        freq *= 2.0;\n        amp *= .5;\n        p += 8.1534;\n        p *= rotate(0.8);\n    }\n    return sum;\n}\n\nvec2 wind(vec2 uv, vec2 cv){\n    \n    float fromCenter = atan(cv.y, cv.x)+PI;\n    float startAngle = fromCenter;\n    float windNoise = fbm(uv*30.5, t);\n    float windAngle = startAngle+windNoise*PI*0.25;\n    vec2 windOffset = vec2(cos(windAngle), sin(windAngle))*.0005;\n    return windOffset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 cv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    vec2 move = wind(uv, cv);\n    float seed = .75*pow(length(texture(iChannel2, uv*0.8).rgb), 0.7) + \n        \t\t.25*pow(length(texture(iChannel2, uv*3.0).rgb), 0.1);\n    vec3 new = vec3(seed);\n    vec3 old = texture(iChannel0, uv+move).rgb - .0001;\n    vec3 clr = mix(new, old, .995);\n    fragColor = vec4(clr, 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int colorsPerGradient = 6;\n\n//--------------------------------------GRADIENT-----------------------------------\n//--------------------------------color point array logic--------------------------\n//-------------------------------------by Krabcode---------------------------------\n\nstruct colorPoint\n{\n    float pos;\n    vec4 val;\n};\n\n\ncolorPoint emptyColorPoint()\n{\n    return colorPoint(1.1, vec4(1.,0.,0.,1.));\n}\n\n\nfloat map(float value, float start1, float stop1, float start2, float stop2)\n{\n    return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));\n}\n\nfloat norm(float value, float start, float stop)\n{\n    return map(value, start, stop, 0., 1.);\n}\n\nint findClosestLeftNeighbourIndex(float pos, colorPoint[colorsPerGradient] gradient)\n{\n    for(int i = 0; i < 100; i++){\n        if(pos >= gradient[i].pos && pos <= gradient[i+1].pos){\n            return i;\n        }\n        if(i >= gradient.length()){\n            return 0;\n        }\n    }\n    return 0;\n}\n\nvec4 gradientColorAt(float normalizedPos, colorPoint[colorsPerGradient] gradient, int blendType)\n{\n    float pos = clamp(normalizedPos, 0., 1.);\n    int leftIndex = findClosestLeftNeighbourIndex(pos, gradient);\n    int rightIndex = leftIndex + 1;\n    colorPoint A = gradient[leftIndex];    \n    colorPoint B = gradient[rightIndex];\n    float normalizedPosBetweenNeighbours = norm(pos, A.pos, B.pos);\n    return mix(A.val, B.val, normalizedPosBetweenNeighbours);\n}\n\n// hexToRgb from here: https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader\nvec3 hexToRgb(int color)\n{\n    float rValue = float(color / 256 / 256);\n    float gValue = float(color / 256 - int(rValue * 256.0));\n    float bValue = float(color - int(rValue * 256.0 * 256.0) - int(gValue * 256.0));\n    return vec3(rValue / 255.0, gValue / 255.0, bValue / 255.0);\n}\n\n\nvec3 gammaCorrection(vec3 rgb){\n    return pow(smoothstep(0., 1., rgb), vec3(1.0/2.2));\n}\n\nvec4 gammaCorrection(vec4 rgba){\n    return vec4(gammaCorrection(rgba.rgb), 1.);\n}\n\n\n\nfloat innerRadius = .18;\nfloat innerTransition = .05;\nfloat outerRadius = .46;\nfloat outerTransition = .05;\n","name":"Common","description":"","type":"common"}]}