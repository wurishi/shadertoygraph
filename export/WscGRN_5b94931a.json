{"ver":"0.1","info":{"id":"WscGRN","date":"1567882205","viewed":196,"name":"Dual Complex Newton Fractal","username":"skye_adaire","description":"Uses the dual complex numbers for automatic differentiation. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","complex","dual","newton","automatic","differentiation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Created by Skye Adaire\n\n#define pi32 3.1415926535\n#define tau32 6.2831853072\n#define eps32 10e-15\n\nfloat alpha(float x, float a, float b)\n{\n   return (x - a) / (b - a);\n}\n\n#define uclamp(x) clamp(x, 0.0, 1.0)\n#define ualpha(x, a, b) uclamp(alpha(x, a, b))\n\n//begin Hypercomplex\n\n#define Real float\n\nReal H_negate(Real r)\n{\n    return -r;\n}\n\nReal H_conjugate(Real r)\n{\n    return r;\n}\n\nReal H_norm(Real r)\n{\n    return abs(r);\n}\n\nReal H_sqnorm(Real r)\n{\n    return r * r;\n}\n\nReal H_add(Real lhs, Real rhs)\n{\n    return lhs + rhs;\n}\n\nReal H_subtract(Real lhs, Real rhs)\n{\n    return lhs - rhs;\n}\n\nReal H_multiply(Real lhs, Real rhs)\n{\n    return lhs * rhs;\n}\n\nReal H_divide(Real lhs, Real rhs)\n{\n    return lhs / rhs;\n}\n\nbool H_isZero(Real r)\n{\n    return H_norm(r) < eps32;\n}\n\nReal H_sq(Real r)\n{\n    return r * r;\n}\n\n#define Complex vec2\n\nComplex H_negate(Complex h)\n{\n    return -h;\n}\n\nComplex H_conjugate(Complex h)\n{\n    return Complex(h[0], -h[1]);\n}\n\nReal H_sqnorm(Complex h)\n{\n    return dot(h, h);\n}\n\nReal H_norm(Complex h)\n{\n    return length(h);\n}\n\nComplex H_inverse(Complex h)\n{\n    return H_conjugate(h) / H_sqnorm(h);\n}\n\nComplex H_normalize(Complex h)\n{\n    return normalize(h);\n}\n\nComplex H_add(Complex lhs, Complex rhs)\n{\n    return lhs + rhs;\n}\n\nComplex H_subtract(Complex lhs, Complex rhs)\n{\n    return lhs - rhs;\n}\n\nComplex H_multiply(Complex lhs, Complex rhs)\n{\n    Real lhs_0 = lhs[0];\n    Real lhs_1 = lhs[1];\n    Real rhs_0 = rhs[0];\n    Real rhs_1 = rhs[1];\n\n    return Complex(\n        H_subtract(H_multiply(lhs_0, rhs_0), H_multiply(H_conjugate(rhs_1), lhs_1)),\n        H_add(H_multiply(rhs_1, lhs_0), H_multiply(lhs_1, H_conjugate(rhs_0))));\n}\n\nComplex H_divide(Complex lhs, Complex rhs)\n{\n    return H_multiply(lhs, H_conjugate(rhs)) / H_sqnorm(rhs);\n}\n\nbool H_isZero(Complex h)\n{\n    return H_norm(h) < eps32;\n}\n\nReal H_argument(Complex h)\n{\n   return atan(h[1], h[0]);//[-pi, pi]\n}\n\nReal H_argument2(Complex h)\n{\n    Real angle = H_argument(h);\n    return angle < Real(0) ? angle + tau32 : angle;//[0, tau]\n}\n\nComplex H_versor(Real angle)\n{\n    return Complex(cos(angle), sin(angle));\n}\n\nstruct PolarComplex\n{\n    float norm;\n    float argument;\n};\n\nPolarComplex H_toPolar(Complex h)\n{\n    return PolarComplex(H_norm(h), H_argument(h));\n}\n\nComplex H_toCartesian(PolarComplex h)\n{\n    return h.norm * H_versor(h.argument);\n}\n\nPolarComplex H_power(PolarComplex polar, Real exponent)\n{\n    return PolarComplex(pow(polar.norm, exponent), polar.argument * exponent);\n}\n\nComplex H_power(Complex h, Real exponent)\n{\n    return H_toCartesian(H_power(H_toPolar(h), exponent));\n}\n\nComplex H_sq(Complex h)\n{\n    return H_multiply(h, h);\n}\n\n#define DualComplex mat2x2\n\nDualComplex D_add(DualComplex lhs, DualComplex rhs)\n{\n    return lhs + rhs;\n}\n\nDualComplex D_subtract(DualComplex lhs, DualComplex rhs)\n{\n    return lhs - rhs;\n}\n\nDualComplex D_multiply(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_multiply(rhs[0], lhs[0]),\n        H_add(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])));\n}\n\nDualComplex D_divide(DualComplex lhs, DualComplex rhs)\n{\n    return DualComplex(\n        H_divide(rhs[0], lhs[0]),\n        H_divide(\n            H_subtract(H_multiply(lhs[1], rhs[0]), H_multiply(lhs[0], rhs[1])),\n            H_sq(rhs[0])));\n}\n\nDualComplex D_power(DualComplex d, Real exponent)\n{\n    return DualComplex(\n        H_power(d[0], exponent),\n        H_multiply(exponent * H_power(d[0], exponent - 1.0), d[1]));\n}\n\n//end Hypercomplex\n\n//https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getPlaneColor(Complex z)\n{\n    PolarComplex polar = H_toPolar(z);\n    \n    return hsv2rgb(vec3(polar.argument / tau32, 1, 1));\n}\n\nDualComplex f(DualComplex z)\n{\n    //return D_power(z, 3.0) - DualComplex(1, 0, 0, 0);\n    //return D_power(z, 3.0) - 2.0 * z + DualComplex(2, 0, 0, 0);\n    return \n        D_multiply(DualComplex(1.0, -2.0, 0, 0), D_power(z, 7.0)) +\n        D_multiply(DualComplex(-10.0, 10.0, 0, 0), D_power(z, 6.0)) +\n        D_multiply(DualComplex(-5.0, 2.0, 0, 0), D_power(z, 3.0)) + \n        D_multiply(DualComplex(-1.0, -6.0, 0, 0), D_power(z, 2.0)) + \n        DualComplex(100, -20,  0, 0);\n}\n\nComplex newton(Complex z, out float m)\n{\n    int i;\n    m = 0.0;\n    \n \tfor(i = 0; i < 50; i++)\n    {\n        DualComplex d = DualComplex(z, 1, 0);\n        DualComplex fz = f(d);\n        \n        Complex zt = z;\n        z = z - H_divide(fz[0], fz[1]);\n        \n        if(H_norm(zt - z) < 0.0001) \n        {\n            break;\n        }\n        \n        //https://www.shadertoy.com/view/Md2yDG\n        vec2 w = H_inverse(z - zt);\n        m += exp(-length(w));\n    }\n    \n    m = 1.0-fract(m);//1.0 - min(m / 20.0, 1.0);\n\n    return z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 clip = uv * 2.0 - 1.0;\n   \tclip.x *= iResolution.x / iResolution.y;\n    vec2 ss = clip * vec2(1.5);\n\n    float i;\n    vec3 color = getPlaneColor(newton(ss, i));\n    color *= i;\n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}