{"ver":"0.1","info":{"id":"ftjfRc","date":"1652540208","viewed":154,"name":"when the highlight is sus","username":"rucksack","description":"Testing lighting models from https://en.wikipedia.org/wiki/Specular_highlight#Models\nSpecular highlights from left to right: Phong, Gaussian, Beckmann, Cook-Torrance.\nStandard Phong stuff for the remaining lighting. Spin around with mouse.","likes":8,"published":1,"flags":64,"usePreview":0,"tags":["amogus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtSSR1","filepath":"https://soundcloud.com/leoseazon/amongus","previewfilepath":"https://soundcloud.com/leoseazon/amongus","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// Uncomment to use only one color\n// (to make it easier to see the differences)\n#define USE_DIFFERENT_COLORS 1\n\n\n\n// Raymarching parameters\n#define MAX_STEPS 512\n#define NEAR_ENOUGH 0.001\n#define TOO_FAR 85.0\n#define SMOOTH_FACTOR 0.3\n\n// Lighting parameters\n#define SHININESS 16.\n#define ATTENUATION 0.6\n\n// Colors\n#define BACKGROUND_COLOR vec3(.7)\n#define LIGHT_COLOR vec3(1)\n#define SUS_COLOR vec3(0.929,0.200,0.231)\n\n#define COLOR0 vec3(0.384,0.627,0.918)\n#define COLOR1 vec3(0.70196,0.64314,0.24706)\n#define COLOR2 vec3(0.0902,0.42745,0.2902)\n#define COLOR3 vec3(0.76471,0.33725,0.76471)\n\n#define PI 3.14159265359\n\nconst vec3 visor_color = COLOR0;\n\n// SDF from Inigo Iquilez (though I might as well work this out myself someday -_-)\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n// Smooth operator by Inigo Iquilez\nfloat smooth_min(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.) / k;\n    return min(a, b) - h*h*h*k*(1./6.);\n}\n\n// Alternate minimum for preserving material color\n// (using blend factor like in iq's article)\nvec4 smooth_min2(vec4 a, vec4 b, float k) {\n    float h = max(k - abs(a.x-b.x), 0.) / k;\n    vec3 c;\n    if (a.x < b.x)\n        c = mix(a.yzw, b.yzw, h*h*h*.5);\n    else\n        c = mix(a.yzw, b.yzw, 1. - h*h*h*.5);        \n    return vec4(min(a.x, b.x) - h*h*h*k*(1./6.), c);\n}\n\nfloat distance_from_everything(vec3 p) {\n    float body = capsule(p, vec3(0, -.1, 0), vec3(0, 1, 0), 1.);\n    float visor = capsule(vec3(p.x, p.y*.8, p.z), vec3(-.2, .5, -1), vec3(.2, .5, -1), .4);\n    float backpack = capsule(vec3(p.x, p.y*.5, p.z), vec3(-.2, .2, 1), vec3(.2, .2, 1), .4);\n    vec3 l = vec3(-.5, -.1, 0);\n    float lh = 1.4;\n    float left_leg = capsule(p, l, l - vec3(0, lh, 0), .4);\n    l.x = -l.x;\n    float right_leg = capsule(p, l, l - vec3(0, lh, 0), .4);\n    float d = smooth_min(body, visor, SMOOTH_FACTOR);\n    d = smooth_min(d, backpack, SMOOTH_FACTOR);\n    d = smooth_min(d, left_leg, SMOOTH_FACTOR);\n    d = smooth_min(d, right_leg, SMOOTH_FACTOR / 2.);\n    return d;\n}\n\nvec3 material_color(vec3 p, vec2 ij) {\n    vec3 body_color = COLOR1;\n#ifdef USE_DIFFERENT_COLORS\n    if (ij.x < 1.) {\n        body_color = COLOR1;\n    } else if (ij.x < 2.) {\n        body_color = COLOR2;\n    } else if (ij.x < 3.) {\n        body_color = COLOR3;\n    } else {\n        body_color = COLOR1;\n    }\n#endif\n    vec4 body = vec4(capsule(p, vec3(0, -.1, 0), vec3(0, 1, 0), 1.), body_color);\n    vec4 visor = vec4(capsule(vec3(p.x, p.y*.8, p.z), vec3(-.2, .5, -1), vec3(.2, .5, -1), .4), visor_color);\n    vec4 backpack = vec4(capsule(vec3(p.x, p.y*.5, p.z), vec3(-.2, .2, 1), vec3(.2, .2, 1), .4), body_color);\n    vec3 l = vec3(-.5, -.1, 0);\n    float lh = 1.4;\n    vec4 left_leg = vec4(capsule(p, l, l - vec3(0, lh, 0), .4), body_color);\n    l.x = -l.x;\n    vec4 right_leg = vec4(capsule(p, l, l - vec3(0, lh, 0), .4), body_color);\n    vec4 d = smooth_min2(body, visor, SMOOTH_FACTOR);\n    d = smooth_min2(d, backpack, SMOOTH_FACTOR);\n    d = smooth_min2(d, left_leg, SMOOTH_FACTOR);\n    d = smooth_min2(d, right_leg, SMOOTH_FACTOR / 2.);\n    return d.yzw;\n}\n\nfloat ray_march(vec3 ray_origin, vec3 ray_direction) {\n    // How far we've traveled\n    float d = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Where we stand\n        vec3 point = ray_origin + ray_direction*d;\n        // How far anything is from us\n        float current_distance = distance_from_everything(point);\n        // March on\n        d += current_distance;\n        // Check status - have we reached a surface?\n        if (current_distance < NEAR_ENOUGH || d > TOO_FAR)\n            break;\n    }\n    return d;\n}\n\n// See https://iquilezles.org/articles/normalsSDF\nvec3 estimate_normal(vec3 point) {\n    vec2 e = vec2(NEAR_ENOUGH, 0); // x smol, y none\n    // Find normal as tangent of distance function\n    return normalize(vec3(\n        distance_from_everything(point + e.xyy) - distance_from_everything(point - e.xyy),\n        distance_from_everything(point + e.yxy) - distance_from_everything(point - e.yxy),\n        distance_from_everything(point + e.yyx) - distance_from_everything(point - e.yyx)\n    ));\n}\n\nfloat phong_specular(vec3 n, vec3 c, vec3 l) {\n    float shininess = 2.5;\n    return pow(max(dot(reflect(-l, n), c), 0.), shininess) * .5;\n}\n\nfloat gaussian_specular(vec3 n, vec3 c, vec3 l) {\n    vec3 h = (c + l) / 2.;\n    float m = .4;\n    return exp(-pow(acos(dot(n, h)) / m, 2.));\n}\n\nfloat beckmann_specular(vec3 n, vec3 c, vec3 l, float m) {\n    vec3 h = (c + l) / 2.;\n    float a = acos(dot(n, h));\n    // Used abs(cos(a)) here, what's the proper way of doing this?\n    return exp(-pow(tan(a), 2.)/(m*m))/(PI*m*m*pow(abs(cos(a)), 4.));\n}\n\nfloat cook_torrance_specular(vec3 n, vec3 v, vec3 l) {\n    vec3 h = (v + l) / 2.;\n    float D = beckmann_specular(n, v, l, .4);\n    float n2 = .1;\n    float R0 = (1. - n2)/(1. + n2) * (1. - n2)/(1. + n2);\n    float theta = acos(dot(n, v));\n    float F = R0 + (1. - R0)*pow(1. - cos(theta), 5.);\n    float G = min(1., min(2.*dot(h, n)*dot(v, n)/dot(v, h), 2.*dot(h, n)*dot(l, n)/dot(v, h)));\n    return D*F*G/(4.*dot(v, n)*dot(n, l));\n}\n\nvec3 lighting(vec3 point, vec3 camera, vec2 ij) {\n    // Avoid casting specular highlight from the void\n    if (length(point - camera) > TOO_FAR*0.99)\n        return BACKGROUND_COLOR;\n\n    vec3 n = estimate_normal(point);\n    vec3 l = normalize(vec3(1, 1, -2)-point);\n    vec3 c = normalize(camera-point);\n    float d = length(c);\n    // Standard Phong diffuse term\n    vec3 material = material_color(point, ij);\n    vec3 color = material * max(dot(n, l), 0.) * .6;\n    if (ij.x < 1.) {\n        color += LIGHT_COLOR * phong_specular(n, c, l);\n    } else if (ij.x < 2.) {\n        color += LIGHT_COLOR * gaussian_specular(n, c, l);\n    } else if (ij.x < 3.) {\n        color += LIGHT_COLOR * beckmann_specular(n, c, l, .3);\n    } else {\n        color += LIGHT_COLOR * cook_torrance_specular(n, c, l);\n    }\n    // Attenuation on point light, only obeying square law\n    float attenuation = 1./(ATTENUATION*d*d);\n    color = attenuation * color;\n    // Contribution from suns\n    color += mix(SUS_COLOR, material, .3) * max(dot(n, normalize(vec3(1, .2, -.4))), 0.) * .4;\n    color += material * max(dot(n, normalize(vec3(-1, .2, -.4))), 0.) * .5;\n    // Ambient intensity\n    color += material * .1;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = (vec2(mod(fragCoord.x, iResolution.x*.25), fragCoord.y) - vec2(.125, .5) * iResolution.xy) / iResolution.y;\n    \n    vec2 ij = floor(fragCoord/iResolution.xy * vec2(4, 1));\n\n    float music = texture(iChannel0, vec2(fragCoord.x, .25)).r;\n\n    // Rotated view\n    //float a = PI*.6 + 2.*PI*iMouse.x/iResolution.x;\n    //float a = PI*.6 + .35*sin(2.*iTime);\n    // Considered adding + .2*(ij.x-1.5) in the sin(),\n    // but it sorta breaks the comparison between the models.\n    float a = PI*.5 + sin(.7*PI*music) + 2.*PI*iMouse.x/iResolution.x;\n    mat3 rotY = mat3(\n        -sin(a),      0, cos(a),\n              0,      1, 0,\n         cos(a),      0, sin(a)\n    );\n    vec3 camera = vec3(0., 0, -6.) * rotY;\n    vec3 ray_direction = vec3(xy, 1.) * rotY;\n\n    float d = ray_march(camera, ray_direction);\n    \n    vec3 point = camera + ray_direction * d;\n\n    vec3 base_color = lighting(point, camera, ij);\n\n    fragColor = vec4(base_color, 1.);\n}\n","name":"Image","description":"","type":"image"}]}