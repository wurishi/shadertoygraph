{"ver":"0.1","info":{"id":"WllfzB","date":"1598207431","viewed":663,"name":"Concrete++","username":"dean_the_coder","description":"I wanted a procedural 3D texture for future projects, written in a way which can be easily shared.\nThanks to @Shane, there's no need for any texture channels to be used.\nSee getConcreteMaterial() for the texture code.  The corridor, etc is just a demo.\n\n","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","sdf","texture","material","concrete"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 'Concrete++'\n//\n// I wanted a procedural 3D concrete texture for future projects, written in a way which\n// can be easily shared.\n// See getConcreteMaterial() for the texture code.\n//\n// Thanks to @Shane, there's no need for any texture channels to be used.\n//\n// The corridor, etc is just a demo so I can see how it all looks in a 3D scene.\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST 0.0015\n\n#define AA  // Comment out this line for a speed boost.\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec2 opRep(vec2 p, vec2 c) {\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\nfloat opRep(inout float p, float size, float c1, float c2) {\n    float w2 = size * 0.5;\n    float pp = p - w2;\n    float idx = clamp(floor(pp / size), c1, c2);\n    p = pp - size * idx - w2;\n    return fract(idx * 12532.56);\n}\n\nfloat opRep(inout vec2 p, vec2 size, vec2 c1, vec2 c2) {\n    vec2 w2 = size * 0.5;\n    vec2 pp = p - w2;\n    vec2 idx = clamp(floor(pp / size), c1, c2);\n    p = pp - size * idx - w2;\n    return dot(fract(idx * 12532.56), vec2(421.0, 965.0));\n}\n\nvec4 min4(vec4 a, vec4 b) { return a.x < b.x ? a : b; }\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\n// Call to create a concrete-like 3D texture.\n//\n// p:   [in]  point in 3D space.\n// mat: [out] material rgb\n// id:  [in]  arbitary ID used as a rnd seed.\n// dist:[in]  distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns: surface noise value to apply to a SDF function.\nfloat getConcreteMaterial(vec3 p, out vec3 mat, float id, float dist) {\n    // Set rnd seed from id.\n    vec3 tp = p + vec3(0.32, 0.40, 1.2) * mod(id, 10.0);\n    \n    // Mix a couple of shades of grey.\n    float baseColor = smoothstep(0.0, 0.5, noise(tp));\n    mat = mix(vec3(0.18, 0.17, 0.17), vec3(0.20, 0.19, 0.19), baseColor);\n\n    // Surface roughness.\n    dist = 1.0 - smoothstep(0.0, 1.0, dist / 14.0);\n    float rough = noise(tp * 60.0) * 0.005 // Base\n         \t\t  + step(0.2, noise(tp * 26.666)) * 0.0033; // Pits/dents.\n    mat += rough * 24.0;\n    \n    // Fade surface roughness(/deflection) out with distance to prevent screen noise.\n    return rough * dist;\n}\n\n// A rectangular concrete 'wall panel', with a small hole in each corner.\n//\n// p: point in 3D space.\n// r: dimensions (halved)\n// id: arbitary ID used as a rnd seed.\n// dist: distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns (distance, material rgb)\nvec4 sdConcretePanel(vec3 p, vec3 r, float id, float dist) {\n    // Tilt each panel a small amount.\n    mat2 tilt = rot((fract(sin(id) * 43758.5453) - 0.5) * 0.03);\n    p.xz *= tilt;\n    p.yz *= tilt;\n    \n    float d = sdBox(p, r - 0.04) - 0.04;\n    \n    // Mounting holes.\n    vec3 pp = p;\n    pp.xy = abs(p.xy) - r.xy * 0.8;\n    float hole = sdCappedCylinder(pp + vec3(0.0, 0.0, r.z * 1.5), r.x * 0.03, r.z * 1.0);\n    d = max(d, -hole);\n    \n    // Apply material.\n    vec3 mat;\n    d -= getConcreteMaterial(p, mat, id, dist);\n    return vec4(d, mat);\n}\n\n// Concrete paving slab.\n//\n// p: point in 3D space.\n// r: dimensions (halved)\n// id: arbitary ID used as a rnd seed.\n// dist: distance from ray origin (Used to fade out surface displacement, avoiding rendering artifacts).\n// returns (distance, material rgb)\nvec4 sdSlab(vec3 p, vec3 r, float id, float dist) {\n    // Tilt each slab a small amount.\n    mat2 tilt = rot((fract(sin(id) * 43758.5453) - 0.5) * 0.05);\n    p.xz *= tilt;\n    p.yz *= tilt;\n\n    float d = sdBox(p, r - 0.04) - 0.04;\n    \n    // Apply material.\n    vec3 mat;\n    d -= getConcreteMaterial(p, mat, id, dist);\n    return vec4(d, mat);\n}\n\n// Map the scene using SDF functions.\nvec4 map(vec3 p, vec3 ro) {\n    vec3 r = vec3(1.0, 2.0, 0.05);\n    \n    vec4 d = vec4(1e10);\n    \n    float dist = distance(p, ro);\n    \n    // Left wall.\n    vec3 pp = p;\n    pp.xz *= rot(3.141 / 2.0);\n    pp.z -= 5.0;\n    float id = opRep(pp.xy, r.xy * 2.0, vec2(-15.0, -2.0), vec2(10.0, 1.0));\n    d = min4(d, sdConcretePanel(pp, r, id, dist));\n    \n    // Far wall.\n    pp = p;\n    id = opRep(pp.xy, r.xy * 2.0, vec2(-5.0, -2.0), vec2(5.0, 1.0));\n    d = min4(d, sdConcretePanel(pp - vec3(0.0, 0.0, 33.0), r, id, dist));\n    \n    // Columns.\n    pp = p - vec3(8.0, 0.0, 0.0);\n    id = opRep(pp.z, 5.0, -4.0, 3.0);\n    d = min4(d, sdSlab(pp, vec3(2.0, 8.0, 1.0), 1.0, dist));\n    \n    // Floor.\n    pp = p;\n    pp.yz *= rot(3.141 / 2.0);\n    pp.z -= 5.0;\n    r = vec3(3.0, 3.0, 0.1);\n    id = opRep(pp.xy, r.xy * 2.0, vec2(-5.0, -5.0), vec2(6.0, 6.0));\n    d = min4(d, sdSlab(pp, r, id, dist));\n    \n    // Ceiling.\n    d = min4(d, sdSlab(p - vec3(1.0, 10.0, 0.0), vec3(10.0, 3.0, 50.0), 1.0, dist));\n    \n    return d;\n}\n\nvec3 calcNormal(vec3 p, vec3 ro) {\n    vec2 e = vec2(1.0, -1.0) * 0.005773;\n    return normalize(e.xyy * map(p + e.xyy, ro).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx, ro).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy, ro).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx, ro).x);\n}\n\nfloat calcShadow(vec3 p, vec3 ro, vec3 lightPos) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float res = 1.0;\n    float t = 0.05;\n    for(float i = 0.0; i < 45.0; i++)\n    {\n        float h = map(p + rd * t, ro).x;\n        if (h < MIN_DIST * t)\n            return 0.0; // Hit an object - Full shadow.\n        \n        res = min(res, 48.0 * h / t);\n        t += h;\n        \n        if (t > 20.0)\n            break; // Marched far enough - Stop.\n    }\n    \n    return res;\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 ro, vec3 n, float h) {\n    return map(p + h * n, ro).x / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, vec3 ro, vec3 mat) {\n    vec3 sunCol = vec3(2.0, 1.6, 1.4);\n    vec3 sunPos = vec3(100.0, 50.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p);\n    vec3 n = calcNormal(p, ro);\n    float amb = dot(vec3(ao(p, ro, n, 0.2), ao(p, ro, n, 0.5), ao(p, ro, n, 2.0)), vec3(0.2, 0.3, 0.5));\n    \n    // Diffuse color.\n    float diff = max(0.0, dot(sunDir, n));\n    \n    // Primary light (Sun).\n    float sha = calcShadow(p, ro, sunPos) + 0.25;\n    vec3 lig = diff * sunCol * sha;\n\n    // Specular.\n    lig += pow(max(0.0, dot(rd, reflect(normalize(sunPos - p), n))), 15.0);\n\n    // Seconary light (Bounce light);\n    lig += max(0.0, dot(-sunDir, n)) * sunCol * 0.1 * amb;\n    \n    return mat * lig;\n}\n\nvec4 march(vec3 ro, vec3 rd, out vec3 p) {\n    float d = 0.01, prevd = 1.0;\n    vec4 details;\n    for (float steps = 0.0; steps < 64.0; steps++) {\n        p = ro + rd * d;\n        details = map(p, ro);\n        \n        if (abs(details.x) < MIN_DIST)\n            break; // We've hit a surface - Stop.\n        if (d > 35.0) return vec4(1e7, 0.0, 0.0, 0.0);\n        \n        d += details.x; // No hit, so keep marching.\n    }\n    \n    return details;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n  \tvec4 details = march(ro, rd, p);\n        \n    // Materials and lighting.\n    return applyLighting(p, rd, ro, details.yzw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera.\n    float ft = smoothstep(0.0, 1.0, fract(iTime / 9.5));\n    float phase = mod(floor(iTime / 9.5), 3.0);\n    float dim = 1.0 - pow(abs(cos(iTime * 3.141 / 9.5)), 100.0);\n    \n    vec3 ro;\n    vec3 lookAt;\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(22.0, 9.0, ft), 0.0, 8.0);\n        lookAt = vec3(6.0, 0.0, mix(5.0, 13.0, ft));\n    } else if (phase == 1.0) {\n        ro = vec3(0.0, 0.0, mix(-9.0, 4.5, ft));\n        lookAt = vec3(0.0, mix(-10.0, 0.0, ft), mix(0.0, 8.0, ft));\n    } else if (phase == 2.0) {\n        ro = vec3(-1.0, 0.0, mix(-4.0, 0.0, ft));\n        lookAt = vec3(-5.0, mix(-1.0, 1.0, ft), ro.z + mix(0.0, 5.0, ft));\n    }\n\n    vec3 col = vec3(0.0);\n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            vec3 rd = getRayDir(ro, lookAt, uv);\n            col += getSceneColor(ro, rd);\n#ifdef AA\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    col *= dim;\n    \n    // Output to screen.\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}