{"ver":"0.1","info":{"id":"WllGRf","date":"1557168147","viewed":227,"name":"Analytical Box Intersection","username":"nr4","description":"--\nDoes anyone have suggestions for optimizing this?","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["intersection","analytical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Analytical Box Intersection\n * Copyright (C) 2019  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n// Update 1: Removed if(.)s\n// Update 2: Illumination only for Box surface\n\n// Global constants\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.0, 0.0, -1.0);\nfloat a = 1.0;\n\n// 3D rotations\nvoid rot(in vec3 p, out mat3 rot)\n{\n    rot = mat3(c.xyyy, cos(p.x), sin(p.x), 0., -sin(p.x), cos(p.x))\n        *mat3(cos(p.y), 0., -sin(p.y), c.yxy, sin(p.y), 0., cos(p.y))\n        *mat3(cos(p.z), -sin(p.z), 0., sin(p.z), cos(p.z), c.yyyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    a = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy-0.5*vec2(a, 1.0);\n    vec3 size = vec3(.3,.3,.05);\n    mat3 M;\n    rot(vec3(3.1,2.3,1.5)*iTime, M);\n    \n    vec3 col = c.yyy,\n        o = 3.*M*(c.yyx-.5*sin(iTime)*c.xyy),\n        ta = M*(vec3(uv,0.)-.5*sin(iTime)*c.xyy),\n        dir = normalize(ta-o),\n        tlo = min((size-o)/dir,(-size-o)/dir); // Select 3 visible planes\n    vec2 abxlo = abs(o.yz + tlo.x*dir.yz),\n        abylo = abs(o.xz + tlo.y*dir.xz),\n        abzlo = abs(o.xy + tlo.z*dir.xy);\n    \n    vec4 dn = 100.*c.xyyy;\n    /* Slower?\n\tif(all(lessThan(abxlo, size.yz)))\n        dn = mix(dn, vec4(tlo.x,c.xyy), step(tlo.x,dn.x));\n    if(all(lessThan(abylo,size.xz)))\n        dn = mix(dn,vec4(tlo.y,c.yxy),step(tlo.y,dn.x));\n\tif(all(lessThan(abzlo,size.xy)))\n        dn = mix(dn, vec4(tlo.z,c.yyx), step(tlo.z,dn.x));\n\t*/\n    dn = mix(dn, vec4(tlo.x,c.xyy), float(all(lessThan(abxlo,size.yz)))*step(tlo.x,dn.x));\n    dn = mix(dn, vec4(tlo.y,c.yxy), float(all(lessThan(abylo,size.xz)))*step(tlo.y,dn.x));\n    dn = mix(dn, vec4(tlo.z,c.yyx), float(all(lessThan(abzlo,size.xy)))*step(tlo.z,dn.x));\n\n    float d = dn.r;\n\tif(d < 10.)\n    {\n        vec3 n = dn.gba;\n        vec3 l = normalize(c.xxx);\n\n        col = .4*c.xyy\n            + .6*vec3(.7,.4,.1)*clamp(dot(l,n),0.,1.)\n            + .6*vec3(.7,.9,.1)*clamp(dot(reflect(-l,n),dir), 0.,1.);\n        col = clamp(col, 0., 1.);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}