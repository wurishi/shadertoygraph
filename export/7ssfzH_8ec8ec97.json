{"ver":"0.1","info":{"id":"7ssfzH","date":"1644513158","viewed":68,"name":"Drone in a scene","username":"DamienE","description":"drone 2","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["drone2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FARAWAY=1e30;\nconst float EPSILON=1e-3;\n\n/* STRUCTURES */\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Cylindre{\n    vec3 center;\n    float rayon;\n    vec3 n;\n    float h;\n    //vec3 color;\n};\n\nCylindre cylindre(vec3 center, float rayon, vec3 n, float h){\n    Cylindre c;\n    c.center = center;\n    c.rayon = rayon;\n    c.n = n;\n    c.h = h;\n    return c;\n}\n\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   // DONE\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0,0,1), C.View));\n   C.Up = normalize(cross(C.View, C.Horiz));\n   \n   C.H = iResolution.y; \n   C.W = iResolution.x;\n \n   C.z = (C.H / 2.0) / tan(aperture * 3.14 / 180.0 /2.0);\n   \n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   // DONE\n   r.Origin = C.Obs;\n   r.Dir = C.Obs + C.z * C.View + ((XY.x - C.W/2.0)* C.Horiz) +  ((XY.y - C.H/2.0) * C.Up);\n   return r;\n}\n\nRay reflect_ray(in Ray I, in vec3 P, in vec3 N) {\n    return Ray(\n      P,\n      -2.0*dot(N,I.Dir)*N + I.Dir\n   );\n}\n\nRay refract_ray(in Ray I, in vec3 P, in vec3 N, in float n) {\n   return  Ray(\n     P,\n     refract(normalize(I.Dir), N, n)\n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\n\nstruct Material {\n    vec3 Kd;       // diffuse color\n    vec3 Ke;       // emissive color\n    vec3 Kr;       // reflective material\n    float checker; // checkerboard size\n    vec3 Ks;       // specular\n    float s;       // specular factor\n    vec3 Kt;       // transmission\n    float n;       // refraction index\n};\n\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\n\nMaterial diffuse(in vec3 Kd) {\n   return Material(Kd, zero3, zero3, 0.0, zero3, 0.0, zero3, 0.0);\n}\n\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n   return Material(\n     Kd, zero3, Kr, 0.0, vec3(1.0, 1.0, 1.0), 30.0, zero3, 0.0\n   );\n}\n\nMaterial light(in vec3 Ke) {\n   return Material(zero3, Ke, zero3, 0.0, zero3, 0.0, zero3, 0.0);\n}\n\nMaterial checkerboard(in vec3 Kd, in float sz) {\n   return Material(Kd, zero3, zero3, sz, zero3, 0.0, zero3, 0.0);\n}\n\n\nstruct ObjectSph {\n   Sphere sphere;\n   Material material;\n};\n\nstruct ObjectCyl {\n   Cylindre cyl;\n   Material material;\n};\n\n/* MAIN SCENE */\nObjectSph spheres[9];\nObjectCyl cylinders[4];\n\nvoid init_scene(in float beta) {\n   float s = sin(beta);\n   float c = cos(beta); \n   \n   spheres[1] = ObjectSph(\n      Sphere(vec3(0.0, 0.0, -10000.0),9999.3),\n      checkerboard(vec3(0.0, 0.0, 0.0), 0.4)\n   );\n\n   /*scene[2] = Object(\n      Sphere(vec3(0.0, 0.0, 0.0),0.7), \n     mirror(vec3(0.1, 0.1, 0.1), vec3(0.9, 0.9, 0.9))\n   );*/\n   \n   spheres[3] = ObjectSph(\n      Sphere(vec3(4.0 , -2.0 , 1),0.0), \n      light(vec3(0.9, 1.0, 1.0))\n   );\n\n   spheres[4] = ObjectSph(\n      Sphere(vec3(-5.0, 0.0, 3.0),0.0),\n      light(vec3(1.0, 1.0, 1.0)) \n   );\n   \n   spheres[5] = ObjectSph(\n      Sphere(vec3(4.0*s/2.0, 4.0*c/2.0, 0.6 * cos(2.0*c) ),0.5), \n      diffuse(vec3(1.0, 1.0, 1.0))\n   );\n   \n   spheres[6] = ObjectSph(\n      Sphere(vec3(spheres[5].sphere.Center.x, spheres[5].sphere.Center.y, spheres[5].sphere.Center.z + 0.6),0.1),\n      light(vec3(1.0*c ,0.0, 1.0 * c)) \n   );\n\n   spheres[7] = ObjectSph(\n      Sphere(vec3(spheres[5].sphere.Center.x - 0.3 *s, spheres[5].sphere.Center.y + 0.3*c,spheres[5].sphere.Center.z),0.3), \n      mirror(vec3(0.2, 0.2, 0.2), vec3(0.9, 0.9, 0.9))\n   );\n   \n   spheres[8] = ObjectSph(\n      Sphere(vec3(0,0,3),1.), \n      mirror(vec3(0.1, 0.1, 0.1), vec3(0.9, 0.9, 0.9))\n      //diffuse(vec3(1.0, 1.0, 1.0))\n   );\n   \n   \n   cylinders[0] = ObjectCyl(\n       Cylindre(vec3(5,0,0), 0.6, vec3(0,0,1), 1.5),\n       //diffuse(vec3(1.0, 1.0, 1.0))\n       //mirror(vec3(0.2, 0.2, 0.2), vec3(0.9, 0.9, 0.9))\n       light(vec3(1.0, 1.0, 1.0)) \n       //checkerboard(vec3(0.0, 0.0, 0.0), 0.02)\n   );\n   /*\n    cylinders[1] = ObjectCyl(\n       Cylindre(vec3(-5,0,0), 0.6, vec3(0,0,1), 1.5),\n       //diffuse(vec3(1.0, 1.0, 1.0))\n       //mirror(vec3(0.2, 0.2, 0.2), vec3(0.9, 0.9, 0.9))\n       light(vec3(1.0, 1.0, 1.0)) \n       //checkerboard(vec3(0.0, 0.0, 0.0), 0.02)\n   );*/\n   \n   \n   cylinders[2] = ObjectCyl(\n       Cylindre(vec3(-5,0,2), 0.5, vec3(0,1,1), 0.1),\n       diffuse(vec3(1.0, 1.0, 1.0))\n       //mirror(vec3(0.2, 0.2, 0.2), vec3(0.9, 0.9, 0.9))\n       //light(vec3(1.0, 1.0, 1.0)) \n       //checkerboard(vec3(0.0, 0.0, 0.0), 0.02)\n   );\n\n   \n}\n\n/* INTERSECTIONS */\n\nbool intersect_cylindre(in Ray R, in Cylindre cyl, out float t){\n    vec3 n = normalize(cyl.n);\n    vec3 A = R.Origin - cyl.center;\n    \n    float a = pow(length(R.Dir - dot(R.Dir, n) * n), 2.);\n    float b = 2.*dot(R.Dir - dot(R.Dir,n)*n , A - dot(A, n)*n);\n    float c = pow(length(A- dot(A, n) *n ),2.) - pow(cyl.rayon, 2.);\n    \n    \n    float Delta = b*b-4.*a*c;\n    if (Delta>0.){\n        t = (-b - sqrt(Delta))/(2.*a);\n        vec3 M = R.Origin + t * R.Dir;\n        if (t>EPSILON  && dot(M-cyl.center, n) < cyl.h){\n            return true;\n        }\n        t = (-b + sqrt(Delta))/(2.*a);\n        M = R.Origin + t * R.Dir;\n        if (t> EPSILON && dot(M-cyl.center, n) < cyl.h){\n            return true;\n        }\n    }\n    t = FARAWAY;\n    return false;\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    // DONE\n    vec3 d = R.Dir - R.Origin;\n    \n    float a = dot(d,d);\n    float b = 2.0* dot(d,(R.Origin - S.Center));\n    float c = dot((R.Origin - S.Center), (R.Origin - S.Center)) - (S.R*S.R);\n    \n    float delta = b*b - 4.0 * a *  c;\n    t = (-b-sqrt(delta)) / (2.0*a);\n    \n    if(delta < 0.0) {\n      return false;\n    }\n    return true;\n}\n\nbool intersect_sphere_2(in Ray R, in Sphere S, out float t) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b+sqrt(delta)) / (2.0*a);\n   return true;\n}\n\n/* GESTION DES OMBRES */\nbool shadow(in Ray R) {\n   /* OMBRE SPHERE*/\n   for(int i=0; i<spheres.length(); ++i) {\n        float t;\n        if(\n          spheres[i].material.Ke == vec3(0.0, 0.0, 0.0) &&\n          intersect_sphere(R, spheres[i].sphere, t) &&\n          t > EPSILON && t < 1.0\n        ) {\n          return true;\n        }\n    }\n    \n    /* OMBRE CYL*/\n    for (int i =0; i<cylinders.length(); ++i)\n    {\n        float t;\n        \n        if (intersect_cylindre(R, cylinders[i].cyl, t))\n        {\n            if (t > EPSILON && t < 1.0) \n            {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n\nvec3 lighting(\n   in vec3 P, in vec3 N, in Material material, in Ray R\n) {\n   if(material.Ke != vec3(0.0, 0.0, 0.0)) {\n      return material.Ke;\n   }  \n\n   vec3 result = vec3(0.0, 0.0, 0.0);\n\n   for(int i=0; i<spheres.length(); ++i) {\n      if(spheres[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, spheres[i].sphere.Center);\n         if(!shadow(R2)) {\n           vec3 E = spheres[i].sphere.Center - P;\n \n           // Diffuse\n           float lamb = max(0.0, dot(E,N) / length(E));\n           vec3 Kd = material.Kd;\n           if(material.checker != 0.0 && \n              sin(P.x/material.checker)*\n              sin(P.y/material.checker) > 0.0) {\n               Kd = vec3(1.0, 1.0, 1.0) - Kd;\n           }\n           result += lamb * Kd * spheres[i].material.Ke;\n\n           // Specular\n           if(material.Ks != zero3) {\n               vec3 Er = 2.0*dot(N,E)*N - E;\n               vec3 View = R.Origin - P;\n               float spec=max(dot(Er,View),0.0);\n               spec /= sqrt(dot(Er,Er)*dot(View,View));\n               spec = pow(spec, material.s);\n               result += \n                  spec * material.Ks * spheres[i].material.Ke;\n           }\n         }\n      }\n   }\n   \n   for(int i=0; i<cylinders.length(); ++i) {\n      if(cylinders[i].material.Ke != vec3(0.0, 0.0, 0.0)) {\n         Ray R2 = Ray(P, cylinders[i].cyl.center);\n         if(!shadow(R2)) {\n           vec3 E = cylinders[i].cyl.center - P;\n \n           // Diffuse\n           float lamb = max(0.0, dot(E,N) / length(E));\n           vec3 Kd = material.Kd;\n           if(material.checker != 0.0 && \n              sin(P.x/material.checker)*\n              sin(P.y/material.checker) > 0.0) {\n               Kd = vec3(1.0, 1.0, 1.0) - Kd;\n           }\n           result += lamb * Kd * cylinders[i].material.Ke;\n           // Specular\n           if(material.Ks != zero3) {\n               vec3 Er = 2.0*dot(N,E)*N - E;\n               vec3 View = R.Origin - P;\n               float spec=max(dot(Er,View),0.0);\n               spec /= sqrt(dot(Er,Er)*dot(View,View));\n               spec = pow(spec, material.s);\n               result += \n                  spec * material.Ks * cylinders[i].material.Ke;\n           }\n         }\n      }\n   }\n\n   return result;\n}\n\nbool nearest_intersection(\n   in Ray R, \n   out vec3 P, out vec3 N, out Material material\n) {\n   const float FARAWAY=1e30; \n   float t = FARAWAY;\n   \n   /* draw sphere */\n   for(int i=0; i<spheres.length(); ++i) {\n       float cur_t;\n       if(\n          intersect_sphere(R, spheres[i].sphere, cur_t) \n          && cur_t < t && cur_t > EPSILON \n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = normalize(P - spheres[i].sphere.Center);\n           material = spheres[i].material;\n       } else if( \n          intersect_sphere_2(R, spheres[i].sphere, cur_t) \n          && cur_t < t && cur_t > EPSILON       \n       ) {\n           t = cur_t;\n           P = R.Origin + t*R.Dir;\n           N = -normalize(P - spheres[i].sphere.Center);\n           material = spheres[i].material;\n           material.n = 1.0 / material.n;\n           material.Kt = vec3(1.0, 1.0, 1.0) * pow(length(R.Dir) / (4.0*t), 2.0);\n       }\n   }\n  \n   /* draw cyl*/\n   for (int i=0; i<cylinders.length(); ++i){\n       float cur_t;\n       if (intersect_cylindre(R, cylinders[i].cyl, cur_t) && cur_t < t && cur_t > EPSILON && cur_t > 0.0){\n            t = cur_t;\n            P = R.Origin + t*R.Dir;\n            N = normalize(P - cylinders[i].cyl.center);\n            material = cylinders[i].material;\n       }\n   }\n\n   return (t != FARAWAY);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float beta = float(iFrame)/30.0;\n   init_scene(beta);\n\n   Camera C = camera(\n       vec3(-8.0 * cos(iTime * 0.1), -7.0 * sin(iTime), 2.3), // my best cam move ! :D\n       //vec3(-6.0 , -2.0 , 2.3), \n       vec3(0.5, 0.5, 0.5),\n       50.0       \n   );\n   \n   Ray R = launch(C, fragCoord);\n   \n   fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n   float t = FARAWAY;\n\n   vec3 P;\n   vec3 N;\n   Material material;\n\n   vec3 Kr_cumul = vec3(1.0, 1.0, 1.0);\n   for(int k=0; k<5; ++k) {\n       if(nearest_intersection(R, P, N, material)) {\n          fragColor.rgb += Kr_cumul * lighting(P,N,material,R);\n          if(material.Kr != zero3) {\n             Kr_cumul *= material.Kr;\n             R = reflect_ray(R, P, N);\n          } else if(material.Kt != zero3) {\n             Kr_cumul *= material.Kt;\n             R = refract_ray(R, P, N, material.n);\n          } else {\n            break;\n          }\n       } else {\n          fragColor.rgb += Kr_cumul * vec3(0, 0, 0);\n          break;\n       }\n   }  \n  \n}\n","name":"Image","description":"","type":"image"}]}