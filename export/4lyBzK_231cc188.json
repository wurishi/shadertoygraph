{"ver":"0.1","info":{"id":"4lyBzK","date":"1543068571","viewed":534,"name":"House: shape over shape ","username":"TLC123","description":"House UPDATED: more fidelity  \nSorry for the messy code, Just a plaything so far.\nMore than just a lathe in my opinion.\nuse one 2d SDF to find a 2D dist of  say ( X , Y )  then use that  with remaining axis Z to look up another 2d SDF  (dist , Z) \n","likes":41,"published":1,"flags":0,"usePreview":1,"tags":["2d","sdf","shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// Fork of \"2 * 2d -> 3d  \" by TLC123. https://shadertoy.com/view/MlyfRW\n// 2018-11-21 16:26:28\n\n// Fork of \"The Walking Raymarcher\" by xorxor. https://shadertoy.com/view/Mt3XWH\n// 2018-11-11 15:37:21\n\n\n// tracer from  https://shadertoy.com/view/Mt3XWH\n// sdPentagon from https://www.shadertoy.com/view/llVyWW\n// roundrect forked fromm https://www.shadertoy.com/view/4sjyRz\n// https://iquilezles.org/articles/distfunctions2d\n// https://www.shadertoy.com/view/XdfXDB\n// http://mercury.sexy/hg_sdf/\n// sexy union functions work just as great in 2D\n\n// grass https://www.shadertoy.com/view/ls33W7\nfloat  tile=24.0;\n\nfloat hash1( vec2 n )\n{\n    return fract(sin(dot(n,vec2(1.0,113.0)))*43758.5453123);\n}\nfloat fOpPipe(float a, float b, float r) {\n    return length(vec2(a, b)) - r;\n}\nvec2 pR45(  vec2 p) {\n    p = (p + vec2(p.y, -p.x)) * sqrt(0.5);\n    return (p);\n}\nvec2 pR90(  vec2 p) {\n    p = (vec2(p.y, -p.x)) ;\n    return (p);\n}\nfloat pMod1(inout float p, float size) {\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if ((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r * sqrt(2.0) / ((n - 1.) * 2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.) / 2. * r;\n        p.x += columnradius * sqrt(2.);\n        if (mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        // At this point, we have turned 45 degrees and moved at a point on the\n        // diagonal that we want to place the columns on.\n        // Now, repeat the domain along this direction and place a circle.\n        pMod1(p.y, columnradius * 2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n    return max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n    return min(a, max(a - ra, abs(b) - rb));\n}\n\nfloat fOpEngrave(float a, float b, float r) {\n    return max(a, (a + r - abs(b)) * sqrt(0.5));\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n    float s = r / n;\n    float u = b - r;\n    return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2. * s)) - s)));\n}\n\nfloat sdBox( in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return (max(d.x, d.y));\n}\n\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n\n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n            vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),\n        vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n\n    return -sqrt(d.x) * sign(d.y);\n}\n\n\n\nfloat smin(float a, float b) {\n    const float k = .26;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n\n}\n\nfloat smax(float d1, float d2, float k) {\n\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n\n    p = abs(p) - c + r;\n    if (p.x >= 0.0 && p.y >= 0.0)\n        return length(p) - r.x;\n    else\n        return max(p.x, p.y) - r.x;\n}\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n\nfloat shape1(vec2 p ,float seed) {\n   \n    \n p=fract(p/tile)*tile;\n  p = vec2(abs(p.x)-(tile*0.5)  ,p.y-(tile*0.5+3.)  ); \n    \nif (fract(seed*7.1)<=0.5){p=pR90(p);           }\nif (fract(seed*9.1)<=0.5){p=pR90(p);           }\n   if (seed<=0.5){p=p.yx;           }\nif (fract(seed*3.1)<=0.5){p=pR90(p);           }\n\n    float d = roundrect(p - vec2(0, -3), vec2(6, 3),vec2(0.));\n\n    if (fract(seed*13.1)<=0.5){p=pR90(p);           }\n    \n      p = vec2(  (p.x)  +cos(seed*17.)*1.25 ,p.y +sin(seed*27.)*1.25); \n\n\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(0, -4.4), vec2(2.2, 3),vec2(0.)), .6, 2.);\n    //d=min(d,   sdBox(p-vec2(0,-2),vec2(2,2) ) );\n    // d=fOpUnionStairs(d, sdLine(p,vec2(0,0),vec2(0,-3))-2. ,.8,2.);\n\n    d = fOpUnionStairs(d, sdLine(p, vec2(0, 0), vec2(0, -3)) - 1.9, .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(0, 2), vec2(0, -3)), .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(1.4, 1.4), vec2(0, 0)), .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(-1.4, 1.4), vec2(0, 0)), .5, 2.);\n\n      p= vec2(abs(p.x),p.y); // mirror p\n    \n    float g = sdBox(p - vec2(0, -3), vec2(4.45, 11));\n    g = smin(g, sdBox(p - vec2(0, -3), vec2(12, 1.42)));\n    //d=min(d,fOpGroove(d,g,0.2,0.51));\n    // d=fOpGroove(d,g,0.2,0.51);\n    d = (fOpTongue(d, g, 0.2, 0.7*seed*seed));\n\n    float g1 = (sdBox(p - vec2(0, -6), vec2(1.3, 4)));\n    d = smin(d, fOpPipe(d - .6, g1, 0.4*seed));\n\n    return (d);\n}\n\n\nfloat shape2(vec2 p,float seed) {\n    \n    \n\n    float d = sdTriangle(p, vec2(0.5, 3), vec2(-4.+sin(seed*10.)*2., 5.+seed*3.), vec2(-10., 5.+seed*3.)); //roof\n    d = min(d, sdTriangle(p, vec2(0.5, 3), vec2(-10., 3), vec2(-10.,5.+seed*3.)));\n\n    d = fOpUnionColumns(d, roundrect(p - vec2(-.4, 3), vec2(1.04, .1), vec2(0.1)), .19, 2.);\n\n\n    d = min(d, roundrect(p - vec2(0, -.5), vec2(0.6, .4), vec2(0.03))); //base\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(-5, 0.4), vec2(5., 2.5), vec2(0.)), 0.3, 2.);\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(0, -1.34), vec2(2.6, .4), vec2(0.)), 0.6, 3.); //base\n\n    d = min(d, roundrect(p - vec2(0, 0.9), vec2(.06, .06), vec2(0.)));\n    d = min(d, roundrect(p - vec2(0, 1.9), vec2(.06, .06), vec2(0.)));\n    d=min(d, p.y + 0.9  );\n \n\n\n    return   d ;\n}\n\nfloat noise(vec2 p){\n    return texture(iChannel0,fract(p)).r;\n}\nvec3 grass(vec2 p){\n    \n    return vec3(mix(\n        vec3(0.12,0.71,0.),\n        vec3(0.07,0.47,0.),\n        noise(p)\n    ));\n}\n\n\nvec4 map(vec3 p) {\n    float plane = abs(p.y + 0.9);\n\nfloat r= hash1(floor(p.xz/tile))*0.5+0.5;    \nfloat g= hash1(vec2(floor(p.xz/tile)+2.));    \nfloat b= hash1(vec2(floor(p.z/tile)))*0.25;    \n\n\n\n    float w = shape1(p.xz,r);\n    float d = shape2(vec2(w, p.y),g);\n\n\n    return (p.y<-0.8 ?vec4(d,grass(  p.xz*0.04)):vec4(d, vec3(r,g,b)/ max(1.,4.*(p.y-2.2)) ));\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float mint, float maxt) {\n    float t = mint;\n    float res = 1.0;\n    for (int i = 0; i < 100; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 1.1 * h / t);\n        t += h;\n        if ((h < 0.001) || (t > maxt)) {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 trace(vec3 ro, vec3 rd) {\n    const float kTMin = 0.001;\n    const float kTMax =300.0;\n    const float kEps = 0.0001;\n\n    float t = kTMin;\n    vec4 res;\n    for (int i = 0; i < 370; i++) {\n        vec3 pos = ro + rd * t;\n        res = map(pos);\n        if ((res.x < kEps) || (t > kTMax)) {\n            break;\n        }\n        t += res.x * 0.25;\n    }\n\n    if (t < kTMax) {\n        return vec4(t, res.yzw);\n    } else {\n        return vec4(-1.0,0,0,0);\n    }\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.005, 0);\n    float dp = map(p).x;\n    return normalize(vec3(dp - map(p - e.xyy).x,\n        dp - map(p - e.yxy).x,\n        dp - map(p - e.yyx).x));\n}\n\nmat3 calcCamera(vec3 eye, vec3 target) {\n    vec3 cw = normalize(target - eye);\n    vec3 cu = cross(cw, vec3(0, 1, 0));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\nvec3 cameraPath( float t )\n    \n{\n    t=t*4.;\n    vec2 p  = vec2(400.0*sin(t/102.),400.*cos(t/103.));\n \tp  += vec2(40.0*sin(t/12.),60.*cos(t/13.));\n    float z = 18.0+1.*sin(t/02.) ;\n\n\treturn vec3( p.x,z , p.y );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\n    vec2 mo = vec2(0.95, -0.2);\n    if (iMouse.z > 0.5) {\n        mo = 10.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2(0.4, 0.1);\n    }\n    mo += 3.14159 * 0.15 * iTime;\n\n    vec3 eye = cameraPath(iTime);\n    vec3 target = cameraPath(iTime+23.+sin(iTime)*6.)-vec3(0,30,0);\n\n    mat3 cam = calcCamera(eye, target);\n\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(uv, 2.0));\n\n    vec3 col = vec3(0.60);\n\n    vec4 res = trace(eye, rd);\n    if (res.x > 0.0) {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal(pos);\n        vec3 ldir = normalize(vec3(-10.5, 20.8, 24.0));\n\n        if (res.y < 1.5) {\n                        col = col* 0.4 + 0.6 * (vec3(1) - nor.zxy);\n            col = col*0.2 + 0.8 * (vec3(res.yzw) );\n\n            float dif = abs(dot(nor, ldir));\n            vec3 ref = reflect(rd, nor);\n            float spe = pow(clamp(dot(ref, ldir), 0.0, 1.0), 2.0);\n\n            col *= (0.2 + 0.8 * dif);\n            float edge = pow(1.0 - dot(-rd, nor), 1.011);\n            col += 0.1 * edge + spe;\n        }\n\n        float sh = calcShadow(pos, ldir, 0.1, 30.0);\n        col *= (0.5 + sh);\n    }\n\n\n \n    if (fract((iTime + 1.) / 10.) < 0.165) {\n        // col=vec3( shape1(uv*20.-vec2(0,4))>0. )\n\n        float len = shape1(eye.xz+uv * 50. - vec2(0, 4), hash1(floor((eye.xz+uv * 50. - vec2(0, 4))/tile))) / 10.;\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n        fragColor = vec4(col * col, 1.0);\n    }\n    if (fract((iTime + 1.) / 10.) < 0.08) {\n        // col=vec3( shape2(uv*20.-vec2(0,-8))>0. );\n\n        float len = shape2(uv * 20. - vec2(0, -2), hash1(floor((uv * 20. - vec2(0, -2))/tile))) / 10.;\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n        if (abs(uv.x) < 0.005) col = vec3(1.);\n\n        fragColor = vec4(col * col, 1.0);\n    }\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}