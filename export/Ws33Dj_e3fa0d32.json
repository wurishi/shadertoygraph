{"ver":"0.1","info":{"id":"Ws33Dj","date":"1569526593","viewed":72,"name":"overTheHills","username":"melkor","description":"Raymarched mountainous terrain","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarchterrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CLIPPING_DIST 0.001\n#define PI 3.14159265359\n\n//https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat hash3(vec2 co){\n    return fract(sin(dot(co,vec2(12.9898,78.233))) * 43758.5453);\n}\n//https://iquilezles.org/articles/voronoise\nfloat noise( vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0 + 63.0*pow(1.0-v,4.0);\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec3  o = vec3(hash3( p + g ))*vec3(u,u,1.0);\n        vec2  r = g - f + o.xy;\n        float d = dot(r,r);\n        float w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += w*o.z;\n        wt += w;\n    }\n\n    return va/wt;\n}\n\nfloat terrain(float x, float y, bool s) {\n    float level = 0.5*sin(x) + sin(y);\n    level += noise(vec2(x,y), 1.0, 1.0);\n    if (!s) {\n    \tlevel += 0.1*noise(vec2(10.0*x,10.0*y),1.0,1.0);\n    }\n    \n    float waterLevel = -0.5;\n    \n    return max(level, waterLevel);\n}\n\nfloat getDist(vec3 p) {\n\tvec4 sphere = vec4(0.0, 0.5, 6.0, 1.0);\n    float sphereDist = length(p-sphere.xyz) - sphere.w;\n    float terrainDist = p.y - terrain(p.x, p.z, false);\n    \n    return min(sphereDist, terrainDist);\n}\n\nvec3 getNormal(vec3 p) {\n    vec3 n;\n    \n    //sphere\n    vec4 sphere = vec4(0.0, 0.5, 6.0, 1.0);\n    vec3 radius = p-sphere.xyz;\n    if (abs(length(radius)-sphere.w) < CLIPPING_DIST) {\n    \tn = radius;\n    }\n    else {\n    \t//Terrain\n        float d = 0.001;\n        n = vec3( terrain(p.x-d,p.z, false) - terrain(p.x+d,p.z, false),\n                            2.0f*d,\n                            terrain(p.x,p.z-d, false) - terrain(p.x,p.z+d,false));\n    }\n    \n    return normalize(n);\n}\n\nfloat getLighting(vec3 p, vec3 n) {\n\tvec3 light = vec3(3.0, 10.0, 5.0);\n    vec3 ray = p-light;\n    return (1.0 - dot(ray, n))/pow(length(ray), 2.0);\n}\n\nvec3 getColour(vec3 p, vec3 n) {\n    float reflectivity;\n    vec3 surfaceColour;\n    vec3 lightColour = vec3(1.0, 0.2, 0.2);\n    vec3 ambientColour = vec3(0.1, 0.1, 1.0);\n    float brightness = 50.0;\n    \n    //sphere\n    vec4 sphere = vec4(0.0, 0.5, 6.0, 1.0);\n    if (abs(length(p-sphere.xyz)-sphere.w) < CLIPPING_DIST) {\n        //metal\n    \treflectivity = 0.9;\n        surfaceColour = vec3(0.8, 1.0, 0.8);\n    }\n    else {\n        if (abs(p.y + 0.5) < CLIPPING_DIST) {\n            //water\n            return 0.5*mix(vec3(0.5, 0.5, 1.0), vec3(0.2, 0.1, 0.1), getLighting(p, n));\n        }\n        else if(p.y > 1.2+0.5*noise(10.0*p.xz, 1.0, 1.0)) {\n        \t//ice\n            reflectivity = 0.9;\n        \tsurfaceColour = vec3(0.9, 0.9, 1.0);\n        }\n        else {\n        \treflectivity = 0.2;\n            surfaceColour = vec3(0.2, 0.1, 0.1);\n        \t//colour = vec3(1.0, 0.4, 0.0);\n        }\n    }\n    \n    float light = reflectivity*getLighting(p, n);\n    float ambientIntensity = 0.1+reflectivity/100.0; //ambient blue light from sky\n    \n    return (brightness * light * lightColour * surfaceColour) + (ambientIntensity * ambientColour);\n}\n\nfloat castRay(vec3 origin, vec3 direction) {\n    float visibilityDist = 100.0;\n    float stepDist;\n    float travelled = CLIPPING_DIST;\n    int maxSteps = 100;\n    vec3 loc = origin + direction * CLIPPING_DIST;\n    \n    for (int i = 0; i < maxSteps; i++) {\n    \tstepDist = getDist(loc);\n        if (stepDist < CLIPPING_DIST || travelled > visibilityDist) {\n            break;\n        }\n        travelled += stepDist;\n        loc += direction * stepDist;\n    }\n    return travelled;\n}\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    vec2 r = 2.0 * (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    //move camera in circle\n    float angle = 0.2*iTime;\n    vec2 loc = vec2(10.0*cos(angle), 10.0*sin(angle)+6.0);\n    vec3 cameraPos = vec3(loc.x, terrain(loc.x, loc.y, true) + 2.0, loc.y);\n    vec3 lookAt = vec3(r.xy, 1.0);\n    mat3 rotation = mat3(cos(angle + PI/2.0),0.0,sin(angle + PI/2.0),\n                         0.0, 1.0, 0.0,\n                         -sin(angle + PI/2.0), 0.0, cos(angle + PI/2.0));\n    lookAt = normalize(rotation*lookAt);\n    \n    \n    vec3 skyColour = vec3(0.0, 0.1, 0.2);\n    vec3 terrainColour = vec3(0.6, 0.4, 0.2);\n    \n    float dist = castRay(cameraPos, lookAt);\n    vec3 p = cameraPos + dist*lookAt;\n    vec3 n = getNormal(p);\n    n.z = -n.z;\n    vec3 colour = getColour(p, n);\n    \n    //antialias horizon\n    colour = mix(colour, skyColour, smoothstep(5.0, 100.0, dist));\n    \n    fragColour = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}