{"ver":"0.1","info":{"id":"McGcRy","date":"1732015729","viewed":75,"name":"Environment BRDF comparison","username":"pinko","description":"This compares 3 IBL BRDF approximations with the UE4 precalc version\n\nFrom left to right\n UE4 Base \n UE4 Mobile\n Knarkowicz Analytical DFG Term for IBL\n Angelo Pesce Approximation of Split Integral for GGX Environment Lighting\n\nPress Mouse to show error","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["brdf","ibl","splitintegral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis compares 3 IBL BRDF approximations with the UE4 precalc version\n\nFrom left to right\n UE4 Base \n UE4 Mobile\n Knarkowicz Analytical DFG Term for IBL\n Angelo Pesce Approximation of Split Integral for GGX Environment Lighting\n\nPress Mouse to show error compared to UE4 Base\n*/\n\n// below ImportanceSampleGGX etc copied from @reindernijhoff Old watch (IBL) https://www.shadertoy.com/view/lscBW4\n// In this buffer I pre-calculate the BRDF integration map, as described in:\n// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\n\nconst float PI = 3.14159265359;\n\n// see: http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\nfloat PartialGeometryGGX(float NdotV, float a) {\n    float k = a / 2.0;\n\n    float nominator   = NdotV;\n    float denominator = NdotV * (1.0 - k) + k;\n\n    return nominator / denominator;\n}\n\nfloat GeometryGGX_Smith(float NdotV, float NdotL, float roughness) {\n    float a = roughness*roughness;\n    float G1 = PartialGeometryGGX(NdotV, a);\n    float G2 = PartialGeometryGGX(NdotL, a);\n    return G1 * G2;\n}\n\nfloat RadicalInverse_VdC(uint bits) {\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 Hammersley(int i, int N) {\n    return vec2(float(i)/float(N), RadicalInverse_VdC(uint(i)));\n} \n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness) {\n    float a = roughness*roughness;\n    float phi      = 2.0 * PI * Xi.x;\n    float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n    vec3 HTangent;\n    HTangent.x = sinTheta*cos(phi);\n    HTangent.y = sinTheta*sin(phi);\n    HTangent.z = cosTheta;\n\n    return HTangent;\n}\n\nvec2 IntegrateBRDF(float roughness, float NdotV) {\n    vec3 V;\n    V.x = sqrt(1.0 - NdotV*NdotV);\n    V.y = 0.0;\n    V.z = NdotV;\n\n    float A = 0.0;\n    float B = 0.0;\n\n    const int SAMPLE_COUNT = 128;\n\n    vec3 N = vec3(0.0, 0.0, 1.0);\n    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 TangentX = normalize(cross(UpVector, N));\n    vec3 TangentY = cross(N, TangentX);\n\n    for(int i = 0; i < SAMPLE_COUNT; ++i)  {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 HTangent = ImportanceSampleGGX(Xi, roughness);\n        \n        vec3 H = normalize(HTangent.x * TangentX + HTangent.y * TangentY + HTangent.z * N);\n        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n        float NdotL = max(L.z, 0.0);\n        float NdotH = max(H.z, 0.0);\n        float VdotH = max(dot(V, H), 0.0);\n\n        if(NdotL > 0.0) {\n            float G = GeometryGGX_Smith(NdotV, NdotL, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1.0 - VdotH, 5.0);\n\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\n\n//https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile\nvec2 EnvBRDFApprox( float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn AB;\n}\n\n//By Angelo Pesce\n//https://c0de517e.blogspot.com/2016/07/siggraph-2015-notes-for-approximate.html\n//https://www.dropbox.com/s/mx0ub7t3j0b46bo/sig2015_approx_models_PBR_notes_DRAFT.pdf?dl=0\nvec2 PesceApprox( float roughness, float NoV )\n{\n    float roughness2=roughness*roughness;\n    float bias=exp2(-(7.0*NoV+4.0*roughness2));\n    float scale=1.0-bias-roughness2*max(bias,min(roughness,0.739+0.323*NoV)-0.434);\n    return vec2(scale,bias);\n}\n\n//https://knarkowicz.wordpress.com/2014/12/27/analytical-dfg-term-for-ibl/\n//slightly modified to work with roughness \nvec2 EnvDFGPolynomial( float roughness, float ndotv )\n{\n    float x =1.0- roughness;\n    x*=x;\n    float y = ndotv;\n\n    float b1 = -0.1688;\n    float b2 = 1.895;\n    float b3 = 0.9903;\n    float b4 = -4.853;\n    float b5 = 8.404;\n    float b6 = -5.069;\n    float bias = clamp( min( b1 * x + b2 * x * x, b3 + b4 * y + b5 * y * y + b6 * y * y * y ) ,0.0,1.0);\n\n    float d0 = 0.6045;\n    float d1 = 1.699;\n    float d2 = -0.5228;\n    float d3 = -3.603;\n    float d4 = 1.404;\n    float d5 = 0.1939;\n    float d6 = 2.661;\n    float delta = clamp( d0 + d1 * x + d2 * y + d3 * x * x + d4 * x * y + d5 * y * y + d6 * x * x * x ,0.0,1.0);\n    float scale = delta - bias;\n    return vec2(scale,bias);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale=2.29;\n    vec2 uv = fragCoord/iResolution.xy*scale;\n    uv.y-=(scale-1.0)/2.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float split=1.02;\n    \n    float u[4];\n    for(int i=0;i<4;i++)\n        u[i]=uv.x-split*float(i);\n\n    float showError=0.0;\n    if(iMouse.z>0.0)showError=1.0;\n\n    vec2 BRDF1=IntegrateBRDF (u[0],uv.y)*(1.0-showError);\n    vec2 BRDF2=abs(EnvBRDFApprox (u[1],uv.y)-IntegrateBRDF (u[1],uv.y)*showError);\n    vec2 BRDF3=abs(EnvDFGPolynomial(u[2],uv.y)-IntegrateBRDF (u[2],uv.y)*showError);\n    vec2 BRDF4=abs(PesceApprox(u[3],uv.y)-IntegrateBRDF (u[3],uv.y)*showError);\n\n    float show[4];\n    for(int i=0;i<4;i++)\n        if(u[i]>=0.0 && u[i]<=1.0)\n            show[i]=1.0;\n\n    vec2 rg=BRDF1*show[0]+BRDF2*show[1]+BRDF3*show[2]+BRDF4*show[3];\n    if(uv.y<0.0 || uv.y>1.0)rg*=0.0;\n\n    fragColor = vec4(rg,0.0,1.0);\n}","name":"Image","description":"","type":"image"}]}