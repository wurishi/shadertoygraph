{"ver":"0.1","info":{"id":"4XlcWB","date":"1726613493","viewed":5,"name":"Newton fractal visualiser","username":"orange389","description":"Newton fractal of f(z) = z ^ 3 - 1. Done for fun after watching 3b1b video on the subject. Note : can't zoom too much in or out because of floating point precision error.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal","newton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function used : f(z) = z^3 - 1, state allows zoom.\n// Note : y is imaginary part of x in pos\nvec2 func(in vec2 pos, in float state)\n{\n    float real = pos.x * pos.x * pos.x - 3.0 * pos.x * pos.y * pos.y - state;\n    float imag = 3.0 * pos.x * pos.x * pos.y - pos.y * pos.y * pos.y;\n    return vec2(real, imag);\n}\n\n// Derivative : f'(z) = 3 * z ^ 2\nvec2 deriv(in vec2 pos)\n{\n    float real = pos.x * pos.x - pos.y * pos.y;\n    float imag = 2.0 * pos.x * pos.y;\n    return 3.0 * vec2(real, imag);\n}\n\n// Gives next iteration to approx. root of f(x) using Newton's formula (z - f(z)/f'(z))\nvoid next(inout vec2 pos, in float time)\n{\n    vec2 f = func(pos, time);\n    vec2 d = deriv(pos);\n    vec2 comp = vec2(d.x, -d.y);\n    float real = f.x * comp.x - f.y * comp.y;\n    float imag = f.x * comp.y + f.y * comp.x;\n    pos -= vec2(real, imag) / (d.x * d.x + d.y * d.y);\n}\n\n// Gives color depending on which root the algorithm approaches for f(z)\nvec4 getColor(in vec2 pos, in float state)\n{\n    float cube_root_state = pow(state, 0.3333);\n    vec2 a = pos - cube_root_state * vec2(1.0, 0);\n    vec2 b = pos - cube_root_state * vec2(-0.5, 0.866025);\n    vec2 c = pos - cube_root_state * vec2(-0.5, -0.866025);\n    if (a.x * a.x + a.y * a.y < cube_root_state * 0.5)\n    {\n        return vec4(0.9, 0.4, 0.4, 1.0);\n    }\n    if (b.x * b.x + b.y * b.y < cube_root_state * 0.5)\n    {\n        return vec4(0.4, 0.9, 0.4, 1.0);\n    }\n    if (c.x * c.x + c.y * c.y < cube_root_state * 0.5)\n    {\n        return vec4(0.4, 0.4, 0.9, 1.0);\n    }\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates \n    vec2 uv = (fragCoord/iResolution.xy * 2.0 - 1.0) * iResolution.xy / iResolution.xx;\n    \n    float time = -3.0 * sin(iTime / 4.0) + 3.0;\n    \n    float state = pow(0.1, time / 4.0);\n    uv.x -= time / 4.0;\n    \n    for (int i = 0; i < 100; ++i)\n    {\n    next(uv, state);\n    }\n    \n    fragColor = getColor(uv, state);\n}","name":"Image","description":"","type":"image"}]}