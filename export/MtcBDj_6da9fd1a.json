{"ver":"0.1","info":{"id":"MtcBDj","date":"1541478062","viewed":271,"name":"complex idea create new destiny","username":"benhardy","description":"getting real freaky on doing fun things where objects intersect WORK IN PROGRESS\n\nman i gotta figure out how to do iq's surface pattern integration stuff to get rid of that aliasing but you get the idea\n\nsee also https://www.shadertoy.com/view/MtcBzX","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","csg","infinity","factory"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// prototypes for functions used further down\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax );\nvec3 calc_surface_normal(vec3 hit);\n\n/**\n * Ray marching parameters for this scene\n */\nconst int   MAX_STEPS  = 10000;\n\nconst float MAX_DIST   =  80.0;\nconst float EPSILON    =   0.001;\nconst float STEP_RATIO =   0.5;\n\n// object ids\nconst int ID_FLOOR     = 2;\nconst int ID_FRACTAL   = 3;\nconst int ID_TOP_PIPE  = 4;\nconst int ID_TOP_STRAP = 5;\nconst int ID_KNOB      = 6;\nconst int ID_CAGE      = 10;\nconst int ID_COLUMN    = 11;\n\n// \"cage\" transformation for boxes\nfloat cage(vec3 where, float box, float thickness, float spacing) {\n    float yp = cmod(where.y, spacing);\n    float off_y = length(vec2(yp, box)) - thickness;\n    float xp = cmod(where.x, spacing);\n    float off_x = length(vec2(xp, box)) - thickness;\n    float zp = cmod(where.z, spacing);\n    float off_z = length(vec2(zp, box)) - thickness;\n    return union(off_x, union(off_y, off_z));\n}    \n\n/**\n * Measure the distance between the given point\n * and the closest object in the scene.\n * Returns a vector containing:\n *.   x: the distance to the closest object\n *.   y: the id of the closest object, as a float\n */\nvec2 measure(vec3 global_where) {\n    float closest = 100000.0;\n    int who = 0;\n    \n    global_where.z = abs(global_where.z) -6.0;\n    // measure distance to floor\n    float dist_floor = global_where.y + 1.0;\n\tvec3 where = global_where;\n    \n\tfloat dist_fractal = round_box(where, vec3(1000,1,1),0.2);\n    \n    vec3 hole_pos = vec3(cmod(where.x, 0.4), abs(where.y) - 0.5, where.z);\n    float dist_hole = round_box(hole_pos, vec3(0.1,0.1,2.0),0.025);\n    dist_fractal = difference(dist_fractal, dist_hole);\n    \n    // top notch\n    vec3 hole_pos2 = vec3(cmod(where.x-2.0, 4.0), where.y - 1.0, where.z + 1.2);\n    float dist_hole2 = round_box(hole_pos2, vec3(0.5,0.23,1.0),0.025);\n    float diff = difference(dist_fractal, dist_hole2);\n    float ridge0 = length(vec2(dist_fractal, dist_hole2)) -0.02;\n    float ridge1 = length(vec2(dist_fractal, dist_hole2-0.04)) -0.02;\n    dist_fractal = union(diff, union(ridge0,ridge1)); // slap on\n    \n    vec3 cage_pos = hole_pos2 + vec3(0,-1.1,-0.5);\n    float cage_box = union(\n        round_box(cage_pos, vec3(0.380,1.40,0.450),0.05),\n        round_box(cage_pos+vec3(0.1,0.62,-0.6), vec3(0.275,0.22,0.8),0.05)\n\t);        \n    float dist_cage = cage(cage_pos, cage_box, 0.005, 0.15);\n    \n    float dist_column = cylinder_capped(cage_pos, vec3(0,-1.8,0), vec3(0,1.2,0), 0.4);\n    \n    // top ridge between notches\n    vec3 ridge_pos = vec3(cmod(where.x, 4.0), where.y - 1.0, where.z + 1.2);\n    float dist_ridge_edge = round_box(ridge_pos, vec3(1.1,0.23,1.0),0.025);\n    float ridge2 = length(vec2(dist_fractal, dist_ridge_edge)) -0.02;\n    float ridge3 = length(vec2(dist_fractal, dist_ridge_edge-0.04)) -0.02;\n    dist_fractal = union(dist_fractal, union(ridge2,ridge3)); // slap on\n    /*\n    vec3 top_notch_pos = vec3(where.x, where.y-1.1, where.z+1.0);\n\tfloat dist_top_notch = round_box(top_notch_pos, vec3(0.5,1.2,1.5),0.0);\n    dist_fractal = max(dist_fractal, -dist_top_notch);\n*/\n    vec3 knob_pos = vec3(cmod(where.x, 0.8), where.y, where.z);\n    float dist_knob = difference(\n        round_box(knob_pos, vec3(0.3,0.3,1.3),0.05),\n        round_box(knob_pos +vec3(0,-0.4,1.35), vec3(0.2,0.6,0.1),0.005)\n    );\n    \n    float dist_top_pipe = cylinder_x(where, vec3(0,1.2,0.3), 0.25);\n    \n    vec3 top_strap_pos = vec3(cmod(where.x, 4.0), where.y, where.z-0.3);\n    float dist_top_strap = cylinder_x_finite(top_strap_pos, vec3(0,1.2,0), 0.27, 0.1);\n\n    if (dist_floor < closest) {\n\t    who = ID_FLOOR;\n        closest = dist_floor;\n    }\n    if (dist_fractal < closest) {\n        who = ID_FRACTAL;\n        closest = dist_fractal;\n    }\n    if (dist_knob < closest) {\n        who = ID_KNOB;\n        closest = dist_knob;\n    }\n    if (dist_top_pipe < closest) {\n        who = ID_TOP_PIPE;\n        closest = dist_top_pipe;\n    }\n    if (dist_top_strap < closest) {\n        who = ID_TOP_STRAP;\n        closest = dist_top_strap;\n    }\n    if (dist_cage < closest) {\n        who = ID_CAGE;\n        closest = dist_cage;\n    }\n    if (dist_column < closest) {\n        who = ID_COLUMN;\n        closest = dist_column;\n    }\n\n    return vec2(closest, who);\n}\n\nconst vec3 floor_color     = vec3(0.31, 0.58, 0.37);\nconst vec3 fractal_color   = vec3(0.90, 0.80, 0.70);\nconst vec3 top_pipe_color  = vec3(0.30, 0.28, 0.27);\nconst vec3 top_strap_color = vec3(0.90, 0.90, 0.90);\nconst vec3 knob_color      = vec3(0.70, 0.70, 0.70);\nconst vec3 cage_color      = vec3(0.70, 0.70, 0.70);\nconst vec3 column_color    = vec3(0.00, 0.90, 0.00);\n\n/**\n * Figure out coloring for where we hit\n */\nvec3 paint(vec2 hit, vec3 where) {\n\n    int who = int(hit.y);\n    \n    if (who == ID_FLOOR) {\n        vec2 w = fract(where.xz);\n        float target = fract(length(where.xz));\n        vec3 tile = vec3(target*0.7,target*0.8,target*0.9);\n        return min(w.x, w.y) > 0.05 ? tile : WHITE;\n    }\n    if (who == ID_FRACTAL) {\n        return fractal_color;\n    }\n    if (who == ID_TOP_PIPE) {\n        return top_pipe_color;\n    }\n    if (who == ID_TOP_STRAP) {\n        return top_strap_color;\n    }\n    if (who == ID_KNOB) {\n        return knob_color;\n    }\n    if (who == ID_COLUMN) {\n        return column_color;\n    }    \n    if (who == ID_CAGE) {\n        return cage_color;\n    }\n    return BLACK;\n}\n\n/**\n * main entrypoint\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(sin(iTime*0.13)*27.0,\n                    1.2 +1.0*sin(iTime*0.39),\n                    cos(iTime*0.13)*3.0);\n    vec3 look_at = vec3(12,0,10);\n    vec3 up = Y;\n    vec3 ray = calculateRay(iResolution, fragCoord, eye, look_at, up);\n    \n    vec3 where = eye;\n    float total_dist = 0.0;\n    vec2 current;\n    int who = 0;\n    for(int steps =0;steps < MAX_STEPS; steps++) {\n        current = measure(where);\n        float current_dist = current.x;\n        if (current_dist < EPSILON) {\n            who = int(current.y);\n            break;\n        }\n        total_dist += current_dist * STEP_RATIO;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n        where = eye + total_dist * ray;\n    }\n\n    vec3 fog_color = vec3(0,0,0);\n    if (who == 0){\n        fragColor = vec4(fog_color, 1.0);\n        return;\n    }\n\tvec3 hit = where;\n    vec3 diffuse = paint(current, where);\n    vec3 to_light = normalize(vec3(-10,5,-4));\n    float shadow = calcSoftshadow(hit, to_light, 0.0, total_dist);\n    vec3 surface_normal = calc_surface_normal(hit);\n    float dotty = dot(to_light, surface_normal);\n    float light_amount = max(0.0, dotty);\n    float light_fade = 1.0 - pow(total_dist / MAX_DIST, 2.0);\n    float ambient = 0.3;\n    float lighting = ambient + (1.0-ambient) * \n        (shadow*0.5 * (1.0 + light_amount * light_fade));\n\n\tvec3 coloring = light_fade *(diffuse * lighting)\n        + fog_color * (1.0-light_fade);\n    vec3 reflected = surface_normal * 2.0 * dotty - to_light;\n    vec3 toEye = normalize(-ray);\n\tfloat specular = pow(max(0.0, dot(toEye, reflected)), 32.0);\n\tcoloring += vec3(specular, specular, specular);\n    fragColor = vec4(coloring,1.0);\n}\n\nvec3 calc_surface_normal(vec3 hit) {\n\treturn normalize(vec3(\n            measure(hit+vec3(NORMAL_DELTA, 0.0, 0.0)).x - measure(hit-vec3(NORMAL_DELTA, 0.0, 0.0)).x,\n            measure(hit+vec3(0.0, NORMAL_DELTA, 0.0)).x - measure(hit-vec3(0.0, NORMAL_DELTA, 0.0)).x,\n            measure(hit+vec3(0.0, 0.0, NORMAL_DELTA)).x - measure(hit-vec3(0.0, 0.0, NORMAL_DELTA)).x\n    ));\n}\n\n// iq's soft shadow algo\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = measure( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define NORMAL_DELTA 0.001\n#define MAX_FLOAT 3.402823466e+38\n#define MIN_FLOAT 1.175494351e-38\n#define MAX_DOUBLE 1.7976931348623158e+308\n#define MIN_DOUBLE 2.2250738585072014e-308\n\n// Indicate to 'repeat' function that we don't wish to\n#define NEVER 1000000.0\n\n// CSG macros\n#define union(x,y) min((x),(y))\n#define intersection(x,y) max((x),(y))\n#define difference(x,y) max((x),-(y))\n\n/**\n * Common vectors\n */\nconst vec3 ORIGIN = vec3(0,0,0);\nconst vec3 X = vec3(1,0,0);\nconst vec3 Y = vec3(0,1,0);\nconst vec3 Z = vec3(0,0,1);\n\n/**\n * Common color values\n */\nconst vec3 BLACK = vec3(0,0,0);\nconst vec3 WHITE = vec3(1,1,1);\nconst vec3 RED   = vec3(1,0,0);\nconst vec3 GREEN = vec3(0,1,0);\nconst vec3 BLUE  = vec3(0,0,1);\nconst vec3 YELLOW  = vec3(1,1,0);\nconst vec3 CYAN    = vec3(0,1,1);\nconst vec3 MAGENTA = vec3(1,0,1);\n\n/**\n * For the given 2d screen position, figure out the ray vector\n */\nvec3 calculateRay(vec3 res, vec2 screenPos, \n                  vec3 eye, vec3 look_at, vec3 up) {\n\tvec2 screen_pos = screenPos.xy / res.xy;\n    float aspect = res.y / res.x;\n    screen_pos -= 0.5;\n    screen_pos.y *= aspect;\n    vec3 look_center = normalize(look_at - eye);\n    vec3 look_right = cross(up, look_center);\n    vec3 look_up = cross(look_center, look_right);\n        \n\tvec3 newRay = normalize(look_center + screen_pos.x * look_right + screen_pos.y * look_up);\n    return newRay;\n}\n\n\n\n/*\n * Signed distance functions for object primitives\n */\nfloat sphere(vec3 where, vec3 center, float radius) {\n  return length(where - center) - radius;\n}\n\n//float torus_around_x(vec3 where, float major, float minor) {\n    \n\nfloat round_box( vec3 where, vec3 sizes, float roundness ) {\n\treturn length(max(abs(where)-sizes,0.0))-roundness;\n}\n\nvec3 repeat(vec3 where, vec3 repetition) {\n\n    return mod(where, repetition);\n}\nvec3 repeat_x(vec3 where, float r) {\n\n    where.x = mod(where.x, r);\n    return where;\n}\n\n\n#define PI 3.141592653589793\nvec3 radial_symmetry_xz(vec3 where, float count) {\n    float ang = mod(atan(where.x, where.z) + PI, 2.0 *PI /count);\n    float r = length(where.xz);\n    return vec3(r *cos(ang), where.y, r * sin(ang));\n}\n\n// polynomial smooth min (k = 0.1);\nfloat blend( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 );\n    return min( a, b ) - h*h*0.25/k;\n}\n\n#define CYLINDER_STYLE_CAPPED 1\n#define CYLINDER_STYLE_PILL 2\n#define CYLINDER_STYLE_INFINITE 0\n\nfloat cylinder_infinite(vec3 point, vec3 start, vec3 end, float radius) {\n\tvec3 dp = point - start;\n\tvec3 de = end - start;\n\tfloat len = length(de);\n\tfloat k = dot(dp, de) / len;\n\tfloat frac = k / len;\n\tvec3 closest = de * frac;\n\tvec3 pc = dp - closest;\n\tfloat rad = length(pc);\n        \n\treturn rad - radius;\n}\nfloat cylinder_capped(vec3 point, vec3 start, vec3 end, float radius) {\n\tvec3 dp = point - start;\n\tvec3 de = end - start;\n\tfloat len = length(de);\n\tfloat k = dot(dp, de) / len;\n\tfloat frac = k / len;\n\tvec3 closest = de * frac;\n\tvec3 pc = dp - closest;\n\tfloat rad = length(pc);\n        \n    k = max(-k, max(k-len, 0.0));\n    rad = max(rad-radius, 0.0);\n    return length(vec2(rad,k));\n}\nfloat cylinder_pill(vec3 point, vec3 start, vec3 end, float radius) {\n\tvec3 dp = point - start;\n\tvec3 de = end - start;\n\tfloat len = length(de);\n\tfloat k = dot(dp, de) / len;\n\tfloat frac = k / len;\n\tvec3 closest = de * frac;\n\tvec3 pc = dp - closest;\n\tfloat rad = length(pc);\n        \n    k = max(-k, max(k-len, 0.0));\n    return length(vec2(rad,k)) - radius;\n}\n\nfloat cylinder_z(vec3 where, vec3 center, float radius) {\n    return length((where - center).xy) -radius;\n}\n\nfloat cylinder_z_finite(vec3 where, vec3 center, float radius, float zstart, float zend) {\n    float c = length((where - center).xy) -radius;\n    return max(c, max(zstart - where.z, where.z - zend));\n}\n\nfloat cylinder_x_finite(vec3 where, vec3 center, float radius, float halfLength) {\n    vec3 p = abs(where - center);\n    float r = length(p.yz);\n    return length(vec2(max(0.0, r-radius), max(0.0, p.x-halfLength)));\n}\n\nfloat cylinder_x(vec3 where, vec3 center, float radius) {\n    return length((where - center).yz) -radius;\n}\nfloat cylinder_y(vec3 where, vec3 center, float radius) {\n    return length((where - center).xz) -radius;\n}\nfloat torus_x(vec3 where, float major, float minor) {\n    float r = length(where.yz);\n    return length(vec2(r-major, where.x)) - minor;\n}\n\nfloat cmod(float x, float d) {\n    return mod(x + d/2.0, d) - d/2.0;\n}\n\nfloat square_torus_z(vec3 where, \n                     float half_height, float half_length, float major, float minor)\n{\n    where = abs(where);\n    where.yz = max(where.yz - vec2(half_height, half_length), 0.0);\n    float r = length(where.yz) - major;\n    return length(vec2(r,where.x))- minor;\n}\n\nint hash(int x) {\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = ((x >> 16) ^ x) * 0x45d9f3b;\n    x = (x >> 16) ^ x;\n    return x;\n}\n","name":"Common","description":"","type":"common"}]}