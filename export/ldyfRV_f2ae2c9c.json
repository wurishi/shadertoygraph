{"ver":"0.1","info":{"id":"ldyfRV","date":"1530195584","viewed":1021,"name":"Colors of noise","username":"nimitz","description":"Removing frequencies from a 2D hash (white noise) using fft and it's inverse to obtain different noise types (blue, pink, brown, violet, etc).\nDrag mouse on shader to control filter width and position.","likes":22,"published":1,"flags":32,"usePreview":0,"tags":["noise","fft","fourier","bluenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Colors of noise by nimitz (2018) (twitter: @stormoid)\n\n/*\n\tInput: Hash function (based on xxHash32)\n\tLeft side: Fourier space with phase in the blue component\n\tRight side: Resulting noise\n\n\tDrag the mouse on the left side to specify an low pass filter and on the right side to specify\n\ta high pass filter. You can test with a ring filter or animated noise by phase rotation\n\twith the defines in the \"Common\" tab.\n\n\tHigh pass filtered blue noise is better suited to dithering applicationg than white noise.\n\tOn the other hand, low pass filtered noise is better suited for fractional noise generation or\n\tapplications where smooth noise is required.\n\n\tMany more functions can be applied to the fourier space (Buf B) to create anisotropic noise or\n\teven fbm-like noise using multiple primitives to shape the frequency domain. An define for an \n\tFBM example is in the \"common\" tab.\n\n\tI am also getting the noise maximum and minimum values in Buffer D to renormalize the output\n\tto 0..1 range.\n\n\n\tThanks to flyguy and FabriceNeyret2 for their implementation of the fourier transform which I\n\tadaptated in the making of this shader.\n\tSee: https://www.shadertoy.com/view/MscGWS and https://www.shadertoy.com/view/XtScWt\n*/\n\nfloat renormalize(float c)\n{\n    vec2 nx = texelFetch(iChannel2, ivec2(0, 0), 0).rg;\n    float range = nx.y - nx.x;\n    float offset = nx.x;\n    return (c - nx.x)*1./range;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    vec2 mo = iMouse.xy/iResolution.xy;\n    mo = (mo==vec2(.0))?mo=vec2(0.3,0.7):mo;\n    \n    if (p.x < 0.5)\n    {\n        col = texture(iChannel0, p).rgg;\n        col.b = max(col.r,col.g)*(atan(col.r, col.g)+3.14159265)/6.2831583;\n        col = pow(col,vec3(0.5));\n    }\n    else\n    {\n        p.x -= 0.5;\n        col = renormalize(texture(iChannel1, p).r) * vec3(1.0);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Colors of noise by nimitz (2018) (twitter: @stormoid)\n\n#if 0\n//Based on XXhash32 (https://github.com/Cyan4973/xxHash)\nfloat hash(uvec2 p)\n{\n    const uint PRIME32_1 = 2654435761U;\n\tconst uint PRIME32_2 = 2246822519U;\n\tconst uint PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U;\n\tconst uint PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5;\n    h32 += p.x * PRIME32_3;\n    h32 = ((h32 << 17) | (h32 >> (32 - 17))) * PRIME32_4;\n    h32 ^= h32 >> 15;\n    h32 *= PRIME32_2;\n    h32 ^= h32 >> 13;\n    h32 *= PRIME32_3;\n    h32 ^= h32 >> 16;\n    return float(h32) * (1.0/float(0xffffffffU));\n}\n#else\n//From iq: https://www.shadertoy.com/view/llGSzw\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n#endif\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) \n        discard;\n        \n    // Horizontal + Vertical Discrete Fourier Transform of the input \n\t// adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\t// In turn adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS\n    for(float i = 0.; i < SIZE; i++)  \n    {\n        vec2 xn = hash(uvec2(i + 0.5, fragCoord.y))*vec2(1,0);\n        vec2 yn = texelFetch(iChannel0, ivec2(fragCoord.x, i + 0.5), 0).ba;\n        vec2 a = - 6.2831853 * (fragCoord - 0.5 - SIZE/2.) * i/SIZE;\n        fragColor.ba += cmul(xn, a.x);\n        fragColor.rg += cmul(yn, a.y);\n    }\n    \n    fragColor.ba /= SIZE;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Colors of noise by nimitz (2018) (twitter: @stormoid)\n//Processing\n\n\n//Can be different shapes\nfloat shape(vec2 p)\n{\n    return length(p);\n}\n\nfloat linstep(in float mn, in float mx, in float x)\n{\n\treturn clamp((x - mn)/(mx - mn), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = fragCoord/SIZE - 0.5;\n    \n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) return;\n    \n    vec4 col = texture(iChannel0, q).rgba;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    mo = (mo==vec2(.0))?mo=vec2(0.37,0.8):mo;\n    float shrp = mo.y*mo.y;\n    \n#ifdef FBM    \n    float shp = shape(p*(2. - mo.y*1.));\n    float w = 0.07 + mo.x*0.05;\n    float filt = smoothstep(w,0., abs(shp + 0.07));\n    filt = max(filt, 0.25*smoothstep(w,0., abs(shp + 0.05)));\n    filt = max(filt, 0.06*smoothstep(w,0., abs(shp + 0.02)));\n    filt = max(filt, 0.012*smoothstep(w,0., abs(shp - 0.03)));\n    filt = max(filt, 0.006*smoothstep(w,0., abs(shp - 0.06)));\n    filt = max(filt, 0.003*smoothstep(w,0., abs(shp - 0.09)));\n    filt = max(filt, 0.002*smoothstep(w,0., abs(shp - 0.12)));\n    filt = max(filt, 0.0015*smoothstep(w,0., abs(shp - 0.15)));\n    filt = max(filt, 0.0008*smoothstep(w,0., abs(shp - 0.2)));\n    filt = max(filt, 0.0005*smoothstep(w,0., abs(shp - 0.25)));\n\tcol.rg *= filt;\n#else\n#ifndef RING_FILTER\n    if (mo.x < 0.5)\n        col.rg *= smoothstep(0.5,0.5 + shrp*0.9, sin(shape(p*1.5) + mo.x*2.8 + 1.8)*0.5+0.5);\n    else\n        col.rg *= smoothstep(0.5,0.5+shrp*0.5, sin(shape(p*1.5) + (mo.x)*3.2 + 3.6)*0.5+0.5);\n#else\n    col.rg *= smoothstep(0.5 + shrp*0.3,0.5 - shrp*0.3, abs(shape(p*1.5)-mo.x)*0.5+(0.5));\n#endif\n#endif\n\t\n    \n    #ifdef ANIMATE\n    //animation (phase rotation)\n    float r = length(col.rg);\n    float a = atan(col.g,col.r);\n    a *= iTime;\n    col.rg = vec2(r*cos(a), r*sin(a));\n    #endif\n    \n    //TODO polar sinusoidal or spiral test\n    \n    fragColor = vec4(col.rg, 1,1);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Colors of noise by nimitz (2018) (twitter: @stormoid)\n\n// Horizontal + Vertical Inverse Discrete Fourier Transform of the input \n// adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x)*vec2(cos(b), sin(b)); }\n//#define Wrap(a) (fract((a + SIZE*0.5)/SIZE)*SIZE)\n#define Wrap(uv)   mod(uv+SIZE/2.,SIZE)                    // wrap [-1/2,1/2] to [0,1]\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    if(fragCoord.x > SIZE || fragCoord.y > SIZE) \n        discard;\n\n    for(float i = 0.; i < SIZE; i++)\n    {\n        float m = Wrap(i);\n        vec2 xn = texelFetch(iChannel0, ivec2(m + 0.5, fragCoord.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(fragCoord.x, m + 0.5), 0).ba;\n        vec2 ang =  6.2831853 *  Wrap(fragCoord-.5) * i/SIZE;   \n        fragColor.ba += cmul(xn, ang.x);\n        fragColor.rg += cmul(yn, ang.y);\n    }\n    \n    fragColor.ba /= SIZE;\n    //fragColor.rg = clamp(fragColor.rg,0.0,1.);\n    fragColor.rg = abs(fragColor.rg); //Should be incorrect, but gives best results\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Colors of noise by nimitz (2018) (twitter: @stormoid)\n\n#define SIZE (400.)\n//#define FBM\n//#define ANIMATE\n//#define RING_FILTER","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Colors of noise by nimitz (2018) (twitter: @stormoid)\n\n//Renomalization\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    float power = 0.;\n    \n    if(fragCoord.x > 1. || fragCoord.y > SIZE) \n        discard;\n\n    float minX = 10.;\n    float maxX = -10.;\n    \n    vec2 bY = texelFetch(iChannel1, ivec2(fragCoord.x, fragCoord.y), 0).ba;\n    float minY = bY.x;\n    float maxY = bY.y;\n    \n    for(float i = 0.; i < SIZE; i++)\n    {\n        vec2 x = texelFetch(iChannel0, ivec2(i + 0.5, fragCoord.y), 0).rg;\n        vec2 y = texelFetch(iChannel1, ivec2(fragCoord.x, i + 0.5), 0).ba;\n        \n        minX = min(minX, x.x);\n        maxX = max(maxX, x.x);\n        minY = min(minY, y.x);\n        maxY = max(maxY, y.y);     \n    }\n    \n    fragColor.ba = vec2(minX, maxX);\n    fragColor.rg = vec2(minY, maxY);\n}","name":"Buf D","description":"","type":"buffer"}]}