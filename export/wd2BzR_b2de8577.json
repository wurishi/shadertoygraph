{"ver":"0.1","info":{"id":"wd2BzR","date":"1589401036","viewed":84,"name":"Monte Carlo Diffusion test","username":"drcd1","description":"Testing Monte Carlo methods for solving the heat equation.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["diffusion","montecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t\n    vec2 res = iResolution.xy;\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/res.xy;\n\t\n\tvec4 value=texture(iChannel0,uv);\n\n    // Output to screen\n    fragColor = value;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//SAMPLES = The depth of the walk, per pixel\n#define SAMPLES 5\n#define R 0.8f\n#define EPS 0.001\n#define M_PI 3.1415926535897932384626433832795\n\n\n//press R to restart the simulation!\n\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nvec3 boundary(vec2 coords){\n\tfloat f = cos(8.0*atan(coords.y,coords.x));\n\tfloat f2 = cos(13.0*atan(coords.y,coords.x));\n    if(f>0.0f)\n        return vec3(0.0f,0.0f,0.0f);\n    else if (f2>0.0f)\n        return vec3(0.7f,0.6,0.2f);\n    else\n        return vec3(0.1f,0.1f,0.8f);\n\n}\n\nfloat sdf(vec2 coords){\n\treturn -abs(sqrt(dot(coords,coords))-R);\n}\n\n\nvec2 applyTransform(vec2 p, vec4 transform){\n    return (p+transform.xy)*transform.zw;\n}\n\nvec3 solveDiffusion(vec2 coords,float frame,vec4 transform){\n    float d = sdf(coords);\n    vec2 p = coords;\n    if(d>0.0f){\n    \treturn vec3(1.0f,1.0f,1.0f);\n    }\n    for(int i = 0; i<SAMPLES; i++){\n    \tif(d>-EPS)\n            return boundary(p);\n        \n        float r = 2.0*M_PI*random(coords+vec2(2.9812*float(i),frame));\n        p += -d*vec2(cos(r),sin(r));\n        d = sdf(p);\n    }\n    if(d>-EPS)\n        return boundary(p);\n    \n    ivec2 coords2d = ivec2(applyTransform(p,transform));\n    if (coords2d.x == 0 && coords2d.y == 0){\n        return vec3(0.0);\n      }\n    return texelFetch(iChannel1,coords2d,0).rgb;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool earlyReturn = false;\n    float currentFrame = texelFetch(iChannel1,ivec2(0,0),0).r+1.0;\n    if(iFrame==0 || 0.0!=texelFetch(iChannel0,ivec2(82,1),0).r){\n    \tfragColor = vec4(0.0f,0.0,0.0,1.0);\n       \tcurrentFrame = 0.0;\n    \tearlyReturn = true;\n    }\n    \n    \n    if(ivec2(fragCoord) == ivec2(0,0) ){\n    \tfragColor = vec4(currentFrame,0.0f,0.0f,1.0f);\n        return;\n    }\n    if(earlyReturn)\n        return;\n    \n    vec2 res = iResolution.xy;\n\tvec2 frag = fragCoord.xy;\n\tvec2 coords = (frag/res*2.0-1.0f);\n    coords.x*=res.x/res.y;\n    \n    vec4 transform;\n    transform.x=res.x/res.y;\n    transform.y = 1.0f;\n    transform.zw = vec2(0.5*res.y);\n    \n    \n    \n    vec4 color = vec4(solveDiffusion(coords,currentFrame,transform),1.0f);\n    fragColor = (texelFetch(iChannel1,ivec2(fragCoord),0)*(currentFrame-1.0)+color)/currentFrame;\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}