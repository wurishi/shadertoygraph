{"ver":"0.1","info":{"id":"3ty3DV","date":"1580358868","viewed":112,"name":"Montreal Winter Mood","username":"antoinefortin","description":"A Little exploration I made using the Montreal winter mood.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ddd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float h(vec2 p)\n{\n    \n\tfloat ba = texture(iChannel0, p * 0.055).x ;    \n    float b = (sin(p.x * 2.))  ;\n    b *= (cos(p.y)) / 2.5 ;\n    b*=  ba * sin( cos( 2.)) * abs(sin(1.) + 1.25);\n    \n    return -b - 1.2;\n}\n\n\nfloat sdPlane(vec3 pos)\n{\n\t\n    return pos.y - (h(pos.xz));\n}\n\nfloat sphereDistance(vec3 pos, float radius)\n{\n\t// copy to local scope of SDF \n    vec3 localPos = pos;\n    float localRadius = radius;\n    return length(localPos) - localRadius;\n    \n}\n\nfloat map(vec3 pos)\n{\n    vec3 q = pos;\n    \n    float radius = .5;\n    \n    float r = sin(q.x);\n    \n        \n\t//float d = sphereDistance(vec3(q.x + .5, q.y - .2 , q.z), .25);\n    float rad = .75;\n    rad *=  abs(sin(q.z - iTime * 5.))\n        * cos(q.x + .5 * 1.5) \n        * (abs(sin(q.z * 3.5)) + abs(cos(q.y)) ); // base\n\t\n    float d1 = sphereDistance(q, 1.);    \n    \n    float d2 = sdPlane(pos);\n    \n    \n    return min(d1, d2);\n}\n\nfloat castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n    \tvec3 pos = ro + t * rd;\n        \n        float h = map(pos);\n        if(h < 0.00001)\n        {\n        \tbreak;\n        }\n        t += h;\n        \n        if(t > 20.0) break;\n        \n    }\n    \n    if(t > 20.0) t = -1.0;\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy) - map(pos-e.xyy),\n        \t\t\t\t\tmap(pos+e.yxy) - map(pos-e.yxy),\n        \t\t\t\t\tmap(pos+e.yyx) - map(pos-e.yyx)\n    \t\t\t\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord- iResolution.xy) / iResolution.y;\n\n\t/*\nvec3 ro = vec3(0.0,0.0,1.0);\n   vec3 rd = normalize(vec3(p, -1.5));\n\t*/\n \t\n    // SKY \n    float speed = 00.00001;\n    float scale = 0.0015;\n    vec2 sp = fragCoord * scale; \n    for(int i=1; i<12; i++){\n        sp.x+=(cos(iTime * 0.25)) * 0.75/float(i)*sin(float(i)*2.*sp.y+iTime*speed)+ (iTime * 69.)/1000.;\n        sp.y+=cos(iTime) * 0.15/float(i)*cos(float(i)*5.*sp.x+iTime*speed)+(iTime * .69)/1000.;\n    }\n    float r=cos(sp.x+sp.y+.025)*.9 + 0.33;\n    float g=sin(sp.x+sp.y+1.)*.55+.5;\n    float b=(sin(p.x * 1. +p.y)+cos(sp.x+(sp.y)))*.5+.28;\n    vec3 color = vec3(b,g,1.0);\n    color -= 0.002;\n\n\tvec3 col = vec3(color);\n\n    \n    // Camera Look at\n    \n    float an = iTime * .5;\n    vec3 ro = vec3(3. * sin(an),.75, 5. *  cos(an));\n    \n\tfloat cameraZoom = 1.5;\n\tvec3 target = vec3(0.1, 0., 0.);\n\t\n\tvec3 ww = normalize(target - ro);\n\tvec3 uu = normalize(cross(ww, vec3(0.,1.,0.)));\n\tvec3 vv = normalize(cross(uu, ww));\n    \n\tvec3 rd = normalize(p.x * uu + p.y * vv + cameraZoom * ww);\n\n    // Rendering part\n\tfloat t = castRay(ro, rd);\n    \n    \n    if(t > 0.5)\n    {\n        \n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n       \tvec3 sundir = normalize(vec3(0.8, 0.4, 0.2));\n     \n        \n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir), 0.0, 1.0);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha * .7;\n        col += vec3(.0, 0.2, .5) * sky_dif * 2.5;\n    }\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}