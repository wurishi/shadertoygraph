{"ver":"0.1","info":{"id":"wtsfRH","date":"1596130096","viewed":209,"name":"Quasi 6 Dimension Square Circle","username":"timeparticle","description":"Display 3 dimensions of a 6 dimensional \"square circle\", with motion. Quasi means a full 6 dimensional set of calculations was not implemented. [Hey, it's my 1st shadertoy. And in my defense, I was left unsupervised.]","likes":3,"published":1,"flags":8,"usePreview":0,"tags":["time","circle","square","particle","dimension","six","6d","squarecircle","timeparticle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n  6 dimensional square circle \n\n  Display 2 dimensions of a cube (+ a little thinckness in 1D for viewability),\n  and 1 dimension of a circle (+ a little thinckness in 2D for viewability),\n  of a 6 dimensional square circle (really cube sphere) object.\n\n\n  This started as the Dila youtube raymarching tutorial\n  with spheres changed to cubes. It evolved. Kudos to:\n\n  dila:   https://www.youtube.com/watch?v=yxNnRSefK94\n  shane:  https://www.shadertoy.com/view/4dt3zn\n  iq:     https://www.shadertoy.com/view/Xds3zN\n  vug:    https://www.shadertoy.com/view/Md23DV\n\n  My hearty thanks to you all.\n\n*/\n\n\n//\n// Select object duplication and motion as options at compile time.\n//\n#define doDuplicateObject;\n#define doMoveScene          // caution: no motion if no duplication\n\n\n#define numberOfObjects 4\n/* objectType list\n\n\t0 cube\n\t1 sphere\n\t2 SquareCircle   // display dim 1 & 2 (i.e. part of cube), and dim 6 (i.3. part of sphere)\n\t3 CircleSquare   // display dim 4 & 6 (i.e. part of sphere), and dim 2 (i.3. part of cube)\n\n*/\n\n\n// list of (perhaps) useful colors\nconst vec3 red_rgb     = vec3(0.75,0.0,0.0);\nconst vec3 green_rgb   = vec3(0.0,1.0,0.0);\nconst vec3 blue_rgb    = vec3(0.0,0.0,1.0);\nconst vec3 white_rgb   = vec3(1.0,1.0,1.0);\nconst vec3 black_rgb   = vec3(0.0,0.0,0.0);\nconst vec3 gray_rgb    = vec3(0.5,0.5,0.5);\nconst vec3 cyan_rgb    = vec3(0.0,1.0,1.0);\nconst vec3 magenta_rgb = vec3(1.0,0.0,1.0);\nconst vec3 purple_rgb  = vec3(0.5,0.0,0.5);\nconst vec3 teal_rgb    = vec3(0.0,0.5,0.5);\n\n\n// Specify the colors for the cube and sphere.\nconst vec3 cube_color = blue_rgb;\nconst vec3 sphere_color = red_rgb;\n\n\n//\n// Compute the distance for the sphere or cube \"map\".\n// Return the distance together with the color of the \n// object for the current pixel.\n//\nvec4 map(vec3 p)\n{\n   \n    // qxyz is representative of the 1st 3 diemnsions,\n    // qabc is representative of the 2nd 3 diemnsions,\n    vec3  qxyz  = p;\n    vec3  qabc = p;\n\n\t#ifdef doDuplicateObject\n       qxyz = fract(p) * 2.0 - 1.0;  // duplicate the object\n       qabc = qxyz;\n    #endif\n\n    \t// Define some handy variables for the distance metrics below.\n        float cube;\n        float cube_y;\n\t   \tfloat cube_z;\n        float cube_xz;\n    \n        float sphere;\n    \tfloat sphere_a;\n    \tfloat sphere_b;\n    \tfloat sphere_ac;\n    \tfloat sphere_bc;\n    \n    \n    /* objectType list\n\n\t\t0 cube\n\t\t1 sphere\n\t\t2 SquareCircle   // display dim 1 & 2 (i.e. part of cube), and dim 6 (i.3. part of sphere)\n\t\t3 CircleSquare   // display dim 4 & 6 (i.e. part of sphere), and dim 2 (i.3. part of cube)\n\t*/\n    // Change object type as time progresses.\n    float secondsPerObjectType = 5.0;\n    float doObjectType = mod(floor(iTime/secondsPerObjectType), float(numberOfObjects));\n    \n    if (doObjectType == 0.0)  // do cube\n    {\n    \n    \tfloat side = 0.20;\n    \tfloat zScale = 1.20;  // adjust z scale for asthetics\n    \tqxyz = abs(qxyz);  // symmetry operation for cube\n    \tcube = max(qxyz.x, max(qxyz.y, zScale*qxyz.z)) - side; // basic cube calculation\n    \n    \treturn vec4(cube, cube_color); \n    }\n    \n    if (doObjectType == 1.0)  // do sphere\n    {\n    \n   \t\tfloat radius = 0.25;\n    \tfloat zScale = 1.20;\n    \tqabc.z *= zScale;\n    \tsphere = length(qabc) - radius;  //sphere\n    \treturn vec4(sphere, sphere_color);\n    }\n \n \n    if (doObjectType == 2.0)  // do SquareCircle\n    {\n \n\t\t//\n    \t// cube\n    \t//\n    \t// cube on x & y, with a small ammount of z for viewability.\n    \t//\n    \t// Do the actual \"cube\" map.\n    \tqxyz = abs(qxyz);  // symmetry operation for cube\n    \tcube = max(qxyz.x,qxyz.y) - 0.20; // basic cube calculation\n       \t\n    \t// \"add in\" some thickness\n    \tcube_z = qxyz.z - 0.01;  // some z thickness for visibility\n    \tcube = max(cube , cube_z); // insert the z thickness\n    \n    \tvec4 cubeDistColor = vec4(cube, cube_color);\n    \n    \t//\n    \t// sphere\n    \t//\n    \t// sphere on axis a, with a small amount of axes b & c for viewability\n    \t//\n    \t// Implement: float radius = 0.25;  circle = length(qabc) - radius;\n    \t// along axis a, while mostly supressing axes b & c for viewability\n    \tfloat radius_a = 0.25;  // \"circle\" in 1 dimension\n    \tfloat radius_bc = 0.025; // small amount of thickness for viewability\n    \t\n    \t// Do the actual \"sphere\" map.\n    \tqabc = abs(qabc);\n    \tsphere_a = (qabc.z - radius_a);\n    \tsphere_bc = length(qabc.xy) - radius_bc;\n    \n    \t// \"add in\" some thickness\n    \tsphere = max(sphere_a, sphere_bc);\n    \n    \t// Put the distance and the color together/\n    \tvec4 sphereDistColor = vec4(sphere, sphere_color);\n    \n    \t// Return the distance and color of the closest object via sorting by distance.\n    \treturn (sphereDistColor.x < cubeDistColor.x) ? sphereDistColor : cubeDistColor;\n\n    }\n    \n \n    if (doObjectType == 3.0)  // do CircleSquare\n    {\n\t\t//\n    \t// cube\n    \t//\n    \t// cube on y, with a small ammount of  x & z for viewability.\n    \t//\n    \t// Do the actual \"cube\" map.\n    \tqxyz = abs(qxyz);  // symmetry operation for cube\n    \t\n    \tfloat side_y  = 0.5;  // y axis \"length\"\n    \tfloat side_xz = 0.01;  // some x & z thickness for visibility\n    \n    \tcube = max(qxyz.x,qxyz.z) - side_xz; // some x & y thickness for visibility\n       \t\n    \t// \"add in\" some thickness\n    \tcube_y = qxyz.y - side_y;  // observing z axis\n    \tcube = max(cube , cube_y); // insert the x & y thickness\n    \n    \tvec4 cubeDistColor = vec4(cube, cube_color);\n  \n    \n    \t//\n    \t// sphere\n    \t//\n    \t// sphere on axes a & b, with a small amount of axis c for viewability\n    \t//\n    \t// Implement: float radius = 0.25;  circle = length(qabc) - radius;\n    \t// along axis a, while mostly supressing axes b & c for viewability\n    \tfloat radius_b = 0.025;  //  small amount of thickness for viewability\n    \tfloat radius_ac = 0.25; // \"sphere\" in 2 dimensions\n    \tfloat cScale = 1.0;  // scale to make it a circle, not an ellipse\n    \tfloat aScale = 0.5;  // scale to make it a circle, not an ellipse\n    \t\n    \t// Do the actual \"sphere\" map.\n    \tqabc = abs(qabc);\n    \tsphere_b = (qabc.y - radius_b);\n    \t// Scale axes to make a circle, instead of an ellipse.\n    \tqabc.z *= cScale;\n    \tqabc.x *= aScale;\n    \tsphere_ac = length(qabc.xz)- radius_ac;\n    \n    \t// \"add in\" some thickness\n    \tsphere = max(sphere_b, sphere_ac);\n        \n    \t// Put the distance and the color together/\n    \tvec4 sphereDistColor = vec4(sphere, sphere_color);\n    \n    \t// Return the distance and color of the closest object via sorting by distance.\n    \treturn (sphereDistColor.x < cubeDistColor.x) ? sphereDistColor : cubeDistColor;\n    }\n}\n\n\n\n// Ray marching will return a pixel distance & color.\n// Apparently, this is atypical for a ray march routine.\nvec4 trace(vec3 origin, vec3 ray)\n{\n    vec4 distColor;\n    float t = 0.0;\n    \n    // typical ray march, but it also passes the object color along\n    for (int i = 0; i <128; i++)\n    {\n        vec3 p = origin + ray * t;\n        // The map function performs the distance metric calculation\n        // across multiple objects.\n        distColor = map(p);\n        t += distColor.x * 0.45;  //0.15;  \n    }\n    \n    // get the proper distance into the returned object, along with the color\n    distColor.x = t;\n\treturn distColor;\n}\n\n\n// The main frag shader routine set the basic parameters,\n// does the motion calculations, invokes the ray marching,\n// computes a distance fogging, and returns the color for a specific pixel.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // -1 to 1\n    uv = uv * 2.0 -1.0;\n    \n    // destretch aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    // The default is no motion.\n    vec3 origin = vec3(0.0, 0.0, -3.0);\n    \n    // Move the scene, if compile time definition is set.\n    #ifdef doMoveScene\n       #ifdef doDuplicateObject\n          // Vary the angle with time.\n          float theta = iTime * 0.25;\n    \t  ray.xy *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n          // Vary the origin with time.\n          origin = vec3(0.0, iTime, iTime);\n\n       #endif\n    #endif\n    \n    \n    // Invoke the ray march.\n    vec4 distColor = trace(origin, ray);\n    \n    // Add \"distance fog\" to the scene.\n    float fog = 1.0 / (1.0 + distColor.x * distColor.x * 0.1); \n    vec3 finalColor = fog * distColor.yzw;\n    \n    float alpha = 1.0;  // this is a \"transparancy factor\"\n    vec4 finalPixel = vec4(finalColor, alpha);\n    \n    // Return the final pixel color with its transparancy.\n    fragColor = finalPixel;\n    \n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n// Add in some simple sounds for fun.\n//\n\n\n// Add sound.\n#define doSound\n\n\n#ifdef doSound\n\n\tvec2 mainSound( in int samp,float time)\n\t{\n    \tfloat secondsBeforeRepeat = 5.0;\n    \ttime = mod(time,secondsBeforeRepeat);\n    \n    \t// A 275 Hz wave that attenuates quickly overt time\n    \tvec2 out1 = vec2( sin(6.2831*275.0*time)*exp(-5.0*time) );\n    \tvec2 out2 = vec2( sin(6.2831*220.0*time) * sin(sin(6.2831*10.0*time)*6.2831*10.0*time) );\n    \tvec2 out3 = out2 * exp(-0.3*time);\n    \n    \tfloat freq = 128.0;\n    \tvec2 out4 = vec2( sin(6.2831*freq*time)*exp(-5.0*time) );\n\n    \tfloat partialMute = 0.025;\n    \n    \tvec2 outCombined = partialMute * (out1 + out2 + out3 + out4);\n    \treturn outCombined;\n\t}\n\n#endif\n","name":"Sound","description":"","type":"sound"}]}