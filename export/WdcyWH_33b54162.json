{"ver":"0.1","info":{"id":"WdcyWH","date":"1670772702","viewed":73,"name":"Living in a Box - WIP2","username":"neriakX","description":"This shader is based on some streams by Flopine and evvvvil. It's my first attempt and I'm a total noob :P\nIt's nothing special and I just keep learning from this. However I share it with you to hopefully get some constructive criticism from you guys.\n","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ltSXDm","filepath":"https://soundcloud.com/neriakx/sidcom-2007","previewfilepath":"https://soundcloud.com/neriakx/sidcom-2007","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Living in a Box - WIP\" by neriakX.\n// 2022-11-26\n\n/* inspired by Flopine's and evvvvil's twitch streams\n\nthis is my first attempt in ray marching.\njust starting to mess around with (hopefully) simple stuff ...\nI took some functions from iq also => https://iquilezles.org/articles/distfunctions\n\nthere's a lot of stuff missing and funky things are happening :)\n\n*/\n\n#define FOV .5\n#define ITER 64.\n//#define PI acos(-1.0)\n//#define TAU PI*2\n#define tt mod(iTime,62.82)\n#define tc (iChannelTime[0] - .1)\n#define bpm (129./60.+1.2)\n\nconst float PI = acos(-1.0),\nTAU = 2.*PI;\nconst vec2 BEAT = vec2(200./440.*0.0390,.05);\nfloat t, scene, g1=0.;\nvec2 sc;\nvec3 np, no, al, po, ld;\n\n\n\n\n// smin function\nfloat smin(float a, float b, float h){\n  float k=clamp((a-b)/h*.5+.5,0.,1.);\n  return mix(a,b,k)-k*(1.-k)*h;\n}\n\n// smin2 function\nvec2 smin2(vec2 a, vec2 b, float h){\n  float k=clamp((a.x-b.x)/h*.5+.5,0.,1.);\n  return mix(a,b,k)-k*(1.-k)*h;\n}\n\n// iq's Tools\nfloat un( float d1, float d2 ) { return min(d1,d2); }\nfloat sub( float d1, float d2 ) { return max(-d1,d2); }\nfloat isec( float d1, float d2 ) { return max(d1,d2); }\n\nfloat ssub( float d1, float d2, float k ){\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvec3 opRepLim( in vec3 p, in float c, in vec3 l){\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\n// rotation function\nmat2 r2 (float a) { return mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n\n//sphere\nfloat sp(vec3 p, float r) { return length(p)-r; }\n\n//diamond\nfloat di (vec3 p, float s){\n    float lx = length(p.x);\n    float ly = length(p.y);\n    float lz = length(p.z);\n    return sqrt(lx+ly+lz)-s;   \n}\n\n// box\nfloat bo (vec3 p, vec3 c){\n    float r = 0.12;\n    vec3 q = abs(p)-c;\n    //return length(max(q, 0.)) + min(0., max(q.x,max(q.y,q.z)));  \n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) -r; // rounded\n}\n\n// unsigned box\nfloat ub (vec3 p, vec3 c){\n    vec3 q = abs(p)-c;\n    return length(max(q , 0.));   \n}\n\n// Cylinder\nfloat cy (vec3 p, float r, float height){\n    return max(length(p.xy)-r,abs(p.z)-height); \n}\n\n// lighting\nfloat lighting (vec3 n, vec3 l){\n  //return max(0., dot(n, l)); // more toonish light\n  return dot(n,l)*0.5+0.5; // more real light\n}\n\n\n// Camera\n/* vec3 camera (vec3 ro, vec3 ta, vec2 uv, float fov)\n{\n    vec3 f = normalize(ta-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,1.), f));\n    vec3 u = normalize(cross(f, l));\n    return normalize(f*fov + l*uv.x + u*uv.y);\n} */\n\n\n\n//Noise function stolen form evvvvil who stole from Virgil who stole it from Shane\nfloat noise(vec3 p){ \n  vec3 ip=floor(p),s=vec3(7,157,113);\n  p-=ip;\n  vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\n\n// the box\nvec2 sbx (vec3 p, vec3 s)\n{\t\n\n    //p.x -= 2.5*sin(bpm*tt/4.);\n    p.yz *= r2(bpm*tt);\n    p.xz *= r2(bpm*tt);\n    //p.y += 2.2*sin(bpm*tt*4.);\n    vec2 h,t=vec2(bo(p, s-0.7*sin(texture(iChannel0,BEAT).x)),11.);\n    return t;\n}\n\n\n// the sphere\nvec2 bs (vec3 p)\n{\t\n    // bouncing sphere \n    p.x -= 2.5*sin(bpm*tt/4.);\n    //p.xz *= r2(tt);\n    p.y += 2.2*sin(bpm*tt*2.);\n    vec2 h,t=vec2(sp(p, 1.3),11.);\n    return t;\n}\n\n// the diamond\nvec2 sdd (in vec3 p) {\n    float per = 3.0; \n    p.x -= -2.*sin(bpm*tt/4.)-2.*cos(bpm*tt/4.);\n    p.y -= sin(bpm*tt*1.8);\n    p.yz *= r2(bpm*tt*1.115);\n    p.xz *= r2(bpm*tt/4.);\n    \n    vec2 h,t=vec2(di(p,1.3),11.);\n    if (tt > 30.) {\n        //p.yz *= r2(bpm*tt*1.8);\n        p.xz *= r2(-0.5*sin(bpm*tt/8.)+0.1*cos(bpm*tt/8.));\n        return t;\n    } else {    \n        p.xz *= r2(1.8*sin(bpm*tt/8.)-1.8*cos(bpm*tt/8.));\n    }\n    return t;\n}\n\n// the room\nvec2 rtr (vec3 p)\n{   \n  \t// moving room\n   \n    \n    p.xz *= r2(-bpm*tt/4.);\n    if (tt>30.){\n        p.yz *= r2(-bpm*tt/4.);\n    } else {\n        p.yz *= r2(atan(sin(tt)*.5));\n    }\n    vec2 h,t = vec2(-bo(p, vec3(20.,4.0,20.)),5.);\n\n    // cut the room with cylinders\n    float per = 2.5; //period - Wiederholungen - netter Wert 1.9 o. 2.5\n    p.xz = mod(p.xz, per)-per *0.5; // repeat\n\th=vec2(cy(p.xzy,0.7, 5.0*1.05+sin(texture(iChannel0,BEAT).x*6.)),5.); // 1e10\n    t.x=ssub(h.x, t.x, .03);\n    return t; \n}\n\n// the scene\nvec2 map (vec3 p) \n{ \t\n    np=p;\n    vec2 h,t=rtr(p);\n    if (tc>15.) {\n        h=sdd(p);\n    } else {\n        h=sbx(p,vec3(1.7));\n    }\n    g1 += 0.01/(0.01+h.x*h.x)*0.12;\n   \tt=(t.x<h.x)?t:h;\n   \tt.x*=0.6;\n    return t;\n}\n\n// main raymarching function\nvec2 tr (vec3 ro, vec3 rd) \n{    \n    vec2 h,t=vec2(0.1);\n    for(float i=0.;i<ITER;i++){\n        h=map(ro+rd*t.x);\n        if(h.x<.0001||t.x>ITER) break;\n        t.x+=h.x;t.y=h.y;\n        //t+=h;\n    }\n    if (t.x>ITER) t.x=0.;\n    return t;\n}\n\n// get Normals (iq)\nvec3 calcNormal( in vec3 po )\n{\t\n    vec2 e=vec2(.00035,-.00035);\n    return normalize(e.xyy*map(po+e.xyy).x+\n        e.yyx*map(po+e.yyx).x+\n        e.yxy*map(po+e.yxy).x+\n        e.xxx*map(po+e.xxx).x); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    \n    // ray_origin / camera\n    vec3 ro = vec3(0.,0.,6.), //ray origin is 0.,0.,6. in space - step back\n    cw=normalize(vec3(0.,1.,0.)-ro),\n    cu=normalize(cross(cw, vec3(0.,0.,1.))),\n    cv=normalize(cross(cu,cw)),\n    rd=mat3(cu,cv,cw)*normalize(vec3(uv,FOV)),\n    co,fo,\n    ld=normalize(vec3(0.5,.4,-.1));\n\n    co=fo=vec3(0.2)*(1.-length(uv)-0.2);\n       \n    sc=tr(ro,rd); // sc.x = distance geometry, sc.y = colour\n    t=sc.x; // t is the result of the geometry\n    \n    if (t>0.) \n    {\t\n        po=ro+rd*t;\n        vec3 no = calcNormal(po),\n        al=vec3(0,.2,.8);\n        \n        // colouring\n        if(sc.y<5.) al=vec3(0);\n    \tif(sc.y>5.) al=vec3(1);\n        if(sc.y>6.) al=vec3(.0, .04, .18);\n        if(sc.y>9.) al=vec3(.18, .08, .0);\n        if(sc.y>10.5) al=vec3(.6, .3, .7);\n        \n    \tfloat dif=dot(no,ld)*0.5+0.5,// diffuse\n    \taor=t/50.,ao=exp2(-2.*pow(max(0.,1.-map(po+no*aor).x/aor),2.)), //ao = ambient occlusion, aor = ambient occlusion range\n    \tspo=exp2(1.+3.*noise(np/vec3(0.4,.8,.8)+noise(np/vec3(0.1,.2,.2)))),\n    \tfr=pow(1.+dot(no,rd),4.);\n    \tvec3 sss=vec3(0.5)*smoothstep(0.,1.,map(po+ld*0.4).x/0.4), //Fake sub surface scattering, from tekf https://www.shadertoy.com/view/lslXRj\n    \tsp=vec3(0.5)*pow(max(dot(reflect(-ld,no),-rd),0.),30.); //specular by shane.\n\n    \tco=mix(sp+al*(0.8*ao+0.2)*(dif),fo,fr); //final lights\n        co += g1*vec3(0.2,0.1,0.2);\n        co=mix(co, vec3(0.035*texture(iChannel0,BEAT).x,0.,0.045)*texture(iChannel0,BEAT).x*0.8, 1.-exp(-0.0033*t*t*t)); // purple fog blinking\n        \n        fragColor = vec4(pow(co, vec3(.45)),1.); // gamma correction\n        fragColor *= 1.2-dot(uv, uv);// vignette\n    }\n}","name":"Image","description":"","type":"image"}]}