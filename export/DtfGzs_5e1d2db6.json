{"ver":"0.1","info":{"id":"DtfGzs","date":"1672224014","viewed":116,"name":"Linear Convolution","username":"Envy24","description":"Read Image tab header.\n\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["convolution","linear","system","response","graphs","dsp"],"hasliked":0,"parentid":"mtf3WN","parentname":"System additivity checker"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n   n = f(t)  - discrete function of time,\n   Blue      - input signal x(n),\n   Purple    - impulse response h(n),\n   Red       - demonstration of convolution process,\n   Dark Cyan - linear_convolution[x(n), h(n)].\n   \n   Source: https://upload.wikimedia.org/wikipedia/commons/2/21/Comparison_convolution_correlation.svg\n   \n   Convolution is commutative, e.g. conv(x, h) == conv(h, x).\n*/\n\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define ORIGIN                    ( vec2(0, 0) )\n#define SCENE_SCALE               ( 15.0 )\n#define UNIT                      ( 2.0*SCENE_SCALE / R.y )          // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx, dsdx = sqrt(1.0 + dfdx * dfdx); // arclength change over argument change\n    return SMAA(abs(sdf) / dsdx);\n                           \n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\nfloat step_(float n) { return n < 0. ? 0. : 1.; } // step signal\nfloat unit(float n) { return n == 0. ? 1. : 0.; } // unit impulse\n\n#define MIN (-21.)\n#define MAX (20.)\n#define T (iTime * 0.1)\n\n//#define LOOP(T) ( loop_continuous(MIN, MAX, T) )\n#define LOOP(T) ( loop_discrete(MIN, MAX, T) )\n//#define LOOP(T) ( (40.*T) )\n//#define LOOP(T) ( 0. ) // off loop\n\nfloat x(float n)\n{\n    //return unit(n) * 1.;\n    \n    if (abs(n) <= 3.) { return 6.; }\n    return 0.;\n}\nfloat h(float n) // impulse response (impulse characteristic)\n{\n    //return unit(n) * 1.;\n    \n    if (abs(n) <= 3.) { return (3. - n); }\n    return 0.;\n}\n\nfloat linear_convolution(float n)\n{\n    float sum = 0., f = x(n);\n    for (float k = MIN; k <= MAX; k += 1.)\n    {\n        sum += x(k)*h(n - k); // conv(x, h)\n        //sum += h(k)*x(n - k); // conv(h, x)\n        // Convolution is commutative, e.g. conv(x, h) == conv(h, x).\n    }\n    return sum;\n}\n\nfloat y(float n) { return linear_convolution(n); }\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, ORIGIN, true);\n\n    float vert_offset = 7.,  // offset relative to y = 0 line\n          vert_shift = -0.,  // shifts plot up or down\n          x_offs = vert_offset + vert_shift,\n          y_offs = vert_shift - vert_offset;\n\n    vec3 X_col = vec3(0,0,1), Y_col = vec3(1,0,0), H_col = vec3(1,0,1), color = vec3(1.);\n    /* Common stuff */\n         color -= x_axis(vec2(NDC.x, NDC.y - x_offs)); \n         color -= x_axis(vec2(NDC.x, NDC.y - y_offs));\n         color -= y_axis(NDC);\n         color = mix(color, vec3(0,.5,0), vertical_line(NDC, MIN));\n         //color = mix(color, vec3(0,.5,0), vertical_line(NDC, MAX)); // for [min, max)   see discrete_loop\n         color = mix(color, vec3(0,.5,0), vertical_line(NDC, MAX + 1.)); // for [min, max]\n         color = mix(color, vec3(0,0,.5), vertical_line(NDC, LOOP(T)));\n\n    /* Input signal x(n) and impulse response h(n) */\n    float n = round(NDC.x), X = x(n) + x_offs, H = h(-(n - LOOP(T))) + x_offs;\n         color = mix(color, X_col, SMAA(segmentSDF_L2(NDC, vec2(n, x_offs), vec2(n, X), UNIT*0.25)));\n         color = mix(color, X_col, SMAA(diskSDF_L2(NDC, vec2(n, X), 2.5*UNIT)));\n         \n         color = mix(color, H_col, SMAA(segmentSDF_L2(NDC, vec2(n, x_offs), vec2(n, H), UNIT*0.25)));\n         color = mix(color, H_col, SMAA(diskSDF_L2(NDC, vec2(n, H), 2.5*UNIT)));\n              \n    /* Full system response y(n) to signal x(n) */\n    float scale = pow(2., -4.), // if output is too high, then scale it down.\n          Y = y(n) * scale + y_offs; \n          \n          color = mix(color, 0.75-Y_col, SMAA(segmentSDF_L2(NDC, vec2(n, y_offs), vec2(n, Y), UNIT*0.25)));\n          color = mix(color, 0.75-Y_col, SMAA(diskSDF_L2(NDC, vec2(n, Y), 2.5*UNIT)));\n          \n    /* Partial system response y(n) to signal x(n)  (for demonstration of convolution process) */     \n    for (float s = MIN; s < LOOP(T); s += 1.)\n    {\n        Y = linear_convolution(s) * scale;\n        Y += y_offs; // shift graph to bottom\n        \n        color = mix(color, Y_col, SMAA(segmentSDF_L2(NDC, vec2(s, y_offs), vec2(s, Y), UNIT*0.25)));\n        color = mix(color, Y_col, SMAA(diskSDF_L2(NDC, vec2(s, Y), 2.5*UNIT)));\n    }\n        \n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float loop_continuous(in float min, in float max, in float T)\n{\n    float //range = max - min;        // [min; max)\n          range = (max + 1.) - min; // [min; max]\n    return (min + fract(T) * range);\n}\nfloat loop_discrete(in float min, in float max, in float T)\n{\n    float //range = max - min;        // [min; max)\n          range = (max + 1.) - min; // [min; max]\n    return round(min + fract(T) * range);\n}\n\nfloat diskSDF_L2(in vec2 NDC, in vec2 C, in float r) { return length(C - NDC)-r; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}","name":"Common","description":"","type":"common"}]}