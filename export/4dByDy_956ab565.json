{"ver":"0.1","info":{"id":"4dByDy","date":"1493508620","viewed":915,"name":"Tiny VPT 2","username":"TinyTexel","description":"a tiny volume path tracing setup\ncube of colored glass + weakly, monochromatically absorbing, scattering cube inside\nversion 2 of: https://www.shadertoy.com/view/lsByDw\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys","likes":43,"published":1,"flags":48,"usePreview":1,"tags":["volume","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tiny VPT 2\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\na tiny volume path tracing setup\ncube of colored glass + weakly, monochromatically absorbing, scattering cube inside\nversion 2 of: https://www.shadertoy.com/view/lsByDw\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\nconst float Pi = 3.14159265359;\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = floor(fragCoord.xy);\n\tvec2 tex = fragCoord.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n   // if(false)\n    {\n    \tcol = 1.0 - exp2(-col * 3.0);\n        col = mix(col, col*col, 0.8);\n    }\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n    //fragColor = vec4(col, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Tiny VPT 2\n// Created by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\na tiny volume path tracing setup\ncube of colored glass + weakly, monochromatically absorbing, scattering cube inside\nversion 2 of: https://www.shadertoy.com/view/lsByDw\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, out vec3 glp)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;\n    \n    glp = cam.Right * llp.x + cam.Up * llp.y;\n    \n    vec3 dir = normalize(imgPos * S1 - glp);\n\n    return dir;\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n\tt = min(ub.x, min(ub.y, ub.z));\t\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t, out vec3 N)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n\tvec3 o = -cth * os;\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n    if(ub.x < ub.y) {t = ub.x; N = vec3(os.x, 0.0, 0.0);} else \n                    {t = ub.y; N = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t   ) {t = ub.z; N = vec3(0.0, 0.0, os.z);}\n    \n    t = max(0.0, t);\n\t//t = min(ub.x, min(ub.y, ub.z));\t\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nvoid Intersect_Ray_SphereBackside(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout float t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = min(dot(rp, rp) - sr2, 0.0);\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\t//if(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(max(0.0, D));\n\n\tt = (-b + sqrtD) / a * 0.5;\n}\n\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(clamp01(1.0 - s1*s1));\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n\n// s [0..1]\nfloat Sample_HenyeyGreensteinPhF(float s, float g)\n{\t\n    if(abs(g) < 0.0001) return s * 2.0 - 1.0;\n\n    float g2 = g * g;\n\n    float t0 = (1.0 - g2) / (1.0 - g + 2.0 * g * s);\n\n    float cosAng = (1.0 + g2 - t0*t0) / (2.0 * g);\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_HenyeyGreensteinPDF(float s0, float s1, float g, vec3 forward)\n{\t\n    float cosTheta = Sample_HenyeyGreensteinPhF(s1, g);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n// s [0..1]\nfloat Sample_SchlickPhF(float s, float k)\n{\t\n    float t0 = 1.0 + k - 2.0 * s;\n    float t1 = 1.0 + k - 2.0 * s * k;\n\n    float cosAng = t0 / t1;\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_SchlickPDF(float s0, float s1, float k, vec3 forward)\n{\t\n    float cosTheta = Sample_SchlickPhF(s1, k);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nfloat HenyeyGreensteinPhF(float cosTheta, float g)\n{\n\tfloat g2 = g * g;\n\t\n\tfloat t0 = 1.0 - g2;\n\tfloat t1 = 1.0 + g2 - 2.0 * g * cosTheta;\n\t\n\t return t0 * rsqrt(max(0.0, t1*t1*t1));\n\t//return t0 * rsqrt(max(1.0e-32, t1*t1*t1));\n}\n\nfloat HenyeyGreensteinPDF(float cosTheta, float g)\n{\n    return HenyeyGreensteinPhF(cosTheta, g) * RcpPi4;\n}\n\n\nfloat FresnelDielectricsP(float ci, float ct, float ni, float nt)\n{\n\tfloat t0 = nt * ci;\n\tfloat t1 = ni * ct;\n\t\n\treturn (t0 - t1) / (t0 + t1);\n}\n\nfloat FresnelDielectricsS(float ci, float ct, float ni, float nt)\n{\n\tfloat t0 = ni * ci;\n\tfloat t1 = nt * ct;\n\t\n\treturn (t0 - t1) / (t0 + t1);\n}\n\nfloat FresnelDielectrics(float ci, float ct, float ni, float nt)\n{\n\tfloat p = FresnelDielectricsP(ci, ct, ni, nt);\n\tfloat s = FresnelDielectricsS(ci, ct, ni, nt);\n\t\n\treturn (p*p + s*s) * 0.5;\n}\n\nfloat FresnelDielectrics(vec3 ray, vec3 N, float n1, float n2)\n{\n\tfloat n = n1 / n2;\n\tfloat NdL = dot(-ray, N);\n\n\tfloat sin2t = n*n * (1.0 - NdL*NdL);\n\tfloat cos2t = 1.0 - sin2t;\n\t\n\tif(cos2t > 0.0)\n\treturn FresnelDielectrics(dot(-ray, N), sqrt(cos2t), n1, n2);\n\telse\n\treturn 1.0;\n}\n\nvec3 ReflectRay(vec3 ray, vec3 N)\n{\n\tfloat ct = dot(-ray, N);\n\t\n\treturn ray + N * (2.0 * ct);\n}\n\n\n//cos2t (discriminant) < 0 -> total internal reflection\nvec3 RefractRay(vec3 ray, vec3 N, float n1, float n2, out float cos2t)\n{\n\tfloat n = n1 / n2;\n\tfloat NdL = dot(-ray, N);\n\n\tfloat sin2t = n*n * (1.0 - NdL*NdL);\n\tcos2t = 1.0 - sin2t;\n\t\n\tif(cos2t > 0.0)\n\tray = n * ray + (n * NdL - sqrt(cos2t)) * N;\n\t// else\n\t// ray = float3(1.0, 0.0, 0.0);\n\t\n\treturn ray;\n}\n\nvoid ReflRefrDielectrics(vec3 ray, vec3 N, float n1, float n2, \nout vec3 refl, out vec3 refr, out float re)\n{\n\tfloat cos2t;\n\n\trefl = ReflectRay(ray, N);\n\trefr = RefractRay(ray, N, n1, n2, cos2t);\n\t\n\tif(cos2t > 0.0)\n\tre = FresnelDielectrics(dot(-ray, N), sqrt(cos2t), n1, n2);\n\telse\n\tre = 1.0;\n}\n\n//s [0..1]\n// return(passed through boundary)\nbool ReflRefrDielectrics(vec3 ray, vec3 N, float n1, float n2, float s, \nout vec3 rayO)\n{\n\tvec3 refl, refr;\n\tfloat re;\n\tReflRefrDielectrics(ray, N, n1, n2, refl, refr, re);\n\t\n\tif(s < re)\n\t{\n\t\trayO = refl;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\trayO = refr;\n\t\treturn true;\n\t}\n}\n\n\nconst vec3 PseudoSpectralRGBWeights_Box_W = 1.0 / vec3(0.25, 0.5, 0.25);\nvec3 Sample_PseudoSpectralRGBWeights_Box(float s)\n{\n\tvec3 fw = vec3(0.0);\n\t\n\tif(s < 0.25) fw.x = 1.0;\n\telse \n\tif(s < 0.75) fw.y = 1.0;\n\telse\t\t fw.z = 1.0;\n\t\n\treturn fw;\n}\n\nconst vec3 PseudoSpectralRGBWeights_Tri_W = 1.0 / vec3(0.25, 0.5, 0.25);\nvec3 Sample_PseudoSpectralRGBWeights_Tri(float s)\n{\n\tvec3 fw;\n\t\n\tif(s < 0.5)\n\t{\n\t\tfw.z = 0.0;\n\t\tfw.y = s * 2.0;\n\t\tfw.x = 1.0 - fw.y;\n\t}\n\telse\n\t{\n\t\tfw.x = 0.0;\n\t\tfw.z = s * 2.0 - 1.0;\n\t\tfw.y = 1.0 - fw.z;\n\t}\n\t\n\treturn fw;\n}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\nvec3 EvalSigmaA(vec3 pos, vec3 posn, vec3 sigma_a_max, vec3 sigma_a_min)\n{ \n    bvec3 cond0 = greaterThan(-pos , vec3(0.0));\n    bvec3 cond1 = greaterThan(-posn, vec3(0.0));\n\n    vec3 sigma_a0 = If(cond0, sigma_a_max, sigma_a_min);\n    vec3 sigma_a1 = If(cond1, sigma_a_max, sigma_a_min);\n\n    vec3 sigma_a = If(equal(cond0, cond1), \n                      sigma_a0, \n                      mix(sigma_a0, sigma_a1, abs(posn) / (abs(posn) + abs(pos))));\n    \n    return sigma_a;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    vec2 ang = vec2(Pi * 0.9, Pi * 0.0);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, PixelCount.x / PixelCount.y);\n    \n    float cdist = exp2(1.8 + mouseAccu.w * 0.02);\n    vec3 cpos = -cam.Front * cdist;\n   // cpos.y -= 1.0;\n\n    float fId = frameAccu * 1.64683 + 0.84377;\n    \n    vec3 pxId  = vec3(frameAccu, uv); \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n    \n    {\n        vec2 off;\n        {\n        \tfloat h0 = Hash(fId, 0xAF609A13u);\n        \tfloat h1 = Hash(fId, 0xE0ABC868u);\n        \n        \t//off = vec2(h0, h1) * 0.5;\n        \toff = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n        }\n                      \n        tex21 = (uv0.xy + off) / PixelCount * 2.0 - vec2(1.0);\n    }\n    \n    vec2 llp = vec2(0.0);// local sample pos on lens\n    if(false)// no DoF\n    {\n        float h0 = HashFlt(hh, 0x27BB116Bu);\n        float h1 = HashFlt(hh, 0x11A95B42u);\n\t\th1 = clamp01(h1 * 0.5 + 0.5);\n\n        llp = Sample_Disk(h0, h1);\n        llp *= 0.005;\n    }\n    \n    vec3 glp;// global sample pos on lens\n    float S1 = cdist - 0.0;// set cube ~sharp\n    vec3 rdir = NewRay(cam, tex21, llp, S1, OUT glp);\n \n    \n    vec2 lightAng = vec2(Pi * 0.4, 0.4 * Pi);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    float lc = 0.9995;\n    vec3 lightp;\n    {\n        float h0 = HashFlt(hh, 0x9E2355B4u);\n        float h1 = HashFlt(hh, 0xDC305E12u);\n        h1 = clamp01(h1 * 0.5 + 0.5);\n        \n        h1 = mix(lc, 1.0, h1);\n        \n        lightp = Sample_Sphere(h0, h1, light);\n    }\n    \n    // tracking monochromatic values per frame here\n    // since for diff color channels rays diverge at interface \n    vec3 colW;\n    {\n        //float h0 = Hash(fId, 0x7F1489B8u);\n        float h0 = HashFlt(hh, 0x7F1489B8u);\n              h0 = clamp01(h0 * 0.5 + 0.5);\n        \n        //float ivals = 4.0;\n        //h0 = (mod(frameAccu, ivals) + h0) / ivals;\n        \n        colW = Sample_PseudoSpectralRGBWeights_Tri(h0);\n    }\n    \n    //light = vec3(0.0, 1.0, 0.0);\n    float pot = 1.0;\n    float val = 0.0;\n    \n    float t = -1.0; vec2 tt;\n    vec3 pos = cpos + glp;\n    vec3 dir = rdir;\n\n    // absorption coefficients\n    vec3 sigma_a_min = vec3(0.01);            \n    vec3 sigma_a_max = vec3(4.0);\n    \n    // scatter coefficient for inner cube\n    float sigma_s = 20.0;\n    float g = 0.5;// asymmmetry parameter\n    \n    float ffp = 0.0;\n    \n\tfloat n2 = 1.01;// real index of refraction of outer cube\n\n    n2 = dot(vec3(1.15, 1.12, 1.10), colW);\n    n2 = dot(vec3(1.2, 1.18, 1.16), colW);\n   // n2 = dot(vec3(1.3083, 1.3111, 1.3163), colW);// ice\n    \n    float E = 3.0 * Pi;\n    \n    vec3 scs = vec3(0.75);//scatter cube scale\n    bool inner = false;\n    \n    bool exit = false;\n    bool scattered = false;\n    \n    \n    vec3 N0, N1, N2;\n    bool hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(1.0), OUT tt, N0, N1) > 0.0;\n    \n\n\tif(hit)\n    {\n        pos += dir * tt.x;\n        \n        vec3 refl, refr;\n        float re;\n        ReflRefrDielectrics(dir, N0, 1.0, n2, refl, refr, re);\n\n        {\n            float h0 = HashFlt(hh, 0x27BB116Bu);\n            float h1 = HashFlt(hh, 0x11A95B42u);\n            h1 = clamp01(h1 * 0.5 + 0.5);\n            h1 = mix(0.999, 1.0, h1);\n\n            refl = Sample_Sphere(h0, h1, refl);//blur out bg\n            \n\t\t\tval += dot(texture(iChannel2, refl).rgb, colW) * re;     \n        \tif(dot(refl, light) > lc) val += E * re;\n        }\n        \n        pot *= 1.0 - re;\n        dir = refr;\n        \n        \n        for(float i = 0.0; i < 64.0; ++i)\n        {\n            hh = Hash(hh);\n            \n            // sample free flight path\n            if(ffp <= 0.0)\n            {\n                float h0 = HashFlt(hh, 0x4EF175A5u);\n                h0 = clamp01(h0 * 0.5 + 0.5);\n                h0 = max(0.0001, h0);\n\n                ffp = -log(h0) / sigma_s;\n            }\n            \n            Intersect_Ray_CubeBackside(pos, dir, vec3(0.0), vec3(1.0), OUT t, N0);\n            bool hi = Intersect_Ray_Cube(pos, dir, vec3(0.0), scs, OUT tt, N1, N2) > 0.0;\n            \n            if(!hi) tt.x = 128.0;\n            \n            float l = min(t, tt.x);\n            \n            if(inner) l = min(l, ffp);\n            \n            \n            vec3 posn = pos + dir * l;\n\n\t\t\tvec3 sigma_a = EvalSigmaA(pos, posn, sigma_a_max, sigma_a_min);   \n\n            pot *= exp(-dot(sigma_a, colW) * l);\n\n\n            pos = posn;\n            \n            if(l == tt.x)\n            {\n                if(inner) ffp -= tt.x;\n                \n                pos -= N1 * 0.001;\n                \n                inner = !inner;\n                \n                continue;\n            }\n            else\n            if(l == t)\n            {      \n                float h0 = HashFlt(hh, 0x2C2E74DAu);\n                h0 = clamp01(h0 * 0.5 + 0.5);\n\n                if(ReflRefrDielectrics(dir, N0, n2, 1.0, h0, OUT dir))\n                {\n                    exit = true;\n\n                    break;\n                }\n                else\n                {                    \n                    continue;\n                }\n            }\n            else\n            //if(inner) implied\n            {        \n                scattered = true;\n                \n                //vec3 a_ss = If(greaterThan(pos, vec3(0.0)), vec3(0.9), vec3(0.2)); \n                //pot *= dot(a_ss, colW);\n                pot *= 0.95;\n                \n                // direct light sampling; mostly ignoring the interface here for simplicity\n                {\n                    float ls;\n                    Intersect_Ray_CubeBackside(pos, lightp, vec3(0.0), scs, OUT ls);\n\t\t\t\t\tls = max(0.0, ls);// meh (fixes errors)\n                    \n                    float phase = HenyeyGreensteinPDF(dot(dir, lightp), g);\n\n                    float la;\n                    Intersect_Ray_CubeBackside(pos, lightp, vec3(0.0), vec3(1.0), OUT la, N0);\n                    \n                    vec3 posn = pos + lightp * la;\n\n\t\t\t\t\tvec3 sigma_a = EvalSigmaA(pos, posn, sigma_a_max, sigma_a_min);   \n\n            \t\tfloat transm = exp(-(dot(sigma_a, colW) * la + sigma_s * ls));\n                    //float transm = exp(-(dot(sigma_a, colW) * la));\n                    //float transm = exp(-(sigma_s * ls));\n                    \n                    //transm *= 1.0 - FresnelDielectrics(lightp, N0, n2, 1.0);\n                    \n                    if(transm > 0.0)// prevents nans for reasons; also had this in HLSL code...\n                        val += pot * phase * transm * E;\n                }\n                \n                \n                // sample scattering direction\n                {\n                    float h0 = HashFlt(hh, 0x874C40D4u);\n                    float h1 = HashFlt(hh, 0xF27BD7E1u);\n                    h1 = clamp01(h1 * 0.5 + 0.5);\n\n                    //dir = Sample_SchlickPhase(h0, h1, 0.6, dir);\n                    dir = Sample_HenyeyGreensteinPDF(h0, h1, g, dir);\n                }  \n            }\n        }\n    }\n\n    \n   // if(false)\n    if(!hit || exit)\n    {\n        float h0 = HashFlt(hh, 0x27BB116Bu);\n        float h1 = HashFlt(hh, 0x11A95B42u);\n\t\th1 = clamp01(h1 * 0.5 + 0.5);\n\t\th1 = mix(0.999, 1.0, h1);\n        \n        dir = Sample_Sphere(h0, h1, dir);//blur out bg\n        \n        val += pot * dot(textureLod(iChannel2, dir, 0.0).rgb, colW);\n        \n        if(!scattered)\n        {\n            if(dot(dir, light) > lc) val += pot * E;\n        }\n    }\n    \n    //if(false)\n    //if(hit && !exit)\n    //{\n    //    col = vec3(1.0, 0.0, 0.0);\n    //}\n    \n    vec3 col = colW * val * PseudoSpectralRGBWeights_Tri_W;\n    \n    \n    vec3 colLast = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    \n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}