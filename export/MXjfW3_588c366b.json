{"ver":"0.1","info":{"id":"MXjfW3","date":"1730047204","viewed":83,"name":"Gold and silver","username":"cesio","description":"Union of sdf obejcts with phong reflection model, merging colours and checkboard-pattern floor.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","phong","union","checkboard"],"hasliked":0,"parentid":"MXjBRt","parentname":"Jelly Gluey Candy"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define EPSILON 0.0005\n#define MIN_DISTANCE 0.0\n#define MAX_DISTANCE 30. \n#define PRECISION 0.01\n#define MERGE_RADIUS 2.1\n#define CAMERA_SPEED 2.6\n\nstruct Material {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float alpha;\n};\n\nMaterial black() {\n  vec3 ambientColor = 0.45 * vec3(0., 0., 0.);\n  vec3 diffuseColor = 0.1 * vec3(0.9);\n  vec3 specularColor = 0.99 * vec3(1, 1, 1);\n  float alpha = 45.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial silver() {\n  vec3 ambientColor = 0.45 * vec3(0.8);\n  vec3 diffuseColor = 0.3 * vec3(0.3);\n  vec3 specularColor = 0.9 * vec3(1, 1, 1);\n  float alpha = 5.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial checkboard(vec3 p) {\n  vec3 ambientColor = 0.35 * vec3(0.3 + 1.*mod((floor(p.x) + floor(p.z)) , 2.0));\n  vec3 diffuseColor =  vec3(0.3);\n  vec3 specularColor = vec3(0.);\n  float alpha = 1.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nstruct Surface {\n    Material m; // material\n    float d; // distance\n};\n\n// return a distance from point p and a sphere with center c and radius r and tm (transform matrix)\nSurface sdSphere(vec3 p, vec3 c, float r, Material m, mat3 tm) {\n    return Surface(m, length(p * tm - c) - r);\n}\n    \n    \n// return a distance from a point p and a floow at a height y (height of which the floor starts)\nSurface sdFloor(vec3 p, float y, Material m) {\n    return Surface(m, p.y + y);\n}\n\n// based on  https://iquilezles.org/articles/distfunctions/\n\nSurface sdTorus(vec3 pr, vec2 t, Material m, mat3 tm) {\n  vec3 p = pr * tm;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Surface(m, length(q)-t.y);\n}\n\n\nSurface minSurface(Surface s1, Surface s2) {\n    Surface res = s1;\n    if (res.d > s2.d) res = s2;\n    return res;\n}\n\n\nSurface roundMerge(Surface surface1, Surface surface2, float radius) {\n    float item1 = surface1.d;\n    float item2 = surface2.d;\n    float touchDistance = abs(item1 - item2);\n    \n    \n    vec2 intersection = vec2(item1 - radius, item2 - radius);\n    intersection = min(intersection, 0.0);\n    float insideDistance = length(intersection);\n    float simpleUnion = min(item1, item2);\n    float outsideDistance = max(simpleUnion, radius);\n    Surface res; res.d = outsideDistance - insideDistance;\n    \n    \n    if (touchDistance >= radius) {\n        if (item1 <= item2) res.m = surface1.m; else res.m = surface2.m;\n    } else {\n        float rr = touchDistance / MERGE_RADIUS;\n        if (surface1.d < surface2.d) {\n            res.m = Material(mix(surface2.m.ambientColor, surface1.m.ambientColor, rr), \n                             mix(surface2.m.diffuseColor, surface1.m.diffuseColor, rr), \n                             mix(surface2.m.specularColor, surface1.m.specularColor, rr), \n                             mix(surface2.m.alpha, surface1.m.alpha, rr));\n        } else {\n            res.m = surface2.m;\n        }\n    }\n    \n\n    return  res;\n}\n\nvec3 multiplyScene(vec3 pr) {\n    // multiply pattern by mod'uling x,y,z coordinates\n    float cx = 0.;\n    float cy = 0.;\n    float cz = 0.;\n    float nx = cx > 0. ? mod(pr.x + 0.5 * cx, cx) - 0.5 * cx : pr.x;\n    float ny = cy > 0. ? mod(pr.y + 0.5 * cy, cy) - 0.5 * cy : pr.y;\n    float nz = cz > 0. ? mod(pr.z + 0.5 * cz, cz) - 0.5 * cz : pr.z;\n    vec3 p = vec3(nx, ny, nz);\n    \n    return p;\n}  \n \nSurface scene(vec3 pr ) {\n    //vec3 pr = multiplyScene(p);\n    float sTime = iTime / 2.;\n/*\n    Surface sphere1 = sdSphere(pr + vec3(cos(sTime * 1.3) * 5.5, 0.0, -5.0), vec3(0.), 1., gold(), identity());\n    Surface sphere2 = sdSphere(pr + vec3(sin(sTime) * 6.5, 0.0, -5.0), vec3(0.), 1., gold(), identity());\n    Surface sphere3 = sdSphere(vec3(pr.x, pr.y + sin(sTime) * 6., pr.z - 5.), vec3(0.), 1., gold(), identity());\n    Surface res = roundMerge(sphere1, sphere2, MERGE_RADIUS);\n    res = roundMerge(res, sphere3, MERGE_RADIUS);\n*/\n    \n    //float tR1 = 3.2;\n    //float tR2 = 3.6;\n    Surface torus1 = sdTorus(vec3(pr.x - 3.2 / 2. + 1.4, pr.y + 2. + cos(sTime) * 4., 2. + pr.z - 3.2 * 2. - iTime * CAMERA_SPEED), vec2(3.8, 0.4), silver(), rotateY(sTime) * rotateX(PI / 4.) * rotateZ(iTime));\n    Surface torus2 = sdTorus(vec3(pr.x - 3.6 / 2. - 3.4, pr.y + 2. + cos(sTime) * 4., 2. + pr.z - 3.6 * 2. - iTime * CAMERA_SPEED), vec2(1.8, 0.2), gold(), rotateY(sTime) * rotateX(PI / 4.) * rotateZ(iTime));\n    Surface torus3 = sdTorus(vec3(pr.x - 3.6 / 2. + 7.4, pr.y + 2. + cos(sTime) * 4., 2. + pr.z - 3.6 * 2. - iTime * CAMERA_SPEED), vec2(1.8, 0.2), gold(), rotateY(sTime) * rotateX(PI / 4.) * rotateZ(iTime));\n    //res = roundMerge(res, torus1, MERGE_RADIUS);\n    Surface res = roundMerge(torus1, torus2, MERGE_RADIUS);\n    res = roundMerge(res, torus3, MERGE_RADIUS);\n    \n    \n    res = roundMerge(res, sdFloor(pr, 1.9, checkboard(pr)), MERGE_RADIUS);\n    return res;\n}\n\n\n// vector normal to sphere with cener c and radius r\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n  return normalize(\n    e.xyy * scene(p + e.xyy).d +\n    e.yyx * scene(p + e.yyx).d +\n    e.yxy * scene(p + e.yxy).d +\n    e.xxx * scene(p + e.xxx).d);\n}\n\n\nstruct RaymarchRes {\n    Surface s;\n    vec3 p; // surface hit point\n    float d; // distance\n};\n\nRaymarchRes raymarch(vec3 ro, vec3 rd, vec3 lightVector) {\n    float t = MIN_DISTANCE; \n    RaymarchRes res;\n    res.d = MAX_DISTANCE;\n        \n    for (int i = 0; i < 155; i++) {\n        vec3 p = ro + t * rd;\n        Surface sf = scene(p); \n        t += sf.d;\n        \n        if (sf.d < PRECISION) { // we hit the surface at point p\n            //vec3 normalToSurfaceVector = calcNormal(p);\n            //res.l = clamp(dot(normalToSurfaceVector, normalize(lightVector - p)), 0.1, 1.);\n            res.p = p;\n            res.s = sf;\n            break;\n        } else if (sf.d > MAX_DISTANCE) break; // we did not hit anything but are to far away from camera \n            //t += sf.d; // we did not hit anything, keep on trying\n    }\n    \n    res.d = t;\n    return res;\n}\n    \nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\n\nvec3 calculateCameraPosition(vec3 lookAt, vec2 uv) {\n    vec3 ro = vec3(0., -0.9, -5. + iTime * CAMERA_SPEED);\n      \n    return ro;\n}\n\nvec3 calculateLightPosition() {\n    // calculate position of the light\n    float lightTime = iTime * 1.;\n    float lightRadius = 2.;\n    vec3 lightVector;\n    lightVector.x = lightRadius * cos(lightTime);\n    lightVector.y = 0.4;\n    lightVector.z = lightRadius * sin(lightTime); \n    \n    lightVector = vec3(-2.0, 2.0, 5.0 +  + iTime);\n    \n    return lightVector;\n}\n\n\nvec3 calculateLight(vec2 fragCoord, RaymarchRes rr, vec3 rd, vec3 lo) {\n    vec3 normalToSurfaceVector = calcNormal(rr.p);\n    vec3 l = normalize(lo - rr.p);\n    \n    // phong reclection\n    vec3 diffusion = clamp(dot(l, normalToSurfaceVector), 0., 1.) * rr.s.m.diffuseColor;\n    float dotRV = clamp(dot(reflect(l, normalToSurfaceVector), -rd), 0., 1.);\n    vec3 specular =  pow(dotRV, rr.s.m.alpha) * rr.s.m.specularColor;\n    \n    vec3 color = rr.s.m.ambientColor + diffusion + specular;\n \n    // fog\n    color = mix(color, vec3(0., 0.1, .2), 1.0  - 1.5 * exp(-0.0004 *  rr.d * rr.d * rr.d));\n \n    /*\n    float l = clamp(dot(normalToSurfaceVector, normalize(lo - rr.p)), 0.1, 1.);\n  \n    vec3 bgColor = vec3(0., 0., 0.);\n    \n    // fog\n    vec3 color = mix(l * rr.s.col, bgColor, 1.0  - 1. * exp(-0.0002 *  rr.d * rr.d * rr.d));\n    \n    // sun\n    color += vec3(1., 0.8, 0.6) * pow(clamp(dot(0.5 - lo, 0.5 - rd), 0.0, 1.), 1.0);\n    */\n    \n    // vigniete\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color = vec3(color * pow(20. * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.22));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 lookAt = vec3(0.0,0.0, +2. +  iTime * CAMERA_SPEED);\n\n    vec3 ro = calculateCameraPosition(lookAt, uv);\n    vec3 rd = camera(ro, lookAt) * normalize(vec3(uv, -1.));\n    vec3 lo = calculateLightPosition();\n\n    //vec4 backgroundColor = vec4(mix(vec3(0., 0.1, .2), vec3(0., 0., 0.), uv.y) * 1.6, 1.0);\n    vec4 backgroundColor = vec4(mix(vec3(0., 0.1, .2), vec3(0., 0., 0.), uv.y) * 1.1, 1.0);\n //   vec4 backgroundColor = vec4(mix(vec3(0., 0.0, .5), vec3(0., 0.9, 0.), uv.y * 2.) * 1.1, 1.0);\n    \n    RaymarchRes rr = raymarch(ro, rd, lo);\n    vec3 normalToSurfaceVector = calcNormal(rr.p);\n    fragColor = (rr.d < MAX_DISTANCE) ? vec4(calculateLight(fragCoord, rr, rd, lo), 1.0) : backgroundColor;    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// credits: https://www.shadertoy.com/view/MtsGWH \n// \"p\" point apply texture to\n// \"n\" normal at \"p\"\n// \"k\" controls the sharpness of the blending in the\n//     transitions areas.\n// \"s\" texture sampler\nvec4 boxmap( in sampler2D s, in vec3 p, in vec3 n, in float k )\n{\n    // project+fetch\n\tvec4 x = texture( s, p.yz );\n\tvec4 y = texture( s, p.zx );\n\tvec4 z = texture( s, p.xy );\n    \n    // and blend\n    vec3 m = pow( abs(n), vec3(k) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\n\n","name":"Common","description":"","type":"common"}]}