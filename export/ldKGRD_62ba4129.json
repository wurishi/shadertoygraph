{"ver":"0.1","info":{"id":"ldKGRD","date":"1453812237","viewed":439,"name":"Colored glass lamp","username":"TambakoJaguar","description":"When I was kid, my grandparents used to have such a lamp in their house. Or at least this is the way I remember about it, it's been such a long time ago.\nI could experiment a lots of things here, like the pre-calculated height/color map.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","reflection","refraction","glass","heightmap","lamp","bulb","coloredglass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Glass Lamp\" by Emmanuel Keller aka Tambako - January 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// Much code adapted from https://www.shadertoy.com/view/Xds3zN, thanks iq to let us use it! :)\n\n#define pi 3.141593\n\n// Switches, you can play with them!\n#define metal_rings\n#define supports\n#define bulb\n//#define shadow\n#define reflections\n//#define ambocc\n#define specular\n//#define show_lamp_texture\n//#define show_not_finished\n#define lamp_is_glass;\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \nLamp lamps[3];\n\n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define LAMPG_OBJ       1\n#define METALRINGS_OBJ  2\n#define BULB_OBJ        3\n#define SUPPORTS_OBJ    4\n\nconst vec2 lampsize = vec2(1.5, 1.8);\n\n// Campera options\nvec3 campos;\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir;\nfloat fov = 5.;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.05;\n\n// Shading options\nconst float specint = 0.45;\nconst float specshin = 12.;\nconst float aoint = 0.5;\nconst float shi = 0.85;\nconst float shf = 0.4;\n\n// Tracing options\nconst float normdelta = 0.005;\nconst float maxdist = 20.;\nconst int nbref = 2;\nconst int nbrefr = 6;\nconst float glass_ior = 1.5;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.6;\nconst int aasamples = 1;\n\n// 1D hash function\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\n// 2D hash function\nvec2 hash2( vec2 n ){\n\treturn fract(vec2(sin(n.x)*3538.5453, sin(n.y)*2753.8256));\n}\n\n// Union operation from iq\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Difference operation from iq\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// Rotates the position vector in function of the position of the mouse\nvec3 rotateVec2(vec3 posr)\n{\n    float angle = -2.*pi*(iMouse.x/iResolution.x - 0.5);\n    float angle2 = -1.3*pi*(iMouse.y/iResolution.y - 0.42);    \n    \n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\n// Gets the bump of the glass part of the lamp\nfloat getLampBump(vec2 uv)\n{\n    return sqrt(smoothstep(0.07, 0.97, texture(iChannel0, uv).a));\n}\n\n// Gets the color of the glass part of the lamp\nvec3 getLampColor(vec2 uv)\n{\n    return mix(texture(iChannel0, uv).rgb, vec3(0.8), smoothstep(texture(iChannel0, uv).a, 0.07, 1.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\n// Converts the position in the world to the 2D mapping coordinates of the texture of the lamps (Buf C)\nvec2 getLampMPos(vec3 pos)\n{\n    return vec2(atan(pos.x, pos.z)/(2.*pi) + 0.5, pos.y/(lampsize.y*2.) + 0.5);\n}\n\n// Distance mapping of the bounding cylinder of the lamp\nfloat map_s(vec3 pos)\n{\n    vec3 posr = rotateVec2(pos);\n    posr.y-= 0.45;\n    return sdCylinder(posr, lampsize*vec2(1.2, 1.37));\n}\n\n// Distance mapping of the glass part of the lamp\nfloat map_lampg(vec3 pos)\n{\n    vec2 hmp = getLampMPos(pos);\n    float hm = 0.5*getLampBump(hmp)*\n               smoothstep(1.12, 0.93, length(pos.y)/lampsize.y)*\n               smoothstep(0.91, 0.97, length(pos.xz)/lampsize.x);\n    return opS(sdCylinder(pos, lampsize), sdCylinder(pos, lampsize*vec2(0.86, 1.5))) - hm;\n}\n\n// Distance mapping of the bulb\nfloat map_bulb(vec3 pos)\n{\n    pos.y*=0.6;\n    return length(pos) - 0.65;\n}\n\n// Distance mapping of the metal rings\nfloat map_metalrings(vec3 pos)\n{\n    pos.y = abs(pos.y);\n    pos.y-= lampsize.y + 0.08;\n    pos.y*= 2.2;\n    \n    return sdTorus(pos, vec2(lampsize.x*.93, 0.2));\n}\n\n// Distance mapping of the supports, socket, cable...\nfloat map_supports(vec3 pos)\n{\n    vec3 mpos1 = pos.yxz;\n    vec3 mpos2 = mpos1;\n    mpos2.yz = rotateVec(mpos2.yz, 2.*pi/3.);\n    vec3 mpos3 = mpos1;\n    mpos3.yz = rotateVec(mpos3.yz, 4.*pi/3.);\n    return min(min(min(min(sdCylinder(pos - vec3(0., 1., 0.), vec2(0.45, 0.35)),                    // Socket\n                           sdCylinder(pos - vec3(0., 1.4, 0.), vec2(0.08, 1.4))),                   // Cable\n                           sdCylinder(mpos1 - vec3(lampsize.y, 0., 0.), vec2(0.044, lampsize.x))),  // Suport 1/3\n                           sdCylinder(mpos2 - vec3(lampsize.y, 0., 0.), vec2(0.044, lampsize.x))),  // Suport 1/3\n                           sdCylinder(mpos3 - vec3(lampsize.y, 0., 0.), vec2(0.044, lampsize.x)));  // Suport 1/3\n}\n\n// Combines all the distance fields\nvec2 map(vec3 pos)\n{\n    vec3 posr = rotateVec2(pos);\n    //return vec2(map_s(posr), LAMPG_OBJ);\n    #ifdef bulb\n    vec2 res = opU(vec2(map_lampg(posr), LAMPG_OBJ),\n                   vec2(map_bulb(posr),  BULB_OBJ));\n    #else\n    vec2 res = vec2(map_lampg(posr), LAMPG_OBJ);\n    #endif\n    #ifdef metal_rings\n    res = opU(res, vec2(map_metalrings(posr),  METALRINGS_OBJ));\n    #endif\n    #ifdef supports\n    res = opU(res, vec2(map_supports(posr),  SUPPORTS_OBJ));\n    #endif\n    return res;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside, bool bounding) \n{\n    float t = 1.6;\n    float objnr = 0.;\n     \n    if (bounding)\n    {\n        for (int i = 0; i <8 ; ++i)\n        {\n            vec3 pos = ray*t + cam;\n            float res = map_s(pos);\n            float dist = res;\n            if (dist>maxdist || abs(dist)<0.001)\n                break;\n            t+= dist*1.07;\n        }\n    }\n    \n  \tfor (int i = 0; i < 40; ++i)\n    {\n    \tvec3 pos = ray*t + cam;\n        vec2 res = inside?-map(pos):map(pos);\n    \tfloat dist = res.x;\n        if (dist>maxdist || abs(dist)<0.00004)\n            break;\n        t+= dist*0.91;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec2 q = vec2(0, e);\n    return (inside?-1.:1.)*normalize(vec3(map(pos + q.yxx).x - map(pos - q.yxx).x,\n                          map(pos + q.xyx).x - map(pos - q.xyx).x,\n                          map(pos + q.xxy).x - map(pos - q.xxy).x));\n}\n\n// Gets the color of the lamp for given position\nvec3 lampg_color(vec3 pos)\n{\n    //vec3 posr = rotateVec2(pos);\n    vec2 hmp = getLampMPos(pos);\n    //vec3 lc = mix(vec3(1.), getLampColor(hmp), smoothstep(0.91, 0.97, length(posr.xz)/lampsize.x));\n    return getLampColor(hmp);\n}\n\n// Gets the color of the bulb\nvec3 bulb_color(vec3 ray)\n{\n    return vec3(0.8, 0.6, 0.3);\n}\n\n// Gets the color of the metal rings\nvec3 metalrings_color(vec3 ray)\n{\n    return vec3(0.6, 0.4, 0.2);\n}\n\n// Gets the color of the metal supports\nvec3 supports_color(vec3 ray)\n{\n    return vec3(0.1);\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n\tvec3 rc = 1.5*texture(iChannel1, ray).rgb;\n    return rc;\n}\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr)\n{\n   #ifdef lamp_is_glass\n   vec3 lampcol = vec3(0);\n   #else\n   vec3 lampcol = lampg_color(rotateVec2(pos));\n   #endif\n   return objnr==LAMPG_OBJ?lampcol:(\n          objnr==BULB_OBJ?bulb_color(pos):(\n          objnr==METALRINGS_OBJ?metalrings_color(pos):(\n          objnr==SUPPORTS_OBJ?supports_color(pos):sky_color(pos))));\n}\n\n// Gets the flares of the lamps (kind of non-reflective specular...)\nvec3 getFlares(vec3 ray)\n{\n\tvec3 rc = vec3(0.);\n    #ifdef bulb\n    rc+= 1.6*clamp(normalize(lamps[1].color)*lamps[1].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[1].position - campos))), 150.), 0., 1.);\n    #endif\n    return rc;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN, but I changed the code\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<50; i++)\n    {\n    \tfloat h = map(ro + rd*t).x;\n        res = min( res, 10.0*h/t + 0.02*float(i));\n        t += 0.8*clamp( h, 0.01, 0.35 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 5;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map(p + rd.x).x) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);\n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = objnr==BULB_OBJ?ocol:ocol*lamp.color*lamp.intensity*smoothstep(-0.1, 1., dot(norm, pli));\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= objnr==BULB_OBJ?vec3(0.):lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(vec3(lamp.position.x, 4.9, lamp.position.z) - pos), shf, 100.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{   \n    campos = vec3(0., 5., 14.);\n    camdir = camtarget-campos;   \n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside, bool bounding)\n{\n    vec2 tr = trace(tpos, ray, maxdist, inside, bounding);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    lamps[0] = Lamp(vec3(-2., 5., 20.), vec3(1., 1., 1.), 1.8, 0.01);\n    lamps[1] = Lamp(vec3(0., 0, 0.), vec3(1., .95, .75), 0.9, 0.01);\n    lamps[2] = Lamp(vec3(16., 3., -8.), vec3(1., .4, .4), 0.7, 0.01);\n    \n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        col = getColor(norm, pos, objnr);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm, 7., 1.1));\n        //col = vec3(calcAO(pos, norm, 7., 1.1));\n        #endif\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Gets the light darkening of the glass in function of the color and thickness\nvec3 getGlassDens(vec3 pos, vec3 ray)\n{\n    vec3 posr = rotateVec2(pos);\n    vec3 glasscol = lampg_color(posr);\n    vec2 hmp = getLampMPos(posr);\n    float cgh = 0.4 + 1.7*getLampBump(hmp)/abs(ray.z);\n    return pow(glasscol, 0.35 + 2.6*vec3(pow(cgh, 3.)));\n}\n\n// Main render function with reflections\nvec4 render(vec2 fragCoord)\n{   \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \n  RenderData traceinf = trace0(campos, ray, maxdist, false, true);\n  vec3 col = traceinf.col + getFlares(ray);\n  #ifdef reflections\n  float r = 1.;\n  for (int i=0; i<nbref; i++)\n  {\n  \t  if (traceinf.objnr==METALRINGS_OBJ)\n      {\n          vec3 refray = reflect(ray, traceinf.norm);\n          RenderData traceinf_ref = trace0(traceinf.pos, refray, 20., false, true);\n          col = mix(col, col*traceinf_ref.col, 0.77);\n          ray = refray;\n          traceinf = traceinf_ref;\n      }\n  }\n  #ifndef lamp_is_glass\n  return vec4(col, 1.0);\n  #endif\n  bool inside = true;\n  float cior = glass_ior;\n  vec3 cdens;\n  vec3 glassf = vec3(1.);\n  if (traceinf.objnr==LAMPG_OBJ)\n  {\n  \t\tvec3 norm = traceinf.norm;\n        vec3 ray_r = refract(ray, traceinf.norm, 1./glass_ior);\n        vec3 ray_r2;\n        \n        //return vec4(cdens, 0.);\n        int n2;\n        for (int n=0; n<nbrefr; n++)\n        {\n            vec3 posr = rotateVec2(traceinf.pos);\n            if (length(posr.xz)>lampsize.x*0.98) cdens = getGlassDens(traceinf.pos, ray);\n        \ttraceinf = trace0(traceinf.pos, ray_r, 20., inside, false);\n            if (length(posr.xz)<=lampsize.x*0.98) cdens = getGlassDens(traceinf.pos, ray);\n                \n            if (inside)\n                glassf*= cdens;\n            else\n                traceinf.col+= getFlares(ray_r);\n            if (traceinf.objnr==METALRINGS_OBJ)\n            {\n                vec3 refray = reflect(ray, traceinf.norm);\n                col+= glassf*mix(col, traceinf.col*sky_color(refray), 0.5);\n            }\n            else\n               col+= traceinf.col*glassf;\n            col = clamp(col, 0., 1.15);\n            \n            if (traceinf.objnr==LAMPG_OBJ)\n            {\n      \t\t    ray_r2 = refract(ray_r, traceinf.norm, cior);\n        \t    if (length(ray_r2)!=0.)\n                {\n                    inside = !inside;\n                    cior = 1./cior;\n                }\n                else\n                    ray_r2 = reflect(ray_r, traceinf.norm);\n            }\n            else\n                break;\n            ray_r = ray_r2;\n            n2 = n;\n        }\n        if (n2==nbrefr-1)\n            #ifdef show_not_finished\n            col = vec3(1., 0., 1.);\n      \t\t#else\n            col+= sky_color(ray_r2)*glassf;\n      \t\t#endif\n                      \n        // Outer reflection\n        #ifdef reflections\n        float r = clamp(1.1*fresnel(ray, norm, glass_ior), 0., 1.);\n        col = mix(col, sky_color(reflect(ray, norm)), r);\n        #endif\n  }\n  #endif\n\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    \n    // Antialiasing.\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    #ifdef show_lamp_texture\n    fragColor = vec4(3.5*getLampBump(uv)*getLampColor(uv), 0);\n    #else\n    fragColor = vs/vec4(aasamples*aasamples);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 lss = vec2(7., 3.1);\n\nfloat hash( float n )\n{\n    return fract(sin(n)*753.5453123);\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise2(vec3 pos)\n{\n    vec3 q = 8.0*pos;\n    float f  = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); q = m*q*2.02;\n    f += 0.1250*noise( q ); q = m*q*2.03;\n    f += 0.0625*noise( q ); q = m*q*2.01;\n    return f;\n}\n\nvec4 voronoi(vec2 x, float rp)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n    float id = 0.0;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( mod(n + g, rp) );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            id = dot(mod(n + g, rp), vec2(7.,41.));\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( mod(n + g, rp) );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4(md, mr, id);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y-= 0.1;\n    \n    float noiseh = noise2(vec3(0.26*uv*lss + vec2(0., 0.3), 1.)*0.9);\n    //float noiseh = noise2(vec3(0.26*uv*lss + vec2(0., 0.3), 0.2*iTime)*0.9);\n    uv+= 0.08*(noiseh - vec2(0.5));\n    vec4 vorv = voronoi(uv*lss, lss.x);\n    //float bumpheight = 0.4*vorv.x*(1. + 1.8*noiseh) + 0.1*noiseh - 0.04;\n    float bumpheight = 0.85*vorv.x;\n    \n    vec3 vorc;\n    if (mod(vorv.w, 4.)==0.) vorc = vec3(0.8, 0.1, 0.1);\n    if (mod(vorv.w, 4.)==1.) vorc = vec3(0.02, 0.7, 0.15);\n    if (mod(vorv.w, 4.)==2.) vorc = vec3(0.1, 0.2, 0.8);\n    if (mod(vorv.w, 4.)==3.) vorc = vec3(0.75, 0.75, 0.05);\n    \n    fragColor = vec4(vorc, bumpheight);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int blur_size = 4;\nconst float blur_width = .9;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)/e); \n}\n\n// Horizontal blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy / iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(x2/iResolution.x, 0.);\n       float g = gauss(x2, float(20*blur_size)*0.5);\n       pixval+= g*texture(iChannel0, mod(ipos, vec2(1.)));\n       tot+= g;\n   }\n   fragColor = pixval/tot;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int blur_size = 4;\nconst float blur_width = .9;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)/e); \n}\n\n// Vertical blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy / iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(0., x2/iResolution.x);\n       float g = gauss(x2, float(20*blur_size)*0.5);\n       pixval+= g*texture(iChannel0, ipos);\n       tot+= g;\n   }\n   fragColor = pixval/tot;\n}","name":"Buf C","description":"","type":"buffer"}]}