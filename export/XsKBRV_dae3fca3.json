{"ver":"0.1","info":{"id":"XsKBRV","date":"1529603332","viewed":317,"name":"Raytracing Chromatic Aberration","username":"noxbuds","description":"This is my first shader which calculates an intersection with the scene rather than doing raymarching. To go along with it I thought I'd try make some kind of chromatic aberration/out of focus effect with refraction. Ended up quite well I think.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Experimenting with raytracing. Likely lots  //\n//  of optimisations I can make; I'll improve   //\n//  this over time...                           //\n//                                              //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Bloom and a bit of anti-aliasing in reflections\n// and stuff. Comment out to disable it.\n#define BLOOM\n\n// Look in Buf A to change the IOR of the colours\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Burgess tonemapping - looks fairly bright/cheerful, has quite\n// a bit of contrast aswell\nvec3 burgess(vec3 col)\n{\n    vec3 maxCol = max(vec3(0.0), col - 0.004);\n    vec3 retCol = (maxCol * (6.2 * maxCol + 0.05)) / (maxCol * (6.2 * maxCol + 2.3) + 0.06);\n    return pow(retCol, vec3(1.0 / 2.2));\n}\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Shift the co-ordinates to -1 <= x <= 1\n    // and correct the aspect ratio\n    //uv = uv * 2.0 - 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Grab colour from Buf A\n    col = texture(iChannel0, uv).rgb;\n    \n    #ifdef BLOOM\n    // Add some bloom\n    for (float xOff = -10.0; xOff <= 10.0; xOff++)\n    {\n        for (float yOff = -10.0; yOff <= 10.0; yOff++)\n        {\n            // Distance multiplier\n            float falloff = min(0.1 / length(vec2(xOff, yOff)), 1.0);\n            \n            // Get colour\n            vec3 ncol = texture(iChannel0, (fragCoord + vec2(xOff, yOff)) / iResolution.xy).rgb;\n            \n            float bright = ncol.r * 0.2126 + ncol.g * 0.7152 + ncol.b * 0.0722;\n            \n            // Check if it's the bloom colour\n            col = mix(col, ncol, (falloff - 0.01) * pow(bright, 2.0));\n        }\n    }\n    #endif\n    \n    // Tonemapping to make the scene look better\n    col = pow(col, vec3(2.2));\n    col = burgess(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Experimenting with raytracing. Likely lots  //\n//  of optimisations I can make; I'll improve   //\n//  this over time...                           //\n//                                              //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.14159\n\n// Lighting data\nvec3 lightDir = normalize(vec3(-0.4, -0.6, 0.4));\nvec3 ambientLight = vec3(0.1, 0.2, 0.3);\n\n// Change these to change how the refracted image looks\n#define IOR_R 1.0 / 1.10\n#define IOR_G 1.0 / 1.12\n#define IOR_B 1.0 / 1.14\n\n/////////////////////////////////////////////////\n//                                             //\n//             OBJECT DATA TYPES               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Sphere\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n};\n    \n// Cube\nstruct Cube\n{\n    vec3 pos;\n    vec3 dim;\n};\n\n/////////////////////////////////////////////////\n//                                             //\n//                   SCENE                     //\n//                                             //\n/////////////////////////////////////////////////\n\n// Objects\nSphere Sphere_1;\nSphere Sphere_2;\n\n// Initialises the properties of each object\nvoid buildScene()\n{\n    // Setup the first sphere\n    Sphere_1.pos = vec3(0.0, 1.0, 0.0);\n    Sphere_1.radius = 1.0;\n    \n    // Setup the second sphere\n    Sphere_2.pos = vec3(0.75, 1.0, 2.0);\n    Sphere_2.radius = 1.0;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//           INTERSECTION FUNCTIONS            //\n//                                             //\n/////////////////////////////////////////////////\n\n// Sphere intersection\nfloat iSphere(Sphere sph, vec3 ro, vec3 rd)\n{\n    // move the sphere position\n    ro = ro - sph.pos;\n    \n    // intersection math\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - sph.radius * sph.radius;\n    float h = b * b - 4.0 * c;\n    if (h < 0.0) return -1.0;\n    float t = (-b - sqrt(h)) / 2.0;\n    return t;\n}\n\n// Cube intersection\n//float iBox(Cube cube\n\n// Plane intersection\nfloat iPlane(vec3 ro, vec3 rd, float h)\n{\n    return -ro.y / rd.y - h;\n}\n\n// Sphere normal\nvec3 nSphere(vec3 o, Sphere sph)\n{\n    return (o - sph.pos) / sph.radius;\n}\n\n// Plane normal\nvec3 nPlane(vec3 p)\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\n// Returns a material ID for shading.\nvec2 intersect(vec3 o, vec3 r)\n{\n    // Base hit data\n    vec2 v = vec2(1000.0, 0.0);\n    \n    // Draw a sphere\n    float sphere = iSphere(Sphere_1, o, r);\n    \n    // Draw another sphere\n    float sphere2 = iSphere(Sphere_2, o, r);\n    \n    // Draw a plane\n    float plane = iPlane(o, r, 0.0);\n    \n    // Check which is closer\n    if (sphere > 0.0)\n    {\n        v.x = sphere;\n        v.y = 1.0;\n    }\n    if (plane > 0.0 && sphere < 0.0 && sphere2 < 0.0)\n    {\n        v.x = plane;\n        v.y = 2.0;\n    }\n    if (sphere2 > 0.0 && sphere < 0.0)\n    {\n        v.x = sphere2;\n        v.y = 3.0;\n    }\n    \n    // Return the hit data\n    return v;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              LIGHTING/SHADING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Diffuse\nvec3 diffuse(vec3 col, vec3 n)\n{\n    // Diffuse multiplier\n    float diff = clamp(max(dot(-lightDir, n), 0.0), 0.0, 1.0);\n    \n    // Combine the two\n    return col * diff;\n}\n\n// Calculates hard shadows\n// Can't figure out how to do these as soft shadows...\nfloat shadow(vec3 p)\n{\n    // Calculate hit data\n    vec2 hit = intersect(p, -lightDir);\n    \n    // If we hit anything, return 0\n    if (hit.y > 0.0 && hit.x > 0.001)\n        return 0.5;\n    else\n        return 1.0;\n}\n\n// Creates a checkered pattern\nvec3 checker(vec2 p, vec3 col)\n{\n    // Calculate cell co-ordinates\n    vec2 c = (p - mod(p, 2.0)) / 2.0;\n\n    // Result of mod\n    float modx = mod(c.x, 2.0);\n    float mody = mod(c.y, 2.0);\n\n    // Create the chess-board-style texture\n    if (modx < 0.05 && mody > 0.05)\n        col *= 0.5;\n    if (modx > 0.05 && mody < 0.05)\n        col *= 0.5;\n    \n    // Return the colour\n    return col;\n}\n\n// Calculates a colour\nvec3 material(float id, vec3 p, out vec3 n, vec3 r, out bool hitDiffuse)\n{\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Only colour in if we hit something\n    if (id == 1.0)\n    {\n        // The sphere\n        \n        // Calculate normal\n        n = nSphere(p, Sphere_1);\n        \n        // Base colour\n        vec3 bcol = vec3(0.0, 0.5, 0.35);\n        \n        // Ambient light\n    \tfloat amb = 0.5 + 0.5 * n.y;\n    \tvec3 ambCol = amb * ambientLight;\n        \n        // Diffuse shading\n        vec3 diff = diffuse(bcol, n) + ambCol;\n        \n        // Specular highlights\n        vec3 refLight = normalize(reflect(-lightDir, n));\n        float spec = max(dot(r, refLight), 0.0);\n        vec3 specular = vec3(0.0);\n        \n        // Create a specular highlight colour\n        spec = pow(spec, 8.0);\n        specular = vec3(ambientLight * 1.0 * spec);\n        \n        // Add the diffuse and specular parts\n        col = diff + spec;\n    }\n    else if (id == 2.0)\n    {\n        // The plane (floor)\n        \n        // Note: Made it diffuse because the refractions\n        // weren't quite working right in the reflections...\n        \n        // Calculate normal\n        n = nPlane(p);\n        \n        // Base colour\n        vec3 bcol = vec3(0.2, 0.6, 0.9);\n        \n        // Create a pattern\n        bcol = checker(p.xz, bcol);\n        //bcol = texture(iChannel1, p.xz * 0.2).rgb;\n        \n        // Lighting\n        col = diffuse(bcol, n);\n    }\n    else if (id == 3.0)\n    {\n        // The sphere\n        \n        // Calculate normal\n        n = nSphere(p, Sphere_2);\n        \n        // Base colour\n        vec3 bcol = vec3(1.0, 0.1, 0.0);\n        \n        // Ambient light\n    \tfloat amb = 0.5 + 0.5 * n.y;\n    \tvec3 ambCol = amb * ambientLight;\n        \n        // Diffuse shading\n        vec3 diff = diffuse(bcol, n) + ambCol;\n        hitDiffuse = true;\n        \n        // Add the diffuse and specular parts\n        col = diff ;\n    }\n    \n    // Return colour\n    return col;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Calculates the brightness of a colour\nfloat calcBrightness(vec3 col)\n{\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722;\n}\n\n// Image composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup UV co-ordinates and correct them\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Normalised mouse position\n    vec2 mp = iMouse.xy / iResolution.xy;\n    mp = (mp * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Setup the scene\n    buildScene();\n    \n    // Ray stuff\n    vec3 o = vec3(mp.x * 3.0, 1.5, mp.y * 3.0 - 4.0);\n    vec3 r = normalize(vec3(uv, 0.58 * PI));\n    \n    // Setup pixel colour\n\tvec3 col = vec3(0.0);\n    \n    // Max ray bounces\n    int maxBounces = 6;\n    float bounces = 0.0;\n    \n    // Bounce the ray a few times\n    for (int rn = 0; rn < maxBounces; rn++)\n    {\n        // Calculate number of bounces\n        bounces = float(rn);\n        \n        // Calculate hit data\n        vec2 hit = intersect(o, r);\n    \n        // Get the properties with better names\n        float t = hit.x;\n        float id = hit.y;\n\n        // Setup position\n        vec3 p = o + r * (t + 0.001);\n\n        // Setup normal\n        vec3 n;\n\t\t\n        // Get material data\n        bool hitDiffuse = false;\n        vec3 fcol = material(id, p, n, r, hitDiffuse);\n\n        // Calculate shadows\n        fcol *= shadow(p);\n        \n        // Calculate fresnel multiplier\n        float fresnel = mix(1e-3, 1.0, pow(dot(-r, n), 2.0));\n        \n        // Refraction stuff\n        vec3 refCol = vec3(0.0);\n        if (id == 1.0)\n        {\n            // Unimportant extra boolean\n            bool rDiff = false;\n            bool gDiff = false;\n            bool bDiff = false;\n            \n            // Red light\n            vec3 rRed = refract(r, n, IOR_R);\n            vec2 hRed = intersect(p, rRed);\n            vec3 nRed;\n            vec3 pRed = p + rRed * (hRed.x + 0.001);\n            float red = material(hRed.y, pRed, nRed, rRed, rDiff).r;\n            \n            // Green light\n            vec3 rGreen = refract(r, n, IOR_G);\n            vec2 hGreen = intersect(p, rGreen);\n            vec3 nGreen;\n            vec3 pGreen = p + rGreen * (hGreen.x + 0.001);\n            float green = material(hGreen.y, pGreen, nGreen, rGreen, gDiff).g;\n            \n            // Blue light\n            vec3 rBlue = refract(r, n, IOR_B);\n            vec2 hBlue = intersect(p, rBlue);\n            vec3 nBlue;\n            vec3 pBlue = p + rBlue * (hBlue.x + 0.001);\n            float blue = material(hBlue.y, pBlue, nBlue, rBlue, bDiff).b;\n            \n            // Create the colour\n            red *= shadow(pRed);\n            green *= shadow(pGreen);\n            blue *= shadow(pBlue);\n            refCol += vec3(red, green, blue);\n            \n            // Make some cubemap reflections in the\n            // refracted image so we don't make it\n            // look silly by having plain colours,\n            // but we don't end up having to repeat\n            // loads or create a recursive function\n            \n            // Red light\n            if (!rDiff)\n            {\n            \trRed = reflect(rRed, nRed);\n            \tred = texture(iChannel0, rRed).r;\n                red *= shadow(pRed);\n                refCol.r += red * 0.4;\n            }\n            \n            // Green light\n            if (!gDiff)\n            {\n                rGreen = reflect(rGreen, nGreen);\n                green = texture(iChannel0, rGreen).g;\n                green *= shadow(pGreen);\n                refCol.g += green * 0.4;\n        \t}\n            // Blue light\n            if (!bDiff)\n            {\n                rBlue = reflect(rBlue, nBlue);\n                blue = texture(iChannel0, rBlue).b;\n                blue *= shadow(pBlue);\n                refCol.b += blue * 0.4;\n            }\n            \n            // Add the refracted colour on\n            //col += mix(refCol, fcol, fresnel);\n            col += mix(refCol, fcol, 1.0 - fresnel);\n        }\n        // Add the reflections\n        else col += fcol;// rn == 0 ? fcol : mix(fcol, col, fresnel);\n        \n        // Shift the position and stuff\n        if (id > 0.0 && hit.x > 0.002)\n        {\n            // Change origin and reflect ray\n        \to = p;\n        \tr = reflect(r, n);\n            \n            // If we hit a diffuse object, stop\n            if (hitDiffuse)\n                break;\n        }\n        else\n        {\n            fcol = texture(iChannel0, r).rgb;\n            col += rn == 0 ? fcol : mix(refCol, fcol, 1.0 - fresnel);\n            break;\n        }\n    }\n    \n    // Normalise the colour\n    col /= bounces + 1.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}