{"ver":"0.1","info":{"id":"mdyXRD","date":"1680783015","viewed":169,"name":"Crosshatched Pumpkin","username":"space928","description":"A little modification of one of my old shaders to add crosshatching.","likes":8,"published":3,"flags":0,"usePreview":1,"tags":["3d","raymarching","sdf","crosshatch","toon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MARCHSTEPS = 128;\nconst float MAX_DIST = 32.;\nconst float EPSILON = 0.01;\nconst vec3 pos = vec3(0.,0.0,-2.5);\nconst vec3 posTime = vec3(0.,0.0,0.);\nconst vec3 lightDir = normalize(vec3(0.5,0.5,-0.9));\nconst float rotRate = .8;\nconst float hatchDensity = 30.;\nconst float hatchThickness = 0.15;\nconst float hatchThicknessMod = 0.2;\nconst float hatchSoftness = 0.3;\nconst float hatchSquiggle = 0.015;\nconst float hatchSquiggleSize = .07;\nconst float pi = 3.1415926535;\n\n//https://iquilezles.org/articles/smin\nvec2 sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\n//https://www.shadertoy.com/view/clB3zc\n#define sfractN(x,w)   min( fract(x)/(1.-(w)), fract(-x)/(w) )\n\nfloat map(vec3 p)\n{\n    //Body\n    vec3 pa = p + vec3(0,sin(iTime*2.)*0.3,0.);\n    pa.y *= 1.1;\n    float angle = atan(pa.x, pa.z);\n    float centreDist = length(pa.xz);\n    float radMod = sin(angle*16.)*0.03;\n    radMod += sin(angle*120.)*0.001;\n    radMod *= (centreDist*centreDist);\n    radMod -= (smoothstep(1.2, -.8, centreDist))*0.5;\n    float d = sdSphere(pa, 1. + radMod);\n    \n    //Stem\n    //Domain bending from:\n    float radMod2 = sin(angle*9.)*0.03;\n    radMod2 += sin(angle*23.)*0.005;\n    radMod2 *= smoothstep(0.02, 0.1, centreDist*centreDist);\n    radMod2 += sin(-pa.x*12.)*0.05+sin(pa.y*5.-1.)*0.03+sin(pa.z*25.)*0.01;\n    d = sminCubic(d, sdVerticalCapsule(pa, 1.1, 0.15+radMod2), 0.1).x;//sminCubic();\n    \n    //Eyes\n    d = max(d, -sdTriPrism(vec3(abs(pa.x),pa.y,pa.z)-vec3(0.3,0.2,-1.), vec2(0.15, 1.5)));\n    \n    //Mouth\n    vec2 c = vec2(sin(0.5), cos(0.5));\n    d = min(d, sdCappedTorus(vec3(pa.x,-pa.y,pa.z)-vec3(0.,-0.2,-0.97), c, 0.35, 0.08));\n    \n    //Floor\n    d = min(d, p.y+.8 + (sfractN(p.x, 0.1) + sfractN(p.z, 0.1))*0.1);\n    \n    return d;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    \n    for( int i=0;i<MARCHSTEPS;i++ ) {\n        vec3 p = o + r * t;\n        \n        float d = map(p);\n        \n        if(t > MAX_DIST) {\n            t = -1.0;\n            break;\n        }\n        \n        t += d;\n    }\n    return t;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nmat3 rotY(float x)\n{\n    float sx = sin(x);\n    float cx = cos(x);\n    return mat3(cx, 0., sx,\n                0., 1., 0.,\n                -sx, 0., cx);\n}\n\n//Random number [0:1] without sine\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*pi*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\n// From: https://www.shadertoy.com/view/4sdGWN\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(map( p + rd ),0.)) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\nconst int hatchLevels = 5;\n\n#define line(x, t, s) smoothstep(t, t + s, abs(x * 2. - 1.))\n#define saturate(x) clamp(x, 0., 1.)\n\nfloat hatch(float x, vec2 uv)\n{\n    float s = texture(iChannel0, uv * hatchSquiggleSize).r * 1.;\n    s += texture(iChannel0, uv * hatchSquiggleSize * 0.5).r * 1.;\n    s += texture(iChannel0, uv * hatchSquiggleSize * 0.25).r * 1.;\n    float s1 = texture(iChannel0, uv * hatchSquiggleSize + vec2(0.1236587, 0.6379)).r * 1.;\n    s1 += texture(iChannel0, uv * hatchSquiggleSize + vec2(0.1236587, -0.6379) * 0.5).r * 1.;\n    s1 += texture(iChannel0, uv * hatchSquiggleSize + vec2(-0.1236587, 0.6379) * 0.25).r * 1.;\n    \n    float t0 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 1.) * 2. - 1.) * hatchThicknessMod);\n    float t1 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 2.) * 2. - 1.) * hatchThicknessMod);\n    float t2 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 3.) * 2. - 1.) * hatchThicknessMod) * 2.;\n    float t3 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 4.) * 2. - 1.) * hatchThicknessMod) * 2.;\n    float t4 = saturate(hatchThickness + (saturate(x * float(hatchLevels+1) - 5.) * 2. - 1.) * hatchThicknessMod) * 2.;\n    \n    float h0 = 1.-line(fract((uv.x + uv.y + s * hatchSquiggle)*hatchDensity), t0, hatchSoftness);\n    float h1 = 1.-line(fract((uv.x - uv.y + s1 * hatchSquiggle)*hatchDensity), t1, hatchSoftness);\n    float h2 = 1.-line(fract((uv.x + uv.y + 0.125 + s * hatchSquiggle)*hatchDensity*2.), t2, hatchSoftness*2.);\n    float h3 = 1.-line(fract((uv.x - uv.y + 0.125 + s1 * hatchSquiggle)*hatchDensity*2.), t3, hatchSoftness*2.);\n    float h4 = 1.;\n    \n    float h = h0 * step(1./float(hatchLevels+1), x);\n    h += h1 * step(2./float(hatchLevels+1), x);\n    h += h2 * step(3./float(hatchLevels+1), x);\n    h += h3 * step(4./float(hatchLevels+1), x);\n    h += h4 * step(5./float(hatchLevels+1), x);\n    \n    return saturate(h);\n}\n\n// Fragpos, surface normal, ray direction, ray depth\nvec3 shadeGBuff(vec3 p, vec3 n, vec3 d, float t, vec2 uv)\n{\n    vec3 col = mix(vec3(0.8, 0.9, 1.), vec3(0.5, 0.6, 1.), abs(saturate(d.y*2.)));\n    if(t != -1. && t < MAX_DIST)\n    {\n        float fog = 1.0 / (1.0 + t * t * 0.05);\n        fog = smoothstep(0., 0.9, fog);\n        \n        vec3 ambient = vec3(0.1,0.1,0.15);\n        float ao = saturate(1.-pow(ambientOcclusion(p, n, .5, 0.3), 3.)*1.2);\n        vec3 light = (1.-hatch(ao+pow(1.-saturate(dot(lightDir, n) * 0.4 + 0.6), 1.5), uv)) * vec3(1., .5, .02);\n        float spec = (pow(saturate(dot(normalize(lightDir + d), n)), 2.8));\n        light += (1.-hatch(1.-saturate(spec*2.) + ao*2., uv)) * vec3(1., 0.8, 0.5);\n        \n        col = mix(col, ambient + light, fog);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 r = normalize(vec3(uv, 2.0))*rotY((iTime-10.)*rotRate);\n    vec3 o = pos*rotY((iTime-10.)*rotRate) + (iTime*posTime);\n    float t = trace(o, r);\n    vec3 p = (o+r*t);\n    vec3 nrm = estimateNormal(p);\n\n    vec3 c = shadeGBuff(p, nrm, r, t, uv);\n\n    vec3 dbg = vec3(hatch(uv.x*0.25 + 0.5, uv));\n\n    // Output to screen\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}