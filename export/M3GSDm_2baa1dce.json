{"ver":"0.1","info":{"id":"M3GSDm","date":"1720023596","viewed":103,"name":"Cone Marching Reference","username":"guhcalm","description":"- Pannini Camera;\n- Conne-Marching Scene (Buffer A);\n- Geometry Buffer (Buffer B);\n- Pre-computed Irradiance and BRDF (Buffer C);\n- Render (Buffer D; SSAO + IBL);\n- Tower by snolot: https://www.shadertoy.com/view/ssKcWW","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["brdf","ibl","conemarching","prefilteredirradiance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 PincushionDistortion(vec2 uv, float strength) {\n  vec2 st = uv - 0.5;\n  float uvA = atan(st.x, st.y);\n  float uvD = dot(st, st);\n  return 0.5 + vec2(sin(uvA), cos(uvA)) * sqrt(uvD) * (1.0 - strength * uvD);\n}\nvec3 ChromaticAbberation(vec2 uv, sampler2D sampler) {\n  float amount = .5;\n  return vec3(\n    texture(sampler, PincushionDistortion(uv, 0.3 * amount)).r,\n    texture(sampler, PincushionDistortion(uv, 0.15 * amount)).g,\n    texture(sampler, PincushionDistortion(uv, 0.075 * amount)).b\n  );\n}\n#define ACESFilmic(color) (color * (2.51 * color + .03)) / (color * (2.43 * color + .59) + .14)\n#define Contrast(color) color * color * (3. -2. * color)\n#define HighlightRolloff(color) 1.85 * color / (1. + color)\nvec3 FilmGrain(vec2 uv, vec3 color) {\n  float seed = dot(uv, vec2(12.9898, 78.233));\n  float noise = .7978845608028654 * exp(-(pow(fract(sin(seed) * 43758.5453), 2.) / .5));\n  vec3 grain = vec3(noise) * (1.0 - color);\n  return color + noise * .075;\n}\n#define Vignetting(uv, color) color * (.5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .25))\nvec3 GaussianBlur(vec2 coord) {\n  const int gaussianK[25] = int[25] (1,4,7,4,1, 4,16,26,16,4, 7,26,41,26,7, 4,16,26,16,4, 1,4,7,4,1);\n  vec2 res = iResolution.xy;\n  vec3 col = vec3(0.0);\n  for(int i = 0; i < 5; i++) {\n    for(int ii = 0; ii < 5; ii++) {\n      int s = (i) + (ii);\n      float g = float(gaussianK[s]);\n      col += g * ChromaticAbberation((coord - 3.0 + (vec2(i, ii))) / res, iChannel0);\n     }\n  }\n  return 1.5 * col / 273.;\n}\n\nvoid mainImage(out vec4 Pixel, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 color = ChromaticAbberation(uv, iChannel0);\n  \n  color = Vignetting(uv, color);\n  color = FilmGrain(uv, color);\n  \n  color = GammaCompression(ACESFilmic(GammaExpansion(color)));\n  \n  color = Contrast(color);\n  color = HighlightRolloff(color);\n  \n  Pixel = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Ray { vec3 origin; vec3 direction; };\nstruct Light { vec3 direction; vec3 color; };\nstruct Geometry {\n  vec3 position;\n  vec3 normal;\n  float depth;\n};\nstruct Material {\n  vec3 albedo;\n  float roughness;\n  float metallic;\n  float reflectance;\n};\n\nconst float PI = radians(180.);\nconst float EPSILON = .001;\nconst float NEAR = .001;\nconst float FAR = 100.;\nconst float CONE_SIZE = 100.;\nconst Geometry DEFAULT_GEOMETRY = Geometry(vec3(0), vec3(0), 1.);\nconst Light SUN = Light(normalize(vec3(1, 1, -1)), vec3(1));\n\n\n#define saturate(value) clamp(value, 0., 1.)\n#define GammaExpansion(color) pow(vec3(color), vec3(2.2))\n#define GammaCompression(color) pow(vec3(color), vec3(1. / 2.2))\n#define EncodeVec2(xy) uintBitsToFloat(packHalf2x16(xy))\n#define DecodeVec2(packedFloat) unpackHalf2x16(floatBitsToUint(packedFloat))\n\nfloat time;\nfloat seed;\nfloat random() { return fract(sin(seed += .1) * 4568.7564); }\nfloat random(vec2 uv) { \n seed++;\n return fract(sin(seed+dot(uv, vec2(127.1, 311.7))) * 4568.7564); }\nvec3 RandomVectorOnHemisphere(vec3 normal) {\n  float u = random();\n  float v = random();\n  float a = 6.283185 * v;\n  float b = u * 2. - 1.;\n  vec3 random = vec3(sqrt(1. - b * b) * vec2(cos(a), sin(a)), b);\n  return normalize(random * sign(dot(normal, random)));\n}\n\nvec3 uvToSphere(vec2 uv) {\n  float phi = (uv.x * 2.0 * PI) - PI;\n  float theta = PI * (1.0 - uv.y);\n  float x = sin(theta) * cos(phi);\n  float y = cos(theta);\n  float z = sin(theta) * sin(phi);\n  return vec3(x, y, z);\n}\n\n/* Panini Camera */\nRay Camera(vec2 uv, vec2 mouse, vec2 resolution) {\n  vec2 m = (mouse.xy - .5 * resolution.xy) / resolution.y;\n  float aspect = resolution.x / resolution.y;\n  float theta = - m.x * PI * 2. - 1.5;\n  float phi = - m.y * PI * 2.;\n  vec3 origin = 5.5 * vec3(sin(theta), mix(1., m.y, .7), cos(theta));\n  \n  float focalLength;\n  vec3 target;\n  \n  vec3 ndc = vec3(uv * 2.0 - 1.0, 1.0);\n  const float fov = radians(60.);\n  const vec3 up = vec3(0, 1, 0);\n  float f = tan(fov / 2.0);\n  vec3 screen = vec3(ndc.x * aspect * f, ndc.y * f, ndc.z / f);\n  float d = sqrt(1.0 + screen.x * screen.x + screen.y * screen.y);\n  float u = screen.x / (screen.z + d * focalLength);\n  float v = screen.y / (screen.z + d * focalLength);\n  vec3 paniniScreen = normalize(vec3(u, v, 1.0));  \n  vec3 w = normalize(target - origin);\n  vec3 uAxis = normalize(cross(w, up));\n  vec3 vAxis = normalize(cross(uAxis, w));  \n  \n  vec3 direction = normalize(mat3(uAxis, vAxis, w) * paniniScreen);\n  return Ray(origin, direction);\n}\n\n\n/* SDF's */\nfloat TowerSDF(in vec3 pos) {\n  const float RADIUS = .3492;\n  const float SCALE = 2.04348;\n  const int ITERATIONS = 10;\n  vec3 p = pos * .5;\n  float s = 2.;\n  for (int i; i < ITERATIONS; i++) {\n    p = abs(p);\n    p += vec3(0.0365, -1.8613, 0.0365);\n    float r2 = dot(p, p);\n    float k = clamp(max(RADIUS / r2, RADIUS), 0., 1.);\n\tp *= k;\n    s *= k;\n    p = p * SCALE / RADIUS;\n    s *= abs(SCALE) / RADIUS;\n    p += vec3(-.5, -1.3028, -.5);\n  }\n  return (length(p) - abs(SCALE - 1.0)) / s - pow(abs(SCALE), float(1 - ITERATIONS));\n}\nfloat SDF(in vec3 position) { return TowerSDF(position * .6); }","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Cone-Marching Pass - 100x100 Grid */\n\nfloat ConeMarcher(Ray camera) {\n  float fov = radians(60.);\n  float f = tan(fov / 2.0);\n  float distance;\n  for(int step; step < 100; step++) {\n    if (distance >= FAR) break;\n    float march = SDF(camera.origin + camera.direction * distance);\n    float conne = (distance * f) / CONE_SIZE;\n    if (march < conne * .7) return distance;\n    if (abs(march) <= NEAR) return distance;\n    distance += march;\n    if (distance >= FAR) break;\n  }\n  return FAR;\n}\n\nvoid mainImage(out vec4 DepthLevel1, vec2 fragCoord) {  \n  vec2 uv = (fragCoord.xy / iResolution.xy) * (iResolution.xy / CONE_SIZE);\n  if (uv.x > 1. || uv.y > 1.) discard;\n  \n  Ray camera = Camera(uv, iMouse.xy, iResolution.xy);\n  \n  time = iTime;\n  float distance = ConeMarcher(camera);\n  float depth = clamp(0., FAR, distance) / FAR;\n  \n  DepthLevel1 = vec4(depth);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/* Geometry Buffer */\n\nfloat RayMarcher(Ray camera, float distance) {\n  for(int steps; steps < 100; steps++) {\n    if (distance >= FAR) break;\n    float march = SDF(camera.origin + camera.direction * distance);\n    if (abs(march) <= NEAR) return distance;\n    distance += march * 2.;\n    if (distance >= FAR) break;\n  }\n  return FAR;\n}\n\n#define ConeMarchedDistance(uv) texture(iChannel0, uv / (iResolution.xy / CONE_SIZE)).w * FAR\n\nvoid mainImage(out vec4 GeometryBuffer, in vec2 fragCoord) {\n  time = iTime;\n  vec2 uv = (fragCoord.xy / iResolution.xy);\n\n  Ray camera = Camera(uv, iMouse.xy, iResolution.xy);\n\n  float distance = RayMarcher(camera, ConeMarchedDistance(uv));\n  float depth = clamp(distance, 0., FAR) / FAR;\n  vec3 position = camera.origin + camera.direction * distance;\n  vec2 e = vec2(EPSILON, 0);\n  vec3 normal = normalize(vec3(\n    SDF(position + e.xyy) - SDF(position - e.xyy),\n    SDF(position + e.yxy) - SDF(position - e.yxy),\n    SDF(position + e.yyx) - SDF(position - e.yyx)\n  ));\n  \n  GeometryBuffer = vec4(normal * .5 + .5, depth);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/* BRDF Texture && Irradiance Map*/\n\nfloat RadicalInverse_VdC(uint bits)  {\n  bits = (bits << 16u) | (bits >> 16u);\n  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n  return float(bits) * 2.3283064365386963e-10;\n}\nvec2 Hammersley(uint i, uint N) { return vec2(float(i) / float(N), RadicalInverse_VdC(i)); }\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\n  float a = roughness*roughness;\n\n  float phi = 2.0 * PI * Xi.x;\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n  \n  vec3 H;\n  H.x = cos(phi) * sinTheta;\n  H.y = sin(phi) * sinTheta;\n  H.z = cosTheta;\n\n  vec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\t\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n}\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float a = roughness;\n  float k = (a * a) / 2.0;\n  float nom   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n  return nom / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n  return ggx1 * ggx2;\n}\n\n/* BRDF Map */\n\nvec2 BRDF(vec2 uv) {\n  float NdotV = uv.x;\n  float roughness = uv.y;\n  vec3 V;\n  V.x = sqrt(1.0 - NdotV*NdotV);\n  V.y = 0.0;\n  V.z = NdotV;\n\n  float A = 0.0;\n  float B = 0.0; \n\n  vec3 N = vec3(0.0, 0.0, 1.0);\n    \n  const uint SAMPLE_COUNT = 1024u;\n  for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(L.z, 0.0);\n    float NdotH = max(H.z, 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    if(NdotL > 0.) {\n      float G = GeometrySmith(N, V, L, roughness);\n      float G_Vis = (G * VdotH) / (NdotH * NdotV);\n      float Fc = pow(1.0 - VdotH, 5.0);\n\n      A += (1. - Fc) * G_Vis;\n      B += Fc * G_Vis;\n    }\n  }\n  return vec2(A, B) / float(SAMPLE_COUNT);\n}\n\n\n/* Irradiance Map */\nvec3 Irradiance(vec2 uv) {\n  vec3 normal = uvToSphere(uv);\n  const int STEPS = 600;\n  vec3 color;\n  for (int i; i < STEPS; i++) color += texture(iChannel0, RandomVectorOnHemisphere(normal)).rgb;\n  return color / float(STEPS);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (iFrame > 1) discard;\n  vec2 uv = fragCoord/iResolution.xy;\n  vec3 irradiance = Irradiance(uv);\n  vec2 brdf = BRDF(uv);\n  fragColor = vec4(irradiance, EncodeVec2(brdf));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"Geometry GeometryBuffer(vec2 uv, Ray camera) {\n  vec4 buffer = texture(iChannel0, uv);\n  if (buffer.a == 1.) return DEFAULT_GEOMETRY;\n  vec3 normal = normalize(buffer.xyz * 2. - 1.);\n  float depth = buffer.a;\n  vec3 position = camera.origin + camera.direction * depth * FAR;\n  return Geometry(position, normal, depth);\n}\n\nfloat AmbientOcclusion(vec2 uv, Geometry geometry, float intensity) {\n  const float SCALE = .1;\n  const float BIAS = 0.01;\n  const float DIS_CONSTRAINT = 3.5;\n  \n  Ray camera = Camera(uv, iMouse.xy, iResolution.xy);\n  \n  vec3 diff = GeometryBuffer(uv, camera).position - geometry.position;\n  vec3 v = normalize(diff);\n  float d = length(v) * SCALE;\n  float ao = max(0.0, dot(geometry.normal, v) - BIAS) * (1.0 / (1.0 + d)) * intensity;\n  float l = length(diff);\n  return ao * smoothstep(DIS_CONSTRAINT, DIS_CONSTRAINT * 0.5, l);\n}\n\nfloat SSAO(vec2 uv, Ray camera, Geometry geometry) {\n  const float INTENSITY = 1.;\n  vec2 random = normalize(vec2(random(uv), random(uv)));\n  const vec2 dire[4] = vec2[](vec2(1, 0), vec2(-1, 0), vec2(0, 1), vec2(0,-1));\n  const float SAMPLE_RAD = 0.1;\n  float ssao;\n  int iterations = 4;\n  for(int i; i < iterations; i++) {\n    vec2 coord1 = reflect(dire[i], random) * SAMPLE_RAD;\n    vec2 coord2 = vec2(coord1.x * cos(radians(45.0)) - coord1.y * sin(radians(45.0)), coord1.x * cos(radians(45.0)) + coord1.y * sin(radians(45.0)));\n    ssao += AmbientOcclusion(uv + coord1 * 0.25, geometry, INTENSITY);\n    ssao += AmbientOcclusion(uv + coord2 * 0.5, geometry, INTENSITY);\n    ssao += AmbientOcclusion(uv + coord1 * 0.75, geometry, INTENSITY);\n    ssao += AmbientOcclusion(uv + coord2, geometry, INTENSITY);\n  }\n  ssao = ssao / (float(iterations) * 4.);\n  ssao = 1. - ssao * INTENSITY;\n  return pow(ssao, .1)\n    *  pow(ssao, .5)\n    *  pow(ssao, .7)\n\n    * pow(smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,ssao)))), 4.)\n    * pow(smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,ssao)))))))), 4.)\n    * pow(smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,ssao))), 3.)\n    * pow(smoothstep(0., 1.,smoothstep(0., 1.,ssao)), 2.)\n    * pow(smoothstep(0., 1., ssao), 1.);\n  \n  return pow(ssao, 1.) * pow(smoothstep(0., 1.,ssao), 5.) * pow(smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,ssao)))), 10.);\n  return pow(ssao, 3.) * pow(smoothstep(0., 1.,ssao), 5.) * pow(smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,ssao)))), 10.);\n  return pow(ssao, 5.) * pow(smoothstep(0., 1.,ssao), 5.) * pow(smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,smoothstep(0., 1.,ssao)))), 100.);\n}\n\nvec2 sphereToUv(vec3 direction) {\n  float phi = atan(direction.z, direction.x);\n  float theta = acos(direction.y);\n  float u = (phi + PI) / (2.0 * PI);\n  float v = theta / PI;\n  return vec2(u, 1. - v);\n}\n\n\nvec3 IBL(Ray camera, Geometry geometry, Material material, float ao) {\n  #define Irradiance(normal) (texture(iChannel1, sphereToUv(normal)).rgb)\n  #define Radiance(direction) (texture(iChannel2, direction).rgb)\n  #define BRDF(NdotV, roughness) DecodeVec2(texelFetch(iChannel1, ivec2(vec2(NdotV, roughness) * iResolution.xy), 0).a)\n  vec3 V = -camera.direction;\n  vec3 N = geometry.normal;\n  vec3 R = reflect(-V, N);\n  vec3 albedo = material.albedo;\n  float metallic = clamp(material.metallic, 0., 1.);\n  float roughness = clamp(material.roughness, .1, 1.);\n  float reflectance = material.reflectance;\n  vec3 F0 = mix(vec3(reflectance), albedo, metallic);\n  \n  vec3 irradiance = Irradiance(N);\n  vec3 radiance = Radiance(R);\n  \n  float NdotV = clamp(dot(N, V), 0., 1.);\n  \n  vec2 brdf = BRDF(NdotV, roughness);\n  vec3 fresnel = (F0 * brdf.r + brdf.g);\n  vec3 diffuse = albedo * (irradiance * irradiance + irradiance);\n  vec3 specular = radiance * radiance + radiance;\n  \n  return GammaExpansion(mix(diffuse, specular, fresnel))* ao;\n}\n\nvec3 Environment(vec3 direction) {\n  vec3 color = texture(iChannel2, direction).rgb;\n  return color * color + color;\n}\nvec3 Render(vec2 uv) {\n  Ray camera = Camera(uv, iMouse.xy, iResolution.xy);\n  Geometry geometry = GeometryBuffer(uv, camera);\n  if (geometry.depth == 1.) return Environment(camera.direction);\n  float ao = SSAO(uv, camera, geometry);\n  Material material = Material(vec3(1), 0., 0., .04);\n  return GammaCompression(IBL(camera, geometry, material, ao));\n}\n\nvoid mainImage(out vec4 Shading, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  Shading = vec4(Render(uv), 1);\n}","name":"Buffer D","description":"","type":"buffer"}]}