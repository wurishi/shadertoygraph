{"ver":"0.1","info":{"id":"wdXcWH","date":"1584666685","viewed":145,"name":"simple mandelbr0t","username":"iyadahmed","description":"my first shadertoy ever :)\n\nplease give feedback","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["math","mandelbrot","fractals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//adapted from https://rosettacode.org/wiki/Mandelbrot_set#GLSL\n//more intuitive zoom\nconst int MaxIterations = 512;\nconst vec2 Focus = vec2( -0.7451,  0.1127);\nconst float Zoom = 0.02;\n \nvec3\ncolor(int iteration, float sqLengthZ) {\n    // If the point is within the mandlebrot set\n    // just color it black\n    if(iteration == MaxIterations)\n        return vec3(0.0);\n \n    // Else we give it a smoothed color\n   \tfloat ratio = (float(iteration) - log2(log2(sqLengthZ))) / float(MaxIterations);\n \n    // Procedurally generated colors\n    return mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0), sqrt(ratio));\n}\n \nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord) { \n    \n    // C is the aspect-ratio corrected UV coordinate.\n    vec2 c = (-1.0 + 2.0 * fragCoord / iResolution.xy) * vec2(iResolution.x / iResolution.y, 1.0);\n \n    // Apply scaling, then offset to get a zoom effect\n    c = ((c - Focus) * Zoom)+ Focus;\n\tvec2 z = c;\n \n    int iteration = 0;\n \n    while(iteration < MaxIterations) {\n        // Precompute for efficiency\n   \t\tfloat zr2 = z.x * z.x;\n        float zi2 = z.y * z.y;\n \n        // The larger the square length of Z,\n        // the smoother the shading\n        if(zr2 + zi2 > 32.0) break;\n \n        // Complex multiplication, then addition\n    \tz = vec2(zr2 - zi2, 2.0 * z.x * z.y) + c;\n        ++iteration;\n    }\n \n    // Generate the colors\n    fragColor = vec4(color(iteration, dot(z,z)), 1.0);\n \n    // Apply gamma correction\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.5));\n}","name":"Image","description":"","type":"image"}]}