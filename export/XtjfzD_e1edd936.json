{"ver":"0.1","info":{"id":"XtjfzD","date":"1514867785","viewed":2272,"name":"Analytic Single Scattering","username":"greje656","description":"A closed form solution for a simple point light in an isotropic homogeneous volume. The solution for the integral is described in this awesome paper by Vincent Pegoraro:\nhttp://www.cs.utah.edu/~vpegorar/research/2009_EG/paper.pdf","likes":53,"published":1,"flags":0,"usePreview":0,"tags":["analytic","singlescattering","closedform"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI4 12.5663706144\n#define ks 0.05\n#define kt ks\n#define I 10.0\n#define light_color vec3(1.000, 0.778, 0.620)\n#define TONEMAP\n\n// From https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n\tfloat a = 2.51;\n\tfloat b = 0.03;\n\tfloat c = 2.43;\n\tfloat d = 0.59;\n\tfloat e = 0.14;\n\treturn clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat I0(float a, float va, float vb) {\n\tconst int maxIterations = 3; // Enough precision for the current scene\n\n\tfloat pva = sqrt(a * a * (va * va + 1.0));\n\tfloat pvb = sqrt(a * a * (vb * vb + 1.0));\n\tfloat ova = atan(a, a * va);\n\tfloat ovb = atan(a, a * vb);\n\tfloat sina = sin(a);\n\tfloat cosa = cos(a);\n\tfloat logv = log(pvb / pva);\n\tfloat phiv = ovb - ova;\n\tfloat I0 = sina * logv - cosa * phiv;\n\n\tfloat kfac = 1.0;\n\tfloat pkva = 1.0;\n\tfloat pkvb = 1.0;\n\tfor (int k = 1; k <= maxIterations; k++) {\n        float kf = float(k);\n\t\tkfac *= kf;\n\t\tpkva *= pva;\n\t\tpkvb *= pvb;\n\t\tfloat okva = a - kf * ova;\n\t\tfloat okvb = a - kf * ovb;\n\t\tfloat denom = 1.0 / (kf * kfac);\n\t\tI0 += (pkvb * sin(okvb) - pkva * sin(okva)) * denom;\n\t}\n\treturn I0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv  = fragCoord.xy / iResolution.xy;\n\tvec2 ndc = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1);\n\tvec3 O   = vec3( 0.0, 0.0, -2.0 );\n    vec3 NP  = vec3(ndc.xy, 0.0);\n\tvec3 V   = normalize(NP - O);\n\n\tvec3 Lp  = vec3( sin(iTime) * 2.0, 0.0, cos(iTime) + 2.0);\n\tvec3 Xa  = O;\n\n\tvec3 P0  = vec3( 0.0, 0.0, 5.0 );\n\tvec3 N0  = vec3( 0.0, 0.0,-1.0 );\n\tvec3 P1  = vec3( 0.0,-2.0, 0.0 );\n\tvec3 N1  = vec3( 0.0, 1.0, 0.0 );\n\n    float ti = dot(P0 - Xa, N0) / dot(V, N0);\n\tfloat tf = dot(P1 - Xa, N1) / dot(V, N1);\n\n    vec3 Xb  = Xa + V * ti;\n\tvec3 Xf  = Xa + V * tf;\n    \n    float Lt = 0.0;\n\n\tif (tf > 0.0) {\n\t\tfloat d = length(Lp - Xf);\n\t\tvec3 L = normalize(Lp - Xf);\n\t\tLt = I * (exp(-kt * d)/(d*d)) * dot(L, N1) * 0.35; // Grey floor\n\t}\n\n    float mousex = iMouse.z < 0.01 ? 0.5 : iMouse.x/iResolution.x;\n    if(fragCoord.x > (iResolution.x*mousex) && fragCoord.x < (iResolution.x*mousex + 1.5)){\n        fragColor = vec4(0.1, 0.1, 0.1,1.0);\n        return;\n    }\n    \n    if (uv.x < mousex) {\n\t\t// Raymarch...\n\t\tconst int num_steps = 50;\n\t\tfloat total_travel_distance = length(Xb - Xa);\n\t\tfloat sample_width = total_travel_distance / float(num_steps);\n\t\tfloat random_offset = noise(vec3(uv * 1000.0, iTime * 10.0));\n\t\tfor (int i = 0; i < num_steps; ++i) {\n\t\t\tfloat nd = float(i) / float(num_steps);\n\t\t\tfloat distance_travelled = nd * total_travel_distance + random_offset * sample_width;\n\t\t\tvec3 X = Xa + V * distance_travelled;\n\t\t\tfloat d = length(Lp - X);\n\t\t\tfloat Li = I / PI4 * (exp(-kt * d) / (d * d));\n\t\t\tLt += exp(-kt*distance_travelled) * (ks*Li) * sample_width;\n\t\t}\n    } else {\n\t\t// Closed Form...\n\t\tvec3 Xh = Xa + (dot(Lp - Xa, V) / dot(V, V)) * V;\n\t\tfloat h = length(Xh - Lp);\n\t\tfloat H = kt * h;\n        float XaXh = length(Xa - Xh);\n        float XbXh = length(Xb - Xh);\n\t\tfloat Va = (-XaXh / h) + sqrt(1.0 + pow(XaXh / h, 2.0));\n\t\tfloat Vb = ( XbXh / h) + sqrt(1.0 + pow(XbXh / h, 2.0));\n\t\tfloat i0 = I0(-H, Va, Vb);\n\t\tLt += I * (ks / h) * exp(-kt * XaXh) * (2.0 / PI4) * i0;\n    }\n\n    Lt = pow(Lt, 1.0/2.2);\n    vec3 color = (Lt * light_color);\n    #if defined(TONEMAP)\n    \tcolor = ACESFilm(color);\n    #endif\n    \n\tfragColor = vec4(color.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}