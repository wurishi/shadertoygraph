{"ver":"0.1","info":{"id":"tls3DS","date":"1557603770","viewed":420,"name":"SGI Logo 2","username":"fizzer","description":"I re-made my old [url=https://www.shadertoy.com/view/ldXGz2]SGI Logo SDF[/url]. This one is about 3.5x faster to evaluate, thanks to the use of symmetry and capsule primitives.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["distancefields","raymarched","logo","sgi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy * 2. - 1.;\n    p.x *= iResolution.x / iResolution.y;\n\n    fragColor = texelFetch(iChannel2, ivec2(fragCoord.xy), 0);\n    fragColor /= fragColor.w;\n\n    fragColor.rgb = pow(fragColor.rgb, mix(vec3(1), vec3(1, 1.4, 1.7), .75));\n    \n    // Gamma correction\n\n    fragColor.rgb = pow(clamp(fragColor.rgb, 0., 1.), vec3(1. / 2.2)) +\n        texelFetch(iChannel1, ivec2(fragCoord) & 1023, 0).rgb / 30.;\n        \n    fragColor.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat traceScene(vec3 ro, vec3 rd)\n{\n    float t = 0.0, d;\n    for(int i = 0; i < 40; ++i)\n    {\n        vec3 rp = ro + rd * t;\n        d = logoSDF(rp);\n        if(d < 2e-4 || t > 5.)\n            break;\n        t += d;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 oldColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    if(iMouse.z > .5 || iFrame < 7)\n        oldColor = vec4(0);\n\n    // Use a flag stored in the alpha channel to indicate\n    // that the texture is already generated.\n    if(oldColor.a < .5)\n    {\n        vec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n        uv.x *= iResolution.x / iResolution.y;\n        vec3 ro = vec3(uv, -2.);\n        vec3 rd = vec3(0, 0, 1);\n\n        initLogoSDF();\n\n        float t = traceScene(ro, rd);\n\n        if(t > 5.)\n            t = 1e6;\n\n        fragColor.rgb = vec3(exp(-t / 16.));\n        fragColor.a = 1.;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float pi = 3.14159265358979323;\nconst float th = pi * 2. / 3.;\nconst vec3 n0 = vec3(sin(th * 2.), cos(th * 2.), 0);\nconst vec3 n2 = vec3(sin(th * 1.), cos(th * 1.), 0);\nconst float sz0 = .1;\nconst float sz1 = .6;\n\nvec3 tubep[4];\n\nmat3 rotX(float a)\n{\n    return mat3(1., 0., 0.,\n                0., cos(a), sin(a),\n                0., -sin(a), cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a), 0., sin(a),\n                0., 1., 0.,\n                -sin(a), 0., cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a), sin(a), 0.,\n                -sin(a), cos(a), 0.,\n                0., 0., 1.);\n}\n\nfloat cyl2(vec3 p,vec3 a,vec3 b)\n{\n    return distance(p, mix(a, b, clamp(dot(p - a, normalize(b - a)) / length(b - a), 0., 1.)));\n}\n\n\nvoid initLogoSDF()\n{\n    mat3 m;\n\n    m[2] = normalize(vec3(-1, 1, 1.));\n    m[1] = normalize(vec3(-1, -1, 0.));\n    m[0] = cross(m[2], m[1]);\n\n    m = transpose(m);\n    \n    tubep[0] = m * vec3(sz0);\n    tubep[1] = m * vec3(sz0, sz1 + sz0 * 2., sz0);\n    tubep[2] = m * vec3(sz0, sz1 + sz0 * 2., sz1);\n    tubep[3] = m * vec3(-sz1, sz1 + sz0 * 2., sz1);\n}\n\nfloat logoSDF(vec3 p)\n{\n    p.xy = -p.yx;\n    p.y =- abs(p.y);\n\n    if(dot(p.xy, n0.xy) < 0.)\n        p.xy = reflect(p.xy, n0.xy);\n\n    if(dot(p.xy, n2.xy) < 0.)\n        p.xy = reflect(p.xy, n2.xy);\n\n    return min(cyl2(p, tubep[0], tubep[1]),\n               min(cyl2(p, tubep[1], tubep[2]),\n                   cyl2(p, tubep[2], tubep[3]))) - sz0;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Lambert BRDF sampling-function.\nvec3 lambertNoTangent(in vec3 normal, in vec2 uv)\n{\n    float theta = pi * 2. * uv.x;\n    uv.y = 2.0 * uv.y - 1.0;\n    vec3 spherePoint = vec3(sqrt(1.0 - uv.y * uv.y) * vec2(cos(theta), sin(theta)), uv.y);\n    return normalize(normal + spherePoint);\n}\n\nuvec2 rstate;\n\n// Tiny Encryption Algorithm for random numbers: \nuvec2 encrypt(uvec2 v)\n{\n    uint k[4], sum = 0U, delta = 0x9e3779b9U;\n    k[0] = 0xA341316CU;\n    k[1] = 0xC8013EA4U;\n    k[2] = 0xAD90777DU;\n    k[3] = 0x7E95761EU;\n    for(uint i = 0U; i < 4U; ++i)\n    {\n        sum += delta;\n        v.x += ((v.y << 4) + k[0]) ^ (v.y + sum) ^ ((v.y >> 5) + k[1]);\n        v.y += ((v.x << 4) + k[2]) ^ (v.x + sum) ^ ((v.x >> 5) + k[3]);\n    }\n\n    return v;\n}\n\nfloat rand()\n{\n    rstate = encrypt(rstate);\n    return float(rstate.x & 0xfffffU) / float(1U << 20U);\n}\n\nvec3 rY(float a, vec3 v)\n{\n    return vec3(cos(a) * v.x + sin(a) * v.z, v.y, cos(a) * v.z - sin(a) * v.x);\n}\n\nfloat s(vec3 p)\n{\n    float d = -p.z+1.3;\n    return min(d, logoSDF(p));\n}\n\nvec3 sceneNorm(vec3 rp)\n{\n    vec3 e = vec3(1e-4, 0, 0);\n    float d0 = s(rp);\n    return normalize(vec3(s(rp + e), s(rp + e.yxy), s(rp + e.yyx)) - d0);\n}\n\nvec2 traceScene(vec3 ro, vec3 rd, out vec3 n)\n{\n    float t = 0.0, d;\n    for(int i = 0; i < 60; ++i)\n    {\n        vec3 rp = ro + rd * t;\n        d = s(rp);\n        if(d < 1e-4 || t > 8.)\n            break;\n        t += d;\n    }\n    n = sceneNorm(ro + rd * t);\n    if(t < 8.)\n        return vec2(t, 1.);\n    return vec2(t, 0.);\n}\n\nfloat samplePattern(vec2 p)\n{\n    vec2 e = vec2(2e-3, 0);\n    float c = textureLod(iChannel2, p * vec2(1.,1.7), 0.).r;\n    float d = c - (textureLod(iChannel2, (p + e.xy) * vec2(1.,1.7), 1.).r + \n                   textureLod(iChannel2, (p + e.yx) * vec2(1.,1.7), 1.).r +\n                   textureLod(iChannel2, (p - e.xy) * vec2(1.,1.7), 1.).r +\n                   textureLod(iChannel2, (p - e.yx) * vec2(1.,1.7), 1.).r) / 4.;\n    return 1. - clamp(abs(d) * 128.,0.,1.);\n}\n\n// Sample the illumunation at a given position, in a given direction.\nvec3 sampleRay(vec3 ro, vec3 rd)\n{\n    vec3 energy = vec3(0);\n    vec3 spectrum = vec3(1.);\n\n    for(int i = 0; i < 5; ++i)\n    {\n        vec3 n, p0, p1;\n        vec2 res = traceScene(ro, rd, n);\n        vec3 rp = ro + rd * res.x;\n\n        vec3 lrd = lambertNoTangent(n, vec2(rand(), rand()));\n\n        if(res.y < .5)\n        {\n            // No intersection.\n            energy += spectrum * vec3(4) * textureLod(iChannel0, rotZ(.6) * rd, 1.).rgb;;\n            break;\n        }\n        else\n        {\n            // Diffuse\n            spectrum *= vec3(1,.7,.7)*.95;\n            ro = rp + n * 2e-4;\n            rd = lrd;\n\n            if(ro.z > 1.29)\n            {\n                vec2 p = ro.xy;\n                if(mod(floor(ro.y * 2.), 2.) > .5)\n                    p.x += .25;\n                spectrum *= mix(.6, 1., samplePattern(mod(p.xy, .5) + vec2(.25,.05)));\n            }\n        }\n\n        if(max(spectrum.x, max(spectrum.y, spectrum.z)) < 1e-3)\n            break;\n    }\n    return energy;\n}\n\n// Sample unit disc\nvec2 disc(vec2 uv)\n{\n    float a = uv.x * pi * 2.;\n    float r = sqrt(uv.y);\n    return vec2(cos(a), sin(a)) * r;\n}\n\n// Sample cone PDF (for tent filtering)\nvec2 cone(vec2 v)\n{\n    return disc(vec2(v.x, 1. - sqrt(1. - v.y)));\n}\n\nvec3 render(vec2 fragCoord)\n{\n    vec3 uv = fragCoord.xyy / iResolution.xyy;\n    vec3 ro = vec3(0.0, 0., -6.5);\n    vec3 rd = normalize(vec3((uv.x - 0.5) * 2.0 * iResolution.x / iResolution.y, uv.y * 2.0 - 1.0, 8.0));\n    vec3 rp = vec3(0.0);\n\n    if(abs(uv.x - .5) > .4)\n        return vec3(0);\n\n    ro += rd * 4.;\n\n    initLogoSDF();\n\n    vec3 energy = sampleRay(ro, rd);\n\n    return energy;\n}\n\n// Halton sequence (radical inverse)\nfloat halton(const uint b, uint j)\n{\n    float h = 0.0, f = 1.0 / float(b), fct = f;\n\n    while(j > 0U)\n    {\n        h += float(j % b) * fct;\n        j /= b;\n        fct *= f;\n    }\n\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    vec4 oldColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    if(iMouse.z > .5 || iFrame < 7)\n        oldColor = vec4(0);\n\n    rstate = uvec2(fragCoord.xy) + uint(iFrame) * 4096U;\n\n    vec2 uv = vec2(halton(2U, uint(oldColor.w) & 2047U), halton(3U, uint(oldColor.w) & 2047U));\n\n    vec2 aaOffset = cone(uv) * .9;\n\n    fragColor = oldColor + vec4(clamp(render(fragCoord + aaOffset).rgb, 0., 2.5), 1.);\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}