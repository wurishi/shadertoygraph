{"ver":"0.1","info":{"id":"Xf3XzH","date":"1714251754","viewed":76,"name":"Psychedelic Vector Field","username":"maxledlie","description":"My first shader. Plotting a time-varying vector field.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14;\n\n// angle in radians\nmat2 rotationMatrix(float angle)\n{\n    float sine = sin(angle), cosine = cos(angle);\n    return mat2( cosine, -sine, \n                 sine,    cosine );\n}\n\nmat2 scaleMatrix(float scale) {\n    return mat2(scale, 0,\n                0,     scale);\n}\n\n// ---- INPUT PARAMETERS --------------------------------------------------------------------\n// Number of cells to draw in the y-direction\nconst int NY = 25;\n\n// Vector-valued function to plot (optionally include iTime)\nvec2 func(vec2 uv) {\n    float vortexFreq = 1.33;\n    float cycloneFreq = 0.875;\n    vec2 vortex = vec2(cos(2. * PI * (uv.x + uv.y)), sin(2. * PI * (uv.x - uv.y)));\n    vec2 cyclone = vec2(cos(-2. * PI * uv.y), sin(2. * PI * uv.x));\n    float alpha = pow(sin(iTime * vortexFreq), 1.);\n    float beta = pow(cos(iTime * cycloneFreq), 1.);\n    \n    // Add a gradual rotation to the overall pattern\n    mat2 rot = rotationMatrix(iTime * 0.1);\n    return 1.8 * (alpha * vortex + beta * cyclone) * rot;\n}\n\n// Domain of the above function to plot\nconst float X_MIN = -1.;\nconst float X_MAX = +1.;\nconst float Y_MIN = -1.;\nconst float Y_MAX = +1.;\n\n// ------------------------------------------------------------------------------------------\n\nvec2 toPolar(vec2 xy) {\n    return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn sqrt(d.x)*sign(d.y);\n}\n\n// Source: https://iquilezles.org/articles/palettes/\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float CELL_SIZE = 2. / float(NY);\n\n    // The x and y coordinates of iResolution are the width and height of the canvas.\n    // uv stretches from -1 to -1 along y axis and from -a to +a along x axis, where a is the aspect ratio\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Coordinates of bottom left corner of cell\n    vec2 bl = floor(uv / CELL_SIZE) * CELL_SIZE;\n    \n    // Coordinates of centre of cell\n    vec2 cn = bl + CELL_SIZE / 2.;\n    \n    // Transform centre point from screen space to model space (assuming domain is centred at the origin for now)\n    float modelX = cn.x * X_MAX * iResolution.y / iResolution.x;\n    float modelY = cn.y * Y_MAX * iResolution.y / iResolution.x;\n    vec2 md = vec2(modelX, modelY);\n    \n    // Evaluate our input function at the CENTRE of each cell, and convert the result to polar coordinates\n    vec2 val = func(md);\n    vec2 pol = toPolar(val);\n    \n    // For rendering our triangles, we want \"local\" coordinates that range from -1 to 1 *within* each cell\n    vec2 loc = 2. * (uv - cn) / CELL_SIZE;\n    \n    // Rotate each triangle according to the angular part of the function output\n    mat2 matrix = rotationMatrix(pol.y);\n    loc = matrix * loc;\n    \n    // Color the triangle according to the angle for a cool effect!\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1., 1., 1.);\n    vec3 d = vec3(0., 0.33, 0.67);\n    vec3 color = palette(pol.y / (2. * PI), a, b, c, d);\n    \n    // Scale the triangle according to the radial part of the function output\n    float scale = sqrt(pol.x);\n    vec2 topLeft = vec2(-0.3, 0.3) * scale;\n    vec2 bottomLeft = vec2(-0.3, -0.3) * scale;\n    vec2 right = vec2(0.8, 0.0) * scale;\n    \n    float sd = sdTriangle(loc, bottomLeft, topLeft, right);\n    float intensity = smoothstep(0., 0.05, sd);\n    \n    fragColor = vec4(intensity * color, 1.);\n}","name":"Image","description":"","type":"image"}]}