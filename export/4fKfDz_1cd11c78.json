{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"#define PI 3.1415926\n#define TIMESCALE 0.8\n\nfloat map(float v, vec2 before, vec2 after)\n{\n    // Maps a number from one range to another one (e.g. from [-1, 1] to [0, 1]), helps avoid mesy code for less obvious mappings than the example.\n    return after.x + (v - before.x) * (after.y - after.x) / (before.y - before.x);\n}\n\nfloat saturate(float v, float drive)\n{\n    // Honestly, probably not the most optimized function for this kind of thing, but okay for a prototype.\n    // This is basically just an easing function for values from -1 to 1. power lets you control how long it stays at either value.\n    // Works similar to a basic saturation wave-shaper you might see in audio processing.\n    return sign(v) * (1.0 - pow((1.0 - clamp(abs(v), 0.0, 1.0)), 1.0/(1.0 - drive)));\n}\n\nfloat grid(vec2 uv, float cellSize, float lineWidth, float mult)\n{\n    vec2 gridMap = abs(mod(uv, cellSize));\n    return (gridMap.x < lineWidth) || (gridMap.y < lineWidth) ? mult : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float time = iTime * TIMESCALE + 1.54;\n    \n    float colorMix = 0.5 + 0.5 * saturate(sin(time * PI), 0.76);\n    vec3 accent = mix(vec3(0.3, 0.5, 1.0), vec3(1.0, 0.5, 0.3), colorMix);\n    \n    vec3 result = vec3(0.3);\n    \n    // Generate zooming grid stripes\n    float gridScale = pow(2.0, 0.5 * mod(time, 2.)) / 2.;\n    result *= grid(uv, 0.25 * gridScale, 0.01, 0.85);\n    result *= grid(uv, 0.0625 * gridScale, 0.01, 1.0 - clamp(gridScale / 4., 0.0, 1.0) * 0.15);\n        \n    // Vignette\n    result *= 1.0 - pow(min(log(length(uv * 0.6) + 1.0), 1.0), 1.5);\n    \n    // Basically, how tight the coil is (integer values work best)\n    float T = 6.0;\n    \n    float K = log(length(uv.xy));\n    float C = atan(uv.y, uv.x);\n    \n    // \"Zoom\" in by offsetting the phase\n    float phase = 2.0 * time;\n    float dist = cos(T*K - C - 2.0*phase)*cos(K + T*C - phase);\n    float r = map(sin(time * PI), vec2(-1., 1.), vec2(-0.707, 0.707));\n    \n    if (dist < r)\n    {\n        // Mix in holographic color\n        result = mix(accent, result, 0.5);\n        \n        // Calculate a halo to be applied\n        float halo = map(dist, vec2(-1., r), vec2(0., 1.));\n        float haloWidth = 0.2;\n        halo = halo > (1.0 - haloWidth) ? map(halo, vec2(1.0 - haloWidth, 1.0), vec2(0.0, 1.0)) : 0.0;\n        result += halo * accent;\n    }\n\n    // Output to screen\n    fragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fKfDz","date":"1733957892","viewed":42,"name":"holographic swiss cheesen't","username":"brickdude","description":"basically works by having opposing log spirals cancel each other out and generating a depth map (interference pattern) that I then slice to choose where to show the glowy material.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","spiral","logarithm","holographic"],"hasliked":0,"parentid":"","parentname":""}}