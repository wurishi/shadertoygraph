{"ver":"0.1","info":{"id":"flByzt","date":"1650117477","viewed":417,"name":"Cosine + Sine Addition w Buffer","username":"formographik","description":"A fun exercise in seeing if I could recreate something that reminded me of math textbook multiplication tables.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["sine","cosine","trigonometry"],"hasliked":0,"parentid":"NtScRt","parentname":"Cosine and Sine Addition Table"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime*.5\n\nvec2 Grid(in vec2 uv, in vec2 grid, out vec2 cells){\n    uv*=grid;\n    cells=floor(uv);\n    uv=fract(uv);\n    return uv;\n}\n\nvec2 Position(float x, float y) {\n    return vec2(sin(t*(x+1.))*.5+.5,cos(t*(y+1.))*.5+.5)*.75+.125;\n}\n\nvec3 Circle(vec2 st, vec2 pos, float size) {\n    float d = distance(st,pos);\n    float w = 0.5*fwidth(d); \n    w *= 1.2;\n    return vec3(1.-smoothstep(-w, w, size - d));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // 0,0 in top left\n    uv.y = 1.-uv.y;\n    \n\n    // split the uv into a grid\n    vec2 cells;\n    uv=Grid(uv,vec2(10.,10.),cells);\n\n    // table\n    vec2 p = Position(cells.x, cells.y);\n\n    // left column\n    if (cells.x == 0.) p = Position(cells.y, cells.y);\n    \n    // top row\n    if (cells.y == 0.) p = Position(cells.x, cells.x);\n\n    // top left corner\n    if (cells.x == 0. && cells.y == 0.) p = vec2(0.5);\n    \n    vec3 circle = Circle(uv,p,.075);\n\n    vec4 color = vec4(circle,1.0);\n    \n    fragColor = color*1.-col;    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define t iTime*.5\n\nvec2 Grid(in vec2 uv, in vec2 grid, out vec2 cells){\n    uv*=grid;\n    cells=floor(uv);\n    uv=fract(uv);\n    return uv;\n}\n\nvec2 Position(float x, float y) {\n    return vec2(sin(t*(x+1.))*.5+.5,cos(t*(y+1.))*.5+.5)*.75+.125;\n}\n\nvec3 Path(vec2 st, vec2 pos, float size) {\n    float d = distance(st,pos);\n    float w = 0.5*fwidth(d); \n    w *= 1.2;\n    return vec3(1.-smoothstep(-w, w, size - d));\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0,ivec2(fragCoord),0);\n    if (fragColor.a != iResolution.x) fragColor = vec4(1);\n    fragColor.a = iResolution.x;\n    \n    vec2 uv=fragCoord.xy/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    // 0,0 in top left\n    uv.y = 1.-uv.y;\n\n    // split the uv into a grid\n    vec2 cells;\n    uv=Grid(uv,vec2(10.,10.),cells);\n\n    // lines\n    vec2 bl = step(vec2(0.01),uv);\n    float pct = bl.x * bl.y;\n    vec2 tr = step(vec2(0.01),1.0-uv);\n    pct *= tr.x * tr.y;\n    vec3 lines = vec3(pct);\n\n    // table\n    vec2 p = Position(cells.x, cells.y);\n    vec3 fill = vec3(cells*.075,1.-cells.x*.075)*.7;\n\n    // left column\n    if (cells.x == 0.) {\n        fill = fill*.6;\n        p = Position(cells.y, cells.y);\n    } \n    \n    // top row\n    if (cells.y == 0.) {\n        fill = fill*.6;\n        p = Position(cells.x, cells.x);\n    } \n\n    // top left corner\n    if (cells.x == 0. && cells.y == 0.) {\n        fill = vec3(0.);\n        p = vec2(0.5);\n    }\n\n    // diagonal\n    if (cells.x==cells.y) fill = fill*.6;\n\n    vec3 color = fill*Path(uv,p,.01)*lines;\n    \n    fragColor.xyz = min(fragColor.xyz, color);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}