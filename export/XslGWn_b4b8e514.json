{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\t\t\t// Created by inigo quilez - iq/2013\n\t\t\t// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\t\t\t// Modified by Croqueteer for anaglyphic stereo, some comments and a few slight optimizations.\n\t\t\t// This was such a beautiful effect, I just had to see it in 3D. I didn't want to do two passes,\n\t\t\t// as it was already pretty heavy, so I opted to the old screen door effect encoding every other pixel.\n\n\t\t\tfloat hash( float n )\n\t\t\t{\n\t\t\t    return fract(sin(n)*43758.5453123);\n\t\t\t}\n\n\t\t\tvec3 noised( in vec2 x )\n\t\t\t{\n\t\t\t    vec2 p = floor(x);\n\t\t\t    vec2 f = fract(x);\n\t\t\t    vec2 ff = f*f;\n\t\t\t    vec2 f2 = f*2.0;\n\t\t\t    vec2 u = ff*(3.0-f2);\n\n\t\t\t    float n = p.x + p.y*57.0;\n\n\t\t\t    float a = hash(n+  0.0);\n\t\t\t    float b = hash(n+  1.0);\n\t\t\t    float c = hash(n+ 57.0);\n\t\t\t    float d = hash(n+ 58.0);\n\t\t\t\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t\t\t\t30.0*ff*((ff-f2)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n\t\t\t}\n\n\t\t\tfloat noise( in vec2 x )\n\t\t\t{\n\t\t\t    vec2 p = floor(x);\n\t\t\t    vec2 f = fract(x);\n\n\t\t\t    f = f*f*(3.0-2.0*f);\n\n\t\t\t    float n = p.x + p.y*57.0;\n\n\t\t\t    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n\t\t\t    return res;\n\t\t\t}\n\n\t\t\tmat3 m = mat3( 0.00,  0.80,  0.60,\n\t\t\t              -0.80,  0.36, -0.48,\n\t\t\t              -0.60, -0.48,  0.64 );\n\n\t\t\tmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\t\t\t\t\n\t\t\tfloat fbm( vec2 p )\n\t\t\t{\n\t\t\t    float f = 0.0;\n\n\t\t\t    f += 0.5000*noise( p ); p = m2*p*2.02;\n\t\t\t    f += 0.2500*noise( p ); p = m2*p*2.03;\n\t\t\t    f += 0.1250*noise( p ); p = m2*p*2.01;\n\t\t\t    f += 0.0625*noise( p );\n\n\t\t\t    return f/0.9375;\n\t\t\t}\n\n\t\t\tfloat terrain( in vec2 x )\n\t\t\t{\n\t\t\t\tvec2  p = x*0.003;\n\t\t\t    float a = 0.0;\n\t\t\t    float b = 1.0;\n\t\t\t\tvec2  d = vec2(0.0);\n\t\t\t    for(int i=0;i<5; i++)\n\t\t\t    {\n\t\t\t        vec3 n = noised(p);\n\t\t\t        d += n.yz;\n\t\t\t        a += b*n.x/(1.0+dot(d,d));\n\t\t\t\t\tb *= 0.5;\n\t\t\t        p=m2*p;\n\t\t\t    }\n\n\t\t\t    return 140.0*a;\n\t\t\t}\n\n\t\t\tfloat terrain2( in vec2 x )\n\t\t\t{\n\t\t\t\tvec2  p = x*0.003;\n\t\t\t    float a = 0.0;\n\t\t\t    float b = 1.0;\n\t\t\t\tvec2  d = vec2(0.0);\n\t\t\t    for(int i=0;i<14; i++)\n\t\t\t    {\n\t\t\t        vec3 n = noised(p);\n\t\t\t        d += n.yz;\n\t\t\t        a += b*n.x/(1.0+dot(d,d));\n\t\t\t\t\tb *= 0.5;\n\t\t\t        p=m2*p;\n\t\t\t    }\n\n\t\t\t    return 140.0*a;\n\t\t\t}\n\n\t\t\tfloat map( in vec3 p )\n\t\t\t{\n\t\t\t\tfloat h = terrain(p.xz);\n\t\t\t\t\n\t\t\t\tfloat ss = 0.03;\n\t\t\t\tfloat hh = h*ss;\n\t\t\t\tfloat fh = fract(hh);\n\t\t\t\tfloat ih = floor(hh);\n\t\t\t\tfh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );\n\t\t\t\th = (ih+fh)/ss;\n\t\t\t\t\n\t\t\t    return p.y - h;\n\t\t\t}\n\n\t\t\tfloat map2( in vec3 p )\n\t\t\t{\n\t\t\t\tfloat h = terrain2(p.xz);\n\t\t\t\t\n\t\t\t\tfloat ss = 0.03;\n\t\t\t\tfloat hh = h*ss;\n\t\t\t\tfloat fh = fract(hh);\n\t\t\t\tfloat ih = floor(hh);\n\t\t\t\tfh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );\n\t\t\t\th = (ih+fh)/ss;\n\t\t\t\t\n\t\t\t    return p.y - h;\n\t\t\t}\n\n\t\t\tbool jintersect(in vec3 rO, in vec3 rD, out float resT )\n\t\t\t{\n\t\t\t    float h = 0.0;\n\t\t\t    float t = 0.1;\n\t\t\t\tfor( int j=0; j<150; j++ )\n\t\t\t\t{\n\t\t\t        //if( t>2000.0 ) break;\n\t\t\t\t\t\n\t\t\t\t    vec3 p = rO + t*rD;\n\t\t\tif( p.y>300.0 ) return false;\n\t\t\t        h = map( p );\n\n\t\t\t\t\tif( h<0.1)\n\t\t\t\t\t{\n\t\t\t\t\t\tresT = t; \n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tt += max(0.1,0.5*h);\n\n\t\t\t\t}\n\n\t\t\t\tif( h<5.0 )\n\t\t\t    {\n\t\t\t\t    resT = t;\n\t\t\t\t    return true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t//shadow intersect\n\t\t\tfloat sintersect(in vec3 rO, in vec3 rD )\n\t\t\t{\n\t\t\t    float res = 1.0;\n\t\t\t    float t = 0.1;\n\t\t\t\tfor( int j=0; j<50; j++ )\n\t\t\t\t{\n\t\t\t        //if( t>1000.0 ) break;\n\t\t\t\t    vec3 p = rO + t*rD;\n\n\t\t\t        float h = map( p );\n\n\t\t\t\t\tif( h<0.1 )\n\t\t\t\t\t{\n\t\t\t\t\t\treturn 0.0;\n\t\t\t\t\t}\n\t\t\t\t\tres = min( res, 16.0*h/t );\n\t\t\t\t\tt += h;\n\n\t\t\t\t}\n\n\t\t\t\treturn clamp( res, 0.0, 1.0 );\n\t\t\t}\n\n\t\t\t// given a position, compute the normal there\n\t\t\tvec3 calcNormal( in vec3 pos, float t )\n\t\t\t{\n\t\t\t    vec3  eps = vec3(0.001*t,0.0,0.0);\n\t\t\t    vec3 nor;\n\t\t\t    float center = map2(pos);\n\t\t\t    nor.x = center - map2(pos-eps.xyy);\n\t\t\t    nor.y = 0.001*t; \n\t\t\t    nor.z = center - map2(pos-eps.yyx);\n\t\t\t    return normalize(nor);\n\t\t\t}\n\n\t\t\t// generates a spirograph type path\n\t\t\tvec3 camPath( float time )\n\t\t\t{\n\t\t\t    vec2 p = 600.0*vec2( cos(1.4+0.37*time), \n\t\t\t                         cos(3.2+0.31*time) );\n\n\t\t\t\treturn vec3( p.x, 0.0, p.y );\n\t\t\t}\n\n\t\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t\t\t{\n\t\t\t    vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy; // generate a location between (-1,-1) and (1,1)\n\t\t\t\tvec2 s = xy*vec2(1.75,1.0); // scales the image up in the y dimension\n\t\t\t\tbool isCyan = 0.5<mod(fragCoord.xy.x,2.0);\n\t\t\t\tif(.5<mod(fragCoord.xy.y,2.0))isCyan = !isCyan;\n                if(isCyan) s.x = s.x - 0.3;\n\t\t\t    float time = 0.1*iTime;\n\n\t\t\t\tvec3 light1 = vec3(  0.53, 0.292,  0.796 );\n\t\t\t\tvec3 light2 = vec3( -0.707, 0.000, -0.707 );\n\n\t\t\t\tvec3 campos = camPath( time ); // position\n\t\t\t\tvec3 camtar = camPath( time + 3.0 ); // target\n\t\t\t\tcampos.y = terrain( campos.xz ) + 15.0; // height where we are now\n\t\t\t\tcamtar.y = campos.y*0.5; // where we are looking - the higher we are the further down we look\n\n\t\t\t\tfloat roll = 0.1*cos(0.1*time); // roll from -0.1 to 0.1\n\t\t\t\tvec3 cw = normalize(camtar-campos);\n\t\t\t\tvec3 cv = vec3(sin(roll), cos(roll),0.0); // slight roll left then right - this is the up vector\n\t\t\t\tvec3 cu = normalize(cross(cw,cv)); // this is the right vector\n\t\t\t\tcv = normalize(cross(cu,cw)); // this is the up vector again - no need\n\t\t\t\tvec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw ); // the ray through the pixel\n\n\t\t\t\tif(isCyan)campos+=2.0*cu; // move camera to the right - the rd vector is still good\n\n\t\t\t\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\t\t\t\tvec3 col;\n\t\t\t    float t;\n\t\t\t    if( !jintersect(campos,rd,t) )\n\t\t\t    {\n\t\t\t     \tcol = 0.9*vec3(0.97,.99,1.0)*(1.0-0.3*rd.y);\n\t\t\t\t\tcol += 0.2*vec3(0.8,0.7,0.5)*pow( sundot, 4.0 );\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvec3 pos = campos + t*rd;\n\n\t\t\t        vec3 nor = calcNormal( pos, t );\n\n\t\t\t\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\t\t\t\tfloat dif2 = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\t\t\t\tfloat sh = 1.0;\n\t\t\t\t\tif( dif1>0.001 ) // if it isn't already facing away from the light, determine if it is shadowed\n\t\t\t\t\t\tsh = sintersect(pos+light1*20.0,light1);\n\t\t\t\t\t\n\t\t\t\t\tvec3 dif1v = vec3(dif1);\n\t\t\t\t\tdif1v *= vec3( sh, sh*sh*0.5+0.5*sh, sh*sh );\n\t\t\t\t\t// the snow covers up most of the nice detail in the dirt\n\t\t\t\t\t#if 1\n\t\t\t\t\tcol = vec3(0.1,0.05,0.02);\n\t\t\t\t\t#else\n\t\t\t\t\tfloat r = noise( 7.0*pos.xz );\n\t\t\t        col = (r*0.25+0.75)*0.9*mix( vec3(0.10,0.05,0.03), vec3(0.13,0.10,0.08), clamp(terrain( vec2(pos.x,pos.y*48.0))/200.0,0.0,1.0) );\n\t\t\t\t\tcol = mix( col, 0.17*vec3(0.5,.23,0.04)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n\t\t\t        col = mix( col, 0.10*vec3(0.2,.30,0.00)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n\t\t\t  \t    col *= 0.75;\n\t\t\t  \t    #endif\n\n\t\t\t         // snow\n\t\t\t        #if 1\n\t\t\t\t\tfloat h = smoothstep(55.0,80.0,pos.y + 25.0*fbm(0.01*pos.xz) );\n\t\t\t        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n\t\t\t        float o = 0.3 + 0.7*smoothstep(0.0,0.1,nor.x+h*h);\n\t\t\t        float s = h*e*o;\n\t\t\t        s = smoothstep( 0.1, 0.9, s );\n\t\t\t        col = mix( col, 0.4*vec3(0.6,0.65,0.7), s );\n\t\t\t        #endif\n\n\t\t\t\t\t// sum the shadowing and direct light\n\t\t\t\t\tvec3 brdf  = 2.0*vec3(0.17,0.19,0.20)*clamp(nor.y,0.0,1.0); //flat surfaces are enhanced\n\t\t\t\t\t     brdf += 6.0*vec3(1.00,0.95,0.80)*dif1v; // shadow\n\t\t\t\t\t     brdf += 2.0*vec3(0.20,0.20,0.20)*dif2; //second light source\n\n\t\t\t\t\tcol *= brdf;\n\t\t\t\t\t\n\t\t\t\t\t//add distance fog\n\t\t\t\t\tfloat fo = 1.0-exp(-pow(0.0015*t,1.5));\n\t\t\t\t\tvec3 fco = vec3(0.7) + 0.6*vec3(0.8,0.7,0.5)*pow( sundot, 4.0 );\n\t\t\t\t\tcol = mix( col, fco, fo );\n\t\t\t\t}\n\n\t\t\t\tcol = sqrt(col); // brightens the image (colors are < 1.0, so sqrt would be a larger number)\n\n\t\t\t\t// darkens the edges of the image\n\t\t\t\tvec2 uv = xy*0.5+0.5;\n\t\t\t\tcol *= 0.7 + 0.3*pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),0.1);\n\t\t\t\tif(isCyan)\n\t\t\t\t\tfragColor=vec4(0.0,col.gb,1.0);\n\t\t\t\telse\n\t\t\t\t\tfragColor=vec4(sqrt(col.r),0.0,0.0,1.0);\n\t\t\t}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XslGWn","date":"1367370964","viewed":829,"name":"Anaglyph Elevated","username":"croqueteer","description":"Modified for anaglyphic stereo, some comments and a few slight optimizations by Croqueteer.\niq created such a beautiful demo, I just had to see it in 3D. I didn't want to do two passes, as it was already pretty heavy, so I opted for the old screen door.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","anaglyph","iq","elevated","stereo"],"hasliked":0,"parentid":"","parentname":""}}