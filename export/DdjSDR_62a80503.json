{"ver":"0.1","info":{"id":"DdjSDR","date":"1670162120","viewed":263,"name":"Terrain contour from march steps","username":"jolle","description":"Terrain shaded from the number of marching steps. Can create some cool looking stuff, see album with some examples: https://imgur.com/a/sJnwAo9","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MULTISAMPLES 1 // Max 4\n\nconst float min_stepsize = 0.015;\nconst float stepfactor = 0.33;\nconst int maxsteps = 80;\n\nconst float zoom = 1.4;\nconst float eyedistance = 50.0;\n\nconst float pi = 3.1415926326;\n\nfloat sq(float x) { return x * x; }\n\nfloat hf(vec2 p)\n{\n    vec2 uv = p * 0.01 + 0.5;\n    float r = clamp(1.0 - length(uv - 0.5) * 2.0, 0.0, 1.0);\n    return sq(r * textureLod(iChannel0, uv, 0.0).x) * 20.0;\n}\n\nvec4 march_terrain(vec3 p, vec3 d)\n{\n    for (int i = 0; i < maxsteps; ++i)\n    {\n        p += d * max(min_stepsize, (p.y - hf(p.xz)) * stepfactor);\n       \tif (p.y < hf(p.xz))\n\t\t\treturn vec4(p, float(i) / float(maxsteps));\n    }\n    return vec4(p, 1.0);\n}\n\nvec3 s(vec3 p, vec3 d)\n{\n    vec4 r = march_terrain(p, d);\n    float df = (1.0 - smoothstep(50.0, 350.0, length(r.xz)));\n    return sq(r.w * sq(df)) * vec3(2.0, 1.0, 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ry = -iMouse.x / iResolution.x * pi * 2.0 + iTime * 0.1;\n    float rx = pi * 0.905;\n    if (iMouse.xy != vec2(0.0))\n        rx = clamp(iMouse.y / iResolution.y * pi, 0.0, pi);\n\n    vec4 cs = cos(vec4(ry, rx, ry - pi * 0.5, rx - pi * 0.5));\n    vec3 forward = -vec3(cs.x * cs.y, cs.w, cs.z * cs.y);\n\tvec3 up = vec3(cs.x * cs.w, -cs.y, cs.z * cs.w);\n\tvec3 left = cross(up, forward);\n    vec3 eye = -forward * eyedistance + vec3(0, 1, 0);\n\n\tvec2 uv = zoom * (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    vec3 dir = normalize(vec3(forward + uv.y * up + uv.x * left));    \n    vec3 color = s(eye, dir);\n#if MULTISAMPLES > 1\n    vec2 uvh = zoom * vec2(0.5) / iResolution.x;\n    color += s(eye, normalize(forward + (uv.y + uvh.y) * up + (uv.x + uvh.x) * left));\n#if MULTISAMPLES > 2\n    color += s(eye, normalize(forward + (uv.y + uvh.y) * up  + uv.x * left));\n#if MULTISAMPLES > 3\n    color += s(eye, normalize(forward + uv.y * up + (uv.x + uvh.x) * left));\n#endif\n#endif\n    color /= float(MULTISAMPLES);\n#endif\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = 1.15 * (\n        texture(iChannel0, uv * 0.25) * 0.5 +\n        texture(iChannel0, uv * -0.5) * 0.25 +\n        texture(iChannel0, uv) * 0.125 +\n        texture(iChannel0, uv * -2.0) * 0.0625 +\n        texture(iChannel0, uv * 4.0) * 0.03125 +\n        texture(iChannel0, uv * -8.0) * 0.015625);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}