{"ver":"0.1","info":{"id":"DtsyWN","date":"1690757046","viewed":56,"name":"Oscillating Quadratic Bezier","username":"Benji_w","description":".","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["curvegowobblewobble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Circle function\nfloat Circle(vec2 p, vec2 c) {\n    float d = length(p-c);\n    return smoothstep(fwidth(d), 0., d-.03);\n    \n}\n// Line function\nfloat Line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float t  = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    vec2 c = a+ba*t;\n    float d = length(c-p);\n    return smoothstep(fwidth(d), 0., d-0.005);\n}\n// final curve function\nvec2 Curve(vec2 a, vec2 b, vec2 c, float t) {\n    return mix(mix(a, c, t), mix(c, b, t), t);\n}\n\n//Remap ranges of numbers\nfloat remap01 (float a, float b, float t) {\n    return (t-a) / (b-a);\n}\n\nfloat remap (float a, float b, float c, float d, float t) {\n     return remap01(a, b, t) *  (d - c) + c;\n}\n\n\n//Main output image code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )  {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.x;\n    // declaring  osscialting time variable for use moving joining circles \n        float t = sin(iTime)*.5+.5; \n    // background color\n        vec3 col = vec3(0,0,0.2) ;\n    // line color \n        vec3 LC = vec3(.5,.5,.5);\n    // offset for x and y of (A) \n        float Axt = remap(0.,1.,.2, -.1, sin(iTime));\n        float Ayt = remap(0.,1.,.1, -.1, sin(iTime));\n    // offset for x and y of (B) \n        float Bxt = .2*sin(2.*iTime);\n        float Byt = .4*sin(iTime);\n    // offset for x and y of (C) \n        float Cxt = sin(iTime*1.2)*.1;\n        float Cyt = cos(iTime*1.2)*.1;\n    //postion of each point    1st and last will be the start and end of the curve\n        vec2\n            A = vec2(-.4, 0.),  // add in xt and yt to each of the x and y of A,B,C ect.. to ossiclate point\n            B = vec2( 0.+Bxt, 0.+Byt), // add in xt and yt to each of the x and y of A,B,C ect.. to ossiclate point\n            C = vec2( .4, 0.); // add in xt and yt to each of the x and y of A,B,C ect.. to ossiclate point\n    //postion of  each 1st joining point \n        vec2\n           AB = mix(A, B, t),\n           BC = mix(B, C, t);\n    //postion of  each 2nd joining point\n        vec2\n           ABBC = mix(AB, BC, t);\n        \n    //Call cirlces for each point\n        //col += vec3(1,0,0)*Circle(uv, A);\n        //col += vec3(1,0,0)*Circle(uv, B);\n        //col += vec3(1,0,0)*Circle(uv, C);\n    //call circles for each 1st joining point\n        //col += vec3(1,0,1)*Circle(uv, AB);\n        //col += vec3(1,0,1)*Circle(uv, BC);\n    //call circles for 2nd joining point \n        col += vec3(0,1,0)*Circle(uv, ABBC);\n        \n    //Call lines between each point\n        //col += vec3(LC)*Line(uv, A, B);\n        //col += vec3(LC)*Line(uv, B, C);\n        //col += vec3(LC)*Line(uv, AB, BC);\n        \n    //drawing the curve   -   increasing NUM_SEGS will increase 'smoothness' of curve    \n         int NUM_SEGS = 1000;\n        \n         vec2 P, PP=A;\n     for(int i=1; i<=NUM_SEGS; i++) {\n       t = float(i)/float(NUM_SEGS);\n       P = Curve(A, C, B, t);\n       col +=  vec3(LC)*Line(uv, P, PP); // this draws the lines between each segment point.\n       PP = P;\n    }\n \n    // Output to screen\n        fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}