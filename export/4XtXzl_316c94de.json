{"ver":"0.1","info":{"id":"4XtXzl","date":"1719413718","viewed":64,"name":"2024_06_26","username":"sako","description":"practice","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// cf\n// https://wgld.org/d/glsl/g014.html\n// https://wgld.org/d/glsl/g012.html\n// https://wgld.org/d/glsl/g013.html\n//\nconst float sphereSize = 1.0;\n\nconst float PI = 3.13159265;\nconst float angle = 60.0;\nconst float deg2rad = PI / 180.0;\nconst float fov = angle * 0.5 * deg2rad;\n\nconst int marchingLoopCount = 256;\n\nvec3 trans(vec3 p){\n    return mod(p, 4.0) - 2.0;\n}\nfloat sdSphere(vec3 p){\n    return length(p)-sphereSize;\n}\n\nfloat sdBox(vec3 p){\n    float size = 1.0;\n    return length(max(abs(p) - vec3(size, size, size), 0.0));\n}\n\nfloat sdRoundBox(vec3 p){\n    return length(max(abs(p) - vec3(0.5, 0.5, 0.5), 0.0))-0.2;\n}\n\nfloat sdTorus(vec3 p){\n    vec2 t = vec2(0.75, 0.25);\n    vec2 r = vec2(length(p.xy) - t.x, p.z);\n    return length(r) - t.y;\n}\n\nfloat sdFloor(vec3 p){\n    return dot(p, vec3(0.0, 1.0, 0.0)) + 1.0;\n}\n\nfloat sdScene(vec3 p){\n    // trans function is dividing space (-2 < p < 2)\n    float s = sdSphere(p+vec3(0.0, 0.0, 5.0));\n    float obj = sdTorus(trans(p));\n    return min(s, obj);\n    //float obj = sdTorus(p);\n    float floor = sdFloor(p);\n    return min(obj, floor);\n}\n\n\n\n//the tetrahedron normal trick\n//https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(vec3 p){\n    vec2 d = .0001 * vec2(1,-1);\n    return normalize(   d.xyy* sdScene(p+d.xyy)\n                      + d.yxy* sdScene(p+d.yxy)\n                      + d.yyx* sdScene(p+d.yyx)\n                      + d.xxx* sdScene(p+d.xxx) );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n    const float sphereSize = 1.0;\n    // center is (0,0)\n    vec2 p = (fragCoord.xy*2.0 - iResolution.xy);\n    // normalize\n    p /= min(iResolution.x, iResolution.y);\n    \n//\n//     *\n//     *****\n//     *********\n//sinθ *************\n//     *****************    θ(fov)\n//     *********************\n//            cosθ\n///////////////////////////////////\n    vec3 ray = normalize(vec3(sin(fov) * p.x, sin(fov) * p.y, -cos(fov)));\t\n    \n    //float t = 2.0*fract(iTime)-1.0;\n    float t = iTime;\n    vec3 cPos = vec3(0.0 , 0.0, 2.0+t);\n\n    \n    float distance = 0.0;\n    float rLen = 0.0;\n    vec3 rPos = cPos;\n    for(int i=0; i<marchingLoopCount; i++){\n        distance = sdScene(rPos);\n        rLen += distance;\n        rPos = cPos + ray * rLen;\n    }\n    \n    \n    if(abs(distance) < 0.001){\n        vec3 normal = getNormal(rPos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        fragColor = vec4(vec3(diff), 1.0);\n        //fragColor = vec4(vec3(normal), 1.0);\n    }\n    else{\n        fragColor = vec4(vec3(0.0), 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}