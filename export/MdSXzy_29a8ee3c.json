{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"mat4 cam;\nmat3 rot;\nvec3 lookFrom;\nvec3 lookAt;\n\nvec2 _fragCoord;\n\n\nstruct Plane\n{\n    vec3 normal;\n    vec3 position;\n};\n\nstruct Ray\n{\n    vec3 from;\n    vec3 direction;\n};\n\nconst int NUM_PLANES = 1;\n\n//#define USE_TEXTURE \n\nPlane planes[NUM_PLANES];    \n    \nvec4 trace(Ray ray)\n{\n    for (int i = 0; i < NUM_PLANES; ++i)\n    {\n        \n        \n        Plane p = planes[i];\n        vec3 originalPosition = p.position;\n        \n        float a = dot(p.position - ray.from, p.normal);\n        float b = dot(ray.direction, p.normal);\n        float t = a / b;\n\n        vec3 worldpos = ray.from + ray.direction * t;\n        vec2 uv = vec2(worldpos.x, worldpos.z);\n\n        #ifdef USE_TEXTURE\n        uv *= 0.16;\n        vec4 tex = texture(iChannel0, uv);\n        #endif\n        \n        if (t > 0.0)\n        {\n            float c = 0.0;\n\n            if(mod(worldpos.x, 1.0) > 0.5 && mod(worldpos.z, 1.0) > 0.5)\n            {\n                c = 1.0;\n            }\n\n            if(mod(worldpos.x, 1.0) < 0.5 && mod(worldpos.z, 1.0) < 0.5)\n            {\n                c = 1.0;\n            }\n            #ifdef USE_TEXTURE\n            return tex;\n\t\t\t#else\n            return vec4(c, 0.41 * float(i + 1), 0.0, 1.0);\n            #endif\n            \n        }\n\n    }    \n    \n    return vec4(0.0,0.25,_fragCoord.y / iResolution.y, 0.0);\n}\n\nvec2 getNormalizedPosition(vec2 screenCoord)\n{\n    float midx = iResolution.x * 0.5;\n    float midy = iResolution.y * 0.5;\n    \n    float mx = screenCoord.x - midx;\n    float my = screenCoord.y - midy;\n    return vec2(mx / midx, my / midy);\n}\n\n\nRay getRay(vec2 screenCoord)\n{\n    vec3 p = vec3(getNormalizedPosition(screenCoord), 0.0);\n    \n    Ray r;\n    r.from = lookFrom;\n    \n    vec3 look = lookAt - lookFrom;\n    \n    p.z = look.z;\n    p.z /= length(look);\n    p = normalize(p);\n    r.direction = p;\n    r.direction *= rot;\n    \n    return r;\n}\n\n\nvoid lookat(vec3 to)\n{\n    lookAt = to;\n    vec3 fwd = normalize(lookFrom - to);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 v = normalize(cross(up, fwd));\n    vec3 w = normalize(cross(fwd, v));\n    \n    rot[0] = v;\n    rot[1] = w;\n    rot[2] = fwd;\n\n\n}\n\nvec4 drawPlanes()\n{\n    \n    vec4 totalCol = vec4(0.0, 0.0, 0.0, 0.0);    \n\tconst int kernel = 11;\n    const float filterOffset = 1.0 / float(kernel);\n    \n    for (int x = -kernel; x < kernel; x+=2)\n    {\n        for (int y= -kernel; y < kernel; y+=2)\n        {\n            vec2 offset = vec2(x, y) * filterOffset;\n            \n            vec2 pos = _fragCoord.xy + offset;\n\t\t    Ray r = getRay(pos);\n\t\t    totalCol += trace(r);\n        }\n    }\n    vec4 col = totalCol / float (kernel * kernel);\n    return col;\n}\n\nvec3 rotateX(float angle, vec3 point)\n{\n    mat3 rotx;\n    rotx[0] = vec3(1.0, 0.0, 0.0);\n    rotx[1] = vec3(0.0, cos(angle), -sin(angle));\n    rotx[2] = vec3(0.0, sin(angle), cos(angle));\n    return rotx * point;\n}\n\nvec3 rotateZ(float angle, vec3 point)\n{\n    mat3 rotz;\n    rotz[0] = vec3(cos(angle), -sin(angle), 0.0);\n    rotz[1] = vec3(sin(angle), cos(angle), 0.0);\n    rotz[2] = vec3(0.0, 0.0, 1.0);\n    return rotz * point;\n}\n    \n    \nvoid rotateCamZ(float angle)\n{\n    mat3 rotz;\n    rotz[0] = vec3(cos(angle), -sin(angle), 0.0);\n    rotz[1] = vec3(sin(angle), cos(angle), 0.0);\n    rotz[2] = vec3(0.0, 0.0, 1.0);\n    \n    rot *= rotz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _fragCoord = fragCoord;\n    float move = iTime;\n    lookFrom = vec3(0.0, -0.0, -move * 2.0);\n    \n    vec3 at = vec3(0.0, -0.0, -1.0);\n    \n    lookat(lookFrom + at);\n    \n    \n    rotateCamZ(sin(move * 0.5) * 0.5);\n    \n    Plane p;\n    p.position = vec3(0.0, -1.0, 1.0);\n    p.normal = vec3(0.0, 1.0, 0.0);\n    planes[0] = p;\n    fragColor = drawPlanes();\n    \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdSXzy","date":"1413210007","viewed":505,"name":"Checkerboard 3D","username":"kuvkar","description":"checkerboard on the move!","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","antialiasing"],"hasliked":0,"parentid":"","parentname":""}}