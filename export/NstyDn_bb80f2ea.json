{"ver":"0.1","info":{"id":"NstyDn","date":"1653304840","viewed":135,"name":"day2 draw seesaw","username":"ankye","description":"draw seesaw","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["seesaw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LINE_W 2.\n#define PI 3.141592653589793\n#define ARROW_SIZE .05\n#define ORANGE vec3(1, .3, 0)\n#define BLUE vec3(0, .3, 1)\n#define GREEN vec3(0, 1, 0)\n#define BLACK vec3(.3)\n#define MAX_MARCHING_STEPS 100\n\nstruct Surface {\n    vec2 a;\n    vec2 b;\n    vec2 origin;\n    vec2 normal;\n    float r;\n};\n\nvec4 drawBg(vec2 uv, inout vec4 col){\n    vec3 temp = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec4 layer= vec4(temp*0.5,0.7);\n   // float channelId = 2.3;\n   // layer = vec4(0.7,0.2,0.4,1.0);\n    //vec4 i=step(vec4(channelId),vec4(0.1,1.1,2.1,3.1));\n    //layer = layer * i;\n    col = mix(col,layer,layer.a);\n    return col;\n}\nvec2 rotate(vec2 uv, float angle){\n    vec2 q;\n    q.x =   cos(angle)*uv.x + sin(angle)*uv.y;\n    q.y = - sin(angle)*uv.x + cos(angle)*uv.y;\n    return q;\n}\n\nfloat circleSDF(vec2 uv,vec2 center,vec2 mul,float radius,float r) {\n    uv = rotate(uv,r);\n    vec2 tempPos = uv - center;\n    tempPos.x = tempPos.x * mul.x ;\n    tempPos.y = tempPos.y * mul.y ; \n    //求圆心距离\n    float d=length(tempPos)-radius;\n    \n    return d;\n}\n\n//输入参数(当前点位置，中心点位置，偏移，点的半径，颜色，与背景过渡的平滑值)\nvec4 drawCircle(vec2 uv,vec2 center,vec2 mul,float radius,float r,vec3 color,\n        float antialias,inout vec4 col){\n\n    //求圆心距离\n    float d= circleSDF(uv,center,mul,radius,r);\n    float t=smoothstep(0.,antialias,d);\n    vec4 layer = vec4(color,1.0-t);\n    col = mix(col,layer,layer.a);\n    return col;\n\n}\n\nfloat rectSDF(vec2 uv,vec2 center,float rect,float r){\n    uv = rotate(uv,r);\n    vec2 tempPos = uv - center;\n    float d = max(abs(tempPos.x),abs(tempPos.y))- rect;\n    return d;\n}\n\nvec4 drawRect(vec2 uv,vec2 center,float rect,float r,float antialias,vec3 color,inout vec4 col) {\n    float d = rectSDF(uv,center,rect,r);\n    float t = smoothstep(0.,antialias,d);\n    vec4 layer = vec4(color,1.0-t);\n    col = mix(col,layer,layer.a);\n    return col;\n}\n\nfloat lineBetween(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\nfloat shortestDistanceToRect(vec2 eye, vec2 center,float rect,float r,vec2 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = rectSDF(eye - depth * marchingDirection,center,rect,r);\n        if (dist < 0.001) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nfloat shortestDistanceToCircle(vec2 eye,vec2 center,vec2 mul,float radius,float r,vec2 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = circleSDF(eye - depth * marchingDirection,center,mul,radius,r);\n        if (dist < 0.001) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec2 estimateNormalCircle(vec2 p,vec2 center,vec2 mul,float radius,float r) {\n    float EPSILON = 0.001;\n    float x = circleSDF(vec2(p.x + EPSILON, p.y),center,mul,radius,r) - circleSDF(vec2(p.x - EPSILON, p.y),center,mul,radius,r);\n    float y = circleSDF(vec2(p.x, p.y + EPSILON),center,mul,radius,r) - circleSDF(vec2(p.x, p.y - EPSILON),center,mul,radius,r);\n    return normalize(vec2(x,y));\n}\n    \n\n// Piecewise Polynomial from https://iquilezles.org/articles/smoothsteps/\nfloat ss_pp(float a, float b, float n) {\n    float x = clamp((n - a) / (b - a), 0.0, 1.0);\n    const float P = 2.;\n    return (x < 0.5) ? 0.5 * pow(2.0 * x, 1.0 / P) : 1.0 - 0.5 * pow(2.0 * (1.0 - x), 1.0 / P);\n}\n\nvec2 reflectRay(vec2 inputRay, vec2 normal) {\n    return inputRay - 2. * normal * dot(normal, inputRay);\n    // uncomment to use the native function, actually the same thing\n    // return reflect(inputRay, normal);\n}\nvec4 visualizeLine(float d, float w, vec3 color, inout vec4 oc) {\n    vec4 layer = vec4(color,1.);\n    oc = mix(oc, layer, 1. - ss_pp(-w, w, d));\n    return oc;\n}\n\nvec4 visualizeLine(vec2 p, vec2 a, vec2 b, float w, vec3 color, inout vec4 oc) {\n    return visualizeLine(lineBetween(p, a, b), w, color, oc);\n}\n\n\nconst float ArrowAngle = 20. * PI / 180.;\nconst float ArrowCS = cos(ArrowAngle);\nconst float ArrowSS = sin(ArrowAngle);\n\nvec4 visualizeArrow(vec2 p, vec2 origin, vec2 n, float h, float w, vec3 color, inout vec4 oc) {\n    vec2 o2 = origin + n * h * 2.;\n    visualizeLine(p, origin, o2, w, color, oc);\n    \n    float a = atan(n.y, n.x);\n    \n    float cs = cos(a + PI), ss = sin(a + PI);\n    vec2 e1 = mat2(cs, ss, -ss, cs) * (vec2(ArrowCS, ArrowSS) * h);\n    visualizeLine(p, o2, o2 + e1, w, color, oc);\n    \n    cs = cos(a), ss = sin(a);\n    vec2 e2 = mat2(cs, ss, -ss, cs) * (vec2(ArrowCS, ArrowSS) * vec2(-h, h));\n    visualizeLine(p, o2, o2 + e2, w, color, oc);\n    \n    return oc;\n}\n\nvec4 visualizeWall(vec2 p, Surface wall, float w, vec3 color, inout vec4 oc) {\n    visualizeLine(p, wall.b, wall.a, w, color, oc);\n    visualizeArrow(p, wall.origin, wall.normal, ARROW_SIZE, w, color, oc);\n    return oc;\n}\n\nSurface getWall(vec2 a, vec2 b, float r) {\n    float cs = cos(r), ss = sin(r);\n    mat2 mat = mat2(cs, ss, -ss, cs);\n    a = mat * a;\n    b = mat * b;\n    vec2 d = b - a;\n    return Surface(a, b, a + d * .5, normalize(vec2(-d.y, d.x)),r);\n}\n\nfloat sat(float t) {\n    return clamp(t, 0.0, 1.0);\n}\nfloat remap01(float a, float b, float t) {\n    return sat((t - a) / (b - a));\n}\nfloat remap(float a, float b, float c, float d, float t) {\n    return remap01(a, b, t) * (d - c) + c;\n}\nvec4 drawNose(vec2 uv,vec2 center,float scale,float r,vec3 color,inout vec4 col) {\n    uv = rotate(uv,r);\n    vec2 p = uv - center;\n    p.x *= 0.7;\n    p.y += p.x * p.x +0.15*scale;\n    p *= 4.0/scale;\n    float d = length(p);\n    vec4 layer = vec4(color,1.);\n    layer.a = smoothstep(0.4, 0.39, d);\n   \n    col = mix(col,layer,layer.a);\n    return col;\n}\nvec4 drawMouth(vec2 uv,vec2 center,float scale,float r,vec3 color,inout vec4 col){\n    uv = rotate(uv,r);\n    vec2 p = uv - center;\n    p.x *= 0.49;\n    p.y -= p.x * p.x - 0.5*scale;\n    \n    p *= 2.5/scale;\n    float d = length(p);\n    vec4 layer = vec4(color,1.);\n    layer.a = smoothstep(0.4, 0.39, d);\n    \n    float td = 1.0-remap(-0.25, 0.25, 0.0, 1.0, p.y);\n    vec3 teeth_col = vec3(smoothstep(0.5, 0.3, d));\n\n    layer.rgb = mix(layer.rgb,teeth_col,smoothstep(0.05, 0.02, td));\n\n    float mtd = remap(-0.25, 0.3, 0.0, 1.0, p.y);\n    layer.rgb *= 1.0 - smoothstep(0.4, 0.0, mtd) * 0.2;\n\n    col = mix(col,layer,layer.a);\n    return col;\n}\n\nvec2 estimateNormalRect(vec2 p,vec2 center,float rect,float r) {\n    float EPSILON = 0.001;\n    float x = rectSDF(vec2(p.x + EPSILON, p.y),center,rect,r) - rectSDF(vec2(p.x - EPSILON, p.y),center,rect,r);\n    float y = rectSDF(vec2(p.x, p.y + EPSILON),center,rect,r) - rectSDF(vec2(p.x, p.y - EPSILON),center,rect,r);\n    return normalize(vec2(x,y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   //获取点的位置\n    //iResolution为屏幕的分辨率\n    //fragCoord为当前点的位置 原点是左下角\n    //返回的uv是以屏幕中心为原点\n    vec2 uv =(2.0*fragCoord.xy-iResolution.xy) /iResolution.y;\n    \n    float w = dFdx(uv.x) * LINE_W;\n\n    //圆的颜色\n    vec3 red=vec3(0.7,0,0);\n    vec3 red_light = vec3(0.8, 0.3, 0.2);\n    vec3 blue = vec3(0.2, 0.6, 0.9);\n    vec4 col = vec4(0.,0.,0.,1.);\n    vec3 gray = vec3(0.5);\n    vec3 gray_light = vec3(.7);\n    vec3 white = vec3(1.);\n    vec3 black = vec3(0.);\n    float speed  = 0.3;\n    float scale = clamp(sin(iTime*speed),0.3,0.4);\n    vec2 offset =  vec2(-clamp(cos(iTime*speed),-.8,.8),0);\n    float antialias = 0.01 * scale;\n    // bg\n    drawBg(uv,col);\n    \n    Surface wall = getWall(vec2(-.8, 0.), vec2(.8, 0.), cos(iTime *speed) * .2);\n    visualizeWall(uv, wall, w, GREEN, col);\n\n    \n    \n\n    //中心点\n    vec2 center = wall.origin+vec2(0.,scale)+offset;\n   \n    //身体\n    drawRect(uv,center+vec2(0.*scale,-0.7*scale), 0.3*scale,wall.r,antialias,blue,col);\n\n    // //左耳朵\n     drawCircle(uv,center+vec2(-0.4*scale,0.55*scale),vec2(1.,1.),0.3*scale,wall.r,white,antialias,col);\n    drawCircle(uv,center+vec2(-0.4*scale,0.55*scale),vec2(1.,1.0),0.2*scale,wall.r,gray_light,antialias,col);\n    // //右耳朵\n     drawCircle(uv,center+vec2(0.4*scale,0.55*scale),vec2(1.,1.),0.3*scale,wall.r,white,antialias,col);\n     drawCircle(uv,center+vec2(0.4*scale,0.55*scale),vec2(1.,1.),0.2*scale,wall.r,gray_light,antialias,col);\n    // //脸\n    drawCircle(uv,center,vec2(1.,1.),0.7*scale,wall.r,white,antialias,col);\n\n     //左眼\n    vec2 rightEyeP = center - vec2(0.3*scale,-0.1*scale);\n    drawCircle(uv,rightEyeP,vec2(1.,1.),0.2*scale,wall.r,gray_light,antialias,col);\n    float angle = sin(iTime)* 0.2 * 3.14159;\n    //左眼球\n    drawCircle(uv,rightEyeP+vec2(0.1*sin(angle)*scale,-0.1*cos(angle)*scale),vec2(1.,1.),0.1*scale,wall.r,black,antialias,col); \n    \n    //右眼\n    vec2 leftEyeP = center+vec2(0.3*scale,0.1*scale);\n    drawCircle(uv,leftEyeP,vec2(1.,1.),0.2*scale,wall.r,gray_light,antialias,col);\n    //左眼球\n    drawCircle(uv,leftEyeP+vec2(0.1*sin(angle)*scale,-0.1*cos(angle)*scale),vec2(1.,1.),0.1*scale,wall.r,black,antialias,col);\n    //鼻子\n    drawNose(uv,center,scale,wall.r,gray_light,col);\n    //嘴巴\n    drawMouth(uv,center,scale,wall.r,red_light,col);\n    \n    vec2 inputRay = normalize(vec2(-.6, .3) + vec2(cos(iTime) * .2 + .2, 0.));\n   \n     float   depth = shortestDistanceToCircle(inputRay,center+vec2(-0.4*scale,0.55*scale),vec2(1.,1.),0.3*scale,wall.r,normalize(inputRay),0.,1.);\n     vec2   origin = inputRay - depth*normalize(inputRay);\n     vec2   n = estimateNormalCircle(origin,center+vec2(-0.4*scale,0.55*scale),vec2(1.,1.),0.3*scale,wall.r);\n    \n\n    if( length(inputRay) - depth <= 0.001){\n        depth = shortestDistanceToCircle(inputRay,center,vec2(1.,1.),0.7*scale,wall.r,normalize(inputRay),0.,1.);\n        origin = inputRay - depth*normalize(inputRay);\n        n = estimateNormalCircle(origin,center,vec2(1.,1.),0.7*scale,wall.r);\n    }\n\n    if( length(inputRay) - depth <= 0.001){\n       depth = shortestDistanceToRect(inputRay,center+vec2(0.*scale,-0.7*scale), 0.3*scale,wall.r,normalize(inputRay),0.,1.);\n       origin = inputRay - depth*normalize(inputRay);\n       n = estimateNormalRect(origin,center+vec2(0.*scale,-0.7*scale), 0.3*scale,wall.r);\n    }\n    if( length(inputRay) - depth <= 0.001){\n        n = wall.normal;\n    }\n    vec2 reflectedRay = normalize(reflectRay(-inputRay, n));\n\n    visualizeLine(uv, inputRay, origin, w, ORANGE, col);\n    visualizeArrow(uv, origin + inputRay * .5, -inputRay, ARROW_SIZE, w, vec3(1, 0, 0), col);\n    \n    visualizeArrow(uv, origin,n, ARROW_SIZE, w, GREEN, col);\n\n    visualizeLine(uv, origin+reflectedRay, origin, w, BLUE, col);\n    visualizeArrow(uv, origin+reflectedRay*0.5,reflectedRay, ARROW_SIZE, w, vec3(0, 0, 1), col);\n    \n   \n\n    // 输出像素\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}