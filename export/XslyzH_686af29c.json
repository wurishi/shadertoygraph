{"ver":"0.1","info":{"id":"XslyzH","date":"1487514951","viewed":1471,"name":"[TDF2017] Schottky Waltz","username":"soma_arc","description":"Tokyo Demo Fest 2017 GLSL Graphics compo 1st place.\nPlay with circles.","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal","kleiniangroups","schottky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2017\nThis work is licensed under Creative Commons Attribution-ShareAlike 3.0 Unported.\n*/\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec2 circleInvert(vec2 pos, vec3 circle){\n\treturn ((pos - circle.xy) * circle.z * circle.z)/(length(pos - circle.xy) * length(pos - circle.xy) ) + circle.xy;\n}\n\nmat2 getRotationMat2(float angleRadians){\n\treturn mat2(cos(angleRadians), -sin(angleRadians),\n                sin(angleRadians), cos(angleRadians));\n}\nconst mat2 UNI_MAT = mat2(1, 0, 0, 1);\n\nconst float PI = 3.1415926535;\nconst float PI_2 = 3.1415926535/2.;\nconst float PI_4 = 3.1415926535/4.;\n\n\nconst float R = 100. * sqrt(2.) / 2.;\nvec3 c1 = vec3(100, 0, 0);\nvec3 c3 = vec3(-100, 0, 0);\nvec3 c2 = vec3(0, 100, 0);\nvec3 c4 = vec3(0, -100, 0);\nvec3 c5 = vec3(0);\n\nfloat l1Angle = PI_4;\nvec2 l1p = vec2(500, 0);\nmat2 l1m;\nmat2 l1mInv;\n\nfloat l2Angle = PI + PI_4;\nvec2 l2p = vec2(-800, 0);\nmat2 l2m;\nmat2 l2mInv;\n\nfloat l3Angle = PI + PI_4;\nvec2 l3p = vec2(-1500, 0);\nmat2 l3m;\nmat2 l3mInv;\n\nfloat l4Angle = PI_2 + PI_4;\nvec2 l4p = vec2(0, -1500);\nmat2 l4m;\nmat2 l4mInv;\n\nbool enableL1 = false;\nbool enableL2 = false;\nbool enableL3 = false;\nbool enableL4 = false;\n\nconst int MAX_ITERATIONS = 35;\nfloat IIS(vec2 pos){\n    float loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < MAX_ITERATIONS ; i++){\n\t\tcont = false;\n\t\t\n        if(length(pos - c1.xy) < c1.z){\n\t\t\tpos = circleInvert(pos, c1);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c2.xy) < c2.z){\n\t\t\tpos = circleInvert(pos, c2);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c3.xy) < c3.z){\n\t\t\tpos = circleInvert(pos, c3);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c4.xy) < c4.z){\n\t\t\tpos = circleInvert(pos, c4);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(length(pos - c5.xy) < c5.z){\n\t\t\tpos = circleInvert(pos, c5);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}\n        \n        if(enableL1){\n        \tpos -= l1p;\n        \tpos = l1mInv * pos;\n        \tif(pos.x > 0.){\n        \t\tpos.x *= -1.;\n            \tloopNum++;\n            \tcont = true;\n        \t}\n        \tpos = l1m * pos;\n        \tpos += l1p;\n        }\n        \n        if(enableL2){\n        pos -= l2p;\n        pos = l2mInv * pos;\n        if(pos.x > 0.){\n        \tpos.x *= -1.;\n            loopNum++;\n            cont = true;\n        }\n        pos = l2m * pos;\n        pos += l2p;\n        }\n        \n        if(enableL3){\n        pos -= l3p;\n        pos = l3mInv * pos;\n        if(pos.x > 0.){\n        \tpos.x *= -1.;\n            loopNum++;\n            cont = true;\n        }\n        pos = l3m * pos;\n        pos += l3p;\n        }\n         \n        if(enableL4){\n        \tpos -= l4p;\n        \tpos = l4mInv * pos;\n        \tif(pos.x > 0.){\n        \t\tpos.x *= -1.;\n            \tloopNum++;\n\t\t\t\tcont = true;\n        \t}\n        \tpos = l4m * pos;\n        \tpos += l4p;\n        }\n        \n\t\tif(cont == false) break;\n\t}\n\n\treturn loopNum;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//w: start time\n//s: duration\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst float SAMPLE_NUM = 20.;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec3 sum = vec3(0);\n    float t = mod(iTime, 20.);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    enableL1 = enableL2 = enableL3 = enableL4 = false;\n\n\tfloat start = 0.;\n    c1.z = mix(0., R, expEasingIn(scene(t, start, 1.)));\n    c2.z = mix(0., R, expEasingIn(scene(t, start + .1, 1.)));\n\tc3.z = mix(0., R, expEasingIn(scene(t, start + .3, 1.)));\n\tc4.z = mix(0., R, expEasingIn(scene(t, start + .5, 1.)));\n    \n    float rotationStart = start + 1.7;\n    float scaleFactor = 150.;    \n    float theta = mix(0., 2. * PI + PI_4, circEasingInOut(scene(t, rotationStart, 1.)));\n    scaleFactor += mix(0., 800., circEasingInOut(scene(t, rotationStart, 1.)));\n        \n\tl1p.x = mix(1500., 200., expEasingIn(scene(t, rotationStart, 1.)));\n\tl2p.x = mix(-1500., -200., expEasingIn(scene(t, rotationStart, 1.5)));\n    enableL1 = t > rotationStart + .5;\n    enableL2 = t > rotationStart + .5;\n    \n\tfloat lineStart = rotationStart + 1.5;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, lineStart, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, lineStart, 1.)));\n    float lpRotateAngle1 = mix(0., PI_2, circEasingInOut(scene(t, lineStart, 1.)));\n   \tl3p.x = mix(-1500., -200., expEasingIn(scene(t, lineStart, 1.)));\n    enableL3 = t > lineStart;\n    \n    float rotateStart2 = lineStart + 1.1;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart2, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart2, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart2, 1.)));    \n\tlpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart2, 1.)));    \n    l4p.y = mix(-1500., -200., expEasingIn(scene(t, rotateStart2, 1.)));\n    enableL4 = t > rotateStart2;\n    \n    float rotateStart3 = rotateStart2 + 1.1;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart3, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart3, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart3, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart3, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart3, 1.)));    \n\tfloat lpRotateAngle2 = mix(0., PI_2, circEasingInOut(scene(t, rotateStart3, 1.))); \n\n    float rotateStart4 = rotateStart3 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart4, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart4, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart4, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart4, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart4, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart4, 1.))); \n    scaleFactor += mix(0., -600., circEasingInOut(scene(t, rotateStart4, 1.)));\n\n    float rotateStart5 = rotateStart4 + 1.1;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart5, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart5, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart5, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart5, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart5, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart5, 1.))); \n \n    float rotateStart6 = rotateStart5 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart6, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart6, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart6, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart6, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart6, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart6, 1.))); \n    \n    float rotateStart7 = rotateStart6 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart7, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart7, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart7, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart7, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart7, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart7, 1.)));\n    \n    float rotateStart8 = rotateStart7 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart8, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart8, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart8, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart8, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart8, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart8, 1.)));\n\n    float rotateStart9 = rotateStart8 + 1.3;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart9, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart9, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart9, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart9, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart9, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart9, 1.)));\n\n    float rotateStart10 = rotateStart9 + 1.2;\n    l1Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart10, 1.)));\n    l2Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart10, 1.)));\n\tl3Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart10, 1.)));  \n   \tl4Angle += mix(0., PI_2 , circEasingInOut(scene(t, rotateStart10, 1.)));\n    lpRotateAngle1 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart10, 1.)));    \n\tlpRotateAngle2 += mix(0., PI_2, circEasingInOut(scene(t, rotateStart10, 1.)));\n        \n    \n    float circleStart = rotateStart5;\n    float deformR = 100.;\n    c1.z += mix(0., deformR, expEasingOut(scene(t, rotateStart5, 1.)));\n    c1.z += mix(0., -deformR, expEasingOut(scene(t, rotateStart6, 1.)));\n\t\n\tc3.z += mix(0., deformR, expEasingOut(scene(t, rotateStart6, 1.)));\n  \tc3.z += mix(0., -deformR, expEasingOut(scene(t, rotateStart7, 1.)));\n\n    c5.z += mix(0., 50., circEasingInOut(scene(t, rotateStart7, 1.)));\n    \n    scaleFactor += mix(0., -300., circEasingInOut(scene(t, rotateStart7, 1.)));\n    scaleFactor /= mix(1., 4., circEasingInOut(scene(t, rotateStart8, 1.)));\n    scaleFactor /= mix(1., 4., circEasingInOut(scene(t, rotateStart9, 1.)));\n    scaleFactor /= mix(1., 4., circEasingInOut(scene(t, rotateStart10, 1.)));\n\n    float endingStart = rotateStart10 + 1.3;\n    if(t >= endingStart){\n        \n        float rotateStart11 = endingStart;\n   \t\tl1Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart11, 1.)));\n    \tl2Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart11, 1.)));\n\t\tl3Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart11, 1.)));  \n   \t\tl4Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart11, 1.)));\n    \tlpRotateAngle1 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart11, 1.)));    \n\t\tlpRotateAngle2 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart11, 1.)));\n        \n        float rotateStart12 = rotateStart11 + 1.3;\n   \t\tl1Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart12, 1.)));\n    \tl2Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart12, 1.)));\n\t\tl3Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart12, 1.)));  \n   \t\tl4Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart12, 1.)));\n    \tlpRotateAngle1 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart12, 1.)));    \n\t\tlpRotateAngle2 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart12, 1.)));\n        \n        float rotateStart13 = rotateStart12+1.3;\n   \t\tl1Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart13, 1.)));\n    \tl2Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart13, 1.)));\n\t\tl3Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart13, 1.)));  \n   \t\tl4Angle -= mix(0., PI_2 , circEasingInOut(scene(t, rotateStart13, 1.)));\n    \tlpRotateAngle1 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart13, 1.)));    \n\t\tlpRotateAngle2 -= mix(0., PI_2, circEasingInOut(scene(t, rotateStart13, 1.)));\n        \n        \n        float endingTime = 1.;\n   \t\t\n\t\tc5.z  = mix(50., 0., circEasingInOut(scene(t, rotateStart12, endingTime)));\n        l1p.x = mix(200., 5000., circEasingIn(scene(t, rotateStart13, endingTime)));  \n\t\tl2p.x = mix(-200., -5000., circEasingIn(scene(t, rotateStart13, endingTime)));\n    \tl3p.y = mix(0., -5000., circEasingIn(scene(t, rotateStart13, endingTime)));  \n\t\tl4p.y = mix(-200., -5000., circEasingIn(scene(t, rotateStart13, endingTime)));\n        c1.z = mix(R, 0., circEasingInOut(scene(t, rotateStart13, endingTime)));\n    \tc2.z = mix(R, 0., circEasingInOut(scene(t, rotateStart13, endingTime)));\n\t\tc3.z = mix(R, 0., circEasingInOut(scene(t, rotateStart13, endingTime)));\n\t\tc4.z = mix(R, 0., circEasingInOut(scene(t, rotateStart13, endingTime)));\n\n        theta += mix(0., -PI_2, circEasingInOut(scene(t, rotateStart13, 1.)));\n\n        scaleFactor *= mix(1., 650., circEasingInOut(scene(t, endingStart, 1.)));\n\n    }\n    \n    mat2 lpRotate1 = getRotationMat2(lpRotateAngle1);    \n    l1m = getRotationMat2(l1Angle);\n    l1mInv = getRotationMat2(-l1Angle);\n    l2m = getRotationMat2(l2Angle);\n    l2mInv = getRotationMat2(-l2Angle);\n    l3m = getRotationMat2(l3Angle);\n    l3mInv = getRotationMat2(-l3Angle);    \n\tl4m = getRotationMat2(l4Angle);\n    l4mInv = getRotationMat2(-l4Angle); \n    \n    l1p = lpRotate1 * l1p;\n\tl2p = lpRotate1 * l2p;\n\tl3p = lpRotate1 * l3p;\n    \n    mat2 lpRotate2 = getRotationMat2(lpRotateAngle2);    \n \tl4p = lpRotate2 * l4p;    \n    \n    mat2 m = getRotationMat2(theta);    \n\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + rand2n(fragCoord.xy, i)) / iResolution.yy ) - vec2(ratio, 0.5);\n        \n        position = position * scaleFactor;\n        position = m * position;\n        \n        \n        float loopNum = IIS(position);\n\n        if(loopNum >  0.){\n            sum += hsv2rgb(vec3(0.01 + 0.05 * (loopNum-1.),1.0,1.0));\n        }\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}\n","name":"Image","description":"","type":"image"}]}