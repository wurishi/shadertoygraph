{"ver":"0.1","info":{"id":"XllBzs","date":"1513074257","viewed":236,"name":"try normal computation","username":"cailuming","description":"Alright,I just try to compute normal through the given formula","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["normal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 32\n#define PI 3.1415926\nstruct Ray{\n   vec3 o;\n   vec3 d;\n};\n    \nstruct Sphere{\n   vec3 polor;\n   vec3 normal;\n   vec3 center;\n   float radius;\n    \n};\n\nvoid rotationY(inout vec3 p,float arc){\n   float x=0.;\n   float z=0.;\n   x=p.x*cos(arc)-p.z*sin(arc);\n   z=p.x*sin(arc)+p.z*cos(arc);\n   \n   p.x=x;\n   p.z=z;\n}\n\nvec3 ObjA(vec3 pr,vec3 lightPos,vec3 center,float lod){\n    vec3 p= pr-center;\n    \n    rotationY(p,iTime*0.8);   \n    \n    vec2 uv=vec2(atan(p.y,p.x),abs(acos(dot(vec3(0,0,1),normalize(p))))); \n    vec3 pu =vec3(0);\n    vec3 pv =vec3(0);\n    \n    float a =1.+texture(iChannel0,vec2(0,0)).x;\n    float b= -0.3*sin(uv.y*lod);\n    float c = 5.;\n    float r =a+b*sin(c*uv.x);\n    float nl=0.;\n    \n    float xu=-a*sin(uv.x)*sin(uv.y)+(b*c*cos(c*uv.x)*cos(uv.x)-b*sin(c*uv.x)*sin(uv.x))*sin(uv.y);\n    float yu=a*cos(uv.x)*sin(uv.y)+(b*c*cos(c*uv.x)*sin(uv.x)+b*sin(c*uv.x)*cos(uv.x))*sin(uv.y);\n    float zu =b*c*cos(c*uv.x)*cos(uv.y);\n    \n    float xv=(a+b*sin(c*uv.x))*cos(uv.x)*cos(uv.y);\n    float yv=(a+b*sin(c*uv.x))*sin(uv.x)*cos(uv.y);\n    float zv =-sin(uv.y)*(a+b*sin(c*uv.x));\n    \n   // sphere formula\n    vec3 polor=vec3(r*cos(uv.x)*sin(uv.y),r*sin(uv.x)*sin(uv.y),r*cos(uv.y));\n          \n    pu=vec3(xu,yu,zu);\n \n    pv=vec3(xv,yv,zv);\n    \n    // normal of the sphere\n    vec3 normal=normalize(cross(pv,pu));\n    \n    vec3 lightDir =normalize(lightPos-polor);\n    rotationY(normal,-iTime*0.8);   \n    \n    nl= clamp(dot(normal,lightDir),0.3,1.);\n    \n    return vec3(length(p-polor)-1.,nl,pr.z);\n}\n\nvec3 map(vec3 p,vec3 lightPos){\n   vec3 res= vec3(0);\n   vec3 ref=vec3(0);\n   \n   ref=ObjA(p,lightPos,vec3(3.*cos(iTime),0,8.+4.*sin(iTime)),(5.+4.*sin(iTime)));\n   \n   res=ObjA(p,lightPos,vec3(5.*cos(iTime+PI),3.*cos(iTime),5.+6.*sin(iTime+PI)),1.);\n    \n   if(ref.x>res.x) {ref=res;}\n      \n   return ref;\n}\n\nvec2 rayHit(Ray ray,vec3 lightPos){\n    vec3 res=vec3(0);\n    float steps=1.;\n    float isHit =0.;\n    vec3 p=vec3(0);\n     \n    for(int i=0;i<FAR;i++){\n       p=ray.o+ray.d*steps;\n       \n       res=map(p,lightPos);\n       \n       if(res.x<0.001){\n           isHit=1.;\n           break;\n       }\n       steps+=res.x;\n    }\n    \n    return vec2(res.y,isHit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5);\n    float aspect = iResolution.x/iResolution.y;\n    vec3 screenP = vec3(uv.x*aspect,uv.y,-10);\n    vec3 eyePos =vec3(0,0.0,-11.1);\n    vec3 center =vec3(0,0,0); \n    vec3 lightPos=vec3(6.,9.,-6.);\n    vec3 col =vec3(0);\n    \n    Ray ray =Ray(eyePos,normalize(screenP-eyePos));\n    \n    Sphere sp;\n    vec2 hit =rayHit(ray,lightPos);\n    \n    float nl=hit.x;\n    \n    nl+=mix(pow(nl,20.),pow(nl,30.),0.7);\n   \n    if(hit.y<=0.){\n       nl=0.;\n    } \n    \n    col=vec3(nl)*vec3(sin(0.5*iTime)*0.3+0.6,0.8+0.4*cos(iTime),0.6);\n    fragColor = vec4(col,1);\n\t\n}","name":"Image","description":"","type":"image"}]}