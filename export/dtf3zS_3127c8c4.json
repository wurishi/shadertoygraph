{"ver":"0.1","info":{"id":"dtf3zS","date":"1671913323","viewed":56,"name":"TESTE","username":"b11","description":"cores","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_OCTAVES 8\n#define octaves 1.\n#define persistence 0.5\n#define lacunarity 2.\n#define offset 0.\n#define multiplier  1.\n#define scale 10. \n#define speed 0.5\n\n\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+10.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//\n// Compatibility layer with demo\n//\nfloat noise3(vec3 p) {\n  return cnoise(p);\n}\n\n\nfloat octaveNoise (vec3 p) {\n  float total = 0.;\n  float frequency = 1.;\n  float amplitude = 1.;\n  float value = 0.;\n  for (int i = 0; i < MAX_OCTAVES; ++i) {\n    if (float(i) >= octaves) break;\n    value += noise3(p * frequency) * amplitude;\n    total += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n  return value / total;\n}\n\nfloat getNoiseColor( vec3 p ) {\n  return offset + multiplier * octaveNoise(vec3 (scale*p + speed*iTime));\n}\n\n//upper part classic noise \n//=======================lower worley noise=========================================\n\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash(i+vec3(0.0,0.0,0.0));\n    float b = hash(i+vec3(1.0,0.0,0.0));\n    float c = hash(i+vec3(0.0,1.0,0.0));\n    float d = hash(i+vec3(1.0,1.0,0.0));\n    float e = hash(i+vec3(0.0,0.0,1.0));\n\tfloat f = hash(i+vec3(1.0,0.0,1.0));\n    float g = hash(i+vec3(0.0,1.0,1.0));\n    float h = hash(i+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n\nfloat noise4(vec3 p) {\n  vec4 v = noised(p);\n  return v.x; \n}\n\nfloat fbmNoise (vec3 p) {\n  float total = 0.;\n  float frequency = 1.;\n  float amplitude = 1.;\n  float value = 0.;\n  for (int i = 0; i < MAX_OCTAVES; ++i) {\n    if (float(i) >= octaves) break;\n    value += noise4(p * frequency) * amplitude;\n    total += amplitude;\n    amplitude *= persistence;\n    frequency *= lacunarity;\n  }\n  return value / total;\n}\n\nfloat getFbmNoiseColor( vec3 p ) {\n  return offset + multiplier * fbmNoise (vec3 (scale*p + speed*iTime));\n}\n\n//==================upper worley noise ==================================\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define PI 3.1415925359\n\n// Rotation matrix.\nmat2 Rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// SDF of a torus at the origin given its two radius.\nfloat dTorus(vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    \n    return length(vec2(x, p.y)) - r.y;\n}\n\n// SDF of a box at the origin given its size (width, height and depth).\n\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\n// SDF of a sphere, given its center and radius.\nfloat dSphere(vec3 p, vec4 s) {\n    return length(p - s.xyz) - s.w;\n}\n\n// SDF of a cylinder given a segment and a radius.\n\n// B + A\nfloat unionSDF (float sda, float sdb) {\n    return min(sda, sdb);\n}\n\n// B * A\nfloat intersectionSDF (float sda, float sdb) {\n    return max(sda, sdb);\n}\n\n// B - A\nfloat differenceSDF (float sda, float sdb) {\n    return max(-sda, sdb);\n}\n\n// Blend A and B\nfloat blendSDF(float sda, float sdb, float k) {\n    float h = clamp(0.5 + 0.5 * (sdb - sda) / k, 0.0, 1.0);\n    return mix(sdb, sda, h) - k * h * (1.0 - h);\n}\n\n// Scene SDF: signed distance function.\nfloat getDist(vec3 p) {\n    float planeDist = p.y;\n    \n    float s = sin(iTime);\n    \n    vec3 bp = p - vec3(3, 0.75, 7);\n    bp.xz *= Rot(iTime);\n    \n    vec3 tp = p - vec3(0, 0.5, 6);\n    tp.y -= s;\n    \n    vec3 bp2 = p - vec3(-3, 0.75, 6);\n    bp2.y -= -s;\n    \n    float cx = -3.0;\n    cx -= s;\n    \n    vec3 a = vec3(0, 0.3, 3);\n    vec3 b = vec3(3, 0.3, 5);\n    vec3 ab = normalize(b - a).zyx;\n    ab.x = -ab.x;\n    a -= s * ab;\n    b -= s * ab;\n    \n    float sd  = dSphere(p, vec4(0, 1, 6 , 1));\n    //float sd2 = dSphere(p, vec4(-3, 0.5, 6, 1.0));\n    //float td  = dTorus (tp, vec2(1.5, 0.3));\n    float bd  = dBox(bp, vec3(0.75));\n    float bd2 = dBox(bp2, vec3(0.75));\n    //float cd  = dCylinder(p, a, b, 0.3);\n    \n    float sd3 = dSphere(p, vec4(cx, 3, 8, 1));\n    float sd4 = dSphere(p, vec4(-2, 3, 8, 1));\n    \n    float d = min(sd, planeDist);\n    //d = min(d, td);\n    //d = min(d, cd);\n    d = min(d, bd);\n    d = min(d, bd2);\n    //d = min(differenceSDF(sd2, bd2), d);\n    //d = min(blendSDF(sd3, sd4, 0.2), d);\n    \n    return d;\n}\n\nconst int MAT_SPHERE = 1;\nconst int MAT_BOX = 2;\nconst int MAT_BOX2 = 3;\n\nint getMat(vec3 p) {\n    float planeDist = p.y;\n    \n    float s = sin(iTime);\n    \n    vec3 bp = p - vec3(3, 0.75, 7);\n    bp.xz *= Rot(iTime);\n    \n    vec3 tp = p - vec3(0, 0.5, 6);\n    tp.y -= s;\n    \n    vec3 bp2 = p - vec3(-3, 0.75, 6);\n    bp2.y -= -s;\n    \n    float cx = -3.0;\n    cx -= s;\n    \n    vec3 a = vec3(0, 0.3, 3);\n    vec3 b = vec3(3, 0.3, 5);\n    vec3 ab = normalize(b - a).zyx;\n    ab.x = -ab.x;\n    a -= s * ab;\n    b -= s * ab;\n    \n    float sd  = dSphere(p, vec4(0, 1, 6 , 1));\n    //float sd2 = dSphere(p, vec4(-3, 0.5, 6, 1.0));\n    //float td  = dTorus (tp, vec2(1.5, 0.3));\n    float bd  = dBox(bp, vec3(0.75));\n    float bd2 = dBox(bp2, vec3(0.75));\n    //float cd  = dCylinder(p, a, b, 0.3);\n    \n    float sd3 = dSphere(p, vec4(cx, 3, 8, 1));\n    float sd4 = dSphere(p, vec4(-2, 3, 8, 1));\n    \n    float d = min(sd, planeDist);\n    //d = min(d, td);\n    //d = min(d, cd);\n    d = min(d, bd);\n    d = min(d, bd2);\n    //d = min(differenceSDF(sd2, bd2), d);\n    //d = min(blendSDF(sd3, sd4, 0.2), d);\n    \n    int mat = 0;\n    \n    if(d == sd){\n        mat = MAT_SPHERE;\n    }\n    else if(d >= bd){\n        mat = MAT_BOX;\n    }\n    else if(d >= bd2){\n        mat = MAT_BOX2;\n    }\n    \n    \n    return mat;\n}\n\n\n// Walk through empty spheres until the ray hits an object\n// or is beyond MAX_DIST, meaning no hit. \nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    return dO;\n}\n\n// The normal is the gradient of the SDF scalar field at point p.\n// By using finite difference: \n// https://en.wikipedia.org/wiki/Finite_difference#Relation_with_derivatives \nvec3 getNormal(vec3 p) {\n    // arbitrary — should be smaller than any surface detail in your distance function, \n    // but not so small as to get lost in float precision\n    vec2 e = vec2(0.001, 0);\n    \n    vec3 n = \n        vec3(\n        getDist(p + e.xyy),\n        getDist(p + e.yxy),\n        getDist(p + e.yyx)) - \n        vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\n// Phong illumination model, given a point and camera position.\nfloat getLight(vec3 p, vec3 ro) {\n    vec3 lightPos = vec3(0, 5, 6);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.0;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    vec3 r = reflect(-l,n);\n    \n    // ambient component\n    float amb = 0.1;\n    // ambient reflection coefficient\n    float ka = 1.0;\n    \n    // diffuse component - apply Lambert's cosine law\n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    // diffuse reflection coefficient\n    float kd = 0.8;\n    \n    // specular component\n    float shininess = 100.;\n    vec3 v = normalize(ro-p);\n    float spec = clamp(dot(r, v), 0.0, 1.0);\n    spec = pow(spec,shininess);\n    // specular reflection coefficient\n    float ks = 1.0;\n    \n    // slightly move point p in the direction of the normal,\n    // so the distance is not zero. Otherwise, the first hit \n    // will be at the plane.\n    float d = rayMarch(p + 2. * n * SURF_DIST , l);\n    \n    // cast a ray to the light\n    if (d < length(lightPos - p)) {\n        // point in the shadow\n        dif *= 0.1;\n        spec *= 0.5;\n    }\n    \n    // ambient + diffuse + specular components\n    return ka * amb + kd * dif + ks * spec;\n}\n\n// Fragment shader.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // camera position\n    vec3 ro = vec3(0, 3, 0);\n    \n    // projection plane z = 1\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Rotate camera down about the x-axis\n    rd.yz *= Rot(PI * 10. / 200.); \n    \n    float d = rayMarch(ro, rd);\n    \n    // point hit by the ray\n    vec3 p = ro + rd * d;\n    \n    // illumination at point p\n    float light_intensity = getLight(p, ro);\n    \n    // dark grey\n    // vec3 background_color = vec3(.2, .2, .2);\n    vec3 background_color = texture(iChannel0, uv*vec2(1.,2.)).rgb;\n    \n    // Antique White color #FAEBD7\n    vec3 surface_color = vec3(250, 235, 215) / 90.;\n    \n    // pixel color\n    vec3 color;\n    \n    if (d < MAX_DIST){\n        // modulate surface color by the light intensity\n        color = surface_color * vec3(light_intensity);\n        int mat = getMat(p);\n        \n        if(mat == MAT_SPHERE){\n            color *= getNoiseColor(p);\n        }\n        else if (mat == MAT_BOX){\n            color *= vec3(0.,0.,1.);\n        }\n        else if (mat == MAT_BOX2){\n            color *= getFbmNoiseColor(p );\n        }\n        \n    }\n    else{ \n        color = background_color;\n        }\n\n    // output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}