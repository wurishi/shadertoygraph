{"ver":"0.1","info":{"id":"sdK3Dm","date":"1631705952","viewed":103,"name":"SDF exp","username":"green92","description":"sdf","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdfunion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct Inter {\n    float t;\n    vec3 n;\n    vec3 c;\n};\n\nRay CameraRay(vec2 pix, vec3 camPos, vec3 camTarget) {\n    vec2 pixm11 = 2.0 * pix / iResolution.xy - 1.0;\n    vec3 f = normalize(camTarget - camPos);\n    vec3 r = cross(f, vec3(0, 0, 1));\n    vec3 up = cross(r, f);\n    float ar = iResolution.y / iResolution.x;\n    return Ray(camPos, normalize(pixm11.x * r + pixm11.y * ar * up + f));\n}\n\nfloat SphereDist(vec3 center, float r, vec3 p) {\n    return length(p - center) - r;\n}\n\nfloat AABBDist(vec3 lower, vec3 upper, vec3 p) {\n    p -= (lower+upper) * 0.5;\n    vec3 b = upper - lower;\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//https://iquilezles.org/articles/distfunctions\nfloat OpSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat SpheresUnion(vec3 p) {\n    vec3 s1c = vec3(0, sin(iTime / 2.0), cos(0.5*iTime));\n    vec3 s2c = vec3(0, cos(iTime / 10.0), sin(iTime));\n    vec3 s3c = vec3(sin(iTime), sin(iTime), 0.5);\n    float r = 1.0;\n    float d1 = SphereDist(s1c, 1.0, p);\n    float d2 = SphereDist(s2c, 1.0, p);\n    float d3 = SphereDist(s3c, 0.8, p);\n    float d4 = AABBDist(vec3(-0.25, -0.25, 0.25), vec3(0.25, 0.25, 0.75), p);\n    return OpSmoothUnion(OpSmoothUnion(OpSmoothUnion(d1, d2, 0.5), d3, 0.5), d4, 0.5);\n}\n\n#define f(p) SpheresUnion(p)\n\n//https://iquilezles.org/articles/normalsSDF\nvec3 CalcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*f( p + k.xyy*h ) + \n                      k.yyx*f( p + k.yyx*h ) + \n                      k.yxy*f( p + k.yxy*h ) + \n                      k.xxx*f( p + k.xxx*h ) );\n}\n\nInter RayMarch(Ray r) {\n    const int maxIter = 50;\n    vec3 p = r.o;\n    float t = 0.0;\n    float prevMinDist = 1e9;\n    for (int i=0; i<maxIter; i++) {\n        p = r.o + t * r.d;\n        float minDist = SpheresUnion(p);\n        if (minDist < 1e-2) {\n            return Inter(t, CalcNormal(p), vec3(0, 1, 0));\n        }\n        if (minDist - prevMinDist > 10.0) {\n            return Inter(1e9, vec3(0), vec3(0));\n        }\n        prevMinDist = minDist;\n        t += minDist;\n    }\n    return Inter(1e9, vec3(0), vec3(0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3(vec2(cos(iTime), sin(iTime)) * 5.0, 10);\n    vec3 camTarget = vec3(0, 0, 0);\n    vec3 L = normalize(camTarget - camPos);\n    const vec3 E = vec3(0.9, 0.9, 0.9);\n    Ray r = CameraRay(fragCoord, camPos, camTarget);\n\n    Inter i = RayMarch(r);\n    vec3 col = vec3(0);\n    \n    if (i.t < 1e9) {\n        col = dot(-L, i.n) * E * i.c;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}