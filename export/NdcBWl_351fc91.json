{"ver":"0.1","info":{"id":"NdcBWl","date":"1657395867","viewed":168,"name":"Ray Marching with Smooth Min","username":"mattdeeds","description":"A second attempt at ray marching.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define kDistanceToScreen 2.0\n#define kOutsideSteps 32\n#define kInsideSteps 16\n\nmat3 rotation3dX(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    1.0, 0.0, 0.0,\n    0.0, c, s,\n    0.0, -s, c\n  );\n}\n\nmat3 rotation3dY(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, 0.0, -s,\n    0.0, 1.0, 0.0,\n    s, 0.0, c\n  );\n}\n\n\nmat3 rotation3dZ(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n\n  return mat3(\n    c, s, 0.0,\n    -s, c, 0.0,\n    0.0, 0.0, 1.0\n  );\n}\n\nfloat sdfSphere(in vec3 pos, in vec3 center, in float radius) {\n  return length(pos - center) - radius;\n}\n\nfloat sdfCube(in vec3 pos, in vec3 center, in float radius) {\n  vec3 rel_pos = pos - center;\n  rel_pos = rotation3dX(iTime) * rel_pos;\n  return length(max(abs(rel_pos) - radius,0.0));\n}\n\nfloat smoothMin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0) / k;\n  return min(a, b) - h * h * h * k * 1.0 / 6.0;\n}\n\nfloat sdfWob(in vec3 pos, in vec3 center, in float radius) {\n  return smoothMin(\n    sdfSphere(pos, center, radius), \n    sdfCube(pos, center, radius * 0.7), 0.5 * (1.0 + cos(iTime * 0.2)));\n}\n\nfloat sdf(in vec3 pos) {\n  return sdfWob(pos, vec3(0.0, 0.0, -5.0), 2.0);\n}\n\n// https://michaelwalczyk.com/blog-ray-marching.html\nvec3 calculate_normal(in vec3 pos)\n{\n  const vec3 del = vec3(0.1, 0.0, 0.0);\n\n  vec3 normal = vec3(\n    sdf(pos + del.xyy) - sdf(pos - del.xyy),\n    sdf(pos + del.yxy) - sdf(pos - del.yxy),\n    sdf(pos + del.yyx) - sdf(pos - del.yyx));\n  return normalize(normal);\n}\n\nvec2 getDepth(vec3 ray_origin, vec3 ray_direction, float end) {\n  float depth = 0.0;\n  vec3 ray_position = ray_origin;\n  for (int i = 0; i < kOutsideSteps; ++i) {\n      float distance = sdf(ray_position);\n      depth += distance;\n      if (distance < 0.01) {\n       return vec2(depth, float(i));\n      }\n      if (depth >= end) {\n        return vec2(end, float(i));\n      }\n      ray_position += ray_direction * distance;\n  }\n  return vec2(depth, float(kOutsideSteps));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * (fragCoord - (iResolution.xy * 0.5)) / iResolution.yy;\n\n    vec2 mouseUV = 8.0 * (iMouse.xy - (iResolution.xy * 0.5)) / iResolution.yy;\n    if (length(iMouse) == 0.0) {\n      mouseUV = vec2(0.0);\n    }\n\n    mat3 tx = rotation3dY(mouseUV.x) * rotation3dX(-mouseUV.y);\n\n    vec3 view = normalize(vec3(uv.x, uv.y, -kDistanceToScreen));\n    view = normalize(tx * view);\n    \n    vec2 depth = getDepth(vec3(0.0), view, 10.0);\n    vec3 normal = calculate_normal(view * depth.x);\n\n    vec3 glow = vec3(0.3, 0.5, 1.0) * pow(depth.y / float(kOutsideSteps - 1), 1.8);\n    vec3 col = glow;\n    if (depth.x < 10.0) {\n      col += normal; // It looks like my normal is broken.\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}