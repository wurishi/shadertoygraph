{"ver":"0.1","info":{"id":"NdlyzX","date":"1642446652","viewed":611,"name":"Capsule / Line SDF","username":"Envy24","description":"Source: https://iquilezles.org/articles/distfunctions2d/\n\nExperimenting with capsule sdf.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf","rasterization","capsule"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                       iResolution\n#define AR                     ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define NZMX                   ( (iMouse.x+iMouse.x-R.x) / R.x )  // in range [-1.0; 1.0]\n#define NZMY                   ( (iMouse.y+iMouse.y-R.y) / R.y )  // in range [-1.0; 1.0]\n\nfloat capsuleSDF(\n    in vec2 P,   // Sample coordinates\n    in vec2 B,   // Capsule begin coordinates\n    in vec2 E,   // Capsule end coordinates\n    in float R)  // Thickness\n{\n    vec2 BP = P - B; // from B to P\n    vec2 BE = E - B; // from B to E\n    \n    // dot(SP, SE) - squared length of projection SP to SE.\n    // dot(SE, SE) - capsule squared length.\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n\n    // Minimal distance from P to line BE * t.\n    vec2 K = BP - BE * t;\n\n    return sqrt(dot(K, K)) - R;\n    //return abs(sqrt(dot(K, K)) - R); // outline\n}\n\nfloat capsuleSDFS(\n    in vec2 P,   // Sample coordinates\n    in vec2 B,   // Capsule begin coordinates\n    in vec2 E,   // Capsule end coordinates\n    in float R,  // Thickness\n    in float SM) // Smoothness\n{\n    vec2 BP = P - B; // from B to P\n    vec2 BE = E - B; // from B to E\n    \n    // dot(SP, SE) - length of projection SP to SE.\n    // dot(SE, SE) - capsule squared length.\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n\n    // Minimal distance from P to line BE * t.\n    vec2 K = BP - BE * t;\n\n    float sdf = sqrt(dot(K, K)) - R;\n\n    return smoothstep(-SM, SM, sdf);\n    //return smoothstep(-SM, SM, abs(sdf)); // outline\n}\n\nfloat capsuleSQSDF(\n    in vec2 P,     // Sample coordinates\n    in vec2 B,     // Capsule begin coordinates\n    in vec2 E,     // Capsule end coordinates\n    in float R,    // Thickness\n    in float sqSM) // Squared Smoothness\n{\n    vec2 BP = P - B; // from B to P\n    vec2 BE = E - B; // from B to E\n    \n    // dot(SP, SE) - length of projection SP to SE.\n    // dot(SE, SE) - capsule squared length.\n    float t = clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0);\n\n    // Minimal distance from P to line BE * t.\n    vec2 K = BP - BE * t;\n\n    return smoothstep(-sqSM, sqSM, dot(K, K) - R*R);\n    //return smoothstep(-SM*SM, SM*SM, abs(dot(K, K) - R*R)); // outline\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    //       initial coordinates       offset                          scale\n    vec2 B = vec2(R.x*0.5, R.y*0.25) - circleOSC(-10.0, 10.0, iTime) * vec2(20.0, 1.0);\n    vec2 E = vec2(R.x*0.5, R.y*0.75) + circleOSC(-10.0, 10.0, iTime) * vec2(20.0, 1.0);\n\n    float thickness = sinOSC(0.1, 100.0, iTime);\n    float smoothness = cosOSC(1.0, 100.0, iTime * 0.5);\n    \n    //O = vec4(capsuleSDF(SC, B, E, thickness));\n    //O = vec4(capsuleSDFS(SC, B, E, thickness, smoothness));\n    O = vec4(capsuleSQSDF(SC, B, E, thickness, smoothness*smoothness));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/* Returns cosine modulated value in range [min, max]. */\nfloat cosOSC(in float min, in float max, in float T)\n{\n    float v = (cos(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/* Returns coordinates of point at circle bounded in range x,y=[min, max]. */\nvec2 circleOSC(in float min, in float max, in float T)\n{\n    vec2 v = vec2(\n        (cos(T) + 1.0) * 0.5,\n        (sin(T) + 1.0) * 0.5);\n    return min + v * (max - min);\n}","name":"Common","description":"","type":"common"}]}