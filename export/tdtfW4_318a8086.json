{"ver":"0.1","info":{"id":"tdtfW4","date":"1616557694","viewed":73,"name":"Andrew's Ray Marcher","username":"andrew741","description":"A basic ray marcher and my first GLSL shader. You can move your camera around to see all of the scene, the sun also moves in a circle around the scene.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define max_steps 200\n#define max_dist 75.\n#define surface_dist 0.04\n#define cloud\n\nconst float seed = -10.;\n\nvec3 red = vec3(255, 0, 0);\nvec3 brown = vec3(205, 133, 63);\nvec3 sky_blue = vec3(200, 200, 225);\nvec3 green = vec3(0, 200, 0);\nvec3 yellow = vec3(255, 255, 0);\nvec3 blue = vec3(0, 0, 255);\nvec3 grey = vec3(150, 150, 150);\nvec3 white = vec3(255, 255, 255);\nvec3 snow = vec3(1000, 1000, 1000);\n\nvec3 player_object_pos = vec3(0, 2.5, 0);\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat getNoise(vec2 p)\n{\n    float h = 0.;\n    p *= 0.05;\n    h += noise(p * 0.1);\n    h += noise(p * 0.2) * 0.5;\n    h += noise(p * 0.4) * 0.25;\n    h += noise(p * 0.8) * 0.125;\n    h += noise(p * 1.6) * 0.1125;\n    h += noise(p * 3.2) * 0.11125;\n    h *= 20.;\n    return 1. - abs(h) + 5.;\n}\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2(coord) / iResolution.xy, 0.0);\n}\n\nfloat DistToCapsole(vec3 p, vec3 lineA, vec3 lineB, float r) {\n\tvec3 LineLine = lineB - lineA;\n    vec3 LinePoint = p - lineA;\n    \n    float t = dot(LineLine, LinePoint) / dot(LineLine, LineLine);\n    t = clamp(t, 0., 1.);\n    \n    vec3 center = lineA + (t * LineLine);\n    \n    return length(p - center) - r;\n}\n\nfloat distToTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat distToSphere(vec3 p, vec3 c, float r) {\n\treturn length(p - c) - r;\n}\n\nfloat distToBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p) - s, 0.));\n}\n\nfloat distToCilander(vec3 p, vec3 lineA, vec3 lineB, float r) {\n\tvec3 LineLine = lineB - lineA;\n    vec3 LinePoint = p - lineA;\n    \n    float t = dot(LineLine, LinePoint) / dot(LineLine, LineLine);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 center = lineA + (t * LineLine);\n    \n    float x = length(p - center) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(LineLine);\n    float e = length(max(vec2(x, y), 0.));\n    \n    float i = min(max(x, y), 0.);\n    \n    return e + i;\n}\n\nfloat distToHollowBox( vec3 p, vec3 b, float e ) {\n\tp = abs(p  )-b;\n  \tvec3 q = abs(p+e)-e;\n  \treturn min(min(\n    \tlength(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n    \tlength(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n    \tlength(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat getDist(vec3 p) {\n    vec4 sphere = vec4(0, 1, 6, 1);\n    \n    float dist_to_player = DistToCapsole(p, vec3(player_object_pos.x, player_object_pos.y - 0.75, player_object_pos.z), vec3(player_object_pos.x, player_object_pos.y + 0.25, player_object_pos.z), 0.3);\n    float dist_to_hollow_box = distToHollowBox(p - vec3(-5, 4, 10), vec3(1.5, 1.5, 1.5), 0.1);\n    float dist_to_capsole = DistToCapsole(p, vec3(0, 1, 6), vec3(1, 2, 6), .2);\n\tfloat dist_to_sphere = distToSphere(p, sphere.xyz, sphere.w);\n    float dist_to_ground = p.y - getNoise(p.xz);\n    float dist_to_torus = distToTorus(p - vec3(0, 0.5, 6), vec2(1.5, 0.3));\n    float dist_to_sqaure = distToBox(p - vec3(-3, 0.75, 6), vec3(0.75));\n    float dist_to_cilander = distToCilander(p, vec3(0, 0.3, 3), vec3(3, 0.3, 5), .3);\n    float cube_dist = distToBox(p - vec3(3, 0.75, 6), vec3(0.75, 1.25, 0.25));\n    float sphere_dist = distToSphere(p, vec3(2, 5, 12), 3.);\n    float dist_to_2nd_capsole = DistToCapsole(p, vec3(6, 0, 16), vec3(2, 7, 12), 0.4);\n    float dist_to_long_capsole = DistToCapsole(p, vec3(-5.5, 5.5, 8.5), vec3(1, 3, 14), 0.35);\n    \n    float min_dist = min(dist_to_capsole, dist_to_ground);\n    min_dist = min(min_dist, dist_to_torus);\n    min_dist = min(min_dist, dist_to_sqaure);\n    min_dist = min(min_dist, dist_to_cilander);\n\tmin_dist = min(min_dist, dist_to_sphere);\n    min_dist = min(min_dist, dist_to_hollow_box);\n    min_dist = min(min_dist, cube_dist);\n    min_dist = min(min_dist, sphere_dist);\n    min_dist = min(min_dist, dist_to_2nd_capsole);\n    min_dist = min(min_dist, dist_to_long_capsole);\n    min_dist = min(min_dist, dist_to_player);\n    \n    return min_dist;\n}\n\n\nvec4 getDistAndColor(vec3 p) {\n    vec4 sphere = vec4(0, 1, 6, 1);\n    \n    float dist_to_player = DistToCapsole(p, vec3(player_object_pos.x, player_object_pos.y - 0.75, player_object_pos.z), vec3(player_object_pos.x, player_object_pos.y + 0.25, player_object_pos.z), 0.3);\n    float dist_to_hollow_box = distToHollowBox(p - vec3(-5, 4, 10), vec3(1.5, 1.5, 1.5), 0.1);\n    float dist_to_capsole = DistToCapsole(p, vec3(0, 1, 6), vec3(1, 2, 6), .2);\n\tfloat dist_to_sphere = distToSphere(p, sphere.xyz, sphere.w);\n    float dist_to_ground = p.y - getNoise(p.xz);\n    float dist_to_torus = distToTorus(p - vec3(0, 0.5, 6), vec2(1.5, 0.3));\n    float dist_to_sqaure = distToBox(p - vec3(-3, 0.75, 6), vec3(0.75));\n    float dist_to_cilander = distToCilander(p, vec3(0, 0.3, 3), vec3(3, 0.3, 5), .3);\n    float cube_dist = distToBox(p - vec3(3, 0.75, 6), vec3(0.75, 1.25, 0.25));\n    float sphere_dist = distToSphere(p, vec3(2, 5, 12), 3.);\n    float dist_to_2nd_capsole = DistToCapsole(p, vec3(6, 0, 16), vec3(2, 7, 12), 0.4);\n    float dist_to_long_capsole = DistToCapsole(p, vec3(-5.5, 5.5, 8.5), vec3(1, 3, 14), 0.35);\n    \n    float min_dist = min(dist_to_capsole, dist_to_ground);\n    min_dist = min(min_dist, dist_to_torus);\n    min_dist = min(min_dist, dist_to_sqaure);\n    min_dist = min(min_dist, dist_to_cilander);\n    min_dist = min(min_dist, dist_to_sphere);\n    min_dist = min(min_dist, dist_to_hollow_box);\n    min_dist = min(min_dist, cube_dist);\n    min_dist = min(min_dist, sphere_dist);\n    min_dist = min(min_dist, dist_to_2nd_capsole);\n    min_dist = min(min_dist, dist_to_long_capsole);\n    min_dist = min(min_dist, dist_to_player);\n    \n    vec3 object_color = vec3(0);\n    \n    if (min_dist == dist_to_capsole) {\n    \tobject_color = red;\n    }\n    else if (min_dist == dist_to_torus) {\n    \tobject_color = yellow;\n    }\n    else if (min_dist == dist_to_sqaure) {\n    \tobject_color = red;\n    }\n    else if (min_dist == dist_to_cilander) {\n    \tobject_color = blue;\n    }\n    else if (min_dist == dist_to_ground){\n        float height = getNoise(p.xz) + 10.;\n        if (height < -7. && height > -100000000.) {  // fix these colors so theres grass and make it so snow stays white by maybe adding a reflectiveness to it\n        \tobject_color = mix(green, brown, 0.4);\n        }\n        else if (height < 0. && height > -7.) {\n            object_color = brown;\n        }\n        else if (height < 12. && height > 0.) {\n            object_color = grey;\n        }\n        else {\n        \tobject_color = snow;\n        }\n    }\n    else if (min_dist == dist_to_sphere) {\n    \tobject_color = brown;\n    }\n    else if (min_dist == dist_to_hollow_box) {\n    \tobject_color = green;\n\t}\n    else if (min_dist == cube_dist) {\n    \tobject_color = mix(blue, red, 0.5);\n    }\n    else if (min_dist == sphere_dist) {\n    \tobject_color = mix(mix(grey, red, 0.5), mix(blue, red, 0.5), 0.5);\n    }\n    else if (min_dist == dist_to_2nd_capsole) {\n    \tobject_color = (red / grey) * 2.;\n    }\n    else if (min_dist == dist_to_long_capsole) {\n    \tobject_color = mix(red, green, 0.5);\n    }\n    else if (min_dist == dist_to_player) {\n    \tobject_color = white;\n    }\n    else {\n    \tvec3 object_color = sky_blue;\n    }\n    \n    return vec4(min_dist, object_color.x, object_color.y, object_color.z);\n}\n\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    \n    return normalize(normal);\n}\n\nvec2 get_angle() {\n\treturn vec2(sin(iTime / 2.5), cos(iTime / 2.5)) * 24.;;\n}\n\nvec4 cast_ray2(vec3 start, vec3 angle) {\n\tfloat dist_from_start = 0.;\n    vec3 object_color = vec3(200, 200, 225);\n    for (int i = 0; i < max_steps; i++) {\n    \tvec3 p = start + (angle * dist_from_start);\n        vec4 data = getDistAndColor(p);\n        float dist_from_surface = data.x;\n        \n        dist_from_start += dist_from_surface;\n        \n        if (dist_from_start > max_dist || dist_from_surface < surface_dist) {\n        \tobject_color = data.yzw;\n            break;\n        }\n    }\n    return vec4(dist_from_start, object_color.x, object_color.y, object_color.z);\n}\n\nvec4 cast_ray(vec3 start, vec3 angle) {\n\tfloat dist_from_start = 0.;\n    vec3 object_color = vec3(200, 200, 225);\n    for (int i = 0; i < max_steps; i++) {\n    \tvec3 p = start + (angle * dist_from_start);\n        vec4 data = getDistAndColor(p);\n        float dist_from_surface = data.x;\n        \n        dist_from_start += dist_from_surface;\n        \n        if (dist_from_start > max_dist || dist_from_surface < surface_dist) {\n        \tobject_color = data.yzw;\n            //if (object_color == red) {\n                //vec3 new_angle = angle + ((getNormal(p) - angle)* 2.);\n            \t//object_color = mix(cast_ray2(p + ((surface_dist * 2.), new_angle).yzw, vec3(225, 225, 225), 0.3);\n            //}\n            break;\n        }\n    }\n    return vec4(dist_from_start, object_color.x, object_color.y, object_color.z);\n}\n\nfloat getLight(vec3 p) {\n\tvec3 sun_pos = load(vec2(0, 0)).xyz;\n    sun_pos.y += 25.;\n    sun_pos.xz += get_angle();\n    vec3 light = normalize(sun_pos - p);\n    vec3 normal = getNormal(p);\n    \n    float dif = clamp(dot(normal, light), 0., 1.);\n    \n    float d = cast_ray(p + (normal * surface_dist * 2.), light).x;\n    \n    if (d < length(sun_pos - p)) dif *= 0.35;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 cam_pos = vec3(0, 2.5, 0);\n    \n    vec3 player_pos = load(vec2(0, 0)).xyz;\n    \n    // from https://www.shadertoy.com/view/WtGXDD (getting ro and rd)\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(0, 4, -4);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    cam_pos += ro;\n    \n    vec2 player_volocity = load(vec2(0, 2)).xy;\n    \n    player_pos.y += player_volocity.y;  // only do this if the casted rays dist is grater than a small number and same fro left,right,forward,backward movement\n    \n    if (player_pos.y < getNoise(player_pos.xz) + 26.) {\n    \tplayer_pos.y = getNoise(player_pos.xz) + 1.;\n    }\n    \n    player_object_pos = vec3(player_pos.x, player_pos.y, player_pos.z);\n    \n    vec3 angle = rd;\n    cam_pos = player_pos + ro;\n\n    vec4 data = cast_ray(cam_pos, angle);\n    vec3 pixel_color = data.yzw;\n    float d = data.x;\n    \n    vec3 p = cam_pos + angle * d;\n    float dif = max(getLight(p), 0.25);\n    \n    if (dif < 1. && d > max_dist / 2.3) {\n        float horizon = angle.y * 3. + 0.75;\n    \tpixel_color = mix(vec3(255, 255, 255), vec3(200, 200, 255), horizon);\n        dif = 1.;\n    }\n\n    pixel_color = normalize(pixel_color);\n    \n    vec3 color = vec3(pixel_color * (dif));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define player_speed 2.5\n#define gravity .5\n\nconst int KEY_BSP   = 8;\nconst int KEY_SP    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\nconst int LSHIFT = 16;\nconst int RSHIFT = 16;\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, (coord) / iResolution.xy, 0.0);\n}\n\nfloat getKeyState(int key) {\n\treturn texelFetch(iChannel1, ivec2(key, 0), 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = vec4(vec3(0), 1.0);\n    \n    vec2 fragCoord_ = vec2(floor(fragCoord.x), floor(fragCoord.y));\n    \n    if (fragCoord_ == vec2(0, 0)) {\n        float down = 0.;\n        if (getKeyState(LSHIFT) == 1. || getKeyState(RSHIFT) == 1.) {\n        \tdown = 1.;\n        }\n        vec3 movement = vec3(getKeyState(KEY_D) + (0. - getKeyState(KEY_A)), getKeyState(KEY_SP) + (0. - down), getKeyState(KEY_W) + (0. - getKeyState(KEY_S)));\n       \tmovement.y = 0.;\n        movement *= player_speed;\n        movement *= iTimeDelta;\n        vec2 cam_rot = load(vec2(0, 1)).xy;\n        vec3 player_pos = load(vec2(0)).xyz + vec3(movement.x, 0, movement.z);  // rotate to the side based on camera rotation\n        Output = vec4(player_pos, 1.0);\n    }\n    else if (fragCoord_ == vec2(0, 1)) {\n    \tvec2 cam_rot = load(vec2(0, 1)).xy;//normalize((vec2(0.) - (iMouse.xy / iResolution.xy - 0.5)));  // fix this so you can rotate in a circle\n        cam_rot = (iMouse.xy-(iResolution.xy/2.))/100.;\n        \n        //cam_rot = ((vec2(0.) - (iMouse.xy / iResolution.xy - 0.5)));\n        \n        Output = vec4(cam_rot, 0., 1.0);\n    }\n    else if (fragCoord_ == vec2(0, 2)) {\n    \tfloat down = 0.;\n        if (getKeyState(LSHIFT) == 1. || getKeyState(RSHIFT) == 1.) {\n        \tdown = 1.;\n        }\n        vec3 movement = vec3(getKeyState(KEY_D) + (0. - getKeyState(KEY_A)), getKeyState(KEY_SP) + (0. - down), getKeyState(KEY_W) + (0. - getKeyState(KEY_S)));\n        vec2 player_volocity = load(vec2(0, 2)).xy;\n        player_volocity.y = player_volocity.y - (gravity * iTimeDelta);\n        if (movement.y == 1.) {\n        \tplayer_volocity.y = 2.;\n        }  // get the volocity working so the player can jump around\n        Output = vec4(player_volocity.xy, 0., 0.);\n    }\n    fragColor = Output;\n}","name":"Buffer A","description":"","type":"buffer"}]}