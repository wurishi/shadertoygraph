{"ver":"0.1","info":{"id":"XdKyWm","date":"1522266888","viewed":169,"name":"A carpet on the wind.","username":"Pr0fed","description":"Was trying to figure out more about FBM. Taken IQ's:  https://www.shadertoy.com/view/lsl3RH\nI'm getting a grasp on color mixing :) Procedural texturing is fun.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Rotation matrix, it does a big impact, as usual.\nconst mat2 m = mat2( 1.40,  1.20, -1.20,  1.40 );\n\n// Strangely simple noise, which gives us that checker\n// pattern, if i understood right.\nfloat noise( in vec2 x )\n{\n\treturn cos(1.5 * x.x) * sin(1.5 * x.y);\n}\n\n// Four octave FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p = m * p * 2.02;\n    f += 0.2500 * noise( p ); p = m * p * 2.03;\n    f += 0.1250 * noise( p ); p = m * p * 2.01;\n    f += 0.0625 * noise( p );\n    return f / 0.9375;\n}\n\n// Six octave FBM.\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5+0.5*noise( p )); p = m * p * 2.02;\n    f += 0.250000 * (0.5+0.5*noise( p )); p = m * p * 2.03;\n    f += 0.125000 * (0.5+0.5*noise( p )); p = m * p * 2.01;\n    f += 0.062500 * (0.5+0.5*noise( p )); p = m * p * 2.04;\n    f += 0.031250 * (0.5+0.5*noise( p )); p = m * p * 2.01;\n    f += 0.015625 * (0.5+0.5*noise( p ));\n    return f / 0.96875;\n}\n\n// Main FBM pattern function.\n//\n// So actually we have 2 \"patterns\" here.\n// One is sitting in 'o', the other one is 'n'. \n// They are a bit different, but not much because\n// they use the same noise. After we got them,\n// we can mix it. Keeping this idea we can add more \n// \"layers\" using different noises and/or more variables.\n//\n// Feel free to play.\nfloat GetFBM( vec2 q, out vec4 ron)\n{\n    // Waves motion.\n    float ql = length( q );\n    q += vec2(0.05 * (2.0 * sin(-iTime * 2.0 + ql * 1.05)));\n\n    // First point.\n    vec2 o;\n    o = vec2(0.5 + 0.5 * fbm4( vec2(2.0 * q + vec2(1.2))));\n\n    // Second point.\n    vec2 n;\n    n.x = fbm6( vec2(4.0 * o + vec2(12.2)));\n    n.y = fbm6( vec2(4.0 * o + vec2(14.2)));\n\n    vec2 p = 4.0 * o + 4.0 * n;\n    float f = 0.5 + 0.5 * fbm4( p );\n\n    // I have seen that cubic mixing a couple of times\n    // is it just gives a nice result, or there is something\n    // behind it? Anyone?\n    f = mix( f, f * f * f * 3.5, f * abs(n.x) );\n\n    float g = 0.5 + 0.5 * sin(4.0 * p.x) * sin(4.0 * p.y);\n    f *= 1.0 - 0.5 * pow( g, 8.0 );\n    \n\tron = vec4( o, n );\n\n    return f;\n}\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    \n    float f = GetFBM(p, on);\n    \n    vec3 col = vec3(0.0);\n    \n    col = mix( vec3(0.78, 0.1, 0.4), vec3(0.0, 0.05, 0.11), f );\n    col = mix( col, vec3(0.4, 0.4, 0.65), dot(on.zw, on.zw));\n    col = mix( col, vec3(0.3, 0.65, 0.3), 0.35 * on.y );\n    col = mix( col, vec3(0.2, 0.4, 0.85), 0.5 * smoothstep(1.1, 1.6,abs(on.z) + abs(on.z)));\n    \n    return col * col * 7. * 0.4545;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 p = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Zoom level.\n    p*= 2.;\n\n    fragColor = vec4( GetColor( p ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}