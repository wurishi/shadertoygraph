{"ver":"0.1","info":{"id":"dlfSRr","date":"1674179933","viewed":155,"name":"Ocean simulator 2","username":"ianertson","description":"Another ocean simulator, control with mouse","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","ray","water","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 86\n#define NEAR 0.01\n#define FAR 1024.0\n#define TE(ch, v) textureLod(ch, v, 0.0).xyz;\n#define T (iTime*0.5)\n#define SEA_LEVEL 30.0\n\nfloat noise(vec3 p, float freq, int depth, int seed) {\n    return perlin_get2d(p.xz, freq, depth, seed);\n}\n\nfloat getDist(vec3 p) {\n    float h = SEA_LEVEL;\n    \n    float freq = 1.0;//max(0.2, 0.5+(noise((p*0.01), 0.01, 1, 11251)*0.5));\n    \n    \n    float fn = ((0.5*cos(T*0.001))) * 1.65;\n    \n   // freq *= (0.5+(fn*0.5));\n    \n    float F = FAR*0.6;\n    \n    float n0 = noise((((p/F)*(freq*3.0)) - (T*0.05)), 9.5, 1, 91251);\n    float n1 = noise((((p/F)*(freq*2.0)) + (T*0.25)), 3.9,  1, 21561)*1.2;\n    float n2 = noise((n1*0.25)+(((p/F)*(freq*2.0)) - sin((T+(n1*0.5))*0.35)), 3.9,  1, 17739)*1.2;\n    float T2 = T*2.0;\n    vec2 offset = vec2(cos(T2), sin(T2))*vec2(n0, n1);\n\n    \n    float bumps = n0*0.6;\n    float hills = pow(n1, 2.0) * 4.0;\n    \n\n    \n    float n = bumps+hills;\n   // n = mix(n, n3, fn*0.5);\n    n /= 2.0;\n \n   n -= n2 * 0.5;\n   \n \n    return p.y+(n*h);\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.1, 0.0);\n    \n    return normalize(getDist(p) - vec3(\n        getDist(p+e.xyy),\n        getDist(p+e.yxy),\n        getDist(p+e.yyx)\n    )); \n}\n\nvec2 getUv(vec3 p) {\n    vec3 uv = p / FAR;\n    \n    return (uv.xz+uv.y);\n}\n\nstruct Data {\n    float dist;\n    vec2 uv;\n    vec3 point;\n    vec3 normal;\n};\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float d = getDist(p);\n        dist += d;\n        \n        if (d <= NEAR || dist >= FAR) break;\n    }\n    \n    vec3 point = ro+rd*dist;\n    data.dist = dist;\n    data.uv = getUv(point);\n    data.normal = getNormal(point);\n    data.point = point;\n    \n    return dist < FAR;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\nbool render(vec3 ro, vec3 rd, inout Data data, inout vec3 col) {\n    vec3 L = normalize(vec3(-1.0, -2.0, -0.5));\n    vec3 lightColor = vec3(1.0);\n    \n    vec3 f0 = vec3(0.04);\n    \n    \n    // ground\n    float dp = pow(max(0.0, dot(rd, vec3(0.0, -1.0, 0.0))), 4.0);\n    vec2 guv = 1.0*((-ro.xz+((rd.xz/rd.y)*FAR))/FAR);\n\n    if (march(ro, rd, data)) {\n        vec3 viewdir = normalize(data.point - ro);\n        vec3 reflectDir = normalize(reflect(-L, data.normal));\n        vec3 albedo = vec3(0.76);//texture(iChannel0, data.uv).rgb;\n        vec3 baseColor = vec3(0.23, 0.44, 0.65);\n        vec3 specColor = vec3(0.2, 0.42, 0.45) + vec3(0.2);\n        float NdotL = max(0.0, dot(data.normal, L));\n        float NdotV = abs(dot(data.normal, viewdir));\n        float VdotR = max(dot(viewdir, reflectDir), 0.0);\n        vec3 env = texture(iChannel1, normalize(reflectDir)).rgb;\n        float att = NdotL;\n        \n        float roughness = 0.27;\n        float metallic = 0.34;\n        vec3 envColor = vec3(0.01);//0.25*mix(mix(specColor/3.14, vec3(0.01), 0.34), env, 0.125);\n        vec3 envBRDF = EnvBRDFApprox(envColor, pow(roughness, 2.0), NdotV);\n        vec3 F = fresnelSchlickRoughness(NdotV, f0, roughness);\n        vec3 indirectSpecular = env * (F * envBRDF.x + envBRDF.y);\n        \n        vec3 H = normalize(L + viewdir);\n        float HdotV = clamp(dot(H, viewdir),0.000001, 1.0);\n        float NdotH = clamp(dot(data.normal, H), 0.000001, 1.0);\n        \n        \n        vec3 fresnel = fresnelSchlick(HdotV, f0);\n        float D = microfacetDistribution(roughness, NdotH);\n        float S = DistributionGGX(data.normal, H, roughness);\n        float G = GeometrySmith(data.normal, viewdir, L, roughness);\n        float Fsd = (4.0 * NdotV * NdotL);\n        vec3 specularity = ((fresnel * S * G * D) / notzero(Fsd)) / M_PI;\n        vec3 kd = (vec3(1.0) - specularity) * (1.0 - metallic);\n        \n        \n        float spec = pow(VdotR, 32.0) / M_PI;\n        vec3 diffuse = (albedo/M_PI)*baseColor;\n        \n        diffuse = mix(diffuse, specColor, pow(NdotL, 16.0));\n        \n        col = indirectSpecular;\n        col += (kd * diffuse + specularity + spec) * ((lightColor * att));\n        col = col*col;\n        \n        \n        \n        \n        \n        float groundDepth = clamp(abs(SEA_LEVEL - data.point.y)/max(0.01, (FAR/SEA_LEVEL)), 0.0, 1.0);\n        \n       \n        // fake refraction\n        guv -= data.point.xz*0.001;\n        guv -= data.uv*0.1;\n        \n        vec3 bg = texture(iChannel3, guv).rgb;\n        col += dp*(bg*bg*bg);\n        col /= max(0.001, 1.0+groundDepth);\n       // col = (indirectSpecular + ((diffuse + spec) * att));\n        \n        return true;\n    } else {\n        vec3 bg = texture(iChannel3, guv).rgb;\n        col += dp*(bg*bg*bg);\n    }\n    \n    return false;\n}\n\nvec3 tonemap(vec3 col) {\n    vec3 x = col;\n    vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n    float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n    \n    x = clamp(\n        (x * (2.51 * x + 0.03)) /\n        (x * (2.23 * x + 1.0392) + 0.98),\n    0.0, 1.0);\n   \n    x = saturate(x, dotVio);\n    x = mix(x, pow(x, vec3(2.0)), 0.3491*pow(dotVio, 2.0));\n    x += luma(x)/6.28;\n    x = clamp(x+(x/6.28), 0.0, 1.0);\n    \n    return pow(x, vec3(0.5125));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n   \n    ro.y += (SEA_LEVEL*0.5) + ((SEA_LEVEL * (0.5+(0.5*cos(T)))) * 3.0);\n    ro.z = ((T*2.0)*60.0);\n    \n    float A = radians(30.0);\n    float B = radians(20.0);\n    float m = (0.5+(cos(T*0.86)*0.5));\n    \n    \n    if (iMouse.z > 0.01) {\n        rd = controller(rd, iMouse, iResolution.xy);\n    } else {\n        rd = controller(rd, vec4(0.0, mix(A, B, m), 0.0, 0.0), vec2(1.0));\n    }\n    \n    \n    rd = normalize(rd);\n   \n    \n    Data data;\n    vec3 primaryColor = vec3(0.0);\n    vec3 reflectionColor = vec3(0.0);\n    if (render(ro, rd, data, primaryColor)) {\n        col = primaryColor;\n        \n        Data refdata;\n        vec3 viewdir = normalize(ro - data.point);\n        vec3 reflection_dir = normalize(reflect(viewdir, data.normal) * -1.);\n        vec3 refpoint = data.point + data.normal*0.5;\n        if (render(refpoint, reflection_dir, refdata, reflectionColor)) {\n            col += reflectionColor;\n        }\n        \n    }/* else {\n        col = texture(iChannel1, rd).rgb;\n    }*/\n    \n    float depth = clamp((data.dist-NEAR) / FAR, 0.0, 1.0);\n    vec3 sky = (depth) * vec3(0.2, 0.6, 0.78);\n    vec3 fog = vec3(depth);\n    col += mix(sky, fog, 0.7*depth*depth);\n    \n    col = mix(col, col*col, 0.6);\n    col = tonemap(col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.14159265359\n\nint HASH[256] = int[256](\n    208, 34,  231, 213, 32,  248, 233, 56,  161, 78,  24,  140, 71,  48,  140,\n    254, 245, 255, 247, 247, 40,  185, 248, 251, 245, 28,  124, 204, 204, 76,\n    36,  1,   107, 28,  234, 163, 202, 224, 245, 128, 167, 204, 9,   92,  217,\n    54,  239, 174, 173, 102, 193, 189, 190, 121, 100, 108, 167, 44,  43,  77,\n    180, 204, 8,   81,  70,  223, 11,  38,  24,  254, 210, 210, 177, 32,  81,\n    195, 243, 125, 8,   169, 112, 32,  97,  53,  195, 13,  203, 9,   47,  104,\n    125, 117, 114, 124, 165, 203, 181, 235, 193, 206, 70,  180, 174, 0,   167,\n    181, 41,  164, 30,  116, 127, 198, 245, 146, 87,  224, 149, 206, 57,  4,\n    192, 210, 65,  210, 129, 240, 178, 105, 228, 108, 245, 148, 140, 40,  35,\n    195, 38,  58,  65,  207, 215, 253, 65,  85,  208, 76,  62,  3,   237, 55,\n    89,  232, 50,  217, 64,  244, 157, 199, 121, 252, 90,  17,  212, 203, 149,\n    152, 140, 187, 234, 177, 73,  174, 193, 100, 192, 143, 97,  53,  145, 135,\n    19,  103, 13,  90,  135, 151, 199, 91,  239, 247, 33,  39,  145, 101, 120,\n    99,  3,   186, 86,  99,  41,  237, 203, 111, 79,  220, 135, 158, 42,  30,\n    154, 120, 67,  87,  167, 135, 176, 183, 191, 253, 115, 184, 21,  233, 58,\n    129, 233, 142, 39,  128, 211, 118, 137, 139, 255, 114, 20,  218, 113, 154,\n    27,  127, 246, 250, 1,   8,   198, 250, 209, 92,  222, 173, 21,  88,  102,\n    219);\n\nint noise2(int x, int y, int seed) {\n  int yindex = (y + seed) % 256;\n  if (yindex < 0) yindex += 256;\n  int xindex = (HASH[yindex] + x) % 256;\n  if (xindex < 0) xindex += 256;\n  return HASH[xindex];\n}\n\nfloat lin_inter(float x, float y, float s) {\n  return x + s * (y - x);\n}\n\nfloat smooth_inter(float x, float y, float s) {\n  return lin_inter(x, y, s * s * (3. - 2. * s));\n}\n\nfloat noise2d(float x, float y, int seed) {\n  int x_int = int(floor(x));\n  int y_int = int(floor(y));\n  float x_frac = float(x - float(x_int));\n  float y_frac = y - float(y_int);\n  int s = noise2(x_int, y_int, seed);\n  int t = noise2(x_int + 1, y_int, seed);\n  int u = noise2(x_int, y_int + 1, seed);\n  int v = noise2(x_int + 1, y_int + 1, seed);\n  float low = smooth_inter(float(s), float(t), float(x_frac));\n  float high = smooth_inter(float(u), float(v), float(x_frac));\n  return smooth_inter(float(low), float(high), float(y_frac));\n}\n\nfloat perlin_get2d(vec2 p, float freq, int depth, int seed) {\n  depth = min(depth, 8); // too slow otherwise\n  float xa = p.x * freq;\n  float ya = p.y * freq;\n  float amp = 1.0;\n  float fin = 0.;\n  float div = 0.0;\n  for (int i = 0; i < depth; i++) {\n    div += 256. * amp;\n    fin += noise2d(xa, ya, seed) * amp;\n    amp /= 2.;\n    xa *= 2.;\n    ya *= 2.;\n  }\n  return clamp(fin / div, -1.0, 1.0);\n}\n\nfloat perlin_get2d(vec2 p, float freq, float depth, float seed) {\n  return perlin_get2d(p, freq, int(depth), int(seed));\n}\n\nvec3 perlin_vec3(vec2 p, float freq, int depth, int seed) {\n  float x = perlin_get2d(p, freq, depth, seed);\n  float y = perlin_get2d(p, freq, depth, int(seed+int(freq)));\n  float z = perlin_get2d(p, freq, depth, int(seed+int(ceil(freq))+int(ceil(freq))));\n  \n  return vec3(x, y, z);\n}\n\n\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\n\nmat4 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(1, 0, 0, 0), vec4(0, c, -s, 0), vec4(0, s, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, 0, s, 0), vec4(0, 1, 0, 0), vec4(-s, 0, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, -s, 0, 0), vec4(s, c, 0, 0), vec4(0, 0, 1, 0),\n              vec4(0, 0, 0, 1));\n}\n\nvec3 rotate(vec3 vertex, vec3 center, vec3 axis, float angle) {\n  mat4 matrix = (rotationX(angle * axis.x) * rotationY(angle * axis.y) * rotationZ(angle * axis.z));\n  return (matrix * vec4(vertex - center, 1.0)).xyz + center;\n}\n\nvec2 rot2D(vec2 p, float angle) {\n  angle = radians(angle);\n  float s = sin(angle);\n  float c = cos(angle);\n  return p * mat2(c, s, -s, c);\n}\n\n\nvec3 controller(vec3 dir, vec4 c, vec2 res) {\n    vec2 m = ((c.xy == vec2(0.) ? vec2(.5) : (c.xy / res.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    return normalize(dir);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n","name":"Common","description":"","type":"common"}]}