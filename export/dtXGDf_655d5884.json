{"ver":"0.1","info":{"id":"dtXGDf","date":"1672546831","viewed":152,"name":"IK-CCD method","username":"yunhai","description":"works not bad, huh\njoint endding is dragable\nnow is configurable\n\n","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["ik"],"hasliked":0,"parentid":"fsG3Dt","parentname":"IK-2joints"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//configurations\nconst int ITR=8;//iteration waves\nconst int JNUM=6;//joints num\nfloat arms[JNUM-1]=\nfloat[](5.,5.,5.,5.,5.);//arm Length\n    \n\n//---------------------Lines-------------------\nconst float HLW=.05;//half line width\nconst float MSI=2.;//mesh space interval\nfloat lineSeg(vec2 uv,vec2 start,vec2 end)\n{\n    vec2 sp=uv-start;\n    vec2 se=end-start;\n    vec2 closp=clamp(dot(sp,se)/dot(se,se),0.,1.)*se+start;\n    return SL(length(uv-closp));\n}\nfloat line(vec2 uv,vec2 ori,vec2 dir)\n{\n    vec2 sp=uv-ori;\n    vec2 closp=dot(sp,dir)*dir+ori;\n    return SL(length(uv-closp));\n}\n//----------------------------------------------\nvec3 cartesian(vec2 uv)\n{\n    vec3 col=vec3(0.);\n    float msp=MSI;\n    float lhlw=HLW/2.;//local HLW\n    vec3 mesh=vec3(SS(lhlw,lhlw-.005,abs(uv.x-round(uv.x/msp)*msp)));\n    mesh+=vec3(SS(lhlw,lhlw-.005,abs(uv.y-round(uv.y/msp)*msp)));\n    col+=mesh*.5;\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(1.,0.)));\n    col=mix(col,vec3(0.,1.,0.),line(uv,vec2(0.),vec2(0.,1.)));\n    return col;\n}\nvec3 palette(float t)//Color Palette\n{\n    t*=1.732;\n    return vec3(.5)+vec3(.5)*cos(2.*PI*(vec3(.71,.31,.21)*t+vec3(.2,.4,.6)));\n}\n//-------------------experiment-----------------\nvoid drawJoint(inout vec4 O,vec4 color,vec2 uv,vec2 p)\n{\n    O=mix(O,color,SS(.3,.3-PIXW,length(uv-p)));\n    O=mix(O,vec4(0),SS(.2,.2-PIXW,length(uv-p)));\n    O=mix(O,color,SS(.3,.1-PIXW,length(uv-p)));\n}\nvoid drawArm(inout vec4 O,vec2 uv,vec2 a,vec2 b)\n{\n    O=mix(O,vec4(1),lineSeg(uv,vec2(a),vec2(b)));\n}\nfloat times(vec2 a,vec2 b)\n{\n    return a.x*b.y-a.y*b.x;\n}\nvec2 buildUV(vec2 C)\n{\n    return (C-vec2(.1,.3)*iR)*PIXW;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv=buildUV(C);\n\n    float t=iTime;\n    O.rgb=cartesian(uv);  \n    \n\n    \n    vec2 freepos=vec2(4)+vec2(cos(t),sin(t))*2.;\n    bool isFree=iM.x<20.||iM.x>(iR.x-20.)||iM.y<20.||iM.y>(iR.y-20.);\n    vec2 target=isFree?freepos:buildUV(iM.xy);\n    if(isFree)\n        O.rgb=mix(O.rgb,vec3(1,1,0),SS(2.,2.-PIXW,length(uv-vec2(4)))*\n                                SS(1.9,1.9+PIXW,length(uv-vec2(4))));//free trail\n    \n    vec2 joints[JNUM];\n    \n    //init \n    joints[0]=vec2(0);\n    for(int i=1;i<JNUM;i++)\n        joints[i]=joints[i-1]+vec2(arms[i-1],0.);\n        \n    \n    //CCD\n    float thetas[JNUM-1];\n    for(int i=0;i<ITR;i++)//big cycle ITR\n    {\n        vec2 tmp=joints[JNUM-1];//endding\n        for(int i=JNUM-2;i>=0;i--)\n        {\n            vec2 l1=tmp-joints[i],\n                 l2=target-joints[i];\n            float ll2=length(l2),ll1=length(l1);\n            thetas[i]=asin(\n            times(l1,l2)/(ll2*ll1));\n            tmp=joints[i]+l2/ll2*ll1;\n        }\n        vec2 armvecs[JNUM-1];\n        for(int i=0;i<JNUM-1;i++)\n        {\n            armvecs[i]=joints[i+1]-joints[i];\n        }\n        tmp.x=0.;\n        for(int i=0;i<JNUM-1;i++)\n        {\n            tmp.x+=thetas[i];\n            vec2 l=armvecs[i];\n            joints[i+1]=joints[i]+mrot(tmp.x)*l;\n        }\n\n        \n    }\n        \n    //draw arm \n    for(int i=1;i<JNUM;i++)\n        drawArm(O,uv,joints[i-1],joints[i]);\n    for(int i=0;i<JNUM-1;i++)\n        drawJoint(O,GREEN,uv,joints[i]);\n    drawJoint(O,RED,uv,joints[JNUM-1]);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iR iResolution.xy\n#define iM iMouse\n#define PIXW (30./iR.x)\n#define SS(a,b,t) smoothstep(a,b,t)\n#define SL(d) smoothstep(HLW+PIXW,HLW-PIXW,d)\nconst vec4 RED=vec4(1,0,0,1);\nconst vec4 GREEN=vec4(0,1,0,1);\nconst float PI=3.14159265;\nmat2x2 mrot(float r)\n{\n    float c=cos(r),s=sin(r);\n    return mat2x2(c,s,-s,c);\n}","name":"Common","description":"","type":"common"}]}