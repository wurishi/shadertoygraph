{"ver":"0.1","info":{"id":"lsBBRG","date":"1501003670","viewed":194,"name":"[SH17B] birdwatching","username":"michaelarbuckle","description":"as you try to approach, white bird/sphere moves into woods eluding capture \nthe code is mashup from several other great shaders on shadertoy.com (see citations inside) \nwhen camera moves within trigger distance of bird,  it takes flight at a right angle ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["woodsbirdelude"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this code is mashup from several great shaders on shadertoy.com \n//\n// Woods at https://www.shadertoy.com/view/XsfGD4 by iq\n// \n// Robin at https://www.shadertoy.com/view/4tl3RM by Dave Hoskins\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define LAUNCH 0\n#define HOVER 1\n#define MOVING 2\n        \nint birdFlight;\nvec3 birdPosition;\nvec3 birdDirection;\n\nvec3 direction;\n\n\nvec4 lpos[7];\n\n\nfloat hash( vec2 n )\n{\n    return fract(sin(dot(n,vec2(1.0,113.0)))*13.5453123);\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\nvec2 hash2( vec2 x )\n{\n\tfloat n = dot(x,vec2(1.0,113.00));\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\n}\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\nvec2 Rot2(vec2 p, float a)\n{\n\tfloat si = sin(a);\n\tfloat co = cos(a);\n\treturn mat2(co, si, -si, co) * p;\n}\nfloat Noise(float n)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = f*f*(3.0-2.0*f);\n    return mix(hash(n), hash(n+1.0), f);\n   \n}\n\nfloat NoiseSlope(float n, float loc)\n{\n    float f = fract(n);\n    n = floor(n);\n    f = smoothstep(0.0, loc, f);\n    return mix(hash(n), hash(n+1.0), f);\n   \n}\nfloat  Sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n//--------------------------------------------------------------------------\nvec3 TexCube(in vec3 p, in vec3 n )\n{\n\tvec3 x = texture(iChannel0, p.yz ).xzy;\n\tvec3 y = texture(iChannel0, p.zx ).xyz;\n    //y = y*y;\n\tvec3 z = texture(iChannel1, p.xy, 2.0).yyy;\n\treturn (x*abs(n.x) + y*abs(n.y) + z*abs(n.z))/(abs(n.x)+abs(n.y)+abs(n.z))*.9;\n}\n\nfloat Cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//----------------------------------------------------------------------------------------\nfloat Segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n//----------------------------------------------------------------------------------------\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat sMin( float a, float b, float k )\n{\n    \n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n \n\nfloat fbm( vec3 p, vec3 n )\n{\n\tp *= 0.15;\n\tfloat x = texture( iChannel0, p.yz ).x;\n\tfloat y = texture( iChannel0, p.zx ).x;\n\tfloat z = texture( iChannel0, p.xy ).x;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nfloat distToBox( in vec3 p, in vec3 abc )\n{\n\tvec3 di = max(abs(p)-abc,0.0);\n\treturn dot(di,di);\n}\nvec3 texturize( sampler2D sa, vec3 p, vec3 n )\n{\nvec3 x = texture( sa, p.yz ).xyz;\nvec3 y = texture( sa, p.zx ).xyz;\nvec3 z = texture( sa, p.xy.yx ).xyz;\n\nreturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\nvec2 column( in float x, in float y, in float z )\n{\n\tvec3 p = vec3( x, y, z );\n\n\tfloat y2=y-0.40;\n    float y3=y-0.35;\n    float y4=y-1.00;\n\n    float di1=distToBox( p, vec3(0.10*0.85,1.00,0.10*0.85) );\n    float di2=distToBox( p, vec3(0.12,0.40,0.12) );\n    float di3=distToBox( vec3(x,y4,z), vec3(0.14,0.02,0.14) );\n    x = max( abs(p.x), abs(p.z) );\n    z = min( abs(p.x), abs(p.z) );\t\n    float di4=distToBox( vec3(x, y, z), vec3(0.14,0.35,0.05) );\n    float di5=distToBox( vec3(x, (y2+z)*0.7071, (z-y2)*0.7071), vec3(0.12, 0.10*0.7071, 0.10*0.7071) );\n    float di6=distToBox( vec3(x, (y3+z)*0.7071, (z-y3)*0.7071), vec3(0.14, 0.10*0.7071, 0.10*0.7071) );\n\n    float dm = min(min(min(di5,di6),min(di3,di4)),di2);\n\t\n\tvec2 res = vec2( dm, 3.0 );\n\tif( di1<res.x ) res = vec2( di1, 2.0 );\n\n\treturn vec2( sqrt(res.x), res.y );\n}\n \n//vec3 treetrunk( in float x, in float y, in float z )\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n\tf =  f*f*(3.0-2.0*f);\n\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n\n\treturn mix( mix( a, b, f.x ), mix( c, d, f.x ), f.y );\n\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z);\n\tvec2 rga = textureLod( iChannel0, (uv+vec2(0.5,0.5))/256.0, 0.0 ).yx;\n\tvec2 rgb = textureLod( iChannel0, (uv+vec2(1.5,0.5))/256.0, 0.0 ).yx;\n\tvec2 rgc = textureLod( iChannel0, (uv+vec2(0.5,1.5))/256.0, 0.0 ).yx;\n\tvec2 rgd = textureLod( iChannel0, (uv+vec2(1.5,1.5))/256.0, 0.0 ).yx;\n\t\n\tvec2 rg = mix( mix( rga, rgb, f.x ),\n\t\t\t\t   mix( rgc, rgd, f.x ), f.y );\n\t\n\treturn mix( rg.x, rg.y, f.z );\n}\nfloat fbm( in vec3 p )\n{\n    return 0.5000*noise(p*1.0)+\n           0.2500*noise(p*2.0)+\n           0.1250*noise(p*4.0)+\n           0.0625*noise(p*8.0);\n}\n\nfloat fbm( in vec2 p )\n{\n    return 0.5000*noise(p*1.0)+\n           0.2500*noise(p*2.0)+\n           0.1250*noise(p*4.0)+\n           0.0625*noise(p*8.0);\n}\n\n \n\nfloat treeBase( vec2 pos )\n{\n\tfloat chsca = 0.2;\n\tvec2 chos = fract(chsca*pos) - 0.5;\n\treturn length( chos );\n}\t\n\nfloat terrain( vec2 pos )\n{\n\tfloat h = 12.0*fbm( pos*0.1 );\n\t\n\tfloat r = treeBase( pos );\n\tr = max(0.0,r-0.1);\n\tfloat ar = 1.0*exp( -50.0*r*r );\n\t\n\treturn h + ar;\n}\n\nvec2 grassDistr( in vec2 pos )\n{\n\tfloat f = fbm( pos );\n    return vec2( smoothstep( 0.45, 0.55, f ), smoothstep(0.4, 0.75, f) );\n}\n\n\nfloat mapTrees( in vec3 pos, out vec4 suvw, out float info )\n{\n    float dis;\n\t\n\t//-----------------------------\n\t// terrain\n\tfloat h = terrain( pos.xz );\n\tfloat mindist = pos.y - h;\n\n\tfloat t = treeBase( pos.xz );\n\tfloat treeOcc = clamp(max(0.0,t-0.15)*3.0,0.0,1.0);\n\tsuvw = vec4( 0.0, 0.0, 0.0, treeOcc );\n\n\t// grass\n\tvec2 gd = grassDistr(pos.xz);\n\tfloat hi = 1.0*clamp( 2.0*textureLod( iChannel0, pos.xz, 0.0 ).x, 0.0, 1.0 );\n\tfloat g = 0.2*hi * (gd.x * gd.y);\n    mindist -= g;\n\n\tsuvw.w *= mix( smoothstep( 0.5, 1.0, hi ), 1.0, 1.0-gd.x );\n\tsuvw.w *= 0.2 + 0.8*clamp( 2.0*abs(gd.x-0.5), 0.0, 1.0 );\n\t\n\t//-----------------------------\n\t// trees\n\t{\n\tfloat chsca = 0.2;\n\tvec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );\n\tfloat y = chos.y;\n\tfloat r = length( chos.xz );\n\t\t\n\tfloat ss = exp(-40.0*y*y);\n\tfloat dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );\n\tfloat sh = 0.08 + (0.1+0.25*ss)*dd;\n\t\t\n    dis = (r - sh)/chsca;\n\tif( dis<mindist )\n\t{\n\t\tmindist = dis;\n\t\tsuvw.x = 1.0;\n\t\tsuvw.y = y;\n\t\tsuvw.z = smoothstep( 0.0, 1.0, dd );\n\t\tsuvw.w = smoothstep( 0.0, 1.0, dd*1.4 ) * clamp(0.3+y*1.5, 0.0, 1.0);\n\t\tinfo = atan( chos.x, chos.z );\n\t}\t\t\n\t\t\n    }\n        return mindist * 0.5;\n\n}\n    \n \nfloat MapBird( vec3 p )\n{\n\tfloat d;\n/*    vec3 post = vec3( p.x,p.y,p.z);\n    \n    p.xz = Rot2(p.xz,  zoomTurn.x);\n\tvec3 o = p;\n    \n    p.y-=body.z;\n    p.yz = Rot2(p.yz, body.x);\n    // Body \n    d = RoundBox(p-vec3(0.0, -1.4,-.3),vec3(.3+.1*animParts.x, .0, .1+.3*animParts.x), .123);\n    d = sMin(d, Sphere(p-vec3(0.0, -.25,0.0), 1.33), 1.);\n    \n\t//Wings...    \n\tvec3 p2 = p;\n    p2.x = abs(p2.x);\n    d = sMin(d,Segment(p2,vec3(1.3, 0.2,.2), vec3(1.5+body.y, -.5,-1.6), .2, .2), .4);\n  \n   \n    // Tail...\n    d = sMin(d,Segment(p2,vec3(.6, -.5, -1.5), vec3(.15, -1.2, -8.0), .2, .2), 2.4);\n    \n    // Rotate head..\n    p.xy = Rot2(p.xy, animParts.y);\n   \tp.zy = Rot2(p.zy, animParts.z);\n   \n    // Head...\n    d = sMin(d, Sphere(p-vec3(0.0, 1.,1.4), .8), 1.0);\n    //animParts.w = .1;\n    // Beak...\n    d = sMin(d,Segment(p-vec3(0.0, 1.,2.5),vec3(0.0, 0.0,-.4), vec3(.0, animParts.w*.2,.15), .1, .096), .72);\n    d = sMin(d,Segment(p-vec3(0.0, 1.05,2.5),vec3(0.0, -animParts.w*.25,-1.5), vec3(.0, -animParts.w,.16), .1, .1), .805);\n    // Eyes...\n    p.x = abs(p.x);\n    d = min(d, Sphere(p-vec3(.35, 1.1,2.05), .11));\n    // Post...\n\td = min(d, Cylinder(post-vec3(0.2, -12.0, .4), vec2(1.8, 8.5)- fbm(post*5.0)*.1));\n    // Legs...\n    o.x = abs(o.x);\n    o.y-=body.w;\n    d = min(d, Segment(o,vec3(0.5, -2.+body.z+body.w,-.5), vec3(.8, -3.5,0.5), .09, .1));\n    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(.8, -3.5,1.2), .04, .04));\n    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(1.4, -3.5,0.8), .04, .04));\n    d = min(d, Segment(o,vec3(.8, -3.5,0.5), vec3(.1, -3.5,0.8), .04, .04));\n*/\n    return d;\n}   \nvec3 map( vec3 pos )\n{\npos /= 15.;\n    float sid = 0.0;\n    float dis;\n\n    vec4 suvw;\n    float info; \n    \n    // floor\n\n    //float mindist = pos.y;\n//-----------------------------\n\t// terrain\n\tfloat h = terrain( pos.xz );\n\tfloat mindist = pos.y - h;\n\n    float t = treeBase( pos.xz );\n\tfloat treeOcc = clamp(max(0.0,t-0.15)*3.0,0.0,1.0);\n\tsuvw = vec4( 0.0, 0.0, 0.0, treeOcc );\n       // columns\n\tvec2 tfc = fract( pos.xz+128.5 ) - 0.5;\n\tvec2 tdis2 = column( tfc.x, pos.y, tfc.y );\n\t\t\n    if(tdis2.x<mindist )\n    {\n        mindist = tdis2.x;\n        sid = tdis2.y;\n    }\n\t\n\n\n\t// grass\n\tvec2 gd = grassDistr(pos.xz);\n\tfloat hi = 1.0*clamp( 2.0*textureLod( iChannel0, pos.xz, 0.0 ).x, 0.0, 1.0 );\n\tfloat g = 0.2*hi * (gd.x * gd.y);\n    mindist -= g;\n\n    \n    \t//-----------------------------\n\t// trees\n\t{\n\tfloat chsca = 0.2;\n\tvec3 chos = vec3( fract(chsca*pos.x)-0.5, chsca*(pos.y-h), fract(chsca*pos.z)-0.5 );\n\tfloat y = chos.y;\n\tfloat r = length( chos.xz );\n\t\t\n\tfloat ss = exp(-40.0*y*y);\n\tfloat dd = fbm( pos*vec3(1.0,0.1,1.0)*2.0 );\n\tfloat sh = 0.08 + (0.1+0.25*ss)*dd;\n\t\t\n    dis = (r - sh)/chsca;\n\tif( dis<mindist )\n\t{\n\t\tmindist = dis;\n\t\tsuvw.x = 1.0;\n\t\tsuvw.y = y;\n\t\tsuvw.z = smoothstep( 0.0, 1.0, dd );\n\t\tsuvw.w = smoothstep( 0.0, 1.0, dd*1.4 ) * clamp(0.3+y*1.5, 0.0, 1.0);\n\t\tinfo = atan( chos.x, chos.z );\n        sid = info;\n\t}\t\t\n\t\t\n\t}\n\t\n    \n    // ceilin\n\tfloat x = fract( pos.x+128.0 ) - 0.5;\n\tfloat z = fract( pos.z+128.0 ) - 0.5;\n    float y = 1.0 - pos.y;\n\tdis = -sqrt( y*y + min(x*x,z*z)) + 0.14;\n\tdis = max( dis, y );\n    if( dis<mindist )\n    {\n        mindist = dis;\n        sid = 1.0;\n    }\n\n   /*\n   dis = MapBird(pos );\n   if( dis<mindist )\n    {\n        mindist = dis  ;\n        sid = pos.y ;\n    }\n   */\n    \n    // columns\n\tvec2 fc = fract( pos.xz+28.5 ) - 0.5;\n    float nn = noise( fc );\n    \n\tvec2 dis2 = column( fc.x  , pos.y, fc.y + nn );\n\t\t\n    if( dis2.x<mindist )\n    {\n        mindist = dis2.x + .03*nn ;\n        sid = dis2.y ;\n    }\n\t\n\t//float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(6.0*pos.y)*sin(50.0*pos.x)*sin(4.0*6.2831*pos.z));\n    //float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(12.0*pos.y)*sin(100.0*pos.x)*sin(8.0*6.2831*pos.z));\n    float dsp = 1.0*clamp(pos.y,0.0,1.0)*abs(sin(8.0*6.2831*pos.z));\n\t\n    mindist -= dsp*0.03*0.25;\n\n    return vec3(mindist*15.,sid,dsp);\n}\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 suvw, out float info )\n{\n    const float maxd = 50.0;\nfloat precis = 0.01;\n    float h = 1.0;\n    float t = 0.0;\n    suvw = vec4(0.0);\ninfo = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        if( h<precis||t>maxd ) break;\n   h  = mapTrees( ro+rd*t, suvw, info );\n        t += h*min(0.25+0.15*t,1.0);\n    }\n\nif( t>maxd ) { t=-1.0; suvw=vec4(512.0); }\n    return t;\n}\n\nvec3 calcColor( in vec3 pos, in vec3 nor, in float sid )\n{\n\tvec3 col = vec3( 1.0 );\n\n    float kk = fbm( 32.0*pos, nor );\n\n    if( sid<0.5 )\n\t{\n\t\tvec2 peldxz = fract( 3.0*12.0*pos.xz );\n\t\tpeldxz = 4.0*peldxz*(1.0-peldxz);\n\t\tfloat de = 20.0*length(fwidth(pos.xz));\n\t\tfloat peld = smoothstep( 0.15-de, 0.15+de, min( peldxz.x, peldxz.y ) );\n\t\tcol = 0.05 + 0.95*vec3(peld);\n        col = pow( texture( iChannel1, 6.0*pos.xz ).xyz, vec3(2.20) );\n\t}\n    else if( sid>0.5 && sid<1.5 )\n\t{\n\t\tfloat fx = fract( pos.x+128.0 ); \n\t    float fz = fract( pos.z+128.0 ); \n\t\tcol = vec3(0.7,0.7,0.7);\n\t\tfloat p = 1.0;\n\t\tp *= smoothstep( 0.02, 0.03, abs(fx-0.1) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fx-0.9) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fz-0.1) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fz-0.9) );\n\t\tcol = mix( 0.75*vec3(0.3,0.15,0.15), col, p );\n\t}\n    else if( sid>1.5 && sid<2.5 )\n\t{\n\t\tfloat l = fract( 12.0*pos.y );\n\t\tfloat peld = smoothstep( 0.1, 0.2, l );\n\t\tcol = 0.05 + 0.95*vec3(peld);\n\t}\n\t\n    return col * 2.0 * kk;\t\n}\nvoid moveBirds( void )\n{\n\n    for( int i=0; i<7; i++ )\n\t{\n\t\tvec3 pos;\n\t    pos.x = 3.2*cos(0.0+0.08*iTime*2.0 + 17.0*float(i) );\n\t    pos.z = 3.2*cos(1.65+0.07*iTime*2.0 + 13.0*float(i) );\n\t    pos.y = terrain( pos.xz ) + 0.4;\n\t\t\n\t\t// make the lights avoid the trees\n\t    vec2 chos = 2.5 + 5.0*floor( pos.xz/5.0);\n\t    float r = length( pos.xz - chos);\n\t    pos.xz = chos + max( r, 1.5 )*normalize(pos.xz-chos);\n\t\t\n\t\tlpos[i].xyz = pos;\n\t\tlpos[i].w = smoothstep(5.0,10.0,iTime)*(0.85 + 0.15*sin(25.0*iTime+ 23.1*float(i)));\n\t}\n}\n\nvec3 castRay( in vec3 ro, in vec3 rd, in float precis, in float startf, in float maxd )\n{\n    float h = precis*10.0;\n    vec3 c;\n    float t = h*4.0;\n    float dsp = 0.0;\n    float sid = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n\t    vec3 res = map( ro+rd*t );\n        h = res.x;\n\t    sid = res.y;\n\t\tdsp = res.z;\n    }\n\n    if( t>maxd ) sid=-1.0;\n    return vec3( t, sid, dsp );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += h;\n\t\tif( t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 rd, float matID, in vec3 uvw, in float info, in vec3 sunDirection )\n{\n\n \n        vec3 rgb = vec3(0.0);\n\n     rgb = vec3(0.35,0.1,0.0);\nrgb = mix( rgb*0.15, vec3(0.2,0.12,0.03), smoothstep( 0.0, 1.0, uvw.y ) );\nfloat tt = texturize( iChannel1, 1.5*pos*vec3(1.0,0.5,1.0), nor ).x;\nrgb *= 0.2+1.5*tt;\ntt = texturize( iChannel1, 0.03*pos, nor ).x;\nfloat ff = texturize( iChannel1, 1.5*pos, nor ).x;\nfloat green = (1.0-smoothstep(0.0, 0.5, uvw.x*4.0 - tt + 0.1));\nrgb = mix( rgb, 2.4*vec3(0.045,0.05,0.00)*ff, 0.8*green );\n// bump\nvec2 cuv = vec2( uvw.x*3.0, info );\nfloat bu = 0.0;\nbu = 0.5 + 0.25*green;\nnor = normalize( nor + bu * (-1.0 + 2.0*texture( iChannel0, cuv ).xyz) );\n   \n    \n    // lighting terms\nfloat occ = uvw.z;\n     vec3 lig = sunDirection;//lpos[i]/SC - pos;\n     float llig = dot( lig, lig);\n \n   //float sha = softshadow( pos, sunDirection, 64.0, 0.0 );\n    float sha = softshadow( pos, sunDirection, 0.02*15., sqrt(llig)*15., 32.0 ); \n    \n\n    float sun = clamp( dot( nor, sunDirection ), 0.0, 1.0 );\n    float sky = clamp( 0.5 + 0.5*nor.y, 0.0, 1.0 );\n    float ind = clamp( dot( nor, normalize(sunDirection*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\nfloat fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0 ), 5.0 );\nfloat spe = pow( clamp( dot( reflect( rd, nor ), sunDirection ), 0.0, 1.0 ), 16.0 );\n\n     // compute lighting\n    vec3 lin  = 3.5*sun*vec3(1.75,1.30,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n         lin += 2.5*sky*vec3(0.82,0.75,0.50)*occ;\n         lin += 1.1*ind*vec3(0.30,0.35,0.25)*occ;\n         lin += 6.0*spe*sha*(0.5+0.5*fre);\n         lin *= 1.0 + 1.0*fre*occ*vec3(1.5,1.0,0.5);\n    for( int i=0; i<7; i++ )\n    {\n        vec3 lig = lpos[i].xyz - pos;\n        float llig = dot(lig,lig);\n        float im = inversesqrt( llig );\n        lig = lig * im;\n        lin += vec3(1.0,0.5,0.2)*1.5*lpos[i].w * clamp(dot(lig,nor),0.0,1.0)*im*im*occ;\n    }\n    \n    \nreturn rgb * lin * 1.3;\n}\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.0015;\n    float b = 0.005;\n    \n\tfloat ref = fbm( 48.0*pos, nor );\n    vec3 gra = -b*vec3( fbm(48.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                        fbm(48.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize ( nor - tgrad );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float ao = 0.0;\n    float sca = 15.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 15.*(0.01 + 0.015*float(i*i));\n        float dd = map( pos + hr*nor ).x;\n        ao += (hr-dd)*sca/15.;\n        sca *= 0.5;\n    }\n    return 1.0 - clamp( ao, 0.0, 1.0 );\n}\n\nfloat birdHeight( in vec3 ro, in vec3 rd, in float t, in vec3 lpo, in float ra )\n{\n\tfloat h = 0.0;\n\tvec3 lv = ro - lpo;\n\tfloat ll = dot(lv,lv);\n    if( ll < (t*t) ) // depth comparison\n    {\n\t\tfloat b = dot(rd,lv);\n\t\tfloat c = ll - ra;\n\t\th = max(b*b-c,0.0)/ra;\n        h = h*h*h*h;\n    }\n\treturn h;\n}\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    // move lights\n    vec3 lpos[7];\n    vec4 lcol[7];\n\n    for( int i=0; i<1; i++ )\n\t{\n\t    float la = 1.0;\n\t    lpos[i].x = 0.5 + 2.2*cos(0.22+0.1*iTime + 17.0*float(i) );\n\t    lpos[i].y = 0.25;\n\t    lpos[i].z = 1.5 + 2.2*cos(2.24+0.1*iTime + 13.0*float(i) );\n\n\t\t// make the lights avoid the columns\n        vec2 ilpos = floor( lpos[i].xz );\n        vec2 flpos = lpos[i].xz - ilpos;\n        flpos = flpos - 0.5;\n        if( length(flpos)<0.2 ) flpos = 0.2*normalize(flpos);\n\t    lpos[i].xz = ilpos + flpos;\n\t\t\n        lpos[i] *= 15.;\n        \n        float li = sqrt(0.5 + 0.5*sin(2.0*iTime+ 23.1*float(i)));\n\n        float h = float(i)/8.0;\n\t\tvec3 c = mix( vec3(1.0,0.8,0.6), vec3(1.0,0.3,0.05), 0.5+0.5*sin(40.0*h) );\n\t    lcol[i] = vec4( c, li );\n\t}\n\n    vec3 col = vec3(0.0);\n    vec3 res = castRay(ro,rd,0.001*15.,0.025*15.,20.0*15.);\n    float t = res.x;\n    if( res.y>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        float ao = calcAO( pos, nor );\npos /= 15.;\nt /= 15.;\n             col = calcColor( pos, nor, res.y );\n\n        nor = doBumpMap( pos, nor );\n\n        ao *= 0.7 + 0.6*res.z;\n        // lighting\n        vec3 lin = 0.03*ao*vec3(0.25,0.20,0.20)*(0.5+0.5*nor.y);\n\t\tvec3 spe = vec3(0.0);\n        for( int i=0; i<1; i++ )\n        {\n            vec3 lig = lpos[i]/15. - pos;\n            float llig = dot( lig, lig);\n            float im = inversesqrt( llig );\n            lig = lig * im;\n            float dif = dot( nor, lig );\n            dif = clamp( dif, 0.0, 1.0 );\n\t\t\tfloat at = 2.0*exp2( -2.3*llig )*lcol[i].w;\n            dif *= at;\n            float at2 = exp2( -0.35*llig );\n\n\t\t\tfloat sh = 0.0;\n\t\t\tif( dif>0.02 ) { sh = softshadow( pos*15., lig, 0.02*15., sqrt(llig)*15., 32.0 ); dif *= sh; }\n\n            float dif2 = clamp( dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 );\n            lin += 0.20*ao*dif2*vec3(0.35,0.20,0.10)*at2;\n            lin += 2.50*ao*dif*lcol[i].xyz;\n\t\t\t\n\t\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\t\tspe += ao*lcol[i].xyz*at*sh*(pow(pp,16.0) + 0.5*pow(pp,4.0));\n        }\n\t  \n        // material\n        col = mix( col, vec3(0.1,0.3,0.0), sqrt(max(1.0-ao*1.4,0.0))*smoothstep(-0.5,-0.1,nor.y) );\n        //col = mix( col, vec3(0.1,0.3,0.0), (1.0-smoothstep( 0.0, 0.12, abs(nor.y) - 0.1*(1.0-smoothstep(-0.1,0.3,pos.y)) ))*(1.0-smoothstep(0.5,1.0,pos.y)) );\n    \n        col = col*lin;\n\n        col += 3.0*spe*vec3(1.0,0.6,0.2);\n    }\nelse\nt /= 15.;\n\tcol *= exp( -0.055*t*t );\n\n    // lights\n\tfor( int i=0; i<1; i++ )\n\t{\n        vec3 lv = lpos[i]/15. - ro/15.;\n        float ll = length( lv );\n        if( ll<t )\n        {\n            float dle = clamp( dot( rd, lv/ll ), 0.0, 1.0 );\n\t\t\tdle = (1.0-smoothstep( 0.0, 0.2*(0.7+0.3*lcol[i].w), acos(dle)*ll ));\n            col += dle*6.0*lcol[i].w*lcol[i].xyz*dle*exp( -0.07*ll*ll );;\n        }\n    }\n\t\n\treturn col;\n}\nvec3 CameraPath( float t )\n{\n    //t = sin(t*.3);\n    t+= 5.0;\n    vec3 p = vec3(1.4+sin(t)*3.5, -.2, 20.0-+sin(t)*2.5);\n\treturn p;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = iTime;\n    float ctime = cos(.2*time);\n        \n  \n\n\t// camera\t\n\tvec3 ce = vec3( 0.5+mo.x, 0.25, 1.5 );\n\tvec3 ro = ce  + vec3( 1.3*ctime, 0.45 , 1.3*mo.y );\n//\tvec3 ro = ce  + vec3( 1.3*cos(0.11*time + 6.0), 0.65*(1.0-mo.y)- 0.2, 1.3*sin(0.11*time + 6.0*mo.x) );\n\tvec3 ta = ce ;//+ vec3( 0.95*cos(1.2+.08*time), 0.4*0.25+0.75*ro.y- 0.2, 0.95*sin(2.0+0.07*time) );\nro *= 15.;\nta *= 15.;\n\tfloat roll = -0.15*sin(0.000001*time);\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( sin(roll), cos(roll),0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\n    // ray march scene\n\tvec4 suvw;\n\tfloat info;\n\n     vec3 col = render( ro, rd );\n\n    float t = intersect( ro, rd, suvw, info );\n\n\tvec3 sunDirection = normalize( vec3(-0.1,0.5,-0.6) );\n \tif( t>0.0 )\n\t{\n\t    vec3 pos = ro + t*rd;\n\t    vec3 nor = calcNormal( pos );\n\n\n\t\tcol = shade( pos, nor, rd, suvw.x, suvw.yzw, info, sunDirection );\n\t}\n    else\n\t{\n\t\tt = 1e10;\n\t}\t\n   /*   \n    if (birdFlight == FIRST)\n    {\n      birdPosition = vec3(1.1,2.1,3.7);\n        birdFlight = HOVER;\n\n    }else if ( length(rd - birdPosition) > 1.)\n    {\n        birdFlight = HOVER;\n    } else\n    {\n        birdFlight = MOVING;\n    }\n        \n\tif (birdFlight == HOVER)\n    {\n        vec3 rrr = vec3(1.1,2.1,3.7) + birdPosition;\n\t\tcol += vec3(1.0,0.85,0.9)*birdHeight( ro, rd, t, rrr.xyz*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,1.0), 0.9 );\n    } else \n    {\n      vec3 rrr = birdPosition ;\n\t\tcol += vec3(1.0,0.85,0.9)*birdHeight( ro, rd, t, rrr.xyz*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,1.0), 0.9 );\n\n    }\n*/\n      vec3 rrr = vec3(1.1,2.1,3.7) ;\n\t\tcol += vec3(1.0,0.85,0.9)*birdHeight( ro, rd, t, rrr.xyz*vec3(1.5,1.0,1.5) + vec3(0.0,10.0,1.0), 0.9 );\n        \n\n\t\n\n\tcol = sqrt( col );\n\t\n    // vigneting\n    col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n\n    fragColor=vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}