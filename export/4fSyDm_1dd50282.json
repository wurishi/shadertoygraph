{"ver":"0.1","info":{"id":"4fSyDm","date":"1722389908","viewed":77,"name":"scaffolding","username":"Elsio","description":"entrando para a grande area das composições arquitetonicas?\nnão exatamente. Esse é mais um estudo. primeiramente desse tipo de raymarch e sua relação com o DDA. E em segundo, me parece um ótimo boilerplate para estudo de luz, sombra, textura e material. ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["voxel","dda","cave","tunel","andaime","architet"],"hasliked":0,"parentid":"McSXzV","parentname":"Vagalumes (hexagonal)"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define normal(p) normalize(map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)))\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define t iTime * 3.\n#define FAR 60.\n\nfloat gcd, id;\nvec3 gD;\n\nvec2 path(float z) {\n    float a = sin(z * .11);\n    float b = cos(z * .14);\n    return vec2(\n               a * 4. - b * 1.5,\n               b * 1.7 + a * 1.5);\n}\n\n\nfloat slength(vec3 p){\n    float k = 8.;\n    vec3 q = pow(abs(p), vec3(k));\n    return pow(dot(q, q/q), 1./k);\n}\n\nfloat box(vec3 p, vec3 b, float sf) {\n    p = abs(p) - b + sf;\n    return length(max(p, 0.)) - sf;\n}\n\n\nbool tunel(vec3 p) {\n    p.xy -= path(p.z);\n    \n    //return 2.5 - length(p.xy) < 0.; \n    \n    return max(\n               2.5 - length(p.xy), // shane\n               texture(iChannel0, p / 300.) .x - .55\n           ) < 0.;\n}\n\nfloat gCD(vec3 p){\n    vec3 g = (sign(gD) * .5 - p) / gD;\n    return max(min(min(g.x, g.y), g.z), 0.) + .0015;\n}\n\nvec3 Dir(vec3 p){\n    vec3 d = abs(p);\n    return step(d.yzx, d.xyz) * step(d.zxy, d.xyz) * sign(p);\n}\n\nfloat map(vec3 p) {\n    vec3 k = floor(p) + .5,\n         q = fract(p) - .5,\n         d = Dir(q);\n\n    gcd = gCD(q);\n    \n    bool c1 = cos(k.x * 2. + k.z * 3.) > .9,\n         c2 = cos(dot(k, vec3(8, 4, 1) / 12.)) > .8;\n    \n    float bloco = 1e5, \n          node  = 1e5,  \n          barra = box(q, abs(d) + .05, .01);\n    \n    \n    if(tunel(k)){\n        \n        bloco = c1 ? slength(q) - .4\n                   : box(q, vec3(.5), .05);\n        \n        if(c2) bloco = 1e5;\n        \n        node = box(q, vec3(.1), .02);\n        if(tunel(k + d))\n            node = min(node, barra);\n\n    }\n    \n    id = step(node, bloco);\n    return min(node, bloco);\n}\n\n\n\nfloat march(vec3 ro) {\n    vec3 p;\n    float i, s, d;\n    \n    while(i++ < 128.) {\n        p = ro + d * gD;\n        s = min(map(p), gcd);\n        \n        if(abs(s) < .001 || d > FAR) break;\n        \n        d += s;\n    }\n    \n    d = min(d, FAR);\n    return d;\n}\n\n\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 r = iResolution.xy;\n         u = (u - r * .5) / r.y;\n         \n    vec3 ro, eye, L, \n         fw, ri, up, D, p, N, col, e, cor;\n    \n    float FOV = 3.14 / 3., \n          ambience, d;\n    \n    ro  = vec3(0, 0, iTime * 4.);\n    eye = ro + vec3(0, 0, 1);\n    L   = ro + vec3(0, .5, 6);\n    \n    eye.xy += path(eye.z);\n    ro.xy  += path(ro.z);\n    L.xy   += path(L.z);\n    \n    fw = normalize(eye - ro),\n    ri = normalize(vec3(fw.z, 0., - fw.x)),\n    up = cross(fw, ri),\n    D = normalize(u.x * ri + u.y * up + fw / FOV),\n    e = vec3(.01, 0, 0);\n    \n    if(iMouse.z > 40.){\n        D.xz *= rot(iMouse.x * .01);\n        D.yx *= rot(iMouse.y * .01);\n    }\n    \n    gD = D;\n    \n    d = march(ro);\n    \n    cor = id < .5 ? vec3(8, 4, 1)\n                  : vec3(1, 4, 8);  \n    \n    o *= 0.;\n    if(d < FAR) {\n        p = ro + d * D;\n        N = normal(p);\n\n        ambience = \n                length(sin(N * 2.) * .5 + .5) / sqrt(3.) * \n                 smoothstep(- 1., 1., N.y);\n        \n        \n        o.rgb = cor * ambience * exp(-d * .1) * .3;\n    }\n    \n    o = sqrt(o);\n}","name":"Image","description":"","type":"image"}]}