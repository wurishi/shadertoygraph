{"ver":"0.1","info":{"id":"WdGBRW","date":"1606619131","viewed":136,"name":"Perlin noise (annotated)","username":"MightyAlex200","description":"Layered and warped Perlin noise, annotated in code. Just something I did for fun.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Perlin noise implementation\n\n// The first step for generating noise is getting a deterministic source of pseudo-random numbers.\n// We need something with O(1) time, and hash functions are a great way of doing this.\n// This is the \"Fowler–Noll–Vo\" hash function, used here because it is extremely simple.\n// You can read more about it on Wikipedia.\nuint fnv(uint i) {\n    const uint FNV_PRIME = 16777619U;\n    const uint FNV_OFFSET = 2166136261U;\n    \n    uint h = FNV_OFFSET;\n    // Integers are 32 bits in this language, 4 bytes.\n    for (uint it = 0U; it < 4U; it++) {\n        uint bits = it * 8U;\n    \th *= FNV_PRIME;\n   \t\th ^= (i >> bits) & 0xFFU;\n    }\n    \n    return h;\n}\n\n// You could just use that function as it is, but it's designed more for speed than for randomness.\n// We can increase randomness at the cost of speed by using this function, just running the hash function twice.\nuint fnv2(uint i) {\n\treturn fnv(fnv(i));\n}\n\n// We also define a helper function to create random values from 2D coordinates.\n// Note that we are not letting x and y \"interact\" directly, only letting y change the hash of x.\n// If x and y meet to produce some sort of \"sum\" value before hashing, it may cause positional artifacts.\nuint fnv2d(uint x, uint y) {\n    return fnv2(fnv2(x) ^ y);\n}\n\n// Just another helper function, this time including a seed value.\nuint fnv2ds(uint x, uint y, uint seed) {\n\treturn fnv2(fnv2d(x, y) ^ fnv2(seed));\n}\n\n// This is the interpolation function we will use for our noise.\n// This is an implementation of the \"Smoothstep\" algorithm.\n// You can try other functions if you want, but I personally think linear interpolation looks crap for pure noise.\nfloat interp(float a0, float a1, float w) {\n    return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;\n}\n\n// We use this function to do 2D interpolation.\n// There are four values interpolated between, and two coordinates dictating that interpolation.\n// If interp implemented linear interpolation then this function would implement bilinear interpolation.\n// The first four variable names are shorthand for Bottom Left, Bottom Right, Upper Left, Upper Right.\n// (Remember that WebGL works from bottom left instead of top left.)\nfloat bi_interp(float bl, float br, float ul, float ur, float x, float y) {\n\tfloat y1 = interp(bl, br, x);\n    float y2 = interp(ul, ur, x);\n    return interp(y1, y2, y);\n}\n\n// Finally, the noise function. It's rather long so I will comment it inside \nfloat perlin(float x, float y, uint seed) {\n    // Now, if you don't know, Perlin noise works by chosing a random vector (\"gradient\") for each point\n    // on a grid (usually the integers in a floating point space), and interpolating the dot products of\n    // those gradients and vectors from each corner to the coordinate.\n    \n    // First, we need a permutation table of vectors for generating gradients.\n    const uint LEN = 8U;\n    const vec2[LEN] VECS = vec2[] (\n        vec2( 1.,  1.),\n        vec2( 1., -1.),\n        vec2(-1.,  1.),\n        vec2(-1., -1.),\n        vec2( 0.,  1.),\n        vec2( 0., -1.),\n        vec2( 1.,  0.),\n        vec2(-1.,  0.)\n    );\n    \n    // Now, we will floor the floats to get the coordinates of the bottom left corner of the current grid square\n    uint gridx = uint(x);\n    uint gridy = uint(y);\n    \n    // Given that the grid squares are delineated by integers, the \"coordinate\" of the point inside the grid\n    // square is just the fractional component of the point.\n    // I wrote it this way this because it is nicer than `coordx = x - gridx` (the more technically\n    // correct version), IMO.\n    float fracx = fract(x);\n    float fracy = fract(y);\n    \n    // Now we generate the gradients, making use of the 2D seeded hash function to index the VECS array.\n    // Note that increasing the points by 1 is not arbitrary. It \"moves\" one vertex over in the grid.\n    // Change any of the 1s to other numbers to watch it break.\n    \n    // And yes, this function is written somewhat poorly by DRY standards (this should probably\n    // all be in a for loop), but I am optimizing for readability. It makes more sense to write\n    // the code to have a control flow similar to how we think about the algorithm conceptually.\n    vec2 gradbl = VECS[fnv2ds(gridx, gridy, seed) % LEN];\n    vec2 gradbr = VECS[fnv2ds(gridx + 1U, gridy, seed) % LEN];\n    vec2 gradul = VECS[fnv2ds(gridx, gridy + 1U, seed) % LEN];\n    vec2 gradur = VECS[fnv2ds(gridx + 1U, gridy + 1U, seed) % LEN];\n    \n    vec2 pos = vec2(fracx, fracy);\n    // Now the vectors to the 4 corners.\n    vec2 vecbl = pos - vec2(0., 0.);\n    vec2 vecbr = pos - vec2(1., 0.);\n    vec2 vecul = pos - vec2(0., 1.);\n    vec2 vecur = pos - vec2(1., 1.);\n    \n    // The dot products\n    float dotbl = dot(gradbl, vecbl);\n    float dotbr = dot(gradbr, vecbr);\n    float dotul = dot(gradul, vecul);\n    float dotur = dot(gradur, vecur);\n    \n    // Bringing it all home with 2D interpolation!\n    return bi_interp(\n    \tdotbl,\n        dotbr,\n        dotul,\n        dotur,\n        fracx,\n        fracy\n    );\n}\n\n// Great, we have a noise function! But it will require a little bit of preprocessing before it looks pretty.\n\n// A common method of making noise look better is to layer different frequencies of noise over each other\n// with different amplitudes.\n// This function does that according to a simple formula!\n// `it` layers of noise, each scaled by lacunarity ^ i with an amplitude of persistance ^ i (where i is\n// the current iteration number starting from 0)\nfloat noiseLayered(uint it, float lacunarity, float persistance, float x, float y) {\n\tfloat o = 0.0;\n    float mag = 0.0;\n    for (uint i = 0U; i < it; i++) {\n    \to += perlin(x * pow(lacunarity, float(i)), y * pow(lacunarity, float(i)), 0U) * pow(persistance, float(i));\n        mag += pow(persistance, float(i));\n    }\n    return o / mag;\n}\n\nconst float ZOOM = 50.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Scrolling effect is created here\n    float x = fragCoord.x / ZOOM + iTime * 4.;\n    float y = fragCoord.y / ZOOM + iTime * 4.;\n    // One last processing effect! You can actually warp the output of noise by warping the input space.\n    // We use perlin noise again (with different seeds) to determine which direction to warp the input space.\n    float offx = perlin(x, y, 1U);\n    float offy = perlin(x, y, 2U);\n    float offs = perlin(x, y, 3U) + 0.5;\n    float noise = noiseLayered(10U, 2., 0.5, x + offx * offs, y + offy * offs);\n    fragColor = vec4(\n        vec3(\n            noise + 0.5\n        ),\n        1.\n    );\n}","name":"Image","description":"","type":"image"}]}