{"ver":"0.1","info":{"id":"4s3yz4","date":"1517985367","viewed":48,"name":"two-sided-ribbon","username":"mdonahoe","description":"more logo experiments\nclick-and-drag to control the camera directly","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ribbon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Arcs\n */\n\n#define PI 3.14159265359\n\n// Simple colors\nconst vec3 blue = vec3(0,0,1);\nconst vec3 white = vec3(1,1,1);\nconst vec3 black = vec3(0,0,0);\nconst vec3 red = vec3(1,0,0);\nconst vec3 green = vec3(0,.8,0);\n\n\n\n#define NO_HIT 0\n#define HIT_BOX 1\n#define HIT_INNER_RIBBON 2\n#define HIT_OUTER_RIBBON 3\n\n\n\n\n// the bad example from IQ's article, Haha!\n// https://iquilezles.org/articles/noacos\nmat3 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat3( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c );\n}\n\n\n// Ray-Plane Intersection Test\nfloat iPlane(vec3 ro, vec3 rd, vec4 plane) {\n\tvec3 n = plane.xyz;\n\tfloat dist = -plane.w;\n\tfloat denom = dot(n, rd);\n\treturn - (dot(n, ro) + dist) / denom;\n}\n\n\nvoid swapIfGreater(inout float x, inout float y) {\n\tif(x>y) {\n\t\tfloat temp = x;\n\t\tx = y;\n\t\ty = temp;\n\t}\t\t\n}\n\n\n// Ray-Box Intersection Test\nfloat iBox(vec3 ro, vec3 rd, vec3 sides, out vec3 normal) {\n\tvec3 axis = normalize(vec3(0.0, 1.0, 0.0));\n\tmat3 rot = rotationAxisAngle(axis, PI/2.);\n\tvec3 xn = rot*vec3(1.0, 0.0, 0.0);\n\tvec3 yn = rot*vec3(0.0, 1.0, 0.0);\n\tvec3 zn = rot*vec3(0.0, 0.0, 1.0);\n\taxis = normalize(vec3(0.0, 1.0, 0.0));\n\txn = rot*xn;\n\tyn = rot*yn;\n\tzn = rot*zn;\t\n\tfloat t1, t2;\n\tfloat tNear = -10000.0;\n\tfloat tFar = 10000.0;\n\t\t\n\t// x -> yz-plane\n\tt1 = iPlane(ro, rd, vec4(xn, -0.5*sides.x));\n\tt2 = iPlane(ro, rd, vec4(xn, 0.5*sides.x));\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = xn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\t// y -> xz-plane\n\tt1 = iPlane(ro, rd, vec4(yn, -0.5*sides.y));\n\tt2 = iPlane(ro, rd, vec4(yn, 0.5*sides.y));\t\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = yn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\t// z -> xy-plane\n\tt1 = iPlane(ro, rd, vec4(zn, -0.5*sides.z));\n\tt2 = iPlane(ro, rd, vec4(zn, 0.5*sides.z));\t\n\tswapIfGreater(t1, t2);\n\tif(t1 > tNear) { normal = zn; tNear = t1; }\n\tif(t2 < tFar) tFar = t2;\n\tif(tNear > tFar) return -1.0;\n    if(tFar < 0.0) return -1.0;\n\t\n\treturn tNear;\n}\n\n\nfloat mod2pi(float a, float b) {\n    float delta = a - b;\n    return mod(delta + PI, 2.0 * PI) - PI;\n}\n\nvec2 tubeBounds(float offsetAngle, float centralAngle, float height, vec2 p) {\n    vec2 bounds = vec2(0.0, height);\n    float angle = atan(p.y, p.x);\n    float delta = mod2pi(offsetAngle, angle);\n    float q = angle + 1.0;\n    float qq = sin(q) * 1.2;\n    bounds.x -= qq / 4.0 - 0.0;\n    bounds.y -= qq / 6.0 - 0.0;\n    if (delta > centralAngle / 2.0) {\n        bounds.x = 0.0;\n        bounds.y = 0.0;\n    }\n    \n    // make a sharp leading edge\n    if (delta < -centralAngle) {\n        float z = -delta -centralAngle;\n        bounds.x += 0.0;\n        bounds.y -= 4.0 * z;\n    }\n    \n    return bounds;\n}\n\n\n// Intersect an uncapped cylindrical section\nfloat iTube(in vec3 ro, in vec3 rd, in vec3 base, in float radius, in float height, in float offsetAngle, in float centralAngle) {\n   \t// Thanks to https://www.shadertoy.com/view/4dSGW1 for the cylinder formula.\n    vec3  delta = ro - base;\n    float a = dot(rd.xz, rd.xz);\n    float b = dot(delta.xz, rd.xz);\n    float c = dot(delta.xz, delta.xz) - radius * radius;\n    float bbac = b*b - a*c;\n    if (bbac > 0.0) {\n        float t = (-b-sqrt(bbac)) / a;\n        vec3 p = ro + t * rd - base;\n        vec2 bounds = tubeBounds(offsetAngle, centralAngle, height, p.xz);\n        if (t > 0.0 && p.y > bounds.x && p.y < bounds.y) {\n            return t;\n        }\n        t = (-b+sqrt(bbac)) / a;\n        p = ro + t * rd - base;\n        bounds = tubeBounds(offsetAngle, centralAngle, height, p.xz);\n        if (t > 0.0 && p.y > bounds.x && p.y < bounds.y) {\n        \treturn t;\n        }\n    }\n    return -1.0;\n}\n\n\n// Check given ray against the various arcs\nint intersect( in vec3 ro, in vec3 rd, out float depth, out vec3 normal ){\n\tdepth = 1e6;\n\tint hit_id = NO_HIT; \n\tvec3 boxCenter = vec3(0.0, 1.0, 0.0);\n\tvec3 boxSides = vec3(1.0, 1.0, 1.0)*2.0;\n\tfloat t = iBox(ro - boxCenter, rd, boxSides, normal);\n\tif(t > 0.0 && t < depth ) {\n\t\thit_id = HIT_BOX;\n\t\tdepth = t;\n\t}\n\n    vec3 ribbonCenter = boxCenter;\n    float ribbonHeight = 0.5;\n    ribbonCenter.y -= ribbonHeight / 2.0 - 0.1;\n    float ribbonRadius = 1.7;\n    float ribbonThickness = 0.01;\n    float offsetAngle = 5.0 * iTime;\n    float centralAngle = PI / 1.5;\n    float tOuterTube = iTube(ro, rd, ribbonCenter, ribbonRadius + 0.001, ribbonHeight, offsetAngle, centralAngle);\n    if (tOuterTube > 0.0 && tOuterTube < depth) {\n    \tdepth = tOuterTube;\n        hit_id = HIT_OUTER_RIBBON;\n    }\n    float tInnerTube = iTube(ro, rd, ribbonCenter, ribbonRadius - 0.001, ribbonHeight, offsetAngle, centralAngle);\n    if (tInnerTube > 0.0 && tInnerTube < depth) {\n    \tdepth = tInnerTube;\n        hit_id = HIT_INNER_RIBBON;\n    }\n \n    \n\treturn hit_id;\n}\n\n\n\n// Transform from spherical to cartesian coordinates\nvec3 sphe2cart(vec2 p) {\n    vec2 s  = sin(p);\n    vec2 c  = cos(p);\n    return normalize(vec3(c.x * s.y, c.y, s.x * s.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Look at point (cd)\n    // Fixed\n    vec3 cd = vec3(0.0, 1.0, 0.0);\n    \n    // Camera origin (co)\n    // Rotate around box, decelerating to a stop, while moving backward.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 camSphe;\n    float x = iTime - 0.0;\n    float y = x * x;\n    float decelRamp = x;\n    if (iMouse.z < 1.0) {\n        // If the mouse button is not down, spin the camera automatically\n        camSphe = vec2(decelRamp, PI / 2.0);\n    } else {\n        // Otherwise use the mouse to control camera rotation.\n        vec2 centeredMouse = (iMouse.xy / iResolution.xy - 0.5 * vec2(1, 1));\n        //centeredMouse.x = 0.0;\n        camSphe = vec2(0.0, PI / 2.0) + centeredMouse * vec2(5.0, 1.2);\n    }\n    float dist = min(15.0 - 4.0 * camSphe.y, 1.0 + 3.0 * iTime);\n    vec3 co = sphe2cart(camSphe) * dist + vec3(2,1,0);\n    \n\n    // Ray direction (rd)\n    vec3 cf = normalize(cd - co);\n    vec3 cu = vec3(0.0,1.0,0.0);\n    vec3 cr = normalize(cross(cf, cu));\n    cu = cross(cr, cf);\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 1.0;\n    vec3 rd = normalize(cf + cr * uv.x + cu * uv.y);\n\n\t// Intersection test\n    // Send rays to detect intersections with objects\n    // intersect will return the object type \"hit_id\"\n\t// and set the ray depth and normal at the intersection point\n\tfloat depth;\n\tvec3 normal;\n\tint hit_id = intersect(co, rd, depth, normal);\n\n    // Color based on the object hit, ignore normals.\n    \n    float tt = mod(iTime, 15.0);\n    vec3 backgroundColor = black;\n \tvec3 boxColor = blue;\n    if (tt < 5.0) {\n        backgroundColor = white;\n \t\tboxColor = blue;\n    } else if (tt < 10.0) {\n        backgroundColor = black;\n \t\tboxColor = white;\n    } else if (tt < 15.0) {\n        backgroundColor = black;\n \t\tboxColor = blue;\n    }\n\n    \n \tvec3 outerRibbonColor = backgroundColor;\n \tvec3 innerRibbonColor = boxColor;\n\tvec3 intersectColor;\n    float alpha = 1.0;\n\tif(hit_id == HIT_BOX) {\n        intersectColor = boxColor;\n    } else if (hit_id == HIT_INNER_RIBBON) {\n        intersectColor = innerRibbonColor;\n    } else if (hit_id == HIT_OUTER_RIBBON) {\n        intersectColor = outerRibbonColor;\n        alpha = 0.8;\n    } else {\n    \talpha = 0.0;\n        intersectColor = backgroundColor;\n    }\n    vec4 im = texture(iChannel0, fragCoord / iResolution.xy);\n\tfragColor = vec4(intersectColor, alpha) + (1.0 - alpha) * im;\n}","name":"Image","description":"","type":"image"}]}