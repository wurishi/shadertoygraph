{"ver":"0.1","info":{"id":"Xtc3RS","date":"1469822465","viewed":5838,"name":"volumetric fractal pathtrace","username":"public_int_i","description":"Controls:\nlook - mouse\nmove - arrow keys\n\nrendering a fractal(distance field) using volume montecarlo path tracing.","likes":75,"published":1,"flags":48,"usePreview":0,"tags":["fractal","volumetric","tracer","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n/*\nControls:\nlook - mouse\nmove - arrow keys\n*/\n\n\n//display montecarlo path trace result\n\n\n#define devrender 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if devrender == 0\n    vec4 csamp = texture(iChannel0, 0.5/iResolution.xy);\n    vec4 samp = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = pow(samp/samp.w/*/(float(iFrame-int(csamp.x*4096.)))*/, vec4(1./2.2));\n    \n    //used for exporting image in the format of r=lighting, g=opacity\n\t//fragColor = texture(iChannel0, fragCoord/iResolution.xy)/(float(iFrame-120));\n    //fragColor.x = pow(fragColor.x, 1./2.2);\n    \n\t#else\n    fragColor = pow(texture(iChannel0, fragCoord/iResolution.xy), vec4(1./2.2));\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\n//montecarlo path tracing pass\n\n\n#define pi 3.1415926\n#define pi2 (pi*2.0)\n\n#define camera_fisheye 1.0\n\n#define iterations 256\n#define minDelta .2\n#define maxDelta 1.\n#define skipDelta .1\n\n#define range 256.\n\n\n#define sunImportance 0.5\n\n#define clouddeform 0.04\n#define clouddeformscale 0.25\n\n\n#define camerarange 256.\n\n\n#define fractal_seed 2.054\n#define fractal_seed2 1.53\n#define fractal_size 18.\n#define fractal_iter 3\n\n#define fractal_color vec3(.9)\n\n\nvec3 sunDirection = normalize(vec3(3.,5.,1.));\nconst vec3 sunColor = vec3(1.,.74,.94)*2.,\n    \t   skyColor = vec3(0.04,0.06,0.14)*0.0,\n    \t   ambientColor = vec3(.99);\n\nconst float sunSize = 0.004,//0-1\n    \t\tcloudDensity = 1.8,//0-2, density/alpha of the clouds\n    \t\tcloudFluff = .6,//0-1, fluffiness/alpha fade of clouds\n    \t\tcloudRoughness = 0.,// roughness of the clouds features\n            ambientDensity = 0.;//0-2, global mist\n\n\n\n#define devrender 0\n\n\n\nfloat ffract(float p) {\n    return fract(p)*2.-1.;\n}\nvec3 ffract(vec3 p) {\n    return fract(p)*2.-1.;\n}\n\n    \nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\n\nfloat encodeRot(vec2 r) {\n    return fract(r.x/pi2)+floor(.5+fract(r.y/pi2)*2048.);\n}\nvec2 decodeRot(float r) {\n    return vec2(r-floor(r),\n                floor(r)/2048.0)*pi2;\n}\n//random float 0-1 from seed a\nfloat hash(float a) {\n    return fract(fract(a*24384.2973)*512.34593+a*128.739623);\n}\n//random float 0-1 from seed p\nfloat hash3(in vec3 p) {\n    return fract(fract(p.x)*128.234+fract(p.y)*124.234+fract(fract(p.z)*128.234)+\n                 fract(p.x*128.234)*18.234+fract(p.y*128.234)*18.234+fract(fract(p.z*128.234)*18.234));\n}\n\n//random ray in a hemisphere relative to d, uses p as a seed\nvec3 randomHemiRay(in vec3 d, in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand*sign(dot(d,rand));\n}\n\n//random ray using p as a seed\nvec3 randomRay(in vec3 p) {\n    vec3 rand = normalize(ffract(ffract(p)*512.124+ffract(p*16.234)*64.3249+ffract(p*128.234)*12.4345));\n    return rand;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*.5,-p.y)-h.x*0.5);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat smax( float a, float b, float k) {\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\n//static backgrund\nvec3 background(vec3 d) {\n    float sun = dot(normalize(sunDirection), d);\n    return mix(skyColor,\n               sunColor,\n               pow(max(0., sun-(1.-sunSize))/sunSize,.3));\n}\n\n\nvec3 color(in vec3 p) {\n    return fractal_color;\n    \n    float mlen = max(abs(p.x),max(abs(p.y),abs(p.z)));\n    if (mlen < 30.) {\n        return vec3(.85);\n    }\n    \n    #define colorscale 10.\n    float id = mod(floor(p.x/colorscale)+floor(p.y/colorscale)+floor(p.z/colorscale), 2.);\n    return mix(vec3(1.,.46,.06),vec3(.14,.8,.9),id);\n}\n\n\nfloat ruins(in vec3 p) {\n    vec3 rp = p;\n    float d = 0.;\n    float s = fractal_size;\n    \n    #define seed fractal_seed\n    #define seed2 fractal_seed2\n    for (int i = 0; i < fractal_iter; i++) {\n        rp -= s/8.;\n        d = max(-sdBox(mod(abs(rp), s*2.)-s, vec3(s*.9)), d);\n        \n        if (mod(float(i),2.) > 0.) {\n            rp.xz = abs(rot(rp.xz,float(i)*1.2+seed));\n        } else {\n            rp.zy = abs(rot(rp.zy,float(i)*1.2+seed2));\n        }\n        \n    \ts /= 2.;\n    }\n                       \n    return max(sdTriPrism(p*vec3(1.,-1.,1.), vec2(60., 40.)), d);\n}\n\n//distance function defining the clouds shape\nfloat df(vec3 p) {\n\t\n    //base shape\n   \tfloat d = ruins(p);//abs(length(p.xy)-10.)-1.9;\n    \n    //cloud shape deform\n    #ifdef clouddeform\n\t#define ldst d\n    for (int i = 1; i < 4; i++) {\n        float pfi = pow(float(i),2.)*clouddeformscale;\n        ldst += abs(cos(p.x/pfi+cos(26.2348+ldst*cloudRoughness*p.z/pfi+(p.y*.39)/pfi)*4.)*\n     \t\t     cos(p.y/pfi+cos(29.8937+ldst*cloudRoughness*p.x/pfi+(p.z*.37)/pfi)*4.)*\n       \t\t     cos(p.z/pfi+cos(14.972+ldst*cloudRoughness*p.y/pfi+(p.x*.41)/pfi)*4.))*pfi*(clouddeform/clouddeformscale);\n    }\n\t#endif\n    \n    return max(skipDelta, d);\n}\n//density lerp percent from distance d and point p\nfloat dstToDensity(float d, vec3 p) {\n    return min(1., (d-skipDelta)*10.*(1.-cloudFluff));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 camtex = texture(iChannel1, 0.5/iResolution.xy);\n    float frame = texture(iChannel2, 0.5/iResolution.xy).x*4096.;\n       \n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //ray direction from uvs and ray position at origin\n    vec3 rd = normalize(vec3((fragCoord*2.-iResolution.xy)*vec2(-1.,1.)/iResolution.x,1./camera_fisheye)),\n         ird,\n         rp = camtex.xyz-camerarange;\n    \n    vec2 cameraRot = decodeRot(camtex.w);\n    rd.yz = rot(rd.yz,cameraRot.y);\n    rd.xz = rot(rd.xz,cameraRot.x);\n    \n    ird = rd;\n    float ifrm = float(iFrame);\n    #define rndifrm(s) fract(fract(ifrm*.044877+s)*256.494+ifrm*.02934)\n    \n    vec4 c = vec4(1,1,1,0);\n    \n    #if devrender == 0\n    \n    \n    //render\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp),\n              dt = d*(minDelta+hash3(rp+rndifrm(rp)*1024.)*(maxDelta-minDelta)),\n              k = dstToDensity(d,rp);\n        if (mix(cloudDensity,ambientDensity,k)*max(1.,dt*.1) > hash3(rp+rndifrm(rp)*256.)) {//if density > random then ray hits cloud\n            c.xyz *= pow(mix(color(rp),ambientColor,floor(k)),\n                             vec3(1.));\n            c.w = 1.;\n            rd = mix(randomRay(rp+rndifrm(rp*1024.)*1024.), sunDirection, floor(hash3(rp*.9+rndifrm(rp*1.5)*512.)+sunImportance-1e-6));\n        }\n        \n        rp += rd*dt;\n        if (length(rp) > range) break;\n    }\n   \n    c.xyz *= background(rd)*float(length(rp)/range > 1.);//if light ray makes it too edge of world illuminate it  \n    fragColor = mix(vec4(background(ird),1.), c, c.w)+\n    texture(iChannel0, uv)*float(float(iFrame)-frame > 1.0);//blend result with background and add to buffer\n\n    //used for exporting image in the format of r=lighting, g=opacity\n    /*(fragColor = vec4(c.x*float(max(length(rp)/range,max(0.,-rp.y)/yRange) > 1.),c.w,0,0)+\n                     texture(iChannel0, uv);\n    */\n    \n    #else\n    for (int i = 0; i < iterations; i++) {\n        float d = df(rp);\n        if (d < .2 || c.w > range) break;\n        \n        rp += rd*d;\n        c.w += d;\n    }\n    if (df(rp) < .2) {\n       c = vec4(cloudColor*(.3+max(0.,(df(rp)-df(rp-sunDirection)))),1.);\n    } else {\n       c = vec4(background(ird),1.); \n    }\n    fragColor = c+texture(iChannel0,uv);\n    #endif\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n//camera move and look\n\n\n\n#define uv (.5/iResolution.xy)\n#define camerarange 256.\n#define pi 3.1415926\n#define pi2 (pi*2.0)\n\n\n#define mouse_sensitivity 0.025 * 60.0\n#define movement_sensitivity 0.2 * 60.0\n\n\n\nfloat encodeRot(vec2 r) {\n    return fract(r.x/pi2)+floor(.5+fract(r.y/pi2)*2048.);\n}\nvec2 decodeRot(float r) {\n    return vec2(r-floor(r),\n                floor(r)/2048.0)*pi2;\n}\n\n\nvec2 rot(in vec2 v, in float ang) {\n    float si = sin(ang);\n    float co = cos(ang);\n    return v*mat2(si,co,-co,si);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(floor(fragCoord.x)+floor(fragCoord.y)) > 0) return;\n    \n    if (iFrame < 10) {\n     \t//set default camera\n        vec3 camPos = vec3(60., -5., 20.),\n             camRot = vec3(3.5, 3.14/3.0, 0.0);\n        \n        fragColor = vec4(camPos+camerarange, encodeRot(mod(camRot.xy,pi2)));\n        return;\n    }\n        \n   \tvec4 samp = texture(iChannel0, uv);\n    vec3 camPos = samp.xyz,\n             camRot = decodeRot(samp.w).xyy;\n    \n    //movement\n    float movementA = texture(iChannel1, vec2(38.5, 25.5)/255.).x-\n                                 texture(iChannel1, vec2(40.5, 25.5)/255.).x;\n    if (movementA != 0.) {\n        vec3 rdB = vec3(0.,0.,1.);    \n        rdB.yz = rot(rdB.yz,camRot.y);\n        rdB.xz = rot(rdB.xz,camRot.x);\n    \tcamPos.xyz += movementA*rdB*iTimeDelta*movement_sensitivity;\n    }\n    float movementB = texture(iChannel1, vec2(37.5, 25.5)/255.).x-\n                      texture(iChannel1, vec2(39.5, 25.5)/255.).x;\n    if (movementB != 0.) {\n         vec3 rdB = vec3(1.,0.,0.);    \n         rdB.yz = rot(rdB.yz,camRot.y);\n         rdB.xz = rot(rdB.xz,camRot.x);\n         camPos.xyz += movementB*rdB*iTimeDelta*movement_sensitivity;\n    }\n                \n    //rotation\n    if (iMouse.w > 0.) {\n    \tvec2 muv = (iMouse.xy/iResolution.xy)-.5;\n        camRot.xy += muv*vec2(1.,-1.)*mouse_sensitivity*iTimeDelta;\n    }\n\n    fragColor = vec4(max(camPos, 0.0), encodeRot(mod(camRot.xy,pi2)));\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Ethan Alexander Shulman 2016\n\n\n//frame of last camera change\n\n\n#define uv (.5/iResolution.xy)\n#define change_epsilon 1e-4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (int(floor(fragCoord.x)+floor(fragCoord.y)) > 0) return;\n    \n    vec4 csamp = texture(iChannel0, uv),\n         bsamp = texture(iChannel1, uv);\n    \n    float hash = fract(length(bsamp)+bsamp.w);\n    if (abs(hash-csamp.y) > change_epsilon) {\n     \tcsamp.y = hash;\n        csamp.x = float(iFrame)/4096.;\n    }\n    \n    fragColor = csamp;\n}","name":"Buf C","description":"","type":"buffer"}]}