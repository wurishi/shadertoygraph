{"ver":"0.1","info":{"id":"4XsBW8","date":"1730112146","viewed":25,"name":"HW_BardakovaN_CG_protection","username":"nikbard","description":"protection","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["hw1","itmo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Прямоугольник\nfloat sdfRect(vec2 uv, vec2 pos, vec2 size) {\n    vec2 halfSize = size * 0.5;\n    vec2 d = abs(uv - pos) - halfSize;\n    return step(max(d.x, d.y), 0.0); \n}\n\n// Функция для вращения координат вокруг центра\nvec2 rotate(vec2 uv, float angle, vec2 center) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    uv -= center;\n    uv = mat2(cosA, -sinA, sinA, cosA) * uv;\n    uv += center;\n    return uv;\n}\n\n// Функция для рисования вертолета\nvec3 drawHelicopter(vec2 uv, vec2 offset) {\n    vec3 col = vec3(0.5, 1.0, 0.5); \n\n    vec2 heliPos = offset; // Позиция вертолета будет определяться смещением\n    vec2 bodySize = vec2(0.4, 0.1); // Размер основы\n    vec2 tailSize = vec2(0.1, 0.05); // Размер хвостовой части\n    float bladeLength = 0.3; // Длина болших лопастей\n    float tailBladeLength = 0.08; // Длина меленьких лопастей\n\n    // основное тело вертолета\n    float body = sdfRect(uv, heliPos, bodySize);\n    col = mix(col, vec3(0.0, 0.0, 0.5), body); // Синяя основа\n\n    // Кабина\n    float cabin = sdfRect(uv, vec2(heliPos.x + 0.15, heliPos.y), vec2(0.1, 0.1));\n    col = mix(col, vec3(0.8, 0.8, 0.0), cabin); // Желтая кабина\n\n    // Хвост\n   float tail = sdfRect(uv, vec2(heliPos.x - 0.25, heliPos.y), tailSize);\n    col = mix(col, vec3(0.3, 0.3, 0.3), tail); // Серый хвост\n\n    // Лопасти главные\n    float blade1 = sdfRect(uv, vec2(heliPos.x, heliPos.y + 0.1), vec2(bladeLength, 0.02));\n    float blade2 = sdfRect(uv, vec2(heliPos.x, heliPos.y + 0.1), vec2(0.02, bladeLength));\n    col = mix(col, vec3(0.2, 0.2, 0.2), blade1); // Серые лопасти\n    col = mix(col, vec3(0.2, 0.2, 0.2), blade2); // Серые лопасти\n\n    // Вращение лопастей\n    float angle = iTime * 10.0; \n\n    // Лопасти на хвосте\n    vec2 tailBladePos1 = rotate(uv, -angle, vec2(heliPos.x - 0.35, heliPos.y));\n    vec2 tailBladePos2 = rotate(uv, -angle + 3.14159 / 2.0, vec2(heliPos.x - 0.35, heliPos.y)); // Перпендикулярные лопасти\n\n    float tailBlade1 = sdfRect(tailBladePos1, vec2(heliPos.x - 0.35, heliPos.y), vec2(tailBladeLength, 0.01));\n    float tailBlade2 = sdfRect(tailBladePos2, vec2(heliPos.x - 0.35, heliPos.y), vec2(tailBladeLength, 0.01));\n    \n    col = mix(col, vec3(0.0, 0.0, 0.0), tailBlade1); // Черные хвостовые лопасти\n    col = mix(col, vec3(0.0, 0.0, 0.0), tailBlade2); // Черные хвостовые лопасти\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy; // Нормализуем координаты\n    uv -= 0.5; // Центрируем координаты\n    uv.x *= iResolution.x / iResolution.y; // Сохраняем правильное соотношение сторон\n\n    //iChannel0 \n    vec2 heliOffset = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n\n    vec3 col = vec3(0.5, 1.0, 0.5); // Зеленый фон\n\n    // Рисуем вертолет\n    col = drawHelicopter(uv, heliOffset);\n\n    // Падающая платформа\n    float speed = 0.6; \n    vec2 platformSize = vec2(0.3, 0.05);\n\n \n    float timeCycle = mod(iTime * speed, 1.0);\n\n    \n    float cycleID = floor(iTime * speed); \n    float randomX = fract(sin(cycleID * 43758.5453)); \n    float platformXPos = mix(-0.5 + platformSize.x / 2.0, 0.5 - platformSize.x / 2.0, randomX); // Позиция по X\n\n\n    float platformYPos = 0.5 - timeCycle;\n\n\n    float platform = sdfRect(uv, vec2(platformXPos, platformYPos), platformSize);\n    col = mix(col, vec3(0.0, 0.4, 0.5), platform); // Цвет платформы\n\n    // Вывод на экран\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec2 handleKeyboard(vec2 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n\n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n\n    offset += (left + up + right + down) * velocity;\n\n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec2 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xy;\n\n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0, 0);\n}","name":"Buffer A","description":"","type":"buffer"}]}