{"ver":"0.1","info":{"id":"4cSGRm","date":"1704222413","viewed":30,"name":"Sound example (RTTTL ringtone)","username":"KaleyGoode","description":"Demonstrates minimal note sequencing, volume, envelope, phase correction. Simple compressed score (not a texture)","likes":2,"published":1,"flags":8,"usePreview":0,"tags":["example","sound","tutorial","ringtone","rtttl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nGo to the Sound Tab ^^^ to view the GPU Sound code \"mainSound\"\n\n*/\nvoid mainImage(out vec4 o, in vec2 fragCoord) {\n  float h = 20.,\n        s = h/14.;\n  vec2 uv = h*fragCoord.xy/iResolution.xy,\n        d = uv-vec2(4.,10.);\n  uv.y-=7.*s;\n  float t = (1.-s)+(s*((1.-abs(d.y)/h))); // Bright in the middle horizontally\n  if(uv.x < 1.) t=0.;\n  if(uv.x < 2.) {\n    if(abs(uv.y) > 3.) t=0.; // Speaker base\n  }else if(uv.x <  3.) t=0.; // Space between base and cone\n   else if(uv.x <= 6.) {     // Speaker Cone:\n    if((abs(uv.y)> 3.)&&(abs(uv.y) >= uv.x+1.)) t=0.;\n  }else if(0==(int(4.*iTime)&1)) { // Speaker Sound-wave:\n    float p = length(d);\n      t=((p < 2.)\n      || (p > 8.)\n      || (d.x < abs(d.y)) ? 0. : 1.-abs(mod(p,2.)-1.));\n    }else t=0.; // Background\n    o = vec4(t*vec3(.9,.8,.4),1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* This is my compressed version of the 'Dream' ringtone - voted most popular Ring-tone in the days when 'phones could only beep.\nI recorded it from a phone, looked at the waveform to figure out the timing of the notes, optimised the pattern and came up with the following RTTTL:\nDream:d=8,o=4,b=220:\nc3,4p.,     c,4p,   d#3, p,d#,d#3, p,d#, p,d#3, p,f3,4p.,     f,4p,   g3, p,g,g3, p,a#3,  p,c, p,\nc3, p,f5, p,c, p,c5,d#3,f5,d#,d#3, p,d#,f5,d#3,g5,f3,p,f5,  p,f, p,f5,g3,g5,g,g3, p,a#3,  p,c, p,\nc3,g5,f5, p,c,g5,c5,d#3,f5,d#,d#3, p,d#,f5,d#3,g5,f3,g,f5,  p,f,g5,f5,g3,g5,g,g3, p,a#3,d#5,c, p,\nc3,g5,f5,c5,c,g5,c5,d#3,f5,d#,d#3,g5,d#,f5,d#3,g5,f3,g,f5,d#5,f,g5,f5,g3,g5,g,g3,f5,a#3,d#5,c,c5,\nThe tune is best played through each of the four rows, then back up the rows repeating forever (row 012321 repeat).\nYou can see from the rows that the final row plays the full complex tune and previous rows are synchopated reductions.\nThis can be used to hold the tune in a highly compressed manner by storing the final row's notes, and the row on which the note starts being used.\nThe syncopation minimises the irritation associated with repetitive beeping.\nI originally used it commercially in code for a tiny embedded covert surveillance device for the military as an audio channel verification signal (so they could check their headphones were plugged in etc).\nI've converted it here to a GPU sound shader with maximal code and comments for clarity so that other annoying noises can accompany shaders ;-)\nA succinct (golfed) version (using ivec instead of arrays) is on my musical clock: https://www.shadertoy.com/view/4cSGRm\n*/\n#define  pi 3.14159265359\n#define tau (2.*pi)\n\n#define Volume .5\n#define Tempo 360. // beats per minute (320 is intended (5 beats per second), 240 is 4 beats per second)\n\n//__The_Score_Data_____________________________________________________________\n#define IntBits 32 // Data assumes 32 bit ints\n\n#define  ScoreBits      5\n#define  ScoreNotes     (1<<ScoreBits)\n#define   NotesMask     (ScoreNotes-1)\n#define ReverseFrom(_i) (0==(_i & (1<<(RowBits+ScoreBits))))\n\n#define RowBits    2 // The Row array is 32 2-bit values per int:\n#define RowMask    ((1<<RowBits)-1)\n#define RowsPerInt (IntBits / RowBits)\n\n#define NoteBits    4 // The Note array is eight 4-bit values per int:\n#define NoteMask    ((1<<NoteBits)-1)\n#define NotesPerInt (IntBits / NoteBits)\n\n#define PitchBits     10 // The pitch array is three 10-bit values per int:\n#define PitchMask     ((1<<PitchBits)-1)\n#define PitchesPerInt (IntBits / PitchBits)\n\n// Get fetches the data from the specified _array at _index and stores it in _result, using the _bits,_mask and _perInt settings for access:\n#define Get(_index, _array, _bits,_mask,_perInt, _result) { /*Scope*/ \\\n  float _i,_p = modf(float(_index)/float(_perInt), _i); /* find the index _and_ shift needed to unpack the bits from the int array */ \\\n  int _shift = ((_perInt-1)*_bits)-int(float(_perInt*_bits)*_p);      \\\n  _result = _mask & (_array[int(_i)]>>_shift);                        \\\n}\n/* The \"First\" array is 2 bits per note saying which row it starts playing on.\nThere are 32 notes in the maximal tune, so there are 64 bits to store in First.\nThe tune scans up and down 4 rows, bringing in more notes on each row (or removing it when reversing):\n0,2,1,3,0,2,1,0,1,0,0,3,0,1,0,1,0,2,1,3,0,2,1,0,1,0,0,3,0,2,0,3\nAs binary: 00 10 01 11 00 10 01 00 01 00 00 11 00 01 00 01 00 10 01 11 00 10 01 00 01 00 00 11 00 10 00 11\nConcatenate to 64 bits: 0010011100100100010000110001000100100111001001000100001100100011\nAs hexadecimal:              0x2724431127244323\nAs 32-bit ints:              0x27244311, 0x27244323 */\nconst int   First[] = int[] (0x27244311, 0x27244323); // 2 bits per note saying which row it starts playing on\nconst int   Notes[] = int[] (0x1DCA6DA2, 0xC72D7C2D, 0x39CB8DC4, 0xD94C5B6A); // 32 note nybbles. This is the complete Row[3], one note per nybble.\nconst int Pitches[] = int[] (0x083270AF, 0x0C43A906, 0x13757588, 0x20B9BABB, 0x31000000);\n/* The Pitches array is 10 bit frequencies is Hz packed three to an int:\nconst int Pitches[] = int[] ((((131<<10)|156)<<10)|175, (((196<<10)|234)<<10)|262, (((311<<10)|349)<<10)|392, (((523<<10)|622)<<10)|699, 784<<20); // 13 Frequencies (in Hz)\n                                c3,     d#3,       f3,     g3,     a#3,       c4,    d#4,      f4,       g4,     c5,     d#5,       f5,  g5\n__Globals_________________________________________________________________*/\nint Index =-1; // The note index\nint State = 0; // bit 7=Reverse; 6,5=Row; 4,3,2,1,0=Col\nint Pitch = 440;\n\n//__Main_______________________________________________________________________\nvec2 mainSound(int samp, float time) {\n  float index = 0.; // Which note is to be played (set by the following modf)\n  float t = modf(time*Tempo/60., index); // [SETS index on the line above] Unit interval [0,1] parametric point within the current note's life\n  if(Index != int(index)) {\n     Index  = int(index); // The core is the interpretation of bits in the count: (higher bits are ignored) bit 7=Reverse; 6,5=Row; 4,3,2,1,0=Col (which note in the row)\n    State = Index % 0xC0;\n    int row = (ReverseFrom(State) ? (0xC0 - (State & 0xE0))  & 0xE0 : State)>>(ScoreBits+1); // Magic mod. The ?,C0 and E0 bounce the row back and forth 0,1,2,3,2,1, 0,1,2,3,2,1... 0xC0 is max Row while reversing, 0xE0 masks Row and Reverse from Col\n    int col = State & NotesMask; // Column in the notes array entry\n    int stt = 0; // What Row a note starts being included on\n    Get(col, First,  RowBits,  RowMask,  RowsPerInt, stt);  // set 'on' to the row index that introduces this note\n    int note = 0; // The (index+1) of the pitch to be played or zero if it's a rest\n    Get(col, Notes, NoteBits, NoteMask, NotesPerInt, note); // set 'Note' to the (index+1) of the pitch to be played or zero if it's a rest\n    if((0==note)||(row<stt)) Pitch=0; // It's a rest note or on a row before this note is introduced\n    else Get(note-1, Pitches,PitchBits,PitchMask,PitchesPerInt, Pitch); // Set the pitch to play\n//Get(row, Pitches,PitchBits,PitchMask,PitchesPerInt, Pitch); // Use to debug values (listen to the numbers) try row or on+1 or Note-1\n//    Pitch*=2; // You might need to adjust the pitch to suit different speakers (to avoid resonance or limited frequency response)\n  }\n  float envelope = 1.-t; // descending ramp (1.-t = xylophone-like; 1.-.5*t = beep-like; abs(1.-2.*t) = synth bell-like; t = reversed xylophone = enohpolyx)\n  if(0==(Index&3)) envelope = min(1., .1+envelope); // 10% emphasis of the first beat of the bar (4:4 time)\n  return vec2(envelope * Volume * sin(tau * float(Pitch) * (time+float(samp)/iSampleRate)));\n}\n","name":"Sound","description":"","type":"sound"}]}