{"ver":"0.1","info":{"id":"ftV3Rw","date":"1637391632","viewed":70,"name":"GG's Strange Shadows","username":"guyemura","description":"simple","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//I learned how to make shapes and light movement from\n//https://www.youtube.com/watch?v=Ff0jJyyiVyw&ab_channel=TheArtofCode\n\n#define surf_hit .009\n#define max_dist 100.\n\n//first vector is position, second one is size\nfloat dBox(vec3 p, vec3 s) {\n    //the x, y, and z cannot get smaller than 0\n    return length(max(abs(p) - s, 0.));\n }\n\n//position of center and then radius of each circle\nfloat sdTorus (vec3 p, vec2 r) {\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\nfloat GetDist(vec3 p) {\n    //one away from ground plane, 6 away from us, radius of one so that it touches the ground\n    vec4 sphere = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p - sphere.xyz) - sphere.w;\n    //ground plane is going to be 0 so p.y\n    float planeDist = p.y;\n    \n    //float box distance\n    //position the box at -2, 2 above the ground, and 6 away from camera,\n    //size of square is .3 in every direction\n    float bd = dBox(p - vec3(-2, 2, 6), vec3(.3));\n    //float torus distance\n    float td = sdTorus(p - vec3(4, 2, 9), vec2(1., .5));\n    float dis = min(planeDist, sphereDist);\n    //actually adds the box to the shader\n    dis = min(dis, bd);\n    dis = min(dis, td);\n    return dis;\n}\n\n// marching shoots a ray based on the camera position and direction of ray\nfloat marching(vec3 camPos, vec3 rayDirec) {\n    //keeping track of distance from origin\n    float distOrig = 0.0;\n    \n    //marching loop\n    for (int i=0; i<100; i++) {\n        vec3 p = camPos + rayDirec * distOrig;\n        //distance to scene\n        float distScene = GetDist(p);\n        distOrig += distScene;\n        if(distOrig > max_dist || distScene < surf_hit) break;\n    }\n    //return the \n    return distOrig;\n}\n\n\nvec3 getNormal(vec3 p) {\n    float dist = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = dist - vec3(\n    //these are called \"swizzles\"; a trick to efficiently manipulate\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(n);\n}\n\n\n//p is some point that we want to return light value based on\nfloat returnLight(vec3 p) {\n    //light position right above sphere\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(2.* sin(iTime), 2. * cos(iTime)) * 2.;\n    vec3 normalizedLight = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float diffuseLight = clamp(dot(n, normalizedLight), 0., 1.);\n    float d = marching(p + n * surf_hit * 1.5, normalizedLight);\n    if(d<length(lightPos-p)) diffuseLight *= .1;\n    \n    return diffuseLight;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalizing it so that the uv is 0 in the middle\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    //camera at one above the ground\n    \n    vec3 camPos = vec3(0, 3, 0);\n    vec3 rayDirec = normalize(vec3(uv.x,uv.y-.3, 1));\n    \n    //distance from ray marching function\n    float dis = marching(camPos, rayDirec);\n    \n    vec3 p = camPos + rayDirec * dis;\n    \n    float diffuseLight = returnLight(p);\n    col = vec3(diffuseLight);\n    \n    //the minimum distance is going to be at least one because\n    //we are one unit above the ground\n    //dis /= 6. ;\n    \n    //col = vec3(dis);\n    //col = getNormal(p); //checks that the getNormal function is working\n    //converting what I see to RGB confirms that the function is correctly done\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}