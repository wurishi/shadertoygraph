{"ver":"0.1","info":{"id":"llGSzK","date":"1485198127","viewed":763,"name":"libg2vibrance","username":"tr4racer","description":"vibrance image processing","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["vibrance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int BIT_COUNT = 32;\n\nint modi(int x, int y) {\n    return x - y * (x / y);\n}\n\nint and(int a, int b) {\n    int result = 0;\n    int n = 1;\n\n    for(int i = 0; i < BIT_COUNT; i++) {\n        if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\n            result += n;\n        }\n\n        a = a / 2;\n        b = b / 2;\n        n = n * 2;\n\n        if(!(a > 0 && b > 0)) {\n            break;\n        }\n    }\n    return result;\n}\nvec4 vibrance(vec4 inCol, float vibrance) //r,g,b 0.0 to 1.0,  vibrance 1.0 no change, 0.0 image B&W.\n{\n       //float rf, gf, bf;\n \n       //rf = *r;\n       //gf = *g;\n       //bf = *b;\n \tvec4 outCol;\n    if (vibrance <= 1.0)\n    {\n        float avg = (inCol[0]*0.3 + inCol[1]*0.6 + inCol[2]*0.1);\n        //outCol = inCol * avg;\n        outCol[0] = inCol[0] * vibrance + avg*(1.0 - vibrance);\n        outCol[1] = inCol[1] * vibrance + avg*(1.0 - vibrance);\n        outCol[2] = inCol[2] * vibrance + avg*(1.0 - vibrance);\n    }\n    else // vibrance > 1.0\n    {\n        float hue_a, a, f, p1, p2, p3, i, h, s, v, amt, _max, _min, dlt;\n        float br1, br2, br3, br4, br5, br2_or_br1, br3_or_br1, br4_or_br1, br5_or_br1;\n        int use;\n\n        _min = min(min(inCol[0], inCol[1]), inCol[2]);\n        _max = max(max(inCol[0], inCol[1]), inCol[2]);\n        dlt = _max - _min + 0.00001 /*Hack to fix divide zero infinities*/;\n        h = 0.0;\n        v = _max;\n\n\t\tbr1 = 1.0 - float(_max > 0.0);\n        s = (dlt / _max)*(1.0 - br1);\n        h = -1.0*br1;\n\n        br2 = float((_max - inCol[0]) > 0.0);\n        br2_or_br1 = max(br2, br1);\n        h = ((inCol[1] - inCol[2]) / dlt)*(1.0 - br2_or_br1) + (h*br2_or_br1);\n\n        br3 = float((_max - inCol[1]) > 0.0);\n\n        \n        br3_or_br1 = max(br3, br1);\n        h = (2.0 + (inCol[2] - inCol[0]) / dlt)*(1.0 - br3_or_br1) + (h*br3_or_br1);\n\n        br4 = 1.0 - br2*br3;\n        br4_or_br1 = max(br4, br1);\n        h = (4.0 + (inCol[0] - inCol[1]) / dlt)*(1.0 - br4_or_br1) + (h*br4_or_br1);\n\n        h = h*(1.0 - br1);\n\n\n        hue_a = abs(h); // between h of -1 and 1 are skin tones\n        a = dlt;      // Reducing enhancements on small rgb differences\n\n        a = float(hue_a < 1.0)*a*(hue_a*0.67 + 0.33) + float(hue_a >= 1.0)*a;       //Reduce the enhancements on skin tones.                                        \n        a *= (vibrance - 1.0);\n        s = (1.0 - a) * s + a*pow(s, 0.25);\n\n\n\n        i = floor(h);\n        f = h - i;\n\n        p1 = v * (1.0 - s);\n        p2 = v * (1.0 - (s * f));\n        p3 = v * (1.0 - (s * (1.0 - f)));\n\n        inCol[0] = inCol[1] = inCol[2] = 0.0;\n        i += 6.0;\n        //use = 1 << ((int)i % 6);\n        use = int(pow(2.0,mod(i,6.0)));\n        a = float(and(use , 1)); // i == 0;\n        use /= 2;\n        inCol[0] += a*v;\n        inCol[1] += a*p3;\n     \tinCol[2] += a*p1;\n \n        a = float(and(use , 1)); // i == 1;\n        use /=2;\n        inCol[0] += a*p2;\n        inCol[1] += a*v;\n        inCol[2] += a*p1;\n\n        a = float( and(use,1)); // i == 2;\n        use /=2;\n        inCol[0] += a*p1;\n        inCol[1] += a*v;\n        inCol[2] += a*p3;\n\n        a = float(and(use, 1)); // i == 3;\n        use /= 2;\n        inCol[0] += a*p1;\n        inCol[1] += a*p2;\n        inCol[2] += a*v;\n\n        a = float(and(use, 1)); // i == 4;\n        use /=2;\n        inCol[0] += a*p3;\n        inCol[1] += a*p1;\n        inCol[2] += a*v;\n\n        a = float(and(use, 1)); // i == 5;\n        use /=2;\n        inCol[0] += a*v;\n        inCol[1] += a*p1;\n        inCol[2] += a*p2;\n\n        outCol = inCol;\n        //*r = rf;\n        //*g = gf;\n        //*b = bf;\n    }\n    return outCol;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,10.0*sin(iTime),1.0);\n    \n    float vibrance_0 = 4.0 + 4.0*sin(iTime);\n    vec4 pixel = texture(iChannel0, uv);\n\tfragColor = vibrance(pixel, vibrance_0);\n}","name":"Image","description":"","type":"image"}]}