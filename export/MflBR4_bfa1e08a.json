{"ver":"0.1","info":{"id":"MflBR4","date":"1723640664","viewed":105,"name":"Projected Multivariate Gaussian","username":"igneus","description":"Approximate affine projection of a multivariate gaussian PDF. Click and drag to change camera position.\n\nReferences: \n3D Gaussian Splatting for Real-Time Radiance Field Rendering (Kerbl et al 2023)\nEWA Volume Splatting (Zwicker et al 2001) ","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["gaussian","splat","splatting"],"hasliked":0,"parentid":"Xf2cDw","parentname":"Iterative path tracing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 rgba, in vec2 xyScreen )\n{        \n    vec4 texel = texelFetch(iChannel0, ivec2(xyScreen), 0);\n    rgba.xyz = pow(texel.xyz / max(1., texel.w), kOne * 0.7);\n    rgba.w = 1.;\n }","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define kInvalidMaterial -1\n\n\n// Ray-plane intersection test\nbool RayPlane(inout Ray ray, bool bounded, float extent, inout HitCtx hit, in Transform transform)\n{\n    RayBasic localRay = RayToObjectSpace(ray.od, transform);\n    if(abs(localRay.d.z) < 1e-10) { return false; } \n\n    float t = localRay.o.z / -localRay.d.z;\n    if (t <= 0.0 || t >= ray.tNear) { return false; }\n    \n    float u = (localRay.o.x + localRay.d.x * t) / extent + 0.5;\n    float v = (localRay.o.y + localRay.d.y * t) / extent + 0.5;\n    \n    if(bounded && (u < 0.0 || u > 1.0 || v < 0.0 || v > 1.0)) { return false; }   \n    \n    ray.tNear = t;\n    SetRayFlag(ray, kFlagsBackfacing, localRay.o.z < 0.0);\n    hit.n = transpose(transform.rot) * vec3(0.0, 0.0, 1.0);\n    hit.uv = vec2(u, v);\n    \n    return true;\n}\n\n// Ray-cylinder intersection test\nbool RayCylinder(inout Ray ray, inout HitCtx hit, in Transform transform, float height)\n{\n    RayBasic localRay = RayToObjectSpace(ray.od, transform);\n    \n    // A ray intersects a sphere in at most two places which means we can find t by solving a quadratic\n    float a = dot(localRay.d.xy, localRay.d.xy);\n    float b = 2.0 * dot(localRay.d.xy, localRay.o.xy);\n    float c = dot(localRay.o.xy, localRay.o.xy) - 1.0;\n    \n    // Intersect the unbounded cylinder\n    vec2 tNearCyl, tFarCyl;\n    if(!QuadraticSolve(a, b, c, tNearCyl.x, tFarCyl.x)) { return false; }    \n    sort(tNearCyl.x, tFarCyl.x);\n    \n    // Intersect the caps\n    tNearCyl.y = (-height * 0.5 - localRay.o.z) / localRay.d.z;\n    tFarCyl.y = (height * 0.5 - localRay.o.z) / localRay.d.z;    \n    sort(tNearCyl.y, tFarCyl.y);\n\n    float tNearMax = max(tNearCyl.x, tNearCyl.y);\n    float tFarMin = min(tFarCyl.x, tFarCyl.y);\n    if(tNearMax > tFarMin) { return false; }  // Ray didn't hit \n\n    float tNear;\n    if(tNearMax > 0.0 && tNearMax < ray.tNear) { tNear = tNearMax; }\n    else if(tFarMin > 0.0 && tFarMin < ray.tNear) { tNear = tFarMin; }\n    else { return false; } // Box is behind the ray\n    \n    vec3 i = localRay.o + localRay.d * tNear;\n    \n    ray.tNear = tNear;\n    hit.n = transpose(transform.rot) * ((tNearCyl.x < tNearCyl.y) ? vec3(0.0, 0.0, sign(i.z)) : vec3(i.xy, 0.));\n    SetRayFlag(ray, kFlagsBackfacing, dot(localRay.o, localRay.o) < 1.0);\n    \n    return true;\n}\n\nmat3 PinholeCameraViewMatrix(vec3 cameraPos, vec3 cameraLookAt)\n{\n    return CreateBasis(normalize(cameraPos - cameraLookAt), vec3(0., 1., 0.));\n}\n\nRay CreatePinholeCameraRay(vec2 uvScreen, vec3 cameraPos, vec3 cameraLookAt)\n{   \n    #define kCameraFoV          40.\n    Ray ray;\n    ray.od.o = cameraPos;\n    ray.od.d = transpose(PinholeCameraViewMatrix(cameraPos, cameraLookAt)) * normalize(vec3(uvScreen, -1. / tan(toRad(kCameraFoV))));\n    ray.tNear = kFltMax;\n    ray.weight = vec3(1.0, 1.0, 1.0);\n    ray.flags = kFlagsCausticPath;\n    ray.depth = 0;\n\n    return ray;  \n}\n\nvec3 PinholeCameraProjectPoint(vec3 p, vec3 cameraPos, vec3 cameraLookAt)\n{\n    // Transform the point into the basis of the camera sensor\n    p = PinholeCameraViewMatrix(cameraPos, cameraLookAt) * (p - cameraPos);\n                \n    return p / (p.z / -tan(toRad(kCameraFoV)));\n}\n\n// Unit quarternion to 3x3 rotation matrix\nmat3 QuartToMat(vec4 q)\n{\n    return 2. * mat3(vec3(0.5 - q.y*q.y - q.z*q.z, q.x*q.y + q.w*q.z, q.x*q.z - q.w*q.y),\n                     vec3(q.x*q.y - q.w*q.z, 0.5 - q.x*q.x - q.z*q.z, q.y*q.z + q.w*q.x),\n                     vec3(q.x*q.z + q.w*q.y, q.y*q.z - q.w*q.x, 0.5 - q.x*q.x - q.y*q.y));\n}\n\n// Trace axis-aligned cylinders and grids for reference\nint Trace(inout Ray ray, out HitCtx hit, bool indirectLambert)\n{\n    Transform transform;\n    hit.matID = kInvalidMaterial;   \n    \n    #define kAxisScale (1. / 200.)\n    for(int i = 0; i < 3; ++i)\n    {\n        vec3 rot = kZero;\n        if(i < 2) rot[1 - i] = kHalfPi;\n        transform = CompoundTransform(vec3(0.), rot, kAxisScale);\n        if(RayCylinder(ray, hit, transform, 1. / kAxisScale)) { hit.matID = i; } \n        Ray tempRay = ray;\n        HitCtx tempHit;\n        if(RayPlane(tempRay, true, 1. / kAxisScale, tempHit, transform)) \n        { \n            #define kGridThickness 0.02\n            vec2 uvFract = fract(tempHit.uv * (10. + kGridThickness));\n            if((uvFract.x < kGridThickness || uvFract.y < kGridThickness) && fract((uvFract.x + uvFract.y) * 10.) < 0.5)\n            {        \n                tempHit.matID = 3 + i; \n                tempHit.n = -ray.od.d;\n                ray = tempRay;\n                hit = tempHit;\n            }\n        }    \n    }\n    \n    return hit.matID;\n}\n\n// Decompose a 2x2 matrix into its constituent eigenvalues and eigenvectors\nbool Eigendecompose(in mat2 A, out vec4 v, out vec2 l)\n{\n    if(abs(A[0][0]) < 1e-10 && abs(A[0][1]) < 1e-10 && abs(A[1][0]) < 1e-10 && abs(A[1][1]) < 1e-10) { return false; }\n    \n    // Eigenvalues\n    float tr = 0.5 * (A[0][0] + A[1][1]);    \n    float det = determinant(A);    \n    l.x = tr + sqrt(tr*tr - det);\n    l.y = tr - sqrt(tr*tr - det);\n    \n    // For a diagonal matrix, the eigenvectors are the two rows of the input matrix\n    if(abs(A[1][0]) < 1e-10 && abs(A[0][1]) < 1e-10)\n    {\n        v.xy = normalize(A[0]);\n        v.zw = normalize(A[1]);\n    }\n    else\n    {    \n       v.xy = normalize((A[0][1] > A[1][0]) ? vec2(1, (l.x - A[0][0]) / A[0][1]) : vec2((l.x - A[1][1]) / A[1][0], 1));\n       v.zw = normalize((A[0][1] > A[1][0]) ? vec2(1, (l.y - A[0][0]) / A[0][1]) : vec2((l.y - A[1][1]) / A[1][0], 1));\n    }\n    \n    return true;    \n}\n\n// Decompose a 2x2 matrix into its constituent eigenvalues\nvec2 Eigenvalues(in mat2 A)\n{\n    if(abs(A[0][0]) < 1e-10 && abs(A[0][1]) < 1e-10 && abs(A[1][0]) < 1e-10 && abs(A[1][1]) < 1e-10) \n    { \n        return vec2(-kFltMax);\n    }\n    else\n    {    \n        float tr = 0.5 * (A[0][0] + A[1][1]);    \n        float det = determinant(A);    \n        return vec2(tr + sqrt(tr*tr - det), tr - sqrt(tr*tr - det));\n    }\n}\n\n\nvoid mainImage( out vec4 rgba, in vec2 xyScreen )\n{   \n    rgba = texelFetch(iChannel0, ivec2(xyScreen), 0);\n    bool mouseDown = (iMouse.z > 0. || iMouse.w > 0.);\n    if(mouseDown) rgba *= 0.;   \n    \n    if(rgba.w > 60.) { return; }\n\n    RenderCtx renderCtx;\n    renderCtx.xyScreen = ivec2(xyScreen);\n    renderCtx.rng = PCGInitialise(HashOf(uint(iFrame), uint(xyScreen.x), uint(xyScreen.y)));\n        \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    bool autoRotate = false;\n    if(iMouse.x <= 0. || iMouse.y <= 0.)\n    {\n        mouse = vec2(0.2, 0.35);\n        autoRotate = true;\n        mouseDown = true;\n    }\n    \n    vec2 uvView = ScreenToNormalisedScreen(xyScreen + (!mouseDown ? Rand4(renderCtx.rng).xy : vec2(0.)), iResolution.xy);     \n    \n    // Camera position\n    float cameraPhi = kTwoPi * mix(-1., 1., mouse.x);\n    if(autoRotate)\n    {\n        cameraPhi += iTime * 0.1;\n        rgba *= 0.;\n    }\n    float cameraTheta = kPi * mix(0.01, 0.99, mouse.y);\n    float cameraDist = 1.3; \n    vec3 cameraPos = vec3(sin(cameraTheta) * cos(cameraPhi), cos(cameraTheta), sin(cameraTheta) * sin(cameraPhi)) * cameraDist;\n    vec3 cameraLookAt = vec3(0., 0., 0.);\n    vec3 L = kZero;\n    \n    // Ray trace axes and planes\n    Ray ray = CreatePinholeCameraRay(uvView, cameraPos, cameraLookAt);    \n    HitCtx hit; \n    if(Trace(ray, hit, false) != kInvalidMaterial)\n    {        \n        vec3 albedo = kZero;\n        albedo[hit.matID % 3] = 1.;\n        L = -dot(ray.od.d, hit.n) * albedo * ((hit.matID >= 3) ? .3 : 1.);\n    }\n    \n    // World space position of splat \n    vec3 p = kZero;\n    // Camera view matrix\n    mat3 W = PinholeCameraViewMatrix(cameraPos, cameraLookAt);    \n    // Project splat position into clip space\n    vec3 pCam = W * (p - cameraPos);                \n    vec3 pView = pCam / (pCam.z * -tan(toRad(kCameraFoV)));\n        \n    // Rotation matrix based on random unit quaternion\n    renderCtx.rng = PCGInitialise(4u);\n    vec4 q = normalize(Rand4(renderCtx.rng));\n    mat3 R = QuartToMat(q);\n    \n    // Scaling matrix and its transpose product\n    vec3 s = vec3(0.2, 0.02, 0.1);\n    //vec3 s = vec3(0.1);\n    mat3 ST = mat3(vec3(s.x*s.x, 0.0, 0.0), vec3(0., s.y*s.y, 0.0), vec3(0., 0.0, s.z*s.z));\n    \n    // Jacobian of projective approximation (Zwicker et al)\n    float lenPCam = length(pCam);\n    mat3 J = mat3(vec3(1. / pCam.z, 0.0, pCam.x / lenPCam), \n                  vec3(0., 1. / pCam.z, pCam.y / lenPCam),\n                  vec3(-pCam.x / (pCam.z*pCam.z), -pCam.y / (pCam.z*pCam.z), pCam.z/lenPCam));\n    \n    // Build covariance matrix\n    mat3 cov = R * ST * transpose(R);\n    \n    // Project covariance matrix\n    mat3 sigma3 = J * W * cov * transpose(W) * transpose(J);\n    mat2 sigma2 = mat2(sigma3[0].xy, sigma3[1].xy);\n   \n    // Gaussian PDF\n    vec2 mu = uvView.xy - pView.xy;   \n    float G = exp(-0.5 * dot(mu * inverse(sigma2), mu));\n    \n    // Isoline perimeter\n    if(G > 0.01 && G < 0.011) { G = 0.3; }\n    \n    // Measure the bound of the splat\n    vec2 l = Eigenvalues(sigma2);\n    if(l.x >= 0. && length(mu) < sqrt(cwiseMax(l)) * 3.) \n    {\n        G += 0.1 * step(0.7, fract((uvView.x + uvView.y) * 100.));\n    }\n    \n    L = mix(L, kOne, G); \n\n    // Visualise matrix\n    if(false)\n    {\n        ivec2 xy = ivec2(xyScreen) / ivec2(iResolution / 3.);\n        float f = sigma3[xy.x][xy.y] * 10.;\n        L = abs(f) * ((f < 0.) ? kRed : kGreen);\n        if(abs(f) < 1e-3) L = kBlue;\n        if(!(f > -1e10 && f < 1e10)) L = kYellow;\n    }\n    \n    rgba += vec4(L, 1.0f);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// *******************************************************************************************************\n//    Math functions\n// *******************************************************************************************************\n\n#define kScreenDownsample 1\n#define kRenderDownsample 1\n\n#define kPi                    3.14159265359\n#define kInvPi                 (1.0 / 3.14159265359)\n#define kTwoPi                 (2.0 * kPi)\n#define kFourPi                (4.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRootPi                1.77245385091\n#define kRoot2                 1.41421356237\n#define kLog10                 2.30258509299\n#define kFltMax                3.402823466e+38\n#define kLog2                  0.6931471805\n#define kOneThird              (1.0 / 3.0)\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.)\n#define kZero                  vec3(0.)\n#define kRed                   vec3(1., 0., 0.)\n#define kGreen                 vec3(0., 1., 0.)\n#define kBlue                  vec3(0., 0., 1.)\n#define kYellow                vec3(1., 1., 0.)\n#define kMagenta               vec3(1., 0., 1.)\n#define kPink                  vec3(1., 0., 0.2) \n\n#define Timecode               vec3\n#define float5                 float[5]\n\nfloat cubrt(float a)           { return sign(a) * pow(abs(a), 1.0 / 3.0); }\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nvec2 sqr(vec2 a)               { return a * a; }\nvec3 sqr(vec3 a)               { return a * a; }\nvec4 sqr(vec4 a)               { return a * a; }\nint sqr(int a)                 { return a * a; }\nint cub(int a)                 { return a * a * a; }\nfloat cub(float a)             { return a * a * a; }\nfloat pow4(float a)            { a *= a; return a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat mod2(float a, float b)   { return mod(mod(a, b) + b, b); }\nvec3 mod2(vec3 a, vec3 b)      { return mod(mod(a, b) + b, b); }\nfloat length2(vec2 v)          { return dot(v, v); }\nfloat length2(vec3 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\nvec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\nvec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\nfloat sin01(float a)           { return 0.5 * sin(a) + 0.5; }\nfloat cos01(float a)           { return 0.5 * cos(a) + 0.5; }\nvec3 sin01(vec3 a)           { return 0.5 * sin(a) + 0.5; }\nvec3 cos01(vec3 a)           { return 0.5 * cos(a) + 0.5; }\nfloat saturate(float a)        { return clamp(a, 0.0, 1.0); }\nvec3 saturate(vec3 a)          { return clamp(a, 0.0, 1.0); }\nvec4 saturate(vec4 a)          { return clamp(a, 0.0, 1.0); }\nfloat saw01(float a)           { return abs(fract(a) * 2.0 - 1.0); }\nfloat cwiseMax(vec3 v)         { return (v.x > v.y) ? ((v.x > v.z) ? v.x : v.z) : ((v.y > v.z) ? v.y : v.z); }\nfloat cwiseMax(vec2 v)         { return (v.x > v.y) ? v.x : v.y; }\nint cwiseMax(ivec2 v)          { return (v.x > v.y) ? v.x : v.y; }\nfloat cwiseMin(vec3 v)         { return (v.x < v.y) ? ((v.x < v.z) ? v.x : v.z) : ((v.y < v.z) ? v.y : v.z); }\nint cwiseMin(ivec3 v)          { return (v.x < v.y) ? ((v.x < v.z) ? v.x : v.z) : ((v.y < v.z) ? v.y : v.z); }\nfloat cwiseMin(vec2 v)         { return (v.x < v.y) ? v.x : v.y; }\nfloat max3(float a, float b, float c) { return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c); }\nfloat min3(float a, float b, float c) { return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c); }\nvoid sort(inout float a, inout float b) { if(a > b) { float s = a; a = b; b = s; } }\nvoid swap(inout float a, inout float b) { float s = a; a = b; b = s; }\nvoid swap(inout int a, inout int b) { int s = a; a = b; b = s; }\n\nvec3 safeAtan(vec3 a, vec3 b)\n{\n    vec3 r;\n    #define kAtanEpsilon 1e-10\n    r.x = (abs(a.x) < kAtanEpsilon && abs(b.x) < kAtanEpsilon) ? 0.0 : atan(a.x, b.x); \n    r.y = (abs(a.y) < kAtanEpsilon && abs(b.y) < kAtanEpsilon) ? 0.0 : atan(a.y, b.y); \n    r.z = (abs(a.z) < kAtanEpsilon && abs(b.z) < kAtanEpsilon) ? 0.0 : atan(a.z, b.z); \n    return r;\n}\n\nvec3 GuardedNormalise(vec3 v, vec3 n)\n{\n    float len = length(v);\n    return (len > 1e-10) ? (v / len) : n;\n}\n\nvec3 SafeNormaliseTexel(vec4 t)\n{\n    return t.xyz / max(1e-15, t.w);\n}\n\nvec4 Sign(vec4 v)\n{\n    return step(vec4(0.0), v) * 2.0 - 1.0;\n}\n\nfloat Sign(float v)\n{\n    return step(0.0, v) * 2.0 - 1.0;\n}\n\nbool IsNan( float val )\n{\n    return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true;\n}\n\nbvec3 IsNan( vec3 val )\n{\n    return bvec3( ( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) ? false : true, \n                  ( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) ? false : true, \n                  ( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 ) ? false : true);\n}\n\nbvec4 IsNan( vec4 val )\n{\n    return bvec4( ( val.x < 0.0 || 0.0 < val.x || val.x == 0.0 ) ? false : true, \n                  ( val.y < 0.0 || 0.0 < val.y || val.y == 0.0 ) ? false : true, \n                  ( val.z < 0.0 || 0.0 < val.z || val.z == 0.0 ) ? false : true,\n                  ( val.w < 0.0 || 0.0 < val.w || val.w == 0.0 ) ? false : true);\n}\n\n\n#define SignedGamma(v, gamma) (sign(v) * pow(abs(v), gamma))\n\nbool QuadraticSolve(float a, float b, float c, out float t0, out float t1)\n{\n    float b2ac4 = b * b - 4.0 * a * c;\n    if(b2ac4 < 0.0) { return false; } \n\n    float sqrtb2ac4 = sqrt(b2ac4);\n    t0 = (-b + sqrtb2ac4) / (2.0 * a);\n    t1 = (-b - sqrtb2ac4) / (2.0 * a);    \n    return true;\n}\n\n// Closed-form approxiation of the error function.\n// See 'Uniform Approximations for Transcendental Functions', Winitzki 2003, https://doi.org/10.1007/3-540-44839-X_82\nfloat ErfApprox(float x)\n{    \n     float a = 8.0 * (kPi - 3.0) / (3.0 * kPi * (4.0 - kPi));\n     return sign(x) * sqrt(1.0 - exp(-(x * x) * (4.0 / kPi + a * x * x) / (1.0 + a * x * x)));\n}\n\nfloat UintToFloat01(uint i)\n{\n    return float(i) / float(0xffffffffu);\n}\n\nfloat UintToFloat01(uint i, int  bits)\n{\n    return float(i & ((1u << bits) - 1u)) / float(((1u << bits) - 1u));\n}\n\nvec3 Hue(float phi)\n{\n    float phiColour = 6.0 * phi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return mix(c0, c1, phiColour - float(i));\n}\n\n// *******************************************************************************************************\n//    Hash functions\n// *******************************************************************************************************\n\n// Constants for the Fowler-Noll-Vo hash function\n// https://en.wikipedia.org/wiki/Fowler-Noll-Vo_hash_function\n#define kFNVPrime              0x01000193u\n#define kFNVOffset             0x811c9dc5u\n#define kDimsPerBounce         4\n\n// Mix and combine two hashes\nuint HashCombine(uint a, uint b)\n{\n    return (((a << (31u - (b & 31u))) | (a >> (b & 31u)))) ^\n            ((b << (a & 31u)) | (b >> (31u - (a & 31u))));\n}\n\n// Compute a 32-bit Fowler-Noll-Vo hash for the given input\nuint HashOf(uint i)\n{\n    uint h = (kFNVOffset ^ (i & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 8u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 16u) & 0xffu)) * kFNVPrime;\n    h = (h ^ ((i >> 24u) & 0xffu)) * kFNVPrime;\n    return h;\n}\n\nuint HashOf(int a) { return HashOf(uint(a)); }\nuint HashOf(uint a, uint b) { return HashCombine(HashOf(a), HashOf(b)); }\nuint HashOf(uint a, uint b, uint c) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashOf(c)); }\nuint HashOf(uint a, uint b, uint c, uint d) { return HashCombine(HashCombine(HashOf(a), HashOf(b)), HashCombine(HashOf(c), HashOf(d))); }\nuint HashOf(vec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\nuint HashOf(ivec2 v) { return HashCombine(HashOf(uint(v.x)), HashOf(uint(v.y))); }\n\nfloat HashOfAsFloat(uint i)\n{    \n    return float(HashOf(i)) / float(0xffffffffu);\n}\n\nfloat HashOfAsFloat(uint i, int bits)\n{    \n    return float(HashOf(i) & ((1u << bits) - 1u)) / float(((1u << bits) - 1u));\n}\n\nvec3 BilinearHalf(sampler2D sampler, vec2 uv, int idx)\n{\n    uv *= vec2(textureSize(sampler, 0));\n    \n    vec4 t00 = texelFetch(sampler, ivec2(uv), 0);\n    vec4 t10 = texelFetch(sampler, ivec2(uv) + ivec2(1, 0), 0);\n    vec4 t01 = texelFetch(sampler, ivec2(uv) + ivec2(0, 1), 0);\n    vec4 t11 = texelFetch(sampler, ivec2(uv) + ivec2(1, 1), 0);\n    \n    idx = (idx & 1) << 1;\n    return mix(mix(vec3(unpackHalf2x16(floatBitsToUint(t00[idx])), t00[idx+1]), vec3(unpackHalf2x16(floatBitsToUint(t10[idx])), t10[idx+1]), fract(uv.x)), \n                mix(vec3(unpackHalf2x16(floatBitsToUint(t01[idx])), t01[idx+1]), vec3(unpackHalf2x16(floatBitsToUint(t11[idx])), t11[idx+1]), fract(uv.x)),\n                fract(uv.y));\n}\n\n///////\n\n\n// *******************************************************************************************************\n//    Random number generation\n// *******************************************************************************************************\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\n\n#define RNGCtx uvec4\n\nuvec4 PCGAdvance(inout RNGCtx rngSeed)\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 Rand4(inout RNGCtx ctx, ivec2 xy, sampler2D sampler)\n{\n    return texelFetch(sampler, (xy + ivec2(PCGAdvance(ctx) >> 16)) % 1024, 0);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 Rand4(inout RNGCtx ctx)\n{\n    return vec4(PCGAdvance(ctx)) / float(0xffffffffu);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nfloat[5] Rand5(inout RNGCtx ctx)\n{\n    vec4 v1 = vec4(PCGAdvance(ctx)) / float(0xffffffffu);\n    vec4 v2 = vec4(PCGAdvance(ctx)) / float(0xffffffffu);\n    return float[5](v1.x, v1.y, v1.z, v1.w, v2.x);\n}\n\n// Generates a tuple of canonical random numbers\nivec4 IRand4(inout RNGCtx ctx) { return ivec4(PCGAdvance(ctx)); }\n\n// Seed the PCG hash function with the current frame multipled by a prime\nRNGCtx PCGInitialise(uint frame)\n{    \n    return uvec4(20219u, 7243u, 12547u, 28573u) * frame;\n}\n\n// Reverse the bits of 32-bit inteter\nuint RadicalInverse(uint i)\n{\n    i = ((i & 0xffffu) << 16u) | (i >> 16u);\n    i = ((i & 0x00ff00ffu) << 8u) | ((i & 0xff00ff00u) >> 8u);\n    i = ((i & 0x0f0f0f0fu) << 4u) | ((i & 0xf0f0f0f0u) >> 4u);\n    i = ((i & 0x33333333u) << 2u) | ((i & 0xccccccccu) >> 2u);    \n    i = ((i & 0x55555555u) << 1u) | ((i & 0xaaaaaaaau) >> 1u);        \n    return i;\n}\n\n// Samples the radix-2 Halton sequence from seed value, i\nfloat HaltonBase2(uint i)\n{    \n    return float(RadicalInverse(i)) / float(0xffffffffu);\n}\n\nfloat HaltonBase3(uint seed)\n{\n    uint accum = 0u;\n    accum += 1162261467u * (seed % 3u); seed /= 3u;\n    accum += 387420489u * (seed % 3u); seed /= 3u;\n    accum += 129140163u * (seed % 3u); seed /= 3u;\n    accum += 43046721u * (seed % 3u); seed /= 3u;\n    accum += 14348907u * (seed % 3u); seed /= 3u;\n    accum += 4782969u * (seed % 3u); seed /= 3u;\n    accum += 1594323u * (seed % 3u); seed /= 3u;\n    accum += 531441u * (seed % 3u); seed /= 3u;\n    accum += 177147u * (seed % 3u); seed /= 3u;\n    accum += 59049u * (seed % 3u); seed /= 3u;\n    accum += 19683u * (seed % 3u); seed /= 3u;\n    accum += 6561u * (seed % 3u); seed /= 3u;\n    accum += 2187u * (seed % 3u); seed /= 3u;\n    accum += 729u * (seed % 3u); seed /= 3u;\n    accum += 243u * (seed % 3u); seed /= 3u;\n    accum += 81u * (seed % 3u); seed /= 3u;\n    accum += 27u * (seed % 3u); seed /= 3u;\n    accum += 9u * (seed % 3u); seed /= 3u;\n    accum += 3u * (seed % 3u); seed /= 3u;\n    return float(accum + seed % 3u) / 3486784400.0f;\n} \n\nfloat HaltonBase5(uint seed)\n{\n    uint accum = 0u;\n    accum += 244140625u * (seed % 5u); seed /= 5u;\n    accum += 48828125u * (seed % 5u); seed /= 5u;\n    accum += 9765625u * (seed % 5u); seed /= 5u;\n    accum += 1953125u * (seed % 5u); seed /= 5u;\n    accum += 390625u * (seed % 5u); seed /= 5u;\n    accum += 78125u * (seed % 5u); seed /= 5u;\n    accum += 15625u * (seed % 5u); seed /= 5u;\n    accum += 3125u * (seed % 5u); seed /= 5u;\n    accum += 625u * (seed % 5u); seed /= 5u;\n    accum += 125u * (seed % 5u); seed /= 5u;\n    accum += 25u * (seed % 5u); seed /= 5u;\n    accum += 5u * (seed % 5u); seed /= 5u;\n    return float(accum + seed % 5u) / 1220703124.0f;\n}\n\nfloat HaltonBase7(uint seed)\n{\n    uint accum = 0u;\n    accum += 282475249u * (seed % 7u); seed /= 7u;\n    accum += 40353607u * (seed % 7u); seed /= 7u;\n    accum += 5764801u * (seed % 7u); seed /= 7u;\n    accum += 823543u * (seed % 7u); seed /= 7u;\n    accum += 117649u * (seed % 7u); seed /= 7u;\n    accum += 16807u * (seed % 7u); seed /= 7u;\n    accum += 2401u * (seed % 7u); seed /= 7u;\n    accum += 343u * (seed % 7u); seed /= 7u;\n    accum += 49u * (seed % 7u); seed /= 7u;\n    accum += 7u * (seed % 7u); seed /= 7u;\n    return float(accum + seed % 7u) / 1977326742.0f;\n}\n\nfloat HaltonBase11(uint seed)\n{\n    uint accum = 0u;\n    accum += 214358881u * (seed % 11u); seed /= 11u;\n    accum += 19487171u * (seed % 11u); seed /= 11u;\n    accum += 1771561u * (seed % 11u); seed /= 11u;\n    accum += 161051u * (seed % 11u); seed /= 11u;\n    accum += 14641u * (seed % 11u); seed /= 11u;\n    accum += 1331u * (seed % 11u); seed /= 11u;\n    accum += 121u * (seed % 11u); seed /= 11u;\n    accum += 11u * (seed % 11u); seed /= 11u;\n    return float(accum + seed % 11u) / 2357947690.0f;\n}\n\nconst mat4 kOrderedDither = mat4(vec4(0.0, 8.0, 2.0, 10.), vec4(12., 4., 14., 6.), vec4(3., 11., 1., 9.), vec4(15., 7., 13., 5.));\nfloat OrderedDither(ivec2 xyScreen)\n{    \n    return (kOrderedDither[xyScreen.x & 3][xyScreen.y & 3] + 0.5) / 16.0;\n}\n\nuint FractalDither(ivec2 xyScreen)\n{    \n    uint sum = 0u;\n    for(int i = 0; i < 3; i++)\n    {    \n        sum += uint(kOrderedDither[xyScreen.x & 3][xyScreen.y & 3]);\n        xyScreen /= 4;\n    }\n    return sum;\n}\n\n// *******************************************************************************************************\n//    Owen-scrambled Sobol\n// *******************************************************************************************************\n\nconst uint[160] directions = uint[160](    \n    0x80000000u, 0x40000000u, 0x20000000u, 0x10000000u,\n    0x08000000u, 0x04000000u, 0x02000000u, 0x01000000u,\n    0x00800000u, 0x00400000u, 0x00200000u, 0x00100000u,\n    0x00080000u, 0x00040000u, 0x00020000u, 0x00010000u,\n    0x00008000u, 0x00004000u, 0x00002000u, 0x00001000u,\n    0x00000800u, 0x00000400u, 0x00000200u, 0x00000100u,\n    0x00000080u, 0x00000040u, 0x00000020u, 0x00000010u,\n    0x00000008u, 0x00000004u, 0x00000002u, 0x00000001u,\n\n    0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\n    0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\n    0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\n    0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\n    0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\n    0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\n    0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\n    0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu,\n\n    0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\n    0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\n    0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\n    0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\n    0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\n    0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\n    0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\n    0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u,\n\n    0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\n    0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\n    0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\n    0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\n    0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\n    0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\n    0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\n    0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u,\n\n    0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\n    0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\n    0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\n    0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\n    0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\n    0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\n    0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\n    0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\n    );\n\nuint sobol(uint index, uint dim)\n{\n    uint X = 0u;\n    for (uint bit = 0u; bit < 32u; ++bit)\n    {\n        uint mask = (index >> bit) & 1u;\n        X ^= mask * directions[dim*32u+bit];\n    }\n    return X;\n}\n\nuint hash_combine(uint a, uint b)\n{\n    return a ^ (b + (a << 6) + (a >> 2));\n    \n    //return (((a << (31u - (b & 31u))) | (a >> (b & 31u)))) ^\n    //        ((b << (a & 31u)) | (b >> (31u - (a & 31u))));\n}\n\nuint laine_karras_permutation(uint x, uint seed)\n{\n    x += seed;\n    x ^= x * 0x6c50b47cu;\n    x ^= x * 0xb82f1e52u;\n    x ^= x * 0xc7afe638u;\n    x ^= x * 0x8d22f6e6u;\n    return x;\n}\n\nuint nested_uniform_scramble_base2(uint x, uint seed)\n{\n    x = RadicalInverse(x);\n    x = laine_karras_permutation(x, seed);\n    x = RadicalInverse(x);\n    return x;\n}\n\nvec4 QRand4(RNGCtx ctx, uint dim)\n{\n    vec4 xi;\n    for (uint d = 0u; d < 4u; ++d, ++dim)\n    {\n        uint index = nested_uniform_scramble_base2(ctx.y, ctx.x);\n        xi[d] = float(nested_uniform_scramble_base2(sobol(index, d), hash_combine(ctx.x, d))) / float(0xffffffffu);\n    }\n\n    return xi;\n}\n\nfloat[5] QRand5(RNGCtx ctx, uint dim)\n{\n    float[5] xi;   \n    uint seed = HashCombine(ctx.x, dim);\n    uint index = nested_uniform_scramble_base2(ctx.y, seed);\n    for (uint d = 0u; d < 5u; ++d)\n    {\n        xi[d] = float(nested_uniform_scramble_base2(sobol(index, d), hash_combine(seed, d))) / float(0xffffffffu);\n    }\n    \n    /*xi[0] = float(nested_uniform_scramble_base2(RadicalInverse(index), hash_combine(ctx.x, dim))) / float(0xffffffffu);\n    xi[1] = float(nested_uniform_scramble_base2(uint(HaltonBase3(index) * float(0xffffffffu)), hash_combine(ctx.x, dim))) / float(0xffffffffu);\n    xi[2] = float(nested_uniform_scramble_base2(RadicalInverse(index), hash_combine(ctx.x, dim+1u))) / float(0xffffffffu);\n    xi[3] = float(nested_uniform_scramble_base2(uint(HaltonBase3(index) * float(0xffffffffu)), hash_combine(ctx.x, dim+1u))) / float(0xffffffffu);\n    xi[4] = float(nested_uniform_scramble_base2(RadicalInverse(index), hash_combine(ctx.x, dim+2u))) / float(0xffffffffu);*/\n        \n    /*xi[0] = fract(HaltonBase2(ctx.y) + UintToFloat01(HashOf(ctx.z, dim)));\n    xi[1] = fract(HaltonBase3(ctx.y) + UintToFloat01(HashOf(ctx.z, dim)));\n    xi[2] = fract(HaltonBase2(ctx.y) + UintToFloat01(HashOf(ctx.z, dim+1u)));\n    xi[3] = fract(HaltonBase3(ctx.y) + UintToFloat01(HashOf(ctx.z, dim+1u)));\n    xi[4] = fract(HaltonBase2(ctx.y) + UintToFloat01(HashOf(ctx.z, dim+2u)));  */\n    \n    return xi;\n}\n\nfloat[5] Halton5(RNGCtx ctx)\n{\n    float[5] xi; \n    xi[0] = HaltonBase2(ctx.y);\n    xi[1] = HaltonBase3(ctx.y);\n    xi[2] = fract(xi[0] + UintToFloat01(HashOf(ctx.z, 1u)));\n    xi[3] = fract(xi[1] + UintToFloat01(HashOf(ctx.z, 1u)));\n    xi[4] = fract(xi[0] + UintToFloat01(HashOf(ctx.z, 2u))); \n    return xi;\n}\n\nconst uint[32] codes = uint[32](0x8fcbc694u, 0xb9eb786au, 0x5929fb96u, 0xea53ae19u, 0x191824du, 0x9825a0c9u, 0xdf3f26f8u, 0x83ee84aau, 0xf583fc8du, 0xf9a361ceu, 0x2b695084u,\n0xa95c08b2u, 0x5121dd9au, 0x8755c4aeu, 0xb38ab962u, 0xc9daadbdu, 0x415b85dbu, 0x12f8433cu, 0x930c557bu, 0x54710d9eu, 0x568a45b0u,\n0x95703c0du, 0x3cfcf39cu, 0x7edcabeu, 0x2c0850fbu, 0xedb84d60u, 0xf74f9239u, 0x50e7ed9u, 0xa7567470u, 0xc784eba1u, 0x7a5017d3u,\n0x56070985u);\n\nfloat[5] QRand2(RNGCtx ctx, uint dim, int iFrame)\n{        \n    float5 xi;\n    xi[0] = UintToFloat01(RadicalInverse(ctx.y));\n    xi[1] = HaltonBase2(ctx.y); \n    return xi;\n}\n\n\n///////\n\n\nvec3 SampleUnitSphere(vec2 xi)\n{\n    xi.x = xi.x * 2.0 - 1.0;\n    xi.y *= kTwoPi;\n\n    float sinTheta = sqrt(1.0 - xi.x * xi.x);\n    return vec3(cos(xi.y) * sinTheta, xi.x, sin(xi.y) * sinTheta);\n}\n\nvec2 SampleUnitDisc(vec2 xi)\n{\n    float phi = xi.y * kTwoPi;   \n    return vec2(sin(phi), cos(phi)) * sqrt(xi.x);   \n}\n\n// Fast construction of orthonormal basis using quarternions to avoid expensive normalisation and branching \n// From Duf et al's technical report https://graphics.pixar.com/library/OrthonormalB/paper.pdf, inspired by\n// Frisvad's original paper: http://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\nmat3 CreateBasis(vec3 n)\n{\n    float s = Sign(n.z);\n    float a = -1.0 / (s + n.z);\n    float b = n.x * n.y * a;\n    \n    return mat3(vec3(1.0f + s * n.x * n.x * a, s * b, -s * n.x),\n                vec3(b, s + n.y * n.y * a, -n.y),\n                n);\n}\n\nmat3 CreateBasis(vec3 n, vec3 up)\n{\n    vec3 tangent = normalize(cross(n, up));\n\tvec3 cotangent = cross(tangent, n);\n\n\treturn transpose(mat3(tangent, cotangent, n));\n}\n\n\n// The minimum amount of data required to define an infinite ray in 3D space\nstruct RayBasic\n{\n    vec3   o;                   // Origin \n    vec3   d;                   // Direction  \n};\n\n// The \"full fat\" ray objects that most methods will refer to\nstruct Ray\n{\n    RayBasic od;   \n    \n    float    tNear;\n    vec3     weight;\n    uint     flags;\n    int      depth;\n};\n\nstruct HitCtx\n{\n    int      matID;\n    vec3     n;\n    vec2     uv;\n    float    alpha;\n};\n\nstruct RenderCtx\n{\n    RNGCtx rng;\n    ivec2 xyScreen;\n};\n\n#define kFlagsBackfacing      1u\n#define kFlagsSubsurface      2u\n#define kFlagsDirectSampleLight 4u\n#define kFlagsDirectSampleBxDF 8u\n#define kFlagsScattered       16u\n#define kFlagsProbePath       32u\n#define kFlagsCausticPath     64u\n#define kFlagsVolumetricPath  128u\n\n//#define InheritFlags(ray) (ray.flags & kFlagsScattered)\n#define InheritFlags(ray) (ray.flags & (kFlagsProbePath | kFlagsCausticPath))\n\n#define IsBackfacing(ray) ((ray.flags & kFlagsBackfacing) != 0u)\n#define IsSubsurface(ray) ((ray.flags & kFlagsSubsurface) != 0u)\n#define IsScattered(ray) ((ray.flags & kFlagsScattered) != 0u)\n#define IsDirectSampleLight(ray) ((ray.flags & kFlagsDirectSampleLight) != 0u)\n#define IsDirectSampleBxDF(ray) ((ray.flags & kFlagsDirectSampleBxDF) != 0u)\n#define IsDirectSample(ray) ((ray.flags & (kFlagsDirectSampleLight | kFlagsDirectSampleBxDF)) != 0u)\n#define IsProbePath(ray) ((ray.flags & kFlagsProbePath) != 0u)\n#define IsCausticPath(ray) ((ray.flags & kFlagsCausticPath) != 0u)\n#define IsVolumetricPath(ray) ((ray.flags & kFlagsVolumetricPath) != 0u)\n\nvoid SetRayFlag(inout Ray ray, in uint flag, in bool set)\n{\n    ray.flags = (ray.flags & ~flag) | uint(set);\n}\n\nvoid CreateRay(inout Ray ray, vec3 o, vec3 d, vec3 kickoff, vec3 weight, int depth, uint flags)\n{     \n    ray.od.o = o + kickoff;\n    ray.od.d = d;\n    ray.tNear = kFltMax;\n    ray.weight = weight;\n    ray.flags = flags;\n    ray.depth = depth;\n}\n\n#define PointAt(ray) (ray.od.o + ray.od.d * ray.tNear)\n\nstruct Transform\n{\n    vec3 trans;\n    mat3 rot;\n    float sca;\n};\n\nRayBasic RayToObjectSpace(in RayBasic world, in Transform transform) \n{\n\tRayBasic object;\n\tobject.o = world.o - transform.trans;\n\tobject.d = world.d + object.o;\n\tobject.o = transform.rot * object.o / transform.sca;\n\tobject.d = (transform.rot * object.d / transform.sca) - object.o;\n\treturn object;\n}\n\nmat3 Identity()\n{\n    return mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));\n}\n\nmat3 ScaleMat3(float scale)\n{\n    float invScale = 1.0f / scale;\n\treturn mat3(vec3(invScale, 0.0, 0.0),\n\t\t\tvec3(0.0, invScale, 0.0),\n\t\t\tvec3(0.0, 0.0, invScale));\n}\n\nmat3 RotXMat3(float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(1.0, 0.0, 0.0),\n\t\t\tvec3(0.0, cosTheta, -sinTheta),\n\t\t\tvec3(0.0, sinTheta, cosTheta));\n}\n\nmat3 RotYMat3(const float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(cosTheta, 0.0, sinTheta),\n\t\t\tvec3(0.0, 1.0, 0.0),\n\t\t\tvec3(-sinTheta, 0.0, cosTheta));\n}\n\nmat3 RotZMat3(const float theta)\n{\n    float cosTheta = cos(theta), sinTheta = sin(theta);\n\treturn mat3(vec3(cosTheta, -sinTheta, 0.0),\n\t\t\tvec3(sinTheta, cosTheta, 0.0),\n\t\t\tvec3(0.0, 0.0, 1.0));\n}\n\nTransform CompoundTransform(vec3 trans, vec3 rot, float scale)\n{\n    Transform t;\n    t.rot = Identity();\n    t.sca = scale;\n    t.trans = trans;\n\n    if (rot.x != 0.0) { t.rot *= RotXMat3(rot.x); }\n    if (rot.y != 0.0) { t.rot *= RotYMat3(rot.y); }\n    if (rot.z != 0.0) { t.rot *= RotZMat3(rot.z); }\n\n    //if (scale != 1.0f) { t.rot *= ScaleMat3(scale); }\n    \n    return t;\n}\n\nTransform IdentityTransform()\n{\n    Transform t;\n    t.rot = Identity();\n    t.sca = 1.0;\n    t.trans = kZero;\n    return t;\n}\n\nvec2 ScreenToNormalisedScreen(vec2 p, vec2 iRes)\n{   \n    return (p - vec2(iRes) * 0.5) / float(iRes.y); \n}\n\n\n","name":"Common","description":"","type":"common"}]}