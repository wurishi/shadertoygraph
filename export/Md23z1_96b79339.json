{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Fuzzy Field by eiffie\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Modifications by knighty\n// just trying to find a use for the new DoF renderer\nfloat focalDistance=4.5,aperature=0.04, fudgeFactor=1., fudgeFactor2=.25, jitter=0.0, focal=3.5;\nfloat FieldHalfWidth=2.;\n\n\n#define tim 0.5*iTime\n#define size iResolution\n\n#define TAO 6.283\n// i got these from knighty and/or darkbeam\nvoid Rotate(inout vec2 v,float angle) {v=cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nvoid Kaleido(inout vec2 v,float power){Rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\nfloat linstep(float a, float b, float t){return clamp((t-a)/(b-a),0.,1.);}\nfloat bell1(float a, float b, float t){\n\tconst float power=3.;\n\tt=2.*clamp((t-a)/(b-a),0.,1.)-1.;\n\treturn pow(1.-t*t,power);\n}\nfloat bell(float a, float b, float t){\n\tt=2.*clamp((t-a)/(b-a),0.,1.)-1.;\n\treturn 1.-t*t;\n}\n\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(tim*dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n\t//return texture(iChannel0,co,-100.).x;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn (length( pa - ba*h ) - r);\n}\nfloat DE(vec3 z0)\n{\n\tz0.xz=abs(mod(z0.xz+1.,2.00)-1.)-0.5;\n\treturn min(z0.y+0.25,sdCapsule(z0,vec3(-0.,0.0,0.),vec3(0.,.3,0.),.125));\n\t//return sdCapsule(z0,vec3(0.,0.0,0.),vec3(0.,.3,0.),.125);\n}\nvec3 mcol;\nfloat CE(vec3 z0){\n\tfloat d=DE(z0);\n\tif (d==z0.y+0.25) mcol+=vec3(.8);\telse \n\t\tmcol+=vec3(0.7)+vec3(sin(z0.xz*5.0)*0.5,0.25)*0.5;\n\treturn d;\n}\n\nfloat FuzzyShadow(vec3 ro, vec3 rd, float lightDist, float coneGrad, float rCoC, vec2 fragCoord){\n\t//return 1.;\n\tfloat t=DE(ro)+rCoC;//avoide self shadowing\n\tfloat d=1.0,s=1.0;\n\tfor(int i=0;i<20;i++){\n\t\tif(t>lightDist || s<0.05) break;\n\t\tfloat r=rCoC+t*coneGrad;//radius of cone\n\t\td=DE(ro+rd*t);\n\t\ts*=linstep(-r,r,d);\n\t\tt+=abs(d+0.5*r)*mix(1.,0.2*rand(fragCoord.xy*0.02*vec2(i)*t),jitter);\n\t\t//t+=max(d-r,r)*mix(1.,0.2*rand(fragCoord.xy*0.02*vec2(i)*t),jitter);\n\t}\n\treturn clamp(s,0.0,1.0);\n}\n\nfloat pixelSize;\nfloat CircleOfConfusion(float t){//calculates the radius of the circle of confusion at length t\n\treturn max(abs(focalDistance-t)-FieldHalfWidth,0.)*aperature+pixelSize*t;\n}\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,normalize(up)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tpixelSize=2./size.y/focal;\n\tfocalDistance=6.+3.*sin(iTime);\n\tvec3 ro=vec3(0.7,2.,0.);\n\tvec3 rd=vec3((2.0*fragCoord.xy-size.xy)/size.y,focal);\n\tfloat cor=focal/length(rd);\n\trd=lookat(vec3(1.0,1.55-ro.y*1.0,0.7),vec3(0.0,1.,0.0))*normalize(rd);\n\tvec3 L=normalize(vec3(5.,5.,-5.));\n\tvec4 col=vec4(0.0);//color accumulator\n\tfloat t=0.*(rand(tim+fragCoord.xy)-0.5);//distance traveled\n\tvec3 ro0=ro+focalDistance/cor*rd;\n\tfloat jj=0.;\n\tfor(int i=1;i<500;i++){//march loop\n\t\tif(col.w>0.9 || t>25.0)break;//bail if we hit a surface or go out of bounds\n\t\tfloat rCoC=CircleOfConfusion(t*cor);//calc the radius of CoC\n\t\tfloat d=DE(ro);\n\t\tif(abs(d)<rCoC){//if we are inside add its contribution\n\t\t\tmcol=vec3(0.0);//clear the color trap, collecting color samples with normal deltas\n\t\t\tvec2 v=vec2(rCoC*0.01,0.0);//use normal deltas based on CoC radius\n\t\t\tvec3 N=normalize(vec3(-CE(ro-v.xyy)+CE(ro+v.xyy),-CE(ro-v.yxy)+CE(ro+v.yxy),-CE(ro-v.yyx)+CE(ro+v.yyx)));\n\t\t\tfloat k = -dot(N,rd);\n\t\t\tif(k>0.)\n\t\t\t{\n\t\t\t\tjj+=1.;\n\t\t\t\t//vec3 rd0=t*cor<focalDistance ? normalize(ro0-ro-N*d) : normalize(ro-ro0-N*d);\n\t\t\t\tfloat sh=FuzzyShadow(ro, L, 3., 0.05, rCoC, fragCoord);\n\t\t\t\tvec3 scol=mcol*0.2*(0.3+sh*0.7*max(0.,dot(N,L)));\n\t\t\t\tscol+=sh*5.*k*pow(max(0.0,dot(reflect(rd,N),L)),50.0)*vec3(.5,0.5,0.5);\n\t\t\t\tfloat alpha=fudgeFactor2*fudgeFactor*k*(1.0-col.w)*bell(-rCoC,rCoC,d);//calculate the mix like cloud density\n\t\t\t\tcol+=vec4(scol*alpha,alpha);//blend in the new color\n\t\t\t}\n\t\t}\n\t\t//if(d<0.001) break;\n\t\td=max(d-0.5*rCoC,0.5*fudgeFactor2*rCoC)*fudgeFactor*mix(1.,rand(fragCoord.xy*0.02*vec2(i)*t),jitter);//add in noise to reduce banding and create fuzz\n\t\t//d=max(d,0.5*fudgeFactor2*rCoC)*fudgeFactor*mix(1.,rand(fragCoord.xy*0.02*vec2(i)*t),jitter);//add in noise to reduce banding and create fuzz\n\t\tro+=d*rd;//march\n\t\tt+=d;\n\t}//mix in background color\n\t//fragColor = vec4(jj/20.); return;\n\tvec3 scol=3.*mix(vec3(0.025,0.1,0.05)+rd*0.025,vec3(0.1,0.2,0.3)+rd*0.2,smoothstep(-0.1,0.1,rd.y));\n\tcol.rgb+=scol*(1.0-clamp(col.w,0.0,1.0));\n\n\tfragColor = vec4(clamp(col.rgb,0.0,1.0),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md23z1","date":"1384701259","viewed":5625,"name":"DOF Tweak 05","username":"knighty","description":"tweaking eiffie's spheres of confusion DE DOF","likes":101,"published":1,"flags":0,"usePreview":0,"tags":["dof","de","soc"],"hasliked":0,"parentid":"","parentname":""}}