{"ver":"0.1","info":{"id":"lccyDl","date":"1731330442","viewed":43,"name":"TP_2024_MIF02","username":"skala","description":"TP_2024_MIF02\nATTIA Corentin 12100557\nERGHAI Abdelmounaim 12100260","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tp2024mif02"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ATTIA Corentin 12100557\n// ERGHAI Abdelmounaim 12100260\n\n\n// couts\n\n// Opérations de base :\n// \n//     Addition/Soustraction : 1\n//     Multiplication : 1\n//     Division : 3 (généralement plus coûteuse que la multiplication)\n// \n// Fonctions mathématiques :\n// \n//     Racine carrée : 20\n//     Puissance (pow) : 25\n//     Fonctions trigonométriques (sin, cos, tan) : 30\n//     Logarithme : 30\n//     Exponentielle : 30\n// \n// Opérations vectorielles :\n// \n//     Produit scalaire (dot product) : 3 (multiplications + additions)\n//     Produit vectoriel (cross product) : 6\n//     Normalisation de vecteur : 25 (inclut une racine carrée)\n\n\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n\nstruct Material {\n    vec3 color;      // Couleur de base de l'objet\n    float ambient;   // Coefficient ambiant\n    float diffuse;   // Coefficient diffus\n    float specular;  // Coefficient spéculaire\n    float reflective; // Niveau de réflexion (0.0 = mat, 1.0 = très réfléchissant)\n};\n\n// Déclaration des matériaux globaux\nMaterial blackMaterial;\nMaterial whiteMaterial;\nMaterial blueMaterial;\nMaterial mirrorMaterial;\nMaterial redMirrorMaterial;\nMaterial metalMaterial;\nMaterial orangeMaterial;\n\n\n// Initialisation des matériaux\nvoid initializeMaterials() {\n  // Matériau noir Légèrement réfléchissant\n  blackMaterial.color = vec3(0.0, 0.0, 0.0);\n  blackMaterial.ambient = 0.3;\n  blackMaterial.diffuse = 0.7;\n  blackMaterial.specular = 0.2;\n  blackMaterial.reflective = 0.1; // \n\n  // Matériau blanc Légèrement réfléchissant\n  whiteMaterial.color = vec3(1.0, 1.0, 1.0); \n  whiteMaterial.ambient = 0.3;\n  whiteMaterial.diffuse = 0.7;\n  whiteMaterial.specular = 0.2;\n  whiteMaterial.reflective = 0.1;\n\n  // Matériau bleu sans réflexion et Mat\n  blueMaterial.color = vec3(0.3, 0.6, 0.9); \n  blueMaterial.ambient = 0.2;\n  blueMaterial.diffuse = 0.6;\n  blueMaterial.specular = 0.4;\n  blueMaterial.reflective = 0.0; \n\n  // Matériau miroir\n  mirrorMaterial.color = vec3(1.0, 1.0, 1.0); \n  mirrorMaterial.ambient = 0.0;              \n  mirrorMaterial.diffuse = 0.0;               \n  mirrorMaterial.specular = 1.0;              \n  mirrorMaterial.reflective = 1.0;           \n\n  // Matériau miroir rouge partiel\n  redMirrorMaterial.color = vec3(1.0, 0.0, 0.0); \n  redMirrorMaterial.ambient = 0.1;\n  redMirrorMaterial.diffuse = 0.2;\n    redMirrorMaterial.specular = 0.8;\n  redMirrorMaterial.reflective = 0.6;\n\n  // Matériau métallique pour les parties du robot\n  metalMaterial.color = vec3(0.8, 0.8, 0.8); // Gris métallique\n  metalMaterial.ambient = 0.3;\n  metalMaterial.diffuse = 0.7;\n  metalMaterial.specular = 0.9;\n  metalMaterial.reflective = 0.3;\n\n  // Matériau orange avec 95% de rugosité et une bonne diffusion\n  orangeMaterial.color = vec3(1.0, 0.6, 0.0);\n  orangeMaterial.ambient = 0.3;\n  orangeMaterial.diffuse = 0.95; \n  orangeMaterial.specular = 0.05; \n  orangeMaterial.reflective = 0.2;\n}\n// Fonction de translation du rayon\n// ray : Le rayon initial\n// t : Vecteur de translation\nRay translation(Ray r, vec3 t) \n{\n  return Ray(r.o + t, r.d); // Déplace l'origine du rayon en ajoutant la translation au vecteur origine\n}\n\n// Fonction de rotation du rayon\n// ray : Le rayon initial\n// m : Matrice de rotation\nRay rotation(Ray r, mat3 m)\n{\n  return Ray(r.o, m * r.d); // Applique la rotation sur la direction du rayon en multipliant la direction par la matrice\n}\n\n// Fonction de mise à l'échelle du rayon\n// ray : Le rayon initial\n// c : Centre de mise à l'échelle\n// s : Facteur d'échelle\nRay scale(Ray r, vec3 c, float s) \n{\n    vec3 newO = c + s * (r.o - c); // Calcule une nouvelle origine en appliquant la mise à l'échelle par rapport au centre\n    return Ray(newO, r.d); // Retourne un rayon avec la nouvelle origine et la direction inchangée\n}\n\n// Fonction pour inverser une translation\n// p : Point initial\n// v : Vecteur de translation\nvec3 inverseTranslation(vec3 p, vec3 v) {\n    return p - v; // Inverse la translation en soustrayant le vecteur de translation\n}\n\n// Fonction pour inverser une mise à l'échelle\n// p : Point à transformer\n// center : Centre de mise à l'échelle\n// factor : Facteur d'échelle\nvec3 inverseScale(vec3 p, vec3 center, float factor) {\n    return center + (p - center) / factor; // Applique l'inverse de la mise à l'échelle en divisant par le facteur\n}\n\n// Fonction pour inverser une rotation\n// p : Point à transformer\n// m : Matrice de rotation\nvec3 inverseRotate(vec3 p, mat3 m) {\n    return transpose(m) * p; // Applique l'inverse de la rotation en utilisant la transposée de la matrice\n}\n\n// Structure représentant une valeur de distance signée, un coût et un matériau\nstruct Val {\n  float v; // Distance signée\n  int c;   // Coût associé\n  Material m; // Matériau\n};\n\n// Fonction pour calculer un point sur un rayon\n// ray : Le rayon\n// t : Distance sur le rayon\nvec3 Point(Ray ray, float t)\n{\n    return ray.o + t * ray.d; // Calcule le point sur le rayon à une distance t\n}\n\n// Fonction pour générer une direction aléatoire dans un hémisphère\n// seed : Graine entière, entre 0 et N\n// n : Direction de l'hémisphère\nvec3 Hemisphere(int seed, vec3 n)\n{\n    float a = fract(sin(176.19 * float(seed))); // Calcul d'un aléatoire uniforme\n    float b = fract(sin(164.19 * float(seed))); // Calcul d'un autre aléatoire uniforme\n    \n    float u = 2.0 * 3.1415 * a; // Angle aléatoire autour de l'axe z\n    float v = acos(2.0 * b - 1.0); // Angle vertical (compensation pour les pôles)\n    \n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v)); // Direction résultante\n    if (dot(d, n) < 0.0) { d = -d; } // Vérifie que la direction est dans le bon hémisphère, sinon inverse-la\n    \n    return d; // Retourne la direction générée dans l'hémisphère\n}\n\n// Constante pour le nombre d'or\nconst float PHI = 1.61803398875; // Nombre d'or\n// Calcul de l'angle d'or\nconst float GOLDEN_ANGLE = 2.0 * 3.14159265359 / PHI; // Angle d'or (environ 137.5 degrés)\n\n// Fonction pour générer un point sur une sphère à l'aide de la suite de Fibonacci\n// k : Indice de la position dans la suite\n// n : Nombre total de points\n// center : Centre de la sphère\nvec3 fibonacciSphere(float k, float n, vec3 center) {\n    // Calcul des coordonnées sphériques\n    float theta = k * GOLDEN_ANGLE;  // Angle azimutal (theta)\n    float phi = acos(1.0 - 2.0 * (k + 0.5) / n); // Angle polaire (phi)\n    \n    // Conversion des coordonnées sphériques en coordonnées cartésiennes\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    \n    // Ajoute le décalage du centre pour obtenir la position du point\n    vec3 point = center + vec3(x, y, z);  // Translation du point en ajoutant le centre\n\n    return point; // Retourne le point en 3D déplacé au centre\n}\n\n// Fonction pour créer une matrice de rotation autour de l'axe Z\n// theta : Angle de rotation en radians\nmat3 rotationMatrixZ(float theta) {\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    return mat3(\n        cosTheta, -sinTheta, 0.0,\n        sinTheta, cosTheta, 0.0,\n        0.0, 0.0, 1.0\n    ); // Retourne une matrice de rotation autour de l'axe Z\n}\n\n// Fonction pour créer une matrice de rotation autour de l'axe X\n// angle : Angle de rotation en radians\nmat3 rotationMatrixX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0,  0.0,  0.0,\n        0.0,  c,   -s,\n        0.0,  s,    c\n    ); // Retourne une matrice de rotation autour de l'axe X\n}\n\n\n\n// Camera -------------------------------------------------------------------------------\n// Matrice de rotation autour de l'axe Z\n// a : Angle de rotation en radians\nmat3 Rz(float a)\n{\n  float sa = sin(a); \n  float ca = cos(a);\n  return mat3(\n    ca, sa, 0.0,    // Première ligne de la matrice (rotation autour de Z)\n    -sa, ca, 0.0,   // Deuxième ligne de la matrice (rotation autour de Z)\n    0.0, 0.0, 1.0   // Troisième ligne (pas de changement sur Z)\n  );\n}\n\n// Matrice de mise à l'échelle\n// s : Facteurs de mise à l'échelle (vecteur pour échelle sur les axes x, y, z)\nmat3 Scale(vec3 s)\n{\n    return mat3(\n        s.x, 0.0, 0.0,  // Mise à l'échelle sur l'axe X\n        0.0, s.y, 0.0,  // Mise à l'échelle sur l'axe Y\n        0.0, 0.0, s.z   // Mise à l'échelle sur l'axe Z\n    );\n}\n\n// Création de rayons pour la caméra\n// m : Coordonnées de la caméra\n// p : Coordonnées de l'écran (pixel)\nRay CreateRay(vec2 m, vec2 p) {\n  float a = 3.0 * 3.14 * m.x + 0.2;   // Calcul de l'angle horizontal\n  float b = m.y * 3.0 + 0.2;          // Calcul de l'angle vertical\n  float le = 3.5;                      // Longueur du rayon\n  vec3 ro = vec3(40.0 * b, 0.0, 15.0 * b) * mat3( // Calcul de l'origine du rayon\n      cos(a), sin(a), 0.0,\n      -sin(a), cos(a), 0.0,\n      0.0, 0.0, 1.0\n  );\n  vec3 ta = vec3(0.0, 0.0, 1.0);  // Point de visée de la caméra\n  vec3 w = normalize(ta - ro);    // Direction du rayon\n  vec3 u = normalize(cross(w, vec3(0.0, 0.0, 1.0))); // Vecteur horizontal\n  vec3 v = normalize(cross(u, w)); // Vecteur vertical\n  vec3 rd = normalize(p.x * u + p.y * v + le * w);  // Direction du rayon sur l'écran\n  return Ray(ro, rd);  // Retourne le rayon avec origine et direction\n}\n\n// Matrice de torsion autour de l'axe Z\n// angle : Angle de torsion\nmat3 torsionMatrixZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat3(\n        c, -s, 0.0,  // Matrice de torsion pour la rotation autour de Z\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\n// Appliquer la torsion à un point\n// p : Point à déformer\n// center : Centre autour duquel la torsion est appliquée\n// spiralFactor : Facteur de torsion pour ajuster l'intensité\nvec3 applyTorsion(vec3 p, vec3 center, float spiralFactor) {\n    vec3 np = p - center;  // Transpose le point par rapport au centre\n    float angle = spiralFactor * np.y;  // Calcul de l'angle de torsion basé sur la coordonnée Y\n    mat3 torsionMatrix = torsionMatrixZ(angle);  // Crée la matrice de torsion\n    vec3 pTorsion = torsionMatrix * np;  // Applique la torsion sur le point\n    return pTorsion + center;  // Retourne le point après application de la torsion\n}\n\n// Fonction pour générer un nombre pseudo-aléatoire basé sur une graine\n// seed : Graine pour la génération de nombres aléatoires\nfloat random(float seed) {\n    return fract(sin(seed) * 65444.41985);  // Fonction de hachage simple pour générer un nombre aléatoire\n}\n\n// Fonction pour appliquer un mouvement stochastique à un point\n// p : Point à déplacer\n// time : Temps utilisé pour créer une graine pour le mouvement aléatoire\nvec3 applyStochasticMovement(vec3 p, float time) {\n    // Utilise le temps comme graine pour créer des valeurs pseudo-aléatoires\n    float randomFactorX = random(p.x + time);\n    float randomFactorY = random(p.y + time);\n    float randomFactorZ = random(p.z + time);\n\n    // Mise à l'échelle des facteurs aléatoires pour contrôler l'amplitude du mouvement\n    float scale = 0.1; // Ajustez cette valeur pour augmenter ou diminuer l'aléatoire\n\n    // Applique un déplacement stochastique\n    return p + vec3(randomFactorX * scale, randomFactorY * scale, randomFactorZ * scale);\n}\n\n// Fonction de bruit (perlin-like)\nfloat noise(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.5432))) * 43758.5453);  // Génère un bruit pseudo-aléatoire basé sur la position du point\n}\n\n// Fonction de turbulence (fBm) pour simuler des détails à différentes échelles\n// p : Position du point\n// frequency : Fréquence du bruit\n// octaves : Nombre de couches de bruit\n// lacunarity : Facteur de croissance de la fréquence entre chaque octave\n// gain : Facteur d'amplitude entre chaque octave\nfloat turbulence(vec3 p, float frequency, int octaves, float lacunarity, float gain) {\n    float sum = 0.0;\n    float amplitude = 1.0;\n    float fq = frequency;\n\n    // Ajoute la contribution de chaque octave\n    for (int i = 0; i < octaves; i++) {\n        sum += amplitude * abs(noise(p * fq));  // Ajoute la turbulence à chaque octave\n        fq *= lacunarity;  // Augmente la fréquence\n        amplitude *= gain; // Réduit l'amplitude\n    }\n\n    return sum;  // Retourne la somme des turbulences\n}\n\n// Fonction pour le déplacement stochastique de p\n// p : Point à déplacer de manière stochastique\nvec3 displacementP(vec3 p) {\n    // Paramètres pour contrôler la turbulence\n    float amplitude = 0.1;\n    float frequency = 1.0;\n    int octaves = 4;\n    float lacunarity = 2.0;\n    float gain = 0.5;\n    \n    // Applique la turbulence pour créer un déplacement aléatoire sur le point\n    vec3 displacement = vec3(\n        turbulence(p, frequency, octaves, lacunarity, gain),\n        turbulence(p + vec3(31.416), frequency, octaves, lacunarity, gain),\n        turbulence(p + vec3(42.1337), frequency, octaves, lacunarity, gain)\n    );\n    return p + displacement * amplitude;  // Retourne le point déplacé\n}\n\n// Fonction pour générer un effet bois en utilisant le bruit\nvec3 Wood2(vec3 p) {\n  float frequency = 10.0;  // Augmentez cette valeur pour des cercles plus petits\n  vec3 q = p + 0.2 * displacementP(p);  // Applique le déplacement stochastique\n  float r = 0.5 * (1.0 + sin(frequency * length(q.xy)));  // Génère une variation de couleur selon la forme\n  vec3 lightWood = vec3(0.9, 0.7, 0.5);  // Couleur bois clair\n  vec3 darkWood = vec3(0.7, 0.5, 0.3);  // Couleur bois foncé\n  return mix(darkWood, lightWood, r);  // Mélange les deux couleurs pour un effet bois\n}\n\n// Fonction pour appliquer des bosses à un point en utilisant des sinusoïdes\nvec3 ApplyBumps(vec3 p) {\n    float frequency = 2.0;  // Fréquence des bosses\n    float amplitude = 0.2;  // Amplitude des bosses\n\n    // Déformer la position en appliquant des sinusoïdes sur les différentes coordonnées\n    p.y += amplitude * sin(frequency * p.x) * cos(frequency * p.z);\n    p.x += amplitude * cos(frequency * p.y) * sin(frequency * p.z);\n    p.z += amplitude * sin(frequency * p.y) * cos(frequency * p.x);\n\n    return p;  // Retourne la position déformée\n}\n\n\nMaterial createWoodMaterial(vec3 p) {\n    Material mat;\n    mat.color = Wood2(p); // Applique la texture de bois\n    mat.ambient = 0.3;\n    mat.diffuse = .5;\n    mat.specular = 0.2;\n    mat.reflective = 0.; // Légèrement réfléchissant\n    return mat;\n}\n\n\n// Primitives -------------------------------------------------------------------------------\n// Sphere\n// p : point à tester\n// c : centre de la sphère\n// r : rayon de la sphère\n// Coût total : 24\nVal Sphere(vec3 p, vec3 c, float r, Material mat)\n{\n  // Calcule la distance entre le point p et le centre de la sphère c, puis soustrait le rayon r\n  return Val(length(p - c) - r, 24, mat);\n}\n\n// Plan\n// p : point à tester\n// n : vecteur normal du plan\n// o : un point sur le plan\n// Coût total : 6\nVal Plane(vec3 p, vec3 n, vec3 o, Material mat)\n{\n    // Calcule la distance du point p au plan défini par le point o et la normale n\n    return Val(dot((p - o), n), 6, mat);\n}\n\n// Donut horizontal\n// p : point à tester\n// c : centre de la structure du donut\n// r1 : rayon autour du centre du donut\n// r2 : rayon autour de l'axe du donut\n// Coût total : 53\nVal Torus(vec3 p, vec3 c, float r1, float r2, Material mat) {\n\n    // Projette le point p dans le plan XZ pour calculer la distance à l'axe central du donut\n    vec2 q = vec2(length(p.xz - c.xz) - r1, p.y - c.y);\n\n    // Calcule la distance entre le point p et la surface du donut\n    return Val(length(q) - r2, 53, mat);\n}\n\n// Cylindre horizontal\n// p : point à tester\n// c : centre de la base du cylindre\n// r : rayon autour du cylindre\n// h : hauteur du cylindre\n// Coût total : 58\nVal Cylinder(vec3 p, vec3 c, float h, float r, Material mat) {\n\n    // Calcule la distance du point p à la surface du cylindre\n    vec2 d = abs(vec2(length(p.xz - c.xz), p.y - c.y)) - vec2(r, h);\n\n    // Calcule la distance signée en utilisant la méthode de distance minimale\n    return Val(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), 58, mat);\n}\n\n// Ellipsoïde\n// p : point à tester\n// c : centre de l'ellipsoïde\n// r1, r2 : rayons dans les directions x et y, respectivement\n// n : normale (utilisée pour d'autres calculs, pas utilisée ici)\n// Coût total : 38\nVal Ellipsoid(vec3 p, vec3 c, vec3 r, Material mat) {\n\n    // Calcule la distance normalisée du point p par rapport à l'ellipsoïde\n    return Val(length((p - c) / r) - 1.0, 38, mat);\n}\n\n// Capsule\n// p : point à tester\n// cA : premier point de la capsule (point a)\n// cB : second point de la capsule (point b)\n// r : rayon de la capsule\n// Coût total : 58\nVal Capsule(vec3 p, vec3 a, vec3 b, float r, Material mat) {\n\n    // Calcule la direction du segment [a, b] et le paramètre h pour le point le plus proche\n    vec3 pa = p - a, ba = b - a;\n\n    // Calcul du paramètre h qui détermine la position du point sur la capsule\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n    // Calcule la distance du point p à la capsule\n    return Val(length(pa - ba * h) - r, 58, mat);\n}\n\n// Pavé (boîte rectangulaire)\n// p : point à tester\n// c : centre du pavé\n// l : longueur sur l'axe x\n// w : largeur sur l'axe y\n// h : hauteur sur l'axe z\n// Coût total : 32\nVal Box(vec3 p, vec3 c, float l, float w, float h, Material mat) {\n    // Projette le point p sur les axes du pavé\n    vec3 d = abs(p - c) - vec3(l, w, h) * 0.5;\n\n    // Calcule la distance entre le point et le pavé en utilisant la méthode de distance signée\n    float outsideDist = length(max(d, vec3(0.0, 0.0, 0.0)));  // Distance extérieure au pavé\n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.0);  // Distance intérieure au pavé\n    float signedDist = outsideDist + insideDist;  // Distance totale signée\n\n    // Retourne la distance signée avec les coûts associés\n    return Val(signedDist, 32, mat);\n}\n\n// Opérateurs\n\n// Union\n// a,b : fonctions de champ des sous-arbres gauche et droit\nVal Union(Val a, Val b)\n{\n  // Effectue l'union des deux objets en comparant leurs distances et en prenant la plus petite\n  if (a.v < b.v) {\n    return Val(a.v, a.c + b.c + 1, a.m);  // On retourne l'objet de gauche si sa distance est plus petite\n  } else {\n    return Val(b.v, a.c + b.c + 1, b.m);  // Sinon on retourne l'objet de droite\n  }\n}\n\n// Correction de la distance pour rendre l'union plus lisse\n// a, b : distances à comparer\nfloat Correction(float a, float b) {\n  float r = 1.0;\n  float h = max(r - abs(a - b), 0.0) / r;  // On calcule une fonction de correction\n  return r * h * h * h * (1.0 / 6.0);  // La correction est une interpolation lissée entre les deux distances\n}\n\n// Union complexe avec correction de la distance\n// a, b : fonctions de champ des sous-arbres gauche et droit\nVal UnionComplexe(Val a, Val b)\n{\n  // L'union complexe prend en compte la correction des distances pour une transition plus douce\n  return Val(min(a.v, b.v) - Correction(a.v, b.v), a.c + b.c + 1, a.m);\n}\n\n// Intersection\n// a, b : fonctions de champ des sous-arbres gauche et droit\nVal Intersect(Val a, Val b) \n{\n  // L'intersection retourne la plus grande distance entre les deux objets\n  return Val(max(a.v, b.v), a.c + b.c + 1, a.m);\n}\n\n// Différence booléenne\n// a, b : fonctions de champ des sous-arbres gauche et droit\nVal BooleanDifference(Val a, Val b)\n{\n  // La différence retourne la distance du premier objet avec l'opposé du second\n  return Val(max(a.v, -b.v), a.c + b.c + 1, a.m);\n}\n\n// Objet de bounding\n// bObject : objet de bounding\n// objet : objet que l'on veut envelopper\nVal boundingObject(Val bObject, Val objet) \n{\n  // Si l'objet de bounding est en dehors de l'objet, on retourne l'objet de bounding\n  if (bObject.v > 0.0) {\n    return bObject;\n  } else {\n    return objet;  // Sinon, on retourne l'objet original\n  }\n}\n\n\n// Matrice de rotation\n// axis : axe autour duquel on effectue la rotation\n// angle : angle de rotation\nmat4 RotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);  // Normalisation de l'axe\n    float c = cos(angle);    // Cosinus de l'angle\n    float s = sin(angle);    // Sinus de l'angle\n    float t = 1.0 - c;       // Calcul de t (pour la matrice de rotation)\n\n    // Matrice de rotation 3x3 en 4x4 (avec une homothétie pour la transformation affine)\n    return mat4(\n        t * axis.x * axis.x + c,     t * axis.x * axis.y - s * axis.z, t * axis.x * axis.z + s * axis.y, 0.0,\n        t * axis.x * axis.y + s * axis.z, t * axis.y * axis.y + c,     t * axis.y * axis.z - s * axis.x, 0.0,\n        t * axis.x * axis.z - s * axis.y, t * axis.y * axis.z + s * axis.x, t * axis.z * axis.z + c,     0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n// Objet complexe\n\n// Crée un objet complexe constitué de sphères disposées autour d'un point\n// p : point à tester\n// center : centre de l'objet complexe\n// r : rayon de la sphère\n// mat_1, mat_2 : matériaux alternés pour les sphères\nVal ComplexObject(vec3 p, vec3 center, float r, Material mat_1, Material mat_2)\n{\n  // La sphère englobante a un rayon égal à r + r * 0.005\n  float boundingRadius = r + r * 0.2;\n  Val bObject = Sphere(p, center, boundingRadius, mat_1);  // Crée l'objet de bounding\n\n  Val v = Val(1.0, bObject.c, mat_1);  // Initialisation de la valeur de l'objet complexe\n  int n = 100;  // Nombre de points à échantillonner sur la sphère\n  Material mat;\n  \n  // Disposition des points autour de la sphère en utilisant la méthode de Fibonacci\n  for (int k = 0; k < n; ++k) {\n    if (k % 2 == 1) {mat = mat_1;}\n    else {mat = mat_2;}\n    vec3 point = fibonacciSphere(float(k), float(n), center);  // Calcul du point sur la sphère via Fibonacci\n    // On effectue l'union entre l'objet complexe et les nouvelles sphères positionnées\n    v = Union(v, Sphere(p, center + (point - center) * r, r * 0.2, mat));\n  }\n  \n  // Retourne l'objet complexe englobé par l'objet de bounding\n  return boundingObject(bObject, v);\n}\n\n// Exemple de démonstration d'union complexe entre deux sphères\nVal ShowcasingComplexUnion(vec3 p)\n{\n  return UnionComplexe(Sphere(p, vec3(10.0, 1.0, 1.0), 2.0, whiteMaterial), \n                       Sphere(p, vec3(9.0, 4.0, 1.0), 2.0, whiteMaterial));\n}\n\n\n\n// Potential field of the object\n// p : point\nVal object(vec3 p)\n{\n  float d = 12.5;\n  initializeMaterials();\n  vec3 p1 = vec3(-d,  d, 0.);\n  vec3 p2 = vec3( 0.,  d, 0.);\n  vec3 p3 = vec3( d,  d, 0.);\n\n  vec3 p4 = vec3(-d,  0., 0.);\n  vec3 p5 = vec3( 0.,  0., 0.); // centre\n  vec3 p6 = vec3( d,  0, 0);\n\n  vec3 p7 = vec3(-d, -d, 0.);\n  vec3 p8 = vec3( 0., -d, 0.);\n\n\n  Val plane = Plane(p,vec3(0.,0.,1.),vec3(0.0,0.0,-10.0),orangeMaterial);\n  Val fibonacciSphere = ComplexObject(p,p6,3.,whiteMaterial,blackMaterial);\n\n  vec3 cA = p1+vec3(0.,0.,2.);\n  vec3 cB = p1-vec3(0.,0.,2.);\n  Val capsule = Capsule(p,cA,cB,2., createWoodMaterial(p));\n  Val cylinder = Cylinder(\n     applyTorsion(inverseTranslation(p,vec3(0.,0.,3.)*(2.-sin(iTime))),p2,.2),\n     p2,5.,2.,\n     blueMaterial\n    );\n  Val cylinder2 = Cylinder(ApplyBumps(p),p3,5.,2.,whiteMaterial);\n  Val torus = Torus(inverseScale(p,p8,2.-sin(iTime)),p8,1.5,.75,blueMaterial);\n  Val complexUnionObject = ShowcasingComplexUnion(inverseRotate(p,rotationMatrixZ(3.*iTime)));\n  Val mirrorSphere = Sphere(p,p5,3.,mirrorMaterial);\n\n  Val box = Box(p, p4, 6.0, 6.0, 6.0, redMirrorMaterial);\n  Val ellipsoid = Ellipsoid(p,p7,vec3(2., 3.0, 4.),redMirrorMaterial);\n  \n  Val v = Union(plane, fibonacciSphere);\n  v = Union(v, capsule);\n  v = Union(v, cylinder);\n  v = Union(v, cylinder2);\n  v = Union(v, torus);\n  v = Union(v, complexUnionObject);\n  v = Union(v, mirrorSphere);\n  v = Union(v, box);\n  v = Union(v, ellipsoid);\n\n\n  return v;\n}\n// Analyse du champ scalaire -----------------------------------------------------------------\n\nconst int Steps = 200;  // Nombre d'étapes dans le raymarching\nconst float Epsilon = .01;  // Epsilon de marching (distance minimale de déplacement lors de chaque itération)\n\n// Calcul de la normale d'un objet\n// p : point où la normale est calculée\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps = .001;  // Petite valeur pour l'approximation des dérivées\n  vec3 n;\n  Val val = object(p);  // Obtient la valeur du champ scalaire à ce point\n  float v = val.v;\n  \n  // Calcul des dérivées sur les 3 axes pour approximer la normale\n  n.x = object(vec3(p.x + eps, p.y, p.z)).v - v;\n  n.y = object(vec3(p.x, p.y + eps, p.z)).v - v;\n  n.z = object(vec3(p.x, p.y, p.z + eps)).v - v;\n  \n  // Normalise le vecteur de la normale\n  return normalize(n);\n}\n\n// Traçage du rayon avec raymarching\n// ray : Rayon à tracer\n// e : Distance maximale\n// t : distance au point d'intersection\n// s : Nombre d'étapes effectuées\n// c : Coût cumulé du raymarching\n// m : Matériau de l'objet rencontré\nbool SphereTrace(Ray ray, float e, out float t, out int s, out int c, out Material m)\n{\n  bool h = false;\n  t = 0.0;  // Initialisation de la distance au point d'intersection\n  c = 0;  // Initialisation du coût cumulé\n  \n  for (int i = 0; i < Steps; i++)\n  {\n    s = i;  // Nombre d'étapes effectuées\n    vec3 p = Point(ray, t);  // Calcul du point à la distance t\n    Val val = object(p);  // Récupère la valeur du champ scalaire à ce point\n    float v = val.v;\n    m = val.m;  // Matériau de l'objet rencontré\n    c += val.c;  // Ajoute le coût de l'objet rencontré\n    \n    // Si la valeur du champ est inférieure à 0, cela signifie qu'on a trouvé un objet\n    if (v < 0.0)\n    {\n      h = true;  // L'objet est rencontré\n      break;\n    }\n    \n    // Avance le long du rayon\n    t += max(Epsilon, v);\n    \n    // Si la distance dépasse la distance maximale, on arrête le raymarching\n    if (t > e)\n    {\n      break;\n    }\n  }\n  return h;  // Retourne vrai si l'objet a été trouvé, sinon faux\n}\n\n\n// Éclairage -------------------------------------------------------------------------------\n\n// Couleur de fond\n// ray : Rayon\nvec3 background(Ray ray)\n{\n  // Interpolation de la couleur de fond en fonction de la direction du rayon\n  return mix(vec3(.45, .55, .99), vec3(.65, .69, .99), ray.d.z * .5 + .5);\n}\n\n// Calcul de l'ombre\n// p : Point\n// n : Normale à l'objet en ce point\n// l : Direction de la lumière\nfloat Shadow(vec3 p, vec3 n, vec3 l)\n{\n  float t;\n  int s;\n  int c;\n  Material m;\n  bool hit = SphereTrace(Ray(p + Epsilon * n, l), 100.0, t, s, c, m);  // Trace un rayon depuis le point éclairé\n  return hit ? 0.0 : 1.0;  // Si on rencontre un objet, il y a de l'ombre, sinon la lumière est totale\n}\n\n// Fonction d'éclairage sans récursivité\nvec3 Shade(vec3 p, vec3 n, Ray eye, Material mat) {\n  vec3 finalColor = vec3(0.0);\n\n  // Composante ambiante\n  vec3 ambient = mat.ambient * mat.color;\n\n  // Position de la source de lumière\n  const vec3 lp = vec3(5.0, 10.0, 25.0);\n  vec3 l = normalize(lp - p);  // Direction de la lumière\n\n  // Calcul de l'ombre\n  float shadow = Shadow(p, n, l);\n\n  // Composante diffuse\n  vec3 diffuse = mat.diffuse * clamp(dot(n, l), 0.0, 1.0) * mat.color;\n\n  // Composante spéculaire\n  vec3 r = reflect(-l, n);\n  vec3 specular = mat.specular * pow(clamp(dot(r, -eye.d), 0.0, 1.0), 35.0) * vec3(1.0);\n\n  // Couleur finale sans réflexion\n  finalColor = ambient + shadow * (diffuse + specular);\n\n  // Gestion de la réflexion sans récursivité\n  if (mat.reflective > 0.0) {\n    // Calcul de la direction du rayon réfléchi\n    vec3 reflectDir = reflect(eye.d, n);\n    Ray reflectRay = Ray(p + n * Epsilon, reflectDir);  // Rayon réfléchi\n    vec3 reflectColor = background(reflectRay);  // Couleur de fond si aucun objet n'est rencontré dans la réflexion\n\n    // Traçage du rayon réfléchi\n    float t;\n    int s, c;\n    Material reflectMat;\n    bool hit = SphereTrace(reflectRay, 100.0, t, s, c, reflectMat);\n    if (hit) {\n      // Position de l'intersection et normale à ce point réfléchi\n      vec3 reflectPos = Point(reflectRay, t);\n      vec3 reflectNormal = ObjectNormal(reflectPos);\n      \n      // Calcul de l'éclairage pour la surface réfléchie\n      vec3 ambientReflect = reflectMat.ambient * reflectMat.color;\n      vec3 diffuseReflect = reflectMat.diffuse * clamp(dot(reflectNormal, l), 0.0, 1.0) * reflectMat.color;\n      vec3 specularReflect = reflectMat.specular * pow(clamp(dot(reflectDir, l), 0.0, 1.0), 35.0) * vec3(1.0);\n      \n      reflectColor = ambientReflect + shadow * (diffuseReflect + specularReflect);\n    }\n\n    // Mélange la couleur de l'objet avec la couleur réfléchie\n    finalColor = mix(finalColor, reflectColor, mat.reflective);\n  }\n\n  return finalColor;\n}\n\n// Ombre basée sur le nombre d'étapes dans le raymarching\n// n : Nombre d'étapes\n// m : Nombre total d'étapes\nvec3 ShadeSteps(int n, int m)\n{\n  float t = float(n) / float(m);\n  return 0.5 + mix(vec3(.05, .05, .5), vec3(.65, .39, .65), t);  // Interpolation entre deux couleurs en fonction du nombre d'étapes\n}\n\n// Image finale\nvoid mainImage(out vec4 color, in vec2 pxy)\n{  \n  // Conversion des coordonnées de pixels en coordonnées de texture\n  vec2 pixel = (-iResolution.xy + 2.0 * pxy) / iResolution.y;\n\n  // Obtenir les coordonnées de la souris\n  vec2 m = iMouse.xy / iResolution.xy;\n\n  // Création du rayon depuis la caméra\n  Ray ray = CreateRay(m, pixel);\n\n  // Initialisation des variables de raymarching\n  float t = 0.0;\n  int s = 0;\n  int c;\n  Material mat;\n  \n  // Traçage du rayon\n  bool hit = SphereTrace(ray, 1000.0, t, s, c, mat);\n\n  // Ombre de fond\n  vec3 rgb = background(ray);\n  \n  if (hit)\n  {\n    // Position d'intersection et calcul de la normale\n    vec3 p = Point(ray, t);\n    vec3 n = ObjectNormal(p);\n\n    // Calcul de l'éclairage sur l'objet\n    rgb = Shade(p, n, ray, mat);\n  }\n  \n  // Décommenter cette ligne pour afficher la couleur selon le nombre d'étapes\n  //rgb = ShadeSteps(s, Steps);\n\n  // Décommenter cette ligne pour afficher le coût du raymarching\n  //rgb = ShadeSteps(c, 25000);\n\n  color = vec4(rgb, 1.0);  // Finalisation de la couleur du pixel\n}\n","name":"Image","description":"","type":"image"}]}