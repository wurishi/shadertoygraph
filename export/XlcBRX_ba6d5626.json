{"ver":"0.1","info":{"id":"XlcBRX","date":"1540372321","viewed":17153,"name":"Triangulated Heightfield Trick","username":"fizzer","description":"Here is a trick to raytrace a triangulated heightfield taking only 1 sample of the heightfield for each triangle tested against the ray and reducing the ray-vs-triangle test to a ray-vs-plane test. Primary rays and shadow rays are both raytraced.","likes":145,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","heightfield","polygonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Rays traverse a uniform grid and are tested against a triangle (actually this is just\n// a ray-versus-plane test). Rather than sampling the heightfield 3 times to get the triangle\n// vertices, previous vertices are kept and only one of the vertices is updated at each step.\n// So the heightfield is only sampled once per step.\n//\n// The algorithm is similar to triangle strip rasterisation, in that each new vertex\n// together with previous 2 vertices define a triangle.\n//\n\n//\n// The shaders of this series:\n//\n//   Triangulated Heightfield Trick 1 - https://www.shadertoy.com/view/XlcBRX (Rigid, right-triangle)\n//   Triangulated Heightfield Trick 2 - https://www.shadertoy.com/view/tlXSzB (Rigid, equilateral)\n//   Triangulated Heightfield Trick 3 - https://www.shadertoy.com/view/ttsSzX (Deforming, equilateral)\n//   Tetrahedral Voxel Traversal      - https://www.shadertoy.com/view/wtfXWB (Rigid, tetrahedron)\n//\n\n\n// Use this to toggle between taking 1 sample of the heightfield and taking\n// 3 samples (to fully construct the triangle on every step).\n#define SINGLE_SAMPLE 1\n\nfloat minh = 0.0, maxh = 6.0;\nvec3 nn = vec3(0);\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat noise(vec3 p)\n{\n    return hash(p.x + p.y*57.0 + p.z*117.0);\n}\n\nfloat valnoise(vec3 p)\n{\n    vec3 c = floor(p);\n    vec3 f = smoothstep(0., 1., fract(p));\n    return mix(\n        mix (mix(noise(c + vec3(0, 0, 0)), noise(c + vec3(1, 0, 0)), f.x),\n             mix(noise(c + vec3(0, 1, 0)), noise(c + vec3(1, 1, 0)), f.x), f.y),\n        mix (mix(noise(c + vec3(0, 0, 1)), noise(c + vec3(1, 0, 1)), f.x),\n             mix(noise(c + vec3(0, 1, 1)), noise(c + vec3(1, 1, 1)), f.x), f.y),\n        f.z);\n}\n\nfloat fbm(vec3 p)\n{\n    float f = 0.;\n    for(int i = 0; i < 5; ++i)\n        f += (valnoise(p * exp2(float(i))) - .5) / exp2(float(i));\n    return f;\n}\n\nfloat height(vec2 p)\n{\n    float h = mix(minh, maxh * 1.3, pow(clamp(.2 + .8 * fbm(vec3(p / 6., 0.)), 0., 1.), 1.3));\n    h += valnoise(vec3(p, .3));\n    return h;\n}\n\n// The raytracing function\nvec3 tr2(vec3 o,vec3 r)\n{\n    // Start ray at upper Y bounds\n    if(o.y > maxh)\n        o += r * (maxh - o.y) / r.y;\n    \n    vec2 oc = vec2(floor(o.x), floor(o.z)), c;\n    vec2 dn = normalize(vec2(-1, 1));\n    vec3 ta, tb, tc;\n\n    // Initialise the triangle vertices\n    ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\n    tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\n    if(fract(o.z) < fract(o.x))\n        tb = vec3(oc.x + 1., height(oc + vec2(1, 0)), oc.y + 0.);\n    else\n        tb = vec3(oc.x, height(oc + vec2(0, 1)), oc.y + 1.);\n\n    float t0 = 1e-4, t1;\n\n    // Ray slopes\n    vec2 dd = vec2(1) / r.xz;\n    float dnt = 1.0 / dot(r.xz, dn);\n    \n    float s = max(sign(dnt), 0.);\n    c = ((oc + max(sign(r.xz), 0.)) - o.xz) * dd;\n\n    vec3 rs = sign(r);\n\n    for(int i = 0; i < 450; ++i)\n    {  \n        t1 = min(c.x, c.y);\n\n        // Test ray against diagonal plane\n        float dt = dot(oc - o.xz, dn) * dnt;\n        if(dt > t0 && dt < t1)\n            t1 = dt;\n \n#if !SINGLE_SAMPLE\n        // Sample the heightfield for all three vertices.\n        vec2 of = (dot(o.xz + r.xz * (t0 + t1) * .5 - oc, dn) > 0.) ? vec2(0, 1) : vec2(1, 0);\n        tb = vec3(oc.x + of.x, height(oc + of), oc.y + of.y);\n        ta = vec3(oc.x, height(oc + vec2(0, 0)), oc.y);\n        tc = vec3(oc.x + 1., height(oc + vec2(1, 1)), oc.y + 1.);\n#endif        \n\n        // Test ray against triangle plane\n        vec3 hn = cross(ta - tb, tc - tb);\n        float hh = dot(ta - o, hn) / dot(r, hn);\n\n        if(hh > t0 && hh < t1)\n        {\n            // Intersection with triangle has been found\n            nn = hn;\n            return o + r * hh;\n        }\n\n#if SINGLE_SAMPLE\n        vec2 offset;\n        \n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\n        // and 0.0 for the far one\n        vec2 ss = step(c, c.yx);\n\n        // Get the coordinate offset of where to read the next vertex height from\n        if(dt >= t0 && dt < c.x && dt < c.y)\n        {\n            offset = vec2(1. - s, s);\n        }\n        else\n        {\n            offset = dot(r.xz, ss) > 0. ? vec2(2, 1) : vec2(-1, 0);\n\n            if(c.y < c.x)\n                offset = offset.yx;\n        }\n\n        // Get the next vertex\n        vec3 tnew = vec3(oc + offset, height(oc + offset)).xzy;\n\n        // Update the triangle vertices.\n        if(dt >= t0 && dt < c.x && dt < c.y)\n        {\n            tb = tnew;\n        }\n        else\n        {\n            // Swap vertex order based on sign of ray axis\n            if(dot(r.xz, ss) > 0.)\n            {\n                ta = tb;\n                tb = tc;\n                tc = tnew;\n            }\n            else\n            {\n                tc = tb;\n                tb = ta;\n                ta = tnew;\n            }\n\n            // Step the grid coordinates along to the next cell\n            oc.xy += rs.xz * ss;\n            c.xy += dd.xy * rs.xz * ss;\n        }\n#else\n        // Get an \"axis selector\", which has 1.0 for the near (intersected) axis\n        // and 0.0 for the far one\n        vec2 ss = step(c, c.yx);\n        \n        if(dt < t0 || dt >= c.x || dt >= c.y)\n        {\n            // Step the grid coordinates along to the next cell\n            oc.xy += rs.xz * ss;\n            c.xy += dd.xy * rs.xz * ss;\n        }\n        \n#endif\n        t0 = t1;\n\n        // Test if the ray left the upper Y bounds\n        if(((maxh - o.y) / r.y < t0 && r.y > 0.) || t0 > 200.)\n            return vec3(10000);\n\n    }\n    return vec3(10000);\n}\n\n// Ray direction function\nvec3 rfunc(vec2 uv)\n{\n    vec3 r = normalize(vec3(uv.xy, -1.3));\n    float ang = .7;\n    r.yz *= mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    return r;\n}\n\nfloat chequer(vec2 p)\n{\n    return step(0.5, fract(p.x + step(0.5, fract(p.y)) * 0.5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 t = uv * 2. - 1. + 1e-3;\n    t.x *= iResolution.x / iResolution.y;\n\n    // Setup primary ray\n    vec3 o = vec3(1.4, 9.5, -iTime), r = rfunc(t);\n\n    // Trace primary ray\n    vec3 rp = tr2(o, r);\n\n    // Surface normal\n    vec3 n = normalize(nn);\n    if(n.y < 0.)\n        n =- n;\n\n    // Checkerboard pattern\n    vec3 col = vec3(mix(.8, 1., chequer(rp.xz / 2.)));\n\n    if(fract(rp.z) < fract(rp.x))\n\t\tcol *= .7;\n    \n    // Light direction\n    vec3 ld = normalize(vec3(1.5, 1, -2));\n\n    // Directional shadow (raytraced)\n    vec3 rp2 = tr2(rp + n*1e-4 + ld * 1e-4, ld);\n    if(distance(rp, rp2) < 1000.)\n        col *= .4 * vec3(.65, .65, 1);\n\n    // Basic colouration\n    col *= mix(vec3(1, .8, .5) / 2., vec3(.3, 1, .3) / 4., 1. - clamp(rp.y / 2., 0., 1.));\n    col = mix(col, vec3(1) * .7, pow(clamp((rp.y - 2.5) / 2., 0., 1.), 2.));\n\n    // Directional light falloff\n    col *= pow(.5 + .5 * dot(n, ld), 1.);\n    \n    // Fog\n    col = mix(vec3(.65, .65, 1), col, exp2(-distance(rp, o) / 1024.));\n\n    // Clamp and gamma-correct\n    fragColor.rgb = pow(clamp(col * 2., 0., 1.), vec3(1. / 2.2));\n}\n\n\n","name":"Image","description":"","type":"image"}]}