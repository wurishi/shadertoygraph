{"ver":"0.1","info":{"id":"X3SyD1","date":"1727185550","viewed":53,"name":"Mecha Forest","username":"shadertoyjiang","description":"mouse \n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["mouse","tree","keyboard","brunch"],"hasliked":0,"parentid":"XXjyzm","parentname":"Array disk disorder jump"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 20240923\n// When the mouse is on the right, the small bead appears.\n// There is an error in the shadow and I haven't found the cause of the problem yet\n\n#define MUL 5.       // MUL >= 0\n#define Shadow 1     // 0 or 1\n//#define ind ((0.-(iy-1.)*M*2.)/(1.-M*2.)+ix+1.)\n#define time (iTime*2.)\n#define TAU 6.2831853\n#define rot(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n#define PI 3.1415926\n//#define iTime 50.4\n\nvec3 dir;\nvec4 clr;\nint obj;\nfloat dist,bord;\n\n\nfloat smin(float d1, float d2, float k)\n{\n        float h =clamp(.5 + .5 *(d2-d1)/k,0.,1.);\n        return mix(d2, d1, h)-k*h*(1.-h);\n}\n\n\nfloat intersect(vec2 o, float r,vec2 dir){\n        vec2 c=vec2(0);\n        vec2 l = c - o;\n        float s = dot(l,dir); // dir.xz\n        float l2 = dot(l,l), r2=r*r;\n        if(s<0. && l2>r2)return -1.;\n        float m2 = l2 - s*s;\n        if(m2>r2)return -1.;\n        float q = sqrt(r2-m2),t;\n        if(l2>r2)t=s-q;\n        else     t=s+q;\n        return t;\n}\n\n//float rnd0(float seed){\n//        return fract(sin(seed*234.567+13.222)*143.219)-.5;\n//}\n\nvec4 rnd4(float p)\n{//  https://www.shadertoy.com/view/4djSRW - Dave_Hoskins\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\nfloat rnd1(float p){\n        return rnd4(p+1.2345).y;\n}\n\nfloat tree(vec3 p, float ind){\n    float sz=.86+ .8*rnd1(ind+.2);\n    p*=sz;\n        float s =1., mn = 999., g=.62+.04*rnd1(ind+.4), mk=mn,\n              r,h,d,sn;\n        \n        vec3 n = vec3(0,1,0);\n        n.xy = n.xy * rot(-(PI/2.-.5)+rnd1(ind+.56)*6.);\n        //n.xy = n.yx*vec2(-1,1); //n=normalize(n);\n        //n=-n;\n        \n        for(int i=0;i<8;i++){\n                r = length(p.xz)-.05;\n                h = abs(p.y-.6)-.6;\n            if(i==7)h = abs(p.y-2.6)-2.6;\n                d = max(r,h);\n                mn = smin(mn, d * s, .01);//, .03);\n                mk = min(mk, dot(p,n)*s);\n                mk = min(mk, dot(p,n*vec3(-1,1,1))*s);\n                mk=min(mk,mn);\n                p.y -= 1.;\n                sn = sign(p.x);\n            // \n            //if(rnd1(ind+3.3+float(i))<.2)p.y+=.5,p=p/.985,s=s*.985;               \n            if(rnd1(ind+3.3)<.1)p.y+=.5,p=p/.985,s=s*.985;\n                p.x = abs(p.x);\n                p.xy = p.xy*rot(-.5);//+-\n                p.xz = p.xz*rot(-4.8*sn);//iMouse.y/iResolution.y*6.28*sn);\n                p = p / g;\n                s = s * g;\n        }\n        return mn/sz;\n}\n\n\n\n\nfloat keyboard(vec3 p){   \n        float size=1. ;//\n        p*=size;\n        vec2 u = p.xz;\n        const float N=1.;\n        float M =float(MUL),\n              au =  atan(u.y, u.x)/TAU , \n              ru = length(u)*N,   \n              iy = round(ru),   \n              ofs = (rnd1(iy+5.)-.5)*time*3.,  \n              ix = round(au * iy*M + ofs);\n        \n        if( ix == round(-.5 * iy*M + ofs) )ix==round(.5 * iy*M + ofs); \n        \n\n        float a = (ix -ofs)/M/iy*TAU;\n        vec2 ni = vec2(-sin(a), cos(a));\n        //if(iy>.1)ix=mod(ix+iy*4.,iy*2.);\n        //if(iy<.2)ix=0.;\n        \n        \n        float ind=0.;\n        if(iy>0.5)ind+=iy*(iy-1.)/2.*M+mod(ix+iy*M,iy*M)+1.;\n        \n        \n        \n        \n        \n        //float nvg = step(0., dot(ni, dir.xz))*2.-1.;\n        float agl = .5/M/iy*TAU;\n        \n        \n        \n        bord = 1e8;dist = 1e8;\n        // 还是笨办法保险，知道还耗71149\n        vec2 nrt = rot(-agl)*ni;\n        float t = - dot(u, nrt) *length(dir)/dot(dir, vec3(nrt, 0).xzy);\n        if(t>0.)bord = min(bord, t); //=?\n        nrt  = rot(agl)*ni;\n        t = - dot(u, nrt) *length(dir)/dot(dir, vec3(nrt, 0).xzy);\n        if(t>0.)bord = min(bord, t); //=?\n        \n        \n        \n        // 求解与内外圆弧边界的距离 bord\n        float k = length(dir.xz);\n        k = length(dir)/k;//(k*k);\n        vec2 nmz = normalize(dir.xz);\n        t = intersect(u, (iy + .5)/N, nmz)*k;  \n        if(t>0.)bord = min(bord, t);        \n        t = intersect(u, (iy - .5)/N, nmz)*k;  \n        if(t>0.)bord = min(bord, t);\n        bord = min(bord, 555.5) + .01*size;   // c>l\n        \n        // 求解各真实物面距离 dist\n        float d1,d2,d3,d4,d5,d6,w = .001, r =.1;\n        if(dot(u, ni)<0.)u = reflect(u, ni);\n        d1 = dot(u, nrt)+w+r;\n        d2 = ru - (iy + .5-w-r)/N ;\n        d3 = (iy - .5+w+r)/N - ru ;\n        // \n        float h = rnd1(ind)*clamp(1.5*sin(time*(1.+rnd1(ind+6.))),-1.,1.);\n        d4 = abs(p.y-h)-.6;   // 与配合可产生其它背景     \n        ////float d6 ;//= tree(p-vec2(ni.y,0,-ni.x)*iy-vec3(0,h+1.2,0));\n        clr = vec4(.8,.5,.2,1)*.5+(rnd4(ind+.1)+.02)*1.5;        \n        dist = length(max(vec4(d1,d2,d3,d4),0.))-r;//2117\n        obj=0;\n        if(iMouse.x<iResolution.x*.6 &&\n           mod(ind+18., 16.)<.5){\n              d5 = length(p - vec3(ni.y*iy, abs(-h)+1.6+.45, -ni.x*iy))-.4;       \n              if(d5<dist)obj=1, clr = vec4(2,.5,.2,1)*(rnd4(ind+23.)+.2);                \n              dist=min(dist, d5);\n           }\n           else if(mod(ind+.1,6.)<3.2){\n              d6 = tree(p-vec3(ni.y,0,-ni.x)*iy-vec3(0,h+.6,0), ind);      \n              if(d6<dist && ind>.1){\n                  clr=vec4(1,3,1,1)+rnd1(ind+.4)-.3;\n                  dist=smin(dist,d6,.1);\n              }\n           }\n        //}\n        \n        \n        if(iTime>2.1 && floor(abs(iTime-16.)*2.5) < ind)dist=1e8;\n        \n        \n        return max(min(dist, bord)/size,p.y/size-5.);\n}\n\n// rot dir ?\nfloat map(vec3 p)\n{\n        float t = time; // 2.54\n        \n        //p.yz *=rot(t*.4);\n        //p.xz *=rot(t*.5);\n        //p.xy *=rot(t*.7);\n        return keyboard(p+vec3(0,5,0));\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd  )\n{// https://www.shadertoy.com/view/lsKcDD - iq\n\tfloat res = 1.0;\n    float t = .0001;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    int technique=1;\n    float tmax=5., w=.1;\n    int j=0;\n    for( int i=0; i<32; i++ )\n    {   j++;\n\t\tfloat h = map( ro + rd*t );\n        \n        float dm = max(dist,.001);\n        \n        if( technique==0 )\n        {\n        \tres = min( res, dm/(w*t) );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = dm*dm/(2.0*ph);\n            float d = sqrt(dm*dm-y*y);\n            res = min( res, d/(w*max(0.0,t-y)) );\n            ph = dm;\n        }\n       \n        t += h;//min(max(h,0.001),.5);\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    //if(j>32)return 0.;\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n\nvoid mainImage(out vec4 O, vec2 v)\n{        \n        O = vec4(0.4);\n        clr=vec4(1);\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,       \n             m = 1. * (iMouse.xy*2. - R) / R.y; \n        vec3 o = vec3(0, 0, -9),                \n             r = normalize(vec3(u+vec2(0,-.5), 1.5)),        \n             e = vec3(0, 1e-3, 0),             \n             p,n,                                 \n             s = normalize(vec3(-1,2,-3));      \n        dir=r;\n        float yy=abs( keyboard(vec3(u.x,0,u.y-.0)*5.));\n        //if(yy>=.02)yy*=9.;\n        O += exp(-80.*yy); // backcolor\n        if(r.y>0.0)return;\n        float d,t,f,g,c ;\n        for(int i;i<256 && t < 25.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        n = normalize(vec3(map(p+e.yxx),map(p+e),map(p+e.xxy))-d);\n                        \n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; \n                        \n                        if(obj==1)O = vec4(c)*clr;\n                        else      O = vec4(c*g)*clr; // 亲\n                        \n                        #if Shadow==1\n                        //vec4 cclr=clr;int cobj=obj;\n                        vec3 rf;//=reflect(r,n);\n                        rf=normalize(s*100.-p);\n                        dir=rf;\n                        float shd=calcSoftshadow(p-r*.02,rf);\n                        //clr=cclr;obj=cobj;\n                        \n                        \n                        if(iMouse.x<iResolution.x*1.6 )   O   *= shd+.05;\n                        #endif\n                        return;\n                }\n                t += d  ;\n        }\n}\n \n\n\n\n\n/*\n        // 求解各真实物面距离 dist\n        float d1,d2,d3,d4, dist = 1e8, w = .1, r =.1;\n        if(dot(u, ni)<0.)u = reflect(u, ni);\n        d1 = dot(u, abn)+w+r;\n        d2 = ru - (iy + .5-w-r)/N ;\n        d3 = (iy - .5+w+r)/N - ru ;\n        d4 = abs(p.y-2.*rnd(iy+ix)*clamp(8.*sin(time*(1.+rnd(iy+ix+6.))),0.,1.))-1.6;        \n        clr = vec4(rnd(iy+ix+3.),rnd(iy+ix+2.),rnd(iy+ix+1.),1)+.7;        \n        dist = length(max(vec4(d1,d2,d3,d4),0.))-r;//2117\n        return min(dist, bord);\n}\n\n\nfloat map(vec3 p)\n{\n        float t = iTime;\n        \n        //p.yz *=rot(t*.4);\n        //p.xz *=rot(t*.5);\n        //p.xy *=rot(t*.7);\n        return keyboard(p+vec3(0,5,0));\n}\n\nvoid mainImage(out vec4 O, vec2 v)\n{        \n        O = vec4(0.4);\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,       \n             m = 1. * (iMouse.xy*2. - R) / R.y; \n        vec3 o = vec3(0, 0, -9),                \n             r = normalize(vec3(u+vec2(0,-.5), 2)),        \n             e = vec3(0, 1e-3, 0),             \n             p,n,                                 \n             s = normalize(vec3(-1,2,-3));      \n        dir = r;\n        O += exp(-80.*abs( keyboard(vec3(u.x,0,u.y)*5.) )); // backcolor\n        \n        float d,t,f,g,c ;\n        for(int i;i<256 && t < 25.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        n = normalize(vec3(map(p+e.yxx),map(p+e),map(p+e.xxy))-d);\n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; \n                        O = vec4(c*g)*clr; // 亲\n                        return;\n                }\n                t += d  ;\n        }\n}\n\n\n\n\n//////////////////\n\n\n/*\n// 1929 20240923\n#define time iTime\n#define TAU 6.2831853\n#define rot(t) mat2(cos(t),sin(t),-sin(t),cos(t))\nvec3 dir;\nvec4 clr;\n\nfloat intersect(vec2 o, float r,vec2 dir){\n        vec2 c=vec2(0);\n        vec2 l = c - o;\n        float s = dot(l,dir); // dir.xz\n        float l2 = dot(l,l), r2=r*r;\n        if(s<0. && l2>r2)return -1.;\n        float m2 = l2 - s*s;\n        if(m2>r2)return -1.;\n        float q = sqrt(r2-m2),t;\n        if(l2>r2)t=s-q;\n        else     t=s+q;\n        return t;\n}\n\nfloat rnd(float seed){\n    //return 0.;\n        return //fract(65.321*sin(123.456*\n        fract(sin(seed*234.567+13.322)*143.219)-.5;//))-.5;\n}\n\n\nfloat keyboard(vec3 p){//return length(p)-5.;\n        vec2 u = p.xz;\n        const float N=1.;\n        float M = 3.;\n        float au = atan(u.y, u.x)/TAU; // 角\n        float ru = length(u)*N;  // 长度\n        float iy = round(ru);   // 取整\n        float ofs = rnd(iy)*time; // 错位\n        float ix = round(au * iy*M + ofs);\n        \n        if((ix == round(-.5 * iy*M + ofs)) )ix = round(.5 * iy*M + ofs);\n        if(iy==0.)ix = 0.;// round(au * iy *M+ ofs);\n        \n        //ix = float((int(ix)+int(iy)/2-1)%int(iy)-int(iy)/2+1);\n        //return length(vec3(au-ix,p.y,ru-iy))-.3;\n        \n        \n        // 求解行进到直线边界的距离 t\n        //vec2 ni = vec2(-iy,ix); // 体素中心处正向旋转向量\n        float a=(ix -ofs)/M/iy*TAU;\n        vec2 ni =vec2(-sin(a),cos(a));\n        if(iy>0.5)ix=mod(ix,iy);\n       // \n        //ix = round(au * iy*M );\n        \n        \n    // float iAgl = step(0., dot(ni, dir.xz))-.5; // 同向正转 0.5 格，反向负 0.5 格\n        //float Agl = (ix +iAgl-ofs)/M/iy*TAU;       // 边界所在角度\n        //vec2 nrt = vec2(-sin(Agl),cos(Agl));       // 边界的法向量\n        float fu=step(0.,  dot( vec3(ni,0).xzy, dir) )*2.-1.;//xxxxx\n        float Agl=(  .5   )/M/iy*TAU;\n        vec2 nrt=rot(Agl*fu)*ni;\n        \n        vec2 nnrr=rot(Agl)*ni;\n        \n        float dbox = 1e8;\n     float t =  -dot(u, nrt) *length(dir)/dot(dir, vec3(nrt.x,0,nrt.y));\n        if(t>=0.)dbox = min(dbox, t);\n        // 求解与内外圆弧边界的距离 t\n     \n     \n     \n     float xi=length(dir.xz);\n     vec2 nm=normalize(dir.xz);\n     \n     t = intersect(u, (iy + .5)/N, nm)/xi; t *= length(dir)/length(dir.xz)  ;\n        if(t>=0.)dbox = min(dbox, t);        \n     t = intersect(u, (iy - .5)/N, nm)/xi; t *= length(dir)/length(dir.xz)  ;\n        if(t>=0.)dbox = min(dbox, t);\n        dbox = min(dbox,.5)+.05 + .0; // 不画边界。\n        \n        \n        //return dbox;\n        \n        \n        // 求解各真实物面距离 \n        float d1,d2,d3,d4, dist = 1e8, w = .1, r =.1;\n        if(dot(u, ni)<0.)u = reflect(u, ni);\n        d1 = dot(u, nnrr)+w+r;\n        // \n        d2 = ru - (iy + .5-w-r)/N ;\n        d3 = (iy - .5+w+r)/N - ru ;\n        d4 = abs(p.y-rnd((iy)+(ix))*1.)-1.6;\n        vec4 ss=max(vec4(d1,d2,d3,d4),0.);\n        dist=length(ss)-r;\n        //dist = max(max(d1,d2), max(d3,d4))-r;\n        \n        \n        clr=vec4(  rnd(iy+ix+1.),  rnd(iy+ix+2.),  rnd(iy+ix+3.),1  )+.7;\n        \n        \n        return min(dist, dbox);\n}\n\nfloat map(vec3 p)\n{\n        float t = iTime;\n        \n        //p.yz *=rot(t*.4);\n        //p.xz *=rot(t*.5);\n        //p.xy *=rot(t*.7);\n        return keyboard(p+vec3(0,5,0));\n}\n\nvoid mainImage(out vec4 O, vec2 v)\n{\n        \n        O = vec4(0.4);\n        vec2 R = iResolution.xy,\n             u = 1. * (v+v+.1 - R) / R.y,      // 实际坐标\n             m = 1. * (iMouse.xy*2. - R) / R.y;// 实际鼠标\n        \n        \n        vec3 pp=vec3(u.x,0, u.y)*5.;\n        float dd=keyboard(pp);\n        O+=exp(-80.*abs(dd));\n        \n        \n       // return;\n        \n        \n        vec3 o = vec3(0, 0, -9),               // 眼睛坐标\n             r = normalize(vec3(u+vec2(0,-.7), 2)),        // 射线\n             e = vec3(0, 1e-3, 0),             // 微距\n             p,n,                                // 法向量\n             s = normalize(vec3(-1,2,-3));     // 太阳\n        dir = r;\n        float d,t,f,g,c,xi=1.;\n        //ctxt=false;\n        for(int i;i<256 && t < 25.;i++)\n        {\n                p = o + r * t;\n                d = map(p);\n                if(d<.01)\n                {\n                        O *= 0.;\n                        //ctxt=true;\n                        float a = map(p+e);\n                        //ctxt=false;\n                        n = normalize(vec3(map(p+e.yxx),a,map(p+e.xxy))-d);\n                        f = .5 + .5 * dot(n, s);\n                        g = max(dot(n,s),0.);\n                        c = 1. + pow(f, 200.)-f*.3; // 665.352.6.542.9958.8.63\n                        O += c*xi;\n                        O = vec4(c*g)*clr; return;\n                        //xi *=.3;\n                        //d =.2;\n                }\n                t += d ;\n        }\n        //O *= .5;\n}\n\n\n*/\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}