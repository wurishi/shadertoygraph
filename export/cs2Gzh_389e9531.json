{"ver":"0.1","info":{"id":"cs2Gzh","date":"1667304252","viewed":156,"name":"Creamy land","username":"kastorp","description":".","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["noise","landscape","extrusions"],"hasliked":0,"parentid":"flK3DD","parentname":"canyons?"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Creamy Land by kastorp\n\n//  Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tp = fract(p);\n\tp = p * p * (3. - 2. * p);\n\tvec4 h = vec4(0, s.yz, (s.y+s.z)) + dot(ip, s);\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat map2d(int i,float ns,float ds){         \n    return (ns-.5 -float(i)/12.)*ds;\n}\n\nfloat map (vec3 ps){\n    float bottom=0., sz=.3;\n    int N =6;\n    vec2 p=vec2(ps.y,0);\n    float  d=1e5, sg=1.;\n    float   ds=1.5,\n           ns= n31(vec3(ps.xz*1./ds,1.));\n             //texture(iChannel0,ps.xz*.1).x;\n    float  yn=map2d(N,ns,ds);\n    for(int i=0;i<N;i++){   \n        float y0=map2d(i,ns,ds),\n              y1=map2d(i+1,ns,ds);\n        float  a= 0.,\n               c=y0,\n               b=(y1-y0)/sz,\n               shift=float(i)*sz;\n        //K<0 inflate, k>0 deflate\n        float k=-.12 ; a+= k/sz/sz; b-= k/sz ;\n        \n\n        vec2 pp=p-vec2(shift+bottom,0);\n        if(pp.x>0. && pp.x<sz && pp.y<c+pp.x*b+pp.x*pp.x*a) sg=-1.; //sign\n                    \n        float xx=clamp(p.x-shift-bottom,0.,sz),\n              yy=c+xx*b +xx*xx*a;            \n        d = min(d, length(p-vec2(xx+shift+bottom,yy)));       \n    }\n     float top=bottom+float(N)*sz;\n    d=min(d, length(p- vec2(top,yn) +vec2(0,1)*  clamp(vec2(top,yn)-p.y  , 0., 1e6)));\n\n    d*=sg;\n    d=min(d,ps.y);\n    return d;\n}\n\n\n\n//-------------------------\n\n//Iq\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .001 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\treturn normalize(n);\n}\n\n\n//Iq\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0,1., 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\n//Iq\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat s = 1., t = .003;\n\tfor (float i = 0.; i < 40.; i++)\n\t{\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 25. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\treturn clamp(s, 0., 1.);\n}\n\nvec3 lights(vec3 p, vec3 rd, float d) {\n    vec3 lightDir = normalize( vec3(6.,19.,18.) );\n\tvec3 ld = lightDir*6.5, n = calcN(p, d) ;\n\n\tfloat ao = 1.,\n\tl1 = .8 + .2 * dot(ld, n),\n\tspe = max(0., dot(rd, reflect(ld, n))) * .2,\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n\tl1 *= .3+ .7* calcShadow(p+.001*n, ld);\n\tvec3 lig = clamp(l1 * ao + spe,0.,5.) * vec3(4.) ;\n\treturn mix(.3, .4, fre) * lig;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\tvec3 p;\n\tfloat d = .01;\n\tfor (float i = 0.; i < 100.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .001  )break;\n        if(d >30.) return vec3(.4,.9,.9);\n\t\td += h;\n\t} \n    vec3 col= p.y<.01?vec3(0.85,0.45,0.01):vec3(.5,.0,0)+.2* cos(vec3(0,2,4)-1.-floor(p.y/.3));\n\treturn mix(vec3(.4,.9,.9), col*lights(p, rd, d),exp(-d*d * .002));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\t\n    float t=-iTime*1.5;\n\tvec3 ro = vec3(t,2.5 +4.*iMouse.y/iResolution.y, -2.+4.*iMouse.x/iResolution.x);\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, vec3(t-3.,1.,0), uv)), vec3(.4)), fc), 0);\n}\n","name":"Image","description":"","type":"image"}]}