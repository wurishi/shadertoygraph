{"ver":"0.1","info":{"id":"NddcRM","date":"1653190753","viewed":80,"name":"Haru86_Ray_220522-01","username":"Haru86_","description":"Haru86_Ray_220522","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n#define time iTime\n#define resolution iResolution\n\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define PI 3.14159265\n\nstruct DBuffer{\n  float d1;\n  float d2;\n  float d3;\n  float mainD;\n};\n\nvec2 fmod(vec2 p,float r){\n  float a=atan(p.x,p.y)+PI/r;\n  float n=(2.*PI)/r;\n  a=floor(a/n)*n;\n  return rot(a)*p;\n}\n\nfloat sm(float d1,float d2,float k){\n  float h=exp(-k*d1)+exp(-k*d2);\n  return -log(h)/k;\n}\n\nfloat Cube(vec3 p,vec3 s){\n  return length(max(abs(p)-s,0.0));\n}\n\nvec2 random2(vec2 seeds)\n{\n seeds = vec2(dot(seeds, vec2(127.1, 311.7)),\n dot(seeds, vec2(269.5, 183.3)));\n return fract(sin(seeds) * 43758.5453123);\n}\n\nfloat perlinNoise(vec2 seeds)\n{\nvec2 i = floor(seeds);\nvec2 f = fract(seeds);\nvec2 i00 = i + vec2(0, 0);\nvec2 i10 = i + vec2(1, 0);\nvec2 i01 = i + vec2(0, 1);\nvec2 i11 = i + vec2(1, 1);\nvec2 f00 = f - vec2(0, 0);\nvec2 f10 = f - vec2(1, 0);\nvec2 f01 = f - vec2(0, 1);\nvec2 f11 = f - vec2(1, 1);\nvec2 g00 = normalize(-1.0 + 2.0 * random2(i00));\nvec2 g10 = normalize(-1.0 + 2.0 * random2(i10));\nvec2 g01 = normalize(-1.0 + 2.0* random2(i01));\nvec2 g11 = normalize(-1.0 + 2.0* random2(i11));\nfloat v00 = dot(g00, f00);\nfloat v10 = dot(g10, f10);\nfloat v01 = dot(g01, f01);\nfloat v11 = dot(g11, f11);\nvec2 p = smoothstep(0.0, 1.0, f);\nfloat v00v10 = mix(v00, v10, p.x);\nfloat v01v11 = mix(v01, v11, p.x);\nreturn mix(v00v10, v01v11, p.y) * 0.5 + 0.5;\n}\n\nfloat Plane(vec3 p){\n//p.z-=time;\np.y+=perlinNoise(p.xz)*1.5+perlinNoise(p.zx*3.)*.5+perlinNoise(p.zx*12.)*.2;\n  return p.y;\n}\n\n#define foldingLimit 1.0\nvec3 boxFold(vec3 z, float dz) {\n    return clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\nvoid sphereFold(inout vec3 z, inout float dz, float minRadius, float fixedRadius) {\n    float m2 = minRadius * minRadius;\n    float f2 = fixedRadius * fixedRadius;\n    float r2 = dot(z, z);\n    if (r2 < m2) {\n        float temp = (f2 / m2);\n        z *= temp;\n        dz *= temp;\n    } else if (r2 < f2) {\n        float temp = (f2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\n// ref: http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\n#define ITERATIONS 12\nfloat deMandelbox(vec3 p, float scale, float minRadius, float fixedRadius) {\n    vec3 z = p;\n    float dr = 1.;\n    for (int i = 0; i < ITERATIONS; i++) {\n        z = boxFold(z, dr);\n        sphereFold(z, dr, minRadius, fixedRadius);\n        z = scale * z + p;\n        dr = dr * abs(scale) + 1.;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\n\nfloat d1(vec3 p){\n  float d=Plane(p);\n  return d;\n}\n\nfloat d2(vec3 p){\n  float tspeed=0.5;\n  float dt=floor(time*tspeed)+pow(fract(time*tspeed),0.75);\n  float val=sin(.15);\n  float d=deMandelbox(p+vec3(0.,-2.5,0.), 2.0, .05+val, 1.+val*0.05);\n  return d;\n}\n\nfloat d1_1(vec3 p){\n  p.xz*=rot(PI/.15);\n  p.yz*=rot(PI/4.0);\n\n  p.z+=0.75;\n\n\n  float scale=.85;\n\n//  p=abs(p)-.1;\n  for(int i=0;i<3;i++){\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.y<p.z)p.yz=p.yz;\n    if(p.x<p.z)p.xz=p.zx;\n    p.yz*=rot(0.75);\n    p.x=abs(p.x)-.12;\n    p.z=abs(p.z)-.12;\n    //p.xy*=rot(0.15);\n  }\np.z=abs(p.z);\n\n\n\nfloat d=Cube(p,vec3(.35,.2,.1));\n  for(int i=0;i<3;i++){\n    p.xy*=rot(0.15);\n    p.xz*=rot(0.01);\n    p.yz*=rot(0.5);\n    p.xy-=0.25;\n    p.xz-=0.25;\n    scale*=.9;\n    d=sm(d,Cube(p,vec3(.35,.2,.1)*scale),6.0);\n  }\n\n  return d;\n}\n\nfloat d3(vec3 p){\n  float scale=0.5;\n\n  float d=length(p)-1.*scale;\n\n//p.x+=1.5;\n  p.xy*=rot(time);\n  p.xz*=rot(time);\n  p.yz*=rot(time);\n  for(int i=0;i<3;i++){\n    p=abs(p)-.3;\n    if(p.x<p.y)p.xy=p.yx;\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n\n    p.xy*=rot(0.5);\n    p.xz*=rot(0.15);\n    p.yz*=rot(0.25);\n}\n\nd=min(d,Cube(p,vec3(.15*scale,.2*scale,.15*scale)));\n\n  return d;\n}\n\nDBuffer map(vec3 p,vec3 ro){\n  DBuffer d;\n  d.d1=d1(p);\n  d.d2=d2(p);\n  //d.d1=2000.0;\n  //d.d2=2000.0;\nfloat radius=-12.;\nfloat speed=-.25;\n  float tval=-0.;\n  \n  d.d3=d3(p+vec3(cos(time*speed)*radius,-1.0,sin(time*speed)*radius));\n  \n  d.mainD=min(min(d.d1,d.d2),d.d3);\n  return d;\n}\n\nvec3 gn(vec3 p,vec3 ro){\n  vec2 e=vec2(0.001,0.);\n  return normalize(\n    vec3(\n      map(p+e.xyy,ro).mainD-map(p-e.xyy,ro).mainD,\n      map(p+e.yxy,ro).mainD-map(p-e.yxy,ro).mainD,\n      map(p+e.yyx,ro).mainD-map(p-e.yyx,ro).mainD\n      )\n    );\n}\n\nvec3 hsv2rgb2(vec3 c, float k) {\n    return smoothstep(0. + k, 1. - k,\n        .5 + .5 * cos((vec3(c.x, c.x, c.x) + vec3(3., 2., 1.) / 3.) * radians(360.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st = (fragCoord.xy*2.0-resolution.xy) / min(resolution.x,resolution.y);\n\n  vec3 col=vec3((st.y+1.0)*0.5*0.25);\n  float radius=15.;\nfloat speed=-.25;\n vec3 ta=vec3(0.);\n\n vec3 ro=vec3(cos(time*speed)*radius,0.0,sin(time*speed)*radius);\n vec3 cDir=normalize(ta-ro);\n vec3 cSide=cross(cDir,vec3(0.,-1.,0.));\n vec3 cUp=cross(cDir,cSide);\n float depth=1.;\n vec3 rd=normalize(vec3(st.x*cSide+st.y*cUp+cDir*depth));\nint ai=0;\n  DBuffer d;\n  float t,acc=0.0;\n  for(int i=0;i<128;i++){\n    d=map(ro+rd*t,ro);\n    ai=i;\n    if(d.d1<0.001||d.d2<0.001||d.d3<0.001||t>1000.0)break;\n    t+=d.mainD;\n    acc+=exp(-1.0*d.mainD);\n  }\n\n  vec3 n=gn(ro+rd*t,ro);\n\n  if(d.d1<0.001){\n    col+=vec3(0.45,0.25,0.16)*acc*0.05;\n  }\n\n  if(d.d2<0.01){\n\n    col+=vec3(0.5,0.25,0.25)*acc*0.025;\n  }\n\n  if(d.d3<0.001){\n    vec3 refro=ro+rd*t;\n    vec3 n=gn(refro,refro);\n    rd=refract(rd,n,1.);\n    ro=refro;\n    t=0.1;\n    float acc2;\n\n    for(int i=0;i<33;i++){\n      d=map(ro+rd*t,refro);\n      if(d.d1<0.001||d.d2<0.001)break;\n      t+=d.mainD;\n      float H = mod(time*0.5, 1.0);\n      acc2+=exp(-3.*d.mainD);\n    }\n\n    vec3 pos=ro+rd*t;\n    float flash=1.0-abs(sin(pos.z*.5+time*4.0));\n    flash+=.1;\n    float H = mod(0.25, 1.5);\n\n    col+=acc*.5*flash*hsv2rgb2(vec3(H,1.0,1.0),2.2);\n  }\n\n  col*=(1.0-length(st)+0.5);\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}