{"ver":"0.1","info":{"id":"4dsyRn","date":"1486709887","viewed":959,"name":"Morphing planet","username":"LukeRissacher","description":"An idea for the title screen of a game I'm working on ([url=http://infinitroid.com]infinitroid.com[/url]). ","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","valuenoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 Rotate(vec2 p, float a) {\n    return p * cos(a) + vec2(-p.y, p.x) * sin(a);\n}\n\n// Value noise. Uses the fact that texture #19's green channel is the red channel displaced by\n// (37, 17). (which I learned via iq's noise func in https://www.shadertoy.com/view/lsyXDK )\nfloat ValueNoise(vec3 pos) {\n    const vec2 Z_OFFSET = vec2(37.0, 17.0) / 256.0;\n    float zi = floor(pos.z);\n    float zf = pos.z - zi;\n    vec2 uv = pos.xy / 256.0 + zi * Z_OFFSET;\n    vec2 val = texture(iChannel0, uv).rg;\n    return mix(val.g, val.r, zf);\n}\n\n// FBM for terrain height & clouds.\nfloat Heightmap(vec3 pos) {\n    float height = 0.0;\n    float scale = 0.5;\n    float total = 0.0;\n    pos *= 1.5;\n    for (int i = 0; i < 6; i++) {\n        height += scale * ValueNoise(pos);\n\t\ttotal += scale;\n        pos += vec3(0.23, 0.77, 0.57);\n        pos *= 2.77;\n        scale /= 2.1;\n        pos.xy = Rotate(pos.xy, 0.6);\n    }\n    return height / total;\n}\n\n// Swizzles orig.rgb to one of 6 permutations based on amount [0..1). Cheap color randomizer.\nvec3 Swizzle(vec3 orig, float amount) {\n    if (amount < 1.0/6.0) {\n        return orig.rgb;\n    }\n    else if (amount < 2.0/6.0) {\n        return orig.rbg;\n    }\n    else if (amount < 3.0/6.0) {\n        return orig.grb;\n    }\n    else if (amount < 4.0/6.0) {\n        return orig.gbr;\n    }\n    else if (amount < 5.0/6.0) {\n        return orig.brg;\n    }\n    else {\n        return orig.bgr;\n    }\n}\n\n// Random 1d lookup for color stuff. \nfloat Rand(float pos) {\n    float i = floor(pos);\n    if (i <= 1.1) {\n        return 0.0;\n    }\n    i += 36.0; // to change initial series\n    vec2 uv = vec2(0.5 + i, 0.5 + floor(i / 256.0)) / 256.0;\n    return texture(iChannel0, uv).r;\n}\n\n// Swizzles 'col' randomly, blends to the next color, and advances seed offset.\nconst float CYCLE_TIME = 12.0;\nfloat g_Offset = 0.0;\nfloat g_OffsetLast = 0.0;\nvoid RandSwizzleBlend(inout vec3 col, float seed, float blend, float advance) {\n    float rand = Rand(seed + 1.0 + g_Offset);\n    float randLast = Rand(seed + g_OffsetLast);\n    col = mix(Swizzle(col, randLast), Swizzle(col, rand), blend);  \n    if (iTime > CYCLE_TIME) {\n        g_Offset += advance;\n    }\n    if (iTime > 2.0 * CYCLE_TIME) {\n        g_OffsetLast += advance;\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Constants\n    const vec3 ICE_COL = vec3(1, 1, 1);\n    const vec3 LIGHT_DIR = normalize(vec3(0.5, 1.0, 1.0));\n    const float HEIGHT_SCALE = 0.09;\n    \n    // Former constants that I'm now fiddling with :)\n    vec3 ATMOS_COL = vec3(0.37, 0.71, 0.95);\n    vec3 WATER_COL = vec3(0.17, 0.32, 0.52) * 0.8;\n    vec3 TROPICS_COL = vec3(0.0, 1.0, 1.0) * 0.75;\n    vec3 FOREST_COL = vec3(0.15,0.58,0.22);\n    vec3 DESERT_COL = vec3(0.8, 0.58, 0.52);\n    \n    // Randomize colors etc.\n    float seed = floor(iTime / CYCLE_TIME);\n    float blend = smoothstep(0.0, 2.5, mod(iTime, CYCLE_TIME));\n    RandSwizzleBlend(ATMOS_COL, seed, blend, 29.0);\n    RandSwizzleBlend(WATER_COL, seed, blend, 0.0);\n    RandSwizzleBlend(TROPICS_COL, seed, blend, 29.0);\n    RandSwizzleBlend(FOREST_COL, seed, blend, 29.0);\n    RandSwizzleBlend(DESERT_COL, seed, blend, 0.0);\n    float phase = fract(iTime / CYCLE_TIME);\n    float WATER_LEVEL = mix(0.4, 0.6, mix(Rand(seed + 5.0), Rand(seed + 6.0), phase));\n    \n    // Map window roughly to -1..1, planet has r=1\n\tvec2 uv = 1.1 * (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // Derive Z pythagorean-ly; if on the sphere...\n    float z2 = 1.0 - uv.x * uv.x - uv.y * uv.y;\n    if (z2 >= 0.0) {\n        \n        // Unit sphere, so pos = normal\n        vec3 pos = vec3(uv, sqrt(z2));\n        vec3 normal = pos;\n        \n        // Terrain height\n        vec3 noiseNormal = pos;\n        float surfaceRot = -0.1 * iTime;\n        noiseNormal.xz = Rotate(noiseNormal.xz, surfaceRot);\n        vec3 noisePos = noiseNormal + vec3(0.0, 0.0, 0.025 * iTime);\n\t\tfloat height = Heightmap(noisePos);\n        \n        // Tropics amount\n        vec3 tropicsCol = mix(WATER_COL, TROPICS_COL, ValueNoise(3.0 * noisePos));\n        \n        // If water...\n        vec3 surfaceColor;\n        float specAmount = 0.1;\n        if (height < WATER_LEVEL) {\n            surfaceColor = mix(WATER_COL, tropicsCol, pow(height / WATER_LEVEL, 16.0));\n            vec3 wavesPos = pos;\n            wavesPos.xz = Rotate(wavesPos.xz, 1.4);            \n            normal = normalize(normal + 0.08 * ValueNoise(256.0 * (wavesPos + 0.04 * vec3(iTime))));\n            specAmount = 0.55;\n        }\n        // Otherwise if land...\n        else {\n            \n            // Find a tangent and binormal basis to use\n            vec3 tangent = cross(noiseNormal, vec3(0, 1, 0));\n\t\t\tvec3 binormal = cross(noiseNormal, tangent);\n            \n            // Get surface normal via finite difference, rotate back into view space\n            const float DX = 0.01;\n            float scaledHeight = height * HEIGHT_SCALE;\n            float tangentWeight = (scaledHeight - HEIGHT_SCALE * Heightmap(noisePos + DX * tangent)) / DX;\n            float binormalWeight = (scaledHeight - HEIGHT_SCALE * Heightmap(noisePos + DX * binormal)) / DX;\n            vec3 landNormal = normalize(\n                noiseNormal +\n                tangent * tangentWeight + \n                binormal * binormalWeight\n            );\n            landNormal.xz = Rotate(landNormal.xz, -surfaceRot);\n            normal = landNormal;\n            \n            // Choose color\n            vec3 landColor = mix(DESERT_COL, FOREST_COL, \n\t\t\t\tclamp(2.0 * ValueNoise(2.0 * noisePos) - 0.8, 0.0, 1.0));\n            landColor = mix(landColor, ICE_COL, smoothstep(0.7, 1.0, abs(pos.y)));\n            float waterBlend = smoothstep(0.0, 0.01, height - WATER_LEVEL);\n            specAmount = 0.55 * (1.0 - waterBlend);\n            landColor = mix(tropicsCol, landColor, waterBlend);\n            surfaceColor = mix(landColor, ICE_COL, \n\t\t\t\tsmoothstep(WATER_LEVEL + 0.1, WATER_LEVEL + 0.2, height));\n        }\n        \n        // Surface lighting\n        float diffuse = 0.05 + clamp(dot(normal, LIGHT_DIR), 0.0, 1.0);\n        vec3 lightViewHalf = normalize(LIGHT_DIR + vec3(0, 0, 1));\n    \tfloat specular = specAmount * pow(clamp(dot(normal, lightViewHalf), 0.0, 1.0), 15.0);\n        fragColor.rgb = diffuse * surfaceColor + vec3(1.0, 0.92, 0.81) * specular;\n\n        // Clouds\n        vec3 cloudPos = vec3(2.0, 6.0, 2.0) * noisePos + 0.07 * iTime;\n        cloudPos.xz = Rotate(cloudPos.xz, 0.007 * iTime);\n        cloudPos.xy = Rotate(cloudPos.xy, 0.3);\n        float cloudMin = mix(0.15, 0.65, mix(Rand(seed + 5.0), Rand(seed + 6.0), phase));\n        float cloudAmt = 0.75 * smoothstep(cloudMin, 0.7, Heightmap(cloudPos));\n        fragColor.rgb = mix(fragColor.rgb, vec3(pow(diffuse, 0.9)), cloudAmt);\n        \n        // Atmosphere, edge antialias\n        vec3 atmosCol = ATMOS_COL * clamp(0.7 * diffuse + 0.05, 0.0, 1.0);\n        fragColor.rgb = mix(fragColor.rgb, 0.6 * atmosCol, smoothstep(0.993, 1.0, length(uv)));\n\t\tfragColor.rgb += pow(1.0 - pos.z, 1.2) * atmosCol;\n    }\n    // If off the sphere...\n    else {\n        \n        // Add atmospheric halo, mild BG gradient\n        vec3 skyCol = vec3(0.15, 0.2, 0.25) * abs(uv.y);\n        vec3 pos = normalize(vec3(uv, 1.0));\n        fragColor.rgb = mix(ATMOS_COL, skyCol, smoothstep(0.95, 1.06, length(uv))) * \n            1.5 * clamp(dot(pos, LIGHT_DIR), 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}