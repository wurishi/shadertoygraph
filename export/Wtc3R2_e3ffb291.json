{"ver":"0.1","info":{"id":"Wtc3R2","date":"1576812594","viewed":206,"name":"[twitch] Train strike","username":"NuSan","description":"Shader coded live on Recondustream twitch (https://www.twitch.tv/recondustream)\nThis twitch channel is a caritative initiative to support the current french strike.\nOriginal shader (Bonzomatic) is here: http://lezanu.fr/LiveCode/Recondustream_Nusan.glsl","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\nShader coded live on Recondustream twitch (https://www.twitch.tv/recondustream)\nThis twitch channel is a caritative initiative to support the current french strike.\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/Recondustream_Nusan.glsl\nThis version is tweaked to better fit to avalaible textures on shadertoy\n*/\n    \nfloat time=0.0;\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define rep(v,s) (fract((v)/s-0.5)-0.5)*s\n\nfloat box(vec2 p, vec2 s) {\n  p=abs(p)-s;\n  return length(max(vec2(0),p)) + min(0.0,max(p.x, p.y));\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return length(max(vec3(0),p)) + min(0.0,max(p.x, max(p.y,p.z)));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p)-r;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\n\nfloat prog=0.0;\nfloat voiture(vec3 p) {\n  \n  vec3 p2=p;\n  vec3 p3=p;\n  \n  float d = box(p, vec3(1.5,2.5,4));\n  \n  p.y += 2.5;\n  d = min(d, max(cyl(p.xy, 1.5), abs(p.z)-4.0));\n  \n  p.y = abs(p.y-1.5)-1.5;\n  d = min(d, box(p, vec3(1.6,0.1,4.1)));\n  \n  p2.x = abs(p.x)-1.6;\n  p2.z = rep(p.z, 1.6);\n  p2.y += 1.4;\n  d = max(d, -box(p2, vec3(0.2,0.7,0.7)));\n  \n  p3.z = abs(p3.z)-4.0;\n  p3.y += 1.0;\n  d = max(d, -box(p3, vec3(0.6,1.2,0.2)));\n  \n  \n  return d;\n}\n\nfloat roues(vec3 p) {\n  \n\n  p.y -= 3.0;\n  p.x = abs(p.x)-1.8;\n  p.z = min(3.0+p.z,max(p.z-3.0,rep(p.z, 1.5)));\n  float d = abs(cyl(p.yz, 0.65))-0.1;\n  d = max(d, abs(p.x)-0.2);\n  \n  p.yz *= rot(time * 4.0);\n  \n  p.y=abs(p.y);\n  p.z=-abs(p.z);\n  p.yz *= rot(0.7);\n  p.y=abs(p.y);\n  p.z=-abs(p.z);\n  p.yz *= rot(0.4);\n  d = min(d, box(p, vec3(0.05,0.05,0.7)));\n\n  \n  return d;\n}\n\nfloat rails(vec3 p) {\n  \n  p.y += 0.2;\n  p.x=abs(p.x)-1.6;\n  float d=box(p.xy, vec2(0.1,0.2));\n  \n  p.z = rep(p.z, 1.5);\n  d=min(d, box(p, vec3(2.0,0.1, 0.3)));\n  \n  return d;\n}\n\nvec3 chemin(vec3 p) {\n  vec3 off=vec3(0);\n  off.x += sin(p.z * 0.04)*10.0;\n  off.x += sin(p.z * 0.023)*22.0;\n  off.y += sin(p.z * 0.03)*10.0;\n  return off;\n}\n\n// distance fonction\nfloat voit = 0.0;\nfloat sol=0.0;\nfloat wat=0.0;\nfloat map(vec3 p) {\n  \n  vec3 p3=p;\n  \n  p += chemin(p);\n  \n  float h = texture(iChannel0, p.xz * 0.001).x;\n  h *= 7.0 * clamp(abs(p.x)/20.0,0.0,1.0);\n  \n  vec3 p2 = p;\n  \n  p.y += 4.2;\n  float tt=time*0.5;\n  float t2 = fract(tt);\n  t2 = smoothstep(0.0,1.0,t2);\n  t2 = smoothstep(0.0,1.0,t2);\n  t2 = pow(t2, 10.0);\n  p.z += (floor(tt) + t2) * 30.0 + time*3.0; \n  prog = p.z;\n  p.z = rep(p.z, 9.5);\n  \n  \n  \n  \n  voit=voiture(p);\n  float d = voit;\n  \n  d=min(d, roues(p));\n  \n  d=min(d, rails(p2));\n  \n  sol=(-p2.y - h + 0.7)*0.7;\n  d=min(d, sol);\n  \n  wat=-p3.y+5.0;\n  d=min(d, wat);\n  \n  return d;\n}\n\nvec3 camera(vec2 uv, vec3 s, vec3 t, float fov) {\n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz, vec3(0,1,0)));\n  vec3 cy=normalize(cross(cx, cz));\n  \n  return normalize(uv.x*cx - uv.y*cy + fov*cz);\n}\n\nvec3 norm(vec3 p) {\n  vec2 off = vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\nfloat shadow(vec3 p, vec3 r) {\n  float shad=1.0;\n  for(int i=0; i<30; ++i) {\n    float d=map(p);\n    shad=min(shad, d*10.0);\n    p+=d*r;\n  }\n  return clamp(shad,0.0,1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  time=mod(iTime,300.0);\n  \n  // camera position\n  vec3 s=vec3(0,0,-30);\n  s.yz *= rot(0.5);\n  s.xz *= rot(0.7+time*0.2);\n  \n  // camera target\n  vec3 t=vec3(0,-7,10);\n  t.xz *= rot(time*0.3);\n  \n  s.z += time * 8.0;\n  t.z += time * 8.0;\n  \n  s -= chemin(s);\n  t -= chemin(t);\n  \n  //float fov = 0.5 + pow(smoothstep(-1.0,1.0,sin(time*10.0)),10.0)*0.2;\n  float fov = 0.7;\n  vec3 r = camera(uv, s, t, fov);\n    \n  vec3 p=s;\n  float at=0.0;\n  float dd=0.0;\n  for(int i=0; i<100; ++i) {\n    float d=map(p) * 0.7;\n    if(d<0.001) {\n      if(wat>0.01) {\n        break;\n      }\n      d = 0.1;\n      r.y = -r.y;\n      r.x += (texture(iChannel0, p.xz*0.008 + time*0.03).x-0.4)*0.5;\n      r=normalize(r);\n    }\n    if(dd>200.0) {\n      break;\n    }\n    \n    p+=r*d;\n    dd+=d;\n    at += 0.1/(0.1+abs(d));\n  }\n    \n  float issol=step(sol,0.01);\n  float isvoit=step(voit,0.01);\n  float iswat=step(wat,0.01);\n  float pp=floor(prog/9.5-0.5);\n  vec3 n=norm(p);\n  \n  float fog = 1.0-clamp(dd/200.0,0.0,1.0);\n  \n  vec3 col=vec3(0);\n    \n  //col += at * 0.03 * vec3(1,0.5,0.3);\n  \n  vec3 l=normalize(-vec3(1,2,3));\n  \n  float shad=shadow(p + n * 0.2, l);\n  \n  float ao = clamp(map(p+n*0.2)/0.2,0.0,1.0) * (clamp(map(p+n*2.0)/2.0,0.0,1.0)*0.5+0.5);\n  \n  vec3 diff=vec3(0.7);\n  diff=mix(diff, vec3(0.5,1.0,0.5), issol);\n  vec3 cc=vec3(1,0.5,0.2);\n  float g=floor(pp);\n  cc.xy *= rot(g);\n  cc.xz *= rot(g*0.7);\n  cc=abs(cc);\n  diff=mix(diff, cc, isvoit);\n  col += max(0.0, dot(n,l)) * diff * shad * ao;\n  \n  vec3 sky = mix(vec3(0.5,0.6,1)*0.8, vec3(1.0,0.5,0.2)*10.0 , pow(max(0.0,dot(l,r)), 3.0));\n  col += (-n.y*0.5+0.5) * diff * 1.2 * ao;\n  \n  col *= fog;\n  \n  col += pow(1.0-fog,3.0) * 1.1 * sky;\n      \n  col *= 1.2-length(uv);\n  \n  col = smoothstep(0.0,1.0,col*1.2);\n  col = pow(col, vec3(0.4545));\n\n  col *= 1.0;\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}