{"ver":"0.1","info":{"id":"Xt3fW2","date":"1541365452","viewed":113,"name":"implicit_surfaces_TP","username":"Brog","description":"A scene representing a house, formed by substracting two cubes, a jellyfish, with a bunch of spheres, segments/lines and a disc.\nThe flowing liquid is done by blending different groups of spheres, slowly waving.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["implicitsurfaces"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Blobs\n// Code original : Eric Galin\n// Modification  : Bryan BONI & Ilyas BIROUK\n\nconst int   Steps \t= 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T\t\t= 0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=50.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R ) {\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R) {\n  return e*falloff(length(p-c),R);\n}\n\n// Distance for a segment\n// p : point\n// a : start of the segment\n// b : end of the segment\nfloat distanceSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 ab = b - a;\n \tvec3 ap = p - a;\n \tvec3 bp = p - b;\n    \n    if(dot(ab, bp) >= 0.0)\n        return length(bp);\n    else if(dot(ab, ap) <= 0.0)\n        return length(ap);\n    else {\n        float len_ap = length(ap);\n        float oa = dot(ab, ap) / length(ab);\n        return sqrt((len_ap * len_ap) - (oa * oa));\n    }\n}\n\n//Segment\n// ab : segment\n// p  : point\n// e  : energy associated to skeleton, intensity\n// R  : segment radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e,float R){\n    return e*falloff(length(distanceSegment(p,a,b)),R); \n}\n//Distance for a cube\n// p : point\n// c : position of the cube\n// power : affect the radius of the cube\n// scale : size of the cube\nfloat distanceCube(vec3 p, vec3 c, float power, float scale) {    \n    vec3 d = vec3(scale, scale, scale);\n    vec3 cp = (p - c) - (scale / 2.0) ;\n    \n   \tvec3 cpT = max(abs(cp) - d,0.0) ;\n    \n    float lcp = pow(pow(cpT.x, power) + pow(cpT.y, power) + pow(cpT.z, power), 1.0 / power) ;\n    \n    return lcp ;\n}\n\n// Cube\n// p : Point\n// c : position of the cube\n// power : affect the radius\n// scale : scale of the cube\n// e : energy associated to skeleton\n// R : large radius\nfloat cube(vec3 p, vec3 c, float power, float scale, float e, float R) { \n    return e * falloff(distanceCube(p, c, power, scale), R); \n}\n\n// Rectangle\n// p : Point\n// c : position of the rectangle\n// power : affect the radius\n// scale : scale of the rectangle\nfloat distanceRectangle(vec3 p, vec3 c, float power, vec3 scale) {     \n    vec3 cp = (p - c) - (scale / 2.0);\n    \n   \tvec3 max_cp = max(abs(cp) - scale, 0.0);\n    \n    float lcp = pow(pow(max_cp.x, power) + pow(max_cp.y, power) + pow(max_cp.z, power), 1.0 / power);\n    \n    return lcp;\n}\n\n// Rectangle\n// p : Point\n// c : position of the rectangle\n// power : affect the radius\n// scale : scale of the rectangle\n// e : energy associated to skeleton\n// R : large radius\nfloat rect(vec3 p, vec3 c, float power, vec3 scale, float e, float R) { \n    return e * falloff(distanceRectangle(p, c, power, scale), R); \n}\n\n// Distance for a Disque (in french)\n// p : Point\n// c : center of the disque \n// r : radius\n// rotationAxis : axe where the rotation is made around the point c\nfloat distanceDisque(vec3 p, vec3 c, float r, vec3 rotationAxis) {\n    vec3 cp = p - c ;\n    \n    vec3 yAxis = normalize(rotationAxis);\n    vec3 zAxis = cross(cp, yAxis);\n    vec3 xAxis = cross(yAxis, zAxis);\n                                 \n    float xAxis_cp = abs(dot(xAxis, cp) / length(xAxis));\n    \n    if(xAxis_cp > r) {\n        vec3 e = normalize(xAxis) * r  + c ;\n        return length(e - p) ;   \n    }\n    else {\n        float C = length(cp) ;\n        return sqrt(C * C - xAxis_cp * xAxis_cp) ;\n    }\n}\n\n// Disque\n// p : Point\n// c : center of the disque (in french)\n// r : radius\n// rotationAxis : axe where the rotation is made around the point c\n// e : energy associated to skeleton\n// R : large radius\nfloat disque(vec3 p, vec3 c, float r, vec3 rotationAxis, float e, float R) {\n    return e * falloff(distanceDisque(p, c, r, rotationAxis), R); \n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b) {\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b) {\n    return max(a,b);\n}\n\n// Intersect\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersect(float a,float b) {\n    return min(a,b);\n}\n\n// Difference\n// a : field function of left sub-tree\n// b : field function of right sub-tree \nfloat Difference(float a, float b){\n    return min(a, 2.0*T-b);\n}\n\n// Potential field of the object\n// p : point\n// origin : position of the medusa\nfloat Medusa(vec3 p, vec3 origin){\n    p.z=-p.z;\n      float cosinus = cos(iTime);\n    //body \n    float v = point(p, origin, 1.0, 5.0);\n    v = Blend(v, disque(p, origin + vec3(0.0, -1.0, 0.0) , 2.5, vec3(0.0, 1.0, 0.0), 0.7, 0.7));\n    \n    //tentacle 1\n    v = Blend(v, segment(p, origin + vec3(-2.0, -1.0, -1.0), origin + vec3(-2.0, -3.0, -1.0), 1.0, 1.0));\n    v = Blend(v, segment(p, origin + vec3(-2.0, -3.0, -1.0), origin + vec3(-3.0+cosinus, -5.0, -1.0), 1.0, 1.0));    \n    v = Blend(v, segment(p, origin + vec3(-3.0+cosinus, -5.0, -1.0), origin + vec3(-2.0, -7.0, -1.0), 1.0, 1.0));    \n    \n    \n    //tentacle 2\n    v = Blend(v, segment(p, origin + vec3(2.0, -1.0, 1.0), origin + vec3(3.0, -3.0, 1.0), 1.0, 1.0));\n    v = Blend(v, segment(p, origin + vec3(3.0, -3.0, 1.0), origin + vec3(2.0-cosinus, -5.0, 1.0), 1.0, 1.0));    \n    v = Blend(v, segment(p, origin + vec3(2.0-cosinus, -5.0, 1.0), origin + vec3(2.0, -7.0, 1.0), 1.0, 1.0));    \n    \n    //tentacle 3\n    v = Blend(v, segment(p, origin + vec3(0.0, -1.0, 2.0), origin + vec3(0.0, -3.0, 2.0), 1.0, 1.0));\n    v = Blend(v, segment(p, origin + vec3(0.0, -3.0, 2.0), origin + vec3(0.0, -5.0, 2.0-cosinus), 1.0, 1.0));    \n    v = Blend(v, segment(p, origin + vec3(0.0, -5.0, 2.0-cosinus), origin + vec3(0.0, -7.0, 2.0), 1.0, 1.0));    \n    \n    //tentacle 4\n    v = Blend(v, segment(p, origin + vec3(0.0, -1.0, -2.0), origin + vec3(0.0, -3.0, -2.0), 1.0, 1.0));\n    v = Blend(v, segment(p, origin + vec3(0.0, -3.0, -2.0), origin + vec3(0.0, -5.0, -2.0+cosinus), 1.0, 1.0));    \n    v = Blend(v, segment(p, origin + vec3(0.0, -5.0, -2.0+cosinus), origin + vec3(0.0, -7.0, -2.0), 1.0, 1.0));    \n    \n      return v;\n}\n\n// A simple house\n// p : point to check\nfloat house(vec3 p) {\n\n    //Shape of the house\n    float house = cube(p, vec3(-2.0, 0.0, -4.0), 10.0, 7.0, 3.0, 1.0);\n    \n    //indoor space\n    house = Difference(house, cube(p, vec3(-2.0, 0.0, -3.6), 10.0, 6.5, 3.0,1.0));\n    \n    //Door + windows\n    house = Difference(house, rect(p, vec3(-6.2, -2.5, -1.0), 10.0, vec3(0.1, 2.5, 1.2), 1.0, 1.0));\n    house = Difference(house, rect(p, vec3(-6.2, 3.0, -6.0), 5.0, vec3(0.1, 1.0, 1.2), 1.0, 1.0));\n    house = Difference(house, rect(p, vec3(-6.2, 3.0, 4.0), 5.0, vec3(0.1, 1.0, 1.2), 1.0, 1.0));\n    \n    //A simple door    \n    return house;\n}\n\n\n// flowingWater\n// p : point\nfloat flowingWater(vec3 p) {\n    \n    float v = point(p, vec3(0.0, 0.0, 0.0), 1.0, 1.0);\n    \n    for(float fi = 0.0; fi < 15.0; ++fi){\n        float cosinus = cos(iTime+fi) * 0.3;\n        float fi2 = fi*0.5;\n    \tv = Blend(v, point(p, vec3(cosinus, fi2, 0.0), 1., 1.));\n        v = Blend(v, point(p, vec3(cosinus, fi2, 0.5), 1., 1.));\n\t\tv = Blend(v, point(p, vec3(cosinus, fi2, 1.0), 1., 1.));\n    }\n                       \n    return v;  \n}\n\n// Field of various object (a house, a medusa and a flowing water of the window)\n// p : point\nfloat object(vec3 p) {\n    p.z=-p.z;\n\n    float field;\n    field = house(p+vec3(-10.0, 0.0, 10.0));\n    field = Union(field, flowingWater(p+vec3(4.0, 1.0, 5.0)));\n    \n    field = Union(field, Medusa(p, vec3(4.0, 3.0+cos(iTime), -5.0)));\n    \n    \n    return -T+field;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p ) {\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s) {\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s) {\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          s=i;\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd) {\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n) {\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n) {\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2));\n  vec3 ro = vec3(0.0, 2.0, 30.0);\n\n\n  float a =-0.5;\n  ro = rotateX(ro, a);\n  rd = rotateX(rd, a);\n    \n  ro = rotateY(ro, -1.5);\n  rd = rotateY(rd, -1.5);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}