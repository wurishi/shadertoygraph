{"ver":"0.1","info":{"id":"4t3GWS","date":"1471056084","viewed":700,"name":"Montecarlo Fractal Explorer","username":"rory618","description":"Use the mouse to draw a new viewport and press w to zoom in. R to reset. Change which fractal to render with comments. W also resets montecarlo result. hold 1 and left mouse button to change seed","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    \n    fragColor = texture(iChannel1, uv);\n    \n    vec2 nup = mouse.xy - mouse.zw;\n    vec2 nright = vec2(nup.y, -nup.x) * iResolution.x / iResolution.y;\n    \n\t\n    \n    vec2 o = (fragCoord - mouse.zw);\n    \n    float z = max(0.0, min(1.0, 1.0-\n    min(\n    \tmin(\n        \tabs( dot(o, nup)/length( nup) - length( nup)) , \n            abs( dot(o,-nup)/length(-nup) - length(-nup)) \n        ), min(\n            abs( dot(o, nright)/length( nright) - length( nright)) ,\n         \tabs( dot(o,-nright)/length(-nright) - length(-nright)) \n        )\n    )));\n    \n    if(iMouse.z>.1 && mouse.z != 0.0)\n        fragColor += z;//*fragColor + (z);\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst vec2 param1Loc = vec2(0.5,2.5);\nconst vec2 param2Loc = vec2(0.5,3.5);\nconst vec2 param3Loc = vec2(0.5,4.5);\nconst vec2 param4Loc = vec2(0.5,5.5);\nconst vec2 param5Loc = vec2(0.5,6.5);\n\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nconst float KEY_0 = 48.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\n\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec4 param1 = load(param1Loc);\n    vec4 param2 = load(param2Loc);\n    vec4 param3 = load(param3Loc);\n    vec4 param4 = load(param4Loc);\n    vec4 param5 = load(param5Loc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n        \n    if (iMouse.z < 0.1) {\n        mouse.zw = -iMouse.xy;\n    } else if(mouse.z < 0.0) {\n        mouse.zw = iMouse.xy;\n    }\n    \n    mouse.xy = iMouse.xy;\n    if (iMouse.z > 0.1 && mouse.z != 0.0) {\n    \tif ( keyIsDown(KEY_W) && mouse.xy != mouse.zw ) {\n        \tvec2 ncenter = uvtoc(center, up, right, (mouse.zw / iResolution.xy - vec2(.5))*2.0);\n            vec2 nup = uvtoc(center, up, right, (mouse.xy / iResolution.xy - vec2(.5))*2.0) - ncenter;\n            center = ncenter;\n            up = nup;\n            mouse.z = 0.0;\n    \t}\n    }\n    \n    viewport = vec4(center, up);\n    \n    if ( keyIsDown(KEY_R) || iFrame <= 1) {\n        viewport = vec4(0.0,0.0,0.0,1.0);\n        //param1=vec4(1);\n        //param2=vec4(0);\n        //param3=vec4(0);\n        //param4=vec4(0);\n        //param5=vec4(0);\n    }\n    \n    fragColor = vec4(0);\n    \n    if (keyIsDown(KEY_1)){param1.xy=mouse.xy;}\n    if (keyIsDown(KEY_2)){param2.xy=mouse.xy;}\n    if (keyIsDown(KEY_3)){param3.xy=mouse.xy;}\n    if (keyIsDown(KEY_4)){param4.xy=mouse.xy;}\n    if (keyIsDown(KEY_5)){param5.xy=mouse.xy;}\n    \n    fragColor += save(param1,param1Loc,fragCoord);\n    fragColor += save(param2,param2Loc,fragCoord);\n    fragColor += save(param3,param3Loc,fragCoord);\n    fragColor += save(param4,param4Loc,fragCoord);\n    fragColor += save(param5,param5Loc,fragCoord);\n    \n    fragColor += save(viewport,viewportLoc,fragCoord);\n    fragColor += save(mouse,mouseLoc,fragCoord);\n}\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define I vec2(0,1)\n#define R vec2(1,0)\n#define PI 3.14159\n#define E 2.71828\n\n//cproj\nfloat creal(vec2 z) {\n    return z.x;\n}\nfloat cimag(vec2 z) {\n    return z.y;}\nvec2 conj(vec2 z) {\n    return vec2(z.x,-z.y);\n}\nvec2 cprod(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 csqr(vec2 a){\n    return cprod(a,a);\n}\nfloat cabs(vec2 z) {\n    return sqrt(cprod(z,conj(z)).x);\n}\nfloat cabs2(vec2 z) {\n    return cprod(z,conj(z)).x;\n}\nvec2 cinv(vec2 z){\n    return conj(z)/cabs2(z);\n}\nvec2 cdivide(vec2 a, vec2 b){\n    return cprod(a,cinv(b));\n                            }\nfloat carg(vec2 z) {\n    if(z.x<0.){\n        if(z.y>0.){\n    \t\treturn PI + atan(z.y/z.x);\n        } else {\n            return -PI + atan(z.y/z.x);\n        }\n    }\n    return atan(z.y/z.x);\n}\nvec2 cexp(vec2 z) {\n    return exp(z.x)*vec2(cos(z.y),sin(z.y));\n}\nvec2 clog(vec2 z) {\n    return R*log(cabs(z))+I*carg(z);\n}\nvec2 cpow(vec2 a, vec2 b) {\n    return cexp(cprod(b,clog(a)));\n}\nvec2 csqrt(vec2 z){\n    return cpow(z, .5*R);\n}\nvec2 csinh(vec2 z){\n    return (cexp(z)-cexp(-z))/2.;\n}\nvec2 ccosh(vec2 z){\n    return (cexp(z)+cexp(-z))/2.;\n}\nvec2 ctanh(vec2 z){\n    return cdivide(csinh(z),ccosh(z));\n}\nvec2 casinh(vec2 z){\n    return clog(z + csqrt(R + cprod(z,z)));\n}\nvec2 cacosh(vec2 z){\n    return clog(z + csqrt(z + R) + csqrt(z - R));\n}\nvec2 catanh(vec2 z){\n    return (clog(z + R) + clog(z - R))/2.;\n}\nvec2 csin(vec2 z){\n    return cprod(-I,csinh(cprod(I,z)));\n}\nvec2 ccos(vec2 z){\n    return ccosh(cprod(I,z));\n}\nvec2 ctan(vec2 z){\n    return cprod(-I,ctanh(cprod(I,z)));\n}\nvec2 casin(vec2 z){\n    return cprod(-I,casinh(cprod(I,z)));\n}\nvec2 cacos(vec2 z){\n    return R*PI/2.+cprod(I, clog(cprod(I,z) + csqrt(R + cprod(z,z))));\n}\nvec2 catan(vec2 z){\n    return cprod(-I,catanh(cprod(I,z)));\n}\nvec2 gammagth(vec2 z) {\n    return cprod(cpow(cprod(z/E,csqrt(cprod(z,csinh(cinv(z))))),z),csqrt(cdivide(R*2.*PI,z)));\n}\nvec2 gamma(vec2 z){\n    if(z.x<.5){\n        return cdivide(PI*R,cprod(csin(cprod(PI*R,z)), gammagth(R-z)));\n    } else {\n        return gammagth(z);\n    }\n}\n\n\nconst vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst vec2 param1Loc = vec2(0.5,2.5);\nconst vec2 param2Loc = vec2(0.5,3.5);\nconst vec2 param3Loc = vec2(0.5,4.5);\nconst vec2 param4Loc = vec2(0.5,5.5);\nconst vec2 param5Loc = vec2(0.5,6.5);\n\nvec2 seed = vec2(0);\nvec2 r1 = vec2(1);\nvec2 r2 = vec2(2);\nvec2 r3 = vec2(3);\nvec2 r4 = vec2(4);\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nconst float KEY_0 = 48.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\n\nfloat smoothing = 100.0;\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n\nbool keyIsDown( float key ) {\n    return texture( iChannel2, vec2(key,0.25) ).x > .5;\n}\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n/*vec2 cprod(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}*/\nvec2 sqr(vec2 z) {\n    return cprod(z,z);\n}\nvec2 cpowi(vec2 z, int i) {\n    float theta = atan(z.y/z.x);\n    if (z.x<0.0){\n        theta += 3.1415926;\n    }\n    return vec2(cos(float(i)*theta),sin(float(i)*theta))*pow(length(z),float(i));\n}\nvec2 cpowf(vec2 z, float f) {\n    float theta = atan(z.y/z.x);\n    if (z.x<0.0){\n        theta += 3.1415926;\n    }\n    return vec2(cos(f*theta),sin(f*theta))*pow(length(z),f);\n}\n/*vec2 cinv(vec2 z) {\n    float lsz = z.x*z.x+z.y*z.y;\n    return z*vec2(1.0,-1.0)/lsz;\n}\nvec2 cdivide(vec2 a, vec2 b) {\n    return cprod(a,cinv(b));\n}*/\n\nvoid parameters(vec2 center, vec2 up, vec2 right) {\n    \n\n    seed = 3.*((load(param1Loc).xy/iResolution.xy)-vec2(.5));\n    \n    \n    r1 = load(param2Loc).xy/iResolution.xy;\n    r2 = load(param3Loc).xy/iResolution.xy;\n    r3 = load(param4Loc).xy/iResolution.xy;\n    r4 = load(param5Loc).xy/iResolution.xy;\n    \n}\n\n\n//////////////////////////////////////////////////\n// HYBRID FRACTAL\n/*///////////////////////////////////////////////\n\n\n\nvec2 boxFold( vec2 x ) {\n    vec2 ret;\n    ret = abs(vec2(-1,-1) - x) - abs(vec2(1,1) - x) - x;\n    return ret;\n}\n\nvec2 ballFold(float r, vec2 x ) {\n    float mag = sqrt (x.x*x.x+x.y*x.y);\n    vec2 ret = x / vec2(mag , mag);\n    if (mag < r) {\n        mag /= r*r;\n    } else if ( mag < 1.0) {\n        mag = 1.0/mag;\n    }\n    return ret * vec2(mag,mag);\n    \n}\n\nvec2 start(vec2 c) {\n    return vec2(c);\n}\nvec2 loop(vec2 z, vec2 c) {\n    \n    float s = -1.0;\n    float r = .2;\n    float f = 1.8;\n    \n    z = sqr(z) + c;\n    z = sqr(z) + c;\n    \n    return s * ballFold(r, f * boxFold(z))+c;\n}\n\nbool bailout(vec2 z) {\n    return length(z) > 16.0;\n}\n\n\nvec3 color(vec2 z, int i){\n    if(i==0){ return vec3(0.0); }\n    float c = float(i);\n    return vec3(\n        .5+.5*sin(5.1*log(c)),\n        .5+.5*sin(5.2*log(c)),\n        .5+.5*sin(5.3*log(c)));\n}\n\n#define MAX_ITER 1000\n\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = loop(z, c);\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n    }\n    return vec3(z, 0);\n}\n\nvec4 image(vec2 p) {\n    \n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////\n// GRID FRACTAL\n/*///////////////////////////////////////////////\n\nfloat start(vec2 c) {\n    return 0.0;\n}\nfloat loop(float z, vec2 c, int i) {\n    vec3 d = (\n        vec3(c,0.0)*mat3(1,0,0,\n                         0,1,0,\n                         0,0,1)\n    ) * float(i);\n    float l = length(mod(d+vec3(.5),vec3(1.0)) - vec3(.5) );\n        \n    return z + (1.-smoothstep(0.,0.1,l))/sqrt(float(i+1));\n    \n}\n\nvec3 color(float z){\n    return vec3(\n    \t.5+.5*sin(sqrt(z)*4.14),\n    \t.5+.5*sin(sqrt(z)*4.25),\n    \t.5+.5*sin(sqrt(z)*4.36)\n    );\n}\n\n#define MAX_ITER 1000\n\nfloat iteratedFractal(vec2 c) {\n    float z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = loop(z, c, i);\n    }\n    return z;\n}\n\nvec4 image(vec2 p) {\n    \n    float f = iteratedFractal(p);\n    return vec4(color(f),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////\n// MANDELBOX\n/*///////////////////////////////////////////////\n\n\n\nvec2 boxFold( vec2 x ) {\n    vec2 ret;\n    ret = abs(vec2(-1,-1) - x) - abs(vec2(1,1) - x) - x;\n    return ret;\n}\n\nvec2 ballFold(float r, vec2 x ) {\n    float mag = sqrt (x.x*x.x+x.y*x.y);\n    vec2 ret = x / vec2(mag , mag);\n    if (mag < r) {\n        mag /= r*r;\n    } else if ( mag < 1.0) {\n        mag = 1.0/mag;\n    }\n    return ret * vec2(mag,mag);\n    \n}\n\nvec2 start(vec2 c) {\n    return vec2(c);\n}\nvec2 loop(vec2 z, vec2 c) {\n    \n    float s = 2.0;\n    float r = .5;\n    float f = 1.0;\n    \n    return s * ballFold(r, f * boxFold(z)) + c;\n}\n\nbool bailout(vec2 z) {\n    return length(z) > 16.0;\n}\n\n\nvec3 color(vec2 z, int i){\n    if(i==0){ return vec3(0.0); }\n    float c = float(i);\n    return vec3(\n        .5+.5*sin(0.1*sqrt(c)),\n        .5+.5*sin(0.2*sqrt(c)),\n        .5+.5*sin(0.3*sqrt(c)));\n}\n\n#define MAX_ITER 100\n\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = loop(z, c);\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n    }\n    return vec3(z, 0);\n}\n\nvec4 image(vec2 p) {\n  \n    \n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////\n// MANDELBOX JULIA\n/*///////////////////////////////////////////////\n\n\n\nvec2 boxFold( vec2 x ) {\n    vec2 ret;\n    ret = abs(vec2(-1,-1) - x) - abs(vec2(1,1) - x) - x;\n    return ret;\n}\n\nvec2 ballFold(float r, vec2 x ) {\n    float mag = sqrt (x.x*x.x+x.y*x.y);\n    vec2 ret = x / vec2(mag , mag);\n    if (mag < r) {\n        mag /= r*r;\n    } else if ( mag < 1.0) {\n        mag = 1.0/mag;\n    }\n    return ret * vec2(mag,mag);\n    \n}\n\nvec2 start(vec2 c) {\n    return vec2(c);\n}\nvec2 loop(vec2 z, vec2 c) {\n    \n    float s = 2.0;\n    float r = .5;\n    float f = 1.0;\n    \n    return s * ballFold(r, f * boxFold(z)) + seed*10.;\n}\n\nbool bailout(vec2 z) {\n    return length(z) > 16.0;\n}\n\n\nvec3 color(vec2 z, int i){\n    if(i==0){ return vec3(0.0); }\n    float c = float(i);\n    return vec3(\n        .5+.5*sin(5.1*log(c)),\n        .5+.5*sin(5.2*log(c)),\n        .5+.5*sin(5.3*log(c)));\n}\n\n#define MAX_ITER 100\n\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = loop(z, c);\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n    }\n    return vec3(z, 0);\n}\n\nvec4 image(vec2 p) {\n  \n    \n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////\n// JULIA SET\n/*///////////////////////////////////////////////\n\nvec2 start(vec2 c) {\n    return vec2(c);\n}\nvec2 loop(vec2 z, vec2 c) {\n    return sqr(z) + c;\n}\n\nbool bailout(vec2 z) {\n    return length(z) > 16.0;\n}\n\n\nvec3 color(vec2 z, int i){\n    if(i==0){ return vec3(0.0); }\n    float c = float(i);\n    return vec3(\n        .5+.5*sin(5.1*log(c)),\n        .5+.5*sin(5.2*log(c)),\n        .5+.5*sin(5.3*log(c)));\n}\n\n#define MAX_ITER 1000\n#define SEED vec2(.4,.1)\n\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = loop(z, seed);\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n    }\n    return vec3(sin(z), 0);\n}\n\nvec4 image(vec2 p) {\n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////\n// SMOOTH MANDELBROT SET\n//*///////////////////////////////////////////////\n\nvec2 start(vec2 c) {\n    return vec2(0);\n}\nvec2 loop(vec2 z, vec2 c) {\n    return sqr(z) + c;\n}\n\nbool bailout(vec2 z) {\n    return length(z) > 16.0;\n}\n\nfloat smoothMandelbrot(vec2 z, int i) {\n    return float(i) + 1. - log(log(length(z)))/log(2.0);\n}\n\nvec3 color(vec2 z, int i){\n    if(i==0){ return vec3(0.0); }\n    float c = smoothMandelbrot(z, i);\n    return vec3(\n        .5+.5*sin(5.1*log(c)),\n        .5+.5*sin(5.2*log(c)),\n        .5+.5*sin(5.3*log(c)));\n}\n\n#define MAX_ITER 1000\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = loop(z, c);\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n    }\n    return vec3(z, 0);\n}\n\nvec4 image(vec2 p) {\n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////\n// BURNING SHIP\n/*///////////////////////////////////////////////\n\nvec2 start(vec2 c) {\n    return c;\n}\nvec2 loop(vec2 z, vec2 c) {\n    return sqr(sqr(abs(z))) + seed;\n}\n\nbool bailout(vec2 z) {\n    return length(z) > 16.0;\n}\n\nfloat smoothMandelbrot(vec2 z, int i) {\n    return float(i) + 1. - log(log(length(z)))/log(4.0);\n}\n\nvec3 color(vec2 z, int i){\n    if(i==0){ return vec3(0.0); }\n    float c = smoothMandelbrot(z, i);\n    return vec3(\n        .5+.5*sin(2.1*sqrt(c)),\n        .5+.5*sin(2.2*sqrt(c)),\n        .5+.5*sin(2.3*sqrt(c)));\n}\n\n#define MAX_ITER 1000\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        z = loop(z, c);\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n    }\n    return vec3(z, 0);\n}\n\nvec4 image(vec2 p) {\n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n//////////////////////////////////////////////////\n// NEWTON\n/*///////////////////////////////////////////////\n\nvec2 start(vec2 c) {\n    return vec2(c);\n}\n\nvec2 p(vec2 z) {\n    //return cpowi(z,3)-vec2(1.0,0.0);\n    return cpowi(z,8)+15.0*cpowi(z,4)-vec2(16.0,0.0);\n    //return cpowi(z,3)-2.0*z+vec2(2.0,0.0);\n}\n\nvec2 pp(vec2 z) {\n    //return 3.0*cpowi(z,2);\n    return 8.0*cpowi(z,7)+4.0*15.0*cpowi(z,3);\n    //return 3.0*cpowi(z,2)-vec2(2.0,0.0);\n}\n\nvec2 dz(vec2 z) {\n    return cinv(\n        \t\tcinv( z - r1 ) +\n        \t\tcinv( z - r2 ) +\n        \t\tcinv( z - r3 ) +\n        \t\tcinv( z - r4 )\n        );\n}\n\nvec2 loop(vec2 z, vec2 c) {\n    //return z - cdivide(p(z),pp(z));\n    //z = cpowf(sqr(z)+c,.5);\n    return z - 3.473*dz(z);\n}\n\nbool bailout(vec2 z) {\n    return length(dz(z)) < 0.001;\n}\n\nvec3 color(vec2 z, int i){\n    if (i == 0) {\n    return vec3(\n        .5+.5*sin(2.0*z.x+1.7*z.y),\n        .5+.5*sin(0.4*z.x+2.6*z.y),\n        .5+.5*sin(1.4*z.x+3.5*z.y));\n    }\n    float c = float(i);\n    return vec3(\n        .25+.25*sin(2.1*log(c)),//+.25+.25*sin(2.0*z.x+1.7*z.y),\n        .25+.25*sin(2.2*log(c)),//+.25+.25*sin(0.4*z.x+2.6*z.y),\n        .25+.25*sin(2.3*log(c)));//+.25+.25*sin(1.4*z.x+3.5*z.y));\n}\n\n#define MAX_ITER 1000\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n        z = loop(z, c);\n    }\n    return vec3(z, 0);\n}\n\nvec4 image(vec2 p) {\n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n//////////////////////////////////////////////////\n// GAMMA\n/*///////////////////////////////////////////////\n\nvec2 start(vec2 c) {\n    return vec2(c);\n}\n\nvec2 loop(vec2 z, vec2 c) {\n    return gamma(z)+c;\n}\n\nbool bailout(vec2 z) {\n    return length(z) > 15.0;\n}\n\nvec3 color(vec2 z, int i){\n    if (i == 0) {\n    return vec3(\n        .5+.5*sin(2.0*z.x+1.7*z.y),\n        .5+.5*sin(0.4*z.x+2.6*z.y),\n        .5+.5*sin(1.4*z.x+3.5*z.y));\n    }\n    float c = float(i);\n    return vec3(\n        .25+.25*sin(2.1*log(c)),//+.25+.25*sin(2.0*z.x+1.7*z.y),\n        .25+.25*sin(2.2*log(c)),//+.25+.25*sin(0.4*z.x+2.6*z.y),\n        .25+.25*sin(2.3*log(c)));//+.25+.25*sin(1.4*z.x+3.5*z.y));\n}\n\n#define MAX_ITER 20\nvec3 iteratedFractal(vec2 c) {\n    vec2 z = start(c);\n    for(int i = 0; i < MAX_ITER; i++) {\n        if (bailout(z)) {\n        \treturn vec3(z, i);\n        }\n        z = loop(z, c);\n    }\n    return vec3(z, 0);\n}\n\nvec4 image(vec2 p) {\n    vec3 f = iteratedFractal(p);\n    return vec4(color(f.xy,int(f.z)),1.0);\n}\n\n\n///////////////////////////////////////////////////////*/\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n\tvec2 uv = (fragCoord.xy - vec2(.5) + hash23(vec3(fragCoord, iTime))) / iResolution.xy;\n    \n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    parameters(center, up, right);\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    if ( keyIsDown(KEY_R) || keyIsDown(KEY_W) || iFrame <= 1) {\n        fragColor = image(p);\n    } else {\n    \tfragColor = (1.0-1.0/smoothing)*texture(iChannel1, fragCoord / iResolution.xy) + (1.0/smoothing)*image(p);\n    }\n    \n}","name":"Buf B","description":"","type":"buffer"}]}