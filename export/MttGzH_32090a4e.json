{"ver":"0.1","info":{"id":"MttGzH","date":"1468029756","viewed":128,"name":"just rtrace dat spheres! v1","username":"pyBlob","description":"faster than raymarching!\n\n2400 chars\ninlined rendering\nround macro\nsaturate macro\nremoved &quot;in&quot;\n\n2000 chars\ninlined shadow\nV swizzle vector\nsphere only needs t2\nreject negative distance\ninlined plane\ninlined sphere\nglobal vars\n\n1500\nmore stuff","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","challenge","sizecoding","sh16a"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define checker(v) mod(floor(v.x),2.0) == mod(floor(v.y), 2.0)\n#define round(v) floor(v + 0.5)\n#define sat(x) clamp(x, 0.0, 1.0)\n#define U(x) normalize(x)\n#define L(x) for (float x=-2.0 ; x<3.0 ; x++)\n\nfloat time, dif, INF = 1e5, b, r;\nvec2 p, uv, V = vec2(0.0, 1.0);\nvec3 ro, cw, cu, cv, rd, pt, col, nor, hit, lig, x, q;\n\n//bool checker(vec2 v)\n//{\n//    v = floor(v);\n//    return mod(v.x, 2.0) == mod(v.y, 2.0);\n//}\n\n//vec2 sphere(vec3 q, vec3 v, float r)\n//{\n//    q.y -= r;\n//    \n//    //if (det < 0.0) return vec2(INF);\n//    //det = sqrt(det);\n//    \n//    //float t1 = (-b+det)/a;\n//    //float t2 = (-b-det)/a;\n//    \n//    //if (t1 < 0.0 && t2 < 0.0) return vec2(INF);\n//    //return vec2(min(t1, t2), r);\n//    \n//    //return vec2(min(det, (-b-sqrt(det))/a), r); // NICE ...\n//    \n//    //a = 2.0 * dot(v, v);\n//    b = dot(q, v);\n//    \n//    return vec2(\n//        -b -\n//        sqrt(\n//            b*b -\n//            dot(q, q) +\n//            r*r\n//        ),\n//        r\n//    ); // just assume it gets removed ^^\n//}\n\n//vec2 plane( vec3 q, vec3 v )\n//{\n//    return vec2(-q.y / v.y);\n//}\n\n//void merge( vec2 t, float tp)\n//{\n//    if (t.x > 0.0 && t.x < pt.x)\n//    {\n//        pt = vec3(t, tp);\n//    }\n//}\n\n#define merge(t, tp) \\\n    pt = t.x > 0.0 && t.x < pt.x ? vec3(t, tp) : pt\n\nvoid trace()\n{\n    pt = vec3(INF, 0.0, 0.25);\n    //merge(pt, plane(ro, rd), 0.5);\n    merge(\n        vec2(-ro.y / rd.y),\n        0.5\n    );\n    \n    L(i)\n        L(j)\n            r = checker(vec2(i,j)) ? 0.4 : 0.25,\n            q = ro - vec3(i,r,j),\n            b = dot(q, rd),\n    \t\tmerge(\n\t\t\t\t//sphere(\n\t\t\t\t//\tq,\n\t\t\t\t//\trd,\n                //\tr\n\t\t\t\t//),\n                vec2(\n                    -b -\n                    sqrt(\n                        b*b -\n                        dot(q, q) +\n                        r*r\n                    ),\n                \tr\n                ),\n\t\t\t\ti*5.0+j\n\t\t\t);\n    \n    //for (float z=-12.0 ; z<13.0 ; z++)\n    //    merge(\n    //        pt,\n    //        sphere(\n    //            ro - vec3(floor(z/5.0),0.0,mod(z,5.0)),\n    //            rd\n    //        ),\n    //        z\n    //    );\n    \n    //return pt;\n}\n\n//float shadow(vec3 ro, vec3 rd, float mint, float tmax )\n//{\n//    return trace(ro+mint*rd, rd).x > tmax ? 1.0 : 0.0;\n//}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n\tp = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\ttime = 5.0;\n    //time = 0.1 * iTime;\n\n\t// camera\n\t//vec3 ro = vec3( 3.0*cos(0.1*time), 1.0, 3.0*sin(0.1*time) );\n    ro = vec3(\n        3.0*cos(time),\n        2.0,\n        3.0*sin(time)\n    );\n\t\n\t// camera-to-world transformation\n\t//mat3 setCamera(vec3 ro, vec3 ta, float cr )\n    cw = U(\n        -0.2 * V.xyx -\n        ro\n    );\n    //vec3 cp = vec3(sin(6.283185), cos(6.283185),0.0); // 6.xxx = 2pi\n    //vec3 cp = vec3(0.0, 1.0, 0.0); // up vector\n    //vec3 cu = U(cross(cw,cp));\n    cu = U(vec3( -cw.z, 0.0, cw.x ));\n    mat3 ca = mat3(cu, cross(cu, cw), cw);\n    \n    // ray direction\n\trd = ca * U( vec3(p.xy,2.0) );\n\n    // render\t\n    trace();\n    \n    col = vec3(0.7, 0.9, 1.0) + rd.y*vec3(0.8);\n    if (pt.z != 0.25)\n    {\n        //nor;\n        hit=ro+rd*pt.x;\n        \n        if (pt.z == 0.5)\n        {\n            nor = V.xyx;\n            \n            uv = 256.0*0.1*hit.xz + vec2(37.0,17.0);\n            \n            col = vec3(\n                checker(hit.xz) ?\n                0.4 :\n                0.5 *\n                texture(\n                    iChannel0,\n                    (floor(uv)+0.5) / 256.0, -100.0\n                ).y\n            );\n            \n            if ( max( abs(hit.x), abs(hit.z)) < 1.5 )\n            {\n                col *= smoothstep(\n                    0.0,\n                    0.5,\n                    length(mod(hit.xz+0.5,1.0)-0.5)\n                );\n            }\n        }\n        else\n        {\n            x = round(hit-pt.y*V.xyx);\n            nor = U(hit-pt.y*V.xyx-x);\n            //col = nor;\n            //col = vec3(1.0,0.0,0.0);\n            col = V.yxx + floor(6.0 + pt.z * 0.5) * vec3(-0.08, 0.03, 0.06);\n        }\n        \n        // shade\n        //vec3 ref = reflect(rd,nor);\n        //vec3 lig = U( vec3(-0.6, 0.7, -0.5) );\n        //\n        //float amb = sat(0.5+0.5*nor.y);\n        //float dif = sat(dot( U(nor), lig ));\n        //float spe = pow(sat( dot(U(ref), lig )), 16.0);\n\t\t//\n        ////dif *= shadow( hit, lig, 0.01, 2.5 );\n        //dif *= trace(hit+0.01*lig, lig).x > 2.5 ? 1.0 : 0.0;\n\t\t//\n        //col =\n        //    col * (\n        //    \tdif * vec3(1.20,1.02,0.66) +\n        //    \tamb * vec3(0.25,0.35,0.5)\n        //    ) +\n        //    spe*dif;\n        \n        lig = U( vec3(-0.6, 0.7, -0.5) );\n        \n        dif = sat(dot( nor, lig ));\n\n        //dif *= shadow( hit, lig, 0.01, 2.5 );\n        ro = hit+0.01*lig;\n        cw = rd;\n        rd = lig;\n        trace();\n        dif *= pt.x > 2.5 ? 1.0 : 0.0;\n\n        col =\n            col * vec3(1.20,1.02,0.66) * dif +\n            col * vec3(0.25,0.35,0.5) * sat(0.5+0.5*nor.y) +\n            dif * pow(sat( dot(reflect(cw,nor), lig )), 16.0);\n    }\n    \n    fragColor=vec4( sqrt(col), 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}