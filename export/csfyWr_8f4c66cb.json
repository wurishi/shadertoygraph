{"ver":"0.1","info":{"id":"csfyWr","date":"1687026258","viewed":125,"name":"Real-Time Spherical Harmonics","username":"cjhoward","description":"Diffuse lighting via real-time generation of spherical harmonics illuminance coefficients/matrices from luminance. I use this technique in Antkeeper, an open-source ant colony simulation game I'm developing: https://antkeeper.com","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["sphericalharmonics","ibl","sh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * MIT License\n * \n * Copyright (c) 2023 Christopher J. Howard\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Control camera angles\n    float yaw = mix(-PI, PI, iMouse.x / iResolution.x);\n    float pitch = mix(HALF_PI, -HALF_PI, iMouse.y / iResolution.y);\n    \n    // Animate camera angles\n    if (iMouse.xy == vec2(0.0))\n    {\n        yaw = TWO_PI * iTime / 20.0;\n        pitch = 0.0;\n    }\n    \n    // Setup camera\n    vec3 camera_position = rotation_y(yaw) * rotation_x(pitch) * vec3(0.0, 0.0, CAMERA_DISTANCE);\n    mat3 view = look_at(camera_position, vec3(0.0), vec3(0.0, 1.0, 0.0));\n    vec3 view_direction;\n    view_direction.xy = fragCoord - iResolution.xy * 0.5;\n    view_direction.z = iResolution.y * -0.5 / tan(CAMERA_VFOV * 0.5);\n    view_direction = normalize(view * view_direction);\n    \n    // Render scene\n    const vec3 sphere_center = vec3(0.0);\n    const float sqr_sphere_radius = 1.0 * 1.0;\n    float t = intersect_ray_sphere(camera_position, view_direction, sphere_center, sqr_sphere_radius).x;\n    if (t > 0.0)\n    {\n        // Render sphere\n        vec3 position = camera_position + view_direction * t;\n        vec3 normal = normalize(position - sphere_center);\n        vec3 illuminance_in = sh_lookup_illuminance(iChannel3, normal);\n        vec3 luminance_out = SPHERE_ALBEDO * INV_PI * illuminance_in;\n        fragColor = vec4(srgb_oetf(luminance_out), 1.0);\n    }\n    else\n    {\n        // Render environment\n        vec3 luminance = sample_environment_luminance(view_direction, iTime, ENVMAP0, ENVMAP1);\n        fragColor = vec4(srgb_oetf(luminance), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n * MIT License\n * \n * Copyright (c) 2023 Christopher J. Howard\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n//-------------------------------------------------------------------------------\n\n/// Number of SH directions to sample.\n#define SH_SAMPLE_COUNT 1024\n\n/// Offset to improve SH sample distribution.\n#define SH_SAMPLE_OFFSET 0.36\n\n/// First environment map texture.\n#define ENVMAP0 iChannel0\n\n/// Second environment map texture.\n#define ENVMAP1 iChannel1\n\n/// Albedo of sphere surface.\n#define SPHERE_ALBEDO vec3(1.0)\n\n/// Camera orbit distance.\n#define CAMERA_DISTANCE 4.0\n\n/// Camera vertical field of view\n#define CAMERA_VFOV radians(60.0)\n\n//-------------------------------------------------------------------------------\n\n/// Pi\n#define PI 3.1415926535897932384626433832795\n\n/// 2*Pi\n#define TWO_PI 6.283185307179586476925286766559\n\n/// Pi/2\n#define HALF_PI 1.5707963267948966192313216916398\n\n/// 1/Pi\n#define INV_PI 0.31830988618379067153776752674503\n\n/// Pi*(3-sqrt(5))\n#define GOLDEN_ANGLE 2.3999632297286533222315555066336\n\n/**\n * Projects luminance into spherical harmonics.\n *\n * @param n Direction vector.\n * @param l Luminance in direction @p n.\n *\n * @return SH coefficients in the following layout: ((Y11, Y1_1, Y10), (Y2_2, Y2_1, Y21), (Y20, Y22, Y00)).\n *\n * @see Ramamoorthi, R., & Hanrahan, P. (2001, August). An efficient representation for irradiance environment maps. In Proceedings of the 28th annual conference on Computer graphics and interactive techniques (pp. 497-500).\n */\nmat3 sh_project(in vec3 n, in float l)\n{\n\treturn mat3(n, n.xyz * n.yzx, vec3(n.z * n.z - 1.0 / 3.0, n.x * n.x - n.y * n.y, 1.0)) * l;\n}\n\n/**\n * Builds a matrix which can be used to reconstruct the illuminance of a color channel for a given surface normal.\n *\n * @param c SH coefficients in the following layout: ((Y11, Y1_1, Y10), (Y2_2, Y2_1, Y21), (Y20, Y22, Y00)).\n *\n * @return SH illuminance matrix.\n *\n * @note The returned matrix is symmetric.\n *\n * @see Ramamoorthi, R., & Hanrahan, P. (2001, August). An efficient representation for irradiance environment maps. In Proceedings of the 28th annual conference on Computer graphics and interactive techniques (pp. 497-500).\n */\nmat4 sh_matrix(mat3 c)\n{\n\t// Apply normalization and convolution constants\n    // (If Pi is removed here, the division by Pi can be removed from Lambertian diffuse lighting)\n\tconst mat3 k = mat3(vec3(1.0), vec3(1.875), vec2(0.9375, 1.0).xxy) * PI;\n\tc = matrixCompMult(c, k);\n\t\n\treturn mat4\n\t(\n\t\tvec4(c[2].y, c[1].xz, c[0].x),\n\t\tvec4(c[1].x, -c[2].y, c[1].y, c[0].y),\n\t\tvec4(c[1].zy, c[2].x * 3.0, c[0].z),\n\t\tvec4(c[0], c[2].z - c[2].x)\n\t);\n}\n\n/**\n * Calculates illuminance from SH illuminance matrices for a given surface normal.\n *\n * @param r SH illuminance matrix for the red color channel.\n * @param g SH illuminance matrix for the green color channel.\n * @param b SH illuminance matrix for the blue color channel.\n * @param n Surface normal.\n *\n * @return Illuminance for given surface normal.\n *\n * @see Ramamoorthi, R., & Hanrahan, P. (2001, August). An efficient representation for irradiance environment maps. In Proceedings of the 28th annual conference on Computer graphics and interactive techniques (pp. 497-500).\n */\nvec3 sh_illuminance(in mat4 r, in mat4 g, in mat4 b, in vec3 n)\n{\n\tvec4 n4 = vec4(n, 1.0);\n\tvec3 illuminance = vec3(dot(n4, r * n4), dot(n4, g * n4), dot(n4, b * n4));\n\treturn max(illuminance, 0.0);\n}\n\n/**\n * Looks up SH illuminance matrices from an SH matrix LUT.\n *\n * @param[in] lut SH matrix LUT.\n * @param[out] r SH illuminance matrix for the red color channel.\n * @param[out] g SH illuminance matrix for the green color channel.\n * @param[out] b SH illuminance matrix for the blue color channel.\n */\nvoid sh_lookup_matrices(in sampler2D lut, out mat4 r, out mat4 g, out mat4 b)\n{\n\tr[0] = texelFetch(lut, ivec2( 0, 0), 0);\n    r[1] = texelFetch(lut, ivec2( 1, 0), 0);\n    r[2] = texelFetch(lut, ivec2( 2, 0), 0);\n    r[3] = texelFetch(lut, ivec2( 3, 0), 0);\n\tg[0] = texelFetch(lut, ivec2( 4, 0), 0);\n\tg[1] = texelFetch(lut, ivec2( 5, 0), 0);\n\tg[2] = texelFetch(lut, ivec2( 6, 0), 0);\n\tg[3] = texelFetch(lut, ivec2( 7, 0), 0);\n\tb[0] = texelFetch(lut, ivec2( 8, 0), 0);\n\tb[1] = texelFetch(lut, ivec2( 9, 0), 0);\n\tb[2] = texelFetch(lut, ivec2(10, 0), 0);\n\tb[3] = texelFetch(lut, ivec2(11, 0), 0);\n}\n\n/**\n * Looks up illuminance from an SH matrix LUT for a given surface normal.\n *\n * @param lut SH matrix lut.\n * @param n Surface normal.\n *\n * @return Illuminance for given surface normal.\n */\nvec3 sh_lookup_illuminance(in sampler2D lut, in vec3 n)\n{\n    mat4 r, g, b;\n    sh_lookup_matrices(lut, r, g, b);\n    return sh_illuminance(r, g, b, n);\n}\n\n/**\n * Calculates the weight of a cubemap texel in the given direction.\n *\n * @param n Direction vector.\n *\n * @return Weight of a cubemap texel in direction @p n.\n *\n * @see Sloan, P. P. (2008, February). Stupid spherical harmonics (sh) tricks. In Game developers conference (Vol. 9, p. 42).\n */\nfloat cubemap_texel_weight(vec3 n)\n{\n\tn = n * n;\n\tfloat w = 1.0 + n.x + n.y + n.z - max(n.x, max(n.y, n.z));\n\treturn w * sqrt(w);\n}\n\n/**\n * Samples points distributed on a unit sphere with a Fibonacci lattice.\n *\n * @param i Index of a sample point.\n * @parma n Total number of sample points.\n * @param offset Offset to improve sample distribution. Recommended value is `0.36`.\n *\n * @return Sample point on unit sphere.\n *\n * @see https://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/\n */\nvec3 fibonacci_sphere(in int i, in int n, in float offset)\n{\n\tfloat theta = float(i) * GOLDEN_ANGLE;\n\tfloat cos_phi = 1.0 - 2.0 * (float(i) + offset) / float(n);\n\tfloat sin_phi = sqrt(1.0 - cos_phi * cos_phi);\n\treturn vec3(cos(theta) * sin_phi, sin(theta) * sin_phi, cos_phi);\n}\n\n/**\n * sRGB opto-electronic transfer function (OETF). Maps a linear sRGB color to a non-linear sRGB signal.\n *\n * @param x Linear sRGB color.\n *\n * @return Non-linear sRGB signal.\n *\n * @see IEC 61966-2-1:1999\n */\n/// @{\nfloat srgb_oetf(in float x)\n{\n\treturn x > 0.0031308 ? pow(x, 1.0 / 2.4) * 1.055 - 0.055 : x * 12.92;\n}\nvec3 srgb_oetf(in vec3 x)\n{\n\tvec3 low = pow(x, vec3(1.0 / 2.4)) * 1.055 - 0.055;\n\tvec3 high = x * 12.92;\n\treturn mix(low, high, step(x, vec3(0.0031308)));\n}\n/// @}\n\n/**\n * sRGB electro-optical transfer function (EOTF). Maps a non-linear sRGB signal to a linear sRGB color.\n *\n * @param x Non-linear sRGB signal.\n *\n * @return Linear sRGB color.\n *\n * @see IEC 61966-2-1:1999\n */\n/// @{\nfloat srgb_eotf(in float x)\n{\n\treturn x > 0.0031308 * 12.92 ? pow((x + 0.055) / 1.055, 2.4) : x / 12.92;\n}\nvec3 srgb_eotf(in vec3 x)\n{\n\tvec3 low = pow((x + 0.055) / 1.055, vec3(2.4));\n\tvec3 high = x / 12.92;\n\treturn mix(low, high, step(x, vec3(0.0031308 * 12.92)));\n}\n/// @}\n\n/**\n * Ray-sphere intersection test.\n *\n * @param ro Ray origin.\n * @param rd Ray direction.\n * @param sc Sphere center.\n * @param sqr_sr Squared sphere radius.\n *\n * @return Distances to the near and far points of intersection. Negative values indicate no intersection.\n *\n * @see Haines, E., Günther, J., & Akenine-Möller, T. (2019). Precision improvements for ray/sphere intersection. Ray Tracing Gems: High-Quality and Real-Time Rendering with DXR and Other APIs, 87-94.\n */\nvec2 intersect_ray_sphere(in vec3 ro, in vec3 rd, in vec3 sc, in float sqr_sr)\n{\n\tvec3 d = ro - sc;\n\tfloat b = dot(d, rd);\n\tvec3 qc = d - rd * b;\n\tfloat h = sqr_sr - dot(qc, qc);\n\t\n\tif (h < 0.0)\n\t{\n\t\treturn vec2(-1.0);\n\t}\n\t\n\tfloat sqrt_h = sqrt(h);\n\treturn vec2(-b - sqrt_h, -b + sqrt_h);\n}\n\n/**\n * Constructs a matrix representing a rotation about the X-, Y-, or Z-axis.\n *\n * @param angle Angle of rotation, in radians.\n *\n * @return Rotation matrix.\n */\n/// @{\nmat3 rotation_x(in float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\nmat3 rotation_y(in float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n}\nmat3 rotation_z(in float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n}\n/// @}\n\n/**\n * Constructs a view matrix.\n *\n * @param position Position of the camera.\n * @param target Position of the reference point.\n * @param direction Direction of the up vector.\n *\n * @return View matrix.\n */\nmat3 look_at(in vec3 position, in vec3 target, vec3 up)\n{\n    vec3 forward = normalize(target - position);   \n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    return mat3(right, up, -forward);\n}\n\n/**\n * Samples the environment luminance in a given direction.\n *\n * @param n Direction vector.\n * @param t Current time, in seconds.\n * @param envmap0 First environment map.\n * @param envmap1 Second environment map.\n *\n * @return Luminance in given direction.\n */\nvec3 sample_environment_luminance(vec3 n, float t, samplerCube envmap0, samplerCube envmap1)\n{\n    float a = sin(t + 0.5) * 0.5 + 0.5;\n    a = (a < 0.5) ? 4.0 * a * a * a : 4.0 * a * a * a - 12.0 * a * a + 12.0 * a - 3.0;\n    vec3 l0 = srgb_eotf(textureLod(envmap0, n, 0.0).rgb);\n    vec3 l1 = srgb_eotf(textureLod(envmap1, n, 0.0).rgb);\n    return mix(l0, l1, a);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n * MIT License\n * \n * Copyright (c) 2023 Christopher J. Howard\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/// Builds a 12x1 SH matrix LUT.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Only write first 12 pixels\n    ivec2 uv = ivec2(fragCoord);\n    if (uv.y > 0 || uv.x > 11)\n    {\n        discard;\n    }\n    \n    // Select color channel\n    int channel = uv.x >> 2;\n    \n    // Integrate projected luminance\n    mat3 c = mat3(0.0);\n    float sum_w = 0.0;\n    for (int i = 0; i < SH_SAMPLE_COUNT; ++i)\n    {\n        vec3 n = fibonacci_sphere(i, SH_SAMPLE_COUNT, SH_SAMPLE_OFFSET);\n        float l = sample_environment_luminance(n, iTime, ENVMAP0, ENVMAP1)[channel];\n        float w = cubemap_texel_weight(n);\n        c += sh_project(n, l * w);\n        sum_w += w;\n    }\n    c /= sum_w;\n    \n    // Build SH matrix and store a column in output color\n    fragColor = sh_matrix(c)[uv.x % 4];\n}","name":"Buffer A","description":"","type":"buffer"}]}