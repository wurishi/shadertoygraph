{"ver":"0.1","info":{"id":"lcXSR2","date":"1715304872","viewed":147,"name":"somethingsomethingatmosphere","username":"quadrortx8000","description":"atmo","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gamma = 2.2;\n\nvec3 tone(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / gamma));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord / iResolution.xy);\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    col = tone(col * 0.5);\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat pi = 3.14159265358979323;\n\nfloat normdist (float x, float mean, float dev) {\n    return (1.0 / (dev * sqrt(2.0 * pi))) * exp(-0.5 * pow((x - mean) / dev, 2.0));\n}\n\n//From Jessie\nfloat PreethamBetaO_Fit(float wavelength) {\n    wavelength -= 390.0;\n    float p1 = normdist(wavelength, 202.0, 15.0) * 14.4;\n    float p2 = normdist(wavelength, 170.0, 10.0) * 6.5;\n    float p3 = normdist(wavelength, 50.0, 20.0) * 3.0;\n    float p4 = normdist(wavelength, 100.0, 25.0) * 7.0;\n    float p5 = normdist(wavelength, 140.0, 30.0) * 20.0;\n    float p6 = normdist(wavelength, 150.0, 10.0) * 3.0;\n    float p7 = normdist(wavelength, 290.0, 30.0) * 12.0;\n    float p8 = normdist(wavelength, 330.0, 80.0) * 10.0;\n    float p9 = normdist(wavelength, 240.0, 20.0) * 13.0;\n    float p10 = normdist(wavelength, 220.0, 10.0) * 2.0;\n    float p11 = normdist(wavelength, 186.0, 8.0) * 1.3;\n    return 0.0001 * ((p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9 + p10 + p11) / 1e20);\n}\n\nfloat Air(in float wavelength) {\n    return 1.0+8.06051E-5+2.480990E-2/(132.274-pow(wavelength,-2.0))+1.74557E-4/(39.32957-pow(wavelength,-2.0));\n}\n\nfloat BetaR(in float wavelength) {\n    float nanometers = wavelength * 1e-9;\n\n    float F_N2 = 1.034 + 3.17e-4 * (1.0 / pow(wavelength, 2.0));\n    float F_O2 = 1.096 + 1.385e-3 * (1.0 / pow(wavelength, 2.0)) + 1.448e-4 * (1.0 / pow(wavelength, 4.0));\n    float CCO2 = 0.045;\n    float kingFactor = (78.084 * F_N2 + 20.946 * F_O2 + 0.934 + CCO2 * 1.15) / (78.084 + 20.946 + 0.934 + CCO2);\n    float n = pow(Air(wavelength * 1e-3), 2.0) - 1.0;\n\n    return ((8.0 * pow(pi, 3.0) * pow(n, 2.0)) / (3.0 * 2.5035422e25 * pow(nanometers, 4.0))) * kingFactor;\n}\n\nvec2 RSI (vec3 ro, vec3 rd, vec4 sph) {\n    ro = ro - sph.xyz;\n    float a = sph.a * sph.a;\n    float b = dot(ro, rd);\n    float c = b * b + a - dot(ro, ro);\n\n    if (c < 0.0) return vec2(-1.0);\n\n    c = sqrt(c);\n    return -b + vec2(-c, c);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define CUSTOMRAYLEIGH\n\nconst float sundeg = 1.0;\nconst float sunintens = 100.0;\n\nconst int points = 16;\nconst int odpoints = 8;\n\nconst vec3 scatterm = vec3(2e-6);\nconst vec3 scatterr = vec3(1.8e-6, 14.5e-6, 44.1e-6);\n\nconst float ozone = 1.0;\n\nconst float planetrad = 6371e3;\nconst float atmoheight = 100e3;\n\nconst vec2 scaleheights = vec2(8.0, 1.4) * 1000.0;\n\nconst vec2 inversescaleheights = 1.0 / scaleheights;\nconst vec2 scaledplanetrads = planetrad * inversescaleheights;\nconst float atmorad = planetrad + atmoheight;\nconst float atmolowerlim = planetrad - 1000.0;\n\nfloat rphase(float c) {\n    return  3.0 * (1.0 + c * c) / 16.0 / pi;\n}\n\nfloat mphase2 (float c) {\n    float g = 0.76;\n\n    float e = 1.0;\n    for (int i = 0; i < 8; i++) {\n        float gFromE = 1.0 / e - 2.0 / log(2.0 * e + 1.0) + 1.0;\n        float deriv = 4.0 / ((2.0 * e + 1.0) * log(2.0 * e + 1.0) * log(2.0 * e + 1.0)) - 1.0 / (e * e);\n        if (abs(deriv) < 0.00000001) break;\n        e = e - (gFromE - g) / deriv;\n    }\n\n    return e / (2.0 * pi * (e * (1.0 - c) + 1.0) * log(2.0 * e + 1.0));\n}\n\nfloat raydens (in float h) {\n    return exp(-h * inversescaleheights.x + scaledplanetrads.x);\n}\n\nfloat miedens (in float h) {\n    return exp(-h * inversescaleheights.y + scaledplanetrads.y);\n}\n\n//From Jessie\nfloat ozonedens (in float h) {\n    float o1 = 25.0 *     exp(( 0.0 - h) /   8.0) * 0.5;\n    float o2 = 30.0 * pow(exp((18.0 - h) /  80.0), h - 18.0);\n    float o3 = 75.0 * pow(exp((25.3 - h) /  35.0), h - 25.3);\n    float o4 = 50.0 * pow(exp((30.0 - h) / 150.0), h - 30.0);\n    return (o1 + o2 + o3 + o4) / 134.628;\n}\n\nvec3 dens2 (float height) {\n    height = max(height, planetrad);\n    float ray = raydens(height);\n    float mie = miedens(height);\n    float ozone = ozonedens((height - planetrad) / 1000.0);\n\n    return vec3(ray, mie, ozone);\n}\n\nvec3 lighttrans (vec3 ro, vec3 rd) {\n    float dist = dot(ro, rd);\n    dist = sqrt(dist * dist + atmorad * atmorad - dot(ro, ro)) - dist;\n    float t = dist / float(odpoints);\n    vec3 step = rd * t;\n    ro += step * 0.5;\n\n    vec3 sum = vec3(0.0);\n    for (int i = 0; i < odpoints; i++, ro += step) {\n        float height = length(ro);\n        sum += dens2(height);\n    }\n    \n    vec3 scattero = vec3(PreethamBetaO_Fit(680.0), PreethamBetaO_Fit(550.0), PreethamBetaO_Fit(440.0)) * 2.5035422e25 * exp(-25e3 / 8e3) * 134.628 / 48.0 * 3e-6 * ozone;\n    #ifndef CUSTOMRAYLEIGH\n    vec3 scatterr = vec3(BetaR(680.0), BetaR(550.0), BetaR(440.0));\n    #endif\n\n    vec3 od = (scatterr * t * sum.x) + (scatterm * t * sum.y) + (scattero * t * sum.z);\n    vec3 trans = exp(-od);\n    if (any(isnan(trans))) trans = vec3(0.0);\n    if (any(isinf(trans))) trans = vec3(1.0);\n\n    return trans;\n}\n\nvec3 march (vec3 ro, vec3 rd, vec3 lrd, float intens, vec3 col) {\n    vec2 atmo = RSI(ro, rd, vec4(vec3(0.0), atmorad));\n    vec2 plan = RSI(ro, rd, vec4(vec3(0.0), atmolowerlim));\n\n    bool atmoi = atmo.y >= 0.0;\n    bool plani = plan.x >= 0.0;\n\n    col *= float(!plani);\n\n    vec2 idk = vec2((plani && plan.x < 0.0) ? plan.y : max(atmo.x, 0.0), (plani && plan.x > 0.0) ? plan.x : atmo.y);\n\n    float t = length(idk.y - idk.x) / float(points);\n    vec3 step = rd * t;\n    vec3 p = rd * idk.x + step * 0.5 + ro;\n\n    float mu = dot(rd, lrd);\n\n    float rayphase = rphase(mu);\n    float miephase = mphase2(mu);\n    \n    vec3 scattero = vec3(PreethamBetaO_Fit(680.0), PreethamBetaO_Fit(550.0), PreethamBetaO_Fit(440.0)) * 2.5035422e25 * exp(-25e3 / 8e3) * 134.628 / 48.0 * 3e-6 * ozone;\n    #ifndef CUSTOMRAYLEIGH\n    vec3 scatterr = vec3(BetaR(680.0), BetaR(550.0), BetaR(440.0));\n    #endif\n\n    vec3 scattering = vec3(0.0);\n    vec3 trans = vec3(1.0);\n    for (int i = 0; i < points; i++, p += step) {\n        vec3 dens = dens2(length(p));\n        if (dens.x > 1e35) break;\n        if (dens.y > 1e35) break;\n        if (dens.z > 1e35) break;\n\n        vec3 mass = t * dens;\n        if (any(isnan(mass))) mass = vec3(0.0);\n\n        vec3 stepod = (scatterr * mass.x) + (scatterm * mass.y) + (scattero * mass.z);\n\n        vec3 steptrans = exp(-stepod);\n        vec3 scatter = trans * (steptrans - 1.0) / -stepod;\n\n        scattering += (scatterr * mass.x * rayphase + scatterm * mass.y * miephase) * scatter * lighttrans(p, lrd);\n        trans *= steptrans;\n    }\n    if (any(isnan(scattering))) return vec3(0.0);\n\n    return scattering * intens + col * trans;\n}\n\nvec3 sky (vec3 ro, vec3 rd, vec3 sunrd, vec3 col) {\n    vec3 sun = dot(rd, sunrd) > cos(radians(sundeg)) ? vec3(sunintens) : col;\n    ro.y += planetrad;\n    return march(ro, rd, sunrd, sunintens, sun);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec4 m = iMouse;\n    m.x = m.x/iResolution.x;\n    m.y = m.y*2.0/iResolution.y;\n    m = m * 2.0 - 1.0;\n    m.x *= iResolution.x/iResolution.y;\n\n    float fov = 90.0;\n\tvec3 ro = vec3(0.0, 10.0, 0.0);\n    float camdist = 1.0 / tan(fov * 0.5 * pi / 180.0);\n    vec3 rt = vec3(uv, camdist) + ro + vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(rt - ro);\n    \n\tvec3 col;\n    \n    vec3 sunrd = normalize(vec3(0.0, cos(iTime * 0.25), sin(iTime * 0.25)));\n    \n    if (iMouse.x > 0.0) {\n        ro *= rotateX(m.y-1.5);\n        ro *= rotateY(m.x);\n        rd *= rotateX(m.y-1.5);\n        rd *= rotateY(m.x);\n    }\n    \n    uint rng = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    \n    vec3 light = sky(ro, rd, sunrd, vec3(0.0));\n    col = light;\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}