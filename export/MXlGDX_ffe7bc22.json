{"ver":"0.1","info":{"id":"MXlGDX","date":"1708016732","viewed":92,"name":"Better Black Hole RayTracer","username":"ShaderGott420","description":"Epic blakhole (horrible code)\nSchwarzschild Metric Christoffel Symbol based geodesic/light ray Marcher\nFully General Relativity Based\nIf someone has an idea as to why the camera is breaking after the black hole/breaking in certain coordinates lmk)","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","blackhole","singularity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Black Hole RayTracer/RayMarcher\" by ShaderGott420. https://shadertoy.com/view/4XsGWj\n// 2024-02-15 13:38:09\n\nvec3 camTarget = vec3(0,0,0); // The point the camera is looking at (the center of the scene)\nvec3 camUp = vec3(0.0, 0.0, 1.0); // \"Up\" direction in world space (usually Y-up)\n\n// Calculate camera\n// Field of view and aspect ratio\nfloat fov = 81.0; // Field of view in degrees\n\nfloat PI = 3.14159265358979323846;\nfloat diskThickness = 0.01; // Thickness of the disk in radians\nfloat equatorialPlane = 3.14159265358979323846 / 2.0; // Equatorial plane angle in radians\nconst float INFINITY = 1.0e20;\nvec3 getPolar(vec3 cartesian) {\n    float r = length(cartesian); // GLSL's length function computes the magnitude of the vector\n    float delta = acos(cartesian.z / r); // GLSL uses .x, .y, .z for vector components\n    float phi = atan(cartesian.y, cartesian.x); // atan(y, x) is used instead of atan2\n\n    return vec3(r, delta, phi);\n}\nfloat calculateDustOpacity(float r, float M) {\n    // As r increases, the opacity should decrease\n    float opacityFactor = smoothstep(2.0*M, 10.0*M, r);\n    return 1.0 - opacityFactor;\n}\n\nvec4 sampleSphericalTexture(vec3 RayDir) {\n    vec3 polarCoords = getPolar(RayDir);\n    float u = polarCoords.z / (2.0 * PI); // Normalize phi to [0, 1]\n    float v = polarCoords.y / PI; // Normalize theta to [0, 1]\n\n    // If the texture is flipped vertically, you may need to flip v\n    v = 1.0 - v;\n\n    return texture(iChannel0, vec2(u, v));\n}\n// Stars texture from Kali\n// https://www.shadertoy.com/view/XlfGRj\n// Very Pretty\n\nvec3 getCartesian(vec3 polar) {\n    float r = polar.x;\n    float delta = polar.y;\n    float phi = polar.z;\n    \n    float x = r * sin(delta) * cos(phi);\n    float y = r * sin(delta) * sin(phi);\n    float z = r * cos(delta);\n    \n    return vec3(x, y, z);\n}\nvec3 rotate90theta(vec3 rotateMe){\n    rotateMe = getPolar(rotateMe);\n    rotateMe.y += PI/2.0;\n    return getCartesian(rotateMe);\n}\nvec3 rotate90phi(vec3 rotateMe){\n    rotateMe = getPolar(rotateMe);\n    rotateMe.z += PI/2.0;\n    return getCartesian(rotateMe);\n}\nvoid assignChristoffelSymbols(vec3 polarCoords, out float trt, out float ttr, out float rrr, out float rtt, out float rphiphi, out float rthetatheta, out float thetartheta, out float thetathetar, out float thetaphiphi, out float phirphi, out float phiphir, out float phithetaphi, out float phiphitheta) {\n    float r = polarCoords.x; // Radial distance\n    float theta = polarCoords.y; // Polar angle\n    float phi = polarCoords.z; // Azimuthal angle (unused in the current symbols but included for completeness)\n\n\n    // Now assign each Christoffel symbol based on r, theta, and predefined M\n    trt = M / (r * (r - 2.0 * M));\n    ttr = M / (r * (r - 2.0 * M));\n    rrr = -M / (r * (r - 2.0 * M));\n    rtt = (M * (r - 2.0 * M)) / pow(r, 3.0);\n    rphiphi = -1.0 * (r - 2.0 * M) * pow(sin(theta), 2.0);\n    rthetatheta = -1.0 * (r - 2.0 * M);\n    thetartheta = 1.0 / r;\n    thetathetar = 1.0 / r;\n    thetaphiphi = -sin(theta) * cos(theta);\n    phirphi = 1.0 / r;\n    phiphir = 1.0 / r;\n    phithetaphi = 1.0 / tan(theta);\n    phiphitheta = 1.0 / tan(theta);\n}\nvec3 updateVelocity(vec3 VE, vec3 P) {\n    float r = P.x;\n    float theta = P.y;\n    float phi = P.z;\n\n    // Variables to hold the Christoffel symbols\n    float trt, ttr, rrr, rtt, rphiphi, rthetatheta, thetartheta, thetathetar, thetaphiphi, phirphi, phiphir, phithetaphi, phiphitheta;\n\n    // Assuming assignChristoffelSymbols is defined to calculate and assign Christoffel symbols\n    assignChristoffelSymbols(P, trt, ttr, rrr, rtt, rphiphi, rthetatheta, thetartheta, thetathetar, thetaphiphi, phirphi, phiphir, phithetaphi, phiphitheta);\n\n    float vr = VE.x;\n    float vtheta = VE.y;\n    float vphi = VE.z;\n\n    float dv_r = -1.0 * rrr * (vr * vr) - rphiphi * (vphi * vphi) - rthetatheta * (vtheta * vtheta);\n    float dv_theta = -1.0 * thetartheta * (vr * vtheta) - thetathetar * (vtheta * vr) - thetaphiphi * (vphi * vphi); \n    float dv_phi = -1.0 * phirphi * (vr * vphi) - phiphir * (vphi * vr) - phithetaphi * (vtheta * vphi) - phiphitheta * (vphi * vtheta); \n\n    vec3 dVE = vec3(dv_r, dv_theta, dv_phi);\n    VE += dVE;\n\n    return VE;\n}\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius)\n{\n    vec3 oc = rayOrigin - sphereCenter;\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0 * dot(oc, rayDirection);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    return discriminant > 0.0;\n}\n\nvec3 sphereCenter = vec3(0.0, 0.0, 0); // Sphere at origin\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat OuterMostRadius = 6.0*M;\n\nfloat sphereRadius = 2.0*M*16.0;\n\nfloat effectiveRadius = 70.0 * M;\nfloat aspectRatio = iResolution.x / iResolution.y;\n\nvec3 camPos = vec3((OriginalDistance-(Speed*iTime))*sin(iTime*camSpeed), 0, (OriginalDistance-(Speed*iTime))*cos(iTime*camSpeed)); // Position of the camera\n\nbool notSingularity = true;\nfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    \n    // Calculate camera basis vectors inside mainImage\n    vec3 camDir = normalize(camTarget - camPos);\n    //vec3 camRight = normalize(rotate90phi(camDir));\n    vec3 camRight = normalize(cross(camDir,camUp));\n    vec3 camUpReal = cross(camDir, camRight);\n    // Calculate FOV in radians for both axes\n    float fovYRad = radians(fov); // Vertical field of view in radians\n    float fovXRad = radians(fov); // Horizontal FOV in radians based on aspect ratio\n    // Calculate field of view in radians\n    float fovRad = tan(radians(fov / 2.0));\n    \n   vec2 ndc = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xy * 2.0;\n    ndc.x *= aspectRatio; // Account for aspect ratio\n\n    // Calculate the ray direction from camera parameters\n   vec3 rayDir = normalize(camDir + (camRight * ndc.x * tan(fovXRad / 2.0)) + (camUpReal * ndc.y * tan(fovYRad / 2.0)));\n\n    // Use this ray direction with the camera's position to cast rays into the scene\n    vec3 rayOrigin = camPos;\n\n    // Use this ray direction with the camera's position to cast rays into the scene\n    vec3 rayMarchedPosition = camPos;\n    float marchDistance = 0.0;\n    rayDir = normalize(rayDir); // Normalize the direction\n    // Sphere definition\n    float dist = length(rayOrigin);\n    float Precision = smoothstep(20.0*M,0.0,dist)*200.0+(smoothstep(OriginalDistance,20.0*M,dist)+1.0)*5.0*M;\n    float k = 900.0*Precision; // Semicolon added here\n    \n    bool hitSphere = intersectSphere(rayOrigin, rayDir, sphereCenter, effectiveRadius-2.0);\n    \n    if(hitSphere){\n    while(length(rayMarchedPosition)>effectiveRadius){\n    \n        rayMarchedPosition += rayDir;\n        \n    }}\n    vec3 rayMarchedVelocity = getPolar(rayMarchedPosition + rayDir/20.0) - getPolar(rayMarchedPosition); // the divisor of rayDir is dependent on a few things\n \n    if(true){\n        //Prolly gon do some polar Transformations.\n            rayMarchedPosition = getPolar(rayMarchedPosition);\n            for(int i = 2; i < int(k); i++) {\n                if(rayMarchedPosition.x <= 2.1*M ){\n                        notSingularity = false;\n                        fragColor = vec4(0.000,0.000,0.000,1.0);\n                        break;\n                }\n                if(dot(getCartesian(rayMarchedPosition+rayMarchedVelocity)-getCartesian(rayMarchedPosition),-getCartesian(rayMarchedPosition))<0.0 && rayMarchedPosition.x > effectiveRadius){\n                        break;\n                }\n\n               if(rayMarchedPosition.x <= OuterMostRadius && abs(rayMarchedPosition.y - equatorialPlane) <= diskThickness){\n                // Calculate opacity based on radial distance\n                 vec3 RMP = rayMarchedPosition;\n                 RMP.x = 1.0-(RMP.x-2.0*M)/(OuterMostRadius*0.8);\n                 RMP.z = (RMP.z/(2.0*PI));\n                 vec4 text = texture(iChannel0, RMP.zx);\n                 if( dot(normalize(text),vec4(0.000,0.000,0.000,1.0)) < 0.95){\n                 fragColor = text; return;}\n                 \n                }\n;\n\n                        rayMarchedVelocity = updateVelocity(rayMarchedVelocity,rayMarchedPosition);\n                        rayMarchedPosition += rayMarchedVelocity;\n            }\n         \n    }\n    if (notSingularity) {\n    rayOrigin = getCartesian(rayMarchedPosition);\n    rayDir = normalize(getCartesian(rayMarchedPosition+rayMarchedVelocity)-getCartesian(rayMarchedPosition));\n    \n   \n    // If the ray does not hit the sphere, check for plane intersections\n    if (notSingularity) {\n        // Since notSingularity is true, render using the cubemap \n        //fragColor = vec4(kali_stars(camPos/length(vec3(OriginalDistance,0,OriginalDistance)),rayDir),1.0);\n          //fragColor = vec4(kali_stars(vec3(iTime/1000.0,0,1),rayDir),1.0);\n          //fragColor = vec4(kali_stars(vec3(0,0,1),rayDir),1.0);\n            fragColor = texture(iChannel1, rayDir);\n\n    } else {\n        // Handle the case when notSingularity is false, e.g., hit the singularity\n        // For example, set to black or any other color indicating singularity\n        fragColor = vec4(0.0);// Example: black color\n    }\n    \n    // Sample the texture based on the plane that was hit\n    \n}\n}\n//Possible future optimizations: Since particles moove on planes, we can theoretically lock them onto a plane, so we save some calculations. Also RK4 might be worth taking a look at, I will also be\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define iterations 11\n#define formuparam 0.53\n#define volsteps 13\n#define stepsize 0.1\n#define zoom   0.800\n#define tile   0.850\n\n#define brightness 0.005\n#define darkmatter 0.100\n#define distfading 0.800\n#define saturation 0.50\nvec3 modified_kali_stars(vec3 from, vec3 dir)\n{\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n    return mix(vec3(length(v)),v,saturation)*.01;\n}\n\n\n\n\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir ) {\n    \n    \n    fragColor = vec4(modified_kali_stars(vec3(0,0,1),rayDir),1.0);\n}","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\n\n// this is from https://www.shadertoy.com/view/4lB3zz\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\n\nfloat tileableNoise(float x, float y) {\n    // Wrap x and y coordinates for tiling\n    float tiledX = mod(x,iResolution.x);\n\n\n    return InterpolationNoise(tiledX, y);\n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.2;\n    float frequency =0.2;\n    float amplitude = 0.3;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.3,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + tileableNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 brightness = vec3(exp(-(1.0 - uv.y)*4.0));\n    float timeFactor = smoothstep(0.0,1.0,1.0-uv.y);// Adjust the values 1.0 and 2.0 as needed\n    // Time varying pixel color\n    float multipleNoise = PerlinNoise2D(uv.x + iTime *0.2, uv.y)*uv.y*8.0 + PerlinNoise2D(uv.x + iTime *0.4, uv.y)*uv.y*4.0 + PerlinNoise2D(uv.x + iTime *0.6, uv.y)*uv.y*2.0;\n    vec3 col = vec3(multipleNoise)*uv.y*2.0;\n    col = mix(col,vec3(0.878,0.427,0.180) ,uv.y*0.99);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define OriginalDistance 300.0\n#define camSpeed  0.05\n#define Speed  5.0\n\n\n\n\n\n\nfloat M = 5.0;","name":"Common","description":"","type":"common"}]}