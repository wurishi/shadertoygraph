{"ver":"0.1","info":{"id":"WdtcRs","date":"1601560430","viewed":141,"name":"infinite cube nightmare","username":"Algorias","description":"A quick intro to how distance fields work for my friends at work.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["livecoding"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPS = 0.01;\nconst float PI = 3.1415;\nvec3 color = vec3(0.3, 0.4, 0.5);\nvec3 glow;\n\nvoid rotate(inout vec2 s,float v) {\n\ts=s*cos(v)+sin(v)*vec2(s.y,-s.x);\n}\n\nvec3 rep(vec3 p, float m) {\n    vec3 c = floor(p/m + 0.5)*m;\n    return p - c;\n}\n\nfloat extrude(float d1, float d2, float m) {\n\treturn min(d1, max(d2, d1-m));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float blend0=clamp(.5+.5*(b-a)/k,0.,1.);\n    return mix( b, a, blend0 )-k*blend0*(1.-blend0);\n}\n\nfloat cube(vec3 p, float b) {\n    vec3 q = abs(p) - b;\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat dist(vec3 p) {\n    float r = 0.04*length(p);\n    \n    rotate(p.xz, iTime + 0.5*sin(iTime) - r);\n    rotate(p.xy, 1.2*iTime -r);\n    p = abs(p) - 5.;\n    float factor = 0.5*sin(10.*r) + 0.4*r;\n    float d = cube(p.xxy, 1.0) +factor;\n    d = min(d, cube(p.xxz, 1.0)+factor);\n    d = min(d, cube(p.zzy, 1.0)+factor);\n    glow = vec3(0.4) + 0.1*sin(3.*p + 4.*iTime);\n    glow *= 1. + 0.4*sin(10.*r - 6.*(floor(iTime) + smoothstep(0., 0.5, fract(iTime))));\n    return min(d, cube(p, 3.0)) + 0.05*sin(dot(p, vec3(10.)));\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = 0.5 * vec2(EPS, 0.);\n    return normalize(vec3(dist(p + e.xyy) - dist(p - e.xyy),\n                          dist(p + e.yxy) - dist(p - e.yxy),\n                          dist(p + e.yyx) - dist(p - e.yyx)));\n}\n\n\nvec3 glowacc;\n\nfloat raymarch(vec3 p, vec3 dir) {\n    glowacc = vec3(0.0);\n    float d = 0.0, t, old_d = 0.0, old_t = 0.0;\n\tfor (int niters=0; niters<100; niters++) {\n        d = dist(p + dir*t);\n        if (d < EPS) break;\n        old_d = d;\n        old_t = t;\n        t += 0.5*d;\n        glowacc += 0.05*glow/pow(d, 0.2);\n    }\n\treturn old_t + (t - old_t)*(old_d - EPS)/(old_d - d);\n}\n\nfloat shade(vec3 p, vec3 ray_dir, vec3 light_pos) {\n    vec3 normal = getNormal(p);\n    vec3 lightdir = normalize(p - light_pos);\n    float ambient=0.25, diffuse=0.5, mat_specular=0.3, mat_hardness=0.0;\n    return ambient\n           + diffuse * max(dot(lightdir, normal), 0.0)\n           + mat_specular * pow(max(dot(lightdir, reflect(ray_dir, normal)), 0.0), mat_hardness);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 pos = (fragCoord * 2. / iResolution.xy -1.)*vec2(16./9., 1.);\n   \n    vec3 p = vec3(3.0, -9.0, 15.0);\n    vec3 camera_target = vec3(0.0);\n    float camera_AoV = 60.0 * 2.*PI/360.0;\n    \n\tvec3 fog_color = vec3(0.0);\n    vec3 light_pos = vec3(-10.0, -10.0, -10.0);\n    \n    // get ray direction\n    vec3 forward = normalize(camera_target - p);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(forward, right));\n    float ratio = 2.*tan(camera_AoV/2.0);\n    vec2 q = pos * ratio;\n    vec3 ray_dir = normalize(q.x * right + q.y * up + forward);\n    \n    // raymarch and light the scene\n    float t = raymarch(p, ray_dir);\n    vec3 ray_end = p + t*ray_dir;\n\n    float fogfactor = clamp(t*t/5000., 0.0, 1.0);\n\n    fragColor.rgb = mix(color * shade(ray_end, ray_dir, light_pos), fog_color, fogfactor);\n\n    if (dist(ray_end) > 2.0*EPS) {\n        fragColor.rgb = fog_color;\n    }\n    \n    fragColor.rgb += glowacc;\n   \t\n}\n","name":"Image","description":"","type":"image"}]}