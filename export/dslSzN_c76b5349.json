{"ver":"0.1","info":{"id":"dslSzN","date":"1668601431","viewed":384,"name":"HeightMapMapping","username":"Mario8664","description":"Heightmap\n1.Parallax mapping (fastest, worst result)\n2.Steep parallax mapping (medium, not bad result)\n3.Parallax occlusion mapping (medium, good result)\n4.Raymarching (slowest, not bad result)\n5.Raymarching with binary search (medium, not bad result)","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","heightmap","parallaxmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DISTANCE 10.0\n#define PI 3.1415926535897932384626\n#define LIGHT vec3(-1.0, 2.0, -1.0)\n#define SUNSIZE 0.01\n#define HEIGHT 0.2\n#define GETHEIGHT(uv) texture(iChannel1, uv)\n\nfloat getPlane(vec3 pos, vec2 planemin, vec2 planemax, float height, vec3 rd)\n{\n    float t = (pos.y - height) / (-rd.y);\n    vec2 xz = pos.xz + rd.xz * t;\n    //if(xz.x < planemin.x || xz.x > planemax.x || xz.y < planemin.y || xz.y > planemax.y)\n    //{\n    //    return -1.0;\n    //}\n    return t;\n}\n\nvec2 rayBox(vec3 pos, vec3 boxmin, vec3 boxmax, vec3 rd)\n{\n\tvec3 t0 = (boxmin - pos) / rd;\n\tvec3 t1 = (boxmax - pos) / rd;\n\tvec3 tmin = min(t0, t1);\n\tvec3 tmax = max(t0, t1);\n\n\tfloat d0 = max(tmin.x, max(tmin.y, tmin.z));\n\tfloat d1 = min(tmax.x, min(tmax.y, tmax.z));\n\n\treturn vec2(d0, d1);\n}\n\n\nfloat getScene(vec3 pos, vec3 rd)\n{\n    //expand the plane a little\n    float d = getPlane(pos, vec2(-1.5), vec2(1.5), 0.0, rd);\n    return d;\n}\n\nvec3 skyBox(vec3 rd)\n{\n    //return texture(iChannel0, rd).xyz;\n    //return ceil(rd * 10.0) / 10.0;    \n    vec3 sky = mix(vec3(1.2), vec3(0.7, 0.8, 1.0), smoothstep(-0.3, 0.7, rd.y));\n    vec3 land = mix(vec3(0.0), vec3(0.2, 0.2, 0.3), smoothstep(-0.9, 0.3, rd.y));\n    vec3 skybox = mix(land, sky, smoothstep(-0.05, 0.1, rd.y));\n    \n    float sun = dot(rd, normalize(LIGHT));\n    sun = (sun - 1.0 + SUNSIZE) / SUNSIZE;\n    sun = clamp(sun, 0.0, 1.0);\n    sun = pow(sun, 5.0);\n    \n    return skybox + sun;\n    return skybox;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 rduv = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n    //Camera\n    vec2 m = texture(iChannel0, vec2(0.375)).xy;//Camera input\n    vec3 target = vec3(0.0, -0.05, 0.0);//Camera view target\n    float theta = m.x * 2.0 * PI;//Input to y-axis angle(0 ~ 2PI)\n    float fai = -(m.y - 0.5) * 0.8  * PI;//Input to local x-axis angle(-0.4Pi ~ 0.4PI)\n\n    //rotation vector(unit vector)\n    vec3 rotation = vec3(cos(theta), sin(fai) ,sin(theta));\n    rotation.xz *= cos(fai);\n    \n    vec4 key = texture(iChannel0, vec2(0.75));\n    float dd = DISTANCE * key.x;\n    vec3 cameraPos = rotation * dd;\n    vec3 cameraForward = normalize(target - rotation);\n    vec3 cameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n    vec3 cameraUp = cross(cameraRight, cameraForward);\n    \n    vec3 ro = cameraPos;\n    vec3 rd = cameraForward * 4.0 + rduv.x * cameraRight + rduv.y * cameraUp;\n    rd = normalize(rd);\n    \n    vec3 pos = ro;\n    vec3 col = skyBox(rd);\n    \n    vec2 box = rayBox(ro, vec3(-1.0, 0.0, -1.0), vec3(1.0, HEIGHT, 1.0), rd);\n    \n    if(box.x < box.y)\n    {\n        float scene = getScene(pos, rd);\n        pos = pos + rd * scene;\n        vec2 uv = (pos.xz + 1.0) * 0.5;\n        vec3 ird = -rd;\n\n        if(key.z <= 0.2)\n        {\n            //parallax mapping\n            float height = GETHEIGHT(uv).r;\n            vec2 offset = ird.xz * clamp(-dot(rd, vec3(0.,1.,0.)), 0.,1.) * height * HEIGHT;\n            vec2 parallaxUV = uv + offset;\n            if(parallaxUV.x >= 0.0 && parallaxUV.y >= 0.0 && parallaxUV.x <= 1.0 && parallaxUV.y <= 1.0)\n                col = GETHEIGHT(parallaxUV).rrr;\n        }\n        else if(key.z <= 0.4)\n        {\n            //steep parallax mapping\n            float layerNum = 32.0;\n            float layerDepth = 1.0 / layerNum;\n\n            vec2 offset = ird.xz * HEIGHT;\n\n            for(float depth = 1.0; depth >= -0.1; depth -= layerDepth)\n            {\n                if(depth < GETHEIGHT(uv + offset * depth).r)\n                {\n                    offset = offset * depth;\n                    break;\n                }\n            }\n\n            vec2 parallaxUV = uv + offset;\n            if(parallaxUV.x >= 0.0 && parallaxUV.y >= 0.0 && parallaxUV.x <= 1.0 && parallaxUV.y <= 1.0)\n                col = GETHEIGHT(parallaxUV).rrr;\n        }\n        else if(key.z <= 0.6)\n        {\n            //parallax occlusion mapping\n            float layerNum = 32.0;\n            float layerDepth = 1.0 / layerNum;\n\n            float lastHeight, lastDepth;\n\n            vec2 offset = ird.xz * HEIGHT;\n\n            for(float depth = 1.0; depth >= -0.1; depth -= layerDepth)\n            {\n                float currentHeight = GETHEIGHT(uv + offset * depth).r;\n                if(depth < currentHeight)\n                {\n                    vec2 lastOffset = offset * lastDepth;\n                    float c = currentHeight - depth;\n                    float l = lastDepth - lastHeight;\n                    float mixValue = c / (c + l);\n                    offset = mix(offset * depth, lastOffset, mixValue);\n                    break;\n                }\n                lastHeight = currentHeight;\n                lastDepth = depth;\n            }\n\n            vec2 parallaxUV = uv + offset;\n            if(parallaxUV.x >= 0.0 && parallaxUV.y >= 0.0 && parallaxUV.x <= 1.0 && parallaxUV.y <= 1.0)\n                col = GETHEIGHT(parallaxUV).rrr;\n        }\n        else if(key.z <= 0.8)\n        {\n            //ray marching\n            const int marchCount = 128;\n            const float end = 1.0 / float(marchCount - 1);\n            float t = box.x;\n            float dt = (box.y - box.x) / float(marchCount - 1);\n            pos = ro + rd * t;\n            for(int i = 0; i < marchCount; i++)\n            {\n                if(pos.x < -1.01 || pos.y < -0.01 || pos.z < -1.01 ||\n                   pos.x > 1.01 || pos.y > HEIGHT + 0.01 || pos.z > 1.01)\n                {\n                    break;\n                }\n                uv = (pos.xz + 1.0) * 0.5;\n                float h = GETHEIGHT(uv).r;\n                float d = pos.y - h * HEIGHT;\n                if(d < end)\n                {\n                    col = vec3(h);\n                    break;\n                }\n                t += dt;\n                pos = ro + rd * t;\n            }\n        }\n        else\n        {\n            //ray marching and binary search(can reduce march count and get better result)\n            const int marchCount = 32;\n            const float end = 1.0 / float(marchCount - 1);\n            const int searchCount = 8;\n            float t = box.x;\n            float dt = (box.y - box.x) / float(marchCount - 1);\n            pos = ro + rd * t;\n            for(int i = 0; i < marchCount; i++)\n            {\n                if(pos.x < -1.01 || pos.y < -0.01 || pos.z < -1.01 ||\n                   pos.x > 1.01 || pos.y > HEIGHT + 0.01 || pos.z > 1.01)\n                {\n                    break;\n                }\n                uv = (pos.xz + 1.0) * 0.5;\n                float h = GETHEIGHT(uv).r * HEIGHT;\n                if(pos.y < h + end)\n                {\n                    //binary search\n                    float tl = max(t - dt, box.x);//last t, y > h\n                    float tr = t;//this t, y < h\n                    for(int j = 0; j < searchCount; j++)\n                    {\n                        t = (tl + tr) * 0.5;\n                        pos = ro + rd * t;\n                        uv = (pos.xz + 1.0) * 0.5;\n                        h = GETHEIGHT(uv).r * HEIGHT;\n                        if(pos.y < h + end)\n                        {\n                            tr = t;\n                        }\n                        else\n                        {\n                            tl = t;\n                        }\n                    }\n                    t = (tl + tr) * 0.5;                            \n                    pos = ro + rd * tr;\n                    uv = (pos.xz + 1.0) * 0.5;\n                    h = GETHEIGHT(uv).r;\n                    col = vec3(h);\n                    break;\n                }\n                t += dt;\n                pos = ro + rd * t;\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor =vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MOUSE_LERP 5.0\n#define MOUSE_STEP 0.5\n#define INIT vec2(0.375, 0.3)\n\n#define INITDISTANCE 0.5\n#define MINDISTANCE 0.2\n#define MAXDISTANCE 0.8\n#define ZOOM_LERP 5.0\n#define ZOOM_STEP 0.005\n\n#define KEY_W 87\n#define KEY_S 83\n\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n#define KEY_4 52","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 i, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 lastil = texture(iChannel0, vec2(0.125));\n    \n    if(uv.x < 0.25)\n    {\n        i = vec4(0.0);\n        vec2 m = i.xy = iMouse.xy / iResolution.xy;\n        if(iMouse.w > 0.5 || iFrame == 0)\n        {\n            lastil.xy = m;\n        }\n        i.xy = m;\n        vec2 offset = (m - lastil.xy) * MOUSE_STEP;\n        i.zw = mix(lastil.zw, offset, MOUSE_LERP * iTimeDelta);\n    }\n    else if(uv.x < 0.5)\n    {\n        if(iFrame == 0)\n        {\n            i = vec4(INIT, 0.0, 0.0);\n        }\n        else\n        {\n            i = texture(iChannel0, vec2(0.375));\n            i.xy += lastil.zw;\n            i.x = fract(i.x);\n            i.y = clamp(i.y, 0.0, 1.0);\n        }\n    }\n    else\n    {\n        if(iFrame == 0)\n        {\n            i = vec4(INITDISTANCE, 0.0, 0.0, 0.5);\n        }\n        else\n        {\n            float wsInput = texelFetch(iChannel1, ivec2(KEY_W,0), 0).r - texelFetch(iChannel1, ivec2(KEY_S,0), 0).r;\n            wsInput = wsInput * 0.5 + 0.5;\n            i = texture(iChannel0, vec2(0.75));\n            i.w = mix(i.w, wsInput, ZOOM_LERP * iTimeDelta);\n            i.x -= (i.w * 2.0 - 1.0) * ZOOM_STEP;\n            i.x = clamp(i.x, MINDISTANCE, MAXDISTANCE);\n            \n            i.z = fract(iTime * 0.2);\n        }\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}