{"ver":"0.1","info":{"id":"fl3SDN","date":"1639089852","viewed":582,"name":"Tracing Quadrics","username":"mrboggieman","description":"Ray tracing quadrics generically, based on the paper ' Ray Tracing Arbitrary Objects on the GPU' by A. Wood et al. Make full screen and enjoy smooth shapes :)","likes":29,"published":3,"flags":0,"usePreview":0,"tags":["quadrics","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray Tracing Quadric shapes (with box constraint)\n// based on the paper: Ray Tracing Arbitrary Objects on the GPU, A. Wood et al\nconst mat4 cylinder = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, -0.25\n);\n\nconst mat4 sphere = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, 4.0, 0.0, 0.0,\n    0.0, 0.0, 4.0, 0.0,\n    0.0, 0.0, 0.0, -1.0\n);\n\nconst mat4 ellipticParaboloid = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, 4.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0\n);\n\nconst mat4 hyperbolicParaboloid = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, -4.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 1.0,\n    0.0, 0.0, 1.0, 0.0\n);\n\nconst mat4 circularCone = mat4(\n    4.0, 0.0, 0.0, 0.0,\n    0.0, -4.0, 0.0, 0.0,\n    0.0, 0.0, 4.0, 0.0,\n    0.0, 0.0, 0.0, 0.0\n);\n\nconst mat4 quadraticPlane = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 1.0, 0.0, 0.0\n);\n\nconst mat4 hyperbolicPlane = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 2.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 2.0, 0.0, 0.0\n);\n\nconst mat4 intersectingPlanes = mat4(\n    0.0, 1.0, 0.0, 0.0,\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0,\n    0.0, 0.0, 0.0, 0.0\n);\n\nconst float EPSILON = 0.000001;\n\nconst int samples = 4; //per x,y per fragment\n\nbool getPointAtTime(in float t, in vec4 ro, in vec4 rd, out vec3 point) {\n    if (t < 0.0) {\n        return false;\n    }\n\n    point = ro.xyz + t * rd.xyz;\n    \n    //constrain to a box\n    return all(greaterThanEqual(point, vec3(-0.5 - EPSILON))) && all(lessThanEqual(point, vec3(0.5 + EPSILON)));\n}\n\n//adapted from https://iquilezles.org/articles/intersectors\nbool intersectBox(in vec4 ro, in vec4 rd, out vec4 outPos)\n{\n    vec3 m = 1.0/rd.xyz;\n    vec3 n = m*ro.xyz;\n    vec3 k = abs(m);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return false; // no intersection\n    outPos = ro + rd * tN;\n    return true;\n}\n\nbool intersectQuadric(in mat4 shape, in vec4 ro, in vec4 rd, out vec3 point) {\n    vec4 rda = shape * rd;\n    vec4 roa = shape * ro;\n    \n    //quadratic equation\n    float a = dot(rd, rda);\n    float b = dot(ro, rda) + dot(rd, roa);\n    float c = dot(ro, roa);\n    \n    if (abs(a) < EPSILON) {\n        if (abs(b) < EPSILON) {\n            return getPointAtTime(c, ro, rd, point);\n        }\n        \n        return getPointAtTime(-c/b, ro, rd, point);\n    }\n\n    float square = b*b - 4.0*a*c;\n\n    if (square < EPSILON) {\n        return false; //no hit\n    }\n\n    float temp = sqrt(square);\n    float denom = 2.0 * a;\n\n    float t1 = (-b - temp) / denom;\n    float t2 = (-b + temp) / denom;\n    \n    //draw both sides but pick the closest point\n    vec3 p1 = vec3(0.0);\n    vec3 p2 = vec3(0.0);\n\n    bool hasP1 = getPointAtTime(t1, ro, rd, p1);\n    bool hasP2 = getPointAtTime(t2, ro, rd, p2);\n    \n    if (!hasP1) {\n        point = p2;\n        return hasP2;\n    }\n    \n    if (!hasP2) {\n        point = p1;\n        return true;\n    }\n\n    if (t1 < t2) {\n        point = p1;\n    } else {\n        point = p2;\n    }\n\n    return true;\n}\n\nvec3 drawQuadric(in mat4 shape, in vec4 ro, in vec4 rd) {\n    vec3 collPoint = vec3(0.0);\n    \n    //intersect the bounding box first and use the intersected origin for solving the quadric\n    //idea from mla: https://www.shadertoy.com/view/wdlBR2\n    if (intersectBox(ro, rd, ro) && intersectQuadric(shape, ro, rd, collPoint)) {\n        //some simple fake shading for now\n        return normalize((shape * vec4(collPoint, 1.0)).xyz) / 2.0 + 0.5;\n    } else {\n        //otherwise return black for now\n        return vec3(0.0);\n    }\n}\n\n//utils\nmat4 rotateX(in float rads) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(rads), -sin(rads), 0.0,\n        0.0, sin(rads), cos(rads), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(in float rads) {\n\treturn mat4(\n        cos(rads), 0.0, sin(rads), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(rads), 0.0, cos(rads), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //camera\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec3 rayTarget = vec3((fragCoord/iResolution.xy) * 2.0 - 1.0, 1.0);\n    rayTarget.y /= aspectRatio;\n    vec3 rayPosition = vec3(0.0, 0.0, -10.0);\n    \n    vec2 rayStep = (1.0 / iResolution.xy) / float(samples);\n    \n    //rotate all of the objects\n    float rotAmount = iTime;\n    mat4 rotMatrix = rotateX(rotAmount) * rotateY(rotAmount * 0.5);\n    \n    vec3 result = vec3(0.0);\n    \n    for (int y=0; y<samples; y++) {\n        for (int x=0; x<samples; x++) {\n            vec3 rayDir = normalize(rayTarget + vec3(rayStep * vec2(x, y), 0.0) - rayPosition);\n            vec4 newDir = vec4(rayDir, 0.0) * rotMatrix;\n\n            //quadrics\n            vec3 pixel = vec3(0.0);\n\n            pixel += drawQuadric(cylinder, vec4(rayPosition - vec3(-3.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(sphere, vec4(rayPosition - vec3(-1.5, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(ellipticParaboloid, vec4(rayPosition - vec3(0.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(hyperbolicParaboloid, vec4(rayPosition - vec3(1.5, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(circularCone, vec4(rayPosition - vec3(3.0, 1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(quadraticPlane, vec4(rayPosition - vec3(-2.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(hyperbolicPlane, vec4(rayPosition - vec3(0.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n            pixel += drawQuadric(intersectingPlanes, vec4(rayPosition - vec3(2.0, -1.0, 30.0), 1.0) * rotMatrix, newDir);\n        \n            result += clamp(pixel, 0.0, 1.0);\n        }\n    }\n    \n    fragColor = vec4(result / float(samples * samples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}