{"ver":"0.1","info":{"id":"XdtfzX","date":"1581099702","viewed":6873,"name":"vt220 coding at night edition","username":"sprash3","description":"Using original vt220 font (https://vt100.net/dec/vt220/glyphs).\nUse mouse to adjust screen curvature and position.\nThe implementation of full vt100 terminal emulation in GLSL is left as an exercise for the reader.","likes":143,"published":1,"flags":32,"usePreview":1,"tags":["2d","retro","screen","crt","font","terminal","multipass","curved"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define LIGHTS_ON true\n//#define LIGHTS_ON false\n#define LIGHTS_ON sin(fract(iTime/23.)+2.74) + 0.05*abs(sin(iTime*1000.)) <.0\n\n#define WIDTH 0.48\n#define HEIGHT 0.3\n#define CURVE 3.0\n#define SMOOTH 0.004\n#define SHINE 0.66\n\n#define BEZEL_COL vec4(0.8, 0.8, 0.6, 0.0)\n\n#define REFLECTION_BLUR_ITERATIONS 5\n#define REFLECTION_BLUR_SIZE 0.04\n\nprecision highp float;\n\nvec2 CurvedSurface(vec2 uv, float r)\n{\n    return r * uv/sqrt(r * r - dot(uv, uv));\n}\n\nvec2 crtCurve(vec2 uv, float r, bool content, bool shine)\n{\n    r = CURVE * r;\n    if (iMouse.z > 0.) r *= exp(0.5 - iMouse.y/iResolution.y);\n    uv = (uv / iResolution.xy - 0.5) / vec2(iResolution.y/iResolution.x, 1.) * 2.0;\n\tuv = CurvedSurface(uv, r);\n\tif(content) uv *= 0.5 / vec2(WIDTH, HEIGHT);\n    uv = (uv / 2.0) + 0.5;        \n   \tif(!shine) if (iMouse.z > 0.) uv.x -= iMouse.x/iResolution.x - 0.5;\n    \n\treturn uv;    \n}\n\nfloat roundSquare(vec2 p, vec2 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\n// standard roundSquare\nfloat stdRS(vec2 uv, float r)\n{\n    return roundSquare(uv - 0.5, vec2(WIDTH, HEIGHT) + r, 0.05);\n}\n\n// Calculate normal to distance function and move along\n// normal with distance to get point of reflection\nvec2 borderReflect(vec2 p, float r)\n{\n    float eps = 0.0001;\n    vec2 epsx = vec2(eps,0.0);\n    vec2 epsy = vec2(0.0,eps);\n    vec2 b = (1.+vec2(r,r))* 0.5;\n    r /= 3.0;\n    \n    p -= 0.5;\n    vec2 normal = vec2(roundSquare(p-epsx,b,r)-roundSquare(p+epsx,b,r),\n                       roundSquare(p-epsy,b,r)-roundSquare(p+epsy,b,r))/eps;\n    float d = roundSquare(p, b, r);\n    p += 0.5;\n    return p + d*normal;\n}\n\nvoid mainImage(out vec4 c, in vec2 fragCoord)\n{    \n \n    c = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec2 uvC = crtCurve(fragCoord, 1., true, false); \t// Content Layer\n    vec2 uvS = crtCurve(fragCoord, 1., false, false);\t// Screen Layer\n    vec2 uvE = crtCurve(fragCoord, 1.25, false, false);\t// Enclosure Layer\n    \n    if (LIGHTS_ON) {\n        // From my shader https://www.shadertoy.com/view/MtBXW3\n        \n        const float ambient = 0.33;\n\n        // Glass Shine \n        vec2 uvSh = crtCurve(fragCoord, 1., false, true);\n    \tc += max(0.0, SHINE - distance(uvSh, vec2(0.5, 1.0))) *\n            smoothstep(SMOOTH/2.0, -SMOOTH/2.0, stdRS(uvS + vec2(0., 0.03), 0.0));\n\n\t    // Ambient\n\t    c += max(0.0, ambient - 0.5*distance(uvS, vec2(0.5,0.5))) *\n\t        smoothstep(SMOOTH, -SMOOTH, stdRS(uvS, 0.0));\n\n\t    // Enclosure Layer \n        uvSh = crtCurve(fragCoord, 1.25, false, true);\n    \tvec4 b = vec4(0., 0., 0., 0.);\n    \tfor(int i=0; i<12; i++)\n\t\t\tb += (clamp(BEZEL_COL + rand(uvSh+float(i))*0.05-0.025, 0., 1.) +\n\t\t\t\trand(uvE+1.0+float(i))*0.25 * cos((uvSh.x-0.5)*3.1415*1.5))/12.;\n        \n        // Inner Border\n        const float HHW = 0.5 * HEIGHT/WIDTH;\n        \n    \tc += b/3.*( 1. + smoothstep(HHW - 0.025, HHW + 0.025, abs(atan(uvS.x-0.5, uvS.y-0.5))/3.1415) \n       \t\t+ smoothstep(HHW + 0.025, HHW - 0.025, abs(atan(uvS.x-0.5, 0.5-uvS.y))/3.1415) )* \n\t\t\tsmoothstep(-SMOOTH, SMOOTH, stdRS(uvS, 0.0)) * \n\t\t\tsmoothstep(SMOOTH, -SMOOTH, stdRS(uvE, 0.05));\n    \n\t\t// Inner Border Shine\n  \t\tc += (b - 0.4)* \n\t\t\tsmoothstep(-SMOOTH*2.0, SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.505), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n\t\t\tsmoothstep(SMOOTH*2.0, -SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.495), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n        \n    \t// Outer Border\n    \tc += b * \n\t\t\tsmoothstep(-SMOOTH, SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n\t\t\tsmoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.15, 0.05)); \n\n    \t// Outer Border Shine\n\t\tc += (b - 0.4)* \n\t\t\tsmoothstep(-SMOOTH*2.0, SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.495), vec2(WIDTH, HEIGHT) + 0.15, 0.05)) * \n\t\t\tsmoothstep(SMOOTH*2.0, -SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.505), vec2(WIDTH, HEIGHT) + 0.15, 0.05));\n        \n        // Table and room\n        c += max(0. , (1. - 2.0* fragCoord.y/iResolution.y)) * vec4(1, 1, 1, 0.) *\n            smoothstep(-0.25, 0.25, roundSquare(uvC - vec2(0.5, -0.2), vec2(WIDTH+0.25, HEIGHT-0.15), .1)) *\n            smoothstep(-SMOOTH*2.0, SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.15, 0.05));\n        \n    } else {\n        // From my shader https://www.shadertoy.com/view/lt2SDK\n        \n        const float ambient = 0.2;\n\n        // Ambient\n\t    c += max(0.0, ambient - 0.3*distance(uvS, vec2(0.5,0.5))) *\n\t        smoothstep(SMOOTH, -SMOOTH, stdRS(uvS, 0.0));\n        \n\t    // Inner Border               \n\t  \tc += BEZEL_COL * ambient * 0.7 *\n\t        smoothstep(-SMOOTH, SMOOTH, stdRS(uvS, 0.0)) * \n\t        smoothstep(SMOOTH, -SMOOTH, stdRS(uvE, 0.05));\n    \n\t    // Corner\n\t  \tc -= (BEZEL_COL )* \n\t        smoothstep(-SMOOTH*2.0, SMOOTH*10.0, stdRS(uvE, 0.05)) * \n\t        smoothstep(SMOOTH*2.0, -SMOOTH*2.0, stdRS(uvE, 0.05));\n\n\t    // Outer Border\n\t    c += BEZEL_COL * ambient *\n\t       \tsmoothstep(-SMOOTH, SMOOTH, stdRS(uvE, 0.05)) * \n\t        smoothstep(SMOOTH, -SMOOTH, stdRS(uvE, 0.15)); \n    \n\t    // Inner Border Reflection\n\t    for(int i = 0; i < REFLECTION_BLUR_ITERATIONS; i++)\n\t    {\n\t    \tvec2 uvR = borderReflect(uvC + (vec2(rand(uvC+float(i)), rand(uvC+float(i)+0.1))-0.5)*REFLECTION_BLUR_SIZE, 0.05);\n\t    \tc += (PHOSPHOR_COL - BEZEL_COL*ambient) * texture(iChannel0, uvR) / float(REFLECTION_BLUR_ITERATIONS) * \n\t\t        smoothstep(-SMOOTH, SMOOTH, stdRS(uvS, 0.0)) * \n\t\t\t\tsmoothstep(SMOOTH, -SMOOTH, stdRS(uvE, 0.05));\n\t    }\n    \n\t    // Bloom using composed MipMaps\n\t    c += (textureLod(iChannel0, uvC, 3.) + \n              textureLod(iChannel0, uvC, 4.) + \n              textureLod(iChannel0, uvC, 5.))\n            * smoothstep(0., -SMOOTH*20., stdRS(uvS, -0.02)) * 0.5;\n    }\n\n    if (uvC.x > 0. && uvC.x < 1. && uvC.y > 0. && uvC.y < 1.)\n    \tc += texture(iChannel0, uvC);\n} ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define FONT_SIZE vec2(10.,20.)\n#define ROWCOLS vec2(80., 24.)\n\n// Some Plasma stolen from dogeshibu for testing\nfloat somePlasma(vec2 uv)\n{\n    uv /= iResolution.xy;\n    uv *= ROWCOLS; // 80 by 24 characters\n    uv = ceil(uv);\n    uv /= ROWCOLS;\n    \n    float color = 0.0;\n    color += 0.7*sin(0.5*uv.x + iTime/5.0);\n    color += 3.0*sin(1.6*uv.y + iTime/5.0);\n    color += 1.0*sin(10.0*(uv.y * sin(iTime/2.0) + uv.x * cos(iTime/5.0)) + iTime/2.0);\n    float cx = uv.x + 0.5*sin(iTime/2.0);\n    float cy = uv.y + 0.5*cos(iTime/4.0);\n    color += 0.4*sin(sqrt(100.0*cx*cx + 100.0*cy*cy + 1.0) + iTime);\n    color += 0.9*sin(sqrt(75.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += -1.4*sin(sqrt(256.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += 0.3 * sin(0.5*uv.y + uv.x + sin(iTime));\n    return 17.0*(0.5+0.499*sin(color))*(0.7+sin(iTime)*0.3);\n}\n\nfloat textLines(vec2 uvG)\n{\n    float wt = 5. * (iTime + 0.5*sin(iTime*1.4) + 0.2*sin(iTime*2.9)); // wobbly time\n    vec2 uvGt = uvG + vec2(0., floor(wt));\n    float ll = rand(vec2(uvGt.y, - 1.)) * ROWCOLS.x; // line length\n    \n    if (uvG.y > ROWCOLS.y - 2.){\n        if (ceil(uvG.x) == floor(min(ll, fract(wt)*ROWCOLS.x)))\n        \treturn 2.;\n        if (ceil(uvG.x) > floor(min(ll, fract(wt)*ROWCOLS.x)))\n        \treturn 0.;\n    }\n    if (uvGt.x > 5. && rand(uvGt) < .075)\n        return 0.;\n    if (max(5., uvGt.x) > ll)\n        return 0.;\n       \n    return rand(uvGt)*15. + 2.;\n}\n\n// Font Rendering\n// From my shader https://www.shadertoy.com/view/llSXDV\n// Can be done much better in the future...\n#define l(y,a,b) roundLine(p, vec2(float(a), float(y)), vec2(float(b), float(y)))\nfloat roundLine(vec2 p, vec2 a, vec2 b) \n{\n\tb -= a + vec2(1.0,0.);\n\tp -= a;\n    float f = length(p-clamp(dot(p,b)/dot(b,b),0.0,1.0)*b);\n\tif (iResolution.y < 320.) // attempt to get rid of aliasing on small resolution\n\t\treturn smoothstep(1.0, 0.9, f);    \n    else if (iResolution.y < 720.)\n\t\treturn smoothstep(0.75, 0.5, f);    \n\telse\n\t\treturn smoothstep(1., 0., f);    \n}\n\nfloat vt220Font(vec2 p, float c)\n{\n    if (c < 1.) return 0.;\n    if(p.y > 16.){\n        if(c > 2.) return 0.0;\n\t\tif(c > 1.) return l(17,1,9);\n    }\n    if(p.y > 14.){\n\t\tif(c > 16.) return l(15,3,8);\n\t\tif(c > 15.) return l(15,1,8);\n\t\tif(c > 14.) return l(15,1,3)+ l(15,7,9);\n\t\tif(c > 13.) return l(15,2,8);\n\t\tif(c > 12.) return l(15,1,9);\n\t\tif(c > 11.) return l(15,2,8);\n\t\tif(c > 10.) return l(15,1,3)+ l(15,6,8);\n\t\tif(c > 9.) return l(15,4,6);\n        if(c > 8.) return l(15,2,4)+ l(15,5,7);\n\t\tif(c > 7.) return l(15,2,8);\n\t\tif(c > 6.) return l(15,2,8);\n\t\tif(c > 5.) return l(15,2,8);\n\t\tif(c > 4.) return l(15,2,9);\n\t\tif(c > 3.) return l(15,1,8);\n\t\tif(c > 2.) return l(15,2,9);\n    }\n    if(p.y > 12.){\n\t\tif(c > 16.) return l(13,2,4)+ l(13,7,9);\n\t\tif(c > 15.) return l(13,2,4)+ l(13,7,9);\n\t\tif(c > 14.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 13.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 12.) return l(13,1,3);\n\t\tif(c > 11.) return l(13,4,6);\n\t\tif(c > 10.) return l(13,2,4)+ l(13,5,9);\n\t\tif(c > 9.) return l(13,2,8);\n\t\tif(c > 8.) return l(13,2,4)+ l(13,5,7);\n\t\tif(c > 7.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 6.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 5.) return l(13,1,3)+ l(13,7,9);\n\t\tif(c > 4.) return l(13,1,3)+ l(15,2,9);\n\t\tif(c > 3.) return l(13,1,4)+ l(13,7,9);\n\t\tif(c > 2.) return l(13,1,3)+ l(13,6,9);\n    }\n    if(p.y > 10.){\n\t\tif(c > 16.) return l(11,1,3);\n\t\tif(c > 15.) return l(11,2,4)+ l(11,7,9);\n\t\tif(c > 14.) return l(11,1,9);\n\t\tif(c > 13.) return l(11,7,9);\n\t\tif(c > 12.) return l(11,2,5);\n\t\tif(c > 11.) return l(11,4,6);\n\t\tif(c > 10.) return l(11,3,5)+ l(11,6,8);\n\t\tif(c > 9.) return l(11,4,6)+ l(11,7,9);\n\t\tif(c > 8.) return l(11,1,8);\n\t\tif(c > 7.) return l(11,1,3)+ l(11,7,9);\n\t\tif(c > 6.) return l(11,1,3)+ l(11,7,9);\n\t\tif(c > 5.) return l(11,1,3)+ l(11,7,9);\n\t\tif(c > 4.) return l(11,1,3);\n\t\tif(c > 3.) return l(11,1,3)+ l(11,7,9);\n\t\tif(c > 2.) return l(11,2,9);\n    }\n    if(p.y > 8.){\n\t\tif(c > 16.) return l(9,1,3);\n\t\tif(c > 15.) return l(9,2,8);\n\t\tif(c > 14.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 13.) return l(9,4,8);\n\t\tif(c > 12.) return l(9,4,8);\n\t\tif(c > 11.) return l(9,4,6);\n\t\tif(c > 10.) return l(9,4,6);\n\t\tif(c > 9.) return l(9,2,8);\n\t\tif(c > 8.) return l(9,2,4)+ l(9,5,7);\n\t\tif(c > 7.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 6.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 5.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 4.) return l(9,1,3)+ l(9,7,9);\n\t\tif(c > 3.) return l(9,1,4)+ l(9,7,9);\n\t\tif(c > 2.) return l(9,7,9);\n    }\n    if(p.y > 6.){\n\t\tif(c > 16.) return l(7,1,3);\n\t\tif(c > 15.) return l(7,2,4)+ l(7,7,9);\n\t\tif(c > 14.) return l(7,2,4)+ l(7,6,8);\n\t\tif(c > 13.) return l(7,5,7);\n\t\tif(c > 12.) return l(7,7,9);\n\t\tif(c > 11.) return l(7,2,6);\n\t\tif(c > 10.) return l(7,2,4)+ l(7,5,7);\n\t\tif(c > 9.) return l(7,1,3)+ l(7,4,6);\n\t\tif(c > 8.) return l(7,1,8);\n\t\tif(c > 7.) return l(7,2,8);\n\t\tif(c > 6.) return l(7,2,8);\n\t\tif(c > 5.) return l(7,2,8);\n\t\tif(c > 4.) return l(7,2,8);\n\t\tif(c > 3.) return l(7,1,8);\n\t\tif(c > 2.) return l(7,2,8);\n    }\n    if(p.y > 4.){\n\t\tif(c > 16.) return l(5,2,4)+ l(5,7,9);\n\t\tif(c > 15.) return l(5,2,4)+ l(5,7,9);\n\t\tif(c > 14.) return l(5,3,7);\n\t\tif(c > 13.) return l(5,6,8);\n\t\tif(c > 12.) return l(5,1,3)+ l(5,7,9);\n\t\tif(c > 11.) return l(5,3,6);\n\t\tif(c > 10.) return l(5,1,5)+ l(5,6,8);\n\t\tif(c > 9.) return l(5,2,8);\n\t\tif(c > 8.) return l(5,2,4)+ l(5,5,7);\n\t\tif(c > 7.) return 0.;\n\t\tif(c > 6.) return 0.;\n\t\tif(c > 5.) return 0.;\n\t\tif(c > 4.) return 0.;\n\t\tif(c > 3.) return l(5,1,3);\n\t\tif(c > 2.) return 0.;\n    }\n    if(p.y > 2.){\n\t\tif(c > 16.) return l(3,3,8);\n\t\tif(c > 15.) return l(3,1,8);\n\t\tif(c > 14.) return l(3,4,6);\n\t\tif(c > 13.) return l(3,1,9);\n\t\tif(c > 12.) return l(3,2,8);\n\t\tif(c > 11.) return l(3,4,6);\n\t\tif(c > 10.) return l(3,2,4)+ l(3,7,9);\n\t\tif(c > 9.) return l(3,4,6);\n\t\tif(c > 8.) return l(3,2,4)+ l(3,5,7);\n\t\tif(c > 7.) return l(3,2,4)+ l(3,6,8);\n\t\tif(c > 6.) return l(3,1,3)+ l(3,4,7);\n\t\tif(c > 5.) return l(3,2,4)+ l(3,6,8);\n\t\tif(c > 4.) return 0.;\n\t\tif(c > 3.) return l(3,1,3);\n\t\tif(c > 2.) return 0.;\n    }\n    else{\n\t\tif(c > 7.) return 0.;\n\t\tif(c > 6.) return l(1,2,5)+ l(1,6,8);\n    }\n    return 0.0;      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float val = 0.;\n    \n   \tvec2 uv = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n   \tvec2 uvT = vec2(80, 24) * FONT_SIZE * uv / iResolution.xy;\n   \tvec2 uvG = floor(ROWCOLS * uv / iResolution.xy);\n    \n    // Switch between 3 \"programs\"\n    float prog = sin(iTime*0.5);\n    if(prog < -0.1)\n    \tval = somePlasma(fragCoord.xy);\n    else if(prog < 0.1)\n    \tval = rand(uvG * iTime) * 17.;\n    else\n    \tval = textLines(uvG);\n\tfragColor = vt220Font(uvT - uvG * FONT_SIZE, val) * PHOSPHOR_COL;\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PHOSPHOR_COL vec4(0.2, 1.0, 0.2, 0.)\n\nprecision highp float;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n","name":"Common","description":"","type":"common"}]}