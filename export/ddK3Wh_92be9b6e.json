{"ver":"0.1","info":{"id":"ddK3Wh","date":"1678482945","viewed":105,"name":"Edge of Chaos 2D","username":"gunthern","description":"Edge of Chaos concept from https://math.hws.edu/eck/js/edge-of-chaos/CA-info.html in 2D (1D)\n\nChanging randomSeed, numStates, and dropChance in common tab will yield different results","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["generative","organic","compute","growth","cca"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void getFade(out float fade, out int iter) {\n\n    iter = iFrame / (duration + fadeDuration);\n    \n    fade = 1.0 - (float(max((iFrame - (duration+fadeDuration)*iter) - duration, 0)) / float(fadeDuration));\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * zoom + vec2((1.0 - zoom) * 0.5, 0.0);\n    \n    // Fade amount and iteration\n    float fade;\n    int iter;\n    getFade(fade, iter);\n\n    // Color from buffer\n    vec4 col = texture(iChannel0, uv);\n    \n    // Bloom from https://www.shadertoy.com/view/lsXGWn\n    vec4 bloom = vec4(0.0);\n    float blurSize = 1.0 / 512.0;\n    bloom += texture(iChannel0, vec2(uv.x - 4.0*blurSize, uv.y)) * 0.05;\n    bloom += texture(iChannel0, vec2(uv.x - 3.0*blurSize, uv.y)) * 0.09;\n    bloom += texture(iChannel0, vec2(uv.x - 2.0*blurSize, uv.y)) * 0.12;\n    bloom += texture(iChannel0, vec2(uv.x - blurSize, uv.y)) * 0.15;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y)) * 0.16;\n    bloom += texture(iChannel0, vec2(uv.x + blurSize, uv.y)) * 0.15;\n    bloom += texture(iChannel0, vec2(uv.x + 2.0*blurSize, uv.y)) * 0.12;\n    bloom += texture(iChannel0, vec2(uv.x + 3.0*blurSize, uv.y)) * 0.09;\n    bloom += texture(iChannel0, vec2(uv.x + 4.0*blurSize, uv.y)) * 0.05;\n\n    bloom += texture(iChannel0, vec2(uv.x, uv.y - 4.0*blurSize)) * 0.05;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y - 3.0*blurSize)) * 0.09;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y - 2.0*blurSize)) * 0.12;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y - blurSize)) * 0.15;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y)) * 0.16;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y + blurSize)) * 0.15;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y + 2.0*blurSize)) * 0.12;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y + 3.0*blurSize)) * 0.09;\n    bloom += texture(iChannel0, vec2(uv.x, uv.y + 4.0*blurSize)) * 0.05;\n        \n\n    // Output to screen\n    fragColor = (col + bloom*0.4) * fade;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void init(inout vec4 fragColor, in vec2 fragCoord, in vec2 iResolution, in int iter) {\n\n   fragColor = vec4(0.0);\n   \n   if (int(fragCoord.y) == 0\n       && int(fragCoord.x - iResolution.x/2.0) < initRow/2\n       && int(fragCoord.x - iResolution.x/2.0) > -initRow/2\n       ) {\n       \n       float state = random(vec2(fragCoord.x * (float(iter) + 2.0)));\n   \n       fragColor = vec4(state, 1.0, 1.0, 1.0);\n   \n   }\n\n}\n\nvoid update(inout vec4 fragColor, in vec2 fragCoord, in vec4 previousTex, in int iter) {\n\n    fragColor = previousTex;\n    \n    if (int(fragCoord.y) == (iFrame % (duration + fadeDuration)) / speed) {\n    \n        float left = texelFetch(iChannel0, ivec2(max(fragCoord.x-1.0, 0.0), fragCoord.y-1.0), 0).r * float(numStates-1);\n        float center = texelFetch(iChannel0, ivec2(fragCoord.x, fragCoord.y-1.0), 0).r * float(numStates-1);\n        float right = texelFetch(iChannel0, ivec2(min(fragCoord.x+1.0, iResolution.x+1.0), fragCoord.y-1.0), 0).r * float(numStates-1);\n        \n        float state = left + (center*2.0) + (right*3.0);\n        \n        float nextState = texelFetch(iChannel1, ivec2(state, 0.0), 0).r;\n\n        fragColor = vec4(nextState, float((duration + fadeDuration) * (iter+1) - iFrame - fadeDuration) / float(duration + fadeDuration), 1.0, 1.0);\n    \n    }\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    // Iteration\n    int iter = iFrame / (duration + fadeDuration);\n\n    //if (int(fragCoord.y) < iter) discard;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Current texture\n    vec4 previousTex = texture(iChannel0, uv);\n   \n    fragColor = previousTex;\n    \n    bool stopCondition = false;\n    \n    if (iFrame == 0 || iFrame % (duration + fadeDuration) == 0) {\n        \n        init(fragColor, fragCoord, iResolution.xy, iter);\n        \n        stopCondition = true;\n    \n    }\n    \n    if (iFrame % speed == 0 && !stopCondition) {\n    \n        update(fragColor, fragCoord, previousTex, iter);\n    \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define fps 60\n#define randomSeed 36.18\n#define numStates 6\n#define dropChance 0.8\n#define initRow 70\n#define speed int(1.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n#define duration int(200.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n#define fadeDuration int(30.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n#define zoom 0.25\n\n// Random function from the Book of Shaders - returns random value between 0 and 1\nfloat random (in vec2 uv) {\n    \n    return fract(sin(dot(uv.xy, vec2(12.98,78.23))) * randomSeed);\n    \n}\n\n// Random colors\nvec3 color(in float p, in int iter) {\n    \n    float ti = float(iter) * random(vec2(p+1.0));\n    \n    float r = random(vec2(p+ti, p+ti+1.0));\n    float g = random(vec2(p+ti+2.0, p+ti+3.0));\n    float b = random(vec2(p+ti+4.0, p+ti+5.0));\n    \n    vec3 col = vec3(r,g,b);\n    return col;\n    \n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Rules\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    if (int(fragCoord.y) > 0 || int(fragCoord.x) > numStates * numStates * numStates) discard;\n    \n    // Iteration\n    int iter = iFrame / (duration + fadeDuration);\n    \n    fragColor = vec4(max(random(vec2(fragCoord.x * (float(iter) - dropChance))) - 0.3, 0.0));\n    \n    if (int(fragCoord.x) == 0) fragColor = vec4(0.0);\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Iter\n    int iter = iFrame / (duration + fadeDuration);\n\n    // Color from buffer\n    vec3 state = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb;\n    vec4 col = vec4(color(state.r, iter) * state.g, 0.0);\n   \n    if (state.r == 0.0) col = vec4(0.0);\n        \n    // Output to screen\n    fragColor = col;\n    \n}","name":"Buffer C","description":"","type":"buffer"}]}