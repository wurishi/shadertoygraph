{"ver":"0.1","info":{"id":"l32cRt","date":"1727611447","viewed":14,"name":"Chessboard N - rectangles","username":"cesio","description":"Chessboard with N rectangles ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rectangles","rotating","chessboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n#define DEG2RAD(d) (d * PI / 180)\n#define N 4.\n#define N_MAX 96.\n#define INC (N_MAX / N)\n#define SPEED 3.\n#define SIZE 0.3\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 cartesianToPolar(vec2 cartesian) {\n    float r = length(cartesian);          \n    float theta = atan(cartesian.y, cartesian.x); \n    return vec2(theta,r);  \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sc = fragCoord.xy / iResolution.xy;\n    sc = 2. * sc - 1.;\n    \n    vec2 polarUV = cartesianToPolar(sc);\n    polarUV.x = polarUV.x / PI;\n    polarUV.y =  SIZE  / polarUV.y;\n    \n    // multiply by sqrt of radius to make \"farther\" parts of the tunnel (in the center of the window) darker\n    vec4 darknessFactor = vec4(sqrt(1. - (polarUV.y)));// - correctedTime)));\n    \n    vec3 color = vec3(0.0);\n    \n    sc = rotate2d( sin(iTime)*PI / SPEED) * sc;\n    //float time = fract(iTime);\n    // size (x,y) of a single fragment if we have N fragments\n   // float timeOffset = 0.;//0.1;\n    float singleFragSize = 1. / (N + sin(iTime)*INC);\n    \n    // in which fragment the current pixel is\n    float fragX = ceil(sc.x  / singleFragSize) - 1. ;\n    float fragY = ceil(sc.y  / singleFragSize) - 1.;\n    \n   // vec2 fragIndex = vec2(frag, frasc / (singleFragSize + fract(iTime));// * sin(iTime);\n    //float pos = sin(radians((sc.x) * 360.0)) * 0.09 + 0.5;\n    \n    if (mod(fragX + fragY , 2.) == 0.) {\n        color = vec3(1.0, sin(iTime), 0.);\n        \n        if (mod(fragX, 3.) == 0.) {\n            color = vec3(abs(sin(iTime)));\n        }\n    } else {\n        color.r = sin(iTime) * darknessFactor.x;\n    }\n    \n    \n    \n\tfragColor = vec4(color,1.0);\n}\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sc = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    float time = fract(iTime);\n    float pos = sin(radians((sc.x) * 360.0)) * 0.05 + 0.5;\n    \n    if (sc.y >= pos) {\n        color = vec3(1.0);\n    } else {\n        color.r = 1.0;\n    }\n    \n    // another IF that does the same\n    \n\n\tfragColor = vec4(color,1.0);\n}\n\n*/","name":"Image","description":"","type":"image"}]}