{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":3,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Optimised version of \"Fast closest point (2 pass)\" https://www.shadertoy.com/view/lftfDX\n// The main difference is that more sampling is done per frame to lower the number of frames required\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(floor(fragCoord));\n\n    // show the geometry map instead of the distance map\n    if (texelFetch(iChannel2, ivec2(50, 2), 0).r >= 1.0) {\n        fragColor = texelFetch(iChannel1, coord, 0);\n        return; \n    }\n    \n    // show the acculated distance map as it is being created (flash warning)\n    vec4 last_value;\n\n    if (texelFetch(iChannel2, ivec2(51, 2), 0).r >= 1.0) {\n        last_value = texelFetch(iChannel3, coord, 0);\n    } else {\n        last_value = texelFetch(iChannel0, coord, 0);\n    }\n\n    // show the closest pixel from the coord in all directions for now\n    ivec2 last_top_right = unpack_2d_pos(last_value.r);\n    ivec2 last_bottom_right = unpack_2d_pos(last_value.g);\n    ivec2 last_bottom_left = unpack_2d_pos(last_value.b);\n    ivec2 last_top_left = unpack_2d_pos(last_value.a);\n    \n    //float scale = max(iResolution.x, iResolution.y);\n    float scale = 80.0; //brighter so we can visualise more easily\n    \n    if (texelFetch(iChannel2, ivec2(52, 2), 0).r >= 1.0) {\n        vec4 cmyk = vec4(\n            clamp(dist(last_top_right) / scale, 0.0, 1.0),\n            clamp(dist(last_bottom_right) / scale, 0.0, 1.0),\n            clamp(dist(last_bottom_left) / scale, 0.0, 1.0),\n            clamp(dist(last_top_left) / scale, 0.0, 1.0)\n        );\n\n        fragColor = vec4(\n            (1.0 - cmyk.xyz) * (1.0 - cmyk.w),\n            1.0\n        );\n        return;\n    }\n    \n    // get the min distance from the quadrant directional closest points\n    float closest_dist = min(min(min(\n        dist(last_top_right) / scale, \n        dist(last_bottom_right) / scale),\n        dist(last_bottom_left) / scale),\n        dist(last_top_left) / scale);\n    \n    fragColor = vec4(vec3(clamp(closest_dist, 0.0, 1.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// this buffer contains the geometry that can interacted with\nconst float THRESHOLD = 0.6;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // start with the opening scene\n    uint frame = uint(iFrame);\n\n    if (frame == uint(0)) {\n        float height = float(texture(iChannel0, fragCoord / iResolution.xy).r > THRESHOLD);\n\n        fragColor = vec4(vec3(height), 1.0);\n        return;\n    }\n    \n    // if the mouse is pressed then add a blob to the scene\n    if (iMouse.z > 0.0) {\n        if (distance(fragCoord.xy, iMouse.xy) < 10.0) {\n            // if the keyboard key is down then create geometry instead\n            float col = 0.0;\n            \n            if (texelFetch(iChannel2, ivec2(49, 2), 0).r < 1.0) {\n                col = 1.0;\n            }\n            \n            fragColor = vec4(vec3(col), 1.0);\n            return;\n        }\n    }\n\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"// settings - common throughout all buffers\nstruct Settings {\n    uint resolution;\n    uint num_samples;\n    uint num_frames;\n    uint total_frames;\n    uint max_value;\n};\n\nSettings get_settings(vec2 res) {\n    // the target width/height to cover\n    uint resolution = uint(ceil(max(res.x, res.y)));\n    \n    // the number of samples to take for each direction per frame\n    // optimal as a base of 2\n    uint num_samples = uint(4); // 4 = 16 samples per frame, halves the number of frames needed\n    \n    // frames needed per pass\n    uint num_frames = uint(ceil(log(float(resolution)) / log(float(num_samples))));\n    \n    // total frames needed before the map can be used\n    uint total_frames = num_frames * uint(2);\n    \n    // the maximum value to use as the default distance for no-hits\n    uint max_value = uint(ceil(sqrt(float(resolution * resolution) * 2.0)));\n\n    return Settings(\n        resolution,\n        num_samples,\n        num_frames,\n        total_frames,\n        max_value\n    );\n}\n\n\n// util functions\n\n// some methods to package a 2 16-bit int into a single 32-bit float\nfloat pack_2d_pos(in ivec2 pos) {\n    return uintBitsToFloat(packSnorm2x16(vec2(pos) / 32767.0));\n}\n\nivec2 unpack_2d_pos(in float col) {\n    return ivec2(unpackSnorm2x16(floatBitsToUint(col)) * 32767.0);\n}\n\nfloat dist(in ivec2 a) {\n    return length(vec2(a));\n    //return sqrt(float((a.x * a.x) + (a.y * a.y)));\n}\n","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// this buffer computes the closest point in each x/y direction for every pixel\n// it does this by checking neighbours in a binary-tree like manner\n// it takes a number of frames to render before it is finished (settings.num_frames)\n// then it computes the closest point for each quadrant again in a binary-tree manner\n\nbool hit_scene(in ivec2 coord) {\n    return texelFetch(iChannel0, coord, 0).r > 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 coord = ivec2(floor(fragCoord));\n    ivec2 res = ivec2(iResolution.xy);\n    Settings settings = get_settings(iResolution.xy);\n    uint frame = uint(iFrame) % settings.total_frames;\n    \n    // check collision with the scene for the first frame\n    if (frame == uint(0)) {\n        //sample this pixel first and just return if we get a result\n        if (hit_scene(coord)) {\n            fragColor = vec4(uintBitsToFloat(uint(0)));\n            return;\n        }\n        \n        // otherwise branch out in each direction linearly\n        // split the sampling of each direction so we can break early in each direction\n        \n        // top\n        uint closest_top = settings.max_value;\n        uint max_top_offset = min(settings.num_samples, uint(res.y - coord.y));\n        for (uint offset=uint(1); offset<max_top_offset; offset++) {\n            if (hit_scene(coord + ivec2(0, offset))) {\n                closest_top = offset;\n                break;\n            }\n        }\n\n        // right\n        uint closest_right = settings.max_value;\n        uint max_right_offset = min(settings.num_samples, uint(res.x - coord.x));\n        for (uint offset=uint(1); offset<max_right_offset; offset++) {\n            if (hit_scene(coord + ivec2(offset, 0))) {\n                closest_right = offset;\n                break;\n            }\n        }\n\n        // bottom\n        uint closest_bottom = settings.max_value;\n        uint max_bottom_offset = min(settings.num_samples, uint(coord.y));\n        for (uint offset=uint(1); offset<max_bottom_offset; offset++) {\n            if (hit_scene(coord + ivec2(0, -offset))) {\n                closest_bottom = offset;\n                break;\n            }\n        }\n\n        // left\n        uint closest_left = settings.max_value;\n        uint max_left_offset = min(settings.num_samples, uint(coord.x));\n        for (uint offset=uint(1); offset<max_left_offset; offset++) {\n            if (hit_scene(coord + ivec2(-offset, 0))) {\n                closest_left = offset;\n                break;\n            }\n        }\n\n        fragColor = vec4(\n            uintBitsToFloat(closest_top),\n            uintBitsToFloat(closest_right),\n            uintBitsToFloat(closest_bottom),\n            uintBitsToFloat(closest_left)\n        );\n\n        return;\n    }\n    \n    if (frame < settings.num_frames) {\n        // jump in a binary manner over multiple frames to find the closest distance for the entire resolution\n        vec4 last_value = texelFetch(iChannel1, coord, 0);\n        uint step_amount = uint(pow(float(settings.num_samples), float(frame)));\n        \n        uint step_max_offset = settings.num_samples * step_amount;\n\n        // top\n        uint last_top = floatBitsToUint(last_value.r);\n\n        if (last_top > step_amount) {\n            uint max_offset = min(step_max_offset, uint(iResolution.y) - uint(coord.y));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 top_neighbour = texelFetch(iChannel1, coord + ivec2(0, offset), 0);\n                uint closest_top = floatBitsToUint(top_neighbour.r) + offset;\n\n                if (closest_top < last_top) {\n                    last_top = closest_top;\n                    break;\n                }\n            }\n        }\n\n        // right\n        uint last_right = floatBitsToUint(last_value.g);\n\n        if (last_right > step_amount) {\n            uint max_offset = min(step_max_offset, uint(iResolution.x) - uint(coord.x));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 right_neighbour = texelFetch(iChannel1, coord + ivec2(offset, 0), 0);\n                uint closest_right = floatBitsToUint(right_neighbour.g) + offset;\n\n                if (closest_right < last_right) {\n                    last_right = closest_right;\n                    break;\n                }\n            }\n        }\n\n        // bottom\n        uint last_bottom = floatBitsToUint(last_value.b);\n\n        if (last_bottom > step_amount) {\n            uint max_offset = min(step_max_offset, uint(coord.y));\n        \n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 bottom_neighbour = texelFetch(iChannel1, coord + ivec2(0, -offset), 0);\n                uint closest_bottom = floatBitsToUint(bottom_neighbour.b) + offset;\n\n                if (closest_bottom < last_bottom) {\n                    last_bottom = closest_bottom;\n                    break;\n                }\n            }\n        }\n\n        // left\n        uint last_left = floatBitsToUint(last_value.a);\n\n        if (last_left > step_amount) {\n            uint max_offset = min(step_max_offset, uint(coord.x));\n\n            for (uint offset=step_amount; offset<max_offset; offset+=step_amount) {\n                vec4 left_neighbour = texelFetch(iChannel1, coord + ivec2(-offset, 0), 0);\n                uint closest_left = floatBitsToUint(left_neighbour.a) + offset;\n\n                if (closest_left < last_left) {\n                    last_left = closest_left;\n                    break;\n                }\n            }\n        }\n\n        // store the accumulated closest point\n        fragColor = vec4(\n            uintBitsToFloat(last_top),\n            uintBitsToFloat(last_right),\n            uintBitsToFloat(last_bottom),\n            uintBitsToFloat(last_left)\n        );\n        \n        return;\n    }\n\n    // once complete, compute the quadrant closest points using the distances computed\n    frame -= settings.num_frames;\n\n    if (frame == uint(0)) {\n        vec4 distances = texelFetch(iChannel1, coord, 0);\n        uint top_dist = floatBitsToUint(distances.r);\n        uint right_dist = floatBitsToUint(distances.g);\n        uint bottom_dist = floatBitsToUint(distances.b);\n        uint left_dist = floatBitsToUint(distances.a);\n        \n        // top right\n        ivec2 closest_top_right;\n        float closest_top_right_dist;\n        if (top_dist < right_dist) {\n            closest_top_right = ivec2(0, int(top_dist));\n            closest_top_right_dist = float(top_dist);\n        } else {\n            closest_top_right = ivec2(int(right_dist), 0);\n            closest_top_right_dist = float(right_dist);\n        }\n        \n        int max_top_right_offset = min(res.y - coord.y, min(res.x - coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_top_right_offset; offset++) {\n            ivec2 cell_offset = ivec2(offset, offset);\n            \n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n            \n            ivec2 closest_top = ivec2(0, int(floatBitsToUint(next_cells.r))) + cell_offset;\n            float closest_top_distance = dist(closest_top);\n\n            if (closest_top_distance < closest_top_right_dist) {\n                closest_top_right = closest_top;\n                closest_top_right_dist = closest_top_distance;\n            }\n\n            ivec2 closest_right = ivec2(int(floatBitsToUint(next_cells.g)), 0) + cell_offset;\n            float closest_right_distance = dist(closest_right);\n\n            if (closest_right_distance < closest_top_right_dist) {\n                closest_top_right = closest_right;\n                closest_top_right_dist = closest_right_distance;\n            }\n        }\n        \n        // bottom right\n        ivec2 closest_bottom_right;\n        float closest_bottom_right_dist;\n        if (bottom_dist < right_dist) {\n            closest_bottom_right = ivec2(0, -int(bottom_dist));\n            closest_bottom_right_dist = float(bottom_dist);\n        } else {\n            closest_bottom_right = ivec2(int(right_dist), 0);\n            closest_bottom_right_dist = float(right_dist);\n        }\n        \n        int max_bottom_right_offset = min(coord.y, min(res.x - coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_bottom_right_offset; offset++) {\n            ivec2 cell_offset = ivec2(offset, -offset);\n            \n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_bottom = ivec2(0, -int(floatBitsToUint(next_cells.b))) + cell_offset;\n            float closest_bottom_distance = dist(closest_bottom);\n\n            if (closest_bottom_distance < closest_bottom_right_dist) {\n                closest_bottom_right = closest_bottom;\n                closest_bottom_right_dist = closest_bottom_distance;\n            }\n\n            ivec2 closest_right = ivec2(int(floatBitsToUint(next_cells.g)), 0) + cell_offset;\n            float closest_right_distance = dist(closest_right);\n\n            if (closest_right_distance < closest_bottom_right_dist) {\n                closest_bottom_right = closest_right;\n                closest_bottom_right_dist = closest_right_distance;\n            }\n        }\n        \n        // bottom left\n        ivec2 closest_bottom_left;\n        float closest_bottom_left_dist;\n        if (bottom_dist < left_dist) {\n            closest_bottom_left = ivec2(0, -int(bottom_dist));\n            closest_bottom_left_dist = float(bottom_dist);\n        } else {\n            closest_bottom_left = ivec2(-int(left_dist), 0);\n            closest_bottom_left_dist = float(left_dist);\n        }\n        \n        int max_bottom_left_offset = min(coord.y, min(coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_bottom_left_offset; offset++) {\n            ivec2 cell_offset = ivec2(-offset);\n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_bottom = ivec2(0, -int(floatBitsToUint(next_cells.b))) + cell_offset;\n            float closest_bottom_distance = dist(closest_bottom);\n\n            if (closest_bottom_distance < closest_bottom_left_dist) {\n                closest_bottom_left = closest_bottom;\n                closest_bottom_left_dist = closest_bottom_distance;\n            }\n\n            ivec2 closest_left = ivec2(-int(floatBitsToUint(next_cells.a)), 0) + cell_offset;\n            float closest_left_distance = dist(closest_left);\n\n            if (closest_left_distance < closest_bottom_left_dist) {\n                closest_bottom_left = closest_left;\n                closest_bottom_left_dist = closest_left_distance;\n            }\n        }\n        \n        // top left\n        ivec2 closest_top_left;\n        float closest_top_left_dist;\n        if (top_dist < left_dist) {\n            closest_top_left = ivec2(0, int(top_dist));\n            closest_top_left_dist = float(top_dist);\n        } else {\n            closest_top_left = ivec2(-int(left_dist), 0);\n            closest_top_left_dist = float(left_dist);\n        }\n        \n        int max_top_left_offset = min(res.y - coord.y, min(coord.x, int(settings.num_samples)));\n        for (int offset=1; offset<max_top_left_offset; offset++) {\n            ivec2 cell_offset = ivec2(-offset, offset);\n            vec4 next_cells = texelFetch(iChannel1, coord + cell_offset, 0);\n\n            ivec2 closest_top = ivec2(0, int(floatBitsToUint(next_cells.r))) + cell_offset;\n            float closest_top_distance = dist(closest_top);\n\n            if (closest_top_distance < closest_top_left_dist) {\n                closest_top_left = closest_top;\n                closest_top_left_dist = closest_top_distance;\n            }\n\n            ivec2 closest_left = ivec2(-int(floatBitsToUint(next_cells.a)), 0) + cell_offset;\n            float closest_left_distance = dist(closest_left);\n\n            if (closest_left_distance < closest_top_left_dist) {\n                closest_top_left = closest_left;\n                closest_top_left_dist = closest_left_distance;\n            }\n        }\n\n        fragColor = vec4(\n            pack_2d_pos(closest_top_right),\n            pack_2d_pos(closest_bottom_right),\n            pack_2d_pos(closest_bottom_left),\n            pack_2d_pos(closest_top_left)\n        );\n\n        return;\n    }\n    \n    // for later frames we lookup the diagonal closest points and compare them to the existing closest point\n    int step_amount = int(pow(float(settings.num_samples), float(frame)));\n    int max_offset = step_amount * int(settings.num_samples);\n\n    vec4 last_closest = texelFetch(iChannel1, coord, 0);\n    \n    // top right\n    ivec2 last_top_right = unpack_2d_pos(last_closest.r);\n    float top_right_dist = dist(last_top_right);\n    int max_top_right_offset = min(min(res.y - coord.y, res.x - coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_top_right_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(1);\n        ivec2 test_top_right = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).r) + offset;\n        float test_top_right_dist = dist(test_top_right);\n\n        if (test_top_right_dist < top_right_dist) {\n            last_top_right = test_top_right;\n            top_right_dist = test_top_right_dist;\n        }\n    }\n    \n    // bottom right\n    ivec2 last_bottom_right = unpack_2d_pos(last_closest.g);\n    float bottom_right_dist = dist(last_bottom_right);\n    int max_bottom_right_offset = min(min(coord.y, res.x - coord.x), max_offset);\n    \n    for (int sample_index = step_amount; sample_index < max_bottom_right_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(1, -1);\n        ivec2 test_bottom_right = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).g) + offset;\n        float test_bottom_right_dist = dist(test_bottom_right);\n\n        if (test_bottom_right_dist < bottom_right_dist) {\n            last_bottom_right = test_bottom_right;\n            bottom_right_dist = test_bottom_right_dist;\n        }\n    }\n    \n    // bottom left\n    ivec2 last_bottom_left = unpack_2d_pos(last_closest.b);\n    float bottom_left_dist = dist(last_bottom_left);\n    int max_bottom_left_offset = min(min(coord.y, coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_bottom_left_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(-1);\n        ivec2 test_bottom_left = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).b) + offset;\n        float test_bottom_left_dist = dist(test_bottom_left);\n\n        if (test_bottom_left_dist < bottom_left_dist) {\n            last_bottom_left = test_bottom_left;\n            bottom_left_dist = test_bottom_left_dist;\n        }\n    }\n    \n    // top left\n    ivec2 last_top_left = unpack_2d_pos(last_closest.a);\n    float top_left_dist = dist(last_top_left);\n    int max_top_left_offset = min(min(res.y - coord.y, coord.x), max_offset);\n\n    for (int sample_index = step_amount; sample_index < max_top_left_offset; sample_index+=step_amount) {\n        ivec2 offset = sample_index * ivec2(-1, 1);\n        ivec2 test_top_left = unpack_2d_pos(texelFetch(iChannel1, coord + offset, 0).a) + offset;\n        float test_top_left_dist = dist(test_top_left);\n\n        if (test_top_left_dist < top_left_dist) {\n            last_top_left = test_top_left;\n            top_left_dist = test_top_left_dist;\n        }\n    }\n\n    // store the accumulated closest point\n    fragColor = vec4(\n        pack_2d_pos(last_top_right),\n        pack_2d_pos(last_bottom_right),\n        pack_2d_pos(last_bottom_left),\n        pack_2d_pos(last_top_left)\n    );\n}\n","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// this buffer renders buffer B when it is complete, keeping the result in the buffer until the next pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(floor(fragCoord));\n    Settings settings = get_settings(iResolution.xy);\n    uint frame = uint(iFrame);\n    \n    if (frame == uint(0)) {\n        fragColor = vec4(pack_2d_pos(ivec2(0)));\n        return;\n    }\n     \n    // the last frame should contain what we want to render\n    if ((frame % settings.total_frames) == (settings.total_frames - uint(1))) {\n        fragColor = texelFetch(iChannel0, coord, 0);\n        return;\n    }\n    \n    fragColor = texelFetch(iChannel1, coord, 0);\n}\n","name":"Buffer C","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XcVBzh","date":"1735172159","viewed":46,"name":"Faster closest point (2 pass)","username":"mrboggieman","description":"A 'closest point' map for every pixel in each directional quadrant. Use for accelerating ray tracing in a grid and creating Voronoi. Draw with mouse.\nKeys:\n  '1' - add/remove geometry\n  '2' - geometry map\n  '3' - acc map (flash warning)\n  '4' - split dir","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["trace","closest"],"hasliked":0,"parentid":"","parentname":""}}