{"ver":"0.1","info":{"id":"tdlBz7","date":"1587961449","viewed":248,"name":"Hilbert curve sort","username":"rory618","description":"Sort 16k arbitrarily placed particles by z order and draw the path connecting them. See line one common to use Hilbert curve or Z order.\nSpace to toggle sorting data view.\ndevblogs.nvidia.com/thinking-parallel-part-iii-tree-construction-gpu","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["particles","sort","jfa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"getters}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    \n    if( texture( iChannel3, vec2(32.5/256.0,0.75) ).x > 0.5){\n        //Show the sorting\n        vec3 rayDir;\n        if(iMouse.z>0.){\n            float size = 1024./R.x/2.;\n            I += iMouse.xy*4.;\n            ivec3 XYFace = ivec3(I.y*size, mod(I.x*size,1024.),I.x*size/1024.);\n            rayDir = XYFaceToRayDir(XYFace);\n            if(XYFace.x > 1024)\n                rayDir=vec3(0);\n        } else {\n            float size = max(1024./R.y,(105.*16.)/R.x);\n            ivec3 XYFace = ivec3(I.y*size, mod(I.x*size,1024.),I.x*size/1024.);\n            rayDir = XYFaceToRayDir(XYFace);\n        }\n\n        if(rayDir==vec3(0)){\n            O = vec4(0);\n        } else {\n            O = texture(iChannel0, rayDir);\n        }\n    } else {\n        int index = int(texture(iChannel1, I/R.xy).z);\n        vec2 p  = sampleIndexStage(index,109).xy;\n        vec2 pp = sampleIndexStage(index+1,109).xy;\n        vec2 pn = sampleIndexStage(index-1,109).xy;\n        float d =  dLine(I,p*R.xy,pp*R.xy);\n        d = min(d, dLine(I,p*R.xy,pn*R.xy));\n        O = vec4(d/2.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"getters}\n\n//Generate random particles each frame, and use a pipelined bitonic sorting network to arrange them in a list\n//so that they are in ascending order along a z curve covering uv space, saving the xy coordinate at each step.\n\n//Get the partner to be compared with for a bitonic sort at a given stage\n//See https://en.wikipedia.org/wiki/Bitonic_sorter#Alternative_representation\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    float bot = floor(float(x)/b)*b;\t\t\t\t//Bottom index in block \n    float top = bot + b - 1.;\t\t\t\t\t\t//Top index in block\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return int(top - (float(x)-bot) + 0.5);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        if(float(x)-bot < b/2.-0.5){\n            return int(float(x) + b/2. + 0.5);\n        }else{\n            return int(float(x) - b/2. + 0.5);\n        }\n    }\n}\n\n\n\nvoid mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n    ivec2 XYTall = ivec2(XYFace.x, XYFace.y + 1024*XYFace.z);\n    if(XYTall.y < 16){\n    \t//Fetch new paericles from buf A\n        O.xy = texture(iChannel1, (.5+vec2(XYTall.x/8, XYTall.y + 16*(XYTall.x%8)))/iChannelResolution[1].xy).zw;\n    } else  {\n        int stage = XYTall.y/16;\n        int sortStage = stage - 1;\n        int index = XYTall.x*16 + (XYTall.y%16);\n        if(stage<106){\n        \t//Execute the sorting network swaps\n            int partner = getPartner(index,sortStage);\n            vec4 A = sampleIndexStage(index, stage-1);\n            vec4 B = sampleIndexStage(partner, stage-1);\n            int zA = Order(A.xy);\n            int zB = Order(B.xy);\n            if(index > partner){\n                if(zA>zB){\n                    O=A;\n                } else {\n                    O=B;\n                }\n            } else {\n                if(zA>zB){\n                    O=B;\n                } else {\n                    O=A;\n                }\n            }\n        } else if(stage<110){\n            //Keep shifting the result down so that JFA pipeline always can find the particles\n            O = sampleIndexStage(index, stage-1);\n        }\n        \n    }\n    \n    \n}\n    \n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define HILBERT\n#define R iResolution\n\n\n\n\n\n//Line segment sdf\nfloat dLine(vec2 p, vec2 a, vec2 b){\n    p-=a;\n    b-=a;\n    float l2 = dot(b,b);\n    p -= b*clamp(dot(p,b/l2),0.,1.);\n    return length(p);\n}\n\n\n//Magic to convert a binary number 0xbbbb into 0x0b0b0b0b\nint spreadBits(int word){\n    word = (word ^ (word << 8 )) & 0x00ff00ff;\n    word = (word ^ (word << 4 )) & 0x0f0f0f0f;\n    word = (word ^ (word << 2 )) & 0x33333333;\n    word = (word ^ (word << 1 )) & 0x55555555;\n    return word;\n}\n\n//Convert a 0-1 xy coordinate to a 20 bit morton/z order code\nint ZOrder(vec2 coord){\n    int x = int(coord.x*1024.);\n    int y = int(coord.y*1024.);\n    return spreadBits(x) | (spreadBits(y)<<1);\n}\n\n//Thanks Wunkolo for some hilbert curve code\nint HOrder( vec2 p )\n{   \n    uvec2 Position = uvec2(p *1024.);\n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = 1024U/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(1024U - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return int(Index);\n}\nint Order(vec2 p){\n    #ifdef HILBERT\n    \treturn HOrder(p);\n    #else\n    \treturn ZOrder(p);\n    #endif\n}\n    \n//Random number functions\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n                                                                                \n#define JFALoop(input, jump, cIn, cOut, stage) {\\\n    float d = 1e3;                       \\\n    for(int k = 0; k < 9; k++ ) {        \\\n        int index = int(texture(input, (I+jump*vec2(k%3-1,k/3-1))/R.xy)[cIn]); \\\n        checkCandidate(index,stage,d,O[cOut],I); \\\n    }\\\n}       \n//Cubemap utils to convert between a 1024 x 1024 x 6 buffer coordinate to a cubemap ray direction\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512.0, -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n\n//Functions to sample a particle coordinate from the cubemap as a 1024 x 6144 buffer and a 16384 x 384 buffer\n#define getters \\\nvec4 sampleXYTall(ivec2 XYTall){\\\n    ivec3 XYFace = ivec3(XYTall.x, XYTall.y%1024, XYTall.y/1024);\\\n\treturn texture(iChannel0, XYFaceToRayDir(XYFace));\\\n}\\\nvec4 sampleIndexStage(int index, int stage){\\\n    ivec2 XYTall = ivec2(index/16, index%16+stage*16);\\\n    return sampleXYTall(XYTall);\n\n\n//JFA checking function\n#define JCF \\\nvoid checkCandidate(int index, int stage, inout float d, inout float o, vec2 I){\\\n    vec2 p = sampleIndexStage(index,stage).xy;\\\n    vec2 pp = sampleIndexStage(index+1,stage).xy;\\\n    vec2 pn = sampleIndexStage(index-1,stage).xy;\\\n    float nd =   dLine(I,p*R.xy,pp*R.xy);\\\n    nd = min(nd, dLine(I,p*R.xy,pn*R.xy));\\\n    if(nd<d){\\\n        d = nd;\\\n        o = float(index);\\\n    }\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"getters}\n\n\n//Search the sorted list to find the list index of a particle with the nearest z order to the target\nint binarySearch(int target){\n    int stage = 106;\n    int N = 1024*16;\n    int jump = N/4;\n    int guess = N/2;\n    for(int i = 0; i < 16; i++){\n        vec4 p = sampleIndexStage(guess, stage);\n        int z = Order(p.xy);\n        if(target==z){\n            return guess;\n        } else if(target>z){\n            guess+=jump;\n            jump=max(1,jump/2);\n        } else {\n            guess-=jump;\n            jump=max(1,jump/2);\n        }\n    }\n    return guess;\n    \n}\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    O.x=float(binarySearch(Order(I/R.xy))); \n    \n    //Spawn new particles with Britney's edges (for performance, dont do this in cubemap)\n    if(I.x<128. && I.y<128.){\n    float best = 0.;\n        for(int i = 0; i < 16; i++){\n            int seed = i + int(I.x)*8 + int(I.y)*8*2000 + iFrame*8*2000*2000;\n            seed = IHash(seed);\n            vec2 coord = rand2(seed);\n            float score = 1.+length(textureLod(iChannel3, coord,0.)-textureLod(iChannel3, coord,1.));\n            if(score > best){\n                best = score;\n                O.zw = coord;\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"getters}\nJCF}\n    \n//Do a pipelined JFA to draw the lines between the particles\n//Select 9 candidates and save the list index of an endpoint of the closest edge at each stage\n//Pipelined JFA order:\n//(A.x -> B.x -> C.x -> D.x) -> (B.y -> C.y -> D.y) -> (B.z -> C.z -> D.z)\n//Parenthesis means operations execute on the same frame, \n    \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    \n    JFALoop(iChannel1, 256., 0, 0, 106);//Stage 0\n    JFALoop(iChannel2, 32., 0, 1, 107);//Stage 3\n    JFALoop(iChannel2, 4., 1, 2, 108);//Stage 6\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"getters}\nJCF}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    JFALoop(iChannel1, 128., 0, 0, 106);//Stage 1\n    JFALoop(iChannel1, 16., 1, 1, 107);//Stage 4\n    JFALoop(iChannel1, 2., 2, 2, 108);//Stage 7\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"getters}\nJCF}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    JFALoop(iChannel1, 64., 0, 0, 106);//Stage 2\n    JFALoop(iChannel1, 8., 1, 1, 107);//Stage 5\n    JFALoop(iChannel1, 1., 2, 2, 108);//Stage 8\n}","name":"Buffer D","description":"","type":"buffer"}]}