{"ver":"0.1","info":{"id":"3s2yRW","date":"1586200560","viewed":133,"name":"Light in the Darkness  V. 3","username":"julianlumia","description":":octopusballoon:\nexperimenting with more realistic lightning and reflections","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Light in the Darkness  V. 2\" by julianlumia. https://shadertoy.com/view/WdjyRW\n// 2020-04-06 19:13:02\n\n\n\n#define T(uv) texture(iChannel0,uv)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n\n    \n    float f = length(uv  - 0.5);\n    fragColor.x = T(uv + f*0.002).x;\n    fragColor.y = T(uv -f*0.002).y;\n    fragColor.z = T(uv-f*0.002).z;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define MAX_STEPS 64\n#define MAX_DIST 50.\n#define SURF_DIST .001\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\n\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nconst float PI = 3.14159265;\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nvec3 spherepos;\nvec2 GetDist(vec3 p) {\n vec2 d;\n d = vec2(p.y +5.3,3);\n vec3 size3 = vec3(3.5,5.,3.5);\n vec3 pos = vec3(0,0.,.0);\n vec3 p4 = p;\n    p4 -=vec3(-1.,4.,.0);\n float the = iTime *.5;\n p4.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n     the = iTime *.2;\n p4.yz *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 box10 = vec2((sdOctahedron(p4, 1.5)),3.);\n spherepos = vec3(-1.0,-0.5,-0);\n float box9 = (sdSphere(p-spherepos, .3));\n vec2 box;\n        vec3 p2 = p+1.;\n p2.x= (abs(p2.x)+.5);\n for(int i=0; i<3; i++)\n {\n   \n  vec3 size = (vec3(size3)/ (float(i)+1.));\n      \n\n     p2= (abs(p2)-.3);  \n\n     p2.x = (abs(p2.x)-size.x/2.)-.0;\n      the = 4.;\n      p2.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n float o = (1.);\n the = (iTime*.3);\n      p2.xz *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n     p2 = rotate( normalize( vec3(1.,sin(o), sin(o) )),120.)*p2;\n      \n  box = vec2(sdBox(p2, vec3(.6*size)),3);\n     \n  vec2 box2 = vec2(sdBox(p2, vec3(0.4,.4,1.)*size),1);\n  vec2 box3 = vec2(sdBox(p2, vec3(.4,1.,.4)*size),1);\n  vec2 box4 = vec2(sdBox(p2, vec3(1.,.4,.4)*size),1);\n  box.x = max( box.x,-box2.x);\n  box.x = max(box.x,-box3.x);\n  box.x = max(box.x,-box4.x);\n  d.x = smin(box.x,d.x,.1);\n  if( box.x < d.x)\n  {\n   d = condmin(d,box);\n  }\n }\n g2 +=.08/(.2+pow(abs(box.x),6.));\n g4 +=.1/(.1+pow(abs(box10.x),10.));\n g3 +=.04/(8.+box9*box9);\n //d.x = min(d.x,box9);\n d = condmin(d,box10);\n return d;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=100.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 45; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || (t)>10.) break;\n  t += d * .2;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\nconst float PI2 = 3.14159265359;\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 randomSphereDir(vec2 rnd)\n{\n\tfloat s = rnd.x*PI*2.;\n\tfloat t = rnd.y*2.-1.;\n\treturn vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n\tvec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n\treturn v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n\tconst int nbIte = 32;\n    const float nbIteInv = 1./float(nbIte);\n    const float rad = 1.-1.*nbIteInv; //Hemispherical factor (self occlusion correction)\n    \n\tfloat ao = 0.0;\n    \n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l; // mix direction with the normal\n        \t\t\t\t\t\t\t\t\t\t\t\t\t    // for self occlusion problems!\n        \n        ao += (l - max(GetDist( p + rd ),0.).x) / maxDist * falloff;\n    }\n\t\n    return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n    float d = 1.;\n    float shadow = 1.0;\n    while(d < maxDist)\n    {\n        float t = GetDist(r0 + d * rd).x;\n        if(t < 0.005) return 0.0;\n        d += t;\n        shadow = min(shadow,40.0 * (t / d));\n    }\n    return shadow;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(spherepos);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*1., l).x;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\nvec2 m = iMouse.xy/iResolution.xy;\n\nvec3 eye = 1.0*vec3(0.,4.,6.);\nvec3 col;\nvec2 d;\nvec3 hoek = vec3(0,2.,2.5);  \nfloat   the = (iTime*1.);\nmat3 camera = setCamera( eye, hoek,0.);\nfloat fov = 1.;\nvec3 dir = camera * normalize(vec3(uv, fov));\nvec3 p;\nvec3 n;\nvec3 focalPoint = eye + (dir * 1.);\nvec3 shiftedRayOrigin = eye;\nvec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n d = RayMarch(shiftedRayOrigin, shiftedRay);\nfloat t =d.x *1.;\nvec3  shiftedRayOrigin2 = shiftedRayOrigin;\nvec3  shiftedRay2= shiftedRay;\nif(t<MAX_DIST) {\n shiftedRayOrigin2 += shiftedRay2 * t;\n vec3 sn = GetNormal(shiftedRayOrigin2);\n shiftedRay2 = reflect(shiftedRay2, sn);\n if(d.y==3.) traceRef(shiftedRayOrigin2 +  shiftedRay2*.1, shiftedRay2);\n sn *= GetNormal(shiftedRayOrigin2);   \n if(d.y==3.) col *= sn;\n col += marchCount * vec3(.6, .6,0.4) * 0.005;\n p = shiftedRayOrigin + shiftedRay * t;\n n= GetNormal(p.xyz);\n float a = ambientOcclusion(p,n, 1.5,5.);\n col*= a*1.5;  \n vec3 lp =    spherepos*.9;\n const int numIter = 50;\n vec3 vD = shiftedRay;\n vD = normalize(vD);\n float stepSize = length(p - shiftedRayOrigin) / float(numIter);\n vec3 vO = shiftedRayOrigin + stepSize * vD;\n float accum = 0.0;\n for(int i = 0; i  < numIter; ++i)\n  {\n\tvec3 ld = normalize(lp - vO);\n\tfloat shad = shadow(vO, ld, 3.0);\n\tfloat d = dot(vO, vO);\n\taccum += (.05 / d ) * shad;\n\tvO += stepSize * vD;\n   }\n  vec3   color= vec3(.3, 0.4, .5);\n  col += g3 * color;\n  col *= accum * color * 12.;\n  float dif = GetLight(p);\n  col *= vec3(dif)+4.;\n  vec3 sky = vec3(0., 0., 0.);\n  col *= mix(sky, col, 4./(t*t/1./1.*.05+1.0));    \n  col +=g2*vec3(0.02)*vec3(.2,.2,.3)*.4;    \n  col +=g4*vec3(0.02)*vec3(1.,0.3,0.5)*.5;    \n }\n col*=1.;\n col=smoothstep(0.0,8.,col);\n col=pow(col, vec3(0.4545));\n fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}