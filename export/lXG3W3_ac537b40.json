{"ver":"0.1","info":{"id":"lXG3W3","date":"1718299659","viewed":34,"name":" funny face ","username":"nnew","description":"st","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["luckyface"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PI2 PI * 2.0\n\nfloat time;\n   \nmat2 rotate(float a)\n{\nreturn mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return vec3( .5, 0.5, 0.5 );\n}\n   \nvec2 fold(in vec2 p, in float s)\n{\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;    \n}\n\nfloat prism(in vec3 p)\n{\np.xy = fold(p.xy, 5.0);\n    p.y -= 0.6 ;\n    return max(abs(p.z) - 0.5, dot(p, normalize(vec3(0.0, 1.0, 0.0))));\n}\n   \nfloat twinPyramid(in vec3 p)\n{\np.xy = fold(p.xy, 5.0);\n    p.y -= 1.7 ;\n    p.z = abs(p.z);\nreturn dot(p, normalize(vec3(0.0, 1.0, 1.0)));\n}\n\nfloat star(in vec3 p)\n{    \np.xy = fold(p.xy, 5.0);\n    p.x = abs(p.x);\n    p.y += p.x * 2.0 - 0.8;\n    p.z = abs(p.z) + p.y * 0.4;\n    return p.y > 0.0 ? length(p.yz) : abs(p.z) - 0.01;\n}\n   \nvec3 transform(in vec3 p)\n{\n    p.xy *= rotate(iMouse.y * 0.05);\n    p.xz *= rotate(iMouse.x * 0.05);\n    return p;\n}\n\nfloat map(in vec3 p)\n{\n \n   \n    p = transform(p);\n        p *= 0.5; // weight;\n    return 0.2 * star(p);\n   \n    vec3 q = p;\n    q.x -= 3.0;\n    q = transform(q);\n \n    p.x += 3.0;\n    p = transform(p);\n    float de1 = prism(p);\n    return min(de1,de1);\n}\n\nvec3 calcNormal(in vec3 p)\n{\nconst vec2 e = vec2(0.0001, 0.0);\nreturn normalize(vec3(\nmap(p + e.xyy) - map(p - e.xyy),\nmap(p + e.yxy) - map(p - e.yxy),\nmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur)\n{\n    float d = length(uv - p);\n    float c = smoothstep(r, r-blur, d);\n    return c;\n}\n\nfloat Smiley(vec2 uv, vec2 p, float size, float rotationZ)\n{\n   \n   \n    uv -= p*2.;\n    uv /= 0.8;\n   \n   \n    float head = Circle(uv,vec2(0.), 0.45, 0.02);\n    float eyes = Circle(uv,vec2(0.2, 0.15), 0.1, 0.01) + Circle(uv,vec2(-0.2, 0.15), 0.1, 0.01);\n    float mouth = -Circle(uv,vec2(0., 0.15), 0.4, 0.01) + Circle(uv,vec2(0., -.1), 0.3, 0.01);\n    mouth = clamp(mouth, 0., 1.0);\n   \n    head -= mouth + eyes;\n    return head;\n\n}\nfloat march(in vec3 ro, in vec3 rd)\n{\nconst float maxd = 10.0;\nconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\nfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n   h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\nfloat happy_rich_healty_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nmat2 rotationMatrix(float angle)\n{\nangle *= PI / 180.0;\n    float sine = sin(angle), cosine = cos(angle);\n    return mat2( cosine, -sine,\n                 sine,    cosine );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = -iTime;\nvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\nvec2 q = p;\n    p = fold(p, 5.0);\n \n   \n    p *= 2.0;\n    p.y -= 1.0;\n    vec3 col;\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n     uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1\n   \n   \n uv*=rotationMatrix(180.);\n   \n    float smiley = Smiley(uv, vec2(0.), .8, iTime * 100.);\n \n   \n   \n    p = q;\n    vec3 rd = normalize(vec3(p, -1.8));\nvec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 li = normalize(vec3(0.5, 0.5, 0.5));\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n       \n        vec3 n = calcNormal(pos);\nn = reflect(rd, n);\n        float dif = clamp((dot(n, li) + 1.0) * 1.2, 0.4, 1.0);\n        col+= hsv(5.1, +.05, 0.5)*smiley+dif;\n}\n     vec4 O = fragColor;\n    vec2 C = fragCoord;\n    O=vec4(0);\nfor(float g=0.,e,j,i=0.;i++<50.;){\n    vec3 p=g*vec3((C*2.-iResolution.xy)/iResolution.y,1),q;\n        p.z+=-iTime*.2;\n        q=p;\n        p=fract(p)-.5;\n         \n        for(j=6.;--j>0.;)\np.xy=abs(p.xy)-.08*j,\n            p.xy=vec2((p.x+p.y)*.6,(p.x-p.y)*.4)*j,\n            p.xy*=.6;\n         \n        g+=e=.6*length(p.yz+col.xy)-2e-3;\n        e<.01?O.xyz+=abs(sin(q*35.))*.6/i:p;\n    }\n   \n   \n    fragColor = vec4(O+vec4(col+happy_rich_healty_star(rd.xy, anim) * vec3(0.55,0.5,0.55)*0.05,1.));\n     }\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}