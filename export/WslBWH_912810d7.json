{"ver":"0.1","info":{"id":"WslBWH","date":"1588165251","viewed":422,"name":"Alphabet Blocks","username":"spalmer","description":"voxelizing sdf shapes into textured cubes like minecraft, \nusing variant of unnick's DDA scanner\nbasically a 3D version of [url]https://shadertoy.com/view/wt3SW8[/url]\ncan fly w mouse & kbd","likes":12,"published":1,"flags":48,"usePreview":1,"tags":["raycast","voxel","font","dda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// was actually trying to do something else,\n// and accidentally made something that was\n// almost looking like toy blocks, so I went\n// ahead and fleshed it out so I could public.\n\n// no relief or bump or anything fancy for now;\n// I might do something better than the current\n// simple embossed fakery.\n\n// not sure why I'm making cubes; I had that many years ago\n// but with polygons, and just abandoned it, so idk why I'd \n// start over now with frag shader GLES!  But here I am.\n\n// Started mostly to flesh out unnick's DDA algo to 3D\n// originally from https://shadertoy.com/view/wtXSW8\n// so I could use it for other tiled raytracing stuff.\n// See Common tab.\n\n#define Font iChannel3\n\nvec3 hue(float x)\n{\n    return cos(vec3(0,2,4) + x * phi * tau) * .5 + .5;\n}\n\nconst vec3 L = normalize(vec3(1,3,2));\n\nfloat lighting(vec3 n, vec3 v)\n{\n   \tfloat nl = dot(vec3(n), L);\n   \tnl = max(0., nl); // lighting\n   \tnl = mix(nl, 1., .2); // ambient\n    return nl;\n}\n\nconst float border = .15;\n\nfloat tex(vec2 uv, vec2 subuv)\n{\n    float fd = texture(Font, uv).w - .5; // 'texture' sdf\n   #if 1 // border\n     float bd = .5 - border - max(abs(.5-subuv.x), abs(.5-subuv.y));\n     fd = min(fd, bd);\n   #endif\n    return fd;\n}\n\n// deconstruction of hit point to obtain uvs for the \n// letters of font texture in iChannel3 which are \n// 16x16 layout glyphs with a unorm sdf in w\nfloat alphatex(vec2 subuv, ivec2 cell, vec2 ll, out float fakelite)\n{\n    vec2 atlas = subuv;\n   #if 1 \n    // inset\n    atlas = mix(atlas, vec2(.5), -border);\n    atlas = clamp(atlas, 0., 1.);\n   #endif\n    atlas += vec2(cell);\n    atlas /= 16.; // because Font texture is 16x16 grid of cells\n    float fd = tex(atlas, subuv);\n    fd += .01;\n    // FIXME proper antialiasing by depth / ss deriv fwidth\n   #if 1\n    // embossed\n    float faa = clamp(.5 - fd * 2., 0., 1.);\n    fakelite = .9;\n    if (abs(fd) < .01) { // FIXME antialias this too :(\n    \tfakelite -= (texture(Font, atlas + vec2( .0005,-.001)).w - .5) * 5.;\n    \tfakelite += (texture(Font, atlas + vec2(-.0005, .001)).w - .5) * 5.;\n    }\n   #else\n    float faa = clamp(.5 - fd * 2., 0., 1.);\n   #endif\n    return faa;\n}\n\n\nfloat textureAtlas(vec2 uv, int hitid, out float fakelite)\n{\n    vec2 ll = vec2(1);\n    return alphatex(uv, ivec2(hitid, hitid >> 4) & 15, ll, fakelite); \n}\n\nvec2 hitUV(vec3 hp, ivec3 n)\n{\n    vec2          uv = hp.xy * vec2(-n.z,1);\n    if (n.x != 0) uv = hp.zy * vec2( n.x,1);\n    if (n.y != 0) uv = hp.xz * vec2( n.y,1);\n    return fract(uv);\n}\n\nvec3 blendSky(vec3 c, vec3 rd, float t)\n{\n\tconst float fogdensity = .04;\n\tvec3 csky;\n    csky = vec3(.81,.91,.99);\n    csky += .3 * pow(max(0., dot(rd, L)), 64.);\n    //csky = rd * .5 + .5; // DEBUG directions\n    return mix(csky, c, exp2(-fogdensity * t)); // simple fog Beer's law\n}\n\n\nvec3 Render(vec3 ro, vec3 rd)\n{\n    // FIXME not efficient enough to go very far;\n    // surely there's a way to optimize it more\n    // so I can traverse further without choking gpu\n    const float maxd = 96.; //64.; //128.; //512.; //256.; //192.; //160.; //\n    ivec3 n;\n    float t = ScanDDA3(ro, ro + rd * maxd, n);\n    vec3 c = vec3(0,0,0); // can't really see bg anyway due to atmo\n    if (t >= 0.) {\n        // hit a block\n\t\tvec3 hp = ro + rd * t;\n        vec2 uv = hitUV(hp, n);\n\t    float fakel;\n        float faa = textureAtlas(uv, hitid, fakel);\n        float nl = lighting(vec3(n), -rd);\n        nl *= fakel;\n        c = vec3(1);\n    \tc *= nl;\n        vec3 tint = hue(float(hitid)); // albedo\n      #if 1 \n        // white \"background\"\n    \ttint = mix(vec3(1), tint, clamp(((faa-.485)*128.)+.8, 0., 1.)); // HACK tint (albedo)\n      #endif\n        c *= tint;\n    } else {\n        t = maxd;\n    }\n    c = blendSky(c, rd, t);\n    return c;\n}\n    //\tc *= .5 + .5 * vec3(n); // DEBUG normal\n    //\tc *= exp2(-.15/*fogdensity*/ * t); // DEBUG black fog\n//\tc *= vec3(mix(exp2(-.2 * t), 1., .2)); // DEBUG black depth fog\n//\tc *= rd * .5 + .5; // DEBUG ray dir\n//\tc *= n * .5 + .5; // DEBUG hit normal\n\nvec3 Render(vec2 p)\n{\n    // TODO SSAA, focus, etc.\n    State state;\n    vec2 R = iResolution.xy;\n    ivec2 i = ivec2(p);\n    LoadState(state, BufA, ivec2(R));\n    vec2 q = (p + p - R) / R.y;\n    mat3 view = Camera(state.eyeaim);\n    // hfovy HACK hardcoded at 60\n    vec3 rv = vec3(q, 2.); // ray dir in view space\n    vec3 rd = normalize(view * rv);\n    vec3 ro = state.eyepos;\n    return Render(ro, rd);\n}\n\nfloat Dither(vec2 p)\n{\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n\tvec3 c = Render(p);\n    c = pow(c, vec3(.4545)); // gamma\n    c += .6 / 256. * Dither(p);\n    o = vec4(c, 1);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BufA iChannel0\n#define IZERO min(iFrame, 0)\n\nconst float \n  tau = 2. * acos(-1.)\n, phi = (sqrt(5.)+1.)*.5\n, voxtile = 8.\n;\n\nfloat shape(vec3 q)\n{\n    float dplane = q.y + 10.;\n    float dwaves = dplane + 5. * sin(.1*q.x) * sin(.1*q.z);\n    float dtorus = length(vec2(abs(length(q.xz)-12.), q.y)) - 3.5; // torus\n    q.z -= 30.; \n    q = abs(q);\n    q.x = max(0., q.x-6.); // rod \n    float dcapsule = length(q) - 6.5; // poof to capsule\n    return min(dwaves, min(dtorus, dcapsule));\n}\n\n\n// cos,sin of full turns angle\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\n    \n// given two fractions azimuth and elevation,\n// return orthonormal camera to world matrix\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution;\n    vec3 eyepos;\n    vec2 eyeaim;\n    bool boost; // move faster\n};\n\nconst int\n  slotResolution = 0\n, slotEyePos     = 1\n, slotEyeAim     = 2\n, slotCount      = 3\n;\n\n// measure offsets *backward* from R = ivec2(iResolution), \n// so slotResolution actually goes at R-1\n// slotCamPos goes at R - 1 - ivec2(1,0) etc.\n\n// cache to and from state structure\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data; // at least temporarily\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResolution].xy);\n    state.eyepos = data[slotEyePos].xyz;\n    state.eyeaim = data[slotEyeAim].xy;\n}\n\n// only needed in Buffer A\n// but it mirrors LoadState\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) {\n      case slotResolution:\n        c.xy = vec2(R);\n        break;\n      case slotEyePos:\n        c.xyz = state.eyepos;\n        break;\n      case slotEyeAim:\n        c.xy = state.eyeaim;\n        break;\n      default:\n        break;\n    }\n}\n\n\nvec3 Light(int m, vec3 p, vec3 n, vec3 v)\n{\n    return mix(n.y, 1., .5) * vec3(1);\n}\n\nbool Condition(ivec3 qi)\n{\n    return shape(vec3(qi)) < 0.; // is voxel here solid?\n}\nint hitid = 0;\n// just record id and stop if hit a solid voxel\nbool Traverse(ivec3 qi)\n{\n    hitid = (qi.x^(qi.y*3)^(qi.z*7))&255;\n    return false;\n}\n\n// unnick's from https://shadertoy.com/view/wtXSW8\n// stripped down to just the DDA portion\n// converted to 3D\n// the dda raycaster; returns total distance traced along ray\nfloat ScanDDA3(vec3 pa, vec3 pb, out ivec3 n)\n{ \n    vec3 ro = pa, pd = pb - pa\n    , rd = normalize(pd), nrd = normalize(rd)\n    , ad = abs(pd)\n    , dd = 1. / abs(nrd)\n    , pos = ro\n    , sd = fract(pos);\n    ivec3 mp = ivec3(floor(pa)) // tile iterator\n    , aid = abs(ivec3(floor(pb))-mp)\n    , st = ivec3(sign(rd)); // step direction\n    int side = 0;\n    if (st.x > 0) sd.x = 1. - sd.x;\n    if (st.y > 0) sd.y = 1. - sd.y;\n    if (st.z > 0) sd.z = 1. - sd.z;\n    sd *= dd;\n    bool miss = true;\n    int nsteps = 1+aid.x+aid.y+aid.z;\n    for (int i = nsteps; --i >= 0; ) {\n        if (Condition(mp))\n            if (!Traverse(mp)) {\n                miss = false;\n            \tbreak;\n            }\n        side = sd.x <= sd.y && sd.x <= sd.z\n            ? 0 : sd.y <= sd.z\n                ? 1 : 2;\n        switch (side) {\n            case 0: sd.x += dd.x; mp.x += st.x; break;\n        \tcase 1: sd.y += dd.y; mp.y += st.y; break;\n        \tcase 2: sd.z += dd.z; mp.z += st.z; break;\n        }\n    }\n    n = ivec3(0);\n    if (miss) return -1.; // past the destination, treat as missed\n    float dist = float(mp[side]) - pos[side];\n    dist += float((1 - st[side]) / 2);\n    dist /= rd[side]; // unproject distance from axial to along ray\n    n[side] = -st[side];\n    return dist;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// from Fly Camera at https://shadertoy.com/view/tdsfR4\n\n#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define Kbd  iChannel3\n\nconst float \n  eyeradius = .25\n, eyespeed = 10.\n, eyespin = 2.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n;\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    bool button;\n  //  bool sprint; // speed boost\n    float dt; // delta time seconds\n    // debug features TODO\n};\n    \nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n// key bindings to local directions\n#if 0 \n    // arrows\n, KEY_LF    = KEY_LEFT\n, KEY_RT    = KEY_RIGHT\n, KEY_FW    = KEY_UP\n, KEY_BW    = KEY_DOWN\n#elif 0 \n    // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0\n    // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else\n    // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE // up - maybe PgUp/Dn?\n, KEY_DW    = KEY_C     // down - anything but control!\n;\n\nfloat key(int vk)\n{\n    return step(.5, texelFetch(Kbd, ivec2(vk, 0), 0).x);\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    if (iMouse.xyz == vec3(0)) // icon?\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    inp.move = vec3(key(KEY_RT) - key(KEY_LF)\n                  , key(KEY_UW) - key(KEY_DW)\n                  , key(KEY_FW) - key(KEY_BW));\n    inp.dt = iTimeDelta;\n}\n\nvec3 CollideSphere(vec3 pos, float radius)\n{\n#if 0\n    // TODO requires SDF, normal, otherwise not needed here\n    float d;\n    vec3 n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .7); // collision\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .9); // again!\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius); // again! helps with getting stuck in crevices\n    pos.y = max(pos.y, radius); // HACK prevent going beneath ground plane just in case\n#endif\n    return pos;\n}\n\nvec3 MoveCamera(State state, Inputs inp) \n{\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed;\n    if (state.boost) spd *= 4.;\n    vec3 op = state.eyepos\n    , move = inp.move * inp.dt * spd \n    , p = op + view * move\n    ;\n//    p = CollideSphere(p, eyeradius);\n    return p;\n}\n\nvec2 TurnCamera(State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution)\n    , oa = state.eyeaim\n    , a = inp.mouse / R;\n    a.x = fract(a.x * eyespin);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    a = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate\n    return a;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    state.boost = key(KEY_SHIFT) > .5;\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(2,6,-18);\n        state.eyeaim = vec2(0.,.5);\n    } else { // update state\n\t    state.eyepos = MoveCamera(state, inp);\n\t    state.eyeaim = TurnCamera(state, inp);\n    }\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    bool init = iFrame == 0;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    vec4 c = init\n        ? vec4(0,0,0,1)\n     \t: fetch(BufA, i);\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n    SaveState(c, state, i);\n    o = c;\n}\n\n\n// unfortunately I cannot reset iMouse, \n// so when one resets the toy, \n// the camera will still be aimed\n// wherever user had it aimed last.\n\n","name":"Buffer A","description":"","type":"buffer"}]}