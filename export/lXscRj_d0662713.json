{"ver":"0.1","info":{"id":"lXscRj","date":"1726528059","viewed":54,"name":"Room Pathtracer","username":"dom_the_whale","description":"This pathtracer uses the Monte Carlo simulation method to obtain accurate lighting results across multiple frames. ","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracer","pathtracer","depthoffield"],"hasliked":0,"parentid":"lcjyzV","parentname":"Sphere Pathtracer + DOF"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 acc = texture(iChannel0, fragCoord/iResolution.xy);\n    fragColor = vec4(acc);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//initializing global variables\nvec3 rp = vec3(0., 0., 0.);\nvec3 rd = vec3(0., 0., 1.);\nvec3 rgb = vec3(1., 1., 1.);\nvec2 uv = vec2(0.);\nfloat i = 0.;\nfloat a = 0.;\nfloat seed = 0.;\n\n//pseudo-random number generator 1\nfloat rand(vec2 co){\n    seed += fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    return fract(sin(dot(co.xy + seed ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//pseudo-random number generator 2\nfloat hash(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    seed += fract((p3.x + p3.y) * p3.z);\n    return fract((p3.x + p3.y) * p3.z + seed);\n}\n\n//generates uniform random position on a sphere\nvec3 randpos(vec2 uv) {\n    float u = hash(vec2(uv + float(iFrame) + a));\n    float v = hash(vec2(uv + u - a));\n\n    float theta = 2.0 * 3.14159265 * u;\n    float phi = acos(2.0 * v - 1.0);\n\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n\n    return normalize(vec3(x, y, z));\n}\n\n\n//calculates distance the ray must travel until it hits the sphere's edge\nfloat spheredist(vec3 pos, float r){\n    vec3 diff = rp - pos;\n    float b = dot(diff, rd);\n    float c = dot(diff, diff) - r * r;\n    float discr = b * b - c;\n\n    float t = -1.0;  \n\n    if (discr >= 0.0) {\n        float sqrtDiscr = sqrt(discr);\n        float t0 = -b - sqrtDiscr;\n        float t1 = -b + sqrtDiscr;\n\n        if (t0 >= 0.0) {\n            t = t0;\n        } else if (t1 >= 0.0) {\n            t = -1.;\n        }\n    }\n\n    if(t>=0.){\n        return t;\n    }\n    else{\n        return 999999.;\n    }\n}\n\n\n//main function for calculating color of ray after reflecting, or scattering\nvoid rendersphere(vec3 pos, float r, vec3 colour, float closedist, float blurryp, float block, float gloss, float scatterblur){\n    //calculates distance to the sphere defined in the parameters given\n    float t = spheredist(pos, r);\n    \n    //checks to make sure the ray intersects the sphere and the sphere is the closest to the camera\n    if (t >= 0.0 && t == closedist) {\n        closedist = -5.;\n        //initializes variables. colordp is a variable to change color influence based on the tilt of the surface of the sphere\n        float colordp = 1.; \n        rd = normalize(rd);\n        rp += rd * t;\n        \n        //if the ray gets scattered\n        if (hash(uv + a + float(iFrame)) < blurryp){\n            rd = randpos(vec2(hash(uv + a + float(iFrame))));\n            if(dot(rd, normalize(rp-pos)) < 0.){rd *= -1.;}\n            colordp *= dot(normalize(rp - pos), rd);\n        \n        //if the ray gets reflected\n        }else{\n            rd = reflect(rd, normalize(rp - pos));\n            //if the ray hits a \"polished\" layer and doesn't interact with the color of the sphere\n            if(hash(vec2(rand(uv)) + a / rand(vec2(iTime))) <= gloss){\n            rgb /= colour;\n            }\n            \n            //calculates noise of the ray based on the blurryness of the sphere\n            vec3 temprd = randpos(vec2(rand(length(uv) + uv + hash(vec2(iFrame)))));\n            if(dot(temprd, normalize(rp-pos)) < 0.){temprd *= -1.;}\n            rd += temprd * scatterblur * rand(a - uv + rand(vec2(iFrame)));\n            rd = normalize(rd);\n        }\n        \n        //gives the sphere a grid texture \n        float tex = 1.;\n        if(block == 1.){tex = round(mod(dot(round(rp/3.), vec3(1.,1.,1.)), 2.))/2. + 0.5;}\n            \n        \n        \n        //final color calculation\n        if(length(colour) < 5.){\n            rgb *= colour * colordp * tex;\n        }else{\n            rgb *= colour;\n            i = 999999.;\n            \n        }\n    }\n}\n\n\n\n\n\n//main image function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initializes variables\n    uv = fragCoord/iResolution.xy;\n    float FOV = 1.0;\n    float focal_length = 100.;\n    float aperture = 2.;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= FOV;\n    vec3 average = vec3(0.);\n    \n    //begins the loop of firing rays. The upper limit of 'a' determines how many rays will be fired.\n    for( a = 1.; a <= 3.; a++){\n        \n        \n        rp = vec3(0., 10., 0.);\n        rd = vec3(uv.x + (hash(uv + a + float(iFrame)) - 0.5)/2000., uv.y + (hash(uv + a + iTimeDelta) - 0.5)/2000., 1.);\n        rd = normalize(rd);\n        \n        float randrad = sqrt(hash(uv + a + float(iFrame)))* aperture;\n        float randangle = hash(uv + a + hash(vec2(float(iFrame)))) * 2. * 3.14159265358979 ;\n\n        rp += vec3(cos(randangle) * randrad, sin(randangle) * randrad, 0.);\n        rd -= vec3(cos(randangle) * randrad, sin(randangle) * randrad, 0.)/focal_length;\n        \n        rd = normalize(rd);\n\n        rgb = vec3(.2, .2, .2);\n        float closedist = 99999.;\n        for(i = 0.; i < 5.; i++){\n            float closedist = 99999.;\n            \n            \n            //closedist = min(closedist, spheredist(vec3(-300, 400., 100), 70.));\n            closedist = min(closedist, spheredist(vec3(0, -999999. - 6., 0), 999999.));\n            closedist = min(closedist, spheredist(vec3(0, 0., 999999. + 200.), 999999.));\n            closedist = min(closedist, spheredist(vec3(999999. + 300., 0., 0.), 999999.));\n            closedist = min(closedist, spheredist(vec3(-999999. - 300., 0., 0.), 999999.));\n            closedist = min(closedist, spheredist(vec3(0., 0., -999999. - 300.), 999999.));\n            closedist = min(closedist, spheredist(vec3(0., 999999. + 300., 0.), 999999.));\n            \n            closedist = min(closedist, spheredist(vec3(0, 7., 100), 13.));\n            closedist = min(closedist, spheredist(vec3(40, 7., 100), 13.));\n            closedist = min(closedist, spheredist(vec3(-40, 7., 100), 13.));\n            \n            closedist = min(closedist, spheredist(vec3(0., 50., 150.), 15.));\n            closedist = min(closedist, spheredist(vec3(-50., 50., 150.), 15.));\n            closedist = min(closedist, spheredist(vec3(50., 50., 150.), 15.));\n\n\n\n\n            //rendersphere(vec3(-300, 400., 100), 70., vec3(255.,255.,255.)*2., closedist, .9, 0., .2, 0.01);\n            rendersphere(vec3(0, -999999. - 6., 0), 999999., vec3(1., 1., 1.), closedist, 1., 0., .2, 0.01);\n            rendersphere(vec3(0, 7., 100), 13., vec3(255,255,255)/255., closedist, .5, 0., 1., 0.5);\n            rendersphere(vec3(40, 7., 100), 13., vec3(255,255,255)/500., closedist, 1., 0., 1., 0.5);\n            rendersphere(vec3(-40, 7., 100), 13., vec3(255,255,255)/500., closedist, .0, 0., 1., 0.);\n            \n            rendersphere(vec3(999999. + 300., 0., 0.), 999999., vec3(255,255,255)/100., closedist, 1., 0., 1., 0.08);\n            rendersphere(vec3(0, 0., 999999. + 200.), 999999., vec3(255,255,255)/600., closedist, .0, 0., 1., 0.0);\n            rendersphere(vec3(-999999. - 300., 0., 0.), 999999., vec3(255,255,255)/100., closedist, 1., 0., 1., 0.08);\n            rendersphere(vec3(0., 0., -999999. - 300.), 999999., vec3(255,255,255)/100., closedist, 1., 0., 1., 0.08);\n            rendersphere(vec3(0., 999999. + 300., 0.), 999999., vec3(255,255,255)/100., closedist, 1., 0., 1., 0.08);\n            \n            rendersphere(vec3(0., 50., 150.), 15., vec3(0.,255.,0.)*1.5, closedist, 1., 0., 1., 0.08);\n            rendersphere(vec3(-50., 50., 150.), 15., vec3(255.,0.,0.)*1.5, closedist, 1., 0., 1., 0.08);\n            rendersphere(vec3(50., 50., 150.), 15., vec3(0.,0.,255.)*1.5, closedist, 1., 0., 1., 0.08);\n\n            \n            \n            \n            if (closedist == 99999.){\n                i = 99999.;\n                rgb *= 0.;\n            }\n        }\n        if(a == 1.){\n            average = rgb;\n        }else{\n            average *= (a-1.)/a;\n            average += rgb/a;\n        }\n    }\n    //fragColor = vec4(vec3(average), 1.);\n    \n    if(iFrame == 0){\n        fragColor = vec4(vec3(average), 1.);\n    }else{\n        fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n        fragColor = mix(fragColor, vec4(vec3(average), 1.), 1./max((float(iFrame)-60.), 1.));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}