{"ver":"0.1","info":{"id":"mt2fWt","date":"1694630288","viewed":39,"name":"Mountains!","username":"airatlovesmusic","description":"It's my first work on the shadertoy, everyone here â€” you are a pure inspiration!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","clouds","fbm","mountains"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nconst int MAX_MARCHING_STEPS=100;\nconst float MIN_DIST=0.;\nconst float MAX_DIST=100.;\nconst float PRECISION=.001;\nconst float EPSILON=.0005;\nconst float PI=3.14159265359;\nconst vec3 COLOR_BACKGROUND=vec3(.15, .6, 1.);\n\nfloat dot2(in vec2 v){return dot(v,v);}\nfloat dot2(in vec3 v){return dot(v,v);}\n\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n\t// optimized away.\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nstruct Surface{\n  float sd;\n  vec3 col;\n};\n\nmat2 rotate2d(float theta){\n  float s=sin(theta),c=cos(theta);\n  return mat2(c,-s,s,c);\n}\n\nfloat sdPlane(vec3 p,vec3 n,float h)\n{\n  // n must be normalized\n  return dot(p,n)+h;\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n  return length(p)-r;\n}\n\nSurface sdFloor(vec3 p,float h,vec3 color){\n  return Surface(p.y+h,color);\n}\n\nSurface minWithSurface(Surface s1,Surface s2){\n  if(s1.sd<s2.sd){\n    return s1;\n  }\n  return s2;\n}\n\nvec3 opFlipX(vec3 p){\n  p.x*=-1.;\n  return p;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n  vec3 q=abs(p)-b;\n  return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r){\n  vec3 pa=p-a,ba=b-a;\n  float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n  return length(pa-ba*h)-r;\n}\n\nfloat sdEllipsoid(vec3 p,vec3 r)\n{\n  float k0=length(p/r);\n  float k1=length(p/(r*r));\n  return k0*(k0-1.)/k1;\n}\n\nfloat sdCone(vec3 p,vec2 c,float h)\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q=h*vec2(c.x/c.y,-1.);\n  \n  vec2 w=vec2(length(p.xz),p.y);\n  vec2 a=w-q*clamp(dot(w,q)/dot(q,q),0.,1.);\n  vec2 b=w-q*vec2(clamp(w.x/q.x,0.,1.),1.);\n  float k=sign(q.y);\n  float d=min(dot(a,a),dot(b,b));\n  float s=max(k*(w.x*q.y-w.y*q.x),k*(w.y-q.y));\n  return sqrt(d)*sign(s);\n}\n\nfloat sdCappedCylinder(vec3 p,float h,float r,vec3 offset)\n{\n  p-=offset;\n  vec2 d=abs(vec2(length(p.xz),p.y))-vec2(h,r);\n  return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat sdCappedTorus(vec3 p,vec2 sc,float ra,float rb)\n{\n  p.x=abs(p.x);\n  float k=(sc.y*p.x>sc.x*p.y)?dot(p.xy,sc):length(p.xy);\n  return sqrt(dot(p,p)+ra*ra-2.*ra*k)-rb;\n}\n\nfloat sdTorus(vec3 p,vec2 t)\n{\n  vec2 q=vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundCone(vec3 p,vec3 a,vec3 b,float r1,float r2)\n{\n  // sampling independent computations (only depend on shape)\n  vec3 ba=b-a;\n  float l2=dot(ba,ba);\n  float rr=r1-r2;\n  float a2=l2-rr*rr;\n  float il2=1./l2;\n  \n  // sampling dependant computations\n  vec3 pa=p-a;\n  float y=dot(pa,ba);\n  float z=y-l2;\n  float x2=dot2(pa*l2-ba*y);\n  float y2=y*y*l2;\n  float z2=z*z*l2;\n  \n  // single square root!\n  float k=sign(rr)*rr*rr*x2;\n  if(sign(z)*a2*z2>k)return sqrt(x2+z2)*il2-r2;\n  if(sign(y)*a2*y2<k)return sqrt(x2+y2)*il2-r1;\n  return(sqrt(x2*a2*il2)+y*rr)*il2-r1;\n}\n\nfloat sdVerticalCapsule(vec3 p,float h,float r)\n{\n  p.y-=clamp(p.y,0.,h);\n  return length(p)-r;\n}\n\nSurface opSmoothUnion(Surface d1,Surface d2,float k){\n  Surface s;\n  float h=clamp(.5+.5*(d2.sd-d1.sd)/k,0.,1.);\n  s.sd=mix(d2.sd,d1.sd,h)-k*h*(1.-h);\n  s.col=mix(d2.col,d1.col,h)-k*h*(1.-h);\n  \n  return s;\n}\n\nfloat opSmoothUnion(float d1,float d2,float k){\n  float h=clamp(.5+.5*(d2-d1)/k,0.,1.);\n  return mix(d2,d1,h)-k*h*(1.-h);\n}\n\nmat3 rotateY(float theta){\n  float c=cos(theta);\n  float s=sin(theta);\n  return mat3(\n    vec3(c,0,s),\n    vec3(0,1,0),\n    vec3(-s,0,c)\n  );\n}\n\nmat3 rotateX(float theta){\n  float c=cos(theta);\n  float s=sin(theta);\n  return mat3(\n    vec3(1,0,0),\n    vec3(0,c,-s),\n    vec3(0,s,c)\n  );\n}\n\nfloat opUnion(float d1,float d2){\n  return min(d1,d2);\n}\n\nSurface opUnion(Surface d1,Surface d2){\n  if(d2.sd<d1.sd)return d2;\n  return d1;\n}\n\nSurface opSubstraction(Surface d1,Surface d2){\n  if(d2.sd>d1.sd)return d2;\n  return d1;\n}\n\n#define OCTAVES 3\n\nfloat fbm(in vec2 p, in bool animate) {\n    float time = animate ? (iTime / 2.) : 0.;\n    float t = .5;\n    mat2 rot = mat2(\n        4./5., -3./5.,\n        3./5., 4./5.\n    );\n\n    float value = 0.;\n    float amp = 1.;\n    float freq = 0.;\n    \n    for (int i = 0; i < OCTAVES; i++) {\n        value += amp * noise(p.yx * rot + time);\n        p *= 2.;\n        amp *= .5;\n    }\n    \n    return value;\n}\n\nSurface scene(vec3 p){  \n  float n = 15. * noise(p.xz / 1./100.) +\n    12. * noise(p.xz * 1./11.) +\n    -2. * noise(p.xz * 1./7.);\n    \n  vec3 col = vec3(0.);\n  if (n > 7.5) {\n    n += fbm(p.xz, false) * 0.4 + .6;\n    col = vec3(1.);\n  } else if (n < 5.) {\n    n += fbm(p.xz, true) * .3;\n    col = vec3(0., 1., 1.);\n   } else {\n    n += fbm(p.xz, false) * .1;\n    col = vec3(.1);\n   }\n\n  Surface terrain = Surface((p.y + 15. -  n) * 0.6, col);\n\n  return terrain;\n}\n\nSurface rayMarch(vec3 ro,vec3 rd){\n  float depth=MIN_DIST;\n  Surface d;\n  \n  for(int i=0;i<MAX_MARCHING_STEPS;i++){\n    vec3 p=ro+depth*rd;\n    d=scene(p);\n    depth+=d.sd;\n    if(d.sd<PRECISION||depth>MAX_DIST)break;\n  }\n  \n  d.sd=depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p){\n  vec2 e=vec2(1,-1)*EPSILON;\n  return normalize(\n    e.xyy*scene(p+e.xyy).sd+\n    e.yyx*scene(p+e.yyx).sd+\n    e.yxy*scene(p+e.yxy).sd+\n    e.xxx*scene(p+e.xxx).sd);\n}\n  \nmat3 camera(vec3 cameraPos,vec3 lookAtPoint){\n    vec3 cd=normalize(lookAtPoint-cameraPos);\n    vec3 cr=normalize(cross(vec3(0,1,0),cd));\n    vec3 cu=normalize(cross(cd,cr));\n    \n    return mat3(-cr,cu,-cd);\n}\n  \nvec3 phong(vec3 lightDir,vec3 normal,vec3 rd,vec3 col){\n    // ambient\n    float k_a=.7;\n    vec3 i_a=col;\n    vec3 ambient=k_a*i_a;\n    \n    // diffuse\n    float k_d=.5;\n    float dotLN=clamp(dot(lightDir,normal),0.,1.);\n    vec3 i_d=vec3(1.);\n    vec3 diffuse=k_d*dotLN*i_d;\n    \n    // specular\n    float k_s=.9;\n    float dotRV=clamp(dot(reflect(lightDir,normal),-rd),0.,1.);\n    vec3 i_s=vec3(1,1,1);\n    float alpha=10.;\n    vec3 specular=k_s*pow(dotRV,alpha)*i_s;\n    \n    return ambient+diffuse + specular;\n}\n  \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseUV=vec2(-.1) + iMouse.xy/iResolution.xy;\n    \n    vec3 col=vec3(0);\n    vec3 lp=vec3(0);// lookat point\n    vec3 ro=vec3(0,0,4);// ray origin that represents camera position\n    \n    float cameraRadius=3.;\n    ro.yz=ro.yz*cameraRadius*rotate2d(mix(-PI/2.,PI/2.,mouseUV.y));\n    ro.xz=ro.xz*rotate2d(mix(0.,2. * PI, mouseUV.x))+vec2(lp.x,lp.z);\n    \n    vec3 rd=camera(ro,lp)*normalize(vec3(uv,-1));// ray direction\n    \n    Surface d=rayMarch(ro,rd);// signed distance value to closest object\n    \n    if(d.sd>MAX_DIST){\n      col = COLOR_BACKGROUND + vec3(fbm(rotate2d(PI/2.) * gl_FragCoord.xy / 200., true) - .1);\n    }else{\n      vec3 p=ro+rd*d.sd;// point on surface found by ray marching\n      vec3 normal=calcNormal(p);// surface normal\n      \n      vec3 lightPosition=vec3(3,4,1.5);\n      vec3 lightDirection=normalize(lightPosition-p);\n      \n      vec3 lightPosition1=vec3(-3,4,1.5);\n      vec3 lightDirection1=normalize(lightPosition1-p);\n      \n      vec3 lightPosition2=vec3(-3,4,-1.5);\n      vec3 lightDirection2=normalize(lightPosition2-p);\n      \n      col=.3*phong(lightDirection,normal,rd,d.col);\n      col+=.3*phong(lightDirection1,normal,rd,d.col);\n      col+=.3*phong(lightDirection2,normal,rd,d.col);\n    }\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}