{"ver":"0.1","info":{"id":"Xdt3zj","date":"1451004396","viewed":258,"name":"Ellipse Curve Control","username":"gaz","description":"can use the mouse.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","de"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI\t3.14159265359\n\nvec2 p0, p1, p2;\n\nmat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix(vec3(1),clamp((abs(fract(h+vec3(3,2,1)/3.)*6.-3.)-1.),0.,1.),s)* v;\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n\tvec2 pa=p-a,ba=b-a;\n\tfloat h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn length(pa-ba*h);\n}\n\n// text\n// https://www.shadertoy.com/view/llSGRm\n#define CHAR_SIZE vec2(6, 7)\n#define CHAR_SPACING vec2(6, 9)\n#define DOWN_SCALE 2.0\n\nvec2 ch_0 = vec2(935221.0,731292.0);\nvec2 ch_1 = vec2(274497.0,33308.0);\nvec2 ch_2 = vec2(934929.0,1116222.0);\nvec2 ch_3 = vec2(934931.0,1058972.0);\nvec2 ch_4 = vec2(137380.0,1302788.0);\nvec2 ch_5 = vec2(2048263.0,1058972.0);\nvec2 ch_6 = vec2(401671.0,1190044.0);\nvec2 ch_7 = vec2(2032673.0,66576.0);\nvec2 ch_8 = vec2(935187.0,1190044.0);\nvec2 ch_9 = vec2(935187.0,1581336.0);\nvec2 ch_A = vec2(935188.0,780450.0);\nvec2 ch_B = vec2(1983767.0,1190076.0);\nvec2 ch_C = vec2(935172.0,133276.0);\nvec2 ch_D = vec2(1983764.0,665788.0);\nvec2 ch_E = vec2(2048263.0,1181758.0);\nvec2 ch_F = vec2(2048263.0,1181728.0);\nvec2 ch_G = vec2(935173.0,1714334.0);\nvec2 ch_H = vec2(1131799.0,1714338.0);\nvec2 ch_I = vec2(921665.0,33308.0);\nvec2 ch_J = vec2(66576.0,665756.0);\nvec2 ch_K = vec2(1132870.0,166178.0);\nvec2 ch_L = vec2(1065220.0,133182.0);\nvec2 ch_M = vec2(1142100.0,665762.0);\nvec2 ch_N = vec2(1140052.0,1714338.0);\nvec2 ch_O = vec2(935188.0,665756.0);\nvec2 ch_P = vec2(1983767.0,1181728.0);\nvec2 ch_Q = vec2(935188.0,698650.0);\nvec2 ch_R = vec2(1983767.0,1198242.0);\nvec2 ch_S = vec2(935171.0,1058972.0);\nvec2 ch_T = vec2(2035777.0,33288.0);\nvec2 ch_U = vec2(1131796.0,665756.0);\nvec2 ch_V = vec2(1131796.0,664840.0);\nvec2 ch_W = vec2(1131861.0,699028.0);\nvec2 ch_X = vec2(1131681.0,84130.0);\nvec2 ch_Y = vec2(1131794.0,1081864.0);\nvec2 ch_Z = vec2(1968194.0,133180.0);\n\nvec2 res;// = iResolution.xy / DOWN_SCALE;\nvec2 print_pos = vec2(0);\n\nfloat extract_bit(in float n, in float b)\n{\n    b = clamp(b,-1.0,22.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\nfloat sprite(in vec2 spr, in vec2 size, in vec2 uv)\n{\n    uv = floor(uv);\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    return bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;\n\n}\nfloat char(in vec2 ch, in vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\nvec2 pos2uv(in vec2 p)\n{\n    vec2 uv = iResolution.xy / 2.0 ;\n    uv += p * iResolution.y / 2.0;\n    uv /= DOWN_SCALE;\n \treturn  uv; \n}\n\n// Marden's Theorem\n// http://www004.upp.so-net.ne.jp/s_honma/mathbun/mathbun466.html\nvec4 foci(in vec2 p0, in vec2 p1, in vec2 p2)\n{\n    float a=p0.x,b=p0.y,c=p1.x,d=p1.y,e=p2.x,f=p2.y;\n    float g=a+c+e;\n    float h=b+d+f;\n    float k=g*g-h*h+3.*(b*d+d*f+f*b-a*c-c*e-e*a);\n    float m=3.*(a*b+c*d+e*f)-g*h;\n    float r=sqrt(k*k+m*m);\n    float s=sign(m);\n \treturn vec4(\n    \tg/3.0+sqrt((r+k)/18.0),h/3.0+s*sqrt((r-k)/18.0),\n    \tg/3.0-sqrt((r+k)/18.0),h/3.0-s*sqrt((r-k)/18.0));\n}\n\nvec4 marden(in vec2 p, in vec2 a, in vec2 b, in vec2 c)\n{\n    vec2 p0 = mix(a, c, 0.5);\n    vec2 p2 = mix(p0, b, 3.0);\n    vec2 p1 = mix(p2, a, 2.0);\n    vec2 p3 = mix(p2, c, 2.0);\n    vec4 f = foci(p1,p2,p3);\n    vec2 f0 = f.xy;\n    vec2 f1 = f.zw;   \n    vec2 vf = f1 - f0;\n    vec2 o = vf * 0.5 + f0; \n    mat2 m = rotate(atan(vf.y, vf.x));\n    float r0 = (length(f0-a) + length(f1-a))/2.0;\n    float r1 = sqrt(r0*r0 - pow(length(f0-o),2.0));\n    vec2 r =  vec2(r0,r1);   \n    vec2 q = (p-o)*m;\n    return vec4(q,r);\n}\n\nfloat deEllipse(in vec2 p, in vec2 r)\n{\n     return (length(p/r) - 1.0)*min(r.x, r.y);\n}\n\n// https://www.shadertoy.com/view/4sS3zz\nfloat deEllipse2( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n    float si = sqrt( 1.0 - co*co ); \n    vec2 r = vec2( ab.x*co, ab.y*si );\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nfloat deEllipsoid(in vec3 p, in vec3 r)\n{\n    return (length(p/r) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat Cross(in vec2 a, in vec2 b ) \n{\n    return a.x*b.y-b.x*a.y;\n}\n\nfloat deCurve(in vec2 p) // type 2D\n{\n    vec4 m = marden(p.xy, p0, p1, p2);\n    vec2 q = m.xy;\n    vec2 r = m.zw;\n    /*\n    float e = 0.01;\n    float de = deEllipse(q, r);\n    // https://www.shadertoy.com/view/MdfGWn\n    float g = length( vec2(\n        deEllipse(q+vec2(e,0.0), r)-deEllipse(q-vec2(e,0.0), r),\n        deEllipse(q+vec2(0.0,e), r)-deEllipse(q-vec2(0.0,e), r)) )/(2.0*e);\n    de = de/g;\n\t*/\n    float de = deEllipse2(q, r);\n    if (Cross(p0-p2, p-p2)> 0.0) de = 1.0;\n    return de; \n}\n\n// https://www.shadertoy.com/view/Xds3zN\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat deCurve(in vec3 p) // type 3D\n{\n    vec4 m = marden(p.xy, p0, p1, p2);\n    vec2 q = m.xy;\n    vec2 r = m.zw;\n    /*\n    float e = 0.01;\n    // https://www.shadertoy.com/view/MdfGWn\n    float g = length( vec2(\n        deEllipse(q+vec2(e,0.0), r)-deEllipse(q-vec2(e,0.0), r),\n        deEllipse(q+vec2(0.0,e), r)-deEllipse(q-vec2(0.0,e), r)) )/(2.0*e);\n    vec2 pp  = vec2(deEllipse(q, r), p.z*g);\n\tfloat de = length8(pp)-g*0.05;   \n    */\n    vec2 pp  = vec2(deEllipse2(q, r), p.z);\n\tfloat de = length8(pp) - 0.05;   \n    de = max(dot(p-vec3(p0,0.0), vec3((p2-p0)*mat2(0,1,-1,0), 0.0)), de);\n\treturn de; \n}\n\nfloat deSolidCurve(in vec3 p)\n{\n    vec4 m = marden(p.xy, p0, p1, p2);\n    vec3 q = vec3(m.xy, p.z);\n    vec3 r = vec3(m.zw, 0.5);\n    float de = deEllipsoid(q, r);\n    de = max(dot(p-vec3(p0,0.0), vec3((p2-p0)*mat2(0,1,-1,0), 0.0)), de);\n    return de; \n}\n\nfloat map(in vec3 p)\n{    \n    p.zx *= rotate(iTime * 0.3); \n    p.yz *= rotate(iTime * 0.5);\n    \n    return min(deCurve(p + vec3(-1.0,0.0,0.0)), deSolidCurve(p + vec3(1.0,0.0,0.0)));\n    //return deCurve(p);\n    //return deSolidCurve(p);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 10.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis || t > maxd) break;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvec3 backBoard(in vec2 p , in vec2 fragCoord)\n{\n    vec2 p3 = mix(p0, p2, 0.5);\n    vec2 b = mix(p3, p1, 3.0);\n    vec2 a = mix(b, p0, 2.0);\n    vec2 c = mix(b, p2, 2.0);\n    \n    vec4 f = foci(a, b, c);\n    vec2 f0 = f.xy;\n    vec2 f1 = f.zw;    \n    vec2 vf = f1 - f0;\n    vec2 o = vf * 0.5 + f0; \n    mat2 m = rotate(atan(vf.y, vf.x));\n    \n    vec2 uv = fragCoord / DOWN_SCALE;\n    float size = 0.02;\n    float width = 0.01;\n    vec3 txtCol = hsv(0.4, 0.7, 1.0);\n    vec3 pntCol1 = hsv(0.2, 0.7, 1.0);\n    vec3 pntCol2 = hsv(0.0, 0.7, 1.0);\n    vec3 pntCol3 = hsv(0.8, 0.7, 1.0);\n    vec3 pntCol4 = vec3(1.0);\n    vec3 lnCol1 = hsv(0.3, 0.7, 1.0);\n    vec3 lnCol2 = hsv(0.6, 0.7, 1.0);\n    vec3 col = mix(vec3(0.05, 0.03, 0.0), vec3(0.8), smoothstep(0.4, 3.5, length(p)));\n    \n    col = mix(col, lnCol1, smoothstep(width, 0.0, sdSegment(p, a, b)));   \n\tcol = mix(col, lnCol1, smoothstep(width, 0.0, sdSegment(p, b, c)));   \n\tcol = mix(col, lnCol1, smoothstep(width, 0.0, sdSegment(p, c, a))); \n    \n    col = mix(col, lnCol2, smoothstep(width*10.0, 0.0, abs(deCurve(p)))); \n\n    float r0 = (length(f0-p0) + length(f1-p0))/2.0;\n    float r1 = sqrt(r0*r0 - pow(length(f0-o), 2.0));   \n    col = mix(col, lnCol1, smoothstep(width, 0.0, abs(deEllipse((p - o) * m , vec2(r0, r1))))); \n\n    col = mix(col, pntCol2, smoothstep(width, 0.0, length(p - p0) - size)); \n    col = mix(col, pntCol2, smoothstep(width, 0.0, length(p - p1) - size)); \n    col = mix(col, pntCol2, smoothstep(width, 0.0, length(p - p2) - size));\n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - a) - size));\n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - b) - size));\n    col = mix(col, pntCol1, smoothstep(width, 0.0, length(p - c) - size));\n    col = mix(col, pntCol4, smoothstep(width, 0.0, length(p - o) - size));\n    col = mix(col, pntCol3, smoothstep(width, 0.0, length(p - f0) - size));\n    col = mix(col, pntCol3, smoothstep(width, 0.0, length(p - f1) - size));\n    \n    print_pos = pos2uv(p0 + vec2(-0.15, 0.05));\n    col = mix(col, txtCol , char(ch_P, uv));\n    col = mix(col, txtCol , char(ch_0, uv));\n    print_pos = pos2uv(p1 + vec2(0.05));\n    col = mix(col, txtCol , char(ch_P, uv));\n    col = mix(col, txtCol , char(ch_1, uv));\n    print_pos = pos2uv(p2 + vec2(0.05));\n    col = mix(col, txtCol , char(ch_P, uv));\n    col = mix(col, txtCol , char(ch_2, uv));\n    print_pos = pos2uv(a + vec2(-0.15, 0.05));\n    col = mix(col, txtCol , char(ch_A, uv));\n    print_pos = pos2uv(b + vec2(0.05));\n    col = mix(col, txtCol , char(ch_B, uv));\n    print_pos = pos2uv(c + vec2(0.05));\n    col = mix(col, txtCol , char(ch_C, uv));\n    print_pos = pos2uv(o + vec2(0.05));\n    col = mix(col, txtCol , char(ch_O, uv));\n    print_pos = pos2uv(f0 + vec2(0.05));\n    col = mix(col, txtCol , char(ch_F, uv));\n    col = mix(col, txtCol , char(ch_0, uv));\n    print_pos = pos2uv(f1 + vec2(0.05));\n    col = mix(col, txtCol , char(ch_F, uv));\n    col = mix(col, txtCol , char(ch_1, uv));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    res = iResolution.xy / DOWN_SCALE;\n    \n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;    \n    p0 = vec2(-0.45, 0.05);\n    p1 = length(iMouse.xy) > 0.0 ? m: vec2(0.0, sin(PI / 3.0) / 3.0);\n    p2 = vec2(0.45, -0.05);  \n    vec3 col = backBoard(p, fragCoord);\n    vec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 rd = normalize(vec3(p, -2.0));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    \tcol = vec3(0.7, 0.6, 0.2);\n        col *= max(dot(li, nor), 0.2);\n        col += pow(max(dot(vec3(0.0, 0.0, 1.0), reflect(-li, nor)), 0.0), 30.0);\n        col = pow(col, vec3(0.8)); \n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}