{"ver":"0.1","info":{"id":"MsdBDj","date":"1526840299","viewed":1357,"name":"Top / Front / Side SDF Modelling","username":"fizzer","description":"Just a small shader to demonstrate that SDF modelling can be done using three 2D distance fields. One for each of top, front, and side projections. Click mouse button to see the result full-screen.","likes":60,"published":1,"flags":0,"usePreview":0,"tags":["sdf","csg","modelling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just a small shader to demonstrate that SDF modelling can be done using three 2D distance fields.\n// One for each of top, front, and side projections. What's nice about this from a practical\n// point of view is that the 3 maps can be stored as 2D textures, at a fraction of the storage cost of \n// a full 3D voxeliation or spare-voxel-octree.\n//\n// Click mouse button to see the result full-screen.\n//\n    \n#define SHAPE\t2\t// Can be 0, 1, or 2\n#define AA\t\t1\t// Anti-aliasing box size\n\nfloat box(vec2 p,vec2 s)\n{\n    p=abs(p)-s;\n    return max(p.x,p.y);\n}\n\n// The next set of functions define one 2D distance field for each axis. The fields are combined using\n// CSG intersect operation to create a 3D shape.\n\n#if SHAPE==0\n\nfloat stairs(vec2 p)\n{\n    float a=3.141592653589*2./8.;\n    vec2 p2=mat2(cos(a),sin(a),-sin(a),cos(a))*p;\n    float s=length(vec2(1))/30.;\n    float f=mod(p2.x+s,s)-s/2.;\n    vec2 n=vec2(cos(a),sin(a));\n    if(f<0.)\n        n.x=-n.x;\n    return dot(n,vec2(f,p2.y));\n}\nfloat Xprofile(vec2 p)\n{\n    p*=2.;\n    p.x=abs(p.x);\n    p.y-=.2;\n    return min(stairs(p),length(p)-.1)/2.;\n}\n\nfloat Yprofile(vec2 p)\n{\n    p*=2.;\n    return box(p,vec2(.4))/2.;\n}\n\nfloat Zprofile(vec2 p)\n{\n    p*=2.;\n    p.x=abs(p.x);\n    p.y-=.2;\n    return min(stairs(p),box(p,vec2(.02,.1)))/2.;\n}\n\n#elif SHAPE==1\n\nfloat Xprofile(vec2 p)\n{\n    p*=2.;\n    return max(box(p-vec2(0.,.1),vec2(.16,.3)),-box(p-vec2(0.,-.25),vec2(.1,.3)))/2.;\n}\n\nfloat Yprofile(vec2 p)\n{\n    p*=2.;\n    return box(p,vec2(.2,.15))/2.;\n}\n\nfloat Zprofile(vec2 p)\n{\n    p*=2.;\n    return max(max(box(p-vec2(0,.1),vec2(.16,.3)),-box(p-vec2(0,-.25),vec2(.1,.3))),\n               -box(p-vec2(0.1,.4),vec2(.19,.3)))/2.;\n}\n\n#else\n\nfloat Xprofile(vec2 p)\n{\n    return max(box(p,vec2(.16-p.y,.1)),-box(p-vec2(0,-.14),vec2(.05,.1)));\n}\n\nfloat Yprofile(vec2 p)\n{\n    return box(p,vec2(.17,.1));\n}\n\nfloat Zprofile(vec2 p)\n{\n    p.x=mod(p.x+1./16.,1./8.)-1./16.;\n    return min(box(p-vec2(0,.06),vec2(.17,.1)),distance(p,vec2(.0,-.07))-.03);\n}\n\n#endif\n\n// The signed distance field.\nfloat f(vec3 p)\n{\n    // Here each of the profile functions are sampled and combined using CSG intersect.\n    return min(p.y+.1,max(Zprofile(p.xy),max(Yprofile(p.xz),Xprofile(p.zy))));\n}\n\n// Orthonormal basis, based on code from PBRT.\nmat3 coordinateSystem(vec3 w)\n{\n    vec3 u = cross(w, vec3(1,0,0));\n    if (dot(u, u) < 1e-6)\n        u = cross(w, vec3(0,1,0));\n    return mat3(normalize(u), normalize(cross(u, w)), normalize(w));\n}\n\n// Signed distance field normal direction.\nvec3 getNormal(vec3 p)\n{\n    float d=f(p);\n    const vec2 e=vec2(1e-3,0);\n    vec3 n=vec3(f(p+e.xyy)-d,f(p+e.yxy)-d,f(p+e.yyx)-d);\n    return n;\n}\n\n// An approximate 'curvature' value (basically the amount of local change in the field normal).\n// It's not perfect, but I'm still working on it...\nfloat curvature(vec3 p)\n{\n    vec3 n=getNormal(p);\n\n    mat3 m=coordinateSystem(n);\n\n    const float e=1e-4;\n    vec3 n1=getNormal(p+m[0]*e);\n    vec3 n2=getNormal(p+m[1]*e);\n    vec3 n3=getNormal(p-m[0]*e);\n    vec3 n4=getNormal(p-m[1]*e);\n\n    return (length((n1-n3)/e)+length((n2-n4)/e))*5.;\n}\n\n// From IQ.\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n    const int steps = 9;\n    const float delta = .18;\n\n    float a = 0.0;\n    float weight = .5;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta; \n        a += weight*(d - f(p + n*d));\n        weight *= 0.99;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nvec3 distanceColourMap(float d)\n{\n    float lines=mix(.5,1.,smoothstep(-.5,.5,(min(fract(d*64.),1.-fract(d*64.))-.5)*3.)*2.);\n    return clamp(mix(vec3(lines)*vec3(.1),vec3(.5,.5,1.),step(d,0.))+d/3.+(1.-smoothstep(.00,.002,abs(d)-.002)),0.,1.);\n}\n\n// Analytically triangle-filtered checkerboard, from IQ\n// https://iquilezles.org/articles/morecheckerfiltering\nvec3 pri( in vec3 x )\n{\n    // see https://www.shadertoy.com/view/MtffWs\n    vec3 h = fract(x/2.0)-0.5;\n    return x*0.5 + h*(1.0-2.0*abs(h));\n}\n\nfloat checkersTextureGradTri( in vec3 p, in vec3 ddx, in vec3 ddy )\n{\n    vec3 w = max(abs(ddx), abs(ddy)) + 0.01;       // filter kernel\n    vec3 i = (pri(p+w)-2.0*pri(p)+pri(p-w))/(w*w); // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y*i.z;                  // xor pattern\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float an=.7;\n    vec2 t=fragCoord/iResolution.xy*2.-1.;\n\n    t.x*=iResolution.x/iResolution.y;\n\n    if(abs(t.x)>1.)\n    {\n        fragColor=vec4(0,0,0,1);\n        return;\n    }\n\n\tfloat full = step(0.5,iMouse.z);\n    \n    if(full>.5)\n    {\n        t=t*.5+.5;\n    }\n    \n    // Check which quadrant the pixel is in.\n    if(t.x<0.&&t.y<0.&&full<.5)\n    {\n        fragColor.rgb=distanceColourMap(Xprofile((t.xy*.5+.25)*1.5));\n    }\n    else if(t.x<0.&&t.y>0.&&full<.5)\n    {\n        fragColor.rgb=distanceColourMap(Yprofile((t.xy*.5+.25*vec2(1,-1))*1.5));\n    }\n    else if(t.x>0.&&t.y<0.&&full<.5)\n    {\n        fragColor.rgb=distanceColourMap(Zprofile((t.xy*.5+.25*vec2(-1,1))*1.5));\n    }\n    else\n    {\n        // Anti-aliasing loop.\n        vec3 c=vec3(0);\n        for(int y=-AA;y<=AA;++y)\n            for(int x=-AA;x<=AA;++x)\n            {\n                float u=float(x)*.25,v=float(y)*.25;\n                \n                // Set up the primary ray.\n                vec3 ro=vec3(0.,0.,1);\n                vec3 rd=normalize(vec3((t.xy+dFdx(t.xy)*u+dFdy(t.xy)*v)*.5-.25,-1.));\n\n                rd.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*rd.xz;\n                ro.xz=mat2(cos(an),sin(an),sin(an),-cos(an))*ro.xz;\n\n                // Get the ray directions of neighbouring pixels for this sample.\n                vec3 ddx_rd = rd + dFdx(rd);\n                vec3 ddy_rd = rd + dFdy(rd);\n\n                float s=20.;\n\n                // Trace primary ray.\n                float t=0.,d=0.;\n                for(int i=0;i<100;++i)\n                {\n                    d=f(ro+rd*t);\n                    if(d<1e-3||t>10.)break;\n                    t+=d;\n                }\n\n\n                vec3 rp=ro+rd*t;\n                vec3 n = normalize(getNormal(rp));\n\n                // Compute ray differentials (based on code from IQ)\n                vec3 ddx_pos = ro - ddx_rd*dot(ro-rp,n)/dot(ddx_rd,n);\n                vec3 ddy_pos = ro - ddy_rd*dot(ro-rp,n)/dot(ddy_rd,n);\n\n                // Calc texture sampling footprint (based on code from IQ)\n                vec3     uvw = rp*32.;\n                vec3 ddx_uvw = ddx_pos*32. - uvw;\n                vec3 ddy_uvw = ddy_pos*32. - uvw;\n\n                // Basic light value.\n                float l=.7+.3*dot(n,normalize(vec3(1)));\n                \n                // Ambient occlusion.\n                l*=ambientOcclusion(rp,n);\n                \n                // Depth cueing.\n                l*=exp(-t)*2.;\n\n                // Darken the geometric edges.\n                l*=clamp(1.-curvature(rp),0.,1.);\n\n                // Get a directional shadow.\n                t=0.;\n                d=0.;\n                ro=rp+n*1e-3;\n                rd=normalize(vec3(1,.3,1));\n                for(int i=0;i<40;++i)\n                {\n                    d=f(ro+rd*t);\n                    if(d<1e-3||t>10.)break;\n                    t+=d;\n                }\n\n                if(d<1e-3)\n                    l*=.3;\n\n                // Apply the filtered checkerboard texture.\n                c+=l*(.5+.5*checkersTextureGradTri( uvw, ddx_uvw, ddy_uvw ));\n            }\n        fragColor.rgb=c/((float(AA)*2.+1.)*(float(AA)*2.+1.));\n    }\n    \n    if(full<.5)\n    {\n    \t// Add separation lines.\n    \tfragColor.rgb=mix(fragColor.rgb,vec3(.1),step(min(abs(t.x),abs(t.y)),.004));\n    }\n    \n    fragColor.rgb=sqrt(max(fragColor.rgb,0.));\n}","name":"Image","description":"","type":"image"}]}