{"ver":"0.1","info":{"id":"DdjXDG","date":"1671765609","viewed":105,"name":"Second Degree Polies","username":"gee8sh","description":"Experimenting with rendering 2nd degree 3D polynomials as: p * A * p + p * B + C = 0, where A is a 3x3 arbitrary matrix, B is an arbitrary vector and C is a scalar, and p is the point at which we evaluate the polynomial.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","polynomials"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = atan(0.0, -1.0);\n\nconst float animationSpeed = 1.0 / 64.0;\nconst vec3 color = vec3(0.2, 0.4, 0.8);\n\n// Observer params\nconst float focalLength = 2.0;\nconst float distanceToPoly = 8.0;\n\n// Sun params\nconst vec3 sunDirection = normalize(vec3(1.0, 1.0, 2.0));\nconst float sunDistance = 128.0;\n\n// Poly\nconst mat3 A0 = mat3(\n    vec3( 3.0,  5.0,  7.0),\n    vec3(11.0, 13.0, 17.0),\n    vec3(19.0, 23.0, 29.0)\n);\nconst vec3 B0 = vec3(1.0, 2.0, 4.0); \nconst float C = 3.0;\n\nconst mat3 diag = 0.5 * PI * mat3(\n    vec3(1.0, 0.0, 0.0),\n    vec3(0.0, 1.0, 0.0),\n    vec3(0.0, 0.0, 1.0)\n);\n\n// Precalculated values\nconst vec3 orig = vec3(0.0, 0.0, distanceToPoly);\nconst float distanceToPolySquared = distanceToPoly * distanceToPoly;\n\nvec4 shootPoly(in vec3 ray, in mat3 A, in mat3 A2, in vec3 B) {\n    float a = dot(ray, A * ray);\n    float b = dot(ray, A2 * orig + B);\n    float c = dot(orig, A * orig) + dot(orig, B) - C;\n    float halfB = 0.5 * b;\n    float hitDistance = 0.0;\n    if (a != 0.0) {\n        float delta = abs(halfB * halfB - a * c);\n        float sqrtD = sqrt(delta);\n        float d1 = (-halfB - sqrtD) / a;\n        float d2 = (-halfB + sqrtD) / a;\n        hitDistance = d1 <= d2\n            ? (d1 >= 0.0 ? d1 : d2) \n            : (d2 >= 0.0 ? d2 : d1);\n    } else if (halfB != 0.0) {\n        hitDistance = -c / b;\n    }\n    return vec4(hitDistance * ray + orig, hitDistance > 0.0 ? 1.0 : 0.0);\n}\n\nvec4 calcNormal(in vec4 hitPosition, in vec3 ray, in mat3 A2, in vec3 B) {\n    vec3 n = normalize(A2 * hitPosition.xyz + B);\n    float f = -dot(n, ray);\n    return vec4(n * sign(f), f);\n}\n\nvec3 calcColor(in vec3 ray, in vec3 normal, float f) {\n    vec3 c = (f > 0.0 ? color : color.bgr); \n    return c + 2.0 * pow(max(dot(reflect(ray, normal), sunDirection), 0.0), sunDistance);\n}\n\nfloat calcShade(vec3 normal, float hit) {\n    float l = dot(normal, sunDirection);\n    return hit * max(l, 0.0);\n}\n\nvec4 sampleColor(in vec2 xy, in mat3 A, in mat3 A2, in vec3 B) {\n    vec3 ray = normalize(vec3(xy, -focalLength));\n    vec4 hitPosition = shootPoly(ray, A, A2, B);\n    vec4 n = calcNormal(hitPosition, ray, A2, B);\n    vec3 normal = n.xyz;\n    float f = n.w;\n    vec3 color = calcColor(ray, normal, f);\n    float shade = calcShade(normal, hitPosition.w);\n    return vec4(shade * color, 1.0);\n    //return vec4(normal, 1.0);\n}\n\nvec2 pixelCoordinates(in vec2 fragCoord, in float halfPixelSize) {\n    float aspect = iResolution.x * halfPixelSize;\n    return 2.0 * halfPixelSize * fragCoord - vec2(aspect, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float halfPixelSize = 1.0 / iResolution.y;\n\n    vec2 xy = pixelCoordinates(fragCoord, halfPixelSize);\n    \n    float time = iTime * animationSpeed;\n    \n    mat3 A = mat3(\n        sin(A0[0] * time + diag[0]),\n        sin(A0[1] * time + diag[1]),\n        sin(A0[2] * time + diag[2])\n    );\n    mat3 AT = transpose(A); \n    mat3 A2 = A + AT; \n    vec3 B = sin(B0 * time);\n    \n    fragColor = sqrt(0.25 * (\n        sampleColor(xy, A, A2, B) + \n        sampleColor(xy + vec2(halfPixelSize, 0.0), A, A2, B) + \n        sampleColor(xy + vec2(0.0, halfPixelSize), A, A2, B) + \n        sampleColor(xy + vec2(halfPixelSize), A, A2, B)\n    ));\n}\n\n","name":"Image","description":"","type":"image"}]}