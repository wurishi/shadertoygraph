{"ver":"0.1","info":{"id":"flSGDy","date":"1624568546","viewed":68,"name":"Ball of Saturation 2","username":"egon","description":"Color-wheel using hsv for the ball and outer circle.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["colorwheel"],"hasliked":0,"parentid":"NtB3DG","parentname":"Ball of Saturation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU (2.0*3.1415926538)\n\nvec2 rot(vec2 pos, float a) {\n\tfloat sn = sin(a);\n\tfloat cs = cos(a);\n\treturn mat2(cs, -sn, sn, cs) * pos;\n}\n\nfloat map(float p, float ss, float se, float ds, float de)\n{\n    return ds + (p-ss)*(de-ds)/(se-ss);\n}\n\nfloat shade(vec2 pos, float dir) {\n    pos = rot(pos, dir);\n    float h = cos(pos.x);\n    return map(pos.y, h, -h, 0.0, 1.0);\n}\n\n//http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 hsv2rgb_subtractive( in vec3 c ) {\n    float frac = fract(c.x)*6.0;\n    vec3 col = smoothstep(vec3(3,0,3),vec3(2,2,4),vec3(frac));\n    col += smoothstep(vec3(4,3,4),vec3(6,4,6),vec3(frac)) * vec3(1, -1, -1);\n    return mix(vec3(1), col, c.y) * c.z;\n}\n\n\n// CIELab to rgb conversion from https://www.shadertoy.com/view/llcXDN\n\nfloat ref_X = 95.047;\nfloat ref_Y = 100.000;\nfloat ref_Z = 108.883;\n\nvec3 xyz2rgb(vec3 xyz) {\n    float var_X = xyz[0] * 0.01;\n    float var_Y = xyz[1] * 0.01;\n    float var_Z = xyz[2] * 0.01;\n    \n    float var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;\n    float var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;\n    float var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;\n    \n    if (var_R > 0.0031308) var_R = 1.055 * pow(var_R, 1.0/2.4) - 0.055;\n    else var_R = 12.92 * var_R;\n    if (var_G > 0.0031308) var_G = 1.055 * pow(var_G, 1.0/2.4) - 0.055;\n    else var_G = 12.92 * var_G;\n    if (var_B > 0.0031308) var_B = 1.055 * pow(var_B, 1.0/2.4) - 0.055;\n    else var_B = 12.92 * var_B;\n    \n    return vec3(var_R,var_G,var_B);\n}\n\nvec3 cielab2xyz(vec3 lab) {\n    float var_Y = (lab[0] + 16.0) / 116.0;\n    float var_X = lab[1] / 500.0 + var_Y;\n    float var_Z = var_Y - lab[2] / 200.0;\n    \n    \n\tfloat py = var_Y*var_Y*var_Y;\n    float px = var_X*var_X*var_X;\n    float pz = var_Z*var_Z*var_Z;\n\n    if (py > 0.008856) var_Y = py;\n    else var_Y = (var_Y - 16.0 / 116.0) / 7.787;\n    if (px > 0.008856) var_X = px;\n    else var_X = (var_X - 16.0 / 116.0) / 7.787;\n    if (pz > 0.008856) var_Z = pz;\n    else var_Z = (var_Z - 16.0 / 116.0) / 7.787;\n    \n    float X = ref_X * var_X;\n    float Y = ref_Y * var_Y;\n    float Z = ref_Z * var_Z;\n    return vec3(X, Y, Z);\n}\n\nvec3 cielab2rgb(vec3 lab) {\n    return xyz2rgb(cielab2xyz(lab));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord;\n    vec2 center = iResolution.xy * 0.5;\n    \n    float inside  = 0.3 * iResolution.y;\n    float mid     = 0.35 * iResolution.y;\n    float outside = 0.45 * iResolution.y;\n    \n    vec2 off = center - uv;\n\n    float h = mod(iTime*0.1, 1.0);\n    if(iMouse.z > 0.0){\n        vec2 p = normalize(center - iMouse.xy);\n        h = atan(-p.y, -p.x) / TAU;\n    }\n\n    float d = length(off);\n    if(d < inside){\n        off /= inside;\n\n        float v = shade(off, 0.0/3.0 * TAU);\n        float s = shade(off, -1.0/4.0 * TAU);\n\n        fragColor = vec4(hsv2rgb(vec3(h, s, v)), 1.0);\n    } else if (mid < d && d < outside) {\n        off = normalize(off);\n        float h = atan(-off.y, -off.x) / TAU;\n        fragColor = vec4(hsv2rgb_subtractive(vec3(h, 0.85, 1.0)), 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.13, 0.15, 1.0);\n    }\n}\n\n","name":"Image","description":"","type":"image"}]}