{"ver":"0.1","info":{"id":"lXVXWV","date":"1720614866","viewed":20,"name":"SDF material blender","username":"aidanwyber","description":"Blends materials based on 1 / sd for each sphere, see lines 120 & 121\nBump up AA to 2 if you're computer can handle it.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mix","sdf","raymarcher","material"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 1\n#define time iTime*0.15\n\n#define K_SHAPE_SMOOTHING 0.10\n#define K_MAT_SMOOTHING 2.\n#define K_SM_FREQ 50.\n#define K_SM_AMP 0.006\n\n#define ENV_COL vec3(0.282,0.396,0.396)\n\nstruct Mat {\n    int id;\n    vec3 col;\n    float hardness; // log scale\n    float reflectivity;\n    vec4 fresnell; // col, amount\n};\n\nMat[] mats = Mat[] (\n    Mat(0, vec3(1.000,0.918,0.000), 1.0, .5, vec4(vec3(1.000,0.733,0.000), 0.0)), // pool ball yellow\n    Mat(0, vec3(0.302,0.569,1.000), 0.6, .5, vec4(vec3(1.000,1.000,1.000), 0.0)), // plasticy blue\n    Mat(1, vec3(0.651,0.000,1.000), 0.0, .5, vec4(vec3(1.000,0.580,0.761), 0.7)), // velvety purple\n    Mat(1, vec3(0.059,0.059,0.059), 0.2, .5, vec4(vec3(1.000,1.000,1.000), 0.0))  // rubbery black\n);\n\nMat mixMat(Mat a, Mat b, float q) {\n    return Mat(\n    -1,\n    mix(a.col, b.col, q),\n    mix(a.hardness, b.hardness, q),\n    mix(a.reflectivity, b.reflectivity, q),\n    mix(a.fresnell, b.fresnell, q)\n    );\n}\n\nstruct MatMixVector {\n    float[mats.length()] fractions;\n};\n\nMat mixedMat(MatMixVector mmv) {\n    Mat mm = Mat(0, vec3(0.), 0., 0., vec4(0.));\n    for (int i = 0; i < mmv.fractions.length(); i++) {\n        float fi = mmv.fractions[i];\n        Mat mi = mats[i];\n        mm.col += fi * mi.col;\n        mm.hardness += fi * mi.hardness;\n        mm.reflectivity += fi * mi.reflectivity;\n        mm.fresnell += fi * mi.fresnell;\n    }\n    return mm;\n}\n\n\nstruct Sphere {\n    vec3 pos;\n    float r;\n    float m;\n    int matId;\n};\nSphere[] spheres = Sphere[] (\n    Sphere(vec3(0.), 0.500, 1., 0),\n    Sphere(vec3(0.), 0.450, 1., 1),\n    Sphere(vec3(0.), 0.350, 1., 2),\n    Sphere(vec3(0.), 0.150, 1., 3),\n    Sphere(vec3(0.), 0.150, 1., 3),\n    Sphere(vec3(0.), 0.150, 1., 3),\n    Sphere(vec3(0.), 0.150, 1., 3)\n);\n\n\nstruct SceneIntersection {\n    float d; // distance to scene\n    vec3 pos; // scene position\n    vec3 normal;\n    Mat mat;\n};\n\n\nfloat sdSphere(vec3 pos, Sphere s) {\n    return length(pos - s.pos) - s.r;\n}\n\n\nvec2 smin( float a, float b, float k ) {\n    k *= 6.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n\nstruct SDFMat {\n    float sd;\n    MatMixVector mmv;\n};\n\nSDFMat sdSceneAndMatMix(in vec3 pos) {\n    float sd = 1e4;\n    float[] matVals = float[](0., 0., 0., 0.);\n    \n    float kSmin = K_SHAPE_SMOOTHING * (1. + sin(dot2(pos) * K_SM_FREQ - iTime * 10.) * K_SM_AMP);\n    \n    int n = spheres.length();\n    for (int i = 0; i < n; i++) {\n        Sphere s = spheres[i];\n        s.m = s.r * s.r * s.r * 10.;\n        \n        vec3 sphPos = vec3(\n            sin(float(i)*130. + time + PHI * 0. * TAU),\n            sin(float(i)*209. + time + PHI * 1. * TAU),\n            sin(float(i)*426. + time + PHI * 2. * TAU)\n        ) * cos(time + float(i) * PHI * TAU) * 1.2;\n        \n        float sdi = sdSphere(pos - sphPos, s);\n        vec2 sminRes = smin(sd, sdi, kSmin);\n        sd = sminRes.x;\n        \n        float matWeightDistFactor = 1. / (1. + pow(abs(sdi), 60.));\n        matVals[s.matId] += 1. / (pow(sdi, K_MAT_SMOOTHING) + 2e-2);\n\n        if (i == 0) sd = sdi;\n    }\n\n    // normalize mat vals array\n    int nMats = mats.length();\n    float matValsSum = 0.;\n    for (int j = 0; j < nMats; j++) {\n        matValsSum += matVals[j];\n    }\n    for (int j = 0; j < nMats; j++) {\n        matVals[j] /= matValsSum;\n    }\n    \n    MatMixVector mmv = MatMixVector(matVals);\n    return SDFMat(sd, mmv);//fract(sin(sd*1000.)));\n}\n\nvec3 calcNormal(in vec3 pos) {\n    // tetrahedron method\n    const vec2 e = vec2(1.0,-1.0)*0.5773*0.005;\n    return normalize(\n        e.xyy * sdSceneAndMatMix(pos + e.xyy).sd + \n        e.yyx * sdSceneAndMatMix(pos + e.yyx).sd + \n        e.yxy * sdSceneAndMatMix(pos + e.yxy).sd + \n        e.xxx * sdSceneAndMatMix(pos + e.xxx).sd\n    );\n}\n\nstruct RayMarchRes {\n    float d;\n    MatMixVector mmv;\n};\n\nRayMarchRes rayMarch(vec3 ro, vec3 rd) {\n    const float maxD = 20.0;\n    \n    RayMarchRes res;\n    float d = 0.0;\n    for (int i = 0; i < 512; i++) {\n\t    SDFMat hit = sdSceneAndMatMix(ro + rd * d); // next closest hit\n        \n        if ((hit.sd < 0.0) || (d > maxD))\n            break;\n        \n        d += hit.sd;\n        res = RayMarchRes(d, hit.mmv);\n    }\n    if (d > maxD) res = RayMarchRes(-1., MatMixVector(float[] (0., 0., 0., 0.)));\n\treturn res;\n}\n\nSceneIntersection intersectScene(vec3 ro, vec3 rd) {\n    RayMarchRes res = rayMarch(ro, rd);\n    \n    vec3 pos = res.d * rd + ro;\n    vec3 normal = calcNormal(pos);\n    Mat mat = mixedMat(res.mmv);\n    \n    return SceneIntersection(\n        res.d,\n        pos,\n        normal,\n        mat\n    );\n}\n\nstruct Light {\n    vec3 pos;\n    float lum;\n    vec3 col;\n};\nLight[] lights = Light[](\n    Light(vec3(0.), 1., vec3(1.000,1.000,1.000)),\n    Light(vec3(0.), 1., vec3(1.000,0.533,0.000)),\n    Light(vec3(0.), 1., ENV_COL)\n);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 timeCirc = vec2(sin(time), cos(time));\n    vec2 mouse = (iMouse.xy / iResolution.xy * 2. - 1.) * -vec2(1., -1.);\n    \n    vec3 aaCol = vec3(0.);\n    for (int AAx = 0; AAx < AA; AAx++) {\n        for (int AAy = 0; AAy < AA; AAy++) {\n            vec2 aa = vec2(AAx, AAy) / float(AA);\n            \n            vec2 uv = fragCoord / iResolution.xy + aa;\n            vec2 pos = (fragCoord + aa - iResolution.xy * 0.5) / iResolution.y * 2.;\n\n\n    vec3 ta = vec3(0.);\n    vec3 cam = vec3(0., 0., -5.);\n    //cam.xz = timeCirc * 10.;\n    vec3 lookAt = ta - cam;\n    \n    vec3 ww = normalize(lookAt);\n    vec3 uu = cross(ww, vec3(0.,1.,0.));\n    vec3 vv = cross(uu, ww);\n    \n    float planeScale = 0.25;\n    vec3 fragPos = cam + ww + pos.x * planeScale * uu + pos.y * planeScale * vv;\n    \n    // 360 cam view from origin\n    //cam = vec3(0., 0., -1.);\n    //fragPos = spherical(pos.x * PI / 2., pos.y * PI / 2. + PI/2., 1.) + cam;\n    \n    vec3 rd = normalize(fragPos - cam);\n    vec3 ro = cam;\n    \n    SceneIntersection si = intersectScene(ro, rd);   \n    \n    vec3 col = pow(ENV_COL * mix(1., 0.3, uv.y), vec3(1., 0.8, 0.67));\n    \n    if (si.d > 0.) { \n        col = ENV_COL * 0.;\n        \n        float lightTime = time * 3.;\n        for (int l = 0, nLights = lights.length(); l < nLights; l++) {\n            Light light = lights[l];\n                   \n            light.pos =  vec3(\n                sin(float(l)*130. + lightTime + PHI),\n                sin(float(l)*209. + lightTime + E),\n                sin(float(l)*426. + lightTime)\n            ) * (20. - float(l) * 6.);\n            \n            vec3 ld = normalize(si.pos - light.pos);\n            \n            float specV = max(dot(ld, si.normal), 0.) * light.lum;\n            vec3 spec = light.col * mix(0.05, 1., specV);\n            float hlight = si.mat.hardness * pow(specV, exp2(si.mat.hardness * 11. + 1.));\n            col += si.mat.col * mix(spec, WHITE, 0.);\n            col += hlight * lights[l].col;\n        }\n        \n        //vec3 refl = cross(si.normal, rd);\n        \n        float fresnell = 1. - abs(dot(rd, si.normal));\n        col = mix(col, si.mat.fresnell.rgb, fresnell * si.mat.fresnell.a);\n        \n        // ambient light?\n        col = mix(ENV_COL, col, 0.95);//, mix(0.3, 1., max(max(col.r, col.g), col.b)));\n    }\n   \n    col = pow(col,vec3(0.4545)); // gamma\n    col *= 0.9;\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n    \n    //col = vec3(0.);\n        \n            aaCol += col;\n        }\n    }\n    aaCol /= float(AA * AA);\n    \n    fragColor = vec4(aaCol, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI             3.14159265358979323846264\n#define TAU            6.28318530717958647692528\n#define SQRT_2         1.41421356237309504880169\n#define PHI            1.61803398874989484820459\n#define E              2.71828182845904523536028\n\n#define WHITE          vec3(1.)\n#define BLACK          vec3(0.)\n\nfloat dot2(in vec2 v) { return dot(v, v); }\n\n#define sq(x) (x)*(x)\n#define circleMap(x) sqrt(1. - sq(x - 1.))\n\n#define nmc(x) (-cos(x) * 0.5 + 0.5)\n#define nmc2(x) nmc(nmc(x) * PI)\n\n#define sat(x) clamp(x, 0., 1.)\n\nfloat map(in float x, in float xmin, in float xmax, in float ymin, in float ymax) {\n  return (x - xmin) / (xmax - xmin) * (ymax - ymin) + ymin;\n}\n\nfloat mpow(in float x, in float p) {\n  // mini pow for mapping\n  float v = 2. * x - 1.;\n  return (pow(abs(v), p) * sign(v)) * 0.5 + 0.5;\n}\n\nfloat sigmoid(in float x) { // [0, 1]\n  return 1. / (1. + exp(-x));\n}\nvec2 sigmoid(in vec2 v) { return vec2(sigmoid(v.x), sigmoid(v.y)); }\nvec3 sigmoid(in vec3 v) { return vec3(sigmoid(v.r), sigmoid(v.g), sigmoid(v.b)); }\n\n#define dot2(x) dot(x, x)\n\nvec3 spherical(in float alpha, in float beta, in float radius) {\n  return vec3(\n    cos(alpha) * cos(beta) * radius,\n    sin(alpha) * radius,\n    cos(alpha) * sin(beta) * radius\n  );\n}\n\nvec2 rotate(in vec2 v, in float theta) {\n  float s = sin(theta);\n  float c = cos(theta);\n  return mat2(c, -s, s, c) * v;\n}\n#define rot(v, th) rotate(v, th)\n\n\n\n","name":"Common","description":"","type":"common"}]}