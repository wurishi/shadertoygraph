{"ver":"0.1","info":{"id":"4ddSDB","date":"1461284177","viewed":462,"name":"Motion Blur Fun","username":"drone1","description":"If you see something silly or have feedback, please don't hesitate to leave a comment, as I'm here to learn!\n\nClick to slow down or speed up the simulation (left=faster, right=slower).\n\nPlease see code for more info.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","motionblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n   I haven't messed around w/ motion blur for a while and was inspired by HLorenzi's\n   shader ( https://www.shadertoy.com/view/XdXXz4 ). I wanted to try and do my own \n   version from scratch for some practice (and hopefully to learn something from any\n   comments!).\n\n   Basically, if this was done as intended, it should be simulating a camera shutter\n   opening and closing, where the shutter is closed at 0% of a given frame, fully open\n   at 25%, fully closed at 50% and stays closed until the next frame begins. Make sense?\n   Hopefully I'm describing this well. I believe this is a classic kind of motion blur,\n   but I'm a total graphics noob, so I'm not sure what it's called.\n\n   Thanks in advance for any feedback! This site is so cool.\n\n   Question: Anyone know why there is banding if you disable dithering?\n*/\n\n// Comment this out for banding fun\n#define DITHERING_ENABLED\n\n// Assumed framerate\n#define FRAMERATE\t\t60\n\n// Number of subframes for shutter open and shutter closed.\n#define NUM_SUBFRAMES\t64\n\n// Falloff exponent, applied to the falloff function (sin)\n#define FALLOFF_EXP\t\t1.0\n\n// Other stuff\n#define PI\t\t\t\t3.141592653\n\n// Antialiased circle\nfloat circle( vec2 uv, float r )\n{\n    return 1.0 - smoothstep( r - 0.005, r + 0.005, length( uv ) );\n}\n\nvec3 scene( vec2 uv, float t )\n{\n    vec3 clr = vec3( 0.0 );\n    \n    t *= 10.0 * mix( 0.9, 0.1, iMouse.x / iResolution.x );\n\tclr += vec3( circle( uv + 3.0 * vec2( 0.25 * cos( 2.0 * t * PI ), 0.25 * sin( 2.0 * t * PI ) ), 0.2 ) );\n\t\n    t *= 1.5;\n    clr += vec3( circle( uv + 1.75 * vec2( -1.0 + mod( t, 2.0 ), 0.25 * sin( t ) ), 0.10 ) );\n    \n    return clr;\n}\n\nvec3 render( vec2 uv )\n{\n    // Accumulate 2xNUM_SUBFRAMES frames where the first NUM_SUBFRAMES is simulating the camera shutter opening\n    // (with it fully open in the exact middle, and closing thereafter), followed by NUM_SUBFRAMES where the\n    // shutter is completely closed.\n    \n    const float frame_duration = 1.0 / float( FRAMERATE );\n    float frame_start_time = floor( iTime * float( FRAMERATE ) ) * frame_duration;\n    float frame_subtime = iTime - frame_start_time;\t// time relative to the render frame start\n    float shutter_open_duration = frame_duration * 0.5;\n    float shutter_open_subframe_duration = shutter_open_duration / float( NUM_SUBFRAMES );\n    \n    vec3 clr = vec3( 0.0 );\n    float w_sum = 0.0;\n    \n    // Accumulate light/color for all subframes where the shutter is open\n    for ( int i = 0; i < NUM_SUBFRAMES; ++i )\n    {\n        float time = frame_start_time - // quantized based on assumed framerate\n            frame_duration +\n            float( i ) * shutter_open_subframe_duration;\n        \n        // w should be 1.0 in the middle, when the shutter is fully open, and fall off from there.\n        float w = pow( 0.5 + 0.5 * sin( PI * float( i ) / float( NUM_SUBFRAMES - 1 ) ), FALLOFF_EXP );\n\n        // Blend in scene at the given time, with the given weight\n        clr += w * scene( uv, time );\n\n        // Accumulate w so we can normalize the resultant color\n        w_sum += w;\n    }\n\n    // Normalize\n    clr /= w_sum;\n    \n    // Dither to remove banding\n#ifdef DITHERING_ENABLED\n    clr += 0.08 * fract( 2973.234 * sin( dot( uv, vec2( 234.7863, 966952.235 ) ) ) );\n#endif\n    \n    return clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\tfragColor = vec4( render( uv ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}