{"ver":"0.1","info":{"id":"Mt3yW4","date":"1532590347","viewed":164,"name":"Fractal bitflipping","username":"dust","description":"Inspired by https://www.shadertoy.com/view/4ldcW8; converts xor/or integer pairs to float, then treats them as complex coordinates [z] for a Mandelbrot distance estimator.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbrot","xor","or","bitflip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Choose fractal zoom + offset here\n#define ZOOM 20.0f\n#define OFFS vec2(-293.434260776)\n\n// Maximum allowed number of fractal iterations\n#define MAX_JULIA_ITER 2048.0\n\n// Small convenience function to change the fractal zoom over time\nfloat zoomAnim()\n{\n    float sinCycle = sin(iTime / 100.0);\n    int cycleNum = int(sinCycle / 0.35);\n    float cycle = mod(sinCycle, 0.35);\n    if (cycleNum % 2 != 0) { return 0.35 - cycle; }\n    else { return cycle; }\n}\n\n// Julia DE reduced from:\n// https://www.shadertoy.com/view/XtXfzj\nfloat JuliaDE(vec2 srcCoord,\n              out vec2 iterZ,\n              out float iterN)\n{\n\t// Convert given coordinates (expected as integers) to the floating range 0...1.0,\n    // then scale into the Julia domain (-2.0.xx, 2.0.xx)\n    vec2 z = (srcCoord / (ZOOM * zoomAnim())) + OFFS;\n    vec2 c = z;\n        \n    // Iterations\n    float maxDist = 200.0;\n    vec2 dz = vec2(1, 0);\n    float iter = 0.0;\n    while (iter < MAX_JULIA_ITER &&\n           length(z) < maxDist)\n    {\n        dz = 2.0 * PolyMul(z, dz);\n    \tz = PolyMul(z, z) + c;\n        iter += 1.0;\n    }\n    \n    // Export iteration count\n    iterN = iter;\n    \n    // Export the iterated coordinate [z]\n    iterZ = z;\n    \n    // Final distance\n    float r = length(z);\n    float dr = length(dz);\n    return 0.5 * r * log(r) / dr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate initial bits\n    int xor = int(fragCoord.x) \n        \t  ^ \n        \t  int(fragCoord.y);\n    int or = int(fragCoord.x)\n        \t |\n        \t int(fragCoord.y);\n    \n    // Iterate the Mandelbrot function for [xor] and [or]\n    float iterCount;\n    vec2 iterBits;\n    float iterBitDist = JuliaDE(vec2(xor, or),\n                               \titerBits,\n                                iterCount);\n    \n    // Synthesize output colour\n    vec3 rgb = vec3(iterBits.x, iterBits.y, 1.0) + vec3(sin(iterBitDist));\n    \n    // Slightly brighten\n    rgb = sqrt(rgb);\n    \n    // Minimize yellow tones\n    if (rgb.b < rgb.r &&\n        rgb.b < rgb.g)\n    {\n    \trgb.b = max(rgb.b, 0.8);    \n    }\n    \n    // Output the generated color to the display\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 PolyMul(vec2 a, vec2 b)\n{\n    return vec2((a.x * b.x) - (a.y * b.y), \n                (a.x * b.y) + (a.y * b.x));\n}","name":"Common","description":"","type":"common"}]}