{"ver":"0.1","info":{"id":"tdsfzB","date":"1588651192","viewed":183,"name":"PBR Sun demo","username":"16807","description":" Click to zoom (3rd person) or rotate (1st person).  Set IS_FIRST_PERSON_POV = true to view from the surface.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sun","pbr","emission"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nstruct maybe_int\n{\n    int value;\n    bool exists;\n};\nstruct maybe_float\n{\n    float value;\n    bool exists;\n};\nstruct maybe_vec2\n{\n    vec2 value;\n    bool exists;\n};\nstruct maybe_vec3\n{\n    vec3 value;\n    bool exists;\n};\nstruct maybe_vec4\n{\n    vec4 value;\n    bool exists;\n};\nconst float PI = 3.14159265358979323846264338327950288419716939937510;\nconst float PHI = 1.6180339887;\nconst float BIG = 1e20;\nconst float SMALL = 1e-20;\n\n/*\nGENERIC MATH UTILITY FUNCTIONS\nfunctions not associated to any subject in particular\n*/\n\n/*\n`erf` is an approximation of the \"error function\": ∫exp(-x²)dx.\nIts average error is no greater than 10⁻⁴ over the range [0,10]\n*/\nfloat erf(in float x)\n{\n    return tanh(0.1*x*x*x + 1.1295*x);\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -log(exp(-a*k)+exp(-b*k))/k;\n}\nfloat smax(float a, float b, float k)\n{\n    return log(exp(a*k)+exp(b*k))/k;;\n}\n\n/*\nNOISE FUNCTIONS\n*/\nfloat noise(float seed, float a, float b)\n{\n    return fract(sin(seed * a) * b);\n}\n\nfloat noise (float seed)\n{\n    return noise(seed, 2.4432, 1.5465);\n}\n\nvec2 noise2(vec2 seeds)\n{\n\treturn vec2(noise(seeds.x), noise(seeds.y));   \n}\n\nvec3 noise3(vec3 seeds)\n{\n\treturn vec3(noise(seeds.x), noise(seeds.y), noise(seeds.z));   \n}\nvec4 noise4(vec4 seeds)\n{\n\treturn vec4(noise(seeds.x), noise(seeds.y), noise(seeds.z), noise(seeds.w));   \n}\n\n/*\nMENSURATION\nthis file contains functions for finding perimeters, areas, \nsurface areas, and volumes of primitive shapes\n*/\nfloat get_perimeter_of_circle(\n    in float radius\n) {\n    return 2.*PI*radius;\n}\nfloat get_area_of_circle(\n    in float radius\n) {\n    return PI*radius*radius;\n}\nfloat get_perimeter_of_triangle(\n    in vec2 vertex1,\n    in vec2 vertex2,\n    in vec2 vertex3\n) {\n    return length(vertex1-vertex2) + length(vertex2-vertex3) + length(vertex3-vertex1);\n}\nfloat get_area_of_triangle(\n    in vec2 vertex1,\n    in vec2 vertex2,\n    in vec2 vertex3\n) {\n    // half the magnitude of the cross product\n    return 0.5f * abs((vertex1.x*(vertex2.y-vertex3.y) + vertex2.x*(vertex3.y-vertex1.y)+ vertex3.x*(vertex1.y-vertex2.y)));\n}\nfloat get_surface_area_of_sphere(\n    in float radius\n) {\n    return 4.*PI*radius*radius;\n}\nfloat get_volume_of_sphere(\n    in float radius\n) {\n    return 4./3.*PI*radius*radius*radius;\n}\nfloat get_surface_area_of_tetrahedron(\n    in vec3 vertex1,\n    in vec3 vertex2,\n    in vec3 vertex3,\n    in vec3 vertex4\n) {\n    // each face is half the magnitude of the cross product\n    return 0.5f * (\n        length(cross(vertex1-vertex2, vertex1-vertex3)) +\n        length(cross(vertex1-vertex2, vertex1-vertex4)) +\n        length(cross(vertex1-vertex3, vertex1-vertex4)) +\n        length(cross(vertex2-vertex3, vertex2-vertex4))\n    );\n}\nfloat get_volume_of_tetrahedron(\n    in vec3 vertex1,\n    in vec3 vertex2,\n    in vec3 vertex3,\n    in vec3 vertex4\n) {\n    // 1/6 the volume of a parallelipiped, which is the scalar triple product of its edges\n    return dot(cross(vertex1-vertex2, vertex1-vertex3), vertex1-vertex4) / 6.f;\n}\n// 2D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nbool is_2d_point_in_circle(in vec2 A0, in vec2 B0, in float r)\n{\n    return length(A0-B0) < r;\n}\n/*\nA0 point position\nB0 ellipsis center\nR  ellipsis radius along each coordinate axis\n*/\nbool is_2d_point_in_ellipsis(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    return length((A0-B0)/R) < 1.0;\n}\n/*\nA0 point position\nB0 rectangle center\nR  rectangle length along each coordinate axis\n*/\nbool is_2d_point_in_axis_aligned_rectangle(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    return all(lessThan(abs((A0-B0)/R), vec2(1)));\n}\n/*\nA0 point position\nB0 line reference\nN  surface normal of region, normalized\n\nNOTE: in this case, N only needs to indicate the direction facing outside, \n it need not be perfectly normal to B\n*/\nbool is_2d_point_in_region_bounded_by_line(in vec2 A0, in vec2 B0, in vec2 N)\n{\n    return dot(A0-B0, N) < 0.;\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\n*/\nbool is_2d_point_in_triangle(in vec2 A0, in vec2 B1, in vec2 B2, in vec2 B3)\n{\n    // INTUITION: if A falls within a triangle,\n    //  the angle between A and any side will always be less than the angle\n    //  between that side and the side adjacent to it\n    vec2 B2B1hat = normalize(B2-B1);\n    vec2 B3B2hat = normalize(B3-B2);\n    vec2 B1B3hat = normalize(B1-B3);\n    return dot(normalize(A0-B1), B2B1hat) > dot(-B1B3hat, B2B1hat)\n        && dot(normalize(A0-B2), B3B2hat) > dot(-B2B1hat, B3B2hat)\n        && dot(normalize(A0-B3), B1B3hat) > dot(-B3B2hat, B1B3hat);\n}\n// 3D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nbool is_3d_point_in_sphere(in vec3 A0, in vec3 B0, in float r)\n{\n    return length(A0-B0) < r;\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  radius\n*/\nbool is_3d_point_in_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    return length((A0-B0)/R) < 1.0;\n}\n/*\nA0 point position\nB0 rectangle center\nR  rectangle length along each coordinate axis\n*/\nbool is_3d_point_in_axis_aligned_rectangle(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    return all(lessThan(abs((A0-B0)/R), vec3(1)));\n}\n/*\nA0 point position\nB0 plane reference\nN  vertex normal\n*/\nbool is_3d_point_in_region_bounded_by_plane(in vec3 A0, in vec3 B0, in vec3 N)\n{\n    return dot(A0-B0, N) < 0.;\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\nbool is_3d_point_in_tetrahedron(in vec3 A0, in vec3 B1, in vec3 B2, in vec3 B3, in vec3 B4)\n{\n    // INTUITION: for each triangle, make sure A0 lies on the same side as the remaining vertex\n    vec3 B2xB3 = cross(B2-B1, B3-B1);\n    vec3 B3xB1 = cross(B3-B2, B1-B2);\n    vec3 B1xB2 = cross(B1-B3, B2-B3);\n   return sign(dot(A0-B1, B2xB3)) == sign(dot(B4-B1, B2xB3))\n        && sign(dot(A0-B2, B3xB1)) == sign(dot(A0-B2, B3xB1))\n        && sign(dot(A0-B3, B1xB2)) == sign(dot(A0-B3, B1xB2))\n        ;\n}\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nfloat get_distance_of_2d_point_to_circle(in vec2 A0, in vec2 B0, in float r)\n{\n    return length(A0-B0) - r;\n}\n/*\nA0 point position\nB0 box center\nB  box dimentsions\n*/\nfloat get_distance_of_2d_point_to_rectangle(in vec2 A0, in vec2 B0, in vec2 B)\n{\n  vec2 q = abs(B0) - B;\n  return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n/*\nA0 point position\nB0 ellipsis center\nR  ellipsis radius along each coordinate axis\n*/\nfloat guess_distance_of_2d_point_to_ellipsis(in vec2 A0, in vec2 B0, in vec2 R)\n{\n    float u = length((A0-B0)/R);\n    float v = length((A0-B0)/(R*R));\n    return u*(u-1.0)/v;\n}\n/*\nA0 point position\nB0 line reference\nN  surface normal of region, normalized\n\nNOTE: in this case, N only needs to indicate the direction facing outside, \n it need not be perfectly normal to B\n*/\nfloat get_distance_of_2d_point_to_region_bounded_by_line(in vec2 A0, in vec2 B0, in vec2 N)\n{\n    return dot(A0-B0, N);\n}\n// 3D FUNCTIONS CHECKING IF POINT IS IN REGION\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nfloat get_distance_of_3d_point_to_sphere(in vec3 A0, in vec3 B0, in float r)\n{\n    return length(A0-B0) - r;\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nfloat guess_distance_of_3d_point_to_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    vec3 V = A0-B0;\n    float u = length(V/R);\n    float v = length(V/(R*R));\n    return u*(u-1.0)/v;\n}\n/*\nA0 point position\nB0 plane reference\nN  vertex normal\n*/\nfloat get_distance_of_3d_point_to_region_bounded_by_plane(in vec3 A0, in vec3 B0, in vec3 N)\n{\n    return dot(A0-B0, N);\n}\n/*\nA0 point position\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\n/*\nfloat get_distance_of_3d_point_to_tetrahedron(in vec3 A0, in vec3 B1, in vec3 B2, in vec3 B3, in vec3 B4)\n{\n    // INTUITION: for each triangle, make sure A0 lies on the same side as the remaining vertex\n    vec3 B2xB3 = cross(B2-B1, B3-B1);\n    vec3 B3xB1 = cross(B3-B2, B1-B2);\n    vec3 B1xB2 = cross(B1-B3, B2-B3);\n    return sign(dot(A0-B1, B2xB3)) == sign(dot(B4-B1, B2xB3)) \n        && sign(dot(A0-B2, B3xB1)) == sign(dot(A0-B2, B3xB1)) \n        && sign(dot(A0-B3, B1xB2)) == sign(dot(A0-B3, B1xB2)) \n        ;\n}\n*/\n\n//#include \"precompiled/academics/math/geometry/point_intersection.glsl\"\n\nmaybe_vec2 get_bounding_distances_along_ray(in maybe_vec2 distances_along_line){\n    return \n      maybe_vec2(\n        vec2(\n          max(min(distances_along_line.value.x, distances_along_line.value.y), 0.0),\n          max(distances_along_line.value.x, distances_along_line.value.y)\n        ),\n        distances_along_line.exists && max(distances_along_line.value.x, distances_along_line.value.y) > 0.\n      );\n}\nmaybe_float get_nearest_distance_along_ray(in maybe_vec2 distances_along_line){\n    return \n      maybe_float(\n        distances_along_line.value.x < 0.0? distances_along_line.value.y :\n        distances_along_line.value.y < 0.0? distances_along_line.value.x :\n        min(distances_along_line.value.x, distances_along_line.value.y),\n        distances_along_line.exists && max(distances_along_line.value.x, distances_along_line.value.y) > 0.\n      );\n}\nmaybe_float get_distance_along_line_to_union(\n    in maybe_float shape1,\n    in maybe_float shape2\n) {\n    return maybe_float(\n        !shape1.exists ? shape2.value : !shape2.exists ? shape1.value : min(shape1.value, shape2.value),\n        shape1.exists || shape2.exists\n    );\n}\nmaybe_vec2 get_distances_along_line_to_union(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape1.exists ? shape2.value.x : !shape2.exists ? shape1.value.x : min(shape1.value.x, shape2.value.x),\n             !shape1.exists ? shape2.value.y : !shape2.exists ? shape1.value.y : max(shape1.value.y, shape2.value.y )),\n        shape1.exists || shape2.exists\n    );\n}\nmaybe_vec2 get_distances_along_line_to_negation(\n    in maybe_vec2 positive,\n    in maybe_vec2 negative\n) {\n    // as long as intersection with positive exists, \n    // and negative doesn't completely surround it, there will be an intersection\n    bool exists =\n        positive.exists && !(negative.value.x < positive.value.x && positive.value.y < negative.value.y);\n    // find the first region of intersection\n    float entrance = !negative.exists ? positive.value.x : min(negative.value.y, positive.value.x);\n    float exit = !negative.exists ? positive.value.y : min(negative.value.x, positive.value.y);\n    // if the first region is behind us, find the second region\n    if (exit < 0. && 0. < positive.value.y)\n    {\n        entrance = negative.value.y;\n        exit = positive.value.y;\n    }\n    return maybe_vec2( vec2(entrance, exit), exists );\n}\n\nmaybe_vec2 get_distances_along_line_to_negation_old(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    return maybe_vec2(\n        vec2(!shape2.exists ? shape1.value.x : min(shape2.value.y, shape1.value.x),\n             !shape2.exists ? shape1.value.y : min(shape2.value.x, shape1.value.y)),\n        shape1.exists && (!shape2.exists || shape1.value.x < shape2.value.x || shape2.value.y < shape1.value.y)\n    );\n}\n\nmaybe_vec2 get_distances_along_line_to_intersection(\n    in maybe_vec2 shape1,\n    in maybe_vec2 shape2\n) {\n    float x = shape1.exists && shape2.exists ? max(shape1.value.x, shape2.value.x) : 0.0;\n    float y = shape1.exists && shape2.exists ? min(shape1.value.y, shape2.value.y ) : 0.0;\n    return maybe_vec2(vec2(x,y), shape1.exists && shape2.exists && x < y);\n}\nfloat get_distance_along_2d_line_nearest_to_point(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0\n){\n    return dot(B0 - A0, A);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\nmaybe_float get_distance_along_2d_line_to_line(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    return maybe_float(\n        length(R) / dot(B, normalize(-R)),\n        abs(abs(dot(A, B)) - 1.0) > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\nmaybe_float get_distance_along_2d_line_to_ray(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in vec2 B\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if distance > 0\n    vec2 D = B0 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && xA > 0.0);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line segment endpoint 1\nB1 line segment endpoint 2\n*/\nmaybe_float get_distance_along_2d_line_to_line_segment(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2\n){\n    // INTUITION: same as the line-line intersection, but now results are only valid if 0 < distance < |B2-B1|\n    vec2 B = normalize(B2 - B1);\n    vec2 D = B1 - A0;\n    // offset\n    vec2 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && 0. < xA && xA < length(B2 - B1));\n}\nmaybe_vec2 get_distances_along_2d_line_to_circle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B0,\n    in float r\n){\n    vec2 D = B0 - A0;\n    float xz = dot(D, A);\n    float z2 = dot(D, D) - xz * xz;\n    float y2 = r * r - z2;\n    float dxr = sqrt(max(y2, 1e-10));\n    return maybe_vec2(vec2(xz - dxr, xz + dxr), y2 > 0.);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\n*/\nmaybe_vec2 get_distances_along_2d_line_to_triangle(\n    in vec2 A0,\n    in vec2 A,\n    in vec2 B1,\n    in vec2 B2,\n    in vec2 B3\n){\n    maybe_float line1 = get_distance_along_2d_line_to_line_segment(A0, A, B1, B2);\n    maybe_float line2 = get_distance_along_2d_line_to_line_segment(A0, A, B2, B3);\n    maybe_float line3 = get_distance_along_2d_line_to_line_segment(A0, A, B3, B1);\n    return maybe_vec2(\n        vec2(min(line1.value, min(line2.value, line3.value)),\n             max(line1.value, max(line2.value, line3.value))),\n        line1.exists || line2.exists || line3.exists\n    );\n}\nfloat get_distance_along_3d_line_nearest_to_point(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0\n){\n    return dot(B0 - A0, A);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 line reference\nB  line direction, normalized\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_line(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 C = normalize(cross(B, A));\n    // cross\n    vec3 R = D - dot(D, A) * A - dot(D, C) * C;\n    // rejection\n    return maybe_float(\n        length(R) / -dot(B, normalize(R)),\n        abs(abs(dot(A, B)) - 1.0) > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ray origin\nB  ray direction, normalized\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_ray(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B\n){\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && xA > 0.0);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 line segment endpoint 1\nB2 line segment endpoint 2\n*/\nmaybe_float get_distance_along_3d_line_nearest_to_line_segment(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B1\n){\n    vec3 B = normalize(B1 - B0);\n    vec3 D = B0 - A0;\n    // offset\n    vec3 R = D - dot(D, A) * A;\n    // rejection\n    float xB = length(R) / dot(B, normalize(-R));\n    // distance along B\n    float xA = xB / dot(B, A);\n    // distance along A\n    return maybe_float(xB, abs(abs(dot(A, B)) - 1.0) > 0.0 && 0. < xA && xA < length(B1 - B0));\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 plane reference\nN  plane surface normal, normalized\n*/\nmaybe_float get_distance_along_3d_line_to_plane(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N\n){\n    return maybe_float( -dot(A0 - B0, N) / dot(A, N), abs(dot(A, N)) < SMALL);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 circle origin\nN  circle surface normal, normalized\nr  circle radius\n*/\nmaybe_float get_distance_along_3d_line_to_circle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 N,\n    in float r\n){\n    // intersection(plane, sphere)\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    return maybe_float(t.value, is_3d_point_in_sphere(A0 + A * t.value, B0, r));\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\n*/\nmaybe_float get_distance_along_3d_line_to_triangle(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3\n){\n    // intersection(face plane, edge plane, edge plane, edge plane)\n    vec3 B0 = (B1 + B2 + B3) / 3.;\n    vec3 N = normalize(cross(B1 - B2, B2 - B3));\n    maybe_float t = get_distance_along_3d_line_to_plane(A0, A, B0, N);\n    vec3 At = A0 + A * t.value;\n    vec3 B2B1hat = normalize(B2 - B1);\n    vec3 B3B2hat = normalize(B3 - B2);\n    vec3 B1B3hat = normalize(B1 - B3);\n    return maybe_float(t.value,\n        dot(normalize(At - B1), B2B1hat) > dot(-B1B3hat, B2B1hat) &&\n        dot(normalize(At - B2), B3B2hat) > dot(-B2B1hat, B3B2hat) &&\n        dot(normalize(At - B3), B1B3hat) > dot(-B3B2hat, B1B3hat)\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 sphere origin\nR  sphere radius along each coordinate axis\n*/\nmaybe_vec2 get_distances_along_3d_line_to_sphere(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in float r\n){\n    float t = dot(B0 - A0, A);\n    vec3  At = A0 + A*t - B0;\n    float y2 = r*r - dot(At,At);\n    float dxr = sqrt(max(y2, SMALL));\n    return maybe_vec2(\n        vec2(t - dxr, t + dxr),\n        y2 > 0.\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nmaybe_float get_distance_along_3d_line_to_ellipsoid(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 R\n){\n    // NOTE: shamelessly copy pasted, all credit goes to Inigo: \n    // https://iquilezles.org/articles/intersectors\n    vec3 Or = (A0 - B0) / R;\n    vec3 Ar = A / R;\n    float ArAr = dot(Ar, Ar);\n    float OrAr = dot(Or, Ar);\n    float OrOr = dot(Or, Or);\n    float h = OrAr * OrAr - ArAr * (OrOr - 1.0);\n    return maybe_float(\n        (-OrAr - sqrt(h)) / ArAr,\n        h >= 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 vertex position 1\nB2 vertex position 2\nB3 vertex position 3\nB4 vertex position 4\n*/\nmaybe_float get_distance_along_3d_line_to_tetrahedron(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in vec3 B3,\n    in vec3 B4\n){\n    maybe_float hit1 = get_distance_along_3d_line_to_triangle(A0, A, B1, B2, B3);\n    maybe_float hit2 = get_distance_along_3d_line_to_triangle(A0, A, B2, B3, B4);\n    maybe_float hit3 = get_distance_along_3d_line_to_triangle(A0, A, B3, B4, B1);\n    maybe_float hit4 = get_distance_along_3d_line_to_triangle(A0, A, B4, B1, B2);\n    maybe_float hit;\n    hit = get_distance_along_line_to_union(hit1, hit2);\n    hit = get_distance_along_line_to_union(hit, hit3);\n    hit = get_distance_along_line_to_union(hit, hit4);\n    return hit;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cylinder reference\nB  cylinder direction, normalized\nr  cylinder radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_infinite_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r\n){\n    // INTUITION: simplify the problem by using a coordinate system based around the line and the tube center\n    // see closest-approach-between-line-and-cylinder-visualized.scad\n    // implementation shamelessly copied from Inigo: \n    // https://iquilezles.org/articles/intersectors\n    vec3 D = A0 - B0;\n    float BA = dot(B, A);\n    float BD = dot(B, D);\n    float a = 1.0 - BA * BA;\n    float b = dot(D, A) - BD * BA;\n    float c = dot(D, D) - BD * BD - r * r;\n    float h = sqrt(max(b * b - a * c, 0.0));\n    return maybe_vec2(\n        vec2((-b + h) / a, (-b - h) / a),\n        h > 0.0\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\nr  cylinder radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_cylinder(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    vec3 B = normalize(B2 - B1);\n    maybe_float a1 = get_distance_along_3d_line_to_plane(A0, A, B1, B);\n    maybe_float a2 = get_distance_along_3d_line_to_plane(A0, A, B2, B);\n    float a_in = min(a1.value, a2.value);\n    float a_out = max(a1.value, a2.value);\n    maybe_vec2 ends = maybe_vec2(vec2(a_in, a_out), a1.exists || a2.exists);\n    maybe_vec2 tube = get_distances_along_3d_line_to_infinite_cylinder(A0, A, B1, B, r);\n    maybe_vec2 cylinder = get_distances_along_line_to_intersection(tube, ends);\n    // TODO: do we need this line?\n    float entrance = max(tube.value.y, a_in);\n    float exit = min(tube.value.x, a_out);\n    return maybe_vec2(\n        vec2(entrance, exit),\n        tube.exists && entrance < exit\n    );\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 capsule endpoint 1\nB2 capsule endpoing 2\nr  capsule radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_capsule(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r\n){\n    maybe_vec2 cylinder = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, r);\n    maybe_vec2 sphere1 = get_distances_along_3d_line_to_sphere(A0, A, B1, r);\n    maybe_vec2 sphere2 = get_distances_along_3d_line_to_sphere(A0, A, B2, r);\n    maybe_vec2 spheres = get_distances_along_line_to_union(sphere1, sphere2);\n    maybe_vec2 capsule = get_distances_along_line_to_union(spheres, cylinder);\n    return capsule;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 ring endpoint 1\nB2 ring endpoing 2\nro ring outer radius\nri ring inner radius\n*/\nmaybe_vec2 get_distances_along_3d_line_to_ring(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float ro,\n    in float ri\n){\n    maybe_vec2 outer = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ro);\n    maybe_vec2 inner = get_distances_along_3d_line_to_cylinder(A0, A, B1, B2, ri);\n    maybe_vec2 ring = get_distances_along_line_to_negation(outer, inner);\n    return ring;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\ncosb cosine of cone half angle\n*/\nmaybe_float get_distance_along_3d_line_to_infinite_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float cosb\n){\n    vec3 D = A0 - B0;\n    float a = dot(A, B) * dot(A, B) - cosb * cosb;\n    float b = 2. * (dot(A, B) * dot(D, B) - dot(A, D) * cosb * cosb);\n    float c = dot(D, B) * dot(D, B) - dot(D, D) * cosb * cosb;\n    float det = b * b - 4. * a * c;\n    if (det < 0.)\n    {\n        return maybe_float(0.0, false);\n    }\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n    // This is a bit messy; there ought to be a more elegant solution.\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t)\n    {\n        t = t2;\n    }\n    else {\n        t = t1;\n    }\n    vec3 cp = A0 + t * A - B0;\n    float h = dot(cp, B);\n    return maybe_float(t, t > 0. && h > 0.);\n}\n/*\nA0 line reference\nA  line direction, normalized\nB0 cone vertex\nB  cone direction, normalized\nr  cone radius\nh  cone height\n*/\nmaybe_float get_distance_along_3d_line_to_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B0,\n    in vec3 B,\n    in float r,\n    in float h\n){\n    maybe_float end = get_distance_along_3d_line_to_circle(A0, A, B0 + B * h, B, r);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(r / h)));\n    cone.exists = cone.exists && dot(A0 +cone.value * A - B0, B) <= h;\n    cone = get_distance_along_line_to_union(end, cone);\n    return cone;\n}\n/*\nA0 line reference\nA  line direction, normalized\nB1 cone endpoint 1\nB2 cone endpoint 2\nr1 cone endpoint 1 radius\nr2 cone endpoint 2 radius\n*/\nmaybe_float get_distance_along_3d_line_to_capped_cone(\n    in vec3 A0,\n    in vec3 A,\n    in vec3 B1,\n    in vec3 B2,\n    in float r1,\n    in float r2\n){\n    float dh = length(B2 - B1);\n    float dr = r2 - r1;\n    float rmax = max(r2, r1);\n    float rmin = min(r2, r1);\n    float hmax = rmax * dr / dh;\n    float hmin = rmin * dr / dh;\n    vec3 B = sign(dr) * normalize(B2 - B1);\n    vec3 Bmax = (r2 > r1? B2 : B1);\n    vec3 B0 = Bmax - B * hmax;\n    vec3 Bmin = Bmax - B * hmin;\n    maybe_float end1 = get_distance_along_3d_line_to_circle(A0, A, Bmax, B, rmax);\n    maybe_float end2 = get_distance_along_3d_line_to_circle(A0, A, Bmin, B, rmin);\n    maybe_float cone = get_distance_along_3d_line_to_infinite_cone(A0, A, B0, B, cos(atan(rmax / hmax)));\n    float c_h = dot(A0 + cone.value * A - B0, B);\n    cone.exists = cone.exists && hmin <= c_h && c_h <= hmax;\n    cone = get_distance_along_line_to_union(cone, end1);\n    cone = get_distance_along_line_to_union(cone, end2);\n    return cone;\n}\n\n/*\nA1 vertex 1 position\nA2 vertex 2 position\nA3 vertex 3 position\n*/\nvec3 get_surface_normal_of_triangle( in vec3 A1, in vec3 A2, in vec3 A3 )\n{\n    return normalize( cross(A2-A1, A3-A1) );\n}\n/*\nA0 point position\nB0 sphere origin\nr  radius\n*/\nvec3 get_surface_normal_of_point_near_sphere( in vec3 A0, in vec3 B0 )\n{\n    return normalize( A0-B0 );\n}\n/*\nA0 point position\nB0 ellipsoid center\nR  ellipsoid radius along each coordinate axis\n*/\nvec3 guess_surface_normal_of_point_near_ellipsoid(in vec3 A0, in vec3 B0, in vec3 R)\n{\n    vec3  V  = A0-B0;\n    return normalize( V/R );\n}\n/*\nA0 point position\nB0 cylinder reference\nB  cylinder direction, normalized\n*/\nvec3 get_surface_normal_of_point_near_infinite_cylinder( in vec3 A0, in vec3 B0, in vec3 B )\n{\n    // INTUITION: equivalent to the normalized vector rejection\n    vec3 D = A0-B0;\n    return normalize( D - B*dot(D, B) );\n}\n/*\nA0 point position\nB1 cylinder endpoint 1\nB2 cylinder endpoing 2\n*/\nvec3 get_surface_normal_of_point_near_cylinder( in vec3 A0, in vec3 B1, in vec3 B2 )\n{\n    vec3 D = A0-B1;\n    vec3 B = normalize(B2-B1);\n    float DB = dot(D,B);\n    return 0.f < DB? -B : DB < length(D)? B : normalize( D-B*DB );\n}\n\n\nfloat get_angular_radius_of_sphere_at_distance(\n\tin float sphere_radius, in float sphere_distance\n){\n\tfloat r = sphere_radius;\n\tfloat h = sphere_distance;\n\t// \"a2\": squared distance to the tangent point, found using pythagorean theorem, \n\t// scaled so hypoteneuse = 1\n\tfloat a2 = 1.0-r*r/(h*h);\n\treturn r * sqrt(a2) / (h * a2);\n}\nfloat get_area_of_intersection_between_circle_and_circle(\n\tin float circle1_radius, in float circle2_radius, in float circle_origin_distance\n){\n\t/*\n\tNOTE: see here for an explanation:\n\thttps://www.xarg.org/2016/07/calculate-the-intersection-area-of-two-circles/\n\t*/\n\tfloat d = circle_origin_distance;\n\tfloat R = max(circle1_radius, circle2_radius);\n\tfloat r = min(circle1_radius, circle2_radius);\n\tif (d>=r+R)\n\t{\n\t\treturn 0.0;\n\t}\n\telse if (d+r<=R)\n\t{\n\t\treturn PI*r*r;\n\t}\n\telse \n\t{\n\t\tconst float EPSILON = 0.000;\n\t\tfloat X = (R*R-r*r+d*d)/(2.0*d);\n\t\tfloat y = sqrt(R*R-X*X);\n\t\tfloat x = abs(d-X);//sqrt(r*r-y*y);\n\t\tfloat theta = asin(y/r);\n\t\tfloat Theta = asin(y/R);\n\t\tfloat a = r*r*theta - x*y;\n\t\tfloat A = R*R*Theta - X*y;\n\t\treturn A + d>=X? a:PI*r*r-a;\n\t}\n}\n/*\nAssumes the light source and occlusion are distant enough that they can be \ntreated as circles on a 2d plane\n*/\nfloat get_fraction_of_sphere_not_occluded_by_sphere(\n\tin vec3 light_destination, in vec3 light_origin, in float light_radius, \n\tin vec3 sphere_origin, in float sphere_radius\n){\n    const float EPSILON = 1e-10;\n\t// direction of light origin from destination\n\tvec3  light_direction  = normalize(light_origin-light_destination);\n\tfloat light_distance   = length(light_origin-light_destination);\n\t// direction of sphere origin from destination\n\tvec3  sphere_direction = normalize(sphere_origin-light_destination);\n\tfloat sphere_distance  = length(sphere_origin-light_destination);\n\tfloat cos_angular_separation = dot(light_direction, sphere_direction);\n\t// angular separation between light and sphere origins when viewed from destination\n    if (cos_angular_separation <= 0.0) return 1.0;\n    if (sphere_distance < sphere_radius) return 0.0;\n\tfloat angular_separation = acos(min(cos_angular_separation, 1.0-EPSILON));\n\tfloat angular_light_radius  = get_angular_radius_of_sphere_at_distance(light_radius, light_distance);\n\tfloat angular_sphere_radius = get_angular_radius_of_sphere_at_distance(sphere_radius, sphere_distance);\n\t// distance between light and sphere origins when viewed from destination, \n\t// treating the two as circles on a 2d plane\n\tfloat angular_distance = 2.0 * tan(angular_separation / 2.0);\n    if(angular_separation>1e20) {return 1.;}\n\tfloat area = get_area_of_intersection_between_circle_and_circle(\n\t\tangular_light_radius, angular_sphere_radius, angular_distance\n\t);\n\treturn 1.0 - area / (PI*angular_light_radius*angular_light_radius);\n}\n\n\n\nconst float DEGREE = 3.141592653589793238462643383279502884197169399/180.;\nconst float RADIAN = 1.;\nconst float KELVIN = 1.;\nconst float DALTON    = 1.66053907e-27;// kilograms\nconst float MICROGRAM = 1e-9; // kilograms\nconst float MILLIGRAM = 1e-6; // kilograms\nconst float GRAM = 1e-3; // kilograms\nconst float KILOGRAM = 1.; // kilograms\nconst float TON = 1000.; // kilograms\nconst float NANOMETER = 1e-9; // meters\nconst float MICROMETER = 1e-6; // meters\nconst float MILLIMETER = 1e-3; // meters\nconst float METER = 1.; // meters\nconst float KILOMETER = 1000.; // meters\nconst float MOLE = 6.02214076e23;\nconst float MILLIMOLE = MOLE / 1e3;\nconst float MICROMOLE = MOLE / 1e6;\nconst float NANOMOLE = MOLE / 1e9;\nconst float FEMTOMOLE = MOLE / 1e12;\nconst float SECOND = 1.; // seconds\nconst float MINUTE = 60.; // seconds\nconst float HOUR = MINUTE*60.; // seconds\nconst float DAY = HOUR*24.; // seconds\nconst float WEEK = DAY*7.; // seconds\nconst float MONTH = DAY*29.53059; // seconds\nconst float YEAR = DAY*365.256363004; // seconds\nconst float MEGAYEAR = YEAR*1e6; // seconds\nconst float NEWTON = KILOGRAM * METER / (SECOND * SECOND);\nconst float JOULE = NEWTON * METER;\nconst float WATT = JOULE / SECOND;\nconst float EARTH_MASS = 5.972e24; // kilograms\nconst float EARTH_RADIUS = 6.367e6; // meters\nconst float STANDARD_GRAVITY = 9.80665; // meters/second^2\nconst float STANDARD_TEMPERATURE = 273.15; // kelvin\nconst float STANDARD_PRESSURE = 101325.; // pascals\nconst float ASTRONOMICAL_UNIT = 149597870700.;// meters\nconst float GLOBAL_SOLAR_CONSTANT = 1361.; // watts/meter^2\nconst float JUPITER_MASS = 1.898e27; // kilograms\nconst float JUPITER_RADIUS = 71e6; // meters\nconst float SOLAR_MASS = 2e30; // kilograms\nconst float SOLAR_RADIUS = 695.7e6; // meters\nconst float SOLAR_LUMINOSITY = 3.828e26; // watts\nconst float SOLAR_TEMPERATURE = 5772.; // kelvin\n\n\n\nconst float SPEED_OF_LIGHT = 299792458. * METER / SECOND;\nconst float BOLTZMANN_CONSTANT = 1.3806485279e-23 * JOULE / KELVIN;\nconst float STEPHAN_BOLTZMANN_CONSTANT = 5.670373e-8 * WATT / (METER*METER* KELVIN*KELVIN*KELVIN*KELVIN);\nconst float PLANCK_CONSTANT = 6.62607004e-34 * JOULE * SECOND;\n// see Lawson 2004, \"The Blackbody Fraction, Infinite Series and Spreadsheets\"\n// we only do a single iteration with n=1, because it doesn't have a noticeable effect on output\nfloat solve_fraction_of_light_emitted_by_black_body_below_wavelength(\n    in float wavelength,\n    in float temperature\n){\n    const float iterations = 2.;\n    const float h = PLANCK_CONSTANT;\n    const float k = BOLTZMANN_CONSTANT;\n    const float c = SPEED_OF_LIGHT;\n    float L = wavelength;\n    float T = temperature;\n    float C2 = h*c/k;\n    float z = C2 / (L*T);\n    float z2 = z*z;\n    float z3 = z2*z;\n    float sum = 0.;\n    float n2=0.;\n    float n3=0.;\n    for (float n=1.; n <= iterations; n++) {\n        n2 = n*n;\n        n3 = n2*n;\n        sum += (z3 + 3.*z2/n + 6.*z/n2 + 6./n3) * exp(-n*z) / n;\n    }\n    return 15.*sum/(PI*PI*PI*PI);\n}\nfloat solve_fraction_of_light_emitted_by_black_body_between_wavelengths(\n    in float lo,\n    in float hi,\n    in float temperature\n){\n    return solve_fraction_of_light_emitted_by_black_body_below_wavelength(hi, temperature) -\n            solve_fraction_of_light_emitted_by_black_body_below_wavelength(lo, temperature);\n}\n// This calculates the radiation (in watts/m^2) that's emitted \n// by a single object using the Stephan-Boltzmann equation\nfloat get_intensity_of_light_emitted_by_black_body(\n    in float temperature\n){\n    float T = temperature;\n    return STEPHAN_BOLTZMANN_CONSTANT * T*T*T*T;\n}\nvec3 solve_rgb_intensity_of_light_emitted_by_black_body(\n    in float temperature\n){\n    return get_intensity_of_light_emitted_by_black_body(temperature)\n         * vec3(\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(600e-9*METER, 700e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(500e-9*METER, 600e-9*METER, temperature),\n             solve_fraction_of_light_emitted_by_black_body_between_wavelengths(400e-9*METER, 500e-9*METER, temperature)\n           );\n}\n// Rayleigh phase function factor [-1, 1]\nfloat get_fraction_of_rayleigh_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    return 3. * (1. + cos_scatter_angle*cos_scatter_angle)\n    / //------------------------\n                (16. * PI);\n}\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\nfloat get_fraction_of_mie_scattered_light_scattered_by_angle(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    return (1. - g*g)\n    / //---------------------------------------------\n        ((4. + PI) * pow(1. + g*g - 2.*g*cos_scatter_angle, 1.5));\n}\n// Schlick's fast approximation to the Henyey-Greenstein phase function factor\n// Pharr and  Humphreys [2004] equivalence to g above\nfloat approx_fraction_of_mie_scattered_light_scattered_by_angle_fast(\n    in float cos_scatter_angle\n){\n    const float g = 0.76;\n    const float k = 1.55*g - 0.55 * (g*g*g);\n    return (1. - k*k)\n    / //-------------------------------------------\n        (4. * PI * (1. + k*cos_scatter_angle) * (1. + k*cos_scatter_angle));\n}\n/*\n\"get_fraction_of_microfacets_accessible_to_ray\" is Schlick's fast approximation for Smith's function\n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_accessible_to_ray(\n    in float cos_view_angle,\n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float v = cos_view_angle;\n    // float k = m/2.0; return 2.0*v/(v+sqrt(m*m+(1.0-m*m)*v*v)); // Schlick-GGX\n    float k = m*sqrt(2./PI); return v/(v*(1.0-k)+k); // Schlick-Beckmann\n}\n/*\n\"get_fraction_of_microfacets_with_angle\" \n  This is also known as the Beckmann Surface Normal Distribution Function.\n  This is the probability of finding a microfacet whose surface normal deviates from the average by a certain angle.\n  see Hoffmann 2015 for a gentle introduction to the concept.\n  see Schlick (1994) for even more details.\n*/\nfloat get_fraction_of_microfacets_with_angle(\n    in float cos_angle_of_deviation,\n    in float root_mean_slope_squared\n){\n    float m = root_mean_slope_squared;\n    float t = cos_angle_of_deviation;\n    float m2 = m*m;\n    float t2 = t*t;\n    float u = t2*(m2-1.0)+1.0; return m2/(PI*u*u);\n    //return exp((t*t-1.)/max(m*m*t*t, 0.1))/max(PI*m*m*t*t*t*t, 0.1);\n}\n/*\n\"get_fraction_of_light_reflected_from_facet_head_on\" finds the fraction of light that's reflected\n  by a boundary between materials when striking head on.\n  It is also known as the \"characteristic reflectance\" within the fresnel reflectance equation.\n  The refractive indices can be provided as parameters in any order.\n*/\nfloat get_fraction_of_light_reflected_from_facet_head_on(\n    in float refractivate_index1,\n    in float refractivate_index2\n){\n    float n1 = refractivate_index1;\n    float n2 = refractivate_index2;\n    float sqrtF0 = ((n1-n2)/(n1+n2));\n    float F0 = sqrtF0 * sqrtF0;\n    return F0;\n}\n/*\n\"get_rgb_fraction_of_light_reflected_from_facet\" returns Fresnel reflectance for each color channel.\n  Fresnel reflectance is the fraction of light that's immediately reflected upon striking the surface.\n  It is the fraction of light that causes specular reflection.\n  Here, we use Schlick's fast approximation for Fresnel reflectance.\n  see https://en.wikipedia.org/wiki/Schlick%27s_approximation for a summary \n  see Hoffmann 2015 for a gentle introduction to the concept\n  see Schlick (1994) for implementation details\n*/\nvec3 get_rgb_fraction_of_light_reflected_from_facet(\n    in float cos_incident_angle,\n    in vec3 characteristic_reflectance\n){\n    vec3 F0 = characteristic_reflectance;\n    float _1_u = 1.-cos_incident_angle;\n    return F0 + (1.-F0) * _1_u*_1_u*_1_u*_1_u*_1_u;\n}\n/*\n\"get_fraction_of_light_reflected_from_material\" is a fast approximation to the Cook-Torrance Specular BRDF.\n  It is the fraction of light that reflects from a material to the viewer.\n  see Hoffmann 2015 for a gentle introduction to the concept\n*/\nvec3 get_fraction_of_light_reflected_from_material(\n    in float NL, in float NH, in float NV, in float HV,\n    in float root_mean_slope_squared,\n    in vec3 characteristic_reflectance\n){\n    float m = root_mean_slope_squared;\n    vec3 F0 = characteristic_reflectance;\n    return 1.0\n        * get_fraction_of_microfacets_accessible_to_ray(NL, m)\n        * get_fraction_of_microfacets_with_angle(NH, m)\n        * get_fraction_of_microfacets_accessible_to_ray(NV, m)\n        * get_rgb_fraction_of_light_reflected_from_facet(HV, F0)\n        / max(4.*PI*NV*NL, 0.001);\n}\n/*\n\"GAMMA\" is the constant that's used to map between \nrgb signals sent to a monitor and their actual intensity\n*/\nconst float GAMMA = 2.2;\n/* \nThis function returns a rgb vector that quickly approximates a spectral \"bump\".\nAdapted from GPU Gems and Alan Zucconi\nfrom https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\n*/\nvec3 get_rgb_intensity_of_rgb_signal(\n    in vec3 signal\n){\n    return vec3(\n        pow(signal.x, GAMMA),\n        pow(signal.y, GAMMA),\n        pow(signal.z, GAMMA)\n    );\n}\n/*\nThis function returns a rgb vector that best represents color at a given wavelength\nIt is from Alan Zucconi: https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\nI've adapted the function so that coefficients are expressed in meters.\n*/\nvec3 get_rgb_signal_of_rgb_intensity(\n    in vec3 intensity\n){\n    return vec3(\n        pow(intensity.x, 1./GAMMA),\n        pow(intensity.y, 1./GAMMA),\n        pow(intensity.z, 1./GAMMA)\n    );\n}\nmat4 get_rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\nmat4 get_translation_matrix(vec3 offset)\n{\n    return mat4(1,0,0,0,\n                0,1,0,0,\n                0,0,1,0,\n                offset,1);\n}\n// \"approx_air_column_density_ratio_through_atmosphere\" \n//   calculates the distance you would need to travel \n//   along the surface to encounter the same number of particles in the column. \n// It does this by finding an integral using integration by substitution, \n//   then tweaking that integral to prevent division by 0. \n// All distances are recorded in scale heights.\n// \"a\" and \"b\" are distances along the ray from closest approach.\n//   The ray is fired in the positive direction.\n//   If there is no intersection with the planet, \n//   a and b are distances from the closest approach to the upper bound.\n// \"z2\" is the closest distance from the ray to the center of the world, squared.\n// \"r0\" is the radius of the world.\nfloat approx_air_column_density_ratio_through_atmosphere(\n    in float a,\n    in float b,\n    in float z2,\n    in float r0\n){\n    // GUIDE TO VARIABLE NAMES:\n    //  \"x*\" distance along the ray from closest approach\n    //  \"z*\" distance from the center of the world at closest approach\n    //  \"r*\" distance (\"radius\") from the center of the world\n    //  \"*0\" variable at reference point\n    //  \"*2\" the square of a variable\n    //  \"ch\" a nudge we give to prevent division by zero, analogous to the Chapman function\n    const float SQRT_HALF_PI = sqrt(PI/2.);\n    const float k = 0.6; // \"k\" is an empirically derived constant\n    float x0 = sqrt(max(r0*r0 - z2, SMALL));\n    // if obstructed by the world, approximate answer by using a ludicrously large number\n    if (a < x0 && -x0 < b && z2 < r0*r0) { return BIG; }\n    float abs_a  = abs(a);\n    float abs_b  = abs(b);\n    float z      = sqrt(z2);\n    float sqrt_z = sqrt(z);\n    float ra     = sqrt(a*a+z2);\n    float rb     = sqrt(b*b+z2);\n    float ch0    = (1. - 1./(2.*r0)) * SQRT_HALF_PI * sqrt_z + k*x0;\n    float cha    = (1. - 1./(2.*ra)) * SQRT_HALF_PI * sqrt_z + k*abs_a;\n    float chb    = (1. - 1./(2.*rb)) * SQRT_HALF_PI * sqrt_z + k*abs_b;\n    float s0     = min(exp(r0- z),1.) / (x0/r0 + 1./ch0);\n    float sa     = exp(r0-ra) / max(abs_a/ra + 1./cha, 0.01);\n    float sb     = exp(r0-rb) / max(abs_b/rb + 1./chb, 0.01);\n    return max( sign(b)*(s0-sb) - sign(a)*(s0-sa), 0.0 );\n}\n\n\n\n// from Carl Hansen et al., \"Stellar Interiors\"\nfloat get_temperature_of_star_at_fraction_of_radius(float fraction_of_radius, float core_temperature) \n{\n    return max( core_temperature * (1.0 - fraction_of_radius*fraction_of_radius), 0.0 );\n}\n// from Carl Hansen et al., \"Stellar Interiors\"\nfloat approx_core_temperature_of_star(float mass, float radius, float mean_molecular_mass) \n{\n    const float SOLAR_MEAN_MOLECULAR_MASS = 0.6*DALTON;\n    return (\n        15e6 * KELVIN \n        * (mean_molecular_mass / SOLAR_MEAN_MOLECULAR_MASS)\n        * (mass / SOLAR_MASS)\n        / (radius / SOLAR_RADIUS)\n    );\n}\n\n// the approximations below are ripped from Artifexian's video on stars:\n// https://www.youtube.com/watch?v=x55nxxaWXAM\n// we only need rough guesses for these properties, so they should be good enough\nfloat approx_luminosity_of_star(float mass) \n{\n    return SOLAR_LUMINOSITY * pow(mass/SOLAR_MASS, 3.5);\n}\nfloat approx_radius_of_star(float mass)\n{\n    return SOLAR_RADIUS * (mass < SOLAR_MASS? pow(mass/SOLAR_MASS, 0.8) : pow(mass/SOLAR_MASS, 0.5));\n}\nfloat approx_intensity_of_star(float mass)\n{\n    return approx_luminosity_of_star(mass) / get_surface_area_of_sphere(approx_radius_of_star(mass));\n}\nfloat approx_surface_temperature(float mass)\n{\n    return pow(approx_intensity_of_star(mass) / STEPHAN_BOLTZMANN_CONSTANT, 1./4.);\n}\nfloat get_fraction_of_radius_for_star_with_temperature(float temperature, float core_temperature)\n{\n    return sqrt(max(1.0 - (temperature / core_temperature), 0.));\n}\n\n\n// TODO: support for light sources from within atmosphere\nvec3 get_rgb_intensity_of_light_emitted_by_sun(\n    vec3 view_origin, vec3 view_direction, float view_start_length, float view_stop_length, vec3 view_wavelengths,\n    vec3 star_position, \n    float star_radius_temp0, //radius at which temperature is assumed 0\n    float star_radius_beta, //radius at which beta_* values are sampled\n    float star_core_temperature,\n    float atmosphere_scale_height,\n    vec3 beta_ray, vec3 beta_mie, vec3 beta_abs\n){\n    // For an excellent introduction to what we're try to do here, see Alan Zucconi: \n    //   https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-3/\n    // We will be using most of the same terminology and variable names.\n    // GUIDE TO VARIABLE NAMES:\n    //  Uppercase letters indicate vectors.\n    //  Lowercase letters indicate scalars.\n    //  Going for terseness because I tried longhand names and trust me, you can't read them.\n    //  \"*v*\"    property of the view ray, the ray cast from the viewer to the object being viewed\n    //  \"*l*\"    property of the light ray, the ray cast from the object to the light source\n    //  \"y*\"     distance from the center of the world to the plane shared by view and light ray\n    //  \"z*\"     distance from the center of the world to along the plane shared by the view and light ray \n    //  \"r*\"     a distance (\"radius\") from the center of the world\n    //  \"h*\"     the atmospheric scale height, the distance at which air density reduces by a factor of e\n    //  \"*2\"     the square of a variable\n    //  \"*0\"     property at the start of the raymarch\n    //  \"*1\"     property at the end of the raymarch\n    //  \"*i\"     property during an iteration of the raymarch\n    //  \"d*\"     the change in a property across iterations of the raymarch\n    //  \"beta*\"  a scattering coefficient, the number of e-foldings in light intensity per unit distance\n    //  \"gamma*\" a phase factor, the fraction of light that's scattered in a certain direction\n    //  \"sigma*\" a column density ratio, the density of a column of air relative to surface density\n    //  \"F*\"     fraction of source light that reaches the viewer due to scattering for each color channel\n    //  \"*_ray\"  property of rayleigh scattering\n    //  \"*_mie\"  property of mie scattering\n    //  \"*_abs\"  property of absorption\n    // setup variable shorthands\n    // express all distances in scale heights \n    // express all positions relative to world origin\n    float h = atmosphere_scale_height;\n    vec3 V0 = (view_origin + view_direction * view_start_length - star_position) / h;\n    vec3 V1 = (view_origin + view_direction * view_stop_length - star_position) / h;\n    vec3 V = view_direction; // unit vector pointing to pixel being viewed\n    float v0 = dot(V0,V);\n    float v1 = dot(V1,V);\n    // \"beta_*\" indicates the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio, which is dependant on height\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio(height)\n    vec3 beta_sum = h*(beta_ray + beta_mie + beta_abs);\n    // number of iterations within the raymarch\n    const float STEP_COUNT = 32.;\n    float dv = (v1 - v0) / STEP_COUNT;\n    float vi = v0;\n    float z2 = dot(V0,V0) - v0*v0;\n    float sigma; // columnar density encountered along the entire path, relative to surface density, effectively the distance along the surface needed to obtain a similar column density\n    vec3 F = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    for (float i = 0.; i < STEP_COUNT; ++i)\n    {\n        sigma = approx_air_column_density_ratio_through_atmosphere(v0, vi, z2, star_radius_beta);\n        float temperature = get_temperature_of_star_at_fraction_of_radius(sqrt(vi*vi+z2) / star_radius_temp0, star_core_temperature);\n        F += (\n            // incoming scattered light: the intensity of light that goes towards the camera\n            // I * exp(r-sqrt(vi*vi+y2+zv2)) * beta_gamma * dv \n            // newly created emitted light: the intensity of light that is generated by the parcel towards the camera\n            + beta_abs * dv\n              * 2.0 * PLANCK_CONSTANT * SPEED_OF_LIGHT*SPEED_OF_LIGHT / (view_wavelengths*view_wavelengths*view_wavelengths*view_wavelengths*view_wavelengths)\n              * exp(star_radius_beta-sqrt(vi*vi+z2)) / (exp(PLANCK_CONSTANT * SPEED_OF_LIGHT/(view_wavelengths*BOLTZMANN_CONSTANT*temperature)) - 1.0) \n            )\n            // outgoing scattered light: the fraction of light that scatters away from camera\n            * exp(-beta_sum * sigma);\n        vi += dv;\n    }\n    return F;\n}\n\n\n\nfloat get_2d_perlin_noise(\n    in vec2 V,\n    in vec2 K\n){\n    vec2 I = floor(V);\n    vec2 F = fract(V);\n    vec2 G = smoothstep(0.f, 1.f, F);\n    vec2 J = vec2(0.f);\n    float a = 0.f;\n    for (int i = 0; i < 1; ++i)\n    {\n        for (int j = 0; j < 1; ++j)\n        {\n            J = I + vec2(i,j);\n            a += noise(dot(J,K))\n                * (i==0? 1.f-G.x : G.x)\n                * (j==0? 1.f-G.y : G.y);\n        }\n    }\n    return clamp(a, 0.f, 1.f);\n}\n/*\nV: position\nK: seed\n*/\nfloat get_3d_perlin_noise(\n    in vec3 V,\n    in vec3 K \n){\n    vec3 I = floor(V);\n    vec3 F = fract(V);\n    vec3 G = smoothstep(0.f, 1.f, F);\n    float a = 0.f;\n    for (int i = 0; i <= 1; ++i)\n    {\n        for (int j = 0; j <= 1; ++j)\n        {\n            for (int k = 0; k <= 1; ++k)\n            {\n                a += noise(dot(I+vec3(i,j,k), K)) \n                    * (i==0? 1.f-G.x : G.x) \n                    * (j==0? 1.f-G.y : G.y) \n                    * (k==0? 1.f-G.z : G.z); \n            }\n        }\n    }\n    return clamp(a, 0.f, 1.f);\n}\nfloat get_3d_worley_noise(vec3 position, mat3 position_seed)\n{\n    vec3 index = floor(position);\n        \n    float nearest_distance = 1e20;\n    vec3  neighbor_index = vec3(0);\n    vec3  neighbor_position = vec3(0);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int z = -1; z <= 1; z++)\n            {\t\n                neighbor_index = index + vec3(x, y, z);\n                neighbor_position = neighbor_index + noise3(position_seed * neighbor_index);\n                \n                nearest_distance = min(nearest_distance, distance(position, neighbor_position));\n            }\n        }\n    }\n    \n    return clamp(nearest_distance, 0.0, 1.0);\n}\nfloat get_3d_worley_noise_with_max_radius(in vec3 position, in float max_radius, in mat3 position_seed, in vec3 radius_seed)\n{\n    vec3 index = floor(position);\n        \n    float nearest_distance = 1e20;\n    float radius = 0.0;\n    vec3  neighbor_index = vec3(0);\n    vec3  neighbor_position = vec3(0);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int z = -1; z <= 1; z++)\n            {\t\n                neighbor_index = index + vec3(x, y, z);\n                neighbor_position = neighbor_index + noise3(position_seed * neighbor_index);\n                \n                radius = max_radius * noise(dot(radius_seed, neighbor_index));\n                \n                nearest_distance = min(nearest_distance, distance(position, neighbor_position) / radius);\n            }\n        }\n    }\n    \n    return clamp(nearest_distance, 0.0, 1.0);\n}\nfloat get_3d_worley_noise_with_smin(vec3 position, mat3 position_seed, float smoothness)\n{\n    vec3 index = floor(position);\n        \n    float nearest_distance = 1e20;\n    vec3  neighbor_index = vec3(0);\n    vec3  neighbor_position = vec3(0);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int z = -1; z <= 1; z++)\n            {\t\n                neighbor_index = index + vec3(x, y, z);\n                neighbor_position = neighbor_index + noise3(position_seed * neighbor_index);\n                \n                nearest_distance = smin(nearest_distance, distance(position, neighbor_position), smoothness);\n            }\n        }\n    }\n    \n    return clamp(nearest_distance, 0.0, 1.0);\n}\n\nfloat get_4d_worley_noise(vec4 position, mat4 position_seed)\n{\n    vec4 index = floor(position);\n        \n    float nearest_distance = 1e20;\n    vec4  neighbor_index = vec4(0);\n    vec4  neighbor_position = vec4(0);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int z = -1; z <= 1; z++)\n            {\t\n                for (int w = -1; w <= 1; w++)\n                {\t\n                    neighbor_index = index + vec4(x, y, z, w);\n                    neighbor_position = neighbor_index + noise4(position_seed * neighbor_index);\n\n                    nearest_distance = min(nearest_distance, distance(position, neighbor_position));\n            \t}\n            }\n        }\n    }\n    \n    return clamp(nearest_distance, 0.0, 1.0);\n}\nfloat get_4d_crater_noise(in vec4 position, in float max_radius, in mat4 position_seed, in vec4 radius_seed)\n{\n    vec4 index = floor(position);\n        \n    float nearest_distance = 1e20;\n    float radius = 0.0;\n    vec4  neighbor_index = vec4(0);\n    vec4  neighbor_position = vec4(0);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int z = -1; z <= 1; z++)\n            {\t\n                for (int w = -1; w <= 1; w++)\n                {\t\n                    neighbor_index = index + vec4(x, y, z, w);\n                    neighbor_position = neighbor_index + noise4(position_seed * neighbor_index);\n\n                    radius = max_radius * noise(dot(radius_seed, neighbor_index));\n\n                    nearest_distance = min(nearest_distance, distance(position, neighbor_position) / radius);\n            \t}\n            }\n        }\n    }\n    \n    return clamp(nearest_distance, 0.0, 1.0);\n}\nfloat get_4d_smooth_worley_noise(vec4 position, mat4 position_seed, float smoothness)\n{\n    vec4 index = floor(position);\n        \n    float nearest_distance = 1e20;\n    vec4  neighbor_index = vec4(0);\n    vec4  neighbor_position = vec4(0);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            for (int z = -1; z <= 1; z++)\n            {\t\n                for (int w = -1; w <= 1; w++)\n                {\t\n                    neighbor_index = index + vec4(x, y, z, w);\n                    neighbor_position = neighbor_index + noise4(position_seed * neighbor_index);\n\n                    nearest_distance = smin(nearest_distance, distance(position, neighbor_position), smoothness);\n            \t}\n            }\n        }\n    }\n    \n    return clamp(nearest_distance, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NOTE: render Sol by default\n    ///*\n    float star_mass = SOLAR_MASS;\n    float star_radius = SOLAR_RADIUS;\n    float view_distance = 6.0*SOLAR_RADIUS;\n    float exposure_intensity = 2e11; // Watts/m^2\n    //*/\n    /*\n    // NOTE: uncomment to see Sigma Orionis Aa, a blue main sequence star\n    float star_mass = 18.*SOLAR_MASS;\n    float star_radius = 5.6*SOLAR_RADIUS;\n    float view_distance = 30.0*SOLAR_RADIUS;\n    float exposure_intensity = 8e12; // Watts/m^2\n    */\n    \n    float u = 170e3; // reference unit, we scale the scene to these units to work within precision limitations\n\n    // star properties, scaled to reference units\n    vec3  B0    = vec3(0,0,0)/u;  // center of the star\n    float h     = 170e3/u; // scale height of photosphere\n    float t     = approx_surface_temperature(star_mass);\n    float tc    = approx_core_temperature_of_star(star_mass, star_radius, 0.6*DALTON);\n    float rt0   = star_radius/u;      // radius at which temperature is assumed to be 0\n    float rt    = rt0*get_fraction_of_radius_for_star_with_temperature(t, tc); // radius at which temperature is assumed to be known \"surface temperature\"\n    float r1    = rt + 1.0*h;  // upper radius at which to start the raymarch\n    float r0    = rt - 5.0*h; // lower radius at which to stop the raymarch\n    float rbeta = rt - 1.0*h;  // radius at which beta_* variables are sampled\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mat4  projection_matrix_inverse = mat4(0.5,0,0,0,\n                                           0,0.3,0,0,\n                                           0,0,0,-1,\n                                           0,0,-1,1);\n    \n     \n    vec2  screenspace    = fragCoord/iResolution.xy;\n    vec2  clipspace = vec2(\n        0.5*(mod(4.0 * screenspace.x, 2.0) - 1.0), \n        2.0 * screenspace.y - 1.0\n    );\n    \n    \n    bool IS_FIRST_PERSON_POV = screenspace.x > 0.5;\n    mat4  view_matrix_inverse;\n    if(IS_FIRST_PERSON_POV){\n        vec3 position = normalize(vec3(-5,1,0))*rbeta*1.0005;\n        vec3 up    = normalize(position);\n        vec3 right = vec3(0,1,0);\n        vec3 front = normalize(cross(up, right));\n        view_matrix_inverse = \n            get_translation_matrix(-position) *\n            get_rotation_matrix(up, -3.0*PI*mouse.x) * \n            get_rotation_matrix(right, PI/2.0-PI*mouse.y) * \n            inverse(mat4(vec4(right,0), vec4(up,0), vec4(front,0), vec4(0,0,0,1)));\n    } else {\n        view_matrix_inverse = \n            // NOTE: rotation is disabled due to precision issues on windows \n            //get_rotation_matrix(vec3(0,1,0), 6.3*mouse.x) * \n            //get_rotation_matrix(vec3(1,0,0), PI/2.0+PI*mouse.y) *\n            //get_translation_matrix(vec3(0,0,view_distance/u)) *\n            get_translation_matrix(vec3(0,0,rt0+(1.0+mouse.y)*6.0*rt0)) *\n            mat4(1);\n    }\n    \n    vec3  view_direction = normalize(view_matrix_inverse * projection_matrix_inverse * vec4(clipspace, 1, 1)).xyz;\n    vec3  view_origin    = view_matrix_inverse[3].xyz;\n\n    vec3  E = vec3(0); // total intensity for each color channel, found as the sum of light intensities for each path from the light source to the camera\n    \n\n    // view ray\n    vec3 V0 = view_origin;\n    vec3 V  = view_direction;\n    vec3 Vi = V0;            // point along view ray\n    \n    // light ray\n    // static\n    //vec3 L  = normalize(vec3(1,0,0)); \n    // daylight hours only\n    vec3 L  = (get_rotation_matrix(vec3(0,1,0), 0.1*PI*sin(0.1*iTime)) * \n               get_rotation_matrix(vec3(0,0,1), -PI*26.3/180.) * \n               vec4(1,0,0,1)).xyz;\n    // realistic\n    //vec3 L  = (get_rotation_matrix(vec3(0,1,0), 0.1*iTime) * vec4(1,0,0,1)).xyz;\n\n    // \"beta_*\" is the rest of the fractional loss.\n    // it is dependant on wavelength, and the density ratio\n    // So all together, the fraction of sunlight that scatters to a given angle is: beta(wavelength) * gamma(angle) * density_ratio\n    vec3  beta_ray_sun   = vec3(5.20e-6, 1.21e-5, 2.96e-5) * u;\n    vec3  beta_mie_sun   = vec3(1e-6)*u;\n    vec3  beta_abs_sun   = vec3(1e-6)*u;\n\n    maybe_vec2  air_along_view_ray  = \n        get_bounding_distances_along_ray(\n            get_distances_along_line_to_negation(\n                get_distances_along_3d_line_to_sphere(V0, V, B0, r1),\n                get_distances_along_3d_line_to_sphere(V0, V, B0, r0)\n            )\n        );\n    \n    if(!air_along_view_ray.exists) \n    { \n        // nothing to see here folks, move along\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    const mat4 K4x4 = mat4(\n        1.5423, 0.9954, 1.3921, 1.8733,\n        4.3321, 2.3321, 3.8328, 2.6285,\n        0.4413, 4.0035, 2.1032, 1.6807,\n        5.9848, 6.8009, 5.9021, 3.7348\n      );\n    const mat3 K3x3 = mat3(\n        1.5423, 0.9954, 1.3921,\n        4.3321, 2.3321, 3.8328,\n        0.4413, 4.0035, 2.1032\n      );\n    const vec4 K4 = vec4(5.9453, 2.6534, 3.5767, 1.4135);\n    \n    if(air_along_view_ray.exists)\n    {\n        float v0 = air_along_view_ray.value.x;\n        float v1 = air_along_view_ray.value.y;\n        vec3 E_emitted = get_rgb_intensity_of_light_emitted_by_sun(\n            V0,V,v0,v1, vec3(650e-9*METER, 550e-9*METER, 450e-9*METER),\n            B0, rt0, rbeta, tc, h,\n            beta_ray_sun, beta_mie_sun, beta_abs_sun\n        );\n        vec3 E_attenuated = E_emitted * get_surface_area_of_sphere(star_radius)/get_surface_area_of_sphere(view_distance);\n        E += E_attenuated;\n        vec4 Vt = vec4((V0 + V*v0)/rt0, iTime/300.);\n        float x = 0.0;\n        x += 0.60 * (1.0 - get_4d_worley_noise(240.0*Vt, K4x4));\n        x += 0.30 * (1.0 - get_4d_worley_noise(80.0*Vt, K4x4));\n        x += 0.15 * (1.0 - get_4d_worley_noise(30.0*Vt, K4x4));\n        //x += 0.30 * get_3d_perlin_noise(5.0*Vt, Kr);\n        E *= 0.8+0.4*x;\n        //E *= 1.0-((1.0-get_3d_worley_noise_with_max_radius(2.0*Vt, 0.2, K, Kr)) * 2.0*get_3d_perlin_noise(5.0*Vt, Kr));\n        E *= get_3d_worley_noise_with_max_radius(2.0*Vt.xyz, 0.2, K3x3, K4.xyz);\n    }\n    \n    //fragColor = world_along_view_ray.exists? vec4(vec3(1),1) : vec4(vec3(0),1);\n    vec3  ldr_tone_map = 1.0 - exp(-E/exposure_intensity);\n\n    fragColor = vec4(get_rgb_signal_of_rgb_intensity(ldr_tone_map), 1);\n    //if((E.x==0.)){fragColor.x = 1.0;} else {fragColor.x=0.0;}\n\n}","name":"Image","description":"","type":"image"}]}