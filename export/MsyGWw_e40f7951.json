{"ver":"0.1","info":{"id":"MsyGWw","date":"1454880356","viewed":1013,"name":"Video metal plate","username":"TambakoJaguar","description":"Nothing special, just a metal play showing the image of your camera like it was engraved in a metal plate made out of silver, gold or copper. You can move around the scene with the mouse.","likes":16,"published":1,"flags":34,"usePreview":0,"tags":["reflection","mouse","video","webcam","metal","silver","rotation","gold","copper","plate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Video metal plate\" by Emmanuel Keller aka Tambako - February 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n// Much code adapted from https://www.shadertoy.com/view/Xds3zN, thanks iq to let us use it! :)\n\n#define pi 3.141593\n\n// Switches, you can play with them!\n#define specular\n//#define shadow\n#define reflections\n//#define ambocc\n\nstruct Lamp\n{\n  vec3 position;\n  vec3 color;\n  float intensity;\n  float attenuation;\n};\n\nstruct RenderData\n{\n  vec3 col;\n  vec3 pos;\n  vec3 norm;\n  int objnr;\n};\n    \nLamp lamps[3];\n\n// Campera options\nvec3 campos;\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir;\nfloat fov = 4.5;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.05;\n\n// Shading options\nconst float specint = 0.45;\nconst float specshin = 12.;\nconst float aoint = 0.2;\nconst float aoMaxdist = 15.;\nconst float aoFalloff = 1.1;\nconst float shi = 0.85;\nconst float shf = 0.4;\n    \n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 50.;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.6;\nconst int aasamples = 2;\n\n// 1D hash function\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// Gets the color of the image parts\nvec3 getImageColor(vec2 uv)\n{\n    vec3 silver = vec3(0.7, 0.72, 0.77);\n    vec3 gold = vec3(0.9, 0.7, 0.1);\n    vec3 copper = vec3(0.8, 0.3, 0.2);\n    vec3 col = texture(iChannel0, uv).rgb;\n    float a = abs(col.r - col.g) + abs(col.g - col.b) + abs(col.b - col.r);\n    float b = abs(col.r - col.g) + abs(col.r - col.b);\n    vec3 col2 = mix(silver, gold, smoothstep(0.45, 0.5, a));\n    return mix(col2, copper, smoothstep(0.65, 0.7, b));\n}\n\n// Gets the bump of the image parts\nfloat getImageBump(vec2 uv)\n{\n    float b = 3. - texture(iChannel0, uv).a;\n    b*= smoothstep(0.47, 0.44, abs(uv.x - 0.5));\n    b*= smoothstep(0.44, 0.41, abs(uv.y - 0.5));\n    return b;\n}\n\n// Converts the position in the world to the 2D mapping coordinates of the texture of the image parts (Buf C)\nvec2 getImageMPos(vec3 pos)\n{\n    return pos.xy*vec2(0.09, 0.125) + vec2(0.5);\n}\n\n// Distance mapping of image\nfloat map(vec3 pos)\n{\n    vec2 hmp = getImageMPos(pos);\n    float hm = 0.4*getImageBump(hmp);\n    return udRoundBox(pos, vec3(5., 3.4, 0.1), 0.25) - hm;\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 75; ++i)\n    {\n    \tpos = ray*t + cam;\n        dist = map(pos);\n        if (dist>maxdist || abs(dist)<0.00004)\n            break;\n        t+= dist*0.8;\n  \t}\n  \treturn vec2(t, 1);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx) - map(pos - q.yxx),\n                          map(pos + q.xyx) - map(pos - q.xyx),\n                          map(pos + q.xxy) - map(pos - q.xxy)));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n\tvec3 rc = 1.5*texture(iChannel1, ray).rgb;\n    return rc;\n}\n\n// Color of the image plate\nvec3 getColor(vec3 pos)\n{\n    vec2 hmp = getImageMPos(pos);\n    return getImageColor(hmp);\n}\n\n// Gets the flares of the lamps (kind of non-reflective specular...)\nvec3 getFlares(vec3 ray)\n{\n\tvec3 rc = vec3(0.);\n    #ifdef bulb\n    rc+= 1.6*clamp(normalize(lamps[1].color)*lamps[1].intensity*specint*pow(max(0.0, dot(ray, normalize(lamps[1].position - campos))), 150.), 0., 1.);\n    #endif\n    return rc;\n}\n\n// From https://www.shadertoy.com/view/Xds3zN, but I changed the code\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<50; i++)\n    {\n    \tfloat h = map(ro + rd*t);\n        res = min(res, 10.0*h/t + 0.02*float(i));\n        t += 0.8*clamp(h, 0.01, 0.35);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tfloat ao = 0.0;\n\tconst int nbIte = 5;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - map(p + rd.x)) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.35*(1.-ao/float(nbIte)), 0., 1.);\n}\n\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(vec3(lamp.position.x, 4.9, lamp.position.z) - pos), shf, 100.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n   vec2 iMouse2;\n   if (iMouse.x==0. && iMouse.y==0.)\n      iMouse2 = iResolution.xy*vec2(0.5, 0.5);\n   else\n      iMouse2 = iMouse.xy;\n   \n   campos = vec3(-20.*cos(0.4 + 2.8*iMouse2.x/iResolution.x),\n                 20.*cos(2.*iMouse2.y/iResolution.y),\n                 20.*sin(0.4 + 2.8*iMouse2.x/iResolution.x)*sin(2.*iMouse2.y/iResolution.y));\n   camdir = camtarget-campos;   \n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    vec2 tr = trace(tpos, ray, maxdist);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    lamps[0] = Lamp(vec3(-2., 5., 20.), vec3(1., 1., 1.), 1.8, 0.01);\n    lamps[1] = Lamp(vec3(15., 3, -8.), vec3(0.9, 0.96, 1.), 1.9, 0.01);\n    lamps[2] = Lamp(vec3(-16., 10., -8.), vec3(1., 0.92, 0.9), 0.4, 0.01);\n    \n    if (tx<maxdist)\n    {\n        norm = getNormal(pos, normdelta);\n        col = getColor(pos);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm, aoMaxdist, aoFalloff));\n        //col = vec3(calcAO(pos, norm, 7., 1.1));\n        #endif\n    }\n    else\n        col = sky_color(ray);\n    return RenderData(col, pos, norm, objnr);\n}\n\n// Main render function with reflections\nvec4 render(vec2 fragCoord)\n{   \n  vec2 uv = fragCoord.xy / iResolution.xy; \n  uv = uv*2.0 - 1.0;\n  uv.x*= iResolution.x / iResolution.y;\n\n  vec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \n  RenderData traceinf = trace0(campos, ray, maxdist);\n  vec3 col = traceinf.col; // + getFlares(ray);\n  #ifdef reflections\n\n  vec3 refray = reflect(ray, traceinf.norm);\n  vec3 skycol = sky_color(refray);\n  float r = clamp(pow(smoothstep(-0.3, 1.7, getImageBump(getImageMPos(traceinf.pos))), 0.5), 0., 1.);\n  col = mix(col, col*skycol, r); \n  //col = vec3(r);\n\n  #endif\n  return vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    setCamera();\n    \n    // Antialiasing.\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = vs/vec4(aasamples*aasamples);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x = 1.- uv.x;\n    vec3 im = texture(iChannel0, uv).xyz;\n    fragColor = vec4(im, dot(im, vec3(1.)));\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int blur_size = 7;\nconst float blur_width = 1.;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)/e); \n}\n\n// Horizontal blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy / iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(x2/iResolution.x, 0.);\n       float g = gauss(x2, float(20*blur_size)*0.5);\n       pixval+= g*texture(iChannel0, ipos);\n       tot+= g;\n   }\n   fragColor = pixval/tot;\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int blur_size = 7;\nconst float blur_width = 1.;\n\nfloat gauss(float x, float e)\n{\n    return exp(-pow(x, 2.)/e); \n}\n\n// Vertical blurring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pos = fragCoord.xy / iResolution.xy;\n   vec4 pixval = vec4(0.);\n   float tot = 0.;\n    \n   const int nb = 2*blur_size+1;\n   \n   for (int x=0; x<nb; x++)\n   { \n       float x2 = blur_width*float(x-blur_size);\n       vec2 ipos = pos + vec2(0., x2/iResolution.x);\n       float g = gauss(x2, float(20*blur_size)*0.5);\n       pixval+= g*texture(iChannel0, ipos);\n       tot+= g;\n   }\n   fragColor = pixval/tot;\n}","name":"Buf C","description":"","type":"buffer"}]}