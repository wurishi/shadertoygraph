{"ver":"0.1","info":{"id":"llVyWt","date":"1538197226","viewed":202,"name":"ts-template","username":"teraspora","description":"This shader  is fundamentally a template for slotting shader code into.\nYou get normalised coordinates, borders and tiling for free.\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["template"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ts-template - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Date: 29 SEP 2018.\n\n// NOTE: This shader  is fundamentally a template for slotting shader code into.\n// You get normalised coordinates, borders and tiling.\n\n// It contains a number of functions not currently used;\n// they are there for ease of adaptation and in the spirit of FOSS;\n// also because I am passionate about discovering, inventing and\n// adapting ideas which I can fashion into useful tools and \n// so am startng to build up a toolset I can use intuitively.\n\n// I want to have them always available, so I am (for now, anyway) building every\n// shader in this template, in which I have to an extent factored out the\n// tiling code and border code into separate functions.\n\n// -----------------------------------------------------------------------------\n\n// Copyright Â© 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// -----------------------------------------------------------------------------\n\nconst float PI = 3.141592654;\nconst float TWO_PI = 6.283185307;\nconst float HALF_PI = 1.5707963267948966;\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 cyan =       vec3(0.0,  1.,   0.84);\nconst vec3 magenta =    vec3(1.0,  0.,   1.0 );\nconst vec3 blue =       vec3(0.0,  0.6,  0.84);\nconst vec3 gold =       vec3(1.0,  0.84, 0.66);\nconst vec3 orange =     vec3(1.0,  0.2,  0.0 );\nconst vec3 yellow =     vec3(1.0,  1.0,  0.0 );\nconst vec3 dark_blue =  vec3(0.0,  0.05, 0.15);\nconst vec3 crimson =    vec3(0.76, 0.0,  0.42);\n    \nvec3[] cols = vec3[](magenta, cyan, crimson, blue, orange, yellow);\nint cl = cols.length();\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\nfloat tileIndex;\n\n// My inline library of useful functions:\n\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n// =======================================\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n}\n\n// MAIN METHOD:\n\nvec3 doStuff(vec2 pixel, vec2 res) {\n    // just takes a pixel and a context and outputs a\n    // colour to mainImage, which keeps things organised\n    // and encapsulated.\n    \n    \n    // Set this var to the number of tiles across and down:\n    float tileDim = 3.;\n    float numTiles = tileDim * tileDim;\n        \n    // the output vector, before normalisation,\n    // giving the position the program needs to know!-\n    vec2 pp = pixel;\n    vec2 hr = res / tileDim;\t// resolution of one tile\n    \n    \n    \n    // ===============================================================\n    \n    // Normalisation and tiling:\n    // ========================\n    \n    // Make numTiles sub-frames:\n    vec2 n = vec2(float(int(pixel.x / res.x * tileDim)), float(int(pixel.y / res.y * tileDim)));\n    \n    float tile = numTiles -(n.y * tileDim + n.x) - 1.; \n    // start at 1 so we don't lose stuff when multiplying\n    float toe = fract(tile / 2.) * 4. - 1.; // returns 1. if tile index odd, -1. if even;\n    float tile2 = tile * tile;\n    \n    // Offset the start of each rendition:\n    float time = tile * 32. + iTime;\n    // shift back to the first tile if in any other tile:\n    pp.x -= hr.x * n.x;\n    pp.y -= hr.y * n.y;\n    // normalise to [0, 1[, shift to make unit quad with origin in centre\n    vec2 q = pp / hr - 0.5;     // normalise\n    // then scale:\n    float scaleFactor = 20.0 * nsin(time * 0.125);\n    q /= scaleFactor;\n    \n    // variation...\n    if (toe < 0.) {\n        q = q.yx;\n    }\n    if (tile == 1.) {\n    \tq = rotate(q, HALF_PI);\n    }\n    \n    // ===============================================================================================\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Main code for the shader goes here:\n    // ===============================================================================================\n    \n    vec3 col = vec3(0.);\n    if (tile == 4.) {\n        //q = mod(q, 0.333333333334);\n        time = sqrt(time);\n    }\n    q *= vec2(ncos(ncos(time)), nsin(ncos(time)));\n    col = vec3(nsin(time), nsin(length(q) * time * 25.), ncos(q.x + q.y));\n    if (tile == 4.) {\n    \tcol = col.brg;\n    }\n    \n    if (toe < 0.) {\n        col = col.bgr;    \t\n    }\n    \n    // ===============================================================================================\n    // ===============================================================================================\n    // ===============================================================================================\n    \n    // Border code:    \n    // ===============================================================================================\n    \n    float borderWidth = 3.;\n    vec3 borderInsetLineColour = white;\n \t\n    col = drawBorder(col, borderWidth, borderInsetLineColour, pp, hr, tile);\n    // finally return the colour to caller(mainImage()):     \n    return col;\n}\t// END doStuff()\n    // ===============================================================================\n\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {    \n    float borderWidth = 6.;\n    vec3 borderInsetLineColour = white;\n \tvec3 col = doStuff(fragCoord, iResolution.xy);\n    col = drawBorder(col, borderWidth, borderInsetLineColour, fragCoord, iResolution.xy, -1.);\n    // finally return the colour:\n    fragColor = vec4(col, 1.0);        \n}\n    \n    \n    ","name":"Image","description":"","type":"image"}]}