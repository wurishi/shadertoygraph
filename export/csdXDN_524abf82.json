{"ver":"0.1","info":{"id":"csdXDN","date":"1680166813","viewed":91,"name":"The glowy marshes","username":"frettini","description":"Was working on another shader with glowing effects. Stumbled upon this cool effect whilst debugging the glow.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n#define RAYMARCHSTEPS 50\n\n#define MATERIAL1 1.\n#define MATERIAL2 2.\n\n#define MINDIST 0.2\n#define MAXDIST 30.0\n\nstruct Hit\n{\n    float rayDist;\n    float matID;\n    vec4 glowCol;\n};\n\nmat3 LookAt(vec3 pos, vec3 target)\n{\n    vec3 forward = normalize(target - pos);\n    vec3 right = normalize(cross(forward,vec3(0.,1.,0.)));\n    vec3 up = normalize(cross(right, forward));\n        \n    return mat3(right,\n                up,\n                forward);\n}\n\n// HASH ----------------------------------------------------------\n//https://www.shadertoy.com/view/XdGfRR, David Hoskins. May 2018\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n// OPERATIONs ----------------------------------------------------\nHit Union(Hit hit1, Hit hit2)\n{\n    if(hit1.rayDist < hit2.rayDist){ return hit1; }\n    else{ return hit2; }\n}\n\nHit Substract(Hit hit1, Hit hit2)\n{\n    if(-hit1.rayDist > hit2.rayDist){ return  Hit( -hit1.rayDist, hit1.matID, hit1.glowCol ); }\n    else{ return hit2; };\n}\n\nHit Intersect(Hit hit1, Hit hit2)\n{\n    if(hit1.rayDist > hit2.rayDist){ return  hit1; }\n    else{ return hit2; };\n}\n\n\nHit SmoothIntersect( Hit hit1, Hit hit2, float k ) \n{\n    Hit result;\n    float h = clamp(0.5-0.5*(hit2.rayDist - hit1.rayDist)/k, 0.0, 1.0);\n    result.rayDist = mix(hit2.rayDist, hit1.rayDist, h) + k*h*(1.0-h);\n    result.matID = hit1.matID; // TODO : this is a simplification for now\n    return result;\n}\n\n// ---------------------------------------------------------------\n// From https://www.shadertoy.com/view/ldB3zc - Inigo Quilez, 2014\nfloat almostIdentity( const float x, const float m, const float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvoid Voronoi(vec2 pos, float smoothF, out float distToClosest, out vec3 cellCol)\n{\n    vec2 grid = floor(pos.xy);\n    vec2 fraction = fract(pos.xy);\n    \n    distToClosest = 8.0;\n    cellCol = vec3(0.);\n    float scaleOffset = 0.; \n    \n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++)\n    {\n        \n        vec2 cell = vec2(float(i),float(j));\n        vec2 offset = hash22(grid+cell);\n        \n        float cellHash =  hash1(dot(cell+grid,vec2(7.0,113.0)));\n\n        float dist = pow(length((cell + offset) - fraction),2.0+cellHash*1.) + cellHash*cos(iTime)*0.5+0.5;\n        \n         // cell color\n        \n\t\tvec3 col = 0.5 + 0.5*sin(cellHash*2.5 + 3.5 + vec3(2.0,3.0,0.0));\n        // in linear space\n        col = col*col;\n        \n        float h = smoothstep(-1.0,1.0, (distToClosest-dist)/smoothF);\n        float q = h*(1.-h)*smoothF/(1.+3.*smoothF);\n        \n        scaleOffset = mix(cellHash, scaleOffset,h) - q;\n        distToClosest = mix(distToClosest, dist , h) - q ;\n        //distToClosest = almostIdentity(distToClosest, 0.4, 0.6);\n        \n        cellCol = mix(cellCol, col, h) - q;\n    }\n       \n    //distToClosest = pow( distToClosest, 2.);\n}\n// ---------------------------------------------------------------\n\n\n// SDFs ----------------------------------------------------------\n\nfloat SDPlane(vec3 pos, vec3 planeNormal, float planeHeight)\n{\n    // planeNormal must be normalized\n    return dot(pos, planeNormal) + planeHeight;\n}\n\nfloat SDTerrain(vec3 pos)\n{\n    float planeDist = SDPlane(pos, vec3(0.,1.,0.),0.);\n    float scale = 0.5;\n    vec2 grid = floor(pos.xz*scale);\n    vec2 interp = fract(pos.xz*scale);\n    float bottomLeft = hash12(grid);\n    float bottomRight = hash12(grid+vec2(1.,0.));\n    float topLeft = hash12(grid+vec2(0.,1.));\n    float topRight = hash12(grid+vec2(1.,1.));\n    float bottomMix = mix(bottomLeft, bottomRight, interp.x);\n    float topMix = mix(topLeft, topRight, interp.x);\n    float finalMix = mix(bottomMix, topMix, interp.y)*0.8;\n    \n    float smoothFactor = 0.3;\n    float voronoiDist = 0.;\n    vec3 outCol = vec3(0.); \n    Voronoi(pos.xz*0.5, smoothFactor, voronoiDist, outCol);\n    \n    return planeDist + finalMix*0. + voronoiDist;\n    //return planeDist + finalMix*0. + exp(-voronoiDist*1.);\n\n    \n}\n\nfloat SDSphere(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    return length(pos - spherePos) - sphereRadius;\n}\n\nfloat SDRoundedCube(vec3 pos, vec3 cubeOrigin, vec3 cubeExtent, float cubeRadius)\n{\n    vec3 q = abs(pos - cubeOrigin)  - cubeExtent;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - cubeRadius;\n}\n\nfloat SDSlab(vec3 pos, float slabHeight, float slabWidth)\n{\n    return abs(pos.y-(slabHeight + slabWidth));\n}\n\n//---------------------------------------------------------------\n\nHit GetGlowDistance(vec3 pos, Hit sceneHit)\n{\n    vec3 glowSpherePos = vec3(0., 0.7, 0.);\n    float glowSphereRadius = 0.2 ;\n    \n    vec3 cubeOrigin = vec3(0., 0., 0.);\n    vec3 cubeExtent = vec3( 10., 1., 0.05);\n    float cubeRadius = 0.01;\n\n    Hit glowHit = Hit(MAXDIST,-1., vec4(0.));\n    float glowDist = SDSlab(pos, 0., 0.2);\n    glowHit = Union( Hit(glowDist, MATERIAL2, vec4(0.)), glowHit);\n    glowHit = Intersect( Hit(glowDist+0.01, MATERIAL2, vec4(0.)), sceneHit);\n    glowHit =  Union( Hit(SDSphere(pos, glowSpherePos, glowSphereRadius), MATERIAL2, vec4(0.)), glowHit);\n    return glowHit;\n    \n}\n\n// from the position, return the distance and material of the closest object\nHit GetDistance(vec3 pos)\n{\n    vec3 spherePos = vec3(0., 0., 0.);\n    float sphereRadius = 0.3;\n    \n    vec3 planeNormal = vec3(0., 1., 0.);\n    float planeHeight = 0.;\n    \n    // Compute Distance to Scene\n    Hit rayHit = Hit(MAXDIST,-1., vec4(0.));\n    float sceneDist = SDTerrain(pos);\n    rayHit = Union( Hit(sceneDist, MATERIAL2, vec4(0.01)), rayHit);\n    \n    // Compute Distance to Emissive Sections\n    Hit glowHit = GetGlowDistance(pos, rayHit); \n    \n    float absorptionCoef = 2.;\n    float lightAttenuation = 1.0;\n    \n    if(glowHit.rayDist < 0.01)\n    {\n        lightAttenuation = 1.0;\n    }\n    else\n    {\n        lightAttenuation = exp( - absorptionCoef * glowHit.rayDist )/1.;\n    }\n    \n    vec3 glowCol = 0.5 + 0.5*cos(iTime+pos.xyx+vec3(0,2,4));\n    \n    vec4 sphereGlowCol = vec4( glowCol, lightAttenuation);    \n    \n    rayHit.glowCol = sphereGlowCol;\n    glowHit.glowCol = sphereGlowCol;\n    \n    float invInterp = smoothstep(0., 0.1, glowHit.rayDist);\n    rayHit.matID += 1.0 - invInterp;\n\n    return glowHit;\n}\n\n// using the specified ray, step through the ray and check against the SDF until the distance is small\n// enough to say that we have hit something.\nvoid Raymarch(vec3 rayOrigin, vec3 rayDirection, vec2 fragCoord, out Hit resultHit)\n{\n    float tmin = MINDIST;\n    float tmax = MAXDIST;\n    \n    vec4 glowCol = vec4(0.,0.,0.,1.);\n    float nearest = 0.;\n    float t = tmin;\n    float previousStep = MINDIST;\n    for(int i = 0; i < RAYMARCHSTEPS && t < tmax; i++)\n    {\n        vec3 testPos = rayOrigin + rayDirection * t;\n        \n        Hit rayHit = GetDistance(testPos);\n                \n        // Volumetric Rendering integration\n        float absorptionCoef = 0.2;\n        if(rayHit.glowCol.w > nearest)\n        {\n            nearest = rayHit.glowCol.w;\n        }\n        glowCol.w *= exp(-previousStep*absorptionCoef) ;\n        glowCol.xyz += rayHit.glowCol.xyz * rayHit.glowCol.w * previousStep * glowCol.w; \n        \n        // if distance is smaller than a given threshold, consider that a Hit\n        if(abs(rayHit.rayDist) < 0.001*t )\n        {\n            // return the distance along the ray and the material ID of what we Hit\n            glowCol.w = nearest;\n            \n            resultHit = Hit(t, rayHit.matID, glowCol);\n            \n            return;\n        }\n        \n        float rayStep = min(rayHit.rayDist, MAXDIST/float(RAYMARCHSTEPS));\n        t += rayStep; \n        previousStep = rayStep;//MAXDIST-t;         \n       \n    }\n    glowCol.w = nearest;\n    resultHit.glowCol = glowCol;\n    \n}\n\n// from : https://iquilezles.org/articles/normalsSDF/\n// tetrahedon method to get the normal of a SDF\nvec3 GetNormal(vec3 pos)\n{\n    // trick the compiler to avoid inlining the Map function\n    #define ZERO (min(0, iFrame))\n    \n    float eps = 0.0001;\n    \n    vec3 normal = vec3(0.);\n    \n    for(int i = ZERO; i < 4 ; i++)\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        normal += e*GetDistance(pos+e*eps).rayDist;\n    }\n    \n    return normalize(normal);\n}\n\n\n// Once we know what we hit, we can start material calculations\nvec3 GetColour(vec3 rayOrigin, vec3 rayDirection, Hit rayHit)\n{\n    vec3 backgroundCol = vec3(0.15);\n    vec3 col = backgroundCol;\n    if(rayHit.matID > 0.)\n    {\n        vec3 pos = rayOrigin + rayDirection * rayHit.rayDist;\n        \n        // PLANE\n        if(rayHit.matID >= 1. && rayHit.matID < 1.99)\n        {\n            float smoothFactor = 0.;\n            float outDist = 0.;\n            vec3 outCol = vec3(0.); \n            Voronoi(pos.xz*0.5, smoothFactor, outDist, col);\n            col = sqrt(col);\n\n            vec3 normal = GetNormal(pos);\n            vec3 reflect = reflect(rayDirection, normal);\n            vec3 dirLightCol = vec3( 0.99,0.95,0.1);\n            vec3 dirLightDir = normalize(vec3(-0.5, -1.0,0.));\n            float dirLightIntensity = 4.0;\n            col *= dot(normal, -dirLightDir) * dirLightCol;  \n            \n        }\n        // SPHERE\n        else if(rayHit.matID >= 2. && rayHit.matID < 2.99)\n        {\n            vec3 normal = GetNormal(pos);\n            vec3 reflect = reflect(rayDirection, normal);\n            \n            col = vec3((normal + 1.0)/2.0);\n\n            // some kind of lighting\n            vec3 dirLightCol = vec3( 0.99,0.95,0.1);\n            vec3 dirLightDir = normalize(vec3(-0.5, -1.0,0.));\n            float dirLightIntensity = 4.0;\n            col *= dot(normal, -dirLightDir) * dirLightCol;\n            \n            col = mix(col, rayHit.glowCol.xyz, fract(rayHit.matID));\n        }\n        else\n        {\n            col = rayHit.glowCol.xyz;\n        }\n        \n#if 0\n        float absorptionCoef = 0.08;\n        float transmittance = exp( - absorptionCoef * rayHit.rayDist);\n        col = (1.0 - transmittance) * backgroundCol + transmittance * col;\n#else  \n        // smooth out things in the background ( could use beer lambert law but makes everything a bit darker)\n        float normDist = rayHit.rayDist / MAXDIST;\n        float smoothDist = smoothstep(0.2,1.0, normDist);\n#endif\n    }\n    \n    float alpha = rayHit.glowCol.w;\n    col = col * (1.0-alpha)  + rayHit.glowCol.xyz*alpha ;\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.2;\n    float focalDistance = 2.5;\n    vec3 rayOrigin = vec3(cos(iTime*speed)*1.5,0.1,sin(iTime*speed)*1.5);\n    vec3 rayTarget = vec3(0., 0.1, 0.);\n    \n    mat3 lookAt = LookAt(rayOrigin, rayTarget);  \n\n    vec3 result = vec3(0.);\n\n#if AA>1\n    for(int hOffset = 0; hOffset < AA; hOffset++)\n    for(int vOffset = 0; vOffset < AA; vOffset++)\n    {\n\n        vec2 pixelOffset = vec2(float(hOffset), float(vOffset)) / float(AA) - 0.5;\n        // Normalized pixel coordinates (from -1.0 to 1.0)\n        vec2 uv = ((fragCoord + pixelOffset)*2.0 - iResolution.xy)/iResolution.y;\n#else\n        vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n#endif\n      \n        // Get the ray direction by building the ray in camera space and transforming it using the lookAt matrix\n        vec3 cameraRayDir =  normalize( vec3(uv, focalDistance) );\n        vec3 rayDirection = normalize(lookAt * cameraRayDir);\n\n        Hit rayHit = Hit(MAXDIST, -1., vec4(0.));\n        Raymarch( rayOrigin, rayDirection, fragCoord, rayHit);\n        vec3 col = GetColour(rayOrigin, rayDirection, rayHit);\n        \n        result += col;\n#if AA>1\n    }\n    result /= float(AA*AA);\n#endif\n    \n    \n    // Output to screen\n    fragColor = vec4(result,1.0);\n}","name":"Image","description":"","type":"image"}]}