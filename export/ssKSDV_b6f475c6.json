{"ver":"0.1","info":{"id":"ssKSDV","date":"1635354156","viewed":242,"name":"Trail Test 3","username":"SnoopethDuckDuck","description":"WIP\ngoes a bit crazy if you leave it too long","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["e"],"hasliked":0,"parentid":"ssVSDK","parentname":"CryptoRoyale Trails Test 3"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 blob(vec2 uv, float scale, float delay) {    \n    // dark outer circle\n    float c0 = 0.5 * step(length(uv), scale);\n   \n    // outline (fudged)\n    float oc = 0.5 * step(length(uv), 1.12 * scale);\n    oc -= c0;\n     \n    // light inner circle\n    float c1 = step(length(uv + (sqrt(2.)/9.) * scale * vec2(1,-1)), 7./9. * scale);\n    c0 = max(c0, c1);\n    \n    // 2 dark inner dots\n    float c2 = 2. * step(length(uv - 0.3 * scale * vec2(-0.5 , 1.5)), 0.2 * scale);\n    float c3 = 2. * step(length(uv + 0.3 * scale * vec2(1.6, 0.)), 0.15 * scale);\n    c0 = max(c0, max(c2, c3));\n    \n    vec3 col;\n    if (c0 == 0.5 || c0 == 2.)\n        col = getDarkCol(iTime + delay);\n    else if (c0 == 1.)\n        col = getLightCol(iTime + delay);\n    if (oc == 0.5)\n        col = vec3(0.01); // looks black but isn't\n\n    return col;  \n}\n\nvec3 blob2(vec2 uv, float scale) {\n     // dark outer circle\n    float c0 = 0.5 * step(length(uv), scale);\n   \n    // light inner circle\n    float c1 = step(length(uv + (sqrt(2.)/9.) * scale * vec2(1,-1)), 7./9. * scale);\n    c0 = max(c0, c1);\n    \n    vec3 col;\n    if (c0 == 0.5)\n        col = getDarkCol(iTime);\n    else if (c1 == 1.)\n        col = getLightCol(iTime);   \n\n    return col;  \n}\n\nvec3 blob3(vec2 uv, float scale) {\n    return vec3(step(length(uv), scale));\n}\n\nfloat h21 (vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 getPos(vec2 uv, float delay, float a, float b) {\n    return .3 * vec2(cos(a * (time - delay)), sin(b * (time - delay)));\n   // return uv - .3 * vec2(cos(time - delay), sin(0.8 * (time + 0.5 * cos(1. * uv.x + cos(4. * uv.x +2.* iTime) + iTime) - delay)));\n}\n\nfloat osc(int i, int num) {\n   // return (1.-float(i) / float(num));// * ( .75 + .25 * cos(4. * iTime + 3. * float(i)));\n    return .5 + .5 * cos(1. * iTime + float(i));\n   // return .5 + .5 * cos(time + 0.3 * float(i));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y;\n    uv += 0.08 * iTime;\n    float n = 1.8 + 1.2 * tanh(0.08 * iTime);\n    vec2 ipos = floor(n * uv); // ?\n    uv = fract(n * uv) - 0.5;\n    \n    float size = 0.1;\n      \n    const int num = 15;\n    //vec2[num] points;\n    float initDelay = 4. * h21(ipos);\n    float a = .5 + .5 * cos(initDelay + 0.006 * iTime);\n    float b = .5 + .5 * sin(initDelay + 0.005 * iTime);\n    \n    float delay = initDelay;\n\n    vec3 c;\n    for (int i=0; i<num; i++) {\n        float scale = 1.;//osc(i, num);\n\n        vec2 p1 = getPos(uv,delay,a,b);\n        delay += 0.2;// * scale;\n        vec2 p2 =  getPos(uv,delay,a,b);\n        \n        float seg = sdSegment(uv, p1, p2);\n        \n        // vec2 dir = normalize(p1 - p2);\n        \n       // float a = 0.1 - scale * (0.1) * (.5 + .5 * cos(-8. * iTime + 100. * float(i)));\n        float a = 0.02 + 0.1 * initDelay * (.5 + .5 * cos(float(i) + iTime));\n        vec3 segCol = vec3(smoothstep(-a, a, scale * 0.01 - seg)) * getDarkCol(iTime + initDelay);\n\n        c = max(c, segCol);    \n    }\n      \n    c = pow(4. * c * (1.-c), vec3(16.));\n    vec3 col = blob(uv - getPos(uv, initDelay,a,b), 0.5 * size, initDelay); // * osc(0,num)\n    float k = step(0.01, length(col));\n    c = k * col + (1.-k) * c;\n    \n    // background (roughly works)\n    c = max(c, vec3(36,26,91)/255.);\n   \n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define time 3. * iTime\n\nvec3 getDarkCol(float t) {\n    float colTime = fract(0.15 * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 220., 244.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(245., 208., 0.) / 255.;\n    else\n        col = vec3(219., 0., 255.) / 255.;\n    return col;\n}\n\nvec3 getLightCol(float t) {\n    float colTime = fract(0.15 * t);\n    vec3 col;\n    if (colTime < 1./3.)\n        col = vec3(0., 255., 195.) / 255.;\n    else if (colTime < 2./3.)\n        col = vec3(238., 243., 0.) / 255.;\n    else\n        col = vec3(255., 59., 235.) / 255.;\n    return col;\n}\n","name":"Common","description":"","type":"common"}]}