{"ver":"0.1","info":{"id":"3dXcW4","date":"1584745800","viewed":101,"name":"RayMarch BALL","username":"Pacan1337","description":"THE BALL","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MaxSteps 500\n#define Tol 0.001\n#define MaxDistance 1000.\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n\tvec3 color;   \n};\n    \nstruct PointLight\n{\n    vec3 pos;\n    float radius;\n    float intencity;\n    float brightness;\n    vec3 color;\n};\n\nfloat SphereDist(in vec3 point, Sphere sphere, out vec3 defuseColor)\n{\n    defuseColor = sphere.color;\n    \n    return distance(point, sphere.center) - sphere.radius;\n}\n\nfloat FloorDist(in vec3 point, out vec3 defuseColor)\n{\n    defuseColor = vec3(0.8);\n    \n    return point.z;\n}\n\nfloat smin (float a, float b)\n{\n    float m = min(a, b);\n    float dif = abs(a - b);\n    \n    return m + dif * (exp(m) / (exp(a) + exp(b)));\n}\n// polynomial smooth min (k = 0.1);\n//float smin( float a, float b, float k )\n//{\n//    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n///    return mix( b, a, h ) - k*h*(1.0-h);\n//}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat GetMinDist(in vec3 point, out vec3 defuseColor)\n{\n    Sphere s1 = Sphere(vec3(0., 0., 1.), 1., vec3(1.));\n    Sphere s2 = Sphere(vec3(5. * cos(iTime), 0., 1.), .5, vec3(1.));\n\n    vec3 sphereColor1;\n    vec3 sphereColor2;\n    float sphereDist1 = SphereDist(point, s1, sphereColor1);\n    float sphereDist2 = SphereDist(point, s2, sphereColor2);\n    vec3 floorColor;\n    float floorDist = FloorDist(point, floorColor);\n    float res;\n    \n\n    if(sphereDist1 < sphereDist2)\n    {\n        defuseColor = sphereColor1;\n        res = sphereDist1;\n    }\n    else\n    {\n        defuseColor = sphereColor2;\n        res = sphereDist2;\n    }\n    res = smin(sphereDist1, sphereDist2, 5.);\n        \n    if(floorDist < res)\n    {\n        defuseColor = floorColor;\n        res = floorDist;\n    }\n    \n    return res;\n}\n\nvec3 RayMarch(\n    in vec3 point,\n    in vec3 direction,\n    out int stepCount,\n    out float minDist,\n    out vec3 hitPoint,\n\tout float dist)\n{\n\n    vec3 rayPoint = point;\n    vec3 resColor;\n    dist = 0.;\n    \n\tfor(int i = 0; i < MaxSteps; ++i)\n    {\n        float minDistOnThisIteration = GetMinDist(rayPoint, resColor);\n        \n        minDist = min(minDistOnThisIteration, minDist);\n        if(minDistOnThisIteration < Tol)\n        {\n            stepCount = i;\n            return resColor;\n        }\n        \n        rayPoint += minDistOnThisIteration * direction;\n        hitPoint = rayPoint;\n        dist += minDistOnThisIteration;\n\t\tif(dist > MaxDistance * 1.5) break;\n    }\n    \n    stepCount = MaxSteps;\n    return vec3(0.);\n}\n\nvec3 GetNormal(vec3 point)\n{\n\tfloat eps = 0.0001;\n    vec3 c;\n    \n    return normalize(GetMinDist(point, c) - vec3(\n        GetMinDist(point + vec3(eps, 0., 0.), c),\n        GetMinDist(point + vec3(0., eps, 0.), c),\n        GetMinDist(point + vec3(0., 0., eps), c) ));\n}\n\nvec4 GetLight(vec3 point, PointLight light)\n{\n\n    float distanceToLight = distance(point, light.pos);\n    if(distanceToLight > light.radius * 10.)\n        return vec4(0., 0., 0., 1.);\n    \n    vec3 lightDirection = normalize(light.pos - point);\n    vec3 normal = GetNormal(point);\n    vec3 c;\n    float dist;\n    float minDist;\n    int steps;\n    vec3 hitPoint;\n    RayMarch(point + lightDirection * 2. * Tol, lightDirection, steps, minDist, hitPoint, dist);\n    \n    vec4 resColor = vec4(light.color * light.intencity, distanceToLight / light.radius);\n    vec3 hitNormal;\n    \n    if(dist <= distanceToLight && dist > Tol)\n    {\n    \thitNormal = GetNormal(hitPoint);\n    }\n    else\n    {\n        hitNormal = normal;\n    }\n    float hitCos = dot(hitNormal, lightDirection);\n    \n    resColor += vec4(vec3(0.), hitCos * 0.5 + 0.5);\n\tresColor.a -= light.brightness;\n    \n    return resColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPoint = vec3(0., -6., 3.);\n    vec3 cameraDirection = normalize(vec3(0., 1., -0.3));\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rayDirection = normalize(vec3(uv.x, 0., uv.y) + cameraDirection);\n    int marchSteps;\n    float marchMinDist;\n    vec3 hitPoint;\n\tfloat dist;\n    \n    vec3 col = RayMarch(cameraPoint, rayDirection, marchSteps, marchMinDist, hitPoint, dist);\n\t\n    vec3 redLightPoint = vec3(3. * cos(iTime), 3. * sin(iTime), 7.);\n    vec3 blueLightPoint = vec3(-3. * cos(iTime), 3. * -sin(iTime), 7.);\n\n    PointLight redLight = PointLight(redLightPoint, 10., 0.2, 0.5, vec3(0.7, 0., 0.));\n    PointLight blueLight = PointLight(blueLightPoint, 10., 0.3, 0.5, vec3(0., 0., .7));\n\n    vec4 light = GetLight(hitPoint, blueLight);\n    col = light.rgb * light.a + col * (1. - light.a);\n    \n    light = GetLight(hitPoint, redLight);\n    //col = light.rgb * light.a + col * (1. - light.a); \n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}