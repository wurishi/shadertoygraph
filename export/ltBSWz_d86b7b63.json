{"ver":"0.1","info":{"id":"ltBSWz","date":"1442778616","viewed":361,"name":"Side By Side 3D Test","username":"Yevano","description":"Simple test for people who can cross their eyes :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Thanks for the pointers, coyote :)\n\n#define EPSILON 0.001\n#define PI 3.1415926535898\n#define MAX_DIST 30.\n\nvec3 lightPos = vec3(0, 0., 0.);\n\nstruct HitInfo {\n    float d;\n    vec3 c;\n    vec3 p;\n};\n\nfloat sphere(vec3 pos, float r) {\n    return length(pos) - r;\n}\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nHitInfo map(vec3 pos, vec3 rd) {\n    HitInfo hit = HitInfo(9999., vec3(0., 0., 0.), pos);\n    float nd;\n    \n    nd = sphere(vec3(pos.xz, pos.y/(sin(iTime)+1.5)).xzy, 1.);\n    if(nd < hit.d) hit = HitInfo(nd, vec3(1., 0., 0.), pos);\n    nd = box(pos - vec3(0., -3, 0.), vec3(1000., 0.5, 1000.));\n    if(nd < hit.d) hit = HitInfo(nd, texture(iChannel0, pos.xz/10.).rgb, pos);\n    \n    return hit;\n}\n\nHitInfo march(in vec3 ro, in vec3 rd) { \n    HitInfo ret = HitInfo(1000., vec3(0.), ro);\n    bool didHit = false;\n    float l = 0.;\n    for(int i = 0; i < 100; i++) {\n        vec3 r = ro + rd * l;\n        HitInfo hit = map(r, rd);\n        if(hit.d <= EPSILON) {\n            ret = HitInfo(l, hit.c, r);\n            didHit = true;\n            break;\n        }\n        if(hit.d > MAX_DIST) {\n            break;\n        }\n        l += hit.d;\n    }\n    \n    if(!didHit) return ret;\n    \n    ro = ro + rd * l;\n    rd = normalize(lightPos - ro);\n    l = 0.1;\n    for(int i = 0; i < 50; i++) {\n        vec3 r = ro + rd * l;\n        HitInfo hit = map(r, rd);\n        if(hit.d <= EPSILON) {\n            ret.c*=0.5;\n            return ret;\n        }\n        if(distance(r, lightPos) < hit.d) {\n            return ret;\n        }\n        l += min(hit.d, distance(r, lightPos));\n    }\n    \n    return ret;\n}\n\nmat2 getRotMat(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat angDiff = 0.;\nfloat xDiff = 0.15;\n\nvec3 pixel(vec2 uv, float sg) {\n    //adjusting the camera origin -sg for cross eye,\n    //sg for parallel viewing or for oculus rift\n    vec3 ro = vec3(-sg*0.4, 0., -6.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    HitInfo hit = march(ro, rd);\n    float i = smoothstep(20., 0., distance(hit.p, lightPos));\n    return hit.c * i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y ;\n\n    //splitting the screen into two\n    float sg = sign( fragCoord.x - 0.5*iResolution.x ) ;\n    uv -= sg * vec2( 0.25*iResolution.x, 0 )/iResolution.y;\n    \n    lightPos = vec3(sin(iTime)*4., 2., cos(iTime)*4.);\n    \n    //sending sg to pixel so camera origin can be moved appropriately\n    fragColor = vec4(pixel(uv,sg), 1.);\n}","name":"","description":"","type":"image"}]}