{"ver":"0.1","info":{"id":"4XscRB","date":"1726348033","viewed":36,"name":"o1 terrain","username":"josplode","description":"o1 terrain","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["terrain","o1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Terrain Ray Marching Shader with Mouse-Controlled Camera\n// Author: OpenAI's ChatGPT\n\n// Rotation function around an axis\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    return v * cosA + cross(axis, v) * sinA + axis * dot(axis, v) * (1.0 - cosA);\n}\n\n// Hash function for noise\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\n\n// 2D Noise function\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth interpolation\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b - c + a) * u.x * u.y;\n}\n\n// Fractal Brownian Motion for terrain\nfloat fbm(vec2 p)\n{\n    float total = 0.0;\n    float amplitude = 0.5;\n    for (int i = 0; i < 6; i++)\n    {\n        total += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return total;\n}\n\n// Terrain Signed Distance Function\nfloat map(vec3 p)\n{\n    float height = fbm(p.xz * 0.5) * 2.0;  // Adjust the multiplier for terrain height\n    return p.y - height;\n}\n\n// Calculate normal for lighting\nvec3 calcNormal(vec3 p)\n{\n    float eps = 0.001;\n    vec3 n;\n    n.x = map(p + vec3(eps, 0.0, 0.0)) - map(p - vec3(eps, 0.0, 0.0));\n    n.y = map(p + vec3(0.0, eps, 0.0)) - map(p - vec3(0.0, eps, 0.0));\n    n.z = map(p + vec3(0.0, 0.0, eps)) - map(p - vec3(0.0, 0.0, eps));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup\n    vec3 camPos = vec3(0.0, 3.0, -6.0);       // Camera position above the terrain\n\n    // Mouse control for camera rotation\n    float yaw = 0.0;\n    float pitch = radians(-20.0); // Initial pitch angle\n\n    // Check if the mouse button is pressed\n    if (iMouse.z > 0.0)\n    {\n        // Map mouse position to yaw and pitch angles\n        vec2 mouse = iMouse.xy / iResolution.xy;\n        yaw = (mouse.x - 0.5) * 3.14159265 * 2.0;   // Map x to [-π, π]\n        pitch = (0.5 - mouse.y) * 3.14159265;       // Map y to [-π/2, π/2]\n        // Limit pitch angle to avoid flipping\n        pitch = clamp(pitch, radians(-89.0), radians(89.0));\n    }\n\n    // Build camera coordinate system\n    vec3 camDir = normalize(vec3(sin(yaw)*cos(pitch), sin(pitch), cos(yaw)*cos(pitch)));\n    vec3 camRight = normalize(cross(camDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = cross(camRight, camDir);\n\n    // Ray direction\n    vec3 rayDir = normalize(uv.x * camRight + uv.y * camUp + camDir);\n\n    // Ray marching\n    float t = 0.0;\n    const int MAX_STEPS = 100;\n    const float MAX_DIST = 100.0;\n    const float SURFACE_DIST = 0.001;\n    float dist = 0.0;\n    vec3 pos;\n    int i;\n    for (i = 0; i < MAX_STEPS; i++)\n    {\n        pos = camPos + t * rayDir;\n        dist = map(pos);\n        if (dist < SURFACE_DIST)\n            break;\n        t += dist;\n        if (t > MAX_DIST)\n            break;\n    }\n\n    // Lighting and color\n    vec3 color;\n    if (t < MAX_DIST)\n    {\n        // Hit the terrain\n        vec3 normal = calcNormal(pos);\n        vec3 lightDir = normalize(vec3(0.5, 1.0, 0.5));\n        float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n        color = mix(vec3(0.1, 0.4, 0.1), vec3(0.4, 0.8, 0.2), diffuse); // Terrain color\n    }\n    else\n    {\n        // Sky color gradient\n        float tSky = 0.5 * (rayDir.y + 1.0);\n        color = mix(vec3(0.6, 0.8, 1.0), vec3(0.2, 0.5, 0.8), tSky);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}