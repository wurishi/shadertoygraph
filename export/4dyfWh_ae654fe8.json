{"ver":"0.1","info":{"id":"4dyfWh","date":"1557415194","viewed":89,"name":"test112","username":"Glim888","description":"tt","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// Ray_tracer v1\n\n#define ITER 100\n#define BILLBOARD_SIZE 5.0\n#define NUMBER_OF_REFLECTIONS 3\n\nstruct ray_t{\n \n    // origin of ray\n    vec3 o;\n    // direction of ray\n    vec3 d;\n    \n};\n\nstruct sphere_t{\n    \n    // position in room\n    vec3 pos;\n    // color \n    vec3 col;\n    // radius\n    float r;\n    // reflection value\n    float ref;\n    \n};\n    \n  \nsphere_t sphere[5];\n\n/*\nmat3 rotY (float ang) {\n    return mat3(cos(ang) ,0.0, sin(ang),\n                0.0, 1.0, 0.0,\n                -sin(ang), 0.0, cos(ang));\n}\n*/\n\n\n// returns the distance to the radius of the shpere\n// if it is <0, then we are inside of that shere\nfloat distance_from_sphere(vec3 pos, sphere_t sphere) {\n \treturn length(pos - sphere.pos) - sphere.r;  \n}   \n    \nvec3 trace(ray_t r, vec3 cam) {\n    \n    vec3 current_position, current_color = vec3(0);\n    float way_done = 0.0, dist, temp_dist; \n    int nearest_sphereN, refelctionN = 0;\n    sphere_t s;\n\n    \n    for (int i=0; i<ITER; i++) {\n        \n        current_position = r.o + r.d * way_done;\n        \n        // find nearest sphere index and distance to it\n        dist = 10000000.0;\n        nearest_sphereN = 0;\n        \n        for (int j=0; j<sphere.length(); j++) {\n                  \n            temp_dist = distance_from_sphere(current_position, sphere[j]);\n            \n            if (temp_dist < dist) {               \n                dist = temp_dist;\n                nearest_sphereN = j;                \n            }\n         }\n        \n         way_done += dist;\n        \n         // reflect\n         if (dist < 0.001) {             \n             \n\n             current_color += sphere[nearest_sphereN].col*sphere[nearest_sphereN].ref;\n             \n             \n             if (refelctionN++ >= NUMBER_OF_REFLECTIONS) break;\n                         \n             //if (refelctionN > 1) current_color *= (current_color + oldCol) * 0.5;\n                            \n             current_position = r.o + r.d * (way_done);\n             \n             way_done = 0.3;\n             vec3 dir = reflect(r.d, normalize(current_position-sphere[nearest_sphereN].pos));\n             r = ray_t (current_position, dir);\n         }\n                         \n    }\n    \n    if (current_color != vec3(0.0)) {\n              \n        vec3 norm = normalize(current_position-sphere[nearest_sphereN].pos);\n        float shading = dot(normalize(vec3(-1.0, 1.0, 0.0)), norm);\n\n        float shading1 = current_position.y > 0. ? 0.5 : 0.1; \n        \n        return current_color*0.5 + shading * 0.25 + shading1*0.25;\n    }else{\n        current_color = vec3(0.7, 0.7, 0.7) * smoothstep(-0.5, 0.5, r.o.y + r.d.y*5.0 - cam.y);   \n    }\n     \n    return current_color;  \n    \n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // set FOV (-0.3 to  0.3) and create uv\n    vec2 uv = fragCoord/iResolution.xy *0.3 -0.15;\n    \n    // remove distortion \n    // (-0.53 -> X -> 0.53)\n    // (-0.3  -> Y -> 0.3)\n\tuv.x *= (iResolution.x/iResolution.y);\n    \n    // we cast rays from here\n    vec3 cam = vec3(0.0,sin(iTime) * 1.5, -10.0);\n    \n    // sending direction\n    vec3 dir = vec3(uv*BILLBOARD_SIZE, 1.0);\n    \n    // Spheres in Room\n    sphere[0] = sphere_t(vec3(0.0), vec3(0.0, 0.0, 0.0), 2.0, .1);\n    sphere[1] = sphere_t(vec3(5.0 * sin(iTime),1.0,3.0 * cos(iTime)), vec3(1.0, 1.0, 0.0), 1.0, 1.);\n    sphere[2] = sphere_t(vec3(0.0, -5.0+cam.y, 5.0), vec3(0.0, 1.0, 1.0), abs(2.0 * sin(iTime)), 1.);\n    sphere[3] = sphere_t(vec3(8.0, 0.0+cam.y, 8.0), vec3(1.0, 1.0, 1.0), 5.0, 1.0);\n    sphere[4] = sphere_t(vec3(-5.0, 5.0+cam.y, 3.0), vec3(1.0, 0., 0.0), 2.0, 1.0);  \n    \n    // create a ray & send it  \n    ray_t r = ray_t (cam, dir);\n    \n    vec3 col = trace(r, cam);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n/*\n    \nvec3 trace(ray_t r, vec3 cam) {\n    \n    vec3 current_position, current_color;\n    float way_done = 0.0, dist, temp_dist; \n    int nearest_sphereN, refelctionN = 0;\n    sphere_t s;\n\n    \n    for (int i=0; i<ITER; i++) {\n        \n        current_position = r.o + r.d * way_done;\n        dist = 10000000.0;\n        nearest_sphereN = 0;\n        \n        for (int j=0; j<sphere.length(); j++) {\n         \n            s = sphere[j];           \n            temp_dist = distance_from_sphere(current_position, s);\n            \n            if (temp_dist < dist) {\n                \n                dist = temp_dist;\n                nearest_sphereN = j;                \n            }\n         }\n        \n         way_done += dist;\n            \n         if (dist < 0.0001) {\n             \n             if (refelctionN++ > 3) break;\n             \n             vec3 oldCol = current_color;\n             current_color += (sphere[nearest_sphereN].col);\n             \n             if (refelctionN > 1) current_color -= (current_color - oldCol) * 0.5;\n                            \n             current_position = r.o + r.d * (way_done+0.01);\n             \n             way_done = 0.3;\n             vec3 dir = reflect(r.d, normalize(current_position-sphere[nearest_sphereN].pos));\n             r = ray_t (current_position, dir);\n         }\n                         \n    }\n    \n    if (current_color != vec3(0.0)) {\n        vec3 norm = normalize(current_position-sphere[nearest_sphereN].pos);\n        float shading = dot(normalize(vec3(-1.0, 1.0, 0.0)), norm);\n\n        return current_color*0.5 + shading * 0.5;\n    }else{\n        \n        //current_color = vec3(0.7, 0.7, 0.7) * smoothstep(-0.5, 0.5, r.o.y + r.d.y*5.0 - cam.y);\n      \treturn current_color;  \n    }\n} \n*/\n","name":"Image","description":"","type":"image"}]}