{"ver":"0.1","info":{"id":"Dsj3Ww","date":"1667692410","viewed":78,"name":"Tangent Plotter (Explicit)","username":"Envy24","description":"Template for plotting tangent lines for explicit functions.\nQuick instruction in Image Tab.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["template","plotter","tangent","graphs"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This method works for explicit ( y=f(x) ) and implicit ( d=f(x,y,...) ) functions. */\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define UNIT                      ( 8.0 / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define SCENE_SCALE               ( 2.5 )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse)\n{\n    vec2 M = MOUSE_OFFSET * (mouse == true ? 1. : 0.);\n    return ((2. * (SC - M) - R.xy) / R.y) * scale - origin;\n}\n\n#define M  (3.)\n#define K  (15.)\n#define A  (0.25)\nfloat explicit(float x)\n{\n    return A*tan(cos(M*x)-sin(x*K)*0.5);\n}\nfloat dydx(float x)\n{\n    /*Numeric derivative.*\n    return ( explicit(x+dx) - explicit(x) ) / (2.*dx);\n    /*Analytic derivative.*/\n    float t = cos((sin(K*x)*0.5-cos(M*x)));\n    return  -A*(K*cos(K*(x))*0.5 + M*sin(M*(x))) * (1./(t*t));\n    /**/\n}\nvec2 tangent(float x) { return vec2(1., dydx(x)); }\nvec2 gradient(float x) { return vec2(1., dydx(x)); }\nvec2 normal(float x) { vec2 T = tangent(x); return vec2(-T.y, T.x); }\nfloat ddydxx(float x)\n{\n    /*Numeric derivative.*/\n    const float dx = 0.01;\n    return (dydx(x+dx) - dydx(x-dx) ) / (2.*dx);\n    /*Analytic derivative.*\n    return 0.;\n    /**/\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), true);\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n\n\n    /* Explicit function y=f(x) */\n         color = mix(color, vec3(1,0,0), draw_explicit_func(NDC, explicit(NDC.x), dydx(NDC.x)));\n\n\n\n   /* Define x0 */\n#define RANGE          ( AR*SCENE_SCALE )\n   float x0 = sinOSC(-RANGE, RANGE, iTime*0.15) * 0.5;\n   \n   /* Tangent line */\n   float slope = dydx(x0);\n#define tangent_line(x, x0) ( slope*((x)-(x0))+explicit(x0) )\n        color = mix(color, vec3(0,0,1), draw_explicit_func(NDC, tangent_line(NDC.x, x0), slope));\n        color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, vec2(x0, explicit(x0)), 2.*UNIT)) );\n\n    /* Tangent (gradient) and normal vectors. */\n    vec2 B = vec2(x0, explicit(x0)),\n         T = tangent(x0),\n         N = normal(x0),\n         E = B + normalize(T) * 0.25;        \n    color = mix(color, vec3(0,0,0), SMAA(segmentSDF_L2(NDC, B, E, 0.01)) );\n         E = B + normalize(N) * 0.25;      \n    color = mix(color, vec3(0,0,0), SMAA(segmentSDF_L2(NDC, B, E, 0.01)) );\n\n\n    /* Cells */\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E,\n    float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}","name":"Common","description":"","type":"common"}]}