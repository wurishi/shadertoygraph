{"ver":"0.1","info":{"id":"ftK3zR","date":"1637076568","viewed":83,"name":"Fork Class 2: I yliao1 453","username":"yliao1","description":"Ray Sphere intersection for class 2","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["intersection","class3","rayshpere"],"hasliked":0,"parentid":"7ts3WN","parentname":"Class 2: Intersection:Ray/Sphere"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed = 0.0;\n\nvec3 bgColor = vec3(0, 1, 1);\n\n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \n// Intersectio code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t = 1000000.0; // initialize to a large number\n    if (disc > 0.0) {\n        /*t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }*/\n        \n        t = min(-b - sqrt(disc), -b + sqrt(disc));\n        if (t > 0.00001f)\n        {\n          return t;\n        }\n    }\n    return t;\n}\n\n\nSphere spheres[4];\n\nvoid makeScene() {\n    spheres[0] = Sphere(1.5, vec3(-1, 0, -7), vec3(1, 1, 0));\n    spheres[1] = Sphere(2.0, vec3(1, 0, -6), vec3(0, .7, 1));\n}\n\nint numSamples = 10000;\nint numSpheres = 2;\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n   \n   makeScene();\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n       \n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n       float t = 10000000.0;\n       Sphere closestSphere;\n       for (int i = 0; i < numSpheres; i ++)\n       {\n              Sphere sphere = spheres[i];\n           float curT = raySphereIntersect(ray, sphere);\n           if (curT < t)\n           {\n             t = curT;\n             closestSphere = sphere;\n           }\n\n       }\n                  if (t < 1000000.0) {\n               vec3 hit = ray.origin + t*ray.direction;\n               vec3 norm = normalize(hit - closestSphere.center);\n               float angle = dot(ray.direction, norm);\n\n\n               samp += abs(angle)*closestSphere.color;\n           } \n   }\n   fragColor = vec4(samp/float(numSamples), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}