{"ver":"0.1","info":{"id":"tlscRj","date":"1592523649","viewed":75,"name":"ColorAccessibilityPost","username":"bearbear","description":"Port of  Madden NFL's color accessibility filter.\nhttps://twvideo01.ubm-us.net/o1/vault/gdc2017/Presentations/Stevens_Karen_GameAccessibilityPracticalFixes.pdf\n\nColorblind Simulation by honet\nhttps://www.shadertoy.com/view/MdSGRW","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["colorblind","accessibility"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEBUG_OVERLAY\n#define USE_CHANNEL_1 0\n\nconst vec2 cSliderStore = vec2(0);\n\nvec4 LoadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\n//--------------------------------------------------------------------------------------------------\n// Colorblind Simulation by honet\n// https://www.shadertoy.com/view/MdSGRW\nvec3 ColorBlindSim(vec2 uv, vec3 col)\n{\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tint id;\n\t\n    //if ( iMouse.w > 0.5)\n    //{\n    //    vec2 muv = iMouse.xy / iResolution.xy;\n\t//\tid = int(floor(muv.x * 3.0)) + int(floor(muv.y * 3.0))*3;\n    //}\n    //else\n    {\n        id = int(floor(uv.x * 3.0)) + int(floor(uv.y * 3.0))*3;\n    }\n\n    //vec2 texuv = (iMouse.w>0.5) ? uv : fract( uv * 3.0 );\n\t//vec4 col = texture( iChannel0, vec2(texuv.x,1.0-texuv.y) );\n\n    //test\n    //col = vec4( uv.x, uv.y, 0.5+0.5*sin(iTime), 1.0 );\n        \n\t//note: data from\n\t// http://web.archive.org/web/20081014161121/http://www.colorjack.com/labs/colormatrix/\n\t// http://en.wikipedia.org/wiki/Color_blindness\n\t \n\tvec3 c_r = vec3(100,0,0);\n\tvec3 c_g = vec3(0,100,0);\n\tvec3 c_b = vec3(0,0,100);\n\t\n\t//Deuteranomaly (\"red/green\" 6% of males, 0.4% of females)\n\tif ( id == 0 ) {\n\t\tc_r = vec3(80, 20, 0);\n\t\tc_g = vec3(25.833, 74.167, 0);\n\t\tc_b = vec3(0, 14.167, 85.833);\n\t}\n\t\n\t//Protanopia (\"red/green\", 1% of males)\n\telse if ( id == 1 ) {\n\t\tc_r = vec3(56.667, 43.333, 0);\n\t\tc_g = vec3(55.833, 44.167, 0);\n\t\tc_b = vec3(0, 24.167, 75.833);\n\t}\n\t\n\t//Protanomaly (\"red/green\", 1% of males, 0.01% of females)\n\telse if ( id == 2 ) {\n\t\tc_r = vec3(81.667, 18.333, 0);\n\t\tc_g = vec3(33.333, 66.667, 0);\n\t\tc_b = vec3(0, 12.5, 87.5);\n\t}\n\t\n\t//Deuteranopia (\"red/green\", 1% of males)\n\telse if ( id == 3 ) {\n\t\tc_r = vec3(62.5, 37.5, 0);\n\t\tc_g = vec3(70, 30, 0);\n\t\tc_b = vec3(0, 30, 70);\n\t}\n\t\n\telse if ( id == 4 ) {\n        //NO ADJUSTMENT\n\t}\n\t\n\t//Tritanomaly (\"blue/yellow\", 0.01% for males and females)\n\telse if ( id == 5 ) {\n\t\tc_r = vec3(96.667, 3.333, 0);\n\t\tc_g = vec3(0, 73.333, 26.667);\n\t\tc_b = vec3(0, 18.333, 81.667);\n\t}\n\t\n\t//Achromatopsia (\"Total color blindness\")\n\telse if ( id == 6 ) {\n\t\tc_r = vec3(29.9, 58.7, 11.4);\n\t\tc_g = vec3(29.9, 58.7, 11.4);\n\t\tc_b = vec3(29.9, 58.7, 11.4);\n\t}\n\t\n\t//Achromatomaly (\"Total color blindness\")\n\telse if ( id == 7 ) {\n\t\tc_r = vec3(61.8, 32, 6.2);\n\t\tc_g = vec3(16.3, 77.5, 6.2);\n\t\tc_b = vec3(16.3, 32.0, 51.6);\n\t}\n\t//Tritanopia (\"blue/yellow\", <1% of males and females)\n    else if ( id == 8 )\n    {\n\t\tc_r = vec3(95, 5, 0);\n\t\tc_g = vec3(0, 43.333, 56.667);\n\t\tc_b = vec3(0, 47.5, 52.5);\n    }\n    else\n    {\n        c_r = vec3(0,0,0);\n        c_g = vec3(0,0,0);\n        c_b = vec3(0,0,0);\n    }\n    \n\t\n\tc_r /= 100.0;\n\tc_g /= 100.0;\n\tc_b /= 100.0;\n\t\n\tvec3 rgb = vec3( dot(col.rgb,c_r), dot(col.rgb,c_g), dot(col.rgb,c_b) );\n \n    return rgb;\n}\n//--------------------------------------------------------------------------------------------------\n\n/*H************************************************************************************************/\n/*!\n \\File AccessibilityPost.fxh\n \\Description\n Accessibility support library for shaders, covering brightness, contrast, and color blind.\n \\Copyright\n (c) 2015 Electronic Arts Inc.\n*/\n/************************************************************************************************H*/\n/*** Include files ********************************************************************************/\n/*** Variables ************************************************************************************/\n#define colorBlindProtanopiaFactor (colorBlindParam.x) // pass in 0 or 1 to turn on support\n#define colorBlindDeuteranopiaFactor (colorBlindParam.y) // pass in 0 or 1 to turn on support\n#define colorBlindTritanopiaFactor (colorBlindParam.z) // pass in 0 or 1 to turn on support\n#define colorBlindDaltonizeFactor (colorBlindParam.w) // pass in 0 or 0.9 for best results\nfloat accessibilityBrightnessFactor = 0.0; // zero is no effect\nfloat accessibilityContrastFactor = 0.0; // zero is no effect\n// suggested brightness factors: -0.1, -0.05, 0, 0.05, 0.11\n// suggested contrast factors: -0.25, -0.12, 0.25, 0.5\n/*** Methods ************************************************************************************/\n// Shifts from rgb to luminosity color representation. The magic numbers\n// are standard conversion values used to do this.\n// see https://en.wikipedia.org/wiki/CIE_1931_color_space for details\nvec3 RgbToLms(vec3 color)\n{\n float l = (17.8824 * color.r) + (43.5161 * color.g) + (4.11935 * color.b);\n float m = (3.45565 * color.r) + (27.1554 * color.g) + (3.86714 * color.b);\n float s = (0.0299566 * color.r) + (0.184309 * color.g) + (1.46709 * color.b);\n return vec3(l,m,s); \n}\n// Shifts from luminosity to rgb color representation. The magic numbers\n// are standard conversion values used to do this.\n// see https://en.wikipedia.org/wiki/LMS_color_space for details\nvec3 LmsToRgb(vec3 color)\n{\n float r = (0.0809444479 * color.r) + (-0.130504409 * color.g) + (0.116721066 * color.b);\n float g = (-0.0102485335 * color.r) + (0.0540193266 * color.g) + (-0.113614708 * color.b);\n float b = (-0.000365296938 * color.r) + (-0.00412161469 * color.g) + (0.693511405 * color.b);\n return vec3(r,g,b);\n}\n// Shifts colors based on color blind color weaknesses to areas where user can better see.\n// The magic numbers model the way the human eye works when affected by different color\n// deficiencies. They will never change.\n// see http://www.daltonize.org/search/label/Color%20Blindness for details\nvec4 Daltonize(vec4 color, vec4 colorBlindParam)\n{\n vec3 colorLMS = color.rgb;\n colorLMS = RgbToLms(colorLMS);\n\n vec3 colorWeak;\n\n colorWeak.r = (2.02344*colorLMS.g - 2.5281*colorLMS.b)*colorBlindProtanopiaFactor + colorLMS.r*(1.0-colorBlindProtanopiaFactor);\n colorWeak.g = (0.494207*colorLMS.r + 1.24827*colorLMS.b)*colorBlindDeuteranopiaFactor + colorLMS.g*(1.0-colorBlindDeuteranopiaFactor);\n colorWeak.b = (-0.395913*colorLMS.r + 0.801109*colorLMS.g)*colorBlindTritanopiaFactor + colorLMS.b*(1.0-colorBlindTritanopiaFactor);\n\n colorWeak = LmsToRgb(colorWeak);\n\n colorWeak = color.rgb - colorWeak;\n \n vec3 colorShift;\n colorShift.r = 0.;\n colorShift.g = colorWeak.g + 0.7*colorWeak.r;\n colorShift.b = colorWeak.b + 0.7*colorWeak.r;\n\n color.rgb += colorShift.rgb;\n color = clamp(color,0.0,1.0);\n\n return color;\n}\n// applies brightness, contrast, and color blind settings to passed in color\nvec4 AccessibilityPostProcessing(vec4 color, vec4 colorBlindParam)\n{\n //apply contrast\n color.rgb = ((color.rgb - 0.5) * (1.0+accessibilityContrastFactor+colorBlindDaltonizeFactor*0.112)) + 0.5;\n\n //apply brightness\n color.rgb += accessibilityBrightnessFactor-0.075*colorBlindDaltonizeFactor;\n\n // apply colorblind compensation algorithm\n color = (Daltonize(color, colorBlindParam)*colorBlindDaltonizeFactor + color*(1.0-colorBlindDaltonizeFactor));\n\n return color;\n}\n\nvec4 ColorBar(vec2 uv)\n{\n    if (uv.y < 0.2)\n    { return vec4(1., 0., 0., 1.); }\n    if (uv.y < 0.4)\n    { return vec4(0., 1., 0., 1.); }\n    if (uv.y < 0.6)\n    { return vec4(0., 0., 1., 1.); }\n    if (uv.y < 0.8)\n    { return vec4(1., 1., 0., 1.); }\n    \n    { return vec4(0.5, 0., 1., 1.); }    \n\n}\n\nvec4 GetSrcColor(vec2 uv)\n{\n#if USE_CHANNEL_1\n    vec4 srcColor = texture(iChannel1, uv);\n#else\n    vec4 srcColor = ColorBar(uv); \n#endif\n    \n    float alpha = length(max(abs(uv - 0.5) - 0.47, 0.0)) - 0.01;\n\tif (alpha > 0.)\n    {\n        srcColor = vec4(0, 0, 0, 1);\n    }\n    \n    return srcColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 colorBlindParam = LoadValue(cSliderStore);\n\n    float r = 0.65;\n    \n    vec2 uv1 = uv;\n    uv1.y -= 1. - r;\n    uv1 /= r;\n    \n    \n    vec2 uv2 = uv;;\n    uv2.x -= r; \n    uv2 /= (1. - r);\n\n    vec4 srcColor = GetSrcColor(uv1);\n\n    vec4 correctedColor = AccessibilityPostProcessing(srcColor, colorBlindParam);\n    vec3 simulatedColor = vec3(0, 0, 0);\n    \n    {\n        vec4 srcColor2 = GetSrcColor(fract(uv2 * 3.));\n        vec4 correctedColor2 = AccessibilityPostProcessing(srcColor2, colorBlindParam);\n\n    \tsimulatedColor = ColorBlindSim(uv2, correctedColor2.rgb);\n    }\n    \n    //fragColor.rgb = simulatedColor;\n    fragColor = uv1.x < 0.5 ? srcColor : correctedColor;\n    \n    if (clamp(uv1, 0., 1.) != uv1)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n    }\n    \n    if (clamp(uv2, 0., 1.) == uv2)\n    {\n        fragColor.rgb = simulatedColor.rgb;\n    }\n    \n#ifdef DEBUG_OVERLAY\n    vec4 debugOverlay = texture(iChannel0, uv);\n    fragColor = mix(fragColor, debugOverlay, debugOverlay.a);\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Store your save data positions as constants for easy retrieval and storage\nconst vec2 cSliderStore = vec2(0);\nconst vec2 cPreviousMouseClickStore = vec2(1.0, 0.0);\n\n// State storing taken from: https://www.shadertoy.com/view/MddGzf\nfloat IsInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nvec4 LoadValue( in vec2 re )\n{\n    return textureLod( iChannel0, (0.5+re) / iChannelResolution[0].xy, 0.0 );\n}\n\nvoid StoreValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( IsInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvec4 LoadData(in ivec2 pos)\n{\n    return texelFetch(iChannel0, pos, 0);\n}\n\nfloat Equal(in vec2 rhs, in vec2 lhs) \n{\n    vec2 signOf = sign(rhs - lhs);\n    return max(1.0 - abs(signOf.x + signOf.y), 0.0);\n}\n\nfloat Not(in float l)\n{\n    return 1.0 - l;\n}\n\n// Draw a slider, and update it's value based on the mouse position\nvec4 Slider(in vec2 uv, in vec2 pos, inout float currentSlider)\n{   \n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    \n\t// Draw the slider bar\n    const vec2 cSquareHalfSize = vec2(0.01, 0.1);\n    vec2 relativeAbsPoint = abs(uv - pos);\n    vec2 inSquareV = step(relativeAbsPoint, cSquareHalfSize);\n    float inSquare = inSquareV.x * inSquareV.y;\n    \n    // Draw the actual slider\n    const vec2 cSliderHalfSize = vec2(0.02, 0.01);\n    vec2 sliderAbsPoint = abs(uv - (pos + vec2(0.0, currentSlider * 2.0 * cSquareHalfSize.y - cSquareHalfSize.y)));\n    vec2 inSliderV = step(sliderAbsPoint, cSliderHalfSize);\n    \n    // Collapse the vector into a single float to determine if we're in the square in both axis\n    float inSlider = inSliderV.x * inSliderV.y;\n    \n    // Check collision against the slider\n    const vec2 cColliderBox = vec2(0.02, 0.1);\n    vec2 relativeMousePoint = (mouseUV - pos);\n    vec2 mouseInCollider = step(abs(relativeMousePoint), cColliderBox);\n    \n\t// Update the slider's position if we're in the collider\n    float sliderHeight = (relativeMousePoint.y + cColliderBox.y) / (2.0 * cColliderBox.y);\n    \n    // Collapse the vector into a single float to determine if we're in the square in both axis\n    currentSlider = mix(currentSlider, sliderHeight, mouseInCollider.x * mouseInCollider.y);\n    \n    // Draw out the slider\n    return vec4(0.5, 0.8, 0.4, 1.0) * inSquare + vec4(1.0) * inSlider;\n}\n\nvec4 Toggle(in vec2 uv, in vec2 pos, inout float currentToggle)\n{\n    vec2 previousMouseClick = LoadValue(cPreviousMouseClickStore).xy;\n    \n    vec2 clickUV = iMouse.zw / iResolution.xy;\n    \n    float hasClickStateChanged = Not(Equal(clickUV.xy, previousMouseClick.xy));\n    \n    float aspect = iResolution.x / iResolution.y;\n    vec2 cSquareHalfSize = vec2(0.02 / aspect, 0.02);\n    vec2 relativeAbsPoint = abs(uv - pos);\n    vec2 inSquareV = step(relativeAbsPoint, cSquareHalfSize);\n\t// Collapse the vector into a single float to determine if we're in the square in both axis\n    float inSquare = inSquareV.x * inSquareV.y;\n    \n    vec2 relativeAbsMousePoint = abs(previousMouseClick - pos);\n    vec2 mouseInCollider = step(relativeAbsMousePoint, cSquareHalfSize);\n    \n    currentToggle = mix(currentToggle, 1.0 - currentToggle, mouseInCollider.x * mouseInCollider.y * hasClickStateChanged);\n    \n    vec2 cOutlineHalfSize = vec2(0.025 / aspect, 0.025);\n    vec2 inOutlineV = step(relativeAbsPoint, cOutlineHalfSize);\n\t// Collapse the vector into a single float to determine if we're in the square in both axis\n    float inOutline = inOutlineV.x * inOutlineV.y;\n    \n    vec4 outlinecolor = vec4(1.0);\n    \n    relativeAbsMousePoint = abs(clickUV - pos);\n    mouseInCollider = step(relativeAbsMousePoint, cSquareHalfSize);\n    \n    vec4 toggleColor = mix(vec4(0.5,0.5,0.5,1.0), vec4(0.5, 0.8, 0.4, 1.0), currentToggle);\n    toggleColor = mix(toggleColor, toggleColor * 0.95,  mouseInCollider.x * mouseInCollider.y);\n    return mix(outlinecolor * inOutline, toggleColor, inSquare);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\t// Load the values that you stored a previous frame\n    vec4 sliderValues = LoadValue(cSliderStore);\n\n    // Draw the sliders and update the slider values based on the mouse input\n\tvec4 sliderColor = Slider(uv, vec2(0.05, 0.85), sliderValues.x);\n    sliderColor += Slider(uv, vec2(0.1, 0.85), sliderValues.y);\n    sliderColor += Slider(uv, vec2(0.15, 0.85), sliderValues.z);\n    sliderColor += Slider(uv, vec2(0.2, 0.85), sliderValues.w);\n    \n    // Draw out the sliders\n    fragColor = sliderColor;\n    \n    // Store the values into the buffer\n    StoreValue(cSliderStore, sliderValues, fragColor, fragCoord);\n    StoreValue(cPreviousMouseClickStore, vec4(iMouse.zw / iResolution.xy, 0, 0), fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}