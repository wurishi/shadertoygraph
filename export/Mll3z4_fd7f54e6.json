{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define BRICK_WIDTH             300.0\n#define BRICK_HEIGHT            100.0\n#define MORTAR_THICKNESS        10.0\n\n#define BRICK_AND_MORTAR_WIDTH  (BRICK_WIDTH + MORTAR_THICKNESS)\n#define BRICK_AND_MORTAR_HEIGHT (BRICK_HEIGHT + MORTAR_THICKNESS)\n\n#define MWF                     (MORTAR_THICKNESS * 0.5 / BRICK_AND_MORTAR_WIDTH)\n#define MHF                     (MORTAR_THICKNESS * 0.5 / BRICK_AND_MORTAR_HEIGHT)\n\n#define BRICK_SIZE              vec2(BRICK_WIDTH, BRICK_HEIGHT)\n#define BRICK_COLOR             vec3(0.5, 0.15, 0.14)\n#define MORTAR_COLOR            vec3(0.5, 0.5, 0.5)\n\n/**\n * @return t number of rd's needed to reach an intersection\n */\nfloat planeIntersection(in vec3 ro, in vec3 rd) {\n    // Here, the plane is z == 0\n    // So the equation of the plane is z == 0 == ro.z + t*rd.z\n\treturn -ro.z / rd.z;\n}\n\n/**\n * Within just one brick, x and y are both normalized to [0.0, 1.0).\n * Given a point <x,y>, I want to return the normal given some applied\n * bump function. The bump function gives us the mortar grooves in\n * between bricks.\n */\nvec3 bumpFunction(float x, float y) {\n    vec3 planeNormal = vec3(0.0, 0.0, 1.0);\n    \n    float bumpX = smoothstep(0.0, MWF, x) - smoothstep(1.0 - MWF, 1.0, x);\n    float bumpY = smoothstep(0.0, MHF, y) - smoothstep(1.0 - MHF, 1.0, y);\n\tfloat bumpValue = bumpX * bumpY;\n    //return normalize(cross(dFdx(vec3(0.0, 0.0, bumpValue)), dFdy(vec3(0.0, 0.0, bumpValue))));  // Magic :O\n    vec3 dx = dFdx(vec3(0.0, 0.0, bumpValue));\n    vec3 dy = dFdy(vec3(0.0, 0.0, bumpValue));\n        \n    dx.x = 1.0;\n    dy.y = 1.0;\n    \n\treturn cross(dx, dy);\n\t//return dFdx(vec3(bumpValue));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 light = normalize(vec3(1.0));\n    \n    // This ranges from 0.0 to about 3.5. The integer component tells you the row number!\n    float row = fragCoord.y / BRICK_HEIGHT;\n\n    // Calculate x and y.\n    float x;\n    float y = fract(fragCoord.y / BRICK_HEIGHT);\n    if (fract(row * 0.5) > 0.5) {\n        // Then we are on an odd row. Offset this row by half a brick.\n        x = fract((fragCoord.x + BRICK_WIDTH / 2.0) / BRICK_WIDTH);\n    } else {\n        // Then we are on an even row. Don't offset this row.\n    \tx = fract(fragCoord.x / BRICK_WIDTH);\n    }\n \n\tfloat horizontal = step(MWF, x) - step(1.0 - MWF, x);\n    float vertical = step(MHF, y) - step(1.0 - MHF, y);\n    \n    vec3 baseColor = mix(MORTAR_COLOR, BRICK_COLOR, horizontal * vertical);\n    vec3 normal = bumpFunction(x, y);\n    float diffuseComponent = clamp(dot(normal, light), 0.0, 1.0);\n    \n\tfragColor = vec4(vec3(baseColor * (1.0 * diffuseComponent)), 1.0);\n    //fragColor = sqrt(fragColor);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mll3z4","date":"1419488611","viewed":392,"name":"Brick Texture","username":"NuclearTide","description":"A simple brick texture with bump mapping, based off code from Texturing and Modeling: A Procedural Approach.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["brick"],"hasliked":0,"parentid":"","parentname":""}}