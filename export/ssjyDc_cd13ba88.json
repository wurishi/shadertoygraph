{"ver":"0.1","info":{"id":"ssjyDc","date":"1644437919","viewed":144,"name":"Eye with refractive cornea","username":"stegu","description":"Cartoonish eyeball with iris behind a refractive prolate cornea, approximated by two intersecting spheres. Analytic AA everywhere.\n\nExperimental hybrid ray trace/screen space rendering. Some view angles look bad. I might revisit this.\n\nDrag mouse to zoom.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fake","raytrace","iris","eyeball","pupil","cornea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Compute the iris pattern. (This really ought to bump the iris normal as well.)\n// Input stp is a convex spherical cap, radius 1.0 in xy, z depth ~0.15\nvec3 iris(vec3 stp, float pupilr) {\n\n    const float PI = 3.1415926536;\n    const vec3 postdark = vec3(0.0, 0.3, 0.6); // Posterior leaf dark color (here: blue)\n    const vec3 postlight = vec3(0.3, 0.5, 0.9); // Posterior leaf light color (here: light blue)\n    const vec3 antecolor = mix(postdark, postlight, 0.8); // Anterior leaf color\n    const vec3 pupilcolor = vec3(0.0); // Pupil color (here: black)\n\n    // Most of the pattern is computed in polar coordinates\n    float r = length(stp.xy);\n    float theta = atan(stp.y, stp.x)/(2.0*PI);   // 0 to 1 rather than 0 to 2*pi\n    float irisr = (r - pupilr) / (1.0 - pupilr); // 0 to 1 outside pupil\n\n    // Posterior leaf: mainly radial streaks, but made with noise to look irregular\n    float pmorph = pupilr * 2.0; // Subtle \"strain\" pattern change on pupil contraction\n    vec2 g, gsum;\n    float postnoise = psrdnoise(vec2(theta*50.0, irisr*0.5), vec2(50.0, 0.0), pmorph, gsum);\n    postnoise += psrdnoise(vec2(theta*100.0, irisr*1.0)-0.15*gsum, vec2(100.0, 0.0), 2.0*pmorph, g);\n\n    // Use first two terms for the pupil edge: less jaggy, but syncs up with the streaks\n    float pupilnoise = postnoise * 0.004;\n    gsum += g;\n    // Add a third octave for the iris pattern (no big difference, just a little more crisp)\n    postnoise += 0.5*psrdnoise(vec2(theta*200.0, irisr*2.0)-0.15*gsum, vec2(200.0, 0.0), 4.0*pmorph, g);\n    vec3 postcolor = mix(postdark, postlight, 0.5+0.5*postnoise);\n\n    // Anterior leaf - a webby-scrunchy tissue extending inwards from the rim\n    // (Code deleted, because the pattern sucked. Settled for a cartoonish look.)\n\n    vec3 iriscolor = postcolor;\n\n    float pupilblend = aasmoothstep(-0.05, 0.05, r - pupilr + pupilnoise);\n    pupilblend *= aastep(pupilr, r + pupilnoise); // Slightly jagged edge for the pupil\n    iriscolor = mix(pupilcolor, iriscolor, pupilblend);\n\n    // Add some fake \"ambient occlusion\" shadowing at the outer rim\n    // (IRL, the rim of the iris attaches slightly recessed from the sclera)\n    iriscolor *= 1.0-0.55*aasmoothstep(0.9, 1.0, r);\n    return iriscolor;\n}\n\n// Compute the sclera pattern.\n// Input stp is a point on the unit sphere. The cornea ends at z = 269.0/325.0.\nvec3 sclera(vec3 stp, float howbloodshotdowewantit) {\n    return vec3(1.0); // A not-so-realistic pattern\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Viewport x,y in [-1.05,1.05], z=5\n    vec3 uvw = 2.1*vec3((fragCoord-iResolution.xy*0.5)/min(iResolution.x, iResolution.y), 5.0);\n    vec3 V = vec3(0.0, 0.0, 1.0); // View direction, \"infinite viewer\" (orthographic view)\n\n    // Large sphere (sclera), radius 1.0 (IRL 12-12.5 mm)\n    const float r1 = 1.0;\n    // Smaller sphere (cornea), radius 0.64 (IRL ~ 8 mm)\n    const float r2 = 0.64;\n    const float dz = 0.52; // Center offset from large sphere\n\n    const float iz = 269.0/325.0;     // Plane of intersection (depends on r1, r2, dz)\n    const float ir = sqrt(1.0-iz*iz); // Radius of circle of intersection\n \n    // A gradient background, for lack of a better idea\n    vec3 bgcolor = (0.5 + 1.5*smoothstep(-1.0, 1.0, uvw.y)) * vec3(0.5, 0.8, 0.5);\n\n    // Adjust scale by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = pow(0.98,iMouse.y-abs(iMouse.w));\n    uvw.xy = zoom*uvw.xy;\n\n    // This particular demo wants to know our AA step size in object-space coords\n    float dP = fwidth(uvw.x); // Our u and v are both in the view plane - either works\n\n    // Outer bounds mask. Adds dP for slightly more margin in distant views.\n    float bounds = 1.0 - aastep(r1 + r2 - dz + 0.05 + 2.0*dP, length(uvw.xy));\n    if(bounds == 0.0) { // Early exit outside object - this can save a ton of work\n        fragColor = vec4(bgcolor, 1.0);\n        return;\n    }\n\n    mat3 M; // M maps view coords to object coords (not the other way around)\n    // Look up and down\n    float el = 0.1*sin(iTime);\n    float Se = sin(el);\n    float Ce = cos(el);\n    M = mat3(1.0, 0.0, 0.0, 0.0, Ce, -Se, 0.0, Se, Ce);\n    // Look side to side\n    float az = 0.5 + 0.6*sin(iTime*sqrt(0.5));\n    float Sa = sin(az);\n    float Ca = cos(az);\n    M = M * mat3(Ca, 0.0, Sa, 0.0, 1.0, 0.0, -Sa, 0.0, Ca);\n    mat3 Mi = transpose(M); // Orthonormal matrix, transpose = inverse\n\n    V = M * V; // Transform view direction to object space\n    vec3 p = M * uvw; // Ray origin for this fragment, in object space\n\n    // Trace sclera\n    vec4 qt1 = tracesphere(p, V, r1+dP);\n    vec3 N1 = qt1.xyz*(1.0/(r1+dP)); // (r1 = 1.0, but dP adds a little to it)\n\n    // AA outline. This is somewhat of a hack:\n    // shave off about one pixel around the rim of both spheres to\n    // avoid having the AA smoothstep() interpolating \"into the void\",\n    // as this would result in sparkly noise. The rendered radius of\n    // this sphere is r1, but the traced radus is r1+dP. Hence, the rim\n    // has a normal that is not exactly perpendicular to the view direction.\n    // The deviation is very small, except for extremely zoomed-out views.\n    float scleramask = 1.0 - aastep(r1, length((Mi*qt1.xyz).xy));\n\n    // Trace cornea\n    vec3 d = vec3(0.0, 0.0, dz-dP); // Offset to poke through sclera\n    vec4 qt2 = tracesphere(p-d, V, r2+dP);\n    vec3 N2 = qt2.xyz*(1.0/(r2+dP)); // Normalize (all qt2.xyz have length r2)\n   \n    // AA outline, carefully constructed for smooth edges from all angles\n    float corneamask = 1.0-aastep(r2-0.5*dP, length((Mi*qt2.xyz).xy)); // Sphere rim\n    // z is wonky around the sphere rim, so do the AA step on xy, not z\n    corneamask *= (1.0-aastep(ir+1.5*dP, length(qt2.xy))); // Intersection with sclera\n    corneamask *= step(0.0,qt2.z); // Mask out the back of the sphere\n\n    // Raytracing hack: a \"beyond-the-rim N\" to reduce aliasing around edges\n    // (Makes no real difference now, though, with our careful nudges of aastep())\n    vec3 N = normalize(vec3(uvw.xy, 0.0));\n    N = mix(N, N1, scleramask);\n    N = mix(N, N2, corneamask);\n    // Because V and p were in object coords, N1, N2 and N are as well.\n\n    vec3 L = M * normalize(vec3(1.0, 2.0, 3.0)); // Directional light\n    vec3 R = reflect(-L, N);\n    float ks = max(0.0, dot(R, V));\n    ks = pow(ks, 30.0);\n    vec3 specularcolor = vec3(1.0);\n    vec3 Is = specularcolor * ks;\n\n    vec3 iriscolor = vec3(0.5); // Costly pattern, computed only if needed\n    float pupil_size = 0.4 + 0.08*psrdnoise(iTime*vec2(sqrt(0.2), sqrt(0.15)));\n    if(corneamask > 0.0) { // If we hit the cornea, compute the iris color\n        vec3 T = refract(-V, N, 1.0/1.3333); // IOR is inverse of what I'd expect...\n        // Place the iris on the big sphere. Reasonably anatomically correct.\n        vec4 q = tracesphere(qt2.xyz+vec3(0.0,0.0,0.52), -T, 1.0);\n        iriscolor = iris(q.xyz/ir, pupil_size);\n    }\n\n    vec3 scleracolor = sclera(p, 0.2); // Our super advanced sclera pattern\n    vec3 diffusecolor = mix(scleracolor, iriscolor, corneamask);\n    // The iris is shaded with the normal of the cornea. This is, of course, wrong.\n    vec3 Id = 0.9 * diffusecolor * max(0.0, dot(N, L));\n    vec3 Ia = 0.1 * diffusecolor;\n    vec3 mixcolor = Ia + Id;\n    // Fake high intensity for the specular highlight: blend, don't add!\n    mixcolor = mix(mixcolor, vec3(1.0), Is*2.0);\n\n    mixcolor = mix(bgcolor, mixcolor, max(scleramask, corneamask)); // AA outline\n\n    fragColor = vec4(mixcolor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// psrdnoise (c) Stefan Gustavson and Ian McEwan,\n// ver. 2021-12-02, published under the MIT license:\n// https://github.com/stegu/psrdnoise/\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)\n{\n\tvec2 uv = vec2(x.x+x.y*0.5, x.y);\n\tvec2 i0 = floor(uv), f0 = fract(uv);\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\tvec2 i1 = i0 + o1, i2 = i0 + 1.0;\n\tvec2 v0 = vec2(i0.x - i0.y*0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y*0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\tvec2 x0 = x - v0, x1 = x - v1, x2 = x - v2;\n\tvec3 iu, iv, xw, yw;\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\tiu = floor(xw + 0.5*yw + 0.5); iv = floor(yw + 0.5);\n\t} else {\n\t\tiu = vec3(i0.x, i1.x, i2.x); iv = vec3(i0.y, i1.y, i2.y);\n\t}\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\tvec3 psi = hash*0.07482 + alpha;\n\tvec3 gx = cos(psi); vec3 gy = sin(psi);\n\tvec2 g0 = vec2(gx.x, gy.x);\n\tvec2 g1 = vec2(gx.y, gy.y);\n\tvec2 g2 = vec2(gx.z, gy.z);\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0); vec3 w2 = w*w; vec3 w4 = w2*w2;\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\tfloat n = dot(w4, gdotx);\n\tvec3 w3 = w2*w; vec3 dw = -8.0*w3*gdotx;\n\tvec2 dn0 = w4.x*g0 + dw.x*x0;\n\tvec2 dn1 = w4.y*g1 + dw.y*x1;\n\tvec2 dn2 = w4.z*g2 + dw.z*x2;\n\tgradient = 10.9*(dn0 + dn1 + dn2);\n\treturn 10.9*n;\n}\n\n// Some psrdnoise() aliases with unused parameters removed\n// (No extra speedup, but less typing and less code clutter)\nfloat psrdnoise(vec2 x, vec2 period, float alpha) {\n    vec2 g;\n    return psrdnoise(x, period, alpha, g);\n}\n\nfloat psrdnoise(vec2 x, float alpha) {\n    vec2 g;\n    return psrdnoise(x, vec2(0.0), alpha, g);\n}\n\nfloat psrdnoise(vec2 x, vec2 period) {\n    vec2 g;\n    return psrdnoise(x, period, 0.0, g);\n}\n\nfloat psrdnoise(vec2 x) {\n    vec2 g;\n    return psrdnoise(x, vec2(0.0), 0.0, g);\n}\n\n// Ray trace against a sphere of radius r at origin,\n// from point p in direction -v. The vec4 return value\n// contains the hit point in p space as the .xyz\n// components, and the t value as the .w component.\n// (The input view vector v must be normalized.)\nvec4 tracesphere(vec3 p, vec3 v, float r) {\n    float a = dot(p,v);\n    float b = a*a - dot(p,p) + r*r;\n    if (b < 0.0) return vec4(p-1e3*v, 1e3); // Infinity is a 1e3\n    float t = a-sqrt(b); // Return \"first hit\" (smallest t)\n    vec3 q = p - t*v;\n    return vec4(q,t);\n}\n\n// Ray trace against a plane at z=0 from point p in direction v.\n// The return vec4 has the hit point in .xyz, and .w is the distance.\n// A negative distance means that the hit is \"behind the camera\".\n// (If v.z = 0, there is no hit.)\nvec4 traceplane(vec3 p, vec3 v) {\n    if(v.z == 0.0) return vec4(p, 1e10);\n    float t = p.z/v.z;\n    return vec4(p-t*v, t);\n}\n\n// Screen-space auto-derivative anti-aliased step()\nfloat aastep(float threshold, float value) {\n\tfloat afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n\treturn smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n#if 0\n// An aastep() for when \"value\" is undefined across \"threshold\" or has\n// a discontinuity at the threshold, mangling the auto derivatives.\n// (The AA margin is pushed safely inside the value < threshold region.)\nfloat aainstep(float threshold, float value) {\n\tfloat afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n\treturn smoothstep(threshold-3.0*afwidth, threshold-1.0*afwidth, value);\n}\n#endif\n\n// A smoothstep() that blends to an aastep() under minification\nfloat aasmoothstep(float t1, float t2, float v) {\n\tfloat aw = 0.7 * length(vec2(dFdx(v), dFdy(v)));\n    float t = 0.5*(t1+t2);\n\tfloat sw = max(0.5*(t2-t1), aw);\n\treturn smoothstep(t-sw, t+sw, v);\n}\n","name":"Common","description":"","type":"common"}]}