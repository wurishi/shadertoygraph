{"ver":"0.1","info":{"id":"ltVSD1","date":"1484243776","viewed":277,"name":"Circle with motion blur","username":"Fieu","description":"Some practice with motion blur on circle (based on [url=http://john-chapman-graphics.blogspot.com/2013/01/what-is-motion-blur-motion-pictures-are.html]this article[/url]).","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["blur","circle","motion","rotating","with"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Motion Blur sample rate (affects how smooth the grandient will be)\n#define rate 16.0\n\n// Motion Blur strength (how many frames backward, affects blur distance)\n#define strength 1.0\n\n// Circle radius\n#define radius 0.3\n\n// Circle move horizontal amplitude\n#define moveWidth 0.8\n\n// Circle move vertical amplitude\n#define moveHeight 0.5\n\n// Move speed (rounds per second)\n#define speed 0.7\n\n#define PI 3.141593\n\n/*\n * Some practice with analytical motion blur. Comment to change to force sample motion blur.\n * Still analyzing FabriceNeyret2's code :)\n */\n//#define USE_ANALYTIC_MOTION_BLUR\n\n/*\n * DrawLine by FabriceNeyret2 (and some other small code changes)\n */\nvec3 drawLine(vec2 uv, vec2 mouse, vec3 bgCol) {\n    return abs(uv.x - mouse.x) < 2./iResolution.x ? vec3(1, 0, 0) : bgCol;\n}\n\n/*\n * Circle drawing function\n */\nvec3 drawCircle(vec2 uv, float t) {\n    float a = 2.*PI*t;\n    vec2 r = vec2(sin(a) * moveWidth, cos(a) * moveHeight) - uv;\n    return length(r) > radius ? vec3(0) : vec3(1);\n}\n\n/*\n * Drawing circle with analytical motion blur. (Huge thanks to FabriceNeyret2)\n */\nvec3 drawCircleWithAMB(vec2 uv, float t0, float t1) {\n    float twoPI = 2.*PI,\n          A0 = twoPI * t0,\n          A1 = twoPI * t1;\n    vec2 P0 = uv - vec2(sin(A0) * moveWidth, cos(A0) * moveHeight),\n         P1 = uv - vec2(sin(A1) * moveWidth, cos(A1) * moveHeight),\n         move = P1 - P0;\n    float a = dot(move, move),\n          b = 2. * dot(P0, move),\n          c = dot(P0, P0) - radius*radius,\n          d = b*b - 4.*a*c;\n    if (d < 0.) {\n        return vec3(0.);\n    }\n    d = sqrt(d);\n    float d0 = (-b - d)/(2.*a),\n          d1 = (-b + d)/(2.*a);\n    if (d0 > 1. || d1 < 0.) return vec3(0.);\n    return vec3(min(1., d1) - max(0., d0));\n}\n\n\n/*\n * Previous drawLine\n *\nvec3 drawLine(vec2 uv, vec2 mouse, vec3 bgCol) {\n    if (uv.x < mouse.x + 0.005 &&\n        uv.x > mouse.x - 0.005) return vec3(1.0, 0.0, 0.0);\n    return bgCol;\n}\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalization\n    float m = min(iResolution.x, iResolution.y);\n\tvec2 uv = 2. * fragCoord.xy - iResolution.xy;\n    uv /= m;\n    vec2 mouse = 2. * iMouse.xy - iResolution.xy;\n    mouse /= m;\n    \n    vec3 c = vec3(0.);\n    if (uv.x > mouse.x) { // Motion blurred side\n        \n        #ifdef USE_ANALYTIC_MOTION_BLUR\n        \tfloat t = speed*iTime;\n        \tc = drawCircleWithAMB(uv, t, t - strength/60.);\n        #else\n        \n        for (float f = 0.; f < rate; f += 1.) {\n            float t = speed*iTime - strength*f/60./rate;\n            c += drawCircle(uv, t);\n    \t}\n        c /= rate;\n        \n        #endif\n    }\n    else { // Normal side\n        float t = speed*iTime;\n        c = drawCircle(uv, t);\n    }\n    \n    // Draw vertical red line\n    c = drawLine(uv, mouse, c);\n    \n\tfragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}