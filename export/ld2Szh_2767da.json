{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nvec2 rotate( in vec2 p, in float t )\n{\n\treturn p * cos( -t ) + vec2( p.y, -p.x ) * sin( -t );\n}\n    \nvec3 rotate( in vec3 p, in vec3 t )\n{\n    p.yz = rotate( p.yz, t.x );\n    p.zx = rotate( p.zx, t.y );\n\tp.xy = rotate( p.xy, t.z );\n    return p;\n}\n\nfloat udBox( in vec3 p, in vec3 b )\n{\n\treturn length( max( abs( p ) - b, 0.0 ) );\n}\n\nfloat boundingBox( in vec3 p, in vec3 r, out bool f )\n{\n\tconst float o = 0.03;\n    f = false;\n    if ( abs( p.x ) > r.x ) return udBox( p, r - o );\n\tif ( abs( p.y ) > r.y ) return udBox( p, r - o );\n\tif ( abs( p.z ) > r.z ) return udBox( p, r - o );\n    //if ( dot(step(r,abs(p)),vec3(1.0))>0.0 ) return udBox( p, r - o );\n\tf = true;\n    //return length( p );\n    return 1.0;\n}\n\n/*\nfloat triangleDE( in vec3 p, in vec3 a, in vec3 b, in vec3 c )\n{\n    vec3 ab = b - a;\n    vec3 bc = c - b;\n    vec3 ca = a - c;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    vec3 cp = p - c;\n    vec3 n = cross( ab, -ca ) ;\n    if ( dot( cross( n, ab ), ap ) < 0.0 )\n    {        \n        float t = clamp( dot( ab, ap ) / dot( ab, ab ), 0.0, 1.0 );        \n        return length( vec3( t * ab - ap ) );\n    }\n    if ( dot( cross( n, bc ), bp ) < 0.0 )\n    {\n        float t = clamp( dot( bc, bp ) / dot( bc, bc ), 0.0, 1.0 );        \n        return length( vec3( t * bc - bp ) );\n    }\n    if ( dot( cross( n, ca ), cp ) < 0.0 )\n    {\n        float t = clamp( dot( ca, cp ) / dot( ca, ca ), 0.0, 1.0 );        \n        return length( vec3( t * ca - cp ) );\n    }\n    return abs( dot( normalize( n ), ap ) );\n}\n*/\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3 )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt((min( min(dot(cross(v21,nor),p1),dot(cross(v32,nor),p2)),dot(cross(v13,nor),p3))<0.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n    /*\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n\t*/\n}\n\nfloat udQuad( in vec3 p, in vec3 v1, in vec3 v2, in vec3 v3, in vec3 v4 )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v43 = v4 - v3; vec3 p3 = p - v3;\n    vec3 v14 = v1 - v4; vec3 p4 = p - v4;\n    vec3 nor = cross( v21, v14 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v43,nor),p3)) + \n                  sign(dot(cross(v14,nor),p4))<3.0) \n                  ?\n                  min( min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v43*clamp(dot(v43,p3)/dot2(v43),0.0,1.0)-p3) ),\n                  dot2(v14*clamp(dot(v14,p4)/dot2(v14),0.0,1.0)-p4) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\nstruct Mesh\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    vec3 d;\n};\n\nconst float sepT = 4.0;\nconst float sepR = 6.0;\nconst float radT = 0.2;\nconst float radR = 0.5;   \n    \nMesh genTorus( in int idx )\n{\n    float thetaT = PI2 / sepT;\n    float thetaR = PI2 / sepR;\n    float i = float( idx );\n    float idT = mod( i, sepT );\n    vec3 vt0 = vec3( radT, 0.0, 0.0 );\n    vec3 vt1 = vec3( radT, 0.0, 0.0 );\n    vt0.xy = rotate( vt0.xy, idT * thetaT );\n    vt1.xy = rotate( vt1.xy, ( idT + 1.0 ) * thetaT );\n    vt0.x += radR;\n    vt1.x += radR;\n    float idR = floor( i / sepT );\n    vec3 v0 = vt0;\n    vec3 v1 = vt1;\n    vec3 v2 = vt0;\n    vec3 v3 = vt1;\n    v0.zx = rotate( v0.zx, idR * thetaR );\n    v1.zx = rotate( v1.zx, idR * thetaR );\n    v2.zx = rotate( v2.zx, ( idR + 1.0 ) * thetaR );\n    v3.zx = rotate( v3.zx, ( idR + 1.0 ) * thetaR );\n    //if (idx < int( sepT * sepR ) ) return Mesh( v0, v1, v2 );\n    //return Mesh( v2, v3, v1 );\n    return Mesh( v1, v0, v2, v3 );\n}\n\n/*\n\nvec3 calcNormal( in vec3 p )\n{\n\tconst vec2 e = vec2( 0.0001, 0.0 );\n\tvec3 n = vec3(\n\t\tmap( p + e.xyy ) - map( p - e.xyy ),\n\t\tmap( p + e.yxy ) - map( p - e.yxy ),\n\t\tmap( p + e.yyx ) - map( p - e.yyx ) );\n\treturn normalize( n );    \n}\n\nfloat map( in vec3 p )\n{\n    bool f;\n    float d = boundingBox( p, vec3( 0.72, 0.22, 0.72 ), f );\n    if ( f )\n    { \n        for ( int i = 0; i < 30; i++ )\n    \t{\n            Mesh m = genTorus( i );\n            d = min( udQuad( p, m.a, m.b, m.c, m.d ), d );\n        }\n        d -= 0.001;\n    }\n    vec3 a = vec3(0.0, 1.0, 0.0);\n    vec3 b = vec3(1.5, 0.0, 0.0);\n    vec3 c = vec3(0.0, -1.0, 0.0);\n    return min( d, udTriangle( p, a, b, c ) - 0.001 ); \n}\n*/\n\nvec3 calcNormal( in vec3 p, in vec3 v1, in vec3 v2 )\n{\n    return normalize( cross(  v2 - v1, p - v1 ) );\n}\n    \nfloat map( in vec3 p, out vec3 nor )\n{\n    bool f;\n    vec3 v1 = vec3( 0.0 );\n    vec3 v2 = vec3( 0.0 );\n    nor = vec3( 0.0 );\n    float de = boundingBox( p, vec3( 0.72, 0.22, 0.72 ), f );\n    if ( f )\n    { \n        for ( int i = 0; i < int(sepT*sepR); i++ )\n    \t{\n            Mesh m = genTorus( i );\n            float d0 = udQuad( p, m.a, m.b, m.c, m.d );\n            if ( d0 < de )\n            {\n              de = d0;\n              v1 = m.a;\n              v2 = m.b;\n            }\n        }\n        de -= 0.001;\n    }\n    vec3 t1 = vec3(1.5, 0.0, 0.0);\n    vec3 t2 = vec3(0.0, 1.0, 0.0);\n    vec3 t3 = vec3(0.0, -1.0, 0.0);\n    float d0 = udTriangle( p, t1, t2, t3 ) - 0.001;\n    if ( d0 < de )\n    {\n    \tde = d0;\n        v1 = t1;\n        v2 = t2;       \n    }\n    vec3 q1 = vec3(0.0, 0.0, 0.0);\n    vec3 q2 = vec3(-1.0, 0.8, 0.0);\n    //vec3 q3 = vec3(-1.2 + 0.5 * sin(iTime), 0.0, 0.0); // concave quad\n    vec3 q3 = vec3(-1.2, 0.0, 0.0);\n    vec3 q4 = vec3(-1.0, -0.8, 0.0);\n    float d1 = udQuad( p, q1, q2, q3, q4 ) - 0.001;\n    if ( d1 < de )\n    {\n        de = d1;\n        v1 = q1;\n        v2 = q2;       \n    }\n    nor = calcNormal( p, v1, v2 );\n    return de; \n}\n\n\nfloat march( in vec3 ro, in vec3 rd, out vec3 nor )\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i = 0; i < 48; i++ )\n    {\n        if( h < precis || t > maxd ) break;\n\t    //h = map( ro + rd * t );\n\t    h = map( ro + rd * t, nor );\n        t += h;\n    }\n    if( t < maxd ) res = t;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n\tvec3 col = vec3( 0.4 + 0.15 * p.y );\n   \tvec3 rd = normalize( vec3( p, -1.8 ) );\n\tvec3 ro = vec3( 0.0, 0.0, 3.0 );\n    vec3 light = normalize( vec3( 0.5, 0.8, 3.0 ) );\n    vec3 rot = vec3( 0.3, 0.5 * iTime, 0.4 );\n    ro = rotate( ro, rot );\n\trd = rotate( rd, rot );\n\tlight = rotate( light, rot );\n    vec3 n;\n    //float t = march( ro, rd );\n    float t = march( ro, rd, n );\n    if( t > -0.1 )\n    {\n        //vec3 pos = ro + t * rd;\n        //vec3 n = calcNormal( pos );\n        float br = dot( n, light ) ;\n\t\tcol = vec3( 1.0, 0.8, 0.5 );\n        //float side = dot( n, rotate( vec3(0.0, 0.0, 1.0 ), rot));\n        float side = dot( n, -rd);\n        if (side < 0.0) // reverse\n        {\n            col = vec3( 0.5, 0.5, 1.0 );\n            br *= -1.0;\n            // br = abs( br );\n        }\n        br = clamp( ( br + 0.5 ) * 0.7, 0.3, 1.0 );\n        col*=  br; \n\t}\n   \tfragColor = vec4( vec3( col ), 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld2Szh","date":"1409144048","viewed":180,"name":"polygon test","username":"gaz","description":"3d","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","polygon"],"hasliked":0,"parentid":"","parentname":""}}