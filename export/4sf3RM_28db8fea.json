{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//// High quality (Some browsers may freeze or crash)\n//#define HIGHQUALITY\n\n//// Medium quality (Should be fine on all systems, works on Intel HD2000 on Win7 but quite slow)\n//#define MEDIUMQUALITY\n\n//// Defaults\n//#define REFLECTIONS\n#define SHADOWS\n//#define GRASS\n//#define SMALL_WAVES\n#define RAGGED_LEAVES\n//#define DETAILED_NOISE\n//#define LIGHT_AA // 2 sample SSAA\n//#define HEAVY_AA // 2x2 RG SSAA\n//#define TONEMAP\n\n//// Configurations\n#ifdef MEDIUMQUALITY\n\t#define SHADOWS\n\t#define SMALL_WAVES\n\t#define RAGGED_LEAVES\n\t#define TONEMAP\n#endif\n\n#ifdef HIGHQUALITY\n\t#define REFLECTIONS\n\t#define SHADOWS\n\t//#define GRASS\n\t#define SMALL_WAVES\n\t#define RAGGED_LEAVES\n\t#define DETAILED_NOISE\n\t#define LIGHT_AA\n\t#define TONEMAP\n#endif\n\n// Constants\nconst float eps = 1e-5;\nconst float PI = 3.14159265359;\n\nconst vec3 sunDir = vec3(0.79057,-0.47434, 0.0);\nconst vec3 skyCol = vec3(0.3, 0.5, 0.8);\nconst vec3 sandCol = vec3(0.9, 0.8, 0.5);\nconst vec3 treeCol = vec3(0.8, 0.65, 0.3);\nconst vec3 grassCol = vec3(0.4, 0.5, 0.18);\nconst vec3 leavesCol = vec3(0.3, 0.6, 0.2);\nconst vec3 leavesPos = vec3(-5.1,13.4, 0.0);\n\n#ifdef TONEMAP\nconst vec3 sunCol = vec3(1.8, 1.7, 1.6);\n#else\nconst vec3 sunCol = vec3(0.9, 0.85, 0.8);\n#endif\n\nconst float exposure = 1.1; // Only used when tonemapping\n\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n// noise functions.\n// Author : Ian McEwan, Ashima Arts.\n// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n// Distributed under the MIT License. See LICENSE file.\n// https://github.com/ashima/webgl-noise\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v) {\n  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i = floor(v + dot(v, C.yyy) );\n  vec3 x0 = v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n  // x1 = x0 - i1 + 1.0 * C.xxx;\n  // x2 = x0 - i2 + 2.0 * C.xxx;\n  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\n\n// Main\nfloat fbm(vec3 p)\n{\n\tfloat final = snoise(p); \n\tp *= 1.94; final += snoise(p) * 0.5;\n\t#ifdef DETAILED_NOISE\n\tp *= 3.75; final += snoise(p) * 0.25;\n\treturn final / 1.75;\n\t#else\n\treturn final / 1.5;\n\t#endif\n}\n\nfloat waterHeight(vec3 p)\n{\n\tfloat d = length(p.xz);\n\tfloat h = sin(d * 1.5 + iTime * 3.0) * 12.0 / d; // Island waves\n\t#ifdef SMALL_WAVES\n\th += fbm(p*0.5); // Other waves\n\t#endif\n\treturn h;\n}\n\nvec3 bump(vec3 pos, vec3 rayDir)\n{\n\tfloat s = 2.0;\n\t\n\t// Fade out waves to reduce aliasing\n\tfloat dist = dot(pos, rayDir);\n\ts *= dist < 2.0 ? 1.0 : 1.4142 / sqrt(dist);\n\t\n\t// Calculate normal from heightmap\n\tvec2 e = vec2(1e-2, 0.0);\n\tvec3 p = vec3(pos.x, iTime*0.5, pos.z)*0.7;\n\tfloat m = waterHeight(p)*s;\n\treturn normalize(vec3(\n\t\twaterHeight(p+e.xyy)*s-m,\n\t\t1.0,\n\t\twaterHeight(p+e.yxy)*s-m\n\t));\n}\n\n// Ray intersections\nvec4 intersectSphere(vec3 rpos, vec3 rdir, vec3 pos, float rad)\n{\n\tvec3 op = pos - rpos;\n\tfloat b = dot(op, rdir); \n\tfloat det = b*b - dot(op, op) + rad*rad; \n\t\t\n\tif (det > 0.0)\n\t{\n\t\tdet = sqrt(det);\n\t\tfloat t = b - det;\n\t\tif (t > eps)\n\t\t\treturn vec4(-normalize(rpos+rdir*t-pos), t);\n\t}\n\t\n\treturn vec4(0.0);\n}\n\nvec4 intersectCylinder(vec3 rpos, vec3 rdir, vec3 pos, float rad)\n{\n\tvec3 op = pos - rpos;\n\tvec2 rdir2 = normalize(rdir.yz);\n\tfloat b = dot(op.yz, rdir2);\n\tfloat det = b*b - dot(op.yz, op.yz) + rad*rad; \n\t\n\tif (det > 0.0)\n\t{\n\t\tdet = sqrt(det);\n\t\tfloat t = b - det;\n\t\tif (t > eps)\n\t\t\treturn vec4(-normalize(rpos.yz+rdir2*t-pos.yz), 0.0, t);\n\t\tt = b + det;\n\t\tif (t > eps)\n\t\t\treturn vec4(-normalize(rpos.yz+rdir2*t-pos.yz), 0.0, t);\n\t}\n\t\n\treturn vec4(0.0);\n}\n\nvec4 intersectPlane(vec3 rayPos, vec3 rayDir, vec3 n, float d)\n{\n\tfloat t = -(dot(rayPos, n) + d) / dot(rayDir, n);\n\treturn vec4(n * sign(dot(rayDir, n)), t);\n}\n\n// Helper functions\nvec3 rotate(vec3 p, float theta)\n{\n\tfloat c = cos(theta), s = sin(theta);\n\treturn vec3(p.x * c + p.z * s, p.y,\n\t\t\t\tp.z * c - p.x * s);\n}\n\nfloat impulse(float k, float x) // by iq\n{\n    float h = k*x;\n    return h * exp(1.0 - h);\n}\n\n// Raymarched parts of scene\nfloat grass(vec3 pos)\n{\n\tfloat h = length(pos - vec3(0.0, -7.0, 0.0)) - 8.0;\n\t\n\tif (h > 2.0) return h; // Optimization (Avoid noise if too far away)\n\t\n\treturn h + snoise(pos * 3.0) * 0.1 + pos.y * 0.9;\n}\n\nfloat tree(vec3 pos)\n{\n\tpos.y -= 0.5;\n\tfloat s = sin(pos.y*0.03);\n\tfloat c = cos(pos.y*0.03);\n\tmat2 m = mat2(c, -s, s, c);\n\tvec3 p = vec3(m*pos.xy, pos.z);\n\t\n\tfloat width = 1.0 - pos.y * 0.02 - clamp(sin(pos.y * 8.0) * 0.1, 0.05, 0.1);\n\t\n\treturn max(length(p.xz) - width, pos.y - 12.5);\n}\n\nvec2 scene(vec3 pos)\n{\n\tfloat vtree = tree(pos);\n\t#ifdef GRASS\n\tfloat vgrass = grass(pos);\n\tfloat v = min(vtree, vgrass);\n\t#else\n\tfloat v = vtree;\n\t#endif\n\treturn vec2(v, v == vtree ? 2.0 : 1.0);\n}\n\nvec3 normal(vec3 pos)\n{\n\tvec2 eps = vec2(1e-3, 0.0);\n\tfloat h = scene(pos).x;\n\treturn normalize(vec3(\n\t\tscene(pos-eps.xyy).x-h,\n\t\tscene(pos-eps.yxy).x-h,\n\t\tscene(pos-eps.yyx).x-h\n\t));\n}\n\nfloat trunkShadow(vec3 rayPos, vec3 rayDir)\n{\n\t// Soft shadow taken from iq\n\tfloat k = 6.0;\n\tfloat t = 0.0;\n\tfloat s = 1.0;\t\n\tfor (int i = 0; i < 30; i++)\n\t{\n\t\tvec3 pos = rayPos+rayDir*t;\t\n\t\tvec2 res = scene(pos);\t\t\n\t\tif (res.x < 0.001) return 0.0;\n\t\ts = min(s, k*res.x/t); \n\t\tt += max(res.x, 0.01);\n\t}\n\t\n\treturn s*s*(3.0 - 2.0*s);\n}\n\n// Ray-traced parts of scene\nvec4 intersectWater(vec3 rayPos, vec3 rayDir)\n{\n\tfloat h = sin(20.5 + iTime * 2.0) * 0.03;\n\tfloat t = -(rayPos.y + 2.5 + h) / rayDir.y;\n\treturn vec4(0.0, 1.0, 0.0, t);\n}\n\nvec4 intersectSand(vec3 rayPos, vec3 rayDir)\n{\n\treturn intersectSphere(rayPos, rayDir, vec3(0.0,-24.1,0.0), 24.1);\n}\n\nvec4 intersectTreasure(vec3 rayPos, vec3 rayDir)\n{\n\treturn vec4(0.0);\n}\n\nvec4 intersectLeaf(vec3 rayPos, vec3 rayDir, float openAmount)\n{\t\n\tvec3 dir = normalize(vec3(0.0, 1.0, openAmount));\n\tfloat offset = 0.0;\n\t\t\t\n\tvec4 res = intersectPlane(rayPos, rayDir, dir, 0.0);\n\tvec3 pos = rayPos+rayDir*res.w;\n\t#ifdef RAGGED_LEAVES\n\toffset = snoise(pos*0.8) * 0.3;\n\t#endif\n\tif (pos.y > 0.0 || length(pos * vec3(0.9, 2.0, 1.0)) > 4.0 - offset) res.w = 0.0;\n\t\n\tvec4 res2 = intersectPlane(rayPos, rayDir, vec3(dir.xy, -dir.z), 0.0);\n\tpos = rayPos+rayDir*res2.w;\n\t#ifdef RAGGED_LEAVES\n\toffset = snoise(pos*0.8) * 0.3;\n\t#endif\n\tif (pos.y > 0.0 || length(pos * vec3(0.9, 2.0, 1.0)) > 4.0 - offset) res2.w = 0.0;\n\t\n\tif (res2.w > 0.0 && res2.w < res.w || res.w <= 0.0)\n\t\tres = res2;\n\t\t\n\treturn res;\n}\n\nvec4 leaves(vec3 rayPos, vec3 rayDir)\n{\n\tfloat t = 1e20;\n\tvec3 n = vec3(0.0);\n\t\n\trayPos -= leavesPos;\n\t\n\tfloat sway = impulse(15.0, fract(iTime / PI * 0.125));\n\tfloat upDownSway = sway * -sin(iTime) * 0.06;\n\tfloat openAmount = sway * max(-cos(iTime) * 0.4, 0.0);\n\t\n\tfloat angleOffset = -0.1;\t\n\tfor (float k = 0.0; k < 6.2; k += 0.75)\n\t{\n\t\t// Left-right\n\t\tfloat alpha = k + (k - PI) * sway * 0.015;\n\t\tvec3 p = rotate(rayPos, alpha);\n\t\tvec3 d = rotate(rayDir, alpha);\n\t\t\n\t\t// Up-down\n\t\tangleOffset *= -1.0;\n\t\tfloat theta = -0.4 + \n\t\t\tangleOffset + \n\t\t\tcos(k) * 0.35 + \n\t\t\tupDownSway + \n\t\t\tsin(iTime+k*10.0) * 0.03 * (sway + 0.2);\n\t\t\n\t\tp = rotate(p.xzy, theta).xzy;\n\t\td = rotate(d.xzy, theta).xzy;\n\t\n\t\t// Shift\n\t\tp -= vec3(5.4, 0.0, 0.0);\n\t\t\n\t\t// Intersect individual leaf\n\t\tvec4 res = intersectLeaf(p, d, 1.0+openAmount);\n\t\tif (res.w > 0.0 && res.w < t)\n\t\t{\n\t\t\tt = res.w;\n\t\t\tn = res.xyz;\n\t\t}\n\t}\n\t\n\treturn vec4(n, t);\n}\n\n// Lighting\nfloat shadow(vec3 rayPos, vec3 rayDir)\n{\t\n\tfloat s = 1.0;\n\t\n\t// Intersect sand\n\t//vec4 resSand = intersectSand(rayPos, rayDir);\n\t//if (resSand.w > 0.0) return 0.0;\n\t\n\t// Intersect trunk\n\ts = min(s, trunkShadow(rayPos, rayDir));\n\tif (s < 0.0001) return 0.0;\n\t\n\t// Intersect leaves\n\tvec4 resLeaves = leaves(rayPos, rayDir);\n\tif (resLeaves.w > 0.0 && resLeaves.w < 1e7) return 0.0;\n\t\n\treturn s;\n}\n\nvec3 light(vec3 p, vec3 n)\n{\n\tfloat s = 1.0;\n\t\n\t#ifdef SHADOWS\n\ts = shadow(p-sunDir*0.01, -sunDir);\n\t#endif\n\t\n\tvec3 col = sunCol * min(max(dot(n, sunDir), 0.0), s);\n\tcol += skyCol * (-n.y * 0.5 + 0.5) * 0.3;\n\treturn col;\n}\n\nvec3 lightLeaves(vec3 p, vec3 n)\n{\n\tfloat s = 1.0;\n\t\n\t#ifdef SHADOWS\n\ts = shadow(p-sunDir*0.01, -sunDir);\n\t#endif\n\t\n\tfloat ao = min(length(p - leavesPos) * 0.1, 1.0);\n\t\n\tfloat ns = dot(n, sunDir);\n\tfloat d = sqrt(max(ns, 0.0));\n\tvec3 col = sunCol * min(d, s);\n\tcol += sunCol * max(-ns, 0.0) * vec3(0.3, 0.3, 0.1) * ao;\n\tcol += skyCol * (-n.y * 0.5 + 0.5) * 0.3 * ao;\n\treturn col;\n}\n\nvec3 sky(vec3 n)\n{\n\treturn skyCol * (1.0 - n.y * 0.8);\n}\n\n// Ray-marching\nvec4 trunk(vec3 rayPos, vec3 rayDir)\n{\n\tfloat t = 0.0;\n    vec4 result = vec4(sky(rayDir), 1e8);\n\t\n\tfor (int i = 0; i < 40; i++)\n\t{\n\t\tvec3 pos = rayPos+rayDir*t;\t\n\t\tvec2 res = scene(pos);\n\t\tfloat h = res.x;\n\t\t\n\t\tif (h < 0.001)\n\t\t{\n\t\t\tvec3 col = res.y == 2.0 ? treeCol : grassCol;\n\t\t\tfloat uvFact = res.y == 2.0 ? 1.0 : 10.0;\n\t\t\t\n\t\t\tvec3 n = normal(pos);\n\t\t\tvec2 uv = vec2(n.x, pos.y * 0.5) * 0.2 * uvFact;\n\t\t\tvec3 tex = texture(iChannel0, uv).rgb * 0.6 + 0.4;\n\t\t\tfloat ao = min(length(pos - leavesPos) * 0.1, 1.0);\n            result = vec4(col * light(pos, n) * ao * tex, t);\n            break;\n\t\t}\n\t\t\n\t\tt += h;\n\t}\n\t\n\treturn result;\n}\n\n// Final combination\nvec3 traceReflection(vec3 rayPos, vec3 rayDir)\n{\n\tvec3 col = vec3(0.0);\n\tfloat t = 1e20;\n\t\t\t\n\t// Intersect trunk\n\tvec4 resTrunk = trunk(rayPos, rayDir);\n\tif (resTrunk.w > 0.0 && resTrunk.w < t)\n\t{\n\t\tt = resTrunk.w;\n\t\tcol = resTrunk.xyz;\n\t}\n\t\n\t// Intersect leaves\n\tvec4 resLeaves = leaves(rayPos, rayDir);\n\tif (resLeaves.w > 0.0 && resLeaves.w < t)\n\t{\n\t\tvec3 pos = rayPos + rayDir * resLeaves.w;\n\t\tvec2 uv = (pos.xz - leavesPos.xz) * 0.3;\n\t\tfloat tex = texture(iChannel0, uv).r * 0.6 + 0.5;\n\t\t\n\t\tt = resLeaves.w;\n\t\tcol = leavesCol * lightLeaves(pos, resLeaves.xyz) * tex;\n\t}\n\t\t\n\tif (t > 1e7) return sky(rayDir);\n\t\n\treturn col;\n}\n\nvec3 trace(vec3 rayPos, vec3 rayDir)\n{\n\tvec3 col = vec3(0.0);\n\tfloat t = 1e20;\n\t\n\t// Intersect sand\n\tvec4 resSand = intersectSand(rayPos, rayDir);\n\tif (resSand.w > 0.0)\n\t{\n\t\tvec3 pos = rayPos + rayDir * resSand.w;\n\t\tt = resSand.w;\n\n\t\tcol = sandCol * light(pos, resSand.xyz);\n\t}\n\t\n\t// Intersect treasure chest\n\tvec4 resTreasure = intersectTreasure(rayPos, rayDir);\n\tif (resTreasure.w > 0.0 && resTreasure.w < t)\n\t{\n\t\tvec3 pos = rayPos + rayDir * resTreasure.w;\n\t\tt = resTreasure.w;\n\t\tcol = leavesCol * light(pos, resTreasure.xyz);\n\t}\n\t\n\t// Intersect leaves\n\tvec4 resLeaves = leaves(rayPos, rayDir);\n\tif (resLeaves.w > 0.0 && resLeaves.w < t)\n\t{\n\t\tvec3 pos = rayPos + rayDir * resLeaves.w;\n\t\tvec2 uv = (pos.xz - leavesPos.xz) * 0.3;\n\t\tfloat tex = texture(iChannel0, uv).r * 0.6 + 0.5;\n\t\t\n\t\tt = resLeaves.w;\n\t\tcol = leavesCol * lightLeaves(pos, resLeaves.xyz) * tex;\n\t}\n\t\n\t// Intersect trunk\n\tvec4 resTrunk = trunk(rayPos, rayDir);\n\tif (resTrunk.w > 0.0 && resTrunk.w < t)\n\t{\n\t\tt = resTrunk.w;\n\t\tcol = resTrunk.xyz;\n\t}\n\t\t\n\t// Intersect water\t\n\tvec4 resWater = intersectWater(rayPos, rayDir);\n\tif (resWater.w > 0.0 && resWater.w < t)\n\t{\n\t\tvec3 pos = rayPos + rayDir * resWater.w;\n\t\tfloat dist = t - resWater.w;\n\t\tvec3 n = bump(pos, rayDir);\n\t\t\n\t\tfloat ct = -min(dot(n,rayDir), 0.0);\n\t\tfloat fresnel = 0.9 - 0.9 * pow(1.0 - ct, 5.0);\n\t\t\n\t\tvec3 trans = col * exp(-dist * vec3(1.0, 0.7, 0.4) * 3.0);\n\t\tvec3 reflDir = normalize(reflect(rayDir, n));\n\t\tvec3 refl = sky(reflDir);\n\t\t\n\t\t#ifdef REFLECTIONS\n\t\tif (dot(pos, rayDir) < -2.0)\n\t\t\trefl = traceReflection(pos, reflDir).rgb;\n\t\t#endif\n\t\t\t\t\n\t\tt = resWater.t;\n\t\tcol = mix(refl, trans, fresnel);\n\t}\n\t\n\tif (t > 1e7) return sky(rayDir);\n\t\n\treturn col;\n}\n\n// Ray-generation\nvec3 camera(vec2 px)\n{\n\tvec2 rd = (px / iResolution.yy - vec2(iResolution.x/iResolution.y*0.5-0.5, 0.0)) * 2.0 - 1.0;\n\tfloat t = sin(iTime * 0.1) * 0.2;\n\tvec3 rayDir = normalize(vec3(rd.x, rd.y, 1.0));\n\tvec3 rayPos = vec3(0.0, 3.0, -18.0);\n\treturn trace(rayPos, rayDir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t#ifdef HEAVY_AA\n\t\tvec3 col = camera(fragCoord.xy+vec2(0.0,0.5))*0.25;\n\t\tcol += camera(fragCoord.xy+vec2(0.25,0.0))*0.25;\n\t\tcol += camera(fragCoord.xy+vec2(0.5,0.75))*0.25;\n\t\tcol += camera(fragCoord.xy+vec2(0.75,0.25))*0.25;\n\t#else\n\t\tvec3 col = camera(fragCoord.xy);\n\t\t#ifdef LIGHT_AA\n\t\t\tcol = col * 0.5 + camera(fragCoord.xy+vec2(0.5,0.5))*0.5;\n\t\t#endif\n\t#endif\n\t\n\t#ifdef TONEMAP\n\t// Optimized Haarm-Peter Duikerâ€™s curve\n\tvec3 x = max(vec3(0.0),col*exposure-0.004);\n\tcol = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n\t#else\n\tcol = pow(col, vec3(0.4545));\n\t#endif\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sf3RM","date":"1365092028","viewed":2211,"name":"Island","username":"vanburgler","description":"Island scene - water plane, leaves and sand are ray-traced while the tree trunk is ray-marched. Leaves are an intersection of two planes with a sphere. Try out the higher-quality levels. Turn off ragged leaves for a speed boost on slower GPUs.","likes":30,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","raytrace"],"hasliked":0,"parentid":"","parentname":""}}