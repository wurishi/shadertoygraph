{"ver":"0.1","info":{"id":"4dcSRB","date":"1459879271","viewed":369,"name":"Hello Voxel","username":"akohdr","description":"canonical 'hello world' for Terse Voxel viewer, as clean as I could make it.\n     (ok maybe tweaking SPHERE primitive to be time varying isn't that clean, looks cool :) )\n","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["voxel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// showing local voxel bounds helps vizualize what's going on\n//#define SHOW_BOUNDS\n\n// Timebase passed into viewer\n#define iTimebase 1.5*iTime\n\n// for demo we make voxel resolution a function of time\n#define RES (1.5 - (sin(.5*T)))\n\n// alternatively fix the resolution\n//#define RES 3.\n//#define RES 1.25\n\n// Cut/Paste begin ------------------------------------------------------------\n#define BOB_H 2.5*RES\n#define EYE_D 40.*RES\n#define MAX_RAY 250\n\n// goal is fast voxel based abstraction returning existence and colour(c) in spacetime(P)\nbool cVoxel(out vec4 c, const in vec4 P );\n\nbool VxViewer(out vec4 fc,             // fragColor\n         const in vec2 P,              // fragCoord\n         const in vec3 R,              // iResolution\n        const in float T ) {           // timebase\n    \n\tconst vec3 WORLD_OFFSET = vec3(0,0,0);\n    const vec4 B0 = vec4(.0,.0,.0,1.),\n               B1 = vec4(.6,.6,.6,1.),\n               B2 = vec4(.3,.3,.3,1.);\n    \n    vec2 t = vec2(sin(T), cos(T)),\n         l = P.xx / R.xx - .5;         // vec ops faster than single scalar\n    \n    vec3 r = vec3(l.y*t.y - .8*t.x, (P.y/R.y - .5)*R.y/R.x, .8*t.y + l.x*t.x),\n         o = t.xxy * vec3(EYE_D, BOB_H, -EYE_D),\n         h = length(r)/r,\n         q = sign(r),\n         f = floor(o),\n         d = abs(h),\n         s = d*(q*(f-o) + (.5*q) + .5),\n         m;\n    \n    for(int i=MAX_RAY; i>0; i--) {\n        vec4 spacetime = vec4(f + WORLD_OFFSET, T);\n\n        if(cVoxel(fc, spacetime)){\n            fc += m.x>0. ? B0 : m.y>0. ? B1 : B2;\n            return true; // early exit\n        }\n        \n        bvec3 a = lessThan(s,s.yzx),\n              b = lessThanEqual(s,s.zxy);\n              m = vec3(a.x && b.x, a.y && b.y, a.z && b.z);  //a && b\n                \n        f += m*q;\n        s += m*d;\n    }\n    return false;\n}\n// Cut/Paste end ------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // iphones apparently don't init to zero\n\n#define AB\n#ifdef AB\n    fragColor = vec4(0.);\n\tVxViewer(fragColor, \n             fragCoord,\n             iResolution,\n             iTimebase);\n#else\n\tif(!VxViewer(fragColor, \n             fragCoord,\n             iResolution,\n             iTimebase)) fragColor = vec4(0.);\n#endif\n}\n\n\n//#define SPHERE(p,c,r) length(p.xyz-c)<r\n\n// let your math sense go nuts!\n#define SPHERE(p,c,r) length(p.xyz-c)<(mod(T,20.)<7.?r:r*sin((tan(.1*T))*(.3*length(p.xxy))))\n//#define SPHERE(p,c,r) length(p.xyz-c)<r*sin((.3*length(p.xxy)))\n//#define SPHERE(p,c,r) length(p.xyz-c)<r*sin(8.*(.3*length(p.xxy)))\n\n// User supplied world state function\nbool cVoxel(out vec4 c,\t    // voxel colour (if exists return true)\n       const in vec4 P \t\t// P.xyz world coord,  P.w world time\n) {\n    c = vec4(0);\n    float T = P.w,\t\t    // timebase (T is used by RES macro)\n          res = RES,\n          rPlanet = 8.,\t\t// planet radius\n          rMoon = 3.;\t\t// moon radius\n\n    vec3 pPlanet = vec3(0),\n         pMoon = vec3(12.,0.,-6.);  // note: moon isn't moving viewer orbits origin\n\n    // adjust size/positions for voxel resolution\n    rPlanet *= res;\n    rMoon *= res;\n    pMoon *= res;\n        \n\t// hit test on planet\n    if (SPHERE(P, pPlanet, rPlanet)) {\n        // spacial colouring\n        c = vec4(.25+normalize(P.xyz),1.);\n        return true;\n    }\n\n    // hit test on moon\n    if (SPHERE(P, pMoon, rMoon)) {\n        // temporal colouring\n        c = vec4(.2+sin(T)*vec3(.7),1.);\n        return true;\n    }\n\n#ifdef SHOW_BOUNDS \n    // bounding markers (white positive direction  .rgb <=> .xyz)\n    const vec4 L = vec4(13.),\n               H = vec4(.5);\n    vec4 ap = abs(P); \n\tbvec4 b = lessThan(ap,L);\n    if(length(ap.xyz-L.xyz)<3. && (b.x&&b.y&&b.z)) c = H+.3*sign(P); //local corners\n#endif\n    \n \treturn c.w>0.;\n}\n","name":"Image","description":"","type":"image"}]}