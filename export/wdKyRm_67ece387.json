{"ver":"0.1","info":{"id":"wdKyRm","date":"1602519813","viewed":452,"name":"Customizable 3x3 Kernel Filter","username":"Dogemaster09","description":"Read the code comments.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["filters","blur","gaussian","kernel","customizable","3x3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis is a version of a 3x3 Gaussian kernel blur. I don't really feel like explaining it here, so here's a computerphile video that does it\nfor me. https://www.youtube.com/watch?v=C_zFhWdM4ic\nIt's fully modifiable, you can change the kernel values as much as you like. Right now it's boring because I have all of them set to 1, but\nI made a different version for the Sobel edge detector. That one is a lot less customizable and it's also slightly more complicated, so it\nwould take a bit of tweaking in this one to recreate the other. You can also tweak this to work with color, I just didn't really feel like it.\n*/\n\n//Color to BW\nfloat bw(sampler2D col, vec2 uv) {\n\treturn dot(texture(col, uv).xyz, vec3(1./3.));\n}\n\n//Pixel UV to normalized UV (just to clean up code, I know it's inefficient)\nvec2 nUv(vec2 uv) {\n\treturn uv/iResolution.xy;\n}\n\n//Kernel pixel UV values, don't change these\nvec2 kO[9] = vec2[9](vec2(-1.,1.), vec2(0.,1.), vec2(1.,1.),\n                     vec2(-1.,0.), vec2(0.,0.), vec2(1.,0.),\n                     vec2(-1.,-1.), vec2(0.,-1.), vec2(1.,-1.));\n//Kernel multiplication values, arranged in the correct grid\n//Feel free to change these\nfloat kM[9] = float[9](1., 1., 1.,\n                       1., 1., 1.,\n                       1., 1., 1.);\n\n//Kernel math\nfloat kernelFilter(vec2 pUv) {\n\tfloat r = 0.;\n\tfor(int i = 0; i < 9; i++){\n  \t\tr += bw(iChannel0, nUv(pUv + kO[i])) * kM[i];\n\t}\n    return r/9.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pUv = fragCoord;\n    float filtered = kernelFilter(fragCoord);\n\tfragColor = vec4(filtered);\n}","name":"Image","description":"","type":"image"}]}