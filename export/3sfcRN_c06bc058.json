{"ver":"0.1","info":{"id":"3sfcRN","date":"1584222821","viewed":156,"name":"Ray tracing bounced spheres","username":"imod","description":"My first try create something on shadertoy.\nRay traced spheres.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","phong","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//raytraced bounce shperes\n//my first try create something on shadertoy\n//twitter: @imod\n//\n//https://twitter.com/imod74\n\n#define shpere_count 8\n#define full_shpere_count 64\n#define lights_count 3\n#define max_intresections 8\n\n#define PI  3.1415926535897932384626433832795\n#define PI_half  1.57079632679489661923\n\nfloat sinc(float x)\n{\n    return sin(x)/x;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nstruct material\n{\n\tvec3 color;\n\tfloat highlight_intencity;\n    float highlight_hard;\n    float reflection;\n    float refraction;\n    float refraction_int;\n    \n};\n\nmaterial create_material(vec3 color, float highlight_intencity, float highlight_hard, float reflection, float refraction, float refraction_int)\n{\n    material new_material;\n    new_material.color = color;\n    new_material.highlight_intencity = highlight_intencity;\n    new_material.highlight_hard = highlight_hard;\n    new_material.reflection = reflection;\n    new_material.refraction = refraction;\n    new_material.refraction_int = refraction_int;\n    \n    return new_material;\n}\n\n\nstruct ray\n{\n\tvec3 position;\n\tvec3 dirrection;\n};\n\nstruct sphere_shape\n{\n    vec3 position;\n\tfloat radius;\n    material cur_material;\n};\n\nsphere_shape create_shpere(vec3 set_position, float set_radius, material set_material)\n{\n    sphere_shape new_sphere;\n    new_sphere.position = set_position;\n    new_sphere.radius = set_radius;\n    new_sphere.cur_material = set_material;\n    return new_sphere;\n}\n\nvec3 shpere_get_normal(sphere_shape shpere, vec3 position)\n{\n    return normalize(position - shpere.position);\n}\n\nvec3 ray_sphere_intersect(vec3 ray_start, vec3 ray_dir, sphere_shape cur_shpere)\n{\n    vec3 distance_point = (ray_dir * dot(ray_dir, cur_shpere.position - ray_start)) + ray_start;\n\tfloat distance_to_ray = length(cur_shpere.position - distance_point);\n    \n    if((distance_to_ray > cur_shpere.radius) || (dot(distance_point - ray_start, ray_dir) < 0.0))\n    {\n        return vec3(0,0,0);\n    }\n\n    float inner_line_length = sqrt((cur_shpere.radius*cur_shpere.radius) - (distance_to_ray*distance_to_ray));\n\n\tvec3 intersect_point = distance_point - (ray_dir * inner_line_length);\n\n    return intersect_point;\n}\n\nstruct light\n{\n\tvec3 position;\n\tvec3 color;\n    float intension;\n    bool shadows;\n};\n    \n    \nlight create_light(vec3 position, vec3 color, float intension, bool shadows)\n{\n    light new_light;\n    new_light.position = position;\n    new_light.color = color;\n    new_light.intension = intension;\n    new_light.shadows = shadows;\n    return new_light;\n}\n\nstruct camera\n{\n    vec3 position;\n    vec3 rotation;\n    float fov;\n};\n\nstruct intresection\n{\n    vec3 position;\n    vec3 normal;\n    material cur_material;\n    float distance_far;\n};\n    \nvec3 ray_plane_intersect(vec3 ray_start, vec3 ray_dir)\n{\n    \n  if ( ray_dir.z > 0.0)\n  {\n    return vec3(0,0,0);\n  }\n\n  float t = ((ray_start.x + ray_dir.x) - ray_start.x)/ray_dir.x;\n  float intresection_x = ray_start.x - ((ray_start.z*ray_dir.x)/ray_dir.z);\n  float intresection_y = ray_start.y - ((ray_start.z*ray_dir.y)/ray_dir.z);\n  return vec3(intresection_x, intresection_y, 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5);\n\tuv.x = uv.x*(iResolution.x/iResolution.y);\n    \n    camera global_camera;\n    global_camera.position = vec3(-15,0,5.5);\n    global_camera.rotation = vec3(1,0,0);\n    float new_time = sin(iTime*4.0+PI_half)*cos(2.0*iTime);\n    float new_time2 = sin(iTime*2.0)*cos(8.0*iTime+PI_half);\n    vec4 new_cam_rotation = rotationMatrix(vec3(0,0,1), new_time/128.0)*vec4(global_camera.rotation,1.0);\n    new_cam_rotation = rotationMatrix(vec3(0,1,0), new_time2/128.0)*new_cam_rotation;\n    global_camera.rotation = new_cam_rotation.xyz;\n    //sin(x)*cos(2*x)\n    global_camera.fov;\n     \n    material bacground_mat = create_material(vec3(0,0,0), 0.5, 100.0, 0.0, 0.0, 0.0);\n    material test_mat = create_material(vec3(1,1,1), 0.5, 100.0, 0.0, 0.0, 0.0);\n    \n    //intresection prepare\n    sphere_shape shapes_array[full_shpere_count];\n    \n    intresection base_intresection;\n    base_intresection.distance_far = 999999999.0;\n    base_intresection.cur_material = bacground_mat;\n    base_intresection.position = vec3(1,0,0) * 100.0;\n    base_intresection.normal = normalize(vec3(1,0,0));\n    \n    intresection intresection_array[max_intresections];\n    for(int i=0;i<max_intresections;i++)\n    {\n        intresection_array[i] = base_intresection;\n\n    }\n    int current_intresection = 0;\n    \n    //lights create\n    \n    light lights_array[lights_count];\n    lights_array[0] = create_light(vec3(sin(iTime)*15.0,cos(iTime)*15.0,20.0), vec3(0.5,0.75,1), 0.5, true);\n    lights_array[1] = create_light(vec3(sin(iTime+PI)*15.0,cos(iTime+PI)*15.0,20.0), vec3(1,0.5,0.6), 0.5, true);\n    lights_array[2] = create_light(vec3(0,0,200.0), vec3(0.8,0.8,1.0), 0.25, true);\n    //lights_array[3] = create_light(vec3(-20,0,10), vec3(1.0,1.0,1.0), 0.5, false);\n    \n    //spheres create\n    float circle_diameter = 2.5;\n  \tfloat shpere_count_float = (PI*2.0)/float(shpere_count);\n    circle_diameter = (cos(iTime*4.0) + cos(iTime*8.0 + PI/1.6) + cos(iTime*8.0 - PI/1.6))+3.0;\n    \n    float sphere_radius_din =  ((cos(iTime*4.0) + cos(iTime*8.0 + PI/1.6) + cos(iTime*8.0 - PI/1.6))+3.5)/4.5;\n    \n    \n    for(int i=0;i<shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float*float(i))*circle_diameter,cos(shpere_count_float*float(i))*circle_diameter,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[i].position = new_shpere_pos.xyz;\n        shapes_array[i].radius = sphere_radius_din;\n        shapes_array[i].cur_material = test_mat;\n        //vec3 new_shpere_pos = vec3(sin(PI*2.0),1,1);\n\t\t//local circle_position = math.vector3d.create(math.sin(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, math.cos(((math.pi*2)/circle_shpere_count)*i)*circle_diameter, 0)\n\t}\n    \n    float circle_diameter_02 = 2.5;\n  \tfloat shpere_count_float_02 = (PI*2.0)/float(shpere_count);\n    circle_diameter_02 = ((cos(iTime*4.0 - 0.5) + cos(iTime*8.0 + PI/1.6 - 0.5) + cos(iTime*8.0 - PI/1.6 - 0.5))+3.0)/1.5;\n    \n    float sphere_radius_din_02 =  ((cos(iTime*4.0) + cos(iTime*8.0 + PI/1.6) + cos(iTime*8.0 - PI/1.6))+2.75)/4.5;\n    \n    \n    for(int i=0;i<shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_02*float(i) + PI/8.0)*circle_diameter_02,cos(shpere_count_float_02*float(i)+ PI/8.0)*circle_diameter_02,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[8+i].position = new_shpere_pos.xyz;\n        shapes_array[8+i].radius = sphere_radius_din_02;\n        shapes_array[8+i].cur_material = test_mat;\n\t}\n    \n    float circle_diameter_03 = 2.5;\n  \tfloat shpere_count_float_03 = (PI*2.0)/float(shpere_count);\n    circle_diameter_03 = ((cos(iTime*4.0 - 1.0) + cos(iTime*8.0 + PI/1.6 - 1.0) + cos(iTime*8.0 - PI/1.6 - 1.0))+2.5)/2.0;\n    \n    float sphere_radius_din_03 =  ((cos(iTime*4.0) + cos(iTime*8.0 + PI/1.6) + cos(iTime*8.0 - PI/1.6))+2.0)/5.0;\n    \n    \n    for(int i=0;i<shpere_count;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_03*float(i))*circle_diameter_03,cos(shpere_count_float_03*float(i))*circle_diameter_03,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        new_shpere_pos.z =new_shpere_pos.z + 5.0;\n        \n        shapes_array[16+i].position = new_shpere_pos.xyz;\n        shapes_array[16+i].radius = sphere_radius_din_03;\n        shapes_array[16+i].cur_material = test_mat;\n\t}\n    \n    \n    float circle_diameter_04 = 18.0;\n  \tfloat shpere_count_float_04 = (PI*2.0)/float(20);\n    \n    float sphere_radius_din_04 =  2.0;\n    \n    \n    for(int i=0;i<20;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_04*float(i) + 0.0)*circle_diameter_04,cos(shpere_count_float_04*float(i) + 0.0)*circle_diameter_04,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        //new_shpere_pos.z =new_shpere_pos.z + 5.0 + cos(acos(new_shpere_pos.x/length(new_shpere_pos))*4.0 + iTime)*2.0 + (1.0/(5.0*cos(iTime*4.0)-6.0))*10.0 + 10.0;\n        new_shpere_pos.z =new_shpere_pos.z + ((10.0/(5.0*cos(iTime*4.0 + sin(asin(new_shpere_pos.y/length(new_shpere_pos)))*5.0 )-7.0))+5.0)*4.0+1.0;\n        //new_shpere_pos.z =new_shpere_pos.z + 5.0 + cos(iTime*2.0);\n        \n        shapes_array[24+i].position = new_shpere_pos.xyz;\n        shapes_array[24+i].radius = sphere_radius_din_04;\n        shapes_array[24+i].cur_material = test_mat;\n\t}\n    \n    float circle_diameter_05 = 55.0;\n  \tfloat shpere_count_float_05 = (PI*2.0)/float(20);\n    \n    float sphere_radius_din_05 =  2.0;\n    \n    \n    for(int i=0;i<20;i++)\n    {\n\n        vec4 new_shpere_pos = vec4(sin(shpere_count_float_05*float(i) + 0.0)*circle_diameter_05,cos(shpere_count_float_05*float(i) + 0.0)*circle_diameter_05,0.0, 1.0);\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), cos(iTime))*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(0,1,0), iTime)*new_shpere_pos;\n        //new_shpere_pos = rotationMatrix(vec3(1,0,0), iTime)*new_shpere_pos;\n        //new_shpere_pos.z =new_shpere_pos.z + 5.0 + cos(acos(new_shpere_pos.x/length(new_shpere_pos))*4.0 + iTime)*2.0 + (1.0/(5.0*cos(iTime*4.0)-6.0))*10.0 + 10.0;\n        new_shpere_pos.z =new_shpere_pos.z + ((10.0/(5.0*cos(iTime*4.0 + cos(acos(new_shpere_pos.x/length(new_shpere_pos)))*5.0 )-7.0))+5.0)*4.0+1.0;\n        //new_shpere_pos.z =new_shpere_pos.z + 5.0 + cos(iTime*2.0);\n        \n        shapes_array[44+i].position = new_shpere_pos.xyz;\n        shapes_array[44+i].radius = sphere_radius_din_05;\n        shapes_array[44+i].cur_material = test_mat;\n        shapes_array[44+i].cur_material.color = vec3(0.2,0.2,0.2);\n\t}\n    \n\n    vec3 ray_start = global_camera.position;\n    vec4 ray_dir = rotationMatrix(vec3(0,0,1), uv.x)*vec4(global_camera.rotation,1.0);\n    ray_dir = rotationMatrix(vec3(0,1,0), uv.y)*vec4(ray_dir);\n    bool isIntersected = false;\n    \n    for(int i=0;i<full_shpere_count;i++)\n    {\n        vec3 cur_inter = ray_sphere_intersect(ray_start, ray_dir.xyz, shapes_array[i]);\n\t\t\n        \n        if(cur_inter != vec3(0,0,0))\n        {\n            isIntersected = true;\n            current_intresection++;\n            intresection_array[current_intresection].position = cur_inter;\n            intresection_array[current_intresection].normal = shpere_get_normal(shapes_array[i], cur_inter); \n            intresection_array[current_intresection].cur_material = shapes_array[i].cur_material;\n            intresection_array[current_intresection].distance_far = distance(global_camera.position, cur_inter);\n        }\n\t}\n\n    vec3 plane_intr_point = ray_plane_intersect(ray_start, ray_dir.xyz);\n    if(plane_intr_point != vec3(0,0,0))\n    {\n        isIntersected = true;\n    \tcurrent_intresection++;\n    \tintresection_array[current_intresection].position = plane_intr_point;\n    \tintresection_array[current_intresection].normal = vec3(0,0,1); \n    \tintresection_array[current_intresection].cur_material = test_mat;\n    \tintresection_array[current_intresection].distance_far = distance(global_camera.position, plane_intr_point);\n    }\n\n    //sort intersections\n    bool isSorted = false;\n    do \n    {\n        isSorted = true;\n        for(int i=0;i<max_intresections-1;i++)\n    \t{\n        \tif (intresection_array[i].distance_far > intresection_array[i+1].distance_far)\n            {\n                intresection intresection_tmp = intresection_array[i];\n                intresection_array[i] = intresection_array[i+1];\n                intresection_array[i+1] = intresection_tmp;\n                isSorted = false;\n            }\n    \t}\n    }\n    while(!isSorted);\n    \n    \n    vec3 col = vec3(0,0,0);\n    \n    if(isIntersected)\n    {\n        for(int i=0;i<lights_count;i++)\n        {\n            vec3 light_dir = normalize(lights_array[i].position - intresection_array[0].position);\n            float light_intencity = dot(light_dir,intresection_array[0].normal);\n\n            bool isShadow = false;\n\n                for(int i=0;i<full_shpere_count;i++)\n                {\n                    vec3 cur_inter = ray_sphere_intersect(intresection_array[0].position + light_dir*0.01, light_dir, shapes_array[i]);\n                    if(cur_inter != vec3(0,0,0))\n                    {\n                        isShadow = true;\n                    }\n                }\n\n\n            if(!isShadow)\n            {\n                col = col + intresection_array[0].cur_material.color*light_intencity*lights_array[i].intension*lights_array[i].color;\n\n                vec3 refl_vec = reflect(light_dir ,intresection_array[0].normal);\n                float phong_highlight = dot(refl_vec, ray_dir.xyz);\n                phong_highlight =  pow(clamp(phong_highlight, 0.0, 1.0),10.0)*0.5;\n                col = col + phong_highlight;\n            }\n        }\n    }\n    col = clamp(col, vec3(0,0,0), vec3(1,1,1));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}