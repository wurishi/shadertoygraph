{"ver":"0.1","info":{"id":"ddsGDs","date":"1667064540","viewed":107,"name":"Sphere but without ray marching","username":"travertexs","description":"To learn another way that can render the scene.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"ldS3DW","parentname":"Ray tracing sphere example"},"renderpass":[{"inputs":[],"outputs":[],"code":"#define saturate(data) clamp(data, 0.0, 1.0)\n#define PI 3.14159265\n\nvec3 sun_dir = normalize(vec3(1.0, 0.75, 0.0));\nvec3 up_dir  = vec3(0.0, 1.0, 0.0);\n\n\n\n\nvec2 GetClipCoord(in vec2 coord, in vec2 aspect_ratio)\n{\n    coord = (coord / iResolution.xy) * 2.0 - 1.0;\n    return coord * aspect_ratio;\n}\n\nvec3 GetCamPos(in vec3 ray_orig, in vec2 view_coord, in vec2 mouse_coord, out vec3 ray_dir)\n{\n    mouse_coord.x *= PI * 2.0;\n    mouse_coord.y  = clamp(abs(mouse_coord.y) * PI * 0.5, 0.1, 0.999);\n    \n    vec3 cam_pos = vec3(\n        sin(mouse_coord.x) * cos(mouse_coord.y),\n        sin(mouse_coord.y),\n        cos(mouse_coord.x) * cos(mouse_coord.y)\n    );\n    \n    vec3 cam_forward = normalize(-cam_pos);\n    vec3 cam_right   = cross(up_dir, cam_forward);\n    vec3 cam_up      = cross(cam_forward, cam_right);\n    \n    cam_pos.xz *= 2.0;\n    cam_pos.y  += 1.0;\n    \n    ray_dir = normalize(\n        cam_right * view_coord.x +\n        cam_up    * view_coord.y +\n        cam_forward\n    );\n    \n    return cam_pos;\n}\n\nfloat ground(\n    in  vec3  ray_orig      ,\n    in  vec3  ray_dir       ,\n    in  float height        ,\n    in  float ray_length_max,\n    out float is_ground\n)\n{\n    float ground_dist = ray_orig.y - height;\n    \n    float cos_theta = dot(-up_dir, ray_dir);\n    is_ground = step(0.0, cos_theta);\n    \n    float ray_length = ground_dist / cos_theta;\n    \n    return mix(ray_length_max, ray_length, is_ground);\n}\n\nfloat sphere(\n    in  vec3  ray_orig      ,\n    in  vec3  ray_dir       ,\n    in  vec3  sphere_pos    ,\n    in  float radius        ,\n    in  float ray_length_max,\n    out float is_sphere\n)\n{\n    // Get the distance between ray origin and sphere edge.\n    // Tips: edge_dist^2 + radius^2 = centre_dist^2\n\tvec3  centre_ray    = sphere_pos - ray_orig;\n\tfloat edge_dist_squ = dot(centre_ray, centre_ray) - radius * radius;\n\n    // Assume a sphere, its centre is ray_orig and its radius is centre_dist.\n    // Cast the distance between ray origin and sphere surface to centre ray direction.\n    // Tips: cos_theta        = ray_dir * centre_ray_dir\n    //       centre_cast_dist = centre_dist * cos_theta\n\tfloat centre_cast_dist = dot(ray_dir, centre_ray);\n\n\tfloat d = centre_cast_dist * centre_cast_dist - edge_dist_squ;\n\tfloat ray_length = centre_cast_dist - sqrt(d);\n\tis_sphere = step(0.0, min(ray_length, d));\n\n\treturn mix(ray_length_max, ray_length, is_sphere);\n}\n\nfloat Map(vec3 ray_orig, vec3 ray_dir, out vec3 world_norm, in float ray_length_max)\n{\n    float map;\n    world_norm = vec3(0.0);\n    \n    // Ground\n    float is_ground;\n    float ground_height = 0.0;\n    float ground = ground(ray_orig, ray_dir, ground_height, ray_length_max, is_ground);\n    map        = ground;\n    world_norm = up_dir * is_ground;\n    \n    // Sphere\n    float sphere_radius = 0.5;\n    vec3  sphere_pos    = vec3(0.0, 0.0, 0.0);\n          sphere_pos.y  = sphere_radius + ground_height;\n\n    sphere_pos.y += pow(abs(sin(mod(iTime, 1.0) * PI * 2.0)), 0.75) * 0.25;\n\n    float is_sphere;\n    float sphere = sphere(\n        ray_orig,\n        ray_dir,\n        sphere_pos,\n        sphere_radius,\n        ray_length_max,\n        is_sphere\n    );\n    map = min(map, sphere);\n    world_norm = mix(\n        world_norm,\n        normalize((ray_orig + ray_dir * map) - sphere_pos),\n        step(0.0, map - sphere)\n    );\n\n    // Divide sky\n    map = mix(-1.0, map, max(is_ground, is_sphere));\n\n    return map;\n}\n\nvec3 GetSky(in vec3 ray_dir)\n{\n    vec3 colour = vec3(0.0);\n\n    float light_theta = 1.0 - saturate(dot(ray_dir, up_dir));\n    \n    vec3 sky_colour = normalize(vec3(0.125, 0.375, 1.0));\n    colour = sky_colour * (light_theta * 0.875 + 0.125) * 0.75;\n    \n    // Horizon\n    vec3 horizon_colour = normalize(vec3(0.8, 0.9, 1.0));\n    colour += horizon_colour * pow(light_theta, 6.0) * 1.25;\n\n    // Sun\n    float sun_radius = 0.001;\n          sun_radius = 1.0 - sun_radius;\n    float sun = saturate(dot(sun_dir, ray_dir));\n    colour += smoothstep(sun_radius - 0.0001, sun_radius + 0.0001, sun);\n\n    // Sun glow\n    float sun_glow_radius = 0.075;\n          sun_glow_radius = 1.0 - sun_glow_radius;\n    colour += pow(smoothstep(sun_glow_radius - 0.1, sun_glow_radius + 0.1, sun), 8.0);\n\n    return colour;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Calculate coordinates.\n    vec2 aspect_ratio = max(iResolution.xy / iResolution.yx, vec2(1.0));\n    vec2 view_coord  = GetClipCoord(fragCoord, aspect_ratio);\n    vec2 mouse_coord = GetClipCoord(iMouse.xy, aspect_ratio);\n\n    vec3 ray_orig = vec3(0.0, 0.0, 1.0);\n    vec3 ray_dir  = normalize(vec3(view_coord, -1.0));\n    \n    vec3 cam_pos = GetCamPos(ray_orig, view_coord, mouse_coord, ray_dir);\n\n\n    vec3 world_norm;\n    float ray_length_max = 1000.0;\n    float ray_length = Map(cam_pos, ray_dir, world_norm, ray_length_max);\n\n    float view_depth;\n    vec3 colour = vec3(0.0);\n    if(ray_length > 0.0)\n    {\n        view_depth = ray_length / ray_length_max;\n        vec3 world_pos  = cam_pos + ray_dir * ray_length;\n\n        // Sun light\n        vec3  temp;\n        vec3  sun_colour = normalize(vec3(1.0, 0.95, 0.9));\n        float sun_light  = saturate(dot(world_norm, sun_dir));\n              sun_light *= step(Map(world_pos, sun_dir, temp, ray_length_max), 0.0);\n        colour += sun_colour * sun_light * 1.625;\n\n        // Env light\n        vec3  env_colour = normalize(vec3(0.5, 0.75, 1.0));\n        float env_light  = saturate(dot(world_norm, up_dir) * 0.5 + 0.5) * 0.3 + 0.7;\n        colour += env_colour * pow(env_light, 2.0) * 0.25;\n    }\n    else\n    {\n        view_depth = 1.0;\n        \n        // Sky\n        colour += GetSky(ray_dir);\n    }\n    \n    // Fog\n    vec3 fog_colour = normalize(vec3(0.2, 0.5, 1.0));\n    colour += fog_colour * sqrt(view_depth * ray_length_max * 0.004) * 0.45;\n \n\t//ray_dir = reflect(ray_dir, world_norm);\n\t//vec3 reflect_colour = GetSky(ray_dir);\n    \n    //colour = mix(colour, reflect_colour, step(0.0, map));\n    colour = pow(colour, vec3(1.0 / 2.2));\n    \n\tfragColor = vec4(colour, 1.0);\n    //fragColor = vec4(vec3(t * 0.1), 1.0);\n}","name":"Image","description":"","type":"image"}]}