{"ver":"0.1","info":{"id":"tlByRc","date":"1594943112","viewed":448,"name":"Connected Dots","username":"PinetreeDev","description":"connected dots with a crt effect.\nThanks to everyone in the comments for the discussion and help about the crt effect.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["crt","dots","hypnotizing","relaxing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S smoothstep\n#define T (iTime)\n\n#define STRIPES_AMOUNT 435.2\n\nfloat DistanceLine(vec2 p, vec2 a, vec2 b)\n{\n \tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return length(pa - ba*t);\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n\tfloat d = DistanceLine(p, a, b);\n    float m = S(.01, .0, d - .001);\n    \n    // if the length of the line segment is bigger han 1.2 = invisible\n    // .8 above fades in\n    m *= S(1.2, .8, length(a - b));\n    return m;\n}\n\nfloat Rnd(vec2 p)\n{\n    p = fract(p * vec2(284.4, 931.5));\n    p += dot(p, p + 24.5);\n    \n    return fract(p.x * p.y);\n}\n\nvec2 RndPoint(vec2 p)\n{\n    // X coordinate\n\tfloat n = Rnd(p);\n    // X & Y\n    return vec2(n, Rnd(p + n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    // Get a noise x, y value\n    vec2 n = RndPoint(id + offset) * T;\n    \n    return offset + sin(n) * .4;\n}\n\nfloat Dots(vec2 uv)\n{\n   \tvec2 grid = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    float m = 0.0;\n\tvec2 p[9];\n    \n    int i = 0;\n    for(float y= -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x<= 1.0; x++)\n        {\n        \tp[i++] = GetPos(id, vec2(x,y)); \n        }\n    }\n    \n    // Think of it as a matrix\n    // 0 1 2\n    // 3 4 5\n    // 6 7 8\n    for(int i =0; i<9; i++)\n    {\n    \tm += Line(grid, p[4], p[i]);\n        \n        vec2 j = (p[i] - grid) * 20.0;\n        float sparkle = 1./dot(j, j);\n        m += sparkle;\n    }\n    // Then we connect the 4 missing connections from this group\n    m += Line(grid, p[1], p[3]);\n    m += Line(grid, p[1], p[5]);\n    m += Line(grid, p[5], p[7]);\n    m += Line(grid, p[7], p[3]); \n\t\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // Thanks jaszunio15 for the help in the crt effect\n    vec2 uv = ((fragCoord - mod(fragCoord, vec2(3,4))) - .5*iResolution.xy)/iResolution.y;\n\n\tuv *= .5;\n\tfloat m = .0;    \n    vec2 grid = fract(uv) - .5;\n\t\n    // 4 layers of dots\n    for (float i = .0; i < 1.; i += 1./3.)\n    {\n        float z = fract(i + T * .01);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0., .2, z) * S(1., .6, z);\n        m += Dots(uv * size + i * 50.) * fade;\n    }\n    vec3 col = vec3(m);\n\t//col.rg = id * .2;\n    vec3 base = sin(T * vec3(.45, .123, .542)) * .4 + .6;\n    col *= base;\n    //if (grid.x > .48 || grid.y > .48) col = vec3(1.0, 0.0, 0.0);\n    \n    // Postprocess crt effect (is there a way to do this without the if statements?)\n    //int reminder = int(fragCoord.x) % 3;\n\t//if (reminder == 0) col.gb *= 0.0;\n\t//else if (reminder == 1) col.rb *= 0.0;\t\n\t//else col.rg *= 0.0;\n        \n\t//if (int(fragCoord.y) % 4 == 0) col *= 0.0;\n    // same thing but without if statements\n    col *= step(0.9, fract((fragCoord.x + vec3(0.499, 1.499, 2.499)) * 0.3333));\n\n    // ----------------------------------------\n        \n    //col = pow(col, vec3(.4545));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}