{"ver":"0.1","info":{"id":"3sVSzW","date":"1574063755","viewed":341,"name":"Raytracing-Test","username":"sapporo_dynamite","description":"My First ray tracing\nprogram may be wrong..","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","test","ray","sphere","camera","cubemap","plane","checkers","srgbtoliner","intersectionsphere","intersectionplane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tRaytracing-Test\n\n\tImplements Ray trace processing ad-hoc to understand the contents\n\n\tauthor:\n\tsapporo_dynamite/2019 \n\n\tLicense :\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n　　Reference：\n    norishige chiba (1991) Cによる　CGレイトレーシング サイエンス社\n\n\tURL:\n\tproject-asura Linear Lighting\n\thttp://www.project-asura.com/program/d3d11/d3d11_003.html\n\n\tproject-asura 正規化Lambert\n\thttp://www.project-asura.com/program/d3d11/d3d11_004.html\n\n\t@doxas WebGL と GLSL で気軽にレイトレーシングに挑戦してみよう！\n\thttps://qiita.com/doxas/items/477fda867da467116f8d\n*/\n\n/*\n\n2019/11/19   \n  1.0.1 → 1.0.2\n    ・fix color space \n\n2019/11/19   \n  1.0.0 → 1.0.1\n    ・床に反射した球のライティングが正しくない部分を修正\n    ・fix bug\n\n2019/11/18   \n  0.0.0 → 1.0.0\n    ・1st release\n\t・内容把握の為 トレース処理を アドホック で 実装\n\n2019/11/16   \n  0.0.0 → 0.0.0\n    ・start\n\t・作業開始\n*/\n\nstruct Ray\n{\n    vec3 dir;\n    vec3 pos;\n};\n\nstruct Sphere\n{\n    vec3 pos;\n    float r;\n    vec3 col;\n};\n\nstruct Plane\n{\n    vec3 pos;\n    vec3 n;\n    vec3 col;\n};\n    \nconst float PI = acos(-1.);\n\nbool InterSectionPlane( in Plane plane, in Ray ray, out vec3 outP, out vec3 outN)\n{\n    float d = dot(-ray.dir, plane.n);\n    if(d > 0.0){\n     float t = dot(ray.pos - plane.pos, plane.n)/d;\n     outP = ray.pos + t * ray.dir;\n     outN = plane.n;\n     return t > 0.0;\n    }\n    return false;\n}\n\nbool InterSectionSphere( in Sphere sphere, in Ray ray, out vec3 outP, out vec3 outN)\n{\n    vec3  a = ray.pos - sphere.pos;\n    float b = dot(ray.dir, a);\n    float c = dot(a, a);\n    float d = ( b * b - c + (sphere.r * sphere.r) );\n    \n    if(d > 0.0) \n    {\n        float t = -b - sqrt(d);\n        outP = ray.pos + t * ray.dir;\n        outN = normalize(outP - sphere.pos);\n        return t > 0.0;\n    }\n    return false;\n}\n    \nvec3 srgbTexture(in vec3 color)\n{\n    return pow(max(color, vec3(0.)), vec3(2.2)); \n}\n\nvec3 Color(in vec3 color)\n{\n    return pow(max(color * 3.0, vec3(0.)), vec3(1.0)); \n}\n\nvec3 finalColor( in vec3 color)\n{\n    return pow(max(color, vec3(0.)), vec3(1./2.2));  \n}\n\nfloat checkers( in vec3 p )\n{\n#if 1    \n    float size = 4.0;\n    vec2 value = vec2(mod(floor(p.x/size),2.0),mod(floor(p.z/size),2.0));\n    return mod( value.x + value.y, 2.0 );\n#else    \n    vec3 q = floor(p);\n    return mod( q.x+q.y+q.z, 2.0 );            // xor pattern\n#endif    \n}\n\nvec3 shade(vec3 lDir, vec3 n, vec3 albedo, vec3 cDir, float power)\n{\n  vec3  L = normalize(lDir);\n  float kd = max(dot(-L, n), 0.0);\n  vec3 diffuse = kd * Color(albedo) * (1.0/PI);\n  vec3 R = normalize ( reflect(cDir, n) );\n  float ks = pow( max ( dot( -L, R ), 0.0 ), power ) * ( ( power + 2.0 )/ ( 2.0 * PI ) );\n  vec3 specular = ks * Color(vec3(1));\n  return diffuse + specular;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 px = ( -iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    \n    // light\n    vec3 lPos = vec3(-100.0, -100.0, 0.0);\n    vec3 lDir = normalize(lPos - vec3(0));\n    \n    // camera\n    vec3 cPos  = vec3( 10. * sin(iTime*0.2),3, 5.*cos(iTime*0.2) );    \n    vec3 cTarget = vec3(0,2.0,0.1);\n    vec3 cDir  = normalize( cTarget - cPos );\n    vec3 cSide = cross( cDir, vec3( 0.0, 1.0 ,0.0 ) );\n    vec3 cUp   = cross( cSide, cDir );\n    float targetDepth = 1.3;\n    \n    // ray dir\n    vec3 raydir = normalize( cSide * px.x + cUp * px.y + cDir * targetDepth );\n    \n    // ray\n    Ray ray;\n    ray.pos = cPos;\n    ray.dir = raydir;\n    \n    // sphere\n    Sphere sphere;\n    sphere.pos = vec3(0.,2.0,-0.);\n    sphere.r = 2.0;\n    sphere.col = vec3(1.,0.,0.);\n   \n    // plane\n    Plane plane;\n    plane.pos = vec3(0.,-0.01,0.);\n    plane.n = vec3(0.,1.,0.);\n    plane.col = vec3(0.0, 0., 0.0);\n    \n    vec3 col = vec3(0);\n    vec3 hitN  = vec3(0);\n    vec3 hitPos = vec3(0);\n    \n    // InterSection Sphere\n    if( InterSectionSphere(sphere, ray, hitPos, hitN ) ) \n    {\n        // shade\n        col = shade(lDir, hitN, sphere.col, ray.dir, 100.);\n        \n        // Trace ray\n        Ray traceRay;\n        traceRay.pos = hitPos;\n        traceRay.dir = normalize (reflect(ray.dir, hitN) );\n        \n        // InterSection Plane\n        if(InterSectionPlane(plane, traceRay, hitPos, hitN ))\n        {\n           // shadow ray\n           Ray shadowRay;\n           shadowRay.pos = hitPos;\n           shadowRay.dir = normalize(hitPos - lPos);\n           float shadow = 1.;\n            \n           // 床の反射\n           // reflection plane\n           vec3 color = shade(lDir, hitN, checkers(hitPos) > 0.0 ? plane.col : vec3(1), traceRay.dir, 100.) * 0.05;\n            \n           // shadow sphere\n           if(InterSectionSphere(sphere, shadowRay, hitPos, hitN))\n           {\n               shadow = 0.5;\n           }\n            \n           col += color * shadow; \n        }\n        else {\n            // 空の反射\n            // reflection skybox\n            col += srgbTexture( texture(iChannel0, traceRay.dir ).rgb ) * 0.01;\n        }\n    }\n    else if(InterSectionPlane(plane, ray, hitPos, hitN ))\n    {\n        // color\n        vec3 color = shade(lDir, hitN, checkers(hitPos) > 0.0 ? plane.col : vec3(1), ray.dir, 100.);\n        \n        // Trace ray\n        Ray traceRay;\n        traceRay.pos = hitPos;\n        traceRay.dir = normalize (reflect(ray.dir, hitN) );\n        \n        // shadow ray\n        Ray shadowRay;\n        shadowRay.pos = hitPos;\n        shadowRay.dir = normalize(hitPos - lPos);\n        float shadow = 1.;\n        \n        // check shadow\n        if(InterSectionSphere(sphere, shadowRay, hitPos, hitN))\n        {\n          shadow = 0.3;\n        }\n        \n        // InterSection Sphere\n        if( InterSectionSphere(sphere, traceRay, hitPos, hitN ) ) \n        {\n           // 球の反射\n           // reflection sphere\n           color += shade(lDir, hitN, sphere.col, traceRay.dir, 100.) * 0.05; \n            \n           traceRay.pos = hitPos;\n           traceRay.dir = normalize (reflect(traceRay.dir, hitN) );\n            \n           // 床の反射\n           if(InterSectionPlane(plane, traceRay, hitPos, hitN))\n           {\n           \t   color += shade(lDir, hitN, checkers(hitPos) > 0.0 ? plane.col : vec3(1), traceRay.dir, 100.) * 0.01;\n           }else {\n               // 空の反射\n               // reflection skybox\n               color += srgbTexture( texture(iChannel0, traceRay.dir ).rgb ) * 0.005;\n           }\n        }\n        else {\n           // 空の反射\n           // reflection skybox\n           color += srgbTexture( texture(iChannel0, traceRay.dir ).rgb ) * 0.05;   \n        }\n        col = color * shadow;\n    }\n    else {\n        // なにも判定がない場合は\n        // Not InterSection ..\n        \n        // 空の反射\n        // reflection skybox\n        col = srgbTexture( texture(iChannel0, ray.dir ).rgb );\n    }\n    \n    // Output to screen\n    fragColor = vec4(finalColor(col), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}