{"ver":"0.1","info":{"id":"3dfGzr","date":"1544657037","viewed":616,"name":"Quesitos MÃ¡gicos","username":"bitnenfer","description":"Trying to make a cheese texture","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cheese"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FARCLIP 100.0\n#define NEARCLIP 0.001\n#define EPSILON 0.001\n#define MARCHSTEPS 500\n\n#define NO_MATERIAL 0\n#define MATERIAL_DEFAULT 1\n#define MATERIAL_CHEESE 2\n#define MATERIAL_PLATE 3\n#define MATERIAL_KNIFE 4\n#define SSS_STEPS 30\n\nstruct Material\n{\n    int type;\n};\n\nconst vec4 kAmbientColor = vec4(0.0);\nconst vec3 kDirLight = vec3(0.23253024,0.4140824,-0.21309763);\n\nfloat mapScene(vec3 p, out Material material);\n\nvoid opRotate(inout vec2 v, float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    float vx = v.x * c - v.y * s;\n    float vy = v.x * s + v.y * c;\n    v.x = vx;\n    v.y = vy;\n}\n\nvec3 opNormal(in vec3 p)\n{\n    Material material;\n    vec2 e = vec2(0.0, EPSILON);\n    float d = mapScene(p, material);\n    vec3 n = d - vec3(\n    \tmapScene(p - e.yxx, material),\n    \tmapScene(p - e.xyx, material),\n    \tmapScene(p - e.xxy, material)\n    );\n    return normalize(n);\n}\n\nvec3 opRepeate(in vec3 p, in vec3 c)\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat opDisp(vec3 p)\n{\n    return sin(20.0*p.x)*sin(20.0*p.y)*sin(20.0*p.z);\n}\n\n\n// iq's sdf functions :3\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opUnion(float a, float b, in Material matA, in Material matB, out Material mat)\n{\n    if (a < b) \n    {\n        mat = matA;\n        return a;\n    }\n    mat = matB;\n    return b;\n}\n\n// MAP \nfloat mapCheese(in vec3 p, out Material material)\n{\n    float value = 0.0;\n    opRotate(p.xz, 0.5);\n    \n    // base shape\n    float cyl0 = sdRoundedCylinder(p, 0.30, 0.04, 0.3);\n    vec3 triP0 = p + vec3(0.0, 0.0, -0.2);\n    opRotate(triP0.zy, -3.14/2.0);\n    float tri0 = sdTriPrism(triP0, vec2(.8, 0.4)) - 0.001;\n    material.type = MATERIAL_CHEESE;\n    value = max(tri0, cyl0);\n    \n    // holes\n    vec3 holesP = p + vec3(-0.1119641, -0.6300012, 0.1603024);\n    holesP = opRepeate(holesP, vec3(0.45));\n    float sp = sdSphere(holesP, 0.12);\n    sp += opDisp(p * 0.3) * 0.15;\n    value = max(-sp, value);\n    \n    //cut\n    vec3 cutP = p + vec3(0.0, 0.0, 0.62);\n    opRotate(cutP.xz, -0.4);\n    opRotate(cutP.yz, -0.2);\n    cutP = opRepeate(cutP, vec3(0.09, 0.001, 0.0));\n    float ct = sdSphere(cutP, 0.07);\n    \n    value = max(-ct, value);\n    \n    return value;\n}\n\nfloat mapPlate(in vec3 p, out Material material)\n{\n    material.type = MATERIAL_PLATE;\n    float base = sdBox(p, vec3(0.8, -0.001, 0.8)) - 0.1;\n    float handle = sdBox(p + vec3(-1.0, 0.0, 0.0), vec3(0.5, 0.0, 0.04 * sin(-0.1 + -p.x * 2.0))) - 0.1;\n    return min(base, handle);\n}\n\nfloat mapKnife(in vec3 p, out Material material)\n{\n    material.type = MATERIAL_KNIFE;\n    \n    p*=0.6;\n    vec3 handleP = p;\n    opRotate(handleP.xy, -sin(handleP.y) * 0.5);\n    opRotate(handleP.xy, 0.14);\n    float handle = sdCappedCylinder(handleP, vec2(0.0, 0.24)) - abs(0.05 * cos(0.3 + p.y * -4.0));\n    float blade = sdBox(p + vec3(0.05, -0.6, 0.0), vec3(0.1 * sqrt(abs(cos(p.y * 1.57))), 0.4, 0.002));\n    return min(handle, blade);\n}\n\nfloat mapScene(vec3 p, out Material material)\n{\n    Material cheeseMaterial;\n    Material plateMaterial;\n    Material knifeMaterial;\n    p = p + vec3(0.2, 0.0, 0.0);\n    vec3 cheeseP = p + vec3(0.3, 0.0, -0.1);\n    vec3 plateP = p + vec3(0.0, 0.456, 0.0);\n    vec3 knifeP = p + vec3(-0.7742586, 0.2902968, -0.11406922);\n    \n    opRotate(knifeP.yz, 3.14/2.0+0.015);\n    opRotate(knifeP.xy, -3.14/4.0);\n    opRotate(knifeP.xz, -0.28);\n    float cheese = mapCheese(cheeseP, cheeseMaterial);\n    float plate = mapPlate(plateP, plateMaterial);\n    float knife = mapKnife(knifeP, knifeMaterial);\n    \n    return opUnion(knife, opUnion(cheese, plate, cheeseMaterial, plateMaterial, material), knifeMaterial, material, material);\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd, out Material material)\n{\n    float total = NEARCLIP;\n    \n    for (int i = 0; i < MARCHSTEPS; ++i)\n    {\n        float dist = mapScene(ro + rd * total, material);\n        if (dist < EPSILON)\n        {\n            return total;\n        }\n        total += dist * 0.7;\n        if (total > FARCLIP) break;\n    }\n    \n    return FARCLIP;\n}\n\nfloat opSSS(in vec3 ro, in vec3 rd, in vec3 n, float dist, float factor)\n{\n    Material material;\n    float value = 0.0;\n    vec3 nrd = refract(rd, n, 1.0);\n    float s = 1.0;\n    #if __VERSION__ == 100\n    const int steps = SSS_STEPS;\n    #else\n    int steps = int(factor);\n    #endif\n    for (int i = 0; i < steps; ++i)\n    {\n        float stepSize = (float(i) / float(steps));\n        float d = mapScene(ro + nrd * stepSize, material);\n        value += (stepSize - d) * s;\n        s *= 0.6;\n    }\n    value = pow(value, 0.2);\n    value = clamp(abs(1.0 - value), 0.0, 1.0000001);\n    return value;\n}\n\nvec3 opReflection(float dist, in vec3 p, in vec3 dir, in vec3 n)\n{\n    vec3 color = vec3(0.1);\n    vec3 rd = normalize(reflect(dir, n));\n    float ft = max(0.0, dot(rd, n));\n    Material material;\n    float d = 0.0;\n        \n    for (int i = 0; i < 50; ++i)\n    {\n        float x = mapScene(p + rd * d, material);\n        if (dist < EPSILON)\n        {\n            break;\n        }\n        d += x*1.2;\n        if (d > FARCLIP) break;\n    }\n   \n    if (d < FARCLIP && ft > 0.0)\n    {\n        vec3 hitPoint = p + rd * d;\n        vec3 n = opNormal(hitPoint);\n        vec3 nld = normalize(kDirLight);\n        vec3 h = normalize(n + nld);\n        float diff = max(0.0, dot(n, nld));\n        \n        if (material.type == MATERIAL_CHEESE)\n        {\n            float sss = opSSS(hitPoint, nld, n, dist, 80.0);\n            \n            color = (vec3(0.9,0.5,0.) + kAmbientColor.rgb) * 0.5; \n            color += diff * vec3(0.5);\n            color += sss * ((vec3(1.5) + kAmbientColor.rgb * 5.8) * 0.7);\n        }\n        else if (material.type == MATERIAL_PLATE)\n        {\n            color = (vec3(0.9,0.9,0.9) + kAmbientColor.rgb) * 0.5; \n            color += diff * vec3(0.89);\n        }\n        else if (material.type == MATERIAL_KNIFE)\n        {\n            color = (vec3(0.01) + kAmbientColor.rgb) * 0.5;\n            color += diff * vec3(0.1);\n        }\n        return (color) * 0.4;\n    }\n    return texture(iChannel0, reflect(dir, n)).rgb;\n}\n\nfloat opAO(in vec3 p, in vec3 n)\n{\n    Material material;\n    float value = 0.0;\n    float s = 1.0;\n    for (int i = 0; i < 3; ++i)\n    {\n        float stepSize = 0.05;\n        float dist = mapScene(p + n * stepSize, material);\n        value += (stepSize - dist) * s;\n        s *=0.8;\n    }\n    value = value;\n    return clamp(sqrt((0.8 - value) * sqrt(1.0)), -1.0, 1.0);\n}\n\nfloat opShadow(in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    Material material;\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        float h = mapScene( ro + rd * t, material );\n        res = min( res, 2.0*h/t );\n        t += clamp( h, 0.002, 0.010 );\n        if( h<0.0001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 shade(float dist, in vec3 rd, in vec3 p, in Material material)\n{\n    vec3 n = opNormal(p);\n    vec3 l = normalize(kDirLight);\n    vec3 h = normalize(l + n);\n    vec3 color = vec3(1, 0, 1);\n    float ao = opAO(p, n);\n    float shadow = opShadow(p, l, 0.01, 10.1);\n    float diff = max(0.0, dot(l, n));\n\n    if (material.type == MATERIAL_CHEESE)\n    {\n        float sss = opSSS(p, l, n, dist, 30.0);\n        float spec = pow(max(0.0, dot(l, n)), 4096.0);\n        float oc = clamp(shadow, 0.0, 1.0);\n        \n        #if 1\n        color = (vec3(1.15,0.45,0.) + kAmbientColor.rgb) * 0.5; \n        color += oc * diff * vec3(0.5);\n        color += oc * spec * vec3(1.0);\n        color += clamp(oc, 0.89,1.0) * sss * ((vec3(1.55, 1.55, 1.3)));\n        color -= 0.13 * vec3(0.0, 0.9, 0.3) * clamp(1.0 - shadow, 0.0, 1.0);\n        color *= pow(ao, 2.1);\n        #else\n        color = (vec3(0.9,0.5,0.) + kAmbientColor.rgb) * 0.5; \n        color += oc * diff * vec3(0.5);\n        color += oc * spec * vec3(1.0);\n        color += clamp(oc, 0.89,1.0) * sss * ((vec3(1.5)));\n        color -= 0.13 * vec3(0.8, 0.8, 0.3) * clamp(1.0 - shadow, 0.0, 1.0);\n        color *= pow(ao, 2.1);\n    \t#endif\n    }\n    else if (material.type == MATERIAL_PLATE)\n    {\n        vec3 ref = opReflection(dist, p, rd, n);\n        color = (vec3(0.9,0.9,0.9) + kAmbientColor.rgb) * 0.5; \n        color += ref * 0.5;\n        color += diff * vec3(0.89);\n        color *= pow(ao, 3.2);\n        color -= 0.3 *vec3(0.4, 0.4, 0.4) * clamp(1.0 - shadow, 0.0, 1.0);\n    }\n    else if (material.type == MATERIAL_KNIFE)\n    {\n        vec3 ref = opReflection(dist, p, rd, n);\n        float oc = clamp(shadow, 0.0, 1.0);\n        color = (vec3(0.01) + kAmbientColor.rgb) * 0.5;\n        color += clamp(ref, 0.0, 1.0) * 1.0;\n        color += oc * diff * vec3(0.1);\n        color -= 0.3 * vec3(0.4, 0.4, 0.4) * clamp(1.0 - shadow, 0.0, 1.0);\n    }\n    \n    return color;\n} \n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord.xy / iResolution.xy - 0.5) * vec2(ar, 1.0);\n    vec3 ro = vec3(0.0, 1.1, -2.2);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 color = vec3(0.15);\n\n    opRotate(rd.yz, 0.59);\n    \n    if (iMouse.z > 0.0)\n    {\n        float rx = (iMouse.x / iResolution.x - 0.5) * -6.28;\n        float ry = (iMouse.y / iResolution.y - 0.5) * -1.25;\n\t\topRotate(ro.xz, rx);\n        opRotate(rd.xz, rx);\n        opRotate(ro.yz, ry);\n        opRotate(rd.yz, ry);\n    }\n    else\n    {\n        float r = sin(iTime) * 0.03 * 3.14;\n        opRotate(ro.xz, r);\n        opRotate(rd.xz, r);\n    }\n    \n    Material material = Material(NO_MATERIAL);\n    float dist = rayMarch(ro, rd, material);\n    if (dist < FARCLIP)\n    {\n        vec3 point = ro + rd * dist;\n        color = shade(dist, rd, point, material);\n    }\n    \n    color = pow(color, vec3(1.0/1.2));\n    color = mix(color, 1.0 - (color * 10.2), max(0.0, pow(length(1.0 * uv / vec2(ar, 1.0)), 5.9)));\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}