{"ver":"0.1","info":{"id":"lfcGzS","date":"1711816772","viewed":64,"name":"Material Maker test","username":"karakure178","description":"Grid and noise combined with Material Maker.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["materialmaker"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Generated by Material Maker */\n\n#define SEED_VARIATION 0.0\n\n\n\n\nfloat dot2(vec2 x) {\n\treturn dot(x, x);\n}\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat param_rnd(float minimum, float maximum, float seed) {\n\treturn minimum+(maximum-minimum)*rand(vec2(seed));\n}\n\nfloat param_rndi(float minimum, float maximum, float seed) {\n\treturn floor(param_rnd(minimum, maximum + 1.0, seed));\n}\n\nvec4 oldbrick(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float round, float bevel) {\n\tfloat color;\n\tvec2 size = bmax - bmin;\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tbevel *= min_size;\n\tround *= min_size;\n\tvec2 center = 0.5*(bmin+bmax);\n\tvec2 d = abs(uv-center)-0.5*(size)+vec2(round+mortar);\n\tcolor = length(max(d,vec2(0))) + min(max(d.x,d.y),0.0)-round;\n\tcolor = clamp(-color/bevel, 0.0, 1.0);\n\tvec2 tiled_brick_pos = mod(bmin, vec2(1.0, 1.0));\n\treturn vec4(color, center, tiled_brick_pos.x+7.0*tiled_brick_pos.y);\n}\n\nvec3 oldbrick_random_color(vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\treturn rand3(fract(center + vec2(seed)));\n}\n\nvec3 oldbrick_uv(vec2 uv, vec2 bmin, vec2 bmax, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\treturn vec3(0.5+(uv-center)/max_size, rand(fract(center)+vec2(seed)));\n}\n\nvec3 oldbrick_corner_uv(vec2 uv, vec2 bmin, vec2 bmax, float mortar, float corner, float seed) {\n\tvec2 center = 0.5*(bmin + bmax);\n\tvec2 size = bmax - bmin;\n\tfloat max_size = max(size.x, size.y);\n\tfloat min_size = min(size.x, size.y);\n\tmortar *= min_size;\n\tcorner *= min_size;\n\treturn vec3(clamp((0.5*size-vec2(mortar)-abs(uv-center))/corner, vec2(0.0), vec2(1.0)), rand(fract(center)+vec2(seed)+ceil(vec2(uv-center))));\n}\n\nvec4 oldbricks_rb(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 oldbricks_rb2(vec2 uv, vec2 count, float repeat, float offset) {\n\tcount *= repeat;\n\tfloat x_offset = offset*step(0.5, fract(uv.y*count.y*0.5));\n\tcount.x = count.x*(1.0+step(0.5, fract(uv.y*count.y*0.5)));\n\tvec2 bmin = floor(vec2(uv.x*count.x-x_offset, uv.y*count.y));\n\tbmin.x += x_offset;\n\tbmin /= count;\n\treturn vec4(bmin, bmin+vec2(1.0)/count);\n}\n\nvec4 oldbricks_hb(vec2 uv, vec2 count, float repeat, float offset) {\n\tfloat pc = count.x+count.y;\n\tfloat c = pc*repeat;\n\tvec2 corner = floor(uv*c);\n\tfloat cdiff = mod(corner.x-corner.y, pc);\n\tif (cdiff < count.x) {\n\t\treturn vec4((corner-vec2(cdiff, 0.0))/c, (corner-vec2(cdiff, 0.0)+vec2(count.x, 1.0))/c);\n\t} else {\n\t\treturn vec4((corner-vec2(0.0, pc-cdiff-1.0))/c, (corner-vec2(0.0, pc-cdiff-1.0)+vec2(1.0, count.y))/c);\n\t}\n}\n\nvec4 oldbricks_bw(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = 2.0*count*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = count*floor(repeat*2.0*uv);\n\tfloat cdiff = mod(dot(floor(repeat*2.0*uv), vec2(1.0)), 2.0);\n\tvec2 corner;\n\tvec2 size;\n\tif (cdiff == 0.0) {\n\t\tcorner = vec2(corner1.x, corner2.y);\n\t\tsize = vec2(1.0, count.y);\n\t} else {\n\t\tcorner = vec2(corner2.x, corner1.y);\n\t\tsize = vec2(count.x, 1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}\n\nvec4 oldbricks_sb(vec2 uv, vec2 count, float repeat, float offset) {\n\tvec2 c = (count+vec2(1.0))*repeat;\n\tfloat mc = max(c.x, c.y);\n\tvec2 corner1 = floor(uv*c);\n\tvec2 corner2 = (count+vec2(1.0))*floor(repeat*uv);\n\tvec2 rcorner = corner1 - corner2;\n\tvec2 corner;\n\tvec2 size;\n\tif (rcorner.x == 0.0 && rcorner.y < count.y) {\n\t\tcorner = corner2;\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == 0.0) {\n\t\tcorner = corner2+vec2(1.0, 0.0);\n\t\tsize = vec2(count.x, 1.0);\n\t} else if (rcorner.x == count.x) {\n\t\tcorner = corner2+vec2(count.x, 1.0);\n\t\tsize = vec2(1.0, count.y);\n\t} else if (rcorner.y == count.y) {\n\t\tcorner = corner2+vec2(0.0, count.y);\n\t\tsize = vec2(count.x, 1.0);\n\t} else {\n\t\tcorner = corner2+vec2(1.0);\n\t\tsize = vec2(count.x-1.0, count.y-1.0);\n\t}\n\treturn vec4(corner/c, (corner+size)/c);\n}vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\tif (rand(uv) < opacity) {\n\t\treturn c1;\n\t} else {\n\t\treturn c2;\n\t}\n}\n\nvec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blend_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_difference(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_additive(vec2 uv, vec3 c1, vec3 c2, float oppacity) {\n\treturn c2 + c1 * oppacity;\n}\n\nvec3 blend_addsub(vec2 uv, vec3 c1, vec3 c2, float oppacity) {\n\treturn c2 + (c1 - .5) * 2.0 * oppacity;\n}\n\nfloat perlin(vec2 uv, vec2 size, int iterations, float persistence, float seed) {\n\tvec2 seed2 = rand2(vec2(seed, 1.0-seed));\n\tfloat rv = 0.0;\n\tfloat coef = 1.0;\n\tfloat acc = 0.0;\n\tfor (int i = 0; i < iterations; ++i) {\n\t\tvec2 step = vec2(1.0)/size;\n\t\tvec2 xy = floor(uv*size);\n\t\tfloat f0 = rand(seed2+mod(xy, size));\n\t\tfloat f1 = rand(seed2+mod(xy+vec2(1.0, 0.0), size));\n\t\tfloat f2 = rand(seed2+mod(xy+vec2(0.0, 1.0), size));\n\t\tfloat f3 = rand(seed2+mod(xy+vec2(1.0, 1.0), size));\n\t\tvec2 mixval = smoothstep(0.0, 1.0, fract(uv*size));\n\t\trv += coef * mix(mix(f0, f1, mixval.x), mix(f2, f3, mixval.x), mixval.y);\n\t\tacc += coef;\n\t\tsize *= 2.0;\n\t\tcoef *= persistence;\n\t}\n\t\n\treturn rv / acc;\n}\n\nvec2 transform(vec2 uv, vec2 translate, float rotate, vec2 scale, bool repeat) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n\tif (repeat) {\n\t\treturn fract(rv);\n\t} else {\n\t\treturn clamp(rv, vec2(0.0), vec2(1.0));\n\t}\t\n}\n\nconst float p_o1379428_amount = 1.000000000;\nconst float p_o1339263_amount = 1.000000000;\nconst float seed_o1182182 = 0.817432523;\nconst float p_o1182182_repeat = 1.000000000;\nconst float p_o1182182_rows = 3.000000000;\nconst float p_o1182182_columns = 3.000000000;\nconst float p_o1182182_row_offset = 0.000000000;\nconst float p_o1182182_mortar = 0.100000001;\nconst float p_o1182182_bevel = 0.000000000;\nconst float p_o1182182_round = 0.000000000;\nconst float p_o1182182_corner = 0.300000012;\nconst float p_o1182183_translate_x = 1.000000000;\nconst float p_o1182183_rotate = 0.000000000;\nconst float p_o1182183_scale_x = 1.000000000;\nconst float p_o1182183_scale_y = 1.000000000;\nconst float p_o1011915_translate_x = 0.500000000;\nconst float p_o1011915_translate_y = 1.000000000;\nconst float p_o1011915_rotate = 0.000000000;\nconst float p_o1011915_scale_x = 1.000000000;\nconst float p_o1011915_scale_y = 1.000000000;\nconst float p_o1011910_translate_x = 0.500000000;\nconst float p_o1011910_translate_y = 1.000000000;\nconst float p_o1011910_rotate = 0.000000000;\nconst float p_o1011910_scale_x = 1.000000000;\nconst float p_o1011910_scale_y = 1.000000000;\nconst float seed_o1011911 = 55134.000000000;\nconst float p_o1011911_scale_x = 4.000000000;\nconst float p_o1011911_scale_y = 4.000000000;\nconst float p_o1011911_iterations = 3.000000000;\nconst float p_o1011911_persistence = 0.500000000;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nfloat _seed_variation_ = SEED_VARIATION;\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec4 o1182182_0_rect = oldbricks_rb((UV), vec2(p_o1182182_columns, p_o1182182_rows), p_o1182182_repeat, p_o1182182_row_offset);\nvec4 o1182182_0 = oldbrick((UV), o1182182_0_rect.xy, o1182182_0_rect.zw, p_o1182182_mortar*1.0, p_o1182182_round*1.0, max(0.001, p_o1182182_bevel*1.0));\nfloat o1182182_0_2_f = o1182182_0.x;\nvec3 o1182182_1_3_rgb = oldbrick_random_color(o1182182_0_rect.xy, o1182182_0_rect.zw, float((seed_o1182182+fract(_seed_variation_))));\nvec4 o1339263_0_s1 = vec4(vec3(o1182182_0_2_f), 1.0);\nvec4 o1339263_0_s2 = vec4(o1182182_1_3_rgb, 1.0);\nfloat o1339263_0_a = p_o1339263_amount*1.0;\nvec4 o1339263_0_2_rgba = vec4(blend_darken((UV), o1339263_0_s1.rgb, o1339263_0_s2.rgb, o1339263_0_a*o1339263_0_s1.a), min(1.0, o1339263_0_s2.a+o1339263_0_a*o1339263_0_s1.a));\nfloat o1011911_0_1_f = perlin((transform((UV), vec2(p_o1182183_translate_x*(2.0*1.0-1.0), (iTime/10.0)*(2.0*1.0-1.0)), p_o1182183_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o1182183_scale_x*(2.0*1.0-1.0), p_o1182183_scale_y*(2.0*1.0-1.0)), true)), vec2(p_o1011911_scale_x, p_o1011911_scale_y), int(p_o1011911_iterations), p_o1011911_persistence, (seed_o1011911+fract(_seed_variation_)));\nfloat o1011911_0_3_f = perlin((transform((transform((UV), vec2(p_o1182183_translate_x*(2.0*1.0-1.0), (iTime/10.0)*(2.0*1.0-1.0)), p_o1182183_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o1182183_scale_x*(2.0*1.0-1.0), p_o1182183_scale_y*(2.0*1.0-1.0)), true)), vec2(p_o1011910_translate_x*(2.0*o1011911_0_1_f-1.0), p_o1011910_translate_y*(2.0*o1011911_0_1_f-1.0)), p_o1011910_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o1011910_scale_x*(2.0*1.0-1.0), p_o1011910_scale_y*(2.0*1.0-1.0)), true)), vec2(p_o1011911_scale_x, p_o1011911_scale_y), int(p_o1011911_iterations), p_o1011911_persistence, (seed_o1011911+fract(_seed_variation_)));\nvec4 o1011910_0_1_rgba = vec4(vec3(o1011911_0_3_f), 1.0);\nfloat o1011911_0_5_f = perlin((transform((transform((UV), vec2(p_o1182183_translate_x*(2.0*1.0-1.0), (iTime/10.0)*(2.0*1.0-1.0)), p_o1182183_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o1182183_scale_x*(2.0*1.0-1.0), p_o1182183_scale_y*(2.0*1.0-1.0)), true)), vec2(p_o1011915_translate_x*(2.0*(dot((o1011910_0_1_rgba).rgb, vec3(1.0))/3.0)-1.0), p_o1011915_translate_y*(2.0*(dot((o1011910_0_1_rgba).rgb, vec3(1.0))/3.0)-1.0)), p_o1011915_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o1011915_scale_x*(2.0*1.0-1.0), p_o1011915_scale_y*(2.0*1.0-1.0)), true)), vec2(p_o1011911_scale_x, p_o1011911_scale_y), int(p_o1011911_iterations), p_o1011911_persistence, (seed_o1011911+fract(_seed_variation_)));\nvec4 o1011915_0_1_rgba = vec4(vec3(o1011911_0_5_f), 1.0);\nvec4 o1182183_0_1_rgba = o1011915_0_1_rgba;\nvec4 o1379428_0_s1 = o1339263_0_2_rgba;\nvec4 o1379428_0_s2 = o1182183_0_1_rgba;\nfloat o1379428_0_a = p_o1379428_amount*1.0;\nvec4 o1379428_0_2_rgba = vec4(blend_darken((UV), o1379428_0_s1.rgb, o1379428_0_s2.rgb, o1379428_0_a*o1379428_0_s1.a), min(1.0, o1379428_0_s2.a+o1379428_0_a*o1379428_0_s1.a));\nfragColor = o1379428_0_2_rgba;\n}\n","name":"Image","description":"","type":"image"}]}