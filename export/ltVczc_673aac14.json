{"ver":"0.1","info":{"id":"ltVczc","date":"1537543263","viewed":109,"name":"Assignment 2 - CSC 550","username":"richardMartin","description":"Assignment 2 for CSC 550, 3 planes, 2 shapes, 1 shape made of triangles with 10 unique vertices  and tectures applied to at least one shape.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","ray","sphere","plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://github.com/yuichiroharai/glsl-y-rotate/blob/master/rotateY.glsl\nmat3 rotateY(float rad) {\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3(\n\t\tc, 0.0, -s,\n\t\t0.0, 1.0, 0.0,\n\t\ts, 0.0, c\n\t);\n}\n\nmat3 rotateX(float rad)\n{\n\tfloat c = cos(rad);\n\tfloat s = sin(rad);\n\treturn mat3\n    (\n\t\t1.0, 0.0, 0.0,\n        0.0, c, s,\n\t\t0.0, -s, c\n\t\t\n\t);\n}\n\n// plane trace from class\nbool planeTrace(in vec3 rayPos, in vec3 rayDirection, \n                 in vec3 planePos, in vec3 planeNormal, \n               out vec3 intersectPos, out vec3 intersectDir)\n{\n    float denom = dot(-rayDirection, planeNormal);\n    \n    if(denom < 0.0001)\n        return false;\n        \n    float t = dot(rayPos - planePos, planeNormal)/denom;\n        \n    //the point on the plane is...\n    intersectPos = rayPos + rayDirection *t;\n    \n    intersectDir = reflect ( rayDirection, planeNormal);\n    \n    return true;\n        \n}\n\n// sphere trace from class\nbool sphereTrace(in vec3 rayPos, in vec3 rayDirection, \n                 in vec3 spherePos, in float sphereRadius, \n                 out vec3 intersectPos, out vec3 intersectDir )\n{\n    /*\n\t\tmath from Dr Landon and\n\t\thttps://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n\t*/\n    \n    // vector between center and ray origin \n    vec3 L = spherePos - rayPos;\n    \n    // through geometry and trig\n    // A dot B = abs(a)*abs(b)Cos(angle between them)\n    // because the projection of vector B onto A will give us the length of AB\n    // the length of AB is tca\n    // let L = A and D = B\n    float tca = dot (L, rayDirection);\n    \n    // the only way tca is negative is\n    // if the two vectors are going in opposite dirrections\n    if(tca < 0.0)\n        return false;\n    \n    // altered pathagorean theorem\n    float d = sqrt(dot(L,L) - pow(tca,2.0));\n    \n    // if d is less than the sphere radius then it intersected.\n    if(d > sphereRadius)\n    \treturn false;\n    \n    float thc = sqrt(pow(sphereRadius, 2.0) - pow(d,2.0));\n    \n    // distance from ray Start to hitting the sphere\n    float t1 = tca - thc;\n    \n    // results in 3D point where ray hits the sphere\n    intersectPos = rayPos + rayDirection*t1;\n    \n    vec3 normal = normalize(intersectPos - spherePos);\n    \n    intersectDir = reflect(rayDirection, normal);\n    \n    return true;\n    \n}\n\nconst vec3 plane_Pos[3] = vec3[3](vec3(0.0),\n                                 \tvec3(10.0,0.0,0.0),\n                                 \tvec3(10,0.0,0.0)\n                                 );\n\nconst vec3 plane_Norms[3] = vec3[3](vec3(0.0,1.0,0.0),\n                                   \tvec3(1.0,0.0,0.0),\n                                   \tvec3(-1.0,0.0,0.0)\n                                   );\n\nconst vec3 plane_Col[3] = vec3[3](vec3(0.02),\n                                  vec3(0.25),\n                                  vec3(0.3)\n                                 );\n\nconst vec3 sphere_Pos[3] = vec3[3](vec3(0.5,2.0,0.0),\n                                   vec3(-1.0,2.0,3.0),\n                                   vec3(0.5,0.2,0.5)\n                                   );\n\nconst float sphere_Radius[3] = float[3](float(0.7),\n                                        float(0.25),\n                                        float(0.1)\n                                        );\n\nconst vec3 sphere_Col[3] = vec3[3]( vec3(0.5, 0.5, 0.0),\n                                    vec3(0.2, 0.2, 1.0),\n                                    vec3(1.0)                                    \n    \t\t\t\t\t\t\t\t);\n\nconst vec3 CUBE0_VERTS[12] = vec3[12](\nvec3( -2.69549430482 ,  0.0 ,  -1.0 ), \nvec3( -1.97188747995 ,  0.525731086731 ,  -0.447213590145 ), \nvec3( -2.97188756935 ,  0.850650906563 ,  -0.44721364975 ), \nvec3( -3.58992160432 ,  -7.81933167104e-08 ,  -0.44721364975 ), \nvec3( -2.97188759915 ,  -0.850650787354 ,  -0.447213590145 ), \nvec3( -1.97188753955 ,  -0.525731146336 ,  -0.447213590145 ), \nvec3( -1.80106700532 ,  0.0 ,  0.44721364975 ), \nvec3( -2.4191011297 ,  0.850650846958 ,  0.447213590145 ), \nvec3( -3.4191011893 ,  0.525731086731 ,  0.44721364975 ), \nvec3( -3.41910107009 ,  -0.52573120594 ,  0.447213590145 ), \nvec3( -2.41910098068 ,  -0.850650787354 ,  0.447213590145 ), \nvec3( -2.69549430482 ,  0.0 ,  1.0 ) \n);\nconst ivec3 CUBE0_INDEX[20] = ivec3[20](\nivec3( 0 ,  2 ,  1 ), \nivec3( 0 ,  3 ,  2 ), \nivec3( 0 ,  4 ,  3 ), \nivec3( 0 ,  5 ,  4 ), \nivec3( 0 ,  1 ,  5 ), \nivec3( 1 ,  2 ,  7 ), \nivec3( 2 ,  3 ,  8 ), \nivec3( 3 ,  4 ,  9 ), \nivec3( 4 ,  5 ,  10 ), \nivec3( 5 ,  1 ,  6 ), \nivec3( 1 ,  7 ,  6 ), \nivec3( 2 ,  8 ,  7 ), \nivec3( 3 ,  9 ,  8 ), \nivec3( 4 ,  10 ,  9 ), \nivec3( 5 ,  6 ,  10 ), \nivec3( 6 ,  7 ,  11 ), \nivec3( 7 ,  8 ,  11 ), \nivec3( 8 ,  9 ,  11 ), \nivec3( 9 ,  10 ,  11 ), \nivec3( 10 ,  6 ,  11 ) \n);\n\nconst vec3 CUBE1_VERTS[32] = vec3[32](\nvec3( 0.0 ,  2.09963607621 ,  -1.0 ), \nvec3( 0.723606824875 ,  2.62536716294 ,  -0.447213590145 ), \nvec3( -0.276393264532 ,  2.95028698277 ,  -0.44721364975 ), \nvec3( -0.8944272995 ,  2.09963599802 ,  -0.44721364975 ), \nvec3( -0.276393294334 ,  1.24898528886 ,  -0.447213590145 ), \nvec3( 0.72360676527 ,  1.57390492988 ,  -0.447213590145 ), \nvec3( 0.8944272995 ,  2.09963607621 ,  0.44721364975 ), \nvec3( 0.276393175125 ,  2.95028692317 ,  0.447213590145 ), \nvec3( -0.72360688448 ,  2.62536716294 ,  0.44721364975 ), \nvec3( -0.72360676527 ,  1.57390487027 ,  0.447213590145 ), \nvec3( 0.276393324137 ,  1.24898528886 ,  0.447213590145 ), \nvec3( 0.0 ,  2.09963607621 ,  1.0 ), \nvec3( 0.187592461705 ,  2.67698627543 ,  -0.794654488564 ), \nvec3( -0.491123467684 ,  2.45645811987 ,  -0.794654488564 ), \nvec3( -0.491123467684 ,  1.74281400275 ,  -0.794654488564 ), \nvec3( 0.187592402101 ,  1.52228587699 ,  -0.794654488564 ), \nvec3( 0.607061982155 ,  2.09963605121 ,  -0.794654488564 ), \nvec3( 0.303530991077 ,  3.0338084085 ,  -0.187592476606 ), \nvec3( -0.794654488564 ,  2.67698621583 ,  -0.187592461705 ), \nvec3( -0.794654488564 ,  1.52228575778 ,  -0.187592461705 ), \nvec3( 0.30353102088 ,  1.16546374392 ,  -0.187592476606 ), \nvec3( 0.982246935368 ,  2.09963605121 ,  -0.187592461705 ), \nvec3( 0.794654488564 ,  2.67698633504 ,  0.187592476606 ), \nvec3( -0.30353102088 ,  3.0338084085 ,  0.187592476606 ), \nvec3( -0.982246994972 ,  2.0996359762 ,  0.187592491508 ), \nvec3( -0.303530961275 ,  1.16546374392 ,  0.187592476606 ), \nvec3( 0.794654488564 ,  1.52228581738 ,  0.187592476606 ), \nvec3( 0.491123437881 ,  2.45645817947 ,  0.794654488564 ), \nvec3( -0.187592476606 ,  2.67698627543 ,  0.794654428959 ), \nvec3( -0.607061982155 ,  2.0996360012 ,  0.794654428959 ), \nvec3( -0.187592417002 ,  1.52228581738 ,  0.794654488564 ), \nvec3( 0.491123467684 ,  1.74281403255 ,  0.794654428959 ) \n);\n\nconst ivec3 CUBE1_INDEX[60] = ivec3[60](\nivec3( 0 ,  2 ,  12 ), \nivec3( 2 ,  1 ,  12 ), \nivec3( 1 ,  0 ,  12 ), \nivec3( 0 ,  3 ,  13 ), \nivec3( 3 ,  2 ,  13 ), \nivec3( 2 ,  0 ,  13 ), \nivec3( 0 ,  4 ,  14 ), \nivec3( 4 ,  3 ,  14 ), \nivec3( 3 ,  0 ,  14 ), \nivec3( 0 ,  5 ,  15 ), \nivec3( 5 ,  4 ,  15 ), \nivec3( 4 ,  0 ,  15 ), \nivec3( 0 ,  1 ,  16 ), \nivec3( 1 ,  5 ,  16 ), \nivec3( 5 ,  0 ,  16 ), \nivec3( 1 ,  2 ,  17 ), \nivec3( 2 ,  7 ,  17 ), \nivec3( 7 ,  1 ,  17 ), \nivec3( 2 ,  3 ,  18 ), \nivec3( 3 ,  8 ,  18 ), \nivec3( 8 ,  2 ,  18 ), \nivec3( 3 ,  4 ,  19 ), \nivec3( 4 ,  9 ,  19 ), \nivec3( 9 ,  3 ,  19 ), \nivec3( 4 ,  5 ,  20 ), \nivec3( 5 ,  10 ,  20 ), \nivec3( 10 ,  4 ,  20 ), \nivec3( 5 ,  1 ,  21 ), \nivec3( 1 ,  6 ,  21 ), \nivec3( 6 ,  5 ,  21 ), \nivec3( 1 ,  7 ,  22 ), \nivec3( 7 ,  6 ,  22 ), \nivec3( 6 ,  1 ,  22 ), \nivec3( 2 ,  8 ,  23 ), \nivec3( 8 ,  7 ,  23 ), \nivec3( 7 ,  2 ,  23 ), \nivec3( 3 ,  9 ,  24 ), \nivec3( 9 ,  8 ,  24 ), \nivec3( 8 ,  3 ,  24 ), \nivec3( 4 ,  10 ,  25 ), \nivec3( 10 ,  9 ,  25 ), \nivec3( 9 ,  4 ,  25 ), \nivec3( 5 ,  6 ,  26 ), \nivec3( 6 ,  10 ,  26 ), \nivec3( 10 ,  5 ,  26 ), \nivec3( 6 ,  7 ,  27 ), \nivec3( 7 ,  11 ,  27 ), \nivec3( 11 ,  6 ,  27 ), \nivec3( 7 ,  8 ,  28 ), \nivec3( 8 ,  11 ,  28 ), \nivec3( 11 ,  7 ,  28 ), \nivec3( 8 ,  9 ,  29 ), \nivec3( 9 ,  11 ,  29 ), \nivec3( 11 ,  8 ,  29 ), \nivec3( 9 ,  10 ,  30 ), \nivec3( 10 ,  11 ,  30 ), \nivec3( 11 ,  9 ,  30 ), \nivec3( 10 ,  6 ,  31 ), \nivec3( 6 ,  11 ,  31 ), \nivec3( 11 ,  10 ,  31 ) \n);\n\n\nbool triangleTrace(in vec3 rayPos, in vec3 rayDirection,\n\tin vec3 vertex0, in vec3 vertex1, in vec3 vertex2,\n\tout vec3 intersectPos, out vec3 intersectDir)\n{\n    \n    \n    vec3 v1v0 = vertex1 - vertex0;\n    vec3 v2v0 = vertex2 - vertex0;\n    vec3 rov0 = rayPos - vertex0;\n\n\n    // Cramer's rule for solcing p(t) = ro+t·rd = p(u,v) = vo + u·(v1-v0) + v·(v2-v1)\n    float d = 1.0/determinant(mat3(v1v0, v2v0, -rayDirection ));\n    float u =   d*determinant(mat3(rov0, v2v0, -rayDirection ));\n    float v =   d*determinant(mat3(v1v0, rov0, -rayDirection ));\n    float t =   d*determinant(mat3(v1v0, v2v0, rov0));\n\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 || t < 0.001 )\n        return false;\n    \n    \n    vec3 N = normalize(cross(v1v0,v2v0));\n    if(dot(rayDirection,N) > 0.0)\n        return false;\n\n    intersectPos = rayPos + t * rayDirection; \n    \n     \n    intersectDir = reflect(rayDirection, N);\n    return true;\n    \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv -= 0.6;\n  \tvec3 col = vec3(0.0);// set background to black \n    \n    vec3 lightDir = vec3(0,1,0);\n    vec3 lightDir2 = normalize(vec3(1,-1,1));\n\n    vec3 rayPos = vec3(-1,4, 6);// position of initial ray\n    vec3 rayDir = normalize(vec3(uv.x - 0.0, uv.y - 0.2, -0.9));// dirrection of initial ray\n    \n    vec3 newPos;\n    vec3 newDir;\n    vec3 currCol;\n    float currSpec;\n    \n    vec3 starPos = vec3(1,2,2);\n     \n    vec3 tempPos = sphere_Pos[1]*rotateY(iTime/1.5*float(1));\n    \n    // loop for ray bouncing\n    for(int r = 0; r < 3; ++r)\n    {\n        // variables from class\n    \tfloat minDist = 999999999.0;\n        vec3 tempNewPos;\n        vec3 tempNewDir;\n        \n        \n        \n        // loop for each plane\n        for(int p = 0; p < 3; ++p)\n        {\n        \tif(planeTrace(rayPos, rayDir,\n                          plane_Pos[p], plane_Norms[p],\n                          tempNewPos, tempNewDir))\n            {\n            \tfloat dist = distance(rayPos, tempNewPos);\n             \t\n                if(dist < minDist)\n                {\n                    minDist = dist;\n                    \n                    newPos = tempNewPos;\n                    newDir = tempNewDir;\n                    {\n                    \tcurrCol = vec3(0.0);\n                    }\n                }\n            }\n            \n        }\n        // cube0\n        for (int f = 0; f < 20; ++f) \n        {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  ((CUBE0_VERTS[CUBE0_INDEX[f].x]/5.0) * rotateY(iTime*float(-3))) + tempPos,\n                              ((CUBE0_VERTS[CUBE0_INDEX[f].y]/5.0) * rotateY(iTime*float(-3))) + tempPos,\n                              ((CUBE0_VERTS[CUBE0_INDEX[f].z]/5.0) * rotateY(iTime*float(-3))) + tempPos,\n\t\t\t\ttempNewPos, tempNewDir)) \n            {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist)\n                {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrCol = currCol = texture(iChannel2, vec2(newPos.y,newPos.z)).rgb;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        // cube1\n        for (int f = 0; f < 60; ++f) \n        {\n            vec2 tex;\n\t\t\tif (triangleTrace(rayPos, rayDir,\n\t\t\t\t\t\t\t  ((CUBE1_VERTS[CUBE1_INDEX[f].x]/1.5) * rotateX(iTime*float(2)) + (sphere_Pos[0])),\n                              ((CUBE1_VERTS[CUBE1_INDEX[f].y]/1.5) * rotateX(iTime*float(2)) + (sphere_Pos[0])),\n                              ((CUBE1_VERTS[CUBE1_INDEX[f].z]/1.5) * rotateX(iTime*float(2)) + (sphere_Pos[0])),\n\t\t\t\ttempNewPos, tempNewDir)) \n            {\n\n\t\t\t\tfloat dist = distance(rayPos, tempNewPos);\n\n\t\t\t\tif (dist < minDist)\n                {\n\n\t\t\t\t\tminDist = dist;\n\n\t\t\t\t\tnewPos = tempNewPos;\n\t\t\t\t\tnewDir = tempNewDir;\n\t\t\t\t\tcurrCol = texture(iChannel1, vec2(newPos.y,newPos.z)).rgb;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n        // loop for sphere 0 and 1\n        for(int s = 0; s < 2; ++s)\n        {\n           if(sphereTrace(rayPos, rayDir,\n              \tsphere_Pos[s]*rotateY(iTime/1.5*float(s)), sphere_Radius[s],\n            \ttempNewPos, tempNewDir))\n           {\n            \tfloat dist = distance(rayPos, tempNewPos);\n\n                if(dist < minDist)\n                {\n                     minDist = dist;\n\n                     newPos = tempNewPos;\n                     newDir = tempNewDir;\n\n                     currCol = sphere_Col[s];\n\n                     currSpec = 0.1;\n                 }\n             }\n        }\n        \n        // check for sphere 3 to make sure it stays around sphere 2\n        if(sphereTrace(rayPos, rayDir,\n           rotateY(iTime*float(4))*sphere_Pos[2] + tempPos, sphere_Radius[2],\n           tempNewPos, tempNewDir))\n                {\n\n                    float dist = distance(rayPos, tempNewPos);\n\n                    if(dist < minDist)\n                    {\n\n                        minDist = dist;\n\n                        newPos = tempNewPos;\n                        newDir = tempNewDir;\n\n                        currCol = sphere_Col[2];\n\n                        currSpec = 0.1;\n\n                    }\n                }\n       \n        rayPos = newPos;\n        rayDir = newDir;\n        \n        if(r == 0)\n        {\n        \tcol += currCol*0.2 \n            + clamp(dot(rayDir, lightDir),0.0,1.0)*vec3(0.4) //diffuse\n            ;\n        }\n        else \n        {\n        \tcol += (currCol*0.2 \n            + clamp(dot(rayDir, lightDir),0.0,1.0)*vec3(0.5)) //diffuse\n            *currSpec\n           ;\n        }\n\t}\n    \n    \n    \n\t// Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}