{"ver":"0.1","info":{"id":"mtlGWB","date":"1672886942","viewed":66,"name":"Animated Sunset","username":"bestknighter","description":"Made this shader for putting together a few concepts I learned in the last few days. I realized that there were things that I could've done better but eh... Maybe someday, after much learning and practice, I'll revisit this piece.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["study","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 stars(vec2 uv, ivec2 density) {\n    vec2 blockIndex = floor(uv*vec2(density));\n    vec2 blockDim = 1.0/vec2(density);\n    vec2 uvOnBlock = mod(uv, blockDim)/blockDim;\n    \n    int blockNum = int(blockIndex.x)+int(blockIndex.y)*density.x;\n    vec2 uvOnBlockOfStar = randv(blockNum);\n    \n    return vec4(\n        vec3(smoothstep(\n            mix(0.0015, 0.002, rand(int(len(uv)*19.0))), // star sizes\n            0.0,\n            len((uvOnBlockOfStar-uvOnBlock)*blockDim*vec2(ar, 1.0)) // star position\n        ))*mix( // star colors\n            vec3(1.0, 0.6, 0.5),\n            vec3(0.5, 0.6, 1.0),\n            rand(int(len(uvOnBlockOfStar)*27.0))\n        ),\n        1.0)*vec4(0.2*sin(iTime*30.0*(rand(int(len(uvOnBlockOfStar)))+1.0))+0.8); // blink\n}\n\nvec4 bgColor(vec2 uv, vec2 posOffset, float progress) {\n    float x = abs(uv.x-0.5-posOffset.x);\n    uv.y -= posOffset.y;\n    progress = smoothstep(0.0, 0.5, progress)*pow(progress, 0.5);\n    vec3 p = vec3( // Poor man's, purely visual, imitation of Rayleigh scattering effect\n        smoothstep(0.0, mix(0.02, 0.4*x+0.02, progress), (uv.y - pow(x/50.0, 20.0/mix(1.0, 30.0, progress) ))),\n        smoothstep(0.0, mix(0.02, 0.2*x+0.02, progress), (uv.y - pow(x/50.0, 20.0/mix(1.0, 31.0, progress) ))),\n        smoothstep(0.0, mix(0.02, 0.3*x+0.02, progress), (uv.y - pow(x/50.0, 20.0/mix(1.0, 32.0, progress) )))\n    );\n    \n    vec3 orangeC = mix(vec3(1.0, 0.3, 0.0), vec3(1.0, 0.6, 0.2), uv.y);\n    vec3 darkSkyColor = mix(vec3(0.3, 0.0, 0.05), vec3(0.0), clamp(pow(uv.y+0.1, 1.0/12.0), 0.0, 1.0) );\n    vec3 lowAtmoColor = mix(vec3(0.1, 0.3, 0.7), vec3(0.015, 0.01, 0.1), progress);\n    vec3 finalColor = mix(mix(lowAtmoColor, mix(orangeC, darkSkyColor, progress), p), vec3(0.0), pow(progress, 15.0));\n    float alpha = mix(1.0, 1.0-clamp(pow(uv.y+posOffset.y, 0.25), 0.0, 1.0), progress*progress*progress);\n    return vec4(finalColor*alpha, alpha);\n}\n\nvec4 ocean(vec2 uv, float oceanHeight, float progress) {\n    vec4 color = vec4(\n        mix(vec3(0.05, 0.3, 0.65), vec3(0.0, 0.0, 0.01), vec3(pow(progress, 0.5), pow(progress, 0.5), progress)),\n        smoothstep(0.0, 0.01, oceanHeight-uv.y)\n    );\n    color.rgb *= color.a;\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    ar = iResolution.x/iResolution.y;\n    \n    float animProgress = min(iTime/35.0, 1.0); // The entire animation lasts 35s, but the stars keep blinking forever\n    const float oceanHeight = 0.185;\n\n    // Atmos FX\n    vec4 color = bgColor(uv, vec2(0.25, oceanHeight-0.085), animProgress);\n    vec4 reflectionColor = vec4(0.0);\n    \n    // Sun\n    float sunAlpha = circle(uv, vec2(0.75, mix(0.33, 0.1, animProgress)), 0.025);\n    color = composite(\n        color,\n        vec4(\n            mix(vec3(1.0, 0.9, 0.6), vec3(1.0, 0.3, 0.15), animProgress*2.5)*sunAlpha,\n            sunAlpha\n        )\n    );\n    float reflectionSunAlpha = circle(rippleUV(uv*vec2(1.0, -1.0), iTime), vec2(0.75, mix(0.33, 0.1, animProgress)-2.0*oceanHeight+0.01), 0.025);\n    reflectionColor = composite(\n        reflectionColor,\n        vec4(\n            mix(vec3(1.0, 0.9, 0.6), vec3(1.0, 0.3, 0.15), animProgress*2.5)*reflectionSunAlpha,\n            reflectionSunAlpha\n        )\n    );\n    \n    // Ocean\n    vec4 oceanColor = ocean(uv, oceanHeight, animProgress);\n    color = composite(color, oceanColor);\n    \n    // Ocean reflection\n    color = composite(color, reflectionColor*oceanColor.a*0.25);\n\n    // Output to screen\n    color = composite(stars(uv, ivec2(10, 10)), color);\n    fragColor = pow(color, vec4(1./2.2));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926\n\nfloat ar;\n\nfloat len(vec2 v) {\n    return sqrt(v.x*v.x + v.y*v.y);\n}\n\nfloat rand(int seed) {\n    float p0 = 3.0;\n    float p1 = 7.0;\n    return fract(999.0*sin(2.0*PI*mod(float(seed)*p0, p1)/p1));\n}\n\nvec2 randv(int seed) {\n    float p3 = 11.0;\n    float p4 = 13.0;\n    float p5 = 17.0;\n    float n = mod(float(seed)*p3, p4)/p4;\n    return vec2(rand(seed), rand(seed*int(p5*n)));\n}\n\nfloat circle( vec2 uv, vec2 pos, float r) {\n    return smoothstep(1.0, 0.0, (len((pos-uv)*vec2(ar, 1.0))-r)*200.0);\n}\n\nvec4 composite(vec4 underLayer, vec4 overLayer) {\n    return overLayer + underLayer*(1.0-overLayer.a);\n}\n\nvec2 rippleUV(vec2 uv, float iTime) {\n    float rippleLength = 0.0075;\n    float sidewaysIntensity = 0.002*sin(uv.y*2.*PI/rippleLength - iTime*0.75);\n    uv.x += sidewaysIntensity;\n    \n    float center = 0.185;\n    uv.y = (uv.y+center)*0.925-center;\n    \n    return uv;\n}\n","name":"Common","description":"","type":"common"}]}