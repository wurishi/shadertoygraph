{"ver":"0.1","info":{"id":"MXfBDH","date":"1728328332","viewed":14,"name":"3D egg wars cubemap","username":"cesio","description":"Forked from 3D egg wars - Lambert light with cubemap added","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","spheres"],"hasliked":0,"parentid":"MXlBR7","parentname":"3D egg wars - Lambert light"},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define PRECISION 0.001\n#define MIN 0.\n#define MAX_MARCHING_STEPS 10\n#define N_Z 5\n#define N_X 4\n#define N_Y 5\n#define EPSILON 0.0005\n#define RADIUS 0.2\n#define A 0.5\n#define sqrtA 1.4142135\n\n\n// taken from thebookofshaders.com\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\n// return a distance from point p and a sphere with center c and radius r\nfloat sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n\n// vector normal to sphere with cener c and radius r\nvec3 calcNormal(vec3 p, vec3 c, float r) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n // float r = 1.; // radius of sphere\n  return normalize(\n    e.xyy * sphere(p + e.xyy, c, r) +\n    e.yyx * sphere(p + e.yyx, c, r) +\n    e.yxy * sphere(p + e.yxy, c, r) +\n    e.xxx * sphere(p + e.xxx, c, r));\n}\n\n\nstruct MarchResult {\n    bool hasHit;\n    float hitPos;\n};\n\nMarchResult rayMarchSphere(vec3 ro, vec3 rd, vec3 sphereCenter, float sphereRadius, float start, float end) {\n    float d = start; // depth at which an object 'was found'\n    MarchResult res;\n    res.hitPos = d;\n    res.hasHit = false;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 probe = ro + d * rd; // probe 'pixel'\n        \n        float distF = sphere(probe, sphereCenter, sphereRadius); // distF is a distance from an object sphere with given parameters\n        d += distF;\n        \n        if (distF < PRECISION || distF > end) { // either we 'hit' the object or passed it without hitting\n            if (distF < PRECISION) { // we 'hit' the object\n                res.hasHit = true;\n                res.hitPos = d;\n            }\n            \n            break;\n        }\n        \n    }\n    \n    return res;\n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end, vec3 lightPosition) {\n    float col = 0.;\n    float dZ = 5. / float(N_Z);\n    float dX = 4. / float(N_X);\n    float dY = 3. / float(N_Y);\n   \n    \n    // iterate ove N_Z spheres over Z axis (depth)\n    float posZ = 0. - floor(iTime);  \n\n    for (int k = 0; k < N_Z; k++) {\n        MarchResult d;\n        // iterate ove N_X spheres over X axis (horiz)\n        float posX = -1.2;\n        for (int i = 0; i < N_X; i++) {\n            // iterate ove N_Y spheres over Y axis (vert)\n            float posY = -1.;\n            for (int j = 0; j < N_Y; j++) {\n                vec3 sphereCenter = vec3(posX, posY, posZ);\n                d = rayMarchSphere(ro, rd, sphereCenter, RADIUS, start, end); \n\n                if (d.hasHit) {// we did hit' the sphere at distance 'd'\n                    vec3 hitPosition = ro + rd * d.hitPos; // point on a sphere we 'hit'\n                    vec3 normalToSphereVector = calcNormal(hitPosition, sphereCenter, RADIUS);\n                    vec3 lightVector = normalize(lightPosition - hitPosition);\n                    float light = clamp(dot(normalToSphereVector, lightVector), 0., 5.);\n                    // the further the darker\n                    light = light - clamp(light, 0., d.hitPos / 4.4); \n                    col += light;\n                   // break; // this is to break as soon as we hit the first object - remove transparency\n                }\n                posY += dY;\n            } // end of vertical loop \n           // if (d.hasHit) break; // this is to break as soon as we hit the first object - remove transparency\n            posX += dX;\n        } // end of horizontal loop\n       // if (d.hasHit) break; // this is to break as soon as we hit the first object - remove transparency\n        posZ -= dZ;\n    } // end of depth loop\n  \n    return clamp(col, 0., 1.);\n}\n\n// taken from the book of shader - same shaping function\nfloat someShapingFunction() {\n    float amplitude = 2.;\n    float frequency = 1.;\n    float x = iTime;\n    float y = sin(x * frequency);\n    float t = 0.01*(-iTime*130.0);\n    y += sin(x*frequency*2.1 + t)*4.5;\n    y += sin(x*frequency*1.72 + t*1.121)*4.0;\n    y += sin(x*frequency*2.221 + t*0.437)*5.0;\n    y += sin(x*frequency*3.1122+ t*4.269)*2.5;\n    y *= amplitude*0.06;\n    return y;\n}\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // uv = rotate2d( sin(iTime)*PI ) * uv;   // basic sinus-based camera movement\n    float shapedValue = someShapingFunction(); // more fancy shaping function camera movement\n    uv = uv * rotate2d(shapedValue); // more interesting function used to rotate camera\n    \n    // play with camera location\n    float posX = (A * sqrtA * cos(iTime )) / (1. + pow(sin(iTime ),2.));\n    float posY = (A * sqrtA * cos(iTime ) * sin(iTime )) / (1. + pow(sin(iTime),2.)) * 1.5;\n    float posZ = 1.2 - iTime - shapedValue / 2.;\n\n    vec3 ro = vec3(posX, posY, posZ); // ray origin (camera position)\n    vec3 lightPosition = vec3(posX, posY, posZ + 1.); // our light vector is following the observator and is behind him\n   \n    //vec3 lightPosition = vec3(posX, posY, 4); // our light vector is 'in front' of the scene\n    vec3 lookAt = vec3(0.,0., posZ - 5.);\n    vec3 rd = camera(ro, lookAt) * normalize(vec3(uv, -1.));\n\n    float d = rayMarch(ro, rd, 0., 5., lightPosition); // usually 5 is not enough for a ray marching but in our scene it works OK and speed calculations up\n   \n    vec3 bgCol = texture(iChannel0, vec3(rd.x, rd.y + 0.9, rd.z + 0.1)).xyz;\n    vec3 col = vec3(d) + bgCol;\n  \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}