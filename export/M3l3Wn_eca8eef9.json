{"ver":"0.1","info":{"id":"M3l3Wn","date":"1707365426","viewed":27,"name":"Parametric Vase","username":"vlsh","description":"Model for 3d printing translated into a model in Python.\n\nhttps://gist.github.com/evilactually/f142b526b4591854aaeeb1f169304cfe","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","3dprinting"],"hasliked":0,"parentid":"7tKfWh","parentname":"Quadric Gargle blaster"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 500\n#define MAX_DIST 300.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdfPolarLoft(vec3 p) {\n    // get angle\n    float angle = atan(p.z,p.x);\n    p.y *= 0.4;\n    float r = (0.5 + p.y*p.y*0.3 + 0.06*sin(p.y*8.0 + angle*10.0) );\n    float d = sqrt(p.x*p.x + p.z*p.z) - r;\n    return d;\n}\n\nfloat sdfSurface(vec3 p) {\n    p += vec3(1.9, 0.0, 0.0);\n    return p.y - (-3.65 + 0.2*pow(p.x,2.0) + 2.0*p.y );\n}\n\n// generic ellipsoid - improved approximated distance\n// https://www.shadertoy.com/view/tdS3DG\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat GetDist(vec3 p) {\n    //float d = sdBox(p, vec3(1));\n    float d;\n    \n    //float y = p.y;\n    //d = length(p.zx) - pow(((1.0-y)*y*y*y*y),2.0*sqrt(iTime/2.0));\n    //d = max(length(p.zx)-2.0,d);\n    //d *= 0.1;\n    \n    float bottom = 3.0 - 0.1*2.0;\n    float thickness = 0.05*smoothstep(4.2,2.0,p.y);\n    if (p.y > -bottom) \n    {\n        d = abs(sdfPolarLoft(p)) - thickness;\n    } \n    else {\n        d = sdfPolarLoft(p) - thickness;\n        if (d < 0.0) d = p.y + bottom;\n    }\n    \n    d = max(p.y - 3.7, d);\n    d = max(-p.y - 3.0, d);\n    \n    d = max(-p.z, d);\n    \n    float s = sdfSurface(p);\n    \n    d = max(d,-s);\n    \n    float er = 1.3;\n    d = max(d, -sdEllipsoid(p + vec3(0.0,3.5 - 0.1,0.0), vec3(er,0.5,er)));\n    \n    return d*0.1;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 50, -2);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 5.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n\n// UGLY PYTHON\n/*\nfrom sdf import *\n\ndef smoothstep(x, edge0=0, edge1=1):\n    # Scale x to the range between edge0 and edge1\n    x = np.clip((x - edge0) / (edge1 - edge0), 0.0, 1.0)\n    # Smooth interpolation function (Hermite interpolation)\n    return x * x * (3 - 2 * x)\n\ndef _vec(*arrs):\n    return np.stack(arrs, axis=-1)\n\ndef _length(a):\n    return np.linalg.norm(a, axis=1)\n\n\ndef sdfSurface2(p):\n    p = p + _vec(1.9, 0.0, 0.0)\n    return p[:,1] - (-3.65 + 0.2*np.power(p[:,0],2.0) + 2.0*p[:,1]  )\n\n\ndef sdfEllipsoid(p, r):\n    k0 = _length(p/r)\n    k1 = _length(p/(r*r))\n    return k0*(k0-1.0)/k1\n\n\n@sdf3\ndef vase(radius=1, center=ORIGIN):\n    def f(p):\n        x = p[:,0]\n        y = p[:,1]*0.4\n        z = p[:,2]\n\n        angle = np.arctan2(z,x)\n        r = 0.5 + 0.3*np.square(y)  + 0.06*np.sin(y*8.0  + angle*10.0)\n\n        d = _length(p[:,[0,2]]) - r\n\n        thickness = 0.05*smoothstep(y/0.4,4.2,2.0);\n\n        bottom = 3.0 - 0.1*2.0\n        d = np.where(p[:,1] > -bottom, \n            np.abs(d) - thickness,\n            np.where(d - thickness + 0.01 < 0, p[:,1] + bottom, d - thickness))\n\n        d = np.maximum(p[:,1]-3.7,d)\n        d = np.maximum(-p[:,1]-3.0,d)\n\n        d = np.maximum(d, -sdfSurface2(p) )\n\n        #d = np.maximum(-p[:,0]-0.0,d)\n        er = 1.3\n        d = np.maximum(d, -sdfEllipsoid(p + _vec(0.0,3.5-0.1,0.0), _vec(er,0.5,er)))\n\n        return d\n    return f\n\nf = vase(1)\n\nf.save('vase.stl', step=0.01,bounds=((-4, -5, -4), (4, 5, 4)))\n*/","name":"Image","description":"","type":"image"}]}