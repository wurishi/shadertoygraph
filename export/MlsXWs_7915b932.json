{"ver":"0.1","info":{"id":"MlsXWs","date":"1440781604","viewed":470,"name":"quaternion julia/distance field","username":"kejran","description":"apparently it does not work properly for some people. i will try to fix (reduce branching maybe?) it later.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","julia","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define JULIA_IT 10\n\n//#define USE_WSHIFT\n\n#define C vec4(-0.7, 0.3, 0.10, 0.0)\n\n#define RAY_IT 100\n#define EPSILON 0.002\n#define NORMAL_STEP 0.00001\n\n#define FOV 0.8\n#define SPEED 0.4\n#define DISTANCE 1.5\n#define BURN_THRESH 0.90\n#define BURN_INTENSITY 4.0\n#define TIMESCALE 1.0\n\nvec4 quat_mul (vec4 a, vec4 b) {\n\treturn vec4(\n        a.x*b.x - a.y*b.y - a.z*b.z - a.w*b.w, \n        a.x*b.y + a.y*b.x - a.z*b.w + a.w*b.z, \n        a.x*b.z + a.y*b.w + a.z*b.x - a.w*b.y, \n        a.x*b.w - a.y*b.z + a.z*b.y + a.w*b.x);\n}\n\nfloat julia_distance (in vec4 coords) {\n    vec4 derivative = vec4(1.0);\n    for (int i=0; i<JULIA_IT; i++) {\n        derivative = 2.0 * quat_mul(coords, derivative);\n        coords = quat_mul(coords, coords) + C \n        #ifdef USE_WSHIFT\n            + vec4(0.0, 0.0, 0.0, 0.2*sin(TIMESCALE *  0.2 * iTime))\n            + vec4(0.2, 0.2, 0.4*cos(TIMESCALE *  0.2 * iTime), 0.0)\n        #endif\n        ;\n        \n        if (dot(coords, coords) > 4.0) break;\n    }\n    return sqrt(dot(coords, coords)/dot(derivative, derivative)) * log(sqrt(dot(coords, coords)));\n}\n\nvec4 julia_gradient (vec4 coords) {\n    return normalize(vec4(\n        julia_distance(coords+vec4(-NORMAL_STEP, 0.0, 0.0, 0.0)) -\n        julia_distance(coords+vec4(NORMAL_STEP, 0.0, 0.0, 0.0)),\n        julia_distance(coords+vec4(0.0, -NORMAL_STEP, 0.0, 0.0)) -\n        julia_distance(coords+vec4(0.0, NORMAL_STEP, 0.0, 0.0)),\n        julia_distance(coords+vec4(0.0, 0.0, -NORMAL_STEP, 0.0)) -\n        julia_distance(coords+vec4(0.0, 0.0, NORMAL_STEP, 0.0)),\n        0.0//WHO CARES\n    ));\n}\n\nbool raycast_distance (vec3 ray, vec3 origin, out vec3 normal) {\n    \n    vec4 derivative;\n    vec3 pos = origin;    \n    derivative = vec4(1.0);\n\n    for (int i=0; i<RAY_IT; i++) {\n        float dist = julia_distance(vec4(pos, 0.0));        \n    \tpos += ray*dist;\n        if (dist < EPSILON) {\n            normal = -julia_gradient(vec4(pos, 0.0)).xyz;\n            return true;\n        }\n        if (dot(pos, pos)>4.0) break;  \n    }\n    return false;\n}\n\nvec3 env(vec3 at) { // we bump up the highlights by blowing up the [0.9,1.0] range a few times\n    vec3 map =  pow(texture(iChannel0, at).xyz, vec3(2.2));  \n    return mix(map, \n               BURN_THRESH+BURN_INTENSITY*smoothstep(vec3(BURN_THRESH), vec3(1.0), map), \n               step(vec3(BURN_THRESH), map));\n}\n\n\nfloat fresnel(float r0, float cosine) {\n    if (cosine < 0.0) return 0.0;\n    return mix(r0, 1.0, pow(1.0-cosine,5.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\t\n   \tfloat aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = FOV * vec2(aspect * (2.0*uv.x-1.0), 2.0*uv.y-1.0);\n    \n    float itime = sin(TIMESCALE * iTime);\n    \n    vec3 origin = vec3(\n        DISTANCE*sin(itime*SPEED), \n        0.6*cos(TIMESCALE * 0.3 * iTime)-0.2, \n        DISTANCE*cos(itime*SPEED));\n    \n    vec3 look_vec = normalize(-origin);\n    vec3 x_ = normalize(cross(look_vec, vec3(0.0, 1.0, 0.0)));\n    vec3 y_ = normalize(cross(look_vec, -x_));                        \n    vec3 look = normalize(look_vec+uv.x*x_+uv.y*y_);\n    \n    vec3 normal;\n    vec3 colour = raycast_distance(look, origin, normal) ?\n        mix(\n            vec3(0.0),\n            env(reflect(look, normal)),\n            fresnel(0.0, dot(normal, -look))\n        ) :\n        env(look);\n\n    colour *= 1.5*smoothstep(3.0, 0.0, length(uv));\n    colour = pow(colour, vec3(0.9,0.95, 1.0))*vec3(1.1,1.0,1.0)+vec3(0.0, 0.0, 0.02);\n    \n\tfragColor = vec4(pow(colour, vec3(1.0/2.2)), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}