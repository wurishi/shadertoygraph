{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\n\nvec3 tankTowerPosition = vec3(0.0, 0.2, 1.0);\nvec3 tankMuzzlePosition = vec3(0.0, 0.3, 0.3);\nvec3 tankMuzzleDirection = vec3(0.0, 0.0, 1.0);\nfloat tankTowerRotationY = 0.0;\nfloat tankTowerRotationX = 0.0;\n\nfloat cameraRotationX = 0.0;\nfloat cameraRotationY = 0.0;\n\nbool isFired = false;\nfloat lastFiredTime = -1.0;\n\nvec3 shellPosition;\nfloat shellVelocity = 1.0;\n\nvec3 floorColor = vec3(0.0);\n\nstruct Surface {\n    float sd;\n    vec3 col;\n};\n\nSurface sdBox(vec3 p, vec3 b, vec3 offset, vec3 col, mat3 transform) {\n    p = (p - offset) * transform;\n    vec3 q = abs(p) - b;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return Surface(d, col);\n}\n\nSurface sdRoundBox(vec3 p, vec3 b, float r, vec3 offset, vec3 col, mat3 transform) {\n    p = (p - offset) * transform;\n    vec3 q = abs(p) - b + r;\n    float d = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n    return Surface(d, col);\n}\n\nSurface sdFloor(vec3 p, vec3 col) {\n    float d = p.y + 0.0;\n    return Surface(d, col);\n}\n\nSurface minWithColor(Surface obj1, Surface obj2) {\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface sdScene(vec3 p) {\n    floorColor = vec3(1.0 + 0.7 * mod(floor(p.x) + floor(p.z), 1.0)) * vec3(0.1, 0.5, 0.1);\n    Surface co = sdFloor(p, floorColor);\n    co = minWithColor(co, sdRoundBox(p, vec3(0.3, 0.2, 0.5), 0.05, tankTowerPosition - vec3(0., 0.2, 0.), vec3(0.5, 0.6, 0.2), identity()));\n    co = minWithColor(co, sdRoundBox(p, vec3(0.2, 0.2, 0.2), 0.05, tankTowerPosition, vec3(0.3, 0.4, 0.0), rotateY(sin(tankTowerRotationY)) * rotateX(sin(tankTowerRotationX))));\n    co = minWithColor(co, sdRoundBox(p, vec3(0.03, 0.03, 0.5), 0.05, tankTowerPosition + tankMuzzleDirection, vec3(0.3, 0.4, 0.0), rotateY(sin(tankTowerRotationY)) * rotateX(sin(tankTowerRotationX))));\n    if (isFired) {\n        co = minWithColor(co, sdBox(p, vec3(0.05), shellPosition, vec3(0.5, 0.5, 0.5), identity()));\n    }\n    vec3 secondTankOffset = vec3(5.0, 0.0, -9.0);\n    co = minWithColor(co, sdRoundBox(p, vec3(0.3, 0.2, 0.5), 0.05, vec3(5, 0, -8), vec3(0.5, 0.6, 0.2), identity()));\n    co = minWithColor(co, sdRoundBox(p, vec3(0.2, 0.2, 0.2), 0.05, vec3(5, 0.2, -8), vec3(0.3, 0.4, 0.0), identity()));\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    Surface co;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = sdScene(p);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > end) break;\n    }\n    co.sd = depth;\n    return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * sdScene(p + e.xyy).sd +\n        e.yyx * sdScene(p + e.yyx).sd +\n        e.yxy * sdScene(p + e.yxy).sd +\n        e.xxx * sdScene(p + e.xxx).sd\n    );\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    return mat3(-cr, cu, -cd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 backgroundColor = vec3(0.835, 1.0, 1.0);\n    \n    tankTowerRotationX = texture(iChannel1, vec2(0, 0)).w;\n    tankTowerRotationY = texture(iChannel1, vec2(0, 0)).z;\n    isFired = bool(int(texelFetch(iChannel1, ivec2(0, 0), 0).y));\n    tankMuzzleDirection = tankMuzzlePosition - tankTowerPosition;\n    tankMuzzleDirection *= rotateY(-sin(tankTowerRotationY)) * rotateX(-sin(tankTowerRotationX));\n    shellPosition = texelFetch(iChannel1, ivec2(0, 1), 0).xyz;\n    //cameraRotationX = texelFetch(iChannel1, ivec2(0, 4), 0).x;\n    //cameraRotationY = texelFetch(iChannel1, ivec2(0, 4), 0).y;\n    tankTowerPosition = vec3(texelFetch(iChannel1, ivec2(0, 5), 0).x, texelFetch(iChannel1, ivec2(0, 5), 0).y, texelFetch(iChannel1, ivec2(0, 5), 0).z);\n    tankMuzzlePosition = vec3(texelFetch(iChannel1, ivec2(0, 6), 0).x, texelFetch(iChannel1, ivec2(0, 6), 0).y, texelFetch(iChannel1, ivec2(0, 6), 0).z);\n    \n    vec3 lp = tankTowerPosition;\n    vec3 ro = tankTowerPosition + vec3(0., 3., 2.5);\n    float cameraRadius = 1.7;\n    ro.x = cameraRadius * -sin(tankTowerRotationY) + lp.x;\n    ro.y = cameraRadius * sin(tankTowerRotationX) + 4. * lp.y;\n    //ro.z = cameraRadius * cos(tankTowerRotationY) + lp.z;\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n    \n    Surface co = rayMarch(ro, rd, MIN_DIST, MAX_DIST);\n    \n    vec3 col = backgroundColor;\n    if (co.sd > MAX_DIST) {\n        col = backgroundColor;\n    } else {\n        vec3 p = ro + rd * co.sd;\n        vec3 normal = calcNormal(p);\n        vec3 lightPosition = vec3(2, 2, 1);\n        vec3 lightDirection = normalize(lightPosition - p);\n        float dif = clamp(dot(normal, lightDirection), 0.3, 1.0);\n        col = dif * co.col + backgroundColor * 0.2;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nvec3 gravity = 1.0 * vec3(0.0, -9.81, 0.0);\nfloat initialVelocity = 35.0;\nvec3 tankTowerPosition = vec3(0.0, 0.2, 1.0);\nvec3 tankTowerPositionOffset = vec3(0., 0., 0.);\nvec3 tankMuzzlePositionOffset = vec3(0., 0., 0.);\nvec3 tankMuzzlePosition = vec3(0, 0.3, 0.3);\nvec3 secondTankOffset = vec3(5.0, 0.0, -9.0);\nvec3 shellPosition = vec3(-0.5, 0.1, 1.0);\nvec3 shellVelocity = vec3(0.0);\n\nfloat tankTowerRotationX = 0.0;\nfloat tankTowerRotationY = 0.0;\nconst float tankTowerRotationVelocity = 0.01;\nconst float tankSpeed = 0.01;\n\nfloat cameraRotationX = 0.0;\nfloat cameraRotationY = 0.0;\nconst float cameraRotationSpeed = 0.01;\n\nbool isFired = false;\nfloat lastFiredTime = 0.0;\n\nconst int keyA = 65;\nconst int keyD = 68;\nconst int keyS = 83;\nconst int keyW = 87;\nconst int keySpace = 32;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nvec2 inputKeyboard(float tankTowerRotationX, float tankTowerRotationY) {\n    float left = texelFetch(iChannel1, ivec2(keyA, 0), 0).x * -1.0;\n    float right = texelFetch(iChannel1, ivec2(keyD, 0), 0).x * 1.0;\n    float newOffsetX = tankTowerRotationX + (left + right) * tankTowerRotationVelocity;\n    \n    float up = texelFetch(iChannel1, ivec2(keyW, 0), 0).x * -1.0;\n    float down = texelFetch(iChannel1, ivec2(keyS, 0), 0).x * 1.0;\n    float newOffsetY = tankTowerRotationY + (up + down) * tankTowerRotationVelocity;\n    \n    return vec2(newOffsetX, newOffsetY);\n}\n\nvec2 tank_inputKeyboard(float tankX, float tankZ) {\n    float forw = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x;\n    float back = texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x;\n    float left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x;\n    float right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x;\n    tankX += (right - left) * tankSpeed;\n    tankZ += (forw - back) * tankSpeed;\n    \n    return vec2(tankX, tankZ);\n}\n\nbool isTankFired() {\n    float space = texelFetch(iChannel1, ivec2(keySpace, 0), 0).x;\n    return space != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame != 0) {\n        tankTowerRotationX = texture(iChannel0, vec2(0, 0)).z;\n        tankTowerRotationY = texture(iChannel0, vec2(0, 0)).w;\n        isFired = bool(int(texelFetch(iChannel0, ivec2(0, 0), 0).y));\n        lastFiredTime = float(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n        cameraRotationX = texelFetch(iChannel0, ivec2(0, 4), 0).x;\n        cameraRotationY = texelFetch(iChannel0, ivec2(0, 4), 0).y;\n        \n        tankTowerPosition = vec3(texelFetch(iChannel0, ivec2(0, 5), 0).x, texelFetch(iChannel0, ivec2(0, 5), 0).y, texelFetch(iChannel0, ivec2(0, 5), 0).z);\n        tankMuzzlePosition = vec3(texelFetch(iChannel0, ivec2(0, 6), 0).x, texelFetch(iChannel0, ivec2(0, 6), 0).y, texelFetch(iChannel0, ivec2(0, 6), 0).z);\n        \n        shellPosition = texelFetch(iChannel0, ivec2(0, 1), 0).xyz;\n        shellVelocity = texelFetch(iChannel0, ivec2(0, 3), 0).xyz;\n    }\n    \n    tankTowerRotationX = clamp(inputKeyboard(tankTowerRotationX, tankTowerRotationY).x, -0.9, 0.9);\n    tankTowerRotationY = clamp(inputKeyboard(tankTowerRotationX, tankTowerRotationY).y, -0.2, 0.1);\n    \n    tankTowerPositionOffset = vec3(tank_inputKeyboard(0., 0.).x, 0., tank_inputKeyboard(0., 0.).y);\n    tankMuzzlePositionOffset = tankTowerPositionOffset;\n    tankTowerPosition += tankTowerPositionOffset;\n    tankMuzzlePosition += tankMuzzlePositionOffset;\n    \n    //cameraRotationX = clamp(cam_inputKeyboard(cameraRotationX, cameraRotationY).x, -1.5, 1.5);\n    //cameraRotationY = clamp(cam_inputKeyboard(cameraRotationX, cameraRotationY).y, -3.14, 3.14);\n\n    if (isTankFired() && !isFired) {\n        vec3 currentTankMuzzleDirection = normalize(tankMuzzlePosition - tankTowerPosition);\n        currentTankMuzzleDirection *= rotateY(-sin(tankTowerRotationX)) * rotateX(-sin(tankTowerRotationY));\n\n        shellVelocity = initialVelocity * currentTankMuzzleDirection;\n\n        lastFiredTime = iTime;\n        shellPosition = tankTowerPosition + currentTankMuzzleDirection;\n        isFired = true;\n    }\n    \n    if (isFired) {\n        float flightTime = iTimeDelta;\n        \n        shellPosition += shellVelocity * flightTime;\n        \n        shellVelocity += gravity * flightTime;\n\n        if (shellPosition.y < 0.0 || shellPosition.y > 15.0 || shellPosition.z < -15.0) {\n            isFired = false;\n            shellPosition.y = 0.0;\n        }\n    }\n\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 0) {\n        fragColor = vec4(lastFiredTime, int(isFired), tankTowerRotationX, tankTowerRotationY);\n    }\n\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 1) {\n        fragColor = vec4(shellPosition, 1.0);\n    }\n\n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 3) {\n        fragColor = vec4(shellVelocity, 1.0);\n    }\n    \n    //if (int(fragCoord.x) == 0 && int(fragCoord.y) == 4) {\n        //fragColor = vec4(cameraRotationX, cameraRotationY, 0.0, 0.0);\n    //}\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 5) {\n        fragColor = vec4(tankTowerPosition.x, tankTowerPosition.y, tankTowerPosition.z, 1.0);\n    }\n    \n    if (int(fragCoord.x) == 0 && int(fragCoord.y) == 6) {\n        fragColor = vec4(tankMuzzlePosition.x, tankMuzzlePosition.y, tankMuzzlePosition.z, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XcGfzR","date":"1734973736","viewed":19,"name":"CG_2(3D)","username":"AmuroVP","description":"3D tanks","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["hw2"],"hasliked":0,"parentid":"","parentname":""}}