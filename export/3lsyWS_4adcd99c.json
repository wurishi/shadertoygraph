{"ver":"0.1","info":{"id":"3lsyWS","date":"1592943845","viewed":267,"name":"Kelp forest bubbles","username":"jarble","description":"This is based on my [url=https://www.shadertoy.com/view/tlscRs]\"Rainy jungle\"[/url] shader, but it looks more like a kelp forest.","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","bubbles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define t iTime\n#define r iResolution\nint surface_color;\n\n//Based on https://www.shadertoy.com/view/3tXyRN\n\nvec3 jungle_color(vec3 p)\n{\n    vec2 uv = vec2(p.x,p.y)/(400.0);\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+p.z)/2.0));\n    vec2 col2;\n    uv += ceil(col+sin((col.x+col.y)));\n    col /= sin(uv.x);\n    col2 = col2+col;\n    // Output to screen\n    return sin(vec3(0.5+uv.y/500.0,col2.x,uv.x/500.0));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\nvec3 animate_rain(vec3 p){\n    p.y -= iTime*200.0;\n    vec3 p1 = p/100.0;\n    p += vec3(sin(p1+p1.yzx))*33.33;\n    return p;\n}\n\nvec3 rain_color(in vec3 uv)\n{\n    //uv /= scale;\n    uv = animate_rain(uv);\n    //uv /= scale;\n    \n    uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(sin(vec2(uv.x, uv.y)));\n        uv.x = uv.y + uv.x;\n        uv.y = uv.x - uv.y;\n    }\n    return vec3((lar * .5), lar*.7, lar)*1.5;\n}\n\n\nfloat rainSDF(vec3 p) {\n    p *= 5.0;\n    p = animate_rain(p);\n\n    float to_return = 3.9 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n    return to_return;\n}\n\n\nfloat jungleSDF(vec3 p) {\n    p /= 40.0;\n    p = p + (sin(p.yzx)-sin(p/(50.0)))*10.0;\n    return  3.9 + sin((p.x/2.0+p.y+p.z/3.0))*3.0+sin(p.z)*1.5;\n}\n\nfloat sceneSDF(vec3 p){\n    float jungle = jungleSDF(p);\n    float rain = rainSDF(p);\n\tfloat to_return = min(jungle,rain);\n    if(to_return == jungle){\n    \tsurface_color = 1;\n    }\n    else{\n    \tsurface_color = 2;\n    }\n    return to_return;\n}\n\nvec3 surface_color1(vec3 p){\n    if(surface_color == 1){\n    \treturn jungle_color(p);\n    }\n    else if(surface_color == 2){\n    \treturn rain_color(p);\n    }\n}\n\nvoid mainImage( out vec4 o, in vec2 U )\n{\n    float scale = .1;\n    vec3 d=vec3(U/r.xy-.5,.5),p=vec3(0,6,t),q;\n    const int iterations = 99;\n    for(int i=0;i<iterations;i++)\n    {\n        p+=d*sceneSDF(p/scale)*scale;\n        if(i==iterations-5)q=p+=d=vec3(.6);\n    }\n    o+=vec4(surface_color1(p*5.0)/5.0,0)*length(p-q)+(p.z-t)/float(iterations/3);\n}","name":"Image","description":"","type":"image"}]}