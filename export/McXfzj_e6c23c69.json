{"ver":"0.1","info":{"id":"McXfzj","date":"1724019399","viewed":64,"name":"Chessboard with spheres","username":"vivid_bw","description":"Reflective spheres are flying between two chessboard planes","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["reflection","spheres","chessboard"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotX(float angle) {\n    float s = sin(angle); float c = cos(angle);\n    return mat3(1., 0., 0., 0., c, s, 0., -s, c);\n}\n\nmat3 rotY(float angle) {\n    float s = sin(angle); float c = cos(angle);\n    return mat3(c, 0., -s, 0., 1., 0., s, 0.0, c);\n}\n\nmat3 rotZ(float angle) {\n    float s = sin(angle); float c = cos(angle);\n    return mat3(c, s, 0., -s, c, 0., 0., 0., 1.);\n}\n\nstruct Ray\n{\n    vec3 start;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nstruct Intersection\n{\n    float time;\n    vec3 pos;\n    vec3 normal;\n    vec4 color;\n};\n\nconst float Infinity = 1e20;\n\nIntersection crossSphere(Sphere sphere, Ray ray)\n{\n    Ray rayInv = ray;\n    // transform ray to make sphere\n    rayInv.start -= sphere.center;\n    rayInv.start /= sphere.radius;\n    rayInv.dir /= sphere.radius;\n    \n    float a = dot(rayInv.dir, rayInv.dir);\n    float b = dot(rayInv.start, rayInv.dir);\n    float c = dot(rayInv.start, rayInv.start) - 1.;\n    float d = b * b - a * c;\n    float t = (-b - sqrt(d)) / a;\n    if (d < 0. || t < 1e-5)\n    {\n        return Intersection(Infinity, vec3(0.), vec3(0.), vec4(1.));\n    }\n    vec3 pos = ray.start + t * ray.dir;\n    vec3 norm = normalize(pos - sphere.center);\n    return Intersection(t, pos, norm, vec4(1.));\n}\n\nvec4 shade(vec3 vnorm, vec3 lnorm, vec3 n, vec4 c, vec4 lc)\n{\n    vec4 diffuse = max(0., dot(n, lnorm)) * c;\n    vec3 r = reflect(-lnorm, n);\n    vec4 specular = pow(max(0., dot(vnorm, r)), 10.) * lc;\n    return diffuse + specular;\n}\n\nIntersection crossPlane(vec4 plane, Ray ray)\n{\n    float t = -dot(vec4(ray.start, 1.), plane) / dot(ray.dir, plane.xyz);\n    if (t < 1e-5 || t > Infinity)\n    {\n        return Intersection(Infinity, vec3(Infinity), normalize(plane.xyz), vec4(1.));\n    }\n    return Intersection(t, ray.start + ray.dir * t, normalize(plane.xyz), vec4(1.));\n}\n\n\nconst float Pi = 3.14159265;\n\nIntersection crossSpheres(Ray ray)\n{\n    Intersection best = Intersection(Infinity, vec3(0.), vec3(0.), vec4(1.));\n    for (float angle = 0.; angle < Pi + Pi - 1e-4; angle += Pi / 6.)\n    {\n        Intersection i = crossSphere(\n            Sphere(\n                1.2 * vec3(cos(angle + iTime), \n                    .3 * sin(3. * iTime + 2. * angle), \n                    sin(angle + iTime)), 0.2), ray);\n        if (i.time < best.time)\n        {\n            best = i;\n            best.color.rgb *= vec3(cos(angle * 1.5), sin(angle * 3.), sin(angle * 2.)) * .3 + .7;\n        }\n    }\n    return best;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord / iResolution.xy - 1.;\n    float rTime = max(0., iTime - 10.);\n    vec3 r = vec3(uv.x, uv.y * iResolution.y / iResolution.x,  1.);\n    r = r * rotX(-rTime * 0.5) * rotY(-rTime * .7) * rotZ(rTime * .3);\n    Ray ray = Ray(vec3(0.), r);\n    \n    vec4 shade = vec4(1.);\n    int iter = 3;\n    do\n    {\n        Intersection i = crossSpheres(ray);\n        if (i.time >= Infinity)\n        {\n            break;\n        }\n        ray.dir = reflect(ray.dir, i.normal);\n        ray.start = i.pos + 1e-5 * ray.dir;    \n        shade *= i.color;\n    } while (--iter > 0);\n    \n    Intersection i = crossPlane(vec4(0., 1., 0., -1.), ray);\n    if (i.time >= Infinity)\n    {\n        i = crossPlane(vec4(0., -1., 0., -1.), ray);\n    }\n    vec2 chess = fract((i.pos.xz) + 3. * vec2(cos(rTime), iTime)) - .5;\n\n    fragColor = vec4(sign(chess.x * chess.y)) * smoothstep(10., 1., length(i.pos)) * shade;\n\n}","name":"Image","description":"","type":"image"}]}