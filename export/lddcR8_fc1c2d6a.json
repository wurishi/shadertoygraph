{"ver":"0.1","info":{"id":"lddcR8","date":"1518141160","viewed":115,"name":"Tri-Colored Cube By Yuru Wang","username":"yuruwang","description":"finish time: 2/1/2018","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 translationMatrix(vec3 v) {\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                v.x, v.y, v.z, 1.0);\t\t\n}\n\nmat4 rotateX(float rad) {\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, cos(rad), sin(rad), 0.0,\n                0.0, -sin(rad), cos(rad), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float rad) {\n\treturn mat4(cos(rad), 0.0, -sin(rad), 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                sin(rad), 0.0, cos(rad), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\n\nmat2 rotateM(float rad) {\n    return mat2(cos(rad), sin(rad),\n                 -sin(rad), cos(rad));\n}\n\nfloat ease_in_quadratic(float t) {\n    return 0.0;\n}\n\nfloat ease_in_out_quadratic(float t) {\n    if (t < 0.5) {\n        return ease_in_quadratic(t * 2.0) / 2.0;\n    } else {\n        return 1.0 - ease_in_quadratic((1.0 - t) * 2.0) / 2.0;\n    }\n        \n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n    return length(max(abs(p)-b,0.0));\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    return udBox(samplePoint, vec3(1.0, 1.0, 1.0));\n}\n\nvec3 rayDirection(vec2 fragCoord, vec3 iResolution) {\n    return vec3(0.0, 0.0, -1.0);\n}\n\n\nfloat march(vec3 eyePos, vec3 rDir, float min_t, float max_t, float EPSILON, mat4 transM) {\n    const int MAX_MARCHING_STEPS = 255;\n\n    float t = min_t;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = eyePos + t * rDir;\n        \n        float PI = 3.14159265359;\n        vec3 transedP = vec3(inverse(transM) * vec4(p, 1.0));\n        float dist = sceneSDF(transedP);\n        if (dist < EPSILON) {\n            return t;\n        }\n        t += dist;\n\n        if (t >= max_t) {\n            return max_t;\n        }\n    }\n    return max_t;\n}\n\nvec3 estimateNormal(vec3 p) {\n    const float EPSILON = 0.0001;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float modTime = mod(iTime, 4.0);\n \tint mode = 0;   \n \n    if (modTime > 0.0 && modTime <= 1.0) {\n        mode = 1;\n    } else if (modTime > 1.0 && modTime <= 2.0) {\n        mode = 2;\n    } else if (modTime > 2.0 && modTime <= 3.0) {\n        mode = 3;\n    } else if(modTime > 3.0 && modTime <= 4.0) {\n        mode = 4;\n    }\n\n\n\tconst float MIN_T = 0.0;\n\tconst float MAX_T = 100.0;\n\tconst float EPSILON = 0.0001;\n    vec3 eyePos = vec3(0.0, 0.0, 80.0);\n    eyePos.x = fragCoord.x / 50.0 - 0.5 * iResolution.x / 50.0;\n    eyePos.y = fragCoord.y / 50.0 - 0.5 * iResolution.y / 50.0;\n\n\tvec3 rDir = rayDirection(fragCoord, iResolution);\n\tvec3 rDir_transed = rDir;\n    \n    float PI = 3.14159265359;\n    mat4 transM = rotateX(0.8 * PI/4.0) * rotateY(PI/4.0);\n    if (mode == 1) {\n        transM = transM * rotateY( -1.0 * PI * 0.5 * fract(iTime));\n    } else if (mode == 3) {\n        transM = transM * rotateX(1.0 * PI * 0.5 * fract(iTime));\n    }\n        \n        \n\n    float t = march(eyePos, rDir_transed, MIN_T, MAX_T, EPSILON, transM);\n    vec3 pos = eyePos + t * rDir_transed;\n    \n    pos = vec3(inverse(transM) * vec4(pos, 1.0));\n\tvec3 normal = estimateNormal(pos);\n    \n        \n    if (t >= MAX_T) {\n        fragColor = vec4(0.9, 0.9, 0.9, 1.0);\n\n    } else {\n        vec4 purple = vec4(81.0/255.0, 65.0/255.0, 86.0/255.0, 1.0);\n        vec4 green = vec4(169.0/255.0, 217.0/255.0, 198.0/255.0, 1.0);\n        vec4 pink = vec4(232.0/255.0, 78.0/255.0,128.0/255.0, 1.0);\n        vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n        vec2 midP = iResolution.xy / 2.0;\n        \n        if (mode == 1) {   \n            if (normal.x == 0.0 && normal.y == 0.0 && normal.z > 0.0) {\n                // front\n                fragColor = purple;\n            } else if (normal.x > 0.0 && normal.y == 0.0 && normal.z == 0.0){\n                // right\n                fragColor = pink;\n            } else if (normal.x == 0.0 && normal.y > 0.0 && normal.z == 0.0){\n                // top\n                fragColor = green;\n            } else if (normal.x < 0.0 && normal.y == 0.0 && normal.z == 0.0){\n                // left\n                fragColor = pink;\n            } \n        } else if (mode == 3) {    \n            if (normal.x == 0.0 && normal.y == 0.0 && normal.z > 0.0) {\n                // front\n                fragColor = purple;\n            } else if (normal.x == 0.0 && normal.y > 0.0 && normal.z == 0.0){\n                // top\n                fragColor = pink;\n            } else if (normal.x < 0.0 && normal.y == 0.0 && normal.z == 0.0){\n                // top\n                fragColor = green;\n            } else if (normal.x == 0.0 && normal.y == 0.0 && normal.z < 0.0){\n                // back\n                fragColor = purple;\n            } \n            \n        } else if (mode == 2) {\n            float angle =  (-1.0) * smoothstep(0.0, 1.0, fract(iTime)) * 2.0 * PI / 3.0; \n            vec2 fragCoordRot = rotateM(angle) * (fragCoord - midP) + midP;\n            vec2 frag_v = normalize(fragCoordRot - midP);\n            vec2 comp_v = vec2(0.0, -1.0);\n            float theta = acos(dot(frag_v, comp_v) / 1.0);\n            if (theta > 0.0 && theta <= (2.0 * PI) / 3.0) {\n                if (fragCoordRot.x >= midP.x) {\n                    fragColor = pink;\n                } else {\n                    fragColor = purple;\n                }    \n            } else if (theta > (2.0 * PI) / 3.0 && theta <= (4.0 * PI) / 3.0) {\n                fragColor = green;\n            }\n                \n            \n        } else if (mode == 4) {\n            float angle =  smoothstep(0.0, 1.0, fract(iTime)) * 2.0 * PI / 3.0; \n            vec2 fragCoordRot = rotateM(angle) * (fragCoord - midP) + midP;\n            vec2 frag_v = normalize(fragCoordRot - midP);\n            vec2 comp_v = vec2(0.0, -1.0);\n            float theta = acos(dot(frag_v, comp_v) / 1.0);\n            if (theta > 0.0 && theta <= (2.0 * PI) / 3.0) {\n                if (fragCoordRot.x >= midP.x) {\n                    fragColor = pink;\n                } else {\n                    fragColor = green;\n                }    \n            } else if (theta > (2.0 * PI) / 3.0 && theta <= (4.0 * PI) / 3.0) {\n                fragColor = purple;\n            }\n            \n        }\n\t\t\n\t\t\n\t}\n\n}\n","name":"Image","description":"","type":"image"}]}