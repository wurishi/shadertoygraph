{"ver":"0.1","info":{"id":"lsyyzw","date":"1521424957","viewed":125,"name":"roundedRect v3","username":"matkatmusic","description":"https://math.stackexchange.com/questions/1649714/whats-the-equation-for-a-rectircle-perfect-rounded-corner-rectangle-without-s","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rectangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//(abs(x)/a)^(2a/r) + (abs(y)/b)^(2b/r) = 1\nfloat compute(float x, float a, float r)\n{\n \tfloat exp = 2. * a / r;\n    return pow((abs(x)/a), exp);\n}\n\nfloat lengthSquared(vec2 v, vec2 w)\n{\n\treturn length(w-v)*length(w-v);   \n}\n\nfloat minimum_distance(vec2 v, vec2 w, vec2 p) {\n  // Return minimum distance between line segment vw and point p\n  float len = lengthSquared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  if (len == 0.0) return distance(p, v);   // v == w case\n  // Consider the line extending the segment, parameterized as v + t (w - v).\n  // We find projection of point p onto the line. \n  // It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  // We clamp t from [0,1] to handle points outside the segment vw.\n  float t = max(0., min(1., dot(p - v, w - v) / len) );\n  vec2 projection = v + t * (w - v);  // Projection falls on the segment\n  return distance(p, projection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //uniform inputs:\n    vec2 bounds = iResolution.xy;\n\tfloat width = .8;\n    float height = 0.6;\n    float thickness = 0.1; //you need to make sure 0 <= (width + thickness) <= 1.0\n    float radius = 0.04;\n    vec4 innerColor = vec4(0,1,1,1);\n    vec4 outerColor = vec4(1,0,0,1);\n        \n    //shader starts here:\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 normalizedFragCoord = fragCoord.xy / bounds;\n\t\n    float ratio = bounds.y / bounds.x;\n    vec2 p = normalizedFragCoord * 2.0 - 1.0;\n    p.y *= ratio;\n    float rectWidth = width;\n    float rectHeight = height * ratio;\n    \n    vec4 col = vec4(1,1,1,1);\n    \n    float threshold = 0.1;\n    \n    /*\n\thow can I determine how far away p.xy is from a boundary? \n\t\n\tdistance of p.x from boundary:\n\tcompute(rectWidth, rectWidth, radius) - compute(p.x,rectWidth,radius)\n\t\n\n\tthis:\n\tif( abs(compute(p.x,rectWidth,radius) + compute(p.y,rectHeight,radius) - 1.) <= threshold )\n\tchecks if they're ON the line\n    \n\tthis: \n\tif( abs(compute(p.x,rectWidth,radius) + compute(p.y,rectHeight,radius)) - 1. > threshold )\n\tchecks if they're OUTSIDE the line\n\n\tthis: \n\tif( abs(compute(p.x,rectWidth,radius) + compute(p.y,rectHeight,radius)) - 1. < threshold )\n\tchecks if they're INSIDE the line\n\n\tthe closing parenthesis location for the abs() statement is VERY important\n\t*/\n    \n    //pixels between outer ring and middle ring\n    if\t( \n        abs(compute(p.x,rectWidth+thickness,radius) + compute(p.y,rectHeight+thickness,radius)) - 1. <= threshold \n        &&\n        abs(compute(p.x,rectWidth,radius) + compute(p.y,rectHeight,radius)) - 1. > threshold \n    \t)\n    {\n        //gradient from outerColor to innerColor   \n         \n    }\n    //pixels between middle ring and inner ring\n    if( \n       abs(compute(p.x,rectWidth,radius) + compute(p.y,rectHeight,radius)) - 1. <= threshold \n       &&\n       abs(compute(p.x,rectWidth-thickness,radius) + compute(p.y,rectHeight-thickness,radius)) - 1. > threshold\n      )\n    {\n        //gradient from innerColor to outerColor\n    }\n    //pixels ON middle ring\n    if( abs(compute(p.x,rectWidth,radius) + compute(p.y,rectHeight,radius) - 1.) <= threshold )\n    {\n        col.xy -= 1.;\n    }\n    //pixels ON inner ring\n    if( abs(compute(p.x,rectWidth-thickness,radius) + compute(p.y,rectHeight-thickness,radius) - 1.) <= threshold )\n    {\n        col.yz -= 1.;    \n    }\n    //pixels ON outer ring\n    if( abs(compute(p.x,rectWidth+thickness,radius) + compute(p.y,rectHeight+thickness,radius) - 1.) <= threshold )\n    {\n        col.zx -= 1.;;\n    }\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}