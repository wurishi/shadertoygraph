{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// constants\n#define PI 3.141593\n#define SQRT2 1.414213562\n\n// camera\n#define FDIST 0.5\n#define FISHEYE\n#define FISHEYE_SCALE 2.\n\n// octree\n#define MAX_VOXELS 80\n#define LEVELS 5\n#define OCCUPANCY_THRESHOLD 0.6\n#define SUBDIVISION_THRESHOLD 0.7\n\n// splatting\n//make TRANSMISSION_CUTOFF really small to get multiple inter-reflection bounces\n#define TRANSMISSION_CUTOFF 0.03\n#define FUZZINESS 0.1\n#define RADIUS 0.4\n#define JITTER 0.1\n//RADIUS and JITTER must add up to less than 0.5\n\n// rendering\n#define IOR 1.7\n#define IOR2 1.2\n#define ABSORBTION_RATE vec3(0.99, 0.97, 0.96)\n#define FOG_COLOR vec3(0.5, 0.95, 1.)\n#define MAX_SHADOW_VOXELS 40\n#define MIN_SHADOW_DIST 2.\n#define MAX_SHADOW_DIST 4.\n#define SHADOW_CUTOFF 0.01\n#define SPEED 1.5\n\nstruct Hit {\n    int mat;\n    float t;\n    vec3 col;\n    int level;\n    vec3 n;\n    vec3 id;\n    vec2 uv;\n};\n\n// math functions\n\nvec3 safe_inverse(in vec3 rd) {\n    vec3 sg = abs(sign(rd));\n    return (1e6 * (1.0-sg) + sg) / (rd + (1.0 - sg));\n}\n\n// https://www.shadertoy.com/view/XlGcRh\nuvec4 pcg4d(uvec4 v)\n{\n    v = v * 1664525u + 1013904223u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    v ^= v >> 16u;\n    \n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    \n    return v;\n}\n\nvec4 noise4d(ivec4 v) {\n    return vec4(pcg4d(uvec4(v))) * (1.0 / float(0xffffffffu));\n}\n\n// color gradient\nvec3 rainbow(float t) {\n    float s = sin(t);\n    return vec3(s, cos(t), -s) * .5 + .5;\n}\n\n// Field functions to define how our octree should be filled / split\nbool occupancy(in ivec3 id, int level) {\n    return noise4d(ivec4(id, level)).x > OCCUPANCY_THRESHOLD;\n}\n\nbool subdivision(in ivec3 id, int level) {\n    return noise4d(ivec4(id, level + LEVELS)).x > SUBDIVISION_THRESHOLD;\n}\n\n// TRACING THE SPHERES\n\n// return opacity and update the hit surface t, normal, and UV coordinate\nfloat cellTrace(in vec3 id, in vec3 rd, in vec3 ro, float sl, inout Hit h) {\n    vec3 cell_center = (id + 0.5) * sl;\n    vec3 co = cell_center - ro;\n    float t = dot(co, rd);\n    vec3 v = cross(co, rd);\n    float vv = dot(v, v);\n    float vs = sqrt(vv);\n    float r = RADIUS * sl;\n\n    if (vs < r) {\n        h.t = t - sqrt(r*r - vv);\n    }\n    h.n = normalize(ro + rd * h.t - cell_center);\n    float phi = atan(h.n.x, h.n.y);\n    h.uv = vec2(phi, h.n.z);\n    return step(vs, r) * step(0., h.t);\n}\n\n// simpler version of the above which returns the smooth shadow factor only\nfloat cellTraceOcclusion(in vec3 id, in vec3 rd, in vec3 ro, float sl, float fuzziness) {\n    vec3 cell_center = (id + 0.5) * sl;\n    vec3 co = cell_center - ro;\n    float t = dot(co, rd);\n    vec3 v = cross(co, rd);\n    float vv = dot(v, v);\n    float vs = sqrt(vv);\n    float r = RADIUS * sl;\n    \n    float sl2 = sl*sl;\n    return smoothstep(vs, vs + fuzziness, r) * step(0., t);\n}\n\n// Get perturbed sphere center within the given cell\nvec3 get_center(vec3 id, vec4 noiseval, int level) {\n    vec3 offset = noiseval.yzw-0.5;\n    float phase = offset.x * PI * 2.;\n    offset.z *= sin(iTime*SPEED*float(level) + phase);\n    return id + offset * JITTER;\n}\n\n// OCTREE TRAVERSAL\n// adapted from abje's octree algorithm: https://www.shadertoy.com/view/4sVfWw\n\n// shadow rays to compute the fraction of incoming light that is transmitted past occluding objects\n// smooth penumbra grows linearly with distance to the occluder, and object opacity falls off with distance to allow some light through\nfloat shadowtrace(in vec3 ro, in vec3 rd) {\n    float t = 0.;\n    int level = 0;\n    float sl = 1.0;\n    vec3 id = floor(ro);\n    vec3 p = ro; // follows the ray to decide which child cells we end up in\n    vec3 ri = safe_inverse(rd);\n    vec3 rs = sign(ri);\n    vec3 rsi = ri * rs;\n    vec3 dis = vec3(0.0);\n    vec3 mm = vec3(0.0);\n    bool exiting = false;\n    vec3 prevId = id;\n    float shadowfac = 1.0;\n    Hit h;\n        \n    for (int i=0; i<MAX_SHADOW_VOXELS; i++) {\n        bool moving = false;\n\n        if (exiting && level > 0) { // exiting up one level of the octree\n            --level;\n            sl *= 2.0;\n            id = floor(id / 2.0);\n            prevId = floor(prevId / 2.0);\n            // check if we are still at the boundary of parent cells; if so, exit again\n            exiting = level > 0 && !all(equal(floor(prevId / 2.0), floor(id / 2.0)));\n            \n        } else if (subdivision(ivec3(id), level) && level < LEVELS) { // going down one level in the octree\n            ++level;\n            vec3 pf = p - id * sl;\n            sl *= 0.5;\n            id =  id*2.0 + step(sl, pf);\n            \n        } else if (occupancy(ivec3(id), level) && t > 0.) { // occupied cell (skip the starting cell which is our shadowed surface)\n            vec4 noiseval = noise4d(ivec4(ivec3(id), level));\n            vec3 offsetID = get_center(id, noiseval, level);\n            float opacity = cellTraceOcclusion(offsetID, rd, ro, sl, FUZZINESS * t);\n            opacity *= 1.-smoothstep(MIN_SHADOW_DIST, MAX_SHADOW_DIST, t);\n            shadowfac *= 1.-opacity;\n            \n            if (shadowfac < SHADOW_CUTOFF) { // stop\n                break;\n            }\n            moving = true;\n        } else {\n            moving = true;\n        }\n        if (moving) { // traverse empty cell\n            prevId = id;\n            dis = (id*sl - ro + sl * (0.5 + rs*0.5)) * ri;\n            t = min ( dis.x, min ( dis.y, dis.z ) );\n            if (t > MAX_SHADOW_DIST) break;\n            p = ro + rd * t;\n            mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n            id += mm * rs;\n            // check if we are at the boundary of parent cells; if so, exit\n            exiting = !all(equal(floor(prevId / 2.0), floor(id / 2.0)));\n        }\n    }\n    return shadowfac;\n}\n\n// Trace primary and reflection rays\nHit trace_octree(in vec3 ro, in vec3 rd) {\n    Hit h;\n    h.mat = 0;\n    h.col = vec3(0);\n    h.t = 0.;\n    h.level = 0;\n    float sl = 1.0;\n    h.id = floor(ro);\n    vec3 p = ro; // follows the ray to decide which child cells we end up in\n    vec3 ri = safe_inverse(rd);\n    vec3 rs = sign(ri);\n    vec3 rsi = ri * rs;\n    vec3 dis = vec3(0.0);\n    vec3 mm = vec3(0.0);\n    bool exiting = false;\n    vec3 prevId = h.id;\n    \n    vec3 transmission = vec3(1.0);\n    float R0 = (IOR-1.)/(IOR+1.);\n    float R02 = (IOR2-1.)/(IOR2+1.);\n    R0*=R0;\n    R02*=R02;\n    float totalRayDist = 0.;\n    \n    vec3 lightdir = normalize(vec3(2., 4., 9.));\n    \n    for (int i=0; i<MAX_VOXELS; i++) {\n        bool moving = false;\n\n        if (exiting && h.level > 0) { // exiting up one level of the octree\n            --h.level;\n            sl *= 2.0;\n            h.id = floor(h.id / 2.0);\n            prevId = floor(prevId / 2.0);\n            // check if we are still at the boundary of parent cells; if so, exit again\n            exiting = h.level > 0 && !all(equal(floor(prevId / 2.0), floor(h.id / 2.0)));\n            \n        } else if (subdivision(ivec3(h.id), h.level) && h.level < LEVELS) { // going down one level in the octree\n            ++h.level;\n            vec3 pf = p - h.id * sl;\n            sl *= 0.5;\n            h.id =  h.id*2.0 + step(sl, pf);\n            \n        } else if (occupancy(ivec3(h.id), h.level)) { // occupied cell -- perform shading, initiate shadow raytrace and redirect this primary ray to compute the reflections\n            vec4 noiseval = noise4d(ivec4(ivec3(h.id), h.level));\n            vec3 offsetID = get_center(h.id, noiseval, h.level);\n            float hit = cellTrace(offsetID, rd, ro, sl, h);\n            \n            if (hit > 0.5) { // reflect ray\n                h.mat = 1;\n                totalRayDist += h.t;\n                ro = ro + rd * h.t; // start ray at new surface\n                \n                // festive texture\n                vec2 uv = h.uv;\n                uv.x *= floor(noiseval.y * 4.+4.) / PI;\n                uv.x += iTime * (noiseval.w-0.5);\n                uv = mat2x2(SQRT2, -SQRT2, SQRT2, SQRT2) * uv;\n                //float pattern_scale = noiseval.z * 0.2 + 0.05;\n                float pattern_scale = 0.5;\n                vec2 mask2 = step(noiseval.x * 0.2, abs(fract(uv * SQRT2 * pattern_scale) - noiseval.y));\n                float mask = min(mask2.x, mask2.y);\n                if (noiseval.w > 0.4) {\n                    mask = 1. - mask;\n                }\n                \n                // light and shadow\n                vec3 albedo = rainbow((float(h.level * 2) * PI) / float(LEVELS+1));\n                vec3 altcolor = 1.-0.4*rainbow(noiseval.z*10.);\n                albedo = mix(albedo, altcolor, mask);\n                \n                float dotprod = max(0., dot(h.n, lightdir));\n                vec3 col1 = albedo * dotprod * vec3(0.7, 0.8, 0.9);\n                if (dotprod > 1e-6) {\n                    col1 *= shadowtrace(ro, lightdir);\n                }\n                // ambient light & fog\n                vec3 col2 = albedo * vec3(0.03, 0.04, 0.06);\n                col2 *= max(0., dot(h.n, -lightdir));\n                vec3 col = col1 + col2;\n                col = mix(FOG_COLOR, col, pow(ABSORBTION_RATE, vec3(totalRayDist)));\n                \n                // reflection\n                float fresnel1 = R0 + (1.-R0) * pow(1.-dot(-rd, h.n), 5.);\n                float fresnel2 = R02 + (1.-R02) * pow(1.-dot(-rd, h.n), 5.);\n                float fresnel = mix(fresnel1, fresnel2, mask);\n                vec3 coat = fresnel * mix(vec3(1., 0.8, 0.8), vec3(.2, .6, 1.), mask);\n                h.col += col * transmission * (1.-coat);// * max(0., 1.-h.t*0.03);\n                \n                transmission *= coat;\n                if (all(lessThan(transmission, vec3(TRANSMISSION_CUTOFF)))) break;\n                \n                // initialize new ray\n                p = ro;\n                rd = reflect(rd, h.n);\n                ri = safe_inverse(rd);\n                rs = sign(ri);\n                rsi = ri * rs;\n            }\n            moving = true;\n        } else {\n            moving = true;\n        }\n        if (moving) { // traverse empty cell\n            prevId = h.id;\n            dis = (h.id*sl - ro + sl * (0.5 + rs*0.5)) * ri;\n            h.t = min ( dis.x, min ( dis.y, dis.z ) );\n            p = ro + rd * h.t;\n            mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n            h.id += mm * rs;\n            // check if we are at the boundary of parent cells; if so, exit\n            exiting = !all(equal(floor(prevId / 2.0), floor(h.id / 2.0)));\n        }\n    }\n    \n    h.n = -mm*rs;\n    if (h.mat == 0) {\n        h.col = FOG_COLOR;\n    }\n\t\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera initialization\n    float scaledTime = iTime * 0.025;\n    float mouseY = iMouse.y < 1. ? 0.35 : (0.5-iMouse.y/iResolution.y) * PI;\n    float mouseX = iMouse.x < 1. ? iTime*0.25 : -(iMouse.x/iResolution.x) * 2. * PI;\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 eye = vec3(cos(scaledTime) * 10., scaledTime * 4., sin(scaledTime) * 10.);\n    vec3 w = vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), -sin(mouseY));\n    vec3 u = normalize(cross(w, vec3(0., 0., 1.)));\n    vec3 v = cross(u, w);\n    \n    #ifdef FISHEYE\n    uv *= FISHEYE_SCALE;\n    vec2 c = cos(uv);\n    vec2 s = sin(uv);\n    float r2 = dot(uv, uv);\n    //vec3 rd = normalize(uv.x * u + uv.y * v + sqrt(1.-r2) * w); // true fisheye\n    vec3 rd = normalize(s.x * c.y * u + s.y * v + c.x * c.y * w); // spherical map projection (can have 360 vision if FISHEYE_SCALE is high enough)\n    #else\n    vec3 rd = normalize(FDIST*w + uv.x*u + uv.y*v);\n    #endif\n\n    // raytrace\n    Hit h = trace_octree(eye, rd);\n    \n    //coloring\n    fragColor = vec4(pow(h.col, vec3(0.45)), 1.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lXdcDH","date":"1735075256","viewed":203,"name":"Christmas Ocean","username":"ShnitzelKiller","description":"Using a random octree to render lots of spatially varying holiday spirit. Octree traversal code is rewritten version of abje's shader: https://www.shadertoy.com/view/4sVfWw\nMouse to look around.","likes":14,"published":3,"flags":0,"usePreview":0,"tags":["raytracing","reflection","christmas","spheres","octree","splatting"],"hasliked":0,"parentid":"","parentname":""}}