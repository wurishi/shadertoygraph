{"ver":"0.1","info":{"id":"NsccRX","date":"1653797806","viewed":194,"name":"Rennala's Full Moon","username":"auurora","description":":)","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nconst int steps = 100;\nconst float far = 200.f;\nconst float near = 0.1f;\n\nconst int stars = 300;\n\nconst int Water = 1;\nconst int Moon = 2;\nconst int Star = 3;\n\nconst float flow_density = 2.5;\nconst float speed = 0.3;\n\nconst float distortion = 1.3;\n\nconst vec4 water_color = vec4(0.01,0.4, 0.6, 0.5);\n\nvec4 tex1, tex2, tex3, tex4;\n\nstruct ray_t\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct ray_result\n{\n    float dist;\n    int object;\n};\n\n\nfloat sphere(vec3 p, vec3 c, float r)\n{\n    return distance(p,c) - r;\n}\n\nvoid add_scene(inout ray_result pixel, inout float scene_dist, float obj, int obj_pixel)\n{\n    if (obj < scene_dist)\n    {\n        scene_dist = obj;\n        pixel.object = obj_pixel;\n    }\n}\n\n\nfloat scene(vec3 p, inout ray_result pixel)\n{\n    float scene_dist = 10000.;\n    \n    add_scene(pixel, scene_dist, p.y, Water); // 1 - Plane\n    add_scene(pixel, scene_dist, \n        sphere(p, vec3(0, 0, 30.), 12.), \n        Moon\n    );\n    \n    \n    return scene_dist;\n}\n\nfloat scene_nowater(vec3 p, inout ray_result pixel)\n{\n    float scene_dist = 10000.;\n    \n    add_scene(pixel, scene_dist, \n        sphere(p, vec3(0, 0, 30), 12.), \n        Moon\n    );\n    \n    \n    return scene_dist;\n}\n\nray_result render_nowater(ray_t ray)\n{\n    ray_result pixel = ray_result(0., 0);\n    \n    for (int i = 0; i < steps; ++i)\n    {\n        vec3 p = ray.origin + (ray.direction * pixel.dist);\n        \n        float object = scene_nowater(p, pixel);\n        pixel.dist += object;\n        \n        if (object < near)\n            return pixel;\n            \n        if (pixel.dist > far)\n            return ray_result(0., 0);\n    }\n    \n    return ray_result(0., 0);\n}\nray_result render(ray_t ray)\n{\n    ray_result pixel = ray_result(0., 0);\n    \n    for (int i = 0; i < steps; ++i)\n    {\n        vec3 p = ray.origin + (ray.direction * pixel.dist);\n        \n        float object = scene(p, pixel);\n        pixel.dist += object;\n        \n        if (object < near)\n            return pixel;\n            \n        if (pixel.dist > far)\n            return ray_result(0., 0);\n    }\n    \n    return ray_result(0., 0);\n}\n\nvec3 normal(vec3 p) {\n    ray_result throwaway_px;\n\tfloat d = scene(p, throwaway_px);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        scene(p-e.xyy, throwaway_px),\n        scene(p-e.yxy, throwaway_px),\n        scene(p-e.yyx, throwaway_px));\n    \n    return normalize(n);\n}\nvec4 color(in ray_t ray, in ray_result ray_object)\n{\n    vec4 final;\n    switch (ray_object.object) {\n        case 0:\n        {\n            float travel = (100.-ray.origin.z)/ray.direction.z;\n            \n            final = \n                mix(\n                    mix(blue_shade, dark_blue_shade, clamp(((ray.direction * travel)/100.).y, -1., 1.)),\n                    vec4(vec3(0.8), 1.),\n                    smoothstep(0.99, 1., rnd(normalize(floor((ray.direction * travel)*10.)).xy))\n                );\n            break;\n        }\n        case Moon:\n        {\n            vec3 nml = normal(ray.origin + ray.direction * ray_object.dist);\n            vec3 incidence = normalize(ray.origin + ray.direction * ray_object.dist - vec3(0,2,0));\n            vec4 fresnel = vec4(0.2 + 0.6 * pow(1.0 + dot(incidence, nml), 2.));\n            final = fresnel + mix(texture(iChannel0, nml.zy - nml.y * ray.direction.xy), texture(iChannel0, ray.direction.xy * nml.z), mix(nml.x, nml.z, ray.origin.y * sin(fbm(ray.direction.xy))));\n            break;\n        }\n        case Star:\n            final = vec4(0.5);\n            break;\n        case Water:\n            final = vec4(0.1,0.3,0.3, 1.);\n            break;\n    }\n    vec3 ray3 = (vec3(0,ray.origin.y,0) + ray.direction * 30.);\n    \n    float zw = (sphere(ray3, vec3(0,0,30), 16.) + 14.) / 24.;\n    float glow = 1.-(smoothstep(0.40, 0.59, zw));\n    \n    float amplifier = 0.4 + (sin(iTime)* 0.1);\n    \n    if (ray_object.object == Moon)\n        amplifier *= 0.02;\n        \n    final += amplifier * vec4(0.66,0.86,0.74, 1.) * glow;\n    return final;\n}\n\nvec4 refl_texture(in vec3 ray_pos, vec2 uv)\n{\n    vec3 dir = vec3(uv, 1.);\n    ray_t reflect_ray = ray_t(ray_pos + (dir), dir);\n    ray_result reflect_r = render_nowater(reflect_ray);\n\n\n    vec3 ref_ray_pos = reflect_ray.origin + reflect_ray.direction * reflect_r.dist;\n    float dist = distance(ray_pos, ref_ray_pos);\n\n    return color(reflect_ray, reflect_r);\n}\n\nfloat light_exposure(vec3 p, vec3 nml)\n{\n    vec3 lightPos = vec3(0, 30., 20);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = nml;\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float angle = fract(iTime/10.) * 3.14159*2.;\n        \n    ray_t ray = ray_t(\n        vec3(0, 2, 0), \n        vec3(uv.x, uv.y, 1.)\n    );\n        \n    ray_result r = render(ray);\n    \n    vec3 ray_pos = ray.origin + ray.direction * r.dist;\n    vec3 ray_normal = normal(ray_pos);\n    \n    fragColor = vec4(0.);\n    \n    if (r.object == Water)\n    {\n        \n        \n        vec2 p = (ray_pos.xz + vec2(0,iTime * 0.7)) * flow_density;\n        vec2 fl = ((fbmv2(fbmv2(fbmv2(p, p-0.5), p + 0.5), p) - 0.3) * 0.69) * vec2(.5, distortion);\n        \n        vec2 offset1 = (fl * fract(iTime * speed));\n        vec2 offset2 = (fl * fract(fract(iTime * speed) + 0.5));\n        \n        vec2 reflected_raydir = vec2(uv.x, mix(-uv.y,-ray_normal.y, offset1.y));\n        vec2 reflected_raydir2 = vec2(uv.x, mix(-uv.y, -ray_normal.y, offset2.y));\n        \n        vec2 reflection_normal = mix\n        (\n            reflected_raydir,\n            reflected_raydir2,\n            abs((fract(iTime * speed) - 0.5) * 2.)\n        );\n        fragColor = vec4(0.03)+mix\n        (\n            refl_texture(ray_pos, reflected_raydir),\n            refl_texture(ray_pos, reflected_raydir2),\n            abs((fract(iTime * speed) - 0.5) * 2.)\n        );\n        \n        fragColor += 0.3* vec4(light_exposure(ray_pos, normalize(vec3(reflection_normal, 1.))));\n    } \n    else \n    {\n        fragColor = color(ray, r);\n    }\n    fragColor = vec4(pow(fragColor.rgb, vec3(1.5)), fragColor.a);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec4 moon_green = vec4(0.16, 0.365, 0.347, 1.);\n\nvec2 cdist2(vec2 uv)\n{\n    return (uv-0.5) - vec2(-0.3, -0.1);\n}\nfloat crater_dist(vec2 uv)\n{\n    return smoothstep(0., 1., 1.-length(cdist2(uv))/0.3);\n}\nvec4 crater(vec2 uv)\n{\n    return mix(moon_green, ice_white, crater_dist(uv) * 2.);\n}\nvec4 moon_tex(vec2 uv)\n{\n    uv*=30.;\n    float mixfbm = \n    fbm(\n        fbmv2(\n            fbm(uv - 32.) * uv,\n            fbm(fract(uv*3.122341) * sin(floor(uv*332.2)/100.)) - uv\n        )\n    );\n    return \n    mix(\n        crater(uv),\n        ice_white,\n        mixfbm\n    ) * 1.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 distort = (fbm2(fbm2(fbm2(uv * 30. + (iTime/5.)))) - 0.5 ) * 0.5;\n    fragColor = moon_tex(uv + distort);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float rnd(vec2 u)\n{\n    return fract((sin(u.y*382.1238 + u.x*1984.2942 ) * 6491.49438) * cos(u.y*9431.4358+u.x*-8342.23));\n}\n\nfloat noise(vec2 u)\n{\n    vec2 i = floor(u);\n    vec2 f = fract(u);\n    \n    f = f * f * (3. - (2. * f));\n    \n    float x = rnd(i);\n    float y = rnd(i + vec2(1, 0));\n    float z = rnd(i + vec2(0, 1));\n    float w = rnd(i + vec2(1, 1));\n    \n    return mix(mix(x,y,f.x), mix(z,w,f.x), f.y);\n}\n\nconst int octaves = 4;\nconst float ampl = .4;\n\nfloat fbm(vec2 u) {\n    float value = 0.0;\n    float amplitude = ampl;\n    \n    for (int i = 0; i < octaves; ++i)\n        value += amplitude * noise(u),u *= 2.,amplitude/=2.;\n        \n    return value;\n}\n\nvec2 fbm2(vec2 u)\n{\n    return vec2(fbm(u), fbm(vec2(u.y, u.x)));\n}\nvec2 fbmv2(vec2 u, vec2 w)\n{\n    return vec2(fbm(u), fbm(w));\n}\n\nfloat fmba(float x, float y)\n{\n    return fbm(vec2(x,y));\n}\n\nmat4 rotateY(float angle)\n{\n    return mat4(\n        1, 0, 0, 0,\n        0, cos(angle), -sin(angle), 0,\n        0, sin(angle), cos(angle), 0,\n        0, 0, 0, 1\n    );\n}\nmat4 rotateX(float angle)\n{\n    return mat4(\n        cos(angle), 0, sin(angle), 0,\n        0, 1, 0, 0,\n        -sin(angle), 0, cos(angle), 0,\n        0, 0, 0, 1\n    );\n}\nconst vec4 blue_shade = vec4(36./255., 80./255., 100./255., 1.);\n\nconst vec4 dark_blue_shade = vec4(14./255., 35./255., 49./255., 1.);\n\nconst vec4 ice_white = vec4(222./255., 232./255., 241./255., 1.);\nconst vec4 ice_blue = vec4(118./255., 131./255., 255./255., 1.);\n\nvec4 star_color(vec2 pos)\n{\n    return mix(blue_shade, vec4(0.8), rnd(pos));\n}\n\nvec4 star_color3(vec3 pos)\n{\n    return mix(blue_shade, vec4(0.8), rnd(vec2(rnd(pos.xy), pos.z)));\n}","name":"Common","description":"","type":"common"}]}