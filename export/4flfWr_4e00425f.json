{"ver":"0.1","info":{"id":"4flfWr","date":"1723694652","viewed":45,"name":"Going places","username":"gllama","description":"The fog but only applied on the beams. Using a realty distortion technique from the wonderful @DamnXYZ.\n\nI feel like the beams should be neon...","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","grid","sdf","distortion","projection","spherical","equirectangular","3dgrid"],"hasliked":0,"parentid":"XclBzM","parentname":"Going Places"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 🏰 Going Places(Equirectangular)\n// License CC0-1.0\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n// Shoutout @DamnXYZ see distort_space() func\n// - gllama\n// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Modified version of @DamnXYZ's effect - License Unkown - https://www.shadertoy.com/view/wdBcW3\nvec3 distort_space(vec3 p){\n    float osc = .5 + .5*sin(iTime);\n    p.x += osc * sin(p.z)*.5;\n    p.y += osc * cos(p.z)*.5+.5;\n    return p;\n}\n\n\n// This function let's us jump from 2D-UV to spherical 3D-XYZ position\nvec3 uvTo3D(vec2 uv) {\n    // The 2-Sphere point via UV => Lat/Long angles\n    float theta = uv.x * 2.0 * 3.14159265359; // Longitude\n    float phi = uv.y * 3.14159265359; // Latitude\n    // Trigonometry from 2-Sphere angles to an XYZ normalized [-1,1].\n    float x = sin(phi) * cos(theta);\n    float y = sin(phi) * sin(theta);\n    float z = cos(phi);\n    // { Dev Note }\n    // If you're porting this shader to a material, I strongly recommend you skip this function and just use the XYZ of your 'varying vNormal' in place of the result you would get here. Should be suitable for all spheres and most round geometries\n    return vec3(x, y, z);\n}\n\nfloat sdfLine(vec3 p) {\n    float radius = .002;\n    //p*=.5;\n    float closestXLine = length(vec2(round(p.yz))-p.yz)-radius;\n    float closestYLine = length(vec2(round(p.xz))-p.xz)-radius;\n    float closestZLine = length(vec2(round(p.xy))-p.xy)-radius;\n    return min(closestXLine,min(closestYLine,closestZLine));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor= vec4(0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 pos = uvTo3D(uv); // UV => 3D for equirectangular/spherical mapping\n    \n    \n    // Simple raymarching blog reference: https://michaelwalczyk.com/blog-ray-marching.html\n    const float MINIMUM_HIT_DISTANCE = 0.02;\n    //int NUMBER_OF_STEPS = 26+int(25.*sin(iTime));\n    const int NUMBER_OF_STEPS = 25;\n    float total_distance_traveled = 0.;\n    // Fix RO overshoot\n    pos*=.86;\n    \n    //fragColor=(vec4(sdfLine(pos)));\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i){\n        vec3 current_position = pos/1.2+iTime + total_distance_traveled * pos;\n        float distance_to_closest = sdfLine(distort_space(current_position));\n        //fragColor.z+=sqrt(length(current_position));\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) // hit\n        {\n            fragColor.x=1./total_distance_traveled;\n            fragColor.y=1./total_distance_traveled;\n            fragColor.w=1.;\n            fragColor.z=fragColor.z/(fragColor.z);\n            //fragColor.z=fragColor.z;\n            break;\n        }\n        \n        //fragColor.x = normalize(fragColor.x);//\n        //fragColor.y = normalize(fragColor.y);//\n        //fragColor.z = normalize(fragColor.z);//\n        //fragColor.w = \n        //fragColor. = normalize(fragColor.)\n \n        total_distance_traveled += distance_to_closest;\n        //if(total_distance_traveled>2.){break;}\n    }\n    //fragColor=normalize(fragColor);\n    //fragColor = normalize(fragColor);\n}\n\n/* \n// 🪦 \n// This doesn't work I don't even know what this would \n// be an SDF for. (if anything?)\nfloat sdfLine(vec3 p) {\n    float radius = .001;\n    //p*=10.;\n    float closestXLine = length(vec3(round(p.x),p.yz)-p)-radius;\n    float closestYLine = length(vec3(p.x,round(p.y),p.z)-p)-radius;\n    float closestZLine = length(vec3(p.xy,round(p.z))-p)-radius;\n    return min(closestXLine,min(closestYLine,closestZLine));\n}\n*/","name":"Image","description":"","type":"image"}]}