{"ver":"0.1","info":{"id":"mdXyR8","date":"1686583762","viewed":60,"name":"Colorful geometric flashing","username":"Targa","description":"colorful shapes, with intense flashing of brightness. inspired by @kishimisu","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","colorful","gradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\nfloat sdRoundedX( in vec2 p, in float w, in float r )\n{\n    p = abs(p);\n    return length(p-min(p.x+p.y,w)*0.5) - r;\n}\nfloat sdfCoolS( in vec2 p )\n{\n    float six = (p.y<0.0) ? -p.x : p.x;\n    p = abs(p);\n    float rex = p.x - min(round(p.x/0.4),0.4);\n    float aby = abs(p.y-0.4);\n    \n    float d; vec2 v;\n    v=vec2(six,0.2-p.y); v  -=clamp(0.5*(v.x+v.y),0.0,0.4); d=      dot(v,v) ;\n    v=vec2(p.x,0.6-aby); v  -=clamp(0.5*(v.x+v.y),0.0,0.4); d=min(d,dot(v,v));\n    v=vec2(rex,p.y-0.2); v.y-=clamp(v.y          ,0.0,0.4); d=min(d,dot(v,v));\n    \n    float s = p.x - min(min(1.0-p.y,0.4),0.2+p.y);\n\n    return sqrt(d) * sign(s);\n}\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0)-pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nvec3 palette( float t ) {\n    vec3 v[4] = vec3[](vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(4.735, 4.005, 4.540));\n\n\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return v[0] + v[1]*cos( 6.28318*(v[2]*t+v[3]) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    vec3 finalColor = vec3(0.0);\n    vec2 ra = 0.4 + 0.3*cos( iTime + vec2(0.0,1.57) + 0.0 );\n    \n    for (float i = 0.0; i < 8.0; i++) {\n        uv = fract(uv * 1.6) - 0.5;\n\n        //float d = length(uv) * exp(-length(uv0));\n        \n        //float d = sdRhombus(uv, ra) * exp(-length(uv0));\n        \n        //float d = (sdRoundedX(uv, ra.x, ra.y) * .8 + sdRhombus(uv, ra) * .5) * exp(-length(uv0));\n        \n        float d = (sdRhombus(uv, ra) * (sin(iTime*.3)+0.3) + sdBlobbyCross(uv, ra.x) * (cos(iTime*.15)+0.5)) * exp(-length(uv0) * .5) + sdRoundedX(uv, ra.x, ra.y) * (cos(iTime*.15)+0.5);\n        \n        vec3 col = palette(length(uv0) + i*.8 + iTime*.4);\n\n        //d = sin(d*6. + iTime)/6.;\n        d = abs(d);\n        d = pow((0.02 - i*.001) / d, 1.2);\n\n        finalColor += col * d;\n    }\n    \n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}