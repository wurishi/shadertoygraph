{"ver":"0.1","info":{"id":"ssc3R4","date":"1629221491","viewed":124,"name":"psych tunnel","username":"hikiko","description":"distorting a voronoi tunnel","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","tunnel","baddistortion"],"hasliked":0,"parentid":"sd33R4","parentname":"Fork psychedeli hikiko 989"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.141592653589793\n\nconst vec2 res = vec2(800.0, 600.0);\nconst float aspect = 1.3333333;\nconst vec2 center = vec2(0.5 * aspect, 0.5);\n\nvec4 voronoi(in vec2 uv);\n\nvec3 hsv2rgb(in vec3 c)\n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 gcolorhsv(in vec3 c)\n{\n\treturn c / vec3(360.0, 100.0, 100.0);\n}\n\nvec3 texture_(in vec2 uv)\n{\n\tvec4 v = voronoi(uv);\n\tvec3 chsv = gcolorhsv(vec3(201.0, 66.0, 93.0));\n\tchsv.x = chsv.x + v.x * 0.3;\n\tchsv = chsv * smoothstep(-1.0, 1.0, pow(v.w, 3.0) * 0.5 + 0.5);\n\n\treturn hsv2rgb(chsv);\n}\n\n// modification of this noise function by Inigo Quilez:\n// https://www.shadertoy.com/view/XsXfRH\n\nfloat hash(in vec2 p)\n{\n    p  = 50.0 * fract(p * 0.3183099 + vec2(0.71, 0.113));\n    return -1.0 + 2.0 * fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat noised(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n#if 0\n    // quintic interpolation\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash(p+vec2(0.0,0.0));\n    float b = hash(p+vec2(1.0,0.0));\n    float c = hash(p+vec2(0.0,1.0));\n    float d = hash(p+vec2(1.0,1.0));\n\t\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = a - b - c + d;\n\n    return k0 + k1 * u.x + k2 * u.y + k3 * u.x * u.y;\n}\n\nvec2 v2noise(in vec2 uv)\n{\n\treturn vec2(noised(uv + vec2(132.47, 821.12)), noised(uv));\n}\n\nvec3 v3noise(in vec2 uv)\n{\n\treturn vec3(noised(uv + vec2(828.7, 21.12)),\n\t\t\t\tnoised(uv + vec2(13.258, 12.57)),\n\t\t\t\tnoised(uv + vec2(324.61, 57.8)));\n}\n\n// modified version of the following one by Inigo Quilez:\n// https://iquilezles.org/articles/smoothvoronoi\n\nvec4 voronoi(in vec2 uv)\n{\n\tivec2 p = ivec2(floor(uv));\n\tvec2 f = fract(uv);\n\n\tfloat res = 8.0;\n\tivec2 cell = p;\n\n\n\tfor(int j=-1; j<=1; j++) {\n\t\tfor(int i=-1; i<=1; i++) {\n\t\t\tivec2 b = ivec2(i, j);\n\t\t\tvec2 r = vec2(b) - f + v2noise(vec2(p + b)) * vec2(0.5, 0.5) + vec2(0.5, 0.5);\n\t\t\tfloat d = dot(r, r);\n\t\t\tif(d < res) {\n\t\t\t\tres = d;\n\t\t\t\tcell = (p + b);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn vec4(v3noise(vec2(cell)) * 0.6 * cos(iTime) + 0.8, sqrt(res));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * vec2(aspect, 1.0);\n    vec2 v = uv - center;\n\tfloat angle = atan(v.y, v.x);\n\tfloat polar_x = angle * 0.5 / M_PI + 0.5;\n\tfloat polar_y = sqrt(dot(v, v));\n\n\tfloat depth = 1.7 / polar_y;\n\tvec2 tex_uv;\n    float t = iTime;\n\ttex_uv.x = min(polar_x * 2.0, 2.0 - polar_x * 2.0) * 19.0 * cos(sin(cos(t) * 0.1) * 0.2 + 0.3 * sin(t));\n\ttex_uv.y = depth * 4.0 + sin(cos(t) + M_PI / 4.0);\n\n\tfloat fog = clamp(35.0 / pow(depth, 2.5), 0.0, 1.0);\n    \n \tfragColor.rgb = texture_(tex_uv + 2.0 * cos(sin(iTime) + 0.3 * cos(iTime)) + M_PI / 2.0) * fog;\n\tfragColor.a = 1.0;   \n}","name":"Image","description":"","type":"image"}]}