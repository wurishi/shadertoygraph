{"ver":"0.1","info":{"id":"ddB3R3","date":"1667934806","viewed":197,"name":"pirate ship","username":"gabo6d","description":"ahoy matey","likes":28,"published":1,"flags":0,"usePreview":1,"tags":["pirateship"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI_TWO\t\t\t1.570796326794897\n#define PI\t\t\t\t3.141592653589793\n#define TWO_PI\t\t\t6.283185307179586\n#define BOAT_POS vec3(0.,0.565,0.)\n#define LCOLOR vec3(0.932, 0.55, 0.4)\n#define LPOS vec3(0.,0.5,-2.)\n#define LDIR normalize(vec3(-1., -1., -1.))\n#define u_time iTime\n#define u_resolution iResolution\n\nfloat hash2f(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.98985, 78.233545))) * 43758.5453);\n}\n\nfloat noise(vec2 x)\n{\n    vec2 id = floor(x);\n    vec2 f = fract(x);\n\n    vec2 e = vec2(0., 1.);\n    float a = hash2f(id);\n    float b = hash2f(id+e.yx);\n    float c = hash2f(id+e.xy);\n    float d = hash2f(id+e.yy);\n\n    return mix(\n    mix(a,b, f.x),\n    mix(c,d, f.x),\n    f.y\n    );\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat hexprism(vec3 p, vec2 h)\n{\nconst vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Simplex 2D noise\n//\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat water_y(vec2 uv)\n{\n    return snoise(.5*uv+vec2(u_time*.25,0.))*1.3; // + snoise(u_time+uv*10.)*.01-.005;\n}\n\nmat3 rotate_boat(vec3 p)\n{\n    float e = 0.1;\n    float w = water_y(vec2(0., 0.));\n    float wx = water_y(vec2(e,0.0));\n    float wy = water_y(vec2(0.0,e));\n\n    float rf = 1.0;\n    float tx = (wx-w)*rf;\n    float ty = (wy-w)*rf;\n    return mat3(\n        1., 0., 0.,\n        0., cos(tx), -sin(tx),\n        0., sin(tx), cos(tx)\n    )*mat3(\n        cos(ty), -sin(ty), 0.,\n        sin(ty), cos(ty), 0.,\n        0., 0., 1.\n    );\n}\n\nvec3 transform_boat(vec3 p)\n{\n    float y = water_y(vec2(0.0));\n    p.y += y*.2;\n    p = rotate_boat(p)*p;\n\n    p = p.xzy;\n    p.z*=1.7;\n    p.x*=.5;\n    p.z -= 1.35*p.x*p.x;\n    p.xy -= p.z*sign(p.xy)*0.1;\n    return p;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sqr(vec2 uv, vec2 sz)\n{\n    vec2 q = abs(uv)-sz;\n    return max(q.x, q.y);\n}\n\nvec3 flag_texture(vec2 uv)\n{\n    uv *=2.;\n    uv *= .75;\n\n    vec2 skull_uv = uv;\n    skull_uv.y *= clamp(0., 2., uv.y*5.);\n    float skull = length(skull_uv)-.25;\n    float jaw = sqr(uv-vec2(0., -0.175), vec2(0.15, 0.125)); \n\n    vec2 teeth_uv = uv-vec2(0.0125,0.);\n    teeth_uv *= 20.;\n    teeth_uv.x = fract(teeth_uv.x);\n    teeth_uv -= vec2(0., -6.);\n    float teeth = sqr(teeth_uv-vec2(.1,0.2), vec2(0.25, 0.5)); \n    \n    float t = opSmoothUnion(skull, jaw, 0.05);\n    t = max(-teeth, jaw);\n    t = opSmoothUnion(t, skull, 0.05);\n\n    float rt = radians(-45.);\n    mat2 r = mat2(cos(rt), -sin(rt), sin(rt), cos(rt));\n\n    vec2 eyes_uv = uv;\n    eyes_uv.x = abs(eyes_uv.x);\n    eyes_uv= r*eyes_uv;\n    eyes_uv.x*=1.5;\n    float eyes = length(eyes_uv-vec2(0.2,0.)) - 0.1;\n\n    vec2 nose_uv = uv-vec2(0., -0.16);\n    nose_uv.x = abs(nose_uv.x);\n    nose_uv = r*nose_uv;\n    nose_uv.x *= 1.2;\n    float nose = length(nose_uv - vec2(0.03, 0.))-0.01;\n    eyes = min(nose, eyes);\n    t = max(-eyes, t);\n\n    vec2 bone_end_uv = uv;\n    bone_end_uv = r*bone_end_uv;\n    bone_end_uv = abs(bone_end_uv);\n    bone_end_uv = abs(bone_end_uv-vec2(0.085, 0.45));\n    bone_end_uv = pow(bone_end_uv,vec2(1.275));\n\n    float b1 = length(bone_end_uv);\n    bone_end_uv = r*r*bone_end_uv;\n    float b2 = length(bone_end_uv);\n    float bone_end = min(b1,b2)-0.05;\n\n    vec2 bone_uv = uv;\n    float bone = sqr(r*bone_uv, vec2(0.1, 0.4));\n\n    t = 1.-step(0., t);\n    return vec3(1.)*t;\n}\n\nfloat boat_flag(vec3 p, out vec2 flag_uv)\n{\n    if (length(p)>1.2)\n        return 999.;\n\n    p.x += -.05;\n    flag_uv = p.zy;\n    float fa = ((p.x+.2)/0.5);\n    vec3 d = vec3(.2, .15, 0.005)*1.5;\n    float s = abs(sin(u_time*.4+snoise(vec2(u_time))*.4));\n    p.x += s*.05+.4+(2.*-p.y)*(2.*p.y)*(.65+s*.25);\n    vec3 q = (abs(p)-d.zyx);\n    return max(q.x, max(q.y,q.z))/5.;\n}\n\nfloat boat_mast(vec3 p, out float mat, out vec2 flag_uv)\n{\n    float y = 0.;\n    p.y += water_y(vec2(0.0))*.2;\n    p.y += 0.1;\n    p = rotate_boat(p)*p;\n\n    float hm = 100.;\n    for (int i = 1; i <= 2; i++)\n    {\n        vec3 hp = p-vec3(0.045, float(i)*((0.77-float(2-i)*.1)*.5),-.75*.5);\n        hp.z -= clamp(hp.z, 0., .75);\n        hm = min(hm, length(hp)-0.0175);\n    }\n\n    p.x = -p.x;\n    float f = boat_flag(p-vec3(0.175, 0.55,0.), flag_uv);\n\n    p.y -= clamp(p.y, 0.0, 1.); \n    float m = length(p)-0.025;\n\n    m = min(hm, m);\n\n    if (f < m)\n        mat = 2.;\n    else\n        mat = 1.;\n    \n    return min(f, m);\n}\n\nfloat boat(vec3 p, bool hollow, out float m, out vec2 flag_uv)\n{\n    vec3 bp = transform_boat(p);\n    vec2 h = vec2(0.25, 0.25);\n    \n    float b = hexprism(bp, h);\n    if (hollow)\n        b = max(-hexprism(bp-vec3(0.,0.,0.1), vec2(0.2, h)), b);\n\n    float bm = boat_mast(p,m, flag_uv);\n    float bb = b/2.;\n    if (bb < bm)\n        m = 1.;\n\n    return min(b/2., bm);\n}\n\nfloat voronoi(vec2 uv) {\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n\n    float y = 1.;\n    float id = 0.;\n    for (int i = -1; i <= 1; i++)\n    for (int j = -1; j <= 1; j++)\n    {\n        vec2 c = vec2(i,j);\n        vec2 delta = c-f+hash2f(p+c);\n        float dist = dot(delta,delta);\n        y = min(dist, y);\n    }\n    y = sqrt(y);\n    return y;\n}\n\nvec2 triplanar_uv(vec3 p)\n{\n    return (p.xz + p.xy + p.yz)/3.;\n}\n\nfloat select_top_plane(vec3 p)\n{\n    return step(0.5, dot(p, vec3(0.,1.,0.)));\n}\n\nfloat sdf_water(vec3 p, vec3 s)\n{\n    vec3 q = abs(p)-s;\n    float y_offset = - water_y(p.xz)*.20; \n    if (abs(p.x) <= s.x && abs(p.z) <= s.z)\n        return q.y - y_offset;\n    return max(q.x, max(q.y-y_offset, q.z));\n}\n\nfloat sdf_scene(vec3 p, out float m, out vec2 flag_uv)\n{\n    float dm = 0.;\n    vec2 dm2 = vec2(0.);\n    float water = sdf_water(p, vec3(1.25, 0.5, 1.25));\n    water = max(-boat(p-BOAT_POS,false, dm, dm2), water);\n    m = 0.;\n\n    float boat = boat(p-BOAT_POS, true, m, flag_uv);\n    if (water < boat)\n        m = 0.;\n    float s = min(boat, water);\n    return s;\n}\n\nfloat sdf_scene(vec3 p)\n{\n    float m = 0.;\n    vec2 flag_uv = vec2(0.);\n    return sdf_scene(p, m, flag_uv);\n}\n\nfloat march(vec3 p, vec3 d, float side, out float m, out vec2 flag_uv)\n{\n    float y = 0.;\n    for (int i =0; i < 100; i++)\n    {\n        float sd = sdf_scene(p, m, flag_uv)*side;\n        p += d*sd;\n        y += sd;\n        if (sd <= 0.001 || sd >= 100.) break;\n    }\n    return y;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.01, 0.);\n    float d = sdf_scene(p);\n    return normalize(\n        d-vec3(\n            sdf_scene(p-e.xyy),\n            sdf_scene(p-e.yxy),\n            sdf_scene(p-e.yyx)\n        )\n    );\n}\n\nvec3 sky(vec3 p)\n{\n    float t = normalize(p).y-.25;\n    vec3 top = vec3(1.0, 1.0, 0.2667);\n    vec3 mid = vec3(0.9412, 0.3294, 0.2745);\n    return mix(mid, top, 1.-t*t);\n}\n\nvec3 water_material(vec3 p, vec3 n, vec3 lpos, vec3 r, vec3 reflectdir)\n{\n    float t = u_time*.1;\n\n    float ff = 10.;\n    vec2 vuv = triplanar_uv(p)*5.;\n    vuv = floor(vuv*ff)/ff;\n    float foam = voronoi(vuv);\n    foam = smoothstep(0.2, 1.0, foam)*3.;\n\n    vec3 tol = -LDIR;\n    float yp = step(0.5, dot(n, vec3(0.,1.,0.)));\n    float a = max(0., dot(n, tol));\n    float s = pow(max(0., dot(reflect(LDIR,n), -r)), 1.);\n    vec3 clr = mix(\n        vec3(0.32, 0.573, 0.68),\n        vec3(0.75, 0.85, 0.92),\n        foam * yp\n    );\n\n    // beer's law\n    vec3 rd = r;\n    float mat = 0.;\n    vec2 flag_uv = vec2(0.);\n    float ed = march(p-n*0.01, rd, -1., mat, flag_uv);\n    vec3 absorption_clr = sky(normalize(rd));\n    vec3 bc = exp(-absorption_clr*ed);\n    clr *= bc; \n\n    // clr *= a;\n    vec3 skyclr = sky(vec3(0., 1., 0.));\n    clr = mix(clr,  vec3(1.), s*.5);\n    return clr;\n}\n\nvec3 boat_material(vec3 p, vec3 n, vec3 r)\n{\n    vec3 rp = transform_boat(p);\n    float planks = max(step(0.5, fract(rp.z*10.)), dot(n, vec3(0., 1., 0.)));\n\n    float rand = hash2f(floor(triplanar_uv(p)*50.))*.5+.5;\n\n    float dm = 0.; // dummy material\n    vec2 dm2 = vec2(0.);\n    // shitty ambient occlusion\n    float sd = smoothstep(0., .05, boat(p+n*0.1-BOAT_POS, true, dm, dm2));\n\n    vec3 clr = mix(\n        vec3(0.33, 0.172, 0.262)*1.5, \n        vec3(0.4, 0.302, 0.302)*1.5, \n        planks*rand*sd\n    );\n\n    vec3 tol = LDIR;\n    float a = max(0.75, dot(tol, n));\n    float s = max(0., dot(reflect(r,n), tol));\n    vec3 sc = sky(p);\n\n    return mix(clr, sky(p), 1.-a)*sd+LCOLOR*s; \n}\n\nvec3 flag_material(vec3 p, vec3 n, vec3 r, vec2 uv)\n{\n    float s = pow(max(0., dot(reflect(LDIR, n), -r)), 1.);\n    float ss = snoise(p.yz*100.)*.85; \n    s *= ss*ss;\n\n    vec3 f = flag_texture(uv);\n\n    vec3 cloth_clr = mix(f, vec3(0.9, 0.9, 0.8), s);\n    return cloth_clr;\n}\n\nvec3 lookat(vec3 p, vec3 l, vec2 uv, float fov)\n{\n    vec3 fwd = normalize(l-p);\n    vec3 right = cross(vec3(0.,1., 0.), fwd);\n    vec3 up = cross(fwd, right);\n    return normalize(\n        right*uv.x + up*uv.y + fwd*radians(fov)\n    );\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / u_resolution.xy;\n    uv = (uv-.5)*2.;\n    uv.x *= u_resolution.x / u_resolution.y;\n    \n\n    float rt = u_time*.25;\n    // rt = 0.;\n    vec3 cp = vec3(cos(rt)*3., 2., sin(rt)*3.);\n    vec3 cd = lookat(cp, vec3(0.), uv, 60.);\n\n    float mat = 2.;\n    vec2 flag_uv = vec2(0.);\n    float t = march(cp, cd, 1., mat, flag_uv);\n\n    vec3 p = cp + cd*t;\n    vec3 color = sky(p);\n    if (t < 100.)\n    {\n        vec3 n = normal(p);\n        vec3 l = vec3(-1., 2., -2.);\n\n        if (mat == 0.)\n        {\n            float a = max(0.25, dot(normalize(l-p), n));\n            color = water_material(p, n, l, cd, reflect(normalize(cd), n));\n        }\n        else if (mat == 1.)\n        {\n            color = boat_material(p, n, cd);\n            color *= max(0.55555, dot(LDIR, n));\n        }\n        else\n        {\n            color = flag_material(p, n, cd, flag_uv);\n        }\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}