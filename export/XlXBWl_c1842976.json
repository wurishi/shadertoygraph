{"ver":"0.1","info":{"id":"XlXBWl","date":"1514204354","viewed":2966,"name":"Microcars","username":"iapafoto","description":"Playing with truchet flow... The Boring Company project  :)","likes":95,"published":1,"flags":32,"usePreview":1,"tags":["truchet","flow","cars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by sebastien durand - 05/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//---------------------------------------------------\n\n// Buf A: generation of truchet map and update position of cars (trick to mix cross and turns)\n// Buf B: 3D rendering (using grid optimization)\n// Image: DOF post processing\n\n//---------------------------------------------------\n// The DOF process :\n// For each neigbourg pixels, the algo calculate if the 3D reconstruct pixelPoint is effectively in \n// the 3D cone (circle) of confusion of the pixel. Otherwise it is ignored.\n// => Avoid artfacts on the edges\n//\n// Inspired by Dave Hoskins bokeh disc [https://www.shadertoy.com/view/4d2Xzw]\n//---------------------------------------------------\n\n\n\n#define WITH_DOF\n#define WITH_CONE_TEST\n\n\n#ifdef WITH_DOF\n\nconst float fov = 2.5;\nconst float aperture = 3.;\n\nconst float cosAngle = cos(radians(aperture/2.));\nconst float GA =2.399;  // golden angle = 2pi/(1+phi)\nconst mat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\n\nvec2 res;\n    \n\n\nbool inCone(vec3 p, vec3 o, vec3 n, float side) {\n\treturn side*dot(normalize(o-p), n) >= cosAngle;\n}\n\nvec3 RD(const vec2 q) {\n    return normalize(vec3((2.* q.x - 1.) * res.x/res.y,  (2.* q.y - 1.), fov));\n}\n\n//--------------------------------------------------------------------------\n// eiffie's code for calculating the aperture size for a given distance...\nfloat coc(float t) {\n\treturn max(t*.04, (2./iResolution.y) * (1.+t));\n}\n\nvec3 dof(sampler2D tex, vec2 uv, float fdist) {\n    \n\tvec4 colMain = texture(tex, uv);\n    \n    const float amount = 1.;\n    \n    float rad = min(.3, coc(abs(colMain.w-fdist)));//.3; // TODO calculate this for Max distance on picture\n    \n    float r=2.;\n    \n    vec3 cn = RD(uv),    // Cone axis    \n         co = cn*fdist,  // Cone origin\n         sum = vec3(0.),  \n     \t bokeh = vec3(1),\n         acc = vec3(0),\n         pixPos;\n    \n\n    vec2 pixScreen,\n         pixel = 1./iResolution.xy,        \n         angle = vec2(0, rad);\n    \n    vec4 pixCol;\n    \n    bool isInCone = false;\n\tfor (int j=0;j<60;j++) {  \n        r += 1./r;\n\t    angle *= rot;\n        \n        pixScreen = uv + pixel*(r-1.)*angle; // Neighbourg Pixel\n        pixCol = texture(tex, pixScreen);    // Color of pixel (w is depth)      \n        pixPos = pixCol.w * RD(pixScreen);   // Position of 3D point in camera base\n#ifdef WITH_CONE_TEST\n        if (inCone(pixPos, co, cn, sign(fdist - pixCol.w))) \n#endif            \n        {        // true if the point is effectivelly in the cone\n            bokeh = pow(pixCol.xyz, vec3(9.)) * amount +.4;\n            acc += pixCol.xyz * bokeh;\t\t\t\n            sum += bokeh;\n            isInCone = true;\n        }\n\t}\n        \n    \n \treturn (!isInCone) ? colMain.xyz : // Enable to deal with problem of precision when at thin begining of the cone\n       acc.xyz/sum;\n}\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 5.5 + 2.5*sin(0.1*t-2.);\n\n\treturn .5*vec3(p.x, y, p.y );\n}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    \n    res = iResolution.xy;\n    vec2 mo = (iMouse.xy/iResolution.xy);\n//    vec3 ro = 45.*vec3(-cos(mouse.x), max(.8,mouse.x-2.+sin(mouse.x)*cos(mouse.y)), -.5-sin(mouse.y));\n    \n             vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n    \n      float gTime = 1.*iTime;\n        float time = 0.3*gTime + 50.0*mo.x;\n    \n    \t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time*2.0+15.0 );\n\t\tta = ro + normalize(ta-ro);\n\t\tta.y = ro.y - 0.6;\n        \n        float cr = -0.2*cos(0.1*time);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n    \n \n    \n    float fdist = texture(iChannel0,vec2(0,-.4)).w;//length(ro);//; 64.;\n    \n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec3 c = dof(iChannel0,uv,fdist); \n    c *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .5); // Vigneting\n\tfragColor = vec4(c,1.);\n}\n\n#else \n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec4 c= texture(iChannel0,uv);\n    c *= pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .5); // Vigneting\n\tfragColor = c; \n}\n\n\n#endif","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float gTime;\n\nvec4[12] _PREV = vec4[12](\n    vec4(1,0,-1,0), vec4(-1,0, 1,0), vec4(0,-1,0,1), vec4( 0,1,0,-1),\n    vec4(0,1,1,0),  vec4( 0,1,-1,0), vec4(0,-1,1,0), vec4(-1,0,0,-1),\n    vec4(-1,0,0,1), vec4( 1,0,0,1), vec4(-1,0,0,-1), vec4( 1,0,0,-1)    \n);\n\n\nvec4 state(in vec2 ip ) {\n    return texelFetch(iChannel0, ivec2(ip), 0);\n}\n\n\n// Dave Hoskins's\nvec3 hash23(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n// 0:left 1:right 2:top 3:bottom\nint getSide(vec2 p) {\n    return p.y == 0. ? (p.x < 0. ? 3 : 2) : (p.y < 0. ? 1 : 0);\n}\n\n// 0:left 1:right 2:top 3:bottom\nfloat getBySide(vec4 st, int side) {\n    int sq = int(floor(st.z));\n    vec4 v = sq == 5 ? st.yxyx : sq == 6 ? st.xyxy :\n             sq < 8 ?  st.yxxy : st.yyxx ;\n    return v[side];\n}\n\nvec2 getPrevObj(vec2 ip, int kind) {\n    vec4 p = _PREV[kind];\n    return vec2(getBySide(state(ip+p.xy), getSide(p.xy)),\n    \t\t\tgetBySide(state(ip+p.zw), getSide(p.zw)));\n}\n\n\nint getKind(vec2 ip) {\n    // to introduce linear elements in the flow, we need to import 2 on x and y\n\tvec3 rnd = hash23(floor(ip/2.));\n    if (rnd.z<.6) {\n    \trnd = hash23(ip);\n        rnd.z = 0.;\n    }\n    if (rnd.z<.25) { // curve\n        return (fract(dot(ip, vec2(.5))) > .25 ? 0 : 2) + (rnd.y < .5 ? 0:1);      \n    } else {\t    // linear\n        int sq = 8 + (mod(ip.y,2.)>.5 ? 0 : 1) + (mod(ip.x,2.)>.5 ? 0 : 2);\n        return rnd.z>.5 ? sq :\n        // Transform one element in special curve with inverted directions\n            sq == 9 ? 4 : sq == 8 ? 5 : sq == 11 ? 6 : 7;\n    } \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    gTime = 1.*iTime;\n\n    vec2 p = fragCoord, ip = floor(p);\n\n    if (iTime<.5 || iFrame < 10) {\n\t\t// Init\n        fragColor = vec4(hash23(p).xy, float(getKind(ip)), floor(gTime));\n        \n    } else {\n        vec4 st = state(ip);\n        if (gTime > floor(abs(st.w)) + 1.) {\n        \tint sq = int(round(st.z));\n            st.xy = getPrevObj(ip, sq);\n            st.w = floor(gTime); // prochain switch\n        /*    // switch type\n            vec3 rnd = hash23(ip + floor(time));\n            if (rnd.x>.96) {                \n\t\t\t\t// Possible inversion but without animation for the moment\n\t\t\t//\t     if (sq == 9) st.z = 4., st.w = -st.w;\n            //    else if (sq == 4) st.z = 9., st.w = -st.w;\n            //    else\n                     if (sq == 0) st.z = 1., st.w = -st.w;\n                else if (sq == 1) st.z = 0., st.w = -st.w;                \n                \n            } */\n        }   \n        fragColor = st;  \n    } \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n#define WITH_SHADOW\n#define WITH_REFLEXION\n#define WITH_AO\n    \n#define PRECISION_FACTOR 2e-2\n#define RAYCAST_CARS\n\n#define MIN_DIST_AO .5*PRECISION_FACTOR\n#define MAX_DIST_AO .02\n#define PRECISION_FACTOR_AO PRECISION_FACTOR\n\n#define ZERO min(iFrame,0)\n\nfloat hash1( float n ) { return fract(43758.5453123*sin(n)); }\n\n//------------------------------------------------------------\n\nconst float MAX_DIST_RAYMARCHING = 35.;\nconst int g_traceLimit=48;\nconst float g_traceSize=.001;\n\nconst float \n    ID_GROUND = 2.,\n    ID_ENGINE = 1.,\n    ID_BOX_1 = 1.5,\n    ID_BOX_2 = 1.6;\n    \n#define BACK_COLOR vec3(.008, .016, .034) \n#define PI 3.141592\n#define PI_2 1.5708\n\nconst float lW = .06, lH = .06; //06; // Pipe width. \nconst float bbox = .06;\nconst float bridgeH = .04;\nconst float yTopEnd = lH*3.+bridgeH+bbox*2.; \n\nconst vec3 light = 100.*vec3(-.5,.75,-1.);\n\nfloat gTime;\n\n\nvec4[12] _PREV = vec4[12](\n    vec4(1,0,-1,0), vec4(-1,0, 1,0), vec4(0,-1,0,1), vec4( 0,1,0,-1),\n    vec4(0,1,1,0),  vec4( 0,1,-1,0), vec4(0,-1,1,0), vec4(-1,0,0,-1),\n    vec4(-1,0,0,1), vec4( 1,0,0,1), vec4(-1,0,0,-1), vec4( 1,0,0,-1)    \n);\n\nvec2[4] _DXY = vec2[4](vec2(1,0), vec2(-1,0), vec2(0,1), vec2(0,-1));\n\n\nvec4 _CX[12] = vec4[12](\n    vec4( 1, 1,-1,-1),vec4(-1, 1, 1,-1),vec4(-1,-1, 1, 0),vec4(-1, 1,-1, 0),\n    vec4(-1, 1,-1, 0),vec4( 1, 1, 1, 2),vec4(-1,-1, 1, 0),vec4(-1, 1, 1,-1),    \n    vec4(-1,1,-PI_2,PI),vec4(1,1,-PI_2,0),vec4(-1,-1,PI_2,PI),vec4(1,-1,PI_2,0));\n\n\nfloat hash(float p){\n    return dot(vec2(p,p+1.), vec2(1.361, 113.947));\n} \n\n//------------------------------------------------------------\n// https://iquilezles.org/articles/distfunctions\n//------------------------------------------------------------\n\nfloat sdBox(vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(max(d.x,d.y),d.z),0.) + length(max(d,0.));\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.) + length(max(d,0.));\n}\n\nfloat sdCylinder( vec3 p, vec3 c) {\n  return length(p.xz-c.xy)-c.z;\n}\n\n//------------------------------------------------------------\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\n// rotate a point arround a axis\n//void rotCY(inout vec2 v, vec2 c, mat2 rot) {\n//    v = (v - c) * rot + c;\n//}\n\nvec3 rotY(vec3 v, vec3 c, mat2 rot) {\n    v.xz = (v.xz - c.xz) * rot + c.xz;\n    return v;\n}\n\n\nvec4 state(in vec2 ip ) {\n    return texelFetch( iChannel2, ivec2(ip), 0 );\n}\n\nvec3 getPos1(int sq, float t, out float a) {\n     vec4 cx = _CX[sq];\n     if (sq < 8) {\n        a = (cx.w+cx.z*t)*PI_2;\n     \treturn vec3(.5+.5*(cx.x+cos(a)), 2.*lH, .5+.5*(cx.y+sin(a)));\n     } else {\n         a = cx.z;\n         float dh = -bridgeH*sin(1.5708+3.14*t*2.);\n         return vec3(.5+(.5-t)*cx.x,2.*lH+dh+bridgeH,.5);\n     }\n}\n\nvec3 getPos2(int sq, float t, out float a) {\n     vec4 cx = _CX[sq];\n     if (sq < 8) {\n        a = (cx.w+cx.z*t)*PI_2;\n        a = sq == 4 || sq == 7 ? -a+PI_2 : \n            sq == 5 || sq == 6 ? -a-PI_2 : a+PI;\n     \treturn vec3(.5+.5*(-cx.x+cos(a)),2.*lH, .5+.5*(-cx.y+sin(a)));\n     } else {\n         a = cx.w;\n     \tfloat dh = -2.*bridgeH+bridgeH*sin(1.5708+3.14*t*2.);\n  \t \treturn vec3(.5,2.*lH+bridgeH+dh,(.5-t)*cx.y+.5);\n     }\n}\n\n \n\n//------------------------------------------------------------\n\nvec3 palette( float st ) {\n\treturn .5*cos( 2.*PI*st + vec3(0,1,2) )+.5;\n}\n\n//------------------------------------------------------------\n\nbool cube(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n\treturn tn>0. && tn<tf;\n}\n\n\nbool cubein(vec3 ro, vec3 rd, vec3 sz, out float tn, out float tf) {\n\tvec3 m = 1./rd,\n         k = abs(m)*sz,\n         a = -m*ro-k*.5, \n         b = a+k;\n    tn = max(max(a.x,a.y),a.z);\n    tf = min(min(b.x,b.y),b.z);\n    tn = max(0., tn);\n\treturn tn<tf;\n}\n\n\n// ---------------------------------------------------------------\n\n\n#ifdef RAYCAST_CARS\n\nfloat map_obj(vec4 st, vec3 pos, vec3 sz) {\n\tfloat d = min(\n         sdBox(pos - vec3(sz.x*.1,sz.y*.2,0), vec3(sz.x*.6,sz.y*.8,sz.z*.8)),\n         sdBox(pos - vec3(0,-sz.y*.2,0), vec3(sz.x,sz.y*.4,sz.z*.8)));\n    float r = min(sz.x, sz.y)*.3;\n // pos.z = abs(pos.z); // tis micro optim Crash compilation !\n    float roues = min(sdCappedCylinder(pos.yzx - vec3(-sz.y*.8+r,0.,sz.x*.35),vec2(r,sz.z)),\n                      sdCappedCylinder(pos.yzx - vec3(-sz.y*.8+r,0.,-sz.x*.4),vec2(r,sz.z))\n                   );\n\n    return min(d,roues);\n\n}\n    \n#else \n\nfloat map_obj(vec4 st, vec3 pos, vec3 sz) {\n\treturn sdBox(pos, sz);\n}\n\n#endif\n\nfloat map_08_12(vec4 st, vec3 pos) {\n    float dh = bridgeH*sin(PI_2+PI*pos.x*2.);\n    vec3 pos2 = pos;\n    pos2.y += dh;\n    float d1 = sdBox(pos2-vec3(.5,bridgeH+lH,.5), vec3(.501,lH,lW));\n    pos2.y += dh;\n    d1 = max(d1,-sdBox(pos2-vec3(.5,bridgeH-.02,.5), vec3(.501,lH,lW+.1)));\n    \n    pos2 = pos;\n    pos2.y += bridgeH - bridgeH*sin(PI_2+PI*pos.z*2.);\n    float d2 = sdBox(pos2-vec3(.5,lH,.5), vec3(lW,lH,.5)); \n    \n\treturn max(min(d1,d2), sdBox(pos-vec3(.5,4.*lH,.5), vec3(.501,4.*lH,.501)));;\n}\n\nfloat map_00_07(vec4 st, vec3 pos) {\n    int sq = int(round(st.z));\n    pos-=vec3(.5,lH,.5);\n\tfloat l1 = length(pos.xz - .5*_CX[sq].xy) - .5, \n          l2 = length(pos.xz + .5*_CX[sq].xy) - .5;\n\treturn max(sdBox(pos, vec3(.501,lH,.501)),\n               min(abs(l1), abs(l2))-lW); \n\n}\n\nfloat trace_00_07(vec4 st, vec3 ro, vec3 rd, float traceStart, float traceEnd ) {\n    float h, t = traceStart;\n    for( int i=ZERO; i < g_traceLimit; i++) {\n        h = map_00_07(st, ro+t*rd );\n        t += h;\n        if (h < g_traceSize || t > traceEnd)\n            return t;\n    }\n\treturn traceEnd+1.;\n}\n\nfloat trace_08_12(vec4 st, vec3 ro, vec3 rd, float traceStart, float traceEnd ) {\n    float h,t = traceStart;\n    for( int i=ZERO; i < g_traceLimit; i++) {\n        h = map_08_12(st, ro+t*rd );\n        t += h;\n        if (h < g_traceSize || t > traceEnd)\n            return t;\n    }\n\treturn traceEnd+1.;\n}\n\n// global distance that works localy\nfloat map(in vec3 pos, in vec2 ip) {\n    float time = fract(gTime);\n    vec4 st = state(ip);\n    int sq = int(round(st.z));\n\n    float ha1 = hash(st.x), ha2 = hash(st.y);\n    vec3 sz1 = .03+mod(vec3(ha1, ha1*111.11, ha1*7.3), vec3(bbox-.03)),\n         sz2 = .03+mod(vec3(ha2, ha2*111.11, ha2*7.3), vec3(bbox-.03));\n    \n    vec3 pos1 = pos;\n    pos1.xz -= ip;\n    float d = sq<8?\n        map_00_07(st, pos1) :\n    \tmap_08_12(st, pos1); \n  \n    \n    float a1, a2;\n    vec3 pobj1 = getPos1(sq, time, a1);\n    vec3 pobj2 = getPos2(sq, time, a2);\n  \tpobj1.y += sz1.y;\n    pobj2.y += sz2.y;\n    \n#ifdef RAYCAST_CARS        \n    mat2 rot1 = rot(a1-PI_2),\n         rot2 = rot(a2-PI_2); \n#else\n    mat2 rot1 = rot(a1+2.*PI*fract(ha1)),\n         rot2 = rot(a2+2.*PI*fract(ha2)); \n#endif\n    \n    vec3 \n    \tp1 = rotY(pos1, pobj1, rot1),\n    \tp2 = rotY(pos1, pobj2, rot2);\n\n    \n\td = min(d, map_obj(st, p1-pobj1, sz1));\n\td = min(d, map_obj(st, p2-pobj2, sz2));\n     \n    // Draw closest neigbourg object\n    ip += abs(pos1.x) > abs(pos1.z) ? vec2(sign(pos1.x),0.) : vec2(0., sign(pos1.z));\n    st = state(ip), \n    pos1 = pos;\n    pos1.xz -= ip;\n    d = min(d,sq<8 ? map_00_07(st, pos1) : map_08_12(st, pos1)); \n\n\treturn d;    \n}\n\n             \nvec2 trace_obj(vec4 st, vec3 ro, vec3 rd, float traceStart, float traceEnd ) {\n    \n    float time = fract(gTime);\n    int sq = int(round(st.z));\n    float ha1 = hash(st.x), ha2 = hash(st.y);\n\n    vec3 sz1 = .03+mod(vec3(ha1, ha1*111.11, ha1*7.3), vec3(bbox-.03)),\n         sz2 = .03+mod(vec3(ha2, ha2*111.11, ha2*7.3), vec3(bbox-.03));\n\n    float tstart1, tstart2;\n    \n    float dh = .06*sin(1.5708+3.14*time*2.);\n    float a1, a2;\n  \tvec3 pobj1 = getPos1(sq, time, a1);\n    vec3 pobj2 = getPos2(sq, time, a2);    \n    pobj1.y += sz1.y;\n    pobj2.y += sz2.y;\n#ifdef RAYCAST_CARS        \n    mat2 rot1 = rot(a1-PI_2),\n         rot2 = rot(a2-PI_2); \n#else\n    mat2 rot1 = rot(a1+2.*PI*fract(ha1)),\n         rot2 = rot(a2+2.*PI*fract(ha2)); \n#endif\n    vec3 ro1 = ro, ro2 = ro, rd1 = rd, rd2 = rd;\n    ro1 = rotY(ro, pobj1, rot1);\n    ro2 = rotY(ro, pobj2, rot2);\n    rd1.xz *= rot1;\n    rd2.xz *= rot2;\n    \n    float tend;\n\n\n    // Bounding box\n    bool cube1 = cube(ro1 - pobj1, rd1, sz1*2., tstart1, tend);\n    bool cube2 = cube(ro2 - pobj2, rd2, sz2*2., tstart2, tend);\n    \n\n#ifndef RAYCAST_CARS\n    if (cube1 && tstart1 > traceStart) {\n        if (cube2 && tstart2 > traceStart && tstart2 < tstart1) {\n            return vec2(tstart2, ID_BOX_2);\n        }\n        return vec2(tstart1, ID_BOX_1);\n    } else if (cube2 && tstart2 > traceStart) {\n    \treturn vec2(tstart2, ID_BOX_2);\n    } else {  \n     \treturn vec2(1000.0, 0.);\n    }\n#else\n\n    float t = 0.;\n    \n    if (cube1) t = min(t, tstart1);\n    if (cube2) t = min(t, tstart2);\n    \n    if ((cube1 || cube2) && (t<traceEnd)) {\n        \n        float objId = 0.;\n        t = max(t, traceStart);\n             \n        float h1,h2,h;\n\n        for( int i=ZERO; i < g_traceLimit; i++) {\n            h1 = map_obj(st, ro1+t*rd1-pobj1, sz1);\n            h2 = map_obj(st, ro2+t*rd2-pobj2, sz2);\n            h = min(h1,h2);\n            objId = h1<h2 ? ID_BOX_1 : ID_BOX_2;\n\n            if (h < g_traceSize || t > traceEnd)\n                return vec2(t+h, objId);\n            t = t+h;\n        }\n    }\n\treturn vec2(1000.0,0.);\n#endif \n}\n \n\n\nvec4 min4(vec4 a, vec4 b) {\n    return a.x<=b.x ? a : b;   \n}\n\nvec4 castRay( in vec3 ro, in vec3 rd, in float tstart, in float tend)\n{\n   \n    if (rd.y<.0) { // on regarde vers le bas\n\t\ttstart = max(tstart,(yTopEnd-ro.y)/rd.y);\n\t\ttend = min(tend, -ro.y/rd.y);\n    } else { // on regarde vers le hut\n    \tfloat tp = (yTopEnd-ro.y)/rd.y;\n\t\ttend = min(tend, (yTopEnd-ro.y)/rd.y);\n\t\ttstart = max(tstart, -ro.y/rd.y);\n    }\n    \n\tvec2 pos = floor(ro.xz + rd.xz*tstart);\n\tvec2 ri = 1.0/rd.xz;\n\tvec2 rs = sign(rd.xz);\n\tvec2 ris = ri*rs;\n\tvec2 dis = (pos-ro.xz+ 0.5 + rs*0.5) * ri;\n\n    vec3 rdi = 1.0/rd;\n    vec3 rda = abs(rdi);\n\tvec2 rds = sign(rd.xz);\n\n    \n    tend = min(tend, MAX_DIST_RAYMARCHING);\n\tvec4 res = vec4( tend+1., 4.0, 0.0, 0.0 );\n    \n    // traverse regular grid (in 2D)\n\tfor( int i=ZERO; i<24; i++ ) \n\t{\n        float ts, tn;\n        \n        if (!cubein(ro-vec3(.5+pos.x, yTopEnd*.5, .5+pos.y), rd, vec3(1.01,yTopEnd,1.01), ts, tn)  || (ts > tend || tn < tstart)) {\n           break;   \n        }\n\n        vec2 ip = floor(pos);   \n    \tvec4 st = state(ip);\n    \tint sq = int(round(st.z));\n        float d =  sq<8?\n             \t\ttrace_00_07(st, ro-vec3(pos.x, 0, pos.y), rd, tstart, res.x) :\n             \t\ttrace_08_12(st, ro-vec3(pos.x, 0, pos.y), rd, tstart, res.x); \n        \n        res = min4(res,vec4(d, ID_ENGINE, ip));\n          \n        vec2 d2 = trace_obj(st, ro-vec3(pos.x, 0, pos.y), rd, tstart, res.x);\n        res = min4(res,vec4(d2, ip));\n\n        \n        for (int k=0; k<4;k++) {\n            vec2 pos2 = pos+ _DXY[k];\n\t        vec2 ip2 = ip + _DXY[k];   \n    \t\tvec4 st2 = state(ip2);\n    \t\tint sq2 = int(round(st2.z));\n            \n            \n\t        vec2 d2 = trace_obj(st2, ro-vec3(pos2.x, 0, pos2.y), rd, tstart, res.x);\n        \tres = min4(res,vec4(d2, ip2));\n      //     \tif (cube(ro-vec3(.5+pos.x, lW, .5+pos), rd, 1.3*vec3(lW,lH,lW), ts, tn)) {\n      //     \t\tres = min4(res,vec4(ts, ID_ENGINE, ip2));\n      //  \t}\n        }\n       \n        \n        // step to next cell\t\t\n\t\tvec2 mm = step(dis.xy, dis.yx); \n\t\tdis += mm*ris;\n        pos += mm*rs;\n\t}\n\n\treturn res;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t, vec4 res) {\n\n\tfloat pitch = .2 * t / iResolution.x;\n    \n//#ifdef FAST\n//\t// don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .001 );\n//#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = map(p0, res.zw);\n\tfloat f1 = map(p1, res.zw);\n\tfloat f2 = map(p2, res.zw);\n\tfloat f3 = map(p3, res.zw);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t//return normalize(grad);\n\t// prevent normals pointing away from camera (caused by precision errors)\n\treturn normalize(grad - max(.0,dot (grad,ray ))*ray);\n}\n\n\nvec3 calcNormal( in vec3 pos, in vec3 rd, float d, in vec4 res )\n{\n\tif( res.y>1.99 ) return vec3(0.0,1.0,0.0);\n\treturn Normal(pos, rd, d, res); //normalize(pos*vec3(1.0,1.0-ic,1.0));\n}\n\n\n\nvec3 cameraPath( float t )\n{\n    // procedural path\t\n    vec2 p  = 100.0*sin( 0.02*t*vec2(1.2,1.0) + vec2(0.1,0.9) );\n\t     p +=  50.0*sin( 0.04*t*vec2(1.1,1.3) + vec2(1.0,4.5) );\n\tfloat y = 5.5 + 2.5*sin(0.1*t-2.);\n\n\treturn .5*vec3(p.x, y, p.y );\n}\n\n\n\n#ifdef WITH_AO\n\nfloat calcAO4( const vec3 pos, const vec3 nor ) {\n    float hr, occ = 0., sca = 1.;\n    vec2 ip;\n    for(int i=ZERO; i<5; i++ ) {\n        hr = MIN_DIST_AO + MAX_DIST_AO*float(i)/4.;\n        ip = floor(nor * hr + pos).xz;\n        occ += -(map(nor * hr + pos, ip)-hr)*sca;\n        sca *= .95;\n    }\n    return clamp(1. - 10.*occ, 0., 1.);    \n}\n\n#endif\n\n\n// Adapted from Shane\nvec3 doColor(in float matid, in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, in vec3 objCol, in bool withShadow){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.0);\n    // Combining the above terms to produce the final scene color.\n    vec3 col = objCol*(diff + 0.15);\n    vec3 sceneCol = col + vec3(1., .6, .2)*spec*2.; \n    \n#ifdef WITH_AO\n    float ao = calcAO4(sp, sn);\n    sceneCol *= (.4+.6*ao);\n#endif\n    \n#ifdef WITH_SHADOW\n    // shadows\n    float sh= 1.;\n    if (withShadow) {\n        // HACK to avoid an artfact  :/\n        if (matid == ID_ENGINE && sp.y>0.11 && (fract(sp.z)<0.07||fract(sp.z)>.97 || fract(sp.x)<0.07||fract(sp.x)>.97)) sp.y +=.2;\n    \tsh = castRay(sp+sn*.001, ld, .001, 10.).x;\n    \tsh = 1.-smoothstep(.6,0.2,sh); \n    }      \n    sceneCol *= (.4+.6*sh);\n#endif\n  //  if (matid == ID_ENGINE && (fract(sp.z)<0.07||fract(sp.z)>.97 || fract(sp.x)<0.07||fract(sp.x)>.97)) sceneCol = vec3(1,0,0);\n    return sceneCol*.7;\n}\n\n\n\nvoid fill(inout vec3 col, vec3 c, float d) {\n\tcol = mix(c, col, smoothstep(0.,.01, d));\n}\n\nvoid draw(inout vec3 col, vec3 c, float d, float ep) {\n\tcol = mix(c, col, smoothstep(0.,ep, abs(d)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gTime = 1.*iTime;\n    \n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\t\n    vec2 mo = iMouse.xy / iResolution.xy;\n    if( iMouse.w<=0.00001 ) mo=vec2(0.0);\n\t\t\n    float t = 1000.;\n\t\n\t// montecarlo\t\n\tvec3 tot = vec3(0.0);\n\tint a = 0;\n\t{\n        vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n        p.x *= iResolution.x/ iResolution.y;\n        float time = 0.3*gTime + 50.0*mo.x;\n\n\t\t// camera\n        vec3  ro = cameraPath( time );\n        vec3  ta = cameraPath( time*2.0+15.0 );\n\t\tta = ro + normalize(ta-ro);\n\t\tta.y = ro.y - 0.6;\n        \n        float cr = -0.2*cos(0.1*time);\n\t\n        // build ray\n        vec3 ww = normalize( ta - ro);\n        vec3 uu = normalize(cross( vec3(sin(cr),cos(cr),0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        float r2 = p.x*p.x*0.32 + p.y*p.y;\n        p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n        vec3 rd = normalize( p.x*uu + p.y*vv + 2.5*ww );\n\n\n\n        // background color\t\n\t\tvec3 bgcol = BACK_COLOR;\n\n        vec3 col = bgcol;\n\t\t\n        float tstart = 0.;\n\t\n        vec4  res = castRay(  ro, rd, tstart, MAX_DIST_RAYMARCHING);\n         t = res.x;\n          \n        if (rd.y<0.)\n        \tres = min4(res, vec4(((-.01-ro.y)/rd.y), ID_GROUND, 0,0));\n            \n        if( t > 0.0 ) {\n\t\t\tvec3 pos = ro + rd*res.x;\n            vec2 ip = res.zw;\n            \n            vec4 st = state(ip);\n\t\t\tvec3 nor = calcNormal(pos, rd, t, res );\n            vec3 mate = res.y == ID_GROUND ? vec3(.03) :\n            \t\t\tres.y == ID_ENGINE ? vec3(1.) :\n                \t\tpalette((res.y == ID_BOX_1 ? st.x : st.y));\n            \n            col = doColor(res.y,pos, rd, nor, light, mate, true);\n\t\t\tcol = mix(col, BACK_COLOR, smoothstep(0.3, 1., t/MAX_DIST_RAYMARCHING));\n#ifdef WITH_REFLEXION            \n            if (res.y == ID_GROUND) {\n                \n                rd = reflect(rd, nor);\n                ro = pos + rd*.01;\n           \t\tres = castRay(ro, rd, 0., 1.);\n               \n                if (res.x > 0.0 ) {\n                    vec3 pos = ro + rd*res.x;\n                    vec2 ip = res.zw;\n\n                    st = state(ip);\n                    nor = calcNormal(pos, rd, res.x, res );\n                    mate = res.y == ID_GROUND ? vec3(.1) :\n                                res.y == ID_ENGINE ? vec3(1.) :\n                                palette((res.y == ID_BOX_1 ? st.x : st.y));\n\n                    vec3 colr = doColor(res.y, pos, rd, nor, light, mate, false);\n                    colr = mix(colr, BACK_COLOR, smoothstep(0.3, 1., t/MAX_DIST_RAYMARCHING));\n                    col = mix(col, colr,.1*smoothstep(0.3,.0,res.x));\n\n                }    \n            }\n#endif // WITH_REFLEXION            \n        }\n\t\t\n       // col = clamp(col,0.0,1.0);\n\t\ttot += col;\n\t}\n\t\n\n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.44) );\n\t\t\n\tfragColor = vec4( tot, t>0. ? t : 1000. );\n}\n\n\n\n\n\n\n\n","name":"Buffer B","description":"","type":"buffer"}]}