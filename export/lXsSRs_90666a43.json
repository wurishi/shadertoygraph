{"ver":"0.1","info":{"id":"lXsSRs","date":"1709881117","viewed":177,"name":"simple Normal Mapping  ","username":"yyf1994","description":"simple the demo form  “https://shadertoy.com/view/MXlSR2”","likes":2,"published":3,"flags":32,"usePreview":1,"tags":["shadow","normalmap","normal","nms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Normal Mapping Shadows (test)\" by yyf1994. https://shadertoy.com/view/MXlSR2\n// 2024-03-08 03:13:13\n\n// Fork of \"Normal Mapping Shadows (NMS)\" by BorisVorontsov. https://shadertoy.com/view/7lBBR3\n// 2024-03-06 15:51:32\n\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Normal Mapping Shadow (NMS)\n// Based on paper http://enbdev.com/doc_normalmappingshadows.htm\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3\tlightposition = vec3(0.5, 0.5, 0.5);\n\tvec3\tplaneposition = vec3(fragCoord.xy / iResolution.y, 0.0);\n\tvec2\tuv = fract(fragCoord.xy / iResolution.y);\n\n  \n \n\n \n\tvec3\tlightdir = lightposition - planeposition;\n\n \n\tlightdir = normalize(lightdir.xyz);\n\n\tvec3\tnormal = texture(iChannel0, uv).xyz;\n    vec3\tdiffuse = texture(iChannel1, uv).xyz;\n    \n\tnormal = normal * 2.0 - 1.0;\n\n\t//lighting with flat normals (from vertex or depth generated)\n\tfloat\tlighting = clamp(dot(lightdir, normal), 0.0, 1.0);\n \n \n\n\t//coloring\n\tvec3\tambientcolor = vec3(1. ) * 0.3;\n\tvec3\tlightcolor = vec3(1.0 ) * 1.2;\n\tfloat\tao = (clamp(normal.z, 0.0, 1.0) * 0.5 + 0.5);\n\t fragColor.xyz =  lighting * lightcolor * diffuse ;\n \n\tfragColor.xyz+= ambientcolor;\n  \tfragColor.xyz*= ao; //kinda diffuse\n    \n    fragColor.xyz = normal;\n    \n }\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Prepass generates normal map from picture\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define invNormalMapScale\t\t5.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv;\n\tvec2\toffset;\n\tvec3\tnormal;\n\tvec3\theight;\n\toffset = 1.0 / iResolution.xy;\n\tuv = fract(fragCoord.xy / iResolution.xy);\n   // uv = uv * 0.3;\n\theight.x = texture(iChannel0, uv).x;\n\theight.y = texture(iChannel0, uv + vec2(offset.x, 0.0)).x;\n\theight.z = texture(iChannel0, uv + vec2(0.0, offset.y)).x;\n\tnormal.xy = (height.x - height.yz);\n\tnormal.xy /= offset;\n\tnormal.z = invNormalMapScale;\n\tnormal = normalize(normal);\n\tnormal = normal * 0.5 + 0.5;\n\tfragColor = vec4(normal, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}