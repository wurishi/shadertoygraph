{"ver":"0.1","info":{"id":"4fdyDj","date":"1731181080","viewed":34,"name":"11/9 Shader","username":"Izixs","description":"1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray Marching with Floor\nfloat MARCH_STEPS = 100.0;\nfloat MARCH_MIN_DISTANCE = 0.001;\nfloat MARCH_MAX_DISTANCE = 100.0;\n\n// Basic SDF primitives\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat cylinderSDF(vec3 p, float radius, float height) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(radius, height);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Floor SDF\nfloat floorSDF(vec3 p) {\n    return p.y + 2.0; // Floor at y = -2\n}\n\n// Domain Repetition\nvec3 opRepeat(vec3 p, vec3 spacing) {\n    return mod(p + 0.5 * spacing, spacing) - 0.5 * spacing;\n}\n\nvec3 opRepeatLimited(vec3 p, vec3 spacing, vec3 limit) {\n    return p - spacing * clamp(round(p/spacing), -limit, limit);\n}\n\n// CSG Operations\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\n// Scene Description\nfloat sceneSDF(vec3 p) {\n    // Store original position for non-repeated elements\n    vec3 originalP = p;\n    \n    // Create floor\n    float floor = floorSDF(p);\n    \n    // Create repeated spheres\n    vec3 repP = opRepeat(p, vec3(4.0));\n    float repeatedSpheres = sphereSDF(repP, 0.5);\n    \n    // Create limited repetition of boxes\n    vec3 limitedRepP = opRepeatLimited(p, vec3(4.0), vec3(2.0, 1.0, 2.0));\n    float repeatedBoxes = boxSDF(limitedRepP, vec3(0.3));\n    \n    // Create central structure\n    float centralSphere = sphereSDF(originalP, 2.0);\n    float centralBox = boxSDF(originalP, vec3(1.5));\n    \n    // Subtract cylinders from central structure\n    float cyl1 = cylinderSDF(originalP.xzy, 0.5, 4.0);\n    float cyl2 = cylinderSDF(originalP.yzx, 0.5, 4.0);\n    float cyl3 = cylinderSDF(originalP, 0.5, 4.0);\n    \n    // Combine everything\n    float central = opSmoothUnion(centralSphere, centralBox, 0.5);\n    central = opSubtraction(cyl1, central);\n    central = opSubtraction(cyl2, central);\n    central = opSubtraction(cyl3, central);\n    \n    // Union everything together\n    float final = opUnion(central, repeatedSpheres);\n    final = opUnion(final, repeatedBoxes);\n    final = opUnion(final, floor);\n    \n    return final;\n}\n\n// Calculate surface normal\nvec3 getNormal(vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1.0, -1.0);\n    return normalize(\n        k.xyy * sceneSDF(p + k.xyy * h) +\n        k.yyx * sceneSDF(p + k.yyx * h) +\n        k.yxy * sceneSDF(p + k.yxy * h) +\n        k.xxx * sceneSDF(p + k.xxx * h)\n    );\n}\n\n// Shadow calculation\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float ph = 1e20;\n    float t = mint;\n    for(float i = 0.0; i < 32.0; i++) {\n        float h = sceneSDF(ro + rd * t);\n        if(t > maxt) break;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, k*d/max(0.0, t-y));\n        ph = h;\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Floor pattern\nfloat floorPattern(vec2 p) {\n    float pattern = mod(floor(p.x) + floor(p.y), 2.0);\n    return 0.4 + pattern * 0.1;\n}\n\n// Ray marching function\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float totalDistance = 0.0;\n    \n    for (float i = 0.0; i < MARCH_STEPS; i++) {\n        vec3 currentPos = ro + totalDistance * rd;\n        float dist = sceneSDF(currentPos);\n        \n        totalDistance += dist;\n        \n        if (dist < MARCH_MIN_DISTANCE) return totalDistance;\n        if (totalDistance > MARCH_MAX_DISTANCE) break;\n    }\n    \n    return MARCH_MAX_DISTANCE;\n}\n\n// Main rendering function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Animate camera position\n    float time = iTime * 0.5;\n    vec3 rayOrigin = vec3(8.0 * sin(time), 5.0, 8.0 * cos(time));\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    \n    // Camera setup\n    vec3 forward = normalize(lookAt - rayOrigin);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    vec3 rayDirection = normalize(forward + right * uv.x + up * uv.y);\n    \n    // Ray march\n    float distance = rayMarch(rayOrigin, rayDirection);\n    \n    // Light setup\n    vec3 lightPos = vec3(4.0, 8.0, -3.0);\n    vec3 color = vec3(0.1); // Background color\n    \n    if (distance < MARCH_MAX_DISTANCE) {\n        vec3 hitPos = rayOrigin + distance * rayDirection;\n        vec3 normal = getNormal(hitPos);\n        vec3 lightDir = normalize(lightPos - hitPos);\n        \n        // Material properties\n        vec3 material;\n        if (abs(hitPos.y + 2.0) < 0.01) {\n            // Floor material with checkerboard pattern\n            material = vec3(floorPattern(hitPos.xz));\n        } else {\n            // Other objects material\n            material = vec3(0.7, 0.8, 1.0);\n        }\n        \n        // Lighting calculation\n        float diff = max(dot(normal, lightDir), 0.0);\n        vec3 reflectDir = reflect(-lightDir, normal);\n        float spec = pow(max(dot(-rayDirection, reflectDir), 0.0), 32.0);\n        \n        // Shadow calculation\n        float shadow = softShadow(hitPos + normal * 0.01, lightDir, 0.1, 20.0, 8.0);\n        \n        // Ambient occlusion approximation\n        float ao = 1.0 - (distance / MARCH_MAX_DISTANCE);\n        \n        // Final color\n        color = material * diff * shadow;\n        color += vec3(0.8) * spec * shadow;\n        color *= ao;\n        \n        // Add ambient light\n        color += material * 0.1;\n    }\n    \n    // Basic tone mapping\n    color = color / (1.0 + color);\n    color = pow(color, vec3(0.4545)); // Gamma correction\n    \n    // Output\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}