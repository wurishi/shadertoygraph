{"ver":"0.1","info":{"id":"MlsSWS","date":"1439420271","viewed":167,"name":"Lorenz Raymarcher 2","username":"metabog","description":"Just something rather odd. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lorenz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float angle =iTime*0.2;\n\nfloat x = cos(angle)*20.0;\nfloat y = sin(angle)*20.0;\n\nvec3 cameraOrigin = vec3(x, 20.0, y);\nvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\nvec3 upDirection = vec3(0.0, 1.0, 0.0);\nvec3 cameraDir = normalize(cameraTarget - cameraOrigin);\nvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\nvec3 cameraUp = cross(cameraDir, cameraRight);\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst int MAX_ITER = 20; \n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat distfunc(vec3 pos)\n{\n    return sphere(pos, 2.0);\n}\n\nfloat lorenzDistance(vec3 pos)\n{\n     float pr = -1.0;//iTime;\n\t float r = 1.0 ;\n\t float b = iTime;\n\t float\txn = pos.x;\n\t float\tyn = pos.y;\n\t float\tzn = pos.z;\n    \n       for(int i = 0; i <3; i++)\n    {\n        float xnn = xn + (pr * (yn - xn)) * 0.02;\n\t\tfloat ynn = xn*yn + (-xn * zn + r * xn - yn) * 0.02;\n\t\tfloat znn = zn + (xn * yn - b * zn) * 0.02;\n\t\txn = xnn;\n\t\tyn = ynn;\n\t\tzn = znn;\n    }\n    \n    //distance from origin is our hue\n    float dis = distance(vec3(xn,yn,zn), vec3(0.0,0.0,0.0));\n    \n    return dis;\n}\n\nfloat thresh = 1000.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    float nearClipping = 5.0;\n    float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = 0.01;\n    \n    \n    \n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv*= iResolution.x / iResolution.y;\n    \n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * uv.y + cameraDir);\n    \n    \n    bool hit = false;\n    for (int i = 0; i < MAX_ITER; i++)\n\t{\n \n\n\n        dist = lorenzDistance(pos);\n        if (dist < thresh && dist>nearClipping)\n        {\n         hit = true;\n       \t break; \n        }\n\n    \tpos += 3.0 * rayDir; \n\t}\n    \n\tif (hit==true)\n\t{\n    \tvec2 eps = vec2(0.0, 0.01);\n\t\tvec3 normal = normalize(vec3(\n    \tlorenzDistance(pos + eps.yxx) - lorenzDistance(pos - eps.yxx),\n   \t\tlorenzDistance(pos + eps.xyx) - lorenzDistance(pos - eps.xyx),\n   \t\tlorenzDistance(pos + eps.xxy) - lorenzDistance(pos - eps.xxy)));\n\n   \t\tfloat diffuse = max(0.0, dot(-rayDir, normal));\n    \tfloat specular = pow(diffuse, 32.0);\n        float val = diffuse+specular*0.9;\n    \t//vec3 color = vec3(diffuse + specular*0.5);\n        vec3 hsv = hsv2rgb(vec3(iTime*0.1, 1.0,1.0))*val;\n\t\tfragColor = vec4(hsv.x,hsv.y,hsv.z,1.0);\n        \n\t}\n\telse\n\t{\n   \t\tfragColor = vec4(0.0);\n\t}\n}","name":"","description":"","type":"image"}]}