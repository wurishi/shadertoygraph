{"ver":"0.1","info":{"id":"DtsBWs","date":"1693646960","viewed":38,"name":"rainbow fragment and snap","username":"HaleyHalcyon","description":"aaa","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["aaaa"],"hasliked":0,"parentid":"clffWs","parentname":"rainbow and ripples"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHER 0\n#if DITHER == 1\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return (float(\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    ) + 0.5) / 16.;\n}\n#endif\n\nconst float TURN = 2. * acos(-1.);\n#define ROTVEC(x) vec2(cos((x) * TURN), -sin((x) * TURN))\n\nconst int COUNT = 7;\nconst float FCOUNT = float(COUNT);\n\nfloat spiral(float v) {\n    return \n    smoothstep(\n        0.85, 0.86,\n        abs(1. - 2. * fract(v))\n    );\n}\n\nfloat distanceC(vec2 uv, vec2 xy) {\n    vec2 a = uv - xy;\n    return a.x * a.x + a.y * a.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 4.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    float C = max(0., 0.5 - 2. * pow(abs(0.5 - t) * 2., 3.));\n    float T = pow(max(0., abs(2. * t - 1.) - 0.1), 2.5);\n    T = mix(T, -T, step(t, 0.5));\n    T = 0.8 * t + 2.5 * T;\n    \n    const vec3 COLORS[COUNT] = vec3[COUNT](\n        vec3(1,0,0),\n        vec3(1,0.5,0),\n        vec3(1,1,0),\n        vec3(0,1,0),\n        vec3(0,0.8,1),\n        vec3(0,0.2,1),\n        vec3(0.5,0,1)\n    );\n    \n    vec2 center[COUNT];\n    for (int i = 0; i < COUNT; i++) {\n        center[i] = C * ROTVEC(T + (float(i) / FCOUNT));    \n    }\n    \n    // Time varying pixel color\n    const float S = 4.;\n    const float V = 8.;\n    float v[COUNT];\n    float vsum = 0.;\n    for (int i = 0; i < COUNT; i++) {\n        v[i] = spiral(float(i) / FCOUNT + V * t + S * distanceC(uv, center[i]));\n#if DITHER == 1\n        float thres = crosshatch(fragCoord);\n        thres = mix(thres, 1.-thres, float(i & 1));\n        const float STEPS = 1.;\n        v[i] = (\n            floor(v[i] * STEPS) +\n            step(thres, fract(v[i] * STEPS))\n        ) / STEPS;\n#endif\n        vsum += v[i];\n    }\n\n    vec3 col = vec3(0);\n    float overexposure = clamp((vsum - 1.) / (FCOUNT - 1.), 0., 1.);\n    for (int i = 0; i < COUNT; i++) {\n        col += COLORS[i] * min(1.0, v[i] + overexposure);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}