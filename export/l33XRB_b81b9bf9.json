{"ver":"0.1","info":{"id":"l33XRB","date":"1719322551","viewed":34,"name":"R1-shundroid","username":"shundroid","description":"説明はコメント欄に追加しました。","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["example"],"hasliked":0,"parentid":"MX3XzS","parentname":"Fork iscg-2022- shundroid 758"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray\n{\n    vec3 org;\n    vec3 dir;\n};\nconst uint DIFFUSE = 0u;\nconst uint MIRROR = 1u;\nconst uint DISNEY = 2u;\nconst vec3 WHITE = vec3(1.0, 1.0, 1.0);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 GREEN = vec3(0.0, 1.0, 0.0);\nconst vec3 YELLOW = vec3(1.0, 1.0, 0.0);\nconst uint SPHERE = 0u;\nconst uint TORUS = 1u;\n// TODO\nconst uint WALL1 = 2u;\nconst uint WALL2 = 3u;\nconst uint WALL3 = 4u;\nconst uint WALL4 = 5u;\nstruct Hit\n{\n    float distanceToHitpoint;\n    vec3 point;\n    vec3 normal;\n    uint material;\n    vec3 color;\n    bool isFloor;\n};\nstruct Obj\n{\n    vec3 pos;\n    uint material;\n    vec3 color;\n    uint shape;\n};\n\n// 各種パラメータの例\nfloat FilmWidth() { return iResolution.x / 100.0; }\nfloat FilmHeight() { return iResolution.y / 100.0;  }\nfloat FilmDistance() { return 8.0; }\n\nvec3 CameraFrom() { return vec3(6.0 * cos(iTime * 0.5), 4.0, 6.0 * sin(iTime * 0.5)); }\nvec3 CameraTo() { return vec3(0.0, 0.0, 0.0); }\nvec3 CameraUp() { return vec3(0.0, 1.0, 0.0); }\n//vec3 Light() { return vec3(6.0 * cos(iTime), 1.0, 6.0 * sin(iTime)); }\nvec3 Light() { return vec3(10.0 * cos(iTime), 10.0, 10.0 * sin(iTime)); }\nfloat LargeFloat() { return 1e+6; }\n\n// 正規直交基底を計算する関数の例\nvoid createOrthoNormalBasis(\n    vec3 from, vec3 to, vec3 up,\n    out vec3 u, out vec3 v, out vec3 w, out vec3 e\n)\n{\n    w = normalize(from - to);\n    u = normalize(cross(up, w));\n    v = cross(w, u);\n    e = from;\n}\n\nvec3 convertToCameraCoordinateSystem(\n    vec2 pixelCoordinate\n)\n{\n    \n    return vec3(\n        FilmWidth() * (1.0 - 2.0 * (pixelCoordinate.x + 0.5) / iResolution.x),\n        FilmHeight() * (1.0 - 2.0 * (pixelCoordinate.y + 0.5) / iResolution.y),\n        FilmDistance()\n    );\n}\n\nRay generateCameraRay(\n    vec2 pixelCoordinate\n)\n{\n    // 1. ピクセル座標をカメラ座標系に変換\n    vec3 cameraCoordinate = convertToCameraCoordinateSystem(pixelCoordinate);\n    // 2. カメラパラメータからカメラ座標系の正規直交基底を計算。\n    vec3 u, v, w, e;\n    createOrthoNormalBasis(\n        CameraFrom(), CameraTo(), CameraUp(),\n        u, v, w, e\n    );\n    // 3. ピクセル座標を基底を用いてワールド座標系に変換\n    vec3 worldCoordinate =\n        cameraCoordinate.x * u + cameraCoordinate.y * v + cameraCoordinate.z * w + e;\n    // 4. カメラレイを計算。\n    Ray ray = Ray(e, normalize(e - worldCoordinate));\n    return ray;\n}\n\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\nfloat sdCoin(vec3 p, float r, float z) {\n    return max(length(p) - r, abs(p).z - z);\n}\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\nvec3 normalSphere(vec3 p) {\n    return normalize(p);\n}\nvec3 normalTorus(vec3 p, vec2 t)\n{\n    float xylen = length(p.xy);\n    float d = xylen - t.x;\n    return normalize(vec3(2.0 * d / xylen * p.xy, 2.0 * p.z));\n}\nvoid intersect(Ray ray, Obj obj, out Hit hit)\n{\n    hit.distanceToHitpoint = LargeFloat();\n    if (obj.shape == WALL1) {\n        vec3 d = normalize(vec3(1.0, 0.0, 1.0));\n        float ratio = dot(ray.dir, d);\n        if (ratio <= 0.0) return;\n        hit.distanceToHitpoint = (obj.pos.x + obj.pos.z - ray.org.x - ray.org.z) / sqrt(2.0) / ratio;\n        hit.point = ray.org + hit.distanceToHitpoint * ray.dir;\n        hit.material = obj.material;\n        hit.color = obj.color;\n        hit.isFloor = false;\n        hit.normal = -d;\n        return;\n    }\n    if (obj.shape == WALL2) {\n        vec3 d = normalize(vec3(-1.0, 0.0, -1.0));\n        float ratio = dot(ray.dir, d);\n        if (ratio <= 0.0) return;\n        hit.distanceToHitpoint = -(obj.pos.x + obj.pos.z - ray.org.x - ray.org.z) / sqrt(2.0) / ratio;\n        hit.point = ray.org + hit.distanceToHitpoint * ray.dir;\n        hit.material = obj.material;\n        hit.color = obj.color;\n        hit.isFloor = false;\n        hit.normal = -d;\n        return;\n    }\n    if (obj.shape == WALL3) {\n        vec3 d = normalize(vec3(-1.0, 0.0, 1.0));\n        float ratio = dot(ray.dir, d);\n        if (ratio <= 0.0) return;\n        hit.distanceToHitpoint = (obj.pos.x - obj.pos.z + ray.org.x - ray.org.z) / sqrt(2.0) / ratio;\n        hit.point = ray.org + hit.distanceToHitpoint * ray.dir;\n        hit.material = obj.material;\n        hit.color = obj.color;\n        hit.isFloor = false;\n        hit.normal = -d;\n        return;\n    }\n    if (obj.shape == WALL4) {\n        vec3 d = normalize(vec3(1.0, 0.0, -1.0));\n        float ratio = dot(ray.dir, d);\n        if (ratio <= 0.0) return;\n        hit.distanceToHitpoint = -(-obj.pos.x + obj.pos.z + ray.org.x - ray.org.z) / sqrt(2.0) / ratio;\n        hit.point = ray.org + hit.distanceToHitpoint * ray.dir;\n        hit.material = obj.material;\n        hit.color = obj.color;\n        hit.isFloor = false;\n        hit.normal = -d;\n        return;\n    }\n\n    float t = 0.0;\n    vec3 p;\n    float s;\n    for (int i = 0; i < 100; i++) {\n        p = ray.org + t * ray.dir;\n        if (obj.shape == SPHERE) {\n            s = sdSphere(p - obj.pos, 1.0);\n        } else if (obj.shape == TORUS) {\n            s = sdTorus(p - obj.pos, vec2(0.8, 0.3));\n        }\n        if (s < 0.001) {\n            hit.distanceToHitpoint = t;\n            hit.point = p;\n            if (obj.shape == SPHERE) {\n                hit.normal = normalSphere(p - obj.pos);\n            } else if (obj.shape == TORUS) {\n                hit.normal = normalTorus(p - obj.pos, vec2(1.0, 0.2));\n            }\n            hit.material = obj.material;\n            hit.color = obj.color;\n            hit.isFloor = false;\n            break;\n        }\n        t += s;\n    }\n}\nvoid intersectFloor(Ray ray, out Hit hit, float z)\n{\n    if (ray.dir.y >= 0.0 || ray.org.y < z) {\n        hit.distanceToHitpoint = LargeFloat();\n    } else {\n        float r = (ray.org.y - z) / -ray.dir.y;\n        hit.distanceToHitpoint = r;\n        hit.point = ray.org + ray.dir * r;\n        hit.normal = vec3(0.0, 1.0, 0.0);\n        hit.material = DIFFUSE;\n        hit.color = WHITE;\n        hit.isFloor = true;\n    }\n}\nbool fastIntersect(Ray ray, Obj obj)\n{\n    if (obj.shape == SPHERE) {\n        vec3 v = obj.pos - ray.org;\n        vec3 d = dot(v, ray.dir) * ray.dir - v;\n        return length(d) <= 1.0;\n    } else if (obj.shape == TORUS) {\n        // first, try with sphere\n        vec3 v = obj.pos - ray.org;\n        vec3 d = dot(v, ray.dir) * ray.dir - v;\n        if (length(d) > 1.1) return false;\n        vec3 p;\n        float t = 0.0;\n        float s;\n        for (int i = 0; i < 100; i++) {\n            p = ray.org + t * ray.dir;\n            s = sdTorus(p - obj.pos, vec2(0.8, 0.3));\n            if (s < 0.001) {\n                return true;\n            }\n            t += 1.2 * s;\n        }\n        return false;\n    } else {\n        return false;\n    }\n}\nconst int lightLen = 4;\nvec3[] lights = vec3[] (\n    vec3(5.0, 5.0, 5.0),\n    vec3(-5.0, 5.0, 5.0),\n    vec3(5.0, 5.0, -5.0),\n    vec3(-5.0, 5.0, -5.0)\n);\nfloat f_schlick(vec3 v, vec3 h, float f0, float f90) {\n    float f_ = 1.0 - dot(v, h);\n    f_ *= f_ * f_ * f_ * f_;\n    return f0 + (f90 - f0) * f_;\n}\nconst int objLen = 4;\nObj[] objs = Obj[] (\n    Obj(vec3(-2.0, 0.0, 0.0), MIRROR, WHITE, SPHERE),\n    Obj(vec3(2.0, 0.0, 0.0), MIRROR, WHITE, SPHERE),\n    Obj(vec3(0.0, 0.0, -2.0), DISNEY, RED, SPHERE),\n    Obj(vec3(0.0, 0.0, 2.0), DIFFUSE, GREEN, TORUS),\n    // WALL: todo\n    Obj(vec3(15.0, 0.0, 0.0), DIFFUSE, YELLOW, WALL1),\n    Obj(vec3(-15.0, 0.0, 0.0), DIFFUSE, WHITE, WALL2),\n    Obj(vec3(15.0, 0.0, 0.0), MIRROR, WHITE, WALL3),\n    Obj(vec3(15.0, 0.0, 0.0), MIRROR, WHITE, WALL4)\n);\nvec3 computeIrradiance(Hit hit, Ray ray) {\n    float alpha = 1.2;\n    vec3 sum = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < lightLen; i++) {\n        vec3 raw_d = lights[i] - hit.point;\n        vec3 d = normalize(raw_d);\n        float c = dot(d, hit.normal);\n        Ray ray = Ray(hit.point, d);\n        if (hit.isFloor) {\n            bool intersected = false;\n            for (int i = 0; i < 4; i++) {\n                if (fastIntersect(ray, objs[i])) {\n                    intersected = true;\n                    break;\n                }\n            }\n            if (!intersected) {\n                sum += hit.color * c / length(raw_d) * 8.0;\n            }\n        } else {\n            sum += hit.color * c / length(raw_d) * 8.0;\n        }\n    }\n    float sigma = 1.0;\n    return sigma / 3.14 * sum;\n}\nvec3 computeDisneyIrradiance(Hit hit, Ray ray) {\n    float alpha = 0.4;\n    vec3 sum = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < lightLen; i++) {\n        vec3 raw_d = lights[i] - hit.point;\n        vec3 d = normalize(raw_d);\n        float c = dot(d, hit.normal);\n        vec3 h = normalize(-ray.dir + d);\n        float cosine = dot(h, ray.dir);\n        float f90 = 0.5 + 2.0 * alpha * cosine * cosine;\n        float f2 = f_schlick(hit.normal, ray.dir, 1.0, f90);\n        float f1 = f_schlick(hit.normal, d, 1.0, f90);\n        sum += f1 * f2 * hit.color * c / length(raw_d) * 3.0;\n    }\n    float sigma = 1.0;\n    return sigma / 3.14 * sum;\n}\nvoid computeReflectionRay(inout Ray ray, Hit hit) {\n    ray.dir = -2.0 * dot(ray.dir, hit.normal) * hit.normal + ray.dir;\n    ray.org = hit.point + 0.1 * ray.dir;\n}\nfloat g1(vec3 n, vec3 v, float alpha)\n{\n    float k = (alpha + 1.0) * (alpha + 1.0) / 8.0;\n    float nv = dot(n, v);\n    return nv / (nv * (1.0 - k) + k);\n}\nvoid gammaCorrection(inout vec4 c)\n{\n    float gamma = 2.2;\n    c.x = pow(c.x, 1.0/gamma);\n    c.y = pow(c.y, 1.0/gamma);\n    c.z = pow(c.z, 1.0/gamma);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Ray ray = generateCameraRay(fragCoord);\n    Hit firstHit, hit;\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    float ratio = 1.0;\n    for (int it = 0; it < 4; it++) {\n        intersectFloor(ray, firstHit, -1.0);\n        for (int i = 0; i < objLen; i++) {\n            intersect(ray, objs[i], hit);\n            if (firstHit.distanceToHitpoint > hit.distanceToHitpoint) {\n                firstHit = hit;\n            }\n        }\n        if (firstHit.distanceToHitpoint < LargeFloat())\n        {\n            if (firstHit.material == DIFFUSE) {\n                fragColor = ratio * vec4(computeIrradiance(firstHit, ray), 0.0);\n                gammaCorrection(fragColor);\n                return;\n            } else if (firstHit.material == DISNEY) {\n                fragColor = ratio * vec4(computeDisneyIrradiance(firstHit, ray), 0.0);\n                gammaCorrection(fragColor);\n                return;\n            }\n            float alpha = 1.0;\n            float f0 = 1.0;\n            float f90 = 0.0;\n            \n            vec3 v = ray.dir;\n            computeReflectionRay(ray, firstHit);\n            vec3 n = firstHit.normal;\n            vec3 l = ray.dir;\n            vec3 h = normalize(v + l);\n            float alpha_square = alpha * alpha;\n            float dot_square = dot(n, h);\n            dot_square *= dot_square;\n            float a = dot_square * (alpha_square - 1.0) + 1.0;\n            a *= a;\n            float D = alpha_square / (3.14 * a);\n            float nv = dot(n, v);\n            float G = g1(n, v, alpha) * g1(n, l, alpha);\n            float F = f_schlick(v, h, f0, f90);\n            ratio = D * G * F / (4.0 * dot(n, v) * dot(n, l));\n            continue;\n        }\n        else\n        {\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            gammaCorrection(fragColor);\n            return;\n        }\n    }\n    fragColor = ratio * vec4(1.0, 0.0, 1.0, 0.0);\n    gammaCorrection(fragColor);\n}","name":"Image","description":"","type":"image"}]}