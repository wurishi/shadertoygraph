{"ver":"0.1","info":{"id":"wdScRd","date":"1593555778","viewed":3526,"name":"Futuristic Tunnel","username":"julianlumia","description":"Some random sketch I found\n","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["futuristic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_STEPS 60\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\n//---------\n#define PI 3.14159\n#define TAU PI*2.\n#define t iTime\nmat2 rz2 (float a) { float c=cos(a), s=sin(a); return mat2(c,s,-s,c); }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat cube (vec3 p, vec3 r) { return length(max(abs(p)-r,0.)); }\n\nvec2 path(float z){\n float x = sin(z) - 4.0 * cos(z * 0.3) - .5 * sin(z * 0.12345);\n float y = cos(z) - 4. * sin(z * 0.3) - .5 * cos(z * 2.12345);\n return vec2(x,y);\n}\nvec2 path2(float z){\n float x = z;\n float y = cos(z) - 10. * sin(z * 0.3) - .01 * cos(z * .14);\n return vec2(x,y);\n}\n\n\nvec2 modA (vec2 p, float count) {\n float an = TAU/count;\n float a = atan(p.y,p.x)+an*.5;\n a = mod(a, an)-an*.5;\n return vec2(cos(a),sin(a))*length(p);\n}\n\nfloat smin (float a, float b, float r)\n{\n float h = clamp(.5+.5*(b-a)/r,0.,1.);\n return mix(b, a, h) - r*h*(1.-h);\n}\n\n\n//----\n\n\n\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\n\nvec2 GetDist(vec3 p) {\n    \n vec2 o2 = path2(p.z) / 4.;\n p = vec3(p.x,p.y,p.z)-vec3(o2.x,o2.y,0.);  \n    \n    \n vec2 d;\n vec3 p2 = p;\n float gap = 1.;\n p2 = mod(p + gap,2.0 * gap) - gap;\n\n     vec3 p4 = p;\n     float gap2 = 1.;\n\n p4.z = mod(p.z + gap2,2.0 * gap) - gap;\n    \n vec2 box = vec2(sdBox(p2-vec3(0,0.,.0), vec3(.1,1.,.95)),3);\n vec2 box2 = vec2(sdBox(p2-vec3(0.,0.,.0), vec3(.8,.2,.95)),3);\n vec2 box3 = vec2(sdBox(p2-vec3(0,0.,0), vec3(.4,sin(p.x*1.+2.8)+0.4,.95)),3);\n p2 = vec3( p- vec3(1.,1.,p.z-1.)); \n float the = iTime *-.5;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.5;\n p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n float size = .4;\n p2 = abs(p2)-.2;\n vec2 dbox2 = vec2(sdBox( p2,vec3(size)),3);\n vec2 dbox20 = vec2(sdOctahedron( p2,(size)),3);\n dbox2.x = mix (dbox2.x,dbox20.x,1.2);\n p2 = vec3( p- vec3(1.,1.,p.z+0.5)); \n the = iTime *-0.2;\n p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.4;\n p2.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2 = abs(p2)-1.2;\n vec2 dbox4 = vec2(sdSphere( p2-vec3(0.,-0.,-.0),(.02)),1);\n vec3 p3 = vec3( p- vec3(1.,1.,p.z-1.)); \n the = iTime *-.5;\n p3.xz *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.5;\n p3.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 dbox5 = vec2(sdBox( p3,vec3(.2)),1);\n\n g3 +=1./(0.1+pow(abs(dbox4.x),5.));\n g4 +=1./(1.+pow(abs(dbox5.x),1.));\n box = condmin(box3,box);\n box = condmin(box2,box);\n vec2 o = path(p.z) / 4.0;\n p = vec3(p)-vec3(1,1.,1.);\n p.xy *= rz2(p.z*sin(1.+250.));    \n float cyl2wave = 1.+1.5*(sin(p.z+t*5.)*.1);\n float cylfade = 1.+smoothstep(.0,5.,abs(p.z+iTime*1.));\n float cyl2r = 0.01*cyl2wave*cylfade;\n float cylT = 1.;\n float cylC = 1.;\n vec2 cyl2p = modA(p.xy, (abs(sin(t*1.)+4.)))-vec2(cyl2wave, 0)*cylfade;   \n vec2 cyl2 = vec2(cyl(cyl2p, cyl2r),1);\n vec3 cubP = p;\n      vec2 box7 = vec2(sdBox(p4-vec3(1,1.,0.), vec3(1.,.5,.4)),1);\n\n float cubC = .1;\n cubP.z = mod(cubP.z, cubC)-cubC*.01;\n cubP.xy *= rz2(t*1.);\n vec2 cub =vec2(cube(cubP,vec3(.1*cyl2wave*cylfade)),3.);\n vec2 ebox = condmin(cyl2,box);\n ebox = condmin(ebox,dbox2);\n ebox.x =(max(ebox.x,-box7.x));\n\n g1 +=1./(.01+pow(abs(cub.x),2.));\n g2 +=1./(.01+pow(abs(cyl2.x),2.));\n d = ebox;\n return d ;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *.7;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=0.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 20; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.001 || (t)>100.) break;\n  t += d * 1.;\n  marchCount+= 1./d*1.;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 a = path2(iTime * 1.0)*1.0;\n vec3 o = vec3(a / 4.0,iTime);   \n vec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\n vec2 m = iMouse.xy/iResolution.xy;\n vec3 eye = 1.0*vec3(o)-vec3(-1.,-1.,0);\n float   the = (iTime*.3);\n vec3 hoek = vec3(1,1.,1);  \n the = (iTime*.2)-2.5;\n//hoek.yz *= mat2(cos(the), -sin(the), sin(the), cos(the))*100.;\n// hoek.xz *= mat2(cos(the), -sin(the), sin(the), cos(the))*50.;\n\n mat3 camera = setCamera( eye, hoek,4.7);\n float fov = .6;\n vec3 dir = camera * normalize(vec3(uv, fov));\n float lensResolution = 1.5;\n float focalLenght =1.;\n float lensAperture = .02;\n float inc = 1./lensResolution;\n float start = inc/2.-1.;\n vec3 focalPoint = eye + (dir * focalLenght);\n for (float stepX = start; stepX < 0.5; stepX+=inc){\n for (float stepY = start; stepY < .5; stepY+=inc){\n vec2 shiftedOrigin = vec2(stepX, stepY) * lensAperture;\n  if (length(shiftedOrigin)<(lensAperture/1.5)){\n  vec3 shiftedRayOrigin = eye;\n  shiftedRayOrigin.x += shiftedOrigin.x;\n  shiftedRayOrigin.y += shiftedOrigin.y;\n  vec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n  vec2 d = RayMarch(shiftedRayOrigin, shiftedRay);\n  float t =d.x *1.;   \n   if(t>.001){\n    vec3 baseColor = vec3(0.,0.,0.);\n    shiftedRayOrigin += shiftedRay * t;\n    vec3 sn = GetNormal(shiftedRayOrigin);\n    shiftedRay = reflect(shiftedRay, sn);\n    if(d.y==3.) traceRef(shiftedRayOrigin +  shiftedRay*.1, shiftedRay);\n    }\n   }\n  }\n }\n vec3 d = vec3(0.);\n// d *= marchCount * vec3(1., 1.,1.) * 1.;\nd +=g1*vec3(0.0003)*abs(vec3(sin(iTime-1.)+0.5+0.5,sin(iTime-2.5)+0.5+0.5,sin(iTime-2.)+0.5+0.5)*.5);    \nd +=g2*vec3(0.0002)*vec3(cos(iTime),1,1);    \nd +=g3*vec3(0.003)*vec3(abs(sin(iTime-2.)),.5,1.)*abs(cos(iTime*0.5));    \n d +=g4*vec3(0.002)*vec3(abs(sin(iTime)),0,0);    \n vec3 sky = vec3(1., 1., 1.);\n d = mix(sky, d, 1.0/(d.x*d.x/1./1.*.1+1.)); \nd*= .9;\n fragColor = vec4(d,1.0);\n}","name":"Image","description":"","type":"image"}]}