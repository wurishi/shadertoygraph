{"ver":"0.1","info":{"id":"WsXSW8","date":"1551928427","viewed":92,"name":"AnotherRaymarchPracticeShader","username":"bignobody","description":"More raymarch practice. First try at soft shadows and reflections. Thanks as always to iq and Jamie Wong for the tutorials. Constructive feedback is welcome... math is hard.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_LIGHTS 1\n#define AMBIENT_LIGHT 1.61\n\nvec3 colours[6] = vec3[](vec3(0.8,0.04,0.01), vec3(0.04,0.8,0.01), vec3(0.01,0.04,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4));\n\n// sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\nfloat sdfBox( vec3 p, vec3 t, vec3 b )\n{\n  vec3 d = abs(p - t) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  // n must be normalized\n  return dot(p-t,n.xyz) + n.w;\n}\nfloat sdfTorus( vec3 p, vec3 tr, vec2 t )\n{\n\tp = p-tr;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothInter( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n////////\n\n// objects map\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    float def = 500.0;\n    float d = sdfPlane(p,vec3(0.0,-2.5,0.0),normalize(vec4(0.0,1.0,0.0,1.0)));\n    pick = 4;\n    \n    if (d > def)\n    {\n      d = def;   \n    }\n    \n     float so = sdfTorus(p,vec3(0.0,1.75 ,0.0),vec2(2.0,1.0));//sdfSphere(p,vec3(0.0),1.0);\n   // float so = sdfTorus(p,vec3(0.0,1.75 * cos(iTime),0.0),vec2(2.0,1.0));//sdfSphere(p,vec3(0.0),1.0);\n   //float so = sdfSphere(p,vec3(0.0,1.75 * cos(iTime),0.0),2.0);\n   // float so = sdfBox(p,vec3(0.0,1.75,0.0),vec3(1.0));\n    if (so < d)\n    {\n        pick = 2;\n        d = so;\n    }\n    \n\tso = sdfSphere(p,vec3(-5.5 * cos(iTime),0.25,5.5 * sin(iTime)),2.0);\n    \n    if (so < d)\n    {\n        pick = 1;\n        d = so;\n    }\n\n\tso = sdfSphere(p,vec3(5.5 * cos (iTime),5.5* sin(iTime),0.0),2.0);\n    \n    if (so < d)\n    {\n        pick = 0;\n        d = so;\n    }\n\n\n    return d;\n    \n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.0001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getGroundColour(vec2 dc)\n{\n \tvec2 sc = vec2(cos(dc.x * 500.0),sin(dc.y * 500.0));\n    //float r = sin(sc.x * sc.y + dc.x * dc.y); \n    float r = sin(sc.x * sc.y); \n    float a = cos(length(dc) * 0.5) - 0.5;\n    return vec3(r,r+a,r*a) + vec3(dc.x,dc.y,dc.x+dc.y) * 10.0;   \n}\n\nvec3 getLightPosition(int l)\n{\n    if (l == 0)\n    {\n        return vec3(0.0,5.5*cos(iTime*0.5)+4.95,0.0);\n      //  return vec3(-5.5* sin(iTime),2.0 + cos(iTime) * 5.0 ,-5.5* cos(iTime));\n        //return vec3(0.0,5.5* cos(iTime)+2.0 , 0.0);\n      // return vec3(-8.80 * sin(iTime),8.0 ,-8.5* cos(iTime));\n   //     return vec3(-4.0, 34.0 ,-4.0);\n    }\n    return vec3(80.80 * sin(iTime*0.5),80.0 ,80.5* cos(iTime * 0.5));\n    //return vec3(4.0,34.0,4.0);\n}\n\n// lighting adapted from Jamie Wong's tutorials\nvec3 phongLight(vec3 diffuse, vec3 specular, float shine, vec3 lightPos, vec3 lightIntensity, vec3 surfacePoint, vec3 surfaceNormal, vec3 eye) \n{\n \tvec3 N = surfaceNormal;\n    vec3 L = normalize(lightPos - surfacePoint);\n    vec3 V = normalize(eye - surfacePoint);\n    vec3 R = normalize(reflect(-L, N));\n        \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return diffuse * 0.01;\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (diffuse * dotLN);\n    }\n    return lightIntensity * (diffuse * dotLN + specular * pow(dotRV, shine));\n}\n\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 normal, float ambientLight, float shadow, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    \n    vec3 lightIntensity[2] = vec3[2](vec3(0.6,0.6,0.6),vec3(0.6,0.6,0.6));\n    vec3 lightSpec[2] = vec3[2](vec3(1.0,1.0,1.0),vec3(1.0,1.0,1.0));\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n    \t//surfaceColour = mix(surfaceColour, phongLight(colours[pick]-shadow, lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], normal, eye, pick), 0.5);\n//        surfaceColour = max(surfaceColour, \n //                           phongLight((colours[pick]-shadow), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], normal, eye, pick)\n  //                          );\n\n        \t\t\t\t\t\t//\t(vec3 diffuse, vec3 specular, float shine, vec3 lightPos, vec3 lightIntensity, vec3 p, vec3 eye, inout int pick) \n        surfaceColour += phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour;\n}\n\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint, float start, float end )\n{\n    vec3 direction = normalize((lightOrigin)-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    for( float s=start; s < end; )\n    {\n        vec3 marchStep = lightOrigin + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.001)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\n\nfloat calcSurfaceShadow(vec3 p)\n{\n    float darken = 1.0;\n\tfor (int i  = 0; i < NUM_LIGHTS; i ++)\n    {\n    \t//vec3 lv = p + getLightPosition(i);\n        //darken += shadowMarch(getLightPosition(i),p, 0.9, 200.0);\n        darken = min(darken, shadowMarch(getLightPosition(i),p, 0.0001, 500.0));\n    }\n    return darken;\n}\n\n// since we can't have recursion, marching reflections here\nvec3 reflectMarch( vec3 origin, vec3 direction, inout int pickTarget, inout vec3 surfacePoint)\n{\n\tfloat marchDistance = 0.01;\n    vec3 marchVec = origin;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 1000;\n    const float MAX_DISTANCE = 500.0;\n    const float CLOSE_ENOUGH = 0.0001;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + direction * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n\t\t\tbreak;         \t\n        }\n        \n        marchDistance += distNow;   \n        \n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n            pickTarget = 5;\n        \treturn colours[pickTarget] - direction.y * 0.5;   \n        }\n        \n    }\n\n    return lightSurfacePoint(origin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, calcSurfaceShadow(surfacePoint), pickTarget);\n}\n\n\nvec3 rayMarch( vec3 origin, vec3 direction, int numReflections, inout vec3 surfacePoint )\n{\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = origin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 1024;\n    const float MAX_DISTANCE = 500.0;\n    const float CLOSE_ENOUGH = 0.0001;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n    vec3 colAccum = vec3(0.0);\n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + direction * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            // hit something!\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n            float shadowVal = calcSurfaceShadow(marchStep);\n            colAccum = lightSurfacePoint(origin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, shadowVal, pickTarget);\n            \n            float mixVal = 0.5;\n            for(int r = 0; r < numReflections; r ++)\n            {\n                vec3 org = surfacePoint;\n            \tcolAccum = mix(colAccum, reflectMarch( org, normalize(reflect((direction), surfaceNormal)), pickTarget, surfacePoint),mixVal);\n              //  colAccum = max(colAccum, reflectMarch( surfacePoint, reflect(normalize(direction), surfaceNormal), pickTarget, surfacePoint));\n                mixVal -= 0.1;\n            }\n\t\t\tbreak;         \t\n        }\n        else\n        {\n         \tmarchDistance += distNow;   \n        }\n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n        \t pickTarget = 5;\n        \treturn colours[pickTarget] - direction.y * 0.5;    \n        }\n        \n        \n    }\n    \n    return colAccum;\n   \n}\n\n\nvec3 castRay(vec3 origin, vec3 lookAt, vec2 fragCoord, float zoom)\n{\n    vec3 forwardVec = normalize(lookAt - origin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = origin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + fragCoord.x * rightVec + fragCoord.y * upVec;\n    return normalize(intersectVec - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 dc = uv * 2.0 - 1.0;\n\t//vec2 dc = uv - vec2(0.5);\n    dc.x *= iResolution.x/iResolution.y;\n   // vec3 rayOrigin = vec3(3.0 * cos(iTime),6.0 + sin(iTime * 0.5),5.0 * sin(iTime));\n     //vec3 rayOrigin = vec3(20.0 * sin(iTime*0.5),6.0 * sin(iTime)+3.0 ,20.0 * cos(iTime));\n  //vec3 rayOrigin = vec3(10.0 * cos(iTime),5.5 ,10.0 * sin(iTime));    \n   vec3 rayOrigin = vec3(0.0,8.0,9.0);\n    vec3 rayDirection = castRay(rayOrigin, vec3(0.0,0.0,0.0), dc, 1.0);\n   // colours[4] = getGroundColour(rayDirection.xy * length(dc));\n    int numReflections = 1;\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = rayMarch(rayOrigin, rayDirection, numReflections, surfacePoint);\n//    col *= calcSurfaceShadow(surfacePoint);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}