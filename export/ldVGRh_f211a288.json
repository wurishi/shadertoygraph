{"ver":"0.1","info":{"id":"ldVGRh","date":"1454065285","viewed":3672,"name":"Glints","username":"tszirr","description":"Example code for our i3D paper \"Real-time Rendering of Procedural Multiscale Materials\".","likes":45,"published":1,"flags":32,"usePreview":1,"tags":["procedural","landscape","snow","microfacet","glints","coherentnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n// Created by Tobias Zirr (KIT, NVIDIA) and Anton Kaplanyan (NVIDIA)\n// Based on https://www.shadertoy.com/view/Xds3zN created by Inigo Quilez\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// For a less restrictive license, find the isolated shading code at:\n// http://alphanew.net/releases/glints/shading.txt\n\n// Example code for the paper \"Real-time Rendering of Procedural Multiscale Materials\",\n// Tobias Zirr (NVIDIA / KIT), Anton Kaplanyan (NVIDIA),\n// in ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games, February 2016.\n// More info on https://research.nvidia.com/publication/real-time-rendering-procedural-multiscale-materials\n\n//----------------------------------------------------------------------\n\n// !!! This is just the post-processing, see Tab \"Buf A\" for rendering code !!!\n\nvec3 loadFromSRGB(vec3 c)\n{\n    c = pow( c, 1. / vec3(0.4545) );\n    c /= max(1.0 - max(max(c.r, c.g), c.b), 1.e-6);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst int r = 16;\n\tfloat stddev = float(r) / 3.;\n\n\tvec3 bloom = vec3(.0);\n\tfloat w = 0.0;\n\n    vec2 offsetCoord = gl_FragCoord.xy + .5;\n    \n    ivec2 d = ivec2(1, -1); \n\tfor (int di = -1; di <= 4; ++di) {\n\t\tfor (int o = -r; o <= r; ++o) {\n\t\t\tvec2 of = vec2(o) / stddev;\n\t\t\tfloat weight = exp(-.5 * dot(of, of)); // 1.f / (2.f * 3.14f * stddev * stddev) * \n\t\t\tvec3 s = texture(iChannel0, (offsetCoord + vec2(o * d)) / iChannelResolution[0].xy).xyz;\n            s = loadFromSRGB(s);\n\t\t\tbloom += weight * max(vec3(.0), s - 8.);\n\t\t\tw += weight;\n\t\t}\n        d.y += 1;\n\t}\n\n    bloom /= w;\n    \n\tfragColor = texture(iChannel0, gl_FragCoord.xy / iChannelResolution[0].xy);\n    fragColor.xyz = loadFromSRGB( fragColor.xyz );\n    fragColor.xyz *= .2;\n\tfragColor.xyz += .01 * bloom;\n    \n    // tonemap, gamma\n    fragColor *= 1.0 / (max(max(fragColor.r, fragColor.g), fragColor.b) + 1.0);\n    fragColor.xyz = pow( fragColor.xyz, vec3(0.4545) );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Copyright (c) 2016, NVIDIA CORPORATION.  All rights reserved.\n// Created by Tobias Zirr (KIT, NVIDIA) and Anton Kaplanyan (NVIDIA)\n// Based on https://www.shadertoy.com/view/Xds3zN created by Inigo Quilez\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// For a less restrictive license, find the isolated shading code at:\n// http://alphanew.net/releases/glints/shading.txt\n\n// Example code for the paper \"Real-time Rendering of Procedural Multiscale Materials\",\n// Tobias Zirr (NVIDIA / KIT), Anton Kaplanyan (NVIDIA),\n// in ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games, February 2016.\n// More info on https://research.nvidia.com/publication/real-time-rendering-procedural-multiscale-materials\n\nfloat hash( float n ) { return fract(sin(mod(n, 3.14))*753.5453123); }\nvec2 hash2( float n ) { return vec2(hash(n), hash(1.1 + n)); }\n\n//----------------------------------------------------------------------\n\n// procedural distance fields; https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) {\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r ) {\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))-r+min(max(d.x,max(d.y,d.z)),0.0);\n}\nfloat sdCylinder( vec3 p, vec2 h ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat length2( vec2 p ) {\n  return sqrt( p.x*p.x + p.y*p.y );\n}\nfloat length8( vec2 p ) {\n  p = p*p; p = p*p; p = p*p;\n  return pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdTorus82( vec3 p, vec2 t ) {\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\n\nfloat opS( float d1, float d2 ) {\n    return max(-d2,d1);\n}\nvec2 opU( vec2 d1, vec2 d2 ) {\n  return (d1.x<d2.x) ? d1 : d2;\n}\n// polynomial smooth min (k = 0.1); https://iquilezles.org/articles/smin\nvec2 smin( vec2 a, vec2 b, float k ) {\n  float h = clamp( 0.5+0.5*(b.x-a.x)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - vec2(k*h*(1.0-h), 0.);\n}\n\n//----------------------------------------------------------------------\n\n// scene\nvec2 wheel( in vec3 pos ) {\n    vec2 res = vec2(sdTorus82( pos.yxz, vec2(0.65,0.15) ), 2.0);\n    res = opU( res, vec2( sdCylinder( pos.yxz, vec2(0.65,0.08) ), 3.0) );\n    return res;\n}\nvec2 fenders( vec2 res, in vec3 pos, float material ) {\n    res = smin( res, vec2(sdCylinder( pos.yxz, vec2(1.,1.65)), material), .4 );\n    res.x = opS( res.x, sdCylinder( pos.yxz, vec2(.9,1.9)) );\n    res.x = opS( res.x, sdBox( pos - vec3(0,-1.1,0), vec3(2.,1.,3.)) );\n    return res;\n}\nvec2 cabin( in vec3 pos, float material ) {\n    vec2 res = vec2(sdRoundBox(pos - vec3(0,1.5,0.1), vec3(.9,.1,2.4), .6), material);\n    res = smin( res, vec2(sdEllipsoid(pos - vec3(0,1.5,-3.), vec3(1.3, .7, .9)), material), 1. );\n    res = smin( res, vec2(sdEllipsoid(pos - vec3(0,1.6,3.3), vec3(1.2,.8,.5)), material), 1. );\n    res = smin( res, vec2(sdRoundBox(pos - vec3(0,2.,.3), vec3(.6,.3,1.), .6), material), .7 );\n    \n    res = fenders(res, pos - vec3(0,.9,-2.5), material);\n    res = fenders(res, pos - vec3(0,.9,2.5), material);\n    \n    res.x = opS( res.x, sdRoundBox(pos - vec3(0,2.6,.3), vec3(.6,.0,3.), .25) );\n    res.x = opS( res.x, sdRoundBox(pos - vec3(0,2.6,-.3), vec3(3.,.1,.4), .15) );\n    res.x = opS( res.x, sdRoundBox(pos - vec3(0,2.6,.8), vec3(3.,.1,.2), .15) );\n    res.x = opS( res.x, sdRoundBox(pos - vec3(0,2.,.3), vec3(.6,.3,1.), .5) );\n    \n    return res;\n}\nvec2 car( in vec3 pos, float material ) {\n    vec2 res = vec2(sdBox(pos - vec3(0,.8,0), vec3(1.3,.3,3)), 2);\n    res = opU(res, wheel(pos - vec3(1.5,.8,2.5)));\n    res = opU(res, wheel(pos - vec3(-1.5,.8,2.5)));\n    res = opU(res, wheel(pos - vec3(1.5,.8,-2.5)));\n    res = opU(res, wheel(pos - vec3(-1.5,.8,-2.5)));\n    \n    res = opU(cabin(pos, material), res);\n    return res;\n}\nvec2 map( in vec3 pos ) {\n    vec2 res = car(pos - vec3(0,0,0.0), 4.3);\n    res = opU(car(pos - vec3(9,0,5), 5.995), res);\n    return res;\n}\n// heightfield\nfloat mapLandscape(vec2 a) {\n    float h = 0.0;\n    h += pow(sin(2. + a.x / 37.) * sin(.5 + a.y / 31.), 2.);\n    h += .5 * pow(sin(a.x / 11.) * sin(a.y / 13.), 2.);\n    h += .2 * sin(1.1 + a.x / 3.1) * sin(.3 + a.y / 3.7);\n    h *= min(length(a) / 10., 5.);\n    h += .1 * sin(.9 + a.x / 1.7);\n    h += .1 * sin(.4 + a.y / 1.4);\n    h += .05 * sin(1.1 + a.y / .9);\n    h += 15. * (1. - cos(a.x / 51.));\n    return h;\n}\n\n//----------------------------------------------------------------------\n\n// raycasting\nvec2 castRayLandscape( in vec3 ro, in vec3 rd ) {\n    float delt = 0.1;\n    const float mint = 0.5;\n    const float maxt = 90.0;\n    float lh = 0.0;\n    float ly = 0.0;\n    float t = mint;\n    for( int i = 0; i < 200; ++i )\n    {\n        if (t < maxt);\n        else break;\n        \n        vec3  p = ro + rd*t;\n        float h = mapLandscape( p.xz );\n        if( p.y < h )\n        {\n            // interpolate the intersection distance\n            return vec2(t - delt + delt*(lh-ly)/(p.y-ly-h+lh), 1.99);\n        }\n        // allow the error to be proportinal to the distance\n        delt = max(0.1*t, delt);\n        lh = h;\n        ly = p.y;\n        \n        t += delt;\n    }\n    return vec2(maxt, -1.);\n}\nvec3 calcNormalLandscape( in vec3 pos ) {\n    vec3 eps = vec3( 0.01, 0.0, 0.0 );\n    vec3 a = eps.xyz;\n    a.y = mapLandscape(pos.xz + a.xz) - mapLandscape(pos.xz - a.xz);\n    a.xz *= 2.;\n    vec3 b = eps.zyx;\n    b.y = mapLandscape(pos.xz + b.xz) - mapLandscape(pos.xz - b.xz);\n    b.xz *= 2.;\n    return normalize( cross(b, a) );\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd ) {\n    float tmin = 1.0;\n    float tmax = 60.0;\n    \n    float precis = 0.01;\n    float t = tmin;\n    float m = -1.0;\n    vec2 res;\n    for( int i=0; i<32; i++ )\n    {\n      res = map( ro+rd*t );\n      if( res.x<precis || t>tmax ) break;\n        t += res.x;\n      m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0; // || res.x > 100.0 * precis \n    res = vec2(t, m);\n    \n    vec2 resLandscape = castRayLandscape(ro, rd);\n    if (resLandscape.y >= 0. && (m < 0. || resLandscape.x < t))\n     res = resLandscape;\n    \n    return res;\n}\nvec3 calcNormal( in vec3 pos ) {\n  vec3 eps = vec3( 0.01, 0.0, 0.0 );\n  vec3 nor = vec3(\n      map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n      map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n      map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax ) {\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.04, 1.0 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n//----------------------------------------------------------------------\n\n// math\nfloat compMax(vec2 v) { return max(v.x, v.y); }\nfloat maxNrm(vec2 v) { return compMax(abs(v)); }\nmat2 inverse2(mat2 m) {\n    return mat2(m[1][1], -m[0][1], -m[1][0], m[0][0]) / (m[0][0] * m[1][1] - m[0][1] * m[1][0]);\n}\n\nfloat erfinv(float x) {\n    float w, p;\n    w = -log((1.0-x)*(1.0+x));\n    if(w < 5.000000) {\n        w = w - 2.500000;\n        p = 2.81022636e-08;\n        p = 3.43273939e-07 + p*w;\n        p = -3.5233877e-06 + p*w;\n        p = -4.39150654e-06 + p*w;\n        p = 0.00021858087 + p*w;\n        p = -0.00125372503 + p*w;\n        p = -0.00417768164 + p*w;\n        p = 0.246640727 + p*w;\n        p = 1.50140941 + p*w;\n    }\n    else {\n        w = sqrt(w) - 3.000000;\n        p = -0.000200214257;\n        p = 0.000100950558 + p*w;\n        p = 0.00134934322 + p*w;\n        p = -0.00367342844 + p*w;\n        p = 0.00573950773 + p*w;\n        p = -0.0076224613 + p*w;\n        p = 0.00943887047 + p*w;\n        p = 1.00167406 + p*w;\n        p = 2.83297682 + p*w;\n    }\n    return p*x;\n}\n\n// ray differentials\nvoid calcDpDxy( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy, in float t, in vec3 nor, \n                out vec3 dpdx, out vec3 dpdy ) {\n    dpdx = 2.*t*(rdx*dot(rd,nor)/dot(rdx,nor) - rd) * sign(dot(rd, rdx));\n    dpdy = 2.*t*(rdy*dot(rd,nor)/dot(rdy,nor) - rd) * sign(dot(rd, rdy));\n}\n\n// some microfacet BSDF geometry factors\n// (divided by NoL * NoV b/c cancelled out w/ microfacet BSDF)\nfloat geometryFactor(float NoL, float NoV, vec2 roughness) {\n    float a2 = roughness.x * roughness.y;\n    NoL = abs(NoL);\n    NoV = abs(NoV);\n\n    float G_V = NoV + sqrt((NoV - NoV * a2) * NoV + a2);\n    float G_L = NoL + sqrt((NoL - NoL * a2) * NoL + a2);\n    return 1. / (G_V * G_L);\n}\n\n//----------------------------------------------------------------------\n\n// ugly inefficient WebGL implementation of simple bit shifts for\n// multilevel coherent grid indices. See comment in multilevelGridIdx.\nint multilevelGridIdx1(inout int idx) {\n    for (int i = 0; i < 32; ++i) {\n        if (idx / 2 == (idx + 1) / 2)\n          idx /= 2;\n        else\n            break;\n    }\n    return idx;\n}\nivec2 multilevelGridIdx(ivec2 idx) {\n//  return idx >> findLSB(idx); // findLSB not supported by Shadertoy WebGL version\n    return ivec2(multilevelGridIdx1(idx.x), multilevelGridIdx1(idx.y));\n}\n\n//----------------------------------------------------------------------\n\n// stable binomial 'random' numbers: interpolate between result for\n// two closest binomial distributions where log_{.9}(p_i) integers\nfloat binomial_interp(float u, float N, float p) {\n    if(p >= 1.)\n        return N;\n    else if(p <= 1e-10)\n        return 0.;\n\n    // convert to distribution on ints while retaining expected value\n    float cN = ceil(N);\n    int iN = int(cN);\n    p = p * (N / cN);\n    N = cN;\n\n    // round p to nearest powers of .9 (more stability)\n    float pQ = .9;\n    float pQef = log2(p) / log2(pQ);\n    float p2 = exp2(floor(pQef) * log2(pQ));\n    float p1 = p2 * pQ;\n    vec2 ps = vec2(p1, p2);\n\n    // compute the two corresponding binomials in parallel\n    vec2 pm = pow(1. - ps, vec2(N));\n    vec2 cp = pm;\n    vec2 r = vec2(N);\n\n    float i = 0.0;\n    // this should actually be < N, no dynamic loops in ShaderToy right now\n    for(int ii = 0; ii <= 17; ++ii)\n    {\n        if(u < cp.x)\n            r.x = min(i, r.x);\n        if(u < cp.y) {\n            r.y = i;\n            break;\n        }\n        // fast path\n        if(ii > 16)\n        {\n            float C = 1. / (1. - pow(p, N - i - 1.));\n            vec2 U = (u - cp) / (1. - cp);\n            vec2 A = (i + 1. + log2(1. - U / C) / log2(p));\n            r = min(A, r);\n            break;\n        }\n\n        i += 1.;\n        pm /= 1. - ps;\n        pm *= (N + 1. - i) / i;\n        pm *= ps;\n        cp += pm;\n    }\n\n    // interpolate between the two binomials according to log p (akin to mip interpolation)\n    return mix(r.y, r.x, fract(pQef));\n}\n// resort to gaussian distribution for larger N*p\nfloat approx_binomial(float u, float N, float p) {\n    if (p * N > 5.)\n    {\n        float e = N * p;\n        float v = N * p * max(1. - p, 0.0);\n        float std = sqrt(v);\n        float k = e + erfinv(mix(-.999999, .999999, u)) * std;\n        return min(max(k, 0.), N);\n    }\n    else\n        return binomial_interp(u, N, p);\n}\n\n//----------------------------------------------------------------------\n\nvec3 glints(vec2 texCO, vec2 duvdx, vec2 duvdy, mat3 ctf\n  , vec3 lig, vec3 nor, vec3 view\n  , vec2 roughness, vec2 microRoughness, float searchConeAngle, float variation, float dynamicRange, float density)\n{\n   vec3 col = vec3(0.);\n\n    // Compute pixel footprint in texture space, step size w.r.t. anisotropy of the footprint\n    mat2 uvToPx = inverse2(mat2(duvdx, duvdy));\n    vec2 uvPP = 1. / vec2(maxNrm(uvToPx[0]), maxNrm(uvToPx[1]));\n\n    // material\n    vec2 mesoRoughness = sqrt(max(roughness * roughness - microRoughness * microRoughness, vec2(1.e-12))); // optimizer fail, max 0 removed\n\n    // Anisotropic compression of the grid\n    vec2 texAnisotropy = vec2( min(mesoRoughness.x / mesoRoughness.y, 1.)\n                             , min(mesoRoughness.y / mesoRoughness.x, 1.) );\n\n    // Compute half vector (w.r.t. dir light)\n    vec3 hvW = normalize(lig + view);\n    vec3 hv = normalize(hvW * ctf);\n    vec2 h = hv.xy / hv.z;\n    vec2 h2 = 0.75 * hv.xy / (hv.z + 1.);\n    // Anisotropic compression of the slope-domain grid\n    h2 *= texAnisotropy;\n\n    // Compute the Gaussian probability of encountering a glint within a given finite cone\n    vec2 hppRScaled = h / roughness;\n    float pmf = (microRoughness.x * microRoughness.y) / (roughness.x * roughness.y)\n        * exp(-dot(hppRScaled, hppRScaled)); // planeplane h\n    pmf /= hv.z * hv.z * hv.z * hv.z; // projected h\n//  pmf /= dot(lig, nor) * dot(view, nor); // projected area, cancelled out by parts of G, ...\n    float pmfToBRDF = 1. / (3.14159 * microRoughness.x * microRoughness.y);\n    pmfToBRDF /= 4.; // solid angle o\n    pmfToBRDF *= geometryFactor(dot(lig, nor), dot(view, nor), roughness); // ... see \"geometryFactor\"\n    // phenomenological: larger cones flatten distribution\n    float searchAreaProj = searchConeAngle * searchConeAngle / (4. * dot(lig, hvW) * hv.z); // * PI\n    pmf = mix(pmf, 1., clamp(searchAreaProj, 0.0, 1.0)); // searchAreaProj / PI\n    pmf = min(pmf, 1.);\n    \n    // noise coordinate (decorrelate interleaved grid)\n    texCO += vec2(100.);\n    // apply anisotropy _after_ footprint estimation\n    texCO *= texAnisotropy;\n\n    // Compute AABB of pixel in texture space\n    vec2 uvAACB = max(abs(duvdx), abs(duvdy)) * texAnisotropy; // border center box\n    vec2 uvb = texCO - 0.5 * uvAACB;\n    vec2 uve = texCO + 0.5 * uvAACB;\n\n    vec2 uvLongAxis = uvAACB.x > uvAACB.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 uvShortAxis = 1.0 - uvLongAxis;\n\n    // Compute skew correction to snap axis-aligned line sampling back to longer anisotropic pixel axis in texture space\n    vec2 skewCorr2 = -(uvToPx * uvLongAxis) / (uvToPx * uvShortAxis);\n    float skewCorr = abs((uvToPx * uvShortAxis).x) > abs((uvToPx * uvShortAxis).y) ? skewCorr2.x : skewCorr2.y;\n    skewCorr *= dot(texAnisotropy, uvShortAxis) / dot(texAnisotropy, uvLongAxis);\n\n    float isoUVPP = dot(uvPP, uvShortAxis);\n    // limit anisotropy\n    isoUVPP = max(isoUVPP, dot(uvAACB, uvLongAxis) / 16.0);\n\n     // Two virtual grid mips: current and next\n    float fracMip = log2(isoUVPP);\n    float lowerMip = floor(fracMip);\n    float uvPerLowerC = exp2(lowerMip);\n\n    // Current mip level and cell size\n    float uvPC = uvPerLowerC;\n    float mip = lowerMip;\n\n    int iter = 0;\n    int iterThreshold = 60;\n\n    for (int i = 0; i < 2; ++i)\n    {\n        float mipWeight = 1.0 - abs(mip - fracMip);\n\n        vec2 uvbg = min(uvb + 0.5 * uvPC, texCO);\n        vec2 uveg = max(uve - 0.5 * uvPC, texCO);\n\n        // Snapped uvs of the cell centers\n        vec2 uvbi = floor(uvbg / uvPC);\n        vec2 uvbs = uvbi * uvPC;\n        vec2 uveo = uveg + uvPC - uvbs;\n\n        // Resulting compositing values for a current layer\n        float weight = 0.0;\n        vec3 reflection = vec3(0.0);\n\n        // March along the long axis\n        vec2 uvo = vec2(0.0), uv = uvbs, uvio = vec2(0.0), uvi = uvbi;\n        for (int iter1 = 0; iter1 < 18; ++iter1) // horrible WebGL-compatible static for loop\n        {\n            // for cond:\n            if (dot(uvo, uvLongAxis) < dot(uveo, uvLongAxis) && iter < iterThreshold);\n            else break;\n\n            // Snap samples to long anisotropic pixel axis\n            float uvShortCenter = dot(texCO, uvShortAxis) + skewCorr * dot(uv - texCO, uvLongAxis);\n\n            // Snapped uvs of the cell center\n            uvi += (floor(uvShortCenter / uvPC) - dot(uvi, uvShortAxis)) * uvShortAxis;\n            uv = uvi * uvPC;\n            float uvShortEnd = uvShortCenter + uvPC;\n\n            vec2 uvb2 = uvbg * uvLongAxis + uvShortCenter * uvShortAxis;\n            vec2 uve2 = uveg * uvLongAxis + uvShortCenter * uvShortAxis;\n\n            // March along the shorter axis\n            for (int iter2 = 0; iter2 < 4; ++iter2) // horrible WebGL-compatible static for loop\n            {\n                // for cond:\n                if (dot(uv, uvShortAxis) < uvShortEnd && iter < iterThreshold);\n                else break;\n\n                // Compute interleaved cell index\n                ivec2 cellIdx = ivec2(uvi + vec2(.5));\n                cellIdx = multilevelGridIdx(cellIdx);\n\n                // Randomize a glint based on a texture-space id of current grid cell\n                vec2 u2 = hash2(float( (cellIdx.x + 1549 * cellIdx.y) ));\n                // Compute index of the cone\n                vec2 hg = h2 / (microRoughness + searchConeAngle);\n                vec2 hs = floor(hg + u2) + u2 * 533.;    // discrete cone index in paraboloid hv grid\n                ivec2 coneIdx = ivec2(hs);\n\n                // Randomize glint sizes within this layer\n                float var_u = hash(float( (cellIdx.x + cellIdx.y * 763 + coneIdx.x + coneIdx.y * 577) ));\n                float mls = 1. + variation * erfinv(mix(-.999, .999, var_u));\n                if (mls <= 0.0) mls = fract(mls) / (1. - mls);\n                mls = max(mls, 1.e-12);\n\n                // Bilinear interpolation using coverage made by areas of two rects\n                vec2 mino = max(1.0 - max((uvb2 - uv) / uvPC, 0.0), 0.0);\n                vec2 maxo = max(1.0 - max((uv - uve2) / uvPC, 0.0), 0.0);\n                vec2 multo = mino * maxo;\n                float coverageWeight = multo.x * multo.y;\n\n                float cellArea = uvPC * uvPC;\n                // Expected number of glints \n                float eN = density * cellArea;\n                float sN = max(eN * mls, min(1.0, eN));\n                eN = eN * mls;\n\n                // Sample actually found number of glints\n                float u = hash(float(coneIdx.x + coneIdx.y * 697));\n                float lN = approx_binomial(u, sN, pmf);\n#if 0\n                // Colored glints\n                if (false) {\n                    vec3 glintColor = hue_colormap(fract(u + u2.y));\n                    glintColor = mix(vec3(1.0f), glintColor, 1. / sqrt(max(lN, 1.0)));\n                }\n#endif\n                // Ratio of glinting vs. expected number of microfacets\n                float ratio = lN / eN;\n                \n                // limit dynamic range (snow more or less unlimited)\n                ratio = min(ratio, dynamicRange * pmf);\n                \n                // convert to reflectance\n                ratio *= pmfToBRDF;\n#if 0\n                // Grid\n                reflection += vec3(u);\n                weight += coverageWeight;\n#else\n                // Accumulate results\n                reflection += coverageWeight * ratio;\n                weight += coverageWeight;\n#endif\n\n                // for incr:\n                uv += uvPC * uvShortAxis, uvi += uvShortAxis, ++iter;\n            }\n\n            // for incr:\n              uvo += uvPC * uvLongAxis, uv = uvbs + uvo\n            , uvio += uvLongAxis, uvi = uvbi + uvio;\n        }\n\n#ifdef DEBUG\n        // Normalization\n        if (weight < 1.e-15) {\n            col = vec3(0.0, 1.0, 1.0);\n            break;\n        }\n#endif\n\n        reflection = reflection / weight;\n\n        // Compositing of two layers\n        col += mipWeight * reflection;\n\n        // for incr:\n        uvPC *= 2., mip += 1.;\n    }\n\n    return col;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{\n    // sun and sky\n    vec3 lig = normalize( vec3(0.6, .9, 0.5) );\n    vec3 lightPower = vec3(9.);\n    vec3 sky = vec3(0.7, 0.9, 1.0) + 1. + rd.y*0.8;\n    vec3 col = sky * lightPower;\n    // ray cast\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n    float m = res.y;\n    // shade hit\n    if( m>-0.5 ) {\n        // hit information\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m < 2.) ? calcNormalLandscape(pos) : calcNormal( pos );\n        \n        mat3 texProjFrame = mat3( vec3(1,0,0), vec3(0,0,1), vec3(0,1,0) );\n        if (abs(nor.x) > abs(nor.y) && abs(nor.x) > abs(nor.z)) {\n            texProjFrame = mat3( vec3(0,0,1), vec3(0,1,0), vec3(1,0,0) );\n        }\n        else if (abs(nor.z) > abs(nor.x) && abs(nor.z) > abs(nor.y)) {\n            texProjFrame = mat3( vec3(1,0,0), vec3(0,1,0), vec3(0,0,1) );\n        }\n        \n        vec3 bitang = normalize(cross(nor, texProjFrame[0]));\n        vec3 tang = cross(bitang, nor);\n        mat3 ctf = mat3(tang, bitang, nor);\n        \n        // texturing\n        vec3 dposdx, dposdy;\n        calcDpDxy( ro, rd, rdx, rdy, t, nor, dposdx, dposdy );\n        // planar projections\n        float texScaling = 1.;\n        vec2 texCO = texScaling * (pos * texProjFrame).xy;\n        vec2 duvdx = texScaling * (dposdx * texProjFrame).xy\n           , duvdy = texScaling * (dposdy * texProjFrame).xy;\n        // computing these manually from ray differentials to handle edges in ray casting,\n        // can simply use standard derivatives in real-world per-object fragment shaders:\n//      duvdx = dFdx(texCO), duvdy = dFdy(texCO);\n        \n        // useful information\n        float occ = softshadow( pos, lig, 0.02, 25. );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = 1. - pow(1. - dif, 2.5);\n        float dfr = 1. - pow(1. - clamp( dot( nor, -rd ), 0.0, 1.0 ), 2.5);\n        dfr *= fre;\n        \n        // some default material        \n        col = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        col *= .4;\n        float specularity = fract(m);\n        \n        // configure multiscale material (snow parameters)\n        vec2 roughness = vec2(.6);\n        vec2 microRoughness = roughness * .024;\n        float searchConeAngle = .01;\n        float variation = 100.;\n        float dynamicRange = 50000.;\n        float density = 5.e8;\n    \n        // snow\n        if (floor(m) == 1.) {\n            col = mix(vec3(.1,.2,.5), vec3(.95,.8,.75), (1. - abs(rd.y)) * dif);\n        }\n        // wheels (not using multiscale, specularity = 0)\n        else if (floor(m) == 2.) {\n            col = vec3(0);\n        }\n        else if (floor(m) == 3.) {\n            col = vec3(0.7);\n        }\n        // car 1 (anisotropic)\n        else if (floor(m) == 4.) {\n            col = vec3(0.02, 0.2, 0.04);\n            col = mix(col, sky, .15 * pow(1. - dfr, 2.));\n            roughness = vec2(.05,.3);\n            density = 2.e7;\n            variation = 10.0;\n            microRoughness = roughness.xx;\n            specularity *= dfr; // layered material (translucency)\n            dynamicRange = 10.; // max 10x more microdetails than expected\n        }\n        // car 2 (isotropic)\n        else if (floor(m) == 5.) {\n            roughness = vec2(.07);\n            microRoughness = roughness * .5;\n            col = vec3(0.5, 0.025, 0.025);\n            col = mix(col, sky, .15 * pow(1. - dfr, 2.));\n            variation = .1;\n            density = 1.e6;\n            specularity *= dfr; // layered material (translucency)\n            dynamicRange = 5.; // max 5x more microdetails than expected\n        }\n        \n        // standard diffuse lighting\n        col *= lightPower * mix(.02, 1., occ * dif);\n        \n        // multiscale specular lighting\n        if (specularity > 0.0 && dif > 0.0 && dot(-rd, nor) > 0.0)\n\t\t\tcol += specularity * glints(texCO, duvdx, duvdy, ctf, lig, nor, -rd, roughness, microRoughness, searchConeAngle, variation, dynamicRange, density)\n\t\t\t\t* lightPower * mix(.05, 1., occ);\n    }\n\n  return col;\n}\n\n//----------------------------------------------------------------------\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n     \n    float time = 15.0 + iTime;\n\n    // camera\n//  time = 1505.0;\n    float ds = 1.5 + sin(time / 2.);\n    vec3 ro = vec3( -0.5+ds * 8.5*cos(0.1*time + 6.0*mo.x)\n                   , 10.0 - 9.5*mo.y\n                   , 0.5 + ds * 8.5*sin(0.1*time + 6.0*mo.x) );\n    ro.y /= 1. + .01 * dot(ro.xz, ro.xz);\n    ro.y += mapLandscape(ro.xz);\n    vec3 ta = vec3( -0.5, -0.4, 0.5 );\n  \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    vec2 rds = -sign(p + .001);\n    vec3 rdx = ca * rds.x * normalize( vec3(p.xy + rds.x * vec2(1./iResolution.y,0),2.0) );\n    vec3 rdy = ca * rds.y * normalize( vec3(p.xy + rds.y * vec2(0,1./iResolution.y),2.0) );\n\n    // render \n    vec3 col = render( ro, rd, rdx, rdy );\n    // tonemap, gamma\n    col *= 1.0 / (max(max(col.r, col.g), col.b) + 1.0);\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}","name":"Buf A","description":"","type":"buffer"}]}