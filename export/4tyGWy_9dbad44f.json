{"ver":"0.1","info":{"id":"4tyGWy","date":"1476369160","viewed":199,"name":"electoral map","username":"halcy","description":"dumb jokes taken seriously here","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["politics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.001\n#define STEP_MULTIPLIER 1.0\n#define NORMAL_OFFSET 0.001\n#define MAX_STEPS 128\n#define SHADOW_OFFSET 0.03\n#define SHADOW_HARDNESS 64.0\n\nvec3 hash33(vec3 p){ \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nvec4 distfunc(vec3 pos) {\n\tfloat dist = min(min(pos.y, -abs(pos.z) + 2.0), -abs(pos.x) + 2.0);\n    \n    pos.x = -pos.x;\n    pos.z = pos.z * 1.3;\n    vec4 col = texture(iChannel0, (pos.xz + vec2(1.0)) * 0.5);\n    dist = min(dist, pos.y + col.a * 1.9 - 0.6);\n    col.a = dist;\n    \n    return(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coords = (2.0 * fragCoord.xy  - iResolution.xy) / max(iResolution.x, iResolution.y);\n    vec3 lightpos = vec3(cos(iTime * 0.7), 1.0, sin(iTime * 0.7));\n    \n    float time = sin(iTime * 0.2) * 0.3;\n    \n    // Camera as eye + imaginary screen at a distance\n    vec3 eye = vec3(sin(time) * -1.75, 1.4, cos(time) * -1.75);\n    vec3 lookat = vec3(0.0, 0.5, 0.0);\n    vec3 lookdir = normalize(lookat - eye);\n    vec3 left = normalize(cross(lookdir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(left, lookdir));\n    vec3 lookcenter = eye + lookdir;\n\tvec3 pixelpos = lookcenter + coords.x * left + coords.y * up;\n    vec3 ray = normalize(pixelpos - eye);\n    ray += hash33(ray) * 0.001;\n    \n    // March\n    vec3 pos = eye;\n    float dist = 0.0;\n    float curdist = 1.0;\n    float iters = float(MAX_STEPS);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        curdist = distfunc(pos).a;\n        dist += curdist * STEP_MULTIPLIER;\n        pos = eye + ray * dist;\n        if(curdist < MIN_DIST) {\n        \titers = float(i);\n            break;\n        }\n    }\n    \n\t// Finite-difference normals\n   \tvec2 d = vec2(NORMAL_OFFSET, 0.0);\n    vec3 normal = normalize(vec3(\n        distfunc(pos + d.xyy).a - distfunc(pos - d.xyy).a,\n        distfunc(pos + d.yxy).a - distfunc(pos - d.yxy).a,\n        distfunc(pos + d.yyx).a - distfunc(pos - d.yyx).a\n    ));\n    \n    // Offset from surface\n    vec3 shadowstart = eye + ray * dist + normal * SHADOW_OFFSET;\n    vec3 shadowpos = shadowstart;\n    \n    // Shadow ray\n    vec3 shadowray = normalize(lightpos - pos);\n    float shadowdist = length(lightpos - pos);\n    float penumbra = 1.0;\n    dist = 0.0;\n    for(int i = 0; i < 32; i++) {\n        curdist = distfunc(shadowpos).a;\n\t\tdist += curdist * STEP_MULTIPLIER;        \n        shadowpos = shadowstart + shadowray * dist;\n        \n        if(curdist < MIN_DIST) {\n            penumbra = 0.0;\n            break;\n        }\n        \n        penumbra = min(penumbra, SHADOW_HARDNESS * curdist / dist);\n        if(dist >= shadowdist) {;\n        \tbreak;   \n        }\n        \n    }\n    \n    float light = max(0.0, dot(normal, shadowray)) * penumbra;\n    \n    vec3 itershade = vec3(iters / float(MAX_STEPS));\n    vec3 colorVal = light * distfunc(pos).rgb + itershade * 0.3;\n    fragColor = vec4(colorVal.xyz, 0.0);\n    fragColor = fragColor * clamp(mod(fragCoord.y, 2.0),  .7, 1.0) * (1.2 - pow(length(coords), 4.0));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 states[49];\n    states[0] = vec3(1.0, -0.464178614902, 0.249122408415); // CA\n    states[1] = vec3(0.0, 0.175033064852, 0.116492853628); // PA\n    states[2] = vec3(1.0, 0.0652487274358, 0.0330415300563); // MI\n    states[3] = vec3(2.0, 0.0323177897181, 0.261915007907); // TN\n    states[4] = vec3(0.0, -0.338411803738, 0.321309864686); // AZ\n    states[5] = vec3(1.0, 0.2616095624, 0.0833933942519); // RI\n    states[6] = vec3(2.0, -0.11892438042, 0.178671327093); // KS\n    states[7] = vec3(0.0, -0.011160798251, 0.00578014243089); // WI\n    states[8] = vec3(0.0, -0.424691883726, 0.181415822679); // NV\n    states[9] = vec3(2.0, -0.0448109623339, 0.399284234347); // LA\n    states[10] = vec3(0.0, 0.160863703594, 0.201033549352); // VA\n    states[11] = vec3(0.0, -0.0755766976676, -0.0386463798689); // MN\n    states[12] = vec3(2.0, -0.322438357937, -0.073921574233); // MT\n    states[13] = vec3(1.0, 0.178611140786, 0.167076435105); // DC\n    states[14] = vec3(0.0, -0.0649598331636, 0.0735408958431); // IA\n    states[15] = vec3(2.0, -0.0512373552331, 0.180139872977); // MO\n    states[16] = vec3(2.0, 0.119276470314, 0.179968342003); // WV\n    states[17] = vec3(1.0, 0.201352536778, 0.153432199373); // DE\n    states[18] = vec3(0.0, 0.108030658905, 0.5); // FL\n    states[19] = vec3(1.0, 0.0789651867355, 0.344920952809); // GA\n    states[20] = vec3(1.0, -0.00158666151071, 0.123745303587); // IL\n    states[21] = vec3(2.0, -0.141310677201, 0.0998934702371); // NE\n    states[22] = vec3(2.0, -0.15898890014, 0.00490744098356); // SD\n    states[23] = vec3(2.0, 0.0314390696401, 0.350566428379); // AL\n    states[24] = vec3(1.0, -0.5, -0.00357581894755); // OR\n    states[25] = vec3(2.0, -0.275529150485, 0.0511846922148); // WY\n    states[26] = vec3(2.0, 0.0638779843004, 0.204012771534); // KY\n    states[27] = vec3(1.0, 0.210025383575, 0.0691743792911); // NY\n    states[28] = vec3(1.0, 0.216487888258, 0.124416380907); // NJ\n    states[29] = vec3(1.0, 0.182162132882, 0.161780040114); // MD\n    states[30] = vec3(1.0, 0.0396680424253, 0.13793723471); // IN\n    states[31] = vec3(0.0, 0.260778991368, 0.0312239035936); // NH\n    states[32] = vec3(1.0, -0.491632598709, -0.0885739306022); // WA\n    states[33] = vec3(2.0, -0.120793165243, 0.268153318598); // OK\n    states[34] = vec3(2.0, -0.052424530133, 0.28579693441); // AR\n    states[35] = vec3(2.0, -0.131668830866, 0.401514137011); // TX\n    states[36] = vec3(1.0, 0.261289070317, 0.0665382190571); // MA\n    states[37] = vec3(0.0, 0.293393950975, -0.00478556371247); // ME\n    states[38] = vec3(2.0, -0.385396244074, 0.00628871672261); // ID\n    states[39] = vec3(1.0, 0.120224404645, 0.31986840264); // SC\n    states[40] = vec3(1.0, 0.243565707648, 0.0122682262945); // VT\n    states[41] = vec3(0.0, 0.0921038574909, 0.122622828967); // OH\n    states[42] = vec3(1.0, -0.2609129059, 0.289221535262); // NM\n    states[43] = vec3(2.0, -0.163951261129, -0.0929223912622); // ND\n    states[44] = vec3(2.0, -0.345420499155, 0.130450058155); // UT\n    states[45] = vec3(0.0, 0.136226438942, 0.265038677225); // NC\n    states[46] = vec3(2.0, -0.0118032870751, 0.35152038134); // MS\n    states[47] = vec3(1.0, 0.242769743742, 0.0862161320367); // CT\n    states[48] = vec3(1.0, -0.247222025781, 0.16201476671); // CO\n\n\n\tvec2 uvo = (fragCoord.xy - iResolution.xy / 2.0) / max(iResolution.x, iResolution.y);\n    vec2 uvx = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.xy;\n    vec2 uv = uvo;\n    uv += vec2(-0.05, -0.1);\n    uv = vec2(uv.x, -uv.y) * 1.2;\n    \n    float bestlen = 100000000000000.0;\n    float color = 0.0;\n    for(int i = 0; i < 49; i++) {\n        if(length(uv - states[i].yz) < bestlen) {\n            if(abs(length(uv - states[i].yz) - bestlen) < 0.005) {\n                color = 3.0;\n                bestlen = length(uv - states[i].yz);\n            }\n            else {\n                color = states[i].x;\n                bestlen = length(uv - states[i].yz);\n            }\n        }\n    }\n    \n    float pv = 3.0;\n    if(length(vec2(pow(uvx.x, pv), pow(uvx.y, pv))) + bestlen > 0.15) {\n    \tcolor = 3.0;   \n    }\n    \n    if(color == 0.0) {\n\t\tfragColor = vec4(240.0, 240.0, 240.0, 0.0) / 255.0;\n    }\n    if(color == 1.0) {\n\t\tfragColor = vec4(5.0, 113.0, 177.0, 0.0) / 255.0;\n    }\n    if(color == 2.0) {\n\t\tfragColor = vec4(204.0, 39.0, 37.0, 0.0) / 255.0;\n    }\n    if(color == 3.0) {\n\t\tfragColor = vec4(40.0, 40.0, 40.0, 0.0) / 255.0;\n    }\n    \n    fragColor.a = bestlen;\n}","name":"Buf A","description":"","type":"buffer"}]}