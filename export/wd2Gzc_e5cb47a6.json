{"ver":"0.1","info":{"id":"wd2Gzc","date":"1549597316","viewed":99,"name":"What The Heck","username":"cbrpnk","description":"Everyday.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, float r)\n{\n    p = abs(p);\n    float d = max(0., p.x-r);\n    d = max(d, p.y-r);\n    d = max(d, p.z-r);\n    return d;\n}\n\nfloat map(vec3 p)\n{\n    \n    float s = sphere(p, 2.);\n    float s2 = sphere(p-vec3(1.3), 1.);\n    vec3 rp = p-vec3(.5);\n    rp = mod(rp+vec3(.5), 1.)-vec3(.5);\n    vec3 id = floor(p);\n    \n    rp.xz = rotate(rp.xz, iTime+id.x);\n    rp.yz = rotate(rp.yz, iTime+id.z);\n\tfloat d = min(1000., box(rp, .125*sin(iTime-p.z)));\n    d = min(d, max(s, -s2));\n    d = min(d, p.y);\n    d = min(d, p.x);\n    d = min(d, p.z);\n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<128; ++i) {\n        float d = map(ro+rd*t);\n        if(d < .001) break;\n        if(t > 50.) break;\n        t += d*.6;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p+vec3(0.001, 0., 0.)) - map(p-vec3(0.001, 0., 0.)),\n        map(p+vec3(0., 0.001, 0.)) - map(p-vec3(0., 0.001, 0.)),\n        map(p+vec3(0., 0., 0.001)) - map(p-vec3(0., 0., 0.001))\n    ));\n}\n\nfloat lightRay(vec3 p, vec3 normal, vec3 lightPos)\n{\n    vec3 lightDir = normalize(lightPos - p);\n    float lightDst = length(lightPos - p);\n    float d = march(p+normal*.02, lightDir);\n    if(d >= lightDst) return 1.;\n    return 0.;\n}\n\nfloat getAo(vec3 p, vec3 normal)\n{\n    float d = march(p+normal*.02, normal);\n    return pow(d, .2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 eye = vec3(1., 1., 6.);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1.+smoothstep(.2, .4, cos(iTime)*.1)));\n    eye.xz = rotate(eye.xz, -.3+sin(iTime)*.1);\n    eye.y += cos(iTime*2.)*.1;\n    eye.z += sin(iTime*2.)*.1;\n    lookat.xz = rotate(lookat.xz, -.4+sin(iTime)*.1);\n    \n    float d = march(eye, lookat);\n    vec3 p = eye + lookat*d;\n    \n    vec3 normal = getNormal(eye+lookat*d);\n    float ao = getAo(p, normal);\n    vec3 light = vec3(1., 1., 5.);\n    vec3 light2 = vec3(15., 5.5, 3.);\n    \n  \t\n    vec3 col = .05+.5*vec3(mod(floor(p.x)+floor(p.y)+floor(p.z), 2.));\n    col *= .5+.01*ao;\n    col += .05 * vec3(.5, .5, .6) * max(0., dot(normal, light));\n    col += .03 * vec3(.6, 1., 1.) * max(0., dot(normal, light2));\n    col += .07*lightRay(p, normal, light);\n    col += .07*lightRay(p, normal, light2);\n    col *= .1;\n    col *= 1.-d*.1;\n\n    // Output to screen\n    col *= 1.-length(uv)*.5;\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}