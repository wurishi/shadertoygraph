{"ver":"0.1","info":{"id":"DsS3WD","date":"1667592073","viewed":52,"name":"f(x)=(x*x - 1) parametrizations","username":"Envy24","description":"Red - f(x)\nGreen - d(x, y)\nBlue - P(t) (first method)\nGrey - P(t) (second method)\nOrange - quadratic interplation.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["graph","compare","parametrization"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n    Comparing different parametrizations of f(x)= x*x - 1.\n        Red - f(x)\n        Green - d(x, y)\n        Blue - P(t) (first method)\n        Grey - P(t) (second method)\n        Orange - quadratic interplation.\n    \n    f(x)    = x^2 - 1 = y\n    d(x, y) = x^2 - 1 - y\n    p0(t):  \n            c = cos(t), s = sin(t), c^2 + s^2 = 1\n            \n            x*x - y = 1\n            x*x - y = c*c + s*s\n            x*x - c*c = y + s*s\n            eq 0:\n               x*x - c*c = 0\n               x*x = c*c\n               sqrt(x*x) = sqrt(c*c)\n               x = c = cos(t)\n            eq 1:\n               y + s*s = 0\n               y = -s*s = -sin(t)*sin(t)\n               \n    thus: p0(t) = vec2(cos(t), -sin(t)*sin(t)) // t = [0; PI]\n    Or p1(t):\n           x*x-1-y = 0            t*t - t*t = 0, or t^6 - t^6 = 0, of t^10 - t^10 = 0 ...\n           x*x-1-y = t*t - t*t                   or t-t = 0, t^3-t^3=0 ... (piecewise cases)\n           x*x-y = t*t - t*t + 1\n           x*x - t*t = 1 - t*t + y\n           eq 0:\n               x*x - t*t = 0\n               x = t // same as in prev parametrization\n           eq 1:\n               1 - t*t + y = 0\n               y = t*t - 1\n        \n    thus: p1(t) = vec2(t, t*t - 1)   // t = [-1; 1]\n        \n    p2(t) = quadratic_interpolation(vec2(-1, f(-1)), vec2(0, f(0)), vec2(1, f(1)), t) // t = [0; 1]\n*/\n#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )                      // Aspect ratio.\n#define UNIT                      ( 6.0 / R.y )                      // Affects AA and thickness\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define SCENE_SCALE               ( 1.2 )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\nfloat draw_implicit_func(vec2 NDC, float fxy, vec2 grad) { return SMAA(abs(fxy) / sqrt(1.0 + grad.x*grad.x + grad.y*grad.y)); }\n// e.t.c.\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - R.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin)\n{\n    return ((2. * (SC - MOUSE_OFFSET) - R.xy) / R.y) * scale - origin;\n}\n\nvec2 parametric0(float theta) // p0(t)\n{\n    return vec2(cos(theta), -sin(theta)*sin(theta));\n}\n\nvec2 parametric1(float t) // p1(t)\n{\n    /**\n    return // for t-t = 0 case\n        t >= 0. ? \n            vec2(sqrt(t), t-1.) :\n            vec2(-sqrt(-t), -t-1.);\n    /**/\n    return // for ttt-ttt = 0 case\n        t >= 0. ? \n            vec2(sqrt(t*t*t), t*t*t-1.) :\n            vec2(-sqrt(-(t*t*t)), -(t*t*t)-1.);\n    /**/\n    //return vec2(t, t*t-1.);\n    //return vec2(t*t*t, t*t*t*t*t*t-1.);\n}\n\n// https://www.shadertoy.com/view/NtVfWG\nfloat parametric_sdf0(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = parametric0(linear_remap(from.x, from.x, from.y, to.x, to.y));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from.x, from.y, to.x, to.y);\n    \n        vec2 E = parametric0(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance;\n}\n\nfloat parametric_sdf1(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = parametric1(linear_remap(from.x, from.x, from.y, to.x, to.y));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from.x, from.y, to.x, to.y);\n    \n        vec2 E = parametric1(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance;\n}\n\nvec2 quadratic(in vec2 P0, in vec2 P1, in vec2 P2, float t)\n{\n    float tt = t * t;\n    float w0 = 2.0 * tt - 3.0 * t + 1.0;\n    float w1 = -4.0 * tt + 4.0 * t;\n    float w2 = 2.0 * tt - t;\n\n    return w0 * P0 + w1 * P1 + w2 * P2;\n}\nfloat parametric_sdf2(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = quadratic(vec2(-1,0), vec2(0,-1), vec2(1,0), linear_remap(from.x, from.x, from.y, to.x, to.y));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from.x, from.y, to.x, to.y);\n    \n        vec2 E = quadratic(vec2(-1,0), vec2(0,-1), vec2(1,0), t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF_L2(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    return minimal_distance;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0));\n    vec2 ndc;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); //color -= y_axis(NDC);\n         \n    /* Explicit function y=f(x) */\n#define func(x) ( (x)*(x)-1. )\n#define dfdx(x) ( 2.*(x) )\n#define T       ( iTime*0.2 )\n#define T0      ( -1. + fract(T) * 2. )        // f(x), p1(t)\n#define T1      ( (1. - fract(T)) * 3.141592 ) // p0(t)\n#define T2      ( fract(iTime*0.2) )                   // q(P0, P1, P2, t)\n         color = mix(color, vec3(1,0,0), draw_explicit_func(NDC, func(NDC.x), dfdx(NDC.x)));\n         color = mix(color, vec3(0.5,0,1), SMAA(diskSDF_L2(NDC, vec2(T0, func(T0)), UNIT)) );\n\n    /* Implicit function d=f(x,y) */\n#define FUNC(x, y) ( (x)*(x)-1.-(y) )\n#define GRAD(x, y) ( vec2(2.*(x), -1.) )\n         ndc = vec2(NDC.x+0.1, NDC.y);\n         color = mix(color, vec3(0,1,0), draw_implicit_func(NDC, FUNC(ndc.x, ndc.y), GRAD(ndc.x, ndc.y)));\n\n    /* Parametric function (x,y)=f(t)=p0(t) */\n         ndc = vec2(NDC.x-0.1, NDC.y);\n         vec2 from0 = vec2(-AR*SCENE_SCALE, AR*SCENE_SCALE), to0 = vec2(0., 6.28/2.);\n         color = mix(color, vec3(0,0,1), SMAA(parametric_sdf0(ndc, from0, to0, 50.)) );\n         color = mix(color, vec3(1,0,1), SMAA(diskSDF_L2(ndc, parametric0(T1), UNIT)) );\n          \n    /* Parametric function (x,y)=f(t)=p1(t) */\n         ndc = vec2(NDC.x-0.2, NDC.y);\n         vec2 from1 = vec2(-AR*SCENE_SCALE, AR*SCENE_SCALE), to1 = vec2(-2.5, 2.5);\n         color = mix(color, vec3(0.5), SMAA(parametric_sdf1(ndc, from1, to1, 100.)) );\n         color = mix(color, vec3(0,0,0), SMAA(diskSDF_L2(ndc, parametric1(T0), UNIT)) );\n           \n    /* Parametric function (x,y)=f(t)=quadratic_interp(P0, P1, P2, t) */\n         ndc = vec2(NDC.x-0.3, NDC.y);\n         vec2 from2 = vec2(-AR*SCENE_SCALE, AR*SCENE_SCALE), to2 = vec2(-0.3, 1.3);\n         color = mix(color, vec3(1,0.5,0), SMAA(parametric_sdf2(ndc, from2, to2, 75.)) );\n         color = mix(color, vec3(0,0.5,1), SMAA(diskSDF_L2(ndc, quadratic(vec2(-1,0), vec2(0,-1), vec2(1,0), T2), UNIT)) );\n         \n    /* Cells *\n#define CELL_SIZE 1\n         NDC = mod(NDC, vec2(CELL_SIZE)); \n         color -= vertical_line(NDC, 0.)*.2;  color -= horizontal_line(NDC, 0.)*.2; // comment this line if you not use mod\n         color -= vertical_line(NDC, -1.)*.2; color -= horizontal_line(NDC, -1.)*.2;         \n         color -= vertical_line(NDC, 1.)*.2;  color -= horizontal_line(NDC, 1.)*.2; \n    /* */ \n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float linear_remap(\n    float val,\n    float fl,\n    float fr,\n    float tl,\n    float tr)\n{\n    val = (val - fl) / (fr - fl); // inverse linear map from [fl; fr] to [0; 1].\n    return val * (tr - tl) + tl;  // linear map from [0; 1] to [tl; tr].\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}","name":"Common","description":"","type":"common"}]}