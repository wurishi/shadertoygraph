{"ver":"0.1","info":{"id":"4lsczl","date":"1506017405","viewed":1267,"name":"Flow Noise 2d","username":"TinyTexel","description":"Flow noise as described in Texturing and Modeling A Procedural Approach (no pseudoadvection for now).\nBasic ideas:\n- domain distorted fbm ( https://iquilezles.org/articles/warp/warp.htm )\n- rotate gradient kernels to animate noise","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Flow Noise 2d\n// by TinyTexel\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n\n/*\nFlow noise as described in \"Texturing and Modeling A Procedural Approach\" (no pseudoadvection for now).\nBasic ideas:\n- domain distorted fbm ( https://iquilezles.org/articles/warp )\n- rotate gradient kernels to animate noise (faster rotation for higher octaves)\n\n[Perlin, K., and F. Neyret. 2001. Flow noise. SIGGRAPH Technical Sketches and Applications]\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define OUT\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat Pow(float x, float e) {return pow(x, e);}\nvec2 Pow(vec2 x, float e) {return pow(x, vec2(e));}\nvec3 Pow(vec3 x, float e) {return pow(x, vec3(e));}\nvec4 Pow(vec4 x, float e) {return pow(x, vec4(e));}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n#define FUNC4_UINT(f)\t\t\t\t\t\t\t\t\\\nuvec2 f(uvec2 v) {return uvec2(f(v.x ), f(v.y ));}\t\\\nuvec3 f(uvec3 v) {return uvec3(f(v.xy), f(v.z ));}\t\\\nuvec4 f(uvec4 v) {return uvec4(f(v.xy), f(v.zw));}\t\\\n    \n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\nFUNC4_UINT(BJXorShift)    \n    \n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\nFUNC4_UINT(GMXorShift) \n    \n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\nFUNC4_UINT(WangHash) \n    \n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nfloat Root4(float x)\n{\n    return rsqrt(rsqrt(x));\n}\n\nfloat SCurveCos(float x)\n{\n    return cos(x * Pi)*-.5+.5;\n}\n\nfloat SCurveC1(float x)\n{\n    return (x * -2.0 + 3.0) * x*x;\n}\n\nfloat SCurveC2(float x)\n{\n    return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;\n}\n\nfloat Sign(float x) {return x < 0.0 ? -1.0 : 1.0;}\n\n\n#define LOOP(head0, head1, head2, body) {head0 body} {head1 body} {head2 body}\n\n// https://en.wikipedia.org/wiki/Simplex_noise\nfloat SmplxGNoise(vec2 uv, float rotS, uint seed)\n{\n    // const float n = 2.0;\n    const float F = 0.36602540378443860;// (sqrt(n + 1.0) - 1.0) / n;\n    const float G = 0.21132486540518708;// (1.0 - rsqrt(n + 1.0)) / n;\n    \n    vec2 uv2 = uv + (uv.x + uv.y) * F;\n    \n    vec2 iuv = floor(uv2);\n    vec2 fuv = uv2 - iuv;\n    \n    uvec2 vSeed = uvec2(0x0D66487Cu, 0x9A19276Bu) ^ uvec2(seed);\n\n    float res = 0.0;\n\n    LOOP(vec2 vert = vec2(0.0, 0.0);, \n         vec2 vert = (fuv.x > fuv.y ? vec2(1.0, 0.0) : vec2(0.0, 1.0));, \n         vec2 vert = vec2(1.0, 1.0);,\n        \n        uint vHash = HashUInt(vert + iuv, vSeed);\n         \n        float h0 = HashFlt(vHash, 0x7483EC45u);\n        float h1 = HashFlt(vHash, 0xE42B9889u);\n         \n        float ang = h0;\n        ang += Time * rotS * (1.0 + 0.309 * h1);\n        \n        vec2 g = AngToVec(ang * Pi);\n\n        vec2 vec  = fuv - vert;\n             vec -= (vec.x + vec.y) * G;\n        \n        float w = Pow3(clamp01(1.0 - 2.0 * SqrLen(vec)));\n             // w = SCurveC2(clamp01(1.0 - sqrt(2.0)*length(vec)));        \n        \n        float v = dot(vec, g);\n        \n        res += w * v;\n\t)\n\n   \n    //res *= 3.36;//SCurveC2\n    res *= 4.123;//Pow3\n    //res *= 6.2;//Pow4\n    \n    //res = abs(res*res)*2.0-1.0;\n    return res;\n}\n\n#undef LOOP\n\n\nfloat Fbm(vec2 uv, uint seed)\n{\n    const float count = 8.0;\n    \n    float res = 0.0;\n    float accu_w = 0.0;\n    float w = 1.0;\n    float rs = 0.2;\n    \n    for(float i = 0.0; i < count; ++i)\n    {\n        float v = SmplxGNoise(uv, rs, seed);\n        \n        res += v * w;\n        \n        accu_w += w;\n        \n        rs *= -1.7;        \n        w *= 0.51;\n        uv *= 2.2;\n        \n        seed = GMXorShift(seed);\n    }\n    \n    res /= accu_w;\n    \n    return res;\n}\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n\tvec2 tex = uv0.xy / PixelCount.xx;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    uint seed0 = 0x17E66082u;\n    uint seed1 = 0x0C1BEFEFu;\n    uint seed2 = 0xAF6DCAB3u;\n\n    \n    tex *= 2.0;\n    \n    vec2 o;\n    o.x = Fbm(tex + vec2(0.45, 0.13) , seed0)*1.;\n    o.y = Fbm(tex + vec2(0.32, 0.87) , seed1)*1.;    \n    \n    o = (abs(o)*2.0-1.0) * 0.5;\n    //o = (abs(abs(o)*2.0-1.0)*2.0-1.0) * 0.3;\n\n    float v = Fbm(tex + o * 0.1, seed2);\n    \n    v = v*.5+.5;\n    //v = o.y*0.5+0.5;\n    //v = (v*2.0-1.0)*128.0*0.5+0.5;\n    //v = pow(clamp(v, 0.0, 1.0), 1.0 / 2.2);\n    outCol = vec4(vec3(v), 1.0);   \n}\n\n","name":"Image","description":"","type":"image"}]}