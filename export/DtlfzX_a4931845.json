{"ver":"0.1","info":{"id":"DtlfzX","date":"1693275135","viewed":57,"name":"Conformal Maps","username":"halirutan","description":"See comments","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["transformation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * The idea is to use trig functions to create kind of a brightness checker-board pattern.\n * By introducing a dynamic phase shift, the pattern starts to move.\n * Now, a nonlinear space transformation is used to map the normal x-y space into something\n * more interesting. After that, a color gradient is applied.\n */\n\n\nconst float Pi = 3.1415926535897932385;\n\n/*\n * Two moving circular waves. In normal space, this just gives the usual\n * interference patters. In non-linearly transformed space, however, it\n * looks kind of nice.\n */\nfloat func(in vec2 pos, float t) {\n    float d1 = length(pos + vec2(1.0, 0));\n    float d2 = length(pos - vec2(1.0, 0));\n    return (0.5*cos(d1*d1 + t)+0.5)*(0.5*cos(d2*d2 + t)+0.5);\n}\n\n/*\n * Transformation of the complex plane. Value t should be in [0, 1] and decides which\n * transformation is used. For t=0 a exponential transformation z -> exp(z) of the complex plane is\n * used. For t=1, the inverse mapping z -> 1/z is applied. We use the parameter t to switch from\n * one mapping to the other over time.\n */\nvoid transform(in vec2 z, out vec2 z2, float t) {\n    float sqdist = (z.y*z.y + z.x*z.x);\n    vec2 z_exp = vec2(exp(z.x)*cos(z.y), exp(z.x)*sin(z.y));\n    z2 = (1.0-t)*z_exp + t*vec2(z.x/sqdist, -z.y/sqdist);\n}\n\n\n/*\n * A color gradient use for astronomical images. Please read https://arxiv.org/abs/1108.5083\n * for details.\n */\nvoid astroColor(float t, in vec4 params, out vec3 color) {\n    float s = params.x;\n    float r = params.y;\n    float h = params.z;\n    float g = params.w;\n    \n    float ptg = pow(t,g);\n    \n    color = vec3(\n        ptg+(h*pow(t,g)*(1.0-ptg)*(-0.14861*cos(2.0*Pi*(s/3.0+r*t))+ 1.78277*\n            sin(2.0*Pi*(s/3.0+r*t))))/2.0,\n        ptg+(h*ptg*(1.0-ptg)*(-0.29227*cos(2.0*Pi*(s/3.0+r*t))-0.90649*\n            sin(2.0*Pi*(s/3.0+r*t))))/2.0,    \n        ptg+(h*ptg*(1.0-ptg)*(1.97294*cos(2.0*Pi*(s/3.0+r*t))))/2.0\n    );\n\n}\n\n/*\n * A helper function that maps continuous time into the range [0, 1] basically always\n * going back and forth between 0 and 1 at speed \"speed\".\n */\nfloat backAndForth(float t, float speed) {\n    return 0.5*sin(speed*t)+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // User settings\n    float transform_time = backAndForth(iTime, 0.5);\n    float color_speed = 1.5;\n    float cx = 0.;\n    float cy = 0.;\n    float zoom = (1.0-transform_time)*0.5 + transform_time*1.5;\n    \n    float w = iResolution.x;\n    float h = iResolution.y;\n    zoom = 1.0/zoom;\n    \n    // Homogeneous coordinate transform to map the viewport into a rectangle\n    // with center at (cx, cy) and a specific zoom level.\n    mat3 transformation = mat3(\n      2.0*zoom/w,    0.0,             0.0,\n      0.0,           2.0*zoom/w,      0.0,\n      cx - zoom,     cy - (zoom*h)/w, 1.0\n    );\n    vec2 uv = (transformation * vec3(fragCoord.xy, 1.0)).xy;\n    vec2 t_uv; // uv transformed into a different space\n    transform(uv, t_uv, transform_time);\n    float j = func(t_uv, 5.0*iTime);\n    \n    \n    float t_color = color_speed * iTime;\n    vec3 astro;\n    astroColor(1.0-j, vec4(2.7, 0.96, 1.0, 0.8), astro);\n    \n    // A 3d rotation matrix to make the colors blend dynamically\n    mat3 rot = mat3(\n       0.333333*(1.0+2.0*cos(t_color)),\n       0.333333*(1.0-cos(t_color)+1.73205*sin(t_color)),\n       0.333333*(1.0-cos(t_color)-1.73205*sin(t_color)),\n       0.333333*(1.-1.*cos(t_color)-1.73205*sin(t_color)),\n       0.333333*(1.+2.*cos(t_color)),\n       0.333333*(1.-1.*cos(t_color)+1.73205*sin(t_color)),\n       0.333333*(1.-1.*cos(t_color)+1.73205*sin(t_color)),\n       0.333333*(1.-1.*cos(t_color)-1.73205*sin(t_color)),\n       0.333333*(1.+2.*cos(t_color))    \n    );\n  \n    // Use rotation matrix to make color change more dynamically\n    fragColor = vec4(rot*astro, 1.0);\n}","name":"Image","description":"","type":"image"}]}