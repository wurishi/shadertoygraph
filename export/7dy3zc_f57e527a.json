{"ver":"0.1","info":{"id":"7dy3zc","date":"1631868808","viewed":103,"name":"SinLines","username":"sephirot47","description":"Sin lines","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// X-related\n#define X_FREQ 20.0\n#define X_FREQ_VARIABILITY 10.0\n#define X_SPEED 7.0\n\n// Y-related\n#define Y_FREQ 10.0\n#define Y_AMPL 0.1\n#define Y_SPEED 0.1\n#define Y_SPEED_VARIABILITY 0.5\n\n// Line properties and number of lines and curves per line\n#define LINE_FADE_STRENGTH 0.4\n#define LINE_THICKNESS 0.005\n#define LINE_THICKNESS_VARIABILITY (LINE_THICKNESS * 0.3)\n#define NUM_LINES 10\n#define NUM_CURVES_PER_LINE 4\n\nfloat rand(float x){return fract(sin(x) * 43758.5453123);}\nfloat randCeil(float x) { return ceil(rand(x) * 100000.0) / 100000.0; }\n\nfloat GenCurve(float x, float RandSeed)\n{\n    // Generate needed randoms\n    float Rand0 = rand(RandSeed);\n    float Rand1 = rand(Rand0);\n    float Rand2 = rand(Rand1);\n    \n    // Generate X Offset, X Speed, and X Freq\n    float CurvePositionOffsetX = Rand0 * 3.141592;\n    float XSpeed = X_SPEED * (Rand1 * 2.0 - 1.0);\n    float CurveSpeedOffsetX = XSpeed * iTime;\n    float XFreq = X_FREQ + X_FREQ_VARIABILITY * (Rand2 * 2.0 - 1.0);\n    \n    // Compute sin curve\n    float CurveY = sin(x * XFreq + CurvePositionOffsetX + CurveSpeedOffsetX);\n    return CurveY;\n}\n\nfloat GetCurveValue(vec2 InUv, float RandSeed)\n{\n    float Rand0 = rand(RandSeed);\n    float Rand1 = rand(RandSeed);\n    float Rand2 = rand(RandSeed);\n    \n    // Rotate uv\n    float RandAngle = (Rand0 * 2.0 - 1.0) * 0.1;\n    vec2 uv = InUv + vec2(0.0, InUv.x * RandAngle);\n    \n    // Compute curve y\n    float CurveY = 0.0;\n    for (int i = 0; i < NUM_CURVES_PER_LINE; ++i)\n    {\n        CurveY += GenCurve(uv.x, Rand1 * float(i));\n    }\n    CurveY *= Y_AMPL;\n    CurveY /= float(NUM_CURVES_PER_LINE);\n    \n    // Get FinalY\n    float YSpeed = (Y_SPEED + Y_SPEED_VARIABILITY * rand(RandSeed));\n    float CurveSpeedOffsetY = (YSpeed * iTime);\n    // float uvyf = (uv.y * Y_FREQ) + CurveSpeedOffsetY;\n    float FinalY = mod(uv.y + CurveSpeedOffsetY, 1.0) * 2.0 - 1.0;\n    \n    // Compute Line Value \n    float LineThickness = (LINE_THICKNESS + LINE_THICKNESS_VARIABILITY * (Rand2 * 2.0 - 1.0));\n    float SignedDistanceToCurve01 = (FinalY - CurveY) / (LineThickness * Y_FREQ);\n    if (SignedDistanceToCurve01 < 0.0)\n        return 0.0;\n        \n    float Value = 1.0 - pow((SignedDistanceToCurve01 + 10.0) * 0.05, LINE_FADE_STRENGTH);\n    Value = max(Value, 0.0);\n    \n    return Value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Compute and combine the value of each line\n    float Value = 0.0;\n    for (int i = 0; i < NUM_LINES; ++i)\n    {\n        float fi = float(i);\n        Value += GetCurveValue(uv + vec2(0.0, 1.0 * fi), fi);\n    }\n    // Value /= float(NUM_LINES);\n    \n    fragColor = vec4(vec3(Value), 1);\n}","name":"Image","description":"","type":"image"}]}