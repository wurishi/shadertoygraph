{"ver":"0.1","info":{"id":"43XBRr","date":"1727910047","viewed":38,"name":"Logistic Fireworks","username":"thedarkbunny","description":"Wanted to try to make the logistic map bifurcation diagram as an iterative function.  Then I got artsy with it.","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["diffusion","practice","logisticmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Output to screen\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define DROP 0.97\n//#define DIFF_RATE 0.9\n#define DROP vec4(0.97,0.98,0.99,1.)\n#define DIFF_RATE vec4(0.3,0.6,0.9,1.)\n\n\n\nvec4 laplacian(in sampler2D buf, in vec2 target, in vec2 shift){\n    vec2 xr = shift*vec2(1.,0.);\n    vec2 yr = shift*vec2(0.,1.);\n    \n    vec4 lap = -texture(buf,target);\n    lap += (\n                    texture(buf,target+xr) +\n                    texture(buf,target-xr) +\n                    texture(buf,target+yr) +\n                    texture(buf,target-yr)\n                )*.2;\n    lap += (\n                    texture(buf,target+xr+yr) +\n                    texture(buf,target+xr-yr) +\n                    texture(buf,target-xr+yr) +\n                    texture(buf,target-xr-yr)\n                )*.05;\n    return lap;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uva = (fragCoord - iResolution.xy*0.5)/min(iResolution.x,iResolution.y);\n    vec2 uvb = fragCoord/iResolution.xy;\n    \n    \n    \n    \n    vec4 old_px = texture(iChannel0,uvb);\n    vec4 diffuse_px = laplacian(iChannel0,uvb,1./iResolution.xy);\n    \n    float r = uvb.x*4.;\n    vec3 p = vec3(uvb.y);\n    \n    \n    \n    for(int i=0;i<100;i+=1){\n        p = p * r * (1.-p);\n    }\n    for(int i=0;i<100;i+=1){\n        p.gb = p.gb * r * (1.-p.gb);\n    }\n    \n    for(int i=0;i<100;i+=1){\n        p.b = p.b * r * (1.-p.b);\n    }\n    \n    vec4 new_px = vec4(pow(1.-abs(p-uvb.y),vec3(1000.)),0.);\n    if(abs(fract(iTime/4.-uvb.x*8.)) > 0.1){\n        new_px = vec4(0.);\n    }\n    \n    \n    \n    //vec4 new_px = old_px * r * (1.-old_px);\n    \n    //fragColor = mix(min(max(new_px+old_px*DROP+diffuse_px*DIFF_RATE,0.),1.),vec4(uvb.y),0.01);\n    fragColor = max(new_px+old_px*DROP+diffuse_px*DIFF_RATE,0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}