{"ver":"0.1","info":{"id":"4dGcWh","date":"1521693810","viewed":810,"name":"Broken Picture","username":"FishMan","description":"simulate the glass broken effect","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["gapcrackglassbrokenexplode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Broken picture - by JiepengTan - 2018\n// jiepengtan@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//you can modify the \"MoveOffset\" function to get better explode effect\n\n#define NUM 30\t// chip center point num\n#define DRAW_POINTS 0 // draw the center points\n#define DRAW_GAP_LINE 1 // draw the gap line\n// xy  is center point's coord\n// zw  is chip 's move offset\nvec4 chipInfo[NUM];//\n// crack's offset\nvec2 center =vec2(.0,-.0);//creak center pos\n\nfloat rnd(vec2 s)\n{\n    return 1.-2.*fract(sin(s.x*253.13+s.y*341.41)*589.19);\n}\nfloat rand(float x)\n{\n    return fract(sin(x*873.15)*519.19);\n}\n//find the nearest point\nint GetNearPos(vec2 p){\n    vec2 v = chipInfo[0].xy;\n    int idx = 0;\n\tfor(int c=0;c<NUM;c++)\n    {\n        vec2 vc=chipInfo[c].xy;\n        vec2 vp2 =vc-p;\n        vec2 vp = v-p;\n        if(dot(vp2,vp2)<dot(vp,vp))\n        {\n\t        v=vc;\n            idx = c;\n        }\n    }\n    return idx;\n}\n\n// calculate the ith chip's move offset\nvec2 MoveOffset(int idx,float t){\n    vec2 offset = vec2(0.);\n    float radVal  =rand(float(idx+1))+0.1;\n    vec2 centerPos = chipInfo[idx].xy;\n    vec2 diff = centerPos -center;\n    float dist = length(diff);\n    if(t>0.0)\n    {\n        //init velocity\n        vec2 initVel = normalize(diff)*dist*1.;\n        //add gravity\n        offset = initVel*t + vec2(0.,1.)* t*t*-0.5;\t\n    }\n    return offset;\n}\n\n// ref https://www.shadertoy.com/view/XdBSzW\nfloat GetGapFactor(vec2 p){\n\tvec2 v=vec2(1E3);\n    vec2 v2=vec2(1E4);\n    //find the most near pos v and v2\n    for(int c=0;c<NUM;c++)\n    {\n        vec2 vc=chipInfo[c].xy;\n        if(length(vc-p)<length(v-p))\n        {\n            v2=v;\n            v=vc;\n        }\n        else if(length(vc-p)<length(v2-p))\n        {\n            v2=vc;\n        }\n    }\n    //check for whether p is at the middle of v and v2\n    float factor= abs(length(dot(p-v,normalize(v-v2)))-length(dot(p-v2,normalize(v-v2))))\n        +.002*length(p-center);\n    factor=7E-4/factor;\n    if(length(v-v2)<4E-3) factor=0.;\n    if(factor<.01) factor = 0.;\n    return factor;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord.xy*2.-iResolution.xy)/iResolution.x;\n    \n    vec2 center=vec2(.0,-.0);\n    float isNear = 0.;\n  \n    float modT = mod(iTime,5.);\n    float time = modT-3.;\n    \n    for(int c=0;c<NUM;c++)\n    {\n        //1.generate Random point \n        float angle=floor(rnd(vec2(float(c),387.44))*16.)//-15~15\n            *3.1415*.4-.5;\n        float dist=pow(rnd(vec2(float(c),78.21)),2.)*.5;//0~0.5\n        vec2 vc=vec2(center.x+cos(angle)*dist,\n                     center.y+sin(angle)*dist);\n        chipInfo[c].xy= vc.xy;\n        //2.compute each chip's move offset\n        chipInfo[c].zw = MoveOffset(c,time);\n    }\n    int belongIdx = -1;\n    for(int c=0;c<NUM;c++)\n    {\n        //3.get raw pos \n        vec2 rawPos = p - chipInfo[c].zw;\n        //4.compute which chip the rawPos locate at\n        int idx = GetNearPos(rawPos);\n        if(idx == c){\n            belongIdx = c;\n        \tbreak;\n        }\n    }\n    vec3 finalCol = vec3(0.);\n    // if this fragment is belong to any chip\n    if(belongIdx != -1){\n        vec2 moveOffset = chipInfo[belongIdx].zw;\n        //calc the raw pos before the picture is broken\n        vec2 rawPos = p - moveOffset;\n        //5.calc the uv from the raw pos\n        vec2 rawCoord = (rawPos*iResolution.x + iResolution.xy)* 0.5;\n        rawCoord.y =iResolution.y-rawCoord.y;\n        // simulate the reflect effect \n        vec2 brokenOffset = vec2(rnd(vec2(belongIdx))*.006);\n        vec2 uv =(rawCoord.xy)/iResolution.xy + brokenOffset;\n        \n        vec4 tex=texture(iChannel0,uv);\n        finalCol = tex.xyz;\n        \n        //if uv is out of window then get black color\n        if(time>0.){\n            if(uv.x>1.||uv.x<0.||uv.y>1.||uv.y<0.){\n                finalCol = vec3(0.);\n            }\n        }\n    }\n    #if DRAW_GAP_LINE\n    if(time<0.)\n    {\n        //draw Gap line\n        float gapFactor = GetGapFactor(p);\n        finalCol=gapFactor*vec3(1.-finalCol.xyz)+(1.-gapFactor)*finalCol.xyz;\n        //draw the points\n        #if  DRAW_POINTS\n        float isNear = 0.;\n        for(int c=0;c<NUM;c++)\n        {\n            vec2 vc = chipInfo[c].xy;\n            //get raw pos \n            if(length(vc-p)<0.01){\n                isNear = 1.;\n            }\n        }\n        finalCol = finalCol *(1.-isNear);\n        #endif\n    }\n    #endif\n  \n    fragColor = vec4(finalCol,1.);\n}","name":"Image","description":"","type":"image"}]}