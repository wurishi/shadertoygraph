{"ver":"0.1","info":{"id":"mtBGWy","date":"1673833862","viewed":79,"name":"1D Game of Life","username":"jellygatorade","description":"Elementary cellular automata based on Inigo Quilez game of life - https://www.shadertoy.com/view/XstGRf","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","automata","life","conway","gameoflife","multipass"],"hasliked":0,"parentid":"XstGRf","parentname":"GameOfLife"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based on Inigo Quilez Game of Life shader\n// https://www.shadertoy.com/view/XstGRf\n// https://iquilezles.org/articles/gameoflife/\n//\n// Using Rule 30 - https://en.wikipedia.org/wiki/Rule_30\n\nfloat scaleBy = 8.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 1. / scaleBy;\n    fragColor = vec4( texelFetch( iChannel0, ivec2( scale * fragCoord), 0 ).xxx, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Based on Inigo Quilez Game of Life shader\n// https://www.shadertoy.com/view/XstGRf\n// https://iquilezles.org/articles/gameoflife/\n//\n// Using Rule 30 - https://en.wikipedia.org/wiki/Rule_30\n\n\nint cell( in ivec2 p )\n{\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return (texelFetch(iChannel0, p, 0 ).x > 0.5 ) ? 1 : 0;\n}\n\nfloat hash1( float n )\n{\n    return fract(sin(n)*138.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    int left = cell(px+ivec2(-1, 0));\n    int self = cell(px);\n    int right = cell(px+ivec2(1, 0));\n    \n    // Rule 30 - https://en.wikipedia.org/wiki/Rule_30\n    // left_cell XOR (central_cell OR right_cell) \n    float f = (left==1) ^^ ((self==1) || (right==1)) ? 1.0 : 0.0;\n    \n    if( iFrame==0 ) {\n    \n    // Original includes hash based on y-coordinate\n    //f = step(0.5, hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)));\n    \n    // Neglect data in y direction (vertical bars only)\n    f = step(0.5, hash1(fragCoord.x*13.0));\n    \n    }\n\t\n\tfragColor = vec4( f, 0.0, 0.0, 0.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}