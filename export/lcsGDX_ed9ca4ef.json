{"ver":"0.1","info":{"id":"lcsGDX","date":"1705010380","viewed":162,"name":"Quadratic Viewport","username":"Diefly75","description":"Some fun with simple multiviewport (but very very badly/not efficiently implemented, i know Â¦;O)\nnext possible improvement ? \n1- Using 1 buffer per viewport ?\n2- Drawing obj with SDF (definitively sure, regarding my obj rendering -> so heavy !)\n3- etc ...","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["perspective","top","orthoright","front"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float drawpointOrtho(vec3 camera,vec3 screen,vec3 objpos,float size){\n    \n    float d = length(cross(objpos-screen,camera))/length(camera);\n    d=smoothstep(size,size-size/0.5,d);\n    return d;\n}\n\nfloat drawpoint(vec3 camera,vec3 screen,vec3 objpos,float size){\n    \n    float d = length(cross(objpos-camera,screen))/length(screen);\n    d=smoothstep(size,size-size/0.5,d);\n    return d;\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(vec2(c, -s),vec2(s, c));\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Define quadratic viewport --->\n    //============================================================\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv= uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //Bottom Left viewport (Perspective)\n    vec2 BLuv = fragCoord;\n    if(BLuv.x > iResolution.x/2. || BLuv.y > iResolution.y/2.){\n        BLuv=vec2(0.);\n    }\n    \n    BLuv = (BLuv.xy/iResolution.xy)*2.;\n    BLuv = BLuv*2.-1.;\n    BLuv.x *= iResolution.x/iResolution.y;\n    \n    float zoom = 1.;\n    vec3 camera = vec3(0.,1.,-1.5);\n    vec3 screen = vec3(BLuv.x,BLuv.y,-1)-camera;\n    vec3 lookat = vec3(0.,0.,0.);\n    \n    vec3 f = normalize(lookat-camera);\n    vec3 r = cross(vec3(.0,1.,.0),f);\n    vec3 u = cross(f,r);\n    \n    vec3 c = camera+f*zoom;\n    vec3 i = c+BLuv.x*r + BLuv.y*u;\n    \n    screen = (i-camera); \n    \n    \n    //Top Left viewport (Front)\n    vec2 TLuv = fragCoord;\n    if(TLuv.x > iResolution.x/2. || TLuv.y < iResolution.y/2.){\n        TLuv=vec2(0.);\n    }\n    \n    TLuv = (TLuv.xy/iResolution.xy)*2. + vec2(0.,-1.);\n    TLuv = TLuv*2.-1.;\n    TLuv.x *= iResolution.x/iResolution.y;\n    \n    float zoomOF = 1.;\n    vec3 OrthoFront = vec3(0,0,-2.);\n    vec3 OrthoscreenF = vec3(TLuv.x,TLuv.y,-1.);\n\n\n    //Bottom Right viewport (Right)\n    vec2 BRuv = fragCoord;\n    if(BRuv.x < iResolution.x/2. || BRuv.y > iResolution.y/2.){\n        BRuv=vec2(0.);\n    }\n    \n    BRuv = (BRuv.xy/iResolution.xy)*2. + vec2(-1.,0.);\n    BRuv = BRuv*2.-1.;\n    BRuv.x *= iResolution.x/iResolution.y;\n    \n    float zoomOR = 1.;\n    vec3 OrthoRight = vec3(-2,0,0);\n    vec3 OrthoscreenR = vec3(-1.,BRuv.y,BRuv.x);\n\n\n    //Top Right viewport (Top)\n    vec2 TRuv = fragCoord;\n    if(TRuv.x < iResolution.x/2. || TRuv.y < iResolution.y/2.){\n        TRuv=vec2(0.);\n    }\n    \n    TRuv = (TRuv.xy/iResolution.xy)*2. + vec2(-1.,-1.);\n    TRuv = TRuv*2.-1.;\n    TRuv.x *= iResolution.x/iResolution.y;\n    \n    float zoomOT = 1.0;\n    vec3 OrthoTop = vec3(0,-2,0);\n    vec3 OrthoscreenT = vec3(TRuv.x,-1.,TRuv.y);\n\n    //===========================================================================\n\n\n    // Draw the cube on each viewport\n    // ==========================================================================\n    vec3 color = vec3(0.);\n    //The Cube\n    vec3 p[8];\n    p[0] = vec3(-.5,-.5,-.5);\n    p[1] = vec3(-.5,-.5,.5);\n    p[2] = vec3(-.5,.5,-.5);    \n    p[3] = vec3(-.5,.5,.5);\n    p[4] = vec3(.5,-.5,-.5);\n    p[5] = vec3(.5,-.5,.5);\n    p[6] = vec3(.5,.5,-.5);\n    p[7] = vec3(.5,.5,.5);\n    \n    //Draw Vertexes\n    float d[8];\n    for(int i=0;i< p.length();i++){\n    \n        //Animate :RotateXZ\n        p[i].xz = rotate(p[i].xz,iTime);\n        \n        d[i] = drawpointOrtho(OrthoRight,OrthoscreenR*zoomOR,p[i],.1);\n        d[i] += drawpointOrtho(OrthoFront,OrthoscreenF*zoomOF,p[i],.1);\n        d[i] += drawpointOrtho(OrthoTop,OrthoscreenT*zoomOT,p[i],.1);\n        d[i] += drawpoint(camera,screen,p[i],.1);\n        \n        color +=d[i]; \n    }\n    \n    //Draw plotted Edges\n    float linestep = 0.;\n    float l[12];\n    vec2 pair[12];\n    pair=vec2[12](vec2(0,1),\n                  vec2(1,3),\n                  vec2(2,3),\n                  vec2(3,7),\n                  vec2(0,4),\n                  vec2(1,5),\n                  vec2(2,6),\n                  vec2(4,5),\n                  vec2(0,2),\n                  vec2(4,6),\n                  vec2(5,7),\n                  vec2(6,7));\n    \n    \n    for(float k=0.;k < 12.;k++){\n        linestep = 40.; //length(d[int(pair[int(k)].x)]-d[int(pair[int(k)].y)]);  --> i'm looking for a way to calculate by pair, the minimum necessary point to have a straight line\n        for(float j = 0.;j < linestep;j++){\n            l[int(k)] = drawpointOrtho(OrthoRight,OrthoscreenR*zoomOR,p[int(pair[int(k)].x)]+(p[int(pair[int(k)].y)]-p[int(pair[int(k)].x)])*j/linestep,.035);\n            l[int(k)] += drawpointOrtho(OrthoFront,OrthoscreenF*zoomOF,p[int(pair[int(k)].x)]+(p[int(pair[int(k)].y)]-p[int(pair[int(k)].x)])*j/linestep,.035);\n            l[int(k)] += drawpointOrtho(OrthoTop,OrthoscreenT*zoomOT,p[int(pair[int(k)].x)]+(p[int(pair[int(k)].y)]-p[int(pair[int(k)].x)])*j/linestep,.035);\n            l[int(k)] += drawpoint(camera,screen,p[int(pair[int(k)].x)]+(p[int(pair[int(k)].y)]-p[int(pair[int(k)].x)])*j/linestep,.045);\n            color += l[int(k)];\n        }\n    }\n\n    \n    vec2 bguv = fract((fragCoord.xy)/(iResolution.xy/2.));\n    bguv = bguv*2.-1.;\n    bguv.x *= iResolution.x/iResolution.y;\n    \n    vec4 backgrounds = vec4(bguv,.0,.0);\n    fragColor = vec4(color*2.,.0) * ((backgrounds+0.5)/2.) + ((-backgrounds)/10.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float noise(float seed)\n{\n    //Ultra simple noise (careful with seed range used !)\n    float noise = fract(sin(seed*6.28)*.5+.5)+4132.;  \n    return noise;\n}\n\nfloat randFromTo(float seed, float Rmin, float Rmax)\n{\n    //***Little \"in house\" function to generate a pseudo random from Rmin to Rmax input \n    float amplitude = (Rmax-Rmin)/2.;\n    float rand = sin(seed*noise(seed)*6.28)*amplitude+amplitude+Rmin;\n    return rand;\n\n}","name":"Common","description":"","type":"common"}]}