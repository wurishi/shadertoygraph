{"ver":"0.1","info":{"id":"sdKGWc","date":"1632350007","viewed":65,"name":"voxel tree pt2","username":"iuryBorgesRodrigues","description":"voxel tree pt2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["voxel","tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 2\nconst float SURFACE_DISTANCE = .0001;\n\n\nconst int MAX_STEPS = 500;\nconst int MAX_SHADOW_STEPS = 50;\n\nconst float MAX_DISTANCE = 50.;\nconst float MAX_REFLECT_DISTANCE = 5.;\nconst float MAX_SHADOW_DISTANCE = 15.;\nconst vec2 normal = vec2(0, 0.01);\n\nconst float FOV = 700.;\n\nconst vec3 AMBIENT_COL = vec3(0.08, 0.1, 0.14);\nconst float SHADOW_SOFTNESS = .2;\n\nconst float DEG_TO_RAD = 0.01745329251;\nconst vec3 CAMERA_ROTATION = vec3(-25. * DEG_TO_RAD, 35. * DEG_TO_RAD, -15. * DEG_TO_RAD);\nconst mat3 CAMERA_ROTATION_MATRIX = mat3(vec3(1, 0, 0),\n                                         vec3(0, cos(CAMERA_ROTATION.x), -sin(CAMERA_ROTATION.x)),\n                                        vec3( 0, sin(CAMERA_ROTATION.x), cos(CAMERA_ROTATION.x)) )* \n    \t\t\t\t\t\t\t\tmat3(vec3(cos(CAMERA_ROTATION.y), 0, sin(CAMERA_ROTATION.y)),\n                                        vec3(0, 1, 0),\n                                        vec3(-sin(CAMERA_ROTATION.y), 0, cos(CAMERA_ROTATION.y)) )* \n    \t\t\t\t\t\t\t\tmat3(vec3(cos(CAMERA_ROTATION.z), -sin(CAMERA_ROTATION.z), 0),\n                                        vec3(sin(CAMERA_ROTATION.z), cos(CAMERA_ROTATION.z), 0),\n                                        vec3( 0, 0, 1));\n\n\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat SDF_Plane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat SDF_Sphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SDF_Torus(vec3 p, vec3 c, vec2 t)\n{\n    p -= c;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n\n\nvec4 getDist(vec3 p)\n{\n    \n    \n  \n   \n\n\n    float f = mod(floor(6.0 * p.z) + floor(6.0 * p.x), 2.0);\n    \n    \n    \n    \n    \n    \n    vec3 pAbs=p;\n    pAbs.x=abs(pAbs.x);\n    pAbs.x-=0.3;\n    \n    vec3 pAbs2=p;\n    pAbs2.z=abs(pAbs2.z);\n    pAbs2.z-=0.4;\n    \n   \n    \n    \n    float d = sdBox(p,vec3(0.1,0.5,0.1));\n    float d1 = sdBox(pAbs+vec3(0.1,0.4,0.0),vec3(0.1,0.1,0.1));\n    float d3 = sdBox(pAbs2+vec3(0.0,0.4,0.2),vec3(0.1,0.1,0.1));\n    \n    d=min(d,d1);\n    d=min(d,d3);\n    \n    d1 = sdBox(pAbs+vec3(0.15,-0.4,0.0),vec3(0.3,0.05,0.05));\n    d3 = sdBox(pAbs2+vec3(0.0,-0.4,0.25),vec3(0.05,0.05,0.3));\n    \n    d=min(d,d1);\n    d=min(d,d3);\n    \n    \n    d1 = sdBox(pAbs+vec3(-0.1,-0.7,0.0),vec3(0.05,0.3,0.05));\n    d3 = sdBox(pAbs2+vec3(0.0,-0.7,-0.0),vec3(0.05,0.3,0.05));\n    \n    d=min(d,d1);\n    d=min(d,d3);\n    \n    float d4 = sdBox(pAbs+vec3(-0.1,-0.9,0.0),vec3(0.2));\n    float d5 = sdBox(pAbs2+vec3(0.0,-0.9,-0.0),vec3(0.2));\n    \n    d4=min(d4,d5);\n    d=min(d,d4);\n    \n    \n    float d2 = sdBox(p+vec3(0.0,-0.5,0.0),vec3(0.3,0.3,0.3));\n    vec4 p1 = vec4(d,vec3(0.561,0.349,0.008));\n    vec4 p2 = vec4(d4,vec3(0.0,1.0,0.0));\n   \n    \n    \n    \n    \n    p.y+=0.5;\n    vec4 plane = vec4(p.y,vec4(0.4 + f * vec4(0.6)));\n    \n    \n    \n    p1=opU(p1,  p2);\n   \n    p1=opU(p1,  plane);\n    return p1;\n}\n\nvec4 rayMarch(vec3 rO, vec3 rD, float maxDistance)\n{   \n    float dist = 0.;\n    vec3 col;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec4 dS = getDist(rO + rD * dist);\n        dist += dS.x;\n        col = dS.yzw;\n        if (dS.x < SURFACE_DISTANCE || dist > MAX_DISTANCE) \n        {\n            break;\n        }\n    }\n    \n    return vec4(dist, col.rgb);\n}\n\nfloat shadows(vec3 rO, vec3 lD)\n{\n    float shadow = 1.;\n    float t = 0.;\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++)\n    {\n        float d = getDist(rO + lD*t).x;\n        shadow = min(shadow, 0.5 + 0.5 * d / (SHADOW_SOFTNESS * t));\n        if (shadow < 0. || t > MAX_SHADOW_DISTANCE) break;\n        t += d;\n    }\n    shadow = max(shadow, 0.);\n    return smoothstep(.5, 1., shadow);\n}\n#define N_AIR 1.0\n#define N_GLASS 1.51\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(getDist(p - normal.yxx).x, getDist(p - normal.xyx).x, getDist(p - normal.xxy).x));\n}\nfloat fresnel(vec3 rd, vec3 n,float n1, float n2){\n    float I = acos(abs(dot(rd, n))-0.0001);\n    float cosI = cos(I);\n    float cosR = n1/n2 * sin(I);\n    if(cosR > 1.0) return 1.0; // total internal reflection\n    cosR = sqrt(1.0 - cosR * cosR);\n    float Rs = (n1*cosI - n2 * cosR)/(n1*cosI + n2 * cosR);\n    float Rp = (n1*cosR - n2 * cosI)/(n1*cosR + n2 * cosI);\n    return mix(Rs*Rs, Rp*Rp, 0.5);\n}\nvec3 shade(vec3 p, vec3 lightDir, vec3 rD, vec3 nrm, vec3 baseCol)\n{\n    float fresnel=fresnel(rD,nrm,N_AIR,N_GLASS);\n    \n    vec3 col = vec3(0,0,0);\n    \n    vec3 diff = vec3(max(0., dot(nrm, lightDir))) * baseCol;\n    \n    float spec = pow(max(0., dot(-rD, reflect(lightDir, nrm))), 40.) * .6;\n    col = diff+   spec ;\n    col+=vec3(1.0)*fresnel;\n    \n    col *= vec3(shadows(p - lightDir * 0.01, -lightDir));\n    \n    col += AMBIENT_COL;\n    \n    return col;\n}\n\nvec3 renderSky(vec3 rD)\n{\n    return vec3((1. - rD.y) / 3. + 0.25, (1. - rD.y) / 5. + 0.3, 0.8 - rD.y / 8.);\n}\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n#define PI 3.14159\nvec3 EnvRemap(vec3 c)\n{\n\treturn pow(2. * c, vec3(2.2));\n}\n\nmat3 rotation;\n\n\n#define ZERO 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t vec3 tot = vec3(0.0);\nvec3 col = vec3(0,0,0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5; \n\t\n\t\n\t\n\t//vec2 fragCoord=FRAGCOORD.xy;\n\t//vec2 iResolution=(1.0/SCREEN_PIXEL_SIZE).xy;\n\t//float iTime=TIME;\n\tvec3 SUN_DIRECTION = normalize(vec3(0.0,-1.0, 1));\n\n\t\n   \n    \n    \n  \n\t\n        \n     vec2 m2 = iMouse.xy / iResolution.xy;\n    m2.y *= -1.0;\n    m2 -= vec2(0.5);\n    \n    // initial mouse position\n    if(iMouse.xy == vec2(0.0))\n    {\n        m2= vec2(0.0, 8.0);\n    }\n\n    rotation = mat3(1.0);\n    rotation = rotx(m2.y * 10.0);\n    rotation *= rotx(PI * 0.5);\n    rotation *= roty(m2.x * 10.0);\n   \n    \n    \n    vec2 uv =fragCoord+o - iResolution.xy / vec2(2,2);\n    uv = uv - vec2(0.5, 0.5);\n    uv /= FOV;\n    \n    vec3 rO = vec3(4.8, 2., -5);\n    vec3 rD = CAMERA_ROTATION_MATRIX * normalize(vec3(uv.x, uv.y, 1));\n\n    rO*=rotation;\n    rD*=rotation;\n    vec4 dist = rayMarch(rO, rD, MAX_DISTANCE);\n    \n    \n    if (dist.x < MAX_DISTANCE)\n    {\n        vec3 p = rO + dist.x * rD;\n    \tvec3 nrm = getNormal(p);\n        vec3 lightDir = normalize(SUN_DIRECTION +vec3(0.8,5.0,-3.0) * -6.);\n        \n        col = shade(p, lightDir, rD, nrm, dist.yzw);\n        \n        vec3 ref = reflect(rD, nrm);\n        vec4 refDist = rayMarch(p + (ref * 0.01), ref, MAX_REFLECT_DISTANCE);\n\t\tvec3 reflectCol;\n        \n        if (refDist.x < MAX_REFLECT_DISTANCE)\n        {\n            vec3 refP = (p + ref * 0.01) + (ref * refDist.x);\n            vec3 refNrm = getNormal(refP);\n            reflectCol = shade(refP, lightDir, ref, refNrm, refDist.yzw);\n        }\n        else\n        {\n            //reflectCol = texture(iChannel0, ref).rgb;\n            reflectCol=textureLod(iChannel0, ref,0.0).rgb;\n        }\n        \n        col = mix(col, reflectCol, clamp(pow(1. - dot(rD, nrm), 4.), 0., 1.));\n    }\n    else \n    {\n    \tcol=EnvRemap(textureLod(iChannel0, rD,0.0).rgb);\n       \n       // col = renderSky(rD);\n    }\n \ttot += col;\n    }\n     tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n}\n\n\n\n\n/*float lightFeeler = rayMarch(p - lightDir * 0.01, -lightDir, MAX_DISTANCE);\n        \n        if (lightFeeler < MAX_DISTANCE)\n        {\n            col.rgb = AMBIENT_COL;\n        }*/","name":"Image","description":"","type":"image"}]}