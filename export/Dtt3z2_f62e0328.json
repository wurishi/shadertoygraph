{"ver":"0.1","info":{"id":"Dtt3z2","date":"1682892876","viewed":320,"name":"Screen-space dashed polylines","username":"leoneruggiero","description":"An attempt at drawing dashed/dotted poly-lines by using a screen-space to u coordinate mapping for the vertices.\nThis method is meant to be used with geometry shaders with adjacency data as input. ","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["lines","npr","stipple","linework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float LinePointDist(vec2 pt, vec2 linePt, vec2 lineNrm)\n{\n  return abs(dot(pt-linePt, lineNrm));\n}\n\nfloat LineSegmentPointDist(vec2 pt, vec2 lineStart, vec2 lineEnd)\n{\n    vec2 lineTan  = lineEnd-lineStart;\n    float lineLen = length(lineTan);\n    lineTan       = normalize(lineTan);\n    vec2 lineNrm  = vec2(-lineTan.y, lineTan.x);\n    \n    float ptDist = min(\n        length(pt-lineStart),\n        length(pt-lineEnd)\n    );\n    \n    float k = dot(pt-lineStart, lineTan);\n    \n    if(k >= 0.f && k <= lineLen ) return abs(dot(pt-lineStart, lineNrm));\n    else                          return ptDist;\n}\n\nvec4 RasterizeLine(uniforms u, fs_in p0, fs_in p1, out float coverage)\n{\n   \n   vec2 p0screen = Remap(p0.position.xy, vec4(-1.f, -1.f, 1.f, 1.f), vec4(vec2(0.f), iResolution.xy));\n   vec2 p1screen = Remap(p1.position.xy, vec4(-1.f, -1.f, 1.f, 1.f), vec4(vec2(0.f), iResolution.xy));\n   \n   float screenLen0 = length(p1screen-p0screen);\n   vec2  lineTan0   = (p1screen-p0screen)/screenLen0;\n   float s          = dot(lineTan0, gl_FragCoord.xy-p0screen.xy)/screenLen0;\n   \n   fs_in fsData;\n   fsData.position = mix(p0.position, p1.position, s);\n   fsData.u        = mix(p0.u, p1.u,               s);\n   \n   vec4 fsRes = Background(gl_FragCoord.xy);\n   coverage = 0.f;\n   \n   float d = LineSegmentPointDist(gl_FragCoord.xy, p0screen, p1screen)-(lineWidth*0.5f);\n    \n   if(d<1.f) \n   {\n       // fragment shader invocation\n       fsRes = fs(u, fsData); \n       \n       coverage = 1.f-clamp(d, 0.f, 1.0f);\n   }\n    \n    return fsRes;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4  c           = Background(fragCoord/vec2(iResolution.xy));\n    vec4  fsCol       = c;\n    float maxCoverage = 0.f;\n    \n    for(int i=0; i<numPts; i++)\n    {\n        float coverage = 0.0f;\n        \n        // vertex processing\n        // ------------------------------------\n        uniforms u;\n        u.viewMatrix = viewMatrix(iTime);\n        u.projMatrix = projMatrix(iResolution.x/iResolution.y);\n        u.screenSize = iResolution.xy;\n        u.time       = iTime;\n        \n        vs_in vin;\n        vin.p0 = PointOnCylinder(4.3f, numPts, i);\n        vin.p1 = PointOnCylinder(4.3f, numPts, i+1);\n        vin.p2 = PointOnCylinder(4.3f, numPts, i+2);\n        \n        fs_in v0out;\n        fs_in v1out;\n        \n        // vertex shader invocation\n        vs(u, vin, v0out, v1out);\n        \n        v0out.position.xyz/=v0out.position.w;\n        v1out.position.xyz/=v1out.position.w;\n        // ------------------------------------\n        \n        vec4 fsout=RasterizeLine(u, v0out, v1out, coverage);\n        \n        // completely fictional aa method:\n        // the primitive with the greatest\n        // coverage wins. \n        // looks OKish though\n        if(coverage > maxCoverage)\n        {\n            maxCoverage = coverage;\n            fsCol = fsout;\n        }\n    }\n    \n    c = mix(c, fsCol, maxCoverage*fsCol.a);\n    \n    // Output to screen\n    fragColor = c;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14f\n\n// STIPPLE ------------------------------------\n#define DASH     0\n#define DOT      1\n#define DASH_DOT 2\n\n/// Write here to change the stipple pattern\n///////////////////////////////////////////////\n#define PATTERN DASH\n\n// --------------------------------------------\n\n\n// 3D MODEL -----------------------------------\n#define QUAD       0\n#define PENTA      1\n#define CYL        2\n#define CYL_HI_RES 3\n\n/// Write here to choose the 3d model\n///////////////////////////////////////////////\n#define MODEL CYL\n\n// ---------------------------------------------\n\nconst float lineWidth  = 2.f;  \nconst int   numPts     \n#if   MODEL == QUAD\n                            = 9;\n#elif MODEL == PENTA\n                            = 11;\n#elif MODEL == CYL\n                            = 33;\n#elif MODEL == CYL_HI_RES\n                            = 65;\n#endif\n\nconst float patternLen \n#if PATTERN == DOT\n                       = 0.02f;\n#else\n                       = 0.035f;\n#endif\n\nconst float ks         = 5.0f;\nconst float kd         = 15.0f;\n\nmat4 viewMatrix(float time)\n{\n    float a = time*PI*0.14f;\n    float b = time*PI*0.07f;\n    \n    vec3 x = vec3(cos(a),0.0f,sin(a));\n    vec3 y = vec3(0.0f,cos(b),sin(b));\n    vec3 z = normalize(cross(x, y));\n    x      = normalize(cross(y, z));\n\n    return mat4(\n    vec4(x, 0.0f),\n    vec4(y, 0.0f),\n    vec4(z, 0.0f), \n    vec4(0.0f, 0.0f, kd, 0.0f)\n    );\n    \n}\n\nmat4 projMatrix(float ar)\n{\n  \n    float n    = 0.3f;\n    float f    = 20.0f;\n    float fovy = PI*0.2f;\n    float t    = tan(fovy)*n;\n    float r    = t*ar;\n    \n    return mat4(\n        n/r, 0.f, 0.f,             0.f,\n        0.f, n/t, 0.f,             0.f,\n        0.f, 0.f,-(f+n)    /(f-n),-1.f,\n        0.f, 0.f,-(2.f*f*n)/(f-n), 0.f\n    );\n}\n\nstruct uniforms\n{\n    mat4  viewMatrix;\n    mat4  projMatrix;\n    vec2  screenSize;\n    float time;\n};\n\nstruct vs_in\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2; // adjacency data\n};\n\nstruct fs_in\n{\n    vec4  position; // ndc in fragment shader\n    float u;        // noperspective interpolation\n};\n\n// vertex shader\n// ------------------------------------------------------------\nvec2 Remap(vec2 val, vec4 oldRange, vec4 newRange)\n{\n  return newRange.xy + ((val - oldRange.xy) * (newRange.zw - newRange.xy) / (oldRange.zw - oldRange.xy));\n}\n\nvoid WarpU(inout float u1, float u2, float modulo) \n{\n  // Increments/decrements u1 so that it becomes\n  // equal to u2 after mod(modulo) is applied.\n\n  float d = mod(u2, modulo) - mod(u1, modulo);\n  \n  if(abs(d)<0.5f*modulo)\n  {\n    u1+=d;\n  }\n  else\n  {\n    u1+= d- sign(d)*modulo;\n  }\n}\n\nfloat MapU(vec2 tanSS, vec2 ptSS, vec2 scrSize)\n{\n    // Maps screen positions to u coordinates.\n    // The point ptSS is the start/end of a line, \n    // and the mapping is determined by the \n    // orientation (tanSS) of the line.\n    //\n    // There are 4 possible mapping functions:\n    //   u = screen x coordinate\n    //   u = reversed screen x coord\n    //   u = screen y coordinate\n    //   u = reversed screen y coord\n    \n    if(abs(tanSS.x)>abs(tanSS.y)) // screen x \n    {\n       if(tanSS.x>0.f) return ptSS.x;\n       else            return scrSize.x - ptSS.x;\n    }\n    else                          // screen y\n    {\n       if(tanSS.y>0.f) return ptSS.y;\n       else            return scrSize.y - ptSS.y;\n    }\n}\n\nvoid vs(uniforms u, vs_in vsin, out fs_in v0out, out fs_in v1out)\n{\n    // Not a vertex shader....something in between a vertex\n    // and a geometry shader where adjacent vertices data is\n    // provided (LINE_STRP_ADJACENCY).\n    mat4 mp = u.projMatrix * u.viewMatrix;\n    vec4 v0 = mp * vec4(vsin.p0, 1.f);\n    vec4 v1 = mp * vec4(vsin.p1, 1.f);\n    vec4 v2 = mp * vec4(vsin.p2, 1.f);\n        \n    vec2 p0screen = Remap(v0.xy/v0.w, vec4(-1.f, -1.f, 1.f, 1.f), vec4(vec2(0.f), u.screenSize));\n    vec2 p1screen = Remap(v1.xy/v1.w, vec4(-1.f, -1.f, 1.f, 1.f), vec4(vec2(0.f), u.screenSize));\n    vec2 p2screen = Remap(v2.xy/v2.w, vec4(-1.f, -1.f, 1.f, 1.f), vec4(vec2(0.f), u.screenSize));\n   \n    float screenLen0 = length(p1screen-p0screen);\n    float screenLen1 = length(p2screen-p1screen);\n    vec2  lineTan0  = (p1screen-p0screen)/screenLen0;\n    vec2  lineTan1  = (p2screen-p1screen)/screenLen1;\n    \n    // Mapping points p0 and p1 to u coordinates.\n    // The interpolated u value (noperspective interpolation)\n    // will be used to draw the stipple by applying\n    // the modulo operator on u.\n    //\n    // Here a u coordinate is establised for p0 and p1.\n    // u0 (for p0) remains unchanged, while u1 (for p1)\n    // is \"warped\" so that it is equal to the u coordinate\n    // of the start point of the next line.\n    float u0 = MapU(lineTan0, p0screen, u.screenSize);\n    float u1 = MapU(lineTan0, p1screen, u.screenSize);\n    float u2 = MapU(lineTan1, p1screen, u.screenSize);\n   \n    WarpU(u1, u2, patternLen * u.screenSize.y);\n    \n    v0out = fs_in(v0, u0);\n    v1out = fs_in(v1, u1);\n}\n// ------------------------------------------------------------\n        \n\n// fragment shader\n// ------------------------------------------------------------\nvec4 fs(uniforms un,fs_in fsin) // : color\n{\n    float d = patternLen * un.screenSize.y;\n    float u = mod(fsin.u,d)/d;\n    \n    // *** DEBUG ***\n    // return vec4(u,u,u, 1.0f);\n    \n    float fog = clamp(-(fsin.position.w+kd)*0.165f, 0.f, 0.8f);\n    float a = 1.f-fog;\n    \n#if   PATTERN == DASH\n    if( u > 0.35f)             return vec4(1.f, 1.f, 1.f, a);\n#elif PATTERN == DOT\n    if( u > 0.4f && u < 0.6f)  return vec4(1.f, 1.f, 1.f, a);\n#elif PATTERN == DASH_DOT\n    if( u < 0.6f  ||\n      ( u > 0.75f &&\n        u < 0.85f))            return vec4(1.f, 1.f, 1.f, a);\n#endif\n    else                       return vec4(0.f);\n\n}\n// ------------------------------------------------------------\n\nvec4 Background(vec2 fragCoord)\n{\n    float v=length(fragCoord*2.0f-1.0f);\n    return mix(vec4(0.f, 0.f, 0.f, 1.f), vec4(0.2f, 0.2f, 0.45f, 1.f), v*0.45f);\n}\n\nvec3 PointOnSine(float a, int subdv, int index, float t)\n{\n  float dx = 2.f*PI/float(subdv);\n  \n  return vec3(\n  -a + float(index)*dx/PI        * a, \n  sin(-2.f*PI + float(index)*dx) * a * 0.5f * sin(t*0.63f),\n  0.0f\n  );\n\n}\nvec3 PointOnCircle(float r, int subdv, int index)\n{\n  float da = 2.f*PI / float(subdv);\n  float a  = float(index) * da;\n  \n  return vec3(\n  cos(a),\n  sin(a),\n  0.0f\n  ) * r;\n\n}\nvec3 PointOnCylinder(float r, int subdv, int index)\n{\n  float s = float(subdv/2);\n  bool  u = float(index) <=s;\n  float da = 2.f*PI / float(s);\n  float a  = float(index + (u ? 1 : 0)) * da;\n  \n  return vec3(\n  cos(a),\n  sin(a),\n  u ? -1 : 1\n  ) * r;\n\n}","name":"Common","description":"","type":"common"}]}