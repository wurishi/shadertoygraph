{"ver":"0.1","info":{"id":"XltBWj","date":"1541800884","viewed":230,"name":"Simple terrain","username":"HUYNH","description":"Simple terrain with noise and smooth function","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float EPSILON = 0.0001;\n\n\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n\n// Reference:  https://thebookofshaders.com/11/?lan=fr\n// noise\n// Not so good, but ok \nfloat noise (float px, float pz) {\n    vec2 st = vec2(px,pz);\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth\n\n    vec2 u = f*f*(3.0-2.0*f);\n    \n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvec3 getNormal( const vec3  p )\n{\n    return normalize( vec3( noise(p.x-EPSILON,p.z) - noise(p.x+EPSILON,p.z),\n                            2.0*EPSILON,\n                            noise(p.x,p.z-EPSILON) - noise(p.x,p.z+EPSILON) ) );\n}\n\n\n// Phong shading\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    \n    vec3 N = getNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        \n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n       \n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(50.0 * sin(iTime/2.0),\n                          80.0,\n                          50.0 * cos(iTime/2.0));\n    \n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n   \n    return color;\n}\n\n\nbool castRay(vec3  ro,  vec3 rd, inout float resT)\n{\n    \n    const float delt = 0.1;\n    const float mint = 0.00;\n    const float maxt = 20.0;\n    for( float t = mint; t < maxt; t += delt )\n    {\n         vec3 p = ro + rd*t;\n        if( p.y < 0.5*noise( p.x, p.z ) )\n        {\n            resT = t - 0.5*delt;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 2, 0);\n    float dist ;\n    \n    if (!castRay(eye, dir,dist)) {\n        // Sky \n        vec3 col = 0.9*vec3(0.4,0.65,1.0) - dir.y*vec3(0.4,0.36,0.4);\n        \n        fragColor = vec4(col, 0.0);\n\t\treturn;\n    }\n    \n    // Terrain Color\n    vec3 p = eye + dist * dir;\n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(0.0, 0.0, 0.0);\n    float shininess = 0.0;   \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}