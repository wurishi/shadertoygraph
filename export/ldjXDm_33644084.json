{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// First try at RayMarching / Use of implicit surfaces\n// Senryoku - 09/2014\n// Based on \"Blobs\" by Eric Galin\n\n// Updates:\n// 22/11/14 - Small cleanup and optimizations\n// (...Many modifications...)\n\n// Configuration\n\n// Comment this to enable mouse control\n#define AUTO_ROTATE \n#define SELF_REFLEXION\n#define SELF_SHADOWING\n#define SOFT_SHADOW\n\nconst int Steps = 150; // Max. ray steps before bailing out\nconst float Epsilon = 0.0025; // Marching epsilon\n\nconst float RayMaxLength = 7.0;\nconst float Near = 16.0; // Screen rays starting point\n\n// Point Light\nvec3 LightPos = vec3(5.0 , 2.0, -5.0);\nconst vec3 LightColor = vec3(1.0, 1.0, 1.0);\n\nfloat Time = 600.0;\n\n// Pre-declarations\n\n// Rotations around an axis\nvec3 rotateX(vec3 p, float a);\nvec3 rotateY(vec3 p, float a);\nvec3 rotateZ(vec3 p, float a);\n\n///////////////////////////////////////////////////////////////////////////\n// Distance => Energy function\n\n// Smooth falloff function\n// Returns (1 - rÂ²/RÂ²)^3\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R)\n{\n\tfloat x = clamp(r / R, 0.0, 1.0);\n\tfloat y = (1.0 - x * x);\n\treturn y * y * y;\n}\n\n// Returns the maximum of the derivative of the falloff function\n// (Lipschitz constant)\nfloat falloff_lipschitz(float R)\n{\n\treturn 1.71730020672 // ~= 96.0 / (25.0 * sqrt(5.0))\n\t\t\t\t/ (R * R);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e, float R)\n{\n\treturn e * falloff(length(p - c), R);\n}\n\n// Segment skeleton\n// p : point\n// a : First point of skeleton\n// b : Second point of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat segment(vec3 p, vec3 a, vec3 b, float e, float R)\n{\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(p - a, ab) / dot(ab, ab), 0.0, 1.0);\n\treturn e * falloff(length(p - (a + t * ab)), R);\n}\n\n// Circle skeleton\n// p : point\n// c : circle center\n// n : circle normal\n// r : circle radius\n// e : energy associated to skeleton\n// R : large radius\nfloat circle(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n\tvec3 rad = c + r * normalize(p - dot(p, n) * n);\n\treturn e * falloff(distance(p, rad), R);\n}\n\n// Disc skeleton\n// p : point\n// c : disc center\n// n : disc normal\n// r : disc radius\n// e : energy associated to skeleton\n// R : large radius\nfloat disc(vec3 p, vec3 c, vec3 n, float r, float e, float R)\n{\n    vec3 proj = p - dot(p, n) * n;\n    if(length(proj - c) < r)\n        return e * falloff(distance(p, proj), R);\n\tvec3 rad = c + r * normalize(proj);\n\treturn e * falloff(distance(p, rad), R);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n\n///////////////////////////////////////////////////////////////////////////\n// Object\n\n// Potential Field properties\nconst float AmbiantEnergy = -5.0; // Base value of the potential field\n\n// Primitive properties\nconst float Energy = 6.0; // Energy of each primitive (reached on skeleton)\nconst float Radius = 1.1; // Influence radius of each primitive\n\nfloat SphereTracedObject(vec3 p)\n{\n\tp.z=-p.z;\n\tfloat v = AmbiantEnergy;\n\n\tv += circle(p, vec3(0.0, 0.0, 0.0), normalize(vec3(sin(Time), tan(Time), cos(Time))), 3.0, Energy, Radius);\n\tv += point(p, vec3( 3.0 * cos(2.0 * Time), 3.0 * sin(2.0 * Time), 0.0), Energy, Radius);\n\tv += point(p, vec3( 3.0 * cos(3.0 * Time), 3.0 * sin(3.0 * Time), 1.0), Energy, Radius);\n\tv += point(p, vec3( 3.0 * cos(6.0 * Time), 3.0 * sin(6.0 * Time), 1.0), Energy, Radius);\n\tv += point(p, vec3( 0.0, 0.0, 0.0), Energy, 2.0);\n\tv += point(p, vec3( cos(2.0 * Time), 2.0 * sin(Time), 1.0), Energy, Radius);\n\tv += point(p, vec3( 3.0 * sin(3.0*Time), 1.0, 2.0 * cos(3.0*Time)), Energy, Radius);\n\tv += point(p, vec3( 3.0 * sin(2.0*Time + 0.5), 1.0, 3.0 * cos(2.0*Time)), Energy, Radius);\n\n\treturn v;\n}\n\n// Returns lipschtz constant of the object's function\n// /!\\ Have to be updated with the object function...\nfloat object_lipschitz()\n{\n    return 11.0; // Good enough :] More permissive constant => Speeds up the whole thing. (But can cause artefacts)\n\t//return 7.0 * Energy * falloff_lipschitz(Radius) + Energy * falloff_lipschitz(2.0);\n}\n\n// Normal of the SphereTracedObject at point p\n// p : point\nvec3 SphereTracedObjectNormal(in vec3 p)\n{\n\tfloat eps = 0.0001;\n\tvec3 n;\n\tfloat v = SphereTracedObject(p);\n\tn.x = SphereTracedObject( vec3(p.x+eps, p.y, p.z) ) - v;\n\tn.y = SphereTracedObject( vec3(p.x, p.y+eps, p.z) ) - v;\n\tn.z = SphereTracedObject( vec3(p.x, p.y, p.z+eps) ) - v;\n\treturn -normalize(n);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////////\n// Tracing\n\n// Trace ray using sphere tracing\n// a : ray origin\n// u : ray direction\nvec3 SphereTrace(vec3 a, vec3 u, out bool hit)\n{\n\thit = false;\n\tvec3 p = a;\n\tfloat lambda = object_lipschitz();\n\tfloat depth = 0.0;\n\tfloat step = 0.0;\n\tfor(int i = 0; i < Steps; i++)\n\t{\n\t\tfloat v = SphereTracedObject(p);\n\t\tif (v > 0.0)\n\t\t{\n\t\t\thit = true; \n\t\t\treturn p;\n\t\t}\n\t\t\n\t\tstep = max(abs(v) / lambda, Epsilon);\n\t\tdepth += step;\n\t\t\n\t\tif(depth > RayMaxLength)\n\t\t\treturn p;\n\t\t\n\t\tp += step * u;\n\t}\n\treturn p;\n}\n\nfloat softShadow(vec3 a, vec3 u, float k)\n{\n    float r = 1.0;\n\tvec3 p = a;\n\tfloat lambda = object_lipschitz();\n\tfloat depth = 0.0;\n\tfloat step = 0.0;\n\tfor(int i = 0; i < Steps; i++)\n\t{\n\t\tfloat v = SphereTracedObject(p);\n\t\tif (v > 0.0)\n\t\t\treturn 0.0;\n        r = min(r, k * (v / AmbiantEnergy) / depth);\n\t\t\n\t\tstep = max(abs(v) / lambda, Epsilon);\n\t\tdepth += step;\n\t\t\n\t\tif(depth > RayMaxLength)\n\t\t\treturn r;\n\t\t\n\t\tp += step * u;\n\t}\n\treturn r;\n}\n\n//////////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////////\n// Shading\n\n// Background color\nvec3 background(vec3 rd)\n{\n\treturn texture(iChannel0, rd).xyz;\n}\n\nvec3 shade_reflect(vec3 p, vec3 rd, vec3 n)\n{\n\tvec3 diffuse = background(reflect(rd, n));\n\tvec3 l = normalize(LightPos - p);\n\n\t// Phong shading\n\tvec3 color = 0.4 * diffuse; // \"Ambiant\" Term\n\t\n    float penumbra = 1.0;\n\tfloat lambertTerm = dot(n,l);\n\tif(lambertTerm > 0.0)\n\t{\n\t\t#ifdef SELF_SHADOWING\n\t\tbool gotout = false;\n\t\tbool hit = false;\n\t\tvec3 p2 = p + Epsilon * l;\n\t\tfor(int i = 0; i < Steps; i++)\n\t\t{\n\t\t\tfloat v = SphereTracedObject(p2);\n\t\t\tif (v < 0.0)\n\t\t\t{\n\t\t\t\tgotout = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp2 += Epsilon * l;\n\t\t}\n        #ifdef SOFT_SHADOW\n        if(gotout)\n            penumbra = clamp(softShadow(p2, l, 16.0), 0.0, 1.0);\n        #else\n\t\tif(gotout)\n\t\t\tSphereTrace(p2, l, hit);\n\t\tif(hit) // We're in shadows, skip diffuse and specular terms \n\t\t\treturn color;\n        #endif\n\t\t#endif\n\t\t\n        vec3 shaded = penumbra * LightColor;\n        \n\t\t// Diffuse Term\n\t\tcolor += lambertTerm * shaded * diffuse;\t\n\n\t\t// Specular Term\n\t\tvec3 r = reflect(l, n);\n\t\tfloat specular = pow( max(dot(r, rd), 0.0), 8.0);\n\t\tcolor += specular * shaded;\t\n\t}\n\n\treturn color;\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pixel = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\t\n\tTime = 0.2 * iTime;\n\t\n\t//LightPos = vec3(5.0 * sin(Time * 2.0), 2.0, 5.0 * cos(Time * 2.0));\n\n\t// Compute ray origin and direction\n\tfloat asp = iResolution.x / iResolution.y;\n\tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y, -5.0));\n\tvec3 ro = vec3(0.0, 0.0, 20.0);\n\n#ifdef AUTO_ROTATE\n\tro = rotateY(ro, Time * 0.5);\n\trd = rotateY(rd, Time * 0.5);\n#else\n\tvec2 um = 5.0 * (iMouse.xy / iResolution.xy-.5);\n\tro = rotateX(ro, um.y);\n\trd = rotateX(rd, um.y);\n\tro = rotateY(ro, um.x);\n\trd = rotateY(rd, um.x);\n#endif\n\t\n\t// Trace ray\n\tbool hit = false;\n\tvec3 pos = vec3(0.0);\n\t\n\tvec3 rgb = vec3(0.0);\n\t\n\t// Skiping useless pixels (hackish way :D)\n\tif(pixel.x > -0.6 && pixel.x < 0.6)\n\t\tpos = SphereTrace(ro + Near * rd, rd, hit);\n\n\tif (hit)\n\t{\n\t\t// Compute normal\n\t\tvec3 n = SphereTracedObjectNormal(pos);\n\n\t\t// Shade\n#ifdef SELF_REFLEXION\n\t\tvec3 ref = SphereTrace(pos + 0.1 * n, n, hit);\n        if(hit)\n        {\n            rd = normalize(ref - pos);\n            pos = ref;\n\t\t\tn = SphereTracedObjectNormal(ref);\n        }\n        rgb = shade_reflect(pos, rd, n);\n#else\n\t\trgb = shade_reflect(pos, rd, n);\n#endif\n\t} else {\n\t\trgb = background(rd);\n\t}\n\n\tfragColor = vec4(rgb, 1.0);\n}\n\n//////////////////////////////////////////////////////////////////////////\n// Transformations\n\nvec3 rotateZ(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateX(vec3 p, float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\n//////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldjXDm","date":"1412909411","viewed":1031,"name":"First Try at RayMarching","username":"Senryoku","description":"Just having fun ! Mainly added shadowing and (one step) reflection.\n\n(Doesn't seem to work under Firefox (Windows), but I have no clue why... Edit: but it works with prefer-native-gl.)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["newbie","implicitsurface"],"hasliked":0,"parentid":"","parentname":""}}