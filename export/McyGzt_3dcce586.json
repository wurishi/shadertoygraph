{"ver":"0.1","info":{"id":"McyGzt","date":"1714956217","viewed":150,"name":"Box-O-Balls","username":"dray","description":"A first shader with procedural music (if you can call it that)\nHit the rewind button to get the sound to start at the same time.","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["procedural","sound","light","balls"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Reduce this if too slow:\n#define NUMBALLS 40\n\nfloat irnd=0.;\nfloat rnd(float l,float h)\n{\n  //irnd = mod(irnd*54.2+1.,12.33);\n  irnd = mod(irnd*54.2+.5,12.33);\n  return irnd*(h-l)/(12.33)+l;\n}\n\nfloat rndsin(float l,float h) {\n  return (sin(iTime*(cos(iTime/5.)+2.)/10.*rnd(.2,1.))+1.)/2.*(h-l)+l;\n}\n\nfloat irnd2 = 0.;\nfloat rnd2(float l,float h)\n{\n  irnd2 = mod(irnd2*54.2+.5,12.33);\n  return irnd2*(h-l)/(12.33)+l;\n}\n\nfloat rnd3(float l,float h,float seed) {\n  return mod(seed*54.2+.5,12.33)*(h-l)/(12.33)+l;\n}\n\nfloat pow2(float x,int p2) { // power of power of 2\n  while ( p2-- > 0 ) x *= x;\n  return x;\n}\n\nvec3 light;\nfloat light_size = .2;\n\nvec3 clr(float t) {\n  vec3 cc = sin(t+vec3(0.,6.28/3.,6.28*2./3.));\n  return cc * cc;\n}\nfloat end=1.;\nvec2 Dist(vec3 pt) { // return distance to closest object and object\n\n  irnd = 1.;\n\n  vec4 sphere = vec4( 0., 0., 6., .6 );\n  float dist = length( pt - sphere.xyz ) - .9 ; // + rndsin(.3,6.); \n  int id = 1;\n\n#define IF(DIST,ID) { float tmp = DIST; if ( tmp < dist ) dist = tmp, id = ID; }\n\n  IF( length( pt - light ) - light_size, 100 );\n\n  //vec4 sphere2 = vec4( 0., 3., 9., .5 );\n  //dist = min( dist, length( pt - sphere2.xyz ) - sphere2.w );\n\n  for ( int bls = 0; bls < NUMBALLS; ++bls )\n    IF( length( pt - vec3(rndsin(-7.,7.),rndsin(-7.,7.),rndsin(4.,23.)) ) - rnd(.2,.9)*end, 1000+bls )\n    \n  float irrid = .0; // .0002;\n/* When camera is close to these planes, it takes too many marches to hit or miss them.\nIt would be better to compute the intersection.\nWhen would pt.y == 9 ?\npt.y + k * dir.y == 9\npt.z + k * dir.z == Z\nZ = pt.z + ( 9 - pt.y ) / dir.y * dir.z\ndZ =  ( 9 - pt.y ) / dir.y * dir.z\ndistance( 9 - pt.y, ( 9 - pt.y ) / dir.y * dir.z )  // exact\nmax( 9 - pt.y, ( 9 - pt.y ) / dir.y * dir.z ) // better\n*/\n//if (false) \n{\n  IF( pt.y+9.   /* + rnd2(0.,irrid)  + sin(pt.x*1.3)*.1 + sin(pt.z*1.9)*.1*/, -1 ) \n  IF(-pt.y+9.   /*+ rnd3(0.,.1,pt.y+pt.x+pt.z)*/, -2 )\n  IF( pt.x+9.   /* + rnd2(0.,irrid) + sin(pt.y*2.7+iTime*3.)*.2 + sin(pt.z*3.4+iTime*7.)*.2*/, -3 )\n  IF( -pt.x+9.  /* + rnd2(0.,irrid) + sin(pt.y*2.)*.1 + sin(pt.z*1.4)*.1 */, -4 )\n  IF( -pt.z+50. /*  + rnd2(0.,irrid*10.) */, -5 )\n}  \n  return vec2(dist,id);\n  \n}\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n  float dist = 0.;\n  vec3 pos;\n  for ( int stps = 0; stps < 300; ++stps ) {\n    pos = beg + dir * dist;\n    vec2 obj = Dist( pos );\n    dist += obj.x;\n    if ( obj.x < .001 || dist > 1000. ) return vec4( pos, obj.y );;\n  }\n  return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n  float dist = Dist(pt).x;\n  float delta = .001;\n  vec3 norm = dist - vec3(\n    Dist(pt-vec3(delta, 0., 0.)).x, \n    Dist(pt-vec3( 0.,delta, 0.)).x, \n    Dist(pt-vec3( 0., 0.,delta)).x );\n  return normalize( norm );\n}\n\nfloat Light(vec3 pt) {\n  vec3 dir = normalize( light - pt );\n  vec3 norm = Normal(pt);\n  float difus = clamp( dot( norm, dir ), 0., 1. );\n  //light.x += 100000.; // ignore light\n  //light_size = -1000000.;  // ignore light\n  //light_size  = 10.;\n  vec4 shadow = March( pt, dir );\n  //light_size = .2;\n  //light.x -= 100000.; // restore light\n  //if ( shadow.x < length( light - pt ) ) difus *= .8;\n  //if ( shadow.y != 100. )  difus *= .5;\n  return difus;\n}\n\nvec2 rot2d(vec2 inp,float ang) {\n  float s = sin(ang);\n  float c = cos(ang);\n  return vec2( inp.x * c + inp.y * s, inp.y * c - inp.x * s ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  irnd2 = 0.; // mod( fragCoord.x * fragCoord.y, 43.2 );\n  irnd = 0.;\n  float stop = 56.;\n  if (iTime>stop&&iTime<80.) end=5./(5.+iTime-stop);\n  vec2 uv = (fragCoord.xy - iResolution.xy/2.) / min(iResolution.x,iResolution.y);\n  //vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / max(iResolution.x,iResolution.y); \n  //vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x,iResolution.y); // x exceeds 1\n  //fragColor = vec4(smoothstep(.9,.901,abs(uv.x)),smoothstep(.9,.901,abs(uv.y)),0.,1.0);\n  uv = rot2d( uv, iTime/4. *end);\n  \n\n  vec3 cam = vec3( 0.+sin(iTime*.25)*7.5, 0.+cos(iTime*.15)*7.5, -8.+sin(iTime*.3)*15. )*end;\n  //vec3 cam = vec3( 1.*cos(iTime), 1.*sin(iTime), -6.+sin(iTime*.33) );\n  float zz = 1. ; //+ .5*sin(iTime);\n  vec3 camdir = normalize( vec3( uv.x*zz, uv.y*zz, 1. ) );\n\n  vec3 lightA = vec3( 4.*cos(iTime*1.5), 4.*sin(iTime*.5), 4. + sin(iTime*.9)*2. );\n  //lightA += vec3( sin(iTime*1.)*2., cos(iTime*1.1)*2., cos(iTime*1.2)*5. - 2. );\n  light = lightA;\n\n  //light.x += 10000.; // get light out of the way\n  vec4 hit = March( cam, camdir );\n  //light.x -= 10000.;\n  \n  float difu = clamp( Light( hit.xyz ), 0., 1. );\n  \n  //difus = difu + (pow( difus, 40. ) - difus) * .7;\n  \n  //difus = pow( difus, .5 );\n  //difus = clamp( difus, .1, 1. );\n  \n  vec3 col = vec3(1.);\n  //vec3 difu = vec3(difus);\n\n  int obj = int(hit.w);\n  if ( obj == -5 )\n    col = vec3(0);\n  else\n  if ( obj == 90 ) // failed to find object\n    col = vec3(.9,.1,.1);\n  else\n  if ( obj != 100 ) { // not light\n    switch ( obj )\n    {\n    //case -5: col = vec3(0.,0.,.2); break;\n    case 1: col = vec3( .3, .3, .99 ); break; // main ball\n    default:\n      if ( obj >= 1000 ) {\n        col = clr(float(obj)); // balls\n      }\n      else {\n        col = vec3( .3, .9, .3 ); // walls\n      }\n      break;\n    }\n    col *= difu;\n    \n    col = col + ( pow2( difu, 5 ) * vec3(1.) - col ) * .5;\n  }\n\n  fragColor = vec4( col*end, 1. );\n\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n\nfloat rnd3(float l,float h,float seed) {\n  return mod(seed*9.2+.5,12.33)*(h-l)/(12.33)+l;\n}\n\n#define PI (3.14159265)\n#define PI2 (PI*2.)\n//#define FS float(44100)\n#define FS iSampleRate\n\n#define SIN(X) sin(mod(X,PI2))\n#define SIN2(FC) SIN( tim * (FC) * PI2 )\n#define SIN3(FC,VOL) ( SIN2( (FC) ) * (VOL) )\n#define SINC(x) (SIN(x)/(x))\n#define SINFM(FC) SINC( tim * (FC) * PI2 )\n\n#define SQR(X) ((X)*(X))\n\n#define SAW(FC) ADD( FC, 1./1. , SQR(1./2). , 0.*1./3. , 0.*1./4. , 0.*1./5. , 0.*1./6. , 0.*1./7. , 0.*1./8. )\n#define SAW2(FC) ( mod( tim * (FC) , 1. ) * 2. - 1. )\n#define SAW3(FC,L,H) ( fract( tim * (FC) ) * ( (H) - (L) ) + (L) )\n\n#define RAMP1(V1,V2,T1,T2) (((V2)-(V1))*(tim-(T1))/((T2)-(T1))+(V1))\n\n#define SQR3(FC,PW,VOL) ( SAW2(FC) > (PW) ? (VOL) : -(VOL) )\n\n#define ADD2(FC,a,b,c,d,e,f,g,h) ( \\\n  (SIN2((FC)*1.)*(a)) + \\\n  (SIN2((FC)*2.)*(b)) + \\\n  (SIN2((FC)*3.)*(c)) + \\\n  (SIN2((FC)*4.)*(d)) + \\\n  (SIN2((FC)*5.)*(e)) + \\\n  (SIN2((FC)*6.)*(f)) + \\\n  (SIN2((FC)*7.)*(g)) + \\\n  (SIN2((FC)*8.)*(h)) )\n\n#define _BP2(FC,BP,BW,HAR)    SIN2((FC)*(HAR))/(HAR) * ( (BW) / ( (BW ) + abs( (FC)*(HAR) - (BP) ) ) )\n#define BP2(FC,BP,BW) ( \\\n  _BP2( FC, BP, BW, 1. ) + \\\n  _BP2( FC, BP, BW, 2. ) + \\\n  _BP2( FC, BP, BW, 3. ) + \\\n  _BP2( FC, BP, BW, 4. ) + \\\n  _BP2( FC, BP, BW, 5. ) + \\\n  _BP2( FC, BP, BW, 6. ) + \\\n  _BP2( FC, BP, BW, 7. ) + \\\n  _BP2( FC, BP, BW, 8. ) + \\\n  _BP2( FC, BP, BW, 9. )  \\\n  )\n\n#define ABSL1(X) ((X)>1.?1./(X):(X))\n#define ABSG1(X) ((X)<1.?1./(X):(X))\n\n#define POW3(X) ((X)*(X)*(X))\n\n#define _BP3(FC,BP,BW,HAR)    SIN2((FC)*(HAR)) / (HAR) / POW3( ABSG1((FC)*(HAR)/(BP)) )\n#define BP3(FC,BP,BW) ( \\\n  _BP3( FC, BP, BW, 1. ) + \\\n  _BP3( FC, BP, BW, 2. ) + \\\n  _BP3( FC, BP, BW, 3. ) + \\\n  _BP3( FC, BP, BW, 4. ) + \\\n  _BP3( FC, BP, BW, 5. ) + \\\n  _BP3( FC, BP, BW, 6. ) + \\\n  _BP3( FC, BP, BW, 7. ) + \\\n  _BP3( FC, BP, BW, 8. ) + \\\n  _BP3( FC, BP, BW, 9. )  \\\n  )\n\n\n#define _LP2(FC,BP,BW,HAR)  SIN2((FC)*(HAR))/(HAR) * ( (BW) / ( (BW ) + max( 0., (FC)*(HAR) - (BP) ) ) )\n#define LP2(FC,BP,BW) ( \\\n  _LP2( FC, BP, BW, 1. ) + \\\n  _LP2( FC, BP, BW, 2. ) + \\\n  _LP2( FC, BP, BW, 3. ) + \\\n  _LP2( FC, BP, BW, 4. ) + \\\n  _LP2( FC, BP, BW, 5. ) + \\\n  _LP2( FC, BP, BW, 6. ) + \\\n  _LP2( FC, BP, BW, 7. ) + \\\n  _LP2( FC, BP, BW, 8. ) + \\\n  _LP2( FC, BP, BW, 9. )  \\\n  )\n\n\n// play a freq for a time\n#define P(F,T) ft = ft.y < (0. T) ? vec2(F,10000.) : ft; ft.y -= (0. T);\n\n// 12-tone notes\n#define C D f f\n#define D E f f\n#define E F f\n#define F G f f\n#define G A f f\n#define A 440.\n#define B A s s\n\n// accidentals\n#define s * 1.05946\n#define f * 0.9438\n\n// octaves\n#define L * .5\n#define H * 2.\n\n// durations\n#define e + .125\n#define t + .16666666666666\n#define q + .25\n#define h + .5\n#define w + 1.\n\n#define DO2(X) X X\n#define DO3(X) X X X\n#define DO4(X) X X X X\n#define DO5(X) DO4(X) X\n#define DO6(X) DO5(X) X\n#define DO8(X) DO4(X) DO4(X)\n\nfloat noise(int samp) {\n  int a = (samp * 123570) ^ (samp * 1487200);\n  a ^= a >> 7;\n  a ^= a >> 6;\n  a ^= a >> 5;\n  a ^= a >> 4;\n  a ^= a >> 3;\n  a ^= a >> 2;\n  a ^= a >> 1;\n  return float( a & 65535 ) / 32768. - 1.;\n}\n\nvec2 rot2d(vec2 inp,float ang) {\n  float ss = sin(ang);\n  float cc = cos(ang);\n  return vec2( inp.x * cc + inp.y * ss, inp.y * cc - inp.x * ss ); \n}\n\nvec2 mainSound( int samp, float time )\n{\n    float tim = float(samp) / FS;\n    //float tim = mod( time, 60. );\n    //float bass = SAW2(220.) + SAW2(330.) + SAW2(440.) + SAW2(550.) + SAW2(660.) + SAW2(770.) \n    //float fc = 220. ; //+ SIN(t*PI2*.5+1.) * 1. ;\n    //float bass = SQR2( fc, .95 * SIN(t*PI2*.1) ) + SQR2( fc*2./3., .95 * SIN(t*PI2*.1+1.) ) ; \n    \n    float left = 0., right = 0.;\n   float end = 56.;\n  if (tim>end&&tim<80.) tim=end+(tim-end)*10./(10.+(tim-end));\n    //tim *= .5;\n  \n    float tempo = tim * 1.;\n    \n    //tempo += w * 48. ;\n    \n    vec2 ft = vec2( 0, mod( tempo, 0. DO4(h) DO4( q q )   ) );\n    \n    DO2(   P( C L L , h )      P( C L L L, h )  )\n    DO4( P( C L , q )  P( 0, q ) )\n    \n    left += SQR3( ft.x, SIN2(1.) * .9, .1 );\n\n    if ( tempo > 0. w * 16. ) {\n\n    ft = vec2( 0, mod( tempo, 0. DO4( DO4(t t t) ) )  );\n    DO4( P( E H, t ) P( D H, t ) P( C H, t ) )\n    DO4( P( F H, t ) P( D H, t ) P( C H, t ) )\n    DO4( P( G H, t ) P( D H, t ) P( C H, t ) )\n    DO4( P( A H, t t ) P( C H, t ) )\n    \n    ft.x = ft.x * ( 1. + SINFM(7.)*.03 );\n    \n    right += SIN3( ft.x, .1 );\n    \n    }\n\n    float bp = SAW3( 1., E H H H, E L   );\n    \n    \n    if ( tempo > 0. w * 32. /* && tempo <  0. DO8( w * 16. ) */ ) {\n    \n    float fc = 0.;\n\n    //if ( tempo < 0. DO8( w * 12. ) ) {\n    \n    ft = vec2( 0, mod( tempo * 4., 0. DO8( h ) )  );\n    DO4( P( C, q ) P( D, q ) P( E, q ) P( F, q )  P( G, q ) P( A, q ) P( B, q ) P( C H, q )  )\n    DO4( P( E H, q ) P( D H, q ) P( C H, q ) P( B, q )  P( A, q ) P( G, q ) P( G, q ) P( E, q )  )\n    fc  = ft.x;\n     \n    right += BP2( fc, bp , 30. ) * .3;\n    \n    \n    \n    if ( tempo > 0. w * 48. ) {\n\n\n    float vv = max( 0. , SAW3( 2. , 1. , 0. ) );\n    vv *= vv;\n    right += noise( samp / ( mod(tempo,2.)>1. ? 16 : 1 ) ) * vv * .1;\n\n\n    float fc = C H H;\n    \n    fc = fc * ( 1. + SINFM( 6. ) * .04 );\n    //fc = SAW3( 8., 2.*fc, fc );\n    //fc += -tim;\n    \n    //left += SIN2(fc) * .3;\n    //float bp = C H H * ( 4. + SIN2( 1./8.)*2.);\n    float bp = SAW3( .5, C H H H H H , C H );\n    left += BP3( fc, bp, 60. ) * .1;\n    \n    \n  /*  \n    fc = ( 1. + SINFM( .1 ) * .2 ) * .5;\n    \n    right += fract( time * ( 1. ) * fc * C L ) *.2;\n    right += fract( time * ( 1. ) * fc * E L ) *.2;\n    right += fract( time * ( 1. ) * fc * G L ) *.2;\n    \n    */\n    }\n    \n   \n    \n    \n    /*\n    } else {\n    \n    float fc = C H H;\n    \n    right += SIN3( fc , .3 * SINFM( 2. + SIN2(.5)/.5 ) + .3 );\n\n    }\n    */\n    \n    \n    \n    }\n\n\n\n/*\n\n    float zz = float( int( tim * 5. + mod( tim * 7.34, 1.9 ) ) );\n    //ft.x = rnd3( C, A H, zz );\n    float spd = 5.;\n    float amp = 2.;\n    ft.x = C + ( D - C ) * SIN(tim*PI2*spd)*amp/spd/tim;\n\n    //P(C L L,e) P(D L L,e) P(E L L,e) P(F L L,e) P(G L L,e) P(A L L,e) P(B L L,e) \n    //P(C L,e)  P(D L,e) P(E L,e) P(F L,e) P(G L,e) P(A L,e) P(B L,e) \n    \n    P(C,e) P(D,e) P(E,e) P(F,e) P(G,e) P(A,e) P(B,e)\n    P(C H,e)  P(G,e) P(E,e)\n    P(C,e)  P(E,e)  P(G,e) P(B,e)\n    P(C s s s ,e)  P(E s s s,e)  P(G s s s,e) P(B s s s,e)\n    P(C,e)  P(E,e)  P(G,e) P(B,e)\n    P(C s s s ,e)  P(E s s s,e)  P(G s s s,e) P(B s s s,e)\n    P(C,e)  P(E,e)  P(G,e) P(B,e)\n    P(C s s s ,e)  P(E s s s,e)  P(G s s s,e) P(B s s s,e)\n    P(C,e)  P(E,e)  P(G,e) P(B,e)\n    \n    //P(C H,e) P(D H,e) P(E H,e) P(F H,e) P(G H,e) P(A H,e) P(B H,e) \n    //P(C H H,e) P(D H H,e) P(E H H,e) P(F H H,e) P(G H H,e) P(A H H,e) P(B H H,e) \n\n    ft.x *= ( 1. + SIN(tim*PI2*8.) * .0005 / tim );\n\n    float tone = 0.\n      + SQR2( C, .4* SIN(t*PI2*2. ) )*.2\n      // + SAW2( ft.x*2./3. )*.2 \n      + SIN2( E)*.4\n      + SIN2(G s)\n      // + smoothstep( -.1, .1,  SIN2( ft.x * 2. ) + .2 ) - .5\n      //+ ADD2( ft.x , 1./1. , 1./2., 1./3. , 1./4. , 1./5. , 1./6. , 1./7. , 1./8. ) \n#define QQ(ZZ) 90. / ( 90. + abs( ft.x*ZZ - C H * ( 3. + SIN(tim*PI2*.4)*3. ) ) )      \n      + ADD2( ft.x , \n          1./1. * QQ(1.) ,\n          1./2. * QQ(2.) ,\n          1./3. * QQ(3.) ,\n          1./4. * QQ(4.) ,\n          1./5. * QQ(5.) ,\n          1./6. * QQ(6.) ,\n          1./7. * QQ(7.) ,\n          1./8. * QQ(8.) )\n      //+ ADD2( ft.x + 2. , 1./1. , 1./2., 1./3. , 1./1. , 1./5. , 1./1. , 1./7. , 1./8. ) \n      ;\n    \n */    \n    //float bass = sin( t * PI2 * 440. );\n    //float v1 = cos( t * PI2 * .1 );\n    //v1 = v1 * v1 * 100.;\n    //bass = sin( bass * ( 1. +  v1 )  ) * .5;\n    //bass = smoothstep( bass, .5-v1, .5+v1 ) - .5;\n    //tone *= .2; \n    return rot2d( vec2( left, right ), SIN2(1./6.) * PI );\n\n              \n    //tone * sin( tim * PI2 * .3 ), tone * cos( tim * PI2 * .7 ) );\n}","name":"Sound","description":"","type":"sound"}]}