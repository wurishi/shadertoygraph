{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by Ramon Viladomat\n//( I used iq's smin for blending the ice when melting and fbm to generate normal maps ) \n\n// disable some of the options if the shader is running slow\n\n//////////////////////////////////\n// OPTIONS\n#define USE_SMOOTH_MIN\n//#define USE_SMOOTH_INNER_SHAPE\n#define POOL_DEFORMATION\n#define USE_NORMAL_DEFORMATION \n//#define PROCEDURAL_NOISE       \n\n//////////////////////////////////\n// CONFIG\n#define STEP_REDUCTION 0.6\n#define MARCHING_STEPS 180\n#define NUM_REFLECTIONS 2\n#define PI 3.1415\n#define EPSILON 0.001\n#define REFRACT_EPSILON 0.03\n#define TIME_SCALE 1.0\n\n#define sincos45 0.70710678118654\n\n#define RAFRACTION_FACTOR 0.76\n#define INV_RAFRACTION_FACTOR 0.90\n\n#define INTRO_TIME 2.0\n#define WAIT_TIME  1.5\n#define MELT_TIME  20.0\n#define EXIT_TIME  5.0 \n\nfloat iceTransformFactor = 0.0;\n\nfloat meltRadius      = 2.0;  \nfloat meltSmooth      = 5.0;  \nfloat meltDeformation = 0.05;  \nfloat meltHeight      = 1.2;  \n\nvec4 meltRandomPhase = vec4(0.0); \n\n// light compute \nvec3 lightColor = vec3(1.0,1.0,0.8);\nvec3 lightPos = vec3(-3.0,4.0,4.0);\nvec4 lightVec = vec4(1.0,0.0,0.0,6.0);\n\n///////////\n// NOISE //\n///////////\n\n//--------------------------------------------------------------------------\nfloat Hash( float n )\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n//iq Noise\n#ifdef PROCEDURAL_NOISE \n\n//--------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                   mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y),\n               mix(mix( Hash(n+113.0), Hash(n+114.0),f.x),\n                   mix( Hash(n+170.0), Hash(n+171.0),f.x),f.y),f.z);\n}\n\n#else \n\n//--------------------------------------------------------------------------\nfloat Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n#endif\n\n//--------------------------------------------------------------------------\nfloat Fbm(in vec3 p)\n{\n\tfloat f;\n    f  = 0.5000*Noise( p ); p = p*2.02;\n    f += 0.2500*Noise( p ); p = p*2.03;\n    f += 0.1250*Noise( p ); p = p*2.01;\n    f += 0.0625*Noise( p );\n\treturn f*2.0- 1.0; \n}\n\n//////////////////\n// UPDATE WORLD //\n//////////////////\n\n//--------------------------------------------------------------------------\nvoid UpdateWorld()\n{\t\n\t//time resources\n\tfloat currentTime = iTime*TIME_SCALE; \n\tfloat totalTime = INTRO_TIME+WAIT_TIME+MELT_TIME+EXIT_TIME;\n\tfloat localTime = mod(currentTime,totalTime); \n\tfloat meltCounter = floor(currentTime/totalTime);\n\t\t\n\t//melting\n\tfloat meltTimeFactor = clamp((localTime-(INTRO_TIME+WAIT_TIME))/MELT_TIME,0.0,1.0);\n\t\n\tmeltRadius      = mix(0.2,4.2,meltTimeFactor); \n\tmeltSmooth      = mix(8.0,2.0,meltTimeFactor); \n\tmeltDeformation = mix(0.0,0.2,meltTimeFactor);\n\tmeltHeight      = mix(0.0,3.0,meltTimeFactor);\n\t\n\tmeltRandomPhase.x = Hash(meltCounter); \n\tmeltRandomPhase.y = Hash(meltCounter+0.734); \n\tmeltRandomPhase.z = Hash(meltCounter+1.384); \n\tmeltRandomPhase.w = Hash(meltCounter+7.821); \n\t\n\tmeltRandomPhase *= 2.0*PI; \n\t\n\t//morphing\n\tfloat introTimeFactor = mix(1.0,min(localTime/INTRO_TIME,1.0),step(0.5,meltCounter));\n\tfloat exitTimeFactor = clamp((localTime-(INTRO_TIME+WAIT_TIME+MELT_TIME))/EXIT_TIME,0.0,1.0);\n\t\n\ticeTransformFactor = smoothstep(0.0,1.0,max(1.0 - introTimeFactor,exitTimeFactor));  \n}\n\n////////////////\n// MORPHOLOGY //\n////////////////\n\n//--------------------------------------------------------------------------\n// IQ exponential smooth min \nfloat SmoothMin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n//--------------------------------------------------------------------------\nvec2 MapIce( in vec3 p , in float mult, in float cryDist)\n{ \n\tvec3 q = p; \n\tq.y += meltHeight;\n\t\n\t//basic cube shape\n\tvec3 iceDimensions = vec3(1.0,1.0,0.5); \n\tvec3 d = abs(q) - iceDimensions;\n\tfloat dist = (min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0))); \n\n\t//Ice basic deformation \n\tdist += meltDeformation*(sin(q.x*2.0+meltRandomPhase.z) + cos(q.y*2.0+meltRandomPhase.w));\n\n\t//water pool shape\n#ifdef POOL_DEFORMATION\n\tfloat angle = atan(p.z,p.x);\n\tfloat waterDistort = sin(angle*3.0+meltRandomPhase.x)+0.3*cos(7.0*angle+meltRandomPhase.y);\n\tfloat radius = meltRadius *(1.0+0.2*waterDistort);\n#else\n\tfloat radius = meltRadius+0.1;\n#endif\n\t\n\tfloat cyl = max(length(p.xz)-radius,abs(p.y + 1.0)-0.005);\n\t\t\n\t//blending them together\n#ifdef USE_SMOOTH_MIN\n\tfloat finalDist = SmoothMin(cyl,dist,meltSmooth); \n\t\n#ifdef USE_SMOOTH_INNER_SHAPE\n\tfinalDist = SmoothMin(finalDist,cryDist+0.5,2.3);\n#endif\n\t\n#else \n\tfloat finalDist = min(cyl,dist);\n#endif\n\t\t\n\t//make the ice spawn from the logo itself\n\tfinalDist = mix(finalDist,cryDist,iceTransformFactor);\n\t\n\treturn vec2(mult*finalDist,2.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 MapBg( in vec3 p)\n{\n\t//background room shape\n\tvec3 q = p; \n\tq.xz = abs(q.xz); \n\treturn vec2(min(min(p.y + 1.0,5.0 - p.y),min(5.0-q.z,5.0-q.x)),1.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 MapCry( in vec3 p )\n{\n\t//rotate the logo\n\tp.xy = vec2(p.x+p.y,p.y-p.x)*sincos45;\n\tvec3 q = abs(p); \n\t\n\t//distance Rounded Box\n\tvec4 dim = vec4(0.54,0.54,0.1,0.02);\n\tfloat boxDist = length(max(q - dim.xyz,vec3(0.0)))-dim.w;\n\t\n\t//distance to Minus Core \n\tfloat sphereDist = length(q.xy + vec2(0.2)) - 0.81;\n\treturn vec2(max(-sphereDist,boxDist),0.0);\n}\n\n//--------------------------------------------------------------------------\nvec2 Map( in vec3 p, in float mult)\n{\n\tvec2 ret = MapCry(p);\n\tvec2 bg = MapBg(p); \n\tvec2 ice = MapIce(p,mult,ret.x);\n\t\n\t//cut the ice on the ground\n\tice.x = max(ice.x,-bg.x);\n\t\t\n\tif (ret.x > bg.x) ret = bg; \n\tif (ret.x > ice.x) ret = ice; \n\treturn ret;\n}\n\n///////////////\n// MATERIALS //\n///////////////\n\n//--------------------------------------------------------------------------\nvec4 BgMaterial(in vec3 pos, in vec3 normal)\n{\n\t//tiled floor\n\tvec2 groundtiles = 2.0*(0.5 - abs(0.5-mod(pos.xz,vec2(1.0)))); \n\tfloat groundtileBorder = smoothstep(0.0,0.1,min(groundtiles.x,groundtiles.y));\n\tvec4 groundColor = mix(vec4(0.15,0.15,0.15,0.02),vec4(0.2,0.2,0.2,0.05),groundtileBorder); \n\t\n\t//Wall Line Light\n\tpos.y -= 4.0; \n\tfloat lightPower = 2.0*pow(smoothstep(1.2,0.0,length(max(abs(pos.xy)-vec2(4.0,0.05),vec2(0.0)))),5.0); \n\tlightPower *= step(EPSILON,-normal.z); \n \tvec4 wallLightColor = vec4(lightPower*lightColor,0.0); \n\t\n\treturn groundColor+wallLightColor;\n}\n\n//--------------------------------------------------------------------------\nvec4 LogoMaterial( in vec3 pos )\n{\n\tvec2 q = vec2(pos.x+pos.y,pos.y-pos.x)*sincos45;\n\t\n\tfloat factorX = step(0.0,q.x); \n\tfloat factorY = step(0.0,q.y); \n\tfloat minusFactorY = 1.0 - factorY; \n\t\n\tvec4 color1 = factorY * vec4(0.2,0.0,0.0,0.2) + minusFactorY * vec4(0.0,0.2,0.0,0.2); \n\tvec4 color2 = factorY * vec4(0.0,0.0,0.2,0.2) + minusFactorY * vec4(0.2,0.2,0.0,0.2); \n\t\t\n\treturn factorX * color1 + (1.0 - factorX) * color2; \t\n}\n\n//--------------------------------------------------------------------------\nvec4 CalcColor( in vec3 pos, in vec3 nor, float material )\n{\n\tvec4 materialColor = vec4(0.0);\n\t\t\n\tif (material < 0.5) materialColor = LogoMaterial( pos ); \n\telse if (material < 1.5) materialColor = BgMaterial( pos, nor );\n\telse materialColor = vec4(0.0,0.1,0.2,0.4);  \n\t\t\n\treturn materialColor;\n}\n\n//////////////////////\n// MAIN RAY/SHADING //\n//////////////////////\n\n//--------------------------------------------------------------------------\nvec2 Intersect( in vec3 ro, in vec3 rd, in float mult)\n{\n\tvec2 res = vec2( 2.0*EPSILON, -1.0);\n    float t = 0.0;\n    for( int i=0; i<MARCHING_STEPS; i++ )\n    {\n\t\tif( res.x<EPSILON ) continue;\n\t\tres = Map( ro+rd*t, mult);\n\t\tt += res.x*STEP_REDUCTION;\n    }\n\tif( res.x>EPSILON ) res.y = -1.0;\n\tres.x = t;\n    return res;\n}\n\n//--------------------------------------------------------------------------\nvec3 CalcNormal( in vec3 pos, in float mult)\n{\n    vec2 eps = vec2(EPSILON,0.0);\n\treturn normalize( \n\t\tvec3( Map(pos+eps.xyy,mult).x - Map(pos-eps.xyy,mult).x, \n\t\t\t  Map(pos+eps.yxy,mult).x - Map(pos-eps.yxy,mult).x, \n\t\t\t  Map(pos+eps.yyx,mult).x - Map(pos-eps.yyx,mult).x) \n\t);\n}\n\n//--------------------------------------------------------------------------\nfloat SoftShadow( in vec3 ro, in vec3 rd, float maxDist, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<40; i++ )\n    {\n\t\tif( t > maxDist ) continue; \n        float h = Map(ro + rd*t,1.0).x;\n        res = min( res, k*h/t );\n        t += h*STEP_REDUCTION;\n    }\n    return clamp(res,0.0,1.0);\n}\n\n//--------------------------------------------------------------------------\n//IQ ray-marched ambient occlusion algorithm \nfloat AmbientOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<8; aoi++ )\n    {\n        float hr = 0.01 + 1.2*pow(float(aoi)/8.0,1.5);\n        vec3 aopos =  nor * hr + pos;\n        float dd = Map( aopos, 1.0 ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.85;\n    }\n    return clamp( 1.0 - 0.6*totao, 0.0, 1.0 );\n}\n\n//--------------------------------------------------------------------------\nvec3 GetLightDir(in vec3 position)\n{\n\t//segment light\n\tfloat lambda = dot(position-lightPos,lightVec.xyz); \n\tvec3 closestLightPos = clamp(lambda,0.0,lightVec.w)*lightVec.xyz+lightPos;\n\t\n\treturn closestLightPos - position; \n}\n\n//--------------------------------------------------------------------------\nvec3 CalcNormalModification(in vec3 position, in vec3 normal, in float materialId)\n{\n#ifdef USE_NORMAL_DEFORMATION\n\t\n\tvec3 dirX = cross(normal,vec3(0.0,0.0,1.0));\n\tvec3 dirXalt = cross(normal, vec3(0.0,1.0,0.0)); \n\tdirX = mix(dirXalt,dirX,step(0.5,length(dirX)));\n\tvec3 dirZ = cross(dirX,normal); \t\n\t\n\tfloat isIce = step(1.5,materialId); \n\tfloat isDistortion = step(0.5,materialId);  \n\t\n\tposition.y += meltHeight*isIce; \n\tfloat dist1 = 0.1*Fbm(vec3(sin(3.0*Fbm(position*2.0)))); \n\tfloat dist2 = 0.05*Fbm(position*3.0);\n\tfloat distort = mix(dist2,dist1,isIce);\n\t\n\treturn isDistortion*(dirX + dirZ)*distort; \n#else \n\treturn vec3(0.0); \n#endif\n}\n\n//--------------------------------------------------------------------------\nvec4 Shade(in vec3 position, in vec3 normal, in float materialId)\n{\n\tif (materialId > -0.5)\n\t{\n\t\t// lights and materials \n\t\tvec4 materialColor \t= CalcColor( position, normal, materialId );\n\t\t\n\t\tfloat ambient  \t\t= 0.7 + 0.3*normal.y;\n\t\tvec3 ambientColor \t= ambient*materialColor.rgb;\n\t\t\t\t\n\t\t//light\n\t\tvec3 lightDir \t= normalize(GetLightDir(position));\t\n\t\tfloat diffuse  = max(dot(normal,lightDir),0.0);\n\t\t\t\n\t\tvec3 diffuseColor = diffuse*lightColor*materialColor.rgb;\n\t\treturn vec4(mix(ambientColor,diffuseColor,0.8),materialColor.w);\n\t}\n\telse\n\t{\n\t\treturn vec4(0.0,0.1,0.15,0.0);\n\t}\n}\n\n//--------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tUpdateWorld();\n\t\n    vec2 puv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    vec2 p = vec2(puv.x * iResolution.x/iResolution.y,puv.y);\n\t\n\t// Compute Camera\t\n\tvec2 mousePos = -1.0 + 2.0 * iMouse.xy/iResolution.xy;\t\n\tfloat camAngle = mousePos.x*PI;\n\t\n    vec3 camPosition = 4.0 * vec3(sin(camAngle), 0.0, cos(camAngle));\n\tcamPosition.y = 2.0+2.0*mousePos.y;\n\t\n    vec3 camTarget\t = vec3( 0.0, 0.0, 0.0 );\n    vec3 camFront \t = normalize( camTarget - camPosition );\n    vec3 camRight \t = normalize( cross(camFront,vec3(0.0,1.0,0.0) ) );\n    vec3 camUp \t\t = normalize( cross(camRight,camFront));\n    vec3 rayDir \t = normalize( p.x*camRight + p.y*camUp + 2.0*camFront );\n\t\n\t// Start Ray\n    vec3 finalcolor = vec3(0.0);\n\tfloat attenuation = 1.0;\n\tfor( int reflectCount=0; reflectCount<NUM_REFLECTIONS; reflectCount++ )\n\t{\t\t\n\t\t// Compute color for single ray\n    \tvec2 tmat = Intersect(camPosition,rayDir,1.0);\t\t\t\n\t\t\n\t\t// results extraction\n\t\tvec3 position \t= camPosition + tmat.x*rayDir;\n\t\tvec3 normal \t= normalize(CalcNormal(position,1.0));\n\t\tnormal += CalcNormalModification(position,normal,tmat.y);\n\t\tnormal = normalize(normal);\n\t\t\n\t\tvec3 reflDir \t= reflect(rayDir,normal);\n\t\t\n\t\tvec4 ilumColor = Shade(position,normal, tmat.y);\n\t\tvec3 innerColor = vec3(0.0);\n\t\t\n\t\tif (tmat.y < -0.5)\n\t\t{\n\t\t\tfinalcolor += attenuation*ilumColor.xyz; \n\t\t}\n\t\telse\n\t\t{\n\t\t\t// refraction \t\t\n\t\t\tif (tmat.y > 1.5)\n\t\t\t{\n\t\t\t\tvec3 refrDir = refract(rayDir, normal, RAFRACTION_FACTOR);\n\t\t\t\tvec3 innerStartPos = position+REFRACT_EPSILON*refrDir; \n\t\t\t\tvec2 refrMat = Intersect(innerStartPos,refrDir,-1.0); \n\t\t\t\t\n\t\t\t\tvec3 innerPos = innerStartPos+refrMat.x*refrDir;\n\t\t\t\tvec3 innerNormal = normalize(CalcNormal(innerPos,-1.0));\t\n\t\t\t\t\n\t\t\t\tif (refrMat.y < 0.5)\n\t\t\t\t{\n\t\t\t\t\tinnerColor = Shade(innerPos,innerNormal,0.0).xyz;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t//getting refracted out of ice again\n\t\t\t\t\tvec3 outerRefrDir = refract(refrDir, innerNormal, INV_RAFRACTION_FACTOR);\n\t\t\t\t\tvec3 outerStartPos = innerPos+REFRACT_EPSILON*outerRefrDir; \n\t\t\t\t\tvec2 outerRefrMat = Intersect(outerStartPos,outerRefrDir,1.0); \n\t\t\t\t\t\n\t\t\t\t\tvec3 outerPos = outerStartPos+outerRefrMat.x*outerRefrDir;\n\t\t\t\t\tvec3 outerNormal = normalize(CalcNormal(outerPos,1.0));\n\t\t\t\t\t\n\t\t\t\t\tinnerColor = Shade(outerPos,outerNormal,outerRefrMat.y).xyz;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tinnerColor *= mix(vec3(0.0,0.5,1.0),vec3(1.0),smoothstep(1.0,0.0,refrMat.x));\n\t\t\t}\n\t\t\t\n\t\t\t//shadow and ambient occlusion\n\t\t\tvec3 lightDir = GetLightDir(position); \n\t\t\tfloat lightDist = length(lightDir); \n\t\t\tfloat shadow = SoftShadow( position, lightDir/lightDist, lightDist, 0.01, 10.0 );\n\t\t\tfloat ao = AmbientOcclusion(position,normal);\t\n\t\t\t\t\t\t\n\t\t\tfinalcolor += attenuation*(0.7+0.3*ao*shadow)*(ilumColor.xyz+innerColor);\n\t\t\t\n\t\t\t// prepare next ray for reflections \n\t\t\tattenuation *= 2.0*ilumColor.w;\n\t\t\trayDir = reflDir;\n\t\t\tcamPosition = position + EPSILON*normal;\n\t\t}\n\t}\n\t\n\t// desaturation, gamma correction and simple vignette\n\tfinalcolor = pow(mix( finalcolor, vec3(dot(finalcolor,vec3(0.33))), 0.3 ), vec3(0.45));\n\tfinalcolor *= mix(1.0,0.0,smoothstep(0.7,2.0,length(puv)));\n\t\n    fragColor = vec4( finalcolor,1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsXSW8","date":"1401814747","viewed":1272,"name":"Frozen Crytek Logo","username":"Ramocles","description":"The Crytek logo inside a melting block of Ice. A quick refraction and blending shapes experiment. Use the mouse to look around. ","likes":29,"published":1,"flags":0,"usePreview":1,"tags":["procedural","3d","raymarching","distancefield","refraction","ice"],"hasliked":0,"parentid":"","parentname":""}}