{"ver":"0.1","info":{"id":"WlXBzH","date":"1595940489","viewed":289,"name":"Sineapple Under The Sea","username":"Flopine","description":"IF IT RUNS SLOW, COMMENT THE LINE 19 (AddSeaweed) \nThis shader was made for a chiptune album cover: https://youtu.be/TSarY-ZmXUY ","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cartoon","modeling","animation","npr","spongebob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n/////////////////////////////////////////////////////////////////////////\n// THIS SHADER WAS MADE FOR A CHIPTUNE ALBUM: Sineapple under the Sea  //\n// https://youtu.be/TSarY-ZmXUY                                        //\n// IF IT RUNS SLOW, COMMENT THE LINE 19 (AddSeaweed)                   //\n/////////////////////////////////////////////////////////////////////////\n\n\n// TOOLBOX //\n#define AddSeaweed\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define ITER 100.\n\n#define BPM (110.0/60.)\n#define time(speed,off) fract(iTime*speed+off)\n#define bouncy(speed,off) sqrt(abs(sin(time(speed,off)*PI))) \n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nstruct bloc\n{\n    float d;\n    vec3 color;\n};\n\nbloc min_struct (bloc a, bloc b)\n{\n    if (a.d<b.d) return a;\n    else return b;\n}\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n/////////////\n\n\n// 2D PROCEDURAL TEXTURE //\nfloat losdist(vec2 uv)\n{\n    uv = abs(uv);\n    return dot(uv,vec2(1.));\n}\n\nfloat grid(vec2 uv)\n{\n    vec2 ga = fract(uv)-.5;\n    vec2 gb = fract(uv-.5)-.5;\n    vec2 guv = (dot(ga,ga)<dot(gb,gb))? ga:gb;\n\n    return clamp(.8-losdist(guv),0.,1.);\n}\n//////////////////////////\n\n\n// 3D BASIC SHAPES //\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat tore (vec3 p, vec2 d)\n{\n    vec2 q = vec2(length(p.xz)-d.x,p.y);\n    return length(q)-d.y;\n}\n\nfloat ellipse( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n/////////////////////\n\n\n// SIGN MODELING //\nfloat part (vec3 p)\n{  \n    float r = 0.2+sin(p.y*(PI/2.)*0.3) * sin(p.y*(PI/2.)*0.3);\n    return cyl(p.xzy, r, 1.);\n}\n\nbloc bb_sign(vec3 p)\n{\n    p *= 2.5;\n    p += vec3(13.,-2.,38.);\n    p.xz *= rot(-PI/2.);\n    p.xy *= rot(PI/10.);\n    vec3 pp = p;\n    p.y += 3.5;\n    float dpole = 1e10;\n    for (int i=0; i<5;i++)\n    {\n        dpole = min(dpole, part(p));\n        p.y -=2.;\n    }\n    bloc pole = bloc (dpole/2.5, vec3(0.3,0.25,0.)); \n\n    p = pp;\n    p.yz += vec2(-1.5, .5);\n    float dlifebelt = tore(p.xzy,vec2(1.6,0.55));\n    bloc lifebelt = bloc(dlifebelt/2.5,vec3(0.8,0.5,0.1));\n    return min_struct(pole, lifebelt);\n}\n/////////////////////\n\n\n// SEAWEED MODELING //\nfloat swdist (vec3 p, float anim)\n{\n    p.x += sin(p.y+anim)*0.2;\n    p *= 0.7;\n    float dseaw = cyl(p.xzy, 0.05-p.y*0.05, 2.);\n    dseaw = min(dseaw,box(p,vec3(0.02,2.,0.15-sin(p.y*4.)*0.1-p.y*0.1))-0.02);\n    return dseaw/0.7;\n}\n\nbloc seaweed (vec3 p)\n{\n    p.y -= 0.7;\n    float per = 1.;\n    p.x = abs(p.x) - 9.5;\n    p.z -= 20.;\n    float id = floor((p.z-20.)/per);\n    float dseaw = 1e10;\n\n    for (float i=0.; i<=40.; i+=per)\n    {\n        dseaw = min(dseaw,swdist(p, time(0.2,id)*TAU));\n        p.z += per;\n    }\n\n    p.y += 2.5;\n    vec3 cseaw = vec3(0.5,0.5+p.y*0.5,0.2)*0.7;\n\n    return bloc(dseaw, cseaw);\n}\n//////////////////////\n\n\n// GROUND MODELING //\nbloc ground (vec3 p)\n{\n    float gsize = 20.;\n    vec3 pp = p;\n    p.y += sin(p.x*(PI/4.)) * sin(p.x*(PI/4.))*0.7;\n    p.y += cos(p.z*(PI/2.)) * sin(p.z*(PI))*0.1;\n    float dsand = max(-box(p,vec3(2.,1.,gsize*1.5)),box(p,vec3(10.,0.5,gsize)));\n    vec3 csand = mix(vec3(0.75,0.8,0.65),vec3(0.6,0.5,0.4),pow(texture(iChannel0,p.xz*0.2).r,7.));\n    bloc sand = bloc(dsand,clamp(csand,0.,1.));\n\n    p = pp;\n    p.y += 0.4;\n    float droad = box(p,vec3(2.,0.3,gsize));\n    vec3 croad = vec3(0.05);\n    bloc road = bloc(droad, croad);\n    return min_struct(sand,road);\n}\n////////////////////\n\n\n// ANCHOR MODELING //\nbloc anchor (vec3 p)\n{\n    p *= 0.5;\n    p += vec3(3.,-0.5,0.5);\n    p.xy *= rot(-0.15);\n    vec3 pp = p;\n    float danch = cyl(pp.xzy, 0.15, 2.);\n\n    pp.y -= 0.9;\n    float c1 = cyl(pp,0.1, 1.);\n    pp.z = abs(pp.z)-1.3;\n    pp.xy *= rot(PI/2.);\n    float t1 = tore(pp, vec2(0.3,0.08));\n    danch = smin(danch,smin(t1,c1,0.1),0.1);\n\n    pp = p;\n    pp.y -= 2.3;\n    pp.xy *= rot(PI/2.);\n    danch = smin(danch, tore(pp, vec2(0.3,0.08)),0.15);\n\n    pp = p;\n    pp.xy *= rot(PI/2.);\n    float a = atan(-pp.z,-pp.x)*length(pp);\n    danch = smin(danch, max(p.y,tore(pp, vec2(2.,0.2-(abs(a))*0.05))),0.1);\n\n    return bloc(danch/0.5, vec3(0.2));\n}\n//////////////////////\n\n\n// CORALS MODELING //\nbloc coral (vec3 p)\n{\n    p *= 1.5;\n    vec3 pp = p;\n    p.x += cos(p.y*2.)*.2;\n    p.z = abs(p.z)-.4;\n    p.z += sin((p.y-0.5)*2.)*0.3;\n    p.yz *= rot(PI/6.);\n\n    float r = 0.2-exp(-sin(p.y*2.))*0.15+.3;\n    float dcor = max((pp.y+pp.z*.4)-.5,abs(cyl(p.xzy,r,1.4))-.05);\n    return bloc(dcor/1.5, vec3(1.,0.3,0.));\n}\n\nbloc corals (vec3 p)\n{\n    vec3 pp = p;\n\n    p += vec3(4.,1.,14.);\n    bloc cs = coral(p);\n\n    p = pp;\n    p += vec3(-8.,1.05,8.);\n    p.xz *= rot(PI/5.);\n    cs = min_struct(cs,coral(p));\n\n    p = pp;\n    p += vec3(-3.,1.5, 0.);\n    p.xz *= rot(-PI/5.);\n    cs = min_struct(cs,coral(p));\n\n    p = pp;\n    p += vec3(4.5,1.05,-3.);\n    cs = min_struct(cs,coral(p));\n\n    p = pp;\n    p += vec3(-7.,1.3, -10.);\n    p.xz *= rot(PI/10.);\n    cs = min_struct(cs,coral(p));\n\n    p = pp;\n    p += vec3(-3.,1.3, -17.);\n    p.xz *= rot(-PI/4.);\n    cs = min_struct(cs,coral(p));\n\n    return cs;\n}\n//////////////////////\n\n\n// PATRICK'S HOUSE MODELING //\nbloc patgir (vec3 p)\n{\n    p.y -= 2.3;\n    p.xy *= rot(PI/2.);\n    float dg = cyl(p.yzx, 0.05, 0.3);\n    p.x -= 0.3;\n    dg = min(dg,cyl(p, 0.05,0.5));\n\n    p.z -= 0.5;\n    p.y = abs(p.y)-0.1;\n    p.yz *= rot(PI/5.);\n    dg = min(dg,cyl(p, 0.05,0.2));\n\n    return bloc(dg,vec3(0.8,0.7,0.1));\n}\n\nbloc pathouse (vec3 p)\n{\n    p *= 0.8;\n    p += vec3(-4.3, 1.7, -3.5);\n    float dhouse = max(-p.y,length(p)-2.);\n\n    return min_struct(bloc(dhouse/0.8,vec3(0.18,0.15,0.1)),patgir(p));\n}\n///////////////////////////////\n\n\nbloc hwindow (vec3 p)\n{\n    float dhw = max(cyl(p, 0.5, 0.1),-cyl(p+vec3(0.,0.,0.1),0.4,0.1));\n    return bloc(dhw,vec3(0.,0.08,.5-length(p)*0.8));\n}\n\n\n// SPONGEBOB'S HOUSE MODELING //\nbloc bobhouse (vec3 p)\n{\n    p += vec3(-4.5,0.1,12.);\n    p.xz *= rot(-PI/2.);\n    vec3 pp = p;\n\n    vec2 puv = vec2(atan(p.z,p.x)*1.5,p.y);\n    bloc dbhouse = bloc(max(-p.y-1.3,ellipse(p,vec3(2., 3.,2.)+grid(puv)*0.3)),vec3(0.9,0.4,0.));\n\n    p += vec3(1.2,-1.,1.7);\n    p.yz *= rot(PI/9.);\n    p.xz *= rot(-PI/5.);\n    dbhouse = min_struct(dbhouse,hwindow(p));\n\n    p = pp;\n    p += vec3(-1.2,-0.2,1.9);\n    p.xz *= rot(PI/5.);\n    dbhouse = min_struct(dbhouse,hwindow(p)); \n\n    p = pp;\n    p.y -= 3.5;\n    p.z -= 0.5;\n    p.z -= sin(p.y)*0.5;\n    mo(p.xz,vec2(0.5+sin(p.y)*0.3));\n    p.x -= 0.4;\n    p.z += 0.5;\n    dbhouse = min_struct(dbhouse, bloc(cyl(p.xzy, 0.3-p.y*0.15, 2.),vec3(0.,1.,0.2)));\n    p.z -= 0.5;\n    dbhouse = min_struct(dbhouse, bloc(cyl(p.xzy, 0.3-p.y*0.15, 2.),vec3(0.3,1.,0.2)));\n\n    return dbhouse;\n}\n/////////////////////////////\n\n\n// SQUIDWARD'S HOUSE MODELING //\nbloc carhouse (vec3 p)\n{\n    p += vec3(-5.,-1.5,4.);\n    p.xz *= rot(PI/10.);\n    vec3 pp = p;\n    float dcarh = cyl(p.xzy, 1.6-p.y*0.05, 3.8);\n\n    p.z = abs(p.z)-2.;\n    dcarh = min(dcarh,box(p,vec3(0.2,1.3,0.5))-0.05);\n\n    p = pp;\n    p.xy += vec2(1.5,-0.2);\n    dcarh = min(dcarh, box(p,vec3(0.3,1.6,0.5-p.y*0.1))-0.05);\n\n    p = pp;\n    p.xy += vec2(1.65,-2.2);\n    dcarh = min(dcarh,box(p,vec3(0.2,0.3,1.5))-0.06);\n\n    bloc face = bloc(dcarh,vec3(0.,0.,0.1));\n    p = pp;\n    p.xy += vec2(1.45,-1.1);\n    p.z = abs(p.z)-0.95;\n    p.xz *= rot(-PI/2.);\n\n    return min_struct(face, hwindow(p));\n}\n////////////////////////////////\n\n\n// ALL SET COMBINED //\nbloc sets (vec3 p)\n{\n    p.z -= 20.;\n    p.z += iTime*1.5;\n    p.z = mod(p.z-20.,40.)-20.;\n    vec3 pp = p;\n\n    bloc cor = corals(p);\n    bloc bbs = bb_sign(p);\n    bloc sw = seaweed(p);\n    bloc anch = anchor(p);\n    bloc patho = pathouse(p);\n    bloc bobho = bloc(bobhouse(p*0.8).d/0.8,bobhouse(p*0.8).color);\n    bloc carho = carhouse(p);\n\n    p.y += 2.;\n    bloc gr = ground(p);\n\n    bloc bset = min_struct(carho,\n                           min_struct(\n                               min_struct(patho,\n                                          bobho),\n                               min_struct(anch,\n                                          min_struct(bbs,\n                                                     gr)\n                                         )\n                           )\n                          );\n\t#ifdef AddSeaweed\n    \tbset = min_struct(bset, sw);\n    #endif\n    bset = min_struct(bset, cor);\n\n    return bset;\n}\n/////////////////////////////\n\n\n// CHARACTER MODELING //\nfloat sx = 0.5, sz = 0.4;\nbloc spongebob (vec3 p)\n{\n    p.x += 1.;\n    bloc feets = bloc(box(p-vec3(0.,bouncy(BPM,0.15),0.),vec3(sx,0.1,sz)),vec3(0.05));\n    bloc pants = bloc(box(p-vec3(0.,0.35+bouncy(BPM,0.1),0.),vec3(sx,0.2,sz)),vec3(0.3,0.25,0.2));\n    bloc shirt = bloc(box(p-vec3(0.,0.75+bouncy(BPM,0.05),0.),vec3(sx,0.15,sz)),vec3(0.9));\n    bloc head = bloc(box(p-vec3(0.,1.55+bouncy(BPM,0.0),0.),vec3(sx,0.6,sz)),vec3(0.7,0.6,0.1));\n    return min_struct(head,min_struct(shirt,min_struct(feets, pants)));\n}\n\nbloc patrick (vec3 p)\n{\n    p.x -= 1.;\n    bloc lowbody = bloc(box(p-vec3(0.,bouncy(BPM,0.10),0.),vec3(sx,0.15,sz)),vec3(0.7,0.2,0.6));\n    bloc pants = bloc(box(p-vec3(0.,0.4+bouncy(BPM,0.05),0.),vec3(sx,0.25,sz)),vec3(0.3,0.8,0.5));\n    bloc upbody = bloc(box(p-vec3(0.,1.4+bouncy(BPM,0.),0.),vec3(sx,0.65,sz)),vec3(0.7,0.2,0.6));\n    return min_struct(upbody,min_struct(lowbody,pants));\n}\n////////////////////////////\n\n\n// ALL SCENE COMBINED //\nbloc SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    p.x += 0.8;\n    vec3 pp = p;\n    bloc se = sets(p);\n\n    p = pp;\n    p.y += 1.7;\n    return min_struct(se,min_struct(patrick(p),spongebob(p)));\n}\n///////////////////////////////\n\n\nvec3 norm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\n\n// MAIN // \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\t\n\n    uv += texNoise(uv*0.2-time(0.05,0.)).r*0.05;\n\n    vec3 ro = vec3(uv*4.5,-100.),\n        rd = normalize(vec3(0.,0.,1.)),\n        p = ro,\n        l = normalize(vec3(-2.,5.,-5.)),\n        col = vec3(0.0,(p.y+p.x*0.5)-5.5, 0.9)*0.7;\n\n    bloc shape;\n    bool hit = false;\n\n\n    for (float i=0.;i<ITER;i++)\n    {\n        shape = SDF(p);\n        if (shape.d<0.01)\n        {\n            hit = true;\n            break;\n        }\n        p += shape.d*rd*0.8;\n    }\n\n    if (hit)\n    {\n        vec3 n = norm(p);\n        col = mix(vec3(0.2,0.6,0.7),shape.color,dot(n,l)*0.5+0.5);\n    }\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}