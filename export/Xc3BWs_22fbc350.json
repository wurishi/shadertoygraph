{"ver":"0.1","info":{"id":"Xc3BWs","date":"1733601000","viewed":28,"name":"Shady Toruses Variation #2","username":"cesio","description":"raymarching, shadow, distortion","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distortion","shadow"],"hasliked":0,"parentid":"4fGcWc","parentname":"Shady, rainy toruses"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define EPSILON 0.0005\n#define MIN_DISTANCE 0.005\n#define MAX_DISTANCE 150. \n#define PRECISION 0.001\n#define MERGE_RADIUS 1.1\n#define MAX_STEPS 155\n\nstruct Material {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float alpha;\n};\n\nMaterial red() {\n  vec3 ambientColor = 0.15 * vec3(0.9, 0., 0.);\n  vec3 diffuseColor = 0.3 * vec3(0.9);\n  vec3 specularColor = 0.99 * vec3(1, 1, 1);\n  float alpha = 15.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial blue() {\n  vec3 ambientColor = 0.15 * vec3(0., 0., 0.9);\n  vec3 diffuseColor = 0.3 * vec3(0.9);\n  vec3 specularColor = 0.99 * vec3(1, 1, 1);\n  float alpha = 15.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\n\n\nMaterial silver() {\n  vec3 ambientColor = 0.45 * vec3(0.8);\n  vec3 diffuseColor = 0.3 * vec3(0.3);\n  vec3 specularColor = 0.9 * vec3(1, 1, 1);\n  float alpha = 5.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n\nMaterial checkboard(vec3 p) {\n  vec3 ambientColor = 0.35 * vec3(0.3 + 1.*mod((floor(p.x) + floor(p.z)) , 2.0));\n  vec3 diffuseColor =  vec3(0.3);\n  vec3 specularColor = vec3(0.2);\n  float alpha = 3.;\n\n  return Material(ambientColor, diffuseColor, specularColor, alpha);\n}\n\nstruct Surface {\n    Material m; // material\n    float d; // distance\n};\n\n// return a distance from point p and a sphere with center c and radius r and tm (transform matrix)\nSurface sdSphere(vec3 p, vec3 c, float r, Material m, mat3 tm) {\n    return Surface(m, length(p  * tm - c) - r);\n}\n    \n    \n// return a distance from a point p and a floow at a height y (height of which the floor starts)\nSurface sdFloor(vec3 p, float y, Material m) {\n    return Surface(m, p.y + y);\n}\n\n// based on  https://iquilezles.org/articles/distfunctions/\n\nSurface sdTorus(vec3 pr, vec2 t, Material m, mat3 tm) {\n  vec3 p = pr * tm;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return Surface(m, length(q)-t.y);\n}\n\n// Euclidean distance function (same as builtin length(p)?)\n// source https://www.shadertoy.com/view/ltyXD3\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\n// Non-Euclidean distance function, so the sphere \"length8(p) = k\" is more squarish.\n// source https://www.shadertoy.com/view/ltyXD3\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\n// A torus with a squarish minor cross section, using non-Euclidean distance function.\n// source https://www.shadertoy.com/view/ltyXD3\nSurface sdTorus82(vec3 pr, vec2 t, Material m, mat3 tm)\n{\n   vec3 p = pr * tm;\n   vec2 q = vec2(length2(p.xz)-t.x,p.y);\n   return Surface(m, length8(q)-t.y);\n}\n\n\nSurface minSurface(Surface s1, Surface s2) {\n    Surface res = s1;\n    if (res.d > s2.d) res = s2;\n    return res;\n}\n\n\nSurface roundMerge(Surface surface1, Surface surface2, float radius) {\n    float item1 = surface1.d;\n    float item2 = surface2.d;\n    \n    vec2 intersection = vec2(item1 - radius, item2 - radius);\n    intersection = min(intersection, 0.0);\n    float insideDistance = -length(intersection);\n    float simpleUnion = min(item1, item2);\n    float outsideDistance = max(simpleUnion, radius);\n    Surface res; res.d = insideDistance + outsideDistance;\n    //res.col = mix(surface1.col, surface2.col, item1-radius);\n    res.m = surface1.m;\n    //res.col = surface1.col;\n    return  res;\n}\n\n\nSurface scene(vec3 pr) {\n    //vec3 p = mod(pr + 0.5 * c, c) - 0.5 * c;\n\n    /*\n    Surface sphere1 = sdSphere(pr + vec3(cos(iTime) * 5.5, 0.0, -5.0), vec3(0.), 1., silver(), identity());\n    Surface sphere2 = sdSphere(pr + vec3(sin(iTime) * 6.5, 0.0, -5.0), vec3(0.), 1., silver(), identity());\n    Surface sphere3 = sdSphere(vec3(pr.x, pr.y + sin(iTime) * 6., pr.z - 5.), vec3(0.), 1., silver(), identity());\n    */\n    //Surface res = roundMerge(sphere1, sphere2, MERGE_RADIUS);\n    //res = roundMerge(res, sphere3, MERGE_RADIUS);\n\n\n    float tR1 = 3.2;\n    Surface torus1 = sdTorus82(vec3(pr.x, pr.y - 2., pr.z - tR1 * 2.), vec2(3.2, 0.2), silver(), rotateY(iTime) * rotateX(PI / 4.) * rotateZ(iTime));\n    Surface torus2 = sdTorus82(vec3(pr.x, pr.y - 2., pr.z - tR1 * 2.), vec2(5.2, 0.2), silver(), rotateX(iTime) * rotateY(PI / 4.) * rotateZ(iTime));\n    Surface torus3 = sdTorus82(vec3(pr.x, pr.y - 2., pr.z - tR1 * 2.), vec2(1.2, 0.2), silver(), rotateX(iTime) * rotateZ(PI / 4.) * rotateY(iTime));\n    Surface res = minSurface(torus1, torus2);\n    res = minSurface(res, torus3);\n    \n    // multiply pattern by mod'uling x,y,z coordinates\n    float cx = 4.;\n    float cy = 0.;\n    float cz = 3.;\n    float nx = cx > 0. ? mod(pr.x + 0.5 * cx, cx) - 0.5 * cx : pr.x;\n    float ny = cy > 0. ? mod(pr.y + 0.5 * cy, cy) - 0.5 * cy : pr.y;\n    float nz = cz > 0. ? mod(pr.z + 0.5 * cz, cz) - 0.5 * cz : pr.z;\n    ny += 1.6 + sin(iTime);\n    vec3 p = vec3(nx, ny, nz);\n    \n    //vec3 p = mod(pr + 0.5 * c, c) - 0.5 * c;\n    //float rX = 45. + sin(iTime) / 5.;\n    \n    Surface sphere1;\n    \n    for (float i = 0.; i < 1.; i += 1.) {\n        if (mod((floor(p.x) + floor(p.z)) , 2.0) > 0.01) {\n            sphere1 = sdSphere(p, vec3(0.), 0.3, red(), identity());\n        } else {\n            sphere1 = sdSphere(p, vec3(0.), 0.3, blue(), identity());\n        }\n        res = minSurface(res, sphere1);\n        p.y += 0.4 + sin(iTime) / 1.2;\n        p.x += 0.8;\n    }\n    \n    \n    Surface sphere2 = sdSphere(pr + vec3(5., 1.0, -2.0), vec3(0.), 1., red(), identity());\n    res = minSurface(res, sphere2);\n\n    Surface sphere3 = sdSphere(pr + vec3(-0.2, -2.0, -6.), vec3(0.), 0.4, red(), identity());\n    res = minSurface(res, sphere3);\n        \n    \n    res = minSurface(res, sdFloor(pr, 2., checkboard(pr)));\n    return res;\n}\n\n\nfloat calcShadow(in vec3 ro, vec3 rd, float softness){ \n    //float t = MIN_DISTANCE; \n    float res = 1.0;\n    float t = 0.;\n   \n    ro += rd * MIN_DISTANCE * 2.;\n        \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        Surface sf = scene(p); \n        \n        if (abs(sf.d) < PRECISION) { // we hit the surface at point p so we have not reached light source\n            return 0.;\n        } else if (sf.d > MAX_DISTANCE) break; // we did not hit anything but are to far away from camera \n        \n        t += sf.d;\n        \n        res = min(res, softness * sf.d / t);\n    }\n        \n    return res;\n}\n\n\n\n// vector normal to sphere with cener c and radius r\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON;\n  return normalize(\n    e.xyy * scene(p + e.xyy).d +\n    e.yyx * scene(p + e.yyx).d +\n    e.yxy * scene(p + e.yxy).d +\n    e.xxx * scene(p + e.xxx).d);\n}\n\n\nstruct RaymarchRes {\n    Surface s;\n    vec3 p; // surface hit point\n    float d; // distance\n};\n\nRaymarchRes raymarch(vec3 ro, vec3 rd) {\n    float t = MIN_DISTANCE; \n    RaymarchRes res;\n    res.d = MAX_DISTANCE;\n        \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        Surface sf = scene(p); \n        t += sf.d;\n        \n        if (sf.d < PRECISION) { // we hit the surface at point p\n            //vec3 normalToSurfaceVector = calcNormal(p);\n            //res.l = clamp(dot(normalToSurfaceVector, normalize(lightVector - p)), 0.1, 1.);\n            res.p = p;\n            res.s = sf;\n            break;\n        } else if (sf.d > MAX_DISTANCE) break; // we did not hit anything but are to far away from camera \n            //t += sf.d; // we did not hit anything, keep on trying\n    }\n    \n    res.d = t;\n    return res;\n}\n    \nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n\n    return mat3(-cr, cu, -cd);\n}\n\n\nvec3 calculateCameraPosition(vec3 lookAt, vec2 uv) {\n    float cameraTime = iTime * 0.8;\n    /*\n    float cameraRadius = 2. * sin(cameraTime) + 4.;\n    vec3 ro; ro.x = cameraRadius * cos(cameraTime) + lookAt.x;\n    ro.y = 0.8;\n    ro.z = cameraRadius * sin(cameraTime) + lookAt.z; \n    \n    ro = vec3(0., 0., -5.);\n    */\n    \n    vec3 ro = vec3(cos(cameraTime) * 4.9 + 1., sin(cameraTime) * 2.2 + 2.1, -5.);\n      \n    return ro;\n}\n\nvec3 calculateLightPosition() {\n    // calculate position of the light\n    float lightTime = iTime * 1.;\n    float lightRadius = 2.;\n    vec3 lightVector;\n    lightVector.x = +2.;//lightRadius * sin(lightTime) * 2.;\n    lightVector.y = -9.2;\n    lightVector.z = 9.;//2. + lightRadius * sin(lightTime); \n    \n    //lightVector = vec3(-2.0, 2.0, 5.0);\n    \n    return lightVector;\n}\n\n/*\n\nvec3 calculateLight(vec2 fragCoord, RaymarchRes rr, vec3 rd, vec3 lo) {\n    vec3 normalToSurfaceVector = calcNormal(rr.p);\n    vec3 l = normalize(lo - rr.p);\n    \n    // phong reclection\n    vec3 diffusion = clamp(dot(l, normalToSurfaceVector), 0., 1.) * rr.s.m.diffuseColor;\n    float dotRV = clamp(dot(reflect(l, normalToSurfaceVector), -rd), 0., 1.);\n    vec3 specular =  pow(dotRV, rr.s.m.alpha) * rr.s.m.specularColor;\n    \n    vec3 color = rr.s.m.ambientColor + diffusion + specular;\n    \n    // vigniete\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color = vec3(color * pow(80. * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.2));\n    \n    return color;\n}\n\n*/\nvec3 calculatePhongLight(vec2 fragCoord, RaymarchRes rr, vec3 rd, vec3 lo) {\n    vec3 normalToSurfaceVector = calcNormal(rr.p);\n    vec3 l = normalize(lo - rr.p);\n    \n    // phong reclection\n    vec3 diffusion = clamp(dot(l, normalToSurfaceVector), 0., 1.) * rr.s.m.diffuseColor;\n    float dotRV = clamp(dot(reflect(l, normalToSurfaceVector), -rd), 0., 1.);\n    vec3 specular =  pow(dotRV, rr.s.m.alpha) * rr.s.m.specularColor;\n    float shadowMask = calcShadow(rr.p, normalize(rr.p - lo), 2.);\n\n    \n    vec3 color = rr.s.m.ambientColor + (diffusion + specular) * shadowMask;\n    \n    // vigniete\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color = vec3(color * pow(20. * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.2));\n    \n    return color;\n}\n\n\nvec3 calculateLight(vec2 fragCoord, RaymarchRes rr, vec3 rd, vec3 lo) {\n    vec3 normalToSurfaceVector = calcNormal(rr.p);\n    vec3 l = normalize(-lo + rr.p); // light direction\n    \n    vec3 diffusion = clamp(dot(l, normalToSurfaceVector), 0., 1.) * rr.s.m.diffuseColor; // diffusion light\n    vec3 newRayOrigin = rr.p + normalToSurfaceVector * PRECISION * 2. ;\n    float dotRV = clamp(dot(reflect(l, normalToSurfaceVector), -rd), 0., 1.);\n    vec3 specular =  pow(dotRV, rr.s.m.alpha) * rr.s.m.specularColor; // specular light\n    float shadowMask = calcShadow(rr.p, normalize(rr.p - lo), 2.3);\n    vec3 color = rr.s.m.ambientColor + specular;\n    color *= diffusion * 45. * shadowMask;\n    \n    \n    // vigniete\n    vec2 q = fragCoord.xy / iResolution.xy;\n    color = vec3(color * pow(20. * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.1)); // vigniete\n    color = mix(color, vec3(0.0,0.0,0.0), 1.0 - exp(-0.00001*rr.d*rr.d*rr.d)); // fog to black\n    \n    return color;\n}\n\n/*\nvec2 calculateRainDropNxM(vec2 p) {\n    float cols = 1.; float rows = 1.; float radius = 0.42; // radius of a droplet\n    vec2 s = p.xy / iResolution.xy;\n\n    float i = floor(s.x * cols);\n    float j = floor(s.y * rows);\n    \n\n   // t += fract(sin(i * 612.1 + j * 822.215) * 525.29) * 13.981;\n\n    vec2 cr = vec2(cols, rows); // how many columns and rows (of droplets)\n    vec2 r = fract(s * cr);\n\n    r -= 0.5; r.y -= 0.5 - radius;\n    r *= iResolution.xy / iResolution.y;\n    r.x *= rows / cols;\n\n    float d1 = smoothstep(radius, 0.,length(r));\n    vec2 bf = vec2(10., 10.);\n    vec2 col = vec2(d1 * r * bf);// + d2 * r2 * bf + d3 * r3 * bf + d4 * r4 * bf);\n    return col;\n}\n*/\n\nvec2 calculateRainDrop(vec2 p) {\n    //float cols = 1.; float rows = 1.; \n    float radius = 0.43; // radius of a droplet\n    vec2 s = p.xy / iResolution.xy;\n\n    float i = floor(s.x);\n    float j = floor(s.y);\n    \n\n   // t += fract(sin(i * 612.1 + j * 822.215) * 525.29) * 13.981;\n\n    //vec2 cr = vec2(cols, rows); // how many columns and rows (of droplets)\n    vec2 r = fract(s);\n\n    r -= 0.5; r.y -= 0.5 - radius;\n    r *= iResolution.xy / iResolution.y;\n    //r.x *= rows / cols;\n\n    float d1 = smoothstep(radius, 0.,length(r));\n    vec2 bf = vec2(20. + 20. * sin(iTime), 20.  + 20. * sin(iTime));\n    vec2 col = vec2(d1 * r * bf);// + d2 * r2 * bf + d3 * r3 * bf + d4 * r4 * bf);\n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 rdd = calculateRainDrop(fragCoord * 1.); // rain drop distortion\n\n\n    vec3 lookAt = vec3(0.0,0., 0.);\n\n    vec3 ro = calculateCameraPosition(lookAt, uv);\n    vec3 rd = camera(ro, lookAt) * normalize(vec3(uv, -1.));\n    rd *= rotateZ(iTime / 3.);\n    vec3 lo = calculateLightPosition();\n\n    //vec4 backgroundColor = vec4(mix(vec3(0., 0.1, .2), vec3(0., 0., 0.), uv.y) * 1.6, 1.0);\n    vec4 backgroundColor = vec4(mix(vec3(0., 0.1, .2), vec3(0., 0., 0.), uv.y) * 1.1, 1.0);\n    //RaymarchRes rr = raymarch(ro, rd);\n    RaymarchRes rr = raymarch(vec3(ro.x - rdd.x, ro.y - rdd.y, ro.z), rd);\n    fragColor = (rr.d < MAX_DISTANCE) ? vec4(calculateLight(fragCoord, rr, rd, lo), 1.0) : backgroundColor;    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n","name":"Common","description":"","type":"common"}]}