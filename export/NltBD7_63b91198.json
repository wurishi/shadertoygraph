{"ver":"0.1","info":{"id":"NltBD7","date":"1663180998","viewed":100,"name":"Linear dithering doesn't matter","username":"stduhpf","description":"follow-up of https://www.shadertoy.com/view/7l3fDn, analyzing the difference linear dithering actually makes\n(not much if there is enough precision)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["dithering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BIT_DEPTH 8\n#define GAMMA 2.2\n\n// Displays the difference between linear dithering (blue/top) vs the usual gamma one (green/middle)\n// the red/bottom one is the quantization without dithering\n\n// The higher the bit depth, and the lower the brightness, the more subtle the difference\n// between linear dithering and naive dithering\n// I can't easily see the difference at 7 bits or more, even in the darkest areas\n    \n// ( WARNING: the resulting image should be really dark, so I normalized the brightness to see it better.\n//   to have it as it displayed as it should, comment following line, and turn up your display brightness)\n#define NORMALIZE_BRIGHTNESS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float eps = 1./iResolution.y;\n    vec2 uv = fragCoord*eps;\n    \n    vec4 noise = texture(iChannel0,(fragCoord)/iChannelResolution[0].xy);\n    //merge channels for better noise precision;\n    noise = noise*255./256.+noise.yzwx*255./(256.*256.);\n    noise+=noise.zwxy/(256.*256.); // the two last channels\n    \n    \n    const float prec = float((1<<BIT_DEPTH)-1); //8-bit color range: 0.->255.\n    \n    float x =uv.x*iResolution.y/iResolution.x;\n    \n    float max_ = .02; // max brightness of the color ramp\n    float max_l = pow(max_,GAMMA); // same thing but in linear\n    \n    float l = max_*(x); //gamma-space value\n    float lin = pow(l,GAMMA); //linear-space value\n    \n    // get quantization \"bounds\"\n    float lfg = floor(l*prec)/prec;\n    float lcg = ceil(l*prec)/prec;\n    \n    // convert bounts to linear\n    float lfl = pow(lfg,GAMMA);\n    float lcl = pow(lcg,GAMMA);\n    \n    float xg = (l  -lfg)/(lcg-lfg); // == fract(l*prec)\n    float xl = (lin-lfl)/(lcl-lfl);\n    \n    //default quantization (causes banding)\n    float q = round(l*prec)/prec;\n    \n    \n    // local average light output from the monitor when using the different methods for ditherings\n    // (lightness of a pixel is proportionnal to its value in linear space)\n    float lq = pow(q,GAMMA);\n    float lg = mix(lfl,lcl,xg);   \n    float ll = mix(lfl,lcl,xl);\n        \n    vec3 light = vec3(lq,lg,ll)/max_l;\n    \n    vec3 dithered = vec3(\n        uv.y*3.<1.?\n            q://uv.y*6.<1.?q:l:  //to compare without quantization (only usefull below 8 bits, or with normalization)\n            uv.y*3.<2.?\n                mix(lfg,lcg,step(noise.x,xg)):\n                mix(lfg,lcg,step(noise.y,xl))\n        ); \n        \n#ifdef NORMALIZE_BRIGHTNESS\n    dithered/=ceil(max_*prec)/prec;\n#endif\n    \n    vec3 f = light;// pow(light,vec3(1.)/GAMMA); //use the pow to see percieved brightness instead of lightness\n    \n    vec3 df = vec3(.5,(dFdx(f)/eps).gb); //ignore red because flat+discontinuities\n    vec3 dist = abs(f-uv.y)/sqrt(df*df+1.);\n    \n    //to simulate a display that is not ideal, the folowing const should have a small (<<1./255), non-zero value\n    //it should be the luminance of a black image divided by the luminance of a white image \n    const float black_brightness = 0.; \n    //perceptual difference, assuming ideal (non-reflective, self emissive) display in a dark environement\n    float ratio = pow((light.g+black_brightness)/(light.b+black_brightness),1./GAMMA)-1.;\n    float dff = dFdx(ratio)/eps;\n    float distf = abs(ratio-uv.y)/sqrt(dff*dff+1.);\n    \n    fragColor = vec4(dithered,0.)\n    +vec4(sqrt(smoothstep(1.5*eps,.5*eps,dist)),1.0) //average lightness of none, gamma and linear ditherings\n    +vec4(sqrt(smoothstep(1.*eps,0.,distf))); //percieved relative brightness difference of gamma vs linear dithering\n}","name":"Image","description":"","type":"image"}]}