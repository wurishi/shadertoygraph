{"ver":"0.1","info":{"id":"7ls3RM","date":"1621809614","viewed":204,"name":"ðŸ§¿ nazar / Õ¡Õ¹Ö„Õ¸Ö‚Õ¬Õ¸Ö‚Õ¶Ö„ ðŸ§¿","username":"gpfault","description":"Nazar / cheshm zakhm, or, as we call it in Armenia, Õ¡Õ¹Ö„Õ¸Ö‚Õ¬Õ¸Ö‚Õ¶Ö„, is a type of amulet meant to ward off the evil eye.\nIt can be found anywhere from the Mediterranean to the Indian subcontinent. https://en.wikipedia.org/wiki/Nazar_(amulet)\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sdf","amulet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*=== TUNABLES === */\nconst float fovDegrees = 60.;\nconst int kMaxRaymarchSteps = 50;\nconst float kRayMarchEps = 0.001;\nconst float kDerivDelta = 0.05;\nconst int kAntiAliasing = 1; /* set to > 1 to enable, high values == worse perf */ \n\n/*=== END OF TUNABLES === */\n\n\n/*=== TRANSFORMS ==*/\nmat4 rotY(float phi) {\n    return mat4(vec4(cos(phi), 0., -sin(phi), 0.),\n                vec4(0., 1., 0., 0.),\n                vec4(sin(phi), 0., cos(phi), 0.),\n                vec4(0., 0., 0., 1.));\n}\n\nmat4 rotX(float phi) {\n    return mat4(vec4(1.,0.,0.,0.),\n                vec4(0.,cos(phi), sin(phi), 0.),\n                vec4(0.,-sin(phi), cos(phi), 0.),\n                vec4(0.,0.,0.,1.));\n}\n\nmat4 translate(vec3 d) {\n    return mat4(vec4(1., 0., 0., 0.),\n                vec4(0., 1., 0., 0.),\n                vec4(0., 0., 1., 0.),\n                vec4(d, 1.));\n}\n\n/*=== TRANSFORMS EOF ===*/\n\n/*=== SDF PRIMITIVES (thanks iq) === */\nvec2 opUnion(vec2 a, vec2 b) {\n return a.x < b.x ? a : b;\n}\n\nvec2 opRevolveZ(vec3 p) {\n    return vec2(length(p.xy), p.z);\n}\n\nvec2 opRevolveY(vec3 p) {\n    return vec2(length(p.xz), p.y);\n}\n\nfloat opSub(float a, float b) {\n    return -a > b ? -a : b;\n}\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n/*=== SDF PRIMITIVES EOF ===*/\n\n/* --------------------------- */\n\n/* distance to img plane for given fov. */\nfloat nearPlaneDist(float fovDegrees) {\n return 1.0 / tan(radians(fovDegrees/2.0));\n}\n\n/* compute primary ray direction for pixel. */\nvec3 ray(vec2 pixel, float fovDegrees) {\n  vec2 uv = pixel / iResolution.xy;\n  uv.y = 1.0 - uv.y;\n  vec2 xy = 2.0 * uv - vec2(1.0);\n  xy.x *= iResolution.x/iResolution.y; /* aspect ratio correction. */\n  return normalize(vec3(xy, nearPlaneDist(fovDegrees)));\n}\n\n/* convert color to approx. nonlinear sRGB. */\nvec4 gammaCorrect(vec3 color) { return vec4(pow(color, vec3(1.0/2.2)), 1.0); }\n\n/* returns color of the surrounding environment. */\nvec3 envColor(vec3 r) {\n    return texture(iChannel1, r*vec3(1.,-1.,1.)).rgb;\n}\n\n/* samples a noise texture, sample point varies depending\n   on time and requested frequency. */\nfloat sampleNoise(float freq) {\n    return texture(iChannel0,\n                   freq * (vec2(sin(iTime),\n                                cos(iTime)) * 0.5 + 0.5)).r;\n}\n\n/* x component of the returned vector is the value of the\n   distance field at the given point.\n   y component is the material of the nearest surface.\n */\nvec2 scene(vec3 p) {    \n    vec2 base =\n        vec2(opSub(sdSphere(p + vec3(0., 2.0, 0.), 0.6),\n                   sdEllipse(opRevolveZ(p), vec2(3.1, 0.5))), 0.0);\n    vec2 string =\n        vec2(sdLink((p+vec3(0., 5.28, 0.)).zyx, 2.6, 0.35, 0.04), 4.);                   \n    vec2 sclera =\n        vec2(\n            sdEllipse(\n                opRevolveZ(p - vec3(0., .45, -.5)),\n                vec2(1.5, 0.2)),\n            1.0);\n\n    /* compute eye rotation matrix. */\n    mat4 eyeRot =\n        rotY(cos(iTime) * 0.25 * sampleNoise(0.12)) *\n        rotX(sin(iTime) * 0.2 * sampleNoise(0.1));\n\n    /* rotate just the iris and pupil (sclera can stay static).*/\n    p = (eyeRot*vec4(p-vec3(0.,.7, 1.0), 1.0)).xyz;\n    vec2 iris =\n        vec2(\n            sdEllipse(\n                opRevolveZ((p - vec3(0.,  .0, -1.92))),\n                vec2(.7, .2)),\n            2.0);\n    float pupil_dilation_factor = sampleNoise(0.1);\n    vec2 pupil =\n        vec2(\n            sdEllipse(\n                opRevolveZ(p - vec3(0.,  .0, -2.1)),\n                vec2(.3 + pupil_dilation_factor*0.1, .1)),\n            3.0);\n            \n\n    return opUnion(string,\n                opUnion(base,\n                    opUnion(sclera,\n                        opUnion(iris, pupil))));\n}\n\n/* compute output color of the surface with the given\n   material and geometric properties. */\nvec3 shade(float mat, vec3 p, vec3 n, vec3 sunDir, vec3 viewDir) {    vec3 h = normalize(n + sunDir);\n\n    vec3 env = envColor(refract(viewDir, n, 0.2));\n    \n    /* default values (\"translucent\" blue base).*/\n    float shininess = 600.0;\n    float envAttn = 0.0;\n    vec3 diffColor = vec3(0.04, 0.03, 1.0) * env;\n    \n    if (mat >= 1.0 && mat < 2.0) {\n        /* white sclera */\n        diffColor = vec3(0.7);\n        shininess = 200.0;\n        envAttn = 0.0;\n    }\n    else if (mat >= 2.0 && mat < 3.0) {\n        /* iris */\n        shininess = 1000.0;\n        diffColor = vec3(0.025, 0.4, 0.5);\n        envAttn = 0.25;\n    }\n    else if (mat >= 3.0 && mat < 4.0) {\n        /* pupil */\n        diffColor = vec3(0.015);\n        shininess = 1000.0;\n        envAttn = 0.025;\n    }\n    else if (mat >= 4.0 && mat < 5.0) {\n        // rope (use Y to generate stripes).\n        diffColor = (sin(p.y*100.)*0.5+0.5)*vec3(0.7, 0.5, 0.1);\n        shininess = 50.0;\n    }\n    float lambert = max(dot(n, sunDir), 0.0);\n    float spec = pow(max(dot(n, h), 0.0), shininess);    \n    return env*envAttn + diffColor*lambert+vec3(spec);\n}\n\n/* gradient of the sdf at point p (normal at surface). */\nvec3 sceneGrad(vec3 p, float d) {\n  return normalize(vec3(d - scene(p - vec3(kDerivDelta, 0., 0.)).x,\n                        d - scene(p - vec3(0., kDerivDelta, 0.)).x,\n                        d - scene(p - vec3(0., 0., kDerivDelta)).x));\n}\n\n/* raymarcher. */\nvec3 marchPrimaryRay(vec3 rd, vec3 ro, int maxSteps, vec3 sunDir, mat4 worldToCameraXform) {\n    float t = 1.;\n    float tmax = 11.9;\n    for (int s = 0; s < kMaxRaymarchSteps && t < tmax; ++s) {\n        vec3 p = (worldToCameraXform * vec4(ro + rd*t, 1.0)).xyz;\n        vec2 sceneData = scene(p);\n        float dist = sceneData.x;\n        if (abs(dist) < kRayMarchEps) {\n            float mat = sceneData.y;\n            vec3 n = sceneGrad(p, dist);\n            vec3 viewDir = normalize((transpose(worldToCameraXform) * vec4(-rd, 0.)).xyz);\n            return shade(mat, p, n, sunDir, viewDir);\n        }\n        t += dist;\n    }\n    return envColor(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /* compute world-to-camera transform. */\n    mat4 worldToCameraXform =\n        rotY(sin(iTime) * 0.5) *\n        translate(vec3(0., 0.,-10.));\n        \n    /* compute sun direction in view space. */\n    vec3 sunDirViewSpace =\n        normalize((worldToCameraXform * vec4(0.00, -1.0, -1.5, 0.0)).xyz);\n    \n    /* generate and march ray. */\n    vec3 color = vec3(0.);\n    for (int p = 0; p < kAntiAliasing; ++p) {\n        for (int q = 0; q < kAntiAliasing; ++q) {\n            vec2 subpixel = vec2(float(p), float(q));\n            vec2 pixelSize = vec2(float(kAntiAliasing));\n            vec2 offs = 0.5 * subpixel / pixelSize - 0.5;\n            vec3 r = ray(fragCoord + offs, fovDegrees);\n            color += marchPrimaryRay(r, vec3(0.0), 0, sunDirViewSpace, worldToCameraXform);\n        }\n    }\n    color /= float(kAntiAliasing*kAntiAliasing);\n    \n    /* write out gamma-corrected color of the pixel. */\n    fragColor = gammaCorrect(color);\n}","name":"Image","description":"","type":"image"}]}