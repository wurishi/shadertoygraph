{"ver":"0.1","info":{"id":"4lSBzw","date":"1528243423","viewed":232,"name":"binary tree structure","username":"tylerbata","description":"Visualize a binary tree.  Attempting to create a tree.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["tree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec4 rand(float x) {\n    return texture( iChannel0, vec2(x, float(int(x/256.0)) + 0.5) );\n}\n\nfloat sdCircle( vec2 p, float s ) {\n    return length(p)-s;\n}\n\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nfloat LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {\n    // Don't let it get more round than circular.\n    rounded = min(thick.y, rounded);\n    // midpoint\n    vec2 mid = (pB + pA) * 0.5;\n    // vector from point A to B\n    vec2 delta = pB - pA;\n    // Distance between endpoints\n    float lenD = length(delta);\n    // unit vector pointing in the line's direction\n    vec2 unit = delta / lenD;\n    // Check for when line endpoints are the same\n    if (lenD < 0.0001) unit = vec2(1.0, 0.0);\t// if pA and pB are same\n    // Perpendicular vector to unit - also length 1.0\n    vec2 perp = unit.yx * vec2(-1.0, 1.0);\n    // position along line from midpoint\n    float dpx = dot(unit, uv - mid);\n    // distance away from line at a right angle\n    float dpy = dot(perp, uv - mid);\n    // Make a distance function that is 0 at the transition from black to white\n    float disty = abs(dpy) - thick.y + rounded;\n    float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;\n\n    // Too tired to remember what this does. Something like rounded endpoints for distance function.\n    float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;\n    dist = min(dist, max(distx, disty));\n\n\n    return dist;\n}\n\n// This makes a filled line in pixel units. A 1.0 thick line will be 1 pixel thick.\nfloat line(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {\n    float scale = dFdy(uv).y;\n    thick = (thick * 0.5 - 0.5) * scale;\n    float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);\n    return saturate(df / scale);\n}\n\n\n\nfloat tree(vec2 p, vec2 start, vec2 dim, int maxSteps) {\n    \n    vec2 samp = start;\n    float d = 100.0;\n    float delta = dim.x;\n    for(int i = 0; i < maxSteps; i++) {\n        vec2 oldSamp = samp;\n        delta *= 0.5;\n        if(p.x > samp.x)\n            samp.x += delta;\n        else\n            samp.x -= delta;\n        samp.y += dim.y / float(maxSteps);\n        d = min(d,line(p, oldSamp, samp, vec2(2.0), 0.0));\n    }\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    float t = tree(uv, vec2(0.5,0.0), mouse, 6);\n    \n    //t = line(uv, vec2(0.0), mouse, vec2(5.0), 0.0);\n    \n    \n    vec3 col = vec3(uv,0.5+0.5*sin(iTime));\n    if(t <= 0.0)col = vec3(1.0);\n    \n    \n    \n    \n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}