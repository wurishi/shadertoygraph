{"ver":"0.1","info":{"id":"cst3Wr","date":"1677168513","viewed":59,"name":"Raymarch demo","username":"JoeAN","description":"Raymarch demo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Compute uv\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n    // Compute small spheres positions\n    vec3 spherePos1 = mix(\n        vec3(5., 5., 0.), \n        vec3(0), \n        pow(sawtooth(iTime * .5), .5)\n    );\n    \n    vec3 spherePos2 = mix(\n        vec3(5., -5., 0.), \n        vec3(0), \n        pow(sawtooth(iTime * .5), .7)\n    );\n    \n    vec3 spherePos3 = mix(\n        vec3(-5., 5., 0.), \n        vec3(0), \n        pow(sawtooth(iTime * .5), .3)\n    );\n    \n    vec3 spherePos4 = mix(\n        vec3(-5., -5., 0.), \n        vec3(0), \n        pow(sawtooth(iTime * .5), .4)\n    );\n\n    // Populate sphere array\n    Sphere[] spheres = Sphere[] (\n        Sphere(vec3(0), 1., vec3(0, 1, 1)),\n        Sphere(spherePos1, 0.5, vec3(1, 0, 1)),\n        Sphere(spherePos2, 0.5, vec3(1, 0, 1)),\n        Sphere(spherePos3, 0.5, vec3(1, 0, 1)),\n        Sphere(spherePos4, 0.5, vec3(1, 0, 1))\n    );\n    \n    // Compute rotating ray origin and direction\n    vec3 rayPos =  vec3(0, 0, 0);\n    float xzOffset = mix(5., 5.5, sin(iTime));\n    rayPos.x = xzOffset * cos(iTime);\n    rayPos.z = xzOffset * sin(iTime);\n    \n    Ray ray = Ray(rayPos, lookAt(rayPos, vec3(0)) * vec3(uv, 1));\n    \n    // Raymarch\n    vec3 resultantColor = raymarchSphere(ray, spheres, uv.y + .35);\n\n    // Color output\n    fragColor = vec4(resultantColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Const variables\nconst int MAX_STEPS = 32;\nconst float MINIMUM_HIT_DISTANCE = 0.001;\nconst float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n// Structs\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec3 color;\n};\n\n// Global scope variables\nvec3 lightDir = vec3(-.5, 1, -1);\n\n// Global scope functions\nfloat sdfSphere(in vec3 p, Sphere s) {\n\treturn length(p - s.position) - s.radius;\n}\n\nfloat smin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2-d1)/k, 0., 1.);\n    return mix(d2, d1, h) - k*h*(1. - h);\n}\n\nfloat sawtooth(float x) {\n    return x - floor(x);\n}\n\nfloat rand(vec2 co) { // See https://stackoverflow.com/questions/12964279/whats-the-origin-of-this-glsl-rand-one-liner\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 randPos(vec2 v, float radius) {\n    return vec2(rand(v), rand(v)) * radius;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\nmat3 lookAt(vec3 position, vec3 target) {\n\tvec3 forward = normalize(target - position);\n\tvec3 right = normalize(cross(vec3(0, 1, 0), forward));\n\tvec3 up = normalize(cross(forward, right));\n\t\n\treturn mat3(right, up, forward);\n}\n\nvec3 raymarchSphere(Ray r, Sphere[5] spheres, float v) {\n    float traveledDist = 0.;\n    for (int i = 0; i < MAX_STEPS; ++i) {\n        // Compute current position\n        vec3 currPos = r.origin + traveledDist * r.direction;\n\n        // Compute SDF\n        float closestDist = sdfSphere(currPos, spheres[0]);\n        for (int i = 0; i < 5; i++) {\n            closestDist = smin(closestDist, sdfSphere(currPos, spheres[i]), .5);\n        }\n\n        // Hit\n        if (closestDist < MINIMUM_HIT_DISTANCE) {\n            return vec3(0.976, 0.886, 0.745);\n        }\n\n        // Miss\n        if (traveledDist > MAXIMUM_TRACE_DISTANCE) {\n            break;\n        }\n\n        // Increment traveled distance\n        traveledDist += closestDist;\n    }\n\n    // Exceeded max steps, sample background\n    return mix(vec3(1, 1, 0), vec3(1, 0, 1), v);\n}","name":"Common","description":"","type":"common"}]}