{"ver":"0.1","info":{"id":"Ds2GWd","date":"1668350594","viewed":282,"name":"1-Loop Fractal [210 Chars]","username":"Xor","description":"I found an interesting method for combining fractals with the raymarcher loop.","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["golf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"1-Loop Fractal\" by @XorDev\n    \n    I found an interesting method for combining fractals with the raymarcher loop.\n    The trick is to raymarch a different octave every \"x\" steps.\n    If you want 7 octaves, then you raymarch using the SDF of the first octave,\n    then the second, then the third and so on.\n    \n    So each raymarch step, you're only considering one octave at a time, but surprisingly,\n    it's good enough for the fractals I tested with.\n    \n    I assume it wouldn't work with some types of fractals, but I'll leave that for another day.\n    \n    <300 chars playlist: https://www.shadertoy.com/playlist/fXlGDN\n*/\nvoid mainImage( out vec4 O, vec2 I)\n{\n    //Resolution for scaling\n    vec3 r = iResolution,\n    //Move along z-axis\n    p = iTime/r/r;\n    \n    //Initialize iteration variables\n    for(float i=0.,j;\n        //Loop 300 times\n        i++<3e2;\n        //Raymarch forward on each fractal octave\n        p -= vec3(round(I)*2.-r.xy,r)/r.x * (length(max(abs(sin(p*j))-.6,0.))-.4)/j )\n        //Loop through 7 octaves ever 7 steps\n        j = exp(mod(i, 7.));\n    \n    //Use derivatives for cheap lighting\n    O = 4. / length(fwidth(p)) / r.yyyy;\n}","name":"Image","description":"","type":"image"}]}