{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// View IQ's clouds demo, through a letter-pi-shaped viewport.\n// For Pi Day, Mar. 14, 2013\n// Pi is illustrated by the ratio of the blue line\n// to the red line.\n\n// Uses techniques similar to Ika-chan (https://www.shadertoy.com/view/lssGRn)\n// except not as sophisticated, for outlining the shape of the letter pi.\n\t\t\t\t\t\t\t\t\t  \n// To get the pi shape, could use the svg path from\n// http://commons.wikimedia.org/wiki/File:Greek_letter_pi_serif%2Bsans.svg\n// (use the second part of the first path, after the z M).\n// But that would require some complex hit-testing code.\n// Maybe I can just do it with rectangles and circles\n// (positive and negative).\n\n// TODO: AA the edges of the letter pi. Make the hit testing functions return a float.\n\n// TODO: make the outline fancier\n\n\t\n// Cloud demo created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 p;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p ) {\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n\nvec4 map( in vec3 p ) {\n\tfloat d = 0.2 - p.y;\n\n\td += 3.0 * fbm( p*1.0 - vec3(1.0,0.1,0.0)*iTime );\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\tvec4 res = vec4( d );\n\n\tres.xyz = mix( 1.15*vec3(1.0,0.95,0.8), vec3(0.7,0.7,0.7), res.x );\n\t\n\treturn res;\n}\n\n\nvec3 sundir = vec3(-1.0,0.0,0.0);\n\n\nvec4 raymarch( in vec3 ro, in vec3 rd ) {\n\tvec4 sum = vec4(0, 0, 0, 0);\n\n\tfloat t = 0.0;\n\tfor(int i=0; i<44; i++)\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = map( pos );\n\t\t\n\t\t#if 1\n\t\tfloat dif =  clamp((col.w - map(pos+0.3*sundir).w)/0.6, 0.0, 1.0 );\n\n        vec3 brdf = vec3(0.65,0.68,0.7)*1.35 + 0.45*vec3(0.7, 0.5, 0.3)*dif;\n\t\tcol.xyz *= brdf;\n\t\t#endif\n\t\t\n\t\tcol.a *= 0.35;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\t//if (sum.a > 0.99) break;\n        #if 0\n\t\tt += 0.1;\n\t\t#else\n\t\tt += max(0.1,0.05*t);\n\t\t#endif\n\t}\n\n\tsum.xyz /= (0.001+sum.w);\n\n\treturn clamp( sum, 0.0, 1.0 );\n}\n\n\nbool inCircle(vec2 c, float r) {\n\treturn (distance(p, c) <= r);\n}\n\n// c1 is lower-left corner of rectangle;\n// c2 is upper-right corner.\nbool inRect(vec2 c1, vec2 c2) {\n\treturn (p.x >= c1.x && p.y >= c1.y &&\n\t\tp.x <= c2.x && p.y <= c2.y);\n}\n\nconst float bot = -0.6, top = 0.8, left = -0.7, right = 0.71;\n\nbool inViewport() {\n\treturn (\n\t\t// top bar\n\t\tinRect(vec2(left, 0.4), vec2(right, top)) ||\n\t\t// top left quarter circle\n\t\t(inCircle(vec2(left, 0.4) , 0.4) && p.y > 0.4) ||\n\t\t// top right quarter circle\n\t\t(inCircle(vec2(right, 0.8), 0.4) && p.y < top) ||\n\t\t// left leg\n\t\tinRect(vec2(-0.65, bot), vec2(-0.25, 0.4)) ||\n\t\t// right leg\n\t\tinRect(vec2(0.25, bot), vec2(0.65, 0.4)) ||\n\t\tinCircle(vec2(-0.5, bot), 0.25) ||\n\t\tinCircle(vec2( 0.5, bot), 0.25) \n\t);\n}\n\nconst float r = 0.25;\nconst float linethick = 0.015;\nconst float linetop = top - r, mid = (linetop + bot) * 0.5;\n\nconst vec2 start = vec2(left - r - 0.45, bot);\nconst vec3 circumcol = vec3(0.8, 0.2, 0.2), gray = vec3(0.25),\n\tblue = vec3(0.4, 0.4, 0.8);\n\nconst float pi = 3.1415926535897932384626433; // Hooray!\n\n/*\n// antialias coefficient\n#define aa(d) ((linethick - (d)) / linethick)\n*/\nfloat aa(float d) {\n\treturn (linethick - d) / linethick;\n}\n\nvec3 piDemo(vec2 p) {\n\tfloat d; // distance from various things\n\tbool onLine = false;\n\tfloat t = sin(iTime); // -1 to 1\n\tt = sign(t) * sqrt(abs(t)); // spend more time near the ends\n\t\n\t// center of rolling circle\n\tvec2 c = vec2(start.x - r, t * (linetop - bot) * 0.5 + mid);\n\t\n\t// vertical line - red\n\td = abs(p.x - start.x);\n\tif (d < linethick && p.y > start.y && p.y < top - r) {\n\t\tonLine = true;\n\t\t// above circle?\n\t\tif (p.y > c.y)\n\t\t\treturn circumcol * aa(d);\n\t}\n\n\t// length of \"string\" below circle's tangent point\n\tfloat len = (t + 1.0) * 0.5; // map t to 0..1 range\n\t\n\t// rolling circle\n\td = distance(p, c);\n\tif (d < r + linethick) {\n\t\t// angle to current pixel from center of circle\n\t\tfloat a = atan(p.y - c.y, p.x - c.x);\n\t\t// put into range 0 to 2pi\n\t\tif (a < 0.0) a += pi * 2.0;\n\t\t// angle interval that string wraps to\n\t\tfloat wrapa = (1.0 - len) * 2.0 * pi;\n\t\t\n\t\t// on circumference?\n\t\tif (abs(d - r) < linethick) {\n\t\t\tif (a > wrapa)\n\t\t\t\treturn circumcol * aa(abs(d - r));\n\t\t\telse return gray * aa(abs(d - r));\n\t\t}\n\t\t\n\t\t// on diameter?\n\t\tif (d < r) {\n\t\t\tfloat dd = abs(sin(wrapa - a) * d);\n\t\t\tif (dd < linethick) {\n\t\t\t\treturn blue * aa(dd);\n\t\t\t} else {\n\t\t\t\t// shouldn't be necessary\n\t\t\t\treturn vec3(0.0);\n\t\t\t}\n\n\t\t}\n\t}\n\n\t// vertical line, gray below circle\n\tif (onLine) {\n\t\treturn gray * aa(abs(p.x - start.x));\n\t}\n\n\treturn vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\tp.x -= 0.3;\n\n\tif (!inViewport()) {\n\t\tfragColor = vec4(piDemo(p).xyz, 1.0);\n\t\treturn;\n\t}\n\t\t\n    vec2 mo = -1.0 + 2.0 * iMouse.xy / iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(cos(2.75-3.0*mo.x), 0.7+(mo.y+1.0), sin(2.75-3.0*mo.x)));\n\tvec3 ta = vec3(0.0, 1.0, 0.0);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n\t\n    vec4 res = raymarch( ro, rd );\n\n\tfloat sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.6,0.71,0.75) - rd.y*0.2*vec3(1.0,0.5,1.0) + 0.15*0.5;\n\tcol += 0.2*vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\tcol = mix( col, res.xyz, res.w );\n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 );\n\t    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsfGz4","date":"1363302480","viewed":351,"name":"Sky in the Pi","username":"huttarl","description":"Something fun for Pi Day (Mar. 14) 2012.\nPi is illustrated by the ratio of the red line to the blue line.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pi","fun"],"hasliked":0,"parentid":"","parentname":""}}