{"ver":"0.1","info":{"id":"fsdfDB","date":"1657135166","viewed":341,"name":"Prick 1","username":"tskj","description":"Physically Based Rendering test with homemade DOF","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["dof","hdr","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nvec3 u_cam_pos = vec3(0.0, 5.0, 80.0);\nfloat u_cam_phi = -0.02;\nfloat u_cam_theta = 0.005;\n\nfloat u_focalDistance = 80.0;\nfloat u_focalLength = 0.200; // 200mm\nfloat u_f_stop = 0.4;\n\nint u_use_dof = 1;\n\n#define SAMPLES 10\nvec2 u_samples[SAMPLES] = vec2[](\n    vec2(0.8969641541326401, 0.43020032713100775),\n    vec2(0.2012734369685738, 0.8381241041314147),\n    vec2(-0.8590357115225253, 0.42331528915068306),\n    vec2(-0.2316680127652595, 0.8904722913703189),\n    vec2(-0.3200932347547254, 0.12793141237496597),\n    vec2(-0.2987539888057733, -0.809767049555127),\n    vec2(-0.8576949675385284, -0.20600620214070142),\n    vec2(0.41290266759079586, -0.08106380910217448),\n    vec2(0.2547714128777887, -0.7490837674203279),\n    vec2(0.974227155408717, -0.15682364050146402)\n);\n\n\n#define SUB_PIXEL_SAMPLING 1\n#define BOUNCES 1\n\n#define MAX_STEPS 1000\n#define SURFACE_EPSILON .001\n#define RENDER_DISTANCE 100.\n\n#define PI 3.1415926535897932384626433832795\n\nmat2 rot(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat max3(vec3 v) {\n  return max(max(v.x, v.y), v.z);\n}\n\nfloat sminCubic( float a, float b, float k ) {\n  float h = max( k-abs(a-b), 0.0 ) / k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat clamp1(float n) {\n  return clamp(n, 0., 1.);\n}\n\n\nfloat sphere(vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat placeSphere(vec3 p, float x, float y, float z, float radius) {\n  return sphere(p - vec3(x, y, z), radius);\n}\n\nfloat box(vec3 p, vec3 dimensions) {\n  vec3 q = abs(p) - dimensions;\n  return length(max(q, vec3(0))) + min(max3(q), 0.);\n}\n\nfloat placeBox(vec3 p, float x, float y, float z, vec3 dim) {\n  return box(p - vec3(x, y, z), dim);\n}\n\nfloat capsule(vec3 p, float L, float R) {\n  p.y -= min(L, max(0.0, p.y));\n  return length(p) - R;\n}\n\nfloat placeCapsule(vec3 p, float x, float y, float z, float l, float r) {\n  return capsule(p - vec3(x,y,z), l, r);\n}\n\nfloat plane(vec3 p, vec3 v, vec3 n) {\n  return dot(p - v, n);\n}\n\nfloat subtract(float a, float b) {\n  return max(a, -b);\n}\n\nfloat d;\n\nfloat junk(vec3 p) {\n  /*\n  float bounding = placeCapsule(p, 0., 0.5, 0., 5., 2.);\n  if (bounding > d) {\n    return d;\n  }\n  */\n\n  float s1 = placeSphere(p, 0., 1., 1., 1.);\n  float s2 = placeSphere(p, -1., 1., 0.5, 1.);\n  float balls = sminCubic(s1, s2, 0.5);\n\n  float shaft = placeCapsule(p, 0., 2., 0., 3., 1.);\n  shaft += sin(p.y * 1.6-0.2) / 30.;\n\n  float glans = sminCubic(placeSphere(p, -0.2, 5.5, 0.1, 0.8)\n  , placeSphere(p, 0.1, 5.5, 0.2, 0.8), 0.05);\n\n  float penis = sminCubic(glans, shaft, 0.5);\n  float junk = sminCubic(penis, balls, 0.5);\n\n  float base = placeSphere(p, -0.2, 1.2, 0.2, 1.2);\n\n  return sminCubic(junk, base, 0.5);\n}\n\nfloat sdf(vec3 p) {\n  float p1 = plane(p, vec3(0), vec3(0, 1, 0));\n\n  d = RENDER_DISTANCE;\n\n  d = min(d, p1);\n\n  d = min(d, placeBox(p, 4.5, 0.5, 1., vec3(3., 0.5, 2.)) - .01);\n  d = min(d, plane(p, vec3(0,0,-15), vec3(0,0,1)));\n\n  d = min(d, junk(p - vec3(-1.-0., 0., -7.-5.)));\n\n  vec3 j2 = p - vec3(5.2, 1.0, 1.0);\n  j2.xz *= rot(1.);\n  d = min(d, junk(j2));\n\n  j2 = p - vec3(3., 0.0, 4.0);\n  j2.xz *= rot(0.7);\n  d = min(d, junk(j2));\n\n  j2 = p - vec3(0.5, 0.0, 3.0);\n  j2.xz *= rot(0.2);\n  d = min(d, junk(j2));\n\n  j2 = p - vec3(-3., 0.0, 15.0);\n  j2.xz *= rot(-1.7);\n  d = min(d, junk(j2));\n\n  j2 = p - vec3(3.5, 0.0, 20.0);\n  j2.xz *= rot(1.7);\n  d = min(d, junk(j2));\n\n  return d;\n}\n\nstruct Material {\n  float metalness;\n  float roughness;\n  vec3 color;\n};\nstruct MaterialDistance {\n  float d;\n  Material material;\n};\n\nMaterialDistance minMat(MaterialDistance md, float newDist, Material mat) {\n  if (newDist <= md.d) {\n    d = min(d, newDist);\n    return MaterialDistance(newDist, mat);\n  }\n  return md;\n}\n\nMaterialDistance getMaterial(vec3 p) {\n  Material sky = Material(0.001, 0.9, vec3(1.));\n\n  Material diff = Material(0.001, 0.9, vec3(0.2));\n  Material turkis = Material(0.001, 0.05, vec3(0.10, 0.20, 0.2));\n\n  Material red_metal = Material(0.5, 0.1, vec3(0.2, 0.01, 0.01));\n\n  Material black_metal = Material(1.0, 0.1, vec3(0.1, 0.04, 0.1));\n\n  Material blue = Material(0.001, 0.9, vec3(0.00, 0.02, 0.2) * 2.);\n  Material smth = Material(0.001, 0.5, vec3(0.22, 0.215, 0.2));\n\n  Material brushed_metal = Material(0.99, 0.5, vec3(0.19, 0.10, 0.05));\n\n  d = RENDER_DISTANCE;\n\n  float p1 = plane(p, vec3(0), vec3(0, 1, 0));\n\n  MaterialDistance d = minMat(MaterialDistance(RENDER_DISTANCE, sky), p1, diff);\n\n  d = minMat(d, placeBox(p, 4.5, 0.5, 1., vec3(3., 0.5, 2.)) - .01, diff);\n  d = minMat(d, plane(p, vec3(0,0,-15), vec3(0,0,1)), diff);\n\n  d = minMat(d, junk(p - vec3(-1.-0., 0., -7.-5.)), smth);\n\n  vec3 j2 = p - vec3(5.2, 1.0, 1.0);\n  j2.xz *= rot(1.);\n  d = minMat(d, junk(j2), black_metal);\n\n  j2 = p - vec3(3., 0.0, 4.0);\n  j2.xz *= rot(0.7);\n  d = minMat(d, junk(j2), turkis);\n\n  j2 = p - vec3(0.5, 0.0, 3.0);\n  j2.xz *= rot(0.2);\n  d = minMat(d, junk(j2), red_metal);\n\n  j2 = p - vec3(-3., 0.0, 15.0);\n  j2.xz *= rot(-1.7);\n  d = minMat(d, junk(j2), blue);\n\n  j2 = p - vec3(3.5, 0.0, 20.0);\n  j2.xz *= rot(1.7);\n  d = minMat(d, junk(j2), brushed_metal);\n\n  return d;\n}\n\n#define EPS_GRAD 0.001\nvec3 getNormal(vec3 p) {\n  vec3 p_x_p = p + vec3(EPS_GRAD, 0, 0);\n  vec3 p_x_m = p - vec3(EPS_GRAD, 0, 0);\n  vec3 p_y_p = p + vec3(0, EPS_GRAD, 0);\n  vec3 p_y_m = p - vec3(0, EPS_GRAD, 0);\n  vec3 p_z_p = p + vec3(0, 0, EPS_GRAD);\n  vec3 p_z_m = p - vec3(0, 0, EPS_GRAD);\n\n  float sdf_x_p = sdf(p_x_p);\n  float sdf_x_m = sdf(p_x_m);\n  float sdf_y_p = sdf(p_y_p);\n  float sdf_y_m = sdf(p_y_m);\n  float sdf_z_p = sdf(p_z_p);\n  float sdf_z_m = sdf(p_z_m);\n\n  return normalize(vec3(sdf_x_p - sdf_x_m\n  ,sdf_y_p - sdf_y_m\n  ,sdf_z_p - sdf_z_m)/(2.*EPS_GRAD));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float max_march_dist) {\n\n  float t = 0.0;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + t * rd;\n\n    float d = sdf(p);\n    t += d;\n\n    if (abs(d) < SURFACE_EPSILON || t >= max_march_dist) {\n      break;\n    }\n  }\n\n  return t;\n}\n\nfloat lightMarch(vec3 ro, vec3 rd, float max_march_dist) {\n  float spread = 100.;\n\n  float intensity = 1.0;\n  float dh = 1e20;\n\n  float t = 0.0;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + t * rd;\n\n    float d = sdf(p);\n\n    if (abs(d) < SURFACE_EPSILON) {\n      return 0.0;\n    }\n\n    float y = d * d / (2.0 * dh);\n    float triangulation = sqrt(d * d - y * y);\n\n    intensity = min( intensity, spread * triangulation / max(0.0, t - y) );\n\n    dh = d;\n    t += d;\n\n    if (t >= max_march_dist) {\n      break;\n    }\n  }\n\n  return intensity;\n}\n\nfloat getOcclusion(vec3 p, vec3 n) {\n  float occlusion = 1.0;\n\n  float step_dist = 0.035 * 2.0;\n  for (float step_nbr = 10.; step_nbr > 0.0; step_nbr--) {\n    occlusion -= pow(step_nbr * step_dist - sdf(p + n * step_nbr * step_dist), 2.0) / step_nbr;\n  }\n\n  return occlusion;\n}\n\nvec3 getAmbience(vec3 p, vec3 n) {\n  vec3 ambience = vec3(0.0);\n\n  float step_dist = 0.035 * 2.0;\n  for (float step_nbr = 10.; step_nbr > 0.0; step_nbr--) {\n    MaterialDistance material = getMaterial(p + n * step_nbr * step_dist);\n    ambience += material.material.color * pow(step_nbr * step_dist - material.d, 2.0) / step_nbr;\n  }\n\n  return ambience;\n}\n\n// Fresnel-Schlick approximation\nvec3 fresnel(vec3 v, vec3 l, vec3 F0) {\n  vec3 h = normalize(l + v);\n  float hv = max(dot(h,v), 0.0);\n  return F0 + (1. - F0) * pow(1.000001 - hv, 5.0);\n}\n\n// GGX distribution function\nfloat normalDistributionFunction(vec3 n, vec3 v, vec3 l, float roughness) {\n  float a = roughness * roughness;\n  vec3 h = normalize(l + v);\n  float nh = max(dot(n,h), 0.0);\n  float nh2 = nh * nh;\n  float a2 = a * a;\n  return a2 / (PI * pow(nh2 * (a2 - 1.0) + 1.0, 2.0));\n}\n\n// Schlick-GGX approximation\nfloat geometricFunction(vec3 n, vec3 dir, float roughness) {\n  float d = max(dot(n,dir), 0.0);\n\n  float r = roughness + 1.0;\n  float k = r * r / 8.0;\n\n  return d / (d * (1. - k) + k);\n}\n\nfloat spec(float roughness, vec3 n, vec3 v, vec3 l) {\n  float numerator = normalDistributionFunction(n, v, l, roughness)\n                  * geometricFunction(n, v, roughness)\n                  * geometricFunction(n, l, roughness);\n\n  float nl = max(dot(n,l), 0.0);\n  float nv = max(dot(n,v), 0.0);\n\n  float denomniator = 4. * nl * nv + 0.00001;\n\n  return numerator / denomniator;\n}\n\nvec3 pbr(float metallicness, float roughness, vec3 color, vec3 n, vec3 v, vec3 l) {\n  vec3 F0 = mix(vec3(0.04), color, metallicness);\n  vec3 F = fresnel(v, l, F0);\n  vec3 specular = F * spec(roughness, n, v, l);\n\n  vec3 diffuseness = (vec3(1.0) - F) * (1.0 - metallicness);\n  vec3 diffuse = diffuseness * color;\n\n  return diffuse + specular;\n}\n\nvec3 getLight(vec3 p, vec3 dir) {\n  vec3 color = vec3(0.0);\n\n  float reflection_strength = 1.0;\n  for (int i = 0; i <= BOUNCES; i++) {\n    float reflection_distance = 10.;\n    vec3 cam_direction = normalize(-dir);\n\n    float sun_dist = 50.;\n    vec3 sun_direction = normalize(vec3(2, 1, 1.5));\n    vec3 sky_direction = vec3(0, 1, 0);\n    vec3 ind_direction = sun_direction * vec3(-1, 0, -1);\n    vec3 sun_color = 10. * vec3(1.64, 1.27, 0.99);\n    vec3 penumbra_color = vec3(1.0, 1.2, 1.5);\n    vec3 sky_color = 10. * vec3(0.16, 0.20, 0.28);\n    vec3 ind_color = 10. * vec3(0.40, 0.28, 0.20);\n\n    vec3 n = getNormal(p);\n\n    Material material = getMaterial(p).material;\n\n    vec3 sample_point = p + n * SURFACE_EPSILON * 2.;\n\n    float shadow_occlusion = lightMarch(sample_point, sun_direction, sun_dist);\n    vec3 shadow = pow(vec3(shadow_occlusion), penumbra_color);\n    float occlusion = getOcclusion(p, n);\n\n    vec3 ambience = getAmbience(p, n);\n    color += ambience * material.color;\n\n    float sun_intensity = clamp1(            dot(n, sun_direction));\n    float sky_intensity = clamp1(0.5 + 0.5 * dot(n, sky_direction));\n    float ind_intensity = clamp1(            dot(n, ind_direction));\n\n    color += sun_intensity * sun_color * shadow    * pbr(material.metalness, material.roughness, material.color, n, cam_direction, sun_direction) * reflection_strength;\n    color += sky_intensity * sky_color * occlusion * pbr(material.metalness, material.roughness, material.color, n, cam_direction, sky_direction) * reflection_strength;\n    color += ind_intensity * ind_color * occlusion * pbr(material.metalness, material.roughness, material.color, n, cam_direction, ind_direction) * reflection_strength;\n\n    #if (BOUNCES > 0)\n    if (i < BOUNCES) {\n      if (material.metalness < 0.1) {\n        break;\n      }\n      reflection_strength *= 0.5 * material.metalness / (1. + 100. * material.roughness);\n      vec3 reflection_direction = 2. * dot(cam_direction, n) * n - cam_direction;\n      float d = rayMarch(sample_point, reflection_direction, reflection_distance);\n      if (d < reflection_distance) {\n        dir = d * reflection_direction;\n        p = p + dir;\n      } else {\n        break;\n      }\n    }\n    #endif\n  }\n\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * (fragCoord.xy - .5 * iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    float aperture_diameter = u_focalLength / u_f_stop;\n    float sensor_width = 0.035; // 35mm\n\n    vec2 lens_distortion = 0.05 * pow(length(uv), 2.) * uv;\n\n    // in uv space\n    float half_pixel_size = 1. / max(iResolution.x, iResolution.y);\n\n    vec3 ro = u_cam_pos;\n\n    vec3 rd = normalize(vec3(0.5 * sensor_width * (uv + lens_distortion),\n                             -u_focalLength));\n\n    vec3 color = vec3(0);\n\n    #if (SUB_PIXEL_SAMPLING == 1)\n\n    vec2 sub_pixels[4];\n    sub_pixels[0] = vec2( half_pixel_size, 0.0);\n    sub_pixels[1] = vec2(0.0,  half_pixel_size);\n    sub_pixels[2] = vec2(-half_pixel_size, 0.0);\n    sub_pixels[3] = vec2(0.0, -half_pixel_size);\n\n    for (int i = 0; i < 4; i++) {\n      vec3 dir = normalize(vec3(0.5 * sensor_width * (uv + lens_distortion + sub_pixels[i]),\n                                -u_focalLength));\n\n      dir.yz *= rot(u_cam_phi);\n      dir.xz *= rot(u_cam_theta);\n\n\n      float d = rayMarch(ro, dir, RENDER_DISTANCE);\n      vec3 p = ro + dir * d;\n\n      if (d >= RENDER_DISTANCE) {\n        fragColor = vec4(1, 1, 1, 1);\n        return;\n      }\n\n      color += getLight(p, dir) * 0.25;\n    }\n\n    #else\n\n    vec3 dir = rd;\n    dir.yz *= rot(u_cam_phi);\n    dir.xz *= rot(u_cam_theta);\n\n    float d = rayMarch(ro, dir, RENDER_DISTANCE);\n    vec3 p = ro + dir * d;\n\n    if (d >= RENDER_DISTANCE) {\n      fragColor = vec4(1, 1, 1, 1);\n      return;\n    }\n\n    color += getLight(p, dir);\n\n    #endif\n\n    vec3 focalPoint = (-u_focalDistance / rd.z) * rd;\n\n    if (u_use_dof == 1) {\n      for (int i = 0; i < SAMPLES; i++) {\n        vec3 sample_ = vec3(0.5 * aperture_diameter * u_samples[i], 0.0);\n\n        vec3 dir = focalPoint - sample_;\n        dir.yz *= rot(u_cam_phi);\n        dir.xz *= rot(u_cam_theta);\n\n        sample_.yz *= rot(u_cam_phi);\n        sample_.xz *= rot(u_cam_theta);\n\n        vec3 sampleOrigin = ro + sample_;\n        vec3 sampleDirection = normalize(dir);\n\n        float d = rayMarch(sampleOrigin, sampleDirection, RENDER_DISTANCE);\n        vec3 p = sampleOrigin + sampleDirection * d;\n\n        color += getLight(p, dir);\n      }\n\n      color *= 1.0 / float(SAMPLES + 1);\n    }\n\n    float expouse = 1.2;\n    color = vec3(1.0) - exp(- expouse * color);\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n\n    /*\n    for (int i = 0; i < SAMPLES; i++) {\n      vec2 sample = u_samples[i] * 0.5;\n      if (length(sample - uv) < 0.005) {\n        fragColor = vec4(0, 0, 1, 1);\n      }\n    }\n    */\n}\n\n","name":"Image","description":"","type":"image"}]}