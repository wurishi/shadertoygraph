{"ver":"0.1","info":{"id":"cldyDr","date":"1699073549","viewed":37,"name":" Noisy","username":"throwshade","description":" perlin noise, alot ripped from wikipedia, fractal part ripped from the book of shaders","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float scale = 48.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float scale = 24.0;\nvec2 rand( int x, int y) {\n    int a = x * y + 23080984 * y + 348394*x+66432;\n    int b = x * 21398562 + 48893;\n    int c = (a*b)%2388942;\n    int d =  (x)%12;\n    c *= 1023131279;\n    c ^= c >> 15-d;\n    c *= 1147493646;\n    c ^= c >> 8+d;\n    c *= 896541231;\n    c ^= c >> 12-d;\n    c *= 363485159;\n    c ^= c >> 9+d;\n\n    float f = float(c)/(2147483647.0) * 2.0 * 3.14159265;\n    vec2 offset = vec2(sin(iTime),cos(iTime)) ;\n    return vec2(sin(f+iTime),cos(f+iTime)) ;\n}\n\n\nfloat interp(float a0, float a1, float w) {\n    /* // You may want clamping by inserting:\n     * if (0.0 > w) return a0;\n     * if (1.0 < w) return a1;\n     */\n    //return (a1 - a0) * w + a0;\n    return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;\n    /* // Use this cubic interpolation [[Smoothstep]] instead, for a smooth appearance:\n     * return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;\n     *\n     * // Use [[Smootherstep]] for an even smoother result with a second derivative equal to zero on boundaries:\n     * return (a1 - a0) * ((w * (w * 6.0 - 15.0) + 10.0) * w * w * w) + a0;\n     */\n}\nvec2 perlin(vec2 v) {\n    int x = int(floor(v.x));\n    int y = int(floor(v.y));\n    int x1 = x + 1;\n    int y1 = y + 1;\n    \n    float sx = fract(v.x);\n    float sy = fract(v.y);\n   \n    \n    vec2 dir0 = rand(x,y);\n    vec2 dir3 = rand(x1,y1);\n    vec2 dir1 = rand(x,y1);\n    vec2 dir2 = rand(x1,y);\n    \n    vec2 rel0 = (vec2(x,y)-v);\n    vec2 rel1 = (vec2(x,y1)-v);\n    vec2 rel2 = (vec2(x1,y)-v);\n    vec2 rel3 = (vec2(x1,y1)-v);\n    \n    float n0 = dot(dir0,rel0);\n    float n1 = dot(dir2,rel2);\n    float ix0 = interp(n0, n1, sx);\n    \n    float n00 = dot(dir1, rel1);\n    float n01 = dot(dir3, rel3);\n    float ix1 = interp(n00, n01, sx);\n    \n    return vec2(interp(ix0,ix1,sy),-interp(ix0,ix1,sy));\n}\n// Properties\nconst int octaves = 4;\nfloat lacunarity = 2.0;\nfloat gain = 0.4;\n//\nvec2 fractal(vec2 v) {\n    // Initial values\n    float amplitude = 0.5;\n    float frequency = 1.;\n    //\n    \n    float y = 0.0;\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * perlin(frequency*v).x;\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    return vec2(y,-y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    fragColor= vec4(fractal(fragCoord/iResolution.xx*scale).xxx * 0.5 + 0.5,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}