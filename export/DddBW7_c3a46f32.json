{"ver":"0.1","info":{"id":"DddBW7","date":"1697473748","viewed":35,"name":"Laser Beam Propogation","username":"drawliphant","description":"Simulates a laser beam caustic. Takes two scanning slits of intensity and calculates how the beam propagates. In this case, it's a Hermiteâ€“Gaussian beam.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 laser;\nvec2 plane;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 b=vec2(0,0);//image convolution y pass\n    if(fragCoord.y>float(center)+1.0&&fragCoord.y<iResolution.y-float(center)){\n       for(int i =-center; i<center;i++){\n           laser=texture(iChannel0,vec2(0.0,float(i)/iResolution.y+.5)).xy;\n           plane=texture(iChannel0,(fragCoord+vec2(0.0,float(i)))/iResolution.xy).xy;\n           b+=vec2(plane.x*laser.x-plane.y*laser.y,plane.x*laser.y+plane.y*laser.x);\n       }\n    }\n    float brig=sqrt(b.x*b.x+b.y*b.y);\n    \n    //fragColor = vec4(viridis_quintic(brig),1.0);//intensity to viridis\n    \n    vec3 linear_rgb = oklab_to_linear_srgb(vec3(brig*2.0,b.x/brig/8.0,b.y/brig/8.0));//use intensity for brightness and phase for hue\n    fragColor = vec4(sqrt(linear_rgb.x),sqrt(linear_rgb.y),sqrt(linear_rgb.z),1);\n    \n    //fragColor = vec4(b,0,1);//no filter\n    \n    //fragColor = texture(iChannel0,fragCoord/iResolution.xy);//pass through input to debug\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float intensity;\nvec2 uv;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//precalculated info for each pixel\n{\n    uv = fragCoord-iResolution.xy/2.0;\n    if(fragCoord.x<1.0){//draw y axis scanning slit on the edge\n        intensity = hermitepdf(uv.y/sigma,temy)*brightness;\n        distanc = sqrt(BeamR*BeamR+uv.y*uv.y);//used to simulate wave curvature like \n        //  https://en.wikipedia.org/wiki/Gaussian_beam#/media/File:Gaussian_beam_w40mm_lambda30mm.png\n        fragColor = vec4(intensity*cos(-distanc*wavelength),intensity*sin(-distanc*wavelength),0,1);//2d vector of intensity and phase\n    }else if(fragCoord.y<1.0){//draw x axis scanning slit on the edge \n        intensity = hermitepdf(uv.x/sigma,temx)*brightness;\n        distanc = sqrt(BeamR*BeamR+uv.x*uv.x);\n        fragColor = vec4(intensity*cos(-distanc*wavelength),intensity*sin(-distanc*wavelength),0,1);\n    }else{//draw distance disk represents relative phase vs distance from a point source. \n        distanc = 100.0*iTime+10.0;\n        vec2 pixelPos = ((fragCoord-iResolution.xy/2.0));\n        float dist = sqrt(pixelPos.x*pixelPos.x+pixelPos.y*pixelPos.y+distanc*distanc)/wavelength;\n        vec2 ripples = vec2(cos(dist)*brightness,sin(dist)*brightness);\n        fragColor = vec4(ripples/distanc,0,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 laser;\nvec2 plane;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.x<1.0){//pass laser y channel through\n        fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    }else{\n        vec2 b=vec2(0,0);//image convolution x pass\n        if(fragCoord.x>float(center)+1.0&&fragCoord.x<iResolution.x-float(center)){\n           for(int i =-center; i<center;i++){\n               laser=texture(iChannel0,vec2(float(i)/iResolution.x+.5,0.0)).xy;\n               plane=texture(iChannel0,(fragCoord+vec2(float(i),0))/iResolution.xy).xy;//just like a gaussian blur so far\n               b+=vec2(plane.x*laser.x-plane.y*laser.y,plane.x*laser.y+plane.y*laser.x);//Both plane and laser have relative phase.\n               //To add phases together we encoded a rotation matrix into the laser pixel to rotate the plane pixel\n               // Then add it just like a gaussian blur.\n           }\n        }\n        //b*=brightness;\n        fragColor = vec4(b.x,b.y,.3,1.0);\n        //fragColor = texture(iChannel0,fragCoord/iResolution.xy)*1000.0;\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float wavelength = .3;//pixels per radian\nfloat distanc = 1.0;//holder\nconst float sigma = 30.0;//beam width pixels\nconst int center = 120;//half width of kernal (how many pixels in beam)\nconst float brightness = .4;//exposure\nconst int temx = 2;//TEM00 select beam modes\nconst int temy = 1;\nconst float BeamR = 100.0;//how far away is focus\nfloat hermitepdf(in float x, in int mode)//generate hermite scanning slits\n{\n    float i;\n    if(mode == 0){i=1.0; }\n    else if(mode == 1){i=2.0*x; }\n    else if(mode == 2){i=4.0*x*x-2.0;}\n    else if(mode == 3){i=8.0*x*x*x-12.0*x;}\n\treturn i*exp(-0.5*x*x);\n}\nvec3 viridis_quintic( float x )//turn float range 0-1 into viridis color scheme\n{\n\tx = clamp( x, 0.0, 1.0 );\n\tvec4 x1 = vec4( 1.0, x, x * x, x * x * x ); // 1 x x2 x3\n\tvec4 x2 = x1 * x1.w * x; // x4 x5 x6 x7\n\treturn vec3(\n\t\tdot( x1.xyzw, vec4( +0.280268003, -0.143510503, +2.225793877, -14.815088879 ) ) + dot( x2.xy, vec2( +25.212752309, -11.772589584 ) ),\n\t\tdot( x1.xyzw, vec4( -0.002117546, +1.617109353, -1.909305070, +2.701152864 ) ) + dot( x2.xy, vec2( -1.685288385, +0.178738871 ) ),\n\t\tdot( x1.xyzw, vec4( +0.300805501, +2.614650302, -12.019139090, +28.933559110 ) ) + dot( x2.xy, vec2( -33.491294770, +13.762053843 ) ) );\n}\nvec3 oklab_to_linear_srgb(vec3 c)//turn lumanace, a, b into rgb \n{\n\tfloat l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;\n\tfloat m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;\n\tfloat s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;\n\n\tfloat l = l_ * l_ * l_;\n\tfloat m = m_ * m_ * m_;\n\tfloat s = s_ * s_ * s_;\n\n\treturn vec3(\n\t\t+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,\n\t\t-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,\n\t\t-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s\n\t);\n}\n","name":"Common","description":"","type":"common"}]}