{"ver":"0.1","info":{"id":"DljGWW","date":"1683725230","viewed":47,"name":"Ray Marching : Practice 4","username":"pkj","description":"Constructive Solid Geometry\n\nPersonal Study","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n// SDF 계산 거리에 대한 기하적 형상 교차 작업\n// 교집합의 형태를 구할 수 있다.\nfloat intersectSDF(float distA, float distB)\n{\n    return max(distA, distB);\n}\n\n// 합집합의 형태를 구할 수 있다.\nfloat unionSDF(float distA, float distB)\n{\n    return min(distA, distB);\n}\n\n// B의 여집합과 A와의 교집합 형태를 구할 수 있다.\nfloat differenceSDF(float distA, float distB)\n{\n    return max(distA, -distB);\n}\n\n\n// 원점을 중심으로 하는 입방체에 대한 SDF\nfloat cubeSDF(vec3 p)\n{\n    // d.x가 0보다 작으면 -1 < p.x < 1 이다. (p.y, p.z도 마찬가지)\n    // d의 모든 구성 요소가 음수이면 p는 단위 큐브 내부에 있다.\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // d.x, d.y, d.z중에 가장 큰 값과 0.0을 비교하여 표면에서 얼마나 떨어져\n    // 있는지 거리를 구한다. (p가 정육면체 안에 있다고 가정)\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // d와 0.0을 비교하여 표면에서 얼마나 떨어져 있는지 구한다. (p가 정육면체 밖에 있다고 가정)\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n// 반지름이 1.0인 원점 중심의 구에 대한 SDF\nfloat sphereSDF(vec3 samplePoint)\n{\n    return length(samplePoint) - 1.0;\n}\n\n// 반환값 : 표면까지의 거리\nfloat sceneSDF(vec3 samplePoint) \n{\n    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;\n    float cubeDist = cubeSDF(samplePoint);\n    return intersectSDF(sphereDist, cubeDist);\n}\n\n// eye : 광선의 시작점 (눈)\n// marchingDirection : Ray가 진행될 정규화된 방향\n// start : 눈에서 멀어지는 시작 거리\n// end : eye에서 진행되는 최대 거리\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end)\n{\n    float depth = start;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if(dist < EPSILON) return depth;\n        \n        depth += dist;\n        if(depth >= end) return end;\n    }\n    return end;\n}\n\n// 단일 픽셀에 대해 시점에서 진행하도록 정규화된 방향을 반환한다.\n// fieldOfView : 수직 시야\n// size : 출력 이미지 해상도\n// fragCoord : 출력 이미지에서 픽셀의 x,y 좌표\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// 법선 벡터 추정 함수\n// SDF의 기울기를 이용하여 점 P에서 표면의 법선을 추정한다.\n// rise-over-run 기법으로 gradient를 유사하게 구할 수 있다.\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n// return : 빛의 RGB 색상 (빛의 속성)\n// k_d : diffuse color 확산광 (광선과의 각도에 따라 달라지는 빛)\n// k_s : specular color 정반사 (빛나는 오브젝트에서 볼 수 있는 밝은 지점을 반사하는 것을 표현 하는 Color)\n// alpha : 광택 계수\n// p : 점 위치\n// eye : 카메라 위치\n// lightPos : 빛 위치\n// lightIntensity : 빛의 색과 강도\n// N : p 지점에서의 법선\n// L : 표면의 점에서 광원을 향하는 방향 벡터\n// V : eye를 가르키는 방향 벡터\n// R : 완전히 반사된 광선이 표면의 이 지점에서 취하는 방향\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, \n                            vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n\n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    // 표면에 있는 점에 빛이 보이지 않는 다면\n    if(dotLN < 0.0) return vec3(0.0, 0.0, 0.0);\n    \n    // 반대 방향의 빛 반사, diffuse에만 적용\n    if(dotRV < 0.0) return lightIntensity * (k_d * dotLN);\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// k_a : ambient color 주변광 (기본으로 주변에 있는 빛)\n// k_d : diffuse color 확산광 (광선과의 각도에 따라 달라지는 빛)\n// k_s : specular color 정반사 (빛나는 오브젝트에서 볼 수 있는 밝은 지점을 반사하는 것을 표현 하는 Color)\n// alpha : 광택 계수\n// p : 점 위치\n// eye : 카메라 위치\n// lightPos : 빛 위치\n// lightIntensity : 빛의 색과 강도\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye)\n{\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(1.0, 1.0, 1.0);//vec3(4.0 * sin(iTime), 2.0, 4.0 * cos(iTime));\n    \n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light1Pos, light1Intensity);\n    \n    vec3 light2Pos = vec3(15.0, 2.0, 90.0);//vec3(2.0 * sin(0.37 * iTime), 2.0 * cos(0.37 * iTime), 2.0); \n    \n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye, light2Pos, light2Intensity);    \n    return color;\n}\n\n// return : view space에서 ray를 변환할 변환 매트릭스를 반환한다.\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    // forward vector\n    vec3 f = normalize(center - eye);\n    \n    // side vector\n    vec3 s = normalize(cross(f, up));\n    \n    // up vector\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if(dist > MAX_DIST - EPSILON)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    // view ray 진행에서 가장 가까운 지점\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.2, 0.8, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}