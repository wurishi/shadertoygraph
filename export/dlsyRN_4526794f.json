{"ver":"0.1","info":{"id":"dlsyRN","date":"1690485192","viewed":37,"name":"EXITEK","username":"ZeroXKiitsu","description":"warping shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["warpingshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Входные данные (измените значения при необходимости)\n    float screenWidth = 800.0;        // Ширина экрана\n    float screenHeight = 600.0;       // Высота экрана\n    vec2 center = vec2(screenWidth / 2.0, screenHeight / 2.0);  // Центр экрана\n    float rotation = 0.3;             // Угол вращения (в радианах)\n    float strength1 = 0.1;            // Сила деформации к центру справа (изменяйте для контроля)\n    float strength2 = 0.1;            // Сила деформации внутрь (изменяйте для контроля)\n\n    // Вычисление размера квадрата\n    float boardSize = 15.0; // Размер доски (количество квадратов по одной стороне)\n    float squareSize = min(screenWidth, screenHeight) / boardSize;\n\n    // Получение вектора от текущей позиции до центра экрана\n    vec2 toCenter = center - fragCoord;\n\n    // Вращение вектора\n    float cosA = cos(rotation);\n    float sinA = sin(rotation);\n    vec2 rotated = vec2(\n        toCenter.x * cosA - toCenter.y * sinA,\n        toCenter.x * sinA + toCenter.y * cosA\n    );\n\n    // Применение силы деформации к центру справа\n    vec2 deformation1 = rotated * strength1;\n\n    // Определение, находится ли пиксель в области деформации внутрь\n    float rightDeformSize = 200.0; // Размер области деформации в центре справа (пиксели)\n    vec2 rightDeformCenter = vec2(center.x + screenWidth / 4.0, center.y);\n    vec2 toRightDeformCenter = rightDeformCenter - fragCoord;\n    bool isInRightDeformArea = abs(toRightDeformCenter.x) < rightDeformSize / 2.0 &&\n                               abs(toRightDeformCenter.y) < screenHeight / 2.0;\n\n    // Применение деформации внутрь к текстурным координатам\n    vec2 deformation2 = vec2(0.0);\n    if (isInRightDeformArea)\n    {\n        float distanceToCenter = length(toRightDeformCenter);\n        deformation2 = normalize(toRightDeformCenter) * strength2 * (rightDeformSize / distanceToCenter);\n    }\n\n    // Применение обеих деформаций к текстурным координатам\n    vec2 texCoord = (fragCoord + deformation1 + deformation2) / vec2(screenWidth, screenHeight);\n\n    // Создание шахматной текстуры\n    float x = floor(fragCoord.x / squareSize);\n    float y = floor(fragCoord.y / squareSize);\n    bool isBlack = mod(x + y, 2.0) == 0.0;\n\n    // Установка цвета пикселя на основе шахматной доски (только черный или белый)\n    vec3 finalColor = isBlack ? vec3(0.0) : vec3(1.0);\n\n    // Получение цвета из текстуры и установка его в качестве цвета пикселя\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}