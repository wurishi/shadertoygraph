{"ver":"0.1","info":{"id":"Nlcfz2","date":"1663337161","viewed":80,"name":"Quad Bezier Reparametrization L1","username":"Envy24","description":"Quadratic Bezier Arclength Reparametrization with L1-metric.\n\nCyan dots - P(s), where s is length parameter, equdistant by length.\nRed dots - P(t), where t is time parameter, equidistant by time.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","bezier","quadratic","l1","arclength","reparametrization"],"hasliked":0,"parentid":"ftdBzS","parentname":"Quadratic Bezier Reparametrizati"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  10.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\n\n/* Arclength with L1-norm. */\nfloat arclength(float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    vec2 A = P0-2.*P1+P2,\n         B = 2.*(P1-P0);\n \n    float a = 2.*A.x*t + B.x,\n          b = 2.*A.y*t + B.y,\n          c = A.y * a * abs(a),\n          d = A.x * b * abs(b),\n          e = A.y*B.x*abs(B.x) + A.x*B.y*abs(B.y),\n          g = 4.*A.y*A.x;\n          \n    return (c+d-e)/g;\n}\n\n/* Bisection method for finding t relative to s */\nvec2 reparametrize(float s, vec2 P0, vec2 P1, vec2 P2)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n    float T[2] = float[2](0., 1.);\n    float F[2] = float[2](\n        arclength(T[0], P0, P1, P2),\n        arclength(T[1], P0, P1, P2));\n    \n    float l = 0.5;\n    \n    for (int i = 0; (i < 12) && (abs(l-s) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float t = (T[0] + T[1]) * 0.5;\n              l = arclength(t, P0, P1, P2);\n\n        int w_idx = int(l>s);\n        \n        F[w_idx] = l; T[w_idx] = t;\n    }\n\n    return quadraticBezier((T[0] + T[1]) * 0.5, P0, P1, P2);\n}\n/**/\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC) * 2.5;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    vec2 P0 = vec2(-4., -2.), P1 = vec2(4.0, 2.0), P2 = vec2(4., -2.);\n    \n    //float offs = sinOSC(-0.5, 0.5, iTime * 0.5);    \n    //P0 = rotateAroundZ(P0, iTime * 0.1) + vec2(2.*offs, -offs);\n    //P1 = rotateAroundZ(P1, iTime * 0.9) + vec2(-6.*offs, 0.0);\n    //P2 = rotateAroundZ(P2, iTime * 0.1) + vec2(-offs, offs);\n                  \n         color = mix(color, vec3(0, 1, 0), SMAA( quadraticBezierSegmentSDF_L2(NDC, P0, P1, P2) ));\n         color = mix(color, vec3(0, 0, 1), SMAA( segmentSDF_L2(NDC, P0, P1) ));\n         color = mix(color, vec3(0, 0, 1), SMAA( segmentSDF_L2(NDC, P1, P2) ));\n         color = mix(color, vec3(1, 0, 1), SMAA( diskSDF_L2(NDC, P0, UNIT) ));\n         color = mix(color, vec3(1, 0, 1), SMAA( diskSDF_L2(NDC, P1, UNIT) ));\n         color = mix(color, vec3(1, 0, 1), SMAA( diskSDF_L2(NDC, P2, UNIT) ));\n\n    float t, l, len = arclength(1., P0, P1, P2); vec2 P;\n\n#define SCALE 0.25\n/* Static */\n         int count = 5;        \n         float dl = len / float(count-1),\n               dt = 1. / float(count-1);\n               len = arclength(1., P0, P1, P2);\n         \n         for (int i = 0; i < count; ++i)\n         {\n                 P = reparametrize(float(i)*dl, P0, P1, P2);\n             color = mix(color, vec3(0, 1, 1), SMAA( diskSDF_L2(NDC, P, 2.*UNIT) ));\n                 P = quadraticBezier(float(i)*dt, P0, P1, P2);\n             color = mix(color, vec3(1, 0, 0), SMAA( diskSDF_L2(NDC, P, UNIT) ));\n         }\n/* Motion (doesn't work on dynamic curves, because of length changes every frame) */\n    float speed = 1.0;\n             l = mod(iTime*speed, len);\n             P = reparametrize(l, P0, P1, P2); // moves with constant length.\n         color = mix(color, vec3(0.3, 0.5, 0.8), SMAA( diskSDF_L2(NDC, P, 2.*UNIT) )); // light blue\n         \n             t = mod(iTime*speed, len)/len; // moves with constant time.\n             P = quadraticBezier(t, P0, P1, P2);\n         color = mix(color, vec3(0.8, 0.5, 0.3), SMAA( diskSDF_L2(NDC, P, 2.*UNIT) )); // brown\n/**/\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}\n\n/*\n    Return value:\n        0 - two complex roots;\n        1 - one real root, but root[0] == root[1];\n        2 - two real roots;\n*/\nint solveQuadratic(\n    inout vec2[2] roots,\n    in float[3] coefs)\n{\n    float discriminant = coefs[1] * coefs[1] - 4.0 * coefs[0] * coefs[2];\n\n    if (discriminant < 0.0)\n    {\n        float INVa = 1.0 / (2. * coefs[0]);\n        float SQRT = sqrt(-discriminant);\n\n        roots[0].x = -coefs[1] * INVa;\n        roots[0].y = SQRT * INVa;\n        roots[1].x = -coefs[1] * INVa;\n        roots[1].y = -SQRT * INVa;\n\n        return 0;\n    }\n\n    if (discriminant == 0.0)\n    {\n        float Re = -coefs[1] / (2. * coefs[0]);\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = Re;\n        roots[1].y = 0.0;\n\n        return 1;\n    }\n\n    float INVa = 1.0 / (2. * coefs[0]);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - coefs[1]) * INVa;\n    roots[0].y = 0.0;\n    roots[1].x = (-coefs[1] - SQRT) * INVa;\n    roots[1].y = 0.0;\n\n    return 2;\n}\n\n/*\n    Return value:\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicVieta(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float a = coef[1] / coef[0];\n    float b = coef[2] / coef[0];\n    float c = coef[3] / coef[0];\n\n    float Q = (a * a - 3.0 * b) / 9.0;\n    float R = (2.0 * a * a * a - 9.0 * a * b + 27.0 * c) / 54.0;\n\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - a * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - a * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(Q);\n        float Re = signR * sqrtQ * cosh(phi);\n        float Im = sqrtQ * sinh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(abs(Q));\n        float Re = signR * sqrtQ * sinh(phi);\n        float Im = sqrtQ * cosh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - a * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - a * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - a * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        //float Re = -cubeRoot(c - a * a * a / 27.0) - a / 3.0;\n        float Re = -pow(c - a * a * a / 27.0, 1./3.) - a / 3.0;\n        float Im = sqrt(abs(a - 3.0 * Re) * (a + Re) - 4.0 * b) * 0.5;\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = -(a + Re) * 0.5;\n        roots[1].y = Im;\n        roots[2].x = -(a + Re) * 0.5;\n        roots[2].y = Im;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - a * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - a * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n\n/*\n    Returns number of finded real roots.\n*/\nint solve(\n    inout vec2[3] roots,\n    in float[4] coef)\n{\n    // Quadratic equation?\n    if (coef[0] == 0.0)\n    {\n        // Linear equation?\n        if (coef[1] == 0.0)\n        {\n            // Constant?\n            if (coef[2] == 0.0) { return 0; }\n            \n            // Solve linear.\n            roots[0].x = -coef[3]/coef[2];\n            roots[0].y = 0.0;\n\n            return 1;\n        }\n        \n        vec2 r[2];\n        float c[3] = float[3](\n            coef[1],\n            coef[2],\n            coef[3]\n        );\n        \n        int num = solveQuadratic(r, c);\n        roots[0] = r[0];\n        roots[1] = r[1];\n        \n        return num;\n    }\n    \n    return solveCubicVieta(roots, coef);\n}\n\nvec2 quadraticBezier(float t, vec2 P0, vec2 P1, vec2 P2)\n{\n    return (P0*(1.-t)*(1.-t)+2.*P1*t*(1.-t)+P2*t*t);\n}\n\n/* Solution from https://www.desmos.com/calculator/zqj0ztakig */\nfloat quadraticBezierSegmentSDF_L2(\n    vec2 NDC,\n    vec2 P0,\n    vec2 P1,\n    vec2 P2)\n{\n    vec2 C = P2 - 2.*P1 + P0;\n    vec2 D = 2.*(P1 - P0);\n    vec2 E = P0 - NDC;\n\n    float coef[4] = float[4](\n        2. * dot(C, C),\n        3. * dot(C, D),\n        2. * dot(C, E) + dot(D, D),\n        dot(D, E)\n    );\n  \n    vec2 T[3];\n    float minSqDist = 99.;\n    int num = solve(T, coef);\n\n    for (int i = 0; i < num; ++i)\n    {\n        float t = clamp(T[i].x, 0.0, 1.0);\n        vec2 diff = quadraticBezier(t, P0, P1, P2) - NDC;\n        \n        minSqDist = min(minSqDist, dot(diff, diff));\n    }\n      \n    return sqrt(minSqDist);\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}","name":"Common","description":"","type":"common"}]}