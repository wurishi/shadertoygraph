{"ver":"0.1","info":{"id":"mstyWr","date":"1703826872","viewed":135,"name":"20231229_ephemeral sdf","username":"0b5vr","description":"haha","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","typography"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define saturate(i) clamp(i,0.,1.)\n#define linearstep(a,b,t) saturate(((t)-(a)) / ((b)-(a)))\n#define repeat(i,n) for(int i=0;i<n;i++)\n\nconst int EPHEMERAL_SAMPLES = 10;\n\nconst float EPHEMERAL_AMP = 0.5;\nconst float EPHEMERAL_DRIP = 1.0;\nconst float EPHEMERAL_BLUR = 0.05;\nconst vec3 EPHEMERAL_FREQ = vec3( 0.3, 0.3, 0.2 );\n\nconst float PI = acos( -1.0 );\n\nuvec3 hash3( uvec3 s ) {\n    s += 1145141919u * ( s.yzx ^ ( s.zxy >> 8u ) );\n    s += 1145141919u * ( s.yzx ^ ( s.zxy >> 8u ) );\n    s += 1145141919u * ( s.yzx ^ ( s.zxy >> 8u ) );\n    return s;\n}\n\nvec3 hash3f( vec3 s ) {\n    uvec3 r = floatBitsToUint( s );\n    return vec3( hash3( r ) ) / float( -1u );\n}\n\nuvec3 seed;\nuvec3 random3() {\n    seed = hash3( seed );\n    return seed;\n}\n\nvec3 random3f() {\n    return vec3( random3() ) / float( -1u );\n}\n\nmat2 rotate2D( float t ) {\n    float c = cos( t );\n    float s = sin( t );\n    return mat2( c, s, -s, c );\n}\n\nmat3 getOrthogonalBasis( vec3 z ) {\n  z = normalize( z );\n  vec3 up = abs( z.y ) < 0.99 ? vec3( 0.0, 1.0, 0.0 ) : vec3( 0.0, 0.0, 1.0 );\n  vec3 x = normalize( cross( up, z ) );\n  return mat3( x, cross( z, x ), z );\n}\n\nvec3 cyclicNoise( vec3 p, float pump ) {\n  vec4 sum = vec4( 0.0 );\n  mat3 basis = getOrthogonalBasis( vec3( -1.0, 2.0, -3.0 ) );\n  \n  repeat( i, 5 ) {\n    p *= basis;\n    p += sin( p.yzx );\n    sum += vec4(\n      cross( cos( p ), sin( p.zxy ) ),\n      1.0\n    );\n    sum *= pump;\n    p *= 2.0;\n  }\n  \n  return sum.xyz / sum.w;\n}\n\nfloat sdbox( vec2 p, vec2 s ) {\n\tvec2 d = abs( p ) - s;\n\treturn min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nfloat sdcapsule( vec2 p, vec2 tail ) {\n    float h = clamp( dot( p, tail ) / dot( tail, tail ), 0.0, 1.0 );\n    return length( p - ( tail * h ) );\n}\n\nfloat shape0( vec2 p ) {\n    float s = abs( sdbox( p, vec2( 0.05, 0.0 ) ) - 0.2 ) - 0.05;\n    s = min( s, length( p ) - 0.03 );\n\n    return s;\n}\n\nfloat shapeB( vec2 p ) {\n    float s = sdbox( p - vec2( -0.25, 0.0 ), vec2( 0.05, 0.25 ) );\n    s = min( s, max(\n        min(\n            abs( sdbox( p - vec2( -0.4, 0.1 ), vec2( 0.55, 0.0 ) ) - 0.1 ) - 0.05,\n            abs( sdbox( p - vec2( -0.4, -0.1 ), vec2( 0.55, 0.0 ) ) - 0.1 ) - 0.05\n        ),\n        sdbox( p, vec2( 0.3, 0.25 ) )\n    ) );\n\n    return s;\n}\n\nfloat shape5( vec2 p ) {\n    float s = sdbox( p - vec2( -0.02, 0.2 ), vec2( 0.28, 0.05 ) );\n    s = min( s, sdbox( p - vec2( -0.25, 0.15 ), vec2( 0.05, 0.1 ) ) );\n    s = min( s, max(\n        abs( sdbox( p - vec2( -0.41, -0.09 ), vec2( 0.55, 0.0 ) ) - 0.11 ) - 0.05,\n        sdbox( p, vec2( 0.3, 0.25 ) )\n    ) );\n\n    return s;\n}\n\nfloat shapeV( vec2 p ) {\n    float s = max(\n        min(\n            sdbox( ( p - vec2( -0.12, 0.0 ) ) * rotate2D( PI * 0.14 ), vec2( 0.06, 0.5 ) ),\n            sdbox( ( p - vec2( 0.12, 0.0 ) ) * rotate2D( -PI * 0.14 ), vec2( 0.06, 0.5 ) )\n        ),\n        sdbox( p, vec2( 0.3, 0.25 ) )\n    );\n\n    return s;\n}\n\nfloat shapeR( vec2 p ) {\n    float s = sdbox( p - vec2( -0.25, 0.0 ), vec2( 0.05, 0.25 ) );\n    s = min( s, max(\n        abs( sdbox( p - vec2( -0.42, 0.08 ), vec2( 0.55, 0.0 ) ) - 0.12 ) - 0.05,\n        sdbox( p, vec2( 0.3, 0.25 ) )\n    ) );\n    s = min( s, max(\n        sdbox( ( p - vec2( 0.12, 0.0 ) ) * rotate2D( PI * 0.14 ), vec2( 0.05, 0.5 ) ),\n        sdbox( p - vec2( 0.0, -0.15 ), vec2( 0.3, 0.1 ) )\n    ) );\n\n    return s;\n}\n\nfloat shape( vec2 p ) {\n    float s = 1E9;\n    s = min( s, shape0( p - vec2( -1.3, 0.0 ) ) );\n    s = min( s, shapeB( p - vec2( -0.65, 0.0 ) ) );\n    s = min( s, shape5( p - vec2( 0.0, 0.0 ) ) );\n    s = min( s, shapeV( p - vec2( 0.65, 0.0 ) ) );\n    s = min( s, shapeR( p - vec2( 1.3, 0.0 ) ) );\n\n    return s;\n}\n\nfloat grid( vec2 p ) {\n    vec2 d = abs( p - floor( p + 0.5 ) );\n    return min( d.x, d.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    seed = uvec3( fragCoord, iFrame );\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float d = 1.0 / iResolution.y;\n    \n    vec3 aa = vec3( 0.0 );\n    \n    float dice = random3f().x;\n    \n    repeat( i, EPHEMERAL_SAMPLES ) {\n        vec2 pt = p;\n        float ephemeral = ( float( i ) + dice ) / float( EPHEMERAL_SAMPLES );\n        float sqEphemeral = ephemeral * ephemeral;\n\n        pt.y -= ( 1.0 - exp( -EPHEMERAL_DRIP * sqEphemeral ) ) * abs( pt.y ) * sign( pt.y );\n        pt += EPHEMERAL_AMP * sqEphemeral * cyclicNoise( EPHEMERAL_FREQ * vec3( p, iTime - sqEphemeral ), 1.5 ).xy;\n        vec3 color = 3.0 / float( EPHEMERAL_SAMPLES ) * smoothstep( 1.0, 0.0, abs( 3.0 * ephemeral - vec3( 1.0, 1.5, 2.0 ) ) );\n        \n        aa += color * linearstep( d + EPHEMERAL_BLUR * sqEphemeral, -d, shape( pt ) );\n    }\n    fragColor = vec4( aa, 1.0 );\n    \n    // fragColor.xyz += 0.5 * linearstep( d, -d, grid( p ) - 2.0 * d );\n    // fragColor.xyz += 0.5 * linearstep( d, -d, grid( p * 10.0 ) / 10.0 - d );\n}\n","name":"Image","description":"","type":"image"}]}