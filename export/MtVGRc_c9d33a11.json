{"ver":"0.1","info":{"id":"MtVGRc","date":"1479856095","viewed":102,"name":"PZ_Mandelbrot","username":"625dennis","description":"PZ_Mandelbrot","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["pzmandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pan-zoom (pz) methods\n#define pz_stateYOffset 0.0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution = iChannelResolution[0].xy;\n    pz_originalBufferResolution = pz_stateSample(0.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+0.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    //fragCoord *= position.z;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n\n// Image parameters in world coordinates.\nvec2 center = vec2(0, 0);\n//float radius = 1.25 + 0.5*sin(iTime);\nfloat radius = 1.25; ///pow(2.0, (iTime));\n\nfloat er2 = 4.0; // Square of the escape radius of the mandelbrot set .\n#define imax 1000\n\n// Convert pixel coordinates to world coordinates.\nvec2 getCoordinate(vec2 center, float radius, vec2 fragCoord, vec3 iResolution) {\n    float x = (fragCoord.x - iResolution.x/2.0) / (iResolution.y/2.0);\n    float y = (fragCoord.y - iResolution.y/2.0) / (iResolution.y/2.0);\n    vec2 c = vec2(center.x + radius*x, center.y + radius*y);\n    return c;\n}\n\n// Square two complex numbers. (a+bi)^2=a^2+2abi-b^2\nvec2 squareComplex(vec2 v) {\n    return vec2(\n        v.x * v.x - v.y * v.y,\n        2.0 * v.x * v.y\n    );\n}\n\n// (a+bi)^4 = a^4+4*a^3bi-6a^2b^2-4ab^3i+b^4\nvec2 fourthPowerComplex(vec2 v) {\n    return vec2(\n        pow(v.x, 4.0) - 6.0 * v.x*v.x * v.y*v.y + pow(v.y, 4.0),\n        4.0*pow(v.x, 3.0) * v.y - 4.0 * v.x * pow(v.y, 3.0)\n    );\n}\n\nbool isInsideOfMandelbrot(vec2 c) {\n    int count = 0;\n    vec2 z = vec2(0.0, 0.0); // z is starting point.\n    \n    for(int i = 0; i < imax; i++) {\n        //z = c + squareComplex(z); // f_c(z) = z^2 + c\n        z = c + fourthPowerComplex(z);\n        count = i;\n        if(dot(z,z) > er2) {break;}\n    }\n    \n    if(count == imax-1)\n        return true;\n    else \n        return false;\n}\n\nvec4 giveColor(vec2 c) {\n    vec2 uv = (c.xy + vec2(radius - center.x , radius - center.y)) / (2.0 * radius);\n    \n    bool isInside = isInsideOfMandelbrot(c);\n    \n    if(isInside)\n        return vec4(0.5+0.5*sin(iTime),uv,1.0);\n    else \n        return vec4(uv,0.5+0.5*cos(iTime),1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n \n    center += pz_initializeState(vec2(0,0));\n    radius /= pz_position().z + 0.00000001;\n    vec2 c = getCoordinate(center, radius, fragCoord, iResolution);\n    fragColor = giveColor(c);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Pan-zoom (pz) methods\n#define pz_stateYOffset 0.0\n#define pz_stateBuf 0\n#define pz_stateSample(x) texture(iChannel0,x)\nvec2 pz_realBufferResolution;\nvec2 pz_originalBufferResolution;\n\nvoid pz_initializeState() {\n    pz_realBufferResolution = iChannelResolution[0].xy;\n    pz_originalBufferResolution = pz_stateSample(.5/pz_realBufferResolution).xy;\n}\n\nvec2 pz_nr2vec(float nr) {\n    return vec2(mod(nr, pz_originalBufferResolution.x)\n                      , pz_stateYOffset+floor(nr / pz_originalBufferResolution.x))+.5;\n}\n\nvec4 pz_readState(float nr) {\n    return pz_stateSample(pz_nr2vec(nr)/pz_realBufferResolution);\n}\n\nfloat pz_resetCount() {\n    return pz_readState(1.).z;\n}\n\nvec3 pz_position() {\n    return pz_readState(3.).xyz;\n}\n\nvec2 pz_initializeState(vec2 fragCoord) {\n    pz_initializeState();\n    \n    vec3 position = pz_position();\n    fragCoord -= 0.5*iResolution.xy;\n    fragCoord += (0.5 + position.xy) * iResolution.xy ;\n    return fragCoord;\n}\n\n#define pz_resetOnMove 1\n\nbool pz_checkCell(float nr, vec2 coord) {\n    return distance(pz_nr2vec(nr),coord)<=0.5;\n}\n\n//Keyboard constants\nconst float KEY_A = 65.5/256.0;\nconst float KEY_W = 87.5/256.0;\nconst float KEY_D = 68.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_Q = 81.5/256.0;\nconst float KEY_Z = 90.5/256.0;\n\n//float deltaFactor = 1.25/pow(2.0, (iTime));\nfloat deltaFactor = 1.0;\n\n// Convert pixel coordinates to world coordinates.\nvec2 getCoordinate(vec2 center, float radius, vec2 fragCoord, vec3 iResolution) {\n    float x = (fragCoord.x - iResolution.x/2.0) / (iResolution.y/2.0);\n    float y = (fragCoord.y - iResolution.y/2.0) / (iResolution.y/2.0);\n    vec2 c = vec2(center.x + radius*x, center.y + radius*y);\n    return c;\n}\n\nbool readKey(float key) {\n    return texture( iChannel1, vec2(key,0.5/3.0) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    pz_initializeState();\n\tfragColor = pz_stateSample(fragCoord/pz_realBufferResolution);\n    if (fragCoord.x < 1. \n     && fragCoord.y < 1.) {\n        //Lets store the initial buffersize at pos0 and use that for addressing\n        if (pz_originalBufferResolution.x == 0.0)\n            fragColor = vec4(pz_realBufferResolution,1.0,1.0);\n        \n    } else if (pz_checkCell(1.,fragCoord)) {\n        \n        // Use postion 1 to trigger screen size changes so we can clear other buffers on going fullscreen\n        if (distance(fragColor.xy,pz_realBufferResolution)>1.0 \n#if pz_resetOnMove            \n            || pz_readState(3.).w > 0.0\n#endif            \n           ) {\n            fragColor.xy = pz_realBufferResolution;\n            fragColor.z = 60.0;\n        } else {\n            if (fragColor.z > 0.0)\n                fragColor.z -= 1.0;\n        }\n\t\n    } else if (pz_checkCell(3.,fragCoord)) {\n        vec2 delta = vec2(readKey(KEY_A) ? -0.0001 / pow(pz_position().z, 2.0) :\n                      readKey(KEY_D) ? 0.0001 / pow(pz_position().z, 2.0) : 0.0\n                    , readKey(KEY_W) ? 0.0001 / pow(pz_position().z, 2.0) :\n                      readKey(KEY_S) ? -0.0001 / pow(pz_position().z, 2.0) : 0.0);\n        float factor = readKey(KEY_Q) ? 1.02 :\n                       readKey(KEY_Z) ? 1.0 - 0.02 : 1.0;\n        \n\t\tif (fragColor.z<0.0000001)\n            fragColor.z = 1.0;\n        \n        fragColor.xy += delta * fragColor.z; //Add keyboard move\n        fragColor.z *= factor;\n        \n        fragColor.w = abs(factor-1.0)*3.0 + length(delta);\n    } else {\n        fragColor = vec4(0.,0.,0.,1.0);\n\t}\n}\n","name":"Buf A","description":"","type":"buffer"}]}