{"ver":"0.1","info":{"id":"mtGyWh","date":"1701811982","viewed":28,"name":"Area Light Example","username":"ediecomas","description":"private","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["private"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n#define USE_AREA 1\n\n//------------------------------------------------------------------------------\n// Distance field functions\n//------------------------------------------------------------------------------\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nvec2 scene(in vec3 position) {\n    vec2 scene = \n          vec2(sdSphere(position - vec3(0.0, 0.0, 0.0), 0.4), 5.0);\n    return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\nfloat D_GGX(float NdotH, float alphaGPow2, float theta) {\n\t\n      float d = NdotH * NdotH * (alphaGPow2 - 1.0) + 1.0;\n      // The divide by pi for the NDF is already in directional_light_color\n      // below\n        float alphaPrimeG = saturate(sqrt(alphaGPow2) + .5 * tan(theta));\n      #if USE_AREA == 1\n      return (alphaPrimeG * alphaPrimeG) / (d * d);\n      #else \n      return alphaGPow2 / (d*d);\n      #endif\n}\n\nfloat V_SmithGGXCorrelated(float NdotL, float alphaGPow2, float NdotV) {\n      float GGXV = NdotL * sqrt(NdotV * (NdotV - alphaGPow2 * NdotV) + alphaGPow2);\n      float GGXL = NdotV * sqrt(NdotL * (NdotL - alphaGPow2 * NdotL) + alphaGPow2);\n      return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(vec3 f0, float VdotH) {\n      float theta = 1.0 - VdotH;\n      theta *= theta * theta * theta * theta;\n      vec3 fresnel = f0 + (vec3(1.0) - f0) * theta;\n      return fresnel;\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n\n\nvec3 fresnel (float NdotV, vec3 diffuseColor, float metallic){\n    float f0 = 0.04;\n    float f90 = mix(1.0, f0, 0.2);\n    float fresnelPower = pow(1.0 - NdotV, 5.0);\n    float f = (f0 + (f90 - f0) * saturate(fresnelPower));\n    vec3 specularFactor = mix(vec3(f), diffuseColor, vec3(metallic));\n    return specularFactor;\n}\n\n\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance, vec2 uv) {\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n        vec3 ray = vec3(0.0);\n\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(1.0, 0.7, -0.5));\n        vec3 r = normalize(reflect(direction, n));\n        float theta = 0.15;\n        float tanTheta = (tan(theta));\n        float cosTheta = (cos(theta));\n\n        float dotLR = (dot(l, r));\n        vec3 projR = (dotLR * l);\n        \t\n        vec3 l_prime = normalize(projR + normalize(r - projR) * abs(dotLR) * tanTheta);\n        l_prime = (dotLR < 0.0) ? -l_prime : l_prime;\n        l_prime = (dotLR >= cosTheta) ? r : l_prime;\n        vec3 h = normalize(l + v);\n        \n        // Directional light impl\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n        float VdotH = saturate(dot(v, h));\n        \n        // Area light impl\n        vec3 h_prime = normalize(l_prime + v);\n        float NoL_prime = saturate(dot(n, l_prime));\n        float NoH_prime = saturate(dot(n, h_prime));\n        float LoH_prime = saturate(dot(l_prime, h_prime));\n        float VdotH_prime = saturate(dot(v, h_prime));\n\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n        if (material < 16.0) {\n            // Metallic objects\n            baseColor = vec3(0.3, 0.0, 0.0);\n            // aniso\n            // roughness = 1.0;\n            // specular \n            roughness = 0.2;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        float f0 = 0.04;\n\n        float attenuation = 1.0;\n\n        // specular BRDF\n\n        #if USE_AREA == 1\n        float D = D_GGX(NoH_prime, linearRoughness * linearRoughness, theta);\n        float V = V_SmithGGXCorrelated( VdotH_prime, linearRoughness * linearRoughness, NoV);\n        vec3  F = F_Schlick(vec3(0.04),VdotH_prime);\n        #else \n        float V = V_SmithGGXCorrelated( VdotH, linearRoughness * linearRoughness, NoV);\n        vec3  F = F_Schlick(vec3(0.04),VdotH);\n        float D = D_GGX(NoH, linearRoughness * linearRoughness, theta);\n\n        #endif \n        vec3 Fr = (D * V) * F;\n        \n        vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n        // diffuse BRDF\n        vec3 Fd = (diffuseColor * NoL);\n        color = Fd + Fr;\n  \n\n\n    }\n\n    return vec3(color);\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 0.8, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin.x += 1.7 * cos(  0.2);\n    origin.z += 1.7 * sin( 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance,  p);\n\n    // Tone mapping\n    color = Tonemap_ACES(color);\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}