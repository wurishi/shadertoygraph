{"ver":"0.1","info":{"id":"cdSSDG","date":"1670781260","viewed":65,"name":"3D-ish Gradient Noise","username":"surma","description":"noise","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint esgtsa(uint s)\n{\n    s = (s ^ 2747636419u) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    s = (s ^ (s >> 16u)) * 2654435769u;// % 4294967296u;\n    return s;\n}\n\nmat3 translation(vec2 p) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        p.x, p.y, 1.0\n    );\n}\n\nmat3 scale(vec2 p) {\n    return mat3(\n        p.x, 0.0, 0.0,\n        0.0, p.y, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nfloat rng(vec2 uv) {\n    //return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n    float f = 1000.;\n    return float(esgtsa(esgtsa(uint(uv.x * f)) + uint(uv.y * f)))/float(1<<30) ;\n}\n\nvec3 gradient(vec3 uv) {\n    float yrot = rng(uv.xz) * 2. * 3.1415;\n    float zrot = rng(uv.xy) * 2. * 3.1415;\n    return mat3(\n        cos(yrot), 0., -sin(yrot),\n        0.,  1., 0.,\n        sin(yrot), 0., cos(yrot)\n        )*mat3(\n        cos(zrot), sin(zrot), 0.,\n        -sin(zrot), cos(zrot), 0.,\n        0., 0., 1\n        ) * vec3(1., 0., 0.);\n    //return mat2(cos(alpha), sin(alpha), -sin(alpha), cos(alpha)) * vec2(1.0, 0.0);\n    //return normalize(vec2(rng(uv), rng(uv + vec2(1.))));\n    \n}\n\nfloat gradient_noise(vec3 uv) { \n    vec3 w = smoothstep(vec3(0.), vec3(1.), fract(uv));\n    vec3 ldb = floor(uv);\n    vec3 ldf = ldb + vec3(0., 0., 1.);\n    vec3 lub = ldb + vec3(0., 1., 0.);\n    vec3 luf = ldb + vec3(0., 1., 1.);\n    vec3 rdb = ldb + vec3(1., 0., 0.);\n    vec3 rdf = ldb + vec3(1., 0., 1.);\n    vec3 rub = ldb + vec3(1., 1., 0.);\n    vec3 ruf = ldb + vec3(1., 1., 1.);\n\n\n    vec3 g_ldb = gradient(ldb);\n    vec3 g_ldf = gradient(ldf);\n    vec3 g_lub = gradient(lub);\n    vec3 g_luf = gradient(luf);\n    vec3 g_rdb = gradient(rdb);\n    vec3 g_rdf = gradient(rdf);\n    vec3 g_rub = gradient(rub);\n    vec3 g_ruf = gradient(ruf);\n    \n    float v_ldb = dot(g_ldb, uv - ldb);\n    float v_ldf = dot(g_ldf, uv - ldf);\n    float v_lub = dot(g_lub, uv - lub);\n    float v_luf = dot(g_luf, uv - luf);\n    float v_rdb = dot(g_rdb, uv - rdb);\n    float v_rdf = dot(g_rdf, uv - rdf);\n    float v_rub = dot(g_rub, uv - rub);\n    float v_ruf = dot(g_ruf, uv - ruf);\n\n    \n    return mix(\n            mix(\n                mix(v_ldb, v_ldf, w.z),\n                mix(v_lub, v_luf, w.z),\n                w.y\n            ),\n            mix(\n                mix(v_rdb, v_rdf, w.z),\n                mix(v_rub, v_ruf, w.z),\n                w.y\n            ), w.x) + 0.5;\n}\n\nfloat fbm_gradient_noise(vec3 uv, float num_octaves) {\n    float acc = 0.0;\n    float att = 0.5;\n    float scale = 1.;\n    for(float i = 1.; i <= num_octaves; i++) {\n        acc += gradient_noise(uv * pow(2., i - 1.)) * pow(.5, i);\n    }\n    // a*r^0 + a*r^1 + ...+ a*r^(n-1)\n    // = a * sum[i=0...n](r^i)\n    // = a * [(1-r^n) / (1 - r)]\n    float normalize_factor = (1. - pow(0.5, num_octaves+1.)) / (1. - 0.5) - 1.;\n    return acc / normalize_factor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_in = fragCoord / iResolution.xy;\n\n    float s = log(iMouse.x / iResolution.x) / 2.;\n    vec2 offset = vec2(1000., 1000.);\n         \n    vec2 uv = (inverse(translation(vec2(.5)) * scale(vec2(s)) * translation(-1. * offset)) * vec3(uv_in, 1.)).xy;\n    vec3 uv_z = vec3(uv, iMouse.y / iResolution.y * 2.);\n\n    // Output to screen\n    vec4 white = vec4(1.);\n    vec4 black = vec4(vec3(0.), 1.);\n    vec4 uv_color = vec4(fract(uv), 0., 1.);\n    fragColor = mix(\n        mix(uv_color, black, .7), \n        white, \n        pow(fbm_gradient_noise(uv_z, 3.0), 4.)\n    );\n}","name":"Image","description":"","type":"image"}]}