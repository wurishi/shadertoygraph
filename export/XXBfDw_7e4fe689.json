{"ver":"0.1","info":{"id":"XXBfDw","date":"1729539274","viewed":117,"name":"BristorBrot_3D","username":"dougfractal","description":"BristorBrot raymarch","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal","raymarch","distanceestimation","3dfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" //Shder by Doug Bristor https://www.shadertoy.com/user/dougfractal\n        /*--------------------------------------------------------------------------------------\n        License CC0 - http://creativecommons.org/publicdomain/zero/1.0/\n        To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n        ----------------------------------------------------------------------------------------\n        ^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n        - Doug Bristor\n        \n        BristorBrot_abs updated to use acos to control sign : \"sign = acos(r/ length(z.yz) )>0.0 ? sign :-sign;\"\n        \n        */\n        /*\n        uniform float iTime;\n        uniform vec2 iResolution;\n        uniform sampler2D textureSampler;\n        \n        varying vec3 vPosition;\n        varying vec2 vUV;\n        #define iChannel0 textureSampler\n        \n        */\n        \n     #define Epsilon  .00077192  \n     // .000197192\n#define RenderDistance 6.0  \n#define MAX_STEP 100 \n\n\nint drawType=0 ;  // [ 0: BristorBrot ,  1:  BristorBrot_abs,  2: Mandelbulb ]\nbool drawJulia = false ;\n \nbool mouse = false; \n\nfloat Power = 2.0;\n\nvec3 CamPos = vec3(-0.5, .09, -6.5);\nvec3 CamRot = vec3(.15, .1, .0);\nfloat CamFocalLength = 2.0;    \n\n        float rotayz=.0;\n      float rotaxz =.0;\n     \n\n        mat2 rotate(float a) {\n            float s = sin(a);\n            float c = cos(a);\n            return mat2(c, -s, s, c);\n        }\n        \n  \n float BristorBrot(vec3 z, vec3 pos ) {\n   float r, dr=1.0;\n  int i=MAX_STEP;\n  while ((r = length(z)) < RenderDistance  &&  i-- > 0 ) { \n    z = vec3(  \n            z.x*z.x - z.y*z.y - z.z*z.z,\n            z.y*(2.0*z.x - z.z),\n            z.z*(2.0*z.x + z.y)\n            ) + pos;\n    dr = 2.0 * r * dr + 1.0;   \n}\n  return 0.5*log(r)*r/dr;\n }\n \n \n    \n   // Bristorbrot (abs) formula     \n float BristorBrot_abs(vec3 z, vec3 pos ) {\n   float r = length(z), dr=1.0, sign=-1.0;\n \n   int i=MAX_STEP;\n  while ((r = length(z))< RenderDistance  &&  i-- > 0 ) { \n     sign = acos(r/ length(z.yz) )>0.0?  sign :-sign;\n    \n    z = vec3(  \n            z.x*z.x - z.y*z.y - z.z*z.z,\n            z.y*(2.0*z.x - abs(z.z)*sign),    \n            z.z*(2.0*z.x + abs(z.y)*sign)\n            ) + pos;      \n    dr =2.0 * r * dr + 1.0;  \n    r = length(z);\n}\n  return 0.5*log(r)*r/dr; \n }\n \n \nfloat Mandelbulb(vec3 z, vec3 pos ) { \n   float dr = 1.0, theta, phi, r = length(z);\n      int i=MAX_STEP;\n  while ((r = length(z)) < RenderDistance  &&  i-- > 0 ) {\n        \n        theta = acos(z.y/r);\n\t\tphi = atan(z.z,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n        \n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tz = pow(r,Power)*vec3(sin(theta)*cos(phi), cos(theta), sin(phi)*sin(theta)) + pos;\n \t\n \n }\n  return 0.5*log(r)*r/dr; \n }\n \n\n        \n float distanceEstimation(vec3 pos) {\nif (mouse )  {\n    pos.yz *= rotate(rotayz);\n    pos.xz *= rotate(rotaxz);\n    }\n    else {\n     float time = float(iFrame)*.001 * 3.1429 *2.   ;\n     pos.yz *= rotate(-time);\n    pos.xz *= rotate(time*.537);\n    }\n\n     float r = length(pos);\n    if(r > RenderDistance  ) return r-1.2;\n\n   vec3 z = pos;\n  \n  if (drawJulia) {\n  \n  vec3 julia = vec3(-.833,.23432,.01);\n    julia.x -=cos(iTime*0.1)*.325;\n    julia.y -=cos(iTime*0.1)*.1;\n    pos = julia;   \n}\n \n     if (drawType==0) \n         return  BristorBrot( z, pos ) ;\n     \n     return drawType==1 ? BristorBrot_abs( z, pos ) : \n         Mandelbulb( z, pos ); \n            \n}\n         \n        \n        \n        \nvec3 normalEstimation(vec3 pos){\n   \n  vec3 xDir = vec3(Epsilon, 0.0, 0.0);\n  vec3 yDir = vec3(0.0, Epsilon, 0.0);\n  vec3 zDir = vec3(0.0, 0.0, Epsilon);\n\n  float normalX = distanceEstimation(pos + xDir)\n                - distanceEstimation(pos - xDir);\n  float normalY = distanceEstimation(pos + yDir)\n                - distanceEstimation(pos - yDir);\n  float normalZ = distanceEstimation(pos + zDir)\n                - distanceEstimation(pos - zDir);\n\n  return normalize(vec3(normalX, normalY, normalZ));\n}\n\n\n\n\nbool hit(inout vec3 pos, in vec3 dir) { \n\n\n    for(int i = 0; i < MAX_STEP; i++){\n        float dist = distanceEstimation(pos);\n        if(dist < Epsilon ) break;\n        if(dist > RenderDistance) return false;\n        pos += dist*dir;\n    }\n    for(int i = 0; i < 4; i++){\n        float dist = distanceEstimation(pos)-Epsilon;\n        pos += dist*dir;\n    } \n    return true;\n}\n        \n\n   \nvec4 colorAndDepth(vec3 pos, vec3 dir){\n    vec3 normal;\n    vec4 c = vec4(0,0,0, 1.0);\n    \n          \n  \n    \n    \n    \n    if(hit(pos, dir)){\n    \n          normal = normalEstimation(pos);\n          c.rgb = normal;\n    \n        vec3 light = vec3(0, -1, -2);\n        \n        // Calculate diffuse lighting by taking the dot product of \n        // the light direction (light-p) and the normal.\n        float dif = clamp(dot(normal, normalize(light - pos)), 0., 1.);\n\t\t\n        // Multiply by light intensity (5) and divide by the square\n        // of the distance to the light.\n        dif *= 5. / dot(light - pos, light - pos);\n   \n        c = vec4(mix(vec3(pow(dif, 0.4545)) ,normal.rbg , .25 ), 1.);     // Gamma correction\n    \n\n    \n    }\n      return c;\n}\n\nmat3 rotationMatrix(vec3 rotEuler){\n    float c = cos(rotEuler.x), s = sin(rotEuler.x);\n    mat3 rx = mat3(1, 0, 0, 0, c, -s, 0, s, c);\n    c = cos(rotEuler.y), s = sin(rotEuler.y);\n    mat3 ry = mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n    c = cos(rotEuler.z), s = sin(rotEuler.z);\n    mat3 rz = mat3(c, -s, 0, s, c, 0, 0, 0, 1);\n    \n    return rz * rx * ry;\n}\n\n\n     void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n          \n          vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n            vec3 ro = CamPos ; \n            vec3 rd = normalize(vec3(uv, CamFocalLength));\n     \n     if( iMouse.z > 0.0 )  {\n       mouse = true;\n         rotayz =  (iMouse.y/iResolution.y-.5)*3.1429;\n       rotaxz =  (iMouse.x/iResolution.x-.5)*3.1429;\n    }\n        fragColor = colorAndDepth(ro, rd);\n        }\n        \n/*\nvoid main() \n{\n    mainImage(gl_FragColor, vUV * iResolution.xy);\n}\n*/","name":"Image","description":"","type":"image"}]}