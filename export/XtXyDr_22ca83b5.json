{"ver":"0.1","info":{"id":"XtXyDr","date":"1504258129","viewed":340,"name":"aFranks Oceanic + IQ gnoised v8","username":"Serg","description":"Used Frank Hugenroth's Oceanic as a starting point (thanks for commenting); IQs noise functions with derivatives and ihash. Filmic tonemapping by Paniq\nThe point being, replace noise functions with IQ derivative warped noise to better mimic natural motion","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["clouds","water","ocean","derivatives","gradientnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NO_POST_PRO\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n#ifdef NO_POST_PRO\n    fragColor = textureLod(iChannel0, q, 0.0);\n    return;\n#endif\n    vec2 v = -1.0 + 2.0*q;\n    v.x *= iResolution.x/ iResolution.y;\n    \n    float vign = smoothstep(4.0, 0.6, length(v));\n    \n    vec2 centerToUv = q-vec2(0.5);\n\tvec3 aberr;\n    aberr.x = textureLod(iChannel0, vec2(0.5)+centerToUv*0.995,0.0).x; \n    aberr.y = textureLod(iChannel0, vec2(0.5)+centerToUv*0.997, 0.0).y;\n    aberr.z = textureLod(iChannel0, vec2(0.5)+centerToUv, 0.0).z;\n    fragColor = vec4(pow(vign*aberr, vec3(0.2+1.0/2.2)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// THANK YOU! IQ for too many reasons to list :)\n// THANK YOU! Thomas Schander for the gold mine in \"Enscape Cube\" - https://www.shadertoy.com/view/4dSBDt\n// THANK YOU! Frank Hugenroth for the template I started with, in \"Oceanic\" - https://www.shadertoy.com/view/4sXGRM\n//\n// The point of this is to show how derivatives can be used to better approximate water and cloud look and motion.\n// Each noise octave is displaced (positively for clouds, negatively for water) by the previous iteration derivatives.\n// The look is improved because displacing the noise is more natural looking than using abs(), and slower :)\n//\n// Clouds: slice based volumetric height-clouds with god-rays, density, sun-radiance/shadow\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// noise and raymarching based on concepts and code from shaders by inigo quilez\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n// some variables to change :)\n\n#define RENDER_GODRAYS    0   // set this to 1 to enable god-rays\n//#define RENDER_GODRAYS    0    // disable god-rays\n\n#define RENDER_CLOUDS 0\n#define RENDER_WATER  1\n\nfloat waterlevel = 1000.0;        // height above water\nfloat wavegain   = 50.0;       // wave height\nfloat large_waveheight = 1.0; // change to adjust the \"heavy\" waves (set to 0.0 to have a very still ocean :)\nfloat small_waveheight = 1.0; // change to adjust the small waves\nfloat roughness = 0.5;\n\nvec3 fogcolor      = vec3( 0.7, 0.6, 0.5 );              \nvec3 skybottom     = vec3(0.93,0.7,0.6) * 2.0;\nvec3 skytop        = vec3(0.08, 0.25, 0.5) * 2.0;\nvec3 reflskycolor  = vec3(0.05, 0.2, 0.5);\nvec3 watercolor    = vec3(0.05, 0.15, 0.3) * 0.5;\nvec3 scattercolor  = vec3(0.05, 0.18, 0.5) * 0.8;\nvec3 foamcolor     = vec3(1.0,1.0,1.0) * 1.0;\nvec3 cloudcol      = vec3(0.93,0.96,0.95);\nvec3 lightcol      = vec3(0.93,0.7,0.5)*2.0;\n\nvec3 light         = normalize( vec3( 0.0, 0.25,  0.9 ) );\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\n////////////////////////// 2D WITH ANALYTICAL DERIVATIVES - BY FRANK HOSHKIN //////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////\nvec2 hash2d( in vec2 x )  // thanks to \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n    \n}\n\n\n\n/////////////////////// 2D GRADIENT NOISE WITH ANALYTICAL DERIVATIVES - BY IQ //////////////////////\n////////////////////// return gradient noise (in x) and its derivatives (in yz)/////////////////////\nvec3 gnoised( in vec2 p )\n{\n  ;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n    \n    vec2 ga = hash2d( i + vec2(0.0,0.0) );\n    vec2 gb = hash2d( i + vec2(1.0,0.0) );\n    vec2 gc = hash2d( i + vec2(0.0,1.0) );\n    vec2 gd = hash2d( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( 0.5 + 0.5 * (va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd)),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n////////////////////////////////////// WATER FRACTAL WITH CUSPING ///////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////////////\n///////// The cusping is achieved by displacing each octave by the previous derivatives /////////////\nconst float scale  = 0.005;\nconst float height  = 10.0;\n\nvec4 waterd( in vec2 x, in int octaves, in float rough )\n{\n    vec2 dir = vec2(0.0, 1.0) * iTime * 0.25;\n    float a = 0.0;\n    float b = 1.0;\n\tfloat f = 1.0;\n    vec2  d = vec2(0.0);\n    vec2 stretch = vec2(0.5, 1.0);\n    \n    for( int i=0; i<octaves; i++ )\n    {\n        vec3 n = gnoised(x * f * scale * stretch + dir + (-d * 0.25));\n        stretch = mix(stretch, vec2(1.0, 1.0), float(i)/float(octaves));\n        a += b*n.x;                   // accumulate values\t\t\n        d += b*n.yz*f*stretch;        // accumulate derivatives\n        b *= rough;                   // amplitude decrease\n        f *= 2.0;                     // frequency increase\n    }\n\n\ta *= wavegain;\n\td *= wavegain*scale;\n\t\n\t// compute normal based on derivatives\n\treturn vec4( a, normalize( vec3(-d.x,1.0,-d.y) ) );\n}\n\n\n////////////////////////////////////// FLOWING HASH - BY IQ /////////////////////////////////////////\n/////////////////////////////////////////////////////////////////////////////////////////////////////\nvec2 hashf( in vec2 x, in float flow )\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );             // replace all of\n    x = x*k + k.yx;                                          // this by something \n    float h = fract( 16.0 * k.x*fract( x.x*x.y*(x.x+x.y)) ); // better\n    \n    float a = 6.2831*h + flow;\n    return vec2( cos(a), sin(a) );\n}\n\n\n\n/////////////////////////////////// MIE Fit - by Thomas Schander /////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////\nfloat numericalMieFit(float costh)\n{\n    // This function was optimized to minimize (delta*delta)/reference in order to capture\n    // the low intensity behavior.\n    float bestParams[10];\n    bestParams[0]=9.805233e-06;\n    bestParams[1]=-6.500000e+01;\n    bestParams[2]=-5.500000e+01;\n    bestParams[3]=8.194068e-01;\n    bestParams[4]=1.388198e-01;\n    bestParams[5]=-8.370334e+01;\n    bestParams[6]=7.810083e+00;\n    bestParams[7]=2.054747e-03;\n    bestParams[8]=2.600563e-02;\n    bestParams[9]=-4.552125e-12;\n    \n    float p1 = costh + bestParams[3];\n    vec4 expValues = exp(vec4(bestParams[1] *costh+bestParams[2], bestParams[5] *p1*p1, bestParams[6] *costh, bestParams[9] *costh));\n    vec4 expValWeight= vec4(bestParams[0], bestParams[4], bestParams[7], bestParams[8]);\n    return dot(expValues, expValWeight);\n}\n\n//////////////////////////////////////////// RENDER SKY //////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 rendersky(in vec3 rd, \n               in vec3 lightcol, \n               in vec3 skytop, \n               in vec3 skybottom, \n               in vec3 light, \n               in vec3 campos, \n               in int samples,\n               in float SunSize)\n{\n    rd = normalize(rd);\n    \n    vec3 skycol = vec3(0.0);\n    float mu = dot(rd,light);\n    float sundot = (0.5 * mu) + 0.5;\n    \n    // mix to an averager of top and bottom according to sundot\n    skybottom = mix((skybottom + skytop) /2.0, skybottom, sundot); \n    \n    float t = pow(1.0-dot(rd, vec3(0.0,1.0,0.0)), 15.0);\n    skycol = mix(skytop, skybottom, clamp(t,0.0,1.0));\n    // sun\n    skycol += 5000.0 * lightcol * smoothstep(1.0 - SunSize, 1.0, sundot);\n     \n    // sun haze\n    skycol += 0.7 * lightcol * pow(sundot, 5.0 );\n    //skycol += 0.25 * lightcol * numericalMieFit(mu);\n    return skycol;\n\n}\n\n\n////////////////////////////// SCHLICK FRESNEL - by Thomas Schander //////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////\nvec4 fresnel(in vec3 dir, in vec3 N, in float fzero)\n{\n    vec4 fresnelout = vec4(0.0);\n    \n    vec3 L = normalize(vec3(0.0)+reflect(dir, N));\n    vec3 V = -dir;\n\tfloat NoV = clamp(abs(dot(N, V))+1e-5,0.0, 1.0);\n    float NoL = max(0.0, dot(N, L));\n    float VoH = max(0.0, dot(V, normalize(V+L)));    \n    float fresnel = fzero + (1.0 - fzero) * pow(1.0 - VoH,5.0);  \n    \n    fresnelout.xyz = L;\n    fresnelout.w = fresnel;\n    return fresnelout;\n}\n\n\n/////////////////////////////// INTERSECTION FUNCTION BY FRANK HUGENROTH /////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n// fog and water intersection function.\n// 1st: collects fog intensity while traveling\n// 2nd: check if hits the water surface and returns the distance\nbool trace(in vec3 rStart, in vec3 rDirection, in float sundot, out float fog, out float dist)\n{\n  float h = 20.0;\n  float t = 0.0;\n  float st = 1.0;\n  float alpha = 0.1;\n  float asum = 0.0;\n  vec3 p = rStart;\n\t\n  for( int j=1; j<100; j++ )\n  {\n    /*/ some speed-up if all is far away...\n    if( t>500.0 ) \n      st = 2.0;\n    else if( t>800.0 ) \n      st = 5.0;\n    else if( t>1000.0 ) \n      st = 12.0;\n*/\n    p = rStart + t*rDirection; // calc current ray position\n \n    vec4 mywater = waterd(p.xz, 5, roughness);\n\t      \n    h = p.y - ((mywater.x) + -15.0);\n\n    if( h<0.1 ) // hit the water?\n    {\n      dist = t; \n      fog = asum;\n      return true;\n    }\n\n    if( p.y>4050.0 ) // lost in space? quit...\n      break;\n    \n    // speed up ray if possible...    \n    if(rDirection.y > 0.0) // look up (sky!) -> make large steps\n      t += 30.0 * st;\n    else\n      t += max(1.0,1.0*h)*st;\n  }\n\n  dist = t; \n  fog = asum;\n  if (h<10.0)\n   return true;\n  return false;\n}\n\n\nvec3 camera( float time )\n{\n  return vec3( 50.0 * sin(2.5+1.57*time), 10.0, 120.0*time );\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 xy = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n  vec2 s = xy*vec2(1.75,1.0);\n    \n  light.x = sin(iTime*0.5)*3.15409;\n  light = normalize(light);\n  lightcol *= 2.0;\n\n  ////////////////// Camera setup by Frank Hugenroth 03/2013 //////////////////////\n  /////////////////////////////////////////////////////////////////////////////////  \n  float time = (iTime+13.5+44.)*0.05;\n    \n  vec3 campos = camera( time * 1.0);\n  vec3 camtar = camera( time + 1.4 * 1.0);\n    \n  campos.z += iTime * 5.0;\n  camtar.z += iTime * 5.0;\n    \n  campos.y = 300.0;\n  camtar.y = 200.0;\n  //campos.y = 300.0 + (sin(iTime * 1.0) * 100.0);// + max(waterlevel+30.0, waterlevel+10.0 + 10.0*sin(time*2.0));\n  //camtar.y = campos.y*1.0;\n    \n\n  float roll = 0.14 * sin(time * 5.2);\n  vec3 cw = normalize(camtar-campos);\n  vec3 cp = vec3(sin(roll), cos(roll),0.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  vec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw );\n\n  float sundot = (0.5*dot(rd,light))+0.5;\n  \n  skybottom *= mix(0.5, 1.0,sundot);\n  skybottom *= 1.0+(pow(sundot, 10.0)*0.25);\n\n  vec3 col;\n  float fog=0.0, dist=0.0;\n\n  if (!trace(campos,rd,sundot, fog, dist)) // If it didnt hit the water render the sky\n  {\n    col += rendersky(rd, lightcol, skytop, skybottom, light, campos, 100, 0.0002); \n  }\n    \n  else // if it did hit the water\n  {\n \n      \n#if RENDER_WATER    \n    \n    vec3 watercol = vec3(0.0);\n    vec3 albedo = vec3(0.0);\n      \n    //render water\n    vec3 wpos = campos + dist*rd; // calculate position where ray meets water\n      \n    //get the water\n    float distaa = mix(0.5, 1.0, 1.0-(1.0-exp(-pow(0.0003 * dist, 3.0))));\n    int octaa = 8;\n    \n    vec3 e = vec3(0.001,0.0,0.0); \n    vec3 calcNormal = vec3(waterd(wpos.xz-e.xy, octaa, roughness * distaa).x - \n                                      waterd(wpos.xz+e.xy, octaa, roughness * distaa).x,\n                           \t\t\t  2.0*e.x,\n                           \t\t\t  waterd(wpos.xz-e.yx, octaa, roughness * distaa).x - \n                                      waterd(wpos.xz+e.yx, octaa, roughness * distaa).x);\n      \n    float curvature = smoothstep(0.21, 0.24, distance(calcNormal, vec3(0.0,0.0,0.0)) * 100.0);\n    calcNormal = normalize(calcNormal);  \n        \n\n      \n    vec4 waterren = waterd(wpos.xz, 6, roughness * distaa)/(wavegain*1.2); /////////////////////////////////////\n   \n    // get the reflected ray direction\n    vec4 fres = fresnel(rd, calcNormal, 0.02);\n      \n    float fresr = fres.w;                        // reflecting amount\n    float frest = (1.0-fresr);                   // transmission amount\n      \n    //Light dotprod\n    float diff = max(dot(normalize(light), calcNormal), 0.25);  \n      \n    // Albedo\n    albedo = mix(watercolor, scattercolor, smoothstep(0.4, 1.5, waterren.x));\n    albedo = mix(albedo, foamcolor, mix(0.25, 1.0, smoothstep(0.8, 1.0, waterren.x)) * curvature);\n    albedo = mix(albedo, foamcolor, mix(0.0, 0.5, smoothstep(0.9, 1.5, waterren.x))); \n      \n    // Shade  \n    watercol = rendersky(fres.xyz, lightcol, skytop, skybottom, light, campos, 50, 0.004) * fresr; // reflecting sky-color \n    watercol += 0.6 * frest * lightcol * albedo;\n    //watercol += foamcolor * curvature * diff;\n\n    //mix over sky colour\n    col = mix(watercol, rendersky(rd, lightcol, skytop, skybottom, light, campos, 50, 0.0002), pow(1.0 - abs(rd.y), 30.0));\n\n#endif\n\n    \n  }\n \n  fragColor=vec4(col * 1.0, 1.0);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemapACES( vec3 x )\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec2   blurRadius    = vec2(20.0) / iResolution.xy;\n\n    vec4 sum = vec4(0.0);\n    float NUM_SAMPLES = 0.;\n    float phiOffset = hash(dot(fragCoord.xy, vec2(1.12,2.251)) + iTime);\n    for(float i = 0.; i < NUM_SAMPLES; i++)\n    {\n        vec2 r = blurRadius * i / NUM_SAMPLES;\n        float phi = (i / NUM_SAMPLES + phiOffset) * 2.0 * 3.1415926;\n        vec2 uv = q + vec2(sin(phi), cos(phi))*r;\n        sum += textureLod(iChannel0, uv, 0.0);\n    }\n    const float BLOOM_AMOUNT = 0.01;\n    //sum.xyz = mix(textureLod(iChannel0, q, 0.0).xyz, sum.xyz / NUM_SAMPLES, BLOOM_AMOUNT);\n    sum.xyz = textureLod(iChannel0, q, 0.0).xyz;\n    // Make it look as if some auto exposure magic is going on\n    float exposure = 1.0;// * (1.0+0.2*sin(0.5*iTime)*sin(1.8*iTime));\n\tfragColor = vec4(tonemapACES(exposure*sum.xyz), 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nivec2 offsets[8] = ivec2[8]( ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0), ivec2(0, -1), \n\tivec2(0, 1), ivec2(-1, 0));\n\nvec3 RGBToYCoCg( vec3 RGB )\n{\n\tfloat Y = dot(RGB, vec3(  1, 2,  1 )) * 0.25;\n\tfloat Co= dot(RGB, vec3(  2, 0, -2 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\tfloat Cg= dot(RGB, vec3( -1, 2, -1 )) * 0.25 + ( 0.5 * 256.0/255.0 );\n\treturn vec3(Y, Co, Cg);\n}\n\nvec3 YCoCgToRGB( vec3 YCoCg )\n{\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - ( 0.5 * 256.0 / 255.0 );\n\tfloat Cg= YCoCg.z - ( 0.5 * 256.0 / 255.0 );\n\tfloat R= Y + Co-Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co-Cg;\n\treturn vec3(R,G,B);\n}\n\n//#define NO_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;    \n    vec3 new = RGBToYCoCg(textureLod(iChannel0, q, 0.0).xyz);\n    vec3 history = RGBToYCoCg(textureLod(iChannel1, q, 0.0).xyz);\n    \n    vec3 colorAvg = new;\n    vec3 colorVar = new*new;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 fetch = RGBToYCoCg(texelFetch(iChannel0, ivec2(fragCoord.xy)+offsets[i], 0).xyz);\n        colorAvg += fetch;\n        colorVar += fetch*fetch;\n    }\n    colorAvg /= 9.0;\n    colorVar /= 9.0;\n    float gColorBoxSigma = 0.5;\n\tvec3 sigma = sqrt(max(vec3(0.0), colorVar - colorAvg*colorAvg));\n\tvec3 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec3 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    history = clamp(history, colorMin, colorMax);\n  \n\tfragColor = vec4(YCoCgToRGB(mix(new, history, 0.95)), 1.0);\n#ifdef NO_AA\n    fragColor = vec4(YCoCgToRGB(new), 1.0);\n#endif\n}\n","name":"Buffer C","description":"","type":"buffer"}]}