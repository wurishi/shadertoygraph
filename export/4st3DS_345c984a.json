{"ver":"0.1","info":{"id":"4st3DS","date":"1452003177","viewed":824,"name":"website background #2","username":"104","description":"just some quick 2d work for a website. Originally very dark, to allow text over top. But for shadertoy.com I made it brighter.","likes":36,"published":1,"flags":0,"usePreview":0,"tags":["minimal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159;\nconst float pi2 = pi * 2.;\n\nconst vec2 cellSizePixels = vec2(192.,192.);// best results = any multiple of 2^iterations\nfloat edgeSizePixels = 2.5;\nconst float iterations = 5.;\n\n\nvec2 q(vec2 x, vec2 p)\n{\n    return floor(x/p)*p;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rand3(vec2 p)\n{\n    vec3 p2 = vec3(p, rand(p));\n    return\n        fract(sin(vec3(\n            dot(p2,vec3(127.1,311.7,427.89)),\n            dot(p2,vec3(269.5,183.3,77.24)),\n            dot(p2,vec3(42004.33,123.54,714.24))\n            ))*43758.5453);\n}\n\nfloat sdAxisAlignedRect(vec2 uv, vec2 tl, vec2 br)\n{\n  \tvec2 d = max(tl - uv, uv - br);\n    return length(max(vec2(0.0), d)) + min(0.0, max(d.x, d.y));\n}\n\nmat2 rot2D(float r)\n{\n    float c = cos(r), s = sin(r);\n    return mat2(c, s, -s, c);\n}\nfloat pulse(float x, float pulseWidth, float totalPeriod)\n{\n    x = mod(x,totalPeriod);\n    x -= pulseWidth /= 2.;\n    return 1.-smoothstep(0.,pulseWidth, abs(x));\n}\n\n\n\nvoid mainImage( out vec4 o, in vec2 i)\n{\n\tvec2 uv = i / iResolution.xy - .5;\n    vec2 uvn = uv;// screen / unwarped coords\n\n    uv += iMouse.xy *.1 / iResolution.xy;\n    \n\tif(iResolution.x > iResolution.y)\n\t\tuv.x *= iResolution.x / iResolution.y;\n\telse\n\t\tuv.y /= iResolution.x / iResolution.y;\n\n    \n    //uv *= 1.+sin(iTime*0.5)*.1;// zoom\n    uv -= .7;// offset rotation origin\n    float rotation = -(iTime+40.)*0.005;\n    //rotation = -0.2;// fixed-rot\n    uv *= rot2D(rotation);// rot\n    \n    vec2 cellSize = cellSizePixels / iResolution.x;\n\n    vec2 cellOrig;\n    float cellID;\n    float edgeSizePixels = 7.;\n\n    for(float i = 0.;i<iterations;i++)\n    {\n        cellSize *= .5;\n        edgeSizePixels *= .5;\n        cellOrig = q(uv, cellSize);\n        cellID = rand(cellOrig);\n        if(i/iterations > sin(cellID*6.28+iTime*.2)*.5+.3)\n            break;\n    }\n    edgeSizePixels = max(edgeSizePixels, 1.);\n    \n    //float cellID = rand(cellOrig);\n    float distToCenter = distance(uv, cellOrig+cellSize/2.)/(length(cellSize)/2.);\n    vec2 tl = cellOrig;\n    vec2 br = cellOrig + cellSize;\n    float distToEdge = sdAxisAlignedRect(uv, tl, br) / length(cellSize);// 0 = edge, -1 = center\n    \n    float edgeSize = edgeSizePixels/iResolution.x/length(cellSize);\n    float aEdge = smoothstep(-edgeSize, 0., distToEdge);\n    \n    float totalPulsePeriod = 10.;// in seconds\n    float highlightDuration = 1.2;\n    float highlightStrength = 1.7;\n    float highlight = pulse((cellID*totalPulsePeriod*totalPulsePeriod)+iTime,highlightDuration,totalPulsePeriod)*highlightStrength+1.;\n    \n    // cell background\n    vec3 cellColor = rand3(cellOrig);\n    o = vec4(cellColor.rgbb)*.3;\n    o *= highlight;\n    o *= 1.-distToCenter*.4;\n    \n    // edge color\n    vec4 edgeColor = vec4(0,0,0,1);\n    o = mix(o, edgeColor, aEdge);\n\n    // saturation\n    o = clamp(o,0.,1.);\n    //o = mix(o, vec4((o.r+o.g+o.b)/3.), sin(iTime)*.5+.5);\n    o = mix(o, vec4((o.r+o.g+o.b)/3.), .6);\n\n    // tint green / brightness\n    o *= vec4(.5,1,1,0)*2.;\n    \n    // noise\n    o.rgb += (rand3(uvn*iTime)-.5)*.1;\n\n    // vignette\n    uvn *= 1.1;\n    o *= 1.-dot(uvn,uvn);\n    \n    // gamma\n    o = clamp(o,0.,1.);\n    o = pow(o, vec4(1./1.2));\n}\n","name":"Image","description":"","type":"image"}]}