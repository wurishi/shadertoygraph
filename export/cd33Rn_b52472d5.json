{"ver":"0.1","info":{"id":"cd33Rn","date":"1676841388","viewed":366,"name":"Cube flips","username":"Bleuje","description":"Reproducing the structure of one of my gif animations\n(https://necessary-disorder.tumblr.com/post/674103325878370304)","likes":26,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","cube","isometric","flips"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by @etiennejcb\n// might need some optimization\n\nfloat PI;\nfloat HALF_PI;\n\nfloat mainCubeSize = 0.17;\nfloat timeFactor = 1.4;\n\n/////////////////////////////////////////////////\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n/////////////////////////////////////////////////\n\nstruct MapData\n{\n    float dist;\n    float type;\n    vec2 ab;\n    float dz;\n};\n\nMapData opUnion(MapData data1,MapData data2)\n{\n    if(data1.dist<=data2.dist)\n    {\n        return data1;\n    }\n    else\n    {\n        return data2;\n    }\n}\n\nfloat easingAmount2 = 2.0;\nfloat easer2(float p,float offset)\n{\n    return ease(mp01(p,(offset)/4.0,(0.25+offset)/4.0),easingAmount2);\n}\n\nvec3 subFlipTransform(vec3 pos,float p,float R,float orientation)\n{\n    p = mod(p,1.0);\n    \n    orientation = 2.*orientation-1.;\n    \n    if(p<=1.0/4.0)\n    {\n        float progress = easer2(p,0.);\n        pos -= vec3(R,R,0.);\n        pos.y -= -R;\n        pos.yz *= rot(progress*PI*orientation);\n        pos.y -= R;\n    }\n    else if(p<=2.0/4.0)\n    {\n        float progress = easer2(p,1.);\n        pos -= vec3(R,-R,0.);\n        pos.x -= -R;\n        pos.xz *= rot(progress*PI*orientation);\n        pos.x -= R;\n    }\n    else if(p<=3.0/4.0)\n    {\n        float progress = easer2(p,2.);\n        pos -= vec3(-R,-R,0.);\n        pos.y -= R;\n        pos.yz *= rot(-progress*PI*orientation);\n        pos.y -= -R;\n    }\n    else if(p<=4.0/4.0)\n    {\n        float progress = easer2(p,3.);\n        pos -= vec3(-R,R,0.);\n        pos.x -= R;\n        pos.xz *= rot(-progress*PI*orientation);\n        pos.x -= -R;\n    }\n    return pos;\n}\n\nMapData mapSingleFrame(vec3 pos,float param,float p)\n{\n    MapData res;\n    float l1 = mainCubeSize*0.96;\n    float l2 = 0.98*l1;\n    \n    \n    float squareDist1 = sdBox(pos,vec3(l1*1.02,l1*1.02,l1/19.0))-0.006;\n    float squareDist2 = sdBox(pos,vec3(l2,l2,l1/1.0));\n    \n    MapData frameData;\n    frameData.dist = max(squareDist1,-squareDist2);\n    frameData.type = 2.0;\n    \n    MapData smallTilesRes;\n    smallTilesRes.dist = 12345.;\n    smallTilesRes.type = 1.0;\n    \n    int K = 3;\n    for(int index=0;index<K;index++)\n    {\n        // flip orientation decision from fixed latest flip start time\n        // (flip orientation choice shouldn't change during flip)\n        float k = floor(4.0*(param+float(index)/3.0));\n        float paramStop = k/4.0 - float(index)/3.0;\n        float pStop = 6.0*paramStop/5.0;\n        float orientation = floor(mod(pStop*6.0+0.8,2.0));\n        \n        vec3 pos2 = subFlipTransform(pos,param+float(index)/3.0,l2/2.0,orientation);\n        \n        float tileL = l2/2.3;\n        \n        float boxDist = sdBox(pos2,vec3(tileL,tileL,l1/20.0))-0.012;\n        float holeDist = length(pos2.xy)-0.44*tileL;\n        \n        MapData localRes = smallTilesRes;\n        localRes.dist = max(boxDist,-holeDist);\n        localRes.type = 1.0;\n        localRes.ab = pos2.xy/tileL;\n        localRes.dz = pos2.z;\n        \n        smallTilesRes = opUnion(smallTilesRes,localRes);\n    }\n    \n    res = opUnion(frameData,smallTilesRes);\n    \n    return res;\n}\n\nfloat easingAmount1 = 2.4;\nfloat easer1(float q,float offset)\n{\n    return ease(mp01(q,(offset)/6.0,(0.6+offset)/6.0),easingAmount1);\n}\n\nvec3 transformFramePos(vec3 pos,float q)\n{\n  float p1 = easer1(q,0.);\n  float p2 = easer1(q,1.);\n  float p3 = easer1(q,2.);\n  float p4 = easer1(q,3.);\n  float p5 = easer1(q,4.);\n  float p6 = easer1(q,5.);\n  \n  float cubeL = mainCubeSize;\n  \n  pos.z -= cubeL;\n  \n  pos.y -= (-cubeL);\n  pos.yz *= rot(-3.0*p1*HALF_PI);\n  pos.y -= cubeL;\n  \n  pos.x -= (-cubeL);\n  pos.xz *= rot(3.0*p2*HALF_PI);\n  pos.x -= cubeL;\n  \n  pos.y -= cubeL;\n  pos.yz *= rot(3.0*p3*HALF_PI);\n  pos.y -= (-cubeL);\n  \n  pos.x -= cubeL;\n  pos.xz *= rot(-3.0*p4*HALF_PI);\n  pos.x -= (-cubeL);\n\n  pos.y -= (-cubeL);\n  pos.yz *= rot(-3.0*p5*HALF_PI);\n  pos.y -= cubeL;\n  \n  \n  pos.x -= (-cubeL);\n  pos.xz *= rot(3.0*p6*HALF_PI);\n  pos.x -= cubeL;\n  \n  return pos;\n}\n\nMapData map(vec3 pos)\n{\n    MapData res;\n    res.dist = 12345.0;\n    \n    vec3 q = pos;\n    \n    pos.xz *= rot(0.5*iTime*timeFactor);\n    pos.xy *= rot(0.35*iTime*timeFactor);\n    \n    float nbFaces = 6.0;\n    \n    vec3 savedPos = pos;\n    \n    int K = int(nbFaces-1.0);\n    float time = mod(iTime*0.25*timeFactor,1.0);\n    \n    for(int i=0;i<K;i++)\n    {\n        float p = (float(i)+time)/float(K);\n        float p2 = (float(i)+time)/nbFaces;\n        pos = transformFramePos(savedPos,p);\n        MapData singleFrame = mapSingleFrame(pos,p2,p);\n        res = opUnion(res,singleFrame);\n    }\n    \n    MapData cube;\n    cube.dist = sdBoxFrame(savedPos,vec3(0.63*mainCubeSize),0.01)-0.01;\n    cube.type = 0.0;\n    \n    res = opUnion(res,cube);\n\n    return res;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal(vec3 p) {\n\tvec2 off=vec2(0.001,0);\n\treturn normalize(map(p).dist-vec3(map(p-off.xyy).dist, map(p-off.yxy).dist, map(p-off.yyx).dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    PI = acos(-1.);\n    HALF_PI = PI/2.0;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 q = uv;\n    q -= vec2(0.5);\n    q *= vec2(iResolution.x/iResolution.y,1.0);\n    \n    vec3 rd = normalize(vec3(0.,0.,-1.));\n    vec3 ro = vec3(q,15.);\n    \n    float nbRaymarchSteps = 50.0;\n    float distanceFromOrigin = 0.;\n    vec3 curPos = ro;\n    bool hit = false;\n    MapData mapRes;\n    \n    for(float iter=0.;iter<1.0;iter+=1.0/nbRaymarchSteps)\n    {\n        mapRes = map(curPos);\n        float d = mapRes.dist;\n        distanceFromOrigin += d;\n        curPos = ro+rd*distanceFromOrigin;\n        if(d<0.0001)\n        {\n            hit = true;\n        }\n    }\n    \n    // background color\n    vec3 col = vec3(0.92)-0.32*length(q);\n    \n    vec3 nrml = getNormal(curPos);\n    \n    // color experiments\n    if(hit)\n    {\n        vec3 aux = 0.5+0.5*nrml;\n        \n        vec3 savedAux = aux;\n        \n        float factor = 0.97;\n        \n        if(mapRes.type==1.0)\n        {\n            float angle = 30.0*length(mapRes.ab)-13.0*iTime*timeFactor+155.*mapRes.dz;\n            angle = mod(angle,2.*PI);\n            angle /= 2.*PI;\n            angle = pow(angle,3.0);\n            angle *= 2.*PI;\n            aux.yz *= rot(angle);\n        }\n        else if(mapRes.type==2.0)\n        {\n            factor = 0.25;\n        }\n        else\n        {\n            factor = 0.95;\n        }\n        \n        aux = mix(savedAux,aux,0.35);\n        \n        float dif=dot(aux,normalize(vec3(0.5,0.5,1.0)));\n        dif=pow(clamp(dif,0.,1.),3.0);\n        \n        if(mapRes.type!=1.0)\n            col = vec3(1.0)*(1.-dif*factor);\n        else\n            col = vec3(0.4)+vec3(0.5)*dif*factor;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 2D Rotation matrix\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,-s,s,c); }\n\nfloat ease(float p, float g) {\n  if (p < 0.5) \n    return 0.5 * pow(2.0*p, g);\n  else\n    return 1.0 - 0.5 * pow(2.0*(1.0 - p), g);\n}\n\nfloat map(float x, float a, float b, float c, float d)\n{\n    return (x-a)/(b-a)*(d-c)+c;\n}\n\nfloat map(float x, float a, float b, float c, float d, bool constr)\n{\n  return constr ? clamp(map(x,a,b,c,d),min(c,d),max(c,d)) : map(x,a,b,c,d);\n}\n\nfloat mp01(float x, float a, float b)\n{\n  return map(x,a,b,0.0,1.0,true);\n}","name":"Common","description":"","type":"common"}]}