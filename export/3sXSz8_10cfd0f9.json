{"ver":"0.1","info":{"id":"3sXSz8","date":"1550789605","viewed":242,"name":"Interactive Raytraced Marbles","username":"AdrianPi","description":"Interactive raytraced marbles\n\nUse arrow keys to move chrome marble. Marbles have different masses and friction settings\n\nAntialiasing gets disabled at full-screen (horizontal res > 800), lines 647-648","likes":10,"published":1,"flags":48,"usePreview":1,"tags":["3d","raytracing","interactive","collisions","2dphysics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nThis is public domain. Do what you please with it :)\n\n*/\n\nstruct ray_t\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 dirInv;\n    int level;\n    vec4 contrib;\n};\n    \nstruct hit_t\n{\n    float t;\n    vec3 pos;\n    vec3 normal;\n    int mat;\n};\n    \nconst int STANDARD_MATERIAL = 1;\nconst int CHECKER_MATERIAL = 2;\nconst int POLKA_MATERIAL = 3;\nconst int HONEYCOMB_MATERIAL = 4;\n\nstruct material_t\n{\n    int type;\n    int flags;\n    int attrib0;\n    int attrib1;\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    vec4 reflection;\n    vec4 transparent;\n};\n    \nconst int SPHERE_PRIMITIVE = 1;\nconst int PLANE_PRIMITIVE = 2;\nconst int RING_PRIMITIVE = 3;\nconst int BOX_PRIMITIVE = 4;\nconst int CYLINDER_PRIMITIVE = 5;\n\nstruct primitive_t\n{\n    int type;\n    int mat;\n    vec3 v0;\n    vec3 v1;\n    vec3 v2;\n};\n    \nconst float PI = 3.1415926535897932384626433832795;\nconst float INFINITE = 1e6;\nconst float EPSILON = 1e-6;\nconst float EPSILON4 = 1e-4;\n\nvec3 viewFrom = vec3(0,-20,4);\nvec3 viewAt = vec3(0,0,-1);\nvec3 viewUp = vec3(0,0,1);\nfloat viewFov = 60.0;\n\nvec3 viewDir;\nvec3 viewRight;\nfloat viewTan;\nfloat aspect = 1.33;\nint oversample = 2;\n\nvec4 skyColor = vec4(0.2,0.,0.5,1);\nvec4 horizonColor = vec4(0.5,0.8,1,1);\n\nconst material_t material0 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(.1,.1,.2,1), \n                                   vec4(.1,.1,.2,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material1 = material_t(STANDARD_MATERIAL,\n                                   0,0,0, \n                                   vec4(0.5,0,1,1), \n                                   vec4(0.5,0,1,1), \n                                   vec4(1,1,1,100), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material2 = material_t(\n    \t\t\t\t\t\t\t   HONEYCOMB_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,1, \n                                   vec4(.25,.25,.25,0), \n                                   vec4(.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material3 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,0,1), \n                                   vec4(0,0,0,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.2,0.2,0.2,0), \n                                   vec4(0.6,0.6,0.6,1.54));\n\nconst material_t material4 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0.1,0.1,0.1,1), \n                                   vec4(0.1,0.1,0.1,1), \n                                   vec4(1,1,1,50), \n                                   vec4(0,0,0,0), \n                                   vec4(0.3,0.3,0.3,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material5 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(0,0,1,1), \n                                   vec4(0,0,1,1), \n                                   vec4(1,1,1,60), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material6 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(.8,.4,0,1), \n                                   vec4(.8,.4,0,1), \n                                   vec4(0.5,0.5,0.5,10), \n                                   vec4(0,0,0,0), \n                                   vec4(0.1,0.1,0.1,0), \n                                   vec4(0,0,0,0));\n\nconst material_t material7 = material_t(\n    \t\t\t\t\t\t\t   STANDARD_MATERIAL,\n    \t\t\t\t\t\t\t   0,0,0, \n                                   vec4(.9,.1,.1,1),\n                                   vec4(.9,.1,.1,1), \n                                   vec4(0.7,0.7,0.7,30), \n                                   vec4(0,0,0,0), \n                                   vec4(0.1,0.1,0.1,0), \n                                   vec4(0,0,0,0));\n\nmaterial_t materials[] = material_t[](\n    \t// 0 - black\n    \tmaterial_t(STANDARD_MATERIAL, 0,0,0, vec4(.1,.1,.2,1), vec4(.1,.1,.2,1), \n                                   vec4(1,1,1,100), vec4(0,0,0,0),  vec4(0.2,0.2,0.2,0), vec4(0,0,0,0)), \n        // 1 - indigo\n        material_t(STANDARD_MATERIAL, 0,0,0, vec4(0.5,0,1,1), vec4(0.5,0,1,1), \n                                   vec4(1,1,1,100), vec4(0,0,0,0), vec4(0,0,0,0), vec4(0,0,0,0)),\n    \t// 2 - honeycomb\n\t\tmaterial_t(HONEYCOMB_MATERIAL,0,0,1, vec4(.25,.25,.25,0), vec4(.001,0.001,0.001,0), \n                                   vec4(0,0,0,0), vec4(0,0,0,0), vec4(0,0,0,0), vec4(0,0,0,0)),\n    \t// 3 - glass\n\t\tmaterial_t(STANDARD_MATERIAL, 0,0,0,  vec4(0,0,0,1),  vec4(0,0,0,1), \n                                   vec4(1,1,1,50),  vec4(0,0,0,0), vec4(0.2,0.2,0.2,0), vec4(0.6,0.6,0.6,1.54)),\n    \t// 4 - mirror\n\t\tmaterial_t(STANDARD_MATERIAL, 0,0,0,  vec4(0.1,0.1,0.1,1), vec4(0.1,0.1,0.1,1), \n                                   vec4(1,1,1,50),  vec4(0,0,0,0), vec4(0.6,0.6,0.6,0), vec4(0,0,0,0)),\n    \t// 5 - blue plastic\n\t\tmaterial_t(STANDARD_MATERIAL, 0,0,0,  vec4(0,0,1,1),  vec4(0,0,1,1), \n                                   vec4(1,1,1,60), vec4(0,0,0,0), vec4(0,0,0,0), vec4(0,0,0,0)),\n    \t// 6 - bronze\n\t\tmaterial_t(STANDARD_MATERIAL, 0,0,0, vec4(.8,.4,0,1), vec4(.8,.4,0,1), vec4(0.5,0.5,0.5,10), \n                                   vec4(0,0,0,0),  vec4(0.1,0.1,0.1,0), vec4(0,0,0,0)),\n    \t// 7 - red plastic\n\t\tmaterial_t(STANDARD_MATERIAL, 0,0,0, vec4(.9,.1,.1,1), vec4(.9,.1,.1,1), \n                                   vec4(0.7,0.7,0.7,30), vec4(0,0,0,0), vec4(0.1,0.1,0.1,0), vec4(0,0,0,0))\n);\n\nconst int NUM_PRIMS = 9;\n\nprimitive_t prims[] = primitive_t[](    \n\t// floor    \n    primitive_t(PLANE_PRIMITIVE, 2, vec3(0, 0, 0), vec3(0, 0, 1), vec3(0,0,0)),\n\t\n    // sphere\n    primitive_t(SPHERE_PRIMITIVE, 4, vec3(-2, 0, 3), vec3(RADIUS0, 0, 0), vec3(0,0,0)),\n\tprimitive_t(SPHERE_PRIMITIVE, 3, vec3(3.5, 0, 3), vec3(RADIUS1, 0, 0), vec3(0,0,0)),\n\tprimitive_t(SPHERE_PRIMITIVE, 5, vec3(-3.5, 2, 3), vec3(RADIUS2, 0, 0), vec3(0,0,0)),\n\tprimitive_t(SPHERE_PRIMITIVE, 6, vec3(-3, -4, 2.5), vec3(RADIUS3, 0, 0), vec3(0,0,0)),\n    \n    // cylinders\n\tprimitive_t(CYLINDER_PRIMITIVE, 4, vec3(18, 0, 0), vec3(RADIUS4, 6, 0), vec3(0,0,0)),\n\tprimitive_t(CYLINDER_PRIMITIVE, 3, vec3(14, -12, 0), vec3(RADIUS5, 10, 0), vec3(0,0,0)),\n\tprimitive_t(CYLINDER_PRIMITIVE, 7, vec3(14, 16, 0), vec3(RADIUS6, 4, 0), vec3(0,0,0)),\n\tprimitive_t(CYLINDER_PRIMITIVE, 7, vec3(-12, -16, 0), vec3(RADIUS7, 8, 0), vec3(0,0,0))\n);\n\nray_t primary_ray(float fx, float fy)\n{\n    ray_t ray;\n    ray.pos = viewFrom;\n    ray.dir = normalize(viewDir + viewRight * fx  * aspect + viewUp * fy);\n    ray.dirInv = vec3(1) / ray.dir;\n    ray.contrib = vec4(1,1,1,1);\n    return ray;\n}\n\nvec4 background(ray_t ray)\n{\n\tfloat t = 1.0 - ray.dir.z * ray.dir.z;\n    t = pow(t, 10.0);\n    return skyColor * (1.0-t) + horizonColor * t;\n}\n\nbool hit_sphere(vec3 center, float radius, int mat, ray_t ray, inout hit_t hit)\n{\n    vec3 q = ray.pos - center;\n    float a = dot(ray.dir, ray.dir);\n    float b = 2.0 * dot(q, ray.dir);\n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else            \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            hit.normal = normalize(hit.pos - center);\n            hit.mat = mat;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hit_plane(vec3 p0, vec3 normal, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            hit.t = t;\n        \thit.pos = ray.pos + ray.dir * t;\n        \thit.normal = normal;\n        \thit.mat = mat;\n        \treturn true;\n        }\n    }\n    return false;\n}\n\nbool hit_ring(vec3 p0, vec3 normal, float r1, float r2, int mat, ray_t ray, inout hit_t hit)\n{\n    float d = dot(normal, ray.dir);\n    if(d > EPSILON || d < -EPSILON)\n    {\n        vec3 q = p0 - ray.pos;\n        float t = dot(q, normal) / d;\n        if(t > EPSILON)\n        {\n            vec3 p = ray.pos + ray.dir * t;\n            vec3 r = p - p0;\n            float e = dot(r, r);\n            if(e < r1*r1 && e > r2*r2)\n            {\n                hit.t = t;\n                hit.pos = p;\n                hit.normal = normal;\n                hit.mat = mat;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool hit_box(vec3 p0, vec3 p1, int mat, ray_t ray, inout hit_t hit)\n{\n    float txmin = (p0.x - ray.pos.x) * ray.dirInv.x;\n    float txmax = (p1.x - ray.pos.x) * ray.dirInv.x;\n    float tymin = (p0.y - ray.pos.y) * ray.dirInv.y;\n    float tymax = (p1.y - ray.pos.y) * ray.dirInv.y;\n    float tzmin = (p0.z - ray.pos.z) * ray.dirInv.z;\n    float tzmax = (p1.z - ray.pos.z) * ray.dirInv.z;\n    \n    float tmin = max(max(min(txmin, txmax), min(tymin, tymax)), min(tzmin, tzmax));\n    float tmax = min(min(max(txmin, txmax), max(tymin, tymax)), max(tzmin, tzmax));\n    \n    if(tmax < EPSILON || tmin > tmax)\n    {\n        return false;\n    }\n    \n    if(tmin < EPSILON)\n    {\n        tmin = tmax; // inside the box\n    }\n    \n    \n    if(tmin > EPSILON)\n    {\n        hit.t = tmin;\n        hit.pos = ray.pos + ray.dir * hit.t;\n        \n        if(hit.pos.x < p0.x+EPSILON4)\n            hit.normal = vec3(-1, 0, 0);\n        else if(hit.pos.x > p1.x-EPSILON4)\n            hit.normal = vec3(1,0,0);\n        else if(hit.pos.y < p0.y+EPSILON4)\n            hit.normal = vec3(0, -1, 0);\n        else if(hit.pos.y > p1.y-EPSILON4)\n            hit.normal = vec3(0, 1, 0);\n        else if(hit.pos.z < p0.z+EPSILON4)\n            hit.normal = vec3(0, 0, -1);\n        else if(hit.pos.z > p1.z-EPSILON4)\n            hit.normal = vec3(0, 0, 1);\n        \n        hit.mat = mat;\n        return true;\n    }\n    \n    return false;\n}\n\nbool hit_cylinder(vec3 center, float radius, float h, int mat, ray_t ray, inout hit_t hit)\n{\n    vec3 q = ray.pos - center;\n    q.z = 0.;\n    float a = dot(ray.dir.xy, ray.dir.xy);\n    float b = 2.0 * dot(q.xy, ray.dir.xy);    \n    float c = dot(q,q) - radius * radius;\n    float d = b * b - 4.0 * a * c;\n    if(d > EPSILON)\n    {\n        float t0 = (-b - sqrt(d)) / (2.0 * a);\n        float t1 = (-b + sqrt(d)) / (2.0 * a);\n\n        float t = INFINITE;\n        \n        if(t1 > EPSILON && t1 < t0)\n        {\n            t = t1;\n        }\n        else           \n        {\n            t = t0;\n        }\n        \n        if(t < EPSILON)\n        {\n            t = INFINITE;\n        }\n        \n        if(t != INFINITE)\n        {\n            hit.t = t;\n            hit.pos = ray.pos + ray.dir * hit.t;\n            if(hit.pos.z >= center.z && hit.pos.z < center.z + h)\n            {                \n            \thit.normal = hit.pos - center;\n            \thit.normal.z= 0.;\n            \thit.normal = normalize(hit.normal);\n            \thit.mat = mat;\n                return true;\n            }            \n        }\n    }\n    return hit_ring(center + vec3(0,0,h), vec3(0,0,1), radius, 0., mat, ray, hit);\n}\n\nvec4 ambientLight = vec4(0.3, 0.3, 0.3, 1);\nvec3 lightDirection = normalize(vec3(1,1,-1));\n\nray_t rayQueue[16];\nint rayHead = 0;\nint rayTail = 0;\n\nvoid enqueueRay(ray_t ray)\n{\n    if((rayTail+1) % 16 != rayHead)\n    {\n        rayQueue[rayTail] = ray;\n        rayTail++;\n        rayTail %= 16;\n    }\n}\n\nbool dequeueRay(inout ray_t ray)\n{\n    if(rayHead != rayTail)\n    {\n        ray = rayQueue[rayHead];\n        rayHead++;\n        rayHead %= 16;\n        return true;\n    }\n    return false;\n}\n\nvoid resetRayQueue()\n{\n    rayHead = rayTail = 0;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit);\n\n\nvec4 shade_standard(ray_t ray, hit_t hit)\n{\n    if(ray.level >= 8)\n        return vec4(0,0,0,0);\n    \n    vec4 color = materials[hit.mat].ambient * ambientLight;\n    \n    ray_t sray;\n    sray.pos = hit.pos - lightDirection * EPSILON4;\n    sray.dir = -lightDirection;\n    sray.dirInv = vec3(1) / sray.dir;\n    hit_t h;\n    intersect(sray, h);\n    if(h.t == INFINITE)\n    {    \n        float d = dot(-lightDirection, hit.normal);\n        d = clamp(d, 0.0, 1.0);\n        color += materials[hit.mat].diffuse * d;\n        vec3 r = reflect(ray.dir, hit.normal);\n        float s = dot(-lightDirection, r);\n        s = clamp(s, 0.0, 1.0);\n        s = pow(s, materials[hit.mat].specular.a);\n        color.rgb += materials[hit.mat].specular.rgb * s;\n    }\n    \n    color.rgb += materials[hit.mat].emission.rgb;\n    \n    vec3 refl = materials[hit.mat].reflection.rgb;\n    if(dot(refl, refl) > 0.0)\n    {\n        ray_t rray;\n        vec3 r = reflect(ray.dir, hit.normal);\n        rray.pos = hit.pos + r * 0.001;\n        rray.dir = r;\n        rray.dirInv = vec3(1) / rray.dir;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(refl, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    vec3 trans = materials[hit.mat].transparent.rgb;\n    if(dot(trans, trans) > 0.0)\n    {\n        float ior = materials[hit.mat].transparent.a;\n        if(dot(ray.dir, hit.normal) < 0.0)\n            ior = 1.0 / ior;\n        \n        ray_t rray;\n        rray.pos = hit.pos + ray.dir * 0.001;\n        rray.dir = refract(ray.dir, hit.normal, ior);\n        rray.dirInv = vec3(1) / rray.dir;\n        rray.level = ray.level + 1;\n        rray.contrib = vec4(trans, 1) * ray.contrib;\n        enqueueRay(rray);\n    }\n    \n    return color;\n}\n\nvec4 shade_checker(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int ix = int(floor(p.x)) & 0x01;\n    int iy = int(floor(p.y)) & 0x01;\n    int iz = int(floor(p.z)) & 0x01;\n\n    hit.mat = ((ix ^ iy ^ iz) == 0) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade_polka(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n    int iy = int(floor(p.y)) & 0x01;\n    if((iy & 0x01) == 1)\n        p.x += 0.5;\n\n    vec3 p2 = mod(p, vec3(1.));\n    p2 *= 2.;\n    p2 -= 1.;\n        \n    float d = dot(p2,p2);\n\n    hit.mat = (d < (.666*.666)) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nconst float SIN60 = 0.86602540378443864676372317075294;\n\nvec4 shade_honeycomb(ray_t ray, hit_t hit)\n{\n    vec3 p = hit.pos * materials[hit.mat].ambient.xyz\n        + materials[hit.mat].diffuse.xyz;\n\n\tp.y += floor(p.x) * 0.5;\n    \n    vec3 p2 = mod(p, vec3(1.));\n    p2 *= 2.;\n    p2 -= 1.;\n    p2 *= vec3(1.1,1.2,1.);\n    p2 = abs(p2);\n        \n\tfloat d = max((p2.x*SIN60+p2.y*0.5),p2.y);\n    \n    hit.mat = (d < (1.)) ? materials[hit.mat].attrib0 : materials[hit.mat].attrib1;\n\n    return shade_standard(ray, hit);\n}\n\nvec4 shade(ray_t ray, hit_t hit)\n{\n    vec4 color;\n    \n    if(hit.t != INFINITE)\n    {    \n        int type = materials[hit.mat].type;\n\n        switch(type)\n        {\n        case STANDARD_MATERIAL:\n            color = shade_standard(ray, hit);\n            break;\n        case CHECKER_MATERIAL:\n            color = shade_checker(ray, hit);\n            break;\n        case POLKA_MATERIAL:\n            color = shade_polka(ray, hit);\n            break;\n        case HONEYCOMB_MATERIAL:\n            color = shade_honeycomb(ray, hit);\n            break;            \n        }\n        \n        // fog\n\n        float f = (hit.t - 30.0) / (175.0-30.0);\n        f = clamp(f, 0.0, 1.0);\n        color = mix(color, horizonColor, f);\n    }\n    else\n    {\n        color = background(ray);\n    }\n    \n    return color * ray.contrib;\n}\n\nvoid intersect(ray_t ray, inout hit_t hit)\n{\n\thit.t = INFINITE;\n    \n#pragma unroll 1\n\n    for(int i = 0; i < NUM_PRIMS; i++)\n    {\n    \thit_t h;\n        int type = prims[i].type;\n        bool result = false;\n        \n        switch(type)\n        {\n        case PLANE_PRIMITIVE:\n            result = hit_plane(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        case SPHERE_PRIMITIVE:\n            result = hit_sphere(prims[i].v0, prims[i].v1.x,  prims[i].mat, ray, h);            \n            break;\n        case RING_PRIMITIVE:\n            result = hit_ring(prims[i].v0, prims[i].v1, prims[i].v2.x, prims[i].v2.y, prims[i].mat, ray, h);\n            break;\n        case BOX_PRIMITIVE:            \n            result = hit_box(prims[i].v0, prims[i].v1, prims[i].mat, ray, h);\n            break;\n        case CYLINDER_PRIMITIVE:\n            result = hit_cylinder(prims[i].v0, prims[i].v1.x, prims[i].v1.y, prims[i].mat, ray, h);            \n            break;\n        }\n        \n        if(result && h.t < hit.t)\n        {\n            hit = h;\n        }\n    }    \n}\n\nvec4 raytrace(ray_t ray)\n{\n    hit_t hit;\n    \n    intersect(ray, hit);\n    \n    return shade(ray, hit);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 temp = loadState(iChannel0, 0);\n    prims[1].v0 = vec3(temp.xy, RADIUS0);\n    temp = loadState(iChannel0, 1);\n    prims[2].v0 = vec3(temp.xy, RADIUS1);\n    temp = loadState(iChannel0, 2);\n    prims[3].v0 = vec3(temp.xy, RADIUS2);\n    temp = loadState(iChannel0, 3);\n    prims[4].v0 = vec3(temp.xy, RADIUS3);\n\n    viewFrom = loadState(iChannel0, 9).xyz;\n    viewAt = prims[1].v0;\n    \n    if(iResolution.x > 800.)\n        oversample = 1;\n    \n    aspect = iResolution.x / iResolution.y;\n    viewTan = tan(((viewFov/180.0)*PI)/2.0);    \n    vec2 uv = fragCoord/iResolution.xy * vec2(2,2) - vec2(1,1);\n    uv *= viewTan;\n    viewDir = normalize(viewAt-viewFrom);\n\tviewRight = cross(viewDir, viewUp);\n    viewUp = cross(viewRight, viewDir);\n        \n    vec4 color = vec4(0,0,0,0);\n    float sx = (1.0 / float(oversample)) / iResolution.x;\n    float sy = (1.0 / float(oversample)) / iResolution.y;\n        \n#pragma unroll 1\n    for(int i = 0; i < oversample; i++)\n    {\n#pragma unroll 1\n        for(int j = 0; j < oversample; j++)\n        {\n    \t\tray_t ray = primary_ray(uv.x + float(i) * sx, uv.y + float(j) * sy);\n            resetRayQueue();\n            enqueueRay(ray);\n            \n            while(dequeueRay(ray))\n\t    \t\tcolor += raytrace(ray);\n        }\n    }\n    \n    // vignette    \n    float d = pow(1. - dot(uv,uv), 3.);\n    color *= d;\n    \n    color /= float(oversample*oversample);\n    fragColor = color;\n    \n    //fragColor += texelFetch(iChannel0, ivec2(fragCoord.xy/32.), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float RADIUS0 = 3.;\nconst float RADIUS1 = 2.;\nconst float RADIUS2 = 3.;\nconst float RADIUS3 = 2.5;\nconst float RADIUS4 = 3.;\nconst float RADIUS5 = 2.;\nconst float RADIUS6 = 3.;\nconst float RADIUS7 = 2.5;\n\nvec4 loadState(sampler2D tx, int pos)\n{\n    return texelFetch(tx, ivec2(pos, 0), 0);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int KEY_UP  = 0x26;\nconst int KEY_DOWN = 0x28;\nconst int KEY_LEFT = 0x25;\nconst int KEY_RIGHT = 0x27;\n\nconst int SOLVE_STEPS = 2;\nconst float ACCEL = 0.1 / float(SOLVE_STEPS);\n\nvoid saveState(vec4 newValue, inout vec4 outValue, ivec2 fragCoord, int pos)\n{\n    outValue = (fragCoord == ivec2(pos, 0)) ? newValue : outValue;\n}\n\nbool keyDown(int key)\n{ \n    return texelFetch(iChannel1, ivec2(key,0.0), 0 ).x > 0.5;\n}\n\nfloat radius[] = float[](RADIUS0, RADIUS1, RADIUS2, RADIUS3, RADIUS4, RADIUS5, RADIUS6, RADIUS7);\nfloat mass[] = float[](1., 0.5, 0.05, 1.5, 0., 0., 0., 0.);\nfloat dynamic_friction[] = float[](.96, .99, .97, 0.98,0.,0.,0.,0.);\nfloat static_friction[] = float[](.96, .99, .97, 0.95,0.,0.,0.,0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ballPos[8];\n\tvec3 ballDir[8];\n    vec3 viewFrom;\n    vec3 viewFrom2;\n    \n    ivec2 iFragCoord = ivec2(fragCoord-0.5);\n\n            \n    if(iFrame < 10)\n    {\n        ballPos[0] = vec3(0.,0.,RADIUS0);\n\t\tballPos[1] = vec3(6, 0, RADIUS1);\t\t\n\t\tballPos[2] = vec3(-5.5, 5, RADIUS2);        \n\t\tballPos[3] = vec3(-5, -6, RADIUS3);\n        \n        ballPos[4] = vec3(18, 0, RADIUS0);\n\t\tballPos[5] = vec3(14, -12, RADIUS0);\n\t\tballPos[6] = vec3(14, 16, RADIUS0);\n\t\tballPos[7] = vec3(-12, -16, RADIUS0);\n                \n        viewFrom = viewFrom2 = vec3(0,-20,16);\n    }\n    else\n    {\n        for(int i = 0; i < 8; i++)\n        {\n        \tvec4 temp = loadState(iChannel0, i);\n    \t\tballPos[i] = vec3(temp.xy, radius[i]);\n    \t\tballDir[i] = vec3(temp.zw, 0);\n        }\n        \n        viewFrom = loadState(iChannel0, 8).xyz;\n        viewFrom2 = loadState(iChannel0, 9).xyz;\n    }\n    \n    if(iFragCoord.x > 9 || iFragCoord.y > 0)\n    {\n        discard;\n        return;\n    }\n    \n    int index = iFragCoord.x;\n    if(index == 0)\n    {\n        if(keyDown(KEY_UP))\n            ballDir[index].y += ACCEL;\n        else if(keyDown(KEY_DOWN))\n            ballDir[index].y -= ACCEL;\n        if(keyDown(KEY_LEFT))\n        \tballDir[index].x -= ACCEL;\n        else if(keyDown(KEY_RIGHT))\n        \tballDir[index].x += ACCEL;\n    }\n\n    for(int k = 0; k < SOLVE_STEPS; k++)\n    {\n        for(int i = 0; i < 8; i++)\n        {\n            for(int j = i+1; j < 8; j++)\n            {\n                vec3 p0 = ballPos[j];\n                vec3 p1 = ballPos[i];\n                vec3 d = p0 - p1;\n                float l = sqrt(dot(d,d));\n                float R = radius[i] + radius[j];\n                if(l < R)\n                {\n                    vec3 v1 = ballDir[i];\n                    vec3 v2 = ballDir[j];\n                    \n                    vec3 p1 = ballPos[i];\n                    vec3 p2 = ballPos[j];\n                    \n                    vec3 p21 = p2-p1;\n                    vec3 p12 = p1-p2;\n                    \n                    R *= 1.0001;\n                    \n                    if(i!=0||mass[j]==0.)\n                    \tp1 = ballPos[j] - normalize(p21) * R;\n                    else\n                    \tp2 = ballPos[i] - normalize(p12) * R;                   \n                    \n                    p12 = p1 - p2;\n                    p21 = -p12;\n                    \n                    float l = 1. / dot(p12, p12);\n                    \n                    float m1 = mass[j] == 0. ? 0. : mass[i] / (mass[i]+mass[j]);\n                    float m2 = mass[i] == 0. ? 0. : mass[j] / (mass[i]+mass[j]);\n\n                    vec3 w1 = v1;\n                    if(m1 == .0)\n                    {\n                        w1 = reflect(w1, normalize(p21)) * 0.8;\n                    }\n                    else\n                    {\n                    \tw1 += p21 * (dot(v2, p21) * l) * m2;\n                    \tw1 -= p12 * (dot(v1, p12) * l) * m2;\n                    }\n                    \n                    vec3 w2 = v2;\n                    if(m2 == 0.)\n                    {\n                        w2 = reflect(w2, normalize(p12)) * 0.8;\n                    } \n                    else\n                    {\n                    \tw2 += p21 * (dot(v1, p21) * l) * m1;\n                    \tw2 -= p12 * (dot(v2, p12) * l) * m1;\n                    }\n                                                           \n                    ballPos[i] = p1;\n                    ballPos[j] = p2;\n                    ballDir[i] = w1;\n                    ballDir[j] = w2;                    \n                }\n            }\n            ballDir[i] = max(min(ballDir[i], vec3(1.)), -1.);\n\t    \tballPos[i] += ballDir[i];\n            float sd = clamp(dot(ballDir[i], ballDir[i]) / 0.01, 0., 1.);\n    \t\tballDir[i] *= (1.-sd) * static_friction[i] + sd * dynamic_friction[i];\n        }\n    }    \n    \n    viewFrom = ballPos[0] + vec3(0, -20, 16);\n    viewFrom2 = viewFrom2 + (viewFrom-viewFrom2) * 0.2;\n         \n    for(int i = 0; i < 8; i++)\n    {\n    \tsaveState(vec4(ballPos[i].x, ballPos[i].y, ballDir[i].x, ballDir[i].y), fragColor, iFragCoord, i);    \t\n    }\n\n    saveState(vec4(viewFrom, 0), fragColor, iFragCoord, 8);\n    saveState(vec4(viewFrom2, 0), fragColor, iFragCoord, 9);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}