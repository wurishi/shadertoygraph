{"ver":"0.1","info":{"id":"wd23Wt","date":"1550329281","viewed":455,"name":"Gears test","username":"yasuo","description":"It's just an experiment.","likes":7,"published":3,"flags":0,"usePreview":0,"tags":["gear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat sdGear( vec3 p, vec2 h )\n{\n    float r = (length(p)-0.08);\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float len = 0.13;\n\tfloat resd = min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    float res2d = max(-r,resd);\n    float b = sdBox(p,vec3(0.02,0.015,len));\n    float b2 = sdBox(p,vec3(len,0.015,0.02));\n    float b3 = sdBox(p*matRotateY(radians(45.0)),vec3(len,0.015,0.02));\n    float b4 = sdBox(p*matRotateY(radians(-45.0)),vec3(len,0.015,0.02));\n    float res3d = max(-b,res2d);\n    float res4d = max(-r,min(min(min(b,b2),b3),b4));\n  \treturn min(res3d,res4d);\n}\n\nvec4 map(vec3 p){\n    p.z -= iTime*0.2;\n    p.z = mod(p.z,1.0)-0.5;\n    \n    mat3 rotX = matRotateX(radians(90.0));\n    float rad = radians(iTime*60.0);\n    float gear0 = sdGear(((p+vec3(-0.17,-0.17,-0.4))*rotX)*matRotateY(rad),vec2(0.1,0.015));\n    float gear1 = sdGear(((p+vec3(0.0,0.0,-0.4))*rotX)*matRotateY(-rad+radians(20.0)),vec2(0.1,0.015));\n    float gear2 = sdGear(((p+vec3(-0.17,0.17,-0.4))*rotX)*matRotateY(rad),vec2(0.1,0.015));\n    float gear3 = sdGear(((p+vec3(0.25,0.0,-0.4))*rotX)*matRotateY(rad),vec2(0.1,0.015));\n    float gear4 = sdGear(((p+vec3(0.43,0.18,-0.4))*rotX)*matRotateY(-rad+radians(20.0)),vec2(0.1,0.015));\n    float gear5 = sdGear(((p+vec3(-0.43,-0.18,-0.4))*rotX)*matRotateY(-rad+radians(20.0)),vec2(0.1,0.015));\n    return vec4(vec3(0.9),min(min(min(min(min(gear0,gear1),gear2),gear3),gear4),gear5));\n}\n\nvec3 normalMap(vec3 p){\n\tfloat d = 0.0001;\n\treturn normalize(vec3(\n\t\tmap(p + vec3(  d, 0.0, 0.0)).w - map(p + vec3( -d, 0.0, 0.0)).w,\n\t\tmap(p + vec3(0.0,   d, 0.0)).w - map(p + vec3(0.0,  -d, 0.0)).w,\n\t\tmap(p + vec3(0.0, 0.0,   d)).w - map(p + vec3(0.0, 0.0,  -d)).w\n\t));\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n\tfloat h = 0.0;\n\tfloat c = 0.001;\n\tfloat r = 1.0;\n\tfloat shadow = 0.5;\n\tfor(float t = 0.0; t < 30.0; t++){\n\t\th = map(ro + rd * c).w;\n\t\tif(h < 0.001){\n\t\t\treturn shadow;\n\t\t}\n\t\tr = min(r, h * 16.0 / c);\n\t\tc += h;\n\t}\n\treturn 1.0 - shadow + r * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tmat3 camRotY = matRotateY(radians(sin(iTime)*30.0));\n    \n\tvec3 ro=vec3(0.,0.0,0.0);\n    vec3 rd=normalize(vec3(p,1.0));\n\t\n    float t, dist;\n\tt = 0.0;\n\tvec3 distPos = vec3(0.0);\n\tvec4 distCl = vec4(0.0);\n\tfor(int i = 0; i < 30; i++){\n\t\tdistCl = map(distPos);\n\t\tdist = distCl.w;\n\t\tif(dist < 1e-4){break;}\n        if(t>13.)break;\n\t\tt += dist;\n\t\tdistPos = (ro+rd*t);\n\t}\n\n\tvec3 color;\n\tfloat shadow = 1.0;\n\t\n\tif(t < 13.){\n\t\t// lighting\n\t\tvec3 lightDir = vec3(1.0, 10.0, 1.0);\n\t\tvec3 light = normalize(lightDir);\n\t\tvec3 normal = normalMap(distPos);\n\n\t\t// difuse color\n\t\tfloat diffuse = clamp(dot(light, normal), 1.0, 1.0);\n\t\tfloat lambert = max(.0, dot( normal, light));\n\t\t\n\t\t// shadow\n\t\tshadow = shadowMap(distPos + normal * 0.001, light);\n\n\t\t// result\n\t\tcolor += vec3(lambert);\n\t\tcolor = diffuse*(distCl.xyz+(.1-length(p.xy)/3.))*vec3(1.0, 1.0, 1.0);\n\t}else{\n        color =.84*max(mix(vec3(1.1,1.31,1.35)+(.1-length(p.xy)/3.),vec3(1),.1),0.);\n\t}\n\n\t// rendering result\n\tfloat brightness = 1.0;\n\tvec3 dst = (color * max(0.5, shadow))*brightness;\n\tfragColor = vec4(dst, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}