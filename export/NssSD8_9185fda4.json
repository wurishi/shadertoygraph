{"ver":"0.1","info":{"id":"NssSD8","date":"1618579712","viewed":86,"name":"Cube + fireball","username":"amaqte","description":"KG21","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cube","fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(oo) clamp(oo, 0.0, 1.0)\n\n#define MarchSteps 8\n// Scene Settings\n#define ExpPosition vec3(0., 0., 0.)\n#define Radius 0.65\n#define Background vec4(0.0, 0.0, 0.0, 0.0)\n// Noise Settings\n#define NoiseSteps 1\n#define NoiseAmplitude 0.06\n#define NoiseFrequency 4.0\n#define Animation vec3(0.0, -3.0, 0.5)\n// Colour Gradient\n#define Color1 vec4(1.0, 1.0, 1.0, 1.0)\n#define Color2 vec4(1.0, 0.8, 0.2, 1.0)\n#define Color3 vec4(1.0, 0.03, 0.0, 1.0)\n#define Color4 vec4(0.05, 0.02, 0.02, 1.0)\n\n\n#define OBJECT_MAP_FUNCTION map1\n\n#define calcRecursion rec3 // use n rays levels (rays1 to rays6): total  RAY_COUNT = 2^n-1\n#define DIST_EPSILON 0.005\n\n#define ID_SKY 2.001\n#define ID_FLOOR 1.\n#define ID_LIGHT 1.001\n#define ID_GLASS_WALL 2.000\n#define ETA 0.85\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n\n#define DENSITY_MIN 0.1\n#define DENSITY_MAX 1.\n#define MATERIAL_COLOR vec3(0.9,0.8,1)*0.1\n#define AIR_COLOR vec3(0.5,0.8,1)*0.1\n\n\n#define SURFACE_COLOR vec3(0.8,1.,0.9)\nvec3 LIGHT_DIR = normalize(vec3(-0.6,0.7,-0.3));\nvec3 LIGHT_DIR2 = normalize(vec3(0.6,0.7,-0.3));\n//-------------------------------------------------------------------------------\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nstruct CP {\n    float dist;\n    vec3 normal;\n    float mat;\n    vec3 p;\n};\n    \n    \nstruct Ray {\n    vec3 rd;\n    CP cp;\n    vec3 col;\n    float share;\n    float eta;\n};\n    \n    \n//-------------------------------------------------------------------------------\nfloat sdSphere( vec3 p, float r)\n{\n   return (length(p)-r);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n   vec3 d = abs(p) - b;\n   return (min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)));\n}\n\nfloat sdPlane( vec3 p )\n{\n    if (abs(p.x) < 2.3 && abs(p.z) < 2.3) \n        return p.y+0.15;\n    return 10000.;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return abs(length(max(abs(p)-b,0.0))-r);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nvec3 opU( vec3 d1, vec3 d2 )\n{\n   \n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opS(  vec3 d1, vec3 d2 )\n{\n    return -d1.x>d2.x ? d2: d1;\n}\n\n//-------------------------------------------------------------------------------\n\n\n\nvec3 map1(in vec3 pos) {\n    float a = 0.;\n\tvec3 s = vec3(0.5+pow(textureLod(iChannel0,vec2(0.0,0.0),0.0).x,2.0)/2.0);\n    s /= 1.59;\n\n\tfloat f;\n\tpos.z -= 0.;\n\t\n\tvec3 br = pos;\n\tbr.y += -0.42+a*2.5;\n\tbr.x += 0.;\n    \n    vec3 res = vec3(udRoundBox(br, s, 0.04),ID_GLASS_WALL, ETA);\n    \n    res = opU(res, vec3(sdCappedCylinder(pos-vec3(0.0,-0.05,-0.0), vec2(0.7,0.1)), ID_FLOOR, ETA));\n    \n    res.x =abs(res.x);\n   \n \treturn res;\n}\n\nvec3 map(in vec3 pos) {\n    vec3 res = vec3(sdPlane(pos), ID_FLOOR, -1. );\n\n\treturn opU(res, OBJECT_MAP_FUNCTION(pos));    \n}\n\n//-------------------------------------------------------------------------------\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.0001, 0.0, 0.0 );\n    float d = map(pos).x;\n    return normalize( vec3(\n\t    map(pos+eps.xyy).x - d,\n\t    map(pos+eps.yxy).x - d,\n\t    map(pos+eps.yyx).x - d)\n\t);\n}\n\n              \nCP findIntersection(vec3 p, vec3 rd) {\n     \n    float tmin = 0.000;\n    float tmax = 50.0;\n    \n\tfloat precis = DIST_EPSILON;\n    float t = tmin;\n    float eta = -1.;\n    vec3 res;\n    for( int i=0; i<50; i++ )\n    {\n\t  \tres = map(p+rd*t);\n        eta = res.z;\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n        if (i == 49) {\n            CP cp = CP(t, vec3(1, 0, 0), res.y, 100.*p);\n\n            return cp;\n        }\n    }\n    \n    p+=rd*t;\n    \n    vec3 n = calcNormal(p-rd*(precis-res.x));\n    CP cp = CP(t, n, res.y, p);\n\n    return cp;\n}\n\n//-------------------------------------------------------------------------------\n\n\nvec3 refractCaustic(vec3 p, vec3 rd, vec3 ld, float eta) {\n     vec3 cl = vec3(1);\n    for(int j = 0; j < 2; ++j) {\n\n        CP cp = findIntersection(p, rd);\n        if (length(cp.p) > 2.) {\n            break;\n        }\n        cl *= SURFACE_COLOR;\n        vec3 normal = sign(dot(rd, cp.normal))*cp.normal;\n        rd = refract(rd, -normal, eta);\n\n        p = cp.p;\n        eta = 1./eta;\n        p += normal*DIST_EPSILON*2.;\n    }\n     float d = clamp( dot( rd, ld ), 0.0, 1.0 );\n     return smoothstep(0.99, 1., d)*cl;\n}\n\nvec3 caustic(vec3 p,vec3 ld, Ray ray) {\n    vec3 VX = normalize(cross(ld, vec3(0,1,0)));\n\tvec3 VY = normalize(cross(ld, VX));     \n    vec3 c = vec3(0);\n    \n    const int N =3;\n    p += ray.cp.normal*DIST_EPSILON;\n   \n    for(int i = 0; i < N;++i) {\n        \n        float n1 = rand(p.xz*10. + vec2(iTime*2. +float(i)*123.));\n        float n2 = rand(p.xz*15. +vec2(iTime*3. +float(i)*111.));\n\n        vec3 rd = ld+(VX*(n1-0.5)+VY*(n2-0.5))*0.1;\n\n        rd = normalize(rd);\n\n \t\tvec3 cl = refractCaustic(p, rd, ld, ray.eta);\n        \n      \tc += cl* dot(rd,ray.cp.normal);\n    }\n    return c*3./float(N);\n}\n\n\nvec3 getFloorColor(in Ray ray) {\n\n    vec3 col = vec3(0);\n    vec3 pos = ray.cp.p;\n    vec3 ref = reflect( ray.rd, ray.cp.normal );\n    \n    \n    float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n\n    col = texture(iChannel2, pos.xz).xyz;\n    \n\n    float dif = clamp( dot( ray.cp.normal, LIGHT_DIR ), 0.0, 1.0 );\n    vec3 brdf = vec3(0.0);\n    brdf += caustic(pos, LIGHT_DIR, ray);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    col = col*brdf;\n    \n    col *= (ID_GLASS_WALL-ray.cp.mat);\n    \n    vec3 col2 = col;\n    \n    col = texture(iChannel2, pos.xz).xyz;\n    \n\n    dif = clamp( dot( ray.cp.normal, LIGHT_DIR2 ), 0.0, 1.0 );\n    brdf = vec3(0.0);\n    brdf += caustic(pos, LIGHT_DIR2, ray);\n    brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n    col = col*brdf;\n    \n    col *= (ID_GLASS_WALL-ray.cp.mat);\n    \n    col = (3. * col2 + 2. * col) / 5.;\n\n    return col;\n}\n    \n\nvec3 getColor(in Ray ray) {\n\n    vec3 p = ray.cp.p ;\n    vec3 c1 = ray.col * SURFACE_COLOR;\n    vec3 c2 = getFloorColor(ray);\n    \n    return mix(c2, c1, ray.cp.mat - ID_FLOOR);\n\n}    \n\n//-------------------------------------------------------------------------------\n\n\nvec3 getRayColor(Ray ray) {\n\n\n    float d = mix(DENSITY_MIN, DENSITY_MAX, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 matColor = mix(AIR_COLOR, MATERIAL_COLOR, (ray.eta - ETA)/(1./ETA-ETA));\n    vec3 col = getColor(ray);\n\n    float q = exp(-d*ray.cp.dist);\n    col = col*q+matColor*(1.-q);\n    return col*ray.share;\n}\n\nvoid getRays(inout Ray ray, out Ray r1, out Ray r2) {\n     vec3 p = ray.cp.p;\n    float cs = dot(ray.cp.normal, ray.rd);\n    \n    float fresnel = 1.0-abs(cs);\n    float r = ray.cp.mat - ID_FLOOR;\n    vec3 normal = sign(cs)*ray.cp.normal;\n    vec3 refr = refract(ray.rd, -normal, ray.eta);\n    vec3 refl = reflect(ray.rd, ray.cp.normal);\n    vec3 z = normal*DIST_EPSILON*2.;\n    p += z;\n    r1 = Ray(refr, findIntersection(p, refr),  vec3(0),(1.-fresnel)*r, 1./ray.eta);\n    p -= 2.*z;\n    r2 = Ray( refl, findIntersection(p, refl), vec3(0),r*fresnel, ray.eta);\n}\n\nvoid rec1(inout Ray ray) {\n    ray.col += getRayColor(ray);\n}\n\n\nvoid rec2(inout Ray ray) {\n\t\n    Ray r1,r2;\n    getRays(ray, r1, r2);\n\n    ray.col += getRayColor(r1);\n    ray.col += getRayColor(r2);\n}\n\nvoid rec3(inout Ray ray) {\n    \n    Ray r1,r2;\n    getRays(ray, r1, r2);\n    \n    rec2(r1);\n    ray.col += getRayColor(r1);\n    \n    rec1(r2);\n    ray.col += getRayColor(r2);\n}\n//---------------------------------------------------------------------------------\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat snoise(vec3 v)\n{\n\tconst vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\tconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n\tvec3 i  = floor(v + dot(v, C.yyy));\n\tvec3 x0 = v - i + dot(i, C.xxx);\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; \n\tvec3 x3 = x0 - D.yyy;      \n\ti = mod289(i);\n\tvec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n\tfloat n_ = 0.142857142857; // 1.0/7.0\n\tvec3  ns = n_ * D.wyz - D.xzx;\n\tvec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 y_ = floor(j - 7.0 * x_);    \n\tvec4 x = x_ *ns.x + ns.yyyy;\n\tvec4 y = y_ *ns.x + ns.yyyy;\n\tvec4 h = 1.0 - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 s0 = floor(b0) * 2.0 + 1.0;\n\tvec4 s1 = floor(b1) * 2.0 + 1.0;\n\tvec4 sh = -step(h, vec4(0.0));\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n    \n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n    \n\tvec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\tm = m * m;\n\treturn 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n}\n\nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n\tfloat value = 0.0;\n\tfloat cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n\tfloat fade;\n\tfloat fOut = minFreq;\n\tfor(int i=NoiseSteps ; i>=0 ; i--)\n\t{\n\t\tif(fOut >= 0.5 * cutoff) break;\n\t\tfOut *= 2.0;\n\t\tvalue += abs(snoise(position * fOut))/fOut;\n\t}\n\tfade = clamp(2.0 * (cutoff-fOut)/cutoff, 0.0, 1.0);\n\tvalue += fade * abs(snoise(position * fOut))/fOut;\n\treturn 1.0-value;\n}\n\nfloat SphereDist(vec3 position)\n{\n\treturn length(position - ExpPosition) - Radius;\n}\n\nvec4 Shade(float distance)\n{\n\tfloat c1 = saturate(distance*5.0 + 0.5);\n\tfloat c2 = saturate(distance*5.0);\n\tfloat c3 = saturate(distance*3.4 - 0.5);\n\tvec4 a = mix(Color1,Color2, c1);\n\tvec4 b = mix(a,     Color3, c2);\n\treturn \t mix(b,     Color4, c3);\n}\n\nfloat RenderScene(vec3 position, out float distance)\n{\n\tfloat noise = Turbulence(position * NoiseFrequency + Animation*iTime, 0.1, 1.5, 0.03) * NoiseAmplitude;\n\tnoise = saturate(abs(noise));\n\tdistance = SphereDist(position) - noise;\n\treturn noise;\n}\n\nvec4 March(vec3 rayOrigin, vec3 rayStep)\n{\n\tvec3 position = rayOrigin;\n\tfloat distance;\n\tfloat displacement;\n\tfor(int step = MarchSteps; step >=0  ; --step)\n\t{\n\t\tdisplacement = RenderScene(position, distance);\n\t\tif(distance < 0.05) break;\n\t\tposition += rayStep * distance;\n\t}\n\treturn mix(Shade(displacement), Background, float(distance >= 0.5));\n}\n\nbool IntersectSphere(vec3 ro, vec3 rd, vec3 pos, float radius, out vec3 intersectPoint)\n{\n\tvec3 relDistance = (ro - pos);\n\tfloat b = dot(relDistance, rd);\n\tfloat c = dot(relDistance, relDistance) - radius*radius;\n\tfloat d = b*b - c;\n\tintersectPoint = ro + rd*(-b - sqrt(d));\n\treturn d >= 0.0;\n}\n\n\n\nvec3 castRay(vec3 p, vec3 rd) {\n    CP cp = findIntersection(p, rd);\n    if (cp.dist > 10.) {\n        return vec3(0, 0, 0);\n    }\n   \n    Ray ray = Ray( rd, cp, vec3(0), 1., ETA);\n    calcRecursion(ray);\n    ray.col = getRayColor(ray);\n\treturn ray.col;\n    \n}\n\nvec3 render(vec3 p, vec3 rd) {\n    vec3 col= castRay(p, rd);\n    return col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n    \n    \n    \n    vec2 p = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tp.x *= iResolution.x/iResolution.y;\n    \n    \n    vec2 mo1 = iMouse.xy/iResolution.xy;\n    mo1 = mix(vec2(0.6,0.3),mo1, sign(mo1.x+mo1.y));\n\n\n    mo1.y+=0.02;\n\tmo1.y *=1.57;\n    float time1 =0.;\n\tmo1.x*=10.;\n    float R1 = 4.3;\n    \n    float Y1 = sin(mo1.y);\n    float X1 = cos(mo1.y);\n\tvec3 ro1 = vec3(-cos(time1 + mo1.x)*X1, Y1, X1*sin(time1 + mo1.x) )*R1;\n    \n    \n\tvec3 ww = normalize(vec3(0.0, 0.0, 0.0) - ro1);\n\tvec3 uu = normalize(cross( vec3(0.0, 1.0, 0.0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd1 = normalize(p.x*uu + p.y*vv + 1.5*ww);\n\tvec4 col = Background;\n\tvec3 origin;\n    bool fire = false;\n    \n    \n    \n\tif(IntersectSphere(ro1, rd1, ExpPosition, Radius + NoiseAmplitude*6.0, origin))\n\t{\n\t\tcol = March(origin, rd1);\n        if (col != Background)\n             fire = true;\n\t}\n\t\n\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    mo = mix(vec2(0.6,0.3),mo, sign(mo.x+mo.y));\n\n\n    mo.y+=0.02;\n\tmo.y *=1.57;\n    float time =0.;\n\tmo.x*=10.;\n    float R = 4.3;\n    \n    float Y = sin(mo.y);\n    float X = cos(mo.y);\n\tvec3 ro = vec3(cos(time + mo.x)*X, Y, X*sin(time + mo.x) )*R;\n\tvec3 ta = vec3( 0,0.4,0);\n\t\n    mat3 ca = setCamera( ro, ta,0. );\n    \n\tvec3 rd = ca * normalize( vec3(uv.xy,2.5) );\n    \n    vec3 c = render(ro, rd);\n    \n    if (c == vec3(0, 0, 0)) {\n        vec2 q = (fragCoord.xy) / iResolution.xy;\n        vec2 p = -1.0 + 2.0 * q;\n\n        float an1 = 3.0;\n        float an2 = 0.6;\n        vec3 ro = 2.5*normalize(vec3(sin(an2)*cos(an1), cos(an2)-0.5, sin(an2)*sin(an1)));\n        vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n        vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n        vec3 vv = normalize(cross(ww,uu));\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.4*ww ); \n        \n        vec3 col = texture( iChannel3, rd ).xyz;\n        fragColor = vec4(col, 1);\n        return ;\n    }\n    \n    if (fire) {\n        fragColor = mix(vec4(c, 1), col, 0.5);\n    } else {\n        fragColor = vec4(c, 1);\n    }\n}","name":"Image","description":"","type":"image"}]}