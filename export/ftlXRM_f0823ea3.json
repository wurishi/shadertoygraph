{"ver":"0.1","info":{"id":"ftlXRM","date":"1625358159","viewed":228,"name":"More surface detail experiments","username":"kibitz9","description":"Using mandelbox fractal for surface detail on various primitives.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//***************************************************************//\n// Yet More Fractal Surface Experiments by CMiller (kibitz9)\n// I am experimenting with using fractals for surface detail (greebles). \n//***************************************************************// \n\nconst float GLOBAL_EPSILON = .0005;\nconst vec2 GLOBAL_PN = vec2(1,-1);\nconst vec3 GLOBAL_PN_XYY=GLOBAL_PN.xyy;\nconst vec3 GLOBAL_PN_YYX=GLOBAL_PN.yyx;\nconst vec3 GLOBAL_PN_YXY=GLOBAL_PN.yxy;\nconst vec3 GLOBAL_PN_XXX=GLOBAL_PN.xxx;\n\nconst vec3 GLOBAL_PN_XYY_EPS=GLOBAL_PN_XYY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YYX_EPS=GLOBAL_PN_YYX*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YXY_EPS=GLOBAL_PN_YXY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_XXX_EPS=GLOBAL_PN_XXX*GLOBAL_EPSILON;\nconst float MAX_DIST = 10.0;\n\n\nconst float COSTHETA1=0.70710677;\nconst float SINTHETA1=0.70710677;\nconst float SECTORSIZE1=0.5235987756;\nfloat sdf4(vec3 p){\n\t//Torus1\n\tfloat primaryRadius1=0.55;\n\tfloat secondaryRadius1=0.2;\n\treturn length(vec2(length(p.xz)-primaryRadius1,p.y))-secondaryRadius1;\n}\n\nconst float SCALE1=0.7;\n//Mandelbox1\nconst float S1=-2.9;\nconst float R1=0.5;\nconst int ITR1=10;\nconst float F1=1.0;\nvec3 scale_color1(vec3 q){\n\tvec3 p=q/SCALE1;\n\treturn vec3(1,1,1);\n}\nfloat sdf1(vec3 p){\n\treturn sdf4(p);\n}\nfloat sdf2(vec3 p){\n\tvec3 sp1=p/SCALE1;\n\tvec4 q3=vec4(sp1,1.0);\n\tvec4 c1=vec4(sp1,1.0);\n    float temp = +sin(iTime/4.)*0.25;\n\tfor (int a1=0;a1<ITR1;a1++){\n\t\tq3.xyz=F1*(clamp(q3.xyz,-1.0,1.0)*2.0-q3.xyz);\n\t\tq3 *=S1/clamp(dot(q3.xyz,q3.xyz),R1+temp,1.0);\n\t\tq3 +=c1;\n\t}\n\treturn (.333*length(q3.xyz)/abs(q3.w))*SCALE1;\n}\nfloat sdf3(vec3 p){\n\tfloat thickness=0.05;\n\tfloat surface=sdf1(p);\n\tfloat onioned=abs(surface)-thickness;\n\tif (onioned>thickness){\n\t\treturn onioned;\n\t}\n\telse if (surface<-thickness){\n\t\treturn surface;\n\t}\n\telse{\n\t\tfloat detail=sdf2(p);\n\t\tfloat dist = max(onioned,detail);\n\t\treturn min(dist,surface);\n\t}\n}\nvec3 onion_color1(vec3 p){\n\tfloat d1 = sdf1(p);\n\tfloat d2 = sdf2(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn vec3(2.0,1.0,0.0);\n\t}\n\telse{\n\t\treturn scale_color1(p);\n\t}\n}\nvec3 sector_color1(vec3 q){\n\tfloat sectorNumber1=round(atan(q.x,q.z)/SECTORSIZE1);\n\tfloat angleOffset1=-sectorNumber1*SECTORSIZE1;\n\tfloat cos1=cos(angleOffset1);\n\tfloat sin1=sin(angleOffset1);\n\tvec3 p=vec3(\n\t\tq.x*cos1+q.z*sin1,\n\tq.y,\n\t\tq.z*cos1-q.x*sin1\n\t);\n\treturn onion_color1(p);\n}\nvec3 rotation_color1(vec3 q){\n\tvec3 p=vec3(q.x,q.y*COSTHETA1+q.z*SINTHETA1,q.z*COSTHETA1+q.y*-SINTHETA1);\n\treturn sector_color1(p);\n}\nvec3 rotation_color2(vec3 q){\n\tfloat cosTheta1=cos(iTime/5.);\n\tfloat sinTheta1=sin(iTime/5.);\n\tvec3 p=vec3(q.x*cosTheta1+q.z*+sinTheta1,q.y,q.z*cosTheta1+q.x*-sinTheta1);\n\treturn rotation_color1(p);\n}\nvec3 translation_color1(vec3 q){\n\tvec3 p=q+vec3(-1.5,-0.0,-0.0);\n\treturn rotation_color2(p);\n}\n\nconst float SCALE2=0.5;\n//Box1\nconst vec3 BOX1=vec3(0.95,0.95,0.95);\nfloat sdf8(vec3 p){\n\tvec3 q4=abs(p)-BOX1;\n\treturn length(max(q4,0.0))+min(max(q4.x,max(q4.y,q4.z)),0.0);\n}\n\n//Mandelbox2\nconst float S2=-2.5;\nconst float R2=0.5;\nconst int ITR2=10;\nconst float F2=1.0;\nfloat sdf5(vec3 p){\n\treturn sdf8(p);\n}\nfloat sdf6(vec3 p){\n\tvec4 q5=vec4(p,1.0);\n\tvec4 c2=vec4(p,1.0);\n    float temp = sin(iTime/7.)*.25;\n    float temp2 = sin(iTime/4.)*.25;\n\tfor (int a2=0;a2<ITR2;a2++){\n\t\tq5.xyz=F2*(clamp(q5.xyz,-1.0,1.0)*2.0-q5.xyz);\n\t\tq5 *=(S2+temp)/clamp(dot(q5.xyz,q5.xyz),R2+temp2,1.0);\n\t\tq5 +=c2;\n\t}\n\treturn .333*length(q5.xyz)/abs(q5.w);\n}\nfloat sdf7(vec3 p){\n\tfloat thickness=0.1;\n\tfloat surface=sdf5(p);\n\tfloat onioned=abs(surface)-thickness;\n\tif (onioned>thickness){\n\t\treturn onioned;\n\t}\n\telse if (surface<-thickness){\n\t\treturn surface;\n\t}\n\telse{\n\t\tfloat detail=sdf6(p);\n\t\tfloat dist = max(onioned,detail);\n\t\treturn min(dist,surface);\n\t}\n}\nvec3 onion_color2(vec3 p){\n\tfloat d1 = sdf5(p);\n\tfloat d2 = sdf6(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn vec3(1.0,1.0,2.0);\n\t}\n\telse{\n\t\treturn vec3(1,1,1);\n\t}\n}\nvec3 scale_color2(vec3 q){\n\tvec3 p=q/SCALE2;\n\treturn onion_color2(p);\n}\nvec3 rotation_color3(vec3 q){\n\tfloat cosTheta2=cos(-iTime/5.);\n\tfloat sinTheta2=sin(-iTime/5.);\n\tvec3 p=vec3(q.x*cosTheta2+q.z*+sinTheta2,q.y,q.z*cosTheta2+q.x*-sinTheta2);\n\treturn scale_color2(p);\n}\nfloat sdf9(vec3 p){\n\tvec3 q1=p+vec3(-1.5,-0.0,-0.0);\n\t//Rotate y axis1\n\tfloat cosTheta1=cos(iTime/5.);\n\tfloat sinTheta1=sin(iTime/5.);\n\tvec3 rot1=vec3(q1.x*cosTheta1+q1.z*+sinTheta1,q1.y,q1.z*cosTheta1+q1.x*-sinTheta1);\n\t//Rotate x axis1\n\tvec3 rot2=vec3(rot1.x,rot1.y*COSTHETA1+rot1.z*SINTHETA1,rot1.z*COSTHETA1+rot1.y*-SINTHETA1);\n\tfloat sectorNumber1=round(atan(rot2.x,rot2.z)/SECTORSIZE1);\n\tfloat angleOffset1=-sectorNumber1*SECTORSIZE1;\n\tfloat cos1=cos(angleOffset1);\n\tfloat sin1=sin(angleOffset1);\n\tvec3 q2=vec3(\n\t\trot2.x*cos1+rot2.z*sin1,\n\trot2.y,\n\t\trot2.z*cos1-rot2.x*sin1\n\t);\n\treturn (sdf3(q2));\n}\nfloat sdf10(vec3 p){\n\t//Rotate y axis2\n\tfloat cosTheta2=cos(-iTime/5.);\n\tfloat sinTheta2=sin(-iTime/5.);\n\tvec3 rot3=vec3(p.x*cosTheta2+p.z*+sinTheta2,p.y,p.z*cosTheta2+p.x*-sinTheta2);\n\tvec3 sp2=rot3/SCALE2;\n\treturn ((sdf7(sp2))*SCALE2);\n}\nvec3 union_color1(vec3 p){\n\tfloat d1 = sdf9(p);\n\tfloat d2 = sdf10(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn translation_color1(p);\n\t}\n\telse{\n\t\treturn rotation_color3(p);\n\t}\n}\n\n//Box2\nconst vec3 BOX2=vec3(100.0,10.0,1.0);\nfloat sdf11(vec3 p){\n\tvec3 q7=abs(p)-BOX2;\n\treturn length(max(q7,0.0))+min(max(q7.x,max(q7.y,q7.z)),0.0);\n}\nvec3 translation_color2(vec3 q){\n\tvec3 p=q+vec3(-0.0,-0.0,-3.0);\n\treturn vec3(1.9,1.9,2.0);\n}\nfloat sdf12(vec3 p){\n\treturn (min(sdf9(p),sdf10(p)));\n}\nfloat sdf13(vec3 p){\n\tvec3 q6=p+vec3(-0.0,-0.0,-3.0);\n\treturn (sdf11(q6));\n}\nvec3 union_color2(vec3 p){\n\tfloat d1 = sdf12(p);\n\tfloat d2 = sdf13(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn union_color1(p);\n\t}\n\telse{\n\t\treturn translation_color2(p);\n\t}\n}\n\nfloat sdf14(vec3 p){\n\tvec3 planeAngleNorm1=vec3(0.0,1.0,0.0);\n\tfloat planeHeight1=1.1;\n\tfloat plane1=dot(p,planeAngleNorm1)+planeHeight1;\n\treturn plane1;\n}\nfloat sdf15(vec3 p){\n\treturn (min(sdf12(p),sdf13(p)));\n}\nfloat sdf16(vec3 p){\n\treturn (sdf14(p));\n}\nvec3 union_color3(vec3 p){\n\tfloat d1 = sdf15(p);\n\tfloat d2 = sdf16(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn union_color2(p);\n\t}\n\telse{\n\t\treturn vec3(1.0,0.9,0.9);\n\t}\n}\n\nconst float SCALE3=0.3;\nconst float SECTORSIZE2=0.31415926536;\nconst float SECTORSIZE3=0.31415926536;\nconst float SECTORSIZE4=0.31415926536;\nconst float COSTHETA2=0.70710677;\nconst float SINTHETA2=0.70710677;\nconst float SCALE4=0.75;\n//Mandelbox3\nconst float S3=-2.5;\nconst float R3=0.5;\nconst int ITR3=10;\nconst float F3=1.0;\nvec3 scale_color3(vec3 q){\n\tvec3 p=q/SCALE4;\n\treturn vec3(1,1,1);\n}\nvec3 rotation_color4(vec3 q){\n\tvec3 p=vec3(q.x,q.y*COSTHETA2+q.z*SINTHETA2,q.z*COSTHETA2+q.y*-SINTHETA2);\n\treturn scale_color3(p);\n}\nvec3 sector_color2(vec3 q){\n\tfloat sectorNumber4=round(atan(q.y,q.x)/SECTORSIZE4);\n\tfloat angleOffset4=-sectorNumber4*SECTORSIZE4;\n\tfloat cos4=cos(angleOffset4);\n\tfloat sin4=sin(angleOffset4);\n\tvec3 p=vec3(\n\t\tq.x*cos4-q.y*sin4,\n\t\tq.y*cos4+q.x*sin4,\n\t\tq.z\n\t);\n\treturn rotation_color4(p);\n}\nvec3 sector_color3(vec3 q){\n\tfloat sectorNumber3=round(atan(q.x,q.z)/SECTORSIZE3);\n\tfloat angleOffset3=-sectorNumber3*SECTORSIZE3;\n\tfloat cos3=cos(angleOffset3);\n\tfloat sin3=sin(angleOffset3);\n\tvec3 p=vec3(\n\t\tq.x*cos3+q.z*sin3,\n\tq.y,\n\t\tq.z*cos3-q.x*sin3\n\t);\n\treturn sector_color2(p);\n}\nvec3 sector_color4(vec3 q){\n\tfloat sectorNumber2=round(atan(q.y,q.x)/SECTORSIZE2);\n\tfloat angleOffset2=-sectorNumber2*SECTORSIZE2;\n\tfloat cos2=cos(angleOffset2);\n\tfloat sin2=sin(angleOffset2);\n\tvec3 p=vec3(\n\t\tq.x*cos2-q.y*sin2,\n\t\tq.y*cos2+q.x*sin2,\n\t\tq.z\n\t);\n\treturn sector_color3(p);\n}\n\nfloat sdf17(vec3 p){\n\tfloat rp1=5.336099999999998;\n\tfloat r1=2.3;\n\tfloat d1;\n\tfloat lp=dot(p,p);\n\tif (lp>rp1){\n\t\td1=sqrt(lp)-r1;\n\t}\n\telse{\n\t\tfloat sectorNumber2=round(atan(p.y,p.x)/SECTORSIZE2);\n\t\tfloat angleOffset2=-sectorNumber2*SECTORSIZE2;\n\t\tfloat cos2=cos(angleOffset2);\n\t\tfloat sin2=sin(angleOffset2);\n\t\tvec3 q9=vec3(\n\t\t\tp.x*cos2-p.y*sin2,\n\t\t\tp.y*cos2+p.x*sin2,\n\t\t\tp.z\n\t\t);\n\t\tfloat sectorNumber3=round(atan(q9.x,q9.z)/SECTORSIZE3);\n\t\tfloat angleOffset3=-sectorNumber3*SECTORSIZE3;\n\t\tfloat cos3=cos(angleOffset3);\n\t\tfloat sin3=sin(angleOffset3);\n\t\tvec3 q10=vec3(\n\t\t\tq9.x*cos3+q9.z*sin3,\n\t\tq9.y,\n\t\t\tq9.z*cos3-q9.x*sin3\n\t\t);\n\t\tfloat sectorNumber4=round(atan(q10.y,q10.x)/SECTORSIZE4);\n\t\tfloat angleOffset4=-sectorNumber4*SECTORSIZE4;\n\t\tfloat cos4=cos(angleOffset4);\n\t\tfloat sin4=sin(angleOffset4);\n\t\tvec3 q11=vec3(\n\t\t\tq10.x*cos4-q10.y*sin4,\n\t\t\tq10.y*cos4+q10.x*sin4,\n\t\t\tq10.z\n\t\t);\n\t\t//Rotate x axis2\n\t\tvec3 rot5=vec3(q11.x,q11.y*COSTHETA2+q11.z*SINTHETA2,q11.z*COSTHETA2+q11.y*-SINTHETA2);\n\t\tvec3 sp4=rot5/SCALE4;\n\t\tvec4 q12=vec4(sp4,1.0);\n\t\tvec4 c3=vec4(sp4,1.0);\n        float temp3=+sin(iTime/4.)*.5;\n\t\tfor (int a3=0;a3<ITR3;a3++){\n\t\t\tq12.xyz=F3*(clamp(q12.xyz,-1.0,1.0)*2.0-q12.xyz);\n\t\t\tq12 *=S3/clamp(dot(q12.xyz,q12.xyz),R3-temp3,1.0);\n\t\t\tq12 +=c3;\n\t\t}\n\t\td1=(.333*length(q12.xyz)/abs(q12.w))*SCALE4;\n\t}\nreturn d1;\n}\n\nfloat sdf18(vec3 p){\n\t//Sphere1\n\tfloat radius1 =1.9;\n\treturn length(p)-radius1;\n}\nfloat sdf19(vec3 p){\n\treturn (sdf17(p));\n}\nfloat sdf20(vec3 p){\n\treturn (sdf18(p));\n}\nvec3 union_color4(vec3 p){\n\tfloat d1 = sdf19(p);\n\tfloat d2 = sdf20(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn sector_color4(p);\n\t}\n\telse{\n\t\treturn vec3(1.0,0.0,0.0);\n\t}\n}\nvec3 scale_color4(vec3 q){\n\tvec3 p=q/SCALE3;\n\treturn union_color4(p);\n}\nvec3 rotation_color5(vec3 q){\n\tfloat cosTheta3=cos(iTime/5.);\n\tfloat sinTheta3=sin(iTime/5.);\n\tvec3 p=vec3(q.x*cosTheta3+q.z*+sinTheta3,q.y,q.z*cosTheta3+q.x*-sinTheta3);\n\treturn scale_color4(p);\n}\nvec3 translation_color3(vec3 q){\n\tvec3 p=q+vec3(1.5,-0.0,-0.0);\n\treturn rotation_color5(p);\n}\nfloat sdf21(vec3 p){\n\treturn (min(sdf15(p),sdf16(p)));\n}\nfloat sdf22(vec3 p){\n\tvec3 q8=p+vec3(1.5,-0.0,-0.0);\n\t//Rotate y axis3\n\tfloat cosTheta3=cos(iTime/5.);\n\tfloat sinTheta3=sin(iTime/5.);\n\tvec3 rot4=vec3(q8.x*cosTheta3+q8.z*+sinTheta3,q8.y,q8.z*cosTheta3+q8.x*-sinTheta3);\n\tvec3 sp3=rot4/SCALE3;\n\treturn ((min(sdf19(sp3),sdf20(sp3)))*SCALE3);\n}\nvec3 union_color5(vec3 p){\n\tfloat d1 = sdf21(p);\n\tfloat d2 = sdf22(p);\n\tif (abs(d1)<abs(d2)){\n\t\treturn union_color3(p);\n\t}\n\telse{\n\t\treturn translation_color3(p);\n\t}\n}\nfloat map7(vec3 p){\n\n\treturn min(sdf21(p),sdf22(p));\n}\nvec3 map7_color(vec3 p){\n\n\treturn(union_color5(p));\n}\n\n\n\n\n\n\nfloat map(in vec3 q){\n/*\n    float time = iTime/8.5;\n    //return 1.0;\n    vec3 p=q;\n\n    float lookDown=.2;\n    float cosld=cos(lookDown);\n    float sinld=sin(lookDown);\n    p=vec3(p.x,p.y*cosld+p.z*-sinld,p.z*cosld+p.y*sinld);\n    //p =vec3(\n    //    p.x*cos(time)+p.z*-sin(time),\n    //    p.y\n    //    ,p.z*cos(time)+p.x*sin(time)\n    //);\n    p=p+vec3(0.,-2.+sin(time*2.)*.125,0.);\n    \n    //float ang2 = sin(iTime/4.)*.25;\n    //p = vec3(p.x*cos(ang2)-p.y*sin(ang2),p.y*cos(ang2)+p.x*sin(ang2),p.z);\n\n    float m;\n    float mb=0.;\n\n    bool bound = false;\n   */\n    float m= map7(q)*.95;\n   \n    ///if (calcColor){\n     //   color = map7_color(q);\n    //}\n    \n \n    //m=min(m,q.y+1.8);\n   // m=min(m,-q.z+25.4);\n   \n    \n    return m;\n }\n    \n    \nvec3 map_color(vec3 p){\n    return map7_color(p);\n}\n \n \n    \n\n\nvec3 getSurfaceNormal( in vec3 p, float epsilon ) // for function f(p)\n{\n  \n    return normalize(\n        GLOBAL_PN_XYY*map(p+GLOBAL_PN_XYY_EPS) +\n        GLOBAL_PN_YYX*map(p+GLOBAL_PN_YYX_EPS) +\n        GLOBAL_PN_YXY*map(p+GLOBAL_PN_YXY_EPS) +\n        GLOBAL_PN_XXX*map(p+GLOBAL_PN_XXX_EPS) \n    \n    );\n}\n\n\nvoid rayMarch(\n    in vec3 origin, \n    in vec3 ray, \n    in float epsilon,\n    in float maxSteps,\n  \n    out vec3 marchPoint,\n    out float marchPointDist,\n    out float stepsTaken\n\n\n){\n    \n  \n    \n    stepsTaken = 0.0;\n    marchPoint=origin;\n    float h = map(marchPoint);\n    while (h>epsilon&&stepsTaken++<maxSteps&&h<MAX_DIST){\n        marchPoint+=ray*h;       \n        h=map(marchPoint);\n    }   \n    marchPointDist=h;\n   \n}\n\nfloat softShadowBalanced(vec3 surface, vec3 surfaceToLight, float radius, float maxDist){\n   \n    //return 1.0;\n  \n    //vec3 surfaceToLight = light-surface;\n    float distanceToLight=length(surfaceToLight);\n    float maxDist2 = min(maxDist,distanceToLight);\n    vec3 ray =normalize(surfaceToLight);\n    float artifactCompensation = 1.0;\n    float minDist = 0.05;//think about this.\n    \n    float travelled = minDist;\n    float xx=1.0;\n    while (travelled < maxDist2){\n    \n        float ratioTravelled=travelled/distanceToLight;\n        \n       \n        float relativeRadius=ratioTravelled*radius;\n        \n        float dist=map(surface+ray*travelled);\n         \n        if (dist<-relativeRadius){\n            return 0.0;\n        }\n        float relativeDiameter=relativeRadius*2.0;\n        \n        float dist2=dist+relativeRadius;\n        xx = min(xx,dist2/relativeDiameter);\n        \n       \n        float artifatCompensation2 = artifactCompensation*clamp(relativeRadius/dist,0.,1.);\n        travelled +=max(abs(dist/artifactCompensation),minDist);\n        \n        \n    }\n       \n   return xx;\n    \n\n    \n}\n\nvec3 power(vec3 vec, float power){\n    return vec3(pow(vec.x,power),pow(vec.y,power),pow(vec.z,power));\n}\n\n\nvoid calcLight(\n    in vec3 surfacePoint, \n    in float shineAtPosition,\n    in vec3 lightPosition,\n    in vec3 observationPosition,\n    in vec3 lightColor,\n    in float lightBrightness,\n    in vec3 surfaceNormal,\n    in float epsilon,\n    in float lightRadius,\n    out vec3 diffuse, \n    out vec3 specular){\n    \n \n     \n    vec3 col0 = lightColor;\n    \n    \n    vec3 surfaceToLight=lightPosition-surfacePoint;\n    vec3 normalToLight=normalize(surfaceToLight);\n    \n    float oneOverDistToLightSquared = lightBrightness/dot(surfaceToLight,surfaceToLight);\n    \n    \n    \n    float dp = dot(normalToLight,surfaceNormal);\n \n    dp=max(dp,0.0);\n\n    \n    diffuse=dp*lightColor*oneOverDistToLightSquared;\n    \n    \n    vec3 rayToObs=normalize(observationPosition-surfacePoint);\n    vec3 avg = normalize(normalToLight+rayToObs);\n    float spec = dot(avg,surfaceNormal);\n    spec = max(spec,0.0);\n    \n    spec = pow(spec,shineAtPosition);\n\n    specular=lightColor*spec*oneOverDistToLightSquared;\n    \n    float shadowAdjust = 1.0;\n    \n\n    if (true){\n        float s = softShadowBalanced(surfacePoint,surfaceToLight,lightRadius, 500.); \n        diffuse*=s*shadowAdjust;\n        specular*=s*shadowAdjust;\n    }\n \n}\n\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n    vec3 lense = vec3(0.0,0.0,1.);\n    \n    \n    vec3 cameraPosition = vec3(0.,2.5,-5);//.+sin(iTime/10.));\n    float specAmt = 0.0;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float epsilon1 = .00125;\n    \n   \n    \n  \n    vec2 ar = (fragCoord/iResolution.x)\n        -vec2(.5,iResolution.y/(2.0*iResolution.x));\n        \n    vec3 lenseIntersection = vec3(ar,lense.z);\n    \n    vec3 ray = normalize(lenseIntersection);//-eye);\n   \n    float lookDown=.09;\n    float cosld=cos(lookDown);\n    float sinld=sin(lookDown);\n   \n    ray = vec3(ray.x,ray.y*cosld+ray.z*-sinld,ray.z*cosld+ray.y*sinld);\n   \n    \n    float stepsTaken;\n    vec3 finalPosition;\n    float finalDistance;\n\n    float maxSteps = 200.0;\n    \n    \n   \n    \n    float time = iTime/8.5;\n\n    vec3 p=cameraPosition+ray;\n\n  \n    p=p+vec3(0.,-2.+sin(time*2.)*.125,0.);\n    \n \n\n    float m;\n    float mb=0.;\n\n    bool bound = false;\n    /////////////\n    \n    rayMarch(p,ray,epsilon1,maxSteps,finalPosition,finalDistance,stepsTaken);\n    \n    vec3 objColor= map_color(finalPosition);\n\n    \n    float objectShine=14.;\n    \n    \n    vec3 diffuse1;\n    vec3 specular1;\n\n    vec3 diffuse2;\n    vec3 specular2;\n\n    vec3 diffuse3;\n    vec3 specular3;\n\n    vec3 diffuse4;\n    vec3 specular4;\n    \n    if (finalDistance<epsilon1){\n    \n\n        finalPosition = finalPosition+(ray*epsilon1*-2.0);\n        vec3 normal = getSurfaceNormal(finalPosition,epsilon1);\n        \n       \n        \n        float lightBrightness = 1200.;\n        float specMult = 2.0;\n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(40.0,30.0,-40.0),//lightposition\n            cameraPosition,//observation position\n            vec3(1.,.9,.8),//light color\n            lightBrightness*2.,//light bright\n       \n            normal,\n            epsilon1,\n            1.,\n            diffuse1,\n            specular1\n        );\n        \n        /*\n         calcLight(\n            finalPosition,\n            objectShine,\n            vec3(-30.0,40.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.7,.325,0.)*.5,//light color\n            lightBrightness*1.5,//light bright\n            normal,\n            epsilon1,\n            1.,\n            diffuse2,\n            specular2\n        );\n        \n        \n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,30.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.35,1.5,.4)*.5,//light color\n            lightBrightness*.75,//light bright\n            normal,\n            epsilon1,\n            .5,\n            diffuse3,\n            specular3\n        );\n        */\n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(130.0,30.0,-480.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.9,.3)*.5,//light color\n            lightBrightness*5.,//light bright\n            normal,\n            epsilon1,\n            diffuse3,\n            specular3\n        );\n        */\n        \n        \n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,10.0,-5.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.8,.5)*.5,//light color\n            lightBrightness/20000.,//light bright\n            normal,\n            epsilon1,\n            diffuse4,\n            specular4\n        );\n    */\n    \n    \n        \n    \n        vec3 col1=objColor*max(diffuse1,0.0);\n        col1+=specular1*specMult;\n        \n        vec3 col2=objColor*max(diffuse2,0.0);\n        col2+=specular2*specMult;\n        \n        vec3 col3=objColor*max(diffuse3,0.0);\n        col3+=specular3*specMult;\n        \n      \n        vec3 colFinal = min(col1+col2+col3,1.);\n        colFinal=power(colFinal,.9);\n        \n     \n        \n        colFinal = pow(colFinal,vec3(.75,.74,.73));\n        \n        fragColor = vec4(colFinal,1.0);\n        \n    }\n    else{\n        fragColor = vec4(.2,0,0,1.0);\n\n    }\n    \n\n    \n    \n}\n\nvoid AntiAlias3( out vec4 fragColor, in vec2 fragCoord, float aaLevel){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float subPixel = 1.0/aaLevel;\n    vec4 result = vec4(0,0,0,1);\n    for (float x=fragCoord.x;x<fragCoord.x+1.0;x+=subPixel){\n        for (float y=fragCoord.y;y<fragCoord.y+1.0;y+=subPixel){\n            vec4 temp;\n            mainImage1(temp,vec2(x,y));\n            result+=temp;\n        }\n    }\n    \n    \n    fragColor = result/(aaLevel*aaLevel);\n   \n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord){\n\n    //vec4 result = vec4(0,0,0,1);\n    //mainImage1(result,fragCoord);\n    //fragColor=result;\n\n    if (HW_PERFORMANCE!=0){\n        AntiAlias3(fragColor, fragCoord,2.);\n    }\n    else{\n        vec4 result = vec4(0,0,0,1);\n        mainImage1(result,fragCoord);\n        fragColor=result;\n     }\n\n    fragColor.xyz = pow(fragColor.xyz,vec3(1.2,1.,.8));\n}\n","name":"Image","description":"","type":"image"}]}