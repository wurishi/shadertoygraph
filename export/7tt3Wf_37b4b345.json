{"ver":"0.1","info":{"id":"7tt3Wf","date":"1636893182","viewed":95,"name":"Barnsley's game of chaos","username":"Envy24","description":"Explanation: https://math.bu.edu/DYSYS/chaos-game/node1.html","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["fractal","game","chaos","of","tirangle","serpinski"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC ) { O = texture(iChannel0, SC/iResolution.xy); }","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \n    https://www.shadertoy.com/view/7tsGzX\n    Returns hash in range [0; UINT32_MAX].\n*/\nuint hashUI32(uint value)\n{\n    // Calculate hash.\n\tvalue += 67890u;\n\tvalue *= 445593459u;\n\tvalue ^= 12345u;\n\n    return value * value * value;\n}\n\n/* Signed distance of squared distances. \n   Should work faster without calculation square root. */\nfloat circleSDFSD(vec2 S, vec2 C,float r, float smoothness)\n{\n    // Sample coordinates relative to circle center.\n    float _x = S.x - C.x; float _y = S.y - C.y;\n    \n    // Signed distance of squares.\n    float sds = _x * _x + _y *_y - r * r;\n    \n    float ss = smoothness * smoothness;\n    \n    // Smoothstep interpolation.\n    return smoothstep(-ss, ss, sds);\n    //return smoothstep(-ss, ss, sds * sds); // outline\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R iResolution\n#define center(P) ( (P+P-R.xy)/R.y )       // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define TEX0(x) (texture(iChannel0, x))\n#define LMB_IS_HOLD  ( iMouse.z > 0.0 )\n\nfloat scene(in vec2 UV)\n{\n    float scale = 1.2;\n    vec2 triangle[3];\n    \n    /* Equaliteral triangle. */\n    triangle[0] = vec2(0.0, 0.75) * scale;\n    triangle[1] = vec2(-0.866025, -0.75)* scale;\n    triangle[2] = vec2(0.866025, -0.75)* scale;\n    /**/\n    \n    /* Right triangle. *\n    triangle[0] = vec2(-0.866025, 0.75) * scale;\n    triangle[1] = vec2(-0.866025, -0.75)* scale;\n    triangle[2] = vec2(0.866025, -0.75)* scale;\n    /**/\n    \n    /* Also works with other triangles. */\n    \n    /* First toss. */\n    uint rand = hashUI32(uint(iFrame));\n\n    /* Seed vertex. */\n    vec2 C = triangle[0];\n\n    for (int toss = 0; toss < 15; ++toss)\n    {\n        // Update coordinates.\n        C += (triangle[rand % 3u] - C) * 0.5;\n        //C = (C + triangle[rand % 3u]) * 0.5;\n\n        /* Other tosses with feedback. */\n        rand = hashUI32(rand);\n    }\n\n    float radius = 4.0 / R.x;\n    float smoothness = 3.0 / R.y;\n    \n    /* Sample size remains same for different resolutions. */\n    return circleSDFSD(UV, C, radius, smoothness);\n}\n\nvoid mainImage( out vec4 O, in vec2 P )\n{\n    /* White screen initialization. */\n    if (iTime < 0.1             // Initialization at launch.\n        || LMB_IS_HOLD == true) // Reinitialization (for fullscreen mode).\n    { O = vec4(1.0); return; }\n\n    O = vec4(\n            min(\n                scene(center(P)),\n                TEX0(P/R.xy).r)\n            );\n}","name":"Buffer A","description":"","type":"buffer"}]}