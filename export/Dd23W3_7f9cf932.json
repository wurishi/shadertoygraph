{"ver":"0.1","info":{"id":"Dd23W3","date":"1668714722","viewed":195,"name":"Perspective illusions","username":"Alpaga","description":"Drag the mouse to see from other angle.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","moon","ice","lights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHADOWS\n//#define AA\n\n#define STEPS 300\n#define FAR 60.0\n\n// Number of spheres\nconst int n = 61;\n\nconst float nf = float(n);\nconst float radius = 3./nf;\nvec4 sphere[n];\n\nconst float firstImage = 8.;\nconst float speed = 2.;\n\nconst vec3 fog = vec3(.1,.1,.15);\nvec3 moonDirection = normalize(vec3(1,1,-2));\nvec3 moonCol = vec3(.1,.1,.15);\nconst float fov = 35.0;\nconst float fovFactor = tan(0.5*fov*0.01745);\n\nfloat time;\nconst float PI = 3.14159;\n\n// Hash functions from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat noise(vec2 p) {\n    vec2 fl = floor(p);\n \tvec2 fr = p - fl;\n    fr = fr*fr*(3.-2.*fr);\n    \n    const vec2 b = vec2(0,1);\n    return mix(mix(hash12(fl+b.xx), hash12(fl+b.yx), fr.x),\n               mix(hash12(fl+b.xy), hash12(fl+b.yy), fr.x), fr.y);\n}\nfloat fbm(vec2 p) {\n    float h = 0., f=1., a=.5;\n    h += a*noise(f*p); f *= 2.; a *=.5;\n    h += a*noise(f*p); f *= 2.; a *=.5;\n    h += a*noise(f*p);\n    return h;\n}\n// Smoothmin taken from vgs\n// https://www.shadertoy.com/view/Ml3Gz8\n// Polynomial smooth min (for copying and pasting into your shaders)\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nmat3 viewMatrix(vec3 forward, vec3 up) {\n \tvec3 w = -normalize(forward);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\n\n// Camera path\nvec3 camPosition(float t) {\n    t *= speed;\n    return vec3(1.*cos(t),.2*sin(2.*t),-3.*t);\n}\n\nvec3 camDirection(float t) {\n    return normalize(camPosition(t+.1)-camPosition(t)+vec3(0,.12,0));\n}\nmat3 camMatrix(float t) {\n    vec3 f = camDirection(t);\n    vec3 u = vec3(0,1,0);\n    return viewMatrix(f,u);\n}\n\n// We define here the images.\n// 2D position of sphere number *i* on image number *im*\nvec2 spherePositionOnImage(float i, float im) {\n    return .8*(.0+1.*i/nf)*vec2(cos(2.*PI*i*im/nf),sin(2.*PI*i*im/nf));\n}\nvec3 sphereColor(float i) {\n    return .5+.5*sin(.02*vec3(4,5,6)*i+vec3(3,4,5));\n}\n\n// Time at which image number *im* is seen on the screen  \nfloat meetingTime(float im) {\n    return 3.*PI*(im-firstImage)/speed;\n}\n\n// Calculates 3D sphere positions so that they project to the \n// 2D positions defined in spherePositionOnImage.\n// Returns 3D position in .xyz channels, radius in .a channel.\nvec4 spherePosition(float i, float im) {\n    vec2 q = spherePositionOnImage(i, im);\n    // Random depth\n    float d = 5.+.2*i+10.*hash11(i+im);\n    \n    float r = fovFactor*radius*d;\n    \n    float t = meetingTime(im);\n    vec3 eye = camPosition(t);\n    mat3 mEye = camMatrix(t);\n    \n    return vec4(eye + d*mEye*vec3(fovFactor*q,-1.), r);\n}\n\nvec4 interpolate(vec4 a, vec4 b, float t) {\n    return (1.-t)*(1.-t)*(1.-t)*a +\n        3.*(1.-t)*(1.-t)*t*vec4(-a.x,-a.y,a.z,0)+ //.1*a.xy,a.z-10.,a.w) +\n        3.*(1.-t)*t*t*vec4(5.*b.xy,b.z+10.,b.w) +\n        t*t*t*b;\n}\n\n// Calculates 3D sphere positions by interpolating between\n// the positions computed by spherePosition(i, im)\nvec4 spherePosition(float i) {\n    float fr = speed*time/(3.*PI)+firstImage;\n    float image = floor(fr);\n    fr -= image;\n    \n    fr = smoothstep(.0,.5,fr);\n    \n    vec4 a = spherePosition(i, image);\n    vec4 b = spherePosition(i, image+1.);\n    \n    return interpolate(a,b,fr);\n}\n\n// Calculate light coming from spheres along a ray.\n// Discard spheres farther than given depth.\n\n// Returns color in .rgb channels, light quantity in .a channel\nvec4 spheresLight(vec3 start, vec3 dir, float depth) {\n    vec4 col = vec4(0);\n    float minSphereDepth = 1e6;\n        for(int i=0; i<n; i++) {\n            // Compute sphere depth and distance to the ray\n            vec4 q = sphere[i];\n            q.xyz -= start;\n            float sphereDepth = dot(q.xyz,dir);\n            float d = sphereDepth * length(normalize(q.xyz)-dir);\n            d -= q.a;\n            \n            if(sphereDepth<depth) {// Discard if sphere behind obstacle\n                if(d<0. && sphereDepth<minSphereDepth) {\n                    // Closest sphere \n                    col.xyz = 4.*sphereColor(float(i));\n                    minSphereDepth = sphereDepth;\n                    col.a = 1.;\n                } else {\n                    // Glow\n                    float k = pow(max(0.,1.-2.*d),3.);\n                    col.xyz += k*sphereColor(float(i));\n                    col.a += k;\n\n                }\n            }\n        }\n    return col;\n}\n\n// Snow bumps\nfloat bump(vec2 p) {\n    return fbm(3.*p);\n}\n// Sd to floor\nfloat sd(vec3 p) {\n    // A tunnel arond camera path...\n    float t = -p.z/3.;\n    float dx = abs(p.x-1.*cos(t));\n    float h = .2*sin(2.*t)+.1*dx*dx-.1;\n    // ...with bumps\n    h += .2*bump(p.xz)-.1;\n   \n    h = smin(h,5.,1.);\n    \n    return .7*(p.y-h);\n}\n\nvec3 normal(vec3 p) {\n    const vec2 delta = vec2(0,.001);\n    float d = sd(p);\n    return normalize(vec3(\n        sd(p+delta.yxx),\n        sd(p+delta.xyx),\n        sd(p+delta.xxy))-d);\n}\n\nfloat march(vec3 start, vec3 dir) {\n\tfloat total = 0., d = 1.;\n    float epsilon = fovFactor*.5/iResolution.y;\n    int i=0;\n    for(; i<STEPS; i++) {\n        if(d<epsilon*total) return total;\n        if(total>FAR) break;\n        d = sd(start + total*dir);\n        total += d;\n    }\n    return FAR+1.;\n}\n\nfloat lightMarch(vec3 start, vec3 dir, float lightDist) {\n\tfloat total = 0., d = 1.;\n    float epsilon = fovFactor*.5/iResolution.y;\n    float minD = 1000.0;\n    for(int i=0; i<STEPS; i++) {\n        if(d<epsilon*total || total>lightDist) break;\n        d = sd(start + total*dir);\n        total += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight, float lightDist) {\n    float minD = lightMarch(p+0.05*toLight, toLight, lightDist-.05);\n    return smoothstep(0.0,0.04,minD);\n}\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 color = vec3(0);\n    \n    float minD;\n    float d = march(start, dir);\n\n    if(d > FAR) {// SKY\n        // Sky\n        vec3 sky = vec3(0,0,.05*pow(1.-dir.y,2.));\n        sky = mix(fog,sky,dir.y/(.01+dir.y));\n        \n        // Stars\n        const vec3 star = vec3(1,1,.7);\n        vec2 q = 40.*dir.xy;\n        vec2 fl = floor(q);\n        fl += .1+.8*hash12(fl);\n        // No star with probability .9\n        float bit = step(.9,hash12(fl+315.812));\n        float r = min(.1*hash12(fl+153.81),bit);\n        color = mix(star,sky,smoothstep(.5*r,r,length(q-fl)));\n        \n        // Moon\n        float l = length(dir-moonDirection);\n        float s = 1./(1.+1e5*pow(l,4.));\n        // Moon glow\n        color = mix(color,2.*moonCol,s);\n        // Moon\n        color = mix(30.*moonCol*fbm(50.*dir.xy),color,smoothstep(.048,.05,l));\n    } else {\n        vec3 p = start + d * dir;\n\n        vec3 normal = normal(p);\n                \n        // Fake subsurface: more light at the top of bumps\n        float b = .5-bump(p.xz);\n        const vec3 ice = vec3(.3,.8,1);\n        vec3 subsurface = ice*exp(-3.*b);\n        {\n            // Diffuse\n            float diff = max(dot(moonDirection, normal), 0.0);\n\n            // Specular\n            vec3 h = normalize(moonDirection-dir);\n            float spec = 20. * pow(max(dot(h,normal),0.0), 300.0);\n\n            #ifdef SHADOWS\n            // Shadow\n            float sh = shadow(p, moonDirection, 10.);\n            #else\n            float sh = 1.;\n            #endif\n            color += sh*(subsurface + diff + spec)*moonCol;\n        }\n        for(int i=0; i<n; i++) {\n            vec3 lightPosition = sphere[i].xyz;\n            vec3 lightCol = 30.*sphereColor(float(i))*sphere[i].a;\n            \n            vec3 lightDirection = lightPosition-p;\n            float lightDist = length(lightDirection);\n            lightDirection /= lightDist;\n\n\n            // Diffuse\n            float diff = max(dot(lightDirection, normal), 0.0);\n            \n            // Specular\n            vec3 h = normalize(lightDirection-dir);\n            float spec = 20. * pow(max(dot(h,normal),0.0), 300.0);\n\n            color += (subsurface + diff + spec)*lightCol/(1.+20.*lightDist*lightDist);\n        }\n       // color = subsurface;\n        color = mix(fog,color,smoothstep(100.,90.,minD));//exp(-.0003*d*d));\n    }\n\n    vec4 l = spheresLight(start, dir, d);\n    return mix(color, l.xyz, l.a);\n}\n\nvoid initSpheres() {\n    for(int i=0; i<n; i++) {\n        sphere[i] = spherePosition(float(i));\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = iTime;//+3.*PI;\n    vec3 cam = camPosition(time);\n        mat3 m = camMatrix(time);\n\n    if(iMouse.z>0.0) {\n        float a = -1.5*PI*(2.*iMouse.x/iResolution.x-1.);\n        float b = .5*PI-.53*PI*iMouse.y/iResolution.y;\n        \n        vec3 center = vec3(0,3,cam.z-23.);\n        vec3 relativeCam = 40.*vec3(sin(a)*cos(b),sin(b),cos(a)*cos(b));\n        cam = center + relativeCam;\n        \n        m = viewMatrix(-relativeCam,vec3(0,1,0));\n       // time = 100.*iMouse.x/iResolution.x;\n    }\n    //moonDirection = normalize(vec3(cos(.1*iTime),sin(.1*iTime),-1.5));\n    initSpheres();\n    \n    vec3 color = vec3(0.0);\n\n    vec2 uv;\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            uv = (2.0*(fragCoord + vec2(i,j)) - iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    \n            vec3 dir = normalize(m*pix);\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(fovFactor*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    #endif\n        \n  //  color = color/(1.+color);\n    color = 1.-exp(-color);\n    // Vignette\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1. - uv.yx;\n    color *= pow(uv.x*uv.y * 15.0, 0.25);\n    \n    // Gamma\n    color = pow(color, vec3(1./2.2));\n        \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}