{"ver":"0.1","info":{"id":"MfccWf","date":"1731895983","viewed":51,"name":"L Game","username":"dray","description":"L Game against GPU.\nCorner Blue L so it cannot move.\nMove your Red L first by clicking where you want it a few times, then click 1 yellow to move it elsewhere.\nRewind to restart.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["2d","game"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The L game is played with two L shaped pieces\n// and two square pieces on a 4x4 square board.\n// From the starting position, you take turns\n// moving your L and then either square piece to\n// try to corner your opponent's L so he cannot move.\n// You can only move pieces to unoccupied\n// squares on the board.\n\n// L Game against GPU.\n// Corner Blue L so it cannot move.\n// Move your Red L first by clicking where you want it a\n// few times, then click either yellow and click again where\n// you want it to go.\n// Rewind to restart.\n\n// I had this game a long time ago.\n// This is barely better than tic-tac-toe (noughts and crosses, Xs and Os).\n// This version probably isn't better.\n// At least UI works on phone.\n// I took a break with this...\n\n// The L Game was invented by Edward de Bono in 1967.\n \nvoid mainImage( out vec4 O, in vec2 U )\n{\n    U /= min(1.,iTime); // <-- this is the only exciting thing here.\n    O = texelFetch(iChannel0, ivec2(U), 0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define B(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p) \\\n (a*1+b*2+c*4+d*8+e*16+f*32+g*64+h*128+i*256+j*512+k*1024+l*2048+m*4096+n*8192+o*16384+p*32767)\n\n#define SHIFT23(L1) \\\n  L1 << 0, \\\n  L1 << 1, \\\n  L1 << 4, \\\n  L1 << 5, \\\n  L1 << 8, \\\n  L1 << 9,\n\n#define SHIFT32(L2) \\\n  L2 << 0, \\\n  L2 << 1, \\\n  L2 << 2, \\\n  L2 << 4, \\\n  L2 << 5, \\\n  L2 << 6,\n\n// possible L positions\nint[] Lpos = int[]( // 6*8=48\n  SHIFT23(B(\n  1,1,1,0,\n  1,0,0,0,\n  0,0,0,0,\n  0,0,0,0 ) )\n  SHIFT23(B(  // 6\n  1,1,1,0,\n  0,0,1,0,\n  0,0,0,0,\n  0,0,0,0 ) )\n  SHIFT23(B(  // 12\n  1,0,0,0,\n  1,1,1,0,\n  0,0,0,0,\n  0,0,0,0 ) )\n  SHIFT23(B(  // 18\n  0,0,1,0,\n  1,1,1,0,\n  0,0,0,0,\n  0,0,0,0 ) )\n  SHIFT32(B(  // 24\n  1,1,0,0,\n  1,0,0,0,\n  1,0,0,0,\n  0,0,0,0 ) )\n  SHIFT32(B(  // 30\n  1,0,0,0,\n  1,0,0,0,\n  1,1,0,0,\n  0,0,0,0 ) )\n  SHIFT32(B(  // 36\n  1,1,0,0,\n  0,1,0,0,\n  0,1,0,0,\n  0,0,0,0 ) )\n  SHIFT32(B(  // 42\n  0,1,0,0,\n  0,1,0,0,\n  1,1,0,0,\n  0,0,0,0 ) )\n  0\n);\n\n#define VARS(OP) \\\nOP(redp,1) \\\nOP(blup,2) \\\nOP(yel1p,3) \\\nOP(yel2p,4) \\\nOP(state,5) \\\nOP(oredp,6) \\\nOP(loser,7)\n\n//#define MouseDown ( iMouse.z > 0. ) // not on phone !\n#define MouseClick ( iMouse.w > 0. ) \n\n#define INSIDE(V) ( V.x >= 0 && V.y >= 0 && V.x <= 3 && V.y <= 3 )\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n\n    O = iFrame > 2 ? texelFetch(iChannel0, ivec2(U), 0) : vec4(0);\n\n    #define GET(VAR,NDX) int VAR = iFrame < 2 ? 0 : int(texelFetch(iChannel0, ivec2(0,NDX), 0));\n    VARS(GET)\n\n    if ( iFrame < 4 )\n    {\n        oredp = redp = 46;\n        blup = 25;\n        yel1p = 3;\n        yel2p = 12;\n        loser = 0;\n    }\n\n    vec2 v = (U-iResolution.xy/2.)/min(iResolution.y,iResolution.x)*1.2+.5;\n    ivec2 cell = ivec2(floor(v*4.));\n\n    vec2 M = (iMouse.xy-iResolution.xy/2.)/min(iResolution.y,iResolution.x)*1.2+.5;\n    ivec2 Mcell = ivec2(floor(M*4.));\n    int Mcn = Mcell.x + 4*Mcell.y;\n\n    int red = Lpos[redp], blu = Lpos[blup], yel1 = 1<<yel1p, yel2 = 1<<yel2p;\n    \n    if ( state == 0 ) { // move L\n        if ( MouseClick && INSIDE(Mcell) )\n        if ( Mcn == yel1p && redp != oredp ) state = 3; // pick yellow 1\n        else\n        if ( Mcn == yel2p && redp != oredp ) state = 4; // pick yellow 2\n        else\n        {  // move Red L\n            if ( loser == 1 ) loser = 0;\n            int occu = Lpos[blup] | (1<<yel1p) | (1<<yel2p);\n            int loc = redp;\n            int cnt = 0, found = -1;\n            for ( int tries = 0; tries < 48; ++tries ) {\n                loc = (loc+1) % 48;\n                if ( ( Lpos[loc] & occu ) == 0 && // unoccupied\n                       loc != oredp ) {  // not same place\n                    ++cnt;\n                    if ( ( Lpos[loc] & (1<<Mcn) ) > 0 ) // desired location\n                        if ( found == -1 ) found = loc;\n                }\n            }\n            if ( cnt < 1 )\n                loser = 1; // could not find anything else ?\n            if ( found >= 0 )\n                red = Lpos[ redp = found ];\n        }\n    } \n    else if ( state == 3 ) { // move yellow 1\n        oredp = redp;\n        int occu = Lpos[redp] | Lpos[blup] | yel2;\n        if ( MouseClick && INSIDE(Mcell) && ( (occu & (1<<Mcn)) == 0 ) ) {\n            yel1p = Mcn;\n            state = 10;\n        }\n        else\n            yel1 = 0;\n    }\n    else if ( state == 4 ) { // move yellow 2\n        oredp = redp;\n        int occu = Lpos[redp] | Lpos[blup] | yel1;\n        if ( MouseClick && INSIDE(Mcell) && ( (occu & (1<<Mcn)) == 0 ) ) {\n            yel2p = Mcn;\n            state = 10;\n        }\n        else\n            yel2 = 0;\n    }\n    else if ( state >= 10 && state < 110 ) {\n        state += 1; // act like working hard, but actually this is all\n    }\n    else if ( state == 110 ) { // machine, not smart\n        int occu = Lpos[redp] | yel1 | yel2;\n        int best = blup, score = -1;\n        int loc = blup;\n        for ( int tries = 0; tries < 48; ++tries ) {\n            loc = (1+loc) % 48;\n            if ( ( Lpos[loc] & occu ) != 0 || loc==blup ) continue;\n            // Tiny heuristic\n            int atry = 0;\n            if ( ( Lpos[loc] & (1<<5) ) > 0 ) ++atry;\n            if ( ( Lpos[loc] & (1<<6) ) > 0 ) ++atry;\n            if ( ( Lpos[loc] & (1<<9) ) > 0 ) ++atry;\n            if ( ( Lpos[loc] & (1<<10) ) > 0 ) ++atry;\n            if ( atry > score ) best = loc, score = atry;\n        }\n        if ( best == blup ) loser = 2;\n        blup = best;\n        blu = Lpos[blup];\n        if ( loser == 0 ) {\n            int loc = yel1p;\n            int occu = red | blu | yel1 | yel2;\n            for ( int tries = 0; tries < 16; ++tries )\n                if ( (occu & (1<<(++loc%16))) == 0 ) break;\n            yel1p = loc % 16;\n            yel1 = 1 << yel1p;\n            state = 0;\n/* It this was smart, search small tree of possibilities:\n~10 pos * 2 yel * 6 dests = ~120 possible moves at a step\n2-3 look-aheads possible in maybe 1 frame\n*/\n       }\n    }\n        \n\n    // Draw board\n    if ( cell.x >= 0 && cell.y >= 0 && cell.x <= 3 && cell.y <= 3 ) {\n\n    O = vec4( abs(fract(v.x*4.)-.5) > .48 || abs(fract(v.y*4.)-.5) > .48 ? .75 : 1. );\n\n    if ( ( ( yel1 >> (cell.x+4*cell.y) ) & 1 ) > 0 ) O=vec4(1,1,0,1);\n    if ( ( ( yel2 >> (cell.x+4*cell.y) ) & 1 ) > 0 ) O=vec4(1,1,0,1);\n\n    if ( loser != 1 || mod(iTime,.2)>.1 )\n    if ( ( ( red  >> (cell.x+4*cell.y) ) & 1 ) > 0 ) O=vec4(1,0,0,1);\n    if ( loser != 2 || mod(iTime,.2)>.1 )\n    if ( ( ( blu  >> (cell.x+4*cell.y) ) & 1 ) > 0 ) \n      O= state > 12 && state < 100\n       ? vec4(vec3(mod(iTime*4.,1.)),1)\n       : vec4(0,0,1,1);\n\n    }\n    \n    #define SET(VAR,NDX) if (ivec2(U)==ivec2(0,NDX)) O = vec4(VAR);\n    VARS(SET)\n    \n}\n","name":"Buffer A","description":"","type":"buffer"}]}