{"ver":"0.1","info":{"id":"fdXBD2","date":"1645381238","viewed":147,"name":"Noisy Chromatic Aberration","username":"QuadricNightmare","description":"Chromatic aberration effect but with offsets shifted with noise, exaggerating the effect in an uneven way","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","distortion","chromatic","aberration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Adjust these to vary effect colouring [0 <= x <= 1]\nconst float g_redScale = 0.02f;\nconst float g_greenScale = 0.005f;\nconst float g_blueScale = 0.013f; \n\n//Controls distribution of effect from centre outward\n//1 == linear, > 1 pushes effect to scene boundry and keeps centre without chromatic aberration. \n//This is a sensitve parameter, > 1.5 makes overall effect very subtle.\nconst float g_distrubutionExponent = 1.2f; \n\n//Overall effect strength\nconst float g_effectStrength = 1.f; \n\n//Noise influence\nconst float g_noise = 15.0f;\nconst float g_noiseUVScale = 1.f;\n\n//Adjust noise effect speed [0 <= x]\nconst float g_speed = 0.f; \n\nvec2 mapOffset(vec2 offset, float globalScale)\n{\n    const vec2 exponent = vec2(g_distrubutionExponent);\n    \n    vec2 signs = vec2(sign(offset.x), sign(offset.y));\n    return pow(abs(offset), exponent) * globalScale * signs;\n}\n\nvec4 simpleChromaticAberration(vec2 fragCoord, float globalScale)\n{\n    vec2 ndc = (fragCoord / iResolution.xy) * 2.f - 1.f; \n        \n    vec2 redUV = (ndc - mapOffset(ndc * g_redScale, globalScale)) * 0.5f + 0.5f;\n    vec2 greenUV = (ndc - mapOffset(ndc * g_greenScale, globalScale)) * 0.5f + 0.5f;\n    vec2 blueUV = (ndc - mapOffset(ndc * g_blueScale, globalScale)) * 0.5f + 0.5f;\n    \n    float red = texture(iChannel0, redUV).r;\n    float green = texture(iChannel0, greenUV).g;\n    float blue = texture(iChannel0, blueUV).b;\n    \n    return vec4(red, green, blue, 1.f);\n}\n\nfloat scrollingNoise(vec2 fragCoord, float uvScale)\n{\n    vec2 uvA = (fragCoord / iResolution.xy + iTime * g_speed) * uvScale;\n    vec2 uvB = (-fragCoord / iResolution.xy + iTime * g_speed) * uvScale;\n    \n    return texture(iChannel1, uvA).r * texture(iChannel1, uvB).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float noise = scrollingNoise(fragCoord, g_noiseUVScale) * g_noise;\n    fragColor = simpleChromaticAberration(fragCoord, (1.f + noise) * g_effectStrength);\n}","name":"Image","description":"","type":"image"}]}