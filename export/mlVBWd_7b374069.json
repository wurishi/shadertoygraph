{"ver":"0.1","info":{"id":"mlVBWd","date":"1702668597","viewed":14,"name":"Y'PbPr colorplane for sRGB","username":"serioux666","description":"Display colors for sRGB colorspace. X and Y coordinates are Pb and Pr. Luminance Y can be set by mouse x position. Impossible colors are set to black.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["colorspace","ycbcr","ypbpr"],"hasliked":0,"parentid":"DlKBDK","parentname":"Rec.709 Whitepoint Adjust"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Copyright (C) 2023  Gregor Vollmer <gpl@dynamic-noise.net>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nstruct primaries {\n    vec2 red;\n    vec2 green;\n    vec2 blue;\n};\n\nstruct csTransforms {\n    mat3 RGB_to_XYZ;\n    mat3 XYZ_to_RGB;\n    mat3 RGBprime_to_YPbPr;\n    mat3 YPbPr_to_RGBprime;\n    vec3 K;\n    vec2 white_xy;\n};\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst vec2 WHITEPOINT_sRGB = vec2(0.3127, 0.3290);\nconst vec2 WHITEPOINT_Rec709 = vec2(0.312713, 0.329016);\n\nconst primaries PRIMARIES_sRGB = primaries(vec2(0.64, 0.33), vec2(0.30, 0.60), vec2(0.15, 0.06));\nconst primaries PRIMARIES_Rec709 = primaries(vec2(0.64, 0.33), vec2(0.30, 0.6), vec2(0.15, 0.06));\n\nvec2 getChromaticityByCCT(float cct);\ncsTransforms calculateColorspaceTransforms(primaries p, vec2 white_xy);\nvec3 xy_to_XYZ(vec2 pc);\nvec3 OETF_sRGB(vec3 col);\nvec3 EOTF_sRGB(vec3 col);\nvec3 OETF_Rec709(vec3 col);\nvec3 EOTF_Rec709(vec3 col);\nfloat OETF_Rec709(float col);\nfloat EOTF_Rec709(float col);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, pos).rgb;\n    vec2 mouseRel = iMouse.xy / iResolution.xy;\n    if(iMouse.xy == c.yy) {\n        mouseRel = vec2(0.5, 0.8);\n    }\n    csTransforms cs_sRGB = calculateColorspaceTransforms(PRIMARIES_sRGB, WHITEPOINT_sRGB);\n    vec3 YPbPr = vec3(mouseRel.x, pos - 0.5);\n    col = cs_sRGB.YPbPr_to_RGBprime * YPbPr;\n    if(max(col.r, max(col.g, col.b)) > 1.) {\n        col = c.yyy;\n    }\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\nvec2 getChromaticityByCCT(float cct)\n{\n    float cct2 = cct*cct;\n    float u = (0.860117757 + 1.54118254e-4 * cct + 1.28641212e-7 * cct2) / (1. + 8.42420235e-4 * cct + 7.08145163e-7 * cct2);\n    float v = (0.317398726 + 4.22806245e-5 * cct + 4.20481691e-8 * cct2) / (1. - 2.89741816e-5 * cct + 1.61456053e-7 * cct2);\n    return vec2(3.*u, 2.*v) / (2.*u - 8.*v + 4.);\n}\n\ncsTransforms calculateColorspaceTransforms(primaries p, vec2 white_xy)\n{\n    csTransforms cs;\n    mat3 P = (mat3(xy_to_XYZ(p.red), xy_to_XYZ(p.green), xy_to_XYZ(p.blue)));\n    mat3 M = inverse(P);\n    cs.K = M * xy_to_XYZ(white_xy);\n    cs.white_xy = white_xy;\n    cs.RGB_to_XYZ = (mat3(xy_to_XYZ(p.red) * cs.K.r, xy_to_XYZ(p.green) * cs.K.g, xy_to_XYZ(p.blue) * cs.K.b));\n    cs.XYZ_to_RGB = inverse(cs.RGB_to_XYZ);\n    cs.RGBprime_to_YPbPr = transpose(mat3(cs.K,\n                     -0.5 * cs.K.r / (1. - cs.K.b), -0.5 * cs.K.g / (1. - cs.K.b), 0.5,\n                     0.5, -0.5 * cs.K.g / (1. - cs.K.r), -0.5 * cs.K.b / (1. - cs.K.r)));\n    cs.YPbPr_to_RGBprime = inverse(cs.RGBprime_to_YPbPr);\n    return cs;\n}\n\nvec3 xy_to_XYZ(vec2 pc)\n{\n    return vec3(pc.x / pc.y, 1., (1. - pc.x - pc.y) / pc.y);\n}\n\nvec3 OETF_sRGB(vec3 col)\n{\n    return pow(col, 1./2.2 * c.xxx);\n}\n\nvec3 EOTF_sRGB(vec3 col)\n{\n    return pow(col, 2.2 * c.xxx);\n}\n\nvec3 OETF_Rec709(vec3 col)\n{\n    return vec3(\n        OETF_Rec709(col.x),\n        OETF_Rec709(col.y),\n        OETF_Rec709(col.z));\n}\n\nvec3 EOTF_Rec709(vec3 col)\n{\n    return vec3(\n        EOTF_Rec709(col.x),\n        EOTF_Rec709(col.y),\n        EOTF_Rec709(col.z));\n}\n\nfloat OETF_Rec709(float E)\n{\n\n    const float alpha = 1.09929682680944;\n    const float beta = 0.018053968510807;\n    return E <= beta ? 4.5 * E : alpha * pow(E, 0.45) - (alpha - 1.);\n}\n\nfloat EOTF_Rec709(float V)\n{\n    const float L_W = 1.0;\n    const float L_B = 0.0;\n    const float gamma = 2.4;\n    const float inv_gamma = 1. / gamma;\n    const float a = pow(pow(L_W, inv_gamma) - pow(L_B, inv_gamma), gamma);\n    const float b = pow(L_B, inv_gamma) / (pow(L_W, inv_gamma) - pow(L_B, inv_gamma));\n    return a * pow(clamp(V + b, 0.0, 1e9), gamma);\n}","name":"Image","description":"","type":"image"}]}