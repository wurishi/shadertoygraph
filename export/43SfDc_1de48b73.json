{"ver":"0.1","info":{"id":"43SfDc","date":"1729981444","viewed":63,"name":"Cubic Spline Blossom/Polar Form","username":"chronos","description":"Rederiving deBoor algorithm i.e B-spline evaluation via \"polar forms\", aka \"blossoming\".\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["polar","cubic","form","blossoming","bspline","blossom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Cubic Spline Blossom/Polar Form by chronos\n    ---------------------------------------------------------------\n\n    Rederiving deBoor algorithm i.e B-spline evaluation\n    via \"polar forms\", aka \"blossoming\".\n    \n    The polar form (or blossoming) view of splines \n    is some of the most beautiful mathematics I know :)\n    \n    Interactive: Move the control points by clicking and dragging\n    ---------------------------------------------------------------\n    self link: https://www.shadertoy.com/view/43SfDc\n    ---------------------------------------------------------------\n*/\n\n\n/*\n\nNotation:\n\nFunction f(x)\nPolar form F(x0, x1, x2) \nControl points c0, c1, c2, c3\nKnots t0, t1, t2 etc\n\n// polarization property\n// symmetry: F(x,y) = F(y,x)\n// multi-affine   F((1-z)*x,y) + F(z * x,y) = (1-z)*F(x,y) + z*F(x,y)\n// Diagonal property: F(x, x, x) = f(x)\n\n// cubic control points (splines):\n\nc0 = F(t0, t1, t2)\nc1 = F(t1, t2, t3)\nc2 = F(t2, t3, t4)\nc3 = F(t3, t4, t5)\n\n// Derivation of cubic spline:\n\nLevel 0\n\nc0 = F(t0, t1, t2)\nc1 = F(t1, t2, t3)\nc2 = F(t2, t3, t4)\nc3 = F(t3, t4, t5)\n\n// Level 1, combine 4 to 3:\nF(x, t1, t2) = (1-z0) * F(t0, t1, t2) + z0 * F(t3, t1, t2) = F((1-z)t0 + z * t3, t1, t2)\nF(x, t2, t3) = F((1-z1)*t1 + z1*4, t2, t3)\nF(x, t2, t3) = F((1-z2)*t2 + z2*t5, t3, t4)\n\nsolve first for z0:\nx = (1-z)t0 + z * t3\nx = t0 + z * (t3-t0)\nz = (x - t0) / (t3 - t0)\n\nGeneral pattern: Inv lerp: (x - t_a)/(t_b - t_a)\n\nwe get:\nF(x, t1, t2) = mix(F(t0, t1, t2), F(t1, t2, t3), invlerp(t0, t3, x));\nF(x, t2, t3) = mix(F(t1, t2, t3), F(t2, t3, t4), invlerp(t1, t4, x));\nF(x, t3, t4) = mix(F(t2, t3, t4), F(t3, t4, t5), invlerp(t2, t5, x));\n\n// Level 2, combine 3 to 2\n\nF(x, x, t2) = mix(F(x, t1, t2), F(x, t2, t3), invlerp(t1, t3, x));\nF(x, x, t3) = mix(F(x, t2, t3), F(x, t3, t4), invlerp(t2, t4, x));\n\n// last level, combine 2 to 1\n\nF(x, x, x) = mix(F(x, x, t2), F(x, x, t3), invlerp(t2, t3, x));\n\n*/\n\n\nvec2 blossom(\n    vec2 c0, vec2 c1, vec2 c2, vec2 c3,\n    float t0, float t1, float t2, float t3, float t4, float t5,\n    float x\n    )\n{\n    // Level 0\n    vec2 Ft0t1t2 = c0;\n    vec2 Ft1t2t3 = c1;\n    vec2 Ft2t3t4 = c2;\n    vec2 Ft3t4t5 = c3;\n    \n    // Level 1\n    vec2 Fxt1t2 = remix(t0, t3, x, Ft0t1t2, Ft1t2t3);\n    vec2 Fxt2t3 = remix(t1, t4, x, Ft1t2t3, Ft2t3t4);\n    vec2 Fxt3t4 = remix(t2, t5, x, Ft2t3t4, Ft3t4t5);\n    \n    // Level 2\n    vec2 Fxxt2 = remix(t1, t3, x, Fxt1t2, Fxt2t3);\n    vec2 Fxxt3 = remix(t2, t4, x, Fxt2t3, Fxt3t4);\n    \n    // Last Level\n    vec2 Fxxx = remix(t2, t3, x, Fxxt2, Fxxt3);\n    \n    return Fxxx;\n}\n\nvec2 get_control_point(int i)\n{\n    vec4 bufA = texelFetch(iChannel0, ivec2(i, 0), 0);\n    vec2 pos = bufA.xy;\n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float ps = 2. / iResolution.y;\n    \n    // background gradient\n    vec3 c0 = pow(vec3(0.3, 0.6, 0.9), vec3(3.));\n    vec3 c1 = pow(vec3(0.4, 0.3, 0.8), vec3(3.));\n    vec3 color =  mix(c0, c1, uv.y*.5+.5);\n    color = mix(color, vec3(dot(color, vec3(1./3.))), 0.5);\n\n    vec2 prev_pos = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    for(int i = 1; i < N; i++)\n    {\n        vec4 bufA = texelFetch(iChannel0, ivec2(i, 0), 0);\n        vec2 pos = bufA.xy;\n        color = mix(color, vec3(0), smoothstep(ps, -ps, seg(prev_pos, pos, uv)-r_seg));\n        \n        prev_pos = pos;\n    }\n    \n    for(int i = 0; i < N; i++)\n    {\n        vec4 bufA = texelFetch(iChannel0, ivec2(i, 0), 0);\n        vec2 pos = bufA.xy;\n        float drag = bufA.z;\n        \n        color = mix(color, vec3(0), smoothstep(ps, -ps, length(pos-uv)-r));\n        \n        const float ring_thickness = 0.005;\n        color = mix(color, vec3(1), drag * smoothstep(ps, -ps, abs(length(pos-uv)-r+ring_thickness*.5) - ring_thickness));\n        \n        prev_pos = pos;\n    }\n\n    vec2 \n            C0 = get_control_point(0),\n            C1 = get_control_point(1),\n            C2 = get_control_point(2),\n            C3 = get_control_point(3);\n    \n    vec2 p0 = blossom(\n                C0, C1, C2, C3,\n                -2., -1., 0., 1., 2., 3.,\n                0.\n            );\n            \n            \n    const int num_segs = (N)-3;\n            \n    for(int segment = 0; segment < num_segs; segment++)\n    {\n        C0 = get_control_point(segment+0),\n        C1 = get_control_point(segment+1),\n        C2 = get_control_point(segment+2),\n        C3 = get_control_point(segment+3);\n\n        float t = float(segment);\n        \n        vec3 seg_color = vec3(num_segs-1-segment, 0, segment)/float(num_segs);\n        \n        for(float x = 0.05; x < 1.; x += 0.05)\n        {\n            vec2 p1 = blossom(\n                C0, C1, C2, C3,\n                t-2., t-1., t+0., t+1., t+2., t+3.,\n                t+x\n            );\n            color = mix(color, seg_color, box(x) * smoothstep(ps, -ps, seg(p0, p1, uv)-0.01));\n            p0 = p1;\n        }\n    }\n\n    color *= 1.-0.125*length(uv);  //vignette\n\n    color = pow(color, vec3(1./2.2)); // srgb\n\n    {\n        uint golden_int = 0x9E3779B9u;\n        \n        vec2 p = floor(fragCoord);\n        float dither_r = fract(p.x / plastic + p.y / (plastic*plastic));\n        p += 2.;\n        float dither_g = fract(p.x / plastic + p.y / (plastic*plastic));\n        p += 2.;\n        float dither_b = fract(p.x / plastic + p.y / (plastic*plastic));\n        \n        vec3 dither = vec3(dither_r, dither_g, dither_b);\n        dither = fract(dither + fract(float(iFrame)/golden));\n        \n        color = color * 1. + (dither-.5)/255.;\n        \n        color = clamp(color, 0., 1.);\n    }\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float r = 0.05;\nconst float r_seg = r/3.;\n\nconst int N = 7;\n\nconst float golden = .5+.5*sqrt(5.);\nconst float plastic = 1.324717957244746025961;\nconst float PI = 3.14159265;\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nfloat invmix(float a, float b, float x) { return (x-a)/(b-a); }\n\nvec2 remix(float a0, float b0, float x, vec2 a1, vec2 b1)\n{\n    return mix(a1, b1, invmix(a0, b0, x));\n}\n\nfloat box(float x)\n{\n    return step(0., x) - step(1., x);\n}\n\nfloat rect(float a, float b, float x)\n{\n    return step(a, x) - step(b, x);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(int(fragCoord.x) > N) return;\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    \n    vec2 pos = vec2(cos(fragCoord.x), sin(fragCoord.x));\n    \n    float drag = 0.;\n    \n    vec4 bufA = vec4(pos, drag, 0);\n    if(iFrame > 0)\n    {\n        bufA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        pos = bufA.xy;\n        drag = bufA.z;\n    }\n    float mouse_down = step(0.5, iMouse.z);\n    \n    pos = mix(pos, mouse, drag);\n\n    if(length(mouse - pos) < r)\n    {\n        drag = 1.;\n    }\n    \n    drag *= mouse_down;\n    \n    bufA = vec4(pos, drag, 0);\n\n    fragColor = bufA;\n}","name":"Buffer A","description":"","type":"buffer"}]}