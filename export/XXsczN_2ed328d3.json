{"ver":"0.1","info":{"id":"XXsczN","date":"1726697550","viewed":84,"name":"electric field grong grong grong","username":"2CM","description":"iofjiwefoisdjfioajef hi","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["lkasjdflkas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nfloat arrow(vec2 uv) {\n    float lineWidth = 0.1;\n    \n    uv = rotate(uv, 1.57) + vec2(0.5); //i dont want to redo the arrow code so this works\n    \n    return (\n        (\n            abs(uv.y - uv.x - 0.5 - lineWidth * 0.5) < lineWidth * 0.5 &&\n            uv.x > 0.25 &&\n            uv.x < 0.5\n        ) ||\n        (\n        \n            abs(uv.y + uv.x - 1.5 - lineWidth * 0.5) < lineWidth * 0.5 &&\n            uv.x < 0.75 &&\n            uv.x > 0.5\n        ) ||\n        (\n            abs(uv.x - 0.5) < lineWidth * 0.5 &&\n            uv.y < 1.0 &&\n            uv.y > 0.0\n        )\n    ) ? 1.0 : 0.0;\n}\n\nfloat dash(vec2 uv) {\n    float lineWidth = 0.1;\n\n    return uv.x > 0.0 && uv.x < 1.0 && abs(uv.y - 0.5) < lineWidth * 0.5 ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(-1) + 2.0 * (fragCoord - vec2(0.5 * (iResolution.x - iResolution.y), 0))/iResolution.yy;\n    vec4 background = vec4(0);\n    \n    for(int i = 0; i < 3; i++) {\n        Point point = points[i];\n        \n        float d = distance(uv, point.pos);\n        vec4 color = vec4(point.charge >= 0.0 ? 1 : 0, 0, point.charge <= 0.0 ? 1 : 0, 1);\n    \n        if(d < 0.05) {        \n            fragColor = color + vec4(1,1,1,0) * (0.05 - d) / 0.1;\n\n            if(point.charge != 0.0) {\n                fragColor *= 1.0 - dash((uv - point.pos) / 0.05 + vec2(0.5));\n                \n                if(point.charge >= 0.0) {\n                    fragColor *= 1.0 - dash(rotate((uv - point.pos), 1.57) / 0.05 + vec2(0.5));\n                }\n            }\n\n            return;\n        }\n        \n        background += color * abs(point.charge / 6.0) / pow(d + 1.0, 2.0);\n    }\n    \n    if(distance(uv, texture(iChannel0, vec2(0)).xy) < 0.06) {\n        fragColor = vec4(1,0,0,1);\n        \n        return;\n    }\n    \n    float tileSize = 0.1;\n    vec2 cell = floor(uv / tileSize) * tileSize;\n    float value = 0.0;\n    \n    for(int x = -1; x <= 1; x++) {\n        for(int y = -1; y <= 1; y++) {\n            vec2 thisCell = cell + tileSize * vec2(x,y);\n            //vec2 thisCell = (cell + tileSize * (vec2(x,y) + mod(vec2(cos(iTime), sin(iTime)), 1.0)));\n            //vec2 thisCell = (cell + tileSize * vec2(x,y));\n            //thisCell.y += mod((floor(mod(thisCell.x / tileSize, 2.0)) * 2.0 - 1.0) * iTime, 1.0) * tileSize;\n            vec2 cellOffset = uv - thisCell;\n            vec2 forceVector = force(thisCell);\n            float dir = atan2(forceVector);\n            float mag = min(length(forceVector), 64.0);\n        \n            value += 0.5 * arrow(5.0 * rotate(cellOffset / tileSize, -dir) / (1.0 + 0.5 * sqrt(mag)));\n        }\n    }\n    \n    /*\n    float step = 0.01;\n    float divergence = (\n        (force(uv - vec2(step, 0)).x - force(uv + vec2(step, 0)).x) / (2.0 * step) +\n        (force(uv - vec2(0, step)).y - force(uv + vec2(0, step)).y) / (2.0 * step)\n    );\n    */\n    \n    /*\n    vec2 currentPos = uv;\n    \n    for(int i = 0; i < 100; i++) {\n        currentPos += min(force(currentPos.xy) * iTimeDelta, 200000000.0) * 0.01;\n    }\n    \n    int closestPointIndex = 0;\n    \n    for(int i = 0; i < 3; i++) {\n        if(distance(currentPos, points[i].pos) < distance(currentPos, points[closestPointIndex].pos)) {\n            closestPointIndex = i;\n        }\n    }\n    \n    //vec4 fractalColor = vec4(hsl2rgb(vec3(float(closestPointIndex) * 294.521, 0.5, 0.5)));\n    vec4 fractalColor = vec4(0,0.5 + 0.5 * sin(float(closestPointIndex) * 952.683),0,0);\n    */\n    \n    fragColor = vec4(1.0 - value) + background;//+ fractalColor;// + vec4(0,abs(divergence) * 1.0, 0,0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0) {\n        fragColor = vec4(10000);\n        \n        return;\n    }\n\n    if(fragCoord.x <= 1.0 && fragCoord.y <= 1.0) {\n        if(iMouse.z > 0.5) {\n            fragColor.xy = vec2(-1) + 2.0 * (iMouse.xy - vec2(0.5 * (iResolution.x - iResolution.y), 0))/iResolution.yy;\n            \n            return;\n        }\n    \n        fragColor = texture(iChannel0, vec2(0,0));\n        fragColor.xy += min(force(fragColor.xy) * iTimeDelta, 200000000.0) * 0.01;\n    \n        return;\n    }\n\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec3 hsl2rgb( vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nstruct Point {\n    vec2 pos;\n    float charge;\n};\n\nPoint[] points = Point[3] (\n    Point(vec2(0.00,  0.71), -6.0),\n    Point(vec2(0.41,  0.31),  6.0),\n    Point(vec2(0.21, -0.21), -2.0)\n);\n\nvec2 efe(Point point, vec2 pos) {\n    return normalize(point.pos - pos) * point.charge / max(pow(distance(point.pos, pos), 2.0), 0.005);\n}\n\nvec2 force(vec2 pos) {\n    vec2 sum = vec2(0);\n    \n    for(int i = 0; i < 3; i++) {\n        sum -= efe(points[i], pos);\n    }\n    \n    return sum;\n}\n\nfloat atan2(vec2 vec) {\n    bool s = (abs(vec.x) > abs(vec.y));\n    return mix(1.57 - atan(vec.x,vec.y), atan(vec.y,vec.x), s);\n}","name":"Common","description":"","type":"common"}]}