{"ver":"0.1","info":{"id":"cdXyWl","date":"1687286715","viewed":28,"name":"Prime Polar Points","username":"gorplex","description":"Prime Polar Plot","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["polar","points","prime"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PRIME_SEARCH 40\n\n// Credit: IQ https://www.shadertoy.com/view/4slGRH\n// see also https://www.shadertoy.com/view/4ljyRK\nbool isPrime( int x )\n{\n\tif( x==1 ) return false;\n\tif( x==2 ) return true;\n\tif( x==3 ) return true;\n\tif( x==5 ) return true;\n\tif( x==7 ) return true;\n\tif( (x&1)==0 ) return false;\n\tif( (x%3)==0 ) return false;\n\tif( (x%5)==0 ) return false;\n\n    int xm = 1 + int(sqrt(float(x)));\n    \n\tint y = 7;\n\tfor( int i=0; i<200; i++ ) // count up to 6000\n\t{\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm    ) return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t}\n\t\n\treturn true;\n}\n\nint oddFloor(float x) {\n    return int(floor(x/2.)*2.-1.);\n}\n\nint getNearestPrimeDown(float r) {\n    if (r<2.) return 0;\n    for(int i = oddFloor(r); i>oddFloor(r)-PRIME_SEARCH; i-=2) {\n        if(isPrime(i)) return i;\n    }\n    return 0;\n}\n\nint getNearestPrimeUp(float r) {\n    if (r<2.) return 2;\n    for(int i = oddFloor(r); i<oddFloor(r)+PRIME_SEARCH; i+=2) {\n        if(isPrime(i)) return i;\n    }\n    return 0;\n}\n\nvec2 getPrimeXY(int prime, float scaleFactor) {\n    return scaleFactor*vec2(float(prime)*cos(float(prime)),\n    float(prime)*sin(float(prime)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord-iResolution.xy/2.;\n    vec3 col = vec3(0.,0.,0.);\n        \n    float scaleFactor = 4.*(1.+cos(iTime*6.28/20.));\n    //float scaleFactor = .5+iTime/10.;\n    \n\n    \n    \n    //float r = length(uv)*1.;\n    uv*=scaleFactor;\n    float r = length(uv)*1.;\n    int prime = getNearestPrimeDown(r);\n    if(prime != 0) {\n        vec2 primePoint = getPrimeXY(prime, 1.);\n        col += vec3(0.,.7,.7) * smoothstep(15.*scaleFactor, 0., length(uv-primePoint));\n        //col += vec3(0.,.3,.3) * smoothstep(0.1, 0., r-float(prime));\n    }\n    prime = getNearestPrimeUp(r);\n    if(prime != 0) {\n        vec2 primePoint = getPrimeXY(prime, scaleFactor);\n        col += vec3(0.,.7,.7) * smoothstep(15.*scaleFactor, 0., length(uv-primePoint));\n        //col += vec3(0.,.3,.3) * smoothstep(0.1, 0., r-float(prime));\n    }\n    \n    \n    \n    \n\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}