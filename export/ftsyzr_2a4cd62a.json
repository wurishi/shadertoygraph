{"ver":"0.1","info":{"id":"ftsyzr","date":"1647450941","viewed":72,"name":"HyperbolicCalculator","username":"stevejtrettel","description":"Computations in the hyperbolic plane","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["hyperbolicgeometry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//------------------------------------------\n//Useful Constants\n//------------------------------------------\n\nfloat PI = 3.14159;\nfloat sqrt2 = sqrt(2.);\nfloat sqrt3 = sqrt(3.);\nvec2 I = vec2(0.,1.);   \n\n//floating point infinity:\n//the funciton isinf() tests if a value is infinite, returning a boolean\nfloat infty = 1./0.;\n\nfloat P = 4.;\nfloat Q = 4.;\nfloat R = 4.;\n\n\n//------------------------------------------\n//Useful Colors\n//------------------------------------------\n\nvec3 lightBlue = vec3(170,210,255)/255.;\nvec3 medBlue = vec3(120, 170, 250)/255.;\nvec3 darkBlue = vec3(110, 155, 240)/255.;\n\nvec3 lightPurple = vec3(170,210,255)/255. + vec3(0.2,0,0);\nvec3 medPurple = vec3(120, 170, 250)/255. + vec3(0.3,0,0);\nvec3 darkPurple = vec3(110, 155, 240)/255. + vec3(0.3,0,0);\n\nvec3 lightGreen = vec3(149, 245, 181)/255.;\n\nvec3 pink = vec3(255, 117, 133)/255.;\n\n\n//----------------------------------------------\n//------------------------------------------\n//SETUP\n//------------------------------------------\n//----------------------------------------------\n\n//this takes in the pixel coordinates on the screen (fragCoord) and rescales\n//them to show the appropriate region of the plane\nvec2 normalizeCoords( vec2 fragCoord ){\n\n    // Normalized the pixel coordinates from 0 to 1\n    //fragCoord is a vector of integers, giving the pixel on the screen\n    //its (0,0) in the top left, increasing down and to the right.\n    //iResolution is a uniform giving the total number of pixels across x,y\n    //the bottom right corner of the screen has pixel coordinates (iResolution.x, iResolution.y)\n    \n    \n    //dividing fragCoord by iResolution results in coordinates running from (0,0) to (1,1)\n    vec2 uv =fragCoord/iResolution.xy;\n    \n    //translate so coordinates run (-0.5, 0.5)\n    uv = uv - vec2(0.5);\n\n    //preserve original aspect ratio\n    float aspect = iResolution.y/iResolution.x;\n    uv = vec2(1,aspect)*uv;\n    \n    //rescale however you like \n    uv = 4.*uv;\n\n    return uv;\n}\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//COMPLEX NUMBERS\n//------------------------------------------\n//----------------------------------------------\n\n//points in the hyperbolic plane are represented by vec2(x,y)\n//these can be added, subtracted and scalar multiplied by built-in operations\n//these can be multiplied and inverted (as complex numbers) using the following\n\n\n//turn a real number into a complex number\nvec2 toC( float x ){\n    return vec2(x,0);\n    }\n    \n    \n\n//complex multiplication\nvec2 mult( vec2 z, vec2 w )\n{\n   float re = z.x*w.x - z.y*w.y;\n   float im = z.x*w.y + z.y*w.x;\n\n   vec2 res = vec2(re, im);\n   return res;\n}\n\n\n//complex conjugation, negates imaginary party\nvec2 conj( vec2 z )\n{\n    vec2 res = vec2(z.x,-z.y);\n    return res;\n}\n\n\n//inverse of the complex number z\nvec2 invert( vec2 z )\n{\n    float mag2 = dot(z,z);\n    vec2 res = conj(z)/mag2;\n    return res;\n}\n\n\n//compute the quotient z/w\nvec2 divide( vec2 z, vec2 w )\n{\n   return mult(z,invert(w));\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//CONVERSIONS BETWEEN MODELS\n//------------------------------------------\n//----------------------------------------------\n\n\n//------------------------------------------\n//Poincare Disk Model\n//------------------------------------------\n\n\n//check if you are inside the unit disk or not\nbool insidePD( vec2 z )\n{\n    //returns true if the inequality is satisfied, falso otherwise\n    return dot(z,z)<1.;\n}\n\n\n\n//apply the mobius transformation taking a point to UHP\n//this is the map z -> (iz+1)/(z+i)\nvec2 toUH( vec2 z ){\n\n    vec2 num = z+I;\n    vec2 denom = mult(I,z)+toC(1.);\n    vec2 res = divide(num,denom);\n    return res; \n}\n\n\n//uses mouse position to make a mobius transformation\nvec2 mouseTransform(vec2 z){\n    if (iMouse.z>0.) {\n        vec2 m = normalizeCoords(iMouse.xy);\n        // Unit disc inversion\n        m /= dot(m,m);\n        z -= m;\n        float k = (dot(m,m)-1.0)/dot(z,z);\n        z *= k;\n        z += m;\n    }\n    return z;\n}\n\n\n\n\n\n\n\n\n//------------------------------------------\n//Upper Half Plane Model\n//------------------------------------------\n\n//check if you are in the upper half plane or not\nbool insideHP( vec2 z )\n{\n    //returns true if the inequality is satisfied, falso otherwise\n    return z.y>0.;\n}\n\n\n//take a point in the upper half plane and map it to the disk\n//this is the transformation z -> (z-i)/(z+i)\nvec2 toPD(vec2 z){\n    vec2 num = z-I;\n    vec2 denom = z+I;\n    vec2 res = divide(num,denom);\n    return res;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//HYPERBOLIC GEOMETRY (in the upper half plane)\n//------------------------------------------\n//----------------------------------------------\n\n\n\n//------------------------------------------\n//Isometries\n//------------------------------------------\n\n//this is a general mobius transformation applied to points in upper half space\n//do the mobius transformation ((a,b),(c,d)).z\nvec2 applyMobius(vec4 mob, vec2 z){\n    float a=mob.x;\n    float b=mob.y;\n    float c=mob.z;\n    float d=mob.w;\n    \n    vec2 num = a*z+toC(b);\n    vec2 denom = c*z + toC(d);\n    \n    vec2 res = divide(num,denom);\n    \n    return res;\n    \n}\n\n\n\n\n//------------------------------------------\n//Points\n//------------------------------------------\n// a point is just a vec2, thought of as a complex number;\n//no special structure here\n\n\n//measure the distance to a point\nfloat dist(vec2 z, vec2 p){\n\n    //just directly using distance function in UH\n     vec2 rel = z-p;\n     float num = dot(rel,rel);\n     float denom = 2.*z.y*p.y;\n     return acosh(1.+num/denom);\n\n}\n\n\n\n//------------------------------------------\n//Circles\n//------------------------------------------\n//a circle has a point for its center, and a float for radius\n\nstruct Circle{\n    vec2 center;\n    float radius;\n};\n\n\nfloat dist(vec2 z, Circle circ){\n    //measure distance from center\n    float d = dist(z,circ.center);\n    //subtract circles radius\n    return abs(d-circ.radius);\n}\n\n\n\nbool inside(vec2 z, Circle circ){\n    //if distance from z to center is less than radius, we're inside\n    return dist(z,circ.center)<circ.radius;\n}\n\n\n\n\n\n\n\n//------------------------------------------\n//Horocycles\n//------------------------------------------\n\n\n//a horocycle is given by its ideal point,\n//and an offset: how far the horocycle is from passing through i\nstruct Horocycle {\n    float ideal;\n    float offset;\n};\n\n\nfloat dist(vec2 z, Horocycle horo){\n    \n    //if the horocycle is based at infinity:\n    if(isinf(horo.ideal)){\n        //move by the offset\n        z /= exp(horo.offset);\n        //measure distance from y=1:\n        return abs(z.y-1.);\n    }\n    \n    \n    //otherwise, compute by conjugating:\n    else{\n    \n        //find mobius transformation fixing i, taking ideal pt to infinty:\n        float d = sqrt(horo.ideal*horo.ideal+1.);\n        float c = horo.ideal/d;\n        float s = -1./d;\n        vec4 mob = vec4(c,-s,s,c);\n        \n        //apply this mobius transformation to z:\n        z = applyMobius(mob, z);\n        \n    \n        //now do the computation from above:\n        //move by the offset\n        z /= exp(horo.offset);\n        //measure distance from y=1:\n        return abs(z.y-1.);\n    }\n}\n\nbool inside(vec2 z, Horocycle horo){\n\n //if the horocycle is based at infinity:\n    if(isinf(horo.ideal)){\n        //move by the offset\n        z /= exp(horo.offset);\n        //true if above y=1;\n        return z.y>1.;\n    }\n    \n    \n    //otherwise, compute by conjugating:\n    else{\n    \n        //find mobius transformation fixing i, taking ideal pt to infinty:\n        float d = sqrt(horo.ideal*horo.ideal+1.);\n        float c = horo.ideal/d;\n        float s = -1./d;\n        vec4 mob = vec4(c,-s,s,c);\n        \n        //apply this mobius transformation to z:\n        z = applyMobius(mob, z);\n        \n    \n        //now do the computation from above:\n        //move by the offset\n        z /= exp(horo.offset);\n        //true if above y=1.;\n        return z.y>1.;\n    }\n    \n}\n\n\n\n\n\n\n\n//------------------------------------------\n//Geodesics\n//------------------------------------------\n\n\n//a geodesic is encoded by remembering its two boundary points\n//these are real numbers (or the constant infty)\nstruct Geodesic{\n//first endpoint\n    float p;\n//second endpoint \n    float q;\n};\n\n\n\n//check if a geodesic is a line\nbool isLine( Geodesic geo ) {\n    return isinf(geo.p)||isinf(geo.q);\n}\n\n\n\n\n//check if a geodesic is a line, and return its endpoint\nbool isLine( Geodesic geo, out float endpt ) {\n\n//if p is infinity, q is the real endpoint\n    if(isinf(geo.p)){\n        endpt = geo.q;\n        return true;\n        }\n        \n//if q is infinity, p is the real endpoint\n    else if ( isinf(geo.q) ){\n        endpt = geo.p;\n        return true;\n    }\n    \n    //if neither is infinity, its not a line\n    return false;\n}\n\n\n\n\n\n//reflect in the geodesic geo\nvec2 reflectIn(vec2 z, Geodesic geo){\n\n    float endpt;\n    \n    //if its a line, do one thing\n    if(isLine(geo,endpt)){\n        z.x -= endpt;\n        z.x *= -1.;\n        z.x += endpt;\n        return z;\n    }\n    \n    //else, if its a circle do something else\n    else{\n        float center = (geo.p+geo.q)/2.;\n        float radius = abs((geo.p-geo.q))/2.;\n        \n        z.x -= center;\n        z /= radius;\n        z /= dot(z,z);\n        z *= radius;\n        z.x += center;\n        \n        return z;\n    }\n}\n\n\n\n\n\n//measure the distance to a geodesic\nfloat dist(vec2 z, Geodesic geo){\n\n    float endpt;\n    \n    //if its a vertical line\n    if(isLine(geo,endpt)){\n        //translate to the origin\n        z.x-=endpt;\n        //measure distance as angle\n        float secTheta=length(z)/abs(z.y);\n        return acosh(secTheta);\n    }\n    \n    //otherwise, its a circle\n    else{\n   \n        //build mobius transformation taking geo to (0,infty)\n        vec4 mob=vec4(1.,-geo.p,1.,-geo.q);\n        z = applyMobius(mob, z);\n\n        //now measure the distance to this vertical line\n        //measure distance as angle\n        float secTheta=length(z)/abs(z.y);\n        return acosh(secTheta);\n    }\n}\n\n\n\n\n\n\n\n\n//------------------------------------------\n//Half Spaces\n//------------------------------------------\n\n\n//a half space is bounded by a geodesic,\n//and is all the area on one side of it\n    //side is + if it contains a portion of the real line (bounded area in model)\n    //side is - if it contains infinity\nstruct HalfSpace{\n    Geodesic bdy;\n    float side;\n};\n\n\n\n//inside checks if you are in a half space or not:\nbool inside(vec2 z, HalfSpace hs){\n\n     float endpt;\n\n    //if the half space is bounded by a line:\n    if( isLine( hs.bdy, endpt ) ){\n    \n        //is point to the right (+) or left (-) of the boundary?\n        float side = sign(z.x - endpt);\n        \n        //check if this is inside (+) or outside (-) the halfspace\n        return side*hs.side>0.;\n    }\n    \n    //otherwise, the half space is bounded by a circle\n    //endpoint was never assigned so dont use it\n    else{\n    \n        float center = (hs.bdy.p+hs.bdy.q)/2.;\n        float radius = abs((hs.bdy.p-hs.bdy.q))/2.;\n        \n        //get relative position\n        vec2 rel = z-toC(center);\n        //get radius\n        float dist2 = dot(rel,rel);\n        \n        //get inside (-) or outside (+) circle\n        float side = sign(dist2-radius*radius);\n        \n        //return true (+) if in half space, false if not\n        return side*hs.side>0.;\n    }\n}\n\n\n\n//reflect into a half space:\n//if you are inside already, do nothing\n//if you are outside, reflect in the boundary\nvec2 reflectIn( vec2 z, HalfSpace hs) {\n    if(!inside(z,hs)){\n        vec2 res = reflectIn(z,hs.bdy);\n        return res;\n        }\n        \n        return z;\n}\n\n\n\n\n//------------------------------------------\n//Triangles\n//------------------------------------------\n\n\n\n//a triangle is the intersection of three half spaces\n//we will call these a, b, and c\nstruct Triangle{\n    HalfSpace a;\n    HalfSpace b;\n    HalfSpace c;\n};\n\n\n\n\nbool inside(vec2 z, Triangle T){\n    //check if you are inside all three half-spaces\n    return inside(z,T.a)&&inside(z,T.b)&&inside(z,T.c);\n}\n\n\n\n\n\n\n\n\n\n\n\n//----------------------------------------------\n//------------------------------------------\n//PRODUCING THE IMAGE\n//------------------------------------------\n//----------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n\n    //setting up a geodesic triangle:\n\n    //vertical geodesic\n    Geodesic side1 = Geodesic(0.,infty);\n    HalfSpace h1 = HalfSpace(side1,1.);\n\n    //side making angle Pi/Q with the vertical, intersecting at i\n    float ang = tan(PI/(2.*Q));\n    Geodesic side2 = Geodesic(-ang,1./ang);\n    HalfSpace h2 = HalfSpace(side2, 1.);\n\n\n    //side making angle PI/R with vertical, intersecting at e^a*i\n    float num  = cos(PI/P) + cos(PI/Q) * cos(PI/R);\n    float denom = sin(PI/Q) * sin(PI/R);\n    //cosha is from the hyperbolic law of cosines\n    float cosha = num/denom;\n\n    //since acosh(z)=log(z+sqrt(z^2-1)), the following is exp(a)= exp(acosh(cosh(a))\n    float x = cosha + sqrt(cosha*cosha-1.);\n\n    //angle here is tanPi/r\n    ang = tan(PI/(2.*R));\n    Geodesic side3 = Geodesic(-x/ang,x*ang);\n    HalfSpace h3 = HalfSpace(side3, -1.);\n\n\n     \n     Triangle T = Triangle(h1,h2,h3);\n \n \n    \n    \n    \n    //the vector that will store our final color:\n    vec3 color=vec3(0);\n    \n    \n    // Normalized pixel coordinates\n    vec2 z = normalizeCoords( fragCoord );\n    \n    //check if insidePD\n    if(insidePD(z)){\n \n       //set background color of the disk\n       color = darkBlue;\n        \n       //move to upper half plane for computations\n       z = mouseTransform(z);\n       z = toUH(z);\n        \n       //color the triangle blue\n        if(inside(z,T)){\n            color=pink;\n        }\n        \n\n\n\n        //example below of how to draw hyperplanes specified\n        //as a word in the reflection group\n       \n        \n        \n        //draw a nbhd of hyperplane 1\n        if(dist(z,side1)<0.03){\n            color=lightGreen;\n        }\n        \n        //draw a nbhd of hyperplane 2\n        if(dist(z,side2)<0.03){\n            color=lightGreen;\n        }\n        \n         //draw a nbhd of hyperplane 3\n        if(dist(z,side3)<0.03){\n            color=lightGreen;\n        }\n        \n        \n        //draw a nbhd of hyperplane 232\n        vec2 w = reflectIn(z,side2);\n        if(dist(w,side3)<0.03){\n            color=lightGreen;\n            }\n        //draw a nbhd of hyperplane 23232\n        w = reflectIn(w,side3);\n        if(dist(w,side2)<0.03){\n            color=lightGreen;\n            }\n        //draw a nbhd of hyperplane 2323232    \n         w = reflectIn(w,side2);\n        if(dist(w,side3)<0.03){\n            color=lightGreen;\n            }\n        \n       \n       \n       \n        vec2 u = reflectIn(z,side3);\n        if(dist(u,side2)<0.03){\n            color=lightGreen;\n            }\n        \n        u = reflectIn(u,side2);\n        if(dist(u,side3)<0.03){\n            color=lightGreen;\n            }\n        \n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n        \n                \n\n\n        \n        \n        \n\n        \n                \n\n       \n\n       \n\n}\n    \n   fragColor=vec4(color,1);\n}","name":"Image","description":"","type":"image"}]}