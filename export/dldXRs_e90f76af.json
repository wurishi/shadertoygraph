{"ver":"0.1","info":{"id":"dldXRs","date":"1685730498","viewed":108,"name":"nto Pixel Shader","username":"NTO256","description":"A simple pixel +outline shader made from scratch, parts of this might prove useful when making a pixel art game utilizing a 3d -> 2d pipeline, iirc dead cells does something like that\n\nParameters are at the top of the shade codes.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pixel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// this adds the outline\n\n// outline parameters\n#define OUTLINE_THICKNESS 10\n#define OUTLINE_COLOR vec3(0, 0, 1)\n\n\n// outline function\nfloat outlineIntensity(float x) { // 0 <= x <= 1\n    return x;\n}\n\nbool isPixel(vec2 point) {\n    return point.x>=0.f && point.x<iResolution.x && point.y>0.f && point.y<iResolution.y;\n}\n\nbool isEmpty(vec4 color) {\n    return color.a == 0.f;\n}\n\nvec4 colorAt(vec2 point) {\n    return texture(iChannel0, point.xy/iResolution.xy);\n}\n\nfloat txDist(vec2 point) {\n    int edge_sz = OUTLINE_THICKNESS * 2 + 1;\n    vec2 p = point - vec2(OUTLINE_THICKNESS);\n    float min_dist = float(OUTLINE_THICKNESS + 1);\n    \n    for (int x = 0;x<edge_sz;x++) {\n        for (int y=0;y<edge_sz;y++) {\n            vec2 current_point = p + vec2(x, y);\n            if (!isPixel(current_point) || isEmpty(colorAt(current_point))) {\n                continue;\n            }\n            \n            \n            // Check if pixel distance is in circle and smallest\n            float p_dist = distance(point, current_point);\n            if (p_dist < min_dist) {\n                min_dist = p_dist;\n            }\n        }\n    }\n    \n    if (min_dist > float(OUTLINE_THICKNESS)) {\n        return -1.f;\n    }\n    return min_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec4 color = colorAt(fragCoord);\n    \n    if (isEmpty(color)) {\n        // Point is \"empty\", so we calculate the min distance to the next visible pixel\n        color = vec4(0);\n        float m_dist = txDist(fragCoord);\n        if (m_dist != -1.f) {\n            color = vec4(OUTLINE_COLOR, 1)*outlineIntensity((float(OUTLINE_THICKNESS)-m_dist)/float(OUTLINE_THICKNESS));\n        }\n    } else {\n        // Uncomment if you want to fill a specific color instead\n        //color = vec4(1);\n    }\n    \n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// buffer removes background\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    \n    float green_ratio = color.y / (color.x + color.y + color.z);\n    \n    if (green_ratio > 0.5f) {\n        color = vec4(0, 0, 0, 0);\n    }\n    \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// buffer pixelates image\n\n// define size of pixels\n#define PX_SZ_X (8)\n#define PX_SZ_Y (8)\n\nivec2 n_pixels;\n\nvec4 colorAt(vec2 position) {\n    return texture(iChannel0, position/iResolution.xy);\n}\n\nvec2 getPixelTopLeft(ivec2 pixelPosition) {\n    vec2 position;\n    \n    position.x = float(pixelPosition.x) * float(PX_SZ_X);\n    position.y = float(pixelPosition.y) * float(PX_SZ_Y);\n    \n    return position;\n}\n\nvec4 getPixelColor(ivec2 pixelPosition) {\n    vec4 color = vec4(0);\n    vec2 topLeftPosition = getPixelTopLeft(pixelPosition);\n    int nPx = PX_SZ_X * PX_SZ_Y;\n    \n    for (int x = 0;x<PX_SZ_X;x++) {\n        for (int y = 0;y<PX_SZ_Y;y++) {\n            color += colorAt(topLeftPosition+vec2(x, y));\n        }\n    }\n    \n    color /= float(nPx);\n    if (color.a != 0.f) {\n        color.a = 1.0f;\n    }\n    \n    return color;\n}\n\nivec2 translatePixelCoords(vec2 position) {\n    ivec2 pixelPosition;\n    \n    pixelPosition.x = int(position.x/float(PX_SZ_X));\n    pixelPosition.y = int(position.y/float(PX_SZ_Y));\n    \n    return pixelPosition;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    n_pixels.x = int(iResolution.x / float(PX_SZ_X));\n    n_pixels.y = int(iResolution.y / float(PX_SZ_Y));\n\n    vec4 color = getPixelColor(translatePixelCoords(fragCoord.xy));\n\n    fragColor = color;\n}","name":"Buffer B","description":"","type":"buffer"}]}