{"ver":"0.1","info":{"id":"cdtyzN","date":"1696094468","viewed":50,"name":"Alternative parabola SDF","username":"Mermersk","description":"See comment, help needed (: Broken when parabola is narrow.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","parabola","alt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nI wanted to see if I could make a valid SDF to a parabola by not using the quadratic equation explicitly, but instead its focus and directrix. \nIts not quite correct distance field though ): It gets more incorrect as the parabola gets narrower, it seems that the distance higher up the\ny-axis is \"smaller\" than down below and therefore its not correct.\n\nI thought I could correct it by scaling the distance with the dot product of the derivative/tangent vector and the unit vector (0, 1).\nIt seems to make it slightly better, but doesnt really fix it. Anybody have insight into how to fix it? Even just getting only the outer distance\ncorrect would be nice.\n\nThought also about doing this:\nscale = (scale + 1.0) + (point.y * 0.25);\nIf the distance gets smaller and smaller higher up the parabola when its narrow than maybe try to use the y-coordinates to \"scale\" the distance field?\nThis does seem to work for pixels close to the parabola line, but produces a weird distance field elsewhere. But it is better if I would just want\nto draw a line along the parabola with even thickness everywhere.\n*/\nvec3 signedDistanceToParabolaDEB(vec3 col, vec2 point, float focus, float directrix) {\n    \n    point.y -= 3.0;\n    vec2 focusPos = vec2(0.0, focus);\n    \n    vec2 focusUV = point - focusPos;\n    // Calculate the distance to the focus.\n    float distanceToFocus = length(focusUV);\n\n    // Calculate the distance to the directrix.\n    float distanceToDirectrix = point.y + directrix;\n    vec2 directrixPos = vec2(0.0, distanceToDirectrix);\n    \n    float d = distanceToFocus - distanceToDirectrix;\n    \n    //vec2 normal = vec2(dFdx(d), dFdy(d));\n    \n    //vec2 normal2 = focusUV - directrixPos;\n    \n    //vec2 vertexPos = vec2(focusPos.x, focusPos.y + abs(focusPos.y - directrixPos.y));\n    \n    //float a = 1.0/(4.0*abs(focusPos.y - vertexPos.y));\n    \n    float k = dot(vec2(0.0, 1.0), normalize(focusUV));\n    //Growth rate along x and y components = The tangent vector I think? Or at least the derivative is in gr.y? But this derivative is never negative.\n    vec2 gr = vec2(1.0-(0.5+(k*0.5)), 0.5+(k*0.5));\n    \n    float scale = dot(vec2(0.0, 1.0), gr);\n    //+ 1.0 so that when vec2(0.0, 1.0) and gr are perpendicular then there is no scaling going on\n    scale = (scale + 1.0); //+ (point.y * 0.25);\n    d = d * scale;\n    \n    //Draw distance field\n    //col += mod(abs(d), 1.0) < 0.5 ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);\n    \n    //d = smoothstep(0.0, 0.2, abs(d));\n    \n    //Draw focus ball\n    float dBall = smoothstep(0.0, 0.01, length(point - vec2(0.0, focus))-0.15);\n    //d = min(d, dBall);\n    \n    //draw directrix\n    float dDirectrix = smoothstep(0.0, 0.1, abs(point.y - directrix));\n    //d = min(d, dDirectrix);\n    \n    \n    // Distance field coloring from IQ\n    col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-0.5*abs(d));\n\tcol *= 0.7 + 0.2*cos(7.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.35,abs(d)) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = (uv*2.0);\n    \n    uv.x = uv.x - 1.0;\n    \n    float ar = iResolution.x / iResolution.y;\n    uv.x = uv.x * ar;\n    \n    uv *= 10.0;\n    \n    vec3 col = vec3(0.0);\n    \n    col = signedDistanceToParabolaDEB(col, uv, abs(sin(iTime*0.66))*10.0, 0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}