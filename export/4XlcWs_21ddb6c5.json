{"ver":"0.1","info":{"id":"4XlcWs","date":"1726876189","viewed":18,"name":"FS RectSelection Test","username":"GabrieleGiuseppini","description":"Experiments for the rectangular selection marker in Floating Sandbox.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["floatingsandbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 linearstep(vec2 lEdge, vec2 rEdge, vec2 x)\n{\n    return clamp((x-lEdge)/(rEdge - lEdge), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make small rect [-1,1]\n    uv = (uv - vec2(0.5)) * 2.0;\n    \n    // Make into -1->1 space *in [-0.5, 0.5] rect*\n    vec2 vertexSpacePosition = uv * 2.0; // [-2.0, 2.0]\n    \n    // Calc pixel size\n    vec2 pixelSizeInVertexSpace = vec2(4.0) / iResolution.xy;\n\n    // Calc border size\n    #define BorderWidthPixels 30.0\n    vec2 borderSizeInVertexSpace = pixelSizeInVertexSpace * BorderWidthPixels;\n\n    vec3 color = vec3(0.880, 0.0704, 0.0704);\n    \n    float elapsed = iTime;\n    \n    ///////////////////////////////////////////\n    \n    vec2 halfBorderSizeInVertexSpace = borderSizeInVertexSpace / 2.0;\n    \n    #define AntiaAliasWidthPixels 2.0\n    vec2 antiAliasWidthVertexSpace = pixelSizeInVertexSpace * AntiaAliasWidthPixels;\n    \n    // Aspect ratio\n    float ar = pixelSizeInVertexSpace.x / pixelSizeInVertexSpace.y;\n    \n    //\n    // Anti-aliasing\n    //        \n    \n    // 1.0 @ |1.0|-b  ->  0.0 @ |1.0|\n    vec2 leftRampAlpha = vec2(1.0) - linearstep(\n        vec2(1.0) - antiAliasWidthVertexSpace, \n        vec2(1.0), \n        abs(vertexSpacePosition));\n    float exteriorAlpha = leftRampAlpha.x * leftRampAlpha.y;\n    // 0.0 @ |1.0|-B  ->  1.0 @ |1.0|-B+b\n    vec2 rightRampAlpha = linearstep(\n        vec2(1.0) - borderSizeInVertexSpace, \n        vec2(1.0) - borderSizeInVertexSpace + antiAliasWidthVertexSpace, \n        abs(vertexSpacePosition));\n    float interiorAlpha = min(rightRampAlpha.x + rightRampAlpha.y, 1.);\n    \n    //\n    // On-center-border lightening, pulsing with time\n    //\n    \n    #define Speed 1.5\n    #define Period 2.0\n    #define DelayPeriods 2.0    \n    float elapsed2 = elapsed * Speed;\n    float timeDepth = \n        step(DelayPeriods * Period, elapsed2)\n        * mod(elapsed2, Period) / Period;\n        \n    // Offset changes from a bit outside the border to a bit inside the border\n    vec2 offset = 1.7 * borderSizeInVertexSpace * (0.5 - timeDepth);\n    \n    vec2 lightening = vec2(1.0) - linearstep( // ls is 0.0 at center of border\n        vec2(0.0),\n        halfBorderSizeInVertexSpace,\n        abs(abs(vertexSpacePosition) + offset - (vec2(1.) - halfBorderSizeInVertexSpace)));\n            \n    // Don't let lightening cross ugly when combining into scalar;\n    // choose x when y > x\n    float xWins = step(\n        (1.0 - abs(vertexSpacePosition.x)),\n        (1.0 - abs(vertexSpacePosition.y)) * ar);    \n    float lighteningScalar = \n        xWins * lightening.x\n        + (1. - xWins) * lightening.y;\n        \n    // Damp down a bit\n    lighteningScalar *= 0.8;\n\n    // Focus\n    lighteningScalar *= lighteningScalar;\n    \n    //\n    // Put it all together\n    //\n    \n    vec4 c = vec4(\n        color + vec3(lighteningScalar),\n        exteriorAlpha * interiorAlpha);\n            \n    //////////////////////////////////////////\n\n    // Simulate vertex shader\n    if (uv.x < -0.5 || uv.x > 0.5 || uv.y < -0.5 || uv.y > 0.5)\n    {\n        c.a = 0.0;\n    }\n\n    // Output to screen\n    fragColor = vec4(\n        mix(\n            vec3(1.),\n            c.rgb,            \n            c.a),\n        1.0);\n}","name":"Image","description":"","type":"image"}]}