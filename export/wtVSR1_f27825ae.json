{"ver":"0.1","info":{"id":"wtVSR1","date":"1584686755","viewed":82,"name":"Naive Disk Sampling Pattern","username":"iradicator","description":"Naive approach to construct a normalized uniform disk sampling pattern.\n(this is incorrect pattern)\n\nFor more details, check out my blog post: https://iradicator.com/normalized-uniform-disk-pattern/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","sampling","pattern","disk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_FLT 3.402823e+38\n#define EPSILON 1.192093e-07\n\n//////////////\n// Controls //\n//////////////\n\nint L = 6;\nint S = 8;\n\n////////////////////\n// Naive Approach //\n////////////////////\n\nint N(int L, int S)\n{\n    return L*S;\n}\n\nvec2 disk(int i, int L, int S)\n{\n    float r = float(i / S) / max(EPSILON, float(L-1));   \n\tfloat theta = 2.0 * PI * float(i % S) / float(S);\n    \n    return r * vec2(cos(theta), sin(theta));    \n}\n\n////////////////////\n// Driver Program //\n////////////////////\n\nfloat sdDisk(vec2 p, int L, int S)\n{\n    float d = MAX_FLT;    \n    for (int i = 0; i < N(L,S); ++i)\n    {             \n        vec2 q = disk(i, L, S);\n        d = min(d, length(p - q));        \n    }\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv *= 1.2 * vec2(aspect, 1.0);\n\n    float d = sdDisk(uv, max(1,L), max(1,S));\n    d = step(0.01, d);\n\t\n    vec3 bg_col = vec3(61, 15, 43) / 255.0;\n    vec3 fg_col = vec3(255, 246, 143) / 255.0;\n    vec3 col = mix(fg_col, bg_col, d);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}