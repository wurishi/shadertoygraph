{"ver":"0.1","info":{"id":"wdsfzB","date":"1588567387","viewed":170,"name":"Parametric curves","username":"rory618","description":"Using a DFS to traverse my BVH in order to handle line segment objects and overlapping bounding boxes, and draw a parametric curve. Add curves using the f function in common. Tune DFS performance parameters at the top of common. Space to show the BVH","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["rasterization","bvh","dfs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Draw 16 thousand line segments along a parametric curve\n//See:\n//https://www.shadertoy.com/view/WssfDn\n//https://www.shadertoy.com/view/Wdlfz7\n//https://www.shadertoy.com/view/tdlBz7\n//https://www.shadertoy.com/view/wdsBRn\n//for all the utilities and algorithm leading up to this,\n//and the paper: https://devblogs.nvidia.com/wp-content/uploads/2012/11/karras2012hpg_paper.pdf\n\ngetters}\n\nbool inBBox(vec4 BBox, vec2 p){\n    return (p.x>BBox.x&&p.y>BBox.y&&p.x<BBox.z&&p.y<BBox.w);\n}\n\nvec4 DFS(vec2 I){\n    float d = 1e8;\n    int count = 0;\n    vec2 coord = (floor(I/R.xy*1024.)+.5)/1024.;\n    int[] stack_data = int[] (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    int stack_pos = -1;\n    int v = 0;\n    \n    #define pop() stack_data[stack_pos--]\n    #define push(data)  stack_data[++stack_pos] = data\n    \n    int node = 0;\n    vec4 bbox = sampleIndexStage(node, BBoxStageFinal);\n    if (!inBBox(bbox,coord)){\n        return vec4(d,0,0,0);\n    }  \n    count++;\n    for(int k = 0; k < DFS_iters; k++){\n        vec4 node_data = sampleIndexStage(node, BBoxStageFinal-BBoxStages+1);\n        int childLeft = int(node_data.x) + int(node_data.y)*128;\n        int childRight = int(node_data.z) + int(node_data.w)*128;\n        bool leafLeft = childLeft >= 16384;\n        bool leafRight = childRight >= 16384;\n        \n        \n        vec4 pDataLeft = sampleIndexStage(childLeft & 16383, leafLeft?sortedStage+BBoxStages-1:BBoxStageFinal);\n        vec4 pDataRight = sampleIndexStage(childRight & 16383, leafRight?sortedStage+BBoxStages-1:BBoxStageFinal);\n        \n        vec4 bboxLeft = leafLeft?leafToBBox(pDataLeft):pDataLeft;\n        vec4 bboxRight = leafRight?leafToBBox(pDataRight):pDataRight;\n        bool validLeft = inBBox(bboxLeft,coord);\n        bool validRight = inBBox(bboxRight,coord);\n        v += int(validLeft&&validRight);\n        count += int(validLeft);\n        count += int(validRight);\n        validLeft = validLeft && (!leafLeft);\n        validRight = validRight && (!leafRight);\n        \n        if(leafLeft){\n            vec4 segment = leafToSegment(pDataLeft);\n            d = min(d, dLine(I,segment.xy*R.xy,segment.zw*R.xy) );\n        }\n        if(leafRight){\n            vec4 segment = leafToSegment(pDataRight);\n            d = min(d, dLine(I,segment.xy*R.xy,segment.zw*R.xy) );\n        }\n        \n        \n        \n        if(validRight){\n            if(validLeft){\n                //Push right, go left\n                push(childRight);\n                node = childLeft;\n            } else {\n                //Go right\n                node = childRight;\n            }\n        } else {\n            if(validLeft){\n                //Go left\n                node = childLeft;\n            } else {\n                //Go up stack\n                if(stack_pos >= 0){\n                    node = pop();\n                } else {\n                    return vec4(d,count,v,0);\n                }\n            }\n        }\n    }\n        \n    return vec4(d,count,v,1);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    //Dot Dot Dot while pipeline fills up\n    if(iFrame<BVHStage0){\n        float fracDone = float(iFrame) / float(BVHStage0);\n        vec2 c = mod(I,R.xy/vec2(3,1));\n        O = vec4(min(1.,R.x/30.-length(c-R.xy/vec2(6,2))));\n        O *= .25+.75*vec4(I.x/R.x<floor(fracDone*4.)/3.);\n    } else {\n        vec4 bbox = sampleIndexStage(0, BBoxStageFinal);\n        \n        if(!inBBox(bbox,vec2(.5))) discard;\n        \n        I = (I-R.xy/2.) * vec2(R.x/R.y,1) + R.xy/2.;\n        O = DFS(I);\n    \tif( texture( iChannel3, vec2(32.5/256.0,0.75) ).x > 0.5){\n        \tO = O.yzwx / vec4(DFS_iters/2, 16, 1,1);\n            O = O.xxxx + vec4(1,0,0,0)*O.y + vec4(-10,-10,1,0 )*O.z;\n        } else {\n            O = 1.5-O.xxxx;\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"getters}\n\n//Generate random particles each frame, and use a pipelined bitonic sorting network to arrange them in a list\n//so that they are in ascending order along a z curve covering uv space, saving the xy coordinate at each step.\n\n//Get the partner to be compared with for a bitonic sort at a given stage\n//See https://en.wikipedia.org/wiki/Bitonic_sorter#Alternative_representation\n\n//   1\n//  11\n//   1\n// 111\n//  10\n//   1\n//1111\n// 100\n//  10\n//   1\n\nconst int[] xors = int[](    1,     3,     1,     7,     2,     1,    15,     4,     2,\n\t\t\t           1,    31,     8,     4,     2,     1,    63,    16,     8,\n\t\t\t           4,     2,     1,   127,    32,    16,     8,     4,     2,\n\t\t\t           1,   255,    64,    32,    16,     8,     4,     2,     1,\n\t\t\t         511,   128,    64,    32,    16,     8,     4,     2,     1,\n\t\t\t        1023,   256,   128,    64,    32,    16,     8,     4,     2,\n\t\t\t           1,  2047,   512,   256,   128,    64,    32,    16,     8,\n\t\t\t           4,     2,     1,  4095,  1024,   512,   256,   128,    64,\n\t\t\t          32,    16,     8,     4,     2,     1,  8191,  2048,  1024,\n\t\t\t         512,   256,   128,    64,    32,    16,     8,     4,     2,\n\t\t\t           1, 16383,  4096,  2048,  1024,   512,   256,   128,    64,\n                      32,    16,     8,     4,     2,     1);\n\nint getPartner(int x, int s){\n    return x ^ xors[s];\n/*    \n\tfloat j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return x ^ (int(b)-1);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        return x ^ int(b/2.);\n    }*/\n}\n\n\n\n//Combine two bounding boxes, return null bbox if one of the bboxes is also null\nvec4 mergeBBox(vec4 A, vec4 B){\n    if(A==vec4(-1) || B==vec4(-1)){\n        return vec4(-1);\n    }\n    return vec4( min(A.xy,B.xy), max(A.zw,B.zw) );\n}\n\n\nvoid mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n    ivec2 XYTall = ivec2(XYFace.x, XYFace.y + 1024*XYFace.z);\n    int index = XYTall.x*16 + (XYTall.y%16);\n    if(XYTall.y < 16){\n        \n        O.xy = f(float(index)/16384.,iFrame);\n        O.zw = f(float(index+1)/16384.,iFrame);\n    } else  {\n        int stage = XYTall.y/16;\n    \tvec4 dataPrev = sampleIndexStage(index, stage-1);\n        int sortStage = stage - 1;\n        if(stage<106){\n        \t//Execute the sorting network swaps\n            int partner = getPartner(index,sortStage);\n            vec4 A = dataPrev;\n            vec4 B = sampleIndexStage(partner, stage-1);\n            int zA = ZOrder(leafToCoord(A));\n            int zB = ZOrder(leafToCoord(B));\n            if((index-partner)*sign(zA-zB)>=0){\n                O = A;\n            } else {\n                O = B;\n            }\n        } else if(stage==BVHStage0){\n            //Fetch the BVH graph from buf A\n            vec4 A = texelFetch(iChannel1, ivec2(index%128, index/128), 0);\n            int childLeft = int(A.z);\n            int childRight = int(A.w);\n            //Pack a 15 bit integer into a pair of cubemap channels\n            O = vec4(childLeft%128,childLeft/128,childRight%128,childRight/128);\n        } else if(stage>=BBoxStage0){\n            //Compute the bounding boxes from leaf nodes upwards towards the root node\n            vec4 BBox = dataPrev;\n            if(BBox == vec4(-1) || stage==BBoxStage0){\n                vec4 node = sampleIndexStage(index, stage-BBoxStages);\n\n                int childLeft = int(node.x) + int(node.y)*128;\n                int childRight = int(node.z) + int(node.w)*128;\n                \n                \n                \n\t\t\t\tbool leafLeft = childLeft>=16384;\n                bool leafRight = childRight>=16384;\n                \n                childLeft = childLeft&16383;\n                childRight = childRight&16383;\n\n                vec4 bboxDataLeft = sampleIndexStage(childLeft, leafLeft?(sortedStage+stage-BBoxStage0+1):(stage-1));\n                vec4 bboxDataRight = sampleIndexStage(childRight, leafRight?(sortedStage+stage-BBoxStage0+1):(stage-1));\n\n                vec4 bboxLeft = leafLeft?leafToBBox(bboxDataLeft):stage==BBoxStage0?vec4(-1):bboxDataLeft;\n                vec4 bboxRight = leafRight?leafToBBox(bboxDataRight):stage==BBoxStage0?vec4(-1):bboxDataRight;\n                \n                O = mergeBBox(bboxLeft, bboxRight);\n            } else {\n                O = BBox;\n            }\n            \n        } else if(stage<=BBoxStageFinal) {\n            //Keep shifting the result down so that JFA pipeline always can find the particles\n            O = dataPrev;\n        }\n        \n    }\n    \n    \n}\n    \n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"const vec2 pad = vec2(1,2);\nconst int DFS_iters = 100;\n\n//Use these parameters for a coarser but faster render\n//const vec2 pad = vec2(1);\n//const int DFS_iters = 40;\n\n#define R iResolution\n\nconst int sortedStage = 106;\nconst int BBoxStages = 40;\nconst int BVHStage0 = sortedStage+BBoxStages;\nconst int BBoxStage0 = BVHStage0+BBoxStages;\nconst int BBoxStageFinal = BBoxStage0 + BBoxStages - 3;\n\n//Line segment sdf\nfloat dLine(vec2 p, vec2 a, vec2 b){\n    p-=a;\n    b-=a;\n    float l2 = dot(b,b);\n    p -= b*clamp(dot(p,b/l2),0.,1.);\n    return length(p);\n}\n\n\n//Magic to convert a binary number 0xbbbb into 0x0b0b0b0b\nint spreadBits(int word){\n    word = (word ^ (word << 8 )) & 0x00ff00ff;\n    word = (word ^ (word << 4 )) & 0x0f0f0f0f;\n    word = (word ^ (word << 2 )) & 0x33333333;\n    word = (word ^ (word << 1 )) & 0x55555555;\n    return word;\n}\n\n//Convert a 0-1 xy coordinate to a 20 bit morton/z order code\nint ZOrder(vec2 coord){\n    int x = int(coord.x*1024.);\n    int y = int(coord.y*1024.);\n    return spreadBits(x) | (spreadBits(y)<<1);\n}\n\n\n//Cubemap utils to convert between a 1024 x 1024 x 6 buffer coordinate to a cubemap ray direction\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512.0, -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n\nfloat saw( float x ) { return -1.0 + 2.0*fract(x); }\n\nvec2 f(float x, int frame){\n    float theta = x * 6.2832;\n    float time = float(frame)/60.;\n    int mode = (frame/60/10)%6;\n    \n    if(mode == 5){\n        //Thanks IQ for shroom: https://www.shadertoy.com/view/XsjSzc\n        float freq = 100.;\n        float h = x;\n        float t = mod(time,3.1416) + 12.0*h/freq;\n        float x = 0.6*cos( 5.0*freq*6.2831*t ) * \n                      sin( 1.0*freq*6.2831*t/12.0) *\n                 (0.1+0.9*step(fract(t*freq/12.0),0.25)) - \n                  0.2*sin(t*6.2831*freq/12.0 + t*2.0) * \n                 (1.0-fract(t*freq/12.0));\n        float y = 0.1*sin( 5.0*freq*6.2831*t ) - \n                  1.0*saw( 1.0*freq*t/12.0 );\n        \n        return vec2(x,y)/2.5+.5;\n    }\n    \n    mat4 phase = mat4(0.,0.,time,time*10.,0.,0.,0.,0.,0,0,0,0,0,0,0,0);\n    mat4 freq =  mat4(1.,2.,4.,140.,5.,6.,7.,8.,0,0,0,0,0,0,0,0);\n    mat4 amp =   mat4(.2,.0,.2,.1,.0,.0,.0,.0,0,0,0,0,0,0,0,0);\n    \n    if(mode == 1){\n        phase = mat4(0.,0.,time,time*10.,0.,0.,0.,0.,0,0,0,0,0,0,0,0);\n    \tfreq =  mat4(1.,2.,6.,140.,5.,6.,7.,8.,0,0,0,0,0,0,0,0);\n    \tamp =   mat4(.3,.0,.1,.05 * cos(theta*14.) ,.0,.0,.0,.0,0,0,0,0,0,0,0,0);\n    }\n    if(mode == 2){\n        phase = mat4(0.,time/2.2,-time/2.2,0,time+theta,0,0,0,0,0,0,0,0,0,0,0);\n    \tfreq =  mat4(1.,3,5,150,-150,0,0,0,0,0,0,0,0,0,0,0);\n    \tamp =   mat4(.1,.1,.1,.03,0.031,0,0,0,0,0,0,0,0,0,0,0);\n    }\n    if(mode == 3){\n        phase = mat4(time,time/2.2,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    \tfreq =  mat4(1.,4,7,150,0,0,0,0,0,0,0,0,0,0,0,0);\n    \tamp =   mat4(.2,.18,.16,.01,0,0,0,0,0,0,0,0,0,0,0,0);\n    }\n    if(mode == 4){\n        phase = mat4(0,0,3.141,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    \tfreq =  mat4(1,-1,100,-100,0,0,0,0,0,0,0,0,0,0,0,0);\n    \tamp =   mat4(.2,.21,.1*sin(theta*10.+time),.1*sin(theta*10.+time),0,0,0,0,0,0,0,0,0,0,0,0);\n    }\n    \n    vec2 r = vec2(.5);\n    \n    r += vec2(cos(phase[0][0] + theta*freq[0][0]), sin(phase[0][0] + theta*freq[0][0]) ) * amp[0][0];\n    r += vec2(cos(phase[0][1] + theta*freq[0][1]), sin(phase[0][1] + theta*freq[0][1]) ) * amp[0][1];\n    r += vec2(cos(phase[0][2] + theta*freq[0][2]), sin(phase[0][2] + theta*freq[0][2]) ) * amp[0][2];\n    r += vec2(cos(phase[0][3] + theta*freq[0][3]), sin(phase[0][3] + theta*freq[0][3]) ) * amp[0][3];\n    r += vec2(cos(phase[1][0] + theta*freq[1][0]), sin(phase[1][0] + theta*freq[1][0]) ) * amp[1][0];\n    r += vec2(cos(phase[1][1] + theta*freq[1][1]), sin(phase[1][1] + theta*freq[1][1]) ) * amp[1][1];\n    r += vec2(cos(phase[1][2] + theta*freq[1][2]), sin(phase[1][2] + theta*freq[1][2]) ) * amp[1][2];\n    r += vec2(cos(phase[1][3] + theta*freq[1][3]), sin(phase[1][3] + theta*freq[1][3]) ) * amp[1][3];\n    return r;\n    \n}\n\n\n\n\nvec4 leafToBBox(vec4 data){\n    vec2 A = data.xy*1024.;\n    vec2 B = data.zw*1024.;\n    vec2 mn = min(A,B);\n    vec2 mx = max(A,B);\n    return vec4((floor(mn)-pad)/1024., (floor(mx)+1.+pad)/1024.);\n}\n\nvec2 leafToCoord(vec4 data){\n    return (data.xy + data.zw)/2.;\n}\n\nvec4 leafToSegment(vec4 data){\n    \n    return data;\n}\n\n//Functions to sample a particle coordinate from the cubemap as a 1024 x 6144 buffer and a 16384 x 384 buffer\n#define getters \\\nvec4 sampleXYTall(ivec2 XYTall){\\\n    ivec3 XYFace = ivec3(XYTall.x, XYTall.y%1024, XYTall.y/1024);\\\n\treturn texture(iChannel0, XYFaceToRayDir(XYFace));\\\n}\\\nvec4 sampleIndexStage(int index, int stage){\\\n    ivec2 XYTall = ivec2(index/16, index%16+stage*16);\\\n    return sampleXYTall(XYTall);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"getters}\n\n//Length of the shared prefix of the morton codes of a pair of particles.\n//If the codes are the same, then also count shared bits of the list index which will never be the same.\n//Return -1 if the j particle is outside the range of all particles\nint plen(int i, int j){\n    if(j<0||j>=16384) return -1;\n    vec4 pi = sampleIndexStage(i, sortedStage);\n    vec4 pj = sampleIndexStage(j, sortedStage);\n    int mi = ZOrder(leafToCoord(pi));\n    int mj = ZOrder(leafToCoord(pj));\n    if(mi!=mj){\n        int x = mi^mj;\n        float f = log2(float(x)+0.5);\n        return 30 - int(f);\n    } else {\n        int x = i^j;\n        float f = log2(float(x)+0.5);\n        return 60 - int(f);\n    }\n}\n        \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    //index always indicates either the left or right end of the range of particle indecies it contains\n    int i = int(I.x) + int(I.y)*128;\n    \n    //Check direction if this node\n    int d = sign(plen(i,i+1)-plen(i,i-1));\n    \n    //Scan to find the other end of this node, so that all the nodes share a prefix at least \n    //as long as the shared prefix between the first two elements\n    //Scan away to find an upper bound\n    int dmin = plen(i,i-d);\n    int lmax = 2;\n    for(int k = 0; k<14; k++){\n        if (plen(i, i + lmax*d) <= dmin)\n            break;\n        lmax *= 2;\n    }\n    \n    //Scan back with a binary search\n    int l = 0;\n    int t = lmax/2;\n    for(int k = 0; k<14; k++){\n        if (plen(i, i + (l+t)*d) > dmin){\n            l = l+t;\n        }\n        if(t==1) break;\n        t /= 2;\n        \n    }\n    //Compute the other end of the range of particle indecies this node contains\n    int j = i + l * d;\n\n    //Find the split index where the nodes on one side share a different longes prefix from the other\n    int dnode = plen(i, j);\n    int s = 0;\n    float ft = float(l)/2.;\n    for(int k = 0; k<14; k++){\n        t = int(max(1.,ceil(ft)));\n        if(plen(i, i + (s + t) * d ) > dnode){\n            s += t;\n        }\n        ft /= 2.;\n    }\n    //Compute split index\n    int y = i + s * d + min(d,0);\n    \n    //Compute the child node indecies using the split index y and two ends i and j\n    int childLeft;\n    int childRight;\n    if (min(i,j) == y) {\n        childLeft = y + 16384;\n    } else {\n        childLeft = y;\n    }\n    if (max(i,j) == y+1){\n        childRight = (y+1) + 16384;\n    } else {\n        childRight = y+1;\n    }\n    \n    //Safe the left index and right index (just for testing), as well as left and right child nodes\n    O = vec4(min(i,j),max(i,j),childLeft,childRight);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}