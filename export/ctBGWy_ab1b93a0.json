{"ver":"0.1","info":{"id":"ctBGWy","date":"1686571913","viewed":69,"name":"core","username":"madevgeny","description":"sphere","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sphere"],"hasliked":0,"parentid":"DtlGWl","parentname":"Fork ray_sphere madevgeny 231"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks to\n// https://www.shadertoy.com/view/tscBz8\n\n#define MAX_STEPS 100\n#define MAX_DIST 4.0\n#define MIN_DIST 0.0\n#define CLOSEST_DIST 0.001\n#define MSAA 2\n\n#define zero4 vec4(0)\n#define zero3 vec3(0)\n#define zero2 vec2(0)\n#define one4 vec4(1)\n#define one3 vec3(1)\n\n#define one4 vec4(1)\n#define one3 vec3(1)\n\n#define blue3 vec3(0, 0, 1)\n#define red3 vec3(1, 0, 0)\n#define pink3 vec3(1, 0, 1)\n\n#define FOCAL_LENGTH 2.5\n\n#define PI 3.14159265359\n#define PI_2 PI * 0.5\n#define PI2 PI * 2.0\n\n#define SMOOTH_CORE 0.01\n#define CORE vec4(zero3, 0.3)\n\n#define N_POINTS 108\n#define POINT_SIZE 0.03\n//#define POINTS_RADIUS (CORE.w)\n#define POINTS_RADIUS 0.3\n\n#define SMOOTH_SPHERE 0.15\n#define SPHERES_ORBIT 0.8\n#define SPHERE_SPEED 0.5\n\n#define BLUE_RADIUS 0.15\n#define RED_RADIUS 0.15\n\n#define AMBIENT_COEFF 0.4\n#define SHINESS_COEFF 8.0\n\n#define GOLDEN_RATIO  ((1.0 + pow(5.0, 0.5))/2.0)\n\nstruct Ray{vec3 o; vec3 d;};\nstruct SpotLight{vec3 p; vec3 c;};\nstruct DirLight{vec3 d; vec3 c;};\n\nstruct Material{\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n};\nstruct Point{\n    float d;\n    Material mat;\n};\n\n#define BlueMaterial Material(blue3 * AMBIENT_COEFF, blue3, red3, SHINESS_COEFF)\n#define RedMaterial Material(red3 * AMBIENT_COEFF, red3, blue3, SHINESS_COEFF)\n#define PinkMaterial Material(pink3 * AMBIENT_COEFF, pink3, vec3(0.0), SHINESS_COEFF)\n#define BigBlueMaterial Material(blue3 * AMBIENT_COEFF, blue3, vec3(1.0), SHINESS_COEFF * 2.0)\n#define BigRedMaterial Material(red3 * AMBIENT_COEFF, red3, vec3(1.0), SHINESS_COEFF * 2.0)\n\n#define MaterialZero Material(zero3, zero3, zero3, 0.0)\n#define PointZero Point(MAX_DIST, MaterialZero)\n\nstruct Scene{\n    vec4 blueSphere;\n    vec4 redSphere;\n    vec4 boundingSphere;\n};\n\nmat3 make_rotate(vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);           \n}\n\n// https://www.math.unipd.it/~erb/LSphere.html\nvec3 liss(float r, float m1, float m2, float alpha, float time){\n    vec3 o = zero3;\n    float t = time * 0.1;\n    float m1t = m1 * t - alpha * PI;\n    float m2t = m2 * t;\n    o.x = r * sin(m2t) * cos(m1t);\n    o.y = r * sin(m2t) * sin(m1t);\n    o.z = r * cos(m2t);\n    return o;\n}\n\nfloat dist_to_sphere(in vec3 p, in vec4 spos){\n    float d = length(p - spos.xyz) - spos.w;\n    return d;\n}\n\nfloat displace_grav(in vec3 p, in float d1, in vec3 spos, in vec3 coeffs)\n{\n    vec3 toP = normalize(p);\n    vec3 toS = normalize(spos);\n    \n    float t = dot(toP, toS);\n    float d = 0.0;\n    if(t > coeffs.x){\n        t = pow(t, coeffs.y);\n        d = mix(0.0, coeffs.z, t);\n    }\n    \n    return d1 + d;\n}\n\n// https://iquilezles.org/articles/smin/\nvec2 smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\nfloat sminCubic(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*h*0.5;\n    float s = m*k*(1.0/3.0); \n    //return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n    return (a<b) ? a-s : b-s;\n}\n\n// https://iquilezles.org/articles/distfunctions/\nPoint smooth_union2(in Point d1, in Point d2, float k){\n    Point o;\n    vec2 d = smin(d1.d, d2.d, k);\n    vec2 dd = smin(d1.d, d2.d, k * 3.0);\n    o.d = d.x;\n    o.mat.diffuseColor = mix(d1.mat.diffuseColor, d2.mat.diffuseColor, dd.y* 1.0);\n    \n    return o;\n}\n\nPoint smooth_union(in Point p1, in Point p2, float smoothness){\n    float t = clamp(0.5 + 0.5 * (p2.d - p1.d) / smoothness, 0.0, 1.0);\n    Material mat = MaterialZero;\n    mat.ambientColor = mix(p2.mat.ambientColor, p1.mat.ambientColor, t);\n    mat.diffuseColor = mix(p2.mat.diffuseColor, p1.mat.diffuseColor, t);\n    mat.specularColor = mix(p2.mat.specularColor, p1.mat.specularColor, t);\n    mat.shininess = mix(p2.mat.shininess, p1.mat.shininess, t);\n    return Point(\n        mix(p2.d, p1.d, t) - smoothness * t * (1.0 - t),\n        mat\n    );\n}\n\nPoint upd(in Point d1, in Point d2){\n    if(d1.d < d2.d){\n        return d1;\n    }\n    return d2;\n}\n\n//----------------------- Begin resource builders -----------------------//\n\nconst int N_DIR_LIGHTS = 1;\nDirLight[N_DIR_LIGHTS] build_dir_lights(in float time){\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    DirLight d[N_DIR_LIGHTS];\n    d[0] = DirLight(normalize(vec3(0, 1, 1)), c);\n//    d[1] = DirLight(normalize(vec3(-1, 0, 0)), c);\n    //d[2] = DirLight(normalize(vec3(1, 0, 0)), c);\n    return d;\n}\n\nconst int N_SPOT_LIGHTS = 1;\nSpotLight[N_SPOT_LIGHTS] build_spot_lights(in float time){\n    SpotLight s[N_SPOT_LIGHTS];\n    s[0] = SpotLight(zero3, vec3(1, 0, 1));\n    return s;\n}\n\nmat3 build_view(float time, vec2 mo, out vec3 orig){\n    //orig = vec3( 4.5*cos(0.5*time + 7.0*mo.x), 2.2, 4.5*sin(0.5*time + 7.0*mo.x) );\n    float r = 3.0;\n    float theta = PI_2 - (mo.x - 0.5) * PI * 4.5 ;\n    float phi = -(mo.y - 0.5) * PI;\n    orig = vec3(r * sin(theta) * cos(phi),r * sin(theta) * sin(phi),r * cos(theta));\n    vec3 cw = normalize(-orig);\n\tvec3 cp = vec3(0, 1, 0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nScene build_scene(float time){\n    Scene s;\n    \n    s.blueSphere = vec4(zero3, BLUE_RADIUS);\n    s.redSphere = vec4(zero3, RED_RADIUS);\n    \n    vec3 ab = zero3;\n    ab = liss(SPHERES_ORBIT, 1.0, 8.0, 1.0, -time * SPHERE_SPEED);\n    s.blueSphere.xyz = ab;\n\n    vec3 ar = zero3;\n    ar = liss(SPHERES_ORBIT, 1.0, 8.0, 1.0, time * SPHERE_SPEED);\n    s.redSphere.xyz = ar;\n    //s.redSphere.xyz = vec3(a.x, cos(a.y), sin(a.x) * sin(a.y), cos(a.x));\n\n    s.boundingSphere = vec4(zero3, SPHERES_ORBIT + RED_RADIUS * 1.5);\n\n    return s;\n}\n\n//----------------------- End resource builders -----------------------//\n\n// https://www.shadertoy.com/view/tscBz8\nvec3 calc_light(in Point p, in Ray ray, in vec3 normal, in vec3 lightColor, in vec3 lightDirection){\n    vec3 illuminationAmbient = p.mat.ambientColor;\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * p.mat.diffuseColor;\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.d));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, p.mat.shininess), 0.0, 1.0) * p.mat.specularColor;\n    return (illuminationAmbient + illuminationDiffuse + illuminationSpecular) * lightColor;\n}\n\n// http://extremelearning.com.au/evenly-distributing-points-on-a-sphere/\nPoint dist_to_spheres(in vec3 p, in float r1, in float r2){\n    Point o = PointZero;\n    for(int i = 0; i < N_POINTS; ++i){\n        float k = float(i) + 0.5;\n        float phi = acos(1.0 - 2.0*k / float(N_POINTS));\n        float theta = 2.0 * PI * float(k) / GOLDEN_RATIO;\n        \n        vec3 pos = r1 * vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));\n        Point o1 = Point(dist_to_sphere(p, vec4(pos, r2)), MaterialZero);\n        if((i % 2) == 0){\n            o1.mat = RedMaterial;\n        }else{\n            o1.mat = BlueMaterial;\n        }\n        o = upd(o1, o);\n    }\n    \n    return o;\n}\n\nPoint dist_to_scene(in vec3 p, in Scene s, in float time){\n    Point o = PointZero;\n    \n    float dc = dist_to_sphere(p, s.boundingSphere);\n    if(dc > CLOSEST_DIST){\n        o.d = dc;\n        return o;\n    }\n    // Core\n    {\n        float dc = dist_to_sphere(p, vec4(zero3, POINTS_RADIUS + POINT_SIZE * 2.0));\n        if(dc <= CLOSEST_DIST)\n        {\n            Point o1 = dist_to_spheres(p, POINTS_RADIUS, POINT_SIZE);\n            if(o1.mat.diffuseColor == blue3){\n                o1.d = displace_grav(p, o1.d, s.blueSphere.xyz, vec3(0.5, 20.0, -0.01));\n            }else{\n                o1.d = displace_grav(p, o1.d, s.redSphere.xyz, vec3(0.5, 20.0, -0.01));\n            }\n            //o = upd(o, o1);\n            \n            float d = dist_to_sphere(p, CORE);\n            Point o2 = upd(o, Point(d, PinkMaterial));\n            \n            o = upd(o, smooth_union(o1, o2, SMOOTH_CORE));\n        }\n        else{o.d = dc;}\n    }\n    \n    // Satellites\n    {\n        Point o1 = upd(PointZero, Point(dist_to_sphere(p, s.blueSphere), BigBlueMaterial));\n        Point o2 = upd(PointZero, Point(dist_to_sphere(p, s.redSphere), BigRedMaterial));\n        o = upd(o, smooth_union(o1, o2, SMOOTH_SPHERE));\n    }\n        \n    return o;\n}\n\nPoint ray_march(in Ray r, in Scene s, in float time, out vec3 pos){\n\tvec3 p = zero3;\n    float dt = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        pos = r.o + r.d * dt;\n        Point o = dist_to_scene(pos, s, time);\n      \n        if(o.d <= CLOSEST_DIST){\n            return o;\n        }\n        \n        if(o.d >= MAX_DIST){\n            return PointZero;\n        }\n        \n        dt += o.d;\n    }\n    return PointZero;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 scene_normal(in vec3 p, in Scene s, in float time){\n\tvec2 e = vec2(1.0,-1.0) * 0.01;\n    Point d1 = dist_to_scene(p + e.xyy, s, time);\n    Point d2 = dist_to_scene(p + e.yyx, s, time);\n    Point d3 = dist_to_scene(p + e.yxy, s, time);\n    Point d4 = dist_to_scene(p + e.xxx, s, time);\n   \n    return normalize(e.xyy * d1.d + \n\t\t\t\t\t  e.yyx * d2.d + \n\t\t\t\t\t  e.yxy * d3.d + \n\t\t\t\t\t  e.xxx * d4.d);\n}\n\nvec3 calc_lights(in vec3 p, in vec3 n, in Ray ray, in Point point, in DirLight[N_DIR_LIGHTS] dirLights, in SpotLight[N_SPOT_LIGHTS] spotLights){\n    vec3 lc = zero3;\n    for(int i = 0; i < N_DIR_LIGHTS; ++i){\n        DirLight l = dirLights[i];\n        lc += calc_light(point, ray, n, l.c, l.d);\n        //lc += \n    }\n     \n    for(int i = 0; i < N_SPOT_LIGHTS; ++i){\n       SpotLight l = spotLights[i];\n       //lc += calc_spot_light_color(p.xyz, n, rd, l.p, l.c);\n    }\n    \n    return min(vec3(1, 1, 1), lc);\n}\n\nvec3 calc_env(vec2 fragCoord){\n    float brightness = 0.1;\n    \n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float dist = length(uv) / 2.0;\n    dist = pow(dist, 5.0);\n    uv = vec2(dist);\n\n    vec3 v = vec3(dist, 0.3, 1);\n    \n    float contrast = 1.0;\n    v = ((v - 0.5f) * max(contrast, 0.0)) + 0.5f;\n\n    v += brightness;\n\n    return v;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 mo = iMouse.xy/iResolution.xy;\n    float time = iTime*1.5;\n\n    SpotLight[N_SPOT_LIGHTS] spot_lights = build_spot_lights(time);\n    DirLight[N_DIR_LIGHTS] dir_lights = build_dir_lights(time);\n    Scene scene = build_scene(time);\n    \n    vec3 env = calc_env(fragCoord);\n    \n    vec3 orig;\n    mat3 view = build_view(time, mo, orig);\n    for(int k = 0; k < N_DIR_LIGHTS; ++k){\n        dir_lights[k].d = view * (-dir_lights[k].d);\n    }\n    vec3 col = zero3;\n    for(int i = 0; i < MSAA; ++i)\n    for(int j = 0; j < MSAA; ++j){\n        // pixel coordinates\n        vec2 o = vec2(float(i),float(j)) / float(MSAA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\n        Ray r;\n        r.o = orig;\n        r.d = view * normalize(vec3(p, FOCAL_LENGTH));\n        \n        vec3 pos;\n        Point point = ray_march(r, scene, time, pos);\n        vec3 normal = scene_normal(pos.rgb, scene, time);\n        if(point.d >= MAX_DIST){\n           col.rgb += env;\n           continue;\n        }\n        vec3 lc = zero3;\n        lc += calc_lights(pos, normal, r, point, dir_lights, spot_lights);\n        \n        // gain\n        // lc.rgb = lc.rgb*3.0/(2.5+lc.rgb);\n        \n\t\t// gamma\n        lc.rgb = pow( lc.rgb, vec3(0.4545) );\n        col += lc;\n    }\n    \n    col /= float(MSAA * MSAA);\n    //col.rgb = env;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}