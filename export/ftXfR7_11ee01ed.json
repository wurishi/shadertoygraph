{"ver":"0.1","info":{"id":"ftXfR7","date":"1650619789","viewed":86,"name":"Catch pokemon (sick snorflex) ","username":"Laggron","description":"Catch the snorflex by clicking on the screen","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["pokemonpokeballsnorflex3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////Explanations////////////////////////////////////\n// Click on snorflex to catch it\n// Made by Benoit Defossez & Kevin Gallus\n// Improvement in progress (don't be bad on our work please it's our first project :) )\n// Thanks to Christian Sandor for making us discover the infographic\n// Thanks to Inigo Quilez for explaining how to make 3d shapes on his site \n// More information here: https://iquilezles.org/articles/distfunctions\n////////////////////////////////////////////////////////////////////////////\n\n\nmat3 rotationMatrix_Y(float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\n\nmat3 rotationMatrix_X(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,c,-s),\n        vec3(0,s,c)\n    );\n}\n\nmat3 rotationMatrix_Z(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,-s,0),\n        vec3(s,c,0),\n        vec3(0,0,1)\n    );\n}\n\nvec3 rotateY(vec3 p, float theta)\n{\n    return p*rotationMatrix_Y(theta);\n}\n\nvec3 rotateX(vec3 p, float theta)\n{\n    return p*rotationMatrix_X(theta);\n}\n\nvec3 rotateZ(vec3 p, float theta)\n{\n    return p*rotationMatrix_Z(theta);\n}\n\n// ---------------------------------------------\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n//-------------------------------------------------\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTwistedBox( vec3 p, vec3 b )\n{\n    vec3 q = rotateY(p,p.y*5.0);\n    return sdBox(q,b);\n}\n\nfloat sdLiquidBox( vec3 p, vec3 b )\n{\n    float d = sdBox(p,b);\n    float noise = 0.1*sin(20.0*p.x) * sin(20.0*p.y)*sin(20.0*p.z);\n    //float noise =0.1*sin(iTime)* sin(20.0*p.x) * sin(20.0*p.y)*sin(20.0*p.z);\n    return d+ noise;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h)\n{\n    vec2 d = vec2(length(p.xz)-2.*ra+rb,abs(p.y)-h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n// r is the sphere's radius, h is the plane's position\nfloat sdCutSphere( in vec3 p, in float r, in float h )\n{\n    float w = sqrt(r*r-h*h); // constant for a given shape\n    \n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n\n    return (s<0.0) ? length(q)-r :\n           (q.x<w) ? h - q.y     :\n                     length(q-vec2(w,h));\n}\n\n//---------------------------------\nfloat map(in vec3 pos, out int material)\n{\n    vec3 q = pos - vec3(0.2,0.0,1.0);\n    float floor = sdBox(q, vec3(3.6,0.02,5.7)); \n    \n    // Corps\n    vec3 r = q + vec3(0.0,-0.5,-0.7);    \n    float d1 = sdEllipsoid( r, vec3(0.6,0.5,0.5));\n    r = q + vec3(0.0,-0.3,-0.7);    \n    float d2 = sdEllipsoid( r, vec3(0.7,0.5,0.5));\n\n    float corps = opSmoothUnion(d1,d2,0.1);\n\n    // Interieur corps\n    r = q + vec3(0.0,-0.5,-0.9);    \n    float int_d1 = sdEllipsoid( r, vec3(0.5,0.4,0.4));\n    r = q + vec3(0.0,-0.35,-0.9);    \n    float int_d2 = sdEllipsoid( r, vec3(0.55,0.4,0.4));\n\n    float int_corps = opSmoothUnion(int_d1,int_d2,0.1);\n\n    // Bras\n    vec3 r_g = vec3(abs(q.x)-0.55,q.y-0.85,q.z-0.9);  \n    r_g = rotateZ(r_g, 0.5); \n    r_g = rotateY(r_g, 0.7); \n    float bras = sdEllipsoid(r_g, vec3(0.4,0.1,0.2));\n\n    corps = opSmoothUnion(corps,bras,0.1);\n\n    // Tete\n    r = q + vec3(0.0,-1.2,-0.7); \n    r = rotateY(r,0.314*sin(iTime));\n    float d3 = sdEllipsoid( r, vec3(0.35,0.3,0.3));\n\n    // Interieur tete\n    r = q + vec3(0.0,-1.2,-0.8);    \n    r = rotateY(r,0.314*sin(iTime));\n    float int_tete = sdEllipsoid( r, vec3(0.28,0.23,0.3));\n\n    // Bouche\n    r = q + vec3(0.0,-1.18,-0.81);\n    r = rotateY(r,0.314*sin(iTime));\n    float bouche = sdEllipsoid( r, vec3(0.25,0.13,0.3));\n\n    // Yeux\n    r = vec3(abs(q.x)-0.1,q.y-1.3,q.z-1.);   \n    r = rotateX(r,0.314*sin(iTime));\n    float yeux = sdEllipsoid( r, vec3(0.09,0.01,0.08));\n    \n    // Oreilles\n    vec3 r1 = vec3(abs(q.x)-0.3,q.y-1.52,q.z-0.7);    \n    r1 = rotateZ(r1, 0.6);\n    float oreilles = sdCone(r1, vec2(0.2,0.15), 0.15);\n\n    float tete = opSmoothUnion(d3,oreilles,0.002);\n    float tete_corps = opSmoothUnion(tete,corps,0.1);\n\n    // Pieds\n    r_g = vec3(abs(q.x)-0.5,q.y-0.2,q.z-1.); \n    r_g = rotateX(r_g, 3.14/2.);\n    r_g = rotateZ(r_g, -3.14/5.);\n    float pieds = sdRoundedCylinder(r_g, 0.1, 0.05, 0.1);\n\n    // IntÃ©rieurs des pieds\n    r_g = vec3(abs(q.x)-0.5,q.y-0.18,q.z-1.01); \n    r_g = rotateX(r_g, 3.14/2.);\n    r_g = rotateZ(r_g, -3.14/5.);\n    float int_pieds = sdRoundedCylinder(r_g, 0.07, 0.05, 0.1);\n\n    //Pokeball\n    r = q + vec3(1.0,-0.2,-1.0);\n    if(iMouse.z > 0.0){\n        r = q + vec3(0.0,-0.2,-1.0);\n        r = rotateZ(r,sin(iTime)/2.0);        \n    }  \n    float toppoke =  sdCutSphere( r, 0.2, 0.0 );\n    float disk = sdRoundedCylinder(r, 0.1, 0.1, 0.003);\n    r = rotateZ(r,3.14);\n    float botpoke =  sdCutSphere( r, 0.2, 0.0 );\n    r = q + vec3(1.0,-0.2,-1.21);\n    if(iMouse.z > 0.0){\n        r = q + vec3(0.0,-0.2,-1.21);     \n    }  \n    r = rotateX(r, 3.14/2.);\n    float rondelle = sdRoundedCylinder(r, 0.022, 0.01, 0.002);\n    float in_disk = sdRoundedCylinder(r, 0.02, 0.01, 0.003);\n    // Ronflex + Sol\n\n    float ronflex = opUnion(pieds,tete_corps);\n    ronflex = opUnion(ronflex,int_pieds);\n    ronflex = opUnion(ronflex,int_corps);\n    float visage = opUnion(yeux,bouche);\n    ronflex = opUnion(ronflex,visage);\n    ronflex = opSmoothUnion(ronflex,int_tete,0.001);\n    float pokeball = opUnion(toppoke,botpoke);\n    pokeball = opUnion(pokeball,disk);\n    pokeball = opUnion(pokeball,in_disk);\n    pokeball = opUnion(pokeball,rondelle);\n    float dt = pokeball;\n    if(iMouse.z < 0.0){\n         dt = opUnion(ronflex,dt);\n    } \n\n\n    if(tete_corps == dt) {\n        material = 1;\n    } else if(pieds == dt || int_corps == dt || int_tete == dt) {\n        material = 2;\n    } else if(int_pieds == dt) {\n        material = 3;\n    } else if(visage == dt || disk == dt || rondelle == dt) {\n        material = 4;\n    } else if (toppoke == dt || (in_disk == dt && sin(iTime*6.0)>0.0)&&iMouse.z > 0.0){\n        material = 5;\n    }else {\n        material =-1;\n    }\n\n\n    \n    return dt;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    int mat = 0;\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep, mat ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep, mat ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep, mat ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep, mat ) );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n    int mat = 0;\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, mat);\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 tot = vec3(0.0);\n    \n    // 1 Set up the camera (primar way) \n   vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y; \n   //center of screen: (0,0)\n   //dimensions: +/- 0.5\n \n   vec3 ro = vec3(0.0,3.0,8.8);\n   vec3 rd = normalize(vec3(p-vec2(0.1,1.9),-6.));\n\n    // Color\n    vec3 uglyGreen = vec3(0,0.4,0.4);\n    vec3 beige = vec3(1,0.90,0.75);\n    vec3 brown = vec3(0.5,0.25,0.0);\n    vec3 white = vec3(1.,1.,1.0);\n    vec3 black = vec3(0.0);\n    vec3 red = vec3(1.0,0.0,0.0);\n\n    // 2 Raymarching\n   float t = 7.0;\n   int mat = 0;\n   for( int i=0; i<128; i++ )\n   {\n\tvec3 p = ro + t*rd;\n\tfloat h = map(p, mat);\n\tif( abs(h)<0.0001 || t>11.0 ) break;\n\tt += h;\n   }\n\n   vec3 col = texture(iChannel0, fragCoord.xy/iResolution.xy).xyz;\n   col*=vec3(0.8,0.6,0.7);\n\n    // Shading\n   if( t<11.0 )\n   {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n        float dif = clamp(dot(nor,lig),0.0,1.0);\n        float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n        float amb = 0.5 + 0.5*nor.y;\n        col = vec3(0.05,0.1,0.15)*amb + vec3(1.00,0.9,0.80)*dif*sha;\n        if(mat == 1) {\n            col *= uglyGreen;\n        } else if(mat == 2) {\n            col *= beige;\n        } else if(mat == 3) {\n            col *= brown;\n        }\n        else if(mat == 4) {\n            col *= black;\n        }else if (mat == 5){\n            col*=red;\n        }  else {\n            col *= white;\n        }\n   }\n\n    col = sqrt( col );\n    tot += col;\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}