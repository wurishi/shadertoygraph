{"ver":"0.1","info":{"id":"wlSfWW","date":"1598989153","viewed":80,"name":"kmrd_CornellBox_v2.1","username":"komradepasha","description":"path-tracing exercise","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// convert linear to sRGB\nfloat sRGB(float channel) \n{\n\tif (channel <= 0.00031308)\n        channel *= 12.92;\n    else\n        channel = 1.055 * pow(channel, (1.0 / 2.4)) - 0.055;\n\n    return channel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 drawBuffer =  texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(vec3(sRGB(drawBuffer.r), sRGB(drawBuffer.g), sRGB(drawBuffer.b)),1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Cornell Box. version 2.1\t\t\t\t\t\t\t\t\t\t by Pavel Pranevsky //\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t//\n//\t\t\t\t\t\t\t\t\t!!Work in Progress!!\t\t\t\t\t\t  \t//\n//\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t//\n// This is an exercise in learning GLSL and understanding Monte Carlo path tracing. //\n// All code is property of it's creator and cannot be used without permission.\t\t//\n\n\n\n////////////////////     defines    ////////////////////\n\n// ray marching limits\n#define MAX_MARCHING_STEPS 100\n#define MAX_MARCHING_DIST 20.0\n#define MIN_SURFACE_DIST 0.0001\n\n#define PIXEL_SAMPLES 1\n\n// ray depth\n#define DIFFUSE_BOUNCES 2\n#define REFRACTION_DEPTH 2\n\n// constants\n#define Pi 3.14159265359\n\n//////////////////// custom structs ////////////////////\nstruct surface \n{\n    bool \tmetallic, refractive;\n    float \temissive, IOR, roughness, scatteringWeight;\n    vec3 \talbedo, scatteringColor;\n};\n\nstruct ray \n{\n    vec3 \torigin, direction;\n};\n\nstruct rayHit \n{\n    float \tdist;\t\t\t\t\t\n    vec3  \tnormal;\n    surface material;\n};\n\nstruct camera \n{\n    vec3 \tposition, target, forward, right, up;\t\t\n};\n\nstruct light \n{\n    vec3 \tposition, target, color, forward, right, up;\t\t\n    float \tintensity, radius;\n};\n\n//////////////////////////////////////////////////////// \nfloat randFloat (vec2 seed)\t\n{\t\n\treturn fract(sin(dot(seed.xy + vec2(iTime), vec2(12.9898, 78.233))) * 43758.5453);\t\n}\n\n\nlight makeLight(vec3 lightPosition, vec3 lightColor, float intensity, float radius) \n{\n    light l;\n    l.position \t\t= lightPosition;\n    l.color \t\t= lightColor;\n    l.intensity \t= intensity;\n    l.radius \t\t= radius;\n    l.forward \t\t= normalize(l.target - l.position);  \t\t\n    l.right \t\t= cross(vec3(0, 1, 0), l.forward);\t    \t\n    l.up \t\t\t= cross(l.forward, l.right);\n    return l;\t\n}\n\n\ncamera makeCamera(vec3 cameraPosition, vec3 cameraTarget) \n{\n    camera cam;\n    cam.position \t= cameraPosition;\n    cam.target \t\t= cameraTarget;\n    cam.forward \t= normalize(cameraTarget - cameraPosition); \n    cam.right \t\t= cross(vec3(0, 1, 0), cam.forward);\t    \n    cam.up \t\t\t= cross(cam.forward, cam.right);\t\t\t\n    return cam;\t\n}\n\n\nray getCameraRay(vec2 uv, camera cam, float zoom) \n{\n    ray r;\n        r.origin \t= cam.position;                          \t\n        vec3 c \t\t= r.origin + cam.forward * zoom;\t\t\t\n        vec3 i \t\t= c + uv.x * cam.right + uv.y * cam.up;\t\t\n        r.direction = normalize(i - r.origin);                  \n    return r;\t\n}\n\n\nvoid resetRayHitDetails (inout rayHit rayHitDetails)\t\n{\n    rayHitDetails.dist\t\t\t\t\t\t=\tMAX_MARCHING_DIST;\n    rayHitDetails.normal\t\t\t\t\t=\tvec3(0.0);\n    rayHitDetails.material.metallic\t\t\t=\tfalse;\n    rayHitDetails.material.refractive\t\t=\tfalse;\n    rayHitDetails.material.albedo\t\t\t=\tvec3(0.0);\n    rayHitDetails.material.scatteringColor\t=\tvec3(0.0);\n\trayHitDetails.material.emissive\t\t\t=\t0.0;\n    rayHitDetails.material.IOR\t\t\t\t=\t1.0;\n    rayHitDetails.material.roughness\t\t=\t0.0;\t\n    rayHitDetails.material.scatteringWeight\t=\t0.0;\t\n}\n\n\nbool planeTrace(ray r, vec3 i0, vec3 i1, vec3 i2, inout rayHit rayHitDetails) \n{\n    vec3  n = normalize(cross((i1 - i0), (i2 - i0)));\n    vec3  p = vec3(0.0);  \t\t\t\t\t\t\t\t\t\n    float d = MIN_SURFACE_DIST;  \t\t\t\t\t\t\t\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n\t{\n        p = r.origin + r.direction * d;\n        vec3 v \t= abs(dot((p - i0), n)) * n;\n\n        if (length(v) > MIN_SURFACE_DIST || d < MAX_MARCHING_DIST)\t\n\t\t\td += length(v);\n        else\t\n\t\t\tbreak;\t\n\t}\n\n    if (d > rayHitDetails.dist\t|| \tp.x >  4.0\n\t\t\t\t\t\t\t\t||\tp.x < -4.0\n\t\t\t\t\t\t\t\t|| \tp.y >  5.0\n\t\t\t\t\t\t\t\t||\tp.y <  0.0        \n\t\t\t\t\t\t\t\t|| \tp.z >  5.0\n\t\t\t\t\t\t\t\t|| \tp.z < -7.0)\t\treturn false;\n\n    rayHitDetails.dist \t\t= d;\n    rayHitDetails.normal \t= n;\n    return true;\n}\n\n\nbool sphereTrace(ray r, vec4 sphere, inout rayHit rayHitDetails) \n{\n    float distToCenter \t= length(sphere.xyz - r.origin);\n    float radius\t\t= sphere.w - MIN_SURFACE_DIST;\n    float cosAlpha \t\t= sqrt(distToCenter*distToCenter - radius*radius) / distToCenter;\n\tfloat cosTheta\t\t= dot((sphere.xyz - r.origin), r.direction) / distToCenter;\n\n    if (cosTheta < cosAlpha && distToCenter > radius)\t\n\t\treturn false;\t\n\t\n    vec3  p = vec3(0.0);  \t\t\t\t\t\t\t\t\t\t\t\t\n    float d = MIN_SURFACE_DIST;  \t\t\t\t\t\t\t\t\t\t// distance to intersection\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) \n\t{ \n        p = r.origin + r.direction * d;\n        float distToSphere \t= abs(distance(sphere.xyz,p) - sphere.w);  \t// distance to sphere from P\n            \n        if (distToSphere > MIN_SURFACE_DIST && d < MAX_MARCHING_DIST)\t\n\t\t\td += distToSphere;\n        else\t\n\t\t\tbreak;\t\n\t}\n\n    if (d > rayHitDetails.dist)\t\t\n\t\treturn false;\n\n    rayHitDetails.dist\t\t= d;\n    rayHitDetails.normal \t= (p - sphere.xyz) / vec3(sphere.w);\n    \n    if (dot(r.direction, rayHitDetails.normal) > 0.0)\t\n\t\trayHitDetails.normal *= -1.0;\n\n\treturn true;\t\n}\n\n\n// trace scene objects\nvoid traceScene(ray r, inout rayHit rayHitDetails) \n{\n    resetRayHitDetails (rayHitDetails);\n\t\n/*    // sphere\n    if (sphereTrace(r, vec4(0, 3.0, -2.0, 0.75), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\t*/\t\n\n    // sphere\n    if (sphereTrace(r, vec4(1.5, 1.0, 0, 1.0), rayHitDetails))  \n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.45;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.5;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\t\t\t\n\n/*    // sphere\n    if (sphereTrace(r, vec4(-1.5, 1.0, 0, 1.0), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= true;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 8.0;\n        rayHitDetails.material.roughness\t\t= 0.1;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\t\t\n\n    // sphere\n    if (sphereTrace(r, vec4(0, 0.75, -2.5, 0.75), rayHitDetails)) \n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}       */\n\n/* */\n    // ceiling \n    if (planeTrace(r, \tvec3( 1, 4.99, -1),\n        \t\t\t\tvec3( 1, 4.99,  1),\n                   \t\tvec3(-1, 4.99,  1), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\t\t\n\n    \n    // floor \n    if (planeTrace(r, \tvec3(-1, 0.01,  1),\n        \t\t\t\tvec3( 1, 0.01,  1),\n                   \t\tvec3( 1, 0.01, -1), rayHitDetails))\t\n\t{\n \t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\n\t}\n\n    // back wall\n    if (planeTrace(r, \tvec3(-1,  1, 4.99),\n        \t\t\t\tvec3( 1,  1, 4.99),\n                   \t\tvec3( 1, -1, 4.99), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1.0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\t\n\t}\t\n\n   // left wall - red\n    if (planeTrace(r, \tvec3(-3.99, 1, -1),\n        \t\t\t\tvec3(-3.99, 1,  1),\n        \t\t\t\tvec3(-3.99, 0,  1), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(1, 0, 0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\t\n\t}\t\t\t\n\n    // right wall - green\n    if (planeTrace(r, \tvec3(3.99, 1, -1),\n        \t\t\t\tvec3(3.99, 0,  1),\n        \t\t\t\tvec3(3.99, 1,  1), rayHitDetails))\t\n\t{\n\t\trayHitDetails.material.metallic\t\t\t= false;\t\n\t\trayHitDetails.material.refractive\t\t= false;\n        rayHitDetails.material.IOR\t\t\t\t= 1.0;\n        rayHitDetails.material.roughness\t\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n        rayHitDetails.material.albedo \t\t\t= vec3(0, 1, 0);\t\n        rayHitDetails.material.scatteringColor\t= vec3(1.0);\t\t\n\t}\t\t\n\n\n    // emissive sphere lights\n\tlight sphereLight1 = makeLight(\tvec3(0.0, 2.0, 1.5),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvec3(  1, .5, .1), \t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t10.0,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t0.85);\n\tif (sphereTrace(r, vec4(sphereLight1.position, sphereLight1.radius), rayHitDetails)) \n\t{\n\t\trayHitDetails.material.metallic\t\t= false;\n\t\trayHitDetails.material.refractive\t= false;\n\t\trayHitDetails.material.IOR\t\t\t= 1.0;\n\t\trayHitDetails.material.roughness\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n\t\trayHitDetails.material.scatteringColor = vec3(0.0);\n\t\trayHitDetails.material.albedo \t\t= sphereLight1.color;\n\t\trayHitDetails.material.emissive \t= sphereLight1.intensity;\n\t\tif (rayHitDetails.material.emissive > 0.0)\n\t\t\trayHitDetails.material.albedo = sphereLight1.color * sphereLight1.intensity;\t\n\t}\n\n/*\tlight sphereLight2 = makeLight(\tvec3( -2.0, 1.5, -2.2),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvec3(  .1, .5,  1),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t10.0,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t0.3);\n\tif (sphereTrace(r, vec4(sphereLight2.position, sphereLight2.radius), rayHitDetails)) \n\t{\n\t\trayHitDetails.material.metallic\t\t= false;\n        rayHitDetails.material.refractive\t= false;\n        rayHitDetails.material.IOR\t\t\t= 1.0;\n        rayHitDetails.material.roughness\t= 0.0;\n        rayHitDetails.material.scatteringWeight\t= 0.0;\n\t\trayHitDetails.material.scatteringColor = vec3(0.0);\n        rayHitDetails.material.albedo \t\t= sphereLight2.color;\n        rayHitDetails.material.emissive \t= sphereLight2.intensity;\n        if (rayHitDetails.material.emissive > 0.0)\n\t\t\trayHitDetails.material.albedo = sphereLight2.color * sphereLight2.intensity;\t\n\t}\t\t\t*/\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n}\n\n\nvec3 translateToWS(vec3 direction, vec3 normal)\t\n{\n\tvec3  right, forward;\n\n    if (abs(normal.x) > abs(normal.y))\t\t\n\t\tright \t= vec3(normal.z, 0.0, -normal.x) / sqrt(normal.x*normal.x + normal.z*normal.z);        \n\telse        \t\t\t\t\t\t\t\n\t\tright \t= vec3(0.0, -normal.z, normal.y) / sqrt(normal.y*normal.y + normal.z*normal.z);  \n\t\tforward = cross(normal, right);\t\t\t\n    \n    return vec3(direction.x * forward.x + direction.y * normal.x + direction.z * right.x,\n\t\t\t\tdirection.x * forward.y + direction.y * normal.y + direction.z * right.y,\n\t\t\t\tdirection.x * forward.z + direction.y * normal.z + direction.z * right.z);\t\n}\n\n\nvec3 getRandomDirection (vec2 seed) \n{\n\tfloat cosTheta\t= sqrt(1.0-randFloat(seed.xy)); \t\t// cosine weighted distribution   \n\tfloat sinTheta\t= sqrt(max(1.0 - cosTheta*cosTheta, 0.0));\n    float phi \t\t= randFloat(seed.yx) * 2.0 * Pi;\n\n    return vec3(cos(phi) * sinTheta, cosTheta, sin(phi) * sinTheta);\t\n}\n\n\nvec3 getLightSampleDirection (vec2 seed, light l, vec3 p) \n{\n\tvec3  direction \t= getRandomDirection(seed + randFloat(seed));\n    direction = normalize(translateToWS(direction, normalize(l.position - p)));\n   \n    float distToCenter \t= length(l.position - p);\n    float radius\t\t= l.radius-MIN_SURFACE_DIST;\n    float cosAlpha \t\t= sqrt(distToCenter*distToCenter - radius*radius) / distToCenter;\n\tfloat cosTheta\t\t= dot((p - l.position), direction) / distToCenter;\n\n    if (cosTheta < cosAlpha)\t\t\t\n\t\treturn direction;\n}\n\n\nfloat getFresnel (ray incomingRay, inout rayHit rayHitDetails)\t\n{\n\tfloat cosTheta1 = dot(normalize(-incomingRay.direction*rayHitDetails.dist), rayHitDetails.normal);\n    float cosTheta2 = sqrt ( 1.0 - (( 1.0 - (cosTheta1 * cosTheta1) ) / (rayHitDetails.material.IOR * rayHitDetails.material.IOR) ));\t\t\t\t\t\t\t\t\t\t\t\t\t\n    float ratio1 = ((cosTheta1 - rayHitDetails.material.IOR * cosTheta2) / (rayHitDetails.material.IOR * cosTheta2 + cosTheta1));\n    float ratio2 = ((rayHitDetails.material.IOR * cosTheta1 - cosTheta2) / (rayHitDetails.material.IOR * cosTheta1 + cosTheta2));        \n    \n\treturn ((ratio1 * ratio1) + (ratio2 * ratio2)) / 2.0;\t\n}\n\n\nfloat specBRDF(ray incomingRay, ray sampleRay, inout rayHit rayHitDetails)\n{\n\tvec3 V \t\t\t= incomingRay.direction;\t// view vector\n    vec3 L \t\t\t= sampleRay.direction;\t\t// light vector\n    vec3 N \t\t\t= rayHitDetails.normal;\t\t// normal\n    vec3 T \t\t\t= cross(vec3(0,1,0), N);\t// tangent\n    vec3 B \t\t\t= cross(N, T);\t\t\t\t// bitangent\n    vec3 H \t\t\t= L + V / length(L+V);\t\t// half vector\n\n    float NdotV\t\t= max(dot(N, V), 0.0);\n    float NdotL\t\t= max(dot(N, L), 0.0);\n    float NdotH\t\t= max(dot(N, H), 0.0);\n    \n    float sinThetaH = length(cross(N, H)) / (length(N) * length(H));\n    float rSquared\t= rayHitDetails.material.roughness * rayHitDetails.material.roughness;\n\tfloat C \t\t= 1.0;\n    \n    float\tdTerm = C / (rSquared * NdotH*NdotH + sinThetaH*sinThetaH)*(rSquared * NdotH*NdotH + sinThetaH*sinThetaH); // TR/GGX\n    float\tfTerm = getFresnel(incomingRay, rayHitDetails); \n    \n    // Smith GGX\n    float\tgTerm = (4.0 * NdotL * NdotV) / (NdotL + sqrt(rSquared + (1.0 - rSquared)*NdotL*NdotL)) * (NdotV + sqrt(rSquared + (1.0 - rSquared)*NdotV*NdotV));\n        \n    return dTerm * fTerm * gTerm;\n}\n\n\nvec3 T(float s) \n{\n\treturn\tvec3(0.233, 0.455, 0.649) * exp(-s*s/0.0064) +\n\t\t\tvec3(  0.1, 0.336, 0.344) * exp(-s*s/0.0484) +\n\t\t\tvec3(0.118, 0.198,   0.0) * exp(-s*s/0.187) +\n\t\t\tvec3(0.113, 0.007, 0.007) * exp(-s*s/0.567) +\n\t\t\tvec3(0.358, 0.004,   0.0) * exp(-s*s/1.99) +\n\t\t\tvec3(0.078,   0.0,   0.0) * exp(-s*s/7.41);\n}\n\n\nvec3 getScattering (ray incomingRay, vec2 uv, light[2] lightList, inout rayHit rayHitDetails)\n{\n\tvec3  scatColor\t\t= rayHitDetails.material.scatteringColor;\n\tvec3  p\t\t\t\t= incomingRay.origin + incomingRay.direction*rayHitDetails.dist;\n\tfloat scatWeight\t= rayHitDetails.material.scatteringWeight;\t\n\tfloat scale\t\t\t= 2.0;\n\n    // nudge sample ray origin inside object, along the hit normal * delta\n\tvec3 p1\t\t\t\t= p - rayHitDetails.normal*0.005;\n\tvec3 scatSampleVector = getLightSampleDirection((uv), lightList[0], p1);\n\n    ray scatSampleRay \t= ray(p1, scatSampleVector);\n\ttraceScene(scatSampleRay, rayHitDetails);\t\t\n    \n\tfloat d = rayHitDetails.dist; // distance a potential light ray travels through the object\n    vec3  n1 = -rayHitDetails.normal;\n    \n    scatSampleRay.origin = p1 + scatSampleVector*d;\n    traceScene(scatSampleRay, rayHitDetails);\n\n    float d1 = rayHitDetails.dist; // distance to light\n    \n    if (rayHitDetails.material.emissive > 0.0)\n    {\n        float s = scale * d;\n        float E = max(0.3 + (dot(scatSampleVector, n1)), 0.0);\n\n        return T(s) * E * rayHitDetails.material.albedo * scatColor / d1 * d1 ;\n    }\n}\n\n\n\nvec3 getCaustics(ray incomingRay, vec2 uv, inout rayHit rayHitDetails)\t\n{\n    vec3  albedo \t\t\t\t\t\t\t= rayHitDetails.material.albedo;\n    vec3  totalRefraction, refractionVector\t= vec3(0.0);\n    float incomingIOR\t\t\t \t\t\t= 1.0;\n    float outgoingIOR\t\t\t\t\t\t= rayHitDetails.material.IOR;\n    float IORratio\t\t\t\t\t\t\t= incomingIOR/outgoingIOR;    \n\tvec3  p\t\t\t\t\t\t\t\t\t= (incomingRay.direction*rayHitDetails.dist + incomingRay.origin) - (rayHitDetails.normal * 0.001);\n\n    for (int i = 0; i < REFRACTION_DEPTH; i++)\t\n\t{\n        refractionVector = refract(incomingRay.direction, rayHitDetails.normal, IORratio);\t\n        ray refractionRay = ray (p, refractionVector);\n\n        traceScene (refractionRay, rayHitDetails);\t\t\n\n        if (rayHitDetails.material.refractive)\t\t\t\n\t\t{\t\n\t\t\tincomingRay = refractionRay;\t\n            p = ((refractionRay.direction*rayHitDetails.dist) + refractionRay.origin) - (rayHitDetails.normal * MIN_SURFACE_DIST);\t\n            IORratio = rayHitDetails.material.IOR;\tcontinue;\t\n\t\t}\n\n        if (rayHitDetails.material.emissive > 0.0)\t\t\n\t\t\treturn albedo * rayHitDetails.material.albedo;\n\t\tif (rayHitDetails.dist == MAX_MARCHING_DIST)\n\t\t\treturn albedo * texture(iChannel1, refractionRay.direction).rgb;\n    }\n}\n\n\n\nvec3 getDiffuse (ray incomingRay, vec2 uv, light[2] lightList, inout rayHit rayHitDetails)\t\n{\n\tvec3 \tindirectDiffuse, directDiffuse\t\t= vec3(0.0);                \n    vec3 \tnormal \t\t\t\t\t\t\t\t= rayHitDetails.normal;\n    vec3 \talbedo \t\t\t\t\t\t\t\t= rayHitDetails.material.albedo;\n    vec3\tp\t\t\t\t\t\t\t\t\t= incomingRay.direction*rayHitDetails.dist + incomingRay.origin;\n\tfloat \tfresnel \t\t\t\t\t\t\t= getFresnel(incomingRay, rayHitDetails);    \n\n    ray sampleRay \t= ray(p, translateToWS(getRandomDirection(uv), normal));\n    if (sampleRay.direction == normal)\t\n\t\treturn vec3(0);\t// reject samples aligned with surface normal\t\n    \n\tfloat NdotL = dot(normal, sampleRay.direction);\t// cosine term\n\n    traceScene (sampleRay, rayHitDetails);\t\n    \t\t\t\t\t\t\t\t\t\t\t\n\tif (rayHitDetails.dist == MAX_MARCHING_DIST)\t\n\t\t\treturn albedo * texture(iChannel1, sampleRay.direction).rgb * NdotL;\t\t\n\tif (rayHitDetails.material.emissive > 0.0)\t\t\n\t\treturn albedo * rayHitDetails.material.albedo * NdotL;\n\tif (rayHitDetails.material.refractive)\t\t\t\n\t\treturn albedo * getCaustics(sampleRay, uv, rayHitDetails) * NdotL; // only calculate caustics on the first bounce, shit's expensive\n\tif (DIFFUSE_BOUNCES > 1)\t\n\t{\n        vec3 indirectAlbedo = vec3(1.0);\n\n        for (int i = 1; i < DIFFUSE_BOUNCES; i++)\t\n\t\t{\n            normal\t\t\t= rayHitDetails.normal;\t\n            indirectAlbedo \t*= rayHitDetails.material.albedo;\n            p\t\t\t\t= sampleRay.direction*rayHitDetails.dist + sampleRay.origin;\n            sampleRay \t\t= ray(p, translateToWS(getRandomDirection(uv + randFloat(uv)), normal));\n            NdotL\t\t\t= dot(normal, sampleRay.direction);\t// cosine term\n\n            traceScene (sampleRay, rayHitDetails);\n\n            if (rayHitDetails.dist == MAX_MARCHING_DIST)\t\n\t\t\t{\t\n\t\t\t\tindirectDiffuse += indirectAlbedo * texture(iChannel1, sampleRay.direction).rgb * NdotL; \n\t\t\t\tbreak;\t\n\t\t\t}\t \n            if (rayHitDetails.material.emissive > 0.0)\t\t\n\t\t\t{\t\n\t\t\t\tindirectDiffuse += indirectAlbedo * rayHitDetails.material.albedo * NdotL; \n\t\t\t\tbreak;\t\n\t\t\t}\n        }      \n\t}\n    return albedo * indirectDiffuse * (1.0-fresnel);\t\n}    \n\n\n\nvec3 getSpecular (ray incomingRay, vec2 uv, light[2] lightList, inout rayHit rayHitDetails)\t\n{\n\tvec3 albedo \t\t= vec3(1.0);\n    float fresnel \t\t= getFresnel(incomingRay, rayHitDetails); \n    vec3 reflVector \t= reflect (incomingRay.direction, rayHitDetails.normal);\n    \n    ray reflectionRay \t= ray((incomingRay.origin + incomingRay.direction*rayHitDetails.dist), normalize(reflVector));\n\n    traceScene (reflectionRay, rayHitDetails);\n\n    if (rayHitDetails.dist == MAX_MARCHING_DIST)    \n\t\treturn albedo * texture(iChannel1, reflectionRay.direction).rgb * fresnel;\t\t\n    if (rayHitDetails.material.emissive > 0.0)    \t\n\t\treturn albedo * rayHitDetails.material.albedo * fresnel;\n    else\t\t\t\t\t\t\t\t\t\t\t\n\t\treturn albedo * getDiffuse (reflectionRay, uv, lightList, rayHitDetails) * fresnel;\n}\n\n\n\nvec3 getReflection (ray incomingRay, vec2 uv, light[2] lightList, inout rayHit rayHitDetails)\t\n{\n\tvec3 albedo \t\t= vec3(1.0);\n    \n    if (rayHitDetails.material.metallic)\t\n\t\talbedo = rayHitDetails.material.albedo;\t// if the object is metallic, color the reflection by it's albedo\n    \n    vec3 reflVector \t= (incomingRay.direction * rayHitDetails.dist) - 2.0*(dot((incomingRay.direction * rayHitDetails.dist), rayHitDetails.normal)) * rayHitDetails.normal;\n     \n    ray reflectionRay \t= ray((incomingRay.origin + incomingRay.direction*rayHitDetails.dist), normalize(reflVector));\n\n    traceScene (reflectionRay, rayHitDetails);\n\n    if (rayHitDetails.dist == MAX_MARCHING_DIST)    \n\t\treturn albedo * texture(iChannel1, reflectionRay.direction).rgb;\t\t\n    if (rayHitDetails.material.emissive > 0.0)    \t\n\t\treturn albedo * rayHitDetails.material.albedo;\n    else\t\t\t\t\t\t\t\t\t\t\t\n\t\treturn albedo * getDiffuse (reflectionRay, uv, lightList, rayHitDetails);\t\n}\n\n\nvec3 getRefraction (ray incomingRay, vec2 uv, light[2] lightList, inout rayHit rayHitDetails)\t\n{   \n    vec3  albedo \t\t\t\t\t\t\t= rayHitDetails.material.albedo;\n    vec3  totalRefraction, refractionVector\t= vec3(0.0);\n    float incomingIOR\t\t\t \t\t\t= 1.0;\n    float outgoingIOR\t\t\t\t\t\t= rayHitDetails.material.IOR;\n    float IORratio\t\t\t\t\t\t\t= incomingIOR/outgoingIOR;    \n\tvec3  p\t\t\t\t\t\t\t\t\t= (incomingRay.direction*rayHitDetails.dist + incomingRay.origin) - (rayHitDetails.normal * 0.001);\n\n    for (int i = 0; i < REFRACTION_DEPTH; i++)\t\n\t{\n        refractionVector \t\t\t= refract(incomingRay.direction, rayHitDetails.normal, IORratio);\t\n        ray refractionRay \t\t\t= ray (p, refractionVector);\n\n        traceScene (refractionRay, rayHitDetails);\t\t\n        rayHit reflectionHitDetails =\trayHitDetails;\n        float fresnel \t\t\t\t=\tgetFresnel(refractionRay, rayHitDetails);\n\n        if (rayHitDetails.material.refractive)\t\t\t\n\t\t{\t\n\t\t\tincomingRay = refractionRay;\t\n            p = ((refractionRay.direction*rayHitDetails.dist) + refractionRay.origin) - (rayHitDetails.normal * MIN_SURFACE_DIST);\t\n            IORratio = rayHitDetails.material.IOR;\t\n\t\t\tcontinue;\t\n\t\t}\n        if (rayHitDetails.dist == MAX_MARCHING_DIST)\t\n\t\t\treturn albedo * texture(iChannel1, refractionRay.direction).rgb;\n        if (rayHitDetails.material.emissive > 0.0)\t\t\n\t\t\treturn albedo * rayHitDetails.material.albedo;\n        if (rayHitDetails.material.metallic)\t\t\t\n\t\t\treturn albedo * fresnel * getReflection(refractionRay, uv, lightList, reflectionHitDetails);\n        else\t\t\t\t\t\t\t\t\t\t\t\n\t\t\treturn albedo * (1.0-fresnel) * getDiffuse(refractionRay, uv, lightList, rayHitDetails) \n            \t\t\t\t\t+ fresnel * getReflection(refractionRay, uv, lightList, reflectionHitDetails);\t \n    }\n}\n\n\nvec3 getPixelColor (ray cameraRay, vec2 uv, light[2] lightList) \n{\n\tvec3 pixelColor = vec3(0.0);\n    vec3 scattering\t= vec3(0.0);\n    vec3 diffuse\t= vec3(0.0);\n    vec3 specular\t= vec3(0.0);\n    \n    rayHit rayHitDetails, reflectionHitDetails, scatteringHitDetails, specHitDetails;\n\n    for (int i = 0; i < PIXEL_SAMPLES; i++)\t\n\t{\n        traceScene (cameraRay, rayHitDetails);\n\t\tfloat fresnel \t= getFresnel(cameraRay, rayHitDetails); \n\t\tfloat sw \t\t= rayHitDetails.material.scatteringWeight;\n            \n\t\treflectionHitDetails = scatteringHitDetails = specHitDetails = rayHitDetails;\n        \n        if (rayHitDetails.dist == MAX_MARCHING_DIST)\t\n\t\t\treturn \ttexture(iChannel1, cameraRay.direction).rgb;\n        if (rayHitDetails.material.emissive > 0.0)\t\t\n\t\t\treturn \trayHitDetails.material.albedo;\n        if (rayHitDetails.material.metallic)\t\t\t\n\t\t\treturn \tfresnel * getReflection(cameraRay, uv, lightList, reflectionHitDetails);\n        if (rayHitDetails.material.refractive)\t\t\t\n\t\t\treturn\t(1.0-fresnel) * getRefraction(cameraRay, uv, lightList, rayHitDetails) \n            \t\t\t+ fresnel * getReflection(cameraRay, uv, lightList, reflectionHitDetails);\n\t\telse\n        {\n            diffuse \t= getDiffuse(cameraRay, uv, lightList, rayHitDetails);\n            if (sw > 0.0)\t\t\t\n\t\t\tscattering \t= sw * getScattering(cameraRay, uv, lightList, scatteringHitDetails);\n            specular \t= getSpecular(cameraRay, uv, lightList, reflectionHitDetails);\n        \n            pixelColor += \tdiffuse + specular + scattering;\t\n        }\n    }\n\treturn pixelColor / vec3(PIXEL_SAMPLES);\t\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\t\n{\n    vec2 uv \t\t\t= fragCoord / iResolution.xy - 0.49;      \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 mouseCoords \t= iMouse.xy / iResolution.xy - 0.49;\t\t// Normalized mouse coordinates \n    float resRatio \t\t= iResolution.x / iResolution.y;       \t\t// screeen aspect ratio\n    vec4 prevBuffer\t\t= texture(iChannel0, fragCoord / iResolution.xy);\t\n    vec3 drawBuffer\t\t= vec3(0);\n    mouseCoords.x \t\t*= resRatio;\n    uv.x \t\t\t\t*= resRatio;                                 \n    camera cam \t\t\t= makeCamera(vec3(0, 0, -4), vec3(0, 0, -3));\t\t\t\t\t\t\t\t\t\t\t\t\n\n    cam.position \t\t= vec3(-sin(mouseCoords.x) * 4.0, \n                               -sin(mouseCoords.y) * 4.0 + 2.0, \n                               -cos(mouseCoords.x) * 8.0 + 2.0);\n    \n\tlight sphereLight1 = makeLight( vec3(0.0, 2.0, 1.5),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvec3(  1, .5, .1), \t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t3.0,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t0.75);\n\n\tlight sphereLight2 = makeLight(\tvec3( -2.0, 1.5, -2.2),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvec3(  .1, .5,  1),\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t3.5,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t0.3);\n\t\n\tlight[] lightList = light[](sphereLight1, sphereLight2);\n\t\n    ray  cameraRay \t\t= getCameraRay(uv, cam, 1.0);\n    drawBuffer \t\t\t= getPixelColor(cameraRay, uv, lightList);\n    float tAlpha\t\t= prevBuffer.w + 1.0;\n\n    if (iMouse.z > 0.0)\t\n\t\ttAlpha = 1.0;\n\n    fragColor = vec4(mix(drawBuffer, prevBuffer.rgb, (1.0-1.0/tAlpha)), tAlpha);\t\t\n}","name":"Buffer A","description":"","type":"buffer"}]}