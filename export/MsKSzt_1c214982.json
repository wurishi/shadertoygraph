{"ver":"0.1","info":{"id":"MsKSzt","date":"1466145403","viewed":136,"name":"More Gears","username":"akohdr","description":"couple of variations from Fab's hex tiled gears.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","gears"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// couple of golfed variations of gears\n// original: https://www.shadertoy.com/view/lsKSRt\n\nvoid gears5( out vec4 k, vec2 p )\n{\n     \tp *= 3./iResolution.y * mat2(.9,-.5, 0,1);\n    vec4 g = fract(k=vec4(++p,p));\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n    k *= min(k.x=length(p),\n             min(fract(g.x=( k.x/.2 - .15*sin(28.*(atan(p.y,p.x) - iDate.w*sign(g.z))) )),\n             \t cos(g.x)));\n}\n\nvoid gears4a( out vec4 k, vec2 p )\n{ \n     \t p *= 2./iResolution.y * mat2(.9,-.5, 0,1);\n    vec4 g = fract(k=vec4(p,p.yxxy));\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n    k *= fract( length(p)/.27 - \n        .1*sin(24.*(atan(p.y,p.x) - iDate.w*sign(g.z))) );\n}\n\nvoid gears4( out vec4 k, vec2 p )\n{ \n     \t p *= 3./iResolution.y * mat2(.9,-.5, 0,1);\n    vec4 g = fract(k=vec4(p,p));\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n    k *= fract( length(p)/.27 - \n        .1*sin(24.*(atan(p.y,p.x) - iDate.w*sign(g.z))) );\n}\n\nvoid gears3( out vec4 k, vec2 p )\n{ \n     \t p *= 6./iResolution.y * mat2(.9,-.5, 0,1);\n    vec4 g = fract(k=vec4(p, 1.-p.x-p.y,0));\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n    k *= fract(\n        length(p)/.27 - \n        .1*sin(12.*(atan(p.y,p.x) - iDate.w*sign(g.z))) \n         );\n}\n    \n\nvoid gears2( out vec4 k, vec2 p )\n{ \n     \t p *= 6./iResolution.y * mat2(.9,-.5, 0,1);\n    vec4 g = fract(k=vec4(p, 1.-p.x-p.y,0));\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n    k *= sin(\n        length(p)/.3 - .8 - \n        .1*sin(12.*(atan(p.y,p.x) - iDate.w*sign(g.z))) \n         );\n}\n    \n\nvoid gears1a( out vec4 k, vec2 p )\n{ \n     \t p *= 4./iResolution.y * mat2(.9,-.5, 0,1);\n    vec4 g = fract(k=vec4(p, 1.-p.x-p.y,0));\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n//    k = mod(ceil(k),.8) * step(\n    k = sin(k*.5) * step(\t\t\t// 249 \n//    k *= step(\t\t\t\t\t// 240 with alt colours\n        length(p)/.3 - .9 - \n        .1*sin(15.*(atan(p.y,p.x) - iDate.w*sign(g.z))) \n        ,.01 );\n}\n\nvoid gears1( out vec4 k, vec2 p )\n{ \n     \t p *= 4./iResolution.y * mat2(.9,-.5, 0,1);\n    vec4 g = fract(k=vec4(p, 1.-p.x-p.y,0));\n       g.z = 1.-g.x-g.y; \n    \t p = (g.xy-ceil(1.-g.z)/3.)* mat2(1,.5, 0,.9);\n    k *= step(\t\t\t\t\t// 240 with alt colours\n        length(p)/.3 - .9 - \n        .1*sin(15.*(atan(p.y,p.x) - iDate.w*sign(g.z))) \n        ,.01 );\n}\n\n    \n/* original https://www.shadertoy.com/view/lsKSRt */\nvoid gears( out vec4 O, vec2 U )\n{ \n    vec2 R = iResolution.xy;\n         U = (U-R/2.)/R.y * 6.;                           // centered coords\n    \n    U *= mat2(1.73/2.,-.5, 0,1);                          // conversion to\n    vec3 g = vec3(U, 1.-U.x-U.y),                         // hexagonal coordinates\n        id = floor(g);                                    // cell id\n    \n    g = fract(g); g.z = 1.-g.x-g.y;                       // triangle coords    \n    U = (g.xy-ceil(1.-g.z)/3.) * mat2(1,.5, 0,1.73/2.);   // screenspace local coords (centered)\n    float r = length(U)/(1.73/2.)*3., // discs r=1 in contact     // to polar coords\n          a = atan(U.y,U.x) - iTime*sign(g.z); \n\n        //anti-aliasing    // gears pattern      // color per cell-id\n    O = smoothstep(.07,.0, r-.9 -.1*sin(15.*a) ) *(1.+mod(id,3.).xyzx)/4. +O-O; \n}\n    \n// cycle macros automatically count declared TX() then cycle every dt secs\n#define CYCLE(b) float ct,i=-1.,m=1.;b;i++;ct=mod(iDate.w,(m-1.)*dt);b;\n#define TX(n) if(i<0.) m++; else if(ct<mod(++i,m)*dt){n(k,p);return;}\n\nvoid mainImage( out vec4 k, vec2 p )\n{ \n//    gears5(k,p);return;\n    \n    float dt = 2.;\n    \n    CYCLE(\n    \tTX(gears5)\n    \tTX(gears4a)\n    \tTX(gears4)\n    \tTX(gears3)\n    \tTX(gears2)\n    \tTX(gears1a)\n    \tTX(gears1)\n    \tTX(gears)\n    )\n}\n","name":"Image","description":"","type":"image"}]}