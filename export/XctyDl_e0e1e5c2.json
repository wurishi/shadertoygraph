{"ver":"0.1","info":{"id":"XctyDl","date":"1731343662","viewed":34,"name":"Simple Voronoi shader test ","username":"asfaloth","description":"Simple fragment shader to color Voronoi regions","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 random_color(vec2 seed){\n    // Generates a pseudorandom color using a seed.\n    // When the frequency is low enough, the regions will have similar colors (try with 0.3)\n   float frequency = 2.0;\n   return vec3(0.5 + 0.5*sin(frequency*seed), cos(frequency*(seed.x+seed.y)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float zoom = 1.0;\n    vec2 uv = 2.0/zoom * (fragCoord - 0.5 * iResolution.xy) / iResolution.y; \n    // scaling the axes to make the centre of the screen have uv (0, 0)\n    \n\n    vec2 moving_point_pos = vec2(sin(0.1*iTime), cos(0.4*iTime));\n    int num_points = 10;\n    \n    vec2 voronoi_points[10] = vec2[10](\n        moving_point_pos,\n        vec2(0,0.5),\n        vec2(0.75,0.25),\n        vec2(0.9, 0.1),\n        vec2(-0.1, 0.3),\n        vec2(-0.3, 0.1),\n        vec2(-0.4, -0.2),\n        vec2(0.8, -0.1),\n        vec2(0.1, 0.1),\n        vec2(0.2, 0.5)\n    );\n    \n    float min_distance = distance(uv, voronoi_points[0]);\n    float point_distance;\n    vec2 closest_point = voronoi_points[0];\n    \n    for (int i = 1; i<num_points; i++){\n        point_distance = distance(uv, voronoi_points[i]);\n        if (point_distance < min_distance){\n            min_distance = point_distance;\n            closest_point = voronoi_points[i];\n        }\n    \n    }\n\n    vec3 col = step(0.01, distance(voronoi_points[0], closest_point)) \n    // returns 0 if the pixel is in the region of the moving point (to avoid sudden color change).\n                * random_color(closest_point) \n                // Generates a pseudorandom color depending on the closest point's position.\n                // This ensures that all of the pixels in the same region have the same color.\n                + 2.0 * step(min_distance, 0.025); \n                // Colors the pixel white if it is close enough to a point.\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}