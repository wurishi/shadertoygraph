{"ver":"0.1","info":{"id":"4s3GW8","date":"1449154572","viewed":279,"name":"[Test] Winding number","username":"Ultraviolet","description":"this shader computes the winding numbers.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["testpolygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926536;\n\n\nvoid BoxReflect(inout float p, in float bbmin, in float bbmax)\n{\n    p = bbmin + mod(p-bbmin, 2.0*(bbmax - bbmin));\n    if(p > bbmax)\n    \tp = bbmax - (p - bbmax);\n    \n}\n\nvoid BoxReflect(inout vec2 p, in vec2 bbmin, in vec2 bbmax)\n{\n    BoxReflect(p.x, bbmin.x, bbmax.x);\n    BoxReflect(p.y, bbmin.y, bbmax.y);\n}\n\n\nvec2 normal(vec2 p0, vec2 p1)\n{\n    vec2 diff = p1 - p0;\n    return vec2(-diff.y, diff.x);\n}\n\nfloat PointSegDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    float s = 1.0;//sign(dot(p-p0, normal(p0, p1)));\n    vec2 d = p1 - p0;\n    \n    float t = dot(p - p0, d) / dot(d, d);\n\n    if(t > 1.0)\n        return length(p1 - p) * s;\n    if(t < 0.0)\n        return length(p0 - p) * s;\n\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return length(proj-p) * s;\n}\n\nfloat angle(vec2 p)\n{\n    return atan(p.y, p.x);\n}\n\nfloat angle(vec2 p0, vec2 p1)\n{\n    float a =  angle(p1) - angle(p0);\n    a = mod(a-PI, 2.*PI)-PI;\n    \n    return a;\n}\n\nfloat Winding(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float winding = 0.0;\n    \n    winding += angle(p0-p, p1-p);\n    winding += angle(p1-p, p2-p);\n    winding += angle(p2-p, p3-p);\n    winding += angle(p3-p, p0-p);\n    \n    return winding;\n    \n}\n    \nfloat PointPolyDistance(vec2 p, vec2 p0, vec2 p1, vec2 p2, vec2 p3)\n{\n    float d = PointSegDistance(p, p0, p1);\n    d = min(d, PointSegDistance(p, p1, p2));\n    d = min(d, PointSegDistance(p, p2, p3));\n    d = min(d, PointSegDistance(p, p3, p0));\n\n    \n    float s = 1.0;\n    \n    if(Winding(p, p0, p1, p2, p3) > 0.5)\n        s = -1.0;\n    \n    return d * s;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec2 p0 = vec2(0.5, 0.5); p0 = p0 + p0*iTime*0.5; BoxReflect(p0, vec2(0.0), vec2(ratio, 1.0));\n    vec2 p1 = vec2(1.0, 0.2); p1 = p1 + p1*iTime*0.5; BoxReflect(p1, vec2(0.0), vec2(ratio, 1.0));\n    vec2 p2 = vec2(0.6, 0.8); p2 = p2 + p2*iTime*0.5; BoxReflect(p2, vec2(0.0), vec2(ratio, 1.0));\n    vec2 p3 = vec2(1.2, 0.9); p3 = p3 + p3*iTime*0.5; BoxReflect(p3, vec2(0.0), vec2(ratio, 1.0));\n    float d = Winding(uv, p0, p1, p2, p3);\n    \n\tfragColor = vec4(max(d, 0.0), max(-d, 0.0), 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}