{"ver":"0.1","info":{"id":"WljfDw","date":"1599086054","viewed":151,"name":"Minimalism #10","username":"Flopine","description":"Tenth piece of a shader serie about minimalism, how to do small and quick artwork that are about composition and animation.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","isometric","minimalist","daily"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define ITER 100.\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define box(p,c) (min(0.,max((abs(p)-c).x,max((abs(p)-c).y,(abs(p)-c).z)))+length(max(abs(p)-c,0.)))\n#define sphere(p,r) (length(p)-r)\n#define getnorm(p,eps) normalize(SDF(p).dist-vec3(SDF(p-eps.xyy).dist,SDF(p-eps.yxy).dist,SDF(p-eps.yyx).dist))\n\n#define time(speed) fract(iTime*speed)\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define replimit(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n#define hash21(x) fract(sin(dot(x,vec2(14.5,34.4)))*454.4)\n\nstruct obj \n{\n    float dist;\n    int mat;\n};\n\nobj minobj (obj a, obj b) \n{\n    if (a.dist < b.dist) return a;\n    else return b;\n}\n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-1./sqrt(2.));\n    p.xz *= rot(PI/4.);\n\n    float per = 3.;\n    float numrep = 3.;\n    vec2 id = floor((p.xz-per*0.5)/per);\n    replimit(p.xz, per, numrep);\n\n    if (hash21(id+time(0.00001)) <= 0.5) \n    {\n        return obj(box(p,vec3(.8)),1);\n    }\n    else \n    {\n        p.xz *= rot(time(0.1+length(id*2.))*TAU);\n        p.xy *= rot(PI/8.);\n        return obj(sphere(p,0.9),2);\n    } \n}\n\nfloat spec (vec3 rd, vec3 l, vec3 n, float specpow)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h),0.),specpow);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n    \n    vec3 ro = vec3(uv*5.,-50.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = vec3(1.,2.,-3.),\n        col = vec3(0.);\n\n    bool hit = false;\n    float shad = 0.;\n    obj scene;\n    vec3 n;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        scene = SDF(p);\n        if (scene.dist < 0.01)\n        {\n            hit = true;\n            n = getnorm(p,vec2(0.05,0.));\n            if (scene.mat == 2)\n            {\n                rd = normalize(reflect(rd,n));\n                p += 0.05*rd;\n            }\n            else break;\n        }\n        scene.dist *= 0.9+dither*0.01;\n        p += scene.dist*rd;\n    }\n\n    if (hit)\n    {\n        if (scene.mat == 1) col = mix(vec3(0.1,0.,0.2),vec3(0.5,0.8,0.9),max(dot(n,normalize(l)),0.));\n        if (scene.mat == 2) col = vec3(0.85,1.,0.9)+spec(rd,l,n,20.)*0.5;\n    }\n\n    fragColor = vec4(sqrt(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}