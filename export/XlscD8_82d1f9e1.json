{"ver":"0.1","info":{"id":"XlscD8","date":"1504621519","viewed":823,"name":"MD5","username":"rory618","description":"Maybe a bit overboard when it comes to quick random numbers for a shader.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["hash","md5"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int[] s = int[](7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n                      5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n                      4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n                      6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21);\n\nconst uint[] K = uint[](0xd76aa478u, 0xe8c7b756u, 0x242070dbu, 0xc1bdceeeu,\n                        0xf57c0fafu, 0x4787c62au, 0xa8304613u, 0xfd469501u,\n                        0x698098d8u, 0x8b44f7afu, 0xffff5bb1u, 0x895cd7beu,\n                        0x6b901122u, 0xfd987193u, 0xa679438eu, 0x49b40821u,\n                        0xf61e2562u, 0xc040b340u, 0x265e5a51u, 0xe9b6c7aau,\n                        0xd62f105du, 0x02441453u, 0xd8a1e681u, 0xe7d3fbc8u,\n                        0x21e1cde6u, 0xc33707d6u, 0xf4d50d87u, 0x455a14edu,\n                        0xa9e3e905u, 0xfcefa3f8u, 0x676f02d9u, 0x8d2a4c8au,\n                        0xfffa3942u, 0x8771f681u, 0x6d9d6122u, 0xfde5380cu,\n                        0xa4beea44u, 0x4bdecfa9u, 0xf6bb4b60u, 0xbebfbc70u,\n                        0x289b7ec6u, 0xeaa127fau, 0xd4ef3085u, 0x04881d05u,\n                        0xd9d4d039u, 0xe6db99e5u, 0x1fa27cf8u, 0xc4ac5665u,\n                        0xf4292244u, 0x432aff97u, 0xab9423a7u, 0xfc93a039u,\n                        0x655b59c3u, 0x8f0ccc92u, 0xffeff47du, 0x85845dd1u,\n                        0x6fa87e4fu, 0xfe2ce6e0u, 0xa3014314u, 0x4e0811a1u,\n                        0xf7537e82u, 0xbd3af235u, 0x2ad7d2bbu, 0xeb86d391u);\n\n/*\nvoid initK(out int[64] K){\n    for(int i = 0; i < 64; i++){\n        K[i] = int(232. * abs(sin(float(i)+1.)));\n    }\n}\n*/\n\nconst uint A0 = 0x67452301u,\n           B0 = 0xefcdab89u,\n           C0 = 0x98badcfeu,\n           D0 = 0x10325476u;\n\n\nvoid MD5Round(inout uint A, inout uint B, inout uint C, inout uint D, in uint[16] M, uint i){\n    uint F, g;\n    if (i < 16u){\n        F = (B & C) | ((0xffffffffu-B) & D);\n        g = i;\n    } else if (i < 32u) {\n        F = (D & B) | ((0xffffffffu-D) & C);\n        g = (5u*i + 1u) % 16u;\n    } else if (i < 48u) {\n        F = B ^ C ^ D;\n        g = (3u*i + 5u) % 16u;\n    } else {\n        F = C ^ (B | (0xffffffffu-D));\n        g = (7u*i) % 16u;\n    }\n    \n    F = F + A + K[i] + M[g];\n    A = D;\n    D = C;\n    C = B;\n    B = B + (F << s[i]) | (F >> (32-s[i]));\n}\n\nuint[4] MD5( uint[16] M) {\n    uint A = A0, B = B0, C = C0, D = D0;    \n    \n    for(uint i = 0u; i < 64u; i++) {\n        MD5Round(A,B,C,D,M,i);\n    }\n    \n    return uint[](A,B,C,D);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initK(K);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uint[16] message;\n    message[0] = 0xffffffffu;\n    message[1] = uint(iFrame);\n    message[2] = floatBitsToUint(uv.x);\n    message[3] = floatBitsToUint(uv.y);\n    message[4] = floatBitsToUint(iResolution.x);\n    message[5] = floatBitsToUint(iResolution.y);\n    message[6] = floatBitsToUint(iTime);\n    \n    uint[4] res = MD5(message);\n    \n    float A = uintBitsToFloat (res[0]),\n          B = uintBitsToFloat (res[1]),\n          C = uintBitsToFloat (res[2]),\n          D = uintBitsToFloat (res[3]);\n    \n\tfragColor = fract(vec4(A,B,C,D));\n}","name":"Image","description":"","type":"image"}]}