{"ver":"0.1","info":{"id":"tllGzN","date":"1555864882","viewed":204,"name":"3D Conway","username":"kindpotato","description":"3D Conways game of life. In Buffer A I calculate whether the cell should die or live based on the variable \"sum\". Click to interact.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define pi 3.14159265358\n\n\nvec3 planeColor(vec3 V,vec3 N,vec3 lightVec,vec2 uv){\n    \n    //float brightness = 1000. * threshold * dot(N,lightVec);\n    float sky = asin( -dot(N, lightVec))/pi+0.25;\n    vec3 reflected = reflect(V,N);\n    //float shine = 600. * threshold * pow(max(0.,dot(reflected,lightVec/lightDist)),50.);\n    float shine = 0.3*pow(max(0.,dot(reflected,-lightVec)),50.);\n    return vec3(sky+shine+0.2);\n}\nbool filled(vec3 gridPos){\n    const int width = 37;\n\tconst float widthf = 37.;\n    if (gridPos.x >= 0. && gridPos.x < widthf &&\n    gridPos.y >= 0. && gridPos.y < widthf &&\n    gridPos.z >= 0. && gridPos.z < widthf)\n    {\n    \tivec3 pos = ivec3(int(gridPos.x),int(gridPos.y),int(gridPos.z));\n    \n    \treturn texelFetch(iChannel0,threetotwo(pos),0).x > 0.5;\n    }\n    else\n        return false;\n}\n\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float aspect = iResolution.x/iResolution.y;\n    \n    \n    float time = 0.4*iTime;\n    //Based on uv\n    vec3 viewingNormal = normalize( vec3( uv-vec2(0.5,0.5/aspect),1));\n    vec3 cameraZ = vec3(-cos(time),0,-sin(time));\n    vec3 cameraX = normalize(cross(vec3(0,1,0),cameraZ));\n    vec3 cameraY = vec3(0,1,0);\n    viewingNormal = viewingNormal.x*cameraX + viewingNormal.y*cameraY + viewingNormal.z*cameraZ;\n    \n    \n    const vec3 planeX = vec3(1,0,0);\n    const vec3 planeY = vec3(0,1,0);\n    const vec3 planeZ = vec3(0,0,1);\n    \n  \t\n    vec3 cameraPos = 60.*vec3(cos(time),0,sin(time)) + vec3(18.1);\n    \n    vec3 currentPos = cameraPos;\n    \n    vec3 gridPos = vec3(floor(currentPos.x),floor(currentPos.y),floor(currentPos.z));\n    vec3 colour = vec3(0.6,0.7,1); //Sky color\n    if (viewingNormal.y < 0.)\n        colour = vec3(0);\n    for(int i = 0; i < 150; ++i){\n        \n    \tvec4 uvt = boxIntersection(viewingNormal,gridPos+vec3(0.5)-currentPos,1.);\n        \n        currentPos += viewingNormal*(uvt.z+0.001); \n        \n        gridPos = vec3(floor(currentPos.x),floor(currentPos.y),floor(currentPos.z));\n        \n        if (filled(gridPos)){\n        \tcurrentPos -= viewingNormal*0.001;\n            vec3 lightVec = normalize(vec3(-1,-10,-3));\n            if (uvt.w == 0.) \n            \tcolour = planeColor(viewingNormal, -sign(viewingNormal.x)*planeX, lightVec,uvt.xy);\n            else if (uvt.w == 0.1)\n            \tcolour = planeColor(viewingNormal, -sign(viewingNormal.y)*planeY, lightVec,uvt.xy);\n            else if (uvt.w == 0.2) \n            \tcolour = planeColor(viewingNormal, -sign(viewingNormal.z)*planeZ, lightVec,uvt.xy);\n            else fragColor = vec4(vec3(0.2,0.3,0.5),1);\n            viewingNormal = normalize(lightVec);\n            break;\n        }\n    }\n    fragColor = vec4(colour, 1);\n     \n\t\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifragCoord = ivec2(int(fragCoord.x),int(fragCoord.y));\n    ivec3 gridPos = twotothree(ifragCoord);\n    if (iFrame < 6){\n        /*gridPos.xyz -= 18;\n        if (gridPos.x*gridPos.x + gridPos.y*gridPos.y + gridPos.z*gridPos.z < 150)\n        \tfragColor = vec4(1);\n        else fragColor = vec4(0);*/\n        fragColor = vec4(step(0.89,texture(iChannel1,fragCoord/64.).x));\n        return;\n    }\n    \n    \n    //If the user is clicking check if this box is being clicked\n    \n    if (iMouse.z > 0.1){\n        vec2 uv = iMouse.xy/iResolution.x;\n        float aspect = iResolution.x/iResolution.y;\n\n\n        float time = 0.4*iTime;\n        //Based on uv\n        vec3 viewingNormal = normalize( vec3( uv-vec2(0.5,0.5/aspect),1));\n        vec3 cameraZ = vec3(-cos(time),0,-sin(time));\n    \tvec3 cameraX = normalize(cross(vec3(0,1,0),cameraZ));\n    \tvec3 cameraY = vec3(0,1,0);\n        viewingNormal = viewingNormal.x*cameraX + viewingNormal.y*cameraY + viewingNormal.z*cameraZ;\n\n\t\tvec3 cameraPos = 60.*vec3(cos(time),0,sin(time)) + vec3(18.1);\n        \n        vec3 fgridPos = vec3(float(gridPos.x),float(gridPos.y),float(gridPos.z));\n        vec4 uvt = boxIntersection(viewingNormal,fgridPos+vec3(0.5)-cameraPos,1.);\n        if (uvt.z != 0.){\n            /*vec3 position = viewingNormal*(uvt.z+0.02);\n            if (texelFetch(iChannel1,threetotwo(ftoivec(position)),0).x > 0.5){\n            \tfragColor = vec4(1);\n            \treturn;\n            }*/\n            fragColor = vec4(1);\n            return;\n        }\n    }\n    if (iFrame % 10 == 0){\n        \n        float sum = 0.;\n        int xmax = 2, xmin = -1;\n        int ymax = 2, ymin = -1;\n        int zmax = 2, zmin = -1;\n        \n        if (gridPos.x == 36)\n            xmax = 1;\n        else if (gridPos.x == 0)\n            xmin = 0;\n        if (gridPos.y == 36)\n            xmax = 1;\n        else if (gridPos.y == 0)\n            xmin = 0;\n        if (gridPos.z == 36)\n            xmax = 1;\n        else if (gridPos.z == 0)\n            xmin = 0;\n            \n        for (int x = xmin; x < xmax; ++x){ \n            for (int y = ymin; y < ymax; ++y){ \n                for (int z = zmin; z < zmax; ++z){\n                    //Runs 27 times\n                    sum += texelFetch(iChannel0,threetotwo(gridPos+ivec3(x,y,z)),0).x;\n                }\n            }\n        }\n\n        sum -= texelFetch(iChannel0,threetotwo(gridPos),0).x;\n        \n        //this condition gives the cell life\n        if (sum >= 5.  && sum <= 5. )\n            fragColor = vec4(1);\n        //This condition maintains the cell's life\n        else if (sum >= 4.  && sum <= 5.)\n            fragColor = texelFetch(iChannel0,threetotwo(gridPos),0);\n        //this condition kills the cell\n        else fragColor = vec4(0);\n    }\n    else\n        fragColor = texelFetch(iChannel0,threetotwo(gridPos),0);\n        \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define UVINBOUND uv.x < halfWidth && uv.x > -halfWidth && uv.y < halfWidth && uv.y > -halfWidth\nivec3 ftoivec(vec3 v){\n    return ivec3(int(floor(v.x)),int(floor(v.y)),int(floor(v.z)));\n}\n//Converts 3D position to texture coords\nivec2 threetotwo(ivec3 pos)\n{\n    return pos.xy + ivec2(37*(pos.z%6),37*(pos.z/6));\n}\n//Converts texture coords to 3D position\nivec3 twotothree(ivec2 coord)\n{\n   return ivec3(coord.x%37,coord.y%37,6*(coord.y/37) + (coord.x/37));\n}\n\nfloat planeIntersection(vec3 N,vec3 V,vec3 pos){\n\tfloat distToPlane = -dot(pos,N);\n\tfloat rayDotPlane = -dot(V,N);\n    if (rayDotPlane > 0. && distToPlane > 0.)\n        return distToPlane/rayDotPlane;\n    else return 0.;\n}\nvec4 boxIntersection(vec3 viewingNormal, vec3 boxPos, float inside){\n    vec3 X = vec3(1,0,0);\n    vec3 Y = vec3(0,1,0);\n   \tvec3 Z = vec3(0,0,1);\n    float halfWidth = 0.5;\n    for (int i = 0; i < 2; ++i){\n        \n        \n        vec2 uv;\n        vec3 pos;\n        \n        vec3 planePos = boxPos - inside*halfWidth*X;\n        float t = planeIntersection(X,viewingNormal,planePos);\n        if (t != 0.){\n            pos = t*viewingNormal;\n\n            uv = (pos - planePos).yz;\n            if (UVINBOUND){\n                return vec4(uv,t,0.);\n            }\n        }\n\n        planePos = boxPos - inside*halfWidth*Y;\n        t = planeIntersection(Y,viewingNormal,planePos);\n        if (t != 0.){\n            pos = t*viewingNormal;\n\n            uv = (pos - planePos).xz;\n            if (UVINBOUND){\n                return vec4(uv,t,0.1);\n            }\n        }\n        planePos = boxPos - inside*halfWidth*Z;\n        t = planeIntersection(Z,viewingNormal,planePos);;\n        if (t != 0.){\n            pos = -t*viewingNormal;\n\n            uv = (pos + planePos).xy;\n            if (UVINBOUND){\n                return vec4(uv,t,0.2);\n            }\n        }\n\n        X *= -1.;\n        Y *= -1.;\n        Z *= -1.;\n    }\n    return vec4(0);\n} ","name":"Common","description":"","type":"common"}]}