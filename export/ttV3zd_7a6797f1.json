{"ver":"0.1","info":{"id":"ttV3zd","date":"1579664627","viewed":136,"name":"Endless Rubber Balls","username":"jake_r","description":"I wanted to try deforming a ball as it got close to the ground so I made this! I think using buffers would have made this easier.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["circles","balls","rubber","loop","bouncing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float ground = -0.42;\nfloat bounciness = 0.7;\nfloat loopLength = 6.;\nfloat bounceFrequency = 8.;\nfloat ballCount = 20.;\nfloat randomSeed = 5.;\n\nvec2 uv; //assigned in main\n\nfloat random(float val){\n \treturn fract(sin(randomSeed+val*219142.349034753957)*54643.624304578);   \n}\nfloat randomT2(float val){\n    return fract(sin(randomSeed+val*4386.48748530579)*95347.206309475);\n}\nfloat randomT3(float val){\n    return fract(sin(randomSeed+val*5432.35609374583759)*26467.557573805);\n}\n\nfloat square(float value){\n\treturn value*value;   \n}\n\n\nfloat ellipse(vec2 position, vec2 size){\n    float t = square(uv.x-position.x)/square(size.x) + square(uv.y-position.y)/square(size.y);\n    return smoothstep(1., 0.9, t);\n}\nfloat bouncingBall(float radius, float bounceWidth, float t){\n    //Bouncing\n    float potentialEnergy = pow(bounciness, t*bounceWidth); //bounciness determines how much energy is lost in each bounce\n    float bounce = abs(sin(t*3.141*bounceWidth))*potentialEnergy; //a sine wave that shortens each half oscillation\n    float bounceOffset = (-radius/2.)*potentialEnergy; //based on potentialEnergy the center can get closer to the ground\n    vec2 currentPos = vec2(-1.2+2.4*t, ground+radius+bounce+bounceOffset);\n    \n    //The ball squishes to never overlap the ground\n    float compression = min(1., abs(ground - currentPos.y)/radius); //distance to ground / radius\n    vec2 deform = vec2(max(1., 1.+0.9*(1.-compression)), min(1., compression)); \n    \n    return ellipse(currentPos, radius*deform);\n}\nvec4 randomBall(float i){\n \tfloat time = mod(iTime + randomT2(i+2.)*loopLength, loopLength)/loopLength; //random offset to avoid overlap, and make them loop\n    \n    i = i+random(floor((iTime + randomT2(i+2.)*loopLength)/loopLength)); //i changes with every loop\n    vec4 randomColor = vec4(random(i+1.), randomT2(i+1.), randomT3(i), 1.);\n    randomColor.rgb = 0.9*randomColor.rgb + 0.1; //lightens it up my making the minimum vec3(0.1)\n    float mask = bouncingBall(random(i)*0.1+0.1, (randomT2(i)*0.75 + 0.25)*bounceFrequency, time);\n    return mask * randomColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord/iResolution.xy - 0.5;\n    float aspectRatio = iResolution.x/iResolution.y;\n    uv.x *= aspectRatio;\n\n    vec4 col = vec4(0.);\n    for(float i = 1.; i <= ballCount; i+=1.){\n        col += randomBall(i) * (1.-col.a);\n    }\n    \n    //col += vec4(max(0., 1.-floor(length(uv)+0.995))); //shows the origin\n    col.xyz += vec3(smoothstep(0., 0.01, ground - uv.y)); //the ground\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}