{"ver":"0.1","info":{"id":"wdcSR7","date":"1571837732","viewed":161,"name":"Drops of colored ink","username":"bitless","description":"Drops of colored ink\nThanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","metaball","colormixing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: bitless\n// Title: drops of colored ink\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\" and inspiration \n\n\n#define SQ_LEN 7. //sequence length in seconds\n\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat rand (vec2 st) {\n    float f = fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*43758.5453123);\n    return max(f,0.2);\n}\n\n// translate color from HSB space to RGB space\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 random_color (vec2 p){\n    return hsb2rgb(vec3(rand(p),.75,1.0));\n}\n\n//draw droplet\nvec4 metadrop(in vec2 v)\n{\n    float m_dist = 80.0;\n    float a;\n    vec3 c = vec3(0.0);\n    float t = mod (iTime,SQ_LEN);\n    \n    //moving droplet\n    if (t < 2.)\n    \tv.y += t*t*0.7-2.0; //before touching of surface\n   \telse\n        v.y += 0.8+(t-2.0)*0.45; //after touching\n    \n    v *= 2.0; \n    \n    float f = max(0.,mod (iTime,SQ_LEN)-2.0)*1.75; //split droplet on smaller pieces after touching\n\n    float meta_dist = 4.0 + f*2.0;\n    \n    for (int i =0; i < 4; i++) { //create metaball from 4 parts\n        vec2 point = random2(vec2(i))*0.7-.35; //part center\n        point *= vec2 (sin(iTime*point.x*4.0)*(1.+f),cos(iTime*point.y*4.0)*(1.0+f)); //animate moving\n        float dist = length(v-point)*1.5;\n        m_dist = min (m_dist,dist);\n        meta_dist = min (meta_dist, meta_dist*dist);\n\t    c = mix (c,random_color(vec2(floor(iTime/SQ_LEN+float(i)))),1.0-smoothstep(0.0,1.0,dist*0.690)); //mix color\n    }\n\n    // blend droplet with surface\n    float dist = max (0.0,(v.y-(t-2.5)*2.0+0.5)*1.5); //distance from surface\n    c = mix (c,vec3(0.0,0.0,0.3),1.0-smoothstep(0.0,1.0,dist*0.850)); //mix color with surface color\n    \n    float col;\n    \n    if ((meta_dist > meta_dist*dist))   { //after touching\n\t    meta_dist = meta_dist*dist;\n    \tcol = smoothstep(1.8,1.6,meta_dist)-smoothstep(0.2,1.8,meta_dist)*0.62; \n\t    a = step(0.1,col); //droplet alpha\n        a = mix (a,0.0,1.0-smoothstep(.0,0.6,dist*0.90)); // surface alpha\n        a = min(a,1.0-smoothstep(0.5,1.2,m_dist)); //blend alpha \n        \n    }\n    else    { //before touching\n\t    col = smoothstep(1.8,1.6,meta_dist)-smoothstep(0.2,1.8,meta_dist)*0.62;\n\t    a = step(0.1,col); //droplet alpha\n    }\n    return vec4(c*col,a);    \n}\n\n//draw waves\nvec4 ringwaves (in vec2 v) \n{\n    float dist;\n    float t = iTime*-5.0;\n    vec3 c = vec3(0.0);\n    v.y *= 3.;\n    v.y +=3.;\n\n    v += (cos((length(v) *1.0 - iTime*1.)*5.25)*0.10) + (cos((length(v) *1.0 - iTime*1.)*15.25)*0.055);\n\n    for (float i=0.0; i < 4.; i++) { //draw 4 rings\n        vec2 pnt = (random2(vec2(i))-0.5)*0.4;\n        vec2 p = random2(vec2(i));\n        dist = length(v-pnt);\n        float n = dist*3.1;\n        dist = cos (n*2.1*p.x+t*1.0*p.y);\n        dist *= cos(n*5.4*p.x+t*1.8*p.y);\n        c = mix(c,random_color(vec2(floor(iTime/SQ_LEN+float(i)))),(dist+1.0)*0.5);\n    }\n    t = max(0.,(mod(iTime,SQ_LEN)-1.9)/SQ_LEN*6.);\n    c = c*(1.0-smoothstep(t-(t*0.15),t+(t*0.15),length(v))); //fade to black outside of wave\n    t = max(0.,(mod(iTime,SQ_LEN)-3.0)/SQ_LEN*6.2);\n    c = c*(smoothstep(t-(t*0.05),t+(t*0.45),length(v)));  //fade to black inside of wave\n    t = smoothstep(1.0,0.0,(mod(iTime,SQ_LEN)-4.0)/SQ_LEN*2.0); \n    c *= t; //fade wave\n    return vec4(c,1.0);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st -= 0.5;\n    if (iResolution.y > iResolution.x ) \n        st.y *= iResolution.y/iResolution.x;\n    else \n        st.x *= iResolution.x/iResolution.y;\n    st *= 3.0;\n\n\t//prepare background\n    vec4 color = mix(vec4(hsb2rgb(vec3(0.7,0.98,0.11)),1.0),vec4(hsb2rgb(vec3(0.7,0.65,0.22)),1.0),smoothstep(-1.5,0.16,st.y));\n    color = mix(color,vec4(hsb2rgb(vec3(0.6,0.58,0.11)),1.0),smoothstep(0.16,1.5,st.y));\n\n\n    color += vec4(ringwaves(st)); //ringwaves\n\n    vec4 c = metadrop(st*vec2(1.0,-1.0)+vec2(0.0,-2.1)); //droplet reflection\n    color = mix (color,c,c.a*0.45);\n    c = metadrop(st); //droplet\n    color = mix (color, c ,c.a);\n\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}