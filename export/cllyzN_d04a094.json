{"ver":"0.1","info":{"id":"cllyzN","date":"1690484072","viewed":74,"name":"1.1.1 Raymarcher (SSAA or FXAA) ","username":"Envy24","description":"See Image tab header.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fast","antialiasing","distance","field","fxaa","ssaa","approximate","supersample"],"hasliked":0,"parentid":"dsXfWH","parentname":"0. Raymarcher (base)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Experimenting with heavyweight SSAA (supersample anti-aliasing).\n    All 3 for full screen, and basically all is same (with little difference).\n    I set high value ORDER only for demonstration purposes.\n    \n    Mouse.y controls blur.\n    \n    Some setting:\n    OSSAA with ORDER = 1., BLUR = 1.      costs 9 samples. // Same as CSSAA + box filter\n    JSSAA with ORDER = 1., BLUR = 1.      costs 9 samples.\n    RSSAA with ORDER = 6., BLUR = 1.5     costs 6 samples.\n    USSAA with ORDER = 4., BLUR = 1.1     costs 4 samples, but adds noise.\n    CSSAA with ORDER = 1., BLUR = 0.6     costs 9 samples.\n    \n    For FXAA scene should be rendered once with 1 sample per pixel,\n    then applying FXAA to buffer will costs 9 texture look ups per pixel.\n    \n    Naming for SSAA:\n        O - simple offset,\n        J - jittered offset,\n        R - random sampling,\n        U - random unit disk sampling,\n        C - simple offset + convolution filter.\n    Also check this shaders for more methods: https://www.shadertoy.com/view/4dGXW1\n                                              https://www.shadertoy.com/view/3sfBWs\n                                              https://www.shadertoy.com/view/7t3yR2\n                                              https://www.shadertoy.com/view/MtSGRG\n                                              https://www.shadertoy.com/view/llj3Dw\n                                              https://www.shadertoy.com/view/MtB3RG\n*/\n\n#define MAX_MISS_DIST    ( 1e4 )\n#define MIN_HIT_DIST     ( 1e-4 )\n#define MAX_NUM_OF_STEPS ( 300. )\n#define INIT             ( iMouse.xy == vec2(0) )\n\n// Anti-aliasing settings for OSSAA, JSSAA, RSSAA, USSAA, CSSAA. For FXAA see function implementation below.\n#define AA_METHOD(uv)    ( OSSAA(uv) ) // variants OSSAA, JSSAA, RSSAA, USSAA, CSSAA, FXAA\n#define BLUR             ( INIT ? 1.5 : 4.*iMouse.y/iResolution.y )\n#define ORDER            ( max(1., /* Your choise -> */ 2.) ) \n// For OSSAA, JSSAA, CSSAA order means:\n// 1 -> 3x3 kernel, 2 -> 5x5 kernel, 3 -> 7x7 kernel, e.t.c\n// For RSSAA, USSAA order means:\n// 1 -> 1 sample, 2 -> 2 samples, 3 -> 3 samples, e.t.c.\n\n// Filters only for CSSAA\n//#define FILTER(P)  ( box(P, ORDER) )           // Box blur\n//#define FILTER(P)  ( tent(P, ORDER) )          // Tent blur (L1 norm)\n//#define FILTER(P)  ( square(P, ORDER) )        // Square blur (Linf norm)\n#define FILTER(P)  ( circle(P, ORDER) )        // Circle blur (L2 norm)\n//#define FILTER(P)  ( motion_blur_a(P, ORDER) ) // Motion blur horizontal\n//#define FILTER(P)  ( motion_blur_b(P, ORDER) ) // Motion blur vertical\n// Also Gauss blur can be used.\n\n// Data structures.\nstruct RAY\n{\n    vec3 origin;\n    vec3 direction;\n};\nstruct HIT\n{\n    float hit_dist;\n    bool hit_something;\n};\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// SDFs\nfloat sphereSDF_L2(in vec3 P, in vec3 C, in float r) { return length(C - P)-r; }\n\n/* SCENE */\n#define SPHERE_POS ( vec3(0, 0, 4) )\n#define SPHERE_R   ( 0.9 ) \nfloat find_closest_scene_object(in vec3 marching_point)\n{\n    return sphereSDF_L2(marching_point, SPHERE_POS, SPHERE_R);\n}\n/* SCENE */\n\nHIT ray_march(\n    RAY ray,\n    float max_num_of_steps,\n    float max_distance,\n    float surface_distance) \n{\n    float marched_distance = 0.0; // Distance marched from ray origin.\n    float minimal_distance = 0.0; // Current distance to closest object.\n\n    bool quit = false, hit = false;\n\n    for (float step = 0.; (step < max_num_of_steps) && (quit == false) && (hit == false); step += 1.)\n    {\n        // Calculate current coordinates at ray.\n        vec3 marching_point = ray.origin + ray.direction * marched_distance;\n\n        // Find distance to closest object to point.\n        minimal_distance = find_closest_scene_object(marching_point);\n\n        // March.\n        marched_distance += minimal_distance;\n\n        hit = minimal_distance < surface_distance; // Hit some object?\n        quit = marched_distance > max_distance;    // Marched into infinity?\n    }\n\n    return HIT(marched_distance, hit);  \n}\n\n/* You can see how this works in 2d here:\n   https://www.shadertoy.com/view/slyBRc */\nvec3 approximate_normal(in vec3 P)\n{\n    const float delta = .01;          \n    // Sample distance function at hit point and three nearby points.\n    float s0 = find_closest_scene_object(P),\n          s1 = find_closest_scene_object(P + vec3(delta, 0, 0)),\n          s2 = find_closest_scene_object(P + vec3(0, delta, 0)),\n          s3 = find_closest_scene_object(P + vec3(0, 0, delta));\n    // Calculate finite differencies.    \n    float dfdx = s1 - s0,\n          dfdy = s2 - s0,\n          dfdz = s3 - s0;\n    // Approximate gradient/normal direction.\n    return normalize(vec3(dfdx, dfdy, dfdz));\n}\n\nvec3 light(RAY ray, HIT hit)\n{\n    vec3 color = vec3(1,0,0),\n         light_pos = vec3(0,10,-10),\n         hp = ray.origin + ray.direction * hit.hit_dist,\n         normal = approximate_normal(hp),\n         light_dir = normalize(light_pos - hp);\n    return \n        hit.hit_something == true ?\n            color * max(dot(light_dir, normal), 0.) :\n            (normalize(hp) + vec3(1)) * 0.5;\n}\n\nvec3 scene(in vec2 SC)\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), false);\n\n    RAY ray;\n    /* Axis-aligned orthographic camera *\n    ray.origin = vec3(NDC, -4.0),\n    ray.direction = normalize(vec3(0., 0., 1.0));         \n    /* Axis-aligned perspective camera */\n    ray.origin = vec3(0.0, 0.0, -4.0),\n    ray.direction = normalize(vec3(NDC*0.125, 1.0));\n    /**/\n         \n    // March through scene.\n    HIT hit = ray_march(ray, MAX_NUM_OF_STEPS, MAX_MISS_DIST, MIN_HIT_DIST);                     \n    return light(ray, hit);\n}\n\nvec3 OSSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = ORDER, inv = 1./(2.*order + 1.);\n\n    for (float y = -order; y <= order; y += 1.0)\n        for (float x = -order; x <= order; x += 1.0)\n        {\n            vec2 offset = (BLUR*vec2(x, y)) * inv;\n            col += scene(SC + offset);\n        }\n        \n    order = 2.*order + 1.;\n    return col / (order*order);  \n}\nvec3 JSSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = ORDER, inv = 1./(2.*order + 1.);\n\n    for (float y = -order; y <= order; y += 1.0)\n        for (float x = -order; x <= order; x += 1.0)\n        {\n            //                                     tweak this\n            vec2 jitter = (vec2(x,y) + HASH(x, y)) * inv;\n            col += scene(SC + jitter * BLUR);\n        }\n    \n    order = 2.*order + 1.;\n    return col / (order*order);  \n}\nvec3 RSSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = ORDER;\n\n    for (float s = 0.; s < order; s += 1.0)\n    {\n        vec2 jitter = HASH(s, s + order) * 0.5;\n        col += scene(SC + jitter * BLUR);\n    }\n    \n    return col / order;  \n}\nvec3 USSAA(in vec2 SC)\n{\n    vec3 col = vec3(0);\n    float order = ORDER;\n\n    for (float s = 0.; s < order; s += 1.0)\n    {\n        vec2 jitter = 0.5*sampleUnitDiscSqrt(SC + vec2(s, s * order));\n        col += scene(SC + jitter * BLUR);\n    }\n    \n    return col / order;  \n}\nvec3 CSSAA(in vec2 SC) // with convolution.\n{\n    vec3 col = vec3(0);\n    float order = ORDER;\n    \n    for (float y = -order; y <= order; y += 1.)\n        for (float x = order; x >= -order; x -= 1.)\n        {      \n            vec2 offset = vec2(x, y);\n            col += scene(SC + offset * BLUR) * FILTER(offset);\n        }\n    \n    return col;\n}\nvec3 rOSSAA(in vec2 SC) // reduced version of OSSAA\n{\n    vec3 col = vec3(0);\n    float order = ORDER, inv = 1./order, blur = BLUR;\n\n    for (float y = 0.; y < order; y += 1.0)\n        for (float x = 0.; x < order; x += 1.0)\n        {\n            vec2 offset = (blur*vec2(x, y)) * inv;\n            col += scene(SC + offset);\n        }\n        \n    return col / (order*order);  \n}\n\nvec3 FXAA( vec2 SC )\n{    \n// Adopted from here: https://www.shadertoy.com/view/mtSGDt\n#define FXAA_SPAN_MAX      8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/8.0)\n    vec2 rcpFrame = vec2(1.);\n    vec4 uv = vec4( SC, SC - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n\n    vec3 rgbNW = scene(uv.zw);\n    vec3 rgbNE = scene(uv.zw + vec2(1,0)*rcpFrame.xy);\n    vec3 rgbSW = scene(uv.zw + vec2(0,1)*rcpFrame.xy);\n    vec3 rgbSE = scene(uv.zw + vec2(1,1)*rcpFrame.xy);\n    vec3 rgbM  = scene(uv.xy);\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        scene(uv.xy + dir * (1.0/3.0 - 0.5)) +\n        scene(uv.xy + dir * (2.0/3.0 - 0.5)));\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        scene(uv.xy + dir * (0.0/3.0 - 0.5)) +\n        scene(uv.xy + dir * (3.0/3.0 - 0.5)));\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = map_to_centered_ndc(SC, 1., vec2(0), false),\n         MP = \n             iMouse.xy == vec2(0) ?\n                 vec2(0) :\n                 map_to_centered_ndc(iMouse.xy, 1., vec2(0), false);\n         \n    O = NDC.x < MP.x ?\n            vec4(scene(SC), 1.) :\n            vec4(AA_METHOD(SC), 1.);\n    // Vertical line and sidebar.\n    vec2 RES = map_to_centered_ndc(iResolution.xy, 1., vec2(0), false);\n    float r = 2. * RES.y;\n    O = mix(O, vec4(0,0,0,1), smoothstep(2./iResolution.y, 0., vertical_lineSDF(NDC, MP.x)));\n    O = mix(O, vec4(0,0,1,1), smoothstep(2./iResolution.y, 0., segmentSDF_L2(NDC, vec2(RES.x, -RES.y), vec2(RES.x, -RES.y + r*BLUR/4.), 0.01)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 hash2to2(\n    const uint x,\n    const uint y)\n{\n    // Pick some seeds.\n    const uint s0 = 123u;\n    const uint s1 = 456u;\n    const uint s2 = 789u;\n\n    // Mix coordinates.\n    uint v0 = y * s2 + x;\n    uint v1 = x * s2 + y;\n\n    // Calculate hash.\n\tv0 += s1; v0 *= 445593459u; v0 ^= s0;\n    v1 += s1; v1 *= 445593459u; v1 ^= s0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(v0 * v0 * v0) * 4.6566128730773926e-10f - 1.0f,\n            float(v1 * v1 * v1) * 4.6566128730773926e-10f - 1.0f);\n}\n#define HASH(x, y)                ( hash2to2(uint(x), uint(y)) )\n\n// More variants: https://www.shadertoy.com/view/stlXDN\nvec2 sampleUnitDiscSqrt(vec2 P)\n{\n    vec2 rand = HASH(P.x, P.y);\n    \n    // applying inverse of CDF.\n    rand.x = sqrt((rand.x + 1.0f) * 0.5f);\n    \n    // map from [-1.0; 1.0] to [-PI; PI].\n    rand.y *= 3.14159274f;\n    \n    return vec2(\n        rand.x * cos(rand.y),\n        rand.x * sin(rand.y));\n}\n\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float r)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - r;\n}\n\n// More filters: https://www.shadertoy.com/view/DsjGRG\nfloat box(vec2 P, float order)\n{\n    float row_length = 2.*order + 1.;\n    return \n        order <= 0. ?\n            0. :\n            1. / (row_length*row_length);\n}\nfloat tent(vec2 P, float order) // based on L1_norm\n{\n    float row_length = 2. * order + 1.,\n          r = ceil(row_length * 0.5),\n          v = r - (abs(P.x) + abs(P.y)),\n          w = r,\n          m = 4.;\n\n    /* can be precalculated */\n    for (float i = 1.; i <= r; i += 1.) {\n        w += (r-i)*m; m += 4.;\n    }\n\n    return\n        v < 0. ?\n            0. :\n            v / w;\n}\nfloat square(vec2 P, float order) // based on Linf_norm\n{\n    float row_length = 2. * order + 1.,\n          r = ceil(row_length * 0.5),\n          v = r - max(abs(P.x), abs(P.y)),\n          w = r,\n          m = 8.;\n\n\n    for (float i = 1.; i <= r; i += 1.)\n    {\n        w += (r-i)*m;\n        m += 8.;\n    }\n\n    return v / w;\n}\nfloat circle(vec2 P, float order) // based on L2_norm\n{\n    float row_length = 2. * order + 1.,\n        r = round(row_length * 0.5001),\n        rr = r*r,\n        v = rr - dot(P, P);\n\n    float w = 0.;\n    for (float y = -order; y <= order; y += 1.)\n    {\n        for (float x = order; x >= -order; x -= 1.)\n        {      \n            w += rr - dot(vec2(x, y), vec2(x, y));\n        }\n    }\n\n    return v / w;\n}\nfloat motion_blur_a(vec2 P, float order)\n{\n    float h_row_length = ceil((2. * order + 1.) * 0.5001);\n    return \n        P.x >= 0. && P.y == 0. ?\n            1. / h_row_length :\n            0.;\n}\nfloat motion_blur_b(vec2 P, float order)\n{\n    float row_length = 2. * order + 1.;\n    float h_row_length = ceil(row_length * 0.5001);\n    return \n        P.x >= 0. ?\n            1. / (row_length * h_row_length) :\n            0.;\n}","name":"Common","description":"","type":"common"}]}