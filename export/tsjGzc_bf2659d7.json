{"ver":"0.1","info":{"id":"tsjGzc","date":"1549595380","viewed":94,"name":"Portal to the Unseen","username":"Hauta","description":"Based on\nhttps://www.shadertoy.com/view/td23RK","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float start = 0.01;\nconst float end = 32.;\nconst float rayStep = 0.6;\nconst float tolerance = 0.001;\nconst float FOV = .7;\nconst int MAX_ITER = 1024;\nconst vec3 bg_color = vec3(0.9, 0.8, 0.3);\nconst vec3 ref_fog = vec3(.5, 0., 0.);\n\nconst float eps = 0.001;\nconst vec3 e0 = vec3(eps, 0., 0.);\nconst vec3 e1 = vec3(0., eps, 0.);\nconst vec3 e2 = vec3(0., 0., eps);\n\nconst vec3 s_center = vec3(0., 1., 0.);\nconst float s_size = 1.;\n\n// reflection constants for plane\nconst float p_spec = 10.;\nconst vec3 p_color = vec3(0., .5, .5);\nconst vec3 p_norm = vec3(0., 1., 0.);\n\nconst vec3 l_center = vec3(1.5, 5., 1.5);\nconst vec3 l_color = vec3(1.);\nconst float l_atten = .2;\n\n\nvoid twistxy(inout vec3 pos, in float amt) {\n  float z = pos.z * amt;\n  float c = cos(z);\n  float s = sin(z);\n  pos.xy *= mat2(c, -s, s, c);\n}\n    \n// finds distance to reflected surfaces\nfloat ref_dist(in vec3 pos, inout int ID) {\n  twistxy(pos, sin(.5 * iTime)* .2);\n  \n  vec3 npos = pos + vec3(0., 2.*iTime, 0.);\n  vec3 nn = floor(npos / 4.);\n  ID = int(floor(nn.x + nn.y + nn.z));\n    \n  // distance to center point at (n, m, l) * 4. - (2., 2., 2.)\n  return length(max(abs(mod(npos, 4.) - 2.) - 1., 0.));\n}\n\n// finds distance to real surface (sphere || lower plain)\nfloat real_dist(in vec3 pos, inout int ID) {\n  float a = length(pos - s_center) - s_size;\n    \n  if(a < pos.y) {\n    ID = -2;\n    return a;\n  } else {\n    ID = -1;\n    return pos.y;\n  }\n}\n\n\nvec3 real_norm(in vec3 pos) {\n  int ID = 0;\n  return normalize(vec3(\n    real_dist(pos + e0, ID) - real_dist(pos - e0, ID),\n    real_dist(pos + e1, ID) - real_dist(pos - e1, ID),\n    real_dist(pos + e2, ID) - real_dist(pos - e2, ID)));   \n}\n\nvec3 ref_norm(in vec3 pos) {\n  int ID = 0;\n  return normalize(vec3(\n    ref_dist(pos + e0, ID) - ref_dist(pos - e0, ID),\n    ref_dist(pos + e1, ID) - ref_dist(pos - e1, ID),\n    ref_dist(pos + e2, ID) - ref_dist(pos - e2, ID)));\n}\n\n// takes origin, direction, gives distance to \n// surface.\nfloat march(in vec3 o, in vec3 d, in bool first, inout int ID) {\n  float rayDist = start;\n  float nextDist = 1024.;\n  for(int i = 0; i < MAX_ITER; ++i) {\n    ID = 0;\n    nextDist = first ? real_dist(o + d * rayDist, ID) : \n                       ref_dist(o + d * rayDist, ID);\n      \n    if(nextDist < tolerance) {\n      break;\n    }\n      \n    if(rayDist > end) {\n      ID = 0;\n      break;\n    }\n      \n    rayDist += rayStep * nextDist;\n  }\n  \n  return rayDist;\n}\n\nfloat march(in vec3 o, in vec3 d) {\n  int ID = 0;\n  return march(o, d, true, ID);   \n}\n\n\nvec3 color(in vec3 l, in float dist, int ID) {\n  switch(int(mod(float(ID), 5.))) {\n    case 0: return vec3(.6, 0.4, 1.); break;\n    case 1: return vec3(1., 1., 0.6); break;\n    case 2: return vec3(1., 0.8, 1.); break;\n    case 3: return vec3(.4, 1., 0.8); break;\n    case 4: return vec3(.4, 1., 0.4); break;\n  }  \n}\n\n// lighting for plane\nvec3 lighting(in vec3 pos, in vec3 cam, in vec3 color, in bool real) {\n  vec3 incidence = l_center - pos;\n  float ld = length(incidence); \n  incidence = normalize(incidence);\n  vec3 norm = real ? real_norm(pos) : ref_norm(pos);\n  vec3 reflection = reflect(-incidence, norm);\n    \n  if(march(pos, incidence) < ld) {\n    return vec3(0.);      \n  }\n    \n  float atten = min(1./ (l_atten * ld), 1.);\n  float diff = max(0., dot(incidence, p_norm));\n  float spec = max(0., dot(reflection, normalize(cam - pos)));\n  spec = pow(spec, p_spec);\n    \n  return (color * diff + spec) * l_color * atten;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n  // camera position + orientation\n  vec3 cam = vec3(4. * sin(.1 * iTime), 1.5 + .7 * cos(.2 + .3 * iTime), 2. * cos(.1*iTime));\n\n  vec3 forward = normalize(s_center - cam);\n  vec3 right = normalize(vec3(forward.z, 0., -forward.x));\n  vec3 up = normalize(cross(forward, right));\n    \n  vec3 o = cam;\n  vec3 d = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n  \n  int ID = -3;\n  float dist = march(o, d, true, ID);\n  vec3 no = o + dist*d;\n    \n  if(ID == 0) {\n    fragColor = vec4(bg_color, 1.);\n    return;\n  }\n    \n  if(ID == -1) {\n    vec3 l = lighting(no, cam, p_color, true);\n    fragColor = vec4(l, 1.);\n  }\n    \n  if(ID == -2) {\n    vec3 l = lighting(no, cam, p_color, true);\n    vec3 dir = normalize(reflect(no, real_norm(no)));\n    float dist2 = march(no, dir, false, ID);\n    vec3 l2 = color(l, dist2, ID);\n    l2 = lighting(no + dist2*dir, no, l2, false);\n    float fog_atten = 1./(.1 * (dist2 + dist));\n    fragColor = vec4(mix(l2, ref_fog, 1. - fog_atten), 1.);\n  }\n}","name":"Image","description":"","type":"image"}]}