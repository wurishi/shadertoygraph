{"ver":"0.1","info":{"id":"tdSBRR","date":"1589344864","viewed":123,"name":"Palace","username":"os0450","description":"Day 40: Palace","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["dailycodingchallenge"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://iquilezles.org/articles/distfunctions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(3213.213123, 7879.789321)))*321312.890);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 ii = i+1.0;\n    vec2 f = fract(p);\n    \n    f = smoothstep(0.0, 1.0, f);\n    \n    return mix(mix(rand(vec2(i.x+0.0, i.y+0.0)), rand(vec2(i.x+1.0, i.y+0.0)), f.x),\n               mix(rand(vec2(i.x+0.0, i.y+1.0)), rand(vec2(i.x+1.0, i.y+1.0)), f.x),\n               f.y);\n}\n\nfloat map(vec3 p) {\n    float d = 1e10;\n    vec3 q;\n    \n    q = p;\n    q.y -= -5.0;\n    d = min(d, q.y + (noise(q.xz*3.0)*0.05)+noise(q.xz*0.5+vec2(13213.2))*0.5 );\n    \n    q = p;\n    q.y -= 25.0;\n    d = min(d, -q.y + (noise(q.xz*3.0)*0.05)+noise(q.xz*0.5+vec2(13213.2))*0.5 );\n    \n    q = p;\n    q.y -= -2.5;\n    q.xz = mod(q.xz, 6.0) - 3.0;\n    d = min(d,\n            sdRoundBox(q, vec3(0.2, 100.0, 0.2), 0.2) +\n            noise( (p.yz+p.xy) )*0.1 +\n            noise( (p.yz+p.xy)*20.0 )*0.01);\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.yy;\n\tvec3 cPos = vec3(0.0, 0.0, -5.0);\n    \n    cPos = vec3(sin(iTime*0.5), 0.3+cos(iTime*0.4)*0.2, cos(iTime*0.5));\n    cPos *= 10.5;\n    \n    vec3 cTar = vec3(0.0, 0.0, 0.0);\n    cTar = vec3(sin(iTime), cos(iTime*0.7)*0.5+0.5, 0.0);\n    cTar *= 10.5;\n    \n    \n    vec3 cDir = normalize(cTar - cPos);\n    vec3 wU = vec3(0.0, 1.0, 0.0);\n    vec3 cR = cross(cDir, wU);\n    vec3 cU = cross(cR, cDir);\n\t\n    vec3 rd = normalize(p.x*cR + p.y*cU + cDir);\n    vec3 ro = cPos;\n    \n    float t = 0.;\n    vec3 rp;\n    for(int i=0; i<99; i++) {\n        rp = ro + rd*t;\n        float d = map(rp);\n        \n        t += d;\n    }\n    \n    float mt = iTime;\n    float ph = fract(mt);\n    \n    vec3 col = vec3(0.0);\n    vec3 lDir = normalize(vec3(0.5, 0.5, -0.5));\n    float diff = max(0.0, dot(lDir, getNormal(rp)));\n\n    col += (diff+0.1)*cDir*exp(-3.0*t*t)*100.0;\n\n    float decay = exp(-0.1*t);\n    col += decay*0.01;\n    col += exp(-100.0*abs(fract(rp*5.0+0.1)-0.5))*decay;\n    col += max(0.0, exp(-500.0*abs( fract(t*0.5)-ph )))*decay*vec3(0.3, 1.0, 0.4)*2.5;\n    col = clamp(col, 0.0, 1.5);\n    \n    col = pow(col, vec3(0.45));\n    col -= ( 1.0-exp(-0.2*length(p)) )*0.2;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}