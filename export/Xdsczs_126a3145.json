{"ver":"0.1","info":{"id":"Xdsczs","date":"1489518714","viewed":316,"name":"The Endless River","username":"schuylermartin45","description":"This is the final project for my Global Illuminations course. We were tasked to learn something new by imitating other artwork. As this is one of my last college projects, I'm basing it off of Pink Floyd's last album.\nhttp://shoyler.com/html/csci711.html","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["theendlessriver","pinkfloyd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dj3D3","filepath":"https://soundcloud.com/ahmad-h-muhammad/pink-floyd-sorrow-2","previewfilepath":"https://soundcloud.com/ahmad-h-muhammad/pink-floyd-sorrow-2","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n** File:        The Endless River\n**\n** Author:      Schuyler Martin <sam8050@rit.edu>\n**\n** Description: Final Project: The Endless River - Pink Floyd\n**\n**              \"The sweet smell of a great sorrow lies over the land\n**               Plumes of smoke rise and merge into the leaden sky:\n**               A man lies and dreams of green fields and rivers...\"\n**                                               - Sorrow, Pink Floyd\n**\n**               Link to SoundCloud rendition:\n**               https://soundcloud.com/ahmad-h-muhammad/pink-floyd-sorrow-2\n**\n** Interaction:  The user can interact with the project by hitting the play button\n**               to watch the sun and clouds move. The user can also click and hold\n**               on the view window to move the camera around.\n**\n** Resources:\n**               There are not many write-ups about how to use the various\n**               tools ShaderToy provides. However, there are plenty of openly\n**               available example projects, most of which are undocumented.\n**               I used this example: https://www.shadertoy.com/view/XslGRr\n**               as a guide to making clouds in ShaderToy and took the time to\n**               understand, document, and tweak user iq's work to fit my needs.\n**               It is my understanding that iq is one of the original creators of\n**               ShaderToy and puts out his work as freely available examples. I felt\n**               that I learned a lot deconstructing this example.\n**\n**               The rest of the project is adapted from my ray tracer program for\n**               the Global Illuminations course.\n**\n**               The project generates volumetric data points from one of ShaderToy's\n**               built-in noise files and then uses \"Ray Marching\" or \"Volumentric Ray\n**               Casting\" (https://en.wikipedia.org/wiki/Volume_ray_casting) to paint\n**               in the clouds.\n**\n**\n**\n** **NOTE: On some versions of Chrome, the texture does not load\n** correctly. On my Chromebook, everything looks fine but on my\n** desktop parts of the texture don't load.\n**\n** Version:\n** - 64-bit Fedora 24, Chrome v57.0.2987.133 - Bad\n** - 64-bit ASUS Chromebook, Chrome OS, v56.0.2924.110 - Good\n** I have screenshots of this phenomenon and will include them in my report.\n**\n** Here's the current bug tracking on that issue:\n** - https://bugs.chromium.org/p/chromium/issues/detail?id=707759\n**\n** ** UPDATE **\n** Unsurprisingly the \"bug\" was my fault (see lines 216 here:\n** https://www.shadertoy.com/view/4dSyRw or ~425 below). I left in a line from\n** the checkerboard pattern that conditionally initialized the color of plane\n** in the phong calculations\n**\n** It's a shame this happens on my desktop because my Chromebook can barely\n** render the scene before it catches fire.\n*/\n\n/*** Macros ***/\n// Physical/viewable objects should never change\n// state/value\n#define SPHERE_TYPE\t1\n#define PLANE_TYPE\t2\n\n/* Sun animation attributes */\n// radius of the sun's orbit\n#define SUN_ORBIT_RAD\t50.0\n// speed of the sun's orbit\n#define SUN_SPEED_COEF\t0.50\n// starting point of the sun, independent of the speed\n#define SUN_START_SEED\t(3.0 / SUN_SPEED_COEF)\n\n/* Cloud Attributes */\n// Controls how much cloud to make. More cloud, more slow, but better picture\n// acceptable range seems to be between 130 - 175\n#define CLOUD_RAY_MARCH_STEPS\t160\n\n/*** Abstract Types ***/\n\n// describes Phong illumination model parameters\nstruct Phong {\n    // reflection params\n    // ambient light\n    vec3 ka;\n    // kd + ks < 1\n    // diffuse (Lambertian reflection)\n    vec3 kd;\n    // specular (mirror-like relfection)\n    vec3 ks;\n    // expontent; size of specular highlight\n    float ke;\n};\n\n/*** Objects in scene ***/\n\n// properties belonging to the whole world\n// (in his hands, he's got the whole world in his hands)\nstruct World {\n    vec3 clr;\n    vec3 ka;\n};\nconst World world = World(\n\t// background color; cornflower blue, of course\n\tvec3(0.39, 0.58, 0.93),\n\t// world ambient light\n\tvec3(0.2, 0.2, 0.2)\n);\n\n// Sphere struct\nstruct Sphere {\n    // radius\n    float rad;\n    // position of a sphere\n\tvec3 pos;\n    // color\n    vec3 clr;\n    // specular highlights\n    vec3 spec;\n    // phong information\n    Phong ph;\n};\n// construct the big and small spheres\nconst Sphere lg_sphere = Sphere(\n    1.0, \n    vec3(0.0, 1.0, 0.0), \n    vec3(1.0, 1.0, 1.0),\n    vec3(0.9, 0.9, 0.9),\n    Phong(\n\t\tvec3(0.7, 0.7, 0.7),\n        vec3(0.9, 0.9, 0.9),\n        vec3(0.4, 0.4, 0.4),\n        2.0\n    )\n);\n\n// Plane struct\nstruct Plane {\n    // coefficients of plane equation\n    // also describes the normal\n    vec3 coef;\n    // color, 2 for the checkerboard\n    vec3 clr0;\n    vec3 clr1;\n    // specular highlights\n    vec3 spec;\n    // phong information\n    Phong ph;\n    // two bounding points (upper right, lower left) in the x-z plane\n    vec2 ur;\n    vec2 ll;\n};\n\n// test pattern plane, now used to represent the cloud plane for some\n// intersection calculations\nconst Plane cloud_plane = Plane(\n    // plane has always been weird\n    vec3(0.0, 1.0, 0.0),\n    // black and white for debugging\n    vec3(0.8, 0.8, 0.8),\n    vec3(0.2, 0.2, 0.2),\n    vec3(1.0, 1.0, 1.0),\n    Phong(\n    \tworld.ka,\n        vec3(0.7, 0.7, 0.7),\n        vec3(0.2, 0.2, 0.2),\n        1.0\n    ),\n    vec2( 10.0, 10.0),\n    vec2(-10.0,-10.0)\n);\n// back sky plane; this is a special plane\nPlane sky_plane = Plane(\n    // this gets set to be parallel to the camera\n    // later on\n    vec3(0.0, 0.0, 1.0),\n    // primary color is the blue sky\n    world.clr,\n    // secondary stores a hint of orange\n    vec3(255.0/255.0, 140.0/255.0, 0.0/255.0),\n    vec3(0.7, 0.7, 0.7),\n    Phong(\n    \tvec3(0.5, 0.5, 0.5),\n        // diffuse is orange\n        vec3(255.0/255.0, 140.0/255.0, 0.0/255.0),\n        vec3(0.75, 0.75, 0.75),\n        100.0\n    ),\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.0)\n);\n\n// a boat is just 5 planes, bottom plus 4 sides\nstruct Boat {\n\tPlane bt;\t// bottom\n    // vertical planes are messed up but I'm afraid of destroying\n    // the sky plane to change it right now and I'm not willing to\n    // add more to the boat until the texture load issue is resolved\n   \t//Plane lt;\t// left,  long side\n    //Plane rt;\t// right, long side\n    //Plane fr;\t// front, short side\n    //Plane bk;\t// back,  short side\n};\n// all the boat sides have the same phong properties\nconst Phong boat_phong = Phong(\n\tvec3(0.5, 0.5, 0.5),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.2, 0.2, 0.2),\n    1.0\n);\n// da boat\nBoat the_boat = Boat(\n    Plane(\n    \tvec3(0.0, 1.0, 0.0),\n      \t// \"EVERYTHING'S BROWN!\" - Regular Car Reviews\n        // (will be replaced with the texture color later)\n        vec3(105.0/256.0, 21.0/256.0, 0.0),\n    \tvec3(0.9, 0.9, 0.9),\n    \tvec3(0.8, 0.8, 0.8),\n\t\tboat_phong,\n    \tvec2( 4.0, 2.0),\n    \tvec2(-4.0,-2.0)\n    )\n);\n\n\n/*** Non-visible objects ***/\n\n// representation of a ray, a drop of golden sun\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};   \n\n// Camera struct\nstruct Camera {\n    // position\n    vec3 pos;\n    // look at vector\n    vec3 look_at;\n    // up vector; forms the ground-plane assumption\n    vec3 up;\n    // camera ray\n    Ray ry;\n};\n// Cambot, Gypsy, Tom Servo, CROOOOOOOOOOOOOW!\nCamera cambot = Camera(\n    vec3(7.0, 1.5, 2.3),\n    vec3(0.0, 0.0, -1.0), \n    vec3(0.0, 1.0, 0.0),\n    // initialized later\n    Ray(\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 0.0)\n    )\n); \n\n// Light struct\nstruct Light {\n    vec3 pos;\n   \t// \"radiance\" of the light\n    vec3 clr;\n};\n\n// Lights; light 0 will be the \"sun\"\nLight sun_light = Light(\n    vec3(0.0, 5.0, 0.0),\n    vec3(247.0/255.0, 211.0/255.0, 82.0/255.0)\n);\n\n/********** BEGIN Object Drawing **********/\n\n/*\n** Calculates the distance from a ray intersecting w/a sphere\n**\n** @param ry Ray structure (direction normalized)\n** @param sp Sphere structure\n**\n** @return Distance to spehere\n*/\nfloat int_sphere(Ray ry, Sphere sp)\n{\n   \t// solve for omega, scale factor of ray\n    // using the quadratic equation (Basic Ray Tracer, pg 25)\n    vec3 diff_pos = ry.pos - sp.pos;\n\tfloat b = 2.0 * (\n          (ry.dir.x * diff_pos.x)\n        + (ry.dir.y * diff_pos.y)\n        + (ry.dir.z * diff_pos.z)\n    );\n    float c = (\n          pow(ry.pos.x - sp.pos.x, 2.0)\n        + pow(ry.pos.y - sp.pos.y, 2.0)\n        + pow(ry.pos.z - sp.pos.z, 2.0)\n        - pow(sp.rad, 2.0)\n    );\n    // b^2 - 4c (a  = 1) is called the discriminant\n    float discrmt = pow(b, 2.0) - (4.0 * c);\n    // imaginary numbers ignore; report negative direction\n    // -42 is a good debugging value\n\tif (discrmt < 0.0)\n    {\n    \treturn -42.0;\n    }\n    // pick the closest intersection to the ray\n    // (smallest positive root; -b - sqrt(discriminant))\n    float omega = (-b - sqrt(discrmt)) / 2.0;\n    return omega;\n}\n\n/*\n** Calculates the distance from a ray intersecting w/a sphere\n** (Overload that just calculates the distance)\n**\n** @param ry Ray structure (direction normalized)\n** @param sp Sphere structure\n**\n** @return Distance to sphere\n** @out int_pt Intersection pt\n** @out n Surface normal\n*/\nfloat int_sphere(Ray ry, Sphere sp, out vec3 int_pt, out vec3 n)\n{\n    float omega = int_sphere(ry, sp);\n    // now calculate the point of intersection and the surface normal\n    int_pt = ry.pos + (ry.dir * omega);\n    n = (int_pt - sp.pos) / sp.rad;\n    return omega;\n}\n\n/*\n** Check if a ray intersects a bounded plane\n**\n** @param ry Ray structure\n** @param pl Plane structure\n**\n** @return Distance to plane\n*/\nfloat int_plane(Ray ry, Plane pl)\n{\n    // Basic Ray Tracer, pg. 32\n\tfloat omega = (-1.0 * (dot(pl.coef, ry.pos))\n        / dot(pl.coef, ry.dir)\n    );\n    // skip bounds checking if all plane boundries are zeroed-out\n    if (dot(pl.ur, pl.ll) != 0.0)\n    {\n        // cut the plane by emitting negative distance by calculating\n        // and comparing against a solution point; this effectively\n        // cuts out some plane calculations\n        vec3 bound_pt = ry.pos + (omega * ry.dir);\n        if ((bound_pt.x < pl.ll.x) || (bound_pt.x > pl.ur.x)\n            || ((bound_pt.z < pl.ll.y) || (bound_pt.z) > pl.ur.y))\n            return -42.0;\n    }\n    return omega;\n}\n\n/*\n** Check if a ray intersects a bounded plane\n** (Overload that just calculates the distance)\n**\n** @param ry Ray structure\n** @param pl Plane structure\n**\n** @return Distance to plane\n** @out int_pt Intersection pt\n** @out n Surface normal\n*/\nfloat int_plane(Ray ry, Plane pl, out vec3 int_pt, out vec3 n)\n{\n\tfloat omega = int_plane(ry, pl);\n    int_pt = ry.pos + (ry.dir * omega);\n    n = pl.coef.xyz;\n    return omega;\n}\n\n/*\n** Checks for shadows\n**\n** @param ry Ray to check against\n**\n** @return True if the target is shadowed, false otherwise\n*/\nbool is_shadow(Ray ry)\n{\n    if (int_sphere(ry, lg_sphere) > 0.0)\n       \treturn true;\n    return false;\n}\n\n/*\n** Calculates the color of something, based on the Phong illumination model\n**\n** @param obj_type Enumeration indicating object type\n**        This is the point where using an OOP-capable system would be nice\n**        ...or at least function pointers\n** @param sp Sphere placeholder object\n** @param pl Plane placeholder object\n** @param lights Array of lights in the scene\n** @param int_pt Intersection point, seen by the camera\n** @param n Normal to that intersection point\n** @param ignore_shadow Ignores the shadow ray, if false\n**\n** @return Color of point to shade\n*/\nvec3 calc_phong(int obj_type, Sphere sp, Plane pl, Light light,\n\tvec3 int_pt, vec3 n, bool ignore_shadow)\n{\n    // retrieve the values based on the object type\n    vec3 obj_clr, obj_spec;\n    Phong obj_ph;\n    switch (obj_type)\n    {\n        case SPHERE_TYPE:\n        \tobj_clr = sp.clr;\n        \tobj_spec = sp.spec;\n        \tobj_ph = sp.ph;\n        \tbreak;\n        case PLANE_TYPE:\n        \t// **NOTE: this line caused the shader texture load \"bug\" mentioned earlier\n        \t//if (mod(int_pt.x, 2.0) > 1.0)\n            obj_clr = pl.clr0;\n        \tobj_spec = pl.spec;\n        \tobj_ph = pl.ph;\n        \tbreak;\n    }\n    \n    // calculate the ambient portion first\n    // I just use the object's ambience setting and the object's color\n    vec3 ambi_clr = obj_ph.ka * obj_clr;\n\n    // if the light is visible, sum the other light sources\n    // diffuse and specular calculations require running through each light\n    vec3 diff_sum = vec3(0.0, 0.0, 0.0);\n    vec3 spec_sum = vec3(0.0, 0.0, 0.0);\n\n    // calculate light vectors\n    // source vector\n    vec3 s = normalize(light.pos - int_pt);\n    // V (view vector) is the reverse of S\n    vec3 v = normalize(-1.0 * s);\n    // reflection vector\n    vec3 r = reflect(normalize(v), n);\n\n    // Here's where we branch from the notes, b/c this implementation\n    // uses a moving camera\n    // Find vectors that point to things used in the lighting\n    vec3 v_cam = normalize(cambot.pos - int_pt);\n    vec3 v_light = normalize(light.pos - int_pt);\n\n    // Angle directions. These are clamped do prevent some kind of\n    // weird \"overflow\" problem described by other ShaderToy users.\n    // Without the clamp, the balls emit light from the \"dark side\n    // of the ball\" *queues synth*\n\n    // diffuse angle points to the light source\n    float light_theta = clamp(dot(v_light, n), 0.0, 1.0);\n    // specular angle points to the camera\n    float cam_theta = clamp(dot(r, v_cam), 0.0, 1.0);\n\n    // prevent intersection calculations, if light source is not visible\n    if (ignore_shadow && (!is_shadow(Ray(int_pt, v_light))))\n    {\n        diff_sum += light.clr * obj_clr * light_theta;\n        spec_sum += light.clr * obj_spec * pow(cam_theta, obj_ph.ke);\n    }\n    \n    // put it all together\n    return ambi_clr + (obj_ph.kd * diff_sum) + (obj_ph.ks * spec_sum);\n}\n\n/*\n** Calculates the color of something, based on the Phong illumination model\n**\n** @param sp Sphere object\n** @param lights Array of lights in the scene\n** @param int_pt Intersection point, seen by the camera\n** @param n Normal to that intersection point\n**\n** @return Color of point to shade\n*/\nvec3 calc_phong(Sphere sp, Light light, vec3 int_pt, vec3 n)\n{\n    Plane pl;\n    // this hack blocks sunlight from reaching the boat analog when the sun\n    // goes under the clouds\n    bool sun_under_clouds = sun_light.pos.y > (-9.0 * cloud_plane.coef.y);\n    return calc_phong(SPHERE_TYPE, sp, pl, light, int_pt, n, sun_under_clouds);\n}\n\n/*\n** Calculates the color of something, based on the Phong illumination model\n**\n** @param pl Plane object\n** @param lights Array of lights in the scene\n** @param int_pt Intersection point, seen by the camera\n** @param n Normal to that intersection point\n**\n** @return Color of point to shade\n*/\nvec3 calc_phong(Plane pl, Light light, vec3 int_pt, vec3 n)\n{\n    Sphere sp;\n    bool sun_under_clouds = sun_light.pos.y > (-9.0 * cloud_plane.coef.y);\n    return calc_phong(PLANE_TYPE, sp, pl, light, int_pt, n, true);\n}\n\n/*\n** Simplified/optimized function to calculates the sun in the sky color\n**\n** @param pl Plane object\n** @param sun_light Light acting as the sun in the scene\n**\n** @return Color of point to shade\n*/\nvec3 calc_sky_color(Plane pl, Light sun_light)\n{\n    // intersect point and normal\n    vec3 int_pt;\n    vec3 n;\n    float lt_dist = int_plane(cambot.ry, sky_plane, int_pt, n);\n    // calculate the ambient portion first\n    // I just use the object's ambience setting and the object's color\n    vec3 ambi_clr = pl.ph.ka * pl.clr0;\n\n    // calculate light vectors\n    // source vector\n    vec3 s = normalize(int_pt - sun_light.pos);\n    // V (view vector) is the reverse of S\n    vec3 v = normalize(-1.0 * s);\n    // reflection vector\n    vec3 r = reflect(normalize(v), n);\n\n    // Here's where we branch from the notes, b/c this implementation\n    // uses a moving camera\n    // Find vectors that point to things used in the lighting\n    vec3 v_cam = normalize(cambot.pos - int_pt);\n    // flip the view vector here; the sun emits light, it is not\n    // a spotlight shining opposite of the light source\n    vec3 v_light = normalize(sun_light.pos - int_pt);\n\n    // diffuse angle points to the light source\n    float light_theta = clamp(dot(v_light, n), 0.0, 1.0);\n    // specular angle points to the camera\n    float cam_theta = clamp(dot(r, v_cam), 0.0, 1.0);\n    \n    // limit diff and spec calcuations; otherwise\n    // we make a weird lighting hyperbola\n    vec3 diff = vec3(0.0, 0.0, 0.0);\n    vec3 spec = vec3(0.0, 0.0, 0.0);\n    if (cam_theta > 0.01)\n    {\n    \tdiff = sun_light.clr * pl.clr0 * light_theta;\n    \tspec = sun_light.clr * pl.spec * pow(cam_theta, pl.ph.ke);\n    }\n    \n    // put it all together\n    return ambi_clr + (pl.ph.kd * diff) + (pl.ph.ks * spec);\n}\n\n/*\n** Read color from the wood texture to use in the boat wood\n**\n** **Note: See file header for more information about texture loading\n** issues\n**\n** @param pt Vector position to use to pull data from the texture\n** @return Color from the wood texture\n*/\nvec3 boat_color(vec3 pt)\n{\n    vec2 pt2D = (pt.xy + (vec2(128.0, 32.0) * (pt.z + 1.0))) + pt.xy;\n    pt2D.x = clamp(pt2D.x, 0.0, 1024.0);\n    pt2D.y = clamp(pt2D.y, 0.0, 1024.0);\n    //-1.0 + 2.0 * mix(rgb.r, rgb.g, rgb.b);\n    // load the RGB color value from the position in the texture\n    vec3 color = texture(iChannel1, pt2D / 1024.0).rgb;\n    // lighten the wood color\n    color = mix(vec3(0.5, 0.5, 0.5), color, 0.8);\n    return color;\n}\n\n/********** END Object Drawing **********/\n\n\n/********** BEGIN Cloud Drawing **********/\n\n/*\n** Noise generator. Takes a value and the texture loaded in iChanel0\n** to generate a noisy output value.\n**\n** @param uv Vector point used to seed the noise\n** @return Noisy value, bounded to 0-1\n*/\nfloat noise(in vec3 pt)\n{\n    // pick a position on the texture to load, based on fiddling w/ x\n    vec3 p = floor(pt);\n    vec3 f = fract(pt);\n\tf = f * f * (3.0-2.0*f);\n\tvec2 uv = (p.xy + vec2(37.0,17.0) * p.z) + f.xy;\n\n    // load the RGB color value from the position in the texture,\n    // each value mapped to a 0-1 range\n\tvec3 rgb = textureLod(iChannel0, uv/256.0, 0.0).rgb;\n\t// mix and bound the output\n\treturn -1.0 + 2.0 * mix(rgb.r, rgb.g, rgb.b);\n}\n\n/*\n** Takes a 3D point and number that is later used to determine the density of the cloud\n**\n** @param pt 3D Point in space\n** @return Floating point value that will be used to generate the cloud color at this point\n*/\nfloat cloud_map(vec3 pt)\n{\n    // move the clouds over time\n\tvec3 q = pt - vec3(1.0, 0.1, 0.0) * iTime;\n\tfloat f;\n    f =  0.50000 * noise(q); q = q * 2.02;\n    f += 0.25000 * noise(q); q = q * 2.03;\n    f += 0.12500 * noise(q); q = q * 2.01;\n    f += 0.06250 * noise(q); q = q * 2.02;\n    f += 0.03125 * noise(q);\n\treturn clamp(1.5 - pt.y - 2.0 + (1.75 * f), 0.0, 1.0);\n}\n\n/*\n** Integrate cloud data to reduce to a color value. No Hadoop required! (ba-dum-tish)\n** This smooths the clouds over the sampling period. This keeps the clouds looking like\n** clouds and not auto-generated terrain.\n**\n** @param sum Summation under the curve\n** @param diff Delta value\n** @param den \"Density\"; sets the thickness look of the clouds\n** @param bg_clr Background color\n** @param t \"Time\"; distance traveled across the cloud points\n*/\nvec4 integrate(in vec4 sum, in float diff, in float den, in vec3 bg_clr, in float t)\n{\n    // lighting calculations; modifications to the cloud color\n    vec3 lin = vec3(0.65,0.7,0.75) * 1.4 + vec3(1.0, 0.6, 0.3) * diff;        \n    vec4 color = vec4(mix(vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den), den);\n    color.xyz *= lin;\n    color.xyz = mix(color.xyz, bg_clr, 1.0 - exp(-0.003 * t * t));\n    // front-to-back blending    \n    color.a *= 0.2;\n    color.rgb *= color.a;\n    return sum + color * (1.0 - sum.a);\n}\n\n/*\n** Ray march through the clouds\n**\n** @param ry Ray to fire through the clouds\n** @param bg_clr Background color\n** @return \"Color\" of the cloud; Alpha channel holds a scale factor to apply to the background color\n**         RGB values act as a vector that gives depth/shape to the clouds\n*/\nvec4 cloud_march(Ray ry, in vec3 bg_clr)\n{\n\tvec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat t = 0.0;\n    \n    // point to the sun so we can shade the portion of the clouds facing the sun as it moves across the sky\n    vec3 int_pt, n;\n    int_plane(ry, cloud_plane, int_pt, n);\n    vec3 sun_dir = normalize(sun_light.pos - int_pt);\n\n    \n\t// march through the point cloud of data to make clouds\n    for(int i=0; i<CLOUD_RAY_MARCH_STEPS; ++i)\n    {\n        vec3 pos = ry.pos + (t * ry.dir);\n        float den = cloud_map(pos);\n        // Clouds are naturally fluffy, and itegration will smooth the clouds\n        // out. The higher this threshold, the more jagged the look and the clouds\n        // start to look like procedurally generated mountains, more than they do hills\n        if (den > 0.25)\n        {\n            float diff = clamp((den - cloud_map(pos + (0.3 * sun_dir))) / 0.2, 0.0, 1.0 );\n            sum = integrate(sum, diff, den, bg_clr, t);\n        }\n        t += max(0.05, 0.02 * t);\n    }\n    \n    return clamp(sum, 0.0, 1.0);\n}\n\n/*\n** Renders the sky and clouds. Anything but the \"person on a boat\" analog\n**\n** @param ry Ray to fire through, from the camera\n** @param uv Pixel position on the screen. Alternatively, this is the camera image plane,\n**        what the CMOS sensor on the camera picks up\n*/\nvec3 render_sky_clouds(Ray ry, vec2 uv)\n{\n    // render the back sky-plane, which includes the sun light source\n    // this is done with phong shading\n    sky_plane.coef = normalize(ry.dir);\n    vec3 color = calc_sky_color(sky_plane, sun_light);\n\n    // render clouds using ray marching\n    vec4 cloud_clr = cloud_march(ry, color);\n    // alpha channel holds the gradient/blending information\n    // without it, the clouds look flat and white\n    color = (color * (1.0 - cloud_clr.a)) + cloud_clr.rgb;\n    \n    // add some adiditional orange-ness as a bit of a fudge-factor\n    // makes the harsh blue in the sky less noticeable\n\tcolor += 0.2 * vec3(0.9, 0.4, 0.2);\n    return color;\n}\n\n/********** END Cloud Drawing **********/\n\n/*\n** Main routine\n**\n** @in fragCoord Fragment location\n** @out fragColor Color of fragment to shade\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)   \n{   \n    // uv describes the viewport in terms of some xy amount from 0-1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // convert to a cambot-friendly viewport window\n    uv = -1.0 + (2.0 * uv);\n    // account for widescreen (16:9?) ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n\t// animate the light using some high-school parametric equations\n    // or in RIT terms: Make Moves, Sun\n    // x1 = x0 + rcos(t), y1 = y0 + rsin(t)\n    sun_light.pos.x = sun_light.pos.x\n    \t+ (SUN_ORBIT_RAD * cos(SUN_SPEED_COEF * (iTime + SUN_START_SEED)));\n    sun_light.pos.y = sun_light.pos.y\n        + (SUN_ORBIT_RAD * sin(SUN_SPEED_COEF * (iTime + SUN_START_SEED)));\n\n    \n    /***** Cambot control *****/\n    \n    // use the mouse screen position to move the camera a little bit in 3D\n    // fixed to look towards the center of the image\n    vec2 mouse_pos = (iMouse.xy / iResolution.xy);\n\n    // reset the camera to the default position on frame reset\n    if ((iFrame != 0) && (mouse_pos.x != 0.0) && (mouse_pos.y != 0.0))\n    {\n        cambot.pos *= (2.0 * normalize(\n            vec3(sin(mouse_pos.x), 0.75 * mouse_pos.y, cos(mouse_pos.x))\n        ));\n    }\n\n    // get vector out of the camera positioning\n    vec3 in_front = normalize(cambot.look_at - cambot.pos);\n    // ray spawns from camera\n    vec3 right = normalize(cross(cambot.up, in_front));\n    cambot.up = normalize(cross(in_front, right));\n    // build the camera transformation matrix\n    mat3 cambot_trans = mat3(right, cambot.up, in_front);\n    \n    \n    // assume ray is coming from the camera, which means\n    // we need to define it after our calculations\n    cambot.ry  = Ray(\n        cambot.pos,\n        // adjusting the 3rd parameter streches the creen and causes a cool fish-eye\n        // lensing effect. Set it too low, and you get the acid trip from 2001\n        normalize(cambot_trans * normalize(vec3(uv, 0.5)))\n    );\n\n    // calculated color from illumination model\n    vec3 color;\n    // calculate the intersection point from the camera; which spawns\n    // the other rays\n    vec3 int_pt;\n    // surface normal\n    vec3 n;\n    // intersect with the guy on a boat analog\n    if (int_sphere(cambot.ry, lg_sphere, int_pt, n) > 0.0)\n\t{\n    \tcolor = calc_phong(lg_sphere, sun_light, int_pt, n);\n\t}\n    \n    // sides of the boat\n    else if (int_plane(cambot.ry, the_boat.bt, int_pt, n) > 0.0)\n\t{\n        // texture the boat plane using the ray intersection\n        // to seed the texture look-up\n        the_boat.bt.clr0 = boat_color(int_pt);\n    \tcolor = calc_phong(the_boat.bt, sun_light, int_pt, n);\n\t}\n\n    // everything else is the sky, including cloud formations\n    else\n\t{\n        color = render_sky_clouds(cambot.ry, uv);\n\t}\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}