{"ver":"0.1","info":{"id":"X3jyzd","date":"1727601631","viewed":17,"name":"Drunk Painter","username":"cesio","description":"Piet Mondatic painting waving in a 'drunk' artist style :)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rectangles","abstractionism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n#define SHOW_CREAM_1 6.0\n\n\n/*\n  Draw rectangle with:\n   - top left corner - v1\n   - width and height - size\n   - line smoothiness - smooth\n*/\n\n/* Waving rectangles in a Piet Mondatic style */\n\nfloat rect(in vec2 st, in vec2 v1, in vec2 size, in vec2 smoothiness) {\n    // top left vertex and bottom right vertex\n    vec2 v2 = v1 + size;\n    vec2 colTop;\n    vec2 colBottom;\n    \n    // IF based conditions of checking colour\n    /*\n    if (st.x >= v1.x && st.x <= v2.x && st.y >= v1.y && st.y <= v2.y) {\n        col = 1.0;\n    }\n    */\n    \n    // step based conditions\n    /*\n    colTop = step(v1.x,st.x) * step(v1.y,st.y); // the same as st.x >= v1.x && st.y >= v1.y means that we are >= top left vertex\n    colBottom = step(st.x,v2.x) * step(st.y, v2.y); // the same as st.x <= v2.x && st.y <= v2.y means that we are <= bottom right vertex\n    */\n\n\tcolTop = smoothstep(v1,v1 + smoothiness,st);\n    colBottom = smoothstep(st, st + smoothiness,v2);\n\n  \n    return colTop.x * colTop.y * colBottom.x * colBottom.y;\n}\n/*\n  Draw outline of rectangle with:\n   - top left corner - v1\n   - width and height - size\n   - width and height (size) of an outline = lineSize\n   - line smoothiness - smooth\n*/\nfloat rectOutline(in vec2 st, in vec2 v1, in vec2 size, in vec2 smoothiness,in vec2 lineSize){\n    // the idea behind is to draw an 'outer' rectangle and then draw 'inner' rectangle with the 'opposite' color\n    // top left vertex and bottom right vertex\n    float outerColor = rect(st, v1, size, smoothiness);\n    float innerColor = 1.0 - rect(st, v1 + lineSize, size - 2.0 * lineSize, smoothiness);\n \n  \n    return innerColor * outerColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    float color = rectOutline(st,vec2(0.3,0.1), vec2(0.4,0.8),vec2(0.009),vec2(0.1));\n    \n    //float timeAccelerationFactor = sin(iTime) * 2. + 1.1;\n    float acceleratedTime1 = 1.4 * iTime;\n    float acceleratedTime2 = 1.7 * iTime;\n    \n    float horLine1Pos = sin(acceleratedTime1) * 0.04;\n    float horLine2Pos = sin(acceleratedTime1) * 0.04;\n    float horLine3Pos = sin(acceleratedTime1) * 0.06;\n    float verLinePos1 = sin(acceleratedTime1) * 0.04;   \n    float verLinePos2 = cos(acceleratedTime1) * 0.04;   \n    float verLinePos3 = cos(acceleratedTime2) * 0.04;   \n    \n\n\n    // Draw Piet Mondrian painting\n    // top left red rect rgb(169,33,35)\n    vec3 topLeftRedRect = vec3(0.662,0.129,0.137) * rect(st,vec2(0.0,0.65 - horLine2Pos), vec2(0.2 + verLinePos1,0.8 - horLine2Pos),vec2(0.009));\n    \n    // top right yellow rect rgb(254,196,55)\n    vec3 topLeftYellowRect = vec3(0.996,0.768,0.215) * rect(st,vec2(0.934 + verLinePos3,0.65 - horLine2Pos), vec2(0.066 - verLinePos3,0.35 + horLine2Pos),vec2(0.009));\n\n    // centerCreamTop rgb(241,232,215)\n    vec3 centerCreamTop = vec3(0.945,0.909,0.843) * rect(st,vec2(0.206 + verLinePos1,0.65 - horLine2Pos), vec2(0.741 - verLinePos1 + verLinePos3,1.0 - horLine2Pos),vec2(0.009));\n    \n    // centerCreamBottom rgb(241,232,215)\n    vec3 centerCreamBottom = vec3(0.945,0.909,0.843) * rect(st,vec2(0.206 + verLinePos1,0.086 + horLine3Pos), vec2(0.794 - verLinePos1,0.564 - horLine2Pos - horLine3Pos),vec2(0.009));\n    \n    // leftCream rgb(241,232,215)\n    vec3 leftCream = vec3(0.945,0.909,0.843) * rect(st,vec2(0.,0.0), vec2(0.2 + verLinePos1,0.65 - horLine2Pos),vec2(0.009));        \n\n    // bottomCream rgb(241,232,215)\n    vec3 bottomCream = vec3(0.945,0.909,0.843) * rect(st,vec2(0.206 + verLinePos1,0.0), vec2(0.51 - verLinePos1 + verLinePos2,0.08 + horLine3Pos),vec2(0.009));        \n    \n    // blue rgb(0,94,155)\n    vec3 blue = vec3(0.,0.368,0.607) * rect(st,vec2(0.72 + verLinePos2,0.0), vec2(0.28 - verLinePos2,0.08 + horLine3Pos),vec2(0.009));    \n    \n    // 1st horizontal black rect rgb(0,0,0)\n    float blackLine1 = rect(st,vec2(0.0,0.775 + horLine1Pos), vec2(1.0,0.03),vec2(0.009));\n    \n    // 2nd horizontal black rect rgb(0,0,0)\n    float blackLine2 = rect(st,vec2(0.0,0.64 - horLine2Pos), vec2(1.0,0.03),vec2(0.009));\n    \n    // 3rd horizontal black rect rgb(0,0,0)\n    //float blackLine3 = rect(st,vec2(0.206 + verLinePos1,0.07), vec2(1.0,0.03),vec2(0.009));\n    \n    // 2nd vertical black rect rgb(0,0,0)\n    float blackLineVert1 = rect(st,vec2(0.706 + verLinePos2,0.0), vec2(0.024,1.0),vec2(0.009));\n    \n    // 2nd vertical black rect rgb(0,0,0)\n    float blackLineVert2 = rect(st,vec2(0.926 + verLinePos3,0.0), vec2(0.024,1.0),vec2(0.009));\n    \n    \n    float isBlack = blackLine1 * blackLine2  * blackLineVert1 * blackLineVert2;\n    \n    if (isBlack == 1.0) {\n     \tfragColor = vec4(0);       \n    } else {fragColor = vec4((topLeftRedRect + + topLeftYellowRect + centerCreamTop + centerCreamBottom + leftCream + bottomCream + blue) * (1.0 - blackLine1) * (1.0 - blackLine2)*  (1.0 - blackLineVert1)* (1.0 - blackLineVert2),1.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}