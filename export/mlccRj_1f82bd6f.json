{"ver":"0.1","info":{"id":"mlccRj","date":"1699429923","viewed":36,"name":"学习raymarching1 about fbm terrain","username":"wangqiuyan","description":"follow study of youtube below:\nhttps://www.youtube.com/@TheArtofCodeIsCool\nand\nhttps://www.youtube.com/watch?v=BFld4EBO2RE&t=161s","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 10000.\n#define MAX_STEP 100\n#define SURFACE_DIST .001\n#define ZERO (min(iFrame,0))\n#define TERRAINHEIB 800.\n\nconst float kMaxTreeHeight = 4.8;\nconst float kMaxHeight = 840.0;\n\nconst vec4 sphere=vec4(0.,1.,6.,1.0);\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat hash1( vec2 p )\n{\n    p  = 150.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n   // #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n   // #else\n    //vec2 u = w*w*(3.0-2.0*w);\n    //#endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n   // return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y);\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\nconst mat2 m2 = mat2(  0.80,  0.60,\n           -0.60,  0.80 );\n           \nfloat fbm_4( in vec2 x )\n{\n    float f = 1.9;\n    float s = 0.55;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}                    \nfloat fbm_9( in vec2 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=ZERO; i<6; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n    \n\treturn a;\n}\nfloat planey(vec2 xz)\n{\n/*\n    float a00=0.1,a10=0.2,a01=0.3;\n    float a20=0.02,a11=-0.012,a02=-0.02;\n    float x=xz.x;\n    float z=xz.y;\n    \n    return a00+a10*x+a01*z+a20*x*x+a11*x*z+a02*z*z;\n    */\n    \n    //return noise(xz/1.);\n    \n   // return 800.*fbm_9(xz/2000.)+800.;\n   \n   float orih=TERRAINHEIB*fbm_9(xz/2000.)+TERRAINHEIB;\n   float s=smoothstep(700.,800.,orih);\n   return orih+90.*s;\n   //return orih;\n}\n\nvec3 getNormalPlane(vec3 p)\n{\n    float minnn=0.03;\n    float y=planey(p.xz);\n    float dx=planey(p.xz-vec2(minnn,0.))-y;\n    float dz=planey(p.xz+vec2(0.,minnn))-y;\n    \n  \n   //return normalize(vec3(dx,minnn,dz));\n   vec2 e = vec2(0.03,0.0);\n   return normalize(vec3(planey(p.xz-e.xy)-planey(p.xz+e.xy),2.*e.x,planey(p.xz-e.yx)-planey(p.xz+e.yx)));\n   \n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nvec2 map(vec3 p)\n{\n    float env=planey(p.xz);\n    float terraindist=p.y-env;\n    // tree envelope\n    float treedis = p.y - (env+kMaxTreeHeight*1.1);\n    \n    vec2 res=vec2(terraindist,1.);\n    \n    //vec4 sphere=vec4(0.,1.,6.,1.0);\n    float spheredist=length(p-sphere.xyz)-sphere.w;\n    //res=opU(res,vec2(spheredist,2));\n    \n   \n    \n    return res;   \n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\nvec2 raymarching(vec3 ro, vec3 rd)\n{\n    float th=SURFACE_DIST;\n   \n    //vec2 mapd;\n    \n    float t2=-1.;\n    float t=0.01,ot=t;\n    \n    float odis2=0.,dis2=0.,odis=0.,dis=0.;\n    \n    for(int i=0;i<400&&t<=MAX_DIST;i++)\n    {\n        vec3 p=ro+t*rd;\n        \n        float hei=planey(p.xz);\n        \n        if(t2<0.)\n        {\n             dis2 = p.y - (hei+kMaxTreeHeight*1.1);\n            \n             if(dis2<th)\n             {\n                  t2=ot+(odis2-th)*(t-ot)/(odis2-dis2);\n             }\n             odis2=dis2;             \n        }\n        \n        dis=p.y-hei;\n        \n        if(dis<SURFACE_DIST) break;\n        \n       \n        odis=dis;\n        ot=t;\n        t+=dis*0.8;\n        \n       \n        \n        \n        //mapd=map(p);\n       // float dis=mapd.x;\n        \n        /*\n        if(mapd.y==1.) {\n            if(planey(p.xz)<=TERRAINHEIB)\n                dis*=1.8*0.25;\n            else\n                dis*=0.8;\n        }*/\n        //d0+=dis;\n        //if(dis<SURFACE_DIST||d0>MAX_DIST)\n         //   break;\n       \n    }\n    \n    if(t>MAX_DIST) t=-1.;\n    t=ot+(odis-th)*(t-ot)/(odis-dis);\n    return vec2(t,t2);\n}\nvec3 getNormal(vec3 p)\n{\n    vec2 e=vec2(0.01,0.0);\n    float d=map(p).x;\n    vec3 n=d-vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\nvec3 getlight(vec3 p,float m){\n    vec3 lightPos=vec3(0.,5.,6.);\n \n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l=normalize(lightPos-p);\n    //l=normalize(vec3(-100,60,1));\n   // vec3 n=getNormalPlane(p);\n    vec3 n=getNormal(p);\n    float dif=dot(n,l);\n    vec3 col=vec3(0.);\n    if(m==1.)\n    {\n        n=getNormalPlane(p);\n        l=normalize(vec3(-6,5,0));\n        vec3 refect=reflect(-l,n);\n        dif=dot(n,l);\n        \n        //shadow\n        float t=0.1,res=1.;\n        for( int i=ZERO; i<32; i++ )\n        {\n            vec3  pos = p + t*l;\n            float  env = planey(pos.xz);\n            float hei = pos.y - env;\n           // res=32.*hei/t;\n            res = min( res, 32.0*hei/t );\n            if( res<0.001  ) break;\n            t+=hei;\n            //t += clamp( hei, 2.0+t*0.1, 100.0 );\n        }\n        //res=abs(res);\n       // res=smoothstep(0.,1.,res);\n        res=clamp(res,0.0,1.);\n        \n        //dif*=res;\n        \n        col=vec3(219,165,150)/255.;\n        \n        vec3 nor = normalize( n + 0.8*(1.0-abs(n.y))*0.8);\n        \n        col=mix(col,vec3(130,130,9)/255.,smoothstep(0.7,0.9,nor.y));\n        \n        vec3 colour=vec3(dif)+(1.+n.y)/2.*vec3(0.42,0.62,1.1)/10.;\n        colour+=clamp(dot(n,-refect),0.,1.)*(vec3(219,165,150)/255.)/1.;\n        col*=colour;\n       \n       \n        \n        \n        //col = vec3(dif);           \n        //if(dif>0.)\n        //col*=vec3(219,165,150)/255.;\n        \n        //if(p.x>0.) col.r=1.;\n        //if(p.z>0.) col.g=1.;\n       \n        \n        //vec3 rm=raymarching(p,-l);\n        //if(rm.y<SURFACE_DIST&&rm.z==1.)\n          //  dif*=0.3;\n      \n    }\n    else{\n         col=vec3(dif);\n    }\n   \n     \n   \n    \n    //if(length(lightPos-p)>raymarching(p+n*SURFACE_DIST*2.,l).x)\n       // dif*=0.1;\n   // dif=clamp(dif,-10.,1.);\n    return col;    \n}\n\nvec3 rendersky(vec3 ro,vec3 rd)\n{\n    vec3 col=vec3(0.);\n     //col += vec3(0.42,0.62,1.1) - rd.y*0.4;\n    float t=(2900.-ro.y)/rd.y;\n    if(t>0.)\n    {\n        col += vec3(0.42,0.62,1.1) - rd.y*0.4;\n        vec3 p=ro+t*rd;\n        vec2 uv=p.xz;\n        float cl = fbm_9( uv/vec2(8346.2452,5000.)+vec2(135.48,-108.02) );\n        float dl = smoothstep(-0.1,0.65,cl);\n        col = mix( col, vec3(1.0), 0.22*dl );\n        \n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (1.*fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 px = (1.0*(fragCoord+vec2(.5,0.0))-.5*iResolution.xy)/iResolution.y;\n    vec2 py = (1.0*(fragCoord+vec2(0.0,0.5))-.5*iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    vec3 col =vec3(0.0);\n    \n   /*\n    vec3 target=sphere.xyz;\n    vec3 ro=vec3(400,400,-400);\n    ro.xz*=Rot(sin(iTime));\n    ro+=target;\n    vec3 dir=normalize(target-ro);\n    */\n    \n    \n    \n    \n    vec3 ro=vec3(0.,500.,6.);\n   \n    vec3 ta = vec3(0.0, 403.5, -90.0 + ro.z );\n    vec3 dir=normalize(sphere.xyz-ro);\n    dir=normalize(ta-ro);\n    //dir=normalize(vec3(0,1,1));\n    dir.zy*=Rot((mouse.y-0.5)*3.14);\n    dir.xz*=Rot(mouse.x*6.28-3.14);\n   \n     \n    vec3 right=cross(vec3(0,1,0),dir);\n    vec3 up=cross(dir,right);\n    \n    dir=normalize(dir);\n     \n    \n    vec3 rd=normalize(uv.x*right+uv.y*up+dir);\n   \n    //vec3 rdx=normalize(vec3(px.x,px.y,1.));\n    //vec3 rdy=normalize(vec3(py.x,py.y,1.));\n    \n    vec2 terrainmar=raymarching(ro,rd);\n    float dterrain=terrainmar.x;\n    float dtree=terrainmar.y;\n  \n    \n    col = rendersky(ro,rd);\n    //col=vec3(rd.y);\n    \n   // int   obj = 0;\n   if(dterrain>0.){\n        vec3 p=ro+rd*dterrain;  \n        col=getlight(p,1.);\n    }\n    if(dtree>0.)\n    {\n         vec3 p=ro+rd*dterrain;  \n         vec2 idxz=(floor(p.xz/2.))*2.+1.;\n         float env=planey(idxz);\n         vec3 localp=p-vec3(idxz.x,env,idxz.y);\n         //localp.xz*=105.;\n         localp.y*=3.;\n         //localp*=vec3(0.5,0.5,0.5);\n         float d=length(localp)-0.8;\n         float dif=dot(localp,normalize(vec3(-6,5,0)));\n         d=smoothstep(0.01,0.0,d);\n         col+=vec3(0,d,0)*.5*dif;\n         //col=vec3(idxz*0.0002,0.5);\n        // col=getlight(p,1.);\n    }\n  \n    \n    \n   \n  \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}