{"ver":"0.1","info":{"id":"3ddGzM","date":"1568100742","viewed":530,"name":"Volumetric Lighting Test","username":"bad_dreams_","description":"ðŸ’¡","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash31(vec3 seed) {\n \tvec3 temp = fract(seed * vec3(235.219, 392.452, 149.976));\n    temp += dot(temp, temp + 23.12);\n    return fract(temp.x * temp.y * temp.z);\n}\n\n// The very lovely Iq's signed distance field functions.\nfloat getSphereDistance(vec3 point, vec3 position, float radius) {\n    return distance(point, position) - radius;\n}\n\nfloat getBoxDistance(vec3 point, vec3 position, vec3 b)\n{\n  vec3 d = abs(point - position) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat getCylinderDistance(vec3 point, vec3 position, float h, float r) {\n  vec3 p = vec3(point.y, point.x, point.z) - vec3(position.y, position.x, position.z);\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat opUnion(float a, float b) { return min(a, b); }\nfloat opSubtract(float a, float b) { return max(a, -b); }\n                        \nfloat getSceneDistance(vec3 point) {\n\tconst vec3 corridorPosition = vec3(0.0, 0.0, 0.0);\n\tconst vec3 corridorExtents = vec3(4.0, 3.0, 10.0);\n    \n    const vec3 interiorPosition = corridorPosition;\n    const vec3 interiorExtents = corridorExtents - vec3(1.0, 1.0, 2.0);\n\n    const vec3 cut0Position = corridorPosition + vec3(-1.0, 3.0, 5.0);\n    const vec3 cut0Extents = vec3(interiorExtents.x / 1.25, 2.0, 1.2);\n    \n    const vec3 cut1Position = corridorPosition + vec3(1.0, 3.0, 3.0);\n    const vec3 cut1Extents = vec3(interiorExtents.x / 1.25, 2.0, 1.0);\n    \n    const vec3 cut2Position = corridorPosition + vec3(4.0, 0.0, 3.0);\n    const vec3 cut2Extents = vec3(2.0, 0.5, 1.0);\n    \n    const vec3 pipe0Position = corridorPosition + vec3(0.0, 0.75, 6.0);    \n    const vec3 pipe1Position = corridorPosition + vec3(0.0, 0.75, 5.0);\n\n    const vec3 cut3Position = corridorPosition + vec3(0.0, -1.7, 1.1);\n    const vec3 cut3Extents = vec3(2.0, 0.6, 3.0); \n    \n    float corridorDist = getBoxDistance(point, corridorPosition, corridorExtents);\n    float interiorDist = getBoxDistance(point, interiorPosition, interiorExtents);\n    float cut0Dist = getBoxDistance(point, cut0Position, cut0Extents);\n    float cut1Dist = getBoxDistance(point, cut1Position, cut1Extents);\n    float cut2Dist = getBoxDistance(point, cut2Position, cut2Extents);\n    float pipe0Dist = getCylinderDistance(point, pipe0Position, 0.25, 3.0);\n    float pipe1Dist = getCylinderDistance(point, pipe1Position, 0.25, 3.0);\n    float ballDist = getSphereDistance(point, corridorPosition + vec3(0.0, sin(iTime), 4.5), 1.4);\n    float cut3Dist = getBoxDistance(point, cut3Position, cut3Extents);\n\n    float stage0 = opSubtract(corridorDist, interiorDist);\n    float stage1 = opSubtract(stage0, cut0Dist);\n    float stage2 = opSubtract(stage1, cut1Dist);\n    float stage3 = opSubtract(stage2, cut2Dist);\n    float stage4 = opUnion(stage3, pipe0Dist);\n    float stage5 = opUnion(stage4, pipe1Dist);\n    float stage6 = opUnion(stage5, ballDist);\n    float stage7 = opSubtract(stage6, cut3Dist);\n    return stage7;\n}\n\nvec3 getSceneNormal(vec3 point) {\n \tfloat epsilon = 0.01;\n    vec3 xOff = vec3(epsilon, 0.0, 0.0);\n    vec3 yOff = vec3(0.0, epsilon, 0.0);\n    vec3 zOff = vec3(0.0, 0.0, epsilon);\n    \n    return normalize(vec3(\n    \tgetSceneDistance(point + xOff) - getSceneDistance(point - xOff),\n    \tgetSceneDistance(point + yOff) - getSceneDistance(point - yOff),\n    \tgetSceneDistance(point + zOff) - getSceneDistance(point - zOff)   \n    ));\n}\n\nstruct HitResult {\n\tbool hit;\n    vec3 point;\n    vec3 normal;\n    float penumbra;\n    float time;\n};\n\nHitResult getSceneHit(vec3 origin, vec3 direction) {\n    // March to scene surface\n    const float MAX_STEPS = 128.0;\n    float time = 0.0;\n    float penumbra = 1.0;\n\n    vec3 testPoint;\n    bool hit = false;\n    for (float stepIndex = 0.0; stepIndex < MAX_STEPS; stepIndex += 1.0) {\n        testPoint = origin + direction * time;\n        float dist = getSceneDistance(testPoint);\n\n        penumbra = min(penumbra, 2.0 * dist / time);\n        time += dist + 0.0051;\n        \n        if (dist < 0.00001) {\n            hit = true;\n            penumbra = 0.0;\n            break;\n        }\n    }\n    \n    penumbra = clamp(penumbra, 0.0, 1.0);\n    \n    if (!hit) {\n    \treturn HitResult(false, vec3(0.0), vec3(0.0), penumbra, 0.0);\n    }\n    \n    return HitResult(true, testPoint, getSceneNormal(testPoint), penumbra, time);\n}\n\nfloat getSceneOcclusion(vec3 position, vec3 normal) {\n\tfloat occlusion = 0.0;\n    float sca = 1.0;\n    for (int index = 0; index < 5; index += 1) {\n        float offset = 0.04 + 0.12 * float(index) / 4.0;\n        vec3 aoPosition = normal * offset + position;\n        float dist = getSceneDistance(aoPosition);\n        occlusion += -(dist - offset) * sca;\n        sca *= 0.65;\n    }\n\n    return clamp(1.0 - 3.0 * occlusion, 0.0, 1.0);\n}\n\nvec3 getLightEnergy(vec3 origin, vec3 direction) {\n    vec3 jitteredOrigin = origin + vec3(hash31(origin)) * 0.025;\n \tHitResult result = getSceneHit(jitteredOrigin, direction);\n    return vec3(result.penumbra) + 0.003;\n}\n\nvec3 getFogEnergy(vec3 origin, vec3 direction) {\n    const float MAX_STEPS = 80.0;\n    const float MAX_DISTANCE = 10.0;\n    const float DELTA_TIME = MAX_DISTANCE / MAX_STEPS;\n    const float accScale = 1.0 / MAX_STEPS;\n    \n    float energy = 0.00;\n\t\n    float time;\n    vec3 testPoint;\n    bool hit = false;\n    for (time = 0.0; time < MAX_DISTANCE; time += DELTA_TIME) {\n        testPoint = origin + direction * time;\n        float dist = getSceneDistance(testPoint);\n        \n        float tx = cos(iTime);\n        float tz = sin(iTime);\n        HitResult lightResult = getSceneHit(testPoint, normalize(vec3(tx, 2.0, tz)));\n        float density = clamp(snoise(testPoint * 32.0 + vec3(1.0) * iTime * 5.0), 0.35, 1.0);\n        energy += lightResult.hit ? 0.0 : lightResult.penumbra * accScale * density;\n        \n        if (dist < 0.001) {\n            hit = true;\n            break;\n        }\n    }\n    \n    return vec3(energy);\n}\n\nvec3 getPrimaryRayColor(vec3 origin, vec3 direction) {\n    HitResult result = getSceneHit(origin, direction);\n    \n    if (result.hit) {\n        float tx = cos(iTime);\n        float tz = sin(iTime);\n        vec3 lightDirection = normalize(vec3(tx, 2.0, tz));\n\n     \t// Calculate lighting.\n        vec3 fogEnergy = getFogEnergy(origin, direction);\n        vec3 lightEnergy = getLightEnergy(result.point + result.normal * 0.1, lightDirection);\n        float ao = getSceneOcclusion(result.point, result.normal);\n        \n        vec3 temp = normalToColor(-result.normal);\n        vec3 diffuse = vec3((temp.x * 0.5 + temp.y * 2.0 + temp.z) / 3.0);\n        return diffuse * ao * lightEnergy + fogEnergy;\n    }\n    \n    return vec3(1.0);\n}\n\nvec3 getSceneColor(vec2 uv) {\n    vec3 origin = vec3(0.0);\n    vec3 direction = normalize(vec3(uv.x, uv.y, 0.35));\n\treturn getPrimaryRayColor(origin, direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (iResolution.xy * 0.5)) / iResolution.y;\n    vec3 color = getSceneColor(uv);\n\n    // Gamma correct.\n    vec3 adjusted = pow(color, vec3(1.0 / 2.2));\n    fragColor = vec4(adjusted, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 normalToColor(vec3 normal) {\n \treturn vec3(\n        (normal.x + 1.0) / 2.0,\n        (normal.y + 1.0) / 2.0,\n        (normal.z + 1.0) / 2.0\n    );\n}\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}","name":"Common","description":"","type":"common"}]}