{"ver":"0.1","info":{"id":"DlKyzc","date":"1700499401","viewed":135,"name":"Abstract Full Moon","username":"granitoale","description":"RayMarched abstract moon in the sea","likes":12,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Alessandro Granito, 2023 - https://granitoale.myportfolio.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material.\nconst vec3 uLight = vec3(300,300,2);\nconst float MAX_DISTANCE = 100.;\nconst int uBoxes = 5;\n#define PI 3.141592653589793\n/*--------------------------------------------------------\nRotation Matrixes for 3D points in space\n--------------------------------------------------------*/\nmat3 rotateX(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,c,-s),\n        vec3(0,s,c)\n    );\n}\nmat3 rotateY(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\nmat3 rotateZ(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,-s,0),\n        vec3(s,c,0),\n        vec3(0,0,1)\n    );\n}\n/*--------------------------------------------------------\n3D Noise by Inigo Quilez\n--------------------------------------------------------*/\nfloat hash(vec3 p){  // replace this by something better\n    p = fract(p*0.3183099+.1);\n    p *= 17.0;\n    return fract(p.x*p.y*p.z*(p.x+p.y+p.z));\n}\nfloat noise(in vec3 x){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\nfloat fbm(vec3 p){\n    mat3 m = mat3( 0.00,  0.80,  0.60,\n                  -0.80,  0.36, -0.48,\n                  -0.60, -0.48,  0.64);\n    vec3 q = 8.0*p;\n    float f  = 0.5000*noise(q); q = m*q*2.01;\n    f += 0.2500*noise(q); q = m*q*2.02;\n    f += 0.1250*noise(q); q = m*q*2.03;\n    f += 0.0625*noise(q); q = m*q*2.01;\n    return f;\n}\n/*--------------------------------------------------------\nStructs\n--------------------------------------------------------*/\nstruct Material {\n\tvec3 ambientColor; //k_a * i_a\n\tvec3 diffuseColor; //k_d * i_d\n\tvec3 specularColor; //k_s * i_s\n\tfloat alpha; //shininess\n\tfloat reflectiveness;\n};\nstruct Surface{\n\tfloat id; //id of object\n\tfloat sdf; //signed distance value from SDF\n\tMaterial mat; //material of object\n};\n/*--------------------------------------------------------\nMaterials\n--------------------------------------------------------*/\nvec3 moonSurfaceBase(vec3 p,float m){\n    vec3 col = vec3(0.);\n    if(m < 0.001){\n        p *= rotateZ(noise(p*17.)+iTime*0.05)*rotateY(noise(p+3.)+iTime*0.05);\n        col = vec3(1.)*(smoothstep(0.5,.9,fbm(p)))*1.5;\n    }\n\treturn col;\n\n}\nMaterial boxMat(){\n\treturn Material(\n\t\tvec3(0., 0., 0.),\n\t\tvec3(1.5, 1.5, 1.5),\n\t\tvec3(.3, .3, .3),\n\t\t1.,\n\t\t0.\n\t);\n}\nMaterial moonMat(vec3 p,float m){\n\treturn Material(\n\t\tmoonSurfaceBase(p,m),\n\t\t0.6*vec3(1.),\n\t\t0.8*vec3(.7),\n\t\t4.,\n\t\t0.\n\t);\n}\nMaterial seaMat(vec3 p){\n\treturn Material(\n\t\t0.3*vec3(0.9),\n\t\t0.8*vec3(0.9),\n\t\t0.5*vec3(0.8),\n\t\t10.,\n\t\t1.\n\t);\n}\n/*--------------------------------------------------------\nSDF Operations\n--------------------------------------------------------*/\nSurface minSDFs(Surface s1,Surface s2){\n\tif(s1.sdf < s2.sdf) return s1;\n\treturn s2;\t\n}\nMaterial mixMats(Material m1,Material m2,float k){\n\treturn Material(\n\t\tmix(m1.ambientColor,m2.ambientColor,k),\n\t\tmix(m1.diffuseColor,m2.diffuseColor,k),\n\t\tmix(m1.specularColor,m2.specularColor,k),\n\t\tmix(m1.alpha,m2.alpha,k),\n\t\tmix(m1.reflectiveness,m2.reflectiveness,k)\n\t);\n}\nSurface opSmoothUnion(Surface s1, Surface s2, float k){\n\tfloat h = clamp(0.5+0.5*(s2.sdf-s1.sdf)/k,0.0,1.0);\n\treturn Surface(mix(s1.id,s2.id,k),mix(s2.sdf,s1.sdf,h)-k*h*(1.0-h),mixMats(s2.mat,s1.mat,h));\n}\nSurface opSmoothSubtraction(Surface s1,Surface s2,float k){\n  float h = clamp(0.5-0.5*(s2.sdf+s1.sdf)/k,0.0,1.0);\n  return Surface(s2.id,mix(s2.sdf,-s1.sdf,h)+k*h*(1.0-h),s2.mat);\n}\n/*--------------------------------------------------------\nSDF Functions\n--------------------------------------------------------*/\nvec3 pBoxes(vec3 p,float i){\n\tfloat rotY = PI*sin(iTime*PI*0.1);\n\tfloat rotZX = PI*cos(iTime*PI*0.1);\n\tp *= rotateY(rotY-i)*rotateZ(rotZX*.3)*rotateX(rotZX*0.7);\n\tp.x -= sin(iTime*PI*0.1)*2.5;\n\tp.z -= sin(iTime)*1.5;\n\treturn p;\n}\nSurface sdfSea(vec3 p){\n\tp += p.y < 0.0 ? vec3(fbm(p*0.04+sin(iTime*PI*0.01))) : vec3(0);\n\treturn Surface(0.,p.y+0.3,seaMat(p));\n}\nSurface sdfMoon(vec3 p){\n    float m = length(p)-1.5;\n\treturn Surface(1.,m,moonMat(p,m));\n}\nSurface sdfBox(vec3 p,vec3 b,float i){\n\tp = pBoxes(p,i);\n\tvec3 q = abs(p) - b;\n  \treturn Surface(2.,length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),boxMat());\n}\nSurface sdfSphere(vec3 p,float b,float i){\n\tp = pBoxes(p,i);\n\treturn Surface(1.,length(p)-(b-.1),boxMat());\n}\n\n/*--------------------------------------------------------\nMaking the scene, calling all the SDF functions passing\nID of object and material. Rotation and Transformation of\nobjects happens in the SDF function.\n--------------------------------------------------------*/\nSurface scene(vec3 p){\n\tvec3 op = p;\n\tp.y -= sin(iTime*PI*0.5)*0.1;\n\tSurface scene = sdfMoon(p);\n\n\tfor(int i = 0; i < uBoxes; i++){\n        Surface sphere = sdfSphere(p,0.12,float(i));\n\t\tSurface insideBox = sdfBox(p,vec3(0.1),float(i));\n\t\tscene = opSmoothSubtraction(sphere,scene,.65);\n\t\tscene = opSmoothUnion(scene,insideBox,0.02);\n\t}\n\n\tSurface sea = sdfSea(op);\n\tscene = opSmoothUnion(scene,sea,.35);\n\t\n\treturn scene;\n}\nvec3 normal(vec3 p) {\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .005773 * (2. * vec3(((i + 3) >> 1) & 1, (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * scene(p + e * 0.005).sdf;\n\t}\n\treturn normalize(n);\n}\nSurface rayMarch(vec3 ro, vec3 rd){\n\tfloat depth = 0.;\n\tSurface sur;\n\tfor (int i = 0; i < 255; i++) {\n\t\tvec3 p = ro + depth * rd;\n\t\tsur = scene(p);\n\t\tdepth += sur.sdf;\n\t\tif (sur.sdf < 0.001 || depth > MAX_DISTANCE) break;\n\t}\n\tsur.sdf = depth;\n\treturn sur;\n}\n//Remeber to correct gamma col = pow(col, vec3(1.0/2.2));\nfloat softShadows(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfloat k = 5.; //Hardness of shadow, greater numbers make it harder\n\tfor(int i = 0; i < 16; i++) {\n\t\tfloat h = scene(ro+rd*t).sdf;\n\t\tres = min(res,k*h/t);\n\t\tt += clamp(h,0.02,0.10);\n\t\tif(h<0.001||t>tmax) break;\n\t}\n\treturn clamp(res,0.3,1.0);//Scaling factor 0 -> Totally black\n}\nvec3 phongLighting(vec3 ro,vec3 rd,Surface scene,vec3 lightPos){\n\tfloat d = scene.sdf;\n\t//Point on surface\n\tvec3 p = ro+rd*d;\n\tvec3 n = normal(p);\n\t//Light direction\n\tvec3 lightDirection = normalize(lightPos-p);\n\t//Ambient\n    vec3 ambient = scene.mat.ambientColor;\n    // diffuse\n\tfloat dotLN = clamp(dot(lightDirection,n),0.,1.);\n\tvec3 diffuse = dotLN*scene.mat.diffuseColor;\n\t// specular\n\tfloat dotRV = clamp(dot(reflect(lightDirection, n),rd),0.,1.);//+clamp(dot(reflect(lightDirection, n),-rd),0.,1.);\n\tvec3 specular = pow(dotRV,scene.mat.alpha)*scene.mat.specularColor;\n\t//ret\n\treturn (ambient+diffuse+specular);//*softShadows(p,lightDirection,0.5,2.5);\n\t//With shadows -> (ambient+diffuse+specular)*softShadows(p,lightDirection,0.02,2.5);\n}\nvec3 fresnelLighting(vec3 ro,vec3 rd,float d,float exp,vec3 col){\n\treturn col*pow(clamp(1.-dot(normal(ro+rd*d),-rd),0.,1.),exp);\n}\nmat3 cameraLookAt(vec3 ro, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - ro); // camera direction\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n\tvec3 cu = normalize(cross(cd, cr)); // camera up\n\treturn mat3(-cr,cu,-cd);\n}\n/*--------------------------------------------------------\nPOST PROCESSING\n--------------------------------------------------------*/\nfloat light(vec3 point, vec3 lightpos, vec3 n, vec3 cam) {\n    vec3 l = normalize(lightpos-point);\n    // Standard diffuse term\n    float diffuse = max(dot(n, l), 0.);\n    float specular = pow(max(dot(reflect(-l, n), -cam), 0.), 10.);\n\n    return 0.5 * diffuse + 0.5 * specular;\n}\nvec3 reflections(vec3 p,vec3 rd){\n\t//ro -> p, rd -> reflect(rd,normal(p))\n\n\tvec3 col = vec3(0.);\n\tvec3 camDir = rd;\n\trd = reflect(rd,normal(p));\n\tSurface scene = rayMarch(p+rd*0.001*2.,rd);\n\tif(scene.sdf < MAX_DISTANCE){\n\t\tcol = phongLighting(p,rd,scene,uLight);\n\t}\n\treturn col;\n}\nvec3 fog(vec3 col,vec3 fogCol,Surface sur){\n\treturn mix(col, fogCol, 1.0 - exp(-0.00003 * sur.sdf * sur.sdf * sur.sdf)); \n}\n/*--------------------------------------------------------\nLET'S CODE\n--------------------------------------------------------*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n\tvec3 col = vec3(0.0);\n\n\t//Camera\n\tvec3 ro = vec3(0.,3.,15.);\n\tvec3 rd = cameraLookAt(ro,vec3(0.,0.,0.))*normalize(vec3(uv,-5.));\n\n\t//Ray Marching the scene\n\tSurface scene = rayMarch(ro,rd);\n\n\tif(scene.sdf < MAX_DISTANCE){\n\t\tcol = phongLighting(ro,rd,scene,uLight);\n\t\t//col += fresnelLighting(ro,rd,scene.sdf,3.,vec3(1.));\n\t\tvec3 p = ro+rd*scene.sdf;\n\t\tif(scene.mat.reflectiveness > 0.)\n\t\t\tcol = mix(col,vec3(reflections(p,rd)),0.5*smoothstep(0.65,1.,scene.mat.reflectiveness));\n\t\t//if(length(p.xz)>2.7) col *= vec3(1.,0.,0.);\n\t\t//col *= vec3(1.,0.,0.)*exp(length(p.xz)-1.5);\n\t}\n\tcol *= fog(col,vec3(0.),scene);\n\n\t//fragColor = TDOutputSwizzle(vec4(col,1.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}