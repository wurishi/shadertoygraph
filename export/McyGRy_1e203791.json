{"ver":"0.1","info":{"id":"McyGRy","date":"1712906506","viewed":59,"name":"Bandlimited Stripes 1","username":"ola","description":"This is a reference I created to see what a bandlimited stripe signal in perspective looks like, using additive synthesis. The smoothing of the waves (transition band) ought to be extended as the waves end somewhat abruptly. \n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["antialiasing","floor","bandlimitedwaves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bandlimited Stripes 1.\n// All rights reserved Ola Fosheim Grøstad 20©24. The artwork as a whole is restricted under copyright.\n// The functions \"est_wavelimit1\", \"est_wavelimit2\", \"groundfloor\" are unrestricted and can be used for whatever purpose, except for recreating this work.\n\n\n#define PI 3.14159265359\n\nfloat est_wavelimit1(vec4 y) {\n    vec2 mx = max(y.xy, y.zw);\n    vec2 mn = min(y.xy, y.zw);\n    return max(mx.x, mx.y) - min(mn.x, mn.y);\n}\n\nfloat est_wavelimit2(vec4 y) {\n    // move largest components to first to positions\n    y.xy = y.x > y.y ? y.xy : y.yx;\n    y.zw = y.z > y.w ? y.zw : y.wz;\n    y.yz = y.y > y.z ? y.yz : y.zy;\n    y.xw = y.x > y.w ? y.xw : y.wx;\n    return 0.5*(y.x + y.y - y.z - y.w);\n}\n\nvec3 groundfloor(float y0, float dy) {\n    float limit = min((PI/64.0)*(1.0/dy), 32.0);\n    float limit2 = min((PI/24.0)*(1.0/dy), 32.0);\n    \n    float f = (2.0*2.0*PI)*y0;\n    float w = 0.0;\n    \n    float i=1.0;\n    for (; i<limit; i+=2.0) {\n       w += (1.0/i) * sin(f*i);\n    }\n    float w2 = (1.0/i) * sin(f*i);\n    w += w2*(1.0-smoothstep(limit, limit2, i));\n\n\n    return 0.5 + 0.5*vec3(w, w, w);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    float focal = 1.0;\n    \n    vec2 uv0 = (2.0*fragCoord - iResolution.xy)/iResolution.yy;\n    vec2 uv1 = (2.0*fragCoord+vec2(-0.5,-0.5) - iResolution.xy)/iResolution.yy;\n    vec2 uv2 = (2.0*fragCoord+vec2(-0.5,0.5) - iResolution.xy)/iResolution.yy;\n    vec2 uv3 = (2.0*fragCoord+vec2(0.5,0.5) - iResolution.xy)/iResolution.yy;\n    vec2 uv4 = (2.0*fragCoord+vec2(0.5,-0.5) - iResolution.xy)/iResolution.yy;\n    \n    vec3 r0 = normalize(vec3(uv0.x,focal,uv0.y));\n    vec3 r1 = normalize(vec3(uv1.x,focal,uv1.y));\n    vec3 r2 = normalize(vec3(uv2.x,focal,uv2.y));\n    vec3 r3 = normalize(vec3(uv3.x,focal,uv3.y));\n    vec3 r4 = normalize(vec3(uv4.x,focal,uv4.y));\n    \n    float t = 0.1*iTime;\n    mat2 rot = mat2(cos(t), -sin(t), sin(t), cos(t));\n    r0.xy = r0.xy*rot;\n    r1.xy = r1.xy*rot;\n    r2.xy = r2.xy*rot;\n    r3.xy = r3.xy*rot;\n    r4.xy = r4.xy*rot;\n    \n    vec3 ro = vec3(0.0, 0.0, 1.8);\n    float y0 = (ro - (ro.z/r0.z)*r0).y;\n    float y1 = (ro - (ro.z/r1.z)*r1).y;\n    float y2 = (ro - (ro.z/r2.z)*r2).y;\n    float y3 = (ro - (ro.z/r3.z)*r3).y;\n    float y4 = (ro - (ro.z/r4.z)*r4).y;\n    float dy = est_wavelimit2(vec4(y1,y2,y3,y4));\n\n    vec3 col = (r1.z < 0.0) ? groundfloor(y0,dy) : vec3(0.0, r1.z, 1.0);\n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}