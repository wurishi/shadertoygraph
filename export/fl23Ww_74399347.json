{"ver":"0.1","info":{"id":"fl23Ww","date":"1624025987","viewed":141,"name":"[phreax] gemification","username":"phreax","description":"Playing around with refractions, inspired by BigWIngs awesome tutorial:\n\nyoutube.com/watch?v=0RWaR7zApEo","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define TAU PI*2.\n#define SIN(x) (sin(x)*.5+.5)\n\n#define S(a, b, x) smoothstep(a, b, x)\n\n// interval, 1 if x in [a, b], 0 otherwise\n#define I(a, b, x) step(a, x)*step(x, b)\n\n\n// fadeIn in only defined in interval [a, b]\nfloat fadeInt(float a, float b, float x) {\n    return S(a, b, x)*I(a, b, x);\n}\n\n\nfloat tt;\n\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\nfloat smoothrect(float x) {\n    return smoothstep(0., .25, mod(x, 1.5))*smoothstep(.25, 0., mod(x, 1.5)-.75);\n}\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 d = abs(p) - r;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\n\nvec3 kaleid(vec3 p) {\n    for(int i=0; i<4; i++) {\n        p = abs(p) - .1;\n        p.xy *= rot(TAU*1./3.);\n        p.yz *= rot(TAU*1./16.+(tt-7.5)*.2);\n    }\n    return p;\n}\n\nvec3 fold(vec3 p) {\n\n    float c = cos(PI/5.), s = sqrt(.75 - c*c);\n    \n    vec3 n = vec3(-.5, -c, s);\n    \n    p = abs(p);;\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    return p;\n}\n\nfloat map(vec3 p) {\n    \n    vec3 bp = p;\n    \n    bp.xy *= rot(tt);\n    bp.zy *= rot(tt * .5);\n    \n\n    float db = box(bp, vec3(1.0));\n    float dc = box(fold(bp), vec3(1.0));\n    \n    p = fold(p);\n    \n    p = kaleid(p);\n    \n    float d = box(p, vec3(1.0));\n\n\n    return mix(mix(db, dc, smoothstep(2., 3., tt)), d, fadeInt(5., 6., tt)+step(6., tt));\n\n}\n\nvec3 getNormal(vec3 p) {\n    \n    float eps = 0.007;\n    vec2 e = vec2(eps, -eps);\n    return normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n\n    \n    // camera system\n    vec3 f = normalize(l - p),  // forward vector\n         r = normalize(cross(vec3(0, 1, 0), f)), // right vector\n         u = cross(f, r), // up vector\n         c = p + f * z, // center of virtual screen\n         i = c + uv.x * r + uv.y * u, // intersection with screen\n         rd = normalize(i - p);  // ray direction\n         \n    return rd;\n    \n}\n\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 p, float sig) {\n    float i, t, d = 0.1;\n\n    p = ro;\n    \n    for(i=0.; i<100.; i++) {\n    \n        d = sig*map(p);\n        \n        if(abs(d) < 0.001 || t > 50.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    return d;\n\n}\n\nvec3 refractCol(vec3 p, vec3 rd, vec3 n, float ior) {\n\n        vec3 rdIn = refract(rd, n, 1./ior);\n        \n        vec3 pEnter = p - n * 0.003;\n        \n        vec3 pExit;\n        float dIn = rayMarch(pEnter, rdIn, pExit, -1.0);\n        \n        vec3 nExit = -getNormal(pExit);\n        vec3 rdOut = refract(rdIn, nExit, ior);\n        \n        if(dot(rdOut, rdOut) == 0.0) rdOut = reflect(rdIn, nExit);\n\n        return texture(iChannel0, rdOut).rgb;\n        \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tt = iTime;\n    tt = mod(tt, 30.0);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -7);\n    vec3 lookat = vec3(0, 0, 0);\n    vec3 ls = vec3(1, .5, -1.0);\n        \n    ro.yz *= rot(-m.y*PI+1.);\n    ro.xz *= rot(-m.x*TAU);\n    \n    vec3 rd = getRayDir(uv, ro, lookat, .8);\n\n    vec3 col, p;\n    \n    float d = rayMarch(ro, rd, p, 1.0);\n    \n\n\n    \n    if(d < 0.001) {\n        \n        vec3 n = getNormal(p);\n        vec3 l = normalize(ls);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        vec3 colR, colG, colB;\n        \n        float roff = 0.02;\n        colR = refractCol(p, rd, n, 1.45);\n        colG = refractCol(p, rd, n, 1.45+roff);\n        colB = refractCol(p, rd, n, 1.45+2.*roff);\n        \n        col.r = colR.r;\n        col.g = colG.g;\n        col.b = colB.b;\n   \n        col = mix(col, texture(iChannel0, reflect(rd, n)).rgb*(normalize(n+vec3(0.196,1.000,0.141)))+spe+dif, .4*SIN((tt-6.)*.25));\n   \n    } else {\n    \tcol = texture(iChannel0, rd).rgb;\n    }\n    \n\n    col = pow(col, vec3(0.4545)); \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}