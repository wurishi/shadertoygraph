{"ver":"0.1","info":{"id":"3sSfWy","date":"1590691201","viewed":200,"name":"Heat conduction & Average Temp","username":"kastorp","description":"I would like to model communicating vessels, but better start with something simpler ","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["heat","average"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*-----------------------------------------------------------\n\nsimplified simulation of heat conduction in an homogeneous solid\nwith isolating barriers\n\nthe average temperature is also calculated \nwith some latency using a binary tree sum on both coordinates \n\n\ndrag mouse to add heat source\n\n\nCredits: \n\t- the maze: https://www.shadertoy.com/view/lt2cRR\n\t- all Wyatt shaders on fluid modelling (far more complex than this)\n-------------------------------------------------------------*/\nMain {\n    \n   \t\n    //if( U.y<RZ.y*ZOOM+10.){\n        \n        vec4 data=A(U / ZOOM );\n        float t = log(data.x)+1.;\n        Q.w=1.;\n    \tQ = mat4(1. , 0., 0., 0., //temp\n                 1. , 1., 0., 0., //temp > .5\n                 0. , .2, 0., 0., // temp <.5\n                 0. , 0., 1., 0. ) //barrier\n            *vec4(clamp(t,0.,1.), clamp(t -.6,0.,1.), clamp(.6- t,0.,1.) ,data.y );\n    //}\n    float avg=A(vec2(0.,(RZ.y+2.))).z*100.;\n    \n    float FONTX,FONTY,FONTZ,FONTSX,FONTSY, FONTLINE; vec4 FONTC;\n    vec4 f=vec4(0.);   \t\n    \n    fontXYZ(50.,R.y-7. ,1.);\n    \n    fontColor(1.,1.,0.);\n    \n  \n    fontString(f, vec4[]  (_A,_v,_e,_r,_a,_g,_e,_spc));\n    fontString(f, vec4[]  (_T,_e,_m,_p,_col,_spc));\n    fontNum(f, avg);\n\n    for(float i = 0.;i<4.; i++){\n        vec2 p=vec2(R.x*.3+ i*R.x*.2,R.y-5.);\n    \tfontXYZ(p.x,p.y-16., 1.);\n        \n        float t = A(p / ZOOM ).x;\n        fontNum(f,t*100.);\n    }\n    \n    fontXYZ(iMouse.x-20.,iMouse.y+10.,1.);\n    fontColor(1.,1.,1.);\n    fontNum(f, A(iMouse.xy/ZOOM).z*100.);\n     Q.xyz+=f.xyz;\n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define ZOOM  4.2\n#define MS  4.\n#define RZ (R/ZOOM  -vec2(0.,10.))\n\n#define AVG\n#define A(U) texture(iChannel0,(U)/R)\n#define TS vec2(textureSize(iChannel0,0))\n#define Neighborhood vec4 n[4] = vec4[] (A(U+vec2(0,1)),  A(U+vec2(1,0)), A(U-vec2(0,1)),  A(U-vec2(1,0)));\n#define Neighborhood2 vec4 n2[8] = vec4[] (A(U+vec2(0,2)),  A(U+vec2(1,1)), A(U+vec2(2,0)),  A(U+vec2(1,-1)),\\\n\t\t\t\t\t\t\t\t\t\t  A(U+vec2(0,-2)),  A(U+vec2(-1,-1)), A(U+vec2(-2,0)),  A(U+vec2(-1,1)));\n\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n#define FN(x,y) ((x+y)/2.) //AVERAGE TEMP\n//#define FN(x,y) max(x,y) //MAX TEMP -not working yet\n//#define FN(x,y) (x>0.&& y>0.?min(x,y):x>0.?x:y)   //MIN TEMP - not working yet\n\n\n#define _(ch) vec4(printCh(ch, FONTX-=(FONTSX+1.)*8., FONTY-= FONTSY*12.,FONTLINE++))* FONTC\n#define fontNum(f,n) printNum(n,f,FONTX,FONTY,FONTC,FONTLINE,FONTSX,FONTSY)\n#define fontXYZ(px,py,fz) FONTZ= fz;FONTLINE=0.; FONTX=floor(U.x/FONTZ -(px-8.)/FONTZ );FONTY=floor(U.y/FONTZ -(py-12.)/FONTZ )\n#define fontMove(cx,cy) FONTX-=floor(cx*8.); FONTY+=floor(cy*12.)\n#define fontLF() FONTX+=  8.*FONTZ*FONTLINE; FONTY+=(12.*FONTZ);FONTLINE=0.;\n#define fontColor(r,g,b) FONTC=vec4(r,g,b,0.)\n#define fontSpacing(sx,sy) FONTSX=sx;FONTSY=-sy\n#define fontString(f,st) \t{for(int _f_i= 0;_f_i<st.length();_f_i++ )f+= _(st[_f_i]);}\n\n//--------------------------------\n// reference table here:\n//\n// http://www.massmind.org/images/member/ng--944/font8x12.png\n//\n//-------------------------------\nconst vec4 _spc = vec4(0x000000,0x000000,0x000000,0x000000);\nconst vec4 _exc = vec4(0x003078,0x787830,0x300030,0x300000);\nconst vec4 _quo = vec4(0x006666,0x662400,0x000000,0x000000);\nconst vec4 _hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nconst vec4 _dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nconst vec4 _pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nconst vec4 _amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nconst vec4 _apo = vec4(0x003030,0x306000,0x000000,0x000000);\nconst vec4 _lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nconst vec4 _rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nconst vec4 _ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nconst vec4 _crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nconst vec4 _com = vec4(0x000000,0x000000,0x000038,0x386000);\nconst vec4 _dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nconst vec4 _per = vec4(0x000000,0x000000,0x000038,0x380000);\nconst vec4 _lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nconst vec4 _0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nconst vec4 _1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nconst vec4 _2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nconst vec4 _3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nconst vec4 _4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nconst vec4 _5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nconst vec4 _6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nconst vec4 _7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nconst vec4 _8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nconst vec4 _9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nconst vec4 _col = vec4(0x000000,0x383800,0x003838,0x000000);\nconst vec4 _scl = vec4(0x000000,0x383800,0x003838,0x183000);\nconst vec4 _les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nconst vec4 _equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nconst vec4 _grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nconst vec4 _que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nconst vec4 _ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nconst vec4 _A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nconst vec4 _B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nconst vec4 _C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nconst vec4 _D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nconst vec4 _E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nconst vec4 _F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nconst vec4 _G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nconst vec4 _H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nconst vec4 _I = vec4(0x007830,0x303030,0x303030,0x780000);\nconst vec4 _J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nconst vec4 _K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nconst vec4 _L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nconst vec4 _M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nconst vec4 _N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nconst vec4 _O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nconst vec4 _P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nconst vec4 _Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nconst vec4 _R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nconst vec4 _S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nconst vec4 _T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nconst vec4 _U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nconst vec4 _V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nconst vec4 _W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nconst vec4 _X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nconst vec4 _Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nconst vec4 _Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nconst vec4 _lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nconst vec4 _rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nconst vec4 _rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nconst vec4 _pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nconst vec4 _usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nconst vec4 _a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nconst vec4 _b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nconst vec4 _c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nconst vec4 _d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nconst vec4 _e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nconst vec4 _f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nconst vec4 _g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nconst vec4 _h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nconst vec4 _i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nconst vec4 _j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nconst vec4 _k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nconst vec4 _l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nconst vec4 _m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nconst vec4 _n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nconst vec4 _o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nconst vec4 _p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nconst vec4 _q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nconst vec4 _r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nconst vec4 _s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nconst vec4 _t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nconst vec4 _u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nconst vec4 _v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nconst vec4 _w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nconst vec4 _x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nconst vec4 _y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nconst vec4 _z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nconst vec4 _lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nconst vec4 _bar = vec4(0x001818,0x181800,0x181818,0x180000);\nconst vec4 _rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nconst vec4 _tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nconst vec4 _lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nfloat printCh(in vec4 ch, in float x, in float y, float line)\n{\n    if(x<0.0 || y<0.0 || x>7.0 || y>11.0) return 0.;\n    float word = (y>5.9?y>8.9?ch.x:ch.y:y>2.9?ch.z:ch.a);\n    float n = floor(7.0-x + 8.0*mod(y,3.0));\n    return mod(floor(word/pow(2.0,n)), 2.0);\n}\n\nvoid printNum(in float n ,inout vec4 f, inout float FONTX, inout float FONTY,vec4 FONTC,inout float FONTLINE,  float FONTSX, float FONTSY){\n\n    if(n<0.) {f+=_(_dsh);n=abs(n);}\n    \n    float c=floor(max(log(n)/log(10.0),0.0));\n    \n    if(c>0.0) n/=pow(10.0,c);\n    for(float i=0.0;i<5.0;i++){\n        if(i>c+2.)continue;\n\t\tfloat d=floor(n);\n        vec4 sprite= d<.5?_0:d<1.5?_1:d<2.5?_2:d<3.5?_3:d<4.5?_4:\n    \t\td<5.5?_5:d<6.5?_6:d<7.5?_7:d<8.5?_8:_9;\n       \n\t\tf+=_(sprite);\n\t\tn=(n-d)*10.0;\n        if(i==c)  f +=_(_per);      \n    }\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"Main {\n\n\tfloat k=  1.; //0. no conduction, 1- max conduction, >1 strange patterns :-)\n    float k2= 10.; //0: exclude 2nd leve neightbours, 1: 2nd are equal to 1st, >1 bypass 1st neightbours\n    Q = A(U); //x= temperature, y=border 0-1, w=average buffer\n\n    if(Q.y<1. && U.y>0. && U.y <RZ.y && U.x>1.){\n        Neighborhood;   \n         \n        //nice configurations:\n        //k=1.4; k2=2.; //angle squares\n        //k=1.4; k2=4.; //rooms\n        //k=1.05; k2=.01; //fast fill\n        //k=25.; k=1.1; //slow fill\n        //k=1.5; k2= 0.05; // worms \n        //k=1.7; k2= 10.; // stripes  & squares\n        //k=25.; k2=.1; //waves\n        //k=5.; k2=.05; //octagons\n       \n\t\tif(k2>0.){\n\n            // uses furter 8 2nd level neightbors, only reachable ones are considered\n            // a little bit faster propagation (around 2x)\n            // more accurate for k>1\n            Neighborhood2;\n\n            float i=  4. - (n[0]+n[1]+n[2] +n[3]).y \n                   +( 8.   - max(n2[0],n[0]) - max(n2[1], n[0]*n[1])\n                           - max(n2[2],n[1]) - max(n2[3], n[1]*n[2])\n                           - max(n2[4],n[2]) - max(n2[5], n[2]*n[3])\n                           - max(n2[6],n[3]) - max(n2[7], n[3]*n[0])\n                          ).y*k2;\n\n            float t =  (n[0]+n[1]+n[2] +n[3]).x  \n                      +\t( n2[0].x *(1.- n[0].y) + n2[1].x* (1. -n[0]*n[1]).y  \n                        + n2[2].x *(1.- n[1].y) + n2[3].x* (1. -n[1]*n[2]).y  \n                        + n2[4].x *(1.- n[2].y) + n2[5].x* (1. -n[2]*n[3]).y  \n                        + n2[6].x *(1.- n[3].y) + n2[7].x* (1. -n[3]*n[0]).y)*k2 ;\n\n           Q.x =clamp(Q.x*(1.-k) +   k *(t/i),0.,200.);\n        }else{\n            // slower, uses only 4 1st level neightbors\n            //float i= 4.; //CASE1: barriers are considered at T=0.  \n            float i= 4.- (n[0]+n[1]+n[2] +n[3]).y; //CASE2: barriers are excluded from computation       \n            Q.x =clamp(Q.x*(1.-k) +  k/i*(n[0]+n[1]+n[2] +n[3]).x,0.,200.);\n   \t\t }        \n        \n    } else Q.x=0.;\n    \n   \n    //INITIALIZE:\n    if (iFrame < 1 || TS.x != A(vec2(0.)).z){\n        Q=vec4(0.);\n        if( U.x<=2. || U.x >=RZ.x-2. ||  U.y<= 2. ||  U.y>=RZ.y-2. ) Q=vec4(0.,1.,0.,0.);\n        \n        \n        Q.y= step(.5, Q.y +step( mod( (U/MS) [ int( 1e4*length(ceil(U/8./MS)) ) % 2 ] , 8. ),.5));\n       \n    }\n    if(iFrame < 2000  && length(U-0.5*RZ)<.05*RZ.x) Q.x=hash12(U+iTime);\n\n#ifdef AVG\n    //AVERAGE VERT, stored in Q.x at U.y=0 for each column\n     if(U.y< RZ.y && U.x>1.){\n        float st1= floor(mod( float(iFrame), log2(RZ.y)+1.));\n        if(mod(U.y, pow(2.,st1))<1. ) \n             if(st1==1.) Q.w =FN(A(U).x , A(U+vec2(0,1)).x);\n             else{\n                 float ind = U.y + pow(2.,st1-1.); \n                 if( ind <=  RZ.y) Q.w=FN(A(U).w , A( vec2(U.x,ind)).w);\n                 else Q.w=FN(A(U).w,0.);\n              }\n         if(U.y<1.){\n             if(pow(2.,st1)>= RZ.y) Q.x=Q.w *pow(2.,st1)/RZ.y; \n             else Q.x=A(U).x;\n         }\n    }\n    \n    //AVERAGE OF AVERAGE, stored in q.x at U.y=RZ.y for groups of columns    \n    if(U.y>=RZ.y){\n\t\t\n    \tfloat st2= floor(mod( float(iFrame), log2(RZ.x)+1.));\n        if(mod(U.x, pow(2.,st2))<1. ) \n             if(st2==1.) Q.w = FN(A(vec2(U.x,0.)).x, A(vec2(U.x+1.,0.)).x);\n             else{\n                 float ind = U.x + pow(2.,st2-1.); \n                 if( ind <=  RZ.x) Q.w=FN( A(U).w,  A( vec2(ind,U.y)).w);\n                 else Q.w=FN(A(U).w,0.);\n              }\n        if(U.x<1.){ \n        \tif(pow(2.,st2)>= RZ.x ) Q.x=Q.w*pow(2.,st2) /RZ.x;\n            else Q.x=A(U).x;\n        }\n    }\n#endif    \n    \n    //SCALE:\n    if(U.y>=RZ.y+5. && U.x>RZ.x*.3) {Q.x=(U.x-RZ.x*.3)/(RZ.x*.7)*2.;Q.y=0.;}\n    \n    //print z if temeperature change too fast\n    if(mod(float(iFrame),20.)<1.) Q.z=Q.x;\n    \n   \t//CHANGE RESOLUTION DETECTION:\n    if(max(U.x,U.y)<1.) Q.zw= TS.xy;\n    \n    //MOUSE FILLER\n    if (iMouse.z/ZOOM>0. && length(U-iMouse.xy/ZOOM)<10. && U.x >1.)\n        {Q.x += hash12(U+iTime)/10.;}\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}