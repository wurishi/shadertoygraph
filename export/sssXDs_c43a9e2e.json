{"ver":"0.1","info":{"id":"sssXDs","date":"1619507017","viewed":38,"name":"test_builtin_function","username":"winsen","description":"test_builtin_function","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float logEx(in float a, in float b)\n{\n    return log2(b) / log2(a);\n}\n\nfloat testModf(in float a, out float b)\n{\n    float g;\n    float r = modf((a - 0.5) * 10.0, g);\n    r = abs(r);\n    g /= 5.0;\n    g = abs(g);\n    b = g;\n    return r;\n}\n\n\nfloat testSmoothstep(float a, float b, float x)\n{\n    float t = fract((x - a)/(b - a));\n    return t*t*(3.0 - (2.0*t));\n}\n\n\nvec2 testFaceforward(in vec2 n, in vec2 i, in vec2 refN)\n{\n    return -n * sign(dot(i, refN));\n}\n\n\nvec2 testReflect(in vec2 i, in vec2 n)\n{\n    return i - 2.0 * dot(i, n) * n;\n}\n\nvec3 testRefract(in vec3 i, in vec3 n, in float eta)\n{\n    float cosi = dot(-i, n);\n    float cost2 = 1.0 - eta * eta * (1.0 - cosi * cosi);\n    vec3 t = eta * i + ((eta * cosi - sqrt(abs(cost2))) * n);\n    return t * vec3(cost2 > 0.0);\n}\n\nvec4 mat2ToVec4(mat2 m)\n{\n    return vec4(m[0][0], m[0][1], m[1][0], m[1][1]);\n}\n\nmat2 testMatrixCompMult(mat2 a, mat2 b)\n{\n    return mat2(a[0][0] * b[0][0], a[0][1] * b[0][1], a[1][0] * b[1][0], a[1][1] * b[1][1]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 inverse_iResolution;\n    inverse_iResolution.xy = 1.0 / iResolution.xy;\n    float e = 2.718281828459;\n    \n    \n    \n    //uv\n    //fragColor.rg = uv.xy;\n    \n    \n    \n    \n    \n    \n    \n    //sin\n    float sinY = sin((uv.x - mod(iTime, 1.0)) * radians(360.0));\n    sinY = sinY * 0.5 + 0.5;\n    float lineDist = abs(length(iResolution.xy * (uv - vec2(uv.x, sinY))));\n    float halfLineWidth = length(20.0);\n    //float lineDist = abs(length(uv - vec2(uv.x, sinY)));\n    //float halfLineWidth = length(20.0 / iResolution.xy);\n    fragColor.r = 1.0 - lineDist / halfLineWidth;\n    \n    //fragColor.r = sin(uv.x * radians(360.0)) * 0.5 + 0.5; //0.5 -> 1 -> 0 -> 0.5\n    \n    //cos    \n    //fragColor.g = cos(uv.y * radians(360.0)) * 0.5 + 0.5; //1 -> 0 -> 1\n    \n    //tan\n    //fragColor.b = tan(uv.x * radians(90.0));  //[0,1] -> [0,45] -> [0,1]\n    \n    //asin\n    //fragColor.r = asin(uv.x) / radians(90.0); //[0, 1] -> [0, 3.14 / 2] -> [0, 1]\n    \n    //acos    \n    //fragColor.g = acos(uv.y) / radians(90.0); //[0, 1] -> [3.14 / 2, 0] -> [1, 0]\n    \n    //atan\n    //fragColor.b = atan(fragCoord.y / fragCoord.x) / radians(90.0);  //\n    \n    //atan2\n    //fragColor.b = atan(fragCoord.y, fragCoord.x) / radians(90.0);  //\n    \n    //sinh\n    //fragColor.r = sinh(uv.x);\n    \n    //cosh\n    //fragColor.g = cosh(uv.y * 1.5) - 1.0;\n    \n    //tanh\n    //fragColor.b = tanh(uv.x);\n    \n    //asinh\n    //fragColor.r = asinh(uv.x);\n    \n    //acosh\n    //fragColor.g = acosh(uv.y * 0.5 + 1.0);\n    \n    //atanh\n    //fragColor.b = atanh(uv.x);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //pow\n    //fragColor.r = pow(uv.x, uv.y);\n    \n    //e\n    //fragColor.r = exp(1.0) / e; //result: 1\n    //fragColor.r = 1.0;\n    \n    //exp(x) == pow(e, x)\n    //fragColor.r = exp(uv.x) - 1.0;\n    //fragColor.r = pow(e, uv.x) - 1.0;\n    \n    //log(x) == logEx(e, x)\n    //fragColor.r = log(uv.x + 1.0);\n    //fragColor.r = logEx(e, uv.x + 1.0);\n    \n    //exp2(x) == pow(2, x)\n    //fragColor.r = exp2(uv.x) - 1.0;\n    //fragColor.r = pow(2.0, uv.x) - 1.0;\n    \n    //log2(x) == logEx(2, x)\n    //fragColor.r = log2(uv.x + 1.0);\n    //fragColor.r = logEx(2.0, uv.x + 1.0);\n    \n    //sqrt inversesqrt\n    //fragColor.r = sqrt(uv.x);\n    //fragColor.r = 1.0 / inversesqrt(uv.x);\n    //fragColor.r = pow(uv.x, 0.5);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //abs\n    //fragColor.r = abs(uv.x - 0.5) * 2.0;\n    \n    //sign\n    //fragColor.r = (sign(floor(uv.x * 3.0) - 1.0) + 1.0) * 0.5;\n    \n    //floor\n    //fragColor.r = floor((uv.x - 0.5) * 10.0) / 10.0 + 0.5;\n    \n    //ceil\n    //fragColor.r = ceil((uv.x - 0.5) * 10.0) / 10.0 + 0.5;\n    \n    //trunc\n    //fragColor.r = trunc((uv.x - 0.5) * 10.0) / 10.0 + 0.5;\n    \n    //fract\n    //fragColor.r = fract((uv.x - 0.5) * 10.0) / 10.0 + 0.5;\n    \n    //mod\n    //fragColor.r = mod((uv.x - 0.5) * 10.0, 1.0);\n    \n    //modf\n    //fragColor.r = testModf(uv.x, fragColor.g);\n    \n    //min\n    //fragColor.r = min(uv.x, 0.6);\n    \n    //max\n    //fragColor.r = max(uv.x, 0.4);\n    \n    //clamp\n    //fragColor.r = clamp(uv.x, 0.4, 0.6);\n    \n    //mix\n    //fragColor.rgb = mix(vec3(1, 0, 0), vec3(0, 0, 1), (uv.x + uv.y) / 2.0);\n    \n    //step\n    //fragColor.r = step(0.5, uv.x);\n    \n    //smoothstep\n    //fragColor.r = smoothstep(0.0, 1.0, uv.x);\n    //fragColor.r = testSmoothstep(0.0, 1.0, uv.x);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //length\n    //fragColor.r = length(uv);\n    \n    //distance\n    //fragColor.r = distance(uv, vec2(0.5, 0.5)) * 2.0;\n    \n    //dot\n    //fragColor.r = dot(uv, vec2(0.5, 0.5));\n    \n    //cross\n    //fragColor.rgb = cross((vec3(uv, 0) - vec3(0.5, 0.5, 0)) * 2.0, vec3(0, 0, 1));\n    \n    //normalize\n    //fragColor.rg = normalize(uv - vec2(0.5, 0.5));\n    \n    //faceforward\n    //fragColor.rg = faceforward(uv - vec2(0.5, 0.5), vec2(-0.5, -0.5), uv - vec2(0.5, 0.5));\n    //fragColor.rg = testFaceforward(uv - vec2(0.5, 0.5), vec2(-0.5, -0.5), uv - vec2(0.5, 0.5));\n    \n    //reflect\n    //fragColor.rg = reflect(normalize(vec2(0.5, 0.5) - uv), vec2(0, 1));\n    //fragColor.rg = testReflect(normalize(vec2(0.5, 0.5) - uv), vec2(0, 1));\n    \n    //refract:  air(1) to water(1.3)\n    //fragColor.rgb = refract(normalize(vec3(0.5, 0.5, 0.0) - vec3(uv, 0.0)), vec3(0, -1, 0), 1.0 / 1.3);\n    //fragColor.rgb = testRefract(normalize(vec3(0.5, 0.5, 0.0) - vec3(uv, 0.0)), vec3(0, -1, 0), 1.0 / 1.3);\n    \n    \n    \n    \n    //determinant\n    //mat2 m = mat2(uv.x, uv.y, -uv.x, uv.y);\n    //fragColor.r = determinant(m);\n    \n    //outerProduct\n    //mat2 m = outerProduct(uv, uv);\n    //fragColor = mat2ToVec4(m);\n    \n    //matrixCompMult\n    //mat2 m = mat2(uv.x, uv.y, uv.x, uv.y);\n    //m = matrixCompMult(m, m);\n    //m = testMatrixCompMult(m, m);\n    //fragColor = mat2ToVec4(m);\n    \n    //inverse\n    //mat2 m = mat2(uv.x, uv.y, -uv.x, uv.y);\n    //m = inverse(m);\n    //fragColor = mat2ToVec4(m);\n    \n    //transpose\n    //mat2 m = mat2(uv.x, uv.y, uv.x, uv.y);\n    //m = transpose(m);\n    //fragColor = mat2ToVec4(m);\n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    //texture: auto set lod\n    //fragColor = texture(iChannel0, uv);\n    \n    //texture with bias: auto set lod(plus bias)\n    //fragColor = texture(iChannel0, uv, mod(iTime, 10.0));\n    \n    //textureLod: manual set lod\n    //fragColor = textureLod(iChannel0, uv, mod(iTime, 10.0));\n    \n    //textureLodOffset\n    //fragColor = textureLodOffset(iChannel0, uv, mod(iTime, 10.0), ivec2(5, 5));\n    \n    //textureGrad\n    //fragColor = textureGrad(iChannel0, uv, vec2(inverse_iResolution.x * mod(iTime, 20.0), 0), vec2(0, inverse_iResolution.y * mod(iTime, 20.0)));\n    \n    //textureGradOffset\n    //fragColor = textureGradOffset(iChannel0, uv, vec2(inverse_iResolution.x * mod(iTime, 20.0), 0), vec2(0, inverse_iResolution.y * mod(iTime, 20.0)), ivec2(5, 5));\n\n    //textureProj\n    //fragColor = textureProj(iChannel0, vec3(uv, 0.3));\n    //fragColor = textureProj(iChannel0, vec4(uv, 0, 0.3));\n    \n    //textureProj with bias\n    //fragColor = textureProj(iChannel0, vec3(uv, 0.3), mod(iTime, 5.0));\n    //fragColor = textureProj(iChannel0, vec4(uv, 0, 0.3), mod(iTime, 5.0));\n    \n    //textureProjLod\n    //fragColor = textureProjLod(iChannel0, vec3(uv, 0.3), mod(iTime, 5.0));\n    //fragColor = textureProjLod(iChannel0, vec4(uv, 0, 0.3), mod(iTime, 5.0));\n    \n    //textureProjLodOffset\n    //fragColor = textureProjLodOffset(iChannel0, vec3(uv, 0.3), mod(iTime, 5.0), ivec2(5, 5));\n    //fragColor = textureProjLodOffset(iChannel0, vec4(uv, 0, 0.3), mod(iTime, 5.0), ivec2(5, 5));\n    \n    //textureProjGrad\n    //fragColor = textureProjGrad(iChannel0, vec3(uv, 0.3), vec2(inverse_iResolution.x * mod(iTime, 20.0), 0), vec2(0, inverse_iResolution.y * mod(iTime, 20.0)));\n    //fragColor = textureProjGrad(iChannel0, vec4(uv, 0, 0.3), vec2(inverse_iResolution.x * mod(iTime, 20.0), 0), vec2(0, inverse_iResolution.y * mod(iTime, 20.0)));\n    \n    //texelFetch textureSize\n    //int lod = int(mod(iTime, 10.0));\n    //fragColor = texelFetch(iChannel0, ivec2(uv * vec2(textureSize(iChannel0, lod))), lod);\n    \n    //texelFetchOffset textureSize\n    //int lod = int(mod(iTime, 10.0));\n    //fragColor = texelFetchOffset(iChannel0, ivec2(uv * vec2(textureSize(iChannel0, lod))), lod, ivec2(-5, -5));\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //isnan\n    //float b = floor(mod(iTime, 2.0));\n    //float a = b / 0.0;\n    //fragColor.r = float(isnan(a));\n    \n    //isinf\n    //float b = floor(mod(iTime, 2.0));\n    //float a = b / 0.0;\n    //fragColor.g = float(isinf(a));\n    \n    //intBitsToFloat floatBitsToInt\n    //fragColor.r = intBitsToFloat(floatBitsToInt(uv.x));\n    \n    //uintBitsToFloat floatBitsToUint\n    //fragColor.r = uintBitsToFloat(floatBitsToUint(uv.x));\n    \n    //packSnorm2x16 unpackSnorm2x16\n    //fragColor.rg = unpackSnorm2x16(packSnorm2x16(uv));\n    \n    //packUnorm2x16 unpackUnorm2x16\n    //fragColor.rg = unpackUnorm2x16(packUnorm2x16(uv));\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    //lessThan\n    //bvec3 b = lessThan(vec3(0.1, 2, 0.5), vec3(0.2, 1, 0.6));\n    //fragColor.rgb = vec3(b);\n    \n    //lessThanEqual\n    //bvec3 b = lessThanEqual(vec3(0.1, 1, 0.5), vec3(0.2, 1, 0.6));\n    //fragColor.rgb = vec3(b);\n    \n    //greaterThan\n    //bvec3 b = lessThan(vec3(0.1, 2, 0.5), vec3(0.2, 1, 0.6));\n    //fragColor.rgb = vec3(b);\n    \n    //greaterThanEqual\n    //bvec3 b = greaterThanEqual(vec3(0.1, 1, 0.5), vec3(0.2, 1, 0.6));\n    //fragColor.rgb = vec3(b);\n    \n    //equal\n    //bvec3 b = equal(vec3(0.1, 1, 0.5), vec3(0.1, 1, 0.5));\n    //fragColor.rgb = vec3(b);\n    \n    //notEqual\n    //bvec3 b = equal(vec3(0.1, 0, 0.5), vec3(0.1, 1, 0.5));\n    //fragColor.rgb = vec3(b);\n    \n    //any\n    //bool b = any(bvec3(0, 0, 0.5));\n    //fragColor.rgb = vec3(b);\n    \n    //all\n    //bool b = all(bvec3(0.1, 2, 0.5));\n    //fragColor.rgb = vec3(b);\n    \n    //not\n    //bvec3 b = not(bvec3(1, 1, 0));\n    //fragColor.rgb = vec3(b);\n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}