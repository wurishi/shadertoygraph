{"ver":"0.1","info":{"id":"ldGyRw","date":"1521567540","viewed":108,"name":"Portfolio hero II","username":"kow","description":"Header animation for my personal site","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//-----------------------------------------------------------------------------------\n\n#define font_size 20. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n#define P_ vec2(0.,5.)\n#define Q_ vec2(1.,5.)\n#define R_ vec2(2.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(A_,M_,p) + t(M_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n#define S1(p) t(C_,A_,p) + t(A_,J_,p) + t(J_,L_,p) + t(I_,H_,p) + t(H_,E_,p) + t(E_,F_,p) + t(O_,M_,p) + t(M_,P_,p) + t(P_,R_,p)\n#define S2(p) t(A_,C_,p) + t(D_,F_,p) + t(G_,H_,p) + t(H_,Q_,p) + t(Q_,P_,p) + t(J_,M_,p) \n#define S3(p) t(A_,C_,p) + t(D_,F_,p) + t(F_,I_,p) + t(I_,G_,p) + t(G_,P_,p) + t(P_,R_,p) + t(L_,K_,p) + t(K_,N_,p) + t(N_,O_,p)\n#define S4(p) t(A_,B_,p) + t(B_,K_,p) + t(K_,J_,p) + t(D_,G_,p) + t(M_,N_,p) + t(N_,Q_,p) + t(Q_,P_,p)\n#define UL(p) t(C_,A_,p) + t(A_,D_,p) + t(D_,F_,p) \n#define UM(p) t(A_,C_,p) + t(D_,F_,p)\n#define UR(p) t(A_,B_,p) + t(B_,E_,p) + t(E_,D_,p)\n\nvec2 caret_origin = vec2(3.0, .7);\nvec2 caret;\nfloat t_time = 0.; // Text drawing delay timer\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\nfloat when_lt(float x, float y) \n{\n\treturn max(sign(y - x), 0.0);\n}\n\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n    float condition = when_lt(count, t_time*15.0);\n\n\treturn textColor(grid(from), grid(to), p) * condition;\n}\n\n\n//-----------------------------------------------------------------------------------\nvec2 r(vec2 fragCoord)\n{\n\tvec2 pos = fragCoord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\n\n\n// UV warping \nvec2 kaleido(vec2 uv)\n{\n\tfloat th = atan(uv.y, uv.x);\n\tfloat r = pow(length(uv), .9);\n\tfloat f = 3.14159 / 3.5;\n\n\tth = abs(mod(th + f/4.0, f) - f/2.0) / (1.0 + r);\n\tfloat th2 = sin(th * 6.283 / f);\n\n    th += th2;\n    \n\treturn vec2(cos(th), sin(th)) * r * .1;\n}\n\n// for kaleidoscope\nvec2 transform(vec2 at)\n{\n\tvec2 v;\n\tfloat th = .02 * iTime;\n\tv.x = at.x * cos(th) - at.y * sin(th) - .2 * sin(th);\n\tv.y = at.x * sin(th) + at.y * cos(th) + .2 * cos(th);\n\treturn v;\n}\n\n// Lens distortion around edges\nvec2 lens_distortion( vec2 uv, float k, float kcube )\n{\n    vec2 t = uv;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t;\n    nUv.y = nUv.y;\n \n    return nUv;   \n}\n\nfloat getText( vec2 coord )\n{\n    float tex = .0;\n\n    if( iTime < 3. ) \n    {\n        t_time = iTime;\n        newline(); \n        tex += H(r(coord)); add(); \n        tex += I(r(coord)); space();\n        tex += T(r(coord)); add();\n        tex += H(r(coord)); add();\n        tex += E(r(coord)); add();\n        tex += R(r(coord)); add();\n        tex += E(r(coord)); add();\n        newline();\n    }\n\n    if( iTime > 3. && iTime < 8. ) \n    {\n        t_time = iTime - 3.;\n        newline(); \n        tex += E(r(coord)); add(); \n        tex += N(r(coord)); add();\n        tex += T(r(coord)); add();\n        tex += E(r(coord)); add();\n        tex += R(r(coord)); space();\n        tex += M(r(coord)); add();\n        tex += Y(r(coord)); add();\n        newline();\n        tex += L(r(coord)); add();\n        tex += A(r(coord)); add();\n        tex += I(r(coord)); add();\n        tex += R(r(coord)); add();\n        tex += STOP(r(coord)); add();\n        tex += STOP(r(coord)); add();\n        tex += STOP(r(coord)); add();\n    }\n\n    // Logo\n    if( iTime > 8. )\n    {\n        t_time = iTime - 8.;\n        newline();\n        tex += S1(r(coord)); add(); \n        tex += S2(r(coord)); add(); \n        tex += S3(r(coord)); add(); \n        tex += S4(r(coord)); add();\n        newline(); \n        tex += UL(r(coord)); add(); \n        tex += UM(r(coord)); add(); \n        tex += UM(r(coord)); add(); \n        tex += UR(r(coord)); add();\n    }\n    return tex;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /**\n     * basic setup\n     */\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\tuv.x = mix(-1.0, 1.0, uv.x);\n\tuv.y = mix(-1.0, 1.0, uv.y);\n\tuv.y *= iResolution.y / iResolution.x;\n\n    float distSpeed = .05;\n    float k = 1.0 * sin( iTime * distSpeed * .9 );\n    float kcube = .5 * sin( iTime * distSpeed );\n    float off = .1 * sin( iTime * distSpeed * .5 );\n\n    /**\n     * kaleidoscope\n     */\n    //vec2 lensedUV = lens_distortion( uv, k + off, kcube );\n    //vec2 kaleidUV = transform(kaleido(lensedUV)) * 4.0;\n    vec2 kaleidUV = transform(kaleido(uv)) * 4.0;\n    vec2 lensedUV = lens_distortion( kaleidUV, k + off, kcube );\n    vec4 kaleTex = texture(iChannel0, lensedUV); // < update here uv\n\n    /**\n     * dithering\n     */\n    vec3 rgb = kaleTex.rgb;\n    vec3 oldcolor = rgb + (rgb * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rgb);\n    vec3 dithered = floor(oldcolor);\n    dithered.g = .0;\n    dithered.b = .261;\n\n    /**\n     * render text\n     */\n\tfloat d = 0.;\n\tcaret = caret_origin;\n\n\t// Build up the text\n\td = getText(fragCoord);\n\n    // Vertical pixel lines\n    d = clamp(d* (.75+sin(fragCoord.x*PI*.5-iTime*4.3)*.5), 0.0, 1.0);\n\n    dithered += vec3(d*.5, d, d*.85);\n\n    /**\n     * vignette fx\n     */\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tdithered *= vec3(.4, .4, .4) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\n\n    fragColor = vec4(dithered, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}