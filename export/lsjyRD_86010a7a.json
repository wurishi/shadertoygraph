{"ver":"0.1","info":{"id":"lsjyRD","date":"1491245365","viewed":88,"name":"Refraction - Toothgip","username":"Toothgip","description":"Refraction","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["refraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere\n{\n    float radius;\n    vec3 center;\n    vec3 color;\n    bool refrac;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct It\n{\n    bool ok;  // presence ou non d'une intersection\n    vec3 p;   // point d'intersection\n    float t;  // distance d'intersection\n    vec3 color; // couleur de l'intersection\n    vec3 normal; // normal au point d'intersection\n    bool refrac;\n};\n    \nstruct Lampe\n{\n    vec3 pos;\n    vec3 color;\n};\n    \nLampe l;\n\nvec2 mouse;\n\nLampe lampe2;\n\n// renvoie t == 0 si pas d'intersection, sinon l'intersection\n// est Ã  ray.origin + t * ray.direction\nfloat intersect(Sphere s, Ray r) {\n    vec3 op = s.center - r.origin;\n    float t;\n    float eps = 1e-4;\n    float b = dot(op, r.direction);\n    float det = b * b - dot(op, op) + s.radius * s.radius;\n    if(det < 0.0) return 0.0;\n    else\n    {\n        det = sqrt(det);\n        float t = b - det;\n        if(t > eps)\n            return t;\n        else\n        {\n            t = b + det;\n            if(t > eps)\n                return t;\n            else\n                return 0.0;\n        }\n    }\n}\n\nconst int nbSpheres = 2;\n\nIt intersect_scene(Ray r)\n{\n    Sphere s[nbSpheres];\n\n    // definition de la scene\n    s[0].radius = 0.5;\n    s[0].center = vec3(0.0, 0.0, 0.0);\n    s[0].color = vec3(1.0, 1.0, 1.0);\n    s[0].refrac = false;\n\n\ts[1].radius = 0.25;\n    s[1].center = vec3(mouse, -1.0);\n    s[1].color = vec3(0.6, 0.0, 0.5);\n    s[1].refrac = true;\n    \n    // recherche d'une intersection\n    It it;\n    it.ok = false;\n\n    for(int i = 0; i < nbSpheres; i++)\n    {\n        float t2 = intersect(s[i], r);\n\n        // si intersection\n        if(t2 != 0.0)\n        {\n            if(t2 < it.t || !it.ok)\n            {\n\n                it.ok = true;\n                it.t = t2;\n                // calcul de la position et de la normal\n                it.p = r.origin + it.t * r.direction;\n                it.color = s[i].color;\n                it.normal = normalize(it.p - s[i].center);\n\n                it.refrac = s[i].refrac;\n\n               \n            }\n        }\n    }\n\n    return it;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x / iResolution.y;\n    mouse = vec2(iMouse.xy/iResolution.xy *2.0-1.0);\n    mouse.x *= ratio;\n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\n    uv.x *= ratio;\n\n    Ray r;\n    r.direction = vec3(0.0, 0.0, 1.0);\n    r.origin = vec3(uv.xy, -1.0);\n\n    It it = intersect_scene(r);\n    \n    //Si il y a intersection \n    if(it.ok && it.refrac)\n    {\n        \t\n    \tr.direction = refract(r.direction,it.normal, 1.833);\n        r.origin = it.p + it.p/2.0;\n        it = intersect_scene(r);\n        \n    }\n\n    if(it.ok)\n    {\n        \n        //Definition des lampes\n        l.pos = vec3(1.0, 0.0, -1.0);\n        l.color = vec3(0.0, 1.0, 0.0);\n        \n        \n       \n        //lampe2.pos = vec3(mouse, -1.0 );\n        //lampe2.color = vec3(0.0, 1.0, 0.5);\n        \n        //Defintion des cos\n        float cosTheta = max(dot(it.normal, normalize(l.pos - it.p)), 0.0);\n       float cosTheta2 = max(dot(it.normal,normalize(lampe2.pos -  it.p)),0.0);\n        \n        if(cosTheta2 == 0.0)\n        {\n        \tfragColor = vec4(0.0, 1.0, 0.0, 1.0);\n        \n        }\n        fragColor = vec4(pow(cosTheta, 4.0) * it.color, 1.0);\n    }\n    \n    else\n        fragColor = vec4(1.0,0.0,0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}