{"ver":"0.1","info":{"id":"dl2BzG","date":"1694386528","viewed":35,"name":"Little Red Box","username":"ceppich","description":"first project","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["boxes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//p is \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nvec3 checker(vec2 Pos){\n Pos = floor(Pos);\n return vec3(mod(Pos.x + mod(Pos.y, 4.0), 4.0));\n}\n\n//fragCoord in the pixel coming in on each function call\n//fragColor is the variable we will set based on the function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    //values \n    float s = sin(iTime);\n    float c = cos(iTime);\n    //making it spin\n    mat3 rotX = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n        \n    mat3 rotY = mat3(\n        c, 0.0, -s,\n        0.0, 1, 0.0,\n        s, 0.0, c\n    );\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //checkerboard\n    vec3 col = tan(checker(fragCoord.xy /25.0 + vec2(iTime*2.0)));\n    \n    //create a ray!; assume orthographic - which means it doesn't scale\n    //raypoint is the pixel, raydirection is the direction\n    //create ray \n    vec3 rayPt = vec3(uv.xy, 0);\n    vec3 rayPtdx = vec3(uv.x + 0.0001, uv.y, 0);\n    vec3 rayPtdy = vec3(uv.x, uv.y + 0.0001, 0);\n    vec3 rayDir = vec3(0,0,1);\n    float t = 0.0, tdx = 0.0, tdy = 0.0; //ray parameter\n   \n    //define the sphere properties\n    vec3 boxPos = vec3(0.2,0.2,0.2);\n    vec3 spherePos = vec3(0.5,0.3,0.05);\n    vec3 sphereProps = vec3(0.5, 0.5, 0.3);\n       \n    //add texture to the background \n    col = mix(col,vec3(texture(iChannel0, uv.xy).rrr), 0.5);\n    \n    for (int i=0; i < 100; i++) {\n        //calculate a point 5 units along the ray\n        vec3 pos = rayPt + rayDir * t;\n        vec3 posdx = rayPtdx + rayDir * tdx;\n        vec3 posdy = rayPtdy + rayDir * tdy;\n        \n        \n           \n        //subtract object position from ray position and check if that point\n        //is in the world origin sphere\n        float dist = sdBox(rotY*(rotX*(pos - vec3(0.5,0.3,5))), boxPos);\n        float distdx = sdBox(rotY*(rotX*(posdx - vec3(0.5,0.3,5))), boxPos);\n        float distdy = sdBox(rotY*(rotX*(posdy - vec3(0.5,0.3,5))), boxPos);\n        \n        if (dist < 0.01 && distdx < 0.0001 && distdy < 0.0001){\n            \n            vec3 lightDir = rayDir;\n            vec3 boxCol = vec3(1,0,1);\n            \n            //I now have 3 points on the surface\n            //pos, posdx, posdy\n            \n            col = boxCol*dot(-lightDir, normalize(cross(posdy - pos, posdx - pos)));\n            //col = boxCol*dot(-lightDir, checker(fragCoord.xy /50.0 + vec2(-iTime)));\n\n            \n            //col = normalize(pos - boxPos);\n            col.z = -col.z;\n            //col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n            \n            break;\n        }\n        \n        float Dist = sdBox(rotY*(rotX*(pos - vec3(0.3,0.5,5))), boxPos);\n        float Distdx = sdBox(rotY*(rotX*(posdx - vec3(0.3,0.5,5))), boxPos);\n        float Distdy = sdBox(rotY*(rotX*(posdy - vec3(0.3,0.5,5))), boxPos);\n        \n        if (Dist < 0.01 && Distdx < 0.0001 && Distdy < 0.0001){\n            \n            vec3 lightDir = rayDir;\n            vec3 boxCol = vec3(0,0,1);\n            \n            //I now have 3 points on the surface\n            //pos, posdx, posdy\n            \n            //col = boxCol*dot(-lightDir, normalize(cross(posdy - pos, posdx - pos)));\n            col = boxCol*dot(-lightDir, checker(fragCoord.xy /5.0 + vec2(-iTime)));\n\n            \n            //col = normalize(pos - boxPos);\n            col.z = -col.z;\n            //col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n            \n            break;\n        }\n        \n        \n        //look at what t value does on the slides\n        t = t + dist;\n        tdx = tdx + distdx;\n        tdy = tdy + distdy;\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}