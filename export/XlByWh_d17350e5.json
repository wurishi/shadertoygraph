{"ver":"0.1","info":{"id":"XlByWh","date":"1508301773","viewed":1238,"name":"Approximate CIE XYZ Spectrum","username":"Tynach","description":"Uses an approximation to the CIE 1931 XYZ color matching functions to render a spectrum.\n\nUpdates:\n2018-02-21:\nNow uses curves that more closely match the proposed XYZ spectral sensitivities.\n2018-03-17:\nIs white balanced to D65 using custom LMS space.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["simulation","spectrum","light","color","rainbow","xyz","dispersion","colorspace","lms","spectral","simulate","simulated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**************************************************************************\n * Scroll to the bottom to change the parameters used to draw the diagram *\n **************************************************************************/\n\nprecision highp float;\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\t(r1), (r2), 1.0 - (r1) - (r2),\\\n\t\t(g1), (g2), 1.0 - (g1) - (g2),\\\n\t\t(b1), (b2), 1.0 - (b1) - (b2))\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define White(x, y)\\\n\tvec3((x), (y), 1.0 - (x) - (y))/(y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag(inverse((space).primaries)*(space).white)\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\n/*\n * Standard XYZ -> LMS transformation matrices\n */\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC (Rec. 601) and SMPTE-240M\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Never-popular, antiquated, and idealized 'HDTV' primaries based mostly on the\n// 1953 NTSC colorspace. SMPTE-240M officially used the SMPTE-C primaries\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// Personal monitor's primaries (Dell U2417H)\nconst mat3 primariesDell = Primaries(\n\t0.6577, 0.337,\n\t0.3073, 0.605,\n\t0.1492, 0.062\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = White(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = White(1.0/3.0, 1.0/3.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = White(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = White(0.312713, 0.329016);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = White(0.34567, 0.35850);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = White(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = White(0.283, 0.298);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; used by older Macintosh systems\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, and is what Adobe RGB uses\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma and full range values)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point and linearized\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n/*\n * Settings\n */\n\n// Convert to this colorspace\nconst rgb_space to = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// Choose main XYZ->LMS conversion matrix from which others derive\n//const mat3 lmsMat = CIECAM02;\n\n// Normalize the LMS matrix to the white point\n//const mat3 toLms = inverse(diag((lmsMat*to.white)))*lmsMat;\n\n// Or not\n//const mat3 toLms = lmsMat;\n\n// Use LMS primaries instead of a pre-created matrix\nconst mat3 toLms = xyzToRgb(LmsRgb);\n\n\n// Converts RGB colors to a linear light scale\nvec3 toLinear(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec3 toGamma(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-1.0*color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n#define gauss(x, o, u, A)\\\n\tA/o*exp(-0.5*pow((x - u)/o, 2.0))\n\n// Converts from a wavelength to xyz\n// Constructed using multi-peak gaussian functions generated using Labplot\n// More closely fits the physiologically-based XYZ curves proposed in 2011\nvec3 waveToXyz(float wave)\n{\n\t// XYZ directly\n\t/*float x1 = gauss(wave, 29.475, 444.358, 55.1489);\n\tfloat x2 = gauss(wave, 40.7142, 446.251, -41.6977);\n\tfloat x3 = gauss(wave, 23.5915, 606.057, 24.34);\n\tfloat x4 = gauss(wave, 37.6977, 590.361, 73.5741);\n\n\tfloat y1 = gauss(wave, 19.6797, 656.021, -0.778595);\n\tfloat y2 = gauss(wave, 42.4066, 565.962, 101.492);\n\tfloat y3 = gauss(wave, 27.5225, 462.807, 3.53373);\n\tfloat y4 = gauss(wave, 18.2148, 529.439, 8.83261);\n\n\tfloat z1 = gauss(wave, 10.2339, 422.327, 16.9254);\n\tfloat z2 = gauss(wave, 11.889, 443.142, 37.6146);\n\tfloat z3 = gauss(wave, 8.90569, 467.586, 10.5197);\n\tfloat z4 = gauss(wave, 25.8258, 460.901, 48.0458);*/\n\n\t// LMS (use with matrix operation to convert to XYZ)\n\t/*float x1 = gauss(wave, 23.5566, 446.096, 1.89299);\n\tfloat x2 = gauss(wave, 11.6691, 500.916, -2.28739);\n\tfloat x3 = gauss(wave, 32.3956, 536.797, 53.544);\n\tfloat x4 = gauss(wave, 33.11, 592.064, 62.7607);\n\n\tfloat y1 = gauss(wave, 13.3211, 479.559, 3.68812);\n\tfloat y2 = gauss(wave, 19.5222, 450.237, 3.33538);\n\tfloat y3 = gauss(wave, 17.7555, 521.0, 10.3423);\n\tfloat y4 = gauss(wave, 33.3204, 552.385, 77.3657);\n\n\tfloat z1 = gauss(wave, 10.2339, 422.327, 8.74764);\n\tfloat z2 = gauss(wave, 11.8916, 443.145, 19.3);\n\tfloat z3 = gauss(wave, 8.90568, 467.586, 5.43695);\n\tfloat z4 = gauss(wave, 25.8258, 460.901, 24.8318);*/\n\n\t// Increased accuracy\n\tfloat x1 = gauss(wave, 21.6622, 449.682, 2.36612);\n\tfloat x2 = gauss(wave, 11.0682, 477.589, 1.39883);\n\tfloat x3 = gauss(wave, 25.7494, 532.488, 34.0478);\n\tfloat x4 = gauss(wave, 5.91487, 570.2, 0.243387);\n\tfloat x5 = gauss(wave, 34.98, 585.858, 77.8669);\n\n\tfloat y1 = gauss(wave, 19.5222, 450.237, 3.33537);\n\tfloat y2 = gauss(wave, 13.3211, 479.559, 3.68813);\n\tfloat y3 = gauss(wave, 17.1502, 519.924, 9.68484);\n\tfloat y4 = gauss(wave, 3.27696, 542.8, 0.105766);\n\tfloat y5 = gauss(wave, 33.3895, 552.158, 77.9298);\n\n\tfloat z1 = gauss(wave, 8.84562, 467.661, 5.32073);\n\tfloat z2 = gauss(wave, 1.30608, 444.863, -0.0330768);\n\tfloat z3 = gauss(wave, 10.2028, 422.211, 8.58498);\n\tfloat z4 = gauss(wave, 11.9848, 443.084, 19.6347);\n\tfloat z5 = gauss(wave, 25.7907, 460.886, 24.9128);\n\n\tvec3 color = vec3(\n\t\t1.0/sqrt(2.0*PI)*(x1 + x2 + x3 + x4 + x5),\n\t\t1.0/sqrt(2.0*PI)*(y1 + y2 + y3 + y4 + y5),\n\t\t1.0/sqrt(2.0*PI)*(z1 + z2 + z3 + z4 + z5)\n\t);\n\n\tcolor = mat3(\n\t\t1.94735469, 0.68990272, 0,\n\t\t-1.41445123, 0.34832189, 0,\n\t\t0.36476327, 0, 1.93485343\n\t)*color;\n\n\treturn color;\n}\n\n// Older, original version of the function\n/*vec3 waveToXyz(float wave)\n{\n\tfloat x1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374);\n\tfloat x2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323);\n\tfloat x3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n\n\tfloat y1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247);\n\tfloat y2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n\n\tfloat z1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278);\n\tfloat z2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n\n\treturn vec3(\n\t\t0.362*exp(-0.5*x1*x1) + 1.056*exp(-0.5*x2*x2) - 0.065*exp(-0.5*x3*x3),\n\t\t0.821*exp(-0.5*y1*y1) + 0.286*exp(-0.5*y2*y2),\n\t\t1.217*exp(-0.5*z1*z1) + 0.681*exp(-0.5*z2*z2)\n\t);\n}*/\n\n// Scales a color to the closest in-gamut representation of that color\nvec3 gamutScale(vec3 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = max((high - 1.0)/(high - luma), 0.0);\n\tfloat scale = max(lowScale, highScale);\n\tcolor += scale*(luma - color);\n\n\treturn color;\n}\n\n// Converts from XYZ to RGB\nvec3 convert(vec3 color)\n{\n\tconst mat3 toRGB = xyzToRgb(to);\n\tconst mat3 whiteBalance = inverse(toLms)*diag((toLms*to.white)/(toLms*whiteE))*toLms;\n\n\t// Commented out numbers/lines are for uniformly brightening the\n\t// spectrum to fit it within sRGB while retaining full accuracy\n\tcolor /= 2.44;//3.71;\n\t//color += 0.29;\n\tcolor = whiteBalance*color;\n\n\tfloat luma = color.y;\n\tcolor = toRGB*color;\n\tcolor = gamutScale(color, luma);\n\n\treturn color;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat wave = 340.0*fragCoord.x/iResolution.x + 390.0;\n\tvec3 color = waveToXyz(wave);\n\n\t// Divide by the wavelength squared; also scaling said wavelength to\n\t// give the same maximum brightness as we'd have without this step.\n\t// I'm doing this so that it gives a spectrum with equal brightness\n\t// across all frequencies, rather than all wavelengths\n\n\t// This might be horribly wrong, so I've commented it out for now\n\t//wave /= 605.0;\n\t//color /= wave*wave;\n\n\tcolor = convert(color);\n\tcolor = toGamma(color, to.trc);\n\n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}