{"ver":"0.1","info":{"id":"msGSRK","date":"1681465637","viewed":58,"name":"Mathematical trippy Landscape","username":"grullier","description":"A landscape based on ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["landscape3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Surface {\n    float distance;\n    vec3 color;\n};\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    #if 1\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    #else\n    vec2 u = w*w*(3.0-2.0*w);\n    #endif\n\n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\nSurface distanceToTerrain(vec3 position, vec3 color) {\n    float distance = 0.0;\n    float scale = 0.3;\n    float persistence = 0.6;\n    float lacunarity = 3.0;\n    float amplitude = 1.6;\n    \n    for (int i = 0; i < 2; i++) {\n        distance += amplitude * noise(position.xz * scale);\n        scale *= lacunarity;\n        amplitude *= persistence;\n    }\n    \n    distance -= -position.y;\n    \n    return Surface(distance, color);\n    \n}\n\nSurface distanceToSphereSurface(vec3 position, vec3 sphereCenter, float sphereRadius, vec3 color) {\n    float distanceToSurface = \n         sqrt(\n             pow((sphereCenter.x - position.x),2.0)+\n             pow((sphereCenter.y - position.y),2.0)+\n             pow((sphereCenter.z - position.z),2.0)\n         )-\n         sphereRadius;\n\n    return Surface(distanceToSurface, color);\n}\n\nSurface distanceToPlaneSurface(vec3 position, vec3 origin, vec3 normal, vec3 color) {\n    float d = \n        normal.x * origin.x+\n        normal.y * origin.y+\n        normal.z * origin.z;\n\n\n    float distanceToSurface = \n        abs( \n           normal.x * position.x+\n           normal.y * position.y+\n           normal.z * position.z+\n           d\n        )/\n        sqrt(\n            pow(normal.x, 2.0)+\n            pow(normal.y, 2.0)+\n            pow(normal.z, 2.0)\n        );\n\n\n    return Surface(distanceToSurface, color);\n}\n\nSurface minSurface(Surface s1, Surface s2) {\n    if (min(s1.distance, s2.distance) == s1.distance) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface map(vec3 position) {\n    Surface surface = Surface(10000.0, vec3(1.0)); // The default \n\n    surface = minSurface(surface, distanceToSphereSurface(position, vec3(0.0,iTime,0.0), 3.0, vec3(0.0,1.0,0)));\n    surface = minSurface(surface, distanceToPlaneSurface(position, vec3(0.0), vec3(0.0, 1.0, 0.0), vec3(0.059,0.741,0.941)));\n    surface = minSurface(surface, distanceToTerrain(position, vec3(1.000,0.839,0.533)));\n\n    return surface;\n}\n\n// A function to calculate the normal to the nearest surface of the map\nvec3 calculateNormal(vec3 position, float epsilon) {\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( \n        e.xyy*map(position + e.xyy*epsilon).distance + \n        e.yyx*map(position + e.yyx*epsilon).distance + \n        e.yxy*map(position + e.yxy*epsilon).distance + \n        e.xxx*map(position + e.xxx*epsilon).distance\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y; \n    float aspectRatio = iResolution.y/iResolution.x;\n\n    // Light source\n    vec3 lightPosition = vec3(100.0,10.0 * iTime, 50.0);\n\n\n    // Camera\n    float cameraFieldOfView = 1.0; \n    vec3 cameraPosition = vec3(10.0);\n    vec3 cameraOrientation = normalize(vec3(-1.0));\n    \n    // Ray\n    vec3 rayDirection = normalize(\n        vec3(\n            cameraOrientation.x + uv.x * cameraFieldOfView,\n            cameraOrientation.y + uv.y * cameraFieldOfView,\n            cameraOrientation.z\n        )\n    );\n    \n    float travelledDistance = 3.0; // Length of the first step\n    bool hit = false;\n    vec4 color = vec4(0.0);\n    Surface surface = Surface(10000.0, vec3(1.0)); // The default\n    for( int i=0; i<128; i++)\n    {\n        // We make one marching step with the ray\n        vec3 rayPosition = cameraPosition + rayDirection * travelledDistance;\n        surface = map(rayPosition);\n        // If we are close enough or missed totally to the surface we stop\n        if(surface.distance < 0.1) {\n            hit = true;\n            color = vec4(surface.color,1.0);\n            break;\n        }\n        // We redefine the step to the closest distance we found\n        travelledDistance += surface.distance;\n    }\n \n    // Lighting rendering\n    vec3 rayPosition = cameraPosition + rayDirection * travelledDistance;\n    vec3 surfaceNormal = calculateNormal(rayPosition, 0.001);\n    vec3 lightDirection = normalize(rayPosition - lightPosition);\n    float scattering = dot(surfaceNormal, lightDirection);\n    color *= -1.0*scattering;\n    \n    // Shadow rendering\n    if (hit) {\n        vec3 rayOrigin = cameraPosition + rayDirection * travelledDistance;\n        vec3 rayDirection = normalize(lightPosition - rayOrigin);\n        float travelledDistance = 1.0; // Length of the first step\n        Surface supportSurface = surface;\n        for( int i=0; i<1024; i++)\n        {\n            // We make one marching step with the ray\n            vec3 rayPosition = rayOrigin + rayDirection * travelledDistance;\n            Surface s = map(rayPosition);\n            // If we are close enough or missed totally to the surface we stop\n            if(s.distance < 0.01) {\n                color = vec4(supportSurface.color*0.1,1.0);\n                break;\n            }\n            // We redefine the step to the closest distance we found\n            travelledDistance += surface.distance;\n        }\n    }\n    \n    // End\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}