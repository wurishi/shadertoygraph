{"ver":"0.1","info":{"id":"XtXyDM","date":"1504967862","viewed":137,"name":"Workshop with Albert Elwin","username":"carrotcake","description":"Workshop with Albert Elwin, I fiddled a bit with the code and created this tornado effect (accidentally)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distance","fields","tornado","albertelwin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"    \nconst vec3 BG_COLOR = vec3(0.0, 0.0, 1.0);\nconst vec3 MG_COLOR = vec3(1.0, 1.0, 0.5);\nconst vec3 FG_COLOR = vec3(0.0, 1.0, 0.75);\n\nfloat sd_plane(vec3 p, float h);\nfloat sd_sphere(vec3 p, float r);\nfloat sd_box(vec3 p, float x, float y, float z);\nfloat sd_torus(vec3 p, float r, float h);\nfloat sd_cylinder(vec3 p, float r, float h);\n\nvec3 twist(vec3 p, float r, float a);\nvec3 repeat(vec3 p, float s);\n\nfloat smin(float a, float b, float k);\nfloat noise(vec3 p);\n\nfloat map(vec3 p) {\n    float d = 1000.0;\n\tp = twist(p, 1.5, 1.0);\n    d = smin(d, sd_plane(p, -1.0), 0.0);\n    //d = smin(d, sd_sphere(p, 1.5), sin(iTime));    \n    //d = smin(d, sd_sphere(p, 1.5), 0.75);    \n    //d = smin(d, sd_sphere(p - vec3(tan(iTime), tan(iTime), sin(iTime)), 1.5), 0.5);\n    \n    //vec3 q = repeat(p - vec3(0.0, -1.0, 0.0), 1.0);\n    \n\tvec3 q = repeat(p - vec3(tan(iTime), tan(iTime), sin(iTime)), 1.0);\n    d = smin(d, sd_sphere(q, 0.5), 0.0);\n                                  \n    d = smin(d, sd_sphere(p - vec3(tan(iTime), tan(iTime), sin(iTime)), 1.5), 0.5);\n    \n    d = d + noise((p + vec3(sin(iTime), tan(iTime), cos(iTime))) * 8.0) * 0.25;\n    \n    //d = smin(d, sd_torus(p - vec3(0.0, -0.5, 0.0), 2.0, 0.25), 0.0);\n    \n#if 0\n    d = smin(d, sd_plane(p, -0.75), 0.0);\n    \n    d = smin(d, sd_sphere(p - vec3(0.0, -0.25, 0.0), 1.0 + sin(iTime) * 0.0625), 0.25);\n    d = smin(d, sd_torus(p - vec3(0.0,-0.60, 0.0), 2.0, 0.1 + sin(iTime) * 0.025), 0.5);\n    \n\td += noise((p + vec3(0.0, iTime * 0.1, 0.0)) * 4.0) * 0.1;\n\n    float height = sin(4.25 - abs(p.x * 0.5)) * 1.5 * max(0.0, p.z + 1.0);\n    d = smin(d, sd_cylinder(repeat(p, 1.0) - vec3(0.0, -1.5, 0.0), 0.25, height), 0.5);\n#endif\n    \n    return d;  \n}\n\nfloat sd_plane(vec3 p, float h) {\n\treturn p.y - h;   \n}\n\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_box(vec3 p, float x, float y, float z) {\n\tvec3 d = abs(p) - vec3(x, y, z);\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sd_torus(vec3 p, float r, float h) {\n\tvec2 q = vec2(length(p.xz) - r, p.y);\n\treturn length(q) - h;\n}\n\nfloat sd_cylinder(vec3 p, float r, float h) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec3 repeat(vec3 p, float s) {\n    vec3 q = p;\n    q.x = mod(q.x, s) - 0.5 * s;\n    q.z = mod(q.z, s) - 0.5 * s;\n    return q;\n}\n\nvec3 twist(vec3 p, float r, float a) {\n\tfloat c = cos(r * p.y + a);\n\tfloat s = sin(r * p.y + a);\n\treturn vec3(p.x * c + p.z * s, p.y, p.x * -s + p.z * c);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n\treturn mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat noise(vec3 p) {\n\tvec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n\tp -= ip;\n\tvec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp = p * p * (3.0 - 2.0 * p);\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z) * 2.0 - 1.0;\n}\n\nvec3 compute_normal(vec3 p) {\n\tvec3 eps = vec3(0.0005, 0.0, 0.0);\n    vec3 n;\n    n.x = map(p + eps.xyy) - map(p - eps.xyy);\n    n.y = map(p + eps.yxy) - map(p - eps.yxy);\n    n.z = map(p + eps.yyx) - map(p - eps.yyx);\n    n = normalize(n);\n    return n;\n}\n\nfloat compute_ao(vec3 p, vec3 n) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor(int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tfloat d = map(p + hr * n);\n\t\tocc += -(d - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    vec3 ro = vec3(0.0, 0.0, -3.5);\n    vec3 rd;\n    rd.xy = (fragCoord.xy / iResolution.y) * 2.0 - vec2(iResolution.x / iResolution.y, 1.0);\n    rd.z = 1.0;\n    rd = normalize(rd);\n    \n    vec3 color = BG_COLOR;\n\t//color.x = sin(iTime);\n    //color.y = cos(iTime);\n    vec3 color2 = BG_COLOR;\n    color2.x = sin(iTime);\n    color2.y = cos(iTime);\n    \n    float t = 0.0;\n    float t_max = 7.5;\n    for(int i = 0; i < 256; i++) {\n        float d = map(ro + t * rd);\n        t += d * 0.6;\n        if(d < 0.002) {\n            vec3 p = ro + t * rd;\n            vec3 n = compute_normal(p);\n            vec3 l = normalize(vec3(0.25, 1.0, -0.5));\n            float dot_nl = clamp(dot(n, l), 0.0, 1.0);\n            float ao = compute_ao(p, n);\n            float fog = clamp(1.0 - t / t_max, 0.0, 1.0);\n            float light = mix(dot_nl, ao, 0.5);\n            \n            color = mix(MG_COLOR, color2, light);\n            color = mix(BG_COLOR, color, fog);\n            break;\n        }\n        else if(t > t_max) {\n            break;\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}