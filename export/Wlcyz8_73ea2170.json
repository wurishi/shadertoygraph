{"ver":"0.1","info":{"id":"Wlcyz8","date":"1608482870","viewed":190,"name":"bell curve","username":"tshrpl","description":"something","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bellcurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n *  almost all of the code is taken from https://www.shadertoy.com/view/tscGWM\n */\n\n\n// const float ROTATION_SPEED = 1.0;\nconst float CAMERA_DISTANCE = 10.0;\nconst int ITERATIONS = 1024;\nconst float EPSILON = 0.005;\n\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\n\nvec2 intersectionOfTwoLines(vec2 A, float sa, vec2 B, float sb) {\n\tfloat buffer = (sa*A.x - A.y - sb * B.x + B.y) / (sa - sb);\n\treturn vec2(buffer, sa*(buffer - A.x) + A.y);\n}\n\nfloat wave(vec3 p, vec3 o, float F, float A) {\n\tfloat e = 2.71828;\n\n\tfloat h = sqrt(dot(p.xz - o.xz, p.xz - o.xz));\n\tfloat k = (p.y-o.y);\n\tvec2 c = vec2(h, k);\n\n    //float h_p = -A * pow(e,-(h*h)/F);\n    //float h_p = - A * pow(e, -(h*h));\n    float h_p = - pow(e, -(h*h)) * sin(F*h*h);\n\n    vec2 r_of_h = vec2(h, h_p);\n\tfloat t_of_h = 2.0 * h ;\n\tfloat n_of_h = -1.0 / t_of_h;\n\tvec2 t_int_n = intersectionOfTwoLines(r_of_h, t_of_h, c, n_of_h);\n\n\treturn distance(c, t_int_n);\n}\n\nfloat wave2(vec3 p, vec3 o, float f1, float r, float A) {\n\tfloat e = 2.71828;\n\n\tfloat h = sqrt(dot(p.xz - o.xz, p.xz - o.xz));\n\tfloat k = (p.y-o.y);\n\tvec2 c = vec2(h, k);\n\n    float h_p = -A * pow(e, -r*(h*h)) * sin(f1*h*h);\n\n    vec2 r_of_h = vec2(h, h_p);\n\tfloat t_of_h = 2.0 * h ;\n\tfloat n_of_h = -1.0 / t_of_h;\n\tvec2 t_int_n = intersectionOfTwoLines(r_of_h, t_of_h, c, n_of_h);\n\n\treturn distance(c, t_int_n);}\n\n\nfloat bound(vec3 p) {\n    return max(\n        wave(p, vec3(0.0), 1.5 + sin(iTime*5.0)*1.5, sin(iTime*5.0) + 1.0),\n        //wave2(p, vec3(0.), 1./mod(iTime, 3.0), 0.35/mod(iTime, 3.0), 2.0-mod(iTime, 3.0)),\n        \n        sdSphere(p, 5.0)\n    ) * 0.05;\n}\n\n\n\nfloat Scene (vec3 p) {\n    float w = bound(p);\n    float s = sdSphere(p, 5.0);\n    if (p.y < 0.0) return w;\n    else return s;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // float theta = iTime * ROTATION_SPEED;\n    float theta = 0.0;\n    float phi = -0.4;\n\n    vec4 mouse = iMouse / iResolution.xyxx;\n    if (mouse.z > 0.0) {\n        theta = mouse.x * 2.0 * 3.14159;\n        phi = (mouse.y - 0.5) * 1.0 * 3.14159;\n    }\n\n    vec3 orbit = vec3(cos(theta)*cos(phi), sin(phi), sin(theta)*cos(phi));\n    vec3 camera_position = orbit * CAMERA_DISTANCE;\n\n    vec3 normal = -normalize(orbit);\n    vec3 tangent = normalize(vec3(-normal.z, 0.0, normal.x));\n\n    vec3 forward = normal;\n    vec3 up = normalize(cross(normal, tangent));\n    vec3 right = tangent;\n\n    vec2 range = uv*2.0 - vec2(1.0,1.0);\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    vec3 ray = normalize(forward + range.x*right + range.y*up*aspect);\n    \n    vec3 p = camera_position;\n    float dist = 0.0;\n    vec3 init_distance = vec3(0.0);\n\n\n    // ray marching code\n    int j;\n    for (int i = 0; i < ITERATIONS; i++) {\n        dist = Scene(p);\n        \n        p += ray*dist;\n        j = i;\n        \n        if (dist < EPSILON || dot(p, p) > 4096.1) break;\n        \n    }\n    \n    \n    \n    // render\n    float hit = step(dist, EPSILON);\n\n    vec3 col = vec3(1.0,1.0,1.0);\n\n    float di = (float(j) + (dist / EPSILON)*hit) / float(ITERATIONS);\n    di = ( 1.0 - di ) * hit;\n    fragColor = vec4(col*di,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}