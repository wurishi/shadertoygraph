{"ver":"0.1","info":{"id":"4lXXD2","date":"1439841310","viewed":1067,"name":"Bokeh Lights","username":"inferno","description":"Branch of this shader [url]https://www.shadertoy.com/view/4lXXDB[/url] by [b]BigWIngs[/b] with some reduction to just get some nice bokeh lights. Use the mouse to look around","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","light","dof","bokeh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Created by Martijn Steinrucken - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// \n// based on https://www.shadertoy.com/view/4lXXDB by BigWIngs\nconst vec3 worldUp = vec3(0.,1.,0.);\n\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nconst float NUM_LIGHTS = 150.;\t\t\t// number of twinkly lights falling down\nconst float _FocalDistance = 0.0035;\t// focal distance of the camera\nconst float _DOF = 1.;\t\t\t\t// depth of field. How quickly lights go out of focus\nconst float _ZOOM = 0.6;\t\t// camera zoom, smaller values means wider FOV\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n// Helper functions - Borrowed from other peoples shaders =================================\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nvec2 hash2(float n) {\n\tvec2 n2 = vec2(n, -n+2.1323);\n    return fract(sin(n2)*1751.5453);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.;\n    x /= w;\n    return 1. - x*x*(3.-2.*x);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat PeriodicPulse(float x, float p) {\n    // pulses from 0 to 1 with a period of 2 pi\n    // increasing p makes the pulse sharper\n\treturn pow((cos(x+sin(x))+1.)/2., p);\n}\n\n\n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(1., dot(p-r.o, r.d))*r.d;\n}\n\n// ================================================================\n\n// simple value noise\nfloat hash3( float n ) \n{ \n\treturn fract(sin(n)*753.5453123); \n}\n\nfloat vnoise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash3(n+  0.0), hash3(n+  1.0),f.x),\n                   mix( hash3(n+157.0), hash3(n+158.0),f.x),f.y),\n               mix(mix( hash3(n+113.0), hash3(n+114.0),f.x),\n                   mix( hash3(n+270.0), hash3(n+271.0),f.x),f.y),f.z);\n}\n\nfloat Bokeh(ray r, vec3 p) \n{\n    float dist = length( p-ClosestPoint(r, p) );\n    \n    float distFromCam = length(p-e.o);\n    float focus = cubicPulse(_FocalDistance, _DOF, distFromCam);\n    \n    vec3 inFocus = vec3(0.2, -0.1, 1.);\t// outer radius = 0.05, inner radius=0 brightness =1\n    vec3 outFocus = vec3(0.25, 0.2, .05);\t// out of focus is larger, has sharper edge, is less bright\n    \n    vec3 thisFocus = mix(outFocus, inFocus, focus);\n    \n    return smoothstep(thisFocus.x, thisFocus.y, dist)*thisFocus.z;\n}\n\nvec3 Lights(ray r, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    float height = 4.;\n   \tfloat halfHeight = height/2.;\n   \n    for(float i=0.; i<NUM_LIGHTS; i++) {\n    \tfloat c = i/NUM_LIGHTS;\n        c *= twopi;\n        \n        vec2 xy = hash2(i)*10.-5.;\n        \n        float y = fract(c)*height-halfHeight;\n        \n        vec3 pos = vec3(xy.x, y, xy.y);\n        pos += vec3(vnoise(i * pos * iTime * 0.0006), vnoise(i * pos * iTime * 0.0002), 0.0);\n        \n        float glitter = 1. +clamp((sin(c+t*3.)-0.9)*50., 0., 100.);\n       \n        col += Bokeh(r, pos)*glitter *mix( vec3(02.5,2.2,01.9), vec3(0.7, 1.6,3.0), 0.5+0.5*sin(float(i)*1.2+1.9));\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - 0.5;\n   \tuv.y *= iResolution.y/iResolution.x;\n    vec3 mouse = -vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\tfloat t = iTime;\n    \n    float speed = 0.004;\n    \n    float st = sin(t*speed);\n    float ct = cos(t*speed);\n    \n    cam.p = vec3(st, st, ct)*vec3(4., 3.5, 4.);\n    cam.p = normalize(cam.p);// NOTE this won't work if the lookat isn't at the origin\n    \n    cam.p = rotate_x(cam.p,mouse.y*2.+5.2); cam.p = rotate_y(cam.p,mouse.x*3.);\n\n    \n    cam.lookAt = vec3(0., 0., 0.);\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(worldUp, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = _ZOOM;\n    \n    vec3 screenCenter = cam.p+cam.forward*cam.zoom;\n    vec3 screenPoint = screenCenter+cam.left*uv.x+cam.up*uv.y;\n    \n    e.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    e.d = normalize(screenPoint-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n   \n    vec3 col = vec3(0.);\n    \n\tcol += Lights(e, t*0.2);\t\t\t\t\t\t\t// lights falling down\n  \tcol += 0.05;\n\tfragColor = vec4(col.r, col.g, col.b, 1.);\n}","name":"","description":"","type":"image"}]}