{"ver":"0.1","info":{"id":"mlsyWj","date":"1691219102","viewed":36,"name":"任意方向圆角矩形的SDF","username":"Leslie","description":"就是水平圆角矩形的SDF公式加了个旋转矩阵。","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 clrDist(float dist)\n{\n    vec3 col = dist>0.0 ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1. - exp(-6.*abs(dist));\n    col *= 1. + 0.2*sin(150.*abs(dist));\n    col = mix(col, vec3(1.), smoothstep(0.01, 0., abs(dist)));\n    return col;\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th, vec4 r )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l; // d为b-a所得向量的单位向量。\n    vec2  q = (p-(a+b)*0.5); // q点为当前fragment坐标减去a,b中点所得向量，如果以q点坐标表示当前fragment坐标，则坐标系原点应在a,b两点中心。\n          q *= mat2(d.x,-d.y,d.y,d.x); // 对q向量进行顺时针旋转，相当于对坐标系进行逆时针旋转；旋转后d方向与X轴方向重合。\n          // 至此坐标系和fragment当前坐标点q都被转换为与求水平矩形距离值相同的情况。\n          \n          r.zw = q.x>0. ? r.zw : r.yx;\n          r.w = q.y>0. ? r.w : r.z;\n          r.w=clamp(r.w, 0., min(l/2., th/2.));\n          q = abs(q)-vec2(l,th)*0.5+r.w; // `abs(q)`，将2，3，4象限的q点转换到第1象限，同时坐标系进行了相反的转换，矩形四个角坐标都转换为vec2(l,th)*0.5，d方向依然与X轴方向重合；然后减去vec2(l,th)*0.5，q点移动负vec2(l,th)*0.5，相当于坐标原点移动正vec2(l,th)*0.5，坐标原点根据q点原来所在象限分别移至矩形四个角。\n\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r.w; // 和求水平矩形距离值公式，`+`前为矩形外的距离值，`+`后为矩形内的距离值。 \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = min(iResolution.x, iResolution.y);\n    \n    /* p点由fragCoord进行以下转换得到：\n    1.`2.*fragCoord`先放大为原先的2倍，坐标系缩小为原来的0.5倍，原先iResolution.xy表示viewport的宽，高；现在iResolution.xy*2.才能表示viewport的宽，高。\n    2. `-iResolution.xy`，再向负方向移动iResolution.xy向量，坐标系向正方向移动iResolution向量，从viewport的左下角移动到viewport的中心。\n    3. `/scale`, 缩小为原先的1/scale倍，坐标系放大为原先的scale倍，原先iResolution.xy*2.表示viewport的度，高，现在iResolution.xy*2./scale表示viewport的宽，高。\n    此时如果以p点表示当前fragment的坐标，则坐标系原点应在viewport中心，viewport的宽，高为iResolution.xy*2./scale。\n    */\n    vec2 p = (2.*fragCoord-iResolution.xy)/scale;\n    vec2 a = vec2(0, sin(iTime*0.5));\n    vec2 b = vec2(sin(iTime*0.55), 0.);\n    float th = 2.-2.*abs(cos(iTime));\n    vec4 r = vec4(0.1, 0.23, 0.36, 0.5);\n    float dist = sdOrientedBox(p, a, b, th, r);\n    vec3 clr = clrDist(dist);\n    fragColor = vec4(clr, 1.);\n}\n","name":"Image","description":"","type":"image"}]}