{"ver":"0.1","info":{"id":"ltSBDW","date":"1515765722","viewed":233,"name":"2D light","username":"elk","description":"first test in 2D for area light","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["arealight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 lightP1 = vec2(-0.05, 0.0);\nvec2 lightP2 = vec2(0.05, 0.0);\nvec2 lightCenterPosition = vec2(0.5, 0.25);\nvec2 lightNormal = vec2(0.0,1.0);\nfloat pi = 3.141592;\n\nvec4 computeSegmentLight(in vec2 position){\n    vec2 P2P1 = lightP2-lightP1;\n    vec2 surfaceP1 = position - lightP1;\n    vec2 surfaceP2 = position - lightP2;\n    vec2 lightP3;\n    \n    float cosTheta1 = dot(normalize(P2P1), normalize(surfaceP1));\n    float cosTheta2 = dot(normalize(-P2P1), normalize(surfaceP2)); \n    if(cosTheta1 < 0.0 || cosTheta2 < 0.0){\n    \tlightP3 = length(surfaceP1) < length(position - lightP2) ? lightP1 : lightP2;\n    }else{\n        float cosTheta = cosTheta1;\n        lightP3 = lightP1 + length(surfaceP1 * cosTheta) * normalize(P2P1);\n        \n    }\n    \n\tvec4 light = vec4(1.0) *  (dot(lightNormal, normalize(position-lightP3)));\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float theta = iTime;\n\tfloat cs = cos(theta);\n\tfloat sn = sin(theta);\n\t\n    lightP1 = vec2(lightP1.x*cs - lightP1.y*sn, lightP1.x*sn + lightP1.y*cs);\n    lightP2 = vec2(lightP2.x*cs - lightP2.y*sn, lightP2.x*sn + lightP2.y*cs);\n\tlightNormal = vec2(lightNormal.x*cs - lightNormal.y*sn, lightNormal.x*sn + lightNormal.y*cs);\n    \n    lightP1 += lightCenterPosition;\n    lightP2 += lightCenterPosition;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xx;\n\t\n    fragColor = computeSegmentLight(uv);\n}","name":"Image","description":"","type":"image"}]}