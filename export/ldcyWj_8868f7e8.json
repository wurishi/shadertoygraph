{"ver":"0.1","info":{"id":"ldcyWj","date":"1520394471","viewed":198,"name":"Thing_7","username":"balkhan","description":"draft","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["draft"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\nvec3\tret_col;\t// color far\nvec3\th;\t\t\t// accumulated color\nfloat\tscreen_dist;\n\n#define I_MAX\t\t200.\n#define E\t\t\t0.0001\n#define FAR\t\t\t110.\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\n//#define NO_SCREEN\n//#define OUTSIDE\n//#define SCANLINES\n#define PIXELS\n#define GLITCH\n\n// transition function\nfloat\ttrans(float start, float time, float speed)\n{\n\treturn 1. - clamp(exp(-time*speed+start*speed), .0, 1. );\n}\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    #ifdef NO_SCREEN\n    screen_dist=2.;\n    #else\n    screen_dist = 1.+-2.*trans(.1, mod(iTime*.5, 12.), .51)+.0*.125*sin(iTime*2.)+ -55.*trans(10., mod(iTime*.5, 12.), .25);//(1. -clamp(exp(-iTime*.125+5.), .0, 1.) ) ;\n    #endif\n    vec3\tcol = vec3(0., 0., 0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n\tvec3\tdir = camera(uv);\n    vec3\tpos = vec3(.0, .0, 0.0);\n\n    vec2\tinter = (march(pos, dir));\n    if (inter.y >= FAR)\n        ret_col = vec3(.90, .82, .70);\n    else\n        ret_col = vec3(.0,.0,.0);\n    col.xyz = ret_col*(1.-inter.x*.005);\n    col.xyz = max(col.xyz, h);\n//    col = col - (col*col*col*(2.-3.*col)); // contrast\n\n    c_out =  vec4(col*1.,1.0);\n}\n\nfloat\tscene(vec3 p)\n{  \n    float\tvar;\n    float\tmind = 1e5;\n    float displz = iTime*1.;\n    #ifdef OUTSIDE\n    p.y -= -5.25;\n    p.x -= -7.;\n    #endif\n    //p.xy += vec2(cos(iTime), sin(iTime) )*.25;\n    p.z -= displz;\n    vec3 op = p;\n    rotate(p.xy, .5*( sin(p.z*.125-iTime*.5)*3.06125+(p.z*.75)+iTime*.5) );\n    //p.xy += vec2(cos(iTime*.5), sin(iTime*.5) )*1.1005;\n    //p.xy += vec2(cos(p.z*.125)*2.3, sin(p.z*.125)*2.3);\n    vec3 pp = p;\n    pp = fract(pp)-.5;\n    \n    mind = min(mylength(pp.yz), min(mylength(pp.xy), mylength(pp.xz) ))-.051;\n    \n    mind = max(mind\n               ,\n               (mylength(p.xy)-1.570)\n              );\n    pp = p;\n    \n    mind = min(mind\n               ,\n               mylength(vec2(abs(pp.x)-.5, pp.y))-.051 // rails\n              );\n    float cadres = max(abs(abs(pp.x)-.2)-.2, max(abs(pp.y)-.2, abs(pp.z+-screen_dist+displz)-.01) );\n    vec2 texcd = 2.*vec2(abs(pp.x) , (pp.y)-.61 )*1.22;\n    if (cadres < E*1.)\n    {\n        vec3 texcol = texture(iChannel0, texcd).xyz;\n        float key;\n        \n        #ifdef GLITCH\n        // little glitch effect\n        vec2 texcdg = texcd;\n        vec2 texcdb = texcd;\n        texcdg.x += sin(floor(iTime*300.)/10.+floor(texcd.y*50.)*.1 )*.05*floor(sin( floor(texcdg.y*500.)+iTime*100. ) );\n        texcdb.x += sin(floor(iTime*300.)/10.+floor(texcd.y*50.)*.1 )*.05*floor(sin( floor(texcdb.y*500.)+iTime*100. +1.57) );\n        vec3 tcg = texture(iChannel0, texcdg).xyz;\n        vec3 tcb = texture(iChannel0, texcdb).xyz;\n        texcol = (1.*texcol+tcg+tcb)*.33333;\n        //texcol = vec3(texcol.x, tcg.y, tcb.z); // too ugly\n        // end glitch\n        #endif\n        // keying\n        key = ( (texcol.y) < length(texcol.xz) ) ? 1. : .0;\n        texcol *= key;\n        // end keying\n        \n        #ifdef SCANLINES\n        // scanlines;\n        texcol += .251*vec3(.1,.5,.1)*ceil(sin(texcd.y*150.)) * (1.-length(texcd.xy+vec2(-.3, .5) ));\n        // end scanlines\n        #endif\n        \n        #ifdef PIXELS\n        // pixels\n        texcol = texcol * abs(1.*cos(texcd.x*150.)*sin(texcd.y*150.) );\n        texcol += vec3(.25,.91,.1)*abs(.125-abs(.125*cos(texcd.x*150.)*sin(texcd.y*150.) ));\n        // end pixels\n        #endif\n    \th = (texcol*1.)*1./max(cadres*cadres , 1.);\n    }\n    mind = min(mind\n               ,\n               cadres\n              );\n    mind = min(mind\n               ,\n               mylength(vec2(mylength(vec2(abs(pp.x)-.182, abs(pp.y)-.02) )-.2, pp.z+-screen_dist+displz ))-.0251\n               );\n    mind = min(mind\n               ,\n               max(-(mylength(vec2(abs(pp.x)-.45,pp.y) )-.025), mylength(vec3(abs(pp.x)-.45,pp.y, pp.z+.75*.0-screen_dist+displz) )-.05)\n               );\n    h += vec3(.75, .45, .1)*1./max(mind*mind*30000.+10., 10.001);\n    \n    float ecrous = 1e5;\n    pp = p;\n    pp.x = abs(pp.x)-.5;\n    pp.z = mod(pp.z, .0625)-.0625*.5;\n    \n    ecrous = mylength(vec2(length(pp.xz)-.051, pp.y ))-.01251;\n\n    mind = min(mind\n               ,\n               ecrous\n               );\n    \n    float bgd = 1e5;\n    \n    bgd = length(p.xy)-3.1;\n    bgd = max(bgd, -(length(p.xy)-3.010) );\n    h += vec3(.2, .27, .74)*1./max(bgd*bgd*30000.+60., .001);\n    bgd = max(abs(bgd), .002);\n    \n    float mine = 1e5;\n    pp = op;\n    rotate(pp.xy, ( (p.z+.5)*-.030 ) +iTime*-.40);\n    op = pp;\n    pp = fract(pp-.5)-.5;\n    rotate(pp.yx, floor( (p.z+.5)*-20. )/20. +iTime*-1.0);\n    mine = mylength(pp.xyz*.15)-0.01468*3.5;\n    mine = max(mine, -(mylength(op.xy)-4.5) );\n    mine = max(mine, mylength(op.xy)-5.4999);\n    h += 1.*vec3(.1, .7, .10)*1./max(mine*mine*100000000.+250., .001);\n\n    mind = min(mind, mine);\n    mind = min(mind, bgd);\n    return (mind);\n}\n\nvec2\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec2\ts = vec2(0.0, 0.0);\n\n\t    for (float i = -1.; i < I_MAX; ++i)\n\t    {\n            vec3 dirr;\n            dirr = dir;\n            rotate(dirr.xz, dist.y*.02510+iTime*.0+1.0*sin(iTime*1.)*.2528);\n            //rotate(dirr.zy, -dist.y*.0510+iTime*.0+1.0*sin(iTime*1.)*.125);\n\t    \tp = pos + dirr * dist.y;\n\t        dist.x = scene(p);\n\t        dist.y += dist.x;\n\t        if (dist.x < E || dist.y > FAR)\n            {\n                break;\n            }\n\t        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\n// Utilities\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret;\n\n    ret = max( abs(p.x), abs(p.y) );\n    \n    return ret;\n}\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret;\n\n    ret = max(abs(p.x), max(abs(p.y), abs(p.z)));\n    return ret;\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec2\trot(vec2 p, vec2 ang)\n{\n\tfloat\tc = cos(ang.x);\n    float\ts = sin(ang.y);\n    mat2\tm = mat2(c, -s, s, c);\n    \n    return (p * m);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.-.25*abs(sin(iTime*1.125));\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n","name":"Image","description":"","type":"image"}]}