{"ver":"0.1","info":{"id":"fldBDr","date":"1663000046","viewed":141,"name":"Project1ZSB","username":"zbrubaker","description":"Project1","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","lighting","satisfying"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DISTANCE 100.0\n#define SURF_DIST 0.01\n\n\n//Code for the Torus primative\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\n\n//Code for the Rotation.\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//Code for the cylinder primative.\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\n\n//GetDist determines which object is closest to the ray and determines where to hit it.\nfloat GetDist(vec3 p){\n    float planeDist = p.y;\n\n    //Make the torus\n    vec3 res = p-vec3(3.0 * sin(iTime), 0, 5);\n    res = res.xzy;\n    res.xy *= Rot( 1.0 * sin(iTime - 3.14 / 2.0));\n    //res.xy *= Rot(2.0 * (iTime - 3.14 / 2.0));\n    float td = sdTorus(res, vec2(1.2, .2));\n    \n    //Top String\n    float cyld = sdCylinder(p,vec3(3.0 * sin(iTime), 1, 5), vec3(0, 10, 5), .01);\n    \n    //Bottom String\n    float cyld2 = sdCylinder(p,vec3(3.0 * sin(iTime), -1, 5), vec3(0, -10, 5), .01);\n    \n    //Right Sphere\n    vec4 s = vec4 (1.4 * sin(iTime + 3.1415) + 3.4,0,1.4 * cos(iTime + 3.1415) + 3.5,1); //Make a Sphere.\n    float sphereDist = length(p-s.xyz * 1.5)-s.w;\n    \n    //Left Sphere\n    //vec4 s2 = vec4 (1.4 * sin(iTime + 3.1415) - 3.4,0,1.4 * cos(iTime + 3.1415) + 3.5,1); //Shere in same rotation\n    vec4 s2 = vec4 (1.4 * sin(-iTime) - 3.4,0,1.4 * cos(-iTime) + 3.5,1); //Make a Sphere moving the opposite rotation.\n    float sphereDist2 = length(p-s2.xyz * 1.5)-s2.w;\n    \n    //Detect closest Surfaces in Ray March\n    float d = min(td, cyld);\n    d = min(cyld2, d);\n    d = min(sphereDist, d);\n    d = min(sphereDist2, d);\n    \n    \n    return d;\n    \n}\n\n//Ray march to find the distance to the object for that ray.\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    //Loop for max steps because if we miss, we want to stop before too long.\n    for (int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd * dO; //P is the point along the ray, dO gives the distance along that ray.\n        float ds = GetDist(p); //Check the distance to the nearest object, and march that amount.\n        dO += ds; //March closer along the ray no more than the distance to the nearest object.\n        if(dO > MAX_DISTANCE || ds < SURF_DIST) break; //If you are too close or too far from the nearest object, then stop.\n    }\n    return dO;\n}\n\n//Get the normal of the surface that point p is on.\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p); //Get the distance to the closest surface that p is near.\n    vec2 e = vec2(0.01, 0); //How far we go along the surface in any direction along the surface.\n    vec3 n = d - vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx)); //Check in every to go in the direction of the surface to get direction of surface.\n    return normalize(n); //Normalize the result.\n}\n\n//Use GetLight to determine the strength of the light at that point. \nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(2,2,0); // Set the position of the light origin.\n    vec3 l = normalize(lightPos - p); //Set the direction from the light origin to the point.\n    vec3 n = GetNormal(p); //Get a vector that is normal to the surface that p is on.\n    float dif = clamp(dot(n, l), 0.0, 1.0); //Get dot product of the normal to surface and the direction of light to the surface, to get light intensity at that point. \n    //Make the Shadows\n    float d = RayMarch(p+n*SURF_DIST * 2.0,l); //Start at below the shape, and if you hit anything, then make a shadow on the point.\n    if(d<length(lightPos-p)) dif *= .1;\n    return dif;\n}\n\n//Code to make the background of the image using fractal technique from: https://www.youtube.com/watch?v=8bbTkNZYdQ8\nvec3 makeBackgound(vec2 fragCoord, vec2 uv){\n    float angle = (2.0 * sin(iTime) + 6.0) * 0.1;\n\n    vec2 nc = fragCoord / iResolution.xy * 2.0 - 1.0; //Setup coordinates\n    //Make a box for inside fractal.\n    if (uv.x > -0.3 && uv.x < 0.3 && uv.y < 0.1 && uv.y > -0.1){\n        //Make the fractal\n        for(float i = 0.0; i < 50.0; i += 1.0){\n            nc = abs(nc);\n            nc -= 0.1;\n            nc *= 1.08;\n            nc *= mat2(\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n            );\n        }\n    }\n    //Second Fractal Box\n    if (uv.x > -0.5 && uv.x < 0.5 && uv.y < 0.3 && uv.y > -0.3){\n            //Make the fractal\n            for(float i = 0.0; i < 50.0; i += 1.0){\n                nc = abs(nc);\n                nc -= 0.3;\n                nc *= 1.13;\n                nc *= mat2(\n                cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n                );\n            }\n    }\n    //Outer Box of Fractle\n    if (uv.x < -0.5 || uv.x > 0.5 || uv.y > 0.3 || uv.y < -0.3){\n        //Make the fractal\n        for(float i = 0.0; i < 50.0; i += 1.0){\n            nc = abs(nc);\n            nc -= 0.5;\n            nc *= 1.05;\n            nc *= mat2(\n            cos(angle), -sin(angle),\n            sin(angle), cos(angle)\n            );\n        }\n    }\n    //Adjust Colors\n    return vec3(length(nc));\n}\n\n//Coloring of Objects\nvec3 objTexture(vec2 uv, vec3 col2){\n    return vec3(col2 + texture(iChannel0, uv + col2.xy).rgb - vec3(0.5));\n}\n\n//Apply Flash Filter For each spot where the balls pass through the ring.\nvec3 applyFilter(vec2 uv, vec3 col)  {\n\n    \n    //LeftLight\n    uv.x += uv.x + 0.55;\n    col += vec3((1.0/(length(uv) * 15.0)) * sin(iTime * 0.5 - 3.14/2.) * sin(iTime * 0.5 - 3.14/2.));\n    \n    //Right Light\n    uv.x += uv.x - 2.2;\n    col += vec3((1.0/(length(uv) * 15.0)) * sin(iTime * 0.5 - 3.14) * sin(iTime * 0.5 - 3.14));\n\n    return col;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Set the uv to be the center of the screen.\n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    //Set the ray origin\n    vec3 ro = vec3(0, 0, -5);\n    \n    //Set the ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //Determines the length along the ray, that the part of the object is at.\n    float d = RayMarch(ro, rd);\n    \n    //Get the point in 3d space that the object is at along the ray.\n    //This is found by starting at the origin, and going along the direction of the ray for length d.\n    vec3 p = ro + rd * d;\n    \n    //vec3 col = vec3(d * 0.1); //This would do the shading based off distance from the camera origin.\n    \n    //Determines the dot product of surface where you are at and the light. The higher the number, the more light.\n    float diff = GetLight(p);\n    \n    //set the backgound color\n    vec3 col = vec3(0);\n    \n    //Makes the strength of the light at that spot into a vector of rgb values for that point.\n    col = vec3(diff);\n    \n    //Shade the object as normal if the object is found\n    if(d < MAX_DISTANCE){\n        col *= objTexture(uv, col);\n        //col = vec3(diff);\n\n    }\n    //Otherwise apply the background if no object is found for that pixel\n    else{\n        col = makeBackgound(fragCoord, uv);\n    }\n    \n    //Apply flash when ball goes through hoop as filter.\n    col = applyFilter(uv, col);\n    \n    //Return the fragColor\n    \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}