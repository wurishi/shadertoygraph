{"ver":"0.1","info":{"id":"dscXDr","date":"1681012335","viewed":67,"name":"Fog Spotlight","username":"Rugged","description":"fog spotlight --- 99.999% of the poor fps comes from the blurNoise function i have\n\nAnyone know a super fast \"blurred\" noise method? (blurred as in something that isn't just pure white/ pink/ etc noise)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n\nfloat zoomNoise(vec2 p, float s){\n\n    vec2 p0 = floor(p/s);\n    \n\n    \n    float cp = hash3(p0);\n    \n    return cp;\n}\n\n\nfloat blurNoise(vec2 fragCoord){\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 col = vec4(0.);\n    \n    fragCoord += iTime * .5;\n    \n    float scale = 2.;\n    \n    col = vec4(zoomNoise(fragCoord, scale));\n    \n    \n    \n    for(int i = 0; i < 8; i++){\n        float ang = (float(i) / 8.) * PI * 2.;\n        \n        vec2 coord = vec2(cos(ang), sin(ang)) * scale;\n        \n        //mat2 r;\n        //r[0] = vec2(cos(iTime), sin(iTime));\n        //r[1] = vec2(sin(iTime), -cos(iTime));\n        \n        mat2 rConst;\n        rConst[0] = vec2(cos(1.83), sin(1.83));\n        rConst[1] = vec2(sin(1.83), -cos(1.83));\n        \n        coord *= rConst;\n        \n        vec2 p = fragCoord + coord;\n        \n        vec2 pf = floor(p);\n        \n                \n        col += vec4(zoomNoise(p, scale));\n        \n        \n        \n    }\n    \n    col /= 9.;\n    \n    \n    return col.x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvc = 2. * (uv - .5);\n    \n    \n    vec4 col = vec4(0.);\n\n    \n    \n    \n    \n    \n    \n    \n    //get the mouse location for look direction unless mouse is not down\n    vec2 muv = iMouse.z > 0.0 ? iMouse.xy / iResolution.xy : vec2(0.5, 0.3);\n    \n        \n    \n    float screenRatio = iResolution.y / iResolution.x;\n    \n    //Setting up the ray directions and other information about the point and camera\n    //##############################################################################\n    \n    \n    //camera direction angles phi (xy plane) and theta (xz plane)\n    //float phi = radians(180.);\n    //float theta = radians(105.);\n    float phi = radians(360. * (muv.x - 1.));\n    float theta = radians(180. * (1. - muv.y));\n\n    //get the camera direction as the basis for the rotation (each ray direction is a rotation of the camera direciton vector)\n    //it is in quarternion form here so its a vec4 instead of a vec3\n    vec4 camD = vec4(0., cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n    \n    \n    \n    \n    \n    \n    //rayD efficient\n    vec3 up = vec3(0., 0., 1.);\n    vec3 right = vec3(1., 0., 0.);\n    \n    vec3 U = normalize(cross(up, camD.yzw));\n    vec3 V = normalize(cross(camD.yzw, U));\n    \n    vec3 rayD = normalize(camD.yzw + uvc.x*U + uvc.y*V);\n    \n    //col = vec4(dot(rayD, right));\n    \n    vec3 lightD = normalize(vec3(cos(iTime* .5), sin(iTime * .5), -1.));\n    \n    \n    \n    vec3 sphC = vec3(-5., 0., 2.);\n    \n    vec3 p = vec3(0., 0., 3.);\n    \n    vec3 p0 = p;\n    \n    \n    for(int i = 0; i < 1000; i++){\n        p += rayD * (float(i) * .001);\n        \n        float d = distance(p, sphC);\n        \n        float noise = blurNoise(p.xy);\n        \n        \n        \n        float inSpot = dot(normalize(p - sphC), lightD) + (.05 * hash3(p.xy));\n        \n        if(inSpot > .96){\n            col += 2.5 * pow(noise, 8.) / d;\n            \n            \n        }\n        else{\n            col += .1 * pow(noise, 8.) / pow(p.z + 5.1, 1.5);\n        }\n        \n        \n        \n        if (p.z <= -4.){\n            vec4 floorC = 2. * texture(iChannel0, p.xy / 2.);\n            \n            floorC /= inSpot > .96 ? 2. : distance(p, sphC);\n            \n            col += floorC;\n            \n            break;\n        }\n        \n        \n        \n        \n        \n        \n        \n    }\n    \n    \n    \n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash3(vec2 xy){\n    xy = mod(xy, .19);\n    float h = dot(xy.yyx,vec3(.013, 27.15, 2027.3));\n    h *= h;\n    h *= fract(h);\n    \n    return fract(h);\n}\n","name":"Common","description":"","type":"common"}]}