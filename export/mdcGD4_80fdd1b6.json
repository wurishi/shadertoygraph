{"ver":"0.1","info":{"id":"mdcGD4","date":"1679946081","viewed":55,"name":"TP1l2","username":"p2002623","description":"dessine un temple","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["tp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modeling - 2023.02.06\n// Eric Galin\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n\nvec3 trans(vec3 a, vec3 b)\n{\n    return a+b;\n}\n\n// Rotation\n// p : point\n// r : rotation angle\n// x : rotation axis\nvec3 Rotation(vec3 p, float r, float ax )\n{\n    float x = p.x; float y = p.y; float z = p.z;\n    if (ax == 0.0){ // axis x\n        p.y = y*cos(r) - z*sin(r);\n        p.z = y*sin(r) + z*cos(r);\n    } else if (ax == 1.0){ // axis y\n        p.x = x*cos(r) + z*sin(r);\n        p.z = -x*sin(r) + z*cos(r);\n    } else { // axis z\n        p.x = x*cos(r) - y*sin(r);\n        p.y = x*sin(r) + y*cos(r);\n    }\n    return p;\n}\n\n// Compute the ray\n//      m : Mouse position\n//      p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(vec2 m,vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=3.5;\n  \n  // Origin\n  ro=vec3(37.,0.,15.);\n  ro*=Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,1.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  rd=normalize(p.x*u+p.y*v+le*w);\n}\n\n// Primitives\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\n\nfloat Intersection(float a,float b)\n{\n    return max(a,b);\n}\n\nfloat Plan(vec3 p, vec3 n, vec3 o)\n{\n    return dot((p-o),n);\n}\n\nfloat cube(vec3 p, vec3 c, float x, float y, float z){\n    vec3 o1 = c + vec3(x, 0, 0);\n    vec3 o2 = c + vec3(0, y, 0);\n    vec3 o3 = c + vec3(0, 0, z);\n    vec3 o4 = c + vec3(-x, 0, 0);\n    vec3 o5 = c + vec3(0, -y, 0);\n    vec3 o6 = c + vec3(0, 0, -z);\n    \n    vec3 n1 = vec3(1, 0, 0);\n    vec3 n2 = vec3(0,1,0);\n    vec3 n3 = vec3(0,0,1);\n    vec3 n4 = vec3(-1,0,0);\n    vec3 n5 = vec3(0,-1,0);\n    vec3 n6 = vec3(0,0,-1);\n    \n    float p1 = Plan(p, n1, o1);\n    float p2 = Plan(p, n2, o2);\n    float p3 = Plan(p, n3, o3); \n    float p4 = Plan(p, n4, o4);\n    float p5 = Plan(p, n5, o5);\n    float p6 = Plan(p, n6, o6);\n    \n    float f1 = Intersection(p1,p2); //On relie tout les cot√©s de la boite\n    float f2 = Intersection(p3,p4);\n    float f3 = Intersection(p5,p6);\n    \n    return Intersection(f1,Intersection(f2,f3)); // retourne la distance euclidienne d'une boite\n}\n\n// Cylinder\n// p : point\n// h : height\n// r : radius\nfloat cylindre(vec3 p, float h, float r){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n \n  \n  float w = Sphere(p,vec3(0.,0.,2.),2.25);\n // float v = Plan(vec3(1., 0. , 0.), vec3(0., 1., 0.), vec3(0. , 0., 1.));\n  \n  //float z = Union(w, v);\n  float p1 = cube(p,vec3(0.0,0.0,-2.5),9.5,10.5,.25);\n  float p2 = cube(p,vec3(0.0,0.0,-3.5),10.0,11.0,.25);\n  float p3 = cube(p,vec3(0.0,0.0, 10.),10.0,11.0,.25);\n  \n  float c1 = cylindre(Rotation(trans(p, vec3(-8.,-9.,0.0)),-1.57, 0.0), .5, 10.0);\n  float c2 = cylindre(Rotation(trans(p, vec3(-8.,9.,0.0)),-1.57, 0.0), .5, 10.0);\n  float c3 = cylindre(Rotation(trans(p, vec3(8.,-9.,0.0)),-1.57, 0.0), .5, 10.0);\n  float c4 = cylindre(Rotation(trans(p, vec3(8.,9.,0.0)),-1.57, 0.0), .5, 10.0);\n  \n  //poutre droite\n  \n  float r1 = cylindre(trans(p, vec3(9., 10., -10.)), 1., 1.);\n  float r2 = cylindre(trans(p, vec3(8., 10., -10.)), 1., 1.);\n  float r3 = cylindre(trans(p, vec3(7., 10., -10.)), 1., 1.);\n  float r4 = cylindre(trans(p, vec3(6., 10., -10.)), 1., 1.);\n  float r5 = cylindre(trans(p, vec3(5., 10., -10.)), 1., 1.);\n  float r6 = cylindre(trans(p, vec3(4., 10., -10.)), 1., 1.);\n  float r7 = cylindre(trans(p, vec3(3., 10., -10.)), 1., 1.);\n  float r8 = cylindre(trans(p, vec3(2., 10., -10.)), 1., 1.);\n  float r9 = cylindre(trans(p, vec3(1., 10., -10.)), 1., 1.);\n  float r10 = cylindre(trans(p, vec3(0., 10., -10.)), 1., 1.);\n  float r11 = cylindre(trans(p, vec3(-1., 10., -10.)), 1., 1.);\n  float r12 = cylindre(trans(p, vec3(-2., 10., -10.)), 1., 1.);\n  float r13 = cylindre(trans(p, vec3(-3., 10., -10.)), 1., 1.);\n  float r14 = cylindre(trans(p, vec3(-4., 10., -10.)), 1., 1.);\n  float r15 = cylindre(trans(p, vec3(-5., 10., -10.)), 1., 1.);\n  float r16 = cylindre(trans(p, vec3(-6., 10., -10.)), 1., 1.);\n  float r17 = cylindre(trans(p, vec3(-7., 10., -10.)), 1., 1.);\n  float r18 = cylindre(trans(p, vec3(-8., 10., -10.)), 1., 1.);\n  float r19 = cylindre(trans(p, vec3(-9., 10., -10.)), 1., 1.);\n  \n  //poutre gauche \n  \n  float g1 = cylindre(trans(p, vec3(9., -10., -10.)), 1., 1.);\n  float g2 = cylindre(trans(p, vec3(8., -10., -10.)), 1., 1.);\n  float g3 = cylindre(trans(p, vec3(7., -10., -10.)), 1., 1.);\n  float g4 = cylindre(trans(p, vec3(6., -10., -10.)), 1., 1.);\n  float g5 = cylindre(trans(p, vec3(5., -10., -10.)), 1., 1.);\n  float g6 = cylindre(trans(p, vec3(4., -10., -10.)), 1., 1.);\n  float g7 = cylindre(trans(p, vec3(3., -10., -10.)), 1., 1.);\n  float g8 = cylindre(trans(p, vec3(2., -10., -10.)), 1., 1.);\n  float g9 = cylindre(trans(p, vec3(1., -10., -10.)), 1., 1.);\n  float g10 = cylindre(trans(p, vec3(0., -10., -10.)), 1., 1.);\n  float g11 = cylindre(trans(p, vec3(-1., -10., -10.)), 1., 1.);\n  float g12 = cylindre(trans(p, vec3(-2., -10., -10.)), 1., 1.);\n  float g13 = cylindre(trans(p, vec3(-3., -10., -10.)), 1., 1.);\n  float g14 = cylindre(trans(p, vec3(-4., -10., -10.)), 1., 1.);\n  float g15 = cylindre(trans(p, vec3(-5., -10., -10.)), 1., 1.);\n  float g16 = cylindre(trans(p, vec3(-6., -10., -10.)), 1., 1.);\n  float g17 = cylindre(trans(p, vec3(-7., -10., -10.)), 1., 1.);\n  float g18 = cylindre(trans(p, vec3(-8., -10., -10.)), 1., 1.);\n  float g19 = cylindre(trans(p, vec3(-9., -10., -10.)), 1., 1.);\n  \n  float poutreL = Union(r1, Union(r2, Union(r3, Union(r4, Union(r5, Union(r6, Union(r7, Union(r8, Union(r9, Union(r10, Union(r11, Union(r12, Union(r13, Union(r14, Union(r15, Union(r16, Union(r17, Union(r18,r19))))))))))))))))));\n  float poutreG = Union(g1, Union(g2, Union(g3, Union(g4, Union(g5, Union(g6, Union(g7, Union(g8, Union(g9, Union(g10, Union(g11, Union(g12, Union(g13, Union(g14, Union(g15, Union(g16, Union(g17, Union(g18,g19))))))))))))))))));\n  float poutre = Union(poutreL, poutreG);\n\n  float c5 = cylindre(Rotation(trans(p, vec3(0.,0.,0.0)),-1.57, 0.0), 2.0, 2.0);\n  \n  float s1  = Sphere(p,vec3(0.,0.,2.), 1.5);\n  float s2  = Sphere(p,vec3(0.,0.,5.7), 0.5);\n  \n  float c6 = cylindre(Rotation(trans(p, vec3(0.,0.,0.0)),-1.57, 0.0), 0.4, 5.3);\n  \n  float te = Sphere(p,vec3(5.,0.,4.7),0.9);\n  float to = cube(p, vec3(5.0,0.0,2.1),.8,1.5,1.6);\n  float br1 = cube(p, vec3(5., 2.0, 2.0), 0.4, .6, 1.6);\n  float br2 = cube(p, vec3(5., -2.0, 2.0), 0.4, .6, 1.6);\n  float j1 = cube(p, vec3(5., 1.0, 0.4), 0.4, .6, 1.6);\n  float j2 = cube(p, vec3(5., -1.0, 0.4), 0.4, .6, 1.6);\n  \n  float corps = Union(Union(te, to), Union(Union(j2, j1),Union(br1,br2)));\n  \n  float  z = Union(p1, p2);\n  float  a = Union(z, c1);\n  float  b = Union(a, c2);\n  float  c = Union(b, c3);\n  float  d = Union(c, c3);\n  float  e = Union(d, c4);\n  float  f = Union(e, c5);\n  float  g = Union(f, s1);\n  float  h = Union(g, c6);\n  float  i = Union(h, p3);\n  float  j = Union(i, s2);\n  float  k = Union(j, corps);\n  float  l = Union(k, poutre);\n  \n  return Union(Plan(p,vec3(0.0,0.0,1.0),vec3(0.0,0.0,-4.0)), l);\n}\n\n// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  float v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z))-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z))-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps))-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float e,out bool h,out int s)\n{\n  h=false;\n  \n  // Start at the origin\n  float t=0.;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=object(p);\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 background(vec3 d)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),d.z*.5+.5);\n}\n\n// Shadowing\n// p : Point\n// n : Normal\n// l : Light direction\nfloat Shadow(vec3 p,vec3 n,vec3 l)\n{\n  bool h;\n  int s;\n  float t=SphereTrace(p+Epsilon*n,l,100.,h,s);\n  if(!h)\n  {\n    return 1.;\n  }\n  return 0.;\n}\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\nvec3 Shade(vec3 p,vec3 n,vec3 e)\n{\n  // Point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  // Light direction to point light\n  vec3 l=normalize(lp-p);\n  \n  // Ambient color\n  vec3 ambient=.25+.25*background(n);\n  \n  // Shadow computation\n  float shadow=Shadow(p,n,l);\n  \n  // Phong diffuse\n  vec3 diffuse=.35*clamp(dot(n,l),0.,1.)*vec3(1.,1.,1.);\n  \n  // Specular\n  vec3 r=reflect(e,n);\n  vec3 specular=.15*pow(clamp(dot(r,l),0.,1.),35.)*vec3(1.,1.,1.);\n  vec3 c=ambient+shadow*(diffuse+specular);\n  return c;\n}\n\n// Shading according to the number of steps in sphere tracing\n// n : Number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return.5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  \n  // Shade background\n  vec3 rgb=background(rd);\n  \n  if(hit)\n  {\n    // Position\n    vec3 p=ro+t*rd;\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    // Shade object with light\n    rgb=Shade(p,n,rd);\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}