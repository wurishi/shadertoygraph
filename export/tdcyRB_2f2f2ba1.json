{"ver":"0.1","info":{"id":"tdcyRB","date":"1601147020","viewed":131,"name":"16 - Alien Diplomat","username":"Krabcode","description":"Raymarching mangled beyond all recognition","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","crazy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made with love by Krabcode\n\n// Based on Ray Marching for Dummies!\"\n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XlGBW3\n\n\n\nconst int MAX_STEPS = 7;\nconst float MAX_DIST = 1000.;\nconst float SURF_DIST = 0.1;\nconst float NORMAL_DIST = .0001;\nconst float SHININESS = 0.05;\nconst float PI = 3.14159;\n\nfloat time; \nvec2 uv;\nvec2  lightOffset; \nvec3  lightPos;\n\nfloat rayLength;\nfloat closestDist;\nfloat hitDist;\nvec3 hit;\nvec3 intersect;\n\nmat2 rotate(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p-pos)-radius;\n}\n\nfloat sdf(vec3 p){ \n    vec3 boxSize = vec3(1.75, 1., 1.75);\n    float waveAmp = 0.8;\n    boxSize.x += waveAmp*sin(8.*p.y+time*.2);\n    boxSize.y += waveAmp*sin(6.*p.x+time*.2);\n    boxSize.z += waveAmp*sin(4.*p.x+time*0.1);\n    p.xy *= rotate(1.);\n    p.xz *= rotate(time*2.5);\n    p.yz *= rotate(2.);\n    return sdBox(p, boxSize);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) \n{\n    float dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = sdf(p);\n        closestDist = min(dS, closestDist);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p) \n{\n    float d = sdf(p);\n    vec2 e = vec2(NORMAL_DIST, 0);\n    vec3 n = d - vec3(\n        sdf(p-e.xyy),\n        sdf(p-e.yxy),\n        sdf(p-e.yyx));\n    return normalize(n);\n}\n\nfloat diffuseLight(vec3 p, vec3 normal) \n{\n    vec3 l = normalize(lightPos-p);\n    float dif = clamp(dot(normal, l), 0., 1.);\n    float d = rayMarch(p+normal*SURF_DIST*2., l);\n    if(d<length(lightPos-p)){ dif *= .1; }\n    return dif;\n}\n\n\nfloat specularLight(vec3 p, vec3 rayDir, vec3 normal) {\n    vec3 lightDir = normalize(p-lightPos);\n    vec3 reflectionDirection = reflect(-lightDir, normal);\n    float specularAngle = max(dot(reflectionDirection, rayDir), 0.);\n    return pow(specularAngle, SHININESS);\n}\n\nfloat render(vec2 uv)\n{\n    vec3 rayOrigin = vec3(uv*3., -5);\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.));\n    // rayDir.xz *= rotate(time*.01);\n    // rayDir.xz *= rotate(0.73);\n    hitDist = rayMarch(rayOrigin, rayDir);\n    hit = rayOrigin + rayDir * hitDist;\n    vec3 normal = normal(hit);\n    float diff = diffuseLight(hit, normal);   \n    float spec = specularLight(hit, rayDir, normal);\n    return .5*diff + .5*spec;\n}\n\nvec3 gammaCorrection(vec3 rgb){\n    float gamma = 2.2;\n    rgb = smoothstep(0., 1., rgb);\n    return pow(max(rgb, 0.), vec3(1.0/gamma));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = float(iFrame)*.0025;\n    lightPos = vec3(-0.5*sin(time), 0.7*cos(time),-10);\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float lit = render(uv);\n    fragColor = vec4(gammaCorrection(vec3(lit)),1.0);\n}\n","name":"Image","description":"","type":"image"}]}