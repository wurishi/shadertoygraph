{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 RaycastFloor(vec3 ray, vec3 pos) {\n    float t=(-3.-pos.y)/ray.y;\n    vec3 hit=t*ray;\n    if (t<0.) {\n        vec3 sun = vec3(0,0,1);\n        float d = dot(ray-sun,ray-sun);\n        if (d<.01)\n            return vec3(1);\n        if (d<.02) {\n            float bloom = 1.-(d*100.-1.);\n            return vec3(bloom*bloom,1,1);\n        }\n        return vec3(0,1,1);\n    }\n    return vec3(texture(iChannel0, hit.xz/2.));\n}\n\nfloat Fresnel(vec3 I, vec3 N, float ior) {\n    float cosi = clamp(-1.,1.,dot(I, N));\n    float etai = 1., etat = ior;\n    if (cosi > 0.) {\n        etai = ior;\n        etat = 1.;\n    }\n    // Compute sini using Snell's law\n    float sint = etai/etat*sqrt(max(0.,1.-cosi*cosi));\n    // Total internal reflection\n    if (sint >= 1.)\n        return 1.;\n    float cost = sqrt(max(0.,1.-sint*sint));\n    cosi = abs(cosi);\n    float Rs = (etat*cosi-etai*cost) / (etat*cosi+etai*cost);\n    float Rp = (etai*cosi-etat*cost) / (etai*cosi+etat*cost);\n    return (Rs * Rs + Rp * Rp) / 2.;\n    // As a consequence of the conservation of energy, the transmittance is given by:\n    // kt = 1 - kr;\n}\n\nvec3 SnapNorm(vec3 norm) {\n    float phi = 3.1415*(sqrt(5.)+1.);\n    for (int i = 0; i < 100; i++) {\n        float y = 1.-(float(i)/99.)*2.;\n        float radius = sqrt(1.-y*y);\n        float theta = phi*float(i);\n        float x = cos(theta)*radius;\n        float z = sin(theta)*radius;\n        vec3 p = vec3(x,y,z);\n        //float cost = cos(iTime/4.);\n        //float sint = sin(iTime/4.);\n        //p = vec3(p.x*cost-p.z*sint,p.y,p.x*sint+p.z*cost);\n        if (dot(norm,p)>.99)\n            return p;\n    }\n    return norm;\n}\n\nvec3 RaycastSphere(vec3 ray, vec3 pos) {\n    float a = dot(ray,ray);\n    float b = dot(ray,pos);\n    float c = dot(pos,pos)-1.;\n    float d = b*b-a*c;\n    if (d < 0.) return RaycastFloor(ray, vec3(0));\n    d = sqrt(d);\n    float t0 = (b+d)/a;\n    float t1 = (b-d)/a;\n    float t = min(t0,t1);\n    vec3 hit = ray*t;\n    vec3 norm = SnapNorm(hit-pos);\n    float w = 1.-Fresnel(ray,norm,1.5);\n    vec3 ray0 = reflect(ray,norm);\n    vec3 val = RaycastFloor(ray0,hit)*(1.-w);\n    ray = refract(ray,norm,1./1.5);\n    float fog = 0.;\n    for (int i = 0; i < 10; i++) {\n        a = dot(ray,ray);\n        b = dot(ray,pos-hit);\n        c = dot(pos-hit,pos-hit)-1.;\n        d = sqrt(b*b-a*c);\n        if ((b+d)/a > 0.)\n            t = (b+d)/a;\n        else\n            t = (b-d)/a;\n        hit += ray*t;\n        norm = -SnapNorm(-(pos-hit));\n        float w0 = Fresnel(ray,norm,1.5);\n        ray0 = refract(ray,norm,1.5);\n        val += RaycastFloor(ray0,hit)*w*(1.-w0);\n        fog += t*w;\n        w *= w0;\n        ray = reflect(ray,norm);\n    }\n    return val+vec3(fog/10.);\n}\n\nbool CheckTri(vec3 o, vec3 ray, vec3 v0, vec3 v1, vec3 v2, vec3 off,\nout float t, out vec3 N) {\n    // Compute the plane's normal\n    vec3 v0v1 = v1-v0;\n    vec3 v0v2 = v2-v0;\n    // No need to normalize\n    N = cross(v0v1,v0v2); // normal\n    float NdR = dot(N,ray);\n    if (NdR>0. || abs(NdR)<.0001) return false;\n    // Step 1: Finding P\n    v0 = v0+off;\n    v1 = v1+off;\n    v2 = v2+off;\n    // Compute d parameter using equation 2\n    float d = -dot(N,v0);\n    // Compute t (equation 3)\n    t = -(dot(N,o)+d)/NdR;\n    // Check if the triangle is behind the ray\n    if (t<0.) return false; // The triangle is behind\n    // Compute the intersection point using equation 1\n    vec3 P = o+t*ray;\n    // Step 2: Inside-Outside Test\n    vec3 Ne; // Vector perpendicular to triangle's plane\n    // Test sidedness of P w.r.t. edge v0v1\n    vec3 v0p = P-v0;\n    Ne = cross(v0v1,v0p);\n    if (dot(N,Ne)<0.) return false; // P is on the right side\n    // Test sidedness of P w.r.t. edge v2v1\n\tvec3 v2v1 = v2-v1;    vec3 v1p = P-v1;\n    Ne = cross(v2v1,v1p);\n    if (dot(N,Ne)<0.) return false; // P is on the right side\n    // Test sidedness of P w.r.t. edge v2v0\n\tvec3 v2v0 = v0-v2;\n    vec3 v2p = P-v2;\n    Ne = cross(v2v0,v2p);\n    if (dot(N,Ne)<0.) return false; // P is on the right side\n    return true; // The ray hits the triangle\n}\n\nvec3 verts[12] = vec3[](\nvec3(0,-0.95105652,0),\nvec3(0.85065081,-0.4253254,0),\nvec3(0.26286556,-0.4253254,0.80901699),\nvec3(-0.68819096,-0.4253254,0.5),\nvec3(-0.68819096,-0.4253254,-0.5),\nvec3(0.26286556,-0.4253254,-0.80901699),\nvec3(-0.85065081,0.4253254,0),\nvec3(-0.26286556,0.4253254,-0.80901699),\nvec3(0.68819096,0.4253254,-0.5),\nvec3(0.68819096,0.4253254,0.5),\nvec3(-0.26286556,0.4253254,0.80901699),\nvec3(0,0.95105652,0));\n\nint inds[60] = int[](\n0,1,2,    0,2,3,    0,3,4,    0,4,5,    0,5,1,\n2,1,9,    3,2,10,   4,3,6,    5,4,7,    1,5,8,\n6,7,4,    7,8,5,    8,9,1,    9,10,2,   10,6,3,\n11,7,6,   11,8,7,   11,9,8,   11,10,9,  11,6,10);\n\nvec3 RaycastMesh(vec3 ray) {\n    float t;\n    vec3 val = vec3(0);\n    for (int i = 0; i < 20; i++) {\n        int tri = i*3;\n        vec3 norm;\n        if (CheckTri(vec3(0),ray,\n        verts[inds[tri]],\n        verts[inds[tri+1]],\n        verts[inds[tri+2]],\n        vec3(0,-1,5),t,norm)) {\n            float w = 1.-Fresnel(ray,norm,1.5);\n            vec3 ray0 = reflect(ray,norm);\n            vec3 hit = ray*t;\n            val += RaycastFloor(ray0,hit)*(1.-w);\n            ray = refract(ray,norm,1./1.5);\n            for (int j = 0; j < 100; j++) {\n                for (int k = 0; k < 20; k++) {\n                    float t0;\n                    if (CheckTri(hit,ray,\n                    verts[inds[k*3]],\n                    verts[inds[k*3+2]],\n                    verts[inds[k*3+1]],\n                    vec3(0,-1,5),t0,norm)) {\n                        t = t0;\n                        float w0 = Fresnel(ray,norm,1.5);\n                        ray0 = refract(ray,norm,1.5);\n                        hit = ray*t;\n                        val += RaycastFloor(ray0,hit)*w*(1.-w0);\n                        w *= w0;\n                        ray = reflect(ray,norm);;\n                    }\n                }\n            }\n            return val;\n        }\n    }\n    return RaycastFloor(ray,vec3(0));\n}\n\n#define ANGLE 0.392699081699/2.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    vec3 ray = normalize(vec3(uv,1.));\n    ray = vec3(ray.x,ray.y*cos(ANGLE)-ray.z*sin(ANGLE),ray.y*sin(ANGLE)+ray.z*cos(ANGLE));\n    fragColor = vec4(RaycastSphere(ray, vec3(0,sin(iTime)/2.-1.5,7)),1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ccBWl","date":"1733931142","viewed":47,"name":"glassball rtx","username":"ZoldLeo","description":"a ball of glass (how do I add shadow for this)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rtx"],"hasliked":0,"parentid":"","parentname":""}}