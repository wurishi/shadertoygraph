{"ver":"0.1","info":{"id":"NttfR2","date":"1716556728","viewed":29,"name":"Tesseract by Erik","username":"eriben0628","description":"j","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["j"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979\n\nmat4x4 rotationMatrixXZ(float v) {\n    mat4x4 mat = mat4x4(\n        cos(v),0.0,sin(v),0.0,\n        0.0,1.0,0.0,0.0,\n        -sin(v),0.0,cos(v),0.0,\n        0.0,0.0,0.0,1.0\n    );\n    \n    return mat;\n}\n\nmat4x4 rotationMatrixZW(float v) {\n    mat4x4 mat = mat4x4(\n        1.0,0.0,0.0,0.0,\n        0.0,1.0,0.0,0.0,\n        0.0,0.0,cos(v),sin(v),\n        0.0,0.0,-sin(v),cos(v)\n    );\n    return mat;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec4 CameraPos = vec4(0.0, 0.0, -2.3, -2.3);\n    \n    vec4 points[] = vec4[] ( \n        vec4(-1.0,-1.0,-1.0,-1.0), \n        vec4(1.0,-1.0,-1.0,-1.0), \n        vec4(1.0,1.0,-1.0,-1.0), \n        vec4(-1.0,1.0,-1.0,-1.0), \n        \n        vec4(-1.0,-1.0,1.0,-1.0), \n        vec4(1.0,-1.0,1.0,-1.0), \n        vec4(1.0,1.0,1.0,-1.0), \n        vec4(-1.0,1.0,1.0,-1.0),\n        \n        vec4(-1.0,-1.0,-1.0,1.0), \n        vec4(1.0,-1.0,-1.0,1.0), \n        vec4(1.0,1.0,-1.0,1.0), \n        vec4(-1.0,1.0,-1.0,1.0), \n        \n        vec4(-1.0,-1.0,1.0,1.0), \n        vec4(1.0,-1.0,1.0,1.0), \n        vec4(1.0,1.0,1.0,1.0), \n        vec4(-1.0,1.0,1.0,1.0)\n    );\n    \n    ivec2 lines[] = ivec2[] (\n        ivec2(0,1),\n        ivec2(1,2),\n        ivec2(2,3),\n        ivec2(3,0),\n        \n        ivec2(4,5),\n        ivec2(5,6),\n        ivec2(6,7),\n        ivec2(7,4),\n        \n        ivec2(0,4),\n        ivec2(1,5),\n        ivec2(2,6),\n        ivec2(3,7),\n        \n        \n        ivec2(8,9),\n        ivec2(9,10),\n        ivec2(10,11),\n        ivec2(11,8),\n        \n        ivec2(12,13),\n        ivec2(13,14),\n        ivec2(14,15),\n        ivec2(15,12),\n        \n        ivec2(8,12),\n        ivec2(9,13),\n        ivec2(10,14),\n        ivec2(11,15),\n        \n        \n        \n        ivec2(0,8),\n        ivec2(1,9),\n        ivec2(2,10),\n        ivec2(3,11),\n        \n        ivec2(4,12),\n        ivec2(5,13),\n        ivec2(6,14),\n        ivec2(7,15)\n    );\n    \n    float minDist = 10000.0;\n    \n    mat4x4 rotationZW = rotationMatrixZW(iTime);\n    mat4x4 rotationXZ = rotationMatrixXZ(PI*0.2);\n    \n    for(int i = 0; i < min(int(iTime*0.5),32); i++) {\n        ivec2 line = lines[i];\n        vec4 PointA = points[line.x];\n        vec4 PointB = points[line.y];\n        \n        PointA *= rotationZW;\n        PointB *= rotationZW;\n        \n        PointA *= rotationXZ;\n        PointB *= rotationXZ;\n        \n        //vec3 pointA = PointA * mat3x4(1.0/(PointA.w-CameraPos.w),0.0,0.0,0.0 , 0.0,1.0/(PointA.w-CameraPos.w),0.0,0.0 , 0.0,0.0,1.0/(PointA.w-CameraPos.w),0.0);\n        //vec3 pointB = PointB * mat3x4(1.0/(PointB.w-CameraPos.w),0.0,0.0,0.0 , 0.0,1.0/(PointB.w-CameraPos.w),0.0,0.0 , 0.0,0.0,1.0/(PointB.w-CameraPos.w),0.0);\n        //vec2 pointa = pointA * mat2x3(1.0/(pointA.z-CameraPos.z),0.0,0.0 , 0.0,1.0/(pointA.z-CameraPos.z),0.0);\n        //vec2 pointb = pointB * mat2x3(1.0/(pointB.z-CameraPos.z),0.0,0.0 , 0.0,1.0/(pointB.z-CameraPos.z),0.0);\n        float An = 1.0/(PointA.w-CameraPos.w);\n        float Bn = 1.0/(PointB.w-CameraPos.w);\n        vec3 pointA = PointA.xyz*An;\n        vec3 pointB = PointB.xyz*Bn;\n        \n        float an = 1.0/(pointA.z-CameraPos.z);\n        float bn = 1.0/(pointB.z-CameraPos.z);\n        vec2 pointa = pointA.xy*an;\n        vec2 pointb = pointB.xy*bn;\n        \n        float d = distanceToLine(pointa, pointb, uv);\n        \n        minDist = min(minDist, d);\n        if(d<0.001) break;\n    }\n    minDist = ceil(minDist-0.001);\n    \n    vec3 col = vec3(minDist);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float distanceToLine1(vec2 p1, vec2 p2, vec2 p3) {\n    float n = (p2.x-p1.x)*(p2.x-p1.x)+(p2.y-p1.y)*(p2.y-p1.y);\n    float xt = 0.0;\n    xt += (p2.x-p1.x)*(p2.x-p1.x)*p3.x;\n    xt += (p2.y-p1.y)*(p2.y-p1.y)*p1.x;\n    xt += (p3.y-p1.y)*(p2.x-p1.x)*(p2.y-p1.y);\n    \n    float yt = 0.0;\n    yt += (p2.y-p1.y)*(p2.y-p1.y)*p3.y;\n    yt += (p2.x-p1.x)*(p2.x-p1.x)*p1.y;\n    yt += (p3.x-p1.x)*(p2.y-p1.y)*(p2.x-p1.x);\n    \n    xt /= n;\n    yt /= n;\n    vec2 intersectPoint = vec2(xt,yt);\n    \n    float l = (xt-p3.x)*(xt-p3.x)+(yt-p3.y)*(yt-p3.y);\n    float maxBoundX = max(p1.x,p2.x);\n    float maxBoundY = max(p1.y,p2.y);\n    \n    float minBoundX = min(p1.x,p2.x);\n    float minBoundY = min(p1.y,p2.y);\n    \n    float distToclosestPoint = min(length(p3-p1),length(p3-p2));\n    distToclosestPoint *= distToclosestPoint;\n    \n    if(xt > maxBoundX) return distToclosestPoint;\n    if(yt > maxBoundY) return distToclosestPoint;\n    if(xt < minBoundX) return distToclosestPoint;\n    if(yt < minBoundY) return distToclosestPoint;\n    \n    \n    return l;\n}\n\nfloat distanceToLine(vec2 a, vec2 b, vec2 p) {\n\n    /*\n    float maxBoundX = max(a.x,b.x);\n    float maxBoundY = max(a.y,b.y);\n    \n    float minBoundX = min(a.x,b.x);\n    float minBoundY = min(a.y,b.y);\n    float l = min(dot(p-a,p-a),dot(p-b,p-b));\n    if(p.x < minBoundX-0.1) return l;\n    if(p.y < minBoundY-0.1) return l;\n    if(p.x > maxBoundX+0.1) return l;\n    if(p.y > maxBoundY+0.1) return l;\n    */\n    \n    float h = dot(p-a,b-a)/dot((b-a),(b-a));\n    h = min(1.0,max(0.0,h));\n    float d = dot(p-a - h*(b-a) , p-a - h*(b-a));\n    return d;\n}","name":"Common","description":"","type":"common"}]}