{"ver":"0.1","info":{"id":"cd2fzd","date":"1690038121","viewed":55,"name":"kiki111222","username":"kiki2586677","description":"111222","likes":1,"published":1,"flags":32,"usePreview":1,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NOISE 0.00346020761245674740484429065744f\n#define FREQUENCY 10.3\n#define RGBSPLIT 37.8\n#define JUMPINDENSITY 0.1\n#define SPLITTINGNUMBER 14.0\n#define JITTERAMOUNT 0.7\n#define JITTERSPEED 0.15\n#define BLOCKSIZE 0.0\n#define MAXRGBSPLITX 1.0\n#define MAXRGBSPLITY 1.0\n#define FADING 2.0\n#define LUMINANCEJITTERTHREASHOLD 0.895\n#define NOISESPEED 0.102\n#define SCANLINEJITTERAMOUNT 3.45\n#define WAVEJITTERAMOUNT 0.5\n#define WAVESPEED 10.32\n\n\n\nvec3 taylorInvSqrt(vec3 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec2 mod289(vec2 x)\n{\n\treturn x - floor(x * NOISE) * 289.0;\n}\n\nvec3 mod289(vec3 x)\n{\n\treturn x - floor(x * NOISE) * 289.0;\n}\n\nvec3 permute(vec3 x)\n{\n\treturn mod289(x * x * 34.0 + x);\n}\n\nfloat randomNoise(vec2 seed)\n{\n\treturn fract(sin(dot(seed * floor(iTime * 30.0), vec2(17.13, 3.71))) * 43758.5453123);\n}\n\nfloat randomNoise(float seed)\n{\n\treturn randomNoise(vec2(seed, 1.0));\n}\n\n    \nfloat randomNoise(float x, float y)\n{\n\treturn fract(sin(dot(vec2(x, y), vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat snoise(vec2 v)\n{\n\tconst vec4 C = vec4(0.211324865405187, 0.366025403784439, - 0.577350269189626, 0.024390243902439);\n\tvec2 i = floor(v + dot(v, C.yy));\n\tvec2 x0 = v - i + dot(i, C.xx);\n\t\n\tvec2 i1;\n\ti1.x = step(x0.y, x0.x);\n\ti1.y = 1.0 - i1.x;\n\tvec2 x1 = x0 + C.xx - i1;\n\tvec2 x2 = x0 + C.zz;\n\t\n\ti = mod289(i);\n\tvec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n\t+ i.x + vec3(0.0, i1.x, 1.0));\n\t\n\tvec3 m = max(0.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n\tm = m * m;\n\tm = m * m;\n\t\n\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\tvec3 h = abs(x) - 0.5;\n\tvec3 ox = floor(x + 0.5);\n\tvec3 a0 = x - ox;\n\t\n\tm *= taylorInvSqrt(a0 * a0 + h * h);\n\t\n\tvec3 g;\n\tg.x = a0.x * x0.x + h.x * x0.y;\n\tg.y = a0.y * x1.x + h.y * x1.y;\n\tg.z = a0.z * x2.x + h.z * x2.y;\n\treturn 130.0 * dot(m, g);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float strength = 0.5 + 0.5 *cos(iTime * FREQUENCY);\n    vec2 uv = fragCoord/iResolution.xy;\n    if(fract(iTime) < 0.93) {\n    fragColor = texture(iChannel0, uv);\n} else{\n    \n    // Screen jump\n    float _JumpTime = iTime * JUMPINDENSITY * 5.8;\n    float hJump = mix(uv.x, fract(uv.x + _JumpTime), JUMPINDENSITY);    \n    //float vJump = mix(uv.y, fract(uv.y + _JumpTime), JUMPINDENSITY);\n    \n    // Tile Jitter\n\tfloat pixelSizeX = 1.0 / iResolution.x;\n\n\tif (mod(uv.y * SPLITTINGNUMBER, 2.0) < 1.0)\n\t{\n        uv.x += pixelSizeX * cos(iTime * JITTERSPEED) * JITTERAMOUNT * strength;\n\t}\n    \n    // Image Block\n    float block = randomNoise(floor(uv * BLOCKSIZE));\n\n\tfloat displaceNoise = pow(block, 8.0) * pow(block, 3.0);\n\tfloat splitRGBNoise = pow(randomNoise(7.2341), 17.0);\n\tfloat offsetX = displaceNoise - splitRGBNoise * MAXRGBSPLITX;\n\tfloat offsetY = displaceNoise - splitRGBNoise * MAXRGBSPLITY;\n\n\tfloat noiseX = 0.05 * randomNoise(13.0);\n\tfloat noiseY = 0.05 * randomNoise(7.0);\n\tvec2 offset = vec2(offsetX * noiseX, offsetY* noiseY);\n\n\tvec4 iColorR = texture(iChannel0, uv);\n\tvec4 iColorG = texture(iChannel0, uv + offset);\n\tvec4 iColorB = texture(iChannel0, uv - offset);\n    \n    // Wave Jitter\n    float noise_wave_1 = snoise(vec2(uv.y, iTime * WAVESPEED * 20.0)) * (strength * WAVEJITTERAMOUNT * 32.0);\n    float noise_wave_2 = snoise(vec2(uv.y, iTime * WAVESPEED * 10.0)) * (strength * WAVEJITTERAMOUNT * 4.0);\n\tfloat noise_wave_x = noise_wave_1 * noise_wave_2 / iResolution.x;\n\tfloat uv_x = uv.x + noise_wave_x;\n    float rgbSplit_uv_x = (RGBSPLIT * 50.0 + (20.0 * strength + 1.0)) * noise_wave_x / iResolution.x;;\n    \n    // Scanline Jitter\n\tfloat jitter = randomNoise(uv.y, iTimeDelta) * 2.0 - 1.0;\n    float threshold = clamp(1.0f - JUMPINDENSITY * 1.2f, 0.0, 1.0);\n\tjitter *= step(threshold, abs(jitter)) * SCANLINEJITTERAMOUNT * strength;\t\n    \n    // Analog Noise\n    vec4 sceneColor = texture(iChannel0, uv);\n    vec4 noiseColor = sceneColor;\n\n    float luminance = dot(noiseColor.rgb, vec3(0.22, 0.707, 0.071));\n    if (randomNoise(vec2(iTimeDelta * NOISESPEED, iTimeDelta * NOISESPEED)) > LUMINANCEJITTERTHREASHOLD)\n\t{\n\t\tnoiseColor = vec4(luminance, luminance, luminance, luminance);\n\t}\n\n\tfloat aNoiseX = randomNoise(iTimeDelta * NOISESPEED + uv / vec2(-213, 5.53));\n\tfloat aNoiseY = randomNoise(iTimeDelta * NOISESPEED - uv / vec2(213, -5.53));\n\tfloat aNoiseZ = randomNoise(iTimeDelta * NOISESPEED + uv / vec2(213, 5.53));\n\n\tnoiseColor.rgb += 0.25 * vec3(aNoiseX,aNoiseY,aNoiseZ) - 0.125;\n    \n    \n    // Mixing\n    vec4 originalColor = texture(iChannel0, uv);\n    vec4 colorG = texture(iChannel0, vec2(uv_x, uv.y));\n    vec4 colorRB = texture(iChannel0, vec2(uv_x + rgbSplit_uv_x, uv.y));\n    vec4 jumpColor = texture(iChannel0, fract(vec2(uv.x, hJump)));\n    vec4 waveColor = vec4(colorRB.r, colorG.g, colorRB.b, colorRB.a + colorG.a);\n    vec4 jumpWaveMix = mix(jumpColor, waveColor, jumpColor.a);\n    vec4 imageBlockColor = vec4(iColorR.r , iColorG.g, iColorB.z, (iColorR.a + iColorG.a + iColorB.a));\n    vec4 tileColor = mix(originalColor, jumpWaveMix, originalColor.a);\n    vec4 scanlineJitterColor = texture(iChannel0, fract(uv + vec2(jitter, 0)));\n    vec4 imageBlockTileMix = mix(imageBlockColor, tileColor, imageBlockColor.a);\n    vec4 analogNoiseColor = mix(sceneColor, noiseColor, FADING);\n    vec4 scanlineImageBlockTileMix = mix(scanlineJitterColor, imageBlockTileMix, scanlineJitterColor.a);\n    \n    \n    // Output to screen\n    fragColor = mix(analogNoiseColor, scanlineImageBlockTileMix, analogNoiseColor.a);\n   \n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n#define DISCO_COLOR 9\n\nconst float PI = 3.1415926536;\n\nvec3 BACKGROUND_COLOR = vec3(0.1, 0.3, 1);\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 3;\n\n// Ray marching for sdf, steps and threshold\nconst int NUM_MARCHSIZE = 100;\nconst float MARCH_EPSILO = 10e-5;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 4;\nconst int NUM_PLANES = 4;\nconst int NUM_SPHERES = 8;\nconst int NUM_Cylinder = 54;\n\nconst int NUM_TORUS = 18;\nconst int TORUS_RING = 18;\nconst float RING_RAD = 0.015; \n// need to update it once you add some material\nconst int RING_MATERIAL_START = 16;\n// Depends on how many ring we will have\nconst int NUM_MATERIALS = RING_MATERIAL_START + TORUS_RING;\n\nfloat blockNum = 1.;\nfloat blockLength = 3.0;\n\n// Cyberpunk mat\nconst int CYBER_MATERIAL = 15;\nconst int CYBER_PHERE = 6;\n#define CYBER_CHANNEL iChannel1\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID_1;\n    int materialID_2;\n    int type; // 0 is for normal plane, 1 is for grid.\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\nstruct Cylinder_t {\n    vec3 vertexA;\n    vec3 vertexB;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\nstruct Torus_t {\n    vec3 center;    // Center of the Torus.\n    float majorRadius;  // Major radius (radius of the tube).\n    float minorRadius;  // Minor radius (radius of the torus cross-section).\n    mat3 rotationMat;\n    int materialID;\n};\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\nCylinder_t Cylinder[NUM_Cylinder];\nTorus_t Torus[NUM_TORUS];\n\n// help function\nmat3 rotateY(float r) {\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, 0, cs.y, 0, 1, 0, -cs.y, 0, cs.x);\n}\nmat3 rotateZ(float r) {\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(cs.x, cs.y, 0., -cs.y, cs.x, 0., 0., 0., 1.);\n}\nmat3 rotateX(float r) {\n    vec2 cs = vec2(cos(r), sin(r));\n    return mat3(1.0,  0.0,    0.0,\n                0.0,  cs.x, -cs.y,\n                0.0,  cs.y,  cs.x);\n}\n\nvoid DrawPlane() {\n  // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID_1 = 0;\n    Plane[0].type = 0;\n    \n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID_1 = 9;\n    Plane[1].type = 0;\n    // left plane\n    Plane[2].A = 1.0;\n    Plane[2].B = 0.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 5.0;\n    Plane[2].materialID_1 = 9;\n    Plane[2].type = 0;\n    \n    // right plane\n    Plane[3].A = -1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = 12.5;\n    Plane[3].materialID_1 = 8;\n    Plane[3].materialID_2 = 8;\n    Plane[3].type = 1;\n\n}\n\nvoid DrawSphere() {\n \n    Sphere[2].center = vec3( 1.0,0.20, -2.0);\n    Sphere[2].radius = 0.2;\n    Sphere[2].materialID = 12;\n    // sphere in cube\n    Sphere[3].center = vec3(1.8, 0.20, 3.0);\n    Sphere[3].radius = 0.2;\n    Sphere[3].materialID = 4;\n    //jumping green ball\n    Sphere[4].center = vec3(2.0,0.20+abs(sin(iTime)), -1.0);\n    Sphere[4].radius = 0.2;\n    Sphere[4].materialID = 3;\n    \n    //cuber balls\n    // Sphere[5].center = vec3(1.5,0.1, 0.2);\n    // Sphere[5].radius = 0.1;\n    // Sphere[5].materialID = 5;\n    \n    // change to cyber punk material\n    Sphere[6].center = vec3(-1.0, 0.55, 3.0);\n    Sphere[6].radius = 0.5;\n    Sphere[6].materialID = CYBER_MATERIAL;\n    \n    //silver balls\n    Sphere[7].center = vec3(3, 0.4, 2);\n    Sphere[7].radius = 0.3;\n    Sphere[7].materialID = 0;\n}\n\nvoid DrawCylinder() {\n //Double quadrangular cone\n    vec3 Cylinder_start=vec3(1.414*sin(iTime),0.5+0.3*sin(iTime*3.0+0.6),1.414*cos(iTime))*2.0;\n    for(int i=0;i<12;i++)\n    {\n        Cylinder[i].materialID = 11;\n        Cylinder[i].radius=0.02;\n    }\n   Cylinder[0].vertexA =  Cylinder_start;\n    Cylinder[0].vertexB = Cylinder_start+vec3(0.618*sin(iTime),1.0,0.618*cos(iTime)); \n    \n    \n    Cylinder[1].vertexA = Cylinder_start; \n    Cylinder[1].vertexB = Cylinder_start+vec3(0.618*sin(iTime+PI/2.0),1.0,0.618*cos(iTime+PI/2.0)); \n    \n    \n    Cylinder[2].vertexA = Cylinder_start; \n    Cylinder[2].vertexB = Cylinder_start+vec3(0.618*sin(iTime+PI),1.0,0.618*cos(iTime+PI)); \n    \n    \n    Cylinder[3].vertexA = Cylinder_start; \n    Cylinder[3].vertexB = Cylinder_start+vec3(0.618*sin(iTime+PI*3.0/2.0),1.0,0.618*cos(iTime+PI*3.0/2.0)); \n    \n    \n    Cylinder[4].vertexA = Cylinder_start+vec3(0.618*sin(iTime),1.0,0.618*cos(iTime)); \n    Cylinder[4].vertexB = Cylinder_start+vec3(0.0,2.0,0.0); \n    \n    Cylinder[5].vertexA = Cylinder_start+vec3(0.618*sin(iTime+PI/2.0),1.0,0.618*cos(iTime+PI/2.0)); \n    Cylinder[5].vertexB = Cylinder_start+vec3(0.0,2.0,0.0); \n    \n    Cylinder[6].vertexA = Cylinder_start+vec3(0.618*sin(iTime+PI),1.0,0.618*cos(iTime+PI)); \n    Cylinder[6].vertexB = Cylinder_start+vec3(0.0,2.0,0.0); \n    \n    Cylinder[7].vertexA = Cylinder_start+vec3(0.618*sin(iTime+PI*3.0/2.0),1.0,0.618*cos(iTime+PI*3.0/2.0)); \n    Cylinder[7].vertexB = Cylinder_start+vec3(0.0,2.0,0.0); \n    \n    Cylinder[8].vertexA = Cylinder_start+vec3(0.618*sin(iTime),1.0,0.618*cos(iTime)); \n    Cylinder[8].vertexB = Cylinder_start+vec3(0.618*sin(iTime+PI/2.0),1.0,0.618*cos(iTime+PI/2.0)); \n    \n    Cylinder[9].vertexA = Cylinder_start+vec3(0.618*sin(iTime),1.0,0.618*cos(iTime)); \n    Cylinder[9].vertexB = Cylinder_start+vec3(0.618*sin(iTime-PI/2.0),1.0,0.618*cos(iTime-PI/2.0)); \n    \n    Cylinder[10].vertexA = Cylinder_start+vec3(0.618*sin(iTime+PI),1.0,0.618*cos(iTime+PI)); \n    Cylinder[10].vertexB = Cylinder_start+vec3(0.618*sin(iTime-PI/2.0),1.0,0.618*cos(iTime-PI/2.0)); \n    \n    Cylinder[11].vertexA = Cylinder_start+vec3(0.618*sin(iTime+PI),1.0,0.618*cos(iTime+PI)); \n    Cylinder[11].vertexB = Cylinder_start+vec3(0.618*sin(iTime+PI/2.0),1.0,0.618*cos(iTime+PI/2.0)); \n    for(int i=0;i<12;i++)\n    {\n        Cylinder[i].vertexA*=0.5;\n        Cylinder[i].vertexB*=0.5;\n    }\n    \n    //Regular icosahedron \n    vec3 icosahedroncenter=vec3(0.0,1.0,0.0);\n    vec3 icosahedronVetex[12];\n    float m=0.52573111211913360602566908484788;\n    float n=0.85065080835203993218154049706301;\n    mat3 R = mat3 (cos(iTime), 0.0, sin(iTime),\n                    0.0, 1.0, 0.0,\n                    -sin(iTime), 0.0, cos(iTime));\n    icosahedronVetex[0]=icosahedroncenter+R*vec3(m,0.0,n);\n    icosahedronVetex[1]=icosahedroncenter+R*vec3(m,0.0,-n);\n    icosahedronVetex[2]=icosahedroncenter+R*vec3(-m,0.0,n);\n    icosahedronVetex[3]=icosahedroncenter+R*vec3(-m,0.0,-n);\n    \n    icosahedronVetex[4]=icosahedroncenter+R*vec3(0.0,n,m);\n    icosahedronVetex[5]=icosahedroncenter+R*vec3(0.0,n,-m);\n    icosahedronVetex[6]=icosahedroncenter+R*vec3(0.0,-n,m);\n    icosahedronVetex[7]=icosahedroncenter+R*vec3(0.0,-n,-m);\n    \n    icosahedronVetex[8]=icosahedroncenter+R*vec3(n,m,0.0);\n    icosahedronVetex[9]=icosahedroncenter+R*vec3(n,-m,0.0);\n    icosahedronVetex[10]=icosahedroncenter+R*vec3(-n,m,0.0);\n    icosahedronVetex[11]=icosahedroncenter+R*vec3(-n,-m,0.0);\n    int num = 12;\n    // Draw 12 width\n   for(int i=0;i<12;i++)\n    {\n        for(int j=0;j<i;j++)\n        {\n            vec3 tem=(icosahedronVetex[i]+icosahedronVetex[j])/2.0;\n            tem=tem-icosahedroncenter;\n\n            if(length(tem)>0.85)\n            {\n                Cylinder[num].vertexA =  icosahedronVetex[i];\n                Cylinder[num].vertexB = icosahedronVetex[j];\n                Cylinder[num].materialID = 11;\n                Cylinder[num].radius=0.05;\n                num += 1;\n            }\n        }\n    }\n    \n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 0.0,1.0, 0.0 );\n    Sphere[0].radius = 0.45;\n    Sphere[0].materialID = 12;\n\n    // Circling sphere.\n    Sphere[1].center = Cylinder_start*0.5+vec3(0.0,0.5,0.0);\n    Sphere[1].radius = 0.15;\n    Sphere[1].materialID = 13;\n    \n    //draw cube\n    float a=1.0;\n    vec3 cubecenter=vec3(3.6,a/2.0,6.0);\n    vec3 cubevertex[8];\n    \n    cubevertex[0]=(cubecenter+vec3(a/2.0,a/2.0,a/2.0))*0.5;\n    cubevertex[1]=(cubecenter+vec3(a/2.0,a/2.0,-a/2.0))*0.5;\n    cubevertex[2]=(cubecenter+vec3(-a/2.0,a/2.0,a/2.0))*0.5;\n    cubevertex[3]=(cubecenter+vec3(-a/2.0,a/2.0,-a/2.0))*0.5;\n    \n    cubevertex[4]=(cubecenter+vec3(a/2.0,-a/2.0,+a/2.0))*0.5;\n    cubevertex[5]=(cubecenter+vec3(a/2.0,-a/2.0,-a/2.0))*0.5;\n    cubevertex[6]=(cubecenter+vec3(-a/2.0,-a/2.0,+a/2.0))*0.5;\n    cubevertex[7]=(cubecenter+vec3(-a/2.0,-a/2.0,-a/2.0))*0.5;\n    \n  //  num = num + 1;\n    // draw cube\n    for(int i=0;i<8;i++){\n        for(int j=0;j<i;j++)\n        {\n            vec3 tem=(cubevertex[i]+ cubevertex[j])/2.0;\n            tem=tem- cubecenter*0.5;\n\n            if(length(tem)>0.7*0.5)\n            {\n                Cylinder[num].vertexA =  cubevertex[i];\n                Cylinder[num].vertexB =  cubevertex[j];\n                Cylinder[num].materialID = 11;\n                Cylinder[num].radius=0.03;\n                num = num + 1;\n            }\n            \n        }\n    }\n}\n\nvoid DrawTorus() {\n    // Init ring.\n\n    vec3 ring_center = vec3(2.7, 1.2 ,1.2);\n    float large_r = float(TORUS_RING) * RING_RAD + 0.33;\n    float outter_line = large_r;\n    float t = iTime*.35;\n\n    // Define ring color.    \n    vec3 inner_color = vec3(0.0, 0.6, 0.3);    // dark blue\n    vec3 outer_color = vec3(1.0, 0.9, 0.0); // yellow\n    \n    for(int i=0; i < TORUS_RING; i++) {\n        \n        int matIdx = RING_MATERIAL_START + i;\n        \n        vec3 interpolatedColor = mix(outer_color, inner_color, large_r/outter_line);\n        vec3 clampedColor = clamp(interpolatedColor, vec3(0.0), vec3(1.0));\n\n        Material[matIdx].k_d = clampedColor;\n        Material[matIdx].k_a = 0.2 * mix(clampedColor, inner_color, 0.5);\n        Material[matIdx].k_r = 2.0 * outer_color;\n        Material[matIdx].k_rg = 0.5 * Material[matIdx].k_d;\n        Material[matIdx].n = 32.0;\n    \n        // set ring.\n        Torus[i].center = ring_center;\n        Torus[i].majorRadius = large_r;\n        Torus[i].minorRadius = RING_RAD;\n        \n        // rot ring.\n        Torus[i].rotationMat = i ==0 ?  rotateZ(t) * rotateY(t*.5) : \n                                 Torus[i-1].rotationMat * rotateZ(t) * rotateY(t*.5);\n        Torus[i].materialID = matIdx;\n        large_r -= RING_RAD * 2.2;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n//Double quadrangular cone\n   \n    \n    DrawCylinder();\n    DrawPlane();\n    DrawSphere();\n    DrawTorus();\n    \n    \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.9 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    //green shining material\n    Material[2].k_d = vec3( 0.0, 20, 0.0 );\n    Material[2].k_a = 0.2 *Material[2].k_d;\n    Material[2].k_r = 0.3*Material[2].k_d;\n    Material[2].k_rg = 0.1*Material[2].k_d;\n    Material[2].n = 128.0;\n\n    //Copper material\n    Material[3].k_d = vec3(0.8, 0.4, 0.1);\n    Material[3].k_a = vec3(0.1, 0.9, 0.1);\n    Material[3].k_r = vec3(0.9, 0.1, 0.9); ;\n    Material[3].k_rg = vec3(0.9, 0.1, 0.9);;\n    Material[3].n = 15.0;\n    \n    //Red diomand\n    Material[4].k_d = vec3( 0.614240, 0.041360, 0.041360 );\n    Material[4].k_a = vec3( 0.174500, 0.011750, 0.011750 );\n    Material[4].k_r = vec3( 0.727811, 0.626959, 0.626959 );\n    Material[4].k_rg = vec3( 0.550000, 0.550000, 0.550000);\n    Material[4].n = 128.0;\n    \n    //pearl\n    Material[5].k_d = vec3( 1.000000, 0.829000, 0.829000 );\n    Material[5].k_a = vec3( 0.250000, 0.207250, 0.207250 );\n    Material[5].k_r = vec3( 0.296648, 0.296648, 0.296648 );\n    Material[5].k_rg = 0.4 * Material[5].k_r;\n    Material[5].n = 128.0;\n    \n    //Bronze\n    Material[6].k_d = vec3( 0.714000, 0.428400, 0.181440 );\n    Material[6].k_a = vec3( 0.212500, 0.127500, 0.054000 );\n    Material[6].k_r = vec3( 0.393548, 0.271906, 0.166721 );\n    Material[6].k_rg = 0.4 * Material[6].k_r;\n    Material[6].n = 128.0;\n    \n    //violet\n    Material[7].k_d = vec3( 161.0, 72.0, 66.0 )/255.0;\n    Material[7].k_a =  0.2 * Material[6].k_d;\n    Material[7].k_r =  2.0 * Material[6].k_d;\n    Material[7].k_rg = 0.5 * Material[6].k_r;\n    Material[7].n = 128.0;\n    \n    //black\n    Material[8].k_d = vec3( 0., 0., 0. );\n    Material[8].k_a = vec3( 0.110000, 0.060000, 0.090000 );\n    Material[8].k_r = vec3( 0.330000, 0.330000, 0.520000 );\n    Material[8].k_rg = 0.4 * Material[8].k_r;\n    Material[8].n = 128.0;\n    \n    //special\n    Material[9].k_d = vec3( 0., 0., 0. );\n    Material[9].k_a = vec3( 0.0, 0.0, 0.0 );\n    Material[9].k_r = vec3( 0.0, 0.0, 0.0 );\n    Material[9].k_rg = 0.4 * Material[9].k_r;\n    Material[9].n = 128.0;\n    \n    // Silver material.\n    Material[10].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[10].k_a = 0.2 * Material[0].k_d;\n    Material[10].k_r = 2.0 * Material[0].k_d;\n    Material[10].k_rg = 0.5 * Material[0].k_r;\n    Material[10].n = 128.0;\n\n    //black material 3-->11\n    Material[11].k_d = vec3(0.11, 0.11, 0.11);\n    Material[11].k_a =  0.2 * Material[3].k_d;\n    Material[11].k_r =  2.0 * Material[3].k_d;\n    Material[11].k_rg = 0.8 * Material[3].k_r;\n    Material[11].n = 128.0;\n    \n    //blue shining material 4-->12\n    Material[12].k_d = vec3(0, 5,5) ;\n    Material[12].k_a = 0.3 * Material[4].k_d;\n    Material[12].k_r = 0.8 * Material[4].k_d;\n    Material[12].k_rg = 0.20 * Material[4].k_r;\n    Material[12].n = 60.0;\n    \n    //red shining material 5-->13\n    Material[13].k_d = vec3(255, 0.0, 0.0 );\n    Material[13].k_a = 0.2 * Material[5].k_d;\n    Material[13].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[13].k_rg = 0.5 * Material[5].k_r;\n    Material[13].n = 128.0;\n    //red shining material 5-->13\n    Material[14].k_d = vec3(255, 0.0, 0.0 );\n    Material[14].k_a = 0.2 * Material[5].k_d;\n    Material[14].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[14].k_rg = 0.5 * Material[5].k_r;\n    Material[14].n = 128.0;\n    \n    // vec4 texColor = texture(iChannel1, fragCoord);\n    // cyber punk material\n    Material[15].k_d = vec3(1.0, 1.0, 1.0);   // Diffuse coefficient\n    Material[15].k_a = vec3(0.1, 0.1, 0.1);   // Ambient coefficient\n    Material[15].k_r = vec3(1.0, 1.0, 1.0);   // Reflected specular coefficient\n    Material[15].k_rg = vec3(0.1, 0.1, 0.1);  // Global reflection coefficient\n    Material[15].n = 32.0;                   // Specular reflection exponent\n\n // Lighting Coeffecient\n    float lightCoeff = 1.0 / 15.5;\n\n    // Light 1\n    Light[0].position = vec3(2.0*cos(1.1*iTime)+0.5, 8.0, 2.0*sin(1.1*iTime)+2.0) * 1.2;\n    Light[0].I_a      = vec3(7.0, 1.0, 4.0) * lightCoeff;\n    Light[0].I_source = vec3(7.0, 1.0, 4.0) * lightCoeff;\n\n    // Light 2.\n    Light[1].position = vec3(2.0*cos(1.1*iTime+PI*0.667)+0.5, 8.0, 2.0*sin(1.1*iTime+PI*0.667)+2.0) * 1.2;\n    Light[1].I_a      = vec3(1.0, 4.0, 7.0) * lightCoeff;\n    Light[1].I_source = vec3(1.0, 4.0, 7.0) * lightCoeff;\n\n    // Light 3.\n    Light[2].position = vec3(2.0*cos(1.1*iTime+PI*1.333)+0.5, 8.0, 2.0*sin(1.1*iTime+PI*1.333)+2.0) * 1.2;\n    Light[2].I_a      = vec3(4.0, 7.0, 1.0) * lightCoeff;\n    Light[2].I_source = vec3(4.0, 7.0, 1.0) * lightCoeff;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\nvec3 oc = ray.o - sph.center;\n    float a = dot(ray.d, ray.d);\n    float b = 2.0 * dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n\n    if(discriminant < 0.0) {\n        return false;\n    }\n\n    float temp = (-b - sqrt(discriminant)) / (2.0 * a);\n    if(temp > tmin && temp < tmax) {\n        t = temp;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = (hitPos - sph.center) / sph.radius;\n        return true;\n    }\n\n    temp = (-b + sqrt(discriminant)) / (2.0 * a);\n    if(temp > tmin && temp < tmax) {\n        t = temp;\n        hitPos = ray.o + t * ray.d;\n        hitNormal = (hitPos - sph.center) / sph.radius;\n        return true;\n    }\n\n    return false;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n     vec3 oc = ray.o - sph.center; \n\n    float a = dot(ray.d, ray.d); \n    float b = 2.0f * dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.radius * sph.radius;\n\n    float discriminant = b * b - 4.0 * a * c; \n    if (discriminant < 0.0) \n    {\n        return false; \n    } \n    else \n    {\n        float t = (-b - sqrt(discriminant)) / (2.0f * a);\n        if (t < tmin) t = (-b + sqrt(discriminant)) / (2.0f * a);\n        if (t < tmin || t > tmax) return false;\n        //recT = t;\n        return true; \n    }\n\n\n   // return false;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\n\n// copied from https://www.shadertoy.com/view/Xt3SzX\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\nbool IntersectCylinder( in Cylinder_t stk, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    t = capIntersect( ray.o, ray.d, stk.vertexA, stk.vertexB, stk.radius );\n\n    if (t >= 0.0 && t <= tmax){\n        hitPos = ray.o + t * ray.d;\n        hitNormal = capNormal(hitPos, stk.vertexA, stk.vertexB, stk.radius);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectCylinder( in Cylinder_t stk, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t = capIntersect( ray.o, ray.d, stk.vertexA, stk.vertexB, stk.radius );\n    if (t >= 0.0 && t >= tmin && t <= tmax){\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Function to calculate the distance from a point to the nearest point on the torus\nfloat sdTorus(vec3 point, Torus_t torus) {\n    // Transform the point into the torus local space using the rotationMat\n    vec3 local_point = transpose(torus.rotationMat) * (point - torus.center);\n\n    // Calculate the distance to the torus surface\n    float x = length(local_point.xy) - torus.majorRadius;\n    float torus_distance = length(vec2(x, local_point.z)) - torus.minorRadius;\n\n    return torus_distance;\n}\n\n// calculate SDF\nbool torusRayIntersection(in Ray_t ray, Torus_t torus, in float tmin, in float tmax, \n                            out float t, out vec3 hitPos, out vec3 hitNormal) {\n    vec3 origin = ray.o, direction = ray.d;\n    // Ray marching loop\n    float accumulated_distance = 0.0;\n    for (int i = 0; i < NUM_MARCHSIZE; i++) {\n        vec3 current_position = origin + direction * accumulated_distance;\n\n        // Calculate the distance to the nearest point on the torus\n        float torus_distance = sdTorus(current_position, torus);\n\n        // Update the accumulated distance\n        accumulated_distance += torus_distance;\n\n        // Check for intersection conditions\n        if (accumulated_distance > tmax || torus_distance < tmin) {\n            break;\n        }\n    }\n\n    // Check if there was no intersection\n    if (accumulated_distance > tmax ) {\n        return false; // No intersection\n    }\n    t = accumulated_distance;\n\n    hitPos = origin + direction * accumulated_distance;\n   \n    // calculate normal\n    float paramSquared = torus.minorRadius * torus.minorRadius + \n                            torus.majorRadius * torus.majorRadius;\n\n    vec3 localPos = transpose(torus.rotationMat) * ( hitPos - torus.center);\n\n    // close calculate\n    vec3 close_normal = vec3(\n        sdTorus(hitPos + vec3(MARCH_EPSILO, 0, 0), torus) - sdTorus(hitPos - vec3(MARCH_EPSILO, 0, 0), torus),\n        sdTorus(hitPos + vec3( 0,MARCH_EPSILO, 0), torus) - sdTorus(hitPos - vec3(0,MARCH_EPSILO,  0), torus),\n        sdTorus(hitPos + vec3( 0, 0, MARCH_EPSILO), torus) - sdTorus(hitPos - vec3(0,  0, MARCH_EPSILO), torus)\n    );\n\n    hitNormal =  normalize(close_normal);\n    return true;\n}\n\nbool IntersectTorus(in Torus_t torus, in Ray_t ray, in float tmin, in float tmax) {\n    vec3 origin = ray.o, direction = ray.d;\n    // Ray marching loop\n    float torus_distance = 0.0;\n    float accumulated_distance = 0.0;\n    for (int i = 0; i < NUM_MARCHSIZE; i++) {\n        vec3 current_position = origin + direction * accumulated_distance;\n        // Calculate the distance to the nearest point on the torus\n         torus_distance = sdTorus(current_position, torus);\n        // Update the accumulated distance\n        accumulated_distance += torus_distance;\n\n        // Check for intersection conditions\n        if (torus_distance < tmin) {\n            return true;\n        } else if(accumulated_distance >= tmax) return false;\n    }\n\n    return false;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n// Reference: https://www.shadertoy.com/view/XdB3Dw\nvec3 squaresColours(vec2 p)\n{\n\tp+=vec2(iTime*0.2);\n\t\n\t//vec3 orange=vec3(1.0,0.4,0.1)*2.0;\n\t//vec3 purple=vec3(1.0,0.2,0.5)*0.8;\n    vec3 orange=vec3(0.0, 0.0,0.3);\n\tvec3 purple=vec3(1.0, 0.6, 0.8)*0.8;\n\n\tfloat l=pow(0.5+0.5*cos(p.x*7.0+cos(p.y)*8.0)*sin(p.y*2.0),4.0)*2.0;\n\tvec3 c=pow(l*(mix(orange,purple,0.5+0.5*cos(p.x*40.0+sin(p.y*10.0)*3.0))+\n\t\t\t\t  mix(orange,purple,0.5+0.5*cos(p.x*20.0+sin(p.y*3.0)*3.0))),vec3(1.2))*0.7;\n\t\n\tc+=purple * pow(0.5+0.5*cos(p.x*20.0)*sin(p.y*12.0),20.0)*2.0;\n\t\n\tc+=vec3(0.5+0.5*cos(p*20.0).x ,0.1, 0.5+0.5*cos(p*20.0).y )*vec3(0.1,0.0,0.2).bgr*0.7;\n\t\n\treturn c;\n}\n\nvec3 calculateColor(vec2 p,float border){\n    float sm=0.02;\n\tvec2 res=vec2(3.5);\n\tvec2 ip=floor(p*res)/res;\n\tvec2 fp=fract(p*res);\n\tfloat m=1.0-max(smoothstep(border-sm,border,abs(fp.x-0.5)),smoothstep(border-sm,border,abs(fp.y-0.5)));\n\tm+=1.0-smoothstep(0.0,0.56,distance(fp,vec2(0.5)));\n\treturn m*squaresColours(ip);\n}\n\n\n// Plane Phong lighting\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Light_t light, vec3 nearest_hitPos, int hitWhichPlane )\n{\n    Material_t mat = Material[1];\n    vec2 p, intPart;\n    float countIntPart;\n    if(hitWhichPlane == 0 || hitWhichPlane == 5) p = nearest_hitPos.xz;\n    else if(hitWhichPlane == 1 || hitWhichPlane == 3) p = nearest_hitPos.xy;\n    else if(hitWhichPlane == 2 || hitWhichPlane == 4) p = nearest_hitPos.yz;\n    else if(hitWhichPlane < 0){p.y = nearest_hitPos.y; p.x = length(nearest_hitPos.xz);}\n    p = p / blockNum;\n    mat.k_d = calculateColor(p, blockLength);\n    mat.k_a = 0.3 * mat.k_d;\n    mat.k_r = 3.0 * mat.k_d;\n\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n//////////////////////////////////////////////////\n// Reference https://www.shadertoy.com/view/lsGGDd\n// Sphere TExture Lighting when calculating a custom texture\n//////////////////////////////////////////////////\nvec3 SphereTextureLighting(in Sphere_t sph, in vec3 hitPos, in vec3 L, in vec3 N, in vec3 V, \n                            in bool inShadow, in Light_t light, in Material_t mat) {\n    // calculate uv;\n    float u = 1.0-atan(N.z, N.x) / (2.0*PI);\n\tfloat v = 1.0-(atan(length(N.xz), N.y)) / PI;\n    \n    // yellow lighting\n    vec3 glowColor = vec3(1.0 + 0.2 * sin(iTime * 3.), \n                         1.0 + 0.2 * sin(iTime * 3.0), 0.0); \n    float intensity = (1.0 + 0.3 * sin(iTime*2.0));\n\n    // calculate texture color\n    mat.k_d =  texture(CYBER_CHANNEL, vec2(u + iTime * 0.3, v)).rgb \n               * intensity     ;\n\n    mat.k_r = mat.k_r * mat.k_d * intensity;\n    mat.k_rg = mat.k_rg * mat.k_d * intensity;\n    mat.k_a = vec3(1., 1., 1.) * mat.k_d * intensity;\n\n     if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n    \n    int hitWhichPlane;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        \n        // If hit, set hasHitSomething as true,\n        // and update the information of front-most (nearest) interesection.\n        if (temp_hasHit && temp_t < nearest_t)\n        {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            if(Plane[i].type == 1)\n            {\n                float tempX = mod(nearest_hitPos.x,5.)-2.5;\n                float tempZ = mod(nearest_hitPos.z,5.)-2.5;\n                if(tempX*tempZ<0.)\n                    nearest_hitMatID = Plane[i].materialID_1;\n                else\n                    nearest_hitMatID = Plane[i].materialID_2;\n            }\n            else\n                nearest_hitMatID = Plane[i].materialID_1;\n            hitWhichPlane = i;\n        }\n    }\n        \n    for(int sphereIdx = 0; sphereIdx < NUM_SPHERES; sphereIdx++)\n    {\n        if( IntersectSphere(Sphere[sphereIdx], ray, DEFAULT_TMIN, nearest_t, temp_t, temp_hitPos, temp_hitNormal) )\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[sphereIdx].materialID;\n            hasHitSomething = true;\n        }\n    }\n    for (int i = 0; i < NUM_Cylinder; i++){\n        if (IntersectCylinder(Cylinder[i], ray, DEFAULT_TMIN,nearest_t,temp_t,temp_hitPos,temp_hitNormal)){\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitMatID = Cylinder[i].materialID;\n        }\n    }\n    // intersection with torus\n    for(int i = 0; i<NUM_TORUS; i++) {\n        if( torusRayIntersection(ray, Torus[i], MARCH_EPSILO, nearest_t, temp_t, temp_hitPos, temp_hitNormal))\n        {\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Torus[i].materialID;\n            hasHitSomething = true;\n        }\n    }\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    for(int lightIdx = 0; lightIdx < NUM_LIGHTS; lightIdx++) \n    {\n        vec3 toLight = normalize(Light[lightIdx].position - nearest_hitPos);\n        vec3 shadowRayOrigin = nearest_hitPos + DEFAULT_TMIN * toLight;\n        Ray_t shadowRay;\n        shadowRay.o = shadowRayOrigin;\n        shadowRay.d = toLight;\n        \n        Ray_t ShadowRay;\n        bool isInShadow = false;\n        for(int planeIdx = 0; planeIdx < NUM_PLANES; planeIdx++)\n        {\n            if ( IntersectPlane(Plane[planeIdx], shadowRay, DEFAULT_TMIN, length(Light[lightIdx].position - nearest_hitPos)) )\n            {\n                isInShadow = true;\n                break;\n            }\n        }\n        for(int sphereIdx = 0; sphereIdx < NUM_SPHERES; sphereIdx++)\n        {\n            if ( IntersectSphere(Sphere[sphereIdx], shadowRay, DEFAULT_TMIN, length(Light[lightIdx].position - nearest_hitPos)) )\n            {\n                isInShadow = true;\n                break;\n            }\n        }\n        for(int cylinderIdx = 0; cylinderIdx < NUM_Cylinder; cylinderIdx++)\n        {\n            if ( IntersectCylinder(Cylinder[cylinderIdx], shadowRay, DEFAULT_TMIN, length(Light[lightIdx].position - nearest_hitPos)) )\n            {\n                isInShadow = true;\n                break;\n            }\n        }\n         \n        for(int truIdx = 0; truIdx < NUM_TORUS; truIdx++) {\n            if(IntersectTorus(Torus[truIdx], shadowRay, DEFAULT_TMIN/10.0, length(Light[lightIdx].position - nearest_hitPos))) {\n                isInShadow = true;\n                break;\n            }\n        }\n        \n        \n\n        vec3 V = -ray.d;\n        if(nearest_hitMatID == DISCO_COLOR)\n             I_local += PhongLighting(ShadowRay.d, nearest_hitNormal, -ray.d, isInShadow, Light[lightIdx], nearest_hitPos, hitWhichPlane);\n        else if(nearest_hitMatID == CYBER_MATERIAL){\n            I_local += SphereTextureLighting(Sphere[CYBER_PHERE], nearest_hitPos, toLight, nearest_hitNormal, V, \n                             isInShadow,  Light[lightIdx],  Material[CYBER_MATERIAL]);\n        \n        } else{\n            I_local += PhongLighting(toLight, nearest_hitNormal, V, isInShadow, Material[nearest_hitMatID], Light[lightIdx]);\n        }\n    }\n\n\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // blockNum = 10.0*abs(sin(0.6*PI*iTime)+1.5);\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    float frequency = 0.15;\n    float radius = 6.;\n    // 目标点在1/4圆周上的弧长（范围在[0, π/2]，即0到90度）\n    float angle = 0.25 * PI * sin(2.0 * PI * frequency * iTime) + 0.3 * PI;\n    // 计算目标点在1/4圆周上的x和z坐标\n    float cam_x = cos(angle) * radius;\n    float cam_z = sin(angle) * radius;\n\n    // Position the camera.\n    vec3 cam_pos = vec3( cam_x, 1.0, cam_z );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = cam_pos;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}","name":"Buffer A","description":"","type":"buffer"}]}