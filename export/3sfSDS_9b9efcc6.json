{"ver":"0.1","info":{"id":"3sfSDS","date":"1572749632","viewed":96,"name":"Discarded","username":"Zoz","description":"Inro idea that never went any way.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\n#define FAR_PLANE 10.\n#define MAX_SAMPLES 60\n\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\n    return rotX*rotY*rotZ;\n}\n\n\n\n/* Noise functions */\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n    //return hash(x.x);\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n//https://www.shadertoy.com/view/Ms2SD1\nfloat noise( vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix(mix( rand( i + vec2(0.0,0.0) ), \n                     rand( i + vec2(1.0,0.0) ), u.x),\n                mix( rand( i + vec2(0.0,1.0) ), \n                     rand( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 v) {\n\tfloat sum = 0.;\n    for (int i = 0; i < 8; i++) {\n        float e = pow(2., float(i));\n        sum += noise(v * vec2(e)) / e;\n    }\n    return sum;\n}\n\nfloat marble(vec2 v) {\n    float c = 0.;\n    for (int i = 0; i < 3; i++) {\n     \tc = fbm(v + c * 2.) + fbm(v)* 1.7;   \n    }\n    return c;\n}\n\n\n/* Boolean operatorns */\nvec2 opUnion(vec2 d1, vec2 d2) {\n    float k = 8.;\n    float res = exp2( -k*d1.x ) + exp2( -k*d2.x );\n    float d =-log2( res )/k;\n    return vec2(d, abs(d - d1.x) < abs(d - d2.x) ? d1.y : d2.y);\n    \n \treturn d1.x < d2.x ? d1 : d2;   \n}\n\nvec2 opIntersect(vec2 d1, vec2 d2) {\n \treturn d1.x > d2.x ? d1 : d2;   \n}\n\nvec2 opComp(vec2 d1, vec2 d2) {\n    return d1.x > -d2.x ? d1 : d2;\n}\n\n/* Distance functions */\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdSphere(vec3 p) {\n \treturn length(p) - 1.;   \n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat tunnel(vec3 p) {\n    p = Rotate(vec3(0, p.y*1., 0)) * p;\n    p.y = mod(p.y, 1.) - .5;\n \tfloat d1 = sdBox(p, vec3(.5));\n    float d2 = sdBox(p, vec3(.4, .4, 1.));\n    float d3 = sdBox(p, vec3(.4, 1., .4));\n    float d4 = sdBox(p, vec3(1., .4, .4));\n   \n    float d = max(d1, -d2);\n    d = max(d, -d3);\n    d = max(d, -d4);\n    \n    return d;\n}\n\n\n/* Sphere tracing */\nvec2 map(vec3 p) {\n    //p = Rotate(vec3(-0.5, -.5, -PI/2.)) * p;\n    vec2 d = vec2(100.);\n    \n    float y = p.y;\n    for (float i = 1.; i <= 5.; i += 1.) {      \n        vec2 off = vec2(noise(vec2(iTime + y + float(i)*50.)), 0.);\n        float dd = .5 * abs(noise(vec2(iTime + y))) + .3;\n        vec3 pd = vec3(p.x + dd * sin(i + off.x), 0., p.z + dd * cos(i + off.x));\n \n     \td = opUnion(d, vec2(sdBox(Rotate(vec3(0., y + off.x, 0.)) * pd, vec3(.1)), float(i)));  \n    }\n    d = opUnion(d, vec2(tunnel(p/2.)*2., 10.));\n    d = opUnion(d, vec2(p.x +2., 11.));\n    d = opUnion(d, vec2(-p.x + 2., 11.));\n    \n    return d;\n}\n\nvec2 strace(vec3 o, vec3 r) {\n    vec2 d = vec2(0.);\n    for (int i = 0; i < MAX_SAMPLES; i++) {\n     \tvec3 p = o + d.x * r;\n        vec2 res = map(p) * 1.;\n        d.x += res.x;\n        d.y = res.y;\n    }\n    \n    return d;\n}\n\n/* Shading helpers */\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                          map(p + e.yxy).x - map(p - e.yxy).x,\n                          map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\nfloat FOG_AMOUNT = 0.2;\nvoid applyFog( inout vec3  rgb, in float dist )\n{\n    //FOG_AMOUNT += pow(.8 * noise(vec2(iTime * 10.)), 10.);\n    float fogAmount = 1.0 - exp( -dist*FOG_AMOUNT );\n    vec3  fogColor  = vec3(.05, .05, .1);\n    fogColor = vec3(0);\n    rgb = mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 color(vec3 o, vec3 r, vec3 n, vec2 d) {\n    vec3 p = o + r * d.x;\n\n    vec3 col;\n    col = vec3(1.);\n    vec2 q = floor(p.yz);\n   \t//if (d.y == 11.) col = vec3(mod(q.x+q.y,2.));\n    if (d.y < 6.) col = vec3(1., .95, 0.95);\n    float ao = 1.;\n    for (float i = 0.; i < 6.; i++) {\n   \t\tao -= 0.3 * abs(length(n * i /16.) - map(p + n * i / 16.).x);\n    }\n    col *= ao;\n    \n    applyFog(col, d.x);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 o = vec3(0., iTime*0., -5.5);\n    vec3 r = normalize(vec3(uv, 2.)); \n    \n   \t\n\n    vec2 d = strace(o, r);\n    vec3 p = o + r * d.x;\n    vec3 n = normal(p);  \n    vec3 col = color(o, r, n, d);\n    \n    \n    \n    r = reflect(r, n);\n    o = p + r;\n    d = strace(o, r);\n    n = normal(o + r * d.x);\n    col = mix(col, color(o, r, n, d), .05);\n   \t\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}