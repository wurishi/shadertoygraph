{"ver":"0.1","info":{"id":"3slBWj","date":"1589119706","viewed":331,"name":"Shallow water sim","username":"huwb","description":"Sorry for the programmer art.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["simulation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat spot(vec2 posCoord, vec2 fragCoord)\n{\n    return smoothstep(2.0,1.99,length(posCoord-fragCoord));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n\t//fragCoord.x /= 5.0;\n    \n    float g = ground(fragCoord, iTime);\n    \n    vec4 data = texture(iChannel0, uv);\n    float y = worldToScreen(data.x + g, res.y);\n    \n    float u = vel(iChannel0, fragCoord, res);\n    \n    if(fragCoord.y < worldToScreen(g, res.y))\n    {\n        fragColor = vec4(0.3) + 0.2 * (data.x >= minHeight() ? 1. : 0.);\n    }\n    else if( fragCoord.y < y)\n    {\n        fragColor = vec4(0.,.3,.6,0.);\n    }\n    else\n    {\n        fragColor = mix(vec4(1.,0.,0.,0.),vec4(0.,1.,0.,0.),.25*u+0.5);\n    }\n    \n    float mouseH = screenToWorld(iMouse.y,res.y) - ground(iMouse.xy, iTime);\n    //if(/*abs(iMouse.x - fragCoord.x - .5) < .4 &&*/ mouseH < 0.)\n    {\n        fragColor *= 1. - .99 * spot(vec2(iMouse.x, worldToScreen(ground(iMouse.xy, iTime), res.y) - 5.0), fragCoord);\n        \n        fragColor.xyz = mix(fragColor.xyz, vec3(1.0), .75 * spot(vec2(iMouse.x - 20.* u * simdt(), worldToScreen(ground(iMouse.xy, iTime), res.y) - 5.0), fragCoord));\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Advect n\n// https://pdfs.semanticscholar.org/c902/c4f2c61734cbf4ec7ee8b792ccb01644943d.pdf\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec4 data = texture(iChannel0, fragCoord/res);\n    \n    float u = vel(iChannel0, fragCoord, res);\n    //float u = .5 * vel(iChannel0, fragCoord - advectOffset(), res)\n    //    + .5 * vel(iChannel0, fragCoord + advectOffset(), res);\n    \n    float dt = simdt();\n    \n    float x_prime = fragCoord.x - dt * u;\n    x_prime = max(x_prime, 0.5);\n    \n    vec4 data_upstream = texture(iChannel0, vec2(x_prime, fragCoord.y)/res);\n    \n    // tried blurring, blew up\n    \n    // limit change in height from advection\n    /*float maxChange = 0.5;\n    float diff = abs(data_upstream.x - fragColor.x);\n    if(diff > maxChange) data_upstream.x = fragColor.x + (data_upstream.x - fragColor.x) * maxChange / diff;*/\n    \n    // compensate for rising ground - makes water flow into ground :/.\n    /*float groundUpstream = ground(vec2(x_prime, fragCoord.y));\n    float ground = ground(fragCoord.xy);\n    if(ground > groundUpstream)\n    \tdata_upstream.x += .8*(groundUpstream - ground);*/\n\t\n    //float h = data_upstream.x + groundUpstream;\n    //data_upstream.x = h - ground;\n    \n    fragColor.x = data_upstream.x;// < data.x ? mix(data.x, data_upstream.x, 1.0) : data_upstream.x;\n    fragColor.y = data.y;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Advect u\n// https://pdfs.semanticscholar.org/c902/c4f2c61734cbf4ec7ee8b792ccb01644943d.pdf\n\n// maybe killing velocity is what i need to be looking at..\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec4 data = texture(iChannel0, fragCoord/res);\n    \n    // On cell boundary - offset grid\n    fragCoord.x += 0.5;\n    \n    float u = vel(iChannel0, fragCoord, res);\n    //float u = .5 * vel(iChannel0, fragCoord - advectOffset(), res)\n    //    + .5 * vel(iChannel0, fragCoord + advectOffset(), res);\n    \n    float dt = simdt();\n    \n    float x_prime0 = find_x(iChannel0, fragCoord.x - 5.0, fragCoord, res);\n    float x_prime1 = find_x(iChannel0, fragCoord.x + 5.0, fragCoord, res);\n    \n    float x_prime = fragCoord.x - dt * u;\n    x_prime = max(x_prime, 0.5);\n    \n    vec4 data_upstream = texture(iChannel0, vec2(x_prime, fragCoord.y)/res);\n    \n    fragColor.x = data.x;\n    fragColor.y = vel(iChannel0, vec2(x_prime, fragCoord.y), res);\n    \n    // Remove some energy if hitting a big differential. Helps to shift location of funky\n    // shape at bottom of waterfall, but doesnt remove funky shape completely.\n    float groundHere = ground(fragCoord, iTime);\n    float groundUpstream = ground(vec2(x_prime, fragCoord.y), iTime);\n    //fragColor.y *= min(1.002*groundUpstream/groundHere, 1.0);\n    float gc = (groundHere - groundUpstream) / abs(fragCoord.x - x_prime);\n    //fragColor.y *= 1.0 - 0.5*max(gc, 0.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Update n\n// https://pdfs.semanticscholar.org/c902/c4f2c61734cbf4ec7ee8b792ccb01644943d.pdf\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec4 data = texture(iChannel0, fragCoord/res);\n    \n    float n = height(iChannel0, fragCoord, res);\n    \n    float u0 = vel(iChannel0, fragCoord - vec2(0.5, 0.0), res);\n    float u1 = vel(iChannel0, fragCoord + vec2(0.5, 0.0), res);\n    float dx = 1.0;\n    float dt = simdt();\n    float na = -n * dt * (u1 - u0) / dx;\n    \n    if(abs(na) > maxAccelN())\n    {\n        na *= maxAccelN() / abs(na);\n    }\n    \n    n += na;\n\n    float mouseH = screenToWorld(iMouse.y,res.y) - ground(fragCoord, iTime);\n    if(abs(fragCoord.x - iMouse.x) < 2.0 && iMouse.z > 0.0 && mouseH > 0.)\n    {\n        n += mouseH * dt;\n    }\n    \n    // 'Spring'\n    if(fragCoord.x == 600.5)\n    {\n        //n += 0.1;\n    }\n    \n    \n    // rain\n    //n += minHeight()/2.;\n    \n    if(n < minHeight()) n = 0.0;\n    //n = max(n, 0.0);\n    \n    fragColor = data;\n    fragColor.x = n;\n    \n    if(iFrame == 0)\n    {\n        fragColor.x = max(-0.9 - ground(fragCoord, iTime), 0.0);\n    }\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Update u\n// https://pdfs.semanticscholar.org/c902/c4f2c61734cbf4ec7ee8b792ccb01644943d.pdf\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec4 data = texture(iChannel0, fragCoord/res);\n    \n    // On cell boundary - offset grid\n    fragCoord.x += 0.5;\n    \n    float u = vel(iChannel0, fragCoord, res);\n    \n    float dt = simdt();\n    float dx = 1.0;\n    float a = 10.0;\n    float g0 = ground(fragCoord - vec2(0.5, 0.0), iTime);\n    float g1 = ground(fragCoord + vec2(0.5, 0.0), iTime);\n    \n    \n    float n0 = height(iChannel0, fragCoord - vec2(0.5, 0.0), res);\n    float n1 = height(iChannel0, fragCoord + vec2(0.5, 0.0), res);\n    \n    float h0 = n0 + g0;\n    float h1 = n1 + g1;\n\n    float hdiff = h0 - h1;\n    \n    if (abs(hdiff) > maxHeightDiff())\n    {\n        hdiff *= maxHeightDiff() / abs(hdiff);\n    }\n    \n    /*\n    float maxdiff = 0.05;\n    float span = abs(h1 - h0);\n    float avg = (h0 + h1)/2.0;\n    if(span > maxdiff)\n    {\n    \th0 = avg + (h0 - avg) * maxdiff / span;\n    \th1 = avg + (h1 - avg) * maxdiff / span;\n    }\n\t*/\n\n    float ua = a * dt * hdiff / dx;\n    if(ua < 0. && n1 < minHeight()) ua = 0., u = 0.;\n    if(ua > 0. && n0 < minHeight()) ua = 0., u = 0.;\n\t\n    if (abs(ua) > maxAccelV())\n    {\n        ua *= maxAccelV() / abs(ua);\n    }\n    \n    u += ua;\n    \n    // add loads of friction if thin flow heading down slope - helps to avoid high vel 'slip stream' cutting\n    // into pond\n    // somewhat physically based: http://www.jsu.edu/depart/geography/mhill/phylabtwo/lab8/streamf.html\n    //u -= .025 * smoothstep(.06, 0., .5*n0+.5*n1) * u;\n    // https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2011WR011126\n    // https://en.wikipedia.org/wiki/Fanning_friction_factor#Application\n    //  - prop to square of vel\n    //  - inverse proportional to pipe diameter\n    //float fr = .001 * u * u / max(n0+n1,0.1);\n    //u *= 1. - fr;\n    // https://iopscience.iop.org/article/10.1088/1742-6596/973/1/012032/pdf\n    u += .005*dt * -u*abs(u)/max(0.001,pow(.5*n0+.5*n1, 4./3.));\n    // http://www.fsl.orst.edu/geowater/FX3/help/8_Hydraulic_Reference/Mannings_n_Tables.htm\n    \n    //u -= .025 * smoothstep(.06, 0., .5*n0+.5*n1) * u;\n    \n    // Calm down horiz vel in deep water. Not sure if this helps.\n    //u *= exp(-.5*n0+.5*n1);\n    \n    if (abs(u) > maxV())\n    {\n        u *= maxV() / abs(u);\n    }\n    \n    fragColor = data;\n    fragColor.y = u;\n}\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat height(sampler2D data, vec2 fragCoord, vec2 res)\n{\n    return texture(data, fragCoord/res).x;\n}\n\nfloat vel(sampler2D data, vec2 fragCoord, vec2 res)\n{\n    fragCoord.x -= 0.5;\n    return texture(data, fragCoord/res).y;\n}\n\nfloat maxV()\n{\n    // couldnt get useful behaviour out of this\n    return 1000.0;\n}\n\nfloat maxAccelV()\n{\n    // setting to 1.0 seemed to look good\n    return 1000.0;\n}\n\nfloat maxAccelN()\n{\n    // good control, setting to 1 might be a good shout. but didnt solve the hole instability!\n    return 1000.0;\n}\n\nfloat maxHeightDiff()\n{\n    // didnt seem to help at all\n    return 1000.0;\n}\n\nfloat worldToScreen(float h, float resy)\n{\n    return resy * (0.5 + 0.25 * h);\n}\n\nfloat screenToWorld(float fragy, float resy)\n{\n    //fragy = resy * (0.5 + 0.25 * h);\n    return (fragy / resy - 0.5) / 0.25;\n}\n\nfloat minHeight()\n{\n    return 0.0001;\n}\n\nfloat ground(vec2 fragCoord, float time)\n{\n    return -1.3\n        + 0.1 * sin(fragCoord.x/10. + time/30.)\n        + 0.1 * sin(fragCoord.x/17.)\n        + 1.0 * smoothstep(-150., -200., -fragCoord.x)\n\t\t//+ 100.*smoothstep(2., .75, abs(fragCoord.x-20.))\n\t\t+ 100.*smoothstep(4., 3.75, abs(fragCoord.x-620.))\n\t\t+ 2.*smoothstep(4., 3.75, abs(fragCoord.x-5.))\n\t\t//- 2.*smoothstep(2., .75, abs(fragCoord.x-360.))\n        ;\n    \n    /*return -1.3\n        + fragCoord.x/600.\n        + 0.1 * sin(fragCoord.x/10.)\n        + 0.5 * sin(fragCoord.x/63.)\n        //+ 0.1 * sin(fragCoord.x/17.)\n        //+ 1.0 * smoothstep(-150., -200., -fragCoord.x)\n\t\t//+ 100.*smoothstep(2., .75, abs(fragCoord.x-20.))\n\t\t+ 100.*smoothstep(4., 3.75, abs(fragCoord.x-620.))\n\t\t//- 10.*smoothstep(2., .75, abs(fragCoord.x-360.))\n        ;*/\n}\n\nfloat simdt()\n{\n    return 0.1;\n}\n\nvec2 advectOffset()\n{\n    return vec2(1.0, 0.0);\n}\n\nfloat find_x(sampler2D data, float x, vec2 fragCoord, vec2 res)\n{\n    for (int i = 0; i < 3; i++)\n    {\n        float u = vel(data, vec2(x, fragCoord.y), res);\n        x = fragCoord.x - simdt() * u;\n    }\n    return x;\n}\n\n","name":"Common","description":"","type":"common"}]}