{"ver":"0.1","info":{"id":"tlGyDK","date":"1611768519","viewed":113,"name":"Tennis court","username":"linlin64","description":"Use mouse left click on the screen to launch a tennis ball","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","projection","perspective","lookat","tennis","stenope"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool sdLine( in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    if(length( pa - ba*h ) <= 0.01) {\n    \treturn true;\n    }\n    return false;\n}\n\nconst vec4 pts[] = vec4[] (\n    vec4(-23.77*0.5, 0, 10.97*0.5,  1),    // 0\n    vec4(23.77*0.5,  0, 10.97*0.5,  1),    // 1\n    vec4(-23.77*0.5, 0, 8.23*0.5,   1),    // 2\n    vec4(23.77*0.5,  0, 8.23*0.5,   1),    // 3\n    vec4(-6.4,       0, 4.1,        1),    // 4\n    vec4(6.4,        0, 4.1,        1),    // 5\n    vec4(-6.4,       0, -4.1,       1),    // 6\n    vec4(6.4,        0, -4.1,       1),    // 7\n    vec4(-6.4,       0, 0.0,        1),    // 8\n    vec4(6.4,        0, 0.0,        1),    // 9 \n    vec4(0.0,        0, 10.97*0.5,  1),    // 10\n    vec4(0.0,        0, -10.97*0.5, 1),    // 11\n    vec4(-23.77*0.5, 0, -10.97*0.5, 1),    // 12\n    vec4(23.77*0.5,  0, -10.97*0.5, 1),    // 13\n    vec4(-23.77*0.5, 0, -8.23*0.5,  1),    // 14\n    vec4(23.77*0.5,  0, -8.23*0.5,  1),     // 15\n    vec4(0.0,        1, 10.97*0.5,  1),    // 16\n    vec4(0.0,        1, -10.97*0.5,  1)    // 17\n);\n\nconst vec2 lines[] = vec2[](\n    vec2(0,1),\n    vec2(2,3),\n    vec2(8,9),\n    vec2(12,13),\n    vec2(14,15),\n    vec2(4,6),\n    vec2(5,7),\n    vec2(10,11),\n    vec2(0,12),\n    vec2(1,13),\n    vec2(16,17),\n    vec2(10,16),\n    vec2(11,17)\n);\n\n/*const float fac1 = (f+n)/(f-n);\nconst float fac2 = -2.0*(f*n)/(f-n);\n\nconst mat4 proj3 = mat4 (\n    vec4(n,0,0,0),\n    vec4(0,n,0,0),\n    vec4(0,0,fac1,1),\n    vec4(0,0,fac2,0)\n);\n*/\n\n\n\nvec2 toScreen(vec4 pt) {\n\n    \n    vec4 test = proj * LookAtRH(iTime) * pt;\n    return vec2(test.x/test.w, test.y/test.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = -1.0 + uv * 2.0;\n    uv.y *= iResolution.y / iResolution.x;\n\n    fragColor = vec4(211.0/255.0,82.0/255.0,32.0/255.0,1);\n\n    // Tennis\n    vec2 screenPts[18];\n    for (int i = 0; i < 18; ++i) {\n        vec2 screenPt = toScreen(pts[i]);\n        screenPts[i] = screenPt;\n    }\n    \n    // Tennis net\n    for (int i = 0; i < 10; ++i) {\n        vec2 index = lines[i];\n        vec2 pt1 = screenPts[int(index.x)];\n        vec2 pt2 = screenPts[int(index.y)];\n        if(sdLine(uv, pt1, pt2)) {\n            fragColor = vec4(1,1,1,1);\n        }\n    }\n    \n    /*// Ball and ball shadow\n    float x = cos(iTime)*10.0;\n    // Ball shadow\n    vec4 ballPosition = vec4(x,0,cos(iTime)*4.0,1);\n    vec2 screenPt = toScreen(ballPosition);\n    vec2 vec = screenPt-uv;\n    float squaredist = vec.x*vec.x + vec.y*vec.y;\n    if(squaredist < 0.001) {\n        fragColor = vec4(0.2,0.2,0.2,1);\n    }*/\n    \n    for (int i = 10; i < 13; ++i) {\n        vec2 index = lines[i];\n        vec2 pt1 = screenPts[int(index.x)];\n        vec2 pt2 = screenPts[int(index.y)];\n        if(sdLine(uv, pt1, pt2)) {\n            fragColor = vec4(1,1,1,1);\n        }\n    }\n    \n    // Ball\n    /*float y = 2.0*(10.0-abs(x))/10.0;\n    ////ballPosition.z = 5.0;\n    ballPosition.y = y;*/\n  \n    \n    int ballNumber = int(texelFetch(iChannel0, ivec2(50,50),0).x);\n    for(int i = 0; i < ballNumber; ++i) {\n        vec4 ball = texelFetch(iChannel0, ivec2(i*2,0),0);\n        float size = 0.001;// * (10.0 + ball.z) / 15.0;\n        // shadow\n        vec2 screenPt = toScreen(vec4(ball.x, 0.0, ball.z,1.0));\n        vec2 vec = screenPt-uv;\n        float squaredist = vec.x*vec.x + vec.y*vec.y;\n        if(squaredist < size) {\n            fragColor = vec4(0.2,0.2,0.2,1);\n        }\n        // ball\n        screenPt = toScreen(ball);\n        vec = screenPt-uv;\n        squaredist = vec.x*vec.x + vec.y*vec.y;\n        if(squaredist < size) {\n            fragColor = vec4(1,1,0,1);\n        }\n    }\n    \n    /*if (ballNumber >= 2) {\n        vec4 ball1 = texelFetch(iChannel0, ivec2(0,0),0);\n        vec4 ball2 = texelFetch(iChannel0, ivec2(1,0),0);\n        vec2 screenPt1 = toScreen(ball1);\n        vec2 screenPt2 = toScreen(ball2);\n        \n        if (sdLine(uv, screenPt1, screenPt2)) {\n            fragColor = vec4(0,1,0,1);\n        }\n    }*/\n    /*bool test = false;\n    vec3 point = vec3(ballPosition.x, ballPosition.y, ballPosition.z);//vec3(6.4,  0, 0.0);\n    //int ballNumber = int(texelFetch(iChannel0, ivec2(50,50),0).x);\n    for(int i = 0; i < ballNumber; ++i) {\n        vec3 ptscreen = texelFetch(iChannel0, ivec2(i,0),0).xyz;\n        \n        vec3 dir = ptscreen - eye;\n        vec3 dir1 = eye - point;\n        float dist = length(cross(dir, dir1))/length(dir);\n        if (dist <= 0.3) {\n            test = true;\n        }\n    }\n    \n    screenPt = toScreen(ballPosition);\n    vec = screenPt-uv;\n    squaredist = vec.x*vec.x + vec.y*vec.y;\n    float size = 0.001;// * (10.0 + ballPosition.z) / 15.0;\n    if(squaredist < size) {\n        if (test) {\n            fragColor = vec4(1,0,0,1);\n        } else {\n            fragColor = vec4(1,1,0,1);\n        }\n    }*/\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 intersectionPointPlanLine(vec3 a_point1, vec3 a_point2, float A, float B, float C, float D) {\n\tvec3 l_temp = a_point2;\n\tvec3 l_diffPoint2Point1 = l_temp - a_point1;\n\tfloat l_u = (A * a_point1.x + B * a_point1.y + C * a_point1.z + D) / (A * l_diffPoint2Point1.x + B * l_diffPoint2Point1.y + C * l_diffPoint2Point1.z);\n\tl_temp = a_point1;\n\tvec3 l_intersectionPoint = l_temp - l_diffPoint2Point1 * l_u;\n\treturn l_intersectionPoint;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int number = int(texelFetch(iChannel0, ivec2(50.0,50.0),0).x);\n\n    for(int i = 0; i < 10; ++i) {\n        float ifloat = float(i);\n        int index = i * 2;\n\n        vec4 pos = texelFetch(iChannel0, ivec2(index, 0),0);\n        vec4 velocity = texelFetch(iChannel0, ivec2(index+1, 0),0);\n        \n        if(i == number && iMouse.w > 0.0) {\n            vec2 uv = iMouse.xy / iResolution.xy;\n            uv = -1.0 + uv * 2.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            vec4 pt3 = inverse(proj*LookAtRH(iTime))*vec4(uv,1, 1);\n            vec4 vec = vec4(pt3.x/pt3.w, pt3.y/pt3.w, pt3.z/pt3.w, 1.0);\n            \n            vec3 eye = vec3(cos(iTime*0.1)*10.0,10.0,sin(iTime*0.1)*10.0);\n\n            vec3 inters = intersectionPointPlanLine(vec3(eye.x, eye.y, eye.z), vec3(vec.x, vec.y, vec.z), 0.0, 1.0, 0.0, 0.0);\n            \n            vec3 test = inters + normalize(eye - inters) * 10.0;\n            pos = vec4(test, 1.0); \n            velocity = vec4(normalize(inters-eye) * 0.2, 0);\n        }\n        velocity.y -= 0.01;\n        pos += velocity;\n        if (pos.y < 0.0) {\n            pos.y = 0.0;\n            velocity = 0.7*vec4(velocity.x, -velocity.y, velocity.z, velocity.w);\n        }\n\n        if (fragCoord.x >= ifloat * 2.0 && fragCoord.x < ifloat * 2.0 + 1.0\n            && fragCoord.y >= 0.0 && fragCoord.y < 1.0) {\n            fragColor = pos;\n            return;\n        }\n        if (fragCoord.x >= ifloat * 2.0 + 1.0 && fragCoord.x < ifloat * 2.0 + 2.0\n            && fragCoord.y >= 0.0 && fragCoord.y < 1.0) {\n            fragColor = velocity;\n            return;\n        }\n    }\n\n    /*if (fragCoord.x >= 0.0 && fragCoord.x < 20.0\n        && fragCoord.y >= 0.0 && fragCoord.y < 1.0) {\n        int fragCoordXint = 0;//int(fragCoord.x);\n        int fragCoordYint = 0;//int(fragCoord.y);\n        vec4 pos = texelFetch(iChannel0, ivec2(fragCoordXint, 0),0);\n        vec4 velocity = texelFetch(iChannel0, ivec2(fragCoordXint+1, 0),0);*/\n        /*if (fragCoordXint == number && iMouse.w > 0.0) {\n            \n            vec2 uv = iMouse.xy / iResolution.xy;\n            uv = -1.0 + uv * 2.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            vec4 pt3 = inverse(proj*lookat)*vec4(uv,1, 1);\n            vec4 vec = vec4(pt3.x/pt3.w, pt3.y/pt3.w, pt3.z/pt3.w, 1.0);\n            \n            vec3 inters = intersectionPointPlanLine(vec3(eye.x, eye.y, eye.z), vec3(vec.x, vec.y, vec.z), 0.0, 1.0, 0.0, 0.0);\n            \n            vec3 test = inters + normalize(eye - inters) * 10.0;\n            pos = vec4(test, 1.0); \n            velocity = vec4(normalize(inters-eye) * 0.2, 0);\n        } else {\n            velocity.y -= 0.01;\n            pos += velocity;\n            if (pos.y < 0.0) {\n                pos.y = 0.0;\n                velocity = 0.7*vec4(velocity.x, -velocity.y, velocity.z, velocity.w);\n            }\n        }*/\n\n        /*if(iMouse.w > 0.0) {\n            pos = vec4(0,0,0,1);\n            velocity = vec4(0,0,-0.1, 0);\n        }*/\n            \n            //velocity.y -= 0.01;\n           // pos += velocity;\n            /*if (pos.y < 0.0) {\n                pos.y = 0.0;\n                velocity = 0.7*vec4(velocity.x, -velocity.y, velocity.z, velocity.w);\n            }*/\n        \n\n        /*if (fragCoord.x >= 0.0 && fragCoord.x < 1.0\n            && fragCoord.y >= 0.0 && fragCoord.y < 1.0) {\n            fragColor = pos;\n            return;\n        }\n        if (fragCoord.x >= 1.0 && fragCoord.x < 2.0\n            && fragCoord.y >= 0.0 && fragCoord.y < 1.0) {\n            fragColor = velocity;\n            return;\n        }\n        return;\n    }*/\n    \n    if (fragCoord.x >= 50.0 && fragCoord.x < 51.0\n        && fragCoord.y >= 50.0 && fragCoord.y < 51.0) {\n        if(iMouse.w > 0.0 && number < 10 ) {\n            ++number;\n        }\n        \n        fragColor = vec4(number, 0,0,0);\n        return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float f = 1000.0;\nconst float n = 0.4;\n\nconst float fov = 3.14f*4.0/8.0f;\nconst float scale = n * tan(fov * 0.5);\nconst float aspectratio = 1024.0/576.0;//iResolution.x/iResolution.y;\nconst float r = aspectratio * scale;\nconst float l = -r;\nconst float t = scale;\nconst float b = -t;\n\nconst mat4 proj = mat4 (\n    vec4(2.0*n/(r-l),  0,               0,                 0),\n    vec4(0,            2.0*n/(t-b),     0,                 0),\n    vec4((r+l)/(r-l),  (t+b)/(t-b),    -(f+n)/(f-n),      -1),\n    vec4(0,            0,               -2.0*(f*n)/(f-n),  0)\n);\n\n// http://perso.univ-lemans.fr/~berger/CoursStereoVision/co/perpective.html\n// sténopé\n// Perspective projection in homogenous coordinates\nconst mat4 proj1 = mat4 (\n    vec4(n,0,0,0),\n    vec4(0,n,0,0),\n    vec4(0,0,n,-1),\n    vec4(0,0,1,0)\n);\n\nmat4 LookAtRH(float iTime) {\n    vec3 eye = vec3(cos(iTime*0.1)*10.0,10.0,sin(iTime*0.1)*10.0);\n    vec3 target = vec3(0,0,0);\n    vec3 up = vec3(0,1,0);\n\n    vec3 zaxis = normalize(eye-target);\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n \n    mat4 orientation = mat4 (\n       vec4( xaxis.x, yaxis.x, zaxis.x, 0 ),\n       vec4( xaxis.y, yaxis.y, zaxis.y, 0 ),\n       vec4( xaxis.z, yaxis.z, zaxis.z, 0 ),\n       vec4(   0,       0,       0,     1 )\n    );\n     \n    mat4 translation = mat4 (\n        vec4(   1,      0,      0,   0 ),\n        vec4(   0,      1,      0,   0 ), \n        vec4(   0,      0,      1,   0 ),\n        vec4(-eye.x, -eye.y, -eye.z, 1 )\n    );\n    return orientation * translation;\n}\n\n","name":"Common","description":"","type":"common"}]}