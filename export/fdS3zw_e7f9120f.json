{"ver":"0.1","info":{"id":"fdS3zw","date":"1617097035","viewed":849,"name":"uniform vs cosine sampling","username":"apfel1994","description":"Left - uniform sampling over hemisphere\nRight - cosine sampling\n\nJust a quick test of what is described here: http://www.rorydriscoll.com/2009/01/07/better-sampling/","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define eps 0.00001\n#define EYEPATHLENGTH 3\n#define SAMPLES 24\n\n#define SHOWSPLITLINE\n\n#define LIGHTCOLOR vec3(16.86, 10.76, 8.2)*200.\n#define WHITECOLOR vec3(.7295, .7355, .729)*0.7\n#define GREENCOLOR vec3(.117, .4125, .115)*0.7\n#define REDCOLOR vec3(.611, .0555, .062)*0.7\n\n#define M_PI 3.141592\n\nfloat hash1(inout float seed) {\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nvec2 hash2(inout float seed) {\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3(inout float seed) {\n    return fract(sin(vec3(seed+=0.1,seed+=0.1,seed+=0.1))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n\n\tfloat s = sqrt(h);\n\tfloat t1 = -b - s;\n\tfloat t2 = -b + s;\n\t\n\treturn t1 < 0.0 ? t2 : t1;\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec3 uniformSampleHemisphere(vec3 N, inout float seed) {\n    vec2 u = hash2(seed);\n    \n    float r = sqrt(1.0 - u.x * u.x);\n    float phi = 2.0 * M_PI * u.y;\n    \n    vec3  B = normalize( cross( N, vec3(0.0,1.0,1.0) ) );\n\tvec3  T = cross( B, N );\n    \n    return normalize(r * sin(phi) * B + u.x * N + r * cos(phi) * T);\n}\n\nvec3 cosineSampleHemisphere(vec3 n, inout float seed)\n{\n    vec2 u = hash2(seed);\n\n    float r = sqrt(u.x);\n    float theta = 2.0 * M_PI * u.y;\n \n    vec3  B = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  T = cross( B, n );\n    \n    return normalize(r * sin(theta) * B + sqrt(1.0 - u.x) * n + r * cos(theta) * T);\n}\n\n//-----------------------------------------------------\n// light\n//-----------------------------------------------------\n\nconst vec4 lightSphere = vec4( 3.0,7.5,2.5, 0.005 );\nvec4 movingSphere;\n\nvoid initMovingSphere( float time ) {\n    time = 0.0;\n\tmovingSphere = vec4( 1.+abs(1.0*sin(time*1.3)), 1.+abs(2.0*sin(time)), 7.-abs(6.*cos(time*0.4)), 1.0);\n}\n\n//-----------------------------------------------------\n// scene\n//-----------------------------------------------------\n\nvec2 intersect( in vec3 ro, in vec3 rd, inout vec3 normal ) {\n\tvec2 res = vec2( 1e20, -1.0 );\n    float t;\n\t\n\tt = iPlane( ro, rd, vec4( 0.0, 1.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 1., 0.); }\n\t//t = iPlane( ro, rd, vec4( 0.0, 0.0,-1.0,8.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = vec3( 0., 0.,-1.); }\n    t = iPlane( ro, rd, vec4( 1.0, 0.0, 0.0,0.0 ) ); if( t>eps && t<res.x ) { res = vec2( t, 2. ); normal = vec3( 1., 0., 0.); }\n#ifdef FULLBOX\n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<res.x && ro.z+rd.z*t < 5.5 ) { res = vec2( t, 1. ); normal = vec3( 0.,-1., 0.); }\n    t = iPlane( ro, rd, vec4(-1.0, 0.0, 0.0,5.59) ); if( t>eps && t<res.x ) { res = vec2( t, 3. ); normal = vec3(-1., 0., 0.); }\n#endif\n\n\tt = iSphere( ro, rd, movingSphere             ); if( t>eps && t<res.x ) { res = vec2( t, 1. ); normal = nSphere( ro+t*rd, movingSphere ); }\n    //t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0, 1.0) ); if( t>eps && t<res.x ) { res = vec2( t, 5. ); normal = nSphere( ro+t*rd, vec4( 4.0,1.0, 4.0,1.0) ); }\n    t = iSphere( ro, rd, lightSphere ); if( t>eps && t<res.x ) { res = vec2( t, 0.0 );  normal = nSphere( ro+t*rd, lightSphere ); }\n\t\t\t\t\t  \n    return res;\t\t\t\t\t  \n}\n\nbool intersectShadow( in vec3 ro, in vec3 rd, in float dist ) {\n    float t;\n\t\n\tt = iSphere( ro, rd, movingSphere            );  if( t>eps && t<dist ) { return true; }\n    //t = iSphere( ro, rd, vec4( 4.0,1.0, 4.0,1.0) );  if( t>eps && t<dist ) { return true; }\n#ifdef FULLBOX    \n    t = iPlane( ro, rd, vec4( 0.0,-1.0, 0.0,5.49) ); if( t>eps && t<dist && ro.z+rd.z*t < 5.5 ) { return true; }\n#endif\n    return false; // optimisation: other planes don't cast shadows in this scene\n}\n\n//-----------------------------------------------------\n// eyepath\n//-----------------------------------------------------\n\nfloat getWeightForPath( int e, int l ) {\n    return float(e + l + 2);\n}\n\nvec3 traceEyePath( in vec3 ro, in vec3 rd, const in bool useUniformSampling, inout float seed ) {\n    vec3 tcol = vec3(0.0);\n    vec3 fcol  = vec3(1.);\n    \n    for( int j=0; j<EYEPATHLENGTH; ++j ) {\n        vec3 normal;\n        \n        vec2 res = intersect( ro, rd, normal );\n        if( res.y < -0.5 ) {\n            tcol += fcol;\n            break;\n        }\n        \n        ro = ro + res.x * rd;   \n\n        if(useUniformSampling) {\n            rd = uniformSampleHemisphere( normal, seed );\n            fcol *= 2.0 * dot(rd, normal);\n        } else {\n            rd = cosineSampleHemisphere( normal, seed );\n        }\n    }  \n    \n    return tcol;\n}\n\n//-----------------------------------------------------\n// main\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    \n\tfloat splitCoord = (iMouse.x == 0.0) ? iResolution.x/2. + iResolution.x*cos(iTime*.5) : iMouse.x;\n    bool useUniformSampling = fragCoord.x < splitCoord;\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n#ifdef ANIMATENOISE\n    float seed = p.x + p.y * 3.43121412313 + fract(1.12345314312*iTime);\n#else\n    float seed = p.x + p.y * 3.43121412313;\n#endif\n    \n    vec3 ro = vec3(2.78, 2.73, -8.00);\n    vec3 ta = vec3(2.78, 2.73,  0.00);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    //-----------------------------------------------------\n    // render\n    //-----------------------------------------------------\n\n    vec3 col = vec3(0.0);\n    vec3 tot = vec3(0.0);\n    vec3 uvw = vec3(0.0);\n    \n    for( int a=0; a<SAMPLES; a++ ) {\n\n        vec2 rpof = 4.*(hash2(seed)-vec2(0.5)) / iResolution.xy;\n\t    vec3 rd = normalize( (p.x+rpof.x)*uu + (p.y+rpof.y)*vv + 3.0*ww );\n        \n#ifdef DOF\n\t    vec3 fp = ro + rd * 12.0;\n   \t\tvec3 rof = ro + (uu*(hash1(seed)-0.5) + vv*(hash1(seed)-0.5))*0.125;\n    \trd = normalize( fp - rof );\n#else\n        vec3 rof = ro;\n#endif        \n        \n#ifdef MOTIONBLUR\n        initMovingSphere( iTime + hash1(seed) / MOTIONBLURFPS );\n#else\n        initMovingSphere( iTime );        \n#endif\n        \n        col = traceEyePath( rof, rd, useUniformSampling, seed );\n\n        tot += col;\n        \n        seed = mod( seed*1.1234567893490423, 13. );\n    }\n    \n    tot /= float(SAMPLES);\n    \n#ifdef SHOWSPLITLINE\n\tif (abs(fragCoord.x - splitCoord) < 1.0) {\n\t\ttot.x = 1.0;\n\t}\n#endif\n    \n\ttot = pow( clamp(tot,0.0,1.0), vec3(0.45) );\n\n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}