{"ver":"0.1","info":{"id":"3djfRy","date":"1598454896","viewed":243,"name":"ray tracing in one weekend-10","username":"shicz86","description":"implement ray tracing in one weekend,thanks for this wonderful digital book-_-\n----------------------------------\ndielectric材质未生效是相机相关代码导致，替换后显示正常\n已查到问题，是ray(origin,dir)dir没有normalize导致dielectric材质显示异常。","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// references：\n// 1、https://yangwc.com/2019/05/08/RayTracer-Basis/\n// 2、http://www.twinklingstar.cn/2013/406/stochastic-distributed-ray-tracing/\n// 3、https://blog.csdn.net/libing_zeng/article/details/54428732\n// you can find depth of field related stuff in <<realistic ray tracing>> camera chapter\n\n#define MIN_FLOAT 1e-3\n#define MAX_FLOAT 1e5\n#define SAMPLES 1\n#define PGC 1\n\n#if PGC\n#define MAX_RECURSION (6+min(0,iFrame))\n#else\n// lower iterations may cause dark color in the ball\n#define MAX_RECURSION (16+min(0,iFrame))\n#endif\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIELECTRIC 2\n\n#define PI 3.14159265359\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nfloat hash1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nfloat seed = 0.0;\nvec2 UV = vec2(0.);\n// Helper functions.\nfloat random()\n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n}\n\nvec3 random_in_unit_sphere()\n{\n\tvec3 p = vec3(0.);\n    do{\n        p=2.*vec3(random(),random(),random())-vec3(1.);\n    }while(dot(p,p)>=1.);\n    return p;\n}\n\nvec3 random_in_unit_disk()\n{\n\tvec3 p =  vec3(0.);\n    do{\n        p=2.*vec3(random(),random(),0)-vec3(1.,1.,0.);\n    }while(dot(p,p)>=1.);\n    return p;\n}\n\nfloat schlick(float cosine, float ior) {\n    float r0 = (1.-ior)/(1.+ior);\n    r0 = r0*r0;\n    return r0 + (1.-r0)*pow((1.-cosine),5.);\n}\n\nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nvec3 point_at_parameter(const ray r,float t)\n{\n\treturn r.origin+t*r.direction;\n}\n\nstruct material\n{\n\tint type;\n    vec3 albedo;\n    float v;\n};\n\nstruct hit_record\n{\n\tfloat t;\n    vec3 p;\n    vec3 normal;\n    material mat;\n};\n\nstruct hitable\n{\n\tvec3 center;\n    float radius;\n};\n    \nbool modified_refract(const in vec3 v, const in vec3 n, const in float ni_over_nt, \n                      out vec3 refracted) {\n    float dt = dot(v, n);\n    float discriminant = 1. - ni_over_nt*ni_over_nt*(1.-dt*dt);\n    if (discriminant > 0.) \n    {\n        refracted = ni_over_nt*(v - n*dt) - n*sqrt(discriminant);\n        return true;\n    } else \n    { \n        return false;\n    }\n}\n    \nbool material_scatter(const in ray r_in,const in hit_record rec,out vec3 attenuation,out ray scattered)\n{\n#if 0\n    if(rec.mat.type == LAMBERTIAN) {\n        vec3 rd = normalize(rec.normal + random_in_unit_sphere(g_seed));\n        scattered = ray(rec.p, rd);\n        attenuation = rec.mat.albedo;\n        return true;\n    } else if(rec.mat.type == METAL) {\n        vec3 rd = reflect(r_in.direction, rec.normal);\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)));\n        attenuation = rec.mat.albedo;\n        return true;\n    } else if(rec.mat.type == DIELECTRIC) {\n        vec3 outward_normal, refracted, \n             reflected = reflect(r_in.direction, rec.normal);\n        float ni_over_nt, reflect_prob, cosine;\n        \n        attenuation = vec3(1);\n        if (dot(r_in.direction, rec.normal) > 0.) {\n            outward_normal = -rec.normal;\n            ni_over_nt = rec.mat.v;\n            cosine = dot(r_in.direction, rec.normal)/length(r_in.direction);\n        } else {\n            outward_normal = rec.normal;\n            ni_over_nt = 1. / rec.mat.v;\n            cosine = -dot(r_in.direction, rec.normal)/length(r_in.direction);\n        }\n        \n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n\t        reflect_prob = schlick(cosine, rec.mat.v);\n        } else {\n            reflect_prob = 1.;\n        }\n        \n        if (random() < reflect_prob) {\n            scattered = ray(rec.p, reflected);\n        } else {\n            scattered = ray(rec.p, refracted);\n        }\n        return true;\n    }\n    return false;\n#else\n    if(rec.mat.type == LAMBERTIAN) {\n        vec3 rd = normalize(rec.normal + random_in_unit_sphere());\n        scattered = ray(rec.p, rd);\n        attenuation = rec.mat.albedo;\n        return true;\n    } else if(rec.mat.type == METAL) {\n        vec3 rd = reflect(r_in.direction, rec.normal);\n        scattered = ray(rec.p, normalize(rd + rec.mat.v*random_in_unit_sphere()));\n        attenuation = rec.mat.albedo;\n        return true;\n    } else if(rec.mat.type == DIELECTRIC) {\n        vec3 outward_normal, refracted, \n             reflected = reflect(r_in.direction, rec.normal);\n        float ni_over_nt, reflect_prob, cosine;\n        \n        attenuation = vec3(1);\n        if (dot(r_in.direction, rec.normal) > 0.) {\n            outward_normal = -rec.normal;\n            ni_over_nt = rec.mat.v;\n            cosine = dot(r_in.direction, rec.normal)/length(r_in.direction);\n        } else {\n            outward_normal = rec.normal;\n            ni_over_nt = 1. / rec.mat.v;\n            cosine = -dot(r_in.direction, rec.normal)/length(r_in.direction);\n        }\n        \n        if (modified_refract(r_in.direction, outward_normal, ni_over_nt, refracted)) {\n\t        reflect_prob = schlick(cosine, rec.mat.v);\n        } else {\n            reflect_prob = 1.;\n        }\n        \n        if (random() < reflect_prob) {\n            scattered = ray(rec.p, reflected);\n        } else {\n            scattered = ray(rec.p, refracted);\n        }\n        return true;\n    }\n    return false;\n#endif\n}\n    \nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \n                 const in float t_max, inout hit_record rec) \n{\n   \tvec3 oc = r.origin-hb.center;\n    float a = dot(r.direction,r.direction);\n    float b = dot(oc,r.direction);\n    float c = dot(oc,oc)-hb.radius*hb.radius;\n    float discriminant = b*b-a*c;\n    if(discriminant>0.0)\n    {\n        float s = sqrt(discriminant);\n        float t1 = (-b-s)/a;\n        float t2 = (-b+s)/a;\n        if(t1 < t_max && t1 > t_min)\n        {\n        \trec.t = t1;\n            rec.p = point_at_parameter(r,rec.t);\n            rec.normal = (rec.p-hb.center)/hb.radius;\n            return true;\n        }\n        if(t2 < t_max && t2 > t_min)\n        {\n        \trec.t = t2;\n            rec.p = point_at_parameter(r,rec.t);\n            rec.normal = (rec.p-hb.center)/hb.radius;\n            return true;\n        }\n    }\n}\n\nbool world_hit(const in ray r,const in float t_min,const in float t_max,inout hit_record rec)\n{\n#if PGC\n    rec.t = t_max;\n    bool hit = false;\n\n  \tif (hitable_hit(hitable(vec3(0,-1000,-1),1000.),r,t_min,rec.t,rec)) hit=true,rec.mat=material(LAMBERTIAN,vec3(.5),0.);\n\n  \tif (hitable_hit(hitable(vec3( 0,1,0),1.),r,t_min,rec.t,rec))        hit=true,rec.mat=material(DIELECTRIC,vec3(0),1.5);\n    if (hitable_hit(hitable(vec3(-4,1,0),1.),r,t_min,rec.t,rec))        hit=true,rec.mat=material(LAMBERTIAN,vec3(.4,.2,.1),0.);\n\tif (hitable_hit(hitable(vec3( 4,1,0),1.),r,t_min,rec.t,rec))        hit=true,rec.mat=material(METAL     ,vec3(.7,.6,.5),0.);\n    \n    int NO_UNROLL = min(0,iFrame);\n    for (int a = -11; a < 11+NO_UNROLL; a++) {\n        for (int b = -11; b < 11+NO_UNROLL; b++) {\n            float m_seed = float(a) + float(b)/1000.;\n            vec3 rand1 = hash3(m_seed);            \n            vec3 center = vec3(float(a)+.9*rand1.x,.2,float(b)+.9*rand1.y); \n            float choose_mat = rand1.z;\n            \n            if (distance(center,vec3(4,.2,0)) > .9) {\n                if (choose_mat < .8) { // diffuse\n                    if (hitable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(LAMBERTIAN, hash3(m_seed)* hash3(m_seed),0.);\n                    }\n                } else if (choose_mat < 0.95) { // metal\n                    if (hitable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(METAL,.5*(hash3(m_seed)+1.),.5*hash1(m_seed));\n                    }\n                } else { // glass\n                    if (hitable_hit(hitable(center,.2),r,t_min,rec.t,rec)) {\n                        hit=true, rec.mat=material(DIELECTRIC,vec3(0),1.5);\n                    }\n                }\n            }\n        }\n    }\n    \n    return hit;\n#else\n    rec.t = t_max;\n    bool hit = false;\n    hitable h0 = hitable(vec3(0.,0.,-1.),0.5);\n    hitable h1 = hitable(vec3(0.,-100.5,-1.),100.);\n    hitable h2 = hitable(vec3(1.,0.,-1.),0.5);\n    hitable h3 = hitable(vec3(-1,0,-1),0.5);\n    //hitable h4 = hitable(vec3(-1,0,-1),-0.45);\n  \tif (hitable_hit(h0,r,t_min,rec.t,rec)) hit=true,rec.mat=material(LAMBERTIAN,vec3(0.03,0.15,0.4),0.);//桃红\n    if (hitable_hit(h1,r,t_min,rec.t,rec)) hit=true,rec.mat=material(LAMBERTIAN,vec3(0.45,0.75,0.02),0.);//蓝\n    if (hitable_hit(h2,r,t_min,rec.t,rec)) hit=true,rec.mat=material(METAL,vec3(0.8,0.6,0.2),0.1);\n    if (hitable_hit(h3,r,t_min,rec.t,rec)) hit=true,rec.mat=material(DIELECTRIC,vec3(0.),1.5);\n\t//if (hitable_hit(h4,r,t_min,rec.t,rec)) hit=true,rec.mat=material(DIELECTRIC,vec3(0.),1.5);\n    return hit;\n#endif\n}\n    \nvec3 color(in ray r) {\n    // pink color {244,121,131}\n    //vec3 attenuation = vec3(0.95,0.47,0.51);\n    vec3 col = vec3(1.);\n    hit_record rec;\n    for (int i=0; i<MAX_RECURSION; i++) \n    {\n        if(world_hit(r,MIN_FLOAT,MAX_FLOAT,rec))\n        {\n            ray scattered;\n            vec3 attenuation;\n            if(material_scatter(r,rec,attenuation,scattered))\n            {\n            \tcol *= attenuation;\n                r = scattered;\n            }else\n            {\n            \treturn vec3(0.);\n            }\n        }\n        else\n        {\n            vec3 unit_direction = normalize(r.direction);\n            float t = 0.5*(unit_direction.y+1.0);\n            col *= mix(vec3(1.),vec3(.5,.7,1.),t);\n            return col;\n        }\n    }\n\treturn vec3(0.);\n}\n\nray camera_getray(const in float u,const in float v)\n{\n\tvec3 lower_left_corner = vec3(0.,0.0,-2.);\n    vec3 horizontal = vec3(2.0,0.0,0.0);\n    vec3 vertical = vec3(0.0,2.0,0.0);\n    vec3 origin = vec3(0.0,0.0,0.0);\n    return ray(origin,lower_left_corner+u*horizontal+v*vertical);\n}\n\nray camera_getray2(const in vec3 lookfrom,const in vec3 lookto,const in vec3 vup,const in float vfov,const in float aspect,const in float s,const in float t,const in float aperture,const in float focus_dist)\n{\n\tvec3 u,v,w;\n    float theta=vfov*PI/180.0;\n    float half_height=tan(theta/2.);\n    float half_width=aspect*half_height;\n    vec3 origin=lookfrom;\n    w=normalize(lookfrom-lookto);\n    u=normalize(cross(vup,w));\n    v=cross(w,u);\n    vec3 lower_left_corner=origin-focus_dist*half_width*u-focus_dist*half_height*v-focus_dist*w;\n    vec3 horizontal=2.*focus_dist*half_width*u;\n    vec3 vertical=2.*focus_dist*half_height*v;\n    \n    float lens_radius=aperture/2.;\n    vec2 rd=lens_radius*random_in_unit_disk(g_seed);\n    vec3 offset=u*rd.x+v*rd.y;\n    \n    return ray(origin+offset,normalize(lower_left_corner+s*horizontal+t*vertical-origin-offset));\n}\n\nstruct camera{\n\tvec3 origin,lower_left_corner,horizontal,vertical,u,v,w;\n     float lens_radius;\n};\n    \nray camera_get_ray(camera c , vec2 uv){\n\t//return ray(c.origin,\n               //normalize(c.lower_left_corner+uv.x*c.horizontal+uv.y*c.vertical - c.origin));\n     vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return ray(c.origin + offset, \n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset));\n}\n\ncamera camera_const(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \n                    const in float vfov, const in float aspect, const in float aperture, \n                    const in float focus_dist) {\n    camera cam;    \n    cam.lens_radius = aperture / 2.;\n    float theta = vfov*3.14159265359/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    return cam;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0)) \n    {\n        fragColor = iResolution.xyxy;\n    }\n    else\n    {\n        g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n        \n        UV = fragCoord / iResolution.xy;\n        float aspect=iResolution.x/iResolution.y;\n        seed = iTime;\n        vec3 col = vec3(0.);\n\n#if PGC    \n        float aperture=.1;\n        vec3 lookfrom=vec3(13.,3.,3.);\n        vec3 lookto=vec3(0.);\n        float dist_to_focus=10.;\n        float fov=30.;\n#else\n        float aperture=1.;\n        vec3 lookfrom=vec3(3.,3.,2.);\n        vec3 lookto=vec3(0.,0.,-1.);\n        float dist_to_focus=length(lookfrom-lookto);\n        float fov=45.;\n#endif\n        \n        for (int s = 0; s < SAMPLES; s++)\n        {   \n            vec2 uv = ((fragCoord+vec2(random(),random()))/iResolution.xy);\n            ray r=camera_getray2(lookfrom,lookto,vec3(0,1,0),fov,aspect,uv.x,uv.y,aperture,dist_to_focus);\n            col += color(r);\n        }\n        col /= float(SAMPLES);\n\n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy)        \n            fragColor = vec4(col,1) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n        else       \n            fragColor = vec4(col,1);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}