{"ver":"0.1","info":{"id":"NsccD8","date":"1653347363","viewed":127,"name":"See thru blocks","username":"scry","description":"gif: https://twitter.com/Scrygl/status/1528790818395344896","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","shadows","trippy","scrygl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n#define time (iTime)\n#define pi 3.14159265\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n//from https:stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [0…1], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//#define dtime time*hill(time,10.)\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,w));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n \n\nvec3 slogo(vec2 uv, float ar, float size) {\n    vec2 px = vec2(1./3.,1./5.);\n    float ls = 4.1;\n    uv.x = 0.993-uv.x;\n    uv *= 8.*ls*(1./size);\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    //b = rr*floor(b);\n    //float ptime = iTime;\n    vec3 l = hsv2rgb(vec3(b+iTime/40.,0.1,rr-b*1.9))*rr;\n    //l -= length(uv)*0.5;\n    //l -= ul*rr*0.6;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    //l -= 3.-ul*2;\n    //l = clamp(l,-1.,1.);\n    return vec3(l);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return max(abs(p.z)-s.z,max(abs(p.x)-s.x,abs(p.y)-s.y));\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l) {\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nvec3 campos(vec3 p) {\n    p.zy *= r2d(deg*20.);\n    return p;\n}\n\nvec3 lpos(void) {\n    vec3 lp = vec3(0.,0.00,0.0);\n    \n    //lp.z -= 1.;\n    //lp.y += 0.5;\n    //vec3 op = p;\n    //lp.xz *= r2d(time*0.3);\n    //lp.x += sin(time)*0.2;\n    float ttime = time;\n    ttime = 0.;\n    float tm = 0.01;\n    for (int i=0;i<1;i++) {\n        tm *= 1.5;\n        lp.xz += vec2(sin(ttime*tm+tm*tm),cos(ttime*tm+tm*tm))*0.1;\n    }\n    lp.x += 0.1;\n    lp.y += 0.1;\n    lp.z -= 0.01;\n    //lp.xz += vec2(sin(time*1.),cos(time*1.))*0.1;\n    //lp.xz += vec2(sin(time*1.2),cos(time*1.7))*0.1;\n    //lp.xz += vec2(sin(time*1.5),cos(time*1.3))*0.1;\n    \n    //lp.xz *= r2d(time*0.3);\n    lp.zy *= r2d(-deg*25.);\n    //lp.xz *= r2d(time*0.3);\n    //lp = campos(lp);\n    return lp;\n}\n\nvec4 map(vec3 p) {\n    float d = 100.;\n    vec3 o = p;\n    p.zy *= r2d(deg*25.);\n    //p = campos(p);\n    p.z -= 0.8;\n    p.y += 0.45;\n    vec3 op = p;\n    \n    p.xz *= r2d(deg*45.+sin(p.z));\n    //p.xz *= r2d(time*0.1);\n    \n    //p.zy *= r2d(sin(time*0.1+p.x*2.));\n    //p.zx *= r2d(sin(time*0.1+p.y*1.5));\n    \n    //p = abs(p)-0.51;\n    //p.x += time*0.1;\n    //p = p/dot(p,p);\n    //p.z += time*0.01+p.y;\n    \n    float l = length(p);\n    p.x -= time/15.;\n    float pd = 0.5;\n    //p.x += time*2.;\n    p.y += 2.5;\n    p = (fract(p/pd)-0.5)*pd;\n    d = min(d,sdBox(p,vec3(0.63,0.13,0.63)));\n    d = abs(d+0.01)-0.002;\n    //p.x += time;\n    p = opRepLim(p,.069,vec3(9.,2.,9.));\n    //p = opRepLim(p,.2,vec3(100.,100.,100.));\n    //p = opRepLim(p,0.22,vec3(10.));\n    float lpl = length(o-lpos());\n    d = min(d,mix(length(p)-0.02,sdBox(p,vec3(0.016)),0.5));\n    //d = min(d,sdBox(p,vec3(0.016)));\n    //d = sdBox(p,vec3(0.02)*clamp(lpl-0.1,0.,1.));\n    p = opRepLim(p,.0089,vec3(2.));\n    d = min(d,sdBox(p,vec3(0.001)));\n    //d = min(d,lpl-0.001);\n    //d = max(d,-(length(o-lpos())-0.2));\n    d = max(d,-sdBox(o-lpos(),vec3(0.02)));\n    d = min(d,op.y+0.45);\n    d = max(d,-(length(o)-0.1));\n    return vec4(o,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd, float side) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<132;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w*side;\n        dO += dS*0.3;\n        ii += 0.003;\n        if (dO > 100. || dS < 0.0001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec2 li(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<40;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = length(p-lpos())-0.0;\n        dO += dS*0.22;\n        ii += 0.01;\n        if (dO > 100. || dS < 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p-h.xyy).w-map(p+h.xyy).w,\n        map(p-h.yxy).w-map(p+h.yxy).w,\n        map(p-h.yyx).w-map(p+h.yyx).w\n    ));\n}\n\nvec3 colo(vec3 p, vec3 n, vec2 d) {\n    vec3 col = 1.-d.xxx*0.8;\n    vec3 mp = map(p).xyz;\n    vec3 cn = n;\n    float sb = sdBox(mp,vec3(0.));\n    \n    cn.rg *= r2d(p.z*3.);\n    cn.br *= r2d(p.z*3.);\n    //cn.gb *= r2d(p.z*19.);\n    //cn.gr *= r2d(p.z*19.);\n    col += cn*0.5;\n    //col += sin(d.y)*10.;\n    col.r += 1.-sb*2.;\n    \n    //col = sin(p.zzz*0.2+1.);\n    //col += sin(p.xyz*n);\n    //col *= 0.1;\n    //col *= 1.-p.z*0.2;\n    //if (p.z > 90.) {\n    //    col *= 0.;\n    //col += p.z*0.1;\n    //}\n    //    col *= 0.;\n    //col += d.y*0.5-0.2;\n    //}\n    \n    col = clamp(col,0.,1.);\n    col += d.y*1.5-0.3;\n    //col -= sin(n+p.z*4.)*0.5+0.5;\n    return col;\n}\n\nfloat shadow(vec3 rd, vec3 ro, vec3 p, vec3 n, vec2 d) {\n    float s = 1.;\n    vec3 lp = lpos();\n    //vec3 lp = vec3(0.,0.,1.);\n    //lp.xz += vec2(sin(time),cos(time))*1.;\n    //lp.y *= (sin(time)*0.5+0.5);\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n,l),0.,1.);\n    vec2 df = RM(p-n*0.003,l,1.);\n    if (df.x<length(lp-p)) {\n        s -= 1.;\n    };\n    //s = df.x*0.1;\n    return s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    vec2 tv = uv;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 ro = vec3(0.);\n    float c = length(uv);\n    vec3 rd = normalize(vec3(uv,0.5-c*0.5));\n    vec3 iro = vec3(uv,0.);\n    vec3 ird = vec3(0.,0.,rd.z);\n    //float m = exp(-1.*time);\n    //float ftime = fract(iTime*0.1);\n    float m = 1.-(abs(time-5.)*1.);\n    //ro = mix(ro,iro,m);\n    //rd = mix(rd,ird,m);\n    //ro.xy = uv;\n    //rd.xy *= 0.;\n    //ro = rd;\n    //rd = vec3(0.1);\n    vec2 d = RM(ro,rd,1.);\n    vec2 ll = li(ro,rd);\n    ll.x = 1.-ll.x*0.005;\n    vec3 col = vec3(d.x/10.);\n    vec3 p = ro+rd*d.x;\n    vec3 op = p;\n    vec3 n = calcNorm(p);\n    vec3 on = n;\n    vec3 oro = ro;\n    vec3 ord = rd;\n    vec2 od = d;\n    float ior = 1.;\n    float rl = 0.5;\n    vec3 ocol = colo(p,n,d);\n    for (int i=0;i<2;i++) {\n        ro = p+n*0.003;\n        rd = refract(rd,-n,1./ior);\n        d = RM(ro,rd,-1.);\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,d)*rl;\n        rl *= rl;\n        ro = p-n*0.003;\n        rd = refract(rd,n,ior);\n        d = RM(ro,rd,1.);\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,d)*rl;\n        col *= 1.+shadow(rd,ro,p,n,d)*0.8;\n        rl *= rl;\n    }\n    col += ocol;\n    //col *= 0.05;\n    col -= 0.1;\n    col *= ocol*0.1+0.1;\n    //col *= clamp(ocol,0.,1.);\n    col *= 0.5+shadow(ord,oro,op,on,od)*0.8;\n    //col = vec3(0.5);\n    //col += clamp(ll.y,0.,1.)*clamp(od.x,0.,1.)-0.5;\n    //col = 1.-vec3(ll/100.);\n    float ligt = clamp(ll.x,0.,1.)*clamp(od.x*10.,0.,1.)-0.5;   \n    //ligt = pow(ligt,2.);\n    ligt = clamp(ligt,0.,1.);\n    //col += clamp(ligt,0.,1.);\n    ligt = pow(ligt+0.5,9.);\n    col += ligt;\n    col = clamp(col,0.,1.);\n    //col *= 0.1;\n    //col += clamp(ll,0.,2.)*clamp(od.x,0.,1.)-0.5;\n    col += -slogo(tv,ar,1.)/18.;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}