{"ver":"0.1","info":{"id":"wtfBzX","date":"1597288160","viewed":234,"name":"Film Burn","username":"Hopepdm","description":"炫光转场切换纹理：https://blog.csdn.net/panda1234lee/article/details/105969304","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["burn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed = 2.31;\n \n#define PI 3.141592653589\n#define PI_HALF (PI/2.)\n#define clamps(x) clamp(x, 0., 1.)\n \n//#iChannel0 \"file://./images/私の初めて、キミにあげます/1 (6).jpeg\"\n//#iChannel1 \"file://./images/私の初めて、キミにあげます/timg (4).jpg\"\n \nfloat progress = 0.f;\n \nvec4 getFromColor(vec2 uv)\n{\n    return texture(iChannel0, uv);\n}\n \nvec4 getToColor(vec2 uv)\n{\n    return texture(iChannel1, uv);\n}\n \nfloat sigmoid(float x, float a)\n{\n    float b = pow(x * 2., a) / 2.;\n    if (x > .5)\n    {\n        b = 1. - pow(2. - (x * 2.), a) / 2.;\n    }\n    return b;\n}\n \nfloat apow(float a, float b)\n{\n    return pow(abs(a), b) * sign(b);\n}\n \n/// @brief 三通道的 apow\nvec3 pow3(vec3 a, vec3 b)\n{\n    return vec3(apow(a.r, b.r), apow(a.g, b.g), apow(a.b, b.b));\n}\n \n/// @brief 平滑混合\nfloat smoothMix(float a, float b, float c)\n{\n    return mix(a, b, sigmoid(c, 2.));\n}\n \n/// ---------------------------------------------------------\n/// 随机函数部分\nfloat rand(float co)\n{\n    return fract(sin((co * 24.9898) + seed) * 43758.5453);\n}\n \nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n \nfloat rand(vec2 co, float shft)\n{\n    co += 10.;\n    return smoothMix(fract(sin(dot(co.xy, vec2(12.9898 + (floor(shft) * .5), 78.233 + seed))) * 43758.5453),\n                     fract(sin(dot(co.xy, vec2(12.9898 + (floor(shft + 1.) * .5), 78.233 + seed))) * 43758.5453),\n                     fract(shft));\n}\n \nfloat smoothRandom(vec2 co, float shft)\n{\n    return smoothMix(smoothMix(rand(floor(co), shft),\n                               rand(floor(co + vec2(1., 0.)), shft), fract(co.x)),\n                     smoothMix(rand(floor(co + vec2(0., 1.)), shft),\n                               rand(floor(co + vec2(1., 1.)), shft), fract(co.x)),\n                     fract(co.y));\n}\n/// ---------------------------------------------------------\n \n/// @brief 纹理平滑混合\nvec4 textureSmoothMix(vec2 p)\n{\n    return mix(getFromColor(p), getToColor(p), sigmoid(progress, 10.));\n}\n \nvec3 color = vec3(1., 0.7, 0.6);\nfloat repeats = 50.0; \n \nvec4 transition(vec2 p)\n{\n    /// @note 粒子效果\n    vec3 f = vec3(0.);\n    /// 粒子的个数\n    for (float i = 0.; i < 20.; i++)\n    {\n        /// @note 大 Blob\n        /// 增加一点随机性，改变每个 blob 的形状\n        f += .1 +\n             sin(((p.x * rand(i) * 6.0) + ///< 影响 blob 的大小\n                  (progress * 8.0)) +     ///< 影响 blob 的速度\n                 rand(i + 1.43)) *\n             cos(((p.y * rand(i + 4.4) * 6.0) + ///< 影响 blob 的大小\n                  (progress * 6.0)) +           ///< 影响 blob 的速度\n                 rand(i + 2.4));\n        // -------------------------------------------------------------------------\n \n        /// @note 小粒子\n        f += 1. - clamps(length(p -\n                                vec2(smoothRandom(vec2(progress * 1.3), i + 1.0),       ///< 控制粒子的运动位置和轨迹\n                                     smoothRandom(vec2(progress * 0.5), i + 6.25))) *\n                         mix(20., 70., rand(i)));                                       ///< 影响粒子的大小，值越大粒子越小\n \n    }\n    f += 4.;\n    f /= 11.;  ///< 变暗\n \n    /// @note 颜色随着 progress 而变化\n    f = pow3(f * color,                  ///< 着色\n             vec3(1., 2. - sin(progress * PI), 1.3)); ///< 1., [2., 1.], 1.3\n    f *= sin(progress * PI);\n \n \n    /// @note 图像周期性缩放\n    p -= .5;    ///< 以屏幕中心为原点\n    /// 随机对纹理坐标进行缩放\n    p *= 1. + (smoothRandom(vec2(progress * 5.), 6.3) * sin(progress * PI) * .05);\n    p += .5;    ///< 平移原点回左下角\n \n \n    vec4 blurred_image = vec4(0.);\n \n    /// @note 带噪点的转场效果\n    float bluramount = sin(progress * PI) * .03;\n \n    /// @note repeats 越大，毛玻璃效果越弱\n    for (float i = 0.; i < repeats; i++)\n    {\n        /// 角度转弧度\n        float rad = radians((i / repeats) * 360.);\n        vec2 q = vec2(cos(rad), sin(rad)) *\n                 (rand(vec2(i, p.x + p.y)) + bluramount); ///< 生成噪点\n \n        vec2 uv2 = p + (q * bluramount); ///< 随机噪点偏移纹理坐标，毛玻璃效果\n        blurred_image += textureSmoothMix(uv2); ///< 叠加随机偏移的纹理（同时随着 progress 变化）\n \n    }\n    blurred_image /= repeats; ///< 平均，模糊\n \n \n    return blurred_image + vec4(f, 0.); ///< 毛玻璃+粒子\n \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // uv.x *= iResolution.x/iResolution.y;\n \n    progress = fract(.5 * iTime); ///< 线性速度\n \n    fragColor = transition(uv);\n}","name":"Image","description":"","type":"image"}]}