{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"precision highp float;\n\n#define time (iTime*0.4)\n#define width  iResolution.x\n#define height iResolution.y\n\nconst float delta  = 0.0006;\nconst float PI =  3.14159265;\n\nfloat sphere(vec3 position, float r) {\n    return length(position) - r;\n}\n\n\nvec3 rotateX(vec3 pos, float alpha) {\n\tmat4 trans= mat4(1.0, 0.0, 0.0, 0.0,\n\t\t\t\t0.0, cos(alpha), -sin(alpha), 0.0,\n\t\t\t\t0.0, sin(alpha), cos(alpha), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\t\t\t\t\n\t\t\t\t\n\treturn vec3(trans * vec4(pos, 1.0));\n}\n\nvec3 rotateY(vec3 pos, float alpha) {\n\n\t\t\t\t\n\tmat4 trans2= mat4(cos(alpha), 0.0, sin(alpha), 0.0,\n\t\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t\t-sin(alpha), 0.0, cos(alpha), 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n\t\t\t\t\n\treturn vec3(trans2 * vec4(pos, 1.0));\n}\n\nvec3 translate(vec3 position, vec3 translation) {\n\treturn position - translation;\n}\n\n\nfloat cube(vec3 pos,float size){\n    return max(max(abs(pos.x)-size,abs(pos.y)-size),abs(pos.z)-size);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q ,0.5);\n}\n\n\t\n\nfloat wonderCube(vec3 position) {\n\nvec3 disp = vec3(0.0,0.0,8.9);\n\nvec3 newPos = rotateY(rotateX(translate(position.xyz,disp),2.3*time),1.8*time);\nreturn opS( opRep(newPos, vec3(1.2,1.2,1.2)),udRoundBox(newPos, vec3(2.2,2.2,2.2), 0.5))\n;\n}\n\nfloat opCheapBend( vec3 p )\n{\n    float c = cos(1.9*(1.0+sin(time*0.3))+p.y*0.19);\n    float s = sin(1.9*(1.0+sin(time*0.3))+p.y*0.18);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return wonderCube(q);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opTwist( vec3 p )\n{\n    float c = cos(0.90*p.y);\n    float s = sin(0.90*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return wonderCube(q);\n}\n\nfloat opDisplace( vec3 p )\n{\n    float d1 = sdTorus(p, vec2(4.0,2.0));\n    float d2 = (sin(p.x*3.0) + sin(p.y*5.0)) *0.2;\n    return d1+d2;\n}\n\n\nfloat opBlend( vec3 position )\n{\nvec3 disp = vec3(0.0+4.0*sin(time*2.2+3.0),0.0+2.0*sin(time*1.3),8.0+0.3*sin(time*1.5));\n\nvec3 newPos = rotateY(rotateX(translate(position.xyz,disp),2.3*time),1.8*time);\n    float d1 = wonderCube(position);\n\tvec3 p = position;\n    float d2 = sin(0.800*p.x)*sin(0.800*p.y)*sin(0.800*p.z) ;\n \n    return d1+d2;\n}\n\nfloat function(vec3 position) {\n\t\n\n\treturn opCheapBend(position);\n\n}\n\n\nconst vec3 lightDirection = vec3(-0.5,0.5,-1.0);\n\n\nvec3 ray(vec3 start, vec3 direction, float t) {\n\treturn start + t * direction;\n}\n\nvec3 gradient(vec3 position) {\n\n\treturn vec3(function(position + vec3(delta, 0.0, 0.0)) - function(position - vec3(delta, 0.0, 0.0)),\n\tfunction(position + vec3(0.0,delta, 0.0)) - function(position - vec3(0.0, delta, 0.0)),\n\tfunction(position + vec3(0.0, 0.0, delta)) - function(position - vec3(0.0, 0.0, delta)));\n\n\t\n}\n\nvec4 plasma(vec2 fragCoord) {\n vec2 p = -1.0 +2.0 * fragCoord.xy / vec2(640, 360);\nfloat cossin1 = ((cos(p.x * 2.50 +time*2.5) +sin(p.y*3.70-time*4.5) +sin(time*2.5))+3.0)/6.0;\nfloat cossin2 = (cos(p.y * 2.30 +time*3.5) +sin(p.x*2.90-time*1.5) +cos(time)+3.0)/6.0;\nfloat cossin3 = (cos(p.x * 3.10 +time*5.5) +0.5*sin(p.y*2.30-time) +cos(time*3.5)+3.0)/6.0;\nreturn vec4(cossin1, cossin2, cossin3, 1.0);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec3 cameraPosition = vec3(0.0, 0.0, -1.4);\n\t\n\tfloat aspect = 360.0/640.0;\n\tvec3 nearPlanePosition = vec3((fragCoord.x - 0.5 * width) / width * 2.0 ,\n\t\t\t\t\t\t\t      (fragCoord.y - 0.5 * height) / height * 2.0 * aspect,\n\t\t\t\t\t\t\t       0.0);\n\t\t\t\t\t\t\t  \n\tvec3 viewDirection = normalize(nearPlanePosition - cameraPosition);\n\t\n\tfloat t = 0.0;\n\tfloat distance;\n\tvec3 position;\n\tvec4 color = plasma(fragCoord);\n\tvec3 normal;\n\tvec3 up = normalize(vec3(0.0, 1.0, 0.0));\n\t\n\tfor(int i=0; i < 64; i++) {\n\t\tposition = ray(cameraPosition,\tviewDirection, t);\n\t\tdistance = function(position);\n\t\t\n\t\n\t\t\n\t\tif(abs(distance) < 0.005) {\n\t\t\t\t\t\t\t\n\t\t\tnormal = normalize(gradient(position));\n\t\t\t\n\t\t\tvec4 color1 = vec4(0.5, 0.9, 0.5,1.0);\n\t\t\tvec4 color2 = vec4(1.0, 0.1, 0.1,1.0);\n\t\t\t\n\t\t\tvec4 color3 = mix(color2, color1, (1.0 + dot(up, normal)) / 2.0);\n\t\t\t\n\t\t\tcolor = color3 * max(dot(normal, normalize(lightDirection)), 0.0) + vec4(0.1, 0.1, 0.1, 1.0);\n\n\t\t\t//specular\n\t\t\tvec3 E = normalize(cameraPosition - position);\n\t\t\tvec3 R = reflect(-normalize(lightDirection), normal);\n\t\t\tfloat specular = pow( max(dot(R, E), 0.0), 8.0);\n\t\t\tcolor += vec4(0.6, 0.4, 0.4, 0.0) * specular;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tt = t + distance;\n\t}\n\t\t\t\t\t\t\t\t  \n\tfragColor = color;\t\t\t\t\t\t\t\t  \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsX3DH","date":"1368613515","viewed":499,"name":"wobbling cube","username":"triggerHLM","description":"basic sphere tracing","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["simple","spheretracing"],"hasliked":0,"parentid":"","parentname":""}}