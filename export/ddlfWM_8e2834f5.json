{"ver":"0.1","info":{"id":"ddlfWM","date":"1688833813","viewed":24,"name":"woozy","username":"garrisonhh","description":"messing around with some visual ideas I had. I'm stuck on the visual line in the center (which isn't intentional), I'm sure it's a sign thing somewhere in all the conversions between coordinates in ranges [1.0, 1.0) and [0., 1.)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["visual"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float ROTATION_SCALAR = 1.0;\nconst float FIELD_SCALE = 50.;\nconst float FIELD_POW = 0.3;\nconst float NORMAL_EPSILON = 0.025;\nconst vec3 LIGHT_DIR = vec3(0., 0., -1.);\n\nstruct Result {\n    float depth;\n    vec3 normal;\n};\n\n// rotate uv based on distance to the origin (ROTATION_SCALAR rotations per unit distance)\nvec2 rotate(vec2 uv) {\n    float dist = (2.0 * cos(iTime * 0.5) - distance(vec2(0.), uv));\n    float angle = atan(uv.y / uv.x);\n    \n    float scalar = sin(iTime) * ROTATION_SCALAR;\n    float rotatedAngle = angle + (2. * scalar * dist);\n    \n    return vec2(cos(rotatedAngle), sin(rotatedAngle)) * dist;\n}\n\n// interesting function\nvec2 calcAt(vec2 uv) {\n    float t = iTime;\n\n    vec2 a = pow(abs(uv), vec2(FIELD_POW));\n    vec2 b = cos(a * FIELD_SCALE + t) * .5 + 1.;\n\n    return b;\n}\n\n// field function using calcAt. returns value in range [0., 1.)\nfloat depthAt(vec2 uv) {\n    vec2 v = calcAt(uv);\n    return min(v.x, v.y);\n}\n\n// estimates normal for this position\nvec3 estimateNormal(vec2 uv) {\n    const float EPS = NORMAL_EPSILON;\n    const vec2[] offsets = vec2[4](\n        vec2(-EPS, 0.),\n        vec2(+EPS, 0.),\n        vec2(0., -EPS),\n        vec2(0., +EPS)\n    );\n\n    vec3[4] diffs;\n    \n    for (int i = 0; i < 4; i++) {\n        vec2 offset = offsets[i];\n        diffs[i] = vec3(offset.x, offset.y, depthAt(uv + offset));\n    }\n\n    vec3 vertDiff = diffs[1] - diffs[0];\n    vec3 horiDiff = diffs[3] - diffs[2];\n\n    return normalize(cross(vertDiff, horiDiff));\n}\n\n\n// get rendered portal from the depth field\nResult portal(vec2 uv) {\n    vec2 pos = rotate(uv);\n\n    vec2 val = calcAt(pos);\n\n    // get depth for this pixel\n    float depth = min(val.x, val.y);\n\n    // get normal for this pixel using surrounding pixels\n    vec3 normal = estimateNormal(pos);\n\n    return Result(depth, normal);\n}\n\nvec3 getColor(Result res) {\n    vec3 scaledNormal = (res.normal + 1.) * .5;\n    float lum = (dot(res.normal, -LIGHT_DIR) + 1.) * .5;\n    \n    return scaledNormal * lum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // scale to [-1, +1]\n    vec2 uv = (fragCoord / iResolution.xy) * 2. - 1.;\n\n    // calculate portal\n    Result res = portal(uv);\n    vec3 color = getColor(res);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}