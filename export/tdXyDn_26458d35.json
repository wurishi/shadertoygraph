{"ver":"0.1","info":{"id":"tdXyDn","date":"1661392150","viewed":127,"name":"twistnoise","username":"mirumoreem","description":"temp","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["temp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 33.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat fbm(vec3 x) {\n    \n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * (2.0+ abs(1.5*sin(0.1*iTime))) + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n\n////////\n\nvec3 twist(vec3 p, float power){\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m * p;\n}\n\nvec3 twistX(vec3 p, float power){\n    float s = sin(power * p.x);\n    float c = cos(power * p.x);\n    mat3 m = mat3(\n        1.0, 0.0, 0.0,\n        0.0,   c,   s,\n        0.0,  -s,   c\n    );\n    return m * p;\n}\n\nfloat exp2Fog(float d, float density) {\n    float dd = d * density;\n    return exp(-dd * dd);\n}\n\nfloat linearFog(float d, float start, float end) {\n    return clamp((end - d) / (end - start), 0.0, 1.0);\n}\n\n/////\n\nfloat random(vec2 uv){\n    vec2 seed = vec2(162.89,78.1);\n    \n    return fract(5040000.0 * sin(dot(uv.xy, seed)));\n}\n\n\n\n\nfloat sphere_d(vec3 pos, float s){\n    return length(pos) - s+sin(iTime)*0.25;\n}\n\nfloat box_d(vec3 pos, vec3 size){\n    vec3 q = abs(pos) - size;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat smin(float d1, float d2, float k ){\n    float res = exp(-k * d1) + exp(-k * d2);\n    return -log(res) / k;\n}\n\nfloat object_d(vec3 pos){\n    //vec3 p = mod(pos, 4.0) - 2.0;\n    pos = twist(pos, 0.2+ (0.1+0.1*sin(iTime*0.5)));\n    pos = twistX(pos, 0.2+(0.1+0.1*cos(iTime*0.5)));\n   \n    float n =  length(fbm(pos)-.15+sin(iTime)*.05 )-.1;\n    float n1 = sphere_d(pos, 3.5);\n    n = min(n, n1);\n    return  n; \n}\n\n    \nvec3 getNormal(vec3 pos){\n    float d = 0.001;\n    return normalize(vec3(\n        object_d(pos + vec3(  d, 0.0, 0.0)) - object_d(pos + vec3( -d, 0.0, 0.0)),\n        object_d(pos + vec3(0.0,   d, 0.0)) - object_d(pos + vec3(0.0,  -d, 0.0)),\n        object_d(pos + vec3(0.0, 0.0,   d)) - object_d(pos + vec3(0.0, 0.0,  -d))\n    ));\n}\n\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \n    \nmat3 x_axis_rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(1.0, 0.0, 0.0, 0.0, c, -s, 0.0, s, c); \n \n}\n\nmat3 y_axis_rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0,  c);\n}\n    \n    \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n    \n    vec2 mouse_pos =  (iMouse.xy/iResolution.xy-.5) * 2.;\n    \n    \n    \n    vec3 camera_pos = vec3(0.0, 0.0, -10.0);\n    vec3 camera_up = vec3(0.0, 1.0, 0.0);\n    vec3 camera_dir = vec3(0.0, 0.0, 1.0);\n    vec3 camera_side = cross(camera_up, camera_dir);\n    \n    Ray ray;\n    ray.pos = camera_pos;\n    ray.dir = normalize(pos.x * camera_side + pos.y * camera_up + camera_dir);\n    \n    mat3 rot = x_axis_rot(0.0) * y_axis_rot(0.5*iTime);\n    \n    \n    float t = 0.0, d;\n    float b = 0.0;\n    for(int i = 0; i < 128; i++){\n        d = object_d(rot*ray.pos);\n        \n        if (d < 0.001){\n            break;\n        }\n        t += d;\n        ray.pos = camera_pos + t*ray.dir;\n        b += 1./100.;\n    } \n    \n    \n    vec3 light_dir = normalize(vec3(-0.2, -0.5 , -1.0));\n    vec3 light2_dir = normalize(vec3(0.2, 0.5 , -1.0));\n    vec3 normal = getNormal(rot*ray.pos);\n    \n    float L = dot(normal, light_dir);\n    float L2 = dot(normal, light2_dir);\n    \n    \n   \n    L = max(L, L2);  ///maxにすると良い\n    \n    \n    b = pow(b,2.0);\n    //L = min(b,L);\n    vec3 blue = vec3(0.1, 0.3, 0.8)*4.0;\n    vec3 green = vec3(0.0, 0.05, 0.1);\n    vec3 b3 = b* blue;\n    \n    \n    if(d < 0.001){\n        color = max(vec3(L)*green, b3);\n    } else{\n        color = vec3(0.93, 0.93, 1.0);\n    }\n    \n    vec3 fog = vec3(0.0);\n    \n    \n    fragColor = vec4(color,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}