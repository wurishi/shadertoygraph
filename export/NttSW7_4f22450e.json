{"ver":"0.1","info":{"id":"NttSW7","date":"1639655102","viewed":2122,"name":"Analytic Direct Illumination","username":"Mathis","description":"Analytic single bounce solution for the rendering equation.\n3D version: https://www.shadertoy.com/view/ft3XDS\n\nEverything is dynamic, see controls and info in the comments.","likes":79,"published":1,"flags":48,"usePreview":1,"tags":["global","illumination","light","analytic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAnalytic global illumination\n    The visibility term creates discontinuity in the integral, so instead of integrating\n    over the whole scene, we only integrate over visible geometry\n        These integrals are continuous and can be expressed analytically, giving the exact single-bounce solution.\n    \nLimitations:\n    This implementation only works with lines without thickness\n    I did not allow intersecting lines, they would make the visibility step more complex\n\n\n\n\nControls:\n    Click near the endpoints of a line to change them\n        Click on the middle of a line to move the entire line\n        The interact-radius can be changed with the variable \"InteractRadius\"\n    Comment out \"#define Sun\" to remove the sun\n    All colors and sun-attributes can be changed in the Common-tab\n    Key \"r\" to reset the scene\n    Key \"a\" to stop animations\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 Color = vec3(0.);\n    //Initialize the list\n    GeoInt NEI = GeoInt(-1.,0.,vec4(0.),vec3(0.));\n    GeoInt SmallerIntegrals[NVA] = GeoInt[NVA](NEI,NEI,NEI,NEI,NEI,NEI,NEI,NEI,NEI,NEI,NEI,NEI,\n    NEI,NEI,NEI,NEI,NEI,NEI);\n    //Divide the rendering integral into smaller continous integrals\n    DivideIntegral(fragCoord,SmallerIntegrals,iChannel0,IRES);\n    //Integrate\n    Color = Integrate(SmallerIntegrals);\n    //Render geometry\n    vec4 GeoC = RenderGeometry(fragCoord,iChannel0,IRES);\n    Color = mix(Color,GeoC.xyz,GeoC.w);\n    //Return\n    fragColor = vec4(pow(1.-exp(-1.2*Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Stores the scene\n\nvec2 NearestPoint(vec2 UV) {\n    vec2 Index = vec2(-1.);\n    vec4 linep; float Len1,Len2;\n    for (float i=0.; i<NObjects; i++) {\n        linep = texture(iChannel0,vec2(1.5+i,0.5)*IRES);\n        if (LineDF(UV,linep.xy,linep.zw)<InteractRadius) {\n            //Click in the middle\n            Index = vec2(i*2.,1.);\n        }\n        Len1 = length(UV-linep.xy);\n        if (Len1<InteractRadius) {\n            Index = vec2(i*2.,0.);\n        }\n        Len2 = length(UV-linep.zw);\n        if (Len2<InteractRadius && Len2<Len1) {\n            Index = vec2(i*2.+1.,0.);\n        }\n    }\n    return Index;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Output = texture(iChannel0,fragCoord*IRES);\n    if (fragCoord.y<1. && fragCoord.x<1.) {\n        //Object and mouse position\n        if (iFrame<2) {\n            Output = vec4(-1.,-1.,iMouse.xy);\n        } else {\n            if (Output.x<-0.5) {\n                vec2 OID = NearestPoint(iMouse.xy);\n                if (iMouse.z>0.) {\n                    Output.xy = OID;\n                }\n            } else if (iMouse.z<0.)\n                Output.x = -1.;\n            //Mouse position\n            Output.zw = iMouse.xy;\n        }\n    } else if (fragCoord.y<1. && fragCoord.x<16.) {\n        //Objects\n        float Obj = floor(fragCoord.x)-1.;\n        if (iFrame<2 || texelFetch(iChannel1,ivec2(82,1),0).x>0.) {\n            //Initial scene geometry\n            if (Obj<0.5) Output = vec4(0.1*RES.x,0.1*RES.y,0.9*RES.x,0.3*RES.y); //Floor\n            else if (Obj<1.5) Output = vec4(0.1*RES.x,0.1*RES.y,0.05*RES.x,0.95*RES.y); //Vertical wall\n            else if (Obj<2.5) Output = vec4(0.05*RES.x,0.95*RES.y,0.4*RES.x,0.8*RES.y); //Small ceiling\n            else if (Obj<3.5) Output = vec4(0.5*RES.x,0.77*RES.y,0.9*RES.x,0.4*RES.y); //Ceiling higher up\n            else if (Obj<4.5) Output = vec4(0.25*RES.x,0.75*RES.y,0.25*RES.x,0.5*RES.y); //Wall in front of emissive\n            else if (Obj<5.5) Output = vec4(0.15*RES.x,0.8*RES.y,0.125*RES.x,0.65*RES.y); //Emissive red\n        } else {\n            //Move objects\n            vec4 OID = texture(iChannel0,vec2(0.5)*IRES);\n            if (OID.x>-0.5 && OID.y<0.5) {\n                //Change endpoints\n                if (abs(Obj-floor(OID.x*0.5))<0.5) {\n                    if (mod(OID.x,2.)==0.) Output.xy += iMouse.xy-OID.zw;\n                    else Output.zw += iMouse.xy-OID.zw;\n                }\n            } else if (OID.x>-0.5) {\n                //Move entire line\n                if (abs(Obj-floor(OID.x*0.5))<0.5) {\n                    Output.xy += iMouse.xy-OID.zw;\n                    Output.zw += iMouse.xy-OID.zw;\n                }\n            }\n        }\n        if (texelFetch(iChannel1,ivec2(65,2),0).x<=0.) {\n            //Animation\n            if (abs(Obj-4.)<0.5) {\n                vec2 Middle = 0.5*(Output.xy+Output.zw);\n                vec2 sincos = vec2(sin(iTimeDelta*2.),cos(iTimeDelta*2.));\n                vec2 Offset = Output.xy-Middle;\n                Output.xy = Middle+vec2(Offset.x*sincos.y-Offset.y*sincos.x,Offset.x*sincos.x+Offset.y*sincos.y);\n                Offset = Output.zw-Middle;\n                Output.zw = Middle+vec2(Offset.x*sincos.y-Offset.y*sincos.x,Offset.x*sincos.x+Offset.y*sincos.y);\n            }\n        }\n    } else if (fragCoord.y<2. && fragCoord.x<16.) {\n        //Last frame copy of attributes\n        Output = texture(iChannel0,(fragCoord+vec2(0.,-1.))*IRES);\n    }\n    fragColor = Output;\n}\n\n/*\n//Scattering approach: sorting visible geometry\n//Super long compilation times, so I implemented a gathering approach instead\n\n\nvoid Delete(inout GeoInt SI[NVA], int Start, int Index) {\n    for (int j=Start; j<=Index-1; j++) {\n        SI[j]=SI[j+1];\n    }\n}\n\nvoid Move(inout GeoInt SI[NVA], int Start, int Offset, int Index) {\n    for (int j=Index-Offset-1; j>=Start; j=j-1) {\n        SI[j+Offset]=SI[j];\n    }\n}\n\nvoid Insert(vec2 UV, inout GeoInt SI[NVA], GeoInt cg) {\n    //Insert the visible geometry into a sorted list SI (Scatter)\n    vec2 PIP; GeoInt sg; GeoInt CG=cg;\n    for (int i=0; i<NVA; i++) {\n        sg=SI[i];\n        if (sg.a0<-0.5 ) {\n            //New geometry (big angle)\n            SI[i]=CG;\n            break;\n        }\n        if (CG.a0>=sg.a1) continue; //No geometry is occluded\n        if (CG.a1<=sg.a0) {\n            //New geometry (small angle)\n            Move(SI,i,1,NVA);\n            SI[i]=CG;\n            break;\n        } else { //No test for plane intersection\n            //No plane intersektion\n            vec2 LTan=sg.p.xy-sg.p.zw;\n            vec2 LNorm=vec2(LTan.y,-LTan.x);\n            LNorm=LNorm*sign(dot(UV-sg.p.xy,LNorm));\n            float CompDot=dot(CG.p.xy-sg.p.xy,LNorm);\n            if (sign(CompDot)!=sign(dot(CG.p.zw-sg.p.xy,LNorm))) {\n                //Test sg against CG instead\n                LTan=CG.p.xy-CG.p.zw;\n                LNorm=vec2(LTan.y,-LTan.x);\n                LNorm=LNorm*sign(dot(UV-CG.p.xy,LNorm));\n                CompDot=-dot(sg.p.xy-CG.p.xy,LNorm);\n            }\n            if (CompDot>=0.) {\n                //CG är framför sg\n                if (CG.a0>sg.a0 && CG.a1<sg.a1) {\n                    //Vi occludar mitten av geometri\n                    Move(SI,i,2,NVA);\n                    PIP=UV+(CG.p.xy-UV)*LineRI(UV,CG.p.xy-UV,sg.p);\n                    SI[i]=GeoInt(sg.a0,CG.a0,vec4(sg.p.xy,PIP),sg.E);\n                    SI[i+1]=CG;\n                    PIP=UV+(CG.p.zw-UV)*LineRI(UV,CG.p.zw-UV,sg.p);\n                    SI[i+2]=GeoInt(CG.a1,sg.a1,vec4(PIP,sg.p.zw),sg.E);\n                    //SI[0].E=vec3(1.,0.,0.); CG.E=vec3(1.,0.5,0.5);\n                    i=NVA;\n                } else if (CG.a0>sg.a0 && CG.a1>=sg.a1) {\n                    //Blockerar senare delen av sg och potentiellt mer\n                    PIP=UV+(CG.p.xy-UV)*LineRI(UV,CG.p.xy-UV,sg.p);\n                    SI[i]=GeoInt(sg.a0,CG.a0,vec4(sg.p.xy,PIP),sg.E);\n                    //SI[0].E=vec3(0.,1.,1.); CG.E=vec3(0.,1.,1.);\n                } else if (CG.a1<sg.a1 && CG.a0<=sg.a0) {\n                    //Blockerar första delen av sg\n                    Move(SI,i,1,NVA);\n                    PIP=UV+(CG.p.zw-UV)*LineRI(UV,CG.p.zw-UV,sg.p);\n                    SI[i]=CG;\n                    SI[i+1]=GeoInt(CG.a1,sg.a1,vec4(PIP,sg.p.zw),sg.E);\n                    //SI[0].E=vec3(1.,1.,0.); CG.E=vec3(1.,1.,0.);\n                    i=NVA;\n                } else {\n                    //Blockerar hela geometrin\n                    Delete(SI,i,NVA);\n                    i=i-1;\n                    //CG.E=vec3(0.,1.,0.);\n                }\n            } else {\n                //Bakom sg, dvs CG är helt blockad\n                if (CG.a0>=sg.a0 && CG.a1<=sg.a1) {\n                    //CG är helt blockerad\n                    i=NVA;\n                } else if (sg.a0<=CG.a0 && sg.a1<CG.a1) {\n                    //Undre delen av CG är blockerad\n                    PIP=UV+(sg.p.zw-UV)*LineRI(UV,sg.p.zw-UV,CG.p);\n                    CG=GeoInt(sg.a1,CG.a1,vec4(PIP,CG.p.zw),CG.E);\n                    //SI[0].E=vec3(0.,1.,1.); CG.E=vec3(0.,1.,1.);\n                } else if (CG.a0<sg.a0 && CG.a1<=sg.a1) {\n                    //Övre delen av CG är blockerad\n                    Move(SI,i,1,NVA);\n                    PIP=UV+(sg.p.xy-UV)*LineRI(UV,sg.p.xy-UV,CG.p);\n                    SI[i]=GeoInt(CG.a0,sg.a0,vec4(CG.p.xy,PIP),CG.E);\n                    //SI[0].E=vec3(1.,1.,0.); CG.E=vec3(1.,1.,0.);\n                    i=NVA;\n                } else {\n                    //sg är i mitten av CG\n                    Move(SI,i,1,NVA);\n                    PIP=UV+(sg.p.xy-UV)*LineRI(UV,sg.p.xy-UV,CG.p);\n                    SI[i]=GeoInt(CG.a0,sg.a0,vec4(CG.p.xy,PIP),CG.E);\n                    SI[i+1]=sg;\n                    PIP=UV+(sg.p.zw-UV)*LineRI(UV,sg.p.zw-UV,CG.p);\n                    CG=GeoInt(sg.a1,CG.a1,vec4(PIP,CG.p.zw),CG.E);\n                    //SI[0].E=vec3(1.,0.4,0.4); CG.E=vec3(1.,0.4,0.4);\n                    i=i+1;\n                }\n            }\n        }\n    }\n}\n\nvoid DivideIntegral(vec2 UV, inout GeoInt SI[NVA]) {\n    //Divide the rendering integral into smaller integrals (Scatter)\n    float LInters; vec2 a; vec4 linep; vec3 Emissive=vec3(1.)*1.;\n    for (float o=0.; o<NObjects; o++) {\n        if (o==0.) Emissive=vec3(1.,1.,0.3)*1.5; else Emissive=vec3(0.);\n        linep=texture(iChannel0,vec2(1.5+o,0.5)*IRES);\n        a=vec2(atan(UV.y-linep.y,UV.x-linep.x)+PI,atan(UV.y-linep.w,UV.x-linep.z)+PI);\n        if (a.x>a.y) { a=a.yx; linep=linep.zwxy; } //Order the points of the line\n        if (a.y-a.x>PI) {\n            //The geometry crosses the 2PI - 0 angle\n            vec2 InterP=LineXI(UV,linep.xy,linep.zw);\n            Insert(UV,SI,GeoInt(0.,a.x,vec4(InterP,linep.xy),Emissive));\n            Insert(UV,SI,GeoInt(a.y,PI2,vec4(linep.zw,InterP),Emissive));\n        } else {\n            //Normal angles\n            Insert(UV,SI,GeoInt(a.x,a.y,linep,Emissive));\n        }\n    }\n}\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Settings\nconst vec3 SkyColor = vec3(0.2,0.5,1.);\nconst vec3 SunColor = vec3(1.,0.7,0.1)*10.;\nconst float SunA = 2.; //Sun-angle position\nconst float SunS = 64.; //Sun-size, higher is smaller\nconst vec3 EmissiveColor = vec3(1.,0.9,0.9)*4.;\n#define Sun\n#define InteractRadius iChannelResolution[0].y*0.05\n\n//Other vars\n#define NObjects 6.\n#define NVA 18\nconst float PI = 3.141592653;\nconst float PI2 = PI*2.;\nconst float IPI2 = 0.5/PI;\nconst float SSunS = sqrt(SunS);\nconst float ISSunS = 1./SSunS;\n#define RES iChannelResolution[0].xy\n#define IRES (1./iChannelResolution[0].xy)\n\nstruct GeoInt { float a0; float a1; vec4 p; vec3 E; };\n\nfloat LineDF(vec2 p, vec2 a, vec2 b) {\n    //Distance Field\n    vec2 ba = b-a;\n    float k = dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat PlaneDF(vec2 p, vec2 a, vec2 b) {\n    //Distance Field\n    vec2 ba = b-a;\n    vec2 lnorm = normalize(vec2(-ba.y,ba.x));\n    return abs(dot(p-a,lnorm));\n}\n\nvec2 LineXI(vec2 uv, vec2 a, vec2 b) {\n    //Intersection of the line from UV with dir vec2(1.,0.)\n    vec2 dir = b-a;\n    vec2 rp = a-uv;\n    return a+dir*(-rp.y/dir.y);\n}\n\nfloat LineRI(vec2 uv, vec2 dir, vec4 ab) {\n    //Intersection of the line\n    vec2 ltan = ab.zw-ab.xy;\n    vec2 lnorm = vec2(-ltan.y,ltan.x);\n    return -dot(uv-ab.xy,lnorm)/dot(dir,lnorm);\n}\n\nvoid Sort(int CIndex, inout GeoInt OUT[NVA], GeoInt CG) {\n    //Sort geometry MAP a0\n    GeoInt SI[NVA] = OUT; float Sample;\n    for (int L=0; L<=CIndex; L++) {\n        Sample = SI[L].a0;\n        if (CG.a0<=Sample || Sample<0.) {\n            for (int S=CIndex; S>=L; S=S-1) {\n                SI[S+1] = SI[S];\n            }\n            SI[L] = CG;\n            break;\n        }\n    }\n    OUT = SI;\n}\n\nvoid DivideIntegral(vec2 UV, inout GeoInt SI[NVA], sampler2D Channel0, vec2 ires) {\n    //Divide the rendering integral into smaller integrals\n    int CIndex = 0; vec2 a; vec3 Emissive = vec3(0.); vec4 linep;\n    for (float o=0.; o<NObjects; o++) {\n        if (o==5.) Emissive = EmissiveColor; else Emissive = vec3(0.);\n        linep = texture(Channel0,vec2(1.5+o,0.5)*ires);\n        a = vec2(atan(UV.y-linep.y,UV.x-linep.x)+PI,atan(UV.y-linep.w,UV.x-linep.z)+PI);\n        if (a.x>a.y) { a = a.yx; linep = linep.zwxy; } //Order the points of the line\n        if (a.y-a.x>PI) {\n            //The geometry crosses the 2PI - 0 angle\n            vec2 InterP = LineXI(UV,linep.xy,linep.zw);\n            Sort(CIndex,SI,GeoInt(0.,a.x,vec4(InterP,linep.xy),Emissive));\n            Sort(CIndex+1,SI,GeoInt(a.y,PI2,vec4(linep.zw,InterP),Emissive));\n            CIndex += 2;\n        } else {\n            //Normal angles\n            Sort(CIndex,SI,GeoInt(a.x,a.y,linep,Emissive));\n            CIndex += 1;\n        }\n    }\n    //Gathering approach: sorting visible geometry\n    int OUTIndex = 0; float Sample; vec2 PIP; GeoInt CG,tmpCG,sg; GeoInt OUT[NVA] = SI;\n    for (int i=0; i<CIndex; i++) { //For each visible geometry\n        CG=OUT[i];\n        if (CG.a0<-1.5) continue;\n        else if (CG.a0<-0.5) break;\n        for (int o=i+1; o<CIndex; o++) { //For each object (in front of CG in the ordered list)\n            sg=OUT[o];\n            if (sg.a0<-0.5 || sg.a0>=CG.a1) break; //We have reached the end\n            //We assume no plane intersection\n            vec2 LTan=sg.p.xy-sg.p.zw;\n            vec2 LNorm=vec2(LTan.y,-LTan.x);\n            LNorm=LNorm*sign(dot(UV-sg.p.xy,LNorm));\n            float CompDot=dot(CG.p.xy-sg.p.xy,LNorm);\n            if (sign(CompDot)!=sign(dot(CG.p.zw-sg.p.xy,LNorm))) {\n                //Test sg against CG instead\n                LTan=CG.p.xy-CG.p.zw;\n                LNorm=vec2(LTan.y,-LTan.x);\n                LNorm=LNorm*sign(dot(UV-CG.p.xy,LNorm));\n                CompDot=-dot(sg.p.xy-CG.p.xy,LNorm);\n            }\n            if (CompDot>=0.) {\n                //CG in front of sg\n                if (sg.a1<=CG.a1 && sg.a0>=CG.a0) {\n                    //CG covers sg\n                    OUT[o]=GeoInt(-2.,0.,vec4(0.),vec3(0.));\n                } else {\n                    //CG covers lower part of sg\n                    PIP=UV+(CG.p.zw-UV)*LineRI(UV,CG.p.zw-UV,sg.p);\n                    OUT[o]=GeoInt(-2.,0.,vec4(0.),vec3(0.));\n                    tmpCG=GeoInt(CG.a1,sg.a1,vec4(PIP,sg.p.zw),sg.E);\n                    for (int L=i+1; L<=NVA; L++) {\n                        Sample=OUT[L].a0;\n                        if (Sample<-1.5) continue;\n                        else if (tmpCG.a0<=Sample || Sample<-0.5) {\n                            for (int S=NVA-2; S>=L; S=S-1) {\n                                OUT[S+1]=OUT[S];\n                            }\n                            OUT[L]=tmpCG;\n                            CIndex+=1;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                //CG behind sg\n                if (CG.a1<=sg.a1 && CG.a0==sg.a0) {\n                    //CG blocked\n                    CG=sg;\n                    OUT[o]=GeoInt(-2.,0.,vec4(0.),vec3(0.));\n                } else if (sg.a1<CG.a1 && CG.a0==sg.a0) {\n                    //sg covers lower delen av CG\n                    PIP=UV+(sg.p.zw-UV)*LineRI(UV,sg.p.zw-UV,CG.p);\n                    OUT[o]=GeoInt(-2.,0.,vec4(0.),vec3(0.));\n                    tmpCG=GeoInt(sg.a1,CG.a1,vec4(PIP,CG.p.zw),CG.E);\n                    for (int L=i+1; L<=NVA; L++) {\n                        Sample=OUT[L].a0;\n                        if (Sample<-1.5) continue;\n                        else if (tmpCG.a0<=Sample || Sample<-0.5) {\n                            for (int S=NVA-2; S>=L; S=S-1) {\n                                OUT[S+1]=OUT[S];\n                            }\n                            OUT[L]=tmpCG;\n                            CIndex+=1;\n                            break;\n                        }\n                    }\n                    CG=sg;\n                }\n                if (CG.a0<sg.a0) {\n                    if (sg.a1<CG.a1) {\n                        //sg covers the middle part of CG\n                        PIP=UV+(sg.p.zw-UV)*LineRI(UV,sg.p.zw-UV,CG.p);\n                        tmpCG=GeoInt(sg.a1,CG.a1,vec4(PIP,CG.p.zw),CG.E);\n                        PIP=UV+(sg.p.xy-UV)*LineRI(UV,sg.p.xy-UV,CG.p);\n                        CG=GeoInt(CG.a0,sg.a0,vec4(CG.p.xy,PIP),CG.E);\n                        for (int L=i+1; L<=NVA; L++) {\n                            Sample=OUT[L].a0;\n                            if (Sample<-1.5) continue;\n                            else if (tmpCG.a0<=Sample || Sample<-0.5) {\n                                for (int S=NVA-2; S>=L; S=S-1) {\n                                    OUT[S+1]=OUT[S];\n                                }\n                                OUT[L] = tmpCG;\n                                CIndex += 1;\n                                break;\n                            }\n                        }\n                    } else {\n                        //sg covers upper part of CG\n                        PIP = UV+(sg.p.xy-UV)*LineRI(UV,sg.p.xy-UV,CG.p);\n                        CG = GeoInt(CG.a0,sg.a0,vec4(CG.p.xy,PIP),CG.E);\n                    }\n                }\n            }\n        }\n        OUT[OUTIndex] = CG;\n        OUTIndex += 1;\n    }\n    for (int L=OUTIndex; L<=NVA; L++) {\n        OUT[L] = GeoInt(-1.,0.,vec4(0.),vec3(0.));\n    }\n    SI=OUT;\n}\n\nvec4 RenderGeometry(vec2 UV, sampler2D ch0, vec2 ires) {\n    float SDF = 10.;\n    float ssdf; vec3 E = vec3(0.); vec4 linep;\n    for (float i=0.; i<NObjects; i++) {\n        linep = texture(ch0,vec2(1.5+i,0.5)*ires);\n        ssdf = LineDF(UV,linep.xy,linep.zw);\n        if (ssdf<SDF) {\n            SDF = ssdf;\n            if (i==5.) E = EmissiveColor; else E = vec3(0.);\n        }\n    }\n    float W = 1.-clamp(0.,1.,SDF-1.);\n    return vec4(E*W,W);\n}\n\nvec3 SkyIntegral(float a0, float a1) {\n    //Integrates the sky\n        //Integrand: SkyColor.xyz*(1.+0.5*sin(a))\n        //Integral: SkyColor.xyz*(a-0.5*cos(a))\n    vec3 SI = SkyColor*(a1-a0-0.5*(cos(a1)-cos(a0)));\n    #ifdef Sun\n        //Integrand: SunColor/(1+SunS*(a-SunA)^2)\n        //Integral: SunColor.xyz*(-atan(sqrt(SunS)*(SunA-a)))/sqrt(SunS)\n    SI += SunColor*(atan(SSunS*(SunA-a0))-atan(SSunS*(SunA-a1)))*ISSunS;\n    #endif\n    return SI;\n}\n\nvec3 Integrate(GeoInt SI[NVA]) {\n    //Compute the rendering integral from a sorted list of smaller integrals\n    vec3 Light = vec3(0.);\n    float BiggestAngle = 0.;\n    GeoInt Sample = SI[0];\n    //Iterate over geometry\n    for (int i=0; i<NVA; i++) {\n        Sample = SI[i];\n        if (Sample.a0<-0.5) break;\n        Light += SkyIntegral(BiggestAngle,Sample.a0); //Integrate between geometry\n        Light += Sample.E*(Sample.a1-Sample.a0); //Integrate geometry\n        BiggestAngle = Sample.a1;\n    }\n    //Last sky-integral from geometry-angle to 2PI\n    Light += SkyIntegral(BiggestAngle,PI2);\n    //Return\n    return Light*IPI2;\n}","name":"Common","description":"","type":"common"}]}