{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define EPS 0.001\n//iTorus1: original method by iq\n//iTorus2: use Unbounding volumes\n//iTorus3: use Durand-Kerner polynomial solving. Not that slow after adding epsilon checking.\n#define iTorus iTorus2 \n//Unbounding volumes (the complement of bounding volume) raymarching.\n//In principle, one can use any kind of unbounding volume.\n//Sphere tracing is just a special case.\n//Here we use spheres which centers lay on the torus axis and are tangent to it.\n//The circle of tangency is the one closest to the current point on the ray.\n\t\nvec3 GetParams(in vec2 p, in vec2 torus ){\n\t//returns parameters of a sphere tangent to torus\n\t// the center of the sphere is always on the y axis\n\t// it's equation is: a*(xÂ²+yÂ²)-2*b*y-c=0\n\t// the sphere can reduce to a plane when a==0\n\t// par == vec3(a, b, c)\n\tvec3 par = vec3(0.);\n\tvec2 n0 = p;\n\tn0.x -= torus.x;\n\tfloat inr=1./length(n0);\n\t//n0 *= inr;\n\tp = n0 * inr * torus.y ;\n\tp.x += torus.x;\n\tpar.x = n0.x;\n\tpar.y = dot(n0, vec2(p.y, -p.x));\n\tpar.z = p.x * dot(n0, p) - p.y * par.y; \n\treturn par;\n}\nfloat iSph( float t, in vec3 ro, in vec3 rd, in vec3 S ){\n\t//a*rdÂ²*tÂ²+2*(a*ro*rd-b*rd.y)*t+a*roÂ²-2*b*ro.y-c=0\n\tfloat A=S.x*dot(rd,rd);//the dots should be precalculated\n\tfloat B=S.x*dot(ro,rd)-S.y*rd.z;\n\tfloat C=S.x*dot(ro,ro)-2.*S.y*ro.z-S.z;\n\tfloat D=B*B-A*C;\n\tif(D<0.0) return -100.;\n\tD=sqrt(D); A=1./A;\n#if 0\n\t//numerically unstable when A~=0.\n\tfloat t0=(-B+D)*A;\n\tfloat t1=(-B-D)*A;\n#else\n\t//stable and works even if A==0.\n\tfloat t0=(-B-sign(B)*D);\n\tfloat t1=C/t0;\n\tt0=t0*A;//\n#endif\n\tif(min(t0,t1)<t) return max(t0,t1)-t;\n\treturn min(t0,t1)-t;\n}\nfloat Torus(in vec3 p, in vec2 torus ){//evaluate torus\n// f(x) = (|x|Â² + RÂ² - rÂ²)Â² - 4Â·RÂ²Â·|xy|Â² \n\tfloat R2=torus.x*torus.x;\n\tfloat r2=torus.y*torus.y;\n\tfloat v=dot(p,p)+R2-r2;\n\tv=v*v-4.*R2*dot(p.xy,p.xy);\n\treturn v;\n}\n#define MAX_ITER 20\nfloat uit=0.;\nfloat iTorus2( in vec3 ro, in vec3 rd, in vec2 torus ){\n\tfloat t = 0.;\n\tfor(int i=0; i<MAX_ITER; i++){\n\t\tvec3 p = ro + t * rd;\n\t\tfloat v=Torus(p,torus);\n\t\tif(v<0.001) break;//continue;//\n\t\telse uit+=1.;\n\t\tvec3 S = GetParams(vec2(length(p.xy),p.z), torus);\n\t\tfloat dt = iSph(t,ro,rd,S);\n\t\tif(dt<0.) return -1.;\n\t\tt+=dt;\n\t}\n\treturn t;\n}\n///////////////////////////////////////////////////////////////////////////////////////////\n//Using Durand kerner method: http://en.wikipedia.org/wiki/Durand%E2%80%93Kerner_method\n//Just to see if how it works\nvec2 cmul(vec2 c1, vec2 c2){\n\treturn vec2(c1.x*c2.x-c1.y*c2.y,c1.x*c2.y+c1.y*c2.x);\n}\nvec2 cinv(vec2 c){\n\treturn vec2(c.x,-c.y)/dot(c,c);\n}\nvec2 cTorus(vec2 t, in vec3 ro, in vec3 rd, in vec2 torus ){\n// f(t) = (tÂ²*rdÂ²+2*t*ro*rd+roÂ²+RÂ²-rÂ²)Â²-4*RÂ²*(tÂ²*rdxyÂ²+2*t*roxy*rdxy+roxyÂ²)\n\tfloat R2=torus.x*torus.x;\n\tfloat r2=torus.y*torus.y;\n\tvec2 t2=vec2(t.x*t.x-t.y*t.y,2.*t.x*t.y);//cmul(t,t);\n\tvec2 res= t2*dot(rd,rd)+2.*t*dot(ro,rd)+vec2(dot(ro,ro)+R2-r2,0.);\n\tres=cmul(res,res);\n\tvec2 res2=4.*R2*(t2*dot(rd.xy,rd.xy)+2.*t*dot(ro.xy,rd.xy)+vec2(dot(ro.xy,ro.xy),0.));\n\t\n\treturn res-res2;\n}\nfloat DKstep(inout vec2 c0, vec2 c1, vec2 c2, vec2 c3, in vec3 ro, in vec3 rd, in vec2 torus){\n\tvec2 fc=cTorus(c0,ro,rd,torus);\n\tfc=cmul(fc,cinv(cmul(c0-c1,cmul(c0-c2,c0-c3))));\n\tc0-=fc;\n\treturn max(abs(fc.x),abs(fc.y));\n}\nfloat iTorus3( in vec3 ro, in vec3 rd, in vec2 torus ){\n\tvec2 c0=vec2(1.,0.);\n\tvec2 c1=vec2(0.4,0.9);\n\tvec2 c2=cmul(c1,vec2(0.4,0.9));\n\tvec2 c3=cmul(c2,vec2(0.4,0.9));\n\tfor(int i=0; i<30; i++){\n\t\tfloat e = DKstep(c0, c1, c2, c3, ro, rd, torus);\n\t\te = max(e,DKstep(c1, c2, c3, c0, ro, rd, torus));\n\t\te = max(e,DKstep(c2, c3, c0, c1, ro, rd, torus));\n\t\te = max(e,DKstep(c3, c0, c1, c2, ro, rd, torus));\n\t\tif(e<EPS) break;\n\t\tuit+=1.;\n\t}\n\tvec4 rs= vec4(c0.x, c1.x, c2.x, c3.x);\n\tvec4 ri= abs(vec4(c0.y, c1.y, c2.y, c3.y));\n\n\tif(ri.x>EPS || rs.x<0.) rs.x=10000.;\n\tif(ri.y>EPS || rs.y<0.) rs.y=10000.;\n\tif(ri.z>EPS || rs.z<0.) rs.z=10000.;\n\tif(ri.w>EPS || rs.w<0.) rs.w=10000.;\n\treturn min(min(rs.x,rs.y),min(rs.z,rs.w));\n}\n///////////////////////////////////////////////////////////////////////////////////////////\n// what follows is the original shader by Iq:\n\n// Analytic intersection of a torus (degree 4 equation). Motivated by Antonalog's \n// shader (https://www.shadertoy.com/view/XdSGWy), and simplified the geometrically \n// impossible cases, and optimized coefficients. One can probably do better than \n// this though...\n\n// f(x) = (|x|Â² + RÂ² - rÂ²)Â² - 4Â·RÂ²Â·|xy|Â² = 0\n\nfloat iTorus1( in vec3 ro, in vec3 rd, in vec2 torus )\n{\n\tfloat Ra2 = torus.x*torus.x;\n\tfloat ra2 = torus.y*torus.y;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\t\t\n\tfloat k = (m - ra2 - Ra2)/2.0;\n\tfloat a = n;\n\tfloat b = n*n + Ra2*rd.z*rd.z + k;\n\tfloat c = k*n + Ra2*ro.z*rd.z;\n\tfloat d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    //----------------------------------\n\n\tfloat p = -3.0*a*a     + 2.0*b;\n\tfloat q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;\n\tfloat r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;\n\tp /= 3.0;\n\tr /= 3.0;\n\tfloat Q = p*p + r;\n\tfloat R = 3.0*r*p - p*p*p - q*q;\n\t\n\tfloat h = R*R - Q*Q*Q;\n\tfloat z = 0.0;\n\tif( h < 0.0 )\n\t{\n\t\tfloat sQ = sqrt(Q);\n\t\tz = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n\t}\n\telse\n\t{\n\t\tfloat sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n\t\tz = sign(R)*abs( sQ + Q/sQ );\n\n\t}\n\t\n\tz = p - z;\n\t\n    //----------------------------------\n\t\n\tfloat d1 = z   - 3.0*p;\n\tfloat d2 = z*z - 3.0*r;\n\n\tif( abs(d1)<1.0e-4 )\n\t{\n\t\tif( d2<0.0 ) return -1.0;\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\tif( d1<0.0 ) return -1.0;\n\t\td1 = sqrt( d1/2.0 );\n\t\td2 = q/d1;\n\t}\n\n    //----------------------------------\n\t\n\tfloat result = 1e20;\n\n\th = d1*d1 - z + d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = -d1 - h - a;\n\t\tfloat t2 = -d1 + h - a;\n\t\t     if( t1>0.0 ) result=t1;\n\t\telse if( t2>0.0 ) result=t2;\n\t}\n\n\th = d1*d1 - z - d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = d1 - h - a;\n\t\tfloat t2 = d1 + h - a;\n\t\t     if( t1>0.0 ) result=min(result,t1);\n\t\telse if( t2>0.0 ) result=min(result,t2);\n\t}\n\n\treturn result;\n}\n\n// df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raytrace\n\t\n\t// raytrace-plane\n\tvec2 torus = vec2(1.,.5);\n\tfloat t = iTorus( ro, rd, torus );\n#if 1\n\tif(p.x<sin(iTime*0.5)*3.) {//show iterations count\n\t\tfragColor = vec4( uit/float(MAX_ITER), 1.-uit/float(MAX_ITER),0., 1.0 );\n\t\treturn;\n\t}\n#endif\t\n    // shading/lighting\t\n\tvec3 col = vec3(0.25);\n\tif( t>0.0 && t<100.0 )\n\t{\n\t    vec3 pos = ro + t*rd;\n\t\tvec3 nor = nTorus( pos.xyz, torus );\n\t\tfloat dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\t\tfloat amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n\t\tcol = vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n\t\tcol *= 0.8;\n\t}\n\t\n\tcol = sqrt( col );\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2GDy","date":"1393016273","viewed":601,"name":"Torus again","username":"knighty","description":"uses spheres which centers lay on the torus's axis and tangent to it in order to do \"uncentered\" sphere tracing. ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","unboundingvolumes"],"hasliked":0,"parentid":"","parentname":""}}