{"ver":"0.1","info":{"id":"mdGfDm","date":"1698389857","viewed":60,"name":"Terrible Fate","username":"lucent","description":"Majoras mask sdf\n\nA work in progress","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["sdf","zelda"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SDFs and utility functions by Inigo Quilez \n\n#define PI 3.14159265359\n\n#define REF_ALPHA 0.0\n#define ZOOM 0.7\n\n#define FLOATING 1\n\n#define WAVE_BG 1\n#define BATTLE_BG 0\n\nvec2 texCoord; // img dim 1200 × 1039                \n\n\n// design line colors to be implemented\n// vec3(0.5608, 0.5490, 0.4549) for white/neutral lines for patterns\n\n// Utility functions\n\n// 0: integer hash\n// 1: float hash (aliasing based) (don't do this unless you live in the year 2013)\n#define METHOD 0\n\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\n\n#if METHOD==0\nfloat hash( in ivec2 p )  // this hash is not production ready, please\n{                         // replace this by something better\n\n    // 2D -> 1D\n    int n = p.x*3 + p.y*113;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & 0x0fffffff)/float(0x0fffffff);\n}\n#else\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n#endif\n\n\n\nfloat noise( in vec2 p )\n{\n    #if METHOD==0\n    ivec2 i = ivec2(floor( p ));\n    #else\n    vec2 i = floor( p );\n    #endif\n    vec2 f = fract( p );\n\t\n    #if INTERPOLANT==1\n    // quintic interpolant\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    #else\n    // cubic interpolant\n    vec2 u = f*f*(3.0-2.0*f);\n    #endif    \n\n    #if METHOD==0\n    return mix( mix( hash( i + ivec2(0,0) ), \n                     hash( i + ivec2(1,0) ), u.x),\n                mix( hash( i + ivec2(0,1) ), \n                     hash( i + ivec2(1,1) ), u.x), u.y);\n    #else\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n    #endif\n}\n\nfloat fbm( vec2 p )\n{\n    const mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\n// exponential smooth min (k=32)\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// Signed distance functions\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdEqTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\n// unused\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat heart(vec2 p) {\n    // Center it more, vertically:\n    p.y += .6;\n    // This offset reduces artifacts on the center vertical axis.\n    const float offset = .3;\n    // (x^2+(1.2*y-sqrt(abs(x)))^2−1)\n    float k = 1.2 * p.y - sqrt(abs(p.x) + offset);\n    return p.x * p.x + k * k - 1.;\n}\n\nfloat repeatedCircles( vec2 p, float r, vec2 s, vec2 lima, vec2 limb)\n{\n    vec2 id = clamp( round(p/s), -lima, limb );\n    p = p - s*id;\n    return sdCircle(p, r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/(iResolution.y*ZOOM);\n    \n    p.y += 0.5;\n    \n    #if FLOATING\n    p.y += 0.1*cos(0.8*iTime);\n    p.x += 0.05*cos(0.6*iTime);\n    #endif\n    \n    //float heartScale = 0.6;\n    //float heartOffset = 0.15;\n    float dHeart = heart((p-vec2(0.0,0.42))*vec2(0.95, 1.3));\n    \n    vec2 rEyeCenter = p - vec2(0.49, 0.52);\n    vec2 lEyeCenter = p - vec2(-0.49, 0.52);\n    \n    vec2 eyeScale = vec2(0.7, 1.0);\n    \n    float dREye = sdCircle(rEyeCenter*eyeScale, 0.2);\n    float dRPupil = sdCircle(rEyeCenter*eyeScale, 0.05);\n    float dRDot = sdCircle(rEyeCenter*eyeScale, 0.015);\n    \n    float dLEye = sdCircle(lEyeCenter*eyeScale, 0.2);\n    float dLPupil = sdCircle(lEyeCenter*eyeScale, 0.05);\n    float dLDot = sdCircle(lEyeCenter*eyeScale, 0.015);\n    \n    float eyeAngle = PI / 5.0;\n    float eyeTipLen = 0.35; // from eye center\n    float eyeSocketRadius = 0.23;\n\n    vec2 rEyeDir = normalize(vec2(cos(eyeAngle), sin(eyeAngle)));\n    vec2 lEyeDir = normalize(vec2(cos(-eyeAngle), sin(-eyeAngle)));\n    \n    float rEyeSocket = smin(\n        sdCircle(rEyeCenter*eyeScale, eyeSocketRadius),\n        udSegment(rEyeCenter, -eyeTipLen*rEyeDir, eyeTipLen*rEyeDir)-0.015,\n        32.0\n    );\n    \n    float lEyeSocket = smin(\n        sdCircle(lEyeCenter*eyeScale, eyeSocketRadius),\n        udSegment(lEyeCenter, -eyeTipLen*lEyeDir, eyeTipLen*lEyeDir)-0.015,\n        32.0\n    );\n    \n    // Red area of mask\n    float eyeOutlineRadius = 0.27;\n    float eyeOutlineTipLen = eyeSocketRadius + 0.15;\n    \n    float rEyeOutline = smin(\n        sdCircle(rEyeCenter*eyeScale, eyeOutlineRadius),\n        udSegment(rEyeCenter, eyeOutlineTipLen*rEyeDir, -rEyeCenter)-0.04,\n        32.0\n    );\n    \n    float lEyeOutline = smin(\n        sdCircle(lEyeCenter*eyeScale, eyeOutlineRadius),\n        udSegment(lEyeCenter, -eyeOutlineTipLen*lEyeDir, -lEyeCenter)-0.04,\n        32.0\n    );\n    \n    float rEyeJoint = udSegment(rEyeCenter, vec2(0.0, 0.0), -rEyeDir*0.43)-0.1;\n    float lEyeJoint = udSegment(lEyeCenter, vec2(0.0, 0.0), lEyeDir*0.43)-0.1;\n    float midColumn = udSegment(p, vec2(0.0, 0.0)-vec2(0.0,-0.17), -vec2(0.0, -1.0)*0.05)-0.1;\n    float chin = sdEqTriangle((p-vec2(0.0,-0.2))*vec2(0.45, 1.0), 0.3);\n    \n    float redSection = smin(\n        lEyeJoint,\n        lEyeOutline,\n        32.0\n    );\n    \n    redSection = smin(\n        redSection,\n        rEyeOutline,\n        32.0\n    );\n    \n    redSection = smin(\n        redSection,\n        rEyeJoint,\n        32.0\n    );\n    \n    redSection = smin(\n        redSection,\n        midColumn,\n        32.0\n    );\n    \n    redSection = smin(\n        redSection,\n        chin,\n        32.0\n    );\n    \n    // Spikes\n    \n    float topLSpike = sdTriangle(p-vec2(-0.55,1.05),vec2(-0.11,0.0), vec2(0.14,0.0), vec2(-0.075,0.42));\n    float topRSpike = sdTriangle(p-vec2(0.55,1.05),vec2(0.11,0.0), vec2(-0.14,0.0), vec2(0.075,0.42));\n    \n    float botLSpike1 = sdTriangle(p-vec2(-1.0,0.5),vec2(-0.53,-0.19), vec2(0.0,0.0),vec2(0.11,-0.17) );\n    float botLSpike2 = sdTriangle(p-vec2(-0.88,0.31),vec2(-0.46,-0.25), vec2(0.0,0.0),vec2(0.17,-0.13) );\n    float botLSpike3 = sdTriangle(p-vec2(-0.68,0.12),vec2(-0.35,-0.3), vec2(0.0,0.0),vec2(0.2,-0.13) );\n    float botLSpike4 = sdTriangle(p-vec2(-0.45,-0.04),vec2(-0.14,-0.38), vec2(0.0,0.0),vec2(0.22,-0.1) );\n    \n    float botRSpike1 = sdTriangle(p-vec2(1.0,0.5),vec2(0.53,-0.19), vec2(0.0,0.0),vec2(-0.11,-0.17) );\n    float botRSpike2 = sdTriangle(p-vec2(0.88,0.31),vec2(0.46,-0.25), vec2(0.0,0.0),vec2(-0.17,-0.13) );\n    float botRSpike3 = sdTriangle(p-vec2(0.68,0.12),vec2(0.35,-0.3), vec2(0.0,0.0),vec2(-0.2,-0.13) );\n    float botRSpike4 = sdTriangle(p-vec2(0.45,-0.04),vec2(0.14,-0.38), vec2(0.0,0.0),vec2(-0.22,-0.1) );\n    \n    float spikes = min(topLSpike, topRSpike);\n    spikes = min(spikes, botLSpike1);\n    spikes = min(spikes, botLSpike2);\n    spikes = min(spikes, botLSpike3);\n    spikes = min(spikes, botLSpike4);\n    spikes = min(spikes, botRSpike1);\n    spikes = min(spikes, botRSpike2);\n    spikes = min(spikes, botRSpike3);\n    spikes = min(spikes, botRSpike4);\n    \n    // dots\n    float smallR = 0.02;\n    vec2 spacing = vec2(0.07, 0.085);\n    float botDots = repeatedCircles(p-vec2(-(smallR+spacing.x)/3.0, 0.0), smallR, spacing, vec2(0.0,2.0), vec2(1.0, 1.0));\n    float midDots = repeatedCircles(p-vec2(-(smallR+spacing.x)/3.0, 0.27), smallR, spacing, vec2(0.0,0.0), vec2(1.0, 0.0));\n    float dots = min(botDots, midDots);\n    \n    // main mask outline\n    float mainMask = min(\n        dHeart,\n        spikes\n    ); \n   \n    \n    // coloring\n    vec3 col;\n    \n    if (dHeart<0.0) {\n        col = vec3(0.2588, 0.2078, 0.4510);\n        col = mix(col, vec3(0.0,0.0,0.0), 0.6*smoothstep(-0.2, 0.0, dHeart));\n        float f = fbm(9.0*p);\n        col = mix(col, vec3(0.0,0.0,0.0), 0.5*f);\n    }\n    \n    if (max(redSection,dHeart) < 0.03){\n        col = vec3(0.4196, 0.0196, 0.0078);\n        col = mix(col, vec3(0.0,0.0,0.0), 0.6*smoothstep(-0.2, 0.0, dHeart));\n        \n        float f = fbm(8.0*p+0.5);\n        col = mix(col, vec3(0.0,0.0,0.0), 0.8*f);\n        if (redSection > -0.001){\n            col = vec3(0.0,0.0,0.0);\n        }\n    }\n    \n    if (lEyeSocket < 0.0 ){\n        col = vec3(0.0980, 0.1098, 0.2118);\n        col = mix(col, vec3(0.0), 0.7*smoothstep(-0.04, 0.0, lEyeSocket)); \n    }\n    \n    if (rEyeSocket < 0.0){\n        col = vec3(0.0980, 0.1098, 0.2118);\n        col = mix(col, vec3(0.0), 0.7*smoothstep(-0.04, 0.0, rEyeSocket)); \n    }\n    \n    if (dLEye < 0.0){\n        vec3 outerEyeCol = vec3(1.0, 0.1568627450980392, 0.058823529411764705);\n        vec3 innerEyeCol = vec3(1.0, 0.8509803921568627, 0.1803921568627451);\n        float a = smoothstep(-0.14, 0.0, dLEye);\n        col = mix(innerEyeCol, outerEyeCol, a);\n        \n        a = smoothstep(-0.04, 0.0, dLEye);\n        col = mix(col, vec3(0.0, 0.0, 0.0), 0.7*a);\n    }\n    \n    if (dLPupil < 0.0){\n        col = vec3(0.4824, 0.90196, 0.1922);\n        \n        float r = length(lEyeCenter);\n        float theta = atan(lEyeCenter.y,lEyeCenter.x);\n        theta += 0.05*fbm(20.0*p);\n        float f = smoothstep(0.02, 0.6, fbm(vec2(3.0*r, 90.0*theta)));\n        col = mix(col, vec3(1.0), f);\n        \n        float a = smoothstep(-0.03, 0.0, dLPupil);\n        col = mix(col, vec3(0.0, 0.0, 0.0), a*0.7);\n    }\n    \n    if (dREye < 0.0){\n        vec3 outerEyeCol = vec3(1.0, 0.1568627450980392, 0.058823529411764705);\n        vec3 innerEyeCol = vec3(1.0, 0.8509803921568627, 0.1803921568627451);\n        float a = smoothstep(-0.14, 0.0, dREye);\n        col = mix(innerEyeCol, outerEyeCol, a);\n        \n        a = smoothstep(-0.04, 0.0, dREye);\n        col = mix(col, vec3(0.0, 0.0, 0.0), 0.7*a);\n    }\n    \n    if (dRPupil < 0.0){\n        col = vec3(0.4824, 0.90196, 0.1922);\n        \n        float r = length(rEyeCenter);\n        float theta = atan(rEyeCenter.y,rEyeCenter.x);\n        theta += 0.05*fbm(20.0*p);\n        float f = smoothstep(0.02, 0.6, fbm(vec2(0.2*r, 90.0*theta)));\n        col = mix(col, vec3(1.0), f);\n        \n        float a = smoothstep(-0.03, 0.0, dRPupil);\n        col = mix(col, vec3(0.0, 0.0, 0.0), a*0.7);\n        \n    }\n    \n    if (dLDot < 0.0 || dRDot < 0.0){\n        col = vec3(0.0);\n    }\n    \n    if (dots < 0.0){\n        col = vec3(0.0);\n    }\n    \n    if (spikes < 0.0 && dHeart > 0.0){\n        col = vec3(0.996, 1.0, 0.157);\n        col = mix(col, vec3(0.0,0.0,0.0), 0.7*smoothstep(-0.04, 0.0, spikes));\n        float f = fbm(3.0*p);\n        col = mix(col, vec3(0.0,0.0,0.0), 0.7*f);\n    }\n    \n    #if WAVE_BG\n    if (mainMask > 0.0) {\n        float r = sqrt(dot(p-vec2(0.0,0.5),p-vec2(0.0,0.5)));\n        float theta = atan(p.y-0.5, p.x);\n        \n        vec3 colBlue = vec3(0.02352941176, 0.0, 0.52549019608);\n        vec3 colTeal = vec3(0.06274509803921569, 0.7019607843137255, 0.7529411764705882);\n        vec3 colPurple = vec3(0.6, 0.00784313725490196, 0.6117647058823529);\n        vec3 colOlive = vec3(0.6901960784313725, 0.6901960784313725, 0.10980392156862745);\n        vec3 colLime = vec3(0.2196078431372549, 0.7450980392156863, 0.10588235294117647);\n        vec3 colViolet = vec3(0.44313725490196076, 0.011764705882352941, 0.792156862745098);\n\n        \n        \n        \n        \n        \n        // Ensure that the transition from 360 degrees to 0 degrees is harmonious\n        \n        theta += 0.05*fbm(4.0*p) + 0.1*iTime;\n        theta = mod(theta, 2.0 * PI);\n        r += 2.0*cos(0.2*iTime);\n        \n        col = colBlue;\n        \n        float f = fbm(vec2(2.0*r,7.0*theta));\n        col = mix(col, vec3(colTeal), f);\n        \n        f = fbm(vec2(2.0*r,5.0*theta));\n        col = mix(col, vec3(colPurple), f);\n        \n        f = fbm(vec2(4.0*r,7.0*theta));\n        col = mix(col, vec3(colOlive), f);\n        \n        f = fbm(vec2(3.0*r,3.0*theta));\n        col = mix(col, vec3(colLime), f);\n        \n        f = fbm(vec2(2.0*r,4.0*theta));\n        col = mix(col, vec3(colViolet), f);\n        \n        \n        //freq *= 0.8*fbm(5.0*p);\n        //float t = 0.5 * (1.0 + cos(spikes * freq - phase*iTime));\n        //vec3 col1 = vec3(0.011764705882352941, 0.4549019607843137, 0.4470588235294118);\n        //vec3 col2 = vec3(0.0, 0.0, 0.0);\n        //col = mix(col1, col2, t);\n    };\n    \n    #endif\n    \n    #if BATTLE_BG\n    \n    #endif\n    \n    // draw reference image\n    float imgAspect = 1200.0 / 1039.0;\n    // Calculate the aspect-corrected texture coordinates\n    vec2 screenDimensions = iResolution.xy;\n    vec2 imageSize = min(screenDimensions / max(imgAspect, 1.0), screenDimensions * max(imgAspect, 1.0));\n    vec2 padding = (screenDimensions - imageSize) / 2.0;\n\n    // Calculate the texture coordinates while maintaining aspect ratio\n    vec2 texCoord = (fragCoord - padding) / imageSize;\n  \n    vec4 imgCol = texture(iChannel0, texCoord);\n    col = mix(col, imgCol.rgb, imgCol.a*REF_ALPHA);\n    \n    // Post-processing\n    col = mix(col, vec3(0.0,0.0,0.0), 0.3*smoothstep(0.0, 1.8, length((p-vec2(0.0,0.5))*vec2(0.5,1.0))));\n    \n   // output\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}