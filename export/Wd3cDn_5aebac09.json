{"ver":"0.1","info":{"id":"Wd3cDn","date":"1601569657","viewed":306,"name":"Kerr Black Hole","username":"bgold","description":"Visualization of a rotating (Kerr solution) black hole.  Geometric effects only, no redshifting or camera velocity effects. \nMouse to change view direction, hold keyboard 1,2,3 to zoom the view.\n\nThe calculation can get pretty bad right near the poles","likes":11,"published":1,"flags":16,"usePreview":0,"tags":["blackhole"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CAMPHASE (iTime*2.0*PI/180.0)\n#define CAMPATH vec3(100.0*cos(CAMPHASE), 5.0*sin(CAMPHASE), 5.0*sin(CAMPHASE/4.0))\n//#define CAMPATH vec3(100,0,70)\n#define FOV 60.0\n\n// set QUAL to 5.0 or higher if you can, diminishing returns after that\n// for very high QUAL you may need to increase MAXITER if \"holes\" appear\n// RMAX just needs to be safely larger than your largest camera radius\n#define QUAL 1.0\n#define MAXITER 30000\n#define RMAX 200.0\n\n// using a prediction-correction integration method allows larger stepsize\n// for the same accuracy and is much faster, but makes the disk look pixelated\n#define PREDICTOR_METHOD\n\n// the fake starfield looks weird at some zoom levels\n// comment this out for a checkerboard background instead\n#define STARS\n\n// make a disk, you can change the inner/outer radius and thickness\n// these are not especially realistic numbers, just chosen to look interesting\n#define DISK\n#define DI 6.0\n#define DO 10.0\n#define DTH 0.05\n\n// Kerr parameter, 1.0 is maximally spinning\nconst float ROT = 1.0;\n\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float PI = 3.14159265359;\nconst float A2 = ROT * ROT;\n\nstruct State {vec3 x; vec3 v;};\n    \nstruct State4 {\n    vec4 r; // r, theta, phi, time\n    vec2 v; // r_dot, theta_dot\n};\n    \nstruct Pars {\n    float e; float lz; float c;\n};\n    \nState cart2sph(in State p) {\n\tvec3 r, vr;\n    \n    float ra2 = dot(p.x, p.x) - A2;\n    float xv = dot(p.x, p.v);\n    float root = sqrt(ra2*ra2 + 4.0*A2*p.x.z*p.x.z);\n    \n    r.r = sqrt(0.5 * (ra2 + root)); // r\n    r.g = acos(p.x.z / r.r); // theta\n    r.b = atan(p.x.y, p.x.x); // phi\n    \n    vr.r = 0.5*xv + (0.5*ra2*xv + A2*p.x.z*p.v.z) / root;\n    vr.r /= r.r;  // rdot\n    vr.g = (vr.r * cos(r.g) - p.v.z) / (r.r * sin(r.g)); // thetadot\n    vr.b = (p.x.x * p.v.y - p.x.y * p.v.x) * cos(r.b) * cos(r.b) / p.x.x / p.x.x; // phidot\n        \n    return State(r,vr);\n}\n\nState sph2cart(in State p) {\n    vec3 x, vx;\n    \n    float r2a2 = p.x.r * p.x.r + A2;\n    float root = sqrt(r2a2);\n    float vxycoeff = p.x.r * p.v.r / r2a2;\n    \n    x.x = root * sin(p.x.g) * cos(p.x.b);\n    x.y = root * sin(p.x.g) * sin(p.x.b);\n    x.z = p.x.r * cos(p.x.g);\n    \n    vx.x = x.x*vxycoeff + p.v.g*x.x/tan(p.x.g) - p.v.b*x.y; // xdot\n    vx.y = x.y*vxycoeff + p.v.g*x.y/tan(p.x.g) + p.v.b*x.x; // ydot\n    vx.z = p.v.r*cos(p.x.g) - p.x.r*p.v.g*sin(p.x.g); // zdot\n \n    return State(x,vx);\n}\n\nPars getPars(in State p) {\n    float r2 = p.x.r * p.x.r;\n    float cos2 = cos(p.x.g) * cos(p.x.g);\n    float sin2 = 1.0 - cos2;\n    float sigma = r2 + A2 * cos2;\n    float gtphi = 2.0 * p.x.r * ROT * sin2 / sigma;\n    \n    // setting tdot to unity \n    float ee = 1.0 - 2.0*p.x.r/sigma + gtphi * p.v.b;\n    float lz = p.v.b * sin2 * (r2 + A2 + ROT*gtphi) - gtphi;\n    \n    return Pars(ee, lz, sigma*sigma*p.v.g*p.v.g + cos2 * (A2*ee*ee - lz*lz/sin2)); \n}\n\nState4 setupDiff(in State r) {\n    return State4(vec4(r.x,0), r.v.rg);\n}\n\nState4 derivs(in State4 s, in Pars par) {\n    vec4 dr;\n    vec2 dp;\n    \n    float r2 = s.r.r * s.r.r;\n    float cos2 = cos(s.r.g) * cos(s.r.g);\n    float sin2 = 1.0 - cos2;\n    float sincos = sin(s.r.g) * cos(s.r.g);\n    float delta = r2 - 2.0 * s.r.r + A2;\n    float sigma = r2 + A2 * cos2;\n    float term1 = par.e * (r2 + A2) - par.lz * ROT;\n    float term2 = pow(par.lz - ROT*par.e,2.0) + par.c;\n    float capr = term1*term1 - delta*term2;\n    float capth = par.c - cos2 * (A2*par.e*par.e + par.lz*par.lz/sin2);\n    float sigma2 = sigma * sigma;\n    \n    dr.r = s.v.r; // rdot\n    dr.g = s.v.g; // thetadot\n    dr.b = -(ROT * par.e - par.lz/sin2) + ROT * term1 / delta;\n    dr.b /= sigma; // phidot\n    dr.a = -ROT * (ROT * par.e * sin2 - par.lz) + (r2+A2)*term1/delta; \n    dr.a /= sigma; // tdot\n    \n    dp.r = 2.0*par.e*s.r.r * term1 - (s.r.r - 1.0)*term2 - 2.0 * s.r.r * capr / sigma;\n    dp.r += A2 * sigma * s.v.r * s.v.g * sincos;\n    dp.r /= sigma2; // rddot\n    \n    dp.g = sincos * A2 * (par.e + capth/sigma);\n    dp.g += par.lz*par.lz * cos(s.r.g)*pow(sin(s.r.g),-3.0) - 2.0 * s.r.r * sigma * s.v.r * s.v.g;\n    dp.g /= sigma2;   \n    \n    return State4(dr,dp);\n}\n\nvec3 output2dir(in State4 s, in Pars par) {\n    State4 ds = derivs(s, par);\n    State c = sph2cart(State(s.r.rgb, ds.r.rgb));\n    return normalize(c.v);\n}\n\nState4 integrationStepRK(in State4 f, in State4 last[3], in Pars par, in float dt) {\n    // I'm sorry this is so awkward\n    const vec4 b = vec4(0.17476028, -0.55148066, 1.20553560, 0.17118478);\n    const mat4 a = mat4(0, 0.4, 0.29697761, 0.21810040,\n                        0, 0, 0.15875964, -3.05096516,\n                        0, 0, 0, 3.83286476,\n                        0,0,0,0);\n    State4 k0 = derivs(f,par);\n    State4 k1 = derivs(State4(f.r + dt*a[1].x*k0.r, f.v + dt*a[1].x*k0.v), par);\n    State4 k2 = derivs(State4(f.r + dt*(a[2].x*k0.r+a[2].y*k1.r), f.v + dt*(a[2].x*k0.v+a[2].y*k1.v)), par);\n    State4 k3 = derivs(State4(f.r + dt*(a[3].x*k0.r+a[3].y*k1.r+a[3].z*k2.r), f.v + dt*(a[3].x*k0.v+a[3].y*k1.v+a[3].z*k2.v)), par);\n    \n    return State4(f.r + dt * (b.x * k0.r + b.y * k1.r + b.z * k2.r + b.w * k3.r),\n                  f.v + dt * (b.x * k0.v + b.y * k1.v + b.z * k2.v + b.w * k3.v));\n}\n\n#ifdef PREDICTOR_METHOD\nState4 integrationStep(in State4 f, inout State4 last[3], in Pars par, in float dt) {\n    // two-step adams-bashforth prediction\n    State4 df = derivs(f, par);\n    State4 pred = State4(f.r + dt * (1.5 * df.r - 0.5 * last[0].r),\n                         f.v + dt * (1.5 * df.v - 0.5 * last[0].v) );\n    // two-step adams-moulton correction\n    State4 ndf = derivs(pred, par);\n    State4 next = State4(f.r + dt / 12.0 * (5.0 * ndf.r + 8.0 * df.r - last[0].r),\n                         f.v + dt / 12.0 * (5.0 * ndf.v + 8.0 * df.v - last[0].v));\n    last[0] = df;\n    return next;\n}\n#else\nState4 integrationStep(in State4 f, in State4 last[3], in Pars par, in float dt) {\n    State4 df = derivs(f, par);\n    return State4(f.r + df.r * dt, f.v + df.v * dt);\n}\n#endif\n\nint sgn(in float x) { return (x>0.0)?1:-1; } // yes, I know\n\nbool inDisk(in vec4 f, in vec4 lastf) {\n    float z = f.r * cos(f.g);\n    float lastz = lastf.r * cos(lastf.g);\n    if ((f.r < DO && f.r > DI) || (sgn(lastf.r - DO) != sgn(f.r - DI))) {\n        if (abs(z) < DTH) return true;\n        if (sgn(z) != sgn(lastz)) return true;\n    }\n    return false;\n}\n\nState4 pathTrace( in State4 f, in Pars par) {\n    float dt;\n    \n    State4 last[3];\n    //last[0] = derivs(f, par);\n    //last[1] = last[0];\n    //last[2] = last[1];\n    for (int j=0; j<MAXITER; j++) {\n        dt = 0.01/QUAL * abs((f.r.r-0.95)) * abs(sin(f.r.g));\n#ifdef PREDICTOR_METHOD\n        dt *= 10.0;\n#endif\n        f = integrationStep(f, last, par, dt);\n        if (f.r.r < 1.0) return State4(vec4(0), vec2(0)); \n#ifdef DISK\n        if (inDisk(f.r, f.r-dt*last[0].r))\n            return State4(vec4(f.r.rgb,-2.0), f.v);\n#endif\n        if (f.r.r > RMAX) return f;\n    }\n    // sometimes there are really crazy long orbits, just bail out on those\n    return State4(vec4(0), vec2(0));\n}\n    \nState setupCam(in vec2 uv, in vec2 m, in float zoom) {\n    vec3 from = vec3(iResolution.x/iResolution.y/tan(FOV*PI/360.0), 0, 0); // about 60-deg wide fov\n    vec3 to = vec3(0, uv/zoom);\n    vec3 view = normalize(to-from);\n\n    // try to keep the cam pointing roughly toward the BH\n    vec3 camdir = -normalize(CAMPATH);\n    vec2 r = vec2(acos(camdir.x)-PI, 0);\n    view = mat3(cos(r.x), -sin(r.x), 0, sin(r.x), cos(r.x), 0, 0, 0, 1 ) * view;\n           \n    view = mat3(cos(m.x), -sin(m.x), 0, sin(m.x), cos(m.x), 0, 0, 0, 1 ) * view;\n    view = mat3(cos(m.y), 0, -sin(m.y), 0, 1, 0, sin(m.y), 0, cos(m.y) ) * view;\n    \n    return State(CAMPATH, view);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n    // set up uv to go from -1 to 1 in vertical direction, -aspect_ratio to aspect_ratio in horizontal\n    vec2 uv = (fragCoord - iResolution.xy/2.0)*2.0/iResolution.y; \n    vec2 m = (iMouse.xy - iResolution.xy/2.0)*2.0/iResolution.xy * vec2(PI, PI/2.0);\n   \n    float zoom = 1.0;\n    \n\tzoom += 1.0*texture(iChannel0, vec2(KEY_1,0.25)).x;\n    zoom += 4.0*texture(iChannel0, vec2(KEY_2,0.25)).x;\n    zoom += 16.0*texture(iChannel0, vec2(KEY_3,0.25)).x;\n        \n    State s = setupCam(uv, m, zoom);\n    \n\n    State r = cart2sph(s);\n    \n    Pars par = getPars(r);\n    State4 f = setupDiff(r);\n    \n    State4 rf = pathTrace(f, par);  // sph coord\n     \n    vec4 shade = vec4(1);\n    if (rf.r.a < 1.0) shade = vec4(0);\n    \n    vec3 view = output2dir(rf, par);\n      \n    float vth = acos(view.z);\n    float vph = atan(view.y, view.x);\n    vec4 background;\n#ifdef STARS\n    background = texture(iChannel1, view);\n#else\n    background = vec4( 0.5*round(fract(vth*18.0/PI)) , 0.5*round(fract(vph*18.0/PI)), 0.5, 1 );  \n#endif\n          \n    fragColor = shade * background;\n#ifdef DISK\n    //if (rf.r.a < -1.0) fragColor = vec4(1,1,1,1);\n    if (rf.r.a < -1.0) {\n        fragColor = texture(iChannel2, vec2(rf.r.b/2.0/PI-fract(iTime/60.0), (rf.r.r-DI)/(DO-DI)));\n        fragColor = pow((fragColor)*vec4(3,2.5,2.5,1), vec4(5.));\n    }\n#endif\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"#define PI 3.1415926536\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(in vec2 x) {\n    float y = 0.0;\n    float g = 1.0;\n    vec2 k = vec2(13.7, 11.9)*100.0;\n    for (int i=0; i<8; i++) {\n        y += g* noise(k*x);\n        g *= 1.1;\n        k *= 1.88;\n    }\n    return y/16.;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 v )\n{\n    vec2 uv = vec2(atan(v.y,v.x)/PI/2.0*sqrt(1.0 - v.z*v.z), acos(v.z)/PI);\n    float x = fbm(uv);\n    x = pow(x*1.99, 10.0);\n    float h1 = 1.0 - pow(fract(x*1e3), 5.0);\n    float h2 = 1.0 - pow(fract(x*1e6), 5.0);\n    \n    vec3 col = x * vec3(1,h1,h2);\n    fragColor = vec4(col,1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}