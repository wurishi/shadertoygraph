{"ver":"0.1","info":{"id":"XtjcRD","date":"1507682431","viewed":170,"name":"Optimized box-shadow shader","username":"cmf028","description":"An example of an optimized version of the box-shadow shader used in webrender.\nhttps://github.com/servo/webrender/blob/f1569c043b838b1ecd62ba47a6694ef09eb1f865/webrender/res/cs_box_shadow.glsl\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n\n#define M_PI 3.14159265359\n\n// number of loop iterations when evaluating the integral in the optimized implementation\n// 24 seems to be sufficient\n#define NUM_STEPS 24\n\n// See http://asciimath.org to render the equations here.\n\n// The Gaussian function used for blurring:\n//\n//     G_sigma(x) = 1/sqrt(pi) e^(-x^2)\nfloat gauss(float x) {\n    return 1.0 / sqrt(M_PI) * exp(-(x * x));\n}\n\n// See http://asciimath.org to render the equations here.\n\n// The Gaussian function used for blurring:\n//\n//     G_sigma(x) = 1/sqrt(2 pi sigma^2) e^(-x^2/(2 sigma^2))\nfloat gauss(float x, float sigma) {\n    \n    float sigmaPow2 = sigma*sigma;\n    return 1.0 / sqrt(2.0 * M_PI * sigmaPow2) * exp(-(x * x)/(2.0*sigmaPow2));\n}\n\n// An approximation of the error function, which is related to the integral of the Gaussian\n// function:\n//\n//     \"erf\"(x) = 2/sqrt(pi) int_0^x e^(-t^2) dt\n//              ~~ 1 - 1 / (1 + a_1 x + a_2 x^2 + a_3 x^3 + a_4 x^4)^4\n//\n// where:\n//\n//     a_1 = 0.278393, a_2 = 0.230389, a_3 = 0.000972, a_4 = 0.078108\n//\n// This approximation is accurate to `5 xx 10^-4`, more than accurate enough for our purposes.\n//\n// See: https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\nfloat erf(float x) {\n    float s = x < 0.0 ? -1.0 : 1.0;\n    x = abs(x);\n    float denom = 1.0 + (0.278393 + (0.230389 + (0.000972 + 0.078108 * x)*x)*x)*x;\n    denom *= denom;\n    float result = s - s / (denom * denom);\n    return result;\n}\n\n// A useful helper for calculating integrals of the Gaussian function via the error function:\n//\n//      \"erf\"_sigma(x) = 2 int 1/sqrt(2 pi sigma^2) e^(-x^2/(2 sigma^2)) dx\n//                     = \"erf\"(x/(sigma sqrt(2)))\nfloat erfSigma(float x, float sigma) {\n    return erf(x / (sigma * 1.4142135623730951));\n}\n\n// Returns the blurred color value from the box itself (not counting any rounded corners). `p_0` is\n// the vector distance to the top left corner of the box; `p_1` is the vector distance to its\n// bottom right corner.\n//\n//      \"colorFromRect\"_sigma(p_0, p_1)\n//          = int_{p_{0_y}}^{p_{1_y}} int_{p_{1_x}}^{p_{0_x}} G_sigma(y) G_sigma(x) dx dy\n//          = 1/4 (\"erf\"_sigma(p_{1_x}) - \"erf\"_sigma(p_{0_x}))\n//              (\"erf\"_sigma(p_{1_y}) - \"erf\"_sigma(p_{0_y}))\nfloat colorFromRect(vec2 p0, vec2 p1, float sigma) {\n    return (erfSigma(p1.x, sigma) - erfSigma(p0.x, sigma)) *\n        (erfSigma(p1.y, sigma) - erfSigma(p0.y, sigma)) / 4.0;\n}\n\n// Returns the `x` coordinate on the ellipse with the given radii for the given `y` coordinate:\n//\n//      \"ellipsePoint\"(y, y_0, a, b) = a sqrt(1 - ((y - y_0) / b)^2)\nfloat ellipsePoint(float y, float y0, vec2 radii) {\n    float bStep = (y - y0) / radii.y;\n    return radii.x * sqrt(1.0 - bStep * bStep);\n}\n\n\n// This is the reference function that is meant to be the most accurate representation.\n// A helper function to compute the value that needs to be subtracted to accommodate the border\n//\n//     \"colorCutout\"_sigma(x_{0_l}, x_{0_r}, y_0, y_{min}, y_{max}, a, b)\n//          = int_{y_{min}}^{y_{max}}\n//              int_{x_{0_r} + \"ellipsePoint\"(y, y_0, a, b)}^{x_{0_r} + a} G_sigma(y) G_sigma(x) dx\n//              + int_{x_{0_l} - a}^{x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)} G_sigma(y) G_sigma(x)\n//                  dx dy\n//          = int_{y_{min}}^{y_{max}} 1/2 G_sigma(y)\n//              (\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b)) +\n//               \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) - \"erf\"_sigma(x_{0_l} - a)) dy\n//          = int_{y_{min}}^{y_{max}} 1/2 G_sigma(y)\n//              ( \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) - \n//                \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b))) dy\n//            + int_{y_{min}}^{y_{max}} 1/2 G_sigma(y) (\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_l} - a)) dy\n//          =\n//            1/2 int_{y_{min}}^{y_{max}} G_sigma(y)\n//              ( \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) -\n//                \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b))) dy\n//            + 1/2 (\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_l} - a)) int_{y_{min}}^{y_{max}} G_sigma(y) dy\n//          =\n//            1/2 (int_{y_{min}}^{y_{max}} G_sigma(y)\n//              ( \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) -\n//                \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b))) dy   \n//            + 1/2(\"erf\"_sigma(y_{max}) - \"erf\"_sigma(y_{min}))(\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_l} - a)))\n// \n// with the integral evaluated numerically via the midpoint rule\nfloat colorCutoutGeneralRef(float x0l,\n                         float x0r,\n                         float y0,\n                         float yMin,\n                         float yMax,\n                         vec2 radii,\n                         float sigma) {\n    float sum = 0.0;\n    float stepsize = 1.0/16.0;\n    // definite part\n    \n    float definiteGaussIntegral = 0.5*(erfSigma(yMax,sigma) - erfSigma(yMin,sigma));\n    \n    definiteGaussIntegral *= (erfSigma(x0r + radii.x, sigma) - erfSigma(x0l - radii.x, sigma));\n    \n    for (float y = yMin + 0.5*stepsize; y < yMax; y += stepsize) {\n        float xEllipsePoint = ellipsePoint(y, y0, radii);\n        sum += gauss(y, sigma) *\n            (  - erfSigma(x0r + xEllipsePoint, sigma) +\n             erfSigma(x0l - xEllipsePoint, sigma));\n    }\n    return (sum * stepsize + definiteGaussIntegral)/ 2.0;\n}\n\n// this is the original version present in webrender\n// A helper function to compute the value that needs to be subtracted to accommodate the border\n//\n//     \"colorCutout\"_sigma(x_{0_l}, x_{0_r}, y_0, y_{min}, y_{max}, a, b)\n//          = int_{y_{min}}^{y_{max}}\n//              int_{x_{0_r} + \"ellipsePoint\"(y, y_0, a, b)}^{x_{0_r} + a} G_sigma(y) G_sigma(x) dx\n//              + int_{x_{0_l} - a}^{x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)} G_sigma(y) G_sigma(x)\n//                  dx dy\n//          = int_{y_{min}}^{y_{max}} 1/2 G_sigma(y)\n//              (\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b)) +\n//               \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) - \"erf\"_sigma(x_{0_l} - a))\n//\n// with the outer integral evaluated numerically.\nfloat colorCutoutGeneral(float x0l,\n                         float x0r,\n                         float y0,\n                         float yMin,\n                         float yMax,\n                         vec2 radii,\n                         float sigma) {\n    float sum = 0.0;\n\n    // definite part\n    for (float y = yMin; y < yMax; y++) {\n        float xEllipsePoint = ellipsePoint(y, y0, radii);\n        sum += gauss(y, sigma) *\n            ( erfSigma(x0r + radii.x, sigma) - erfSigma(x0r + xEllipsePoint, sigma) +\n             erfSigma(x0l - xEllipsePoint, sigma) - erfSigma(x0l - radii.x, sigma));\n    }\n    return sum / 2.0;\n}\n\n\n// A helper function to compute the value that needs to be subtracted to accommodate the border\n//\n//     \"colorCutout\"_sigma(x_{0_l}, x_{0_r}, y_0, y_{min}, y_{max}, a, b)\n//          = int_{y_{min}}^{y_{max}}\n//              int_{x_{0_r} + \"ellipsePoint\"(y, y_0, a, b)}^{x_{0_r} + a} G_sigma(y) G_sigma(x) dx\n//              + int_{x_{0_l} - a}^{x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)} G_sigma(y) G_sigma(x)\n//                  dx dy\n//          = int_{y_{min}}^{y_{max}} 1/2 G_sigma(y)\n//              (\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b)) +\n//               \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) - \"erf\"_sigma(x_{0_l} - a)) dy\n//          = int_{y_{min}}^{y_{max}} 1/2 G_sigma(y)\n//              ( \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) - \n//                \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b))) dy\n//            + int_{y_{min}}^{y_{max}} 1/2 G_sigma(y) (\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_l} - a)) dy\n//          =\n//            1/2 int_{y_{min}}^{y_{max}} G_sigma(y)\n//              ( \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) -\n//                \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b))) dy\n//            + 1/2 (\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_l} - a)) int_{y_{min}}^{y_{max}} G_sigma(y) dy\n//          =\n//            1/2 (int_{y_{min}}^{y_{max}} G_sigma(y)\n//              ( \"erf\"_sigma(x_{0_l} - \"ellipsePoint\"(y, y_0, a, b)) -\n//                \"erf\"_sigma(x_{0_r} + \"ellipsePoint\"(y, y_0, a, b))) dy   \n//            + 1/2(\"erf\"_sigma(y_{max}) - \"erf\"_sigma(y_{min}))(\"erf\"_sigma(x_{0_r} + a) - \"erf\"_sigma(x_{0_l} - a)))\n// \n// with the integral evaluated numerically via the midpoint rule\nfloat colorCutoutGeneral2(float x0l,\n                         float x0r,\n                         float y0,\n                         float yMin,\n                         float yMax,\n                         vec2 radii,\n                         float sigma) {\n \n    float numSteps = float(NUM_STEPS);\n    \n    // normalize the distribution and scale to sigma = 1.0/sqrt(2.0) to remove some computations\n    // this could be done in the vertex shader\n    float invsigma = 1.0/(sqrt(2.0)*sigma);\n    yMin *= invsigma;\n    yMax *= invsigma;\n    y0 *= invsigma;\n    x0l *= invsigma;\n    x0r *= invsigma;\n    radii *= invsigma;\n    sigma *= invsigma;\n    \n    // focus integration samples to [-3.0*sigma, 3.0*sigma] (99.73% of the area of gauss() is in this range)\n    float start = clamp(-3.0*sigma, yMin, yMax);\n    float end = clamp(3.0*sigma, yMin, yMax);\n    \n    float stepsize = (end - start)/numSteps;\n    \n    float y = start + stepsize*0.5;\n    \n    // GPU Gems 3: Incremental Computation of the Gaussian\n    float g0 = gauss(y);\n    float imm = exp(-stepsize*stepsize);\n    float g1 = imm*exp(-stepsize*y*2.0);\n    float g2 = imm*imm;\n    \n    float sum = 0.0;\n    \n    \n    // from the equation of an ellipse:\n    // x = a/b sqrt(b^2-(y-y0)^2) \n    // = sqrt(b^2*(a^2/b^2)-(y-y0)^2*(a^2/b^2))\n    // = sqrt(a^2-((y-y0)*a/b)^2)\n    float yoff = (y - y0)*radii.x/radii.y;\n    float rx = radii.x*radii.x;\n    float stepsize2 = stepsize*radii.x/radii.y;\n    \n    // numerical integration by midpoint rule\n    for (int i = 0; i < NUM_STEPS; i++) {\n        float xoff = sqrt(rx-yoff*yoff);\n        \n        sum += g0 * (erf(x0l - xoff) - erf(x0r + xoff));\n        \n        g0 *= g1;\n        g1 *= g2;\n        yoff += stepsize2;\n    }\n    \n    sum *= stepsize;\n    sum += 0.5*(erf(end) - erf(start)) * (erf(x0r + radii.x) - erf(x0l-radii.x));\n    return sum*0.5;\n}\n\n// same as colorCutoutGeneral2, but combines computations for the top and bottom parts to increase performance\nfloat colorCutout(float x0l, float x0r, float y0b, float y0t, vec2 radii, float sigma)\n{\n    float numSteps = float(NUM_STEPS);\n    \n    // normalize the distribution, then scale to sigma = 1.0/sqrt(2.0) to remove some computations\n    // this could be done in the vertex shader\n    float invsigma = 1.0/(sqrt(2.0)*sigma);\n    y0b *= invsigma;\n    y0t *= invsigma;\n    x0l *= invsigma;\n    x0r *= invsigma;\n    radii *= invsigma;\n    sigma *= invsigma;\n    \n    // focus integration samples to [-3.0*sigma, 3.0*sigma] (99.73% of the area of gauss() is in this range)\n    float start = clamp(-3.0/sqrt(2.0), y0t, y0t+radii.y);\n    float end = clamp(3.0/sqrt(2.0), y0t, y0t+radii.y);\n    \n    float start2 = clamp(-3.0/sqrt(2.0), y0b-radii.y, y0b);\n    float end2 = clamp(3.0/sqrt(2.0), y0b-radii.y, y0b);\n    \n    // take the largest range because we are integrating both top and bottom\n    // this works because the top and bottom use the same y radius\n    float mlen = max(end2-start2, end-start);\n    float stepsize = mlen / numSteps;\n    \n    float yt = start + stepsize*0.5;\n    float yb = end2 - stepsize*0.5;\n    \n    // GPU Gems 3: Incremental Computation of the Gaussian\n    float imm = exp(-stepsize*stepsize);\n    float g2 = imm*imm;\n    \n    // top:    gauss(yt),gauss(yt+stepsize),gauss(yt+2stepsize)...\n    float g0t = gauss(yt);\n    float g1t = imm*exp(-stepsize*yt*2.0);\n    \n    // bottom: gauss(yb),gauss(yb-stepsize),gauss(yb-2stepsize)...\n    float g0b = gauss(yb);\n    float g1b = imm*exp(stepsize*yb*2.0);\n    \n    float sum = 0.0;\n    \n    // from the equation of an ellipse:\n    // x = a/b sqrt(b^2-y^2) \n    // = sqrt(b^2*(a^2/b^2)-y^2*(a^2/b^2))\n    // = sqrt(a^2-(y*a/b)^2)\n    float yoff = max(yt - y0t, y0b - yb)*radii.x/radii.y;\n    float rx = radii.x*radii.x;\n    float stepsize2 = stepsize*radii.x/radii.y;\n    \n    // numerical integration by midpoint rule\n    // integrates both the top and bottom at the same time\n    for (int i = 0; i < NUM_STEPS; i++) {\n        float xoff = sqrt(rx - yoff*yoff);\n        \n        sum += (g0t + g0b) * (erf(x0l - xoff) - erf(x0r + xoff));\n        \n        g0t *= g1t;\n        g1t *= g2;\n        g0b *= g1b;\n        g1b *= g2;\n        yoff += stepsize2;\n    }\n    \n    sum *= stepsize;\n    \n    // integrate last part\n    float xerfdiff = erf(x0r + radii.x) - erf(x0l - radii.x);\n    sum += 0.5*(erf(start+mlen) - erf(start)) * xerfdiff;\n    sum += 0.5*(erf(end2) - erf(end2-mlen)) * xerfdiff;\n    \n    return sum*0.5;\n}\n\n// The value that needs to be subtracted to accommodate the top border corners.\nfloat colorCutoutTop(float x0l, float x0r, float y0, vec2 radii, float sigma) {\n    return colorCutoutGeneral(x0l, x0r, y0, y0, y0 + radii.y, radii, sigma);\n}\n\n// The value that needs to be subtracted to accommodate the bottom border corners.\nfloat colorCutoutBottom(float x0l, float x0r, float y0, vec2 radii, float sigma) {\n    return colorCutoutGeneral(x0l, x0r, y0, y0 - radii.y, y0, radii, sigma);\n}\n\n// The value that needs to be subtracted to accommodate the top border corners.\nfloat colorCutoutTopRef(float x0l, float x0r, float y0, vec2 radii, float sigma) {\n    return colorCutoutGeneralRef(x0l, x0r, y0, y0, y0 + radii.y, radii, sigma);\n}\n\n// The value that needs to be subtracted to accommodate the bottom border corners.\nfloat colorCutoutBottomRef(float x0l, float x0r, float y0, vec2 radii, float sigma) {\n    return colorCutoutGeneralRef(x0l, x0r, y0, y0 - radii.y, y0, radii, sigma);\n}\n// The value that needs to be subtracted to accommodate the top border corners.\nfloat colorCutoutTop2(float x0l, float x0r, float y0, vec2 radii, float sigma) {\n    return colorCutoutGeneral2(x0l, x0r, y0, y0, y0 + radii.y, radii, sigma);\n}\n\n// The value that needs to be subtracted to accommodate the bottom border corners.\nfloat colorCutoutBottom2(float x0l, float x0r, float y0, vec2 radii, float sigma) {\n    return colorCutoutGeneral2(x0l, x0r, y0, y0 - radii.y, y0, radii, sigma);\n}\n\n// The blurred color value for the point at `pos` with the top left corner of the box at\n// `p_{0_\"rect\"}` and the bottom right corner of the box at `p_{1_\"rect\"}`.\nfloat color(vec2 pos, vec2 p0Rect, vec2 p1Rect, vec2 radii, float sigma) {\n    // Compute the vector distances `p_0` and `p_1`.\n    vec2 p0 = p0Rect - pos, p1 = p1Rect - pos;\n\n    // Compute the basic color `\"colorFromRect\"_sigma(p_0, p_1)`. This is all we have to do if\n    // the box is unrounded.\n    float cRect = colorFromRect(p0, p1, sigma);\n    if (radii.x == 0.0 || radii.y == 0.0 || cRect == 0.0)\n        return cRect;\n\n    // Compute the inner corners of the box, taking border radii into account: `x_{0_l}`,\n    // `y_{0_t}`, `x_{0_r}`, and `y_{0_b}`.\n\n    float x0l = p0.x + radii.x;\n    float y0t = p1.y - radii.y;\n    float x0r = p1.x - radii.x;\n    float y0b = p0.y + radii.y;\n    \n    \n    // Compute the final color:\n    //\n    //     \"colorFromRect\"_sigma(p_0, p_1) -\n    //          (\"colorCutoutTop\"_sigma(x_{0_l}, x_{0_r}, y_{0_t}, a, b) +\n    //           \"colorCutoutBottom\"_sigma(x_{0_l}, x_{0_r}, y_{0_b}, a, b))\n    \n    // reference\n    //float refo = cRect - (colorCutoutTopRef(x0l, x0r, y0t, radii,sigma) + colorCutoutBottomRef(x0l, x0r, y0b, radii,sigma));\n   \n    // webrender version\n    //float res1o = cRect - (colorCutoutTop(x0l, x0r, y0t, radii, sigma) + colorCutoutBottom(x0l, x0r, y0b, radii, sigma));\n    \n    // optimized version, separate top/bottom\n    float res2o = cRect - (colorCutoutTop2(x0l, x0r, y0t, radii, sigma) + colorCutoutBottom2(x0l, x0r, y0b, radii, sigma));\n    \n    // optimized version, combined top/bottom\n    //float res3o = cRect - colorCutout(x0l, x0r, y0b, y0t, radii, sigma);\n    \n    return res2o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    \n    // nothing to see here, just normalizing coordinates for shadertoy\n    vec2 idealResolution = vec2(800.0, 450.0);\n    vec2 resScale = iResolution.xy/idealResolution;\n    \n    // (rounded) rectangle parameters\n    vec2 p0Rect = vec2(100,100), p1Rect = vec2(600,300);\n    vec2 radii = vec2(300,100);\n    float blurRadius = 64.0;\n    \n    p0Rect *= resScale;\n    p1Rect *= resScale;\n    radii *= resScale;\n\n    \n    float sigma = blurRadius / 2.0;\n    \n    float value = color(pos, p0Rect, p1Rect, radii, sigma);\n\n    value = max(value, 0.0);\n    fragColor = vec4(value,value,value,1.0);\n}","name":"Image","description":"","type":"image"}]}