{"ver":"0.1","info":{"id":"MdG3R3","date":"1455565909","viewed":180,"name":"Orange Matter","username":"fab","description":"A fixed version of my older failed noise implementation, along with some ad-hoc stuff to make it look eerie :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["proceduralnoiseoctaves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Range: 0..1\nfloat intensity = 1.0;\n\n// Number of octaves in the Perlin noise generation\nconst int iterations = 10;\n\nfloat rand(vec2 co){\n    return mod(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453), 1.0)*\n               (1.0 + sin((0.000431*(co.x+41521.1251)*(co.y-22535.12412) + iTime)/0.7) / 2.0);\n}\n\nfloat getOctHarsh(float oct, vec2 pos, float att){\n    float x = pos.x;\n    float y = pos.y;\n    float divx = iResolution.x / pow(2.0, oct);\n    float divy = iResolution.y / pow(2.0, oct);\n    x = floor(x / divx);\n    y = floor(y / divy);\n    return rand(divx * divy * vec2(x, y)) * att;\n}\n\nfloat getOct(float octave, vec2 pos, float att){\n    float divx = iResolution.x / pow(2.0, octave);\n    float divy = iResolution.y / pow(2.0, octave);\n    \n    // neighbor noise values\n    vec2 below       = vec2( pos.x        , pos.y + divy );\n    vec2 above       = vec2( pos.x        , pos.y - divy );\n    vec2 left        = vec2( pos.x - divx , pos.y        );\n    vec2 right       = vec2( pos.x + divx , pos.y        );\n    vec2 topleft     = vec2( pos.x - divx , pos.y - divy );\n    vec2 topright    = vec2( pos.x + divx , pos.y - divy );\n    vec2 bottomleft  = vec2( pos.x - divx , pos.y + divy );\n    vec2 bottomright = vec2( pos.x + divx , pos.y + divy );\n    \n    // UV within that grain of noise\n    vec2 uv = vec2(mod(pos.x, divx)/divx, mod(pos.y, divy)/divy);\n    \n    \n    // LR weights\n    float wr = (2.0*max(uv.x - 0.5, 0.0)) * (1.0 - (2.0 * abs(uv.y - 0.5)));\n    float wl = (2.0*max(0.5 - uv.x, 0.0)) * (1.0 - (2.0 * abs(uv.y - 0.5)));\n    wr = wr / 2.0;\n    wl = wl / 2.0;\n    \n    // AB weights\n    float wb = (2.0*max(uv.y - 0.5, 0.0)) * (1.0 - (2.0 * abs(uv.x - 0.5)));\n    float wa = (2.0*max(0.5 - uv.y, 0.0)) * (1.0 - (2.0 * abs(uv.x - 0.5)));\n    wa = wa / 2.0;\n    wb = wb / 2.0;\n    \n    // corner weigts\n    float wtl = max(0.5 - uv.x, 0.0) * max(0.5 - uv.y, 0.0);\n    float wtr = max(uv.x - 0.5, 0.0) * max(0.5 - uv.y, 0.0);\n    float wbl = max(0.5 - uv.x, 0.0) * max(uv.y - 0.5, 0.0);\n    float wbr = max(uv.x - 0.5, 0.0) * max(uv.y - 0.5, 0.0);\n    wtl = wtl * 4.0;\n    wtr = wtr * 4.0;\n    wbl = wbl * 4.0;\n    wbr = wbr * 4.0;\n    \n    float cmid = getOctHarsh(octave, pos, att);\n    \n    float ctl = (getOctHarsh(octave, topleft, att) +\n        getOctHarsh(octave, above, att) +\n        getOctHarsh(octave, left, att) +\n        cmid) / 4.0;\n    float ctr = (getOctHarsh(octave, topright, att) +\n        getOctHarsh(octave, above, att) +\n        getOctHarsh(octave, right, att) +\n        cmid) / 4.0;\n    float cbl = (getOctHarsh(octave, bottomleft, att) +\n        getOctHarsh(octave, below, att) +\n        getOctHarsh(octave, left, att) +\n        cmid) / 4.0;\n    float cbr = (getOctHarsh(octave, bottomright, att) +\n        getOctHarsh(octave, below, att) +\n        getOctHarsh(octave, right, att) +\n        cmid) / 4.0;   \n    \n    return (1.0 - wl - wr - wa - wb - wtl - wtr - wbl - wbr) * cmid +\n        \twl * getOctHarsh(octave, left, att) +\n        \twr * getOctHarsh(octave, right, att) + \n        \twa * getOctHarsh(octave, above, att) + \n        \twb * getOctHarsh(octave, below, att) +\n        \twtl * ctl +\n            wtr * ctr +\n       \t\twbl * cbl +\n        \twbr * cbr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 green = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 blue = vec4(0.0, 0.0, 1.0, 1.0);\n    float noise = -0.42;\n   \n    for(int i = 3; i < iterations; i++){\n    \tnoise += getOct(float(i), fragCoord.xy, pow(0.76, float(i) - 1.0));\n    }\n    \n    noise *= intensity;\n    noise = pow(noise-0.1, 1.6);\n\tfragColor = vec4(noise, max(0.0, noise - 0.4), max(0.0, noise*2.0 - 1.5), 1.0);\n}","name":"Image","description":"","type":"image"}]}