{"ver":"0.1","info":{"id":"clXGzf","date":"1672111885","viewed":139,"name":"Ray-Tracing","username":"mattwilson720","description":"Simple ray-tracing scene with a few reflective surfaces. Click and drag to move the main light.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","reflection","phong","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Matthew K. Wilson\n\n#define PI 3.14159265\n#define MAX_RAYCASTS 5\n#define EPSILON 0.001\n\n// Structs ------------\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction; // normalized\n};\n\nstruct Material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float roughness;\n    float kLocal;\n    float kReflect;\n    float kTransmit;\n};\n\nstruct RayIntersect\n{\n    bool valid;\n    vec3 point;\n    vec3 normal;\n    Material material;\n};\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n    Material material;\n};\n\nstruct Plane\n{\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\nstruct Light\n{\n    vec3 position;\n    vec3 color;\n    float intensity;\n};\n// --------------------\n\n// Global Variables ---\n// Constants\nconst int NumberPlanes = 6;\nconst int NumberSpheres = 3;\nconst int NumberLights = 2;\n\n// Objects\nPlane planes[NumberPlanes];\nSphere spheres[NumberSpheres];\n\n// Define the camera in WCS\nvec3 camPosition = vec3(3,1,10);\nvec3 cameraLookAtPoint = vec3(0,0,0);\nvec3 cameraUp = vec3(0,1,0);\n\n// Lights\nvec3 ambientLight = vec3(0.2,0.2,0.2);\nLight mainLight;\nLight secondaryLight;\nLight lights[NumberLights];\n\n// --------------------\n\n// Calculates position of light based on position of cursor\nvec3 lightPositionToMouse(Light light, mat3 mouseTransform) {\n    return mouseTransform * vec3(iMouse.xy/iResolution.xy,1.0);\n}\n\n// Calculates light source fall-off (linear)\nfloat calculateLightIntensity(Light light, vec3 position) {\n    float distanceFromSource = length(light.position - position);\n    return light.intensity / (distanceFromSource); \n}\n\n// Calculates intersection point for sphere and ray L(t)\n//   returns t on intersection or t = -1.0 if not \nfloat raycastSphere(Ray ray, Sphere sphere) {\n\n    float r = sphere.radius;\n    vec3 p = sphere.position;\n    vec3 o = ray.origin;\n    vec3 d = ray.direction;\n    \n    float c = r*r - dot(o,o) + 2.0 * dot(o,p) - dot(p,p);\n    float b = -2.0 * (dot(o,d) - dot(p,d)); \n    float a = -1.0; \n    \n    float q = b*b - 4.0*a*c;\n    if(q < 0.0) {\n        return -1.0;\n    }\n    \n    q = sqrt(q);\n    \n    float t1 = (-b - q)/(2.0*a);\n    float t2 = (-b + q)/(2.0*a);\n    \n    return t1 < t2 ? t1 : t2;\n}\n\n// Calculates intersection point for plane and ray L(t)\n//   returns t on intersection or t = -1.0 if not \nfloat raycastPlane(Ray ray, Plane plane) { \n    float d = -dot(plane.position, plane.normal);\n    float denominator = dot(plane.normal,ray.direction);\n    // plane and ray are parallel\n    if (denominator == 0.0) {\n        return -1.0;\n    }\n    return -(dot(plane.normal,ray.origin) + d) / denominator;\n}\n\nRayIntersect raycast(Ray ray) {\n    vec3 intersectionPoint;\n    vec3 intersectionNormal;\n    Material material;\n    \n    // Find closest intersection\n    float t = -1.0;\n    bool hitSphere = false;\n    bool hitPlane = false;\n    \n    Sphere nearestSphere;\n    for(int i = 0; i < NumberSpheres; i++) {\n        float temp = raycastSphere(ray, spheres[i]);\n        if ((t == -1.0 || temp < t) && temp >= 0.0) {\n            t = temp;\n            nearestSphere = spheres[i];\n            hitSphere = true;\n        }\n    }\n    \n    if (hitSphere) {\n        intersectionPoint = ray.origin + ray.direction*t;\n        intersectionNormal = normalize(intersectionPoint - nearestSphere.position); \n        material = nearestSphere.material;\n    } else {\n        Plane nearestPlane;\n        \n        for(int i = 0; i < NumberPlanes; i++) {\n            float temp = raycastPlane(ray, planes[i]);\n            if ((t == -1.0 || temp < t) && temp >= 0.0) {\n                t = temp;\n                nearestPlane = planes[i];\n                hitPlane = true;\n            }\n        }\n        \n        if(hitPlane) {\n            intersectionPoint = ray.origin + ray.direction*t;\n            intersectionNormal = nearestPlane.normal;\n            material = nearestPlane.material;\n        }\n    }\n    \n    return RayIntersect(hitSphere || hitPlane, intersectionPoint, intersectionNormal, material);\n}\n\nbool raycastShadow(vec3 position, Light light) {\n    vec3 direction = normalize(light.position - position);\n    Ray shadowRay = Ray(position + direction * EPSILON, direction);\n    RayIntersect rayIntersect = raycast(shadowRay);\n    return !rayIntersect.valid || length(rayIntersect.point - position) < length(position - light.position);\n}\n\n// Blinn-Phong Lighting Model \nvec3 calculateBlinnPhongLighting(Material material, vec3 position, vec3 normal) {\n    vec3 color = ambientLight * material.ambient;\n    \n    for(int i = 0; i < NumberLights; i++) {\n        Light light = lights[i];\n\n        if (raycastShadow(position, light)) {\n            continue;\n        }\n\n        float lightIntensity = calculateLightIntensity(light, position);\n        vec3 lightColor = light.color * lightIntensity;\n        \n        vec3 L = normalize(light.position - position);\n        vec3 V = normalize(camPosition - position);\n        vec3 H = normalize(L+V);\n        \n        vec3 diffuse = lightColor * material.diffuse * max(dot(normal,L), 0.0);\n        vec3 specular = lightColor * material.specular * pow(max(dot(normal,H),0.0),1.0 / material.roughness); // pow(max(dot(R,V),0.0),material.shininess);\n        color += diffuse + specular;\n    }\n\n    return color;\n}\n\n// Iteratively trace reflection rays (does not handle transmission)\nvec3 iterativeRaytrace(Ray ray) {\n    RayIntersect[MAX_RAYCASTS] intersectionStack;\n    int counter = 0;\n    \n    RayIntersect rayIntersect = raycast(ray);\n    \n    while (rayIntersect.valid && counter < MAX_RAYCASTS) { \n        intersectionStack[counter] = rayIntersect;\n        \n        if (intersectionStack[counter].material.kReflect > 0.0) {\n            vec3 reflectionDirection = normalize(reflect(ray.direction, rayIntersect.normal));\n            // move the reflaction ray ahead by small amount so it doesn't intersect with itself\n            Ray reflectionRay = Ray(rayIntersect.point + reflectionDirection / 1000.0, reflectionDirection);\n            rayIntersect = raycast(reflectionRay);\n        } else {\n            // stop bouncing once a non-reflective material is reached\n            break;\n        }\n        \n        counter++;\n    }\n    \n    rayIntersect = intersectionStack[counter];\n    vec3 color = rayIntersect.material.kLocal * calculateBlinnPhongLighting(rayIntersect.material,rayIntersect.point,rayIntersect.normal);\n    \n    for(int i = counter - 1; i >= 0; i--) {\n        rayIntersect = intersectionStack[i];\n        Material material = rayIntersect.material;\n        vec3 localColor = calculateBlinnPhongLighting(material,rayIntersect.point,rayIntersect.normal);\n        vec3 reflectColor = color;\n        \n        color = material.kLocal * localColor + material.kReflect * reflectColor;\n    }\n\n    return color;\n}\n\n//vec3 raytrace(Ray ray) {\n    \n//    RayIntersect rayIntersect = raycast(ray);\n//    vec3 color = vec3(0.0,0.0,0.0);\n    \n//    if (rayIntersect.valid) {\n//        Material material = rayIntersect.material;\n//        vec3 localColor = calculateBlinnPhongLighting(material,rayIntersect.point,rayIntersect.normal);\n//        vec3 reflectColor = vec3(0.0,0.0,0.0);\n//        vec3 transmitColor = vec3(0.0,0.0,0.0);\n        \n//        if (material.kReflect > 0.0) {\n//            vec3 reflectionDirection = normalize(reflect(ray.direction, rayIntersect.normal));\n//            Ray reflectionRay = Ray(rayIntersect.point, reflectionDirection);\n//            reflectColor = raytrace(reflectionRay);\n//        }\n        \n//        if (material.kTransmit > 0.0) {\n//            Ray transmissionRay = Ray(rayIntersect.point, ray.direction);\n//            // TODO: handle refraction\n//            transmitColor = raytrace(transmissionRay);\n//        }\n        \n//        color = material.kLocal * localColor + material.kReflect * reflectColor + material.kTransmit * transmitColor;\n//    }\n\n//    return color;\n//}\n\n// Create ray in WCS\nRay createRay(vec2 uv)\n{\n    // Calculate camera/viewing matrix\n    vec3 k = normalize(camPosition - cameraLookAtPoint);\n    vec3 i = normalize(cross(cameraUp, k));\n    vec3 j = cross(k, i);\n    mat4 cameraMatrix = mat4(vec4(i,0.0), vec4(j,0.0), vec4(k,0.0), vec4(camPosition, 1.0));\n    mat4 viewMatrix = inverse(cameraMatrix);\n\n    // Define the view frustum\n    float aspect = 16.0/9.0;\n    float fov = 70.0;\n    float n = 2.0; \n    float f = 10.0; \n\n    float r = n * tan((fov*PI/180.0)/2.0);\n    float l = -r;\n\n    float b = l/aspect;\n    float t = r/aspect;\n    \n    // Unneeded, but keeping this here for future reference\n    mat4 projMatrix = mat4(\n        2.0*n/(r-l), 0.0, 0.0, 0.0,\n        0.0, 2.0*n/(t-b), 0.0, 0.0,\n        (r+l)/(r-l), (t+b)/(t-b), -(f+n)/(f-n), -1.0,\n        0.0, 0.0, -2.0*f*n/(f-n), 0.0);\n\n    float x = uv.x * (2.0*r) - r;\n    float y = uv.y * (2.0*t) - t;\n    float z = -n;\n    \n    // Convert ray from VCS to WCS\n    vec4 position = cameraMatrix * vec4(x,y,z,1.0);\n    vec3 direction = normalize(position.xyz - camPosition);  \n    return Ray(camPosition, direction);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Material planeMaterial1 = Material(vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.0,0.0), 1.0, 1.0, 0.0, 0.0);\n    Material planeMaterial2 = Material(vec3(0.5,0.5,0.5), vec3(0.77, 0.17, 0.17), vec3(0.0,0.0,0.0), 1.0, 1.0, 0.0, 0.0);\n    Material planeMaterial3 = Material(vec3(0.5,0.5,0.5), vec3(0.52, 0.88, 0.56), vec3(0.0,0.0,0.0), 1.0, 1.0, 0.0, 0.0);\n    Material planeMaterial4 = Material(vec3(0.5,0.5,0.5), vec3(1.0, 1.0, 1.0), vec3(1.0,1.0,1.0), 2.0, 0.0, 1.0, 0.0);\n    Material planeMaterial5 = Material(vec3(0.5,0.5,0.5), vec3(0.54, 0.30, 0.93), vec3(0.0,0.0,0.0), 1.0, 1.0, 0.0, 0.0);\n    Material sphereMaterial = Material(vec3(0.5,0.5,0.5), vec3(0.0, 0.888, 0.76), vec3(0.5,0.5,0.5), 0.02, 0.94, 0.06, 0.0);\n    Material sphereMaterial2 = Material(vec3(0.5,0.5,0.5), vec3(1.0, 1.0, 1.0), vec3(0.3,0.3,0.3), 0.1, 0.0, 1.0, 0.0);\n    Material sphereMaterial3 = Material(vec3(0.5,0.5,0.5), vec3(0.85, 0.23, 0.43), vec3(0.0,0.0,0.0), 5.0, 1.0, 0.0, 0.0);\n\n    Plane pFloor = Plane(vec3(0.0,-2.0,0.0), vec3(0.0,1.0,0.0), planeMaterial1);\n    Plane plWall = Plane(vec3(-5.0,-2.0,0.0), vec3(1.0,0.0,0.0), planeMaterial2); \n    Plane prWall = Plane(vec3(5.0,-2.0,0.0), vec3(-1.0,0.0,0.0), planeMaterial3); \n    Plane pbWall = Plane(vec3(0.0,-2.0,-5.0), vec3(0.0,0.0,1.0), planeMaterial4); \n    Plane pfWall = Plane(vec3(0.0,-2.0,12.0), vec3(0.0,0.0,-1.0), planeMaterial5); \n    Plane pCeiling = Plane(vec3(0.0,4.0,0.0), vec3(0.0,-1.0,0.0), planeMaterial1);\n    \n    Sphere sphere1 = Sphere(vec3(0.0,-1.0,0.0), 1.0, sphereMaterial);\n    Sphere sphere2 = Sphere(vec3(-2.0,0.0,4.0), 1.0, sphereMaterial2);\n    Sphere sphere3 = Sphere(vec3(3.0,1.5,4.0), 0.5, sphereMaterial3);\n\n    mainLight = Light(vec3(2.0,2.0,5.0),vec3(1.0,1.0,1.0), 2.0);\n    secondaryLight = Light(vec3(-2.0,1.5,-2.0),vec3(1.0,1.0,1.0), 2.0);\n    mainLight.position = lightPositionToMouse(mainLight, mat3(vec3(6.0,0.0,0.0), vec3(0.0,2.0,0.0), vec3(-3.0,0.0,6.0)));\n\n    lights = Light[](mainLight, secondaryLight);\n\n    planes = Plane[NumberPlanes](plWall, prWall, pbWall, pfWall, pFloor, pCeiling);\n    spheres = Sphere[NumberSpheres](sphere1, sphere2, sphere3);\n\n    Ray ray = createRay(fragCoord.xy / iResolution.xy);\n    vec3 color = iterativeRaytrace(ray);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}