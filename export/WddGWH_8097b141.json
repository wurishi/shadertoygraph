{"ver":"0.1","info":{"id":"WddGWH","date":"1568388514","viewed":119,"name":"manhattan transfer","username":"tristanwhitehill","description":"bike bike","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bike"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec2 hash( vec2 x ) \n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 3.0*sin( (iTime*.4)*130.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = ceil( p );\n\t\n\tvec2 u = f*f*(sin(iTime*.5)*5.-1.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat manhatanDistance(vec2 pointA, vec2 pointB)\n{\n    return abs(pointA.x - pointB.x) + abs(pointA.y - pointB.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \tvec2 uv = fragCoord.xy / iResolution.xy;\n    float n= (noise(uv));\n   float fm = sin(iTime*.5)*.5;\n   float fm2 = sin(iTime*.03)*fm*n;\n    //Define points used for partitioning the plane\n    vec2 points[10];\n    points[0] = vec2(0.048, 0.259-fm);\n\tpoints[1] = vec2(0.45+fm2, 0.233-fm2);\n\tpoints[2] = vec2(0.386-fm*n, 0.556-fm);\n\tpoints[3] = vec2(0.847, 0.868+fm);\n\tpoints[4] = vec2(0.437+fm, 0.718-fm2);\n\tpoints[5] = vec2(0.095+fm, 0.558);\n\tpoints[6] = vec2(0.513-fm2, 0.680-fm2);\n\tpoints[7] = vec2(0.013, 0.865-fm);\n\tpoints[8] = vec2(0.168+fm2*n, 0.653+fm2);\n\tpoints[9] = vec2(0.891-fm, 0.721+fm);\n    \n    \n    //Define the point colors\n    vec4 pointColors[10];\n    pointColors[0] = vec4(0.,0.,0.0, 1.0);\n\tpointColors[1] = vec4(255.,255.,255., 1.0);\n\tpointColors[2] = vec4(0.,0.,0.0, 1.0);\n\tpointColors[3] = vec4(255.,255.,255., 1.0);\n\tpointColors[4] = vec4(0.,0.,0.0, 1.0);  \n    pointColors[6] = vec4(255.,255.,255., 1.0);\n\tpointColors[5] = vec4(0.,0.,0.0, 1.0);\n\tpointColors[7] = vec4(255.,255.,255., 1.0);\n\tpointColors[8] = vec4(0.,0.,0.0, 1.0);\n\tpointColors[9] = vec4(255.,255.,255., 1.0);\n    \n    //Allow the image to be scaled\n\n    //Preserve aspect ratio\n    if(iResolution.x > iResolution.y)\n    {\n        uv.x = uv.x / iResolution.y * iResolution.x;\n        for(int i = 0; i < 10; i++)\n        {\n            points[i].x = points[i].x / iResolution.y * iResolution.x;\n        }\n    }\n    else\n    {\n        uv.y = uv.y / iResolution.x * iResolution.y;\n        for(int i = 0; i < 10; i++)\n        {\n            points[i].y = points[i].y / iResolution.x * iResolution.y;\n        }\n    }\n    \n    //Find the point closest to the pixel that is beeing colored now\n    float minDistance = manhatanDistance(uv, points[0]);\n    fragColor = pointColors[0];\n    for(int i = 1; i < 10; i++)\n    {\n        float currentDistance = manhatanDistance(uv, points[i]);\n        if(currentDistance < minDistance)\n        {\n            minDistance = currentDistance;\n            fragColor = pointColors[i];\n        }\n    }\n    \n    //Color the points\n    if(minDistance < 0.0005)\n    {\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}