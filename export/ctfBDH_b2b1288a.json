{"ver":"0.1","info":{"id":"ctfBDH","date":"1692850321","viewed":83,"name":"DDA Visualization","username":"cesor","description":"a visualization of dda algorithm.\n\nseveral implementation of drawing a line segment.\nu can see how different methods work by changing the value of METHOD(from 1 to 3, now).","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["dda","algorithm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tDDA Algorithm - https://www.geeksforgeeks.org/dda-line-generation-algorithm-computer-graphics/\n\tDDA Algorithm - https://lodev.org/cgtutor/raycasting.html#Untextured_Raycaster_\n\tDistance Estimation - https://iquilezles.org/articles/distance/\n\t2D SDF - https://iquilezles.org/articles/distfunctions2d/\n*/\n#define METHOD 2\nfloat border(vec2 p, float d)\n{\n\tvec2 minp = floor(p);\n\tvec2 maxp = ceil(p);\n\tvec2 cp = minp + (maxp-minp)*.5;\n\t//float d = .1;\n\t/*\n\t\tsame as:\n\t\t\tfloat b = smoothstep(minp.x-d,minp.x+d, p.x);\n\t\t\tb *= smoothstep(maxp.x+d,maxp.x-d, p.x);\n\t\t\tb *= smoothstep(minp.y-d,minp.y+d, p.y);\n\t\t\tb *= smoothstep(maxp.y+d,maxp.y-d, p.y);\n\t*/\n\tvec2 bs = smoothstep(minp-d,minp+d,p) * smoothstep(maxp+d,maxp-d,p);\n\treturn bs.x*bs.y;\n}\n\n// each voxel's origin in left-down.\nfloat isInVoxel(vec2 p, ivec2 pix)\n{\n\t//if (ivec2(round(p))==pix)\n#if METHOD == 1\n\tif (ivec2(ceil(p))==pix)\n#else\n\tif (ivec2(floor(p))==pix)\n#endif\n\t\treturn 1.;\n\treturn 0.;\n}\n\n// method 1 - DDA https://www.geeksforgeeks.org/dda-line-generation-algorithm-computer-graphics/\nfloat mapDDA(vec2 p, vec2 start, vec2 end)\n{\n\tvec2 delta = end-start;\n\tfloat steps = max(abs(delta.x), abs(delta.y));\n\tvec2 inc = delta/steps;\n\t\n\tvec2 cur = start;\n\tfor(int i=0; i<=int(round(steps)); i++)\n\t{\n\t\tvec2 gp = round(cur);\n\t\tif(isInVoxel(p, ivec2(gp))>0.)\n\t\t\treturn 1.;\n\t\tcur += inc;\n\t}\n\t\n\t// compensation of the end point.\n\t// if(isInVoxel(p, ivec2(floor(end)))>0.)\n\t\t//return 1.;\n\treturn 0.;\n}\n\n// method 2 - DDA https://lodev.org/cgtutor/raycasting.html#Untextured_Raycaster_\nfloat mapDDA2(vec2 p, vec2 start, vec2 end)\n{\n\tvec2 sp = start;\n\tivec2 vp = ivec2(floor(sp));\n\n\tvec2 offset = end-start;\n\tvec2 rayDir = normalize(offset);\n\tfloat maxDist = length(offset);\n\n\t// float deltaDistX = abs(1./rayDir.x);\n\t// float deltaDistY = abs(1./rayDir.y);\n\n\t// int stepX = 0;\n\t// float sideDistX = 0.;\n\t// if (rayDir.x < 0.)\n\t// {\n\t//     stepX = -1;\n\t//     sideDistX = (sp.x-float(vp.x))*deltaDistX;\n\t// }\n\t// else\n\t// {\n\t//     stepX = 1;\n\t//     sideDistX = (float(vp.x)+1.-sp.x)*deltaDistX;\n\t// }\n\t\n\t// int stepY = 0;\n\t// float sideDistY = 0.;\n\t// if(rayDir.y < 0.)\n\t// {\n\t//     stepY = -1;\n\t//     sideDistY = (sp.y-float(vp.y))*deltaDistY;\n\t// }\n\t// else\n\t// {\n\t//     stepY = 1;\n\t//     sideDistY = (float(vp.y)+1.-sp.y)*deltaDistY;\n\t// }\n\t\n\n\t// for(int i=0; i<128; i++)\n\t// {\n\t//     if(sideDistX>=maxDist && sideDistY>=maxDist)\n\t//     {\n\t//         if(isInVoxel(p,vp) > 0.)\n\t//             return 1.;\n\t//         break;\n\t//     }\n\n\t//     if(isInVoxel(p,vp) > 0.)\n\t//         return 1.;\n\t//     if(sideDistX < sideDistY)\n\t//     {\n\t//         sideDistX += deltaDistX;\n\t//         vp.x += stepX;\n\t//     }\n\t//     else\n\t//     {\n\t//         sideDistY += deltaDistY;\n\t//         vp.y += stepY;\n\t//     }\n\t// }\n\n\t/*\n\t\tstep(0., x) = x < 0 ? 0: 1\n\n\t\tstepXo = step(0., rayDir.x)\n\t\tstepX = stepXo * 2. - 1. // convert [0,1] to [-1,1]\n\t\tstepX * sideDistX = (float(vp.x) - sp.x + stepXo ) * deltaDistX\n\t\tsideDistX = ( (float(vp.x) - sp.x + stepXo) / stepX ) * deltaDistX\n\t*/\n\tvec2 deltaDist = 1./abs(rayDir);\n\n\tvec2 stepo = step(0., rayDir);\n\tvec2 steps = stepo * 2. - 1.;\n\tvec2 sideDist = (vec2(vp) - sp + stepo) * (deltaDist/steps);\n\n\tfor(int i=0; i<128; i++)\n\t{\n\t\tif(sideDist.x>=maxDist && sideDist.y>=maxDist)\n\t\t{\n\t\t\tif(isInVoxel(p,vp) > 0.)\n\t\t\t\treturn 1.;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(isInVoxel(p,vp) > 0.)\n\t\t\treturn 1.;\n\n\t\tfloat m = step(sideDist.y, sideDist.x);\n\t\tvec2 mm = vec2(1.-m, m);\n\t\tsideDist += deltaDist * mm;\n\t\tvp += ivec2(steps * mm);\n\t}\n\t\n\treturn 0.;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdfSegment(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat len = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n\treturn length(pa-len*ba);\n}\nfloat crosszofvec2(vec2 p, vec2 a, vec2 b)\n{\n\treturn normalize(cross(vec3(p-a,0.), vec3(b-a,0.))).z;\n}\n\n// method 3 - sdf\nfloat mapSDF(vec2 p, vec2 start, vec2 end)\n{ \n\t/*\n\tfloat fe = 1.4142;\n\tfloat e = .7071;\n\tvec2 t = vec2(1., 0.);\n\tvec2 vp = floor(p);\n\tvec2 vp0 = vp+t.yy;\n\tvec2 vp1 = vp+t.xy;\n\tvec2 vp2 = vp+t.yx;\n\tvec2 vp3 = vp+t.xx;\n\t\n\t//float sd0 = sdfSegment(vp0, start, end);\n\t//if (sd0 > fe) return 0.;\n\t//float sd1 = sdfSegment(vp1, start, end);\n\t//if (sd1 > fe) return 0.;\n\t//float sd2 = sdfSegment(vp2, start, end);\n\t//if (sd2 > fe) return 0.;\n\t//float sd3 = sdfSegment(vp3, start, end);\n\t//if (sd3 > fe) return 0.;\n\n\t//if( step(sd0,e) > 0. ||\n\t//  step(sd1,e) > 0. ||\n\t//  step(sd2,e) > 0. ||\n\t//  step(sd3,e) > 0.)\n\t//{\n\t//  float c0 = crosszofvec2(vp0, start, end);\n\t//  float c1 = crosszofvec2(vp1, start, end);\n\t//  if((c0>=0. && c1>=0.) || (c0<=0. && c1<=0.))\n\t//  {\n\t//      float c2 = crosszofvec2(vp2, start, end);\n\t//      if((c0>=0. && c2>=0.) || (c0<=0. && c2<=0.))\n\t//      {\n\t//          float c3 = crosszofvec2(vp3, start, end);\n\t//          if((c0>=0. && c3>=0.) || (c0<=0. && c3<=0.))\n\t//              return 0.;\n\t//          else\n\t//              return 1.;\n\t//      } else return 1.;\n\t//  } else return 1.;\n\t//}\n\n\tfloat sd =  step(sdfSegment(vp0, start, end),e) +\n\t\t\t\tstep(sdfSegment(vp1, start, end),e) +\n\t\t\t\tstep(sdfSegment(vp2, start, end),e) +\n\t\t\t\tstep(sdfSegment(vp3, start, end),e);\n\n\t// if voxel doesnt intersect with segment, all of its verts must be on the same side of the segment.\n\tfloat cc =  crosszofvec2(vp0, start, end) + \n\t\t\t\tcrosszofvec2(vp1, start, end) + \n\t\t\t\tcrosszofvec2(vp2, start, end) + \n\t\t\t\tcrosszofvec2(vp3, start, end);\n\treturn min(sd * abs(abs(cc)-4.), 1.);\n\t*/\n\n\t\n\t/*\n\t\twhen the segment slope is close to the diagonal of the map,\n\t\t\tselect half of the diagonal of the voxel as the SDF threshold(max).\n\t\totherwise\n\t\t\tselect half of the side of the voxel as the SDF threshold(min).\n\t*/\n\tfloat angle = atan((end.y-start.y),(end.x-start.x));\n\tfloat s = (sin(4.*angle-1.57)+1.)*.5;\n\tfloat e = mix(.5, .7071, s);\n\tvec2 mvp = floor(p)+.5;\n\tfloat sd = sdfSegment(mvp, start, end);\n\treturn step(sd, e);\n}\n\n\nfloat mapPoint(vec2 p, vec2 pp)\n{\n\tfloat t = 1.-length(p-pp);\n\treturn smoothstep(.01,.015,t-.7);\n}\n\n// distance field of line\nfloat f(vec2 p, vec2 start, vec2 end)\n{\n\tfloat x0 = start.x;\n\tfloat x1 = end.x;\n\tfloat y0 = start.y;\n\tfloat y1 = end.y;\n\tfloat k = (y1-y0)/(x1-x0);\n\tfloat y = k*(p.x-x0) + y0;\n\treturn y-p.y;\n}\nfloat df(vec2 p, vec2 start, vec2 end)\n{\n\tvec2 kk = end - start;\n\tfloat k = kk.y / kk.x;\n\treturn length(vec2(k, -1));\n}\nvec2 grad(vec2 p, vec2 start, vec2 end)\n{\n\tvec2 h = vec2(.01, .0);\n\treturn vec2( f(p+h.xy, start, end) - f(p-h.xy, start, end),\n\t\t\t\t f(p+h.yx, start, end) - f(p-h.yx, start ,end) ) / (2.*h.x);\n}\n\n// https://www.shadertoy.com/view/XstfzB\nvec2 path(float z)\n{\n\treturn vec2(\n\t\t\tsin(z * 0.1) + sin(cos(z * 0.031) * 4.0) + sin(sin(z * 0.0091) * 3.0) * 3.0,\n\t\t\tcos(z * 0.1) + cos(cos(z * 0.031) * 4.0) + cos(sin(z * 0.0091) * 3.0) * 3.0\n\t\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec2 mo = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n\tvec2 start = vec2(1.1, 3.6);\n\t//vec2 end = vec2(-4.5*cos(iTime), -5.1*sin(iTime));\n\tvec2 end = path(iTime*3.5) * 5.;\n\t//if(iMouse.w>.01)\n\t\t//start = mo;\n\tif(iMouse.z>.01)\n\t\tend = mo * 50.;\n\t\n\t\n\tfloat sc = max(length(end),length(start));\n\tp *= sc;\n\tmo *= sc;\n\t\n\tfloat b = border(p, mix(.01, 1., sc/80.));\n#if METHOD == 1\n\tfloat voxel = mapDDA(p, start, end);\n#elif METHOD == 2\n\tfloat voxel = mapDDA2(p, start, end);\n#else\n\tfloat voxel = mapSDF(p, start, end);\n#endif\n\tfloat op = mapPoint(p, vec2(0.));\n\tfloat mp = mapPoint(p, start) + mapPoint(p, end); // origin, start, end\n\tfloat pp = (1.-mp) * op + mp;\n\t\n\t// bottom layer is the grid\n\tfloat vm = voxel * (1.-pp); // second layer is voxel\n\tfloat om = op; // top layer is point(origin)\n\tfloat mm = mp; // top layer is point(start & end)\n\tfloat vmm = vm + pp;\n\tfloat gm = b;\n\t\n\tvec3 mmcol = mp*vec3(0.,1.,0.) + op*vec3(0.,0.,1.);\n\tvec3 vmcol = vm*vec3(1.,0.,0.) + mmcol;\n\tvec3 col = vmcol*vmm + vec3(b)*(1.-vmm);\n\n\t// distance estimation\n\tfloat dx = abs(f(p,start,end))/abs(df(p,start,end));\n\t//float dx = abs(f(p,start,end))/length(grad(p,start,end));\n\tfloat line = smoothstep(.1,.0,dx);\n\t\n\tcol = (1.-line)*col + line*0.;\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}