{"ver":"0.1","info":{"id":"4ltSz2","date":"1482462322","viewed":3102,"name":"SSAO Test","username":"Crow","description":"references: UnityEngine Screen Space Ambient Occlusion\n               http://www.gamedev.net/page/resources/_/technical/graphics-programming-and-theory/a-simple-and-practical-approach-to-ssao-r2753\n               https://www.shadertoy.com/view/Ms23Wm\n\n","likes":16,"published":1,"flags":32,"usePreview":1,"tags":["ssao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COUNT 16\n#define FARCLIP 10.0\n#define BIAS 0.3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv = fragCoord.xy / iResolution.xy;    \n\n    vec4 norz = texture(iChannel0, uv);\n    float depth = norz.w * FARCLIP;\n    float radius = 0.1;\n    float scale = radius / depth;\n    \n    float ao = 0.0;\n    for(int i = 0; i < COUNT; i++)\n    {\n        vec2 randUv = (fragCoord.xy + 23.71 * float(i)) / iChannelResolution[1].xy;\n        vec3 randNor = texture(iChannel1, randUv).xyz * 2.0 - 1.0;\n        if(dot(norz.xyz, randNor) < 0.0)\n            randNor *= -1.0;\n        \n        vec2 off = randNor.xy * scale;\n        vec4 sampleNorz = texture(iChannel0, uv + off);\n        float depthDelta = depth - sampleNorz.w * FARCLIP;\n        \n        vec3 sampleDir = vec3(randNor.xy * radius, depthDelta);        \n        float occ = max(0.0, dot(normalize(norz.xyz), normalize(sampleDir)) - BIAS) / (length(sampleDir) + 1.0);\n        ao += 1.0 - occ;\n    }    \n    ao /= float(COUNT);\n    \n    fragColor = vec4(vec3(ao), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FARCLIP 10.0\n\nfloat SdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat SdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat SdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\nfloat SdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat OpU( float d1, float d2 )\n{\n\treturn min(d1, d2);\n}\n\nfloat OpS( float d1, float d2 )\n{\n    return max(-d2, d1);\n}\n\nfloat Map( vec3 pos )\n{\n    float res = SdPlane(pos);    \n    res = OpU( res, SdCylinder(pos - vec3(0, 0.1, 0), vec2(0.65, 0.06)));\n    res = OpU( res, SdSphere(pos - vec3(0, 1.15, 0), 0.75));\n    \n    res = OpU( res, OpS(SdBox(pos - vec3(0, 0.06, 0), vec3(0.8, 0.06, 0.8)),   \n                        SdCylinder(pos - vec3(0, 0.1, 0), vec2(0.66, 0.065))));\n    \n    res = OpU( res, OpS(SdSphere(pos - vec3(0, 1.15, 0), 1.0), \n                        OpU(SdSphere(pos - vec3(0, 1.15, 0), 0.77), \n                            SdSphere(pos - vec3(0.7, 1.6, 0.7), 0.7))));\n                        \n    return res;\n}\n\nfloat CastRay( vec3 camPos, vec3 rayDir )\n{\n    float nearClip = 0.1;\n    \n    float dis = nearClip;\n    for(int i = 0; i < 50; i++)\n    {\n\t    float res = Map(camPos + rayDir * dis);\n        if(res < 0.001) \n            break;\n        \n        dis += res;\n        if(dis > FARCLIP)\n        {\n            dis = -1.0;\n            break;\n        }\n    }\n    \n    return dis;\n}\n\n//---render-------------------------------------------------\nvec3 GetNormal( vec3 pos )\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(Map(pos + eps.xyy) - Map(pos - eps.xyy),\n                    Map(pos + eps.yxy) - Map(pos - eps.yxy),\n                    Map(pos + eps.yyx) - Map(pos - eps.yyx));\n\treturn normalize(nor); \n}\n\nvec4 Render( vec3 camPos, vec3 localViewDir, mat3 cam2worldMatrix )\n{\n    vec4 col;    \n    vec3 pos = camPos;\n    vec3 rayDir = cam2worldMatrix * localViewDir;\n    \n    float dis = CastRay(pos, rayDir);\n    if(dis > 0.0)\n    {\n        pos += rayDir * dis;\n\n        vec3 nor = GetNormal(pos);\n        nor = inverse(cam2worldMatrix) * nor;\n        nor.z *= -1.0;\n\n        float zDelta = localViewDir.z;\n        zDelta *= dis / FARCLIP;\n        \n        col = vec4(nor, zDelta);\n    }\n    else\n    {\n        col = vec4(vec3(0.0), 1.0);\n    }\n    \n    return col;\n}\n//--------------------------------------------------------\n\nmat3 SetCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec3 camPos = vec3(3.0 * cos(7.0 * mouse.x), 1.0 + 2.0 * mouse.y, 3.0 * sin(7.0 * mouse.x));\n    vec3 camLookAt = vec3(0.0, 1.0, 0.0);\n    \n    mat3 cam2worldMatrix = SetCamera(camPos, camLookAt, 0.0);\n    \n    vec3 localViewDir = normalize(vec3(p.xy, 1.5));\n    \n    fragColor = Render(camPos, localViewDir, cam2worldMatrix);\n}","name":"Buffer A","description":"","type":"buffer"}]}