{"ver":"0.1","info":{"id":"MfK3zW","date":"1715967702","viewed":49,"name":"Sphere SDF + raymarcing","username":"Akuto","description":"SDF + lighting","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//SDF sphere\nfloat sdSphere(in vec3 p, float rad)\n{\n    // return 0 if the point is on the surface of the sphere\n    // return positive result if the point is outside the sphere\n    // return negative result if the point is inside the sphere\n    return length(p) - rad;\n}\n\n//SDF box\nfloat sdBox( vec3 p, vec3 b )\n{\n  // return 0 if the point is on the surface of the box\n  // return positive result if the point is outside the box\n  // return negative result if the point is inside the box\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// map is our global SDF, combination of every SDFs\n// If the distance is negative, it mean we are inside the surface but if\n// it's positive, it mean we are outside the surface\nfloat map(in vec3 pos)\n{\n    float sphereRad = .8f;\n    float sphere = sdSphere(pos, sphereRad);\n\n    float groundHeigth = -0.8;\n    float ground = pos.y - groundHeigth;\n    \n    return min(sphere, ground); // Get the closest object\n}\n\n// Get the gradient which is actually the normal of the circle\nvec3 calcNormal( in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(pos+e.xyy) - map(pos-e.xyy),\n                        map(pos+e.yxy) - map(pos-e.yxy),\n                        map(pos+e.yyx) - map(pos-e.yyx)));\n    \n}\n\n//Raymarching, allow us to render the implicite surface define by the global SDF map()\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    float t = 0.0; // Total distance\n    for(int i=0; i<100; i++)\n    {\n        vec3 pos = ro + t*rd;\n        \n        // map is the every sdf and the ground combine\n        float h = map(pos); // get the closest distance from the global sdf\n        // If the distance is negative, it mean we are inside the circle but if\n        // it's positive, it mean we are outside the circle\n        if(h<0.001)\n            break;\n        t += h;\n        if(t>20.0) break;\n    }\n    \n    if( t>20.0 ) t=-1.0;\n    \n    return t;\n}\n\n//Fonction called for each pixel\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n\n    float an = 10.0*iMouse.x/iResolution.x;\n    \n    \n    //lenght from the target and the camera\n    float cameraLength = 3.0;\n    \n    \n    //Place de camera on the zaxis\n    vec3 ta = vec3(0.0, 0.0, 0.0); // target of the camera\n    vec3 rayOrigin = ta + vec3(cameraLength*sin(an), 0.0, cameraLength*cos(an));//Ray origine\n\n    \n    vec3 ww = normalize(ta-rayOrigin);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu,ww));\n    \n    float lenghtViewCone = 1.5; //lenght of the view cone of the camera\n    vec3 rayDir = normalize(p.x*uu + p.y*vv + lenghtViewCone*ww);\n\n\n    vec3 col = vec3(0.65, 0.75, 0.9) - 0.8*rayDir.y; // Sky color\n    \n    float t = castRay(rayOrigin, rayDir); // Total distance\n    \n    \n    if(t>0.0)\n    {\n        vec3 pos = rayOrigin + t*rayDir;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2));\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float sun_sha = step(castRay(pos+nor*0.001, sun_dir), 0.0);\n        float sky_dif = clamp( 0.5 + 0.5*dot(nor,vec3(0.0, 1.0, 0.0)), 0.0, 1.0 );\n        float bou_dif = clamp( 0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0 );\n        \n        col  = mate * vec3(7.0,5.0,3.0)*sun_dif*sun_sha;\n        col += mate * vec3(0.5, 0.8, 0.9)*sky_dif;\n        col += mate * vec3(0.7, 0.3, 0.2)*bou_dif;\n    }\n    \n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}