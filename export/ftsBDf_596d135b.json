{"ver":"0.1","info":{"id":"ftsBDf","date":"1659931943","viewed":69,"name":"VolumetricRockByCrystalGrains","username":"thekingofways","description":"Attempt at a volumetric shader to capture real-world rocks.\nCurrently granite. Working on more types and general geometry.\nCrystal grains are defined by Voronoi regions on a randomly perturbed 3D grid, which are then \"biased\" by mineral.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","rocks","physicallybased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Real rocks have distinctive texture based on the crystal or sediment grains that compose them. This is an attempt to make a volumetric shader\n// that determines material properties based on these grains.\n//\n// The approach starts with an evenly-spaced 3D grid. This grid is perturbed with noise to create the centers of the crystal grains.\n//\n// The initial grains are then defined as Voronoi regions, e.g. each grain containing all points closest to its center than other centers.\n//\n// Starting with a grid like this leads to noticeable artifacting at finer grain sizes, but allows easy bucketing for determing the closest center.\n//     (using a uniform random sample and caching buckets would probably fix this artifacting).\n//\n// Grains are then randomly assigned a mineral, based on noise.\n//     I added support for considering a periodic function too, for sediment layers, but was not happy with the results.\n//\n// These minerals define the color/specularity/etc., but also define a \"bias tensor\" that weights the distance function to get different sizes.\n//     By being a tensor, this can also specify direction biases, to create minerals that are long or flat in certain directions.\n//         This lengthening effect is visible in the black grains in the granite.\n//     This approach does have several limitations.\n//         Having no limit on matrix magnitude can violate the assumption used for the bucketing, and lead to right angle corners to larger grains.\n//         Smaller grains can be trapped inside larger grains (see the white circles inside the larger pink grains).\n//         Since Voronoi regions are defined by distance, weighting it like this leads to slightly elliptical edges between regions.\n//         The uniform sampling limits the difference in grain sizes. This is alright in random rocks like granite, but\n//             for layered rocks, a denser grid would be desireable for the smaller-grained layers.\n//         These might be fixable if larger grains \"pushed\" the sampled points nearby them before assigning regions - then no bias is necessary\n// \n// The voronoi regions defined by these grains have dividing surfaces that are used to define the \"facets\" of the grains by defining normals.\n//     These normals are optionally interpolated with the overall surface normal (to make them stand out less) and a normal relative to the\n//         center of the grain (to round out individual grains).\n//     Selecting only \"external\" facets (the color of facets should be defined by the material inside the sphere, and not outside) is non-trivial.\n//\n// The actual shader currently operates via ray-tracing the sphere, then ray-marching slightly to find the actual facet. This should be transferrable\n// to normal pixel shaders by getting a world position (by interpolating vertex coordinates) and knowing the camera ray.\n//\n// The sphere has a polished look at the moment - while alright for statues/carvings/counters/etc, if this were used for environments\n// some noise and weathering to the colors would need to be applied. Ideally this would be variable so that side- and freshly-exposed- \n// surfaces were cleaner.\n//\n// Optimization is VERY possible, primarily by caching grains to avoid noise calls. Currently cost should be relatively invariant with grain size,\n// though caching would require more memory for smaller grains. Lots of conditionals that could be removed.\n\n//###############################################################################\n//Noise from https://www.shadertoy.com/view/Xt23Ry\n//###############################################################################\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvec2 randVec2(vec2 seed) { return vec2(rand(seed.y), rand(seed.x)); }\nvec3 randVec3(vec3 seed) { return vec3(rand(seed.xy), rand(seed.yx), rand(seed.xz)); }\n\n//Some window parameters\nfloat x_res = 1.0f;\nfloat y_res = 1.0f;\nfloat aspect_ratio = 1.0f;\n    \nbool inited = false;\n\n\n//Defining the camera and sphere for now.\n#define CAM_DIST -2.0f\nfloat camera_dist = CAM_DIST;\nvec3 camera_pos = vec3(0.0, 10.0, CAM_DIST);\nvec3 sphere_pos = vec3(0.0, 10.0, 1.0);\nfloat sphere_rad = .5;\n\n//###############################################################################\n//###############################################################################\n//  Material Definitions\n//###############################################################################\n//\n// A list of different rocks and test rocks follows. GRANITE is by far the\n// best, though SANDSTONE is also alright. MARBLE, TRAVERTINE, and GABBRO are \n// also options.\n//\n//###############################################################################\n//###############################################################################\n\n\n#define GRANITE\n\n//###############################################################################\n#ifdef TEST_MATERIAL\n//How many cells to divide the world into. Currently only uses DIVISION_SPACING, smaller values give smaller grains.\n#define DIVISIONS 50\n#define DIVISION_SPACING 0.03\n#define NUM_MATS 3\n\n//Covariance or stress/strain tensor type matrix for specifying mineral grain size and direction preference.\n//Should be symmetrical. The diagonal will weight grain size along world axes. Off diagonals specify a line\n//that it will weight on (0 diagonal and 1 off-diagonal should bias it along the line going in +x/+y/+z).\n//\n//I think technically right now this should be the inverse - easier to think about like this though, so I'll just cache the inverse?\n//\n//A diagonal of 1 will just use the distance to the cell center as it's distance, while a diagonal of 2 .1 .1 will be long in X but\n//short in Y and Z for instance. A diagonal of 3 3 3 would be ~3 times bigger (points would be weighted 3x closer to it for the purposes of finding which cell it is in).\n//\n//I think the weight will then be length(MAT^-1 * (world_pos - cell_center))\nmat3 materialCellSizeBias[NUM_MATS] = mat3[NUM_MATS](mat3(.3,.85,.85,\n                                                          .85,.3,.85,\n                                                          .85,.85,.3), \n                                                     mat3(1,0,0,\n                                                          0,1,0,\n                                                          0,0,1),\n                                                     mat3(1.8,0,0,\n                                                          0,.25,0,\n                                                          0,0,.25)\n                                                    );\n//Percentage by which the cell size bias can vary (uniformly atm)\nfloat materialCellSizeBiasVariance[NUM_MATS] = float[NUM_MATS](0.0f, 0.4f, .2f);\n//Defines material weights. Should always end in 1, relative random weight is gap size between previous number (or 0 if the first number).\nfloat materialWeights[NUM_MATS] = float[NUM_MATS](.4f,.6f,1.0f);\nvec3  materialBaseColor[NUM_MATS]   = vec3[NUM_MATS](vec3(.4, 0, 0), vec3(0.5, 0.5, .9), vec3(0.2,0.6,0.2));\nvec3  materialRandomColor[NUM_MATS] = vec3[NUM_MATS](vec3(.1, .1, .1), vec3(.3, .3, .1), vec3(0.2,0.1,0.2));\nfloat materialSpecularity[NUM_MATS] = float[NUM_MATS](0.4,3.0,1.5f);\nfloat    materialShininess[NUM_MATS] = float[NUM_MATS](4.0f,128.0f,32.0f);\n//Interpolates between individual facet normals and grain-wide normals\nfloat interpolate_grains = 0.5;\n//Interpolates to sphere instead of grain normal\nbool interpolate_to_sphere = false;\n//Less than 1, currently ratio of grain sphere size to overall sphere size\nfloat grain_roundness[NUM_MATS] = float[NUM_MATS](0.8, .97, .97);\n//How much to interpolate the roundness, must add to <1 with interpolate_grains\nfloat interpolate_roundness[NUM_MATS] = float[NUM_MATS](0.2, 0.0, 0.0);\n\n//How big (in world coordinates) layers are. Ignored if layer_weight is 0.\nfloat layer_scale = 100000.0f;\n//direction layers stack in\nvec3 layer_direction = normalize(-.2,.8,0);\n//Frequency (in each dimension) for noise input\nvec3 gradient_noise_frequency = vec3(1.0,1.0,1.0);\n//Following three weights determine weighting of material lookup. Technically can add to more than 1, but will wrap if so.\n//How far in the material lookup table it can skip ahead from gradient noise\nfloat gradient_noise_weight = 0.2;\n//How much to weight static noise for skipping ahead in lookup table\nfloat static_noise_weight   = 0.8;\n//How much to weight movement through the layers (0 if no layers).\nfloat layer_weight = 0.0;\n#endif\n//###############################################################################\n#ifdef TEST_MAT_SIMPLE\n#define DIVISION_SPACING 0.08\n#define NUM_MATS 1\n\nmat3 materialCellSizeBias[NUM_MATS] = mat3[NUM_MATS](mat3(1,0,0,\n                                                          0,1,0,\n                                                          0,0,1)\n                                                    );\nfloat materialCellSizeBiasVariance[NUM_MATS] = float[NUM_MATS](0.4f);\nfloat materialWeights[NUM_MATS] = float[NUM_MATS](1.0f);\nvec3  materialBaseColor[NUM_MATS]   = vec3[NUM_MATS](vec3(.5, .5, .5));\nvec3  materialRandomColor[NUM_MATS] = vec3[NUM_MATS](vec3(.1, .1, .1));\nfloat materialSpecularity[NUM_MATS] = float[NUM_MATS](3.0);\nfloat    materialShininess[NUM_MATS] = float[NUM_MATS](16.0);\nfloat interpolate_grains = 0.4;\nbool interpolate_to_sphere = false;\nfloat grain_roundness[NUM_MATS] = float[NUM_MATS](0.92);\nfloat interpolate_roundness[NUM_MATS] = float[NUM_MATS](0.4);\n#endif\n//###############################################################################\n#ifdef GRANITE\n#define DIVISION_SPACING 0.008\n#define NUM_MATS 3\n\nmat3 materialCellSizeBias[NUM_MATS] = mat3[NUM_MATS](mat3(3.0,-1.0,.0,\n                                                          -1.0,3.0,.0,\n                                                          .0,.0,2.5), \n                                                     mat3(.1,.7,0,\n                                                          .7,.7,0,\n                                                          0,0,.7),\n                                                     mat3(1.0,0,0,\n                                                          0,1.0,0,\n                                                          0,0,1.0)\n                                                    );\nfloat materialCellSizeBiasVariance[NUM_MATS] = float[NUM_MATS](0.0f, 0.4f, 0.2f);\nfloat materialWeights[NUM_MATS] = float[NUM_MATS](.04f,.4f,1.0f);\n//float materialWeights[NUM_MATS] = float[NUM_MATS](.003f,0.98f,1.0f);\nvec3  materialBaseColor[NUM_MATS]   = vec3[NUM_MATS](vec3(1.0, 0.6, 0.6), vec3(0.15, 0.15, .15), vec3(0.83,0.8,0.8));\nvec3  materialRandomColor[NUM_MATS] = vec3[NUM_MATS](vec3(.2, .1, .1), vec3(.02, .02, .02), vec3(0.2,0.1,0.2));\nfloat materialSpecularity[NUM_MATS] = float[NUM_MATS](6.0,200.0,3.0f);\nfloat    materialShininess[NUM_MATS] = float[NUM_MATS](64.0f,128.0f,16.0f);\nfloat interpolate_grains = 0.65;\nbool interpolate_to_sphere = true;\nfloat grain_roundness[NUM_MATS] = float[NUM_MATS](0.0, 0.1, 0.85);\nfloat interpolate_roundness[NUM_MATS] = float[NUM_MATS](0.0,0.1,0.35);\n\n//float layer_scale = 0.2f;\n//vec3 layer_direction = normalize(vec3(-.2,.8,0.0));\n//vec3 gradient_noise_frequency = vec3(20.0);\n//float gradient_noise_weight = 1.75;\n//float static_noise_weight   = 0.5;\n//float layer_weight         = 1.0;\n\nfloat layer_scale = 100.0f;\nvec3 layer_direction = normalize(vec3(-.2,.8,0.0));\nvec3 gradient_noise_frequency = vec3(00.0);\nfloat gradient_noise_weight = 0.0;\nfloat static_noise_weight   = 1.0;\nfloat layer_weight         = 0.0;\n#endif\n//###############################################################################\n#ifdef GABBRO\n#define DIVISION_SPACING 0.01\n#define NUM_MATS 3\n\nmat3 materialCellSizeBias[NUM_MATS] = mat3[NUM_MATS](mat3(1.5,3.5,.0,\n                                                          3.5,1.5,.0,\n                                                          .0,.0,1.5), \n                                                     mat3(.6,3.1,0,\n                                                          3.1,3.1,0,\n                                                          0,0,3.1),\n                                                     mat3(2.0,0,0,\n                                                          0,2.0,0,\n                                                          0,0,2.0)\n                                                    );\nfloat materialCellSizeBiasVariance[NUM_MATS] = float[NUM_MATS](.6f, 0.4f, 0.2f);\nfloat materialWeights[NUM_MATS] = float[NUM_MATS](.07f,.85f,1.0f);\n//float materialWeights[NUM_MATS] = float[NUM_MATS](.003f,0.98f,1.0f);\nvec3  materialBaseColor[NUM_MATS]   = vec3[NUM_MATS](vec3(0.58, 0.6, 0.35), vec3(0.30, 0.28, .28), vec3(0.65,0.63,0.63));\nvec3  materialRandomColor[NUM_MATS] = vec3[NUM_MATS](vec3(.2, .1, .1), vec3(.08, .08, .08), vec3(0.2,0.1,0.2));\nfloat materialSpecularity[NUM_MATS] = float[NUM_MATS](0.2,2.0,2.0f);\nfloat    materialShininess[NUM_MATS] = float[NUM_MATS](2.0f,16.0f,16.0f);\nfloat interpolate_grains = 0.7;\nbool interpolate_to_sphere = false;\nfloat grain_roundness[NUM_MATS] = float[NUM_MATS](0.0, 0.0, 0.85);\nfloat interpolate_roundness[NUM_MATS] = float[NUM_MATS](0.0,0.0,0.35);\n\n//float layer_scale = 0.2f;\n//vec3 layer_direction = normalize(vec3(-.2,.8,0.0));\n//vec3 gradient_noise_frequency = vec3(20.0);\n//float gradient_noise_weight = 1.75;\n//float static_noise_weight   = 0.5;\n//float layer_weight         = 1.0;\n\nfloat layer_scale = 100.0f;\nvec3 layer_direction = normalize(vec3(-.2,.8,0.0));\nvec3 gradient_noise_frequency = vec3(00.0);\nfloat gradient_noise_weight = 0.0;\nfloat static_noise_weight   = 1.0;\nfloat layer_weight         = 0.0;\n#endif\n//###############################################################################\n#ifdef SANDSTONE\n//Really needs layers to work convincingly\n#define DIVISION_SPACING 0.002\n#define NUM_MATS 4\n\nmat3 materialCellSizeBias[NUM_MATS] = mat3[NUM_MATS](\n                                                     mat3(1.0,0.1,0,\n                                                          0.1,1.0,0,\n                                                          0,0,1.0),\n                                                     mat3(1.2,0.1,0,\n                                                          0.1,1.20,0,\n                                                          0,0,1.2),\n                                                     mat3(1.0,0.1,0,\n                                                          0.1,1.0,0,\n                                                          0,0,1.0),\n                                                     mat3(1.2,0.1,0,\n                                                          0.1,1.2,0,\n                                                          0,0,1.2)\n                                                    );\nfloat materialCellSizeBiasVariance[NUM_MATS] = float[NUM_MATS](0.4f,.5f,.4f,.5f);\nfloat materialWeights[NUM_MATS] = float[NUM_MATS](0.25f,0.55,0.70f,1.0f);\nvec3  materialBaseColor[NUM_MATS]   = vec3[NUM_MATS](vec3(0.75, 0.71, 0.57),\n                                                     vec3(0.85, 0.8, 0.7),\n                                                     vec3(0.9, 0.85, 0.6),\n                                                     vec3(0.73, 0.64, 0.55));\nvec3  materialRandomColor[NUM_MATS] = vec3[NUM_MATS](vec3(.1, .1, .1),\n                                                     vec3(.1, .1, .1),\n                                                     vec3(.1, .1, .1),\n                                                     vec3(.1, .1, .1));\nfloat materialSpecularity[NUM_MATS] = float[NUM_MATS](0.1f,0.1f,0.1f,0.1f);\nfloat materialShininess[NUM_MATS] = float[NUM_MATS](128.0f,128.0f,128.0f,128.0f);\nfloat interpolate_grains = 0.25;\nbool interpolate_to_sphere = true;\nfloat grain_roundness[NUM_MATS] = float[NUM_MATS](0.97,.95,0.97,0.95);\nfloat interpolate_roundness[NUM_MATS] = float[NUM_MATS](0.75,0.75,0.75,0.75);\n\nfloat layer_scale = 0.06f;\nvec3 layer_direction = normalize(vec3(-.2,.8,0.0));\nvec3 gradient_noise_frequency = vec3(60.0);\n//float gradient_noise_weight = 2.6;\nfloat gradient_noise_weight = .6;\nfloat static_noise_weight   = 0.1;\nfloat layer_weight         = 1.0;\n#endif\n//###############################################################################\n#ifdef MARBLE\n//Really needs layers to work convincingly\n#define DIVISION_SPACING 0.005\n#define NUM_MATS 5\n\nmat3 materialCellSizeBias[NUM_MATS] = mat3[NUM_MATS](\n                                                     mat3(1.0,-.3,.0,\n                                                          -.3,1.0,.0,\n                                                          .0,.0,.8),\n                                                     mat3(1.0,-.3,.0,\n                                                          -.3,1.0,.0,\n                                                          .0,.0,.8),\n                                                     mat3(1.0,-.3,.0,\n                                                          -.3,1.0,.0,\n                                                          .0,.0,.8),\n                                                     mat3(.1,-0.65,0,\n                                                          -0.65,0.65,0,\n                                                          0,0,0.65),\n                                                    mat3(.1,-0.65,0,\n                                                          -0.65,0.65,0,\n                                                          0,0,0.65)\n                                                    );\nfloat materialCellSizeBiasVariance[NUM_MATS] = float[NUM_MATS](0.5f,.3f,0.5f,.2f,.1f);\n//float materialWeights[NUM_MATS] = float[NUM_MATS](0.3f,0.5,0.8f,0.92,1.0f);\nfloat materialWeights[NUM_MATS] = float[NUM_MATS](0.3f,0.5,0.8f,0.92,1.0f);\nvec3  materialBaseColor[NUM_MATS]   = vec3[NUM_MATS](vec3(0.95, 0.94, 0.93),\n                                                     vec3(0.9, 0.89, 0.88),\n                                                     vec3(0.95, 0.94, 0.93),\n                                                     vec3(0.25, 0.25, .25),\n                                                     vec3(0.13, 0.13, .13));\nvec3  materialRandomColor[NUM_MATS] = vec3[NUM_MATS](vec3(.03, .03, .02),\n                                                     vec3(.01, .01, .01),\n                                                     vec3(.03, .03, .02),\n                                                     vec3(.1, .1, .1),\n                                                     vec3(.1, .1, .1));\nfloat materialSpecularity[NUM_MATS] = float[NUM_MATS](4.0f,4.0f,4.0f,6.0f,6.0f);\nfloat materialShininess[NUM_MATS] = float[NUM_MATS](256.0f,64.0f,256.0f,128.0f,128.0f);\nfloat interpolate_grains = 0.92;\nbool interpolate_to_sphere = false;\nfloat grain_roundness[NUM_MATS] = float[NUM_MATS](0.97,.95,0.97,0.95,0.95);\nfloat interpolate_roundness[NUM_MATS] = float[NUM_MATS](0.0,0.0,0.0,0.0,0.0);\n\nfloat layer_scale = 0.06f;\n//float layer_scale = 0.01f;\nvec3 layer_direction = normalize(vec3(-1,-1,0));\nvec3 gradient_noise_frequency = vec3(12.0);\n//float gradient_noise_weight = 2.6;\nfloat gradient_noise_weight = 4.0;\n//float gradient_noise_weight = 1.5;\nfloat static_noise_weight   = 0.03;\nfloat layer_weight         = 1.0;\n#endif\n//###############################################################################\n#ifdef TRAVERTINE\n//Really needs layers to work convincingly\n#define DIVISION_SPACING 0.007\n#define NUM_MATS 6\n\nmat3 materialCellSizeBias[NUM_MATS] = mat3[NUM_MATS](\n                                                     mat3(1.0,0.0,.0,\n                                                          0.0,0.8,.0,\n                                                          .0,.0,1.0),\n                                                     \n                                                     mat3(1.0,0.0,.0,\n                                                          0.0,0.8,.0,\n                                                          .0,.0,1.0),\n                                                    mat3(1.0,0.0,.0,\n                                                          0.0,0.5,.0,\n                                                          .0,.0,1.0),\n                                                     mat3(1.0,0.0,.0,\n                                                          0.0,0.8,.0,\n                                                          .0,.0,1.0),\n                                                     mat3(1.0,0.0,.0,\n                                                          0.0,0.8,.0,\n                                                          .0,.0,1.0),\n                                                    mat3(2.0,0.0,.0,\n                                                          0.0,0.5,.0,\n                                                          .0,.0,2.0)\n                                                    );\nfloat materialCellSizeBiasVariance[NUM_MATS] = float[NUM_MATS](0.5f,.5f,0.5f,.5f,.5f,.5f);\n//float materialWeights[NUM_MATS] = float[NUM_MATS](0.3f,0.5,0.8f,0.92,1.0f);\nfloat materialWeights[NUM_MATS] = float[NUM_MATS](0.3f,0.493,0.5,0.8f,0.996,1.0f);\nvec3  materialBaseColor[NUM_MATS]   = vec3[NUM_MATS](vec3(0.95, 0.84, 0.63),\n                                                     vec3(0.9, 0.8, 0.56),\n                                                     vec3(0.6, 0.5, .3),\n                                                     vec3(0.95, 0.84, 0.63),\n                                                     vec3(0.92, 0.8, .59),\n                                                     vec3(0.6, 0.5, .3));\nvec3  materialRandomColor[NUM_MATS] = vec3[NUM_MATS](\n                                                     vec3(.03, .03, .03),\n                                                     vec3(.03, .03, .03),\n                                                     vec3(.0, .0, .0),\n                                                     vec3(.03, .03, .03),\n                                                     vec3(.03, .03, .03),\n                                                     vec3(.0, .0, .0));\nfloat materialSpecularity[NUM_MATS] = float[NUM_MATS](4.0f,4.0f,0.0f,4.0f,4.0f,0.0f);\nfloat materialShininess[NUM_MATS] = float[NUM_MATS](16.0f,16.0f,16.0f,16.0f,16.0f,16.0f);\nfloat interpolate_grains = 1.0;\nbool interpolate_to_sphere = true;\nfloat grain_roundness[NUM_MATS] = float[NUM_MATS](0.97,.95,.95,0.97,0.95,0.95);\nfloat interpolate_roundness[NUM_MATS] = float[NUM_MATS](0.0,0.0,0.0,0.0,0.0,0.0);\n\nfloat layer_scale = 0.06f;\n//float layer_scale = 0.01f;\nvec3 layer_direction = normalize(vec3(-0,-1,0));\nvec3 gradient_noise_frequency = vec3(6.0);\n//float gradient_noise_weight = 2.6;\nfloat gradient_noise_weight = 4.0;\n//float gradient_noise_weight = 1.5;\nfloat static_noise_weight   = 0.03;\nfloat layer_weight         = 1.0;\n#endif\n//###############################################################################\n//#define DIVISIONS 10\n//Old code that cached an attempt at randomness rather than rand (though it should really use perlin but eh)\n//vec3 grid_pertbs[DIVISIONS*DIVISIONS*DIVISIONS];\n\n//vec3 get_3D(vec3[DIVISIONS*DIVISIONS*DIVISIONS] arr, int i, int j, int k){\n//    return arr[i * DIVISIONS*DIVISIONS + j * DIVISIONS + k];\n//}\n//vec3[DIVISIONS*DIVISIONS*DIVISIONS] rand_init_3D(vec3[DIVISIONS*DIVISIONS*DIVISIONS] arr, vec3 seed){\n//    vec3 last_point = seed;\n//    for (int i = 0; i < DIVISIONS*DIVISIONS*DIVISIONS; i++) {\n//        vec3 new_point = randVec3(last_point);\n//        arr[i] = new_point;\n//        last_point = new_point + vec3(.125123,.2123645,.823412356);\n//    }\n//    return arr;\n//}\n\n//###############################################################################\n//###############################################################################\n//###############################################################################\n\n\n\n\n\n\n//###############################################################################\n//  Number in bottom left debugging code\n//###############################################################################\n#define ADD_DEBUG\n#ifdef ADD_DEBUG\n\n#define BLACK vec3(0)\n#define WHITE vec3(1)\n#define GRAY vec3(.5)\n#define RED vec3(1.,.3,.3)\n#define BLUE vec3(.3,.3,1.)\n#define GREEN vec3(.3,1.,.3)\n#define YELLOW vec3(1.,1.,.3)\n// From: https://www.shadertoy.com/view/4sBfRd\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n// Modified from: https://www.shadertoy.com/view/Md23DV\nfloat coordinateGrid(vec2 r) {\n\tfloat result;\n\tfor(float i = -2.; i <= 2.; i += .1) for(int j = 0; j < 2; j++) {\n\t\tresult += 1. - smoothstep(.0, .003, abs(r[j] - i));\n\t\tif(mod(i, 2.) < .01) result += 1. - smoothstep(.0, .004, abs(r[j] - i - 1.));\n\t\tif(abs(i) < .01) result += 1. - smoothstep(.0, .005, abs(r[j]));\t\n\t}\n\treturn result;\n}\n\nfloat printNumber(vec2 fragCoord, float number) {\n\tfloat fontSize = 16.;\n\t// init digits\n\tint digits[12];\n\t// numbers start at 48 in font map\n\tfor(int i = 0; i <= 9; i++) digits[i] = 48 + i;\n\tdigits[10] = 46; // .\n\tdigits[11] = 45; // -\n\n\tint a[15]; // array for digits of number\n\tint c = 0; // counter for array = length\n\tfloat tmp = abs(number);\n\t// do not display numbers higher than this due to precision issues\n\tif (tmp > 999999.) {\n\t\twhile(c < 8) a[c++] = 11; // --------\n\t} else {\n\t\tif(number < 0.) a[c++] = 11; // add - if number is negative\n\t\tint v; // current digit\n\t\tbool f; // true if first digit > 0 found\n\t\tfor(int i = 8; i >= -4; i--) {\n\t\t\tv = int(tmp / pow(10., float(i))); // calculate digit\n\t\t\t// omit leading zeros\n\t\t\tif(v > 0 || f) {\n\t\t\t\ta[c++] = v; // add digits 0-9\n\t\t\t\ttmp -= float(v) * pow(10., float(i)); // subtract\n\t\t\t\tf = true;\n\t\t\t}\n\t\t\t//decimal point\n\t\t\tif(i == 0 && abs(number) < 1.) a[c++] = 0; // add 0\n\t\t\tif(i == 0) a[c++] = 10; // add .\n\t\t}\n\t\twhile(a[c-1] == 0) c--; // strip 0\n\t\tif(a[c-1] == 10) c--; // strip .\n\t}\n\t// coordinate system that starts at bottom left\n\t// which is independent of aspect ratio\n\tvec2 p = fragCoord.xy / iResolution.y;\n\tfloat result;\n\t// output number\n\tfor(int i = 0; i < c; i++) {\n\t\tresult += char(p * 256. / fontSize + vec2(-.5 * float(i), 0.0), digits[a[i]]).x;\n\t}\n\treturn result;\n}\n#endif\n//###############################################################################\n//  Noise Code https://www.shadertoy.com/view/Xsl3Dl\n//###############################################################################\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat grad_noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n//###############################################################################\n//  Material Properties Code\n//###############################################################################\nint getWhichMaterial(vec3 cell_center) {\n    \n    float layer_val = dot(cell_center, layer_direction)/layer_scale;\n    //Add a bit of randomness to layer thickness, should probably also be a parameter\n    layer_val = layer_val + .6 * (1.0 + grad_noise(vec3(layer_val) * vec3(0.999999f, 0.99981343f, 0.9931453f)));\n    layer_val = fract(layer_val);\n\n    float grad_val = 0.5f + .5f * grad_noise(gradient_noise_frequency * cell_center * vec3(0.999999f, 0.99981343f, 0.9931453f));\n    \n    float static_val = rand(cell_center);\n    \n    float randVal = layer_val * layer_weight + static_val * static_noise_weight + grad_val * gradient_noise_weight;\n        \n    randVal = fract(randVal);\n    \n    int i = 0;\n    for(; randVal > materialWeights[i]; i++){}\n    return i;\n}\nvec3 getCellColor(int which_material, vec3 world_position, vec3 cell_center) {\n    return materialBaseColor[which_material] + dot(randVec3(cell_center), materialRandomColor[which_material]);\n    //4 * normalize(randVec3(cc) + vec3(2,0,0));\n    //1.0 * (vec3(.5) + .5 * normalize(randVec3(cc) + vec3(0,0,2)));\n}\nvec3 getCellNormal(int which_material, vec3 world_position, vec3 cell_center) {\n    return normalize(cell_center - sphere_pos);\n}\n//###############################################################################\n//  Code to divide into cells\n//###############################################################################\n\n//Gets the center of a cell in a perfect grid\nvec3 getNominalCellCenter(vec3 point){\n    vec3 f = floor(point / DIVISION_SPACING);\n    return f * DIVISION_SPACING + vec3(DIVISION_SPACING/2.0);\n    //return point + vec3(DIVISION_SPACING/2.0) - mod(point, DIVISION_SPACING);\n}\n//Gets the center of a cell in a perturbed grid\nvec3 getPerturbedCellCenter(vec3 point){\n    vec3 nom = getNominalCellCenter(point);\n    //This leads to some floating point errors? space varying noise should avoid?\n    nom += randVec3(nom) * DIVISION_SPACING - vec3(DIVISION_SPACING/2.0);\n    return nom;\n}\n\n//Gets the cloesest cell center from the perturbed grid. Perturbations mean it has\n//to check the several neighboring cells. Also accounts for material, biasing cell cize\nvec3 getClosestCenter(vec3 point, float min_dist, out float biased_dist_result){\n    vec3 dir_bias = vec3(1.0);\n    float lowest_dist = 100.0;\n    vec3 closest = vec3(-1);\n    \n    //These may need to check more cells if material bias gets too extreme?\n    for(int i = -1; i < 2; i++){\n        for(int j = -1; j < 2; j++){\n            for(int k = -1; k < 2; k++){\n                vec3 cc = getPerturbedCellCenter(point + vec3(i,j,k) * DIVISION_SPACING);\n                int which_mat = getWhichMaterial(cc);\n                mat3 bias_matrix = materialCellSizeBias[which_mat];\n                \n                float biased_dist = length(bias_matrix * (point - cc));\n                biased_dist = biased_dist * (1.0f + ((rand(-cc)-.5f) * materialCellSizeBiasVariance[which_mat]));\n                \n                //When determining 2nd closest with min_dist set to previous biased_dist_result, the calculation should be the exact same\n                //So > being strict should exclude the previous closest point.\n                if (biased_dist < lowest_dist && biased_dist > min_dist) {\n                    closest = cc;\n                    lowest_dist = biased_dist;\n                }\n            }\n        }\n    }\n    biased_dist_result = lowest_dist;\n    return closest;\n}\n//###############################################################################\n//  Code to shoot rays/get normals\n//###############################################################################\n//https://www.shadertoy.com/view/7lB3D1\n\n\nfloat shootRayAtZPlane(\n    vec3 ray,\n    vec3 rayDir,\n    float plane_z)\n{\n    float z_dist = plane_z - ray.z;\n    float scale_factor = z_dist/rayDir.z;\n    \n    vec3 hit_pos = vec3(ray.x + scale_factor * rayDir.x, ray.y + scale_factor * rayDir.y, plane_z);\n    \n    return length(hit_pos - ray);\n    \n}\nfloat shootRayAtSphereBack(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius,\n    float clip_plane)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float half_b = dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float discriminant = half_b * half_b - a * c;\n    \n    if (discriminant < 0.0) { return -1.0; }\n      \n    float e = sqrt(discriminant);\n\n    float root = (-half_b - e) / a;\n\n    if (root >= 0.0) { return root; }\n\n    root = (-half_b + e) / a;\n\n    if (root >= 0.0) { return root; }\n    \n    return -1.0;\n}\nfloat doClippingCheck(float dist, vec3 ray, vec3 rayDir, float clip_z, vec3 sphereCenter, float sphereRadius){\n    vec3 pos = ray + rayDir * dist;\n    if (pos.z > clip_z){\n        return dist;\n    }\n    else{\n        //either greater than plane dist or -1, don't need to care about previous dist\n        \n        float plane_back = shootRayAtZPlane(ray, rayDir, clip_z);\n        float sphere_back = shootRayAtSphereBack(ray + rayDir * plane_back, rayDir, sphereCenter, sphereRadius, clip_z);\n        if(sphere_back == -1.0){\n            return -1.0;\n        }\n        return plane_back;\n    }\n}\n\nfloat shootRayInSphere2(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius,\n    float clip_plane)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float half_b = dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float discriminant = half_b * half_b - a * c;\n    \n    if (discriminant < 0.0) { return -1.0; }\n      \n    float e = sqrt(discriminant);\n\n    float root = (-half_b - e) / a;\n\n    if (root >= 0.0) { return doClippingCheck(root, ray, rayDir, clip_plane, sphereCenter, sphereRadius); }\n\n    root = (-half_b + e) / a;\n\n    if (root >= 0.0) { return doClippingCheck(root, ray, rayDir, clip_plane, sphereCenter, sphereRadius); }\n    \n    return -1.0;\n}\n\n\nvec3 uvToRay(vec2 uv){\n    return normalize(vec3( (uv.x - .5) * aspect_ratio, uv.y - .5, -camera_dist)); \n}\nvec3 collideRay(vec2 uv, float clip_plane, float camera_rot){\n    vec3 ray = uvToRay(uv);\n    float temp = ray.z;\n    ray.z = cos(camera_rot)*ray.z + sin(camera_rot)*ray.x;\n    ray.x = cos(camera_rot)*ray.x - sin(camera_rot)*temp;\n    float dist = shootRayInSphere2(camera_pos, ray, sphere_pos, sphere_rad, clip_plane);\n    if (dist < 0.0f){\n        return vec3(-1);\n    } else {\n        \n        vec3 hit_pos = camera_pos + ray*dist;\n        return hit_pos;\n    }\n}\nvec3 collideRayOld(vec2 uv){\n    vec3 ray = uvToRay(uv);\n    for(float dist = 0.0; dist < 100.0; dist += 0.02){\n        if(length(sphere_pos - (camera_pos + ray*dist)) < sphere_rad){\n            vec3 hit_pos = camera_pos + ray*dist;\n            return hit_pos;\n        }\n    }\n    return vec3(-1);\n}\n//Not really working great\nvec3 collideRayWithFacets(vec2 uv, float clip_plane, float camera_rot){\n    float STEP_DIST = 0.001f;\n    vec3 ray = uvToRay(uv);\n    vec3 starting_point = collideRay(uv, clip_plane, camera_rot);\n    if(length(starting_point - vec3(-1)) < 0.01){\n        return vec3(-1);\n    }\n    starting_point = starting_point - ray*DIVISION_SPACING*1.9f;\n    \n    for(float dist = 0.0; dist < DIVISION_SPACING*3.0f; dist += STEP_DIST){\n        float biased_dist_to_cc;\n        float biased_dist_to_scc;\n        vec3 cc = getClosestCenter(starting_point + ray*dist, 0.0f, biased_dist_to_cc);\n        vec3 scc = getClosestCenter(starting_point + ray*dist, biased_dist_to_cc, biased_dist_to_scc);\n        if(biased_dist_to_scc - biased_dist_to_cc < STEP_DIST*5.1f){\n            int i = 0;\n            vec3 ray_to_cc  = cc  - (starting_point + ray*dist);\n            for(int i = 0; i < 200; i++){\n                if(dot(ray_to_cc, ray) > 0.0f){\n                    return starting_point + ray*dist;\n                }\n                dist += STEP_DIST;\n                cc = getClosestCenter(starting_point + ray*dist, 0.0f, biased_dist_to_cc);\n                ray_to_cc  = cc  - (starting_point + ray*dist);\n            }\n        }\n    }\n    return vec3(-2);\n}\n\nvec3 collideRayNormal(vec2 uv, float clip_plane, float camera_rot){\n    vec3 p = collideRay(uv, clip_plane, camera_rot);\n    return normalize(p - sphere_pos);\n}\nvec3 getNormalFrom3DPoint(vec3 point){\n    return normalize(point - sphere_pos);\n}\n//###############################################################################\n//###############################################################################\n//###############################################################################\n//  \n//       MAIN FUNCTION\n//\n//###############################################################################\n//###############################################################################\n//###############################################################################\n\nvoid initialize(){\n    \n    vec2 last_point = vec2(0.5, 0.2);\n    //set aspect ratio\n    x_res = iResolution[0];\n    y_res = iResolution[1];\n    aspect_ratio = x_res/y_res;\n    \n    inited = true;\n    \n    for(int i = 0; i < NUM_MATS; i++){\n        materialCellSizeBias[i] = inverse(materialCellSizeBias[i]);\n    }\n}\n\n#define CAMERA_BOB_MAG .3\n#define CAMERA_BOB_FREQ .051\n#define LIGHT_ROT_FREQ 0.5\n\n\n#define CLIPPING_Z_PLANE_MAX 1.1\n#define CLIPPING_Z_PLANE_MIN 0.48\n#define CLIPPING_Z_PLANE_FREQ 0.1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (!inited){\n        initialize();\n    }\n    float clipping_z_plane = CLIPPING_Z_PLANE_MIN + (CLIPPING_Z_PLANE_MAX-CLIPPING_Z_PLANE_MIN)/2.0 + (CLIPPING_Z_PLANE_MAX-CLIPPING_Z_PLANE_MIN)/2.0*sin(iTime*CLIPPING_Z_PLANE_FREQ);\n    \n    //sphere_pos = vec3(0,10.0+.4*sin(iTime*1.5),.8);\n    camera_pos = vec3(2.5,10.0+CAMERA_BOB_MAG*sin(iTime*CAMERA_BOB_FREQ),-1.8);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Worldspace point of ray at that uv\n    vec3 point_3D_from_ray = collideRay(uv, clipping_z_plane, 0.7);\n    // Output color\n    vec3 col = vec3(0,0,0); \n    vec3 norm = vec3(1,0,0);\n    \n    // Black if it doesn't hit anything\n    if(length(point_3D_from_ray - vec3(-1)) < 0.001){\n        col = vec3(0);\n    }\n    else if(length(point_3D_from_ray - vec3(-2)) < 0.001){\n        col = vec3(1, 0, 1);\n    }\n    else if(length(point_3D_from_ray - vec3(-3)) < 0.001){\n        col = vec3(1, 1, 0);\n    }\n    else{\n        //Closest cell center (3D)\n        float biased_dist_to_cc;\n        float dont_use_me;\n        vec3 cc = getClosestCenter(point_3D_from_ray, 0.0f, biased_dist_to_cc);\n        vec3 scc = getClosestCenter(point_3D_from_ray, biased_dist_to_cc, dont_use_me);\n        \n        //Swaps points if outside sphere - doesn't make a visual difference really, but leads to less smooth movement?\n        //if(length(scc-sphere_pos) < sphere_rad && length(cc-sphere_pos) > sphere_rad){\n        //    vec3 temp = cc;\n        //    cc = scc;\n        //    scc = temp;\n        //}\n        \n        //Randomly check which region center lies in (for the two different colors. Biased currently.)\n        int which_material = getWhichMaterial(cc);\n        col = getCellColor(which_material, point_3D_from_ray, cc);\n        \n        vec3 light_dir = normalize(vec3(sin(iTime * LIGHT_ROT_FREQ), -.3,cos(iTime * LIGHT_ROT_FREQ)));\n        vec3 backlight_dir = -light_dir;//normalize(vec3(-.8,.5,.0));\n        \n        //a interpolates the sphere surface normal with the facet normal.\n        //Higher values \"flatten\" the cell to be closer to a single surface\n        //Facets are the intersection of cells, in theory \n        float a = interpolate_grains;\n        norm = normalize(scc-cc);\n        \n        //Normal relative to sphere\n        vec3 sphere_norm = getCellNormal(which_material, point_3D_from_ray, cc);\n        \n        //Normal relative to cell (bunch of sphere segments)\n        vec3 cell_norm = normalize(point_3D_from_ray - cc);\n        if(dot(cell_norm, point_3D_from_ray - camera_pos) > 0.0f){\n            cell_norm = -normalize(point_3D_from_ray - cc);\n        }\n        \n        //If the closest center is actually outside the sphere, make it flat\n        if(dot(norm, sphere_norm) < 0.0f){\n            //norm = -norm;\n            a = 1.0f;\n        }\n        //Need better ways to find borders for this to work.\n        //if(dot(norm, cell_norm) < 0.0f){\n        //   norm = -norm;\n        //}\n        \n        if(interpolate_to_sphere){\n            sphere_norm = normalize(point_3D_from_ray - sphere_pos);\n        }\n        vec3 roundness_norm = normalize(point_3D_from_ray - (sphere_pos + (cc - sphere_pos)*grain_roundness[which_material]));\n        float b = interpolate_roundness[which_material];\n        \n       \n        norm = normalize( (1.0f - a - b) * norm + a * sphere_norm + b * roundness_norm);\n        vec3 view_dir = normalize(point_3D_from_ray - camera_pos);\n        \n        bool on_clip_plane = false;\n        if(abs(point_3D_from_ray.z - clipping_z_plane) < .01){\n            norm = vec3(0,0,-1.0);\n            on_clip_plane = true;\n        }\n        //https://learnopengl.com/Lighting/Basic-Lighting\n        vec3 reflect_dir = reflect(-light_dir, norm);\n        float spec = materialSpecularity[which_material] * pow(max(dot(view_dir, reflect_dir), 0.0), materialShininess[which_material]);\n        vec3 breflect_dir = reflect(-backlight_dir, norm);\n        float bspec = materialSpecularity[which_material] * pow(max(dot(view_dir, breflect_dir), 0.0), materialShininess[which_material]);\n        \n        spec = max(spec, 0.0);\n        bspec = max(bspec, 0.0);\n        \n        \n        float lscale  = max(0.0f, dot(light_dir, -norm));\n        float blscale = max(0.0f, dot(backlight_dir, -norm));\n        if(on_clip_plane){\n            if(dot(light_dir, norm) >= 0.0f){\n                lscale = 0.0f;\n                spec = 0.0f;\n            }\n            else{\n                blscale = 0.0f;\n                bspec = 0.0f;\n            }\n        }\n        else{\n            if(dot(light_dir, point_3D_from_ray - sphere_pos) >= 0.0f){\n                lscale = 0.0f;\n                //Technically more accurate to shadow specular too, but this sparkles and looks cool\n                spec   = 0.0f;\n            }\n            if(dot(backlight_dir, point_3D_from_ray - sphere_pos) >= 0.0f){\n                blscale = 0.0f;\n                bspec   = 0.0f;\n            }\n        }\n        vec3 light_scale = (lscale + spec) * vec3(.9,.9,.9) + (blscale + bspec) * vec3(.1,.1,.25) + vec3(.1);\n        //col = (col + vec3(rand(point_3D_from_ray)*0.2)) * light_scale;\n        col = col * light_scale;\n        //col = vec3(1) * grad_noise(cc*100.0f);\n        //col = vec3(.5) + .5 * grad_noise(20.0f*cc*vec3(0.999999, 0.99981343, 0.9931453));\n        //col = vec3(1) * grad_noise(cc);\n    }\n    \n    \n    \n    \n    //if (length(getClosestCenter(vec3(uv, 0.001)).xy - uv) < 0.02){\n    //    col = mix(col, vec3(1,1,1), .5);\n    //}\n    \n    \n    if(mod(uv.x, DIVISION_SPACING) < 0.002 || mod(uv.y, DIVISION_SPACING) < 0.002) {\n        //col = mix(col, vec3(0,1,0), 0.5);\n    }  \n    // Output to screen\n    col = mix(col, GREEN, printNumber(fragCoord, grad_noise(vec3(0.123643216,0.123643216,0.123643216))));\n    \n    fragColor = vec4(col,1.0); \n    \n}","name":"Image","description":"","type":"image"}]}