{"ver":"0.1","info":{"id":"lllfDr","date":"1511660947","viewed":310,"name":"ddx / ddy normal test","username":"cabbibo","description":"shading in seperate buffer!","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["ddx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n   \n    vec4 col = texture( iChannel0 , uv );\n    \n\tfragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The MINIMIZED version of https://www.shadertoy.com/view/Xl2XWt\n\n\nconst float MAX_TRACE_DISTANCE = 5.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n\nvec2 opS( vec2 d1, vec2 d2 ){\n    return  -d1.x > d2.x  ? vec2(-d1.x , d1.y) : d2 ;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n\nfloat length6( vec3 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/6.0 );\n}\n\nfloat fractal(vec3 p , float size)\n{\n   \tfloat len = length(p);\n    p=p.yxz;\n\n    float scale = 1.25;\n    const int iterations = 50;\n    float a = iTime;\n\tfloat l = 0.;\n    \n    vec2 rotationAnimAmp = 3. * vec2(0.02,0.04);\n\tvec2 rotationPhase = vec2(.8,0.83);\n\t\n    // uncomment this to find good spots with the mouse :)\n    vec2 m = iMouse.xy / iResolution.xy;\n    //rotationPhase = m;\n   \n    vec3 juliaOffset = vec3(-3.,-1.5,-.5);\n    \n    for (int i=0; i<iterations; i++) {\n\t\tp.xy = abs(p.xy);\n        // scale and offset the position\n\t\tp = p*scale + juliaOffset;\n        \n        // Rotate the position\n\n        pR(p.xy,rotationPhase.x*3.14 + cos(iTime + len)*rotationAnimAmp.y);\n        pR(p.zx,rotationPhase.y*3.14 + sin(iTime + len)*rotationAnimAmp.x);\t\t\n\n        l=length6(p);\n\t}\n    \n\treturn l*pow(scale, -float(iterations))-size;\n}\n\n\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    vec3 fPos = pos - vec3( .2 + sin( iTime ) * .1 , .4 + sin( iTime + 2. ) * .1 , -.2 + sin( iTime + 4. ) * .3);\n    \n \tvec2 res= vec2( sdSphere( fPos , 1.1 ) , 1. ); /// vec2(0. ,10000000.);\n    \n    vec2 s1 = vec2( sdSphere( fPos , 1.1 ) , 3. ); \n    vec2 s2 = vec2( sdSphere( fPos , .7  ) , 2. ); \n    \n    vec3 nP = pos- vec3( -.3 , -.2 , -0.2 );\n    pR( nP.xz , sin(iTime) * .2);\n    pR( nP.xy , sin(iTime) * .1);\n    \n    \n    \n    vec2 f = vec2(fractal( nP * 6., .1 ) / 10., 3.);\n    \n    \n   \n    vec3 fPos1 = pos - vec3( -.8 + sin( -iTime ) * .1 , -.4 + sin( -iTime + 2. ) * .1 , -.2 + sin( -iTime + 4. ) * .3);\n\n   \n    vec2 ss1= vec2( sdSphere( fPos1 , .8 ) , 3. ); \n    vec2 ss2= vec2( sdSphere( fPos1 , .5  ) , 2. );\n    \n    res = opS( s1  , f  );\n    \n    res = opS( ss1  , res  );\n    res = opU( s2  , res  );\n    res = opU( ss2  , res  );\n    \n    return res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n\nvec4 render( vec2 res , vec3 ro , vec3 rd ){\n   \n\n  vec4 color = vec4( 0. , 0. , -1. , 10000000. );\n    \n    \n    \n  if( res.y > -.5 ){\n  \tcolor = vec4( res.y , res.x , 0. , 1. );    \n  }\n   \n  return color;\n    \n    \n}\n\nvoid doCamera( in vec2 coord , out vec3 rayO , out vec3 rayD ){\n    \n    vec2 p = (-iResolution.xy + 2.0*coord.xy)/iResolution.y;\n\n    vec3 ro = vec3( 0., 0., 3.);\n    vec3 ta = vec3( 0. , 0. , 0. );\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) );\n    \n    rayO = ro;\n    rayD = rd;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 ro; vec3 rd;\n    \n    doCamera( fragCoord.xy , ro , rd );\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\t\n    vec4 color = render( res , ro , rd );\n    \n\tfragColor = color;\n\n    \n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nvec4 render( float tD , vec4 mapInfo , vec4 dx ,vec4 dx2 , vec4 dy , vec4 dy2  , vec3 norm ){\n   \n\n  vec4 color = vec4( 0. , 0. , 0. , 10000000. );\n    \n    \n  vec4 ddx = dx - mapInfo;\n  vec4 ddy = dy - mapInfo;\n    \n   \n    \n \n    \n  if( mapInfo.x > 0. ){\n  \t\n    color =vec4( norm * .5 + .5 , 1. );///// vec4( dX.y , dY.y , 0. , 10000000. );    \n \t\n    \n    if( dx.x != 0. || dx2.x != 0. || dy.x != 0. || dy2.x != 0. ){\n      color.xyz =vec3( 1. , 1. , 1.  );   \n    }else{\n        \n        \n        color.xyz *=  vec3( 1.- tD );// - length( abs(ddx.y) + abs(ddy.y))* .01;// , 0.) * 10.;\n        \n        \n        if( mapInfo.x == 2. ){\n       color = vec4( 1. , 0. , 1. ,1.);   \n      }\n       //  color.xyz =  vec3(tD * 10000000000000000000. );// - length( abs(ddx.y) + abs(ddy.y))* .01;// , 0.) * 10.;\n        \n        \n        //color.xyz = vec3(1.) * (1. /(mapInfo.y -1.))* (1. /(mapInfo.y -1.));\n      //color.xyz =(1. /(mapInfo.y -1.))* (1. /(mapInfo.y -1.))* .3* vec3( abs(sin(mapInfo.x))  , abs(sin(mapInfo.x * 10.)) , abs(sin(mapInfo.x*30.)));\n     //color *= (abs(ddx.y) + abs( ddy.y )) * 10.;\n    }\n      \n      \n   \n   }\n    \n  return color;\n    \n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec2 u = vec2(0., 1. / iResolution.y );\n    vec2 r = vec2( 1. / iResolution.x , 0.);\n    \n\tvec4 mapInfo = texture( iChannel0 , uv );\n    vec4 U = texture( iChannel0 , uv + u );\n    vec4 D = texture( iChannel0 , uv - u );\n    vec4 L = texture( iChannel0 , uv - r );\n    vec4 R = texture( iChannel0 , uv + r );\n    \n    vec4 U2 = texture( iChannel0 , uv + u * 2. );\n    vec4 D2 = texture( iChannel0 , uv - u * 2. );\n    vec4 L2 = texture( iChannel0 , uv - r * 2. );\n    vec4 R2 = texture( iChannel0 , uv + r * 2. );\n    \n    vec4 dx  = R - L;\n    vec4 dx2 = R2 - L2;\n    \n \n    \n    vec4 dy  = U - D;\n    vec4 dy2 = U2 - D2;\n    \n    float dXr = abs(R.y * 100. - mapInfo.y * 100.);\n    float dXl = abs(L.y * 100. - mapInfo.y * 100.);\n    float dXu = abs(U.y * 100. - mapInfo.y * 100.);\n    float dXd = abs(D.y * 100. - mapInfo.y * 100.);\n \n    float tD = abs(dXr - dXl) + abs( dXu - dXd );\n    \n    \n    vec3 x; vec3 y;\n    \n    x = vec3( 1. / iResolution.x , 0. , R.y - mapInfo.y );\n  \ty = vec3(  0. ,  1. / iResolution.y , U.y - mapInfo.y );\n  \n  \tvec3 normL = normalize(cross( x , y ));\n    \n    x = vec3( 1. / iResolution.x , 0. , L.y - mapInfo.y );\n    y = vec3(  0. ,  1. / iResolution.y , D.y - mapInfo.y );\n  \n  \tvec3 norm1 = normalize(cross( x , y ));\n    vec3 norm2 = normalize(cross( x , y ));\n    \n    \n    vec3 norm = norm1 + norm2; \n    norm = normalize( norm );\n\t\n    vec4 color = render( 1.-tD  , mapInfo, dx , dx2 , dy , dy2 , norm  );\n     //color *= 0.0;\n\tfragColor = color;\n    \n    \n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nfloat noise( vec2 uv ){\n    float n = sin( uv.x * 1000. ) + sin( uv.x * 20000. ) + sin(uv.x  * 12431.);\n    n += sin( uv.y * 2000. ) + sin( uv.y * 30000. ) + sin(uv.y  * 512431.);\n    n/=6.;\n    return n;\n    \n}\n\nvec3 hsv(float h, float s, float v)\n{\n    \n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    vec4 col = texture( iChannel0 , uv );\n    vec4 oCol = texture( iChannel1 , uv );\n    \n    vec2 u = vec2(0., 1. / iResolution.y );\n    vec2 r = vec2( 1. / iResolution.x , 0.);\n    \n    vec4 U = texture( iChannel1 , uv + u );\n    vec4 D = texture( iChannel1 , uv - u );\n    vec4 L = texture( iChannel1 , uv - r );\n    vec4 R = texture( iChannel1 , uv + r );\n    \n    \n    vec4 newCol = col * .01 + oCol * .99;\n    \n    vec3 dif = col.xyz - vec3( 1. , 1. , 1. );\n    \n    float l = length( dif );\n    \n    float sphere = 0.;\n    if( col.xyz == vec3( 1. , 0. , 1. )){\n     col.xyz = vec3( 0. , 0. , 0.);   \n        sphere = 1.;\n    }\n    \n    if( col.xyz == vec3( 1. , 1. , 1.) ){\n        newCol.xyz = vec3( 1. , 1. , 1. );\n    }else{\n        newCol =  mix( col , oCol , .4 );\n    }\n    \n    float n = .6 * triNoise3D( vec3( fragCoord.xy * .001 , 0. ) , 3.4 ) + triNoise3D( vec3( fragCoord.xy * .005 , 0. ) , 4. );// + .2 * vec2( sin(iTime * .1 ) , cos(iTime * .1)) );\n      \n    \n   \n    \n    if( col.w > 10.  ){\n        \n       newCol.xyz =  mix( col.xyz , oCol.xyz , 0.48 );\n        \n       //newCol.xyz = vec3( 0., 0., 0.);\n       newCol.xyz +=  .13 *abs(n)*  length(U.xyz);\n       newCol.xyz +=  .13 *abs(n)*  length(L.xyz);\n       newCol.xyz +=  .13 *abs(n)*  length(R.xyz);\n       newCol.xyz +=  .13 *abs(n)*  length(D.xyz);\n          //newCol.xyz =  mix( newCol.xyz , oCol.xyz , 0.2 ); \n    }\n    \n    if( sphere == 1. ){\n        \n       newCol.xyz =  mix( col.xyz , oCol.xyz , 0.94 );\n        \n       //newCol.xyz = vec3( 0., 0., 0.);\n       newCol.xyz += 0.;hsv( -.6 + .7 * abs(n)*  length(U.xyz) , 1. ,.01 + abs( n) * .01 ) ;\n       newCol.xyz += 0.;hsv( -.6 + .7 * abs(n)*  length(L.xyz) , 1. ,.01 + abs( n) * .01 ) ;\n       newCol.xyz += 0.;hsv( -.6 + .7 * abs(n)*  length(R.xyz) , 1. ,.01 + abs( n) * .01 ) ;\n       newCol.xyz += 0.;hsv( -.6 + .7 * abs(n)*  length(D.xyz) , 1. ,.01 + abs( n) * .01 ) ;\n        newCol.xyz = clamp( newCol.xyz , vec3(0.,0.,0.), vec3(1.,1.,1.));\n          //newCol.xyz =  mix( newCol.xyz , oCol.xyz , 0.2 ); .5*\n    }\n    \n    \n        \n       //newCol.xyz = vec3( 0., 0., 0.);\n       //newCol.x += .21 *abs(n)*  length(U.xyz);\n       //newCol.x += .21 *abs(n)*  length(L.xyz);\n       //newCol.x += .21 *abs(n)*  length(R.xyz);\n       //newCol.x += .21 *abs(n)*  length(D.xyz);\n       //   //newCol.xy1 =  mix( newCol.xyz , oCol.xyz , 0.2 ); \n    \n    \n  //newCol = vec4(0.,0.,0.,0.);\n    \n   // color = vec4( 0. , 0.,  0. , 0.);\n    \n\tfragColor = newCol;\n}","name":"Buf C","description":"","type":"buffer"}]}