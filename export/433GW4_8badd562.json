{"ver":"0.1","info":{"id":"433GW4","date":"1716574944","viewed":125,"name":"Ball Pool","username":"coposuke","description":"Reference : \"Basic : Voronoi Tracking\" @Gijs\nhttps://www.shadertoy.com/view/WltSz7\n\nMade by learning Voronoi tracking.\n\nR: Reset","likes":9,"published":1,"flags":48,"usePreview":0,"tags":["voronoi","tracking","jump","particle","flooding","jfa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Visualize all particles\n//\n// Buffer A: Particle Buffer\n// Buffer B: Voronoi Tracking Buffer\n// \nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int particles = getParticleCount(iResolution.xy);\n    int particleID = -1;\n    float dist = 1e+8;\n    \n    if(false)\n    {\n        for(int i = 0; i < min(particles, 100); ++i)\n        {\n            vec4 particle = getParticle(iChannel0, iResolution.xy, i);\n            dist = min(dist, distance(particle.xy, fragCoord));\n        }\n    }\n    else\n    {\n        ivec4 closest = getClosest(iChannel1, fragCoord);\n        \n        particleID = closest.x;\n        vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n        vec2 particlePos = particle.xy;\n\n        dist = distance(fragCoord, particlePos);\n    }\n    \n    vec3 hsv = vec3(float(particleID) / float(particles), 0.25, 0.8);\n    vec3 particleColor = hsv2rgb(hsv);\n    float particleRadius = getParticleRadius(iResolution.xy);\n    \n    vec3 color = vec3(0.0);\n    color += particleColor * smoothstep(0.0, -2.0, dist - particleRadius);\n    fragColor = vec4(color, 1.0);\n    \n    // debug\n    //fragColor += vec4(dist / 50.0);\n    vec2 uv = fragCoord/iResolution.xy;\n    //fragColor = texture(iChannel0, uv);\n    //fragColor = texture(iChannel1, uv) / float(particles);\n    //fragColor = texture(iChannel1, uv).xxxx / float(particles);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Update Particle\n// \n// xy: position\n// zw: velocity\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\n    int particles = getParticleCount(iResolution.xy);\n    int particleID = getParticleID(fragCoord, iResolution.xy);\n    if (particleID >= particles)\n        return;\n        \n    vec4 particle = getParticle(iChannel0, iResolution.xy, particleID); // ==texture(iChannel0, fragCoord / iResolution.xy);\n    vec2 position = particle.xy;\n    vec2 velocity = particle.zw;\n\n    // Initialize & Reset\n    if (iFrame < 60 || 0.0 < getKeyR(iChannel2, 0))\n    {\n        position.x = hash(fragCoord.xy);\n        position.y = hash(fragCoord.xy * vec2(0.5, 0.5));\n        \n        float radian = hash(float(particleID)) * TAU;\n        velocity.x = sin(radian);\n        velocity.y = cos(radian);\n        \n        position *= iResolution.xy;\n        velocity *= PARTICLE_SPEED;\n    }\n    // Update\n    else\n    {\n        // Move\n        position += velocity * iTimeDelta;\n\n        // Coefficient of restitution\n        const float COR = 1.0;\n        const float COR2 = 1.0 + COR * COR;\n        \n        // Hit closest particles\n        float particleRadius = getParticleRadius(iResolution.xy);\n        ivec4 closest = getClosest(iChannel1, position);\n        for (int i = 0; i < 4; i++)\n        {\n            if(closest[i] < 0 || closest[i] == particleID)\n                continue;\n        \n            vec4 particle = getParticle(iChannel0, iResolution.xy, closest[i]);\n            vec2 particlePos = particle.xy;\n            vec2 particleVel = particle.zw;\n            float dist = distance(position, particlePos);\n            \n            if (dist <= particleRadius * 2.0)\n            {\n                float overlap = dist - particleRadius * 2.0;\n                vec2 normal = normalize(position - particlePos);\n                //float dotNV = dot((velocity - particleVel) * 0.5, normal);\n                float dotNV = dot(velocity, normal);\n                \n                position -= overlap * normal;                // pushback\n                velocity = velocity - dotNV * normal * COR2; // repulsion\n            }\n        }\n        \n        // Hit wall\n        vec2 halfRes = iResolution.xy * 0.5;\n        vec2 diff  = position - halfRes;\n        vec2 velSign = sign(velocity);\n        vec2 wall = halfRes * velSign - particleRadius * velSign;\n\n        vec2 a = mix(diff, wall, velSign * 0.5 + 0.5);\n        vec2 b = mix(wall, diff, velSign * 0.5 + 0.5);\n\n        if (a.x < b.x)\n        {\n            float overlap = abs(diff.x) - halfRes.x;\n            position.x -= (overlap + particleRadius) * velSign.x; // pushback\n            velocity.x *= -COR;                                   // repulsion\n        }\n\n        if (a.y < b.y)\n        {\n            float overlap = abs(diff.y) - halfRes.y;\n            position.y -= (overlap + particleRadius) * velSign.y; // pushback\n            velocity.y *= -COR;                                   // repulsion\n        }\n    }\n    \n    particle.xy = position;\n    particle.zw = velocity;\n    fragColor = particle;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/// Hash ///\nfloat hash(float v)\n{\n    return fract(sin(v) * 43758.5453123);\n}\n\nfloat hash(vec2 v)\n{\n    return fract(sin(dot(v, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\n/// Particle ///\nconst float PARTICLE_SPEED = 100.0;\n\nfloat getParticleRadius(vec2 resolution)\n{\n    return resolution.y / 800.0 * 8.0;\n}\n\nint getParticleCount(vec2 resolution)\n{\n    float radius = getParticleRadius(resolution);\n    float fullCount = floor(resolution.x * resolution.y / (4.0 * radius * radius));\n    return int(fullCount * 0.5);\n}\n\nint getParticleID(ivec2 fragCoord, ivec2 resolution)\n{\n    return fragCoord.x + fragCoord.y * resolution.x;\n}\n\nint getParticleID(vec2 fragCoord, vec2 resolution)\n{\n    return getParticleID(ivec2(fragCoord), ivec2(resolution));\n}\n\nvec4 getParticle(sampler2D aBuffer, vec2 resolution, int pid)\n{\n    int particles = getParticleCount(resolution);\n    pid = abs(pid) % particles; // round to within limit\n\n    int rx = int(resolution.x);\n    int ux = pid % rx;\n    int uy = pid / rx;\n    return texelFetch(aBuffer, ivec2(ux, uy), 0); // aBuffer = ParticleBuffer\n}\n\n/// Voronoi Tracking ///\nivec4 getClosest(sampler2D bBuffer, ivec2 fragCoord)\n{\n    return ivec4(texelFetch(bBuffer, fragCoord, 0));\n}\n\nivec4 getClosest(sampler2D bBuffer, vec2 fragCoord)\n{\n    return getClosest(bBuffer, ivec2(fragCoord));\n}\n\n/// Other ///\nconst float PI = 3.14159265358979;\nconst float TAU = PI * 2.0;\n\nfloat getKeyR(sampler2D keyboardBuffer, int state)\n{\n    return texelFetch(keyboardBuffer, ivec2(82, state), 0).x;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// Voronoi Tracking\n// \n// x: closest no.1\n// y: closest no.2\n// z: closest no.3\n// w: closest no.4\n//\n\n//#define MODE_VERY_HIGH_PERFORMANCE\n#define MODE_HIGH_PERFORMANCE\n//#define MODE_MIDDLE_PERFORMANCE\n//#define MODE_LOW_PERFORMANCE\n\nvoid insertClosest(inout ivec4 srcIDs, inout vec4 srcDist, in int dstID, in float dstDist)\n{\n    if (dstDist < srcDist.x)\n    {\n        srcIDs = ivec4(dstID, srcIDs.xyz);\n        srcDist = vec4(dstDist, srcDist.xyz);\n    }\n    else if(dstDist < srcDist.y)\n    {\n        srcIDs = ivec4(srcIDs.x, dstID, srcIDs.yz);\n        srcDist = vec4(srcDist.x, dstDist, srcDist.yz);\n    }\n    else if(dstDist < srcDist.z)\n    {\n        srcIDs = ivec4(srcIDs.xy, dstID, srcIDs.z);\n        srcDist = vec4(srcDist.xy, dstDist, srcDist.z);\n    }\n    else if(dstDist < srcDist.w)\n    {\n        srcIDs = ivec4(srcIDs.xyz, dstID);\n        srcDist = vec4(srcDist.xyz, dstDist);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec4 closestList = ivec4(-1);  // new closest list (particleIDs)\n    vec4 distanceList = vec4(1e+8); // new distance list\n\n    // Reset\n    if (iFrame < 20 || 0.0 < getKeyR(iChannel2, 1))\n    {\n        fragColor = vec4(closestList);\n        return;\n    }\n    \n    // Loading closest particleID List\n    ivec4 prevList = getClosest(iChannel1, fragCoord);\n    for (int i = 0; i < 4; ++i)\n    {\n        int particleID = prevList[i];\n        if (particleID < 0)\n            continue;\n\n        vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n        vec2 particlePos = particle.xy;\n        \n        // The position of the ball changes, so load while sorting.\n        // comparing distance fragCoord to particlePos, and insert one closest.\n        float dist = distance(fragCoord, particlePos);\n        insertClosest(/*out*/ closestList, /*out*/ distanceList, prevList[i], dist);\n    }\n\n    // setting parameters (by mode performance)\n    float jfStart = min(10.0, floor(log2(max(iResolution.x, iResolution.y))));\n    int offsetLoops = 8;\n    const vec2 [8] OFFSETS = vec2[8]\n    (\n        vec2(-1.0,  0.0), vec2(0.0,  1.0), vec2( 1.0, 0.0), vec2(0.0, -1.0), // Left, Up, Right, Down\n        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0), vec2(1.0,  1.0)  // 4 corners\n    );\n    int closestLoops = 4;\n    \n#ifdef MODE_VERY_HIGH_PERFORMANCE\n    // very high (max loops: 11 * 8 * 4 = 352)\n#elif defined(MODE_HIGH_PERFORMANCE)\n    // high      (max loops: 11 * 8 * 2 = 176)\n    closestLoops = 2;\n#elif defined(MODE_MIDDLE_PERFORMANCE)\n    // middle    (max loops:  9 * 4 * 2 = 72)\n    jfStart = floor(jfStart * 0.8);\n    offsetLoops = 4;\n    closestLoops = 2;\n#else //MODE_LOW_PERFORMANCE\n    // low       (max loops:  7 * 4 * 1 = 28)\n    jfStart = floor(jfStart * 0.6);\n    offsetLoops = 4;\n    closestLoops = 1;\n#endif\n\n    // jump flooding loops\n    for (float jf = jfStart; jf >= 0.0; jf--)\n    {\n        float jfLength = pow(2.0, jf);\n        \n        // getting neighbor closest particleID list\n        for (int i = 0; i < offsetLoops; ++i)\n        {\n            vec2 offset = OFFSETS[i];\n            ivec4 neighbor = getClosest(iChannel1, fragCoord + offset * jfLength);\n\n            for(int ci = 0; ci < closestLoops; ci++) // closest index\n            {\n                int particleID = neighbor[ci];\n                if (particleID < 0)\n                    continue;\n                    \n                // continue when closestList contain the particleID\n                if (any(equal(closestList, ivec4(particleID))))\n                    continue;\n\n                vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n                vec2 particlePos = particle.xy;\n\n                // comparing distance fragCoord to particlePos, and insert one closest.\n                float dist = distance(fragCoord, particlePos);\n                insertClosest(/*out*/ closestList, /*out*/ distanceList, particleID, dist);\n            }\n        }\n    }\n    \n    // random pick a particleID, and insert one closest.\n    // we need to find closest particle IDs, with in the area between particles.\n    {\n        int particles = getParticleCount(iResolution.xy);\n    \n        int [2] particleIDs = int[2](0, 0);\n        particleIDs[0] = int(hash(fragCoord + iTime * 0.1) * float(particles));            // random pick\n        particleIDs[1] = (getParticleID(fragCoord, iResolution.xy) + iFrame) % particles;  // fixed pick\n\n        for (int i = 0; i < 2; ++i)\n        {\n            int particleID = particleIDs[i];\n            \n            // Same as above\n            if (any(equal(closestList, ivec4(particleID))))\n                continue;\n                    \n            vec4 particle = getParticle(iChannel0, iResolution.xy, particleID);\n            vec2 particlePos = particle.xy;\n\n            float dist = distance(fragCoord, particlePos);\n            insertClosest(/*out*/ closestList, /*out*/ distanceList, particleID, dist);\n        }\n    }\n    \n    fragColor = vec4(closestList);\n}","name":"Buffer B","description":"","type":"buffer"}]}