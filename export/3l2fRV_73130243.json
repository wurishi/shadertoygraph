{"ver":"0.1","info":{"id":"3l2fRV","date":"1599369691","viewed":157,"name":"quarantined Alpes","username":"danhel95","description":" Learning tutorial 6!\n learning about reflections , refractions , lights and terrains. tried to make it organized so that new beginners like me understand whats going on! ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["terrain","refraction","water","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Learning tutorial 6!\n// learning about reflections , refractions , lights and terrains\n// terrain based on https://www.shadertoy.com/view/wtfyzf by @yonatan\n// added water :) and tried to make it fast as possible!\n// reflection/refraction based on https://www.shadertoy.com/view/3llXW7 by @eseris\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPSILON\t1e-3\n#define ITR 100.\n#define SURF 1e-5\n#define FAR 100.\n#define REFSTEP 4.\n#define ZERO min(iFrame,0)\n#define THEIGHT .7\n#define TWIDTH 1.1\n\n\n\n#define pow(a,b) pow(abs(a),(b))\n\nmat2 R2(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nstruct star{\n    vec3 pos;\n    vec3 col;\n    float rad;\n};\n\n\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n    vec3 t;\n    float zoom;\n};\n\nstruct obj\n{\n\n    float d;\n    vec3 material;\n    vec3 col; //final\n    float amb;\n    float diffuse;\n    float specular;\n    float shiness;\n    float transparency;\n    float id;\n\n};\n\n\nmat3 camera(ray r , float roll)\n{\n\tvec3 f = normalize(r.t-r.o);\n    vec3 up = vec3(sin(roll),cos(roll),0.);\n    vec3 u = normalize(cross(f,up));\n    vec3 v = normalize(cross(u,f));\n    return mat3(u,v,f);\n}\n\nvec3 cam_to_world(ray r , vec2 uv , float roll){\n    mat3 viewCam = camera(r, roll); // viewCam = mat(u,v,f)\n    vec3 o = vec3(uv,r.zoom);\n    vec3 rd =  viewCam * normalize(o); // basically rd = uv.x*u + uv.y*v +zoom*f\n    return normalize(rd) ;\n}\n\nray raydir(vec2 uv, vec2 m) {\n\n    float roll = 0.;\n    ray r ;\n    r.zoom = 1.5;\n    r.o = vec3(0., 6., -10.);\n    r.t = vec3(.0);\n\n    float ang = .3 * iTime;\n    r.o.zx *= R2( - m.x * TWO_PI );\n    r.o.xy *= R2( - m.y * PI + .5);\n\n    r.d = cam_to_world(r,uv,roll);\n    return r;\n}\n\n\n\nfloat box(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n\treturn length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.);\n}\n\nfloat plane(vec3 p, vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r ;\n\n}\n\nfloat wave(vec2 xz, float k, float c, float t)\n{\n    float X = xz.x + xz.y - c * t;\n    //return pow(sin(k * X) * exp(-.01*X*X),2.);\n    return pow(sin(k * X) ,2.);\n}\n\nfloat terrain(vec3 p) {\n  float h=0., amp =.8, n;\n  for(float i = 0.; i < 1.; i+=1./3.) {\n    n = sin(p.x) * cos(p.z) ;\n    n = n * n *n -.1*n;\n    h += n * amp;\n    p.xz *= R2(i*i-.5*p.y) ;\n    p.xz *= 3.;\n    amp *= .13;\n    if (p.y - h < -.15){\n        p.xz += iTime*h;\n      p.y += clamp(h * wave(mod(p.xz*2.,4.)+.2,.2,.01,iTime),.0,.2);\n    }\n\n  }\n  return p.y - h;\n}\n\n\n\n\n\nobj uop(in obj a, in obj b)\n{\n    if(a.d < b.d) return a;\n    return b;\n\n    }\n\n\nfloat bassin(vec3 p) {\n    vec3 p1 = p  - vec3(0, 3., 0);\n    float db2 = box(p1, vec3(3.1, 3., 3.1))-.2;\n    float dp2 = plane(p1,vec4(0, 1., 0,1.));\n    db2 = abs(db2);\n    db2 = max(dp2,db2) ;\n    return db2;\n\n}\n\nobj scene(vec3 p) {\n\n    // float ds = sphere(p-spos, .4);\n    vec3 q = (p-vec3(.0,.2,.0)) * TWIDTH ;\n    float dt = terrain(q);\n    float dp = box(q, vec3(3, .1, 3));\n    dp -= THEIGHT*max(dt,dp);\n    vec3 tcol = vec3(.5,.3,4.)*(q.y+.01*dt);\n    float db2 = bassin(p);\n    obj pln = obj(dp ,tcol,vec3(0.), .6, 1., 3., 100.,1., 1.);\n    //obj sp = obj(ds ,vec3(1.,0.,1.),vec3(0.),  .25, 1., 3., 100.,1.,2.);\n    obj bx2 = obj(db2 ,vec3(0.,1.,1.),vec3(0.),  .25, 1., 3., 100.,.2, 3.);\n\n    obj r = uop(pln,bx2);\n\n    return r;\n}\nvec3 grad(vec3 p) {\n\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*scene(p+0.0005*e).d;\n      if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    const float maxHei = 2.;\n    float tp = (maxHei-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=min(0, iFrame); i<3; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).d;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1.0 );\n}\n\n\nobj march(in vec3 ro, in vec3 rd)\n{\n\n    float t = 0.; obj s; vec3 p;\n    for (float i = 0.; i < 1. && t <= FAR; i+=1./ITR)\n    {\n        p = ro + rd * t;\n        s = scene(p);\n        if (abs(s.d) <= SURF)break;\n        t += (s.d);\n    }\n\n    s.d = t;\n    return s;\n}\n\n\n\n\nvoid let_be_light(vec3 p, vec3 rd, vec3 normal,star l, inout obj ob) {\n\n    vec3 lp = normalize(l.pos-p);\n    float Kd = clamp( dot( normal, lp ), .1, 1. );\n    vec3  s = normalize( lp-rd );\n    //vec3  s = normalize( reflect(-rd,normal) );\n    float Ks = pow(dot( normal, s ), ob.shiness);\n\n    Kd *= shadow(p, lp, .1, 3.);\n\n    vec3 dif =  ob.material * Kd * ob.diffuse;\n    vec3 spec = ob.material * Ks * l.col*  ob.specular;\n    vec3 ambi = ob.material *  ob.amb;\n\n    ob.col += (dif + spec + ambi) ;\n\n\n}\n\nvec3 refract2(vec3 i, vec3 n, float eta) {\n    if(dot(i, n) < 0.) eta = 1. / eta;\n    else n = -n;\n    return refract(i, n, eta);\n}\n\nvec3 draw_star(vec3 p, star s, vec3 rd, float d, float i)\n{\n    float g = .0;\n    vec3 lp = s.pos - p;\n    float l = dot(lp,lp);\n    if ( l  - s.rad < d *10.)\n    {\n        float a = max(abs(dot(normalize(lp), rd)), 0.1);\n\t\tg = pow(a,3000.);\n    }\n\n    return s.col * g * i;\n}\n\n\nvec3 render(ray r) {\n\n    vec3 resCol = vec3(0);\n    vec3 p = r.o;\n    float alpha = 1.;\n    obj ob;\n    float radius = 2.  ,theta= iTime*.5;\n    vec3 spos = vec3(radius * cos(1.5*theta), 1.5 + sin(theta ) * .5, radius * sin(theta));\n    star blue = star(spos, vec3(.1,.1,.8), 1. );\n\n    for(float i = 0.; i < 1.; i += 1./REFSTEP) {\n        ob = march(p,r.d);\n        p +=  ob.d * r.d ;\n    \tvec3 normal = grad(p);\n        let_be_light(p, r.d, normal,blue, ob);\n        vec3 s = draw_star(p,blue,r.d,ob.d,20.);\n        resCol += s ;\n\n        ob.col *= pow(smoothstep(FAR, 20., 2.*ob.d), 20.);\n        if(ob.id < 3. ) {\n            resCol += ob.col * alpha  ;\n       \t\talpha *= 0.1;\n            r.d = reflect(r.d, normal);\n        }\n        else {\n            resCol += ob.col * alpha *ob.transparency;\n            alpha *= (1. - ob.transparency);\n            r.d = refract2(r.d, normal,1.03);\n        }\n\n       if(ob.id < 2.) break;\n\n        p += r.d * 1e-3;\n\n\n\n    }\n\n\n\treturn resCol;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy ;\n\n    ray r = raydir(uv,m);\n\n    vec3 color = render(r);\n    color = pow(color,vec3(0.75));\n    fragColor = vec4( color, 1.0);\n}","name":"Image","description":"","type":"image"}]}