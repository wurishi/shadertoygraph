{"ver":"0.1","info":{"id":"wsfcDS","date":"1585448910","viewed":113,"name":"Interference Blobs","username":"KJK","description":"I put a bunch of circular waves evenly spaced around the origin and moved them in and out. I ran the sum of the waves through a smoothstep to make discrete blobs.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["interferencepattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float TAU = 2.0 * 3.14159;\n    float speed = 6.0;\n    float range = 100.0;\n    float waveFrequency = 2.0;\n    float waveSmoothness = 1.0;\n    float invScale = 80.0;\n    float dropletCount = 5.0;\n    //float rotationSpeed = 0.1;\n    \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv *= invScale;\n    \n    //float ct = cos(iTime * rotationSpeed);\n    //float st = sin(iTime * rotationSpeed);\n    //uv = vec2(ct * uv.x + st * uv.y, st * uv.x - ct * uv.y);\n\n    float brightness = 0.0;\n    for (float i = 0.0; i < dropletCount; i++) {\n        float angle = TAU * i / dropletCount;\n        float dist = (0.5 + 0.5 * sin(iTime * speed / range)) * range;\n        vec2 pos = vec2(sin(angle), cos(angle)) * dist;\n        float distFromDrop = length(uv.xy - pos);\n        float height = 0.5 + 0.5 * cos(waveFrequency * distFromDrop);\n        brightness += height;\n    }\n    brightness /= dropletCount;\n    \n    vec2 gradient = vec2(dFdx(brightness), dFdy(brightness));\n    float slope = length(gradient);\n    \n    // If the wave is steep here, compensate by smoothing the step.\n    float r = waveSmoothness * slope;\n    \n    // The larger r is, the wider the interpolation region is and the smoother the step is.\n    brightness = smoothstep(0.5 - r, 0.5 + r, brightness);\n    \n    fragColor = vec4(brightness);\n}","name":"Image","description":"","type":"image"}]}