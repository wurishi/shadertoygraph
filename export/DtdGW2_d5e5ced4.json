{"ver":"0.1","info":{"id":"DtdGW2","date":"1699359048","viewed":44,"name":"Circle optical illusion","username":"Undeadly","description":"Recreation of the illusion from this tweet: https://twitter.com/jagarikin/status/1384660858131804161\n\n[Still in progress] All elements are present, but could not figure out what the trick is.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["opticalillusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Optical illusion recration \n// Source: https://twitter.com/jagarikin/status/1384660858131804161\n\n#define Pi  3.1415926\n#define Two_Pi 6.28318530718\n\nvec3 bgColor = vec3(138.0/255.0,138.0/255.0,138.0/255.0);\nvec3 arrowColor = vec3(109.0/255.0,107.0/255.0,108.0/255.0);\n\nfloat toAngle(vec2 v){\n  return atan(v.y, v.x) + Pi;\n}\n\nfloat normally(float minV, float maxV, float vV){\n  float mid = (minV+maxV)/2.0;\n  if(mid == vV) return 1.0;\n  if(mid<vV){\n    return 1.0 - ((vV-mid)/(maxV - mid));\n  }\n  return 1.0 - ((mid-vV)/(mid - minV));\n}\n\nvec3 drawTriangle(vec2 st, vec2 bot){\n  vec3  color = bgColor;\n  float height = 0.24;\n  \n  float bottomLineY = bot.y;\n  float base = bot.x;\n  float thinckness = 0.24;\n  \n  \n  float p = 1.0 - ((st.y - bottomLineY)/height);\n  float leftX  = base - p*thinckness;\n  float rightX = base + p*thinckness;\n  \n  float topLineY = height + bottomLineY;\n  \n  //st.y=bottomLineY;\n  if(st.y > bottomLineY && st.y < topLineY) {\n    if(st.x>leftX && st.x<rightX)\n      color = arrowColor;\n  }      \n  \n  return color;\n}\n\nvec3 drawRect(vec2 st, vec2 top, float height){\n  vec3 color = bgColor;\n  float thickness = .08;\n  \n  float topLineY = top.y;\n  float bottomLineY = top.y - height;\n  float leftX = top.x - thickness;\n  float rightX = top.x + thickness;\n  \n  if(st.y>bottomLineY && st.y<topLineY) {\n    if(st.x>leftX && st.x<rightX)\n      color = arrowColor;\n  }      \n  \n  return color;\n}\n\nvec3 drawArrow(vec2 v, float boxSize, float angle){\n  //draw triangle\n  // draw rectagle\n  vec2 st = v.xy/vec2(boxSize,boxSize);\n  float xN = cos(angle)*st.x - sin(angle)*st.y;\n  float yN = sin(angle)*st.x + cos(angle)*st.y;\n  st = vec2(xN, yN);\n  vec3 color = bgColor;\n  vec2 triangleBase = vec2(.0,.1);\n  float lineHeight = .4;\n  \n  if(st.y > triangleBase.y)\n    return drawTriangle(st, triangleBase);\n  return drawRect(st, triangleBase, lineHeight); \n}\n// todo: move to declare\nfloat waitT = 1.2;\nfloat rotateT = .6;\n\n#define TOP_BOT       1\n#define RIGHT_LEFT    2\n#define BOT_TOP       3\n#define LEFT_RIGHT    4\n#define SHRINK_EXPAND 5\n#define EXPAND_SHRINK 6\n//TODO: screw\n\n// equal to highest number of animation type\n#define MAX_ANIMATION_ELEMENTS  6.0 \n\nfloat getAnimationTime(){\n\n  float s = waitT+rotateT;\n  float t = mod(iTime, (s)*MAX_ANIMATION_ELEMENTS);\n  return t;\n}\n\nint getAnimationState() {\n\n  float s = waitT+rotateT;\n  float t = getAnimationTime();\n  float subT = t/s;\n  return int(subT) + 1;\n/*\n  if(t<s){\n    return TOP_BOT\n  }\n  if(t<2.0*s){\n    float rT = 2.0*s-rotateT;\n    return RIGHT_LEFT\n  }\n  if(t<3.0*s){\n    return BOT_TOP;\n  }\n  if(t<4.0*s){\n    return LEFT_RIGHT;\n  }\n  return -1;\n*/\n}\n\nfloat transitionTime(int animationState) {\n  float s = waitT+rotateT;\n  float t = getAnimationTime();\n  float n = float(animationState);\n  return t - (n*s - rotateT);\n  // n*wait + (n-1)*wait\n  // 0: s   - rotateT = 1*waitT                 \n  // 1: 2*s - rotateT = 2*wait + rotateT\n  // 2: 3*s - rotateT = 3*wait + 2*rotateT\n  // 3: 4*s - rotateT = 4*wait + 3*rotateT\n}\n\nvec3 animateShrinkGrow(vec2 uv, float boxSize, float time, float dir) {\n  int state = getAnimationState();\n  float lowAngle = float(state-1) * Pi/2.0f;\n  float dT = transitionTime(state);\n  float dirx = dir;\n  if(uv.x > 0.0){\n     uv.x = -normally(-1.0, 1.0, uv.x) + 0.93;\n  }\n  else {\n      dirx *= -1.0;\n      uv.x = normally(-1.0, 1.0, uv.x)  - 0.93;\n  }\n  uv.x*=dirx;\n  float diry = dir;\n  if(uv.y > 0.0){\n     uv.y = -normally(-1.0, 1.0, uv.y) + 0.93;\n  }\n  else {\n      diry *= -1.0;\n      uv.y = normally(-1.0, 1.0, uv.y)  - 0.93;\n  }\n  uv.y*=diry;\n  //uv.x = normally(-1.0, 1.0, uv.x);\n  //uv.y = normally(-1.0, 1.0, uv.x);\n  return drawArrow(uv, boxSize/1.5, Pi/4.0);\n }\n\nvec3 animate(vec2 uv, float boxSize, float time, float dir) {\n  int state = getAnimationState();\n  float dT = transitionTime(state);\n  state = 1;\n  dT = 0.0;\n  float lowAngle = float(state-1) * Pi/2.0f;\n  //if(state > 4) return animateShrinkGrow(uv, boxSize, time, dir);\n  // if state > 4 : expand and shrink animation\n  if(state <= LEFT_RIGHT) {\n      float highAngle = 0.0f;\n      if(dT>0.0){\n          highAngle = dT/(rotateT)*(Pi/2.0) + lowAngle;\n          return drawArrow(uv, boxSize, highAngle);\n      } else{\n          return drawArrow(uv, boxSize, lowAngle);\n      }\n  } else{\n      uv.x = -normally(-1.0, 1.0, uv.x) + 0.55;\n      uv.y = -normally(-1.0, 1.0, uv.x) + 0.55;\n      if(state == SHRINK_EXPAND) {\n          return drawArrow(uv, boxSize,0.0);\n      } \n      if (state == EXPAND_SHRINK) {\n          return drawArrow(uv, boxSize,Pi);\n      }\n  }\n  \n  return drawArrow(uv, boxSize,0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      float fGlobalTime = iTime;\n      vec2 uv = fragCoord / iResolution.xy - 0.5;\n      uv.x *= iResolution.x/iResolution.y; \n      \n      uv *= 2.0;\n       \n      float dir = 1.0;\n      if(uv.x > 0.0){\n        dir = -1.0;\n        uv.x = -normally(-1.0, 1.0, uv.x) + 0.55;\n\n      } else {\n        uv.x = normally(-1.0, 1.0, uv.x) - 0.55;\n      }\n\n      float intencity = distance(uv, vec2(0,0))*5.0;\n      float angle = toAngle(uv);\n\n      float r=.0f,g=.0f,b = 0.0f;\n      float innerRing = 0.256; // max 0.26\n      float outerRing = 0.384; // min 0.38\n     \n      float d = distance(uv, vec2(0,0));\n      // Seems increase of speed have some effect (lowered because to flashy)\n      float speed = 10.0;\n      float rotR = 0.4;\n      float rotT =  speed*fGlobalTime;\n      \n      // !Main juice of illusion!\n      //changing speed of inner and outer rings\n      //if(0.38<d && d<outerRing) rotT +=2.0;\n      //if(innerRing<d && d<0.26) rotT +=2.0;\n          \n      vec2 rotatingPoint1 = vec2(rotR*sin(rotT)           , rotR*cos(rotT));\n      vec2 rotatingPoint2 = vec2(rotR*sin(rotT+2.0*Pi/3.0), rotR*cos(rotT+2.0*Pi/3.0));\n      vec2 rotatingPoint3 = vec2(rotR*sin(rotT+4.0*Pi/3.0), rotR*cos(rotT+4.0*Pi/3.0));\n\n       float a1 = toAngle(rotatingPoint1);\n       float a2 = toAngle(rotatingPoint2);\n       float a3 = toAngle(rotatingPoint3);\n      \n      // !Main juice of illusion!\n      //scale optic illusion\n      // \n      /*\n          shrink and grow \n          float shirnk = 1.0; //if neg grow first\n          float k = shirnk*dir;\n          float phase = Pi/4.0;\n      */\n      /*Both grow or getting closer\n          float k = dir;\n          float phase = Pi/4.0;\n          if(k>0.0) phase = -phase;\n      */\n      // both shrink or getting far away\n          /*float k = dir;\n          float phase = Pi/4.0;\n          if(k<0.0) phase = -phase;\n          */\n\n          float k = dir;\n          float phase = Pi/4.0;\n          if(k>0.0) phase = -phase;\n          float addPhase = 0.0;\n\n       if(0.38<d && d<outerRing){\n          a1-=k*phase+ addPhase;\n          a2-=k*phase+ addPhase;\n          a3-=k*phase+ addPhase;\n       }\n       \n       if(innerRing<d && d<0.26){\n          a1+=k*phase + addPhase;\n          a2+=k*phase + addPhase;\n          a3+=k*phase + addPhase;\n       }\n       \n       \n      if (a1>a3){\n\n        if(angle > a3 && angle < a1) {\n          r = normally(a3, a1, angle);  \n        }\n      } else{\n        if(angle < a1){ \n\n          r = normally(a1 - 4.0*Pi/3.0, a1, angle);  \n\n        }\n        else if(angle > a3){\n          r = normally(a3, a3+ 4.0*Pi/3.0, angle);  \n\n        }\n      }\n      if(a1<a2){\n        if(angle > a1 && angle < a2) {\n          g = normally(a1, a2, angle);\n        }\n      } else{\n        if(angle < a2){ \n          g = normally(a2 - 4.0*Pi/3.0, a2, angle);  \n        }\n        else if(angle > a1){\n          g = normally(a1, a1+ 4.0*Pi/3.0, angle);  \n\n        }\n      }\n      if(a2<a3){\n        if(angle > a2 && angle < a3){\n          b = normally(a2, a3, angle);\n        }\n      } else{\n         if(angle < a3){ \n          //  \n          b = normally(a3 - 4.0*Pi/3.0, a3, angle);  \n        }\n        else if(angle > a2){\n          b = normally(a2, a2+ 4.0*Pi/3.0, angle);  \n\n        }\n      }\n      if(d<innerRing){\n        uv.y = dir*uv.y;\n        uv.x = dir*uv.x;\n\n        fragColor = vec4(animate(uv, 0.34,fGlobalTime, dir),1.0);\n      }\n      else if(d < outerRing){\n          fragColor = vec4(r,g,b,1)*vec4(intencity,intencity,intencity,1);//* vec4(1,g,1,1) * vec4(1,1,b,1);\n      } else{\n        fragColor = vec4(bgColor.xyz,1);\n      }\n}","name":"Image","description":"","type":"image"}]}