{"ver":"0.1","info":{"id":"7dXSDS","date":"1619640575","viewed":53,"name":"task2_ray_tracing","username":"marikil","description":".","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["hometask"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(10, -1, 8);\n\nconst vec3 LIGHT1_POS = vec3(-4, 2.5, -1.5);\nconst float LIGHT1_RAD = 0.5;\nconst vec3 LIGHT1_COLOR = vec3(1, 1, 0);\n\nconst vec3 LIGHT2_POS = vec3(2, 1.5, -2);\nconst float LIGHT2_RAD = 0.2;\nconst vec3 LIGHT2_COLOR = vec3(1, 0, 1);\n\nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\n\nconst float PHI = (1.0 + sqrt(5.0))/2.0; \nconst float R = sqrt(PHI + 2.0);\nconst float H = sqrt(R*R - 1.0);\n\nconst float cylinderR = 1.2;\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal)\n{\n    float t = (-0.3 - H - pos.y)/dir.y;\n    if (t <= 0.0)\n    {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0)\n    {\n        return INF;\n    }\n    \n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal)\n{\n    //dot(t*dir + pos, t*dir+pos) = r*r\n    //t*t*dot(dir, dir) + 2*t*dot(dir, pos) + dot(pos, pos) = r*r\n    float a = dot(dir, dir);\n    float b = dot(dir, pos);\n    float c = dot(pos, pos) - r*r;\n    float D = b*b - a*c;\n    if (D < 0.0)\n    {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0)\n    {\n        normal = normalize(t*dir + pos);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0)\n    {\n        return INF;\n    }\n    normal = normalize(t*dir + pos);\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, float r, out vec3 normal)\n{\n    float t = (-H - pos.y)/dir.y;\n    if (t <= 0.0)\n    {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < r*r)\n    {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(dir.xz, pos.xz);\n    float c = dot(pos.xz, pos.xz) - r*r;\n    float D = b*b - a*c;\n    if (D < 0.0)\n    {\n        return INF;\n    }\n    \n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) \n    {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -H) \n        {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) \n    {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -H) \n    {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    \n    return INF;\n}\n\nstruct Triangle\n{\n    vec3 vertices[3];\n};\n\nfloat traceTriangle(vec3 pos, vec3 dir, Triangle tr, out vec3 normal)\n{\n    const float EPSILON = 1e-4;\n    vec3 ver0 = tr.vertices[0];\n    vec3 ver1 = tr.vertices[1];  \n    vec3 ver2 = tr.vertices[2];\n    vec3 edge1 = ver1 - ver0;\n    vec3 edge2 = ver2 - ver0;\n    vec3 h = cross(dir, edge2);\n    float a = dot(edge1, h);\n    \n    if (a > -EPSILON && a < EPSILON) return INF;\n    \n    float f = 1.0/a;\n    vec3 s = pos - ver0;\n    float u = f * dot(s, h);\n    \n    if (u < 0.0 || u > 1.0) return INF;\n    \n    vec3 q = cross(s, edge1);\n    float v = f * dot(dir, q);\n    \n    if (v < 0.0 || u + v > 1.0) return INF;\n    \n    float t = f * dot(edge2, q);\n    \n    if (t < EPSILON) return INF;\n    \n    vec3 v1 = ver2 - ver0;\n    vec3 v2 = ver1 - ver0;\n    normal = normalize(cross(v1,v2));\n    return t;\n}\n\nfloat traceIcosahedron(vec3 pos, vec3 dir, out vec3 normal)\n{        \n        vec3 v[12];\n        \n        v[0] = vec3(-1,  PHI, 0);\n        v[1] = vec3( 1,  PHI, 0);\n        v[2] = vec3(-1, -PHI, 0);\n        v[3] = vec3( 1, -PHI, 0);\n        \n        v[4] = vec3(0, -1,  PHI);\n        v[5] = vec3(0,  1,  PHI);\n        v[6] = vec3(0, -1, -PHI);\n        v[7] = vec3(0,  1, -PHI);\n        \n        \n        v[8]  = vec3( PHI, 0, -1);\n        v[9]  = vec3( PHI, 0,  1);\n        v[10] = vec3(-PHI, 0, -1);\n        v[11] = vec3(-PHI, 0,  1);\n        \n        Triangle tr[20];\n        tr[0] = Triangle(vec3[3](v[5], v[11], v[0]));\n        tr[1] = Triangle(vec3[3](v[1], v[5],  v[0]));\n        tr[2] = Triangle(vec3[3](v[7], v[1],  v[0]));\n        tr[3] = Triangle(vec3[3](v[10], v[7], v[0]));\n        tr[4] = Triangle(vec3[3](v[11], v[10], v[0]));\n        \n        tr[5] = Triangle(vec3[3](v[9], v[5], v[1]));\n        tr[6] = Triangle(vec3[3](v[4], v[11], v[5]));\n        tr[7] = Triangle(vec3[3](v[2], v[10], v[11]));\n        tr[8] = Triangle(vec3[3](v[6], v[7], v[10]));\n        tr[9] = Triangle(vec3[3](v[8], v[1], v[7]));\n        \n        tr[10] = Triangle(vec3[3](v[4], v[9], v[3]));\n        tr[11] = Triangle(vec3[3](v[2], v[4], v[3]));\n        tr[12] = Triangle(vec3[3](v[6], v[2], v[3]));\n        tr[13] = Triangle(vec3[3](v[8], v[6], v[3]));\n        tr[14] = Triangle(vec3[3](v[9], v[8], v[3]));\n        \n        tr[15] = Triangle(vec3[3](v[5], v[9], v[4]));\n        tr[16] = Triangle(vec3[3](v[11], v[4], v[2]));\n        tr[17] = Triangle(vec3[3](v[10], v[2], v[6]));\n        tr[18] = Triangle(vec3[3](v[7], v[6], v[8]));\n        tr[19] = Triangle(vec3[3](v[1], v[8], v[9]));\n        \n        vec3 tmpNormal;\n        float t = INF;\n        for (int i = 0; i < 20; i++) \n        {\n            float triangleT = traceTriangle(pos, dir, tr[i], tmpNormal);\n            if (triangleT < t) \n            {\n                t = triangleT;\n                normal = tmpNormal;\n            }\n        }\n        return t;\n}\n\nbool isOccluded(vec3 pos, vec3 target) {\n    vec3 v = target - pos;\n    float dist = length(v);\n    vec3 dir = v / dist;\n    \n    vec3 normal = vec3(0, 0, 0);\n    \n    float t = traceIcosahedron(pos, dir, normal);\n    if (dist >= t) {\n        return true;\n    }\n    vec3 cylinderNorm = normal;\n    t = traceCylinder(pos, dir, cylinderR, cylinderNorm);\n    return (t > 0.0 && dist >= t);\n}\n\nvec3 randV;\nvec3 randDir;\n\nvec3 Light(vec3 pos, vec3 color, vec3 normal)\n{\n    vec3 light1Pos = LIGHT1_POS + randDir * LIGHT1_RAD;\n    vec3 tolight1 = light1Pos - pos;\n    float dist1_sq = dot(tolight1, tolight1);\n    bool occluded1 = isOccluded(pos + normalize(tolight1) * 1e-3, light1Pos);\n    float att1 = 25.0/dist1_sq * (occluded1 ? 0.0 : 1.0);\n    \n    vec3 light2Pos = LIGHT2_POS + randDir * LIGHT2_RAD;\n    vec3 tolight2 = light2Pos - pos;\n    float dist2_sq = dot(tolight2, tolight2);\n    bool occluded2 = isOccluded(pos + normalize(tolight2) * 1e-3, light2Pos);\n    float att2 = 20.0/dist2_sq * (occluded2 ? 0.0 : 1.0);\n    \n    \n    return color * (\n           max(0.0, dot(normal, normalize(tolight1))) * att1 * LIGHT1_COLOR\n           + max(0.0, dot(normal, normalize(tolight2))) * att2 * LIGHT2_COLOR\n           + texture(iChannel1, normal).rgb \n           );\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2)\n{\n    if (dot(v, normal) < 0.0)\n    {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 v_tan = normalize(v - cosA * normal);\n    \n    float sinB = sinA * n1 / n2;\n    float cosB = sqrt(1.0 - sinB * sinB);\n    \n    if (sinB > 1.0)\n        return reflect(v, normal);\n    \n    return sinB * v_tan + cosB * normal;\n    \n}\n\nfloat rand(float frame)\n{\n    return fract(sin(dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\n\nfloat fireSdf(vec3 pos) {\n    return length(pos) - 0.25;\n}\n\nvec4 sampleFire(vec3 pos, vec3 dir){\n\n    float f = fireSdf(pos);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + f) * dir;\n        float sdf = fireSdf(curPos);\n        if (sdf < -0.05 && sdf > -0.3) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(-12.0 * (\n            texture(iChannel3, curPos).r +\n            texture(iChannel3, curPos *  3.0).r\n            )/2.0 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    return vec4(vec3(1, 0.35, 0) * 2.5 * totalAbs, 1.0 - opacity);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    randV = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randV - 0.5);\n\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randV.xy - 0.5) * 2.0)/iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n        const int EMISSION = 0;\n        const int DIFFUSE = 1;\n        const int REFLECTION = 2;\n        const int REFRACTION = 3;\n        \n    vec3 currentPos = CAMERA_POS;\n    vec3 currentDir = viewVec;\n    \n    float n1, n2;\n    n1 = AIR_N;\n    n2 = GLASS_N;\n    float GLASS_R = (AIR_N - GLASS_N) * (AIR_N - GLASS_N) /\n                    ((AIR_N + GLASS_N) * (AIR_N + GLASS_N));\n            \n    float mult = 1.0;\n    bool b= false;                \n    vec3 resCol;\n    \n    for (int i = 0; i < 10; ++i)\n    {\n        float t = INF;\n        int materialType;\n        vec3 color;\n        vec3 planeNormal;\n        vec3 normal = vec3(0);\n        \n        \n        float planeT = tracePlane(currentPos, currentDir, planeNormal);\n        if (planeT < t)\n        {\n            t = planeT;\n            vec3 worldPos = t * currentDir + currentPos;\n            if (randV.x < 0.2) materialType = REFLECTION;\n            else materialType = DIFFUSE;\n            color = texture(iChannel0, worldPos.xz * 0.1).rgb;\n            normal = planeNormal;\n        }\n        \n        vec3 icosahedronNormal;\n        float icosahedronT = traceIcosahedron(currentPos, currentDir, icosahedronNormal);\n        if (icosahedronT < t)\n        {\n            t = icosahedronT;\n            if (randV.x < GLASS_R) materialType = REFLECTION;\n            else materialType = REFRACTION;\n           //materialType = DIFFUSE;\n           //color = vec3(0.2, 0.7, 0.1);\n            normal = icosahedronNormal;\n        }\n        \n        vec3 cylinderNormal;\n        float cylinderT = traceCylinder(currentPos, currentDir, cylinderR, cylinderNormal);\n        if (cylinderT < t)\n        {\n            t = cylinderT;\n            if (randV.y < 0.1) materialType = REFLECTION;\n            else materialType = DIFFUSE;\n            vec3 worldPos = t * currentDir + currentPos;\n            color = texture(iChannel2, worldPos.xz * worldPos.y).rgb;\n            normal = cylinderNormal;\n        }\n        \n        vec3 light1Normal;\n        float lightT = traceSphere(currentPos - LIGHT1_POS, currentDir, LIGHT1_RAD, light1Normal);\n        if (lightT < t)\n        {\n            t = lightT;\n            materialType = EMISSION;\n            color = LIGHT1_COLOR;\n            normal = light1Normal;\n        }\n        \n        vec3 light2Normal;\n        lightT = traceSphere(currentPos - LIGHT2_POS, currentDir, LIGHT2_RAD,  light2Normal);\n        if (lightT < t)\n        {\n            t = lightT;\n            materialType = EMISSION;\n            color = LIGHT2_COLOR;\n            normal = light2Normal;\n        }\n        \n        \n    \n        if (t != INF)\n        {\n            vec3 worldPos = t * currentDir + currentPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            \n            if (materialType == EMISSION)\n            {\n                //resCol += color;\n                fragColor.rgb = color;\n                break;\n            }\n            else if (materialType == DIFFUSE)\n            {\n                //resCol += Light(worldPos, color, normal);\n                fragColor.rgb = Light(worldPos, color, normal);\n                break;\n            }\n            else if (materialType == REFLECTION)\n            {\n                \n                currentDir = reflect(currentDir, normal);\n                currentPos = worldPos + currentDir * 1e-4;\n            }\n            else if (materialType == REFRACTION)\n            {\n                currentDir = refraction(currentDir, normal, n1, n2);\n                currentPos = worldPos + currentDir * 1e-4;\n                /*if (b == false) {\n                    float mult = 2.0;\n                    vec4 fog = sampleFire(currentPos, currentDir);\n                    resCol += fog.rgb * fog.a * mult;\n                    \n                    mult *= 1.0 + fog.a;\n                    \n                    float tmp = n1;\n                    n1 = n2;\n                    n2 = tmp;\n                    b = true;\n                }*/\n                n1 = n1 + n2;\n                n2 = n1 - n2;\n                n1 = n1 - n2;\n            }\n        }\n        if (t == INF)\n        {\n            //resCol += 0.1 * 2.0 * texture(iChannel1, currentDir).rgb;\n            fragColor.rgb =  texture(iChannel1, currentDir).rgb;\n            break;\n        }\n    }\n   // fragColor = vec4(resCol, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}