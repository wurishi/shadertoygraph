{"ver":"0.1","info":{"id":"sdsyW8","date":"1642040805","viewed":299,"name":"Voxel Staircase with Shadow & AO","username":"jt","description":"Towards construction of a voxel-building: implemented shadows & ambient occlusion.\n(The shadows still have some errors but as they look mostly ok I've enabled them anyway.\nAlso there's potential for optimization - maybe in a future version).\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","grid","raycasting","shadow","voxel","ao","ambientocclusion","dda","staircase","stairs","grids","textured","walls","offset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/sdsyW8 Voxel Staircase with Shadow & AO, 2022 by Jakob Thomsen\n// Towards rendering a building by efficiently raytracing voxels which contain raymarched shapes.\n// Walls & floors implemented as offset grid.\n// History/previous versions:\n//     https://www.shadertoy.com/view/NtVXzV Voxel Staircase\n//     https://www.shadertoy.com/view/NlVXzG Voxels Containing Walls & Stairs\n//     https://www.shadertoy.com/view/flVXDw Voxels Containing Walls\n//     https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects\n// efficient voxel tracing based on https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4\n// (with loop optimization by kzy) which implements DDA based on http://lodev.org/cgtutor/raycasting.html\n// Basic functionality (intersection & raymarching primitives) based on iq's https://iquilezles.org/articles/distfunctions\n\n// tags: 3d, raymarching, raycasting, voxel, dda, textured, subobjects, walls, stairs, staircase\n\nfloat hash13(vec3 p3) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n#define MAX_DIST 1000.0\n\n// https://iquilezles.org/articles/intersectors\nvec2 boxIntersection( in vec3 ro, in vec3 rd, vec3 boxSize )\n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat box2d(vec2 p)\n{\n    vec2 q = abs(p) - vec2(1.0);\n    return min(max(q.x,q.y), float(0.0)) + length(max(q, float(0.0)));\n}\n\n// https://www.shadertoy.com/view/NddGWs 2d Infinite Stairs SDF (my stairs function, improved by iq)\nfloat infinite_stairs_even2d(vec2 p, float n)\n{\n    p *= n; // scale by number of stairs\n    p = vec2(p.x+p.y,p.x-p.y)/float(4.0);\n    p = fract(p.x) + vec2(p.y,-p.y);\n    p = float(2.0)*p-float(1.0);\n    return box2d(p) / n;\n}\n\nfloat infinite_stairs_even(vec3 p, float n)\n{\n    return infinite_stairs_even2d(vec2(p.y, p.z), n);\n}\n\nfloat finite_stairs_even(vec3 p, float n)\n{\n    return max(infinite_stairs_even(p + 0.5 / n, n * 2.0), sdBox(p, vec3(1.0) / 2.0));\n    //return max(infinite_stairs_even(p + 0.5 / n - iTime * 0.1, n * 2.0), sdBox(p, vec3(1.0) / 2.0));\n}\n\n#define halfwallsize (1.0/32.0)\n\nfloat sdMixed(vec3 p, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    float d = MAX_DIST;\n    if(walls0.x) d = min(d, sdBox(p + vec3(0.5 - halfwallsize, 0.0, 0.0), vec3(halfwallsize, 0.5, 0.5)));\n    if(walls0.y) d = min(d, sdBox(p + vec3(0.0, 0.5 - halfwallsize, 0.0), vec3(0.5, halfwallsize, 0.5)));\n    if(walls0.z) d = min(d, sdBox(p + vec3(0.0, 0.0, 0.5 - halfwallsize), vec3(0.5, 0.5, halfwallsize)));\n    if(walls1.x) d = min(d, sdBox(p - vec3(0.5 - halfwallsize, 0.0, 0.0), vec3(halfwallsize, 0.5, 0.5)));\n    if(walls1.y) d = min(d, sdBox(p - vec3(0.0, 0.5 - halfwallsize, 0.0), vec3(0.5, halfwallsize, 0.5)));\n    if(walls1.z) d = min(d, sdBox(p - vec3(0.0, 0.0, 0.5 - halfwallsize), vec3(0.5, 0.5, halfwallsize)));\n    //if(idx == 1u) d = min(d, sdBox(p, vec3(0.25)));\n    if(idx == 1u) d = min(d, finite_stairs_even(p.xyz, 8.0));\n    if(idx == 2u) d = min(d, finite_stairs_even(p.yxz, 8.0));\n    if(idx == 3u) d = min(d, finite_stairs_even(p.xyz * vec3(1,1,-1), 8.0));\n    if(idx == 4u) d = min(d, finite_stairs_even(p.yxz * vec3(1,1,-1), 8.0));\n    return d;\n}\n\n#define halfboundsize 6\n\n#define PI 3.1415926\n\nfloat checker(vec3 p)\n{\n    //return step(0.5, length(1.0 - abs(2.0 * fract(p) - 1.0))); // dots\n    return step(0.0, sin(PI * p.x + PI/2.0)*sin(PI *p.y + PI/2.0)*sin(PI *p.z + PI/2.0));\n    //return step(0.0, sin(p.x)*sin(p.y)*sin(p.z));\n}\n\nfloat blob(vec3 p)\n{\n    return step(0.5, length(fract(p)-0.5));\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define EPSILON 0.001\n\n// raymarch subobject\nfloat march(vec3 ro, vec3 rd, float tmin, float tmax, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    for(float t = tmin; t < tmax;)\n    {\n        float h = sdMixed(ro + rd * t, walls0, walls1, idx);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return MAX_DIST;\n}\n\n// based on https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p, bvec3 walls0, bvec3 walls1, uint idx)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdMixed(p + k.xyy * h, walls0, walls1, idx) +\n                     k.yyx * sdMixed(p + k.yyx * h, walls0, walls1, idx) +\n                     k.yxy * sdMixed(p + k.yxy * h, walls0, walls1, idx) +\n                     k.xxx * sdMixed(p + k.xxx * h, walls0, walls1, idx));\n}\n\nbvec3 getWalls(ivec3 cell)\n{\n    //vec3 threshold = vec3(0.1, 0.1, 0.5);\n    //return lessThan(vec3(texelFetch(iChannel0, cell + 0 + halfboundsize, 0)), threshold); // use with random RGB volume\n    uvec3 code = uvec3(0, 0, 0); // WORKAROUND: use uvec3 min/max as replacement for missing bvec and/or\n    // ground plate\n    if(cell.z == -(halfboundsize-1)) code = max(code, uvec3(0, 0, 1));\n    // staircase-platforms\n    if(cell.x == -1 && cell.y == -1) code = max(code, uvec3(0, 0, 1));\n    if(cell.x == +1 && cell.y == -1) code = max(code, uvec3(0, 0, 1));\n    if(cell.x == +1 && cell.y == +1) code = max(code, uvec3(0, 0, 1));\n    if(cell.x == -1 && cell.y == +1) code = max(code, uvec3(0, 0, 1));\n    // elevator\n    if(cell.x == 0 && cell.y == 0) code = max(code, uvec3(1, 1, 0));\n    if(cell.x == 1 && cell.y == 0) code = max(code, uvec3(1, 0, 0));\n    if(cell.x == 0 && cell.y == 1) code = max(code, uvec3(0, 1, 0));\n    return bvec3(code);\n}\n\nuint getIdx(ivec3 cell)\n{\n    //return texelFetch(iChannel1, cell + 0 + halfboundsize, 0).x > 0.5 ? 1u : 0u;\n    //return uint(floor(texelFetch(iChannel1, cell + 0 + halfboundsize, 0).x * 8.0)); // use with random value volume\n    // staircase\n    if(cell.x == -1 && cell.y ==  0) return 1u;\n    if(cell.x ==  0 && cell.y == +1) return 2u;\n    if(cell.x == +1 && cell.y ==  0) return 3u;\n    if(cell.x ==  0 && cell.y == -1) return 4u;\n    return 0u;\n}\n\n// voxel with environment (3x3x3) slow!\nfloat sdMixedWithEnv(ivec3 cell, vec3 offset)\n{\n    float d = MAX_DIST;\n    for(int z = -1; z <= +1; z++)\n    {\n        for(int y = -1; y <= +1; y++)\n        {\n            for(int x = -1; x <= +1; x++)\n            {\n                bvec3 walls0 = getWalls(cell + ivec3(x, y, z));\n                bvec3 walls1 = // can this be optimized?\n                    bvec3\n                    (\n                        getWalls(cell + ivec3(x, y, z) + ivec3(1,0,0)).x,\n                        getWalls(cell + ivec3(x, y, z) + ivec3(0,1,0)).y,\n                        getWalls(cell + ivec3(x, y, z) + ivec3(0,0,1)).z\n                    );\n                uint idx = getIdx(cell + ivec3(x, y, z));\n                d = min(d, sdMixed(offset - vec3(x, y, z), walls0, walls1, idx));\n            }\n        }\n    }\n    return d;\n}\n\n// https://www.shadertoy.com/view/Xds3zN Raymarching - Primitives by iq\n// https://iquilezles.org/articles/distfunctions\nfloat calcAO(vec3 pos, vec3 nor)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.12*float(i) / 4.0;\n        ivec3 cell = ivec3(floor(pos + h*nor));\n        //uint id = getVoxelIndex(cell);\n        //float d = SDF_Voxel(pos + h*nor - vec3(cell) - vec3(0.5), id);\n        float d = sdMixedWithEnv(cell, pos + h*nor - vec3(cell) - vec3(0.5));\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if(occ > 0.35) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0);\n}\n\n#define MAX_RAY_STEPS 64\n\nstruct result\n{\n    float dist;\n    ivec3 cell;\n};\n\nresult voxelray(vec3 rayPos, vec3 rayDir)\n{\n    result res;\n\n    vec3 deltaDist = 1.0 / abs(rayDir);\n    ivec3 rayStep = ivec3(sign(rayDir));\n    res.dist = MAX_DIST;\n    res.cell = ivec3(floor(rayPos));\n    \n    vec3 sideDist = (sign(rayDir) * (vec3(res.cell) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; // Setup of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to avoid crash on some systems\n    {\n        //if (all(lessThanEqual(sign(rayDir) * vec3(res.cell), vec3(halfboundsize)))) // proceed until ray LEAVES level-box (but ENTER is OK, so level can be seen from outside)\n        if(all(lessThan(abs(res.cell), ivec3(halfboundsize)))) // odd\n        //if(all(greaterThanEqual(cell, -ivec3(halfboundsize))) && all(lessThan(cell, ivec3(halfboundsize)))) // even\n        {\n            bvec3 walls0 = getWalls(res.cell + 0);\n            bvec3 walls1 = // can this be optimized?\n                bvec3\n                (\n                    getWalls(res.cell  + ivec3(1,0,0)).x,\n                    getWalls(res.cell  + ivec3(0,1,0)).y,\n                    getWalls(res.cell  + ivec3(0,0,1)).z\n                );\n            uint idx = getIdx(res.cell);\n            if(any(walls0) || any(walls1) || idx > 0u) // skip empty voxels\n            {\n                // Near bounding-box side can be reconstructed from dda, howvever we need far bounding-box side, too.\n                // float d = length(vec3(mask) * (sideDist - deltaDist)) / length(rayDir);\n                // It appears to be easier to just do the box-intersection here (potential for optimization).\n                vec2 bounds = boxIntersection( rayPos - vec3(res.cell) - vec3(0.5), rayDir, vec3(0.5) ); // bounding box\n\n                uint id = getIdx(res.cell);\n                bvec3 walls0 = getWalls(res.cell);\n                bvec3 walls1 = // can this be optimized?\n                    bvec3\n                    (\n                        getWalls(res.cell + ivec3(1,0,0)).x,\n                        getWalls(res.cell + ivec3(0,1,0)).y,\n                        getWalls(res.cell + ivec3(0,0,1)).z\n                    );\n                if(any(walls0) || any(walls1) || id != 0u)\n                {\n                    float dist = march(rayPos - vec3(res.cell) - vec3(0.5), rayDir, bounds.x, bounds.y, walls0, walls1, idx);\n\n                    if(dist >= bounds.x && dist <= bounds.y)\n                    {\n                        if(dist >= 0.0) // required to catch corner-cases when ray starts in wall behind camera (duplicate close objects bug)\n                        {\n                            res.dist = dist;\n  \n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // \"The raycasting code is somewhat based around a 2D raycasting toutorial found here:\n        //  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n        // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n        bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        sideDist += vec3(mask) * deltaDist;\n        res.cell += ivec3(vec3(mask)) * rayStep;\n    }\n\n    return res;\n}\n\n// Coordinate-systems:\n//  * camera-coordinates: x,y aligned with screen, z towards viewer\n//  * world-coordinates: map-on-table, i.e. x,y on the map with additional z-coordinate for height\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 camx = vec3(1.0, 0.0, 0.0);\n    vec3 camy = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 camz = vec3(0.0, 0.0, 1.0);\n    vec3 rayPos = vec3(0.0, mix(2.0, 0.5, (0.5 - 0.5 * cos(iTime/10.0))) * float(halfboundsize), 0.0);\n\n    vec3 rayDir = screenPos.x * camx + screenPos.y * camy + camz;\n    rayDir.yz = mat2(vec2(0.0, 1.0), vec2(-1.0, 0.0)) * rayDir.yz;\n\n    mat2 R = rotate(1.0 * iTime / 5.0);\n    rayPos.xy = R * rayPos.xy;\n    rayDir.xy = R * rayDir.xy;\n\n    rayDir = normalize(rayDir);\n\n    vec3 color = vec3(0.0);\n    result res = voxelray(rayPos, rayDir);\n\n    if(res.dist < MAX_DIST)\n    {\n        uint idx = getIdx(res.cell);\n        bvec3 walls0 = getWalls(res.cell);\n        bvec3 walls1 = // can this be optimized?\n            bvec3\n            (\n                getWalls(res.cell + ivec3(1,0,0)).x,\n                getWalls(res.cell + ivec3(0,1,0)).y,\n                getWalls(res.cell + ivec3(0,0,1)).z\n            );\n        vec3 dst = rayPos + rayDir * res.dist;\n        \n        vec3 n = normal(dst - vec3(res.cell) - vec3(0.5), walls0, walls1, idx);\n        //color = vec3(1.0); // plain\n        //color = 0.5 + 0.5 * vec3(texture(iChannel0, 0.1 * vec3(cell))); // some random colors to improve visualization\n        color = 0.5 + 0.5 * hash33(0.1 * vec3(res.cell)); // some random colors to improve visualization\n        //color = 0.5 + 0.5 * normalize(result.xyz); // normal colors\n\n        //color *= texture(iChannel0, dst).xyz;\n        //color *= vec3(0.5 + 0.5 * checker(dst * 8.0));\n        //color *= vec3(0.5 + 0.5 * checker(dst));\n        //color *= vec3(0.5 + 0.5 * blob(dst));\n        //color *= 0.5 + 0.5 * vec3(texture(iChannel0, dst)); // 3d texture\n        //color *= 0.5 + 0.5 * hash33(dst); // 3d texture\n\n        vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n        //vec3 fogcolor = vec3(0.75, 0.6, 0.3); // smog\n        color *= mix(fogcolor, color, exp(-res.dist * res.dist / 200.0)); // fog for depth impression & to suppress flickering\n\n        float ao = calcAO(rayPos + rayDir * res.dist, n);\n        vec3 lightdir = normalize(vec3(1.0,-2.0, 3.0));\n        result shadow = voxelray(dst, lightdir);\n        float brightness = 0.1 * ao + max(dot(lightdir, n), 0.0) * step(MAX_DIST, shadow.dist);\n    \n        color *= brightness;\n    }\n    \n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}