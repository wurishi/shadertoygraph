{"ver":"0.1","info":{"id":"dstSRS","date":"1680035739","viewed":123,"name":"Procedural grass texture","username":"ianertson","description":"grass texture","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["texture","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\nfloat noise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash21(id, seed), hash21(id+vec2(1,0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1,1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise23(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash23(id, seed), hash23(id+vec2(1,0), seed), lv.x),\n        mix(hash23(id+vec2(0, 1), seed), hash23(id+vec2(1,1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise23(in vec2 p, in float seed, in float freq, const in int octaves) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < octaves; i++) {\n        n += amp * noise23(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return clamp(1.0-length(pa - ba * h)/t, 0.0, 1.0);\n}\n\nvec3 blade(in vec2 uv, in vec2 id, in float seed, inout float edge, inout float cracks, in float i) {\n    vec3 col = vec3(0.0);\n    \n    float discrd = fract((id.x+id.y+seed*10.293891)*6.69491);\n    if (floor(discrd+0.69) <= 0.0) return col;\n    \n    float r1 = noise((0.5-id)*0.10, seed*2.+0.392912);\n    \n    \n    uv *= rot(sin(r1*6.28)*3.14);\n    \n    float r2 = fract((r1*30.3298289125)+id.x*3.29912+id.y);\n    float r3 = fract(r1+r2*(id.x+id.y)*16.0932882);\n    \n    uv.y *= mix(1.0, 0.8, r2*r2);\n    uv.x *= mix(1.0, 1.5, r2*r2);\n    \n    uv *= mix(1.0, 1.9, r3*r3);\n    \n    vec3 c1 = rgb(102, 146, 18);\n    vec3 c2 = rgb(70, 127, 0);\n    vec3 c3 = rgb(108, 108, 44);\n    vec3 c4 = rgb(205, 176, 77);\n    vec3 c5 = rgb(159, 144, 78);\n    vec3 c6 = rgb(19, 57, 6);\n    \n    vec3 hf1 = noise23(uv, seed+7.798391, 32.0, 3);\n    vec3 gc1 = mix(c1, c2, hf1.x);\n    vec3 gc2 = mix(c3, c4, hf1.y);\n    vec3 gc3 = mix(c5, c6, hf1.z);\n    vec3 g1 = mix(gc1, gc2, hf1.z);\n    vec3 g2 = mix(gc2, gc3, hf1.x);\n    vec3 g = (g1+g2)*0.5;\n    \n    float tint = noise(id+0.93281, seed+3.392912);\n    g = mix(g, g*g, tint);\n    \n    float len = 0.9;\n    \n    float s = 1.0-smoothstep(0.0, len/2., uv.y);\n    \n    vec2 start = vec2(0.09*s, -len/2.);\n    vec2 end = vec2(0.09*s, len/2.);\n    vec2 ba = end - start;\n    start.x -= 0.3*smoothstep(0.1, -0.04, uv.y+0.5);\n    vec2 e = (start-end).yx;\n    float dp = dot(vec2(abs(uv.x), -0.5)-vec2(s*0.09, -1.2), e);\n    col += smoothstep(0.0, 0.01, dp);\n    \n    float ithick = i*0.009;\n    float ll = line(vec2(abs(uv.x), uv.y), start, end, 0.01+ithick);\n    col += ll;\n    edge = line(vec2(abs(uv.x), uv.y), start, end, 0.3+ithick);\n    \n    float nn = noise((uv*2.)+hf1.xy, seed+3.392891);\n    float nn2 = noise((uv*3.)+(hf1.zx*0.05), seed+0.00923981);\n    cracks = 1.0-smoothstep(0.02, 0.1, abs(nn2*2.0-1.0));\n    float broken = smoothstep(0.3, 0.6, nn);\n    edge *= broken;\n\n    return clamp(col, 0.0, 1.0)*g*broken;\n}\n\nvec3 grassTexture(in vec2 uv, in float seed, inout vec3 norm) {\n    vec3 col = vec3(0.0);\n    float tile = 3.0;\n    \n    vec3 c1 = rgb(102, 146, 18);\n    vec3 c2 = rgb(70, 127, 0);\n    vec3 c3 = rgb(108, 108, 44);\n    vec3 c4 = rgb(205, 176, 77);\n    vec3 c5 = rgb(159, 144, 78);\n    vec3 c6 = rgb(19, 57, 6);\n    vec3 hf1 = noise23(uv, seed, 32.0, 3);\n    vec3 gc1 = mix(c1, c2, hf1.x);\n    vec3 gc2 = mix(c3, c4, hf1.y);\n    vec3 gc3 = mix(c5, c6, hf1.z);\n    vec3 g1 = mix(gc1, gc2, hf1.z);\n    vec3 g2 = mix(gc2, gc3, hf1.x);\n    vec3 g = (g1+g2)*0.5;\n    \n    float cracks = 0.0;\n    float iterations = 16.0;\n    float e = 0.0;\n    float lum = 0.0;\n    for (float i = 0.0; i < iterations; i++) {\n        float mag = max(0.89, 1.0-((i+1.)/8.));\n        vec2 id = floor(uv*tile);\n        vec2 lv = fract(uv*tile);\n        float e2 = 0.0;\n        float cracks2 = 0.0;\n        vec3 b = mag*blade(0.5-lv, id, seed, e2, cracks2, i);\n        lum += luma(b);\n        cracks += cracks2;\n        float lb = (luma(b)+length(b))/2.;\n        e = max(e, e2*mag);\n        col = max(col, b);\n        uv *= mat2(6.28, 8.0, -6.28, 8.0)*0.1;\n        uv += 0.03;\n        seed += 3.3092912;\n        uv *= 1.16;\n    }\n    cracks /=  (0.9032821+lum);\n    e = smoothstep(0.7, 1.2, e);\n    col = mix(col, g, smoothstep(0.5, 0.0, length(col)));\n    col = mix(col, col*0.25*col, e);\n    col = mix(col, col*gc2, smoothstep(0.7, 1.5, cracks));\n    norm = vec3(dFdx(luma(col)-e), dFdy(luma(col)-e),  -0.89);\n    return col / M_PI;\n}\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec2 uv = (fc-0.5*R.xy)/R.y;;\n    vec3 col = vec3(0.0);\n    float moveT = (T+3.229815)*0.025;\n    \n    vec3 norm = vec3(0.0);\n    uv *= 0.25+1.5*(0.5 + sin((T+22.75)*1.5) * 0.5);\n    \n    if (iMouse.z > 0.001) {\n        vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n        uv += m*2.;\n    } else {\n        uv += vec2(cos(moveT), sin(moveT))*0.25;\n    }\n    col += grassTexture(uv, 0.3929821, norm);\n    \n    vec3 L = normalize(vec3(1, 2, -1.));\n    vec3 Lpos = vec3(sin(T), cos(T), 0.)*0.5;\n    float dist = distance(uv, Lpos.xy);\n    float NdotL = max(0.05, dot(norm, L));\n    col *= NdotL*max(0.7, 4.0/max(0.6, pow(dist, 2.)));\n    \n    col += luma(col)/2.5;\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    O = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}