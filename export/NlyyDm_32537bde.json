{"ver":"0.1","info":{"id":"NlyyDm","date":"1673109049","viewed":25,"name":"3dmodelingstuff","username":"MatthewBanyas","description":"description","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdfs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 BACKGROUND = vec3(0.8, 0.9, 1.0);\nfloat THRESHOLD_FOR_HIT = 0.01;\n\nfloat sdfSphere(vec3 p, vec3 center, float radius) {\n    // write the sdf for a sphere centered at <0, 0, -10> with radius 5, or something.\n    vec3 shifted = p - center;\n    \n    // dot(p, p) = p.x^2 + p.y^2 + p.z^2\n    float dist = sqrt(dot(shifted, shifted)) - radius;\n    return dist;\n}\n\n// THE SDF :3\nfloat sdf(vec3 p) {\n    return min(\n        sdfSphere(p, vec3((10.0 * sin(iTime)-15.0), 3.0 * sin(iTime), -20.0), 10.0),\n        //sdfSphere(p, vec3(3.0, -3.0 * sin(iTime), -20.0), 4.0),\n        sdfSphere(p, vec3(3.0, 3.0, (10.0 * sin(iTime)-15.0)), 3.0)\n    );\n}\n\n\nvec3 ambient() {\n    //ambient reflection constant & ambient lighting color\n    float ambrconst = 0.6;\n    vec3 ambrlcolor = vec3(0.7, 0.7, 0);\n\n    vec3 ambient = ambrconst * ambrlcolor;\n    return ambient;\n}\n\nvec3 calculateNormal(vec3 p) {\n    float thr = THRESHOLD_FOR_HIT;\n    return normalize(vec3(\n        sdf(vec3(p.x+thr, p.y, p.z)) - sdf(vec3(p.x-thr, p.y, p.z)),\n        sdf(vec3(p.x, p.y+thr, p.z)) - sdf(vec3(p.x, p.y-thr, p.z)),\n        sdf(vec3(p.x, p.y, p.z+thr)) - sdf(vec3(p.x, p.y, p.z-thr))\n    ));\n}\n\nvec3 diffusion(vec3 p) {\n    vec3 pointNormal = calculateNormal(p);\n    vec3 lightPosition = vec3(15.0, 20.0, -5.0);\n    vec3 normallp = normalize(lightPosition - p);\n    //diffuse reflection constant\n    float diffrconst = 0.5;\n    float dotLN = dot(lightPosition, normallp);\n    //light intensity\n    vec3 lightint = vec3(0.7, 0.5, 0);\n    vec3 diffuse = diffrconst * dotLN * lightint;\n    return diffuse;\n}\n\nvec3 specularity(vec3 p, vec3 ray) {\n    vec3 pointNormal = calculateNormal(p);\n    vec3 lightPosition = vec3(15.0, 20.0, -5.0);\n    vec3 normallp = normalize(lightPosition - p);\n    //specular reflection constant\n    float specrconst = 0.6;\n    vec3 reflectedray = reflect(normallp, pointNormal);\n    //directionpointing toward viewer\n    vec3 viewerdirect = -ray;\n    float dotRefView = dot(reflectedray, viewerdirect);\n    \n    return vec3(0.0);  // TODO\n}\n\n\n\n// This is the RGB color of any solid at point p.\n// Be creative and you can make interesting textures.\nvec3 color(vec3 p, float distance_traveled, int maxloops) {\n    float floatloops = float(maxloops);\n    float ratio = 1.0 - distance_traveled/floatloops;\n    float quadcolor = -(pow(ratio-1.0, 2.0)) + 1.0;\n    float lincolor = ratio;\n    float sqrtcolor = sqrt(ratio);\n    float scolor2 = 1.1 - sqrt(-0.9*ratio + 1.0);\n    float floorcolor = 0.02 * floor(50.0*ratio);\n    \n    return vec3(floorcolor);\n    \n    //float fog_frac = 1.0 - 150.0 / (150.0 + distance_traveled * distance_traveled);\n    //return fog_frac * BACKGROUND + (1.0 - fog_frac) * vec3(fract(p.x), fract(p.y), 0.3);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // The screen will go from -1 to 1 in the p.y direction\n    // and -1.6-ish to 1.6-ish in the p.x direction (because it's correcting\n    // for the non-square aspect ratio).\n    float scale = 1.0;\n    vec2 screen_coord = fragCoord - vec2(iResolution.x/2.0, iResolution.y/2.0);\n    screen_coord *= 2.0/iResolution.y * 0.5;\n    \n    // Simple assumption: the camera is at the origin (0, 0, 0)\n    // Up is +y, right is +x, TOWARD the camera is +z (weird!)\n    // So objects that show up in the camera's field of view\n    // will have a negative z coordinate.\n    \n    // trace is where we are (and we'll be changing this as we step forward);\n    // ray is a unit vector in the direction we'll be going.\n    vec3 trace = vec3(5.0 * cos(iTime), 4.0 * sin(iTime * 2.0), 0.0);\n    vec3 ray = normalize(vec3(screen_coord.x, screen_coord.y, -1.0));\n    \n    int max_loops_allowed = 64;\n    \n    // Here, do a for loop (or a while) where we do the following:\n    //  1. get the sdf in 3d for the current trace\n    //  2. if the sdf is within a certain threshold of 0.0, or it's negative,\n    //      we have reached our target; we're on the surface of a 3d solid.\n    //      we can break out of the loop and assign the point a color.\n    //  3. if the sdf is above a large number (maybe 100), assume our ray\n    //      has exited the level and we can draw a background color.\n    //  4. if neither of these cases, step trace forward by ray * sdf_value.\n\n    fragColor = vec4(BACKGROUND, 1.0);\n    float distance_traveled = 0.0;\n    \n    for (int cycle = 1; cycle <= max_loops_allowed; cycle++) {\n        float dist = sdf(trace);\n        \n        if (dist <= THRESHOLD_FOR_HIT) {\n            //fragColor = vec4(color(trace, distance_traveled, max_loops_allowed), 1.0);\n            fragColor = vec4(calculateNormal(trace)*0.5+vec3(0.5), 1.0);\n            break;\n        }\n        \n        if (dist > 100.0) {\n            fragColor = vec4(BACKGROUND, 1.0);\n            break;\n        }\n        \n        trace += ray * dist;\n        distance_traveled += dist;\n    }\n\n    //fragColor = vec4(fract(p.x), fract(p.y), 0.2, 1.0);\n}","name":"Image","description":"","type":"image"}]}