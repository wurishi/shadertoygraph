{"ver":"0.1","info":{"id":"MldcR4","date":"1531859431","viewed":175,"name":"01_Oscilloscope","username":"CptSloth199","description":"Oscilloscope with an interactive Cursor that follows the Curve. This is my first shader in glsl, feel free to play with the settings on the right and leave feedback. :D","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["oscilloscope","interactive","green","curve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Anti Stretch, thanks to Abvadabra\n    float ScreenScaleAdj = iResolution.x / iResolution.y;\n    uv.x *= ScreenScaleAdj;\n    \n    //This will look really dumb if it turns out there is a predefined constant in GLSL....\n    float Pi = 3.14;\n    \n    \n    //////////////////////////////////////////////////////\n    //                  ---SETTINGS---                  //\n    //////////////////////////////////////////////////////\n    \n    \n\n    //Set what Version to use!\n    bool UseSmoothVersion = true;\n    \n    //Automatic Version Switching\n    bool AlternateVersions = false;\n    \n    //Switching Version Interval\n    float IntervalV = 5.0;\n    \n    \n    \n    //Distortion Mode (0-5)\n    int DistortionMode = 5;\n    \n    //Automatic Mode Switching\n    bool AlternateModes = true;\n    \n    //Distortion\n    float Distortion = 15.2;\n    \n    //Switching Mode Interval\n    float IntervalM = .15;\n    \n    \n    \n    //Set Line Color\n    vec3 LineColBase = vec3(0.0,0.6,0.0);\n    \n    //Set Line Color2\n    vec3 LineColCurve = vec3(0.0,1.0,0.0);\n    \n    \n    \n    //Set Curve Speed\n    float CurveSpeed = 2.0;\n    \n\n    //Scale X Axis\n    float CurveXScale = Pi * 4.0;\n    \n    \n    //Scale Y Axis\n    float CurveYScale = 0.6;\n    \n    \n    //Set Line Width\n    float LineWidth = 4.0/iResolution.y;\n    \n    \n    //Set Sharpness (Only Smooth Version)\n    float LineSharpness = 65.0;\n    \n    \n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////\n    \n    \n    \n    //ReaderHead Effect\n    float ReaderHeadLocation = iMouse.x/iResolution.x * (ScreenScaleAdj);\n    \n    \n    //Timed Switches\n    if(AlternateVersions){\n        if (mod (iTime, IntervalV)< IntervalV * 0.5)\n            UseSmoothVersion = true;\n        else\n            UseSmoothVersion = false;\n    }\n    \n    if(AlternateModes){\n        DistortionMode = int(mod((iTime * IntervalM),6.0));\n        \n    }\n    \n    \n    vec3 LineCol = vec3(1.0,1.0,0.0);\n    \n    //Background Color\n    float BackGrndCol = 0.5;\n    vec3 BackGrnd = abs(uv.y-0.5)*vec3(BackGrndCol,BackGrndCol,BackGrndCol);\n    \n    \n    //Grid\n    vec3 GridPatternX = pow(clamp(sin(uv.x*100.0),0.0,1.0),55.0)* abs(pow(clamp(sin(uv.y*100.0),0.0,1.0),1.0)-1.0)*vec3(1.0,1.0,1.0);\n    vec3 GridPatternY = pow(clamp(sin(uv.y*100.0),0.0,1.0),55.0)* abs(pow(clamp(sin(uv.x*100.0),0.0,1.0),1.0)-1.0)*vec3(1.0,1.0,1.0);\n    vec3 GridPattern =  max(vec3(GridPatternX),vec3(GridPatternY))*LineColBase*0.1;   \n        \n      \n\n    \n    //Generate Curve\n        \n    float CurveVal = 0.0;\n    \n    //MODE 0\n    if (DistortionMode == 0)\n    CurveVal = sin(iTime * CurveSpeed + (uv.x * CurveXScale)) * CurveYScale;     \n    //MODE 1\n    if (DistortionMode == 1)\n    CurveVal = sin(iTime * CurveSpeed * (mod (uv.x*Distortion,1.0))  + (uv.x * CurveXScale)) * CurveYScale; \n    //MODE 2\n    if (DistortionMode == 2)    \n    CurveVal = sin(iTime * CurveSpeed  + (uv.x * CurveXScale) * CurveYScale) * (mod (uv.x*Distortion,1.0));\n    //MODE 3\n    if (DistortionMode == 3)\n    CurveVal = sin(iTime * CurveSpeed + (uv.x * CurveXScale)) * CurveYScale + (sin(iTime + (uv.x * CurveXScale*Distortion)) * CurveYScale) * 0.2;\n    //MODE 4\n    if (DistortionMode == 4)\n    CurveVal = sin(iTime * CurveSpeed + ((uv.x+(sin(iTime))*0.3) * CurveXScale)) * CurveYScale + (sin(iTime + (uv.x * CurveXScale*Distortion)) * CurveYScale) * 0.2;\n    //MODE 5\n    if (DistortionMode == 5)\n    CurveVal = sin(iTime * CurveSpeed + (uv.x * CurveXScale * min(uv.x * CurveXScale,abs( uv.x - ScreenScaleAdj))*1.2)) * CurveYScale;  \n    \n    \n    \n     //ScanLineTool\n    float ScanLineXPos = 0.0;\n    float ScanLineYPos = ReaderHeadLocation;\n    if (DistortionMode == 0)\n    ScanLineXPos = (sin(iTime * CurveSpeed + (ScanLineYPos * CurveXScale)) * CurveYScale + 1.0) * 0.5; \n    if (DistortionMode == 1)\n    ScanLineXPos = (sin(iTime * CurveSpeed * (mod (ScanLineYPos*Distortion,1.0))  + (ScanLineYPos * CurveXScale)) * CurveYScale + 1.0) * 0.5;   \n    if (DistortionMode == 2)  \n    ScanLineXPos = (sin(iTime * CurveSpeed  + (ScanLineYPos * CurveXScale) * CurveYScale) * (mod (ScanLineYPos*Distortion,1.0)) + 1.0) * 0.5; \n    if (DistortionMode == 3)\n    ScanLineXPos = (sin(iTime * CurveSpeed + (ScanLineYPos * CurveXScale)) * CurveYScale + (sin(iTime + (ScanLineYPos * CurveXScale*Distortion)) * CurveYScale) * 0.2 + 1.0) * 0.5;\n    if (DistortionMode == 4)\n    ScanLineXPos = (sin(iTime * CurveSpeed + ((ScanLineYPos+(sin(iTime))*0.3) * CurveXScale)) * CurveYScale + (sin(iTime + (ScanLineYPos * CurveXScale*Distortion)) * CurveYScale) * 0.2 + 1.0 ) * 0.5;\n    if (DistortionMode == 5)\n    ScanLineXPos = (sin(iTime * CurveSpeed + (ScanLineYPos * CurveXScale * min(ScanLineYPos * CurveXScale,abs( ScanLineYPos - ScreenScaleAdj))*1.2)) * CurveYScale + 1.0) * 0.5;\n    vec3 ScanLineTool = max(pow(abs(distance(uv.y,ScanLineXPos)-1.0),255.0) , pow(abs(distance(uv.x,ScanLineYPos)-1.0),255.0))*LineColBase;\n    \n    \n    //Circle\n    vec2 CircleOutLocation = vec2(ScanLineYPos,ScanLineXPos);\n    float CircleOut = abs(clamp(pow(distance(vec2(uv.xy) , CircleOutLocation)*28.0,32.0),0.0,1.0)-1.0);\n    float CircleIn = abs(clamp(pow(distance(vec2(uv.xy) , CircleOutLocation)*32.0,32.0),0.0,1.0)-1.0);\n    vec3 ScanCircle = (CircleOut-CircleIn) * LineColBase ;\n    \n    \n    //Move Curve from 1<->-1 to 1<->0\n    float NormCurveVal = (CurveVal + 1.0) * 0.5;\n    \n    \n    \n    if (!UseSmoothVersion){\n    \n   \n    //Color it with LineWidth margin\n    if (NormCurveVal+LineWidth*0.5 > uv.y && NormCurveVal - LineWidth*0.5 < uv.y)\n        LineCol = LineColCurve;   \n    else         \n   \t\tLineCol = vec3(0.0,0.0,0.0);\n        \n        \n    // Output Simple Version to Screen\n\tfragColor = vec4(max(LineCol,(BackGrnd+GridPattern) + ScanLineTool + ScanCircle),1.0);\n    }\n    \n    else\n        \n    {\n    \n    \n    //Move Curve from 1<->-1 to 1<->0\n    float NormCurveVal = (CurveVal + 1.0) * 0.5;\n    \n    vec2 CheckLoc = vec2((uv.x),NormCurveVal);\n    vec2 AntiCurveSmooth = vec2(max(uv-CheckLoc,CheckLoc-uv));\n    AntiCurveSmooth = abs(vec2 (AntiCurveSmooth)-1.0);\n    float AntiCurveSharp =  pow(AntiCurveSmooth.y, LineSharpness);\n    \n    // Output Smooth Version to Screen\n    fragColor = vec4(max(vec3(AntiCurveSharp * LineColCurve),(BackGrnd+GridPattern)),1.0)+vec4(ScanLineTool + ScanCircle,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}