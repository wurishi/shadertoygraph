{"ver":"0.1","info":{"id":"WlsXDl","date":"1617801906","viewed":215,"name":"Glitch Rider (4k intro)","username":"slerpy","description":"[url]https://www.pouet.net/prod.php?which=82612[/url]","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["demo","attempt","data","mashing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This is the intro fork of\n// \"Data Moshing Effect\"\n// https://www.shadertoy.com/view/tlsSRs\n//\n// If you want to understand how the effect works\n// I highly recommend checking out that one instead.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = vec4(iResolution.xy, iTime, iFrame);\n    \n    //fragColor=10.*abs(texelFetch(iChannel0,ivec2(fragCoord),0).wwww-R.z);return;\n    \n    // debug\n#if(DEBUG_GEOMETRY)\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    return;\n#endif\n    \n    //fragColor = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    //return;\n    \n    // init random vec\n   \tvec4 rv = vec4(fragCoord, R.zw);\n    for(int i=0; i<8; i++)rv = fract(1e4*sin(rv) + rv.wxyz);\n    \n    // fetch buffer a\n    ivec2 u = ivec2(fragCoord);\n    vec4 tex = texelFetch(iChannel0, u, 0);\n    if(int(R.w) % SKIPS != 0 && tex.w > 0.)u = ivec2(tex.xy);\n    \n    // fetch buffer b\n    vec4 col = clamp(texelFetch(iChannel1, u, 0), .0, 1.);\n    col = mix(col, smoothstep(.0, 1., col), vec4(1, .5, 0, 0));\n    col *= smoothstep(.0, 5., R.z) * smoothstep(120., 115., R.z);\n    fragColor = pow(col, vec4(.45)) + .05 * (rv - rv.wzyx);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"int S;\nbool alt;\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p); p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p*=p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat map(vec3 p)\n{\n    float d = 1e4, t = d;\n    vec3 q = p;\n    \n    // bumpy wall\n    if(S==0)\n    {\n        p.xy *= rot(.3);\n        t = .2 * noise(floor(4.*p.xyy));\n        d = -.4*(p.z+t);\n        alt = t > .10;\n    }\n    \n    // inf grid\n    else if(S==1)\n    {\n        //d = 2.-abs(p.y);\n        p = abs(fract(p)-.5);\n        q = min(p, p.zxy);\n        //d = min(d,max(max(q.x, q.y), q.z) - 0.1);\n        d = max(max(q.x, q.y), q.z) - 0.1;\n        alt = abs(max(max(p.x,p.y),p.z)-0.4) < .03;\n    }\n    \n    // cube in sphere\n    else if(S==2)\n    {\n        p = abs(p);\n        q = max(p, p.zxy);\n        d = min(min(12.-length(p), 3.-min(min(q.x, q.y), q.z)), min(\n            t=length(max(p-1.,0.)),\n            max(.9-min(min(q.x, q.y), q.z), max(q.x, q.y)-1.2))\n        );\n        \n        alt = (t == d);\n    }\n    \n    // spiral tunnel\n    else if(S==3)\n    {\n        p.xy *= rot(.2*p.z);\n        q.xy = abs(p.xy);\n        q = min(q,q.yxz);\n        d = 1.-q.x;\n        q = sign(p);\n        alt = q.x == q.y;\n    }\n    \n    // cubes over plane\n    else if(S==4)\n    {\n        p.xy *= rot(-2. / 8.);\n        d = -p.z;\n        q = abs(fract(p)-.5);\n        q = max(q, q.zxy);\n        d = min(d, t=max(q.x, q.y) - .16);\n        alt = (t == d);\n    }\n    \n    // 256b\n    else if(S==5)\n    {\n        q = abs(p);\n        d = max(-p.z, 1.-max(q.x, q.z));\n        alt = fract(p.y-.25) < .5;\n    }\n    \n    return d;\n}\n\nmat3 cam(float t, out vec3 ro)\n{\n    //t -= mod(t, .45);\n    \n    vec3 to = (ro -= ro);\n    \n    if(R.z<16.65)\n    {\n        t = pow(smoothstep(1., 16.65, t), 1.7);\n        to.z = 100.;\n        ro.z = -2.;\n        ro.y = to.y = 16.*t;\n        S = 0;\n    }\n    \n    else if(R.z<33.24)\n    {\n        t = pow(smoothstep(16.65, 33.24,t), .8);\n        ro.z = 8.*t;\n        to = vec3(-ro.z,0,8);\n        S = 1;\n    }\n    \n    else if(R.z<49.84)\n    {\n        t = smoothstep(33.24, 49.84, t);\n        ro.z = -2.5;\n        ro.y = 2.*t;\n        ro.xz *= rot(6.*ro.y);\n        S = 2;\n    }\n    \n    else if(R.z<67.22)\n    {\n        t = smoothstep(49.84, 67.22, t);\n        to.z = (ro.z = 32.*t) + 1.;\n        to.x = 1.;\n        S = 3;\n    }\n    \n    else if(R.z<83.03)\n    {\n        t = 3.*smoothstep(67.22, 83.03, t);\n        ro = to = vec3(4.*t, -t, -t-2.);\n       \tto.z += 1.;\n        S = 4;\n    }\n    \n    else if(R.z<99.62)\n    {\n        t = smoothstep(83.03, 99.62, t);\n        ro = to = vec3(0, 8.*t, -1.);\n       \tto.z += 1.;\n        S = 5;\n    }\n    \n    else\n    {\n        t = smoothstep(99.62, 140., t);\n        ro.y = 12.*t + 8.3;\n        t *= 4.*pi; \n        ro.xz = .01*vec2(cos(t),sin(t));\n        S = 1;\n    }\n    \n    /*else\n    {\n        t = smoothstep(95., 110., t);\n        to.z = 2.*(ro.z = -24.*(t-.5));\n        to.x = 1.;\n        S = 3;\n    }*/\n    \n    vec3 cw=normalize(to-ro);\n    vec3 cu=normalize(cross(vec3(0,1,0),cw));\n    vec3 cv=normalize(cross(cw,cu));\n    return mat3(cu,cv,cw);\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float m, t=0.1;\n    for(int i=0; i++<400;)\n        if(t+=m=map(ro+rd*t), m<0.01||t>32.)\n            break;\n    \n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = vec4(iResolution.xy, iTime, iFrame);\n    \n    ivec2 u = ivec2(fragCoord);\n    vec4 last = texelFetch(iChannel0, u, 0);\n    \n    // reset after color override\n    if(last.w < .0)\n    {\n        fragColor = vec4(fragCoord, 0, R.z);\n        return;\n    }\n    \n    // main trace\n    vec3 ro, rd = cam(R.z, ro) * normalize(vec3(2.*fragCoord-R.xy, R.y));\n    \n    float t = trace(ro, rd);\n    vec3 p = ro + rd * t;\n    \n    // occlusion trace\n    float pt = last.w;\n    mat3 m = cam(pt, ro);\n    \n    vec3 od = ro - p;\n    float odl = length(od);\n    bool occ = trace(p, od/max(odl,1e-8))-odl < 0.1;\n    \n    // back projection\n    vec2 coord = 0.5 * (od *= m, od.xy / od.z * R.y + R.xy);\n    \n    // out of range check\n    occ = occ || (floor(coord/R.xy) != vec2(0));\n    \n    // far plane check\n    if(t > 32.)occ = false;\n    \n    // debug\n#if(DEBUG_GEOMETRY)\n    map(p);\n    fragColor = vec4(exp(-0.2*t) * (.5 + .3 * fract(4.*p)) + .6*vec3(occ,alt,0), R.z);\n    return;\n#endif\n    \n    // color override\n    if(occ && R.w > 2.)\n    {\n        vec2 e = vec2(.0,.001);\n        vec3 n = normalize(map(p)-vec3(map(p-e.yxx),map(p-e.xyx),map(p-e.xxy)));\n        float ao = mix(5.*map(p+.2*n), 1., 0.85);\n        \n        vec3 q = round(8.*p);\n        for(int i=0; i<8; i++)q = fract(1e4*sin(q) + q.zxy);\n        \n        vec3 c = ao * vec3(exp(-.07*t) * (1. + 0.2*dot(rd, -n)) + .05*(q.x-q.y));\n        if(alt)c *= vec3(.25); //c[S%3] *= -1., c = max(-c,.0);\n        //p = abs(fract(8.*p)-.5); c *= vec3(min(length(p.xy), min(length(p.yz), length(p.xz))) < 0.1);\n        fragColor = vec4(c, -1.);\n        return;\n    }\n    \n    // output coord\n    if(int(R.w) % SKIPS == 0)pt = R.z;\n    //coord = abs(mod(coord-R.xy, 2.*R.xy)-R.xy);\n    fragColor = vec4(coord, 0, pt);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    R = vec4(iResolution.xy, iTime, iFrame);\n    \n    // fetch buffer a\n    ivec2 u = ivec2(fragCoord);\n    vec4 tex = texelFetch(iChannel0, u, 0);\n    \n    // manual color override\n    if(tex.w < .0)\n    {\n        fragColor = tex;\n        return;\n    }\n    \n    // fetch buffer b\n    if(int(R.w) % SKIPS == 0)u = ivec2(tex.xy);\n    fragColor = texelFetch(iChannel1, u, 0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define SKIPS 6\n\n#define DEBUG_GEOMETRY 0\n\nconst float pi = acos(-1.);\n\nvec4 R;","name":"Common","description":"","type":"common"}]}