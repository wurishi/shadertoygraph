{"ver":"0.1","info":{"id":"dlVyzh","date":"1700162913","viewed":109,"name":"MPR Trace Support Function","username":"spalmer","description":"no SDF or intersector.  Uses MPR technique.  Cool idea, thanks encypruon and kastorp!\nslightly reformatted.  added lighting.  straightening some math out.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raycast","minkowski","mpr","hull","gjk","supportfunction"],"hasliked":0,"parentid":"dtVyzz","parentname":"Support Function Ray Casting"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Support Function Ray Casting\n// fork of http://shadertoy.com/view/dtVyzz by kastorp\n// fork of http://shadertoy.com/view/wstyRB by encypruon\n\n// see this http://shadertoy.com/view/MsjSWR by demofox\n// see this interesting article http://xenocollide.snethen.com/mpr2d.html\n// see http://shadertoy.com/view/mlKczw where I tried to simplify this down to 2D (\"1D MPR\")\n// http://wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm\n// http://graphics.stanford.edu/courses/cs448b-00-winter/papers/gilbert.pdf\n\nconst int\n    oBox    = 0,\n    oSphere = 1,\n    oCyl    = 2,\n    oCone   = 3,\n    oSeg    = 4,\n    oTet    = 5;\n// 0=box, 1=sphere, 2=cylinder, 3=cone, 4=segment, 5=tetrahedra\nstruct obj\n{\n    vec3 c; // center\n    vec3 b; // local bounding box extent/size/scale along axis\n    vec4 r; // rotation (xyz=axis, w=angle) // TODO replace with Quats\n    int s;  // shape id\n};\n\nvec3 supMax(vec3 d, vec3 a, vec3 b)\n{\n    return dot(d, a) > dot(d, b) ? a : b;\n}\n\n// returns a point on the object, in local space,\n// location of feature nearest to query direction d\nvec3 supportBase(vec3 d, in obj o)\n{\n    vec3 r, b = o.b;\n    switch (o.s) {\n        default:\n        case oBox:\n            r = sign(d) * b;\n            break;\n        case oSphere:\n            r = normalize(d) * b.x;\n            break;\n        case oCyl:\n            r = supMax(d,\n                vec3(normalize(d.xy) * b.x, b.y), \n                vec3(normalize(d.xy) * b.x,-b.y));\n            break;\n        case oCone:\n            r = supMax(d,        \n                vec3(normalize(d.xy) * b.x, b.z),\n                vec3(0, 0, -b.z));\n            break;\n        case oSeg:\n            r = supMax(d, b,-b) + normalize(d) * .02;\n            break;\n        case oTet:\n            r = supMax(d,\n                  supMax(d, vec3(b), vec3(-b.x,b.y,-b.z)),\n                  supMax(d, vec3(b.x,-b.yz), vec3(-b.xy,b.z)));\n            break;\n        case -1:\n            r = vec3(0);\n            break;\n    }\n    return r;\n}\n// truly the support function need not return an actual vertex,\n// can return a location on a face or whatever is nearest,\n// in fact can simply return overlap along axis (a scalar)\n// and the caller can figure things out using only that info.\n// I've done it.  I just can't find the code now.\n\n// anyway in almost all cases what happens is the caller\n// takes the result of this call (a vector to a feature, from obj local origin)\n// and takes dot product of it with the query unit vector!\n// something like:\n//  s = rsupport(d, o); if (dot(s.xy, d.xy) <= 0.) ...\n\n// once you get object transformed to local space, the ray\n// may be treated as the intersection of two planes\n// with normals perpendicular to the ray dir, intersecting the ray origin.\n// that's just two overlap tests using the support function I recall.\n// if they both succeed, they should constrain a hit point\n// if intersect those planes with the original ray.\n\n// anyway this overlap lets you calculate a vector \n// which is from the origin to a point on the object\n// the plane of the query, anyway leaves many problems unsolved\n// such as how to calculate the normal or find the exact intersection point\n// along the ray, surf the found surface normal upwind toward the ray somehow.\n\n// apparently this extra information, about the actual vector to the\n// actual nearby point of local extremity, allows this \n// perspective shifting that kastorp added to encypruon's technique.\n// that's pretty clever, I still need to understand that.\n\n// Rodrigues\nvec3 erot(vec3 p, vec3 ax, float r) \n{\n    return mix(dot(p, ax) * ax, p, cos(r)) - sin(r) * cross(p, ax);\n}\nmat3 mrot(vec3 ax, float r)\n{\n    return mat3(\n        erot(vec3(1,0,0), ax, r),\n        erot(vec3(0,1,0), ax, r),\n        erot(vec3(0,0,1), ax, r));\n}\n\n// TODO goal is to remove these global var hacks\n// and make rayVsSupport work with arbitrary direction vector\n// not require +Z; it can work in 3D instead of 2D, would aid clarity!\n// I will require more coffee to proceed.\n\nmat3 rmi; // rm is just a transpose, didn't really need it\n    \nvec3 oro;\n\nvec3 rsupport(vec3 dir, obj o)\n{ \n    mat3 rt = mrot(o.r.xyz, o.r.w);\n    vec3 s1 = supportBase(rt * (rmi * dir), o);   \n    return (s1 + rt * o.c) * rt * rmi;\n}\n\n// is perp dot product/cross2 > 0? refactored 3x copies\nbool check(vec2 p, vec2 v) {\n    return dot((p - v).yx * vec2(-1,1), p) > 0.; //cross(vec3(p-v,0), vec3(p,0)).z > 0.; //\n} //cross(vec3(p,0), vec3(v,0)).z > 0.; // strangely, was working just as well!\n\n#define IZERO min(0, iFrame)\n\n\n// adapted from http://shadertoy.com/view/wstyRB\n//  Casts ray in +z direction at object, from oro, estimates depth and normal\n// assumes rd equals (0,0,1), relies on HACKS in rsupport to handle view ray transformation\n// encypruon says \"2D GJK in xy-plane\"\nbool rayVsSupport(obj o, out vec3 normal, out float depth)\n{\n    vec3 ord = rmi[2], oc = o.c, v;   \n    // whatever happened to ord to make it become +Z, do same thing to o.c - oro?\n    // basically, also transforms o.c to be relative to ray\n    o.c = cross(cross(ord, oro - oc), ord);\n    vec3 s[3]; // a triangle\n    s[0] = rsupport(vec3(1, 0, 0), o);\n    if (s[0].x <= 0.)\n        return false;\n    s[1] = rsupport(vec3(-s[0].xy, 0), o);\n    if (dot(-s[0].xy, s[1].xy) <= 0.)\n        return false;\n    \n    v = vec3((s[1].xy - s[0].xy).yx * vec2(-1,1), 0);\n    if (dot(v.xy, s[0].xy) >= 0.) {\n        v.xy = -v.xy;\n        vec3 tmp = s[0]; s[0] = s[1]; s[1] = tmp; // swap\n    }\n    s[2] = rsupport(v, o);\n    if (dot(s[2].xy, v.xy) <= 0.)\n        return false;\n    // refines silhouettes; quite noticeable on cone\n    for (int i = IZERO + 7; ; ) {\n             if (dot(v.xy = (s[2].xy - s[0].xy).yx * vec2(-1,1), s[2].xy) < 0.)\n        { s[1] = s[2]; }\n        else if (dot(v.xy = (s[1].xy - s[2].xy).yx * vec2(-1,1), s[2].xy) < 0.)\n        { s[0] = s[2]; }\n        else break; // Origin in triangle -> intersection!\n        \n        s[2] = rsupport(v, o);    \n        if (dot(s[2].xy, v.xy) <= 0. || --i == 0)\n            return false;\n    }\n    // HACK should be based on distance to camera, and resolution?\n    const float tolerance = 1e-6;\n\n    // needs all this refinement to produce sufficient precision to avoid shadow acne  :(\n    // essentially a simplicial binary search, in 2D\n    for (int i = IZERO + 28; i-- > 0; ) {\n        v = normalize(cross(s[1] - s[0], s[2] - s[0])); // compute estimated normal vector of tri\n        vec3 sd = rsupport(v, o);\n\n        if (dot(v, sd) - dot(v, s[0]) < tolerance)\n            break;\n\n        // xd = origin left of xd line (perp dots = cross2d)\n        bool ad = check(sd.xy, s[0].xy),\n             bd = check(sd.xy, s[1].xy),\n             cd = check(sd.xy, s[2].xy);\n\t\t\n        // Choose triangle that intersects z-axis furthest in z direction\n             if (ad && !bd) { s[2] = sd; }\n        else if (bd && !cd) { s[0] = sd; }\n        else if (cd && !ad) { s[1] = sd; }\n        else break; //discard; // Should not happen\n\t}   \n    v = normalize(cross(s[2] - s[0], s[1] - s[0])); // final normal\n    depth = dot(oc - oro, ord) - s[0].z - dot(s[0].xy, v.xy) / v.z;\n    if (depth < 0.) return false;\n    normal = normalize(rmi * v);\n    return true;\n}\n\n\n// SCENE: same as kastorp's original (no dodecagon)\nconst vec4 nr = vec4(1,0,0, 0),\n    pr = vec4(1,0,0, acos(0.));\nconst obj[] o =  obj[](\n    obj( vec3( 0, -.3, 0), vec3( .5,.1,.5), nr, oBox   ), // base\n    obj( vec3( -.4, 0, 0), vec3( .1,.2,.1), nr, oBox   ), // box\n    obj( vec3(  .3, 0, 0), vec3( .2      ), nr, oSphere), // sphere\n    obj( vec3( 0, 0, -.4), vec3( .2,.1,.1), nr, oCyl   ), // cylinder\n    obj( vec3( 0, 0,  .3), vec3(.2, 0, .2), pr, oCone  ), // cone\n    obj( vec3( 0, -.2, 0), vec3(.4, .4, 0), pr, oSeg   ), // segment 1\n    obj( vec3( 0, -.2, 0), vec3(.4,-.4, 0), pr, oSeg   ), // segment 2\n    obj( vec3( 0, -.1, 0), vec3(       .1), nr, oTet   )  // tetrahedron\n);\n\nmat3 view(vec3 z)\n{\n    vec3 x = normalize(cross(vec3(0,1,0), z)),\n         y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nbool trace(vec3 ro, vec3 rd, out vec3 nor, out float dist)\n{\n    rmi = view(rd); \n    oro = ro;\n    bool hit = false;    \n    dist = 8e4; nor = -rd;\n    // not using IZERO here makes compile times really long\n    for (int i = IZERO + o.length(); i-- > 0; ) {\n        vec3 n;\n        float d;\n        bool rvs = rayVsSupport(o[i], n, d);\n        if (rvs && d < dist) {\n            nor = n; dist = d; hit = true;\n        }\n    }\n    return hit;\n}\n\nvoid mainImage(out vec4 O, vec2 fc)\n{\n    vec2 r = iResolution.xy;\n    float v = min(r.x, r.y);\n    vec2 m = iMouse.z > 0. ? (2. * iMouse.xy - r) / v : vec2(.04*iTime, .1);\n    m.x *= 2.25;\n    vec3 ro = vec3(sin(m.x), .5 - m.y, cos(m.x));\n    vec3 acc = vec3(0), fw = normalize(-ro); // lookat origin\n    mat3 vm = view(fw);\n    int aa = max(1, 2 + int(v < 513.) - int(v > 1024.));\n    for (int aai = aa * aa; aai-- > 0;) {\n        vec2 q = fc;\n        q += .33*(vec2(aai % aa, aai / aa) - .3 * float(aai) / float(aa * aa) - float(aai/2));\n        q = (2. * q - r) / v;\n\n        vec3 rd = normalize(vm * vec3(q, 2)), n;\n        float dist;\n        bool hit = trace(ro, rd, n, dist);\n        vec3 L = normalize(vec3(.57)), c;\n        if (!hit) // sky?\n            c = mix(pow(max(0., dot(rd, L)), 2.) + .45 - .45 * rd, vec3(1), .04);\n        else {\n            vec3 hpos = ro + dist * rd, ln;\n            float nl = dot(n, L), lhd = 8e4;\n            // massive shadow acne if insufficient refinement\n            bool sh = nl <= 0. \n                || trace(hpos + (1.*n + 1.*L - 1.*rd) * 1e-4, L, ln, lhd)\n                ;\n            // TODO soft shadow penumbra somehow; find closest pt to ray somehow\n            if (sh) nl = max(nl, 0.) * lhd/(lhd + .2); // shadow attenuation hacks\n            //if (sh) nl = 0.; else nl = 1.;\n\n            nl = mix(nl, 1., .3); // ambient\n            vec3 gtex = step(cos(80. * acos(0.) * hpos), vec3(.995));\n            c = mix(gtex, vec3(1), .3 + .7 * n * n) // triplanar grid texture\n              * (n * .5 + .5); // albedo based on normal\n            c *= nl; // lighting\n            c *= exp2(-1.2 * (dist - .3));\n        }\n        c = sqrt(sqrt(c * c * c)); // tonemap/gamma OETF hacks\n        acc += c;\n    }\n    vec3 c = acc / float(aa*aa);\n    O = vec4(c, 1); // supersample antialiasing\n}","name":"Image","description":"","type":"image"}]}