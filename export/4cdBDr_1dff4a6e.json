{"ver":"0.1","info":{"id":"4cdBDr","date":"1732962221","viewed":25,"name":"2D Ray Marching Test","username":"jttninjacode","description":"2D Ray Marching Test.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cheatsheet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdf_of_rect(vec2 point, vec2 center, vec2 size) {\n    vec2 half_size = size * 0.5;\n    vec2 delta = abs(point - center) - half_size;\n\n    float outside_dist = length(vec2(max(delta.x, 0.0), max(0.0, delta.y)));\n    float inside_dist = min(max(delta.x, delta.y), 0.0);\n\n    return outside_dist + inside_dist;\n}\n\nfloat sdf_of_circle(vec2 point, vec2 center, float radius) {\n    return abs(length(point - center)) - radius;\n}\n\nfloat smooth_min(float d1, float d2, float factor) {\n    return -log(exp(factor * -d1) + exp(factor * -d2)) / factor;\n}\n\nbool ray_march_2d(vec2 p, float minDist) {\n    float min_d1 = sdf_of_rect(p, vec2(0.4, 0.0), vec2(0.2, 0.5));\n    float min_d2 = sdf_of_circle(p, vec2(0.0), 0.2);\n    float min_d = smooth_min(min_d1, min_d2, 12.0);\n    return min_d < 0.001; // Return the maximum distance if no intersection\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adaptively select the shortest axis's bounds as -0.5 to 0.5.\n    float min_axis = min(iResolution.x, iResolution.y);\n    vec2 coord = (fragCoord - iResolution.xy / 2.0) / min_axis;\n\n    bool pred = ray_march_2d(coord, 0.1);\n    vec3 color = pred ? vec3(1.0) : vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(color ,1.0);\n}","name":"Image","description":"","type":"image"}]}