{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat lengthRound(vec3 p)\n{\n\tfloat n = 1.7;\n\treturn pow(pow(p.x,n) + pow(p.y,n) + pow(p.z,n), 1.0/n);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  \n  //float lengthRounded = lengthRound(max(d,0.0));\n  //return min(max(d.x,max(d.y,d.z)),0.0) + lengthRounded;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeatPos(vec3 p, vec3 c)\n{\n\treturn mod(p,c)-.5 * c;\n}\n\nfloat getDistance(vec3 position)\n{\t\n    vec3 pos = vec3(position.x + 2.0 * sin(iTime), position.y + 2.0 * cos(iTime), position.z);\n    vec3 pos2 = vec3(position.x - 2.0 + 4.0 * cos(iTime), position.y + 4.0 * sin(iTime), position.z);\n    \n    float dis1 = sdSphere(pos, 2.0);\n    //float dis2 = sdSphere(pos2, 2.0);\n    float dis2 = sdBox(pos2, vec3(1.,1.,1.));\n    float distance = min(dis1, dis2);\n    \n    return dis1;\n    //return distance;\n    \n    \n    //return sdSphere(pos, 2.0);\n    //Repeat shape\n\t//vec3 repPos = repeatPos(position, vec3(5.0,20.0,4.5));\n    \n    //Draw cubes\n\t//return sdBox(repPos, vec3(1.,1.,1.));\n\t\n    //Draw spheres\n\t//return sdSphere(repPos, 1.0);\n}\n\nvec4 getColor(vec3 position)\n{\n\tfloat e = 0.01;\n\tfloat f0 = getDistance(position);\n\t\n    //Approximate the normal by stepping a minimal amount in each of the axes' direction\n\tfloat fx = getDistance(vec3(position.x + e, position.y, position.z));\n\tfloat fy = getDistance(vec3(position.x, position.y + e, position.z));\n\tfloat fz = getDistance(vec3(position.x, position.y, position.z + e));\n\t\n\t\n\t\n\tvec3 normal = normalize(vec3(fx - f0, fy - f0, fz - f0));\n\tvec3 lightPosition = vec3\n\t\t(\n\t\t\t0.0, //+ 12.0*sin(iTime*1.0),\n\t\t\t0.0, //+ 12.0*sin(iTime*2.0),\n            -3.0\n            //iTime * 20.0\n            \n            //-1.0 - sin(iTime) * 2.0\n\t\t\t//280.0 + 300.0*sin(iTime*1.0) //Make the light move on the z axis\n\t\t\t//iTime * 5.0 + 100.0\n\t\t);\n\tvec3 lightDir = normalize(lightPosition - position);\n\tvec4 lightColor = vec4(.5,0.2,0.0,0.2);\n\tvec4 lightIntensity = lightColor * dot(normal, lightDir);\n\tfloat reflectance = 0.5;\n\t\n\tfloat lightDistance = length(position-lightPosition);\n    \n    //Hacky but pretty good looking light intensity diminishing over distance\n\t//float distanceIntensity = (1.0 / (pow(lightDistance / 100.0, 1.1))); \n    float distanceIntensity = (5.0 / (pow(lightDistance / 25.0, 1.0001))); \n\t\n\treturn reflectance * lightIntensity * (distanceIntensity);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Moving eye position, bugs on some weaker hardware and just shows grey as mentioned in the omments\n    //vec3 eye = vec3(0, 3, iTime * 20.0 - 50.0);\n    \n    //Still eye\n\tvec3 eye = vec3(0, 0, -5);\n\t//eye.z = -1.0*sin(iTime);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = vec3(1, 0, 0);\n    \n    //Epsilon for when we are close enough to a surface to decide the surface is right here\n    float epsilon = 0.1;\n    float maxDistance = 100000.0;\n\n\t//Normalized device coordinates\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 uv = ndcXY * vec2( aspectRatio, 1.0 );\n\t//uv.y += (0.07 * sin(uv.x + iTime*4.0));\n\n\t\n    \n    //Variables needed for ray marching this pixel\n    float focalLength = 1.0;\n    vec3 forward = normalize(cross(right, up));\n    \n    vec3 planePos = right * uv.x + up * uv.y;\n\t\n    vec3 pImagePlane = eye + forward * focalLength + planePos;\n    vec3 rayDirection = normalize(pImagePlane - eye);\n\n\t// Sky color\n    vec4 color = vec4\n\t\t(\n\t\t\t0.9,\n\t\t\t0.5,\n\t\t\t0.5,\n\t\t\t1\n\t\t); \n\n    float t = 0.0;\n    const float maxSteps = 512.0;\n    for(float i = 0.0; i < maxSteps; ++i)\n    {\n        vec3 p = pImagePlane + rayDirection * t;\n\t\tfloat d = getDistance(p);\n\t\tif(d > maxDistance) {break;}\n        if(d < epsilon)\n        {\n\t\t\n            //Fixed color, no shading\n\t\t\t//color = vec4(i*0.1+0.1,0.5,0,1);\n            \n            //Shade this surface\n\t\t\tcolor = getColor(p);\n            break;\n        }\n\t\t//March forward by the distance to the closest surface to current point in space\n        t += d;\n    }\n\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ltj3RR","date":"1426681477","viewed":129,"name":"Testing stuff yay","username":"Tsarpf","description":"Ray marched stuff WIP","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ball"],"hasliked":0,"parentid":"","parentname":""}}