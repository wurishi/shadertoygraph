{"ver":"0.1","info":{"id":"ltlczH","date":"1503524444","viewed":105,"name":"Juliabox Slices","username":"zaiyugi","description":"A slice of the Juliabox fractal at z=0. Animation from animating the scale parameter","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Iterations 6\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r2 < 0.5) { \n\t\tfloat temp = 1.0/0.5;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n    if (r2 < 1.0) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp = 1.0/r2;\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n \nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -1.0, 1.0) * 2.0 - z;\n}\n\nfloat map(in vec3 p, in vec3 c, inout vec4 C)\n{\n    float Scale = 1.0;//sin(iTime) + 2.0;\n    \n    vec3 z = p;\n    vec3 offset = c;\n    C = vec4(1.e20);\n    \n    float dr = 1.0;\n    float bailout = 10.0;\n    \n    vec3 z1 = abs(z);\n    float r2 = max(z1.x, max(z1.y, z1.z));\n    for (int n = 0; n < Iterations; n++)\n    {\n        if( r2 > bailout )\n            break;\n        \n        boxFold(z,dr);       // Reflect\n\n        r2 = dot(z,z);\n        float k = max(Scale/r2, 1.0);\n        z = z * k + offset;\n        dr = dr * k;\n        \n        z1 = abs(z);\n    \tr2 = max(z1.x, max(z1.y, z1.z));\n        \n        C.xyz = min(C.xyz, abs(z));\n        C.w = min(C.w, r2);\n    }\n        \n    z1 = abs(z);\n    r2 = max(z1.x, max(z1.y, z1.z));\n    if( r2 > bailout )\n        C = vec4(0.0);\n    \n    float d = (length(z) - 1.732)/abs(dr);\n    return d;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p_uv = fragCoord.xy / iResolution.xy;\n\t\n    float aspect_ratio = float(iResolution.x) / float(iResolution.y);\n    p_uv = p_uv * 2.0 - 1.0;\n    p_uv.x *= aspect_ratio;\n    \n   \tvec3 color;\n\tvec3 p = vec3(p_uv, sin(iTime * 0.0));\n    vec4 C = vec4(0.0);\n\n    float angle_t = iTime * 0.5;\n    \n    vec3 offset = vec3( (iMouse.xy / iResolution.xy) * 4.0 - 2.0, 0.0 );\n    //vec3 offset = vec3(1.0 * cos(angle_t), 1.0 * sin(angle_t), 0.0);\n    float d = map(p, offset, C);\n    float s = dot(C.xyz, C.xyz) / C.w;\n    \n    color = vec3(0.5) + vec3(0.5) * cos(6.28318 * (vec3(1.0) * s + vec3(0.0, 0.1, 0.2)));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}