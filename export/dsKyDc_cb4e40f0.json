{"ver":"0.1","info":{"id":"dsKyDc","date":"1696716287","viewed":42,"name":"Double Slit Maxwell 2D","username":"jimmyjames145","description":"Credit to Amirk:\nhttps://www.shadertoy.com/user/Amirk\nMaxwell's equations implemented in 2D. Buffer A updates H field using curls of E field, after which Buffer B updates E field using curls of H field.\nVisualisation with Electric field. ","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["wave","refraction","light","maxwell","doubleslit","electrodynamics"],"hasliked":0,"parentid":"mdKcW3","parentname":"Fork Maxwell 2D jimmyjames 810"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col=vec3(0);\n\n    float EZ = texture(iChannel0,uv).r*40.;\n    //float HX= texture(iChannel0,uv).g*40.;\n    //float HY= texture(iChannel0,uv).b*40.;\n    \n    //float energy=0.5*(er*EZ*EZ+(HX*HX+HY*HY)/ur); //energy in the field\n    \n    \n    // Double Slit Parameters\n    vec2 slitSize = vec2(0.03, 0.15); // Width and height of each slit\n    float slitDistance = 0.06; // Distance between the two slits\n    vec2 barrierSize = vec2(0.05, 0.03); // Width and height of the barrier\n    \n    vec2 centerBarrierPos = vec2(0.3, 0.5); // Center of the entire barrier (between the slits)\n    vec2 topSlitPos = centerBarrierPos - vec2(0.0, slitSize.y/2.0 + barrierSize.y/2.0); // Top of the center barrier\n    vec2 bottomSlitPos = centerBarrierPos + vec2(0.0, slitSize.y/2.0 + barrierSize.y/2.0); // Bottom of the center barrier\n\n    // Check for positions in the barriers\n    bool inTopBarrier = abs(fragCoord.x - topSlitPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - topSlitPos.y * iResolution.y) < barrierSize.y * iResolution.y * 0.9;\n    bool inBottomBarrier = abs(fragCoord.x - bottomSlitPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - bottomSlitPos.y * iResolution.y) < barrierSize.y * iResolution.y * 0.9;\n    bool inCenterBarrier = abs(fragCoord.x - centerBarrierPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - centerBarrierPos.y * iResolution.y) < slitDistance * iResolution.y * 0.9;\n\n    // Check if fragment is within one of the barriers\n    if(inTopBarrier || inBottomBarrier || inCenterBarrier) {\n        er=200.0;\n        ur=200.0;\n    }\n     col= color(1.51*EZ)/(er*0.5);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this Buffer updates magnetic field H with curls of E with buffer B\n\nivec2 boxBoundary(int px, int py){\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    return clamp(ivec2(px,py), ivec2(0,0), r-1);\n}\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){\n    return texelFetch(iChannel0, boxBoundary(i,j),0).r;\n}\n\n\nfloat Hx(int i, int j){\n    return texelFetch(iChannel0, boxBoundary(i,j),0).g;\n}\nfloat Hy(int i, int j){\n    return texelFetch(iChannel0, boxBoundary(i,j),0).b;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    float EZ,HX,HY;\n    \n \n    // Double Slit Parameters\n    vec2 slitSize = vec2(0.03, 0.15); // Width and height of each slit\n    float slitDistance = 0.06; // Distance between the two slits\n    vec2 barrierSize = vec2(0.05, 0.03); // Width and height of the barrier\n    \n    vec2 centerBarrierPos = vec2(0.3, 0.5); // Center of the entire barrier (between the slits)\n    vec2 topSlitPos = centerBarrierPos - vec2(0.0, slitSize.y/2.0 + barrierSize.y/2.0); // Top of the center barrier\n    vec2 bottomSlitPos = centerBarrierPos + vec2(0.0, slitSize.y/2.0 + barrierSize.y/2.0); // Bottom of the center barrier\n\n    // Check for positions in the barriers\n    bool inTopBarrier = abs(fragCoord.x - topSlitPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - topSlitPos.y * iResolution.y) < barrierSize.y * iResolution.y * 0.9;\n    bool inBottomBarrier = abs(fragCoord.x - bottomSlitPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - bottomSlitPos.y * iResolution.y) < barrierSize.y * iResolution.y * 0.9;\n    bool inCenterBarrier = abs(fragCoord.x - centerBarrierPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - centerBarrierPos.y * iResolution.y) < slitDistance * iResolution.y * 0.9;\n\n    // Check if fragment is within one of the barriers\n    if(inTopBarrier || inBottomBarrier || inCenterBarrier) {\n        er=200.0;\n        ur=200.0;\n    }\n\n    \n    EZ=Ez(i,j);\n  \n    //Maxwell's equation:\n    //update H:\n    HX=Hx(i,j) -mH*( Ez(i,j+1)-Ez(i,j) );\n    HY=Hy(i,j)-mH*( -(Ez(i+1,j)-Ez(i,j)) );\n    \n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,HX,HY);\n    \n    \n    fragColor = vec4(col,1.0);\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":" //speed of light c:\n #define c  1. \n //grid cell size:\n #define dz 0.1\n //relative permittivity:\n float er = 1.0;\n //relative permeability:\n float ur = 1.0;\n //timestep is chosen so that one grid cell is traversed in excatly two time steps. \n //First time step is to update H, the second to update E.\n #define dt dz/(2.0*c)\n //some precalculations:\n #define mE c*dt/(er*dz)\n #define mH c*dt/(ur*dz)\n //maxFreq controls the highest frequency contained in the source pulse.\n //it should be of the of the same order as the speed of light c.\n #define maxFreq 1. \n \n float t;\n\n\n//a gaussian pulse at x, y:\nfloat source(float time, ivec2 xy, int i, int j){ \n    if(i==xy.x&&j==xy.y)\n        return exp(-(time-dt*70.0)*(time-dt*70.0)*4.0*maxFreq*maxFreq);\n    \n    else return 0.0;\n}\n\nvec3 color(float t)\n{\n vec3 col;\n col.r = 0.5-0.5*cos(2.*3.1416*(1.5*t+1.9));\n col.g = 0.5-0.5*cos(2.*3.1416*(.9*t+.15));\n col.b = 0.5-0.5*cos(2.*3.1416*(1.7*t+.2));\n return col;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this Buffer updates electric field E with curls of H using buffer A\n\nivec2 boxBoundary(int px, int py){\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    return clamp(ivec2(px,py), ivec2(0,0), r-1);\n}\n\n\n\n    //We store Ez as col.r and Hx,Hy as col.g, col.b\n\nfloat Ez(int i, int j){\n    \n    return texelFetch(iChannel0, boxBoundary(i,j),0).r;\n}\nfloat Hx(int i, int j){\n\n    return texelFetch(iChannel0, boxBoundary(i,j),0).g;\n}\nfloat Hy(int i, int j){\n\n    return texelFetch(iChannel0, boxBoundary(i,j),0).b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = vec3(0);\n    \n    int i=int(fragCoord.x);\n    int j=int(fragCoord.y);\n    \n    t=dt*float(iFrame);\n    \n    float EZ,HX,HY;\n    \n     \n    // Double Slit Parameters\n    vec2 slitSize = vec2(0.03, 0.15); // Width and height of each slit\n    float slitDistance = 0.06; // Distance between the two slits\n    vec2 barrierSize = vec2(0.05, 0.03); // Width and height of the barrier\n    \n    vec2 centerBarrierPos = vec2(0.3, 0.5); // Center of the entire barrier (between the slits)\n    vec2 topSlitPos = centerBarrierPos - vec2(0.0, slitSize.y/2.0 + barrierSize.y/2.0); // Top of the center barrier\n    vec2 bottomSlitPos = centerBarrierPos + vec2(0.0, slitSize.y/2.0 + barrierSize.y/2.0); // Bottom of the center barrier\n\n    // Check for positions in the barriers\n    bool inTopBarrier = abs(fragCoord.x - topSlitPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - topSlitPos.y * iResolution.y) < barrierSize.y * iResolution.y * 0.9;\n    bool inBottomBarrier = abs(fragCoord.x - bottomSlitPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - bottomSlitPos.y * iResolution.y) < barrierSize.y * iResolution.y * 0.9;\n    bool inCenterBarrier = abs(fragCoord.x - centerBarrierPos.x * iResolution.x) < barrierSize.x * iResolution.x * 0.1 && abs(fragCoord.y - centerBarrierPos.y * iResolution.y) < slitDistance * iResolution.y * 0.9;\n\n    // Check if fragment is within one of the barriers\n    if(inTopBarrier || inBottomBarrier || inCenterBarrier) {\n        er=200.0;\n        ur=200.0;\n    }\n\n    \n    //Maxwell's equation:\n    //update E:\n    EZ=Ez(i, j)+ mE* ((Hy(i,j)-Hy(i-1,j))-(Hx(i,j)-Hx(i,j-1)));\n    \n    //add sources:\n    EZ+=source(t, ivec2(iResolution.x/2. - iResolution.x/4., iResolution.y/2.), i,j);\n    \n    if(iMouse.z>0.){\n        EZ+= source(dt*50., ivec2(iMouse.xy), i, j);\n  \n    }\n    \n    HX=Hx(i,j);\n    HY=Hy(i,j);\n    \n    //store fields in color channels:\n    col.rgb=vec3(EZ,HX,HY);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}