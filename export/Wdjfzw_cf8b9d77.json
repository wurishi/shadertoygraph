{"ver":"0.1","info":{"id":"Wdjfzw","date":"1590098283","viewed":170,"name":"Animated tree forest","username":"Jaraxus","description":"A 2d procedural tree forest.\nYou can change TIME_FACTOR to increase or decrease the time speed :)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","painting","animated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Math alias\n#define M_PI\t\t\t3.14159265359\n#define RandomSign(x,y) (rand(vec2(x,y)) <= 0.5 ? -1. : 1.)\n\n// Settings alias\n#define TIME_FACTOR  1.\n#define time\t\t (iTime*TIME_FACTOR)\n#define DayTimeOf(x) mod(time + 1.5 * x, 24.)\n\n// Colors constants\nconst vec3\t\tBLACK = vec3(0.0, 0.0, 0.0),\n    \n\t   DARK_NIGHT = vec3(0.06274, 0., 0.4196),\n\t\t  MID_SUN = vec3(1., 0.3687, 0.),\n\t\tPLAIN_SUN = vec3(0.6118, 1., 0.9334),\n\n\tBRIGHT_LEAVES = vec3(0.16078, 0.54118, 0.00392),\n\t  DARK_LEAVES = vec3(0.07059, 0.32157, 0.0235),\n    \t\tTRUNC = vec3(0.25098, 0.1647, 0.08627);\n\n// Settings constants\nconst float\t\t   NB_TREES = 20.,\n    \n\t\t  LEAVES_RADIUS = 0.2,\n\t\t\tTRUNC_WIDTH = 0.025,\n\tTRUNC_PATTERN_REPET = 2.,\n    \n    \t  GROUND_HEIGHT = 0.03;\n\nfloat rand(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat mapCos(float cosValue, float lowerBound, float upperBound) {\n    // can be optimized with following formula :\n    // return mix(lowerBound, upperBound, .5+.5*(cosValue)); (?)\n    return (cosValue + 1.) * (upperBound - lowerBound) / 2. + lowerBound;\n}\n\nvec3 drawTree(vec2 position, vec3 treePosition)\n{\n    vec3 color = BRIGHT_LEAVES;\n    \n    // luminosity factor is the same for all the tree (it doesn't depend on pixel's y coordinate)\n    float dayTime = DayTimeOf(0.25);\n    float luminosityFactor = 1. - mapCos(cos(dayTime / 12. * M_PI + treePosition.z * 2. - 0.35), 0., 0.9);\n    \n    // draw leaves\n    // draws bright leaves\n    vec2 leavesCenter = vec2(treePosition.x, 1. - treePosition.z);\n    float treeLeavesRadius = LEAVES_RADIUS * mapCos(cos(time / 3. + treePosition.z * 23.), 0.7, 1.3);\n    float maxLeaveDist =\n        mapCos(\n            cos(50. * ((treePosition.z + 0.1) * 10. +\n                       (RandomSign(treePosition.z, treePosition.y) * position.x + position.y) * 2.6 +\n                       (RandomSign(treePosition.y, treePosition.z) * time / 5.)))\n            , 0., treeLeavesRadius);\n    maxLeaveDist *= mapCos(cos(time / 5. + treePosition.z * 13.), 0.6, 1.);\n    color *= smoothstep(maxLeaveDist + 0.05, maxLeaveDist, length(leavesCenter - position));\n    // draws dark leaves\n    if (color == BLACK)\n        color = DARK_LEAVES * smoothstep(treeLeavesRadius + 0.05, treeLeavesRadius, length(leavesCenter - position));\n    // changes luminosity\n    color *= luminosityFactor;\n    \n    if (color != BLACK)\n    \treturn color;\n    \n    // draw trunc\n    // defines left and right bounds for trunc\n    float treeTruncWidth = TRUNC_WIDTH + mapCos(cos(treePosition.z * 10. + iTime / 10.), -TRUNC_WIDTH * 0.2, TRUNC_WIDTH * 0.4);\n    float lowerTruncBound = treePosition.x + treeTruncWidth * (cos(cos((treePosition.x + treePosition.z) * 10.) * 5. * (position.y)) / 5. - 1.);\n    float upperTruncBound = treePosition.x - treeTruncWidth * (cos(cos((treePosition.x + treePosition.z) * 10.) * 5. * (position.y) + M_PI / 2.) / 5. - 1.);\n    // generates ground\n    float groundExpantion = exp(-40. * (position.y - treePosition.z * 0.25)) * 10.;\n    lowerTruncBound -= groundExpantion;\n    upperTruncBound += groundExpantion;\n    // generates intern trunc pattern\n    float truncSmoothstep = smoothstep(lowerTruncBound, upperTruncBound, position.x);\n    color = truncSmoothstep * (1. - truncSmoothstep) * TRUNC *\n\t\t\tcos(position.y * position.x * (1.01 - treePosition.z) * TRUNC_PATTERN_REPET * 5000. *\n                cos(position.x + position.y + treePosition.z * 1000. + time / 25.));\n    // changes luminosity\n    color *= luminosityFactor * 22.5;\n    // adds smooth to bottom of ground\n    color *= smoothstep(0., 0. + GROUND_HEIGHT, position.y);\n    // limits trunc height\n    color *= smoothstep(1. - treePosition.z + GROUND_HEIGHT, 1. - treePosition.z, position.y);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 position = fragCoord/iResolution.xy;\n    // Hour of the day (between 00h and 24h)\n    float dayTime = DayTimeOf(position.y);\n    \n    // draw trees\n    vec3 color = BLACK;\n    for (float treeId = 0.; treeId < NB_TREES; ++treeId) {\n        vec3 treePosition = vec3(0);\n        // defines x position (moving along the time)\n        treePosition.x = 0.5 + cos(time / 10. + treeId + 1.) / 2.;\n        // increases z position according to tree depth in hierarchy\n        treePosition.z += treeId * 0.02;\n        color = drawTree(position, treePosition);\n        // no need to process further if a color is found\n        if (color != BLACK)\n            break;\n    }\n    \n    // draw sky background\n    if (color == BLACK)\n        color = mix(MID_SUN, (dayTime <= 6. || dayTime >= 18. ? DARK_NIGHT : PLAIN_SUN), mapCos(cos(M_PI * dayTime / 6.), 0., 1.));\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}