{"ver":"0.1","info":{"id":"WtKSzm","date":"1582468408","viewed":165,"name":"The moon and stars","username":"hedyla2055","description":"A star field with moon and some noise with fbm. Another beginner's trial.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FORTY_FIVE_DEGREES acos(-1.) / 4.\n#define SIXTY_DEGREES acos(-1.) / 3.\n#define THIRTY_DEGREES acos(-1.) / 6.\n#define SPACE_PURPLE vec3(0.409, 0.157, 0.567)\n#define WHITE vec3(1.0)\n#define ZOOM_OUT 5.8\n#define MOON vec4(0, 1, 1.18, 1.) // vec3 center and radius\n#define MAX_STEPS 100\n#define MAX_DISTANCE 100.\n#define SURFACE_DIST 0.01\n#define OCTAVES 6\n\nmat2 Rotate(float angle)\n{\n\tfloat c = cos(angle), s = sin(angle);\n    return mat2(c, -s, s, c); \n}\n\n// Random number between 0 and 1\nfloat Random(vec2 seed)\n{\n    seed = fract(seed * vec2(123.39, 456.21));\n\tseed += dot(seed, seed + 695.39);\n    return fract(seed.x * seed.y);\n}\n\nfloat GetDistance(vec3 pos)\n{\n    float moon_dist = length(pos - MOON.xyz) - MOON.w;\n    return moon_dist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 diff = vec2(0.01, 0.);\n    float dist = GetDistance(p);\n    \n    vec3 normal = dist - vec3(GetDistance(p - diff.xyy),\n                              GetDistance(p - diff.yxy),\n                              GetDistance(p - diff.yyx) );\n    \n    return normalize(normal);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(-12, 13, -14);\n    lightPos.xy *= Rotate(-THIRTY_DEGREES)\n        * Rotate(FORTY_FIVE_DEGREES)\n        * Rotate(SIXTY_DEGREES);\n    vec3 normal_dir = GetNormal(p);\n    vec3 light_dir = normalize(lightPos - p);\n    \n    return dot(normal_dir, light_dir);\n}\n\nfloat Star(vec2 pos, float glow, float size)\n{\n    float d = length(pos);\n    float res = 0.01 / d;\n\t\n    float rays = max(0., 1. - abs(pos.x * pos.y) * 1000.) * glow * 0.3 * size;\n\tpos *= Rotate(FORTY_FIVE_DEGREES);\n    rays += max(0., 5. - abs(pos.x * pos.y) * 100000.) * glow * .2;\n    res += rays;\n        \n    // Fade the star light with distance\n    res *= smoothstep(1., .3, d) * size;\n    \n    return res;\n}\n\n// Remaps the global uv coord to cell uv coord\nvec2 Remap(vec2 pos, float rand, float origin)\n{\n\tvec2 pos_in_cell = fract(pos) - origin;\n    vec2 id = floor(pos); // get the id of the cell\n    pos_in_cell -= vec2(rand, fract(rand * 34.));\n    \n    return pos_in_cell;\n}\n\nfloat LayoutStars(vec2 pos)\n{\n    float res = 0.;\n    vec2 id = floor(pos);\n\tfor (int y = -4; y <= 4; ++y)\n    {\n    \tfor (int x = -4; x <= 4; ++x)\n        {\n            vec2 neighbor_id = vec2(x, y); // Adds neighboring star contribution\n        \tfloat rand = Random(id + neighbor_id);\n            res += Star(Remap(pos, rand, rand) - neighbor_id,\n                        rand * .3,\n                       \trand * 2.5);\n        }\n    }\n    \n    return res;\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = Random(i);\n    float b = Random(i + vec2(1.0, 0.0));\n    float c = Random(i + vec2(0.0, 1.0));\n    float d = Random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.0;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(uv);\n        uv *= 2.;\n        amplitude *= .46;\n    }\n    return value;\n}\n\nfloat RayMarch(vec3 ray_origin, vec3 ray_direction)\n{\n    float distance_from_origin = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        vec3 p = ray_origin + distance_from_origin * ray_direction;\n        float distance_from_surface = GetDistance(p);\n        distance_from_origin += distance_from_surface;\n        if (distance_from_origin > MAX_DISTANCE ||\n            distance_from_surface < SURFACE_DIST)\n            break;\n    }\n    \n    return distance_from_origin;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    uv *= ZOOM_OUT;\n    vec3 col = SPACE_PURPLE * .3;\n    vec2 id = floor(uv);\n    float randP = Random(cos(vec2(iTime)));\n    col += LayoutStars(uv)* (randP * SPACE_PURPLE + WHITE);\n    \n    // now model the moon\n    vec3 ray_origin = vec3(0, 1., 0.);\n    vec3 ray_dir = normalize(vec3(uv.x, uv.y, 1.0));\n    float dist = RayMarch(ray_origin, ray_dir);\n    \n    vec3 p = ray_origin + dist * ray_dir;\n \tfloat moon = GetLight(p);\n    moon *= smoothstep(0.25, 1., 1. +  moon) * 1.5;\n\n    if (moon > 0.)\n    {\n        col = vec3(moon);\n        col *= (0.3 + fbm(uv));\n        col *= 1. - smoothstep(1., .2, moon);\n    }\n\n \tcol.rb *= 1.13;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}