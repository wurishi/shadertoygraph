{"ver":"0.1","info":{"id":"ldV3W1","date":"1454953502","viewed":1034,"name":"Stalactite Cave","username":"mazander","description":"Deep water flooded cave with stalactites. draft.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","noise","tunnel","water","cave","stalactites"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Modified version of the \"Volcanic\" shader by by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat noise( in vec3 p ){    \n        vec3 i = floor(p); p -= i; p *= p*(3. - 2.*p);\n\tp.xy = texture(iChannel0, (p.xy + i.xy + vec2(37, 17)*i.z + .5)/256., -100.).yx;\n\treturn mix(p.x, p.y, p.z);\n}\n\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//=====================================================================\n\nvec3 path( float time )\n{\n\treturn vec3(cos(0.51 * time) + sin(0.14 * time), 0.8 * sin(0.27 * time), time);\n\t\n}\n\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat cave( vec3 p )\n{\n\n    float f = 0.0;\n    \n    vec3 s = 1.2 * vec3(sin(p.z * 0.32), cos(p.z * 0.77), 1.0);\n    \n    vec3 d = (path(p.z) - p) * s;\n    float dist = length(d);\n    f -= dist;\n    \n    vec3 stalactites = vec3(6.0, 0.15, 6.0);\n    \n    f += 0.7500 * noise( stalactites * p ); p = m*p*2.05;\n    f += 0.5000 * noise( p ); p = m*p*2.02;\n    f += 0.2500 * noise( p ); p = m*p*2.03;\n    f += 0.1250 * noise( p ); p = m*p*2.01;\n    f += 0.0625 * noise( p ); \n\n\t\n    return f;\n}\n\n// Based on original by IQ.\nfloat calculateAO(vec3 p, vec3 n){\n\n    const float AO_SAMPLES = 5.0;\n    float r = 0.0, w = 1.0, d;\n    \n    for (float i=1.0; i<AO_SAMPLES+1.1; i++){\n        d = i/AO_SAMPLES;\n        r += w*(d - cave(p + n*d));\n        w *= 0.5;\n    }\n    \n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\nfloat raymarchTerrain( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 20.0;\n    float t = 0.1;\n    for( int i = 0; i< 160; i++ )\n    {\n\t    float h = cave( ro + rd * t );\n        if( h < (0.001 * t) || t > maxd ) break;\n        t += (step(h, 1.) * .05 + 0.1) * h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           cave(pos+eps.xyy) - cave(pos-eps.xyy),\n           cave(pos+eps.yxy) - cave(pos-eps.yxy),\n           cave(pos+eps.yyx) - cave(pos-eps.yyx) ) );\n\n}\n\n//vec3 lig = normalize( vec3(-0.3,0.4,0.7) );\n\t\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0*q;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\t\n    // camera\t\n\tfloat off = step( 0.001, iMouse.z )*6.0*iMouse.x/iResolution.x;\n\tfloat time = off + 1.2 * iTime;\n\tvec3 ro = path( time+0.0 );\n\tvec3 ta = path( time+1.6 );\n    \n\t//ta.y *= 0.35 + 0.25*sin(0.09*time);\n\t// camera2world transform\n    mat3 cam = setCamera( ro, ta, 0.0 );\n\n    // ray    \n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = cam * normalize(vec3(p.xy,2.1));\n\n    vec3 col = vec3(0.0);\n    \n    // terrain\t\n\tfloat t = raymarchTerrain(ro, rd);\n    if( t>0.0 )\n\t{\n\t\tvec3 pos = ro + t*rd;\n\t\tvec3 nor = calcNormal( pos, t );\n\t\tvec3 ref = reflect( rd, nor );\n\t\n\n        // lighting\n\t\tfloat bac = clamp( abs(dot( nor, rd)), 0.0, 1.0 );\n        \n        float ao = calculateAO(pos, nor);\n\t\n\n\t\tvec3 lin = ao * bac * vec3(0.7, 0.9, 1.0) / pow(t, 2.5);\n\n\n        // surface shading/material\t\n        \n\t\tcol = texcube( iChannel1, 0.5*pos, nor ).xyz;\n\t\n\t\tcol = lin * col;\n        \n        // water\n        if(pos.y < -1.0) {\n            // blue tint\n         \tcol.z += 0.005;\n            // darken when deep\n            col *= pow(0.4, pos.y * pos.y);\n        }\n\t\t\n    }\n\t\n\n    // gamma\t\n\tcol = pow( clamp( col, 0.0, 1.0 ), vec3(0.45) );\n\n    // contrast, desat, tint and vignetting\t\n\tcol = col*0.3 + 0.7*col*col*(3.0-2.0*col);\n\tcol = mix( col, vec3(col.x+col.y+col.z)*0.33, 0.2 );\n\tcol *= 1.3*vec3(1.06,1.1,1.0);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}