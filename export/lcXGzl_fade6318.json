{"ver":"0.1","info":{"id":"lcXGzl","date":"1703345913","viewed":30,"name":"only up","username":"nayk","description":"colorful, neon, rotate, spiral","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spiral","colorful","rotate","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*original https://www.shadertoy.com/view/dl3XDS*/\n#define TWO_PI              6.28318530718\n#define r(A)                mat2(cos(A), -sin(A), sin(A), cos(A))\n#define iterations 17\n#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*22.3+vec3(52,3,11)+cos(iTime))*.5+.5)\n\n#define R2 mat2(cos(a/4.+vec4(0,11,33,0)))\n#define NUM_LAYERS 8.\n#define TAU 6.28318\n#define PI 3.141592\n#define Velocity .025 //modified value to increse or decrease speed, negative value travel backwards\n#define StarGlow 0.025\n#define StarSize 02.\n#define CanvasView 20.\n\nconst float MATH_PI = float( 3.14159265359 );\n\nvoid Rotate( inout vec2 p, float a )\n{\np = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1.0 ) * r;\n}\n\nfloat Rand( vec2 c )\n{\nreturn fract( sin( dot( c.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat saturate( float x )\n{\nreturn clamp( x, 0.0, 1.0 );\n}\n\nvoid BokehLayer( inout vec3 color, vec2 p, vec3 c )  \n{\n    float wrap = 450.0;    \n    if ( mod( floor( p.y / wrap + 0.5 ), 2.0 ) == 0.0 )\n    {\n        p.x += wrap * 0.5;\n         \n    }    \n   \n    vec2 p2 = mod( p + 0.5 * wrap, wrap ) - 0.5 * wrap;\n    vec2 cell = floor( p / wrap + 0.5 );\n    float cellR = Rand( cell );\n       \n    c *= fract( cellR * 3.33 + 3.33 );    \n    float radius = mix( 30.0, 70.0, fract( cellR * 7.77 + 7.77 ) );\n    p2.x *= mix( 0.9, 1.1, fract( cellR * 11.13 + 11.13 ) );\n    p2.y *= mix( 0.9, 1.1, fract( cellR * 17.17 + 17.17 ) );\n   \n    float sdf = Circle( p2, radius );\n    float circle = 1.0 - smoothstep( 0.0, 1.0, sdf * 0.04 );\n    float glow = exp( -sdf * 0.025 ) * 0.3 * ( 1.0 - circle );\n    color += c * ( circle + glow );\n}\n\nfloat Star(vec2 uv, float flare){\n    float d = length(uv);\n  float m = sin(StarGlow*1.2)/d;  \n    float rays = max(0., .5-abs(uv.x*uv.y*1000.));\n    m += (rays*flare)*2.;\n    m *= smoothstep(1., .1, d);\n    return m;\n}\n\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\n\nvec3 StarLayer(vec2 uv){\n    vec3 col = vec3(0);\n    vec2 gv = fract(uv);\n    vec2 id = floor(uv);\n    for(int y=-1;y<=1;y++){\n        for(int x=-1; x<=1; x++){\n            vec2 offs = vec2(x,y);\n            float n = Hash21(id+offs);\n            float size = fract(n);\n            float star = Star(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.1,.9,size)*.46);\n            vec3 color = sin(vec3(.2,.3,.9)*fract(n*2345.2)*TAU)*.25+.75;\n            color = color*vec3(.9,.59,.9+size);\n            star *= sin(iTime*.6+n*TAU)*.5+.5;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\n\n\n\nconst float nbCircle = 13.;\n\nvec2 rotate(float angle, float radius)\n{\n    return vec2(cos(angle),-sin(angle)) * radius;\n}\n\nvec2 perp(vec2 v)\n{\n    return vec2(-v.y, v.x);\n}\n\nfloat udTriangle( vec2 p, vec2 a, vec2 b, vec2 c )\n{\n  vec2 ab = b - a; vec2 pa = a - p;\n  vec2 bc = c - b; vec2 pb = b - p;\n  vec2 ca = a - c; vec2 pc = c - p;\n   \n  float d0 = dot(perp(ab), pa);\n  float d1 = dot(perp(bc), pb);\n  float d2 = dot(perp(ca), pc);\n   \n  return min(min(d0, d1), d2);\n}\n\nfloat sdfTriangle(vec2 p)\n{\n    float radius = 1.2;\n    float angle = iTime * 0.8;\n    vec2 a = rotate( angle, radius);\n    vec2 b = rotate( TAU / 3. + angle, radius);\n    vec2 c = rotate( 2. * TAU / 3. + angle, radius);\n   \n    return udTriangle(p, a, b, c);\n}\n\nfloat radFilter(float v)\n{\n    return smoothstep(100. / iResolution.y, 0., abs(v-1.));\n}\n\nfloat distFilter(float v)\n{\n    return smoothstep(0., 0.5, v);\n}\nvec2 rotate(vec2 v, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\nvec3 palette(vec2 uv, float i) {\n    float t = length(uv) + i * 0.5 - iTime * 0.5;\n\n    vec3 a = vec3(0.468, 0.358, 0.5);\n    vec3 b = vec3(0.448, 0.218, 0.388);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.002, 0.168, 0.498);\n\n    return a + b * cos(TWO_PI * (c * t + d));\n}\n\nfloat circle(vec2 uv, vec2 center, float r)\n{\n    float brightness = 0.008;\n    float l = length(uv + center);\n\n    return brightness / abs(sin(l - r));\n}\n\nfloat shape(vec2 uv, float size)\n{\n    float mask = 0.0;\n    float time = iTime * 1.03;\n\n    const float sides = 7.0;\n\n    for (float i = 0.0; i < sides; i++) {\n        uv *= r(TWO_PI / sides);\n        vec2 uvOrig = uv;\n\n        mask += circle(uv, vec2(uv.x, uv.y + size * 1.0), size * 1.0);\n        uv = -(uvOrig * r(-2.65 * time));\n    }\n\n    return mask;\n}\nvec3 palette( float t ) {\n    vec3 a = vec3(0.5,0.5,0.5);\n    vec3 b = vec3(0.5,0.5,0.5);\n    vec3 c = vec3(2.000,1.000,0.000);\n    vec3 d = vec3(0.5,0.2,0.25);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat SDF_Triangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)/sign(p.y);\n}\n\nfloat spiral(in vec2 p)\n{\n    float x = p.x*3.;\n    float m = min (fract (x), fract (3. -x)) ;\n    return smoothstep (-0.2, .5, m*.5+.2-p.y) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nfloat c22 = Rand(vec2(-5.,5.));\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n     vec2 uv2 = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n     vec2 p2 = (2. *  fragCoord - iResolution.xy) / iResolution.y;\n     p2*=tan(iTime*1.2);\n    float angle = atan(p2.y, p2.x);\n    float l = length(p2) * nbCircle;\n    float circleId = floor(l);\n    vec4 O = fragColor;\n    vec2 C  =fragCoord;\n   float n2 = Hash21(vec2(-5.,5.));\n    float s = 0.6;    \n     vec2 st = vec2 (atan(uv.x, uv.y), length (uv)) ;\n    uv = vec2 (st.x / 6.2831+.5 - sin(-iTime + st.y), st.y);\n    float c = 0.0;\n    \n    float triangle = SDF_Triangle((fragCoord.xy-.5*iResolution.xy) / iResolution.y, .3);\n    \n    c = spiral(uv) + cos(iTime)*3. * spiral(vec2(spiral(uv / 0.6), triangle));\n    \n    \n    c += triangle * n2*c22;\n\n\nvec4 O2;\nO2=vec4(0);\n    vec3 j,q2,r2=iResolution,\n    d3=normalize(vec3((C*2.-r2.xy)/r2.y,1));  \n    for(float i=0.,a,s,e,g=0.;\n        ++i<110.;\n        O2.xyz+=mix(vec3(1),H(g*.1),sin(.8))*1./e/8e3\n    )\n    {\n        j=g*d3;\n        j.z+=-iTime*.5;\n        a=15.*n2;\n        j=mod(j-a,a*2.)-a;\n        s=6.;\n        for(int i=0;i++<4;){\n            j=.3-abs(j);\n            \n            j.x<j.z?j=j.zyx:j;\n            j.z<j.y?j=j.xzy:j;\n            \n            s*=e=1.4+sin(iTime*.234)*.1;\n            j=abs(j)*e-\n                vec3(\n                    5.+cos(iTime*2.3*c22+.5*sin(iTime*1.3))*3.,\n                    10,\n                    4.+cos(iTime*0.3*c22)*5.\n                 );\n         }\n         g+=e=length(j.yz)/s;\n    }\n    \n    vec3 col = palette(length(st.y) + .4 + iTime*.4);\n    col *= c;\n    float modCircleId = mod(circleId, 2.);\n    float d2 = sdfTriangle(p2);\n    d2 = distFilter(d2);\n    vec3 color = shape(uv, 2.9) * palette(uv, 0.0)+d2;\n    O=vec4(0);\n    vec3 y,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));  \n    for(float i=0.,a,s,e,f=0.;\n        ++i<110.;\n        O.xyz+=mix(vec3(1),H(f*.1),sin(.8))*1./e/8e3\n    )\n    {\n        y=f*d;\n        y.z+=-iTime*2.5;\n        a=14.;\n        y=mod(y-a,a*2.)-a;\n        s=6.;\n        y.xy*=mat2(cos(iTime*0.05),sin(iTime*0.05),-sin(iTime*0.05),cos(iTime*0.05));\n        for(int i=0;i++<8;){\n            y=.3-abs(y);\n           \n            y.x<y.z?y=y.zyx:y*c22;\n            y.z<y.y?y=y.xzy:y;\n           \n            s*=e=1.4+sin(iTime*.234)*.1;\n            y=abs(y)*e-\n                vec3(\n                    15.+sin(iTime*.3+.5*sin(iTime*.3))*3.,\n                    120,\n                    7.+cos(iTime*.2)*5.*n2\n                 )+O2.xyz-col+d2+c22;\n         }\n         f+=e=length(y.yz)/s;\n       \n    };\n \n\n    fragColor = vec4(O.xyz, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}