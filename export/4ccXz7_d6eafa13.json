{"ver":"0.1","info":{"id":"4ccXz7","date":"1713713191","viewed":69,"name":"sdf Rounded Rectangle and Border","username":"lgc","description":"sdf of rounded rectangle with different corner radius; sdf of border with different width.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","roundedrectangle","roundedborder"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// xy: half size\nfloat sd_rectangle(vec2 p, vec2 xy) {\n    vec2 d = abs(p) - max(xy, 0.0);\n    float outer = length(max(d, 0.0));\n    float inner = min(max(d.x, d.y), 0.0);\n    return outer + inner;\n}\n\n// xy: half size\n// r: radius [top left, top right, bottom left, bottom right]\nfloat sd_rounded_rectangle(vec2 p, vec2 xy, vec4 r) {\n    float s = r[int(p[0] > 0.0) + int(p[1] < 0.0) * 2];\n    // shrink when `radius < min(w,h)/2`\n    s = min(s, min(xy.x, xy.y));\n    return sd_rectangle(p, xy - s) - s;\n}\n\n// xy: half size\n// border: border width [top, right, bottom, left]\nfloat sd_border(vec2 p, vec2 xy, float r, vec4 border) {\n    vec2 dp = vec2(border[1] - border[3], border[0] - border[2]) / 2.;\n    vec2 inner_p = p + dp;\n    vec2 dxy = vec2(border[1] + border[3], border[0] + border[2]) / 2.;\n    vec2 inner_xy = xy - dxy;\n    float d2 = sd_rounded_rectangle(p, xy, vec4(r));\n    if(d2 > 0.0 || inner_xy.x < 0.0 || inner_xy.y < 0.0) {\n        return d2;\n    }\n    // FIXME: when border widths are different, inner corner should be ellipse\n    // FIXME: when inner corner radius shrinks, it will not match outer corner\n    float r0 = max(r - max(border[3], border[0]), 0.0);\n    float r1 = max(r - max(border[0], border[1]), 0.0);\n    float r2 = max(r - max(border[2], border[3]), 0.0);\n    float r3 = max(r - max(border[1], border[2]), 0.0);\n    vec4 inner_r = vec4(r0, r1, r2, r3);\n    float d1 = sd_rounded_rectangle(inner_p, inner_xy, inner_r);\n    return d1 < 0.0 ? -d1 : max(-d1, d2);\n}\n\nvec4 visualize(float d) {\n    // return vec4(smoothstep(0.01, -0.01, d));\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)));\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float w = min(iResolution.x, iResolution.y) / 2.0;\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / w;\n    vec2 m = (iMouse.xy * 2.0 - iResolution.xy) / w;\n\n    // float d = sd_circle(p, length(m));\n    // float d = sd_rectangle(p, abs(m));\n    // vec4 r = vec4(0.1, 0.2, 0.3, 0.4);\n    // float d = sd_rounded_rectangle(p, abs(m), r);\n    vec4 border = vec4(0.1, 0.2, 0.3, 0.4);\n    float d = sd_border(p, abs(m), 0.4, border);\n\n    fragColor = visualize(d);\n}","name":"Image","description":"","type":"image"}]}