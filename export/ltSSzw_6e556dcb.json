{"ver":"0.1","info":{"id":"ltSSzw","date":"1442381868","viewed":561,"name":"Modular Raymarching Spheres","username":"vamoss","description":"Studying raymarching, trying to acquire this result:<br/>http://33.media.tumblr.com/d8a5312755288bed2952eed4eeff4b16/tumblr_njjdh9EABY1rpco88o2_r1_500.gif","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float VERY_LARGE_DISTANCE = 100.;\nconst int MAX_STEPS = 80;\n\n#define TWO_PI 6.2831852\n\n//=====================================================\n//raymarching\n\n#define pMod(a, b) (mod(a,b)-0.5*b)\n\n\nvec3 opRotX(in float x, in vec3 point) {\n    return vec3(point.x, point.y*cos(x)-point.z*sin(x), point.y*sin(x)+point.z*cos(x));\n}\n\nmat3 mRotX(in float x) {\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, cos(x), -sin(x),\n        0.0, sin(x), cos(x)\n        );\n}\n\nvec3 opRotY(in float y, in vec3 point) {\n    return vec3(point.x*cos(y)-point.z*sin(y), point.y, point.x*sin(y)+point.z*cos(y));\n}\n\nmat3 mRotY(float y) {\n    return mat3(\n        cos(y), 0.0, -sin(y),\n        0.0, 1.0, 0.0,\n        sin(y), 0.0, cos(y)\n        );\n}\n\nvec3 opRotZ(in float z, in vec3 point) {\n    return vec3(point.x*cos(z)-point.y*sin(z), point.x*sin(z)+point.y*cos(z), point.z);\n}\n\nmat3 mRotZ(in float z) {\n    return mat3(\n        cos(z), -sin(z), 0.0,\n        sin(z), cos(z), 0.0,\n        0.0, 0.0, 1.0\n        );\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat fSphere(in vec3 p, in float r) {\n    return length(p)-r;\n}\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdBox(in vec3 p, in vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone(in vec3 p, in vec3 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -p.y-c.z;\n    float d2 = max(dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2),0.0)) + min(max(d1, d2), 0.0);\n}\n\nfloat sdCappedCone(in vec3 p, in vec2 c) {\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.z));\n}\n\nfloat fCylinder(in vec3 p, in float r, in float height) {\n    return max(length(p.xz)-r,abs(p.y)-height);\n}\nfloat fInfCylinder(in vec2 p, in float r) {\n    return length(p)-r;\n}\n\nfloat fCapsule(in vec3 p, in float r, in float c) {\n    return mix(length(p.xz)-r,\n               length(vec3(p.x,abs(p.y)-c,p.z))-r,\n               step(c, abs(p.y)));\n}\n\nfloat fPlane(in vec3 p, in vec3 n) {\n    return dot(p, n);\n}\n\n//=====================================================\n//custom\n\nfloat map( in vec3 p )\n{\n    return fSphere(pMod(p.xyz, 2.5), 0.1);\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = VERY_LARGE_DISTANCE;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<MAX_STEPS; i++ )\n    {\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 getPosition( float time ) { return vec3(     2.5*sin(1.0*time), 0.0,      1.0*cos(1.0*time) ); }\n\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    //camera target\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    \n    //camera rotation\n    float rotVel = iTime/5.0+iMouse.x/iResolution.x;\n    float rotRadius = 30.0;\n    vec3 ro = vec3( rotRadius*sin(rotVel), 0.0, rotRadius*cos(rotVel));\n    \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    vec3 col = vec3(1.0);\n    \n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        col = mix(vec3(0.0), col, t/float(MAX_STEPS)*2.0);\n\t}\n\n\tcol = clamp(col,0.0,1.0);\n\tfragColor = vec4( col, 1.0);\n}","name":"Image","description":"","type":"image"}]}