{"ver":"0.1","info":{"id":"3dByRD","date":"1586162002","viewed":381,"name":"Julia Glassblower Recoloured","username":"mla","description":"Variant on [url]https://www.shadertoy.com/view/tdjczh[/url] - a more colourful background, also added mouse rotation.","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["glassblower"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by David Gallardo - xjorma/2019\n// Modified Matthew Arcus - mla/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#if HW_PERFORMANCE==0\n#else\n#define AA\n#endif\n\n#define BIASED_NORMAL \t1\n#define MAX_BOUNCES     4\n#define MAX_DIST\t\t4.\n#define ABSORB\t\t\tvec3(0., 0.5, 1.3)\n\nconst int maxIterations = 6;\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat saturate(float c)\n{\n    return clamp(c,0.,1.);\n}\n\n\n// http://www.cs.cmu.edu/~kmcrane/Projects/QuaternionJulia/paper.pdf\n\nvec4 quatMult( vec4 q1, vec4 q2 )\n{\n    vec4 r;\n    r.x = q1.x*q2.x - dot( q1.yzw, q2.yzw );\n    r.yzw = q1.x*q2.yzw + q2.x*q1.yzw + cross( q1.yzw, q2.yzw );\n    return r;\n}\n\nvec4 quatSq( vec4 q )\n{\n    vec4 r;\n    r.x = q.x*q.x - dot( q.yzw, q.yzw );\n    r.yzw = 2.*q.x*q.yzw;\n    return r;\n}\n\n#define ESCAPE_THRESHOLD 1e1\n\nvoid iterateIntersect( inout vec4 q, inout vec4 qp, vec4 c, int maxIterations )\n{\n    for( int i=0; i<maxIterations; i++ )\n    {\n        qp = 2.0 * quatMult(q, qp);\n        q = quatSq(q) + c;\n        if( dot( q, q ) > ESCAPE_THRESHOLD )\n        {\n            break;\n        }\n    }\n}\n\n\nfloat map(in vec3 p)\n{\n    vec4 z = vec4( p, 0 );\n\tvec4 zp = vec4( 1, 0, 0, 0 );\n    float t = iTime * 0.1;\n    vec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n\titerateIntersect( z, zp, c, maxIterations );\n\tfloat normZ = length( z );\n\tfloat d = 0.5 * normZ * log( normZ ) / length( zp ); //lower bound on distance to surface\n    return d;\n}\n\n\nvec3 getSkyColor(vec3 rd)\n{\n    return rd;\n    //vec3 col = texture(iChannel0, rd).rgb;\n    //return col*col;\n}\n\n\nfloat rayMarch(in float sgn, in vec3 ro, in vec3 rd, in float offT)\n{\n  float t = offT;\n  for (int i = 0; i < 60; i++)\n  {\n    float h = sgn * map(ro + rd * t);\n    t += h;\n    if (h < 0.001 || t > MAX_DIST)\n        break;\n  }\n  return t;\n}\n\n#define EPS  0.02\n\n#if BIASED_NORMAL\nvec3 calcNormal(vec3 pos)\n{\n    float\tref;\n    float\ttrans;\n    vec3\tabsorb;\n    vec3\tcol;\n    vec2\teps = vec2(EPS, 0);\n\tfloat d = map(pos);\n\treturn normalize(vec3(map(pos + eps.xyy) - d, map(pos + eps.yxy) - d, map(pos + eps.yyx) - d));\n}\n#else\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = EPS;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n#endif\n\nvec3 Render(in vec3 ro, in vec3 rd)\n{\n    float sgn = 1.;\n    float cref = 0.7;\n    vec3  col = vec3(0);\n    vec3  rel = vec3(1);\n    float transp = 0.9;\n    vec3  absorb = ABSORB;\n    for(int i = 0; i < MAX_BOUNCES; i++)\n    {\n        float t = rayMarch(sgn, ro, rd, 0.02);\n        if( t> MAX_DIST)\n        {\n            col += rel * getSkyColor(rd);\n            break;\n        }\n        vec3 rabs = mix(absorb, vec3(0), (sgn + 1.) / 2.);\n        vec3 beerlamb = exp(-rabs * t);\n        vec3 p = ro + rd * t;\n        vec3 n = sgn * calcNormal(p);\n        vec3 refl = reflect(rd, n);\n        vec3 refr = refract(rd, n, cref);\n        //float fresnel = 1.0 - pow(dot(n, -rd), 2.);\n        float fresnel = pow(1.0 - abs(dot(n, rd)), 2.0);\n        float reflectorFactor = mix (0.2, 1.0, fresnel);\n        float refractionFactor = mix (transp, 0., fresnel);\n    \n    \tcol += (1.0 - refractionFactor) * rel * beerlamb * getSkyColor(refl) * reflectorFactor;\n    \trel *= refractionFactor * beerlamb;     \n        \n       \tro = p;     \n        if (refr == vec3(0.0))\n        {\n            rd = refl;\n        }\n        else\n        {\n            rd = refr; \n            sgn *= -1.;\n            cref = 1. / cref;\n        }        \n    }\n    col += rel * getSkyColor(rd);\n    return col;\n}\n\nvec3 contrast( in vec3 color, in float c)\n{\n    float t = 0.5 - c * 0.5; \n    return color * c + t;\n}\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q)\n{\n\tcol = pow(col, vec3(0.9));\n\tcol = contrast(col, 1.2);\n\t//col = vignette(col, q, 0.8);\n\treturn col;\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat3 genMat(in vec3 dir,in vec3 up)\n{\n\tvec3 cw = normalize(dir);\n\tvec3 cu = normalize( cross(cw,up) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nbool dorotate = true;\nfloat PI = 3.14159;\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    p.yz = rotate(p.yz,t*0.125);\n    p.zx = rotate(p.zx,t * 0.2);\n  }\n  return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 tot = vec3(0.0);\n#ifdef AA\n\tvec2 rook[4];\n    rook[0] = vec2( 1./8., 3./8.);\n    rook[1] = vec2( 3./8.,-1./8.);\n    rook[2] = vec2(-1./8.,-3./8.);\n    rook[3] = vec2(-3./8., 1./8.);\n    for( int n=0; n<4; ++n )\n    {\n        // pixel coordinates\n        vec2 o = rook[n];\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else //AA\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif //AA\n \n        // camera\n        //float theta\t= radians(90. + iTime*10.);\n        //float phi\t= radians(90.);\n        \n        //float theta\t= radians(360.)*(iMouse.x/iResolution.x-0.5);\n        //float phi\t= radians(90.)*(iMouse.y/iResolution.y-0.5)-1.;\n        //float theta\t= radians(90.);\n        //float phi\t= radians(50.);\n        vec3 ro = 2.0*vec3(0,0,1); //vec3( sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta));\n        vec3 ta = vec3( 0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta );\n        //vec3 cd = ca[2];    \n        \n        vec3 rd =  ca*normalize(vec3(p,1.5));        \n\n        ro = transform(ro);\n        rd = transform(rd);\n        rd = normalize(rd);\n        vec3 col = Render(ro ,rd);\n        \n\n        tot += col;\n            \n#ifdef AA\n    }\n    tot /= 4.;\n#endif\n        \n    tot = postProcess(tot,fragCoord / iResolution.xy);\n    \n\tfragColor = vec4( sqrt(tot), 1.0 );\n}","name":"Image","description":"","type":"image"}]}