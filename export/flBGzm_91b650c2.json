{"ver":"0.1","info":{"id":"flBGzm","date":"1623669895","viewed":476,"name":"2D RIPPLES","username":"alro","description":"Click to perturb surface","likes":27,"published":1,"flags":32,"usePreview":0,"tags":["waves","ripples","sea","water","light","fluid","ocean","transparent","caustics","scattering","translucent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2D water shader with wave propagation, transmittance and fake light shafts\n// Extension of https://www.shadertoy.com/view/NtBGRw\n\n// Based on:\n// https://web.archive.org/web/20160310071837/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm\n// See BufferA for wave simulation\n\n// Variables for 2D ray marching the water surface in the light direction\nconst int MAX_STEPS = 64;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 1e-3;\n\n// Index of refraction for water\n#define IOR 1.333\n\n// Ratios of air and water IOR for refraction\n// Air to water\n#define ETA 1.0/IOR\n\nvec3 waterColour = 0.3 * vec3(0.15, 0.5, 0.95);\n\n\n//-------------------------- Ray functions ----------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n// https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 at, vec3 up){\n    vec3 zaxis = normalize(at-camera);    \n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n\n    return mat3(xaxis, yaxis, -zaxis);\n}\n\nfloat getWaveHeight(vec2 pos){\n    return texture(iChannel0, vec2(pos.x, 0.0)).r;\n}\n\n//------------------------- Surface intersection ---------------------------\n\nfloat getIntersection(vec2 start, vec2 rayDir){\n\t//Distance between sample points. Set according to previous sample\n    float stepSize = 0.0;\n    //Height of the water\n    float height = 0.0;\n    //Length of the ray\n    float dist = 0.0;\n    //Difference between sample point and water height\n    float diff = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        //Sample point\n        vec2 p = start + rayDir * dist;\n        \n        height = getWaveHeight(p);\n        \n        diff = abs(height-p.y);\n        \n        if(diff < EPSILON){\n            return dist;\n        }\n        \n        if(height < p.y){\n            return dist;\n        }\n\n        stepSize = diff * 0.25;\n        \n        //Increment ray\n        dist += stepSize;\n        \n        if(dist > MAX_DIST){\n        \treturn MAX_DIST;\n        }\n    }\n    return dist;\n}\n\nvec2 getNormal(vec2 pos){\n    float eps = 1e-2;\n    return normalize(vec2( 2.0 * eps, getWaveHeight(pos-eps) - getWaveHeight(pos+eps)));\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // The ratio of the width and height of the screen\n    float widthHeightRatio = iResolution.x/iResolution.y;\n\n    vec2 pos = uv;\n    \n    // Shift everything up so that y == 0 is in the middle of the screen\n    pos.y = uv.y - 0.5;\n    \n    // Adjust y by ratio for uniform transforms\n    pos.y /= widthHeightRatio;\n\n    \n    //----------------- Define a camera -----------------\n    \n    vec3 rayDir = rayDirection(70.0, fragCoord);\n\n    vec3 cameraPos = vec3(-10.0, 0.0, 0.0);\n\n    vec3 targetDir = -normalize(cameraPos);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    // Get the view matrix from the camera orientation.\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n\n    // Transform the ray to point in the correct direction.\n    rayDir = normalize(viewMatrix * rayDir);\n\n    //---------------------------------------------------\n    \n    // Get the water height at current x-position\n    float height = getWaveHeight(pos);\n    \n    // Fragment depth under surface\n    float depth = height-pos.y;\n    \n    // 0 if air\n    // 1 if water\n    // smooth transition between\n    float medium;\n    \n    medium = smoothstep(-0.0015, 0.0015, depth);\n    \n    // Refract the view ray at a single water plane\n    vec3 dir = normalize(mix(rayDir, refract(rayDir, vec3(-1.0, 0.0, 0.0), ETA), medium));\n    \n    // Blur the environment when viewed through water\n    float LOD = mix(0.0, 3.0, medium);\n    \n    // Read cubemap and undo gamma\n    vec3 background = pow(clamp(texture(iChannel1, dir, LOD).rgb, 1e-5, 1.0), vec3(2.2));\n\n    vec2 lightDir = normalize(vec2(0.5, 0.5)-pos);\n\n    // Fragment distance to surface in light direction\n    float light = getIntersection(pos, lightDir);\n\n    vec3 colour = waterColour * exp(-16.0 * depth);\n    \n    // Transmittance for light shafts\n    colour += waterColour * exp(-6.0 * light);\n    \n    // Overwrite anything above the surface\n    colour = mix(background, colour, medium);\n    \n    // Tonemapping\n    // Don't apply tonemapping to the cubemap above the water\n    if(medium > 0.0){\n        colour = ACESFilm(colour);\n    }\n\n    // Gamma correction 1.0/2.2 = 0.4545...\n    colour = pow(colour, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Wave propagation solver based on data in the last two frames\n// Produces a 1D heightmap stored in the first row of pixels\n\n#define DROPLETS\n\nfloat rand(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // If the first row of pixels\n    if(fragCoord.y == 0.5){\n    \n        //Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // Texture lookup epsilon\n        float eps = 1e-2;\n        // The height of the water surface\n        float height = 0.0;\n        // How much energy is maintained every frame\n        float dampen = 0.98;\n\n        vec2 data = texture(iChannel0, uv).rg;\n\n        // Find last frames' data to the left and right of current position\n        // Set wall conditions to be the same as first and last cells for \n        // reflective boundary conditions\n\n        vec2 leftData;\n        if(fragCoord.x == 0.5){\n            leftData = data;\n        }else{\n            leftData = texture(iChannel0, uv-vec2(eps, 0.0)).rg;\n        }\n\n        vec2 rightData;\n        if(fragCoord.x == iResolution.x-0.5){\n            rightData = data;\n        }else{\n            rightData = texture(iChannel0, uv+vec2(eps, 0.0)).rg;\n        }\n\n        if(iFrame == 0){\n\n            // Set initial conditions\n\n            // Some sine wave\n            height = 0.1*(sin(10.0*fragCoord.x/iResolution.x));\n\n            // Only perturb the middle of the screen\n            height *= smoothstep(0.15, 0.35, uv.x);\n            height *= smoothstep(0.85, 0.65, uv.x);\n\n            data = vec2(height);\n\n        }else{\n\n            // Depress surface at mouse x-coordinate \n            // (showing it the last few seasons of GoT should do it)\n            if(iMouse.z > 0.0){\n\n                // Scale strength by fragment distance from mouse\n                float dist = length(iMouse.x-fragCoord.x)/iResolution.x;\n                height = -0.00175 * smoothstep(0.1, 0.0, dist);\n            }\n            \n            #ifdef DROPLETS\n            // Random droplets to stop the surface ever being still\n            if(mod(float(iFrame), 10.0) == 0.0){\n \n                float pos = rand(float(iFrame));\n\n                float dist = length(pos-uv.x);\n                float droplet = smoothstep(0.05, 0.0, dist);\n\n                height -= 0.0015*droplet;\n\n            }\n            #endif\n\n            // Ripple propagation\n\n            // Previous data is in the red channel\n            // Data before that is in green\n            height += data.r + (0.5*(leftData.r + rightData.r) - data.g);\n\n            // Write new to red, previous to green\n            data = vec2(dampen * height, data.r);\n        }\n\n        fragColor = vec4(data, 1.0, 1.0);\n    \n    }else{\n        fragColor = vec4(1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}