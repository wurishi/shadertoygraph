{"ver":"0.1","info":{"id":"XsGGz3","date":"1455498475","viewed":180,"name":"Robert Mangold - Untitled - hdd","username":"Hanley","description":"A study in replicating and animating Robert Mangold's - Untitled (2008) - https://www.pinterest.com/pin/106467978665948145/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lines","noob","sine","study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nfloat circle (in vec2 pixel_n, in vec2 position_n, in float radius_n) {\n    float blurAmount_n = 0.01;\n    float brightness = smoothstep(radius_n + blurAmount_n, radius_n, distance(pixel_n, position_n));\n    return brightness;\n}\n\nfloat circleStroke (in vec2 pixel_n, in vec2 position_n, in float radius_n, in float stroke_width_n) {\n    float blurAmount_n = stroke_width_n * 0.5; // subjective\n    float radiusOuter = radius_n + stroke_width_n * 0.5;\n    float radiusInner = radius_n - stroke_width_n * 0.5;\n\n    float brightnessOuter = smoothstep(radiusOuter + blurAmount_n, radiusOuter, distance(pixel_n, position_n));\n    float brightnessInner = smoothstep(radiusInner + blurAmount_n, radiusInner, distance(pixel_n, position_n));\n\n    return brightnessOuter - brightnessInner;\n}\nfloat arcStroke (in vec2 pixel_n, in vec2 position_n, in float radius_n, in float stroke_width_n, float angleStart, float angleClose, in bool fill) {\n    // arc is drawn anti-clockwise between angleA and angleB\n\n    // ensure that angleA and angleB are between Ï€, -Ï€\n    angleStart = mod(angleStart+PI, TWO_PI) - PI;\n    angleClose = mod(angleClose+PI, TWO_PI) - PI;\n\n    // Determine Angles\n    vec2 vectorToCentre = position_n - pixel_n;\n    float pixelAngle = atan(vectorToCentre.y, vectorToCentre.x); // returns an angle between Ï€, -Ï€\n\n    if (angleClose < angleStart) {\n        // drawing through the radial-origin\n        if (pixelAngle < angleStart && pixelAngle > angleClose) {\n            return 0.0;\n        }\n    } else {\n        // drawing normally, from negative-to-positive angle\n        if (pixelAngle < angleStart || pixelAngle > angleClose) {\n            return 0.0;\n        }\n    }\n\n    // Draw Circle Stroke\n    float blurAmount_n = stroke_width_n * 0.5; // subjective\n    float radiusOuter = radius_n + stroke_width_n * 0.5;\n    float radiusInner = radius_n - stroke_width_n * 0.5;\n\n    float brightnessOuter = smoothstep(radiusOuter + blurAmount_n, radiusOuter, distance(pixel_n, position_n));\n    if (fill) {\n        return brightnessOuter;\n    }\n\n    float brightnessInner = smoothstep(radiusInner + blurAmount_n, radiusInner, distance(pixel_n, position_n));\n    return brightnessOuter - brightnessInner;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 st = uv; // pixel_n\n    float t = iTime ;\n\n    // Quick Aspect Ratio Fix\n    float aspect = iResolution.x / iResolution.y;\n    st -= vec2(0.5); // set origin to centre of screen\n    st.x *= aspect;\n\n    // Guides\n    float c = 13.5;\n    float radius1 = 3.9/c;\n    float radius1b = radius1 + 0.5/c;\n    float radius2 = radius1 + 1.0/c;\n    float radius3 = radius1 + 2.0/c;\n\n    float bgLineWidth = 0.004;\n\n    float tt = t * 3.0;\n    float timeOffset1 = - ( sin(tt-PI) + tt);\n    float timeOffset2 = sin(tt-PI) + tt;\n\n    // Circular Lines\n    float circleStroke1 = circleStroke(st, vec2(0.0), radius1, bgLineWidth);\n    float arcStroke1 = arcStroke(st, vec2(0.0), radius1b, bgLineWidth, PI*0.5, -PI*0.5, false);\n    float circleStroke2 = circleStroke(st, vec2(0.0), radius2, bgLineWidth);\n    float arcStroke3 = arcStroke(st, vec2(0.0), radius3, bgLineWidth, -PI*0.5, PI*0.5, false);\n    float circulars = circleStroke1 + arcStroke1 + circleStroke2 + arcStroke3;\n\n    // Angle Info\n    vec2 vectorToCentre = vec2(0.0) - st;\n    float distanceToCentre = length(vectorToCentre);\n    float pixelAngle = atan(vectorToCentre.y, vectorToCentre.x);\n\n    // Spokes\n    float brightnessIn = smoothstep(0.98, 1.0, fract( (pixelAngle * 10.0 + PI + timeOffset1*2.0) / TWO_PI));\n    float brightnessOut = smoothstep(0.02, 0.0, fract( (pixelAngle * 10.0 + PI + timeOffset1*2.0) / TWO_PI));\n    float spokes1 = brightnessIn + brightnessOut;\n    float mask1 = arcStroke(st, vec2(0.0), radius2, bgLineWidth, PI*0.5, -PI*0.5, true);\n    spokes1 = spokes1 * mask1;\n    \n    float brightnessIn2 = smoothstep(0.98, 1.0, fract( (pixelAngle * 6.0 + PI + timeOffset2 * 2.0) / TWO_PI));\n    float brightnessOut2 = smoothstep(0.02, 0.0, fract( (pixelAngle * 6.0 + PI + timeOffset2 * 2.0) / TWO_PI));\n    float spokes2 = brightnessIn2 + brightnessOut2;\n    float mask2 = arcStroke(st, vec2(0.0), radius3, bgLineWidth, -PI*0.5, PI*0.5, true);\n    spokes2 = spokes2 * mask2;\n\n    float brightnessIn3 = smoothstep(0.995, 1.0, fract( (pixelAngle * 2.0 + PI) / TWO_PI));\n    float brightnessOut3 = smoothstep(0.005, 0.0, fract( (pixelAngle * 2.0 + PI) / TWO_PI));\n    float spokesPermanent = brightnessIn3 + brightnessOut3;\n    float mask3 = arcStroke(st, vec2(0.0), radius3, bgLineWidth, 0.0, -0.00001, true);\n    spokesPermanent = spokesPermanent * mask3;\n\n    float maskCircle = arcStroke(st, vec2(0.0), radius1-bgLineWidth, bgLineWidth, 0.0, -0.00001, true); // creates a circle\n    float spokes = (spokes1 + spokes2 + spokesPermanent) * (1.0-maskCircle);\n\n    // Wavy Lines\n    float waveLineWidth = 0.009;\n    float radius = sin(pixelAngle*5.0+PI*0.5 + timeOffset1)*(radius1b-radius1)+radius1b;\n    float wave1 = arcStroke(st, vec2(0.0), radius, waveLineWidth, PI*0.5, -PI*0.5, false);\n    radius = sin(pixelAngle*3.0 + PI*0.5 + timeOffset2)*(radius2-radius1)+radius2;\n    float wave2 = arcStroke(st, vec2(0.0), radius, waveLineWidth, -PI*0.5, PI*0.5, false);\n    float waves = wave1 + wave2;\n    float backgroundLines = max(circulars, spokes)*0.33;\n    \n    vec3 color = vec3(0.0); \n    // color = vec3( max(backgroundLines, waves) );\n    color = vec3( sqrt(backgroundLines + waves) );\n\n    vec3 tint = vec3(0.6,0.95,0.98);\n    color = color*tint;\n\n    // Render Color\n      fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}