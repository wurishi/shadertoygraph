{"ver":"0.1","info":{"id":"Wl33zB","date":"1576704146","viewed":133,"name":"boxTest","username":"BrianDeLange","description":"creating a box test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFINITY 10000.\n\nmat4 inv(mat4 matrix)\n{\n    mat4 m = mat4(1., 0., 0., 0.,\n                  0., 1., 0., 0.,\n                  0., 0., 1., 0.,\n                  0., 0., 0., 1.);\n    \n    for(int row = 0; row < 4; row++){\n        float v = 1./matrix[row][row];\n        for(int col = 0; col < 4; col++){\n            matrix[row][col] *= v;\n            m[row][col] *= v;\n        }\n        for(int r = 0; r < 4; r++){\n            if(r != row){\n                float e = -matrix[r][row];\n                for(int col = 0; col < 4; col++){\n                    matrix[r][col] += e*matrix[row][col];\n                    m[r][col] += e*m[row][col];\n                }\n            }\n        }\n    }\n    return m;\n}\n\nmat4 Camera(vec3 position, vec3 forward, vec3 upguide)\n{\n    forward = normalize(forward);\n    vec3 right = normalize(cross(upguide, forward));\n    vec3 up = normalize(cross(forward, right));\n    \n    return mat4(right.x, up.x, forward.x, position.x,\n                right.y, up.y, forward.y, position.y,\n                right.z, up.z, forward.z, position.z,\n                0., 0., 0., 1.);\n}\n\nmat4 rotateX(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(1., 0., 0., 0.,\n                0., c , -s, 0.,\n                0., s , c , 0.,\n                0., 0., 0., 1.);\n}\n\nmat4 rotateY(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(c , 0., s , 0.,\n                0., 1., 0., 0.,\n                -s, 0., c , 0.,\n                0., 0., 0., 1.);\n}\n\nmat4 rotateZ(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat4(c , -s, 0., 0.,\n                s , c , 0., 0.,\n                0., 0., 1., 0.,\n                0., 0., 0., 1.);\n}\n\nmat4 GetBoxTransform(vec3 position, vec3 scale, vec3 rotation)\n{\n    mat4 rot = rotateX(rotation.x)*rotateY(rotation.y)*rotateZ(rotation.z);\n    return mat4(scale.x, 0., 0., 0.0,\n                0., scale.y, 0., 0.0,\n                0., 0., scale.z, 0.0,\n                0., 0., 0., 1.)*\n        rot*\n        mat4(1., 0., 0., position.x,\n             0., 1., 0., position.y,\n             0., 0., 1., position.z,\n             0., 0., 0., 1.);\n}\n    \nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Plane{\n    vec3 position;\n    vec3 normal;\n};\n    \nstruct Box{\n    vec3 position;\n    mat4 transform;\n};\n    \nstruct BoundingBox{\n    vec3 Min;\n    vec3 Max;\n};\n\nstruct Data{\n    vec3 normal;\n    float dist;\n};\n\n    \nvec3 getPostion(Ray ray, float dist){\n\n    return ray.origin + ray.direction * dist;\n\n}\n\nData distPlane(Ray ray, Plane plane)\n{\n    Data d;\n    float denom = dot(plane.normal, ray.direction);\n    if (denom < 0.)\n    {\n        vec3 originPosition = plane.position - ray.origin;\n        \n        d.normal = plane.normal;\n        d.dist = dot(originPosition, plane.normal) / denom;\n        \n        return d;\n    }\n    d.dist = INFINITY;\n    return d;\n}\n\nfloat checkPosition(Plane plane, Ray ray, Box box){\n    vec3 vecMin = vec3(-.5, -.5, -.5);\n    vec3 vecMax = vec3(.5, .5, .5);\n\n    \n    float dist = distPlane(ray, plane).dist;\n    vec3 intersectionPoint = (getPostion(ray, dist));\n    if(dist > 0. && \n       intersectionPoint.x > vecMin.x-0.001 && intersectionPoint.x < vecMax.x+0.001 && \n       intersectionPoint.y > vecMin.y-0.001 && intersectionPoint.y < vecMax.y+0.001 && \n       intersectionPoint.z > vecMin.z-0.001 && intersectionPoint.z < vecMax.z+0.001)\n        return dist;\n    return INFINITY;\n}\n\n\nData distBox(Ray ray, Box box)\n{\n    Data d;\n    d.dist = INFINITY;\n    ray.origin = (vec4((ray.origin.xyz), 1.)*inverse(box.transform)).xyz;\n    ray.direction = (vec4((ray.direction.xyz), 0.)*inverse(box.transform)).xyz;\n    \n    vec3 Fractal = 1./ray.direction;\n    \n    float Vmin = -1.;\n    float Vmax =  1.;\n    \n    float t1 = (Vmin - ray.origin.x) * Fractal.x;\n    float t2 = (Vmax - ray.origin.x) * Fractal.x;\n    float t3 = (Vmin - ray.origin.y) * Fractal.y;\n    float t4 = (Vmax - ray.origin.y) * Fractal.y;\n    float t5 = (Vmin - ray.origin.z) * Fractal.z;\n    float t6 = (Vmax - ray.origin.z) * Fractal.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (!(tmax < 0. || tmin > tmax))\n    {\n        d.dist = tmin;\n        vec3 centerVec = d.dist*ray.direction+ray.origin;\n        if(centerVec.x > 0.9999) d.normal = vec3(1., 0., 0.);\n        if(centerVec.x < -0.9999) d.normal = vec3(-1., 0., 0.);\n        if(centerVec.y > 0.9999) d.normal = vec3(0., 1., 0.);\n        if(centerVec.y < -0.9999) d.normal = vec3(0., -1., 0.);\n        if(centerVec.z > 0.9999) d.normal = vec3(0., 0., 1.);\n        if(centerVec.z < -0.9999) d.normal = vec3(0., 0., -1.);\n    }\n\n    return d;\n}\n\nBoundingBox calculateBoundingBox(Box box){\n    BoundingBox b;\n    \n    mat4 inv = box.transform;\n\n    float xPos = inv[0][3];\n    float yPos = inv[1][3];\n    float zPos = inv[2][3];\n    \n    float x = (abs(inv[0][0])+abs(inv[0][1])+abs(inv[0][2]));\n    float y = (abs(inv[1][0])+abs(inv[1][1])+abs(inv[1][2]));\n    float z = (abs(inv[2][0])+abs(inv[2][1])+abs(inv[2][2]));\n    \n    float minX = xPos-x;\n    float minY = yPos-y;\n    float minZ = zPos-z;\n    \n    float maxX = xPos+x;\n    float maxY = yPos+y;\n    float maxZ = zPos+z;\n    \n    b.Min = vec3(minX, minY, minZ);\n    b.Max = vec3(maxX, maxY, maxZ);\n    \n    return b;\n}\n\nbool RenderBoundingBox(Ray ray, BoundingBox box)\n{\n    \n    vec3 Fractal = 1./ray.direction;\n    \n    vec3 Vmin = box.Min;\n    vec3 Vmax = box.Max;\n    \n    float t1 = (Vmin.x - ray.origin.x) * Fractal.x;\n    float t2 = (Vmax.x - ray.origin.x) * Fractal.x;\n    float t3 = (Vmin.y - ray.origin.y) * Fractal.y;\n    float t4 = (Vmax.y - ray.origin.y) * Fractal.y;\n    float t5 = (Vmin.z - ray.origin.z) * Fractal.z;\n    float t6 = (Vmax.z - ray.origin.z) * Fractal.z;\n\n    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));\n    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));\n\n    if (!(tmax < 0. || tmin > tmax))\n    {\n        return true;\n    }\n\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 camPosition = vec3(0., 0., -4.);\n    mat4 cam = Camera(camPosition, vec3(0., 0., 1.), vec3(0., 1., 0.));\n    \n    Ray ray;\n    ray.origin = camPosition;\n    ray.direction = normalize(cam * vec4(uv.xy, 1.0, 0.)).xyz;\n    \n    Plane plane;\n    plane.position = vec3(0., -3., 0.);\n    plane.normal = vec3(0., 1., 0.);\n    \n    vec3 pos = vec3(0.);\n    \n    vec2 mouseUv = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    Ray positionRay;\n    positionRay.origin = camPosition;\n    positionRay.direction = normalize(cam * vec4(mouseUv, 1.0, 0.)).xyz;\n    \n    Data p = distPlane(positionRay, plane);\n    pos = p.dist * positionRay.direction + positionRay.origin;\n    \n    Box boxes[3];\n    boxes[0].transform = GetBoxTransform(pos, vec3(0.5, 0.5, 0.5), vec3(iTime, iTime, 0.));\n    //boxes[0].transform = rotateX(iTime*2.)*(rotateZ(iTime)*boxes[0].transform);\n    boxes[1].transform = GetBoxTransform(vec3(-3., 0., 6.), vec3(2., 2., 1.), vec3(2.*iTime, 0., 2.*iTime));\n    boxes[2].transform = GetBoxTransform(vec3( 3., 0., 6.), vec3(2., 2., 1.), vec3(iTime, 0., 2.*iTime));\n    \n    BoundingBox boundingBoxes[3];\n    boundingBoxes[0] = calculateBoundingBox(boxes[0]);\n    boundingBoxes[1] = calculateBoundingBox(boxes[1]);\n    boundingBoxes[2] = calculateBoundingBox(boxes[2]);\n    \n    vec3 col;\n    Data d = distPlane(ray, plane);\n    //d.dist = INFINITY;\n    vec3 intersectPoint = ray.direction*d.dist+ray.origin;\n    vec3 localNormal = vec3(0., 1., 0.);\n    for(int i = 0; i < 3; i++){\n        Data d2 = distBox(ray, boxes[i]);\n        if(d2.dist < d.dist) {\n            d = d2;\n            localNormal = d.normal;\n            d.normal = (vec4(d.normal, 0.)*boxes[i].transform).xyz;\n            intersectPoint = (boxes[i].transform* vec4((inverse(boxes[i].transform)*vec4(ray.direction, 0.)).xyz*d.dist, 0.)).xyz+\n                              ray.origin;\n            \n        }\n    }\n                    \n    vec3 lights[4];\n    lights[0] = vec3(0., 0., 0.);\n    lights[1] = vec3(-6., 4., -5.73);\n    lights[2] = vec3(2., -1., -2.423);\n    lights[3] = vec3(0., -3., -4.5);\n    \n    for(int i = 0; i < 4; i++){\n        if(d.dist > 0. && d.dist < INFINITY) col += (localNormal*0.5+0.5) * dot(d.normal, \n                                        normalize(lights[i]-intersectPoint));\n    }\n\n    fragColor = vec4(col,1.0);\n    \n    for(int i = 0; i < 3; i++){\n        if(RenderBoundingBox(ray, boundingBoxes[i])){\n            fragColor += vec4(1., 0., 0., .5);\n        }\n    }\n    \n}","name":"Image","description":"","type":"image"}]}