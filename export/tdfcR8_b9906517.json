{"ver":"0.1","info":{"id":"tdfcR8","date":"1584111740","viewed":151,"name":"simple raymarching_aganztracy","username":"aganztracy","description":"simple raymarching test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat GetDist(vec3 p){//计算从p点出发，继续步进，hit到场景中一点的最短距离\n\n    //此处场景中假设只有一个平面和球体，\n    //那么要计算p到平面的最短距离以及p到球体最短距离的较小值\n    \n    vec4 s = vec4(0, 1, 0, 1);//球体x,y,z,r\n    float sphereDist = sdSphere(p-s.xyz, s.w);\n    \n    float planeDist = sdPlane(p);//点到地面距离为点的y坐标\n    \n    float d = min(sphereDist , planeDist);//取（最）较小值\n    return d;//由此得到了p点到场景中hit到的最近点的距离\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    //射线以hit到场景中物体的最小距离向前步进\n    float d0=0.;\n    \n    for(int i=0;i<MAX_STEPS;i++){//在给定的步数下步进\n        vec3 p = ro+rd*d0;//当前步进到的点的位置\n        float dS = GetDist(p);//算出从当前点向前步进能hit物体的最短距离\n        d0 += dS;//向前一步，更新当前位置\n        \n        if(d0>MAX_DIST || dS<SURF_DIST)//如果ray已经超过设定的最长步进距离或者hit到了某一点\n   \t\tbreak;//不再向前步进\n    }\n    \n    return d0;//返回相机到hit的点的距离\n    //之后根据得到的距离计算材质 颜色 光照。\n}\n\nvec3 GetNormal(vec3 p){//得到着色点的法向量\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n    //注意上下两个表达式是一样的\n    //vec3 n = vec3(\n    //   d - GetDist(p - e.xyy),\n    //   d - GetDist(p - e.yxy),\n    //   d - GetDist(p - e.yyx));\n    return normalize(n);\n}\n\n\n\nvec3 Bg(vec3 rd) {\n    return texture(iChannel0, rd).rgb;\n}\n\nvec3 render(in vec3 ro, in vec3 rd){\n\n    vec3 col = Bg(rd);//cubemap贴图的底色\n    \n    float d=RayMarch(ro ,rd);//得到当前射线方向能hit到的物体表面的最小距离\n    vec3 p = ro + rd * d;//着色点，即从相机发出的射线hit到的物体表面点\n    \n    //--------normal--------\n    vec3 normal = GetNormal(p);\n    \n    //--------diffuse--------\n    vec3 lightPos = vec3(0, 5, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime)) *2.;//让灯光绕圈运动\n    vec3 light = normalize(lightPos - p);\n    //漫反射计算\n    float dif = clamp(dot(normal, light), 0., 1.);//dot点乘有可能为负，所以需要clamp\n    //硬阴影计算：从着色点p向着灯光方向l发射ray 进行march，如果距离小雨灯光到该点的距离，则说明该点没有直接照射到灯光，处于阴影之下。\n    //由于着色点p实际上是在某个物体的表面点，因此距离本身所在的物体极近，为了不让该射线hit到自身，因此p点要做一点小小的偏移n*SURF_DIST\n    //如果场景还是有问题，就再把该偏移拉大一点，所以此处乘以2.了\n    float d_p_to_light = RayMarch(p+normal*SURF_DIST*2., light);\n    if(d_p_to_light < length(lightPos-p))  dif *= .1;//乘以一个小点的数，表示阴影。或者也可直接设置成0；\n    \n    //--------reflection--------\n    vec3 r = reflect(rd, normal);\n    vec3 reflection = Bg(r);\n    col = reflection * dif;\n        \n    \n    \n    \n    return vec3(col);\n\n}\n\n// camera to world \nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )//rayorigin lookat-target\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n//------------------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (fragCoord)/iResolution.xy-0.5;//仅仅把uv坐标映射到-0.5～0.5，u和v的单位长度不一致，因此画面会拉伸\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;//为了让屏幕坐标原点在屏幕中心，且xy轴伸缩一致\n    \n    \n    ///[camera]\n    \n    //（直接设置相机位置及其方向），该相机是一个正交相机\n    //vec3 ro=vec3(0,1,0);//ray origin-->camera position\n    //vec3 rd=normalize(vec3(uv.x,uv.y,1));// 根据相机位置和屏幕uv得到从相机发出的ray的direction\n \n    \n    //（根据鼠标位置绕目标旋转），该相机是一个针孔相机？\n    //ray origin 相机位置, iTime后乘积是为了让屏幕自动旋转\n    vec3 ro = vec3(sin(iMouse.x / iResolution.x*3. + iTime*1.) * 9., 2.0, cos(iMouse.x / iResolution.x*3. + iTime*1.0) * 9.);\n    //camera target\n    vec3 ta = normalize(vec3(0.0, 0.1, 0.0));\n    //根据相机的参数求到相机变换矩阵ViewMat ca\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(uv.xy,2.0) );//相机屏幕在z轴为2.0处，ra为从相机出发射向屏幕的ray的raydirection\n    \n    \n    ///[render]\n    vec3 col = render(ro, rd);\n    \n    col = pow(col, vec3(.4545));\t// gamma correction ：1/2.2 = .4545\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n","name":"Common","description":"","type":"common"}]}