{"ver":"0.1","info":{"id":"MtsBR4","date":"1511204236","viewed":611,"name":"Sega Master System BIOS","username":"fgsfds","description":"A recreation of the attract mode from JPN SMS BIOS v2.1. Not very accurate.\nI'm much too dumb to write a working FM synth, so I used the closest track I found on Soundcloud (courtesy of haji/BlueHairKei).\nCredits to iq, Flyguy, KINGGOLDrus, AxleMike.","likes":16,"published":1,"flags":96,"usePreview":0,"tags":["star","bitmap","sprite","8bit","scroller","sega","sms","segamastersystem","mastersystem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"ldjXzR","filepath":"https://soundcloud.com/haji-19812703/space-harrier-main-theme-sega-master-system-v21j-bios-mdggnes-mix","previewfilepath":"https://soundcloud.com/haji-19812703/space-harrier-main-theme-sega-master-system-v21j-bios-mdggnes-mix","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SMS BIOS attract mode by fgsfds\n// requires WebGL2: uses bitops and dynamic array indexing\n// last updated 22/11/17 20:41 MSK:\n// - I realized that WebGL 2 also has bitwise ops and logical xor;\n// - added precision qualifiers in buffers just in case.\n// credits:\n// - KINGGOLDrus for testing and help;\n// - iq for voronoi() and hash2d();\n// - Flyguy for his method of packing bitmaps (/view/Mt2GWD);\n// - AxleMike for his starfield shader (/view/XtjSDh),\n//   from which i stole the star generating code;\n// - haji/BlueHairKei for the music.\n\n// if defined, the screen size multiplier is rounded down\n#define INTEGER_SCALE\n// if defined, width and height are scaled by the same amount\n#define KEEP_ASPECT\n// if defined, floor scrolls at a lower framerate like in the original\n#define CUT_FLOOR_FPS\n\n#define SCROLL_SPEED 24.0\n\n\n// hash and voronoi functions by iq\n// used here to generate a starfield\nvec2 hash2d(in vec2 p) {\n  float h = dot(p, vec2(12.9898, 78.233));\n  float h2 = dot(p, vec2(37.271, 377.632));\n  return -1.0 + 2.0 * vec2(fract(sin(h) * 43758.5453), fract(sin(h2) * 43758.5453));\n}\n\nfloat voronoi(in vec2 p) {\n  vec2 n = floor(p);\n  vec2 f = fract(p);\n  vec2 mg, mr;\n  float md = 8.0;\n  for(int j = -1; j <= 1; ++j) {\n    for(int i = -1; i <= 1; ++i) {\n      vec2 g = vec2(float(i), float(j));\n      vec2 o = hash2d(n + g);\n      vec2 r = g + o - f;\n      float d = dot(r, r);\n      if(d < md) {\n        md = d;\n        mr = r;\n        mg = g;\n      }\n    }\n  }\n  return md;\n}\n\nvec4 text(in vec2 p) {\n  vec2 pos = vec2(41, 72);\n  vec2 size = vec2(197, 56);\n  float bounds = float(all(greaterThanEqual(p, pos)) && all(lessThan(p-pos, size)));\n  return bounds*texture(iChannel0, (p - pos) / size);\n}\n\nvec4 fallingstar(in vec2 p) {\n  ivec2 ip = ivec2(p);\n  ip.x -= 128;\n  float cx = sin(iTime / 10.0) * 200.0;\n  float rad = 350.0 + 50.0 * sin(iTime / 12.0);\n  int y = int(256.0 - sin(iTime * 1.25) * rad);\n  int x = int(256.0 + cx + cos(iTime * 1.25) * rad);\n  float w = float(ip.x == x && ip.y == y);\n  return vec4(w, w, w, 1.0);\n}\n\nvec4 starfield(in vec2 p) {\n  p = ceil(p);\n  const float t = 0.0005;\n  const float yend = 141.0;\n  float star = voronoi(p * 6.68);\n  float bounds = float(p.y < yend);\n  float c = float(star < t) * bounds;\n\n  ivec2 ip = ivec2(p / 16.0);\n  ivec2 is = ivec2(ceil(256.0 / 16.0));\n  int itotal = is.x * is.y;\n\n  \n  int idx = ip.y * is.x + ip.x;\n  float b = float((int(iTime * 2.5 + 32.0) % itotal) == idx);\n  \n  vec4 res = vec4(c*b*1.0, c*(0.5098 + b*0.4902), c*(0.7803 + b*0.2197), 1.0);\n  return res + bounds * fallingstar(p);\n}\n\nvec4 segaLogo(in vec2 p) {\n  vec2 pos = vec2(40, 8);\n  vec2 size = vec2(179, 50);\n  float bounds = float(all(greaterThanEqual(p, pos)) && all(lessThan(p-pos, size)));\n  return bounds*texture(iChannel1, (p - pos) / size);\n}\n\nfloat floorTexture(in vec2 p) {\n  vec2 fp = mod(p, 2.0);\n  bvec2 f = greaterThan(fp, vec2(1.0));\n  return float(f.x ^^ f.y);\n}\n\n// red ticks 0x40 every 8.5 seconds\n// blue ticks 0x40 every 34 seconds, but it goes\n// 0 1 3 2 0 1 3 2 instead of 0 1 2 3 3 2 1 0 like red\nvec3 floorColor() {\n  const float r[8] = float[](0.0, 0.25, 0.5, 0.75, 0.75, 0.5, 0.25, 0.0);\n  const float b[4] = float[](0.0, 0.25, 0.75, 0.5);\n  int rc = int(floor(mod(iTime / 8.5, 8.0)));\n  int bc = int(floor(mod(iTime / 34.0, 4.0)));\n  return vec3(r[rc], 0.0, b[bc]);\n}\n\nvec4 floorScroll(in vec2 p) {\n  const float ystart = 142.0;\n  const vec2 size = vec2(256.0, 196.0 - 142.0);\n  const vec2 c = vec2(128.0, 110.0);\n\n  p = ceil(p);\n  float h = 0.35;\n  vec2 cp = (p - c) / size;\n  vec3 tp = vec3(cp.x, cp.y - h - 1.0, cp.y - h);\n  vec2 pm = tp.xy * vec2(1.75, 1.0) / tp.z + vec2(0.5, 0.0);\n  float bounds = float(p.y >= ystart);\n\n#ifdef CUT_FLOOR_FPS\n  vec2 spd = vec2(0, -floor(iTime * SCROLL_SPEED) * 0.2);\n#else\n  vec2 spd = vec2(0, -iTime * SCROLL_SPEED * 0.2);\n#endif\n  float ft = floorTexture(pm + spd);\n\n  float tm = mod(iTime, 25.0) / 5.0;\n\n  vec4 res = vec4(0.0, 0.0, 0.0, 1.0);\n  res.rgb = floorColor();\n  res.g = 0.25 + ft * 0.25;\n\n  res.rgb *= bounds;\n  return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n  const vec2 size = vec2(256.0, 192.0);\n\n#ifdef INTEGER_SCALE\n  vec2 vtimes = max(floor(iResolution.xy / size), vec2(1.0, 1.0));\n#else\n  vec2 vtimes = iResolution.xy / size;\n#endif\n\n#ifdef KEEP_ASPECT\n  float times = min(vtimes.x, vtimes.y);\n#else\n  vec2 times = vtimes;\n#endif\n  vec2 target = size * times;\n\n  vec2 center = iResolution.xy / 2.0;\n  vec2 pos = round(center - target / 2.0);\n\n  float bounds = float(all(greaterThanEqual(uv, pos)) && all(lessThan(uv-pos, target)));\n  uv -= pos;\n  uv /= times;\n\n  vec4 textLogo = segaLogo(uv) + text(uv);\n  float sf = float(!any(greaterThan(textLogo.xyz, vec3(0.0))));\n  vec4 combined = textLogo + sf * starfield(uv) + floorScroll(uv);\n  combined.a = 1.0;\n\n  vec4 border = vec4(0.05, 0.05, 0.05, 1.0);\n  fragColor = bounds * combined + (1.0 - bounds) * border;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// the \"please turn power off and insert game\" message\n// and copyright text\n// message consists of two bitmaps, one 166x16, another 116x16\n// copyright is a 158x8 bitmap because i'm a lazy fuck\n\nconst int img_text2[166] = int[](\n  0x000010,\n  0x000020,\n  0x000060,\n  0x002000,\n  0x002000,\n  0x001000,\n  0x000800,\n  0x000600,\n  0x000188,\n  0x000078,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000008,\n  0x000010,\n  0x002010,\n  0x002010,\n  0x001010,\n  0x000810,\n  0x000408,\n  0x000308,\n  0x0000c8,\n  0x000038,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000002,\n  0x007ffc,\n  0x000040,\n  0x000040,\n  0x000080,\n  0x000100,\n  0x000000,\n  0x000000,\n  0x000200,\n  0x000108,\n  0x0000c8,\n  0x0030a8,\n  0x004898,\n  0x00444c,\n  0x00424a,\n  0x004f88,\n  0x004104,\n  0x004104,\n  0x004100,\n  0x000080,\n  0x0000c0,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x008000,\n  0x004000,\n  0x002000,\n  0x001002,\n  0x000802,\n  0x000602,\n  0x000182,\n  0x00007e,\n  0x000180,\n  0x000600,\n  0x000800,\n  0x001000,\n  0x002000,\n  0x004000,\n  0x008000,\n  0x000000,\n  0x001820,\n  0x000620,\n  0x0021a2,\n  0x007ffe,\n  0x000090,\n  0x000040,\n  0x000020,\n  0x000010,\n  0x000008,\n  0x000008,\n  0x000008,\n  0x001ff0,\n  0x002000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000008,\n  0x000010,\n  0x000010,\n  0x000010,\n  0x000008,\n  0x000f08,\n  0x0010c8,\n  0x002024,\n  0x002014,\n  0x00200c,\n  0x00200c,\n  0x002004,\n  0x000004,\n  0x000004,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x0001c0,\n  0x000220,\n  0x000410,\n  0x000808,\n  0x003005,\n  0x00c002,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x006020,\n  0x001820,\n  0x000720,\n  0x0000e2,\n  0x00001e,\n  0x000010,\n  0x001c10,\n  0x002040,\n  0x002020,\n  0x0020a0,\n  0x002062,\n  0x002024,\n  0x002001,\n  0x000002,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000010,\n  0x001c20,\n  0x002220,\n  0x004220,\n  0x004222,\n  0x00423e,\n  0x004220,\n  0x0042d0,\n  0x004310,\n  0x000608,\n  0x000008,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000788,\n  0x003870,\n  0x006000,\n  0x005800,\n  0x000600,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000020,\n  0x000020,\n  0x0000c0,\n  0x000700,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x003000,\n  0x004800,\n  0x004800,\n  0x003000\n);\n\nconst int img_text1[116] = int[](\n  0x000078,\n  0x00000a,\n  0x003eaa,\n  0x002aaa,\n  0x002aaa,\n  0x002aaa,\n  0x002a0a,\n  0x007efe,\n  0x00aa0a,\n  0x00aaaa,\n  0x00aaaa,\n  0x00aaaa,\n  0x00beaa,\n  0x00800a,\n  0x006078,\n  0x000000,\n  0x008010,\n  0x006021,\n  0x001842,\n  0x000604,\n  0x006000,\n  0x001ffe,\n  0x004002,\n  0x0037f2,\n  0x000492,\n  0x00849a,\n  0x00fc96,\n  0x000492,\n  0x000492,\n  0x0017f2,\n  0x006002,\n  0x000000,\n  0x000200,\n  0x000108,\n  0x0000c8,\n  0x0030a8,\n  0x004898,\n  0x00444d,\n  0x00424a,\n  0x004f88,\n  0x004104,\n  0x004104,\n  0x004100,\n  0x000080,\n  0x0000c0,\n  0x000000,\n  0x000000,\n  0x001ff0,\n  0x002008,\n  0x004004,\n  0x004004,\n  0x004004,\n  0x002008,\n  0x001ff0,\n  0x000000,\n  0x000000,\n  0x004004,\n  0x007ffc,\n  0x004104,\n  0x000104,\n  0x000104,\n  0x000384,\n  0x00000c,\n  0x000000,\n  0x004004,\n  0x007ffc,\n  0x004104,\n  0x000104,\n  0x000104,\n  0x000384,\n  0x00000c,\n  0x000000,\n  0x001f84,\n  0x007078,\n  0x000c00,\n  0x000000,\n  0x000000,\n  0x000e08,\n  0x001010,\n  0x002010,\n  0x002008,\n  0x002008,\n  0x002008,\n  0x002008,\n  0x002000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000001,\n  0x001ffe,\n  0x002002,\n  0x004000,\n  0x004000,\n  0x004000,\n  0x002000,\n  0x002000,\n  0x001000,\n  0x000800,\n  0x000600,\n  0x000008,\n  0x000010,\n  0x000010,\n  0x000010,\n  0x000008,\n  0x000f08,\n  0x0010c8,\n  0x002024,\n  0x002014,\n  0x00200c,\n  0x00200c,\n  0x002004,\n  0x000004,\n  0x000004,\n  0x000000,\n  0x00b000,\n  0x007000\n);\n\nconst int img_copyright[158] = int[](\n  0x00003c,\n  0x000042,\n  0x000099,\n  0x0000a5,\n  0x0000a5,\n  0x000081,\n  0x000042,\n  0x00003c,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x0000ce,\n  0x0000df,\n  0x0000db,\n  0x0000db,\n  0x0000db,\n  0x0000fb,\n  0x000073,\n  0x000000,\n  0x0000ff,\n  0x0000ff,\n  0x0000db,\n  0x0000db,\n  0x0000db,\n  0x0000db,\n  0x0000c3,\n  0x000000,\n  0x00007e,\n  0x0000ff,\n  0x0000c3,\n  0x0000db,\n  0x0000db,\n  0x0000fb,\n  0x0000fb,\n  0x000000,\n  0x0000fc,\n  0x0000fe,\n  0x000037,\n  0x000033,\n  0x000037,\n  0x0000fe,\n  0x0000fc,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000041,\n  0x00007f,\n  0x00007f,\n  0x00007f,\n  0x000040,\n  0x000000,\n  0x000000,\n  0x00000e,\n  0x00005f,\n  0x000051,\n  0x000051,\n  0x00007f,\n  0x00007f,\n  0x00003e,\n  0x000000,\n  0x000036,\n  0x00007f,\n  0x000049,\n  0x000049,\n  0x00007f,\n  0x00007f,\n  0x000036,\n  0x000000,\n  0x000007,\n  0x000007,\n  0x000001,\n  0x000079,\n  0x00007d,\n  0x00000f,\n  0x000007,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x00000f,\n  0x00001f,\n  0x000030,\n  0x000060,\n  0x000030,\n  0x00001f,\n  0x00000f,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000046,\n  0x000067,\n  0x000061,\n  0x000051,\n  0x00005f,\n  0x00005f,\n  0x00004e,\n  0x000000,\n  0x000000,\n  0x000060,\n  0x000060,\n  0x000000,\n  0x000041,\n  0x00007f,\n  0x00007f,\n  0x00007f,\n  0x000040\n);\n\nfloat bitget(int n, int b) {\n  return float((n >> b) & 1);      \n}\n\nfloat text1(in vec2 uv) {\n  const vec2 size = vec2(116.0, 16.0);\n  int bit = int(uv.y * size.y);\n  int xx = int(uv.x * size.x);\n  float pixels = 0.0;\n  if (bit >= 0 && bit <= 25 && xx >= 0 && xx < 116)\n    pixels = bitget(img_text1[xx], bit);\n  return pixels;\n}\n\nfloat text2(in vec2 uv) {\n  const vec2 size = vec2(166.0, 16.0);\n  int bit = int(ceil(uv.y * size.y));\n  int xx = int(ceil(uv.x * size.x));\n  float pixels = 0.0;\n  if (bit >= 0 && bit <= 25 && xx >= 0 && xx < 166)\n  \tpixels = bitget(img_text2[xx], bit);\n  return pixels;\n}\n\nfloat text3(in vec2 uv) {\n  const vec2 size = vec2(158.0, 8.0);\n  int bit = int(ceil(uv.y * size.y));\n  int xx = int(ceil(uv.x * size.x));\n  float pixels = 0.0;\n  if (bit >= 0 && bit <= 25 && xx >= 0 && xx < 158)\n  \tpixels = bitget(img_copyright[xx], bit);\n  return pixels;\n}\n\nvec4 text(in vec2 uv) {\n  vec2 size = vec2(197, 56);\n  vec2 size1 = vec2(116, 16);\n  vec2 size2 = vec2(166, 16);\n  vec2 size3 = vec2(158, 8);\n  vec2 uv1 = uv * size;\n  vec2 uv2 = uv1 - vec2(4, 24);\n  vec2 uv3 = uv1 - vec2(39, 48);\n  float c = text1(uv1 / size1) + text2(uv2 / size2);\n  float b = text3(uv3 / size3);\n  return vec4(c*0.7803, c*0.7686, c*0.7803 + b*0.7803, 1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  fragColor = text(uv);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// SEGA and Master System logos\n// pixels of these have 3 possible colors: white, blue and none\n// encoded using the same method, but with two bitplanes\n\nconst int img_sega_bp1[80] = int[](\n  0x1ff0fe0,\n  0x1113838,\n  0x111600c,\n  0x1114006,\n  0x1118382,\n  0x1118c63,\n  0x1110821,\n  0x1111011,\n  0x1111111,\n  0x1111111,\n  0x1111111,\n  0x1101111,\n  0x1082111,\n  0x08c6311,\n  0x0838311,\n  0x0c00711,\n  0x0600f11,\n  0x0383f11,\n  0x01fffff,\n  0x0380038,\n  0x060000c,\n  0x0c00006,\n  0x083ff82,\n  0x18c1063,\n  0x1081021,\n  0x1101011,\n  0x1111111,\n  0x1111111,\n  0x1111111,\n  0x1111111,\n  0x1111111,\n  0x1111111,\n  0x1111111,\n  0x1111111,\n  0x1111111,\n  0x111ff11,\n  0x1ffffff,\n  0x0380038,\n  0x060000c,\n  0x0c00006,\n  0x083ff82,\n  0x18c0063,\n  0x1080021,\n  0x1100011,\n  0x111ff11,\n  0x1111111,\n  0x1111111,\n  0x1101111,\n  0x1101111,\n  0x1101111,\n  0x11ff111,\n  0x1000111,\n  0x1000111,\n  0x1000111,\n  0x10fffff,\n  0x103c000,\n  0x1007800,\n  0x1e00f00,\n  0x1fc01e0,\n  0x1138038,\n  0x110700e,\n  0x1100e02,\n  0x11001c3,\n  0x1118031,\n  0x111f011,\n  0x1118031,\n  0x11001c3,\n  0x1100e02,\n  0x110700e,\n  0x113803e,\n  0x11c01fc,\n  0x1000f86,\n  0x100797a,\n  0x107c285,\n  0x1fc02d5,\n  0x00002d5,\n  0x00002ad,\n  0x000017a,\n  0x0000186,\n  0x0000078\n);\n\nconst int img_sega_bp2[80] = int[](\n  0x0000000,\n  0x0ee07c0,\n  0x0ee1ff0,\n  0x0ee3ff8,\n  0x0ee7c7c,\n  0x0ee739c,\n  0x0eef7de,\n  0x0eeefee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0efeeee,\n  0x0f7deee,\n  0x0739cee,\n  0x07c7cee,\n  0x03ff8ee,\n  0x01ff0ee,\n  0x007c0ee,\n  0x0000000,\n  0x007ffc0,\n  0x01ffff0,\n  0x03ffff8,\n  0x07c007c,\n  0x073ef9c,\n  0x0f7efde,\n  0x0efefee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0ee00ee,\n  0x0000000,\n  0x007ffc0,\n  0x01ffff0,\n  0x03ffff8,\n  0x07c007c,\n  0x073ff9c,\n  0x0f7ffde,\n  0x0efffee,\n  0x0ee00ee,\n  0x0eeeeee,\n  0x0eeeeee,\n  0x0efeeee,\n  0x0efeeee,\n  0x0efeeee,\n  0x0e00eee,\n  0x0fffeee,\n  0x0fffeee,\n  0x0fffeee,\n  0x0f00000,\n  0x0fc0000,\n  0x0ff8000,\n  0x01ff000,\n  0x003fe00,\n  0x0ec7fc0,\n  0x0ef8ff0,\n  0x0eff1fc,\n  0x0effe3c,\n  0x0ee7fce,\n  0x0ee0fee,\n  0x0ee7fce,\n  0x0effe3c,\n  0x0eff1fc,\n  0x0ef8ff0,\n  0x0ec7fc0,\n  0x0e3fe00,\n  0x0fff078,\n  0x0ff8084,\n  0x0f8017a,\n  0x000012a,\n  0x000012a,\n  0x0000152,\n  0x0000084,\n  0x0000078,\n  0x0000000\n);\n\nconst int img_ms_bp1[179] = int[](\n  0x000000,\n  0x020001,\n  0x03ffff,\n  0x03ffff,\n  0x02007f,\n  0x0007ff,\n  0x007fe0,\n  0x03fe00,\n  0x03f000,\n  0x007e00,\n  0x0007e0,\n  0x02007f,\n  0x03ffff,\n  0x03ffff,\n  0x03ffff,\n  0x020001,\n  0x000000,\n  0x000000,\n  0x020000,\n  0x03c000,\n  0x03fc00,\n  0x023fc0,\n  0x001bf8,\n  0x00187f,\n  0x00180f,\n  0x00187f,\n  0x001bff,\n  0x023ff8,\n  0x03ffc0,\n  0x03fe00,\n  0x03e000,\n  0x020000,\n  0x000000,\n  0x000000,\n  0x0070f0,\n  0x03c1fc,\n  0x0103fe,\n  0x0103c6,\n  0x030783,\n  0x030783,\n  0x030783,\n  0x038f02,\n  0x01ff06,\n  0x00fe0f,\n  0x00783c,\n  0x000000,\n  0x000018,\n  0x00000e,\n  0x000007,\n  0x000007,\n  0x020003,\n  0x03ffff,\n  0x03ffff,\n  0x03ffff,\n  0x020003,\n  0x000007,\n  0x000007,\n  0x00000e,\n  0x000018,\n  0x000000,\n  0x000000,\n  0x020001,\n  0x03ffff,\n  0x03ffff,\n  0x03ffff,\n  0x030303,\n  0x030303,\n  0x030303,\n  0x030303,\n  0x030303,\n  0x038fc7,\n  0x03c00f,\n  0x00e01c,\n  0x002000,\n  0x000000,\n  0x020001,\n  0x03ffff,\n  0x03ffff,\n  0x03ffff,\n  0x020603,\n  0x000603,\n  0x000603,\n  0x001f07,\n  0x007f07,\n  0x01f7fe,\n  0x03e3fc,\n  0x038070,\n  0x020000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x0070f0,\n  0x03c1fc,\n  0x0103fe,\n  0x0103c6,\n  0x030783,\n  0x030783,\n  0x030783,\n  0x038f02,\n  0x01ff06,\n  0x00fe0f,\n  0x00783c,\n  0x000000,\n  0x000001,\n  0x000003,\n  0x00000f,\n  0x02003f,\n  0x0200fd,\n  0x03fff0,\n  0x03ffc0,\n  0x03ffc0,\n  0x0200f0,\n  0x02003d,\n  0x00000f,\n  0x000003,\n  0x000001,\n  0x0070f0,\n  0x03c1fc,\n  0x0103fe,\n  0x0103c6,\n  0x030783,\n  0x030783,\n  0x030783,\n  0x038f02,\n  0x01ff06,\n  0x00fe0f,\n  0x00783c,\n  0x000000,\n  0x000018,\n  0x00000e,\n  0x000007,\n  0x000007,\n  0x020003,\n  0x03ffff,\n  0x03ffff,\n  0x03ffff,\n  0x020003,\n  0x000007,\n  0x000007,\n  0x00000e,\n  0x000018,\n  0x000000,\n  0x000000,\n  0x020001,\n  0x03ffff,\n  0x03ffff,\n  0x03ffff,\n  0x030303,\n  0x030303,\n  0x030303,\n  0x030303,\n  0x030303,\n  0x038fc7,\n  0x03c00f,\n  0x00e01c,\n  0x002000,\n  0x000000,\n  0x020001,\n  0x03ffff,\n  0x03ffff,\n  0x02007f,\n  0x0007ff,\n  0x007fe0,\n  0x03fe00,\n  0x03f000,\n  0x007e00,\n  0x0007e0,\n  0x02007f,\n  0x03ffff,\n  0x03ffff,\n  0x03ffff,\n  0x020001,\n  0x000000\n);\n\nconst int img_ms_bp2[179] = int[](\n  0x020001,\n  0x010002,\n  0x000000,\n  0x000000,\n  0x010080,\n  0x020800,\n  0x008010,\n  0x000100,\n  0x000800,\n  0x008100,\n  0x020810,\n  0x010080,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x010002,\n  0x020001,\n  0x020000,\n  0x010000,\n  0x002000,\n  0x000200,\n  0x014020,\n  0x020404,\n  0x000080,\n  0x000010,\n  0x000080,\n  0x020400,\n  0x014004,\n  0x000020,\n  0x000100,\n  0x001000,\n  0x010000,\n  0x020000,\n  0x000000,\n  0x008008,\n  0x003002,\n  0x00c000,\n  0x020039,\n  0x000044,\n  0x000000,\n  0x008800,\n  0x007005,\n  0x020008,\n  0x010010,\n  0x008402,\n  0x000000,\n  0x000004,\n  0x000011,\n  0x000008,\n  0x020000,\n  0x010004,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x010004,\n  0x020000,\n  0x000008,\n  0x000011,\n  0x000004,\n  0x000000,\n  0x020001,\n  0x010002,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000484,\n  0x000008,\n  0x000010,\n  0x010002,\n  0x004000,\n  0x020001,\n  0x010002,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x010000,\n  0x020000,\n  0x001904,\n  0x002000,\n  0x0080d8,\n  0x020801,\n  0x001402,\n  0x004088,\n  0x010000,\n  0x020000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x008008,\n  0x003002,\n  0x00c000,\n  0x020039,\n  0x000044,\n  0x000000,\n  0x008800,\n  0x007005,\n  0x020008,\n  0x010010,\n  0x008402,\n  0x000000,\n  0x000002,\n  0x000004,\n  0x000010,\n  0x000040,\n  0x010102,\n  0x000008,\n  0x000020,\n  0x000020,\n  0x010109,\n  0x000042,\n  0x000010,\n  0x000004,\n  0x000002,\n  0x008009,\n  0x003002,\n  0x00c000,\n  0x020039,\n  0x000044,\n  0x000000,\n  0x008800,\n  0x007005,\n  0x020008,\n  0x010010,\n  0x008402,\n  0x000000,\n  0x000004,\n  0x000011,\n  0x000008,\n  0x020000,\n  0x010004,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x010004,\n  0x020000,\n  0x000008,\n  0x000011,\n  0x000004,\n  0x000000,\n  0x020001,\n  0x010002,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x000484,\n  0x000008,\n  0x000010,\n  0x010002,\n  0x004000,\n  0x020001,\n  0x010002,\n  0x000000,\n  0x000000,\n  0x010080,\n  0x020800,\n  0x008010,\n  0x000100,\n  0x000800,\n  0x008100,\n  0x020810,\n  0x010080,\n  0x000000,\n  0x000000,\n  0x000000,\n  0x010002,\n  0x020001\n);\n\nfloat bitget(int n, int b) {\n  return float((n >> b) & 1);      \n}\n\nvec4 sega(in vec2 uv) {\n  const vec2 size = vec2(80.0, 25.0);\n  int bit = int(uv.y * size.y);\n  int xx = int(ceil(uv.x * size.x));\n  float white = 0.0, blue = 0.0;\n  if (bit >= 0 && bit <= 25 && xx >= 0 && xx < 80) {\n    white = bitget(img_sega_bp1[xx], bit);\n    blue = bitget(img_sega_bp2[xx], bit)*0.7803;\n  }\n  return vec4(white*0.7803, white*0.7686, white*0.7803 + blue*0.7803, 1.0);\n}\n\nvec4 mastersystem(in vec2 uv) {\n  const vec2 size = vec2(179.0, 18.0);\n  int bit = int(ceil(uv.y * size.y));\n  int xx = int(uv.x * size.x);\n  float white = 0.0, blue = 0.0;\n  if (bit >= 0 && bit <= 25 && xx >= 0 && xx < 179) {\n    white = bitget(img_ms_bp1[xx], bit);\n    blue = bitget(img_ms_bp2[xx], bit)*0.7803;\n  }\n  return vec4(white*0.7803, white*0.7686 + blue*0.2549, white*0.7803 + blue*0.7803, 1.0);\n}\n\nvec4 logo(in vec2 uv) {\n  vec2 size = vec2(179, 50);\n  vec2 size1 = vec2(80, 25);\n  vec2 size2 = vec2(179, 18);\n  vec2 uv0 = uv * size;\n  vec2 uv1 = uv0 - vec2(48, 0);\n  vec2 uv2 = uv0 - vec2(0, 33);\n  vec4 c = sega(uv1 / size1) + mastersystem(uv2 / size2);\n  c.w = 1.0;\n  return c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  fragColor = logo(uv);\n}\n","name":"Buf B","description":"","type":"buffer"}]}