{"ver":"0.1","info":{"id":"Mf3GzB","date":"1711822951","viewed":56,"name":"Raymarching space repetition","username":"jarvarvarvis","description":"Raymarching test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"MfX3WH","parentname":"kishimisu's raymarching starter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Scene\nfloat toruses(vec3 p) {\n    // Rotate point around z axis based on time\n    p.xy *= rot2D(fract(iTime * 0.09) * 3.141);\n\n    // Space repetition\n    p = opRepetition(p, vec3(1.0, 1.0, 0.25));\n    \n    // Torus rotation\n    p.xy *= rot2D(iTime * 1.5);\n    p.yz *= rot2D(iTime * 1.5);\n    \n    // Torus\n    float torus = sdTorus(p, vec2(0.1, 0.06));\n    \n    return torus;\n}\n\nfloat scene(vec3 p, float t) {\n    // Create copy of point\n    // Apply rotation on z axis, wiggle vertically and move forward\n    vec3 torusesP = p.xyz;\n    torusesP.xy *= rot2D(t * 0.1);\n    torusesP.y += sin(t * 0.5) * 0.75;\n    torusesP.z = mod(torusesP.z + iTime * 1.0, 1.0);\n\n    // Pass that point to the toruses function\n    float torusesDist = toruses(torusesP);\n    \n    // Calculate result\n    float result = torusesDist;\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2  m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    vec3 ro = vec3(0, 0, -1);         // ray origin\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    vec3 col = vec3(0);               // final pixel color\n\n    // Camera rotation\n    float camHAngle = 0.3; // -m.x;\n    float camVAngle = 0.0; // -m.y;\n\n    // Rotate camera around origin\n    mat2 horizontalRotation = rot2D(camHAngle);\n    mat2 verticalRotation   = rot2D(camVAngle);\n    \n    // Apply to ray\n    ro.xz *= horizontalRotation; rd.xz *= horizontalRotation;\n    ro.yz *= verticalRotation;   rd.yz *= verticalRotation;\n    \n    // Distance\n    const float MAX_DIST = 100.;\n    float t = 0.;\n\n    // Raymarching\n    int i;\n    for (i = 0; i < 80; i++) {\n        // Position along the ray\n        vec3 p = ro + rd * t;\n        \n        // Current distance to the scene\n        float d = scene(p, t);\n\n        // \"March\" the ray\n        t += d;\n\n        // Early stop if close enough or too far\n        if (d < .001 || t > MAX_DIST) break;\n    }\n    \n    // Coloring\n    if (t <= MAX_DIST) {\n        float iterationValue = float(i) / 80.0;\n        \n        float maxDistDiv = 3.0;\n        float distValue = t * (maxDistDiv / MAX_DIST) * 0.75;\n        \n        // Mix iteration and distance values to achieve more detail on each torus while\n        // preserving the variation in palette colors\n        float value = mix(iterationValue, distValue, 0.8);\n        \n        col = palette( value, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    } else {\n        col = vec3(0);\n    }\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// 2D rotation matrix\nmat2 rot2D(float a) {\n    return mat2(\n        cos(a), -sin(a), \n        sin(a), cos(a)\n    );\n}\n\n\n// SDF functions\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n\n// Operators\nvec3 opRepetition(vec3 p, vec3 s) {\n    vec3 q = p - s*round(p/s);\n    return q;\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n\n// Color palette\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n","name":"Common","description":"","type":"common"}]}