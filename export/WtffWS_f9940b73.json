{"ver":"0.1","info":{"id":"WtffWS","date":"1597536869","viewed":95,"name":"Aquatic colors","username":"Lay","description":"Hi there!\n\nThis is the first shader I share\nAnd it is very simple :)\nHope, all designations are correct\n\nHave a nice day!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat2 m = mat2( 0.60,  0.80, -0.80,  0.60 ); // everybody use this matrix\n\nfloat noise(vec2 p)\n{\n    float a = fract(100.*sin(220.*p.x+34.24)*sin(520.*p.y+2.68));\n    \n    return a;\n}\n\nvec2 random_direction(vec2 p)\n{\n    float f = noise(p);\n    return vec2(cos(6.283185307*f), sin(6.283185307*f));\n}\n\nfloat smoothing(float a, float b, float t)\n{\n    t = t * t * t * (t * (t * 6. - 15.) + 10.);\n    return a + (b-a)*t;\n}\n\nfloat perlin(vec2 p, float N)\n{\n    p *= N;\n    vec2 r = floor(p);\n    vec2 q = fract(p);\n    \n    float n00 = dot(q-vec2(0.,0.),random_direction(r+vec2(0.,0.)));\n    float n10 = dot(q-vec2(1.,0.),random_direction(r+vec2(1.,0.)));\n    float n01 = dot(q-vec2(0.,1.),random_direction(r+vec2(0.,1.)));\n    float n11 = dot(q-vec2(1.,1.),random_direction(r+vec2(1.,1.)));\n    \n    return .5*(1.+smoothing(smoothing(n00, n10, q.x),smoothing(n01, n11, q.x), q.y));\n}\n\nfloat perlin_octaves(vec2 p)\n{\n    float N = 7.;// + .5*sin(0.0003*iTime);\n    int oct = 4;\n    \n    float ns = perlin(p, N);\n    float A = 1.;\n    float MAX = 1.;\n    for (int i = 0; i < oct; ++i) {\n        N *= 2.;\n        A *= .5;\n        ns += A*perlin(p, N);\n        MAX += A;\n    }\n    return ns / MAX;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x + vec2(0.02,0.05)*iTime + vec2(-0.05*sin(0.4*iTime), -0.03*sin(0.3*iTime));\n\n    vec2 p = uv;\n    float per0 = perlin_octaves(p);\n    float per1 = perlin_octaves(m*p + vec2(1., 3.));\n    float per2 = perlin_octaves(m*m*p + vec2(2., 2.));\n    float per3 = perlin_octaves(m*m*m*p + vec2(1., 1.));\n    \n    float super_perlin0 = perlin_octaves(m*(vec2(per0, per1) + 0.5*(per1*sin(.07*iTime)+per3*cos(.07*iTime))));\n    float super_perlin1 = perlin_octaves(m*m*vec2(per2, per3));// + 0.7*sin(0.2*iTime)*(per2+per3));\n    \n    float mega_perin = perlin_octaves(m*m*m*vec2(super_perlin0, super_perlin1));\n    \n    vec3 col = vec3(mega_perin, mega_perin, mega_perin);\n    \n    col *= per1*vec3(.4, .8, .3) + per3*vec3(.5, .25, .8) + per2*vec3(.0, .02, .0);\n    col *= 1.7;\n    \n    // to calibrate noise\n    float ns = .5+.5*noise(uv);\n    //col = vec3(ns, ns, ns);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}