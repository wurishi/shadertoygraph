{"ver":"0.1","info":{"id":"NdtfWr","date":"1656358785","viewed":86,"name":"Real-world Sun position","username":"Koulatko","description":"Settings at the top of Image\nFloat roundoff might be messing it up a little","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["sun","astronomy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//position to calculate at (degrees, positive=east/north)\n#define LAT 00.\n#define LON 00.\n\n//browser timezone (compensate iDate being in local time)\n//example EST = -5.0\n#define TIMEZONE 0.\n\n//for comparison with photos of sticks and magnetic compasses\n#define MAGNETIC_DECLINATION 0.\n\n//if you change line 40 to depend on t, you can make the sun go really fast, motion blur can make that clearer\n#define BLUR_STEPS 1\n\n//months in date vec4s are off by 1! January = 0.0, February = 1.0 ...\n\n//refraction not modeled\n\n//when the sun is below the horizon, a blue light source pointing at it is used\n\n\n\nmat3 equatorial_horizontal(float theta, float longitude, float latitude){ //pain\n    //http://www2.arnes.si/~gljsentvid10/sfera/chapter7.htm\n    //converted to 3x3 matrix by trial and error\n    \n    float HA = longitude+theta;\n    return mat3(\n    sin(latitude), 0.,-cos(latitude),\n    0.,1.,0.,\n    cos(latitude), 0., sin(latitude)\n    )*mat3(\n    -cos(HA),sin(HA),0.,\n    -sin(HA),-cos(HA),0.,\n    0.,0.,1.\n    );\n}\nvec3 sun_function(float t){\n    //https://en.wikipedia.org/wiki/Position_of_the_Sun#Approximate_position\n    float n = get_J2000_days(iDate, TIMEZONE);  \n    \n    float L = 280.460 + 0.9856474*n;\n    float g = 357.528 + 0.9856003*n;\n    L *= DEG;\n    g *= DEG;\n    float lambda = L + DEG*(1.915*sin(g)+0.02*sin(2.*g));\n    \n    \n    \n    \n    float eps = DEG*(23.439 - 0.0000004*n);\n    \n    \n    vec3 sun=vec3(cos(lambda),\n                  cos(eps)*sin(lambda),\n                  sin(eps)*sin(lambda));\n    \n    \n    \n    \n    \n    \n    //https://en.wikipedia.org/wiki/Sidereal_time\n    float theta = 2.*PI*(0.779057273264+1.00273781191135448*n);\n    \n    float longitude = LON*DEG;\n    float latitude = LAT*DEG;\n    \n    return equatorial_horizontal(theta,longitude,latitude)*sun;\n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nbool hit_compare(vec4 a, vec4 b){\n    return b.w > 0.0 && (b.w < a.w || !(a.w > 0.0));\n}\n\n\nvec3 ground_texture(vec2 uv){\n    uv *= 0.5;\n    float decl = MAGNETIC_DECLINATION*DEG;\n    \n    uv = mat2(cos(decl),sin(decl),-sin(decl),cos(decl))*uv;\n    \n    uv = vec2(-uv.y,uv.x);\n    \n    vec3 col = vec3(0.7);\n\n    vec2 N_rel = 4.*(uv-vec2(-0.125,1.));\n    uv = mat2(0.,1.,-1.,0.)*uv;\n    vec2 E_rel = 4.*(uv-vec2(-0.125,1.));\n    uv = mat2(0.,1.,-1.,0.)*uv;\n    vec2 S_rel = 4.*(uv-vec2(-0.125,1.));\n    uv = mat2(0.,1.,-1.,0.)*uv;\n    vec2 W_rel = 4.*(uv-vec2(-0.125,1.));\n    uv = mat2(0.,1.,-1.,0.)*uv;\n    \n    if(abs(N_rel.x-0.5)<0.5 && abs(N_rel.y-0.5)<0.5){\n        col = vec3(1.);\n        if(pil(N_rel,vec2(0.2,0.15),vec2(0.2,0.85), 0.08)) col = vec3(0.);\n        if(pil(N_rel,vec2(0.8,0.15),vec2(0.8,0.85), 0.08)) col = vec3(0.);\n        if(pil(N_rel,vec2(0.8,0.15),vec2(0.2,0.85), 0.08)) col = vec3(0.);\n    }\n    if(abs(S_rel.x-0.5)<0.5 && abs(S_rel.y-0.5)<0.5){\n        col = vec3(1.);\n        if(pil(S_rel,vec2(0.3,0.15),vec2(0.7,0.15), 0.08)) col = vec3(0.);\n        if(pil(S_rel,vec2(0.3,0.50),vec2(0.7,0.50), 0.08)) col = vec3(0.);\n        if(pil(S_rel,vec2(0.3,0.85),vec2(0.7,0.85), 0.08)) col = vec3(0.);\n        if(pil(S_rel,vec2(0.7,0.15),vec2(0.7,0.50), 0.08)) col = vec3(0.);\n        if(pil(S_rel,vec2(0.3,0.50),vec2(0.3,0.85), 0.08)) col = vec3(0.);\n    }\n    if(abs(E_rel.x-0.5)<0.5 && abs(E_rel.y-0.5)<0.5){\n        col = vec3(1.);\n        if(pil(E_rel,vec2(0.25,0.15),vec2(0.25,0.85), 0.08)) col = vec3(0.);\n        if(pil(E_rel,vec2(0.25,0.15),vec2(0.75,0.15), 0.08)) col = vec3(0.);\n        if(pil(E_rel,vec2(0.25,0.50),vec2(0.75,0.50), 0.08)) col = vec3(0.);\n        if(pil(E_rel,vec2(0.25,0.85),vec2(0.75,0.85), 0.08)) col = vec3(0.);\n    }\n    if(abs(W_rel.x-0.5)<0.5 && abs(W_rel.y-0.5)<0.5){\n        col = vec3(1.);\n        if(pil(W_rel,vec2(0.15,0.80),vec2(0.30,0.15), 0.08)) col = vec3(0.);\n        if(pil(W_rel,vec2(0.30,0.15),vec2(0.50,0.50), 0.08)) col = vec3(0.);\n        if(pil(W_rel,vec2(0.50,0.50),vec2(0.70,0.15), 0.08)) col = vec3(0.);\n        if(pil(W_rel,vec2(0.70,0.15),vec2(0.85,0.80), 0.08)) col = vec3(0.);\n    }\n    \n    if(abs(uv.y) < 0.05 && abs(uv.x) < 0.9) col = vec3(0.4);\n    if(abs(uv.x) < 0.05 && abs(uv.y) < 0.9) col = vec3(0.4);\n    \n    return col;\n}\n\nvec4 ray_scene(vec3 ro, vec3 rd, out int o_id){\n    vec4 h;\n    vec4 h1;\n    \n    h1 = ray_plane(ro, rd, vec4(0.,0.,1.,0.));\n    if(hit_compare(h,h1)){\n        h = h1;\n        o_id = 1;\n    }\n    \n    h1 = ray_cylinder(ro, rd, vec3(0.,0.,0.), vec3(0.,0.,1.), 0.2);\n    if(hit_compare(h,h1)){\n        h = h1;\n        o_id = 2;\n    }\n    \n    return h;\n}\n\n\n\n\n\n\n\n\nvec3 img(in vec2 fragCoord, float T){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec2 fr = uv;\n    fr.y *= iResolution.y/iResolution.x;\n    fr.x = 1.-fr.x;\n    fr *= 4.;\n    fr.x = 1.-fr.x;\n    \n    if(abs(fr.x-0.5) < 0.5 && abs(fr.y-0.5) < 0.5){\n        vec3 col = vec3(0.);\n\n        vec2 p = fr*2.-1.;\n\n        vec3 rd = vec3(normalize(mat2(0.,1.,-1.,0.)*p), 1.);\n        float tmpf = length(p);\n        rd.xy *= sin(tmpf*PI);\n        rd.z *= -cos(tmpf*PI);\n        rd.yz *= -1.;\n\n        if(tmpf > 1.){\n            return vec3(0.1);\n        }\n\n        col += vec3(0.2,0.3,0.4);\n        if(dot(sun_function(T),rd) > 0.99) col = vec3(0.7);\n\n        if(rd.z < 0.) col -= 0.2;\n\n        return col;\n    }\n    \n\n    vec2 ss = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = texelFetch(iChannel3, ivec2(0,0), 0).xyz;\n    \n    vec4 camera_angle_texel = texelFetch(iChannel3, ivec2(1,0), 0);\n    float pitch = camera_angle_texel.y;\n    float yaw = camera_angle_texel.x;\n    \n    vec3 right = vec3(sin(yaw), -cos(yaw), 0.0);\n    vec3 up = vec3(-cos(yaw)*sin(pitch), -sin(yaw)*sin(pitch), cos(pitch));\n    vec3 forward = vec3(cos(yaw)*cos(pitch), sin(yaw)*cos(pitch), sin(pitch));\n\n    vec3 rd = normalize(vec3(ss.x,ss.y,-1.4));\n    //rd = camera_stereographic(ss);\n    rd = mat3(right,up,-forward)*rd;\n    \n    int o_id;\n    vec4 h = ray_scene(ro, rd, o_id);\n    \n    vec3 sun = sun_function(T);\n    //sun = normalize(vec3(1.,1.,1.));\n    \n    if(h.w > 0.){\n        vec3 N = h.xyz;\n        vec3 diffuse;\n        \n        vec3 illum = vec3(1.);\n        \n        if(sun.z < 0.){\n            sun *= -1.;\n            illum = vec3(0.2,0.2,1.0);\n        }\n        \n        if(o_id == 1) diffuse = ground_texture(ro.xy+h.w*rd.xy);\n        if(o_id == 2) diffuse = vec3(1.,0.,0.);\n        \n        int int_trash;\n        vec4 shadow_ray = ray_scene(ro+h.w*rd+0.0001*N, sun, int_trash);\n        \n        if(shadow_ray.w > 0.) illum = vec3(0.);\n        illum += vec3(0.1);\n        \n        return max(0.,dot(N,sun))*diffuse*illum;\n    }\n    float sun_dot = dot(rd,sun);\n    return vec3(1.,0.9,0.7)*vec3(1.7*pow(sun_dot,320.));\n}\n\nfloat degrees_azimuth(vec2 v){\n    float a = atan(-v.y,v.x);\n    if(a < 0.) a += 2.*PI;\n    return a*180./PI;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < BLUR_STEPS; i++){\n        col += pow(img(fragCoord, iTime+iTimeDelta*float(i)/float(BLUR_STEPS)), vec3(1.));\n    }\n    col /= float(BLUR_STEPS);\n    col = sqrt(col);\n    \n    vec3 S = sun_function(iTime);\n    \n    col += PrintValue(fragCoord, vec2(10.,15.), vec2(15.), degrees_azimuth(S.xy), 3., 3.);\n    col += PrintValue(fragCoord, vec2(10.,40.), vec2(15.), degrees(asin(S.z)), 3., 3.);\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979323\n#define DEG 0.01745329251994329576923690768488612713442871888541725456097191440171\n\n\n\n\nvec3 camera_stereographic(vec2 ss){\n    float stereo_denom = 1./(1.+dot(ss,ss));\n    vec3 rd = vec3(2.*ss.x, 2.*ss.y, -2.)*stereo_denom;\n    rd.z += 1.;\n    return rd;\n}\n\n\n\nvec4 ray_sphere(vec3 ro, vec3 rd, float r){\n    float b = -dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float d = b*b-c;\n    if(d < 0.0) return vec4(-1.0);\n    float h = sqrt(d);\n    float t = b < h ? b+h : b-h;\n    return vec4((ro+t*rd)/r, t);\n}\nvec4 ray_plane(vec3 ro, vec3 rd, vec4 p){\n    return vec4(p.xyz, -(dot(ro, p.xyz)-p.w)/dot(rd, p.xyz));\n}\n\n\n//https://iquilezles.org/articles/intersectors/\nvec4 ray_cylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( (oc+t*rd-ca*y/caca)/ra, t );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( ca*sign(y)/caca, t );\n    return vec4(-1.0); //no intersection\n}\n\n\n\n\nbool pil(vec2 p, vec2 a, vec2 b, float k){\n    \n    vec2 d = normalize(b-a);\n    \n    float t = dot(p-a,d)/length(b-a);\n    \n    t = max(0.,min(t,1.));\n    \n    float di = distance(p,a+t*(b-a));\n    \n    return di < k;\n}\n\n\n\n\n\n\n\n\nbool is_leap_year(int Y){\n    if((Y&3) > 0) return false;\n    if(Y%100>0) return true;\n    if(Y%400>0) return false;\n    return true;\n}\nint _datetime_interval_from_year_start(int month, int day, bool leap){\n    int summed_months[12] = int[](\n    0,31,59,90,120,151,181,212,243,273,304,334\n    );\n    int days = summed_months[month]+day;\n    if(!(month > 1 && leap)) days--;\n    return days;\n}\nint _datetime_interval_from_year_start(int year, int month, int day){\n    return _datetime_interval_from_year_start(month, day, is_leap_year(year));\n}\n\nint count_intervals(int a, int b, int interval){\n    return b/interval-(a-1)/interval;\n}\n\nint _datetime_interval_leap_years(int start, int end){\n    return count_intervals(start,end,4)-count_intervals(start,end,100)+count_intervals(start,end,400);\n}\n\nint date_interval(ivec4 start, ivec4 end){\n    int year_diff = end[0] - start[0];\n    \n    if(year_diff == 0){\n        int tmp2 = _datetime_interval_from_year_start(end[0],end[1],end[2]);\n        int tmp1 = _datetime_interval_from_year_start(start[0],start[1],start[2]);\n        return tmp2-tmp1;\n    }\n    \n    if(year_diff > 0){\n        bool start_year_leap = is_leap_year(start[0]);\n        int until_next_year = 365-_datetime_interval_from_year_start(start[1], start[2], start_year_leap);\n        if(start_year_leap) until_next_year++;\n        \n        int after_end_year = _datetime_interval_from_year_start(end[0], end[1], end[2]);\n        \n        int years_in_between = 0;\n        if(year_diff > 1){\n            years_in_between = 365*(year_diff-1)\n                              +_datetime_interval_leap_years(start[0]+1,end[0]-1);\n        }\n        \n        return until_next_year+after_end_year+years_in_between;\n    }\n    \n    return 0;\n}\n\n//offset because floats\nfloat datetime_interval_days(vec4 start, vec4 end, float offset){\n    int days = date_interval(ivec4(start), ivec4(end));\n    return float(days)+(offset+(end[3]-start[3])/86400.);\n}\n\nfloat get_J2000_days(vec4 date, float browser_timezone){\n    const vec4 epoch = vec4(2000.,0.,1.,43200.);\n    float UTC = datetime_interval_days(epoch, date, -browser_timezone/24.);\n    \n    return UTC;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 old_math(float time){\n    //ray,sun both relative to the ground\n    //earth coordinate system:\n    //origin : core\n    //    +X : 0E 0N\n    //    +Y : 90E 0N\n    //    +Z : north pole\n    \n    //observer coordinate system:\n    // X: east Y: north Z: up\n    \n    //stellar coordinate system:\n    //origin  : sun\n    //XY plane: ecliptic\n    //\n    //ray and sun variables are in this system\n    \n    vec3 sun = vec3(0.0);\n    \n    \n    \n    float time_factor = 1e6;\n    float axis_tilt = 23.*DEG;\n    float axis_speed = -1.0/86400.0; //negative-valued for real Earth\n    float axis_init = 0.0;\n    float orbit_speed = axis_speed/365.25; //10 day year so seasons are visible\n    float orbit_init = 0.;\n    \n    float earth_radius = 0.01;\n    float orbit_radius = 1.0;\n    \n    float axis = axis_init+axis_speed*time_factor*time;\n    float orbit = orbit_init+orbit_speed*time_factor*time;\n    \n    \n    \n    mat4 earth_to_stellar=\n    \n    mat4( //orbit\n    1.,0.,0.,0.,\n    0.,1.,0.,0.,\n    0.,0.,1.,0.,\n    orbit_radius*cos(orbit),orbit_radius*sin(orbit),0.,1.\n    )*\n    mat4( //tilt applied in ZX plane\n    cos(axis_tilt),0.,-sin(axis_tilt),0.,\n    0.,1.,0.,0.,\n    sin(axis_tilt),0.,cos(axis_tilt),0.,\n    0.,0.,0.,1.\n    )*\n    mat4( //axial spin (main component of day/night)\n    cos(axis),sin(axis),0.,0.,\n   -sin(axis),cos(axis),0.,0.,\n    0.,0.,1.,0.,\n    0.,0.,0.,1.\n    );\n    \n    \n    float latitude = 50.*DEG;\n    float longitude = 100.*DEG;\n    mat4 observer_to_earth= //similar to view matrix from euler angle calculation\n    mat4(\n   -sin(longitude),cos(longitude),0.,0.,\n    -cos(longitude)*sin(latitude),-sin(longitude)*sin(latitude),cos(latitude),0.,\n    cos(longitude)*cos(latitude),sin(longitude)*cos(latitude),sin(latitude),0.,\n    0.,0.,0.,1.\n    );\n    observer_to_earth[3].xyz = earth_radius*observer_to_earth[2].xyz;\n    \n    observer_to_earth = mat4(1.0);\n    \n    mat4 observer_to_stellar = earth_to_stellar*observer_to_earth;\n    vec3 observer_pos_stellar = (observer_to_stellar*vec4(0.,0.,0.,1.)).xyz;\n    \n    \n    //sun is at the origin of stellar coord. system, transform direction towards it back into observer system\n    return (inverse(observer_to_stellar)*vec4(-normalize(observer_pos_stellar),0.)).xyz;\n    \n}\n\n\n\n\n\n\n\n\n// Prints numbers\n\n// Original version: https://www.shadertoy.com/view/4sBSWW\n\n// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Note that the values printed are not always accurate!\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n// Original version\nfloat PrintValue00(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// Improved version\n//\n// Most important change is dropping everything left of the decimal point ASAP \n// when printing the fractional digits. This is done to bring the magnitule down\n// for the following division and modulo.\n//\n// Another change is to replace the logarithm with a power-of-ten value \n// calculation that is needed later anyway.\n// This change is optional, either one works.\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //W = 87\n    //S = 83\n    //D = 68\n    //A = 65\n    //space = 32\n    //shift = 16\n    \n    //0,0 = camera pos\n    //1,0 = camera_euler\n    \n    bool is_start = iFrame == 0;\n    \n    ivec2 fc = ivec2(fragCoord);\n    vec4 cv = texelFetch(iChannel0, fc, 0);\n    vec4 nv = cv;\n    if(fc == ivec2(0,0)){ //Camera motion\n    \n        if(is_start){ //Init\n            fragColor = vec4(-2.0, 0.0, 1., 0.0);\n            return;\n        }\n        \n        vec4 camera_angle_texel = texelFetch(iChannel0, ivec2(1,0), 0); //Geometry\n        float pitch = camera_angle_texel.y;\n        float yaw = camera_angle_texel.x;\n        \n        vec3 off;\n        \n        float W = texelFetch(iChannel1, ivec2(87, 0), 0).x;\n        float S = texelFetch(iChannel1, ivec2(83, 0), 0).x;\n        float A = texelFetch(iChannel1, ivec2(65, 0), 0).x;\n        float D = texelFetch(iChannel1, ivec2(68, 0), 0).x;\n        float space = texelFetch(iChannel1, ivec2(32, 0), 0).x;\n        float shift = texelFetch(iChannel1, ivec2(16, 0), 0).x;\n        \n        float F = texelFetch(iChannel1, ivec2(70, 0), 0).x;\n        \n        vec3 hor_forward = vec3(cos(yaw), sin(yaw), 0.0); \n        vec3 hor_right = vec3(sin(yaw), -cos(yaw), 0.0);\n        \n        float spd = 4.1;\n        if(F > 0.0) spd *= 2.0;\n        if(W > 0.0){\n            nv.xyz += spd*iTimeDelta*hor_forward;\n        }\n        if(S > 0.0){\n           nv.xyz -= spd*iTimeDelta*hor_forward;\n        }\n        if(A > 0.0){\n            nv.xyz -= spd*iTimeDelta*hor_right;\n        }\n        if(D > 0.0){\n            nv.xyz += spd*iTimeDelta*hor_right;\n        }\n        if(space > 0.0){\n            nv.z += spd*iTimeDelta;\n        }\n        if(shift > 0.0){\n            nv.z -= spd*iTimeDelta;\n        }\n    }\n    \n    //0 - increment per-frame, smoother\n    //1 - increment relative to last click, time-stable but stutters\n    \n    int mouse_mode = 0;\n    \n    \n    if(fc == ivec2(1,0)){\n        if(is_start){\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            return;\n        }\n        vec4 old_mouse = texelFetch(iChannel0, ivec2(2,0), 0);\n        vec4 anchor = texelFetch(iChannel0, ivec2(2,1), 0);\n        \n        if(old_mouse.z > 0.0){\n            if(mouse_mode == 0){\n                nv.xy = cv.xy - 1.5*vec2(1.0,-1.0)*(iMouse.xy - old_mouse.xy)/iResolution.y;\n                nv.x = mod(nv.x, 2.0*PI);\n                nv.y = clamp(nv.y, -0.5*PI, 0.5*PI);\n            }\n            if(mouse_mode == 1){\n                nv.xy = anchor.xy + 0.01*vec2(-1.0, 1.0)*(iMouse.xy - old_mouse.xy);\n            }\n            \n        }\n        \n    }\n    if(fc == ivec2(2,0)){\n        if(mouse_mode == 0){\n            nv = iMouse;\n        }\n        if(mouse_mode == 1){\n            if(iMouse.z != cv.z) nv = iMouse;\n        }\n    }\n    if(fc == ivec2(2,1)){\n        if(mouse_mode == 1){\n            vec4 old_mouse = texelFetch(iChannel0, ivec2(2,0), 0);\n            if(iMouse.z != old_mouse.z) nv = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    \n    fragColor = nv;\n    \n    \n}\n","name":"Buffer D","description":"","type":"buffer"}]}