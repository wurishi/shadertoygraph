{"ver":"0.1","info":{"id":"NsBBWc","date":"1647201684","viewed":153,"name":"Rotating Gravity Fractal","username":"metabog","description":"Fractal generated by tracking orbits of 3-body gravity system solutions. It looks cool but I believe a lot of the content is actually caused by quantisation error in the update. Use mouse click-drag to set launch velocity for one of the bodies.","likes":2,"published":1,"flags":64,"usePreview":0,"tags":["fractal","simulation","chaos","gravity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XtlXWf","filepath":"https://soundcloud.com/user-599438178/entheonome","previewfilepath":"https://soundcloud.com/user-599438178/entheonome","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//A fractal-like visual based off tracking the position of one body in a 3 body gravitational bound system\n//Mouse position sets the start position of the second body. Pixel position is mapped to the start position of\n//the body we are tracking. Then map the color to be how long it took the tracked body to escape.\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 compute_grav_pull(vec2 me, vec2 other, float mass)\n{\n    vec2 vec = other-me;\n    float d = length(vec);\n    vec = normalize(vec);\n    \n    //multiply by 50 to apply some distance scale otherwise all the bodies will be very close by\n    //and explode off of each other's steep gravity wells very quickly\n    //there are no collisions so acceleration approaches infinity near the centres of objects!\n   \n   //this is called \"Plummer softening\" look it up\n    d*=50.0;\n    float pull = 1.0f/sqrt(d*d + 2.0);\n    vec *= pull * 1.5 * mass;\n    return vec;\n}\n\n//change these to set the starting velocities of the other bodies\nvec2 body1_start_vel = vec2(-0.001,0.006);\nvec2 body2_start_vel = vec2(0.003,-0.01);\n\n//the masses of the bodies\nfloat b1mass = 1.0;\nfloat b2mass = 1.3;\nfloat movermass = 0.5;\n\nfloat dt = 0.5;\n\n//change this for some big fx!\nvec2 launch_vec = vec2(0,0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //correct aspect ratio\n    float aspect = (iResolution.x/iResolution.y);\n    uv.x = uv.x * aspect;\n    \n    float anim_time = iTime*0.2;\n\n    vec2 b1pos = vec2(0.0, 0.0);\n    vec2 b2pos = vec2(cos(anim_time),sin(anim_time))*sin(anim_time)*0.5 + b1pos;\n    \n    vec2 b1vel = body1_start_vel;\n    vec2 b2vel = body2_start_vel;\n    \n    //start at uv coords\n    vec2 moverpos = uv - vec2(0.5*aspect,0.5);\n    \n    if(length(iMouse.xy)>0.0)\n    {\n        launch_vec = iMouse.xy/iResolution.xy - vec2(0.5,0.5);\n    }\n    \n    //set start velocity for the tracked body to rotate slowly\n    vec2 movervel = launch_vec;\n    //movervel = vec2(0,0.01);\n    int maxiter = 128;\n    \n    int iter_reached = 0;\n   \n    vec2 b1acc = vec2(0.0,0.0);\n    vec2 b2acc =  vec2(0.0,0.0);\n    vec2 moveracc =  vec2(0.0,0.0);\n   \n    bool escaped = false;\n    while(iter_reached<maxiter)\n    {\n        //VERLET INTEGRATION UPDATE\n        vec2 new_b1pos = b1pos + b1vel*dt + b1acc*dt*dt*0.5;\n        vec2 new_b2pos = b2pos + b2vel*dt + b2acc*dt*dt*0.5;\n        vec2 new_moverpos = moverpos + movervel*dt + moveracc*dt*dt*0.5;\n        \n        //get the new velocities\n        vec2 new_b1acc  = compute_grav_pull(b1pos, b2pos, b2mass) + compute_grav_pull(b1pos,moverpos, movermass);\n        vec2 new_b2acc  = compute_grav_pull(b2pos, b1pos, b1mass) + compute_grav_pull(b2pos,moverpos,movermass);\n        vec2 new_moveracc = compute_grav_pull(moverpos, b1pos,b1mass) + compute_grav_pull(moverpos,b2pos,b2mass);\n\n        vec2 new_b1vel = b1vel + (b1acc + new_b1acc)*dt*0.5;\n        vec2 new_b2vel = b2vel + (b2acc + new_b2acc)*dt*0.5;\n        vec2 new_movervel = movervel + (moveracc + new_moveracc)*dt*0.5;\n       \n        b1acc = new_b1acc;\n        b2acc = new_b2acc;\n        moveracc = new_moveracc;\n        \n        b1vel = new_b1vel;\n        b2vel = new_b2vel;\n        movervel = new_movervel;\n        \n        b1pos = new_b1pos;\n        b2pos = new_b2pos;\n        moverpos = new_moverpos;\n        \n        if(length(moverpos)>3.0)\n        {\n            escaped = true;\n            break;\n        }\n        iter_reached++;\n    }\n    \n    bool blacken_captures = false;\n    \n    float d = (escaped || !blacken_captures) ? float(iter_reached)/float(maxiter) : 0.0;\n    fragColor = vec4(hsv2rgb(vec3(d*5.9,0.4,d)),1.0);\n}","name":"Image","description":"","type":"image"}]}