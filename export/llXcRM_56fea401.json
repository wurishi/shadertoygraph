{"ver":"0.1","info":{"id":"llXcRM","date":"1504003616","viewed":255,"name":"water+cloud","username":"Coolok","description":"water+cloud","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["watercloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// maybe something between 0.5 and 3.0\nconst float CLOUD_HEIGHT = 2.0;\n\n// scale of clouds\nconst float UV_FREQ = 0.004;\n\n// cloudiness, bigger number = less clouds\nconst float CLOUD_FILTER = 0.35;\n\n// parallax layers\nconst int PARALLAX_LAYERS = 2;\n\nfloat flter(float f, float a)\n{\n   f = clamp(f - a, 0.0, 1.0);\n   f /= (1.0 - a);    \n   return f;\n}\n\nfloat fbm(vec2 uv)\n{\n    float f = (texture(iChannel0, uv * 2.0).r - 0.5) * 0.5;\n    f += (texture(iChannel0, uv * 4.0).r - 0.5) * 0.125;\n    f += (texture(iChannel0, uv * 8.0).r - 0.5) * 0.125 * 0.5;\n    f += (texture(iChannel0, uv * 16.0).r - 0.5) * 0.125 * 0.25;\n    f += (texture(iChannel0, uv * 32.0).r - 0.5) * 0.125 * 0.24;\n    f += (texture(iChannel0, uv * 64.0).r - 0.5) * 0.125 * 0.22;\n    f += (texture(iChannel0, uv * 128.0).r - 0.5) * 0.125 * 0.12;\n    f += (texture(iChannel0, uv * 256.0).r - 0.5) * 0.125 * 0.1;\n    f += 0.5;\n    return clamp(f, 0.0, 1.0);\n}\n\n\n\nvec2 getuv(in vec2 uv, float l)\n{\n    vec3 rd = normalize(vec3(uv, 0.4));\n    vec2 _uv = vec2(rd.x / abs(rd.y) * l, rd.z / abs(rd.y) * l);\n    return _uv;\n}\n\n// cloud rendering\nvoid clouds (vec2 uv, inout vec4 col, float t, float freq)\n{\n    vec2 _uv = getuv(uv, 1.0);\n    _uv.y += t;\n    float l = 1.0;\n    \n    vec2 mouse = (iMouse.xy - iResolution.xy * 0.5) / iResolution.xy;\n    \n    for (int i = 0; i < PARALLAX_LAYERS; ++i)\n    {\n        // 3 parallax layers of clouds\n        float h = fbm(_uv * freq) * 0.5;\n        h += fbm(vec2(-t * 0.001, t * 0.0015) + _uv * freq * 1.1) * 0.35;\n        h += fbm(vec2(t * 0.001, -t * 0.0025) + _uv * freq * 1.2) * 0.15;\n        \n        float f = flter(h, CLOUD_FILTER + mouse.x * 0.1 + sin(t)/2.0 *0.1);\n        f -= (l - 1.0) * CLOUD_HEIGHT; // height\n        \n        //f = clamp(f, 0.0, 1.0);\n        if (f < 0.0)\n            f = 0.0;\n        \n        //self-shadow the deepest cloud portions\n        col += f * vec4(0.9, 0.9, 1.0, 1.0) * (1.0 - col.a);\n        if (f > 0.27)\n        {\n            float overflow = f-0.27;\n            col -= 0.9* overflow * vec4(0.6, 0.6, 0.7, 1.0);\n        }        \n        col += 0.04;\n        \n        l *= 1.09 - h * (0.18 * (1.0 + (mouse.y + 0.8 + cos(t)/2.0) * 0.2) ); // parallax control, offset uv by fbm density\n       \n        _uv = getuv(uv, l);\n    \t_uv.y += t;\n    }\n}\n\n// fbm for reflections\nfloat wfbm(vec2 uv)\n{\n    float f = (texture(iChannel1, uv * 1.0).r - 0.5) * 0.5;\n    f += (texture(iChannel1, uv * 2.0).r - 0.5) * 0.5 * 0.5;\n    f += (texture(iChannel1, uv * 4.0).r - 0.5) * 0.25 * 0.5;\n    f += (texture(iChannel1, uv * 8.0).r - 0.5) * 0.25 * 0.5 * 0.5;\n    f += (texture(iChannel1, uv * 16.0).r - 0.5) * 0.25 * 0.5 * 0.5 * 0.5;\n    return f + 1.7;\n    \n}\n\nvec3 grad(vec2 uv)\n{\n\tvec2 off = vec2(0.15, 0.0);\n    vec3 g = vec3(wfbm(uv + off.xy) - wfbm(uv - off.xy),\n                  off.x,\n\t\t\t\t  wfbm(uv + off.yx) - wfbm(uv - off.yx));\n    \n    return normalize(g);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= vec2(0.5);\n    uv.y /= iResolution.x / iResolution.y;\n    float AcosTime = abs(cos(iTime*0.1));\n    vec4 dark = vec4(0.1, 0.2, 0.3, 0.0) * 1.5*AcosTime;\n    vec4 light = vec4(0.3, 0.4, .55, 0.0) * 1.5*AcosTime;\n    vec4 bg = mix(light, dark, abs(uv.y) * 16.5);\n    vec4 col = vec4(AcosTime ,AcosTime ,AcosTime ,1.0);\n    \n    vec2 _uv = uv;\n    _uv.y -= iTime * 0.01;\n    _uv.x *= 0.1;\n    vec2 guv = vec2(0.0);\n    \n    if (uv.y < 0.0)\n    {\n\t    vec3 g = grad(_uv * 5.0);\n\t    guv = vec2(g.x / g.y, g.z / g.y);\n    }\n    \n    clouds(uv + guv * 0.015 * mix(-0.0, 1.0, clamp(abs(uv.y) * 5.0 - 0.04, 0.0, 1.0)  ), col, iTime * 0.4, UV_FREQ);\n   \n    fragColor = mix(bg, col, col.a);\n    if (uv.y < 0.0)\n    {\n        //darken the water\n        fragColor *= 0.7;\n        //add some ambient blue\n        fragColor += vec4(0.07, 0.07, 0.13, 1.0);\n    }\n\n    // some graphical candy, sun halos etc.\n    if(uv.y < 0.0)\n    {\n        _uv = uv;\n    \tfragColor = mix(dark, fragColor, (1.0 - smoothstep(-0.05, -0., uv.y) * 0.75));\n        \n        _uv.x *= 0.1;\n        fragColor = mix(fragColor, vec4(1.0), 1.0 - smoothstep(0.0, 0.025, length(_uv)));\n\n        //_uv.y *= 0.05;\n        //_uv.x *= 0.35;\n\t\t//fragColor = mix(fragColor, vec4(1.0), 1.0 - smoothstep(0.0, 0.005, length(_uv)));\n        \n    }else\n    {\n\t    vec4 wcolor = light * 1.3;\n    \tfragColor = mix(wcolor, fragColor, (smoothstep(0., .1, uv.y)));        \n\t\tvec2 _uv = uv;\t\n        _uv.x *= 0.5;\n        fragColor = mix(fragColor, vec4(1.0, 0.60, 0.1 ,1.0), 1.0 - smoothstep(0.0, 0.05*abs(cos(iTime*0.1)), length(_uv)));\n    }\n    \n    uv.x *= 0.015;\n    fragColor = mix(fragColor, vec4(1.0), 1.0 - smoothstep(0., 0.01, length(uv)));\n    fragColor = mix(fragColor, vec4(1.0), 1.0 - smoothstep(0., 0.005, length(uv)));\n    \n    // contrast\n    float contr = 0.6;\n    fragColor = mix(vec4(0.0), vec4(1.0), fragColor * contr + (1.0 - contr) * fragColor * fragColor * (3.0 - 2.0 * fragColor));\n}","name":"Image","description":"","type":"image"}]}