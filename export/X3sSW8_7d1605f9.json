{"ver":"0.1","info":{"id":"X3sSW8","date":"1709452631","viewed":191,"name":"perspective attempt","username":"zeroDarkThirty","description":"perspective attempt","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["perspectiveattempt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  perspective camera projections\n  \n  ar: aspect ratio (screenWidth/screenHeight). Should be 1 since uv coords are normalized?\n  fov: vertical angle  \n  near, far: points you want displayed should have points.z > near && points.z < far\n*/\n\n# define ar 1.\n# define fov 30.\n# define near .1\n# define far 100.\n\n/*\n  since +y is up, +x is right, and +z comes out of the screen, camera is looking down z\n*/\n\nvec3 camera = vec3(0.0,0.0,20.);\n\n# define dotSize 0.015\n\n\n/*\n  dont chnage\n*/\n# define itfov 1.0/(tan(3.141592654*fov/(180.*2.)))\n# define iar 1.0/ar\n# define fodfn far/(far-near)\n# define fnodfn -near*far/(far-near)\n\n\n/*\n  rotations (realtive to origin)\n  point => get a point from x and y\n  projection => apply perspective projection\n  pixelFromPos => combines point() and projection(), needs uv and camera\n*/\n\nvec3 rotY( vec3 r, float t ){return vec3(r.x*cos(t)+r.z*sin(t),r.y,-r.x*sin(t)+r.z*cos(t));}\nvec3 rotX( vec3 r, float t ){return vec3(r.x,r.y*cos(t)-r.z*sin(t),r.y*sin(t)+r.z*cos(t));}\nvec3 rotZ( vec3 r, float t ){return vec3(r.x*cos(t)-r.y*sin(t),r.x*sin(t)+r.y*cos(t),r.z);}\nfloat point( vec2 u, vec2 r ){return pow(dotSize/length(u-r), 2.);}\nvec2 projection( vec4 r ){float d = (r.z*fodfn+r.w*fnodfn);return vec2(r.x*itfov*iar/d,r.y*itfov/d);}\nfloat pixelFromPos( vec3 r,vec3 cam,vec2 uv ){return point(uv,projection(vec4(r-cam,1.0)));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    /*  screen middle at (0,0) x and y, almost spans -1.0<>1.0 */\n    \n    \n    float alpha;\n    camera.z = (cos(iTime)+1.)*5.+10.;\n    \n    \n    /*  just a cube from 12 edges with dots inbetween  */\n    for(float i = -1.0; i<1.1; i+=0.1)\n    {\n        alpha += pixelFromPos(rotX(rotY(vec3(i,1.0,1.0),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(i,-1.0,1.0),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(1.0,i,1.0),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(-1.0,i,1.0),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(i,1.0,-1.0),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(i,-1.0,-1.0),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(1.0,i,-1.0),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(-1.0,i,-1.0),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(-1.0,-1.0,i),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(-1.0,1.0,i),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(1.0,-1.0,i),iTime),iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(1.0,1.0,i),iTime),iTime),camera,uv);\n    }\n    \n    \n    /*  random expanding rectange points  */\n    for(float i = 1.; i<5.; i+=0.1)\n    {\n        float phaseDiff = 3.141592654 * i * cos(iTime) ;\n        alpha += pixelFromPos(rotX(rotY(vec3(-.5,-.5,-2.*i*cos(iTime)),iTime+phaseDiff),2.*iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(.5,.5,-2.*i*cos(iTime)),iTime+phaseDiff),2.*iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(-.5,.5,-2.*i*cos(iTime)),iTime+phaseDiff),2.*iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(.5,-.5,-2.*i*cos(iTime)),iTime+phaseDiff),2.*iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(-.5,-.5,2.*i*cos(iTime)),iTime+phaseDiff),2.*iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(.5,.5,2.*i*cos(iTime)),iTime+phaseDiff),2.*iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(-.5,.5,2.*i*cos(iTime)),iTime+phaseDiff),2.*iTime),camera,uv);\n        alpha += pixelFromPos(rotX(rotY(vec3(.5,-.5,2.*i*cos(iTime)),iTime+phaseDiff),2.*iTime),camera,uv);\n    }    \n    \n    \n    vec3 color = (alpha) * vec3(0.3, 0.2, sin(iTime) * 0.3);\n\tfragColor = vec4(color, 1.);  \n}","name":"Image","description":"","type":"image"}]}