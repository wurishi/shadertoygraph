{"ver":"0.1","info":{"id":"lcyGRz","date":"1712319594","viewed":101,"name":"Smooth Rectangle","username":"wutzhuhn","description":"Similar to a rounded rectangle, but using parabolas for the corners instead of circles. This way the curvature of the outline is smoother, though it could be better, see iq's comments below.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","rectangle","quadratic","smooth","rounded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parabola code based on https://www.shadertoy.com/view/lsdBDS\n// Colors and some more inspiration from https://www.shadertoy.com/view/ws3GD7 \n\nfloat smoothRect(in vec2 p, in vec2 pos, in vec2 size, in float radius)\n{\n    p = abs(p - pos) - size / 2.0 + vec2(0.25 * radius);\n\n    p = vec2(abs(p.x - p.y), -(p.x + p.y)) * 0.5;\n\n    // Straight horizontal or vertical segments\n    if (sqrt(0.5) * radius <= p.x + p.y) return (p.x - 0.25 * radius - p.y);\n    \n    // The rest is for finding the distance to the corner-parabola.\n    float a = p.x / radius / 4.0;\n    float b = (p.y / radius - 0.5) / 3.0;\n    float dis = a * a - b * b * b;\n \n    float qx;\n    if (0.0 <= dis)\n    {   // one root\n        float r = pow(a + sqrt(dis), 1.0 / 3.0);\n        qx = r + b / r;\n    }\n    else\n    {   // three roots\n        // However, the center one can never be the closest, so we can ignore it.\n        // The third is eliminated because it's a mirror of the first one and we abs'd px before.\n        float r = sqrt(b);\n        qx = r * 2.0 * cos(acos(a / (b * r)) / 3.0);\n    }\n    vec2 q = vec2(qx, qx * qx) * radius;\n    return length(q - p) * sqrt(2.0) * sign(q.y - p.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float ip = 1.0 / iResolution.y;\n    vec2 p = (2.0 * fragCoord - iResolution.xy) * ip;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy) * ip;\n\n    float t = iTime/2.0;\n    vec2 pos  = vec2(0.0 + 0.4 * cos(t * 1.1 + 5.5), -0.4 + 0.2 * cos(t * 1.2 + 3.0));\n    vec2 size = vec2(0.8 + 0.7 * cos(t * 1.3 + 3.5),  0.8 + 0.7 * cos(t * 1.4 + 3.3));\n\n    float d = smoothRect(p, pos, size, min(size.x, size.y) * 0.5);\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n        d = smoothRect(m, pos, size, min(size.x, size.y) * 0.5);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}