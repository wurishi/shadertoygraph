{"ver":"0.1","info":{"id":"tsSyDt","date":"1587500351","viewed":93,"name":"Cornell Box with DOF & Penumbra","username":"Iris_","description":"Homework for CIS 561","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["cornellbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define NOEFFECT\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from https://www.shadertoy.com/view/XdfGDH\n    const int mSize = 11;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 20.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 unblurredColor = texture(iChannel0, uv);\n\n    fragColor = vec4(mix(unblurredColor.rgb, final_color/(Z*Z), unblurredColor.a / 2.0), 1.0);\n    \n    float vignette = smoothstep(1.75, 0.0, length((2.0 * uv) - vec2(1.0)));\n    fragColor = mix(vec4(0.0, 0.0, 0.1, 1.0), fragColor, vignette);\n    \n    // fragColor = vec4(unblurredColor.a, unblurredColor.a, unblurredColor.a, 1.0);\n    #ifdef NOEFFECT\n    fragColor = unblurredColor;\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FIVE_TAP\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 material = computeMaterial(hitObj, isect, nor);\n   \n    float shadowCoefficient = shadow(isect, 0.1) * 1.2;\n\tvec3 overallColor = material * (lambertColor(isect, nor) * shadowCoefficient + 0.1);\n    \n\n    #ifdef FIVE_TAP\n    float ao = fiveTapAO(isect, nor, FIVETAP_K);\n    overallColor *= ao;\n    #endif\n    \n    vec3 sdfColor = overallColor;\n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    // eye = rotateY(vec3(0.0, 0.0, 15.0), sin(iTime * 0.1) * 3.14159 * 0.5);\n    eye = cameraTarget + vec3(0, 150, -850);\n    ref = cameraTarget;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    uv2.x = -uv2.x;\n    \n    // 2x2 anti-aliasing ray casts\n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye);\n        }\n    }\n    \n    float distAlongCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float focallength = FOCAL_LENGTH + sin(iTime * 2.) * 100.;\n    float dofZ = min(1.0, abs(distAlongCamZ - focallength) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5);\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), dofZ);\n    \n    vec4 globalColor = texture(iChannel0, uv);\n    fragColor = fragColor * 0.85 + globalColor * 0.5;\n    // fragColor = globalColor;\n\n   // float fogT = smoothstep(50.0, 100.0, distance(aaIsects[0].p, eye));\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int GLOBAL_SAMPLES = 20;\n\nvec2 random2(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\nvoid coordinateSystem(const vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y)) {\n        v2 = vec3(-v1.z, 0, v1.x) / length(v1.xz);\n    }\n    else {\n        v2 = vec3(0, v1.z, -v1.y) / length(v1.yz);\n    }\n    v3 = cross(v1, v2);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 sdfColor = vec3(0., 0., 0.);\n    // Sample a few points in the hemisphere around n at p\n    vec3 tdire, bdire;\n    // Make a tangent and bitangent vector\n    coordinateSystem(nor, tdire, bdire);\n    for(int i = 0; i < GLOBAL_SAMPLES; ++i) {\n        // Generate a pair of random [0, 1] floats\n        vec2 xi = random2(isect + float(i) * 203.1);\n        // vec2 xi = vec2(1., 0.);\n        // Convert the xi pair to a vector in the hemisphere\n        xi.y = pow(xi.y, 2.);\n        float len = sqrt(xi.y);\n        float rx = len * cos(6.2831 * xi.x);\n        float ry = len * sin(6.2831 * xi.x);\n        float rz = sqrt(1.0 - xi.y); // z = sqrt(1 - x*x - y*y)\n        vec3 dir2 = vec3(rx * tdire + ry * bdire + rz * nor);\n        float t2;\n        int hitObj2;\n        isect += dir2 * 0.01;\n        march(isect, dir2, t2, hitObj2);\n        vec3 isect2 = isect + t2 * dir2;\n        vec3 nor2 = computeNormal(isect2);\n    \n        vec3 material2 = computeMaterial(hitObj2, isect2, nor2);\n        float shadowCoefficient = 1.f;\n        vec3 overallColor2 = material2 * (lambertColor(isect2, nor2) * shadowCoefficient + 0.1);\n        sdfColor += overallColor2;\n    }\n    sdfColor /= float(GLOBAL_SAMPLES);\n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    // eye = rotateY(vec3(0.0, 0.0, 15.0), sin(iTime * 0.1) * 3.14159 * 0.5);\n    eye = cameraTarget + vec3(0, 150, -850);\n    ref = cameraTarget;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    uv2.x = -uv2.x;\n    \n    Intersection aaIsects;\n    vec3 dir, eye, ref;\n\n    raycast(uv2 , dir, eye, ref);\n    aaIsects = sdf3D(dir, eye);\n\n    float focallength = FOCAL_LENGTH + sin(iTime * 2.) * 100.;\n    vec3 avgColor = aaIsects.color;\n\n    fragColor = vec4(avgColor * step(0.0, aaIsects.t), 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define OBJ_FLOOR\t\t1\n#define OBJ_CEILING\t\t2\n#define OBJ_BACKWALL\t3\n#define OBJ_LEFTWALL\t4\n#define OBJ_RIGHTWALL\t5\n#define OBJ_LIGHT\t\t6\n#define OBJ_SHORTBLOCK\t7\n#define OBJ_TALLBLOCK\t8\n\n// RGB wavelengths: 650nm, 510nm, 475nm\nconst vec3 lightColor = vec3(16.86, 8.76 +2., 3.2 + .5);\nconst vec3 lightDiffuseColor = vec3(.78);\nconst vec3 leftWallColor = vec3(.611, .0555, .062);\nconst vec3 rightWallColor = vec3(.117, .4125, .115);\nconst vec3 whiteWallColor = vec3(.7295, .7355, .729);\nconst vec3 cameraTarget = vec3(556, 548.8, 559.2) * .5;\nconst vec3 lightPos = vec3(278, 548.8 -100., 292 - 50);\nconst float SHADOW_HARDNESS = 12.;\nconst int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\nconst float FOCAL_LENGTH = 800.0;\n//const float FOCAL_RANGE = 300.0;\nconst float FOCAL_RANGE = 300.0;\n\nconst float AO_DIST = 10.;\nconst float FIVETAP_K = 0.04;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n\n/// +++++++++++++++++++ Help Function +++++++++++++++++++\n    \n// from https://www.shadertoy.com/view/XdfGDH\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\n\nvec3 rotateX(in vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n\n\n/// +++++++++++++++++++ SDF +++++++++++++++++++\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n    \tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat mapBlocks(vec3 p, out int obj) {\n\tfloat t1 = box(rotateY(p + vec3(-186, -82.5, -169.5), 0.29718), vec3(83.66749, 83.522452, 82.5));\n\tfloat t2 = box(rotateY(p + vec3(-368.5, -165, -351.5), -0.30072115), vec3(87.02012, 165, 83.6675));\n    obj = OBJ_SHORTBLOCK;\n\tif (t2 < t1) \n    {\n        obj = OBJ_TALLBLOCK;\n        t1 = t2;\n    }\n\treturn t1;\n}\n\n\n/// +++++++++++++++++++ Scene Info +++++++++++++++++++\n\nfloat sceneMap3D(vec3 pos)\n{\n\n    float t = plane(pos, vec4(1.0, 0.0, 0.0, 0.0));\n    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 556.0)));\n    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 0.0)));\n    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 548.8)));\n    t = min(t, plane(pos, vec4(0.0, 0.0, -1.0, 559.2)));\n    int m;\n    t = min(t, mapBlocks(pos, m));\n\n    return t;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = plane(pos, vec4(1.0, 0.0, 0.0, 0.0));\n    float t2;\n    obj = OBJ_RIGHTWALL; // 0 is center sphere\n    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 556.0))) < t) {\n        t = t2;\n        obj = OBJ_LEFTWALL;        \n    }\n    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 0.0))) < t) {\n        t = t2;\n        obj = OBJ_FLOOR;\n    }\n    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 548.8))) < t) {\n        t = t2;\n        obj = OBJ_CEILING;\n    }\n    if((t2 = plane(pos, vec4(0.0, 0.0, -1.0, 559.2))) < t) {\n        t = t2;\n        obj = OBJ_BACKWALL;\n    }\n    int blockType;\n    float blockDepth = mapBlocks(pos, blockType);\n    if(blockDepth < t)\n    {\n        t = blockDepth;\n        obj = blockType;\n    }\n\n}\n\n/// +++++++++++++++++++ Base Code +++++++++++++++++++\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n) {\n    float t;\n    switch(hitObj) {\n        case OBJ_FLOOR: \n        case OBJ_CEILING:\n        case OBJ_BACKWALL:\n        return whiteWallColor;\n\n        case OBJ_LEFTWALL:\n        return leftWallColor;\n        \n        case OBJ_RIGHTWALL:\n        return rightWallColor;\n        \n        case OBJ_SHORTBLOCK:\n        case OBJ_TALLBLOCK:\n        return whiteWallColor;\n\n    }\n    return vec3(1.0);\n}\n\nfloat lambertColor(vec3 p, vec3 nor)\n{\n    vec3 l = normalize(lightPos - p);\n    float lightDistance = length(lightPos - p);\n    float atten = ((1. / lightDistance) * .5) + ((1. / (lightDistance * lightDistance)) * .5);                                                  \n    return max(dot(nor, l), 0.0) * atten * 500.0;\n}\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 obj = origin + t * dir;\n        float m = sceneMap3D(obj);\n        if(dot(obj - lightPos, origin - lightPos) < 0.) \n            return 1.0;\n        if(m < 0.0001) {\n            // return 0.0;\n            return float(i) * 0.01;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 obj = origin + t * dir;\n        float m = sceneMap3D(obj);\n        if(dot(obj - lightPos, origin - lightPos) < 0.) \n            return res;\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow( vec3 origin, float min_t) {\n    vec3 dir = normalize(lightPos - origin);\n    // #define HARD_SHADOW\n    #ifdef HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// from https://www.shadertoy.com/view/XdfGDH\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // from https://www.shadertoy.com/view/XdfGDH\n    const int mSize = 7;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_color = vec3(0.0);\n\n    //create the 1-D kernel\n    float sigma = 20.0;\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j) {\n        kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n    }\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j) {\n        Z += kernel[j];\n    }\n    \n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i) {\n        for (int j=-kSize; j <= kSize; ++j) {\n            final_color += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\n        }\n    }\n    \n    fragColor = vec4(final_color/(Z*Z), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}