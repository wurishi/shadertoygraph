{"ver":"0.1","info":{"id":"XcVyWd","date":"1732563804","viewed":17,"name":"Simple Camera Projection","username":"oneshade","description":"Example of how to project 3D points onto the screen from the viewpoint of a camera.","likes":0,"published":3,"flags":0,"usePreview":0,"tags":["2d","3d","camera","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.001;\n\nfloat map(in vec3 p) {\n    float xAxisMarker = max(abs(p.x - 0.5) - 0.5, length(p.zy) - 0.1);\n    float yAxisMarker = max(abs(p.y - 0.5) - 0.5, length(p.xz) - 0.1);\n    float zAxisMarker = max(abs(p.z - 0.5) - 0.5, length(p.xy) - 0.1);\n    return min(xAxisMarker, min(yAxisMarker, zAxisMarker));\n}\n\nvec3 getNormal(in vec3 p, in float centralDist) {\n    return normalize(vec3(\n        map(p + vec3(EPSILON, 0.0, 0.0)),\n        map(p + vec3(0.0, EPSILON, 0.0)),\n        map(p + vec3(0.0, 0.0, EPSILON))\n    ) - centralDist);\n}\n\n#define paint(sdf2d, color) fragColor.rgb = mix(color, fragColor.rgb, smoothstep(0.0, fwidth(sdf2d), sdf2d))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    fragColor = vec4(0.0);\n\n    vec3 markers[] = vec3[3](\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n\n    vec3 cameraPos = vec3(0.75 + sin(iTime), 1.25 + cos(iTime), 2.5);\n    vec3 viewTarget = vec3(0.0, 0.25, 0.0);\n    float focalLength = 1.0;\n\n    vec3 forwardAxis = normalize(viewTarget - cameraPos);\n    vec3 rightAxis = normalize(vec3(-forwardAxis.z, 0.0, forwardAxis.x));\n    vec3 upAxis = cross(rightAxis, forwardAxis);\n    mat3 cameraMatrix = mat3(rightAxis, upAxis, forwardAxis);\n\n    vec3 ro = cameraPos;\n    vec3 rd = normalize(cameraMatrix * vec3(uv, focalLength));\n\n    float t = 0.0;\n    float dist;\n    vec3 pos;\n    bool hit = false;\n    for (int i = 0; i < 100; i++) {\n        pos = ro + rd * t;\n        dist = map(pos);\n        if (abs(dist) < EPSILON) {\n            hit = true;\n            break;\n        }\n\n        if (t > 25.0)\n            break;\n\n        t += dist;\n    }\n\n    if (hit) {\n        vec3 normal = getNormal(pos, dist);\n        fragColor.rgb = 0.5 + 0.5 * normal;\n    }\n\n    mat3 inverseCamera = inverse(cameraMatrix);\n    for (int i = 0; i < markers.length(); i++) {\n        vec3 viewSpacePos = inverseCamera * (markers[i] - cameraPos); // Undo camera translation and rotation\n        vec2 projectedPos = viewSpacePos.xy * focalLength / viewSpacePos.z; // Perspective projection\n        paint(length(uv - projectedPos) - 0.01, vec3(1.0, 0.0, 0.0));\n    }\n}","name":"Image","description":"","type":"image"}]}