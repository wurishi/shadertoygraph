{"ver":"0.1","info":{"id":"csGczz","date":"1695694337","viewed":22,"name":"1/49","username":"tono","description":"1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["49"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box(vec3 p , vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x,max(p.y,p.z));\n}\n\nfloat bo(vec2 p , vec2 s)\n{\n    p = abs(p) - s;\n    return max(p.x,p.y);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat smin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nfloat scaleSphere( vec3 p, vec3 scale, float s )\n{\n    return (length(p/scale)-s)*min(scale.x, min(scale.y, scale.z));\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat pi = acos(-1.);\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec2 min2(vec2 a, vec2 b)\n{\n    if(a.x < b.x)\n    {\n        return a;\n    }\n    return b;\n}\n\nvec2 beans(vec3 p)\n{\n    float o = 10.;\n    //p.xz = mod(p.xz , 3.) - 1.5;\n    p.y -= 1.3;\n    p.x += iTime + sin(p.z/10. + iTime/10.) * 32.;\n    p.xz = sin(p.xz);\n    for(int i = 0; i < 3; i++)\n    {\n        p.y += sin(p.x + p.z)/10.;\n        p = abs(p) - .2;\n        p.xz *= rot(0.3);\n        p.yz *= rot(0.21);\n    \to = smin(box(p,vec3(.1,0.01,0.1) * 12.),o,14. );\n    }\n    return vec2(o,2.);\n} \n\nvec2 tanbo(vec3 p)\n{\n    vec3 op= p;\n    p.y *= -1.;\n    float grid = 32. * 3.;\n    p.xz = mod(p.xz , grid) - grid/2.;\n    float h = p.y;\n    float tanboSize = 14.8 * 3.;\n    h = ( smoothstep(0.,1.,p.x + tanboSize) * smoothstep(1.,0.,p.x - tanboSize) \n        * smoothstep(0.,1.,p.z + tanboSize) * smoothstep(1.,0.,p.z - tanboSize))  \n        * .9;\n    \n    if(h > 0. && p.y + h < 0.1 )\n    {\n    \th += noise(op.xz * 20.)/20.;\n    }else if(h > 0. && p.y + h < 1.){\n    }\n    \n    vec2 o = vec2(p.y + h,smoothstep(0.,1.,-p.y));\n    if(h > 0.)\n    {\n    \to = min2(o,beans(op));\n    }\n    return o;\n}\n\nfloat wave(vec3 p)\n{\n    float h = 0.;\n    for(int i = 0; i < 3; i++)\n    {\n        p.x += sin(iTime);\n        h += (1.-abs(sin(p.x)) * abs(cos(p.x)))/(float(i) + 6.);\n        p.xz *= rot(2.);\n    }\n    return h;\n}\n\n\nvec2 map(vec3 p)\n{\n    \n    vec2 o = vec2(1.);\n    //o.x = length(p) - .4;\n    p.y -= 2.5;\n    o = tanbo(p);\n    //o.x = p.y - sin(p.x);\n    return o;\n}\n\nvec2 march(vec3 cp,vec3 rd)\n{\n    float depth = 0.;\n    for(int i = 0; i < 256 ; i++)\n    {\n        vec2 d = map(cp + rd * depth);\n        if(abs(d.x) < 0.001)\n        {\n        \treturn vec2(depth , d.y);    \n        }\n        if(depth > 300.)break;\n        depth += d.x;\n    }\n    return vec2(-1.);\n    \n}\n\nvec3 leaf = normalize(vec3(119,152,85));\nvec3 road = normalize(vec3(95,91,85));\nvec3 dirt = normalize(vec3(75,64,47));\nvec3 sky = normalize(vec3(194,203,212));\nvec3 mountain = normalize(vec3(79,105,131));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    vec3 forward = vec3(0.);\n    forward.z += iTime;\n    forward.x += (noise(vec2(iTime)) - .5)/2.;\n    forward.y += (noise(vec2(iTime/2.)) - .5)/2.;\n    vec3 cp = vec3(0.,0.,-5.) + forward;\n    vec3 target = vec3(0.) + forward;\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd , cs));\n    float fov =1.5;\n    //fov *= 3. - dot(p,p);\n    vec3 rd = normalize(cd * fov + p.x * cs + p.y * cu);\n    \n    vec3 color = vec3(0.);\n    color = sky;\n    \n    \n    vec2 d = march(cp , rd);\n    if(d.x > 0.)\n    {\n        vec3 pos = d.x * rd + cp;\n        vec2 e = vec2(1.0, -1.0) * 0.0005;\n        vec3 n = -normalize(\n                  e.xyy * map(pos + e.xyy).x +\n                  e.yyx * map(pos + e.yyx).x +\n                  e.yxy * map(pos + e.yxy).x +\n                  e.xxx * map(pos + e.xxx).x);\n        \n        vec3 lp = (vec3(0.,0.,1.));\n        vec3 lcol = vec3(.8,.9,1.);\n        float strength = 5.;\n        float rimstr = 1.;\n        \n        vec3 mat = vec3(.6);\n        mat = mix(vec3(.2),dirt,d.y);\n        mat = mix(mat,leaf,max(0.,d.y - 1.));\n        strength = strength / pow(length(lp - pos),2.);\n        vec3 l = normalize(lp - pos) * strength;\n        \n        l= normalize(vec3(2.,4.,8.));\n        float diff = max(0.,dot(l,n));\n        float rim = pow(clamp(1. - dot(n, -rd), 0., 1.), rimstr);\n        \n        float sp = max(0.,dot(reflect(n,l),-rd));\n        sp = pow(sp,100.) * 1.;\n        //rim = pow(rim,3.);\n        float shadow = step(march(pos + n * 0.01,-l).x,0.);\n        color = mat;\n        color = diff * mat;\n        color += sp * lcol;\n        color *= shadow;\n       // color += rim *mat;\n      //  color = n;\n        d.x = abs(d.x);\n        float t = 1. - exp(-0.000003 * d.x * d.x * d.x);\n        color = mix(color , sky,t);\n        \n    }else{\n        float moun = (fbm(p.x * vec2(1.,-1.) * 10.) + 6.)/12.;\n        moun -= fbm(p.xx)/4.;\n        vec3 a = normalize(vec3(64,88,109));\n        vec3 mountainCol = mix(mountain,vec3(0.),fbm(p * 3.) );\n        mountainCol = mix(mountainCol,normalize(vec3(133,162,187)),noise(p * vec2(10.,200.) ));\n    \tcolor = mix(color,mountainCol,step(p.y,moun));\n        //(64,88,109)\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}