{"ver":"0.1","info":{"id":"cdScWm","date":"1687750455","viewed":84,"name":"Skin Segment","username":"leolii","description":"This is a simple shader for skin segment.\nThere are 2 methods implemented in common shader. Both of them are processed in YCbCr color space, whose effectiveness in skin detection has been shown previously. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","imageprocess","skinsegment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 rgbColor = texture(iChannel0, uv);\n    vec3 ycbcrColor = rgb2ycbcr(rgbColor.rgb);\n    \n    fragColor = (step(uv.x, 0.5) * thresholdSegment(ycbcrColor.gb) + \n                step(0.5, uv.x) * ellipseSegment(ycbcrColor.gb)) *\n                rgbColor;\n                \n    if(uv.x > 0.498 && uv.x < 0.502)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 rgb2ycbcr(vec3 rgb) {\n    vec3 rgb2ycbcr_vec = vec3(16.0, 128.0, 128.0);\n    \n    mat3 rgb2ycbcr_mat = mat3(\n        65.4810, 128.5530, 24.9660,\n        -37.7745, -74.1592, 111.9337,\n        111.9581, -93.7509, -18.2072\n    );\n    \n    return rgb2ycbcr_vec + rgb * rgb2ycbcr_mat;\n}\n\nfloat rotatedEllipse(vec2 point) {\n    vec2 center = vec2(113, 155.6);\n    vec2 axis = vec2(23.4, 15.2);\n    float theta = radians(43.0);\n\n    float x = point.x;\n    float y = point.y;\n    float h = center.x;\n    float k = center.y;\n    float a = axis.x;\n    float b = axis.y;\n\n    float firstPart = ((x-h) * cos(theta) + (y-k) * sin(theta)) / a;\n    float secondPart = (-(x-h) * sin(theta) + (y-k) * cos(theta)) / b;\n    float ellipseVal = firstPart * firstPart + secondPart * secondPart;\n\n    return ellipseVal;\n}\n\n// More precise but will bring more noise\nvec4 ellipseSegment(vec2 cbcr) {\n    return step(rotatedEllipse(cbcr), 1.0) *\n           vec4(1.0);\n}\n\n// More tolorentable but less precise\nvec4 thresholdSegment(vec2 cbcr) {\n    float cb = cbcr.x;\n    float cr = cbcr.y;\n    \n    return step(77.0, cb) * step(cb, 127.0) * \n           step(133.0, cr) * step(cr, 173.0) *\n           vec4(1.0);\n}","name":"Common","description":"","type":"common"}]}