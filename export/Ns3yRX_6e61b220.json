{"ver":"0.1","info":{"id":"Ns3yRX","date":"1653801961","viewed":64,"name":"belíssimo xeider","username":"isinyaaa","description":"lindíssimo shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lindo","belo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233))/1.2e5)\n                 * 43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat norm( in vec2 v )\n{\n    return sqrt(dot(v, v));\n}\n\nvec2 rot( in vec2 v, in float ang )\n{\n    return vec2(cos(ang) * v.x - sin(ang) * v.y, sin(ang) * v.x + cos(ang) * v.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec2 ac = 8.0 * uv;\n\n    // Time varying pixel color\n    vec3 col1 = 0.5 - 0.3*cos(iTime * 2.0+uv.xyx+vec3(0,2,4));\n    vec3 col2 = 0.7 + 0.3*sin(iTime * 2.0+uv.xyx+vec3(0,2,4));\n    \n    float theta = atan(iResolution.y/iResolution.x) + iTime/10.0;\n    uv -= 0.5;\n    uv = vec2(uv.x/norm(iResolution.xy/iResolution.xx),uv.y/norm(iResolution.xy/iResolution.yy));\n    vec2 ac = rot(uv, -theta);\n    vec2 n = ac;\n    ac *= 1.0 - 0.1 * vec2(sin(iTime),1.0 - sin(iTime));\n    ac = 16.0 * vec2(ac.x - 0.5, ac.y);\n    n = 4.0 * vec2(n.x - 0.5, n.y);\n    \n    // Make squares\n    fragColor = vec4(smoothstep(0.0, 1.0, noise(n * iTime/100.0)) * col1, 1);\n    if (mod(ac.x, 2.0) < 1.0) {\n        if (mod(ac.y, 2.0) >= 1.0)\n            fragColor += 0.5 * vec4(smoothstep(0.0, 1.0, noise(n * (2.0 - 0.5 * sin(iTime * 10.0)) * 100.0)) * col2, 1);\n    } else {\n        if (mod(ac.y, 2.0) < 1.0) {\n            fragColor += 0.5 * vec4(smoothstep(0.0, 1.0, noise(n * (2.0 - 0.5 * sin(iTime * 10.0)) * 100.0)) * col2, 1);\n            //fragColor = \n        }\n    }\n}","name":"Image","description":"","type":"image"}]}