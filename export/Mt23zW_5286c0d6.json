{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Lighting is done by Spherical Harmonics:\n// This one is a cheap variant presented in 2001 by Ravi Ramamoorthi\n// and Pat Hanrahan: http://graphics.stanford.edu/papers/envmap/\n// http://graphics.stanford.edu/papers/envmap/envmap.pdf\n// There's a C program (prefilter.c) provided to compute spherical harmonic\n// coefficients from light probe images (in the floating point format).\n// I used pvalue tool from Radiance package on my Ubuntu system to convert\n// angular light probe images in HDR format to floating point format with\n// the following command:\n// $ pvalue -df -H -h stpeters_probe.hdr > stpeters_probe.float\n// I then have slightly modified prefilter.c to output values with a factor\n// applied to have coefficients in a correct range (used a factor of 0.1),\n// and ran the following command:\n// $ ./prefilter stpeters_probe.float 1500\n// You can read too the Orange Book, chapter 12.3 (OpenGL Shading Language\n// by Randi J. Rost), it has been very useful.\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is St. Peter's Basilica.\nconst SHCoefficients stpeter = SHCoefficients(\n    vec3( 0.3623915,  0.2624130,  0.2326261 ),\n    vec3( 0.1759131,  0.1436266,  0.1260569 ),\n    vec3(-0.0247311, -0.0101254, -0.0010745 ),\n    vec3( 0.0346500,  0.0223184,  0.0101350 ),\n    vec3( 0.0198140,  0.0144073,  0.0043987 ),\n    vec3(-0.0469596, -0.0254485, -0.0117786 ),\n    vec3(-0.0898667, -0.0760911, -0.0740964 ),\n    vec3( 0.0050194,  0.0038841,  0.0001374 ),\n    vec3(-0.0818750, -0.0321501,  0.0033399 )\n);\n\nvec3 calcIrradiance(vec3 nor, float sca) {\n    const SHCoefficients c = stpeter;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    ) * sca;\n}\n\nvec3 spherePos = vec3(0.0, 1.0, 1.5);\nfloat sphereRadius = 2.5;\n\nfloat raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax, float r) {\n    vec3 ce = ro - spherePos;\n    float b = dot(rd, ce);\n    float c = dot(ce, ce) - r * r;\n    float t = b * b - c;\n    if (t > tmin) {\n        t = -b - sqrt(t);\n        if (t < tmax)\n            return t;\n        }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 3.0, 5.0);\n    vec2 rot = 6.2831 * (vec2(0.6 + iTime * 0.05, sin(iTime * 0.1) * 0.06) + vec2(1.0, 0.25) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - eye);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));   \n\n    vec3 col = texture(iChannel0, rd).xyz;\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n\n    // raytrace the sphere\n    float tsph = raytraceSphere(ro, rd, tmin, tmax, sphereRadius);\n    if (tsph > tmin) {\n        vec3 spos = ro + rd * tsph;\n        vec3 nor = normalize(spos - spherePos);\n        float occ = 0.5 + 0.5 * nor.y;\n        vec3 ref = reflect(rd, nor);\n        vec3 refCol = pow(texture(iChannel0, ref).xyz, vec3(1.0));\n        col = mix(refCol, calcIrradiance(nor, 2.25) * occ, 0.95);\n    }\n\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mt23zW","date":"1427395049","viewed":1178,"name":"StPeter's Spherical Harmonics","username":"jimmikaelkael","description":"Just testing cheap spherical harmonics lighting from Ravi Ramamoorthi and Pat Hanrahan. Their formula uses only 9 coefficients to compute irradiance.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["lighting","spherical","harmonics","stpeters"],"hasliked":0,"parentid":"","parentname":""}}