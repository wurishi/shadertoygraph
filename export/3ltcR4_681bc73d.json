{"ver":"0.1","info":{"id":"3ltcR4","date":"1608595992","viewed":123,"name":"xmas tree flyover (vlllll)","username":"valalalalala","description":"Working a holiday themed flyover. Trying to add some LOD distance cutoffs. Still  a lot of artifacts. Want to improve the sky.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tree","xmas","flyover"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"Xmas Tree Flyover\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Starting from https://www.shadertoy.com/view/tsyfDw\n//\n/////////////////////////////////////////////////////////////////////////////\n\n\n/////////////////////////////////////////////////////////////////////////////\n// toggle camera controlled by the mouse or by time\n\n#define CAMERA_MOUSE_\n\n/////////////////////////////////////////////////////////////////////////////\n// ray marching values\n\n#define RAY_MARCH_STEPS    66\n#define RAY_MARCH_TOO_FAR  float( RAY_MARCH_STEPS )\n#define RAY_MARCH_CLOSE    0.02\n#define RAY_EPSILON        vec2( RAY_MARCH_CLOSE, .0 )\n\n#define THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION\n\n/////////////////////////////////////////////////////////////////////////////\n// scene parameters\n\n#define NOISIER_GROUND_\n\n#define TREE_DISTANCE_MAX       33.\n#define TREE_DISTANCE_SIMPLIFY  10.\n\n\n// object ids\n\n#define TRUNK  1.\n#define BODY   2.\n#define STAR   3.\n#define GROUND 4.\n#define SNOW   5.\n\n/////////////////////////////////////////////////////////////////////////////\n// useful constants and macros\n\n#define TRIG(d, a)      ( d * vec2( cos( a ), sin( a ) ) )\n#define RGB(r,g,b)      vec3( float(r)/255., float(g)/255., float(b)/255. )\n\n#define VEC123          vec3( .1, .2, .3 )\n#define VEC3X(x)        vec3( x, .0, .0 )\n#define VEC3Y(y)        vec3( .0, y, .0 )\n#define VEC3Z(z)        vec3( .0, .0, z )\n\n/////////////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/4dsGRl\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x.xzy);\n    vec3 f = fract(x.xzy);\n\tf = f*f*(3.0-2.0*f);\n\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).ba;\n\treturn mix( rg.y, rg.x, f.z )-.5;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// signed distance functions for types\n\n// https://iquilezles.org/articles/distfunctions \nfloat capo( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat capt( vec3 p, float h, float r )\n{\n  float q = clamp( p.y, 0.0, h );\n  float i = clamp( h - p.y, .0, h * 1.0 );\n  i *= 1.0-step(.999,i/h);\n  \n  p.y -= q;\n  \n  float n = noise( p * 13. );\n  p *= ( .85 + .15 * n );\n  \n  r += 0.006 * sin( i * 33. * (.8 + .2* n ) );\n  \n  return length( p ) - r * i;\n}\n\nfloat caps( vec3 p, float h, float r )\n{\n  float q = clamp( p.y, 0.0, h );\n  float i = clamp( h - p.y, .0, h * 1.0 );\n  i *= 1.0-step(.999,i/h);\n  \n  p.y -= q;\n  \n  return length( p ) - r * i;\n}\n\n////\n\nfloat starSegmentSDF( vec3 point, vec3 a, float thickness ) {\n    float h = clamp( dot( point - a, - a ) / dot( a, a ), 0., 1. );\n    vec3 q = a - a * h;\n    //h = pow( h, 0.7 ) * .8;      \n    return length( point - q ) - thickness * h;\n}\n\nfloat starSDF( vec3 point, float len, float thickness ) {\n    vec3 a0 = vec3( +0.000 * len, +1.000 * len, .0 ); // @ r:+1.570 , d:90\n    vec3 a1 = vec3( -0.952 * len, +0.309 * len, .0 ); // @ r:+2.827 , d:162\n    vec3 a2 = vec3( -0.588 * len, -0.810 * len, .0 ); // @ r:+4.084 , d:234\n    vec3 a3 = vec3( +0.587 * len, -0.810 * len, .0 ); // @ r:+5.340 , d:306\n    vec3 a4 = vec3( +0.951 * len, +0.309 * len, .0 ); // @ r:+6.597 , d:378\n    \n    float d0 = starSegmentSDF( point, a0, thickness );\n    float d1 = starSegmentSDF( point, a1, thickness );\n    float d2 = starSegmentSDF( point, a2, thickness );\n    float d3 = starSegmentSDF( point, a3, thickness );\n    float d4 = starSegmentSDF( point, a4, thickness );\n\n    return min( d0, min( d1, min( d2, min( d3, d4 ) ) ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// create the scene\n\nvec2 which( in vec2 current, in vec2 test ) {\n    current.y = mix( current.y, test.y, step( test.x, current.x ) );\n    current.x = min( current.x, test.x );\n    return current;\n}\n\nfloat ground( in vec3 point ) {\n    point *= 8.;\n    point.y = .0;\n    return 2. * (\n        +4.50 * noise( point * .01 )\n#ifdef NOISIER_GROUND\n        +0.50 * noise( point * .1 )\n        +0.15 * noise( point * .2 )\n        +0.03 * noise( point * .4 )\n#endif\n    ) + 2.;\n}\n\nvec2 xmasTree( vec3 f, float total, float n ) {\n    vec2 d = vec2( capo( f - VEC3Y( 0.0 ), .50, .04 ), TRUNK );    \n    float r_1 = .41 + .4 * n;\n    float r_2 = .37 + .3 * n;\n    float r_3 = .33 + .3 * n;\n\n#if 1\n    d = which( d, vec2( capt( f - VEC3Y( 0.4 ), .80, r_1 ), BODY  ) ); // bottom\n    d = which( d, vec2( capt( f - VEC3Y( 0.8 ), .61, r_2 ), BODY  ) ); // middle\n    d = which( d, vec2( capt( f - VEC3Y( 1.1 ), .43, r_3 ), BODY  ) ); // top\n#else\n    // meh..\n    float h_1 = total * .45;\n    float h_2 = total * .35;\n    float h_3 = total * .20;\n    float y = .4;\n    float q = 1.6;\n        \n    d = which( d, vec2( capt( f - VEC3Y( y ), h_1 * q, r_1 ), BODY  ) ); // bottom\n    y += h_1;\n    d = which( d, vec2( capt( f - VEC3Y( y ), h_2 * q, r_2 ), BODY  ) ); // middle\n    y += h_2;\n    d = which( d, vec2( capt( f - VEC3Y( y ), h_3 * q, r_3 ), BODY  ) ); // top\n#endif\n        \n    d = which( d, vec2( starSDF( f - VEC3Y( total + .66 ), .13, .04 ), STAR ) );\n    return d;\n}\n\nvec2 simpleTree( vec3 f, float total ) {      \n    return vec2( caps( f - VEC3Y( .3 ), total * 1.4, .35 ), BODY );\n}\n\nvec2 tree( in vec3 point, in float dizzy ) {\n    vec2 d = vec2( RAY_MARCH_TOO_FAR, 0. );\n    \n    //if ( dizzy > TREE_DISTANCE_MAX ) return d;\n\n    // make repetion rate drop off...\n    // not much luck...\n    \n    float dzo = pow( dizzy / TREE_DISTANCE_MAX, 2. ); \n    //float repeat = 3. + floor( dzo * 6. ) ;\n    float repeat = 3. + floor( dzo * 6. * .4 );\n    //float repeat = .25 * floor( mix( 10., 30., dzo ) );\n    //float repeat = 1. + floor( mix( 2., 7., dzo - .2 ) );\n\n    \n    float halb = .5 * repeat;\n    \n    ///////////\n    \n    vec3 f = point;\n    f.xz = mod( f.xz + halb, repeat ) - halb;\n        \n    vec3 i = point - f;\n    \n    float n = noise( i );\n    \n    f.y += ground( i );\n    f.xz -=  n;\n    \n    /////////////\n    \n    float total = 1. + .3 * n;\n    \n    if ( dizzy < TREE_DISTANCE_SIMPLIFY ) {\n        d = which( d, xmasTree( f, total, n ) );\n    } else {\n        d = which( d, simpleTree( f, total ) );\n    }\n    \n    return d;\n}\n\nvec2 sceneDistance( in vec3 point, in float dizzy ) {\n    vec2 d = vec2( RAY_MARCH_TOO_FAR, 0. );\n \n    float g = ground( point );\n    \n    d = which( d, tree( point, dizzy ) );\n    d = which( d, vec2( point.y + g , GROUND ) );\n    \n    float snow = noise( point * 1.2357 );\n    d = which( d, vec2( point.y + g + snow , SNOW ) );\n    \n    return d;\n}\n\nvec2 sceneDistance( in vec3 point ) {\n    return sceneDistance( point, .0 );\n}\n\n\nfloat eq( in float i, in float value ) {  \n    return clamp(1.-step(0.2020,abs(i-floor(value))),0.,1.);\n}\n\nvec3 sceneNormal( in vec3 point ) {\n    return normalize( sceneDistance( point ).x - vec3(\n        sceneDistance( point - RAY_EPSILON.xyy ).x,\n        sceneDistance( point - RAY_EPSILON.yxy ).x,\n        sceneDistance( point - RAY_EPSILON.yyx ).x\n    ));\n}\n\nvec3 colorAt( in vec3 point, vec2 d ) {\n    vec3 color = vec3( .0 );\n    \n    color += RGB( 100,  80,  33 ) * eq( d.y, TRUNK );\n    color += RGB( 180, 255, 180 ) * eq( d.y, BODY );\n    color += RGB( 255, 255, 122 ) * eq( d.y, STAR );\n    color += RGB(  71,  94,  33 ) * eq( d.y, GROUND );\n    color += RGB( 255, 255, 255 ) * eq( d.y, SNOW );\n    \n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// the ray marching bits\n\n\nvec2 rayMarch( in vec3 origin, in vec3 direction ) {\n    vec2 total = vec2( .0 );\n    for ( int i = 0 ; i < RAY_MARCH_STEPS ; i++ ) {\n        vec3 point = origin + direction * total.x;\n        vec2 current = sceneDistance( point, total.x );\n\n#ifdef THANKS_SHANE_FOR_THE_RAY_SHORTENING_SUGGESTION\n        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {\n            break;\n        }\n        // Note: Ray advancement occurs after checking for a surface hit.\n        //\n        // Ray shortening: Shorter for the first few iterations.\n        total.x += i<32? current.x*.35 : current.x*.85; \n        total.y = current.y;\n#else\n        total.x += current.x;\n        total.y = current.y;\n\n        if ( total.x > RAY_MARCH_TOO_FAR || current.x < RAY_MARCH_CLOSE ) {\n            break;\n        }     \n#endif\n\n    }\n    return total;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// lighting\n\nfloat pointLight( vec3 point, vec4 light ) {\n    vec3 normal = sceneNormal( point );\n    \n    vec3 towardLight = light.xyz - point;\n    float toLight = length( towardLight );\n    towardLight = normalize( light.xyz - point );\n\n    float diffuse = clamp( dot( normal, towardLight ), 0., 1. );\n    \n    vec3 lightStart = point + normal * RAY_MARCH_CLOSE * 2.;\n    float d = rayMarch( lightStart, towardLight ).x;\n    diffuse *= 1. - 0.5 * smoothstep( d * 0.9, d, toLight );\n\n    float lightStrength = .2 + .8 * light.w / dot( toLight, toLight );  \n    return diffuse * lightStrength;\n}\n\nvec3 colorPoint( vec3 point, vec3 eye, vec2 d ) {\n    vec4 light    = vec4( eye + vec3(.0,2.,+4.), 8. );\n    float ambient = 0.007;\n    float gamma   = 1.3;\n    \n    float lighting = pointLight( point, light );\n    lighting = ( 1. -  ambient ) * gamma * lighting;\n\n    vec3 color = colorAt( point, d );\n\treturn vec3( color * ambient + color * lighting );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// simple camera\n\nstruct Ray {\n    vec3 eye;\n    vec3 direction;\n};\n\n// from https://github.com/glslify/glsl-look-at\nmat3 makeCamera( vec3 origin, vec3 target, float roll ) {\n\tvec3 up = vec3( sin( roll ), cos( roll ), .0 );\n\tvec3 zz = normalize( target - origin );\n\tvec3 xx = normalize( cross( zz, up ) );\n\tvec3 yy = normalize( cross( xx, zz ) );\n\treturn mat3( xx, yy, zz );\n}\n\nRay cameraRay( in vec2 uv ) {\n#ifdef CAMERA_MOUSE\n    vec2 mx = ( iMouse.xy / iResolution.xy ) -.5;\n    vec2 T = TRIG( 4., mx.x * PI2 );\n    vec2 V = TRIG( 4., mx.y * PI2 * .5 );\n        \n    vec3 eye  = vec3( T.x, mx.y * 4. +2. , T.y );\n    vec3 look = vec3( 0. );\n    \n    float zoom = 1.;\n    float roll = .0;\n#else\n    vec2 T = TRIG( 1., iTime );\n    \n\tvec3  eye  = vec3( 6. * T.x, 2., 6. * T.y );\n\tvec3  look = vec3( .0, 0, .0 );\n    \n    eye = vec3( .3 * T.x, 4. , iTime * 3.);\n    \n    float g = ground( eye );\n    eye.y = 3. - g;\n    \n    look = vec3( .0, eye.y, eye.z + 2. );\n    \n\tfloat roll = 0.0002 * T.x; // TODO: stars need to match..\n    float zoom = 1.2;\n    \n    //roll = .0;\n#endif\n    \n\tmat3 camera = makeCamera( eye, look, roll );\n    vec3 direction = normalize( camera * vec3( uv.xy, zoom ) );\n\n    return Ray( eye, direction );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// main function\n\nvec3 mainly( in vec2 fragCoord ) {\n\tvec2 uv = ( 2. * gl_FragCoord.xy - iResolution.xy ) / iResolution.y; \n    Ray ray = cameraRay( uv );\n\n    //ray.eye += noise( vec3(uv,.0) ); /// lol, xmas nightmare mode\n    ray.eye += 0.1 * noise( vec3(uv,uv.x*uv.y) );\n    vec2 d = rayMarch( ray.eye, ray.direction );\n    \n    float tooFar = step( RAY_MARCH_TOO_FAR, d.x );\n    vec3 point = ray.eye + ray.direction * d.x;\n    \n\t// the end\n    \n    float star = .5 + noise( 333.444 * vec3( uv, 0. ) );\n    float twinkle = 5. * ( .5 + noise( 22.22 * vec3( uv, 0. ) ) );\n    star = smoothstep( .9 + .05 * sin( iTime * twinkle ), 1., star );\n    \n    vec3 background = vec3( star );\n    vec3 color = colorPoint( point, ray.eye, d );\n\n    vec3 fog = vec3( 0.3 );\n    vec3 fogged_background = mix( background, fog, 0.6 );\n    vec3 fogged_color = mix( color, fog, pow( d.x / RAY_MARCH_TOO_FAR, .7  )  );\n    return mix( fogged_color, fogged_background, tooFar );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4( mainly( fragCoord ), 1. );\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////////////","name":"Image","description":"","type":"image"}]}