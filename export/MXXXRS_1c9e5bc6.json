{"ver":"0.1","info":{"id":"MXXXRS","date":"1709650018","viewed":119,"name":"Fork Glass Cube OKLCH","username":"mehow_one","description":"I was curious to see how dispersion would look like with the OKLCH color model. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","refraction","reflections","translucency","dispersion"],"hasliked":0,"parentid":"WdBBz3","parentname":"Glass Cube With Dispersion"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//June 21, 2020: Added chromatic abberation\n\n#define ABSORBTION \t\t\t\tvec3(0.03)\n#define IOR \t\t\t\t\t1.5\n#define DISPERSION \t\t\t\t0.09\n#define CHROMATIC_ABBERATION\t0.02\n\n#define TIMESCALE 0.35\n#define INTERNAL_REFLECTIONS 4\n#define SAMPLES 30.0\n\n\n#define rot2(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n\nvec3 rotate ( vec3 p, vec3 r ) {\n    p.yz *= rot2(r.x);\n    p.xz *= rot2(-r.y);\n    p.xy *= rot2(r.z);\n    return p;\n}\n\n\nfloat InteriorCubeReflection ( vec3 ro, vec3 rd ) {\n    vec3 d = (0.5*sign(rd)-ro)/rd;\n    return min( min(d.x, d.y), d.z );\n}\n\n\nfloat IntersectCube ( vec3 ro, vec3 rd ) {\n    float dfront = -InteriorCubeReflection(-ro,rd);\n    float dback  = InteriorCubeReflection(ro,rd);\n    return dback>=dfront ? dfront : -1.0;\n}\n\n\nfloat GetReflectance ( vec3 i, vec3 t, vec3 nor, float iora, float iorb ) {\n    vec2 c = nor * mat2x3(i,t);\n    vec2 ior = vec2(iora,iorb);\n    vec2 sp = ( mat2(c,-c.yx)*ior ) / ( mat2(c,c.yx)*ior );\n    return dot(sp,sp)/2.0;\n}\n\n\nvec3 GetSky ( vec3 rd ) {\n    float v = dot(rd, vec3(0.5,-0.15,0.85));\n    v = smoothstep(-0.05, 0.05, sin(v*50.0));\n    return vec3( v  );\n}\n\n\nvec3 GetDispersedColor( float w ) {\n\n     vec3 p = vec3(1.,1.,w);\n     return max(lch2rgb(p),0.);\n\n\n    //return max( sin( ( w - vec3(0.0,0.25,0.5) ) * 6.28318531 ), 0.0);\n    /*\n    vec3 s = vec3(0.9, 1.0, 0.8);\n    vec3 c = w - vec3( 0.0, 0.25, s.b-0.5 );\n    c = clamp(c*s, 0.0, 1.0) * 6.28318531;\n    c = sin(c) * s;\n    return max( c, 0.0);\n\t*/\n}\n\n\nvec3 GetRenderSample ( vec3 ro, vec3 rd, float df ) {\n\tfloat rl = IntersectCube( ro, rd );\n    \n    if ( rl > 0.0 ) {\n        \n        float iord = IOR + DISPERSION*(df-0.5);\n        \n        vec3 xyz = ro + rd*rl;\n        vec3 nor = round( xyz*1.00001 );\n        vec3 power = vec3(1.0);\n        vec3 refractd = refract( rd, nor, 1.0/iord );\n        vec3 reflectd = reflect( rd, nor );\n        float refl = GetReflectance ( rd, refractd, nor, 1.0, iord );\n        vec3 c = GetSky(reflectd) * refl;\n        power *= 1.0-refl;\n        rd = refractd;\n\n        for ( int i=0; i<INTERNAL_REFLECTIONS; i++ ) {\n        \trl = InteriorCubeReflection( xyz, rd );\n        \txyz += rd*rl;\n            nor = round( xyz*1.00001 );\n        \trefractd = refract( rd, -nor, 1.0/iord );\n        \treflectd = reflect( rd, -nor );\n        \trefl = GetReflectance ( rd, refractd, -nor, iord, 1.0 );\n        \tpower *= exp( -ABSORBTION * rl );\n            c += GetSky(refractd) * (1.0-refl) * power;\n            power *= refl;\n            rd = reflectd;\n        }\n        return c;\n    } else {\n            return vec3(0.);\n           //return GetSky(rd);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy) / iResolution.x;\n    \n    vec3 col = vec3(0.0);\n    for ( float f = 0.0; f<SAMPLES; f++ ) {\n        float w = f/SAMPLES;\t\t// wavelength sample ( 0 => 1 across visible spectrum )\n        \n        float b = (fract(f*134.102119) - 0.5) / 60.0;\t\t\t\t\t\t\t//temporal offset for motion blur\n        vec2 aa = (fract((f+uv)*134.102119+iTime)-0.5)/iResolution.x*3.0;\t\t//quick and sloppy positional offset for aa\n        \n        vec3 cp = vec3( aa, -2.5);\n        vec3 cr = normalize( vec3(uv,1.0+w*CHROMATIC_ABBERATION) );\n    \tcp = rotate( cp, vec3( (iTime + b) * TIMESCALE ) );\n        cr = rotate( cr, vec3( (iTime + b) * TIMESCALE ) );\n        \n        vec3 c = GetRenderSample( cp, cr, w );\n        \n        vec3 sp = GetDispersedColor(w);\n    \tcol += c * sp;\n    }\n    col /= SAMPLES/3.0;\n    \n    col = smoothstep(0.0, 1.0, col);\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979323846;\n\n//see link in description for the source of those transfer function\nfloat transfer(float v) {\n    return v <= 0.0031308 ?12.92 * v : 1.055 *pow(v, 0.4166666666666667) - 0.055;\n}\n\nvec3 transfer(vec3 v) {\n    return vec3(transfer(v.x), transfer(v.y), transfer(v.z));\n}\n\n// slightly rearranged vector components so it matches with LCH\nvec3 lch2rgb(vec3 lch) {\n    lch.y *= 0.33;\n    \n    vec3 lab = vec3(\n        lch.x,\n        lch.y * cos(lch.z * PI*2.0),\n        lch.y * sin(lch.z * PI*2.0)\n    );\n    \n    vec3 lms = vec3(\n        lab.x + 0.3963377774f * lab.y + 0.2158037573f * lab.z,\n        lab.x - 0.1055613458f * lab.y - 0.0638541728f * lab.z,\n        lab.x - 0.0894841775f * lab.y - 1.2914855480f * lab.z\n    );\n    \n    lms = pow(max(lms, vec3(0.0)), vec3(3.0));\n    \n    vec3 rgb = vec3(\n        +4.0767416621f * lms.x - 3.3077115913f * lms.y + 0.2309699292f * lms.z,\n        -1.2684380046f * lms.x + 2.6097574011f * lms.y - 0.3413193965f * lms.z,\n        -0.0041960863f * lms.x - 0.7034186147f * lms.y + 1.7076147010f * lms.z\n    );\n     \n    rgb = transfer(rgb);\n    return rgb;\n}","name":"Common","description":"","type":"common"}]}