{"ver":"0.1","info":{"id":"MtKXRD","date":"1483408459","viewed":92,"name":"raymarching fun krwq","username":"krwq","description":"raymarching fun krwq","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingfunkrwq"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on jlfwong's tutorial https://www.shadertoy.com/view/llt3R4\n// some functions stolen from iq\n\n#define pi 3.14159265359\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat opS(float d1, float d2) {\n    return max(-d2, d1);\n}\n\nfloat opU(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nmat3 rotx(float angle) {\n    return mat3(1.,          0.,         0.,\n                0.,  cos(angle), -sin(angle),\n                0.,  sin(angle),  cos(angle));\n}\n\nmat3 roty(float angle) {\n    return mat3( cos(angle), 0., sin(angle),\n                 0,          1., 0.,\n                -sin(angle), 0., cos(angle));\n}\n\nmat3 rotz(float angle) {\n    return mat3( cos(angle), sin(angle), 0.,\n                -sin(angle), cos(angle), 0.,\n                         0.,         0., 1.);\n}\n\nfloat map(vec3 p) {\n    p = rotz(sin(2. * pi * iTime / 17.) * 0.7) * p;\n    float ret = sphereSDF(p, 0.7);\n    ret = opU(ret, sphereSDF(roty(2. * pi * iTime / 4.) * p - vec3(.9, 0., 0.), 0.4));\n    return ret;\n}\n\nvec3 normal(in vec3 pos) {\n    /*float eps = 0.001;\n    return normalize(vec3(map(pos + vec3(eps,   0,   0)).x - map(pos - vec3(eps,   0,   0)).x,\n                          map(pos + vec3(  0, eps,   0)).x - map(pos - vec3(  0, eps,   0)).x,\n                          map(pos + vec3(  0,   0, eps)).x - map(pos - vec3(  0,   0, eps)).x));/* */\n    vec2 e = vec2(1.0,-1.0) * EPSILON;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n                      e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  \n                      e.xxx*map( pos + e.xxx ));/* */\n\n}\n\n\nfloat shortestDistanceToSurface(vec3 ro, vec3 rd, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = map(ro + depth * rd);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat cartoonEffect(float c, float n) {\n    return floor(c * n) / n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);    \n   \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 n = normal(eye + dir * dist);\n    \n    vec3 color;\n    //color = vec3(1., 0., 0.);\n    color = rotz(2. * pi * iTime / 11.) * rotx(2. * pi * iTime / 7.) * n;\n    fragColor = vec4(n, 1.);\n    //fragColor = vec4(0.8 * color * dot(n, -dir), 1.0);\n    fragColor = vec4(cartoonEffect(0.8 * dot(n, -dir), 30. * 0.5 * (1.0 + sin(2. * pi * iTime / 10.))) * color, 1.0);\n}","name":"Image","description":"","type":"image"}]}