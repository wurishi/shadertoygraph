{"ver":"0.1","info":{"id":"llSSWt","date":"1447252588","viewed":373,"name":"Gathering","username":"gaz","description":"3d","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI  3.14159265359\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// iq's function\nfloat smin( float a, float b )\n{\n    float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// https://www.shadertoy.com/view/4tX3DS\nvec2 fold(in vec2 p, in float a)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(cos(a), sin(a));\n    for(int i = 0; i < 5; i++)\n    {\n        p -= 2.0 * min(0.0, dot(p, v)) * v;\n        v = normalize(vec2(v.x - 1.0, v.y));\n    }\n    return p;    \n}\n\nvec2 sfold(in vec2 p, in float a)\n{\n    p.x = abs(p.x);\n    vec2 v = vec2(cos(a), sin(a));\n    for(int i = 0; i < 5; i++)\n    {\n        // a very subtle smooth minimum ?\n        p -= 2.0 * smin(0.0, dot(p, v)) * v;\n        v = normalize(vec2(v.x - 1.0, v.y));\n    }\n    return p;    \n}\n\nfloat map(in vec3 p)\n{   \n    int type = 0;\n    if (p.x > 0.0) type = 1;\n    p.yz *= rotate(iTime * 0.1);\n    p.zx *= rotate(iTime * 0.05);\n\tif (type == 0)\n    {\n\t    p.xy = fold(p.xy, PI / 2.0);\n    } else {\n    \tp.xy = sfold(p.xy, PI / 2.0);\n        \n    }\n    p.z = abs(p.z) - 0.5;\n    p.z = abs(p.z) - 0.8;\n    p.z = abs(p.z) - 0.7;\n    p.z = abs(p.z) - 0.5;\n    p.z += sin(length(p.xy) * 1.5 + iTime * 2.0) * 0.15;\n    p.y += iTime * 0.5;\n    p.y = mod(p.y, 0.4) - 0.2;\n    return length(p) -  0.1;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 35.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis || t > maxd) break;\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(length(p) * 0.1);\n    col.b += 0.05;\n    vec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 rd = normalize(vec3(p, -1.8));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    \tcol = vec3(0.8, 0.1, 0.1);\n        col *= max(dot(li, nor), 0.2);\n        col += pow(max(dot(vec3(0, 0, 1), reflect(-li, nor)), 0.0), 30.0);\n        col = pow(col, vec3(0.8)); \n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}