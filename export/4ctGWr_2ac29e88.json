{"ver":"0.1","info":{"id":"4ctGWr","date":"1711752348","viewed":57,"name":"FlockDataBird","username":"Plastic","description":"Flock simulator, a new take on the boids algorithm.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["algorithm","boids"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotation(vec2 v, float a)\n{\n    mat2 rotation = mat2(\n    cos(a), -sin(a),\n    sin(a), cos(a));\n    \n    return rotation*v;\n}\n\nfloat triang(vec2 uv, vec2 c, float s, vec2 dir)\n{\n    \n    const float pi = 3.141592653589793;\n    \n    vec2 v;\n\n    if(dir.x < .0)\n    {\n        v = rotation(uv-c, atan(dir.y/dir.x)+2.*pi)+c;\n    }\n    else\n    {\n        v = rotation(uv-c, atan(dir.y/dir.x)+pi)+c;\n    }\n    \n    float trig = (v.y>-0.25*s+c.y && v.y<2.*(v.x-c.x)+0.5*s+c.y && v.y<-2.*(v.x-c.x)+0.5*s+c.y) ? 1.0 : .0;\n    \n    return trig;\n}\n\nvec3 torender(vec2 uv)\n{\n\n    vec2 birds[count];\n    \n    vec3 final = vec3(.0);\n    for(int a = 0; a<birds.length(); a++)\n    {\n        birds[a] = texelFetch(iChannel0, ivec2(a, 0), 0).xy;\n        \n        vec2 dir = texelFetch(iChannel0, ivec2(a, 0), 0).zw;\n        \n        vec3 current = vec3(triang(uv, birds[a], 0.5, -vec2(-dir.y, dir.x) ));\n        final += current;\n    }\n    \n    return vec3(uv, 1.)*clamp(final, .0, 1.);\n    //return final;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 img = torender(uv*6.);\n    \n    //int decode = int(floor(decodeuv.x*40.));\n\n    //fragColor = vec4(vec2(randir(uv*10., iDate.w)), .0, 1.0);\n    fragColor = vec4(img, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 samplenoise(vec2 uv)\n{\n    return texture(iChannel2, uv).xy;\n\n}\n\nvoid randstart(inout vec2 birdpos[count])\n{\n    for(int i = 0; i<birdpos.length(); i++)\n    {\n        float godi = float(i)+iDate.w*14.;\n        float randx = sin(136.*cos(176.*cos(godi)))*5.;\n        float randy = cos(867.*cos(526.*sin(godi)))*5.;\n        \n        birdpos[i] = vec2(randx, randy);\n    }\n}\n\nvoid poscalc(inout vec2 birdpos[count], in float speed, inout vec2 look[count])\n{   \n    for(int i = 0; i<birdpos.length(); i++)\n    {\n        \n        birdpos[i] = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        \n        vec2 oldpos = birdpos[i];\n        \n        vec2 dir = vec2(.0);\n        \n        for(int a = 0; a<birdpos.length(); a++)\n        {\n        \n            if(a != i)\n            {\n                \n                vec2 change = normalize(birdpos[a]-birdpos[i]);\n                \n                vec2 align = (vec2(.0)-birdpos[i]);\n                \n                vec2 currentdir = -change*6.+align;\n                \n                dir += currentdir*speed;\n               \n            }\n        }\n        \n        //dir /= float(birdpos.length());\n        dir /= 20.;\n        \n        vec2 align = (vec2(.0)-birdpos[i]);\n        \n        vec2 will = samplenoise((birdpos[i]*0.5+0.5)*0.05);\n        \n        birdpos[i] += dir+will*0.05;\n        \n        look[i] = normalize(oldpos - birdpos[i]);\n        \n    }\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ub = ivec2(fragCoord);\n   \n    vec2 birdpos[count];\n    vec2 look[count];\n    \n    if(iFrame < 1)\n    {\n        randstart(birdpos);\n    }\n    else\n    {\n        poscalc(birdpos, 0.009, look);\n    }\n    \n    fragColor = vec4(vec2(birdpos[ub.x]), look[ub.x].x, look[ub.x].y);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec2 randir(vec2 uv, float off)\n{\n    return vec2( sin(4.+32.*cos(25.*sin(uv.x+uv.x+uv.y-uv.x*3.+off))),\n                 sin(5.+83.*sin(25.*cos(uv.x+uv.y+uv.y-uv.x*3.+off))));\n\n}\n\nvec2 powermix(vec2 a, vec2 b, float t)\n{\n    return (-pow(t, 1.)+1.)*a+pow(t, 1.)*b;\n}\n\nvec2 noise(vec2 uv, float off, float res)\n{\n    vec2 smoothgrid = fract(uv*res);\n    vec2 samplegrid = floor(uv*res)/res;\n    \n    vec2 randirbl = randir(samplegrid, off);\n    vec2 randirbr = randir(samplegrid + vec2(1./res, .0), off);\n    vec2 randirtl = randir(samplegrid + vec2(.0, 1./res), off);\n    vec2 randirtr = randir(samplegrid + vec2(1./res), off);\n    \n    return powermix(powermix(randirbl, randirbr, smoothgrid.x), powermix(randirtl, randirtr, smoothgrid.x), smoothgrid.y);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 final = noise(uv, iDate.w*0.002, 16.);\n\n    fragColor = vec4(final.xy, .0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define count 35","name":"Common","description":"","type":"common"}]}