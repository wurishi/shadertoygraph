{"ver":"0.1","info":{"id":"3lBSWK","date":"1571609221","viewed":538,"name":"FFT fluid 2 for 1","username":"rory618","description":"Using one complex fft to compute two real fft's to have extra buffer space left over. X and C to control diffusion and length restoring\n","likes":28,"published":1,"flags":48,"usePreview":0,"tags":["fluid","diffusion","advection","fourier","multipass","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"FFT Fluid - analysis rory618 cod\" by FabriceNeyret2. https://shadertoy.com/view/tdfSR4\n// 2019-08-28 23:39:56\n\n// Fork of \"FFT Fluid\" by rory618. https://shadertoy.com/view/wdBGWG 2019-02-20 16:36:17\n\n// Data structure, Fourier-block calculation, fluid simulation:\n// see my comments in Common.\n\n// [ original rory618 comments, in their full mystery :-) ]\n// Four step seperated FFT, factored horizontally, vertically, and over major and minor axis for each of x and y\n// Total worst case for 2048*2048 image is 2 (x and y) times 4 (factored into 4) 32pt dft's where each pixel/thread \n// must compute one bin of its corresponding dft. Pipelining through A-B-C-D means fft of the whoe screen only takes one frame.\n// Both the x and y of the feild need to be fft'd so it takes up all 4 channels to do an fft, so every other frame\n// the fft direction is swapped to compute the inverse, and overall the simulation runs at one step per two frames\n\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = vec4(0);\n    if(FFT_DIR==BACKWARD){\n        if (keypressed(32)) discard;\n        vec4 t0 = texture(iChannel1, I/R.xy); // --- display fluid\n        O = vec4(.25*log(1.+length(t0))); // fake content\n    } else {\n        if (!keypressed(32))  discard;\n    \tO = texture(iChannel1, .5+I/R.xy);    // --- display Fourier\n        float l0 = dot2(O.xy); O.xy *= log(1.+l0) / l0;\n        float l1 = dot2(O.zw); O.zw *= log(1.+l1) / l1;\n        O = abs(O);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Data structure:\n\n//   O.xy contains either fluid v over space or V, the fourier transform of vx + j vy\n//   The fourier transform X of fluid velocity x and Y can be extracted from V, see\n//   http://www.robinscheibler.org/2013/02/13/real-fft.html\n//   Essentially the x is a purely real signal, y is purely imaginary, so the even and odd \n//   parts of the spectrum are X and Y\n\n\n// Fourier calculation:\n\n// - one 2D fourier on x + j y\n// - 2D Fourier = Fy(Fx(image)): BufA,B do Fx, BufC,D do Fy\n// - 1D Fourier is done by incomplete FFT: Cooley-Tukey on DFT blocks\n//   - Data structure:\n//       Buf A,B = N0x horizontal blocks of size N1x (NO.N1 = R)\n//                 equiv to array(N0x,N1x)\n//       Buf C,D = N0y vertical blocks of size N1y \n//                 equiv to array(N0y,N1y)\n//   - Algo:\n//       Buf A,C : DTF along N0\n//       Buf B,D : DTF along N1\n\n\n// Fluid calculation:\n\n// Forward:  (odd frames)\n// - advect velocity (bufA) \n// - Fourier transform V (BuffA,B,C,D) -> ^V\n// - apply mass conservation + viscosity in Fourier, see Jos Stam paper http://www.dgp.toronto.edu/people/stam/reality/Research/pdf/jgt01.pdf\n// - display only if Fourier required (Image)\n// Backward: (even frames)\n// - Fourier transform ^V (BuffA,B,C,D) -> V\n// - Apply forces (mouse control) (BuffD)\n// - display fluid (density faked from velocity turbulent features) (Image)\n\n#define viscosity 1e-5 // 1e-7: turbulent 1e-5: some diffusion\n\n#define pi 3.14159265\n#define R  iResolution\n#define iR ivec3(R)\n#define T(x,y) texelFetch(iChannel0, ivec2(x,y), 0)\n#define keypressed(c) (texelFetch(iChannel2,ivec2(c,2),0).x > .5)\n\n// --- (i)FFT sum on blocks\n                            // FFT vs iFFT at even vs odd frame\n#define FFT_DIR float((iFrame%2)*2-1)\n#define FORWARD 1.\n#define BACKWARD -1.\n                             // exp( s* 2iPi k/N )\n#define W(k,n) cexp(vec2(0,FFT_DIR*(2.*pi*float(k)/float(n))))\n\n/**/\n                             // partial DFT on blocks\n#define SUM(v,n0,n2, V)                  \\\n    setRadix(R);                         \\\n    int x = int(I.x),                    \\\n        y = int(I.y),                    \\\n        n = v/n0;  v = v%n0;             \\\n    O = vec4(0);                         \\\n    for(int i = 0; i < 64; i++){         \\\n        if (i >= n2) break;              \\\n        vec2 w = W(i*n,n2);              \\\n        O.xy += cprod(V,w);              \\\n    }\n/**\nvec2 sum;                    // sum(expr) on blocks\n#define SUM(expr, ind, len)            \\\n    sum = vec2(0);                     \\\n    for(int ind = 0; ind < 64; ind++){ \\\n        if (ind >= len) break;         \\\n        sum += expr;                   \\\n    }\n/**/\n\n// --- radix calculation:\n// partial FFT on blocks N1,N2 close to sqrt(R) with N1.N2=R\n// more understanding needed (e.g. N1,N2 vs 64)\n// See https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm\n\nint x_N0, x_N1,\n    y_N0, y_N1;\n\nint factor(float x){ // find largest f<sqrt(x) such that f*g = x\n    int i = int(x),  // (isn't it costly to do that for each pixel*frame*buffer ?)\n        f = int(sqrt(x));\n    while( i % f > 0 ) f--;\n    return f;\n  //return float(i)/float(f);\n}\n\nvoid setRadix(vec3 R){  \n    x_N0 = factor(R.x);\n    y_N0 = factor(R.y);\n    x_N1 = int(R.x)/x_N0;\n    y_N1 = int(R.y)/y_N0;\n    \n}\n\n// --- complex arithmetics\n\nvec2 cprod(vec2 a, vec2 b){\n    return mat2(a,-a.y,a.x) * b;\n}\n\nvec2 cis(float t){\n    return cos(t - vec2(0,pi/2.));\n}\nvec2 cexp(vec2 z) {\n    return exp(z.x)*cis(z.y);\n}\n\nfloat dot2(vec2 x) { return dot(x,x); }\n\n// --- random numbers\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn float(a) / float(0x7FFFFFFF);\n}\n\n#define Ihash3(x,y,z) IHash((x)^IHash((y)^IHash(z)))\n    \nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// apply advection and proceed 1st step of block-FFTx\n\nfloat ln (vec2 p, vec2 a, vec2 b) { // returns distance to line segment for mouse input\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\nvec2 inp(int x, int y);\nvoid mainImage( out vec4 O, vec2 I ) // --- block-FFTx\n{\n    SUM( x, x_N1, x_N0, inp( x+i*x_N1, y ) );\n    \n    O.xy = (cprod(O.xy, W(x*n,iR.x)));\n    if(FFT_DIR==FORWARD){\n    \tif(I.x<1.){O.zw = iMouse.xy;} else {O.zw = iMouse.zw;}\n    } else {\n        O.zw = texture(iChannel1, I/R.xy).zw;\n    }\n}\n\n\nvec2 inp(int x, int y){\n    vec2 I = vec2(x,y);\n    if(FFT_DIR==FORWARD){ // space domain: --- apply advection and mouse forces\n        vec2 v = T(x, y).xy;                 \n        v = texture(iChannel0,mod(( vec2(x, y) -v/2. + rand2(Ihash3(x,y,iFrame)) ) / R.xy,1. )).xy;\n        \n        vec4 mo = texture(iChannel1,vec2(10));\n        mo.xy = texture(iChannel1,vec2(0)).zw;\n        float l = ln(I,iMouse.xy,mo.xy);\n        if (iMouse.z > 0. && mo.z > 0.) v = mix(v,6.*vec2((R.y/20.-l)*(iMouse.xy-mo.xy)/R.y),1./(1.+l*l/90.));\n        if(iResolution.y<250.)\n       \t\tv += .01*(R.xy*.5)*exp(-.1/(1.+length(I-R.xy*.5))*dot2(I-R.xy*.5));\n        //if(length(v)>40.){ v *= 40./length(v);}\n        return v;\n    } else {// fourier domain: --- apply diffusion and conservation of mass\n        vec2 C = vec2(x,y);\n        if(C.x>(R.x/2.)) C.x-=(R.x);\n        if(C.y>(R.y/2.)) C.y-=(R.y);\n        \n        vec2 a = T(x, y).xy;\n        vec2 b = T((int(R.x)-x)%int(R.x), (int(R.y)-y)%int(R.y)).xy * vec2(1,-1);\n        \n        //Extract the even and odd parts of FFT(x + j y) to get X and Y\n        vec2 X = (a + b)/2.;\n        vec2 Y = cprod(vec2(0,-1),(a - b)/2.);\n        \n        vec2 xyr = vec2(X.x,Y.x);\n        vec2 xyi = vec2(X.y,Y.y);\n        float lx = length(xyr),\n              ly = length(xyi);\n\t\tif(length(C)>0.5 && iFrame > 8) {\n        \txyr-=dot(normalize(C),xyr)*normalize(C);\n        \txyi-=dot(normalize(C),xyi)*normalize(C);\n        } else {\n            xyr *= 0.;\n            xyi *= 0.;\n        }\n        if (!keypressed(67)) {              // C\n        \txyr *= lx / (1e-3+length(xyr));\n        \txyi *= ly / (1e-3+length(xyi));\n        }\n        if (!keypressed(88)) {\n            xyr*=exp(-dot2( C )*viscosity);\n            xyi*=exp(-dot2( C )*viscosity);\n        }\n        X = vec2(xyr.x,xyi.x);\n        Y = vec2(xyr.y,xyi.y);\n        \n        return X + cprod(vec2(0,1),Y);\n        \n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// proceed 2nd step of block-FFTx\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    SUM( x, x_N0, x_N1, T( x*x_N1+i, y ).xy );\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// proceed 1st step of block-FFTy\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    SUM( y, y_N1, y_N0, T( x, y+i*y_N1 ).xy );\n    \n    O.xy = (cprod(O.xy, W(y*n,iR.y)));\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// proceed 2nd step of block-FFTy\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    SUM( y, y_N0, y_N1, T( x, y*y_N1+i ).xy );  // --- block-FFTy\n    \n    O /= sqrt(R.x*R.y);\n    \n    \n    \n    if(iFrame<6 && FFT_DIR==BACKWARD) // --- init\n        O=vec4(0);\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}