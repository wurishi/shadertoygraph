{"ver":"0.1","info":{"id":"4l3BDr","date":"1541859266","viewed":94,"name":"TPblob_Peuriere_Romain","username":"p1707721","description":"Modélisation d'un pneu en surfaces implicites","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["blob"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Peuriere Romain\n\nconst int Steps = 1000;\nconst float Epsilon = 0.05; // Marching epsilon\nconst float T=0.5;\n\nconst float rA=10.0; // Maximum ray marching or sphere tracing distance from origin\nconst float rB=40.0; // Minimum\n\n// Transforms\nvec3 rotateX(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nvec3 rotateZ(vec3 p, float a)\n{\n  float sa = sin(a);\n  float ca = cos(a);\n  return vec3(ca*p.x + sa*p.y, -sa*p.x + ca*p.y, p.z);\n}\n\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n  float x = clamp(r/R,0.0,1.0);\n  float y = (1.0-x*x);\n  return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n    return e*falloff(length(p-c),R);\n}\n\n// Segment skeleton\n// p : point\n// c1 : 1st extremity of skeleton\n// c2 : 2nd extremity of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat segment(vec3 p, vec3 c1, vec3 c2, float e, float R)\n{\n    vec3 unitVec = normalize(c2-c1);\n    \n    float val;\n    \n    float projectedDistance = dot((p-c1),unitVec);\n    if (projectedDistance<0.0){\n    \tval = length(p-c1); \n    }else if (projectedDistance>length(c1-c2)){\n     \tval = length(p-c2);   \n    }else{\n    \tval = sqrt(length(p-c1) * length(p-c1) - projectedDistance * projectedDistance);   \n    }\n    return e*falloff(val,R);\n}\n\n// Disc skeleton\n// p : point\n// center : center of the disc\n// n : normal to the disc\n// discRadius : disc radius\n// e : energy associated to skeleton\n// R : large radius\nfloat disc(vec3 p, vec3 center, vec3 n, float discRadius, float e, float R)\n{\n    float distanceToCenter = length(center-p);\n    \n    n = normalize(n); // disc normal\n    float verticalDistance = dot((p-center),n);\n    float horizontalDistance = sqrt(distanceToCenter*distanceToCenter - verticalDistance*verticalDistance);\n    \n    float val;\n    if (horizontalDistance<discRadius){\n        val = abs(verticalDistance);\n    }else{\n     \tval = sqrt( (horizontalDistance-discRadius)*(horizontalDistance-discRadius) + verticalDistance*verticalDistance);    \n    }\n    \n    return e*falloff(val,R);\n}\n\n// Torus skeleton\n// p : point\n// center : center of the Torus\n// n : normal to the Torus\n// discRadius : Torus radius\n// e : energy associated to skeleton\n// R : large radius\nfloat torus(vec3 p, vec3 center, vec3 n, float discRadius, float e, float R)\n{\n    float distanceToCenter = length(center-p);\n    \n    n = normalize(n); // disc normal\n    float verticalDistance = dot((p-center),n);\n    float horizontalDistance = sqrt(distanceToCenter*distanceToCenter - verticalDistance*verticalDistance);\n    \n    float val = sqrt( (horizontalDistance-discRadius)*(horizontalDistance-discRadius) + verticalDistance*verticalDistance);    \n    \n    \n    return e*falloff(val,R);\n}\n\n// Cube skeleton\n// p : point\n// pmin : lower point of the cube\n// pmax : upper point of the cube\n// e : energy associated to skeleton\n// R : large radius\nfloat cube(vec3 p, vec3 pmin,vec3 pmax, float e, float R) \n{\n  float dx = max(0.0 , max(pmin.x - p.x, p.x - pmax.x));\n  float dy = max(0.0 , max(pmin.y - p.y, p.y - pmax.y));\n  float dz = max(0.0 , max(pmin.z - p.z, p.z - pmax.z));\n  \n  float val = sqrt(dx*dx + dy*dy + dz*dz);    \n  return e*falloff(val,R);\n}\n\n// Plan skeleton\n// p : point\n// c1 : 1st extremity of the plan diagonal\n// c2 : 2nd extremity of the plan diagonal\n// n : normal to the plan\n// e : energy associated to skeleton\n// R : large radius\nfloat plan(vec3 p, vec3 c1, vec3 c2, vec3 n, float e, float R)\n{\n    //float v = plan(p, vec3(-2,-2,0), vec3(2,2,0), vec3(0,0,1),1.0, 2.0);\n    vec3 c3,c4;\n    \n    vec3 diag = normalize(c2-c1);\n\n    c3 = c1 + 0.5 * (c2-c1) + 0.5 * length(c2-c1) * normalize(cross(diag,n)); // corner right\n    c4 = c1 + 0.5 * (c2-c1) - 0.5 * length(c2-c1) * normalize(cross(diag,n)); // corner left\n    \n    \n    vec3 unitVec1 = normalize(c3-c1);\n    vec3 unitVec2 = normalize(c4-c1);\n    \n    n = normalize(n);\n    \n    float val;\n    \n    float projectedDistance1 = dot((p-c1),unitVec1);\n    float projectedDistance2 = dot((p-c1),unitVec2);\n    \n    if (projectedDistance1<0.0){\n         if (projectedDistance2<0.0){\n    \t\tval = length(p-c1); \n         }else if (projectedDistance2>length(c1-c4)){\n            val = length(p-c4);\n         }else{\n            val = sqrt(length(p-c1) * length(p-c1) - projectedDistance2 * projectedDistance2);\n         }\n    }else if (projectedDistance1>length(c1-c3)){\n         if (projectedDistance2<0.0){\n    \t\tval = length(p-c3); \n         }else if (projectedDistance2>length(c3-c2)){\n            val = length(p-c2);\n         }else{\n            val = sqrt(length(p-c3) * length(p-c3) - projectedDistance2 * projectedDistance2);\n         }\n    }else{\n         if (projectedDistance2<0.0){\n    \t\tval = sqrt(length(p-c1) * length(p-c1) - projectedDistance1 * projectedDistance1);\n         }else if (projectedDistance2>length(c1-c4)){\n            val = sqrt(length(p-c4) * length(p-c4) - projectedDistance1 * projectedDistance1);\n         }else{\n            float projectedDistance3 = dot((p-c1),n);\n            val = abs(projectedDistance3);\n         }\n    \t   \n    }\n    return e*falloff(val,R);\n}\n\n// Triangle skeleton\n// p : point\n// c1 : 1st extremity of the triangle\n// c2 : 2nd extremity of the triangle\n// c3 : 3rd extremity of the triangle\n// n : normal to the plan\n// e : energy associated to skeleton\n// R : large radius\nfloat triangle(vec3 p, vec3 c1, vec3 c2, vec3 c3, float e, float R)\n{\n    vec3 n = normalize(cross((c2-c1),(c3-c1)));\n                       \n    vec3 unitVec1 = normalize(c2-c1);\n    vec3 unitVec2 = normalize(c3-c1);\n    vec3 unitVec3 = normalize(c3-c2);\n\n    float val;\n    \n    float sign1 = (p.x - c2.x) * (c1.y - c2.y) - (c1.x - c2.x) * (p.y - c2.y);\n    float sign2 = (p.x - c3.x) * (c2.y - c3.y) - (c2.x - c3.x) * (p.y - c3.y);\n    float sign3 = (p.x - c1.x) * (c3.y - c1.y) - (c3.x - c1.x) * (p.y - c1.y);\n    \n    \n    if(sign1>=0.0 && sign2>=0.0 && sign3>=0.0){\n        val = abs(dot((p-c1),n));\n    }else{\n        val = 10000.0;\n    }\n    return e*falloff(val,R);\n                       \n}\n                       \n                       \n    \n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n    return a+b;\n}\n\n// Union\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Union(float a,float b)\n{\n    return max(a,b);\n}\n\n// Intersection\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Intersection(float a,float b)\n{\n    return min(a,b);\n}\n\n// Without\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Without(float a,float b)\n{\n    return min(a,2.0*T - b);\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n  \tp.z=-p.z;\n    // Point non tournant pour le plan\n    vec3 pold = p;\n    // Rotation du pneu\n    p = rotateZ(p,iTime*4.0);\n    \n    //PNEU\n    \n    //torus principal\n    float v = torus(p, vec3(0,0,-0.5), vec3(0,0,1), 3.5, 1.0, 2.0);\n    v = Blend(v,torus(p, vec3(0,0,+0.5), vec3(0,0,1), 3.5, 1.0, 2.0));\n    \n    //bandes rainures\n    v = Blend(v,torus(p, vec3(0,0,0), vec3(0,0,1), 4.6, -0.1, 0.1));\n    v = Blend(v,torus(p, vec3(0,0,-0.7), vec3(0,0,1), 4.4, -0.1, 0.1));\n    v = Blend(v,torus(p, vec3(0,0,+0.7), vec3(0,0,1), 4.4, -0.1, 0.1));\n    v = Blend(v,torus(p, vec3(0,0,-0.9), vec3(0,0,1), 4.3, -0.1, 0.1));\n    v = Blend(v,torus(p, vec3(0,0,+0.9), vec3(0,0,1), 4.3, -0.1, 0.1));\n    \n    // cotés (aplatissement)\n    v = Blend(v,disc(p, vec3(0,0,+1.5), vec3(0,0,1), 3.5, -1.0, 0.5));\n    v = Blend(v,disc(p, vec3(0,0,-1.5), vec3(0,0,1), 3.5, -1.0, 0.5));\n    \n    // chevrons\n    /*\n  \tfor(float i = 0.0; i < 2.0*3.14;i=i+0.1){\n    \tv = Blend(v,segment(p, rotateZ(vec3(-4.5,1.0,0.0),i), rotateZ(vec3(-4.5,0,-0.7),i), -0.1, 0.05));\n    \tv = Blend(v,segment(p, rotateZ(vec3(-4.5,1.0,0.0),i), rotateZ(vec3(-4.5,0,0.7),i), -0.1, 0.05));\n     \tv = Blend(v,segment(p, rotateZ(vec3(-4.3,0.0,-1.0),i), rotateZ(vec3(-4.0,0,-1.2),i), -0.1, 0.05));\n\t}\n\t*/\n    \n    // JANTE\n    v = Union(v,disc(p, vec3(0,0,-1.2), vec3(0,0,1), 3.3, 1.0, 0.1));\n    \n    // Triangles de la jante\n  \tfor(float i = 0.0; i < 2.0*3.14;i=i+1.04){\n    \tv = Without(v,triangle( p,  rotateZ(vec3(-1,-3,-1.3),i),  rotateZ(vec3(1,-3,-1.3),i),  rotateZ(vec3(0,-0.5,-1.3),i),1.0,0.5));\n\n  \t}\n    // Centre de la jante\n  \tv = Union(v,disc(p, vec3(0,0,-1.1), vec3(0,0,1), 1.0, 1.0, 0.3));\n    \n    \n  \tfor(float i = 0.0; i < 2.0*3.14;i=i+1.04){\n    \t//trou écrou\n      \tv = Without(v,point(p,  rotateZ(vec3(-0.5,-0.8,-1.3),i), 1.0, 0.3));\n\t\t// segment associé\n      \tv= Without(v,segment(p,rotateZ(vec3(-1.5,-2.6,-1.2),i), rotateZ(vec3(-0.7,-1.2,-1.2),i), 1.0 ,0.3));\n \t }\n    \n   \t// Centre enfoncé\n  \tv = Blend(v,disc(p, vec3(0,0,-1.2), vec3(0,0,1), 0.5, -1.0, 0.2));\n   \n    // plan final\n    v = Union(v,plan(pold,vec3(-4,-4.5,-4),vec3(4,-4.5,4),vec3(0,1,0),1.0,0.2));\n\n  \treturn v-T;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n  float eps = 0.0001;\n  vec3 n;\n  float v = object(p);\n  n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n  n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n  n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n          h = true;\n          break;\n      }\n      // Move along ray\n      t += Epsilon;\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o, vec3 u, out bool h,out int s)\n{\n  h = false;\n\n    // Don't start at the origin, instead move a little bit forward\n    float t=rA;\n\n  for(int i=0; i<Steps; i++)\n  {\n    s=i;\n    vec3 p = o+t*u;\n    float v = object(p);\n    // Hit object\n      if (v > 0.0)\n      {\n      \th = true;\n      \tbreak;\n      }\n      // Move along ray\n      t += max(Epsilon,abs(v)/4.0);\n      // Escape marched far away\n      if (t>rB)\n      {\n          break;\n      }\n  }\n  return t;\n}\n\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(0.4, 0.3, 0.0), vec3(0.7, 0.8, 1.0), rd.y*0.5+0.5);\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p, vec3 n)\n{\n  // point light\n  const vec3 lightPos = vec3(5.0, 5.0, 5.0);\n  const vec3 lightColor = vec3(0.5, 0.5, 0.5);\n\n  vec3 c = 0.25*background(n);\n  vec3 l = normalize(lightPos - p);\n\n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff = 0.5*(1.0+dot(n, l));\n\n  c += diff*lightColor;\n\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n   float t=float(n)/(float(Steps-1));\n   return vec3(t,0.25+0.75*t,0.5-0.5*t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n  // compute ray origin and direction\n  float asp = iResolution.x / iResolution.y;\n  vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -4.0));\n  vec3 ro = vec3(0.0, 0.0, 20.0);\n\n  // vec2 mouse = iMouse.xy / iResolution.xy;\n  float a=iTime*2.0;\n  ro = rotateY(ro,- 0.90);\n  rd = rotateY(rd, -0.90);\n // ro = rotateY(ro, a);\n // rd = rotateY(rd, a);\n\n  // Trace ray\n  bool hit;\n\n  // Number of steps\n  int s;\n\n  float t = SphereTrace(ro, rd, hit,s);\n  vec3 pos=ro+t*rd;\n  // Shade background\n  vec3 rgb = background(rd);\n\n  if (hit)\n  {\n    // Compute normal\n    vec3 n = ObjectNormal(pos);\n\n    // Shade object with light\n    rgb = Shade(pos, n);\n  }\n\n  // Uncomment this line to shade image with false colors representing the number of steps\n  //rgb = ShadeSteps(s);\n\n  fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}