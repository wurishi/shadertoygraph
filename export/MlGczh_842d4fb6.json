{"ver":"0.1","info":{"id":"MlGczh","date":"1535038283","viewed":624,"name":"Pixelated Edges","username":"lgabriel13","description":"I'm pretty sure that everyone wants to get rid of pixelated/aliased edges and I'm a 100% sure that this shader won't help, but it was a pretty interesting exercise.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sobel","edgedetection","sobelfilter","pixelated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Pixelated edges effect\n//I'm pretty sure that everyone wants to get rid of pixalated edges and I'm a hundred percent \n//sure that this shader won't help, but it was a pretty interesting exercise.\n//Basically, I'm using the Sobel filter to find the edges of the image, and where i've been able to find \n//an edge i apply a \"pixelated image effect\".\n//You can find more informations here: http://en.wikipedia.org/wiki/Sobel_operator\n\n/*\nmat3 Gx = mat3 (\n    \t1.0, 0.0, -1.0,\n    \t2.0, 0.0, -2.0,\n    \t1.0, 0.0, -1.0\n    );\n\nmat3 Gy = mat3 (\n    \t-1.0, 2.0, 1.0,\n    \t0.0, 0.0, 0.0,\n    \t-1.0, -2.0, -1.0\n    );\n\nAnother solution might be:\nmat3 Gx = mat3 (\n    \t3.0, 0.0, -3.0,\n    \t10.0, 0.0, -10.0,\n    \t3.0, 0.0, -3.0\n    );\n\nmat3 Gy = mat3 (\n    \t3.0, 10.0, 3.0,\n    \t0.0, 0.0, 0.0,\n    \t-3.0, -10.0, -3.0\n    );\n\n*/\n\n//Get texture's color and return luma\nfloat LookUp (vec2 p, vec2 offset)\n{\n    float offsetScale = 1.0;   \n    vec2 uv = p + offset * offsetScale;\n    vec4 col = texture(iChannel0, uv/iResolution.xy);\n\t\n\t// return luma\n    return 0.212 * col.r + 0.715 * col.g + 0.072 * col.b;\n}\n\n\n//Calculate the sobel convolsion\n//Return GY, GX, and the length of the gradient/displacement\n//If you need to calculate the direction: float alpha = atan (gy/gx);\nvec3 SobelFilter (vec2 uv)\n{\n    //Get the info for all surrounding pixels\n    float tl = LookUp (uv, vec2 (-1.0, 1.0));\n    float tc = LookUp (uv, vec2 (0.0, 1.0));\n    float tr = LookUp (uv, vec2 (1.0, 1.0));\n    \n    float l = LookUp (uv, vec2 (-1.0, 0.0));\n    float c = LookUp (uv, vec2 (0.0, 0.0));\n    float r = LookUp (uv, vec2 (1.0, 0.0));\n    \n    float bl = LookUp (uv, vec2 (-1.0, -1.0));\n    float bc = LookUp (uv, vec2 (0.0, -1.0));\n    float br = LookUp (uv, vec2 (1.0, -1.0));\n    \n    //Apply sobel filter kernels for X and Y using the convolusion matrices (GX and GY)\n    float gx = tl - tr + 2.0 * l - 2.0 * r + bl - br;\n    float gy = -tl - 2.0*tc - tr + bl + 2.0 * bc + br;\n    \n    //return gx, gy and the length of the gradient\n    return vec3 (gx, gy, sqrt (gx * gx + gy * gy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //Uv -> [0,1]\n    vec2 uv = fragCoord/iResolution.xy;\t    \n    float aspectRatio = iResolution.x/iResolution.y;\n    \n   \t//Sobel filter\n    vec3 sobelFilter = SobelFilter (fragCoord);\n    float gradient = sobelFilter.x * sobelFilter.x + sobelFilter.y * sobelFilter.y;\n   \n    vec2 offset = vec2 (0.0);\n    float pixelVal = 512.0; //normal texture dimension\n   \t//If our gradient's length is bigger than our min factor than pixelize that zone.\n    float minPixelizeFactor = 0.3; //you can play with these 2 variables\n    float minPixelVal = 50.0;\n    if (sobelFilter.z > minPixelizeFactor)\n    {\n        pixelVal = minPixelVal;       \n    }\n    \n    vec2 pixelUV = floor (uv * pixelVal + offset)/pixelVal;   \n    \n    //Get the normal color    \n    vec4 tex = textureLod (iChannel0, pixelUV, 0.0);     \n   \tfragColor.rgb = tex.rgb + vec3 (pow (gradient, 0.4), gradient, 0.0);\n    \n}","name":"Image","description":"","type":"image"}]}