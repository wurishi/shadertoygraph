{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"//0: torus, 1:sphere\n#define PID 0\n\nconst float PI = 3.14159;\n\nvec3 hsv(float h, float s, float v){\n    vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n    return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nmat3 setCamera(vec3 ro, vec3 tg, float cr){\nvec3 cw = normalize(tg-ro);\nvec3 cu = normalize(cross(cw,vec3(sin(cr), cos(cr), 0.0)));\nvec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nmat2 rotate2D(float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n\n\n#define resolution iResolution.xy\n#define time iTime\n\n// SDF для куба\nfloat sdBox( vec3 p, vec3 b )\n{\n p.xz*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n  p.yz*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\n// Функция opElongate\nvec3 opElongate( vec3 p, vec2 h )\n{\n  vec3 q = p;\n \n  q.x = abs(p.x) - h.x;\n    return q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\nuv.xy*=mat2(cos(iTime),sin(iTime),-sin(iTime), cos(iTime));\n    vec3 col = vec3(0);\n   vec2 uv3 = (fragCoord-.5*resolution.xy)/resolution.y;\n  vec3 ro = vec3(0,0,3);\n  \n  vec3 rd = normalize(vec3(uv3, -1.));\n\n  float t = 0.0;\n  vec3 p = ro + rd * t;\n\n  vec2 h = vec2(1.0, 0.0); // Параметры растяжения\n   p = opElongate(p,h);  // Применяем opElongate\n\n   float d = sdBox(p, vec3(.5)); // Используем sdBox\n\n   for(int i =0; i< 100; ++i)\n   {\n     p = ro + rd * t;\n     p = opElongate(p,h);\n     d = sdBox(p, vec3(.5));\n\n    if(abs(d) < .001)\n      break;\n        t += d;\n   }\n\n\n    vec3 col3 = vec3(0);\n    if(d < .001)\n   {\n      vec3 n = normalize(vec3(\n       sdBox( opElongate(p + vec3(0.01+cos(iTime), 0, 0),h) , vec3(.5)) - sdBox(opElongate(p - vec3(0.01, 0, 0),h) , vec3(.5)),\n        sdBox( opElongate(p + vec3(.2+cos(iTime), 0.01, 0),h) , vec3(.5)) - sdBox(opElongate(p - vec3(0, 0.01, 0),h) , vec3(.5)),\n        sdBox( opElongate(p + vec3(0, 0.5+cos(iTime), 0.01),h) , vec3(.5+cos(iTime))) - sdBox(opElongate(p - vec3(0, 0, 0.01),h) , vec3(.5))\n    ));\n    \n     col = vec3(.5) + .5 * n;\n   }\n    float t3 = iTime;\n   \n    vec3 ro3 = vec3(0, 0, -1);\n    vec3 tg = vec3(0);\n\n    mat3 ca = setCamera(ro3, tg, 0.);\n    vec3 rd3 = ca * normalize(vec3(uv, 1.));\n\n    vec3 p3,q;\n    float td=.1, d3;\n\n    for(int i=0;i<40;++i){\n        p3 = ro + td * rd;\n        p3.z-=t;\n        for(int i=0;i<6;++i){\n            p3=abs(p3)-.3;\n            p3.yz*=rotate2D(PI*.5);\n            p3.xz*=rotate2D(PI*.25);\n        }\n        q=mod(abs(p3-.5),1.)-.5;\n        #if PID == 0\n        d = abs(length(vec2(length(q.xz) - 1., q.y)) - .9);\n        #else\n        d = abs(length(q) - .65);\n        #endif\n        if(d < 0.001){\n            col += hsv(sin(q.x*q.y*8.+t), .8, .02/abs(sin(atan(q.x, q.z)*2.+t)*sin(atan(q.y, q.z)*2.+t)+.1));\n            d+=0.003;\n        }\n        td += d;\n    }\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"43cyzS","date":"1735230071","viewed":107,"name":"crystal cube 2","username":"nayk","description":"source","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["fractal","cubos"],"hasliked":0,"parentid":"","parentname":""}}