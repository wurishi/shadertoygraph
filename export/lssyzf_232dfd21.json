{"ver":"0.1","info":{"id":"lssyzf","date":"1522348580","viewed":785,"name":"The Black Oil","username":"chadmiral","description":"PROJECT PEREGRINE\nDESIGNATION: M12 TOP SECRET\nDO NOT DISTURB THE SAMPLE WITH THE MOUSE - EXTREMELY UNSTABLE.","likes":30,"published":1,"flags":32,"usePreview":0,"tags":["2d","sdf","fluid","circle","metaball","oil","ferrofluid","trustnoone","microscopic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Men can never be free, because they're weak, corrupt, worthless...\n// and restless. The people believe in authority. They've grown tired of\n// waiting for miracle or mystery. Science is their religion - no\n// greater explanation exists for them! They must never believe\n// any differently if the project is to go forward.\n//\n\nvec4 chromatic_aberration(vec2 uv, float strength, float aspect_ratio)\n{\n    vec2 eps = strength * vec2(aspect_ratio, 0.0);\n    \n    float r = texture(iChannel0, uv - eps).r;\n    float g = texture(iChannel0, uv + vec2(0.0, -eps)).g;\n    float b = texture(iChannel0, uv + eps).b;\n    \n    return vec4(r, g, b, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    \n    float blur_strength = 0.0;\n\n#if defined LAYER_6\n    float d2 = dist_squared_circle(uv, vec2(0.5, 0.5), 0.95, aspect_ratio);\n    blur_strength = 0.012 * clamp(1.0 * (d2 + 0.65), 0.0, 1.0);\n    //blur_strength = 1.5 * blur_strength * texture(iChannel1, 2.0 * uv).r;\n    \n    //random defocusing synced w/ spikes - this needs to be synced w/ Buf C\n    float focus_level = texture(iChannel2, vec2(0.03 * iTime, 0.0)).r;\n    focus_level = 0.04 * clamp((pow(focus_level, 1.25) - 0.18), 0.0, 1.0);\n    if(iMouse.x < 0.01 || iMouse.y < 0.01) { focus_level = 0.0; }\n    \n    blur_strength = max(blur_strength, focus_level);\n#endif // LAYER_6\n    \n    fragColor = chromatic_aberration(uv, blur_strength, aspect_ratio);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// This shader demonstrates signed distance fields in 2 dimensions,\n// doing a distance test against two wandering circles, and using that\n// value to interpolate between \"inside\" and \"outside\" colors.\n// We use a smooth-min (polynomial) function to create a \"metaball\" effect.\n//\n\n#define VIEW_DISTANCE_GRADIENT\n#define MOUSE_ADDS_OIL\n//#define MOUSE_SUBTRACTS_OIL\n#define MOUSE_REPELS_OIL\n\nfloat Edge_width = 1.0;     // controls width of the border\nfloat Edge_sharpness = 0.5; // controls sharpness of the border\nfloat Height_scalar = 1.0;\n\nvec3 Color_a = vec3(0.0, 0.0, 0.0);\nvec3 Color_b = 1.0 * vec3(1.0, 1.0, 1.0);\n\n#define NUM_SITES 35\n\nfloat Radius_a = 0.15;\nfloat Radius_b = 0.25;\n\nvec2 fbm_warp(vec2 uv, vec2 warp_uvs, float strength)\n{\n    float zspeed = 0.15;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    float x = 2.0 * fbm(vec3(warp_uvs, 1.0 + iTime * zspeed)) - 1.0;\n    float y = aspect_ratio * (2.0 * fbm(vec3(warp_uvs, 0.5 + iTime * zspeed)) - 1.0);\n    \n    return uv + strength * vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n#ifdef LAYER_2\n    vec2 warp_uvs = 4.0 * uv + vec2(0.0, iTime * 0.06);\n    \n    float warp_strength = 0.1;\n    uv = fbm_warp(uv, warp_uvs, warp_strength);\n#endif\n    \n    \n    vec2 sites[NUM_SITES];\n    float radii[NUM_SITES];\n    for(int i = 0; i < NUM_SITES; i++)\n    {\n        float a = float(i) / float(NUM_SITES);\n        sites[i] = vec2(bad_random(14.7654 * a + 174.24), bad_random(81.9414 * a + 25.123));\n        \n        sites[i] = sites[i] + vec2(0.2 * sin(bad_random(a + 63.87) * 0.5 * iTime + bad_random(a + 68.12)),\n                                   0.2 * cos(bad_random(a + 34.76) * 0.5 * iTime + bad_random(a + 793.65)));\n        \n        \n#if defined MOUSE_REPELS_OIL\n        //repel the site from the cursor\n        vec2 m = iMouse.xy / iResolution.xy;\n        float mouse_dist = dist_squared_circle(sites[i], m, 0.1, aspect_ratio);\n        vec2 repel_dir = normalize(sites[i] - m);\n        float repel_radius = 0.2;\n        float repel_strength = 1.0 - mouse_dist - repel_radius;\n        repel_strength = clamp(repel_strength, 0.0, 0.18);\n        sites[i] += repel_strength * repel_dir;\n#endif\n        \n        radii[i] = mix(0.05, 0.08, bad_random(762.01 * a + 23.765));\n    }\n    \n    float focus_level = 0.0;\n\n    //random defocusing synced w/ spikes - this needs to be synced w/ Buf C\n    focus_level = texture(iChannel2, vec2(0.03 * iTime, 0.0)).r;\n    focus_level = 0.35 * clamp((pow(focus_level, 1.25) - 0.18), 0.0, 1.0);\n    if(iMouse.x < 0.01 || iMouse.y < 0.01) { focus_level = 0.0; }\n    \n#if defined LAYER_6\n    //screen shake \n    vec2 screen_shake = focus_level * SCREEN_SHAKE_STRENGTH *\n            vec2(texture(iChannel1, vec2(iTime * 1.0, 0.0)).x - 0.5,\n                 texture(iChannel1, vec2(iTime * 1.0, 0.5)).x - 0.5);\n    \n    \n    uv += screen_shake;\n#endif //LAYER_6\n    \n#if defined MOUSE_ADDS_OIL\n    sites[0] = iMouse.xy / iResolution.xy;\n#if defined LAYER_6\n    sites[0] -= 4.0 * screen_shake;\n#endif //LAYER_6\n    radii[0] = 0.15;\n#endif\n    \n    float min_dist = 100.0;\n    \n\n    \n    //first one is the mouse one - make it spiky!\n  \tfloat spikiness = 0.0;\n    float d = dist_squared_circle(uv, sites[0], radii[0], aspect_ratio);;\n#if defined LAYER_5\n    spikiness = mix(0.0, 0.4, focus_level);\n    \n    d -= spikes(spikiness, iTime * 5.0, sites[0], uv, radii[0], aspect_ratio);\n#endif //LAYER_5\n    \n    \n\tmin_dist = d;\n    \n    \n    for(int i = 1; i < NUM_SITES; i++)\n    {\n    \td = dist_squared_circle(uv, sites[i], radii[i], aspect_ratio);\n#if defined LAYER_1\n\t\tmin_dist = poly_smin(d, min_dist, 0.05);\n#else\n        min_dist = min(d, min_dist);\n#endif //LAYER_1\n    }\n    \n\n    float height = 0.0;\n    if(min_dist > 0.0)\n    {\n        height = 0.0;\n    }\n    else\n    {\n        height = clamp(pow(abs(min_dist), Edge_sharpness) / Edge_width, 0.0, 1.0);\n    }\n    \n#if defined MOUSE_SUBTRACTS_OIL\n    //subtract from mouse\n\tvec2 v = (iMouse.xy / iResolution.xy - uv);\n    v.x *= iResolution.x / iResolution.y;\n    float mouse_d2 = 1.0 - 0.75 * pow(v.x * v.x + v.y * v.y, 1.0);\n    mouse_d2 = 1.0 - clamp(mouse_d2, 0.0, 1.0);\n   \n    height = clamp(poly_smin(mouse_d2, height, 0.075), 0.0, 1.0);\n#endif\n\n    vec3 final_color = vec3(height, height, height);\n    \n\tfragColor = vec4(final_color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 normal_from_height_map(vec2 uv, sampler2D tex)\n{\n    float eps = 1.0 / iResolution.x;\n    \n    float surfaceCurvature = 0.125f;\n    \n    float x0 = pow(texture(tex, vec2(uv.x - eps, uv.y)).r, surfaceCurvature);\n    float x1 = pow(texture(tex, vec2(uv.x + eps, uv.y)).r, surfaceCurvature);\n    float y0 = pow(texture(tex, vec2(uv.x, uv.y - eps)).r, surfaceCurvature);\n    float y1 = pow(texture(tex, vec2(uv.x, uv.y + eps)).r, surfaceCurvature);\n    \n    float dz_dx = (x0 - x1) / (2.0 * eps);\n    float dz_dy = (y0 - y1) / (2.0 * eps);\n    \n    vec3 n = vec3(dz_dx, dz_dy, 1.0);\n \n    return normalize(n);\n}\n\nvec3 desaturate(vec3 in_rgb)\n{\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    float luminance = dot(in_rgb, W);\n    return vec3(luminance, luminance, luminance);\n}\n\nvec4 contrast(vec4 in_rgb, float c)\n{\n\treturn ((in_rgb - 0.5) * c) + 0.5;\n}\n\nvec3 internal_glow(vec3 n)\n{\n    //mat4 m = rotation_matrix(vec3(0.707, 0.707, 0.0), iTime * 1.0);\n    //vec4 rot_n = m * vec4(n, 1.0);\n    \n\tvec3 glow = desaturate(texture(iChannel2, n.xyz).rgb);\n\tglow = contrast(vec4(glow.rgb, 1.0), 0.1).rgb;\n    \n    return glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    vec4 distance = texture(iChannel1, uv);\n\n    vec3 n = normal_from_height_map(uv, iChannel1);\n    \n    // add in some fresnel internal glow\n    // use the height field to apply this glow more where the\n    // liquid is thin (height is close to zero).\n    //\n    // use a different color for the mouse blob\n    //\n    vec2 m_pos = iMouse.xy / iResolution.xy;\n    float dm = -50.0 * dist_squared_circle(uv, m_pos, 0.2, aspect_ratio);\n    dm = clamp(dm, 0.0, 1.0);\n    \n    float beat_str = 0.35;\n    \n    vec3 internal_color_a = 0.12 * vec3(0.88, 0.55, 0.15);\n    vec3 internal_color_b = (0.15 + beat_str) * vec3(0.8, 1.0, 0.2);\n    \n    vec3 internal_color = mix(internal_color_a, internal_color_b, dm);\n    \n    float n_dot_v = dot(n, vec3(0.0, 0.0, 1.0));\n    n_dot_v = 1.0 - pow(n_dot_v, 6.0);\n    vec3 glow = mix(internal_color / distance.r, vec3(0.0, 0.0, 0.0), n_dot_v);\n    \n    vec3 final_color = vec3(1.0, 1.0, 0.94);\n    final_color = final_color - 0.15 * texture(iChannel0, 0.2 * uv).rrr;\n    if(distance.g > 0.01)\n    {\n        vec4 reflection = vec4(desaturate(texture(iChannel3, n).rgb), 1.0);\n        float k = 1.5;\n        reflection = vec4(pow(reflection.r, k),\n                          pow(reflection.g, k),\n                          pow(reflection.b, k), 1.0);\n        \n        vec3 glow_color = internal_glow(n);\n\n    \tfinal_color = contrast(reflection, 3.5).rgb + glow * glow_color;\n    }\n    \n#if defined LAYER_4\n    fragColor = vec4(final_color, 1.0);\n#else\n#if defined LAYER_3\n    fragColor = vec4(n, 1.0);\n#else\n    fragColor = vec4(100.0 * distance.rgb, 1.0);\n#endif // LAYER_3\n#endif // LAYER_4\n    //fragColor = vec4(fragCoord, 0.0, 1.0);\n    \n\n    //\n    //fragColor = vec4(distance.rgb, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define LAYER_0 // just circles\n#define LAYER_1 // sdf\n#define LAYER_2 // warp\n#define LAYER_3 // normals\n#define LAYER_4 // cube maps\n#define LAYER_5 // spikes\n#define LAYER_6 // post fx\n\n\n#define SCREEN_SHAKE_STRENGTH 0.4\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\n//super NOT random... but good enough for our purposes!\nfloat bad_random(float seed)\n{\n    return fract(sin(seed) * 136453.2432);\n    //return texture(iChannel1, vec2(seed, 0.0)).r;\n}\n\n// polynomial smooth min\nfloat poly_smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat dist_squared_circle(vec2 test_pos, vec2 c_pos, float radius, float aspect_ratio)\n{\n    float a = (test_pos.x - c_pos.x) * aspect_ratio;\n    float b = test_pos.y - c_pos.y;\n    return a * a + b * b - radius * radius;\n}\n\n#define M_PI 3.14159\nvec2 xyz_to_polar(vec2 P)\n{\n    float rho = length(P);\n    float theta = atan(P.y,P.x);\n    if( theta < 0.0 )\n        theta = 2.0*M_PI+theta;\n    return vec2(rho,theta);\n}\n\nfloat spikes(float strength, float phase, vec2 center, vec2 pos, float radius, float aspect)\n{\n    vec2 v = pos - center;\n    float d2 = dist_squared_circle(pos, center, radius, aspect);\n    if(d2 < 0.0) { return 0.0; }\n    \n    vec2 polar = xyz_to_polar(v);\n    \n    float f = 20.0;\n    float a = sin(f * polar.y + phase);\n    float b = 0.0;//sin(f * polar.y - phase);\n    return strength * pow(0.5 * ((a + b + 1.0)), 9.0);\n}\n\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// from anastadunbar's gaussian blur demo\n// https://www.shadertoy.com/view/4lXXWn\nvec3 gaussian(vec2 uv, float bluramount)\n{\n    vec3 r_col = vec3(1.0, 0.5, 0.0);\n    vec3 b_col = vec3(0.0, 0.5, 1.0);\n    \n    //float dists = 5.;\n    vec3 blurred_image = vec3(0.);\n    #define repeats 12.0\n    for (float i = 0.; i < repeats; i++) { \n        //Older:\n        //vec2 q = vec2(cos(degrees((grid(i,dists)/repeats)*360.)),sin(degrees((grid(i,dists)/repeats)*360.))) * (1./(1.+mod(i,dists)));\n        vec2 q = vec2(cos(degrees((i/repeats)*360.)),sin(degrees((i/repeats)*360.))) *  (rand(vec2(i,uv.x+uv.y))+bluramount); \n        \n        vec2 uv2 = uv+(q * bluramount);\n        blurred_image += texture(iChannel0,vec2(uv2.x,uv2.y)).rgb/2.;\n        \n        //One more to hide the noise.\n        q = vec2(cos(degrees((i/repeats)*360.)),sin(degrees((i/repeats)*360.))) *  (rand(vec2(i+2.,uv.x+uv.y+24.))+bluramount); \n        uv2 = uv+(q*bluramount);\n        blurred_image += texture(iChannel0,vec2(uv2.x,uv2.y)).rgb/2.;\n    }\n    blurred_image /= repeats;\n    return blurred_image;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    \n    //random defocusing\n    float focus_level = texture(iChannel1, vec2(0.03 * iTime, 0.0)).r;\n    focus_level = 0.5 * clamp((pow(focus_level, 1.5) - 0.15), 0.0, 1.0);\n    if(iMouse.x < 0.01 || iMouse.y < 0.01) { focus_level = 0.0; }\n    \n    vec2 eps = vec2(1.0 / iResolution.x, 0.0);\n    float d2 = dist_squared_circle(uv, vec2(0.5, 0.5), 0.75, aspect_ratio);\n    \n    float mask_strength = 0.0;\n\n#if defined LAYER_6\n    mask_strength = clamp(40.0 * d2, 0.0, 1.0);\n#endif // LAYER_6\n    \n    vec3 mask_color = vec3(1.0, 1.0, 1.0) * (1.0 - mask_strength);// * mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 10.0 * d2_dx);\n\n    float blur_strength = 0.0;\n\n#if defined LAYER_6\n    blur_strength = 3.0 * focus_level + 0.25 * clamp(1.0 * (d2 + 0.4), 0.0, 1.0);\n#endif // LAYER_6\n    \n    vec4 oil = vec4(gaussian(uv, 0.1 * blur_strength), 1.0);\n    \n    fragColor = oil * vec4(mask_color, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}