{"ver":"0.1","info":{"id":"tt2SzG","date":"1566373582","viewed":151,"name":"Noise RayMarcher","username":"Dude","description":"RayMarch over Noise floor","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noiseraymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXIMUM_STEPS 1290\n#define DISTANCE_THRESHOLD .01\n#define FAR_CLIP 90.0\n\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opDisplace( vec3 p, float noiseColor )\n{\n    vec4 plo = vec4(.0,.10,.0,.2);\n    float d1 = sdPlane(p, plo);\n    float d2 = noiseColor;\n    return d1+d2;\n}\n\n/* ROTATIONS */\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\nfloat nearestSurface(vec3 rp, float nclr) {\n    \n    float msd = 99999.;\n    msd = min(msd, opDisplace(rp, nclr));\n\n    return msd;\n}\n\n/* RAY MARCHING */\n\n//march a single ray\nvec4 marchRay(vec3 ro, vec3 rd) {\n\n    float d = 0.0; //distance marched\n    vec4 pc = vec4(0.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        \n        vec3 rp = ro + rd * d; //ray position\n        rp *= .5f;\n        float f = noise(vec2(rp.x, rp.z));\n\t\tvec2 uv = vec2(rp.x*0.5f, rp.z*0.5f);\n        mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n        \n        float hills = 0.36;\n        \n        \n        f  = 0.5000*noise( uv ); uv = m*uv;\n        f += 0.2500*noise( uv ); uv = m*uv;\n        f += 0.1250*noise( uv ); uv = m*uv;\n        //f += 0.0625*noise( uv ); uv = m*uv;\n        f = 0.3 + hills*f;\n        \n        float ns = nearestSurface(rp, f);\n        d += ns;\n        \n        if (abs(ns) < DISTANCE_THRESHOLD) {\n            float clf = 1.-f * 3.;\n            \n            if(clf > 0.3f){\n            \tpc = vec4(clf, clf, clf, 1.)*2.7;\n            }else{\n            \tpc = vec4(clf*0.3, clf*0.4, clf*0.2, 1)*5.;\n            }\n            pc *= d*0.06;\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            pc = vec4(0.1, 0.3, 0.9, 1.);\n            pc *= 1.-smoothstep(0.02, 0.33, rd.y) + 0.8;\n            break;\n        }\n    }\n\n    return pc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 1.5));\n    vec3 ro = vec3(0, 0, -1.+float(iFrame)/15.);\n\n    rY(ro, -cos(iTime) * .0006);\n    rY(rd, sin(iTime) * .02);\n    rX(rd, .5);\n    \n\tfragColor = marchRay(ro, rd);\n}\n\n","name":"Image","description":"","type":"image"}]}