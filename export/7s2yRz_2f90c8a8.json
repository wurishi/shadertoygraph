{"ver":"0.1","info":{"id":"7s2yRz","date":"1643030315","viewed":208,"name":"10-1 SphereSDF","username":"ccc9527","description":"SDF,ray marching","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n#define sphere vec4(0,1,6,2)\n\n//中心位于原点半径为1的球体的符号距离函数定义\nfloat sphereSDF(vec3 samplePoint)\n{\n    return length(samplePoint-sphere.xyz)-sphere.w;\n}\n/**\n* 返回最短距离函数\n* eye: 射线的起点，可理解为相机\n* marchingDirection: 射线的标准化方向向量\n* start: 从相机开始的最短距离\n* end: 最远距离\n* RayMarch\n*/\nfloat shortDistanceToSurface(vec3 eye,vec3 marchingDirection)\n{\n    float depth = 0.0;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++)\n    {\n        vec3 p = eye+depth*marchingDirection;\n        float dist = sphereSDF(p);\n        depth+=dist;\n        if(dist<EPSILON || depth>MAX_DIST) break;\n    }\n    return depth;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0.0,1.0,0.0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.0));\n    \n    float dist = shortDistanceToSurface(ro,rd);\n    \n    if(dist>MAX_DIST) return;\n    \n    fragColor = vec4(1.0,0.0,0.0,1.0);\n    \n    vec3 point = ro + rd * dist;\n    vec3 lightPos = vec3(0.0,5.0,4.0);\n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    vec3 lightDir = normalize(lightPos-point);\n    \n    vec3 normal = normalize(point-sphere.xyz);\n    \n    float normalDotLight = clamp(dot(normal, lightDir), 0.0, 1.0);\n    fragColor = mix(vec4(0.1, 0.1, 0.1, 1.0), fragColor, normalDotLight);\n}","name":"Image","description":"","type":"image"}]}