{"ver":"0.1","info":{"id":"4cGSzd","date":"1715595503","viewed":93,"name":"[zznewclear13] sRGB in Shadertoy","username":"zznewclear13","description":"Explains how to use sRGB in Shadertoy, based on my understanding.\nTop: encode fragColor to sRGB.\nRed bars represent evenly distributed light intensity.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["gamma","srgb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] sRGB in Shadertoy\n// https://www.shadertoy.com/view/4cGSzd\n// Explains how to use sRGB in Shadertoy, based on my understanding.\n// Top: encode fragColor to sRGB.\n// Red bars represent evenly distributed light intensity.\n\n// References:\n// [sRGB vs gamma encoding 3](https://www.shadertoy.com/view/7sBfDm)\n// [Gamma correction test, gradient](https://www.shadertoy.com/view/7tKXWR)\n// Can be seen as a combination of both.\n\n// #define SRGB_SIMPLE\n#define BAR_COUNT 10.0f\n\nfloat luminance(vec3 val)\n{\n    return dot(vec3(0.2126f, 0.7152f, 0.0722f), val);\n}\n\nvec3 sRGB_OETF(vec3 val)\n{\n#if defined(SRGB_SIMPLE)\n    return pow(val, vec3(1.0f/2.2f));\n#else\n    return mix(val*12.92f,1.055f*pow(val,vec3(1.0f/2.4f))-0.055f,greaterThan(val,vec3(0.0031308f)));\n#endif\n}\n\nvec3 sRGB_EOTF(vec3 val)\n{\n#if defined(SRGB_SIMPLE)\n    return pow(val, vec3(2.2f));\n#else\n    return mix(val/12.92f,pow((val+0.055f)/1.055f,vec3(2.4f)),greaterThan(val,vec3(0.04045f)));\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    ivec2 iFragCoord = ivec2(fragCoord);\n    vec4 bufferA = texelFetch(iChannel0, iFragCoord, 0);\n    \n    // We are measuring radiance in bufferA.\n    vec3 col = bufferA.rgb;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    if(uv.y >= 0.5f) \n    {\n        // Correct way, we convert radiance to sRGB values.\n        col = sRGB_OETF(col);\n    }\n    \n    // Our monitor expects sRGB values, Shadertoy also expects sRGB values.\n    fragColor = vec4(col, 1.0f);\n    \n    // During display, our monitor does a sRGB EOTF to emit light into our eyes.\n    // fragColor.rgb = sRGB_EOTF(fragColor.rgb);\n    \n    // Red bars represent evenly distributed light intensity.\n    float bar = abs(fract(luminance(sRGB_EOTF(fragColor.xxx)) * BAR_COUNT) - 0.5f) < 0.02f ? 1.0f : 0.0f; \n    fragColor.rgb = mix(fragColor.rgb, vec3(0.5f, 0.0f, 0.0f), bar * (1.0f - bufferA.a));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SPHERE_COUNT 5.0f\n\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n\nstruct Light\n{\n    vec3 col;\n    vec3 dir;    \n};\n\nLight lights[3];\n\nvoid InitLights()\n{\n    lights[0] = Light(vec3(3.5f, 3.5f, 3.5f), vec3(-0.5f, 0.5f, -0.3f));\n    lights[1] = Light(vec3(1.20f, 0.5f, 0.5f), vec3(0.6f, -0.1f, -0.5f));\n    lights[2] = Light(vec3(0.5f, 0.5f, 1.2f), vec3(0.6f, 0.3f, 0.3f));  \n}\n\nconst float tmin = 1e-3;\nconst float tmax = 1e3;\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Special case: sphere with radius of 1.0 at (0.0, 0.0, 0.0)\nbool raySphereIntersect(vec3 o, vec3 d, out vec3 p)\n{\n    bool hasIntersection = false;\n    float a = dot(d, d);\n    float b = dot(o, d);\n    float c = dot(o, o) - 1.0f;\n    float det = b * b - a * c;    \n    if(det < 0.0f) return false;\n    \n    float sqrtVal = sqrt(det);\n    float t1 = (-b - sqrtVal) / a;\n    float t2 = (-b + sqrtVal) / a;\n    if(t2 <= tmin) return false;\n    \n    float t = (t1 <= tmin) ? t2 : t1;  \n    if(t > tmax) return false;\n    \n    p = normalize(o + t * d);\n    return true;\n}\n\n// Bruce Walter et al. 2007. Microfacet Models for Refraction through Rough Surfaces. Proceedings of the Eurographics Symposium on Rendering.\nfloat D_GGX(float NoH, float roughness) {\n    float a = NoH * roughness;\n    float k = roughness / (1.0 - NoH * NoH + a * a);\n    return k * k * INV_PI;\n}\n\n// Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3 (2).\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\n// Christophe Schlick. 1994. An Inexpensive BRDF Model for Physically-Based Rendering. Computer Graphics Forum, 13 (3), 233â€“246.\nvec3 F_Schlick(float LoH, vec3 f0) {\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - LoH, 5.0);\n}\n\n// Specular BRDF\nvec3 Fr(float NoV, float NoL, float NoH, float LoH, float roughness, vec3 f0) {\n    float D = D_GGX(NoH, roughness);\n    vec3 F = F_Schlick(LoH, f0);\n    float V = V_SmithGGXCorrelated(NoV, NoL, roughness);\n    return D * F * V;\n}   \n\nfloat Fd_Lambert() {\n    return INV_PI;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitLights();\n\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 gridCount = vec2(SPHERE_COUNT, 2.0f);\n    vec2 gridUV = uv * gridCount;\n    vec2 sphereIndex = floor(gridUV);\n    gridUV = fract(gridUV);\n    \n    vec3 ta = vec3(0.0f, 0.0f, 0.0f);\n    vec3 ro = vec3(0.0f, 0.0f, -3.0f);\n    mat3 ca = setCamera(ro, ta, 0.0f);\n    \n    vec2 res = iResolution.xy / gridCount;\n    vec2 gridP = (gridUV * 2.0f - 1.0f) * res.xy / res.x;\n    float fl = 2.5f;\n    vec3 rd = ca * normalize(vec3(gridP, fl));\n    \n    vec3 p;  \n    bool intersect = raySphereIntersect(ro, rd, p);    \n    vec3 col = vec3(0.0f, 0.0f, 0.0f);\n    if (intersect)\n    {\n        vec3 diffuseCol = vec3(sphereIndex.x / SPHERE_COUNT * 0.8f + 0.1f);\n        vec3 specularCol = vec3(0.04f, 0.04f, 0.04f);\n    \n        vec3 n = normalize(p);\n        vec3 v = normalize(-rd);     \n        float NoV = abs(dot(n, v)) + 1e-5f;\n        for (int i=0; i<lights.length(); ++i)\n        {\n            Light light = lights[i];\n            vec3 l = normalize(light.dir);\n            vec3 h = normalize(l + v);\n            float NoL = max(dot(n, l), 1e-5f);\n            float NoH = dot(n, h);\n            float LoH = dot(l, h);\n\n            col += (diffuseCol * Fd_Lambert() + Fr(NoV, NoL, NoH, LoH, 0.4f, specularCol)) * light.col * NoL;                \n        }\n    }\n    else\n    {\n        col = uv.xxx;\n    }\n\n    fragColor = vec4(col, intersect);\n}","name":"Buffer A","description":"","type":"buffer"}]}