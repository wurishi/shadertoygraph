{"ver":"0.1","info":{"id":"WlVGRm","date":"1578598829","viewed":201,"name":"Four Rhombus Spiral Tessellation","username":"revort","description":"Takes the four rhombus tessellation and spiralizes according to two integers (a,b) describing the number of tilings in two vector directions.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["spiral","tiling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Using https://iquilezles.org/articles/distfunctions2d for the rhombus sdf, \nhttps://iquilezles.org/articles/distfunctions for the repetition of the tiling\nusing rhombus tesselation functions from https://www.shadertoy.com/view/tlGGDR\nspiral stuff based on http://isohedral.ca/escher-like-spiral-tilings/\n*/\n\nfloat tau = 6.28318530718;\nfloat pi = 3.14159265358979;\nfloat sqrt_2 = 1.41421356237;\nfloat sqrt_half = 0.70710678118;\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nvec2 rotatePoint(vec2 p, float theta){\n    return vec2(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\n\nvec2 translatePoint(vec2 p, vec2 t){\n    return p - t;\n}\n\nfloat tesselatedRhombiPos(float theta1, vec2 p){\n    vec2 p_ = p;\n    p_ = translatePoint(p_,vec2(0.5,0.5));\n    p_ = rotatePoint(p_,-pi/4.0);\n    float d = sdRhombus(p_, vec2(cos(pi/4.0),sin(pi/4.0)));\n    p_ = p;\n    p_ = translatePoint(p_,vec2(0.5+0.5*cos(theta1),1.0+0.5*sin(theta1)));\n    p_ = rotatePoint(p_,-theta1/2.0);\n    d = min(d,sdRhombus(p_, vec2(cos(theta1/2.0),sin(theta1/2.0))));\n    p_ = p;\n    p_ = translatePoint(p_,vec2(1.0+0.5*sin(theta1),0.5-0.5*cos(theta1)));\n    p_ = rotatePoint(p_,(pi-theta1)/2.0);\n    d = min(d,sdRhombus(p_, vec2(cos(theta1/2.0),sin(theta1/2.0))));\n    p_ = p;\n    p_ = translatePoint(p_,vec2(1.0 + sqrt_half*cos(theta1-pi/4.0),1.0 + sqrt_half*sin(theta1-pi/4.0)));\n    p_ = rotatePoint(p_,-theta1-pi/4.0);\n    d = min(d,sdRhombus(p_, vec2(cos(pi/4.0),sin(pi/4.0))));\n    return d;\n}\n\nvec2 opRep( in vec2 p, in vec2 c)\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nfloat getTesselatedRhombusVal(vec2 p, float theta1){\n    vec2 a_vec = vec2(cos(theta1),1.0+sin(theta1));\n    vec2 b_vec = vec2(1.0+sin(theta1),-cos(theta1));\n    float angle = atan(a_vec.y,a_vec.x);\n    float len = length(a_vec);\n    vec2 offset = vec2(len,len);\n    vec2 p_ = rotatePoint(p, -angle);\n    p_ = opRep(p_, offset);\n    float val = tesselatedRhombiPos(theta1,rotatePoint(p_, angle));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ + vec2(offset.x,0.0), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ - vec2(offset.x,0.0), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ + vec2(0.0,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ - vec2(0.0,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ + vec2(offset.x,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ - vec2(offset.x,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ + vec2(-offset.y,offset.y), angle)));\n    val = min(val, tesselatedRhombiPos(theta1,rotatePoint(p_ - vec2(-offset.y,offset.y), angle)));\n    return val;\n}\n\nfloat getFilteredRhombusVal(vec2 p, float theta1){\n    float val = 0.6*getTesselatedRhombusVal(p, theta1);\n    //basic filter to prevent aliasing crap\n    val += 0.1*getTesselatedRhombusVal(p+vec2(0.01,0.0), theta1);\n    val += 0.1*getTesselatedRhombusVal(p-vec2(0.01,0.0), theta1);\n    val += 0.1*getTesselatedRhombusVal(p+vec2(0.0,0.01), theta1);\n    val += 0.1*getTesselatedRhombusVal(p-vec2(0.0,0.01), theta1);\n    return val;\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime/2.0;\n    // Change these to any integer for more fun\n    vec2 ab = vec2(7.0,5.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n    vec2 cart = uv * iResolution.xy / iResolution.x * 12.0;\n    // cart /= length(ab);\n    float angle = atan(cart.y,cart.x);\n    float r = length(cart)/2.0;\n    cart = vec2(angle,r);\n    float rhombus_theta = mod(t,2.0)*pi/2.0;\n    vec2 a_vec = vec2(cos(rhombus_theta),1.0+sin(rhombus_theta));\n    vec2 b_vec = vec2(1.0+sin(rhombus_theta),-cos(rhombus_theta));\n    vec2 ab_vec = ab.x*a_vec + ab.y*b_vec;\n    float theta=atan(ab_vec.y,ab_vec.x);\n    float l = length(ab_vec)/tau;\n    \n    vec2 p = vec2(cart.x*cos(theta)-cart.y*sin(theta),\n                  cart.x*sin(theta)+cart.y*cos(theta))*l;\n    vec2 offset_vec = (a_vec)*mod(t,2.0)/2.0;\n    p = p - offset_vec;\n    //p = p + vec2(offset_vec.x*cos(-theta)-offset_vec.y*sin(-theta), offset_vec.x*sin(-theta)+offset_vec.y*cos(-theta));\n    vec3 col = vec3(1.0);\n    float x_dist = min(abs(p.x-ceil(p.x)),abs(p.x-floor(p.x)));\n    float y_dist = min(abs(p.y-ceil(p.y)),abs(p.y-floor(p.y)));\n    float dist = min(x_dist,y_dist);\n    x_dist = mod(p.x,1.0);\n    y_dist = mod(p.y,1.0);\n    float val = getFilteredRhombusVal(p, rhombus_theta);\n    col = mix(col,vec3(0.0),0.5 + 0.5*cos(val*pi*8.0+t*5.0));\n    /*float d = abs(abs(abs(sdCircle(vec2(x_dist,y_dist)-vec2(0.5,0.5),0.3))-0.19)-0.09)-(0.05+0.025*sin(t+r));\n    if (d < 0.0){\n        col = mix(col,vec3(0.0),1.0-(abs(d)/0.2));\n    }*/\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}