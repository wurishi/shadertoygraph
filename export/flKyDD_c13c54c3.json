{"ver":"0.1","info":{"id":"flKyDD","date":"1661496827","viewed":137,"name":"chromaticity xy 380,780nm","username":"LongJiangnan","description":"UI:\n1. shape:\"Square(0.2)\", approximation is determines whether triangles or palette are displayed.\n2. shape:\"Square(0.2,0.01)\", diffuse scale is similar to the 'area' of palette distribution.\n3. concentration .","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["xy","colormetry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0,uv).rgb,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"///@license Free \n\n#define SPECTRUM_SIZE ( (780u-380u)/5u+1u )\nconst vec3 CIE_RGB[SPECTRUM_SIZE] = vec3[SPECTRUM_SIZE](\nvec3(0.0000300000000000,-0.0000100000000000,0.0011700000000000),\nvec3(0.0000500000000000,-0.0000200000000000,0.0018900000000000),\nvec3(0.0001000000000000,-0.0000400000000000,0.0035900000000000),\nvec3(0.0001700000000000,-0.0000700000000000,0.0064700000000000),\nvec3(0.0003000000000000,-0.0001400000000000,0.0121400000000000),\nvec3(0.0004700000000000,-0.0002200000000000,0.0196900000000000),\nvec3(0.0008400000000000,-0.0004100000000000,0.0370700000000000),\nvec3(0.0013900000000000,-0.0007000000000000,0.0663700000000000),\nvec3(0.0021100000000000,-0.0011000000000000,0.1154100000000000),\nvec3(0.0026600000000000,-0.0014300000000000,0.1857500000000000),\nvec3(0.0021800000000000,-0.0011900000000000,0.2476900000000000),\nvec3(0.0003600000000000,-0.0002100000000000,0.2901200000000000),\nvec3(-0.0026100000000000,0.0014900000000000,0.3122800000000000),\nvec3(-0.0067300000000000,0.0037900000000000,0.3186000000000000),\nvec3(-0.0121300000000000,0.0067800000000000,0.3167000000000000),\nvec3(-0.0187400000000000,0.0104600000000000,0.3116600000000000),\nvec3(-0.0260800000000000,0.0148500000000000,0.2982100000000000),\nvec3(-0.0332400000000000,0.0197700000000000,0.2729500000000000),\nvec3(-0.0393300000000000,0.0253800000000000,0.2299100000000000),\nvec3(-0.0447100000000000,0.0318300000000000,0.1859200000000000),\nvec3(-0.0493900000000000,0.0391400000000000,0.1449400000000000),\nvec3(-0.0536400000000000,0.0471300000000000,0.1096800000000000),\nvec3(-0.0581400000000000,0.0568900000000000,0.0825700000000000),\nvec3(-0.0641400000000000,0.0694800000000000,0.0624600000000000),\nvec3(-0.0717300000000000,0.0853600000000000,0.0477600000000000),\nvec3(-0.0812000000000000,0.1059300000000000,0.0368800000000000),\nvec3(-0.0890100000000000,0.1286000000000000,0.0269800000000000),\nvec3(-0.0935600000000000,0.1526200000000000,0.0184200000000000),\nvec3(-0.0926400000000000,0.1746800000000000,0.0122100000000000),\nvec3(-0.0847300000000000,0.1911300000000000,0.0083000000000000),\nvec3(-0.0710100000000000,0.2031700000000000,0.0054900000000000),\nvec3(-0.0531600000000000,0.2108300000000000,0.0032000000000000),\nvec3(-0.0315200000000000,0.2146600000000000,0.0014600000000000),\nvec3(-0.0061300000000000,0.2148700000000000,0.0002300000000000),\nvec3(0.0227900000000000,0.2117800000000000,-0.0005800000000000),\nvec3(0.0551400000000000,0.2058800000000000,-0.0010500000000000),\nvec3(0.0906000000000000,0.1970200000000000,-0.0013000000000000),\nvec3(0.1284000000000000,0.1852200000000000,-0.0013800000000000),\nvec3(0.1676800000000000,0.1708700000000000,-0.0013500000000000),\nvec3(0.2071500000000000,0.1542900000000000,-0.0012300000000000),\nvec3(0.2452600000000000,0.1361000000000000,-0.0010800000000000),\nvec3(0.2798900000000000,0.1168600000000000,-0.0009300000000000),\nvec3(0.3092800000000000,0.0975400000000000,-0.0007900000000000),\nvec3(0.3318400000000000,0.0790900000000000,-0.0006300000000000),\nvec3(0.3442900000000000,0.0624600000000000,-0.0004900000000000),\nvec3(0.3475600000000000,0.0477600000000000,-0.0003800000000000),\nvec3(0.3397100000000000,0.0355700000000000,-0.0003000000000000),\nvec3(0.3226500000000000,0.0258300000000000,-0.0002200000000000),\nvec3(0.2970800000000000,0.0182800000000000,-0.0001500000000000),\nvec3(0.2634800000000000,0.0125300000000000,-0.0001100000000000),\nvec3(0.2267700000000000,0.0083300000000000,-0.0000800000000000),\nvec3(0.1923300000000000,0.0053700000000000,-0.0000500000000000),\nvec3(0.1596800000000000,0.0033400000000000,-0.0000300000000000),\nvec3(0.1290500000000000,0.0019900000000000,-0.0000200000000000),\nvec3(0.1016700000000000,0.0011600000000000,-0.0000100000000000),\nvec3(0.0785700000000000,0.0006600000000000,-0.0000100000000000),\nvec3(0.0593200000000000,0.0003700000000000,0.0000000000000000),\nvec3(0.0436600000000000,0.0002100000000000,0.0000000000000000),\nvec3(0.0314900000000000,0.0001100000000000,0.0000000000000000),\nvec3(0.0229400000000000,0.0000600000000000,0.0000000000000000),\nvec3(0.0168700000000000,0.0000300000000000,0.0000000000000000),\nvec3(0.0118700000000000,0.0000100000000000,0.0000000000000000),\nvec3(0.0081900000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0057200000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0041000000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0029100000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0021000000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0014800000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0010500000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0007400000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0005200000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0003600000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0002500000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0001700000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0001200000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0000800000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0000600000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0000400000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0000300000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0000100000000000,0.0000000000000000,0.0000000000000000),\nvec3(0.0000000000000000,0.0000000000000000,0.0000000000000000)\n);\n\n/// From theory in \"How the CIE 1931 Color-Matching Functions Were Derived from Wrightâ€“Guild Data\"\n///                             [0.49,    0.31,    0.20   ]\n///   xyz = xyz0 * V/y0, xyz0 = [0.17697, 0.81240, 0.01063] * rgb\n///                             [0.00,    0.01,    0.99   ]\n/// \n/// 'V' is dot(rgb,vec3(1,4.590700,0.060100)), 'y0' is ...\n///\n///   xyz = xyz0 * dot(rgb,vec3(1,4.590700,0.060100))/dot(rgb,vec3(0.17697, 0.81240, 0.01063))\n///\n///         [0.49,    0.31,    0.20   ]\n///   xyz = [0.17697, 0.81240, 0.01063] * rgb * 5.6508\n///         [0.00,    0.01,    0.99   ]\n/// So the\nconst mat3 rgb2xyz = mat3(\n  2.768892, 1.751748, 1.130160,\n  1,        4.590700, 0.060100,\n  0,        0.056508, 5.594292\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 params = texelFetch(iChannel0, ivec2(Bufer_A_size,0), 0);\n    float diffuse_scale = iFrame != 0 ? params[0] : 0.001;\n    float radius_scale = iFrame != 0 ? params[1] : 1.0;\n    float concentration = iFrame != 0 ? params[2] : 0.5;\n    float approximation = iFrame != 0 ? params[3] : 0.0;\n    vec2 iMouse_uv = iMouse.xy/iResolution.xy;\n    if ( iMouse.w>0.01 ) {\n        if ( all(lessThanEqual(vec2(0.7,0.7),iMouse_uv)) &&\n             all(lessThanEqual(iMouse_uv,vec2(0.9,0.71))) ) {\n            concentration = (iMouse_uv.x - 0.7)/(0.9 - 0.7);\n        } else if ( all(lessThanEqual(vec2(0.7,0.8),iMouse_uv)) &&\n                    all(lessThanEqual(iMouse_uv,vec2(0.9,0.81))) ) {\n            diffuse_scale = max(pow(10.0,-3.0+2.0*(iMouse_uv.x - 0.7)/(0.9 - 0.7)), 0.001);\n        } else if ( all(lessThanEqual(vec2(0.7,0.9),iMouse_uv)) &&\n                    all(lessThanEqual(iMouse_uv,vec2(0.72,0.92))) ) {\n            approximation = approximation == 0.0 ? 1.0 : 0.0;\n        }\n    }\n    \n    uvec2 ixy = uvec2(fragCoord.xy);\n    if ( ixy.x == Bufer_A_size && ixy.y == 0u ) {\n        fragColor = vec4(diffuse_scale,radius_scale,concentration,approximation);\n    }\n    if ( ixy.x < Bufer_A_size && ixy.y == 0u ) {\n        if (approximation == 0.0) {\n            /// rgb to xyz.\n            /// \n            uint rng = ixy.x + 1920u*ixy.y + (1920u*1080u)*uint(iFrame);\n            float spd[SPECTRUM_SIZE];\n            for (uint k = 0u; k != SPECTRUM_SIZE; ++k) {\n                spd[k] = hash1(rng++) * diffuse_scale;\n            }\n            for (uint k = 0u, kend = ihash1(rng)%(uint(max(concentration*float(SPECTRUM_SIZE),1.0))/*SPECTRUM_SIZE/2u*/ - 1u + 1u) + 1u; k != kend; ++k) {\n                spd[ihash1(rng++)%SPECTRUM_SIZE] = hash1(rng++) * radius_scale;\n            }\n\n            vec3 rgb = vec3(0.0);/// = integral<L=380,780>( CIE_RGB[L]*spd[L] ) ( Trapozoidal )\n            for (uint k = 0u; k != SPECTRUM_SIZE; ++k) {\n                rgb += CIE_RGB[k]*spd[k] \n                    * (k == 0u || (k+1u) == SPECTRUM_SIZE ? 0.5f : 1.0f);\n            }\n            rgb *= (780.0 - 380.0)/float(SPECTRUM_SIZE - 1u);\n\n            vec3 xyz = rgb * rgb2xyz;\n            vec3 xy = xyz/dot(xyz,vec3(1.0));\n\n            uvec2 result_ixy = uvec2(xy.xy * (iResolution.xy - 1.0));\n            fragColor = vec4(tonemap(rgb),uintBitsToFloat(result_ixy.x|(result_ixy.y<<16)));\n            /// \n            /// end of rgb to xyz.\n        } else {\n            uint rng = ixy.x + 1920u*ixy.y + (1920u*1080u)*uint(iFrame);\n            \n            vec3 saturatedrgb = vec3(hash3(rng++));\n            vec3 saturatedrgb2rgb = /*integral<L=380,780>(CIE_RGB[L]) = */vec3(18.91012573242188,18.91012573242188,18.90707588195801);\n            \n            vec3 xyz = (saturatedrgb * saturatedrgb2rgb) * rgb2xyz;\n            vec3 xy = xyz/dot(xyz,vec3(1.0));\n\n            uvec2 result_ixy = uvec2(xy.xy * (iResolution.xy - 1.0));\n            fragColor = vec4(/*!!*/saturatedrgb/*!!*/,uintBitsToFloat(result_ixy.x|(result_ixy.y<<16)));\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nuint ihash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n & uint(0x7fffffffU);\n}\n\nfloat hash1( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uint(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec3 k = n * uvec3(n,n*16807U,n*48271U);\n    return vec3( k & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nconst uint Bufer_A_size = 128u;\n\n/// Test your tonemap?\nvec3 tonemap( vec3 rgb )\n{\n    //return rgb;\n\n    /// For example: Reinhard.\n    vec3 white = /*integral<L=380,780>(CIE_RGB[L]) = */vec3(18.91012573242188,18.91012573242188,18.90707588195801);\n    return rgb*(1.0 + rgb/(white*white))/(1.0 + rgb);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates [0 to iResolution)\n    uvec2 ixy = uvec2(fragCoord.xy);\n    \n    bool traced = false;\n    for ( uint i = 0u; i != Bufer_A_size; ++i ) {\n        // sampled data(rgb,packaged_index)\n        vec4 something = texelFetch(iChannel0,ivec2(i,0),0);\n\n        uint packaged_index = floatBitsToUint(something[3]);\n        uvec2 result_ixy = uvec2(packaged_index&((1u<<16u) - 1u), packaged_index>>16u);\n        if (all(equal(ixy,result_ixy))) {\n            fragColor.rgb = something.rgb;\n            traced = true;\n        }\n    }\n    \n    // Normalized pixel coordinates (from 0 to 1) for UI test.\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 iMouse_uv = iMouse.xy/iResolution.xy;\n    \n    // UI.\n    bool updated = false;\n    if( iMouse.w>0.01 ) {\n        if ( all(lessThanEqual(vec2(0.7,0.7),iMouse_uv)) &&\n             all(lessThanEqual(iMouse_uv,vec2(0.9,0.71))) ) {\n            //float radius = (iMouse_uv.x - 0.7)/(0.9 - 0.7);\n            updated = true;\n        } else if ( all(lessThanEqual(vec2(0.7,0.8),iMouse_uv)) &&\n                    all(lessThanEqual(iMouse_uv,vec2(0.9,0.81))) ) {\n            updated = true;\n        } else if ( all(lessThanEqual(vec2(0.7,0.9),iMouse_uv)) &&\n                    all(lessThanEqual(iMouse_uv,vec2(0.72,0.92))) ) {\n            updated = true;\n        }\n    }\n    \n    // accumulate previous samplers.\n    if (!updated && !traced) {\n        vec4 params = texelFetch(iChannel0, ivec2(Bufer_A_size,0), 0);\n        if ( all(lessThanEqual(vec2(0.7,0.7),uv)) &&\n             all(lessThanEqual(uv,vec2(0.9,0.71))) ) {\n            if ( distance(uv,vec2(0.7+params[2]*0.2,0.705))<0.02 ) {\n                fragColor.rgb = vec3(0.0,0.0,1.0);\n            } else {\n                fragColor.rgb = vec3(1.0);\n            }\n        } else if ( all(lessThanEqual(vec2(0.7,0.8),uv)) &&\n                    all(lessThanEqual(uv,vec2(0.9,0.81))) ) {\n            if ( distance(uv,vec2(0.7+((log(params[0])/log(10.0)+3.0)/2.0)*0.2,0.805))<0.01 ) {\n                fragColor.rgb = vec3(0.0,0.0,1.0);\n            } else {\n                fragColor.rgb = vec3(1.0);\n            }\n        } else if ( all(lessThanEqual(vec2(0.7,0.9),uv)) &&\n                    all(lessThanEqual(uv,vec2(0.72,0.92))) ) {\n            if ( params[3] != 0.0 ) {\n                fragColor.rgb = vec3(0.0,0.0,1.0);\n            } else {\n                fragColor.rgb = vec3(1.0);\n            }\n        } else {\n            fragColor.rgb = texelFetch(iChannel1,ivec2(ixy),0).rgb;\n        }\n    \n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}