{"ver":"0.1","info":{"id":"Dlcfz8","date":"1700922404","viewed":26,"name":"[WIP] Micro Planet 1.2","username":"codeforger","description":"pixel shaded planet","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["pixel","planet"],"hasliked":0,"parentid":"dttfzr","parentname":"[WIP] Micro planet 1.1"},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 planet = vec4(1024/2,576/2,300, 1);\nconst float PLANET_SIZE = 200.;\nconst float ATMO_SIZE = 260.;\nconst vec3 sunVector = vec3(1, 1, -1);\n//const vec3 sunVector = vec3(1, 0, 0);\nconst int MARCH_MAX = 100;\nconst float DST_MAX = 600.;\nconst float DST_THRESHOLD = .1;\nconst float CONTINENT_SCALE = 1.;\nconst float CONTINENT_HEIGHT = 9.;\nconst float MOUNTAIN_SCALE = 4.;\nconst float MOUNTAIN_HEIGHT = 50.;\nconst float HILL_SCALE = 6.;\nconst float HILL_HEIGHT = 50.;\n\nvec3[] colors = vec3[] (\n\n        vec3( 1.0, 0.0, 0.0 ), // error color\n        vec3( 0.2, 0.5, 0.2 ), // planet grass color\n        vec3( .0, 0., 1. ),    // water color\n        vec3( 0.5, 1.0, 0.5 ),\n        vec3( 0.5, 0.5, 1.0 ),\n        vec3( 0.5, 1.0, 1.0 ),\n        vec3( 1.0, 0.5, 1.0 ),\n        vec3( 1.0, 1.0, 0.5 )\n);\n\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    //float rand = texture(iChannel0, intPos / 64.0).r; \n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoiseOld(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    return 1.-texture(iChannel0, pos/15.).r*2.;\n}\n\nfloat getNoiseHeight(vec3 vecToPlanet) {\n\n    float ang = atan(vecToPlanet.x / vecToPlanet.z) + iTime/3.;\n    float noise = (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * CONTINENT_SCALE))/CONTINENT_HEIGHT;\n    noise += (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * MOUNTAIN_SCALE))/MOUNTAIN_HEIGHT;\n    noise += (Pseudo3dNoise(vec3(cos(ang), vecToPlanet.y/(300./2.), sin(ang)) * HILL_SCALE))/HILL_HEIGHT;\n    \n    return noise;\n}\n\nvec4 colorAndDistanceToScene(vec3 point){\n\n    vec4 retPlanet = vec4(colors[int(planet.a)], 0);\n    vec3 vecToPlanet = planet.xyz - point;\n    float noise = getNoiseHeight(vecToPlanet);\n    float planetRawDst = distance(point, planet.xyz + noise * vecToPlanet) - PLANET_SIZE;\n    retPlanet.a = planetRawDst; // + (Pseudo3dNoise(vec3((point.x)/60. + iTime, point.y/60.,0))*20.);\n    retPlanet.xyz += (distance(point, planet.xyz) - PLANET_SIZE) / 20.;\n    if(abs(vecToPlanet.y) > 150.) {\n        retPlanet.xyz = clamp(retPlanet.xyz + (vec3(1)*((abs(vecToPlanet.y)-150.)/50.)), vec3(0), vec3(1));\n    }\n\n    if((distance(point, planet.xyz) - PLANET_SIZE) / 20. > .5) {\n        retPlanet.xyz = (vec3(1));\n    }\n\n    vec4 retSea = vec4(colors[2], 0);\n    retSea.a = distance(point, planet.xyz) - PLANET_SIZE;\n    \n    retSea.xyz -= planetRawDst / 60.;\n\n    return retPlanet.a < retSea.a ? retPlanet: retSea;\n}\n\nfloat distanceToAtmosphere(vec3 point){\n    return distance(point, planet.xyz) - ATMO_SIZE;\n}\nconst vec4 vec4Zero = vec4(0); \n\n\nfloat marchToSun(vec3 uv) {\n    vec3 uv2 = vec3(uv.xy, uv.z - DST_THRESHOLD*4.);\n    float dst = 0.;\n    for(int i = 0; i < MARCH_MAX; i++) {\n        vec4 colAndDist = colorAndDistanceToScene(vec3(uv2 + (sunVector * dst)));\n        dst += colAndDist.a;\n        if(dst > DST_MAX) {\n            return 1.-float(i)/float(MARCH_MAX);\n        }\n        \n        if(colAndDist.a < DST_THRESHOLD){\n            return 0.;\n        }\n        \n    }\n    \n    return 1.;\n}\n\nvec4[2] march(vec2 uv) {\n    float dst = 0.;\n    vec3 lightFromAtomsphere = vec3(0);\n    for(int i = 0; i < MARCH_MAX; i++) {\n        vec4 colAndDist = colorAndDistanceToScene(vec3(uv, dst));\n        float dstToAtmo = distanceToAtmosphere(vec3(uv, dst));\n        if (dstToAtmo < 0.) {\n            lightFromAtomsphere += vec3(.529, .808, .922) * min(colAndDist.a, 10.) * (marchToSun(vec3(uv, dst)));\n            dst += min(colAndDist.a, 10.);\n        } else {\n            dst += dstToAtmo + 10.;\n        }\n        if(dst > DST_MAX) {\n            return vec4[2](vec4Zero, vec4(i, lightFromAtomsphere));\n        }\n        \n        if(colAndDist.a < DST_THRESHOLD){\n            return vec4[2](vec4(colAndDist.xyz, dst), vec4(i, lightFromAtomsphere));\n        }\n        \n    }\n    \n    return vec4[2](vec4Zero, vec4(100, lightFromAtomsphere));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    planet = vec4(iResolution.xy/2.,300, 1);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - vec2(ivec2(fragCoord)%8);\n    //vec2 uv = fragCoord;\n\n\n    vec4[2] marchInfo = march(uv);\n    vec4 colorAndDist = marchInfo[0],\n        hitInfo = marchInfo[1];\n    float dst = (1.-((colorAndDist.a - 100.)/DST_MAX));\n    //float itrs = clamp(float(hitInfo.x)/float(MARCH_MAX), 0., .5);\n    float sunLightRaw = marchToSun(vec3(uv, colorAndDist.a));\n    //float sunLightPlanet = (colorAndDist.a == DST_MAX ? 0. : sunLightRaw);\n    float sunLight = sunLightRaw;\n    //float sunLightAtmos =  (((sunLightRaw) *marchToSun(vec3(uv, planet.z - sunVector.z*length(planet.xy-uv)))) / 4. * 3. + .25);\n    // Output to screen\n    fragColor = vec4(clamp(\n    colorAndDist.xyz*dst * sunLight + hitInfo.gba/DST_MAX,\n    vec3(0,0,0),\n    vec3(1,1,1)\n    ) ,1.0);\n    //fragColor = vec4(vec3(.7, .7, 1) * itrs * sunLightAtmos,1.0);\n    //fragColor = vec4(colorAndDist.aaaa);\n    //fragColor = vec4(colorAndDist.xyz, 0);\n    //fragColor = vec4(hitInfo.y/DST_MAX,0,0, 0);\n}","name":"Image","description":"","type":"image"}]}