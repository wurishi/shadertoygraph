{"ver":"0.1","info":{"id":"WtjBDt","date":"1647591855","viewed":97,"name":"Communicating with space","username":"MapleSyrupCS6","description":"MapleStudy","likes":6,"published":1,"flags":8,"usePreview":0,"tags":["maplestudy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAT_BOX 0.\n#define MAT_MONITOR 1.\n#define MAT_BUTTON1 2.\n#define MAT_KEY1 3.\n#define MAT_KEY2 4.\n#define MAT_KEY3 5.\n#define MAT_KEY4 6.\n#define MAT_KEY5 7.\n#define MAT_KEY6 8.\n#define MAT_LIGHT 9.\n\n\n\nfloat rand(vec2 id)\n{\n    return fract(sin(dot(id, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 min2(vec2 a, vec2 b){\n    \n    return a.x < b.x ? a : b;\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPyramid( vec3 p, float h, float size)\n{\n  float m2 = h*h + 0.25;\n\n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= size;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n\nfloat  sdSphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec2 distanceFuncMonitor(vec3 p)\n{\n    //float p1 = sdPyramid(p*rand(p.xy), 1.0);\n    float p2 = sdPyramid(p, 0.85, 0.5);\n    vec3 q1 = rotate(vec3(p.x, p.y - 0.35, p.z + 0.4), radians(3.)*10., vec3(-0.1, 0.0, 0.0));\n    float mb = sdTriPrism(q1, vec2(0.4, 0.15));\n    float d =  max(-mb, p2);\n    float m = sdTriPrism(vec3(q1.x, q1.y, q1.z-0.3), vec2(0.38, 0.15));\n    vec2 dm = min2(vec2(d, MAT_BOX), vec2(m, MAT_MONITOR));\n    \n    vec3 br = rotate(vec3(p.x, p.y, p.z), radians(11.5)*10., vec3(-0.1, 0.0, 0.0));\n    float b1 = sdCappedCylinder(vec3(br.x, br.y+0.43, br.z-0.13), 0.03, 0.04);\n    dm = min2(dm, vec2(b1, MAT_BUTTON1));\n    \n    float b2 = sdCappedCylinder(vec3(br.x+0.2, br.y+0.43, br.z-0.13), 0.03, 0.04);\n    dm = min2(dm, vec2(b2, MAT_BUTTON1));\n    \n    float b3 = sdCappedCylinder(vec3(br.x-0.2, br.y+0.43, br.z-0.13), 0.03, 0.04);\n    dm = min2(dm, vec2(b3, MAT_BUTTON1));\n    \n    vec3 antR = rotate(vec3(p.x+0.18, p.y - 0.91, p.z + 0.3), radians(5.)*10., vec3(0.0, 0.0, 0.1));\n    float ant1 = sdCappedCylinder(vec3(antR.x-0.5, antR.y-0.2, antR.z-0.3), 0.03, 0.15);\n    dm = min2(dm, vec2(ant1, MAT_BUTTON1));\n    \n    vec3 antL = rotate(vec3(p.x+0.18, p.y -1.21, p.z + 0.3), radians(5.)*10., vec3(0.0, 0.0, -0.1));\n    float ant2 = sdCappedCylinder(vec3(antL.x+0.5, antL.y+0.3, antL.z-0.3), 0.03, 0.15);\n    dm = min2(dm, vec2(ant2, MAT_BUTTON1));\n    \n    float sph1 = sdSphere(vec3(p.x+0.4, p.y-0.75, p.z), 0.07);\n    dm = min2(dm, vec2(sph1, MAT_BUTTON1));\n    \n    float sph2 = sdSphere(vec3(p.x-0.4, p.y-0.75, p.z), 0.07);\n    dm = min2(dm, vec2(sph2, MAT_BUTTON1));\n    \n    float flo = sdCappedCylinder(vec3(p.x, p.y+0.02, p.z), 1.1, 0.02);\n    dm = min2(dm, vec2(flo, MAT_LIGHT));\n\n\n    return dm; \n    \n}\n\nvec2 distanceFuncKeyboard(vec3 p)\n{\n    float board = sdRoundBox(vec3(p.x, p.y, p.z + 0.74), vec3(0.3, 0.01, 0.15), 0.01 );\n    vec2 dm = vec2(board, MAT_BOX);\n    \n    float key1 = sdRoundBox(vec3(p.x, p.y-0.03, p.z + 0.82), vec3(0.05, 0.0, 0.05), 0.01 );\n    dm = min2(dm, vec2(key1, MAT_KEY1));\n    \n    float key2 = sdRoundBox(vec3(p.x-0.15, p.y-0.03, p.z + 0.82), vec3(0.05, 0.0, 0.05), 0.01 );\n    dm = min2(dm, vec2(key2, MAT_KEY2));\n    \n    float key3 = sdRoundBox(vec3(p.x+0.15, p.y-0.03, p.z + 0.82), vec3(0.05, 0.0, 0.05), 0.01 );\n    dm = min2(dm, vec2(key3, MAT_KEY3));\n    \n    float key4 = sdRoundBox(vec3(p.x, p.y-0.03, p.z + 0.68), vec3(0.05, 0.0, 0.05), 0.01);\n    dm = min2(dm, vec2(key4, MAT_KEY4));\n    \n    float key5 = sdRoundBox(vec3(p.x-0.15, p.y-0.03, p.z + 0.68), vec3(0.05, 0.0, 0.05), 0.01 );\n    dm = min2(dm, vec2(key5, MAT_KEY5));\n    \n    float key6 = sdRoundBox(vec3(p.x+0.15, p.y-0.03, p.z + 0.68), vec3(0.05, 0.0, 0.05), 0.01 );\n    dm = min2(dm, vec2(key6, MAT_KEY6));\n    \n    return dm;\n}\n\nvec2 distanceFuncLightning(vec3 p)\n{\n    p = vec3(p.x, p.y, p.z);\n    float top = sdPyramid(p, 1.5, 0.05);\n    vec2 dm = vec2(top, MAT_LIGHT); \n    \n    vec3 btmRot = rotate(p, radians(18.)*10., vec3(0., 0.0, 0.5));\n    float btm = sdPyramid(vec3(btmRot.x + 0.05, btmRot.y+0.05, btmRot.z), 1.5, 0.05);\n    dm = min2(dm, vec2(btm, MAT_LIGHT)); \n\n    \n    return dm;\n}\n\n\nvec2 map(vec3 p)\n{\n  \t  vec3 q1 = rotate(p, radians(-3.)*10., vec3(0.0, -0.5, 0.0));\n      vec2 df = distanceFuncMonitor(q1);\n      vec2 dfK = distanceFuncKeyboard(vec3(q1.x, q1.y-0.02, q1.z));\n    \n      vec3 q2 = rotate(q1, radians(mix(3., 3.05, 3.*sin( iTime*5.)))*10., vec3(0., 0., 0.1));\n      vec2 dfL = distanceFuncLightning(vec3(q2.x-0., q2.y-1.1, q2.z));\n      vec2 dm = min2(df, dfK);\n      dm = min2(dm,dfL );\n    \n      vec3 q3 = rotate(q1, radians(mix(6. ,6.02, 6.*sin(iTime*5.)))*10., vec3(0., 0., 0.1));\n      vec2 dfL2 = distanceFuncLightning(vec3(q3.x+0.3, q3.y-1., q3.z));\n      dm = min2(dm,dfL2 );\n      return dm;\n}\n\n\nvec3 MonitorImage(vec3 p)\n{\n    vec3 color = vec3(1.0);\n    \n    float d = sin(p.y * 300.-iTime*10.);\n    vec3 c1 = vec3(0.9, 0.8, 0.3)+0.2;\n    vec3 c2 = vec3(0.6);\n    color = mix(c1, c2, d);\n    \n    \n    return color;\n}\n\n\nvoid getSurfaceCol(vec3 p, vec2 mat, out vec3 outColor)\n{\n    outColor = vec3(0.);\n    \n    if(mat.y == MAT_BOX)\n    {\n      \toutColor = vec3(0.9, 0.3, 0.7)+0.4;  \n    }\n    else if(mat.y == MAT_MONITOR)\n    {\n        outColor = vec3(0.9, 0.8, 0.3)+0.2; \n        outColor = MonitorImage(p);\n    }\n    else if(mat.y == MAT_BUTTON1)\n    {\n       outColor = vec3(0.3, 0.7, 0.9)+0.2;  \n    }\n    else if(mat.y == MAT_KEY1)\n    {\n       outColor = vec3(0.3, 0.7, 0.9)+mix(0.2, 0.4, sin(iTime*3.));  \n    }\n        else if(mat.y == MAT_KEY2)\n    {\n       outColor = vec3(0.3, 0.7, 0.9)+mix(0.2, 0.4, sin(iTime*3.+4.));\n    }\n        else if(mat.y == MAT_KEY3)\n    {\n       outColor = vec3(0.3, 0.7, 0.9)+mix(0.2, 0.4, sin(iTime*3.+3.)); \n    }\n        else if(mat.y == MAT_KEY4)\n    {\n       outColor = vec3(0.3, 0.7, 0.9)+mix(0.2, 0.4, sin(iTime*3.+5.));\n    }\n        else if(mat.y == MAT_KEY5)\n    {\n       outColor = vec3(0.3, 0.7, 0.9)+mix(0.2, 0.4, sin(iTime*3.+2.)); \n    }\n        else if(mat.y == MAT_KEY6)\n    {\n       outColor = vec3(0.3, 0.7, 0.9)+mix(0.2, 0.4, sin(iTime*3.+1.)); \n    }\n    else if(mat.y == MAT_LIGHT)\n    {\n       outColor = vec3(0.9, 0.8, 0.3)+0.2;  \n    }\n    else\n    {\n        outColor = vec3(0.0, 0.4, 0.3);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 camPos = vec3(0.0, 0.35, -2.4);\n    float screenZ = 2.5;\n    vec3 rayDir = normalize(vec3(uv, screenZ));\n    vec3 lightDir = normalize(vec3(1., 1., 10.));\n    \n    vec2 dist = vec2(0.);\n    float depth = 0.0;\n    vec3 rayPos = vec3(0.0);\n    vec3 col = vec3(1.0);\n    \n    \n    for(int i = 0;  i < 256; i++)\n    {\n\t\trayPos = camPos + (rayDir * depth);\n        dist = map(rayPos);\n        \n        if(dist.x < 0.0001)\n        {\n            vec3 color;\n            //col = 1.0 - vec3(float(i) / 99.);\n            //col = 1.0 - vec3(0.7/float(i) / 99., 0.5/float(i) / 99., 0.9 /float(i) / 99.);\n            //col = 1.0 - vec3(0.1*float(i) / 99., 0.5*float(i) / 99., 0.9 *float(i) / 99.);\n            //col = 1.0 - vec3(0.7+float(i) / 99., 0.5+float(i) / 99., 0.9 +float(i) / 99.);\n            col = 1.0 + vec3(float(i) / 99.);\n            //col = 1.0 + vec3(0.7/float(i) / 99., 0.5/float(i) / 99., 0.9 /float(i) / 99.);\n            getSurfaceCol(rayPos, dist, color);\n            col *= color;\n            break;\n        }\n        else\n        {\n          \tcol = vec3(0.7, 0.5, 0.9);  \n        }\n        \n        \n        depth += dist.x;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 bd(float time)\n{\n  return vec2(pow(fract(-time*3.),9.));\n}\n\nvec2 noise2(float time)\n{\n    return vec2(clamp(fract(sin(time*8.3)*1e6)-.4, 0.0, 0.09)); \n}\n\nvec2 sound2(float time)\n{\n    return vec2(clamp(sin(6.2831*100.*time)*fract(mod(-2.*time, 5.)/9.), 0.0, 0.5));\n}\n\nvec2 sound3(float time)\n{ \n    //return vec2(sin(6.2831*1500.*time)*fract(-2.*time));\n    return vec2(sin(6.4831*1300.*time)*pow(fract(2.*-time), 4.));  \n}\n\n\n\nvec2 fm(float time)\n{\n  float r = 3.0;// FM/F\n  float freq = 440.0;//F\n  return vec2(sin(6.4831*freq*time+sin(6.4831*freq*r*time))*fract(-time*1.));\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    //vec2 sound = sound3(time);\n    vec2 sound = vec2(0, 0);\n    return sound;  \n\n}\n","name":"Sound","description":"","type":"sound"}]}