{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nvec3 ExtractCameraPos(mat4 a_modelView)\n{\n  mat3 rotMat =mat3(a_modelView[0].xyz,a_modelView[1].xyz,a_modelView[2].xyz);\n  vec3 d =  a_modelView[3].xyz;\n \n  vec3 retVec = -d * rotMat;\n  return retVec;\n}\n\nfloat smoothCurves(float x)\n{\n  return (x<0.)?0.:x;\n}\n\nfloat f(vec3 c)\n{\n    float d1 = length(c)-1.3;\n    float d2 = distance(c,vec3(0.,0.,1.))-.5;\n    float e = mix(d1,d2,smoothCurves(d1-d2));\n    return e;\n}\n\nvec3 normal(vec3 p) {\n  vec3 e = vec3(.1, 0.0, 0.0);\n  vec3 n;\n  n.x = f(p + e.xyy) - f(p - e.xyy);\n  n.y = f(p + e.yxy) - f(p - e.yxy);\n\tn.z = f(p + e.yyx) - f(p - e.yyx);\n\treturn normalize(n);\n}\n\nvec3 cool(vec2 p)\n{\n  vec2 q = vec2(p.y * cos(p.x), p.y*sin(p.x));\n  float f = fbm (q);\n  \n\t\n\tvec3 pupil = vec3(0.);\n\tvec3 border = vec3(0.9,0.6,0.2);\n\tvec3 blue= mix( vec3( 0.0, 0.3, 0.4 ), vec3(0.2,0.5,0.4), fbm (20.*q));\n\n\tvec3 nerf = mix (vec3( .8,0.,0.), vec3(1.),abs(cos(p.x*2. + f*5.)) +.4 );\t\n\t\t\n\tf = smoothstep( 0.3, 1.0, fbm( vec2(25.0*p.x,6.0*p.y) ) );\n\tborder = mix( border, vec3(1.), f );\n\tblue = mix( blue, vec3(1.), f );\n\t\n\tf = smoothstep( 0.3, 1.0, fbm( vec2(50.0*p.x,12.*p.y) ) );\n\tborder = mix( border, vec3(0.), f );\n\tblue = mix( blue, vec3(0.), f );\n\t\n\tvec3 color = mix(pupil , border, smoothstep(.07, .1, p.y/3.14));\n\tcolor = mix(color, blue, smoothstep(.06, .15, p.y/3.14));\n  color = mix(color, vec3(0.), smoothstep(.15, .16, p.y/3.14));\n  color = mix(color, vec3(1.), smoothstep(.15, .17, p.y/3.14));  \n\tcolor = mix(color, nerf, smoothstep(.17, .5, p.y/3.14));\n\t\n\treturn color;\n\t\n}\n\nvec2 cart2spherical( vec3 pos )\n{\n        // code from colbert et al.\n\n        vec3 npos = normalize(pos);\n\n        float phi = atan(npos.y,npos.x);\n        phi = (phi>0.)?phi:(2. * 3.14 + phi);\n\n        float theta = acos(npos.z);\n\n        return vec2( phi , theta );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy.xy;\n  p.x *= iResolution.xy.x/iResolution.xy.y;\n\n  vec3 l = normalize(vec3(-1.,1.,1.));\n    // camera\n    vec2 pos = (iMouse.xy / iResolution.xy) * vec2(6.28, 3.14) - vec2(3.14, 1.57); // rotation en x sur 2pi et sur pi en y\n    float cosx = cos(pos.x);\n    float sinx = sin(pos.x);\n    float cosy = cos(pos.y);\n    float siny = sin(pos.y);\n    vec3 ro = vec3(sinx * cosy, -siny, cosx * cosy) * 3.5;\n    vec3 ww = normalize(vec3(0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n  vec3 color = vec3(.5,.3,.2)*length(p);\n  color = pow(texture(iChannel1, rd).rgb, vec3(2.2));\n  float e, d =0.;\n\n  vec3 c;\n  for(int i = 0; i<64; i++)\n  {\n    c = ro + d *rd;\n\n    e = f(c);\n    if(e < .001)\n    {\n       break;\n    }\n    d+=e;\n  }\n\n  // Refraction and reflection\n  if(e < .001)\n  {\n    vec3 n = normal(c);\n    vec3 newd = refract(rd,n,0.75);\n    float d2 = 0.;\n\tvec3 m ;\n    for(int j =0; j<32; j++)\n    {\n      m = c + d2 * newd  ;\n      float e2 = length(m)-1.;\n      if(e2<.005)\n      {\n        color = cool(cart2spherical(m))*(1.-d2)*1.2;\n        break;\n      }\n      d2+=e2;\n    }\n    \n      // Add the reflection\n      vec3 s = normalize(l);\n      vec3 v = -rd;\n      vec3 h = normalize(v+s);\n      color += pow(max(0.0, dot(n,h)), 125.);\n      color += pow( 0.4*texture(iChannel0, reflect(rd, n)).rgb, vec3(4.4));\n\t  \n\t  float opacity = length(c-m);\n\t  \n\t  color *= ( 1.75*opacity);\n  }\n  \n  fragColor = vec4(color, 1.0); \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XslXW8","date":"1400100242","viewed":227,"name":"Experiment with an eyeball","username":"Saorel","description":"Old simple experiment created in March 2013, it is not really finished, I should work a little bit more on the shape.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raytracing","experiment"],"hasliked":0,"parentid":"","parentname":""}}