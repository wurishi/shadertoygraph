{"ver":"0.1","info":{"id":"ttc3R2","date":"1577179925","viewed":173,"name":"Droste 2","username":"voax","description":"droste effect based on http://roy.red/droste-.html , http://roy.red/infinite-regression-.html#infinite-regression and https://www.shadertoy.com/view/4tlGRn\n\nfixed zoom speed, added twists parameter","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["droste"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int twists = 1;\nfloat scale = 0.5;\nfloat zoom = 4.0;\n\nvec2 complexExp(in vec2 z){\n\treturn vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y));\n}\nvec2 complexLog(in vec2 z){\n\treturn vec2(log(length(z)), atan(z.y, z.x));\n}\nvec2 complexMult(in vec2 a,in vec2 b){\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\nfloat complexMag(in vec2 z){\n\treturn float(pow(length(z), 2.0));\n}\nvec2 complexReciprocal(in vec2 z){\n\treturn vec2(z.x / complexMag(z), -z.y / complexMag(z));\n}\nvec2 complexDiv(in vec2 a,in vec2 b){\n\treturn complexMult(a, complexReciprocal(b));\n}\nvec2 complexPower(in vec2 a, in vec2 b){\n\treturn complexExp( complexMult(b,complexLog(a))  );\n}\nconst float TWO_PI = 3.141592*2.0;\n\nfloat f(float x,float n){\n    return pow(n,-floor(log(x)/log(n)));\n}\n\nvec2 droste(vec2 z, float zoom, float twists, float scale) {\n\tfloat ratio = 1.0 / scale;\n\tfloat angle = atan(log(ratio) * twists/(TWO_PI));\n    z = complexExp(complexDiv(complexLog(z), complexExp(vec2(0,angle))*cos(angle)));\n    z *= zoom;\n    vec2 a_z = abs(z);\n    z *= f(max(a_z.x,a_z.y)*2.,ratio);\n    return z/ratio;\n}\n\nvec4 checkerboard(vec2 uv) {\n    vec2 q = abs(uv * 10.0);\n    if (int(q.x) % 2 == int(q.y) % 2)\n        return vec4(1.0);\n    else\n        return vec4(0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iMouse.z > 0.5) {\n    \tscale = iMouse.x / iResolution.x;\n    \ttwists = int(floor(10.0 * iMouse.y / iResolution.y) + 0.5);\n    } else {\n        scale = 0.5;\n        twists = 1;\n    }\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 z = uv * 2.0 - 1.0;\n    // z.x *= iResolution.x/iResolution.y;\n    \n    // zoom:\n\tfloat FT = fract(iTime);\n\tFT = log((1.0/scale-1.0)*FT+1.0)/log(1.0/scale); \n    zoom = 1.0+FT*(scale-1.0);\n    \n    z = droste(z, zoom, float(twists), scale);\n\n    uv = (z + 1.0) / 2.0;\n    fragColor = texture(iChannel0, uv) /* * checkerboard(uv) */;\n}","name":"Image","description":"","type":"image"}]}