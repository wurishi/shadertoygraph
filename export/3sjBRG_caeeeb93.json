{"ver":"0.1","info":{"id":"3sjBRG","date":"1590279154","viewed":59,"name":"Sinewave pattern","username":"timeisbeautifulhere","description":"I couldn't replicate this if I tried","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","wave","sine","pattern","accident"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define PI 3.14159\n\n#define FUNK_SPEED 2.0\n#define SCROLL_SPEED 3.0\n\n//Transform a value that to something between [-1,1].\n//A wrapping function gone horribly wrong.\nfloat weirdWrapFunk(float val){\n    \n    //My mini algo only works for positive numbers.\n    //Multiply by multiples of range (2) to make number\n    //positive without affecting result.\n    if(val < 0.0){\n    \tfloat factor = abs(floor(val));\n        val = val + (2.0 * factor);\n    }\n    \n    //f(x) = x - floor((x-minx)/(max-min)) - 1\n    float res = (val) - floor((val+1.0)/2.0) - 1.0;\n    \n    return res;\n}\n\n//Check if in sine wave.\n//Expects uv to be in [-1,1]\nbool checkInSine(vec2 uv){\n    //Sine wave = Asine(wt + 0)\n    \n    //get x in radians\n    float x = (uv.x + 1.0) * (PI);\n    \n    float expected = sin(x);\n    float actual = uv.y;\n    \n    //Apply weird transform, then wrap to [-1,1]\n    expected = weirdWrapFunk(expected + (iTime * (SCROLL_SPEED)));\n    expected = mod(expected, 2.0) - 1.0;\n    actual = weirdWrapFunk(actual + (iTime * FUNK_SPEED));\n    actual = mod(actual, 2.0) - 1.0;\n    \n    \n    return abs(expected - actual) < 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Default shadertoy junk\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col,1.0);\n    \n    //normalize [-1,1]\n    uv = ((2.0*fragCoord) / iResolution.xy) - 1.0;\n    \n    if(checkInSine(uv)){\n        fragColor = vec4(vec3(1.0,1.0,1.0),1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}