{"ver":"0.1","info":{"id":"slsGWl","date":"1623196694","viewed":79,"name":"simple 4d projection","username":"hpx","description":"I stumbled upon this site on the weekend and now I also want to write my own ray marcher.\nThe domain is already quite explored, so I have added a dimension in order to have to think a little while looking at tutorials.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","4d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The scene is static and mouse controls the camera around the origin.  Color is based on normal.\n// mouse click locks 2 rotation planes to the clicked location and moving the mouse then controls other two planes\n// if you hold click in the middle, the locked rotators are unit matrix and the controllable rotators\n// are equivalent to rotation around x and y axis\n\n#define M_PI 3.14159265359\n\n// tried to write this without branching, which turned out ugly and i'm not even sure if it's faster\nfloat m(int row, int column, int axes, float value)\n{\n    int bits = axes & (1 << row | 1 << column);\n    return float(bits == 0) * value + float(bits != 0) * float(row == column);\n} \n\n// compute a rotator plane based on two bit-coded axes (1 = x, 2 = y, 4 = z, 8 = w)\nmat4 rotator(float angle, int a)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(m(0,0,a, c), m(0,1,a,-s), m(0,2,a,-s), m(0,3,a,-s),\n                m(1,0,a, s), m(1,1,a, c), m(1,2,a,-s), m(1,3,a,-s),\n                m(2,0,a, s), m(2,1,a, s), m(2,2,a, c), m(2,3,a,-s),\n                m(3,0,a, s), m(3,1,a, s), m(3,2,a, s), m(3,3,a, c));\n}\nconst float inf = 1. / 0.;\n\nvec4 mouse_rotator(vec4 vector)\n{\n    vec2 angle = 2. * M_PI * iMouse.xy / iResolution.xy;\n    vec2 angle2 =  2. * M_PI * iMouse.zw / iResolution.xy;\n    \n    return rotator(angle.x, 1 << 1 | 1 << 3) *\n           rotator(angle.y, 1 << 0 | 1 << 3) *\n           rotator(angle2.x, 1 << 0 | 1 << 1) *\n           rotator(angle2.y, 1 << 0 | 1 << 2) *\n      //     rotator(iTime * 0.3, 1 << 0 | 1 << 2) *\n           vector;\n}\n\n// vector folds with min/max\nfloat vmin(vec2 v) { return min(v.x, v.y); }\nfloat vmin(vec3 v) { return min(v.x, vmin(v.yz)); }\nfloat vmin(vec4 v) { return min(v.x, vmin(v.yzw)); }\n\nfloat vmax(vec2 v) { return max(v.x, v.y); }\nfloat vmax(vec3 v) { return max(v.x, vmax(v.yz)); }\nfloat vmax(vec4 v) { return max(v.x, vmax(v.yzw)); }\n\n// used sdf from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(float radius, vec4 point)\n{\n    return length(point) - radius;\n}\n\nfloat sdBox(vec4 bounds, vec4 point)\n{\n    vec4 q = abs(point) - bounds;\n  \n    return length(max(q, 0.0)) + min(vmax(q), 0.0);\n}\n\nfloat sdScene(vec4 point)\n{\n    point -= vec4(1.,0.,0.,0.);\n    return max(sdBox(vec4(1.), point), -sdSphere(1.3, point));    \n}\n\n// vector field functions would take care of normal computation nicely, but they probably aren't very good in the remaining uses\nvec4 sdNormal(vec4 point)\n{\n    const float eps = 0.00001; // sampling precision must not be smaller than 1e-7 and should be big enough to mitigate rouding errors\n\n    // the code is absolutely disgusting and needs an abstraction\n    float sample_o = sdScene(point); // this can be an argument\n    float sample_x = sdScene(point + vec4(eps, 0., 0., 0.));\n    float sample_y = sdScene(point + vec4(0., eps, 0., 0.));\n    float sample_z = sdScene(point + vec4(0., 0., eps, 0.));\n    float sample_w = sdScene(point + vec4(0., 0., 0., eps));\n    \n    return vec4(sample_x - sample_o, sample_y - sample_o, sample_z - sample_o, sample_w - sample_o);\n}\n\nvec4 trace(vec4 trace_origin, vec4 trace_direction)\n{\n    // the vector has to be normalized in order to leverage distance function aided stepping\n    trace_direction = normalize(trace_direction);\n\n    float dist = 0.;\n    \n    // the basic idea is to traverse along the vector direction until we hit something\n    // the distance function tells us how far is the closest object, so we can always make a step of that length\n    \n    const float eps = 0.00001; // a tolerance for the hit, worked fine in place of a iteration limit\n    \n    while (true) {\n        float closest = sdScene(trace_origin + trace_direction * dist);\n        if (closest <= eps)\n            break;\n        \n        dist = dist + closest;\n        if (dist == inf) // we have missed everything in the world.  waiting for inf takes a few iterations\n            return vec4(0.);\n    }\n    \n    return (normalize(sdNormal(trace_origin + trace_direction * dist)) + 1.) * 0.5; // debug display of the hit surface\n}\n\nvec4 canvas_projection(vec2 point)\n{\n    vec2 unit = point / iResolution.xy;\n                        \n    return mouse_rotator(vec4(unit.x - 0.5, unit.y - 0.5, -8.2, 0.) * vec4(iResolution.x / iResolution. y, 1., 1., 1.));\n} \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // the point from which rays originate (eye/camera)\n    vec4 ray_origin = mouse_rotator(vec4(0., .0, -10., .0));\n    \n    // canvas is a rectangle that the rays pass through and can be freely trasnformed in 4d\n    vec4 canvas_pass_through_point = canvas_projection(fragCoord);\n    \n    vec4 ray_direction = canvas_pass_through_point - ray_origin;\n    \n    vec4 color = trace(canvas_pass_through_point, ray_direction);\n    \n    // Output to screen\n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}