{"ver":"0.1","info":{"id":"mdGfRR","date":"1697818776","viewed":46,"name":"Bounds of sphere projection","username":"Verlet","description":"Testing exact formulas for calculating bounds in screen space of projected 3D sphere given its radius (in view space) and its center (in clip or view space)\n\nSphere projection based on https://www.shadertoy.com/view/MljXWD by jeannekamikaze","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["testing","projection","formula","bounds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n https://www.shadertoy.com/view/mdGfRR\n\n Testing a formula for calculating exact axis aligned bounds in screen space of a projected sphere given its view or clip space coords and world space radius.\n This is probably a rather special use case...\n If you find this useful, I would love to know about it :)\n\n The basic formula used here for the \"shadow offset\" from sphere center:\n    d = [-rrx +- sqrt(zz * rr * (zz - rr + xx))] / (rr-zz)\n\n was derived from the pythagorean formula applied to four right triangles:\n    dd = TT + rr\n    ll = PP + rr\n    ll = zz + xx\n    QQ = zz + (x+d)^2\n , where we use the segment lengths on the two sphere tangents that intersect origo of the projection:\n    P = Q + T\n P is distance along tangent from origo to sphere intersection.\n Q is distance along tangent from origo to z-plane intersecting sphere center\n T is the _signed_ distance from z-plane to sphere intersection.\n\n Note: the formulation is valid for both tangents, so the two solutions applies to both offsets.\n The (x+d) term makes the whole thing dependent on the signs of x and d.\n\n Known issues: Assumes z<0\n\n Created by Verlet (Martin Bjerregaard Nielsen)\n Twitter/X: @Verlet\n\n (Uses code from https://www.shadertoy.com/view/MljXWD by jeannekamikaze that demos an approximate solution.)\n*/\n\n#define TO_RAD 0.01745329251\n\nfloat fovy = 140.0 * TO_RAD;\nfloat near = 0.1;\nfloat far  = 200.0;\n\nvec3  sphere_center = vec3(0,0,-100);\nfloat sphere_radius = 40.0;\n\nvec3 L = vec3(0.1, 0.1, 1.0);\n\nmat4 projection (float fovy, float aspect, float near, float far)\n{\n    float f = 1.0 / tan(fovy/2.0);\n    return mat4\n        (f/aspect, 0,                      0,  0\n        ,0,        f,                      0,  0\n        ,0,        0,  (near+far)/(near-far), -1\n        ,0,        0, 2.*near*far/(near-far),  0);\n}\n\n// project from view space to normalized device coordinate system\nvec2 project (vec3 p)\n{\n    float r = iResolution.x / iResolution.y;\n\n    vec4 clip = projection(fovy, r, near, far) * vec4(p, 1.0);\n    vec4 ndc  = clip / clip.w;\n    return ndc.xy*0.5 + 0.5;\n}\n\n/*\n Computes \"shadow bounds\" of sphere\n Given sphere position and radius in view space, returns the extent of the spheres shadow (as seen by light centered at the origin)\n as (x0, x1, y0, y1), where eg. x0 is the offset from the spheres center.x where the edge of the spheres shadow intersects the z-plane passing through the center of the sphere.\n*/\nvec4 projected_sphere_shadow(vec3 center_view, float radius_world) {\n    float x = center_view.x;\n    float y = center_view.y;\n    float z = center_view.z;\n    float r = radius_world;\n \n    float zz = z*z;\n    float rr = r*r;\n    float rr_zz = (rr - zz);\n    \n    float rrx = rr*x;\n    float rootx = sqrt((zz * rr) * (-rr_zz + (x*x)));\n    float dx0 = (-rrx + rootx) / rr_zz;\n    float dx1 = (-rrx - rootx) / rr_zz;\n\n    float rry = rr*y;\n    float rooty = sqrt((zz * rr) * (-rr_zz + (y*y)));\n    float dy0 = (-rry + rooty) / rr_zz;\n    float dy1 = (-rry - rooty) / rr_zz;\n\n    return vec4(dx0, dx1, dy0, dy1);\n}\n\n\nvec3 viewFromClip(vec4 clip, vec4 tangents) {\n    float f = 1.0 / ((tangents.z+tangents.w) * 0.5);\n    float aspect = (tangents.x+tangents.y) / (tangents.z+tangents.w);\n\n    float x = clip.x / (f/aspect);\n    float y = clip.y / f;\n    float z = -clip.w;\n    return vec3(x,y,z);\n}\n\n\n// compute bounds of the projection of the sphere\nvec4 projected_sphere_bounds(vec4 center_clip, float radius, vec4 tangents)\n{\n    // Convert from clip space to view space \n    vec3 center_view = viewFromClip(center_clip, tangents);\n    vec4 bounds_view = projected_sphere_shadow(center_view, radius);\n\n    // Convert back to NDC space\n    float f = 1.0 / ((tangents.z+tangents.w) * 0.5);\n    float aspect = (tangents.x+tangents.y) / (tangents.z+tangents.w);\n    float z = abs(center_clip.w);\n    return 0.5 * f * vec4(bounds_view.xy / aspect, bounds_view.zw) / z;\n}\n/* Reference\nfloat projected_sphere_max_aa_bound(vec4 center_clip, float radius, vec4 tangents) {\n    vec4 spb = projected_sphere_bounds(center_clip, radius, tangents);\n    vec4 pb = abs(spb);\n    float aspect = (tangents.x+tangents.y) / (tangents.z+tangents.w);\n   return max(max(pb.x * aspect, pb.y* aspect), max(pb.z, pb.w));\n}\n*/\n\nvec2 projected_sphere_shadow2D(float x, float z, float radius_world) {\n    float r = radius_world;\n \n    float zz = z*z;\n    float rr = r*r;\n    float rr_zz = (rr - zz);\n    \n    float rrx = rr*x;\n    float rootx = sqrt((zz * rr) * (-rr_zz + (x*x)));\n    float dx0 = (-rrx + rootx) / rr_zz;\n    float dx1 = (-rrx - rootx) / rr_zz;\n\n    return vec2(dx0, dx1);\n}\n\nfloat projected_sphere_max_aa_bound(vec4 center_clip, float radius, vec4 tangents) {\n    // Convert from clip space to view space \n    vec3 center_view = viewFromClip(center_clip, tangents);\n\n    float z = abs(center_view.z);\n    float x = (abs(center_view.x) < abs(center_view.y)) ? center_view.y : center_view.x;\n    vec2 bounds_view = projected_sphere_shadow2D(x, z, radius);\n\n    // Convert back to NDC space\n    float f = 1.0 / ((tangents.z+tangents.w) * 0.5);\n    float aspect = (tangents.x+tangents.y) / (tangents.z+tangents.w);\n    vec4 spb = 0.5 * f * vec4(bounds_view.xy / aspect, bounds_view.xy) / z;\n \n    vec4 pb = abs(spb);\n    return max(max(pb.x * aspect, pb.y* aspect), max(pb.z, pb.w));\n}\n\nvec3 intersect_sphere (vec3 ray_dir)\n{\n    vec3 t; // x = tmin, y = tmax, z = {>0, intersection, <0 no intersection}\n    t.z = -1.0;\n    vec3 l = sphere_center - vec3(0); // ray centered at (0,0,0)\n    float l2 = dot(l,l);\n    float r2 = sphere_radius * sphere_radius;\n    float p = dot (l, ray_dir);\n    if (p < 0.0) return t; // no intersection\n    float a2 = l2 - p*p;\n    if (a2 < r2)\n    {\n        float k = sqrt(r2 - a2);\n        t.x = p-k;\n        t.y = p+k;\n        t.z = 1.0;\n        return t;\n    }\n    return t; // no intersection\n}\n\nvec3 cam_ray (vec2 texcoord)\n{\n    float d = 0.5 / tan(fovy/2.0);\n    float r = iResolution.x / iResolution.y;\n\n    return normalize(vec3((texcoord.x - 0.5) * r, texcoord.y - 0.5, -d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime + 1115.4;\n    vec2 texcoord = fragCoord.xy / iResolution.xy;\n    \n    // intersect sphere\n    sphere_center = sphere_center\n                  + vec3(60.0*sin(1.5*t), -40.0*cos(2.7*t), 60.0*sin(0.7*t)*cos(pow(t,1.05)));\n    vec3 ray = cam_ray(texcoord);\n    vec3 intersection = intersect_sphere(ray);\n    \n    // circle center and radius\n    float aspect = iResolution.x / iResolution.y;\n    float tanN = tan(fovy * 0.5);\n    float tanS = tan(fovy * 0.5);\n    float tanW = aspect * tanN;\n    float tanE = aspect * tanN;\n    vec4 tangents = vec4(tanW, tanE, tanN, tanS);\n        \n    vec4 centerClip = projection(fovy, aspect, near, far) * vec4(sphere_center, 1.0);\n    vec4 projected_bounds = projected_sphere_bounds(centerClip, sphere_radius, tangents);\n    \n    vec2  projected_center = project(sphere_center);\n    \n    vec3 colour = vec3(0);\n    \n    // shade the sphere itself\n    vec3 albedo = 1.3 * vec3(1.2, 1.4, 1.1);\n    if (intersection.z > 0.0)\n    {\n        vec3 pmin = ray * intersection.x;\n        vec3 normal = normalize(pmin-sphere_center);\n        vec3 k = albedo * normal;\n        vec3 s = reflect(ray, normal);\n        colour += mix(k*dot(normal, normalize(L)), s, 0.3);\n    }\n    \n    // shade based on whether the fragment is within the calculated bounds\n    vec2 spherecenter_pixel = projected_center * iResolution.xy;\n\n    vec2 pixel = fragCoord;\n    float w = 3.0;\n    // Sphere center\n //   colour += smoothstep(w, 0.0, length(spherecenter_pixel - fragCoord));\n\n    // The four exact axis aligned bounds\n    vec4 bounds_pixel = projected_bounds * iResolution.xxyy;\n    vec4 dist = abs(spherecenter_pixel.xxyy + bounds_pixel - pixel.xxyy);\n    vec4 b = smoothstep(w, 0.0, dist);\n    colour += vec3(b.y + b.z, b.w, b.x + b.z);\n    \n    // The single max bound\n    float max_bound = projected_sphere_max_aa_bound(centerClip, sphere_radius, tangents);\n    vec2 max_bound_pixel = max_bound * iResolution.yy;\n    vec2 dist2 = abs(abs(spherecenter_pixel - pixel.xy) - max_bound_pixel);\n    float b2 = length(smoothstep(w, 0.0, dist2));\n    colour += vec3(0.6) * b2;\n\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"}]}