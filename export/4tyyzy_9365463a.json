{"ver":"0.1","info":{"id":"4tyyzy","date":"1536816708","viewed":81,"name":"Raymarching trus twist","username":"uynet","description":"twist","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["volumerendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Trus{\n    vec3 dir;\n    vec3 pos;\n    float r;\n    float s;\n};\n struct Sphere{\n     vec3 pos;\n     float r;\n };\nstruct Ray{\n    vec3 orig;\n    vec3 dist;\n};\n struct Metaball{\n     vec3 pos;\n};\n\n vec3 L =normalize(vec3(1));\nconst float EPS = 0.001;\nTrus trus;\n\n//trus distancefield\nfloat dist(vec3 p,Trus trus){\n  float d;\n   p -= trus.pos;\n   vec3 p_proj = p-trus.dir*(dot(p,trus.dir));\n   p_proj = trus.r * normalize(p_proj);\n   d = length(p_proj - p)-trus.s;\n   return d;\n}\nfloat dist_twist(vec3 p ,Trus trus){\n    float pich = 100.0*sin(iTime);\n    float c = cos(p.y*pich);\n    float s = sin(p.y*pich);\n    mat2 m = mat2(c,-s,s,c);\n    vec3 q = vec3(m*p.xz,p.y);\n    return dist(q,trus);\n}\n\nfloat dist_s(vec3 p,Sphere sphere){\n   return length(p-sphere.pos)-sphere.r;\n}\n\n\n\n\nRay march(Ray ray, float dist){\n                        //distance / distination\n    Ray r = ray;\n    r.orig = ray.orig + dist*ray.dist;\n    return r;\n}\n\nvec3 rotX(vec3 v, float a) {\n\ta *= 3.141592 / 180.;\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn vec3(\n\t\tv.x,\n\t\tv.y * c - v.z * s,\n\t\tv.z * c + v.y * s\n\t);\n}\n\n// 法線の計算\nvec3 getNormal(vec3 p) {\n  return normalize(vec3(\n    dist(p + vec3(EPS, 0.0, 0.0),trus) - dist(p + vec3(0),trus),\n    dist(p + vec3(0.0, EPS, 0.0),trus) - dist(p + vec3( 0),trus),\n    dist(p + vec3(0.0, 0.0, EPS),trus) - dist(p + vec3(0),trus)\n  ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    trus.dir = normalize(vec3(1));\n    //trus.dir = rotX(trus.dir,iTime*100.0);\n    trus.pos = vec3(0,0,0);\n    trus.r = 0.1;\n    trus.s = trus.r/4.0;\n   \n    \n    Sphere sphere;\n    sphere.pos = vec3(sin(iTime)*0.1,0,0);\n    sphere.r = 0.1;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    uv-=0.5;\n    uv.y*=asp;\n    \n    Ray ray;\n    ray.orig = vec3(0,0,-1);\n    ray.dist = vec3(uv,1);\n    \n    float d1;\n    float d2;\n    \n    float d = 100.0;\n    int t = 0;\n    vec3 col = vec3(0);\n    \n    while(d > EPS){\n        \n        d1 = dist_s(ray.orig,sphere);\n        d2 = dist_twist(ray.orig,trus);\n        //d = min(d1,d2);\n        d = d2;\n        ray = march(ray,d);\n        if(t++>10)break;\n        \n    }\n    if(d<=0.01){\n        vec3 norm =  getNormal(ray.orig);\n        float dif = max(dot(L,norm),0.0);\n        float spe = max(dot(L,reflect(ray.dist,norm)),0.0);\n        float amb = 0.4;\n        col = vec3(dif+spe+amb);\n        //col = norm;\n    }\n\n    // Time varying pixel color\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}