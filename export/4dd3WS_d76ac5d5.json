{"ver":"0.1","info":{"id":"4dd3WS","date":"1451992709","viewed":336,"name":"Terrain generator","username":"Draedrus","description":"Terrain generator\nUse the black bar to zoom in and out","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["procedural","2d","terrain","heightmap","flowmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/**\n* author: Pierre-Marie Plans\n* mail: pierre.plans@gmail.com\n**/\n\nvec2 river(float ter0, vec2 fuv, float e)\n{\n    vec4 ter1 = texture(iChannel0, clamp(fuv+vec2(-e, 0.0), 0.0, 1.0));\n    vec4 ter2 = texture(iChannel0, clamp(fuv+vec2(e, 0.0), 0.0, 1.0));\n    vec4 ter3 = texture(iChannel0, clamp(fuv+vec2(0.0, -e), 0.0, 1.0));\n    vec4 ter4 = texture(iChannel0, clamp(fuv+vec2(0.0, e), 0.0, 1.0));\n    \n    float x0 = ter1.x-ter0;\n    float x1 = ter2.x-ter0;\n    float y0 = ter3.x-ter0;\n    float y1 = ter4.x-ter0;\n    \n    #if 0\n    float x = x1+x0;\n    float y = y1+y0;\n    \n    #elif 0\n    float x = max(x0, x1)==x0?-max(x0, x1):max(x0, x1);\n    float y = max(y0, y1)==y0?-max(y0, y1):max(y0, y1);\n    #else\n    float x = abs(x0)>abs(x1)?x0:x1;\n    float y = abs(y0)>abs(y1)?y0:y1;\n    #endif\n    \n    return normalize(vec2(x, y));\n}\n\nvoid flowmap(\n    float blend_cycle, float cycle_speed,\n    float offset,\n    vec2 flow, float flow_speed, vec2 flow_scale,\n    vec2 uv_scale,\n    vec2 base_uv,\n    out vec2 oLayer1, out vec2 oLayer2)\n{\n\t// UV flow  calculation\n\t/****************************************************************************************************/\n\tfloat half_cycle = blend_cycle * 0.5;\n\n\tfloat phase1 = mod(offset + iTime * cycle_speed, blend_cycle);\n\tfloat phase2 = mod(offset + iTime * cycle_speed + half_cycle, blend_cycle);\n\n\t// Blend factor to mix the two layers\n\tfloat blend_factor = abs(half_cycle - phase1)/half_cycle;\n\n\t// Offset by halfCycle to improve the animation for color (for normalmap not absolutely necessary)\n\tphase1 -= half_cycle;\n\tphase2 -= half_cycle;\n\n\t// Multiply with scale to make flow speed independent from the uv scaling\n\tflow *= flow_speed * uv_scale;\n\n\toLayer1 = flow * phase1 + base_uv;\n\toLayer2 = flow * phase2 + base_uv;\n}\n\nvec4 color(vec2 uv, vec2 nuv, vec2 fuv, bool bGenTerrain)\n{\n    vec4 ter;\n    if(bGenTerrain)\n    {\n        ter = vec4(terrain(uv), 0.0, 0.0, 0.0);\n    }else\n    {\n        ter = texture(iChannel0, nuv);\n    }\n    float h = ter.r;\n    float ho = h/0.2;\n    \n    //float o = ocean(uv, h, iTime);\n    \n    vec2 riv = river(ter.r, nuv, 0.01);\n    vec3 NT = normalTerrain(uv, 0.01);\n    \n    vec2 layer1, layer2;\n    float offset = texture(iChannel1, nuv).r;\n    flowmap(\n        1.0, 1.0,\n        offset,\n        riv, 0.5, vec2(1.0, 1.0),\n        vec2(1.0, 1.0),\n        uv,\n        layer1, layer2);\n   \n    float ospeed = 0.05;\n    vec3 NO = normalOcean(layer1, riv, ho, iTime*ospeed, 0.001);\n    vec3 NO2 = normalOcean(layer2, riv, ho, iTime*ospeed, 0.001);\n    \n    NO = mix(NO, NO2, 0.5);\n    \n    //vec3 L = normalize(vec3(cos(iTime), sin(iTime), 0.2));\n    vec3 L = normalize(vec3(-0.2, 1.0, 0.2));\n    \n    float NoLO = max(0.0, dot(NO, L));\n    float NoLT = max(0.0, dot(NT, L));\n    vec3 Lr = -reflect(L, NO);\n    float VoLr = dot(Lr, vec3(0.0, 1.0, 0.0));\n    \n    float Fs = Fresnel_Schlick(1.13, 1.0, NoLO);\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    if(h<LEVEL_WATER) {\n        col = (mix(vec4(0.2, 0.3, 0.5, 1.0),\n                   vec4(0.4, 0.5, 0.7, 1.0),\n                   max(h, 0.0)/LEVEL_WATER)+Fs)*NoLO+pow(VoLr, 128.0);\n    }else if(h<LEVEL_BEACH) {\n        col = NoLT*mix(vec4(0.4, 0.4, 0.3, 1.0), vec4(0.7, 0.7, 0.5, 1.0), (h-0.2)/0.02);\n    }else if(h<LEVEL_GRASS) {\n        col = NoLT*mix(vec4(0.6, 0.9, 0.5, 1.0), vec4(0.4, 0.6, 0.3, 1.0), (h-0.22)/0.28);\n    }else if(h<LEVEL_FOREST) {\n        col = NoLT*mix(vec4(0.4, 0.6, 0.3, 1.0), vec4(0.2, 0.4, 0.1, 1.0), (h-0.5)/0.2);\n    }else if(h<LEVEL_ROCK) {\n        col = NoLT*mix(vec4(0.2, 0.4, 0.1, 1.0), vec4(0.6, 0.5, 0.4, 1.0), (h-0.7)/0.2);\n    }else {\n        col = vec4(min(1.0, pow(NoLT, 0.1))*vec3(1.0), 1.0);//mix(vec4(0.6, 0.5, 0.4, 1.0), vec4(1.0), (h-0.9)/0.1);\n    }\n    if(h>=0.2 && h<0.9 && length(riv)>0.4)\n    {\n    \tcol = mix\n            (mix(vec4(0.2, 0.3, 0.5, 1.0),\n                   vec4(0.4, 0.5, 0.7, 1.0),\n                   max(h, 0.0)/0.2)*NoLO+Fs\n             , col\n             , length(riv)\n            );\n    }\n    //col = mix(vec4(riv.x, riv.y, 0.0, 1.0), col, 0.5);\n    //col = vec4(NO, 1.0);\n    //col = mix(vec4(ho), col, 0.5);\n    //col = vec4(NT, 1.0);\n    //col.rg = ter.rr;\n    //col.b = 0.0;\n    //col.rg = riv;\n    //col.rg += riv;\n    return col;\n}\n\nvec4 color_oldschool(vec2 uv, vec2 nuv, vec2 fuv, bool bGenTerrain)\n{\n    vec4 ter;\n    if(bGenTerrain)\n    {\n        ter = vec4(terrain(uv), 0.0, 0.0, 0.0);\n    }else\n    {\n        ter = texture(iChannel0, nuv);\n    }\n    float h = ter.r;\n    float ho = h/0.2;\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    float layers = 6.0;\n    \n    h = floor(max(0.0, h)*(h)*layers)/layers;\n    \n    col = mix(vec4(0.8, 0.8, 0.75, 1.0), vec4(1.0), h);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 nuv = fragCoord.xy / iResolution.xy;\n    vec2 muv = -1.0+2.0*(iMouse.xy/iResolution.xy);\n\t//vec2 uv = -1.0+2.0*puv;\n    float zoom = 0.0;\n\n    vec3 buff =LoadValue(\n        iChannel0,\n        iChannelResolution[ 0 ].xy,\n        ZOOM_STORE_TX\n    ).rgb; \n    zoom = max(buff.r, 0.01);\n    vec2 buv = buff.gb;\n    if(widget_draw(nuv, ZOOM_BOX))\n    {\n        fragColor = vec4(vec3(zoom), 1.0);\n    }\n    else\n    {\n\n        vec2 puv;\n        vec2 uv = getUV(\n            fragCoord.xy,\n            buv.xyxy*iResolution.xyxy,\n            true,\n            iResolution.xy,\n            zoom,\n            iTime,\n            puv);\n        \n        if(nuv.x<0.5)\n        {\n            fragColor = color(\n                uv,\n                nuv,\n                puv,\n                false\n    \t\t);\n            //fragColor.rg = uv;\n            //fragColor.ba = vec2(0.0, 1.0);\n        }\n        else if(nuv.x<0.75)\n        {\n                    \n            fragColor = color_oldschool(\n           \t\tuv,\n                nuv,\n                puv,\n                false\n            );\n        }\n        else\n        {\n            fragColor = texture(iChannel0, nuv).rrrr;\n        }\n    }\n    /*vec4 quad=vec4(-0.98, 0.68, -0.68, 0.98);\n    vec4 quaduv=0.5*(1.0+vec4(quad.x, quad.y, quad.z, quad.w));\n    if(uv.x>quad.x && uv.x<quad.z && uv.y>quad.y && uv.y<quad.w)\n    {\n        puv -= quaduv.xy;\n        puv /= quaduv.zw-quaduv.xy;\n        fragColor += color(\n            puv,\n            puv,\n            true\n   \t \t);\n    }*/\n    //fragColor = vec4(puv.x, puv.y, 0.0, 1.0)\n    //fragColor = texture(iChannel0, puv);\n    /*zoom = LoadValue(\n        iChannel0,\n        iChannelResolution[ 0 ].xy,\n        ZOOM_STORE_TX\n    ).r;*/\n    //fragColor = vec4(texture(iChannel0, puv));\n    //fragColor = vec4(texture(iChannel0, ZOOM_STORE_TX))*1.0;\n\t//fragColor += vec4(length(buv-nuv));\n    //fragColor = vec4(buff, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 puv = fragCoord.xy / iResolution.xy;\n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    float zoom = 1.0;\n\n    vec3 buff =LoadValue(\n        iChannel0,\n        iChannelResolution[ 0 ].xy,\n        ZOOM_STORE_TX\n    ).rgb; \n    zoom = max(buff.r, 0.01);\n    vec2 buv = buff.gb;\n    \n    //zoom = texture(iChannel0, ZOOM_STORE_TX).r;\n    float percent = 0.0;\n    bool inZoomBox = widget_box(muv, ZOOM_BOX, percent);\n    if(inZoomBox)\n    {\n        zoom = percent;\n    }\n    else\n    {\n        buv = muv;\n    }\n    //zoom = widget_percent(iMouse.xy/iResolution.xy, ZOOM_BOX);\n\n    vec2 uv = getUV(\n        fragCoord.xy,\n        buv.xyxy*iResolution.xyxy,\n        !inZoomBox,\n        iResolution.xy,\n        zoom,\n        iTime,\n    \tpuv);\n\n    float h = 0.0;\n    h = terrain(uv);\n    fragColor.r = h;\n    //fragColor = vec4(zoom, 0.0, 0.0, 0.0);\n    StoreValue(ZOOM_STORE_TX, vec4(zoom, buv.x, buv.y, 0.0), fragColor, fragCoord);\n    /*if(fragCoord.x==0.0 && fragCoord.y==0.0)\n    {\n        fragColor.r = zoom;\n    }*/\n    //fragColor.r = zoom;\n    //fragColor.g = zoom;\n    //fragColor.g = widget_percent(iMouse.xy/iResolution.xy, ZOOM_BOX);\n    //fragColor.g = widget_inBox(iMouse.xy/iResolution.xy, ZOOM_BOX)? widget_percent(iMouse.xy/iResolution.xy, ZOOM_BOX):1.0;\n    //fragColor.b = widget_draw(puv, ZOOM_BOX)?1.0:0.0;\n    //fragColor.rg = iMouse.zw/iResolution.xy;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define MOUSESPEED 10.0\n#define ZOOM 0.08\n#define PI 3.1415\n#define PI2 6.2830\n#define NWAVES 4\n\n#define AMP_ATT 1.0\n#define CHOPINESS_ATT 1.0\n#define SPEED_ATT 1.0\n\n#define EXTINCTION(E, d, mini) mini+(smoothstep(1.0, 0.0, min(1.0, d/E)))\n\n#define AMP_EXTINCTION_P 20.0\n#define NORMAL_EXTINCTION_P 20.0\n#define MIN_NORMAL_EXTINCTION 0.0\n\n#define WINDROLL\n\nvec2 MainWindDir = vec2(0.5, 0.5);\nfloat MainAmp = 1.8;\n\n#define ZOOM_BOX vec4(0.05, 0.05, 0.1, 0.4)\n#define ZOOM_STORE_TX vec2(0.0, 0.0)\n#define ZOOM_MAX 100.0\n#define ZOOM_MIN 1.0\n#define ZOOM_SCALE_INT(zoom, m, M) max(m, (1.0-zoom)*M)\n#define ZOOM_SCALE(zoom) ZOOM_SCALE_INT(zoom, ZOOM_MIN, ZOOM_MAX)\n\n#define WIP\n\n#define LEVEL_WATER 0.6\n#define LEVEL_BEACH 0.61\n#define LEVEL_GRASS 0.7\n#define LEVEL_FOREST 0.8\n#define LEVEL_ROCK 0.90\n#define LEVEL_SNOW 1.0\n\nvec2 rot(vec2 X, float a)\n{\n \tfloat s = sin(a); float c = cos(a);\n    return mat2(c, -s, s, c)*X;\n}\n\nfloat hash2D(vec2 uv)\n{\n \tvec2 suv = sin(uv);\n    suv = rot(suv, uv.x);\n    return fract(mix(suv.x*13.13032942, suv.y*12.01293203924, dot(uv, suv)));\n}\n\nfloat custom_perlin_hash(vec2 uv)\n{\n \tvec2 lower\t= floor(uv);\n    vec2 frac \t= fract(uv);\n    vec2 f = frac*frac*(3.0-2.0*frac);\n    \n    return mix(\n        \tmix(hash2D(lower+vec2(0.0, 0.0)), hash2D(lower+vec2(1.0, 0.0)), f.x),\n        \tmix(hash2D(lower+vec2(0.0, 1.0)), hash2D(lower+vec2(1.0, 1.0)), f.x),\n        \tf.y);\n}\n\nfloat fbm_hash(vec2 uv)\n{\n    float total = 0.0;\n    total += 0.5000*custom_perlin_hash(uv); uv*=2.001;\n    total += 0.2500*custom_perlin_hash(uv); uv*=2.003;\n    total += 0.1250*custom_perlin_hash(uv); uv*=2.002;\n    total += 0.0625*custom_perlin_hash(uv); uv*=2.001;\n    return clamp(total, 0.0, 1.0);\n}\n\nfloat hash(vec2 v) {\n\tfloat h = dot(v, vec2(111.5, 143.7));\n    return fract(sin(h)*4054.39495854);\n}\n\nfloat noise(vec2 uv) {\n    vec2 _uv = floor(uv);\n    vec2 fuv = fract(uv);\n    vec2 f = fuv*fuv*(3.0-2.0*fuv);\n    float wins = 1.0;\n    return mix(\n        mix(hash(_uv+vec2(0.0, 0.0)), hash(_uv+vec2(wins, 0.0)), f.x),\n        mix(hash(_uv+vec2(wins, 0.0)), hash(_uv+vec2(wins,wins)), f.x),\n        f.y);\n}\n\n// Simplex 2D noise\n// sources: Ian McEwan - https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// sources: Patricio Gonzalez Vivo - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return clamp(0.5*(130.0 * dot(m, g)+1.0), 0.0, 1.0);\n}\n\nfloat voronoi2D(vec2 uv) {\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    float res = 1.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 p = vec2(i, j);\n            float h = hash2D(fl+p);\n            vec2 vp = p-fr+h;\n            float d = dot(vp, vp);\n            \n            res +=1.0/pow(d, 8.0);\n        }\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n// Gertsner\n\nstruct sGerstnerParams\n{\n    float nWaves;\n    float steepness;\n    float speed;\n    float waveDiv;\n    float amp;\n    vec2 wind;\n};\n\nsGerstnerParams BlendGParams(sGerstnerParams p1, sGerstnerParams p2, float a)\n{\n    p1.nWaves = mix(p1.nWaves, p2.nWaves, a);\n    p1.steepness = mix(p1.steepness, p2.steepness, a);\n    p1.speed = mix(p1.speed, p2.speed, a);\n    p1.waveDiv = mix(p1.waveDiv, p2.waveDiv, a);\n    p1.amp = mix(p1.amp, p2.amp, a);\n    p1.wind = mix(p1.wind, p2.wind, a);\n    return p1;\n}\n\n//  inspired from https://80.lv/articles/tutorial-ocean-shader-with-gerstner-waves/\nfloat gerstner(\n    vec3 p,\n    vec2 WindDir,\n    float wD,\n    float a,\n    float waveFreq,\n    float steepness,\n\tfloat speedfactor,\n\tfloat t)\n{\n    float depthz = 0.0, depthx = 0.0, depthy = 0.0;\n    //for(int i = 0; i < 4; ++i)\n    {\n        float WaveLength = PI2 / wD;\n        \n        float speed = WaveLength * speedfactor;\n        \n        float nWaves = waveFreq * PI2;\n        float Amplitude = a;\n        \n        float Time = t * speed;\n        \n        float Wave = dot(normalize(WindDir), (p.xz)) * WaveLength + Time;\n\n        float Qi = steepness/(nWaves * Amplitude * WaveLength);\n        float QiA = Qi*Amplitude;\n        \n        depthz = QiA*WindDir.y*cos(Wave);\n        depthx = QiA*WindDir.x*cos(Wave);\n        depthy = Amplitude*sin(Wave);\n    }\n    return length(vec3(depthx, depthy, depthz));//min( depthy, min(depthz, depthx));\n}\n\n\n\nfloat dfunc(vec3 p, sGerstnerParams params, float t)\n{\n    float nWaves = params.nWaves;\n    float steepness = params.steepness;\n    float speed = params.speed;\n    float waveDiv = params.waveDiv;\n    float depth = p.y;\n    vec2 wind = params.wind;\n    float amp = params.amp;\n    float s = -1.0;\n    for(int i = 0; i < NWAVES; ++i)\n    {\n        depth +=\n        gerstner(p, wind, waveDiv, amp, nWaves, steepness, speed, t);\n        speed *= SPEED_ATT;\n        steepness *= CHOPINESS_ATT;\n        amp *= AMP_ATT;\n        #ifdef WINDROLL_PER_WAVE\n        //wind = mat2(0.4, 0.8, -0.7, 0.2)*wind;\n        #endif\n        //nWaves *= 2.0;\n    }\n    return depth;\n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat mapg(vec3 p, float t)\n{\n    float ext = EXTINCTION(AMP_EXTINCTION_P, length(p), 0.01);\n    sGerstnerParams paramsAgitated1;\n    paramsAgitated1.nWaves = 4.0;\n    paramsAgitated1.steepness = 0.5;//60.0;\n    paramsAgitated1.speed = 12.0;\n    paramsAgitated1.waveDiv = 20.0;\n    #ifdef WINDROLL\n    paramsAgitated1.wind = rot(MainWindDir, fbm_hash(MainWindDir*p.xz));\n    #else\n    paramsAgitated1.wind = MainWindDir;//+fbm_hash(MainWindDir*0.16*p.xz);\n    #endif\n    paramsAgitated1.amp = MainAmp * ext;\n    \n    sGerstnerParams paramsAgitated2;\n    paramsAgitated2.nWaves = 4.0;\n    paramsAgitated2.steepness = 0.5;//25.0;\n    paramsAgitated2.speed = 12.0;\n    paramsAgitated2.waveDiv = 20.0;\n    #ifdef WINDROLL\n    paramsAgitated2.wind = rot(MainWindDir, 1.5*PI+fbm_hash(MainWindDir*p.xz));\n    #else\n    paramsAgitated2.wind = -MainWindDir;//+fbm_hash(MainWindDir*0.16*p.xz);\n    #endif\n    paramsAgitated2.amp = MainAmp * ext;\n    \n    \n    sGerstnerParams params;\n    params.nWaves = 2.0;\n    params.steepness =0.001;\n    params.speed = 10.0;\n    params.waveDiv = 10.0;\n    #ifdef WINDROLL\n    params.wind = rot(MainWindDir, fbm_hash(MainWindDir*p.xz));\n    #else\n    params.wind = MainWindDir;//+fbm_hash(MainWindDir*0.16*p.xz);\n    #endif\n    params.amp = MainAmp * ext;\n    \n    sGerstnerParams params2;\n    params2.nWaves = 2.0;\n    params2.steepness = 0.01;\n    params2.speed = 10.2;\n    params2.waveDiv = 10.0;\n    #ifdef WINDROLL\n    params2.wind = rot(MainWindDir, 1.5*PI+fbm_hash(MainWindDir*p.xz));\n    #else\n    params2.wind = -MainWindDir;//+fbm_hash(MainWindDir*0.16*p.xz);\n    #endif\n    params2.amp = MainAmp * ext;\n    \n    \n    params = BlendGParams(paramsAgitated1, params, 0.5);\n    params2 = BlendGParams(paramsAgitated2, params2, 0.5);\n        \n    return smin(\n        dfunc(p, params, t),\n        dfunc(p, params2, t),\n    0.5);\n}\n\nfloat terrain(vec2 uv) {\n    float h = 0.0;\n    float amp = 1.2, f = 0.2, e = 0.0, sumAmp = amp;\n    for(int i = 0;i<10;i++) {\n        e = 0.5*fbm_hash(uv*f);\n        e += 0.5*fbm_hash(-uv*f*f*f);\n        //e += snoise(-uv*f*f*f)*0.5;\n        h += e*amp;\n        f *= 1.9;\n        amp *= 0.4;\n        sumAmp += amp;\n    }\n    h = pow(h, 0.8);\n    float v=voronoi2D(0.01*uv);\n    v = v*v*v*v;\n    h-=1.5*v;\n    return (h+fbm_hash(uv))/sumAmp;\n}\n\n// inspired from TDM's seascape\nfloat seaNoise(vec2 a, float p) {\n    a += snoise(a);\n    vec2 wv = 1.0-abs(sin(a));\n    vec2 swv = abs(cos(a));\n    wv = mix(wv,swv,wv);\n    vec2 v = wv;\n    return pow(1.0-pow(v.x*v.y, 0.65), p);\n}\n\nfloat ocean(vec2 uv, vec2 coastdir, float deep, float t) {\n    float h = 0.0;\n    float amp = 0.1, f = 2.0, e = 0.0;\n    float p = 4.0;\n    float d = 0.0;\n    for(int i = 0;i<4;i++) {\n        e = fbm_hash(f*uv+t);//seaNoise(uv+iTime*0.04*f, p);\n        e += fbm_hash(f*uv-t);//seaNoise(uv-iTime*0.04*f, p);\n        /*e = snoise(uv+iTime*0.04*f);\n        e += snoise(uv-iTime*0.04*f);*/\n        h += e*amp;\n        f *= 1.2;\n        amp *= 0.22;\n        p = mix(p, 1.0, 0.2);\n        uv *= mat2(1.6, 1.4, -1.4, 1.6);\n    }\n    //h = mapg(vec3(uv.x, 0.0, uv.y), t);\n    return h;//clamp(h, 0.0, 1.0);\n}\n\nvec3 normalOcean(vec2 uv, vec2 coastdir, float deep, float t, float e)\n{\n    vec3 normal;\n    normal.y = ocean(uv, coastdir, deep, t);\n    normal.x = ocean(uv+vec2(-e, 0.0), coastdir, deep, t)-normal.y;\n    normal.z = ocean(uv+vec2(0.0, e), coastdir, deep, t)-normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nvec3 normalTerrain(vec2 uv, float e)\n{\n    vec3 normal;\n    normal.y = terrain(uv);\n    normal.x = terrain(uv+vec2(-e, 0.0))-normal.y;\n    normal.z = terrain(uv+vec2(0.0, e))-normal.y;\n    normal.y = e;\n    return normalize(normal);\n}\n\nfloat Fresnel_Schlick(float n1, float n2, float NdotV)\n{\n    float R0 = (n1-n2)/(n1+n2);\n    R0 *= R0;\n    return R0+(1.0-R0)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV)*(1.0-NdotV);\n}\n\n// widget\n\n\nbool widget_inBox(vec2 pt, vec4 box)\n{\n    return pt.x>box.x && pt.x<box.z\n        && pt.y<(1.0-box.y) && pt.y>(1.0-box.w);\n}\n\nfloat widget_percent(vec2 m, vec4 box)\n{\n    return (1.0-clamp(((1.0-m.y)-box.y)/(box.w-box.y), 0.0, 1.0));\n}\n\nbool widget_box(vec2 muv, vec4 box, inout float percent)\n{\n    bool bRet = widget_inBox(muv, box);\n    float bNew = widget_percent(muv, box);\n    percent = bRet && bNew>0.0?bNew:percent;\n    return bRet;\n}\n\nbool widget_draw(vec2 uv, vec4 box)\n{\n    return widget_inBox(uv, box);\n}\n\nvoid StoreValue( vec2 re, vec4 va, inout vec4 fragColor, vec2 fragCoord )\n{\n    fragCoord = floor( fragCoord );\n    \n    fragColor =\n        ( fragCoord.x == re.x && fragCoord.y == re.y ) ?\n        va\n        : fragColor\n            ;\n}\n\nvec4 LoadValue(sampler2D tex, vec2 texRes, vec2 tx )\n{\n    // texRes = iChannelResolution[ 0 ]\n    return  texture( tex, ( tx + 0.5 ) / texRes.xy );\n    //return floor( texture( tex, ( tx + 0.5 ) / texRes.xy ) );\n    //return floor(texture(tex, tx/texRes.xy));\n}\n\nvec2 getUV(vec2 fragCoord, vec4 mouseCoord, bool useMouse, vec2 resolution, float zoom, float time, inout vec2 puv)\n{\n    puv = fragCoord.xy / resolution.xy;\n    vec2 muv = -1.0+2.0*(mouseCoord.xy/resolution.xy);\n    #ifdef WIP\n    puv += useMouse?muv*100.0:vec2(0.0);\n    #endif\n\tvec2 uv = -1.0+2.0*(fragCoord.xy / resolution.xy);\n    \n    vec2 ret = puv\n        +uv*\n        ZOOM_SCALE(zoom);\n    return ret;\n}","name":"Common","description":"","type":"common"}]}