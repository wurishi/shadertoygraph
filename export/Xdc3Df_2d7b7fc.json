{"ver":"0.1","info":{"id":"Xdc3Df","date":"1452414558","viewed":904,"name":"Water Color Shader !!","username":"raja","description":"Water Color Shader. Work in progress !!","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["npr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":" #ifdef GL_ES\nprecision highp float;\n#endif\n\nconst int radius = 15;\n\nvec3 darken( vec3 s, vec3 d )\n{\n\treturn min(s,d);\n}\n\nvec3 multiply( vec3 s, vec3 d )\n{\n\treturn s*d;\n}\n\nvec3 colorBurn( vec3 s, vec3 d )\n{\n\treturn 1.0 - (1.0 - d) / s;\n}\n\nvec3 linearBurn( vec3 s, vec3 d )\n{\n\treturn s + d - 1.0;\n}\n\nvec3 darkerColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z < d.x + d.y + d.z) ? s : d;\n}\n\nvec3 lighten( vec3 s, vec3 d )\n{\n\treturn max(s,d);\n}\n\nvec3 screen( vec3 s, vec3 d )\n{\n\treturn s + d - s * d;\n}\n\nvec3 colorDodge( vec3 s, vec3 d )\n{\n\treturn d / (1.0 - s);\n}\n\nvec3 linearDodge( vec3 s, vec3 d )\n{\n\treturn s + d;\n}\n\nvec3 lighterColor( vec3 s, vec3 d )\n{\n\treturn (s.x + s.y + s.z > d.x + d.y + d.z) ? s : d;\n}\n\nfloat overlay( float s, float d )\n{\n\treturn (d < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 overlay( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = overlay(s.x,d.x);\n\tc.y = overlay(s.y,d.y);\n\tc.z = overlay(s.z,d.z);\n\treturn c;\n}\n\nfloat softLight( float s, float d )\n{\n\treturn (s < 0.5) ? d - (1.0 - 2.0 * s) * d * (1.0 - d) \n\t\t: (d < 0.25) ? d + (2.0 * s - 1.0) * d * ((16.0 * d - 12.0) * d + 3.0) \n\t\t\t\t\t : d + (2.0 * s - 1.0) * (sqrt(d) - d);\n}\n\nvec3 softLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = softLight(s.x,d.x);\n\tc.y = softLight(s.y,d.y);\n\tc.z = softLight(s.z,d.z);\n\treturn c;\n}\n\nfloat hardLight( float s, float d )\n{\n\treturn (s < 0.5) ? 2.0 * s * d : 1.0 - 2.0 * (1.0 - s) * (1.0 - d);\n}\n\nvec3 hardLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = hardLight(s.x,d.x);\n\tc.y = hardLight(s.y,d.y);\n\tc.z = hardLight(s.z,d.z);\n\treturn c;\n}\n\nfloat vividLight( float s, float d )\n{\n\treturn (s < 0.5) ? 1.0 - (1.0 - d) / (2.0 * s) : d / (2.0 * (1.0 - s));\n}\n\nvec3 vividLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = vividLight(s.x,d.x);\n\tc.y = vividLight(s.y,d.y);\n\tc.z = vividLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 linearLight( vec3 s, vec3 d )\n{\n\treturn 2.0 * s + d - 1.0;\n}\n\nfloat pinLight( float s, float d )\n{\n\treturn (2.0 * s - 1.0 > d) ? 2.0 * s - 1.0 : (s < 0.5 * d) ? 2.0 * s : d;\n}\n\nvec3 pinLight( vec3 s, vec3 d )\n{\n\tvec3 c;\n\tc.x = pinLight(s.x,d.x);\n\tc.y = pinLight(s.y,d.y);\n\tc.z = pinLight(s.z,d.z);\n\treturn c;\n}\n\nvec3 hardMix( vec3 s, vec3 d )\n{\n\treturn floor(s + d);\n}\n\nvec3 difference( vec3 s, vec3 d )\n{\n\treturn abs(d - s);\n}\n\nvec3 exclusion( vec3 s, vec3 d )\n{\n\treturn s + d - 2.0 * s * d;\n}\n\nvec3 subtract( vec3 s, vec3 d )\n{\n\treturn s - d;\n}\n\nvec3 divide( vec3 s, vec3 d )\n{\n\treturn s / d;\n}\n\n//\trgb<-->hsv functions by Sam Hocevar\n//\thttp://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\t\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hue( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.x = rgb2hsv(s).x;\n\treturn hsv2rgb(d);\n}\n\nvec3 color( vec3 s, vec3 d )\n{\n\ts = rgb2hsv(s);\n\ts.z = rgb2hsv(d).z;\n\treturn hsv2rgb(s);\n}\n\nvec3 saturation( vec3 s, vec3 d )\n{\n\td = rgb2hsv(d);\n\td.y = rgb2hsv(s).y;\n\treturn hsv2rgb(d);\n}\n\nvec3 luminosity( vec3 s, vec3 d )\n{\n\tfloat dLum = dot(d, vec3(0.3, 0.59, 0.11));\n\tfloat sLum = dot(s, vec3(0.3, 0.59, 0.11));\n\tfloat lum = sLum - dLum;\n\tvec3 c = d + lum;\n\tfloat minC = min(min(c.x, c.y), c.z);\n\tfloat maxC = max(max(c.x, c.y), c.z);\n\tif(minC < 0.0) return sLum + ((c - sLum) * sLum) / (sLum - minC);\n\telse if(maxC > 1.0) return sLum + ((c - sLum) * (1.0 - sLum)) / (maxC - sLum);\n\telse return c;\n}\nvec3 sample( vec2 fragCoord, const int x, const int y)\n{\n\tvec2 uv = (fragCoord.xy + vec2(x, y)) / iResolution.xy;\n\t//uv.y = 1.0 - uv.y;\n\t\n\treturn texture(iChannel0, uv).xyz;\n}\n\n\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n {\n\t vec2 src_size = vec2 (1.0 / iResolution.x, 1.0 / iResolution.y);\n     vec2 uv = fragCoord.xy/iResolution.xy;\n     float n = float((radius + 1) * (radius + 1));\n     int i; \n\t int j;\n     vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n     vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n     vec3 c;\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m0 += c;\n             s0 += c * c;\n         }\n     }\n\n     for (int j = -radius; j <= 0; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m1 += c;\n             s1 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = 0; i <= radius; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m2 += c;\n             s2 += c * c;\n         }\n     }\n\n     for (int j = 0; j <= radius; ++j)  {\n         for (int i = -radius; i <= 0; ++i)  {\n             c = texture(iChannel0, uv + vec2(i,j) * src_size).rgb;\n             m3 += c;\n             s3 += c * c;\n         }\n     }\n\n\n\t vec4 result;\n     float min_sigma2 = 1e+2;\n     m0 /= n;\n     s0 = abs(s0 / n - m0 * m0);\n\n     float sigma2 = s0.r + s0.g + s0.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m0, 1.0);\n     }\n\n     m1 /= n;\n     s1 = abs(s1 / n - m1 * m1);\n\n     sigma2 = s1.r + s1.g + s1.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m1, 1.0);\n     }\n\n     m2 /= n;\n     s2 = abs(s2 / n - m2 * m2);\n\n     sigma2 = s2.r + s2.g + s2.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m2, 1.0);\n     }\n\n     m3 /= n;\n     s3 = abs(s3 / n - m3 * m3);\n\n     sigma2 = s3.r + s3.g + s3.b;\n     if (sigma2 < min_sigma2) {\n         min_sigma2 = sigma2;\n         result = vec4(m3, 1.0);\n     }\n\t\n\t const vec3 lumi = vec3(0.2126, 0.7152, 0.0722);\n\t\n\tvec3 hc =sample(fragCoord,-1,-1) *  1.0 + sample( fragCoord,0,-1) *  2.0\n\t\t \t+sample( fragCoord,1,-1) *  1.0 + sample(fragCoord,-1, 1) * -1.0\n\t\t \t+sample( fragCoord,0, 1) * -2.0 + sample( fragCoord,1, 1) * -1.0;\n\t\t\n\tvec3 vc =sample(fragCoord,-1,-1) *  1.0 + sample(fragCoord,-1, 0) *  2.0\n\t\t \t+sample(fragCoord,-1, 1) *  1.0 + sample( fragCoord,1,-1) * -1.0\n\t\t \t+sample(fragCoord, 1, 0) * -2.0 + sample( fragCoord,1, 1) * -1.0;\n\t\n\tvec3 c2 = sample(fragCoord,0, 0);\n\t\n\tc2 -= pow(c2, vec3(0.2126, 0.7152, 0.0722)) * pow(dot(lumi, vc*vc + hc*hc), 0.5);\n\tfragColor = vec4(overlay(screen( result.rgb,c2.rgb), result.rgb) , 1.0);\n }","name":"","description":"","type":"image"}]}