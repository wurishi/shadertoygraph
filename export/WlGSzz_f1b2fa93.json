{"ver":"0.1","info":{"id":"WlGSzz","date":"1582035033","viewed":244,"name":"Fractal by the ocean","username":"matistjati","description":"A path traced fractal located in an ocean with some poor clouds.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["fractal","clouds","water","globalillumination","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, uv).xyz/float(iFrame);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define screenSize = iResolution.xy\n#define position vec3(0.,1.,4.6)\n#define zoom 1\n#define time 1.\n#define frame iFrame\n\n\n/*<GuiHint>GuiType: submenu, Name: Rendering options, Identifier: render</GuiHint>*/\n\n/*<GuiHint>GuiType: submenu, Name: Path tracing, Identifier: pathTrace</GuiHint>*/\n\n/*<GuiHint>GuiType: submenu, Name: Sky, Identifier: sky</GuiHint>*/\n\n/*<GuiHint>GuiType: submenu, Name: Fractal Parameters, Identifier: fractalParams</GuiHint>*/\n\n/*<GuiHint>GuiType: submenu, Name: Coloring, Identifier: color</GuiHint>*/\n\n\n\n/*<GuiHint>GuiType: slider, Name: Max Iterations, Parent: render, Range: (1, 100)</GuiHint>*/\nconst float maxIterations = 40.;\n\n/*<GuiHint>GuiType: slider, Name: Max Steps, Parent: render, Range: (1, 1000)</GuiHint>*/\nconst int maxSteps = 300;\n\n/*<GuiHint>GuiType: slider, Name: Anti Aliasing, Parent: render, Range: (1, 5)</GuiHint>*/\nconst float antiAliasing = 1.;\n\n/*<GuiHint>GuiType: slider, Name: Fudge Factor, Parent: render, Range: (0.1, 3)</GuiHint>*/\nconst float fudgeFactor = 0.95;\n\n/*<GuiHint>GuiType: slider, Name: Gamma Correction, Parent: render, Range: (0, 2)</GuiHint>*/\nconst float gamma = 1.;\n\n/*<GuiHint>GuiType: slider, Name: ray acceptance, Parent: render, Range: (0.0001, 0.001)</GuiHint>*/\nconst float zoomDetailRatio = 0.001;\n\n/*<GuiHint>GuiType: slider, Name: Max Ray Distance, Parent: render, Range: (1, 64)</GuiHint>*/\nconst float maxDist = 16.;\n\n/*<GuiHint>GuiType: slider, Name: Escacpe Radius, Parent: render, Range: (1, 1024)</GuiHint>*/\nconst float escapeRadius = 256.;\n\n/*<GuiHint>GuiType: slider, Name: Shadow Darkness, Parent: render, Range: (1, 3)</GuiHint>*/\nconst float shadowDarkness = 1.;\n\n/*<GuiHint>GuiType: slider, Name: Specular Strength, Parent: render, Range: (0, 2)</GuiHint>*/\nconst float specularStrength = 1.;\n\n\n\n/*<GuiHint>GuiType: checkBox, Name: Path Trace Image, Parent: pathTrace</GuiHint>*/\nconst bool pathTrace = true;\n\n/*<GuiHint>GuiType: slider, Name: Bounces, Parent: pathTrace, Range: (1, 10)</GuiHint>*/\nconst float bounces = 3.;\n\n/*<GuiHint>GuiType: slider, Name: Brightness, Parent: pathTrace, Range: (0.2, 10)</GuiHint>*/\nconst float brightness = .6;\n\n/*<GuiHint>GuiType: slider, Name: Water Height, Parent: pathTrace, Range: (-5, 5)</GuiHint>*/\nconst float waterHeight = 0.5;\n\n/*<GuiHint>GuiType: slider, Name: Water bumpiness, Parent: pathTrace, Range: (0, 2)</GuiHint>*/\nconst float bumpFactor = 0.05;\n\n/*<GuiHint>GuiType: colorPicker, Name: Surface Color, Parent: pathTrace</GuiHint>*/\nconst vec3 surfaceColor = vec3(0.1)*vec3(1.2,1.1,1.0);\n\n/*<GuiHint>GuiType: slider, Name: Cloud amount, Parent: pathTrace, Range: (0, 1)</GuiHint>*/\nconst float cloudAmount = 0.3;\n\n/*<GuiHint>GuiType: slider, Name: Water and sky max distance, Parent: pathTrace, Range: (0, 1000)</GuiHint>*/\nconst float maxWaterDist = 1000.;\n\n/*<GuiHint>GuiType: slider, Name: Noise Scale small, Parent: pathTrace, Range: (0.0001, 1)</GuiHint>*/\nconst vec3 noiseScaleSmall = vec3(0.09, 0.195, 1);\n\n/*<GuiHint>GuiType: slider, Name: Noise Scale large, Parent: pathTrace, Range: (1, 100)</GuiHint>*/\nconst vec3 noiseScaleLarge = vec3(1,2,1);\n\n/*<GuiHint>GuiType: slider, Name: Noise persistence, Parent: pathTrace, Range: (0, 1)</GuiHint>*/\nconst float persistence = 0.711;\n\n/*<GuiHint>GuiType: slider, Name: Density level, Parent: pathTrace, Range: (0, 1)</GuiHint>*/\nconst float densityLevel = 0.215;\n\n/*<GuiHint>GuiType: slider, Name: Density threshold, Parent: pathTrace, Range: (0, 1)</GuiHint>*/\nconst float densityThreshold = 0.937;\n\n/*<GuiHint>GuiType: slider, Name: Cloud brightness, Parent: pathTrace, Range: (0.001, 5)</GuiHint>*/\nconst float cloudBrightness = 1.2;\n\n/*<GuiHint>GuiType: slider, Name: Step size, Parent: pathTrace, Range: (0.01, 4)</GuiHint>*/\nconst float stepSize = 0.33;\n\n/*<GuiHint>GuiType: slider, Name: Cloud box position, Parent: pathTrace, Range: (-50, 50)</GuiHint>*/\nconst vec3 boxPos = vec3(0,20,0);\n\n/*<GuiHint>GuiType: slider, Name: Cloud box width, Parent: pathTrace, Range: (0, 500)</GuiHint>*/\nconst vec3 boxWidth = vec3(300,10,200);\n\n\n\n\n/*<GuiHint>GuiType: checkBox, Name: Fog Coloring, Parent: color</GuiHint>*/\nconst bool fogColoring = false;\n\n/*<GuiHint>GuiType: slider, Name: Shadow Softness, Range: (-4, 64), Parent: color</GuiHint>*/\nconst float shadowSoftness = 4.;\n\n\n\n/*<GuiHint>GuiType: slider, Name: Sun Size, Parent: sky, Range: (-1, 10)</GuiHint>*/\nconst float sunSize = 1.0;\n\n/*<GuiHint>GuiType: slider, Name: Sun Spread, Parent: sky, Range: (-1, 128)</GuiHint>*/\nconst float sunSpread = 44.0;\n\n/*<GuiHint>GuiType: colorPicker, Name: Sun Color, Parent: sky</GuiHint>*/\nconst vec3 sunColor = vec3(0.8,0.7,0.5);\n\n/*<GuiHint>GuiType: colorPicker, Name: Sky Color, Parent: sky</GuiHint>*/\nconst vec3 skyColor = vec3(0.8, 0.95, 1.2);\n\n\n\n        /*<GuiHint>GuiType: slider, Name: Fog Darkness, Parent: color, Range: (0, 10)</GuiHint>*/\n        const float fogDarkness = 5.;\n\n        /*<GuiHint>GuiType: slider, Name: Distance Diff, Parent: render, Range: (0, 4)</GuiHint>*/\n        const float distDiff = 2.;\n\n        /*<GuiHint>GuiType: slider, Name: Scale, Parent: fractalParams, Range: (-2, 4)</GuiHint>*/\n        const float scale = 1.3;\n\n        /*<GuiHint>GuiType: slider, Name: First rotation, Parent: fractalParams, Range: (0, 1)</GuiHint>*/\n        const vec3 rot1 = vec3(0.448,0.68,0.425);\n\n        /*<GuiHint>GuiType: slider, Name: Second rotation, Parent: fractalParams, Range: (0, 1)</GuiHint>*/\n        const vec3 rot2 = vec3(0.319,0.646,0.733);\n\n        /*<GuiHint>GuiType: slider, Name: Center, Parent: fractalParams, Range: (0, 5)</GuiHint>*/\n        const vec3 offset = vec3(2,4.8,0);\n\n        /*<GuiHint>GuiType: colorPicker, Name: Color A, Parent: color</GuiHint>*/\n        const vec3 colorA = vec3(0, 0.707, 0.707);\n\n        /*<GuiHint>GuiType: colorPicker, Name: Edge Color, Parent: color</GuiHint>*/\n        const vec3 edgeColor = vec3(0, 0.4, 0.4);\n\n        /*<GuiHint>GuiType: slider, Name: Color period, Parent: color, Range: (0, 200)</GuiHint>*/\n        const float frequency = 10.;\n\n\nconst vec3 light = vec3(-0.707107, 0.000, 0.707107);\n\n#define sun normalize(vec3(-1.,0.4,-0.4))\n\n\n\n\n\n\n// Helper functions\n\n        // Fold space about the symmetry planes of a tetrahedron\n        void sierpinskiFold(inout vec3 w)\n        {\n                if(w.x + w.y < 0.) w.xy = -w.yx;\n                if(w.x + w.z < 0.) w.xz = -w.zx;\n                if(w.y + w.z < 0.) w.yz = -w.zy;\n        }\n\n        // Fold space about the symmetry planes of a menger sponge\n        void mengerFold(inout vec3 w)\n        {\n                w=abs(w);\n                if(w.x-w.y<0.) w.xy = w.yx;\n                if(w.x-w.z<0.) w.xz = w.zx;\n                if(w.y-w.z<0.) w.yz = w.zy;\n        }\n\n        // Fold space about the symmetry planes of an icosahedron\n        void icosaFold(inout vec3 w)\n        {\n                const float phi = 1.61803399; // golden ratio.\n\n                const vec3 n1 = normalize(vec3(-phi,phi-1.0,1.0));\n                const vec3 n2 = normalize(vec3(1.0,-phi,phi+1.0));\n\n                w.yz=abs(w.yz);\n                w-=2.0 * max(0.,dot(w, n2)) * n2;\n\n                w.xz = abs(w.xz);\n                w-=2.0 * max(0.,dot(w, n1)) * n1;\n        }\n\n    // Sphere inversion\n        void sphereFold(inout vec3 z, inout float dz, float r2, float innerRadius, float outerRadius)\n        {\n                if (r2 < innerRadius)\n                {\n                        // linear inner scaling\n                        float temp = (outerRadius/innerRadius);\n                        z *= temp;\n                        dz*= temp;\n                }\n                else if (r2<outerRadius)\n                {\n                        // this is the actual sphere inversion\n                        float temp =(outerRadius/r2);\n                        z *= temp;\n                        dz*= temp;\n                }\n        }\n\n        float hash11(float p)\n        {\n                p = fract(p * .1031);\n                p *= p + 33.33;\n                p *= p + p;\n                return abs(fract(p));\n        }\n\n        vec2 hash21(inout float p)\n        {\n                p = hash11(p);\n                p = hash11(p);\n                vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n                p3 += dot(p3, p3.yzx + 33.33);\n                return fract((p3.xx+p3.yz)*p3.zy);\n        }\n\n        vec2 hash22(vec2 p)\n        {\n                vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n                p3 += dot(p3, p3.yzx+33.33);\n                return fract((p3.xx+p3.yz)*p3.zy);\n        }\n\n        vec2 hash23(vec3 p)\n        {\n                vec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n                p4 += dot(p4, p4.wzxy+33.33);\n                return (fract((p4.xxyz+p4.yzzw)*p4.zywx)).xy;\n        }\n\n        uint intHash(uint x)\n        {\n                x = ((x >> 16) ^ x) * 0x45d9f3bU;\n                x = ((x >> 16) ^ x) * 0x45d9f3bU;\n                x = (x >> 16) ^ x;\n                return x;\n        }\n\n        vec2 hash2(uint n, out uint hash)\n        {\n                uint ih =intHash(n);\n                hash = intHash(ih);\n                uvec2 k = uvec2(ih,hash);\n                return vec2(k & uvec2(0xffffffffU))/float(0xffffffffU);\n        }\n\n        // Cellular noise taken from: https://github.com/ashima/webgl-noise\n\n        //Copyright (C) 2011 by Ashima Arts (Simplex noise)\n        //Copyright (C) 2011-2016 by Stefan Gustavson (Classic noise and others)\n\n        //Permission is hereby granted, free of charge, to any person obtaining a copy\n        //of this software and associated documentation files (the \"Software\"), to deal\n        //in the Software without restriction, including without limitation the rights\n        //to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        //copies of the Software, and to permit persons to whom the Software is\n        //furnished to do so, subject to the following conditions:\n\n        //The above copyright notice and this permission notice shall be included in\n        //all copies or substantial portions of the Software.\n\n        //THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        //IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        //FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        //AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        //LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        //OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n        //THE SOFTWARE.\n\n        vec4 mod289(vec4 x)\n        {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n        }\n\n        vec3 mod289(vec3 x)\n        {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n        }\n\n        vec2 mod289(vec2 x)\n        {\n          return x - floor(x * (1.0 / 289.0)) * 289.0;\n        }\n\n        // Modulo 7 without a division\n        vec3 mod7(vec3 x)\n        {\n          return x - floor(x * (1.0 / 7.0)) * 7.0;\n        }\n\n        // Modulo 7 without a division\n        vec4 mod7(vec4 x)\n        {\n          return x - floor(x * (1.0 / 7.0)) * 7.0;\n        }\n\n        // Permutation polynomial: (34x^2 + x) mod 289\n        vec3 permute(vec3 x)\n        {\n          return mod289((34.0 * x + 1.0) * x);\n        }\n\n        vec4 permute(vec4 x)\n        {\n          return mod289((34.0 * x + 1.0) * x);\n        }\n\n        // Cellular noise, returning F1 and F2 in a vec2.\n        // Standard 3x3 search window for good F1 and F2 values\n        float cellular(vec2 P)\n        {\n                #define K 0.142857142857 // 1/7\n                #define Ko 0.428571428571 // 3/7\n                const float jitter = 1.0; // Less gives more regular pattern\n                P.x*=3.;\n                P.y*=5.;\n                vec2 Pi = mod289(floor(P));\n                vec2 Pf = fract(P);\n                vec3 oi = vec3(-1.0, 0.0, 1.0);\n                vec3 of = vec3(-0.5, 0.5, 1.5);\n                vec3 px = permute(Pi.x + oi);\n                vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n                vec3 ox = fract(p*K) - Ko;\n                vec3 oy = mod7(floor(p*K))*K - Ko;\n                vec3 dx = Pf.x + 0.5 + jitter*ox;\n                vec3 dy = Pf.y - of + jitter*oy;\n                vec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n                p = permute(px.y + Pi.y + oi); // p21, p22, p23\n                ox = fract(p*K) - Ko;\n                oy = mod7(floor(p*K))*K - Ko;\n                dx = Pf.x - 0.5 + jitter*ox;\n                dy = Pf.y - of + jitter*oy;\n                vec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n                p = permute(px.z + Pi.y + oi); // p31, p32, p33\n                ox = fract(p*K) - Ko;\n                oy = mod7(floor(p*K))*K - Ko;\n                dx = Pf.x - 1.5 + jitter*ox;\n                dy = Pf.y - of + jitter*oy;\n                vec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n                // Sort out the two smallest distances (F1, F2)\n                vec3 d1a = min(d1, d2);\n                d2 = max(d1, d2); // Swap to keep candidates for F2\n                d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n                d1 = min(d1a, d2); // F1 is now in d1\n                d2 = max(d1a, d2); // Swap to keep candidates for F2\n                d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n                d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n                d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n                d1.y = min(d1.y, d1.z); // nor in  d1.z\n                d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n                return sqrt(d1.y);\n        }\n\n\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// 3x3x3 search region for good F2 everywhere, but a lot\n// slower than the 2x2x2 version.\n// The code below is a bit scary even to its author,\n// but it has at least half decent performance on a\n// modern GPU. In any case, it beats any software\n// implementation of Worley noise hands down.\nfloat cellular(vec3 P, float scale)\n{\n        #define K 0.142857142857 // 1/7\n        #define Ko 0.428571428571 // 1/2-K/2\n        #define K2 0.020408163265306 // 1/(7*7)\n        #define Kz 0.166666666667 // 1/6\n        #define Kzo 0.416666666667 // 1/2-1/6*2\n\n        P*=scale;\n        const float jitter = 0.8; // smaller jitter gives less errors in F2\n        vec3 Pi = mod289(floor(P));\n        vec3 Pf = fract(P);\n        vec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\n        vec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\n        vec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n        p = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n        vec4 p1 = permute(p + Pi.z); // z+0\n        vec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\n        vec4 ox1 = fract(p1*K) - Ko;\n        vec4 oy1 = mod7(floor(p1*K))*K - Ko;\n        vec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\n        vec4 ox2 = fract(p2*K) - Ko;\n        vec4 oy2 = mod7(floor(p2*K))*K - Ko;\n        vec4 oz2 = floor(p2*K2)*Kz - Kzo;\n        vec4 dx1 = Pfx + jitter*ox1;\n        vec4 dy1 = Pfy + jitter*oy1;\n        vec4 dz1 = Pf.z + jitter*oz1;\n        vec4 dx2 = Pfx + jitter*ox2;\n        vec4 dy2 = Pfy + jitter*oy2;\n        vec4 dz2 = Pf.z - 1.0 + jitter*oz2;\n        vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n        vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n        // Cheat and sort out only F1\n        d1 = min(d1, d2);\n        d1.xy = min(d1.xy, d1.wz);\n        d1.x = min(d1.x, d1.y);\n        return sqrt(d1.x);\n}\n\n\n\n// Distance estimator\n\nfloat DistanceEstimator(vec3 w, out vec4 resColor)\n{\n                float m = dot(w,w);\n                vec4 trap = vec4(abs(w),m);\n\n                vec3 phase1 = vec3(0,0,0);\n                vec3 phase2 = vec3(0,0,0);\n\n                vec3 sinrot1 = vec3(sin((rot1+phase1)*6.28318530718));\n                vec3 cosrot1 = vec3(cos((rot1+phase1)*6.28318530718));\n                mat3 rotMat1 = mat3(1,0,0,0,cosrot1.x,-sinrot1.x,0,sinrot1.x,cosrot1.x)*mat3(cosrot1.y,0,sinrot1.y,0,1,0,-sinrot1.y,0,cosrot1.y)*mat3(cosrot1.z,-sinrot1.z,0,sinrot1.z,cosrot1.z,0,0,0,1);\n\n                vec3 sinrot2 = vec3(sin((rot2+phase2)*6.28318530718));\n                vec3 cosrot2 = vec3(cos((rot2+phase2)*6.28318530718));\n                mat3 rotMat2 = mat3(1,0,0,0,cosrot2.x,-sinrot2.x,0,sinrot2.x,cosrot2.x)*mat3(cosrot2.y,0,sinrot2.y,0,1,0,-sinrot2.y,0,cosrot2.y)*mat3(cosrot2.z,-sinrot2.z,0,sinrot2.z,cosrot2.z,0,0,0,1);\n\n\n        float i;\n        for(i = 0.; i < maxIterations; i++)\n        {\n\n                w*=rotMat1;\n\n                w=abs(w);\n                if(w.x-w.y<0.) w.xy = w.yx;\n                if(w.x-w.z<0.) w.xz = w.zx;\n                if(w.y-w.z<0.) w.yz = w.zy;\n\n                w*=rotMat2;\n        w = w*scale-offset*(scale-1.);\n\n\n\n\n\n                if (length(w)>escapeRadius) {i++; break;}\n        }\n\n        resColor = trap;\n\n        return (length(w)-distDiff)*pow(scale,-i);\n}\n\n\n// Stuff like multiple distance estimators\n\n        float sceneDistance(vec3 w, out vec4 resColor)\n        {\n                return DistanceEstimator(w, resColor);\n        }\n\n        float sceneDistance(vec3 w)\n        {\n                vec4 temp;\n                return DistanceEstimator(w, temp);\n        }\n\n\n// The actual ray marching, implement things like bounding geometry\n\n#define LinneaRetarded 0\n        // Compute the intersection of the fractal and a given ray parameterised by a starting point and a direction\n        float trace(vec3 origin, vec3 direction, out vec4 trapOut, float px, out float percentSteps, out bool hitSurface)\n        {\n                float res = -1.;\n                vec4 trap;\n\n                float t = 0.;\n                float h = 0.;\n                int i = 0;\n                float th = 0.;\n                for(; i < maxSteps; i++)\n                {\n                        vec3 pos = origin + direction * t;\n                        h = fudgeFactor * sceneDistance(pos, trap);\n                        th = 0.25 * px * t;\n\n                        if (h < th || h > maxDist)\n                        {\n                                break;\n                        }\n                        t += h;\n                }\n\n                percentSteps = float(i)/float(maxSteps);\n\n                trapOut = trap;\n\n                hitSurface = h < th && i < maxSteps;\n\n#if LinneaRetarded\n                if (t < maxDist && !fogColoring)\n#else\n                if (h < maxDist && !fogColoring)\n#endif\n                {\n                        res = t;\n                }\n\n                return res;\n        }\n\n\n\n        vec3 calculateNormal(vec3 p)\n        {\n                const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n                vec3 gradient;\n                vec4 temp;\n\n                gradient.x = sceneDistance(p + small_step.xyy, temp) - sceneDistance(p - small_step.xyy, temp);\n                gradient.y = sceneDistance(p + small_step.yxy, temp) - sceneDistance(p - small_step.yxy, temp);\n                gradient.z = sceneDistance(p + small_step.yyx, temp) - sceneDistance(p - small_step.yyx, temp);\n\n                return normalize(gradient);\n        }\n\n        float SoftShadow(vec3 origin, vec3 direction, float k)\n        {\n                float result = 1.0;\n                float t = 0.0;\n\n                for(int i = 0; i < maxSteps; i++)\n                {\n                        float h = sceneDistance(origin + direction * t);\n                        result = min(result, k * h / t);\n\n                        if(result < 0.001) break;\n\n                        t += clamp(h, 0.01, 32.);\n                }\n                return clamp(result, 0.0, 1.0);\n        }\n\n\n// Transforming some inputs, calling trace and calculating color and shadow\n\n        vec2 RayBoxIntersection(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax)\n        {\n            vec3 tMin = (boxMin - rayOrigin) / rayDir;\n            vec3 tMax = (boxMax - rayOrigin) / rayDir;\n            vec3 t1 = min(tMin, tMax);\n            vec3 t2 = max(tMin, tMax);\n            float tNear = max(max(t1.x, t1.y), t1.z);\n            float tFar = min(min(t2.x, t2.y), t2.z);\n            return vec2(tNear, tFar);\n        }\n\n        float cloudNoise(vec3 pos)\n        {\n                float a;\n                float b;\n                float c;\n                a = 1.-cellular(pos, noiseScaleLarge.x * noiseScaleSmall.x);\n                b = 1.-cellular(pos, noiseScaleLarge.y * noiseScaleSmall.y);\n                c = 1.-cellular(pos, noiseScaleLarge.z * noiseScaleSmall.z);\n                float f = a + (b * persistence) + (c * persistence * persistence);\n                return max(0., f - densityThreshold) * densityLevel;\n        }\n\n       \n        #define boxMin boxPos-boxWidth*0.5\n        #define boxMax boxPos+boxWidth*0.5\n        float lightMarch(vec3 pos)\n        {\n            float distInsidebox = RayBoxIntersection(pos, sun, boxMin, boxMax).y;\n\n            float sunStepSize = distInsidebox/10.;\n            float totalDensity = 0.;\n\n            for (int step = 0; step < 10; step++)\n            {\n                pos += sun * sunStepSize;\n                totalDensity += max(0., cloudNoise(position)) * sunStepSize;\n            }\n\n            float transmittance = exp(-totalDensity * 0.1);\n            return 2. + transmittance * (1.-2.);\n        }\n\n\n        float SampleCloudDensity(vec3 ro, vec3 rd, out vec3 cloudCol, bool calculateSunLight)\n        {\n            vec2 intersect = RayBoxIntersection(ro, rd, boxMin, boxMax);\n            if (intersect.y<0.)\n            {\n                return 1.;\n            }\n\n            const float phaseVal = .5;\n\n            float transmittance = 1.;\n            vec3 lightEnergy = vec3(0.);\n            for (float t = intersect.x; t < intersect.y; t+=stepSize)\n            {\n                float density = cloudNoise(ro+rd*t) * stepSize;\n                if (density > 0.)\n                {\n                    float lightTransmittance = 1.;\n                    if (calculateSunLight) lightTransmittance = lightMarch(ro+rd*t);\n\n                    lightEnergy += density * stepSize * transmittance * lightTransmittance * phaseVal;\n                    transmittance *= exp(-density * stepSize * 0.1);\n\n                    // Early exit\n                    if (transmittance < 0.01)\n                    {\n                        break;\n                    }\n                }\n            }\n\n            cloudCol = lightEnergy*sunColor;\n\n            return transmittance;\n        }\n\n\n\n        float shadow(in vec3 ro, in vec3 rd)\n        {\n            float res = 0.0;\n\n            float maxDist = 12.0;\n\n            float t = 0.001;\n            for (int i = 0; i < maxSteps; i++)\n            {\n                float h = sceneDistance(ro+rd*t);\n                if(h < 0.0001 || t > maxDist) break;\n                t += h;\n            }\n\n            if (t > maxDist) res = 1.0;// + pow(clamp(dot(ro, rd),0,1),5);\n\n\n            vec3 temp;\n            return res*SampleCloudDensity(ro, rd, temp, false);\n        }\n\n        float hash(float seed)\n        {\n                return fract(sin(seed)*43758.5453);\n        }\n\n        vec3 cosineDirection( in float seed, in vec3 nor)\n        {\n                float u = hash( 78.233 + seed);\n                float v = hash( 10.873 + seed);\n\n\n                // Method 1 and 2 first generate a frame of reference to use with an arbitrary\n                // distribution, cosine in this case. Method 3 (invented by fizzer) specializes\n                // the whole math to the cosine distribution and simplfies the result to a more\n                // compact version that does not depend on a full frame of reference.\n\n                #if 0\n                        // method 1 by http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n                        vec3 tc = vec3( 1.0+nor.z-nor.xy*nor.xy, -nor.x*nor.y)/(1.0+nor.z);\n                        vec3 uu = vec3( tc.x, tc.z, -nor.x );\n                        vec3 vv = vec3( tc.z, tc.y, -nor.y );\n\n                        float a = 6.2831853 * v;\n                        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n                #endif\n                #if 0\n                        // method 2 by pixar:  http://jcgt.org/published/0006/01/01/paper.pdf\n                        float ks = (nor.z>=0.0)?1.0:-1.0;     //do not use sign(nor.z), it can produce 0.0\n                        float ka = 1.0 / (1.0 + abs(nor.z));\n                        float kb = -ks * nor.x * nor.y * ka;\n                        vec3 uu = vec3(1.0 - nor.x * nor.x * ka, ks*kb, -ks*nor.x);\n                        vec3 vv = vec3(kb, ks - nor.y * nor.y * ka * ks, -nor.y);\n\n                        float a = 6.2831853 * v;\n                        return sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0-u)*nor;\n                #endif\n                #if 1\n                        // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n                        float a = 6.2831853 * v;\n                        u = 2.0*u - 1.0;\n                        return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n                #endif\n        }\n\n\n        vec3 uniformVector( in float seed)\n        {\n                float a = 3.141593*hash( 78.233 + seed);\n                float b = 6.283185*hash( 10.873 + seed);\n                return vec3( sin(b)*sin(a), cos(b)*sin(a), cos(a) );\n        }\n\n        bool intersectPlane(vec3 ro, vec3 rd, float height, out float dist)\n        {\n                if (rd.y==0.0)\n                {\n                        return false;\n                }\n\n                float d = -(ro.y - height)/rd.y;\n                d = min(100000.0, d);\n                if( d > 0. )\n                {\n                        dist = d;\n                        return true;\n                }\n                return false;\n        }\n\n        float hash(vec3 p)  // replace this by something better\n        {\n                p  = fract( p*0.3183099+.1 );\n                p *= 17.0;\n                return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n        }\n\n        vec3 calculateColor(vec3 ro, vec3 direction, float seed)\n        {\n                vec3 Sun = sun;\n                vec3 sunCol = 3.0*sunColor;\n                vec3 skyCol =  4.0*skyColor;\n                float px = (100./iResolution.y) * 1. * zoomDetailRatio;\n                const float epsilon = 0.0001;\n\n                vec3 col;\n                vec3 colorMask = vec3(1);\n                vec3 accumulatedColor = vec3(0.0);\n\n                float fdis = 0.0;\n\n                vec4 trap;\n                float steps;\n                bool hitSurface;\n                float t = trace(ro, direction, trap, px, steps, hitSurface);\n\n                // Water intersection and reflection\n                float dist;\n                bool intersects = intersectPlane(ro, direction, waterHeight, dist);\n                bool aboveWater = (ro + direction*t).y > waterHeight;\n\t\t\t\tfloat skyReflectAmount = 1.;\t\n            \n                // With unsifficient raymarching steps, we will we unable to make a perfect deduction about the state of the ray\n                // The following approach suffers in form of incorrectly labelling some of the water around the fractal as part of the real fractal\n                // This is the least punishing case, as the fractal will still be reflected on the water, thus we will most likely be able to get away with it\n                // Case A: Hit the fractal but we are under water. Case B: Did not hit the fractal, still above water after marching but will intersect with water.\n                // Stored as variable for future info\n                bool reflected = dist < maxWaterDist && (hitSurface && !aboveWater) || ((!hitSurface && aboveWater) && intersects);\n                if (reflected)\n                {\n                        col = vec3(0.,0,0.05);\n                        ro = ro + direction*dist;\n\n                        const float bumpDistance = 200.;\n                        const float epsilon = 0.2;\n\n\n                        float bumpfactor = bumpFactor * (1. - smoothstep( 0., bumpDistance, dist));\n\n                        vec2 coord = ro.xz+time*0.1;\n                        vec2 step = vec2(epsilon, 0.);\n\n                        vec3 nor = vec3(0.,1.,0.);\n                        nor.x = -bumpfactor * (cellular(coord + step.xy) - cellular(coord - step.xy)) / (2. * epsilon);\n                        nor.z = -bumpfactor * (cellular(coord + step.yx) - cellular(coord - step.yx)) / (2. * epsilon);\n                        nor = normalize(nor);\n                        direction = reflect(direction, nor);\n                    \tskyReflectAmount = 0.75*clamp(pow(dist,0.1),1.,2.);\n                }\n\n                for(int bounce = 0; bounce < 3; bounce++) // bounces of GI\n                {\n                        //rd = normalize(rd);\n\n                        //-----------------------\n                        // trace\n                        //-----------------------\n\n                        t = trace(ro, direction, trap, px, steps, hitSurface);\n\n                        if(!hitSurface)\n                        {\n                                // Clouds\n                            vec3 cloudCol;\n                                float transmittance = SampleCloudDensity(ro, direction, cloudCol, true);\n\n\n        \t\t\t\t\t\tcol += skyColor * (0.6 + 0.4 * pow(clamp(0.6-direction.y,0.,1.),1.2)) * skyReflectAmount;\n\n\n\n        col += sunSize * sunColor * pow(clamp(dot(direction, Sun), 0.0, 1.0),sunSpread);\n\n\n                                col = mix(col, edgeColor, pow(steps,fogDarkness));\n\n                                return col*transmittance+cloudCol;\n                        }\n\n                        if( bounce==0 ) fdis = t;\n\n                        vec3 pos = ro + direction * t;\n                        vec3 nor = calculateNormal(pos);\n\n                        //-----------------------\n                        // add direct lighitng\n                        //-----------------------\n                        colorMask *= surfaceColor;\n                        col.x += 1.-cos(trap.y);col.y += 0.8*cos(trap.x);col.z += sqrt(sin(trap.z));\n                        col*=brightness;\n\n                        vec3 light = vec3(0.0);\n\n                        // light 1\n                        float sunDif =  max(0.0, dot(Sun, nor));\n                        float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = shadow( pos + nor*epsilon, Sun);\n                        light += sunCol * sunDif * sunSha;\n\n                        // light 2\n                        vec3 skyPoint = cosineDirection( seed + 7.1*float(frame) + 5681.123 + float(bounce)*92.13, nor);\n                        float skySha = shadow( pos + nor*epsilon, skyPoint);\n                        light += skyCol * skySha;\n\n\n                        accumulatedColor += colorMask * col * light;\n\n                        //-----------------------\n                        // calculate new ray\n                        //-----------------------\n                        float isDif = 0.8;\n                        if( hash(seed + 1.123 + 7.7*float(bounce)) < isDif )\n                        {\n                           direction = cosineDirection(76.2 + 73.1*float(bounce) + seed + 17.7*float(frame), nor);\n                        }\n                        else\n                        {\n                                float glossiness = 0.2;\n                                direction = normalize(reflect(direction, nor)) + uniformVector(seed + 111.123 + 65.2*float(bounce)) * glossiness;\n                        }\n\n                        ro = pos;\n           }\n\n           return accumulatedColor;\n        }\n\n        vec3 render(vec3 origin, vec3 direction, vec2 uv)\n        {\n                float px = (100./iResolution.y) * 1. * zoomDetailRatio;\n                vec4 trap;\n                float steps;\n                bool hitSurface = false;\n\n                float t = trace(origin, direction, trap, px, steps, hitSurface);\n\n                vec3 col = vec3(0);\n\n\n                vec3 Sun = sun;\n\n                // Color the sky if we don't hit the fractal\n                if(t < 0.0)\n                {\n                        // Sky gradient\n\n        col += skyColor * (0.6 + 0.4 * direction.y);\n\n\n                        // Sun\n\n        col += sunSize * sunColor * pow(clamp(dot(direction, Sun), 0.0, 1.0), sunSpread);\n\n\n                        col = mix(col, edgeColor, pow(steps,fogDarkness));\n                }\n                else\n                {\n                        col.x += 1.-cos(trap.y);col.y += 0.8*cos(trap.x);col.z += sqrt(sin(trap.z));\n\n                        // Lighting\n\n                        // The end position of the ray\n                        vec3 pos = (origin + direction * t);\n\n                        vec3 normal = calculateNormal(pos);\n\n                        vec3 fractalToSunDir = normalize(Sun - direction);\n                        float occlusion = clamp(0.05*log(trap.x),0.0,1.0);\n                        float fakeSSS = clamp(1.0+dot(direction, normal),0.0,1.0);\n\n                        // Sun\n                        float shadow = SoftShadow(pos + 0.001 * normal, fractalToSunDir, shadowSoftness);\n                        float diffuse = clamp(dot(Sun, normal), 0.0, 1.0) * shadow * min(3.,0.5/steps);\n                        float specular = pow(clamp(dot(normal,fractalToSunDir),0.0,1.), 32.0 )*diffuse*(0.04+0.96*pow(clamp(1.0-dot(fractalToSunDir,Sun),0.0,1.0),5.0));\n\n                        // Bounce\n                        float diffuse2 = clamp( 0.5 + 0.5*dot(light, normal), 0.0, 1.0 )*occlusion;\n\n                        // Sky\n                        float diffuse3 = (0.7+0.3*normal.y)*(0.2+0.8*occlusion);\n\n                        vec3 light = vec3(0.0);\n                        diffuse *= specularStrength;\n                        light += 7.0*vec3(1.50,1.10,0.70)*diffuse;\n                        light += 4.0*vec3(0.25,0.20,0.15)*diffuse2;\n                        light += 1.5*vec3(0.10,0.20,0.30)*diffuse3;\n                        light += 2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occlusion); // ambient\n                        light += 4.*fakeSSS*occlusion;                            // fake SSS\n                        light = pow(light, vec3((light.x<1.) ? 1. : 1.5));\n\n                        light = pow(light, 1./vec3(shadowDarkness));\n                        col *= light;\n                        col = pow( col, vec3(0.7,0.9,1.0) );                  // fake SSS\n                        col += specular;\n\n                        // Reflection (?)\n                        //vec3 reflection = reflect( ray.dir, normal );\n                        //col += 8.0*vec3(0.8,0.9,1.0)*(0.2+0.8*occlusion)*(0.03+0.97*pow(fakeSSS,5.0))*smoothstep(0.0,0.1,reflection.y )*SoftShadow( Ray(pos+0.01*normal, reflection), 2.0 );\n                }\n\n                return pow(col, vec3(gamma));\n        }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n        int AA = int(antiAliasing);\n        vec3 col = vec3(0.0);\n\n        if (pathTrace)\n        {\n            \tuint p = uint(intHash(uint(fragCoord.x)))*intHash(uint(fragCoord.y));\n            \tuint f = intHash((uint(abs(frame))));\n                uint hash = uint(intHash(f+p));\n                vec2 frag = gl_FragCoord.xy;\n                // Anti aliasing\n                frag += hash2(hash, hash)*2.-1.;\n                vec2 uv = frag / iResolution.xy * 2.0 - 1.0;\n                uv.x *= float(iResolution.x) / float(iResolution.y);\n\n                vec3 direction = normalize(vec3(uv.xy, -1));\n\n\n                float seed = float(hash)/float(0xffffffffU);\n                col = calculateColor(position, direction, seed);\n\n                // gl_FragCoord is in the range [0.5, screenSize+0.5], so we subtract to get to [0, screenSize]\n                vec2 pos = gl_FragCoord.xy-vec2(0.5);\n                int index = int(pos.y*iResolution.x+pos.x);\n                \n                col = pow(col.xyz, vec3(gamma))+texture(iChannel0,fragCoord/iResolution.xy).xyz;\n            \tfragColor = vec4(col, 1);\n        }\n        else\n        {\n                for (int i = 0; i < AA; i++)\n                {\n                        for (int j = 0; j < AA; j++)\n                        {\n                                vec2 frag = gl_FragCoord.xy;\n                                frag += vec2(float(i),float(j))/float(AA);\n                                vec2 uv = frag / iResolution.xy * 2.0 - 1.0;\n                                uv.x *= float(iResolution.x) / float(iResolution.y);\n\n                                vec3 direction = normalize(vec3(uv.xy, -1));\n\n\n                                col += render(position, direction, uv);\n                        }\n                }\n                col /= vec3(AA*AA);\n        }\n\n\n}\n","name":"Buffer A","description":"","type":"buffer"}]}