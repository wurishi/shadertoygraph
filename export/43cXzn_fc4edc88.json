{"ver":"0.1","info":{"id":"43cXzn","date":"1719351216","viewed":45,"name":"魔法阵","username":"PTSXDWD","description":"魔法阵","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["glsl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//UV旋转\nvec2 rot(vec2 uv,float t){\n\tmat2 m = mat2(cos(t),sin(t),-sin(t),cos(t));  //旋转矩阵\n\treturn m * uv;\n}\n\n//uv缩放\nvec2 uvZoom(vec2 uv, float speed, float iTime){\n    uv = uv/smoothstep(0., speed, fract(iTime * .2));  //处理uv\n    return uv;\n}\n\n//圆环\nfloat roundness(vec2 uv, float circleSize, float l) {\n    float c1 = length(uv / (circleSize + l));  //外边缘\n    c1 = smoothstep(circleSize, circleSize - 0.005, c1);  //边缘模糊\n    float c2 = length(uv / circleSize);  //内边缘\n    c2 = smoothstep(circleSize, circleSize - 0.005, c2);  //边缘模糊\n    return c1 - c2;\n}\n\n//正方形\nfloat square(vec2 uv, float squareSize, float l) {\n    float c1 = 0.;  //外边缘\n    float c2 = 0.;  //内边缘\n    if(abs(uv.x) <= squareSize+l && abs(uv.y) <= squareSize+l){c1 = 1.;}  //外边缘\n    if(abs(uv.x) <= squareSize && abs(uv.y) <= squareSize){c2 = 1.;}  //内边缘\n    return c1 - c2;\n}\n\n//四角星范围\nfloat disc(vec2 uv, float circleSize, float l) {\n    float c = 1. - length(uv / (circleSize + l));  //范围\n    c = smoothstep(0., .3, c);  //衰减\n    return c;\n}\n\n//彩虹颜色\nvec3 palette(float t) {\n    vec3 a = vec3(.5, .5, .5);\n    vec3 b = vec3(.5, .5, .5);\n    vec3 c = vec3(1.0, 1.0, 1.);\n    vec3 d = vec3(.263, .416, .557);\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n//绘制魔法阵\nfloat magicCircle(vec2 uv, float iTime, float lineThickness, float circleSize, float squareSize, \n                  float circleSize2, float squareSize2, float circleSize3){\n    //uv\n    vec2 uv1 = rot(uv, -iTime * 1.);  //逆时针旋转\n    vec2 uv2 = rot(uv, iTime * 1.2);  //顺时针旋转\n    vec2 uv3 = uv;  //uv3\n    //外圆环\n    uv3 = uvZoom(uv1, .2, iTime);  //uv缩放速度与大小\n    float r1 = roundness(uv3, circleSize, lineThickness);  //圆环1\n    float r2 = roundness(uv3, circleSize - .08, lineThickness);  //圆环2\n    float r = r1 + r2;  //外圆环集合\n    //外八角星\n    uv3 = uvZoom(uv1, .3, iTime);  //uv缩放速度与大小\n    float s1 = square(uv3, squareSize, lineThickness);  //正方形1\n    float s2 = square(rot(uv3, 0.8), squareSize, lineThickness);  //正方形2\n    float s_01 = s1 + s2;  //外八角星输出\n    //内圆环\n    uv3 = uvZoom(uv2, .4, iTime);  //uv缩放速度与大小\n    float r3 = roundness(uv3, circleSize2, lineThickness);  //圆环3   \n    //内八角星\n    uv3 = uvZoom(uv2, .5, iTime);  //uv缩放速度与大小\n    float s3 = square(uv3, squareSize2, lineThickness);  //正方形3\n    float s4 = square(rot(uv3, 0.8), squareSize2, lineThickness);  //正方形4\n    float s_02 = s3 + s4;  //内八角星输出\n    //中心圆环\n    uv3 = uvZoom(uv1, .6, iTime);  //uv缩放速度与大小\n    float r4 = roundness(uv3, circleSize3, lineThickness);  //圆环4    \n    //中心四角星\n    uv3 = uvZoom(uv, .2, iTime);  //uv缩放速度与大小\n    float x = max(0., 1.-abs(uv3.x * uv3.y * 750.));  //中心四角星\n    x *= smoothstep(0., .7, fract(iTime * .2));  //中心四角星淡出\n    float d = disc(uv3, circleSize, lineThickness);  //四角星范围\n    x = smoothstep(0., .8, x);  //边缘模糊\n    x = mix(0., x, d);  //中心四角星输出\n    //输出\n    return clamp(r + s_01 + r3 + s_02 + r4 + x, 0., 1.);\n}\n\n\n//片元Shader\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //参数\n    float lineThickness = .01;  //线条粗细\n    float circleSize = .96;  //外圆环大小\n    float squareSize = .54;  //外八角星大小\n    float circleSize2 = .62;  //内圆环大小\n    float squareSize2 = .26;  //内八角星大小\n    float circleSize3 = .35;  //中心圆环大小\n    \n    //uv\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;  //uv\n    vec3 col = palette(length(uv) + iTime * .2);  //彩虹颜色\n\n    //绘制魔法阵\n    float m = magicCircle(uv, iTime, lineThickness, circleSize, squareSize,\n                          circleSize2, squareSize2, circleSize3);\n \n    //输出\n    col *= vec3(m);  //混合颜色\n    col += col;  //加强颜色\n    fragColor = vec4(col, 1.);  //输出结果至屏幕\n}","name":"Image","description":"","type":"image"}]}