{"ver":"0.1","info":{"id":"llccRH","date":"1531505636","viewed":270,"name":"Path Tracer Testing","username":"noxbuds","description":"First attempt at shading using Monte Carlo path tracing. Probably got some things wrong.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["3d","pathtrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Attempting to do raytracing with global     //\n//  illumination, approximated by a Monte Carlo //\n//  integration. Probably lots wrong, feel      //\n//  free to comment if I missed things :P       //\n//                                              //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Bloom and a bit of anti-aliasing in reflections\n// and stuff. Comment out to disable it.\n#define BLOOM\n\n// Look in Buf A to change the IOR of the colours\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Burgess tonemapping - looks fairly bright/cheerful, has quite\n// a bit of contrast aswell\nvec3 burgess(vec3 col)\n{\n    vec3 maxCol = max(vec3(0.0), col - 0.004);\n    vec3 retCol = (maxCol * (6.2 * maxCol + 0.05)) / (maxCol * (6.2 * maxCol + 2.3) + 0.06);\n    return pow(retCol, vec3(1.0 / 2.2));\n}\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Shift the co-ordinates to -1 <= x <= 1\n    // and correct the aspect ratio\n    //uv = uv * 2.0 - 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Grab colour from Buf A\n    col = texture(iChannel0, uv).rgb;\n    col *= 1.5;\n    \n    #ifdef BLOOM\n    // Add some bloom\n    for (float xOff = -10.0; xOff <= 10.0; xOff++)\n    {\n        for (float yOff = -10.0; yOff <= 10.0; yOff++)\n        {\n            // Distance multiplier\n            float falloff = min(0.1 / length(vec2(xOff, yOff)), 1.0);\n            \n            // Get colour\n            vec3 ncol = texture(iChannel0, (fragCoord + vec2(xOff, yOff)) / iResolution.xy).rgb;\n            \n            float bright = ncol.r * 0.2126 + ncol.g * 0.7152 + ncol.b * 0.0722;\n            \n            // Check if it's the bloom colour\n            col = mix(col, ncol, (falloff - 0.01) * pow(bright, 2.0));\n        }\n    }\n    #endif\n    \n    // Tonemapping to make the scene look better\n    col = pow(col, vec3(2.2));\n    col = burgess(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Attempting to do raytracing with global     //\n//  illumination, approximated by a Monte Carlo //\n//  integration. Probably lots wrong, feel      //\n//  free to comment if I missed things :P       //\n//                                              //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n// If NOISY is defined, then the shader won't\n// smoothen out over time; it will remain noisy\n//#define NOISY\n\n// If FAKE_AA is greater th, the rays will get a\n// (slight) random change in direction which, when\n// smoothed out, creates a sort of AA effect\n//#define FAKE_AA\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n#define PI 3.14159\n#define BIG_NUMBER 1e6\n#define EPS 1e-3\n\n// Lighting data\nvec3 lightDir = normalize(vec3(0.0, -0.6, 0.4));\nvec3 ambientLight = vec3(0.1, 0.2, 0.3);\n\n/////////////////////////////////////////////////\n//                                             //\n//             OBJECT DATA TYPES               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Sphere\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n};\n    \n// Box\nstruct Box\n{\n    vec3 pos;\n    vec3 dim;\n};\n    \n/////////////////////////////////////////////////\n//                                             //\n//                 UTILITIES                   //\n//                                             //\n/////////////////////////////////////////////////\n    \n// Calculates the boundaries of a box\nvoid calcBounds(Box box, out vec3 bmin, out vec3 bmax)\n{\n    // First calculate minimum bounds\n    bmin = box.pos - box.dim / 2.0;\n    \n    // Then calculate maximum bounds\n    bmax = box.pos + box.dim / 2.0;\n}\n\n// Returns the minimum component of a vector\nfloat min3(vec3 v)\n{\n    return min(min(v.x, v.y), v.z);\n}\n\n// Returns the maximum component of a vector\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\n// Swaps two terms\nvoid swap(inout float a, inout float b)\n{\n    float temp = a;\n    a = b;\n    b = temp;\n}\n\n// Random 3D vector function\nvec3 R3D(vec3 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    vec3 v = fract(vec3(a.x * a.y, a.y * a.z, a.x * a.z));\n    return normalize(v * 2.0 - 1.0);\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//                   SCENE                     //\n//                                             //\n/////////////////////////////////////////////////\n\n// Objects\nSphere Sphere_1;\nSphere Sphere_2;\nBox Box_1;\n\n// Initialises the properties of each object\nvoid buildScene()\n{\n    // Setup the first sphere\n    Sphere_1.pos = vec3(-8.0, 1.0, -1.0);\n    Sphere_1.radius = 1.0;\n    \n    // Setup the second sphere\n    Sphere_2.pos = vec3(-4.0, 0.8, 0.0);\n    Sphere_2.radius = 1.0;\n    \n    // Setup the box\n    Box_1.pos = vec3(-5.0, 2.0, 2.0);\n    Box_1.dim = vec3(8.0, 4.0, 2.0);\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//           INTERSECTION FUNCTIONS            //\n//                                             //\n/////////////////////////////////////////////////\n\n// Sphere intersection\nfloat iSphere(Sphere sph, vec3 ro, vec3 rd)\n{\n    // move the sphere position\n    ro = ro - sph.pos;\n    \n    // intersection math\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - sph.radius * sph.radius;\n    float h = b * b - 4.0 * c;\n    if (h < 0.0) return -1.0;\n    float t = (-b - sqrt(h)) / 2.0;\n    return t;\n}\n\n// Box intersection function\nfloat iBox(Box box, vec3 ro, vec3 rd)\n{\n    // Calculate bounds\n    vec3 bmin, bmax;\n    calcBounds(box, bmin, bmax);\n    \n    // Calculate minima and maxima\n    vec3 tmin3 = (bmin - ro) / rd;\n    vec3 tmax3 = (bmax - ro) / rd;\n    \n    // Get the real minima and maxima\n    if (tmin3.x > tmax3.x) swap(tmin3.x, tmax3.x);\n    if (tmin3.y > tmax3.y) swap(tmin3.y, tmax3.y);\n    if (tmin3.z > tmax3.z) swap(tmin3.z, tmax3.z);\n    \n    // Calculate minimum and maximum point\n    // from all the components of the vector\n    float tmin = max3(tmin3);\n    float tmax = min3(tmax3);\n    \n    // Skip over the box if we are out of bounds\n    if (tmin > min3(tmax3) || max3(tmin3) > tmax)\n        return -1.0;\n    \n    // Return the closest point\n    return min(tmin, tmax);\n}\n\n// Plane intersection\nfloat iPlane(vec3 ro, vec3 rd, float h)\n{\n    return -ro.y / rd.y - h;\n}\n\n// Sphere normal\nvec3 nSphere(vec3 o, Sphere sph)\n{\n    return (o - sph.pos) / sph.radius;\n}\n\n// Plane normal\nvec3 nPlane(vec3 p)\n{\n    return vec3(0.0, 1.0, 0.0);\n}\n\n// Box normal\nvec3 nBox(vec3 p, Box box)\n{\n    // Shift p to box co-ordinates\n    vec3 v = p - box.pos;\n    v /= box.dim * 0.5;\n    \n    // 1 - eps\n    float _1_eps = 1.0 - EPS * 2.0;\n    \n    // Calculate the normal\n    if (v.x > _1_eps)\n        return vec3(1.0, 0.0, 0.0);\n    if (v.x < -_1_eps)\n        return vec3(-1.0, 0.0, 0.0);\n    if (v.y > _1_eps)\n        return vec3(0.0, 1.0, 0.0);\n    if (v.y < -_1_eps)\n        return vec3(0.0, -1.0, 0.0);\n    if (v.z > _1_eps)\n        return vec3(0.0, 0.0, 1.0);\n    if (v.z < -_1_eps)\n        return vec3(0.0, 0.0, -1.0);\n    \n    // Don't know if this is possible\n    return vec3(0.0);\n}\n\n// Looks nowhere near as tidy as the combine function\n// for raymarching. Oh well.\nvec2 combine(vec2 a, vec2 b)\n{\n    vec2 h = vec2(BIG_NUMBER, 0.0);\n    if (a.x < h.x && a.x > 0.0)\n        h = a;\n    if (b.x < h.x && b.x > 0.0)\n        h = b;\n    return h;\n}\n\n// Returns a material ID for shading.\nvec2 intersect(vec3 o, vec3 r)\n{\n    // Base hit data\n    vec2 v = vec2(BIG_NUMBER, 0.0);\n    \n    // Draw a sphere\n    float sphere = iSphere(Sphere_1, o, r);\n    \n    // Draw another sphere\n    float sphere2 = iSphere(Sphere_2, o, r);\n    \n    // Draw a plane\n    float plane = iPlane(o, r, 0.0);\n    \n    // Draw a box\n    float box = iBox(Box_1, o, r);\n    \n    // Combine the hit data\n    v = combine(v, vec2(sphere, 1));\n    v = combine(v, vec2(plane, 2));\n    v = combine(v, vec2(sphere2, 3));\n    v = combine(v, vec2(box, 4));\n    \n    // Return the hit data\n    return v;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              LIGHTING/SHADING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Diffuse\nvec3 diffuse(vec3 col, vec3 n)\n{\n    // Diffuse multiplier\n    float diff = max(dot(-lightDir, n), 0.0);\n    \n    // Combine the two\n    return col * diff;\n}\n\n// Specular\nvec3 specular(vec3 col, vec3 n, vec3 r)\n{\n    // Ambient light\n    float amb = 0.5 + 0.5 * n.y;\n    vec3 ambCol = amb * ambientLight;\n\n    // Diffuse shading\n    vec3 diff = diffuse(col, n) + ambCol;\n\n    // Specular highlights\n    vec3 refLight = normalize(reflect(-lightDir, n));\n    float spec = max(dot(r, refLight), 0.0);\n    vec3 specular = vec3(0.0);\n\n    // Create a specular highlight colour\n    spec = pow(spec, 20.0);\n    specular = vec3(ambientLight * 1.0 * spec);\n\n    // Add the diffuse and specular parts\n    return diff + spec;\n}\n\n// Calculates hard shadows\n// Can't figure out how to do these as soft shadows...\nfloat shadow(vec3 p)\n{\n    // Calculate hit data\n    vec2 hit = intersect(p, -lightDir);\n    \n    // If we hit anything, return 0\n    if (hit.y > 0.0 && hit.x > EPS)\n        return 0.5;\n    else\n        return 1.0;\n}\n\n// Creates a checkered pattern\nvec3 checker(vec2 p, vec3 col)\n{\n    // Calculate cell co-ordinates\n    vec2 c = (p - mod(p, 2.0)) / 2.0;\n\n    // Result of mod\n    float modx = mod(c.x, 2.0);\n    float mody = mod(c.y, 2.0);\n\n    // Create the chess-board-style texture\n    if (modx < 0.05 && mody > 0.05)\n        col *= 0.5;\n    if (modx > 0.05 && mody < 0.05)\n        col *= 0.5;\n    \n    // Return the colour\n    return col;\n}\n\n// Sphere UV\nvec2 sphereUV(vec3 p, vec3 n)\n{\n    // Calculate UV co-ordinates; we use\n    // cylindrical mapping here\n    vec2 uv = vec2(atan(n.x, n.z) / (2.0 * PI) + 0.5, p.y * 0.5 + 0.5);\n\n    // Calculate UV x co-ordinate\n    uv.x = mod((uv.x + 0.22) * 2.0, 1.0);\n\n    // Correct the UV coordinates\n    return uv * 2.0 - 1.0;\n}\n\n// Calculates a colour\nvec3 material(float id, vec3 p, out vec3 n, vec3 r, out float hitDiffuse)\n{\n    // Setup colour\n    vec3 col = vec3(0.0);\n    hitDiffuse = 0.0;\n    \n    // Only colour in if we hit something\n    if (id == 1.0)\n    {\n        // The sphere\n        \n        // Calculate normal\n        n = nSphere(p, Sphere_1);\n        \n        // Base colour\n        vec3 bcol = vec3(0.0, 0.5, 0.35);\n        col = specular(bcol, n, r);\n        col = bcol;\n    }\n    else if (id == 2.0)\n    {\n        // The plane (floor)\n        hitDiffuse = 0.7;\n        \n        // Calculate normal\n        n = nPlane(p);\n        \n        // Base colour\n        vec3 bcol = vec3(0.2, 0.6, 0.9);\n        \n        // Create a pattern\n        bcol = checker(p.xz, bcol);\n        \n        // Lighting\n        col = diffuse(bcol, n);\n        col = bcol;\n    }\n    else if (id == 3.0)\n    {\n        // The sphere\n        hitDiffuse = 0.6;\n        \n        // Calculate normal\n        n = nSphere(p, Sphere_2);\n        \n        // Base colour\n        vec3 bcol = vec3(1.0, 0.1, 0.0);\n        \n        // Map a texture\n        vec2 uv = sphereUV(p, n);\n        bcol = texture(iChannel1, uv * vec2(0.2, 1.0) + vec2(0.2, 0.0)).rgb;\n        \n        // Specular shading\n        col = specular(bcol, n, r);\n        col = bcol;\n    }\n    else if (id == 4.0)\n    {\n        // The box\n        hitDiffuse = 0.4;\n        \n        // Calculate normal\n        n = nBox(p, Box_1);\n        \n        // Colour it in\n        vec3 bcol = vec3(0.1, 1.0, 0.0);\n        col = specular(bcol, n, r);\n        col = bcol;\n    }\n    \n    // Return colour\n    return col;\n}\n\n// Casts a ray and returns its final colour\nvec3 castRay(inout vec3 o, inout vec3 r, out bool sbreak, out vec3 p, out vec3 n, out float id)\n{\n    // Calculate hit data\n    vec2 hit = intersect(o, r);\n\t\n    // Get the properties with better names\n    float t = hit.x;\n    id = hit.y;\n\n    // Setup position\n    p = o + r * (t + 0.001);\n\t\n    // Get material data\n    float hitDiffuse = 0.0;\n    vec3 fcol = material(id, p, n, r, hitDiffuse);\n\t\n    // Shift the position and stuff\n    if (id > 0.0 && hit.x > EPS)\n    {\n        // Change origin and reflect ray\n        o = p + n * EPS;\n        \n        \n        vec3 vRef = reflect(r, n);\n        vec3 vDiffuse = normalize(R3D(p * (iTime + 1.0)));\n        \n        r = mix(vRef, vDiffuse, hitDiffuse);\n        \n        // Return the colour\n        return fcol;\n    }\n    else\n    {\n        sbreak = true;\n        return texture(iChannel0, r).rgb;\n    }\n}\n\n// Monte Carlo ray tracing\nvec3 mcRaytrace(inout vec3 o, inout vec3 r, out bool breakl)\n{\n    // Setup p and n\n    vec3 p, n = vec3(0.0);\n    float id = 0.0;\n    \n    #ifdef FAKE_AA\n    // Generate random vector\n    vec3 rrv = R3D(o + r * (iTime + 1.0));\n    rrv = normalize(rrv);\n    \n    // Add the random vector\n    r += rrv.xzy * 0.001;\n    #endif\n    \n    // Get the base colour\n    bool sbreak = false;\n    vec3 col = castRay(o, r, sbreak, p, n, id);\n    vec3 bkp = p + n * EPS;\n    breakl = sbreak;\n    \n    if (id < 1.0) return col;\n    \n    // Monte Carlo indirect lighting\n    float N = 16.0;\n    vec3 ila = vec3(0.0);\n    \n    // Iterate through each sample\n    for (float ns = 0.0; ns < N; ns++)\n    {\n        // Generate random vector\n        vec3 rv = R3D(p * ns * (iTime + 1.0));\n        rv = normalize(rv);\n        \n        p = p + n * EPS;\n        \n        // Approximate the indirect lighting\n        vec3 p_, n_ = vec3(0.0);\n        ila += castRay(p, rv, sbreak, p_, n_, id);\n        p = bkp;\n    }\n    \n    // Average it out\n    ila /= N;\n    \n    // Add the indirect lighting\n    col += ila;\n    col /= 2.0;\n    \n    // Soft shadows using Monte Carlo approximation\n    N = 16.0;\n    vec3 sa = vec3(0.0);\n    \n    // Iterate through each sample\n    for (float ns = 0.0; ns < N; ns++)\n    {\n        // Generate random vector\n        vec3 rv = R3D(p * ns * (iTime + 1.0)) * 0.2;\n        \n        // Point the ray in the direction of the light direction\n        rv -= lightDir;\n        \n        // Cast a ray\n        vec3 p_, n_ = vec3(0.0);\n        vec3 scol = castRay(p, rv, sbreak, p_, n_, id);\n        p = bkp;\n        \n        // If we hit something\n        if (id < 1.0)\n            sa += vec3(1.0);\n    }\n    \n    // Average it out\n    sa /= N;\n    \n    // Add the shadow\n    col *= sa;\n    \n    // Return colour\n    return col;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Calculates the brightness of a colour\nfloat calcBrightness(vec3 col)\n{\n    return col.r * 0.2126 + col.g * 0.7152 + col.b * 0.0722;\n}\n\n// Image composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup UV co-ordinates and correct them\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Normalised mouse position\n    vec2 mp = iMouse.xy / iResolution.xy;\n    mp = (mp * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Setup the scene\n    buildScene();\n    \n    // Ray stuff\n    vec3 o = vec3(mp.x * 3.0, 1.5, mp.y * 3.0 - 4.0);\n    vec3 r = normalize(vec3(uv, 0.58 * PI));\n    \n    // Setup pixel colour\n\tvec3 col = vec3(0.0);\n    \n    // Max ray bounces\n    int maxBounces = 6;\n    int rn = 0;\n    \n    // Path tracing\n    for (rn = 0; rn < 6; rn++)\n    {\n        bool sbreak = false;\n    \tcol += mcRaytrace(o, r, sbreak);\n        if (sbreak) break;\n    }\n    col /= float(rn) + 1.0;\n    \n    // Output to screen\n    #ifdef NOISY\n    // This is without any multipass things - it makes it noisy\n    fragColor = vec4(col, 1.0);\n    #else\n    // This is with some blending between frames to reduce noise\n    col += texture(iChannel2, fragCoord / iResolution.xy).rgb * float(iFrame);\n    fragColor = vec4(col / float(iFrame + 1), 1.0);\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"}]}