{"ver":"0.1","info":{"id":"ctSczG","date":"1691883620","viewed":38,"name":"GPU Racer","username":"medley","description":"This is my submission for the Husky Jam 2023. Controls are in the comment at the top. Enjoy!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["gamejam","lanes","roadtripping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/***********************************************************\nThis is my submission for the Husky Jam 2023. Move the mouse\nhorizontally across the screen to control the car. You lose\nif you see a red screen. The game will just keep going after\nthat, but if you want to restart you can pause the preview\nand hit the |< button.\n\nIf you lose, you can press the left arrow button in the\npreview window to restart.\n\nHave fun! :D\n***********************************************************/\n\n// This function controls the difficulty.\n// 3.0 seems to be a minimum for some reason :/\n// Higher = easier, 3.0 recommended\nfloat speed()\n{\n    return 3.0; // This is a function cause I'm still working\n                // on how to make this speed up over time.\n}\n\n// Here are some controls over the raymarcher.\n#define HIT_THRESH 0.005\n#define RAYMARCH_ITER 256\n\n#define PI 3.14159265358979\n\n// Represents the material of an in-engine object.\nstruct Material\n{\n    vec3 albedo;\n    vec3 ambient;\n};\n\n// Positions\nfloat xPosns[3] = float[3](-3.0,0.0,3.0);\n\n\nMaterial mats[4] \n= Material[4](\n    Material(vec3(0.7,0.7,0.7),vec3(0.2,0.2,0.2)),\n    Material(vec3(0.9,0.9,0.9),vec3(0.2,0.2,0.2)),\n    Material(vec3(0.2,0.1,0.1),vec3(0.3,0.1,0.0)),\n    Material(vec3(0.0,0.0,0.0),vec3(0.0,0.0,0.0))\n);\n\n/**\n * The signed distance field of a plane (inexact).\n * Source: Inigo Quilez\n *\n * @param p The point at which to evaluate the sdf\n * @return The signed distance to the \"plane\"\n */\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\n/**\n * Calculate the distance to and color of the road.\n * \n * @param p The point at which to evaluate the road\n * @return A vec2 in the format (dist,mat)\n */\nvec2 mapRoad( vec3 p )\n{\n    float d = p.y;\n    float stripe = mod(p.z+iTime*(speed()*4.0+1.0),3.0);\n    int idx = 4 * int((p.x < -6.0 && p.x > -6.5)\n        || (p.x > 6.0 && p.x < 6.5)\n        || (p.x > -0.25 && p.x < 0.25 &&\n            stripe > 0.5 && stripe < 1.5));\n    \n    return vec2(d, idx);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCrate( vec3 p )\n{\n    // This is an abomination to the craft of graphics programming.\n    // Inigo, I have failed you.\n    int cratePos = int(mod(floor(texture(iChannel0,vec2(floor(iTime/speed()) / iChannelResolution[0].x,floor(iTime/(speed()*speed()))/iChannelResolution[0].y)).y * (speed() * speed())),3.0));\n    float crateDist = (speed() - mod(iTime,speed())) / speed() * 40.0 - 5.0;\n    return sdBox( p - vec3(xPosns[cratePos],1.0,crateDist), vec3(2.0));\n}\n\n/**\n * Find the closer object\n *\n * @param o1 The first object to compare\n * @param o2 The second object to compare\n * @return A two-component vector containing the distance\n *         to and material of the closer object\n */\nvec2 minObj( vec2 o1, vec2 o2 )\n{\n    float d = min(o1.x,o2.x);\n    float m = o1.y * float(o1.x<o2.x) +\n              o2.y * float(o2.x<o1.x);\n    return vec2(d,m);\n}\n\n/**\n * Get the signed distance to the scene at a given point,\n * as well as the material of the closest object.\n * \n * @param pos The point to evaluate the distance at\n * @return A two-component vector containing scene\n *         distance and material index\n */\nvec2 map( vec3 pos )\n{\n    float dc = sdCrate(pos);\n    vec2 rd = mapRoad(pos);\n    //return vec2(pos.y,1.0);\n    return minObj(vec2(dc,2.0),rd);\n    return rd;\n}\n\n/**\n * Get the normal of the scene at the given point.\n * Source: Inigo Quilez\n *\n * @param p The point at which to evaluate the normal\n * @return The normal of the scene as a vec3\n */\nvec3 calcNormal( in vec3 p )\n{\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy).x - map(p-h.xyy).x,\n                           map(p+h.yxy).x - map(p-h.yxy).x,\n                           map(p+h.yyx).x - map(p-h.yyx).x));\n}\n\n/**\n * Get the position at which a given ray intersects the scene,\n * as well as the proper material.\n *\n * @param ro   The ray origin\n * @param rd   The ray direction\n * @param tmin The near clipping plane, or minimum distance the ray must travel\n * @param tmax The far clipping plane, or maximum distance the ray can travel\n * @return A two-component vector containing the traveled\n *         distance and the material of the object hit\n */\nvec2 castRay( vec3 ro, vec3 rd, float tmin, float tmax )\n{\n    float t = tmin; // Start at the near plane\n    float m = 0.0;\n    \n    // March the ray along its direction\n    for (int i = 0; i < RAYMARCH_ITER; i++)\n    {\n        // Evaluate the distance to the scene\n        vec2 d = map(ro+rd*t);\n        \n        // Advance t according to the distance\n        t += d.x;\n        \n        // Unadvance and stop evaluating if we're below the hit threshold\n        t -= d.x * float(d.x < HIT_THRESH);\n        i += RAYMARCH_ITER * int(d.x < HIT_THRESH);\n        m = d.y * float(d.x < HIT_THRESH);\n        \n        // Stop evaluating if the t value exceeds the maximum\n        i += RAYMARCH_ITER * int(t > tmax);\n    }\n    \n    return vec2(t,m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Screen coordinate space\n    vec2 screen = fragCoord / iResolution.xy;\n    \n    // Better coordinate space\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Clipping planes\n    float near = 0.5;\n    float far = 100.0;\n    \n    // Set up camera and cast the ray\n    vec3 cam = vec3(xPosns[int(iMouse.x/iResolution.x>0.33)+int(iMouse.x/iResolution.x>0.66)],2.0,-1.5);\n    vec3 dir = normalize(vec3(p,1.0));\n    vec2 res = castRay(cam, dir, near, far);\n    \n    Material mat = mats[int(res.y)];\n    \n    // Initial color albedo\n    vec3 col = mat.ambient;\n    \n    if ( res.y == 0.0 )\n    {\n        // Only use albedo for sky\n        col = mat.albedo;       \n    }\n    else\n    {\n        // Ambient color\n        col = mat.ambient;\n        \n        // Lit color\n        vec3 ld = normalize(vec3(1.0,1.0,-1.0)); // Light dir\n        vec3 lc = vec3(0.6,0.6,0.6); // Light color\n        col += mat.albedo * lc * clamp(dot(calcNormal(cam+dir*res.x),ld),0.0,1.0);\n        \n        // Bounce lighting\n        float bc = 0.15; // Bounce coefficient\n        col += mat.albedo * lc * (bc * clamp(dot(calcNormal(cam+dir*res.x),-ld),0.0,1.0));\n        \n        // Sky lighting\n        vec3 scol = mats[0].albedo;\n        float scoef = 0.1;\n        col += scol * scoef\n                    * clamp(dot(calcNormal(cam+dir*res.x),vec3(0.0,1.0,0.0)),0.0,1.0);\n    }\n    \n    // Gamma correction\n    col = vec3(pow(col.x,1.0/2.2),pow(col.y,1.0/2.2),pow(col.z,1.0/2.2));\n    \n    // Death awaits\n    if (sdCrate(cam) < 1.0)\n    {\n        col = vec3(0.7,0.0,0.0);\n    }\n    \n    // Final color\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}