{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Visualization of symmetries used to simpify SDFs\n\n#define max4(A,B,C,D) max(max(A,B),max(C,D))\n#define max3(A,B,C) max(max(A,B),C)\n\nfloat sdCube(vec3 p,float r) {\n    p = abs(p);\n    return max3(p.x,p.y,p.z) - r;\n}\n\nfloat sdOctahedron(vec3 p,float r) {\n    p = abs(p);\n    return (p.x+p.y+p.z)/sqrt(3.) - r;\n}\n\n#define PHI 1.6180339887\n\nfloat sdDodecahedron(vec3 p,float r) {\n    p = abs(p);\n    return max3( p.y+p.z*PHI, p.z+p.x*PHI, p.x+p.y*PHI )/sqrt(2.+PHI) - r;\n}\n\nfloat sdIcosahedron(vec3 p,float r) {\n    p = abs(p);\n    return max4( p.x+p.y+p.z, p.y/PHI+p.z*PHI, p.z/PHI+p.x*PHI, p.x/PHI+p.y*PHI )/sqrt(3.) - r;\n}    \n\n// Circumscribed sphere radius ratio to Inscribed sphere radius (thanks spalmer)\n#define CircSphTetrahedron  (1./3.)\n#define CircSphCube         sqrt(1./3.)\n#define CircSphOctahedron   sqrt(1./3.)\n#define CircSphDodecahedron sqrt(1./PHI)\n#define CircSphIcosahedron  sqrt(1./PHI)\n\n#define ROT2(ANG) mat2(cos(ANG),sin(ANG),-sin(ANG),cos(ANG))\n\nvec3 Spin(float tim,vec3 p) {\n   tim += iTime;\n   p.xz *= ROT2(tim*.75);\n   p.yz *= ROT2(tim*.25);\n   p.yx *= ROT2(tim*.5);\n   return p;\n}\n\n#define sin1(X) (.5+.5*sin(X))\n#define sinab(X,A,B) (sin1(X)*(B-A)+A)\n#define PI 3.141592653589793\n\nbool hide;\nvec3 Split(vec3 p) {\n   p = abs(p);\n   p -= max(0.,sinab(iTime*.5-PI/2.,-.5,1.));\n   hide = p.x < 0. || p.y < 0. || p.z < 0.;\n   p = max(p,vec3(0));   \n   return p;\n}\n\n#define T(SDF) if ( (tmp = SDF) < hit.x ) hide2=hide, hit = vec2(tmp,clr); clr += 1.;\n\nbool hide2;\nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n\n    float SZ=5.;\n    \n    float YP=7.;\n    clr = 0.;\n\n    T(sdCube(        Split(Spin(2.,pt-vec3(9,7,9))),SZ*CircSphCube));\n    T(sdOctahedron(  Split(Spin(3.,pt-vec3(-9,7,9))),SZ*CircSphOctahedron));\n    T(sdDodecahedron(Split(Spin(4.,pt-vec3(9,-7,9))),SZ*CircSphDodecahedron));\n    T(sdIcosahedron( Split(Spin(5.,pt-vec3(-9,-7,9))),SZ*CircSphIcosahedron));\n\n    T(pt.z+200.);\n    return hit;\n}\n\n\nvec4 March(vec3 beg,vec3 dir) {\n    float dist = 0.;\n    vec3 pos;\n    #define LIMIT 100\n    for ( int stps = 0; stps <= LIMIT; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( obj.x < .001 || stps == LIMIT ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .4;\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\nfloat pow2n(float i,int n)\n{\n  while ( n-- > 0 ) i *= i;\n  return i;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (U+U-R) / min(R.x,R.y);  // -1 ... +1\n    uv /= 5.;\n    \n    vec3 cam = vec3( 0, 0, -64.);\n    vec3 camdir = normalize( vec3( uv, 1. ) );\n    \n    vec4 hit = March( cam, camdir );\n    vec3 norm = Normal(hit.xyz);\n    \n    vec3 light = vec3( 0, 10, -10 );\n    vec3 dir = normalize( light - hit.xyz );\n    float difu = dot( norm, dir );\n    \n    difu = .5 + .5*difu;\n    \n    #define col4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    O = sqrt( col4(hit.w*.4) );\n    O *= difu + pow2n(difu,9);\n    if ( hide2 ) O *= 0.;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"43ccDn","date":"1734923361","viewed":98,"name":"Spliting Polyhedra","username":"dray","description":"8 identical parts (with mirroring) of a few polyhedra.\n","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["polyhedra","platonic"],"hasliked":0,"parentid":"lXcyRN","parentname":"Platonic Polyhedra Sizes"}}