{"ver":"0.1","info":{"id":"4lfSRX","date":"1438584440","viewed":1032,"name":" [SIG15]Terminator2_Mercury","username":"jvillegas","description":"A tribute to the scene of the T1000 resurrection in Terminator 2.","likes":11,"published":1,"flags":2,"usePreview":0,"tags":["metaballs","camera","mercury"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define N 15\nvec2 wicenters[N];\nfloat wilens[N];\nfloat RaStart[N];\nfloat EndTime[N];\nvec2 wicentersm[N];\nfloat pi = 3.1415926535897932384626433832795;\nfloat tT = 28.0;\nfloat tU = 25.0;\nfloat tM =15.0;\nfloat tpS = 18.0;\nfloat tS =22.0;\nfloat scaleBall =1.0;\n\n// iniciates arbitrary positions and lengths\n\nvoid initVecs(){\n\nwicenters[0] =vec2(0.45874,0.414764);\nwicenters[1] =vec2(0.614197,0.00408936);\nwicenters[2] =vec2(0.866638,0.998932);\nwicenters[3] =vec2(0.642395,0.163727);\nwicenters[4] =vec2(0.937103,0.419952);\nwicenters[5] =vec2(0.372375,0.708374);\nwicenters[6] =vec2(0.0341492,0.665619);\nwicenters[7] =vec2(0.321838,0.732941);\nwicenters[8] =vec2(0.925201,0.779694);\nwicenters[9] =vec2(0.768188,0.887817);\nwicenters[10] =vec2(0.742371,0.435059);\nwicenters[11] =vec2(0.244629,0.831665);\nwicenters[12] =vec2(0.670593,0.107422);\nwicenters[13] =vec2(0.821289,0.485901);\nwicenters[14] =vec2(0.205627,0.571014);\nwilens[0] =0.0810867;\nwilens[1] =0.0812851;\nwilens[2] =0.0858078;\nwilens[3] =0.0840393;\nwilens[4] =0.0885834;\nwilens[5] =0.0699341;\nwilens[6] =0.0698898;\nwilens[7] =0.055661;\nwilens[8] =0.0868881;\nwilens[9] =0.074411;\nwilens[10] =0.068898;\nwilens[11] =0.0667572;\nwilens[12] =0.0555908;\nwilens[13] =0.0778244;\nwilens[14] =0.0822388;\nRaStart[0] =0.714111;\nRaStart[1] =2.84601;\nRaStart[2] =2.90076;\nRaStart[3] =5.44427;\nRaStart[4] =4.28192;\nRaStart[5] =0.186035;\nRaStart[6] =4.94879;\nRaStart[7] =1.80652;\nRaStart[8] =3.75952;\nRaStart[9] =4.16034;\nRaStart[10] =0.642517;\nRaStart[11] =4.34271;\nRaStart[12] =1.71716;\nRaStart[13] =2.98096;\nRaStart[14] =3.15875;\nEndTime[0] =11.582;\nEndTime[1] =4.13228;\nEndTime[2] =5.46328;\nEndTime[3] =9.27904;\nEndTime[4] =7.25116;\nEndTime[5] =2.97096;\nEndTime[6] =11.9494;\nEndTime[7] =11.8675;\nEndTime[8] =6.68617;\nEndTime[9] =14.0748;\nEndTime[10] =13.4538;\nEndTime[11] =8.06619;\nEndTime[12] =6.44497;\nEndTime[13] =11.5162;\nEndTime[14] =6.69735;\n\nwicentersm[0] =vec2(0.436259,0.499708);\nwicentersm[1] =vec2(0.59914,0.510903);\nwicentersm[2] =vec2(0.403966,0.336172);\nwicentersm[3] =vec2(0.553396,0.670167);\nwicentersm[4] =vec2(0.239477,0.396473);\nwicentersm[5] =vec2(0.750656,0.499618);\nwicentersm[6] =vec2(0.292381,0.546264);\nwicentersm[7] =vec2(0.594034,0.373787);\nwicentersm[8] =vec2(0.383432,0.673328);\nwicentersm[9] =vec2(0.474048,0.807147);\nwicentersm[10] =vec2(0.706351,0.66046);\nwicentersm[11] =vec2(0.588251,0.890544);\nwicentersm[12] =vec2(0.533144,0.278963);\nwicentersm[13] =vec2(0.369283,0.175812);\nwicentersm[14] =vec2(0.31823,0.829804);\n\n\n    \n    for (int k = 0; k<N; k++){\n  \t  wicenters[k].x= wicenters[k].x*iResolution.x;\n   \t wicenters[k].y=wicenters[k].y*iResolution.y;\n    }\n    \n    for (int k = 0; k<N; k++){\n    wilens[k]*=(scaleBall*iResolution.x);\n    }\n    \n\n    for (int k = 0; k<N; k++){\n\n    wicentersm[k].x*=iResolution.x;\n    wicentersm[k].y*=iResolution.y;\n    }\n}\n\n// evaluates a circular Tukey window\nfloat tukey(vec2 pixCoords,vec2 centerCoords, float theRadius, float r){\n\tfloat d = distance(pixCoords,centerCoords);\n\tfloat w = d/theRadius;\n     if(w > 1.0){\n    \treturn 0.0;\n    }\n    else if (w <= (1.0 - r/2.0)){\n    \n    \treturn 1.0;\n    }\n    else{\n    \n    \treturn (0.5*(1.0+cos(2.0*pi/r*(w-1.0+r/2.0))));\n    \n    }\n    \n}\n\n// Heigh based distortion\nvec4 textuDist(vec2 pixCoords, float A){;\n    float Z =5.0; \n    vec2 uv = (pixCoords / iResolution.xy);// - vec2(0.5,0.5);\n    vec2 NewCord = uv*(Z-1.0)/(Z -A);// + vec2(0.5,0.5);\n    vec4 tempColor = texture(iChannel0, NewCord);\n    return tempColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     float modTime = mod(iTime,tT);\n    if(modTime < tpS){\n      scaleBall = 1.0;\n    }\n    else if ((modTime>=tpS)&&(modTime < tU)){\n         scaleBall = 1.0 + 0.4*(modTime-tpS)/(tU-tpS);\n    }\n    \n     else{\n      scaleBall = 1.4 - 0.4*(modTime-tU)/(tT-tU);\n    }\n    \n    initVecs();\n    vec4 tempColor;\n\n   \n    float Acum = 0.0;\n     vec2 currCent[N];\n    \n    for (int k = 0; k<N; k++){\n        \n     \n        \n        if (modTime < RaStart[k]){\n        \n        \tcurrCent[k] = wicenters[k];\n        \n        }  \n        else if((modTime >= RaStart[k])&&(modTime<EndTime[k]))\n        \n        {      \n       \t  currCent[k] = (wicenters[k] + (modTime-RaStart[k])/(EndTime[k]-RaStart[k])*(wicentersm[k] - wicenters[k]));\n        }\n        else if ((modTime>=EndTime[k])&&(modTime < tS)){\n        \tcurrCent[k] = wicentersm[k];\n       }\n        \n        else if ((modTime>=tS)&&(modTime < tU)){\n        \n            currCent[k] = (wicentersm[k] + (modTime-tS)/(tU-tS)*(wicenters[k] - wicentersm[k]));\n        }\n        \n        else{\n           currCent[k] = wicenters[k];\n        }\n       Acum += tukey (fragCoord,currCent[k], wilens[k],1.0);\n    \n\n       \n    }\n    \n    float A;\n    if (modTime < tM){\n     A = min(0.95*Acum,1.0);\n    }\n    else if ((modTime>=tM)&&(modTime<tpS)){\n    \n     A = min((0.95 + 0.05*(modTime-tM)/(tpS-tM))*Acum,1.0);\n    \n    }\n    else if ((modTime>=tpS)&&(modTime < tU)){\n     A = min(Acum,1.0);\n    }\n    else{\n      A = min((1.0 - 0.05*(modTime-tU)/(tT-tU))*Acum,1.0);\n    }\n       \n        \n        // A = pow(A,1.0);\n\n    tempColor = textuDist(fragCoord,A);\n    float A2 =min(Acum,1.0);\n    fragColor = vec4(tempColor.r*A2,tempColor.g*A2,tempColor.b*A2,1.0);\n    \n}","name":"","description":"","type":"image"}]}