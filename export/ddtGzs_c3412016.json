{"ver":"0.1","info":{"id":"ddtGzs","date":"1677727075","viewed":130,"name":"floating around","username":"ianertson","description":"Use the mouse to look around :)","likes":10,"published":1,"flags":48,"usePreview":1,"tags":["3d","raytracing","raymarching","raymarch","sdf","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 getColor(vec2 uv) { return texture(iChannel0, uv).rgb; }\n\n\nvec3 blurx(vec2 uv, float f) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = clamp(1.0+f, 1.0, 8.0) / vec2(R.xy);//vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\n\nfloat estimateNoise(vec3 col, vec2 uv) {\n    vec2 e = vec2(1.0) / R.xy;\n    vec3 a = vec3(\n        luma(getColor(uv + vec2(e.x, 0))),\n        luma(getColor(uv + vec2(0, e.y))),\n        luma(getColor(uv + vec2(e.x, e.y)))\n    );\n    \n    float l = luma(col);\n    float n1 = abs(l - ((a.x+a.y+a.z)/3.));\n    float n2 = abs(a.x - a.y);\n    float n3 = abs(a.x - a.z);\n    float n4 = abs(a.y - a.z);\n    float n5 = fwidth(l);\n    \n    float n = (n1+n2+n3+n4+n5)/5.0;\n    return clamp(n*M_PI, 0.0, 1.0);\n}\n\nvec3 shade(vec2 uv) {\n    vec3 col = getColor(uv);\n    float depth = texture(iChannel0, uv).a;\n    float noiseEst = estimateNoise(col, uv);\n    \n    vec3 smo = blurx(uv, depth);\n    col = mix(col, smo, 0.8*clamp(noiseEst*noiseEst, 0.0, 1.0));\n    col = mix(col, smo, smoothstep(0.0, 0.36, depth)*0.9);\n\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = shade(uv);\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { dist = var; id = id_; }\n#define AMBIENT 0.05\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n\nstruct Material {\n    float rough;\n    float spec;\n    float metallic;\n};\n\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    int only;\n    Material m;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, 0, NEW_MATERIAL)\n\nstruct Light {\n    vec3 p;\n    vec3 d;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    switch (light.type) {\n        case LIGHT_AMBIENT: return normalize(light.p); break;\n        case LIGHT_POINT: return normalize(light.p - p); break;\n        case LIGHT_DIR: return normalize(light.d); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0)/max(0.0001, distance(light.p, p))); break;\n        case LIGHT_DIR: return light.c * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.xz, round(adot(n, vec3(0, 1, 0)))), p.zy, round(adot(n, vec3(1, 0, 0))));\n}\n\nvec3 noise(in sampler2D samp, in vec2 p, in float seed) {\n    return textureLod(samp, (p + (seed*1.0023981828))/256.0, 0.0).xyz;\n}\n\nvec3 snoise(in sampler2D samp, in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    \n    return mix(\n        mix(noise(samp, id, seed), noise(samp, id+vec2(1, 0), seed), lv.x),\n        mix(noise(samp, id+vec2(0, 1), seed), noise(samp, id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 noise(in sampler2D samp, in vec2 p, in float seed, in float freq) {\n    p += 2.2;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*noise(samp, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n/div;\n}\n\nvec3 snoise(in sampler2D samp, in vec2 p, in float seed, in float freq) {\n    p += 2.2;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*snoise(samp, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n/div;\n}\n\nvec3 noise6(in sampler2D samp, in vec2 p, in float seed, in float freq) {\n    p += 2.2;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*noise(samp, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n/div;\n}\n\nvec3 snoise6(in sampler2D samp, in vec2 p, in float seed, in float freq) {\n    p += 2.2;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    #define ADV n += amp*snoise(samp, p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    ADV;ADV;ADV;ADV;ADV;ADV;\n    #undef ADV\n    return n/div;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 fixNormal(vec3 wn, vec3 n, float th, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(th, dot(wn, n))));\n}\n\nvec3 uchimura(vec3 x, float P, float a, float m, float l, float c, float b) {\n  float l0 = ((P - m) * l) / a;\n  float L0 = m - m / a;\n  float L1 = m + (1.0 - m) / a;\n  float S0 = m + l0;\n  float S1 = m + a * l0;\n  float C2 = (a * P) / (P - S1);\n  float CP = -C2 / P;\n\n  vec3 w0 = vec3(1.0 - smoothstep(0.0, m, x));\n  vec3 w2 = vec3(step(m + l0, x));\n  vec3 w1 = vec3(1.0 - w0 - w2);\n\n  vec3 TT = vec3(m * pow(x / m, vec3(c)) + b);\n  vec3 S = vec3(P - (P - S1) * exp(CP * (x - S0)));\n  vec3 L = vec3(m + a * (x - m));\n\n  return TT * w0 + L * w1 + S * w2;\n}\n\nvec3 uchimura(vec3 x) {\n  const float P = 1.0;  // max display brightness\n  const float a = 1.0;  // contrast\n  const float m = 0.22; // linear section start\n  const float l = 0.4;  // linear section length\n  const float c = 1.33; // black\n  const float b = 0.0;  // pedestal\n\n  return uchimura(x, P, a, m, l, c, b);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            speed *= 1.; //+ 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n            speed *= 3.0;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\n#define ID_NONE 0\n#define ID_BOX 1\n#define ID_WATER 2\n\n#define WALK 0\n#define Y 16.\n#define OY (Y/4.)\n#define CENTER vec3(100, 0, 100)\n\n#define BOX_ROT_YZ (cos((T*0.3)+sin(((T*0.8)-2.22232125)*0.2)))\n#define BOX_ROT_XZ (sin((T*0.3)+cos(((T*0.8)+3.329918923)*0.4)))\n#define BOX_POS vec3(0, (-3.4) - ((0.5+(0.5*cos((T*2.)+sin(T+0.2998982813+cos(T-3.399291541)))))*0.5), 0)\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat waterSDF(in vec3 p) {\n    if (p.y > 6.) return p.y;\n    vec3 pc = p - CENTER;\n    vec3 bpos = BOX_POS;\n    float db = clamp(1.0/(1.0+distance(pc, bpos-CENTER)), 0.0, 2.0);\n    vec2 dir = normalize(pc.xz - (bpos-CENTER).xz);\n    float dotb = dot(normalize(pc.xz), (bpos-CENTER).xz);\n    float h = 0.0;\n    h -= 3.;\n    float time = T*0.1;\n    float ra = 4.0;\n    float fe = ra*0.5;\n    float c = (1.0-smoothstep(ra-fe, ra+fe, distance(pc, bpos-CENTER)));\n    h += (0.5)*((c*(cos((T*3.)+((c+abs(dotb))*TAU*2.)))*(0.5+(0.5*max(-1., (-bpos.y)-3.4))))/2.);\n    time += c;\n    vec2 shift = vec2(cos(time + db), sin(time+db));\n    vec3 n11 = snoise6(iChannel3, p.xz + (shift*6.), 5.3212377, 0.2);\n    float n1 = n11.x;   \n    shift += vec2(sin(n1*2.), cos(n1*2.))*(2.+db);\n    vec3 n22 = snoise6(iChannel3, p.zx - (shift*3.), 0.88847281, 0.1);\n    float n2 = n22.x;\n    shift += vec2(cos(n2*2.), sin(n2*2.))*(2.+db);\n    vec3 n3 = snoise6(iChannel3, p.xz + (shift*2.), 0.3878272, 0.2);\n    h -= n1;\n    h += n2;\n    h -= n3.x;\n    h -= db*0.5;\n    return p.y-h;\n}\n\n\nfloat sdf(inout Data data, in vec3 p) {\n    int id = 0;\n    int skip = data.skip;\n    int only = data.only;\n    float dist = FAR;\n    \n    float water = skip == ID_WATER ? FAR : waterSDF(p - CENTER);\n    vec3 bp = p - (CENTER + BOX_POS);\n    bp.yz *= rot(BOX_ROT_YZ);\n    bp.xz *= rot(BOX_ROT_XZ);\n    float box = boxSDF(bp, vec3(1.0)) - 0.07;\n     \n    SAMPLE(box, ID_BOX);\n    SAMPLE(water, ID_WATER);\n\n    data.id = id;\n    \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if ((next) <= (NEAR * (1.0+(d)))) break;\n        if ((d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    \n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    data.d = d;\n    \n    return true;\n}\n\nfloat getShadow(in int skip, in vec3 ro, in vec3 rd, in float near, in float far) {\n    float d = 0.0;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if ((next) <= (NEAR*(1.0+d))) break;\n        if ((d) >= far) return 1.0;\n    }\n    \n    d = abs(d);\n    \n    return clamp(d/(1.0+d), AMBIENT, 0.96);\n}\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(176, 142, 115);\n    vec3 c2 = rgb(74, 48, 42);\n    vec3 c3 = rgb(195, 135, 90);\n    vec3 c4 = rgb(86, 51, 29);\n    \n    vec3 alt = noise(iChannel3, uv, 8.83159, 128.);\n    \n    col = mix(col, c1, alt.x);\n    col = mix(col, c2, alt.y);\n    col = mix(col, c3, alt.z);\n    \n    float lines = ((alt.z+alt.x+alt.y)/3.)*cos((uv.x-sin(uv.y*TAU))*TAU+cos((uv.x-uv.y)*TAU));\n    lines = pow(max(0.0, 0.7*(1.0-abs(lines))), 3.0);\n    \n    col = mix(col, c2*c2*c2, lines*alt.y);\n    col = mix(col, c4, clamp(0.1*fract(10.38921*(tan(lines*6.831)+cos(alt.x+alt.y+alt.z))), 0.0, 1.0));\n    col += luma(col);\n    col = col*col*col*col;\n    \n    m.spec = clamp(alt.x*lines, alt.z*0.2, 1.0);\n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 bp = data.p;\n    bp -=  BOX_POS;\n    bp -= CENTER;\n    bp.yz *= rot(BOX_ROT_YZ);\n    bp.xz *= rot(BOX_ROT_XZ);\n\n    vec3 nn = data.n;\n    nn.yz *= rot(BOX_ROT_YZ);\n    nn.xz *= rot(BOX_ROT_XZ);\n    vec2 uv = boxUv(bp, nn)/2.;\n    vec3 col = woodTexture(uv, data.p, data.m);\n    \n    float e = 0.01;\n    vec3 bump = fixNormal(data.n, normalize(luma(col) - vec3(\n        luma(woodTexture(uv + vec2(e, 0), data.p, data.m)),\n        luma(woodTexture(uv + vec2(0, e), data.p, data.m)),\n        0.3\n    )), 0.0, 0.9);\n    data.n = bump;\n    \n    return col;\n}\n\nvec3 getAlbedoWater(inout Data data) {\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.29, 0.69, 0.9);\n    col = mix(col, rgb(62, 86, 79), 0.42);\n    col = col*col*col;\n    \n    \n    vec3 n = snoise6(iChannel3, uv + (vec2(cos(T*0.1), sin(T*0.1))*2.), 0.45928123, 0.5);\n    data.m.rough = clamp(n.x*n.x*n.x*n.x, 0.000001, 0.4);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_WATER: return getAlbedoWater(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in Data data, in Light light, in vec3 ro, in vec3 rd) {\n  vec3 col = vec3(0.0);\n  vec2 uv = rd.xz / rd.y;\n  vec3 blue = vec3(0.3, 0.56, 0.8);\n\n  float dotup = cdot(rd, vec3(0, 1, 0));\n\n  col = pow(blue, vec3(1.0 + (dotup * 2.)));\n\n  if (dotup <= 0.0) return col;\n  \n  float time = T * 0.2;\n\n  vec2 shift = vec2(cos(time), sin(time));\n  uv += sin(shift * 6.) * 0.01;\n\n  vec3 lf1 = noise6(iChannel3, uv + shift, 0.03291895, 0.9);\n  vec3 hf1 = noise6(iChannel3, uv - (shift * 0.2), 1.2321956,\n                    16.0 + mix(0.0, 1., pow(lf1.z, 2.0)));\n  vec3 mixer = noise6(iChannel3, uv + sin(shift), 0.11111223, 0.9);\n\n  time *= mix(1.0, 0.9, smoothstep(0.3, 1., mixer.y * mixer.x));\n\n  time += adot(lf1, hf1);\n\n  float mixf = mix(mixer.x, mixer.y, 0.5 + (0.5 * sin(time)));\n\n  float low = mix(lf1.x, lf1.y, 0.5 + (0.5 * cos(time)));\n  float high = mix(hf1.x, hf1.y, 0.5 + (0.5 * sin(time)));\n\n  vec3 lfi = noise6(iChannel3, uv + shift, 0.53928111, 1.0);\n  float inv = pow(mix(lfi.x, lfi.y, 0.5 + (0.5 * cos(time))), 2.0);\n\n  float clouds = mix(low, high, mixf);\n\n  clouds = mix(clouds, 0.0, inv);\n  clouds = pow(clouds, 3.0);\n  \n  clouds *= clamp(dotup*40., 0.0, 1.0);\n\n  col = mix(col + clouds, mix(col, vec3(1.0), clouds),\n            0.5 + (0.5 * cos(time + low + high + inv)));\n\n  return col;\n}\n\n\nvec3 forEachLight(in int j, inout Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    \n    int skip = data.id;\n    float shadow = getShadow(skip, p+(n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR : \n        distance(light.p, p));\n        \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.69), 2.0, LIGHT_AMBIENT);\n    vec3 mixf = vec3(1.0);\n    float d = FAR;\n    \n    for (int j = ZERO; j < 2; j++) {\n        if (march(data, ro, rd)) {\n            if (j <= 0) { d = data.d;}\n            vec3 albedo = getAlbedo(data);\n            vec3 diffuse = albedo / M_PI;\n            col += (mixf * forEachLight(j, data, lights[0], ro, rd, diffuse)) / (1.0 + float(j));\n            \n\n            float rough = data.m.rough;\n\n            if (rough >= 0.9999) break;\n\n            float metallic = data.m.metallic;\n            vec3 n = data.n;\n            vec3 p = data.p;\n            float NdotV = dot(n, -rd);\n\n            rd = reflect(rd, n);\n            ro = p+(n*NEAR*2.);\n\n            vec3 f0 = mix(vec3(0.04), vec3(0.9), float(data.id == ID_WATER));//mix(vec3(0.5), diffuse, metallic);\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n\n            mixf *= F * max(0.0, 1.0 - rough);\n        } else {\n            col += (mixf * getSky(data, lights[0], ro, rd)) / (1.0 + float(j));\n            break;\n        }\n    }\n    \n    depth = d / FAR;\n    \n    col += (smoothstep(0.1, 1.0, depth) * max(0.0, 1.0 - smoothstep(0.0, 0.3, dotup)))/TAU;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    float depth = FAR;\n    \n    vec3 ro = vec3(0, 0., -1.);\n    \n    #if WALK\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    ro += walk;\n    ro.y += fly.y;\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    #else\n    \n    if (length(m.xy) > 0.01 && m.z > 0.01) {\n        ro.z -= 4.0;\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        \n        ro.y -= 6.0;\n        ro.z += 8.;\n    } else {\n        rd.xy *= rot(cos(T)*0.1);\n        rd.yz *= rot(sin(T)*0.1);\n        ro.y -= 6.0;\n        ro.z += 3.5;\n        ro.x -= 3.;\n        ro.y += ((0.5*sin((((T + (0.5*cos((T*0.8)+8.8372715)))-3.39298112)*2.5))))*0.25;\n    }\n    #endif\n    \n    ro += CENTER;\n    ro.y += OY;\n    ro.z -= 8.; \n    ro.y = max(ro.y, -3.);\n\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n\n    Data data = NEW_DATA;\n    col += render(data, ro, rd, depth);\n    \n    col += (col*col*luma(col));\n    col = uchimura(col);\n    //col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(col, depth);\n}","name":"Buffer A","description":"","type":"buffer"}]}