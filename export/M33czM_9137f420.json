{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"// Simple Volumetric Clouds (Raymarch + fBm Noise)\n// Try adjusting STEPS, MARCH_DIST, and other constants for different looks.\n\n#define STEPS 48             // Number of steps along the ray\n#define MARCH_DIST 50.0      // How far we march into the scene\n#define STEP_SIZE (MARCH_DIST / float(STEPS))\n#define NOISE_SCALE 0.15\n#define OCTAVES 4\n\n// Simple 3D hash-based noise --------------------------------\nfloat hash13(vec3 p) {\n    // Quick 3D hash -> 1D. Not great quality but simple.\n    p = fract(p * 0.3183099 + 0.1);\n    p *= 17.0;\n    return fract(p.x * p.y * p.z * (p.x + p.y + p.z));\n}\n\nfloat noise3D(vec3 p) {\n    // Trilinear interpolation of hash corners\n    vec3 i = floor(p), f = fract(p);\n    float n000 = hash13(i + vec3(0,0,0));\n    float n100 = hash13(i + vec3(1,0,0));\n    float n010 = hash13(i + vec3(0,1,0));\n    float n110 = hash13(i + vec3(1,1,0));\n    float n001 = hash13(i + vec3(0,0,1));\n    float n101 = hash13(i + vec3(1,0,1));\n    float n011 = hash13(i + vec3(0,1,1));\n    float n111 = hash13(i + vec3(1,1,1));\n    vec3 u = f*f*(3.0-2.0*f); // smoothstep\n    return mix(\n      mix(mix(n000,n100,u.x),mix(n010,n110,u.x),u.y),\n      mix(mix(n001,n101,u.x),mix(n011,n111,u.x),u.y),\n      u.z\n    );\n}\n\n// Fractional Brownian Motion -------------------------------\nfloat fbm(vec3 p) {\n    float total = 0.0, amp = 1.0;\n    for(int i=0; i<OCTAVES; i++) {\n        total += noise3D(p) * amp;\n        p *= 2.01;\n        amp *= 0.5;\n    }\n    return total;\n}\n\n// Main raymarch --------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    // Basic camera setup\n    vec3 ro = vec3(0.0, 1.0, -4.0+0.*iTime);    // camera origin\n    vec3 rd = normalize(vec3(uv, .8)); // forward direction\n\n    // Animate clouds over time\n    float time = iTime * 0.05;\n    \n    // Raymarch\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    float transmittance = 1.0; // how much light is left\n\n    for(int i = 0; i < STEPS; i++) {\n        vec3 pos = ro + rd * t;\n        \n        // Sample noise as \"cloud density\"\n        float density = 0.5*fbm(pos * NOISE_SCALE + time);\n        \n        // Threshold / shape a bit\n        density = smoothstep(0.6, 0.65, density);  // tweak these for thicker/thinner clouds\n        \n        // Accumulate color\n        // \"albedo\" of cloud (white-ish) times density\n        vec3 cloudColor = vec3(1.0) * density;\n        \n        // Basic absorption (beerâ€™s law style)\n        float stepAbsorb = exp(-density * 0.3);\n        \n        // Combine\n        col += transmittance * cloudColor * 0.3; // 0.3 is \"light strength\"\n        transmittance *= stepAbsorb;\n\n        t += STEP_SIZE;\n        if(transmittance < 0.01) break; // early out if almost fully opaque\n    }\n    \n    // Simple background: sky gradient\n    vec3 skyCol = mix(vec3(0.3, 0.5, 0.9), vec3(0.8, 0.9, 1.0), uv.y + 0.5);\n    \n    // Final color: blend between clouds & sky\n    vec3 finalCol = col + transmittance * skyCol;\n    fragColor = vec4(finalCol, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"M33czM","date":"1734861878","viewed":70,"name":"jakaba clouds","username":"mrjonjonjon","description":"learning about volumetric raymarching","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""}}