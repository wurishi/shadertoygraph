{"ver":"0.1","info":{"id":"4slfDs","date":"1498860490","viewed":121,"name":"Cereals jumping on milk","username":"onclipse","description":"Simular unos cereales saltando sobre leche. Trabajo de shaders para la práctica 3 de PGATR.\nSe ha implementado mediante ray-marching. Más información en el pdf.\nClaudia Ochagavías\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","torus","fog","plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCEREALS JUMPING ON MILK\n*/\n/*Trabajo para la práctica 3 de PGATR - Claudia Ochagavías\n//Creado utilizando ray marching\n*/\n\n//Constantes que serán utilizadas durante el shader\n#define DISTANCIA_BIAS 0.7\n#define EPSILON 0.015\n#define NUMERO_PASOS 50\n#define PLANO_CERCA 0.5\n#define PLANO_LEJOS 60.0\n\n//Creación de plano ondulado. Se mueve con el tiempo\nfloat planoOndulado(const in vec3 vPos) {\n\tfloat f1 = 0.2 + sin(vPos.x + iTime) * 0.15 - 1.0;\n\tfloat f2 = vPos.y;\n\t//return (f2 < f1) ? f1 - f2 : f2 - f1;\n    return f2 - f1;\n        \n}\n//Función creación de un plano\nfloat sdPlane( vec3 p, vec4 n )\n{\n  //https://iquilezles.org/articles/distfunctions\n  // n está normalizado\n  return dot(p,n.xyz) + n.w;\n}\n\n//Función para crear esfera. p: posición global del rayo. s: radio de esfera\nfloat crearEsfera (vec3 p, float s){\n    //https://iquilezles.org/articles/distfunctions\n    //return length(p)-s;\n    float dis = length(p)-s;\n\n   // return dis + sin(iTime)*0.08;\n     return dis + sin(iTime)*0.08;\n}\n\n//Función crear torus\nfloat crearTorus( vec3 p, vec2 t ){\n    //https://iquilezles.org/articles/distfunctions\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat fmod(float a, float b){\n    if(a < 0.0){\n        return b - mod(abs(a), b);\n    }\n    return mod(a,b);\n}\n\n//Escena: Se genera una distancia a la posición dada\nvec2 escena(vec3 position)\n{\n    //Trasladamos el plano\n    vec3 trasladar = vec3(0.0, 1.1, 1.0);\n    //float distancia = crearEsfera(position - trasladar, 0.5);\n    //Creamos el plano a partir de las distancias\n    //float distancia = sdPlane(position - trasladar, vec4(0.0,1.0,0.0,1.0));\n    float distancia = planoOndulado(position - trasladar);\n    \n    //Asignamos el identificador del material\n    float materialId = 1.0;\n    trasladar = vec3(0.0, +0.65, 1.0);\n\n    //Vamos a crear los cereales, haciendo un tiling de torus. Para ello, modificaremos la posición\n    //del plano, y tilearemos en X.\n    vec3 posicion_plano = position - trasladar;\n    \n    //Hacemos un offset en 0.5, tileamos, y volvemos a -0.5 para ponerlo en la posición original\n    posicion_plano.x = fract(posicion_plano.x + 0.5) - 0.5;\n    posicion_plano.z = fmod(posicion_plano.z + 1.0, 2.0) - 1.0;\n    \n    //Vamos a animar el movimiento de los cereales a partir de seno y el coseno,\n    //modificando la altura\n    posicion_plano.y += sin(position.x + iTime*2.5) * 0.85;\n    posicion_plano.y += cos(position.z + iTime*3.5) * 0.9;\n    float distancia2 = crearTorus(posicion_plano, vec2(0.15,0.065));\n    //Identificador del material de los cereales\n    float materialId2 = 2.0;\n    \n    //Combinamos las distancias de los dos objetos\n    if(distancia2 < distancia){\n        distancia = distancia2;\n        materialId = materialId2;\n    }\n    \n    //Devolvemos un vec2 con la distancia y el material final\n    return vec2 (distancia, materialId);  \n}\n\n\n//Función raymarching\nvec2 raymarching(vec3 position, vec3 direction){\n\n    //Cómo de lejos nos hemos movido\n    float total_distancia = PLANO_CERCA;\n    for(int i=0; i < NUMERO_PASOS ; i++){\n    \tvec2 result = escena(position + direction * total_distancia);\n        \n        //Si estamos muy cerca a la superficie (epsilon) asumimos que la golpeamos\n        if(result.x < EPSILON){\n        \treturn vec2(total_distancia, result.y);\n        }\n    \n        //Utilizamos distancia_bias para corregir imprecisiones\n        total_distancia += result.x * DISTANCIA_BIAS;\n        \n        //Paramos si nos vamos demasiado lejos\n        if(total_distancia > PLANO_LEJOS){\n            break;\n        }\n    \n    }\n\n    //Si no nos hemos acercado a ninguna superficie, devolvemos distancia de plano_lejos\n    //y ningún material\n    return vec2(PLANO_LEJOS, 0.0);\n}\n\n//Cálculo vector normal\nvec3 normal(vec3 rayo_posicion, float smoothness){\n\n    vec3 n;\n    vec2 dn =  vec2(smoothness, 0.0);\n    n.x\t= escena(rayo_posicion + dn.xyy).x - escena(rayo_posicion - dn.xyy).x;\n\tn.y\t= escena(rayo_posicion + dn.yxy).x - escena(rayo_posicion - dn.yxy).x;\n\tn.z\t= escena(rayo_posicion + dn.yyx).x - escena(rayo_posicion - dn.yyx).x;\n\treturn normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Coordenadas en espacio UV 0-1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n//\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n    //Movemos la coordenada 0,0 al centro. Por lo tanto tenemos de -1,-1 a 1,1\n    uv = uv * 2.0 - 1.0;\n    \n    //El aspect ratio de la ventana. Adaptamos la coordenada x\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Creamos la posición de la cámara y la dirección\n    vec3 camara_pos = vec3(0.0, 1.4, -5.0);\n    vec3 direction = normalize(vec3(uv, 2.5));\n\n    //Llamamos a la función de raymarching\n    vec2 result = raymarching (camara_pos, direction);\n                               \n    //Colores de los cereales y el plano\n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if(result.y == 1.0)\n    {\n        vec3 color;\n        color = vec3(1.2,1.65,2.0);\n        materialColor = color;\n    }\n    if(result.y == 2.0)\n    {\n        //Los cereales van cambiando de color con el tiempo\n       \tmaterialColor = vec3(uv,0.7+0.8*sin(iTime) + 0.4);\n    }                           \n    \n    //Punto de intersección y normal\n    vec3 interseccion = camara_pos + direction * result.x;\n    vec3 normalf = normal(interseccion, 0.01);\n      \n    //Luz direccional y difusa\n    vec3 luz_dir = normalize(vec3(1.0, 1.0, 0.0));\n   \tfloat difusa = dot(luz_dir, normalf);                           \n    //Luz alrededor\n    difusa = difusa * 0.7 + 0.5;                           \n    //Combinamos luz ambiental e iluminación difusa por luz direccional\n    vec3 color_ambiental = vec3(0.2, 0.45, 0.7);\n    vec3 color_luz = vec3(1.3, 1.1, 0.6);\n    vec3 difusaL = materialColor * (difusa * color_luz + color_ambiental);                          \n    \n        \n    //Añadimos niebla para que el fondo se vaya viendo cada vez menos\n    float niebla = pow(1.0 / (1.0 + result.x), 0.45);\n    \n    //Color final\n    fragColor = vec4(difusaL, 1.0) * niebla;                           \n     \n}","name":"Image","description":"","type":"image"}]}