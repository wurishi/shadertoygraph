{"ver":"0.1","info":{"id":"3tsyWj","date":"1600793354","viewed":97,"name":"Alfonso - Mandelbulb","username":"AlfonsoLR","description":"Mandelbulb tryout.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON .0001\n#define BOUNCE_COLOR vec3(.3f, .3f, .2f)\n#define BOUNCE_DIRECTION vec3(.0f, -1.0f, .0f)\n#define PLANE_ALBEDO vec3(2.0f, 2.0f, 2.0f)\n#define SPHERE_ALBEDO vec3(.4f)\n#define SKY_COLOR vec3(.0, .1f, .3f)\n#define SKY_DIRECTION vec3(.0f, 1.0f, .0f)\n#define SUN_COLOR vec3(.8f, .8f, .5f)\n#define SUN_DIRECTION normalize(vec3(.8, .4, .2))\n\n#define SPHERE 0.0\n#define PLANE 1.0\n\n\nfloat mapMandelbulb(vec3 pos) { \n    vec3 w = pos;\n    float m = dot(w,w), dz = 1.0f;\n    \n    for (int it = 0; it < 20; ++it) {\n        float m2 = m*m;\n        float m4 = m2*m2;\n        dz = 8.0 * sqrt(m4 * m2 * m) * dz + 1.0;\n        \n       \tfloat x = w.x; float x2 = x * x; float x4 = x2 * x2;\n        float y = w.y; float y2 = y * y; float y4 = y2 * y2;\n        float z = w.z; float z2 = z * z; float z4 = z2 * z2;\n\n        float k3 = x2 + z2;\n        float k2 = inversesqrt(k3 * k3 * k3 * k3 * k3 * k3 * k3);\n        float k1 = x4 + y4 + z4 - 6.0 * y2 * z2 - 6.0 * x2 * y2 + 2.0 * z2 * x2;\n        float k4 = x2 - y2 + z2;\n\n        w.x = pos.x + 64.0 * x * y * z * (x2 - z2) * k4 * (x4 - 6.0 * x2 * z2 + z4) * k1 * k2;\n        w.y = pos.y + -16.0 * y2 * k3 * k4 * k4 + k1 * k1;\n        w.z = pos.z + -8.0 * y * k4 * (x4 * x4 - 28.0 * x4 * x2 * z2 + 70.0 * x4 * z4 - 28.0 * x2 * z2 * z4 + z4 * z4)\n                * k1 * k2;\n        \n        m = dot(w,w);\n\t\tif(m > 256.0)\n            break;\n    }\n    \n    return 0.25 * log(m) * sqrt(m) / dz;\n}\n\nfloat mapSDFBox(vec3 pos, vec3 extent, float radius) {\n    vec3 q = abs(pos) - extent;\n  \treturn length(max(q, 0.0f)) + min(max(q.x, max(q.y,q.z)), 0.0f) - radius;\n}\n\nfloat mapSDFOctahedron(vec3 pos, float s) {\n \tvec3 p = abs(pos);\n  \tfloat m = p.x + p.y + p.z - s;\n  \tvec3 q;\n    \n    if(3.0f * p.x < m) q = p.xyz;\n  \telse if(3.0f * p.y < m) q = p.yzx;\n  \telse if(3.0f * p.z < m) q = p.zxy;\n  \telse return m * 0.5773f;\n    \n  \tfloat k = clamp(0.5f * (q.z - q.y + s), 0.0f, s); \n  \treturn length(vec3(q.x, q.y - s + k, q.z - k));  \n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5f + 0.5f * (d2 - d1) / k, 0.0f, 1.0f);\n    return mix(d2, d1, h) - k * h * (1.0f - h); \n}\n\n\nvec2 map(vec3 pos) {\n\tfloat mandelbulbDistance = mapMandelbulb(pos);\n    float boxDistance = mapSDFBox(pos, vec3(0.5, 0.5, 0.5), 0.2f);\n    float octahedronDistance = mapSDFOctahedron(pos, 1.4f);\n    float primaryModelDistance = opSmoothUnion(boxDistance, mandelbulbDistance, 0.1f);\n    \n    float floorDistance = pos.y + 2.0f;\n    \n    //return vec2(mandelbulbDistance, SPHERE);\n    //return vec2(primaryModelDistance, SPHERE);\n    \n   \treturn (mandelbulbDistance < floorDistance) ? vec2(mandelbulbDistance, SPHERE) : vec2(floorDistance, PLANE);    \n}\n\nvec3 calculateSphereNormal(vec3 pos) {\n    vec2 e = vec2(EPSILON, .0);\n    return normalize(vec3(map(pos + e.xyy).x - map(pos - e.xyy).x,\n                          map(pos + e.yxy).x - map(pos - e.yxy).x,\n                          map(pos + e.yyx).x - map(pos - e.yyx).x));\n}\n\nvec2 castRay(vec3 ro, vec3 rd) {\n    float material = -1.0f;\n    float t = .0f;\n    \n    for (int i = 0; i < 1000; ++i) {\n        vec3 pos = ro + t * rd;\n        \n   \t\tvec2 h = map(pos);\n        material = h.y;\n        if (h.x < EPSILON) break;\n        \n        t += h.x;\n        if (t > 256.0) break;\n    }\n    \n    if (t > 256.0f) t = -1.0f;\n    \n    return vec2(t, material);\n}\n\nvec3 correctColor(vec3 color) {\n \treturn pow(color, vec3(0.4545));   \n}\n\nfloat softShadow(vec3 pos, vec3 lightDir, float k) {\n    float res = 1.0;\n    float t = 0.0;\n    \n    for( int i = 0; i < 100; i++ )\n    {\n        float h = map(pos + lightDir * t).x;\n        res = min(res, k * h/t );\n        if( res < 0.001 ) break;\n        t += clamp(h, 0.01f, 0.2f);\n    }\n    \n    return clamp(res, 0.0f, 1.0f);   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // From -1 to 1\n    vec2 p = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\t\n    \n    // Mouse picks the camera position\n    float xzAngle = 5.0 * iMouse.x / iResolution.x, yAngle = .0f;//5.0 * iMouse.y / iResolution.y;\n    \n    // Ray coordinates\n    vec3 ro = vec3(2.5f * sin(xzAngle), sin(yAngle), 2.5f * cos(xzAngle));\n    vec3 target = vec3(.0);\n    vec3 zDir = normalize(target - ro);\n    vec3 xDir = normalize(cross(zDir, vec3(.0f, 1.0f, .0f)));\n    vec3 yDir = normalize(cross(xDir, zDir));\n    vec3 rd = normalize(p.x * xDir + p.y * yDir + 1.5 * zDir);\n    \n    // Color\n    vec3 col = vec3(.6f, .7f, 1.0f) - .5f * rd.y;\n    vec3 albedo = vec3(.0f);\n    \n    // Cast rays\n    vec2 t = castRay(ro, rd);\n    \n    if (t.x > .0f) {\n        vec3 pos = ro + rd * t.x;\n        vec3 normal = calculateSphereNormal(pos);\n        \n        float diffuse = clamp(dot(normal, SUN_DIRECTION), .0f, 1.0f);\n        float skyDiffuse = clamp(.5f + .5f * dot(normal, SKY_DIRECTION), .0f, 1.0f);\n        float sunShadow = softShadow(pos + normal * EPSILON, SUN_DIRECTION, 26.0);\n        float bounceDiffuse = clamp(.5f + .5f * dot(normal, BOUNCE_DIRECTION), .0f, 0.6f);\n        \n        if (t.y < .5f) {\n            vec3 nx = mix(vec3(1.0f, 0.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), (normal.x + 1.0f) / 2.0f);\n       \t\tvec3 ny = mix(vec3(0.0f, 1.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), (normal.y + 1.0f) / 2.0f);\n        \tvec3 nz = mix(vec3(0.0f, 0.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), (normal.y + 1.0f) / 2.0f);\n        \talbedo = 3.0f * mix(mix(nx, ny, 1.0f / 3.0f), nz, 1.0f / 3.0f);   \n        } else if (t.y < 1.5f) {\n         \talbedo = PLANE_ALBEDO; \n        }\n        \n        col \t= albedo * SUN_COLOR * diffuse * sunShadow;\n        col \t+= albedo * SKY_COLOR * skyDiffuse;\n        col \t+= albedo * BOUNCE_COLOR * bounceDiffuse;\n    }\n\n    // Output to screen\n    fragColor = vec4(correctColor(col),1.0);\n}","name":"Image","description":"","type":"image"}]}