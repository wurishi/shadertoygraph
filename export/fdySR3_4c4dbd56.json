{"ver":"0.1","info":{"id":"fdySR3","date":"1634970927","viewed":76,"name":"CALayer: Border","username":"barton","description":"Possible implementation for rendering CALayer border like Core Animation framework.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["rounded","border","layer","calayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// CALayer: Border\n//\n// This shader shows possible implementation for rendering CALayer in temrs of border.\n//\n// There is such framework like Core Animation for iOS/macOS.\n// In iOS CALayer will be ceated like:\n//\n// let targetLayer = CALayer()\n// targetLayer.frame = CGRect(x: 0, y: 0, width: 700, height: 700)\n// targetLayer.cornerRadius = 500\n// targetLayer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner]\n// targetLayer.borderWidth = 30\n// targetLayer.borderColor = UIColor.yellow.cgColor\n// targetLayer.opacity = 1.0\n// view.layer.addSublayer(targetLayer)\n//\n// By some reason the radius could be greater than some critical value and layer's shape\n// will start changing. But as I used SDF algorithm for rounded corners they will get form\n// changes but what about unmasked corners? Unmasked corners should be changed as well.\n// This shader handles such case.\n//\n\n#define kTopLeftCorner      0x1\n#define kTopRightCorner     0x2\n#define kBottomLeftCorner   0x4\n#define kBottomRightCorner  0x8\n\nstruct LayerUniform {\n    vec2 size;\n    float cornerRadius;\n    int maskedCorners;\n    float borderWidth;\n    vec4 borderColor;\n    float opacity;\n};\n\n// Calculate SDF for rect by size.\nfloat sdfRect(vec2 point, vec2 size) {\n    vec2 q = abs(point) - size/2.0;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0));\n}\n\n// Calculate SDF for rect by size with corner radius.\nfloat sdfRect(vec2 point, vec2 size, float cornerRadius) {\n    vec2 q = abs(point) - size/2.0 + cornerRadius;\n    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - cornerRadius;\n}\n\n// Calculate SDF for rect with corner radius and masked corners;\nfloat sdfRect(vec2 point, vec2 size, float cornerRadius, int maskedCorners) {\n    if (maskedCorners == 0) {\n        return sdfRect(point, size);  \n    } else if ((point.x < 0.0 && point.y > 0.0) && (maskedCorners & kTopLeftCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x > 0.0 && point.y > 0.0 && (maskedCorners & kTopRightCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x < 0.0 && point.y < 0.0 && (maskedCorners & kBottomLeftCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    } else if (point.x > 0.0 && point.y < 0.0 && (maskedCorners & kBottomRightCorner) > 0) {\n        return sdfRect(vec2(point.x, point.y), size, cornerRadius);\n    }\n    \n    float d1 = sdfRect(vec2(point.x, 0), size, cornerRadius);\n    float d2 = sdfRect(vec2(0, point.y), size, cornerRadius);\n    \n    return max(d1, d2);\n}\n\nfloat makeBorderdMask(vec2 uv, LayerUniform layerUniform) {\n    vec2 fragCoord = uv * iResolution.xy;\n    vec2 size = layerUniform.size;\n    float cornerRadius = layerUniform.cornerRadius;\n    int maskedCorners = layerUniform.maskedCorners;\n    float borderWidth = layerUniform.borderWidth;\n\n    float d = sdfRect(fragCoord, size, cornerRadius, maskedCorners);\n    float mask1 = smoothstep(d - 0.8, d + 0.8, 0.16);\n    float mask2 = smoothstep(abs(d) - 0.8, abs(d) + 0.8, borderWidth - 0.16);\n    \n    return mask1 * mask2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float initialRadius = 500.0;\n    float upadtedRadius = abs(initialRadius * sin(iTime * 0.5));\n\n    // Input uniform for fragment shader.\n    LayerUniform layerUniform;\n    layerUniform.size = vec2(700, 700);\n    layerUniform.cornerRadius = upadtedRadius;\n    layerUniform.maskedCorners = kTopLeftCorner | kBottomRightCorner;\n    //layerUniform.maskedCorners = kTopLeftCorner | kTopRightCorner | kBottomLeftCorner | kBottomRightCorner;\n    layerUniform.borderWidth = 30.0;\n    layerUniform.borderColor = vec4(1, 1, 0, 1);\n    layerUniform.opacity = 1.0;\n    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    float borderMask = makeBorderdMask(uv, layerUniform);\n    vec4 color = mix(vec4(0), layerUniform.borderColor, borderMask * layerUniform.opacity);\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}