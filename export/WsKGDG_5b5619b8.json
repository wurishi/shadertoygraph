{"ver":"0.1","info":{"id":"WsKGDG","date":"1570882410","viewed":87,"name":"UFO!!","username":"silicagel","description":"I tried to make UFO","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 lightDir = normalize(vec3(0.,1.,1.));\nconst float PI = 3.14159265;\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat random(vec2 p){\n    return fract(sin(dot(p,vec2(18.4562,876.25)))* 3632.357 + iTime * 0.1);\n}\n\nfloat noise(vec2 p){\n    vec2 pi = floor(p);\n    vec2 pf = fract(p);\n    \n    vec2 t = vec2(1,0);\n    \n    float x0y0 = random(pi);\n    float x0y1 = random(pi + t.yx);\n\tfloat x1y0 = random(pi + t.xy);\n    float x1y1 = random(pi + t.xx);\n    \n    vec2 u = pf * pf * (3. - 2. * pf);\n    \n    return mix(mix(x0y0,x1y0,u.x),mix(x0y1,x1y1,u.x),u.y);\n}\n\nfloat fbm(vec2 p){\n    float a = 1.;\n    float o = 1.;\n    float r = 0.;\n    for(int i = 0;i < 8;i++){\n        r += a * noise(p);\n        p *= rot(o);\n        a *= 0.5;\n        o *= 2.;\n    }\n    return r;\n}\n\nfloat sphere(vec3 p){\n    p.y -= 0.3;\n    return length(p) -1.5;\n}\n\nfloat torus(vec3 p){\n    return length(vec2(length(p.xz) - 2.,p.y)) - 0.3;\n}\n\nfloat smoothMin(float d1,float d2,float k){\n    float h = exp(-d1 * k) + exp(-d2 * k);\n    return -log(h) / k;\n}\n\nfloat dist(vec3 p){\n    \n    float a = 1.;\n    float o = 1.;\n    for(int i = 0;i < 4;i++){\n        p.x += a * sin(iTime * o + PI/4.);\n        p.z += a * cos(iTime * o);\n        p.y += a * sin(iTime * o);\n        o *= 2.;\n        a *= 0.5;\n    }   \n    return smoothMin(sphere(p),torus(p),3.);\n}\n\nvec3 getNormal(vec3 p){\n    vec2 d = vec2(0.001,0);\n    return normalize(vec3(dist(p + d.xyy) - dist(p - d.xyy),\n                          dist(p + d.yxy) - dist(p - d.yxy),\n                          dist(p + d.yyx) - dist(p - d.yyx)\n                          ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = (2. * fragCoord - iResolution.xy)/min(iResolution.x,iResolution.y);\n\t\n    vec3 cPos = vec3(0,0,5);\n    vec3 cDir = vec3(0,0,-1);\n    vec3 cUp = vec3(0,1,0);\n    vec3 cSide = cross(cDir,cUp);\n    \n    vec3 ray = cSide * p.x + cUp * p.y + cDir * 1.;\n    \n    vec3 rPos = cPos;\n    float rLen = 0.;\n    float dis = 0.;\n    \n    for(int i = 0;i < 64; i++){\n        dis = dist(rPos);\n        rLen += dis;\n        rPos = cPos + ray * rLen;\n        if(abs(dis) < 0.01)break;\n    }\n    \n    vec2 t = p * 2.;\n    float bc = fbm(t * fbm(t * 5. + fbm(t * 5.)));\n    vec3 col = vec3(0.098,bc * 0.117,bc *0.705);\n\n    \n    float uc = clamp(dot(lightDir,getNormal(rPos)),0.01,1.0);\n    col += vec3(0.098,uc * 0.117,uc * 0.705);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}