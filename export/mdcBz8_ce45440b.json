{"ver":"0.1","info":{"id":"mdcBz8","date":"1697541528","viewed":185,"name":"Triplanar with Normals","username":"gehtsiegarnixan","description":"Generic tripalanr Mapping with Normals using tangent space matrixes. ","likes":9,"published":3,"flags":0,"usePreview":0,"tags":["3d","texture","triplanar","uv","normal","mapping","tbn"],"hasliked":0,"parentid":"mlScD3","parentname":"BiCubemap MSIM"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"/*\nThis is a small demonstration of how to implement triplanar mapping with accurate \nnormals. I noticed that other implementations lacked clear explanations for their \nnormal to world space mathematics or comments. Therefore, I derived it from scratch \nby constructing the tangent space matrices for the three projections. This mapping \nalso ensures that all textures are oriented correctly.\n\nSeveral global constants are defined below to enable debug views of the\nmapping, as well as mouse controls for navigation.\n\nSee here for a detailed view of the TBN matrix for triplanar:\nhttps://www.shadertoy.com/view/md3BzS\n\nSee here how to make this ~3x faster while looking the same: \nhttps://www.shadertoy.com/view/Ds3BzS\n*/\n\n// A value of 1 means no contrast, higher values increase contrast\n#define CONTRAST 16.0\n\n// This visualizes the blend region between the two cubemappings\n// Green, Red and Blue represent the upper and lower bounds of the weights\n//#define SHOWGRID\n#define LINETHICKNESS 0.01\n\n// Structure to hold material properties\nstruct materialValues {\n    vec3 color;\n    vec3 normal;\n};\n\n// Triplanar mapping\nmaterialValues triplanar(sampler2D tex, vec3 normal, float scale, float contrast) {   \n    // Calculate sign for flipping sides\n    vec3 sgn = sign(normal);\n    \n    // Scale coordinates\n    vec3 uvwC = normal * scale;\n    \n    // Coordinate projections all right side up with slightly different offsets\n    vec2 uvX = vec2(uvwC.y * sgn.x, uvwC.z) + 0.25; \n    vec2 uvY = vec2(-uvwC.x * sgn.y, uvwC.z) + 0.5; \n    vec2 uvZ = vec2(uvwC.x * sgn.z, uvwC.y) + 0.75; \n\n    // Sample textures for cardinal directions\n\tvec3 colorX = texture(tex, uvX).xyz;\n\tvec3 colorY = texture(tex, uvY).xyz;\n\tvec3 colorZ = texture(tex, uvZ).xyz;\n    \n    // Sample normal, if possible use a normal texture instead in tangent space\n    vec3 tsNormalX = heightToNormal(tex, uvX, iChannelResolution[0].xy, 5.0);\n    vec3 tsNormalY = heightToNormal(tex, uvY, iChannelResolution[0].xy, 5.0);\n    vec3 tsNormalZ = heightToNormal(tex, uvZ, iChannelResolution[0].xy, 5.0);\n    \n    // Tangent is the direction of uvX.x in world space\n    vec3 tangentX = normalize(cross(normal, vec3(0,0,-1)));\n    \n    // Bitangent is the direction of uvY.y in world space. Is not perpendicular to tangent!\n    vec3 bitangentX = normalize(cross(normal, vec3(0,sgn.x,0)));\n    \n    // Tangent Bitangent Normal (tbn) matrix to translate normal textures to world space normals\n    mat3 tbnX = mat3(tangentX, \n                     bitangentX, \n                     normal); // Normal vector straight up from the surface\n                     \n    // TBN matric for the Y sides\n    vec3 tangentY = normalize(cross(normal, vec3(0,0,-1)));\n    vec3 bitangentY = normalize(cross(normal, vec3(-sgn.y,0,0)));\n    mat3 tbnY = mat3(tangentY,\n                     bitangentY,\n                     normal);\n                     \n    // TBN matric for the Z sides\n    vec3 tangentZ = normalize(cross(normal, vec3(0,-1,0)));\n    vec3 bitangentZ = normalize(cross(normal, vec3(sgn.z,0,0)));\n    mat3 tbnZ = mat3(tangentZ,\n                     bitangentZ,\n                     normal);\n    \n    // Translate normals to world space\n    vec3 wsNormalX = tbnX * tsNormalX;\n    vec3 wsNormalY = tbnY * tsNormalY;\n    vec3 wsNormalZ = tbnZ * tsNormalZ;\n        \n    // Weights/Alpha for interpolation\n    vec3 weights = abs(normal);\n    \n    // Increase contrast of weights for sharper transitions\n    weights = smoothContrast(weights, contrast);\n    \n    // Color interpolation\n    vec3 color = colorX * weights.x + \n                 colorY * weights.y + \n                 colorZ * weights.z;\n    \n    // Interpolate normals. Slerp may be better but the difference is not noticeable.\n    vec3 normalWS = normalize(wsNormalX * weights.x + \n                              wsNormalY * weights.y + \n                              wsNormalZ * weights.z);\n        \n    // NB: trick published in https://hal.inria.fr/inria-00536064v2\n    // Deeper conservation: see histogram-preserving here: https://hal.inria.fr/hal-01824773\n    // Modified version of FabriceNeyret2 https://www.shadertoy.com/view/4dcSDr \n    float squaredAlphaSum = weights.x * weights.x +\n                            weights.y * weights.y +\n                            weights.z * weights.z ; // = dot(weights, weights)         \n            \n    // Sampling mips lowest level to get the mean. Can be a constant if known.\n    vec3 mean = vec3(0.576,0.455,0.404); // textureLod(tex, uvX, 12.).xyz; \n\n    // Variance restoration with normalization (very visible in the Stars)\n    color = mean + (color - mean) / sqrt(squaredAlphaSum);\n    \n    #ifdef SHOWGRID\n        // Overlaying the edges of the alpha mask\n        vec3 mask = step(abs(weights - 0.1), vec3(LINETHICKNESS));\n        color = max(mask, color);\n    #endif\n    return materialValues(color, normalWS);\n}\n\n// _____________________________3D Section_____________________________\n// https://www.shadertoy.com/view/4sjXW1 by nimitz (twitter: @stormoid)\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat iSphere(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return -1.;\n    return -b - sqrt(h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n    p*= 1.5;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,2.4);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mat2 mx;\n    mat2 my;\n    if(iMouse.x > 0.0)\t{    \n        mx = mm2(um.x*5.);\n        my = mm2(um.y*5.);\n    } else {\n        mx = mm2(-iTime*.1+um.x*5.);\n        my = mm2(iTime*0.05+um.y*5.);\n    }\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float t = iSphere(ro,rd);\n\n    vec3 lightDir = normalize(vec3(1,0,1));\n\n    // Alternate between background and sphere mapping\n    vec3 color;\n    if (t > 0.) {\n        // Sphere mapping\n    \tvec3 normal = ro + rd * t;\n        \n        // Sample albedo textures\n        materialValues planar = triplanar(iChannel0, normal, 0.7, CONTRAST);\n        \n        #ifdef SHOWGRID\n            // Show unlit color\n            color = planar.color;\n        #else\n            // Apply lighting to show the normals too\n            color = phongLighting(planar.color, planar.normal, ro, lightDir);\n        #endif       \n    } else {\n        // Background mapping\n        vec3 normal = rd;       \n        \n        // Sample albedo textures\n        materialValues planar = triplanar(iChannel1, normal, 2., CONTRAST);\n        \n        #ifdef SHOWGRID\n            // Show unlit color\n            color = planar.color;\n        #else        \n            // Make stars less bright\n            float stars = pow(planar.color.x * planar.color.y * planar.color.z,2.);\n            vec3 albedo = planar.color * stars; // Make stars colorful\n            \n            // Create sun with halo\n            vec3 sun = sun(normal, lightDir);\n\n            // Combine stars albedo and sunlight\n            color = max(albedo - sun, 0.) + sun;\n        #endif \n    }\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//_________________________GENERIC FUNCTIONS_____________________________________\n#define SUN_COLOR vec3(1.0, 0.9, 0.7)\n\n// Phong lighting model\nvec3 phongLighting(vec3 albedo, vec3 normal, vec3 cameraDir, vec3 lightDir) {\n    // Ambient\n    float ambientStrength = 0.15;\n    vec3 ambient = ambientStrength * albedo;\n\n    // Diffuse \n    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);\n    vec3 diffuse = diff * albedo;\n\n    // Specular\n    float specularStrength = 1.0;\n    vec3 viewDir = normalize(cameraDir);\n    vec3 reflectDir = reflect(-lightDir, normal);  \n    float spec = pow(clamp(dot(viewDir, reflectDir), 0.0, 1.0), 36.0);\n    vec3 specular = specularStrength * spec * SUN_COLOR;  \n\n    // Combine results\n    return ambient + diffuse + specular;\n}\n\n// This function creates a simple sun with a halo effect.\nvec3 sun(vec3 normal, vec3 lightDir){\n    // Compute the dot product of the normal and light direction.\n    float NdotL = dot(normal, lightDir);\n    \n    // Compute the angle between the normal and light direction.\n    float angle = acos(NdotL) / 3.14159;\n\n    // Compute an intensity based on the angle.\n    float intensity = pow(1.0 - angle, 25.0) * 2.0;\n\n    // Generate a color based on the intensity and the sun's color.\n    return intensity * SUN_COLOR;\n}\n\n// Increases the steepness of Alpha while forcing 0-1 range and 1 sum\n// See 2 value example https://www.desmos.com/calculator/n6gpory8yq\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// Function for generating normals using 3 texture samples.\n// Original source: https://www.shadertoy.com/view/3sSSW1\nvec3 heightToNormal(sampler2D tex, vec2 uv, vec2 res, float strength) {\n    vec2 s = 1.0 / res;\n    \n    float textureOffset = 1.0;\n    \n    float p = texture(tex, uv).x;\n    float h1 = texture(tex, uv + s * vec2(textureOffset,0)).x;\n    float v1 = texture(tex, uv + s * vec2(0,textureOffset)).x;\n       \n   \tvec2 xy = (p - vec2(h1, v1));\n    \n    return normalize(vec3(xy * strength, 1.0));\n}","name":"Common","description":"","type":"common"}]}