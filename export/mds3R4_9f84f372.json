{"ver":"0.1","info":{"id":"mds3R4","date":"1665793525","viewed":3062,"name":"Fractal Texturing","username":"Xor","description":"Here's a technique for preserving texture detail at any scale. On the left is regular mipmapping, and on the right is my method.","likes":120,"published":1,"flags":0,"usePreview":1,"tags":["texture","demo","filtering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Fractal Texturing\" by @XorDev\n    \n    While creating a 3D game (https://twitter.com/XorDev/status/1578947873550389248),\n    I came across a problem with my texture quality. I needed something that looked good up close\n    or far away. That's when I developed what I call \"fractal texturing\". I'm sure it's been done\n    before, but it's new to me and I thought it was quite neat so I'm sharing it here.\n\n    The concept is quite simple:\n    Instead of sampling a texture at one scale for all pixels, we'll sample at a different scale\n    depending on the pixel's depth. Then by blending smoothly between the scales, we can produce\n    a consistent level of detail. This isn't perfect for all textures (e.g. struggles with bricks)\n    but it's perfect for many natural textures like dirt or grass and works well for my needs.\n    Maybe you'll find a use for it also!\n    \n    Tutorial: https://mini.gmshaders.com/p/gm-shaders-mini-fractal-texturing-1408552\n*/\n\n//Samples at three scales, interpolating between them\nvec4 fractal_texture(sampler2D tex, vec2 uv, float depth)\n{\n    //Find the pixel level of detail\n\tfloat LOD = log(depth);\n    //Round LOD down\n\tfloat LOD_floor = floor(LOD);\n    //Compute the fract part for interpolating\n\tfloat LOD_fract = LOD - LOD_floor;\n\t\n    //Compute scaled uvs\n\tvec2 uv1 = uv / exp(LOD_floor - 1.0);\n\tvec2 uv2 = uv / exp(LOD_floor + 0.0);\n\tvec2 uv3 = uv / exp(LOD_floor + 1.0);\n\t\n    //Sample at 3 scales\n\tvec4 tex0 = texture(tex, uv1);\n\tvec4 tex1 = texture(tex, uv2);\n\tvec4 tex2 = texture(tex, uv3);\n    \n    //Blend samples together\n\treturn (tex1 + mix(tex0, tex2, LOD_fract)) * 0.5;\n}\n//Samples at three scales, interpolating between them (with mipmapping)\nvec4 fractal_texture_mip(sampler2D tex, vec2 uv, float depth)\n{\n\t//Find the pixel level of detail\n\tfloat LOD = log(depth);\n    //Round LOD down\n\tfloat LOD_floor = floor(LOD);\n    //Compute the fract part for interpolating\n\tfloat LOD_fract = LOD - LOD_floor;\n\t\n\t//Compute scaled uvs\n\tvec2 uv1 = uv / exp(LOD_floor - 1.0);\n\tvec2 uv2 = uv / exp(LOD_floor + 0.0);\n\tvec2 uv3 = uv / exp(LOD_floor + 1.0);\n    \n    //Compute continous derivitives\n    vec2 dx = dFdx(uv) / depth * exp(1.0);\n    vec2 dy = dFdy(uv) / depth * exp(1.0);\n\t\n    //Sample at 3 scales\n\tvec4 tex0 = textureGrad(tex, uv1, dx, dy);\n\tvec4 tex1 = textureGrad(tex, uv2, dx, dy);\n\tvec4 tex2 = textureGrad(tex, uv3, dx, dy);\n    \n    //Blend samples together\n\treturn (tex1 + mix(tex0, tex2, LOD_fract)) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Center coordinates\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\n    //Compute perspective\n    float perspective = 1.0/abs(5.0-uv.y*8.0);\n    //Scale in and out\n    float scale = exp(cos(iTime*0.5)*2.5);\n    \n    //Compute perspective coordinates\n    vec2 coords = uv * perspective * scale;\n    //Add scrolling offset\n    coords.x += (iTime+sin(iTime*0.5)/0.5)/5e1;\n    \n    //Compute pixel depth\n    float depth = length(vec3(uv, 1)) * scale * perspective;\n    //Scale window height\n    depth *= 1e3 / iResolution.y;\n    \n    //Left: Regular mipmapping for comparison\n    vec4 tex0 = texture(iChannel0, coords*4.0);\n    //Right: Fractal Texturing\n    vec4 tex1 = fractal_texture_mip(iChannel0, coords, depth);\n    \n    //Pick texture for each side\n    vec4 col = (uv.x<0.0) ? tex0 : tex1;\n    //Add light at the top\n    col += 0.6*perspective;\n    //Add border between textures\n    col *= smoothstep(0.0, 3.0, abs(uv.x) * iResolution.x);\n    \n    //Output results\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}