{"ver":"0.1","info":{"id":"3scSWr","date":"1571745468","viewed":191,"name":"ShaderTober - Tread","username":"Flopine","description":"A small doodle with inktober's theme \"Tread\". \nMy lack of inspiration is visible... 'cause it's when I'm doing something zelda-ish XD","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","zelda","twist","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define ITER 100.\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = 2.*PI/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per) -per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl(vec2 p, float r)\n{return length(p)-r;}\n\nfloat pillars (vec3 p)\n{\n    float per = 2.;\n    p.z = mod(p.z, per)-per*0.5;\n    p.x = abs(p.x)-1.6;\n    float c1 = cyl(p.xz, 0.3);\n    moda(p.xz, 5.);\n    p.x -= .3;\n    return max(-cyl(p.xz, 0.1), c1);\n}\n\nfloat room (vec3 p)\n{return stmin(pillars(p),-box(p, vec3(2.,1.,1e10)),0.2, 3.);}\n\nfloat carpet (vec3 p)\n{\n    vec3 pp = p;\n    p.y += 0.99;\n    float b1 = box(p, vec3(0.8,0.02,1e10));\n    \n    p = pp;\n    p.y +=0.6;\n    p.x = abs(p.x) - 2.;\n    float b2 = box(p, vec3(0.02,0.5,1e10));\n    \n    return min(b1,b2);\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    p.xy *= rot(-p.z*0.1);\n    float c = carpet(p);\n    float r = room(p);\n    float d = min(carpet(p),room(p));\n    \n    if (d == c) mat_id = 1;\n    if (d == r) mat_id = 2;\n    \n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.0);\n    return normalize(SDF(p) - vec3(SDF(p-eps.xyy),SDF(p-eps.yxy), SDF(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.001,0.001,-3.+iTime),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        l = vec3(0.,1.,-0.5),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            shad = i/ITER;\n            break;\n        }\n        \n        p += d*rd;\n    }\n\t\n    float t= length(ro-p);\n    \n    if (mat_id == 1) col = vec3(0.6-abs(p.x*0.15),0.,0.1);\n    if (mat_id == 2) col = vec3(0.8,0.7,0.6);\n    vec3 n = getnorm(p);\n    col *= mix(vec3(0.05,0.,0.2),\n               vec3(0.9,0.8,0.7),\n               dot(n,normalize(l))*0.5+0.5\n               );\n    col *= vec3(1.-shad);\n\n    col = mix(col, vec3(0.7,0.7,0.8),1.-exp(-0.05*t*t));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}