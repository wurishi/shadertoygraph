{"ver":"0.1","info":{"id":"XfdSRs","date":"1714329907","viewed":79,"name":"3D Perlin noise","username":"adaad","description":"3d perlin pattern","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = texture(iChannel0,uv);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define gridSize 100.\n#define gradVecLen 1.5\n#define speed .2\n\nfloat rand2(vec2 co){return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);}\nfloat rand3(vec3 co){return fract(rand2(co.xy) + rand2(co.yz)*235.21397);}\nfloat randm(vec3 co, float mult){return fract(rand3(co)*mult)*2.-1.;}\nvec3 grad(vec3 co) {return normalize(vec3(randm(co,123.532),randm(co,3.123426),randm(co,5.23)))*gradVecLen;}\nfloat calc(vec3 point, vec3 corner) {\n    return dot(point - corner, grad(corner));\n}\n\nstruct cont {\n    float height;\n    vec3 color;\n};\n\n/*cont[] colors = cont[] (\n    cont( 0.8, vec3(1,0,.1)),\n    cont( 0.4, vec3(0,1,1)),\n    cont( 0.0, vec3(1,.9,0)),\n    cont(-0.4, vec3(0,1,0.2)),\n    cont(-0.8, vec3(1,.5,0))\n);\n\nint numcolors = 5*/\n\ncont[] colors = cont[] (\n    cont( 0.8, vec3(1 , 0 , .5)),\n    cont( 0.6, vec3(1 , 0 , 0 )),\n    cont( 0.4, vec3(1 , .5, 0 )),\n    cont( 0.2, vec3(1 , 1 , 0 )),\n    cont( 0.0, vec3(.2, 1 , 0 )),\n    cont(-0.2, vec3(0 , 1 , .5)),\n    cont(-0.4, vec3(0 , 1 , 1 )),\n    cont(-0.6, vec3(0 , .5, 1 )),\n    cont(-0.8, vec3(.5, 0 , 1 ))\n);\n\nint numcolors = 9;\n\nfloat sm(float a, float b, float x) {\n    x = smoothstep(0.,1.,x);\n    if (a < b) {\n        return mix(a,b,x);\n    } else if (a > b) {\n        return mix(b,a,1.0-x);\n    } else {\n        return a;\n    }\n}\n\nfloat perlin(vec3 p){\n    p /= gridSize;\n    vec3 p0 = floor(p);\n    vec3 s = p - p0;\n    \n    #define f(v) dot(p-(v),grad(v))\n    #define g(a,b) f(p0+vec3(0.,a,b)),f(p0+vec3(1.,a,b))\n    return sm(sm(sm(g(0.,0.),s.x),\n                 sm(g(1.,0.),s.x),s.y),\n              sm(sm(g(0.,1.),s.x),\n                 sm(g(1.,1.),s.x),s.y),s.z);\n}\n\nbool approx( float a, float b, float interval ) {\n    float diff = a-b;\n    return abs(diff) < interval;\n}\n\nbool approx(float a,float b){return approx(a,b,0.02);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(fragCoord,iTime*speed*gridSize);\n    \n    // very low-freq noise as a base\n    float value = perlin(pos*.25);\n    \n    // add layered perlin noise\n    for (int i = 0; i < 3; i++) {\n        float mult = pow(2.0,float(i));\n        value += perlin(pos*mult)/mult;\n    }\n    \n    // compute the trail from the prev frame\n    vec2 trailPos = vec2(fragCoord.x+1.,fragCoord.y+sin(iTime/5.)/2.);\n    vec2 uv = trailPos / iResolution.xy;\n    vec3 col = texture(iChannel0,uv).xyz * 0.95;\n\n    // get contour lines\n    for (int i = 0; i < numcolors; i++) {\n        if (approx(value,colors[i].height)) {\n            col = colors[i].color;\n        }\n    }\n    \n    // add cool mouse fade effect\n    if (iMouse.z > 0.0) {\n        vec2 muv = iMouse.xy / iResolution.x;\n        uv = fragCoord / iResolution.x;\n        col = mix(vec3(value/2.+.5),col,vec3(clamp(length(uv-muv)*10.-.5,0.,1.)));\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}