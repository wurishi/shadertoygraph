{"ver":"0.1","info":{"id":"MXjyzR","date":"1726866394","viewed":40,"name":"970c31aa9b1b36551e5297864f698a34","username":"michelangelo","description":"exercise","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAX_ITER = 255;\nfloat EPS = 0.001;\nvec3 AMBIENT = vec3(0.99, 0.99, 0.97);\nfloat MIN_OBJ_DIST = 0.1;\nint RAYS = 5;\n\nvec3 normalToColor(vec3 n) {\n    return (n + vec3(1.)) / 2.;\n}\n\nstruct Hit {\n    vec3 color;\n    float dist;\n};\n\nHit sphere1(vec3 loc) {\n    vec3 disp = loc - vec3(14., 1. + 5. * sin(0.823466 * iTime), 1. + sin(0.4756524 * iTime));\n    float dist = length(disp) - 1.5;\n    vec3 col = normalToColor(normalize(disp));\n    return Hit(col, dist);\n}\n\nHit sphere2(vec3 loc) {\n    vec3 disp = loc - vec3(30., -10., 10.);\n    float dist = length(disp) - 10.0;\n    float a = asin(sin(10. * atan(disp.x, disp.y) + 1.2542 * iTime));\n    float val = 0.4 + 0.2 * step(a, 0.0);\n    vec3 col = vec3(val, val, val + 0.1);\n    return Hit(col, dist);\n}\n\nHit ground(vec3 loc) {\n    float dist = loc.z + 2.;\n    vec3 col = vec3((fract(loc.x * 0.15) + fract(loc.y * 0.15)) * 0.2) + vec3(0.7);\n    return Hit(vec3(0.8, 1., 0.8) * col, dist);\n}\n\nHit scene(vec3 loc) {\n    Hit hs1 = sphere1(loc);\n    Hit hs2 = sphere2(loc);\n    Hit hg = ground(loc);\n    if (hs1.dist < hs2.dist && hs1.dist < hg.dist) {\n        return hs1;\n    } else if (hs2.dist < hg.dist) {\n        return hs2;\n    } else {\n        return hg;\n    }\n}\n\nvec3 reflectBy(vec3 ray, vec3 n) {\n    return ray - 2. * dot(ray, n) * n;\n}\n\nvec3 perturb(vec3 n, vec3 noise, float t) {\n    return normalize(n + t * (noise - vec3(0.5)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = max(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy - (iResolution.xy / 2.)) / scale;\n    \n    vec3 accColor = vec3(0.);\n    for (int j = 0; j < RAYS; ++j) {    \n        vec3 dir = normalize(vec3(0.75, uv.x, uv.y));\n        vec3 noise = texture(iChannel0, vec2(31.4159265359 * uv.x + 2.5432623 * float(j), 27.1828182846 * uv.y + 1.5432623 * float(j))).xyz;\n\n        float reflectivity = 0.5*cos(0.3 * iTime) + 0.5;\n\n        vec3 pos = vec3(0.);\n        vec3 col = AMBIENT;\n        Hit hit;\n        for (int i = 0; i < MAX_ITER; ++i) {\n            hit = scene(pos);\n            if (hit.dist <= EPS) {\n                col = col * hit.color;\n                Hit hx = scene(pos + EPS * vec3(1., 0., 0.));\n                Hit hy = scene(pos + EPS * vec3(0., 1., 0.));\n                Hit hz = scene(pos + EPS * vec3(0., 0., 1.));\n                float d = hit.dist;\n                vec3 n = normalize(vec3(hx.dist - d, hy.dist - d, hz.dist - d));\n                n = perturb(n, noise, (1. - reflectivity) * 0.3);\n                dir = reflectBy(dir, n);\n                pos += dir * MIN_OBJ_DIST;\n            } else {\n                pos += dir * hit.dist;\n            }\n        }\n        accColor += col;\n    }\n\n    fragColor = vec4(accColor / float(RAYS), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}