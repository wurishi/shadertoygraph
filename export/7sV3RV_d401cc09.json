{"ver":"0.1","info":{"id":"7sV3RV","date":"1631818059","viewed":166,"name":"Walking on a torus","username":"MagmaMcFry","description":"What a 2D creature (the white dot) walking on a torus of revolution would see in all directions if light travelled geodesically on the torus surface. In other words, an azimuthal equidistant torus map.\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["torus","map","projection","geodesic","azimuthal","equidistant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//// This shader displays the view of someone (the white dot) living on the surface of a torus of revolution.\n//// The red part is the positively curved outer part of the torus,\n//// the blue part is the negatively curved inner part.\n\n// The tube radius is always 1. The midradius is the radius of the circle followed by the tube.\nconst float midradius = 1.5;\n// If the midradius is close to or less than 1, significant numerical instability will occur,\n// and you need to crank up the number of integration steps below.\n\n// Number of numerical integration steps to compute geodesic differential equation\n// Increase to improve numerical accuracy and fix yellow areas, decrease for performance\nconst int integrationSteps = 40;\n\n// Length of a unit, in pixels. Larger values will zoom the screen out.\n// This may require more integration steps for accuracy at large distances.\nconst float unitLength = 20.0;\n\n// Number of latitude/longitude lines\nconst float latitudeLines = 8.0;\nconst float longitudeLines = midradius * latitudeLines;\n\n// Parametrization of the torus:\n// P = ((m+cos(y))cos(x), ((m+cos(y))sin(x), sin(y))\n// m is the midradius\n\n// Geodesic differential equation:\n// (m+cos(y))x'' - sin(y)x'y' = 0\n// 2y'' + sin(y)x'x' = 0\n\n// Given position and velocity of a curve in parameter space representing a geodesic, compute second derivatives of that curve.\nvec2 dd(vec2 pos, vec2 dpos) {\n    vec2 ddpos;\n    ddpos.x = sin(pos.y) * dpos.x * dpos.y / (midradius+cos(pos.y));\n    ddpos.y = -sin(pos.y) * dpos.x * dpos.x / 2.0;\n    return ddpos;\n}\n\n// Convert second-order 2D differential equation function to first-order 4D\nvec4 D(vec4 pdp) {\n    return vec4(pdp.zw, dd(pdp.xy, pdp.zw));\n}\n\n// Euler method\nvec4 step_eu(vec4 v, float dt) {\n    vec4 Dv = D(v);\n    return v + dt * Dv;\n}\n\n// Midpoint method\nvec4 step_mp(vec4 v, float dt) {\n    vec4 Dv = D(v);\n    vec4 Dvm = D(v + 0.5 * dt * Dv);\n    return v + dt * Dvm;\n}\n\n// Classic 4-step Runge-Kutta method\nvec4 step_rk(vec4 v, float dt) {\n    vec4 Dv1 = D(v);\n    vec4 Dv2 = D(v + 0.5 * dt * Dv1);\n    vec4 Dv3 = D(v + 0.5 * dt * Dv2);\n    vec4 Dv4 = D(v + dt * Dv3);\n    return v + dt * (Dv1 + 2.0 * Dv2 + 2.0 * Dv3 + Dv4) / 6.0;\n}\n\nvec3 gridColor(vec2 uv) {\n    float p = 2.0;\n    float pi = 3.14159265359;\n    vec2 r = abs(2.0*fract(uv/vec2(2.0*pi/longitudeLines, 2.0*pi/latitudeLines))-vec2(1.0, 1.0));\n    float g = 0.5*float(r.x > 0.9) + 0.8*float(r.y > 0.9);\n    return vec3(cos(uv.y), g, -cos(uv.y));\n}\n\n// Iteratively follow geodesic in small steps\nvec2 iter(vec2 uv, vec2 pos0) {\n    // Convert screen coordinates to tangent coordinates isometrically\n    vec2 dpos0 = uv/vec2(midradius+cos(pos0.y), 1.0);\n    vec4 pdp = vec4(pos0, dpos0);\n    const float stepSize = 1.0 / float(integrationSteps);\n    for (int i = 0; i < integrationSteps; ++i) {\n        pdp = step_rk(pdp, stepSize);\n    }\n    return pdp.xy;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / unitLength;\n    vec2 pos0 = vec2(0.0, iTime);\n    vec4 visibleColor = vec4(gridColor(iter(uv, pos0)), 1.0);\n    vec4 dotColor = vec4(1.0, 1.0, 1.0, 1.0);\n    fragColor = mix(visibleColor, dotColor, float(dot(uv, uv) < 0.03));\n}\n","name":"Image","description":"","type":"image"}]}