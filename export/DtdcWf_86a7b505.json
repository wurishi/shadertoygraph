{"ver":"0.1","info":{"id":"DtdcWf","date":"1700370097","viewed":72,"name":"Mini Rasterisation","username":"celifan","description":"Top : Construction from plan view and elevation. ( similar to  https://www.shadertoy.com/view/DttyRS ) \nBottom : Direct construction. \n\n\n  ","likes":15,"published":1,"flags":0,"usePreview":1,"tags":["projection","perspective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n\nconst float PI = 3.1415926;\n// grid\nconst float _n = 12.0; // grid num subdivision.\nconst float _s = 0.28;//  grid width in normalize pix coordinates\n//\nfloat _pixSize ;\n// default pt radius in pixels\nfloat _ps = 3.0;\n// default colors \nconst vec3 _co = vec3( .9,0.3,0.0); // orange \nconst vec3 _cb = vec3(0.0,0.36,1.0); // blue\n// default text scale\nfloat _cs = 20.0;\n// default line drawing\nconst float _lw =1.0; // default line width in pixels\nconst float _ds =0.003; // default dash scale.\n// animation\nconst int _du = 25;\nconst int _tt = 25; // ease in/out time.\n//\nvoid drawChar(vec2 p, int c,vec3 color, inout vec3 pixel) \n{\n    if (p.x>=.0 && p.x<=1. && p.y>=0.&& p.y<=1.)\n    {\n        float f =  textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).x;\n        pixel =  mix(pixel, color, f);\n    }\n}\n\n// https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// fill the interior shape described by sd.\nvoid fill( float sd, vec3 color, inout vec3 pixel  )\n{\n    pixel =  mix(pixel, color, 1.0 - smoothstep(0.0, _pixSize*(_lw +.5), sd));\n    pixel = sd<0.0 ? color : pixel;\n}\n\n// Fade between 2 colors at a given time.\nvec3 colorAtTime(vec3 a, vec3 b,int duration, float opacity, inout int fBegin)\n{\n    float f1 = smoothstep(float(fBegin), float(fBegin+_tt),float(iFrame));\n    float f2 = 1.0-smoothstep( float(fBegin+duration-_tt), float(fBegin+duration),float(iFrame));\n    //\n    float f = min(f1, f2);\n    \n    vec3 end = mix( a, b,1.0-f );\n    return end;\n}\n\n//Segment - exact   (https://www.shadertoy.com/view/3tdSDj and https://www.youtube.com/watch?v=PMltMdi1Wzg)\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// solid stroke for the boundary of shape described by sd\nvoid strokeSolid( float sd, vec3 color,float lineWidth ,inout vec3 pixel  )\n{\n    pixel =  mix(pixel, color, (1.0 - sqrt(smoothstep((lineWidth-1.0)*_pixSize,_pixSize*(lineWidth +.5), abs(sd)))));\n}\n\n// dashed stroke for the boundary of shape described by sd.\nvoid strokeDashed(float sd, float alen, vec3 color, float lineWidth,float dashScale,inout vec3 pixel)\n{ \n    float d = sin((1.0/dashScale)*alen);\n    pixel =  mix(pixel, color,  clamp( .5 + .5*d/fwidth(d) , 0., 1. ) *(1.0 - sqrt(smoothstep((lineWidth-1.0)*_pixSize, _pixSize*(lineWidth +.5),abs(sd)))));\n}\n\nvoid drawSegmentDashed(vec2 p, vec2 a, vec2 b,float lineWidth, float dashScale,\n                 vec3 color,inout vec3 pixel )\n{\n   float d =  sdSegment(p,a, b );\n   vec2 ab = b-a;\n   float u= dot(p-a,normalize(ab));\n   strokeDashed(d,u, color, lineWidth, dashScale,pixel);\n}\n\nvoid drawSegment(vec2 p, vec2 a, vec2 b,float lineWidth,\n                 vec3 color, inout vec3 pixel )\n{\n   float d =  sdSegment(p,a, b );\n   strokeSolid(d, color, lineWidth,pixel);\n}\n\nvoid drawPoint(vec2 p, float pointSize, vec3 color, inout vec3 pixel )\n{\n   float sd =length(p);\n   pixel =  mix(pixel, color, (1.0 -sqrt(smoothstep((pointSize-1.0)*_pixSize, _pixSize*(pointSize +.5), abs(sd)))));\n}\n\n\n// transformation to apply to vec2 in [_n X _n ] -->  normalize pix coordinates\n#define V(x,y) (vec2(x,y)*_s/_n)\n#define S(x) ((x)*_s/_n) \nvec2 hd = vec2(S(_n),0.0);\nvec2 vd = vec2(0.0,S(_n));\nfloat cs = 6.0; //  unit cube\nfloat df =4.0; //cube distance from f\n\n//float ed = 3.0;\nvoid drawTemplate(vec2 p, inout vec3 pixel,float ed,\n                  out vec2  g, out vec2 h, out vec2 i, out vec2 j)\n{\n    //\n    float de = S(_n)*ed;\n    g= vec2(de,0.0);\n    h = g+hd;\n    i = h+vd;\n     j = g+vd;\n    drawPoint((p-g),_ps,_co, pixel);\n    drawPoint((p-h),_ps,_co, pixel);\n    drawPoint((p-i),_ps,_co, pixel);\n    drawPoint((p-j),_ps,_co, pixel);\n    \n    drawSegment(p,g,j,_lw,_co, pixel);\n    drawSegment(p,g,h,_lw,_co, pixel);\n    drawSegment(p,i,h,_lw,_co, pixel);\n    drawSegment(p,i,j,_lw,_co, pixel);\n    // \n    drawSegment(p,h,vec2(0.0),_lw,_co, pixel);\n    drawSegment(p,hd+V(0.0,1.0),  hd-V(0.0,1.0),_lw,_co,  pixel);\n    drawSegment(p,2.*hd +V(0.0,1.0), 2.*hd-V(0.0,1.0),_lw,_co,  pixel);\n    vec2 e = vd;\n    drawPoint((p-vd),_ps,_co, pixel);\n    drawSegmentDashed(p, e,  i, _lw,_ds,_co,pixel);\n    drawSegmentDashed(p, e,  vec2(0.0), _lw,_ds,_co,pixel);\n    // draw eye positions\n    drawChar((p-(e-V(2.0,2.0)))*_cs,101,_co,pixel);\n}\n\nvoid drawDirect(vec2 p, float ed,inout vec3 pixel, inout int begin)\n{\n    vec2 j,g,h,i;\n    vec2 e = vd;\n    vec2 o=V(2.0,2.0);\n    drawTemplate(p-o,pixel,ed, j,g,h,i);\n    e+=o;j+=o; g+=o;h+=o;i+=o;\n    //\n    drawChar((p-(j - V(.0,2.0)))*_cs,106,_co,pixel);\n    drawChar((p-(g- V(.0,2.0)))*_cs,103,_co,pixel);\n    drawChar((p-(h- V(.0,2.0)))*_cs,104,_co,pixel);\n    drawChar((p-(i- V(.0,2.0)))*_cs,105,_co,pixel);\n     \n    \n    vec2 l =(j+ vd/(ed+1.0));\n    vec2 k = vec2(g.x-hd.x/(ed+1.0),g.y + vd.y/(ed+1.0));\n    \n    begin+=_du;\n    vec3 fc =colorAtTime(_co,pixel,_du*6,2.0, begin);\n    drawSegment(p,e,g,_lw,fc,  pixel);\n    drawSegment(p,l,l+hd,_lw,fc,pixel);\n    drawSegment(p,g,i,_lw,fc,  pixel);\n    begin +=_du*2;\n    if (iFrame >begin +_tt){\n        drawPoint(p -k ,_ps,_co, pixel);\n        drawPoint(p-l,_ps,_co,pixel);\n        drawChar((p-(k-V(2.0,0.0)))*_cs,107,_co,pixel);\n        drawChar((p-l)*_cs,108,_co,pixel);\n    }\n    begin +=_du*6;\n    float rf = ed/(ed + 1.0);\n    if (iFrame >begin +_tt)\n    {\n        vec3 pcol =mix( pixel, (_co+pixel)*.5, smoothstep(float(begin),float(begin+_du),float(iFrame)));\n        float sd =sdTriangle(p, g,l, k);\n        fill(sd, pcol,pixel);\n        sd =sdTriangle(p, g,j,l);\n        fill(sd, pcol,pixel);\n\n        begin +=_du*3;\n        if (iFrame >begin +_tt)\n        {\n            vec3 fBlue =mix( pixel, _cb, smoothstep(float(begin),float(begin+4*_du),float(iFrame)));\n            vec3 fOra =mix( pixel, _co, smoothstep(float(begin),float(begin+4*_du),float(iFrame)));\n            vec3 fc =colorAtTime(fOra,pixel,_du*6,2.0, begin);\n            begin+=6*_du;\n            vec2 m= j+V(_n-(df+cs),0.0);\n            drawChar((p-(m-V(0.0,1.8)))*_cs,109,fOra,pixel);\n            vec2 n = j + V(df,0.0);\n            drawChar((p-(n-V(0.0,1.8)))*_cs,110,fOra,pixel);\n            drawSegment(p,n,e,_lw,fc,  pixel);\n            drawSegment(p,m,i,_lw,fc,  pixel);\n            float r0 = (1.0-ed/(ed+(n.x-j.x)/S(_n)));\n            vec2 jl = j+V(0.0,_n*r0);\n            drawSegment(p,jl, jl+ V(_n,0.0),_lw,fc,  pixel);\n\n            float dx = mix(m.x-j.x, 0.0 ,r0);\n            vec2 jli = vec2(j.x+dx, jl.y);\n            drawPoint(p-jli,_ps,fBlue,pixel);\n            //\n            vec2 o =(m+V(cs,0.0));\n            drawChar((p-(o-V(0.0,1.8)))*_cs,111,fOra,pixel);\n            drawSegment(p,o,i,_lw,fc,pixel);\n            dx = mix(o.x, i.x,r0);\n            vec2 jli1 = vec2(dx, jl.y);\n            drawPoint(p-jli1,_ps,fBlue,pixel);\n            float lBase =jli1.x-jli.x;\n            vec2 jli1t= jli1 + vec2(0.0,lBase);\n            //\n            vec2 jlit= jli + vec2(0.0,lBase);\n            drawSegment(p, jli,jlit,_lw,fBlue,pixel);\n            // \n            vec2 q = (n + V(cs,0.0));\n            drawPoint(p-q,_ps,fOra,pixel);\n            drawChar((p-(q-V(0.0,1.8)))*_cs,113,fOra,pixel);\n            drawSegment(p, e,q,_lw,fc,pixel);\n            r0 = (1.0-ed/(ed+(q.x-j.x)/S(_n)));\n            jl = j+V(0.0,_n*r0);\n            drawPoint(p-jl,_ps,fOra,pixel);\n            drawSegment(p,jl, jl+ V(_n,0.0),_lw,fc,  pixel);\n\n            // draw point after\n            drawPoint(p-m,_ps,fOra,pixel); //m\n            drawPoint(p-jl,_ps,fOra,pixel);\n            drawPoint(p-o,_ps,fOra,pixel);\n            drawPoint(p-n, _ps,fOra,pixel);\n\n            drawSegment(p, jli1,jli1t,_lw,fBlue,pixel);\n            drawSegment(p, jlit,jli1t,_lw,fBlue,pixel);\n            drawSegment(p,jli1t, i, _lw,fc,pixel);\n            drawSegment(p,jlit, i, _lw,fc,pixel);\n            drawSegment(p, jli,jli1,_lw,fBlue,pixel);\n\n            dx = mix(o.x-j.x, 0.0 ,r0);\n            vec2 jli2 = vec2(j.x+dx, jl.y);\n            drawPoint(p-jli2,_ps,fBlue,pixel);\n\n            float r1 = ( i.y-jli1t.y)/(jli1t.x-i.x);\n            float dy = r1*(jli2.x-jli1t.x);\n            vec2 jli2t = vec2(jli2.x,jli1t.y-dy);\n            drawSegment(p, jli2t,jli1t,_lw,fBlue,  pixel);\n            drawSegment(p, jli2,jli2t,_lw,fBlue,  pixel);\n            dx = mix(m.x-j.x, 0.0 ,r0);\n            vec2 jli3 = vec2(j.x+dx, jl.y);\n            drawPoint(p-jli3,_ps,fBlue,pixel);\n            r1 = ( i.y-jlit.y)/(jlit.x-i.x);\n            dy = r1*(jli3.x-jlit.x);\n            vec2 jli3t = vec2(jli3.x,jlit.y-dy);\n            drawSegment(p, jli3t,jlit,_lw,fBlue,  pixel);\n            drawSegment(p, jli3,jli3t,_lw,fBlue,  pixel);\n            drawSegment(p,jli3t,jli2t,_lw,fBlue,  pixel);\n            //\n            drawSegment(p,jli,jli3,_lw,fBlue,  pixel);\n            drawSegment(p,jli1,jli2,_lw,fBlue,  pixel);\n            drawSegment(p,jli2,jli3,_lw,fBlue,  pixel);\n        }\n    }\n}\n\nvoid drawWithOrtho(vec2 p, float ed,inout vec3 pixel,inout int begin)\n{  \n    // ortho views\n    vec2 g3,h3,i3,j3;\n    vec2 e3 = vd;\n    vec2 o3= V(2.0,_n+4.0);\n    drawTemplate(p-o3,pixel,ed, g3,h3,i3,j3);\n    e3+=o3;g3+=o3; h3+=o3;i3+=o3;j3+=o3;\n    //\n    drawChar((p-(g3+ V(.0,.2)))*_cs,103,_co,pixel);\n    drawChar((p-(h3+ V(.0,.2)))*_cs,104,_co,pixel);\n    drawChar((p-(i3+ V(.0,.2)))*_cs,105,_co,pixel);\n    drawChar((p-(j3+ V(.0,.2)))*_cs,106,_co,pixel);\n    //\n   \n    vec2 g4,h4,i4,j4;\n    vec2 e4 = vd;\n    vec2 o4= V(2.0,2.0*_n+4.0);\n    drawTemplate(p-o4,pixel,ed, g4,h4,i4,j4);\n    e4+=o4; g4+=o4; h4+=o4; i4+=o4; j4+=o4;\n    o3+=hd*ed; o4+= hd*ed;\n    // perpsective window\n    vec2 ec = vec2(i3.x + S(_n*.5), i3.y+ S(_n*.5));\n    drawPoint(p-ec,_ps,_co,pixel);\n    drawSegment(p, ec,ec+V(_n,0.0),_lw,_co,pixel);\n    drawSegment(p, ec+V(_n,0.0),ec+V(_n,-_n),_lw,_co,pixel);\n    drawSegment(p, ec+V(_n,-_n),ec+V(0.0,-_n),_lw,_co,pixel);\n    drawSegment(p, ec+V(0.0,-_n),ec,_lw,_co,pixel);\n    // draw cube front [ elevation ] jklm\n    vec2 k4 = o4+V(df,0.0);\n    vec2 l4 = k4 + V(cs,0.0);\n    vec2 m4 = l4 + V(0.0,cs);\n    vec2 n4 = k4+ V(0.0,cs);\n    //\n    drawSegment(p, k4,l4,_lw,_cb,pixel);\n    drawSegment(p, l4,m4,_lw,_cb,pixel);\n    drawSegment(p, m4,n4,_lw,_cb,pixel);\n    drawSegment(p, n4,k4,_lw,_cb,pixel);\n    // draw cube top [plan view ] jkno\n    vec2 k3 = o3+V(df,df);\n    vec2 l3 = k3 + V(cs,0.0);\n    vec2 m3 = l3 + V(0.0,cs);\n    vec2 n3 = k3+ V(0.0,cs);\n    //\n    drawSegment(p, k3,l3,_lw,_cb,pixel);\n    drawSegment(p, l3,m3,_lw,_cb,pixel);\n    drawSegment(p, m3,n3,_lw,_cb,pixel);\n    drawSegment(p, n3,k3,_lw,_cb,pixel);\n    // projection base plane\n    float r = (_n*ed)/(ed+1.0);\n    vec3 fc =colorAtTime(_co,pixel,_du*4,1.0, begin);\n   \n    drawSegment(p,e3, h3,_lw,fc,pixel);\n    drawSegment(p,e4, h4,_lw,fc,pixel);\n    vec3 pcol =mix( pixel, (_co+pixel)*.5, smoothstep(float(begin),float(begin),float(iFrame)));\n    vec2 p1 = ec+V(0.0,-_n);\n    vec2 p2 = ec + V(r,-r);\n    vec2 p3= ec+V(_n,-_n);\n    \n    float sd =sdTriangle(p, p1,p2 ,p3 );\n    fill(sd, pcol,pixel);\n    sd =sdTriangle(p, ec+V(0.0,-_n), ec+V(0.0,-r), ec + V(r,-r));\n    fill(sd,pcol,pixel);\n    begin+= _du*4;\n    \n    //projection blue cube\n    float rn = ed/(ed +df/_n);\n    float rf = ed/(ed +(df+cs)/_n);\n    \n    vec2 jp;\n    fc =colorAtTime(_co,pixel,_du*4,1.0, begin);\n    drawSegment(p,e3, k3,_lw,fc,pixel);\n    drawSegment(p,e4, k4,_lw,fc,pixel);\n    jp =ec+ V(rn*(_n-df),-rn*_n);\n    if (iFrame > begin+_tt) drawPoint(p-jp,_ps,_cb,pixel);\n    begin+= _du*4;\n    \n    vec2 kp;\n    fc =colorAtTime(_co,pixel,_du*4,1.0, begin);\n    drawSegment(p,e3, l3,_lw,fc,pixel);\n    drawSegment(p,e4, l4,_lw,fc,pixel);\n    kp =ec+ V(rf*(_n-df),-rf*_n);\n    if (iFrame > begin+_tt) drawPoint(p-kp,_ps,_cb,pixel);\n    begin+= _du*4;\n    \n    vec2 lp;\n    fc =colorAtTime(_co,pixel,_du*4,1.0, begin);\n    drawSegment(p,e3, m3,_lw,fc,pixel);\n    drawSegment(p,e4, l4,_lw,fc,pixel);\n    lp =ec+ V(rf*(_n-df-cs),-rf*(_n));\n     if (iFrame > begin+_tt) drawPoint(p-lp,_ps,_cb,pixel);\n    begin+= _du*4;\n     \n    vec2 mp;\n    fc =colorAtTime(_co,pixel,_du*4,1.0, begin);\n    drawSegment(p,e3, n3,_lw,fc,pixel);\n    drawSegment(p,e4, k4,_lw,fc,pixel);\n    mp =ec+ V(rn*(_n-df-cs),-rn*(_n));\n    if (iFrame > begin+_tt) drawPoint(p-mp,_ps,_cb,pixel);\n    begin+= _du*4;\n    \n    if (iFrame > begin+_tt)\n    {\n        float dBase = distance(jp,mp);\n        vec2 jpt = jp + vec2(0.0, dBase);\n        drawSegment(p,jp, jpt,_lw,_cb,pixel);\n        vec2 mpt = mp + vec2(0.0, dBase);\n        drawSegment(p,mp, mpt,_lw,_cb,pixel);\n        drawSegment(p,jp, mp,_lw,_cb,pixel);\n        drawSegment(p,jpt, mpt,_lw,_cb,pixel);\n        drawSegment(p,jp, kp,_lw,_cb,pixel);\n        drawSegment(p,mp, lp,_lw,_cb,pixel);\n        drawSegment(p,kp, lp,_lw,_cb,pixel);\n        //\n        vec2  lpt =ec+ V(rf*(_n-df-cs),-rf*(_n-cs));\n        drawSegment(p,lpt, lp,_lw,_cb,pixel);\n        drawSegment(p,lpt, mpt,_lw,_cb,pixel);\n        vec2  kpt =ec+ V(rf*(_n-df),-rf*(_n-cs));\n        drawSegment(p,kpt, kp,_lw,_cb,pixel);\n        drawSegment(p,kpt, lpt,_lw,_cb,pixel);\n        drawSegment(p,kpt, jpt,_lw,_cb,pixel);\n    }\n}\n\nvoid draw(vec2 p,float ed, inout vec3 pixel)\n{\n    int begin = 0;\n   \n    drawDirect(p,ed,pixel,begin);\n    begin +=3*_du;\n    drawWithOrtho(p,ed,pixel,begin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    _pixSize = 1.0/iResolution.y;\n    float ed = iFrame > _du*45 ? abs(cos(iTime)*3.0) :3.0;\n    // Time varying pixel color\n    vec3 pixel = vec3(.9);\n    draw(uv,ed,pixel);\n\n    // Output to screen\n    fragColor = vec4(pixel,1.0);\n}","name":"Image","description":"","type":"image"}]}