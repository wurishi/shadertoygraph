{"ver":"0.1","info":{"id":"ttfGzs","date":"1557296743","viewed":158,"name":"Rough Reflections GI","username":"space928","description":"Buggy reflection shader...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","gi","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//uniform float time;\nuniform vec2 resolution;\nuniform sampler2D PerlinNoise;\nuniform sampler2D Mountain;\nuniform float subsecond;\nuniform sampler2D Grass;\nuniform sampler2D Rock;\nuniform sampler2D Cliff;\nuniform sampler2D noise;\nuniform sampler2D noisec;\n\nfloat pi = 3.1415926;\nfloat EPSILON = 0.02;\nint MARCHSTEPS = 64;\nint GISTEPS = 16;\nfloat MAX_DIST = 20.0;\n\nvec3 pos = vec3(0.0, -8., -8.);\nvec3 posTime = vec3(0.0, 0.0, 0.0);\nvec3 lightDir = vec3(0.8, 0.1, -0.1);\nfloat camRoty = 0.;\nfloat camRotyTime = .0;\n\nvec3 lightCol = vec3(1., .9, 0.8);\nvec3 amb = vec3(.8, .9, .6);\nfloat ambInt = .15;\n\nvec3 fogCol = vec3(.35, .4, .5);\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n    vec3 q = vec3(p.x, fract(p.y) * 2.0 - 1.0, p.z);\n\n    return length(max(abs(q)-b,0.0))-r;\n}\n\nfloat box( vec3 p, vec3 b)\n{\n  return length(max(abs(p)-b,0.))-.1;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    vec3 q = fract(p/2.) * 2.0 - 1.0;\n\n    return length(q) - r;\n}\n\nfloat cyl(vec3 p, float r)\n{\n    vec3 q = fract(p/4.) * 2.0 - 1.0;\n\n    return length(q.xz)-r/2.;\n}\n\nfloat disp(vec3 p)\n{\n    float l = length(fract(p.xz)*2.-1.);\n    l = pow(l, l+.1)+p.y+1.;\n    l+= texture(iChannel2,floor(p.xz)/10.).r*4.;\n    return l;\n}\n\nfloat plane(vec3 p)\n{\n  return p.y;\n}\n\nvec3 twist(vec3 p, float sc, float a) {\n    float c = cos(sc*p.y);\n    float s = sin(sc*p.y);\n     mat2 m = mat2(c,-s,s,c);\n    return mix(vec3(m*p.xz,p.y), p, a);\n}\n\nvec3 rot(vec3 p, float t, float x)\n{\n  p *= mat3(cos(iTime*t+x), 0., sin(iTime*t+x),\n            0., 1., 0.,\n            -sin(iTime*t+x), 0., cos(iTime*t+x));\n  return p;\n}\n\nfloat add(float d, float o)\n{\n    return min(d, o);\n}\n\nfloat uni(float d, float o)\n{\n    return max(d, o);\n}\n\nfloat map(vec3 p)\n{\n  p = rot(p, camRotyTime, camRoty);\n\n  float d = plane(p+2.);\n  d = add(d, box(p-vec3(0.,-1.5,0.), vec3(.4)));\n  d = add(d, cyl(p,.2));\n\n  return d;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n\n    for( int i=0;i<MARCHSTEPS;i++ ) {\n        vec3 p = o + r * t;\n\n        float d = map(p);\n\n        if(d < 0.)\n          return t + d;\n\n        t += d*.5;\n    }\n    return t;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n  return normalize(vec3( map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n     map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n     map(vec3(p.x, p.y, p.z + 0.05)) - map(vec3(p.x, p.y, p.z - EPSILON)) ));\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n      vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0., 1.0 );\n\n      return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getCol(vec3 nrm, vec3 p)\n{\n    p = p;\n\n    vec3 grass = texture(iChannel2, p.xz/2.).rgb;\n    vec3 rock = texture(iChannel3, p.xz/2.).xyz;\n\n    //return nrm*.5+.5;\n    vec3 ret = mix(rock, grass, nrm.y);\n\n    if(nrm.y < .01)\n     ret = vec3(1., .4, .2)*3.;// * ret*10.;\n    return vec3(1.);//ret;\n    //return mix(rock, grass, nrm.y*2.);\n}\n\nvec3 collectLight(vec3 nrm, vec3 p, vec3 view, vec2 uv)\n{\n  vec3 c = vec3(0.);\n  vec3 d1 = vec3(0.);\n\n  for(int i = 0; i<GISTEPS; i++)\n  {\n    vec3 rndHemi = texture(iChannel1, p.xy+p.z*float(i)+iTime*20.3156).xyz;//Add temporal?\n    rndHemi.xyz *= 2.;\n    rndHemi.xyz -= 1.;\n    rndHemi = normalize(rndHemi);\n    rndHemi = mix(rndHemi,reflect(view*2., normalize(nrm)),.7);\n    //rndHemi = //Map hemi onto nrm\n\n    float d = trace(p, rndHemi);\n    vec3 n = estimateNormal(p+rndHemi*d);\n\n    if(length(d)>MAX_DIST*.5)\n       c += texture(iChannel0, uv).xyz;\n     else\n       c += clamp(dot((lightDir), n)*lightCol,0.,1.);\n\n     d1.xyz=n;\n  }\n  c /= float(GISTEPS);\n\n  return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    pos = vec3(sin(iTime*pi/2.)*1.7, sin(iTime)*.5-1., -2.);\n\n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = pos + (iTime*posTime);\n    vec3 t = vec3(trace(o, r));\n    //t *= vec3(1.0, 0.6, 0.4);\n    vec3 p = o+r*t;\n    vec3 nrm = estimateNormal(p);\n    nrm = rot(nrm, camRotyTime, camRoty);\n    //t *= hsv2rgb(vec3(fract(time/4.), 1., 1.5));\n\n     vec3 fog = clamp(1.0 / (1.0 + t * t * 0.04)+fogCol-vec3(length(fogCol)), 0., 1.);\n     fog = getCol(nrm, p)*1.5;\n     fog *= collectLight(nrm, p, r, fragCoord.xy / iResolution.xy);\n     //fog *= clamp(dot((lightDir), nrm)*lightCol + pow(1./length(fract(p.xz/2.) * 2.0 - 1.0)*.4, 2.), 0., 1.5);\n     fog += amb * ambInt;\n     //if(nrm.y < .01)\n     //  fog = vec3(1., .4, .2) * fog*5.;\n\n     if(length(t)>MAX_DIST)\n       fog = texture(iChannel0, fragCoord.xy / iResolution.xy).xyz;\n     fog = mix(texture(iChannel0, fragCoord.xy / iResolution.xy).xyz, fog, smoothstep(length(t)/MAX_DIST, 1., .95));\n\n     fragColor = vec4(fog,1.0);\n}","name":"Image","description":"","type":"image"}]}