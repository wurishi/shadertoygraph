{"ver":"0.1","info":{"id":"wsKyzd","date":"1603550666","viewed":104,"name":"fork-game of throne-Sound","username":"jorge2017a1","description":"fork-game of throne-Sound","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["forkgameofthronesound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///http://glslsandbox.com/e#17931.0\n#define PI 3.141\n\n#ifdef MULTISAMPLE\nconst float frames = 8.;\n#else\nconst float frames = 1.;\n#endif\n\nconst float shutter = 1./60.; //shutter speed\nconst float ap = 0.3; \t\t//aperture\nconst int maxSteps = 44;\n\n\nfloat gTime;\n\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy, vec2(12.9898,78.233)))*43758.5453);\n}\n\nvec3 rotateY(vec3 p,float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\tvec3 r;\n\tr.x = ca*p.x + sa*p.z;\n\tr.y = p.y;\n\tr.z = -sa*p.x + ca*p.z;\n\treturn r;\n\n}\n\nvec3 rotateZ(vec3 p,float a)\n{\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\tvec3 r;\n\tr.x =-sa*p.y + ca*p.x; \n\tr.y = ca*p.y + sa*p.x;\n\t\n\tr.z = p.z;\n\treturn r;\n\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\n\n\nconst float landang=4.5;\nconst float speed=25.;\nconst float falls=1.+.38;\nconst float curve=1.*.27;\t\nconst float sep = 6.0;\nconst float rate=speed/sep;\n\nfloat domino(vec3 q )\n{\n \treturn sdBox( q, vec3(1.0,8.,4.)*0.5 );\n}\n\nvec3 dominoRotate( vec3 p )\n{\n\tfloat dist=gTime*speed;\n\n\tp=rotateY(p,gTime*0.2);\n\tp.y+=4.*sin(gTime*0.2);\n\tp.y+=7.;\n\tp.x+=dist;\n\n\treturn p;\n}\n\nfloat dominoNum(vec3 p)\n{\n\tp=dominoRotate( p );\n\n\treturn floor(( (p.x)/sep));\n}\n\nvec3 dominoPos(vec3 p, float off)\n{\n\tp = dominoRotate( p );\n\n\tfloat num = floor(( (p.x)/sep));\n\t\n\tvec3 q = p;\n\t//q.y-=4.;\n\tq.x+=0.;\n\tq.x= mod(p.x+off*sep,sep)-0.5*sep;\n\tq.x-=off*sep;\n\tfloat rot = (gTime*rate-num-off)*curve;\n\trot=(1.-max(1.-rot,0.)*max(1.-rot,0.));\n\n\tfloat a=PI; //standing\n\tif(num+5.+off < ((gTime)*rate))\n\t\ta=landang;\n\telse if(num+off < ((gTime)*rate))\n\t\ta=a=min(PI+falls*rot,landang);\n\tq=rotateZ(q,a);\n\tq.x-=0.5;\n\tq.y+=4.0;\n\t\n\treturn q;\n}\n\nfloat spc=1.13;\nfloat rad=0.18;\n\nvec3 domCol = vec3(0.1);\nvec3 dotCol = vec3(0.9);\nvec3 dominoTex(vec3 p, float rnd )\n{\n#ifndef SIMPLE\n\tvec3 q=p;\n\n\tif (( abs(q.z) > spc*1.5)  || (abs(q.y) > spc*3.+rad) || q.x<0.)\n\t\treturn domCol;\n\n\tif (( abs(q.z) < 1.8) && (abs(q.y) < 0.1) )\n\t\treturn dotCol;\n\n\tif (q.y > 0.)\n\t\tq.y-=6.0*0.51;\n\telse\n\t\tq.y+=6.0*0.51;\n\tq+=0.5*spc;\n\t\n\n\tq = mod(q,spc)-0.5*spc;\n\tp/=spc;\n\tif (p.y> 0.)\n\t\tp.y -=0.19;\n\tint spotN = int(p.z+1.45)+3*int(p.y+3.1);\n\n\tint n = int(rand(vec2(rnd,-rnd))*7.);\n\n\tif (spotN>8)\n\t{\n\t\tn = int(rand(vec2(-rnd,rnd))*7.);\n\t\tspotN-=9;\n\t}\n\t\n\n\tif ((spotN == 1) || (spotN ==7)) \n\t\treturn domCol;\n\tif (((spotN == 0) || (spotN == 8)) && (n < 4))\t\n\t\treturn domCol;\n\tif ((spotN == 4) && (n/2 == (n+1)/2))\n\t\treturn domCol;\n\tif (((spotN ==2) || (spotN ==6)) && n < 2)\n\t\treturn domCol;\n\tif (((spotN ==3) || (spotN ==5)) && n != 6)\n\t\treturn domCol;\t\n\n\tif (pow(q.y,2.)+pow(q.z,2.)<rad )\n\t\treturn dotCol;\n\n#endif\n\treturn domCol;\n\n}\n\n\nfloat scene(vec3 pos)\n{\n\treturn min(domino(dominoPos(pos,0.)),domino(dominoPos(pos,-1.)));\n\n}\n\n// calculate scene normal\nvec3 sceneNormal( in vec3 pos )\n{\n    float eps = 0.0001;\n    vec3 n;\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - scene( vec3(pos.x-eps, pos.y, pos.z) );\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - scene( vec3(pos.x, pos.y-eps, pos.z) );\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - scene( vec3(pos.x, pos.y, pos.z-eps) );\n    return normalize(n);\n}\n\t\t\t\nconst vec3 lightPos = vec3(-1.0,10.0,7.0);\nvec3 l = normalize(lightPos-vec3(0.0));\n\nvec3 trace(vec3 ro, vec3 rd, out vec3 rgb, out bool hit)\n{\n\thit = false;\t\n\n\tconst float hitThreshold = 0.05;\n\n\tvec3 pos = ro+rd;\n\t\n\t\n\trgb = vec3(1.0);\n\n\n\tfor( int i=0;i<maxSteps;i++)\n\t{\n\t\tvec3 currPos =  dominoPos(pos,0.);\n\t\tvec3 prevPos =  dominoPos(pos,-1.);\n\t\tfloat curr = domino(currPos);\n\t\tfloat prev = domino(prevPos);\n\t\tfloat d = min( curr, prev );\n\t\tif(d<hitThreshold) {\n\t\t\thit = true;\n\t\t\tfloat rnd = dominoNum(pos);\n\t\t\t\t\n\t\t\t\n\t\t\tif (curr < prev)\n\t\t\t{\n\t\t\t\trgb = dominoTex(currPos, rnd );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trgb = dominoTex(prevPos, rnd-1.);\n\t\t\t}\n\t\t\t#ifndef SIMPLE\n\t\t\tvec3 n = sceneNormal(pos);\n\t\t\trgb+= dot(l,n)*0.05;\n\t\t\t#endif\n\n\t\t\treturn pos;\n\t\t}\n\n\n\t\tfloat h = 0.;\n\t\th-=4.*sin(gTime*0.2);\n\t\th-=7.;\n\n\t\tif (pos.y < h)\n\t\t{\n\t\t\thit=false;\n\t\t\treturn pos;\n\t\t}\n\n\t\tpos += d*rd*1.;\n\t\t\n\t}\n\trgb = vec3(0.);\n\thit=false;\n\treturn pos;\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 position = ( (fragCoord.xy/iResolution.x)*2. -vec2(1.,iResolution.y/iResolution.x));\n\n\t\n\tfloat foc = 28.0;//sin(t)*30.+40.0;\n\t\n\tvec3 rgb = vec3(0.0);\n\tvec3 rf = vec3(position.x*foc,position.y*foc, 0.0);\n\tvec3 getcol;\n\tfor(float frame = 0.0;frame <frames;frame++)\n\t{\n// WTF with all the fuzzy random dot shit?\n\n\t\tgTime=iTime-.5*shutter;\n\n\t\n\t\tfloat j=0.;\n\t\n\t\tfloat a=3.141*2.*rand(vec2(iTime,iTime*0.5)*(position+frame));\n\n\t\tvec3 ro=vec3(0.0, 0.0, foc);\n\t\tvec3 rd=normalize(rf - ro);\n\t\tbool hit;\n\t\tvec3 pos = trace(ro,rd, getcol, hit);\n\t\n\t\tif (hit)\n\t\t\trgb += getcol/frames;\n\t\telse\n\t\t{\t\n\t\t\t#ifndef SIMPLE\n\t\t\tfloat ao = 0.5-scene(pos);\n\t\t\trgb-=clamp( ao, 0.0, 1.0)/frames;\n\t\t\t#endif\n\t\t\tvec3 po = ro+rd*10000.;\n\t\t\tfloat b = clamp(abs(po.y/10000.),0.0,1.0);\n\t\t\n\t\t    \trgb+= vec3(1.-b)/frames;\n\t\t}\n\t}\n\t\n\tfragColor = vec4( rgb , 1.0 );\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//referencia y modificado por jorge2017a1\n///https://www.shadertoy.com/view/tdVyRK   Creado por jt en 2020-10-21\n\n///https://www.shadertoy.com/view/tdVyRK\n//https://www.shadertoy.com/view/4djSRW\n\n//  1 out, 1 in...  Creado por Dave_Hoskins\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nfloat hash1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//referencia Inigo Quilez\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n \n    float k = hash11(i);\n    \n\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n//referencia Inigo Quilez\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    //uint  i = uint(floor(p));\n    float  i = (floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n\n    //float g0 = hash(i+0u)*2.0-1.0;\n    float g0 = hash11(i)*2.0-1.0;\n    \n    //float g1 = hash(i+1u)*2.0-1.0;\n\tfloat g1 = hash11(i)*2.0-1.0;\n    \n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\n////////////////////////////////////\n//referencia Inigo Quilez\nfloat fbm( in float x )\n{    \n    float n = 0.0;\n    float s = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        n += s*bnoise(x);\n        s *= 0.5;\n        x *= 2.0;\n        x += 0.131;\n    }\n    return n;\n}\n\n\n\n\n\n\n#define pi 3.1415926\n\nfloat wave(float t)\n{\n    float s1=sin(2.0 * pi * t);\n\treturn fbm(sin(2.0 * pi * t + sin(s1+sin(s1)) ));\n}\n\nfloat saw(float t)\n{\n    return  fbm (2.0*fract(t+fract(t+2.0*fract(t))) - 1.0);\n}\n\n#define S 8.0\n#define N 96\n\nconst int base[N] = int[N](\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    7, 7, 0, 0, 3, 5,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    2, 2,-5,-5,-2, 0,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 2, 3,\n    5, 5,-2,-2, 3, 2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2,\n    0, 0,-7,-7,-4,-2\n);\n\nconst int voice[N] = int[N](\n    7, 7, 7, 7, 7, 7,\n    0, 0, 0, 0, 0, 0,\n    3, 5, 7, 7, 7, 7,\n    0, 0, 0, 0, 3, 5,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    2, 2, 2, 2, 2, 2,\n    5, 5, 5, 5, 5, 5,\n   -2,-2,-2,-2, 3, 2,\n    5, 5, 5, 5, 5, 5,\n   -2,-2,-2,-2, 3, 2,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0\n    );\n\nivec2 note(float time)\n{\n    int n = int(floor(time * S)); // keep in sync with local\n    return ivec2(base[n % N] - 24, voice[n % N]);\n}\n\nfloat local(float time)\n{\n    return fract(time * S) / S; // keep in sync with note\n}\n\nfloat sound1(float freq, float time)\n{\n    float t = freq * time;\n    float h = clamp(1.0 - 4.0 * time, 0.0, 1.0); // linear\n    return mix(wave(t), saw(t), h) * h; // plucked string like sound\n}\n\nfloat sound2(float freq, float time)\n{\n    float t = freq * time;\n    float h = 0.5;\n    return mix(wave(t), saw(t), h);\n}\n\nfloat play(float time)\n{\n    ivec2 n = note(time);\n    float t = local(time);\n    vec2 f = 0.5 * 440.0 * exp2(vec2(n) / 12.0);\n    return sound1(f.x, t) + sound2(f.y, t);\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    //return vec2(sound(0.25 * 440.0, time)); \n    return vec2(play(time));\n}\n","name":"Sound","description":"","type":"sound"}]}