{"ver":"0.1","info":{"id":"4cs3z8","date":"1704388446","viewed":87,"name":"Train to nowhere","username":"Aurore_B","description":"// A lot of cleaning is still needed. //\n\n2d parallax attempt taking Spirited Away as an inspiration !","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ---------------------------------------------------------------\n// Colors.\n// ---------------------------------------------------------------\n\n#define MountainLayerOneLight vec3(221,229,244)/255.\n#define MountainLayerOneDark vec3(102,142,171)/255.\n#define MountainLayerTwoLight vec3(102,142,171)/255.\n#define MountainLayerTwoDark vec3(57,65,73)/255.\n#define MountainLayerThreeLight vec3(102,142,171)/255.\n#define MountainLayerThreeDark vec3(27,35,43)/255.\n\n#define OceanLight vec3(112,199,232)/255.\n#define OceanDark vec3(93,170,213)/255.\n\n#define CloudsLight vec3(240)/255.\n#define CloudsDark vec3(120)/255.\n\n#define LampPostLight vec3(100,100,100)/255.\n#define LampPostDark vec3(20,20,20)/255.\n\n#define BridgeLight vec3(135,60,67)/255.\n#define BridgeDark vec3(100,50,49)/255.\n\n#define TrainBgLight vec3(30,30,45)/255.\n#define TrainBgDark vec3(8,8,15)/255.\n#define Handles vec3(18,18,32)/255.\n#define BarLight vec3(10,10,25)/255.\n#define BarDark vec3(4,4,10)/255.\n\n#define SeatsLight vec3(3,46,43)/255.\n#define SeatsDark vec3(1,34,35)/255.\n\n#define FacelessTris vec3(135,60,67)/255.\n#define FacelessDark vec3(15)/255.\n#define FacelessLight vec3(238)/255.\n\n// ---------------------------------------------------------------\n// Utilities.\n// ---------------------------------------------------------------\n\n\nfloat sdCircle(vec2 uv, vec2 pos, float r){\n    \n    float c = distance(uv, pos);\n    return step(c, r);\n   \n}\n\nfloat sdBox(vec2 uv, vec2 pos, float width, float height) {\n\tfloat t = 0.0;\n\tif ((uv.x > pos.x - width / 2.0) && (uv.x < pos.x + width / 2.0)\n\t\t&& (uv.y > pos.y - height / 2.0) && (uv.y < pos.y + height / 2.0)) {\n\t\tt = 1.0;\n\t}\n\treturn t;\n}\n\nfloat triSDF( in vec2 st)\n{\n    st = (st*2.0-1.0)*2.0;\n    return max(abs(st.x)*0.866025 + st.y *0.5, -st.y*0.5);\n}\n\n\nfloat stroke(float x, float s, float w){\n    float d = step(s, x+w*.5) - step(s, x-w*.5);\n    return clamp(d, 0., 1.);\n}\n\nconst float PI = 3.14;\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float sine = sin(angle), cosine = cos(angle);\n    return mat2( cosine, -sine, \n                 sine,    cosine );\n}\n\n\n//2D Sdf from Inigo Quilez\n//https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// ---------------------------------------------------------------\n// Sky.\n// ---------------------------------------------------------------\n\n// ---------------- Sky Gradient. ---------------------\n\nvec3 skyGradient(float y){ \n\n    // colors\n    vec3 colors[4];\n    colors[0] = vec3(156,202,223)/255.;\n    colors[1] = vec3(90,184,218)/255.;\n    colors[2] = vec3(54,167,206)/255.;\n\n    //position\n    float steps[3];\n    steps[0] = 0.01;\n\tsteps[1] = 0.35;\n    steps[2] = 0.97;\n    \n    vec3 out_color = colors[0];\n    for (int i = 1; i < 3; i++){\n        out_color = mix(out_color, colors[i], smoothstep(steps[i-1], steps[i]+0.05, y));\n    }\n    \n    return out_color;\n}\n\n\n// ---------------- Clouds. ---------------------\n// ----------------cloud type1 mask\nfloat cloud1(vec2 uv, float scale, vec2 pos){\n    \n    uv /= scale; \n    uv -= pos;\n    \n    vec2 uv_c1 = uv;    \n    uv_c1.x *= iResolution.x/iResolution.y;    \n    \n    float col = sdCircle(uv_c1, vec2(0.6, 0.5), 0.18);    \n    col = max(col,sdCircle(uv_c1, vec2(0.72, 0.68), 0.13));\n    col = max(col,sdCircle(uv_c1, vec2(0.8, 0.48), 0.15));\n    col = max(col,sdCircle(uv_c1, vec2(0.98, 0.48), 0.15));\n    col = max(col,sdCircle(uv_c1, vec2(0.90, 0.65), 0.10));\n    \n    float rect = sdBox(uv, vec2(0.45,0.65), 0.54, 0.41);\n    col *= rect;\n \n    return col;\n       \n}\n\n// ----------------cloud type2 mask\nfloat cloud2(vec2 uv, float scale, vec2 pos){\n    \n    uv /= scale; \n    uv -= pos;\n    \n    vec2 uv_c1 = uv;    \n    uv_c1.x *= iResolution.x/iResolution.y;    \n    \n    float col = sdCircle(uv_c1, vec2(0.6, 0.5), 0.12);    \n    col = max(col,sdCircle(uv_c1, vec2(0.75, 0.59), 0.15));\n    col = max(col,sdCircle(uv_c1, vec2(0.73, 0.48), 0.15));\n    col = max(col,sdCircle(uv_c1, vec2(0.94, 0.61), 0.14));\n    col = max(col,sdCircle(uv_c1, vec2(0.92, 0.46), 0.18));\n    col = max(col,sdCircle(uv_c1, vec2(1.07, 0.48), 0.11));\n    \n    float rect = sdBox(uv, vec2(0.45,0.65), 0.54, 0.47);\n    col *= rect;\n    \n    //return vec3(uv, 1.0);\n    return col;\n   \n}\n\n// ----------------cloud type3 mask\nfloat cloud3(vec2 uv, float scale, vec2 pos){\n    \n    uv /= scale; \n    uv -= pos;\n    \n    vec2 uv_c1 = uv;    \n    uv_c1.x *= iResolution.x/iResolution.y;   \n    \n    float col = sdCircle(uv_c1, vec2(0.6, 0.5), 0.16);    \n    col = max(col,sdCircle(uv_c1, vec2(0.77, 0.44), 0.14));\n    \n    float rect = sdBox(uv, vec2(0.45,0.65), 0.54, 0.47);\n    col *= rect;\n    \n    //return vec3(uv, 1.0);\n    return col;\n\n}\n\n// ---------------- Seats. ---------------------\nvec3 seatsGradient(float y){ \n\n    // colors\n    vec3 colors[4];\n    colors[0] = SeatsDark;\n    colors[1] = SeatsLight;\n    colors[2] = SeatsLight;\n    colors[3] = SeatsDark;\n\n    //position\n    float steps[4];\n    steps[0] = 0.0;\n\tsteps[1] = 0.45;\n    steps[2] = 0.55;\n    steps[3] = 1.0;\n    \n    vec3 out_color =  colors[0];\n    for (int i = 1; i < 4; i++){\n        out_color = mix(out_color, colors[i], smoothstep(steps[i-1], steps[i]+0.05, y));\n    }\n    \n    return out_color;\n}\n\n// ---------------------------------------------------------------\n// Main.\n// ---------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float t = iTime*0.1;\n    \n    // ___ SKY ___\n    vec3 sky = skyGradient(uv.y);\n    \n    // ___ MOUNTAINS ___\n    \n    // --1\n    vec2 uv_m1 = uv * 12.0 ;\n    uv_m1.x += 6.2+t*1.3;  \n    float m1 = step(uv_m1.y -9.3 +sin(uv_m1.x*1.2)*0.55 + (cos(uv_m1.x*0.95)*0.7) + (sin(uv_m1.x*4.8)*0.07), 0.);\n    \n    vec3 m1_col = mix(MountainLayerOneLight,MountainLayerOneDark, smoothstep(0.0, 0.79, uv.y));\n    vec3 col = mix(sky, m1_col, m1);\n    \n    // --2\n    vec2 uv_m2 = uv * 5.0 ;\n    uv_m2.x += 18.+t*0.7;  \n    float m2 = step(uv_m2.y -3.0 +(sin(uv_m2.x*1.2)*0.8) + (cos(uv_m2.x*2.6)*0.3)+ (cos(uv_m2.x*6.2)*0.08), 0.);    \n  \n    vec3 m2_col = mix(MountainLayerTwoLight,MountainLayerTwoDark, smoothstep(0.0, 0.79, uv.y));\n    col = mix(col, m2_col, m2);\n    \n    \n    // --3\n    vec2 uv_m3 = uv * 12.0 ;\n    uv_m3.x += 4.+t*3.1;  \n    float m3 = step(uv_m3.y+sin(uv_m3.x*0.8)-7.0 + (cos(uv_m3.x*1.8+1.)*0.5) + (sin(uv_m3.x*3.8)*0.2), 0.);\n    \n    vec3 m3_col = mix(MountainLayerThreeLight,MountainLayerThreeDark, smoothstep(0.0, 0.79, uv.y));\n    col = mix(col, m3_col, m3);\n\n\n    // ___ OCEAN ___\n    vec3 ocean = 1.0-vec3(step( 0.52, uv.y));\n    vec3 ocean_col = mix(OceanLight,OceanDark, smoothstep(0.36, 0.5, uv.y));\n    col = mix(col, ocean_col, ocean);\n    \n    // ___ CLOUDS ___\n    vec3 c_colo =mix(CloudsDark,CloudsLight, smoothstep(0.35, 0.65, uv.y));;\n\n    float cloud1 = cloud1(uv, 0.3, vec2(-1.0+fract(-t*0.60)*6.0,1.5));\n    col = mix(col, c_colo,cloud1);\n    \n    float cloud2 = cloud2(uv, 0.5, vec2(-1.0+fract(0.5-t*0.41)*3.0, 0.65));\n    col = mix(col, c_colo,cloud2);\n\n    vec2 uv_mirrored = vec2(1.0 -uv.x, uv.y);\n    float cloud4 = cloud3(uv_mirrored, 0.4, vec2(-1.0+fract(0.1+t*0.85)*3.5, 1.25));\n    col = mix(col, c_colo,cloud4);\n\n    float cloud3 = cloud3(uv, 0.5, vec2(-1.0+fract(0.15-t*0.5)*3.5, 0.68));\n    col = mix(col, c_colo,cloud3);\n\n    // ___ LAMP POST ___\n    float lamp_post = sdBox(uv, vec2(-2.+fract(-t*0.8)*13.0,0.5), 0.06, 1.0);\n    vec3 lamp_col = mix(LampPostDark,LampPostLight, smoothstep(0.0, 1., uv.y));\n    col = mix(col, lamp_col, lamp_post);\n    \n    // ___ RED BRIDGE ___\n    vec3 bridge_col = mix(BridgeDark,BridgeLight, smoothstep(0.0, 1., uv.y));\n\n    vec2 uv_setup = uv*2.0-1.;\n    uv_setup.y *= 0.5;\n    uv_setup.y += 0.9;\n    uv_setup.x += -10. + fract(t*.8)*38.0;\n    float k = stroke(length(uv_setup), 1.4, .16);\n    col = mix(col, bridge_col, k);\n    float mask_b = step(length(uv_setup), 1.4);\n\n    float uv_mouv_x = uv.x + fract(t*.8)*18.0;\n    vec2 uv_b = vec2(uv_mouv_x, uv.y)*rotationMatrix(20.);\n    vec2 uv_bridge_line = vec2(fract(0.25+uv_b.x*5.0), uv_b.y);\n    float bridge_rect = sdBox(uv_bridge_line, vec2(0.5,0.6), 0.45,10.5);\n    float bridge_lines = bridge_rect * mask_b; \n    col = mix(col, bridge_col, bridge_lines);\n        \n    \n    // ___ TRAIN ___\n    //global mask\n    vec2 uv_base_t = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float window_y_shift = 0.2;\n    float window_h = 0.5;    \n    float window_w = 0.65;\n\n    vec2 uv_t1 = vec2(uv_base_t.x, uv_base_t.y-window_y_shift);\n    vec2 uv_t2 = vec2(uv_base_t.x-1.5, uv_base_t.y-window_y_shift);\n    vec2 uv_t3 = vec2(uv_base_t.x+1.5, uv_base_t.y-window_y_shift);\n\n    float windows = 1.0 - smoothstep(0.0, 0.01, sdRoundBox(uv_t1, vec2(window_w, window_h), vec4(0.15,0.04,0.15,0.04)));\n    windows += 1.0 - smoothstep(0.0, 0.01, sdRoundBox(uv_t2, vec2(window_w, window_h), vec4(0.15,0.04,0.15,0.04)));\n    windows += 1.0 - smoothstep(0.0, 0.01, sdRoundBox(uv_t3, vec2(window_w, window_h), vec4(0.15,0.04,0.15,0.04)));\n    windows *= 1.0 - sdBox(uv, vec2(0.0,0.72), 10., 0.02);\n    \n    vec3 bg_train_col = mix(TrainBgDark,TrainBgLight, smoothstep(0.0, 1., uv.y));\n    vec3 col_train = bg_train_col * 1.0-windows;\n    \n    //seats\n    vec2 uv_s = vec2(fract(0.3+uv.x*5.0), uv.y-0.2);\n    float mask_seats = sdBox(uv, vec2(0.0,0.04), 10., 0.5);\n    \n    //formula from up in the cloud sea by mdb\n    //https://www.shadertoy.com/view/Ndc3zl\n    mask_seats *= min(step(1.0, uv_s.y)\n           + smoothstep(-0.09, -0.088, -uv_s.y - 0.0023/(1.0 - abs(uv_s.x*2.0 - 1.0))), 1.0);\n       \n    col_train = mix(col_train, seatsGradient(uv_s.x),mask_seats);\n    \n    //handles\n    vec2 uv_h = vec2(fract(0.55+uv.x*6.0), -1.75+uv.y*2.8);\n    float mask_handles = stroke(triSDF(uv_h),0.2,0.1);\n    mask_handles = max(mask_handles,sdBox(uv_h,vec2(0.5,0.98),0.06,0.8));\n\n    vec3 handles_col = Handles;\n    col_train = mix(col_train, handles_col, mask_handles);\n\n    //bar\n    vec2 uv_temp = uv*1.8;\n    vec2 uv_bar = vec2(fract(0.93+uv_temp.x*0.8), uv_temp.y);\n    float mask_bar = sdBox(uv_bar, vec2(0.2,0.6), 0.045,5.5);\n    vec3 bar_col = mix(BarDark, BarLight, smoothstep(0.0, 1., uv.y));\n    col_train = mix(col_train, bar_col, mask_bar);\n    \n    col_train += pow((texture(iChannel0,uv*1.6)).x ,1.)*0.06;\n    \n    float global_mask = max( 1.0-windows, max(mask_bar, max(mask_handles,mask_seats)));\n    \n    col = mix(col, col_train, global_mask);\n    \n    \n    // ___ FACELESS ___\n    \n    //body \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 uv_body_pos = vec2(0.215+p.x, 0.9-p.y);\n    float body_mask = smoothstep(0.26,0.25,sdTriangleIsosceles(uv_body_pos+vec2(0.0,-1.0), vec2(0.12,0.9)));\n    vec3 body_color= FacelessDark;\n    vec3 faceless =  body_mask * body_color; \n    \n    //head\n    vec2 uv_head_pos = vec2(0.2155+p.x, 0.18+p.y);\n    float head_mask =  1.0 - smoothstep(0.0, 0.01, sdRoundBox(uv_head_pos, vec2(0.18, 0.25), vec4(0.18,0.18,0.18,0.18)));;\n    vec3 head_color= FacelessLight;\n    faceless =  mix(faceless, head_color, head_mask); \n    \n    //eyes and mouth \n    vec3 face_color= FacelessDark;\n    vec2 uv_eye1_pos = vec2(0.3+p.x,0.14+p.y);\n    float face_mask =  1.0 - smoothstep(0.0, 0.01, sdRoundBox(uv_eye1_pos, vec2(0.03, 0.015), vec4(0.015,0.015,0.015,0.015)));;\n    vec2 uv_eye2_pos = vec2(0.13+p.x,0.14+p.y);\n    face_mask += 1.0 - smoothstep(0.0, 0.01, sdRoundBox(uv_eye2_pos, vec2(0.03, 0.015), vec4(0.015,0.015,0.015,0.015)));;\n    vec2 uv_mouth_pos = vec2(0.215+p.x,0.33+p.y);\n    face_mask += 1.0 - smoothstep(0.0, 0.01, sdRoundBox(uv_mouth_pos, vec2(0.028, 0.007), vec4(0.007,0.007,0.007,0.007)));;\n\n    faceless =  mix(faceless, face_color, face_mask); \n\n    //red tris\n    vec3 tris_color= FacelessTris;\n    vec2 uv_tri1_pos = vec2(0.3+p.x, 1.28+p.y);\n    float tris_mask = smoothstep(0.01,0.002,sdTriangleIsosceles(uv_tri1_pos+vec2(0.0,-1.0), vec2(0.02,0.1)));\n    vec2 uv_tri2_pos = vec2(0.13+p.x, 1.28+p.y);\n    tris_mask += smoothstep(0.01,0.002,sdTriangleIsosceles(uv_tri2_pos+vec2(0.0,-1.0), vec2(0.02,0.1)));\n    vec2 uv_tri3_pos = vec2(0.13+p.x, 0.97-p.y);\n    tris_mask += smoothstep(0.01,0.002,sdTriangleIsosceles(uv_tri3_pos+vec2(0.0,-1.0), vec2(0.02,0.07)));\n    vec2 uv_tri4_pos = vec2(0.3+p.x, 0.97-p.y);\n    tris_mask += smoothstep(0.01,0.002,sdTriangleIsosceles(uv_tri4_pos+vec2(0.0,-1.0), vec2(0.02,0.07)));\n  \n    faceless =  mix(faceless, tris_color, tris_mask);\n    faceless += pow((texture(iChannel0,uv*1.6)).x ,1.)*0.04;\n    col = mix(col, faceless, body_mask);\n    \n    // Output to screen\n    //col += pow((texture(iChannel0,uv*1.6)).x ,1.)*0.09;\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}