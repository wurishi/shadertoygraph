{"ver":"0.1","info":{"id":"MsjcRy","date":"1492650696","viewed":203,"name":"more raymarch thang","username":"rytone","description":"oh boy infinity","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarch","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float blur_kern(vec2 pos) {\n    return clamp(1.0-pow(length(pos), 5.0), 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 in_raw = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec3  color = in_raw.rgb;\n    float depth = (1.0/in_raw.w)-1.0;\n    \n    float aperture = focal_length/f_number;\n    float coc = abs(aperture * (focal_length * (depth - plane_in_focus)) / (depth * (plane_in_focus - focal_length)));\n    float blur_radius = (coc / sensor_height);\n    int blur_samp_radius = min(5, int(ceil(blur_radius)));\n    \n    vec3 color_acc   = vec3(0);\n    float sample_acc = 0.;\n    for (float y = -1.; y <= 1.; y += 1.0/float(blur_samp_radius)) {\n        for (float x = -1.; x <= 1.; x += 1.0/float(blur_samp_radius)) {\n            float x_ofs = blur_radius * x;\n            float y_ofs = blur_radius * y;\n            vec2  pos   = vec2(x_ofs, y_ofs);\n            \n            float kern  = blur_kern(vec2(x,y));\n            color_acc  += kern * texture(iChannel0, (fragCoord+pos)/iResolution.xy).rgb, 1.0/2.2;\n            sample_acc += kern;\n        }\n    }\n    \n    fragColor = vec4(color_acc/sample_acc, 1.0);\n    fragColor.rgb *= vec3(1.0 - length(fragCoord/iResolution.xy - vec2(0.5)) * 0.8 + 0.3);\n    fragColor = vec4(texture(iChannel1, fragCoord/iResolution.xy));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPSILON 0.001\n#define FAR 32.0\n#define MAX_STEPS 64\n#define PI 3.14159265359\n#define DEG_TO_RAD (PI / 180.0)\n#define RAD_TO_DEG (180.0 / PI)\n\nfloat prim_sphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat prim_box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat map(vec3 p_o) {   \n    vec3 p = mod(p_o, 4.0) - 2.0;\n    \n    float center_box = prim_box(p, vec3(0.5, 0.5, 0.5));\n    float cross_1 = prim_box(p, vec3(2.0, 0.1, 0.1));\n    float cross_2 = prim_box(p, vec3(0.1, 2.0, 0.1));\n    float cross_3 = prim_box(p, vec3(0.1, 0.1, 2.0));\n    \n    float final = FAR;\n    final = min(final, center_box);\n    final = min(final, cross_1);\n    final = min(final, cross_2);\n    final = min(final, cross_3);\n    \n    pR(p_o.xy, 65.);\n    pR(p_o.yz, 40.);\n    pR(p_o.zx, 115.);\n    vec3 p2 = mod(p_o, 2.0) - 1.0;\n    final = min(final, prim_sphere(p2, 0.05));\n    \n    return final;\n}\n\nfloat march_map(vec3 eye, vec3 dir) {\n    float depth = 0.0;\n    vec3 pos = eye;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        float d = map(pos);\n        depth += d;\n        pos += dir * d;\n        \n        if (d < EPSILON) {\n            break;\n        }\n        \n        if (d >= FAR) {\n            return FAR;\n        }\n    }\n    \n    return depth;\n}\n\nvec3 map_grad(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 dir_from_fov(float fov, vec2 pos, vec2 res) {\n\tvec2 xy = pos - res * 0.5;\n\n\tfloat cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\t\n\tfloat z = res.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\nmat3 look_at(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    ///////////////////////////\n    \n    vec3 eye = vec3(sin(iTime * 0.2) * 5.0, -iTime * 3.0, sin(iTime * 0.3) * 5.0);\n    vec3 look = vec3(sin(iTime/5.0), sin(iTime*0.1)*(FAR/10.0) - 4.0, cos(iTime/5.0));\n    vec3 light = eye + vec3(sin(iTime * 3.0) * 5.0, -10.0, cos(iTime * 2.4) * 8.0);\n    \n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    vec3 ambient = vec3(0.05, 0.05, 0.05);\n    \n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    \n    ///////////////////////////\n    \n    \n    look = eye + look;\n    float fov = 2.0*atan(sensor_height/(2.0*focal_length)) * RAD_TO_DEG;\n    vec3 dir = dir_from_fov(fov, fragCoord, iResolution.xy);\n    mat3 view = look_at(eye, look, vec3(0, 1, 0));\n    dir = view * dir;\n    \n    float depth = march_map(eye, dir);\n    if (depth >= FAR) {\n        fragColor = vec4(bg, 1.0/(depth + 1.0));\n    } else {\n        vec3 hit_pos = eye + dir * depth;\n        vec3 nrm = map_grad(hit_pos);\n        vec3 to_light = normalize(light - hit_pos);\n        \n        float light_dist = 1.0 - min(length(light - hit_pos) / 25.0, 1.0);\n        float light_amnt = dot(nrm, to_light) * light_dist;\n        \n        float v =  1.0 - depth / FAR;\n        \n        \n        ///////////////////////////\n        \n        vec3 surf_color = hsv2rgb(vec3(v / 2.5 + 0.6 + iTime * 0.05, 0.5, 0.9));\n        \n        ///////////////////////////\n        \n        \n        surf_color = mix(surf_color, light_color, light_amnt);\n        surf_color = mix(ambient, surf_color, light_dist);\n        surf_color = mix(bg, surf_color, v);\n        \n        fragColor = vec4(surf_color, 1.0/(depth + 1.0));\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// in-focus plane\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 in_raw = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec3  color = in_raw.rgb;\n    float depth = (1.0/in_raw.w)-1.0;\n    \n    if (depth >= plane_in_focus - focus_plane_r && depth <= plane_in_focus + focus_plane_r) {\n        fragColor = vec4(color, 1.0);\n    } else {\n    \tfragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// far plane\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 in_raw = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec3  color = in_raw.rgb;\n    float depth = (1.0/in_raw.w)-1.0;\n    \n    if (depth > plane_in_focus + focus_plane_r) {\n        fragColor = vec4(color, 1.0);\n    } else {\n    \tfragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// near plane\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 in_raw = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec3  color = in_raw.rgb;\n    float depth = (1.0/in_raw.w)-1.0;\n    \n    if (depth < plane_in_focus - focus_plane_r) {\n        fragColor = vec4(color, 1.0);\n    } else {\n    \tfragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float sensor_height = 18.0;\nfloat focal_length = 35.0;\n\nfloat f_number = 0.3;\n\nfloat plane_in_focus = 10.0;\nfloat focus_plane_r = 3.0;","name":"Common","description":"","type":"common"}]}