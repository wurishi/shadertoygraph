{"ver":"0.1","info":{"id":"cttcz7","date":"1699647718","viewed":11,"name":"drici.mohamed-islam","username":"dricislam","description":"Spheres","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["spherestp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\n\nstruct Ellipsoide{\n    vec3 e; //centre\n    vec3 a; \n    vec3 b;\n    vec3 c;\n    int i; //TextureID\n};\nstruct Cylindre{\n    vec3 a,b;// \n    float r;// Radius\n    int i;// Texture Id\n\n};\nstruct Cylinder {\n    vec3 c;     // Center of the base\n    float r;    // Radius\n    float h;    // Height\n    int i;      // Texture Id\n};\nstruct Box {\n    vec3 min; // Coin minimum de la boîte (coin le plus proche de l'origine)\n    vec3 max; // Coin maximum de la boîte (coin le plus éloigné de l'origine)\n    int i;    // Identifiant de texture\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n};\n\nstruct LightAttribs\n{\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nstruct MaterialPhong\n{\n\tLightAttribs attribs;\n\tfloat shininess;\n\n\tfloat reflectedFactor;\n};\n\nstruct DirectionalLight\n{\n\tvec3 direction;\n\tLightAttribs attribs;\n};\n\nstruct PointLight\n{\n\tvec3 position;\n\tLightAttribs attribs;\n\tfloat attenuationFactor;\n};\n\n// Scene lights\nint directionalLightsNumber = 1;\nDirectionalLight directionalLight[1];\nint pointLightsNumber = 1;\nPointLight pointLight[1];\n\n// Camera\nvec3 viewDirection;\n\n// Materials\nMaterialPhong matPhongGround = MaterialPhong\n(\n\tLightAttribs\n    (\n        vec3(0.0, .0, .0),\n        vec3(.0, .0, .0),\n        vec3(.0, .0, .0)\n    ),\n\tfloat(64.0),\n\t0.0\n);\nMaterialPhong matPhong1 = MaterialPhong\n(\n    LightAttribs\n    (\n        vec3(4, 27, 64) / 255.0,\n        vec3(121, 81, 148) / 255.0,\n        vec3(215, 185, 235) / 255.0\n    ),\n\tfloat(4.0),\n\t0.0\n);\nMaterialPhong matPhong2 = MaterialPhong\n(\n    LightAttribs\n    (\n        vec3(79, 4, 1) / 255.0,\n        vec3(168, 133, 56) / 255.0,\n        vec3(212, 194, 155) / 255.0\n    ),\n\tfloat(4.0),\n\t0.5\n);\nMaterialPhong matPhongMirror = MaterialPhong\n(\n    LightAttribs\n    (\n        vec3(0, 0, 0) / 255.0,\n        vec3(0, 0, 0) / 255.0,\n        vec3(0, 0, 0) / 255.0\n    ),\n\tfloat(4.0),\n\t1.0\n);\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Hemisphere direction\n// seed : Integer seed, from 0 to N\n//    n : Direction of the hemisphere\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n    \n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arccosine distribution to compensate at poles\n    \n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n    if(dot(d,n)<0.){d=-d;}// Hemisphere\n    \n    return d;\n}\n\n// Compute point on ray\n// ray : The ray\n//   t : Distance\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\n/**\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return Material(vec3(.8,.5,.4));\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col);\n    }\n    return Material(vec3(0));\n}\n**/\n// Compute phong material\n// i : index of Phong material\nMaterialPhong PhongId(int i, vec3 point)\n{\n\tswitch (i)\n\t{\n\tcase 0:\n        // Compute checkboard\n        float f = Checkers(.5 * point.xy);\n        vec3 col = vec3(0.4, 0.5, 0.7) + f * vec3(0.1);\n        \n        // Create a MaterialPhong with the computed color\n        MaterialPhong matPhong;\n        matPhong.attribs.ambiant = vec3(.0);  \n        matPhong.attribs.diffuse = col;\n        matPhong.attribs.specular = vec3(0.2);\n        matPhong.shininess = 0.2; \n        matPhong.reflectedFactor = 0.0;  \n        \n        return matPhong;\n\t\tbreak;\n\tcase 1:\n        return matPhong1;\n\t\tbreak;\n    case 2:\n        return matPhongMirror;\n        break;\n    case 3:\n        return matPhong2;\n        break;\n\tdefault:\n\t\treturn matPhongGround;\n\t\tbreak;\n\t}\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n    \n}\n\nbool IntersectBox(Ray ray, Box box, out Hit hit) {\n    // Calculate the intersection distances along each axis\n    vec3 invDir = 1.0 / ray.d;\n    vec3 t1 = (box.min - ray.o) * invDir;\n    vec3 t2 = (box.max - ray.o) * invDir;\n\n    // Find the intersections for the near and far planes\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n\n    // Find the largest tmin and the smallest tmax\n    float near = max(max(tmin.x, tmin.y), tmin.z);\n    float far = min(min(tmax.x, tmax.y), tmax.z);\n\n    if (near <= far && far >= 0.0) {\n        // The ray intersects the box\n\n        // Calculate the intersection point\n        vec3 intersectionPoint = ray.o + ray.d * near;\n\n        // Calculate the normal at the intersection point\n        vec3 normal = vec3(0.0);\n\n        if (abs(intersectionPoint.x - box.max.x) < 0.001) normal = vec3(1.0, 0.0, 0.0);\n        else if (abs(intersectionPoint.x - box.min.x) < 0.001) normal = vec3(1.0, 0.0, 0.0);\n        else if (abs(intersectionPoint.y - box.max.y) < 0.001) normal = vec3(0.0, 1.0, 0.0);\n        else if (abs(intersectionPoint.y - box.min.y) < 0.001) normal = vec3(0.0, -1.0, 0.0);\n        else if (abs(intersectionPoint.z - box.max.z) < 0.001) normal = vec3(0.0, 0.0, 1.0);\n        else if (abs(intersectionPoint.z - box.min.z) < 0.001) normal = vec3(0.0, 0.0, -1.0);\n\n        hit.t = near;\n        hit.n = normal;\n        hit.i = box.i;\n\n        return true;\n    }\n\n    return false;\n}\n\n\nbool IntersectEllipsoid(Ray ray,Ellipsoide el,out Hit x)\n\n{ \n\n  float dx=ray.d.x;\n  float dy=ray.d.y;\n  float dz=ray.d.z;\n  \n  float a=((dx*dx)/dot(el.a,el.a)) + ((dy*dy)/dot(el.b,el.b)) + ((dz*dz)/dot(el.c,el.c));\n  float b=2.0*(dx*((ray.o.x-el.e.x)/dot(el.a,el.a)) + dy*((ray.o.y-el.e.y)/dot(el.b,el.b)) + dz*((ray.o.z-el.e.z)/dot(el.c,el.c)));\n  float c=((ray.o.x-el.e.x)*(ray.o.x-el.e.x)/dot(el.a,el.a)) + ((ray.o.y-el.e.y)*(ray.o.y-el.e.y)/dot(el.b,el.b)) + ((ray.o.z-el.e.z)*(ray.o.z-el.e.z)/dot(el.c,el.c))-1.0;\n  \n  float d= b*b -4.0*a*c;\n  \n  if (d>0.)\n  \n  {\n      float t1=(-b - sqrt(d))/(2.0*a);\n      float t2=(-b + sqrt(d))/(2.0*a);\n      if (t1>0.)\n     {   vec3 p=Point(ray,t1);\n         x=Hit(t1,p-el.e,el.i);\n         return true;\n     }\n     else if (t2<0.) \n     {return false;}\n     else\n     {   vec3 p=Point(ray,t2);\n         x=Hit(t2,p-el.e,el.i);\n     }\n   }\n   \n   return false;\n   \n}\n\n\nbool IntersectCylinder(Ray ray, Cylindre cyl, out Hit x)\n{\n    vec3 oc = ray.o - cyl.a;\n    vec3 ab = cyl.b - cyl.a;\n    \n    float ab2 = dot(ab, ab);\n    float aboc = dot(ab, oc);\n    float a = dot(ray.d, ray.d) - dot(ray.d, ab) * dot(ray.d, ab) / ab2;\n    float b = 2.0 * (dot(ray.d, oc) - dot(ray.d, ab) * dot(oc, ab) / ab2);\n    float c = dot(oc, oc) - dot(oc, ab) * dot(oc, ab) / ab2 - cyl.r * cyl.r;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant >= 0.0)\n    {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        \n        float t = min(t1, t2);\n        \n        if (t > 0.0)\n        {\n            vec3 p = ray.o + ray.d * t;\n            float h = dot(p - cyl.a, ab) / ab2;\n            \n            if (h >= 0.0 && h <= 1.0 )\n            {\n                vec3 n = normalize(p - (cyl.a + ab * h));\n                x = Hit(t, n, cyl.i);\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nbool IntersectCylinder1(Ray ray, Cylinder cyl, out Hit x) {\n    float tmin = 1000.0;\n    vec3 normal;\n    vec3 ro = ray.o - cyl.c;\n    vec3 rd = ray.d;\n\n    // Intersection with the tube\n    float a = rd.x * rd.x + rd.y * rd.y;\n    float b = 2.0 * (rd.x * ro.x + rd.y * ro.y);\n    float c = ro.x * ro.x + ro.y * ro.y - cyl.r * cyl.r;\n\n    float det = b*b - 4.0*a*c;\n\n    if (det > 0.0) {\n        float sqrt_det = sqrt(det);\n        float t1 = (-b - sqrt_det) / (2.0 * a);\n        float t2 = (-b + sqrt_det) / (2.0 * a);\n\n        // Check if t1 is a valid intersection\n        float z1 = ro.z + t1 * rd.z;\n        if (t1 > 0.0 && z1 >= 0.0 && z1 <= cyl.h) {\n            tmin = t1;\n            normal = normalize(vec3(ro.x + t1 * rd.x, ro.y + t1 * rd.y, 0.0));\n        }\n\n        // Check if t2 is a valid intersection\n        float z2 = ro.z + t2 * rd.z;\n        if (t2 > 0.0 && z2 >= 0.0 && z2 <= cyl.h) {\n            if (t2 < tmin) {\n                tmin = t2;\n                normal = normalize(vec3(ro.x + t2 * rd.x, ro.y + t2 * rd.y, 0.0));\n            }\n        }\n    }\n\n    // Intersection with the caps\n    for (float sign = 1.0; sign >= -1.0; sign -= 2.0) {\n        float t = (sign * cyl.h - ro.z) / rd.z;\n        vec3 p = ro + t * rd;\n        if (t > 0.0 && dot(p, p) <= cyl.r * cyl.r) {\n            if (t < tmin) {\n                tmin = t;\n                normal = vec3(0.0, 0.0, sign);\n            }\n        }\n    }\n\n    if (tmin < 1000.0) {\n        x = Hit(tmin, normal, cyl.i);\n        return true;\n    }\n    return false;\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(5.,0.,2.),1.,1);\n    const Sphere sph2=Sphere(vec3(0.,4.,2.),1.,2);\n    const Sphere sph3=Sphere(vec3(0.,-4.,2.),1.,3);\n    const Sphere sph4=Sphere(vec3(0.,8.,2.),1.,0);\n    const Box box1 = Box(vec3(-1.0, 4.0, 4.0), vec3(0.0, 5.0, 5.0), 1);\n    const Ellipsoide el1=Ellipsoide(vec3(-5.,1.,5),vec3(2.,0.,0.),vec3(0.,2.,1.),vec3(0.,3.,0.),3);\n    const Sphere sph6=Sphere(vec3(1.,3.,3.),0.5,1);\n    const Sphere sph5=Sphere(vec3(5.,3.,4.),0.5,1);\n    const Cylindre cyl = Cylindre(vec3(1., 3., 3.), vec3(5., 3., 4.), 0.5, 1);\n    const Cylinder cyl2 = Cylinder(vec3(5., 0., 3.9), 1., 3.0, 1);\n    \n    \n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph3,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray,sph4,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if (IntersectBox(ray, box1, current) && current.t < x.t) {\n    x = current;\n    ret = true;\n    }\n    if (IntersectEllipsoid(ray,el1,current)&& current.t < x.t) {\n    x = current;\n    ret = true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph6,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph5,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }if (IntersectCylinder(ray, cyl, current) && current.t < x.t) {\n    x = current;\n    ret = true;\n    }\n    if(IntersectCylinder1(ray, cyl2, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    } \n    \n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\nvec3 Color(Material m,vec3 n)\n{\n    vec3 light=normalize(vec3(1,1,1));\n    \n    float diff=clamp(dot(n,light),0.,1.);\n    vec3 col=m.d*diff+vec3(.2,.2,.2);\n    return col;\n}\n\nvec3 getDiffuse(vec3 matDiffuse, vec3 lightDiffuse, vec3 normal, vec3 lightDirection)\n{\n\treturn vec3(matDiffuse * lightDiffuse * max(dot(normal, lightDirection), 0.0));\n}\n\nvec3 getSpecular(vec3 matSpecular, float matShininess, vec3 lightSpecular, vec3 normal, vec3 lightDirection)\n{\n\tvec3 reflectedLight = reflect(lightDirection, normal);\n\tfloat specularFactor = pow(max(dot(reflectedLight, viewDirection), 0.0), matShininess);\n\treturn vec3(matSpecular * lightSpecular * specularFactor);\n}\n\nvec3 Phong(MaterialPhong mat, LightAttribs lightAttribs, vec3 normal, vec3 lightDir)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    color += getDiffuse(mat.attribs.diffuse, lightAttribs.diffuse, normal, -lightDir);\n    color += getSpecular(mat.attribs.specular, mat.shininess, lightAttribs.specular, normal, -lightDir);\n    \n    return color;\n}\n\nvec3 getDirectionalLight(MaterialPhong mat, DirectionalLight light, vec3 normal)\n{\n    return Phong(mat, light.attribs, normal, light.direction);\n}\n\nvec3 phongPointLight(MaterialPhong mat, PointLight light, vec3 normal, vec3 pointPosition)\n{\n    vec3 lightToObject = pointPosition - light.position;\n        vec3 lightDir = normalize(lightToObject);\n    float attenuation = 1.0 / (light.attenuationFactor * dot(lightToObject, lightToObject));\n    LightAttribs attenuatedLightAttribs = light.attribs;\n    attenuatedLightAttribs.ambiant *= attenuation;\n    attenuatedLightAttribs.diffuse *= attenuation;\n    attenuatedLightAttribs.specular *= attenuation;\n    return Phong(mat, attenuatedLightAttribs, normal, lightDir);\n}\n\nvec3 getDirectionalLightAmbiantOnly(MaterialPhong mat, DirectionalLight light)\n{\n    return mat.attribs.ambiant* light.attribs.ambiant;\n}\n\nvec3 phongPointLightAmbiantOnly(MaterialPhong mat, PointLight light)\n{\n    return mat.attribs.ambiant* light.attribs.ambiant;\n}\n\nvec3 Color(MaterialPhong mat, Ray ray, Hit hit)\n{\n\tvec3 color = vec3(0, 0, 0);\n    \n    vec3 impactPoint = Point(ray, hit.t);\n    Ray pointToLightRay;\n    pointToLightRay.o = impactPoint + hit.n * 0.001;\n        \n    for (int i = 0; i < directionalLightsNumber; i++)\n    {\n        pointToLightRay.d = -directionalLight[i].direction;\n        Hit dummyHit;\n        \n        color += getDirectionalLightAmbiantOnly(mat, directionalLight[i]);\n        \n        if(Intersect(pointToLightRay, dummyHit))\n            continue;\n\n        color += getDirectionalLight(mat, directionalLight[i], hit.n);\n    }\n\n    for (int i = 0; i < pointLightsNumber; i++)\n    {\n        pointToLightRay.d = normalize(pointLight[i].position - impactPoint);\n        Hit dummyHit;\n        \n        color += phongPointLightAmbiantOnly(mat, pointLight[i]);\n        \n        if(Intersect(pointToLightRay, dummyHit))\n            continue;\n\n        color += phongPointLight(mat, pointLight[i], hit.n, impactPoint);\n    }\n\n\treturn color;\n}\n\n// Rendering\n//   ray : Ray\n// depth : Reflexion depth\nvec3 Shade(Ray ray, int depth)\n{\n    vec3 finalColor = vec3(0.0, 0.0, 0.0);\n    Hit hit;\n    vec3 impactPoint;\n    float reflexionFactor =1.;\n    \n    bool atLeastOneHit = true;\n    \n    for (int i = 0 ; i < depth ; i++)\n    {\n        if(!Intersect(ray, hit))\n        {\n            if (atLeastOneHit)\n                finalColor += Background(ray.d) * reflexionFactor;\n            break;\n        }\n        \n        atLeastOneHit = true;\n        impactPoint = Point(ray, hit.t);\n        MaterialPhong mat = PhongId(hit.i, impactPoint);\n        finalColor += Color(mat, ray, hit) * reflexionFactor;\n        \n        reflexionFactor *= mat.reflectedFactor;\n        ray.o = impactPoint;\n        ray.d = reflect(ray.d, hit.n);\n    }\n \n    return finalColor;\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n\tvec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n\n\t// Mouse control\n\tvec2 mouse = (vec2(1.0, 1.0) - iMouse.xy / iResolution.xy) * 2.;\n\n\t// Ray origin\n\tvec3 ro = 12. * normalize(vec3(sin(2. * 3.14 * mouse.x), cos(2. * 3.14 * mouse.x), 1.4 * (mouse.y - .1)));\n\tvec3 ta = vec3(0., 0., 1.5);\n\tmat3 ca = setCamera(ro, ta);\n\n\t// Ray\n\tvec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.5)), 1.));\n\n\t// Lights\n\tdirectionalLight[0] = DirectionalLight\n\t(\n\t\tnormalize(vec3(-1.0, 1.0, -1.0)),\n        LightAttribs\n        (\n            vec3(1.0, 1.0, 1.0),\n            vec3(1.0, 1.0, 1.0),\n            vec3(.0, .0, .0)\n        )\n\t);\n\tpointLight[0] = PointLight\n\t(\n\t\tvec3(0.0, 0.0, 10.0),\n        LightAttribs\n        (\n            vec3(1.0, 1.0, 1.0),\n            vec3(0.0, 0.0, 0.0),\n            vec3(0.0, 0.0, 0.0)\n        ),\n\t\tfloat(0.2)\n\t);\n\n\t// Render\n\tviewDirection = normalize(rd);\n\tvec3 col = Shade(Ray(ro, rd), 20);\n\n\tfragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}