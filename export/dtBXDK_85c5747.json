{"ver":"0.1","info":{"id":"dtBXDK","date":"1677644322","viewed":113,"name":"Slowly Scrolling Starfield","username":"Holywar20","description":"A Basic Starfield.\n\nInspired by this https://www.shadertoy.com/view/tlyGW3\nTutorial  https://youtu.be/rvDo9LvfoVE\n\nFrom @BigWing \n\nthough somewhat modified.\n\nthe vec2( t, t ) variable could be changed for a uniform. I wanted to make a scrolling starfield\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["space","stars","starfield","scrolling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LAYERS 6.0\n\nfloat hash21( vec2 id ){\n   id = fract( id * vec2( 123.34 , 456.21 ) );\n   id += dot( id , id + 45.321);\n   return fract( id.x * id.y );\n}\n \nmat2 rotate( float a ){\n    // Takes an angle in Radians\n    float s = sin(a);\n    float c = cos(a);\n    \n    // Returns a 2d Rotation Matrix\n    return mat2(c, -s , s , c);\n}\n \nfloat star( vec2 uv , float flare , float rand ){\n    // Simulating a light like shape\n    float d = length(uv);\n    float starLight = 0.02/d;\n \n    vec2 rotUv = uv * rotate( 3.1415 / 4.0 );\n    float rotRays = max( 0.0 , 1.0 - abs( rotUv.x * rotUv.y * 1000.0 ) ) * 0.05 * flare;\n    \n    float allLight =  starLight + rotRays;\n    \n    allLight *= smoothstep( 0.3 , 0.2 , d );\n    return max( allLight , 0.0 );\n}\n\nvec3 starLayer( vec2 uv , float layerSeed ){\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv);\n    \n    vec3 col = vec3( 0 );\n    \n    for( int y=-1; y<=1; y++ ) {\n        for( int x=-1; x<=1; x++ ) {\n            vec2 offset = vec2(x , y);\n            vec2 thisId = offset + id;\n            \n            float starRand = hash21( thisId + layerSeed );\n            float size = fract(starRand *405.32 );\n            vec2 starPos = gv - offset - vec2( sin(starRand * 12.3423) * 0.5 + 0.5 , fract( starRand * 90.123 ) ) + 0.5;\n            \n            float thisStar = star( starPos , smoothstep( .9 , 1.0, 1.0 ) , starRand  );\n            \n            vec3 color = sin( vec3(0.6 , 0.3 , 0.9) * fract( starRand * 2342.2 ) * 123.2 ) * 0.5 + 0.5;\n            color = max( color, vec3( 0.4 , 1.0 , 0.4 ) );\n            \n            color *= vec3(1.0 , 0.6 , 1.0 + size );\n            \n            col += thisStar * size * color;\n        }\n    }\n    \n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center UV coordinate\n    vec2 uv = ( fragCoord - 0.5 * iResolution.xy )/iResolution.y;\n    float t = iTime * 0.5;\n    \n    float distFade = 1.0;\n    vec3 col = vec3( 0 );\n    for( float x = 0.0; x<1.0; x += 1.0/LAYERS){\n        float depth = fract( x );\n        float fade = depth;\n        float scale = mix( 10.0 , 0.5 , depth );\n        float layerRand = hash21( vec2(scale , depth) ) ;\n        // Edit the vec2( sin .... ) param to change how the movement is done.\n        // Currently set up to rotate in a circle but this could be tweaked to\n        // go in any direction by adding the appropriate vector. \n        col += starLayer( uv * scale + vec2( sin(t * 0.1) * 15.0 , cos(t * 0.1) * 15.0 ) , layerRand ) * fade;\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}