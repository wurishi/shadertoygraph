{"ver":"0.1","info":{"id":"DdyXRh","date":"1680687876","viewed":27,"name":"morellej_3D","username":"morellej","description":"Rendu cours 3D pour le web","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//==================================== constantes =========================================\n#define TERRAIN 1\n#define EAU 3\n#define CIEL 4\n#define EPSILON 1e-4\n\n// CAMERA\n#define CAM_ROTATION_SPEED 0.05\n\n// SUN\n#define SUN_ROTATION_SPEED 0.3\n\n//COULEURS\n#define BLEU vec3(0.,0.,1.0)\n#define BLANC vec3(1.0,1.0,1.0)\n\n//génération\n#define TERRAIN_SEED 15.6\n#define NIVEAU_EAU 1.1\n\n// ===================================================\n// fonctions utiles\n// ===================================================\n\n// Représente un matériau avec une couleur et un type (Eau, Ciel)\nstruct material {\n    vec3 couleur;\n    int type;\n};\n\n// représente une caméra avec une origine (un vecteur de trois composantes) et des vecteurs w, u, et v qui représentent la direction du regard de la caméra et deux axes orthogonaux.\nstruct camera {\n    vec3 origine;\n    vec3 w;\n    vec3 u;\n    vec3 v;\n};\n\n// représente un rayon avec une origine et une direction\nstruct ray {\n    vec3 ori;\n    vec3 dir;\n};\n\n// fonction de hachage qui prend un vecteur 2D p en entrée et renvoie une valeur de hachage unique entre 0 et 1.\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// fonction qui renvoie une valeur de transition en douceur entre 1 et 0 en fonction d'une valeur t.\nfloat falloff(float t) {\n    float t2 = clamp(0.0, 1.0, abs(t));\n    return 1.0 - smoothstep(0.0, 1.0, t2);\n}\n\n// fonction qui crée des variations de hauteur dans une texture\nfloat bump(vec2 p, vec2 centre) {\n    vec2 decalage = p - centre;\n    float b = falloff(decalage.x) * falloff(decalage.y);\n\n    float v = 2. * hash12(centre) - 1.;\n    return v * b;\n}\n\n// La fonction snoise prend en entrée un vecteur 2D p et renvoie une valeur de bruit cohérente basée sur la valeur de \"bump\" calculée à partir de ce vecteur.\nfloat snoise(vec2 p) {\n    float resultat = 0.;\n    vec2 ll = floor(p);\n\n    resultat += bump(p, ll + vec2(0., 0.0));\n    resultat += bump(p, ll + vec2(1., 0.0));\n    resultat += bump(p, ll + vec2(1., 1.0));\n    resultat += bump(p, ll + vec2(0., 1.0));\n    return resultat;\n}\n\n// calcule la somme fractale du bruit de Perlin (utilisée pour créer le ciel nuageux)\nfloat somme_fractale(vec2 p, float octaves) {\n    float v = 0.0;\n    float w = 1.0;\n    for(float i = 0.; i < octaves; ++i, p *= 3., w *= .25) v += w * snoise(p);\n\n    return v;\n}\n\n// retourne un rayon (représenté par le struct ray) à partir d'une caméra (cam) et d'une coordonnée de pixel (uv).\nray getray(camera cam, vec2 uv) {\n    return ray(cam.origine, normalize(uv.x * cam.u + uv.y * cam.v + 1.5 * cam.w));\n}\n\n// point atteint par le rayon à cette distance t de son origine\nvec3 rayAt(ray r, float t) {\n    return r.ori + t * r.dir;\n}\n\n//--------- mouvement fractal brownien\n// https://www.shadertoy.com/view/4slGD4\n// - dave hoskins\nfloat bruit(in vec2 XY) {\n    return sin(XY.x) + cos(XY.y);\n}\n\n// ===================================================\n// fonctions de génération de terrain et d'eau\n// ===================================================\n\n// Cette fonction fbm (Fractal Brownian Motion) génère la hauteur du terrain en fonction des coordonnées UV passées en paramètre. Elle utilise un algorithme de bruit de Perlin pour générer la valeur de hauteur à chaque position UV. Elle calcule une somme de bruits à différentes fréquences et amplitudes pour générer une texture de terrain réaliste.\n// Source:\n// https://iquilezles.org/articles/fbm/\nfloat fbm(in vec2 uv) {\n    // cette fonction génère la hauteur du terrain\n    uv /= 3.5;\n    float value = 0.1;\n    float amplitude = 1.;\n    float freq = 1.;\n    // pour chaque amplitude\n    for(int i = 0; i < 8; i++) {\n        value = max(value, value + (.25 - abs(bruit(uv * freq) - .8) * amplitude));\n        amplitude *= .37;\n        freq *= 2.05;\n\n        uv = uv.yx;\n    }\n\n    return value * 2.0 - 2.0;\n}\n\n// même principe que le fbm du terrain mais modifié pour simuler de l'eau\n// Source:\n// https://iquilezles.org/articles/fbm/\nfloat fbmWater(in vec2 uv) {\n    // cette fonction génère la hauteur du terrain\n    uv /= .1;\n    float value = .01;\n    float amplitude = .01;\n    float freq = 1.;\n    for(int i = 0; i < 8; i++) {\n        value = max(value, value + (.25 - abs(bruit(uv * freq) + 0.99) * amplitude));\n\n        amplitude *= .17 + (0.1 * (sin(iTime * 1.3)));\n\n        freq *= 5.05;\n\n        uv = uv.yx;\n    }\n\n    return value * 2.0 - 2.0;\n}\n\n// Cette fonction calcule la hauteur du terrain en un point donné pos en utilisant une fonction de bruit fractal (fonction fbm) qui prend en entrée les coordonnées x et z du point. Le paramètre TERRAIN_SEED est une valeur constante qui sert de graine pour la génération du bruit, afin de pouvoir obtenir des terrains différents en modifiant cette valeur.\nfloat terrain(in vec3 pos) {\n    float flr = pos.y - (fbm(vec2(pos.x + TERRAIN_SEED, pos.z)));\n    if(flr < -0.05) {\n        pos.xz += iTime;\n    }\n    return flr;\n}\n\n// Cette fonction calcule la hauteur de l'eau en un point de l'espace donné par la variable pos\nfloat water(in vec3 pos) {\n    float water = pos.y + NIVEAU_EAU - (fbmWater(vec2(pos.x, pos.z)));\n    return water;\n}\n\n// ===================================================\n// lancer de rayons\n// ===================================================\n\n// calcule le point le plus proche de la caméra qui est touché par le rayon qui part de la caméra et qui passe par pos. En fonction de l'objet touché (soit le terrain, soit l'eau, soit rien), elle définit le type de matériau correspondant (TERRAIN, EAU ou CIEL) pour ce point. Enfin, elle retourne la distance entre le point le plus proche touché et la caméra.\nfloat map(in vec3 pos, out material mat) {\n    // le sol\n    float flr = terrain(pos);\n    //         l'eau\n    float water = water(pos);\n\n    //         trouver l'objet le plus proche touché par le rayon\n    float m = min(flr, water);\n\n    //         définir notre matériau en conséquence \n    if(m == flr)\n        mat.type = TERRAIN;\n    if(m == water)\n        mat.type = EAU;\n    else\n        mat.type == CIEL;\n\n    return m;\n}\n\n// calcule la normale d'un point sur une surface en utilisant la méthode de la différence finie. Cette normale est nécessaire pour calculer la réflexion de la lumière sur la surface et donc pour déterminer la couleur de cette dernière. Elle est également utile pour calculer l'effet d'ombres et de lumières sur la surface.\nvec3 calcNormal(in vec3 pos) {\n    material m;\n    vec3 x = vec3(EPSILON, 0.0, 0.0);\n    vec3 y = vec3(0.0, EPSILON, 0.0);\n    vec3 z = vec3(0.0, 0.0, EPSILON);\n    return normalize(vec3(map(pos + x, m) - map(pos - x, m), map(pos + y, m) - map(pos - y, m), map(pos + z, m) - map(pos - z, m)));\n}\n\n// fonction de lancement de rayon qui prend un rayon en entrée et renvoie un matériau et la distance parcourue par le rayon\nfloat castRay(in ray r, out material m) {\n    float t = 0.0;\n    // plus il y a d'itérations, meilleure sera la résolution, mais cela peut être lourd à traiter\n    for(int i = 0; i < 150; i++) {\n        // déplacement du rayon en utilisant l'origine et en ajoutant incrémentiellement t fois la direction du rayon\n        vec3 pos = rayAt(r, t);\n        // avons-nous touché quelque chose dans notre scène en utilisant la fonction map \n        float h = map(pos, m);\n\n        // si nous avons touché quelque chose, nous renvoyons ce que nous avons trouvé à t\n        if(h < EPSILON)\n            return t;\n\n        // sinon nous continuons\n        t += h;\n\n        //au-delà de la distance maximale\n        if(t > 20.0) {\n            t = 0.0;\n            return t;\n        }\n    }\n    return t;\n}\n\n// ===================================================\n// caméra\n// ===================================================\n\n// permet de créer une caméra en spécifiant sa position, sa cible à regarder et son vecteur \"up\" pour l'orientation verticale.\ncamera makeCam(vec3 lookfrom, vec3 lookat, vec3 vup) {\n    camera cam;\n    cam.origine = lookfrom;\n\n    float rotationSpeed = CAM_ROTATION_SPEED; // vitesse de rotation de la caméra\n    float angle = iTime * rotationSpeed;\n\n    // Création d'une matrice de rotation pour tourner la caméra autour de la cible\n    mat3 rotationMatrix = mat3(cos(angle), 0.0, sin(angle), 0.0, 1.0, 0.0, -sin(angle), 0.0, cos(angle));\n\n    // rotation de la caméra autour de la cible\n    vec3 direction = lookat - lookfrom;\n    direction = rotationMatrix * direction;\n    lookat = lookfrom + direction;\n\n    cam.w = normalize(lookat - lookfrom);\n    cam.u = normalize(cross(cam.w, vup));\n    cam.v = normalize(cross(cam.u, cam.w));\n\n    return cam;\n}\n\n// ===================================================\n// couleurs\n// ===================================================\n\nvec3 rotateSunDirection(vec3 sun_dir, float time) {\n    float rotationSpeed = SUN_ROTATION_SPEED; // Ajustez cette valeur pour contrôler la vitesse de rotation du soleil\n    float angle = time * rotationSpeed;\n\n    // Créez une matrice de rotation autour de l'axe X\n    mat3 rotationMatrix = mat3(1.0, 0.0, 0.0, 0.0, cos(angle), -sin(angle), 0.0, sin(angle), cos(angle));\n\n    // Appliquez la matrice de rotation au vecteur sun_dir\n    return rotationMatrix * sun_dir;\n}\n\n// Cette fonction calcule la couleur finale d'un point de l'espace en fonction de la distance parcourue par le rayon, de la normale à ce point, du matériau et de la position.\nvec3 computeColor(float t, inout vec3 col, material m, in vec3 pos, vec2 uv) {\n    // obtenir la normale de pos\n    vec3 nor = calcNormal(pos);\n\n    // Direction de la lumière\n    //\n    vec3 initial_sun_dir = vec3(0.9, 0.4, 0.5);\n    vec3 sun_dir = rotateSunDirection(initial_sun_dir, iTime);\n    float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n\n    // calcul de l'ombre   \n    ray shadow_ray = ray(pos + nor * 0.001, sun_dir);\n    float sun_shadow;\n\n    // éclairage diffus et réfléchi \n    float sky_dif = clamp(dot(nor, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n    float bounce_dif = clamp(dot(nor, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n\n    // si nous avons touché quelque chose \n    if(t > 0.0) {\n        //----------------------  TERRAIN.\n        if(m.type == TERRAIN) {\n            // Lumière -\n            // (https://www.youtube.com/watch?v=Cfe5UQ-1L9Q&t=9211s&ab_channel=InigoQuilez)\n            // calcul de l'ombre\n            sun_shadow = step(castRay(shadow_ray, m), 0.0);\n            // mélange de couleurs sur le terrain\n            vec3 matt = vec3(0.3);\n\n            // Couleur de la neige\n            col = matt * vec3(.3, 1.4, .4) * sun_dif * sun_shadow;\n            col += matt * vec3(.0, 0.8, 0.4) * sky_dif;\n\n            // lumière réfléchie\n            col += matt * vec3(0.1, 0.4, 0.4) * bounce_dif;\n        }\n        //---------------------- WATER.\n        else if(m.type == EAU) {\n            // calcul de l'ombre\n            sun_shadow = step(castRay(shadow_ray, m), 0.1);\n            // mélange de couleurs sur l'eau\n            vec3 matt = vec3(0.0, 0.1, 0.3);\n            col = matt / (sun_shadow + vec3(1.0, 1.0, 0.0));\n            col += matt * vec3(0.0, 0.01, 0.05);\n        }\n    }\n\n    return col;\n}\n\n// ===================================================\n// rendu de la scène\n// ===================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // coordonnées uv à partir de fragCoord, centrées\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    // construction de la caméra\n    vec3 lookfrom = vec3(.2, 1.5, 2.0);\n    vec3 lookat = vec3(0.0, 0.9, 0.);\n    vec3 vup = vec3(0, 1, 0);\n\n    camera cam = makeCam(lookfrom, lookat, vup);\n\n    ray r = getray(cam, uv);\n\n    // couleur du ciel avec des nuages, i.e. couleur par défaut\n    vec3 col = vec3(somme_fractale(uv * 5. + vec2(iTime * .3, 0.0), 8.));\n    col = mix(BLANC, BLEU, col);\n\n    // étape 2 - lancer le rayon, garder la trace du matériau\n    material m;\n    float t = castRay(r, m);\n\n    // étape 3 - construire la position à partir de la caméra\n    vec3 pos = lookfrom + t * r.dir;\n\n    // étape 4 - calcul final de la couleur\n    col = computeColor(t, col, m, pos, uv);\n\n    // étape 5 - correction gamma\n    col = pow(col, vec3(1.0 / 2.4));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}