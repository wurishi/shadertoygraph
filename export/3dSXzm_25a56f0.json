{"ver":"0.1","info":{"id":"3dSXzm","date":"1553373978","viewed":3793,"name":"Data Surge","username":"shau","description":"Inspired by Beeple","likes":49,"published":1,"flags":32,"usePreview":0,"tags":["3d","beeple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime\n#define R iResolution.xy\n\nconst float GA =2.399; \n\n// simplified version of Dave Hoskins blur from Virgill\nvec3 dof(sampler2D tex, vec2 uv, float rad) {\n\tvec3 acc = vec3(0);\n    vec2 pixel = vec2(.002*R.y/R.x, .002), angle = vec2(0, rad);;\n    rad = 1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1. / rad;\n\t    angle *= rot(GA);\n        vec4 col=texture(tex,uv+pixel*(rad-1.)*angle);\n\t\tacc+=col.xyz;\n\t}\n\treturn acc/80.;\n}\n\nfloat noise(vec2 uv, float s1, float s2, float t1, float t2, float c1) {\n\treturn clamp(hash33(vec3(uv.xy * s1, t1)).x +\n\t\thash33(vec3(uv.xy * s2, t2)).y, c1, 1.);\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    vec2 uv = U / R;\n\tvec3 pc = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.).xyz;\n    float n = noise(uv, 64., 32., float(iFrame), float(iFrame), .96);\n    pc *= n;\n    pc *= sin((uv.y + T * 0.05) * 800.0) * 0.2 + 0.9; \n    \n    C = vec4(pc, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define PI 3.141592\n#define EPS .005\n#define FAR 30.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define BUF(C, P, R) texture(C, P / R)\n#define BPOS(P) vec2(P + .5, .5)\n\n#define LP vec3(5., 6., -5.)\n\nvec3 hash33(vec3 p) {\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\nvec2 path(float p, float T) {\n    return vec2(sin(p * .2 + T * .2), cos(p * .3 + T * .1));\n}\n\n//noise IQ - Shane\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nvec3 camera(vec2 U, vec2 R, vec3 ro, vec3 la, float fl) {\n    vec2 uv = (U - R*.5) / R.y;\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z, 0., -fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define T iTime\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    C = texture(iChannel0, U / iResolution.xy);\n    \n    if (C == vec4(0) || C.x < -20.) {\n        //initialise particle\n        vec3 r = 5. * (hash33(vec3(U + 4. + T, iFrame)) - vec3(.5));\n        C = vec4(20. + r.x * 4., r.y, r.z, clamp(r.y * .5, .1, .4));        \n    }\n    \n    //move particle\n    C.x -= clamp(C.w * .4, .3, .5); \n    C.yz += path(C.x + C.w * 100., T) * clamp(C.w * .1, .01, .05);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by SHAU - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define T iTime\n\nstruct Surface{\n    float t; //nearest\n    float b; //bands\n    float bl; //band lights\n    float c; //core\n    float cl; //core lights\n};\nconst Surface MISS = Surface(-1., 0., 0., 0., 0.);\n\nvec3 kali(vec3 rd) {\n    vec3 pc = vec3(0);\n    float k = 0.;\n    for (float i = 0.; i < 6.; i++) {\n        rd = abs(rd) / dot(rd, rd) - .63;\n        k += length(rd) * length(hash33(rd + T*.2));\n        pc += mix(vec3(1.,.5,0.), vec3(0.,1.,0.), i/6.) * k*k*k * .0003;\n    }\n    return pc;\n}\n\n//IQ\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h) - r;\n}\n\n//IQ\nfloat sdBox(vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n//Dr 2\nfloat sdSquareHelix(vec3 p, float r1, float r2, vec2 b, float m, float o) {\n  float halfm = m * .5,\n        a = 0.5 * sign(p.z) - atan(p.z,p.y) / (2.*PI);\n  p.x = mod(-p.x + m * a + o, m) - halfm;\n  return max(sdBox(vec2(length(p.yz) - r1, p.x), vec2(b + r2)), \n            -sdBox(vec2(length(p.yz) - r1, p.x), vec2(b - r2))); \n}\n\n//Eiffie\nfloat sdHelix(vec3 p, float r1, float r2, float m, float o) {\n    float halfm = m*.5,\n          b = mod(p.x + o, PI*m) - PI*halfm,\n          a = abs(atan(p.y, p.z) * halfm - b);\n    if (a > PI*halfm) a = PI*m - a;\n    return length(vec2(length(p.zy) - r1, a)) - r2;\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat sdBall(vec3 p, float i, float r) {\n    vec4 cp = BUF(iChannel0, BPOS(i), iResolution.xy);\n    return length(cp.xyz - p) - (1. / (1. + dot(cp.yz, cp.yz) * r));\n}\n\nvec2 dfCore(vec3 p) {\n    \n    vec3 q = p;\n    q.yz += path(q.x, T);\n    float qt = length(q.yz);\n    vec3 h = hash33(q * qt * qt * 1.1);\n    float nz = n3D(q * 1. + (vec3(T*8., T*.3, T*.3) + h)) -.5;\n    float core = sdCapsule(q, vec3(100., 0., 0.), vec3(-100., 0., 0.), 1.4 + nz * qt * 1.3); \n\n    p.x = mod(p.x - 16., 40.) - 20.;    \n    float ts = FAR, tsl = FAR;\n    \n    for (float i = 0.; i < 10.; i++) {\n        float bt = sdBall(p, i, .2 + nz * .6);\n        ts = (bt < ts) ? bt : ts;\n    }\n    \n    for (float i = 10.; i < 24.; i++) {\n        float bt = sdBall(p, i, .6);\n        tsl = (bt < tsl) ? bt : tsl;\n    }\n    \n    return vec2(smin(ts, core, .9), tsl);    \n}\n\nSurface map(vec3 p) {\n\n    p.yz *= rot(T * .3);\n\n    vec2 core = dfCore(p);\n    \n    float bands = sdSquareHelix(p, 3., .01, vec2(.01,.7), 4. * PI, 0.);\n    float bandLights = min(sdHelix(p, 3.06, .06, 4., -PI-.35),\n                       sdHelix(p, 3.06, .06, 4., -PI+.35));\n    bands = min(bands, sdSquareHelix(p, 2.4, .01, vec2(.01,.9), 4.6 * PI, -1.4));\n    bandLights = min(bandLights, min(sdHelix(p, 2.46, .06, 4.6, .9-PI-.4),\n                             sdHelix(p, 2.46, .06, 4.6, .9-PI+.4)));\n    bands = min(bands, sdSquareHelix(p, 3.6, .01, vec2(.01,.2), 3. * PI, -3.4));\n    bandLights = min(bandLights, sdHelix(p, 3.68, .04, 3., 4.6-PI-.4));\n\n    return Surface(min(core.x, min(bands, min(bandLights, core.y))), \n                   bands, \n                   bandLights, \n                   core.x, \n                   core.y);\n}\n\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).t + e.xxy * map(p + e.xxy).t + \n\t\t\t\t\t e.xyx * map(p + e.xyx).t + e.yyy * map(p + e.yyy).t);   \n}\n\nfloat AO(vec3 p, vec3 n) {\n\n    float r = 0.0,\n          w = 1.0,\n          d = 0.0;\n\n    for (float i = 1.0; i < 5.0; i += 1.0){\n        d = i / 5.0;\n        r += w * (d - map(p + n * d).t);\n        w *= 0.5;\n    }\n\n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\nSurface march(vec3 ro, vec3 rd, inout float t, inout vec3 gc) {\n    \n   for (int i = 0; i < 96; i++) {\n        \n        Surface s = map(ro + rd * t);\n        \n        if (s.t < EPS) return s;\n        if (t > FAR) break;\n        \n        //core lights\n        float ltsg = 1. / (1. + s.cl * s.cl * 12.);\n        gc += vec3(0., 1., 0.) * ltsg * .1;\n       \n        //band glow\n        float ltbg = 1. / (1. + s.bl * s.bl * 400.);\n        gc += vec3(0., 1., 0.) * ltbg * .1;\n        \n        t += s.t * .5;\n    }\n    t = -1.;\n    return MISS;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n\n\tvec3 ro = vec3(1., 3. + (sin(T * .2) + 1.) * 1.2, -4.5 + (sin(T * .1) + 1.) * .2), \n         gc = vec3(0.);\n    \n    ro.xz *= rot(sin(T * .2) * .1);\n    vec3 rd = camera(U, R, ro, vec3(0.), 2.4);\n\n    vec3 pc = kali(-rd * 1.4) * .5;\n    \n    float t = 0., dof = 0.;\n    Surface s = march(ro, rd, t, gc);\n    if (t > 0.) {\n        vec3 p = ro + rd * t;\n        dof = length(p) * .05;\n        vec3 n = normal(p);\n        float ao = AO(p, n);\n        vec3 ld = normalize(LP - p);\n        float df = max(.05, dot(ld, n));\n        float sp = pow(max(dot(reflect(-ld, n), -rd), 0.), 32.);\n        float fres = pow(clamp(dot(n, rd) + 1., 0., 1.), 8.);\n        if (s.t == s.b) {\n            //band\n            pc = vec3(.1) * df * ao;    \n            pc += vec3(1.) * sp;\n            pc += vec3(1.) * fres;\n            \n        } else if (s.t == s.c) {\n            //core    \n            pc = vec3(.2) * df * ao;\n            //dof = .9;\n            \n        } else if (s.t == s.cl || s.t == s.bl) {\n            //lights    \n            pc = vec3(0., 1.8, 0.) * ao;\n        }\n    }\n    pc += gc;\n    //pc = mix(pc, vec3(0), t * t * .08 / FAR);\n\n    C = vec4(pc, dof);\n}","name":"Buffer B","description":"","type":"buffer"}]}