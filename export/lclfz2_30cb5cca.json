{"ver":"0.1","info":{"id":"lclfz2","date":"1724083950","viewed":19,"name":"Soft shadows Discovery","username":"KivuSupremeKing","description":"soft shadows, using Inigo Quilez article.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot2D(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nfloat sdSphere(vec3 o, float s)\n{\n    return length(o) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    k *= 1.0;\n    float r = exp2(-a/k) + exp2(-b/k);\n    return -k*log2(r);\n}\n\n\nvec3 colorGround(vec3 p)\n{\n    float i = 0.;\n    if (p.x < 0.) i = 1.;\n    float c = float(int(floor(abs(p.x) + i)) % 2);\n    i = 0.;\n    if (p.z < 0.) i = 1.;\n    c += float(int(floor(abs(p.z) + i)) % 2);\n    if (c > 1.0) c = 0.;\n    return vec3(c);\n}\n\nvec3 colorMap(vec3 p)\n{\n    float ground = p.y + .75;\n    float sphere = sdSphere(p - vec3(2, 0, 0), 1.);\n    \n    float minV = min(ground, sphere);\n    \n    if (minV == sphere) return vec3(1.);\n    return colorGround(p);\n}\n\n\nvec3 normalGround(vec3 p)\n{\n    return normalize(vec3(0, 1, 0));\n}\n\nvec3 normalSphere(vec3 p, vec3 o)\n{\n    return normalize(p - o);\n}\n\nvec3 normalMap(vec3 p)\n{\n    float ground = p.y + .75;\n    float sphere = sdSphere(p - vec3(2, 0, 0), 1.);\n    \n    float minV = min(ground, sphere);\n    \n    if (minV == sphere) return normalSphere(p, vec3(2, 0, 0));\n    return normalGround(p);\n}\n\n\nfloat map(vec3 p)\n{\n    float ground = p.y + .75;\n    float sphere = sdSphere(p - vec3(2, 0, 0), 1.);\n    \n    return min(ground, sphere);\n}\n\n\nfloat shadow(vec3 ro, vec3 rd,float maxT, float k)\n{\n    float res = 1.0;\n    float t = 0.1;\n    for( int i=0; i<256 && t<maxT; i++ )\n    {\n        float h = map(ro + t*rd);\n        res = min( res, h/(k*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res< -1.0 || t>maxT ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25 * (1.0+res) * (1.0+res) * (2.0-res);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //initialization\n    vec2 uv = ((fragCoord*2.) - iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n    if (iMouse.xy == vec2(0.))\n        m = vec2(0.);\n    float fov = 1.;\n\n    vec3 ro = vec3(0, 0, -3); //ray origin\n    vec3 rd = normalize(vec3(uv * fov, 1)); //ray direction\n    \n    ro.yz *= rot2D(m.y);\n    rd.yz *= rot2D(m.y);\n    \n    ro.xz *= rot2D(m.x);\n    rd.xz *= rot2D(m.x);\n    \n    vec3 color = vec3(0.0);\n   \n    vec3 normal = vec3(0);\n    \n    \n    float t = 0.; //total distance travelled\n    \n    //lights\n    vec3 lightPoint = normalize(vec3(-2, -0.1, 0));\n    vec3 lightColor2 = vec3(1.);\n    \n    vec3 p = vec3(0.);\n    \n    \n    //raymarching\n    for (int i = 0; i < 120; i += 1) {\n        p = ro + rd * t;\n\n        float d = map(p); //current distance\n\n        t += d;\n        \n        if (d < 0.01) {\n            p = ro + rd * t;\n            color = colorMap(p);\n            color += vec3(t / 50.);\n            normal = normalMap(p);\n            break;\n        }\n        \n        if (t > 100.) break; //distance maximum\n    }\n    \n    if (normal != vec3(0)) {\n        vec3 lightPointDir = normalize(p - lightPoint);\n        float dotV = dot(lightPointDir, normal) * -1.;\n        if (dotV < 0.) dotV = 0.;\n        \n        color *= dotV * lightColor2;\n        \n        float shadowV = shadow(p, -lightPointDir, length(p - lightPoint), 1./5.);\n        color *= shadowV;\n    }\n\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}