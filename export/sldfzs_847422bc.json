{"ver":"0.1","info":{"id":"sldfzs","date":"1663622500","viewed":189,"name":"[phreax] rainbow hive","username":"phreax","description":"Some more rainbow madness..\n\nInspired by hexeosis\n\nUpdate: add numeric edge detection by Kali","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","palette","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n * phreax 2022\n *\n * Special thanks to: iq, evvvvil, nusan, bigwings, fabrice, flopine, yx \n * for their amazing content and learning material.\n * \n */\n#define PI 3.141592\n#define TAU PI*2.\n#define SIN(x) (.5+.5*sin(x))\n\n#define EDGE_DETECTION 1\n\nfloat tt;\nvec3 ro;\nvec2 beamId;\nfloat hexId;\nfloat gMatId;\n\n\n// from \"Palettes\" by iq. https://shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 getPal(int id, float t) {\n\n    id = id % 7;\n\n    vec3          col = pal( t, vec3(.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,-0.33,0.33) );\n    if( id == 1 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    if( id == 2 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    if( id == 3 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    if( id == 4 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    if( id == 5 ) col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    if( id == 6 ) col = pal( t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    return col;\n}\n\n\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 q = abs(p) - r;\n    return max(max(q.x, q.y),q.z);\n}\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\n\nfloat pModSingle(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\nfloat repeat(inout float x, float n) {\n    float id = floor(n*x)/n;\n    x = fract(n*x);\n    return id;\n}\n\n\nvec3 colorStripeTexture(vec3 p, int palId, float off) {\n    float dim = p.y*6.;\n    \n    float id = repeat(dim, 5.2) + tt + off;\n    vec3 col = getPal(palId, id);\n    return col;\n}\n\n// from https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvoid transform(inout vec3 p) {\n    \n    float repz = 8.;\n\n    float idz = pModSingle(p.z,8.);  \n    p.xy *= rot(.25*PI*mod(idz, repz));\n}\n\n// by Nusan\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(floor(t), floor(t)+1., pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\n// kaleidoscopic function\nvec3 kalei(vec3 p) {\n  float w = 1.;\n  p = abs(p) -.3;\n  \n  float tc = curve(tt, 2.)*2.414+curve(.57*tt, 6.)*3.212;\n  for(float i=0.; i < 2.; i++) {\n        float t1 = 2.+sin(i+tc) + sin(.7*tc)*.4;\n        p.xy *= rot(.34*t1);\n        p -= 0.1 + .1*i;\n        p.y -= 0.1;\n        p = abs(p);\n \n    }\n    p /= w;\n    return p;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat map(vec3 p) {\n\n    vec3 bp = p;\n    float repz = 1.5;\n\n    float hexCount = 8.;\n    \n    if(tt > 8.) p = kalei(p);\n   \n    float segId = pModSingle(p.z, repz);\n    hexId = pModInterval1(p.z, .15, 0., hexCount);\n    \n\n    p.xy *= rot(PI*1./2.);\n    float pid = pModPolar(p.xy, 6.);\n    \n    gMatId = segId + abs(pid);\n    p.x -= .4;\n    p.xy *= rot(PI*1./2.);\n  \n  \n    float sizeMod = (hexId/hexCount)*.1;\n    float width = .09-sizeMod;\n    float size = .2-sizeMod;\n    float thickness = .04;\n    float hex = max(sdHexPrism(p, vec2(size, width)), -sdHexPrism(p, vec2(size-thickness, width+.1)));\n    \n    float d = hex*.6;\n    \n    d = max(d, -sdHexPrism(bp-ro, vec2(.2, 10)));\n\n    return d;\n   \n}\n\nvoid cam(inout vec3 p) {\n    p.z += 1.*tt;;\n\n}\n\n// numeric edge detection by kali\nfloat edge;\nvec3 normal(vec3 p) { \n\tvec3 e = vec3(0.0,0.0035,0.0);\n\n\tfloat d1=map(p-e.yxx),d2=map(p+e.yxx);\n\tfloat d3=map(p-e.xyx),d4=map(p+e.xyx);\n\tfloat d5=map(p-e.xxy),d6=map(p+e.xxy);\n\tfloat d=map(p);\n\tedge=abs(d-0.5*(d2+d1))+abs(d-0.5*(d4+d3))+abs(d-0.5*(d6+d5));//edge finder\n\tedge=min(1.,pow(edge,.7)*20.);\n\treturn normalize(vec3(d1-d2,d3-d4,d5-d6));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    tt = iTime;\n         ro = vec3(0, 0, -4.);\n    vec3 rd = normalize(vec3(uv, 1.5)),\n         lp = vec3(0., 0., 2.);\n    \n    cam(ro);\n    cam(lp);\n  \n    float i, t, d = 0.1;\n\n    vec3 p = ro;\n\n    float matId;\n    for(i=0.; i<300.; i++) {\n    \n          \n        d = map(p);\n        matId = hexId; // save id\n        \n        if(d < 0.001 || t > 200.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    vec2 e = vec2(0.0035, -0.0035);\n    \n    vec3 fo, co;\n    co = fo = vec3(0.965,0.945,0.918);\n    \n    if(d < 0.001) {\n        vec3 al;\n        \n        vec3 n = normal(p);\n                            \n        int palId = 0;\n        if(tt > 16.) palId = mod(tt, 16.) <8. ? 4 : 3;\n        \n        al = getPal(palId, .5-matId*.15+.5*tt+gMatId+.5)*1.3;\n        \n        if(tt > 32.)  al = mix(al, (vec3(0.867,1.000,0.780)-abs(n))*1.4, .8*SIN(tt));\n        \n        //if(mod(hexId, 2.) == 1. && tt > 16.) al = colorStripeTexture(p, palId, hexId);\n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 40.);\n        float sss = smoothstep(0., 1., map(p+l*.4))/.4; \n        \n        co =  al*mix(1., .4*spe+(.4*dif+1.5*sss), .45);\n        \n        #if EDGE_DETECTION\n        co *= max(0.,1.-edge);\n        #endif\n        co = mix(co, fo, 1.-exp(-.0003*t*t*t))*.9+.1*fo;   \n    }\n\n\n    // Output to screen\n    fragColor = vec4(co, 1.);\n}","name":"Image","description":"","type":"image"}]}