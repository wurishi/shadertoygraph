{"ver":"0.1","info":{"id":"4X3XD7","date":"1719164339","viewed":52,"name":"Pixel Art Mars","username":"ArchaicVirus","description":"Procedural mars-like planet in a dithered pixel art style","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["pixel","sphere","space","planet","dithering","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DITHER_STRENGTH 0.1\n#define PIXEL_SIZE 4.0\n\nfloat hash(float n) {\n    return fract(sin(n) * 53738.14534123);\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u * u * (3.0 - 2.0 * u);\n    float scale = 105.0;\n    return mix(\n        mix(hash(ip.x + ip.y * scale), hash(ip.x + 1.0 + ip.y * scale), u.x),\n        mix(hash(ip.x + (ip.y + 1.0) * scale), hash(ip.x + 1.0 + (ip.y + 1.0) * scale), u.x),\n        u.y\n    );\n}\n\nvec3 rotate(vec3 p, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return vec3(c*p.x - s*p.z, p.y, s*p.x + c*p.z);\n}\n\nfloat layeredNoise(vec3 p, float amplitude, float frequency, float persistence, int octaves) {\n    float n = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        n += noise(p.xy * frequency) * amplitude;\n        amplitude *= persistence;\n        frequency *= 2.0;\n        p = rotate(p, 45.0);\n    }\n    return n;\n}\n\nfloat sphere(vec3 ro, vec3 rd, float radius) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - radius * radius;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec3 colorBanding(float n) {\n    vec3 color = vec3(0);\n    if (n > 0.92) return vec3(0.5, 0.2, 0.1);\n    else if (n > 0.80) color = vec3(0.7, 0.3, 0.2);\n    else if (n > 0.68) color = vec3(0.8, 0.4, 0.2);\n    else if (n > 0.53) color = vec3(0.9, 0.5, 0.3);\n    else if (n > 0.37) color = vec3(0.8, 0.5, 0.4);\n    else if (n > 0.21) color = vec3(0.7, 0.4, 0.3);\n    else color = vec3(0.5, 0.3, 0.2);\n    return color;\n}\n\nconst mat4 bayerMatrix = mat4(\n    0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,\n    12.0/16.0, 4.0/16.0, 14.0/16.0,  6.0/16.0,\n    3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,\n    15.0/16.0, 7.0/16.0, 13.0/16.0,  5.0/16.0\n);\n\nvec3 applyDithering(vec3 color, vec2 uv, float noiseValue) {\n    int x = int(mod(uv.x, 4.0));\n    int y = int(mod(uv.y, 4.0));\n    float threshold = bayerMatrix[x][y];\n    noiseValue += threshold * DITHER_STRENGTH;\n    return colorBanding(noiseValue);\n}\n\nvec3 applyLighting(vec3 color, vec3 normal, vec3 lightDir) {\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    return color * diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float pixelSize = PIXEL_SIZE;\n    vec2 uv = (floor(fragCoord / pixelSize) * pixelSize - iResolution.xy * 0.5) / iResolution.y;\n    \n    vec3 ro_planet = vec3(0.0, 0.0, 2.4);\n    vec3 ro_clouds = vec3(0.0, 0.0, 2.3);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float t_planet = sphere(ro_planet, rd, 1.0);\n    float t_clouds = sphere(ro_clouds, rd, 1.0);\n    if (t_clouds < 0.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        vec3 pos = ro_planet + t_planet * rd;\n        vec3 norm = normalize(pos);\n        \n        pos = rotate(pos, iTime * 0.15);\n        vec3 rotatedNorm = normalize(rotate(norm, iTime * 0.15));\n        \n        float noiseValue = layeredNoise(rotatedNorm * 3.1415, 0.75, 1.0, 0.5, 8);\n        \n        vec3 color;\n        if (t_planet < 0.0) {\n            color = vec3(0.0);\n        } else {\n            color = applyDithering(colorBanding(noiseValue), fragCoord.xy / pixelSize, noiseValue);\n        }\n        \n        vec3 lightDir = normalize(vec3(1.0, 0.5, 1.0));\n        color = applyLighting(color, norm, lightDir);\n        fragColor = vec4(color, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}