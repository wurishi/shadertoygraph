{"ver":"0.1","info":{"id":"mlBBWW","date":"1694032454","viewed":29,"name":"Viewing Parts of a Model","username":"gest","description":"airplane from here:\nhttps://www.shadertoy.com/view/4sSXDG","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//airplane from here:\n//https://www.shadertoy.com/view/4sSXDG\n// \"River Flight\" by dr2 - 2014\n\n#define SHADERTOY\n\n#ifdef SHADERTOY\n    #define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\n    #define u_canvas iResolution\n    #define u_mouse iMouse\n    #define u_time iTime\n    #define gl_FragCoord fragCoord\n    #define gl_FragColor fragColor\n#endif\n\n//Параметры крыла\nstruct WingParam {\n\tfloat wingspan; \t//Размах\n\tfloat spanradius; \t//радиус крылв\n\tfloat wingoffset;\t//Смещение\n\tfloat thickness;\t//Толщина\n\tfloat wingwidth;\t//Ширина крыла\n\tfloat edgeradius;\t//Радиус кромки\n};\n//Крылья\nfloat dfWing (vec3 p, WingParam w) {\n  vec3 q;\n  \n  q = p;\n  q.y -= w.spanradius;\n  float d1 = dfCyl(q.yz, w.thickness);\n  \n  q = p;\n  q.y -= -w.spanradius;\n  float d2 = dfCyl(q.yz, w.thickness);\n  \n  float d = max (d1, d2);\n  \n  q = p;\n  q.x -= w.wingoffset;\n  float d4 = dfBetween0(q.x, w.wingspan);\n  \n  q = p;\n  float d_cut = dfAfter(q.z, w.wingwidth);\n  \n  d = max (max (d, d4), -d_cut);\n  \n  q = p;\n  q.z -= w.wingwidth;\n  float d6 = dfCyl(q.yz, w.edgeradius);\n  \n  return min (d, max (d6, d4));\n}\n\n//Масштаб модели\nfloat zoom = 1.;\n\nconst float wSpan = 12.;\nconst WingParam w1 = WingParam(wSpan, 13.7, 0., 14., 1.72, 0.195);\nconst WingParam w2 = WingParam(0.4 * wSpan, 6.8, 0., 7., 1.2, 0.095);\nconst WingParam w3 = WingParam(0.15 * wSpan, 6.8, 2.2, 7., 1.2, 0.095);\nconst vec3 engPos = vec3 (0.35 * wSpan, -0.2, -1.5);\nconst float wSweep = 0.2;\nconst float fusLen = 11.; //Длина фюзеляжа\nconst float taPos = 12.5;\n\n\n//-----Карта расстояний до элементов сцены (с возвращением информации об объекте)\nfloat map(vec3 p, inout Object object) {\n\tvec3 q;\n\tfloat wr, ws, cLen;\n\t\n\tobject = Object(1e6, 0.);\n\t\n\tp /= zoom;\n\t\n\t//Кабина\n\tObject obj1 = Object(1e6, 1.);\n\t{\n\t\tq = p;\n\t\twr = p.z / fusLen;\n\t\tq -=  vec3 (0., fusLen *(0.045 + 0.08 * wr), 0.);\n\t\tobj1.distance = dfCapsule (q,  fusLen *0.46, fusLen *0.11);\n\t}\n\tobject = OR(object, obj1);\n\n\t//Фюзеляж\n\tObject obj2 = Object(1e6, 2.);\n\t{\n\t\tq = p;\n\t\twr = p.z / fusLen;\n\t\tq -=  vec3 (0., 0., - fusLen * 0.32);\n\t\tobj2.distance = dfCapsule (q,  fusLen, fusLen * (0.15 - 0.051 * wr * wr)) - 0.1;\n\t}\n\tobject = OR(object, obj2, 0.1);\n\n\t//Передние крылья\n\tObject obj3 = Object(1e6, 3.);\n\t{\n\t\tq = p;\n\t\tws = wSweep * abs (p.x) / wSpan;\n\t\tq -= vec3 (0., -0.054 * fusLen + 6. * ws, -12. * ws);\n\t\tobj3.distance = dfWing (q, w1)-0.2;\n\t}\n\tobject = OR(object, obj3, 0.2);\n\n\t//Задние крылья\n\tObject obj4 = Object(1e6, 4.);\n\t{\n\t\tq = p;\n\t\tws = wSweep * abs (p.x) / wSpan;\n\t\tq -= vec3 (0., 0.1 + 6. * ws, -taPos - 12. * ws);\n\t\tobj4.distance = dfWing (q, w2)-0.1;\n\t}\n\tobject = OR(object, obj4, 0.1);\n\n\t//Хвостовой стабилизатор\n\tObject obj5 = Object(1e6, 5.);\n\t{\n\t\t#if 0\n\t\t\tq = p.yxz;\n\t\t#else\n\t\t\tq = p;\n\t\t\trotateZ(q, -PI/2.);\n\t\t#endif\n\t\tws = wSweep * abs (p.y) / wSpan;\n\t\tq -= vec3 (0.2, 0., -taPos - 12. * ws);\n\t\tobj5.distance = dfWing (q, w3)-0.1;\n\t}\n\tobject = OR(object, obj5, 0.1);\n\n\t//Двигатели\n\tObject obj6 = Object(1e6, 6.);\n\t{\n\t\tq = p;\n\t\tmirror(q.x, engPos.x);\n\t\tcLen = 3.5;\n\t\twr = p.z / cLen;\n\t\tq -= vec3(0, engPos.y, engPos.z);\n\t\tfloat d = dfCylCappedZ (q, cLen * (0.2  - 0.07 * wr * wr), cLen);\n\t\tfloat d_cut = dfCylCappedZ (q, 0.04, cLen * 1.02);\n\t\tobj6.distance = AND (d, - d_cut);\n\t}\n\tobject = OR(object, obj6);\n\n\t//Турбина\n\tObject obj7 = Object(1e6, 7.);\n\t{\n\t\tq = p;\n\t\tmirror(q.x, engPos.x);\n\t\tq -= vec3 (0., engPos.y, engPos.z + 4.2);\n\t\tobj7.distance = dfConeZ (q, vec3 (0.8, 0.6, 0.7));\n\t}\n\tobject = OR(object, obj7);\n\n\t//Окончание крыльев\n\tObject obj8 = Object(1e6, 8.);\n\t{\n\t\tq = p;\n\t\tmirror(q.x, wSpan + 0.1);\n\t\tcLen = 2.8;\n\t\tq -= vec3 (0, 0.5 * wSweep * wSpan - 0.6, -wSweep * wSpan + 0.025 * cLen - 0.5);\n\t\twr = (q.z-0.5) / cLen;\n\t\tobj8.distance = dfCapsule (q,  cLen, cLen *(0.15 - 0.055 * wr * wr));\n\t}\n\tobject = OR(object, obj8);\n\n\t//Пропеллер\n\tObject obj9 = Object(1e6, 9.);\n\t{\n\t\tq = p;\n\t\tmirror(q.x, engPos.x);\n\t\tq -= vec3(0,engPos.y,engPos.z+3.65);\n\t\tobj9.distance = dfCylCappedZ (q, 1.9, 0.05);\n\t}\n\tobject = OR(object, obj9);\n\n\treturn object.distance * zoom;\n}\n\n//-----Карта расстояний до элементов сцены (без возвращения информации об объекте)\nfloat map ( in vec3 p ) {\n\tObject object;\n\treturn map (p, object);\n}\n\n//-----Вычисление нормали к поверхности\nvec3 mapNormal (vec3 p, float eps) {\n\tvec2 e = vec2 (eps, 0.);\n\tfloat d = map(p),  d1 = map(p + e.xyy),  d2 = map(p + e.yxy),  d3 = map(p + e.yyx);\n  \treturn normalize (vec3 ( d - d1, d - d2, d - d3 ));\n}\n\n//-----Поиск минимаотного расстояния до объета\nfloat rayMarch(inout Ray ray) {\n\tray.distance = ray.near;\n\tfloat steps = 1.;\n\tfor (float i = 0.; i < 100.; ++i) {\n\t\tray.position = ray.origin + ray.direction * ray.distance;\n\t\tray.object.distance = map(ray.position, ray.object);\n\t\tray.hit = ray.object.distance < ray.epsilon;\n\t\tif (ray.hit) break;\n\t\tray.distance += ray.object.distance*ray.swing;\n\t\tif (ray.distance>ray.far) break;\n\t\tsteps++;\n\t\tif (steps>ray.steps) break;\n\t}\n\treturn steps;\n}\n\n//-----Простейшая функция освещения\nvec3 lighting(Ray ray, vec3 mColor) {\n\t#if 1\n\t\tfloat diffuse = max(0.3, dot(ray.normal,  ray.direction));\n\t\treturn mColor*diffuse;\n\t#else\n\t\treturn  mColor*vec3(1.-pow(ray.distance/ray.far, 1.2));\n\t#endif\n}\n\nvoid main() {\n\tfloat aspect = u_canvas.x / u_canvas.y;\n\tvec2 uv0 = gl_FragCoord.xy / u_canvas.xy;\n\tvec2 uv = 2. * uv0 - 1.;\n\t\n\tvec2 mouse = u_mouse.xy/u_canvas.xy;\n\tif (mouse==vec2(0)) mouse = vec2(0.5, 0.3);\n\tvec2 uv1 = 2.*mouse - 1.;\n\t\n\tvec2 uv2 = uv-uv1;\n\tuv2.x *= aspect;\n\t\n\t//Выбор объекта\n\tfloat object_id_select = 0.;\n\t\n\t//Камера\n\tCamera cam;\n\t{\n\t\tcam.fov     = 45.;\n\t\tcam.aspect  = aspect;\n\t\tcam.origin  = vec3(0,0,20)*rotate(radians(vec3(-30., 30.+u_time*5., 0)));\n\t\tcam.target  = vec3(0,0,0);\n\t\tcam.up \t\t= vec3(0,1,0);\n\t}\n\t\n\t//Выпускаем луч из мыши\n\tRay ray1 = lookAt(uv1, cam);\n\t{\n\t\tray1.near \t= 0.01;\n\t\tray1.far  \t= 40.;\n\t\tray1.epsilon = 0.001;\n\t\tray1.swing\t= 1.;\n\t\tray1.steps \t= 100.;\n\t}\n\trayMarch (ray1);\n\t\n\tif (ray1.distance<ray1.far) {\n\t\t//Устанавливаем выделенный объект\n\t\tobject_id_select = ray1.object.id;\n\t}\n\t\n\t//Формируем луч\n\tRay ray = lookAt(uv, cam);\n\t{\n\t\tray.near \t= 0.01;\n\t\tray.far  \t= 40.;\n\t\tray.epsilon = 0.001;\n\t\tray.swing\t= 1.;\n\t\tray.steps \t= 100.;\n\t}\n\t//Запускаем луч через сцену\n\trayMarch (ray);\n\t\n\tvec3 color = vec3(0.3, 0.4, 1.0); //Цвет фона\n\t\n\tif (ray.distance<ray.far) {\n\t\t//Найден элемент сцены\n\t\tray.normal = mapNormal(ray.position, 0.01);\n\t\t//Цвет элемента\n\t\tvec3 mColor = vec3(1);\n\t\tif (object_id_select==ray.object.id) mColor = vec3(1,0,0);\n\t\t//Цвет элемента с учетом освещения\n\t\tcolor = lighting(ray, mColor);\n\t}\n\t\n\t//Метка позиции мыши\n\tif (length(uv2)<=0.1) {\n\t\tfloat mFac = length(uv2)/0.1;\n\t\tcolor += (1.-mFac)*vec3(1,1,0); //\n\t}\n\t\n\tgl_FragColor = vec4 (color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = radians(180.);\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov, aspect;\n\tvec3  origin, target, up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward, right, position, coord;\n};\n\n//Параметры объекта\nstruct Object {\n\tfloat   distance;\t//Последнее приближение к объекту сцены\n\tfloat \tid;\t\t\t//id найденого объека сцены\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние от камеры (начало сцены)\n\tfloat far;\t\t\t//Максивальное расстояние от камеры (конец сцены)\n\tfloat epsilon;\t\t//Точность обнаружения поверхности\n\tfloat steps;\t\t//Максимальное число итераций\n\tfloat swing;\t\t//Колебание шага\n\t//Вычисляемые параметры\n\tfloat distance; \t//Расстояние до объекта сцены от ray.origin в направлении ray.direction\n\tvec3  position; \t//Точка поверхности\n\tvec3  normal;\t\t//Нормаль в точке поверхности\n\tbool  hit;\t\t\t//Флаг нахождения точки поверхности с заданной точностью\n\tObject object;\t\t//Параметры объекта (можно формировать непосредственно в карте расстояний)\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.forward, cam.up));\n\tcam.up \t\t\t= cross(cam.right, cam.forward);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t\t//Умолчания\n\t\tray.near\t\t= 0.01;\n\t\tray.far\t\t\t= 100.;\n\t\tray.epsilon\t\t= 0.001;\n\t\tray.swing\t\t= 1.0;\n\t\tray.steps\t\t= 100.;\n\t}\n\treturn ray;\n}\n\n//-------------------Функции позиционирования объектов сцены\n\n//Вращение вокруг осей\nmat3 rotate(vec3 r) {\n\tvec3 s = sin(r), c = cos(r);\n\tmat3 mx = mat3(1.0, 0.0, 0.0,    0.0, c.x, -s.x,   \t0.0, s.x, c.x);\n\tmat3 my = mat3(c.y, 0.0, -s.y,   0.0, 1.0, 0.0,   \ts.y, 0.0, c.y);\n\tmat3 mz = mat3(c.z, -s.z, 0.0,   s.z, c.z, 0.0,   \t0.0, 0.0, 1.0);\n   \treturn mx * my * mz;\n}\nvoid rotate(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = tMat * p;\n}\nvoid rotateOrigin(inout vec3 p, vec3 r) {\n\tmat3 tMat = rotate(r);\n\tp = p * tMat;\n}\nvoid rotateX(inout vec3 p, float r) {\n\tfloat s = sin(r); float c = cos(r);\n\tmat2 tMat = mat2(c, s, -s, c);\n\tp.yz = tMat * p.yz;\n}\nvoid rotateY(inout vec3 p, float r) {\n\tfloat s = sin(r); float c = cos(r);\n\tmat2 tMat = mat2(c, s, -s, c);\n\tp.xz = tMat * p.xz;\n}\nvoid rotateZ(inout vec3 p, float r) {\n\tfloat s = sin(r); float c = cos(r);\n\tmat2 tMat = mat2(c, s, -s, c);\n\tp.xy = tMat * p.xy;\n}\n//Отражение / Дублирование\nvoid mirror(inout vec3 p, vec3 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout vec2 p, vec2 dist) {\n\tp = abs(p) - dist;\n}\nvoid mirror(inout float p, float dist) {\n\tp = abs(p) - dist;\n}\n\n//-------------------Функции сочетания расстояний до объектов сцены\n//Сложение / Объединение / ИЛИ\nfloat OR(float distA, float distB) {\n\treturn mix(distA, distB, step(distB, distA)); //if (distB<distA) return distB; return distA;\n}\n//Умножение / Пересечение / И\nfloat AND(float distA, float distB) {\n\treturn mix(distA, distB, step(distA, distB)); //if (distB>distA) return distB; return distA;\n}\n// Минимальная функция сглаживания. Есть бесчисленное множество статей, но IQ объясняет это лучше всего здесь:\n// http://iquilezles.org/www/articles/smin/smin.htm\n//Гладкое сложение / Объединение / ИЛИ (k==0 без)\nfloat OR( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 + 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) - k*h*(1.-h);\n}\n//Гладкое умножение / Пересечение / И (k==0 без)\nfloat AND( float distA, float distB, float k ) {\n\tfloat h = clamp( 0.5 - 0.5*(distB-distA)/k, 0., 1. );\n\treturn mix( distB, distA, h ) + k*h*(1.-h);\n}\n//Исключение / НЕ\nfloat NOT(float dist) {\n\treturn -dist;\n}\n//-------------------Функции сочетания объектов сцены\n//Сложение / Объединение / ИЛИ\nObject OR(Object objectA, Object objectB) {\n\tif (objectB.distance<objectA.distance) return objectB;\n\treturn objectA;\n}\nObject OR(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance<objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = OR(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n\n//Умножение / Пересечение / И\nObject AND(Object objectA, Object objectB) {\n\tif (objectB.distance>objectA.distance) return objectB;\n\treturn objectA;\n}\nObject AND(Object objectA, Object objectB, float k) {\n\tObject object = objectA;\n\tif (objectB.distance>objectA.distance) object = objectB;\n\tif (k!=0.) object.distance = AND(objectA.distance, objectB.distance, k);\n\treturn object;\n}\n//Исключение / НЕ\nObject NOT(Object object) {\n\tobject.distance = -object.distance;\n\treturn object;\n}\n\n\n//-----Функции расстояния до примитивов и сборных объектов\nfloat dfBefore(float p, float p1) {\n\treturn p - p1;\n}\nfloat dfAfter(float p, float p1) {\n\treturn -p + p1;\n}\nfloat dfBetween(float p, float p1, float p2) {\n\t#if 0\n\t\tfloat d_after = dfAfter(p, p1);\n\t\tfloat d_before = dfBefore(p, p2);\n\t\treturn AND(d_after, d_before);\n\t#else\n\t\treturn max(-p + p1, p - p2);\n\t#endif\n}\nfloat dfBetween0(float p, float h) {\n\treturn abs(p) - h;\n}\nfloat dfBall(vec3 p, float R) {\n\treturn length(p)-R;\n}\nfloat dfCyl(vec2 p, float R) {\n\treturn length(p) - R;\n}\n//Симметричная капсула вдоль оси Z: L - половина длины, R - радиус\nfloat dfCapsule (vec3 p, float L, float R) {\n\t#if 0\n\t\tp.z -= clamp (p.z, -L, L);\n\t\treturn dfBall(p, R);\n\t#else\n\t\treturn length (p - vec3 (0., 0., clamp (p.z, -L, L))) - R;\n\t#endif\n}\n//Симметричный Цилиндр вдоль оси Z: R - радиус, L - половина длины\nfloat dfCylCappedZ (vec3 p, float R, float L) {\n\t#if 0\n\t\tfloat d_cyl_z = dfCyl(p.xy, R);\n\t\tfloat d_between_z = dfBetween0(p.z, L);\n\t\treturn AND (d_cyl_z, d_between_z);\n\t#else\n\t\treturn max(length (p.xy) - R, abs (p.z) - L);\n\t#endif\n}\n//Конус вдоль оси Z: b.x-угол , b.y- угол, b.z-высота\nfloat dfConeZ (vec3 p, vec3 b) {\n\t#if 0\n\t\tfloat d_cone = dfCyl(p.xy, -p.z*b.y/b.x)*b.x;\n\t\tfloat d_between = dfBetween0(p.z, b.z);\n\t\treturn AND (d_cone, d_between);\n\t#else\n\t\treturn max(dot (vec2 (length (p.xy), p.z), b.xy), abs (p.z) - b.z);\n\t#endif\n}\n","name":"Common","description":"","type":"common"}]}