{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const vec2 quiltSize = vec2(8., 5.);\n\n\nconst float numViews = quiltSize.x * quiltSize.y;\n\n#define TMOD (mod(iTime, 10.0))\n\n#define USE_PERSPECTIVE_X (TMOD >= 3.0 && TMOD < 5.0)\n#define USE_PERSPECTIVE_Y (TMOD < 8.0)\n\nconst float lineNumber = 19.6153;\nconst float obliquity = 0.10255;\nconst float screenWidth = 1440.0;\nconst float screenHeight = 2560.0;\n\n\nconst float pitch  = (screenWidth * 3. ) / lineNumber;\nconst float slope  = -obliquity * (screenHeight / screenWidth);\nconst float center = -(1.0 / 40. * 8.)\n//强迫症发病中\nconst float invView = 0.0;\n\n#define RENDER_AS_QUILT 0\n\n//原版texarr\n//vec2 texArr(vec3 uvz) {\n//    float z = floor(uvz.z * numViews);\n//    float x = (mod(z, quiltSize.x) + uvz.x) / quiltSize.x;\n//    float y = (floor(z / quiltSize.x) + uvz.y) / quiltSize.y;\n//    return vec2(x, y);\n//}\n\nvec2 texArr(vec3 uvz) {\n    float z = floor((1.0 - uvz.z) * numViews);\n\n    float x = (mod(z, quiltSize.x) + uvz.x) / quiltSize.x;\n    float y = (quiltSize.y - 1.0 - floor(z / quiltSize.x) + uvz.y) / quiltSize.y;\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float subp = 1.0 / (iResolution.x * 3.0);\n\n#if RENDER_AS_QUILT\n    fragColor = textureLod(iChannel0, fragCoord / iResolution.xy, 0.);\n#else\n    vec3 rgb;\n    vec2 uv = fragCoord / iResolution.xy;\n    for (int chan = 0; chan < 3; ++chan) {\n        float z = (uv.x + float(chan) * subp + uv.y * slope) * pitch - center;\n        z = mod(z + ceil(abs(z)), 1.0);\n        z = (1.0 - invView) * z + invView * (1.0 - z);\n        \n        vec2 iuv = texArr(vec3(uv, z));\n        rgb[chan] = textureLod(iChannel0, iuv, 0.)[chan];\n    }\n    fragColor = vec4(rgb, 1.0);\n#endif\n\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize the fragment coordinates and adjust for screen aspect ratio.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y; // Flip Y axis to match top-left origin.\n\n    // Define grid dimensions.\n    const int cols = 8;\n    const int rows = 5;\n\n    // Calculate the size of each cell.\n    vec2 cellSize = 1.0 / vec2(float(cols), float(rows));\n\n    // Determine which cell this fragment belongs to.\n    vec2 cellPos = floor(uv / cellSize);\n    int index = int(cellPos.y) * cols + int(cellPos.x);\n\n    // Ensure index is within bounds.\n    if (index >= 0 && index < cols * rows)\n    {\n        // Calculate the number to display in this cell.\n        int numberToShow = index + 1;\n\n        // Convert the number to a color for rendering.\n        float hue = mod(float(numberToShow) / 40.0 * 360.0, 360.0);\n        float s = 0.5, v = 0.9; // Saturation and Value\n\n        // Convert HSV to RGB.\n        float C = v * s;\n        float X = C * (1.0 - abs(mod(hue / 60.0, 2.0) - 1.0));\n        float m = v - C;\n        vec3 rgb;\n\n        if      (hue < 60.0) rgb = vec3(C, X, 0.0);\n        else if (hue < 120.0) rgb = vec3(X, C, 0.0);\n        else if (hue < 180.0) rgb = vec3(0.0, C, X);\n        else if (hue < 240.0) rgb = vec3(0.0, X, C);\n        else if (hue < 300.0) rgb = vec3(X, 0.0, C);\n        else                  rgb = vec3(C, 0.0, X);\n\n        rgb = clamp((rgb + m), 0.0, 1.0); // Add the m component and clamp the values.\n\n        // Draw the colored cell as background.\n        fragColor = vec4(rgb, 1.0);\n\n        // Calculate the normalized position inside the current cell.\n        vec2 localUV = fract(uv / cellSize) - 0.5;\n\n        // Draw dots inside the cell.\n        for (int dotIndex = 0; dotIndex < numberToShow; ++dotIndex)\n        {\n            // Calculate the angle and radius for each dot.\n            float angle = 2.0 * 3.141592 * float(dotIndex) / float(numberToShow);\n            float radius = 0.4 * sqrt(float(dotIndex + 1) / float(numberToShow)); // Adjust the radius as needed.\n\n            // Calculate the position of the dot relative to the center of the cell.\n            vec2 dotPos = vec2(cos(angle), sin(angle)) * radius;\n\n            // Check if the current pixel is close enough to the dot position.\n            float distToDot = length(localUV - dotPos);\n            float dotRadius = 0.05; // Dot size, can be adjusted.\n            if (distToDot < dotRadius)\n            {\n                // Color of the dot.\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black dots.\n            }\n        }\n    }\n    else\n    {\n        // If outside the grid, color the pixel black.\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    // Draw grid lines.\n    float lineWidth = 0.005;\n    if (fract(uv.x * float(cols)) < lineWidth || fract(uv.y * float(rows)) < lineWidth)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lfyfD3","date":"1734513424","viewed":36,"name":"C1 test","username":"pengshiqi","description":"谢谢小鑫！","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""}}