{"ver":"0.1","info":{"id":"dls3Wf","date":"1672650534","viewed":216,"name":"[steve] Happy New Year 2023","username":"import_shader_steve","description":"Happy New Year 2023! \nBased on The Art of Code's Newton's Cradle and Firework shaders.","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["newtonscradle","artofcode","happynewyear"],"hasliked":0,"parentid":"sdsXWr","parentname":"Newton's Cradle Tutorial"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\n#if HW_PERFORMANCE!=0\n#define USE_AA\n#endif\n\n#define S smoothstep\n#define T iTime\n\nconst int MAT_BASE=1;\nconst int MAT_BARS=2;\nconst int MAT_BALL=3;\nconst int MAT_LINE=4;\nconst int MAT_SEA = 5;\nconst int MAT_BUILDING_1 = 6;\nconst int MAT_HARBOR = 7;\nconst int MAT_SAFETYBAR_VERTICAL = 8;\nconst int MAT_SAFETYBAR_HORIZONTAL = 9;\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdLineSeg(vec3 p, vec3 a, vec3 b) {\n    vec3 ap=p-a, ab=b-a;\n    float t = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    vec3 c = a + ab*t;\n    return length(p-c);\n}\n\nvec2 sdBall(vec3 p, float a) {\n    \n    p.y-=1.01;\n    p.xy *= Rot(a);\n    p.y+=1.01;\n    \n    float ball = length(p)-.15;\n    float ring = length(vec2(length(p.xy-vec2(0, .15))-.03, p.z))-.01;\n    ball = min(ball, ring);\n    \n    p.z = abs(p.z);\n    float line = sdLineSeg(p, vec3(0,.15,0), vec3(0, 1.01, .4))-.005;\n    \n    float d = min(ball, line);\n    \n    return vec2(d, d==ball ? MAT_BALL : MAT_LINE);\n}\n\n// return a pseudo-random number from 0 to 1\nfloat Hash11(float n) {\n    return fract(sin(n * 456.23) * 112.45);\n}\n\n// return a pseudo-random 1 or 2\nint RandomColorChoice(float n) {\n    return int(ceil(sin(n * 135.46)));\n}\n\nfloat Random31_1(float x, float y, float z) {\n    return sin(x * 346.58) * 67.49 + cos(y * 178.21) * 94.92 + sin(z * 612.38) * 83.65;\n}\n\nfloat Random31_2(float x, float y, float z) {\n    return sin(x * 482.21) * 124.39 + cos(y * 348.12) * 659.4 + sin(z * 133.46) * 38.52;\n}\n\nfloat Random31_3(float x, float y, float z) {\n    return sin(x * 589.23) * 790.47 + cos(y * 117.86) * 348.59 + sin(z * 858.04) * 68.78;\n}\n\n// this is different from the above 3 random functions\nfloat Random31_4(float x, float y, float z) {\n    return fract(sin(x * 516.25) * 612.38 + cos(y * 385.71) * 156.97 + sin(z * 912.77) * 62.26 + iTime);\n}\n\nfloat Remap01(float lower, float upper, float x) {\n    return clamp((x-lower)/(upper-lower), 0., 1.);\n}\n\nvec3 Random13(float n) {\n    return vec3(0.);\n}\n\nfloat RandomBuildingZ(int n) {\n    return -5. + abs(sin(float(n+1) * 344.89)) * -5.; // [-5., -10.]\n}\n\nfloat RandomBuildingX(int n) {\n    return -6. + abs(cos(float(n+1) * 116.94)) * 12.; // [-6., 6.]\n}\n\nvec3 RandomBuildingShape(int id) {\n    float n = float(id);\n    float x = .1 + fract(sin(n * 90.32) * 46.54) * 1.9;\n    float y = 1. + fract(sin(n * 21.7) * 88.8) * 4.;\n    float z = .1 + fract(sin(n * 63.26) * 74.79) * .9;\n    return vec3(x, y, z); // vec3 ~ [.1 ~ 1., 1. ~ 3., .1 ~ 1.]\n}\n\nfloat sdSea(vec3 p) {\n    float d = p.y;\n    d += sin(p.x*5. + iTime)*.025 + sin(p.z*3. + iTime)*.01;\n    return d;\n}\n\nvec2 Min(vec2 a, vec2 b) {\n    return a.x<b.x ? a : b;\n}\n\nconst int NUM_BUILDINGS = 5;\nfloat sdBuildings(vec3 p) {\n    // first, generate the sdf of the first building\n    vec3 building_1_pos = vec3(RandomBuildingX(0), 0., RandomBuildingZ(0));\n    float building_1 = sdBox(p - building_1_pos, RandomBuildingShape(0)) - .1;\n    float d = building_1;\n    // and then, generate sdf's of the rest of the buildings, and compute the joint sdf\n    for (int i = 1; i < NUM_BUILDINGS; i++) {\n        vec3 next_building_pos = vec3(RandomBuildingX(i), 0., RandomBuildingZ(i));\n        float next_building = sdBox(p - next_building_pos, RandomBuildingShape(i)) - .1;\n        d = min(d, next_building);\n    }\n    return d;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSafetyBarVertical(vec3 p, float h, float r) {\n    // uncomment below lines to see each effect on warping space\n    // p.x = fract(p.x);\n    // p.x = fract(p.x) * 2.;\n    p.x = mod(p.x, 0.25);\n    return sdCappedCylinder(p, h, r);\n}\n\nfloat sdSafetyBarHorizontal(vec3 p, float h, float r) {\n    p.xy *= Rot(1.57);\n    return sdCappedCylinder(p, h, r);\n}\n\nvec2 GetDist(vec3 p) {\n    //float base = sdBox(p, vec3(1,.1,.5))-.1;\n    \n    float buildings = sdBuildings(p);\n    \n    float sea = sdSea(p);\n    \n    float d = min(buildings, sea);\n    \n    float harbor = sdBox(p - vec3(0., 0., -9.), vec3(12., .01, 4.)) - .03;\n    \n    d = min(d, harbor);\n    \n    float safetyBarVertical = sdSafetyBarVertical(p - vec3(0., 0., -5.5), .2, .02);\n    \n    d = min(d, safetyBarVertical);\n    \n    float safetyBarHorizontal_1 = sdSafetyBarHorizontal(p - vec3(0., 0.17, -5.5), 10., 0.005);\n    \n    d = min(d, safetyBarHorizontal_1);\n    \n    float safetyBarHorizontal_2 = sdSafetyBarHorizontal(p - vec3(0., 0.12, -5.5), 10., 0.005);\n    \n    d = min(d, safetyBarHorizontal_2);\n    \n    int mat = 0;\n    \n    if(d == sea) {\n        mat = MAT_SEA;\n    } else if(d == buildings) {\n        mat = MAT_BUILDING_1;\n    } else if (d == harbor) {\n        mat = MAT_HARBOR;\n    } else if (d == safetyBarVertical) {\n        mat = MAT_SAFETYBAR_VERTICAL;\n    } else if (d == safetyBarHorizontal_1 || d == safetyBarHorizontal_2) {\n        mat = MAT_SAFETYBAR_HORIZONTAL;\n    }\n        \n    return vec2(d, mat);\n}\n\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec2 dSMat = vec2(0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dSMat = GetDist(p);\n        dO += dSMat.x;\n        if(dO>MAX_DIST || abs(dSMat.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dSMat.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec4 Render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last) {\n    // first add background color/texture to every pixel in the scene\n    // vec3 col = texture(iChannel0, rd).rgb;\n    vec3 col = vec3(0.);\n    vec2 dMat = RayMarch(ro, rd);\n    \n    ref *= 0.;\n    \n    float alpha = 0.;\n    // and then do ray marching and add the material colors on top of background colors\n    if(dMat.x<MAX_DIST) {\n        vec3 p = ro + rd * dMat.x;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(0);\n        \n        int mat = int(dMat.y);\n        \n        float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 5.);\n        fresnel = mix(.01, .7, fresnel);\n        if(mat==MAT_BASE) {\n            col += dif*.05;\n            ref = vec3(1)*fresnel;\n        } else if(mat==MAT_BARS) {\n            ref = vec3(.8);\n        } else if(mat==MAT_LINE) {\n            col += dif*.1;\n        } else if(mat == MAT_SEA){\n            //col += 0.;\n            ref = vec3(150./255., 232./255., 249./255.);\n        }\n          else if(mat == MAT_HARBOR) {\n            vec3 harborColor = vec3(5. / 255.);\n            col += dif * harborColor;\n        } else if(mat == MAT_SAFETYBAR_VERTICAL) {\n            vec3 safetyBarVerticalColor = vec3(20. / 255.);\n            col += dif * safetyBarVerticalColor;\n        } else if(mat == MAT_SAFETYBAR_HORIZONTAL) {\n            vec3 safetyBarHorizontalColor = vec3(60. / 255.);\n            col += dif * safetyBarHorizontalColor;\n        } else if(mat == MAT_BUILDING_1) {\n            vec3 buildingColor = vec3(0.);\n            // below - old checker pattern\n            // below two lines of code: get both the quotient and remainder of p.xy * 10.0 and 2.0\n            // float checkerPattern = mod(floor(p.x*10.) + floor(p.y*10.), 2.0); // actually, checkerPattern only has 0 or 1 as output\n            // b/c floor(n) returns an integer, mod(an integer, 2.0) only returns 0 or 1\n            // float checkerIndex = floor((floor(p.x*10.) + floor(p.y*10.)) / 2.0);\n            // below - new checker pattern\n            // ncp - checker pattern\n            // nci - checker index\n            vec3 ncp = vec3(mod(floor(p.x*20.), 2.), mod(floor(p.y*20.), 2.), mod(floor(p.z*20.), 2.)); // vec3 ~ [0. or 1., 0. or 1., 0. or 1.]\n            // somehow p.x & p.y in nci need to time 40. instead of 20. in ncp\n            // maybe it's because we mod and divide by 2. => 20. * 2. == 40.\n            vec3 nci = vec3(floor(floor(p.x*40.) / 2.), floor(floor(p.y*40.) / 2.), floor(floor(p.z*40.) / 2.));\n            \n            // if (ncp.x + ncp.y + ncp.z == 1.) {\n            //     buildingColor = vec3(1., 0., 1.);\n            // }\n            \n            // if at a checker pattern cell without light\n            if (ncp.x + ncp.y + ncp.z == 1.) {\n                buildingColor = vec3(0., 0., 0.);\n              // if at a checker pattern cell with light\n            } else {\n                int color = RandomColorChoice(Random31_1(nci.x, nci.y, nci.z));\n                // bright yellow - (251, 218, 129)\n                // LED white - (212, 237, 224)\n                if (color == 1) {\n                    // pick a random yellow color\n                    float mixAmount = Hash11(Random31_2(nci.x, nci.y, nci.z));\n                    mixAmount = pow(mixAmount, mix(10., 20., Random31_4(nci.x, nci.y, nci.z)));\n                    buildingColor = mix(vec3(0., 0., 0.), vec3(251./255., 218./255., 129./255.), mixAmount);\n                    // pick a random white color\n                } else {\n                    float mixAmount = Hash11(Random31_3(nci.x, nci.y, nci.z));\n                    mixAmount = pow(mixAmount, mix(10., 20., Random31_4(nci.x, nci.y, nci.z)));\n                    buildingColor = mix(vec3(0., 0., 0.), vec3(212./255., 237./255., 224./255.), mixAmount);\n                }\n            }\n            \n            //if ((ncp.x == 1. && ncp.y == 0. && ncp.z == 0.) || (ncp.x == 0. && ncp.y == 1. && ncp.z == 0.) || (ncp.x == 0. && ncp.y == 0. && ncp.z == 1.)) {\n            //    buildingColor = vec3(1., 0., 1.);\n            //}\n            if (nci.x == 1. && nci.y == 5.) {\n                //buildingColor = vec3(0., 1., 0.);\n            }\n            // buildingColor = vec3(1. + 0.7*checkerPattern);\n            col += dif * buildingColor;\n        }\n            \n        ro = p + n*SURF_DIST*3.;\n        rd = r;\n        alpha = 1.0;\n    }\n    return vec4(col, alpha);\n}\n\nvec3 RenderAll(vec2 pixCoord) {\n    vec2 uv = (pixCoord-.5*iResolution.xy)/iResolution.y;\n\t//vec2 m = iMouse.xy/iResolution.xy;\n    vec2 m = vec2(.5, .5);\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.75,0), 2.);\n    vec3 col = vec3(0);\n    vec3 ref, fil=vec3(1);\n   \n    float numBounces = 2.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = Render(ro, rd, ref, i==numBounces-1.);\n        col += pass.rgb*fil;\n        \n        fil*=ref;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    vec3 col = RenderAll(fragCoord);\n    #ifdef USE_AA\n    col +=\n        RenderAll(fragCoord+vec2(.5,.0))+\n        RenderAll(fragCoord+vec2(.0,.5))+\n        RenderAll(fragCoord+vec2(.5,.5));\n    col /= 4.;    \n    #endif\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    \n    col += texture(iChannel0, uv - vec2(0., .35)).rgb;\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// \"Fireworks\" by Martijn Steinrucken aka BigWings - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n#define PI 3.141592653589793238\n#define TWOPI 6.283185307179586\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define saturate(x) clamp(x,0.,1.)\n\n#define NUM_EXPLOSIONS 8.\n#define NUM_PARTICLES 70.\n\n\n// Noise functions by Dave Hoskins \n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3, p3.yzx + 19.19);\n   return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat circ(vec2 uv, vec2 pos, float size) {\n\tuv -= pos;\n    \n    size *= size;\n    return S(size*1.1, size, dot(uv, uv));\n}\n\nfloat light(vec2 uv, vec2 pos, float size) {\n\tuv -= pos;\n    \n    size *= size;\n    return size/dot(uv, uv);\n}\n\nvec3 explosion(vec2 uv, vec2 p, float seed, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    vec3 en = hash31(seed);\n    vec3 baseCol = en;\n    for(float i=0.; i<NUM_PARTICLES; i++) {\n    \tvec3 n = hash31(i)-.5;\n       \n\t\tvec2 startP = p-vec2(0., t*t*.1);        \n        vec2 endP = startP+normalize(n.xy)*n.z;\n        \n        \n        float pt = 1.-pow(t-1., 2.);\n        vec2 pos = mix(p, endP, pt);    \n        float size = mix(.01, .005, S(0., .1, pt));\n        size *= S(1., .1, pt);\n        \n        float sparkle = (sin((pt+n.z)*100.)*.5+.5);\n        sparkle = pow(sparkle, pow(en.x, 3.)*50.)*mix(0.01, .01, en.y*n.y);\n      \n    \t//size += sparkle*B(.6, 1., .1, t);\n        size += sparkle*B(en.x, en.y, en.z, t);\n        \n        col += baseCol*light(uv, pos, size);\n    }\n    \n    return col;\n}\n\nvec3 Rainbow(vec3 c) {\n\t\n    float t=iTime;\n    \n    float avg = (c.r+c.g+c.b)/3.;\n    c = avg + (c-avg)*sin(vec3(0., .333, .666)+t);\n    \n    c += sin(vec3(.4, .3, .3)*t + vec3(1.1244,3.43215,6.435))*vec3(.4, .1, .5);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float n = hash12(uv+10.);\n    float t = iTime*.5;\n    \n    vec3 c = vec3(0.);\n    \n    for(float i=0.; i<NUM_EXPLOSIONS; i++) {\n    \tfloat et = t+i*1234.45235;\n        float id = floor(et);\n        et -= id;\n        \n        vec2 p = hash31(id).xy;\n        p.x -= .5;\n        p.x *= 1.6;\n        c += explosion(uv, p, id, et);\n    }\n    //c = Rainbow(c);\n    \n    fragColor = vec4(c, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}