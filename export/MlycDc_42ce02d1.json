{"ver":"0.1","info":{"id":"MlycDc","date":"1538925824","viewed":323,"name":"Roll Up","username":"shau","description":"  Tunnel experiment rotating cubes around a path ","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["3d","tunnel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define EPS .005\n#define FAR 160.\n#define T iTime * 8.\n#define PI 3.141592\n#define PI2 (PI * 2.)\n#define R iResolution.xy\n#define HASHSCALE1 .1031\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p) {\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//standard path deform - check out any tunnel by Shane or Aiekick for some good examples\nvec3 path(float t) {\n    float a = sin(t * PI / 24. + 1.7);\n    float b = cos(t * PI / 32.);\n    return vec3(a * 2., b * a * 2.4, 0.);\n} \n\n//IQ - Sphere functions\n//https://iquilezles.org/articles/spherefunctions\n//intersection\nfloat sphI(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.) return FAR;\n    h = sqrt(h);\n    return -b - h;\n}\n\n//density\nfloat sphD(vec3 ro, vec3 rd, vec4 sph, float d) {\n\n    float nd = d / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.;\n    float h = b * b - c;\n    if (h < 0.) return 0.;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0. || t1 > nd) return 0.;\n    t1 = max(t1, 0.);\n    t2 = min(t2, nd);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.);\n    \n    return (i2 - i1) * (3.0 / 4.0);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//neat trick from Shane\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\nvec2 map(vec3 p, vec2 ra) {\n    \n    vec2 t = vec2(FAR, 0.);  //miss\n\n    p = p + path(p.z);\n    p.z = mod(p.z, 2.) - 1.;\n    \n    //brute force\n    for (int i = 0; i < 10; i++) {        \n        vec3 q = p; //reset rotations every iteration\n        q.xy *= rot(ra.y * float(i));\n        t = nearest(t, vec2(sdBox(q - vec3(0., ra.x, 0.), vec3(0.8)), float(i))); \n        q.xy *= rot(ra.y * -float(i) * 2.);\n        t = nearest(t, vec2(sdBox(q - vec3(0., ra.x, 0.), vec3(0.8)), -float(i)));    \n    }\n\n    return t;    \n}\n\n//tetrahedral normal\nvec3 normal(vec3 p, vec2 ra) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx, ra).x + e.xxy * map(p + e.xxy, ra).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx, ra).x + e.yyy * map(p + e.yyy, ra).x);   \n}\n\nvec3 camera(vec2 uv, vec3 ro, vec3 la) {\n    float FOV = PI / 3.;\n    vec3 fwd = normalize(la - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    vec3 up = cross(fwd, rgt);\n\n    vec3 rd = normalize(fwd + FOV * uv.x * rgt + FOV * uv.y * up);\n    rd.xy *= rot(sin(-ro.x  * 0.5) * 0.3); //roll camera\n    \n    return rd;\n}\n\nvoid mainImage(out vec4 C, vec2 U) {\n    \n    float r = clamp(sin(T * 0.005) * 106. -106., -106., -6.); //tunnel radius\n    vec2 ra = vec2(r, atan(1. / r) * 2.); //segment rotation\n    \n    vec4 snd = texture(iChannel0, vec2(0.5) / R); //sound\n    \n    vec3 p = vec3(0.), \n         pc = p,\n         la = vec3(0., r + 6., T),\n         ro = vec3(0., r + 6., T - 20.);\n    \n    la -= path(la.z);\n    ro -= path(ro.z);\n    \n    vec2 uv = (U - R * .5) / R.y;\n    vec3 rd = camera(uv, ro, la);\n\n    //background\n    float a = (atan(rd.y, rd.x) / PI2) + .1;\n    float fla = floor(a * 24.) / 24.;\n    float fra = fract(a * 24.);\n    pc = mix(vec3(1., 0., 0.), vec3(1., 1., 0.), fla) * step(0.1, fra);\n    float mt = mod(rd.y + hash11(fla) * 4. - T * 0.01, 0.3);\n    pc *= step(mt, 0.16) * mt * 16. * max(rd.y, 0.);\n    \n    //ray marching\n    float t = 0.;\n    float id = 0.;\n    for (int i = 0; i < 64; i++) {\n        p = ro + rd * t;\n        vec2 si = map(p, ra);\n        if (si.x < EPS || t > FAR) {\n            id = si.y;\n            break;\n        }\n        t += si.x;\n    }\n    \n    //shade floor/wall\n    if (t > 0. && t < FAR) {\n        \n        vec3 n = normal(p, ra);\n        vec3 ld = normalize(la - p);\n        float lt = length(la - p);\n        float at = 1. / (1. + lt * lt * 0.02);\n        float df = dot(ld, n);\n        float spc = pow(max(dot(reflect(-ld, n), -rd), 0.), 8.);\n        float frs = pow(clamp(dot(n, rd) + 1., 0., 1.), 2.) * 2.;\n        \n        //colour surface\n        pc = vec3(1., .5, 0.) * df * at;\n        pc += vec3(1., 0., 0.) * frs * 0.2;\n        pc += vec3(1., .8, .6) * spc * 0.4;\n        pc *= at;\n        \n        //box center\n        vec3 bc = vec3(0., r, floor(p.z * 0.5) * 2.);\n        bc.xy *= rot(-ra.y * id);\n        bc -= path(bc.z);\n        float rnd = hash12(vec2(id, bc.z) + floor(T * 0.2));\n        \n        //march interior of cube\n        t = EPS * 4.;\n        for (int j = 0; j < 48; j++) {\n            vec3 ip = p + rd * t;\n            vec2 sii = map(ip, ra);\n            if (sii.x > 0.) break;\n            lt = 2. / (1. + length(bc - ip) * length(bc - ip) * .4);\n            float lt2 = 2. / (1. + length(la - ip) * length(la - ip) * .4);\n            pc += vec3(1.0, 0.0, 0.) * lt * lt2 * rnd * step(0.6, rnd) * step(rnd, 0.8) * snd.y;\n            pc += vec3(1., 0.5, 0.) * lt * lt2 * rnd * step(0.8, rnd) * snd.z;\n            t += 0.05;\n        }\n    }\n    \n    //glow ball\n    float st = sphI(ro, rd, vec4(la, 1.8));\n    if (st > 0. && st < FAR) {\n        float w = sphD(ro, rd, vec4(la, 1.8), FAR);\n        if (w > 0.) {\n           pc += vec3(1., 0., 0.) * w * w;    \n           pc += vec3(1., 1., 0.) * pow(w, 6.);    \n           pc += vec3(1.) * pow(w, 18.);    \n        }\n    }\n    \n    C = vec4(pc, 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 cs = texture(iChannel0, uv / iResolution.xy);\n    \n    float lvl = cs.x;\n    float low = cs.y;\n    float hi = cs.z;\n    \n    for (int x = 0; x < 512; x++) {\n        vec4 ns = texelFetch(iChannel1, ivec2(x , 0), 0);\n        lvl += ns.x;\n        if (x > 300) {\n            hi += ns.x;\n        } else {\n            low += ns.x;\n        }\n    }\n    \n    lvl /= 60.0;\n    low /= 100.0;\n    hi /= 80.0;\n    \n    fragColor = vec4(lvl, low, hi, 0.);    \n}","name":"Buffer A","description":"","type":"buffer"}]}