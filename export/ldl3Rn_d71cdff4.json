{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n\tby kioku / System K\n*/\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\nstruct Sphere\n{\n\tvec3 center;\n\tfloat radius;\n};\nstruct Plane\n{\n\tvec3 p;\n\tvec3 n;\n};\n\nstruct Intersection\n{\n\tfloat t;\n\tvec3 p;     // hit point\n\tvec3 n;     // normal\n\tint hit;\n};\n\nSphere sphere[3];\nPlane plane;\nfloat aspectRatio = 16.0/9.0;\nint seed = 0;\n\nvoid shpere_intersect(Sphere s, Ray ray, inout Intersection isect)\n{\n\tvec3 rs = ray.org - s.center;\n\tfloat B = dot(rs, ray.dir);\n\tfloat C = dot(rs, rs) - (s.radius * s.radius);\n\tfloat D = B * B - C;\n\n\tif (D > 0.0)\n\t{\n\t\tfloat t = -B - sqrt(D);\n\t\tif ( (t > 0.0) && (t < isect.t) )\n\t\t{\n\t\t\tisect.t = t;\n\t\t\tisect.hit = 1;\n\n\t\t\t// calculate normal.\n\t\t\tisect.p = ray.org + ray.dir * t;\n\t\t\tisect.n = normalize(isect.p - s.center);\n\t\t}\n\t}\n}\nvoid plane_intersect(Plane pl, Ray ray, inout Intersection isect)\n{\n\tfloat d = -dot(pl.p, pl.n);\n\tfloat v = dot(ray.dir, pl.n);\n\n\tif (abs(v) < 1.0e-6) {\n\t\treturn;\n\t} else {\n\t\tfloat t = -(dot(ray.org, pl.n) + d) / v;\n\n\t\tif ( (t > 0.0) && (t < isect.t) )\n\t\t{\n\t\t\tisect.hit = 1;\n\t\t\tisect.t   = t;\n\t\t\tisect.n   = pl.n;\n\t\t\tisect.p = ray.org + t * ray.dir;\n\t\t}\n\t}\n}\n\n\nvoid Intersect(Ray r, inout Intersection i)\n{\n\tfor (int c = 0; c < 3; c++)\n\t{\n\t\tshpere_intersect(sphere[c], r, i);\n\t}\n\tplane_intersect(plane, r, i);\n}\n\n\t\t\nvoid orthoBasis(out vec3 basis[3], vec3 n)\n{\n\tbasis[2] = vec3(n.x, n.y, n.z);\n\tbasis[1] = vec3(0.0, 0.0, 0.0);\n\n\tif ((n.x < 0.6) && (n.x > -0.6))\n\t\tbasis[1].x = 1.0;\n\telse if ((n.y < 0.6) && (n.y > -0.6))\n\t\tbasis[1].y = 1.0;\n\telse if ((n.z < 0.6) && (n.z > -0.6))\n\t\tbasis[1].z = 1.0;\n\telse\n\t\tbasis[1].x = 1.0;\n\n\n\tbasis[0] = cross(basis[1], basis[2]);\n\tbasis[0] = normalize(basis[0]);\n\n\tbasis[1] = cross(basis[2], basis[0]);\n\tbasis[1] = normalize(basis[1]);\n\n}\n\n\nfloat random()\n{\n\tseed = int(mod(float(seed)*1364.0+626.0,509.0));\n\treturn float(seed)/509.0;\n}\n\nvec3 computeAO(inout Intersection isect)\n{\n\tconst int ntheta = 8;\n\tconst int nphi   = 8;\n\tconst float eps  = 0.0001;\n\n\t// Slightly move ray org towards ray dir to avoid numerical problem.\n\tvec3 p = isect.p + eps * isect.n;\n\n\t// Calculate orthogonal basis.\n\t vec3 basis[3];\n\torthoBasis(basis, isect.n);\n\n\tfloat occlusion = 0.0;\n\n\tfor (int j = 0; j < ntheta; j++)\n\t{\n\t\tfor (int i = 0; i < nphi; i++)\n\t\t{\n\t\t\t// Pick a random ray direction with importance sampling.\n\t\t\t// p = cos(theta) / 3.141592\n\t\t\tfloat r = random();\n\t\t\tfloat phi = 2.0 * 3.141592 * random();\n\n\t\t\tvec3 ref;\n\t\t\tfloat s, c;\n\t\t\ts = sin(phi);\n\t\t\tc = cos(phi);\n\t\t\tref.x = c * sqrt(1.0 - r);\n\t\t\tref.y = s * sqrt(1.0 - r);\n\t\t\tref.z = sqrt(r);\n\n\t\t\t// local -> global\n\t\t\tvec3 rray;\n\t\t\trray.x = ref.x * basis[0].x + ref.y * basis[1].x + ref.z * basis[2].x;\n\t\t\trray.y = ref.x * basis[0].y + ref.y * basis[1].y + ref.z * basis[2].y;\n\t\t\trray.z = ref.x * basis[0].z + ref.y * basis[1].z + ref.z * basis[2].z;\n\n\t\t\tvec3 raydir = vec3(rray.x, rray.y, rray.z);\n\n\t\t\tRay ray;\n\t\t\tray.org = p;\n\t\t\tray.dir = raydir;\n\t\t\t\n\t\t\tIntersection occIsect;\n\t\t\toccIsect.hit = 0;\n\t\t\toccIsect.t = 1.0e30;\n\t\t\toccIsect.n = occIsect.p = vec3(0);\n\t\t\tIntersect(ray, occIsect);\n\t\t\tocclusion += (occIsect.hit != 0 ? 1.0 : 0.0);\n\t\t}\n\t}\n\n\t// [0.0, 1.0]\n\tocclusion = (float(ntheta * nphi) - occlusion) / float(ntheta * nphi);\n\treturn vec3(occlusion, occlusion, occlusion);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t\n\tvec3 dir = normalize(vec3((uv-0.5)*2.0*vec2(1.0,1.0/aspectRatio),-1.0));\n\tRay ray;\n\tray.org = vec3(0,0,0);\n\tray.dir = dir;\n\tIntersection it;\n\tit.hit = 0;\n\tit.n = vec3(0,0,0);\n\tit.p = vec3(0,0,0);\n\tit.t = 10000.0;\n\t\t\t\n\tsphere[0].center = vec3(-2.0, 0.0, -3.5);\n\tsphere[0].radius = 0.5;\n\tsphere[1].center = vec3(-0.5, 0.0, -3.0);\n\tsphere[1].radius = 0.5;\n\tsphere[2].center = vec3(1.0, 0.0, -2.2);\n\tsphere[2].radius = 0.5;\n\tplane.p = vec3(0,-0.5, 0);\n\tplane.n = vec3(0, 1.0, 0);\n\tIntersect(ray,it);\n\t\n\tseed = int(mod((dir.x+0.5) * (dir.y+0.5) * 452534.0, 65536.0));\n\tfragColor = \tvec4(computeAO(it),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldl3Rn","date":"1361810289","viewed":1544,"name":"AOBench","username":"kioku","description":"The most popular CG benchmark all over the world.<br>\nSee site: https://code.google.com/p/aobench/ <br>\nTry extream AOBench! http://aobench.com/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["aobench"],"hasliked":0,"parentid":"","parentname":""}}