{"ver":"0.1","info":{"id":"3dKGzG","date":"1570612033","viewed":644,"name":"Spherical texture projection","username":"blueneosky","description":"Sphere projection test","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["texture","sphere","projection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// modify these to change some aspect\nconst bool withTilingBorderGradient = true;\nconst float tilingBorderGradiantAngle = PI_8;\nconst float zoomShader = 1.0;\nconst int shaderIndex = 4;\n\nvec3[3] smoothSphereToCubicTiling(vec2 ang, float smoothAng) {\n    if(smoothAng <.0) smoothAng = -smoothAng;\n\tif(smoothAng > PI_2)\n        return vec3[] (vec3(.0), vec3(.0), vec3(.0));\n\n    float t1 = PI_4 - .5 * smoothAng;\n    float t2 = PI_4 + .5 * smoothAng;\n    \n    // the pole\n    vec3 uv1;\n    {\n    \tfloat r = (PI_2-abs(ang.y));\t//radius from center to border\n        float body = 1. - smoothstep(t1, t2, r);\n        vec2 uv = sign(ang.y) * vec2(r*cos(ang.x), r*sin(ang.x))/ PI_4;\n        uv1 = body > 0. ? vec3(uv, body) : vec3(0.);\n    }\n    \n    // the 'current' tile\n    vec3 uv2;\n    float n = floor((ang.x+PI_4) / PI_2);\n    float tiled_lttd = ang.y;\n    float tiled_lgtd = ang.x - n*PI_2;\n    {\n        float body = (1. - smoothstep(t1, t2, abs(tiled_lgtd)))\n            \t   * (1. - smoothstep(t1, t2, abs(tiled_lttd)));\n        vec2 uv = vec2(tiled_lgtd, tiled_lttd) / PI_4;\n        uv2 = body > 0. ? vec3(uv, body) : vec3(0.);\n    }\n    \n    // the 'side' tile (left or right)\n    vec3 uv3;\n    {\n        tiled_lgtd -= sign(tiled_lgtd) * PI_2;\n        float body = (1. - smoothstep(t1, t2, abs(tiled_lgtd)))\n            \t   * (1. - smoothstep(t1, t2, abs(tiled_lttd)));\n        vec2 uv = vec2(tiled_lgtd, tiled_lttd) / PI_4;\n        uv3 = body > 0. ? vec3(uv, body) : vec3(0.);\n\t}\n    \n    float err = (uv1+uv2+uv3).z;\n    vec3 err_cor = vec3(1.);\n    if(err > 1.)\n        err_cor.z = 1./err;\n    \n    vec3[] result = vec3 [] (\n        uv1 * err_cor,\n        uv2 * err_cor,\n        uv3 * err_cor );\n   \t\n    return result;\n}\n\n/* no more used - first attempt*/\nvec3[1] sphereToCubicTiling(vec2 ang) {\n    float tiledLgtd, tiledLttd;\n    if(abs(ang.y)> PI_4)\n    {\n        // poles\n        float r = (PI_2-abs(ang.y));\t//radius from center to border\n        tiledLgtd = r*cos(ang.x);\n        tiledLttd = r*sin(ang.x);\n    } else {\n        // horizontal tiled\n        tiledLgtd = mod(ang.x+PI_4, PI_2) - PI_4;\n    \ttiledLttd = mod(ang.y+PI_4, PI_2) - PI_4;\n    }\n\tvec2 puv = vec2(tiledLgtd, tiledLttd) / PI_4;\n\n    return vec3 [1] ( vec3(puv, 1.) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y; // -1 to 1\n\n    // sphere rotation by mouse\n    vec4 s_polb = mouseRotatedSpherePolarBody(uv, 1., iMouse.xy, iResolution.xy);\n    float s_body = s_polb.w;\n    \n    // select tiling\n    vec3[] sh_uvs = smoothSphereToCubicTiling(s_polb.yz, tilingBorderGradiantAngle);\n    //vec3[] sh_uvs = sphereToCubicTiling(s_polb.yz);\n    \n    vec3 col = vec3(0.);\n    for (int i = 0; i<sh_uvs.length(); i++) {\n        vec3 sh_uv = sh_uvs[i];\n        if(sh_uv.z>.0) {\n        \tvec3 t_col;\n\n        \t// select shader\n            vec2 puv = sh_uv.xy / zoomShader;\n            if(shaderIndex==0) t_col = basicShader(puv, iTime);\n            if(shaderIndex==1) t_col = squareShader(puv, 1., iTime);\n    \t\tif(shaderIndex==2) t_col = testShader(puv, iTime);\n            if(shaderIndex==3) t_col = 1.-vec3(sh_uv.z);\n            if(shaderIndex==4) t_col = texture(iChannel0, .5*(sh_uv.xy+1.)).xyz;\n        \t\n        \tcol += t_col * (withTilingBorderGradient ? sh_uv.z : 1.);\n    \t}\n    }\n\n    // global sphere body\n    col *= s_body;\n                        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI_2 = asin(1.);\nconst float PI = 2. * PI_2;\nconst float PI_4 = PI_2/2.;\nconst float PI_8 = PI_2/4.;\nconst float D_PI = 4. * PI_2;\n\n/*======= transformation methods =====*/\n\nvec4 spherePolarBody(in vec2 uv, in float radius) {\n    float l = length(uv);\n    if(radius != 1.) uv /=radius;\n    \n    float body = 1.-smoothstep(.95*radius, radius, l);\n    if(body == .0)\n        return vec4(.0);\n    \n    float lttd = asin(uv.y);\n    float rlttd = cos(lttd);\n    float lgtd = asin(uv.x / rlttd);\n    \n    return vec4(radius, lgtd, lttd, body);\n}\n\nvec3 rotation(in vec3 pt, vec2 ang) {\n    float cy = cos(ang.y);\n    float sy = sin(ang.y);\n    mat3 matZtoY = mat3(1., 0., 0.,\n                        0., cy, -sy,\n                        0., sy, cy);\n\n    float cx = cos(ang.x);\n    float sx = sin(ang.x);\n    mat3 matZtoX = mat3(cx, 0., -sx,\n                        0., 1., 0,\n                        sx, 0., cx);\n\n    return matZtoX * (matZtoY * pt);\n}\n\nvec3 polar(in vec3 pt) {\n    float l = length(pt);\n    \n    if(l == 0.) return vec3(0.);\n    \n    if(l != 1.) pt /= l; // normalize\n    \n    float lttd = asin(pt.y);\n    float rlttd = cos(lttd);\n    float lgtd;\n    // note: asin(pt.x / rlttd) fail for lttd close to +-PI_2 (precision loss)\n    if(abs(pt.x) <.8*rlttd) {\n    \tlgtd= asin(pt.x / rlttd);\n    \tif(pt.z<0.) lgtd = PI - lgtd;\n    } else {\n        lgtd = acos(pt.z / rlttd);\n        if(pt.x<0.) lgtd = -lgtd;\n    }\n    \n    return vec3(l, lgtd, lttd);\n}\n\nvec4 mouseRotatedSpherePolarBody(in vec2 uv, float radius, vec2 M, vec2 R) {\n    vec4 s_polb = spherePolarBody(uv, radius);\n    vec3 s_pol = s_polb.xyz;\n    float s_body = s_polb.w;\n    if(s_body == 0.) return vec4(0.);\n    \n   \tvec3 s_pt = rotation(vec3(.0, .0, 1.), s_pol.yz);\n\n    // mouse\n    //if(false)\n    {\n        vec2 mfilter = vec2(1., 1.);\n       \tvec2 m_pol = mfilter * D_PI * (2.*M.xy-R.xy)/R.y; // -2PI to 2PI\n        // rotate the point following the mouse\n        s_pt = rotation(s_pt, -m_pol);\n    }\n        \n    s_pol = polar(s_pt);\n    \n    return vec4(s_pol, s_body);\n}\n\n/*======= some 'shaders' =============*/\nvec3 basicShader(in vec2 uv, in float iTime) { return (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4))); }\n\nvec3 squareShader(in vec2 uv, in float s, in float iTime) {\n    float body =   (1.-smoothstep(.95*s, s, abs(uv.x)))\n                  *(1.-smoothstep(.95*s, s, abs(uv.y)));\n    vec3 col = body*(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n    \n    return col;\n}\n\nfloat psin(float v) { return .5*(1.+sin(v)); }\nfloat pcos(float v) { return .5*(1.+cos(v)); }\n\nvec3 testShader(in vec2 uv, in float iTime) {\n    float colR = -log(.7*length(uv)) * sin(uv.x*2. + uv.y + 3.*iTime);\n    float colG = psin(2.*(uv.x-0.3+3.*sin(iTime))) * pcos(3.*uv.y + .4*iTime);\n    float colB = abs(pcos(uv.y+ 1.*iTime));\n    \n    float cross = 1.;//smoothstep(0., 0.01, min(abs(uv.x), abs(uv.y)));\n    \n    return vec3(colR, colG, colB)*cross*cross;\n}\n\n/*====================================*/\n","name":"Common","description":"","type":"common"}]}