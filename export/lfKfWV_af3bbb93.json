{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// The MIT License\n// Copyright Â© 2024 Jake Rice\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/* \nAuthors notes:\n\nI pray that this does not crash your webgl.\n\nThis is my attempt at finding the distance to the edges of L4 voronoi, part of my quest to find the distance to edges of voronoi in all norms. \nTechnically this methodology works for all voronoi norms >= 2 (but works best when the norm is even valued). But numerically it will probably fall apart at anything bigger \nthan L8... The idea is to move the problem into 3d as voronoi boundaries are at the intersections of 3d paraboloids. And to find the boundaries you can use the idea of \"Alternating Projections\", which\nis a method for finding points on the intersection of convex sets!\n\nIt's unfortunately an iterative method, and webgl will crash if I really crank up the iterations, so there are some artifacts in certain voronoi configurations.\n\nAlso if I've done anything really stupid here please let me know :) I want to make this work and also have it be fast!\n\nI'm gonna go eat dinner now, it's important to listen to your body. Make sure you get your heart rate up for at least 30 minutes, 3 times a week. Don't forget to\ndrink water either. But not too much, we don't want you to drown.\n\n<3\n*/\n#define ANIMATE \n\n\n\n#define L6 0\n\n\n\n\nfloat f(float x){\n    #if !L6\n    return x * x * x * x;\n    #else\n    return x * x * x * x * x * x;\n    #endif\n}\n\n\n\nfloat f_prime(float x){\n    #if !L6\n    return 4.0  * (x * x * x);\n    #else\n    return 6.0  *(x * x * x * x * x);\n    #endif\n}\n\nfloat f_prime2(float x){\n    #if !L6\n    return 12.0 * (x * x);\n    #else\n    return 30.0  *(x * x * x * x);\n    #endif\n    \n}\n\n\n\nvec3 paraboloid(vec2 x,  vec2 c){\n    return vec3(x.x, x.y, f(x.x - c.x)  + f(x.y - c.y));\n}\n\n\n/*\n\nGiven a point in 3d space, (p0,p1,p2), \nthe center of a paraboloid (a,b) \nand a function f() such that (a, b, f(x - a) + f(y - b)) is a convex paraboloid\n\nfind the 2d position (x,y), such that it minimizes:\n\n(x - p0)^2 + (y - p1)^2 + (f(a - x) + f(b - y) - p2)^2\n\n\nwhich in lay speak just means, find the (x,y) values that it minimizes the distance from our point in 3d space to the paraboloid centered at (a,b)\n\nto do this we can use newtons method which means we need to differentiate our inputs with respect to x and y, twice to get a jacobian and hessian.\n\nthis will work with varying success for most convex functions f(), but the amount of iterations needed may be extreme...\n*/\n\nvec2 jacobian(float x,float y, float a, float b, float p0, float p1, float p2){\n    float dx = 2.0 * (x - p0) + 2.0 * (f(x - a) + f(y - b) - p2) * f_prime(x-a);\n    float dy = 2.0 * (y - p1) + 2.0 * (f(x - a) + f(y - b) - p2) * f_prime(y-b);\n    return vec2(dx, dy);\n}\nmat2 hessian(float x,float y, float a, float b, float p0, float p1, float p2){\n    float dxx =  2.0 * (f(x - a) + f(y - b) - p2) * f_prime2(x-a) + 2.0 * f_prime(x-a) * f_prime(x - a) + 2.0;\n    float dyy =  2.0 * (f(x - a) + f(y - b) - p2) * f_prime2(y-b) + 2.0 * f_prime(y-b) * f_prime(y - b) + 2.0;\n    float dxy = 2.0 * f_prime(x - a) * f_prime(y - b);\n    return mat2(dxx, dxy, dxy, dyy);\n}\n\nfloat length2(vec3 a){\n    return dot(a,a);\n}\n\n//safe inversion which just returns 0 if the matrix is degenerate\nmat2 invert2(mat2 m) {\n  float det = (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n  float inv_det = 0.;\n  if(det > 1e-4){\n    inv_det = 1. / det;\n  }\n  \n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) * inv_det;\n}\n\nvec2 l4_normalize(vec2 a){\n    vec2 a_l4 = (a * a * a * a); \n    float denom = pow(a_l4.x + a_l4.y,1./4.0);\n    return a / denom;\n}\n\nvec2 l6_normalize(vec2 a){\n    vec2 a_l6 = (a * a * a * a * a * a); \n    float denom = pow(a_l6.x + a_l6.y,1./6.0);\n    return a / denom;\n}\n\n\nvec2 ln_normalize(vec2 a, float n){\n    return a / pow(abs(pow(a.x, n) + pow(a.y, n)),1./n);\n}\n\n\n/*\nit's important to pick a good initial guess for newtons method. In this case we use the point on the paraboloid who's height\nis equal to our current height, and is facing our current point.\n*/\n\nvec3 newtons_method_for_nearest_point_on_paraboloid(vec3 a, vec2 center){\n    vec2 guess = vec2(a.x, a.y);\n    \n    #if !L6\n    guess = center + l4_normalize(guess - center) * pow(a.z, 1. / 4.0);\n    #else\n    guess = center + l6_normalize(guess - center) * pow(a.z, 1. / 6.0);\n    #endif\n    \n    int i = 0;\n    while(i < 100){\n        vec2 jac = jacobian(guess.x, guess.y, center.x, center.y, a.x, a.y, a.z);\n        mat2 hess = hessian(guess.x, guess.y, center.x, center.y, a.x, a.y, a.z);\n        vec2 dir = -invert2(hess) * jac;\n        vec2 guess_new = guess  + dir;\n\n        if(length(guess_new - guess) < 1e-6) break;\n\n        \n        guess = guess_new;\n        i++;\n    \n    }\n    return paraboloid(guess, center);\n}\n\n\n\n\n//hash2 shamelessly stolen from IQ <(^.^<)\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n/*\nThe intersection boundaries of voronoi in R^N is equivalent finding the intersections of R^N+1 paraboloids\n\nIn our case we will use alternating projections to find the nearest point on the R^3 paraboloids described by our voronoi points and metric\nAlternating Projections is a simple algorithm for finding an intersection between two convex sets. Unfortunately it may not always be the closest\nintersection point. To get that, one could use Dykstra's algorithm (not to be confused with Dijkstra's. Algorithm). However in this case, alternating projections\nseems to work well.\n\nConvergence issues: \nUnfortunately alternating projections is an iterative method, and while convergence is gauranteed, it may not be quick...\nPlus numerical issues suck butt!\n\n*/\n\nvec3 alternating_projections(vec3 x_in, vec2 c0, vec2 c1){\n    vec3 x = x_in;\n    int i = 0;\n    while(i < 500){\n        vec3 x0 = newtons_method_for_nearest_point_on_paraboloid(x, c1);\n        vec3 x1 = newtons_method_for_nearest_point_on_paraboloid(x0, c0);\n        if(length(x1 - x) < 1e-6) break; \n        x = x1;\n        i++;\n    }\n    return x;\n}\n\n\n/*\nvoid insert_element(float dist, int index){\n\n}\n*/\n\n\n//this portion is all based on IQ's Voronoi Edge Shader\n//any additions have been commented\nvec3 voronoi( in vec2 x, out vec2 gradient, out vec2 cell)\n{\n    vec2 shade_n = floor(x);\n    vec2 shade_f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr, mr_2;\n    int nearest_index;\n    float md = 100.0;\n    \n\n    //find nearest voronoi point\n    \n    for( int k=0; k<9; k++ )\n    {\n        int i = k / 3 - 1;\n        int j = k % 3 - 1;\n               \n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( shade_n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.35*sin( iTime * .1 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - shade_f;\n        \n        //L4 or L6 distance depending on the setting\n        float d = f(r.x) +f(r.y);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            cell = o;\n            nearest_index = k;\n        }\n    }\n  \n\n    //world space paraboloid center\n    vec2 voronoi_center0 = shade_n + mg + cell;\n        \n        \n    \n    int indices[5] = int[](-1,-1,-1,-1,-1);\n    float dists[5] = float[](1e10,1e10,1e10,1e10,1e10);\n    \n    //build a list of the 5 nearest voronoi centers in L2.\n    for( int k=0; k<25; k++ )\n    {\n        //skip ourself\n        if(k == 12) continue;\n        \n        int i = k / 5 - 2;\n        int j = k % 5 - 2;\n        \n\n        \n        vec2 g = mg + vec2(float(i),float(j)); //centered at our found voronoi point. if our voronoi point is (1,1) then its the region around(1,1)\n\t\tvec2 o = hash2( shade_n + g ); //hash based off our centering around the voronoi point\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.35*sin( iTime * .1 + 6.2831*o );\n        #endif\t\n        vec2 voronoi_center1 = (g + o + shade_n);\n        vec2 avg = (voronoi_center0 + voronoi_center1) * .5;\n        \n        //get exact voronoi neighbors :) \n        float d = dot(x - avg, normalize(voronoi_center0 - voronoi_center1));\n        \n        //create an ordered list of closest neighbors :) \n        for(int l = 0; l <5; l++){\n            if(d <= dists[l]){\n                for(int ii = 4; ii > l; ii--){\n                    dists[ii] = dists[ii - 1];\n                    indices[ii] = indices[ii - 1];\n                }\n                dists[l] = d;\n                indices[l] = k;\n                break;\n            \n            }\n        }\n\n    }\n    \n    \n    //----------------------------------\n    // second pass: distance to borders\n    //---------------------------------\n    \n    md = 1e10; //starting distance\n    \n\n    \n    //starting position on paraboloid\n    vec3 x_start  = paraboloid(x, voronoi_center0);\n    \n    \n    for(int k = 0; k < 5; k++)\n    {\n        int i = indices[k] / 5 - 2;\n        int j = indices[k] % 5 - 2;\n        \n\n        vec2 g = mg + vec2(float(i),float(j)); //centered at our found voronoi point. if our voronoi point is (1,1) then its the region around(1,1)\n\t\tvec2 o = hash2( shade_n + g ); //hash based off our centering around the voronoi point\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.35*sin( iTime * .1 + 6.2831*o );\n        #endif\t\n\n        \n\t\t//get the world space voronoi center \n        vec2 voronoi_center1 = shade_n + g + o;\n        \n        \n        //get point on intersection boundary\n        vec3 x_out = alternating_projections(x_start, voronoi_center0, voronoi_center1);\n        \n        //distance to intersection boundary\n        float dist = length(x_out.xy - x);\n        md = min(md, dist); //minimum distance\n            \n    }\n\t\n    return vec3(md);//vec3( float(indices[0]) / 25.0, mr );\n}\n\n//Visualization also shamelessly stolen from IQ (>^.^)>\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = fragCoord/iResolution.xx;\n    vec2 grad = vec2(0.);\n    vec2 cell = vec2(0.);\n    vec3 c = voronoi(5.0*p, grad, cell);\n    vec3 col = vec3(c.x);\n\n\n    \n    //isolines\n    col += c.x * pow(0.5 + 0.5*sin(200.0*c.x + iTime * .1), 1.) *vec3(2.0);\n    // borders\t\n    col = mix( vec3(1.), col, pow(smoothstep( 0.002, 0.015, c.x ), 1.) );\n\t\n\n\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lfKfWV","date":"1734487358","viewed":170,"name":"Distances to L4 Voronoi","username":"curice","description":"Approximated distance to L4 voronoi cell boundaries. Unfortunately if I really try to make it exact I will crash webgl, and or things will be super slow. Sorry! But either way this idea extends to any dimension, and for any L-Norm metric greater than 2.","likes":3,"published":3,"flags":0,"usePreview":1,"tags":["math","convex","distance","optimization","science","metric","love","distances","projections","alternating","moroni","l4"],"hasliked":0,"parentid":"","parentname":""}}