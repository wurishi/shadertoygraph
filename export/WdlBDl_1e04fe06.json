{"ver":"0.1","info":{"id":"WdlBDl","date":"1589338210","viewed":156,"name":"SphereTestLight","username":"RoyaleNoir","description":"Raytracing Spaghetti code","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EP 0.0001\n\n//This code is really ugly\nfloat sI(vec3 o, vec3 d, vec3 c, float r)\n{\n    vec3 pC = (c + vec3(0, -r, 0));\t//TODO: make this not broken\n    vec3 pN = normalize(vec3(0, 1, 0));\n    \n    float plane = dot(pC - o, pN) / dot(d, pN);\n    \n    //return plane;\n    \n    float A = dot(d, d);\n    float B = 2.0 * dot(d, (o - c));\n    float C = dot((o - c), (o - c)) - r * r;\n    \n    float t1 = (-B + sqrt(B*B - 4.*A*C)) / (2. * A);\n    float t2 = (-B - sqrt(B*B - 4.*A*C)) / (2. * A);\n    \n    if(t2 < -EP)\n    {\n        return plane;\n    }\n    \n    return min(t1 > EP ? t1 : t2, t2);\n}\n\n\nfloat sIC(in vec3 o, in vec3 d, in vec3 c, in float r, out vec3 albedo)\n{\n    vec3 pC = (c + vec3(0, -r, 0));\n    vec3 pN = normalize(vec3(0, 1, 0));\n    \n    float plane = dot(pC - o, pN) / dot(d, pN);\n    \n    //return plane;\n    \n    float A = dot(d, d);\n    float B = 2.0 * dot(d, (o - c));\n    float C = dot((o - c), (o - c)) - r * r;\n    \n    float t1 = (-B + sqrt(B*B - 4.*A*C)) / (2. * A);\n    float t2 = (-B - sqrt(B*B - 4.*A*C)) / (2. * A);\n    \n    //Everything breaks if I don't do these\n    if(t2 >= -EP)\n    {\n        albedo = vec3(.8, .2, .1);\n    }\n    else\n    {\n        albedo = vec3(.8, .8, .8);\n    }\n    \n    \n    if(t2 < -EP)\n    {\n        return plane;\n    }\n    \n    return min(t1 > EP ? t1 : t2, t2);\n}\n\nvec3 normal(vec3 o, vec3 d, vec3 c, float r)\n{\n    vec3 n = normalize(vec3(\n        sI(o + vec3(EP, 0, 0), d, c, r) - sI(o - vec3(EP, 0, 0), d, c, r),\n        sI(o + vec3(0, EP, 0), d, c, r) - sI(o - vec3(0, EP, 0), d, c, r),\n        sI(o + vec3(0, 0, EP), d, c, r) - sI(o - vec3(0, 0, EP), d, c, r)\n        ));\n    return n;\n}\n\nfloat Schlick(float cosTheta, float R0)\n{\n    return R0 + (1.0 - R0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//vec3 because I'm lazy\nvec3 vogelDisk(int index, int range, float off)\n{\n    float goldenAngle = 2.4;\t//Close enough, accurate in radians to ~5 s.f.\n    float theta = float(index) * goldenAngle + off * 6.28;\n    float r = sqrt(float(index))/sqrt(float(range));\n    \n    return vec3(r * cos(theta), 0, r * sin(theta));\n}\n\n//Big boy PCF\nfloat calcShadow(vec3 vX, vec3 vL, vec3 sphere, float r)\n{\n    int SAMPLES = 4;\n    \n    float shadow = 0.0;\n    float num;\n    \n    //Blue noise\n    float offset = texture(iChannel0, gl_FragCoord.xy / iChannelResolution[0].xy).r;\n    \n    for(int i = 1; i < SAMPLES + 1; i++)\n    {\n        vec3 light = normalize(vL + 0.1 * vogelDisk(i, SAMPLES, offset));\n        shadow += (sI(vX, light, sphere, r)) > EP? 0.0 : 1.0;\n        num += 1.0;\n    }\n    \n    return (shadow / num) * 0.9 + 0.1;\n}\n\nvec3 GetImage(in vec3 rO, in vec3 rD, in float lastMask, out float mask, out vec3 pos, out vec3 dir)\n{\n    vec3 lightDir = normalize(vec3(sin(iTime), 1, cos(iTime)));\n    vec3 sphere = vec3(0, 0, 5);\n    \n    vec3 albedo;\n    \n    float vS = sIC(rO, rD, sphere, 2.0, albedo);\n    vec3 vN = normal(rO, rD, sphere, 2.0);\t//N\n    vec3 vL = lightDir;\t\t\t\t\t    //L\n   \n    vec3 vX = rO + rD * vS;\n    \n    vec3 vR = reflect(rD, vN);\n    \n    float vShadow = calcShadow(vX, vL, sphere, 2.0);\n    float vAtten = dot(vN, vL) * vShadow;\n    vec3 main = albedo * max(vAtten, 0.0);\n    \n    float vMask = vS > EP ? 1.0: 0.0;\n    float lMask = lastMask;\n    \n    mask = vMask * lMask * Schlick(dot(-rD, vN), 0.04);\n    pos = vX;\n    dir = vR;\n    \n    return mix(vec3(0.1), main, vMask) * lMask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    //RayTracing\n    vec3 rO = vec3(0, 1, -1);\n    vec3 rD = normalize(vec3(uv, 0.5));\n    \n    float mask = 1.0;\n\n    vec3 pos = rO;\n    vec3 dir = rD;\n    \n    vec3 fin;\n    \n    for(int i = 0; i < 3; i++)\n    {\n   \t\tfin += GetImage(pos, dir, mask, mask, pos, dir);\n    }\n    \n    // Output to screen\n    fragColor = vec4(fin, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Ray Struct / Helper functions\n//A ray is defined as an origin, a (normalized) direction vector, and a multiplier\nstruct Ray\n{\n    vec3 o;\t//Origin\n    vec3 d;\t//Direction\n};\n\n//Gets the position of a ray\nvec3 getRayPos(Ray r, float t)\n{\n    return r.o + r.d * t;\n}\n\nRay createRay(vec3 o, vec3 d)\n{\n    Ray r;\n    r.o = o;\n    r.d = d;\n    return r;\n}\n\nRay reflectRay(Ray r, float t, vec3 n)\n{\n    vec3 pos = getRayPos(r, t);\n    \n    return createRay(pos, reflect(r.d, n));\n}","name":"Common","description":"","type":"common"}]}