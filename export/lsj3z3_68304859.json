{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Created by tux\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Much of the noise, fbm, and tracing code taken from the elevated shader toy by the awesome iq.\n// The contribution of this toy is to show a different method of triplanar mapping that is more tailored\n// to height maps given the observation that the xy and zy planes are likely going to introduce stretching.\n// Instead if we pick planes that are informed by the terrain we can get much better results. (in this case hard\n// coded to 45 degrees).\n\n// =========  From other shader toys ==========\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 57.0);\n    float d = hash(n+ 58.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\t\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n\n\treturn f/0.875;\n}\n\n\nfloat terrain( in vec2 p)\n{\n\treturn fbm(p * 0.2) * 3.0;\t\n}\n\nfloat map( in vec3 p )\n{\n    return p.y - terrain(p.xz);\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n\tfloat e = 0.001;\n\te = 0.0001*t;\n    vec3  eps = vec3(e,0.0,0.0);\n    vec3 nor;\n    nor.x = map(pos+eps.xyy) - map(pos-eps.xyy);\n    nor.y = map(pos+eps.yxy) - map(pos-eps.yxy);\n    nor.z = map(pos+eps.yyx) - map(pos-eps.yyx);\n    return normalize(nor);\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tfloat maxd = 40.0;\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n\tfloat d = 0.0;\n    float m = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n        if( h<precis||t>maxd ) continue;//break;\n        t += h * 0.5;\n\t    h = map( ro+rd*t );\n    }\n\t\n\tt = h < precis ? t : -1.0;\n\n    return t;\n}\n// ========= End From other shader toys ==========\n\n// draw a checkerboard based on the uv\nfloat checkerboard(vec2 uv)\n{\n\tuv = fract(uv);\n\treturn ((uv.x < 0.5 && uv.y < 0.5) || (uv.x > 0.5 && uv.y > 0.5)) ? 0.0 : 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*.15;\n\t\n\t// Normal set up code for ray trace.\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tvec2 s = (-1.0 + 2.0* xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\t\n\tvec3 ro = vec3(sin(time * 0.1) * 10.0, 3.0, cos(time * 0.1) * 10.0);\n\tvec3 cd = normalize(vec3(-0.5, -0.5, -0.5));\n\tvec3 cu = vec3(0.0, 1.0, 0.0);\n\tvec3 cr = normalize(cross(cd, cu));\n\tcu = normalize(cross(cr, cd));\n\n\tvec3 rd = normalize( s.x*cr + s.y*cu + 2.0*cd );\n\n\tvec3 col = vec3(0.0, 1.0, 0.0);\n    float t = intersect(ro, rd);\n    if(t > 0.0)\n    {\t\n\t\t// Get some information about our intersection\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 normal = calcNormal(pos, t);\n\t\t\n\t\t// Hang on to the sign of the normal because\n\t\t// we will be testing against the pairs of planes at the same time\n\t\tvec3 signs = sign(normal);\n\t\t\n\t\t// Calculate some weights for blending.\n\t\t// Note: I used the normal weights from tri planar assuming the\n\t\t// xy, zy, and zx planes. This could change based on the normal\n\t\t// dotted with each plane normal but I found the orthoginal nature\n\t\t// of this weighting allowed for some more flexibility.\n\t\tvec3 weights = max(abs(normal) - vec3(0.0, 0.4, 0.0), 0.0);\n\t\tweights /= max(max(weights.x, weights.y), weights.z);\n\t\tfloat sharpening = 10.0;\n\t\tweights = pow(weights, vec3(sharpening, sharpening, sharpening));\n\t\tweights /= dot(weights, vec3(1.0, 1.0, 1.0));\n\t\t\n\t\t// We are constructing a set of 5 planes:\n\t\t// 2 are rotated around x, 2 are rotated around y\n\t\t// and the last is the xz plane. these are the only\n\t\t// planes we care about for heightmap terrain\n\t\t// for this example I have chosen to use 45 degrees\n\t\t// as the angle to use, you can match your largest\n\t\t// slope and it will still be gauranteed better than\n\t\t// using normal triplanar mapping.\n\t\tfloat anglep = 3.14159265/4.0;\n\t\t\n\t\t// an angle of zero reverts back to standard triplanar mapping\n\t\t// draw a divider that you can scrub to see the difference\n\t\tif (xy.x < iMouse.x/iResolution.x)\n\t\t{\n\t\t\tanglep *= 0.0;\n\t\t}\n\n\t\t// cache these as we are using a plane reflected around various\n\t\t// axes so these numbers are shared.\n\t\tfloat cosp = cos(anglep);\n\t\tfloat sinp = sin(anglep);\n\t\t\n\t\t// Set up the 3 planar projections that we will be using\n\t\t// first plane is rotated around z compensating for the sign of the normal\n\t\tvec3 p1t = vec3(0.0, 0.0, 1.0);\n\t\tvec3 p1b = vec3(-signs.x * cosp, sinp, 0.0);\n\n\t\t// second plane is just the xz plane\n\t\tvec3 p2t = vec3(0.0, 0.0, 1.0);\n\t\tvec3 p2b = vec3(1.0, 0.0, 0.0);\n\t\t\n\t\t/// third plane is rotated around x also compensating for the sign of the normal\n\t\tvec3 p3t = vec3(1.0, 0.0, 0.0);\n\t\tvec3 p3b = vec3(0.0, sinp, -signs.z * cosp);\n\t\t\n\t\t// Perform the uv projection on to each plane\n\t\tvec2 uvp1 = vec2(dot(pos, p1t), dot(pos, p1b));\n\t\tvec2 uvp2 = vec2(dot(pos, p2t), dot(pos, p2b));\n\t\tvec2 uvp3 = vec2(dot(pos, p3t), dot(pos, p3b));\n\t\t\n\t\t// draw some checkerboard debug pattern\n\t\tfloat p1c = checkerboard(uvp1 * 2.0) * weights.x;\n\t\tfloat p2c = checkerboard(uvp2 * 2.0) * weights.y;\n\t\tfloat p3c = checkerboard(uvp3 * 2.0) * weights.z;\n\t\tvec3 checkCol = vec3(p1c, p2c, p3c);\n\t\t\n\t\t// sample the texture, you can mess around with the assigned texture if you want\n\t\tvec3 texCol = texture( iChannel0, uvp1, 0.0 ).xyz * weights.x +\n\t\t\t  texture( iChannel1, uvp2, 0.0 ).xyz * weights.y +\n\t\t\t  texture( iChannel2, uvp3, 0.0 ).xyz * weights.z;\n\t\t\n\t\t// alternate between the texure and the checkerboard\n\t\tcol = mix(checkCol, texCol, smoothstep(-0.5, 0.5, sin(time * 2.0))); \n\t\t\n\t\t// At this point if you wanted to do normal mapping on top of the tri-planar projection\n\t\t// you just use the plane tangents and bi-normals as the frame, if you want you can re-\n\t\t// othogonize the matrix before using but it looks ok with out that.\n\t\t// vec3 p1bump = p1t * bump.x + p1b * bump.y\n\t\t// ...\n\t\t// normal = normalize(normal + p1bump * weights.x + p2bump * weights.y ... )\n\t}\n\t\n\t// draw the divider\n\tif (abs(xy.x - iMouse.x/iResolution.x) < 0.002)\n\t\tcol = col * 0.5 + vec3(0.5, 0.5, 0.0);\n\t\n\tfragColor=vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsj3z3","date":"1391882761","viewed":1689,"name":"Improved Triplanar Mapping","username":"tux","description":"Illustrates an improved method for triplanar mapping specifically for height maps that reduces stretching by using different planes than xy, zx, and xz.\n\nSee comments for details.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["procedural","triplanar","helpers"],"hasliked":0,"parentid":"","parentname":""}}