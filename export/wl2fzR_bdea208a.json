{"ver":"0.1","info":{"id":"wl2fzR","date":"1598468613","viewed":360,"name":"AWAKE","username":"EDragon","description":"A recreation of an animation from the game MapleStory\nI really liked the effect and wanted to try and see if I can recreate it","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["glitch","neon","maplestory","recreation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define res iResolution.xy\n#define s smoothstep\n#define t iTime\n#define pi 3.1415\n\nmat2 rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat A(vec2 st){\n    float curve = .35;\n    float a = step(st.x+st.y*curve,.0)*step(.0,st.x-st.y*curve)*step(.15,-st.y)*step(-st.y,.75);\n    a *= 1.-step(.15,st.x-st.y*curve)*step(.15,-st.x-st.y*curve)*step(.7,-st.y);\n    a *= 1.-step(.15,st.x-st.y*curve)*step(.15,-st.x-st.y*curve)*step(-.6,st.y);\n    return a;\n}\n\nfloat W(vec2 st){\n    float curve = .35;\n    float w = step(.0,st.x+st.y*curve)*step(st.x-st.y*curve,1.)*step(.15,-st.y)*step(-st.y,.75);\n    w *= 1.-step(.15,st.x+st.y*curve)*step(st.x-st.y*curve,.5);\n    w *= 1.-step(.15+.35,st.x+(st.y)*curve)*step(st.x-st.y*curve,.5+.35);\n    w *= 1.-step(.15+.5,st.x-(st.y)*curve)*step(st.x+st.y*curve,.5-.15);\n    return w;\n}\n\nfloat K(vec2 st){\n    float curve = .75;\n    float k = step(.75,st.x)*step(st.x,1.5)*step(.15,-st.y)*step(-st.y,.75);\n    k *= 1.-step(st.x-st.y*curve,1.15)*step(.875,st.x);\n    k *= 1.-step(-.475,-st.x-st.y*curve)*step(.875,st.x);\n    k *= 1.-step(-st.x+st.y*curve,-1.29)*step(-st.x-st.y*curve,-.615);\n    return k;\n}\n\nfloat E(vec2 st){\n    float e = step(.35,st.x)*step(st.x,.8)*step(.15,-st.y)*step(-st.y,.75);\n    e *= 1.-step(.5,st.x)*step(-st.y,.625)*step(.51,-st.y);\n    e *= 1.-step(.5,st.x)*step(-st.y,.39)*step(.275,-st.y);\n    e *= 1.-step(.75,st.x)*step(-st.y,.6)*step(.3,-st.y);\n    return e;\n}\n//these functions made me feel so samrt yet I probably forgot how they work by now\n\nfloat rand21(vec2 st){\n\tst = fract(st*vec2(231.327,142.753));\n    st += dot(st, st+41.63);\n    return fract(st.x*st.y);\n}\n\nfloat lazer(vec2 st, float r){\n    st.y += 1.;\n    st *= rot(r);\n    st.y -= 1.;\n    float h = 1.-s(st.x,.0,.01)*s(-st.x,.0,.01);\n    return h;\n}\n//sometimes you just gotta h some lazers man\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*res.x)/iResolution.y;\n    vec2 uv3 = uv; //don't want to be affected by sir modified uv later on chief\n    vec2 uv4 = uv;\n    vec2 uv5 = uv;\n    vec3 col = vec3(0.0);\n    uv *= 1.8; //zoom\n    uv.x -= .075; //screen's doing a wack, don't mind it\n    vec2 uv6 = uv;\n    \n    \n    \n    float cap = 643326.1235; //zmart\n    float move = 224.124; //zmarterst\n    \n    float d = 0.; //d\n    \n    uv5 *= uv5.y-2.; //a classic of mine\n    uv5 *= 10.;\n\tuv5 -= vec2(.0,mod(t,500.)*.1); //stars get yeeha-ed overtime so this will keep'em in line\n    vec2 gv = fract(uv5)-vec2(.5,.9);\n    vec2 id = floor(uv5);\n    float n = 1.;\n    \n    for (float y=-n;y<=n;y++){\n        for (float x=-n;x<=n;x++){\n            vec2 off = vec2(x,y);\n            float r1 = rand21(id+off);\n            float r2 = rand21(id+off)*10.-.475;\n            float f = fract(r1*31.912);\n            \n    \t\tgv = fract(uv5)-vec2(.5,-1.);\n\t\t\tuv5 -= vec2(.0,mod(t,500.)*-.5);\n    \t\tid = floor(uv5);\n            \n            d = s(.1,1.,.02/distance(1.*gv-off,.75*vec2(r1*12.421,r2)-vec2(1.,.0)))*mix(1.,.5,r2);\n            col += d;\n        }\n    }\n    \n    float T = mod(t,10.);\n    \n    if (uv.y >= .25*sin(T*cap)-.75){\n    \tuv.x -= .01*sin(T*move+5323453.351);\n    }else if (uv.y <= .25*sin(T*cap)-.75){\n        uv.x += .01*sin(T*move+5321343.351);\n    }\n    \n    \n    vec2 uv2 = uv;\n\n    vec2 ap = vec2(.55+.75,.25);\n    vec2 wp = vec2(.4+.75,.25);\n    vec2 ap2 = vec2(.0,.25);\n    vec2 kp = vec2(.4,.25); //why did I keep it like that...\n    vec2 ep = vec2(-.55,.25);\n    float space = .02; //text space\n    float space2 = .005; //grid lines space\n    \n    uv3 = fract(uv3*3.+space2-vec2(.0,-t));\n    uv4 = fract(uv4*3.-space2-vec2(.0,-t));\n    \n    vec3 grid = vec3(1.-step(uv3.x-.99,2./res.x)*step(uv3.y-.99,1.25/res.y))*.2*vec3(1.,.0,.5);\n    vec3 grid2 = vec3(1.-step(uv4.x-.99,2./res.x)*step(uv4.y-.99,1.25/res.y))*.1*vec3(.0,1.,3.);\n    \n    \n    \n    vec3 bg = vec3(.0,.0,uv.y*.2+.2)*1.25;\n    bg += vec3(-uv.y*.1,.0,-uv.y*.2);\n    \n    col += max(bg,grid+grid2);\n    col += A(uv+vec2(-space+ap.x,ap.y))*vec3(1.,0.,0.5);\n   \tcol += A(uv+vec2(space+ap.x,ap.y))*vec3(0.,1.,1.);\n    \n    \n    col += W(uv+vec2(-space+wp.x,wp.y))*vec3(1.,0.,0.5);\n    col += W(uv+vec2(space+wp.x,wp.y))*vec3(0.,1.,1.);\n    \n    col += A(uv+vec2(-space+ap2.x,ap2.y))*vec3(1.,0.,0.5);\n    col += A(uv+vec2(space+ap2.x,ap2.y))*vec3(0.,1.,1.);\n    \n    col += K(uv+vec2(-space+kp.x,kp.y))*vec3(1.,0.,0.5);\n    col += K(uv2+vec2(space+kp.x,kp.y))*vec3(0.,1.,1.);\n    \n    col += E(uv+vec2(-space+ep.x,ep.y))*vec3(1.,0.,0.5);\n    col += E(uv+vec2(space+ep.x,ep.y))*vec3(0.,1.,1.);\n    \n    float range = .2; //lazer rotation range\n    float del = .5; //movement delay\n    \n    col += vec3(0.,1.,1.)*lazer(uv6-vec2(.3,-1.3),range*sin(t+del*0.)+.6);\n    col += vec3(1.,0.,.25)*lazer(uv6-vec2(.25,-1.3),range*sin(t+del*1.)+.45);\n    col += vec3(0.,1.,.5)*lazer(uv6-vec2(.2,-1.3),range*sin(t+del*2.)+.3);\n    \n    col += vec3(0.,1.,.5)*lazer(uv6-vec2(-.35,-1.3),range*sin(t+del*2.+pi)-.3);\n    col += vec3(1.,0.,.25)*lazer(uv6-vec2(-.4,-1.3),range*sin(t+del*1.+pi)-.45);\n    col += vec3(0.,1.,1.)*lazer(uv6-vec2(-.45,-1.3),range*sin(t+del*0.+pi)-.6);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}