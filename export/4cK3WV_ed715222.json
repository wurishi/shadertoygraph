{"ver":"0.1","info":{"id":"4cK3WV","date":"1713295140","viewed":146,"name":"X-Wing Target Assistant","username":"jbsiraudin","description":"\"Use the force Luke ...\"","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["2d","starwars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Jean-Baptiste Siraudin @2024\n// Some 2D UI animation for good practice, here with a Star Wars famous screen \n// Using https://www.shadertoy.com/view/MXSSzt for numbers printing\n\n// Basic postprocess pass\n// With parts from : https://www.shadertoy.com/view/Ms23DR\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 oricol = texture(iChannel0, vec2(uv.x,uv.y)).xyz;\n    vec3 col;\n\n    col.r = texture(iChannel0,vec2(uv.x+0.001,uv.y+0.000)).x+0.05;\n    col.g = texture(iChannel0,vec2(uv.x+0.000,uv.y-0.001)).y+0.05;\n    col.b = texture(iChannel0,vec2(uv.x-0.001,uv.y+0.000)).z+0.05;\n\n    col = clamp(col*0.6+0.4*col*col*1.0,0.05,1.0);\n    col *= 1.6*vec3(0.95,1.05,0.95);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ----------------------------\n// SOME CONSTANTS AND MACROS\n// ----------------------------\n// Some classics:\n#define degToRad 0.01745\n#define PI 3.14159265359\n\n// Base value for Stroke Width\n#define sW 0.001\n\n// pixelWidth, used for antialiasing drawing\n#define pW 1.0/iResolution.y\n\n// -- Antialiased drawing functions --\n// Takes an sdf and fill it or trace a stroke on it\n// N weights the \"blur\" on the edges = it's our antialiasing technique here\n// N may vary according to what looks best for each sdf! (but it's mostly 4.)\n#define N 4.\n#define fill(sdf) smoothstep(N*pW, 0., sdf)\n#define stroke(sdf, e) smoothstep(N*pW, 0., abs(sdf)-e*sW)\n#define strokeN(a, sdf, e) smoothstep(a*pW, 0., abs(sdf)-e*sW)\n\n// An aliased version of fill for masking, the edges are meant to be covered by a stroke!\n#define mask(sdf) step(0., -sdf)\n\n#define union(sdf1, sdf2) min(sdf1, sdf2)\n#define substract(sdf1, sdf2) max(-sdf1, sdf2)\n#define intersection(sdf1, sdf2) max(sdf1, sdf2)\n\n// -- Coordinates manipulation --\n#define mirror(p) vec2(abs(p.x), p.y)\n#define d_mirror(p) vec2(abs(p.x), -abs(p.y))\n\n#define rotate(p, t) vec2(cos(t)*p.x-sin(t)*p.y, sin(t)*p.x+cos(t)*p.y)\n#define square(x) x*x\n\n#define sc(x) vec2(cos(x), sin(x))\n\n\n// ----------------------------\n// ---------SDF SHAPES---------\n// ----------------------------\n\n\n// BOX - CARTESIAN COORDINATES\n// a, b (corners of the box), r (rounding radius)\nfloat sdBox(in vec2 p, in vec2 b, in float r)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n// SECTOR - CARTESIAN COORDINATES\n// A whole sector of the screen defined by the line passing through 2 points\n// p (coord of the point), a & b (the two points defining the line)\nfloat sdSector(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 bp = b-p, ba = b-a;\n    return dot(vec2(-ba.y, ba.x), b-p);\n}\n\nfloat sdVerticalLine(in vec2 p, in float x)\n{\n    return abs(p.x - x);\n}\n\nfloat sdHorizontalLine(in vec2 p, in float y)\n{\n    return abs(p.y - y);\n}\n\n// SEGMENT - CARTESIAN COORDINATES\n// Segment defined by two point\n// p (coord of the point), a & b (the two points defining the segment)\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n\n// CIRCLE - CARTESIAN COORDINATES\n// Can be centered anywhere on the screen\n// p (coord of the point), center (coord of the center of the circle), r (desired radius of the circle)\nfloat sdCircle(in vec2 p, in vec2 center, in float r)\n{\n    return length(p-center)-r;\n}\n\n\n// ARC - CARTESIAN COORDINATES\nfloat sdArc( in vec2 p, in float angle, in float ra, in float rb)\n{\n    // sc is the sin/cos of the arc's aperture\n    vec2 sc = vec2(sin(angle), cos(angle));\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Various code pieces come from iq's 2D sdf library, aka the Bible:\n// https://iquilezles.org/articles/distfunctions2d\n\n// 240/255 = the grey of the player bar in shadertoy\nconst float grey = 0.94117647058;\n\n// ----------------------------\n// SOME CONSTANTS AND MACROS\n// ----------------------------\n// Some classics:\n#define degToRad 0.01745\n#define PI 3.14159265359\nconst float fifteen = degToRad*15.;\nconst float ten = degToRad*20.;\nconst float fourty = degToRad*40.;\nconst float sixty = degToRad*60.;\n\n\n// ----------------------------\n// ---------SDF NUMBERS--------\n// ----------------------------\n\nfloat n0(in vec2 p, in float scale, in float w)\n{\n    float angle = degToRad*mix(80., 85., scale);\n    float a = sdArc(vec2(p.x, abs(p.y)), angle, scale, w*scale*sW);\n    return fill(a);\n}\n\nfloat n1(in vec2 p, in float scale, in float w)\n{\n    float a = sdSegment(p, scale*vec2(0.15, 1.), scale*vec2(0.15, -1.));\n    float b = sdSegment(p, scale*vec2(0.15, 1.), scale*vec2(-0.25, 0.6));\n    return stroke(union(a, b), w*scale);\n}\n\nfloat n2(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(8., 5., scale);\n    float angle = degToRad*45.;\n    float angle2 = degToRad*135./2.;\n    \n    float r = 0.55;\n    vec2 p1 = r*sc(PI/2.-2.*angle2);\n    \n    float a = sdArc(rotate((p - scale*vec2(0., 1.-r)), -angle - varAngle), angle - varAngle, r*scale, w*scale*sW);\n    float b = sdArc(rotate((p - scale*vec2(0., 1.-r)), angle2 + varAngle), angle2 - varAngle, r*scale, w*scale*sW);\n    \n    float c = sdSegment(p, scale*(vec2(-r,-1.)+mix(0.3, 0.2, scale)*vec2(1.)), scale*(p1+vec2(0., 1.-r)));\n    float d = sdSegment(p, scale*vec2(-r, -1.), scale*vec2(r, -1.));\n    \n    float sd = union(a, union(b, abs(c)-w*scale*sW));\n    \n    return fill(sd)+stroke(d, w*scale); \n}\n\nfloat n3(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(8., 5., scale);\n    float angle = degToRad*90.;\n    float angle2 = degToRad*45.;\n    \n    float r = 0.5;\n    vec2 p_ = vec2(p.x, abs(p.y)) - scale*vec2(0., 1.-r);\n    \n    float a = sdArc(rotate(p_, -varAngle), angle - varAngle, r*scale, w*scale*sW);\n    float b = sdArc(rotate(p_, 3.*angle2 + varAngle), angle2 - varAngle, r*scale, w*scale*sW);\n    \n    return fill(union(a, b));\n}\n\nfloat n4(in vec2 p, in float scale, in float w)\n{\n    float r = 0.65;\n    float r2 = 0.4;\n    vec2 p1 = scale*vec2(-r, -0.5);\n    float a = sdSegment(p, p1, vec2(abs(p1.x), p1.y));\n    float b = sdSegment(p, p1 + scale*mix(0.3, 0.2, scale)*vec2(1.), scale*vec2(r2, 0.9));\n    float c = sdSegment(p, scale*vec2(r2, -1.), scale*vec2(r2, 0.9 - mix(0.5, 0.35, scale)));\n    \n    return stroke(union(b, union(a, c)), w*scale);\n}\n\nfloat n5(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(8., 5., scale);\n    float angle = degToRad*36.;\n    float angle2 = degToRad*225./2.;\n    \n    float r = 0.65;\n    float r2 = 0.35;\n    vec2 p1 = -vec2(0., 1.-r) + r*sc(degToRad*135.);\n    vec2 p2 = vec2(-r2, 1.);\n    \n    float a = sdArc(rotate((p + scale*vec2(0., 1.-r)), -degToRad*145. + varAngle), angle - varAngle, r*scale, w*scale*sW);\n    float b = sdArc(rotate((p + scale*vec2(0., 1.-r)), angle2 - degToRad*45. - varAngle), angle2 - varAngle, r*scale, w*scale*sW);\n    \n    float c = sdSegment(p, scale*p1, scale*p1 + scale*(p2-p1)*mix(0.6, 0.75, scale));\n    float d = sdSegment(p, scale*p2, scale*mirror(p2));\n    \n    float sd = union(a, union(b, abs(c)-w*scale*sW));\n    \n    return fill(sd)+stroke(d, w*scale);\n}\n\n\nfloat n6(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(8., 5., scale);\n    float angle = degToRad*90.;\n    float angle2 = degToRad*60.;\n    \n    float r = 0.65;\n    vec2 p1 = -vec2(0., 1.-r) + r*sc(degToRad*150.);\n    \n    float a = sdArc(rotate((p + scale*vec2(0., 1.-r)), degToRad*90. - varAngle), angle - varAngle, r*scale, w*scale*sW);\n    float b = sdArc(rotate((p + scale*vec2(0., 1.-r)), degToRad*180. + angle2 + varAngle), angle2 - varAngle, r*scale, w*scale*sW);\n    float c = sdSegment(p, scale*p1, scale*(p1+1.22*sc(degToRad*60.)));\n    \n    float sd = union(b, abs(c)-w*scale*sW);\n    \n    return fill(a) + fill(sd);\n}\n\nfloat n7(in vec2 p, in float scale, in float w)\n{\n    float r = 0.6;\n    float r2 = 0.45;\n    vec2 p1 = scale*vec2(-r, 1.);\n    \n    float a = sdSegment(p, scale*vec2(-r, 1.), scale*vec2(r, 1.));\n    float b = sdSegment(p, scale*vec2(-r2, -1.), scale*vec2(r2, 0.9 - mix(0.3, 0.2, scale)));\n    \n    return stroke(union(b, a), w*scale);\n}\n\nfloat n8(in vec2 p, in float scale, in float w)\n{\n    float varAngle = degToRad*mix(20., 10., scale);\n    float angle = degToRad*180.;\n    \n    float r = 0.5;\n    vec2 p_ = vec2(p.x, abs(p.y)) - scale*vec2(0., 1.-r);\n    float a = sdArc(rotate(p_, angle), angle - varAngle, r*scale, w*scale*sW);\n    \n    return fill(a);\n}\n\nfloat n9(in vec2 p, in float scale, in float w)\n{\n    return n6(-p, scale, w);\n}\n\nfloat digit(in vec2 p, in int n, in float scale, in float w)\n{\n    //for debugging spacing\n    //float r = stroke(sdCircle(p, vec2(0.), scale), 2.);\n    float r=0.;\n    if(n == 0)\n\t{\n\t\treturn r+n0(p, scale, w);\n\t}\n\tif(n == 1)\n\t{\n\t\treturn r+n1(p, scale, w);\n\t}\n\tif(n == 2)\n\t{\n\t\treturn r+n2(p, scale, w);\n\t}\n\tif(n == 3)\n\t{\n\t\treturn r+n3(p, scale, w);\n\t}\n\tif(n == 4)\n\t{\n\t\treturn r+n4(p, scale, w);\n\t}\n\tif(n == 5)\n\t{\n\t\treturn r+n5(p, scale, w);\n\t}\n\tif(n == 6)\n\t{\n\t\treturn r+n6(p, scale, w);\n\t}\n\tif(n == 7)\n\t{\n\t\treturn r+n7(p, scale, w);\n\t}\n\tif(n == 8)\n\t{\n\t\treturn r+n8(p, scale, w);\n\t}\n\tif(n == 9)\n\t{\n\t\treturn r+n9(p, scale, w);\n\t}\n\n\treturn 0.;\n}\n\n//Length of a number in digits from https://www.shadertoy.com/view/4dc3zr\nint numberLength(float n)\n{\n\treturn int(ceil(max(log(n) / log(10.0), 0.0)));\n}\n\nfloat number(in vec2 p, in float n, in int minChar, in float scale, in float w)\n{\n    float r = 0.;\n\tint l = numberLength(n);\n    float it = pow(10., -float(minChar));\n    \n\tfor(int i = minChar; i >= 0; i--)\n\t{\n\t\tint d = int(floor(mod(n * it,10.)));\n\t\t\n        if (i >= l)\n        {\n            d = 0;\n        }\n        \n        \n        if(n > it || i == 0 || i >= l)\n\t\t{\n            vec2 pos = p - 2.3*scale*vec2(minChar-i,0);\n\t\t\tr += digit(pos, d, scale, w);\n\t\t}\n        \n        it *= 10.;\n\t}\n    \n    return r;\n}\n\n// -------------------------\n// --------2D SCENE---------\n// -------------------------\nconst vec2 corner = vec2(1.2, 0.7);\n\nfloat scene(vec2 p)\n{\n    vec2 p_mirror = vec2(abs(p.x), abs(p.y - 0.15));\n    float a = 0.;\n    \n    vec2 p1 = vec2(1.75, 2.1);\n    vec2 p2 = vec2(1.75, 1.25);\n    vec2 p3 = vec2(1.75, 0.4);\n\n    // 2d rays from the center \n    a += stroke(sdSegment(p_mirror, vec2(0.), p1), 4.*length(p_mirror));\n    a += stroke(sdSegment(p_mirror, vec2(0.), p2), 4.*length(p_mirror));\n    a += stroke(sdSegment(p_mirror, vec2(0.), p3), 4.*length(p_mirror));\n    \n    // tunnel lines\n    float remap_y = pow(p_mirror.y * 167., 0.34);\n    float remap_x = pow(p_mirror.x * 200., 0.34);\n    float timeshift = -3.*iTime;\n    \n    float sdf_y = sdHorizontalLine(vec2(p_mirror.x, fract(timeshift + remap_y)), 0.5);\n    float sdf_x = sdVerticalLine(vec2(fract(timeshift + remap_x), p_mirror.y), 0.5);\n    \n    float sdf_y_mask = sdSector(vec2(p_mirror.x, -(p.y - 0.15)), vec2(0.), p1);\n    float sdf_x_mask = sdSector(p_mirror, p1, vec2(0.));\n    a += strokeN(6.*pow(10., 1./remap_y), sdf_y, 10. * pow(10., 1./remap_y)) * mask(sdf_y_mask);\n    a += strokeN(6.*pow(10., 1./remap_x), sdf_x, 10. * pow(10., 1./remap_x)) * mask(sdf_x_mask);    \n    \n    // round box for tunnel\n    float ui_box_sdf = sdBox(p_mirror, corner, 0.1);\n    a *= mask(ui_box_sdf);\n    a += stroke(ui_box_sdf, 5.);\n    \n    // box for text\n    a += stroke(sdBox(vec2(p.x, abs(p.y + 1.)), vec2(0.6, 0.18), 0.1), 5.);\n    \n    return a;\n}\n\nfloat sceneBg(vec2 p, in float t)\n{\n    vec2 p_mirror = vec2(abs(p.x), abs(p.y - 0.15));\n    \n    float sd = sdVerticalLine(p_mirror, mix(corner.x, 0., 1.-t));\n    float a = stroke(sd, 10.);\n    \n    float ui_box_sdf = sdBox(p_mirror, corner, 0.1);\n    a *= mask(ui_box_sdf);\n    \n    return a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    // Normalized coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n   \n\t// Scene\n    float t = 100000. - iTime * 1000.;\n    float a = scene(p);\n    float b = sceneBg(p, t/100000.);\n\n\t// Numbers\n    float n = number(p + vec2(0.5, 0.87), t, 5, 0.09, .03*iResolution.x);\n    \n    // COMP\n    a = clamp(a, 0., 1.);\n    b = clamp(b, 0., 1.);\n\tvec3 col = mix(vec3(0.), vec3(120./255., 5./255., 5./255.), b);\n    col = mix(col, vec3(255./255., 80./255., 10./255.), a);\n    col = mix(col, vec3(120./255., 5./255., 5./255.), n);\n    \n\tfragColor = vec4(sqrt(col), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}