{"ver":"0.1","info":{"id":"4lBXzm","date":"1444074587","viewed":180,"name":"raytrace_bk","username":"d1kkop","description":"raytrace_bk","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracebk"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n#define BG vec3(0,0,0);\n#define AA 4\n#define AMBIENT 0.0015\n#define REFLECT_COUNT 5\n#define REFRACT\n#define time iTime\n#define EPS 0.001\n\n\n// Struct definitions\nstruct Camera\n{\n    vec3 pos;\n    vec3 dir;\n    float fov;\n    float zoom; // derived\n    mat3 view; // derived\n};\n    \n        \nstruct Material\n{\n    vec3 color;\n    float shine;\n    float refl;\n    float refr;\n};\t\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n    Material mat;\n};\n    \n\nstruct Light\n{\n    vec4 ori_dir;\n    vec3 color;\n};\n    \n\n// Init of structures\nCamera cam = Camera(\n    vec3(0.0, 2.0, -7.0),\n    vec3(0.0, -1.0, 2.0),\n    45.0,\n    0.0, // zoom\n    mat3(vec3(0), vec3(0), vec3(0)) // view\n);  \n    \n\nLight light = Light( \n    vec4(0.0, 20.0, -10.0, 1.0),          \n    vec3(1.0, 1.0, 1.0) \t\n);\n\n\nSphere spheres[30];\nconst int c_numSpheres = 20;\n\nvoid initSpheres()\n{\n    float dAng = 360.0 / float(c_numSpheres);\n    float r = 5.0;\n    for (int i = 0; i < c_numSpheres; i++)\n    {\n        float ang = float(i)*dAng;\n        float rad = radians(ang);\n        float x = cos(rad)*r;\n        float z = sin(rad)*r;\n        spheres[i] = Sphere(vec3(x, 0.0, z), \n                            0.6 /*0.5*(cos(ang)+1.0)*0.6+0.3*/,  \t\t\n                            Material(vec3(0.1 + 0.5*(cos(ang)+1.0)+0.3,\n                                          0.1 + 0.5*(cos(ang*4.0+1.2)+1.0)+0.3, \n                                          0.1 + 0.5*(sin(ang*4.0+1.2)+1.0)+0.1), \n                                     \t(sin(ang*3.0)+1.0)*800.0+3.0,\n                                     \t0.5,\n                                      \t1.0));\n    }\n}\n\n\nfloat zoomForFov(float fovDeg)\n{\n    return 1.0 / tan(radians(0.5 * fovDeg));\n}\n\n\nvoid rotateLight()\n{\n    float r = 40.0;\n    float rotspeed = time * 1.0;\n    float x = cos(rotspeed) * r;\n    float z = sin(rotspeed) * r;\n    light.ori_dir = vec4(x, 30.0, z, 1.0);\n}\n\n\n/*\nvoid traceHeight(vec3 ro, vec3 rd, vec2 map)\n{\n    vec2 as = vec2(ro.x, ro.z);\n    vec2 bs = vec2(rd.x, ro.z);\n    float dx = bs.x - as.x;\n    float dy = bs.y - as.y;\n    float det = bd.x * ad.y - bd.y * ad.x;\n    u = (dy * bd.x - dx * bd.y) / det;\n    v = (dy * ad.x - dx * ad.y) / det;\n}*/\n\n\nfloat sphereRayIntersect(vec3 sc, float sr, vec3 ro, vec3 rd)\n{\n    vec3 e = sc - ro;\n    float a = dot(e, rd);\n    if (a < 0.0)\n        return -1.0; // possible intersect is in opposite dir of ray\n    float e2 = dot(e, e);\n    float r2 = sr*sr;\n    float arg = r2 - e2 + a*a;\n    if (arg < 0.0)\n        return -1.0; // miss\n    if (e2 <= r2)\n        return -1.0; // origin on or inside\n    return a - sqrt(arg); // return dist to intersect\n}\n\n\nvec3 computeShading( vec3 hit, vec3 normal, Material m, Light l )\n{\n    vec3 ldir;\n    if (l.ori_dir.w > 0.5)\n    \tldir = normalize( l.ori_dir.xyz - hit );\n    else\n        ldir = normalize(-l.ori_dir.xyz);\n    \n    float diff = max( 0.0, dot(ldir, normal) );\n    vec3 hdir = normalize( ldir - cam.dir );\n    float spec = pow( max(0.0, dot(hdir, normal)), m.shine );\n    \n    return  diff * (m.color * l.color) +\n        \tspec * l.color +\n        \tAMBIENT * m.color;\n  //  return (diff + AMBIENT) * m.color * l.color + spec * l.color;\n}\n\n\nbool traceScene2( vec3 ro, vec3 rd, out vec3 hit, out vec3 normal, out vec3 col, inout float refl, out float refr )\n{\n    bool bhit = false;\n    float dist = 100000.0;\n    Sphere closest;\n    \n    // test spheres\n    for (int i = 0; i < c_numSpheres; i++)\n    {\n        Sphere s = spheres[i];\n        float distSphere = sphereRayIntersect( s.origin, s.radius, ro, rd );\n        if ( distSphere >= 0.0 && distSphere < dist )\n        {\n            dist = distSphere;\n            closest = spheres[i];\n            bhit = true;\n        }\n    }\n\n    if ( bhit )\n    {\n        hit = ro+rd*dist;\n        normal = normalize( hit - closest.origin );\n        col += computeShading( hit, normal, closest.mat, light ) * refl;\n        refl = closest.mat.refl;\n        refr = closest.mat.refr;\n    }\n    \n    return bhit;\n}\n\nvoid traceReflections( vec3 ro, vec3 rd, vec3 hit, vec3 normal, inout vec3 col, float refl, float refr )\n{\n    for (int i=0; i<REFLECT_COUNT; i++)\n    {\n        rd = reflect( rd, normal );\n        ro = hit+rd*EPS;\n        traceScene2( ro, rd, hit, normal, col, refl, refr);\n    }   \n}\n\nvoid traceRefractions( vec3 ro, vec3 rd, vec3 hit, vec3 normal, inout vec3 col, float refl, float refr )\n{\n    rd = refract( rd, normal, refr );\n    ro = hit+rd*EPS;\n    traceScene2( ro, rd, hit, normal, col, refl, refr );  \n}\n\nvec3 traceScene( vec3 ro, vec3 rd )\n{\n    float eps = 0.0001;\n    vec3 col = vec3(0);\n    float refl = 1.0;\n    float refr, trans;\n    vec3 hit, normal;\n\n    if ( traceScene2( ro, rd, hit, normal, col, refl, refr ) ) \n    {\n        traceReflections( ro, rd, hit, normal, col, refl, refr );\n        #ifdef REFRACT\n        traceRefractions( ro, rd, hit, normal, col, refl, refr );\n        #endif\n    }\n    \n    return col;\n}\n\nvec3 constructRay( vec2 ras )\n{\n    vec3 ray = vec3( ras, cam.zoom );\n    ray = normalize( ray );\n    return cam.view * ray;\n}\n\n\nvec3 traceSceneAA( vec2 ras, float asp )\n{\n    vec3 finalColor = BG;\n    ras = 2.0*ras - 1.0;\n    ras.x *= asp;\n    vec2 aa = vec2(2.0*asp, 2.0) / (iResolution.xy * float(AA));\n    ras += aa*0.5;\n    vec2 sub = ras;\n    for (int y = 0; y < AA; y++)\n    {\n        sub.x = ras.x;\n        for (int x = 0; x < AA; x++)\n        {\n            vec3 rd = constructRay( sub );\n            finalColor += traceScene( cam.pos, rd );\n            sub.x += aa.x;\n        }\n        sub.y += aa.y;\n    }\n    float denom = float(AA);\n    denom = 1.0 / (denom*denom);\n    return finalColor * denom;\n}\n\n\nmat3 lookatMatrix(vec3 forward)\n{\n    forward = normalize(forward);\n    vec3 right = normalize( cross( vec3(0.0, 1.0, 0.0), forward ));\n    vec3 up = normalize(cross(forward, right));\n    mat3 lookat = mat3(right, up, forward);\n    return lookat;\n}\n\n\nvoid updateCam()\n{\n    float spd = 0.076*time;\n    float hspd = 0.1*time;\n    float r=10.0;\n    float x=cos(spd)*r;\n    float z=sin(spd)*r;\n    float y=3.0;//cos(hspd)*2.0+3.0;\n    vec3 mid=vec3(0.0, 0.0, 0.0);\n    cam.pos = vec3(x,y,z);\n    vec3 dir= normalize (mid - cam.pos);\n    \n    \n    cam.zoom = zoomForFov( cam.fov );\n    cam.dir = normalize( dir );\n    cam.view = lookatMatrix( cam.dir );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initSpheres();\n   // rotateLight();\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float asp = iResolution.x / iResolution.y;\n    \n    updateCam();\n    vec3 col = traceSceneAA( uv, asp );\n    \n    col = pow(col, vec3(0.79));\n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"","description":"","type":"image"}]}