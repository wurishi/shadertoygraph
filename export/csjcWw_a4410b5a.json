{"ver":"0.1","info":{"id":"csjcWw","date":"1687815019","viewed":115,"name":"blort666","username":"manthrax","description":"planet","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec4 calcHalo(float dist, float radius){\n    float edist=dist+(radius*.5);\n    return vec4(haloColor,\n        smoothstep(0.,radius,edist)*smoothstep(radius,0.,edist)*5.);\n}\n\n\nvec3 planetColor(vec3 spherePt){\n    vec3 col=vec3(0.);\n    col = (spherePt+1.)*.5;\n    \n    \n    float continent=simplex3d_fractal(spherePt*1.);\n    continent+=simplex3d_fractal(spherePt*10.)*.2;\n    continent+=simplex3d_fractal(spherePt*100.)*.04;\n    \n    float height = continent;\n    float poles=smoothstep(.4,.5,pow(abs(spherePt.y),3.));\n    continent += poles*.1;\n    \n    continent = smoothstep(.0,.05,continent);\n    //continent = continent / .2;\n    \n    float terrain=simplex3d(spherePt*10.);\n    \n    \n    float equator = pow(abs(spherePt.y),2.);\n    vec3 terrainColor = mix(equatorColor,groundColor,equator);\n    \n    \n    col = mix(oceanColor,terrainColor,continent);\n    \n    col = mix(col,poleColor, smoothstep(.5,.95,abs(spherePt.y)*4.1)*height);\n\n\n    col+=simplex3d_fractal(vec3(spherePt*vec3(1.,3,1.))); //Clouds\n    \n    return col;\n}\n\nvec3 tcross(vec2 cuv){\n    vec2 coord = floor(cuv*4.);\n    vec2 side = fract(cuv*4.);\n    vec3 p=vec3(side-.5,.5);\n    vec3 planet=vec3(0.);\n    if(coord==vec2(1.,2.)){//top\n        planet=vec3(p.x,p.z,p.y);\n    \n    }else if(coord==vec2(1.,1.)){//front\n        planet=vec3(p.x,p.y,-p.z);\n    } \n    if(coord==vec2(1.,0.)){//bottom\n        planet=vec3(p.x,-p.z,-p.y);\n    }\n    else if(coord==vec2(0.,1.)){//left\n        planet=vec3(-p.z, p.y,-p.x);\n    }else if(coord==vec2(2.,1.)){//right\n        planet=vec3( p.z, p.y, p.x);\n    }else if(coord==vec2(3.,1.)){//back\n        planet=vec3(-p.x,p.y, p.z);\n    }\n    return normalize(planet);\n}\n\nvec4 getVar(int id){\n    return texelFetch(iChannel0,ivec2(0,id),0);\n}\n\n\nvoid uiDraw(int vidx,inout vec3 color, vec2 fragCoord ){\n    //vec4 va,vb,vc,vd;\n    //getVars(iChannel0, va,vb,vc,vd);\n\n    vec2 cellf=fragCoord.xy*celldim/iResolution.xy;\n    cellf.y=celldim.y-cellf.y;\n    vec2 cell = floor(cellf);\n    vec2 cuv=fract(cellf);\n    vec4 var = getVar(vidx);//va;\n    float cstep = step(cuv.x,var.x);\n    cell.y-=float(vidx*4);\n    \n    if(cell==vec2(0,0)){\n        color+=vec3(step(cuv.x,var.x),0.,0.);\n    }else if(cell==vec2(0,1)){\n        color+=vec3(0.,step(cuv.x,var.y),0.);\n    }else if(cell==vec2(0,2)){\n        color+=vec3(0.,0.,step(cuv.x,var.z));\n    }else if(cell==vec2(0,3)){\n        color+=mix(var.rgb,vec3(step(cuv.x,var.w*.25)),step(var.w,cuv.x));\n    }\n    if(cell.x==0.){\n        vec2 sd = abs((cuv.xy-.5)*2.);\n        if(max(sd.x,sd.y)>.9)\n            color = vec3(1.);\n\n    }\n}\n\nvoid adjustColor(inout vec3 color,int vidx){\n    vec4 va = getVar(vidx);\n    color = mix(color,va.rgb,va.a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    adjustColor(haloColor,0);\n    adjustColor(ambientColor,1);\n    adjustColor(oceanColor,2);\n    adjustColor(groundColor,3);\n    adjustColor(poleColor,4);\n    adjustColor(equatorColor,5);\n    vec4 var = getVar(6);\n    planetRad += var.x;\n    haze += var.y;\n//vec3  haloColor =    vec3(.6,.8,.99);\n//vec3  ambientColor = vec3(.2,.2,.2);\n//vec3  oceanColor =   vec3(.3,.3,.7);\n//vec3  groundColor =  vec3(.4,.7,.2);\n//vec3  poleColor =    vec3(.8,.8,.9);\n//vec3  equatorColor = vec3(.7,.6,.3);\n//float planetRad = .4;\n//float haze = .2;\n    \nvec4 clickInfo = getVar(16);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*.01;\n\n\n    vec2 st = (var.yz-.5)*PI*2.;//(iTime*.1)+(iMouse.x*.02);\n    vec3 sunDir = normalize(vec3(sin(st.x*.73),cos(st.y*.3),-cos(sqrt(length(st)))));//);\n    vec3 sunPos = sunDir*-200.;\n\n    float aspect = iResolution.x/iResolution.y;\n\n    vec2 camUv = vec2(((uv.x-.5)*aspect),uv.y-.5);\n\n    camUv*=1.+var.w;//(((iMouse.y/iResolution.y)-.5)*.9);\n\n    float rdist = length(camUv);\n\n\n    vec4 halo = calcHalo(rdist-planetRad,planetRad*.3);\n\n    col.rgb=stars(fragCoord,iResolution,iTime).rgb;\n\n    col.rgb = mix(col.rgb,halo.rgb,halo.a);\n\n\n    if(rdist<planetRad){\n        mat4 spin = rotationMatrix(vec3(0.,1.,0.), iTime*.2);\n    \n        vec2 pt = camUv/planetRad;\n        float squaredLength = dot(pt, pt);\n        float z = sqrt(1.0 - squaredLength);\n        vec3 spherePt = (squaredLength > 1.0) ?\n            vec3(0.0, 1.0, z) : vec3(pt,-z);\n\n        vec3 planetNormal = (vec4(spherePt,0.)*spin).xyz;\n        col.rgb = planetColor(planetNormal);\n\n\n        float lightDot=clamp(dot(sunDir,spherePt),0.,1.);\n\n        col.rgb*=lightDot;\n\n        //col.rgb+=ambientColor;\n\n        float haloTint = smoothstep(-1.,1.,lightDot) * haze;\n\n        vec3 haloC = clamp(haloColor.rgb*smoothstep(.8,.999,1.-spherePt.z),0.,1.);\n\n        col.rgb = mix(col.rgb,haloC,haloTint);//(haloColor.rgb*lightDot);\n\n        col.rgb += (haloColor.rgb*(1.+spherePt.z))*clamp((lightDot*.5)+.5,0.,1.);\n\n    }\n\n\n    //Draw cursor\n    col += vec3(0.,0.,1.)*clamp(4.-length(iMouse.xy-fragCoord),0.,1.);\n\n\n    // Output to screen\n\n    vec2 tcuv = vec2(uv.x*aspect,uv.y)*2.5;\n    if(tcuv.y<1.){\n        if(tcuv.x<1.){\n            col.rgb = vec3(1.);\n            vec3 planet=tcross(tcuv);\n            col.rgb=planetColor(planet);//(planet+1.)*.5;\n        }else if(tcuv.x<2.){\n\n            vec2 tc=fract(tcuv);\n            col.rgb=planetColor(uvToSphereNormal(tc));\n        }else if(tcuv.x<3.){\n            //col.rgb = vars.xyz;\n        }\n    }else{\n    }\n\n\n    fragColor = vec4(col,1.0);\n    int row = int(celldim.y-(fragCoord.y*celldim.y/iResolution.y))/4;\n    if(row<7)\n        uiDraw(row,fragColor.rgb,fragCoord);\n        \n    //fragColor.rgb=vec3(iMouse.w);\n    \n    \nvec2 ccell = floor(texelFetch(iChannel0,ivec2(1,1),0).xy*celldim);\nif(ccell==floor(uv * celldim).xy)\n    fragColor.rgb += vec3(.2);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nvec2 celldim=vec2(6.,128.);\n\n\nvec3  haloColor =    vec3(.6,.8,.99);\nvec3  ambientColor = vec3(.2,.2,.2);\nvec3  oceanColor =   vec3(.3,.3,.7);\nvec3  groundColor =  vec3(.4,.7,.2);\nvec3  poleColor =    vec3(.8,.8,.9);\nvec3  equatorColor = vec3(.7,.6,.3);\nfloat planetRad = .4;\nfloat haze = .2;\n\n\nivec2  tvMouse=ivec2(1,1);\n\n\n\n\n/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright Â© 2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/* const matrices for 3d rotation */\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\n/* directional artifacts can be reduced by rotating each octave */\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\n\n\n\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n\n//from flickering stars by turanzkij\n// 3D Gradient noise from: https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nconst float PI = 3.1415926;\nvec4 stars( in vec2 fragCoord, vec3 iResolution, float iTime )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Stars computation:\n    vec3 stars_direction = normalize(vec3(uv * 2.0f - 1.0f, 1.0f)); // could be view vector for example\n\tfloat stars_threshold = 8.0f; // modifies the number of stars that are visible\n\tfloat stars_exposure = 200.0f; // modifies the overall strength of the stars\n\tfloat stars = pow(clamp(noise(stars_direction * 200.0f), 0.0f, 1.0f), stars_threshold) * stars_exposure;\n\tstars *= mix(0.4, 1.4, noise(stars_direction * 100.0f + vec3(iTime))); // time based flickering\n\t\n    // Output to screen\n    return vec4(vec3(stars),1.0);\n}\n\n//gpt3.5\nvec3 uvToSphereNormal(vec2 uv)\n{\n    // Convert UV coordinates to latitude and longitude angles\n    float latitude = (uv.y - 0.5) * 180.0;\n    float longitude = (uv.x - 0.5) * 360.0;\n\n    // Convert angles to radians\n    float latitudeRad = radians(latitude);\n    float longitudeRad = radians(longitude);\n\n    // Calculate 3D coordinates on the unit sphere\n    float x = cos(latitudeRad) * cos(longitudeRad);\n    float y = sin(latitudeRad);\n    float z = cos(latitudeRad) * sin(longitudeRad);\n\n    // Create and normalize the normal vector\n    vec3 normal = normalize(vec3(x, y, z));\n\n    return normal;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 clickedCell(){\n    return texelFetch(iChannel0,ivec2(1,1),0).xy*celldim/iResolution.xy;\n}\n\nvec2 mouseCell(){\n    vec2 cellf=iMouse.xy*celldim/iResolution.xy;\n    cellf.y=celldim.y-cellf.y;\n    return cellf;\n}\n\n\nvoid rgbaSlider(inout vec4 var,int vidx){\n    vec2 cellf = mouseCell();\n    vec2 cell = floor(cellf);\n    vec2 cuv=fract(cellf);\n    cell.y-=float(vidx*4);\n    if(cell==vec2(0,0))     var.x=cuv.x;\n    else if(cell==vec2(0,1))var.y=cuv.x;\n    else if(cell==vec2(0,2))var.z=cuv.x;\n    else if(cell==vec2(0,3))var.w=cuv.x;\n}\n\nvec4 cellVar(ivec2 ci){\n    return texelFetch(iChannel0,ci,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 texelPos = ivec2(fragCoord);//Get the vertical pixel index as variable id    \n    vec4 var = cellVar(texelPos);    //read the variable at vidx\n    if(texelPos.x==0){//If left most row of pixels \n        vec2 clickCell = floor(cellVar(tvMouse).xy*celldim);\n        vec2 mouseCell = floor(fragCoord*celldim/iResolution.xy);\n        //if(clickCell == mouseCell)\n        {\n            rgbaSlider(var,texelPos.y); //If the mouse is manipulating this var.. do it\n        }\n    }\n    if(texelPos==ivec2(1,1)){\n        if(iMouse.w>0.){\n            //Mouse clicked.. write clicked mouse to cell 1,1\n            var.xy = iMouse.xy/iResolution.xy;//floor(iMouse.xy*celldim/iResolution.xy);\n        }\n    }\n    fragColor = var;         //Write it back...\n}","name":"Buffer A","description":"","type":"buffer"}]}